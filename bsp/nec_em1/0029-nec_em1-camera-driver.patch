From dfe2a8273de3b202168f0af1937934f3f254c2cc Mon Sep 17 00:00:00 2001
From: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
Date: Mon, 9 Nov 2009 15:18:44 +0900
Subject: [PATCH 29/29] nec_em1: camera driver

This driver controls camera I/F of EM1 and RJ6ABA100.
RJ6ABA100 is an optional camera module board.
This module is offered by the form built into V4L2.

Signed-off-by: Kazuya Tsukamoto <kazuya.tsukamoto@necel.com>
---
 arch/arm/mach-mp200/include/mach/mp200_cam.h |   70 +
 drivers/media/video/Kconfig                  |    2 +
 drivers/media/video/Makefile                 |    2 +
 drivers/media/video/mp200_cam/Kconfig        |    6 +
 drivers/media/video/mp200_cam/Makefile       |    7 +
 drivers/media/video/mp200_cam/mp200_cam.c    | 6378 ++++++++++++++++++++++++++
 drivers/media/video/mp200_cam/mp200_cam.h    |  247 +
 drivers/media/video/mp200_cam/mp200_mega.c   | 3236 +++++++++++++
 8 files changed, 9948 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mp200/include/mach/mp200_cam.h
 create mode 100644 drivers/media/video/mp200_cam/Kconfig
 create mode 100644 drivers/media/video/mp200_cam/Makefile
 create mode 100644 drivers/media/video/mp200_cam/mp200_cam.c
 create mode 100644 drivers/media/video/mp200_cam/mp200_cam.h
 create mode 100644 drivers/media/video/mp200_cam/mp200_mega.c

diff --git a/arch/arm/mach-mp200/include/mach/mp200_cam.h b/arch/arm/mach-mp200/include/mach/mp200_cam.h
new file mode 100644
index 0000000..c61bd9b
--- /dev/null
+++ b/arch/arm/mach-mp200/include/mach/mp200_cam.h
@@ -0,0 +1,70 @@
+/*
+ *  File Name	    : arch-mp200/mp200_cam.h
+ *  Function	    : CAMERA I/F Driver
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2009/06/03
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef MP200_CAM_INC_H
+#define MP200_CAM_INC_H
+
+#define MP200_CAM_NON_PMMU	1
+
+#include <linux/videodev2.h>
+
+/* V4L2 private controls */
+#define MP200_CID_IPU				   V4L2_CID_PRIVATE_BASE
+	/* NOT SUPPORT */
+#define MP200_CID_PMMU				   (V4L2_CID_PRIVATE_BASE + 1)
+	/* NOT SUPPORT */
+#define MP200_CID_CA_MIRROR			   (V4L2_CID_PRIVATE_BASE + 2)
+#define MP200_CID_CA_BNGR			   (V4L2_CID_PRIVATE_BASE + 3)
+#define MP200_CID_CA_CBGR			   (V4L2_CID_PRIVATE_BASE + 4)
+#define MP200_CID_CA_CRGR			   (V4L2_CID_PRIVATE_BASE + 5)
+#define MP200_CID_CA_BNZR			   (V4L2_CID_PRIVATE_BASE + 6)
+#define MP200_CID_CA_CBZR			   (V4L2_CID_PRIVATE_BASE + 7)
+#define MP200_CID_CA_CRZR			   (V4L2_CID_PRIVATE_BASE + 8)
+#define MP200_RJ6ABA100_CID_FW			   (V4L2_CID_PRIVATE_BASE + 9)
+#define MP200_RJ6ABA100_CID_OUTIMG_SIZE		   (V4L2_CID_PRIVATE_BASE + 10)
+#define MP200_RJ6ABA100_CID_OUTIMG_FORMAT	   (V4L2_CID_PRIVATE_BASE + 11)
+#define MP200_RJ6ABA100_CID_OUTDATA_FORMAT	   (V4L2_CID_PRIVATE_BASE + 12)
+#define MP200_RJ6ABA100_CID_FLICKER		   (V4L2_CID_PRIVATE_BASE + 13)
+#define MP200_RJ6ABA100_CID_FLICKER_AUTO_DETECTION (V4L2_CID_PRIVATE_BASE + 14)
+	/* NOT SUPPORT */
+#define MP200_RJ6ABA100_CID_AE			   (V4L2_CID_PRIVATE_BASE + 15)
+	/* NOT SUPPORT */
+#define MP200_RJ6ABA100_CID_AE_MANUAL		   (V4L2_CID_PRIVATE_BASE + 16)
+	/* NOT SUPPORT */
+#define MP200_RJ6ABA100_CID_WB			   (V4L2_CID_PRIVATE_BASE + 17)
+#define MP200_RJ6ABA100_CID_WB_MANUAL_GAIN	   (V4L2_CID_PRIVATE_BASE + 18)
+#define MP200_RJ6ABA100_CID_BRIGHTNESS		   (V4L2_CID_PRIVATE_BASE + 19)
+#define MP200_RJ6ABA100_CID_CONTRAST		   (V4L2_CID_PRIVATE_BASE + 20)
+#define MP200_RJ6ABA100_CID_SHARPNESS		   (V4L2_CID_PRIVATE_BASE + 21)
+#define MP200_RJ6ABA100_CID_MIRROR		   (V4L2_CID_PRIVATE_BASE + 22)
+#define MP200_RJ6ABA100_CID_EFFECT_COLOR	   (V4L2_CID_PRIVATE_BASE + 23)
+#define MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL	   (V4L2_CID_PRIVATE_BASE + 24)
+#define MP200_RJ6ABA100_CID_EFFECT_NEGATIVE	   (V4L2_CID_PRIVATE_BASE + 25)
+#define MP200_RJ6ABA100_CID_EFFECT_EMBOSS	   (V4L2_CID_PRIVATE_BASE + 26)
+#define MP200_RJ6ABA100_CID_EFFECT_SKETCH	   (V4L2_CID_PRIVATE_BASE + 27)
+#define MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL   (V4L2_CID_PRIVATE_BASE + 28)
+
+#endif
+
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 14c7559..307338b 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -995,4 +995,6 @@ config VIDEO_SH_MOBILE_CEU
 
 source "drivers/media/video/mp200/Kconfig"
 
+source "drivers/media/video/mp200_cam/Kconfig"
+
 endif # VIDEO_CAPTURE_DRIVERS
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 62d6e4d..daa9600 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -147,6 +147,8 @@ obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
 obj-$(CONFIG_VIDEO_MP200) += mp200/ videobuf-core.o
 
+obj-$(CONFIG_VIDEO_MP200_CAMERA) += mp200_cam/
+
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
diff --git a/drivers/media/video/mp200_cam/Kconfig b/drivers/media/video/mp200_cam/Kconfig
new file mode 100644
index 0000000..47afa84
--- /dev/null
+++ b/drivers/media/video/mp200_cam/Kconfig
@@ -0,0 +1,6 @@
+
+config VIDEO_MP200_CAMERA
+	bool "MP200 Video for Linux2 camera driver"
+	depends on VIDEO_DEV && ARCH_MP200
+	default y
+
diff --git a/drivers/media/video/mp200_cam/Makefile b/drivers/media/video/mp200_cam/Makefile
new file mode 100644
index 0000000..76febc8
--- /dev/null
+++ b/drivers/media/video/mp200_cam/Makefile
@@ -0,0 +1,7 @@
+# Makefile for mp200_v4l2 driver for MP201
+
+mp200_v4l2_cam-objs := mp200_cam.o mp200_mega.o
+
+obj-y += mp200_v4l2_cam.o
+
+EXTRA_CFLAGS = -I$(src)/.. -Wall
diff --git a/drivers/media/video/mp200_cam/mp200_cam.c b/drivers/media/video/mp200_cam/mp200_cam.c
new file mode 100644
index 0000000..ee2ad21
--- /dev/null
+++ b/drivers/media/video/mp200_cam/mp200_cam.c
@@ -0,0 +1,6378 @@
+/*
+ *  File Name       : mp200_cam.c
+ *  Function        : CAMERA I/F Driver
+ *  Release Version : Ver 0.06
+ *  Release Date    : 2008/02/19
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <mach/pmu.h>
+#include <mach/smu.h>
+#include <mach/ipu.h>
+#include <mach/img.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+#include <linux/freezer.h>
+#include <mach/pm.h>
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+/* #define MP200_CAM_MAKING_DEBUG */
+/* #define MP200_CAM_GLOBAL_DEFINE */
+
+#include "mp200_cam.h"
+
+#define CAM_NAME "mp200_camera"
+#if 1
+#define CAM_MAX_BUFNBRS 4
+#else
+#define CAM_MAX_BUFNBRS VIDEO_MAX_FRAME
+#endif
+
+
+
+#define DEV_NAME "mp200_cam"
+
+
+#define printk_info(fmt, arg...) \
+	do {								\
+		printk(KERN_INFO DEV_NAME \
+		       ": %s(%d): " fmt "\n", __func__, __LINE__, ## arg); \
+	} while (0)
+
+
+struct mp200_enq_index {
+	unsigned int grab;
+	unsigned int done;
+};
+
+enum {
+	CAM_MMAP = 0,
+	CAM_READ,
+};
+
+enum {
+	CAM_OFF = 0,
+	CAM_ON,
+};
+
+#define CAM_IPU_OFF  CAM_OFF
+#define CAM_IPU_ON   CAM_ON
+#if MP200_CAM_NON_PMMU
+#else
+#define CAM_PMMU_OFF CAM_OFF
+#define CAM_PMMU_ON  CAM_ON
+#endif
+
+#if MP200_CAM_NON_PMMU
+enum {
+	BUF_FIXED = 0,
+	BUF_IPU,
+};
+#else
+enum {
+	BUF_V = 0,
+	BUF_DMA,
+	BUF_IPU,
+	BUF_PMMU,
+	BUF_CAM_PMMU_IPU,
+	BUF_IPU_PMMU,
+};
+#endif
+
+enum {
+	CAM_BUF_IDLE = 0,
+	CAM_BUF_QUEUED,
+	CAM_BUF_GRABBING,
+	CAM_BUF_GRAB,
+	CAM_BUF_DONE,
+	CAM_BUF_BREAK,
+};
+
+struct mp200_cam_mapping {
+	unsigned int count;
+	unsigned long start;
+	unsigned long end;
+};
+
+struct mp200_cam_buffer {
+	__u32 index;
+	__u32 state;
+	__u32 bytesused;
+	struct timeval timestamp;
+	unsigned long sequence;
+	char *vadr;             /* points to actual buffer */
+	unsigned long padr;     /* physical buffer address */
+	union {
+		__u32 offset;
+		unsigned long userptr;
+	} m;
+	struct mp200_cam_mapping *map;
+};
+
+struct mp200_cam_fmt {
+	__u8 description[32];      /* Description string */
+	__u32 pixelformat;         /* Format fourcc      */
+	int depth;                 /* bit/pixel          */
+	int flags;
+	int boundary;
+};
+
+struct mp200_cam_frames {
+	struct kfifo *enq;
+	spinlock_t enq_lock;
+	struct mp200_cam_buffer *buff;
+	wait_queue_head_t proc_list;
+	unsigned int cnt;
+	unsigned int max;
+	int (*update)(void *);
+	__u32 blocksize;
+	enum v4l2_memory memory;
+	const struct mp200_cam_fmt *fmt;
+	int buf_type;
+};
+
+/* CAMIF status */
+#define B_L1MISS (0x01 << 18)
+#define B_APERR  (0x01 << 17)
+#define B_PMERR  (0x01 << 16)
+#define B_SUBOR  (0x01 << 5)
+#define B_SUBTC  (0x01 << 4)
+#define B_MAINOR (0x01 << 3)
+#define B_MAINTC (0x01 << 2)
+#define B_DMAERR (0x01 << 1)
+#define B_CAMVS  (0x01 << 0)
+
+/* IPU status */
+#define B_IPU_SUCCESS   (0x01 << 29)      /* IPU_CALLBACK_SUCCESS */
+#define B_IPU_SET_PARAM (0x01 << 28)      /* IPU_CALLBACK_SET_PARAM */
+#define B_IPU_CANCEL    (0x01 << 27)      /* IPU_CALLBACK_CANCEL */
+#define B_IPU_FAIL      (0x01 << 26)      /* IPU_CALLBACK_FAIL */
+#define B_IPU_ERROR     (0x01 << 25)      /* IPU_CALLBACK_IPU_ERROR */
+#define B_IPU_STOP      (0x01 << 24)      /* IPU_CALLBACK_IPU_STOP */
+
+struct mp200_cam {
+	__u32 status;
+
+	__u32 setup:1;
+	__u32 reset:1;
+	__u32 stop:1;
+	__u32 action:1; /* 0:mmap 1:read */
+	__u32 reading:1;
+	__u32 streaming:1;
+	__u32 frames_active:1;
+	__u32 userptr:1;
+	unsigned int mapping;
+
+	__u32 ipu:1;
+#if MP200_CAM_NON_PMMU
+#else
+	__u32 pmmu:1;
+#endif
+	struct mutex lock;
+
+	struct kfifo *deq_grab;
+	spinlock_t deq_grab_lock;
+	struct kfifo *deq_done;
+	spinlock_t deq_done_lock;
+	unsigned long sequence;
+
+	spinlock_t cam_lock;
+
+	struct task_struct *th;
+	int (*th_convert)(int);
+	int (*read_convert)(char *, __u32, __u32, __u32);
+
+	__u32 width;              /* Image width in pixels. */
+	__u32 height;             /* Image height in pixels. */
+	struct v4l2_rect c;       /* Cropping rectangle */
+	struct v4l2_rect bounds;  /* Defines the window within capturing */
+	const struct mp200_cam_fmt *fmt;
+	struct mutex frames_lock;
+	struct mp200_cam_frames *grab;
+	struct mp200_cam_frames *done;
+	struct mp200_cam_prepare pre;
+
+	struct mp200_cam_hw_operations hw;
+	struct video_device *vdev;
+	struct proc_dir_entry *proc_entry;
+	int open_count;
+	__u32 active_number;
+	__u32 used_number;
+};
+
+struct mp200_cam *cam;
+#if 1 /* XXX */
+static int warming_up = 1;
+#endif
+
+struct mp200_cam_private {
+	int number;
+};
+
+/* ipu uses */
+struct mp200_ipu_req *ipu_req;
+struct mp200_ipu_reg_info *ipu_reg_info;
+#define IPU_MAX_REG_INFO 14
+
+/*
+ * Camera I/F Functions
+ */
+
+struct mp200_camif {
+	__u32 status;
+	struct mutex lock;
+
+	__u32 update:1;
+
+	__u8 mirror;
+	__u8 bngr;
+	__u8 cbgr;
+	__u8 crgr;
+	__s8 bnzr;
+	__s8 cbzr;
+	__s8 crzr;
+};
+
+struct mp200_camif *camif;
+
+#define CA_STATUS        IO_ADDRESS(MP200_CAMERA_BASE + 0x0000)
+#define CA_RAWSTATUS     IO_ADDRESS(MP200_CAMERA_BASE + 0x0004)
+#define CA_ENSET         IO_ADDRESS(MP200_CAMERA_BASE + 0x0008)
+#define CA_ENCLR         IO_ADDRESS(MP200_CAMERA_BASE + 0x000C)
+#define CA_FFCLR         IO_ADDRESS(MP200_CAMERA_BASE + 0x0010)
+#define CA_ERRORADR      IO_ADDRESS(MP200_CAMERA_BASE + 0x0014)
+#define CA_CSR           IO_ADDRESS(MP200_CAMERA_BASE + 0x0020)
+#define CA_X1R           IO_ADDRESS(MP200_CAMERA_BASE + 0x0030)
+#define CA_X2R           IO_ADDRESS(MP200_CAMERA_BASE + 0x0034)
+#define CA_Y1R           IO_ADDRESS(MP200_CAMERA_BASE + 0x0038)
+#define CA_Y2R           IO_ADDRESS(MP200_CAMERA_BASE + 0x003C)
+#define CA_BNZR          IO_ADDRESS(MP200_CAMERA_BASE + 0x0040)
+#define CA_BNGR          IO_ADDRESS(MP200_CAMERA_BASE + 0x0044)
+#define CA_CBZR          IO_ADDRESS(MP200_CAMERA_BASE + 0x0048)
+#define CA_CBGR          IO_ADDRESS(MP200_CAMERA_BASE + 0x004C)
+#define CA_CRZR          IO_ADDRESS(MP200_CAMERA_BASE + 0x0050)
+#define CA_CRGR          IO_ADDRESS(MP200_CAMERA_BASE + 0x0054)
+#define CA_DMACNT        IO_ADDRESS(MP200_CAMERA_BASE + 0x0080)
+#define CA_FRAME         IO_ADDRESS(MP200_CAMERA_BASE + 0x0084)
+#define CA_DMAREQ        IO_ADDRESS(MP200_CAMERA_BASE + 0x0088)
+#define CA_DMASTOP       IO_ADDRESS(MP200_CAMERA_BASE + 0x008C)
+#define CA_LINESIZE_MAIN IO_ADDRESS(MP200_CAMERA_BASE + 0x0100)
+#define CA_XRATIO_MAIN   IO_ADDRESS(MP200_CAMERA_BASE + 0x0104)
+#define CA_YRATIO_MAIN   IO_ADDRESS(MP200_CAMERA_BASE + 0x0108)
+#define CA_DMAX_MAIN     IO_ADDRESS(MP200_CAMERA_BASE + 0x010C)
+#define CA_DMAY_MAIN     IO_ADDRESS(MP200_CAMERA_BASE + 0x0110)
+#define CA_YPLANE_A      IO_ADDRESS(MP200_CAMERA_BASE + 0x0114)
+#define CA_UVPLANE_A     IO_ADDRESS(MP200_CAMERA_BASE + 0x0118)
+#define CA_VPLANE_A      IO_ADDRESS(MP200_CAMERA_BASE + 0x0244)
+#define CA_YPLANE_B      IO_ADDRESS(MP200_CAMERA_BASE + 0x011C)
+#define CA_UVPLANE_B     IO_ADDRESS(MP200_CAMERA_BASE + 0x0120)
+#define CA_VPLANE_B      IO_ADDRESS(MP200_CAMERA_BASE + 0x0248)
+#define CA_MODULECONT    IO_ADDRESS(MP200_CAMERA_BASE + 0x022C)
+#define CA_UPDATE        IO_ADDRESS(MP200_CAMERA_BASE + 0x0230)
+#define CA_MIRROR        IO_ADDRESS(MP200_CAMERA_BASE + 0x0234)
+#define CA_OD_BYTELANE   IO_ADDRESS(MP200_CAMERA_BASE + 0x0238)
+#define CA_X3R           IO_ADDRESS(MP200_CAMERA_BASE + 0x0240)
+#define CA_OD_BYTELANE2  IO_ADDRESS(MP200_CAMERA_BASE + 0x0254)
+
+#if MP200_CAM_NON_PMMU
+#else
+#define CA_MMU_MODE     IO_ADDRESS(MP200_MMUCAM_BASE + 0x0000)
+#define CA_MMU_STATUS1  IO_ADDRESS(MP200_MMUCAM_BASE + 0x0004)
+#define CA_MMU_STATUS2  IO_ADDRESS(MP200_MMUCAM_BASE + 0x0008)
+#define CA_MMU_CTRL     IO_ADDRESS(MP200_MMUCAM_BASE + 0x000C)
+#define CA_MMU_1D0      IO_ADDRESS(MP200_MMUCAM_BASE + 0x0080)
+#define CA_MMU_INDEX0   IO_ADDRESS(MP200_MMUCAM_BASE + 0x0084)
+#define CA_MMU_1D1      IO_ADDRESS(MP200_MMUCAM_BASE + 0x0088)
+#define CA_MMU_INDEX1   IO_ADDRESS(MP200_MMUCAM_BASE + 0x008c)
+#define CA_MMU_1D2      IO_ADDRESS(MP200_MMUCAM_BASE + 0x0090)
+#define CA_MMU_INDEX2   IO_ADDRESS(MP200_MMUCAM_BASE + 0x0094)
+
+#define B_CHK_PERMISSION        (0x01 << 5)
+#define B_CHK_PAGE              (0x01 << 4)
+#define B_MMU_EN                (0x01 << 0)
+#endif
+
+#define M_CA_ENSET (B_L1MISS | B_APERR | B_PMERR \
+		    | B_MAINOR | B_MAINTC | B_DMAERR | B_CAMVS)
+
+#define S_656MODE       14
+#define S_PIXEL_YUV     13
+#define S_SYNCTYPE      12
+#define S_PIXELMODE     11
+#define S_DATA_OD       10
+#define S_DATA_ID       9
+#define S_LD_TMG        8
+#define S_VS_DET        7
+#define S_HS_DET        6
+#define S_LIMITSEL      5
+#define S_SYNCMODE      4
+#define S_CLK_EDGE      3
+#define S_DATA_DET      2
+#define S_VS_POL        1
+#define S_HS_POL        0
+
+#define S_SUBYUV        13
+#define S_MAINYUV       12
+#define S_SUBREC        10
+#define S_MAINREC       8
+#define S_SUBMODE       6
+#define S_MAINMODE      4
+#define S_SBRESIZE      3
+#define S_MNRESIZE      2
+#define S_PCULLR        0
+
+#define S_SUBFRM        2
+#define S_MAINFRM       0
+
+struct camif_reg {
+	__u32 csr;
+	__u32 x1r;
+	__u32 x2r;
+	__u32 x3r;
+	__u32 y1r;
+	__u32 y2r;
+	__u32 dmacnt;
+	__u32 od_bytelane;
+	__u32 od_bytelane2;
+	__u32 yplane_a;
+	__u32 uvplane_a;
+	__u32 vplane_a;
+	__u32 frame;
+	__u32 dmax_main;
+	__u32 dmay_main;
+	__u32 linesize_main;
+	__u32 xratio_main;
+	__u32 yratio_main;
+};
+
+static inline int snprintf_rect(char *out, size_t size, struct v4l2_rect *rect)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct v4l2_rect : %p ", rect);
+	if (!rect)
+		return i;
+	i += snprintf(out + i, size - i, "top : %d ", rect->top);
+	i += snprintf(out + i, size - i, "left : %d ", rect->left);
+	i += snprintf(out + i, size - i, "width : %d ", rect->width);
+	i += snprintf(out + i, size - i, "height : %d ", rect->height);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_fmt(char *out, size_t size,
+			       const struct mp200_cam_fmt *fmt)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam_fmt : %p\n", fmt);
+	if (!fmt)
+		return i;
+	i += snprintf(out + i, size - i, "description : %s "
+		      , fmt->description);
+	i += snprintf(out + i, size - i, "pixelformat : %08x "
+		      , fmt->pixelformat);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "depth : %d ", fmt->depth);
+	i += snprintf(out + i, size - i, "flags : %08x ", fmt->flags);
+	i += snprintf(out + i, size - i, "boundary : %d ", fmt->boundary);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_time(char *out, size_t size, struct timeval *t)
+{
+	int i = 0;
+
+	if (!t)
+		return i;
+	i += snprintf(out + i, size - i, "tv_sec : %ld ", t->tv_sec);
+	i += snprintf(out + i, size - i, "tv_usec : %ld ", t->tv_usec);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_map(char *out, size_t size,
+			       struct mp200_cam_mapping *map)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam_mapping : %p\n"
+		      , map);
+	if (!map)
+		return i;
+	i += snprintf(out + i, size - i, "count : %d ", map->count);
+	i += snprintf(out + i, size - i, "start : %ld ", map->start);
+	i += snprintf(out + i, size - i, "end : %ld ", map->end);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_buff(char *out, size_t size,
+				struct mp200_cam_buffer *buff,
+				enum v4l2_memory memory)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam_buffer : %p\n"
+		      , buff);
+	if (!buff)
+		return i;
+	i += snprintf(out + i, size - i, "index : %d ", buff->index);
+	i += snprintf(out + i, size - i, "bytesused : %d ", buff->bytesused);
+	i += snprintf_time(out + i, size - i, &buff->timestamp);
+	i += snprintf(out + i, size - i, "sequence : %ld ", buff->sequence);
+	i += snprintf(out + i, size - i, "vadr : %p ", buff->vadr);
+	i += snprintf(out + i, size - i, "padr : %lu ", buff->padr);
+	if (V4L2_MEMORY_MMAP == memory) {
+		i += snprintf(out + i, size - i, "m.offset : %d ",
+			      buff->m.offset);
+	} else {
+		i += snprintf(out + i, size - i, "m.userptr : %lu ",
+			      buff->m.userptr);
+	}
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "map : %p ", buff->map);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_buffs(char *out, size_t size,
+				 struct mp200_cam_buffer *buff, int max,
+				 enum v4l2_memory memory)
+{
+	int i = 0, j;
+
+	for (j = 0; max > j; j++)
+		i += snprintf_buff(out + i, size - i, &buff[j], memory);
+
+	return i;
+}
+
+static inline int snprintf_frm(char *out, size_t size,
+			       struct mp200_cam_frames *frm)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam_frames : %p\n", frm);
+	if (!frm)
+		return i;
+	i += snprintf(out + i, size - i, "enq : %p ", frm->enq);
+	/* i += snprintf(out+i, size-i, "enq_lock.raw_lock.lock : %d ",
+				 frm->enq_lock.raw_lock.lock); */
+	i += snprintf(out + i, size - i, "buff : %p ", frm->buff);
+	/* i += snprintf(out+i, size-i, "proc_list.lock.raw_lock.lock : %d ",
+					frm->proc_list.lock.raw_lock.lock); */
+	i += snprintf(out + i, size - i, "cnt : %d ", frm->cnt);
+	i += snprintf(out + i, size - i, "max : %d ", frm->max);
+	i += snprintf(out + i, size - i, "update : %p ", frm->update);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "blocksize : %d ", frm->blocksize);
+	i += snprintf(out + i, size - i, "memory : %d ", frm->memory);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "fmt : %p ", frm->fmt);
+	if (frm->fmt)
+		i += snprintf_fmt(out + i, size - i, frm->fmt);
+	i += snprintf(out + i, size - i, "buf_type : %d ", frm->buf_type);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_hw(char *out, size_t size,
+			      struct mp200_cam_hw_operations *hw)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i,
+		      "struct mp200_cam_hw_operations : %p\n", hw);
+	if (!hw)
+		return i;
+	i += snprintf(out + i, size - i, "name : %s ", hw->name);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i,
+		      "vidioc_queryctrl : %p ", hw->vidioc_queryctrl);
+	i += snprintf(out + i, size - i,
+		      "vidioc_g_ctrl : %p ", hw->vidioc_g_ctrl);
+	i += snprintf(out + i, size - i,
+		      "vidioc_s_ctrl : %p ", hw->vidioc_s_ctrl);
+	i += snprintf(out + i, size - i,
+		      "vidioc_querymenu : %p ", hw->vidioc_querymenu);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "prepare : %p ", hw->prepare);
+	i += snprintf(out + i, size - i, "trigger : %p ", hw->trigger);
+	i += snprintf(out + i, size - i, "sync : %p ", hw->sync);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "stream_on : %p ", hw->stream_on);
+	i += snprintf(out + i, size - i, "stream_off : %p ", hw->stream_off);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "startup : %p ", hw->startup);
+	i += snprintf(out + i, size - i, "shutdown : %p ", hw->shutdown);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "private : %p ", hw->private);
+	i += snprintf(out + i, size - i, "unregister : %p ", hw->unregister);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_pre(char *out, size_t size,
+			       struct mp200_cam_prepare *pre)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam_preparet : %p\n"
+		      , pre);
+	if (!pre)
+		return i;
+	i += snprintf(out + i, size - i,
+		      "actions : %s ", (pre->actions) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "reset : %s ", (pre->reset) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "syncmode : %s ", (pre->syncmode) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "synctype : %s ", (pre->synctype) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "data_id : %s ", (pre->data_id) ? "on" : "off");
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i,
+		      "vs_det : %s ", (pre->vs_det) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "hs_det : %s ", (pre->hs_det) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "clk_edge : %s ", (pre->clk_edge) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "data_det : %s ", (pre->data_det) ? "on" : "off");
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i,
+		      "vs_pol : %s ", (pre->vs_pol) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "hs_pol : %s ", (pre->hs_pol) ? "on" : "off");
+	i += snprintf(out + i, size - i, "bounds :\n");
+	i += snprintf_rect(out + i, size - i, &pre->bounds);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_cam(char *out, size_t size,
+			       struct mp200_cam *cam)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct mp200_cam : %p\n", cam);
+	if (!cam)
+		return i;
+	i += snprintf(out + i, size - i, "status : %08x ", cam->status);
+	i += snprintf(out + i, size - i,
+		      "setup : %s ", (cam->setup) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "reset : %s ", (cam->reset) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "stop : %s ", (cam->stop) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "action : %s ", (cam->action) ? "read" : "map");
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i,
+		      "reading : %s ", (cam->reading) ? "on" : "off");
+	i += snprintf(out + i, size - i,
+		      "streaming : %s ", (cam->streaming) ? "on" : "off");
+	i += snprintf(out + i, size - i, "mapping : %d ", cam->mapping);
+	i += snprintf(out + i, size - i, "ipu : %s "
+		      , (cam->ipu) ? "on" : "off");
+#if MP200_CAM_NON_PMMU
+#else
+	i += snprintf(out + i, size - i, "pmmu : %s "
+		      , (cam->pmmu) ? "on" : "off");
+#endif
+	i += snprintf(out + i, size - i, "sequence : %ld ", cam->sequence);
+	/* i += snprintf(out+i, size-i,
+			 "lock.count : %d ", cam->lock.count); */
+	/* i += snprintf(out+i, size-i, "lock.wait_lock.raw_lock.lock : %d ",
+					cam->lock.wait_lock.raw_lock.lock); */
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "lock.wait_list.next : %p ",
+		      cam->lock.wait_list.next);
+	i += snprintf(out + i, size - i, "lock.wait_list.prev : %p ",
+		      cam->lock.wait_list.prev);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "deq_grab : %p ", cam->deq_grab);
+	i += snprintf(out + i, size - i, "deq_done : %p ", cam->deq_done);
+	/* i += snprintf(out+i, size-i, "deq_done_lock.wait_lock.raw_lock.lock"
+		" : %d ", cam->deq_done_lock.wait_lock.raw_lock.lock); */
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "th : %p ", cam->th);
+	i += snprintf(out + i, size - i, "th_convert : %p ", cam->th_convert);
+	i += snprintf(out + i, size - i, "read_convert : %p "
+		      , cam->read_convert);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "width : %d ", cam->width);
+	i += snprintf(out + i, size - i, "height : %d ", cam->height);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "c : ");
+	i += snprintf_rect(out + i, size - i, &cam->c);
+	i += snprintf(out + i, size - i, "bounds : ");
+	i += snprintf_rect(out + i, size - i, &cam->bounds);
+	i += snprintf(out + i, size - i, "fmt : %p ", cam->fmt);
+	if (cam->fmt)
+		i += snprintf_fmt(out + i, size - i, cam->fmt);
+	i += snprintf(out + i, size - i, "grab : %p ", cam->grab);
+	i += snprintf(out + i, size - i, "done : %p ", cam->done);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "vdev : %p ", cam->vdev);
+	i += snprintf(out + i, size - i, "proc_entry : %p ", cam->proc_entry);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "open_count : %d ", cam->open_count);
+	i += snprintf(out + i, size - i,
+		      "active_number : %08x ", cam->active_number);
+	i += snprintf(out + i, size - i, "used_number : %08x "
+		      , cam->used_number);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_reg(char *out, size_t size, struct camif_reg *reg)
+{
+	int i = 0;
+
+	i += snprintf(out + i, size - i, "struct camif_reg : %p\n", reg);
+	if (!reg)
+		return i;
+	i += snprintf(out + i, size - i, "csr : %08x ", reg->csr);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "x1r : %08x ", reg->x1r);
+	i += snprintf(out + i, size - i, "x2r : %08x ", reg->x2r);
+	i += snprintf(out + i, size - i, "x3r : %08x ", reg->x3r);
+	i += snprintf(out + i, size - i, "y1r : %08x ", reg->y1r);
+	i += snprintf(out + i, size - i, "y2r : %08x ", reg->y2r);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "dmacnt : %08x ", reg->dmacnt);
+	i += snprintf(out + i, size - i, "od_bytelane : %08x "
+		      , reg->od_bytelane);
+	i += snprintf(out + i, size - i, "od_bytelane2 : %08x ",
+		      reg->od_bytelane2);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "yplane_a : %08x ", reg->yplane_a);
+	i += snprintf(out + i, size - i, "uvplane_a : %08x ", reg->uvplane_a);
+	i += snprintf(out + i, size - i, "vplane_a : %08x ", reg->vplane_a);
+	i += snprintf(out + i, size - i, "frame : %08x ", reg->frame);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "dmax_main : %08x ", reg->dmax_main);
+	i += snprintf(out + i, size - i, "dmay_main : %08x ", reg->dmay_main);
+	i += snprintf(out + i, size - i, "linesize_main : %08x ",
+		      reg->linesize_main);
+	i += snprintf(out + i, size - i, "\n");
+	i += snprintf(out + i, size - i, "xratio_main : %08x "
+		      , reg->xratio_main);
+	i += snprintf(out + i, size - i, "yratio_main : %08x "
+		      , reg->yratio_main);
+	i += snprintf(out + i, size - i, "\n");
+
+	return i;
+}
+
+static inline int snprintf_ipureg(char *out, size_t size,
+				  struct mp200_ipu_req *p)
+{
+	int i = 0, l, e = 0;
+
+	if (!p)
+		return i;
+	for (l = 0; IPU_MAX_REG_INFO > l; l++) {
+		switch (p->ipu_reg_info[l].reg) {
+		case IMG_MODE:
+			i += snprintf(out + i, size - i, "%d IMG_MODE : ", l);
+			break;
+		case IMG_FORMAT:
+			i += snprintf(out + i, size - i, "%d IMG_FORMAT : ", l);
+			break;
+		case IMG_SRCSIZE_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCSIZE_B : ", l);
+			break;
+		case IMG_SRCHSIZE_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCHSIZE_B : ", l);
+			break;
+		case IMG_SRCVSIZE_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCVSIZE_B : ", l);
+			break;
+		case IMG_SRCSIZE_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCSIZE_F : ", l);
+			break;
+		case IMG_SRCHSIZE_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCHSIZE_F : ", l);
+			break;
+		case IMG_SRCVSIZE_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCVSIZE_F : ", l);
+			break;
+		case IMG_OFFSETX:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_OFFSETX : ", l);
+			break;
+		case IMG_OFFSETY:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_OFFSETY : ", l);
+			break;
+		case IMG_SRCYRGBADR_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCYRGBADR_B : ", l);
+			break;
+		case IMG_SRCYRGBADR_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCYRGBADR_F : ", l);
+			break;
+		case IMG_SRCUVADR_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCUVADR_B : ", l);
+			break;
+		case IMG_SRCUVADR_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCUVADR_F : ", l);
+			break;
+		case IMG_SRCVADR_B:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCVADR_B : ", l);
+			break;
+		case IMG_SRCVADR_F:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_SRCVADR_F : ", l);
+			break;
+		case IMG_DSTYRGBADR:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTYRGBADR : ", l);
+			break;
+		case IMG_DSTUVADR:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTUVADR : ", l);
+			break;
+		case IMG_DSTVADR:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTVADR : ", l);
+			break;
+		case IMG_DSTHSIZE:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTHSIZE : ", l);
+			break;
+		case IMG_DSTVSIZE:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTVSIZE : ", l);
+			break;
+		case IMG_DSTSIZE:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_DSTSIZE : ", l);
+			break;
+		case IMG_HSTEP:
+			i += snprintf(out + i, size - i, "%d IMG_HSTEP : ", l);
+			break;
+		case IMG_HFOLD:
+			i += snprintf(out + i, size - i, "%d IMG_HFOLD : ", l);
+			break;
+		case IMG_PEL_ENDIAN:
+			i += snprintf(out + i, size - i,
+				      "%d IMG_PEL_ENDIAN : ", l);
+			break;
+		case IMG_REQ:
+			i += snprintf(out + i, size - i, "%d IMG_REQ : ", l);
+			break;
+		case IPU_REG_INFO_END:
+			i += snprintf(out + i, size - i,
+				      "%d IPU_REG_INFO_END : ", l);
+			e = 1;
+			break;
+		default:
+			i += snprintf(out + i, size - i,
+				      "%d Unknowing 0x%02lx : ",
+				      l, p->ipu_reg_info[l].reg);
+			e = 1;
+		}
+
+		i += snprintf(out + i, size - i,
+			      "0x%08lx\n", p->ipu_reg_info[l].data);
+
+		if (e)
+			break;
+	}
+
+	return i;
+}
+
+static inline int camif_chg_pinsel(void)
+{
+#define CHG_PINSEL_G00_CAM_BIT    0x00000C00  /* GIO_P5     : CAM_SCLK */
+#define CHG_PINSEL_G00_CAM_DATA   0x00000C00
+#define CHG_PINSEL_G64_CAM_BIT    0xFFC00000
+/* GIO_P75-79 : CAM_YUV4, CAM_YUV3, CAM_YUV2, CAM_YUV1, CAM_YUV0 */
+#define CHG_PINSEL_G64_CAM_DATA   0xFFC00000
+#define CHG_PINSEL_G80_CAM_BIT    0x03000000  /* GIO_P92    : CAM_CLKI */
+#define CHG_PINSEL_G80_CAM_DATA   0x02000000
+#define CHG_PINSEL_SD1_CAM_BIT    0x00000003
+/* SD1        : CAM_YUV5, CAM_YUV6, CAM_YUV7, CAM_VS, CAM_HS */
+#define CHG_PINSEL_SD1_CAM_DATA   0x00000002
+
+#define CHG_PULL_G72_BIT          0x77777000
+#define CHG_PULL_G72_DATA         0x44444000
+#define CHG_PULL_G88_BIT          0x00070000
+#define CHG_PULL_G88_DATA         0x00040000
+#define CHG_PULL2_BIT             0x00444000
+#define CHG_PULL2_DATA            0x00444000
+
+	/* Pin select
+	 * GIO_P5  : CAM_SCLK : 0xXXXXXCXX
+	 * GIO_P75 : CAM_YUV4 : 0xXXCXXXXX
+	 * GIO_P76 : CAM_YUV3 : 0xX3XXXXXX
+	 * GIO_P77 : CAM_YUV2 : 0xXCXXXXXX
+	 * GIO_P78 : CAM_YUV1 : 0x3XXXXXXX
+	 * GIO_P79 : CAM_YUV0 : 0xCXXXXXXX
+	 * GIO_P92 : CAM_CLKI : 0xX2XXXXXX
+	 * SD1     : CAM_CLKI : 0xXXXXXXX2
+	 */
+	writel((readl(CHG_PINSEL_G00) & ~CHG_PINSEL_G00_CAM_BIT)
+	       | CHG_PINSEL_G00_CAM_DATA, CHG_PINSEL_G00);
+	/* GIO_P5     : CAM_SCLK */
+	writel((readl(CHG_PINSEL_G64) & ~CHG_PINSEL_G64_CAM_BIT)
+	       | CHG_PINSEL_G64_CAM_DATA, CHG_PINSEL_G64);
+	/* GIO_P75-79 : CAM_YUV4, CAM_YUV3, CAM_YUV2, CAM_YUV1, CAM_YUV0 */
+	writel((readl(CHG_PINSEL_G80) & ~CHG_PINSEL_G80_CAM_BIT)
+	       | CHG_PINSEL_G80_CAM_DATA, CHG_PINSEL_G80);
+	/* GIO_P92    : CAM_CLKI */
+	writel((readl(CHG_PINSEL_SD1) & ~CHG_PINSEL_SD1_CAM_BIT)
+	       | CHG_PINSEL_SD1_CAM_DATA, CHG_PINSEL_SD1);
+	/* SD1        : CAM_YUV5, CAM_YUV6, CAM_YUV7, CAM_VS, CAM_HS */
+
+	writel((readl(CHG_PULL_G72) & ~CHG_PULL_G72_BIT)
+	       | CHG_PULL_G72_DATA, CHG_PULL_G72);
+	/* GIO75-79    : CAM_YUV4, CAM_YUV3, CAM_YUV2, CAM_YUV1, CAM_YUV0 */
+	writel((readl(CHG_PULL_G88) & ~CHG_PULL_G88_BIT)
+	       | CHG_PULL_G88_DATA, CHG_PULL_G88);
+	/* GIO92       : CAM_CLK */
+	writel((readl(CHG_PULL2)    & ~CHG_PULL2_BIT)
+	       | CHG_PULL2_DATA,    CHG_PULL2);
+	/* SD1_D/CM/CK : CAM_YUV7, CAM_YUV6, CAM_YUV5, CAM_VS, CAM_HS */
+
+	writel(0x00000113, SMU_DIVCAMSCLK);
+	return 0;
+}
+
+static inline int camif_start_clock(void)
+{
+	/* start clock */
+/*	mp200_pmu_clkctrl_off(MP200_CLKCTRL_CAM); */
+/*	mp200_pmu_clkctrl_off(MP200_CLKCTRL_CAMPCLK); */
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_CAM_CLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_CAM_SCLK);
+	mp200_pmu_open_clockgate(MP200_CLOCKGATE_CAM_PCLK);
+	mp200_pmu_unreset_device(MP200_RESETDEVICE_CAM);
+/*	mp200_pmu_clkctrl_on(MP200_CLKCTRL_CAM); */
+/*	mp200_pmu_clkctrl_on(MP200_CLKCTRL_CAMPCLK); */
+
+	return 0;
+}
+
+static inline int camif_stop_clock(void)
+{
+/*	mp200_pmu_clkctrl_off(MP200_CLKCTRL_CAM); */
+/*	mp200_pmu_clkctrl_off(MP200_CLKCTRL_CAMPCLK); */
+	mp200_pmu_reset_device(MP200_RESETDEVICE_CAM);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_CAM_CLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_CAM_SCLK);
+	mp200_pmu_close_clockgate(MP200_CLOCKGATE_CAM_PCLK);
+
+	return 0;
+}
+
+static inline int camif_irq_enclr(void)
+{
+	outl(M_CA_ENSET, CA_ENCLR);
+	outl(M_CA_ENSET, CA_FFCLR);
+
+	return 0;
+}
+
+static inline __u32 camif_fmt_boundary(const struct mp200_cam_fmt *fmt,
+				       __u32 width)
+{
+	/* d1b("chk width %d\n", width); */
+
+	width = width >> fmt->boundary;
+	width = width << fmt->boundary;
+
+	/* d1b("chk width %d\n", width); */
+
+	return width;
+}
+
+#if 0
+/* @@static inline __u32 camif_ratio_limit(const struct mp200_cam_fmt* fmt,
+   __u32 size) */
+#else
+static inline __u32 camif_width_ratio_limit(const struct mp200_cam_fmt *fmt,
+					    __u32 size)
+#endif
+{
+	u32 limit = 64 * size / 1023;
+
+	size = camif_fmt_boundary(fmt, limit);
+
+	if (limit >= size)
+		size += (1 << fmt->boundary);
+
+	return size;
+}
+
+#if 1
+static inline __u32 camif_height_ratio_limit(const struct mp200_cam_fmt *fmt,
+					     __u32 size)
+{
+	u32 limit = 64 * size / 1023;
+
+	if (64 * size % 1023)
+		limit += 1;
+	size = limit;
+
+	return size;
+}
+#endif
+
+static inline __u32 camif_width_limit(const struct mp200_cam_fmt *fmt,
+				      __u32 width)
+{
+	u32 limit = 1;
+
+#if 0
+/* @@	width = camif_ratio_limit(fmt, width); */
+#else
+	width = camif_width_ratio_limit(fmt, width);
+#endif
+
+	limit = limit << fmt->boundary;
+
+	if (limit > width)
+		width = limit;
+
+	return width;
+}
+
+static inline __u32 camif_height_limit(const struct mp200_cam_fmt *fmt,
+				       __u32 height)
+{
+	u32 limit = 1;
+
+#if 0
+/* @@	height = camif_ratio_limit(fmt, height); */
+#else
+	height = camif_height_ratio_limit(fmt, height);
+#endif
+
+	if (limit > height)
+		height = limit;
+
+	return height;
+}
+
+static inline int cam_reset_update(int flag)
+{
+	int ret = 0;
+
+	cam->c = cam->pre.bounds;
+	cam->bounds = cam->pre.bounds;
+	cam->width  = camif_fmt_boundary(cam->fmt, cam->c.width);
+	cam->height = cam->c.height;
+
+	return ret;
+}
+
+static inline int camif_set_frame_setting(struct camif_reg *ca, __u32 index)
+{
+	int ret = 0;
+
+	switch (cam->fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_RGB565:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->uvplane_a = 0;
+		ca->vplane_a = 0;
+		break;
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_NV422:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->uvplane_a = ca->yplane_a + (cam->width * cam->height);
+		ca->vplane_a = 0;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->uvplane_a = 0;
+		ca->vplane_a = 0;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->uvplane_a = ca->yplane_a + (cam->width * cam->height);
+		ca->vplane_a = ca->uvplane_a + (cam->width * cam->height / 2);
+		break;
+	case V4L2_PIX_FMT_YUV420:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->uvplane_a = ca->yplane_a + (cam->width * cam->height);
+		ca->vplane_a = ca->uvplane_a + (cam->width * cam->height / 4);
+		break;
+	case V4L2_PIX_FMT_YVU420:
+		ca->yplane_a = cam->grab->buff[index].padr;
+		ca->vplane_a = ca->yplane_a + (cam->width * cam->height);
+		ca->uvplane_a = ca->vplane_a + (cam->width * cam->height / 4);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static inline int camif_set_format_setting(struct camif_reg *ca)
+{
+	int ret = 0;
+
+	switch (cam->fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_RGB565:
+		ca->csr |= (0x01 << S_PIXELMODE);
+		ca->od_bytelane  = 0xd8;
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		ca->csr |= (0x01 << S_PIXELMODE);
+		ca->od_bytelane  = 0xd8;
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		ca->csr |= (0x01 << S_PIXELMODE);
+		ca->od_bytelane  = 0x72;
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		ca->csr |= (0x01 << S_PIXEL_YUV);
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+		ca->csr |= (0x01 << S_PIXEL_YUV);
+		ca->dmacnt |= (0x01 << S_MAINYUV);
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_NV12:
+		ca->csr |= (0x01 << S_DATA_OD);
+		ca->dmacnt |= (0x01 << S_MAINYUV);
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	case V4L2_PIX_FMT_NV21:
+		ca->csr |= (0x01 << S_DATA_OD);
+		ca->dmacnt |= (0x01 << S_MAINYUV);
+		ca->od_bytelane2 = 0xe4b1;
+		break;
+	case V4L2_PIX_FMT_NV422:
+		ca->csr |= (0x01 << S_DATA_OD);
+		ca->od_bytelane2 = 0xe4e4;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static inline int camif_set_output_setting(struct camif_reg *ca)
+{
+	int ret = 0;
+
+	/* output setting : transfer */
+	ca->dmacnt |= (0x01 << S_MNRESIZE); /* resize */
+	ca->od_bytelane = 0xe4;
+
+	/* output setting : address */
+	ca->frame |= (0x01 << S_MAINFRM);
+
+	if (cam->width && cam->height) {
+		/* output setting : size */
+		ca->dmax_main = cam->width;
+		ca->dmay_main = cam->height;
+
+		switch (cam->fmt->pixelformat) {
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB24:
+			ca->linesize_main = cam->width * 2;
+			break;
+		default:
+			ca->linesize_main = cam->width;
+		}
+
+#if 0
+/* @@#if 1 / * XXX * / */
+/* @@	    ca->xratio_main = ((camif_fmt_boundary(cam->fmt, cam->c.width) */
+/* @@					 - cam->width) * 64) / cam->width; */
+/* @@#else */
+/* @@		ca->xratio_main = ((cam->c.width - cam->width) * 64) */
+/* @@							     / cam->width; */
+/* @@#endif */
+#else
+		ca->xratio_main = ((cam->c.width - cam->width) * 64)
+				  / cam->width;
+#endif
+		ca->yratio_main = ((cam->c.height - cam->height) * 64)
+				  / cam->height;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static inline int camif_set_input_setting(struct camif_reg *ca)
+{
+	int ret = 0;
+	int cpe = ((cam->pre.clk_edge) ? 1 : 2);
+
+	/* input setting */
+	ca->csr |= (cam->pre.syncmode << S_SYNCMODE);
+	ca->csr |= (cam->pre.synctype << S_SYNCTYPE);
+	ca->csr |= (cam->pre.data_id << S_DATA_ID);
+	ca->csr |= (cam->pre.vs_det << S_VS_DET);
+	ca->csr |= (cam->pre.hs_det << S_HS_DET);
+	ca->csr |= (cam->pre.clk_edge << S_CLK_EDGE);
+	ca->csr |= (cam->pre.data_det << S_DATA_DET);
+	ca->csr |= (cam->pre.vs_pol << S_VS_POL);
+	ca->csr |= (cam->pre.hs_pol << S_HS_POL);
+#if 0
+/* @@	ca->csr |= (0x01 << S_LIMITSEL); / * 8bit full        * / */
+#else
+	ca->csr |= (0x00 << S_LIMITSEL); /* ITU-R BT656(601) */
+#endif
+
+	/* input setting : range */
+	ca->x1r = cam->pre.c.left * cpe;
+
+#if 0
+/* @@#if 1 / * XXX * / */
+/* @@	ca->x2r = (cam->pre.c.left */
+/* @@		 + camif_fmt_boundary(cam->fmt, cam->pre.c.width)) * cpe; */
+/* @@#else */
+/* @@	ca->x2r = (cam->pre.c.left + cam->pre.c.width) * cpe; */
+/* @@#endif */
+#else
+	ca->x2r = (cam->pre.c.left + cam->pre.c.width) * cpe;
+#endif
+	ca->x3r = (cam->pre.bounds.left + cam->pre.bounds.width) * cpe;
+
+	ca->y1r = cam->pre.c.top;
+	ca->y2r = cam->pre.c.top + cam->pre.c.height;
+
+	return ret;
+}
+
+static inline int camif_set_setting(int flags)
+{
+	int ret = 0;
+	struct camif_reg ca;
+
+	memset(&ca, 0, sizeof(ca));
+
+	ret = camif_set_input_setting(&ca);
+	if (ret)
+		return ret;
+
+	ret = camif_set_output_setting(&ca);
+	if (ret)
+		return ret;
+
+	ret = camif_set_format_setting(&ca);
+	if (ret)
+		return ret;
+
+	assert(!(ca.csr & ~0xffff));
+	assert(!(ca.x1r & ~0x1fff));
+	assert(!(ca.x2r & ~0x1fff));
+	assert(!(ca.x3r & ~0x1fff));
+	assert(!(ca.y1r & ~0xfff));
+	assert(!(ca.y2r & ~0xfff));
+	assert(!(ca.dmacnt & ~0x3fff));
+	assert(!(ca.od_bytelane & ~0xff));
+	assert(!(ca.od_bytelane2 & ~0xffff));
+	assert(!(ca.frame & ~0xf));
+	assert(!(ca.dmax_main & ~0xffe));
+	assert(!(ca.dmay_main & ~0xfff));
+	assert(!(ca.linesize_main & ~0x1ffc));
+	assert(!(ca.xratio_main & ~0x3ff));
+	assert(!(ca.yratio_main & ~0x3ff));
+
+	outl(ca.csr, CA_CSR);
+	outl(ca.x1r, CA_X1R);
+	outl(ca.x2r, CA_X2R);
+	outl(ca.x3r, CA_X3R);
+	outl(ca.y1r, CA_Y1R);
+	outl(ca.y2r, CA_Y2R);
+	outl(ca.dmacnt, CA_DMACNT);
+	outl(ca.od_bytelane, CA_OD_BYTELANE);
+	outl(ca.od_bytelane2, CA_OD_BYTELANE2);
+	outl(ca.frame, CA_FRAME);
+	outl(ca.dmax_main, CA_DMAX_MAIN);
+	outl(ca.dmay_main, CA_DMAY_MAIN);
+	outl(ca.linesize_main, CA_LINESIZE_MAIN);
+	outl(ca.xratio_main, CA_XRATIO_MAIN);
+	outl(ca.yratio_main, CA_YRATIO_MAIN);
+
+	debug_dump(snprintf_reg, &ca);
+
+	return ret;
+}
+
+static inline int camif_set_frame(__u32 index)
+{
+	int ret = 0;
+	struct camif_reg ca;
+
+	memset(&ca, 0, sizeof(ca));
+
+	ret = camif_set_frame_setting(&ca, index);
+
+	if (ret)
+		return ret;
+
+	assert(!(ca.yplane_a & ~0xfffffffc));
+	assert(!(ca.uvplane_a & ~0xfffffffc));
+	assert(!(ca.vplane_a & ~0xfffffffc));
+
+	outl(ca.yplane_a, CA_YPLANE_A);
+	outl(ca.uvplane_a, CA_UVPLANE_A);
+	outl(ca.vplane_a, CA_VPLANE_A);
+
+	/* debug_dump(snprintf_reg, &ca); */
+
+	return ret;
+}
+
+#if 1
+struct control_menu_info {
+	int value;
+	char name[32];
+};
+
+static const struct control_menu_info camif_ca_mirror_menus[] =
+{
+	{ 0x00, "Normal" },
+#if 0
+/* @@	{ 0x01,	"Horizontally" }, */
+/* @@	{ 0x02,	"Vertically" }, */
+/* @@	{ 0x03,	"Horizontally & Vertically" } */
+#else
+	{ 0x04, "Horizontally" },
+	{ 0x08, "Vertically" },
+	{ 0x0C, "Horizontally & Vertically" }
+#endif
+};
+#define NUM_CA_MIRROR_MENUS ARRAY_SIZE(camif_ca_mirror_menus)
+
+static const struct v4l2_queryctrl no_ctrl = {
+	.name  = "camif",
+	.flags = V4L2_CTRL_FLAG_DISABLED,
+};
+
+static const struct v4l2_queryctrl camif_ctrls[] = {
+	{
+		.id            = MP200_CID_CA_MIRROR,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Mirror Horizontally & Vertically",
+		.minimum       = 0,
+		.maximum       = (NUM_CA_MIRROR_MENUS - 1),
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_BNGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_BNGR is brightness gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CBGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CBGR is U color gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CRGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CRGR is V color gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_BNZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_BNZR is brightness offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CBZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CBZR is U color offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CRZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CRZR is V color offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}
+};
+#define NUM_CAMIF_CTRLS ARRAY_SIZE(camif_ctrls)
+#endif
+
+/* MP200_CID_CA_MIRROR */
+static inline int camif_set_ca_mirror(__u8 val)
+{
+	int ret = 0;
+
+#if 0
+/* @@	outl(val, CA_MIRROR); */
+#else
+	outl(camif_ca_mirror_menus[val].value, CA_MIRROR);
+#endif
+	camif->mirror = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_BNGR */
+static inline int camif_set_ca_bngr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_BNGR);
+	camif->bngr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_CBGR */
+static inline int camif_set_ca_cbgr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_CBGR);
+	camif->cbgr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_CRGR */
+static inline int camif_set_ca_crgr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_CRGR);
+	camif->crgr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_BNZR */
+static inline int camif_set_ca_bnzr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_BNZR);
+	camif->bnzr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_CBZR */
+static inline int camif_set_ca_cbzr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_CBZR);
+	camif->cbzr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+/* MP200_CID_CA_CRZR */
+static inline int camif_set_ca_crzr(__u8 val)
+{
+	int ret = 0;
+
+	outl(val, CA_CRZR);
+	camif->crzr = val;
+	camif->update = 1;
+
+	return ret;
+}
+
+#if 0
+struct control_menu_info {
+	int value;
+	char name[32];
+};
+
+static const struct control_menu_info camif_ca_mirror_menus[] =
+{
+	{ 0x00, "Normal" },
+#if 0
+/* @@	{ 0x01,	"Horizontally" }, */
+/* @@	{ 0x02,	"Vertically" }, */
+/* @@	{ 0x03,	"Horizontally & Vertically" } */
+#else
+	{ 0x04, "Horizontally" },
+	{ 0x08, "Vertically" },
+	{ 0x0C, "Horizontally & Vertically" }
+#endif
+};
+#define NUM_CA_MIRROR_MENUS ARRAY_SIZE(camif_ca_mirror_menus)
+
+static const struct v4l2_queryctrl no_ctrl = {
+	.name  = "camif",
+	.flags = V4L2_CTRL_FLAG_DISABLED,
+};
+
+static const struct v4l2_queryctrl camif_ctrls[] = {
+	{
+		.id            = MP200_CID_CA_MIRROR,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Mirror Horizontally & Vertically",
+		.minimum       = 0,
+		.maximum       = (NUM_CA_MIRROR_MENUS - 1),
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_BNGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_BNGR is brightness gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CBGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CBGR is U color gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CRGR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CRGR is V color gain",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 128,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_BNZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_BNZR is brightness offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CBZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CBZR is U color offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_CID_CA_CRZR,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "CA_CRZR is V color offset",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = 0,
+	}
+};
+#define NUM_CAMIF_CTRLS ARRAY_SIZE(camif_ctrls)
+
+#endif
+
+static inline const struct v4l2_queryctrl *camif_ctrl_by_id(unsigned int id)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUM_CAMIF_CTRLS; i++)
+		if (camif_ctrls[i].id == id)
+			return camif_ctrls + i;
+	return NULL;
+}
+
+static int mp200_camif_vidioc_queryctrl(struct file *file, void *fh,
+					struct v4l2_queryctrl *a)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	if (a->id <  MP200_CID_CA_MIRROR ||
+	    a->id > MP200_CID_CA_CRZR) {
+		if (cam->hw.vidioc_queryctrl)
+			ret = cam->hw.vidioc_queryctrl(file, fh, a);
+		else
+			ret = -EINVAL;
+	} else {
+		ctrl = camif_ctrl_by_id(a->id);
+		*a = (NULL != ctrl) ? *ctrl : no_ctrl;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_vidioc_querymenu(struct file *file, void *fh,
+					struct v4l2_querymenu *m)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	/* memset(m->name, 0, sizeof(m->name)); */
+	/* m->reserved = 0; */
+
+	switch (m->id) {
+	case MP200_CID_CA_MIRROR:
+		if (m->index < 0 || m->index >= NUM_CA_MIRROR_MENUS) {
+			ret = -EINVAL;
+			break;
+		}
+		strcpy(m->name, camif_ca_mirror_menus[m->index].name);
+		break;
+	default:
+		if (cam->hw.vidioc_querymenu)
+			ret = cam->hw.vidioc_querymenu(file, fh, m);
+		else
+			ret = -EINVAL;
+		break;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_vidioc_g_ctrl(struct file *file, void *fh,
+				     struct v4l2_control *c)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = camif_ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		if (cam->hw.vidioc_g_ctrl)
+			ret = cam->hw.vidioc_g_ctrl(file, fh, c);
+		else
+			ret = -EINVAL;
+		FNC_EXIT(ret)
+		return ret;
+	}
+	switch (c->id) {
+	case MP200_CID_CA_MIRROR:
+		c->value = camif->mirror;
+		break;
+	case MP200_CID_CA_BNGR:
+		c->value = camif->bngr;
+		break;
+	case MP200_CID_CA_CBGR:
+		c->value = camif->cbgr;
+		break;
+	case MP200_CID_CA_CRGR:
+		c->value = camif->crgr;
+		break;
+	case MP200_CID_CA_BNZR:
+		c->value = camif->bnzr;
+		break;
+	case MP200_CID_CA_CBZR:
+		c->value = camif->cbzr;
+		break;
+	case MP200_CID_CA_CRZR:
+		c->value = camif->crzr;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_vidioc_s_ctrl(struct file *file, void *fh,
+				     struct v4l2_control *c)
+{
+	int ret = 0;
+	int moving;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = camif_ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		if (cam->hw.vidioc_s_ctrl) {
+#if 0 /* not support V4L2_MEMORY_MMAP */
+			moving = ((cam->mapping
+				   | cam->reading
+				   | cam->streaming) ? 1 : 0);
+#else
+			moving = (cam->streaming ? 1 : 0);
+#endif
+			ret = cam->hw.vidioc_s_ctrl(file, (void *)moving, c);
+			if (!ret) {
+				if (cam->hw.prepare) {
+					cam->pre.actions = 0;
+					ret = cam->hw.prepare(&cam->pre);
+					if (ret) {
+						d1b("stop\n");
+						cam->stop = 1;
+						FNC_EXIT(ret)
+						return ret;
+					}
+					if (cam->pre.reset) {
+						cam_reset_update(0);
+						cam->reset = 1;
+					}
+				}
+			}
+			FNC_EXIT(ret)
+			return ret;
+		} else {
+			FNC_EXIT(ret)
+			return -EINVAL;
+		}
+	}
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_BOOLEAN:
+	case V4L2_CTRL_TYPE_MENU:
+	case V4L2_CTRL_TYPE_INTEGER:
+		if (c->value < ctrl->minimum)
+			c->value = ctrl->minimum;
+		if (c->value > ctrl->maximum)
+			c->value = ctrl->maximum;
+		break;
+	default:
+		/* nothing */;
+	}
+	mutex_lock(&camif->lock);
+	switch (c->id) {
+	case MP200_CID_CA_MIRROR:
+		ret = camif_set_ca_mirror(c->value);
+		break;
+	case MP200_CID_CA_BNGR:
+		ret = camif_set_ca_bngr(c->value);
+		break;
+	case MP200_CID_CA_CBGR:
+		ret = camif_set_ca_cbgr(c->value);
+		break;
+	case MP200_CID_CA_CRGR:
+		ret = camif_set_ca_crgr(c->value);
+		break;
+	case MP200_CID_CA_BNZR:
+		ret = camif_set_ca_bnzr(c->value);
+		break;
+	case MP200_CID_CA_CBZR:
+		ret = camif_set_ca_cbzr(c->value);
+		break;
+	case MP200_CID_CA_CRZR:
+		ret = camif_set_ca_crzr(c->value);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&camif->lock);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static irqreturn_t mp200_camif_handler(int irq, void *dev_id)
+{
+	int ret = 0;
+
+	camif->status = inl(CA_STATUS);
+
+	assert(!(~M_CA_ENSET & camif->status));
+
+	cam->status |= camif->status;
+
+	if (B_L1MISS & camif->status) {
+		err("%s: L1MISS fault.\n", CAM_NAME);
+		ret = IRQ_HANDLED;
+	}
+	if (B_APERR  & camif->status) {
+		err("%s: APERR fault.\n", CAM_NAME);
+		ret = IRQ_HANDLED;
+	}
+	if (B_PMERR  & camif->status) {
+		err("%s: PMERR fault.\n", CAM_NAME);
+		ret = IRQ_HANDLED;
+	}
+	if (B_MAINOR & camif->status) {
+		err("%s: MAINOR fault.\n", CAM_NAME);
+		ret = IRQ_HANDLED;
+	}
+	if (B_DMAERR & camif->status) {
+		err("%s: DMAERR fault.\n", CAM_NAME);
+		ret = IRQ_HANDLED;
+	}
+
+	if (ret) {
+		outl(M_CA_ENSET, CA_ENCLR);
+		outl(M_CA_ENSET, CA_FFCLR);
+		d1b("stop\n");
+		cam->stop = 1;
+		if (cam->grab->update)
+			cam->grab->update(cam);
+		return ret;
+	}
+
+	ret = IRQ_HANDLED;
+
+	if (B_CAMVS & camif->status) {
+		if (camif->update) {
+			outl(camif->update, CA_UPDATE);
+			camif->update = 0;
+		}
+	}
+
+	if (B_MAINTC & camif->status) {
+		if (cam->grab->update)
+			cam->grab->update(cam);
+	}
+
+	outl(camif->status, CA_FFCLR);
+
+	return ret;
+}
+
+static int mp200_camif_running(int flag)
+{
+	return inl(CA_DMAREQ) ? 1 : 0;
+}
+
+static int mp200_camif_restart(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	/* module reset */
+	outl(0, CA_MODULECONT);
+
+	schedule_timeout_uninterruptible(1);
+
+	/* initial */
+	ret = camif_set_setting(0);
+
+	/* module unreset */
+	outl(1, CA_MODULECONT);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_capture(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	outl(0x01, CA_DMAREQ);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_prepare(__u32 index)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (cam->setup) {
+		cam->pre.width = cam->width;
+		cam->pre.height = cam->height;
+		cam->pre.c = cam->c;
+#if 1 /* XXX */
+		ret = mp200_camif_restart(0);
+#else
+		ret = camif_set_setting(0);
+#endif
+
+		if (ret) {
+			FNC_EXIT(ret)
+			return ret;
+		}
+
+		outl(1, CA_UPDATE);
+		cam->setup = 0;
+	}
+
+	ret = camif_set_frame(index);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+#if 1
+static void mp200_camif_unreset(void)
+{
+	/* module unreset */
+	outl(1, CA_MODULECONT);
+	outl(1, CA_UPDATE);
+}
+#endif
+
+static int mp200_camif_startup(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	/* change pin select */
+	camif_chg_pinsel();
+
+	/* start clock */
+	camif_start_clock();
+
+	/* irq */
+	camif_irq_enclr();
+
+	ret = request_irq(INT_CAM, mp200_camif_handler,
+			  IRQF_DISABLED, "CAMIF", (void *)cam);
+
+	if (ret) {
+		FNC_EXIT(-ENODEV)
+		return -ENODEV;
+	}
+
+	outl(M_CA_ENSET, CA_ENSET);
+
+	/* initial */
+	ret = camif_set_setting(0);
+
+#if 0
+	/* module unreset */
+/* @@	outl(1, CA_MODULECONT); */
+/* @@	outl(1, CA_UPDATE); */
+#else
+/*	mp200_camif_unreset(); */
+#endif
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_shutdown(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	/* module reset */
+	outl(0, CA_MODULECONT);
+
+	/* irq */
+	camif_irq_enclr();
+
+	free_irq(INT_CAM, (void *)cam);
+
+	/* stop clock */
+	camif_stop_clock();
+
+	/* irq */
+	outl(M_CA_ENSET, CA_ENSET);
+
+	/* initial */
+	ret = camif_set_setting(0);
+
+	/* module unreset */
+	outl(1, CA_MODULECONT);
+	outl(1, CA_UPDATE);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_unregister(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	kfree(camif);
+	camif = NULL;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_camif_register(int flag)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+
+	camif = kzalloc(sizeof(*camif), GFP_KERNEL);
+
+	if (NULL == camif)
+		return -ENOMEM;
+
+	/* initial camif */
+	mutex_init(&camif->lock);
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_MIRROR);
+	camif->mirror  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_BNGR);
+	camif->bngr  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_CBGR);
+	camif->cbgr  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_CRGR);
+	camif->crgr  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_BNZR);
+	camif->bnzr  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_CBZR);
+	camif->cbzr  = ctrl->default_value;
+
+	ctrl = camif_ctrl_by_id(MP200_CID_CA_CRZR);
+	camif->crzr  = ctrl->default_value;
+
+	return ret;
+}
+
+/*
+ * Tools
+ */
+static inline int no_active(__u32 number)
+{
+	return (cam->active_number == number) ? 0 : 1;
+}
+
+static const struct v4l2_queryctrl cam_ctrls[] = {
+#if 0 /* not supported */
+/* @@	{ */
+/* @@		.id            = MP200_CID_IPU, */
+/* @@		.type          = V4L2_CTRL_TYPE_BOOLEAN, */
+/* @@		.name          = "Use a image processor", */
+/* @@		.minimum       = 0, */
+/* @@		.maximum       = 1, */
+/* @@		.step          = 1, */
+/* @@		.default_value = 1, */
+/* @@		.flags         = 0, */
+/* @@	} */
+#endif
+#if MP200_CAM_NON_PMMU
+#else
+	{
+		.id            = MP200_CID_PMMU,
+		.type          = V4L2_CTRL_TYPE_BOOLEAN,
+		.name          = "Use a peripheral MMU",
+		.minimum       = 0,
+		.maximum       = 1,
+		.step          = 1,
+		.default_value = 1,
+		.flags         = 0,
+	}
+#endif
+};
+#define NUM_CAM_CTRLS ARRAY_SIZE(cam_ctrls)
+
+static inline const struct v4l2_queryctrl *cam_ctrl_by_id(unsigned int id)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUM_CAM_CTRLS; i++)
+		if (cam_ctrls[i].id == id)
+			return cam_ctrls + i;
+	return NULL;
+}
+
+#define FORMAT_FLAGS_PACKED       0x00
+#define FORMAT_FLAGS_PLANAR       0x01
+
+static const struct mp200_cam_fmt cam_formats[] = {
+	{
+#if 0 /* not supported */
+/* @@		.description	= "RGB24", */
+/* @@		.pixelformat	= V4L2_PIX_FMT_RGB24, */
+/* @@		.depth		= 24, */
+/* @@		.flags		= FORMAT_FLAGS_PACKED, */
+/* @@		.boundary	= 1, */
+/* @@	},{ */
+/* @@		.description	= "RGB565", */
+/* @@		.pixelformat	= V4L2_PIX_FMT_RGB565, */
+/* @@		.depth		= 16, */
+/* @@		.flags		= FORMAT_FLAGS_PACKED, */
+/* @@		.boundary	= 1, */
+/* @@	},{ */
+#endif
+		.description    = "YUYV : YUV422 Interleave",
+		/* Y U Y V Y U Y V Y U Y V Y U Y V Y U Y V */
+		.pixelformat    = V4L2_PIX_FMT_YUYV,
+		/* Y U Y V Y U Y V Y U Y V Y U Y V Y U Y V */
+		.depth          = 16,
+		.flags          = FORMAT_FLAGS_PACKED,
+		.boundary       = 1,
+	}, {
+#if 0 /* not supported */
+/* @@		.description	= "UYVY : YUV 422 Interleave",
+   / * U Y V Y U Y V Y U Y V Y U Y V Y U Y V Y * / */
+/* @@		.pixelformat	= V4L2_PIX_FMT_UYVY,
+   / * U Y V Y U Y V Y U Y V Y U Y V Y U Y V Y * / */
+/* @@		.depth		= 16, */
+/* @@		.flags		= FORMAT_FLAGS_PACKED, */
+/* @@		.boundary	= 1, */
+/* @@	},{ */
+#endif
+		.description    = "YUV422P : YUV 422 Planar",
+		/* Y Y Y Y Y Y Y Y */
+		.pixelformat    = V4L2_PIX_FMT_YUV422P,
+		/* Y Y Y Y Y Y Y Y */
+		.depth          = 16,
+		/* U U U U U U U U */
+		.flags          = FORMAT_FLAGS_PLANAR,
+		/* V V V V V V V V */
+		.boundary       = 3,
+	}, {
+		.description    = "NV422 : YUV 422 Semi-Planar",
+		/* Y Y Y Y Y Y Y Y */
+		.pixelformat    = V4L2_PIX_FMT_NV422,
+		/* Y Y Y Y Y Y Y Y */
+		.depth          = 16,
+		/* U V U V U V U V */
+		.flags          = FORMAT_FLAGS_PLANAR,
+		/* U V U V U V U V */
+		.boundary       = 2,
+	}, {
+		.description    = "YUV420 : YUV 420 Planar",
+		/* Y Y Y Y Y Y Y Y */
+		.pixelformat    = V4L2_PIX_FMT_YUV420,
+		/* Y Y Y Y Y Y Y Y */
+		.depth          = 12,
+		/* U U U U         */
+		.flags          = FORMAT_FLAGS_PLANAR,
+		/* V V V V         */
+		.boundary       = 3,
+#if 0 /* not supported */
+/* @@	},{ */
+/* @@		.description	= "YVU420 : YUV 420 Planar",
+/ * Y Y Y Y Y Y Y Y * / */
+/* @@		.pixelformat	= V4L2_PIX_FMT_YVU420,
+/ * Y Y Y Y Y Y Y Y * / */
+/* @@		.depth		= 12,
+/ * V V V V         * / */
+/* @@		.flags		= FORMAT_FLAGS_PLANAR,
+/ * U U U U         * / */
+/* @@		.boundary	= 3, */
+#endif
+	}, {
+		.description    = "NV12 : YUV 420 Semi-Planar",
+		/* Y Y Y Y Y Y Y Y */
+		.pixelformat    = V4L2_PIX_FMT_NV12,
+		/* Y Y Y Y Y Y Y Y */
+		.depth          = 12,
+		/* U V U V U V U V */
+		.flags          = FORMAT_FLAGS_PLANAR,
+		.boundary       = 2,
+#if 0 /* not supported */
+/* @@	},{ */
+/* @@		.description	= "NV21 : YUV 420 Semi-Planar",
+/ * Y Y Y Y Y Y Y Y * / */
+/* @@		.pixelformat	= V4L2_PIX_FMT_NV21,
+/ * Y Y Y Y Y Y Y Y * / */
+/* @@		.depth		= 12,
+/ * V U V U V U V U * / */
+/* @@		.flags		= FORMAT_FLAGS_PLANAR, */
+/* @@		.boundary	= 2, */
+#endif
+	}
+};
+#define NUM_CAM_FORMATS ARRAY_SIZE(cam_formats)
+
+static const struct mp200_cam_fmt rgb_input = {
+	.description    = "YUV 422 Interleave",
+	.pixelformat    = 0, /* dummy */
+	.depth          = 16,
+	.flags          = FORMAT_FLAGS_PACKED,
+	.boundary       = 1,
+};
+
+static inline const struct mp200_cam_fmt *format_by_pixelformat(
+	__u32 pixelformat)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUM_CAM_FORMATS; i++)
+		if (cam_formats[i].pixelformat == pixelformat)
+			return cam_formats + i;
+
+	return NULL;
+}
+
+static inline __u32 get_sizeimage(const struct mp200_cam_fmt *fmt,
+				  __u32 width, __u32 height,
+				  __u32 *bytesperline)
+{
+	__u32 sizeimage;
+
+	if (fmt->flags & FORMAT_FLAGS_PLANAR) {
+		*bytesperline = width; /* Y plane */
+		sizeimage = (width * height * fmt->depth) >> 3;
+	} else {
+		*bytesperline = (width * fmt->depth) >> 3;
+		sizeimage = height * *bytesperline;
+	}
+
+	return sizeimage;
+}
+
+static inline void pix_format_set_size(struct v4l2_pix_format *f,
+				       const struct mp200_cam_fmt *fmt,
+				       __u32 width, __u32 height)
+{
+	f->width = width;
+	f->height = height;
+
+	f->sizeimage = get_sizeimage(fmt, width, height, &f->bytesperline);
+}
+
+static inline int check_reset_fmt(const struct mp200_cam_fmt *src,
+				  const struct mp200_cam_fmt *dir)
+{
+	int reset = 0;
+
+	if (src->depth != dir->depth)
+		reset = 1;
+	if (V4L2_PIX_FMT_RGB24 == src->pixelformat
+	    && V4L2_PIX_FMT_RGB24 != dir->pixelformat) {
+		reset = 1;
+	}
+	if (V4L2_PIX_FMT_RGB565 == src->pixelformat
+	    && V4L2_PIX_FMT_RGB565 != dir->pixelformat) {
+		reset = 1;
+	}
+
+	return reset;
+}
+
+static inline unsigned int __kfifo_try_get(struct kfifo *fifo,
+					   unsigned char *buffer,
+					   unsigned int len)
+{
+	unsigned int l;
+
+	len = min(len, fifo->in - fifo->out);
+
+	/*
+	 * Ensure that we sample the fifo->in index -before- we
+	 * start removing bytes from the kfifo.
+	 */
+
+	smp_rmb();
+
+	/* first get the data from fifo->out until the end of the buffer */
+	l = min(len, fifo->size - (fifo->out & (fifo->size - 1)));
+	memcpy(buffer, fifo->buffer + (fifo->out & (fifo->size - 1)), l);
+
+	/* then get the rest (if any) from the beginning of the buffer */
+	memcpy(buffer + l, fifo->buffer, len - l);
+
+	/*
+	 * Ensure that we remove the bytes from the kfifo -before-
+	 * we update the fifo->out index.
+	 */
+
+	smp_mb();
+
+	/* fifo->out += len; */
+
+	return len;
+}
+
+static inline unsigned int kfifo_try_get(struct kfifo *fifo,
+					 unsigned char *buffer,
+					 unsigned int len)
+{
+	unsigned long flags;
+	unsigned int i = len;
+	unsigned int ret;
+
+	spin_lock_irqsave(fifo->lock, flags);
+
+	ret = __kfifo_try_get(fifo, buffer, len);
+	len = fifo->in - fifo->out;
+
+	spin_unlock_irqrestore(fifo->lock, flags);
+
+	assert((0 == ret || 1 == (ret / i)));
+
+	ret = len / i;
+
+	return ret;
+}
+
+static inline void deq_done_pushq(unsigned int q)
+{
+	unsigned int ret;
+
+	ret = kfifo_put(cam->deq_done, (unsigned char *)&q, sizeof(int));
+
+	assert(1 == (ret / sizeof(int)));
+
+	return;
+}
+
+
+static inline unsigned int deq_done_pullq(void)
+{
+	unsigned int buf;
+	unsigned int ret;
+
+	ret = kfifo_get(cam->deq_done, (unsigned char *)&buf, sizeof(int));
+
+	assert(1 == (ret / sizeof(int)));
+
+	return buf;
+}
+
+static inline unsigned int deq_done_peepq(unsigned int *q)
+{
+	return kfifo_try_get(cam->deq_done, (unsigned char *)q, sizeof(int));
+}
+
+static inline void deq_grab_pushq(unsigned int q)
+{
+	unsigned int ret;
+
+	ret = kfifo_put(cam->deq_grab, (unsigned char *)&q, sizeof(int));
+
+	assert(1 == (ret / sizeof(int)));
+
+	return;
+}
+
+static inline unsigned int deq_grab_pullq(void)
+{
+	unsigned int buf;
+	unsigned int ret;
+
+	ret = kfifo_get(cam->deq_grab, (unsigned char *)&buf, sizeof(int));
+
+	assert(1 == (ret / sizeof(int)));
+
+	return buf;
+}
+
+static inline unsigned int deq_grab_peepq(unsigned int *q)
+{
+	return kfifo_try_get(cam->deq_grab, (unsigned char *)q, sizeof(int));
+}
+
+static inline void enq_pushq(struct mp200_enq_index q,
+			     struct mp200_cam_frames *frm)
+{
+	unsigned long flags;
+	unsigned int ret;
+	struct kfifo *fifo = frm->enq;
+
+	spin_lock_irqsave(fifo->lock, flags);
+
+	ret = __kfifo_put(fifo, (unsigned char *)&q,
+			  sizeof(struct mp200_enq_index));
+
+	frm->cnt++;
+	if (frm->cnt >= frm->max)
+		frm->cnt = 0;
+
+	spin_unlock_irqrestore(fifo->lock, flags);
+
+	assert(1 == (ret / sizeof(q)));
+
+	return;
+}
+
+static inline struct mp200_enq_index enq_pullq(struct mp200_cam_frames *frm)
+{
+	struct mp200_enq_index buf;
+	unsigned int ret;
+
+	ret = kfifo_get(frm->enq, (unsigned char *)&buf,
+			sizeof(struct mp200_enq_index));
+
+	assert(1 == (ret / sizeof(struct mp200_enq_index)));
+
+	return buf;
+}
+
+static inline void done_pushq(struct mp200_enq_index q)
+{
+	enq_pushq(q, cam->done);
+
+	return;
+}
+
+static inline struct mp200_enq_index done_pullq(void)
+{
+	return enq_pullq(cam->done);
+}
+
+static inline unsigned int done_peepq(struct mp200_enq_index *q)
+{
+	return kfifo_try_get(cam->done->enq, (unsigned char *)q,
+			     sizeof(struct mp200_enq_index));
+}
+
+static inline void grab_pushq(struct mp200_enq_index q)
+{
+	enq_pushq(q, cam->grab);
+
+	return;
+}
+
+static inline struct mp200_enq_index grab_pullq(void)
+{
+	return enq_pullq(cam->grab);
+}
+
+static inline unsigned int grab_peepq(struct mp200_enq_index *q)
+{
+	return kfifo_try_get(cam->grab->enq, (unsigned char *)q,
+			     sizeof(struct mp200_enq_index));
+}
+
+static inline unsigned int deq_peepq(unsigned int *i, struct kfifo *q)
+{
+	return kfifo_try_get(q, (unsigned char *)i, sizeof(int));
+}
+
+static inline void deq_pushq(unsigned int grab)
+{
+	struct mp200_enq_index q;
+
+	memset(&q, 0, sizeof(q));
+
+	if (cam->done == cam->grab) {
+		q.grab = grab;
+		q.done = grab;
+		cam->done->buff[q.done].state = CAM_BUF_QUEUED;
+	} else {
+		q.grab = cam->grab->cnt;
+		cam->grab->buff[q.grab].state = CAM_BUF_QUEUED;
+		q.done = grab;
+		cam->done->buff[q.done].state = CAM_BUF_QUEUED;
+	}
+
+	deq_grab_pushq(q.grab);
+	deq_done_pushq(q.done);
+	grab_pushq(q);
+
+	return;
+}
+
+static int mp200_cam_done_ipu_handler(void *p);
+static int mp200_cam_done_cpu_handler(void *p);
+static int mp200_cam_grab_handler(void *p);
+static int mp200_cam_grabs_handler(void *p);
+static int mp200_cam_ipu_regist(int flag);
+static int mp200_cam_convert(int flag);
+static ssize_t mp200_cam_read_convert(char *buf, __u32 index,
+				      __u32 cnt, __u32 bpl);
+
+static void release_userptr(struct mp200_cam_buffer *buff)
+{
+	if (buff->m.userptr) {
+		iounmap((void *)buff->vadr);
+		buff->vadr = NULL;
+		buff->padr = 0;
+		buff->m.userptr = 0;
+	}
+
+	return;
+}
+
+static int request_userptr(struct mp200_cam_buffer *buff,
+			   unsigned long userptr, __u32 length)
+{
+	int ret = 0;
+
+	debug_snprintf("%s(%p, %lu, %d)\n",
+		       __func__, buff, userptr, length);
+
+	buff->vadr = ioremap(userptr, length);
+
+	if (buff->vadr) {
+		buff->padr = userptr;
+		buff->m.userptr = userptr;
+	} else {
+		err("%s: userptr can't set up page mapping.\n", CAM_NAME);
+		ret = -EINVAL;
+		buff->vadr = NULL;
+		buff->padr = 0;
+		buff->m.userptr = 0;
+	}
+
+	return ret;
+}
+
+static void release_frm_userptr(struct mp200_cam_frames *frms)
+{
+	int i;
+	__u32 count = frms->max;
+
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	for (i = 0; i < count; i++)
+		release_userptr(&frms->buff[i]);
+
+	return;
+}
+
+static inline void release_ipu(void)
+{
+	kfree(ipu_req);
+
+	ipu_reg_info = NULL;
+	ipu_req = NULL;
+
+	return;
+}
+
+static inline int request_ipu(void)
+{
+	ipu_req = kzalloc(sizeof(*ipu_req)
+			  + IPU_MAX_REG_INFO * sizeof(*ipu_reg_info),
+			  GFP_KERNEL);
+
+	if (NULL == ipu_req) {
+		warn("%s: ipu_req allocation failed.\n", CAM_NAME);
+		goto out_request_ipu_buffer;
+	}
+
+	ipu_reg_info = ipu_req->ipu_reg_info;
+
+	return 0;
+
+out_request_ipu_buffer:
+
+	return -ENOMEM;
+}
+
+#if MP200_CAM_NON_PMMU
+/* 0x38000000 - 0x39808000 Camera Frame 25198592 byte M2 MemMap v1.4 */
+#define CAMERA_FRAME_BASE       (unsigned long)0x38000000
+#define CAMERA_FRAME_SIZE       (6152 * 4096)
+
+static unsigned long camera_frame_offset;
+
+static void free_fixed_buffer(struct mp200_cam_frames *frms)
+{
+	int i;
+	__u32 count = frms->max;
+
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	iounmap((void *)frms->buff[0].vadr);
+
+	for (i = 0; i < count; i++) {
+		frms->buff[i].vadr = NULL;
+		frms->buff[i].padr = 0;
+		frms->buff[i].m.offset = 0;
+	}
+
+	return;
+}
+
+static int alloc_fixed_buffer(__u32 count, size_t blocksize,
+			      struct mp200_cam_buffer *buff)
+{
+	int i = 0;
+	char *vadr = NULL;
+	unsigned long camera_frame = CAMERA_FRAME_BASE + camera_frame_offset;
+	unsigned long frame_size = CAMERA_FRAME_SIZE - camera_frame_offset;
+
+	debug_snprintf("%s(%d, %d, %p)\n",
+		       __func__, count, blocksize, buff);
+
+	for (i = count; i > 0; i--) {
+		if (frame_size > blocksize * i)
+			break;
+	}
+
+	if (!i) {
+		err("%s: no buffer.\n", CAM_NAME);
+		return 0;
+	}
+
+	count = i;
+
+	vadr = ioremap(camera_frame, blocksize * count);
+
+	for (i = 0; i < count; i++) {
+		buff[i].index = i;
+		buff[i].m.offset = blocksize * i;
+		buff[i].vadr = vadr + (blocksize * i);
+		buff[i].padr = camera_frame + (blocksize * i);
+	}
+
+	camera_frame_offset += blocksize * count;
+
+	return i;
+}
+
+static void release_frame_buff(struct mp200_cam_frames *frm)
+{
+
+	if (V4L2_MEMORY_MMAP == frm->memory) {
+		switch (frm->buf_type) {
+		case BUF_IPU:
+			release_ipu();
+		default:
+			free_fixed_buffer(frm);
+		}
+	} else {
+		release_frm_userptr(frm);
+		cam->userptr   = 0;
+		switch (frm->buf_type) {
+		case BUF_IPU:
+			release_ipu();
+			break;
+		default:
+			;
+		}
+	}
+
+	frm->max = 0;
+	frm->blocksize = 0;
+	frm->memory = 0;
+	kfree(frm->buff);
+	frm->buff = NULL;
+
+	return;
+}
+
+static int request_frame_buff(struct mp200_cam_frames *frm,
+			      __u32 count, const struct mp200_cam_fmt *fmt,
+			      enum v4l2_memory memory, int buf_type)
+{
+	__u32 blocksize, bpl;
+
+	frm->buff = kzalloc(count * sizeof(*cam->grab->buff), GFP_KERNEL);
+
+	if (NULL == frm->buff) {
+		err("%s: frame info allocation failed\n", CAM_NAME);
+		return 0;
+	}
+
+	blocksize = get_sizeimage(fmt, cam->bounds.width,
+				  cam->bounds.height, &bpl);
+
+	blocksize = PAGE_ALIGN(blocksize);
+
+	if (V4L2_MEMORY_MMAP == memory) {
+		switch (buf_type) {
+		case BUF_IPU:
+			if (request_ipu()) {
+				count = 0;
+				break;
+			}
+		default:
+			count = alloc_fixed_buffer(count,
+						   blocksize, frm->buff);
+		}
+	} else {
+		cam->userptr   = 1;
+		switch (buf_type) {
+		case BUF_IPU:
+			if (0 > request_ipu())
+				count = 0;
+			break;
+		default:
+			;
+		}
+	}
+
+	if (count) {
+		frm->max = count;
+		frm->blocksize = blocksize;
+		frm->memory = memory;
+		frm->fmt = fmt;
+		frm->buf_type = buf_type;
+	} else {
+		frm->max = 0;
+		frm->blocksize = 0;
+		frm->memory = 0;
+		kfree(frm->buff);
+		frm->buff = NULL;
+	}
+
+	frm->cnt = 0;
+
+	return count;
+}
+
+static int request_doubling_buffers(__u32 count, enum v4l2_memory memory)
+{
+	int ret = 0;
+	int piece = 2;
+
+	cam->done = kzalloc(sizeof(*cam->done), GFP_KERNEL);
+
+	if (NULL == cam->done) {
+		warn("%s: done buffer allocation failed.\n", CAM_NAME);
+		goto out_request_doubling_buffers;
+	}
+
+	init_waitqueue_head(&cam->done->proc_list);
+
+	cam->done->enq = kfifo_alloc(sizeof(struct mp200_enq_index) * count,
+				     GFP_KERNEL, &cam->done->enq_lock);
+
+	if (IS_ERR(cam->done->enq)) {
+		warn("%s: done fifo allocation failed.\n", CAM_NAME);
+		goto out_kfree_done;
+	}
+
+	kfifo_reset(cam->done->enq);
+
+#if 1 /* mp200 cam admit one piece */
+	{
+		__u32 limitsize, blocksize, bpl;
+
+#if 1 /* XXX */
+		limitsize = get_sizeimage(&rgb_input, 640, 480, &bpl);
+#else
+		limitsize = get_sizeimage(&rgb_input, 2048, 1536, &bpl);
+#endif
+		blocksize = get_sizeimage(&rgb_input, cam->bounds.width,
+					  cam->bounds.height, &bpl);
+
+		if (limitsize < blocksize)
+			piece = 1;
+	}
+#endif
+	ret = request_frame_buff(cam->grab, piece, &rgb_input,
+				 V4L2_MEMORY_MMAP, BUF_FIXED);
+
+	if (0 == ret)
+		goto out_kfifo_free_done;
+#if 0 /* mp200 cam admit one piece */
+	else if (2 > ret) {
+		warn("%s: not enough grab buffers.\n", CAM_NAME);
+		ret = 0;
+		goto out_release_grab_buffer;
+	}
+#endif
+
+#if 1 /* mp200 cam admit one piece */
+	if (1 == piece)
+		count = 1;
+#endif
+	ret = request_frame_buff(cam->done, count, cam->fmt,
+				 memory, (cam->ipu) ? BUF_IPU : BUF_FIXED);
+
+	if (0 == ret)
+		goto out_release_grab_buffer;
+#if 0 /* mp200 cam admit one piece */
+	else if (2 > ret) {
+		warn("%s: not enough done buffers.\n", CAM_NAME);
+		ret = 0;
+		goto out_release_done_buffer;
+	}
+#endif
+
+	return ret;
+
+#if 0 /* mp200 cam admit one piece */
+out_release_done_buffer:
+	release_frame_buff(cam->done);
+#endif
+out_release_grab_buffer:
+	release_frame_buff(cam->grab);
+out_kfifo_free_done:
+	kfifo_free(cam->done->enq);
+out_kfree_done:
+	kfree(cam->done);
+	cam->done = NULL;
+out_request_doubling_buffers:
+
+	return ret;
+}
+
+static void cam_release_buffers(int flag)
+{
+	if (!cam->done)
+		goto out_release_buffers;
+
+	/* doubling buffers */
+	if (cam->done != cam->grab) {
+		release_frame_buff(cam->done);
+		kfifo_free(cam->done->enq);
+		kfree(cam->done);
+		cam->done = NULL;
+	}
+
+	cam->done = NULL;
+	release_frame_buff(cam->grab);
+
+	camera_frame_offset = 0;
+
+out_release_buffers:
+
+	return;
+}
+
+static int cam_request_buffers(int action, __u32 count,
+			       enum v4l2_memory memory)
+{
+	/* action 0:mmap, 1:read */
+	int ret = 0;
+	int i = 0, doubling = 0;
+
+	debug_dump(snprintf_fmt, cam->fmt);
+
+	switch (cam->fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_RGB565:
+		if (!action || cam->ipu)
+			doubling = 1;
+		break;
+	default:
+		/* nothing */;
+	}
+
+	if (doubling) {
+		i = request_doubling_buffers(count, memory);
+		if (i) {
+			debug_dump(snprintf_frm, cam->grab);
+			debug_dump(snprintf_buffs, cam->grab->buff,
+				   cam->grab->max, cam->grab->memory);
+			debug_dump(snprintf_frm, cam->done);
+			debug_dump(snprintf_buffs, cam->done->buff,
+				   cam->done->max, cam->done->memory);
+		} else {
+			ret = -ENOMEM;
+		}
+	} else {
+		int piece = count;
+
+#if 1 /* mp200 cam admit one piece */
+		{
+			__u32 limitsize, blocksize, bpl;
+
+			limitsize = get_sizeimage(&rgb_input, 640, 480, &bpl);
+			blocksize = get_sizeimage(&rgb_input,
+						  cam->bounds.width,
+						  cam->bounds.height, &bpl);
+
+			if (limitsize < blocksize)
+				piece = 1;
+		}
+#endif
+
+		i = request_frame_buff(cam->grab, piece, cam->fmt,
+				       memory, BUF_FIXED);
+
+		if (i) {
+			cam->done = cam->grab;
+			debug_dump(snprintf_frm, cam->grab);
+			debug_dump(snprintf_buffs, cam->grab->buff,
+				   cam->grab->max, cam->grab->memory);
+		} else {
+			ret = -ENOMEM;
+		}
+	}
+
+	if (!ret)
+		cam->reset = 0;
+
+	return ret;
+}
+#else
+/* CA_MMU_MODE */
+static int mp200_camif_mmu(int flag)
+{
+	/* flag 0 : OFF, 1 : ON */
+	int ret = 0;
+
+	if (flag) {
+		outl((B_CHK_PERMISSION | B_CHK_PAGE), CA_MMU_MODE);
+		outl((inl(CA_MMU_MODE) | B_MMU_EN), CA_MMU_MODE);
+	} else {
+		outl((inl(CA_MMU_MODE) & ~B_MMU_EN), CA_MMU_MODE);
+	}
+
+	debug_snprintf("CA_MMU_MODE(0x%08x)\n", inl(CA_MMU_MODE));
+
+	return ret;
+}
+
+static void release_dma_coherent(struct mp200_cam_frames *frms)
+{
+	int i;
+	__u32 count = frms->max;
+	size_t blocksize = frms->blocksize;
+
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	for (i = 0; i < count; i++) {
+		dma_free_coherent(NULL, blocksize, frms->buff[i].vadr,
+				  frms->buff[i].padr);
+		frms->buff[i].vadr   = NULL;
+		frms->buff[i].padr   = 0;
+		frms->buff[i].m.offset = 0;
+	}
+
+	return;
+}
+
+static int request_dma_coherent(__u32 count, size_t blocksize,
+				struct mp200_cam_buffer *buff)
+{
+	int i;
+	char *vadr;
+	unsigned long padr;
+
+	debug_snprintf("%s(%d, %d, %p)\n",
+		       __func__, count, blocksize, buff);
+
+	for (i = 0; i < count; i++) {
+		vadr = dma_alloc_coherent(NULL, (int)blocksize,
+					  (void *)&padr, GFP_KERNEL | GFP_DMA);
+		if (NULL == vadr)
+			return i;
+		buff[i].index = i;
+		buff[i].m.offset = blocksize * i;
+		buff[i].vadr = vadr;
+		buff[i].padr = padr;
+	}
+
+	if (!i)
+		err("%s: dma_alloc_coherent allocation failed\n", CAM_NAME);
+
+	return i;
+}
+
+
+static void vfree_buffer(struct mp200_cam_frames *frms)
+{
+	int i;
+	__u32 count = frms->max;
+
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	vfree(frms->buff[0].vadr);
+
+	for (i = 0; i < count; i++) {
+		frms->buff[i].vadr = NULL;
+		frms->buff[i].padr = 0;
+		frms->buff[i].m.offset = 0;
+	}
+
+	return;
+}
+
+static int vmalloc_buffer(__u32 count, size_t blocksize,
+			  struct mp200_cam_buffer *buff, int pmmu)
+{
+	int i;
+	char *vadr = NULL;
+
+	debug_snprintf("%s(%d, %d, %p, %d)\n",
+		       __func__, count, blocksize, buff, pmmu);
+
+	for (i = count; i > 0; i--) {
+		if (pmmu) {
+			vadr = (char *)__vmalloc(blocksize * i,
+						 GFP_KERNEL | __GFP_HIGHMEM,
+						 pgprot_noncached(PAGE_KERNEL));
+		} else {
+			vadr = (char *)vmalloc(blocksize * i);
+		}
+
+		if (vadr)
+			break;
+	}
+
+	if (!i) {
+		err("%s: vmalloc allocation failed\n", CAM_NAME);
+		return 0;
+	}
+
+	count = i;
+
+	for (i = 0; i < count; i++) {
+		buff[i].index = i;
+		buff[i].m.offset = blocksize * i;
+		buff[i].vadr = vadr + (blocksize * i);
+		buff[i].padr = (unsigned long)buff[i].vadr;
+	}
+
+	return i;
+}
+
+static void free_ipu_pmmu_buffer(struct mp200_cam_frames *frms)
+{
+	int i;
+	__u32 count = frms->max;
+	size_t blocksize = frms->blocksize;
+
+	debug_snprintf("mp200_ipu_pmmu_unmap(IPU_HW_FUNC_IMG,%p,%d)\n",
+		       frms->buff[0].vadr, (blocksize * count));
+
+	mp200_ipu_pmmu_unmap(IPU_HW_FUNC_IMG,
+			     frms->buff[0].vadr, (blocksize * count));
+
+	for (i = 0; i < count; i++) {
+		frms->buff[i].vadr   = NULL;
+		frms->buff[i].padr   = 0;
+		frms->buff[i].m.offset = 0;
+	}
+
+	return;
+}
+
+static int alloc_ipu_pmmu_buffer(__u32 count, size_t blocksize,
+				 struct mp200_cam_buffer *buff)
+{
+	int i;
+	char *vadr = NULL;
+
+	for (i = count; i > 0; i--) {
+		debug_snprintf("mp200_ipu_pmmu_map(IPU_HW_FUNC_IMG,%d)\n",
+			       (blocksize * i));
+		vadr = (char *)mp200_ipu_pmmu_map(IPU_HW_FUNC_IMG,
+						  (blocksize * i));
+		if ((unsigned long)vadr >= VMALLOC_START
+		    && (unsigned long)vadr < VMALLOC_END) {
+			break;
+		}
+	}
+
+	if (!i) {
+		err("%s: mp200_ipu_pmmu_map allocation failed %d\n",
+		    CAM_NAME, (int)vadr);
+		return 0;
+	}
+
+	count = i;
+
+	for (i = 0; i < count; i++) {
+		buff[i].index = i;
+		buff[i].m.offset = blocksize * i;
+		buff[i].vadr = vadr + (blocksize * i);
+		buff[i].padr = (unsigned long)buff[i].vadr;
+	}
+
+	return i;
+}
+
+static void *pmmu_id;
+
+static void release_pmmu_buffer(struct mp200_cam_frames *frms)
+{
+	__u32 count = frms->max;
+	size_t blocksize = frms->blocksize;
+
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	debug_snprintf("mp200_pmmu_unmap(%p,%p,%d,0)\n",
+		       pmmu_id, frms->buff[0].vadr, (blocksize * count));
+	mp200_pmmu_unmap(pmmu_id, frms->buff[0].vadr,
+			 (blocksize * count), 0);
+	if (BUF_PMMU == frms->buf_type)
+		vfree_buffer(frms);
+	else
+		free_ipu_pmmu_buffer(frms);
+
+	return;
+}
+
+static int request_pmmu_buffer(__u32 count, size_t blocksize,
+			       struct mp200_cam_buffer *buff, int buf_type)
+{
+	int i;
+
+	debug_snprintf("%s(%d, %d, %p)\n",
+		       __func__, count, blocksize, buff);
+
+	if (BUF_PMMU == buf_type)
+		i = vmalloc_buffer(count, blocksize, buff, CAM_PMMU_ON);
+	else
+		i = alloc_ipu_pmmu_buffer(count, blocksize, buff);
+
+	if (i) {
+		debug_snprintf("mp200_pmmu_map(%p,%p,%d,0)\n",
+			       pmmu_id, buff[0].vadr, (blocksize * i));
+		mp200_pmmu_map(pmmu_id, buff[0].vadr, (blocksize * i), 0);
+	}
+
+	return i;
+}
+
+static void release_ipu_buffer(struct mp200_cam_frames *frms)
+{
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	release_dma_coherent(frms);
+	release_ipu();
+
+	return;
+}
+
+static int request_ipu_buffer(__u32 count, size_t blocksize,
+			      struct mp200_cam_buffer *buff)
+{
+	int i;
+
+	debug_snprintf("%s(%d, %d, %p)\n",
+		       __func__, count, blocksize, buff);
+
+	i = request_ipu();
+
+	if (0 > i)
+		return 0;
+
+	i = request_dma_coherent(count, blocksize, buff);
+
+	if (0 >= i)
+		release_ipu();
+
+	return i;
+}
+
+static void release_ipu_pmmu_buffer(struct mp200_cam_frames *frms)
+{
+	debug_snprintf("%s(%p)\n", __func__, frms);
+
+	free_ipu_pmmu_buffer(frms);
+
+	release_ipu();
+
+	return;
+}
+
+static int request_ipu_pmmu_buffer(__u32 count, size_t blocksize,
+				   struct mp200_cam_buffer *buff)
+{
+	int i;
+
+	debug_snprintf("%s(%d, %d, %p)\n",
+		       __func__, count, blocksize, buff);
+
+	i = request_ipu();
+
+	if (0 > i)
+		return 0;
+
+	i = alloc_ipu_pmmu_buffer(count, blocksize, buff);
+
+	if (!i)
+		goto out_kfree_ipu_reg_info;
+
+	return i;
+
+out_kfree_ipu_reg_info:
+	release_ipu();
+
+	return 0;
+}
+
+static void release_frame_buff(struct mp200_cam_frames *frm)
+{
+
+	if (V4L2_MEMORY_MMAP == frm->memory) {
+		switch (frm->buf_type) {
+		case BUF_DMA:
+			release_dma_coherent(frm);
+			break;
+		case BUF_IPU:
+			release_ipu_buffer(frm);
+			break;
+		case BUF_PMMU:
+		case BUF_CAM_PMMU_IPU:
+			release_pmmu_buffer(frm);
+			break;
+		case BUF_IPU_PMMU:
+			release_ipu_pmmu_buffer(frm);
+			break;
+		default:
+			vfree_buffer(frm);
+		}
+	} else {
+		release_frm_userptr(frm);
+		cam->userptr   = 0;
+		switch (frm->buf_type) {
+		case BUF_IPU:
+		case BUF_IPU_PMMU:
+			release_ipu();
+			break;
+		default:
+			;
+		}
+	}
+
+	frm->max = 0;
+	frm->blocksize = 0;
+	frm->memory = 0;
+	kfree(frm->buff);
+	frm->buff = NULL;
+
+	return;
+}
+
+static int request_frame_buff(struct mp200_cam_frames *frm,
+			      __u32 count, const struct mp200_cam_fmt *fmt,
+			      enum v4l2_memory memory, int buf_type)
+{
+	__u32 blocksize, bpl;
+
+	frm->buff = kzalloc(count * sizeof(*cam->grab->buff), GFP_KERNEL);
+
+	if (NULL == frm->buff) {
+		err("%s: frame info allocation failed\n", CAM_NAME);
+		return 0;
+	}
+
+	blocksize = get_sizeimage(fmt, cam->bounds.width,
+				  cam->bounds.height, &bpl);
+
+	blocksize = PAGE_ALIGN(blocksize);
+
+	if (V4L2_MEMORY_MMAP == memory) {
+		switch (buf_type) {
+		case BUF_DMA:
+			count = request_dma_coherent(count,
+						     blocksize, frm->buff);
+			break;
+		case BUF_IPU:
+			count = request_ipu_buffer(count,
+						   blocksize, frm->buff);
+			break;
+		case BUF_PMMU:
+			count = request_pmmu_buffer(count,
+						    blocksize, frm->buff,
+						    BUF_PMMU);
+			break;
+		case BUF_CAM_PMMU_IPU:
+			count = request_pmmu_buffer(count,
+						    blocksize, frm->buff,
+						    BUF_CAM_PMMU_IPU);
+			break;
+		case BUF_IPU_PMMU:
+			count = request_ipu_pmmu_buffer(count,
+							blocksize, frm->buff);
+			break;
+		default:
+			count = vmalloc_buffer(count,
+					       blocksize, frm->buff,
+					       CAM_PMMU_OFF);
+		}
+	} else {
+		cam->userptr   = 1;
+		switch (buf_type) {
+		case BUF_IPU:
+		case BUF_IPU_PMMU:
+			if (0 > request_ipu())
+				count = 0;
+			break;
+		default:
+			;
+		}
+	}
+
+	if (count) {
+		frm->max = count;
+		frm->blocksize = blocksize;
+		frm->memory = memory;
+		frm->fmt = fmt;
+		frm->buf_type = buf_type;
+	} else {
+		frm->max = 0;
+		frm->blocksize = 0;
+		frm->memory = 0;
+		kfree(frm->buff);
+		frm->buff = NULL;
+	}
+
+	frm->cnt = 0;
+
+	return count;
+}
+
+static int request_doubling_buffers(__u32 count, enum v4l2_memory memory)
+{
+	int ret = 0;
+	int buf_type;
+	int piece = 2;
+
+	cam->done = kzalloc(sizeof(*cam->done), GFP_KERNEL);
+
+	if (NULL == cam->done) {
+		warn("%s: done buffer allocation failed.\n", CAM_NAME);
+		goto out_request_doubling_buffers;
+	}
+
+	init_waitqueue_head(&cam->done->proc_list);
+
+	cam->done->enq = kfifo_alloc(sizeof(struct mp200_enq_index) * count,
+				     GFP_KERNEL, &cam->done->enq_lock);
+
+	if (IS_ERR(cam->done->enq)) {
+		warn("%s: done fifo allocation failed.\n", CAM_NAME);
+		goto out_kfree_done;
+	}
+
+	kfifo_reset(cam->done->enq);
+
+	if (cam->ipu)
+		buf_type = (cam->pmmu) ? BUF_CAM_PMMU_IPU : BUF_DMA;
+	else
+		buf_type = (cam->pmmu) ? BUF_PMMU : BUF_DMA;
+
+#if 1 /* mp200 cam admit one piece */
+	{
+		__u32 limitsize, blocksize, bpl;
+
+		limitsize = get_sizeimage(&rgb_input, 640, 480, &bpl);
+		blocksize = get_sizeimage(&rgb_input, cam->bounds.width,
+					  cam->bounds.height, &bpl);
+
+		if (limitsize < blocksize)
+			piece = 1;
+	}
+#endif
+	ret = request_frame_buff(cam->grab, piece, &rgb_input,
+				 V4L2_MEMORY_MMAP, buf_type);
+
+	if (0 == ret)
+		goto out_kfifo_free_done;
+#if 0 /* mp200 cam admit one piece */
+	else if (2 > ret) {
+		warn("%s: not enough grab buffers.\n", CAM_NAME);
+		ret = 0;
+		goto out_release_grab_buffer;
+	}
+#endif
+
+	if (cam->ipu)
+		buf_type = (cam->pmmu) ? BUF_IPU_PMMU : BUF_IPU;
+	else
+		buf_type = BUF_V;
+
+#if 1 /* mp200 cam admit one piece */
+	if (1 == piece)
+		count = 1;
+#endif
+	ret = request_frame_buff(cam->done, count, cam->fmt, memory, buf_type);
+
+	if (0 == ret)
+		goto out_release_grab_buffer;
+
+#if 0 /* mp200 cam admit one piece */
+	else if (2 > ret) {
+		warn("%s: not enough done buffers.\n", CAM_NAME);
+		ret = 0;
+		goto out_release_done_buffer;
+	}
+#endif
+
+	return ret;
+
+#if 0 /* mp200 cam admit one piece */
+out_release_done_buffer:
+	release_frame_buff(cam->done);
+#endif
+out_release_grab_buffer:
+	release_frame_buff(cam->grab);
+out_kfifo_free_done:
+	kfifo_free(cam->done->enq);
+out_kfree_done:
+	kfree(cam->done);
+	cam->done = NULL;
+out_request_doubling_buffers:
+
+	return ret;
+}
+
+static void cam_release_buffers(int flag)
+{
+	if (!cam->done)
+		goto out_release_buffers;
+
+	/* doubling buffers */
+	if (cam->done != cam->grab) {
+		release_frame_buff(cam->done);
+		kfifo_free(cam->done->enq);
+		kfree(cam->done);
+		cam->done = NULL;
+	}
+
+	cam->done = NULL;
+	release_frame_buff(cam->grab);
+
+	if (pmmu_id) {
+		mp200_camif_mmu(CAM_OFF);
+		debug_snprintf("mp200_pmmu_terminate(%p)\n", pmmu_id);
+		mp200_pmmu_terminate(pmmu_id);
+		pmmu_id = NULL;
+	}
+
+out_release_buffers:
+	return;
+}
+
+static int cam_request_buffers(int action, __u32 count,
+			       enum v4l2_memory memory)
+{
+	/* action 0:mmap, 1:read */
+	int ret = 0;
+	int i = 0, doubling = 0;
+
+	debug_dump(snprintf_fmt, cam->fmt);
+
+	switch (cam->fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_RGB565:
+		if (!action || cam->ipu)
+			doubling = 1;
+		break;
+	default:
+		/* nothing */;
+	}
+
+	if (cam->pmmu
+	    && (doubling || (!doubling && (V4L2_MEMORY_MMAP == memory)))) {
+		mp200_camif_mmu(CAM_ON);
+		debug_snprintf("mp200_pmmu_initiate(%p,%p,32)\n",
+			       (u_long *)CA_MMU_1D0, (u_long *)CA_MMU_INDEX0);
+		pmmu_id = mp200_pmmu_initiate((u_long *)CA_MMU_1D0,
+					      (u_long *)CA_MMU_INDEX0, 32);
+	}
+
+	if (doubling) {
+		i = request_doubling_buffers(count, memory);
+		if (i) {
+			debug_dump(snprintf_frm, cam->grab);
+			debug_dump(snprintf_buffs, cam->grab->buff,
+				   cam->grab->max, cam->grab->memory);
+			debug_dump(snprintf_frm, cam->done);
+			debug_dump(snprintf_buffs, cam->done->buff,
+				   cam->done->max, cam->done->memory);
+		} else {
+			ret = -ENOMEM;
+		}
+	} else {
+		int piece = count;
+
+#if 1 /* mp200 cam admit one piece */
+		{
+			__u32 limitsize, blocksize, bpl;
+
+			limitsize = get_sizeimage(&rgb_input, 640, 480, &bpl);
+			blocksize = get_sizeimage(&rgb_input,
+						  cam->bounds.width,
+						  cam->bounds.height, &bpl);
+
+			if (limitsize < blocksize)
+				piece = 1;
+		}
+#endif
+		i = request_frame_buff(cam->grab, piece, cam->fmt,
+				       memory,
+				       (cam->pmmu) ? BUF_PMMU : BUF_DMA);
+		if (i) {
+			cam->done = cam->grab;
+			debug_dump(snprintf_frm, cam->grab);
+			debug_dump(snprintf_buffs, cam->grab->buff,
+				   cam->grab->max, cam->grab->memory);
+		} else {
+			ret = -ENOMEM;
+		}
+	}
+
+	if (!ret)
+		cam->reset = 0;
+
+	return ret;
+}
+#endif
+
+
+static int cam_choice_function(int action)
+{
+	/* action 0 : mmap, 1 : read */
+	int ret = 0;
+
+	assert(cam->done);
+
+	switch (cam->fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_RGB565:
+		if (cam->ipu) {
+			cam->done->update = mp200_cam_done_ipu_handler;
+			cam->th_convert = mp200_cam_ipu_regist;
+			cam->grab->update = mp200_cam_grab_handler;
+			cam->read_convert = NULL;
+		} else {
+			if (!action) {
+				cam->done->update = mp200_cam_done_cpu_handler;
+				cam->th_convert = mp200_cam_convert;
+				cam->grab->update = mp200_cam_grab_handler;
+				cam->read_convert = NULL;
+			} else {
+				cam->grab->update = mp200_cam_grabs_handler;
+				cam->th_convert = NULL;
+				cam->read_convert = mp200_cam_read_convert;
+			}
+		}
+		break;
+	default:
+		cam->grab->update = mp200_cam_grabs_handler;
+		cam->th_convert = NULL;
+		cam->read_convert = NULL;
+	}
+
+	debug_dump(snprintf_cam, cam);
+
+	return ret;
+}
+
+
+#define LIMIT(x) ((((x) > 0xffffff) ? 0xff0000 : (((x) <= 0xffff) ? 0 \
+						  : (x) & 0xff0000)) >> 16)
+
+static size_t cam_yuv2rgb(int *ysrcp, unsigned char *dirp, size_t count)
+{
+	int cnt = 0;
+	int srccnt = 0;
+	int yplane_data = 0;
+
+	while (count > cnt) {
+
+		int y, u, v, r, g, b, y1;
+
+		/* data is little endian & 32bit set */
+
+		yplane_data = *ysrcp;
+		y  = (yplane_data & 0x000000ff);
+		u  = (yplane_data >> 8) & 0x000000ff;
+		y1 = (yplane_data >> 16) & 0x000000ff;
+		v  = (yplane_data >> 24) & 0x000000ff;
+
+		y  = (y - 16) * 76284;
+		u  = u - 128;
+		y1 = (y1 - 16) * 76284;
+		v  = v - 128;
+
+		r  = 104595 * v;
+		g = -53281 * u + -25625 * v;
+		b = 132252 * u;
+		switch (cam->fmt->pixelformat) {
+		case V4L2_PIX_FMT_RGB565:
+			/* data type shout little endian */
+			*dirp++ = ((LIMIT(g + y) & 0xfc) << 3) |
+				  (LIMIT(b + y) >> 3);
+			*dirp++ = (LIMIT(r + y) & 0xf8) |
+				  (LIMIT(g + y) >> 5);
+			*dirp++ = ((LIMIT(g + y1) & 0xfc) << 3) |
+				  (LIMIT(b + y1) >> 3);
+			*dirp++ = (LIMIT(r + y1) & 0xf8) |
+				  (LIMIT(g + y1) >> 5);
+			cnt += 4;
+			break;
+		case V4L2_PIX_FMT_RGB24:
+			*dirp++ = LIMIT(r + y);
+			*dirp++ = LIMIT(g + y);
+			*dirp++ = LIMIT(b + y);
+			*dirp++ = LIMIT(r + y1);
+			*dirp++ = LIMIT(g + y1);
+			*dirp++ = LIMIT(b + y1);
+			cnt += 6;
+			break;
+		default:
+			err("%s: yuv2rgb format none\n", CAM_NAME);
+			return 0;
+		}
+
+		ysrcp++;
+
+		srccnt++;
+		if (signal_pending(current))
+			break;
+		if (cam->stop)
+			break;
+	}
+
+	return srccnt;
+}
+
+static inline void cam_buffer_status(struct v4l2_buffer *b,
+				     __u32 index, enum v4l2_buf_type type)
+{
+	struct mp200_cam_buffer *cdb = &cam->done->buff[index];
+
+	b->index    = index;
+	b->type     = type;
+	b->memory   = cam->done->memory;
+
+	switch (b->memory) {
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	case V4L2_MEMORY_MMAP:
+		b->m.offset  = cdb->m.offset;
+		b->length    = cam->done->blocksize;
+		break;
+#endif
+	case V4L2_MEMORY_USERPTR:
+		b->m.userptr = cdb->m.userptr;
+		b->length    = cam->done->blocksize;
+		break;
+	default:
+		/* nothing */;
+	}
+
+	b->flags    = 0;
+	if (cdb->map)
+		b->flags |= V4L2_BUF_FLAG_MAPPED;
+
+	switch (cdb->state) {
+	case CAM_BUF_QUEUED:
+	case CAM_BUF_GRABBING:
+	case CAM_BUF_GRAB:
+		b->flags |= V4L2_BUF_FLAG_QUEUED;
+		break;
+	case CAM_BUF_DONE:
+		b->flags |= V4L2_BUF_FLAG_DONE;
+		break;
+	case CAM_BUF_IDLE:
+	case CAM_BUF_BREAK:
+		/* nothing */
+		break;
+	}
+
+	b->field = V4L2_FIELD_NONE;
+
+	b->timestamp = cdb->timestamp;
+	b->bytesused = cdb->bytesused;
+	b->sequence  = cdb->sequence;
+
+	return;
+}
+
+static int mp200_cam_thread(void *p);
+
+#ifdef MP200_CAM_MAKING_DEBUG
+#define LIMIT_TIME 60
+#else
+#define LIMIT_TIME 10
+#endif
+
+static inline int cam_waiton(struct mp200_cam_frames *frm,
+			     struct kfifo *q, int non_blocking,
+			     int intr, int th, int timeout)
+{
+	int ret = 0;
+	__u32 state;
+	unsigned int len, index, limit;
+	unsigned long flags;
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (timeout)
+		limit = timeout / HZ;
+	else
+		limit = 1;
+
+	local_irq_save(flags);
+
+	/* d1b("cam_waiton chk SIGINT %d\n", sigismember(
+					&(current->blocked), SIGINT)); */
+
+	len = deq_peepq(&index, q);
+	if (len)
+		state = frm->buff[index].state;
+	else
+		state = CAM_BUF_GRABBING;
+
+	switch (state) {
+	case CAM_BUF_BREAK:
+		err("%s: buffer break.\n", CAM_NAME);
+		ret = -EIO;
+		break;
+	case CAM_BUF_IDLE:
+	case CAM_BUF_QUEUED:
+	case CAM_BUF_GRABBING:
+		if (non_blocking) {
+			ret = -EAGAIN;
+			break;
+		}
+		set_current_state(intr  ? TASK_INTERRUPTIBLE
+				  : TASK_UNINTERRUPTIBLE);
+
+		add_wait_queue(&frm->proc_list, &wait);
+		do {
+			local_irq_restore(flags);
+
+			if (timeout) {
+				schedule_timeout(HZ);
+				limit--;
+				d1b("chk limit %d\n", limit);
+			} else {
+				schedule();
+			}
+
+			/* assert(limit != 0); */
+
+			local_irq_save(flags);
+
+			set_current_state(intr  ? TASK_INTERRUPTIBLE
+					  : TASK_UNINTERRUPTIBLE);
+
+			if (intr && signal_pending(current)) {
+				warn("%s: buffer waiton: -EINTR.\n", CAM_NAME);
+				ret = -EINTR;
+				break;
+			}
+
+			if (th && kthread_should_stop()) {
+				ret = -EINTR;
+				break;
+			}
+
+			deq_peepq(&index, q);
+
+			len = deq_peepq(&index, q);
+			if (!len)
+				continue;
+
+			if (CAM_BUF_BREAK == frm->buff[index].state) {
+				err("%s: buffer break.\n", CAM_NAME);
+				ret = -EIO;
+				break;
+			}
+
+			if (CAM_BUF_GRAB == frm->buff[index].state
+			    || CAM_BUF_DONE == frm->buff[index].state
+			    || CAM_BUF_IDLE == frm->buff[index].state) {
+				break;
+			}
+		} while (limit);
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&frm->proc_list, &wait);
+
+		if (ret)
+			break;
+	case CAM_BUF_GRAB:
+	case CAM_BUF_DONE:
+		break;
+	}
+
+	local_irq_restore(flags);
+
+	if (!ret && !limit)
+		ret = -ETIMEDOUT;
+
+	return ret;
+}
+
+static inline int cam_stop(int flag)
+{
+	int ret = 0;
+	unsigned int i, len, index;
+
+	d1b("stop\n");
+	cam->stop = 1;
+
+	len = deq_grab_peepq(&index);
+
+	for (i = 0; i < len; i++) {
+		if (CAM_BUF_GRABBING == cam->grab->buff[index].state) {
+			cam_waiton(cam->grab, cam->deq_grab,
+				   0, 1, 0, LIMIT_TIME * HZ);
+			break;
+		}
+		deq_grab_pullq();
+		deq_grab_peepq(&index);
+	}
+
+	if (cam->done != cam->grab) {
+		len = deq_done_peepq(&index);
+
+		for (i = 0; i < len; i++) {
+			if (CAM_BUF_GRABBING == cam->done->buff[index].state) {
+				cam_waiton(cam->done, cam->deq_done,
+					   0, 1, 0, LIMIT_TIME * HZ);
+				break;
+			}
+			deq_done_pullq();
+			deq_done_peepq(&index);
+		}
+	}
+
+	if (mp200_camif_running(0)) {
+		err("%s: don't stream stop !\n", CAM_NAME);
+		ret = -EFAULT;
+	}
+
+	if (cam->hw.stream_off)
+		ret = cam->hw.stream_off(0);
+
+	return ret;
+}
+
+static inline int cam_stream(int flag)
+{
+	/* flag 0 : OFF, 1 : ON */
+	int ret = 0;
+
+	if (flag) {
+		struct task_struct *th;
+
+		th = kthread_run(mp200_cam_thread, &cam, "mp200_cam_thread");
+		if (IS_ERR(th)) {
+			err("%s:  kernel_thread() failed\n", CAM_NAME);
+			return PTR_ERR(th);
+		}
+		cam->th = th;
+
+		if (cam->hw.stream_on) {
+			ret = cam->hw.stream_on(0);
+			if (ret) {
+				d1b("stop\n");
+				cam->stop = 1;
+			}
+		}
+#if 1 /* XXX */
+		if (warming_up) {
+			schedule_timeout_uninterruptible(HZ);
+			warming_up = 0;
+		}
+#endif
+
+	} else {
+		if (cam->th) {
+			ret = kthread_stop(cam->th);
+			cam->th = NULL;
+		}
+		cam_stop(0);
+	}
+
+	return ret;
+}
+
+static inline int cam_capture(int flag)
+{
+	int ret = 0;
+	struct mp200_enq_index q;
+	unsigned long flags;
+
+	if (cam->stop)
+		return -EIO;
+
+	if (!grab_peepq(&q))
+		return ret;
+
+	if (mp200_camif_running(0))
+		return ret;
+
+	if (CAM_BUF_QUEUED != cam->grab->buff[q.grab].state)
+		return ret;
+
+	if (cam->frames_active)
+		return ret;
+
+	if (cam->hw.prepare) {
+		cam->pre.actions = 1;
+		ret = cam->hw.prepare(&cam->pre);
+		if (ret) {
+			d1b("stop\n");
+			cam->stop = 1;
+			return ret;
+		}
+	}
+
+	if (cam->pre.reset) {
+		d1b("stop\n");
+		cam->stop = 1;
+		return ret;
+	}
+
+	ret = mp200_camif_prepare(q.grab);
+	if (ret) {
+		d1b("stop\n");
+		cam->stop = 1;
+		return ret;
+	}
+
+	if (cam->hw.trigger) {
+		ret = cam->hw.trigger(0);
+		if (ret) {
+			d1b("stop\n");
+			cam->stop = 1;
+			return ret;
+		}
+	}
+
+	spin_lock_irqsave(&cam->cam_lock, flags);
+	ret = mp200_camif_capture(0);
+	if (ret) {
+		d1b("stop\n");
+		cam->stop = 1;
+		return ret;
+	}
+
+	cam->grab->buff[q.grab].state = CAM_BUF_GRABBING;
+	cam->frames_active = 1;
+
+	spin_unlock_irqrestore(&cam->cam_lock, flags);
+
+	return ret;
+}
+
+static inline int cam_sync(int flag)
+{
+	int ret = 0;
+
+	if (!cam->frames_active)
+		return ret;
+
+	/* assert(0 == mp200_camif_running(0)); */
+
+	{
+		int i = 100;
+
+		do {
+			if (!mp200_camif_running(0))
+				break;
+			udelay(1);
+		} while (--i);
+		/* module reset */
+
+		/* assert(0 != i); */
+	}
+
+	if (cam->hw.sync) {
+		cam->pre.actions = 1;
+		ret = cam->hw.sync(&cam->pre);
+		if (ret) {
+			d1b("stop\n");
+			cam->stop = 1;
+			return ret;
+		}
+	}
+
+	if (cam->pre.actions) {
+		ret = mp200_camif_restart(0);
+		cam->setup = 1;
+	}
+
+	cam->frames_active = 0;
+
+	return ret;
+}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+static inline int cam_read_start(int flag)
+{
+	int i, ret = 0;
+
+	ret = -EINVAL;
+
+	if ((!cam->action && cam->done) || cam->reset)
+		cam_release_buffers(0);
+
+	if (!cam->done) {
+		ret = cam_request_buffers(CAM_READ, CAM_MAX_BUFNBRS,
+					  V4L2_MEMORY_MMAP);
+		if (ret)
+			goto done_cam_read_start;
+
+		ret = cam_choice_function(CAM_READ);
+
+		if (ret) {
+			cam_release_buffers(0);
+			ret = -ENOMEM;
+			goto done_cam_read_start;
+		}
+
+		cam->action = CAM_READ;
+	}
+	for (i = 0; cam->done->max > i; i++)
+		deq_pushq(cam->done->cnt);
+
+	ret = cam_stream(CAM_ON);
+
+	if (ret)
+		goto done_cam_read_start;
+
+	cam->reading = 1;
+
+	mutex_lock(&cam->frames_lock);
+	ret = cam_capture(0);
+	mutex_unlock(&cam->frames_lock);
+
+done_cam_read_start:
+	return ret;
+}
+#endif
+
+/*
+ * Convert Functions
+ */
+static int mp200_cam_thread(void *p)
+{
+	int ret = 0;
+
+	d1b("entry\n");
+
+	while (!kthread_should_stop()) {
+
+#if defined(CONFIG_PM) || defined(CONFIG_DPM)
+		try_to_freeze();
+#endif /* CONFIG_PM || CONFIG_DPM */
+
+		ret = cam_waiton(cam->grab, cam->deq_grab,
+				 0, 1, 1, LIMIT_TIME * HZ);
+
+		if (-EINTR == ret) {
+			mutex_lock(&cam->frames_lock);
+			cam_sync(0);
+			mutex_unlock(&cam->frames_lock);
+
+			wake_up_interruptible(&cam->done->proc_list);
+			continue;
+		} else if (-EIO == ret)   {
+			mutex_lock(&cam->frames_lock);
+			cam_sync(0);
+			mutex_unlock(&cam->frames_lock);
+
+			wake_up_interruptible(&cam->done->proc_list);
+			deq_grab_pullq();
+			continue;
+		} else if (-ETIMEDOUT == ret)   {
+			d1b("cam_waiton timeout.\n");
+			continue;
+		} else {
+			deq_grab_pullq();
+		}
+
+		mutex_lock(&cam->frames_lock);
+		ret = cam_sync(0);
+		mutex_unlock(&cam->frames_lock);
+
+		if (ret) {
+			wake_up_interruptible(&cam->done->proc_list);
+			continue;
+		}
+
+		mutex_lock(&cam->frames_lock);
+		ret = cam_capture(0);
+		mutex_unlock(&cam->frames_lock);
+
+		if (cam->th_convert)
+			ret = cam->th_convert(0);
+	}
+
+	d1b("exit:%d\n", 0);
+
+	return 0;
+}
+
+static ssize_t mp200_cam_read_convert(char *buf, __u32 index,
+				      __u32 cnt, __u32 bpl)
+{
+	int ret = 0;
+	int srccnt = 0;
+	int cnvcnt = 0;
+	int *ysrcp  = (int *)cam->done->buff[index].vadr;
+
+
+	void *line;
+
+	ret = -EFAULT;
+
+	line = kmalloc(bpl, GFP_KERNEL);
+
+	if (!line) {
+		ret = -ENOMEM;
+		warn("%s: not enough convert buffers.\n", CAM_NAME);
+		goto done_cam_read_convert;
+	}
+
+	while (cnt > cnvcnt) {
+		if (cnt < (cnvcnt + bpl))
+			bpl = cnt - cnvcnt;
+		srccnt = cam_yuv2rgb(ysrcp, line, bpl);
+
+		if (copy_to_user(buf + cnvcnt, line, bpl)) {
+			kfree(line);
+			err("%s: read: copy_to_user fault.\n",
+			    CAM_NAME);
+			goto done_cam_read_convert;
+		}
+		ysrcp  += srccnt;
+
+		cnvcnt += bpl;
+
+		if (signal_pending(current)) {
+			kfree(line);
+			ret = -EINTR;
+			goto done_cam_read_convert;
+		}
+		if (cam->stop)
+			break;
+	}
+	kfree(line);
+
+	ret = cnt;
+
+done_cam_read_convert:
+	return ret;
+}
+
+static int mp200_cam_convert(int flag)
+{
+	int ret = 0;
+	int *ysrcp;
+
+	unsigned char *dirp;
+	size_t srccnt;
+	__u32 count, bpl;
+	struct mp200_enq_index q;
+	FNC_ENTRY;
+
+	if (!done_peepq(&q)) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	if (CAM_BUF_QUEUED != cam->done->buff[q.done].state) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	count = get_sizeimage(cam->done->fmt, cam->width, cam->height, &bpl);
+
+	cam->done->buff[q.done].state = CAM_BUF_GRABBING;
+
+	ysrcp  = (int *)cam->grab->buff[q.grab].vadr;
+
+
+	dirp   = cam->done->buff[q.done].vadr;
+
+	srccnt = cam_yuv2rgb(ysrcp, dirp, count);
+	srccnt = (srccnt * 2 /*PIXEL*/) * (cam->done->fmt->depth >> 3);
+
+	assert(count == srccnt);
+
+	if (cam->done->update)
+		cam->done->update(cam);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/*
+ * IPU Functions
+ */
+
+static void mp200_cam_ipu_handler(unsigned long sequence, int flag)
+{
+	FNC_ENTRY;
+
+	switch (flag) {
+	case IPU_CALLBACK_SUCCESS:
+		cam->status |= B_IPU_SUCCESS;
+		break;
+	case IPU_CALLBACK_SET_PARAM:
+		cam->status |= B_IPU_SET_PARAM;
+		d1b("stop\n");
+		cam->stop = 1;
+		warn("%s: ipu_handler flag SET_PARAM.\n", CAM_NAME);
+		break;
+	case IPU_CALLBACK_CANCEL:
+		cam->status |= B_IPU_CANCEL;
+		d1b("stop\n");
+		cam->stop = 1;
+		break;
+	case IPU_CALLBACK_FAIL:
+		cam->status |= B_IPU_FAIL;
+		d1b("stop\n");
+		cam->stop = 1;
+		err("%s: ipu_handler flag FAIL\n", CAM_NAME);
+		break;
+	case IPU_CALLBACK_IPU_ERROR:
+		cam->status |= B_IPU_ERROR;
+		d1b("stop\n");
+		cam->stop = 1;
+		err("%s: ipu_handler flag IPU_ERROR\n", CAM_NAME);
+		break;
+	case IPU_CALLBACK_IPU_STOP:
+		cam->status |= B_IPU_STOP;
+		d1b("stop\n");
+		cam->stop = 1;
+		err("%s: ipu_handler flag IPU_STOP\n", CAM_NAME);
+		break;
+	default:
+		cam->status |= B_IPU_ERROR;
+		d1b("stop\n");
+		cam->stop = 1;
+		err("%s: ipu_handler flag none\n", CAM_NAME);
+	}
+
+	if (cam->done->update)
+		cam->done->update(cam);
+
+	FNC_EXIT(0)
+	return;
+}
+
+
+static inline int imgreg(unsigned long reg, unsigned long data,
+			 struct mp200_ipu_reg_info *ipu_reg_info, int index)
+{
+	assert((IPU_MAX_REG_INFO > index) && -1 < index);
+	ipu_reg_info[index].reg  = reg;
+	ipu_reg_info[index].data = data;
+	return ++index;
+}
+
+static int mp200_cam_ipu_regist(int flag)
+{
+	int ret = 0, i = 0;
+	__u32 size, bpl;
+	struct mp200_enq_index q;
+	FNC_ENTRY;
+
+	if (!done_peepq(&q)) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	if (CAM_BUF_QUEUED != cam->done->buff[q.done].state) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	size = get_sizeimage(cam->done->fmt, cam->width, cam->height, &bpl);
+
+	/* IMG_MODE */
+	i = imgreg(IMG_MODE, IMG_OP_MODE_07_BIT | IMG_NEWEN_BIT,
+		   ipu_reg_info, i);
+	/* SOURCE IMAGE */
+	/* SRCYRGBADR_B */
+	i = imgreg(IMG_SRCYRGBADR_B, cam->grab->buff[q.grab].padr,
+		   ipu_reg_info, i);
+	/* SRCSIZE_B */
+	i = imgreg(IMG_SRCSIZE_B, cam->width * 2, ipu_reg_info, i);
+	/* SRCHSIZE_B */
+	i = imgreg(IMG_SRCHSIZE_B, cam->width, ipu_reg_info, i);
+	/* SRCVSIZE_B */
+	i = imgreg(IMG_SRCVSIZE_B, cam->height, ipu_reg_info, i);
+	/* DESTINATION IMAGE */
+	/* DSTYRGBADR */
+	i = imgreg(IMG_DSTYRGBADR, cam->done->buff[q.done].padr,
+		   ipu_reg_info, i);
+	/* DSTSIZE */
+	i = imgreg(IMG_DSTSIZE,
+		   ((V4L2_PIX_FMT_RGB565 == cam->done->fmt->pixelformat) ?
+		    cam->width * 2 : cam->width * 3), ipu_reg_info, i);
+	/* NEWEN IMG_FORMAT */
+	i = imgreg(IMG_FORMAT,
+		   IMG_FORMAT_SRCFMT_B_YUV422_INTERLEAVE |
+		   ((V4L2_PIX_FMT_RGB565 == cam->done->fmt->pixelformat) ?
+		    IMG_FORMAT_DSTFMT_RGB565 : IMG_FORMAT_DSTFMT_RGB888),
+		   ipu_reg_info, i);
+	/* NEWEN IMG_INDATABYTE */
+	i = imgreg(IMG_INDATABYTE,
+		   IMG_INDATABYTE_DATA3_BYTE3 | IMG_INDATABYTE_DATA2_BYTE2 |
+		   IMG_INDATABYTE_DATA1_BYTE1 | IMG_INDATABYTE_DATA0_BYTE0,
+		   ipu_reg_info, i);
+	/* IMG_PEL_ENDIAN */
+	i = imgreg(IMG_PEL_ENDIAN, IMG_PEL_ENDIAN_IN_ENDI_LITTLE |
+		   IMG_PEL_ENDIAN_OUT_ENDI_LITTLE, ipu_reg_info, i);
+	/* IMG_YUVRGB_CONF */
+	i = imgreg(IMG_YUVRGB_CONF, IMG_YUVRGB_YOFFSET_VALID_BIT,
+		   ipu_reg_info, i);
+
+	/* Start IMG */
+	i = imgreg(IMG_REQ, IMG_REQ_BIT, ipu_reg_info, i);
+
+	/* end mark */
+	i = imgreg(IPU_REG_INFO_END, -1, ipu_reg_info, i);
+
+	ipu_req->ipu_hw_func = IPU_HW_FUNC_IMG;
+	ipu_req->callback = mp200_cam_ipu_handler;
+	ipu_req->data = (unsigned long)cam;
+
+	debug_dump(snprintf_ipureg, ipu_req);
+
+	cam->done->buff[q.done].state = CAM_BUF_GRABBING;
+
+	ret = mp200_ipu_regist(ipu_req);
+
+	switch (ret) {
+	case IPU_REQ_REGISTERED:
+		ret = 0;
+		break;
+	case IPU_REQ_BUSY:
+		warn("%s: mp200_ipu_regist -EBUSY.\n", CAM_NAME);
+		cam->done->buff[q.done].state = CAM_BUF_QUEUED;
+		ret = -EBUSY;
+		break;
+	case IPU_REQ_PARAMERR:
+		err("%s: mp200_ipu_regist -EINVAL\n", CAM_NAME);
+		cam->done->buff[q.done].state = CAM_BUF_BREAK;
+		ret = -EINVAL;
+		break;
+	default:
+		err("%s: mp200_ipu_regist none\n", CAM_NAME);
+		cam->done->buff[q.done].state = CAM_BUF_BREAK;
+		ret = -EFAULT;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *mp200_cam_proc_root;
+
+static int proc_mp200_cam_read(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	char *out = page;
+	int len;
+
+	/* IMPORTANT: This output MUST be kept under PAGE_SIZE
+	 *            or we need to get more sophisticated. */
+
+#ifdef MP200_CAM_MAKING_DEBUG
+	out += strlcpy(out, ddump + off, count);
+
+	len = out - page;
+
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else {
+		len = count;
+	}
+
+	*start = page;
+#else
+	out += sprintf(out, "%s : read-only\n-----------------------\n",
+		       CAM_NAME);
+	out += sprintf(out, "V4L Driver version:       %d.%d.%d\n",
+		       MP200_CAM_MAJ_VER, MP200_CAM_MIN_VER,
+		       MP200_CAM_PATCH_VER);
+
+	len = out - page;
+	len -= off;
+
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+			return 0;
+	} else {
+		len = count;
+	}
+
+	*start = page + off;
+#endif
+	return len;
+}
+
+
+static int proc_mp200_cam_write(struct file *file,
+				const char __user *buf,
+				unsigned long count, void *data)
+{
+	int retval = 0;
+
+	if (mutex_lock_interruptible(&cam->lock))
+		return -ERESTARTSYS;
+
+	mutex_unlock(&cam->lock);
+
+	return retval;
+}
+
+static void create_proc_mp200_cam(struct mp200_cam *cam)
+{
+	char name[5 + 1 + 10 + 1];
+	struct proc_dir_entry *ent;
+
+	if (!mp200_cam_proc_root || !cam)
+		return;
+
+	snprintf(name, sizeof(name), "video%d", cam->vdev->minor);
+
+	ent = create_proc_entry(name, S_IFREG | S_IRUGO | S_IWUSR,
+				mp200_cam_proc_root);
+	if (!ent)
+		return;
+
+	ent->data = cam;
+	ent->read_proc = proc_mp200_cam_read;
+	ent->write_proc = proc_mp200_cam_write;
+	cam->proc_entry = ent;
+}
+
+static void destroy_proc_mp200_cam(struct mp200_cam *cam)
+{
+	char name[5 + 1 + 10 + 1];
+
+	if (!cam || !cam->proc_entry)
+		return;
+
+	snprintf(name, sizeof(name), "video%d", cam->vdev->minor);
+	remove_proc_entry(name, mp200_cam_proc_root);
+	cam->proc_entry = NULL;
+}
+
+static void proc_mp200_cam_create(void)
+{
+	mp200_cam_proc_root = proc_mkdir("driver/cam", NULL);
+
+	if (mp200_cam_proc_root)
+		mp200_cam_proc_root->owner = THIS_MODULE;
+	else
+		err("Unable to initialise /proc/driver/cam\n");
+}
+
+#if 1
+static void proc_mp200_cam_destroy(void)
+#else
+static void __exit proc_mp200_cam_destroy(void)
+#endif
+{
+	remove_proc_entry("driver/cam", NULL);
+}
+#endif
+
+/*
+ * V4L2 Core Functions
+ */
+
+static inline int cam_done_handler(void *p)
+{
+	int ret = 0;
+	__u32 bytesused, bpl;
+	struct mp200_enq_index enq;
+
+	enq = done_pullq();
+
+	if (cam->status
+	    & (B_IPU_CANCEL | B_IPU_FAIL | B_IPU_ERROR | B_IPU_STOP)) {
+		cam->done->buff[enq.done].state = CAM_BUF_BREAK;
+		cam->done->buff[enq.done].bytesused = 0;
+		ret = -EIO;
+	} else {
+		bytesused = get_sizeimage(cam->done->fmt,
+					  cam->width, cam->height, &bpl);
+		cam->done->buff[enq.done].state = CAM_BUF_DONE;
+		cam->done->buff[enq.done].bytesused = bytesused;
+	}
+	cam->grab->buff[enq.grab].state = CAM_BUF_IDLE;
+	cam->done->buff[enq.done].sequence = cam->sequence;
+	do_gettimeofday(&cam->done->buff[enq.done].timestamp);
+	cam->sequence++;
+
+	wake_up_interruptible(&cam->done->proc_list);
+
+	return ret;
+}
+
+static int mp200_cam_done_ipu_handler(void *p)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	ret = cam_done_handler(p);
+
+	if (!ret)
+		ret = mp200_cam_ipu_regist(0);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_done_cpu_handler(void *p)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	ret = cam_done_handler(p);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+
+static int mp200_cam_grab_handler(void *p)
+{
+	int ret = 0;
+	__u32 bytesused, bpl;
+	struct mp200_enq_index enq;
+	FNC_ENTRY;
+
+	enq = grab_pullq();
+
+	if (cam->status
+	    & (B_L1MISS | B_APERR | B_PMERR | B_MAINOR | B_DMAERR)) {
+		cam->grab->buff[enq.grab].state = CAM_BUF_BREAK;
+		cam->grab->buff[enq.grab].bytesused = 0;
+		ret = -EIO;
+	} else {
+		bytesused = get_sizeimage(&rgb_input,
+					  cam->width, cam->height, &bpl);
+		cam->grab->buff[enq.grab].state = CAM_BUF_GRAB;
+		cam->grab->buff[enq.grab].bytesused = bytesused;
+	}
+	cam->grab->buff[enq.grab].sequence = cam->sequence;
+	do_gettimeofday(&cam->grab->buff[enq.grab].timestamp);
+
+	wake_up_interruptible(&cam->grab->proc_list);
+
+	if (!ret)
+		done_pushq(enq);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_grabs_handler(void *p)
+{
+	int ret = 0;
+	__u32 bytesused, bpl;
+	struct mp200_enq_index enq;
+	FNC_ENTRY;
+
+	enq = grab_pullq();
+
+	if (cam->status
+	    & (B_L1MISS | B_APERR | B_PMERR | B_MAINOR | B_DMAERR)) {
+		cam->grab->buff[enq.grab].state = CAM_BUF_BREAK;
+		cam->grab->buff[enq.grab].bytesused = 0;
+		ret = -EIO;
+	} else {
+		bytesused = get_sizeimage(cam->grab->fmt,
+					  cam->width, cam->height, &bpl);
+		cam->grab->buff[enq.grab].state = CAM_BUF_DONE;
+		cam->grab->buff[enq.grab].bytesused = bytesused;
+	}
+	cam->grab->buff[enq.grab].sequence = cam->sequence;
+	do_gettimeofday(&cam->grab->buff[enq.grab].timestamp);
+	cam->sequence++;
+
+	wake_up_interruptible_all(&cam->grab->proc_list);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+static void mp200_cam_vm_open(struct vm_area_struct *vma)
+{
+	struct mp200_cam_mapping *map = vma->vm_private_data;
+
+	d1b("vm_open %p [count=%d,vma=%08lx-%08lx]\n", map,
+	    map->count, vma->vm_start, vma->vm_end);
+	map->count++;
+	cam->mapping++;
+}
+
+static void mp200_cam_vm_close(struct vm_area_struct *vma)
+{
+	struct mp200_cam_mapping *map = vma->vm_private_data;
+	struct mp200_cam_frames *frm = cam->done;
+	int i;
+
+	d1b("vm_close %p [count=%d,vma=%08lx-%08lx]\n", map,
+	    map->count, vma->vm_start, vma->vm_end);
+
+	map->count--;
+	if (0 == map->count) {
+		mutex_lock(&cam->lock);
+		for (i = 0; i < frm->max; i++) {
+			if (frm->buff[i].map != map)
+				continue;
+			frm->buff[i].map   = NULL;
+		}
+		mutex_unlock(&cam->lock);
+		kfree(map);
+	}
+	cam->mapping--;
+
+	return;
+}
+#endif
+
+/*
+ * V4L2 Functions
+ */
+#define CAM_VERSION KERNEL_VERSION(MP200_CAM_MAJ_VER, MP200_CAM_MIN_VER, \
+				   MP200_CAM_PATCH_VER)
+
+/* VIDIOC_QUERYCAP handler */
+static int mp200_cam_vidioc_querycap(struct file *file, void *fh,
+				     struct v4l2_capability *cap)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	memset(cap, 0, sizeof(*cap));
+	strlcpy(cap->driver, "cam", sizeof(cap->driver));
+	strlcpy(cap->card, "mp200", sizeof(cap->card));
+	strlcpy(cap->bus_info, "own", sizeof(cap->bus_info));
+	cap->version = CAM_VERSION;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* Input handling */
+static int mp200_cam_vidioc_enum_input(struct file *file, void *fh,
+				       struct v4l2_input *inp)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (inp->index != 0) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	memset(inp, 0, sizeof(*inp));
+	strlcpy(inp->name, "cam", sizeof(inp->name));
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_g_input(struct file *file, void *fh,
+				    unsigned int *i)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	*i = 0;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_s_input(struct file *file, void *fh,
+				    unsigned int i)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (i > 0)
+		ret = -EINVAL;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* Control handling */
+static int mp200_cam_vidioc_queryctrl(struct file *file, void *fh,
+				      struct v4l2_queryctrl *a)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+#if 0
+/* @@#if MP200_CAM_NON_PMMU */
+/* @@	if (a->id < MP200_CID_IPU || */
+/* @@	    a->id > MP200_CID_IPU) */
+/* @@#else */
+/* @@	if (a->id < MP200_CID_IPU || */
+/* @@	    a->id > MP200_CID_PMMU) */
+/* @@#endif */
+#else
+	if (a->id < MP200_CID_IPU ||
+	    a->id > MP200_CID_PMMU)
+#endif
+	{
+		ret = mp200_camif_vidioc_queryctrl(file, fh, a);
+	} else {
+		ctrl = cam_ctrl_by_id(a->id);
+		*a = (NULL != ctrl) ? *ctrl : no_ctrl;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_querymenu(struct file *file, void *fh,
+				      struct v4l2_querymenu *m)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	memset(m->name, 0, sizeof(m->name));
+	m->reserved = 0;
+
+	ret = mp200_camif_vidioc_querymenu(file, fh, m);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_g_ctrl(struct file *file, void *fh,
+				   struct v4l2_control *c)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = cam_ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		ret = mp200_camif_vidioc_g_ctrl(file, fh, c);
+		FNC_EXIT(ret)
+		return ret;
+	}
+	switch (c->id) {
+	case MP200_CID_IPU:
+		c->value = cam->ipu;
+		break;
+#if MP200_CAM_NON_PMMU
+#else
+	case MP200_CID_PMMU:
+		c->value = cam->pmmu;
+		break;
+#endif
+	default:
+		ret = -EINVAL;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_s_ctrl(struct file *file, void *fh,
+				   struct v4l2_control *c)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = cam_ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		ret = mp200_camif_vidioc_s_ctrl(file, fh, c);
+		FNC_EXIT(ret)
+		return ret;
+	}
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_BOOLEAN:
+	case V4L2_CTRL_TYPE_MENU:
+	case V4L2_CTRL_TYPE_INTEGER:
+		if (c->value < ctrl->minimum)
+			c->value = ctrl->minimum;
+		if (c->value > ctrl->maximum)
+			c->value = ctrl->maximum;
+		break;
+	default:
+		/* nothing */;
+	}
+
+	mutex_lock(&cam->lock);
+	switch (c->id) {
+	case MP200_CID_IPU:
+#if 0 /* not support V4L2_MEMORY_MMAP */
+		if (cam->mapping || cam->reading || cam->streaming) {
+#else
+		if (cam->streaming) {
+#endif
+			warn("%s: s_ctrl IPU: streaming already exists.\n",
+			     CAM_NAME);
+			ret = -EBUSY;
+			break;
+		}
+		if (cam->ipu != c->value) {
+			if (V4L2_PIX_FMT_RGB24 == cam->fmt->pixelformat
+			    || V4L2_PIX_FMT_RGB565 == cam->fmt->pixelformat) {
+				cam->reset = 1;
+			}
+			cam->ipu = (c->value) ? 1 : 0;
+		}
+		break;
+#if MP200_CAM_NON_PMMU
+#else
+	case MP200_CID_PMMU:
+#if 0 /* not support V4L2_MEMORY_MMAP */
+		if (cam->mapping || cam->reading || cam->streaming) {
+#else
+		if (cam->streaming) {
+#endif
+			warn("%s: s_ctrl PMMU: streaming already exists.\n",
+			     CAM_NAME);
+			ret = -EBUSY;
+			break;
+		}
+		if (cam->pmmu != c->value) {
+			cam->reset = 1;
+			cam->pmmu = (c->value) ? 1 : 0;
+		}
+		break;
+#endif
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&cam->lock);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* VIDIOC_ENUM_FMT handlers */
+static int mp200_cam_vidioc_enum_fmt_cap(struct file *file, void *fh,
+					 struct v4l2_fmtdesc *f)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+#if 0
+/* @@	if (f->index > NUM_CAM_FORMATS) { */
+#else
+	if (f->index >= NUM_CAM_FORMATS) {
+#endif
+	FNC_EXIT(-EINVAL)
+	return -EINVAL;
+}
+
+strlcpy(f->description, cam_formats[f->index].description,
+	sizeof(f->description));
+f->pixelformat = cam_formats[f->index].pixelformat;
+
+FNC_EXIT(ret)
+return ret;
+}
+
+/* VIDIOC_TRY_FMT handlers */
+static int mp200_cam_vidioc_try_fmt_cap(struct file *file, void *fh,
+					struct v4l2_format *f)
+{
+	int ret = 0;
+	const struct mp200_cam_fmt *fmt;
+	FNC_ENTRY;
+
+	if (f->fmt.pix.field != V4L2_FIELD_ANY &&
+	    f->fmt.pix.field != V4L2_FIELD_NONE) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+
+	fmt = format_by_pixelformat(f->fmt.pix.pixelformat);
+	if (NULL == fmt) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	{
+		u32 max_width  = camif_fmt_boundary(fmt, cam->c.width);
+		u32 max_height = cam->c.height;
+		u32 min_width  = camif_width_limit(fmt, max_width);
+		u32 min_height = camif_height_limit(fmt, max_height);
+
+		if (min_width > f->fmt.pix.width)
+			f->fmt.pix.width = min_width;
+		if (max_width < f->fmt.pix.width)
+			f->fmt.pix.width = max_width;
+		if (min_height > f->fmt.pix.height)
+			f->fmt.pix.height = min_height;
+		if (max_height < f->fmt.pix.height)
+			f->fmt.pix.height = max_height;
+
+		f->fmt.pix.width = camif_fmt_boundary(fmt, f->fmt.pix.width);
+	}
+
+	pix_format_set_size(&f->fmt.pix, fmt,
+			    f->fmt.pix.width, f->fmt.pix.height);
+
+	f->fmt.pix.colorspace = 0;
+	f->fmt.pix.priv = 0;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* VIDIOC_G_FMT handlers */
+static int mp200_cam_vidioc_g_fmt_cap(struct file *file, void *fh,
+				      struct v4l2_format *f)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	f->fmt.pix.width        = cam->width;
+	f->fmt.pix.height       = cam->height;
+	f->fmt.pix.field        = V4L2_FIELD_NONE;
+	f->fmt.pix.pixelformat  = cam->fmt->pixelformat;
+
+	pix_format_set_size(&f->fmt.pix, cam->fmt, cam->width, cam->height);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* VIDIOC_S_FMT handlers */
+static int mp200_cam_vidioc_s_fmt_cap(struct file *file, void *fh,
+				      struct v4l2_format *f)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	ret = mp200_cam_vidioc_try_fmt_cap(file, fh, f);
+	if (ret < 0) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	if (cam->mapping || cam->reading || cam->streaming) {
+#else
+	if (cam->streaming) {
+#endif
+		warn("%s: s_fmt: streaming already exists.\n", CAM_NAME);
+		ret = -EBUSY;
+	} else {
+		const struct mp200_cam_fmt *fmt;
+
+		mutex_lock(&cam->lock);
+		fmt = format_by_pixelformat(f->fmt.pix.pixelformat);
+		if (cam->fmt->pixelformat != fmt->pixelformat) {
+			cam->reset = check_reset_fmt(cam->fmt, fmt);
+			cam->setup = 1;
+		}
+		if (cam->width != f->fmt.pix.width)
+			cam->setup = 1;
+		if (cam->height != f->fmt.pix.height)
+			cam->setup = 1;
+		cam->fmt    = fmt;
+		cam->width  = f->fmt.pix.width;
+		cam->height = f->fmt.pix.height;
+		mutex_unlock(&cam->lock);
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* Crop ioctls */
+static int mp200_cam_vidioc_cropcap(struct file *file, void *fh,
+				    struct v4l2_cropcap *c)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != c->type) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	mutex_lock(&cam->lock);
+	c->bounds  = cam->bounds;
+	c->defrect = cam->bounds;
+	c->pixelaspect.numerator   = 1;
+	c->pixelaspect.denominator = 1;
+	mutex_unlock(&cam->lock);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_g_crop(struct file *file, void *fh,
+				   struct v4l2_crop *crop)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != crop->type) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	mutex_lock(&cam->lock);
+	crop->c = cam->c;
+	mutex_unlock(&cam->lock);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_s_crop(struct file *file, void *fh,
+				   struct v4l2_crop *crop)
+{
+	int ret = 0;
+#if 0
+/* @@	__u32 width, height; */
+#else
+	__s32 width, height;
+#endif
+	FNC_ENTRY;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != crop->type) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	if (cam->mapping || cam->reading || cam->streaming) {
+#else
+	if (cam->streaming) {
+#endif
+		warn("%s: s_crop: streaming already exists.\n", CAM_NAME);
+		return -EBUSY;
+	}
+
+	crop->c.left = crop->c.left >> 1;
+	crop->c.left = crop->c.left << 1;
+
+#if 0
+/* @@	if (cam->bounds.left > crop->c.left) { */
+/* @@		crop->c.left = cam->bounds.left; */
+/* @@	} */
+/* @@ */
+/* @@	if (cam->bounds.top > crop->c.top) { */
+/* @@		crop->c.top = cam->bounds.top; */
+/* @@	} */
+/* @@ */
+/* @@	width = (cam->bounds.left + cam->bounds.width) - crop->c.left; */
+/* @@ */
+/* @@	if (width < crop->c.width) { */
+/* @@		crop->c.width = width; */
+/* @@	} */
+/* @@ */
+/* @@	height = (cam->bounds.top + cam->bounds.height) - crop->c.top; */
+/* @@ */
+/* @@	if (height < crop->c.height) { */
+/* @@		crop->c.height = height; */
+/* @@	} */
+#else
+	width = (cam->bounds.left + cam->bounds.width)
+		- abs(cam->bounds.left - crop->c.left);
+	if (width < crop->c.width)
+		crop->c.width = width;
+	crop->c.width = camif_fmt_boundary(cam->fmt, crop->c.width);
+
+	height = (cam->bounds.top + cam->bounds.height)
+		- abs(cam->bounds.top - crop->c.top);
+	if (height < crop->c.height)
+		crop->c.height = height;
+
+	if (cam->bounds.left > crop->c.left)
+		crop->c.left = cam->bounds.left;
+
+	if (cam->bounds.top > crop->c.top)
+		crop->c.top = cam->bounds.top;
+
+	if ((crop->c.left >= cam->bounds.left + cam->bounds.width)  ||
+	    (crop->c.top  >= cam->bounds.top  + cam->bounds.height) ||
+	    (crop->c.left + crop->c.width  <= cam->bounds.left)     ||
+	    (crop->c.top  + crop->c.height <= cam->bounds.top)      ||
+	    crop->c.width  <= 0                                    ||
+	    crop->c.height <= 0
+	    ) {
+		warn("%s: s_crop: crop out of range.\n", CAM_NAME);
+		return -EINVAL;
+	}
+#endif
+
+	mutex_lock(&cam->lock);
+	if (crop->c.width < cam->width) {
+#if 0
+/* @@		cam->width = camif_fmt_boundary(cam->fmt, crop->c.width); */
+#else
+		cam->width = crop->c.width;
+#endif
+		cam->setup = 1;
+	}
+#if 1
+	else if (camif_width_ratio_limit(cam->fmt, crop->c.width)
+		 > cam->width) {
+		crop->c.width = 1023 * cam->width / 64;
+		crop->c.width = camif_fmt_boundary(cam->fmt, crop->c.width);
+	}
+#endif
+
+	if (crop->c.height < cam->height) {
+		cam->height = crop->c.height;
+		cam->setup = 1;
+	}
+#if 1
+	else if (camif_height_ratio_limit(cam->fmt, crop->c.height)
+		 > cam->height)
+		crop->c.height = 1023 * cam->height / 64;
+#endif
+
+	if (cam->c.top    != crop->c.top
+	    || cam->c.left   != crop->c.left
+	    || cam->c.width  != crop->c.width
+	    || cam->c.height != crop->c.height) {
+		cam->c = crop->c;
+		cam->setup = 1;
+	}
+
+	mutex_unlock(&cam->lock);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* Buffer handlers */
+static int mp200_cam_vidioc_reqbufs(struct file *file, void *fh,
+				    struct v4l2_requestbuffers *req)
+{
+	struct mp200_cam_private *priv = fh;
+	int ret = 0;
+	unsigned int count;
+	FNC_ENTRY;
+
+	if (no_active(priv->number)) {
+		warn("%s: reqbufs: no active.\n", CAM_NAME);
+		return -EINVAL;
+	}
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != req->type) {
+		warn("%s: reqbufs: queue type invalid.\n", CAM_NAME);
+		return -EINVAL;
+	}
+
+	if (1 > req->count) {
+		warn("%s: reqbufs: count invalid (%d).\n",
+		     CAM_NAME, req->count);
+		return -EINVAL;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	if (V4L2_MEMORY_MMAP != req->memory
+	    && V4L2_MEMORY_USERPTR != req->memory) {
+#else
+	if (V4L2_MEMORY_USERPTR != req->memory) {
+#endif
+		warn("%s: reqbufs: memory type invalid.\n", CAM_NAME);
+		return -EINVAL;
+	}
+
+	if (cam->streaming) {
+		warn("%s: reqbufs: streaming already exists.\n", CAM_NAME);
+		return -EBUSY;
+	}
+	cam->reading = 0;
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	if (cam->mapping) {
+		warn("%s: reqbufs: buffers already mapping.\n", CAM_NAME);
+		return -EBUSY;
+	}
+#endif
+
+	mutex_lock(&cam->lock);
+	if (cam->action) {
+		cam_stream(CAM_OFF);
+		if (cam->done != cam->grab)
+			kfifo_reset(cam->done->enq);
+		kfifo_reset(cam->grab->enq);
+		kfifo_reset(cam->deq_grab);
+		kfifo_reset(cam->deq_done);
+	}
+
+	if (cam->done) {
+		cam_release_buffers(0);
+		cam->action = CAM_MMAP;
+	}
+
+	count = req->count;
+
+	if (CAM_MAX_BUFNBRS < count)
+		count = CAM_MAX_BUFNBRS;
+
+	ret = cam_request_buffers(CAM_MMAP, count, req->memory);
+
+	if (ret) {
+		warn("%s: mmap setup returned %d.\n", CAM_NAME, ret);
+		goto done_vidioc_reqbufs;
+	}
+
+	ret = cam_choice_function(CAM_MMAP);
+	if (ret) {
+		cam_release_buffers(0);
+		ret = -ENOMEM;
+		goto done_vidioc_reqbufs;
+	}
+
+	req->count = cam->done->max;
+
+done_vidioc_reqbufs:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_querybuf(struct file *file, void *fh,
+				     struct v4l2_buffer *b)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != b->type) {
+		warn("%s: querybuf: wrong type.\n", CAM_NAME);
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	if (!cam->done || cam->action || cam->reset) {
+		warn("%s: querybuf: buffer is null.\n", CAM_NAME);
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	if (0 > b->index || cam->done->max <= b->index) {
+		warn("%s: querybuf: index out of range.\n", CAM_NAME);
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+
+	cam_buffer_status(b, b->index, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_qbuf(struct file *file, void *fh,
+				 struct v4l2_buffer *b)
+{
+	struct mp200_cam_private *priv = fh;
+	int ret = 0;
+	__u32 bytesused, bpl;
+	struct mp200_cam_buffer *cdb;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: qbuf: no active.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	ret = -EBUSY;
+
+	if (cam->reading) {
+		warn("%s: qbuf: Reading running...\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+#endif
+
+	ret = -EINVAL;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != b->type) {
+		warn("%s: qbuf: Wrong type.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	if (!cam->done || cam->action || cam->reset) {
+		warn("%s: qbuf: buffer is null.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	if (0 > b->index || cam->done->max <= b->index) {
+		warn("%s: qbuf: index out of range.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	cdb = &cam->done->buff[b->index];
+
+	if (cam->done->memory != b->memory) {
+		warn("%s: qbuf: memory type is wrong.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	if (cdb->state == CAM_BUF_QUEUED ||
+	    cdb->state == CAM_BUF_GRABBING) {
+		warn("%s: qbuf: buffer is already queued or active.\n"
+		     , CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	/* XXX if (b->flags & V4L2_BUF_FLAG_INPUT) XXX */
+
+	bytesused = get_sizeimage(cam->done->fmt,
+				  cam->width, cam->height, &bpl);
+
+	switch (b->memory) {
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	case V4L2_MEMORY_MMAP:
+		if (0 == cdb->vadr) {
+			err("%s: qbuf: mmap requested"
+			    "but buffer addr is zero!\n", CAM_NAME);
+			goto done_vidioc_qbuf;
+		}
+		break;
+#endif
+	case V4L2_MEMORY_USERPTR:
+		if (b->length < bytesused) {
+			warn("%s: qbuf: buffer length is not enough.\n"
+			     , CAM_NAME);
+			goto done_vidioc_qbuf;
+		}
+
+		if (!b->m.userptr)
+			goto done_vidioc_qbuf;
+
+		if (cdb->m.userptr && cdb->m.userptr != b->m.userptr)
+			release_userptr(cdb);
+
+		if (!cdb->m.userptr) {
+			if (request_userptr(cdb, b->m.userptr, b->length))
+				goto done_vidioc_qbuf;
+		}
+		debug_dump(snprintf_buffs, cdb, 1, V4L2_MEMORY_USERPTR);
+		break;
+	default:
+		warn("%s: qbuf: wrong memory type.\n", CAM_NAME);
+		goto done_vidioc_qbuf;
+	}
+
+	b->field = V4L2_FIELD_NONE;
+
+	b->flags |= V4L2_BUF_FLAG_QUEUED;
+	b->flags &= ~V4L2_BUF_FLAG_DONE;
+
+	deq_pushq(b->index);
+
+	ret = 0;
+
+	if (cam->streaming) {
+		mutex_lock(&cam->frames_lock);
+		ret = cam_capture(0);
+		mutex_unlock(&cam->frames_lock);
+	}
+
+done_vidioc_qbuf:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_dqbuf(struct file *file, void *fh,
+				  struct v4l2_buffer *b)
+{
+	struct mp200_cam_private *priv = fh;
+	unsigned int len, index;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: dqbuf: no active.\n", CAM_NAME);
+		goto done_vidioc_dqbuf;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	ret = -EBUSY;
+
+	if (cam->reading) {
+		warn("%s: dqbuf: Reading running...\n", CAM_NAME);
+		goto done_vidioc_dqbuf;
+	}
+#endif
+
+	ret = -EINVAL;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != b->type) {
+		warn("%s: dqbuf: Wrong type.\n", CAM_NAME);
+		goto done_vidioc_dqbuf;
+	}
+
+	if (!cam->done || cam->action || cam->reset) {
+		warn("%s: dqbuf: buffer is null.\n", CAM_NAME);
+		goto done_vidioc_dqbuf;
+	}
+
+	len = deq_done_peepq(&index);
+
+	if (!len) {
+		warn("%s: dqbuf: no qbuf.\n", CAM_NAME);
+		goto done_vidioc_dqbuf;
+	}
+
+	/* debug_snprintf("%s(len : %d, index : %d)\n",
+				 __FUNCTION__, len, index); */
+
+	ret = cam_waiton(cam->done, cam->deq_done,
+			 file->f_flags & O_NONBLOCK, 1, 0, LIMIT_TIME * HZ);
+
+	if (ret)
+		goto done_vidioc_dqbuf;
+
+	memset(b, 0, sizeof(*b));
+	cam_buffer_status(b, index, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+
+#if 1
+	{
+		unsigned int index = deq_done_pullq();
+		cam->done->buff[index].state = CAM_BUF_IDLE;
+	}
+#else
+	cam->done->buff[deq_done_pullq()].state = CAM_BUF_IDLE;
+#endif
+
+done_vidioc_dqbuf:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/* Stream on/off */
+static int mp200_cam_vidioc_streamon(struct file *file, void *fh,
+				     enum v4l2_buf_type i)
+{
+	struct mp200_cam_private *priv = fh;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: streamon: no active.\n", CAM_NAME);
+		goto done_vidioc_streamon;
+	}
+
+	if (!cam->done || cam->action || cam->reset) {
+		warn("%s: streamon: buffer is null.\n", CAM_NAME);
+		goto done_vidioc_streamon;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	ret = -EBUSY;
+
+	if (cam->reading) {
+		warn("%s: streamon: Reading running...\n", CAM_NAME);
+		goto done_vidioc_streamon;
+	}
+#endif
+
+	ret = 0;
+
+	if (cam->streaming)
+		goto done_vidioc_streamon;
+
+	ret = cam_stream(CAM_ON);
+
+	if (ret)
+		goto done_vidioc_streamon;
+
+	cam->streaming = 1;
+
+	mutex_lock(&cam->frames_lock);
+	ret = cam_capture(0);
+	mutex_unlock(&cam->frames_lock);
+
+done_vidioc_streamon:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_vidioc_streamoff(struct file *file, void *fh,
+				      enum v4l2_buf_type i)
+{
+	struct mp200_cam_private *priv = fh;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: streamoff: no active.\n", CAM_NAME);
+		goto done_vidioc_streamoff;
+	}
+
+	if (!cam->streaming) {
+		warn("%s: streamoff: no streamon.\n", CAM_NAME);
+		goto done_vidioc_streamoff;
+	}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	ret = -EBUSY;
+
+	if (cam->reading) {
+		warn("%s: streamoff: Reading running...\n", CAM_NAME);
+		goto done_vidioc_streamoff;
+	}
+#endif
+
+	ret = 0;
+
+	cam_stream(CAM_OFF);
+
+	if (cam->done != cam->grab)
+		kfifo_reset(cam->done->enq);
+	kfifo_reset(cam->grab->enq);
+	kfifo_reset(cam->deq_grab);
+	kfifo_reset(cam->deq_done);
+
+	cam->streaming = 0;
+
+done_vidioc_streamoff:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static unsigned int mp200_cam_poll(struct file *file, poll_table *wait)
+{
+	struct mp200_cam_private *priv = file->private_data;
+	unsigned int len, index;
+	unsigned int rc = 0;
+	FNC_ENTRY;
+
+	if (no_active(priv->number)) {
+		warn("%s: poll: no active.\n", CAM_NAME);
+		FNC_EXIT(POLLERR)
+		return POLLERR;
+	}
+
+	mutex_lock(&cam->lock);
+
+	len = 0;
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	if (cam->mapping ||  cam->userptr) {
+		if (!cam->streaming) {
+			warn("%s: poll: no stream.\n", CAM_NAME);
+			rc = POLLERR;
+		}
+	} else {
+		if (!cam->reading) {
+			int ret;
+			ret = cam_read_start(0);
+			if (ret) {
+				warn("%s: read setup returned %d.\n",
+				     CAM_NAME, ret);
+				rc = POLLERR;
+			}
+		}
+	}
+#else
+	if (cam->userptr && !cam->streaming) {
+		warn("%s: poll: no stream.\n", CAM_NAME);
+		rc = POLLERR;
+	}
+#endif
+
+	len = deq_done_peepq(&index);
+
+	if (!len)
+		rc = POLLERR;
+
+	if (0 == rc) {
+		struct mp200_cam_buffer *cdb = &cam->done->buff[index];
+
+#if 1 /* XXX */
+		d1b("chk poll %d\n", cdb->state);
+
+		switch (cdb->state) {
+		case CAM_BUF_BREAK:
+			rc = POLLERR;
+			break;
+		case CAM_BUF_IDLE:
+		case CAM_BUF_QUEUED:
+		case CAM_BUF_GRABBING:
+			poll_wait(file, &cam->done->proc_list, wait);
+			if (CAM_BUF_BREAK == cdb->state) {
+				rc = POLLERR;
+				break;
+			}
+			if (CAM_BUF_DONE == cdb->state) {
+				rc = POLLIN | POLLRDNORM;
+				break;
+			}
+			break;
+		case CAM_BUF_GRAB:
+		case CAM_BUF_DONE:
+			d1b("chk poll 3 %d\n", CAM_BUF_QUEUED);
+			rc = POLLIN | POLLRDNORM;
+			break;
+		}
+#else
+		poll_wait(file, &cam->done->proc_list, wait);
+		if (CAM_BUF_DONE == cdb->state || CAM_BUF_BREAK == cdb->state)
+			rc = POLLIN | POLLRDNORM;
+#endif
+	}
+
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(rc)
+	return rc;
+}
+
+#if 0 /* not support V4L2_MEMORY_MMAP */
+static ssize_t mp200_cam_read(struct file *file, char *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct mp200_cam_private *priv = file->private_data;
+	int ret = 0;
+	unsigned int len, index, next;
+	__u32 cnt, bpl;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+
+	if (!count)
+		goto done_cam_read;
+
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: read: no active.\n", CAM_NAME);
+		goto done_cam_read;
+	}
+
+	if (cam->streaming) {
+		warn("%s: read: streaming already exists.\n", CAM_NAME);
+		goto done_cam_read;
+	}
+
+	if (cam->mapping) {
+		warn("%s: read: mapping done.\n", CAM_NAME);
+		goto done_cam_read;
+	}
+
+	if (cam->userptr) {
+		warn("%s: read: userptr done.\n", CAM_NAME);
+		goto done_cam_read;
+	}
+
+	if (!cam->reading) {
+		ret = cam_read_start(0);
+		if (ret) {
+			warn("%s: read setup returned %d.\n", CAM_NAME, ret);
+			goto done_cam_read;
+		}
+	}
+
+	cnt = get_sizeimage(cam->done->fmt, cam->width, cam->height, &bpl);
+
+	if (cnt > count) {
+		warn("%s: read: count < %d.\n", CAM_NAME, cnt);
+		goto done_cam_read;
+	}
+
+	ret = -EFAULT;
+
+	len = deq_done_peepq(&index);
+
+	if (!len) {
+		err("%s: read: no deq_done.\n", CAM_NAME);
+		goto done_cam_read;
+	}
+
+	ret = cam_waiton(cam->done, cam->deq_done,
+			 file->f_flags & O_NONBLOCK, 1, 0, LIMIT_TIME * HZ);
+
+	if (ret)
+		goto done_cam_read;
+
+	ret = -EFAULT;
+
+	if (cam->read_convert) {
+		ret = cam->read_convert(buf, index, cnt, bpl);
+		if (0 > ret) {
+			err("%s: read: convert fault.\n", CAM_NAME);
+			goto done_cam_read;
+		} else {
+			cnt = ret;
+		}
+	} else {
+		if (copy_to_user(buf, cam->done->buff[index].vadr, cnt)) {
+			err("%s: read: copy_to_user fault.\n", CAM_NAME);
+			goto done_cam_read;
+		}
+	}
+
+	cam->done->buff[index].state = CAM_BUF_IDLE;
+
+	next = deq_done_pullq();
+
+	assert(index == next);
+
+	deq_pushq(next);
+
+	mutex_lock(&cam->frames_lock);
+	ret = cam_capture(0);
+	mutex_unlock(&cam->frames_lock);
+
+	if (!ret)
+		ret = cnt;
+
+done_cam_read:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static struct vm_operations_struct cam_vm_ops = {
+	.open           = mp200_cam_vm_open,
+	.close          = mp200_cam_vm_close,
+};
+
+static int mp200_cam_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct mp200_cam_private *priv = file->private_data;
+	struct mp200_cam_frames *frm = cam->done;
+	struct mp200_cam_mapping *map;
+	unsigned int first, last, size, i;
+	unsigned int start = vma->vm_start;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+	ret = -EINVAL;
+
+	if (no_active(priv->number)) {
+		warn("%s: mmap: no active.\n", CAM_NAME);
+		goto done_cam_mmap;
+	}
+
+	if (!(vma->vm_flags & VM_WRITE)) {
+		warn("%s: mmap app bug: PROT_WRITE please.\n", CAM_NAME);
+		goto done_cam_mmap;
+	}
+
+	if (!(vma->vm_flags & VM_SHARED)) {
+		warn("%s: mmap app bug: MAP_SHARED please.\n", CAM_NAME);
+		goto done_cam_mmap;
+	}
+
+	if (!frm) {
+		warn("%s: mmap: buffer is null.\n", CAM_NAME);
+		goto done_cam_mmap;
+	}
+
+	if (V4L2_MEMORY_MMAP != frm->memory) {
+		warn("%s: mmap: memory type invalid.\n", CAM_NAME);
+		goto done_cam_mmap;
+	}
+
+	/* look for first buffer to map */
+	for (first = 0; first < frm->max; first++) {
+		if (frm->buff[first].m.offset == (vma->vm_pgoff << PAGE_SHIFT))
+			break;
+	}
+	if (frm->max == first) {
+		warn("%s: mmap app bug: offset invalid [offset=0x%lx]\n",
+		     CAM_NAME, (vma->vm_pgoff << PAGE_SHIFT));
+		goto done_cam_mmap;
+	}
+
+	/* look for last buffer to map */
+	for (size = 0, last = first; last < frm->max; last++) {
+		if (frm->buff[last].map) {
+			ret = -EBUSY;
+			goto done_cam_mmap;
+		}
+		size += frm->blocksize;
+		if (size == (vma->vm_end - vma->vm_start))
+			break;
+	}
+	if (frm->max == last) {
+		warn("%s: mmap app bug: size invalid [size=0x%lx]\n",
+		     CAM_NAME, (vma->vm_end - vma->vm_start));
+		goto done_cam_mmap;
+	}
+
+	/* create mapping */
+	ret = -ENOMEM;
+	map = kzalloc(sizeof(*map), GFP_KERNEL);
+
+	if (NULL == map)
+		goto done_cam_mmap;
+
+	for (i = first; i <= last; i++) {
+		unsigned long page;
+		unsigned long pos, blocksize;
+		pos = (unsigned long)frm->buff[i].vadr;
+		blocksize = frm->blocksize;
+
+		while (blocksize > 0) {
+			page = vmalloc_to_pfn((void *)pos);
+			if (remap_pfn_range(vma, start, page,
+					    PAGE_SIZE, PAGE_SHARED)) {
+				warn("%s: mmap: remap_pfn_range() failed!\n",
+				     CAM_NAME);
+				ret = -EAGAIN;
+				goto done_cam_mmap;
+			}
+			start += PAGE_SIZE;
+			pos += PAGE_SIZE;
+			if (blocksize > PAGE_SIZE)
+				blocksize -= PAGE_SIZE;
+			else
+				blocksize = 0;
+		}
+	}
+
+	for (i = first; i <= last; i++)
+		frm->buff[i].map = map;
+
+	map->start    = vma->vm_start;
+	map->end      = vma->vm_end;
+	vma->vm_ops   = &cam_vm_ops;
+	vma->vm_flags |= VM_DONTEXPAND | VM_RESERVED;
+	vma->vm_flags &= ~VM_IO; /* using shared anonymous pages */
+	vma->vm_private_data = map;
+
+	mp200_cam_vm_open(vma);
+
+	d1b("mmap %p: %08lx-%08lx pgoff %08lx bufs %d-%d\n",
+	    map, vma->vm_start, vma->vm_end, vma->vm_pgoff, first, last);
+	ret = 0;
+
+done_cam_mmap:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+#endif
+
+#define CAM_OPEN_MAX 32
+
+
+static int mp200_cam_open(struct inode *inode, struct file *file)
+{
+	int ret = 0, i;
+	struct mp200_cam_private *priv;
+	__u32 nouse;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+
+	if (CAM_OPEN_MAX <= cam->open_count) {
+		ret = -EBUSY;
+		goto done_cam_open;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto done_cam_open;
+	}
+
+	for (i = 0; i < CAM_OPEN_MAX; i++) {
+		nouse = 0x01 << i;
+		if (!(cam->used_number & nouse))
+			break;
+	}
+
+	if (0 == cam->active_number) {
+		assert(!cam->action)
+#if 0 /* not support V4L2_MEMORY_MMAP */
+		assert(!cam->reading)
+#endif
+		assert(!cam->streaming)
+		assert(!cam->done)
+
+		cam->status = 0;
+		cam->setup  = 1;
+		cam->reset  = 1;
+		cam->stop   = 0;
+		cam->frames_active = 0;
+
+		cam->th           = NULL;
+		cam->th_convert   = NULL;
+		cam->read_convert = NULL;
+		cam->done = NULL;
+
+		kfifo_reset(cam->deq_grab);
+		kfifo_reset(cam->deq_done);
+		kfifo_reset(cam->grab->enq);
+
+		cam->active_number = nouse;
+	}
+
+	if (0 == cam->open_count) {
+#ifdef MP200_CAM_MAKING_DEBUG
+#ifdef MP200_CAM_GLOBAL_DEFINE
+		ddump_cnt = 0;
+#endif
+#endif
+
+		ret = mp200_camif_startup(0);
+		if (ret) {
+			kfree(priv);
+			priv = NULL;
+			goto done_cam_open;
+		}
+
+		if (cam->hw.startup) {
+			ret = cam->hw.startup(0);
+			if (ret) {
+				kfree(priv);
+				priv = NULL;
+				goto done_cam_open;
+			}
+		}
+
+		if (cam->hw.sync) {
+			cam->pre.actions = 0;
+			ret = cam->hw.sync(&cam->pre);
+			if (ret) {
+				if (cam->hw.shutdown)
+					cam->hw.shutdown(0);
+				kfree(priv);
+				priv = NULL;
+				goto done_cam_open;
+			}
+		}
+
+		mp200_camif_unreset();
+	}
+
+	priv->number = nouse;
+
+	cam->used_number |= priv->number;
+
+	file->private_data = priv;
+
+	cam->open_count++;
+
+done_cam_open:
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_close(struct inode *inode, struct file *file)
+{
+	struct mp200_cam_private *priv = file->private_data;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&cam->lock);
+	cam->open_count--;
+
+	if (cam->active_number == priv->number) {
+
+		cam_stream(CAM_OFF);
+
+		cam->action    = 0;
+		cam->reading   = 0;
+		cam->streaming = 0;
+		cam->userptr   = 0;
+
+		if (cam->done)
+			cam_release_buffers(0);
+
+		cam->active_number = 0;
+	}
+
+	if (0 == cam->open_count) {
+		mp200_camif_shutdown(0);
+
+		if (cam->hw.shutdown)
+			cam->hw.shutdown(0);
+	}
+
+	/* d1b("chk used_number : 0x%08x number : 0x%08x \n",
+					cam->used_number, ~priv->number); */
+	cam->used_number &= ~priv->number;
+
+	debug_dump(snprintf_cam, cam);
+
+	kfree(priv);
+	priv = NULL;
+
+	mutex_unlock(&cam->lock);
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/*
+ * register V4L2 device
+ */
+
+static int video_nr = -1;
+
+static const struct file_operations mp200_cam_fops = {
+	.owner          = THIS_MODULE,
+	.open           = mp200_cam_open,
+	.release        = mp200_cam_close,
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	.read           = mp200_cam_read,
+#endif
+	.poll           = mp200_cam_poll,
+	.ioctl          = video_ioctl2,
+#if 0 /* not support V4L2_MEMORY_MMAP */
+	.mmap           = mp200_cam_mmap,
+#endif
+	.llseek         = no_llseek,
+};
+
+static const struct v4l2_ioctl_ops mp200_cam_ioctl_ops = {
+	.vidioc_querycap        = mp200_cam_vidioc_querycap,
+	.vidioc_enum_input      = mp200_cam_vidioc_enum_input,
+	.vidioc_g_input         = mp200_cam_vidioc_g_input,
+	.vidioc_s_input         = mp200_cam_vidioc_s_input,
+	.vidioc_queryctrl       = mp200_cam_vidioc_queryctrl,
+	.vidioc_querymenu       = mp200_cam_vidioc_querymenu,
+	.vidioc_g_ctrl          = mp200_cam_vidioc_g_ctrl,
+	.vidioc_s_ctrl          = mp200_cam_vidioc_s_ctrl,
+	.vidioc_enum_fmt_vid_cap        = mp200_cam_vidioc_enum_fmt_cap,
+	.vidioc_g_fmt_vid_cap   = mp200_cam_vidioc_g_fmt_cap,
+	.vidioc_s_fmt_vid_cap   = mp200_cam_vidioc_s_fmt_cap,
+	.vidioc_try_fmt_vid_cap         = mp200_cam_vidioc_try_fmt_cap,
+	.vidioc_cropcap         = mp200_cam_vidioc_cropcap,
+	.vidioc_g_crop          = mp200_cam_vidioc_g_crop,
+	.vidioc_s_crop          = mp200_cam_vidioc_s_crop,
+	.vidioc_reqbufs         = mp200_cam_vidioc_reqbufs,
+	.vidioc_querybuf        = mp200_cam_vidioc_querybuf,
+	.vidioc_qbuf            = mp200_cam_vidioc_qbuf,
+	.vidioc_dqbuf           = mp200_cam_vidioc_dqbuf,
+	.vidioc_streamon        = mp200_cam_vidioc_streamon,
+	.vidioc_streamoff       = mp200_cam_vidioc_streamoff,
+};
+
+static struct video_device mp200_cam_template = {
+	.ioctl_ops              = &mp200_cam_ioctl_ops,
+	.fops                   = &mp200_cam_fops,
+	.name                   = CAM_NAME,
+	.minor                  = -1,
+	.release                = video_device_release,
+};
+
+static int mp200_cam_register(int flag)
+{
+	int ret = -ENOMEM;
+	FNC_ENTRY;
+
+	cam = kzalloc(sizeof(*cam), GFP_KERNEL);
+
+	if (NULL == cam) {
+		err("%s: only one device allowed!\n", CAM_NAME);
+		goto out_mp200_cam_register;
+	}
+
+	mutex_init(&cam->lock);
+	mutex_init(&cam->frames_lock);
+
+	cam->deq_grab = kfifo_alloc(sizeof(int) * CAM_MAX_BUFNBRS * 2,
+				    GFP_KERNEL, &cam->deq_grab_lock);
+
+	if (IS_ERR(cam->deq_grab)) {
+		err("%s: deq_grab fifo allocation failed\n", CAM_NAME);
+		goto out_kfree_cam;
+	}
+
+	cam->deq_done = kfifo_alloc(sizeof(int) * CAM_MAX_BUFNBRS * 2,
+				    GFP_KERNEL, &cam->deq_done_lock);
+
+	if (IS_ERR(cam->deq_done)) {
+		err("%s: deq_done fifo allocation failed\n", CAM_NAME);
+		goto out_kfifo_free_deq_grab;
+	}
+
+	cam->grab = kzalloc(sizeof(*cam->grab), GFP_KERNEL);
+
+	if (NULL == cam->grab) {
+		err("%s: grab buffer allocation failed\n", CAM_NAME);
+		goto out_kfifo_free_deq_done;
+	}
+
+	init_waitqueue_head(&cam->grab->proc_list);
+
+	cam->grab->enq = kfifo_alloc(sizeof(struct mp200_enq_index)
+				     * CAM_MAX_BUFNBRS, GFP_KERNEL,
+				     &cam->grab->enq_lock);
+
+	if (IS_ERR(cam->grab->enq)) {
+		err("%s: grab fifo allocation failed\n", CAM_NAME);
+		goto out_kfree_grab;
+	}
+
+	cam->vdev = video_device_alloc();
+
+	if (NULL == cam->vdev) {
+		err("%s: video_device_alloc() failed!\n", CAM_NAME);
+		goto out_kfifo_free_grab;
+	}
+
+	memcpy(cam->vdev, &mp200_cam_template, sizeof(mp200_cam_template));
+	video_set_drvdata(cam->vdev, cam);
+
+	/* register v4l device */
+	ret = video_register_device(cam->vdev, VFL_TYPE_GRABBER, video_nr);
+
+	if (ret) {
+		err("%s: video_register_device() failed!\n", CAM_NAME);
+		goto out_video_device_release;
+	}
+
+	/* initialize the spinlock */
+	spin_lock_init(&cam->cam_lock);
+
+#ifdef CONFIG_PROC_FS
+	create_proc_mp200_cam(cam);
+#endif
+
+	FNC_EXIT(ret)
+	return 0;
+
+out_video_device_release:
+	video_device_release(cam->vdev);
+out_kfifo_free_grab:
+	kfifo_free(cam->grab->enq);
+out_kfree_grab:
+	kfree(cam->grab);
+	cam->grab = NULL;
+out_kfifo_free_deq_done:
+	kfifo_free(cam->deq_done);
+out_kfifo_free_deq_grab:
+	kfifo_free(cam->deq_grab);
+out_kfree_cam:
+	kfree(cam);
+	cam = NULL;
+out_mp200_cam_register:
+
+	FNC_EXIT(ret)
+	return ret;
+}
+static int mp200_cam_unregister(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	video_unregister_device(cam->vdev);
+
+#ifdef CONFIG_PROC_FS
+	destroy_proc_mp200_cam(cam);
+#endif
+
+	kfifo_free(cam->grab->enq);
+	kfree(cam->grab);
+	cam->grab = NULL;
+	kfifo_free(cam->deq_grab);
+	kfifo_free(cam->deq_done);
+	kfree(cam);
+	cam = NULL;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+/*
+ * Driver init and exit Functions
+ */
+
+#ifdef CONFIG_PM
+static int mp200_cam_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	switch (state.event) {
+	case DEV_SUSPEND_IDLE_1:
+	case PM_EVENT_SUSPEND:
+		if (cam->open_count)
+			ret = -EBUSY;
+		break;
+	default:
+		break;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+static int mp200_cam_resume(struct platform_device *dev)
+{
+	FNC_ENTRY;
+
+	FNC_EXIT(0)
+	return 0;
+}
+#endif
+
+static int mp200_cam_probe(struct platform_device *devptr)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	ret = mp200_cam_register(0);
+
+	if (ret)
+		goto out_mp200_cam_probe;
+	else
+		platform_set_drvdata(devptr, cam);
+
+	ret = mp200_camif_register(0);
+
+	if (ret)
+		goto out_mp200_cam_unregister;
+
+	ret = mp200_cam_hw_register(&cam->hw);
+
+	if (ret)
+		goto out_mp200_camif_unregister;
+
+	/* initial cam */
+	if (cam->hw.prepare) {
+		cam->pre.actions = 0;
+		ret = cam->hw.prepare(&cam->pre);
+		if (ret) {
+			FNC_EXIT(ret)
+			return ret;
+		}
+	} else {
+		err("%s: hw.prepare() nothing!\n", CAM_NAME);
+	}
+
+	cam->ipu  = CAM_IPU_OFF;
+#if MP200_CAM_NON_PMMU
+#else
+	cam->pmmu = CAM_PMMU_OFF;
+#endif
+
+	cam->sequence = 0;
+
+/* @@	cam->fmt = format_by_pixelformat(V4L2_PIX_FMT_YUYV); */
+	cam->fmt = format_by_pixelformat(V4L2_PIX_FMT_NV12);
+
+	cam_reset_update(0);
+
+	info("%s : \"%s\" registered device video%d [V4L2]\n",
+	     CAM_NAME, cam->hw.name, cam->vdev->minor);
+
+	d1b("chk VIDIOC_ENUMINPUT 0x%08x\n", VIDIOC_ENUMINPUT);
+
+	debug_dump(snprintf_cam, cam);
+
+	FNC_EXIT(0)
+	return 0;
+
+out_mp200_camif_unregister:
+	mp200_camif_unregister(0);
+out_mp200_cam_unregister:
+	mp200_cam_unregister(0);
+out_mp200_cam_probe:
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static int mp200_cam_remove(struct platform_device *devptr)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	cam->hw.unregister(0);
+	mp200_camif_unregister(0);
+	mp200_cam_unregister(0);
+	platform_set_drvdata(devptr, NULL);
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static struct platform_device *device;
+static struct platform_driver driver = {
+	.probe          = mp200_cam_probe,
+	.remove         = __devexit_p(mp200_cam_remove),
+#ifdef CONFIG_PM
+	.suspend        = mp200_cam_suspend,
+	.resume         = mp200_cam_resume,
+#endif
+	.driver.name    = CAM_NAME,
+};
+
+static int __init mp200_cam_init(void)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+#ifdef MP200_CAM_MAKING_DEBUG
+#ifdef MP200_CAM_GLOBAL_DEFINE
+	ddump_cnt = 0;
+	ddump = kzalloc(DUMP_MAX, GFP_KERNEL);
+	if (ddump == NULL) {
+		err("DUBUG: ddump allocation failed!\n");
+		FNC_EXIT(-ENOMEM)
+		return -ENOMEM;
+	}
+	/* info("DUBUG : cam logging on %p\n", ddump); */
+#endif
+#endif
+
+#ifdef CONFIG_PROC_FS
+	proc_mp200_cam_create();
+#endif
+#if 1 /* XXX */
+	warming_up = 1;
+#endif
+	ret = platform_driver_register(&driver);
+
+	if (0 > ret) {
+		err("%s: platform_driver_register() failed!\n", CAM_NAME);
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	device = platform_device_register_simple(CAM_NAME, -1, NULL, 0);
+
+	if (!IS_ERR(device)) {
+		if (platform_get_drvdata(device)) {
+			FNC_EXIT(ret)
+			return 0;
+		}
+		err("%s: platform_get_drvdata() failed!\n", CAM_NAME);
+		platform_device_unregister(device);
+		ret = -ENODEV;
+	} else {
+		err("%s: platform_device_register_simple() failed!\n",
+		    CAM_NAME);
+		ret = PTR_ERR(device);
+	}
+
+	platform_driver_unregister(&driver);
+
+#ifdef CONFIG_PROC_FS
+	proc_mp200_cam_destroy();
+#endif
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+static void __exit mp200_cam_exit(void)
+{
+	FNC_ENTRY;
+
+	platform_device_unregister(device);
+	platform_driver_unregister(&driver);
+
+#ifdef CONFIG_PROC_FS
+	proc_mp200_cam_destroy();
+#endif
+
+#ifdef MP200_CAM_MAKING_DEBUG
+#ifdef MP200_CAM_GLOBAL_DEFINE
+	kfree(ddump);
+	ddump = NULL;
+#endif
+#endif
+	FNC_EXIT(0)
+	return;
+}
+
+module_init(mp200_cam_init);
+module_exit(mp200_cam_exit);
+
+#ifdef MP200_CAM_MAKING_DEBUG
+#ifdef MP200_CAM_GLOBAL_DEFINE
+module_param(debug,  int, 0644);
+#endif
+#endif
+
+
+module_param(video_nr, int, 0);
+MODULE_PARM_DESC(video_nr, "video device to register (0=/dev/video0, etc)");
+
+MODULE_DESCRIPTION("Mega Camera driver for mp200 chip");
+MODULE_SUPPORTED_DEVICE("video");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/video/mp200_cam/mp200_cam.h b/drivers/media/video/mp200_cam/mp200_cam.h
new file mode 100644
index 0000000..0fae19f
--- /dev/null
+++ b/drivers/media/video/mp200_cam/mp200_cam.h
@@ -0,0 +1,247 @@
+/*
+ *  File Name	    : mp200_cam.h
+ *  Function	    : CAMERA I/F Driver local header
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2007/10/03
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#ifndef MP200_CAM_H
+#define MP200_CAM_H
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <mach/mp200_cam.h>
+#include <linux/proc_fs.h>
+#include <mach/ipu.h>
+
+#if MP200_CAM_NON_PMMU
+#else
+/*#include <asm/arch/mp200_pmmu.h>*/
+#endif
+
+/* ipu externs */
+extern int mp200_ipu_regist(struct mp200_ipu_req *p);
+extern int mp200_ipu_cancel(unsigned long sequence, int flag);
+#if MP200_CAM_NON_PMMU
+#else
+extern void *mp200_ipu_pmmu_map(int ipu_hw_func, unsigned long size);
+extern int mp200_ipu_pmmu_unmap(int ipu_hw_func, void *va, unsigned long size);
+#endif
+
+#define MP200_CAM_MAJ_VER       0
+#define MP200_CAM_MIN_VER       1
+#define MP200_CAM_PATCH_VER     0
+
+struct mp200_cam_prepare {
+	__u32 actions:1;
+	__u32 reset:1;
+	__u32 syncmode:1;        /* CA_CSR SYNCMODE */
+	__u32 synctype:1;        /* CA_CSR SYNCTYPE */
+	__u32 data_id:1;         /* CA_CSR DATA_ID */
+	__u32 vs_det:1;          /* CA_CSR VS_DET */
+	__u32 hs_det:1;          /* CA_CSR HS_DET */
+	__u32 clk_edge:1;        /* CA_CSR CLK_EDGE */
+	__u32 data_det:1;        /* CA_CSR DATA_DET */
+	__u32 vs_pol:1;          /* CA_CSR VS_POL */
+	__u32 hs_pol:1;          /* CA_CSR HS_POL */
+#if 1 /* XXX */
+	__u32 width;             /* Image width in pixels. */
+	__u32 height;            /* Image height in pixels. */
+	struct v4l2_rect c;      /* Cropping rectangle */
+#endif
+	struct v4l2_rect bounds; /* Defines the window within capturing */
+};
+
+struct mp200_cam_hw_operations {
+	__u8 name[32];
+	int (*vidioc_queryctrl)(struct file *file, void *fh,
+				struct v4l2_queryctrl *a);
+	int (*vidioc_g_ctrl)(struct file *file, void *fh,
+			     struct v4l2_control *a);
+	int (*vidioc_s_ctrl)(struct file *file, void *fh,
+			     struct v4l2_control *a);
+	int (*vidioc_querymenu)(struct file *file, void *fh,
+				struct v4l2_querymenu *a);
+	int (*prepare)(struct mp200_cam_prepare *);
+	int (*trigger)(int);
+#if 1 /* XXX */
+	int (*sync)(struct mp200_cam_prepare *);
+#else
+	int (*sync)(int);
+#endif
+	int (*stream_on)(int);
+	int (*stream_off)(int);
+	int (*startup)(int);
+	int (*shutdown)(int);
+	void *private;
+	int (*unregister)(int);
+};
+
+extern int mp200_cam_hw_register(struct mp200_cam_hw_operations *hw);
+
+#if 0
+#define err(format, arg...) printk(KERN_ERR format, ## arg)
+#define info(format, arg...) printk(KERN_INFO format, ## arg)
+#define warn(format, arg...) printk(KERN_WARNING format, ## arg)
+#define emerg(format, arg...) printk(KERN_EMERG format, ## arg)
+#define assert(expr) do {} while (0)
+#else
+#define err(format, arg...) printk(KERN_INFO format, ## arg)
+#define info(format, arg...) printk(KERN_INFO format, ## arg)
+#define warn(format, arg...) printk(KERN_INFO format, ## arg)
+#define emerg(format, arg...) printk(KERN_INFO format, ## arg)
+#define assert(expr) \
+	if (unlikely(!(expr))) {				 \
+		printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n",	  \
+		       # expr, __FILE__, __func__, __LINE__);      	   \
+	}
+#endif
+
+/*** DEBUG code by the making ->*/
+#ifdef MP200_CAM_MAKING_DEBUG
+
+#ifdef MP200_CAM_GLOBAL_DEFINE
+int debug = 2;
+char *ddump;
+int ddump_cnt;
+int ddump_cnt_max = 750;
+int ddump_page = 1;
+int entry_cnt;
+#else
+extern int debug;
+extern char *ddump;
+static int ddump_cnt_max;
+extern int ddump_cnt;
+extern int ddump_page;
+extern int entry_cnt;
+#endif
+
+#define DUMP_MAX (4096 * 4)
+
+#include <linux/moduleparam.h>
+
+#define FNC_ENTRY	\
+	if (debug == 1 || debug >= 9) {	\
+		char buf[20]; \
+		memset(buf, 0, 20); \
+		memset(buf, ' ', entry_cnt); \
+		entry_cnt++; \
+		printk(KERN_INFO "%s((%d:entry )):%s\n", buf, entry_cnt, \
+		       __func__); \
+	}
+#define FNC_EXIT(r)	\
+	if (debug == 1 || debug >= 9) {	\
+		int i = entry_cnt; \
+		char buf[20]; \
+		entry_cnt--; \
+		memset(buf, 0, 20); \
+		memset(buf, ' ', entry_cnt); \
+		printk(KERN_INFO "%s((%d:exit:%d)):%s:%d\n", buf, i, \
+		       r, __func__, __LINE__); \
+	}
+#define d0b(fmt, args...)	\
+	{ \
+		char buf[20]; \
+		memset(buf, 0, 20); \
+		memset(buf, ' ', entry_cnt + 1); \
+		printk(KERN_INFO "%s%s:%d: " fmt, buf, \
+		       __func__, __LINE__, ## args); \
+	}
+#define d1b(fmt, args...)	\
+	if (debug == 1 || debug >= 9) {	\
+		char buf[20]; \
+		memset(buf, 0, 20); \
+		memset(buf, ' ', entry_cnt + 1); \
+		printk(KERN_INFO "%s%s:%d: " fmt, buf, \
+		       __func__, __LINE__, ## args); \
+	}
+#define d2b(fmt, args...)	\
+	if (debug == 2 || debug >= 9) {	\
+		char buf[20]; \
+		memset(buf, 0, 20); \
+		memset(buf, ' ', entry_cnt + 1); \
+		printk(KERN_INFO "%s%s:%d: " fmt, buf, \
+		       __func__, __LINE__, ## args); \
+	}
+#define d3b(fmt, args...)	\
+	if (debug == 3 || debug >= 9) {	\
+		printk(KERN_INFO " --M%d-- " fmt, debug, ## args); \
+	}
+#define d4b(fmt, args...)	\
+	if (debug == 4 || debug >= 9) {	\
+		printk(KERN_INFO " --M%d-- " fmt, debug, ## args); \
+	}
+#define d5b(fmt, args...)	\
+	if (debug == 5 || debug >= 9) {	\
+		printk(KERN_INFO " --M%d-- " fmt, debug, ## args); \
+	}
+#define d6b(fmt, args...)	\
+	if (debug == 6 || debug >= 9) {	\
+		printk(KERN_INFO " --M%d-- " fmt, debug, ## args); \
+	}
+
+#define debug_page	\
+	{ \
+		if (DUMP_MAX <= (ddump_cnt + ddump_cnt_max + 128)) { \
+			ddump_cnt = 0; \
+			ddump_page++; \
+		} \
+		ddump_cnt += snprintf(ddump + ddump_cnt, \
+				      DUMP_MAX - ddump_cnt,  \
+				      "-- p.%d +%d -->\n", ddump_page, \
+				      ddump_cnt);		       \
+	}
+
+#define debug_snprintf(fmt, args...)	\
+	{ \
+		debug_page; \
+		ddump_cnt += snprintf(ddump + ddump_cnt, \
+				      DUMP_MAX - ddump_cnt, fmt, ## args); \
+	}
+
+#define debug_dump(func, args...)	\
+	{ \
+		int i; \
+		debug_page; \
+		i = func(ddump + ddump_cnt, DUMP_MAX - ddump_cnt, ## args); \
+		if (ddump_cnt_max < i) { \
+			ddump_cnt_max = i; \
+		} \
+		ddump_cnt += i;	\
+		ddump_cnt += snprintf(ddump + ddump_cnt, \
+				      DUMP_MAX - ddump_cnt, "<-- %d --\n", i); \
+	}
+#else
+#define FNC_ENTRY do { } while (0);
+#define FNC_EXIT(r) do { } while (0);
+#define d0b(fmt, args...) do { } while (0);
+#define d1b(fmt, args...) do { } while (0);
+#define d2b(fmt, args...) do { } while (0);
+#define d3b(fmt, args...) do { } while (0);
+#define d4b(fmt, args...) do { } while (0);
+#define d5b(fmt, args...) do { } while (0);
+#define d6b(fmt, args...) do { } while (0);
+#define debug_dump(func, args...) do { } while (0);
+#define debug_snprintf(fmt, args...) do { } while (0);
+#endif
+/*<- end of DEBUG code ***/
+#endif
+
diff --git a/drivers/media/video/mp200_cam/mp200_mega.c b/drivers/media/video/mp200_cam/mp200_mega.c
new file mode 100644
index 0000000..4e02aca
--- /dev/null
+++ b/drivers/media/video/mp200_cam/mp200_mega.c
@@ -0,0 +1,3236 @@
+/*
+ *  File Name       : mp200_mega.c
+ *  Function        : MEGA for CAMERA I/F Driver
+ *  Release Version : Ver 0.01
+ *  Release Date    : 2009/06/03
+ *
+ *  Copyright (C) NEC Electronics Corporation 2009
+ *
+ *  This program is free software;you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by Free
+ *  Softwere Foundation; either version 2 of License, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY;
+ *  without even the implied warrnty of MERCHANTABILITY or FITNESS FOR A
+ *  PARTICULAR PURPOSE.
+ *  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program;
+ *  If not, write to the Free Software Foundation, Inc., 59 Temple Place -
+ *  Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <mach/spi.h>
+#include <mach/gpio.h>
+#include <mach/pmu.h>
+#include <mach/smu.h>
+
+/* #define MP200_CAM_MAKING_DEBUG */
+
+#include "mp200_cam.h"
+
+
+#define DEV_NAME "mp200_mega"
+
+#define CAM_DEBUG 0
+
+#define printk_info(fmt, arg...) \
+	do {			  \
+		printk(KERN_INFO DEV_NAME ": %s(%d): " fmt "\n" \
+		       , __func__, __LINE__, ## arg);		\
+	} while (0)
+
+
+/*===============================================================*/
+/* I2C Functions                                                 */
+/*===============================================================*/
+#define RJ6ABA100_I2C (0x50) /* 1010000(bit) */
+
+/* flags */
+static int i2c_stop;
+
+static unsigned short normal_i2c[] = { RJ6ABA100_I2C, I2C_CLIENT_END };
+static unsigned short ignore = I2C_CLIENT_END;
+
+/* prottyped */
+static int rj6aba100_i2c_attach(struct i2c_adapter *adapter,
+				int addr, int kind);
+static int rj6aba100_i2c_probe(struct i2c_adapter *adapter);
+static int rj6aba100_i2c_detach(struct i2c_client *client);
+static int rj6aba100_i2c_command(struct i2c_client *client,
+				 unsigned int cmd, void *arg);
+static inline int rj6aba100_i2c_write(unsigned char cmd,
+				      unsigned char *buf, unsigned char len);
+static inline int rj6aba100_i2c_read(unsigned char cmd,
+				     unsigned char *buf, unsigned char len);
+
+/* i2c registerd infomation */
+static struct i2c_client_address_data rj6aba100_i2c_addr_data = {
+	.normal_i2c     = normal_i2c,
+	.probe          = &ignore,
+	.ignore         = &ignore,
+};
+
+static struct i2c_driver rj6aba100_i2c_driver = {
+	.driver.name    = "i2c for RJ6ABA100",
+	.id             = I2C_DRIVERID_I2CDEV, /* Fake ID */
+	.attach_adapter = rj6aba100_i2c_probe,
+	.detach_client  = rj6aba100_i2c_detach,
+	.command        = rj6aba100_i2c_command,
+};
+static struct i2c_client *rj6aba100_i2c_client;
+
+/* i2c registerd function */
+static int rj6aba100_i2c_attach(struct i2c_adapter *adapter, int addr, int kind)
+{
+
+	rj6aba100_i2c_client = kzalloc(sizeof(*rj6aba100_i2c_client),
+				       GFP_KERNEL);
+
+	if (NULL == rj6aba100_i2c_client) {
+		err("rj6aba100_i2c_client allocation failed!\n");
+		return -ENOMEM;
+	}
+
+	sprintf(rj6aba100_i2c_client->name, "Mega-%02x", RJ6ABA100_I2C);
+	rj6aba100_i2c_client->adapter = adapter;
+	rj6aba100_i2c_client->addr    = addr;
+	rj6aba100_i2c_client->driver  = &rj6aba100_i2c_driver;
+
+	return i2c_attach_client(rj6aba100_i2c_client);
+}
+
+static int rj6aba100_i2c_probe(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &rj6aba100_i2c_addr_data,
+			 rj6aba100_i2c_attach);
+}
+
+static int rj6aba100_i2c_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	kfree(client);
+	return 0;
+}
+
+static int rj6aba100_i2c_command(struct i2c_client *client,
+				 unsigned int cmd, void *arg)
+{
+	return 0;
+}
+
+/* usable i2c funcrion */
+static inline int rj6aba100_i2c_write(unsigned char cmd,
+				      unsigned char *buf, unsigned char len)
+{
+	int ret = 0;
+	char s_buf[15];
+	struct i2c_msg msg = { .addr = RJ6ABA100_I2C, .flags = 0,
+			       .buf = s_buf, .len = len + 1 };
+
+	s_buf[0] = cmd;
+	memcpy(&s_buf[1], buf, len);
+
+	if (i2c_stop)
+		return -EIO;
+
+	assert(rj6aba100_i2c_client);
+
+	ret = i2c_transfer(rj6aba100_i2c_client->adapter, &msg, 1);
+	if (1 != ret) {
+		err("i2c_transfer: cmd : 0x%02x ret = %d\n", cmd, ret);
+		i2c_stop = 1;
+		ret = -EIO;
+	} else {
+		ret = 0;
+	}
+	return ret;
+}
+
+static inline int rj6aba100_i2c_read(unsigned char cmd,
+				     unsigned char *buf, unsigned char len)
+{
+	int ret = 0;
+	struct i2c_msg msg[] =  {{ .addr = RJ6ABA100_I2C, .flags = 0,
+				   .buf = &cmd, .len = 1 },
+				 { .addr = RJ6ABA100_I2C, .flags = I2C_M_RD,
+				   .buf = buf,  .len = len } };
+	if (i2c_stop)
+		return -EIO;
+
+	assert(rj6aba100_i2c_client);
+
+	ret = i2c_transfer(rj6aba100_i2c_client->adapter, msg, 2);
+	if (2 != ret) {
+		err("i2c_transfer: cmd : 0x%02x ret = %d\n", cmd, ret);
+		i2c_stop = 1;
+		ret = -EIO;
+	} else {
+		ret = 0;
+	}
+	return ret;
+}
+
+
+
+/*===============================================================*/
+/* RJ6ABA100 Camera control flags                                */
+/*===============================================================*/
+enum {
+	MP200_RJ6ABA100_IDLE = 0,
+	MP200_RJ6ABA100_LIVE,
+	MP200_RJ6ABA100_CAPTURE,
+	MP200_RJ6ABA100_BREAK,
+};
+
+struct mp200_rj6aba100 {
+	int state;
+	struct mutex lock;
+
+	__u32 active:1;
+	__u32 reset:1;
+
+	__u8 firmware_version;
+	__u8 capture_size;
+	__u8 outimg_fmt;
+	__u8 imgdata_fmt;
+	__u8 flicker_manual;
+	__u8 wb_mode;
+	__u32 wb_manual_gain;
+	__u8 brightness;
+	__u8 contrast;
+	__u32 sharpness;
+	__u8 mirror;
+	__u8 efct_color;
+	__u8 efct_emboss;
+	__u8 efct_negative;
+	__u8 efct_sketch;
+};
+
+struct mp200_rj6aba100 *rj6aba100;
+
+
+/*===============================================================*/
+/* RJ6ABA100 data structure. for VIDIOC_S_CTRL                   */
+/*===============================================================*/
+struct control_menu_info {
+	int value;
+	char name[32];
+};
+
+
+struct control_resize_info {
+	int value;
+	char name[32];
+	__s32 x;
+	__s32 y;
+	__s32 width;
+	__s32 height;
+};
+
+
+/* MP200_RJ6ABA100_CID_OUTIMG_SIZE */
+static const struct control_resize_info rj6aba100_outimg_size_menus[] =
+{
+	{ 0x00, "QQVGA : 160x120",  3, 2, 162, 121 },
+	{ 0x01, "QCIF  : 176x144", 11, 2, 144, 176 },
+	{ 0x02, "QVGA  : 320x240",  4, 4, 323, 243 },
+	{ 0x03, "CIF   : 352x288", 22, 5, 373, 292 },
+	{ 0x04, "VGA   : 640x480",  7, 7, 646, 486 },    /* default */
+};
+#define NUM_OUTIMG_SIZE_MENUS ARRAY_SIZE(rj6aba100_outimg_size_menus)
+#define BOUNDARY_OUT_IMG_RESIZE 0x04 /* 640x480 */
+
+
+/* MP200_RJ6ABA100_CID_OUTIMG_FORMAT */
+#define OUT_FORMAT_YCBCR422 0x00
+#define OUT_FORMAT_YUV422   0x01
+#define OUT_FORMAT_RGB_RAW  0x02
+#define OUT_FORMAT_RGB565   0x03
+#define OUT_FORMAT_RGB444   0x04
+#define OUT_FORMAT_MONO     0x05
+static const struct control_menu_info rj6aba100_outimg_fmt_menus[] =
+{
+	{ 0x00, "YCbCr422",       },
+	{ 0x01, "YUV422",         },     /* default */
+	{ 0x02, "RGB Bayer(RAW)", },
+	{ 0x03, "RGB565",         },
+	{ 0x04, "RGB444",         },
+	{ 0x05, "Mono",           },
+};
+#define NUM_OUTIMG_FORMAT_MENUS ARRAY_SIZE(rj6aba100_outimg_fmt_menus)
+
+
+/* MP200_RJ6ABA100_CID_OUTDATA_FORMAT */
+static const struct control_menu_info
+rj6aba100_outdata_fmt_menus[NUM_OUTIMG_FORMAT_MENUS][4] =
+{
+	{       /* YCbCr422 */
+		{ 0x00, "CbYCrY...",   },
+		{ 0x01, "CrYCbY...",   },
+		{ 0x02, "YCbYCr...",   },
+		{ 0x03, "YCrYCb...",   },
+	}, {     /* YUV422 */
+		{ 0x00, "UYVY...",     },        /* default */
+		{ 0x01, "VYUY...",     },
+		{ 0x02, "YUYV...",     },
+		{ 0x03, "YVYU...",     },
+	}, {     /* RGB Bayer */
+		{ 0x04, "RGRG...GBGB", },
+		{ 0x05, "GBGB...RGRG", },
+		{ 0x06, "GRGR...BGBG", },
+		{ 0x07, "BGBG...GRGR", },
+	}, {     /* RGB565 */
+		{ 0x08, "R5G6B5...",   },
+		{ 0x09, "B5G6R5...",   },
+		{ 0xFF, "Reserved",   },
+		{ 0xFF, "Reserved",   },
+	}, {     /* RGB444 */
+		{ 0x0E, "R4G4B4...",   },
+		{ 0xFF, "Reserved",   },
+		{ 0xFF, "Reserved",   },
+		{ 0xFF, "Reserved",   },
+	}, {     /* Mono */
+		{ 0x0D, "YYYY...",     },
+		{ 0xFF, "Reserved",   },
+		{ 0xFF, "Reserved",   },
+		{ 0xFF, "Reserved",   },
+	}
+};
+#define NUM_OUTDATA_FORMAT_MENUS ARRAY_SIZE(rj6aba100_outdata_fmt_menus)
+
+
+/* MP200_RJ6ABA100_CID_FLICKER */
+static const struct control_menu_info rj6aba100_flicker_menus[] =
+{
+	{ 0x00, "Disable Friker detection"   },
+	{ 0x32, "Auto Friker detection mode" },
+	{ 0x04, "Manual 60Hz Friker mode"    }, /* default */
+	{ 0x08, "Manual 50Hz Friker mode"    },
+};
+#define NUM_FLICKER_MENUS ARRAY_SIZE(rj6aba100_flicker_menus)
+
+
+/* MP200_RJ6ABA100_CID_WB */
+static const struct control_menu_info rj6aba100_wb_menus[] =
+{
+	{ 0x00, "Auto WB"   }, /* default */
+	{ 0x01, "Manual WB" },
+};
+#define NUM_WB_MENUS ARRAY_SIZE(rj6aba100_wb_menus)
+
+
+/* MP200_RJ6ABA100_CID_MIRROR */
+static const struct control_menu_info rj6aba100_mirror_menus[] =
+{
+	{ 0x00, "Mirror Off"                       }, /* default */
+	{ 0x01, "Mirror Horizontally"              },
+	{ 0x02, "Mirror Vertically"                },
+	{ 0x03, "Mirror Horizontally & Vertically" },
+};
+#define NUM_MIRROR_MENUS ARRAY_SIZE(rj6aba100_mirror_menus)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_COLOR */
+static const struct control_menu_info rj6aba100_effect_color_menus[] =
+{
+	{ 0x00, "Color Effect Off"     }, /* default */
+	{ 0x01, "Color Effect Sepia"   },
+	{ 0x02, "Color Effect Green"   },
+	{ 0x03, "Color Effect Aqua"    },
+	{ 0x04, "Color Effect Red"     },
+	{ 0x05, "Color Effect Cool"    },
+	{ 0x06, "Color Effect Warm"    },
+	{ 0x07, "Color Effect BW"      },
+	{ 0x08, "Color Effect Antique" },
+	{ 0x09, "Color Effect UserSet" },
+};
+#define NUM_EFFECT_COLOR_MENUS   ARRAY_SIZE(rj6aba100_effect_color_menus)
+#define NUM_EFFECT_COLOR_MANUAL (NUM_EFFECT_COLOR_MENUS - 1)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_NEGATIVE */
+static const struct control_menu_info rj6aba100_effect_negative_menus[] =
+{
+	{ 0x00, "Negative Effect Off" }, /* default */
+	{ 0x01, "Negative Effect On"  },
+};
+#define NUM_EFFECT_NEGATIVE_MENUS ARRAY_SIZE(rj6aba100_effect_negative_menus)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_EMBOSS */
+static const struct control_menu_info rj6aba100_effect_emboss_menus[] =
+{
+	{ 0x00, "Emboss Effect Off"   }, /* default */
+	{ 0x01, "Emboss Effect mode0" },
+	{ 0x02, "Emboss Effect mode1" },
+};
+#define NUM_EFFECT_EMBOSS_MENUS ARRAY_SIZE(rj6aba100_effect_emboss_menus)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_SKETCH */
+static const struct control_menu_info rj6aba100_effect_sketch_menus[] =
+{
+	{ 0x00, "Sketch Effect Off"     }, /* default */
+	{ 0x01, "Sketch Effect image1"  },
+	{ 0x02, "Sketch Effect image2"  },
+	{ 0x03, "Sketch Effect image3"  },
+	{ 0x04, "Sketch Effect image4"  },
+	{ 0x05, "Sketch Effect UserSet" },
+};
+#define NUM_EFFECT_SKETCH_MENUS   ARRAY_SIZE(rj6aba100_effect_sketch_menus)
+#define NUM_EFFECT_SKETCH_MANUAL (NUM_EFFECT_SKETCH_MENUS - 1)
+
+
+/*===============================================================*/
+/* RJ6ABA100 data structure. for VIDIOC_QUERYCTRL                */
+/*===============================================================*/
+static const struct v4l2_queryctrl no_ctrl = {
+	.name  = "rj6aba100",
+	.flags = V4L2_CTRL_FLAG_DISABLED,
+};
+
+/* default settings */
+static const struct v4l2_queryctrl rj6aba100_ctrls[] = {
+	{
+		.id            = MP200_RJ6ABA100_CID_OUTIMG_SIZE,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Output image size",
+#if 0
+/* @@		.minimum       = 0, */
+/* @@		.maximum       = (NUM_OUTIMG_SIZE_MENUS - 1), */
+#else /* VGA only */
+		.minimum       = 4,
+		.maximum       = 4,
+#endif
+		.step          = 1,
+		.default_value = 4, /* VGA */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_OUTIMG_FORMAT,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Output image Format",
+#if 0
+/* @@		.minimum       = 0, */
+/* @@		.maximum       = (NUM_OUTIMG_FORMAT_MENUS - 1), */
+#else /* YUV422 only */
+		.minimum       = 1,
+		.maximum       = 1,
+#endif
+		.step          = 1,
+		.default_value = 1, /* YUV422 */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_OUTDATA_FORMAT,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Output data Format",
+		.minimum       = 0,
+#if 0
+/* @@		.maximum       = (NUM_OUTDATA_FORMAT_MENUS
+   / NUM_OUTIMG_FORMAT_MENUS - 1), */
+#else /* UYVY... only */
+		.maximum       = 0,
+#endif
+		.step          = 1,
+		.default_value = 0, /* UYVY... */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_FW,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Revision Number of RJ6ABA100",
+		.minimum       = 0,
+		.maximum       = 0xFF,
+		.step          = 1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_FLICKER,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Flicker Mode",
+		.minimum       = 0,
+		.maximum       = (NUM_FLICKER_MENUS - 1),
+		.step          = 1,
+		.default_value = 2, /* 60Hz freker free */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_WB,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "AWB on/off",
+		.minimum       = 0,
+		.maximum       = (NUM_WB_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* AWB on */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_WB_MANUAL_GAIN,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Manual WB(Rgain, Ggain, Bgain)",
+		.minimum       = 0,
+		.maximum       = 0xFFFFFF,
+		.step          = 1,
+		.default_value = 0x404040,
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 1,
+		.default_value = 0x01,
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Y Contrast",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 0x40,
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_SHARPNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Edge Gain/Threshold",
+		.minimum       = 0,
+		.maximum       = 0x3FFF,
+		.step          = 1,
+		.default_value = 0x2410,
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_MIRROR,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Mirror Horizontally & Vertically",
+		.minimum       = 0,
+		.maximum       = (NUM_MIRROR_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* Mirror Off */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_COLOR,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Color Effect",
+		.minimum       = 0,
+		.maximum       = (NUM_EFFECT_COLOR_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* Color Effect Off */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Color Effect (user set)",
+		.minimum       = 0,
+		.maximum       = 0xFFFF,
+		.step          = 1,
+		.default_value = 0x30B0,
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_NEGATIVE,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Negative Effect",
+		.minimum       = 0,
+		.maximum       = (NUM_EFFECT_NEGATIVE_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* Negative Effect Off */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_EMBOSS,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Emboss Effect",
+		.minimum       = 0,
+		.maximum       = (NUM_EFFECT_EMBOSS_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* Emboss Effect Off */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_SKETCH,
+		.type          = V4L2_CTRL_TYPE_MENU,
+		.name          = "Sketch Effect",
+		.minimum       = 0,
+		.maximum       = (NUM_EFFECT_SKETCH_MENUS - 1),
+		.step          = 1,
+		.default_value = 0, /* Sketch Effect Off */
+		.flags         = 0,
+	}, {
+		.id            = MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Sketch Effect (user set)",
+		.minimum       = 0,
+		.maximum       = 0xFFFFFFFF,
+		.step          = 1,
+		.default_value = 0x20C81080,
+		.flags         = 0,
+	}
+};
+#define NUM_RJ6ABA100_CTRLS ARRAY_SIZE(rj6aba100_ctrls)
+
+
+/*===============================================================*/
+/* RJ6ABA100 register data structure                             */
+/*===============================================================*/
+struct register_info {
+	unsigned char bank;
+	unsigned char address;
+	unsigned char data;
+	unsigned char mask;
+};
+
+
+/* RJ6ABA100 register groupe : output image size */
+static const struct register_info
+rj6aba100_register_outimg_size[NUM_OUTIMG_SIZE_MENUS][23] =
+{
+	{       /* QQVGA */
+		{0x01, 0x3D, 0x80, 0xFF},       {0x01, 0x3E, 0x80, 0xFF},
+		{0x01, 0x2D, 0x00, 0xFF},       {0x01, 0x2E, 0x15, 0xFF},
+		{0x01, 0x2F, 0x01, 0xFF},       {0x01, 0x30, 0xF5, 0xFF},
+		{0x02, 0x58, 0x00, 0xFF},       {0x02, 0x59, 0x04, 0xFF},
+		{0x02, 0x5A, 0x00, 0xFF},       {0x02, 0x5B, 0x00, 0xFF},
+		{0x02, 0x5C, 0x00, 0xFF},       {0x02, 0x5D, 0xA0, 0xFF},
+		{0x02, 0x5E, 0x00, 0xFF},       {0x02, 0x5F, 0x78, 0xFF},
+		{0x02, 0x60, 0x00, 0xFF},       {0x02, 0x61, 0x38, 0xFF},
+		{0x02, 0x62, 0x00, 0xFF},       {0x02, 0x63, 0x2A, 0xFF},
+		{0x02, 0x64, 0x00, 0xFF},       {0x02, 0x65, 0x30, 0xFF},
+		{0x02, 0x66, 0x00, 0xFF},       {0x02, 0x67, 0x24, 0xFF},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* QCIF */
+		{0x01, 0x3D, 0x6A, 0xFF},       {0x01, 0x3E, 0x6A, 0xFF},
+		{0x01, 0x2D, 0x00, 0xFF},       {0x01, 0x2E, 0x15, 0xFF},
+		{0x01, 0x2F, 0x01, 0xFF},       {0x01, 0x30, 0xF2, 0xFF},
+		{0x02, 0x58, 0x00, 0xFF},       {0x02, 0x59, 0x05, 0xFF},
+		{0x02, 0x5A, 0x00, 0xFF},       {0x02, 0x5B, 0x00, 0xFF},
+		{0x02, 0x5C, 0x00, 0xFF},       {0x02, 0x5D, 0xC1, 0xFF},
+		{0x02, 0x5E, 0x00, 0xFF},       {0x02, 0x5F, 0x90, 0xFF},
+		{0x02, 0x60, 0x00, 0xFF},       {0x02, 0x61, 0x44, 0xFF},
+		{0x02, 0x62, 0x00, 0xFF},       {0x02, 0x63, 0x33, 0xFF},
+		{0x02, 0x64, 0x00, 0xFF},       {0x02, 0x65, 0x3A, 0xFF},
+		{0x02, 0x66, 0x00, 0xFF},       {0x02, 0x67, 0x2B, 0xFF},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* QVGA */
+		{0x01, 0x3D, 0x40, 0xFF},       {0x01, 0x3E, 0x40, 0xFF},
+		{0x01, 0x2D, 0x00, 0xFF},       {0x01, 0x2E, 0x15, 0xFF},
+		{0x01, 0x2F, 0x01, 0xFF},       {0x01, 0x30, 0xF5, 0xFF},
+		{0x02, 0x58, 0x00, 0xFF},       {0x02, 0x59, 0x07, 0xFF},
+		{0x02, 0x5A, 0x00, 0xFF},       {0x02, 0x5B, 0x00, 0xFF},
+		{0x02, 0x5C, 0x01, 0xFF},       {0x02, 0x5D, 0x40, 0xFF},
+		{0x02, 0x5E, 0x00, 0xFF},       {0x02, 0x5F, 0xF0, 0xFF},
+		{0x02, 0x60, 0x00, 0xFF},       {0x02, 0x61, 0x70, 0xFF},
+		{0x02, 0x62, 0x00, 0xFF},       {0x02, 0x63, 0x54, 0xFF},
+		{0x02, 0x64, 0x00, 0xFF},       {0x02, 0x65, 0x60, 0xFF},
+		{0x02, 0x66, 0x00, 0xFF},       {0x02, 0x67, 0x48, 0xFF},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* CIF */
+		{0x01, 0x3D, 0x35, 0xFF},       {0x01, 0x3E, 0x35, 0xFF},
+		{0x01, 0x2D, 0x00, 0xFF},       {0x01, 0x2E, 0x16, 0xFF},
+		{0x01, 0x2F, 0x01, 0xFF},       {0x01, 0x30, 0xF4, 0xFF},
+		{0x02, 0x58, 0x00, 0xFF},       {0x02, 0x59, 0x09, 0xFF},
+		{0x02, 0x5A, 0x00, 0xFF},       {0x02, 0x5B, 0x00, 0xFF},
+		{0x02, 0x5C, 0x01, 0xFF},       {0x02, 0x5D, 0x82, 0xFF},
+		{0x02, 0x5E, 0x01, 0xFF},       {0x02, 0x5F, 0x21, 0xFF},
+		{0x02, 0x60, 0x00, 0xFF},       {0x02, 0x61, 0x88, 0xFF},
+		{0x02, 0x62, 0x00, 0xFF},       {0x02, 0x63, 0x66, 0xFF},
+		{0x02, 0x64, 0x00, 0xFF},       {0x02, 0x65, 0x74, 0xFF},
+		{0x02, 0x66, 0x00, 0xFF},       {0x02, 0x67, 0x56, 0xFF},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* VGA */
+		{0x01, 0x3D, 0x20, 0xFF},       {0x01, 0x3E, 0x20, 0xFF},
+		{0x01, 0x2D, 0x00, 0xFF},       {0x01, 0x2E, 0x15, 0xFF},
+		{0x01, 0x2F, 0x01, 0xFF},       {0x01, 0x30, 0xF5, 0xFF},
+		{0x02, 0x58, 0x00, 0xFF},       {0x02, 0x59, 0x0E, 0xFF},
+		{0x02, 0x5A, 0x00, 0xFF},       {0x02, 0x5B, 0x00, 0xFF},
+		{0x02, 0x5C, 0x02, 0xFF},       {0x02, 0x5D, 0x80, 0xFF},
+		{0x02, 0x5E, 0x01, 0xFF},       {0x02, 0x5F, 0xE0, 0xFF},
+		{0x02, 0x60, 0x00, 0xFF},       {0x02, 0x61, 0xE0, 0xFF},
+		{0x02, 0x62, 0x00, 0xFF},       {0x02, 0x63, 0xA8, 0xFF},
+		{0x02, 0x64, 0x00, 0xFF},       {0x02, 0x65, 0xC0, 0xFF},
+		{0x02, 0x66, 0x00, 0xFF},       {0x02, 0x67, 0x90, 0xFF},
+		{0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_OUTIMG_SIZE_REGS ARRAY_SIZE(rj6aba100_register_outimg_size)
+
+
+/* RJ6ABA100 register groupe : output image format */
+static const struct register_info
+rj6aba100_register_outimg_fmt[NUM_OUTIMG_FORMAT_MENUS][9] =
+{
+	{       /* YCbCr422 */
+		{0x01, 0x49, 0xE0, 0xFF},       {0x01, 0x4A, 0x37, 0xFF},
+		{0x01, 0x4B, 0x10, 0xFF},       {0x01, 0x4C, 0xEB, 0xFF},
+		{0x01, 0x0C, 0xFF, 0xFF},       {0x01, 0x0D, 0x03, 0x03},
+		{0x01, 0x0E, 0x01, 0x01},       {0x01, 0x0F, 0x08, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* YUV422 */
+		{0x01, 0x49, 0xFF, 0xFF},       {0x01, 0x4A, 0x40, 0xFF},
+		{0x01, 0x4B, 0x01, 0xFF},       {0x01, 0x4C, 0xFE, 0xFF},
+		{0x01, 0x0C, 0xFF, 0xFF},       {0x01, 0x0D, 0x03, 0x03},
+		{0x01, 0x0E, 0x01, 0x01},       {0x01, 0x0F, 0x08, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* RGB Bayer(RAW) */
+		{0x01, 0x49, 0xFF, 0xFF},       {0x01, 0x4A, 0x40, 0xFF},
+		{0x01, 0x4B, 0x01, 0xFF},       {0x01, 0x4C, 0xFE, 0xFF},
+		{0x01, 0x0C, 0x43, 0xFF},       {0x01, 0x0D, 0x00, 0x03},
+		{0x01, 0x0E, 0x00, 0x01},       {0x01, 0x0F, 0x00, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* RGB565 */
+		{0x01, 0x49, 0xFF, 0xFF},       {0x01, 0x4A, 0x40, 0xFF},
+		{0x01, 0x4B, 0x01, 0xFF},       {0x01, 0x4C, 0xFE, 0xFF},
+		{0x01, 0x0C, 0xFF, 0xFF},       {0x01, 0x0D, 0x03, 0x03},
+		{0x01, 0x0E, 0x01, 0x01},       {0x01, 0x0F, 0x08, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* RGB444 */
+		{0x01, 0x49, 0xFF, 0xFF},       {0x01, 0x4A, 0x40, 0xFF},
+		{0x01, 0x4B, 0x01, 0xFF},       {0x01, 0x4C, 0xFE, 0xFF},
+		{0x01, 0x0C, 0xFF, 0xFF},       {0x01, 0x0D, 0x03, 0x03},
+		{0x01, 0x0E, 0x01, 0x01},       {0x01, 0x0F, 0x08, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Mono */
+		{0x01, 0x49, 0xFF, 0xFF},       {0x01, 0x4A, 0x40, 0xFF},
+		{0x01, 0x4B, 0x01, 0xFF},       {0x01, 0x4C, 0xFE, 0xFF},
+		{0x01, 0x0C, 0xFF, 0xFF},       {0x01, 0x0D, 0x03, 0x03},
+		{0x01, 0x0E, 0x01, 0x01},       {0x01, 0x0F, 0x08, 0x08},
+		{0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_OUTIMG_FORMAT_REGS ARRAY_SIZE(rj6aba100_register_outimg_fmt)
+
+
+/* RJ6ABA100 register groupe : output image format & output image size */
+#define NUM_PCLK_RATE_RGBRAW_MONO   0  /* RGB Bayer, Mono */
+#define NUM_PCLK_RATE_YCBCR_YUV_RGB 1  /* YCbCr422, YUV422, RGB565 */
+#define NUM_PCLK_RATE_MAX           2
+#define SELECT_PCLK_RATE_DESCRIPTION(format) ((format == OUT_FORMAT_RGB_RAW \
+					       || format == OUT_FORMAT_MONO) \
+					      ? NUM_PCLK_RATE_RGBRAW_MONO \
+					      : NUM_PCLK_RATE_YCBCR_YUV_RGB)
+
+static const struct register_info
+rj6aba100_register_pclk_rate[NUM_PCLK_RATE_MAX][NUM_OUTIMG_SIZE_MENUS][4] =
+{
+	{       /* RGB Bayer, Mono */
+		{       /* QQVGA */
+			{0x01, 0x19, 0x01, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x17, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* QCIF */
+			{0x01, 0x19, 0x03, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x8C, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* QVGA */
+			{0x01, 0x19, 0x03, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x01, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* CIF */
+			{0x01, 0x19, 0x01, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x17, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* VGA */
+			{0x01, 0x19, 0x01, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x01, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}
+	}, {     /* YCbCr422, YUV422, RGB565 */
+		{       /* QQVGA */
+			{0x01, 0x19, 0x00, 0x0F},  {0x01, 0x3F, 0x01, 0xFF},
+			{0x01, 0x40, 0x17, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* QCIF */
+			{0x01, 0x19, 0x02, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x8C, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* QVGA */
+			{0x01, 0x19, 0x01, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x01, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* CIF */
+			{0x01, 0x19, 0x00, 0x0F},  {0x01, 0x3F, 0x01, 0xFF},
+			{0x01, 0x40, 0x17, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}, {     /* VGA */
+			{0x01, 0x19, 0x00, 0x0F},  {0x01, 0x3F, 0x00, 0xFF},
+			{0x01, 0x40, 0x01, 0xFF},  {0x00, 0x00, 0x00, 0x00},
+		}
+	}
+};
+#define NUM_PCLK_RATE_REGS ARRAY_SIZE(rj6aba100_register_pclk_rate)
+
+
+/* MP200_RJ6ABA100_CID_MIRROR */
+static const struct register_info
+rj6aba100_register_mirror[NUM_MIRROR_MENUS + 1][3] =
+{
+	{       /* Mirror Off */
+		{0x01, 0x19, 0x60, 0x60},       {0x01, 0x0F, 0x00, 0x03},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Mirror Horizontally */
+		{0x01, 0x19, 0x60, 0x60},       {0x01, 0x0F, 0x01, 0x03},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Mirror Virtically */
+		{0x01, 0x19, 0x60, 0x60},       {0x01, 0x0F, 0x02, 0x03},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Mirror Horizontally & Vertically */
+		{0x01, 0x19, 0x60, 0x60},       {0x01, 0x0F, 0x03, 0x03},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Common Postprocessing */
+		{0x01, 0x19, 0x00, 0x60},       {0x00, 0x00, 0x00, 0x00},
+		{0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_MIRROR ARRAY_SIZE(rj6aba100_register_mirror)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_COLOR */
+static struct register_info
+rj6aba100_register_effect_color[NUM_EFFECT_COLOR_MENUS][4] =
+{
+	{       /* Color Effect Off */
+		{0x01, 0x0E, 0x01, 0x81},       {0x01, 0x42, 0x30, 0xFF},
+		{0x01, 0x43, 0xB0, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Sepia */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0xA0, 0xFF},
+		{0x01, 0x43, 0x20, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Green */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0xC0, 0xFF},
+		{0x01, 0x43, 0xC0, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Aqua */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x20, 0xFF},
+		{0x01, 0x43, 0xC0, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Red */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x00, 0xFF},
+		{0x01, 0x43, 0x50, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Cool */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x50, 0xFF},
+		{0x01, 0x43, 0xC0, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Warm */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x90, 0xFF},
+		{0x01, 0x43, 0x30, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect BW */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x00, 0xFF},
+		{0x01, 0x43, 0x00, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect Antique */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x90, 0xFF},
+		{0x01, 0x43, 0x10, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Color Effect UserSet */
+		{0x01, 0x0E, 0x81, 0x81},       {0x01, 0x42, 0x00, 0xFF},
+		{0x01, 0x43, 0x00, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_EFFECT_COLOR_REGS ARRAY_SIZE(rj6aba100_register_effect_color)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_NEGATIVE */
+static const struct register_info
+rj6aba100_register_effect_negative[NUM_EFFECT_NEGATIVE_MENUS][3] =
+{
+	{       /* Negative Effect Off */
+		{0x02, 0x2C, 0x03, 0xFF},       {0x01, 0x0E, 0x01, 0x09},
+		{0x00, 0x00, 0x00, 0x00},
+	}, {     /* Negative Effect On */
+		{0x02, 0x2C, 0x02, 0xFF},       {0x01, 0x0E, 0x09, 0x09},
+		{0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_EFFECT_NEGATIVE_REGS ARRAY_SIZE(rj6aba100_register_effect_negative)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_EMBOSS */
+static const struct register_info
+rj6aba100_register_effect_emboss[NUM_EFFECT_EMBOSS_MENUS][4] =
+{
+	{       /* Emboss Effect Off */
+		{0x02, 0x2C, 0x03, 0xFF},       {0x01, 0x45, 0xC8, 0x09},
+		{0x01, 0x0E, 0x01, 0x31},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Emboss Effect mode0 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x45, 0x80, 0x09},
+		{0x01, 0x0E, 0x21, 0x31},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Emboss Effect mode1 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x45, 0x80, 0x09},
+		{0x01, 0x0E, 0x31, 0x31},       {0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_EFFECT_EMBOSS_REGS ARRAY_SIZE(rj6aba100_register_effect_emboss)
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_SKETCH */
+static struct register_info
+rj6aba100_register_effect_sketch[NUM_EFFECT_SKETCH_MENUS][7] =
+{
+	{       /* Sketch Effect Off */
+		{0x02, 0x2C, 0x03, 0xFF},       {0x01, 0x0E, 0x01, 0x41},
+		{0x01, 0x44, 0x20, 0xFF},
+		{0x01, 0x45, 0xC8, 0xFF},       {0x01, 0x46, 0x10, 0xFF},
+		{0x01, 0x47, 0x80, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Sketch Effect image1 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x0E, 0x41, 0x41},
+		{0x01, 0x44, 0xFF, 0xFF},
+		{0x01, 0x45, 0xFF, 0xFF},       {0x01, 0x46, 0x08, 0xFF},
+		{0x01, 0x47, 0xFF, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Sketch Effect image2 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x0E, 0x41, 0x41},
+		{0x01, 0x44, 0xFF, 0xFF},
+		{0x01, 0x45, 0xFF, 0xFF},       {0x01, 0x46, 0x08, 0xFF},
+		{0x01, 0x47, 0x80, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Sketch Effect image3 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x0E, 0x41, 0x41},
+		{0x01, 0x44, 0xFF, 0xFF},
+		{0x01, 0x45, 0x80, 0xFF},       {0x01, 0x46, 0x08, 0xFF},
+		{0x01, 0x47, 0xFF, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Sketch Effect image4 */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x0E, 0x41, 0x41},
+		{0x01, 0x44, 0x20, 0xFF},
+		{0x01, 0x45, 0x80, 0xFF},       {0x01, 0x46, 0x08, 0xFF},
+		{0x01, 0x47, 0xFF, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}, {     /* Sketch Effect UserSet */
+		{0x02, 0x2C, 0x01, 0xFF},       {0x01, 0x0E, 0x41, 0x41},
+		{0x01, 0x44, 0x00, 0xFF},
+		{0x01, 0x45, 0x00, 0xFF},       {0x01, 0x46, 0x00, 0xFF},
+		{0x01, 0x47, 0x00, 0xFF},       {0x00, 0x00, 0x00, 0x00},
+	}
+};
+#define NUM_EFFECT_SKETCH_REGS ARRAY_SIZE(rj6aba100_register_effect_sketch)
+
+
+/*===============================================================*/
+/* RJ6ABA100 Camera control function                             */
+/*===============================================================*/
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_chkreg_bank
+ * RETURN   :
+ * NOTE     : check & change RJ6ABA100 register bank
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B03_REGBANK_A  0x00
+#define NUM_B03_REGBANK_B  0x01
+#define NUM_B03_REGBANK_C  0x02
+#define NUM_B03_REGBANK_D  0x03
+
+static inline int rj6aba100_chkreg_bank(__u8 value)
+{
+	int ret;
+	unsigned char bank;
+
+	ret = rj6aba100_i2c_read(0x03, &bank, 1); /* get bank */
+	if (!ret) {
+		if (bank != value)
+			ret = rj6aba100_i2c_write(0x03, &value, 1);
+			/* set bank */
+	}
+	return ret;
+}
+
+
+#if CAM_DEBUG
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mage_register_debug
+ * RETURN   :
+ * NOTE     : check RJ6ABA100 register (debug only)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline void mp200_mage_register_debug(void)
+{
+	unsigned char buf[16];
+	int i, j, bank, ret;
+
+	for (bank = NUM_B03_REGBANK_B; bank <= NUM_B03_REGBANK_D; bank++) {
+		ret = rj6aba100_chkreg_bank(bank);
+		if (ret)
+			return;
+
+		printk(KERN_DEBUG"========================================"
+		       "========================\n");
+		printk(KERN_DEBUG" Group %c\n",
+		       ((bank == NUM_B03_REGBANK_B) ? 'B'
+			: ((bank == NUM_B03_REGBANK_C) ? 'C' : 'D')));
+		printk(KERN_DEBUG"-----------------------------------------"
+		       "-----------------------\n");
+
+		for (i = 0; i < 0xFF; i += 16) {
+			for (j = 0; j < 16; j++) {
+				ret = rj6aba100_i2c_read(i + j, &buf[j], 1);
+				if (ret)
+					return;
+			}
+
+			printk(KERN_DEBUG" %c-%02x:  %02x %02x %02x %02x  "
+			       "%02x %02x %02x %02x  %02x %02x "
+			       "%02x %02x  %02x %02x %02x %02x\n",
+			       ((bank == NUM_B03_REGBANK_B) ? 'B'
+				: ((bank == NUM_B03_REGBANK_C) ? 'C' : 'D')),
+			       i, buf[0], buf[1], buf[2], buf[3], buf[4],
+			       buf[5], buf[6], buf[7], buf[8], buf[9],
+			       buf[10], buf[11], buf[12], buf[13], buf[14],
+			       buf[15]);
+		}
+	}
+	printk(KERN_DEBUG"================================================"
+	       "================\n");
+
+}
+#endif /* CAM_DEBUG */
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega
+ * FUNCTION : rj6aba100_setreg_array
+ * RETURN   :
+ * NOTE     : set RJ6ABA100 register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_array(struct register_info *reg_info)
+{
+	int i, ret = 0;
+	unsigned char data;
+
+	for (i = 0; reg_info[i].bank != 0x00; i++) {
+		ret = rj6aba100_chkreg_bank(reg_info[i].bank); /* check bank */
+		if (!ret) {
+			ret = rj6aba100_i2c_read(reg_info[i].address, &data, 1);
+			if (!ret) {
+				data = (data & ~reg_info[i].mask)
+					| reg_info[i].data;
+				ret  = rj6aba100_i2c_write(reg_info[i].address,
+							   &data, 1);
+			}
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_pll_control
+ * RETURN   :
+ * NOTE     : set RJ6ABA100 PLL control register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B09_PLL_CTRL01      0x09
+#define NUM_B0A_PLL_CTRL02      0x0A
+#define NUM_B0B_PLL_CTRL03      0x0B
+#define NUM_B09_PLL_CTRL01_MASK 0x30
+#define NUM_B0A_PLL_CTRL02_MASK 0xFF
+#define NUM_B0B_PLL_CTRL03_MASK 0xFF
+
+#define NUM_B09_PLL_CTRL01_X10  0x00
+#define NUM_B09_PLL_CTRL01_X12  0x10
+#define NUM_B09_PLL_CTRL01_X14  0x20
+#define NUM_B09_PLL_CTRL01_X16  0x30
+
+#define NUM_B0A_PLL_CTRL02_X1   0x00
+#define NUM_B0A_PLL_CTRL02_X2   0x01
+#define NUM_B0A_PLL_CTRL02_X3   0x02
+#define NUM_B0A_PLL_CTRL02_X4   0x03
+#define NUM_B0A_PLL_CTRL02_X5   0x04
+#define NUM_B0A_PLL_CTRL02_X6   0x05
+#define NUM_B0A_PLL_CTRL02_X7   0x06
+#define NUM_B0A_PLL_CTRL02_X8   0x07
+
+#define NUM_B0B_PLL_CTRL03_X1   0x00
+#define NUM_B0B_PLL_CTRL03_X2   0x01
+#define NUM_B0B_PLL_CTRL03_X3   0x02
+#define NUM_B0B_PLL_CTRL03_X4   0x03
+#define NUM_B0B_PLL_CTRL03_X5   0x04
+#define NUM_B0B_PLL_CTRL03_X6   0x05
+#define NUM_B0B_PLL_CTRL03_X7   0x06
+#define NUM_B0B_PLL_CTRL03_X8   0x07
+
+static inline int rj6aba100_setreg_pll_control(int arg)
+{
+	int i, ret;
+	unsigned char add[3], buf[3];
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		ret  = rj6aba100_i2c_read(NUM_B0A_PLL_CTRL02, &buf[0], 1);
+		ret |= rj6aba100_i2c_read(NUM_B09_PLL_CTRL01, &buf[1], 1);
+		ret |= rj6aba100_i2c_read(NUM_B0B_PLL_CTRL03, &buf[2], 1);
+		if (!ret) {
+			/* camera module clock setting */
+			add[0] = NUM_B0A_PLL_CTRL02;
+			add[1] = NUM_B09_PLL_CTRL01;
+			add[2] = NUM_B0B_PLL_CTRL03;
+
+			if (arg == 344) {
+				buf[0] = (buf[0] &
+				 (unsigned char)~NUM_B0A_PLL_CTRL02_MASK)
+					| NUM_B0A_PLL_CTRL02_X2;
+				/* x1/2 : 11.47/2 => 5.74    */
+				buf[1] = (buf[1] &
+				 (unsigned char)~NUM_B09_PLL_CTRL01_MASK)
+					| NUM_B09_PLL_CTRL01_X12;
+				/* x12  : 5.74x12 => 68.8    */
+				buf[2] = (buf[2] &
+				 (unsigned char)~NUM_B0B_PLL_CTRL03_MASK)
+					| NUM_B0B_PLL_CTRL03_X2;
+				/* x1/2 : 68.8/2  => 34.4Mhz */
+			} else if (arg == 574)    {
+				buf[0] = (buf[0] &
+				 (unsigned char)~NUM_B0A_PLL_CTRL02_MASK)
+					| NUM_B0A_PLL_CTRL02_X2;
+				/* x1/2 : 11.47/2 => 5.74    */
+				buf[1] = (buf[1] &
+				 (unsigned char)~NUM_B09_PLL_CTRL01_MASK)
+					| NUM_B09_PLL_CTRL01_X10;
+				/* x10  : 5.74x10 => 57.4    */
+				buf[2] = (buf[2] &
+				 (unsigned char)~NUM_B0B_PLL_CTRL03_MASK)
+					| NUM_B0B_PLL_CTRL03_X1;
+				/* x1/1 : 57.4/1  => 57.4Mhz */
+			} else if (arg == 688)    {
+				buf[0] = (buf[0] &
+				 (unsigned char)~NUM_B0A_PLL_CTRL02_MASK)
+					| NUM_B0A_PLL_CTRL02_X2;
+				/* x1/2 : 11.47/2 => 5.74    */
+				buf[1] = (buf[1] &
+				 (unsigned char)~NUM_B09_PLL_CTRL01_MASK)
+					| NUM_B09_PLL_CTRL01_X12;
+				/* x12  : 5.74x12 => 68.8    */
+				buf[2] = (buf[2] &
+				 (unsigned char)~NUM_B0B_PLL_CTRL03_MASK)
+					| NUM_B0B_PLL_CTRL03_X1;
+				/* x1/1 : 68.8/1  => 68.8Mhz */
+			}
+
+			for (i = 0; i < ARRAY_SIZE(buf); i++) {
+				ret = rj6aba100_i2c_write(add[i], &buf[i], 1);
+				if (ret)
+					return ret;
+			}
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_outimg_size
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_OUTIMG_SIZE
+ *          : set RJ6ABA100 output image size register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B34_WINDOW_X1H  0x34
+#define NUM_B35_WINDOW_X1L  0x35
+#define NUM_B36_WINDOW_Y1H  0x36
+#define NUM_B37_WINDOW_Y1L  0x37
+#define NUM_B38_WINDOW_X2H  0x38
+#define NUM_B39_WINDOW_X2L  0x39
+#define NUM_B3A_WINDOW_Y2H  0x3A
+#define NUM_B3B_WINDOW_Y2L  0x3B
+
+static inline int rj6aba100_setreg_outimg_size(__u8 value)
+{
+	struct control_resize_info *s;
+	unsigned char add[8], buf[8];
+	int i, ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		s = (struct control_resize_info *)rj6aba100_outimg_size_menus;
+		s += value;
+
+		add[0] = NUM_B34_WINDOW_X1H;
+		buf[0] = (unsigned char)(s->x >> 8);
+		/* windowX1(H) */
+		add[1] = NUM_B35_WINDOW_X1L;
+		buf[1] = (unsigned char) s->x;
+		/* windowX1(L) */
+		add[2] = NUM_B36_WINDOW_Y1H;
+		buf[2] = (unsigned char)(s->y >> 8);
+		/* windowY1(H) */
+		add[3] = NUM_B37_WINDOW_Y1L;
+		buf[3] = (unsigned char) s->y;
+		/* windowY1(L) */
+		add[4] = NUM_B38_WINDOW_X2H;
+		buf[4] = (unsigned char)(s->width >> 8);
+		/* windowX2(H) */
+		add[5] = NUM_B39_WINDOW_X2L;
+		buf[5] = (unsigned char) s->width;
+		/* windowX2(L) */
+		add[6] = NUM_B3A_WINDOW_Y2H;
+		buf[6] = (unsigned char)(s->height >> 8);
+		/* windowY2(H) */
+		add[7] = NUM_B3B_WINDOW_Y2L;
+		buf[7] = (unsigned char) s->height;
+		/* windowY2(L) */
+
+		for (i = 0; i < ARRAY_SIZE(buf); i++) {
+			ret = rj6aba100_i2c_write(add[i], &buf[i], 1);
+			if (ret)
+				return ret;
+		}
+		ret = rj6aba100_setreg_array(
+	    (struct register_info *)(&rj6aba100_register_outimg_size[value]));
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_outimg_fmt
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_OUTIMG_FORMAT
+ *          : set RJ6ABA100 output image format register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_outimg_fmt(__u8 value)
+{
+	return rj6aba100_setreg_array(
+	      (struct register_info *)(&rj6aba100_register_outimg_fmt[value]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_pclk_rate
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_OUTIMG_SIZE &
+ *            MP200_RJ6ABA100_CID_OUTIMG_FORMAT
+ *          : set RJ6ABA100 PCLK rate register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_pclk_rate(void)
+{
+	int pclk_flag = SELECT_PCLK_RATE_DESCRIPTION(rj6aba100->outimg_fmt);
+
+	return rj6aba100_setreg_array(
+	 (struct register_info *)
+	 (&rj6aba100_register_pclk_rate[pclk_flag][rj6aba100->capture_size]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_outdata_fmt
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_OUTDATA_FORMAT
+ *          : set RJ6ABA100 output data array format register group
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B18_FORMAT       0x18
+#define NUM_B18_FORMAT_MASK  0xFF
+#define NUM_B18_FORMAT_SFT   0x00
+
+static inline int rj6aba100_setreg_outdata_fmt(__u8 value)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		ret = rj6aba100_i2c_read(NUM_B18_FORMAT, &buf, 1);
+		if (!ret) {
+			buf = (buf & ~NUM_B18_FORMAT_MASK) | value;
+			ret = rj6aba100_i2c_write(NUM_B18_FORMAT, &buf, 1);
+			/* OutputFormat */
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_flicker_manual
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FLICKER
+ *          : set RJ6ABA100 friker free (manual mode) register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_BB7_FLICKER_CTRL       0xB7
+#define NUM_BB7_FLICKER_CTRL_MASK  0x3E
+#define NUM_BB7_FLICKER_CTRL_SFT   0x01
+
+static inline int rj6aba100_setreg_flicker_manual(__u8 value)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		ret = rj6aba100_i2c_read(NUM_BB7_FLICKER_CTRL, &buf, 1);
+		if (!ret) {
+			buf = (buf & ~NUM_BB7_FLICKER_CTRL_MASK)
+				| rj6aba100_flicker_menus[value].value;
+			ret = rj6aba100_i2c_write(NUM_BB7_FLICKER_CTRL,
+						  &buf, 1);
+			/* FlikerControl1 */
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_wb_mode
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_WB
+ *          : set RJ6ABA100 brightness register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_C04_AUTO_CTRL           0x04
+#define NUM_C04_AUTO_CTRL_AWB_MASK  0x04
+#define NUM_C04_AUTO_CTRL_AE_MASK   0x03
+#define NUM_C04_AUTO_CTRL_AWB_SFT   0x02
+#define NUM_C04_AUTO_CTRL_AE_SFT    0x00
+
+static inline int rj6aba100_setreg_wb_mode(__u8 value)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_C); /* check bank C */
+	if (!ret) {
+		ret = rj6aba100_i2c_read(NUM_C04_AUTO_CTRL, &buf, 1);
+		if (!ret) {
+			buf = (buf & ~NUM_C04_AUTO_CTRL_AWB_MASK)
+				| (value << NUM_C04_AUTO_CTRL_AWB_SFT);
+			ret = rj6aba100_i2c_write(NUM_C04_AUTO_CTRL, &buf, 1);
+			/* auto_control_1 (AWB Register Update) */
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_wb_manual_gain
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_WB_MANUAL_GAIN
+ *          : set RJ6ABA100 brightness register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_BAD_WB_RGAIN             0xAD
+#define NUM_BAE_WB_GGAIN             0xAE
+#define NUM_BAF_WB_BGAIN             0xAF
+#define NUM_BAD_WB_RGAIN_MASK        0x00FF0000
+#define NUM_BAE_WB_GGAIN_MASK        0x0000FF00
+#define NUM_BAF_WB_BGAIN_MASK        0x000000FF
+#define NUM_BAD_WB_RGAIN_SFT         16
+#define NUM_BAE_WB_GGAIN_SFT         8
+#define NUM_BAF_WB_BGAIN_SFT         0
+#define NUM_WB_MANUAL_GAIN_TABLE_MAX 3
+
+static inline int rj6aba100_getreg_wb_manual_gain(__u32 *value)
+{
+	int i, ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		unsigned char addr[NUM_WB_MANUAL_GAIN_TABLE_MAX] =
+			{NUM_BAD_WB_RGAIN,
+			 NUM_BAE_WB_GGAIN,
+			 NUM_BAF_WB_BGAIN};
+		unsigned char data[NUM_WB_MANUAL_GAIN_TABLE_MAX];
+
+		for (i = 0; i < NUM_WB_MANUAL_GAIN_TABLE_MAX; i++)
+			ret = rj6aba100_i2c_read(addr[i], &data[i], 1);
+		*value = (data[0] << NUM_BAD_WB_RGAIN_SFT)
+			| (data[1] << NUM_BAE_WB_GGAIN_SFT)
+			| (data[2] << NUM_BAF_WB_BGAIN_SFT);
+	}
+	return ret;
+}
+
+static inline int rj6aba100_setreg_wb_manual_gain(__u32 value)
+{
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		int i;
+		unsigned char addr[NUM_WB_MANUAL_GAIN_TABLE_MAX] =
+			{NUM_BAD_WB_RGAIN,
+			 NUM_BAE_WB_GGAIN,
+			 NUM_BAF_WB_BGAIN};
+		unsigned char data[NUM_WB_MANUAL_GAIN_TABLE_MAX] =
+			{(__u8)((value & NUM_BAD_WB_RGAIN_MASK)
+				>> NUM_BAD_WB_RGAIN_SFT),
+			 (__u8)((value & NUM_BAE_WB_GGAIN_MASK)
+				>> NUM_BAE_WB_GGAIN_SFT),
+			 (__u8)((value & NUM_BAF_WB_BGAIN_MASK)
+				>> NUM_BAF_WB_BGAIN_SFT)};
+
+		for (i = 0; i < NUM_WB_MANUAL_GAIN_TABLE_MAX; i++)
+			ret = rj6aba100_i2c_write(addr[i], &data[i], 1);
+			/* Rgain, Ggain, Bgain */
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_brightness
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_BRIGHTNESS
+ *          : set RJ6ABA100 brightness register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B4B_YBLIGHTNESS  0x4B
+
+static inline int rj6aba100_setreg_brightness(__u8 value)
+{
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret)
+		ret = rj6aba100_i2c_write(NUM_B4B_YBLIGHTNESS, &value, 1);
+		/* Brightness */
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_contrast
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_CONTRAST
+ *          : set RJ6ABA100 contrast register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B4A_YCONTRAST  0x4A
+
+static inline int rj6aba100_setreg_contrast(__u8 value)
+{
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret)
+		ret = rj6aba100_i2c_write(NUM_B4A_YCONTRAST, &value, 1);
+		/* Y contrast */
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_SHARPNESS */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_sharpness
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_SHARPNESS
+ *          : set RJ6ABA100 contrast register
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B52_EDGE_GAIN           0x52
+#define NUM_B54_EDGE_THRESHOLD      0x54
+#define NUM_B52_EDGE_GAIN_MASK      0x00003F00
+#define NUM_B54_EDGE_THRESHOLD_MASK 0x000000FF
+#define NUM_B52_EDGE_GAIN_SFT       8
+#define NUM_B54_EDGE_THRESHOLD_SFT  0
+#define NUM_SHARPNESS_TABLE_MAX     2
+
+static inline int rj6aba100_setreg_sharpness(__u32 value)
+{
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		int i;
+		unsigned char addr[NUM_SHARPNESS_TABLE_MAX] =
+			{NUM_B52_EDGE_GAIN,
+			 NUM_B54_EDGE_THRESHOLD};
+		unsigned char data[NUM_SHARPNESS_TABLE_MAX] =
+			{(__u8)((value & NUM_B52_EDGE_GAIN_MASK)
+				>> NUM_B52_EDGE_GAIN_SFT),
+			 (__u8)((value & NUM_B54_EDGE_THRESHOLD_MASK)
+				>> NUM_B54_EDGE_THRESHOLD_SFT)};
+
+		for (i = 0; i < NUM_SHARPNESS_TABLE_MAX; i++)
+			ret = rj6aba100_i2c_write(addr[i], &data[i], 1);
+			/* Edge Gain/Threshorld */
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_mirror
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_MIRROR
+ *          : set RJ6ABA100 Mirror register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_mirror(__u8 value)
+{
+	int ret;
+
+	/* Each Priprocessing */
+	ret = rj6aba100_setreg_array(
+		(struct register_info *)(&rj6aba100_register_mirror[value]));
+	if (!ret) {
+		/* Common Postprocessing */
+
+		/*
+		 * wait 1frame
+		 */
+		msleep(30);
+
+		ret = rj6aba100_setreg_array(
+			(struct register_info *)
+			(&rj6aba100_register_mirror[NUM_MIRROR_MENUS]));
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_effect_color
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_COLOR
+ *          : set RJ6ABA100 effect (color) register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_effect_color(__u8 value)
+{
+	return rj6aba100_setreg_array(
+	 (struct register_info *)(&rj6aba100_register_effect_color[value]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_getreg_effect_color_userset
+ *            / rj6aba100_setreg_effect_color_userset
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL
+ *          : set RJ6ABA100 effect (color) register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_color(__u8 *value);
+#define NUM_B42_SEPHIA_CB          0x42
+#define NUM_B43_SEPHIA_CR          0x43
+#define NUM_B42_SEPHIA_CB_MASK     0x0000FF00
+#define NUM_B43_SEPHIA_CR_MASK     0x000000FF
+#define NUM_B42_SEPHIA_CB_SFT      8
+#define NUM_B43_SEPHIA_CR_SFT      0
+#define NUM_EFFECT_COLOR_TABLE_MAX 2
+
+static inline int rj6aba100_getreg_effect_color_userset(__u32 *value)
+{
+	unsigned char now_setting;
+	int i, ret;
+
+	ret = rj6aba100_get_effect_color(&now_setting);
+	if (!ret) {
+		*value = 0;
+		for (i = 0; i < NUM_EFFECT_COLOR_TABLE_MAX; i++) {
+			switch (rj6aba100_register_effect_color
+				[now_setting][i + 1].address) {
+			case NUM_B42_SEPHIA_CB:
+				*value |=
+					((__u32)rj6aba100_register_effect_color
+					 [now_setting][i + 1].data
+					 << NUM_B42_SEPHIA_CB_SFT);
+				break;
+			case NUM_B43_SEPHIA_CR:
+				*value |=
+					((__u32)rj6aba100_register_effect_color
+					 [now_setting][i + 1].data
+					 << NUM_B43_SEPHIA_CR_SFT);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+static inline int rj6aba100_setreg_effect_color_userset(__u32 value)
+{
+	int i;
+	unsigned char addr[NUM_EFFECT_COLOR_TABLE_MAX] =
+		{NUM_B42_SEPHIA_CB,
+		 NUM_B43_SEPHIA_CR};
+	unsigned char data[NUM_EFFECT_COLOR_TABLE_MAX] =
+		{(__u8)((value & NUM_B42_SEPHIA_CB_MASK)
+			>> NUM_B42_SEPHIA_CB_SFT),
+		 (__u8)((value & NUM_B43_SEPHIA_CR_MASK)
+			>> NUM_B43_SEPHIA_CR_SFT)};
+
+	for (i = 0; i < NUM_EFFECT_COLOR_TABLE_MAX; i++) {
+		/* register is actually set in
+		   MP200_RJ6ABA100_CID_EFFECT_COLOR */
+		rj6aba100_register_effect_color
+			[NUM_EFFECT_COLOR_MANUAL][i + 1].address = addr[i];
+		rj6aba100_register_effect_color
+			[NUM_EFFECT_COLOR_MANUAL][i + 1].data    = data[i];
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_effect_negative
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_NEGATIVE
+ *          : set RJ6ABA100 effect (negative) register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_effect_negative(__u8 value)
+{
+	return rj6aba100_setreg_array(
+	 (struct register_info *)(&rj6aba100_register_effect_negative[value]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_effect_emboss
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_EMBOSS
+ *          : set RJ6ABA100 effect (emboss) register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_effect_emboss(__u8 value)
+{
+	return rj6aba100_setreg_array(
+	   (struct register_info *)(&rj6aba100_register_effect_emboss[value]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_effect_sketch
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_SKETCH
+ *          * set RJ6ABA100 effect (sketch) register
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_setreg_effect_sketch(__u8 value)
+{
+	return rj6aba100_setreg_array(
+	 (struct register_info *)(&rj6aba100_register_effect_sketch[value]));
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_getreg_effect_sketch_userset
+ *          / rj6aba100_setreg_effect_sketch_userset
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL
+ *          : set RJ6ABA100 effect (sketch) register
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_sketch(__u8 *value);
+#define NUM_B44_SKETCH_OFFSET1       0x44
+#define NUM_B45_SKETCH_OFFSET2       0x45
+#define NUM_B46_SKETCH_OFFSET3       0x46
+#define NUM_B47_SKETCH_OFFSET4       0x47
+#define NUM_B44_SKETCH_OFFSET1_MASK  0xFF000000
+#define NUM_B45_SKETCH_OFFSET2_MASK  0x00FF0000
+#define NUM_B46_SKETCH_OFFSET3_MASK  0x0000FF00
+#define NUM_B47_SKETCH_OFFSET4_MASK  0x000000FF
+#define NUM_B44_SKETCH_OFFSET1_SFT   24
+#define NUM_B45_SKETCH_OFFSET2_SFT   16
+#define NUM_B46_SKETCH_OFFSET3_SFT   8
+#define NUM_B47_SKETCH_OFFSET4_SFT   0
+#define NUM_EFFECT_SKETCH_TABLE_MAX  4
+
+static inline int rj6aba100_getreg_effect_sketch_userset(__u32 *value)
+{
+	unsigned char now_setting;
+	int i, ret;
+
+	ret = rj6aba100_get_effect_sketch(&now_setting);
+	if (!ret) {
+		*value = 0;
+		for (i = 0; i < NUM_EFFECT_SKETCH_TABLE_MAX; i++) {
+			switch (rj6aba100_register_effect_sketch
+				[now_setting][i + 2].address) {
+			case NUM_B44_SKETCH_OFFSET1:
+				*value |=
+				((__u32)rj6aba100_register_effect_sketch
+				 [now_setting][i + 2].data
+				 << NUM_B44_SKETCH_OFFSET1_SFT);
+				break;
+			case NUM_B45_SKETCH_OFFSET2:
+				*value |=
+				((__u32)rj6aba100_register_effect_sketch
+				 [now_setting][i + 2].data
+				 << NUM_B45_SKETCH_OFFSET2_SFT);
+				break;
+			case NUM_B46_SKETCH_OFFSET3:
+				*value |=
+				((__u32)rj6aba100_register_effect_sketch
+				 [now_setting][i + 2].data
+				 << NUM_B46_SKETCH_OFFSET3_SFT);
+				break;
+			case NUM_B47_SKETCH_OFFSET4:
+				*value |=
+				((__u32)rj6aba100_register_effect_sketch
+				 [now_setting][i + 2].data
+				 << NUM_B47_SKETCH_OFFSET4_SFT);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+static inline int rj6aba100_setreg_effect_sketch_userset(__u32 value)
+{
+	int i;
+	unsigned char addr[NUM_EFFECT_SKETCH_TABLE_MAX] =
+		{NUM_B44_SKETCH_OFFSET1,
+		 NUM_B45_SKETCH_OFFSET2,
+		 NUM_B46_SKETCH_OFFSET3,
+		 NUM_B47_SKETCH_OFFSET4};
+	unsigned char data[NUM_EFFECT_SKETCH_TABLE_MAX] =
+		{(__u8)((value & NUM_B44_SKETCH_OFFSET1_MASK)
+			>> NUM_B44_SKETCH_OFFSET1_SFT),
+		 (__u8)((value & NUM_B45_SKETCH_OFFSET2_MASK)
+			>> NUM_B45_SKETCH_OFFSET2_SFT),
+		 (__u8)((value & NUM_B46_SKETCH_OFFSET3_MASK)
+			>> NUM_B46_SKETCH_OFFSET3_SFT),
+		 (__u8)((value & NUM_B47_SKETCH_OFFSET4_MASK)
+			>> NUM_B47_SKETCH_OFFSET4_SFT)};
+
+	for (i = 0; i < NUM_EFFECT_SKETCH_TABLE_MAX; i++) {
+		/* register is actually set in
+		   MP200_RJ6ABA100_CID_EFFECT_SKETCH */
+		rj6aba100_register_effect_sketch
+			[NUM_EFFECT_SKETCH_MANUAL][i + 2].address = addr[i];
+		rj6aba100_register_effect_sketch
+			[NUM_EFFECT_SKETCH_MANUAL][i + 2].data    = data[i];
+	}
+	return 0;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_control01
+ * RETURN   :
+ * NOTE     : set RJ6ABA100 register Control01
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B04_STDBYMODE_ON    0x00
+#define NUM_B04_STDBYMODE_OFF   0x80
+#define NUM_B04_CLOCK_KILL      0x40
+#define NUM_B04_CLOCK_NOTKILL   0x00
+#define NUM_B04_STANDBY_ON      0x20
+#define NUM_B04_STANDBY_OFF     0x00
+#define NUM_B04_PLL_SELECT      0x10
+#define NUM_B04_PLL_NOTSELECT   0x00
+#define NUM_B04_BIDIRECT_HIZ    0x08
+#define NUM_B04_BIDIRECT_NORMAL 0x00
+
+#define NUM_B04_STDBYMODE_MASK  0x80
+#define NUM_B04_CLOCK_MASK      0x40
+#define NUM_B04_STANDBY_MASK    0x20
+#define NUM_B04_PLL_MASK        0x10
+#define NUM_B04_BIDIRECT_MASK   0x08
+
+static inline int rj6aba100_setreg_control01(__u8 mask, __u8 value)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		ret = rj6aba100_i2c_read(0x04, &buf, 1);
+		if (!ret) {
+			buf = (buf & ~mask) | value;
+			ret = rj6aba100_i2c_write(0x04, &buf, 1);
+			/* Control_01 */
+		}
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_setreg_softreset
+ * RETURN   :
+ * NOTE     : set RJ6ABA100 register SoftReset
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B06_SOFTRESET     0x06
+#define NUM_B06_SOFTRESET_OFF 0x00
+#define NUM_B06_SOFTRESET_ON  0x01
+
+static inline int rj6aba100_setreg_softreset(__u8 value)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_chkreg_bank(NUM_B03_REGBANK_B); /* check bank B */
+	if (!ret) {
+		buf = value;
+		ret = rj6aba100_i2c_write(NUM_B06_SOFTRESET, &buf, 1);
+		/* Softreset */
+	}
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_getreg_firmware_version
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FW
+ *          : get RJ6ABA100 register revesion number
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define NUM_B02_REVNUMBER  0x02
+
+static inline int rj6aba100_getreg_firmware_version(__u8 *val)
+{
+	char buf;
+	int ret;
+
+	ret = rj6aba100_i2c_read(NUM_B02_REVNUMBER, &buf, 1);
+	/* revesion number */
+	if (!ret)
+		*val = buf;
+	return ret;
+}
+
+
+/* etc */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_set_liveview
+ * RETURN   :
+ * NOTE     :
+ * CREATE   :
+ * UPDATE   :
+ ******************************************************************************/
+#define SET_LIVEVIEW_STOP  0
+#define SET_LIVEVIEW_START 1
+
+static inline int rj6aba100_set_liveview(__u8 val)
+{
+	unsigned char mask, data;
+	int ret = 0;
+
+	mask = NUM_B04_STDBYMODE_MASK | NUM_B04_CLOCK_MASK
+		| NUM_B04_STANDBY_MASK | NUM_B04_PLL_MASK
+		| NUM_B04_BIDIRECT_MASK;
+	if (val == SET_LIVEVIEW_START)
+		data = NUM_B04_STDBYMODE_OFF | NUM_B04_CLOCK_NOTKILL
+			| NUM_B04_STANDBY_OFF | NUM_B04_PLL_SELECT
+			| NUM_B04_BIDIRECT_HIZ;    /* 0x98 */
+	else
+		data = NUM_B04_STDBYMODE_OFF | NUM_B04_CLOCK_NOTKILL
+			| NUM_B04_STANDBY_ON  | NUM_B04_PLL_NOTSELECT
+			| NUM_B04_BIDIRECT_NORMAL; /* 0xA0 */
+/* @@	else	data = NUM_B04_STDBYMODE_OFF | NUM_B04_CLOCK_NOTKILL
+| NUM_B04_STANDBY_OFF | NUM_B04_PLL_NOTSELECT | NUM_B04_BIDIRECT_NORMAL;
+ / * 0x80 * / */
+/* @@	else	data = NUM_B04_STDBYMODE_OFF | NUM_B04_CLOCK_KILL
+| NUM_B04_STANDBY_ON  | NUM_B04_PLL_NOTSELECT | NUM_B04_BIDIRECT_NORMAL;
+/ * 0xE0 * / */
+
+	ret = rj6aba100_setreg_control01(mask, data);
+	if (!ret) {
+		if (val == SET_LIVEVIEW_START)
+			rj6aba100->state = MP200_RJ6ABA100_LIVE;
+		else
+			rj6aba100->state = MP200_RJ6ABA100_IDLE;
+	}
+
+	return ret;
+}
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_set_capture_read
+ * RETURN   :
+ * NOTE     :
+ * CREATE   :
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_set_capture_read(__u8 data)
+{
+	int ret = 0;
+
+	if (MP200_RJ6ABA100_IDLE != rj6aba100->state)
+		return -EBUSY;
+
+	ret = rj6aba100_setreg_outimg_size(data);
+	if (!ret)
+		rj6aba100->state = MP200_RJ6ABA100_CAPTURE;
+
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_shutdown
+ * RETURN   :
+ * NOTE     :
+ * CREATE   :
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_shutdown(void)
+{
+	int ret = 0;
+
+	/* rj6aba100 power off
+	 * 1. GIO_P8 ='0b'
+	 */
+	gpio_direction_output(GPIO_CAM_RST, 0x0); /* GIO_P8 output Low */
+
+	return ret;
+}
+
+
+
+
+
+/* MP200_RJ6ABA100_CID_FW */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_firmware_version
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FW
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_firmware_version(__u8 *value)
+{
+	*value = rj6aba100->firmware_version;
+	return 0;
+}
+
+
+/* MP200_RJ6ABA100_CID_OUTIMG_SIZE */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_outimg_size / rj6aba100_set_outimg_size
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FW
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_outimg_size(__u8 *value)
+{
+	*value = rj6aba100->capture_size;
+	return 0;
+}
+
+static inline int rj6aba100_set_outimg_size(__u8 value)
+{
+	int ret = 0;
+
+	if (value != rj6aba100->capture_size) {
+		rj6aba100->capture_size = value;
+		rj6aba100->reset = 1;
+	}
+
+	return ret;
+}
+
+/* MP200_RJ6ABA100_CID_OUTIMG_FORMAT */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_outimg_fmt / rj6aba100_set_outimg_fmt
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FW
+ * CREATE   : 2009/07/15 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_outimg_fmt(__u8 *value)
+{
+	*value = rj6aba100->outimg_fmt;
+	return 0;
+}
+
+static inline int rj6aba100_set_outimg_fmt(__u8 value)
+{
+	int ret = 0;
+
+	if (value != rj6aba100->outimg_fmt)
+		rj6aba100->outimg_fmt = value;
+
+	return ret;
+}
+
+/* MP200_RJ6ABA100_CID_OUTDATA_FORMAT */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_imgdata_fmt / rj6aba100_set_imgdata_fmt
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FW
+ * CREATE   : 2009/07/15 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_imgdata_fmt(__u8 *value)
+{
+	*value = rj6aba100->imgdata_fmt;
+	return 0;
+}
+
+static inline int rj6aba100_set_imgdata_fmt(__u8 value)
+{
+	int ret = 0;
+
+	if (value != rj6aba100->imgdata_fmt)
+		rj6aba100->imgdata_fmt = value;
+
+	return ret;
+}
+
+/* MP200_RJ6ABA100_CID_FLICKER */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_flicker_manual / rj6aba100_set_flicker_manual
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_FLICKER
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_flicker_manual(__u8 *value)
+{
+	*value = rj6aba100->flicker_manual;
+	return 0;
+}
+
+static inline int rj6aba100_set_flicker_manual(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_flicker_manual(value);
+	if (!ret)
+		rj6aba100->flicker_manual = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_WB */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_wb_mode / rj6aba100_set_wb_mode
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_WB
+ * CREATE   : 2009/06/29 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_wb_mode(__u8 *value)
+{
+	*value = rj6aba100->wb_mode;
+	return 0;
+}
+
+static inline int rj6aba100_set_wb_mode(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_wb_mode(value);
+	if (!ret)
+		rj6aba100->wb_mode = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_WB_MANUAL_GAIN */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_wb_manual_gain / rj6aba100_set_wb_manual_gain
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_WB_MANUAL_GAIN
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_wb_manual_gain(__u32 *value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_getreg_wb_manual_gain(value);
+	if (!ret)
+		rj6aba100->wb_manual_gain = *value;
+	return ret;
+}
+
+static inline int rj6aba100_set_wb_manual_gain(__u32 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_wb_manual_gain(value);
+	if (!ret)
+		rj6aba100->wb_manual_gain = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_BRIGHTNESS */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_brightness / rj6aba100_set_brightness
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_BRIGHTNESS
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_brightness(__u8 *value)
+{
+	*value = rj6aba100->brightness;
+	return 0;
+}
+
+static inline int rj6aba100_set_brightness(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_brightness(value);
+	if (!ret)
+		rj6aba100->brightness = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_CONTRAST */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_contrast / rj6aba100_set_contrast
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_CONTRAST
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_contrast(__u8 *value)
+{
+	*value = rj6aba100->contrast;
+	return 0;
+}
+
+static inline int rj6aba100_set_contrast(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_contrast(value);
+	if (!ret)
+		rj6aba100->contrast = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_SHARPNESS */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_sharpness / rj6aba100_set_sharpness
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_SHARPNESS
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_sharpness(__u32 *value)
+{
+	*value = rj6aba100->sharpness;
+	return 0;
+}
+
+static inline int rj6aba100_set_sharpness(__u32 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_sharpness(value);
+	if (!ret)
+		rj6aba100->sharpness = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_MIRROR */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_mirror / rj6aba100_set_mirror
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_MIRROR
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_mirror(__u8 *value)
+{
+	*value = rj6aba100->mirror;
+	return 0;
+}
+
+static inline int rj6aba100_set_mirror(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_mirror(value);
+	if (!ret)
+		rj6aba100->mirror = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_COLOR */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_color / rj6aba100_set_effect_color
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_COLOR
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_color(__u8 *value)
+{
+	*value = rj6aba100->efct_color;
+	return 0;
+}
+
+static inline int rj6aba100_set_effect_color(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_effect_color(value);
+	if (!ret)
+		rj6aba100->efct_color = value;
+	return ret;
+}
+
+/* MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_color_userset
+ *           / rj6aba100_set_effect_color_userset
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_COLOR_USER_CB
+ *          : MP200_RJ6ABA100_CID_EFFECT_COLOR_USER_CR
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_color_userset(__u32 *value)
+{
+	return rj6aba100_getreg_effect_color_userset(value);
+}
+
+static inline int rj6aba100_set_effect_color_userset(__u32 value)
+{
+	return rj6aba100_setreg_effect_color_userset(value);
+}
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_NEGATIVE */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_negative / rj6aba100_set_effect_negative
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_NEGATIVE
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_negative(__u8 *value)
+{
+	*value = rj6aba100->efct_negative;
+	return 0;
+}
+
+static inline int rj6aba100_set_effect_negative(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_effect_negative(value);
+	if (!ret)
+		rj6aba100->efct_negative = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_EMBOSS */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_emboss / rj6aba100_set_effect_emboss
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_EMBOSS
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_emboss(__u8 *value)
+{
+	*value = rj6aba100->efct_emboss;
+	return 0;
+}
+
+static inline int rj6aba100_set_effect_emboss(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_effect_emboss(value);
+	if (!ret)
+		rj6aba100->efct_emboss = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_SKETCH */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_sketch / rj6aba100_set_effect_sketch
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_SKETCH
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_sketch(__u8 *value)
+{
+	*value = rj6aba100->efct_sketch;
+	return 0;
+}
+
+static inline int rj6aba100_set_effect_sketch(__u8 value)
+{
+	int ret = 0;
+
+	ret = rj6aba100_setreg_effect_sketch(value);
+	if (!ret)
+		rj6aba100->efct_sketch = value;
+	return ret;
+}
+
+
+/* MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL */
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_get_effect_sketch_userset
+ *           / rj6aba100_set_effect_sketch_userset
+ * RETURN   :
+ * NOTE     : MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL
+ * CREATE   : 2009/06/26 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_get_effect_sketch_userset(__u32 *value)
+{
+	return rj6aba100_getreg_effect_sketch_userset(value);
+}
+
+static inline int rj6aba100_set_effect_sketch_userset(__u32 value)
+{
+	return rj6aba100_setreg_effect_sketch_userset(value);
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_start_capture_read
+ * RETURN   :
+ * NOTE     :
+ * CREATE   :
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_start_capture_read(void)
+{
+	int ret = 0;
+
+	ret = rj6aba100_set_capture_read(rj6aba100->capture_size);
+
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : ctrl_by_id
+ * RETURN   :
+ * NOTE     : get rj6aba100_ctrls id
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static const struct v4l2_queryctrl *ctrl_by_id(unsigned int id)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUM_RJ6ABA100_CTRLS; i++)
+		if (rj6aba100_ctrls[i].id == id)
+			return rj6aba100_ctrls + i;
+	return NULL;
+}
+
+
+/* i/f function with mp200_cam.c */
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_vidioc_queryctrl
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_QUERYCTRL)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_vidioc_queryctrl(struct file *file,
+				       void *fh, struct v4l2_queryctrl *a)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	if (a->id < MP200_RJ6ABA100_CID_FW
+	    || a->id > MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL) {
+		ret = -EINVAL;
+	} else{
+		ctrl = ctrl_by_id(a->id);
+		*a = (NULL != ctrl) ? *ctrl : no_ctrl;
+	}
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_vidioc_querymenu
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_QUERYMENU)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_vidioc_querymenu(struct file *file,
+				       void *fh, struct v4l2_querymenu *m)
+{
+	const struct v4l2_queryctrl *ctrl;
+	int ret = 0;
+	FNC_ENTRY;
+
+	ctrl = ctrl_by_id(m->id);
+	if (NULL == ctrl) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_MENU:
+		if (m->index < ctrl->minimum || m->index > ctrl->maximum)
+			ret = -EINVAL;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	if (ret) {
+		FNC_EXIT(ret)
+		return ret;
+	}
+
+	mutex_lock(&rj6aba100->lock);
+	switch (m->id) {
+	case MP200_RJ6ABA100_CID_OUTIMG_SIZE:
+		strcpy(m->name, rj6aba100_outimg_size_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_OUTIMG_FORMAT:
+		strcpy(m->name, rj6aba100_outimg_fmt_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_OUTDATA_FORMAT:
+		strcpy(m->name,
+		       rj6aba100_outdata_fmt_menus
+		       [rj6aba100->outimg_fmt][m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_FLICKER:
+		strcpy(m->name, rj6aba100_flicker_menus[m->index].name);
+		break;
+#if 0 /* NOT SUPPORT */
+	case MP200_RJ6ABA100_CID_FLICKER_AUTO_DETECTION:
+	case MP200_RJ6ABA100_CID_AE:
+	case MP200_RJ6ABA100_CID_AE_MANUAL:
+		ret = -EINVAL;
+		break;
+#endif
+	case MP200_RJ6ABA100_CID_WB:
+		strcpy(m->name, rj6aba100_wb_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_MIRROR:
+		strcpy(m->name, rj6aba100_mirror_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_COLOR:
+		strcpy(m->name, rj6aba100_effect_color_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_NEGATIVE:
+		strcpy(m->name,
+		       rj6aba100_effect_negative_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_EMBOSS:
+		strcpy(m->name, rj6aba100_effect_emboss_menus[m->index].name);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_SKETCH:
+		strcpy(m->name, rj6aba100_effect_sketch_menus[m->index].name);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_vidioc_g_ctrl
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_G_CTRL)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_vidioc_g_ctrl(struct file *file, void *fh,
+				    struct v4l2_control *c)
+{
+	__u32 val = 0;
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+	mutex_lock(&rj6aba100->lock);
+	switch (c->id) {
+	case MP200_RJ6ABA100_CID_FW:
+		ret = rj6aba100_get_firmware_version((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_OUTIMG_SIZE:
+		ret = rj6aba100_get_outimg_size((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_OUTIMG_FORMAT:
+		ret = rj6aba100_get_outimg_fmt((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_OUTDATA_FORMAT:
+		ret = rj6aba100_get_imgdata_fmt((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_FLICKER:
+		ret = rj6aba100_get_flicker_manual((__u8 *)&val);
+		break;
+#if 0 /* NOT SUPPORT */
+	case MP200_RJ6ABA100_CID_FLICKER_AUTO_DETECTION:
+	case MP200_RJ6ABA100_CID_AE:
+	case MP200_RJ6ABA100_CID_AE_MANUAL:
+		ret = -EINVAL;
+		break;
+#endif
+	case MP200_RJ6ABA100_CID_WB:
+		ret = rj6aba100_get_wb_mode((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_WB_MANUAL_GAIN:
+		ret = rj6aba100_get_wb_manual_gain((__u32 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_BRIGHTNESS:
+		ret = rj6aba100_get_brightness((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_CONTRAST:
+		ret = rj6aba100_get_contrast((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_SHARPNESS:
+		ret = rj6aba100_get_sharpness((__u32 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_MIRROR:
+		ret = rj6aba100_get_mirror((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_COLOR:
+		ret = rj6aba100_get_effect_color((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL:
+		ret = rj6aba100_get_effect_color_userset((__u32 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_NEGATIVE:
+		ret = rj6aba100_get_effect_negative((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_EMBOSS:
+		ret = rj6aba100_get_effect_emboss((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_SKETCH:
+		ret = rj6aba100_get_effect_sketch((__u8 *)&val);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL:
+		ret = rj6aba100_get_effect_sketch_userset((__u32 *)&val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	if (!ret)
+		c->value = val;
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_vidioc_s_ctrl
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_S_CTRL)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_vidioc_s_ctrl(struct file *file, void *fh,
+				    struct v4l2_control *c)
+{
+	int ret = 0;
+	int moving = (int)fh;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	ctrl = ctrl_by_id(c->id);
+	if (NULL == ctrl) {
+		FNC_EXIT(-EINVAL)
+		return -EINVAL;
+	}
+	switch (ctrl->type) {
+	case V4L2_CTRL_TYPE_BOOLEAN:
+	case V4L2_CTRL_TYPE_MENU:
+	case V4L2_CTRL_TYPE_INTEGER:
+#if 0
+		if (c->value < ctrl->minimum)
+			c->value = ctrl->minimum;
+		if (c->value > ctrl->maximum)
+			c->value = ctrl->maximum;
+#else
+		if (c->id == MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL) {
+			if ((__u32)c->value < (__u32)ctrl->minimum)
+				c->value = ctrl->minimum;
+			if ((__u32)c->value > (__u32)ctrl->maximum)
+				c->value = ctrl->maximum;
+		} else{
+			if (c->value < ctrl->minimum)
+				c->value = ctrl->minimum;
+			if (c->value > ctrl->maximum)
+				c->value = ctrl->maximum;
+		}
+#endif
+		break;
+	default:
+		/* nothing */;
+	};
+	mutex_lock(&rj6aba100->lock);
+	switch (c->id) {
+#if 0 /* READ ONLY */
+	case MP200_RJ6ABA100_CID_FW:
+		break;
+#endif
+	case MP200_RJ6ABA100_CID_OUTIMG_SIZE:
+		if (moving) {
+			warn("RJ6ABA100 : s_ctrl OUT_IMG_RESIZE :"
+			     "streaming already exists.\n");
+			ret = -EBUSY;
+			break;
+		}
+		ret = rj6aba100_set_outimg_size(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_OUTIMG_FORMAT:
+		ret = rj6aba100_set_outimg_fmt(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_OUTDATA_FORMAT:
+		ret = rj6aba100_set_imgdata_fmt(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_FLICKER:
+		ret = rj6aba100_set_flicker_manual(c->value);
+		break;
+#if 0 /* NOT SUPPORT */
+	case MP200_RJ6ABA100_CID_FLICKER_AUTO_DETECTION:
+	case MP200_RJ6ABA100_CID_AE:
+	case MP200_RJ6ABA100_CID_AE_MANUAL:
+		ret = -EINVAL;
+		break;
+#endif
+	case MP200_RJ6ABA100_CID_WB:
+		ret = rj6aba100_set_wb_mode(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_WB_MANUAL_GAIN:
+		ret = rj6aba100_set_wb_manual_gain(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_BRIGHTNESS:
+		ret = rj6aba100_set_brightness(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_CONTRAST:
+		ret = rj6aba100_set_contrast(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_SHARPNESS:
+		ret = rj6aba100_set_sharpness(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_MIRROR:
+		ret = rj6aba100_set_mirror(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_COLOR:
+		ret = rj6aba100_set_effect_color(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_COLOR_MANUAL:
+		ret = rj6aba100_set_effect_color_userset(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_NEGATIVE:
+		ret = rj6aba100_set_effect_negative(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_EMBOSS:
+		ret = rj6aba100_set_effect_emboss(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_SKETCH:
+		ret = rj6aba100_set_effect_sketch(c->value);
+		break;
+	case MP200_RJ6ABA100_CID_EFFECT_SKETCH_MANUAL:
+		ret = rj6aba100_set_effect_sketch_userset(c->value);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : rj6aba100_set_prepare
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static inline int rj6aba100_set_prepare(struct mp200_cam_prepare *prepare)
+{
+	FNC_ENTRY;
+
+	prepare->syncmode = 0;
+	prepare->synctype = 1;
+	prepare->data_id  = 0;
+	prepare->vs_det   = 0;
+	prepare->hs_det   = 0;
+	prepare->clk_edge = 0;
+	prepare->data_det = 0;
+	prepare->vs_pol   = 0;
+	prepare->hs_pol   = 0;
+
+	FNC_EXIT(ret)
+	return 0;
+}
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_sync
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_sync(struct mp200_cam_prepare *prepare)
+{
+	int ret = 0;
+	__u8 size;
+	FNC_ENTRY;
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_get_outimg_size(&size);
+	if (ret) {
+		FNC_EXIT(ret)
+		mutex_unlock(&rj6aba100->lock);
+		return ret;
+	}
+
+	if (BOUNDARY_OUT_IMG_RESIZE <= size) {
+		struct control_resize_info *s;
+
+		if (MP200_RJ6ABA100_BREAK == rj6aba100->state) {
+			FNC_EXIT(-EIO)
+			mutex_unlock(&rj6aba100->lock);
+			return -EIO;
+		}
+
+		ret = rj6aba100_get_outimg_size(&size);
+		if (ret) {
+			FNC_EXIT(ret)
+			mutex_unlock(&rj6aba100->lock);
+			return ret;
+		}
+
+		s = (struct control_resize_info *)rj6aba100_outimg_size_menus;
+		s += size;
+
+		prepare->bounds.left   = 0;
+		prepare->bounds.top    = 0;
+		prepare->bounds.width  = s->width  - (s->x - 1);
+		prepare->bounds.height = s->height - (s->y - 1);
+
+		prepare->c = prepare->bounds;
+		prepare->width  = prepare->c.width  - (prepare->c.left - 1);
+		prepare->height = prepare->c.height - (prepare->c.top  - 1);
+
+		if (!prepare->actions) {
+			FNC_EXIT(ret)
+			mutex_unlock(&rj6aba100->lock);
+			return ret;
+		}
+
+		prepare->actions = 1;
+
+		ret = rj6aba100_set_liveview(SET_LIVEVIEW_START);
+	} else {
+		prepare->actions = 0;
+	}
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_prepare
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_prepare(struct mp200_cam_prepare *prepare)
+{
+	__u8 index;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_get_outimg_size(&index);
+	if (!ret) {
+		struct control_resize_info *s;
+
+		s = (struct control_resize_info *)rj6aba100_outimg_size_menus;
+		s += index;
+
+		prepare->bounds.left   = 0;
+		prepare->bounds.top    = 0;
+		prepare->bounds.width  = s->width  - (s->x - 1);
+		prepare->bounds.height = s->height - (s->y - 1);
+
+		rj6aba100_set_prepare(prepare);
+
+		prepare->reset = rj6aba100->reset;
+		d1b("chk reset 0x%02x\n", rj6aba100->reset);
+
+		if (prepare->actions && !rj6aba100->reset
+		    && BOUNDARY_OUT_IMG_RESIZE <= index)
+			rj6aba100->state = MP200_RJ6ABA100_IDLE;
+
+		rj6aba100->reset = 0;
+	}
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_trigger
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_trigger(int flag)
+{
+	__u8 size;
+	int ret = 0;
+	FNC_ENTRY;
+
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_get_outimg_size(&size);
+	if (ret) {
+		FNC_EXIT(ret)
+		mutex_unlock(&rj6aba100->lock);
+		return ret;
+	}
+
+	if (BOUNDARY_OUT_IMG_RESIZE <= size) {
+		ret = rj6aba100_start_capture_read();
+		if (MP200_RJ6ABA100_BREAK == rj6aba100->state) {
+			FNC_EXIT(-EIO)
+			mutex_unlock(&rj6aba100->lock);
+			return -EIO;
+		}
+	}
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_stream_on
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_STREAMON)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_stream_on(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_set_liveview(SET_LIVEVIEW_START);
+	msleep(500);
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_stream_off
+ * RETURN   :
+ * NOTE     : called from mp200_cam.c ioctl(VIDIOC_STREAMOFF)
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_stream_off(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_set_liveview(SET_LIVEVIEW_STOP);
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_startup
+ * RETURN   :
+ * NOTE     : initialize RJ6ABA100. called from mp200_cam.c open()
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+#define END_MARK 0xFF
+static int mp200_mega_startup(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+	mutex_lock(&rj6aba100->lock);
+
+	i2c_stop = 0;
+	rj6aba100->state = MP200_RJ6ABA100_IDLE;
+
+	/* Reset Camera Module
+	 * GIO_P8 = '1b'
+	 */
+	gpio_direction_output(GPIO_CAM_RST, 0x1); /* GIO_P8 output High */
+
+	ret = i2c_add_driver(&rj6aba100_i2c_driver);
+	debug_snprintf("i2c_add_driver(%d, %p)\n", ret, rj6aba100_i2c_client);
+	if (ret < 0) {
+		err("i2c: Driver registration failed,"
+		    "module not inserted.\n");
+		goto done_mega_startup;
+	} else if (NULL == rj6aba100_i2c_client)    {
+		i2c_del_driver(&rj6aba100_i2c_driver);
+		err("i2c: Device was not detected.\n");
+		ret = -EINVAL;
+
+		goto done_mega_startup;
+	} else {
+
+		ret = rj6aba100_set_liveview(SET_LIVEVIEW_STOP);
+		if (ret) {
+			err("i2c: Failed in writing to ");
+			err("the softstandby[B-04:Control_01].\n");
+			goto done_mega_startup;
+		}
+
+		ret = rj6aba100_setreg_softreset(NUM_B06_SOFTRESET_OFF);
+		if (ret) {
+			err("i2c: Failed in writing to ");
+			err("the softreset[B-06:Softreset].\n");
+			goto done_mega_startup;
+		}
+
+		ret = rj6aba100_getreg_firmware_version(
+			&rj6aba100->firmware_version);
+		if (ret) {
+			err("i2c: Failed in reading of the version");
+			err("information[x-02: RevNumber].\n");
+			goto done_mega_startup;
+		}
+	}
+
+	/* rj6aba100 initialization */
+	{
+		ret = rj6aba100_setreg_pll_control(688);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_outimg_size(rj6aba100->capture_size);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_outimg_fmt(rj6aba100->outimg_fmt);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_pclk_rate();
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_outdata_fmt(rj6aba100->imgdata_fmt);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_flicker_manual(
+			rj6aba100->flicker_manual);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_wb_manual_gain(
+			rj6aba100->wb_manual_gain);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_wb_mode(rj6aba100->wb_mode);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_brightness(rj6aba100->brightness);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_contrast(rj6aba100->contrast);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_sharpness(rj6aba100->sharpness);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_mirror(rj6aba100->mirror);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_effect_color(rj6aba100->efct_color);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_effect_negative(
+			rj6aba100->efct_negative);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_effect_emboss(rj6aba100->efct_emboss);
+		if (ret)
+			goto done_mega_startup;
+
+		ret = rj6aba100_setreg_effect_sketch(rj6aba100->efct_sketch);
+		if (ret)
+			goto done_mega_startup;
+
+		rj6aba100->state = MP200_RJ6ABA100_IDLE;
+
+#if CAM_DEBUG
+		/* debug only */
+		mp200_mage_register_debug();
+#endif /* CAM_DEBUG */
+	}
+
+	rj6aba100->active = 1;
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+
+done_mega_startup:
+
+	rj6aba100_shutdown();
+	if (rj6aba100_i2c_client) {
+		debug_snprintf("i2c_del_driver(%p)\n", rj6aba100_i2c_client);
+		i2c_del_driver(&rj6aba100_i2c_driver);
+	}
+	rj6aba100_i2c_client = NULL;
+	rj6aba100->active = 0;
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_shutdown
+ * RETURN   :
+ * NOTE     : uninitialize RJ6ABA100. called from mp200_cam.c close()
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_shutdown(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+	mutex_lock(&rj6aba100->lock);
+
+	ret = rj6aba100_shutdown();
+
+	if (rj6aba100_i2c_client) {
+		debug_snprintf("i2c_del_driver(%p)\n", rj6aba100_i2c_client);
+		i2c_del_driver(&rj6aba100_i2c_driver);
+	}
+	rj6aba100_i2c_client = NULL;
+
+	FNC_EXIT(ret)
+	mutex_unlock(&rj6aba100->lock);
+	return 0;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_mega_unregister
+ * RETURN   :
+ * NOTE     : unregist RJ6ABA100. called from mp200_cam.c shutdown
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+static int mp200_mega_unregister(int flag)
+{
+	int ret = 0;
+	FNC_ENTRY;
+
+	kfree(rj6aba100);
+	rj6aba100 = NULL;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+
+
+/*****************************************************************************
+ * MODULE   : mp200_mega.c
+ * FUNCTION : mp200_cam_hw_register
+ * RETURN   :
+ * NOTE     : regist RJ6ABA100. called from mp200_cam.c startup
+ * CREATE   : 2009/06/25 M.Haguro
+ * UPDATE   :
+ ******************************************************************************/
+int mp200_cam_hw_register(struct mp200_cam_hw_operations *hw)
+{
+	int ret = 0;
+	const struct v4l2_queryctrl *ctrl;
+	FNC_ENTRY;
+
+	rj6aba100 = kzalloc(sizeof(*rj6aba100), GFP_KERNEL);
+
+	if (rj6aba100 == NULL) {
+		err("RJ6ABA100: rj6aba100 allocation failed!\n");
+		FNC_EXIT(-ENOMEM)
+		return -ENOMEM;
+	}
+
+	strlcpy(hw->name, "EM1: RJ6ABA100 Camera", sizeof(hw->name));
+
+	hw->vidioc_queryctrl = mp200_mega_vidioc_queryctrl;
+	hw->vidioc_querymenu = mp200_mega_vidioc_querymenu;
+	hw->vidioc_g_ctrl    = mp200_mega_vidioc_g_ctrl;
+	hw->vidioc_s_ctrl    = mp200_mega_vidioc_s_ctrl;
+	hw->prepare          = mp200_mega_prepare;
+	hw->trigger          = mp200_mega_trigger;
+	hw->sync             = mp200_mega_sync;
+	hw->stream_on        = mp200_mega_stream_on;
+	hw->stream_off       = mp200_mega_stream_off;
+	hw->startup          = mp200_mega_startup;
+	hw->shutdown         = mp200_mega_shutdown;
+	hw->unregister       = mp200_mega_unregister;
+
+	/* initial rj6aba100 */
+	mutex_init(&rj6aba100->lock);
+
+	rj6aba100->firmware_version = 0xff;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_OUTIMG_SIZE);
+	rj6aba100->capture_size  = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_OUTIMG_FORMAT);
+	rj6aba100->outimg_fmt = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_OUTDATA_FORMAT);
+	rj6aba100->imgdata_fmt = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_FLICKER);
+	rj6aba100->flicker_manual = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_WB_MANUAL_GAIN);
+	rj6aba100->wb_manual_gain = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_WB);
+	rj6aba100->wb_mode = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_BRIGHTNESS);
+	rj6aba100->brightness = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_CONTRAST);
+	rj6aba100->contrast = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_SHARPNESS);
+	rj6aba100->sharpness = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_MIRROR);
+	rj6aba100->efct_color = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_EFFECT_COLOR);
+	rj6aba100->efct_color = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_EFFECT_NEGATIVE);
+	rj6aba100->efct_negative = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_EFFECT_EMBOSS);
+	rj6aba100->efct_emboss = ctrl->default_value;
+
+	ctrl = ctrl_by_id(MP200_RJ6ABA100_CID_EFFECT_SKETCH);
+	rj6aba100->efct_sketch = ctrl->default_value;
+
+	hw->private = rj6aba100;
+
+	FNC_EXIT(ret)
+	return ret;
+}
+EXPORT_SYMBOL(mp200_cam_hw_register);
+
+
-- 
1.6.5.2

