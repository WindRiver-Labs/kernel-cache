From 6867c56848e11c60847c21e5306668d840827ab7 Mon Sep 17 00:00:00 2001
From: Tom Zanussi <tom.zanussi@intel.com>
Date: Thu, 25 Nov 2010 03:42:45 -0600
Subject: [PATCH 11/15] eg20t: Add official 2.6.33 pch_i2c patch

I2C driver of Topcliff PCH

Topcliff PCH is the platform controller hub that is going to be used in
Intel's upcoming general embedded platform. All IO peripherals in
Topcliff PCH are actually devices sitting on AMBA bus.
Topcliff PCH has I2C I/F. Using this I/F, it is able to access system
devices connected to I2C.

Signed-off-by: Tomoya MORINAGA <tomoya-linux@dsn.okisemi.com>

Applied to 2.6.34 with fuzz, by: Tom Zanussi<tom.zanussi@intel.com>

Signed-off-by: Tom Zanussi <tom.zanussi@intel.com>
---
 drivers/i2c/busses/Kconfig   |    8 +
 drivers/i2c/busses/Makefile  |    3 +
 drivers/i2c/busses/i2c-pch.c |  910 ++++++++++++++++++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-pch.h |  147 +++++++
 drivers/i2c/i2c-dev.c        |   21 +
 5 files changed, 1089 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-pch.c
 create mode 100644 drivers/i2c/busses/i2c-pch.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 9c6170c..ef291ae 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -7,6 +7,14 @@ menu "I2C Hardware Bus support"
 comment "PC SMBus host controller drivers"
 	depends on PCI
 
+config PCH_I2C
+	tristate "PCH I2C"
+	depends on PCI
+	help
+	  This driver is for PCH I2C of Topcliff which is an IOH for x86
+	  embedded processor.
+	  This driver can access PCH I2C bus device.
+
 config I2C_ALI1535
 	tristate "ALI 1535"
 	depends on PCI
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 097236f..412c425 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -78,3 +78,6 @@ obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
+
+obj-$(CONFIG_PCH_I2C) += pch_i2c.o
+pch_i2c-objs := i2c-pch.o
diff --git a/drivers/i2c/busses/i2c-pch.c b/drivers/i2c/busses/i2c-pch.c
new file mode 100644
index 0000000..455bab3
--- /dev/null
+++ b/drivers/i2c/busses/i2c-pch.c
@@ -0,0 +1,910 @@
+/*
+ * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+#include <linux/ktime.h>
+
+#include "i2c-pch.h"
+
+static int pch_i2c_speed = 100; /* I2C bus speed in Kbps */
+static int pch_clk = 50000;	/* specifies I2C clock speed in KHz */
+static wait_queue_head_t pch_event;
+static DEFINE_MUTEX(pch_mutex);
+
+static struct pci_device_id __devinitdata pch_pcidev_id[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_PCH_I2C)},
+	{0,}
+};
+
+static irqreturn_t pch_handler_ch0(int irq, void *pData);
+static irqreturn_t(*pch_handler_list[PCH_MAX_CHN]) (int irq, void *pData) = {
+	pch_handler_ch0,
+};
+
+static inline void pch_setbit(void __iomem *addr, u32 offset, u32 bitmask)
+{
+	iowrite32(((ioread32(addr + offset)) | (bitmask)), (addr + offset));
+}
+
+static inline void pch_clrbit(void __iomem *addr, u32 offset, u32 bitmask)
+{
+	iowrite32(((ioread32(addr + offset)) & (~(bitmask))), (addr + offset));
+}
+
+/**
+ * pch_init() - hardware initialization of I2C module
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_init(struct i2c_algo_pch_data *adap)
+{
+	u32 pch_i2cbc;
+	u32 pch_i2ctmr;
+	u32 reg_value;
+	void __iomem *p = adap->pch_base_address;
+
+	/* reset I2C controller */
+	iowrite32(0x01, p + PCH_I2CSRST);
+	iowrite32(0x0, p + PCH_I2CSRST);
+	/* Initialize I2C registers */
+	iowrite32(CLR_REG, p + PCH_I2CCTL);
+	iowrite32(CLR_REG, p + PCH_I2CMOD);
+	iowrite32(CLR_REG, p + PCH_I2CBUFFOR);
+	iowrite32(CLR_REG, p + PCH_I2CBUFSLV);
+	iowrite32(CLR_REG, p + PCH_I2CBUFSUB);
+	iowrite32(CLR_REG, p + PCH_I2CBUFMSK);
+	iowrite32(CLR_REG, p + PCH_I2CESRFOR);
+	iowrite32(CLR_REG, p + PCH_I2CESRMSK);
+	iowrite32(0x21, p + PCH_I2CNF);
+
+	dev_dbg(adap->pch_adapter.dev.parent,
+		"Cleared the registers PCH_I2CCTL,PCH_I2CMOD,PCH_I2CBUFFOR\n,"
+		"PCH_I2CBUFSLV,PCH_I2CBUFSUB,PCH_I2CBUFMSK,\n"
+		"PCH_I2CESRFOR,PCH_I2CESRMSK\n");
+
+	reg_value = PCH_I2CCTL_I2CMEN;
+	pch_setbit((adap->pch_base_address), PCH_I2CCTL,
+			  PCH_I2CCTL_I2CMEN);
+
+	if (pch_i2c_speed != 400)
+		pch_i2c_speed = 100;
+
+	if (pch_i2c_speed == FAST_MODE_CLK) {
+		reg_value |= FAST_MODE_EN;
+		dev_dbg(adap->pch_adapter.dev.parent, "Fast mode enabled\n");
+	}
+
+	if (pch_clk <= 0 || pch_clk > PCH_MAX_CLK)
+		pch_clk = 62500;
+
+	pch_i2cbc = ((pch_clk) + (pch_i2c_speed * 4)) / (pch_i2c_speed * 8);
+	/* Set transfer speed in I2CBC */
+	iowrite32(pch_i2cbc, p + PCH_I2CBC);
+
+	pch_i2ctmr = (pch_clk) / 8;
+	iowrite32(pch_i2ctmr, p + PCH_I2CTMR);
+
+	reg_value |= NORMAL_INTR_ENBL;	/* Enable interrupts in normal mode */
+	iowrite32(reg_value, p + PCH_I2CCTL);
+
+	dev_dbg(adap->pch_adapter.dev.parent,
+		"%s: I2CCTL=%x pch_i2cbc=%x pch_i2ctmr=%x Enable interrupts\n",
+		__func__, ioread32(p + PCH_I2CCTL),
+		pch_i2cbc, pch_i2ctmr);
+
+	init_waitqueue_head(&pch_event);
+}
+
+static inline int ktime_lt(const ktime_t cmp1, const ktime_t cmp2)
+{
+	return cmp1.tv64 < cmp2.tv64;
+}
+
+/**
+ * pch_wait_for_bus_idle() - check the status of bus.
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ * @timeout:	waiting time counter (us).
+ */
+static s32 pch_wait_for_bus_idle(struct i2c_algo_pch_data *adap,
+				 s32 timeout)
+{
+	void __iomem *p = adap->pch_base_address;
+
+	/* MAX timeout value is timeout*1000*1000nsec */
+	ktime_t ns_val = ktime_add_ns(ktime_get(), timeout*1000*1000);
+	do {
+		if ((ioread32(p + PCH_I2CSR) & I2CMBB_BIT) == 0)
+			break;
+		msleep(1);
+	} while (ktime_lt(ktime_get(), ns_val));
+
+	dev_dbg(adap->pch_adapter.dev.parent,
+			"%s : I2CSR = %x\n", __func__, ioread32(p + PCH_I2CSR));
+
+	if (timeout == 0) {
+		dev_err(adap->pch_adapter.dev.parent,
+					"%s :return%d\n", __func__, -ETIME);
+	} else {
+		dev_dbg(adap->pch_adapter.dev.parent,
+					"%s : return %d\n", __func__, 0);
+	}
+
+	return ((timeout <= 0) ? (-ETIME) : (0));
+}
+
+/**
+ * pch_start() - Generate I2C start condition in normal mode.
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ *
+ * Generate I2C start condition in normal mode by setting I2CCTL.I2CMSTA to 1.
+ */
+static void pch_start(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+	dev_dbg(adap->pch_adapter.dev.parent, "In %s : I2CCTL = %x\n",
+					__func__, ioread32(p + PCH_I2CCTL));
+	pch_setbit((adap->pch_base_address), PCH_I2CCTL, PCH_START);
+	dev_dbg(adap->pch_adapter.dev.parent,
+		"Invoke %s successfully. I2CCTL = %x\n", __func__, PCH_I2CCTL);
+}
+
+/**
+ * pch_wait_for_xfer_complete() - initiates a wait for the tx complete event
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static s32 pch_wait_for_xfer_complete(struct i2c_algo_pch_data *adap)
+{
+	s32 ret;
+	ret = wait_event_interruptible_timeout(pch_event,
+			(adap->pch_event_flag != 0), msecs_to_jiffies(50));
+	if (ret < 0)
+		goto out;
+
+	if (ret == 0) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	if (adap->pch_event_flag & I2C_ERROR_MASK) {
+		ret = -EIO;
+		dev_err(adap->pch_adapter.dev.parent,
+				"error bits set: %x\n", adap->pch_event_flag);
+		goto out;
+	}
+
+	adap->pch_event_flag = 0;
+	ret = 0;
+out:
+	return ret;
+}
+
+/**
+ * pch_getack() - to confirm ACK/NACK
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static s32 pch_getack(struct i2c_algo_pch_data *adap)
+{
+	u32 reg_val;
+	void __iomem *p = adap->pch_base_address;
+	reg_val = ioread32(p + PCH_I2CSR) & PCH_GETACK;
+
+	if (reg_val == 0)
+		dev_dbg(adap->pch_adapter.dev.parent, "%s : return 0\n",
+								__func__);
+	else
+		dev_dbg(adap->pch_adapter.dev.parent, "%s : return%d\n",
+							__func__, -EPROTO);
+
+	return (((reg_val) == 0) ? (0) : (-EPROTO));
+}
+
+/**
+ * pch_stop() - generate stop condition in normal mode.
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_stop(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : I2CCTL = %x\n", __func__,
+		ioread32(p + PCH_I2CCTL));
+	/* clear the start bit */
+	pch_clrbit((adap->pch_base_address), PCH_I2CCTL, PCH_START);
+	dev_dbg(adap->pch_adapter.dev.parent, "In %s : I2CCTL = %x\n", __func__,
+						ioread32(p + PCH_I2CCTL));
+}
+
+/**
+ * pch_repstart() - generate repeated start condition in normal mode
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_repstart(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+	dev_dbg(adap->pch_adapter.dev.parent, "In %s : I2CCTL = %x\n",
+					__func__, ioread32(p + PCH_I2CCTL));
+	pch_setbit((adap->pch_base_address), PCH_I2CCTL, PCH_REPSTART);
+
+	dev_dbg(adap->pch_adapter.dev.parent, "In %s : I2CCTL = %x\n", __func__,
+						ioread32(p + PCH_I2CCTL));
+}
+
+/**
+ * pch_writebytes() - write data to I2C bus in normal mode
+ * @i2c_adap:	Pointer to the struct i2c_adapter.
+ * @last:	specifies whether last message or not.
+ *		In the case of compound mode it will be 1 for last message,
+ *		otherwise 0.
+ * @first:	specifies whether first message or not.
+ *		1 for first message otherwise 0.
+ */
+static s32 pch_writebytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,
+			  u32 last, u32 first)
+{
+	struct i2c_algo_pch_data *adap = i2c_adap->algo_data;
+	u8 *buf;
+	u32 length;
+	u32 addr;
+	u32 addr_2_msb;
+	u32 addr_8_lsb;
+	s32 wrcount;
+	void __iomem *p = adap->pch_base_address;
+	length = msgs->len;
+	buf = msgs->buf;
+	addr = msgs->addr;
+	/* enable master tx */
+	pch_setbit((adap->pch_base_address), PCH_I2CCTL, I2C_TX_MODE);
+
+	dev_dbg(adap->pch_adapter.dev.parent,
+		"%s : I2CCTL = %x msgs->len = %d\n", __func__,
+		ioread32(p + PCH_I2CCTL), length);
+
+	if (first) {
+		if (pch_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)
+			return -ETIME;
+	}
+
+	if (msgs->flags & I2C_M_TEN) {
+		addr_2_msb = ((addr & I2C_MSB_2B_MSK) >> 7);
+		iowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);
+		if (first)
+			pch_start(adap);
+		if ((pch_wait_for_xfer_complete(adap) == 0) &&
+		    (pch_getack(adap) == 0)) {
+			addr_8_lsb = (addr & I2C_ADDR_MSK);
+			iowrite32(addr_8_lsb, p + PCH_I2CDR);
+		} else {
+			pch_stop(adap);
+			return -ETIME;
+		}
+	} else {
+		/* set 7 bit slave address and R/W bit as 0 */
+		iowrite32(addr << 1, p + PCH_I2CDR);
+		if (first)
+			pch_start(adap);
+	}
+
+	if ((pch_wait_for_xfer_complete(adap) == 0) &&
+						(pch_getack(adap) == 0)) {
+		for (wrcount = 0; wrcount < length; ++wrcount) {
+			/* write buffer value to I2C data register */
+			iowrite32(buf[wrcount], p + PCH_I2CDR);
+			dev_dbg(adap->pch_adapter.dev.parent,
+				"%s : writing %x to Data register\n",
+				__func__, buf[wrcount]);
+
+			if (pch_wait_for_xfer_complete(adap) != 0) {
+				wrcount = -ETIME;
+				break;
+			}
+
+			dev_dbg(adap->pch_adapter.dev.parent,
+						"%s return %d", __func__, 0);
+
+			if (pch_getack(adap)) {
+				wrcount = -ETIME;
+				break;
+			}
+		}
+
+		/* check if this is the last message */
+		if (last)
+			pch_stop(adap);
+		else
+			pch_repstart(adap);
+	} else {
+		pch_stop(adap);
+	}
+
+	dev_err(adap->pch_adapter.dev.parent,
+					"%s return=%d\n", __func__, wrcount);
+
+	return wrcount;
+}
+
+/**
+ * pch_sendack() - send ACK
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_sendack(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : I2CCTL = %x\n", __func__,
+		  ioread32(p + PCH_I2CCTL));
+	pch_clrbit((adap->pch_base_address), PCH_I2CCTL, PCH_ACK);
+
+	dev_dbg(adap->pch_adapter.dev.parent,
+		"Invoke %s successfully. I2CCTL = %x\n", __func__, PCH_I2CCTL);
+}
+
+/**
+ * pch_sendnack() - send NACK
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_sendnack(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : I2CCTL = %x\n", __func__,
+						  ioread32(p + PCH_I2CCTL));
+	pch_setbit((adap->pch_base_address), PCH_I2CCTL, PCH_ACK);
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : I2CCTL = %x\n", __func__,
+						  ioread32(p + PCH_I2CCTL));
+}
+
+/**
+ * pch_readbytes() - read data  from I2C bus in normal mode.
+ * @i2c_adap:	Pointer to the struct i2c_adapter.
+ * @msgs:	Pointer to i2c_msg structure.
+ * @last:	specifies whether last message or not.
+ * @first:	specifies whether first message or not.
+ */
+s32 pch_readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,
+		  u32 last, u32 first)
+{
+	struct i2c_algo_pch_data *adap = i2c_adap->algo_data;
+
+	u8 *buf;
+	u32 count;
+	u32 length;
+	u32 addr;
+	u32 addr_2_msb;
+	void __iomem *p = adap->pch_base_address;
+	length = msgs->len;
+	buf = msgs->buf;
+	addr = msgs->addr;
+
+	/* enable master reception */
+	pch_clrbit((adap->pch_base_address), PCH_I2CCTL, I2C_TX_MODE);
+
+	if (first) {
+		if (pch_wait_for_bus_idle(adap, BUS_IDLE_TIMEOUT) == -ETIME)
+			return -ETIME;
+	}
+
+	if (msgs->flags & I2C_M_TEN) {
+		addr_2_msb = (((addr & I2C_MSB_2B_MSK) >> 7) | (I2C_RD));
+		iowrite32(addr_2_msb | TEN_BIT_ADDR_MASK, p + PCH_I2CDR);
+
+	} else {
+		/* 7 address bits + R/W bit */
+		addr = (((addr) << 1) | (I2C_RD));
+		iowrite32(addr, p + PCH_I2CDR);
+	}
+
+	/* check if it is the first message */
+	if (first)
+		pch_start(adap);
+
+	if ((pch_wait_for_xfer_complete(adap) == 0)
+					    && (pch_getack(adap) == 0)) {
+		dev_dbg(adap->pch_adapter.dev.parent,
+						"%s return %d", __func__, 0);
+
+		if (length == 0) {
+			pch_stop(adap);
+			ioread32(p + PCH_I2CDR); /* Dummy read needs */
+
+			count = length;
+		} else {
+			int read_index;
+			int loop;
+			pch_sendack(adap);
+
+			/* Dummy read */
+			for (loop = 1, read_index = 0; loop < length; loop++) {
+				buf[read_index] = ioread32(p + PCH_I2CDR);
+
+				if (loop != 1)
+					read_index++;
+
+				if (pch_wait_for_xfer_complete(adap) != 0) {
+					pch_stop(adap);
+					return -ETIME;
+				}
+			}	/* end for */
+
+			pch_sendnack(adap);
+
+			buf[read_index] = ioread32(p + PCH_I2CDR);
+
+			if (length != 1)
+				read_index++;
+
+			if (pch_wait_for_xfer_complete(adap) == 0) {
+				if (last)
+					pch_stop(adap);
+				else
+					pch_repstart(adap);
+
+				buf[read_index++] = ioread32(p + PCH_I2CDR);
+				count = read_index;
+			} else {
+				count = -ETIME;
+			}
+
+		}
+	} else {
+		count = -ETIME;
+		pch_stop(adap);
+	}
+
+	return count;
+}
+
+/**
+ * pch_cb_ch0() - Interrupt handler Call back function
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_cb_ch0(struct i2c_algo_pch_data *adap)
+{
+	u32 sts;
+	void __iomem *p = adap->pch_base_address;
+
+	sts = ioread32(p + PCH_I2CSR);
+	sts &= (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT);
+	if (I2CMAL_BIT & sts)
+		adap->pch_event_flag |= I2CMAL_EVENT;
+
+	if (I2CMCF_BIT & sts)
+		adap->pch_event_flag |= I2CMCF_EVENT;
+
+	/* clear the applicable bits */
+	pch_clrbit((adap->pch_base_address), PCH_I2CSR, sts);
+
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : PCH_I2CSR = %x\n",
+					__func__, ioread32(p + PCH_I2CSR));
+
+	wake_up_interruptible(&pch_event);
+}
+
+/**
+ * pch_handler_ch0() - interrupt handler for the PCH I2C controller
+ * @irq:	irq number.
+ * @pData:	cookie passed back to the handler function.
+ */
+static irqreturn_t pch_handler_ch0(int irq, void *pData)
+{
+	s32 reg_val;
+
+	struct i2c_algo_pch_data *adap_data = (struct i2c_algo_pch_data *)pData;
+	void __iomem *p = adap_data->pch_base_address;
+	u32 mode = ioread32(p + PCH_I2CMOD) & (BUFFER_MODE | EEPROM_SR_MODE);
+
+	if (mode == NORMAL_MODE) {
+		reg_val = ioread32(p + PCH_I2CSR);
+		if (reg_val & (I2CMAL_BIT | I2CMCF_BIT | I2CMIF_BIT))
+			pch_cb_ch0(adap_data);
+		else
+			goto err_out;
+	} else {
+		dev_err(adap_data->pch_adapter.dev.parent,
+			"%s I2C mode is not supported\n", __func__);
+		goto err_out;
+	}
+	return IRQ_HANDLED;
+
+err_out:
+	return IRQ_NONE;
+}
+
+/**
+ * pch_xfer() - Reading adnd writing data through I2C bus
+ * @i2c_adap:	Pointer to the struct i2c_adapter.
+ * @msgs:	Pointer to i2c_msg structure.
+ * @num:	number of messages.
+ */
+static s32 pch_xfer(struct i2c_adapter *i2c_adap,
+		    struct i2c_msg *msgs, s32 num)
+{
+	struct i2c_msg *pmsg;
+	u32 i;
+	u32 status;
+	u32 msglen;
+	u32 subaddrlen;
+	s32 ret;
+
+	struct i2c_algo_pch_data *adap = i2c_adap->algo_data;
+
+	ret = mutex_lock_interruptible(&pch_mutex);
+	if (ret) {
+		ret = -ERESTARTSYS;
+		goto return_err_nomutex;
+	}
+	if (adap->p_adapter_info->pch_suspended == false) {
+		dev_dbg(adap->pch_adapter.dev.parent,
+			"%s adap->p_adapter_info->pch_suspended is %d\n",
+			__func__, adap->p_adapter_info->pch_suspended);
+		/* transfer not completed */
+		adap->pch_xfer_in_progress = true;
+		dev_dbg(adap->pch_adapter.dev.parent,
+			"adap->pch_xfer_in_progress is %d\n",
+			adap->pch_xfer_in_progress);
+
+		ret = -EBUSY;
+		for (i = 0; i < num; i++) {
+			pmsg = &msgs[i];
+			pmsg->flags |= adap->pch_buff_mode_en;
+			status = pmsg->flags;
+			dev_dbg(adap->pch_adapter.dev.parent,
+				"After invoking I2C_MODE_SEL :flag= 0x%x\n",
+				status);
+			/* calculate sub address length and message length */
+			/* these are applicable only for buffer mode */
+			subaddrlen = pmsg->buf[0];
+			/* calculate actual message length excluding
+			 * the sub address fields */
+			msglen = (pmsg->len) - (subaddrlen + 1);
+			if (status & (I2C_M_RD)) {
+				dev_dbg(adap->pch_adapter.dev.parent,
+					"%s invoking pch_readbytes\n",
+					__func__);
+				ret = pch_readbytes(i2c_adap, pmsg,
+						      (i + 1 == num),
+						      (i == 0));
+			} else {
+				dev_info(adap->pch_adapter.dev.parent,
+					"%s invoking pch_writebytes\n",
+					__func__);
+				ret = pch_writebytes(i2c_adap, pmsg,
+						       (i + 1 == num),
+						       (i == 0));
+			}
+
+		}
+
+		adap->pch_xfer_in_progress = false;	/* transfer completed */
+
+		dev_dbg(adap->pch_adapter.dev.parent,
+					"adap->pch_xfer_in_progress is %d\n",
+					adap->pch_xfer_in_progress);
+	} else {
+		ret = -EBUSY;
+	}
+
+	mutex_unlock(&pch_mutex);
+return_err_nomutex:
+	dev_dbg(adap->pch_adapter.dev.parent, "%s return:%d\n\n\n\n",
+								__func__, ret);
+	return ret;
+}
+
+/**
+ * pch_func() - return the functionality of the I2C driver
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static u32 pch_func(struct i2c_adapter *adap)
+{
+	u32 ret;
+	ret = I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;
+	return ret;
+}
+
+static struct i2c_algorithm pch_algorithm = {
+	.master_xfer = pch_xfer,
+	.functionality = pch_func
+};
+
+/**
+ * pch_disbl_int() - Disable PCH I2C interrupts
+ * @adap:	Pointer to struct i2c_algo_pch_data.
+ */
+static void pch_disbl_int(struct i2c_algo_pch_data *adap)
+{
+	void __iomem *p = adap->pch_base_address;
+
+	pch_clrbit((adap->pch_base_address), PCH_I2CCTL,
+			  NORMAL_INTR_ENBL);
+
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : I2CCTL = %x\n", __func__,
+			  ioread32(p + PCH_I2CCTL));
+
+	iowrite32(EEPROM_RST_INTR_DISBL, p + PCH_I2CESRMSK);
+
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : PCH_I2CESRMSK = %x\n",
+					__func__, ioread32(p + PCH_I2CESRMSK));
+
+	iowrite32(BUFFER_MODE_INTR_DISBL, p + PCH_I2CBUFMSK);
+	dev_dbg(adap->pch_adapter.dev.parent, "%s : PCH_I2CBUFMSK = %x\n",
+		__func__, ioread32(p + PCH_I2CBUFMSK));
+}
+
+static int __devinit pch_probe(struct pci_dev *pdev,
+			       const struct pci_device_id *id)
+{
+	int i;
+	void __iomem *base_addr;
+	s32 ret;
+	struct adapter_info *adap_info =
+			kzalloc((sizeof(struct adapter_info)), GFP_KERNEL);
+
+	dev_dbg(&pdev->dev, "Enterred in %s\n", __func__);
+
+	if (adap_info == NULL) {
+		dev_err(&pdev->dev, "Memory allocation failed FAILED");
+		ret = -ENOMEM;
+		goto return_err;
+	}
+
+	dev_dbg(&pdev->dev,
+		"%s kzalloc invoked successfully and adap_info valu = %p\n",
+		__func__, adap_info);
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "%s : pci_enable_device FAILED", __func__);
+		goto err_pci_enable;
+	}
+
+	dev_dbg(&pdev->dev, "%s pci_enable_device returns %d\n", __func__, ret);
+
+	ret = pci_request_regions(pdev, MODULE_NAME);
+	if (ret) {
+		dev_err(&pdev->dev, "pci_request_regions FAILED");
+		goto err_pci_req;
+	}
+
+	dev_dbg(&pdev->dev, "%s pci_request_regions returns %d\n",
+								__func__, ret);
+
+	base_addr = pci_iomap(pdev, 1, 0);
+
+	if (base_addr == 0) {
+		dev_err(&pdev->dev, "pci_iomap FAILED");
+		ret = -ENOMEM;
+		goto err_pci_iomap;
+	}
+
+	dev_dbg(&pdev->dev, "%s pci_iomap invoked successfully\n", __func__);
+	adap_info->pch_suspended = false;
+
+	dev_dbg(&pdev->dev, "%s pch_entcb invoked successfully\n", __func__);
+
+	for (i = 0; i < PCH_MAX_CHN; i++) {
+		adap_info->pch_data[i].p_adapter_info = adap_info;
+
+		adap_info->pch_data[i].pch_adapter.owner = THIS_MODULE;
+		adap_info->pch_data[i].pch_adapter.class = I2C_CLASS_HWMON;
+		strcpy(adap_info->pch_data[i].pch_adapter.name, "pch_i2c");
+		adap_info->pch_data[i].pch_adapter.algo = &pch_algorithm;
+		adap_info->pch_data[i].pch_adapter.algo_data =
+							&adap_info->pch_data[i];
+
+		/* (i * 0x80) + base_addr; */
+		adap_info->pch_data[i].pch_base_address = base_addr;
+
+		adap_info->pch_data[i].pch_adapter.dev.parent = &pdev->dev;
+
+		ret = i2c_add_adapter(&(adap_info->pch_data[i].pch_adapter));
+
+		if (ret) {
+			dev_err(&pdev->dev, "i2c_add_adapter FAILED");
+			goto err_i2c_add_adapter;
+		}
+
+		dev_dbg(&pdev->dev,
+			"i2c_add_adapter returns %d for channel-%d\n", ret, i);
+		pch_init(&adap_info->pch_data[i]);
+		dev_dbg(&pdev->dev, "pch_init invoked successfully\n");
+		ret = request_irq(pdev->irq, pch_handler_list[i], IRQF_SHARED,
+			  MODULE_NAME, &adap_info->pch_data[i]);
+		if (ret) {
+			dev_err(&pdev->dev, "request_irq Failed\n");
+			goto err_request_irq;
+		}
+	}
+
+	dev_dbg(&pdev->dev, "request_irq returns %d pch_probe returns.\n", ret);
+	pci_set_drvdata(pdev, adap_info);
+	return 0;
+
+err_request_irq:
+	for (i = 0; i < PCH_MAX_CHN; i++)
+		i2c_del_adapter(&(adap_info->pch_data[i].pch_adapter));
+err_i2c_add_adapter:
+	pci_iounmap(pdev, base_addr);
+err_pci_iomap:
+	pci_release_regions(pdev);
+err_pci_req:
+	pci_disable_device(pdev);
+err_pci_enable:
+	kfree(adap_info);
+return_err:
+	return ret;
+}
+
+static void __devexit pch_remove(struct pci_dev *pdev)
+{
+	int i;
+
+	struct adapter_info *adap_info = pci_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "invoked function pci_get_drvdata successfully\n");
+
+	for (i = 0; i < PCH_MAX_CHN; i++) {
+		pch_disbl_int(&adap_info->pch_data[i]);
+
+		free_irq(pdev->irq, &adap_info->pch_data[i]);
+		dev_dbg(&pdev->dev, "free_irq invoked successfully\n");
+
+		i2c_del_adapter(&(adap_info->pch_data[i].pch_adapter));
+		dev_dbg(&pdev->dev, "invoked i2c_del_adapter successfully\n");
+	}
+
+	if (adap_info->pch_data[0].pch_base_address) {
+		pci_iounmap(pdev, adap_info->pch_data[0].pch_base_address);
+		dev_dbg(&pdev->dev, "pci_iounmap invoked successfully\n");
+		adap_info->pch_data[0].pch_base_address = 0;
+	}
+
+	pci_set_drvdata(pdev, NULL);
+
+	pci_release_regions(pdev);
+	dev_dbg(&pdev->dev, "pci_release_regions invoked successfully\n");
+
+	pci_disable_device(pdev);
+	kfree(adap_info);
+	dev_dbg(&pdev->dev,
+		"pci_disable_device invoked success.%s invoked success\n",
+		__func__);
+}
+
+#ifdef CONFIG_PM
+static int pch_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	int i;
+	int ret;
+
+	struct adapter_info *adap_info = pci_get_drvdata(pdev);
+	void __iomem *p = adap_info->pch_data[0].pch_base_address;
+
+	dev_dbg(&pdev->dev, "invoked function pci_get_drvdata successfully\n");
+
+	adap_info->pch_suspended = true;
+
+	for (i = 0; i < PCH_MAX_CHN; i++) {
+		while ((adap_info->pch_data[i].pch_xfer_in_progress)) {
+			/* It is assumed that any pending transfer will
+			 * be completed after the delay
+			 */
+			msleep(1);
+		}
+		/* Disable the i2c interrupts */
+		pch_disbl_int(&adap_info->pch_data[i]);
+	}
+
+	dev_dbg(&pdev->dev,
+		"I2CSR = %x I2CBUFSTA = %x I2CESRSTA = %x "
+		"invoked function pch_disbl_int successfully\n",
+		ioread32(p + 0x08),
+		ioread32(p + 0x30),
+		ioread32(p + 0x44));
+
+	ret = pci_save_state(pdev);
+
+	if (ret) {
+		dev_err(&pdev->dev, "pci_save_state failed\n");
+		return ret;
+	}
+
+	dev_dbg(&pdev->dev, "Invoked pci_save_state successfully\n");
+
+	pci_enable_wake(pdev, PCI_D3hot, 0);
+	dev_dbg(&pdev->dev, "Invoked pci_enable_wake successfully\n");
+
+	pci_disable_device(pdev);
+	dev_dbg(&pdev->dev, "Invoked pci_disable_device successfully\n");
+
+	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	dev_dbg(&pdev->dev,
+		"Invoked pci_set_power_state successfully. %s returns 0\n",
+		__func__);
+
+	return 0;
+}
+
+static int pch_resume(struct pci_dev *pdev)
+{
+	struct adapter_info *adap_info = pci_get_drvdata(pdev);
+	int i;
+
+	dev_dbg(&pdev->dev, "invoked function pci_get_drvdata successfully\n");
+
+	pci_set_power_state(pdev, PCI_D0);
+	dev_dbg(&pdev->dev, "Invoked pci_set_power_state successfully\n");
+
+	pci_restore_state(pdev);
+	dev_dbg(&pdev->dev, "Invoked pci_restore_state successfully\n");
+
+	if (pci_enable_device(pdev) < 0) {
+		dev_err(&pdev->dev, "pci_enable_device failed in pch_resume\n");
+		return -EIO;
+	}
+
+	pci_enable_wake(pdev, PCI_D3hot, 0);
+
+	dev_dbg(&pdev->dev, "Invoked pci_enable_wake successfully\n");
+
+	for (i = 0; i < PCH_MAX_CHN; i++)
+		pch_init(&adap_info->pch_data[i]);
+
+	dev_dbg(&pdev->dev, "Invoked pch_init successfully\n");
+
+	adap_info->pch_suspended = false;
+
+	dev_dbg(&pdev->dev, "%s return 0\n", __func__);
+	return 0;
+}
+#else
+#define pch_suspend NULL
+#define pch_resume NULL
+#endif
+
+static struct pci_driver pch_pcidriver = {
+	.name = "pch_i2c",
+	.id_table = pch_pcidev_id,
+	.probe = pch_probe,
+	.remove = __devexit_p(pch_remove),
+	.suspend = pch_suspend,
+	.resume = pch_resume
+};
+
+static int __init pch_pci_init(void)
+{
+	return pci_register_driver(&pch_pcidriver);
+}
+
+static void __exit pch_pci_exit(void)
+{
+	pci_unregister_driver(&pch_pcidriver);
+}
+
+MODULE_DESCRIPTION("PCH I2C PCI Driver");
+MODULE_LICENSE("GPL");
+module_init(pch_pci_init);
+module_exit(pch_pci_exit);
+module_param(pch_i2c_speed, int, (S_IRUSR | S_IWUSR));
+module_param(pch_clk, int, (S_IRUSR | S_IWUSR));
diff --git a/drivers/i2c/busses/i2c-pch.h b/drivers/i2c/busses/i2c-pch.h
new file mode 100644
index 0000000..0bb71e1
--- /dev/null
+++ b/drivers/i2c/busses/i2c-pch.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2010 OKI SEMICONDUCTOR CO., LTD.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PCH_HAL_H__
+#define __PCH_HAL_H__
+
+#define PCH_MAX_CHN	1	/* Maximum I2C channels available */
+#define PCH_EVENT_SET	0	/* I2C Interrupt Event Set Status */
+#define PCH_EVENT_NONE	1	/* I2C Interrupt Event Clear Status */
+#define PCH_MAX_CLK		100000	/* Maximum Clock speed in MHz */
+#define PCH_BUFFER_MODE_ENABLE	0x0002	/* flag for Buffer mode enable */
+#define PCH_EEPROM_SW_RST_MODE_ENABLE	0x0008	/* EEPROM SW RST enable flag */
+
+#define I2C_MODE_SEL	0x711	/* for mode selection */
+
+#define PCH_I2CSADR	0x00	/* I2C slave address register */
+#define PCH_I2CCTL	0x04	/* I2C control register */
+#define PCH_I2CSR	0x08	/* I2C status register */
+#define PCH_I2CDR	0x0C	/* I2C data register */
+#define PCH_I2CMON	0x10	/* I2C bus monitor register */
+#define PCH_I2CBC	0x14	/* I2C bus transfer rate setup counter */
+#define PCH_I2CMOD	0x18	/* I2C mode register */
+#define PCH_I2CBUFSLV	0x1C	/* I2C buffer mode slave address register */
+#define PCH_I2CBUFSUB	0x20	/* I2C buffer mode subaddress register */
+#define PCH_I2CBUFFOR	0x24	/* I2C buffer mode format register */
+#define PCH_I2CBUFCTL	0x28	/* I2C buffer mode control register */
+#define PCH_I2CBUFMSK	0x2C	/* I2C buffer mode interrupt mask register */
+#define PCH_I2CBUFSTA	0x30	/* I2C buffer mode status register */
+#define PCH_I2CBUFLEV	0x34	/* I2C buffer mode level register */
+#define PCH_I2CESRFOR	0x38	/* EEPROM software reset mode format register */
+#define PCH_I2CESRCTL	0x3C	/* EEPROM software reset mode ctrl register */
+#define PCH_I2CESRMSK	0x40	/* EEPROM software reset mode */
+#define PCH_I2CESRSTA	0x44	/* EEPROM software reset mode status register */
+#define PCH_I2CTMR	0x48	/* I2C timer register */
+#define PCH_I2CSRST	0xFC	/* I2C reset register */
+#define PCH_I2CNF	0xF8	/* I2C noise filter register */
+
+#define BUS_IDLE_TIMEOUT	20
+#define PCH_I2CCTL_I2CMEN	0x0080
+#define TEN_BIT_ADDR_DEFAULT	0xF000
+#define TEN_BIT_ADDR_MASK	0xF0
+#define PCH_START		0x0020
+#define PCH_ESR_START		0x0001
+#define PCH_BUFF_START		0x1
+#define PCH_REPSTART		0x0004
+#define PCH_ACK			0x0008
+#define PCH_GETACK		0x0001
+#define CLR_REG			0x0
+#define I2C_RD			0x1
+#define I2CMCF_BIT		0x0080
+#define I2CMIF_BIT		0x0002
+#define I2CMAL_BIT		0x0010
+#define I2CBMFI_BIT		0x0001
+#define I2CBMAL_BIT		0x0002
+#define I2CBMNA_BIT		0x0004
+#define I2CBMTO_BIT		0x0008
+#define I2CBMIS_BIT		0x0010
+#define I2CESRFI_BIT		0X0001
+#define I2CESRTO_BIT		0x0002
+#define I2CESRFIIE_BIT		0x1
+#define I2CESRTOIE_BIT		0x2
+#define I2CBMDZ_BIT		0x0040
+#define I2CBMAG_BIT		0x0020
+#define I2CMBB_BIT		0x0020
+#define BUFFER_MODE_MASK	(I2CBMFI_BIT | I2CBMAL_BIT | I2CBMNA_BIT | \
+				I2CBMTO_BIT | I2CBMIS_BIT)
+#define I2C_ADDR_MSK		0xFF
+#define I2C_MSB_2B_MSK		0x300
+#define FAST_MODE_CLK		400
+#define FAST_MODE_EN		0x0001
+#define SUB_ADDR_LEN_MAX	4
+#define BUF_LEN_MAX		32
+#define PCH_BUFFER_MODE		0x1
+#define EEPROM_SW_RST_MODE	0x0002
+#define NORMAL_INTR_ENBL	0x0300
+#define EEPROM_RST_INTR_ENBL	(I2CESRFIIE_BIT | I2CESRTOIE_BIT)
+#define EEPROM_RST_INTR_DISBL	0x0
+#define BUFFER_MODE_INTR_ENBL	0x001F
+#define BUFFER_MODE_INTR_DISBL	0x0
+#define NORMAL_MODE		0x0
+#define BUFFER_MODE		0x1
+#define EEPROM_SR_MODE		0x2
+#define I2C_TX_MODE		0x0010
+#define PCH_BUF_TX		0xFFF7
+#define PCH_BUF_RD		0x0008
+#define I2C_ERROR_MASK	(I2CESRTO_EVENT | I2CBMIS_EVENT | I2CBMTO_EVENT | \
+			I2CBMNA_EVENT | I2CBMAL_EVENT | I2CMAL_EVENT)
+#define I2CMAL_EVENT		0x0001
+#define I2CMCF_EVENT		0x0002
+#define I2CBMFI_EVENT		0x0004
+#define I2CBMAL_EVENT		0x0008
+#define I2CBMNA_EVENT		0x0010
+#define I2CBMTO_EVENT		0x0020
+#define I2CBMIS_EVENT		0x0040
+#define I2CESRFI_EVENT		0x0080
+#define I2CESRTO_EVENT		0x0100
+
+#define MODULE_NAME		"pch_i2c"
+#define PCI_DEVICE_ID_PCH_I2C	0x8817
+
+/**
+ * struct i2c_algo_pch_data - for I2C driver functionalities
+ * @p_adapter_info:		stores the reference to adapter_info structure
+ * @pch_adapter:		stores the reference to i2c_adapter structure
+ * @pch_base_address:		specifies the remapped base address
+ * @pch_buff_mode_en:		specifies if buffer mode is enabled
+ * @pch_event_flag:		specifies occurrence of interrupt events
+ * @pch_xfer_in_progress:	specifies whether the transfer is completed
+ */
+struct i2c_algo_pch_data {
+	struct adapter_info *p_adapter_info;
+	struct i2c_adapter pch_adapter;
+	void __iomem *pch_base_address;
+	int pch_buff_mode_en;
+	u32 pch_event_flag;
+	bool pch_xfer_in_progress;
+};
+
+/**
+ * struct adapter_info - This structure holds the adapter information for the
+			 PCH i2c controller
+ * @pch_data:	stores a list of i2c_algo_pch_data
+ * @pch_suspended:	specifies whether the system is suspended or not
+ *		perhaps with more lines and words.
+ *
+ * pch_data has as many elements as maximum I2C channels
+ */
+struct adapter_info {
+	struct i2c_algo_pch_data pch_data[PCH_MAX_CHN];
+	bool pch_suspended;
+};
+
+#endif
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index f4110aa..53e13de 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -36,6 +36,7 @@
 #include <linux/i2c-dev.h>
 #include <linux/jiffies.h>
 #include <asm/uaccess.h>
+#include "busses/i2c-pch.h"
 
 static struct i2c_driver i2cdev_driver;
 
@@ -372,6 +373,12 @@ static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	struct i2c_client *client = (struct i2c_client *)file->private_data;
 	unsigned long funcs;
 
+	unsigned long pch_mode;
+	int ret;
+
+	struct i2c_msg msg;
+	unsigned char msgbuf[1];
+
 	dev_dbg(&client->adapter->dev, "ioctl, cmd=0x%02x, arg=0x%02lx\n",
 		cmd, arg);
 
@@ -427,6 +434,20 @@ static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		 */
 		client->adapter->timeout = msecs_to_jiffies(arg * 10);
 		break;
+	case I2C_MODE_SEL:
+		pch_mode = arg;
+
+		if (pch_mode <= 4) {
+			msgbuf[0] = pch_mode;
+			msg.buf = msgbuf;
+			msg.len = 1;
+			msg.flags = 0;
+			ret = i2c_transfer(client->adapter, &msg, 1);
+		} else {
+			printk(KERN_ERR "I2C mode sel:Invalid mode\n");
+			ret = -EINVAL;
+		}
+		return ret;
 	default:
 		/* NOTE:  returning a fault code here could cause trouble
 		 * in buggy userspace code.  Some old kernel bugs returned
-- 
1.7.0.4

