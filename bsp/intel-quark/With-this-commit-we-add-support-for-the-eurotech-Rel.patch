From 49e6a52a0ab95da9551eb5173b4acaa8975b8512 Mon Sep 17 00:00:00 2001
From: Mihaita Ivascu <mihaita.ivascu@windriver.com>
Date: Sun, 7 Sep 2014 08:09:41 +0300
Subject: [PATCH] With this commit, we add support for the eurotech ReliaGATE
 Quark board : This board is similar to Clanton Hill. Still
 there are some differences: - there is only one sound
 controller and clanton had 2 - platform file had to remove
 the probing of missing audio chip

Signed-off-by: Mihaita Ivascu <mihaita.ivascu@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |   10 +
 drivers/platform/x86/quark/Makefile                |    2 +
 .../x86/quark/intel_qrk_audio_ctrl_reliagate.c     |  397 ++++++++++++++++++++
 .../x86/quark/intel_qrk_audio_ctrl_reliagate.h     |   40 ++
 drivers/platform/x86/quark/intel_qrk_board_data.c  |   10 +-
 .../platform/x86/quark/intel_qrk_plat_reliagate.c  |  232 ++++++++++++
 6 files changed, 688 insertions(+), 3 deletions(-)
 create mode 100755 drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.h
 create mode 100755 drivers/platform/x86/quark/intel_qrk_plat_reliagate.c

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 45ab69c..8dd98f0 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -144,6 +144,16 @@ static struct stmmac_qrk_mac_data phy_data [] = {
 		.bus_id		= 2,
 		.name		= "AiotX1000",
 	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "ReliaGate",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name		= "ReliaGate",
+	},
 };
 
 
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index 2cc5c75..4abbc53 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -15,3 +15,5 @@ obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_test.o
 obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram_test.o
 obj-$(CONFIG_INTEL_QRK_THERMAL)	+= intel_qrk_thermal.o
 obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL) += intel_qrk_audio_ctrl.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_reliagate.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_audio_ctrl_reliagate.o
diff --git a/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.c b/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.c
new file mode 100755
index 0000000..2d5b5fc
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.c
@@ -0,0 +1,397 @@
+/*
+ * Intel Quark platform audio control driver for Eurotech ReliaGATE board
+ *
+ * Copyright(c) 2014 Windriver Systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * The Intel Clanton Hill platform hardware design includes an audio subsystem
+ * with a number of interconnected audio interfaces.  This driver enables
+ * applications to choose which audio connections to enable for various
+ * application use cases.  The interconnections are selectable using GPIO output
+ * pins on the CPU.  This driver is also responsible for configuring a Maxim
+ * 9867 audio codec, a component of this audio subsystem, connected to the CPU
+ * via I2C.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+
+#include "intel_qrk_audio_ctrl_reliagate.h"
+
+#define DRIVER_NAME "intel_qrk_audio_ctrl_reliagate"
+
+/*
+ * GPIO numbers to use for switching audio paths
+ */
+#define GPIO_AUDIO_S0   11
+#define GPIO_AUDIO_S1   12
+#define GPIO_AUDIO_S2   13
+
+#define GPIO_AUDIO_DEFAULT (INTEL_QRK_AUDIO_MODE_SPKR_MIC)
+
+/**
+ * struct intel_qrk_audio_ctrl_data
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_qrk_audio_ctrl_priv {
+
+	/* Char dev to provide user-space ioctl interface for audio control */
+	struct cdev cdev;
+	dev_t cdev_no;
+	struct class *cl;
+
+	/* Mutex to protect against concurrent access to the ioctl() handler */
+	struct mutex lock;
+
+	/* Current GPIO switch value */
+	unsigned char gpio_val;
+};
+
+static int
+intel_qrk_audio_ctrl_open(struct inode *inode, struct file *filp)
+{
+	struct intel_qrk_audio_ctrl_priv *priv;
+
+	priv = container_of(inode->i_cdev,
+			    struct intel_qrk_audio_ctrl_priv,
+			    cdev);
+	filp->private_data = priv;
+
+	return 0;
+}
+
+static int
+intel_qrk_audio_ctrl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/*
+ * Logic truth table for AUDIO_S[0-3] outputs, illustrating which paths are
+ * connected between audio interfaces A, B.  Each audio interface has one
+ * effective input (I) port and one effective output (O) port
+ *
+ * A = USB Codec (to Quark CPU)
+ * B = Spkr/Mic  (to car audio system)
+ *
+ * PATH examples:
+ *   BI-AI: B-Input connected to A-Input
+ *
+ * NOTE: Assume a CI-AI connection is available in ALL cases (sometimes unused)
+ *
+ * S2 S1 S0  PATHS             USE CASE
+ * -- -- --  ----------------- -------------------------------------------------
+ *  0  0  1  AO-BO             Analog Driver Alerts (CI unused)
+ *  0  1  1  AO-BO,BI-AI       Archival Voice Record/Playback (or Driver Alerts)
+ *
+ *
+ * Mapping to IOCTLs (using more intuitive naming on the API):
+ *
+ * PATHS           IOCTL
+ * --------------- -------------------------------------------------------------
+ * AO-BO           INTEL_QRK_AUDIO_MODE_SPKR_ONLY
+ * AO-BO,BI-AI     INTEL_QRK_AUDIO_MODE_SPKR_MIC
+ */
+
+static int
+intel_qrk_audio_ctrl_gpio_update(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	int ret = 0;
+	struct gpio audio_sw_gpios[] = {
+		{
+			GPIO_AUDIO_S2,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s2"
+		},
+		{
+			GPIO_AUDIO_S1,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s1"
+		},
+		{
+			GPIO_AUDIO_S0,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s0"
+		}
+	};
+
+	/*
+	 * Update the Audio Switch GPIO outputs according to the user selection
+	 */
+	ret = gpio_request_array(audio_sw_gpios,
+				 ARRAY_SIZE(audio_sw_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate audio control GPIO pins\n",
+		       __func__);
+		return ret;
+	}
+
+	gpio_set_value(GPIO_AUDIO_S2, (priv->gpio_val >> 2) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S1, (priv->gpio_val >> 1) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S0, (priv->gpio_val >> 0) & 0x1);
+
+	gpio_free_array(audio_sw_gpios,
+			ARRAY_SIZE(audio_sw_gpios));
+
+	return 0;
+}
+
+static long
+intel_qrk_audio_ctrl_ioctl(struct file *filp,
+			   unsigned int cmd,
+			   unsigned long arg)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = filp->private_data;
+	int ret = 0;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case INTEL_QRK_AUDIO_MODE_IOC_SPKR_ONLY:
+	case INTEL_QRK_AUDIO_MODE_IOC_SPKR_MIC:
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	priv->gpio_val = _IOC_NR(cmd) & 0x7;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+static const struct file_operations intel_qrk_audio_ctrl_fops = {
+	.owner = THIS_MODULE,
+	.open = intel_qrk_audio_ctrl_open,
+	.release = intel_qrk_audio_ctrl_release,
+	.unlocked_ioctl = intel_qrk_audio_ctrl_ioctl
+};
+
+static int
+intel_qrk_audio_ctrl_chrdev_init(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	/* Register a character dev interface (with ioctls)
+	 * to allow control of the audio subsystem switch
+	 */
+	int ret;
+	struct device *dev;
+
+	ret = alloc_chrdev_region(&priv->cdev_no, 0, 1,
+				  "intel_qrk_audio_ctrl");
+	if (ret) {
+		pr_err("Failed to alloc chrdev: %d", ret);
+		return ret;
+	}
+
+	cdev_init(&priv->cdev, &intel_qrk_audio_ctrl_fops);
+
+	ret = cdev_add(&priv->cdev, priv->cdev_no, 1);
+	if (ret) {
+		pr_err("Failed to add cdev: %d", ret);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return ret;
+	}
+
+	priv->cl = class_create(THIS_MODULE, "char");
+	if (IS_ERR(priv->cl)) {
+		pr_err("Failed to create device class: %ld",
+		       PTR_ERR(priv->cl));
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(priv->cl);
+	}
+
+	dev = device_create(priv->cl, NULL, priv->cdev_no, NULL,
+			    "intel_qrk_audio_ctrl");
+	if (IS_ERR(dev)) {
+		pr_err("Failed to create device: %ld",
+		       PTR_ERR(priv->cl));
+		class_destroy(priv->cl);
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(dev);
+	}
+
+	return 0;
+}
+
+static int
+intel_qrk_audio_ctrl_chrdev_remove(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	device_destroy(priv->cl, priv->cdev_no);
+	class_destroy(priv->cl);
+	cdev_del(&priv->cdev);
+	unregister_chrdev_region(priv->cdev_no, 1);
+
+	return 0;
+}
+
+
+ssize_t intel_qrk_audio_ctrl_sysfs_show_mode(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	int ret;
+	char *mode;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (priv->gpio_val) {
+	case INTEL_QRK_AUDIO_MODE_SPKR_ONLY:
+		mode = "spkr";
+		break;
+	case INTEL_QRK_AUDIO_MODE_SPKR_MIC:
+		mode = "spkr_mic";
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = scnprintf(buf, PAGE_SIZE, "%s\n", mode);
+
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+ssize_t intel_qrk_audio_ctrl_sysfs_store_mode(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t count)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	char mode[16];
+	unsigned char gpio_val;
+	int ret = count;
+
+	sscanf(buf, "%15s", mode);
+
+
+        if (!strcmp(mode, "spkr"))
+	    gpio_val = INTEL_QRK_AUDIO_MODE_SPKR_ONLY;
+	else if (!strcmp(mode, "spkr_mic"))
+	    gpio_val = INTEL_QRK_AUDIO_MODE_SPKR_MIC;
+	else
+	    return -EINVAL;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+	    return ret;
+
+	priv->gpio_val = gpio_val;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+	if (ret)
+	    goto exit;
+
+	ret = count;
+
+exit:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+/* Sysfs attribute descriptor (for alternative user-space interface) */
+static DEVICE_ATTR(audio_switch_mode, S_IWUSR | S_IRUGO,
+		   intel_qrk_audio_ctrl_sysfs_show_mode,
+		   intel_qrk_audio_ctrl_sysfs_store_mode);
+
+/******************************************************************************
+ *                                Module hooks
+ ******************************************************************************/
+static int intel_qrk_audio_ctrl_reliagate_probe(struct platform_device *pdev)
+{
+
+       struct intel_qrk_audio_ctrl_priv *priv;
+       int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv),
+			    GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	mutex_init(&priv->lock);
+
+        platform_set_drvdata(pdev, priv);
+
+	priv->gpio_val = GPIO_AUDIO_DEFAULT;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+	if (ret)
+		goto exit;
+
+	/* Create a char dev interface, providing an ioctl config option */
+	ret = intel_qrk_audio_ctrl_chrdev_init(priv);
+	if (ret)
+		goto exit;
+
+	/* Also create a sysfs interface, providing a cmd line config option */
+	ret = sysfs_create_file(&pdev->dev.kobj,
+				&dev_attr_audio_switch_mode.attr);
+
+exit:
+	return ret;
+}
+
+
+
+
+static int intel_qrk_audio_ctrl_reliagate_remove(struct platform_device *pdev)
+{
+        struct intel_qrk_audio_ctrl_priv *priv;
+
+        priv = platform_get_drvdata(pdev);
+
+        intel_qrk_audio_ctrl_chrdev_remove(priv);
+
+	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_audio_switch_mode.attr);
+
+	return 0;
+}
+
+static struct platform_driver intel_qrk_audio_ctrl_reliagate_driver = {
+  .driver          = {
+    .name     = DRIVER_NAME,
+    .owner    = THIS_MODULE,
+  },
+  .probe     = intel_qrk_audio_ctrl_reliagate_probe,
+  .remove    = intel_qrk_audio_ctrl_reliagate_remove,
+};
+
+module_platform_driver(intel_qrk_audio_ctrl_reliagate_driver);
+
+MODULE_AUTHOR("Mihaita Ivascu <mihaita.ivascu@windriver.com>");
+MODULE_DESCRIPTION("Intel Quark platform audio control driver adapted for Eurotech ReliaGATE 15-10 board which doesn't have MAX9867 chip");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.h b/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.h
new file mode 100644
index 0000000..db7ca1f
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_audio_ctrl_reliagate.h
@@ -0,0 +1,40 @@
+/*
+ * Intel Quark platform audio control driver
+ *
+ * Copyright(c) 2014 WindRiver Systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * See intel_qrk_audio_ctrl_reliagate.c for a detailed description
+ *
+ */
+
+#ifndef __INTEL_QRK_AUDIO_CTRL_H__
+#define __INTEL_QRK_AUDIO_CTRL_H__
+
+#include <linux/module.h>
+
+#define INTEL_QRK_AUDIO_MODE_SPKR_ONLY      0x1
+#define INTEL_QRK_AUDIO_MODE_SPKR_MIC       0x3
+
+
+#define INTEL_QRK_AUDIO_MODE_IOC_SPKR_ONLY \
+	_IO('x', INTEL_QRK_AUDIO_MODE_SPKR_ONLY)
+#define INTEL_QRK_AUDIO_MODE_IOC_SPKR_MIC \
+	_IO('x', INTEL_QRK_AUDIO_MODE_SPKR_MIC)
+
+#endif /* __INTEL_QRK_AUDIO_CTRL_H__ */
diff --git a/drivers/platform/x86/quark/intel_qrk_board_data.c b/drivers/platform/x86/quark/intel_qrk_board_data.c
index e5c66db..92eebfb 100644
--- a/drivers/platform/x86/quark/intel_qrk_board_data.c
+++ b/drivers/platform/x86/quark/intel_qrk_board_data.c
@@ -139,6 +139,10 @@ static struct platform_device bsp_data [] = {
 		.name	= "AiotX1000",
 		.id	= -1,
 	},
+	{
+		.name	= "ReliaGate",
+		.id	= -1,
+	},
 };
 
 /**
@@ -185,7 +189,7 @@ static int __init intel_qrk_board_data_init_legacy(void)
 	if (!spi_data)
 		return -ENODEV;
 
-	/* get mfh and first item pointer */	
+	/* get mfh and first item pointer */
 	mfh = spi_data + MFH_OFFSET;
 	if (mfh->id != MFH_MAGIC){
 		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
@@ -239,9 +243,9 @@ static int __init intel_qrk_board_data_init(void)
 	u32 i;
 
 	/* BIOS later than version 0.9.0 contains the right DMI data */
-	for (i = 0; board_name != NULL && bios_version != NULL && 
+	for (i = 0; board_name != NULL && bios_version != NULL &&
 		i < sizeof(bsp_data)/sizeof(struct platform_device); i++){
-	
+
 		if (!strcmp(bsp_data[i].name, board_name)){
 
 			/* Register board */
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_reliagate.c b/drivers/platform/x86/quark/intel_qrk_plat_reliagate.c
new file mode 100755
index 0000000..f297e55
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_reliagate.c
@@ -0,0 +1,232 @@
+/*
+ * Copyright(c) 2014 Windriver Systems.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * mihaita.ivascu@windriver.com
+ */
+/*
+ * Eurotech reliaGATE 15-10 Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME		"ReliaGate"
+#define GPIO_RESTRICT_NAME	"qrk-gpio-restrict-nc"
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+#define AD7298_MAX_EXT_VIN_EXT_BATT 30000
+#define AD7298_MAX_EXT_VIN_INT_BATT 9200
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN_EXT_BATT, AD7298_MAX_EXT_VIN_INT_BATT }
+};
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	},
+};
+
+/******************************************************************************
+ *             ST Microelectronics LIS331DLH I2C Device Platform Data
+ ******************************************************************************/
+#include <linux/platform_data/lis331dlh_intel_qrk.h>
+
+/* GPIO interrupt pins connected to the LIS331DLH */
+#define ST_ACCEL_INT1_GPIO 15
+#define ST_ACCEL_INT2_GPIO 4
+
+static struct lis331dlh_intel_qrk_platform_data lis331dlh_i2c_platform_data = {
+	.irq1_pin = ST_ACCEL_INT1_GPIO,
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		ST_ACCEL_INT1_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int1"
+	},
+	{
+		ST_ACCEL_INT2_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int2"
+	},
+};
+
+/* I2C device addresses */
+#define LIS331DLH_ADDR				0x19
+
+static struct i2c_adapter *i2c_adap;
+static struct i2c_board_info probed_i2c_lis331dlh = {
+	.platform_data = &lis331dlh_i2c_platform_data,
+};
+static const unsigned short lis331dlh_i2c_addr[] =
+	{ LIS331DLH_ADDR, I2C_CLIENT_END };
+
+
+ static struct platform_device audio_ctrl_reliagate_device = {
+
+    .name = "intel_qrk_audio_ctrl_reliagate",
+    .id = -1,
+
+
+    };
+
+
+
+static int i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	/* Always return success: the I2C clients are already known.  */
+	return 1;
+}
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Hill platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+				       ARRAY_SIZE(spi_onboard_devs));
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	static int gpio_done, spi_done;
+	struct i2c_client *lis331dlh = NULL;
+
+	if (gpio_done)
+		goto spi;
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret)
+		goto end;
+	gpio_done = 1;
+
+spi:
+	if (spi_done)
+		goto i2c;
+	ret = intel_qrk_spi_add_onboard_devs();
+	if (ret)
+		goto end;
+	spi_done = 1;
+i2c:
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+        platform_device_register(&audio_ctrl_reliagate_device);
+
+	strlcpy(probed_i2c_lis331dlh.type, "lis331dlh_qrk", I2C_NAME_SIZE);
+	lis331dlh = i2c_new_probed_device(i2c_adap, &probed_i2c_lis331dlh,
+					lis331dlh_i2c_addr, i2c_probe);
+	i2c_put_adapter(i2c_adap);
+
+	if (NULL == lis331dlh) {
+		pr_err("%s: can't probe I2C devices\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_reliagate_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_qrk_plat_reliagate_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_reliagate_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_reliagate_probe,
+	.remove		= intel_qrk_plat_reliagate_remove,
+};
+
+module_platform_driver(qrk_reliagate_driver);
+
+MODULE_AUTHOR("Mihaita Ivascu  <mihaita.ivascu@windriver.com>");
+MODULE_DESCRIPTION("Clanton Hill BSP Data adapted for Eurotech ReliaGATE 15-10 board");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
-- 
1.7.5.4

