From 8df1e71bdca57b26fb2e0e56025898f717a5a0b5 Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Wed, 21 Nov 2012 16:27:00 +0000
Subject: [PATCH 1027/1187] staging:iio:ad7793: Rework regulator handling

commit dd2c101348cb725cfd3c9aa6c53c3443f2746c93	upstream

Rework the regulator handling of the driver to match more closely what we do in
other drivers. Make the regulator non-optional if a external reference is used.
Also dispose the option of specifying the reference voltage via platform data.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Jonathan Cameron <jic23@kernel.org>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/staging/iio/adc/ad7793.c |   44 ++++++++++++++++++++++---------------
 drivers/staging/iio/adc/ad7793.h |    3 --
 2 files changed, 26 insertions(+), 21 deletions(-)

diff --git a/drivers/staging/iio/adc/ad7793.c b/drivers/staging/iio/adc/ad7793.c
index ec0fbd4..6ddaccb 100644
--- a/drivers/staging/iio/adc/ad7793.c
+++ b/drivers/staging/iio/adc/ad7793.c
@@ -111,7 +111,8 @@ static int ad7793_calibrate_all(struct ad7793_state *st)
 }
 
 static int ad7793_setup(struct iio_dev *indio_dev,
-	const struct ad7793_platform_data *pdata)
+	const struct ad7793_platform_data *pdata,
+	unsigned int vref_mv)
 {
 	struct ad7793_state *st = iio_priv(indio_dev);
 	int i, ret = -1;
@@ -175,7 +176,7 @@ static int ad7793_setup(struct iio_dev *indio_dev,
 
 	/* Populate available ADC input ranges */
 	for (i = 0; i < ARRAY_SIZE(st->scale_avail); i++) {
-		scale_uv = ((u64)st->int_vref_mv * 100000000)
+		scale_uv = ((u64)vref_mv * 100000000)
 			>> (st->chip_info->channels[0].scan_type.realbits -
 			(!!(st->conf & AD7793_CONF_UNIPOLAR) ? 0 : 1));
 		scale_uv >>= i;
@@ -463,7 +464,7 @@ static int ad7793_probe(struct spi_device *spi)
 	const struct ad7793_platform_data *pdata = spi->dev.platform_data;
 	struct ad7793_state *st;
 	struct iio_dev *indio_dev;
-	int ret, voltage_uv = 0;
+	int ret, vref_mv = 0;
 
 	if (!pdata) {
 		dev_err(&spi->dev, "no platform data?\n");
@@ -483,25 +484,31 @@ static int ad7793_probe(struct spi_device *spi)
 
 	ad_sd_init(&st->sd, indio_dev, spi, &ad7793_sigma_delta_info);
 
-	st->reg = regulator_get(&spi->dev, "vcc");
-	if (!IS_ERR(st->reg)) {
+	if (pdata->refsel != AD7793_REFSEL_INTERNAL) {
+		st->reg = regulator_get(&spi->dev, "refin");
+		if (IS_ERR(st->reg)) {
+			ret = PTR_ERR(st->reg);
+			goto error_device_free;
+		}
+
 		ret = regulator_enable(st->reg);
 		if (ret)
 			goto error_put_reg;
 
-		voltage_uv = regulator_get_voltage(st->reg);
+		vref_mv = regulator_get_voltage(st->reg);
+		if (vref_mv < 0) {
+			ret = vref_mv;
+			goto error_disable_reg;
+		}
+
+		vref_mv /= 1000;
+	} else {
+		vref_mv = 1170; /* Build-in ref */
 	}
 
 	st->chip_info =
 		&ad7793_chip_info_tbl[spi_get_device_id(spi)->driver_data];
 
-	if (pdata && pdata->vref_mv)
-		st->int_vref_mv = pdata->vref_mv;
-	else if (voltage_uv)
-		st->int_vref_mv = voltage_uv / 1000;
-	else
-		st->int_vref_mv = 1170; /* Build-in ref */
-
 	spi_set_drvdata(spi, indio_dev);
 
 	indio_dev->dev.parent = &spi->dev;
@@ -515,7 +522,7 @@ static int ad7793_probe(struct spi_device *spi)
 	if (ret)
 		goto error_disable_reg;
 
-	ret = ad7793_setup(indio_dev, pdata);
+	ret = ad7793_setup(indio_dev, pdata, vref_mv);
 	if (ret)
 		goto error_remove_trigger;
 
@@ -528,12 +535,12 @@ static int ad7793_probe(struct spi_device *spi)
 error_remove_trigger:
 	ad_sd_cleanup_buffer_and_trigger(indio_dev);
 error_disable_reg:
-	if (!IS_ERR(st->reg))
+	if (pdata->refsel != AD7793_REFSEL_INTERNAL)
 		regulator_disable(st->reg);
 error_put_reg:
-	if (!IS_ERR(st->reg))
+	if (pdata->refsel != AD7793_REFSEL_INTERNAL)
 		regulator_put(st->reg);
-
+error_device_free:
 	iio_device_free(indio_dev);
 
 	return ret;
@@ -541,13 +548,14 @@ error_put_reg:
 
 static int ad7793_remove(struct spi_device *spi)
 {
+	const struct ad7793_platform_data *pdata = spi->dev.platform_data;
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad7793_state *st = iio_priv(indio_dev);
 
 	iio_device_unregister(indio_dev);
 	ad_sd_cleanup_buffer_and_trigger(indio_dev);
 
-	if (!IS_ERR(st->reg)) {
+	if (pdata->refsel != AD7793_REFSEL_INTERNAL) {
 		regulator_disable(st->reg);
 		regulator_put(st->reg);
 	}
diff --git a/drivers/staging/iio/adc/ad7793.h b/drivers/staging/iio/adc/ad7793.h
index 9e90590..7f6acac 100644
--- a/drivers/staging/iio/adc/ad7793.h
+++ b/drivers/staging/iio/adc/ad7793.h
@@ -182,7 +182,6 @@ enum ad7793_excitation_current {
 
 /**
  * struct ad7793_platform_data - AD7793 platform data
- * @vref_mv: Reference voltage in milli-Volt
  * @clock_src: Clock source selection
  * @burnout_current: If set to true the 100nA burnout current is enabled.
  * @boost_enable: Enable boost for the bias voltage generator.
@@ -195,8 +194,6 @@ enum ad7793_excitation_current {
  * @current_source_direction: Excitation current direction selection
  */
 struct ad7793_platform_data {
-	u16 vref_mv;
-
 	enum ad7793_clock_source clock_src;
 	bool burnout_current;
 	bool boost_enable;
-- 
1.7.5.4

