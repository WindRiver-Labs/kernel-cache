From a0fa3ea24972d4800574760112d263e0b032f35b Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Thu, 1 Jan 2015 10:42:20 +0800
Subject: [PATCH 03/31] Add the recommended UART driver for Quark SoC.

source: Intel vendor drop 1.1.0-rc2

This driver is the real replacement to 8250_pci for Quark SoC. The glue
mfd driver gives the hint regarding of enumerating 8250_dw, so the necessary
glue codes are added here.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/tty/serial/8250/8250.h    |   28 ---------
 drivers/tty/serial/8250/8250_dw.c |  111 +++++++++++++++++++++++++++++++++++++
 2 files changed, 111 insertions(+), 28 deletions(-)

diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index 1ebf853..480134c2 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -14,34 +14,6 @@
 #include <linux/serial_8250.h>
 #include <linux/dmaengine.h>
 
-struct uart_8250_dma {
-	dma_filter_fn		fn;
-	void			*rx_param;
-	void			*tx_param;
-
-	int			rx_chan_id;
-	int			tx_chan_id;
-
-	struct dma_slave_config	rxconf;
-	struct dma_slave_config	txconf;
-
-	struct dma_chan		*rxchan;
-	struct dma_chan		*txchan;
-
-	dma_addr_t		rx_addr;
-	dma_addr_t		tx_addr;
-
-	dma_cookie_t		rx_cookie;
-	dma_cookie_t		tx_cookie;
-
-	void			*rx_buf;
-
-	size_t			rx_size;
-	size_t			tx_size;
-
-	unsigned char		tx_running:1;
-};
-
 struct old_serial_port {
 	unsigned int uart;
 	unsigned int baud_base;
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 5caf10e..7912330 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -33,6 +33,10 @@
 
 #include "8250.h"
 
+static bool use_dma = 1;
+module_param(use_dma, bool, 0);
+MODULE_PARM_DESC(use_dma, "use_dma=1 (enable DMA)/use_dma=0(disable DMA)");
+
 /* Offsets for the DesignWare specific registers */
 #define DW_UART_USR	0x1f /* UART Status Register */
 #define DW_UART_CPR	0xf4 /* Component Parameter Register */
@@ -215,6 +219,19 @@ static unsigned int dw8250_serial_in32(struct uart_port *p, int offset)
 	return dw8250_modify_msr(p, offset, value);
 }
 
+static void
+dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
+		   struct ktermios *old)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+
+	/* For Quark, hs-uart is capable of auto flow control */
+	up->capabilities |= UART_CAP_AFE;
+
+	serial8250_do_set_termios(p, termios, old);
+}
+
 static int dw8250_handle_irq(struct uart_port *p)
 {
 	struct dw8250_data *d = p->private_data;
@@ -379,6 +396,96 @@ static inline int dw8250_probe_acpi(struct uart_8250_port *up,
 }
 #endif /* CONFIG_ACPI */
 
+static void _dw8250_mfd_dma_probe(struct uart_8250_port *up,
+					struct uart_8250_port *priv)
+{
+	up->dma->rx_chan_id = priv->dma->rx_chan_id;
+	up->dma->tx_chan_id = priv->dma->tx_chan_id;
+
+	if (priv->dma->fn)
+		up->dma->fn = priv->dma->fn;
+
+	if (priv->dma->txconf.dst_maxburst > 0)
+		up->dma->txconf.dst_maxburst = priv->dma->txconf.dst_maxburst;
+
+	if (priv->dma->rxconf.src_maxburst > 0)
+		up->dma->rxconf.src_maxburst = priv->dma->rxconf.src_maxburst;
+
+	if (priv->dma->tx_param)
+		up->dma->tx_param = priv->dma->tx_param;
+
+	if (priv->dma->rx_param)
+		up->dma->rx_param = priv->dma->rx_param;
+
+	return;
+}
+
+static int dw8250_probe_mfd_dev(struct platform_device *pdev,
+				struct uart_8250_port *up,
+				struct dw8250_data *data)
+{
+	struct plat_serial8250_port *pdata;
+	struct uart_8250_port *priv;
+	struct uart_port *p = &up->port;
+
+	/* Bail out if the device doesn't contain platform data */
+	if (NULL == pdev->dev.platform_data) {
+		dev_err(&pdev->dev, "no MFD platform data found!\n");
+		return -ENODEV;
+	}
+	pdata = pdev->dev.platform_data;
+
+	/* Bail out if there is no clock source assignment in platform data */
+	if (0 == pdata->uartclk) {
+		dev_err(&pdev->dev, "no uartclk found.\n");
+		return -ENODEV;
+	}
+	p->uartclk = pdata->uartclk;
+	dw8250_setup_port(up);
+
+	if (pdata->iotype) {
+		p->iotype = pdata->iotype;
+		if (p->iotype == UPIO_MEM32) {
+			p->serial_in = dw8250_serial_in32;
+			p->serial_out = dw8250_serial_out32;
+		}
+	}
+
+	if (pdata->regshift)
+		p->regshift = pdata->regshift;
+
+	p->set_termios = dw8250_set_termios;
+
+	up->dma = &data->dma;
+
+	if (pdata->dma_mapbase)
+		up->dma->mapbase = pdata->dma_mapbase;
+
+	if (pdata->private_data)
+		priv = pdata->private_data;
+	else
+		goto probe_mfd_dev_done;
+
+	if (priv->port.fifosize > 0)
+		p->fifosize = priv->port.fifosize;
+
+	if (priv->tx_loadsz > 0)
+		up->tx_loadsz = priv->tx_loadsz;
+	else
+		up->tx_loadsz = p->fifosize;
+
+	/* Override capabilities if found */
+	if (priv->capabilities > 0)
+		up->capabilities = priv->capabilities;
+
+	/* Override DMA structure if found */
+	if (priv->dma)
+		_dw8250_mfd_dma_probe(up, priv);
+
+probe_mfd_dev_done:
+	return 0;
+}
+
 static int dw8250_probe(struct platform_device *pdev)
 {
 	struct uart_8250_port uart = {};
@@ -436,6 +543,10 @@ static int dw8250_probe(struct platform_device *pdev)
 		err = dw8250_probe_acpi(&uart, data);
 		if (err)
 			return err;
+	} else if (strcmp((pdev->dev.type)->name, "mfd_device") == 0) {
+		err = dw8250_probe_mfd_dev(pdev, &uart, data);
+		if (err)
+			return err;
 	} else {
 		return -ENODEV;
 	}
-- 
1.7.5.4

