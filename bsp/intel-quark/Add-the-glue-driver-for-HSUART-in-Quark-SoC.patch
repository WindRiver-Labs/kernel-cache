From c5b4c468a081869ce8f4c3b2a577ddd6b7e86778 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Thu, 1 Jan 2015 10:44:43 +0800
Subject: [PATCH 04/31] Add the glue driver for HSUART in Quark SoC.

source: Intel vendor drop 1.1.0-rc2

The role of this driver is spliting the 2 UART and DMA devices in orderly
manner for their respective drivers, corresponding to 8250_dw and dw_dmac.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/mfd/Kconfig                  |   10 +
 drivers/mfd/Makefile                 |    1 +
 drivers/mfd/intel_quark_hsuart_dma.c |  482 ++++++++++++++++++++++++++++++++++
 include/linux/dw_dmac.h              |    2 +
 include/linux/serial_8250.h          |   32 +++-
 5 files changed, 526 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mfd/intel_quark_hsuart_dma.c

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index d54e985..5004c29 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -349,6 +349,16 @@ config MFD_MAX8998
 	  additional drivers must be enabled in order to use the functionality
 	  of the device.
 
+config MFD_INTEL_QUARK_HSUART_DMA
+	tristate "Intel Quark MFD for High Speed UART with DMA Engine"
+	depends on PCI
+	select MFD_CORE
+	help
+	  This MFD supports High Speed UART PCI device with its DMA engine
+	  companion in Intel Quark product series such as Intel Quark X1000.
+	  Its role is spliting the 2 devices in orderly manner for their
+	  respective driver.
+
 config EZX_PCAP
 	bool "Motorola EZXPCAP Support"
 	depends on GENERIC_HARDIRQS && SPI_MASTER
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 718e94a..1020c60 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -155,3 +155,4 @@ obj-$(CONFIG_MFD_LM3533)	+= lm3533-core.o lm3533-ctrlbank.o
 obj-$(CONFIG_VEXPRESS_CONFIG)	+= vexpress-config.o vexpress-sysreg.o
 obj-$(CONFIG_MFD_RETU)		+= retu-mfd.o
 obj-$(CONFIG_MFD_AS3711)	+= as3711.o
+obj-$(CONFIG_MFD_INTEL_QUARK_HSUART_DMA) += intel_quark_hsuart_dma.o
diff --git a/drivers/mfd/intel_quark_hsuart_dma.c b/drivers/mfd/intel_quark_hsuart_dma.c
new file mode 100644
index 0000000..c099173
--- /dev/null
+++ b/drivers/mfd/intel_quark_hsuart_dma.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright(c) 2013,2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/mfd/core.h>
+#include <linux/serial_8250.h>
+#include <linux/dw_dmac.h>
+#include <uapi/linux/serial_reg.h>
+#include <uapi/linux/serial_core.h>
+
+static bool uart1_dma = true;
+module_param(uart1_dma, bool, 0);
+MODULE_PARM_DESC(uart1_dma, "Set UART0 to use DMA");
+
+static bool uart2_dma = true;
+module_param(uart2_dma, bool, 0);
+MODULE_PARM_DESC(uart2_dma, "Set UART1 to use DMA");
+
+/* MFD */
+#define	QUARK_IORESOURCE_MEM			0
+#define	QUARK_IORESOURCE_IRQ			1
+#define	QUARK_MFD_DMA				0
+#define	QUARK_MFD_UART				1
+
+/* HSUART DMA Paired ID */
+#define	INTEL_QUARK_UART1_PAIR_ID		0
+#define	INTEL_QUARK_UART2_PAIR_ID		1
+
+/* Serial */
+#define	TX					0
+#define	RX					1
+#define	INTEL_QUARK_UART_MEM_BAR		0
+
+	/* DMA for Serial */
+#define	INTEL_QUARK_UART1_RX_CH_ID		0
+#define	INTEL_QUARK_UART1_TX_CH_ID		1
+#define	INTEL_QUARK_UART2_RX_CH_ID		0
+#define	INTEL_QUARK_UART2_TX_CH_ID		1
+
+/* DMA */
+#define	INTEL_QUARK_DMA_MEM_BAR			1
+
+/* MISC */
+	/* Intel Quark X1000 HSUART DMA Engine Internal Base Address */
+#define	INTEL_X1000_DMA_MAPBASE			0xFFFFF000
+
+/* PCI ID List */
+#define	PCI_DEVICE_ID_INTEL_QUARK_X1000_UART	0x0936
+
+static const struct pci_device_id intel_quark_hsuart_dma_ids[] = {
+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_QUARK_X1000_UART) },
+	{ /* Sentinel */ },
+};
+
+/*
+ * Multi-Functional Device Section
+ */
+static struct resource mfd_dma_res[] = {
+	[QUARK_IORESOURCE_MEM] = {
+		.start = 0x0,
+		.end = 0x0,
+		.flags = IORESOURCE_MEM,
+	},
+	[QUARK_IORESOURCE_IRQ] = {
+		.start = 0x0,
+		.end = 0x0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mfd_uart_res[] = {
+	[QUARK_IORESOURCE_MEM] = {
+		.start = 0x0,
+		.end = 0x0,
+		.flags = IORESOURCE_MEM,
+	},
+	[QUARK_IORESOURCE_IRQ] = {
+		.start = 0x0,
+		.end = 0x0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct mfd_cell intel_quark_hsuart_dma_cells[] = {
+	[QUARK_MFD_DMA] = {
+		.name = "",
+		.num_resources = ARRAY_SIZE(mfd_dma_res),
+		.resources = mfd_dma_res,
+		.ignore_resource_conflicts = true,
+	},
+	[QUARK_MFD_UART] = {
+		.name = "",
+		.num_resources = ARRAY_SIZE(mfd_uart_res),
+		.resources = mfd_uart_res,
+		.ignore_resource_conflicts = true,
+	},
+};
+
+/*
+ * Serial Sections
+ */
+enum serial8250_pdata_index {
+	INTEL_QUARK_UART1 = 0,
+	INTEL_QUARK_UART2,
+};
+
+static bool intel_quark_uart_dma_filter(struct dma_chan *chan, void *param);
+
+struct serial8250_filter_param {
+	int chan_id;
+	int device_id;
+	int slave_config_id;
+	int slave_config_direction;
+};
+
+static struct serial8250_filter_param intel_quark_filter_param[][2] = {
+	[INTEL_QUARK_UART1] = {
+		[RX] = {
+			.chan_id = INTEL_QUARK_UART1_RX_CH_ID,
+			.device_id = INTEL_QUARK_UART1_PAIR_ID,
+			.slave_config_id = INTEL_QUARK_UART1,
+			.slave_config_direction = RX,
+		},
+		[TX] = {
+			.chan_id = INTEL_QUARK_UART1_TX_CH_ID,
+			.device_id = INTEL_QUARK_UART1_PAIR_ID,
+			.slave_config_id = INTEL_QUARK_UART1,
+			.slave_config_direction = TX,
+		},
+	},
+	[INTEL_QUARK_UART2] = {
+		[RX] = {
+			.chan_id = INTEL_QUARK_UART2_RX_CH_ID,
+			.device_id = INTEL_QUARK_UART2_PAIR_ID,
+			.slave_config_id = INTEL_QUARK_UART2,
+			.slave_config_direction = RX,
+		},
+		[TX] = {
+			.chan_id = INTEL_QUARK_UART2_TX_CH_ID,
+			.device_id = INTEL_QUARK_UART2_PAIR_ID,
+			.slave_config_id = INTEL_QUARK_UART2,
+			.slave_config_direction = TX,
+		},
+	},
+};
+
+static struct dw_dma_slave dma_dws[][2] = {
+	[INTEL_QUARK_UART1] = {
+		[RX] = {
+			.cfg_hi = DWC_CFGH_SRC_PER(INTEL_QUARK_UART1_RX_CH_ID),
+			.cfg_lo = (DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL),
+		},
+		[TX] = {
+			.cfg_hi = DWC_CFGH_DST_PER(INTEL_QUARK_UART1_TX_CH_ID),
+			.cfg_lo = (DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL),
+		},
+	},
+	[INTEL_QUARK_UART2] = {
+		[RX] = {
+			.cfg_hi = DWC_CFGH_SRC_PER(INTEL_QUARK_UART2_RX_CH_ID),
+			.cfg_lo = (DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL),
+		},
+		[TX] = {
+			.cfg_hi = DWC_CFGH_DST_PER(INTEL_QUARK_UART2_TX_CH_ID),
+			.cfg_lo = (DWC_CFGL_HS_DST_POL | DWC_CFGL_HS_SRC_POL),
+		},
+	},
+};
+
+static struct uart_8250_dma serial8250_dma[] = {
+	[INTEL_QUARK_UART1] = {
+		.fn = &intel_quark_uart_dma_filter,
+		.tx_chan_id = INTEL_QUARK_UART1_TX_CH_ID,
+		.rx_chan_id = INTEL_QUARK_UART1_RX_CH_ID,
+		.txconf.slave_id = INTEL_QUARK_UART1_TX_CH_ID,
+		.rxconf.slave_id = INTEL_QUARK_UART1_RX_CH_ID,
+		.txconf.dst_maxburst = 8,
+		.rxconf.src_maxburst = 8,
+		.tx_param = &intel_quark_filter_param[INTEL_QUARK_UART1][TX],
+		.rx_param = &intel_quark_filter_param[INTEL_QUARK_UART1][RX],
+	},
+	[INTEL_QUARK_UART2] = {
+		.fn = &intel_quark_uart_dma_filter,
+		.tx_chan_id = INTEL_QUARK_UART2_TX_CH_ID,
+		.rx_chan_id = INTEL_QUARK_UART2_RX_CH_ID,
+		.txconf.slave_id = INTEL_QUARK_UART2_TX_CH_ID,
+		.rxconf.slave_id = INTEL_QUARK_UART2_RX_CH_ID,
+		.txconf.dst_maxburst = 8,
+		.rxconf.src_maxburst = 8,
+		.tx_param = &intel_quark_filter_param[INTEL_QUARK_UART2][TX],
+		.rx_param = &intel_quark_filter_param[INTEL_QUARK_UART2][RX],
+	},
+};
+
+static struct uart_8250_port serial8250_port[] = {
+	[INTEL_QUARK_UART1] = {
+		.port.fifosize = 16,
+		.tx_loadsz = 8,
+		.dma = &serial8250_dma[INTEL_QUARK_UART1],
+	},
+	[INTEL_QUARK_UART2] = {
+		.port.fifosize = 16,
+		.tx_loadsz = 8,
+		.dma = &serial8250_dma[INTEL_QUARK_UART2],
+	},
+};
+
+static struct plat_serial8250_port serial8250_pdata[] = {
+	[INTEL_QUARK_UART1] = {
+		.dma_mapbase = INTEL_X1000_DMA_MAPBASE,
+		.uartclk = 44236800,
+		.iotype = UPIO_MEM32,
+		.regshift = 2,
+		.private_data = &serial8250_port[INTEL_QUARK_UART1],
+	},
+	[INTEL_QUARK_UART2] = {
+		.dma_mapbase = INTEL_X1000_DMA_MAPBASE,
+		.uartclk = 44236800,
+		.iotype = UPIO_MEM32,
+		.regshift = 2,
+		.private_data = &serial8250_port[INTEL_QUARK_UART2],
+	},
+};
+
+static bool intel_quark_uart_dma_filter(struct dma_chan *chan, void *param)
+{
+	struct dw_dma_slave *dws;
+	struct serial8250_filter_param *data;
+
+	if (!param)
+		return false;
+	data = param;
+
+	if (chan->device->dev_id != data->device_id)
+		return false;
+	if (chan->chan_id != data->chan_id)
+		return false;
+
+	dws = &dma_dws[data->slave_config_id][data->slave_config_direction];
+	dws->dma_dev = chan->device->dev;
+	chan->private = dws;
+
+	switch (data->device_id) {
+	case INTEL_QUARK_UART1_PAIR_ID:
+		return uart1_dma;
+	case INTEL_QUARK_UART2_PAIR_ID:
+		return uart2_dma;
+	}
+
+	return true;
+}
+
+
+static int intel_quark_uart_device_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	struct resource *res;
+	void *pdata;
+	struct mfd_cell *cell = &intel_quark_hsuart_dma_cells[QUARK_MFD_UART];
+	int bar = 0, ret = 0;
+
+	switch (id->device) {
+	case PCI_DEVICE_ID_INTEL_QUARK_X1000_UART:
+		cell->name = "dw-apb-uart";
+		bar = INTEL_QUARK_UART_MEM_BAR;
+		if (1 == PCI_FUNC(pdev->devfn)) {
+			cell->id = INTEL_QUARK_UART1_PAIR_ID;
+			pdata = &serial8250_pdata[INTEL_QUARK_UART1];
+		} else if (5 == PCI_FUNC(pdev->devfn)) {
+			cell->id = INTEL_QUARK_UART2_PAIR_ID;
+			pdata = &serial8250_pdata[INTEL_QUARK_UART2];
+		} else {
+			goto uart_error;
+		}
+		cell->platform_data = pdata;
+		cell->pdata_size = sizeof(struct plat_serial8250_port);
+		break;
+	default:
+		goto uart_error;
+	}
+
+	res = &mfd_uart_res[QUARK_IORESOURCE_MEM];
+	res->start = pci_resource_start(pdev, bar);
+	res->end = pci_resource_end(pdev, bar);
+
+	res = &mfd_uart_res[QUARK_IORESOURCE_IRQ];
+	res->start = pdev->irq;
+	res->end = pdev->irq;
+
+	pci_set_master(pdev);
+
+	ret = mfd_add_devices(&pdev->dev, 0, cell, 1, NULL, 0, NULL);
+	if (ret) {
+		pci_clear_master(pdev);
+	}
+
+	return ret;
+
+uart_error:
+	dev_warn(&pdev->dev, "no valid UART device.\n");
+	ret = -ENODEV;
+	return ret;
+}
+
+/*
+ * DMA Sections
+ */
+enum dw_dma_pdata_index {
+	INTEL_QUARK_DMA1 = 0,
+	INTEL_QUARK_DMA2,
+};
+
+static struct dw_dma_platform_data dw_dma_pdata[] = {
+	[INTEL_QUARK_DMA1] = {
+		.nr_channels = 2,
+		.is_private = true,
+		.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
+		.chan_priority = CHAN_PRIORITY_ASCENDING,
+		.block_size = 4095U,
+		.nr_masters = 1,
+		.data_width = {2, 0, 0, 0},
+		.nollp = {true, true,},
+	},
+	[INTEL_QUARK_DMA2] = {
+		.nr_channels = 2,
+		.is_private = true,
+		.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
+		.chan_priority = CHAN_PRIORITY_ASCENDING,
+		.block_size = 4095U,
+		.nr_masters = 1,
+		.data_width = {2, 0, 0, 0},
+		.nollp = {true, true, },
+	},
+};
+
+static int intel_quark_dma_device_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	struct resource *res;
+	void *pdata;
+	struct mfd_cell *cell = &intel_quark_hsuart_dma_cells[QUARK_MFD_DMA];
+	int bar = 0, ret = 0;
+
+	switch (id->device) {
+	case PCI_DEVICE_ID_INTEL_QUARK_X1000_UART:
+		cell->name = "dw_dmac";
+		bar = INTEL_QUARK_DMA_MEM_BAR;
+		if (1 == PCI_FUNC(pdev->devfn)) {
+			cell->id = INTEL_QUARK_UART1_PAIR_ID;
+			pdata = &dw_dma_pdata[INTEL_QUARK_DMA1];
+		} else if (5 == PCI_FUNC(pdev->devfn)) {
+			cell->id = INTEL_QUARK_UART2_PAIR_ID;
+			pdata = &dw_dma_pdata[INTEL_QUARK_DMA2];
+		} else {
+			goto dma_error;
+		}
+		cell->platform_data = pdata;
+		cell->pdata_size = sizeof(struct dw_dma_platform_data);
+		break;
+	default:
+		goto dma_error;
+	}
+
+	res = &mfd_dma_res[QUARK_IORESOURCE_MEM];
+	res->start = pci_resource_start(pdev, bar);
+	res->end = pci_resource_end(pdev, bar);
+
+	res = &mfd_dma_res[QUARK_IORESOURCE_IRQ];
+	res->start = pdev->irq;
+	res->end = pdev->irq;
+
+	ret = mfd_add_devices(&pdev->dev, 0, cell, 1, NULL, 0, NULL);
+	goto dma_done;
+
+dma_error:
+	dev_warn(&pdev->dev, "no valid DMA device.\n");
+	ret = -ENODEV;
+dma_done:
+	return ret;
+}
+
+/*
+ * Main Section
+ */
+static int intel_quark_hsuart_dma_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	int ret = 0;
+
+	dev_info(&pdev->dev, "found PCI serial controller(ID: %04x:%04x)\n",
+		 pdev->vendor, pdev->device);
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_warn(&pdev->dev, "Failed to enable PCI Device\n");
+		goto probe_error;
+	}
+
+	/* Execute DMA device probe first. I/O can live with/without DMA */
+	ret = intel_quark_dma_device_probe(pdev, id);
+	if (ret)
+		dev_warn(&pdev->dev, "Failed to initialize DMA device\n");
+
+	ret = intel_quark_uart_device_probe(pdev, id);
+	if (ret) {
+		dev_warn(&pdev->dev, "Failed to initialize HSUART device\n");
+		goto probe_disable_device;
+	}
+
+	return ret;
+
+probe_disable_device:
+	mfd_remove_devices(&pdev->dev);
+	pci_disable_device(pdev);
+probe_error:
+	return ret;
+}
+
+static void intel_quark_hsuart_dma_remove(struct pci_dev *pdev)
+{
+	mfd_remove_devices(&pdev->dev);
+	pci_disable_device(pdev);
+}
+
+#ifdef CONFIG_PM
+/*
+ * Quark SoC family does not support ACPI D3_hot, ie the HSUART is
+ * powered off during ACPI S3 state.
+ * UART and DMA context is restored by respectively the tty and dmaengine
+ * subsystems.
+ *
+ * At the PCI level, we need to ensure that bus mastering is enabled, before
+ * IRQs are switched on.
+ */
+static int intel_quark_hsuart_dma_suspend_noirq(struct device *dev)
+{
+	pci_clear_master(to_pci_dev(dev));
+	return 0;
+}
+static int intel_quark_hsuart_dma_resume_noirq(struct device *dev)
+{
+	pci_set_master(to_pci_dev(dev));
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static const struct dev_pm_ops intel_quark_hsuart_dma_pm_ops = {
+#ifdef CONFIG_PM
+	.suspend_noirq = intel_quark_hsuart_dma_suspend_noirq,
+	.resume_noirq = intel_quark_hsuart_dma_resume_noirq,
+#endif
+};
+
+static struct pci_driver intel_quark_hsuart_dma_driver = {
+	.name		= "intel_quark_hsuart_dma",
+	.id_table	= intel_quark_hsuart_dma_ids,
+	.probe		= intel_quark_hsuart_dma_probe,
+	.remove		= intel_quark_hsuart_dma_remove,
+	.driver = {
+		.pm	= &intel_quark_hsuart_dma_pm_ops,
+	},
+};
+
+module_pci_driver(intel_quark_hsuart_dma_driver);
+
+MODULE_AUTHOR("Chew, Kean Ho <kean.ho.chew@intel.com>");
+MODULE_DESCRIPTION("HSUART DMA MFD driver for Intel Quark Series");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/dw_dmac.h b/include/linux/dw_dmac.h
index 481ab23..9ab70d6 100644
--- a/include/linux/dw_dmac.h
+++ b/include/linux/dw_dmac.h
@@ -46,6 +46,7 @@ struct dw_dma_slave {
  *		(0 - 8bits, 1 - 16bits, ..., 5 - 256bits)
  * @sd: slave specific data. Used for configuring channels
  * @sd_count: count of slave data structures passed.
+ * @nollp: specifically mentions no LLP for a channel.
  */
 struct dw_dma_platform_data {
 	unsigned int	nr_channels;
@@ -59,6 +60,7 @@ struct dw_dma_platform_data {
 	unsigned short	block_size;
 	unsigned char	nr_masters;
 	unsigned char	data_width[4];
+	bool		nollp[8];
 };
 
 /* bursts size */
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index af47a8a..312750f 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -13,6 +13,7 @@
 
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
+#include <linux/dmaengine.h>
 
 /*
  * This is the platform device platform_data structure
@@ -21,6 +22,7 @@ struct plat_serial8250_port {
 	unsigned long	iobase;		/* io base address */
 	void __iomem	*membase;	/* ioremap cookie or NULL */
 	resource_size_t	mapbase;	/* resource base */
+	resource_size_t	dma_mapbase;	/* DMA internal resource base */
 	unsigned int	irq;		/* interrupt number */
 	unsigned long	irqflags;	/* request_irq flags */
 	unsigned int	uartclk;	/* UART clock rate */
@@ -59,7 +61,35 @@ enum {
 	PLAT8250_DEV_SM501,
 };
 
-struct uart_8250_dma;
+struct uart_8250_dma {
+	dma_filter_fn		fn;
+	void			*rx_param;
+	void			*tx_param;
+
+	int			rx_chan_id;
+	int			tx_chan_id;
+
+	struct dma_slave_config	rxconf;
+	struct dma_slave_config	txconf;
+
+	struct dma_chan		*rxchan;
+	struct dma_chan		*txchan;
+
+	dma_addr_t		rx_addr;
+	dma_addr_t		tx_addr;
+
+	dma_cookie_t		rx_cookie;
+	dma_cookie_t		tx_cookie;
+
+	void			*rx_buf;
+
+	size_t			rx_size;
+	size_t			tx_size;
+
+	unsigned char		tx_running:1;
+
+	resource_size_t		mapbase;
+};
 
 /*
  * This should be used by drivers which want to register
-- 
1.7.5.4

