From 624e974e83fc7affa940499809506da93e5af870 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Thu, 1 Jan 2015 13:37:38 +0800
Subject: [PATCH 07/31] Implement j1708 driver.

source: Intel vendor drop 1.1.0-rc2

This driver works as SAE J1708 protocol receiver. This driver co-works with
the 8250 uart driver, the chosen uart port will be connected to this driver
once the module is loaded and J1708 device file is opened & started.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/net/can/slcan.c                      |  391 ++++++++----
 drivers/platform/x86/quark/Kconfig           |    9 +
 drivers/platform/x86/quark/Makefile          |    1 +
 drivers/platform/x86/quark/intel_qrk_j1708.c |  868 ++++++++++++++++++++++++++
 drivers/tty/serial/8250/8250_core.c          |  136 ++++-
 include/linux/intel_qrk_j1708.h              |  136 ++++
 include/linux/serial_8250.h                  |   10 +
 7 files changed, 1420 insertions(+), 131 deletions(-)
 create mode 100644 drivers/platform/x86/quark/intel_qrk_j1708.c
 create mode 100644 include/linux/intel_qrk_j1708.h

diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index 06b7e09..4840b76 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -66,41 +66,57 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Oliver Hartkopp <socketcan@hartkopp.net>");
 
 #define SLCAN_MAGIC 0x53CA
+#define MUX_NETDEV_MAX 10
 
-static int maxdev = 10;		/* MAX number of SLCAN channels;
+static int maxchannel = 10;	/* MAX number of SLCAN channels;
 				   This can be overridden with
-				   insmod slcan.ko maxdev=nnn	*/
-module_param(maxdev, int, 0);
-MODULE_PARM_DESC(maxdev, "Maximum number of slcan interfaces");
+				   insmod slcan.ko maxcahnnel=nnn   */
+module_param(maxchannel, int, 0);
+MODULE_PARM_DESC(maxchannel, "Maximum number of slcan channels");
+
+static int muxnetdevs = 2;	/*	MAX number of net devices multiplexed
+					per SLCAN channel;
+					This can be overridden with
+					insmod slcan.ko muxnetdevs=nnn   */
+module_param(muxnetdevs, int, 0);
+MODULE_PARM_DESC(muxnetdevs, "Max number of netdevs muxed per slcan channel");
 
 /* maximum rx buffer len: extended CAN frame with timestamp */
-#define SLC_MTU (sizeof("T1111222281122334455667788EA5F\r")+1)
+#define SLC_MTU (sizeof("0T1111222281122334455667788EA5F\r")+1)
 
-struct slcan {
+struct slcan_channel {
 	int			magic;
 
 	/* Various fields. */
 	struct tty_struct	*tty;		/* ptr to TTY structure	     */
-	struct net_device	*dev;		/* easy for intr handling    */
+	struct net_device	*dev[MUX_NETDEV_MAX];
+	/* easy for intr handling    */
 	spinlock_t		lock;
 
 	/* These are pointers to the malloc()ed frame buffers. */
 	unsigned char		rbuff[SLC_MTU];	/* receiver buffer	     */
 	int			rcount;         /* received chars counter    */
-	unsigned char		xbuff[SLC_MTU];	/* transmitter buffer	     */
-	unsigned char		*xhead;         /* pointer to next XMIT byte */
-	int			xleft;          /* bytes left in XMIT queue  */
 
 	unsigned long		flags;		/* Flag values/ mode etc     */
 #define SLF_INUSE		0		/* Channel in use            */
 #define SLF_ERROR		1               /* Parity, etc. error        */
 };
 
-static struct net_device **slcan_devs;
+struct slcan_dev {
+	struct slcan_channel	*channel;	/* parent slcan channel      */
+	int			addr;
+
+	/* These are pointers to the malloc()ed frame buffers. */
+	unsigned char		xbuff[SLC_MTU];	/* transmitter buffer	     */
+	unsigned char		*xhead;         /* pointer to next XMIT byte */
+	int			xleft;          /* bytes left in XMIT queue  */
+};
+
+static struct slcan_channel **slcan_channels;
 
- /************************************************************************
-  *			SLCAN ENCAPSULATION FORMAT			 *
-  ************************************************************************/
+/************************************************************************
+ *			SLCAN ENCAPSULATION FORMAT			 *
+ ************************************************************************/
 
 /*
  * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended
@@ -133,26 +149,32 @@ static struct net_device **slcan_devs;
  *
  */
 
- /************************************************************************
-  *			STANDARD SLCAN DECAPSULATION			 *
-  ************************************************************************/
+/************************************************************************
+ *			STANDARD SLCAN DECAPSULATION			 *
+ ************************************************************************/
 
 /* Send one completely decapsulated can_frame to the network layer */
-static void slc_bump(struct slcan *sl)
+static void slc_bump(struct slcan_channel *sl)
 {
 	struct sk_buff *skb;
 	struct can_frame cf;
 	int i, dlc_pos, tmp;
 	unsigned long ultmp;
-	char cmd = sl->rbuff[0];
+	int ext_frame, dev_idx;
+
+	char cmd;
+
+	ext_frame = (sl->rbuff[0] >= '0' && sl->rbuff[0] <= '9') ? 1 : 0;
+
+	cmd = sl->rbuff[ext_frame];
 
 	if ((cmd != 't') && (cmd != 'T') && (cmd != 'r') && (cmd != 'R'))
 		return;
 
 	if (cmd & 0x20) /* tiny chars 'r' 't' => standard frame format */
-		dlc_pos = 4; /* dlc position tiiid */
+		dlc_pos = 4 + ext_frame; /* dlc position tiiid */
 	else
-		dlc_pos = 9; /* dlc position Tiiiiiiiid */
+		dlc_pos = 9 + ext_frame; /* dlc position Tiiiiiiiid */
 
 	if (!((sl->rbuff[dlc_pos] >= '0') && (sl->rbuff[dlc_pos] < '9')))
 		return;
@@ -161,7 +183,7 @@ static void slc_bump(struct slcan *sl)
 
 	sl->rbuff[dlc_pos] = 0; /* terminate can_id string */
 
-	if (strict_strtoul(sl->rbuff+1, 16, &ultmp))
+	if (strict_strtoul(sl->rbuff + 1 + ext_frame, 16, &ultmp))
 		return;
 
 	cf.can_id = ultmp;
@@ -190,7 +212,12 @@ static void slc_bump(struct slcan *sl)
 	if (!skb)
 		return;
 
-	skb->dev = sl->dev;
+	dev_idx = ext_frame ? sl->rbuff[0] - '0' : 0;
+
+	if (sl->dev[dev_idx] == NULL)
+		return;
+
+	skb->dev = sl->dev[dev_idx];
 	skb->protocol = htons(ETH_P_CAN);
 	skb->pkt_type = PACKET_BROADCAST;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -202,19 +229,18 @@ static void slc_bump(struct slcan *sl)
 	       &cf, sizeof(struct can_frame));
 	netif_rx_ni(skb);
 
-	sl->dev->stats.rx_packets++;
-	sl->dev->stats.rx_bytes += cf.can_dlc;
+	sl->dev[dev_idx]->stats.rx_packets++;
+	sl->dev[dev_idx]->stats.rx_bytes += cf.can_dlc;
 }
 
 /* parse tty input stream */
-static void slcan_unesc(struct slcan *sl, unsigned char s)
+static void slcan_unesc(struct slcan_channel *sl, unsigned char s)
 {
 
 	if ((s == '\r') || (s == '\a')) { /* CR or BEL ends the pdu */
 		if (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&
-		    (sl->rcount > 4))  {
+		    (sl->rcount > 4))
 			slc_bump(sl);
-		}
 		sl->rcount = 0;
 	} else {
 		if (!test_bit(SLF_ERROR, &sl->flags))  {
@@ -222,41 +248,53 @@ static void slcan_unesc(struct slcan *sl, unsigned char s)
 				sl->rbuff[sl->rcount++] = s;
 				return;
 			} else {
-				sl->dev->stats.rx_over_errors++;
+				sl->dev[0]->stats.rx_over_errors++;
 				set_bit(SLF_ERROR, &sl->flags);
 			}
 		}
 	}
 }
 
- /************************************************************************
-  *			STANDARD SLCAN ENCAPSULATION			 *
-  ************************************************************************/
+/************************************************************************
+ *			STANDARD SLCAN ENCAPSULATION			 *
+ ************************************************************************/
 
 /* Encapsulate one can_frame and stuff into a TTY queue. */
-static void slc_encaps(struct slcan *sl, struct can_frame *cf)
+static void slc_encaps(struct slcan_dev *sl_dev, struct can_frame *cf,
+		       int dev_idx)
 {
 	int actual, idx, i;
-	char cmd;
+	char cmd, if_idx;
 
 	if (cf->can_id & CAN_RTR_FLAG)
 		cmd = 'R'; /* becomes 'r' in standard frame format */
 	else
 		cmd = 'T'; /* becomes 't' in standard frame format */
 
-	if (cf->can_id & CAN_EFF_FLAG)
-		sprintf(sl->xbuff, "%c%08X%d", cmd,
-			cf->can_id & CAN_EFF_MASK, cf->can_dlc);
-	else
-		sprintf(sl->xbuff, "%c%03X%d", cmd | 0x20,
-			cf->can_id & CAN_SFF_MASK, cf->can_dlc);
+	if (muxnetdevs < 2) {
+		if (cf->can_id & CAN_EFF_FLAG)
+			sprintf(sl_dev->xbuff, "%c%08X%d", cmd,
+				cf->can_id & CAN_EFF_MASK, cf->can_dlc);
+		else
+			sprintf(sl_dev->xbuff, "%c%03X%d", cmd | 0x20,
+				cf->can_id & CAN_SFF_MASK, cf->can_dlc);
+	} else {
+		if_idx = dev_idx + '0';
+		if (cf->can_id & CAN_EFF_FLAG)
+			sprintf(sl_dev->xbuff, "%c%c%08X%d", if_idx, cmd,
+				cf->can_id & CAN_EFF_MASK, cf->can_dlc);
+		else
+			sprintf(sl_dev->xbuff, "%c%c%03X%d", if_idx,
+				cmd | 0x20,
+				cf->can_id & CAN_SFF_MASK, cf->can_dlc);
+	}
 
-	idx = strlen(sl->xbuff);
+	idx = strlen(sl_dev->xbuff);
 
 	for (i = 0; i < cf->can_dlc; i++)
-		sprintf(&sl->xbuff[idx + 2*i], "%02X", cf->data[i]);
+		sprintf(&sl_dev->xbuff[idx + 2 * i], "%02X", cf->data[i]);
 
-	strcat(sl->xbuff, "\r"); /* add terminating character */
+	strcat(sl_dev->xbuff, "\r"); /* add terminating character */
 
 	/* Order of next two lines is *very* important.
 	 * When we are sending a little amount of data,
@@ -266,11 +304,15 @@ static void slc_encaps(struct slcan *sl, struct can_frame *cf)
 	 * if we did not request it before write operation.
 	 *       14 Oct 1994  Dmitry Gorodchanin.
 	 */
-	set_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);
-	actual = sl->tty->ops->write(sl->tty, sl->xbuff, strlen(sl->xbuff));
-	sl->xleft = strlen(sl->xbuff) - actual;
-	sl->xhead = sl->xbuff + actual;
-	sl->dev->stats.tx_bytes += cf->can_dlc;
+	set_bit(TTY_DO_WRITE_WAKEUP, &sl_dev->channel->tty->flags);
+	actual = sl_dev->channel->tty->ops->write(sl_dev->channel->tty,
+			sl_dev->xbuff,
+			strlen(sl_dev->xbuff));
+
+	sl_dev->xleft = strlen(sl_dev->xbuff) - actual;
+	sl_dev->xhead = sl_dev->xbuff + actual;
+	sl_dev->channel->dev[dev_idx]->stats.tx_bytes += cf->can_dlc;
+
 }
 
 /*
@@ -279,31 +321,44 @@ static void slc_encaps(struct slcan *sl, struct can_frame *cf)
  */
 static void slcan_write_wakeup(struct tty_struct *tty)
 {
-	int actual;
-	struct slcan *sl = (struct slcan *) tty->disc_data;
+	int actual, i;
+	struct slcan_channel *sl = (struct slcan_channel *) tty->disc_data;
+
+	struct slcan_dev *sl_dev;
 
 	/* First make sure we're connected. */
-	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))
+	if (!sl || sl->magic != SLCAN_MAGIC)
 		return;
 
-	if (sl->xleft <= 0)  {
-		/* Now serial buffer is almost free & we can start
-		 * transmission of another packet */
-		sl->dev->stats.tx_packets++;
-		clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
-		netif_wake_queue(sl->dev);
-		return;
-	}
+	for (i = 0; i < muxnetdevs; i++) {
+
+		if (!netif_running(sl->dev[i]))
+			continue;
 
-	actual = tty->ops->write(tty, sl->xhead, sl->xleft);
-	sl->xleft -= actual;
-	sl->xhead += actual;
+		sl_dev = netdev_priv(sl->dev[i]);
+
+		if (sl_dev->xleft <= 0)  {
+			/* Now serial buffer is almost free & we can start
+			 * transmission of another packet */
+			sl->dev[i]->stats.tx_packets++;
+			clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+			netif_wake_queue(sl->dev[i]);
+			continue;
+		}
+
+		actual = tty->ops->write(tty, sl_dev->xhead, sl_dev->xleft);
+
+		sl_dev->xleft -= actual;
+		sl_dev->xhead += actual;
+	}
 }
 
 /* Send a can_frame to a TTY queue. */
 static netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct slcan *sl = netdev_priv(dev);
+	struct slcan_dev *sl_dev = netdev_priv(dev);
+
+	struct slcan_channel *sl = sl_dev->channel;
 
 	if (skb->len != sizeof(struct can_frame))
 		goto out;
@@ -319,8 +374,9 @@ static netdev_tx_t slc_xmit(struct sk_buff *skb, struct net_device *dev)
 		goto out;
 	}
 
-	netif_stop_queue(sl->dev);
-	slc_encaps(sl, (struct can_frame *) skb->data); /* encaps & send */
+	netif_stop_queue(sl->dev[sl_dev->addr]);
+	slc_encaps(sl_dev, (struct can_frame *) skb->data,
+		   sl_dev->addr); /* encaps & send */
 	spin_unlock(&sl->lock);
 
 out:
@@ -336,7 +392,9 @@ out:
 /* Netdevice UP -> DOWN routine */
 static int slc_close(struct net_device *dev)
 {
-	struct slcan *sl = netdev_priv(dev);
+	struct slcan_dev *sl_dev = netdev_priv(dev);
+
+	struct slcan_channel *sl = sl_dev->channel;
 
 	spin_lock_bh(&sl->lock);
 	if (sl->tty) {
@@ -345,7 +403,7 @@ static int slc_close(struct net_device *dev)
 	}
 	netif_stop_queue(dev);
 	sl->rcount   = 0;
-	sl->xleft    = 0;
+	sl_dev->xleft    = 0;
 	spin_unlock_bh(&sl->lock);
 
 	return 0;
@@ -354,7 +412,9 @@ static int slc_close(struct net_device *dev)
 /* Netdevice DOWN -> UP routine */
 static int slc_open(struct net_device *dev)
 {
-	struct slcan *sl = netdev_priv(dev);
+	struct slcan_dev *sl_dev = netdev_priv(dev);
+
+	struct slcan_channel *sl = sl_dev->channel;
 
 	if (sl->tty == NULL)
 		return -ENODEV;
@@ -367,9 +427,33 @@ static int slc_open(struct net_device *dev)
 /* Hook the destructor so we can free slcan devs at the right point in time */
 static void slc_free_netdev(struct net_device *dev)
 {
-	int i = dev->base_addr;
+	int dev_idx, devs_in_use, i;
+
+	struct slcan_dev *sl_dev = netdev_priv(dev);
+
+	struct slcan_channel *sl = sl_dev->channel;
+
+	dev_idx = sl_dev->addr;
+
 	free_netdev(dev);
-	slcan_devs[i] = NULL;
+
+	sl->dev[dev_idx] = NULL;
+
+	devs_in_use = 0;
+
+	for (i = 0; i < muxnetdevs; i++) {
+		if (sl->dev[i] != 0)
+			devs_in_use++;
+	}
+
+	/* Free slcan_channel when not referencing any netdev. */
+	if (devs_in_use == 0) {
+		for (i = 0; i < maxchannel; i++) {
+			if (sl == slcan_channels[i])
+				slcan_channels[i] = NULL;
+		}
+		kfree(sl);
+	}
 }
 
 static const struct net_device_ops slc_netdev_ops = {
@@ -411,16 +495,19 @@ static void slc_setup(struct net_device *dev)
 static void slcan_receive_buf(struct tty_struct *tty,
 			      const unsigned char *cp, char *fp, int count)
 {
-	struct slcan *sl = (struct slcan *) tty->disc_data;
+	struct slcan_channel *sl = (struct slcan_channel *) tty->disc_data;
 
-	if (!sl || sl->magic != SLCAN_MAGIC || !netif_running(sl->dev))
+	if (!sl || sl->magic != SLCAN_MAGIC)
+		return;
+
+	if (!netif_running(sl->dev[0]))
 		return;
 
 	/* Read the characters out of the buffer */
 	while (count--) {
 		if (fp && *fp++) {
 			if (!test_and_set_bit(SLF_ERROR, &sl->flags))
-				sl->dev->stats.rx_errors++;
+				sl->dev[0]->stats.rx_errors++;
 			cp++;
 			continue;
 		}
@@ -435,55 +522,80 @@ static void slcan_receive_buf(struct tty_struct *tty,
 /* Collect hanged up channels */
 static void slc_sync(void)
 {
-	int i;
-	struct net_device *dev;
-	struct slcan	  *sl;
+	int i, j;
+	struct slcan_channel *sl;
 
-	for (i = 0; i < maxdev; i++) {
-		dev = slcan_devs[i];
-		if (dev == NULL)
+	for (i = 0; i < maxchannel; i++) {
+		sl = slcan_channels[i];
+		if (sl == NULL)
 			break;
 
-		sl = netdev_priv(dev);
 		if (sl->tty)
 			continue;
-		if (dev->flags & IFF_UP)
-			dev_close(dev);
+
+		for (j = 0; j < muxnetdevs; j++) {
+
+			if (sl->dev[i] == NULL)
+				continue;
+
+			if (sl->dev[i]->flags & IFF_UP)
+				dev_close(sl->dev[i]);
+		}
 	}
 }
 
 /* Find a free SLCAN channel, and link in this `tty' line. */
-static struct slcan *slc_alloc(dev_t line)
+static struct slcan_channel *slc_alloc(dev_t line)
 {
-	int i;
+	int i, j;
 	char name[IFNAMSIZ];
 	struct net_device *dev = NULL;
-	struct slcan       *sl;
+	struct slcan_channel *sl;
+	struct slcan_dev *sl_dev;
 
-	for (i = 0; i < maxdev; i++) {
-		dev = slcan_devs[i];
-		if (dev == NULL)
+	for (i = 0; i < maxchannel; i++) {
+		sl = slcan_channels[i];
+		if (sl == NULL)
 			break;
 
 	}
 
 	/* Sorry, too many, all slots in use */
-	if (i >= maxdev)
+	if (i >= maxchannel)
 		return NULL;
 
-	sprintf(name, "slcan%d", i);
-	dev = alloc_netdev(sizeof(*sl), name, slc_setup);
-	if (!dev)
+	sl = kzalloc(sizeof(struct slcan_channel), GFP_KERNEL);
+
+	if (!sl)
 		return NULL;
 
-	dev->base_addr  = i;
-	sl = netdev_priv(dev);
+	for (j = 0; j < MUX_NETDEV_MAX; j++)
+		sl->dev[j] = NULL;
+
+	for (j = 0; j < muxnetdevs; j++) {
+		sprintf(name, "slcan%d", i * muxnetdevs + j);
+
+		dev = alloc_netdev(sizeof(*sl_dev), name, slc_setup);
+		if (!dev) {
+			kfree(sl);
+			return NULL;
+		}
+
+		dev->base_addr  = i * muxnetdevs + j;
+		sl_dev = netdev_priv(dev);
+
+		sl_dev->channel = sl;
+		sl_dev->addr = j;
+		sl_dev->xleft = 0;
+
+		sl->dev[j] = dev;
+	}
 
 	/* Initialize channel control data */
 	sl->magic = SLCAN_MAGIC;
-	sl->dev	= dev;
+
 	spin_lock_init(&sl->lock);
-	slcan_devs[i] = dev;
+	slcan_channels[i] = sl;
 
 	return sl;
 }
@@ -500,8 +612,8 @@ static struct slcan *slc_alloc(dev_t line)
 
 static int slcan_open(struct tty_struct *tty)
 {
-	struct slcan *sl;
-	int err;
+	struct slcan_channel *sl;
+	int err, i;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -525,6 +637,7 @@ static int slcan_open(struct tty_struct *tty)
 	if (sl && sl->magic == SLCAN_MAGIC)
 		goto err_exit;
 
+
 	/* OK.  Find a free SLCAN channel to use. */
 	err = -ENFILE;
 	sl = slc_alloc(tty_devnum(tty));
@@ -537,13 +650,15 @@ static int slcan_open(struct tty_struct *tty)
 	if (!test_bit(SLF_INUSE, &sl->flags)) {
 		/* Perform the low-level SLCAN initialization. */
 		sl->rcount   = 0;
-		sl->xleft    = 0;
 
 		set_bit(SLF_INUSE, &sl->flags);
 
-		err = register_netdevice(sl->dev);
-		if (err)
-			goto err_free_chan;
+		for (i = 0; i < muxnetdevs; i++) {
+
+			err = register_netdevice(sl->dev[i]);
+			if (err)
+				goto err_free_chan;
+		}
 	}
 
 	/* Done.  We have linked the TTY line to a channel. */
@@ -575,7 +690,9 @@ err_exit:
 
 static void slcan_close(struct tty_struct *tty)
 {
-	struct slcan *sl = (struct slcan *) tty->disc_data;
+	int i;
+
+	struct slcan_channel *sl = (struct slcan_channel *) tty->disc_data;
 
 	/* First make sure we're connected. */
 	if (!sl || sl->magic != SLCAN_MAGIC || sl->tty != tty)
@@ -585,7 +702,8 @@ static void slcan_close(struct tty_struct *tty)
 	sl->tty = NULL;
 
 	/* Flush network side */
-	unregister_netdev(sl->dev);
+	for (i = 0; i < muxnetdevs; i++)
+		unregister_netdev(sl->dev[i]);
 	/* This will complete via sl_free_netdev */
 }
 
@@ -599,7 +717,7 @@ static int slcan_hangup(struct tty_struct *tty)
 static int slcan_ioctl(struct tty_struct *tty, struct file *file,
 		       unsigned int cmd, unsigned long arg)
 {
-	struct slcan *sl = (struct slcan *) tty->disc_data;
+	struct slcan_channel *sl = (struct slcan_channel *) tty->disc_data;
 	unsigned int tmp;
 
 	/* First make sure we're connected. */
@@ -608,8 +726,8 @@ static int slcan_ioctl(struct tty_struct *tty, struct file *file,
 
 	switch (cmd) {
 	case SIOCGIFNAME:
-		tmp = strlen(sl->dev->name) + 1;
-		if (copy_to_user((void __user *)arg, sl->dev->name, tmp))
+		tmp = strlen(sl->dev[0]->name) + 1;
+		if (copy_to_user((void __user *)arg, sl->dev[0]->name, tmp))
 			return -EFAULT;
 		return 0;
 
@@ -637,21 +755,32 @@ static int __init slcan_init(void)
 {
 	int status;
 
-	if (maxdev < 4)
-		maxdev = 4; /* Sanity */
+	if (maxchannel < 4)
+		maxchannel = 4; /* Sanity */
+
+	if (muxnetdevs < 1)
+		muxnetdevs = 1;
+
+	if (muxnetdevs > MUX_NETDEV_MAX)
+		muxnetdevs = MUX_NETDEV_MAX;
 
 	printk(banner);
-	printk(KERN_INFO "slcan: %d dynamic interface channels.\n", maxdev);
+	printk(KERN_INFO "slcan: %d dynamic interface channels.\n", maxchannel);
+
+	if (muxnetdevs > 1)
+		printk(KERN_INFO "slcan: xslcan multiplexer enabled ratio %d:1.\n",
+		       muxnetdevs);
 
-	slcan_devs = kzalloc(sizeof(struct net_device *)*maxdev, GFP_KERNEL);
-	if (!slcan_devs)
+	slcan_channels = kzalloc(sizeof(struct slcan_channel *)*maxchannel,
+					GFP_KERNEL);
+	if (!slcan_channels)
 		return -ENOMEM;
 
 	/* Fill in our line protocol discipline, and register it */
 	status = tty_register_ldisc(N_SLCAN, &slc_ldisc);
 	if (status)  {
 		printk(KERN_ERR "slcan: can't register line discipline\n");
-		kfree(slcan_devs);
+		kfree(slcan_channels);
 	}
 	return status;
 }
@@ -659,12 +788,11 @@ static int __init slcan_init(void)
 static void __exit slcan_exit(void)
 {
 	int i;
-	struct net_device *dev;
-	struct slcan *sl;
+	struct slcan_channel *sl;
 	unsigned long timeout = jiffies + HZ;
 	int busy = 0;
 
-	if (slcan_devs == NULL)
+	if (slcan_channels == NULL)
 		return;
 
 	/* First of all: check for active disciplines and hangup them.
@@ -674,11 +802,11 @@ static void __exit slcan_exit(void)
 			msleep_interruptible(100);
 
 		busy = 0;
-		for (i = 0; i < maxdev; i++) {
-			dev = slcan_devs[i];
-			if (!dev)
+		for (i = 0; i < maxchannel; i++) {
+
+			sl = slcan_channels[i];
+			if (!sl)
 				continue;
-			sl = netdev_priv(dev);
 			spin_lock_bh(&sl->lock);
 			if (sl->tty) {
 				busy++;
@@ -691,25 +819,28 @@ static void __exit slcan_exit(void)
 	/* FIXME: hangup is async so we should wait when doing this second
 	   phase */
 
-	for (i = 0; i < maxdev; i++) {
-		dev = slcan_devs[i];
-		if (!dev)
+	for (i = 0; i < maxchannel; i++) {
+		sl = slcan_channels[i];
+		if (!sl)
 			continue;
-		slcan_devs[i] = NULL;
+		slcan_channels[i] = NULL;
 
-		sl = netdev_priv(dev);
 		if (sl->tty) {
 			printk(KERN_ERR "%s: tty discipline still running\n",
-			       dev->name);
+			       sl->dev[i]->name);
 			/* Intentionally leak the control block. */
-			dev->destructor = NULL;
+			sl->dev[i]->destructor = NULL;
 		}
 
-		unregister_netdev(dev);
+		if (sl->dev[i] == NULL)
+			continue;
+
+		for (i = 0; i < muxnetdevs; i++)
+			unregister_netdev(sl->dev[i]);
 	}
 
-	kfree(slcan_devs);
-	slcan_devs = NULL;
+	kfree(slcan_channels);
+	slcan_channels = NULL;
 
 	i = tty_unregister_ldisc(N_SLCAN);
 	if (i)
diff --git a/drivers/platform/x86/quark/Kconfig b/drivers/platform/x86/quark/Kconfig
index 4d7e14e..d30fbf8 100644
--- a/drivers/platform/x86/quark/Kconfig
+++ b/drivers/platform/x86/quark/Kconfig
@@ -38,3 +38,12 @@ config INTEL_QRK_AUDIO_CTRL
 	depends on INTEL_QUARK_X1000_SOC
 	help
 	  Say Y here to enable Quark's audio control driver
+
+config INTEL_QRK_J1708
+	tristate "SAE J1708 receiver driver for Intel Quark platform"
+	depends on SERIAL_8250
+	help
+	  Select to enable Quark's J1708 receiver driver. This driver works
+	  as SAE J1708 protocol receiver. This driver co-works with the 8250
+	  uart driver, the chosen uart port will be connected to this driver
+	  once the module is loaded and J1708 device file is opened & started
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index d08f597..d191d3e 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -12,3 +12,4 @@ obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_test.o
 obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram_test.o
 obj-$(CONFIG_INTEL_QRK_THERMAL)	+= intel_qrk_thermal.o
 obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL) += intel_qrk_audio_ctrl.o
+obj-$(CONFIG_INTEL_QRK_J1708) += intel_qrk_j1708.o
diff --git a/drivers/platform/x86/quark/intel_qrk_j1708.c b/drivers/platform/x86/quark/intel_qrk_j1708.c
new file mode 100644
index 0000000..309365d
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_j1708.c
@@ -0,0 +1,868 @@
+/*
+ * Copyright(c) 2013,2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+/*
+ * J1708 receiver driver for Intel Quark platform
+ *
+ * - J1708 particular definition:
+ *	The J1708 standard is a bus protocol where multiple nodes have access to
+ *	the same bus. A particular feature of the J1708 protocol is related to
+ *	bus access timing. The principle timing constraints are based around max
+ *	time between characters (must be < 2 bits) and the min time between
+ *	messages (always >= 12 bits). The line is considered idle once 10 bit
+ *	time with no transmission has elapsed. J1708 requires 9600 BAUD, so 1
+ *	bit time equals to about 0.104 ms.
+ *
+ * - J1708 solution overview
+ *	(1) Extension of Intel Quark UART driver to support time-stamping(tsc)
+ *	in interrupt handler. Interrupt trigger level sets at 1 character. We
+ *	assume the tsc of interrupt handler representing the arrival time of
+ *	each characters.
+ *	(2) J1708 receive and buffer of the incoming char/tsc in
+ *	j1708_char_ring_buffer.
+ *	(3) J1708 periodicaly(every 4 ms, implemented with a timer) query
+ *	buffered char/tsc and detect J1708 message boundary by comparing the tsc
+ *	gap of two consective characters to the min message gap of 22 bit time
+ *	(2.2 ms, equals to sum of the minimal message gap of 12 bit time + 1
+ *	charater's transmission of 10 bit time).
+ *	(4) After detecting one J1708 message, checks its checksum, message
+ *	length and inter-char violation etc., push correct message into
+ *	j1708_msg_ring_buffer for reader to read.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/serial_core.h>
+#include <linux/math64.h>
+#include <asm/desc.h>
+#include <linux/intel_qrk_j1708.h>
+
+#define MSECS_PER_SEC 1000UL
+
+/* by default two j1708 devices installed in system: e.g. /dev/j1708_0[1] */
+static unsigned int dev_num = 2;
+module_param(dev_num, uint, S_IRUGO);
+
+extern int bind_uart_port_to_j1708(struct uart_port **port, unsigned int idx,
+				   unsigned int j1708_idx, void *push_func);
+extern int unbind_uart_port_to_j1708(struct uart_port *port);
+
+/* max in-char gap (12-bit time) in cpu cycle */
+static u64 max_char_gap_cycle;
+/* min inter-msg gap (22-bit time) in cpu cycle */
+static u64 min_msg_gap_cycle;
+
+static struct class *j1708_class;
+
+struct j1708_device {
+	unsigned int uart_idx;
+	struct uart_port *up;
+
+	int max_msg_size;
+
+	enum j1708_dev_state dev_state;
+	int ref_cnt;
+	dev_t dev_id;
+	struct cdev cdev;
+	struct device *dev;
+
+	struct mutex mutex;
+	wait_queue_head_t read_wait;
+
+	struct j1708_stats stats;
+
+	/* data path: char_rb -> mid_char_rb -> msg_rb */
+	struct j1708_msg_ring_buffer *msg_rb;
+	struct j1708_char_ring_buffer *char_rb;
+	struct j1708_mid_char_ring_buffer *mid_char_rb;
+	u64 start_tsc;
+	/* using 4 ms timeout to check message periodically */
+	struct timer_list watchdog_timer;
+
+	/* for debug */
+	int mid_char_rb_overrun;	/* intermediate char ringbuf overrun */
+	int rx_char_rb_overrun;		/* rx char ring buf overrun cnt */
+};
+
+static struct j1708_device *j1708_dev;
+
+static struct j1708_device *lookup_j1708_dev(const dev_t dev_id,
+					     unsigned int *idx)
+{
+	unsigned int i = 0;
+
+	BUG_ON(idx == NULL);
+
+	for (i = 0; i < dev_num; i++) {
+		if (j1708_dev[i].dev_id == dev_id) {
+			*idx = i;
+			return &j1708_dev[i];
+		}
+	}
+
+	return NULL;
+}
+
+static bool j1708_chksum_passed(u8 mid, u8 *buf, int buf_len)
+{
+	int sum = 0;
+	int i;
+
+	for (i = 0; i < buf_len; i++)
+		sum += buf[i];
+	sum += mid;
+	sum &= 0xff;
+
+	return (sum == 0) ? true : false;
+}
+
+static bool char_timeout_detected(u64 pre_tsc, u64 post_tsc)
+{
+	u64 cycles = 0;
+
+	BUG_ON(post_tsc < pre_tsc);
+	cycles = post_tsc - pre_tsc;
+
+	return (cycles > max_char_gap_cycle) ? true : false;
+}
+
+static bool message_gap_detected(u64 pre_tsc, u64 post_tsc)
+{
+	u64 cycles = 0;
+
+	BUG_ON(post_tsc < pre_tsc);
+	cycles = post_tsc - pre_tsc;
+
+	return (cycles > min_msg_gap_cycle) ? true : false;
+}
+
+/*
+ * migrate char/tsc from char_rb to mid_char_rb
+ */
+static void pop_from_char_buffer(struct j1708_device *pdev, u64 *pop_tsc)
+{
+	unsigned long flags;
+	u64 tsc = 0;
+	int i = 0;
+
+	spin_lock_irqsave(&pdev->char_rb->lock, flags);
+
+	rdtscll(tsc);
+	*pop_tsc = tsc;
+
+	/* if char_rb->cnt == 0, represents line idle */
+	for (i = 0; i < pdev->char_rb->cnt; i++) {
+		pdev->mid_char_rb->data[pdev->mid_char_rb->head] =
+		    pdev->char_rb->data[pdev->char_rb->tail];
+		pdev->mid_char_rb->tsc[pdev->mid_char_rb->head] =
+		    pdev->char_rb->tsc[pdev->char_rb->tail];
+
+		pdev->char_rb->tail = (pdev->char_rb->tail + 1) & CBUF_MASK;
+		pdev->mid_char_rb->head =
+		    (pdev->mid_char_rb->head + 1) & MID_CBUF_MASK;
+
+		if (pdev->mid_char_rb->cnt == MAX_J1708_MID_CHAR_BUF_SIZE) {
+			pdev->mid_char_rb->tail =
+			    (pdev->mid_char_rb->tail + 1) & MID_CBUF_MASK;
+			pdev->mid_char_rb_overrun++;
+		} else {
+			pdev->mid_char_rb->cnt++;
+		}
+	}
+
+	pdev->char_rb->cnt = 0;
+	BUG_ON(pdev->char_rb->head != pdev->char_rb->tail);
+
+	spin_unlock_irqrestore(&pdev->char_rb->lock, flags);
+}
+
+static void process_one_message(struct j1708_device *pdev, u32 msg_len,
+				u32 pos_lo, u32 pos_hi, bool cgap_exceed)
+{
+	struct j1708_msg_entry msg;
+	int i;
+
+	BUG_ON(pdev == NULL);
+
+	/* msg_len including mid, data and chksum */
+	/* check max message length including chksum, the msg_len should >= 2 */
+	if (msg_len > pdev->max_msg_size || msg_len < 2) {
+		/* discard this message */
+		pdev->stats.j1708_error_cnt++;
+		return;
+	}
+
+	BUG_ON(((pos_lo + msg_len - 1) & MID_CBUF_MASK) != pos_hi);
+
+	msg.length = msg_len - 1;
+	msg.mid = pdev->mid_char_rb->data[pos_lo];
+	msg.char_gap_exceed = cgap_exceed;
+
+	for (i = 0; i < msg_len; i++) {
+		/* include MID + chksum */
+		msg.tsc[i] =
+		    pdev->mid_char_rb->tsc[(pos_lo + i) & MID_CBUF_MASK];
+	}
+
+	for (i = 0; i < msg_len - 1; i++) {
+		/* exclude MID */
+		msg.data[i] = pdev->mid_char_rb->data[(pos_lo + i + 1) &
+						      MID_CBUF_MASK];
+	}
+
+	if (!j1708_chksum_passed(msg.mid, msg.data, (msg_len - 1))) {
+		/* discard this message */
+		pdev->stats.j1708_error_cnt++;
+		return;
+	}
+
+	if (cgap_exceed) {
+		/* NOT abandon this message */
+		pdev->stats.j1708_warn_cnt++;
+	}
+
+	spin_lock(&pdev->msg_rb->lock);
+	pdev->msg_rb->msg[pdev->msg_rb->head] = msg;
+	pdev->msg_rb->head = ((pdev->msg_rb->head + 1) & MRB_MASK);
+	if (pdev->msg_rb->cnt == MAX_J1708_MSG_ENTRY_NUM) {
+		/* message ring buffer overflow */
+		pdev->msg_rb->tail = (pdev->msg_rb->tail + 1) & MRB_MASK;
+
+		pdev->stats.overrun_msg_cnt++;
+	} else {
+		pdev->msg_rb->cnt++;
+	}
+
+	pdev->stats.total_msg_cnt++;
+	pdev->stats.buf_msg_cnt = pdev->msg_rb->cnt;
+
+	spin_unlock(&pdev->msg_rb->lock);
+
+	if (waitqueue_active(&pdev->read_wait))
+		wake_up_interruptible(&pdev->read_wait);
+}
+
+static void watchdog_timeout_handler(unsigned long data)
+{
+	u32 msg_hi_pos;		/* last char position of a message */
+	u32 msg_lo_pos;		/* 1st char position of a message */
+	u32 cur_pos, next_pos;
+	u64 cur_tsc, next_tsc;
+	u32 msg_len;
+	bool char_gap_exceed;
+
+	int cnt;
+	u64 pop_tsc;
+
+	struct j1708_device *pdev = (struct j1708_device *)data;
+
+	pop_from_char_buffer(pdev, &pop_tsc);
+	cnt = pdev->mid_char_rb->cnt;
+
+	BUG_ON(pdev->dev_state != J1708_STATE_START_BUS_UNSYNC &&
+	       pdev->dev_state != J1708_STATE_START_BUS_SYNC);
+
+	if (cnt == 0) {
+		/*
+		 * if line idle time(from device starting) exceeds the min msg
+		 * gap, update status to bus_synced
+		 */
+		if ((pdev->dev_state == J1708_STATE_START_BUS_UNSYNC) &&
+		    message_gap_detected(pdev->start_tsc, pop_tsc)) {
+			pdev->dev_state = J1708_STATE_START_BUS_SYNC;
+		}
+		goto restart_timer;
+	}
+
+	/*
+	 * if the interval(from device starting to the 1st char) > min_msg_gap,
+	 * update status to bus_synced
+	 */
+	if ((pdev->dev_state == J1708_STATE_START_BUS_UNSYNC) &&
+	    message_gap_detected(pdev->start_tsc,
+				 pdev->mid_char_rb->
+					tsc[pdev->mid_char_rb->tail])) {
+		pdev->dev_state = J1708_STATE_START_BUS_SYNC;
+	}
+
+	/* detect and extract j1708 messages from mid_char_rb */
+	msg_lo_pos = pdev->mid_char_rb->tail;
+	cur_pos = pdev->mid_char_rb->tail;
+	msg_len = 0;
+	char_gap_exceed = false;
+	while (cnt) {
+		msg_len++;
+		cur_tsc = pdev->mid_char_rb->tsc[cur_pos];
+		next_pos = (cur_pos + 1) & MID_CBUF_MASK;
+		next_tsc =
+		    (cnt == 1) ? pop_tsc : pdev->mid_char_rb->tsc[next_pos];
+
+		if (message_gap_detected(cur_tsc, next_tsc)) {
+			/*
+			 * last char position: it is correct that
+			 * hi_pos < lo_pos since this is a ring
+			 */
+			msg_hi_pos = cur_pos;
+
+			if (pdev->dev_state == J1708_STATE_START_BUS_UNSYNC) {
+				/* discard 1st possibly incompleted message*/
+				pdev->dev_state = J1708_STATE_START_BUS_SYNC;
+			} else {
+				process_one_message(pdev, msg_len, msg_lo_pos,
+						    msg_hi_pos,
+						    char_gap_exceed);
+			}
+
+			/* remove message's char/tsc from mid_char_rb */
+			pdev->mid_char_rb->cnt -= msg_len;
+			pdev->mid_char_rb->tail =
+			    (pdev->mid_char_rb->tail + msg_len) & MID_CBUF_MASK;
+
+			if (!pdev->mid_char_rb->cnt) {
+				BUG_ON(pdev->mid_char_rb->tail !=
+				       pdev->mid_char_rb->head);
+			}
+
+			/* reset for next message */
+			msg_lo_pos = pdev->mid_char_rb->tail;
+			char_gap_exceed = false;
+			msg_len = 0;
+		} else {
+			if (char_timeout_detected(cur_tsc, next_tsc))
+				char_gap_exceed = true;
+		}
+
+		cnt--;
+		cur_pos = (cur_pos + 1) & MID_CBUF_MASK;
+	}
+
+ restart_timer:
+	mod_timer(&pdev->watchdog_timer,
+		  jiffies + msecs_to_jiffies(TIMEOUT_IN_MS));
+}
+
+static void j1708_char_buffer_push(unsigned int j1708_idx, unsigned char ch,
+				   u64 tsc, bool uart_err)
+{
+	struct j1708_device *pdev;
+	unsigned long flags;
+
+	BUG_ON(j1708_idx >= dev_num);
+	pdev = &j1708_dev[j1708_idx];
+	if (uart_err) {
+		pdev->stats.uart_error_cnt++;
+		return;
+	}
+
+	spin_lock_irqsave(&pdev->char_rb->lock, flags);
+	pdev->char_rb->data[pdev->char_rb->head] = ch;
+	pdev->char_rb->tsc[pdev->char_rb->head] = tsc;
+	pdev->char_rb->head = (pdev->char_rb->head + 1) & CBUF_MASK;
+
+	if (pdev->char_rb->cnt == MAX_J1708_CHAR_BUF_SIZE) {
+		pdev->char_rb->tail = (pdev->char_rb->tail + 1) & CBUF_MASK;
+		pdev->rx_char_rb_overrun++;
+	} else {
+		pdev->char_rb->cnt++;
+	}
+	spin_unlock_irqrestore(&pdev->char_rb->lock, flags);
+}
+
+static int j1708_open(struct inode *inode, struct file *filp)
+{
+	unsigned int j1708_idx = 0;
+	int ret = 0;
+	dev_t dev_id = inode->i_rdev;
+	struct j1708_device *pdev;
+
+	pdev = lookup_j1708_dev(dev_id, &j1708_idx);
+	if (!pdev)
+		return -EINVAL;
+
+	if (filp->f_flags & (~(O_NONBLOCK | O_RDONLY)))
+		return -EINVAL;
+
+	mutex_lock(&pdev->mutex);
+	if (pdev->ref_cnt == 0)
+		pdev->dev_state = J1708_STATE_OPEN;
+	pdev->ref_cnt++;
+	mutex_unlock(&pdev->mutex);
+
+	return ret;
+}
+
+static int j1708_release(struct inode *inode, struct file *filp)
+{
+	unsigned int j1708_idx = 0;
+	int ret = 0;
+	dev_t dev_id = inode->i_rdev;
+	struct j1708_device *pdev;
+	pdev = lookup_j1708_dev(dev_id, &j1708_idx);
+
+	if (!pdev)
+		return -EINVAL;
+
+	mutex_lock(&pdev->mutex);
+
+	if (pdev->ref_cnt == 1) {
+		switch (pdev->dev_state) {
+		case J1708_STATE_OPEN:
+		case J1708_STATE_CLOSE:
+		case J1708_STATE_UART_UNBIND:
+			break;
+		case J1708_STATE_START_BUS_UNSYNC:
+		case J1708_STATE_START_BUS_SYNC:
+			pdev->up->ops->shutdown(pdev->up);
+
+			ret = unbind_uart_port_to_j1708(pdev->up);
+			del_timer_sync(&pdev->watchdog_timer);
+
+			dev_dbg(pdev->dev,
+				"j1708_ioctl_stop: rx_char_rb_overrun[%d] "
+				"mid_char_rb_overrun[%d]\n",
+				pdev->rx_char_rb_overrun,
+				pdev->mid_char_rb_overrun);
+			break;
+		case J1708_STATE_STOP:
+		case J1708_STATE_UART_BIND:
+			ret = unbind_uart_port_to_j1708(pdev->up);
+			break;
+		default:
+			break;
+		}
+		pdev->dev_state = J1708_STATE_CLOSE;
+	}
+
+	if (pdev->ref_cnt > 0)
+		pdev->ref_cnt--;
+	mutex_unlock(&pdev->mutex);
+
+	return ret;
+}
+
+static long j1708_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned int j1708_idx = 0;
+	int ret = 0;
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	dev_t dev_id = inode->i_rdev;
+	struct j1708_device *pdev;
+
+	pdev = lookup_j1708_dev(dev_id, &j1708_idx);
+	if (!pdev)
+		return -EINVAL;
+	BUG_ON(j1708_idx >= dev_num);
+
+	mutex_lock(&pdev->mutex);
+
+	switch (cmd) {
+	case J1708_IOCTL_BIND_UART:
+		if (arg != PORT0 && arg != PORT1) {
+			ret = -EINVAL;
+			goto error;
+		}
+
+		pdev->uart_idx = (unsigned int) arg;
+
+		if ((pdev->dev_state == J1708_STATE_UART_UNBIND) ||
+		    (pdev->dev_state == J1708_STATE_OPEN)) {
+			ret = bind_uart_port_to_j1708(&pdev->up,
+						      pdev->uart_idx,
+						      j1708_idx,
+						      j1708_char_buffer_push);
+			if (!ret)
+				pdev->dev_state = J1708_STATE_UART_BIND;
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+
+	case J1708_IOCTL_UNBIND_UART:
+		if ((pdev->dev_state == J1708_STATE_STOP) ||
+		    (pdev->dev_state == J1708_STATE_UART_BIND)) {
+			ret = unbind_uart_port_to_j1708(pdev->up);
+			if (!ret) {
+				pdev->dev_state = J1708_STATE_UART_UNBIND;
+				pdev->up = NULL;
+			}
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+
+	case J1708_IOCTL_START:
+		if ((pdev->dev_state == J1708_STATE_UART_BIND) ||
+		    (pdev->dev_state == J1708_STATE_STOP)) {
+			memset(&pdev->stats, 0, sizeof(struct j1708_stats));
+
+			pdev->char_rb->cnt = 0;
+			pdev->char_rb->tail = 0;
+			pdev->char_rb->head = 0;
+
+			pdev->mid_char_rb->cnt = 0;
+			pdev->mid_char_rb->tail = 0;
+			pdev->mid_char_rb->head = 0;
+
+			pdev->msg_rb->cnt = 0;
+			pdev->msg_rb->tail = 0;
+			pdev->msg_rb->head = 0;
+
+			pdev->rx_char_rb_overrun = 0;
+			pdev->mid_char_rb_overrun = 0;
+
+			rdtscll(pdev->start_tsc);
+			ret = pdev->up->ops->startup(pdev->up);
+			if (!ret) {
+				pdev->dev_state = J1708_STATE_START_BUS_UNSYNC;
+				mod_timer(&pdev->watchdog_timer,
+					  jiffies +
+					  msecs_to_jiffies(TIMEOUT_IN_MS));
+			}
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+
+	case J1708_IOCTL_STOP:
+		if ((pdev->dev_state == J1708_STATE_START_BUS_UNSYNC) ||
+		    (pdev->dev_state == J1708_STATE_START_BUS_SYNC)) {
+			pdev->up->ops->shutdown(pdev->up);
+			pdev->dev_state = J1708_STATE_STOP;
+			del_timer_sync(&pdev->watchdog_timer);
+
+			dev_dbg(pdev->dev,
+				"j1708_ioctl_stop: rx_char_rb_overrun[%d] "
+				"mid_char_rb_overrun[%d]\n",
+				pdev->rx_char_rb_overrun,
+				pdev->mid_char_rb_overrun);
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+
+	case J1708_IOCTL_RESET:
+		if ((pdev->dev_state == J1708_STATE_START_BUS_UNSYNC) ||
+		    (pdev->dev_state == J1708_STATE_START_BUS_SYNC)) {
+			pdev->up->ops->shutdown(pdev->up);
+
+			memset(&pdev->stats, 0, sizeof(struct j1708_stats));
+
+			pdev->max_msg_size = MAX_J1708_LENGTH;
+
+			pdev->char_rb->cnt = 0;
+			pdev->char_rb->tail = 0;
+			pdev->char_rb->head = 0;
+
+			pdev->mid_char_rb->cnt = 0;
+			pdev->mid_char_rb->tail = 0;
+			pdev->mid_char_rb->head = 0;
+
+			pdev->msg_rb->cnt = 0;
+			pdev->msg_rb->tail = 0;
+			pdev->msg_rb->head = 0;
+
+			dev_dbg(pdev->dev,
+				"j1708_ioctl_stop: rx_char_rb_overrun[%d] "
+				"mid_char_rb_overrun[%d]\n",
+				pdev->rx_char_rb_overrun,
+				pdev->mid_char_rb_overrun);
+
+			pdev->rx_char_rb_overrun = 0;
+			pdev->mid_char_rb_overrun = 0;
+
+			rdtscll(pdev->start_tsc);
+			ret = pdev->up->ops->startup(pdev->up);
+			if (!ret) {
+				pdev->dev_state = J1708_STATE_START_BUS_UNSYNC;
+				mod_timer(&pdev->watchdog_timer,
+					  jiffies +
+					  msecs_to_jiffies(TIMEOUT_IN_MS));
+			}
+		} else {
+			ret = -EINVAL;
+		}
+
+		break;
+
+	case J1708_IOCTL_SET_MSG_LENGTH:
+		if (arg < 2 || arg > MAX_CONFIG_J1708_LENGTH)
+			ret = -EINVAL;
+		pdev->max_msg_size = arg;
+		break;
+
+	case J1708_IOCTL_GET_MSG_LENGTH:
+		put_user(pdev->max_msg_size, (unsigned long *)arg);
+		break;
+
+	case J1708_IOCTL_GET_STAT:
+		pdev->stats.j1708_state = pdev->dev_state;
+
+		if (copy_to_user((struct j1708_stats *)arg, &pdev->stats,
+				 sizeof(struct j1708_stats)))
+			ret = -EFAULT;
+		break;
+
+	case J1708_IOCTL_SET_NONBLOCK:
+		if (arg)
+			filp->f_flags |= O_NONBLOCK;
+		else
+			filp->f_flags &= ~O_NONBLOCK;
+		break;
+
+	case J1708_IOCTL_GET_NONBLOCK:
+		put_user((filp->f_flags & O_NONBLOCK), (unsigned long *)arg);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+ error:
+	mutex_unlock(&pdev->mutex);
+
+	return ret;
+}
+
+static ssize_t j1708_read_one_message(struct file *filp, char __user *buf,
+				      size_t len, loff_t *off)
+{
+	unsigned int j1708_idx = 0;
+	struct j1708_msg_entry *pmsg;
+	struct j1708_device *pdev;
+	ssize_t retval = 0;
+	unsigned long flags = 0;
+
+	struct inode *inode = filp->f_path.dentry->d_inode;
+	dev_t dev_id = inode->i_rdev;
+	pdev = lookup_j1708_dev(dev_id, &j1708_idx);
+	if (!pdev)
+		return -EINVAL;
+
+	if (len != sizeof(struct j1708_msg_entry))
+		return -EINVAL;
+
+	if (filp->f_flags & O_NONBLOCK) {
+		if (!spin_trylock_irq(&pdev->msg_rb->lock))
+			return -EAGAIN;
+	} else {
+		spin_lock_irqsave(&pdev->msg_rb->lock, flags);
+	}
+
+	while (pdev->msg_rb->cnt == 0) {
+		spin_unlock_irqrestore(&pdev->msg_rb->lock, flags);
+
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(pdev->read_wait,
+					     (pdev->msg_rb->cnt > 0)))
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave(&pdev->msg_rb->lock, flags);
+	}
+
+	pmsg = &pdev->msg_rb->msg[pdev->msg_rb->tail];
+	pdev->msg_rb->tail = (pdev->msg_rb->tail + 1) &
+			     (MAX_J1708_MSG_ENTRY_NUM - 1);
+	pdev->msg_rb->cnt--;
+
+	pdev->stats.buf_msg_cnt = pdev->msg_rb->cnt;
+
+	if (copy_to_user(buf, pmsg, sizeof(struct j1708_msg_entry)))
+		retval = -EFAULT;
+	else
+		retval = sizeof(struct j1708_msg_entry);
+
+	spin_unlock_irqrestore(&pdev->msg_rb->lock, flags);
+
+	return retval;
+}
+
+static const struct file_operations j1708_fops = {
+	.owner = THIS_MODULE,
+	.open = j1708_open,
+	.release = j1708_release,
+	.read = j1708_read_one_message,
+	.write = NULL,
+	.unlocked_ioctl = j1708_ioctl
+};
+
+static int one_j1708_device_init(struct j1708_device *pdev,
+				 const unsigned int idx)
+{
+	int ret;
+	struct device *dev_ret;
+
+	pdev->msg_rb =
+	    kzalloc(sizeof(struct j1708_msg_ring_buffer), GFP_KERNEL);
+	if (!pdev->msg_rb) {
+		ret = -ENOMEM;
+		goto tsc_buf_error;
+	}
+
+	pdev->msg_rb->msg =
+	    kzalloc(sizeof(struct j1708_msg_entry) * MAX_J1708_MSG_ENTRY_NUM,
+		    GFP_KERNEL);
+	if (!pdev->msg_rb->msg) {
+		ret = -ENOMEM;
+		goto mrb_error;
+	}
+
+	pdev->char_rb = kzalloc(sizeof(struct j1708_char_ring_buffer),
+				GFP_KERNEL);
+	if (!pdev->char_rb) {
+		ret = -ENOMEM;
+		goto cbuf_error;
+	}
+
+	pdev->mid_char_rb =
+	    kzalloc(sizeof(struct j1708_mid_char_ring_buffer), GFP_KERNEL);
+	if (!pdev->mid_char_rb) {
+		ret = -ENOMEM;
+		goto mid_cbuf_error;
+	}
+
+	ret = alloc_chrdev_region(&pdev->dev_id, 0, 1, "j1708");
+	if (ret < 0)
+		goto chrdev_region_error;
+
+	dev_ret = device_create(j1708_class, NULL, pdev->dev_id, NULL,
+				"j1708_" "%d", idx);
+	if (IS_ERR(dev_ret)) {
+		pr_err("Failed to create j1708 device: %ld\n",
+		       PTR_ERR(dev_ret));
+		ret = PTR_ERR(dev_ret);
+		goto device_error;
+	}
+	pdev->dev = dev_ret;
+
+	cdev_init(&pdev->cdev, &j1708_fops);
+	ret = cdev_add(&pdev->cdev, pdev->dev_id, 1);
+	if (ret != 0) {
+		pr_err("Failed to add cdev for j1708: %d\n", ret);
+		goto cdev_error;
+	}
+
+	spin_lock_init(&pdev->msg_rb->lock);
+	spin_lock_init(&pdev->char_rb->lock);
+
+	pdev->max_msg_size = MAX_J1708_LENGTH;
+	memset(&pdev->stats, 0, sizeof(struct j1708_stats));
+
+	mutex_init(&pdev->mutex);
+	init_waitqueue_head(&pdev->read_wait);
+
+	init_timer(&pdev->watchdog_timer);
+	pdev->watchdog_timer.function = watchdog_timeout_handler;
+	pdev->watchdog_timer.data = (unsigned long) pdev;
+
+	dev_info(dev_ret, "Intel Quark J1708 node %u init\n", idx);
+
+	return 0;
+
+ cdev_error:
+	device_destroy(j1708_class, pdev->dev_id);
+ device_error:
+	unregister_chrdev_region(pdev->dev_id, 1);
+ chrdev_region_error:
+	kfree(pdev->mid_char_rb);
+ mid_cbuf_error:
+	kfree(pdev->char_rb);
+ cbuf_error:
+	kfree(pdev->msg_rb->msg);
+ mrb_error:
+	kfree(pdev->msg_rb);
+ tsc_buf_error:
+	return ret;
+}
+
+static int __init quark_j1708_module_init(void)
+{
+	unsigned int i = 0;
+	int ret = 0;
+	s32 remainder;
+	u64 cpu_hz = 0;
+
+	if (dev_num > 8)
+		return -EINVAL;
+
+	j1708_dev = kzalloc(sizeof(struct j1708_device) * dev_num, GFP_KERNEL);
+	if (!j1708_dev)
+		return -ENOMEM;
+
+	j1708_class = class_create(THIS_MODULE, "j1708");
+	if (IS_ERR(j1708_class)) {
+		pr_err("Failed to create j1708 device class: %ld\n",
+		       PTR_ERR(j1708_class));
+		ret = PTR_ERR(j1708_class);
+		goto class_error;
+	}
+
+	for (i = 0; i < dev_num; i++) {
+		ret = one_j1708_device_init(&j1708_dev[i], i);
+		if (ret != 0)
+			goto init_one_j1708_error;
+	}
+
+	BUG_ON(!cpu_khz);
+	cpu_hz = cpu_khz * MSECS_PER_SEC;
+	max_char_gap_cycle = div_u64_rem(MAX_J1708_CHAR_GAP_BIT_TIME * cpu_hz,
+					 J1708_BAUD, &remainder) + 1;
+
+	min_msg_gap_cycle = div_u64_rem(MIN_J1708_MSG_GAP_BIT_TIME * cpu_hz,
+					J1708_BAUD, &remainder) + 1;
+
+	dev_dbg(j1708_dev[0].dev,
+		"J1708: system-cpu_hz[%lld] max_char_gap_cycle[%lld] "
+		"min_msg_gap_cycle [%lld]\n",
+		cpu_hz, max_char_gap_cycle, min_msg_gap_cycle);
+
+	return 0;
+
+ init_one_j1708_error:
+	class_destroy(j1708_class);
+ class_error:
+	kfree(j1708_dev);
+
+	return ret;
+}
+
+static void one_j1708_device_release(struct j1708_device *pdev)
+{
+	cdev_del(&(pdev->cdev));
+	device_destroy(j1708_class, pdev->dev_id);
+	unregister_chrdev_region(pdev->dev_id, 1);
+
+	kfree(pdev->char_rb);
+	kfree(pdev->mid_char_rb);
+	kfree(pdev->msg_rb->msg);
+	kfree(pdev->msg_rb);
+}
+
+static void __exit quark_j1708_module_exit(void)
+{
+	unsigned int i = 0;
+	for (i = 0; i < dev_num; i++)
+		one_j1708_device_release(&j1708_dev[i]);
+
+	kfree(j1708_dev);
+
+	class_destroy(j1708_class);
+}
+
+module_init(quark_j1708_module_init);
+module_exit(quark_j1708_module_exit);
+
+MODULE_DESCRIPTION("Intel Quark Platform J1708 Driver");
+MODULE_AUTHOR("Wei Lin<wei.w.lin@intel.com>, Xin Zhang<xin.x.zhang@intel.com>");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index d3efbed..14218ab 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -1344,6 +1344,49 @@ static void serial8250_enable_ms(struct uart_port *port)
 }
 
 /*
+ * receive characters and push to j1708 driver
+ */
+static void serial8250_rx_j1708_char(struct uart_8250_port *up,
+					  unsigned char lsr, u64 tsc)
+{
+	 struct uart_port *port = &up->port;
+	 unsigned char ch;
+
+	 BUG_ON(!up->bound_j1708);
+
+	 if (likely(lsr & UART_LSR_DR))
+		  ch = serial_in(up, UART_RX);
+	 else
+		  ch = 0;
+
+	 port->icount.rx++;
+
+	 if (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {
+		  if (lsr & UART_LSR_BI) {
+			   lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+			   port->icount.brk++;
+		  } else if (lsr & UART_LSR_PE) {
+			   port->icount.parity++;
+		  } else if (lsr & UART_LSR_FE) {
+			   port->icount.frame++;
+		  }
+
+		  if (lsr & UART_LSR_OE)
+			   port->icount.overrun++;
+
+		  /*
+		   * Mask off conditions which should be ignored.
+		   */
+		  lsr &= port->read_status_mask;
+
+		  up->j1708_push(up->j1708_idx, 0, tsc, true);
+	 }
+
+	 if (likely(lsr & UART_LSR_DR))
+		  up->j1708_push(up->j1708_idx, ch, tsc, false);
+}
+
+/*
  * serial8250_rx_chars: processes according to the passed in LSR
  * value, and returns the remaining LSR bits not handled
  * by this Rx routine.
@@ -1476,6 +1519,10 @@ unsigned int serial8250_modem_status(struct uart_8250_port *up)
 	struct uart_port *port = &up->port;
 	unsigned int status = serial_in(up, UART_MSR);
 
+	if (up->ier & UART_IER_MSI && up->mcr & UART_MCR_AFE) {
+		status &= ~(UART_MSR_DCTS);
+		status |= UART_MSR_CTS;
+	}
 	status |= up->msr_saved_flags;
 	up->msr_saved_flags = 0;
 	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
@@ -1506,6 +1553,10 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	struct uart_8250_port *up =
 		container_of(port, struct uart_8250_port, port);
 	int dma_err = 0;
+	u64 tsc = 0;
+
+	if (up->bound_j1708)
+		rdtscll(tsc);
 
 	if (iir & UART_IIR_NO_INT)
 		return 0;
@@ -1516,6 +1567,12 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 
 	DEBUG_INTR("status = %x...", status);
 
+	if (up->bound_j1708) {
+		serial8250_rx_j1708_char(up, status, tsc);
+		spin_unlock_irqrestore(&port->lock, flags);
+		return 1;
+	}
+
 	if (status & (UART_LSR_DR | UART_LSR_BI)) {
 		if (up->dma)
 			dma_err = serial8250_rx_dma(up, iir);
@@ -1524,7 +1581,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 			status = serial8250_rx_chars(up, status);
 	}
 	serial8250_modem_status(up);
-	if (!up->dma && (status & UART_LSR_THRE))
+	if (!up->dma && (status & UART_LSR_THRE) && (iir & 0x3f) == UART_IIR_THRI)
 		serial8250_tx_chars(up);
 
 	spin_unlock_irqrestore(&port->lock, flags);
@@ -2164,6 +2221,21 @@ dont_test_tx_en:
 	up->lsr_saved_flags = 0;
 	up->msr_saved_flags = 0;
 
+	if (up->bound_j1708) {
+		serial_port_out(port, UART_LCR, UART_LCR_WLEN8 | UART_LCR_DLAB);
+		serial_dl_write(up, DIV_ROUND_CLOSEST(port->uartclk/16, 9600));
+		serial_port_out(port, UART_LCR, UART_LCR_WLEN8);
+		up->lcr = UART_LCR_WLEN8;
+
+		serial8250_clear_fifos(up);
+		serial_port_out(port, UART_FCR,
+				UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00);
+		uart_update_timeout(port, CS8, 9600);
+
+		up->j1708_store_dma = up->dma;
+		up->dma = NULL;
+	}
+
 	/*
 	 * Request DMA channels for both RX and TX.
 	 */
@@ -2212,6 +2284,11 @@ static void serial8250_shutdown(struct uart_port *port)
 	if (up->dma)
 		serial8250_release_dma(up);
 
+	if (up->bound_j1708 && up->j1708_store_dma) {
+		up->dma = up->j1708_store_dma;
+		up->j1708_store_dma = NULL;
+	}
+
 	spin_lock_irqsave(&port->lock, flags);
 	if (port->flags & UPF_FOURPORT) {
 		/* reset interrupts on the AST Fourport board */
@@ -2519,6 +2596,9 @@ static int serial8250_request_std_resource(struct uart_8250_port *up)
 	struct uart_port *port = &up->port;
 	int ret = 0;
 
+	if (up->bound_j1708)
+		return 0;
+
 	switch (port->iotype) {
 	case UPIO_AU:
 	case UPIO_TSI:
@@ -2555,6 +2635,9 @@ static void serial8250_release_std_resource(struct uart_8250_port *up)
 	unsigned int size = serial8250_port_size(up);
 	struct uart_port *port = &up->port;
 
+	if (up->bound_j1708)
+		return;
+
 	switch (port->iotype) {
 	case UPIO_AU:
 	case UPIO_TSI:
@@ -3411,6 +3494,57 @@ module_exit(serial8250_exit);
 EXPORT_SYMBOL(serial8250_suspend_port);
 EXPORT_SYMBOL(serial8250_resume_port);
 
+/*
+ * unbind 8250_port from tty, instead bind it to j1708
+ */
+int bind_uart_port_to_j1708(struct uart_port **port, unsigned int idx,
+			    unsigned int j1708_idx, void *push_func)
+{
+	struct uart_8250_port *priv;
+	struct uart_port *uport;
+
+	if (idx > UART_NR)
+		return -EINVAL;
+
+	priv = &serial8250_ports[idx];
+	uport = &priv->port;
+
+	priv->j1708_idx = j1708_idx;
+	priv->j1708_push = push_func;
+	priv->bound_j1708 = true;
+
+	/* remove /dev/ttySx to avoid interfere from stty */
+	uart_remove_one_port(&serial8250_reg, uport);
+
+	*port = uport;
+
+	return 0;
+}
+EXPORT_SYMBOL(bind_uart_port_to_j1708);
+
+/*
+ * unbind 8250_port from j1708, re-bind to tty
+ */
+int unbind_uart_port_to_j1708(struct uart_port *uport)
+{
+	int ret = 0;
+	struct uart_8250_port *priv;
+
+	priv = container_of(uport, struct uart_8250_port, port);
+
+	/* recover /dev/ttySx */
+	ret = uart_add_one_port(&serial8250_reg, uport);
+	if (ret < 0)
+		dev_info(uport->dev, "uart register fails %d\n", ret);
+
+	priv->bound_j1708 = false;
+	priv->j1708_push = NULL;
+	priv->j1708_idx  = 255;
+
+	return ret;
+}
+EXPORT_SYMBOL(unbind_uart_port_to_j1708);
+
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Generic 8250/16x50 serial driver");
 
diff --git a/include/linux/intel_qrk_j1708.h b/include/linux/intel_qrk_j1708.h
new file mode 100644
index 0000000..1151ad2
--- /dev/null
+++ b/include/linux/intel_qrk_j1708.h
@@ -0,0 +1,136 @@
+/*
+ * Copyright(c) 2013,2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+/*
+ * Intel Quark J1708 driver
+ */
+
+#ifndef __INTEL_QRK_J1708_H__
+#define __INTEL_QRK_J1708_H__
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/spinlock.h>
+
+#define MAX_J1708_LENGTH	21
+#define MAX_CONFIG_J1708_LENGTH 64
+
+#define PORT0 0
+#define PORT1 1
+
+/* keep as 2^xx */
+#define MAX_J1708_MSG_ENTRY_NUM 2048
+#define MRB_MASK (MAX_J1708_MSG_ENTRY_NUM - 1)
+
+#define MAX_J1708_CHAR_BUF_SIZE 512
+#define CBUF_MASK (MAX_J1708_CHAR_BUF_SIZE - 1)
+
+#define MAX_J1708_MID_CHAR_BUF_SIZE 1024
+#define MID_CBUF_MASK (MAX_J1708_MID_CHAR_BUF_SIZE - 1)
+
+#define J1708_BAUD 9600
+#define ONE_BIT_TIME_NS 104167
+
+/* 12 bits =  2 bits max character gap + 10 bits message data access */
+#define MAX_J1708_CHAR_GAP_BIT_TIME  12
+
+/* 22 bits =  12 bits minimal message gap + 10 bits message data access */
+#define MIN_J1708_MSG_GAP_BIT_TIME  22
+#define MIN_J1708_MSG_GAP_NS (MIN_J1708_MSG_GAP_BIT_TIME * ONE_BIT_TIME_NS)
+
+/* for watchdog_timer timeout set as 4 ms */
+#define TIMEOUT_IN_MS 4
+
+#define J1708_IOCTL_MAGIC 'Z'
+
+#define	J1708_IOCTL_BIND_UART		_IO(J1708_IOCTL_MAGIC, 1)
+#define	J1708_IOCTL_UNBIND_UART		_IO(J1708_IOCTL_MAGIC, 2)
+#define	J1708_IOCTL_START		_IO(J1708_IOCTL_MAGIC, 3)
+#define	J1708_IOCTL_STOP		_IO(J1708_IOCTL_MAGIC, 4)
+#define	J1708_IOCTL_RESET		_IO(J1708_IOCTL_MAGIC, 5)
+#define	J1708_IOCTL_SET_MSG_LENGTH	_IOW(J1708_IOCTL_MAGIC, 6, int)
+#define	J1708_IOCTL_GET_MSG_LENGTH	_IOR(J1708_IOCTL_MAGIC, 7, int)
+#define	J1708_IOCTL_GET_STAT		_IOR(J1708_IOCTL_MAGIC, 8, int)
+#define	J1708_IOCTL_SET_NONBLOCK	_IOW(J1708_IOCTL_MAGIC, 9, int)
+#define	J1708_IOCTL_GET_NONBLOCK	_IOR(J1708_IOCTL_MAGIC, 10, int)
+
+enum j1708_dev_state {
+	J1708_STATE_OPEN               = 0x0,
+	J1708_STATE_UART_BIND          = 0x1,
+	J1708_STATE_UART_UNBIND        = 0x2,
+	J1708_STATE_START_BUS_UNSYNC   = 0x3,
+	J1708_STATE_START_BUS_SYNC     = 0x4,
+	J1708_STATE_STOP               = 0x5,
+	J1708_STATE_CLOSE              = 0x6,
+};
+
+
+/*
+ * J1708 RX message entry
+ */
+struct j1708_msg_entry {
+	u32 length;				/* Msg length including MID */
+	u8  mid;				/* Message Identification */
+	u8  data[MAX_CONFIG_J1708_LENGTH];	/* message data with checksum */
+	u64 tsc[MAX_CONFIG_J1708_LENGTH];	/* timestamp */
+	u8  char_gap_exceed;			/* exceed 2 bit time char gap */
+} __packed;
+
+struct j1708_stats {
+	u32 uart_error_cnt;
+	u32 j1708_error_cnt;           /* excceed msg length + chksum error */
+	u32 j1708_warn_cnt;            /* break the max char gap */
+	u32 buf_msg_cnt;               /* unread message left in ring buffer */
+	u64 total_msg_cnt;             /* total messages received from uart */
+	u32 debug;                     /* TBD */
+	u32 overrun_msg_cnt;           /* msgs discarded due to overflow */
+	enum j1708_dev_state j1708_state; /* J1708 device state */
+} __packed;
+
+/*
+ * j1708 message ring buffer
+ */
+struct j1708_msg_ring_buffer {
+	struct j1708_msg_entry *msg;
+	u32 head;
+	u32 tail;
+	int cnt;
+	spinlock_t lock;
+};
+
+/*
+ * ring buffer for characters/tsc from UART I/O
+ */
+struct j1708_char_ring_buffer {
+	u8  data[MAX_J1708_CHAR_BUF_SIZE];
+	u64 tsc[MAX_J1708_CHAR_BUF_SIZE];
+
+	u32 head;
+	u32 tail;
+	int cnt;
+	spinlock_t lock;
+};
+
+/*
+ * intermidiate ring buffer for char/tsc message boundary detection
+ */
+struct j1708_mid_char_ring_buffer {
+	u8  data[MAX_J1708_MID_CHAR_BUF_SIZE];
+	u64 tsc[MAX_J1708_MID_CHAR_BUF_SIZE];
+
+	u32 head;
+	u32 tail;
+	int cnt;
+};
+
+#endif /* __INTEL_QRK_J1708_H__ */
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 312750f..1db9bdd 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -128,6 +128,16 @@ struct uart_8250_port {
 	/* 8250 specific callbacks */
 	int			(*dl_read)(struct uart_8250_port *);
 	void			(*dl_write)(struct uart_8250_port *, int);
+
+
+	/* quark j1708 driver specific */
+	bool			bound_j1708;
+	unsigned int		j1708_idx;
+	struct uart_8250_dma	*j1708_store_dma;
+	/* push one character and its tsc to J1708 char ring buffer */
+	void			(*j1708_push)(unsigned int j1708_idx,
+					      unsigned char ch, u64 tsc,
+					      bool uart_err);
 };
 
 int serial8250_register_8250_port(struct uart_8250_port *);
-- 
1.7.5.4

