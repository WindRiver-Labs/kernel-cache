From 101754bbb4e544ca9c64ea2ea9c58c42e70ad90e Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 5 Jan 2015 13:02:37 +0800
Subject: [PATCH 14/31] Enable i2c_dw driver for quark.

source: Intel vendor drop 1.1.0-rc2

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/i2c/busses/Kconfig                 |    2 +-
 drivers/i2c/busses/i2c-designware-core.c   |   95 ++++++++++++++++++++++++++--
 drivers/i2c/busses/i2c-designware-core.h   |   10 +++
 drivers/i2c/busses/i2c-designware-pcidrv.c |   20 +++---
 4 files changed, 110 insertions(+), 17 deletions(-)

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 49423e9..989001c 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -412,7 +412,7 @@ config I2C_DESIGNWARE_PLATFORM
 
 config I2C_DESIGNWARE_PCI
 	tristate "Synopsys DesignWare PCI"
-	depends on PCI
+	depends on PCI && !INTEL_QUARK_X1000_SOC
 	select I2C_DESIGNWARE_CORE
 	help
 	  If you say yes to this option, support will be included for the
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index a4dd9bd..9a49890 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -170,6 +170,29 @@ static char *abort_sources[] = {
 		"lost arbitration",
 };
 
+/*
+ * Bitmask for struct i2c_dw_data_cmd's `cmd' field.
+ * - DW_IC_CMD_READ:  read/~write operation
+ * - DW_IC_CMD_STOP:  stop condition generation (only for devices requiring
+ *   explicit transaction termination)
+ * - DW_IC_CMD_RESTART:  (re)start condition generation (only for devices
+ *   requiring explicit transaction termination)
+ */
+#define DW_IC_CMD_READ			0x01
+#define DW_IC_CMD_STOP			0x02
+#define DW_IC_CMD_RESTART		0x04
+
+/*
+ * Define the IC_DATA_CMD format.
+ */
+static union i2c_dw_data_cmd {
+	struct fields {
+		u8 data;
+		u8 cmd;
+	} fields;
+	u16 value;
+} data_cmd;
+
 u32 dw_readl(struct dw_i2c_dev *dev, int offset)
 {
 	u32 value;
@@ -392,6 +415,9 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
 	struct i2c_msg *msgs = dev->msgs;
 	u32 ic_con, ic_tar = 0;
 
+	/* Disable interrupts */
+	i2c_dw_disable_int(dev);
+
 	/* Disable the adapter */
 	__i2c_dw_enable(dev, false);
 
@@ -445,6 +471,7 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 	u32 buf_len = dev->tx_buf_len;
 	u8 *buf = dev->tx_buf;
 	bool need_restart = false;
+	int segment_start = 0;
 
 	intr_mask = DW_IC_INTR_DEFAULT_MASK;
 
@@ -468,6 +495,7 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 			break;
 		}
 
+		segment_start = 0;
 		if (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {
 			/* new i2c_msg */
 			buf = msgs[dev->msg_write_idx].buf;
@@ -480,14 +508,28 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 			if ((dev->master_cfg & DW_IC_CON_RESTART_EN) &&
 					(dev->msg_write_idx > 0))
 				need_restart = true;
+
+			segment_start = 1;
 		}
 
 		tx_limit = dev->tx_fifo_depth - dw_readl(dev, DW_IC_TXFLR);
 		rx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);
 
+		/*
+		 * The maximum number of read requests that can be put into TX
+		 * FIFO depends on the number read operations already pending
+		 * in RX FIFO + the number of outstanding read operations still
+		 * queued in the TX FIFO.
+		 * This prevents RX FIFO overrun.
+		 */
+		rx_limit -= dev->rx_outstanding;
+
 		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
 			u32 cmd = 0;
 
+			data_cmd.fields.data = 0x00;
+			data_cmd.fields.cmd = 0x00;
+
 			/*
 			 * If IC_EMPTYFIFO_HOLD_MASTER_EN is set we must
 			 * manually set the stop bit. However, it cannot be
@@ -509,11 +551,41 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 				if (rx_limit - dev->rx_outstanding <= 0)
 					break;
 
-				dw_writel(dev, cmd | 0x100, DW_IC_DATA_CMD);
+				/* Master-receiver */
+				data_cmd.fields.cmd = DW_IC_CMD_READ;
 				rx_limit--;
 				dev->rx_outstanding++;
-			} else
-				dw_writel(dev, cmd | *buf++, DW_IC_DATA_CMD);
+			} else {
+				/* Master-transmitter */
+				data_cmd.fields.data = *buf;
+				 buf++;
+			}
+
+
+			if (1 == dev->explicit_stop
+			    && 1 == segment_start) {
+				/*
+				 * First byte of a transaction segment for a
+				 * device requiring explicit transaction
+				 * termination: generate (re)start symbol.
+				 */
+				segment_start = 0;
+				data_cmd.fields.cmd |= DW_IC_CMD_RESTART;
+			}
+
+			if (1 == dev->explicit_stop
+			    && dev->msg_write_idx == dev->msgs_num - 1
+			    && 1 == buf_len) {
+				/*
+				 * Last byte of last transction segment for a
+				 * device requiring explicit transaction
+				 * termination: generate stop symbol.
+				 */
+				data_cmd.fields.cmd |= DW_IC_CMD_STOP;
+			}
+
+			dw_writel(dev, data_cmd.value, DW_IC_DATA_CMD);
+
 			tx_limit--; buf_len--;
 		}
 
@@ -732,8 +804,6 @@ static u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)
 		dw_readl(dev, DW_IC_CLR_RX_DONE);
 	if (stat & DW_IC_INTR_ACTIVITY)
 		dw_readl(dev, DW_IC_CLR_ACTIVITY);
-	if (stat & DW_IC_INTR_STOP_DET)
-		dw_readl(dev, DW_IC_CLR_STOP_DET);
 	if (stat & DW_IC_INTR_START_DET)
 		dw_readl(dev, DW_IC_CLR_START_DET);
 	if (stat & DW_IC_INTR_GEN_CALL)
@@ -784,8 +854,21 @@ irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)
 	 * the current transmit status.
 	 */
 
+	/*
+	 * Process stop condition after the last transaction segment is
+	 * transmitted (and received if appropriate).
+	 */
+	if (dev->msgs_num == dev->msg_write_idx
+		&& (DW_IC_INTR_STOP_DET & dw_readl(dev, DW_IC_INTR_STAT))
+		&& 0 == dw_readl(dev, DW_IC_TXFLR)
+		&& 0 == dw_readl(dev, DW_IC_RXFLR)
+		&& 0 == dev->rx_outstanding) {
+			dw_readl(dev, DW_IC_CLR_STOP_DET);
+			complete(&dev->cmd_complete);
+	}
+
 tx_aborted:
-	if ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)
+	if ((stat & (DW_IC_INTR_TX_ABRT)) || dev->msg_err)
 		complete(&dev->cmd_complete);
 
 	return IRQ_HANDLED;
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index e8a7565..9e9d9b5 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -34,6 +34,14 @@
 #define DW_IC_CON_RESTART_EN		0x20
 #define DW_IC_CON_SLAVE_DISABLE		0x40
 
+struct dw_pci_controller {
+	u32 bus_num;
+	u32 bus_cfg;
+	u32 tx_fifo_depth;
+	u32 rx_fifo_depth;
+	u32 clk_khz;
+	u8  explicit_stop;
+};
 
 /**
  * struct dw_i2c_dev - private i2c-designware data
@@ -61,6 +69,7 @@
  * @tx_fifo_depth: depth of the hardware tx fifo
  * @rx_fifo_depth: depth of the hardware rx fifo
  * @rx_outstanding: current master-rx elements in tx fifo
+ * @explicit_stop: set to 1 if hardware requires explicit stop bit transmission
  * @ss_hcnt: standard speed HCNT value
  * @ss_lcnt: standard speed LCNT value
  * @fs_hcnt: fast speed HCNT value
@@ -98,6 +107,7 @@ struct dw_i2c_dev {
 	unsigned int		tx_fifo_depth;
 	unsigned int		rx_fifo_depth;
 	int			rx_outstanding;
+	u8			explicit_stop;
 	u32			sda_hold_time;
 	u16			ss_hcnt;
 	u16			ss_lcnt;
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index 9dec4be..cbbe890 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -66,16 +66,6 @@ struct dw_scl_sda_cfg {
 	u32 sda_hold;
 };
 
-struct dw_pci_controller {
-	u32 bus_num;
-	u32 bus_cfg;
-	u32 tx_fifo_depth;
-	u32 rx_fifo_depth;
-	u32 clk_khz;
-	u32 functionality;
-	struct dw_scl_sda_cfg *scl_sda_cfg;
-};
-
 #define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
 				DW_IC_CON_SLAVE_DISABLE |	\
 				DW_IC_CON_RESTART_EN)
@@ -102,6 +92,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[moorestown_1] = {
 		.bus_num     = 1,
@@ -109,6 +100,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[moorestown_2] = {
 		.bus_num     = 2,
@@ -116,6 +108,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_0] = {
 		.bus_num     = 0,
@@ -123,6 +116,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_1] = {
 		.bus_num     = 1,
@@ -130,6 +124,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_2] = {
 		.bus_num     = 2,
@@ -137,6 +132,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_3] = {
 		.bus_num     = 3,
@@ -144,6 +140,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_4] = {
 		.bus_num     = 4,
@@ -151,6 +148,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_5] = {
 		.bus_num     = 5,
@@ -158,6 +156,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[baytrail] = {
 		.bus_num = -1,
@@ -301,6 +300,7 @@ static int i2c_dw_pci_probe(struct pci_dev *pdev,
 
 	dev->tx_fifo_depth = controller->tx_fifo_depth;
 	dev->rx_fifo_depth = controller->rx_fifo_depth;
+	dev->explicit_stop = controller->explicit_stop;
 	r = i2c_dw_init(dev);
 	if (r)
 		return r;
-- 
1.7.5.4

