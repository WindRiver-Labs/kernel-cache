From 3486ce39ca6e5a269757f7cca8d6da8ad920a4dc Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 5 Jan 2015 16:52:57 +0800
Subject: [PATCH 26/31] Tidy up galileo platform driver.

This platform driver has strong relationship with gpio-sch and gip
drivers. To make sure the dependecies around them, refresh the
register flow to conditionally active the path to get the resource.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 .../platform/x86/quark/intel_qrk_plat_galileo.c    |  102 ++++++++++++++------
 1 files changed, 71 insertions(+), 31 deletions(-)
 mode change 100644 => 100755 drivers/platform/x86/quark/intel_qrk_plat_galileo.c

diff --git a/drivers/platform/x86/quark/intel_qrk_plat_galileo.c b/drivers/platform/x86/quark/intel_qrk_plat_galileo.c
old mode 100644
new mode 100755
index f021208..05bc72d
--- a/drivers/platform/x86/quark/intel_qrk_plat_galileo.c
+++ b/drivers/platform/x86/quark/intel_qrk_plat_galileo.c
@@ -37,7 +37,8 @@
 #include <linux/i2c/at24.h>
 
 #define DRIVER_NAME 		"Galileo"
-#define GPIO_RESTRICT_NAME 	"qrk-gpio-restrict-sc"
+#define GPIO_RESTRICT_NAME_SC 	"qrk-gpio-restrict-sc"
+#define GPIO_RESTRICT_NAME_NC 	"qrk-gpio-restrict-nc"
 #define LPC_SCH_SPINAME		"spi-lpc-sch"
 
 /* GPIO line used to detect the LSB of the Cypress i2c address */
@@ -53,6 +54,9 @@
 #define EEPROM_ADDR_A0_1		0x50
 #define EEPROM_ADDR_A0_0		0x51
 
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
 /******************************************************************************
  *                   Cypress I/O Expander Platform Data
  ******************************************************************************/
@@ -288,36 +292,23 @@ static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
 {
 	int ret = 0;
 	struct i2c_client *cypress = NULL, *eeprom = NULL;
-	static int spi_done;
 	static int gpios_done;
 
-	if (spi_done)
-		goto gpios;
-
-	ret = intel_qrk_spi_add_onboard_devs();
-	if (ret)
-		goto end;
-
-	spi_done = 1;
+	if (!gpios_done) {
+		ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+		if (ret)
+			goto end;
 
-gpios:
-	if (gpios_done)
-		goto i2c;
+		probed_i2c_cypress.irq = gpio_to_irq(GPIO_CYPRESS_INT_S3);
 
-	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
-	if (ret)
-		goto end;
-
-	probed_i2c_cypress.irq = gpio_to_irq(GPIO_CYPRESS_INT_S3);
-
-	gpios_done = 1;
-
-i2c:
+		gpios_done = 1;
+	}
+	
 	i2c_adap = i2c_get_adapter(0);
 	if (NULL == i2c_adap) {
 		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
 			__func__);
-		ret = -EPROBE_DEFER;
+		ret = -ENODEV;
 		goto end;
 	}
 	strlcpy(probed_i2c_cypress.type, "cy8c9540a", I2C_NAME_SIZE);
@@ -331,30 +322,79 @@ i2c:
 	if (NULL == cypress || NULL == eeprom) {
 		pr_err("%s: can't probe Cypress Expander\n", __func__);
 		ret = -ENODEV;
-		goto end;
 	}
-
 end:
 	return ret;
 }
 
-static struct platform_driver gpio_restrict_pdriver = {
+static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	static int spi_done;
+	
+	if (!spi_done) {
+		int ret = intel_qrk_spi_add_onboard_devs();
+		if (ret) {
+			pr_err("%s: can't add on-board spi devices\n", __func__);
+			return ret;
+		}
+
+		spi_done = 1;
+	}
+
+	sc_gpio_reg = 1;
+	if (sc_gpio_reg && nc_gpio_reg)
+		return intel_qrk_gpio_restrict_probe(pdev);
+
+	return 0;
+}
+
+static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	nc_gpio_reg = 1;
+	if (sc_gpio_reg && nc_gpio_reg)
+		return intel_qrk_gpio_restrict_probe(pdev);
+
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
 	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
+		.name	= GPIO_RESTRICT_NAME_SC,
 		.owner	= THIS_MODULE,
 	},
-	.probe		= intel_qrk_gpio_restrict_probe,
+	.probe		= intel_qrk_gpio_restrict_probe_sc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_nc,
 };
 
 static int intel_qrk_plat_galileo_probe(struct platform_device *pdev)
 {
 	int ret = 0;
-
+	
 	/* Assign GIP driver handle for board-specific settings */
 	intel_qrk_gip_get_pdata = galileo_gip_get_pdata;
 
-	/* gpio */
-	ret = platform_driver_register(&gpio_restrict_pdriver);
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+	/* sc gpio */
+	ret = platform_driver_register(&gpio_restrict_pdriver_sc);
+	if (ret)
+		goto end;
+
+	/* nc gpio */
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
 	if (ret)
 		goto end;
 
-- 
1.7.5.4

