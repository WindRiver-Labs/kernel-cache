From b6b221b6010c7bb8020861d241f9734231885a4d Mon Sep 17 00:00:00 2001
From: Bryan Freed <bfreed@chromium.org>
Date: Thu, 25 Oct 2012 00:39:00 +0100
Subject: [PATCH 0966/1187] iio: isl29018: Support suspend and resume.

commit 1e45cf3c493cb76618558201a8ef6f3a065f9073	upstream

The driver leaves the device in power-down state anyway,
so there is nothing to do on suspend.
On resume, we just have to make sure the range and ADC
values are updated in the device since it may have been
powered down in suspend.

Signed-off-by: Bryan Freed <bfreed@chromium.org>
Signed-off-by: Jonathan Cameron <jic23@kernel.org>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/staging/iio/light/isl29018.c |   45 ++++++++++++++++++++++++++++++++++
 1 files changed, 45 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/iio/light/isl29018.c b/drivers/staging/iio/light/isl29018.c
index 6ee5567..3b03f6f 100644
--- a/drivers/staging/iio/light/isl29018.c
+++ b/drivers/staging/iio/light/isl29018.c
@@ -67,6 +67,7 @@ struct isl29018_chip {
 	unsigned int		range;
 	unsigned int		adc_bit;
 	int			prox_scheme;
+	bool			suspended;
 };
 
 static int isl29018_set_range(struct isl29018_chip *chip, unsigned long range,
@@ -368,6 +369,10 @@ static int isl29018_read_raw(struct iio_dev *indio_dev,
 	struct isl29018_chip *chip = iio_priv(indio_dev);
 
 	mutex_lock(&chip->lock);
+	if (chip->suspended) {
+		mutex_unlock(&chip->lock);
+		return -EBUSY;
+	}
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
 	case IIO_CHAN_INFO_PROCESSED:
@@ -561,6 +566,7 @@ static int __devinit isl29018_probe(struct i2c_client *client,
 	chip->lux_scale = 1;
 	chip->range = 1000;
 	chip->adc_bit = 16;
+	chip->suspended = false;
 
 	chip->regmap = devm_regmap_init_i2c(client, &isl29018_regmap_config);
 	if (IS_ERR(chip->regmap)) {
@@ -603,6 +609,44 @@ static int __devexit isl29018_remove(struct i2c_client *client)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int isl29018_suspend(struct device *dev)
+{
+	struct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));
+
+	mutex_lock(&chip->lock);
+
+	/* Since this driver uses only polling commands, we are by default in
+	 * auto shutdown (ie, power-down) mode.
+	 * So we do not have much to do here.
+	 */
+	chip->suspended = true;
+
+	mutex_unlock(&chip->lock);
+	return 0;
+}
+
+static int isl29018_resume(struct device *dev)
+{
+	struct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));
+	int err;
+
+	mutex_lock(&chip->lock);
+
+	err = isl29018_chip_init(chip);
+	if (!err)
+		chip->suspended = false;
+
+	mutex_unlock(&chip->lock);
+	return err;
+}
+
+static SIMPLE_DEV_PM_OPS(isl29018_pm_ops, isl29018_suspend, isl29018_resume);
+#define ISL29018_PM_OPS (&isl29018_pm_ops)
+#else
+#define ISL29018_PM_OPS NULL
+#endif
+
 static const struct i2c_device_id isl29018_id[] = {
 	{"isl29018", 0},
 	{}
@@ -620,6 +664,7 @@ static struct i2c_driver isl29018_driver = {
 	.class	= I2C_CLASS_HWMON,
 	.driver	 = {
 			.name = "isl29018",
+			.pm = ISL29018_PM_OPS,
 			.owner = THIS_MODULE,
 			.of_match_table = isl29018_of_match,
 		    },
-- 
1.7.5.4

