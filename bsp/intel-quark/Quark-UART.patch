From 4d4979a98259a005a1679876ac5e1f6651646e2c Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 24 Dec 2014 14:34:28 +0800
Subject: [PATCH] Quark UART

source: Intel quark BSP release 1.1.0-rc2

Signed-off-by: Kean Ho Chew <kean.ho.chew@intel.com>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/dma/Kconfig                |    6 +-
 drivers/dma/Makefile               |    1 +
 drivers/tty/serial/8250/8250.h     |    7 +
 drivers/tty/serial/8250/8250_dw.c  |  217 +++++++++++++++++++++++++++++++-----
 drivers/tty/serial/8250/8250_pci.c |   52 +++++++++-
 drivers/tty/serial/Kconfig         |   20 ++++
 drivers/tty/serial/Makefile        |    1 +
 include/linux/dw_dmac.h            |    5 +
 include/linux/serial_8250.h        |   11 ++
 9 files changed, 290 insertions(+), 30 deletions(-)

diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index a7687b2..2433e9b 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -36,13 +36,13 @@ comment "DMA Devices"
 source "drivers/dma/xilinx/Kconfig"
 
 config INTEL_MID_DMAC
-	tristate "Intel MID DMA support for Peripheral DMA controllers"
+	tristate "Intel DMAC Moorsetown/Medfield/Quark DMA controllers"
 	depends on PCI && X86
 	select DMA_ENGINE
 	default n
 	help
-	  Enable support for the Intel(R) MID DMA engine present
-	  in Intel MID chipsets.
+	  Enable support for the Intel(R) MID/Quark DMA engine present
+	  in Intel MID chipsets and Quark SOC devices
 
 	  Say Y here if you have such a chipset.
 
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 5517dcd..d153966 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_DMA_OF) += of-dma.o
 
 obj-$(CONFIG_NET_DMA) += iovlock.o
 obj-$(CONFIG_INTEL_MID_DMAC) += intel_mid_dma.o
+intel_mid_dma-objs:= intel_mid_dma_core.o intel_qrk_dma_pci.o intel_mid_dma_pci.o
 obj-$(CONFIG_DMATEST) += dmatest.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index 1ebf853..1818ee6 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -40,6 +40,8 @@ struct uart_8250_dma {
 	size_t			tx_size;
 
 	unsigned char		tx_running:1;
+
+	resource_size_t		mapbase;
 };
 
 struct old_serial_port {
@@ -88,6 +90,11 @@ struct serial8250_config {
 #define SERIAL8250_SHARE_IRQS 0
 #endif
 
+#define PCI_DEVICE_ID_INTEL_BYT_UART1	0x0f0a
+#define PCI_DEVICE_ID_INTEL_BYT_UART2	0x0f0c
+#define LPSS_UART_BYTE_CNT		0x818
+#define LPSS_UART_OVRFLW_INTR_STAT	0x820
+
 static inline int serial_in(struct uart_8250_port *up, int offset)
 {
 	return up->port.serial_in(&up->port, offset);
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 5caf10e..8f56724 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -33,6 +33,10 @@
 
 #include "8250.h"
 
+static bool use_dma = 1;
+module_param(use_dma, bool, 0);
+MODULE_PARM_DESC(use_dma, "use_dma=1 (enable DMA)/use_dma=0(disable DMA)");
+
 /* Offsets for the DesignWare specific registers */
 #define DW_UART_USR	0x1f /* UART Status Register */
 #define DW_UART_CPR	0xf4 /* Component Parameter Register */
@@ -215,16 +219,29 @@ static unsigned int dw8250_serial_in32(struct uart_port *p, int offset)
 	return dw8250_modify_msr(p, offset, value);
 }
 
+static void
+dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
+                  struct ktermios *old)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+
+	/* For Quark, hs-uart is capable of auto flow control */
+	up->capabilities |= UART_CAP_AFE;
+
+	serial8250_do_set_termios(p, termios, old);
+}
+
 static int dw8250_handle_irq(struct uart_port *p)
 {
-	struct dw8250_data *d = p->private_data;
 	unsigned int iir = p->serial_in(p, UART_IIR);
 
 	if (serial8250_handle_irq(p, iir)) {
 		return 1;
 	} else if ((iir & UART_IIR_BUSY) == UART_IIR_BUSY) {
 		/* Clear the USR */
-		(void)p->serial_in(p, d->usr_reg);
+		(void)p->serial_in(p, DW_UART_USR);
+
 		return 1;
 	}
 
@@ -243,14 +260,6 @@ dw8250_do_pm(struct uart_port *port, unsigned int state, unsigned int old)
 		pm_runtime_put_sync_suspend(port->dev);
 }
 
-static bool dw8250_dma_filter(struct dma_chan *chan, void *param)
-{
-	struct dw8250_data *data = param;
-
-	return chan->chan_id == data->dma.tx_chan_id ||
-	       chan->chan_id == data->dma.rx_chan_id;
-}
-
 static void dw8250_setup_port(struct uart_8250_port *up)
 {
 	struct uart_port	*p = &up->port;
@@ -283,6 +292,14 @@ static void dw8250_setup_port(struct uart_8250_port *up)
 		up->capabilities |= UART_CAP_AFE;
 }
 
+static bool dw8250_dma_filter(struct dma_chan *chan, void *param)
+{
+	struct dw8250_data *data = param;
+
+	return chan->chan_id == data->dma.tx_chan_id ||
+		chan->chan_id == data->dma.rx_chan_id;
+}
+
 static int dw8250_probe_of(struct uart_port *p,
 			   struct dw8250_data *data)
 {
@@ -339,12 +356,68 @@ static int dw8250_probe_of(struct uart_port *p,
 }
 
 #ifdef CONFIG_ACPI
+static bool dw8250_acpi_dma_filter(struct dma_chan *chan, void *parm)
+{
+	return chan->chan_id == *(int *)parm;
+}
+
+static acpi_status
+dw8250_acpi_walk_resource(struct acpi_resource *res, void *data)
+{
+	struct uart_port		*p = data;
+	struct uart_8250_port		*port;
+	struct uart_8250_dma		*dma;
+	struct acpi_resource_fixed_dma	*fixed_dma;
+	struct dma_slave_config		*slave;
+
+	port = container_of(p, struct uart_8250_port, port);
+
+	switch (res->type) {
+	case ACPI_RESOURCE_TYPE_FIXED_DMA:
+		fixed_dma = &res->data.fixed_dma;
+
+		/* TX comes first */
+		if (!port->dma) {
+			dma = devm_kzalloc(p->dev, sizeof(*dma), GFP_KERNEL);
+			if (!dma)
+				return AE_NO_MEMORY;
+
+			port->dma = dma;
+			slave = &dma->txconf;
+
+			slave->direction	= DMA_MEM_TO_DEV;
+			slave->dst_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
+			slave->slave_id		= fixed_dma->request_lines;
+			slave->dst_maxburst	= port->tx_loadsz / 4;
+
+			dma->tx_chan_id		= fixed_dma->channels;
+			dma->tx_param		= &dma->tx_chan_id;
+			dma->fn			= dw8250_acpi_dma_filter;
+		} else {
+			dma = port->dma;
+			slave = &dma->rxconf;
+
+			slave->direction	= DMA_DEV_TO_MEM;
+			slave->src_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
+			slave->slave_id		= fixed_dma->request_lines;
+			slave->src_maxburst	= p->fifosize / 4;
+
+			dma->rx_chan_id		= fixed_dma->channels;
+			dma->rx_param		= &dma->rx_chan_id;
+		}
+
+		break;
+	}
+
+	return AE_OK;
+}
+
 static int dw8250_probe_acpi(struct uart_8250_port *up,
 			     struct dw8250_data *data)
 {
 	const struct acpi_device_id *id;
 	struct uart_port *p = &up->port;
-	struct dw8250_acpi_desc *acpi_desc;
+	acpi_status status;
 
 	dw8250_setup_port(up);
 
@@ -355,20 +428,19 @@ static int dw8250_probe_acpi(struct uart_8250_port *up,
 	p->iotype = UPIO_MEM32;
 	p->serial_in = dw8250_serial_in32;
 	p->serial_out = dw8250_serial_out32;
+	p->set_termios = dw8250_set_termios;
 	p->regshift = 2;
-
-	up->dma = &data->dma;
-
-	up->dma->rxconf.src_maxburst = p->fifosize / 4;
-	up->dma->txconf.dst_maxburst = p->fifosize / 4;
-
-	acpi_desc = (struct dw8250_acpi_desc *)id->driver_data;
-	if (!acpi_desc)
-		return 0;
-
-	if (acpi_desc->set_termios)
-		p->set_termios = acpi_desc->set_termios;
-
+	p->uartclk = clk_get_rate(data->clk);
+
+	if (use_dma){
+		status = acpi_walk_resources(ACPI_HANDLE(p->dev), METHOD_NAME__CRS,
+				     dw8250_acpi_walk_resource, p);
+		if (ACPI_FAILURE(status)) {
+			dev_err_ratelimited(p->dev, "%s failed \"%s\"\n", __func__,
+				    acpi_format_exception(status));
+			return -ENODEV;
+		}
+	}
 	return 0;
 }
 #else
@@ -379,6 +451,96 @@ static inline int dw8250_probe_acpi(struct uart_8250_port *up,
 }
 #endif /* CONFIG_ACPI */
 
+static void _dw8250_mfd_dma_probe(struct uart_8250_port *up,
+					struct uart_8250_port *priv)
+{
+	up->dma->rx_chan_id = priv->dma->rx_chan_id;
+	up->dma->tx_chan_id = priv->dma->tx_chan_id;
+
+	if (priv->dma->fn)
+		up->dma->fn = priv->dma->fn;
+
+	if (priv->dma->txconf.dst_maxburst > 0)
+		up->dma->txconf.dst_maxburst = priv->dma->txconf.dst_maxburst;
+
+	if (priv->dma->rxconf.src_maxburst > 0)
+		up->dma->rxconf.src_maxburst = priv->dma->rxconf.src_maxburst;
+
+	if (priv->dma->tx_param)
+		up->dma->tx_param = priv->dma->tx_param;
+
+	if (priv->dma->rx_param)
+		up->dma->rx_param = priv->dma->rx_param;
+
+	return;
+}
+
+static int dw8250_probe_mfd_dev(struct platform_device *pdev,
+				struct uart_8250_port *up,
+				struct dw8250_data *data)
+{
+	struct plat_serial8250_port *pdata;
+	struct uart_8250_port *priv;
+	struct uart_port *p = &up->port;
+
+	/* Bail out if the device doesn't contain platform data */
+	if (NULL == pdev->dev.platform_data) {
+		dev_err(&pdev->dev, "no MFD platform data found!\n");
+		return -ENODEV;
+	}
+	pdata = pdev->dev.platform_data;
+
+	/* Bail out if there is no clock source assignment in platform data */
+	if (0 == pdata->uartclk) {
+		dev_err(&pdev->dev, "no uartclk found.\n");
+		return -ENODEV;
+	}
+	p->uartclk = pdata->uartclk;
+	dw8250_setup_port(up);
+
+	if (pdata->iotype) {
+		p->iotype = pdata->iotype;
+		if (p->iotype == UPIO_MEM32) {
+			p->serial_in = dw8250_serial_in32;
+			p->serial_out = dw8250_serial_out32;
+		}
+	}
+
+	if (pdata->regshift)
+		p->regshift = pdata->regshift;
+
+	p->set_termios = dw8250_set_termios;
+
+	up->dma = &data->dma;
+
+	if (pdata->dma_mapbase)
+		up->dma->mapbase = pdata->dma_mapbase;
+
+	if (pdata->private_data)
+		priv = pdata->private_data;
+	else
+		goto probe_mfd_dev_done;
+
+	if (priv->port.fifosize > 0)
+		p->fifosize = priv->port.fifosize;
+
+	if (priv->tx_loadsz > 0)
+		up->tx_loadsz = priv->tx_loadsz;
+	else
+		up->tx_loadsz = p->fifosize;
+
+	/* Override capabilities if found */
+	if (priv->capabilities > 0)
+		up->capabilities = priv->capabilities;
+
+	/* Override DMA structure if found */
+	if (priv->dma)
+		_dw8250_mfd_dma_probe(up, priv);
+
+probe_mfd_dev_done:
+	return 0;
+}
+
 static int dw8250_probe(struct platform_device *pdev)
 {
 	struct uart_8250_port uart = {};
@@ -436,6 +598,10 @@ static int dw8250_probe(struct platform_device *pdev)
 		err = dw8250_probe_acpi(&uart, data);
 		if (err)
 			return err;
+	} else if (strcmp((pdev->dev.type)->name, "mfd_device") == 0) {
+		err = dw8250_probe_mfd_dev(pdev, &uart, data);
+		if (err)
+			return err;
 	} else {
 		return -ENODEV;
 	}
@@ -446,8 +612,7 @@ static int dw8250_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, data);
 
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
+	pm_runtime_forbid(&pdev->dev);
 
 	return 0;
 }
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index 112b477..c05c3ef 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -27,7 +27,13 @@
 
 #include "8250.h"
 
-#undef SERIAL_DEBUG_PCI
+/* QUARK FPGA */
+#define SERIAL_DEBUG_PCI
+
+/* TODO: Bryan remove ! */
+static unsigned int quark_enable_msi = 0;
+module_param(quark_enable_msi, uint, 0644);
+MODULE_PARM_DESC(quark_enable_msi, "Enable MSI operation on Quark 8250-PCI");
 
 /*
  * init function returns:
@@ -156,6 +162,20 @@ afavlab_setup(struct serial_private *priv, const struct pciserial_board *board,
 }
 
 /*
+ * UART parameters for Intel Quark setup
+ */
+static int
+pci_intel_qrk_setup(struct serial_private *priv,
+		const struct pciserial_board *board,
+		struct uart_8250_port *port, int idx)
+{
+	unsigned int bar, offset = board->first_offset;
+	bar = FL_GET_BASE(board->flags);
+
+	return setup_port(priv, port, bar, offset, board->reg_shift);
+}
+
+/*
  * HP's Remote Management Console.  The Diva chip came in several
  * different versions.  N-class, L2000 and A500 have two Diva chips, each
  * with 3 UARTs (the third UART on the second chip is unused).  Superdome
@@ -1811,6 +1831,14 @@ static struct pci_serial_quirk pci_serial_quirks[] __refdata = {
 		.subdevice	= PCI_ANY_ID,
 		.setup		= byt_serial_setup,
 	},
+	{
+		.vendor		= PCI_VENDOR_ID_INTEL,
+		.device		= 0x0936,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.setup		= pci_intel_qrk_setup,
+	},
+
 	/*
 	 * ITE
 	 */
@@ -2575,6 +2603,8 @@ enum pci_board_num_t {
 	pbn_oxsemi_2_4000000,
 	pbn_oxsemi_4_4000000,
 	pbn_oxsemi_8_4000000,
+	pbn_intel_cb,
+	pbn_intel_qrk,
 	pbn_intel_i960,
 	pbn_sgi_ioc3,
 	pbn_computone_4,
@@ -3162,6 +3192,12 @@ static struct pciserial_board pci_boards[] = {
 		.reg_shift	= 2,
 		.first_offset	= 0x10000,
 	},
+	[pbn_intel_qrk] = {
+		.flags		= FL_BASE0,
+		.num_ports	= 1,
+		.base_baud	= 2764800,
+		.reg_shift	= 2,
+	},
 	[pbn_sgi_ioc3] = {
 		.flags		= FL_BASE0|FL_NOIRQ,
 		.num_ports	= 1,
@@ -3635,6 +3671,14 @@ pciserial_init_one(struct pci_dev *dev, const struct pci_device_id *ent)
 	if (rc)
 		return rc;
 
+	/* TODO: Bryan remove ! */
+	if(quark_enable_msi == 1){
+		if(pci_enable_msi(dev)!=0){
+			printk(KERN_ERR "QUARK/DEBUG unable to enable MSIs on serial port!\n");
+		}
+	}
+
+
 	if (ent->driver_data == pbn_default) {
 		/*
 		 * Use a copy of the pci_board entry for this;
@@ -4514,6 +4558,12 @@ static struct pci_device_id serial_pci_tbl[] = {
 	{	PCI_VENDOR_ID_MORETON, PCI_DEVICE_ID_RASTEL_2PORT,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 		pbn_b2_bt_2_115200 },
+ 	/*
+	 * Quark descriptor
+	 */
+	{	PCI_VENDOR_ID_INTEL, 0x0936,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
+		pbn_intel_qrk },
 
 	/*
 	 * EKF addition for i960 Boards form EKF with serial port
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 7e7006f..4e38f53 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1340,6 +1340,26 @@ config SERIAL_IFX6X60
 	help
 	  Support for the IFX6x60 modem devices on Intel MID platforms.
 
+config SERIAL_QUARK_UART
+	tristate "Quark High Speed UART support"
+	depends on PCI
+	select SERIAL_CORE
+	select DMADEVICES
+	select INTEL_MID_DMAC
+	help
+	  This driver is for Intel(R) Quark X1000 UART with DMA enabled.
+	  If you don't want DMA then you should use the standard 8250_pci
+	  driver.
+
+config SERIAL_QUARK_UART_CONSOLE
+	bool "Support for console on Intel(R) Quark X1000 UART"
+	depends on SERIAL_QUARK_UART=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Say Y here if you wish to use the Quark UART as the system console
+	  (the system  console is the device which receives all kernel messages and
+	  warnings and which allows logins in single user mode).
+
 config SERIAL_PCH_UART
 	tristate "Intel EG20T PCH/LAPIS Semicon IOH(ML7213/ML7223/ML7831) UART"
 	depends on PCI
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index eedfec4..a295867 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -74,6 +74,7 @@ obj-$(CONFIG_SERIAL_VT8500) += vt8500_serial.o
 obj-$(CONFIG_SERIAL_MRST_MAX3110)	+= mrst_max3110.o
 obj-$(CONFIG_SERIAL_MFD_HSU)	+= mfd.o
 obj-$(CONFIG_SERIAL_IFX6X60)  	+= ifx6x60.o
+obj-$(CONFIG_SERIAL_QUARK_UART)	+= intel_quark_uart.o
 obj-$(CONFIG_SERIAL_PCH_UART)	+= pch_uart.o
 obj-$(CONFIG_SERIAL_MSM_SMD)	+= msm_smd_tty.o
 obj-$(CONFIG_SERIAL_MXS_AUART) += mxs-auart.o
diff --git a/include/linux/dw_dmac.h b/include/linux/dw_dmac.h
index 481ab23..1ebf4f9 100644
--- a/include/linux/dw_dmac.h
+++ b/include/linux/dw_dmac.h
@@ -59,6 +59,10 @@ struct dw_dma_platform_data {
 	unsigned short	block_size;
 	unsigned char	nr_masters;
 	unsigned char	data_width[4];
+	bool		is_embedded;
+	struct		dw_dma_slave *sd;
+	unsigned int	sd_count;
+	bool		nollp[8];
 };
 
 /* bursts size */
@@ -110,5 +114,6 @@ void dw_dma_cyclic_stop(struct dma_chan *chan);
 dma_addr_t dw_dma_get_src_addr(struct dma_chan *chan);
 
 dma_addr_t dw_dma_get_dst_addr(struct dma_chan *chan);
+bool dw_dma_generic_filter(struct dma_chan *chan, void *param);
 
 #endif /* DW_DMAC_H */
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index af47a8a..d05ab9b 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -13,6 +13,7 @@
 
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
+#include <linux/dmaengine.h>
 
 /*
  * This is the platform device platform_data structure
@@ -21,6 +22,7 @@ struct plat_serial8250_port {
 	unsigned long	iobase;		/* io base address */
 	void __iomem	*membase;	/* ioremap cookie or NULL */
 	resource_size_t	mapbase;	/* resource base */
+	resource_size_t	dma_mapbase;	/* DMA internal resource base */
 	unsigned int	irq;		/* interrupt number */
 	unsigned long	irqflags;	/* request_irq flags */
 	unsigned int	uartclk;	/* UART clock rate */
@@ -98,6 +100,15 @@ struct uart_8250_port {
 	/* 8250 specific callbacks */
 	int			(*dl_read)(struct uart_8250_port *);
 	void			(*dl_write)(struct uart_8250_port *, int);
+
+	/* quark j1708 driver specific */
+	bool			bound_j1708;
+	unsigned int		j1708_idx;
+	struct uart_8250_dma	*j1708_store_dma;
+	/* push one character and its tsc to J1708 char ring buffer */
+	void			(*j1708_push)(unsigned int j1708_idx,
+					      unsigned char ch, u64 tsc,
+					      bool uart_err);
 };
 
 int serial8250_register_8250_port(struct uart_8250_port *);
-- 
1.7.5.4

