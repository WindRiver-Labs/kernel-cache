From 6f84b64ee31442d9ae83c35bd04e9cc058433fee Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 27 Jan 2014 12:50:22 +0800
Subject: [PATCH 1/2] intel-quark: add iio support for 0.9.0.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/iio/Kconfig                                |    1 +
 drivers/iio/accel/lis331dlh_intel_cln.c            |  206 +++++++++-----
 drivers/iio/adc/max78m6610_lmu.c                   |  276 ++++++++++++++++++
 drivers/iio/common/st_sensors/Kconfig              |   12 +-
 drivers/iio/common/st_sensors/st_sensors_core.c    |   22 +-
 drivers/iio/common/st_sensors/st_sensors_i2c.c     |    1 +
 drivers/iio/common/st_sensors/st_sensors_trigger.c |    3 +-
 drivers/iio/industrialio-buffer.c                  |    6 +-
 drivers/iio/trigger/Kconfig                        |   55 ++++
 drivers/iio/trigger/Makefile                       |    9 +
 drivers/iio/trigger/iio-trig-bfin-timer.c          |  307 ++++++++++++++++++++
 drivers/iio/trigger/iio-trig-bfin-timer.h          |   24 ++
 drivers/iio/trigger/iio-trig-gpio.c                |  167 +++++++++++
 drivers/iio/trigger/iio-trig-hrtimer.c             |  282 ++++++++++++++++++
 drivers/iio/trigger/iio-trig-periodic-rtc.c        |  202 +++++++++++++
 drivers/iio/trigger/iio-trig-sysfs.c               |  227 +++++++++++++++
 include/linux/iio/common/st_sensors.h              |    7 +-
 17 files changed, 1711 insertions(+), 96 deletions(-)
 create mode 100644 drivers/iio/trigger/Kconfig
 create mode 100644 drivers/iio/trigger/Makefile
 create mode 100644 drivers/iio/trigger/iio-trig-bfin-timer.c
 create mode 100644 drivers/iio/trigger/iio-trig-bfin-timer.h
 create mode 100644 drivers/iio/trigger/iio-trig-gpio.c
 create mode 100644 drivers/iio/trigger/iio-trig-hrtimer.c
 create mode 100644 drivers/iio/trigger/iio-trig-periodic-rtc.c
 create mode 100644 drivers/iio/trigger/iio-trig-sysfs.c

diff --git a/drivers/iio/Kconfig b/drivers/iio/Kconfig
index b2f963b..2167ace 100644
--- a/drivers/iio/Kconfig
+++ b/drivers/iio/Kconfig
@@ -70,5 +70,6 @@ source "drivers/iio/gyro/Kconfig"
 source "drivers/iio/imu/Kconfig"
 source "drivers/iio/light/Kconfig"
 source "drivers/iio/magnetometer/Kconfig"
+source "drivers/iio/trigger/Kconfig"
 
 endif # IIO
diff --git a/drivers/iio/accel/lis331dlh_intel_cln.c b/drivers/iio/accel/lis331dlh_intel_cln.c
index 57998d0..c76c30a 100644
--- a/drivers/iio/accel/lis331dlh_intel_cln.c
+++ b/drivers/iio/accel/lis331dlh_intel_cln.c
@@ -35,18 +35,15 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/mutex.h>
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/gpio.h>
-#include <linux/irq.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
-#include <linux/iio/trigger.h>
-#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
 
 #include <linux/iio/common/st_sensors.h>
 #include <linux/iio/common/st_sensors_i2c.h>
@@ -113,8 +110,33 @@
 #define ST_ACCEL_2_INT_CFG_ZHIE_EN		0x20
 
 #define ST_ACCEL_2_MULTIREAD_BIT		true
+#define ST_ACCEL_2_THRESH_VAL_MIN		0x00
+#define ST_ACCEL_2_THRESH_VAL_MAX		0x7f
 #define CLN_ACCEL_INT2_WAKEUP_THRESH_VAL	0x7f
 
+#define CLN_ACCEL_INT1_DISABLED			0
+#define CLN_ACCEL_INT1_ENABLED			1
+
+#define CLN_ACCEL_LSM_CHANNELS(device_type, index, mod, endian, bits, addr) \
+{ \
+	.type = device_type, \
+	.modified = 1, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.scan_index = index, \
+	.channel = mod, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = bits, \
+		.shift = 16 - bits, \
+		.storagebits = 16, \
+		.endianness = endian, \
+	}, \
+	.event_mask = IIO_EV_BIT(IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), \
+}
+
 static const u8 iio_modifier_map[] = {
 	IIO_NO_MOD,
 	IIO_MOD_X,
@@ -169,11 +191,11 @@ static irqreturn_t lis331dlh_intel_cln_threshold_event_handler(
 		iio_modifier = iio_modifier_map[iio_modifier];
 
 		iio_push_event(private,
-				IIO_EVENT_CODE(IIO_ACCEL,
-				0, /* non differential */
+				IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				0,
 				iio_modifier,
 				IIO_EV_TYPE_THRESH,
-				IIO_EV_DIR_RISING, 0, 0, 0),
+				IIO_EV_DIR_RISING),
 				timestamp);
 	}
 
@@ -181,6 +203,27 @@ st_sensors_read_err:
 	return IRQ_HANDLED;
 }
 
+static inline int lis331dlh_intel_cln_read_info_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch, int *val)
+{
+	int err;
+
+	mutex_lock(&indio_dev->mlock);
+	err = st_sensors_read_axis_data(indio_dev, ch->address, val);
+
+	if (unlikely(err < 0))
+		goto read_error;
+
+	*val = *val >> ch->scan_type.shift;
+	mutex_unlock(&indio_dev->mlock);
+
+	return err;
+
+read_error:
+	mutex_unlock(&indio_dev->mlock);
+	return err;
+}
+
 static int lis331dlh_intel_cln_read_raw(
 	struct iio_dev *indio_dev,
 	struct iio_chan_spec const *ch,
@@ -191,8 +234,8 @@ static int lis331dlh_intel_cln_read_raw(
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
-		err = st_sensors_read_info_raw(indio_dev, ch, val);
-		if (err < 0)
+		err = lis331dlh_intel_cln_read_info_raw(indio_dev, ch, val);
+		if (unlikely(err < 0))
 			goto read_error;
 
 		return IIO_VAL_INT;
@@ -226,7 +269,6 @@ static int lis331dlh_intel_cln_write_raw(
 	return err;
 }
 
-
 static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
 static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
 static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
@@ -267,7 +309,8 @@ static int lis331dlh_intel_cln_write_event_value(
 	struct st_sensor_data *sdata;
 
 	/* range check */
-	if ((val < 0) || (val > 0x7f))
+	if (unlikely((val < ST_ACCEL_2_THRESH_VAL_MIN) ||
+				 (val > ST_ACCEL_2_THRESH_VAL_MAX)))
 		return -EINVAL;
 
 	sdata = iio_priv(indio_dev);
@@ -276,36 +319,36 @@ static int lis331dlh_intel_cln_write_event_value(
 				ST_ACCEL_2_INT1_THRESH_ADDR, val);
 
 	return err;
-
 }
 
 /*  Configure the INT1 pin to fire an interrupt on a high threshold event.
  */
 static int lis331dlh_intel_cln_configure_threshold_interrupt(
-	struct iio_dev *indio_dev, bool state)
+	struct iio_dev *indio_dev, u8 state)
 {
 	int err = 0;
 	struct st_sensor_data *sdata = iio_priv(indio_dev);
 
-	if (sdata->int_thresh == state)
+	if (sdata->sensor->drdy_irq.ig1.en_mask == state)
 		return 0;
 
-	if (state) {
+	if (state == CLN_ACCEL_INT1_ENABLED) {
 		err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
 				NULL,
 				lis331dlh_intel_cln_threshold_event_handler,
 				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
 				"lis331dlh_intel_cln_threshold",
 				indio_dev);
-		if (err == 0) {
-			sdata->int_thresh = true;
+		if (likely(err == 0)) {
+			sdata->sensor->drdy_irq.ig1.en_mask =
+					CLN_ACCEL_INT1_ENABLED;
 			err = sdata->tf->write_byte(
 				&sdata->tb, sdata->dev,
 				ST_ACCEL_2_INT1_DURATION_ADDR, 1);
 		}
 	} else {
 		free_irq(sdata->get_irq_data_ready(indio_dev), indio_dev);
-		sdata->int_thresh = false;
+		sdata->sensor->drdy_irq.ig1.en_mask = CLN_ACCEL_INT1_DISABLED;
 	}
 
 	return err;
@@ -343,21 +386,23 @@ static int lis331dlh_intel_cln_write_event_config(
 	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
 
 	err = st_sensors_write_data_with_mask(indio_dev,
-					      ST_ACCEL_2_INT1_CFG_ADDR,
-					      mask, state);
+					ST_ACCEL_2_INT1_CFG_ADDR,
+					mask, state);
+	if (unlikely(err < 0))
+		goto write_event_err;
 
-	if (err == 0)
-		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-					   ST_ACCEL_2_INT1_CFG_ADDR, &data);
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT1_CFG_ADDR, &data);
+	if (unlikely(err < 0))
+		goto write_event_err;
 
-	if (err == 0) {
-		new_int_state = data & (ST_ACCEL_2_INT_CFG_XHIE_EN |
+	new_int_state = data & (ST_ACCEL_2_INT_CFG_XHIE_EN |
 					ST_ACCEL_2_INT_CFG_YHIE_EN |
 					ST_ACCEL_2_INT_CFG_ZHIE_EN);
-		err = lis331dlh_intel_cln_configure_threshold_interrupt(
+	err = lis331dlh_intel_cln_configure_threshold_interrupt(
 			indio_dev, new_int_state);
-	}
 
+write_event_err:
 	return err;
 }
 
@@ -371,33 +416,38 @@ static int lis331dlh_intel_cln_enable_wakeup_interrupt(
 	u8 data;
 	struct st_sensor_data *sdata = iio_priv(indio_dev);
 
-	if (err == 0)
-		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
 					ST_ACCEL_2_INT2_THRESH_ADDR,
 					CLN_ACCEL_INT2_WAKEUP_THRESH_VAL);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
 
 	/* Latch interrupt request on INT2 */
-	if (err == 0)
-		err = st_sensors_write_data_with_mask(
+	err = st_sensors_write_data_with_mask(
 			indio_dev, ST_ACCEL_2_DRDY_IRQ_ADDR,
 			ST_ACCEL_2_INT_LIR_MASK, 1);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
 
-	if (err == 0)
-		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-					    ST_ACCEL_2_INT2_DURATION_ADDR, 0);
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT2_DURATION_ADDR, 0);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
 
-	if (err == 0)
-		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-					    ST_ACCEL_2_INT2_CFG_ADDR,
-					    ST_ACCEL_2_INT_CFG_XHIE_EN |
-					    ST_ACCEL_2_INT_CFG_YHIE_EN);
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_CFG_ADDR,
+						ST_ACCEL_2_INT_CFG_XHIE_EN |
+						ST_ACCEL_2_INT_CFG_YHIE_EN);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
 
 	/* Clean ST_ACCEL_2_INT2_SRC */
-	if (err == 0)
-		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-					   ST_ACCEL_2_INT2_SRC_ADDR,
-					   &data);
 
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_SRC_ADDR,
+						&data);
+
+enable_wakeup_int_err:
 	return err;
 }
 
@@ -408,17 +458,20 @@ static int lis331dlh_intel_cln_disable_wakeup_interrupt(
 	u8 data;
 	struct st_sensor_data *sdata = iio_priv(indio_dev);
 
-	if (err == 0)
-		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-					    ST_ACCEL_2_INT2_CFG_ADDR,
-					    0);
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_CFG_ADDR,
+						0);
+	if (unlikely(err < 0))
+		goto disable_wakeup_int_err;
 
 	/* Clean ST_ACCEL_2_INT2_SRC */
-	if (err == 0)
-		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-					   ST_ACCEL_2_INT2_SRC_ADDR,
-					   &data);
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_SRC_ADDR,
+						&data);
+	if (unlikely(err < 0))
+		goto disable_wakeup_int_err;
 
+disable_wakeup_int_err:
 	return err;
 }
 
@@ -433,18 +486,20 @@ static int lis331dlh_intel_cln_handle_wakeup_interrupt(
 	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
 				   ST_ACCEL_2_INT2_SRC_ADDR,
 				   &data);
+	if (unlikely(err < 0))
+		goto handle_wakeup_int_err;
 
-	if (err == 0)
-		if (data & ST_ACCEL_2_INT_IA_MASK) {
-			iio_push_event(indio_dev,
-					IIO_EVENT_CODE(IIO_ACCEL,
-					0, /* non differential */
-					IIO_MOD_X_OR_Y_OR_Z,
-					IIO_EV_TYPE_THRESH,
-					IIO_EV_DIR_EITHER, 0, 0, 0),
-					timestamp);
-		}
+	if (data & ST_ACCEL_2_INT_IA_MASK) {
+		iio_push_event(indio_dev,
+				IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				0,
+				IIO_MOD_X_OR_Y_OR_Z,
+				IIO_EV_TYPE_THRESH,
+				IIO_EV_DIR_EITHER),
+				timestamp);
+	}
 
+handle_wakeup_int_err:
 	return err;
 }
 
@@ -460,11 +515,11 @@ static const struct iio_info accel_info = {
 };
 
 static const struct iio_chan_spec st_accel_12bit_channels[] = {
-	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
+	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
 		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_X_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
+	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
 		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Y_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
+	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
 		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Z_L_ADDR),
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
@@ -538,7 +593,7 @@ static int lis331dlh_intel_cln_probe(
 	int ret = 0;
 
 	indio_dev = iio_device_alloc(sizeof(*adata));
-	if (indio_dev == NULL) {
+	if (unlikely(indio_dev == NULL)) {
 		ret = -ENOMEM;
 		goto iio_device_alloc_error;
 	}
@@ -551,13 +606,13 @@ static int lis331dlh_intel_cln_probe(
 	adata->dev = &client->dev;
 
 	pdata = client->dev.platform_data;
-	if (!pdata) {
+	if (unlikely(!pdata)) {
 		pr_err("No platform data provided\n");
 		goto lis331dlh_intel_cln_init_err;
 	}
 
 	ret = gpio_to_irq(pdata->irq1_pin);
-	if (ret < 0) {
+	if (unlikely(ret < 0)) {
 		pr_err(
 			"Failed to obtain valid IRQ for GPIO %d, "
 			"gpio_to_irq returned %d\n",
@@ -572,8 +627,8 @@ static int lis331dlh_intel_cln_probe(
 	indio_dev->info = &accel_info;
 
 	ret = st_sensors_check_device_support(indio_dev,
-					      1, &lis331dlh_intel_cln_sensor);
-	if (ret < 0)
+						1, &lis331dlh_intel_cln_sensor);
+	if (unlikely(ret < 0))
 		goto lis331dlh_intel_cln_init_err;
 
 	indio_dev->channels = adata->sensor->ch;
@@ -583,14 +638,19 @@ static int lis331dlh_intel_cln_probe(
 	adata->current_fullscale = (struct st_sensor_fullscale_avl *)
 		&adata->sensor->fs.fs_avl[0];
 	adata->odr = adata->sensor->odr.odr_avl[0].hz;
-	adata->int_thresh = false;
+
+	adata->sensor->drdy_irq.ig1.en_mask = CLN_ACCEL_INT1_DISABLED;
 
 	ret = st_sensors_init_sensor(indio_dev);
-	if (ret < 0)
+	if (unlikely(ret < 0))
+		goto lis331dlh_intel_cln_init_err;
+
+	ret = st_sensors_set_enable(indio_dev, true);
+	if (unlikely(ret < 0))
 		goto lis331dlh_intel_cln_init_err;
 
 	ret = iio_device_register(indio_dev);
-	if (ret)
+	if (unlikely(ret))
 		goto lis331dlh_intel_cln_init_err;
 
 	return 0;
@@ -609,7 +669,7 @@ static int lis331dlh_intel_cln_remove(
 
 	st_sensors_set_enable(indio_dev, false);
 
-	if (adata->int_thresh)
+	if (adata->sensor->drdy_irq.ig1.en_mask == CLN_ACCEL_INT1_ENABLED)
 		free_irq(adata->get_irq_data_ready(indio_dev), indio_dev);
 
 	iio_device_unregister(indio_dev);
diff --git a/drivers/iio/adc/max78m6610_lmu.c b/drivers/iio/adc/max78m6610_lmu.c
index f38ed57..5a72f8e 100644
--- a/drivers/iio/adc/max78m6610_lmu.c
+++ b/drivers/iio/adc/max78m6610_lmu.c
@@ -38,7 +38,10 @@
 #include <linux/iio/trigger_consumer.h>
 #include <linux/iio/triggered_buffer.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
 #include <linux/version.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
 
 #define INSTAN_VA       0x33 /* instaneous Voltage for VA source */
 #define INSTAN_IA       0x44 /* instaneous Current for IA source */
@@ -77,6 +80,7 @@
 #define SIGN_BIT_NUM	23
 #define SPI_MSG_LEN	5
 #define RX_OFFSET	1
+#define SPI_BBUFFER_LEN 4096
 
 /* SPI message Control byte */
 #define SPI_CB(x)	((SPI_CB_NBR_ACC << 4)\
@@ -436,6 +440,14 @@ struct max78m6610_lmu_state {
 
 	u8	tx_buf[SPI_MSG_LEN * MAX_CHAN_NUM];
 	u8	rx_buf[SPI_MSG_LEN * MAX_CHAN_NUM + sizeof(s64)];
+
+
+	/* Char dev to provide ioctl interface for f/w upgrade
+	 * or low-level register access */
+	struct cdev cdev;
+	dev_t cdev_no;
+	struct class *cl;
+	u8	*bbuffer;
 };
 
 /**
@@ -710,6 +722,264 @@ static const struct iio_info max78m6610_lmu_info = {
 	.driver_module = THIS_MODULE,
 };
 
+static int
+max78m6610_lmu_open(struct inode *inode, struct file *filp)
+{
+	struct max78m6610_lmu_state *st;
+	int ret = 0;
+
+	st = container_of(inode->i_cdev,
+			    struct max78m6610_lmu_state,
+			    cdev);
+	filp->private_data = st;
+
+	if (!st->bbuffer) {
+		st->bbuffer = kmalloc(SPI_BBUFFER_LEN, GFP_KERNEL);
+		if (!st->bbuffer) {
+			dev_dbg(&st->spi->dev, "open/ENOMEM\n");
+			ret = -ENOMEM;
+		}
+	}
+
+	return ret;
+}
+
+static int
+max78m6610_lmu_release(struct inode *inode, struct file *filp)
+{
+	struct max78m6610_lmu_state *st =
+		(struct max78m6610_lmu_state *)filp->private_data;
+
+	kfree(st->bbuffer);
+	st->bbuffer = NULL;
+
+	return 0;
+}
+
+static int spidev_message(struct max78m6610_lmu_state *st,
+			  struct spi_ioc_transfer *u_xfers,
+			  unsigned n_xfers)
+{
+	struct spi_message	msg;
+	struct spi_transfer	*k_xfers;
+	struct spi_transfer	*k_tmp;
+	struct spi_ioc_transfer *u_tmp;
+	unsigned		n, total;
+	u8			*buf;
+	int			status = -EFAULT;
+
+	spi_message_init(&msg);
+	k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
+	if (k_xfers == NULL)
+		return -ENOMEM;
+
+	/* Construct spi_message, copying any tx data to bounce buffer.
+	 * We walk the array of user-provided transfers, using each one
+	 * to initialize a kernel version of the same transfer.
+	 */
+	buf = st->bbuffer;
+	total = 0;
+	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+			n;
+			n--, k_tmp++, u_tmp++) {
+		k_tmp->len = u_tmp->len;
+
+		total += k_tmp->len;
+		if (total > SPI_BBUFFER_LEN) {
+			status = -EMSGSIZE;
+			goto done;
+		}
+
+		if (u_tmp->rx_buf) {
+			k_tmp->rx_buf = buf;
+			if (!access_ok(VERIFY_WRITE, (u8 __user *)
+						(uintptr_t) u_tmp->rx_buf,
+						u_tmp->len))
+				goto done;
+		}
+		if (u_tmp->tx_buf) {
+			k_tmp->tx_buf = buf;
+			if (copy_from_user(buf, (const u8 __user *)
+						(uintptr_t) u_tmp->tx_buf,
+					u_tmp->len))
+				goto done;
+		}
+		buf += k_tmp->len;
+
+		k_tmp->cs_change = !!u_tmp->cs_change;
+		k_tmp->bits_per_word = u_tmp->bits_per_word;
+		k_tmp->delay_usecs = u_tmp->delay_usecs;
+		k_tmp->speed_hz = u_tmp->speed_hz;
+#ifdef VERBOSE
+		dev_dbg(&st->spi->dev,
+			"  xfer len %zd %s%s%s%dbits %u usec %uHz\n",
+			u_tmp->len,
+			u_tmp->rx_buf ? "rx " : "",
+			u_tmp->tx_buf ? "tx " : "",
+			u_tmp->cs_change ? "cs " : "",
+			u_tmp->bits_per_word ? : st->spi->bits_per_word,
+			u_tmp->delay_usecs,
+			u_tmp->speed_hz ? : st->spi->max_speed_hz);
+#endif
+		spi_message_add_tail(k_tmp, &msg);
+	}
+
+	status = spi_sync(st->spi, &msg);
+	if (status < 0)
+		goto done;
+
+	/* copy any rx data out of bounce buffer */
+	buf = st->bbuffer;
+	for (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {
+		if (u_tmp->rx_buf) {
+			if (__copy_to_user((u8 __user *)
+					(uintptr_t) u_tmp->rx_buf, buf,
+					u_tmp->len)) {
+				status = -EFAULT;
+				goto done;
+			}
+		}
+		buf += u_tmp->len;
+	}
+	status = total;
+
+done:
+	kfree(k_xfers);
+	return status;
+}
+
+static long
+max78m6610_lmu_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct max78m6610_lmu_state *st = filp->private_data;
+	struct iio_dev *indio_dev = spi_get_drvdata(st->spi);
+	u32			tmp;
+	unsigned		n_ioc;
+	struct spi_ioc_transfer	*ioc;
+	int ret = 0;
+
+	/* Check type and command number */
+	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
+		return -ENOTTY;
+
+	/* Check access direction once here; don't repeat below.
+	 * IOC_DIR is from the user perspective, while access_ok is
+	 * from the kernel perspective; so they look reversed.
+	 */
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE,
+				(void __user *)arg, _IOC_SIZE(cmd));
+	if (ret == 0 && _IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ,
+				(void __user *)arg, _IOC_SIZE(cmd));
+	if (ret)
+		return -EFAULT;
+
+	ret = mutex_lock_interruptible(&indio_dev->mlock);
+	if (ret)
+		return ret;
+
+	/* segmented and/or full-duplex I/O request */
+	if (_IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))
+	    || _IOC_DIR(cmd) != _IOC_WRITE) {
+		ret = -ENOTTY;
+		goto exit;
+	}
+
+	tmp = _IOC_SIZE(cmd);
+	if ((tmp % sizeof(struct spi_ioc_transfer)) != 0) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	n_ioc = tmp / sizeof(struct spi_ioc_transfer);
+	if (n_ioc == 0)
+		goto exit;
+
+	/* copy into scratch area */
+	ioc = kmalloc(tmp, GFP_KERNEL);
+	if (!ioc) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (__copy_from_user(ioc, (void __user *)arg, tmp)) {
+		kfree(ioc);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	/* translate to spi_message, execute */
+	ret = spidev_message(st, ioc, n_ioc);
+	kfree(ioc);
+
+exit:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+static const struct file_operations max78m6610_lmu_fops = {
+	.owner = THIS_MODULE,
+	.open = max78m6610_lmu_open,
+	.release = max78m6610_lmu_release,
+	.unlocked_ioctl = max78m6610_lmu_ioctl,
+};
+
+static int
+max78m6610_lmu_chrdev_init(struct max78m6610_lmu_state *st)
+{
+	int ret;
+	struct device *dev;
+
+	ret = alloc_chrdev_region(&st->cdev_no, 0, 1,
+				  "max78m6610_lmu");
+	if (ret) {
+		pr_err("Failed to alloc chrdev: %d", ret);
+		return ret;
+	}
+
+	cdev_init(&st->cdev, &max78m6610_lmu_fops);
+
+	ret = cdev_add(&st->cdev, st->cdev_no, 1);
+	if (ret) {
+		pr_err("Failed to add cdev: %d", ret);
+		unregister_chrdev_region(st->cdev_no, 1);
+		return ret;
+	}
+
+	st->cl = class_create(THIS_MODULE, "char");
+	if (IS_ERR(st->cl)) {
+		pr_err("Failed to create device class: %ld",
+		       PTR_ERR(st->cl));
+		cdev_del(&st->cdev);
+		unregister_chrdev_region(st->cdev_no, 1);
+		return PTR_ERR(st->cl);
+	}
+
+	dev = device_create(st->cl, NULL, st->cdev_no, NULL,
+			    "max78m6610_lmu");
+	if (IS_ERR(dev)) {
+		pr_err("Failed to create device: %ld",
+		       PTR_ERR(st->cl));
+		class_destroy(st->cl);
+		cdev_del(&st->cdev);
+		unregister_chrdev_region(st->cdev_no, 1);
+		return PTR_ERR(dev);
+	}
+
+	return 0;
+}
+
+static int
+max78m6610_lmu_chrdev_remove(struct max78m6610_lmu_state *st)
+{
+	device_destroy(st->cl, st->cdev_no);
+	class_destroy(st->cl);
+	cdev_del(&st->cdev);
+	unregister_chrdev_region(st->cdev_no, 1);
+
+	return 0;
+}
+
 /**
  * max78m6610_lmu_probe
  *
@@ -758,6 +1028,10 @@ static int max78m6610_lmu_probe(struct spi_device *spi)
 	if (ret)
 		goto error_cleanup_ring;
 
+	ret = max78m6610_lmu_chrdev_init(st);
+	if (ret)
+		goto error_cleanup_ring;
+
 	return 0;
 
 error_cleanup_ring:
@@ -779,7 +1053,9 @@ error_free:
 static int max78m6610_lmu_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
 
+	max78m6610_lmu_chrdev_remove(st);
 	iio_device_unregister(indio_dev);
 	iio_triggered_buffer_cleanup(indio_dev);
 	iio_device_free(indio_dev);
diff --git a/drivers/iio/common/st_sensors/Kconfig b/drivers/iio/common/st_sensors/Kconfig
index d1b474a..865f1ca 100644
--- a/drivers/iio/common/st_sensors/Kconfig
+++ b/drivers/iio/common/st_sensors/Kconfig
@@ -2,19 +2,13 @@
 # STMicroelectronics sensors common library
 #
 
-menu "STMicro sensors"
 config IIO_ST_SENSORS_I2C
-	tristate "IIO ST SENSORS"
-	help
-	  Enable SENSORS I2C option
+	tristate
 
 config IIO_ST_SENSORS_SPI
-	tristate "IIO SENSORS SPI"
-	help
-	  Enable IIO_ST_SENSORS_SPI
+	tristate
 
 config IIO_ST_SENSORS_CORE
-	tristate "IIO SENSORS CORE"
+	tristate
 	select IIO_ST_SENSORS_I2C if I2C
 	select IIO_ST_SENSORS_SPI if SPI_MASTER
-endmenu
diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c
index 9873869..945a55b 100644
--- a/drivers/iio/common/st_sensors/st_sensors_core.c
+++ b/drivers/iio/common/st_sensors/st_sensors_core.c
@@ -200,7 +200,7 @@ int st_sensors_init_sensor(struct iio_dev *indio_dev)
 
 	mutex_init(&sdata->tb.buf_lock);
 
-	err = st_sensors_set_enable(indio_dev, true);
+	err = st_sensors_set_enable(indio_dev, false);
 	if (err < 0)
 		goto init_error;
 
@@ -273,7 +273,7 @@ st_sensors_match_scale_error:
 }
 EXPORT_SYMBOL(st_sensors_set_fullscale_by_gain);
 
-static int st_sensors_read_axis_data(struct iio_dev *indio_dev,
+int st_sensors_read_axis_data(struct iio_dev *indio_dev,
 							u8 ch_addr, int *data)
 {
 	int err;
@@ -291,18 +291,30 @@ static int st_sensors_read_axis_data(struct iio_dev *indio_dev,
 read_error:
 	return err;
 }
+EXPORT_SYMBOL(st_sensors_read_axis_data);
 
 int st_sensors_read_info_raw(struct iio_dev *indio_dev,
 				struct iio_chan_spec const *ch, int *val)
 {
 	int err;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
 
 	mutex_lock(&indio_dev->mlock);
-	err = st_sensors_read_axis_data(indio_dev, ch->address, val);
-	if (err < 0)
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		err = -EBUSY;
 		goto read_error;
+	} else {
+		err = st_sensors_set_enable(indio_dev, true);
+		if (err < 0)
+			goto read_error;
 
-	*val = *val >> ch->scan_type.shift;
+		msleep((sdata->sensor->bootime * 1000) / sdata->odr);
+		err = st_sensors_read_axis_data(indio_dev, ch->address, val);
+		if (err < 0)
+			goto read_error;
+
+		*val = *val >> ch->scan_type.shift;
+	}
 	mutex_unlock(&indio_dev->mlock);
 
 	return err;
diff --git a/drivers/iio/common/st_sensors/st_sensors_i2c.c b/drivers/iio/common/st_sensors/st_sensors_i2c.c
index f8e82c5..38af944 100644
--- a/drivers/iio/common/st_sensors/st_sensors_i2c.c
+++ b/drivers/iio/common/st_sensors/st_sensors_i2c.c
@@ -15,6 +15,7 @@
 
 #include <linux/iio/common/st_sensors_i2c.h>
 
+
 #define ST_SENSORS_I2C_MULTIREAD	0x80
 
 static unsigned int st_sensors_i2c_get_irq(struct iio_dev *indio_dev)
diff --git a/drivers/iio/common/st_sensors/st_sensors_trigger.c b/drivers/iio/common/st_sensors/st_sensors_trigger.c
index 8b4dd48..139ed03 100644
--- a/drivers/iio/common/st_sensors/st_sensors_trigger.c
+++ b/drivers/iio/common/st_sensors/st_sensors_trigger.c
@@ -34,8 +34,7 @@ int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
 	err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
 			iio_trigger_generic_data_rdy_poll,
 			NULL,
-			IRQF_SHARED | /* sharing with the accelerometer events*/
-			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			IRQF_TRIGGER_RISING,
 			sdata->trig->name,
 			sdata->trig);
 	if (err)
diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c
index aaadd32..7b8d510 100644
--- a/drivers/iio/industrialio-buffer.c
+++ b/drivers/iio/industrialio-buffer.c
@@ -119,8 +119,8 @@ static ssize_t iio_scan_el_show(struct device *dev,
 	int ret;
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 
-	ret = test_bit(to_iio_dev_attr(attr)->address,
-		       indio_dev->buffer->scan_mask);
+	ret = abs(test_bit(to_iio_dev_attr(attr)->address,
+		       indio_dev->buffer->scan_mask));
 
 	return sprintf(buf, "%d\n", ret);
 }
@@ -762,7 +762,7 @@ int iio_scan_mask_query(struct iio_dev *indio_dev,
 	if (!buffer->scan_mask)
 		return 0;
 
-	return test_bit(bit, buffer->scan_mask);
+	return abs(test_bit(bit, buffer->scan_mask));
 };
 EXPORT_SYMBOL_GPL(iio_scan_mask_query);
 
diff --git a/drivers/iio/trigger/Kconfig b/drivers/iio/trigger/Kconfig
new file mode 100644
index 0000000..e9e837d
--- /dev/null
+++ b/drivers/iio/trigger/Kconfig
@@ -0,0 +1,55 @@
+#
+# Industrial I/O standalone triggers
+#
+comment "Triggers - standalone"
+
+if IIO_TRIGGER
+
+config IIO_PERIODIC_RTC_TRIGGER
+	tristate "Periodic RTC triggers"
+	depends on RTC_CLASS
+	help
+	  Provides support for using periodic capable real time
+	  clocks as IIO triggers.
+
+config IIO_GPIO_TRIGGER
+	tristate "GPIO trigger"
+	depends on GENERIC_GPIO
+	help
+	  Provides support for using GPIO pins as IIO triggers.
+
+config IIO_SYSFS_TRIGGER
+	tristate "SYSFS trigger"
+	depends on SYSFS
+	depends on HAVE_IRQ_WORK
+	select IRQ_WORK
+	help
+	  Provides support for using SYSFS entry as IIO triggers.
+	  If unsure, say N (but it's safe to say "Y").
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called iio-trig-sysfs.
+ 
+config IIO_HRTIMER_TRIGGER
+	tristate "HRTIMER trigger"
+	#depends on HRTIMER
+	select IRQ_WORK
+	help
+	  Provides support for using HRTIMER entries as IIO triggers.
+	  If unsure, say N (but it's safe to say "Y").
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called iio-trig-hrtimer.
+
+config IIO_BFIN_TMR_TRIGGER
+	tristate "Blackfin TIMER trigger"
+	depends on BLACKFIN
+	select BFIN_GPTIMERS
+	help
+	  Provides support for using a Blackfin timer as IIO triggers.
+	  If unsure, say N (but it's safe to say "Y").
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called iio-trig-bfin-timer.
+
+endif # IIO_TRIGGER
diff --git a/drivers/iio/trigger/Makefile b/drivers/iio/trigger/Makefile
new file mode 100644
index 0000000..ad2f595
--- /dev/null
+++ b/drivers/iio/trigger/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for triggers not associated with iio-devices
+#
+
+obj-$(CONFIG_IIO_PERIODIC_RTC_TRIGGER) += iio-trig-periodic-rtc.o
+obj-$(CONFIG_IIO_GPIO_TRIGGER) += iio-trig-gpio.o
+obj-$(CONFIG_IIO_SYSFS_TRIGGER) += iio-trig-sysfs.o
+obj-$(CONFIG_IIO_HRTIMER_TRIGGER) += iio-trig-hrtimer.o
+obj-$(CONFIG_IIO_BFIN_TMR_TRIGGER) += iio-trig-bfin-timer.o
diff --git a/drivers/iio/trigger/iio-trig-bfin-timer.c b/drivers/iio/trigger/iio-trig-bfin-timer.c
new file mode 100644
index 0000000..42798da
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-bfin-timer.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2011 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/gptimers.h>
+#include <asm/portmux.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+#include "iio-trig-bfin-timer.h"
+
+struct bfin_timer {
+	unsigned short id, bit;
+	unsigned long irqbit;
+	int irq;
+	int pin;
+};
+
+/*
+ * this covers all hardware timer configurations on
+ * all Blackfin derivatives out there today
+ */
+
+static struct bfin_timer iio_bfin_timer_code[MAX_BLACKFIN_GPTIMERS] = {
+	{TIMER0_id,  TIMER0bit,  TIMER_STATUS_TIMIL0,  IRQ_TIMER0, P_TMR0},
+	{TIMER1_id,  TIMER1bit,  TIMER_STATUS_TIMIL1,  IRQ_TIMER1, P_TMR1},
+	{TIMER2_id,  TIMER2bit,  TIMER_STATUS_TIMIL2,  IRQ_TIMER2, P_TMR2},
+#if (MAX_BLACKFIN_GPTIMERS > 3)
+	{TIMER3_id,  TIMER3bit,  TIMER_STATUS_TIMIL3,  IRQ_TIMER3, P_TMR3},
+	{TIMER4_id,  TIMER4bit,  TIMER_STATUS_TIMIL4,  IRQ_TIMER4, P_TMR4},
+	{TIMER5_id,  TIMER5bit,  TIMER_STATUS_TIMIL5,  IRQ_TIMER5, P_TMR5},
+	{TIMER6_id,  TIMER6bit,  TIMER_STATUS_TIMIL6,  IRQ_TIMER6, P_TMR6},
+	{TIMER7_id,  TIMER7bit,  TIMER_STATUS_TIMIL7,  IRQ_TIMER7, P_TMR7},
+#endif
+#if (MAX_BLACKFIN_GPTIMERS > 8)
+	{TIMER8_id,  TIMER8bit,  TIMER_STATUS_TIMIL8,  IRQ_TIMER8, P_TMR8},
+	{TIMER9_id,  TIMER9bit,  TIMER_STATUS_TIMIL9,  IRQ_TIMER9, P_TMR9},
+	{TIMER10_id, TIMER10bit, TIMER_STATUS_TIMIL10, IRQ_TIMER10, P_TMR10},
+#if (MAX_BLACKFIN_GPTIMERS > 11)
+	{TIMER11_id, TIMER11bit, TIMER_STATUS_TIMIL11, IRQ_TIMER11, P_TMR11},
+#endif
+#endif
+};
+
+struct bfin_tmr_state {
+	struct iio_trigger *trig;
+	struct bfin_timer *t;
+	unsigned timer_num;
+	bool output_enable;
+	unsigned int duty;
+	int irq;
+};
+
+static int iio_bfin_tmr_set_state(struct iio_trigger *trig, bool state)
+{
+	struct bfin_tmr_state *st = trig->private_data;
+
+	if (get_gptimer_period(st->t->id) == 0)
+		return -EINVAL;
+
+	if (state)
+		enable_gptimers(st->t->bit);
+	else
+		disable_gptimers(st->t->bit);
+
+	return 0;
+}
+
+static ssize_t iio_bfin_tmr_frequency_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct bfin_tmr_state *st = trig->private_data;
+	unsigned long val;
+	bool enabled;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret)
+		goto error_ret;
+
+	if (val > 100000) {
+		ret = -EINVAL;
+		goto error_ret;
+	}
+
+	enabled = get_enabled_gptimers() & st->t->bit;
+
+	if (enabled)
+		disable_gptimers(st->t->bit);
+
+	if (!val)
+		goto error_ret;
+
+	val = get_sclk() / val;
+	if (val <= 4 || val <= st->duty) {
+		ret = -EINVAL;
+		goto error_ret;
+	}
+
+	set_gptimer_period(st->t->id, val);
+	set_gptimer_pwidth(st->t->id, val - st->duty);
+
+	if (enabled)
+		enable_gptimers(st->t->bit);
+
+error_ret:
+	return ret ? ret : count;
+}
+
+static ssize_t iio_bfin_tmr_frequency_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct bfin_tmr_state *st = trig->private_data;
+	unsigned int period = get_gptimer_period(st->t->id);
+	unsigned long val;
+
+	if (period == 0)
+		val = 0;
+	else
+		val = get_sclk() / get_gptimer_period(st->t->id);
+
+	return sprintf(buf, "%lu\n", val);
+}
+
+static DEVICE_ATTR(frequency, S_IRUGO | S_IWUSR, iio_bfin_tmr_frequency_show,
+		   iio_bfin_tmr_frequency_store);
+
+static struct attribute *iio_bfin_tmr_trigger_attrs[] = {
+	&dev_attr_frequency.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_bfin_tmr_trigger_attr_group = {
+	.attrs = iio_bfin_tmr_trigger_attrs,
+};
+
+static const struct attribute_group *iio_bfin_tmr_trigger_attr_groups[] = {
+	&iio_bfin_tmr_trigger_attr_group,
+	NULL
+};
+
+static irqreturn_t iio_bfin_tmr_trigger_isr(int irq, void *devid)
+{
+	struct bfin_tmr_state *st = devid;
+
+	clear_gptimer_intr(st->t->id);
+	iio_trigger_poll(st->trig, 0);
+
+	return IRQ_HANDLED;
+}
+
+static int iio_bfin_tmr_get_number(int irq)
+{
+	int i;
+
+	for (i = 0; i < MAX_BLACKFIN_GPTIMERS; i++)
+		if (iio_bfin_timer_code[i].irq == irq)
+			return i;
+
+	return -ENODEV;
+}
+
+static const struct iio_trigger_ops iio_bfin_tmr_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = iio_bfin_tmr_set_state,
+};
+
+static int iio_bfin_tmr_trigger_probe(struct platform_device *pdev)
+{
+	struct iio_bfin_timer_trigger_pdata *pdata = pdev->dev.platform_data;
+	struct bfin_tmr_state *st;
+	unsigned int config;
+	int ret;
+
+	st = kzalloc(sizeof(*st), GFP_KERNEL);
+	if (st == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	st->irq = platform_get_irq(pdev, 0);
+	if (!st->irq) {
+		dev_err(&pdev->dev, "No IRQs specified");
+		ret = -ENODEV;
+		goto out1;
+	}
+
+	ret = iio_bfin_tmr_get_number(st->irq);
+	if (ret < 0)
+		goto out1;
+
+	st->timer_num = ret;
+	st->t = &iio_bfin_timer_code[st->timer_num];
+
+	st->trig = iio_trigger_alloc("bfintmr%d", st->timer_num);
+	if (!st->trig) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	st->trig->private_data = st;
+	st->trig->ops = &iio_bfin_tmr_trigger_ops;
+	st->trig->dev.groups = iio_bfin_tmr_trigger_attr_groups;
+	ret = iio_trigger_register(st->trig);
+	if (ret)
+		goto out2;
+
+	ret = request_irq(st->irq, iio_bfin_tmr_trigger_isr,
+			  0, st->trig->name, st);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"request IRQ-%d failed", st->irq);
+		goto out4;
+	}
+
+	config = PWM_OUT | PERIOD_CNT | IRQ_ENA;
+
+	if (pdata && pdata->output_enable) {
+		unsigned long long val;
+
+		st->output_enable = true;
+
+		ret = peripheral_request(st->t->pin, st->trig->name);
+		if (ret)
+			goto out_free_irq;
+
+		val = (unsigned long long)get_sclk() * pdata->duty_ns;
+		do_div(val, NSEC_PER_SEC);
+		st->duty = val;
+
+		/**
+		 * The interrupt will be generated at the end of the period,
+		 * since we want the interrupt to be generated at end of the
+		 * pulse we invert both polarity and duty cycle, so that the
+		 * pulse will be generated directly before the interrupt.
+		 */
+		if (pdata->active_low)
+			config |= PULSE_HI;
+	} else {
+		st->duty = 1;
+		config |= OUT_DIS;
+	}
+
+	set_gptimer_config(st->t->id, config);
+
+	dev_info(&pdev->dev, "iio trigger Blackfin TMR%d, IRQ-%d",
+		 st->timer_num, st->irq);
+	platform_set_drvdata(pdev, st);
+
+	return 0;
+out_free_irq:
+	free_irq(st->irq, st);
+out4:
+	iio_trigger_unregister(st->trig);
+out2:
+	iio_trigger_put(st->trig);
+out1:
+	kfree(st);
+out:
+	return ret;
+}
+
+static int iio_bfin_tmr_trigger_remove(struct platform_device *pdev)
+{
+	struct bfin_tmr_state *st = platform_get_drvdata(pdev);
+
+	disable_gptimers(st->t->bit);
+	if (st->output_enable)
+		peripheral_free(st->t->pin);
+	free_irq(st->irq, st);
+	iio_trigger_unregister(st->trig);
+	iio_trigger_put(st->trig);
+	kfree(st);
+
+	return 0;
+}
+
+static struct platform_driver iio_bfin_tmr_trigger_driver = {
+	.driver = {
+		.name = "iio_bfin_tmr_trigger",
+		.owner = THIS_MODULE,
+	},
+	.probe = iio_bfin_tmr_trigger_probe,
+	.remove = iio_bfin_tmr_trigger_remove,
+};
+
+module_platform_driver(iio_bfin_tmr_trigger_driver);
+
+MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_DESCRIPTION("Blackfin system timer based trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:iio-trig-bfin-timer");
diff --git a/drivers/iio/trigger/iio-trig-bfin-timer.h b/drivers/iio/trigger/iio-trig-bfin-timer.h
new file mode 100644
index 0000000..c07321f
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-bfin-timer.h
@@ -0,0 +1,24 @@
+#ifndef __IIO_BFIN_TIMER_TRIGGER_H__
+#define __IIO_BFIN_TIMER_TRIGGER_H__
+
+/**
+ * struct iio_bfin_timer_trigger_pdata - timer trigger platform data
+ * @output_enable: Enable external trigger pulse generation.
+ * @active_low: Whether the trigger pulse is active low.
+ * @duty_ns: Length of the trigger pulse in nanoseconds.
+ *
+ * This struct is used to configure the output pulse generation of the blackfin
+ * timer trigger. If output_enable is set to true an external trigger signal
+ * will generated on the pin corresponding to the timer. This is useful for
+ * converters which needs an external signal to start conversion. active_low and
+ * duty_ns are used to configure the type of the trigger pulse. If output_enable
+ * is set to false no external trigger pulse will be generated and active_low
+ * and duty_ns are ignored.
+ **/
+struct iio_bfin_timer_trigger_pdata {
+	bool output_enable;
+	bool active_low;
+	unsigned int duty_ns;
+};
+
+#endif
diff --git a/drivers/iio/trigger/iio-trig-gpio.c b/drivers/iio/trigger/iio-trig-gpio.c
new file mode 100644
index 0000000..fcc4cb0
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-gpio.c
@@ -0,0 +1,167 @@
+/*
+ * Industrial I/O - gpio based trigger support
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * Currently this is more of a functioning proof of concept than a full
+ * fledged trigger driver.
+ *
+ * TODO:
+ *
+ * Add board config elements to allow specification of startup settings.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+static LIST_HEAD(iio_gpio_trigger_list);
+static DEFINE_MUTEX(iio_gpio_trigger_list_lock);
+
+struct iio_gpio_trigger_info {
+	struct mutex in_use;
+	unsigned int irq;
+};
+/*
+ * Need to reference count these triggers and only enable gpio interrupts
+ * as appropriate.
+ */
+
+/* So what functionality do we want in here?... */
+/* set high / low as interrupt type? */
+
+static irqreturn_t iio_gpio_trigger_poll(int irq, void *private)
+{
+	/* Timestamp not currently provided */
+	iio_trigger_poll(private, 0);
+	return IRQ_HANDLED;
+}
+
+static const struct iio_trigger_ops iio_gpio_trigger_ops = {
+	.owner = THIS_MODULE,
+};
+
+static int iio_gpio_trigger_probe(struct platform_device *pdev)
+{
+	struct iio_gpio_trigger_info *trig_info;
+	struct iio_trigger *trig, *trig2;
+	unsigned long irqflags;
+	struct resource *irq_res;
+	int irq, ret = 0, irq_res_cnt = 0;
+
+	do {
+		irq_res = platform_get_resource(pdev,
+				IORESOURCE_IRQ, irq_res_cnt);
+
+		if (irq_res == NULL) {
+			if (irq_res_cnt == 0)
+				dev_err(&pdev->dev, "No GPIO IRQs specified");
+			break;
+		}
+		irqflags = (irq_res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;
+
+		for (irq = irq_res->start; irq <= irq_res->end; irq++) {
+
+			trig = iio_trigger_alloc("irqtrig%d", irq);
+			if (!trig) {
+				ret = -ENOMEM;
+				goto error_free_completed_registrations;
+			}
+
+			trig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);
+			if (!trig_info) {
+				ret = -ENOMEM;
+				goto error_put_trigger;
+			}
+			trig->private_data = trig_info;
+			trig_info->irq = irq;
+			trig->ops = &iio_gpio_trigger_ops;
+			ret = request_irq(irq, iio_gpio_trigger_poll,
+					  irqflags, trig->name, trig);
+			if (ret) {
+				dev_err(&pdev->dev,
+					"request IRQ-%d failed", irq);
+				goto error_free_trig_info;
+			}
+
+			ret = iio_trigger_register(trig);
+			if (ret)
+				goto error_release_irq;
+
+			list_add_tail(&trig->alloc_list,
+					&iio_gpio_trigger_list);
+		}
+
+		irq_res_cnt++;
+	} while (irq_res != NULL);
+
+
+	return 0;
+
+/* First clean up the partly allocated trigger */
+error_release_irq:
+	free_irq(irq, trig);
+error_free_trig_info:
+	kfree(trig_info);
+error_put_trigger:
+	iio_trigger_put(trig);
+error_free_completed_registrations:
+	/* The rest should have been added to the iio_gpio_trigger_list */
+	list_for_each_entry_safe(trig,
+				 trig2,
+				 &iio_gpio_trigger_list,
+				 alloc_list) {
+		trig_info = trig->private_data;
+		free_irq(gpio_to_irq(trig_info->irq), trig);
+		kfree(trig_info);
+		iio_trigger_unregister(trig);
+	}
+
+	return ret;
+}
+
+static int iio_gpio_trigger_remove(struct platform_device *pdev)
+{
+	struct iio_trigger *trig, *trig2;
+	struct iio_gpio_trigger_info *trig_info;
+
+	mutex_lock(&iio_gpio_trigger_list_lock);
+	list_for_each_entry_safe(trig,
+				 trig2,
+				 &iio_gpio_trigger_list,
+				 alloc_list) {
+		trig_info = trig->private_data;
+		iio_trigger_unregister(trig);
+		free_irq(trig_info->irq, trig);
+		kfree(trig_info);
+		iio_trigger_put(trig);
+	}
+	mutex_unlock(&iio_gpio_trigger_list_lock);
+
+	return 0;
+}
+
+static struct platform_driver iio_gpio_trigger_driver = {
+	.probe = iio_gpio_trigger_probe,
+	.remove = iio_gpio_trigger_remove,
+	.driver = {
+		.name = "iio_gpio_trigger",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(iio_gpio_trigger_driver);
+
+MODULE_AUTHOR("Jonathan Cameron <jic23@kernel.org>");
+MODULE_DESCRIPTION("Example gpio trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/trigger/iio-trig-hrtimer.c b/drivers/iio/trigger/iio-trig-hrtimer.c
new file mode 100644
index 0000000..3f7d5b8
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-hrtimer.c
@@ -0,0 +1,282 @@
+/*
+ * Industrial I/O - hrtimer trigger support
+ *
+ * Copyright 2013 STMicroelectronics Inc.
+ * Denis Ciocca <denis.ciocca@xxxxxx>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+struct iio_hrtimer_trigger_data {
+	struct iio_trigger *trig;
+	struct hrtimer timer;
+	struct list_head l;
+	ktime_t period;
+	u16  freq;
+	int id;
+};
+
+static LIST_HEAD(iio_hrtimer_trigger_list);
+static DEFINE_MUTEX(iio_hrtimer_trigger_list_mut);
+
+static int iio_hrtimer_trigger_probe(int id);
+static int iio_hrtimer_trigger_remove(int id);
+
+static ssize_t iio_sysfs_hrtimer_trig_add(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = kstrtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+
+	ret = iio_hrtimer_trigger_probe(input);
+	if (ret)
+		return ret;
+
+	return len;
+}
+static DEVICE_ATTR(add_trigger, S_IWUSR, NULL, &iio_sysfs_hrtimer_trig_add);
+
+static ssize_t iio_sysfs_hrtimer_trig_remove(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = kstrtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+
+	ret = iio_hrtimer_trigger_remove(input);
+	if (ret)
+		return ret;
+
+	return len;
+}
+static DEVICE_ATTR(remove_trigger, S_IWUSR,
+					NULL, &iio_sysfs_hrtimer_trig_remove);
+
+static struct attribute *iio_hrtimer_trig_attrs[] = {
+	&dev_attr_add_trigger.attr,
+	&dev_attr_remove_trigger.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_hrtimer_trig_group = {
+	.attrs = iio_hrtimer_trig_attrs,
+};
+
+static const struct attribute_group *iio_hrtimer_trig_groups[] = {
+	&iio_hrtimer_trig_group,
+	NULL,
+};
+
+static struct device iio_hrtimer_trig_dev = {
+	.bus = &iio_bus_type,
+	.groups = iio_hrtimer_trig_groups,
+};
+
+static int iio_hrtimer_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	if (trig_data->freq == 0)
+		return -EINVAL;
+
+	if (state)
+		hrtimer_start(&trig_data->timer,
+					trig_data->period, HRTIMER_MODE_REL);
+	else
+		hrtimer_cancel(&trig_data->timer);
+
+	return 0;
+}
+
+static ssize_t iio_hrtimer_trigger_set_freq_value(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	u16 frequency;
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	ret = kstrtou16(buf, 10, &frequency);
+	if (ret < 0)
+		return ret;
+
+	if (frequency > NSEC_PER_SEC)
+		return -EINVAL;
+
+	trig_data->freq = frequency;
+
+	if (frequency)
+		trig_data->period =
+				ktime_set(0, NSEC_PER_SEC / trig_data->freq);
+
+	return len;
+}
+
+static ssize_t iio_hrtimer_trigger_get_freq_value(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	return sprintf(buf, "%hu\n", trig_data->freq);
+}
+
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO,
+					iio_hrtimer_trigger_get_freq_value,
+					iio_hrtimer_trigger_set_freq_value);
+
+static struct attribute *iio_hrtimer_trigger_attrs[] = {
+	&dev_attr_frequency.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_hrtimer_trigger_attr_group = {
+	.attrs = iio_hrtimer_trigger_attrs,
+};
+
+static const struct attribute_group *iio_hrtimer_trigger_attr_groups[] = {
+	&iio_hrtimer_trigger_attr_group,
+	NULL,
+};
+
+static const struct iio_trigger_ops iio_hrtimer_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &iio_hrtimer_trig_set_state,
+};
+
+enum hrtimer_restart iio_hrtimer_trigger_func(struct hrtimer *timer)
+{
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	trig_data = container_of(timer, struct iio_hrtimer_trigger_data, timer);
+
+	hrtimer_forward_now(timer, trig_data->period);
+	iio_trigger_poll(trig_data->trig, 0);
+
+	return HRTIMER_RESTART;
+}
+
+static int iio_hrtimer_trigger_probe(int id)
+{
+	int err;
+	bool foundit = false;
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	mutex_lock(&iio_hrtimer_trigger_list_mut);
+	list_for_each_entry(trig_data, &iio_hrtimer_trigger_list, l) {
+		if (id == trig_data->id) {
+			foundit = true;
+			break;
+		}
+	}
+	if (foundit) {
+		err = -EINVAL;
+		goto iio_hrtimer_mutex_unlock;
+	}
+
+	trig_data = kmalloc(sizeof(*trig_data), GFP_KERNEL);
+	if (trig_data == NULL) {
+		err = -ENOMEM;
+		goto iio_hrtimer_mutex_unlock;
+	}
+
+	trig_data->id = id;
+	trig_data->trig = iio_trigger_alloc("hrtimer_trig%d", id);
+	if (!trig_data->trig) {
+		err = -ENOMEM;
+		goto iio_hrtimer_free_trig_data;
+	}
+
+	trig_data->trig->dev.groups = iio_hrtimer_trigger_attr_groups;
+	trig_data->trig->ops = &iio_hrtimer_trigger_ops;
+	trig_data->trig->dev.parent = &iio_hrtimer_trig_dev;
+	dev_set_drvdata(&trig_data->trig->dev, trig_data);
+
+	trig_data->freq = 0;
+	hrtimer_init(&trig_data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	trig_data->timer.function = &iio_hrtimer_trigger_func;
+
+	err = iio_trigger_register(trig_data->trig);
+	if (err)
+		goto iio_hrtimer_free_trig_data;
+
+	list_add(&trig_data->l, &iio_hrtimer_trigger_list);
+	__module_get(THIS_MODULE);
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+
+	return 0;
+
+iio_hrtimer_free_trig_data:
+	kfree(trig_data);
+iio_hrtimer_mutex_unlock:
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+	return err;
+}
+
+static int iio_hrtimer_trigger_remove(int id)
+{
+	bool foundit = false;
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	mutex_lock(&iio_hrtimer_trigger_list_mut);
+	list_for_each_entry(trig_data, &iio_hrtimer_trigger_list, l) {
+		if (id == trig_data->id) {
+			foundit = true;
+			break;
+		}
+	}
+	if (!foundit) {
+		mutex_unlock(&iio_hrtimer_trigger_list_mut);
+		return -EINVAL;
+	}
+
+	iio_trigger_unregister(trig_data->trig);
+	iio_trigger_free(trig_data->trig);
+
+	list_del(&trig_data->l);
+	kfree(trig_data);
+	module_put(THIS_MODULE);
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+
+	return 0;
+}
+
+static int __init iio_hrtimer_trig_init(void)
+{
+	device_initialize(&iio_hrtimer_trig_dev);
+	dev_set_name(&iio_hrtimer_trig_dev, "iio_hrtimer_trigger");
+	return device_add(&iio_hrtimer_trig_dev);
+}
+module_init(iio_hrtimer_trig_init);
+
+static void __exit iio_hrtimer_trig_exit(void)
+{
+	device_unregister(&iio_hrtimer_trig_dev);
+}
+module_exit(iio_hrtimer_trig_exit);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@xxxxxx>");
+MODULE_DESCRIPTION("Hrtimer trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/trigger/iio-trig-periodic-rtc.c b/drivers/iio/trigger/iio-trig-periodic-rtc.c
new file mode 100644
index 0000000..9102b1b
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-periodic-rtc.c
@@ -0,0 +1,202 @@
+/* The industrial I/O periodic RTC trigger driver
+ *
+ * Copyright (c) 2008 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This is a heavily rewritten version of the periodic timer system in
+ * earlier version of industrialio.  It supplies the same functionality
+ * but via a trigger rather than a specific periodic timer system.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+static LIST_HEAD(iio_prtc_trigger_list);
+static DEFINE_MUTEX(iio_prtc_trigger_list_lock);
+
+struct iio_prtc_trigger_info {
+	struct rtc_device *rtc;
+	int frequency;
+	struct rtc_task task;
+};
+
+static int iio_trig_periodic_rtc_set_state(struct iio_trigger *trig, bool state)
+{
+	struct iio_prtc_trigger_info *trig_info = trig->private_data;
+	if (trig_info->frequency == 0)
+		return -EINVAL;
+	printk(KERN_INFO "trigger frequency is %d\n", trig_info->frequency);
+	return rtc_irq_set_state(trig_info->rtc, &trig_info->task, state);
+}
+
+static ssize_t iio_trig_periodic_read_freq(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_prtc_trigger_info *trig_info = trig->private_data;
+	return sprintf(buf, "%u\n", trig_info->frequency);
+}
+
+static ssize_t iio_trig_periodic_write_freq(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf,
+					    size_t len)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_prtc_trigger_info *trig_info = trig->private_data;
+	unsigned long val;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret)
+		goto error_ret;
+
+	ret = rtc_irq_set_freq(trig_info->rtc, &trig_info->task, val);
+	if (ret)
+		goto error_ret;
+
+	trig_info->frequency = val;
+
+	return len;
+
+error_ret:
+	return ret;
+}
+
+static DEVICE_ATTR(frequency, S_IRUGO | S_IWUSR,
+	    iio_trig_periodic_read_freq,
+	    iio_trig_periodic_write_freq);
+
+static struct attribute *iio_trig_prtc_attrs[] = {
+	&dev_attr_frequency.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_trig_prtc_attr_group = {
+	.attrs = iio_trig_prtc_attrs,
+};
+
+static const struct attribute_group *iio_trig_prtc_attr_groups[] = {
+	&iio_trig_prtc_attr_group,
+	NULL
+};
+
+static void iio_prtc_trigger_poll(void *private_data)
+{
+	/* Timestamp is not provided currently */
+	iio_trigger_poll(private_data, 0);
+}
+
+static const struct iio_trigger_ops iio_prtc_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &iio_trig_periodic_rtc_set_state,
+};
+
+static int iio_trig_periodic_rtc_probe(struct platform_device *dev)
+{
+	char **pdata = dev->dev.platform_data;
+	struct iio_prtc_trigger_info *trig_info;
+	struct iio_trigger *trig, *trig2;
+
+	int i, ret;
+
+	for (i = 0;; i++) {
+		if (pdata[i] == NULL)
+			break;
+		trig = iio_trigger_alloc("periodic%s", pdata[i]);
+		if (!trig) {
+			ret = -ENOMEM;
+			goto error_free_completed_registrations;
+		}
+		list_add(&trig->alloc_list, &iio_prtc_trigger_list);
+
+		trig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);
+		if (!trig_info) {
+			ret = -ENOMEM;
+			goto error_put_trigger_and_remove_from_list;
+		}
+		trig->private_data = trig_info;
+		trig->ops = &iio_prtc_trigger_ops;
+		/* RTC access */
+		trig_info->rtc
+			= rtc_class_open(pdata[i]);
+		if (trig_info->rtc == NULL) {
+			ret = -EINVAL;
+			goto error_free_trig_info;
+		}
+		trig_info->task.func = iio_prtc_trigger_poll;
+		trig_info->task.private_data = trig;
+		ret = rtc_irq_register(trig_info->rtc, &trig_info->task);
+		if (ret)
+			goto error_close_rtc;
+		trig->dev.groups = iio_trig_prtc_attr_groups;
+		ret = iio_trigger_register(trig);
+		if (ret)
+			goto error_unregister_rtc_irq;
+	}
+	return 0;
+error_unregister_rtc_irq:
+	rtc_irq_unregister(trig_info->rtc, &trig_info->task);
+error_close_rtc:
+	rtc_class_close(trig_info->rtc);
+error_free_trig_info:
+	kfree(trig_info);
+error_put_trigger_and_remove_from_list:
+	list_del(&trig->alloc_list);
+	iio_trigger_put(trig);
+error_free_completed_registrations:
+	list_for_each_entry_safe(trig,
+				 trig2,
+				 &iio_prtc_trigger_list,
+				 alloc_list) {
+		trig_info = trig->private_data;
+		rtc_irq_unregister(trig_info->rtc, &trig_info->task);
+		rtc_class_close(trig_info->rtc);
+		kfree(trig_info);
+		iio_trigger_unregister(trig);
+	}
+	return ret;
+}
+
+static int iio_trig_periodic_rtc_remove(struct platform_device *dev)
+{
+	struct iio_trigger *trig, *trig2;
+	struct iio_prtc_trigger_info *trig_info;
+	mutex_lock(&iio_prtc_trigger_list_lock);
+	list_for_each_entry_safe(trig,
+				 trig2,
+				 &iio_prtc_trigger_list,
+				 alloc_list) {
+		trig_info = trig->private_data;
+		rtc_irq_unregister(trig_info->rtc, &trig_info->task);
+		rtc_class_close(trig_info->rtc);
+		kfree(trig_info);
+		iio_trigger_unregister(trig);
+	}
+	mutex_unlock(&iio_prtc_trigger_list_lock);
+	return 0;
+}
+
+static struct platform_driver iio_trig_periodic_rtc_driver = {
+	.probe = iio_trig_periodic_rtc_probe,
+	.remove = iio_trig_periodic_rtc_remove,
+	.driver = {
+		.name = "iio_prtc_trigger",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(iio_trig_periodic_rtc_driver);
+
+MODULE_AUTHOR("Jonathan Cameron <jic23@kernel.org>");
+MODULE_DESCRIPTION("Periodic realtime clock  trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/trigger/iio-trig-sysfs.c b/drivers/iio/trigger/iio-trig-sysfs.c
new file mode 100644
index 0000000..3bac972
--- /dev/null
+++ b/drivers/iio/trigger/iio-trig-sysfs.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2011 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/irq_work.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+struct iio_sysfs_trig {
+	struct iio_trigger *trig;
+	struct irq_work work;
+	int id;
+	struct list_head l;
+};
+
+static LIST_HEAD(iio_sysfs_trig_list);
+static DEFINE_MUTEX(iio_syfs_trig_list_mut);
+
+static int iio_sysfs_trigger_probe(int id);
+static ssize_t iio_sysfs_trig_add(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf,
+				  size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = strict_strtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+	ret = iio_sysfs_trigger_probe(input);
+	if (ret)
+		return ret;
+	return len;
+}
+static DEVICE_ATTR(add_trigger, S_IWUSR, NULL, &iio_sysfs_trig_add);
+
+static int iio_sysfs_trigger_remove(int id);
+static ssize_t iio_sysfs_trig_remove(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf,
+				     size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = strict_strtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+	ret = iio_sysfs_trigger_remove(input);
+	if (ret)
+		return ret;
+	return len;
+}
+
+static DEVICE_ATTR(remove_trigger, S_IWUSR, NULL, &iio_sysfs_trig_remove);
+
+static struct attribute *iio_sysfs_trig_attrs[] = {
+	&dev_attr_add_trigger.attr,
+	&dev_attr_remove_trigger.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_sysfs_trig_group = {
+	.attrs = iio_sysfs_trig_attrs,
+};
+
+static const struct attribute_group *iio_sysfs_trig_groups[] = {
+	&iio_sysfs_trig_group,
+	NULL
+};
+
+
+/* Nothing to actually do upon release */
+static void iio_trigger_sysfs_release(struct device *dev)
+{
+}
+
+static struct device iio_sysfs_trig_dev = {
+	.bus = &iio_bus_type,
+	.groups = iio_sysfs_trig_groups,
+	.release = &iio_trigger_sysfs_release,
+};
+
+static void iio_sysfs_trigger_work(struct irq_work *work)
+{
+	struct iio_sysfs_trig *trig = container_of(work, struct iio_sysfs_trig,
+							work);
+
+	iio_trigger_poll(trig->trig, 0);
+}
+
+static ssize_t iio_sysfs_trigger_poll(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_sysfs_trig *sysfs_trig = trig->private_data;
+
+	irq_work_queue(&sysfs_trig->work);
+
+	return count;
+}
+
+static DEVICE_ATTR(trigger_now, S_IWUSR, NULL, iio_sysfs_trigger_poll);
+
+static struct attribute *iio_sysfs_trigger_attrs[] = {
+	&dev_attr_trigger_now.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_sysfs_trigger_attr_group = {
+	.attrs = iio_sysfs_trigger_attrs,
+};
+
+static const struct attribute_group *iio_sysfs_trigger_attr_groups[] = {
+	&iio_sysfs_trigger_attr_group,
+	NULL
+};
+
+static const struct iio_trigger_ops iio_sysfs_trigger_ops = {
+	.owner = THIS_MODULE,
+};
+
+static int iio_sysfs_trigger_probe(int id)
+{
+	struct iio_sysfs_trig *t;
+	int ret;
+	bool foundit = false;
+	mutex_lock(&iio_syfs_trig_list_mut);
+	list_for_each_entry(t, &iio_sysfs_trig_list, l)
+		if (id == t->id) {
+			foundit = true;
+			break;
+		}
+	if (foundit) {
+		ret = -EINVAL;
+		goto out1;
+	}
+	t = kmalloc(sizeof(*t), GFP_KERNEL);
+	if (t == NULL) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+	t->id = id;
+	t->trig = iio_trigger_alloc("sysfstrig%d", id);
+	if (!t->trig) {
+		ret = -ENOMEM;
+		goto free_t;
+	}
+
+	t->trig->dev.groups = iio_sysfs_trigger_attr_groups;
+	t->trig->ops = &iio_sysfs_trigger_ops;
+	t->trig->dev.parent = &iio_sysfs_trig_dev;
+	t->trig->private_data = t;
+
+	init_irq_work(&t->work, iio_sysfs_trigger_work);
+
+	ret = iio_trigger_register(t->trig);
+	if (ret)
+		goto out2;
+	list_add(&t->l, &iio_sysfs_trig_list);
+	__module_get(THIS_MODULE);
+	mutex_unlock(&iio_syfs_trig_list_mut);
+	return 0;
+
+out2:
+	iio_trigger_put(t->trig);
+free_t:
+	kfree(t);
+out1:
+	mutex_unlock(&iio_syfs_trig_list_mut);
+	return ret;
+}
+
+static int iio_sysfs_trigger_remove(int id)
+{
+	bool foundit = false;
+	struct iio_sysfs_trig *t;
+	mutex_lock(&iio_syfs_trig_list_mut);
+	list_for_each_entry(t, &iio_sysfs_trig_list, l)
+		if (id == t->id) {
+			foundit = true;
+			break;
+		}
+	if (!foundit) {
+		mutex_unlock(&iio_syfs_trig_list_mut);
+		return -EINVAL;
+	}
+
+	iio_trigger_unregister(t->trig);
+	iio_trigger_free(t->trig);
+
+	list_del(&t->l);
+	kfree(t);
+	module_put(THIS_MODULE);
+	mutex_unlock(&iio_syfs_trig_list_mut);
+	return 0;
+}
+
+
+static int __init iio_sysfs_trig_init(void)
+{
+	device_initialize(&iio_sysfs_trig_dev);
+	dev_set_name(&iio_sysfs_trig_dev, "iio_sysfs_trigger");
+	return device_add(&iio_sysfs_trig_dev);
+}
+module_init(iio_sysfs_trig_init);
+
+static void __exit iio_sysfs_trig_exit(void)
+{
+	device_unregister(&iio_sysfs_trig_dev);
+}
+module_exit(iio_sysfs_trig_exit);
+
+MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_DESCRIPTION("Sysfs based trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:iio-trig-sysfs");
diff --git a/include/linux/iio/common/st_sensors.h b/include/linux/iio/common/st_sensors.h
index 337da33..56d0495 100644
--- a/include/linux/iio/common/st_sensors.h
+++ b/include/linux/iio/common/st_sensors.h
@@ -15,7 +15,6 @@
 #include <linux/spi/spi.h>
 #include <linux/irqreturn.h>
 #include <linux/iio/trigger.h>
-#include <linux/iio/events.h>
 
 #define ST_SENSORS_TX_MAX_LENGTH		2
 #define ST_SENSORS_RX_MAX_LENGTH		6
@@ -49,7 +48,6 @@
 	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
 			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
 	.scan_index = index, \
-	.channel = mod, \
 	.channel2 = mod, \
 	.address = addr, \
 	.scan_type = { \
@@ -59,7 +57,6 @@
 		.storagebits = 16, \
 		.endianness = endian, \
 	}, \
-	.event_mask = IIO_EV_BIT(IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), \
 }
 
 #define ST_SENSOR_DEV_ATTR_SAMP_FREQ() \
@@ -217,7 +214,6 @@ struct st_sensor_data {
 	struct st_sensor_fullscale_avl *current_fullscale;
 
 	bool enabled;
-	bool int_thresh;
 	bool multiread_bit;
 
 	char *buffer_data;
@@ -269,6 +265,9 @@ int st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable);
 
 int st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale);
 
+int st_sensors_read_axis_data(struct iio_dev *indio_dev,
+							u8 ch_addr, int *data);
+
 int st_sensors_read_info_raw(struct iio_dev *indio_dev,
 				struct iio_chan_spec const *ch, int *val);
 
-- 
1.7.5.4

