From 9ca5cc823c0316b4317ccce8daf31c943967ff18 Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Thu, 15 Nov 2012 13:15:00 +0000
Subject: [PATCH 1008/1187] staging:iio:ad7298: Fix temperature scale and
 offset

commit 01a10e04f8e099fea3212a70df0b25a8ffd9275f	upstream

The temperature scale and offset depend on the reference voltage, the current
formula used in the driver assumes a 2.5V reference. This patch modifies the
code to report the unprocessed value for the temperature channel "raw" property
and to provide proper "scale" and "offset" properties which depend on the
selected reference voltage.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Jonathan Cameron <jic23@kernel.org>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/staging/iio/adc/ad7298_core.c |   51 +++++++++++++++------------------
 1 files changed, 23 insertions(+), 28 deletions(-)

diff --git a/drivers/staging/iio/adc/ad7298_core.c b/drivers/staging/iio/adc/ad7298_core.c
index 6dd696f..b74b76f 100644
--- a/drivers/staging/iio/adc/ad7298_core.c
+++ b/drivers/staging/iio/adc/ad7298_core.c
@@ -45,7 +45,8 @@ static const struct iio_chan_spec ad7298_channels[] = {
 		.indexed = 1,
 		.channel = 0,
 		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT |
-		IIO_CHAN_INFO_SCALE_SEPARATE_BIT,
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT |
+			IIO_CHAN_INFO_OFFSET_SEPARATE_BIT,
 		.address = AD7298_CH_TEMP,
 		.scan_index = -1,
 		.scan_type = {
@@ -80,7 +81,7 @@ static int ad7298_scan_direct(struct ad7298_state *st, unsigned ch)
 
 static int ad7298_scan_temp(struct ad7298_state *st, int *val)
 {
-	int tmp, ret;
+	int ret;
 	__be16 buf;
 
 	buf = cpu_to_be16(AD7298_WRITE | AD7298_TSENSE |
@@ -102,24 +103,24 @@ static int ad7298_scan_temp(struct ad7298_state *st, int *val)
 	if (ret)
 		return ret;
 
-	tmp = be16_to_cpu(buf) & RES_MASK(AD7298_BITS);
+	*val = sign_extend32(be16_to_cpu(buf), 11);
 
-	/*
-	 * One LSB of the ADC corresponds to 0.25 deg C.
-	 * The temperature reading is in 12-bit twos complement format
-	 */
+	return 0;
+}
+
+static int ad7298_get_ref_voltage(struct ad7298_state *st)
+{
+	int vref;
 
-	if (tmp & (1 << (AD7298_BITS - 1))) {
-		tmp = (4096 - tmp) * 250;
-		tmp -= (2 * tmp);
+	if (st->ext_ref) {
+		vref = regulator_get_voltage(st->reg);
+		if (vref < 0)
+			return vref;
 
+		return vref / 1000;
 	} else {
-		tmp *= 250; /* temperature in milli degrees Celsius */
+		return AD7298_INTREF_mV;
 	}
-
-	*val = tmp;
-
-	return 0;
 }
 
 static int ad7298_read_raw(struct iio_dev *indio_dev,
@@ -130,7 +131,6 @@ static int ad7298_read_raw(struct iio_dev *indio_dev,
 {
 	int ret;
 	struct ad7298_state *st = iio_priv(indio_dev);
-	int scale_mv;
 
 	switch (m) {
 	case IIO_CHAN_INFO_RAW:
@@ -155,24 +155,19 @@ static int ad7298_read_raw(struct iio_dev *indio_dev,
 	case IIO_CHAN_INFO_SCALE:
 		switch (chan->type) {
 		case IIO_VOLTAGE:
-			if (st->ext_ref) {
-				scale_mv = regulator_get_voltage(st->reg);
-				if (scale_mv < 0)
-					return scale_mv;
-				scale_mv /= 1000;
-			} else {
-				scale_mv = AD7298_INTREF_mV;
-			}
-			*val =  scale_mv;
+			*val = ad7298_get_ref_voltage(st);
 			*val2 = chan->scan_type.realbits;
 			return IIO_VAL_FRACTIONAL_LOG2;
 		case IIO_TEMP:
-			*val =  1;
-			*val2 = 0;
-			return IIO_VAL_INT_PLUS_MICRO;
+			*val = ad7298_get_ref_voltage(st);
+			*val2 = 10;
+			return IIO_VAL_FRACTIONAL;
 		default:
 			return -EINVAL;
 		}
+	case IIO_CHAN_INFO_OFFSET:
+		*val = 1093 - 2732500 / ad7298_get_ref_voltage(st);
+		return IIO_VAL_INT;
 	}
 	return -EINVAL;
 }
-- 
1.7.5.4

