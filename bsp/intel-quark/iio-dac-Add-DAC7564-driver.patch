From 776fb89035a86f80084c42cd08979e50d7f117f0 Mon Sep 17 00:00:00 2001
From: Adrian Bradianu <adrian.bradianu@windriver.com>
Date: Thu, 19 Jun 2014 18:03:56 +0300
Subject: [PATCH] iio: dac: Add DAC7564 driver

This patch adds support for Texas Instruments DAC7564 quad channel
Digital to Analog Converter. DAC7564 driver capabilities:
- read/write raw output voltage
- set/get power down state
- set/get power down mode
- get available power down modes

Signed-off-by: Adrian Bradianu <adrian.bradianu@windriver.com>
---
 drivers/iio/dac/Kconfig               |   10 +
 drivers/iio/dac/Makefile              |    1 +
 drivers/iio/dac/dac7564.c             |  420 +++++++++++++++++++++++++++++++++
 include/linux/platform_data/dac7564.h |   21 ++
 4 files changed, 452 insertions(+), 0 deletions(-)
 create mode 100644 drivers/iio/dac/dac7564.c
 create mode 100644 include/linux/platform_data/dac7564.h

diff --git a/drivers/iio/dac/Kconfig b/drivers/iio/dac/Kconfig
index f4a6f08..18cf811 100644
--- a/drivers/iio/dac/Kconfig
+++ b/drivers/iio/dac/Kconfig
@@ -130,6 +130,16 @@ config AD5686
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad5686.
 
+config DAC7564
+	tristate "Texas Instruments DAC7564 DAC driver"
+	depends on SPI_MASTER
+	help
+	  Say yes here to build support for Texas Instruments DAC7564
+	  quad channel Digital to Analog Converter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called dac7564.
+
 config MAX517
 	tristate "Maxim MAX517/518/519 DAC driver"
 	depends on I2C
diff --git a/drivers/iio/dac/Makefile b/drivers/iio/dac/Makefile
index 5b528eb..247ab94 100644
--- a/drivers/iio/dac/Makefile
+++ b/drivers/iio/dac/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_AD5791) += ad5791.o
 obj-$(CONFIG_AD5686) += ad5686.o
 obj-$(CONFIG_MAX517) += max517.o
 obj-$(CONFIG_MCP4725) += mcp4725.o
+obj-$(CONFIG_DAC7564) += dac7564.o
\ No newline at end of file
diff --git a/drivers/iio/dac/dac7564.c b/drivers/iio/dac/dac7564.c
new file mode 100644
index 0000000..77ce6ef
--- /dev/null
+++ b/drivers/iio/dac/dac7564.c
@@ -0,0 +1,420 @@
+/*
+ * Copyright (C) 2014 Wind River Systems
+ * Copyright (C) 2012 Analog Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Wind River Systems, Inc
+ */
+/*
+ * DAC7564 Quad channel, Digital to analog converter driver
+ *
+ * Author : Adrian Bradianu <adrian.bradianu@windriver.com>
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/platform_data/dac7564.h>
+
+#define DAC7564_NUM_CHANNELS		4
+
+/* Channel number to channel address mapping */
+#define DAC7564_CHAN_ADDR(x)		(x)
+
+/* Set device adress */
+#define DAC7564_ADDR(x)			((x) << 22)
+
+/* Load command and mode */
+#define DAC7564_LD(x)			((x) << 20)
+#define DAC7564_LD_CHAN_UPDATE		1
+
+/* Set DAC channel */
+#define DAC7564_DAC(x)			((x) << 17)
+
+/* Power down commands and modes */
+#define DAC7564_PD(x)			((x) << 16)
+#define DAC7564_PD0_BIT			(1 << 16)
+#define DAC7564_PD_MODE_SHIFT		14
+#define DAC7564_PD_MODE_1K		1
+#define DAC7564_PD_MODE_100K		2
+#define DAC7564_PD_MODE_3STATE		3
+
+/* Internal reference voltage ena/dis commands */
+#define DAC7564_INT_REF_ENA		0x10000
+#define DAC7564_INT_REF_DIS		0x12000
+
+/**
+ * struct dac7564_chip_info - chip specific information
+ * @channel_template:	channel specification
+ */
+struct dac7564_chip_info {
+	const struct iio_chan_spec channel_template;
+};
+
+/**
+ * struct dac7564_state - driver instance specific data
+ * @spi: spi device the driver is attached to
+ * @chip_info: chip model specific constants, available modes etc
+ * @address: device address
+ * @pwr_down_mode: channel's current power down mode
+ * @shift_reg: software shadow of the channel's shift register
+ */
+struct dac7564_state {
+	struct spi_device		*spi;
+	const struct dac7564_chip_info	*chip_info;
+	u8				address;
+	u8				pwr_down_mode[DAC7564_NUM_CHANNELS];
+	u32				shift_reg[DAC7564_NUM_CHANNELS];
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 */
+
+	union {
+		u32 d32;
+		u8 d8[4];
+	} data[2] ____cacheline_aligned;
+};
+
+enum dac7564_type {
+	ID_DAC7564,
+};
+
+static int dac7564_write_unlocked(struct iio_dev *indio_dev,
+	u32 shift_reg)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+
+	st->data[0].d32 = cpu_to_be32(shift_reg);
+
+	return spi_write(st->spi, &st->data[0].d8[1], 3);
+}
+
+static int dac7564_write(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, bool pd, unsigned int data)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+	int  ret;
+	u32 shift_reg;
+
+	mutex_lock(&indio_dev->mlock);
+
+	/*
+	 * The input shift register is 24 bits wide.
+	 * Bits 23-22: address bits
+	 * Bits 21-20: load type bits
+	 * Bits 19: not used
+	 * Bits 18-17: DAC channel select
+	 * Bits 16: power down bit
+	 * Bits 15-4: data/power down mode bits
+	 * Bits 3-0: not used
+	 */
+
+	shift_reg = DAC7564_ADDR(st->address) | DAC7564_DAC(chan->address) |
+		DAC7564_LD(DAC7564_LD_CHAN_UPDATE) | DAC7564_PD(pd);
+
+	if (pd)
+		shift_reg |= data << DAC7564_PD_MODE_SHIFT;
+	else
+		shift_reg |= data << chan->scan_type.shift;
+
+	ret = dac7564_write_unlocked(indio_dev, shift_reg);
+
+	/* Save data for read */
+	if (ret >= 0) {
+		st->shift_reg[chan->channel] = shift_reg;
+		if (pd)
+			st->pwr_down_mode[chan->channel] = data;
+	}
+
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+static int dac7564_write_raw(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, int val, int val2, long info)
+{
+	int max_val = (1 << chan->scan_type.realbits);
+	int ret;
+
+	switch (info) {
+	case IIO_CHAN_INFO_RAW:
+		if (val < 0 || val >= max_val)
+			return -EINVAL;
+
+		ret = dac7564_write(indio_dev, chan, false, val);
+
+		return ret;
+	}
+
+	return -EINVAL;
+}
+
+static int dac7564_read_raw(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, int *val, int *val2, long info)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+
+	switch (info) {
+	case IIO_CHAN_INFO_RAW:
+		*val = (st->shift_reg[chan->channel] >> chan->scan_type.shift) &
+			((1 << chan->scan_type.realbits) - 1);
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const char * const dac7564_powerdown_modes[] = {
+	"1kohm_to_gnd",
+	"100kohm_to_gnd",
+	"three_state",
+};
+
+static int dac7564_get_powerdown_mode(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+
+	return st->pwr_down_mode[chan->channel] - 1;
+}
+
+static int dac7564_set_powerdown_mode(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, unsigned int mode)
+{
+	int ret;
+
+	ret = dac7564_write(indio_dev, chan, true, mode + 1);
+
+	return ret;
+}
+
+static const struct iio_enum dac7564_powerdown_mode_enum = {
+	.items = dac7564_powerdown_modes,
+	.num_items = ARRAY_SIZE(dac7564_powerdown_modes),
+	.get = dac7564_get_powerdown_mode,
+	.set = dac7564_set_powerdown_mode,
+};
+
+static ssize_t dac7564_read_powerdown(struct iio_dev *indio_dev, uintptr_t priv,
+	const struct iio_chan_spec *chan, char *buf)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+
+	return sprintf(buf, "%d\n",
+		       (bool)(st->shift_reg[chan->channel] & DAC7564_PD0_BIT));
+}
+
+static ssize_t dac7564_write_powerdown(struct iio_dev *indio_dev, uintptr_t priv,
+	struct iio_chan_spec const *chan, const char *buf, size_t len)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+	bool pwr_down;
+	int ret;
+
+	ret = strtobool(buf, &pwr_down);
+	if (ret)
+		return ret;
+
+	ret = dac7564_write(indio_dev, chan, pwr_down,
+			st->pwr_down_mode[chan->channel]);
+
+	return ret ? ret : len;
+}
+
+static int __devinit dac7564_setup_pdata(struct iio_dev *indio_dev,
+	const struct dac7564_platform_data *pdata)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+	int ret;
+
+	/* Get device address from platform data */
+	st->address = pdata->address;
+
+	if (pdata->int_vref) {
+		/* Write command for enabling internal reference */
+		ret = dac7564_write_unlocked(indio_dev, DAC7564_INT_REF_ENA);
+	} else {
+		/* Write command for disabling internal reference */
+		ret = dac7564_write_unlocked(indio_dev, DAC7564_INT_REF_DIS);
+	}
+
+	return 0;
+}
+
+static const struct iio_info dac7564_info = {
+	.read_raw = dac7564_read_raw,
+	.write_raw = dac7564_write_raw,
+	.driver_module = THIS_MODULE,
+};
+
+static const struct iio_chan_spec_ext_info dac7564_ext_info[] = {
+	{
+		.name = "powerdown",
+		.read = dac7564_read_powerdown,
+		.write = dac7564_write_powerdown,
+	},
+	IIO_ENUM("powerdown_mode", false, &dac7564_powerdown_mode_enum),
+	IIO_ENUM_AVAILABLE("powerdown_mode", &dac7564_powerdown_mode_enum),
+	{ },
+};
+
+#define DAC7564_CHANNEL(_bits) {				\
+	.type = IIO_VOLTAGE,					\
+	.indexed = 1,						\
+	.output = 1,						\
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT, 		\
+	.scan_type = IIO_ST('u', (_bits), 16, 16 - (_bits)),	\
+	.ext_info = dac7564_ext_info,				\
+}
+
+static const struct dac7564_chip_info dac7564_chip_info_tbl[] = {
+	[ID_DAC7564] = {
+		.channel_template = DAC7564_CHANNEL(12),
+	},
+};
+
+static const struct dac7564_platform_data dac7564_default_pdata = {
+	.address = 0,
+	.int_vref = true
+};
+
+static int __devinit dac7564_alloc_channels(struct iio_dev *indio_dev)
+{
+	struct dac7564_state *st = iio_priv(indio_dev);
+	struct iio_chan_spec *channels;
+	unsigned int i;
+
+	channels = kcalloc(indio_dev->num_channels,
+			   sizeof(struct iio_chan_spec), GFP_KERNEL);
+
+	if (!channels)
+		return -ENOMEM;
+
+	for (i = 0; i < indio_dev->num_channels; ++i) {
+		channels[i] = st->chip_info->channel_template;
+		channels[i].channel = i;
+		channels[i].address = DAC7564_CHAN_ADDR(i);
+	}
+
+	indio_dev->channels = channels;
+
+	return 0;
+}
+
+static int __devinit dac7564_probe(struct spi_device *spi)
+{
+	enum dac7564_type type = spi_get_device_id(spi)->driver_data;
+	const struct dac7564_platform_data *pdata = dev_get_platdata(&spi->dev);
+	struct iio_dev *indio_dev;
+	struct dac7564_state *st;
+	int ret, i;
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (indio_dev == NULL) {
+		dev_err(&spi->dev, "Failed to allocate iio device\n");
+		return  -ENOMEM;
+	}
+
+	st = iio_priv(indio_dev);
+	spi_set_drvdata(spi, indio_dev);
+
+	st->chip_info = &dac7564_chip_info_tbl[type];
+	st->spi = spi;
+
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->info = &dac7564_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->num_channels = DAC7564_NUM_CHANNELS;
+
+	ret = dac7564_alloc_channels(indio_dev);
+	if (ret) {
+		dev_err(&spi->dev, "Failed to allocate channels: %d\n", ret);
+		goto error_free;
+	}
+
+	for (i = 0; i < indio_dev->num_channels; ++i) {
+		st->pwr_down_mode[i] = DAC7564_PD_MODE_1K;
+	}
+
+	if (!pdata)
+		pdata = &dac7564_default_pdata;
+
+	ret = dac7564_setup_pdata(indio_dev, pdata);
+	if (ret)
+		goto error_free_channels;
+
+	ret = iio_device_register(indio_dev);
+	if (ret) {
+		dev_err(&spi->dev, "Failed to register iio device: %d\n", ret);
+		goto error_free_channels;
+	}
+
+	dev_info(&spi->dev, "DAC7564 DAC registered\n");
+
+	return 0;
+
+error_free_channels:
+	kfree(indio_dev->channels);
+error_free:
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+static int __devexit dac7564_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+
+	iio_device_unregister(indio_dev);
+
+	kfree(indio_dev->channels);
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+static const struct spi_device_id dac7564_id[] = {
+	{ "dac7564", ID_DAC7564 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(spi, dac7564_id);
+
+static struct spi_driver dac7564_driver = {
+	.driver = {
+		.name = "dac7564",
+		.owner = THIS_MODULE,
+	},
+	.probe = dac7564_probe,
+	.remove = __devexit_p(dac7564_remove),
+	.id_table = dac7564_id,
+};
+module_spi_driver(dac7564_driver);
+
+MODULE_AUTHOR("Adrian Bradianu <adrian.bradianu@windriver.com>");
+MODULE_DESCRIPTION("Texas Instruments DAC7564 DAC");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/platform_data/dac7564.h b/include/linux/platform_data/dac7564.h
new file mode 100644
index 0000000..63a6f8f
--- /dev/null
+++ b/include/linux/platform_data/dac7564.h
@@ -0,0 +1,21 @@
+/*
+ * DAC7564 Quad channel, Digital to analog converter
+ *
+ * Copyright (C) 2014 Wind River Systems
+ *
+ * Licensed under the GPL-2.
+ */
+#ifndef __LINUX_PLATFORM_DATA_DAC7564_H__
+#define __LINUX_PLATFORM_DATA_DAC7564_H__
+
+/**
+ * struct dac7564_platform_data - DAC7564 DAC driver platform data
+ * @address: DAC7564 address on SPI bus.
+ * @int_vref: Whether internal reference voltage is used.
+ **/
+struct dac7564_platform_data {
+	u8 address;
+	bool int_vref;
+};
+
+#endif
-- 
1.7.5.4

