From 90821d45265a32e6932b36c4f8bcc4decda08754 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Thu, 10 Oct 2013 09:31:41 +0800
Subject: [PATCH 1171/1187] Quark: add GIP support.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/i2c/busses/Kconfig                 |    2 +-
 drivers/i2c/busses/i2c-designware-core.c   |   96 ++-
 drivers/i2c/busses/i2c-designware-core.h   |   12 +
 drivers/i2c/busses/i2c-designware-pcidrv.c |   18 +-
 drivers/mfd/Kconfig                        |   30 +
 drivers/mfd/Makefile                       |    6 +
 drivers/mfd/intel_cln_gip.h                |  101 +++
 drivers/mfd/intel_cln_gip_core.c           |  327 ++++++++
 drivers/mfd/intel_cln_gip_gpio.c           |  659 +++++++++++++++
 drivers/mfd/intel_cln_gip_i2c.c            |  204 +++++
 drivers/mfd/intel_cln_gip_test.c           | 1202 ++++++++++++++++++++++++++++
 drivers/mfd/lpc_sch.c                      |   76 ++-
 12 files changed, 2704 insertions(+), 29 deletions(-)
 create mode 100644 drivers/mfd/intel_cln_gip.h
 create mode 100644 drivers/mfd/intel_cln_gip_core.c
 create mode 100644 drivers/mfd/intel_cln_gip_gpio.c
 create mode 100644 drivers/mfd/intel_cln_gip_i2c.c
 create mode 100644 drivers/mfd/intel_cln_gip_test.c

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 7b197ca..a60f472 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -370,7 +370,7 @@ config I2C_DESIGNWARE_PLATFORM
 
 config I2C_DESIGNWARE_PCI
 	tristate "Synopsys DesignWare PCI"
-	depends on PCI
+	depends on PCI && !INTEL_CLN_SOC
 	select I2C_DESIGNWARE_CORE
 	help
 	  If you say yes to this option, support will be included for the
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index 6193349..f90cbe0 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -163,6 +163,29 @@ static char *abort_sources[] = {
 		"lost arbitration",
 };
 
+/*
+ * Bitmask for struct i2c_dw_data_cmd's `cmd' field.
+ * - DW_IC_CMD_READ:  read/~write operation
+ * - DW_IC_CMD_STOP:  stop condition generation (only for devices requiring
+ *   explicit transaction termination)
+ * - DW_IC_CMD_RESTART:  (re)start condition generation (only for devices
+ *   requiring explicit transaction termination)
+ */
+#define DW_IC_CMD_READ			0x01
+#define DW_IC_CMD_STOP			0x02
+#define DW_IC_CMD_RESTART		0x04
+
+/*
+ * Define the IC_DATA_CMD format.
+ */
+static union i2c_dw_data_cmd {
+	struct fields {
+		u8 data;
+		u8 cmd;
+	} fields;
+	u16 value;
+} data_cmd;
+
 u32 dw_readl(struct dw_i2c_dev *dev, int offset)
 {
 	u32 value = readl(dev->base + offset);
@@ -368,6 +391,7 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 	u32 addr = msgs[dev->msg_write_idx].addr;
 	u32 buf_len = dev->tx_buf_len;
 	u8 *buf = dev->tx_buf;
+	int segment_start = 0;
 
 	intr_mask = DW_IC_INTR_DEFAULT_MASK;
 
@@ -391,21 +415,65 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 			break;
 		}
 
+		segment_start = 0;
 		if (!(dev->status & STATUS_WRITE_IN_PROGRESS)) {
 			/* new i2c_msg */
 			buf = msgs[dev->msg_write_idx].buf;
 			buf_len = msgs[dev->msg_write_idx].len;
+			segment_start = 1;
 		}
 
 		tx_limit = dev->tx_fifo_depth - dw_readl(dev, DW_IC_TXFLR);
 		rx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);
 
+		/*
+		 * The maximum number of read requests that can be put into TX
+		 * FIFO depends on the number read operations already pending
+		 * in RX FIFO + the number of outstanding read operations still
+		 * queued in the TX FIFO.
+		 * This prevents RX FIFO overrun.
+		 */
+		rx_limit -= dev->rx_outstanding;
+
 		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
+			data_cmd.fields.data = 0x00;
+			data_cmd.fields.cmd = 0x00;
+
 			if (msgs[dev->msg_write_idx].flags & I2C_M_RD) {
-				dw_writel(dev, 0x100, DW_IC_DATA_CMD);
+				/* Master-receiver */
+				data_cmd.fields.cmd = DW_IC_CMD_READ;
 				rx_limit--;
-			} else
-				dw_writel(dev, *buf++, DW_IC_DATA_CMD);
+				dev->rx_outstanding++;
+			} else {
+				/* Master-transmitter */
+				data_cmd.fields.data = *buf;
+				buf++;
+			}
+
+			if (1 == dev->explicit_stop
+			    && 1 == segment_start) {
+				/*
+				 * First byte of a transaction segment for a
+				 * device requiring explicit transaction
+				 * termination: generate (re)start symbol.
+				 */
+				segment_start = 0;
+				data_cmd.fields.cmd |= DW_IC_CMD_RESTART;
+			}
+
+			if (1 == dev->explicit_stop
+			    && dev->msg_write_idx == dev->msgs_num - 1
+			    && 1 == buf_len) {
+				/*
+				 * Last byte of last transction segment for a
+				 * device requiring explicit transaction
+				 * termination: generate stop symbol.
+				 */
+				data_cmd.fields.cmd |= DW_IC_CMD_STOP;
+			}
+
+			dw_writel(dev, data_cmd.value, DW_IC_DATA_CMD);
+
 			tx_limit--; buf_len--;
 		}
 
@@ -456,8 +524,10 @@ i2c_dw_read(struct dw_i2c_dev *dev)
 
 		rx_valid = dw_readl(dev, DW_IC_RXFLR);
 
-		for (; len > 0 && rx_valid > 0; len--, rx_valid--)
+		for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
 			*buf++ = dw_readl(dev, DW_IC_DATA_CMD);
+			dev->rx_outstanding--;
+		}
 
 		if (len > 0) {
 			dev->status |= STATUS_READ_IN_PROGRESS;
@@ -515,6 +585,7 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	dev->msg_err = 0;
 	dev->status = STATUS_IDLE;
 	dev->abort_source = 0;
+	dev->rx_outstanding = 0;
 
 	ret = i2c_dw_wait_bus_not_busy(dev);
 	if (ret < 0)
@@ -613,8 +684,6 @@ static u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)
 		dw_readl(dev, DW_IC_CLR_RX_DONE);
 	if (stat & DW_IC_INTR_ACTIVITY)
 		dw_readl(dev, DW_IC_CLR_ACTIVITY);
-	if (stat & DW_IC_INTR_STOP_DET)
-		dw_readl(dev, DW_IC_CLR_STOP_DET);
 	if (stat & DW_IC_INTR_START_DET)
 		dw_readl(dev, DW_IC_CLR_START_DET);
 	if (stat & DW_IC_INTR_GEN_CALL)
@@ -665,8 +734,21 @@ irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)
 	 * the current transmit status.
 	 */
 
+	/*
+	 * Process stop condition after the last transaction segment is
+	 * transmitted (and received if appropriate).
+	 */
+	if (dev->msgs_num == dev->msg_write_idx
+		&& (DW_IC_INTR_STOP_DET & dw_readl(dev, DW_IC_INTR_STAT))
+		&& 0 == dw_readl(dev, DW_IC_TXFLR)
+		&& 0 == dw_readl(dev, DW_IC_RXFLR)
+		&& 0 == dev->rx_outstanding) {
+			dw_readl(dev, DW_IC_CLR_STOP_DET);
+			complete(&dev->cmd_complete);
+	}
+
 tx_aborted:
-	if ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)
+	if ((stat & (DW_IC_INTR_TX_ABRT)) || dev->msg_err)	
 		complete(&dev->cmd_complete);
 
 	return IRQ_HANDLED;
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index 02d1a2d..3d920b5 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -34,6 +34,14 @@
 #define DW_IC_CON_RESTART_EN		0x20
 #define DW_IC_CON_SLAVE_DISABLE		0x40
 
+struct dw_pci_controller {
+	u32 bus_num;
+	u32 bus_cfg;
+	u32 tx_fifo_depth;
+	u32 rx_fifo_depth;
+	u32 clk_khz;
+	u8  explicit_stop;
+};
 
 /**
  * struct dw_i2c_dev - private i2c-designware data
@@ -60,6 +68,8 @@
  * @adapter: i2c subsystem adapter node
  * @tx_fifo_depth: depth of the hardware tx fifo
  * @rx_fifo_depth: depth of the hardware rx fifo
+ * @rx_outstanding: current outstanding master-receiver bytes in TX FIFO
+ * @explicit_stop: set to 1 if hardware requires explicit stop bit transmission
  */
 struct dw_i2c_dev {
 	struct device		*dev;
@@ -88,6 +98,8 @@ struct dw_i2c_dev {
 	u32			master_cfg;
 	unsigned int		tx_fifo_depth;
 	unsigned int		rx_fifo_depth;
+	int			rx_outstanding;
+	u8			explicit_stop;
 };
 
 extern u32 dw_readl(struct dw_i2c_dev *dev, int offset);
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index 00e8f21..d33ba8f 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -56,14 +56,6 @@ enum dw_pci_ctl_id_t {
 	medfield_5,
 };
 
-struct dw_pci_controller {
-	u32 bus_num;
-	u32 bus_cfg;
-	u32 tx_fifo_depth;
-	u32 rx_fifo_depth;
-	u32 clk_khz;
-};
-
 #define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
 				DW_IC_CON_SLAVE_DISABLE |	\
 				DW_IC_CON_RESTART_EN)
@@ -75,6 +67,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[moorestown_1] = {
 		.bus_num     = 1,
@@ -82,6 +75,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[moorestown_2] = {
 		.bus_num     = 2,
@@ -89,6 +83,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_0] = {
 		.bus_num     = 0,
@@ -96,6 +91,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_1] = {
 		.bus_num     = 1,
@@ -103,6 +99,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_2] = {
 		.bus_num     = 2,
@@ -110,6 +107,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_3] = {
 		.bus_num     = 3,
@@ -117,6 +115,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_4] = {
 		.bus_num     = 4,
@@ -124,6 +123,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 	[medfield_5] = {
 		.bus_num     = 5,
@@ -131,6 +131,7 @@ static struct  dw_pci_controller  dw_pci_controllers[] = {
 		.tx_fifo_depth = 32,
 		.rx_fifo_depth = 32,
 		.clk_khz      = 25000,
+		.explicit_stop = 0,
 	},
 };
 static struct i2c_algorithm i2c_dw_algo = {
@@ -282,6 +283,7 @@ const struct pci_device_id *id)
 
 	dev->tx_fifo_depth = controller->tx_fifo_depth;
 	dev->rx_fifo_depth = controller->rx_fifo_depth;
+	dev->explicit_stop = controller->explicit_stop;
 	r = i2c_dw_init(dev);
 	if (r)
 		goto err_iounmap;
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 554ad25..4f0ee2d 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -740,6 +740,36 @@ config MFD_TIMBERDALE
 	The timberdale FPGA can be found on the Intel Atom development board
 	for in-vehicle infontainment, called Russellville.
 
+config INTEL_CLN_GIP
+	tristate "Intel Clanton GIP"
+	depends on PCI && X86 && INTEL_CLN_SOC
+	depends on I2C
+	select GENERIC_IRQ_CHIP
+	help
+	  GIP driver for Clanton SoC.
+	  Clanton GIP is a single PCI function exporting a GPIO and an I2C
+	  controller, namely Synopsys DesignWare GPIO and Synopsys DesignWare
+	  I2C. The GPIO interface exports a total amount of 8 interrupt-capable
+	  GPIO.
+
+config INTEL_CLN_GIP_TEST
+	tristate "Intel Clanton GIP support for Integration Testing"
+	depends on INTEL_CLN_GIP
+	depends on INTEL_CLN_SOC_FPGAEMU || INTEL_CLN_SOC_SVP
+	select I2C_CHARDEV
+	select GPIO_SYSFS
+	select SPI
+	select SPI_BITBANG
+	select SPI_GPIO
+	select SPI_MASTER
+	select SPI_SPIDEV
+	help
+	  Clanton GIP automated Integration Testing package.
+	  It selects kernel components needed for GPIO and I2C tests as per
+	  Integration Test Specification, and it also adds a kernel-space
+	  facility for testing the GPIO.
+	  Note this module is also used to test the Clanton Legacy GPIO.
+
 config LPC_SCH
 	tristate "Intel SCH LPC"
 	depends on PCI
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 53b594b..fcc6f4f 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -98,6 +98,12 @@ obj-$(CONFIG_AB8500_I2C_CORE)	+= ab8500-i2c.o
 obj-$(CONFIG_MFD_DB5500_PRCMU)	+= db5500-prcmu.o
 obj-$(CONFIG_MFD_TIMBERDALE)    += timberdale.o
 obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
+obj-$(CONFIG_INTEL_CLN_GIP)	+= intel_cln_gip.o
+intel_cln_gip-objs		:= intel_cln_gip_core.o \
+					intel_cln_gip_gpio.o \
+					intel_cln_gip_i2c.o \
+					../i2c/busses/i2c-designware-core.o
+obj-$(CONFIG_INTEL_CLN_GIP_TEST)+=intel_cln_gip_test.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
 obj-$(CONFIG_MFD_JANZ_CMODIO)	+= janz-cmodio.o
diff --git a/drivers/mfd/intel_cln_gip.h b/drivers/mfd/intel_cln_gip.h
new file mode 100644
index 0000000..18ab774
--- /dev/null
+++ b/drivers/mfd/intel_cln_gip.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton GIP (GPIO/I2C) driver
+ */
+
+#ifndef __INTEL_CLNGIP_H__
+#define __INTEL_CLNGIP_H__
+
+#include <linux/i2c.h>
+#include <linux/pci.h>
+#include "../i2c/busses/i2c-designware-core.h"
+
+/* PCI BAR for register base address */
+#define GIP_I2C_BAR		0
+#define GIP_GPIO_BAR		1
+
+/**
+ * intel_cln_gpio_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_cln_gpio_probe(struct pci_dev *pdev);
+
+/**
+ * intel_cln_gpio_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_cln_gpio_remove(struct pci_dev *pdev);
+
+/**
+ * intel_cln_gpio_isr
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: used to distinguish the device (for shared interrupts)
+ *
+ * Perform GPIO-specific ISR of the top-level GIP driver.
+ */
+irqreturn_t intel_cln_gpio_isr(int irq, void *dev_id);
+
+/**
+ * intel_cln_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_cln_gpio_save_state(void);
+
+/**
+ * intel_cln_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_cln_gpio_restore_state(void);
+
+/**
+ * intel_cln_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_cln_i2c_probe(struct pci_dev *pdev, 
+			struct dw_i2c_dev **drvdata);
+
+/**
+ * intel_cln_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data 
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_cln_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev);
+
+#endif /* __INTEL_CLNGIP_H__ */
diff --git a/drivers/mfd/intel_cln_gip_core.c b/drivers/mfd/intel_cln_gip_core.c
new file mode 100644
index 0000000..7464b32
--- /dev/null
+++ b/drivers/mfd/intel_cln_gip_core.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton GIP (GPIO/I2C) PCI driver
+ *
+ *  PCI glue logic for Clanton GIP driver.
+ *  Clanton GIP is a single PCI function exporting a GPIO and an I2C device.
+ *  The PCI driver performs the bus-dependent probe/release operations, and
+ *  call into GPIO/I2C specific modules for handling the two diffrerent
+ *  functionalities.
+ */
+
+#include <asm/cln.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_cln_gip.h"
+
+static unsigned int enable_msi = 1;
+module_param(enable_msi, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+static unsigned int i2c = 1;
+module_param(i2c, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(i2c, "Register I2C adapter");
+
+static unsigned int gpio = 1;
+module_param(gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio, "Register GPIO chip");
+
+/* GIP private data, supporting only a single instance of the device. */
+struct intel_cln_gip_data {
+	struct pci_dev *pci_device;
+	struct dw_i2c_dev *i2c_drvdata;
+};
+
+/**
+ * intel_cln_gip_handler
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: device private data
+ *
+ * Top-level interrupt handler for GIP driver.
+ * It calls into the appropriate sub-routines and gathers the return values.
+ */
+static irqreturn_t intel_cln_gip_handler(int irq, void *dev_id)
+{
+	irqreturn_t ret_i2c = IRQ_NONE;
+	irqreturn_t ret_gpio = IRQ_NONE;
+	struct intel_cln_gip_data *data = (struct intel_cln_gip_data *)dev_id;
+
+	mask_pvm(data->pci_device);
+
+	if (likely(i2c)) {
+		/* Only I2C gets platform data */
+		ret_i2c = i2c_dw_isr(irq, data->i2c_drvdata);
+	}
+
+	if (likely(gpio)) {
+		ret_gpio = intel_cln_gpio_isr(irq, NULL);
+	}
+
+	unmask_pvm(data->pci_device);
+
+	if (likely(IRQ_HANDLED == ret_i2c || IRQ_HANDLED == ret_gpio))
+		return IRQ_HANDLED;
+
+	/* Each sub-ISR routine returns either IRQ_HANDLED or IRQ_NONE. */
+	return IRQ_NONE;
+}
+
+static DEFINE_PCI_DEVICE_TABLE(intel_cln_gip_ids) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0934), },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_cln_gip_ids);
+
+#ifdef CONFIG_PM
+
+/**
+ * cln_gip_suspend
+ * 
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to sleep state.
+ * Save context, disable GPIO chip and I2C adapter, transition PCI device into
+ * low-power state.
+ */
+static int cln_gip_suspend(struct device *dev)
+{
+	int err = 0;
+	struct intel_cln_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
+
+	i2c_dw_disable(data->i2c_drvdata);
+	intel_cln_gpio_save_state();
+
+	err = pci_save_state(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "pci_save_state failed\n");
+		return err;
+	}
+
+	err = pci_set_power_state(pdev, PCI_D3hot);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * cln_gip_resume
+ * 
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to fully active state.
+ * Set PCI device into full-power state, restore context, enable I2C adapter
+ * and GPIO chip.
+ */
+static int cln_gip_resume(struct device *dev)
+{
+	int err = 0;
+	struct intel_cln_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
+
+	err = pci_set_power_state(pdev, PCI_D0);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
+		return err;
+	}
+
+	pci_restore_state(pdev);
+
+	intel_cln_gpio_restore_state();
+	i2c_dw_init(data->i2c_drvdata);
+
+	return 0;
+}
+
+#else
+#define cln_gip_suspend		NULL
+#define cln_gip_resume		NULL
+#endif
+
+static const struct dev_pm_ops cln_gip_pm_ops = {
+	.resume         = cln_gip_resume,
+	.suspend        = cln_gip_suspend,
+};
+
+/**
+ * intel_cln_gip_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @param id: GIP PCI Device ID
+ * @return 0 success < 0 failure
+ *
+ * GIP PCI driver probing. Calls into the appropriate probe routines for GPIO
+ * and I2C too.
+ */
+static int intel_cln_gip_probe(struct pci_dev *pdev,
+				const struct pci_device_id *id)
+{
+	int retval = 0;
+	struct intel_cln_gip_data *gip_drvdata = NULL;
+
+	retval = pci_enable_device(pdev);
+	if (retval)
+		return retval;
+
+	retval = pci_request_regions(pdev, "cln-gip");
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting PCI region\n");
+		goto err_pcidev_disable;
+	}
+
+	gip_drvdata = kzalloc(sizeof(struct intel_cln_gip_data), GFP_KERNEL);
+	if (NULL == gip_drvdata) {
+		retval = -ENOMEM;
+		goto err_pciregions_release;
+	}
+	pci_set_drvdata(pdev, gip_drvdata);
+
+	gip_drvdata->pci_device = pdev; 
+
+	if (gpio) {
+		retval = intel_cln_gpio_probe(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (i2c) {
+		retval = intel_cln_i2c_probe(pdev,
+			(struct dw_i2c_dev **)&gip_drvdata->i2c_drvdata);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (enable_msi) {
+		pci_set_master(pdev);
+		retval = pci_enable_msi(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	/*
+	 * Request a shared IRQ.
+	 * Since the dev_id cannot be NULL, it points to PCI device descriptor
+	 * if I2C is not registered.
+	 */
+	retval = request_irq(pdev->irq, intel_cln_gip_handler, IRQF_SHARED,
+			"intel_cln_gip", gip_drvdata);
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting IRQ\n");
+		goto err;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	pci_set_drvdata(pdev, NULL);
+	kfree(gip_drvdata);
+err:
+	if (enable_msi)
+		pci_disable_msi(pdev);
+err_pciregions_release:
+	pci_release_regions(pdev);
+err_pcidev_disable:
+	pci_disable_device(pdev);
+
+	return retval;
+}
+
+/**
+ * intel_cln_gip_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Release resources. Calls into GPIO/I2C dedicate routines too.
+ */
+static void intel_cln_gip_remove(struct pci_dev *pdev)
+{
+	struct intel_cln_gip_data *data = NULL;
+
+	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
+
+	if (NULL == data) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	free_irq(pdev->irq, data);
+
+	if (enable_msi) {
+		pci_clear_master(pdev);
+		if (pci_dev_msi_enabled(pdev))
+			pci_disable_msi(pdev);
+	}
+
+	if (i2c)
+		intel_cln_i2c_remove(pdev, data->i2c_drvdata);
+
+	if (gpio)
+		intel_cln_gpio_remove(pdev);
+
+	pci_set_drvdata(pdev, NULL);
+	kfree(data);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver intel_cln_gip_driver = {
+	.name =		"intel_cln_gip",
+	.id_table	= intel_cln_gip_ids,
+	.probe		= intel_cln_gip_probe,
+	.remove		= intel_cln_gip_remove,
+	.driver         = {
+		.pm     = &cln_gip_pm_ops,
+	},
+};
+
+static int intel_cln_gip_init(void)
+{
+	return pci_register_driver(&intel_cln_gip_driver);
+}
+
+static void intel_cln_gip_exit(void)
+{
+	pci_unregister_driver(&intel_cln_gip_driver);
+}
+
+module_init(intel_cln_gip_init);
+module_exit(intel_cln_gip_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Clanton GIP driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/mfd/intel_cln_gip_gpio.c b/drivers/mfd/intel_cln_gip_gpio.c
new file mode 100644
index 0000000..15d4058
--- /dev/null
+++ b/drivers/mfd/intel_cln_gip_gpio.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton GIP (GPIO/I2C) - GPIO-specific PCI and core driver
+ *
+ *  PCI glue logic and core driver for Clanton GIP/GPIO.
+ *  The GIP GPIO device is the DesignWare GPIO. This file defines the PCI glue
+ *  for this driver and as well as the core logic for the device.
+ *  Please note only a single instance of the GPIO device is supported.
+ *  The default number of GPIO is 8, all interrupt-capable.
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include "intel_cln_gip.h"
+
+static void cln_gpio_restrict_release(struct device *dev) {}
+static struct platform_device cln_gpio_restrict_pdev = 
+{
+	.name	= "cln-gpio-restrict-sc",
+	.dev.release = cln_gpio_restrict_release,
+};
+struct uio_info *info;
+
+/* The base GPIO number under GPIOLIB framework */
+#define INTEL_CLN_GIP_GPIO_BASE		8
+
+/* The default number of South-Cluster GPIO on Clanton. */
+#define INTEL_CLN_GIP_NGPIO		8
+
+/*
+ * The default base IRQ for searching and allocating the range of GPIO IRQ
+ * descriptors.
+ */
+#define INTEL_CLN_GIP_GPIO_IRQBASE	56
+
+/* The GPIO private data. */
+static struct gpio_chip *gc;
+static struct irq_chip_generic *igc;
+static void __iomem *reg_base;
+static spinlock_t lock;
+static int irq_base;
+static unsigned int n_gpio = INTEL_CLN_GIP_NGPIO;
+static unsigned int gpio_irqbase = INTEL_CLN_GIP_GPIO_IRQBASE;
+
+/* Store GPIO context across system-wide suspend/resume transitions */
+static struct gpio_saved_regs {
+	u32 data;
+	u32 dir;
+	u32 int_en;
+	u32 int_mask; 
+	u32 int_type; 
+	u32 int_pol; 
+	u32 int_deb; 
+} saved_regs;
+
+/* PortA registers set. Note other ports are unused */
+#define PORTA_DATA			0x00	/* Data */
+#define PORTA_DIR			0x04	/* Direction */
+#define PORTA_INT_EN			0x30	/* Interrupt enable */
+#define PORTA_INT_MASK			0x34	/* Interrupt mask */
+#define PORTA_INT_TYPE_LEVEL		0x38	/* Interrupt level*/
+#define PORTA_INT_POLARITY		0x3c	/* Interrupt polarity */
+#define PORTA_INT_STATUS		0x40	/* Interrupt status */
+#define PORTA_INT_RAW_STATUS		0x44	/* Interrupt raw status */
+#define PORTA_DEBOUNCE			0x48	/* Debounce enable */
+#define PORTA_INT_EOI			0x4c	/* Clear interrupt */
+#define PORTA_EXT			0x50	/* External */
+
+module_param(n_gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(n_gpio, "Number of GPIO");
+
+module_param(gpio_irqbase, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_irqbase, "Base IRQ for GPIO range");
+
+/**
+ * intel_cln_gpio_get
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return 0 if GPIO is deasserted, 1 if GPIO is asserted
+ *
+ * Read back the value of a GPIO.
+ */
+static int intel_cln_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *reg_ext = reg_base + PORTA_EXT;
+	u32 val_ext = ioread32(reg_ext);
+
+	val_ext &= BIT(offset % 32);
+	return (val_ext > 0);
+}
+
+/**
+ * intel_cln_gpio_set
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ *
+ * Set value of a GPIO.
+ */
+static void intel_cln_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	void __iomem *reg_data = reg_base + PORTA_DATA;
+	u32 val_data = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_data = ioread32(reg_data);
+	if (value)
+		iowrite32(val_data | BIT(offset % 32), reg_data);
+	else
+		iowrite32(val_data & ~BIT(offset % 32), reg_data);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_direction_input
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return always 0 (success)
+ *
+ * Set direction of a GPIO as input.
+ */
+static int intel_cln_gpio_direction_input(struct gpio_chip *chip,
+						unsigned offset)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir & ~BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_cln_gpio_direction_output
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param value: value to be driven to the GPIO
+ * @return always 0 (success)
+ *
+ * Set the default value of a GPIO, and then set direction as output.
+ */
+static int intel_cln_gpio_direction_output(struct gpio_chip *chip,
+			unsigned offset, int value)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	/* Ensure glitch-free operation. */
+	intel_cln_gpio_set(chip, offset, value);
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir | BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_cln_gpio_set_debounce
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param debounce: 1 to enable, 0 to disable
+ * @return always 0 (success)
+ *
+ * Enable/disable interrupt debounce logic for a GPIO.
+ */
+static int intel_cln_gpio_set_debounce(struct gpio_chip *chip,
+				 unsigned offset, unsigned debounce)
+{
+	u32 val_deb = 0;
+	void __iomem *reg_deb = reg_base + PORTA_DEBOUNCE;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_deb = ioread32(reg_deb);
+	if (debounce)
+		iowrite32(val_deb | BIT(offset % 32), reg_deb);
+	else
+		iowrite32(val_deb & ~BIT(offset % 32), reg_deb);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_cln_gpio_irq_type
+ * @param irq_data: Pointer to information about the IRQ
+ * @param type: set the triggering type of the interrupt
+ * @return always 0 (success)
+ *
+ * Set interrupt triggering type for a GPIO.
+ */
+static int intel_cln_gpio_irq_type(struct irq_data *d, unsigned type)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+	void __iomem *reg_level = reg_base + PORTA_INT_TYPE_LEVEL;
+	void __iomem *reg_pol = reg_base + PORTA_INT_POLARITY;
+	u32 val_level = 0;
+	u32 val_pol = 0;
+	u32 gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n",  __func__);
+		return -EFAULT;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_level = ioread32(reg_level);
+	val_pol = ioread32(reg_pol);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return ret;
+}
+
+/**
+ * intel_cln_gpio_irq_unmask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Unmask interrupts for a GPIO.
+ */
+static void intel_cln_gpio_irq_unmask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask | BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_irq_mask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Mask interrupts for a GPIO.
+ */
+static void intel_cln_gpio_irq_mask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask & ~BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_irq_enable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Enable interrupts for a GPIO.
+ */
+static void intel_cln_gpio_irq_enable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte | BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_irq_disable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Disable interrupts for a GPIO.
+ */
+static void intel_cln_gpio_irq_disable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte & ~BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_to_irq
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return IRQ associated to GPIO
+ *
+ * Compute the IRQ number based on the GPIO.
+ */
+static int intel_cln_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	return irq_base + offset;
+}
+
+/**
+ * intel_cln_gpio_isr
+ * @param irq: IRQ number
+ * @param dev_id: cookie used to tell what instance of the driver the interrupt
+ *                belongs to
+ * @return IRQ_HANDLED if interrupt served, IRQ_NONE if no interrupt pending
+ *
+ * Interrupt Service Routine for GPIO. Identify which GPIOs (if any) is pending
+ * for interrupt to be served, acknowledge the interrupt and serve it.
+ */
+irqreturn_t intel_cln_gpio_isr(int irq, void *dev_id)
+{
+	irqreturn_t ret = IRQ_NONE;
+	u32 pending = 0, gpio = 0;
+	void __iomem *reg_pending = reg_base + PORTA_INT_STATUS;
+	void __iomem *reg_eoi = reg_base + PORTA_INT_EOI;
+
+	/* Which pin (if any) triggered the interrupt */
+	while ((pending = ioread32(reg_pending))) {
+		/*
+		 * Acknowledge all the asserted GPIO interrupt lines before
+		 * serving them, so that we don't lose an edge.
+		 * This has only effect on edge-triggered interrupts.
+		 */
+		iowrite32(pending, reg_eoi);
+
+		/* Serve each asserted interrupt */
+		do {
+			gpio = __ffs(pending);
+			generic_handle_irq(
+				gpio_to_irq(INTEL_CLN_GIP_GPIO_BASE + gpio));
+			pending &= ~BIT(gpio);
+			ret = IRQ_HANDLED;
+		} while(pending);
+	}
+
+	return ret;
+}
+
+/**
+ * intel_cln_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_cln_gpio_save_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	saved_regs.int_mask = ioread32(reg_base + PORTA_INT_MASK);
+	saved_regs.int_en = ioread32(reg_base + PORTA_INT_EN);
+	saved_regs.int_deb = ioread32(reg_base + PORTA_DEBOUNCE);
+	saved_regs.int_pol = ioread32(reg_base + PORTA_INT_POLARITY);
+	saved_regs.int_type = ioread32(reg_base + PORTA_INT_TYPE_LEVEL);
+	saved_regs.dir = ioread32(reg_base + PORTA_DIR);
+	saved_regs.data = ioread32(reg_base + PORTA_DATA);
+
+	/* Mask out interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_MASK);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_cln_gpio_restore_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	iowrite32(saved_regs.data, reg_base + PORTA_DATA);
+	iowrite32(saved_regs.dir, reg_base + PORTA_DIR);
+	iowrite32(saved_regs.int_type, reg_base + PORTA_INT_TYPE_LEVEL);
+	iowrite32(saved_regs.int_pol, reg_base + PORTA_INT_POLARITY);
+	iowrite32(saved_regs.int_deb, reg_base + PORTA_DEBOUNCE);
+	iowrite32(saved_regs.int_en, reg_base + PORTA_INT_EN);
+	iowrite32(saved_regs.int_mask, reg_base + PORTA_INT_MASK);
+
+	/* Clear out spurious interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_EOI);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_cln_gpio_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ * Initiate the GPIO device.
+ */
+int intel_cln_gpio_probe(struct pci_dev *pdev)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+
+	/* Get UIO memory */
+	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	/* Determine the address of the GPIO area */
+	start = pci_resource_start(pdev, GIP_GPIO_BAR);
+	len = pci_resource_len(pdev, GIP_GPIO_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_GPIO_BAR);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (NULL == reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	memset(&saved_regs, 0x0, sizeof(saved_regs));
+
+	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
+	if (!gc) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	if (n_gpio == 0 || n_gpio > INTEL_CLN_GIP_NGPIO) {
+		dev_err(&pdev->dev, "n_gpio outside range [1,%d]\n",
+			INTEL_CLN_GIP_NGPIO);
+		retval = -EINVAL;
+		goto err_free_gpiochip;
+	}
+
+	gc->label = "intel_cln_gip_gpio";
+	gc->owner = THIS_MODULE;
+	gc->direction_input = intel_cln_gpio_direction_input;
+	gc->direction_output = intel_cln_gpio_direction_output;
+	gc->get = intel_cln_gpio_get;
+	gc->set = intel_cln_gpio_set;
+	gc->set_debounce = intel_cln_gpio_set_debounce;
+	gc->to_irq = intel_cln_gpio_to_irq;
+	gc->base = INTEL_CLN_GIP_GPIO_BASE;
+	gc->ngpio = n_gpio;
+	gc->can_sleep = 0;
+	retval = gpiochip_add(gc);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding GPIO chip\n");
+		goto err_free_gpiochip;
+	}
+
+	spin_lock_init(&lock);
+
+	/*
+	 * Allocate a range of IRQ descriptor for the available GPIO.
+	 * IRQs are allocated dynamically.
+	 */
+	irq_base = irq_alloc_descs(-1, gpio_irqbase, n_gpio, NUMA_NO_NODE);
+	if (irq_base < 0) {
+		dev_err(&pdev->dev, "failure adding GPIO IRQ descriptors\n");
+		goto err_remove_gpiochip;
+	}
+
+	retval = platform_device_register(&cln_gpio_restrict_pdev);
+	if (retval < 0){
+		goto err_free_irq_descs;
+	}
+
+	igc = irq_alloc_generic_chip("intel_cln_gip_gpio", 1, irq_base,
+			reg_base, handle_simple_irq);
+	if (NULL == igc) {
+		retval = -ENOMEM;
+		goto err_free_irq_descs;
+	}
+
+	/* UIO */
+	info->mem[0].addr = start;
+	info->mem[0].internal_addr = reg_base;
+	info->mem[0].size = len;
+	info->mem[0].memtype = UIO_MEM_PHYS;
+	info->mem[0].name = "gpio_regs";
+	info->name = "gpio uio";
+	info->version = "0.0.1";
+
+	if (uio_register_device(&pdev->dev, info))
+		goto err_free_irq_descs;
+
+	pr_info("%s UIO addr 0x%08x internal_addr 0x%08x size %lu memtype %d\n",
+		__func__, info->mem[0].addr, info->mem[0].internal_addr,
+		info->mem[0].size, info->mem[0].memtype);
+	igc->chip_types->chip.irq_mask = intel_cln_gpio_irq_mask;
+	igc->chip_types->chip.irq_unmask = intel_cln_gpio_irq_unmask;
+	igc->chip_types->chip.irq_set_type = intel_cln_gpio_irq_type;
+	igc->chip_types->chip.irq_enable = intel_cln_gpio_irq_enable;
+	igc->chip_types->chip.irq_disable = intel_cln_gpio_irq_disable;
+
+	irq_setup_generic_chip(igc, IRQ_MSK(n_gpio), IRQ_GC_INIT_MASK_CACHE,
+			IRQ_NOREQUEST | IRQ_NOPROBE, 0);
+
+	return 0;
+
+err_free_irq_descs:
+	irq_free_descs(irq_base, n_gpio);
+err_remove_gpiochip:
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+err_free_gpiochip:
+	kfree(gc);
+err_iounmap:
+	iounmap(reg_base);
+exit:
+	if (info != NULL)
+		kfree(info);
+	return retval;
+}
+
+/**
+ * intel_cln_gpio_remove
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP
+ * driver.
+ */
+void intel_cln_gpio_remove(struct pci_dev *pdev)
+{
+	if (NULL == igc) {
+		dev_err(&pdev->dev, "null pointer to irq_generic_chip\n");
+		return;
+	}
+	if (NULL == gc) {
+		dev_err(&pdev->dev, "null pointer to gpio_chip\n");
+		return;
+	}
+
+	/* Tear down IRQ descriptors */
+	irq_remove_generic_chip(igc, IRQ_MSK(n_gpio), 0,
+		IRQ_NOREQUEST | IRQ_NOPROBE);
+	kfree(igc);
+	irq_free_descs(irq_base, n_gpio);
+
+	platform_device_unregister(&cln_gpio_restrict_pdev);
+
+	/* Release GPIO chip */
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+
+
+	if (info != NULL){
+		uio_unregister_device(info);
+		iounmap(info->mem[0].internal_addr);
+		kfree(info);
+	}
+
+	kfree(gc);
+	iounmap(reg_base);
+}
diff --git a/drivers/mfd/intel_cln_gip_i2c.c b/drivers/mfd/intel_cln_gip_i2c.c
new file mode 100644
index 0000000..f2fa6a5
--- /dev/null
+++ b/drivers/mfd/intel_cln_gip_i2c.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton GIP (GPIO/I2C) - I2C-specific PCI driver
+ *
+ *  PCI glue logic for Clanton GIP/I2C.
+ *  The GIP I2C device is the DesignWare I2C. This file defines the PCI glue
+ *  for this driver and is heavily based on
+ *  on drivers/i2c/busses/i2c-designware-pcidrv.c.  Also, it relies on
+ *  drivers/i2c/busses/i2c-designware-core.c for the core logic.
+ *  Please note only a single instance of the I2C device is supported.
+ */
+
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_cln_gip.h"
+
+enum dw_pci_ctl_id_t {
+	clanton_0,
+};
+
+static unsigned int i2c_std_mode;
+module_param(i2c_std_mode, uint, S_IRUSR);
+MODULE_PARM_DESC(i2c_std_mode, "Force I2C standard mode");
+
+#define INTEL_CLN_STD_CFG  (DW_IC_CON_MASTER |			\
+				DW_IC_CON_SLAVE_DISABLE |	\
+				DW_IC_CON_RESTART_EN)
+
+static struct dw_pci_controller cln_gip_i2c_controller = {
+	.bus_num	= 0,
+	.bus_cfg	= INTEL_CLN_STD_CFG | DW_IC_CON_SPEED_FAST,
+	.tx_fifo_depth	= 16,
+	.rx_fifo_depth	= 16,
+	.clk_khz	=
+#ifdef CONFIG_INTEL_CLN_SOC_FPGAEMU
+			14000,
+#else
+			33000,
+#endif
+	.explicit_stop	= 1,
+};
+
+static struct i2c_algorithm i2c_dw_algo = {
+	.master_xfer	= i2c_dw_xfer,
+	.functionality	= i2c_dw_func,
+};
+
+/**
+ * i2c_dw_get_clk_rate_khz
+ * @param dev: Pointer to I2C device private data
+ * @return clock rate in kHz
+ *
+ * Ancillary function returning the frequency of the clock supplied to the
+ * interface.
+ */
+static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+{
+	return dev->controller->clk_khz;
+}
+
+/**
+ * intel_cln_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ * Also call into I2C core driver routines for initiating the device.
+ */
+int intel_cln_i2c_probe(struct pci_dev *pdev,
+			struct dw_i2c_dev **drvdata)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+	struct dw_i2c_dev *dev = NULL;
+	struct i2c_adapter *adap = NULL;
+	void __iomem *reg_base = NULL;
+	struct dw_pci_controller *controller = NULL;
+
+	controller = &cln_gip_i2c_controller;
+
+	/* Clanton default configuration is fast mode, unless otherwise asked */
+	if (i2c_std_mode)
+		controller->bus_cfg = INTEL_CLN_STD_CFG | DW_IC_CON_SPEED_STD;
+
+	/* Determine the address of the I2C area */
+	start = pci_resource_start(pdev, GIP_I2C_BAR);
+	len = pci_resource_len(pdev, GIP_I2C_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_I2C_BAR);
+		retval = -ENODEV;
+		goto err;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (!reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->clk = NULL;
+	dev->controller = controller;
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+	dev->base = reg_base;
+	dev->dev = get_device(&pdev->dev);
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->master_cfg =  controller->bus_cfg;
+
+	*drvdata = dev;
+
+	dev->tx_fifo_depth = controller->tx_fifo_depth;
+	dev->rx_fifo_depth = controller->rx_fifo_depth;
+	dev->explicit_stop = controller->explicit_stop;
+	retval = i2c_dw_init(dev);
+	if (retval)
+		goto err_release_drvdata;
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = 0;
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->nr = controller->bus_num;
+	snprintf(adap->name, sizeof(adap->name), "intel_cln_gip_i2c");
+
+	i2c_dw_disable_int(dev);
+	i2c_dw_clear_int(dev);
+	retval = i2c_add_numbered_adapter(adap);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding I2C adapter\n");
+		goto err_release_drvdata;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	put_device(&pdev->dev);
+	kfree(dev);
+err_iounmap:
+	iounmap(reg_base);
+err:
+	return retval;
+}
+
+/**
+ * intel_cln_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data 
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_cln_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev)
+{
+
+	if (NULL == dev) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	i2c_dw_disable(dev);
+	i2c_del_adapter(&dev->adapter);
+	iounmap(dev->base);
+
+	kfree(dev);
+}
diff --git a/drivers/mfd/intel_cln_gip_test.c b/drivers/mfd/intel_cln_gip_test.c
new file mode 100644
index 0000000..ea8d846
--- /dev/null
+++ b/drivers/mfd/intel_cln_gip_test.c
@@ -0,0 +1,1202 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton GIP (GPIO/I2C) Test module
+ *
+ * Clanton GIP + North-Cluster GPIO test module.
+ */
+
+#include <asm/tsc.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#define DRIVER_NAME			"intel_cln_gip_test"
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define GIP_TEST_IOCTL_CODE			0xE0
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_CLN_GPIO_11			_IO(GIP_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_CLN_GPIO_11_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x01)
+#define IOCTL_CLN_GPIO_12			_IO(GIP_TEST_IOCTL_CODE, 0x02)
+#define IOCTL_CLN_GPIO_12_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x03)
+#define IOCTL_CLN_GPIO_13			_IO(GIP_TEST_IOCTL_CODE, 0x04)
+#define IOCTL_CLN_GPIO_13_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x05)
+#define IOCTL_CLN_GPIO_14			_IO(GIP_TEST_IOCTL_CODE, 0x06)
+#define IOCTL_CLN_GPIO_14_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x07)
+#define IOCTL_CLN_GPIO_15			_IO(GIP_TEST_IOCTL_CODE, 0x08)
+#define IOCTL_CLN_GPIO_15_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x09)
+#define IOCTL_CLN_GPIO_16			_IO(GIP_TEST_IOCTL_CODE, 0x0A)
+#define IOCTL_CLN_GPIO_16_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0B)
+#define IOCTL_CLN_GPIO_17			_IO(GIP_TEST_IOCTL_CODE, 0x0C)
+#define IOCTL_CLN_GPIO_17_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0D)
+#define IOCTL_CLN_GPIO_19			_IO(GIP_TEST_IOCTL_CODE, 0x0E)
+#define IOCTL_CLN_GPIO_19_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0F)
+#define IOCTL_CLN_GPIO_20			_IO(GIP_TEST_IOCTL_CODE, 0x10)
+#define IOCTL_CLN_GPIO_20_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x11)
+#define IOCTL_CLN_GPIO_21			_IO(GIP_TEST_IOCTL_CODE, 0x12)
+#define IOCTL_CLN_GPIO_21_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x13)
+#define IOCTL_CLN_GPIO_24			_IO(GIP_TEST_IOCTL_CODE, 0x14)
+#define IOCTL_CLN_GPIO_26			_IO(GIP_TEST_IOCTL_CODE, 0x15)
+#define IOCTL_CLN_GPIO_26_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x16)
+/* Exercise callbacks for S0/S3 power-state transitions and vice-versa */
+#define IOCTL_CLN_GIP_SYSTEM_SUSPEND		_IO(GIP_TEST_IOCTL_CODE, 0x17)
+#define IOCTL_CLN_GIP_SYSTEM_RESUME		_IO(GIP_TEST_IOCTL_CODE, 0x18)
+
+#define GPIO_INT_EDGE_POS_LABEL			"gpio-edge-pos"
+#define GPIO_INT_EDGE_NEG_LABEL			"gpio-edge-neg"
+#define GPIO_INT_LEVEL_HIGH_LABEL		"gpio-level-hi"
+#define GPIO_INT_LEVEL_LOW_LABEL		"gpio-level-lo"
+#define GPIO_INT_BASIC_LABEL			"gpio-edge-pos-basic"
+#define GPIO_PM_TEST_IRQ_LABEL			"gpio_pm_test_irq"
+
+/*
+ * Board GPIO numbers.
+ * Mapping between the North/South cluster GPIO and GPIOLIB IDs.
+ */
+#define SUT_GPIO_NC_0				0x00
+#define SUT_GPIO_NC_1				0x01
+#define SUT_GPIO_NC_2				0x02
+#define SUT_GPIO_NC_3				0x03
+#define SUT_GPIO_NC_4				0x04
+#define SUT_GPIO_NC_5				0x05
+#define SUT_GPIO_NC_6				0x06
+#define SUT_GPIO_NC_7				0x07
+#define SUT_GPIO_SC_0				0x08
+#define SUT_GPIO_SC_1				0x09
+#define SUT_GPIO_SC_2				0x0A
+#define SUT_GPIO_SC_3				0x0B
+#define SUT_GPIO_SC_4				0x0C
+#define SUT_GPIO_SC_5				0x0D
+#define SUT_GPIO_SC_6				0x0E
+#define SUT_GPIO_SC_7				0x0F
+
+/*
+ * Bitbanged SPI bus numbers.
+ */
+#define GPIO_NC_BITBANG_SPI_BUS			0x0
+#define GPIO_SC_BITBANG_SPI_BUS			0x1
+
+/*****************************************************************************/
+
+/**
+ * struct intel_cln_gip_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_gip_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_cln_gip_test_dev gip_test_dev;
+static struct class *gip_test_class;
+static DEFINE_MUTEX(gip_test_mutex);
+static int gip_test_major;
+
+/* Private pointers to NC/SC bitbanged SPI devices */
+static struct platform_device *spi_gpio_nc_pdev = NULL;
+static struct platform_device *spi_gpio_sc_pdev = NULL;
+
+/*
+ * Level-triggered interrupt variables
+ */
+/* Level-triggered GPIO workqueue */
+static struct delayed_work work;
+/* Level-triggered interrupt counter */
+static unsigned int level_int_count;
+/* By default, a level-triggered interrupt is a low-level triggered */
+static int level_high_triggered = 0;
+
+/*
+ * Interrupt performance metrics variables and parameters
+ */
+/* How many captures */
+#define INT_PERF_TEST_CAPTURES			10000
+/* Timestamp for latency test interrupt handler */
+static cycles_t perf_t1;
+/* Captures to be returned to user space */
+static cycles_t deltas[INT_PERF_TEST_CAPTURES];
+/* Couldn't find the actual define for this */
+#define UINT64_MAX		0xFFFFFFFFFFFFFFFFULL
+
+static irqreturn_t gpio_pm_test_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_latency_handler(int irq, void *dev_id)
+{
+	/* t0 */
+	perf_t1 = get_cycles();
+
+	gpio_set_value(SUT_GPIO_SC_0, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_basic_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_pos_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_neg_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_level_handler(int irq, void *dev_id)
+{
+	/* Untrigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 0 : 1);
+
+	level_int_count ++;
+	if (level_int_count < 1000) {
+		/* Next task due in a jiffy */
+		schedule_delayed_work(&work, 1);
+	} else if (level_int_count == 1000){
+		/* OK */
+	} else {
+		/*
+		 * We may get spurious interrupts. This because the TE requires
+		 * some time to drive the actual value to the GPIO.
+		 */
+		pr_info("Spurious interrupt\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void gpio_level_drive(struct work_struct *work)
+{
+	/* TE to trigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 1 : 0);
+}
+
+/*
+ * Define bitbanged SPI interface over Nort-Cluster South-Cluster GPIO blocks.
+ * Assign GPIO to SCK/MOSI/MISO
+ */
+static struct spi_gpio_platform_data spi_gpio_nc_data = {
+	.sck = SUT_GPIO_NC_3,
+	.mosi = SUT_GPIO_NC_4,
+	.miso = SUT_GPIO_NC_5,
+	.num_chipselect = 1,
+};
+static struct spi_gpio_platform_data spi_gpio_sc_data = {
+	.sck = SUT_GPIO_SC_2,
+	.mosi = SUT_GPIO_SC_3,
+	.miso = SUT_GPIO_SC_4,
+	.num_chipselect = 1,
+};
+
+/*
+ * Board information for SPI devices.
+ */
+static struct spi_board_info spi_gpio_nc_board_info[] = {
+	{
+	.modalias	= "spidev",
+	.max_speed_hz	= 1000,
+	.bus_num	= GPIO_NC_BITBANG_SPI_BUS,
+	.mode		= SPI_MODE_0,
+	.platform_data	= &spi_gpio_nc_data,
+	/* Assign GPIO to CS */
+	.controller_data = (void *)SUT_GPIO_NC_6,
+	},
+};
+static struct spi_board_info spi_gpio_sc_board_info[] = {
+	{
+	.modalias	= "spidev",
+	.max_speed_hz	= 1000,
+	.bus_num	= GPIO_SC_BITBANG_SPI_BUS,
+	.mode		= SPI_MODE_0,
+	.platform_data	= &spi_gpio_sc_data,
+	/* Assign GPIO to CS */
+	.controller_data = (void *)SUT_GPIO_SC_5,
+	},
+};
+
+/**
+ * gpio_sc_level_int
+ *
+ * Request level triggered IRQ for SUT_GPIO_SC_6 and register
+ * SUT_GPIO_SC_7 as output GPIO.
+ * If positive equals to 0, the IRQ is high-level triggered.
+ * Otherwise, low-level triggered.
+ * Mask the IRQ if requested.
+ */
+static int gpio_sc_level_int(int positive, int masking)
+{
+	int ret = 0;
+	int irq = -1;
+
+	unsigned long out_init_val =
+		(positive ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);
+
+	level_high_triggered = positive;
+
+	/* Initialise workqueue task */
+	INIT_DELAYED_WORK(&work, gpio_level_drive);
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_hi_level");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, out_init_val, "gpio_output");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_level_handler,
+			positive ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW,
+			positive ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_LEVEL_LOW_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	level_int_count = 0;
+
+	pr_info("Registered output gpio%d and IRQ for gpio%d\n", SUT_GPIO_SC_7,
+		SUT_GPIO_SC_6);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		pr_info("Masked gpio%d IRQ\n", SUT_GPIO_SC_6);
+	}
+
+	/*
+	 * Submit task to workqueue to drive the external Test Equipment.
+	 * Note the task is delayed long enough to have Aarvark already set up.
+	 * This because Aardvark has to ignore the initial glitches during the
+	 * previous GPIO setup phase. 
+	 */
+	schedule_delayed_work(&work, 20 * HZ);
+
+	return 0;
+
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_level_int_teardown
+ *
+ * Release resources reserved by gpio_sc_level_int().
+ */
+static int gpio_sc_level_int_teardown(void)
+{
+	int irq = -1;
+
+	if (0 != cancel_delayed_work_sync(&work))
+		pr_warn("delayed work was still pending\n");
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	/* Make sure no handler is still running by this time */
+	mdelay(20);
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/*
+ * gpio_sc_interrupt_perf
+ *
+ * Performs a basic GPIO interrupt latency test by timestamping delta between
+ * interrupt driven and handled over a GPIO loopback.
+ *
+ * Returns to userspace the array of deltas obtained during each capture.
+ * A total amount of INT_PERF_TEST_CAPTURES captures is performed.
+ *
+ */
+static int gpio_sc_interrupt_perf(unsigned long user_memloc)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_1;
+	int gpio_output = SUT_GPIO_SC_0;
+	unsigned int i = 0;
+	cycles_t perf_t0 = 0;
+	cycles_t delta = 0;
+
+	/* Casting pointer to user-space location to write */
+	cycles_t __user *user_ptr = (cycles_t __user *)user_memloc;
+
+	/* Can we copy the captures array into user-space location? */
+	if (!access_ok(VERIFY_WRITE, user_ptr, sizeof(deltas))) {
+		pr_err("can't copy 0x%x bytes to user-space address 0x%p\n",
+			sizeof(deltas),user_ptr);
+		return -EFAULT;
+	}
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(gpio_output)) {
+		pr_err("gpio%d is invalid\n", gpio_output);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_intperf_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_output, GPIOF_OUT_INIT_LOW, "gpio_intperf_out");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_output, ret);
+		goto fail_release_input_gpio;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_latency_handler,
+			IRQF_TRIGGER_RISING, "gpio_latency_handler", NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+
+	/* Perform test */
+	for (i = 0; i < INT_PERF_TEST_CAPTURES; i ++) {
+		/* t0 */
+		perf_t0 = get_cycles();
+
+		/* Trigger interrupt */
+		gpio_set_value(gpio_output, 1);
+		mdelay(2);
+
+		/* Check for wrap-around and store delta */
+		if(perf_t0 < perf_t1) {
+			delta = perf_t1 - perf_t0;
+		} else {
+			delta = perf_t1 + (UINT64_MAX - perf_t0);
+		}
+		deltas[i] = delta;
+	}
+
+	/* Expose results to userspace */
+	ret = copy_to_user(user_ptr, &deltas, sizeof(deltas));
+
+	/* Release resources */
+
+	free_irq(irq, NULL);
+
+fail_release_output_gpio:
+	gpio_free(gpio_output);
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	if (0 != ret) {
+		pr_err("%s() failed\n", __func__);
+	}
+
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Request rising edge-triggered IRQ for SUT_GPIO_SC_0
+ */
+static int gpio_sc_pm_test_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_0;
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_pm_test_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_pm_test_handler,
+			IRQF_TRIGGER_RISING, GPIO_PM_TEST_IRQ_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+
+	return 0;
+
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_pm_test_int_teardown(void)
+{
+	int irq = -1;
+
+	irq = gpio_to_irq(SUT_GPIO_SC_0);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_0);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_0);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_edge_int
+ *
+ * Request IRQ for SUT_GPIO_SC_6 and SUT_GPIO_SC_7, respectively positive-edge
+ * and negative edge-triggered.
+ * Mask the IRQs if requested.
+ */
+static int gpio_sc_edge_int(int masking)
+{
+	int ret = 0;
+	int irq_pos = -1, irq_neg = -1;
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_pos_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, GPIOF_IN, "gpio_neg_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq_pos, gpio_pos_edge_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_EDGE_POS_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	if (0 != (ret = request_irq(irq_neg, gpio_neg_edge_handler,
+			IRQF_TRIGGER_FALLING, GPIO_INT_EDGE_NEG_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_7);
+		goto fail_release_first_gpio_irq;
+	}
+
+	pr_info("Registered gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+		SUT_GPIO_SC_7);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_7));
+		pr_info("Masked gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+			SUT_GPIO_SC_7);
+	}
+
+	return 0;
+
+fail_release_first_gpio_irq:
+	free_irq(irq_pos, NULL);
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_edge_int_teardown
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_edge_int_teardown(void)
+{
+	int irq_pos = -1, irq_neg = -1;
+
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+	} else {
+		free_irq(irq_neg, NULL);
+	}
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq_pos, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_basic_int
+ *
+ * Register rising-edge interrupt handler on SUT_GPIO_SC_1
+ */
+static int gpio_sc_basic_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN, "gpio_pos_edge_basic");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_basic_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_BASIC_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	pr_info("Registered gpio%d IRQ\n", gpio);
+
+	return 0;
+
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_basic_int_teardown
+ *
+ * Release resources reserved by gpio_sc_basic_int()
+ */
+static int gpio_sc_basic_int_teardown(void)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/**
+ * gpio_spidev_register
+ *
+ * Register a bitbanged SPI platform device and export a `spidev' to userspace.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_register(int north_cluster)
+{
+	int err = -ENOMEM;
+	struct platform_device *pdev = NULL;
+	struct spi_gpio_platform_data *pdata =
+		north_cluster ? &spi_gpio_nc_data : &spi_gpio_sc_data;
+	struct spi_board_info *gpio_spi_board_info = 
+		(north_cluster ? spi_gpio_nc_board_info : spi_gpio_sc_board_info);
+
+	if (north_cluster) {
+		spi_gpio_nc_pdev = NULL;
+	} else {
+		spi_gpio_sc_pdev = NULL;
+	}
+
+	pdev = platform_device_alloc("spi_gpio",
+		north_cluster ? GPIO_NC_BITBANG_SPI_BUS : GPIO_SC_BITBANG_SPI_BUS);
+	if (NULL == pdev) {
+		goto err_out;
+	}
+	err = platform_device_add_data(pdev, pdata, sizeof(*pdata));
+	if (err) {
+		goto err_put_pd;
+	}
+	err = platform_device_add(pdev);
+	if (err) {
+		goto err_put_pd;
+	}
+
+	err = spi_register_board_info(gpio_spi_board_info,
+		/*
+		 * Note I pass an array here instead of a pointer in order not
+		 * to break ARRAY_SIZE.
+		 */
+		ARRAY_SIZE(spi_gpio_sc_board_info));
+	if (err) {
+		goto err_del_pd;
+	}
+
+	if (north_cluster) {
+		spi_gpio_nc_pdev = pdev;
+	} else {
+		spi_gpio_sc_pdev = pdev;
+	}
+
+	return 0;
+
+err_del_pd:
+	platform_device_del(pdev);
+err_put_pd:
+	platform_device_put(pdev);
+err_out:
+	return err;
+}
+
+/**
+ * gpio_spidev_unregister
+ *
+ * Release a bitbanged SPI platform device and its `spidev' interface.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_unregister(int north_cluster)
+{
+	int ret = 0;
+
+	struct platform_device *pdev =
+		(north_cluster ? spi_gpio_nc_pdev : spi_gpio_sc_pdev);
+	struct spi_board_info *gpio_spi_board_info = 
+		(north_cluster ? spi_gpio_nc_board_info : spi_gpio_sc_board_info);
+
+	ret = spi_unregister_board_info(gpio_spi_board_info,
+		/*
+		 * Note I pass an array here instead of a pointer in order not
+		 * to break ARRAY_SIZE.
+		 */
+		ARRAY_SIZE(spi_gpio_sc_board_info));
+
+	if (0 == ret) {
+		platform_device_unregister(pdev);
+	}
+
+	if (north_cluster) {
+		spi_gpio_nc_pdev = NULL;
+	} else {
+		spi_gpio_sc_pdev = NULL;
+	}
+
+	return ret;
+}
+
+/**
+ * gip_system_power_transition 
+ *
+ * @param state: 0 if transition to S3, !0 if transition to S0
+ * @return 0 success < 0 failure
+ *
+ * Exercise system-wide suspend/resume power management transitions.
+ * 
+ */
+static int gip_system_power_transition(int state)
+{
+	struct pci_dev *gip = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, NULL);
+	if (NULL == gip) {
+		pr_err("can't find GIP PCI device\n");
+		return -ENOENT;
+	}
+
+	if (0 == state) {
+		gip->driver->driver.pm->suspend(&gip->dev);
+	} else {
+		gip->driver->driver.pm->resume(&gip->dev);
+	}
+
+	/* Decrement reference count of PCI device */
+	if (NULL != pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, gip)) {
+		pr_warn("found duplicate of GIP PCI device?!\n");
+	}
+
+	return 0;
+}
+
+/**
+ * gpio_sc_debounce
+ *
+ * Enable GPIO debounce functionality for SC_GPIO_1 (edge and level triggered)
+ *
+ */
+static int gpio_sc_debounce(int level)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio = SUT_GPIO_SC_0;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN,
+		level ? "gpio_level_mask" : "gpio_edge_mask");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/*
+	 * Register IRQ. gpio_pos_edge_handler will do for both level and edge
+	 * interrupts, as it's nooping.
+	 */
+	if (0 != (ret = request_irq(irq, gpio_pos_edge_handler,
+			level ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_RISING,
+			level ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_EDGE_POS_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/* Set debounce */
+	if (0 != (ret = gpio_set_debounce(gpio, 1))) {
+		pr_err("can't set debounce for gpio%d\n", gpio);
+		goto fail_free_irq;
+	}
+
+	return 0;
+
+fail_free_irq:
+	free_irq(irq, NULL);
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_debounce_teardown
+ *
+ * Undo gpio_sc_debounce
+ *
+ */
+static int gpio_sc_debounce_teardown(int level)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_0;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long gip_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_CLN_GPIO_11:
+			/* Edge-triggered interrupts */
+			ret = gpio_sc_edge_int(0);
+			break;
+		case IOCTL_CLN_GPIO_11_CLEANUP:
+			/* Edge-triggered interrupts cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_12:
+			/* Edge-triggered interrupts (masking) */
+			ret = gpio_sc_edge_int(1);
+			break;
+		case IOCTL_CLN_GPIO_12_CLEANUP:
+			/* Edge-triggered interrupts (masking) cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_13:
+			/* GPIO debounce (edge) */
+			ret = gpio_sc_debounce(0);
+			break;
+		case IOCTL_CLN_GPIO_13_CLEANUP:
+			/* GPIO debounce cleanup (edge) */
+			ret = gpio_sc_debounce_teardown(0);
+			break;
+		case IOCTL_CLN_GPIO_14:
+			/* High-level triggered interrupts */
+			ret = gpio_sc_level_int(1, 0);
+			break;
+		case IOCTL_CLN_GPIO_14_CLEANUP:
+			/* High-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_15:
+			/* Low-level triggered interrupts */
+			ret = gpio_sc_level_int(0, 0);
+			break;
+		case IOCTL_CLN_GPIO_15_CLEANUP:
+			/*Low-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_16:
+			/* Level triggered interrupts (masking) */
+			ret = gpio_sc_level_int(1, 1);
+			break;
+		case IOCTL_CLN_GPIO_16_CLEANUP:
+			/* Level triggered interrupts (masking) cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_17:
+			/* GPIO debounce (level) */
+			ret = gpio_sc_debounce(1);
+			break;
+		case IOCTL_CLN_GPIO_17_CLEANUP:
+			/* GPIO debounce cleanup (level) */
+			ret = gpio_sc_debounce_teardown(1);
+			break;
+		case IOCTL_CLN_GPIO_19:
+			/* Register IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int();
+			break;
+		case IOCTL_CLN_GPIO_19_CLEANUP:
+			/* Free IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int_teardown();
+			break;
+		case IOCTL_CLN_GPIO_20:
+			/* NC bitbanged SPI */
+			ret = gpio_spidev_register(1);
+			break;
+		case IOCTL_CLN_GPIO_20_CLEANUP:
+			/* NC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(1);
+			break;
+		case IOCTL_CLN_GPIO_21:
+			/* SC bitbanged SPI */
+			ret = gpio_spidev_register(0);
+			break;
+		case IOCTL_CLN_GPIO_21_CLEANUP:
+			/* SC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(0);
+			break;
+		case IOCTL_CLN_GPIO_24:
+			/*
+			 * SC GPIO interrupt performance test.
+			 * Note it's shared between CLN_GPIO_24 and CLN_GPIO_25
+			 * plus it doesn't need any cleanup call.
+			 */
+			ret = gpio_sc_interrupt_perf(arg);
+			break;
+		case IOCTL_CLN_GPIO_26:
+			/* Interrupt for basic loopback test */
+			ret = gpio_sc_basic_int();
+			break;
+		case IOCTL_CLN_GPIO_26_CLEANUP:
+			/* Interrupt for basic loopback test cleanup */
+			ret = gpio_sc_basic_int_teardown();
+			break;
+		case IOCTL_CLN_GIP_SYSTEM_SUSPEND:
+			ret = gip_system_power_transition(0);
+			break;
+		case IOCTL_CLN_GIP_SYSTEM_RESUME:
+			ret = gip_system_power_transition(1);
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int gip_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&gip_test_dev.open_lock)) {
+		mutex_unlock(&gip_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (gip_test_dev.opened) {
+		mutex_unlock(&gip_test_dev.open_lock);
+		mutex_unlock(&gip_test_mutex);
+		return -EINVAL;
+	}
+
+	gip_test_dev.opened++;
+	mutex_unlock(&gip_test_dev.open_lock);
+	mutex_unlock(&gip_test_mutex);
+	return 0;
+}
+
+static int gip_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_dev.open_lock);
+	gip_test_dev.opened = 0;
+	mutex_unlock(&gip_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations gip_test_file_ops = {
+	.open = gip_test_open,
+	.release = gip_test_release,
+	.unlocked_ioctl = gip_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_cln_gip_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_cln_gip_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&gip_test_dev.open_lock);
+	cdev_init(&gip_test_dev.cdev, &gip_test_file_ops);
+	gip_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&gip_test_dev.cdev, MKDEV(gip_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(gip_test_class, NULL,
+				 MKDEV(gip_test_major, minor), NULL,
+				 "giptest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_cln_gip_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(gip_test_dev.cdev.dev);
+
+	device_destroy(gip_test_class, MKDEV(gip_test_major, minor));
+	cdev_del(&gip_test_dev.cdev);
+
+	class_destroy(gip_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_gip_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_gip_test_remove,
+};
+
+/**
+ * intel_cln_gip_test_init
+ *
+ * Load module.
+ */
+static int __init intel_cln_gip_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	gip_test_class = class_create(THIS_MODULE,"cln_gip_test");
+	if (IS_ERR(gip_test_class)) {
+		retval = PTR_ERR(gip_test_class);
+		printk(KERN_ERR "gip_test: can't register gip_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "gip_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	gip_test_major = MAJOR(dev);
+
+	memset(&gip_test_dev, 0x00, sizeof(gip_test_dev));
+	gip_test_dev.pldev = platform_create_bundle(
+		&intel_cln_gip_test_driver, intel_cln_gip_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(gip_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(gip_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(gip_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_cln_gip_test_exit(void)
+{
+	platform_device_unregister(gip_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_gip_test_driver);
+}
+
+module_init(intel_cln_gip_test_init);
+module_exit(intel_cln_gip_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Clanton GIP test module");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/mfd/lpc_sch.c b/drivers/mfd/lpc_sch.c
index abc4213..3ddbf70 100644
--- a/drivers/mfd/lpc_sch.c
+++ b/drivers/mfd/lpc_sch.c
@@ -40,21 +40,41 @@
 #define WDTBASE		0x84
 #define WDT_IO_SIZE	64
 
+/* BIOS control reg */
+#define LPC_BIOS_CNTL	0xD8
+#define LPC_BIOS_CNTL_WE 0x01
+
+/* Root complex base address derived registers */
+#define RCBA_BASE	0xF0
+
 static struct resource smbus_sch_resource = {
 		.flags = IORESOURCE_IO,
 };
 
-
 static struct resource gpio_sch_resource = {
 		.flags = IORESOURCE_IO,
 };
 
+static struct resource spi_res = {
+	.flags		= IORESOURCE_MEM,
+	.start		= 0,
+	.end		= 0,
+};
+
+static struct platform_device lpc_sch_spi = {
+	.name 		= "spi-lpc-sch",
+	.id 		= -1,
+	.resource	= &spi_res,
+};
+
 static struct mfd_cell lpc_sch_cells[] = {
+#ifndef CONFIG_INTEL_CLN_SOC
 	{
 		.name = "isch_smbus",
 		.num_resources = 1,
 		.resources = &smbus_sch_resource,
 	},
+#endif
 	{
 		.name = "sch_gpio",
 		.num_resources = 1,
@@ -77,6 +97,7 @@ static struct mfd_cell tunnelcreek_cells[] = {
 static DEFINE_PCI_DEVICE_TABLE(lpc_sch_ids) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SCH_LPC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ITC_LPC) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CLANTON_ILB) },
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, lpc_sch_ids);
@@ -86,22 +107,26 @@ static int __devinit lpc_sch_probe(struct pci_dev *dev,
 {
 	unsigned int base_addr_cfg;
 	unsigned short base_addr;
+	u32 rcba_base, bios_cntl;
 	int i;
 	int ret;
 
-	pci_read_config_dword(dev, SMBASE, &base_addr_cfg);
-	if (!(base_addr_cfg & (1 << 31))) {
-		dev_err(&dev->dev, "Decode of the SMBus I/O range disabled\n");
-		return -ENODEV;
-	}
-	base_addr = (unsigned short)base_addr_cfg;
-	if (base_addr == 0) {
-		dev_err(&dev->dev, "I/O space for SMBus uninitialized\n");
-		return -ENODEV;
-	}
+	/* Clanton does not support iLB SMBUS */
+	if (id->device != PCI_DEVICE_ID_INTEL_CLANTON_ILB) {
+		pci_read_config_dword(dev, SMBASE, &base_addr_cfg);
+		if (!(base_addr_cfg & (1 << 31))) {
+			dev_err(&dev->dev, "Decode of the SMBus I/O range disabled\n");
+			return -ENODEV;
+		}
+		base_addr = (unsigned short)base_addr_cfg;
+		if (base_addr == 0) {
+			dev_err(&dev->dev, "I/O space for SMBus uninitialized\n");
+			return -ENODEV;
+		}
 
-	smbus_sch_resource.start = base_addr;
-	smbus_sch_resource.end = base_addr + SMBUS_IO_SIZE - 1;
+		smbus_sch_resource.start = base_addr;
+		smbus_sch_resource.end = base_addr + SMBUS_IO_SIZE - 1;
+	}
 
 	pci_read_config_dword(dev, GPIOBASE, &base_addr_cfg);
 	if (!(base_addr_cfg & (1 << 31))) {
@@ -125,6 +150,31 @@ static int __devinit lpc_sch_probe(struct pci_dev *dev,
 	if (ret)
 		goto out_dev;
 
+	/* Add RCBA SPI device */
+	if (id->device == PCI_DEVICE_ID_INTEL_CLANTON_ILB) {
+		pci_read_config_dword(dev, LPC_BIOS_CNTL, &bios_cntl);
+		pr_info("%s BIOS_CNTL 0x%08x\n", __func__, bios_cntl);
+
+		/* Enable flash write */
+		bios_cntl |= LPC_BIOS_CNTL_WE;
+		pci_write_config_dword(dev, LPC_BIOS_CNTL, bios_cntl);
+
+		/* Verify */
+		pci_read_config_dword(dev, LPC_BIOS_CNTL, &bios_cntl);
+		pr_info("%s new BIOS_CNTL 0x%08x\n", __func__, bios_cntl);
+	}
+
+	pci_read_config_dword(dev, RCBA_BASE, &rcba_base);
+	rcba_base &= 0xFFFFC000;
+	spi_res.start = rcba_base + 0x3020;
+	spi_res.end = rcba_base + 0x3088;
+	pr_info("%s RCBA @ 0x%08x\n", __func__, rcba_base);
+	ret = platform_device_register(&lpc_sch_spi);
+	if (ret < 0){
+		pr_err("unable to register %s plat dev\n", lpc_sch_spi.name);
+		goto out_dev;
+	}
+
 	if (id->device == PCI_DEVICE_ID_INTEL_ITC_LPC) {
 		pci_read_config_dword(dev, WDTBASE, &base_addr_cfg);
 		if (!(base_addr_cfg & (1 << 31))) {
-- 
1.7.5.4

