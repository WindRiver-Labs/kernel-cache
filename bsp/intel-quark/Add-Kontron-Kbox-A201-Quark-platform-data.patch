From f1fccc98d18ea2d8181b8e610772deae17ec8376 Mon Sep 17 00:00:00 2001
From: Ionut Neicu <ineicu@windriver.com>
Date: Thu, 12 Nov 2015 13:04:28 +0200
Subject: [PATCH 5/6] Add Kontron Kbox A201 Quark platform data

Signed-off-by: Ionut Neicu <ineicu@windriver.com>
---
 drivers/platform/x86/intel-quark/Makefile          |    1 +
 .../intel-quark/intel_quark_platform_kbox_a201.c   |  305 ++++++++++++++++++++
 2 files changed, 306 insertions(+), 0 deletions(-)
 create mode 100644 drivers/platform/x86/intel-quark/intel_quark_platform_kbox_a201.c

diff --git a/drivers/platform/x86/intel-quark/Makefile b/drivers/platform/x86/intel-quark/Makefile
index 5c09e08..85ce492 100644
--- a/drivers/platform/x86/intel-quark/Makefile
+++ b/drivers/platform/x86/intel-quark/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL_RELIAGATE) += intel_quark_audio_ctrl_reliagate
 obj-$(CONFIG_INTEL_QRK_THERMAL)+= intel_qrk_thermal.o
 obj-$(CONFIG_X86_INTEL_QUARK)			 += intel_quark_platform_cse_e100.o
 obj-$(CONFIG_X86_INTEL_QUARK)			 += intel_quark_platform_reliagate.o
+obj-$(CONFIG_X86_INTEL_QUARK)	                 += intel_quark_platform_kbox_a201.o
diff --git a/drivers/platform/x86/intel-quark/intel_quark_platform_kbox_a201.c b/drivers/platform/x86/intel-quark/intel_quark_platform_kbox_a201.c
new file mode 100644
index 0000000..655ea56
--- /dev/null
+++ b/drivers/platform/x86/intel-quark/intel_quark_platform_kbox_a201.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright(c) 2014 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Kontron Kbox A201 Quark based boards support
+ * SXQU111 schematic
+ *
+ * Author : Yury Kylulin <yury.kylulin@intel.com> 2014
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#define DRIVER_NAME 		"KBoxA201"
+#define GPIO_RESTRICT_NAME	"gpio-restrict-sc"
+
+// Define to enable TPM
+#define ENABLE_TPM
+
+/******************************************************************************/
+/* NXP PCAL6416A GPIO expander platform data                                  */
+/******************************************************************************/
+#include "linux/i2c/pcal6416a.h"
+
+#define NXP_PCAL6416A_ADDR	0x21
+#define GPIO_PCAL6416A_INT	8
+
+static struct pcal6416a_platform_data gpio_expander_platform_data = {
+	.gpio_base = 16,
+};
+
+static struct i2c_board_info probed_i2c_pcal6416a = {
+	.platform_data = &gpio_expander_platform_data,
+};
+
+static const unsigned short pcal6416a_i2c_addr[] = {
+	NXP_PCAL6416A_ADDR, I2C_CLIENT_END
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_PCAL6416A_INT,
+		GPIOF_IN,
+		"pcal6416a-int",
+	},
+};
+
+/******************************************************************************/
+/* TI TCA9546A I2C switch platform data                                       */
+/******************************************************************************/
+#include "linux/i2c/pca954x.h"
+
+#define TI_TCA9546A_ADDR	0x76
+
+static struct pca954x_platform_mode i2c_switch_platform_modes[] = {
+	{ 1, 1 },
+	{ 2, 1 },
+	{ 3, 1 },
+	{ 4, 1 },
+};
+
+static struct pca954x_platform_data i2c_switch_platform_data = {
+	.modes = i2c_switch_platform_modes,
+	.num_modes = 4,
+};
+
+static struct i2c_board_info probed_i2c_tca9546a = {
+	.platform_data = &i2c_switch_platform_data,
+};
+
+static const unsigned short tca9546a_i2c_addr[] = {
+	TI_TCA9546A_ADDR, I2C_CLIENT_END
+};
+
+/******************************************************************************/
+/* Atmel AT24C32D EEPROM platform data                                        */
+/******************************************************************************/
+#include <linux/platform_data/at24.h>
+
+#define ATMEL_AT24C32D_ADDR	0x50
+
+static struct i2c_board_info probed_i2c_eeprom;
+
+static const unsigned short at24c32d_i2c_addr[] = {
+	ATMEL_AT24C32D_ADDR, I2C_CLIENT_END
+};
+
+#ifdef ENABLE_TPM
+/******************************************************************************/
+/* Infineon SLB9645TT platform data                                           */
+/******************************************************************************/
+#include <linux/platform_data/tpm_i2c_infenion.h>
+
+#define INFINEON_SLB9645TT_ADDR	0x20
+
+static struct i2c_board_info probed_i2c_slb9645tt;
+
+static const unsigned short slb9645tt_i2c_addr[] = {
+	INFINEON_SLB9645TT_ADDR, I2C_CLIENT_END
+};
+#endif
+
+static unsigned int pcal6416a_i2c_initialized = 0;
+static unsigned int tca9546a_i2c_initialized = 0;
+
+/******************************************************************************/
+/* Intel Quark SPI controller data                                            */
+/******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = -1,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = -1,
+};
+
+static struct spi_board_info spi_generic_devs[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	},
+
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+};
+
+static int i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	/* Always return success: the I2C clients are already known */
+	return 1;
+}
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Izmir platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_generic_devs,
+			ARRAY_SIZE(spi_generic_devs));
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them. The
+ * GPIOs are never released nor accessed by this driver.
+ *
+ * Registers devices which are dependent on this GPIO driver
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct i2c_adapter *i2c_adap = NULL;
+	struct i2c_adapter *i2c_adap_swi = NULL;
+	struct i2c_client *client = NULL;
+
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter (0) not ready yet. Deferring..\n",
+			__func__);
+		return -EPROBE_DEFER;
+	}
+
+	/* NXP PCAL6416A GPIO expander init */
+	if (pcal6416a_i2c_initialized)
+		goto skip_pcal6416a;
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret)
+		dev_err(&client->dev, "failed to request reserved gpios\n");
+
+	strlcpy(probed_i2c_pcal6416a.type, "pcal6416a", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_pcal6416a,
+				       pcal6416a_i2c_addr, i2c_probe);
+	if (client == NULL)
+		pr_err("%s: Failed to probe NXP PCAL6416A I2C GPIO expander\n",
+		       __func__);
+
+	pcal6416a_i2c_initialized = 1;
+
+skip_pcal6416a:
+	if (tca9546a_i2c_initialized)
+		goto skip_tca9546a;
+
+	strlcpy(probed_i2c_tca9546a.type, "tca9546", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_tca9546a,
+				       tca9546a_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe TI TCA9546A I2C switch\n",
+		       __func__);
+		goto spi_init;
+	}
+
+	tca9546a_i2c_initialized = 1;
+
+skip_tca9546a:
+	i2c_adap_swi = i2c_get_adapter(1);
+	if (NULL == i2c_adap_swi) {
+		pr_info("%s: i2c adapter (1) not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+	strlcpy(probed_i2c_eeprom.type, "24c32", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap_swi, &probed_i2c_eeprom,
+				       at24c32d_i2c_addr, i2c_probe);
+	if (client == NULL)
+		pr_err("%s: Failed to probe Atmel AT24C32D EEPROM\n", __func__);
+
+#ifdef ENABLE_TPM
+	strlcpy(probed_i2c_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap_swi, &probed_i2c_slb9645tt,
+				       slb9645tt_i2c_addr, i2c_probe);
+	if (client == NULL)
+		pr_err("%s: Failed to probe Infineon SLB9645TT TPM\n", __func__);
+#endif
+
+	i2c_put_adapter(i2c_adap_swi);
+
+spi_init:
+	ret = intel_qrk_spi_add_onboard_devs();
+
+end:
+	i2c_put_adapter(i2c_adap);
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_kontron_kbox_a201_quark_probe(struct platform_device *pdev)
+{
+	pr_info("%s: Kontron KBox A201 quark platform devices init\n", __func__);
+
+	return platform_driver_register(&gpio_restrict_pdriver);
+}
+
+static int intel_qrk_plat_kontron_kbox_a201_quark_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_kontron_kbox_a201_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_kontron_kbox_a201_quark_probe,
+	.remove		= intel_qrk_plat_kontron_kbox_a201_quark_remove,
+};
+
+module_platform_driver(qrk_kontron_kbox_a201_driver);
+
+MODULE_AUTHOR("Yury Kylulin <yury.kylulin@intel.com>");
+MODULE_DESCRIPTION("Kontron Kbox A201 Quark BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
-- 
1.7.5.4

