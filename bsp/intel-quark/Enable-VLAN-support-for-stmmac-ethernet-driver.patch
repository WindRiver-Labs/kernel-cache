From 80870754d614a461ba65bb8448b076fa7ffeffb4 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Tue, 13 Jan 2015 15:34:54 +0800
Subject: [PATCH 09/31] Enable VLAN support for stmmac ethernet driver.

source: Intel vendor drop 1.1.0-rc2

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/common.h       |   11 +-
 drivers/net/ethernet/stmicro/stmmac/descs.h        |   43 ++++
 drivers/net/ethernet/stmicro/stmmac/dwmac1000.h    |   62 +++++-
 .../net/ethernet/stmicro/stmmac/dwmac1000_core.c   |  143 ++++++++++-
 .../net/ethernet/stmicro/stmmac/dwmac1000_dma.c    |    9 +-
 .../net/ethernet/stmicro/stmmac/dwmac100_core.c    |    6 +-
 drivers/net/ethernet/stmicro/stmmac/mmc_core.c     |    2 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac.h       |    5 +
 .../net/ethernet/stmicro/stmmac/stmmac_ethtool.c   |   21 ++-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |  156 +++++++++++--
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |  251 +++++++++++++++++---
 11 files changed, 638 insertions(+), 71 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 9517697..87d009e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -32,6 +32,9 @@
 #include <linux/init.h>
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 #define STMMAC_VLAN_TAG_USED
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+#define STMMAC_VLAN_HASH
+#endif
 #include <linux/if_vlan.h>
 #endif
 
@@ -377,15 +380,16 @@ struct stmmac_dma_ops {
 	void (*rx_watchdog) (void __iomem *ioaddr, u32 riwt);
 };
 
+struct stmmac_priv;
 struct stmmac_ops {
 	/* MAC core initialization */
 	void (*core_init) (void __iomem *ioaddr);
 	/* Enable and verify that the IPC module is supported */
-	int (*rx_ipc) (void __iomem *ioaddr);
+	int (*set_rx_ipc) (void __iomem *ioaddr, bool on);
 	/* Dump MAC registers */
 	void (*dump_regs) (void __iomem *ioaddr);
 	/* Handle extra events on specific interrupts hw dependent */
-	int (*host_irq_status) (void __iomem *ioaddr,
+	int (*host_irq_status) (struct stmmac_priv *priv,
 				struct stmmac_extra_stats *x);
 	/* Multicast filter setting */
 	void (*set_filter) (struct net_device *dev, int id);
@@ -399,6 +403,9 @@ struct stmmac_ops {
 			       unsigned int reg_n);
 	void (*get_umac_addr) (void __iomem *ioaddr, unsigned char *addr,
 			       unsigned int reg_n);
+	/* Enable/Disable VLAN Hash filters */
+	int (*vlan_rx_add_vid)(struct stmmac_priv *priv, unsigned short vid);
+	int (*vlan_rx_kill_vid)(struct stmmac_priv *priv, unsigned short vid);
 	void (*set_eee_mode) (void __iomem *ioaddr);
 	void (*reset_eee_mode) (void __iomem *ioaddr);
 	void (*set_eee_timer) (void __iomem *ioaddr, int ls, int tw);
diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h
index ad39960..ce4bd0b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/descs.h
+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h
@@ -161,6 +161,49 @@ struct dma_desc {
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
+
+	/* Enhanced mode - with VLAN/1588-2005/IPC CHKSUM offload */
+	#if defined(STMMAC_ATDS_USED)
+		union {
+			/* Receive descriptor */
+			struct {
+				/* RDES4 */
+				u32 ip_payload_type:3;
+				u32 ip_header_error:1;
+				u32 ip_payload_error:1;
+				u32 ip_checksum_bypassed:1;
+				u32 ipv4_packet_received:1;
+				u32 ipv6_packet_received:1;
+				u32 message_type:4;
+				u32 ptp_frame_type:1;
+				u32 ptp_version:1;
+				u32 timestamp_dropped:1;
+				u32 reserved1:1;
+				u32 av_packet_received:1;
+				u32 av_tagged_packet_received:1;
+				u32 vlan_tag_priority_value:3;
+				u32 reserved2:3;
+				u32 layer3_filter_match:1;
+				u32 layer4_filter_match:1;
+				u32 layer3_layer4_filter_num_matched:2;
+				u32 reserved3:4;
+
+				/* RDES5 */
+				u32 reserved4;
+			} erx;
+
+			/* Transmit descriptor */
+			struct {
+				/* TDES4 */
+				u32 reserved1;
+
+				/* TDES5 */
+				u32 reserved2;
+			} etx;
+		} des05;
+		unsigned int ts_lo;	     /* des6 Tx/Rx timestmp lo */
+		unsigned int ts_hi;	     /* des7 Tx/Rx timestamp hi */
+	#endif
 };
 
 /* Extended descriptor structure (supported by new SYNP GMAC generations) */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
index c12aabb..cbce4a9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
@@ -50,7 +50,14 @@ enum dwmac1000_irq_status {
 	rgmii_irq = 0x0001,
 };
 #define GMAC_INT_MASK		0x0000003c	/* interrupt mask register */
-
+#define GMAC_INT_MASK_LPIIM	0x00000200	/* LPI Interrupt Mask */
+#define GMAC_INT_MASK_TSIM	0x00000100	/* Timestamp Interrupt Mask */
+#define GMAC_INT_MASK_PMTIM	0x00000004	/* PMT Interrupt Mask */
+#define GMAC_INT_MASK_PCSANCIM	0x00000002	/* PCS AN Completion */
+#define GMAC_INT_MASK_PCSLCHGIM	0x00000001	/* PCS Link Status */
+#define GMAC_INT_MASK_DEFAULT (GMAC_INT_MASK_PCSLCHGIM | GMAC_INT_MASK_PCSANCIM\
+				| GMAC_INT_MASK_PMTIM | GMAC_INT_MASK_TSIM\
+				| GMAC_INT_MASK_LPIIM)
 /* PMT Control and Status */
 #define GMAC_PMT		0x0000002c
 enum power_event {
@@ -168,6 +175,7 @@ enum inter_frame_gap {
 #define GMAC_FRAME_FILTER_SAIF	0x00000100	/* Inverse Filtering */
 #define GMAC_FRAME_FILTER_SAF	0x00000200	/* Source Address Filter */
 #define GMAC_FRAME_FILTER_HPF	0x00000400	/* Hash or perfect Filter */
+#define GMAC_FRAME_FILTER_VTFE	0x00010000	/* VLAN Tag Filter Enable */
 #define GMAC_FRAME_FILTER_RA	0x80000000	/* Receive all mode */
 /* GMII ADDR  defines */
 #define GMAC_MII_ADDR_WRITE	0x00000002	/* MII Write */
@@ -178,6 +186,12 @@ enum inter_frame_gap {
 #define GMAC_FLOW_CTRL_RFE	0x00000004	/* Rx Flow Control Enable */
 #define GMAC_FLOW_CTRL_TFE	0x00000002	/* Tx Flow Control Enable */
 #define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
+/* GMAC VLAN TAG defines */
+#define GMAC_VLAN_TAG_VTHM	0x00080000	/* Hash Table Match Enable */
+#define GMAC_VLAN_TAG_ESVL	0x00040000	/* Enable S-VLAN */
+#define GMAC_VLAN_TAG_VTIM	0x00020000	/* VLAN Tag inverse match */
+#define GMAC_VLAN_TAG_ETV	0x00010000	/* Enable 12-bit tag comp */
+#define GMAC_VLAN_TAG_VLMASK	0x0000FFFF	/* VLAN tag ID for Rx frames */
 
 /*--- DMA BLOCK defines ---*/
 /* DMA Bus Mode register defines */
@@ -203,6 +217,7 @@ enum rx_tx_priority_ratio {
 #define DMA_BUS_MODE_USP	0x00800000
 #define DMA_BUS_MODE_PBL	0x01000000
 #define DMA_BUS_MODE_AAL	0x02000000
+#define DMA_BUS_MODE_RIX	0x80000000
 
 /* DMA CRS Control and Status Register Mapping */
 #define DMA_HOST_TX_DESC	  0x00001048	/* Current Host Tx descriptor */
@@ -265,5 +280,50 @@ enum rtc_control {
 #define GMAC_MMC_TX_INTR   0x108
 #define GMAC_MMC_RX_CSUM_OFFLOAD   0x208
 
+/* VLAN Hash register offset */
+#define GMAC_VLAN_TAG_REP	0x584
+#define GMAC_VLAN_HASH		0x588
+#define GMAC_VLAN_HASH_MAXID	0x0F
+
+/***************** 1588 regs *****************/
+#define GMAC_TS_CTRL		0x700		/* Timestamp control reg */
+#define GMAC_TS_CTRL_TSENA	0x00000001	/* Timestamp enable */
+#define GMAC_TS_CTRL_TSCFUPDT	0x00000002	/* Timestamp fine/coarse */
+#define GMAC_TS_CTRL_TSINT	0x00000004	/* Timestamp initialise */
+#define GMAC_TS_CTRL_TSUPDT	0x00000008	/* Timestamp update */
+#define GMAC_TS_CTRL_TSTRIG	0x00000010	/* Timestamp trigger en */
+#define GMAC_TS_CTRL_TSADDREG	0x00000020	/* Timestamp addreg update */
+#define GMAC_TS_CTRL_TSENALL	0x00000100	/* Timestamp RX enable all */
+#define GMAC_TS_CTRL_TSCTRLSSR	0x00000200	/* Timestamp rollover ctr */
+#define GMAC_TS_CTRL_TSVER2ENA	0x00000400	/* Timestamp PTP v2 en */
+#define GMAC_TS_CTRL_TSIPENA	0x00000800	/* Timestamp PTP over eth */
+#define GMAC_TS_CTRL_TSIPV6ENA	0x00001000	/* Timestamp over IPV6 */
+#define GMAC_TS_CTRL_TSIPV4ENA	0x00002000	/* Timestamp over IPV4 */
+#define GMAC_TS_CTRL_TSEVNTENA	0x00004000	/* Timestamp event only */
+#define GMAC_TS_CTRL_TSMSTRENA	0x00008000	/* Timestamp master enable */
+#define GMAC_TS_CTRL_SNTYPSEL0	0x00000000	/* Timestamp type 0 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL1	0x00010000	/* Timestamp type 1 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL2	0x00020000	/* Timestamp type 2 snapshot */
+#define GMAC_TS_CTRL_SNTYPSEL3	0x00030000	/* Timestamp type 3 snapshot */
+#define GMAC_TS_CTRL_TSENMACADR	0x00040000	/* Timestamp mac filter en */
+#define GMAC_TS_CTRL_ATSFC	0x01000000	/* Timestamp aux fifo clear */
+#define GMAC_TS_CTRL_ATSEN0	0x02000000	/* Timestamp aux0 snap en */
+#define GMAC_TS_CTRL_ATSEN1	0x04000000	/* Timestamp aux1 snap en */
+#define GMAC_TS_CTRL_ATSEN2	0x08000000	/* Timestamp aux2 snap en */
+#define GMAC_TS_CTRL_ATSEN3	0x10000000	/* Timestamp aux3 enable */
+#define GMAC_SS_INC		0x704		/* Sub-second increment reg */
+#define GMAC_ST_SEC		0x708		/* System time seconds */
+#define GMAC_ST_NSEC		0x70C		/* System time nseconds */
+#define GMAC_ST_SECUP		0x710		/* System time sec-update */
+#define GMAC_ST_NSECUP		0x714		/* System time nsec-update */
+#define GMAC_TS_APPEND		0x718		/* Timestamp append */
+#define GMAC_TT_SEC		0x71C		/* Target time seconds */
+#define GMAC_TT_NSEC		0x720		/* Target time nseconds */
+#define GMAC_ST_HWSEC		0x724		/* System time high word sec */
+#define GMAC_ST_TS_STAT		0x728		/* Timestamp status */
+#define GMAC_PPS_CTRL		0x72C		/* PPS signal output control */
+#define GMAC_AUXTS_NSEC		0x730		/* Aux timestamp counter nsec */
+#define GMAC_AUXTS_SEC		0x734		/* Aux timestamp counter sec */
+
 extern const struct stmmac_dma_ops dwmac1000_dma_ops;
 #endif /* __DWMAC1000_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index 7e05e8d..bb6ed52 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -30,6 +30,7 @@
 #include <linux/slab.h>
 #include <linux/ethtool.h>
 #include <asm/io.h>
+#include "stmmac.h"
 #include "dwmac1000.h"
 
 static void dwmac1000_core_init(void __iomem *ioaddr)
@@ -39,7 +40,7 @@ static void dwmac1000_core_init(void __iomem *ioaddr)
 	writel(value, ioaddr + GMAC_CONTROL);
 
 	/* Mask GMAC interrupts */
-	writel(0x207, ioaddr + GMAC_INT_MASK);
+	writel(GMAC_INT_MASK_DEFAULT, ioaddr + GMAC_INT_MASK);
 
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Tag detection without filtering */
@@ -47,11 +48,15 @@ static void dwmac1000_core_init(void __iomem *ioaddr)
 #endif
 }
 
-static int dwmac1000_rx_ipc_enable(void __iomem *ioaddr)
+static int dwmac1000_set_rx_ipc(void __iomem *ioaddr, bool on)
 {
 	u32 value = readl(ioaddr + GMAC_CONTROL);
 
-	value |= GMAC_CONTROL_IPC;
+	if (on == true)
+		value |= GMAC_CONTROL_IPC;
+	else
+		value &= ~GMAC_CONTROL_IPC;
+
 	writel(value, ioaddr + GMAC_CONTROL);
 
 	value = readl(ioaddr + GMAC_CONTROL);
@@ -88,6 +93,7 @@ static void dwmac1000_get_umac_addr(void __iomem *ioaddr, unsigned char *addr,
 static void dwmac1000_set_filter(struct net_device *dev, int id)
 {
 	void __iomem *ioaddr = (void __iomem *)dev->base_addr;
+	struct stmmac_priv *priv = netdev_priv(dev);
 	unsigned int value = 0;
 	unsigned int perfect_addr_number;
 
@@ -150,6 +156,10 @@ static void dwmac1000_set_filter(struct net_device *dev, int id)
 	/* Enable Receive all mode (to debug filtering_fail errors) */
 	value |= GMAC_FRAME_FILTER_RA;
 #endif
+	if (priv->active_vlans != 0)
+		/* VLAN hash filtering is active on this interface */
+		value |= GMAC_FRAME_FILTER_VTFE;
+
 	writel(value, ioaddr + GMAC_FRAME_FILTER);
 
 	CHIP_DBG(KERN_INFO "\tFilter: 0x%08x\n\tHash: HI 0x%08x, LO 0x%08x\n",
@@ -196,38 +206,38 @@ static void dwmac1000_pmt(void __iomem *ioaddr, unsigned long mode)
 	writel(pmt, ioaddr + GMAC_PMT);
 }
 
-static int dwmac1000_irq_status(void __iomem *ioaddr,
+static int dwmac1000_irq_status(struct stmmac_priv *priv,
 				struct stmmac_extra_stats *x)
 {
-	u32 intr_status = readl(ioaddr + GMAC_INT_STATUS);
+	u32 intr_status = readl(priv->ioaddr + GMAC_INT_STATUS);
 	int ret = 0;
 
 	/* Not used events (e.g. MMC interrupts) are not handled. */
 	if ((intr_status & mmc_tx_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC tx interrupt: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_TX_INTR));
+			 readl(priv->ioaddr + GMAC_MMC_TX_INTR));
 		x->mmc_tx_irq_n++;
 	}
 	if (unlikely(intr_status & mmc_rx_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx interrupt: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_RX_INTR));
+			 readl(priv->ioaddr + GMAC_MMC_RX_INTR));
 		x->mmc_rx_irq_n++;
 	}
 	if (unlikely(intr_status & mmc_rx_csum_offload_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx csum offload: 0x%08x\n",
-			 readl(ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));
+			 readl(priv->ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));
 		x->mmc_rx_csum_offload_irq_n++;
 	}
 	if (unlikely(intr_status & pmt_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC: received Magic frame\n");
 		/* clear the PMT bits 5 and 6 by reading the PMT status reg */
-		readl(ioaddr + GMAC_PMT);
+		readl(priv->ioaddr + GMAC_PMT);
 		x->irq_receive_pmt_irq_n++;
 	}
 	/* MAC trx/rx EEE LPI entry/exit interrupts */
 	if (intr_status & lpiis_irq) {
 		/* Clean LPI interrupt by reading the Reg 12 */
-		ret = readl(ioaddr + LPI_CTRL_STATUS);
+		ret = readl(priv->ioaddr + LPI_CTRL_STATUS);
 
 		if (ret & LPI_CTRL_STATUS_TLPIEN) {
 			CHIP_DBG(KERN_INFO "GMAC TX entered in LPI\n");
@@ -249,11 +259,11 @@ static int dwmac1000_irq_status(void __iomem *ioaddr,
 
 	if ((intr_status & pcs_ane_irq) || (intr_status & pcs_link_irq)) {
 		CHIP_DBG(KERN_INFO "GMAC PCS ANE IRQ\n");
-		readl(ioaddr + GMAC_AN_STATUS);
+		readl(priv->ioaddr + GMAC_AN_STATUS);
 		x->irq_pcs_ane_n++;
 	}
 	if (intr_status & rgmii_irq) {
-		u32 status = readl(ioaddr + GMAC_S_R_GMII);
+		u32 status = readl(priv->ioaddr + GMAC_S_R_GMII);
 		CHIP_DBG(KERN_INFO "GMAC RGMII/SGMII interrupt\n");
 		x->irq_rgmii_n++;
 
@@ -282,6 +292,111 @@ static int dwmac1000_irq_status(void __iomem *ioaddr,
 	return ret;
 }
 
+static unsigned int dwmac1000_calc_vlan_4bit_crc(const char *vlan)
+{
+	int i = 0, j = 0, len = 0, bit = 0;
+	unsigned int crc = 0xFFFFFFFF;
+	unsigned int poly = 0x04C11DB7;
+	unsigned char data;
+
+	if (unlikely(vlan == NULL))
+		return 0;
+
+	for (i = 0; i < 2; i++) {
+		data = vlan[i];
+
+		if (i == 0)
+			len = 8;
+		else
+			len = 4;
+
+		for (bit = 0; bit < len; bit++) {
+			j = ((crc >> 31) ^ data) & 0x1;
+			crc <<= 1;
+
+			if (j != 0)
+				crc ^= poly;
+
+			data >>= 1;
+		}
+	}
+	return crc;
+}
+
+/* DesignWare Cores Ethernet MAC Universal Databook, 6.2.2.35
+ * "The hash value of the destination address
+ * is calculated in the following way:
+ *  1. Calculate the 32-bit CRC for the VLAN tag or ID
+ *  2. Perform bitwise reversal for the value obtained in 1.
+ *  3. Take the upper four bits from the value obtained in 2."
+ *
+ * vlan here being either vlan tag or vlan ID,
+ * since register understands both
+ */
+static inline unsigned int dwmac1000_get_hash_value(const char *vlan) {
+	return (~dwmac1000_calc_vlan_4bit_crc(vlan)) >> 28;
+}
+
+static int dwmac1000_vlan_rx_add_vid(struct stmmac_priv *priv,
+				unsigned short vid)
+{
+	u32 reg = 0;
+	u32 bit_nr = 0;
+
+	if (unlikely(priv == NULL || vid > GMAC_VLAN_HASH_MAXID))
+		return -EINVAL;
+
+	if (priv->active_vlans == 0) {
+
+		/* Flip the VTFE bit in GMAC_FRAME_FILTER */
+		reg = readl(priv->ioaddr + GMAC_FRAME_FILTER);
+		reg |= GMAC_FRAME_FILTER_VTFE;
+		writel(reg, priv->ioaddr + GMAC_FRAME_FILTER);
+
+		/* Enable hash filtering - based on 12 bit vid */
+		reg = readl(priv->ioaddr + GMAC_VLAN_TAG);
+		reg |= GMAC_VLAN_TAG_VTHM | GMAC_VLAN_TAG_ETV | GMAC_VLAN_TAG_VLMASK;
+		writel(reg, priv->ioaddr + GMAC_VLAN_TAG);
+	}
+
+	bit_nr = dwmac1000_get_hash_value((const char *)&vid);
+	priv->active_vlans |= 1 << bit_nr;
+
+	writel(priv->active_vlans, priv->ioaddr + GMAC_VLAN_HASH);
+
+	return 0;
+}
+
+static int dwmac1000_vlan_rx_kill_vid(struct stmmac_priv *priv,
+				unsigned short vid)
+{
+	u32 reg = 0;
+	u32 bit_nr = 0;
+
+	if (unlikely(priv == NULL || vid > GMAC_VLAN_HASH_MAXID))
+		return -EINVAL;
+
+	bit_nr = dwmac1000_get_hash_value((const char *)&vid);
+
+	priv->active_vlans &= ~(1 << bit_nr);
+	writel(priv->active_vlans, priv->ioaddr + GMAC_VLAN_HASH);
+
+	if (priv->active_vlans == 0) {
+
+		/* Disable hash filtering */
+		reg = readl(priv->ioaddr + GMAC_VLAN_TAG);
+		reg &= ~(GMAC_VLAN_TAG_VTHM | GMAC_VLAN_TAG_ETV | 0x00000001);
+		writel(reg, priv->ioaddr + GMAC_VLAN_TAG);
+
+		/* Flip the VTFE bit in GMAC_FRAME_FILTER */
+		reg = readl(priv->ioaddr + GMAC_FRAME_FILTER);
+		reg &= ~GMAC_FRAME_FILTER_VTFE;
+		writel(reg, priv->ioaddr + GMAC_FRAME_FILTER);
+	}
+
+	return 0;
+}
+
 static void dwmac1000_set_eee_mode(void __iomem *ioaddr)
 {
 	u32 value;
@@ -369,7 +484,7 @@ static void dwmac1000_get_adv(void __iomem *ioaddr, struct rgmii_adv *adv)
 
 static const struct stmmac_ops dwmac1000_ops = {
 	.core_init = dwmac1000_core_init,
-	.rx_ipc = dwmac1000_rx_ipc_enable,
+	.set_rx_ipc = dwmac1000_set_rx_ipc,
 	.dump_regs = dwmac1000_dump_regs,
 	.host_irq_status = dwmac1000_irq_status,
 	.set_filter = dwmac1000_set_filter,
@@ -377,6 +492,8 @@ static const struct stmmac_ops dwmac1000_ops = {
 	.pmt = dwmac1000_pmt,
 	.set_umac_addr = dwmac1000_set_umac_addr,
 	.get_umac_addr = dwmac1000_get_umac_addr,
+	.vlan_rx_add_vid = dwmac1000_vlan_rx_add_vid,
+	.vlan_rx_kill_vid = dwmac1000_vlan_rx_kill_vid,
 	.set_eee_mode = dwmac1000_set_eee_mode,
 	.reset_eee_mode = dwmac1000_reset_eee_mode,
 	.set_eee_timer = dwmac1000_set_eee_timer,
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
index 2c431b6..ec90338 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
@@ -59,9 +59,12 @@ static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
 	 * DMA transfers the data in 8, 16, 32, 64, 128 & 256 beats
 	 * depending on pbl value.
 	 */
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	value = DMA_BUS_MODE_RIX | (pbl << DMA_BUS_MODE_PBL_SHIFT);
+#else
 	value = DMA_BUS_MODE_PBL | ((pbl << DMA_BUS_MODE_PBL_SHIFT) |
 				    (pbl << DMA_BUS_MODE_RPBL_SHIFT));
-
+#endif
 	/* Set the Fixed burst mode */
 	if (fb)
 		value |= DMA_BUS_MODE_FB;
@@ -70,6 +73,10 @@ static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,
 	if (mb)
 		value |= DMA_BUS_MODE_MB;
 
+#ifdef STMMAC_ATDS_USED
+	value |= DMA_BUS_MODE_ATDS;
+#endif
+
 #ifdef CONFIG_STMMAC_DA
 	value |= DMA_BUS_MODE_DA;	/* Rx has priority over tx */
 #endif
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
index 007bb2b..901a4e9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
@@ -66,12 +66,12 @@ static void dwmac100_dump_mac_regs(void __iomem *ioaddr)
 		readl(ioaddr + MAC_VLAN2));
 }
 
-static int dwmac100_rx_ipc_enable(void __iomem *ioaddr)
+static int dwmac100_set_rx_ipc(void __iomem *ioaddr, bool on)
 {
 	return 0;
 }
 
-static int dwmac100_irq_status(void __iomem *ioaddr,
+static int dwmac100_irq_status(struct stmmac_priv *priv,
 			       struct stmmac_extra_stats *x)
 {
 	return 0;
@@ -159,7 +159,7 @@ static void dwmac100_pmt(void __iomem *ioaddr, unsigned long mode)
 
 static const struct stmmac_ops dwmac100_ops = {
 	.core_init = dwmac100_core_init,
-	.rx_ipc = dwmac100_rx_ipc_enable,
+	.set_rx_ipc = dwmac100_set_rx_ipc,
 	.dump_regs = dwmac100_dump_mac_regs,
 	.host_irq_status = dwmac100_irq_status,
 	.set_filter = dwmac100_set_filter,
diff --git a/drivers/net/ethernet/stmicro/stmmac/mmc_core.c b/drivers/net/ethernet/stmicro/stmmac/mmc_core.c
index b13724c..e6a4c1e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/mmc_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/mmc_core.c
@@ -144,7 +144,7 @@ void dwmac_mmc_ctrl(void __iomem *ioaddr, unsigned int mode)
 //		 MMC_CNTRL, value);
 }
 
-/* To mask all all interrupts.*/
+/* To mask all interrupts.*/
 void dwmac_mmc_intr_all_mask(void __iomem *ioaddr)
 {
 	writel(MMC_DEFAULT_MASK, ioaddr + MMC_RX_INTR_MASK);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index c922fde..875d5ad 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -27,6 +27,7 @@
 #define DRV_MODULE_VERSION	"March_2013"
 
 #include <linux/clk.h>
+#include <linux/clocksource.h>
 #include <linux/stmmac.h>
 #include <linux/phy.h>
 #include <linux/pci.h>
@@ -83,11 +84,14 @@ struct stmmac_priv {
 	int mii_irq[PHY_MAX_ADDR];
 
 	struct stmmac_extra_stats xstats ____cacheline_aligned_in_smp;
+	int active_vlans;
 	struct plat_stmmacenet_data *plat;
 	struct dma_features dma_cap;
 	struct stmmac_counters mmc;
 	int hw_cap_support;
 	int synopsys_id;
+	int irqmode_msi;
+	struct pci_dev *pdev;
 	u32 msg_enable;
 	int wolopts;
 	int wol_irq;
@@ -188,6 +192,7 @@ static inline int stmmac_register_pci(void)
 static inline void stmmac_unregister_pci(void)
 {
 }
+
 #endif /* CONFIG_STMMAC_PCI */
 
 #endif /* __STMMAC_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index c5f9cb8..19e32f5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -32,6 +32,7 @@
 
 #include "stmmac.h"
 #include "dwmac_dma.h"
+#include "dwmac1000.h"
 
 #define REG_SPACE_SIZE	0x1054
 #define MAC100_ETHTOOL_NAME	"st_mac100"
@@ -322,9 +323,7 @@ static int stmmac_ethtool_getsettings(struct net_device *dev,
 		return -EBUSY;
 	}
 	cmd->transceiver = XCVR_INTERNAL;
-	spin_lock_irq(&priv->lock);
 	rc = phy_ethtool_gset(phy, cmd);
-	spin_unlock_irq(&priv->lock);
 	return rc;
 }
 
@@ -359,9 +358,7 @@ static int stmmac_ethtool_setsettings(struct net_device *dev,
 		return 0;
 	}
 
-	spin_lock(&priv->lock);
 	rc = phy_ethtool_sset(phy, cmd);
-	spin_unlock(&priv->lock);
 
 	return rc;
 }
@@ -394,7 +391,7 @@ static int stmmac_ethtool_get_regs_len(struct net_device *dev)
 static void stmmac_ethtool_gregs(struct net_device *dev,
 			  struct ethtool_regs *regs, void *space)
 {
-	int i;
+	int i, offset = 0;
 	u32 *reg_space = (u32 *) space;
 
 	struct stmmac_priv *priv = netdev_priv(dev);
@@ -415,9 +412,21 @@ static void stmmac_ethtool_gregs(struct net_device *dev,
 		/* MAC registers */
 		for (i = 0; i < 55; i++)
 			reg_space[i] = readl(priv->ioaddr + (i * 4));
+
+		/* VLAN registers */
+		offset = i;
+		reg_space[offset++] = readl(priv->ioaddr + GMAC_VLAN_TAG_REP);
+		reg_space[offset++] = readl(priv->ioaddr + GMAC_VLAN_HASH);
+
+		/* 1588 registers */
+		for (i = 0; i < 13; i++)
+			reg_space[i + offset] =
+				readl(priv->ioaddr + (GMAC_TS_CTRL + (i * 4)));
+
 		/* DMA registers */
+		offset += i;
 		for (i = 0; i < 22; i++)
-			reg_space[i + 55] =
+			reg_space[i + offset] =
 			    readl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));
 	}
 }
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index cb83154..5539b9d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -28,6 +28,9 @@
 	https://bugzilla.stlinux.com/
 *******************************************************************************/
 
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+#include <asm/qrk.h>
+#endif
 #include <linux/clk.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -144,6 +147,8 @@ static irqreturn_t stmmac_interrupt(int irq, void *dev_id);
 #ifdef CONFIG_STMMAC_DEBUG_FS
 static int stmmac_init_fs(struct net_device *dev);
 static void stmmac_exit_fs(void);
+static int debugfs_registered;
+
 #endif
 
 #define STMMAC_COAL_TIMER(x) (jiffies + usecs_to_jiffies(x))
@@ -992,13 +997,53 @@ static int stmmac_init_rx_buffers(struct stmmac_priv *priv, struct dma_desc *p,
 }
 
 /**
+ * init_dma_err_cleanup
+ *
+ * @dev: net device to clean
+ * Description: Does a cleanup if kmalloc fails during init
+ */
+static void init_dma_err_cleanup(struct stmmac_priv *priv)
+{
+	int i;
+	if (priv->tx_skbuff != NULL)
+		kfree(priv->tx_skbuff);
+	priv->tx_skbuff = NULL;
+
+	if (priv->rx_skbuff_dma != NULL) {
+		/* Set the max buffer size according to the DESC mode
+		 * and the MTU. Note that RING mode allows 16KiB bsize. */
+		unsigned int bfsize = \
+			priv->hw->ring->set_16kib_bfsize(priv->dev->mtu);
+
+		for (i = 0; i < priv->dma_rx_size; i++) {
+			if (priv->rx_skbuff_dma[i] != 0) {
+				dma_unmap_single( \
+					priv->device, priv->rx_skbuff_dma[i], \
+					bfsize, DMA_FROM_DEVICE);
+			}
+		}
+		kfree(priv->rx_skbuff_dma);
+		priv->rx_skbuff_dma = NULL;
+	}
+
+	if (priv->rx_skbuff != NULL) {
+		for (i = 0; i < priv->dma_rx_size; i++) {
+			if (priv->rx_skbuff[i] != NULL)
+				dev_kfree_skb(priv->rx_skbuff[i]);
+		}
+		kfree(priv->rx_skbuff);
+		priv->rx_skbuff = NULL;
+	}
+}
+
+/**
  * init_dma_desc_rings - init the RX/TX descriptor rings
  * @dev: net device structure
  * Description:  this function initializes the DMA RX/TX descriptors
  * and allocates the socket buffers. It suppors the chained and ring
  * modes.
  */
-static void init_dma_desc_rings(struct net_device *dev)
+static int init_dma_desc_rings(struct net_device *dev)
 {
 	int i;
 	struct stmmac_priv *priv = netdev_priv(dev);
@@ -1030,7 +1075,7 @@ static void init_dma_desc_rings(struct net_device *dev)
 						   &priv->dma_tx_phy,
 						   GFP_KERNEL);
 		if ((!priv->dma_erx) || (!priv->dma_etx))
-			return;
+			return -ENOMEM;
 	} else {
 		priv->dma_rx = dma_alloc_coherent(priv->device, rxsize *
 						  sizeof(struct dma_desc),
@@ -1041,17 +1086,30 @@ static void init_dma_desc_rings(struct net_device *dev)
 						  &priv->dma_tx_phy,
 						  GFP_KERNEL);
 		if ((!priv->dma_rx) || (!priv->dma_tx))
-			return;
+			return -ENOMEM;
 	}
 
 	priv->rx_skbuff_dma = kmalloc_array(rxsize, sizeof(dma_addr_t),
 					    GFP_KERNEL);
+	if (priv->rx_skbuff_dma == NULL)
+		return -ENOMEM;
+
 	priv->rx_skbuff = kmalloc_array(rxsize, sizeof(struct sk_buff *),
 					GFP_KERNEL);
+	if (priv->rx_skbuff == NULL) {
+		init_dma_err_cleanup(priv);
+		return -ENOMEM;
+	}
+
 	priv->tx_skbuff_dma = kmalloc_array(txsize, sizeof(dma_addr_t),
 					    GFP_KERNEL);
 	priv->tx_skbuff = kmalloc_array(txsize, sizeof(struct sk_buff *),
 					GFP_KERNEL);
+	if (priv->tx_skbuff == NULL) {
+		init_dma_err_cleanup(priv);
+		return -ENOMEM;
+	}
+
 	if (netif_msg_drv(priv))
 		pr_debug("(%s) dma_rx_phy=0x%08x dma_tx_phy=0x%08x\n", __func__,
 			 (u32) priv->dma_rx_phy, (u32) priv->dma_tx_phy);
@@ -1110,6 +1168,8 @@ static void init_dma_desc_rings(struct net_device *dev)
 
 	if (netif_msg_hw(priv))
 		stmmac_display_rings(priv);
+
+	return 0;
 }
 
 static void dma_free_rx_skbufs(struct stmmac_priv *priv)
@@ -1524,6 +1584,26 @@ static int stmmac_init_dma_engine(struct stmmac_priv *priv)
 }
 
 /**
+ *  stmmac_hw_set_rx_ipc
+ *  @priv : pointer to the private device structure.
+ *  Enables RX IPC offload if the feature is supported in hardware
+ */
+static int stmmac_hw_set_rx_ipc(struct stmmac_priv *priv, bool on)
+{
+	int ret = 0;
+
+	/* Enable the IPC (Checksum Offload) and check if the feature has been
+	 * enabled during the core configuration.
+	 */
+	ret = priv->hw->mac->set_rx_ipc(priv->ioaddr, on);
+	if (on == true && !ret) {
+		pr_warn(" RX IPC Checksum Offload not configured.\n");
+		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
+	}
+	return ret;
+}
+
+/**
  * stmmac_tx_timer: mitigation sw timer for tx.
  * @data: data pointer
  * Description:
@@ -1587,7 +1667,12 @@ static int stmmac_open(struct net_device *dev)
 	priv->dma_tx_size = STMMAC_ALIGN(dma_txsize);
 	priv->dma_rx_size = STMMAC_ALIGN(dma_rxsize);
 	priv->dma_buf_sz = STMMAC_ALIGN(buf_sz);
-	init_dma_desc_rings(dev);
+	ret = init_dma_desc_rings(dev);
+	if (ret < 0) {
+		pr_err("%s: DMA initialization failed\n", __func__);
+		goto open_error;
+	}
+
 
 	/* DMA initialization and SW reset */
 	ret = stmmac_init_dma_engine(priv);
@@ -1643,6 +1728,11 @@ static int stmmac_open(struct net_device *dev)
 	/* Set the HW DMA mode and the COE */
 	stmmac_dma_operation_mode(priv);
 
+	/* Enable RX IPC if supported by silicon */
+	ret = stmmac_hw_set_rx_ipc(priv, true);
+	if(!ret)
+		goto open_error_lpiirq;
+
 	/* Extra statistics */
 	memset(&priv->xstats, 0, sizeof(struct stmmac_extra_stats));
 	priv->xstats.threshold = tc;
@@ -1654,9 +1744,12 @@ static int stmmac_open(struct net_device *dev)
 		pr_warn("%s: failed PTP initialisation\n", __func__);
 
 #ifdef CONFIG_STMMAC_DEBUG_FS
-	ret = stmmac_init_fs(dev);
-	if (ret < 0)
-		pr_warn("%s: failed debugFS registration\n", __func__);
+	if (debugfs_registered == 0) {
+		debugfs_registered = 1;
+		ret = stmmac_init_fs(dev);
+		if (ret < 0)
+			pr_warn("%s: failed debugFS registration\n", __func__);
+	}
 #endif
 	/* Start the ball rolling... */
 	DBG(probe, DEBUG, "%s: DMA RX/TX processes started...\n", dev->name);
@@ -2242,9 +2335,19 @@ static netdev_features_t stmmac_fix_features(struct net_device *dev,
 	if (priv->plat->bugged_jumbo && (dev->mtu > ETH_DATA_LEN))
 		features &= ~NETIF_F_ALL_CSUM;
 
+	stmmac_hw_set_rx_ipc(priv, features & NETIF_F_RXCSUM);
+
 	return features;
 }
 
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+	#define mask_pvm(x) qrk_pci_pvm_mask(x)
+	#define unmask_pvm(x) qrk_pci_pvm_unmask(x)
+#else
+	#define mask_pvm(x)
+	#define unmask_pvm(x)
+#endif
+
 /**
  *  stmmac_interrupt - main ISR
  *  @irq: interrupt number.
@@ -2263,10 +2366,11 @@ static irqreturn_t stmmac_interrupt(int irq, void *dev_id)
 		return IRQ_NONE;
 	}
 
+	mask_pvm(priv->pdev);
+
 	/* To handle GMAC own interrupts */
 	if (priv->plat->has_gmac) {
-		int status = priv->hw->mac->host_irq_status((void __iomem *)
-							    dev->base_addr,
+		int status = priv->hw->mac->host_irq_status(priv,
 							    &priv->xstats);
 		if (unlikely(status)) {
 			/* For LPI we need to save the tx status */
@@ -2280,6 +2384,8 @@ static irqreturn_t stmmac_interrupt(int irq, void *dev_id)
 	/* To handle DMA interrupts */
 	stmmac_dma_interrupt(priv);
 
+	unmask_pvm(priv->pdev);
+
 	return IRQ_HANDLED;
 }
 
@@ -2517,6 +2623,20 @@ static void stmmac_exit_fs(void)
 }
 #endif /* CONFIG_STMMAC_DEBUG_FS */
 
+#ifdef STMMAC_VLAN_HASH
+static int stmmac_vlan_rx_add_vid(struct net_device *dev, __be16 proto, unsigned short vid)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	return priv->hw->mac->vlan_rx_add_vid(priv, vid);
+}
+
+static int stmmac_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, unsigned short vid)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	return priv->hw->mac->vlan_rx_kill_vid(priv, vid);
+}
+#endif
+
 static const struct net_device_ops stmmac_netdev_ops = {
 	.ndo_open = stmmac_open,
 	.ndo_start_xmit = stmmac_xmit,
@@ -2527,6 +2647,10 @@ static const struct net_device_ops stmmac_netdev_ops = {
 	.ndo_tx_timeout = stmmac_tx_timeout,
 	.ndo_do_ioctl = stmmac_ioctl,
 	.ndo_set_config = stmmac_config,
+#ifdef STMMAC_VLAN_HASH
+	.ndo_vlan_rx_add_vid = stmmac_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid = stmmac_vlan_rx_kill_vid,
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = stmmac_poll_controller,
 #endif
@@ -2599,11 +2723,7 @@ static int stmmac_hw_init(struct stmmac_priv *priv)
 	/* To use alternate (extended) or normal descriptor structures */
 	stmmac_selec_desc_mode(priv);
 
-	ret = priv->hw->mac->rx_ipc(priv->ioaddr);
-	if (!ret) {
-		pr_warn(" RX IPC Checksum Offload not configured.\n");
-		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
-	}
+	ret = stmmac_hw_set_rx_ipc(priv, true);
 
 	if (priv->plat->rx_coe)
 		pr_info(" RX Checksum Offload Engine supported (type %d)\n",
@@ -2677,6 +2797,12 @@ struct stmmac_priv *stmmac_dvr_probe(struct device *device,
 	/* Both mac100 and gmac support receive VLAN tag detection */
 	ndev->features |= NETIF_F_HW_VLAN_CTAG_RX;
 #endif
+#ifdef STMMAC_VLAN_HASH
+	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+	ndev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+				NETIF_F_RXCSUM;
+#endif
+
 	priv->msg_enable = netif_msg_init(debug, default_msg_level);
 
 	if (flow_ctrl)
@@ -2757,7 +2883,7 @@ int stmmac_dvr_remove(struct net_device *ndev)
 {
 	struct stmmac_priv *priv = netdev_priv(ndev);
 
-	pr_info("%s:\n\tremoving driver", __func__);
+	pr_info("%s:\n\tremoving driver\n", __func__);
 
 	priv->hw->dma->stop_rx(priv->ioaddr);
 	priv->hw->dma->stop_tx(priv->ioaddr);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 023b7c2..f2d6b97 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -23,30 +23,164 @@
   Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
 *******************************************************************************/
 
+#include <linux/dmi.h>
 #include <linux/pci.h>
+#include <linux/platform_data/quark.h>
 #include "stmmac.h"
 
-struct plat_stmmacenet_data plat_dat;
-struct stmmac_mdio_bus_data mdio_data;
-struct stmmac_dma_cfg dma_cfg;
+/* List of supported PCI device IDs */
+#define STMMAC_VENDOR_ID 0x700
+#define STMMAC_DEVICE_ID 0x1108
+#define STMMAC_QUARK_ID 0x0937
+#define MAX_INTERFACES	 0x02
+
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+static int enable_msi = 1;
+#else
+static int enable_msi; /* by default initialized to 0 */
+#endif
+module_param(enable_msi, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+
+struct stmmac_qrk_mac_data {
+	int phy_addr;
+	int bus_id;
+	const char *name;
+};
+
+static struct stmmac_qrk_mac_data phy_data[] = {
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 1,
+		.name		= "QuarkEmulation",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 2,
+		.name		= "QuarkEmulation",
+	},
+	{
+		.phy_addr	= 3,
+		.bus_id		= 1,
+		.name		= "ClantonPeakSVP",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 2,
+		.name		= "ClantonPeakSVP",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "KipsBay",
+	},
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name 		= "KipsBay",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "CrossHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 2,
+		.name		= "CrossHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "ClantonHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 2,
+		.name		= "ClantonHill",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "Galileo",
+	},
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name		= "Galileo",
+	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "GalileoGen2",
+	},
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name		= "GalileoGen2",
+	},
+};
 
-static void stmmac_default_data(void)
+
+static int stmmac_find_phy_addr(int mdio_bus_id)
 {
-	memset(&plat_dat, 0, sizeof(struct plat_stmmacenet_data));
-	plat_dat.bus_id = 1;
-	plat_dat.phy_addr = 0;
-	plat_dat.interface = PHY_INTERFACE_MODE_GMII;
-	plat_dat.clk_csr = 2;	/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
-	plat_dat.has_gmac = 1;
-	plat_dat.force_sf_dma_mode = 1;
-
-	mdio_data.phy_reset = NULL;
-	mdio_data.phy_mask = 0;
-	plat_dat.mdio_bus_data = &mdio_data;
-
-	dma_cfg.pbl = 32;
-	dma_cfg.burst_len = DMA_AXI_BLEN_256;
-	plat_dat.dma_cfg = &dma_cfg;
+	int i = 0;
+	const char *board_name = dmi_get_system_info(DMI_BOARD_NAME);
+	if (board_name == NULL)
+		return -1;
+
+	for (; i < sizeof(phy_data)/sizeof(struct stmmac_qrk_mac_data); i++) {
+		if ((!strcmp(phy_data[i].name, board_name)) &&
+			phy_data[i].bus_id == mdio_bus_id)
+			return phy_data[i].phy_addr;
+	}
+
+	return -1;
+}
+
+static int stmmac_default_data(struct plat_stmmacenet_data *plat_dat,
+			       int mdio_bus_id, const struct pci_device_id *id)
+{
+	int phy_addr = 0;
+	memset(plat_dat, 0, sizeof(struct plat_stmmacenet_data));
+
+	plat_dat->mdio_bus_data = kzalloc(sizeof(struct stmmac_mdio_bus_data),
+					GFP_KERNEL);
+	if (plat_dat->mdio_bus_data == NULL)
+		return -ENOMEM;
+
+	plat_dat->dma_cfg = kzalloc(sizeof(struct stmmac_dma_cfg), GFP_KERNEL);
+	if (plat_dat->dma_cfg == NULL)
+		return -ENOMEM;
+
+	if (id->device ==  STMMAC_QUARK_ID) {
+		phy_addr = stmmac_find_phy_addr(mdio_bus_id);
+		if (phy_addr == -1)
+			return -ENODEV;
+
+		plat_dat->interface = PHY_INTERFACE_MODE_RMII;
+		/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
+
+		plat_dat->dma_cfg->pbl = 16;
+		plat_dat->dma_cfg->fixed_burst = 1;
+	} else {
+		plat_dat->interface = PHY_INTERFACE_MODE_GMII;
+		/* clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */
+
+		plat_dat->dma_cfg->pbl = 32;
+	}
+
+	plat_dat->bus_id = mdio_bus_id;
+	plat_dat->phy_addr = phy_addr;
+	plat_dat->clk_csr = 2;
+	plat_dat->has_gmac = 1;
+	plat_dat->force_sf_dma_mode = 1;
+	plat_dat->mdio_bus_data->phy_reset = NULL;
+	plat_dat->mdio_bus_data->phy_mask = 0;
+	plat_dat->dma_cfg->burst_len = DMA_AXI_BLEN_256;
+
+	return 0;
 }
 
 /**
@@ -67,14 +201,28 @@ static int stmmac_pci_probe(struct pci_dev *pdev,
 	int ret = 0;
 	void __iomem *addr = NULL;
 	struct stmmac_priv *priv = NULL;
+	struct plat_stmmacenet_data *plat_dat = NULL;
 	int i;
+	static int bus_id = 1;
+
+	plat_dat = kmalloc(sizeof(struct plat_stmmacenet_data), GFP_KERNEL);
+	if (plat_dat == NULL) {
+		ret = -ENOMEM;
+		goto err_out_map_failed;
+	}
+
+	/* return -ENODEV for non existing PHY, stop probing here  */
+	ret = stmmac_default_data(plat_dat, bus_id, id);
+	if (ret != 0)
+		goto err_platdata;
+
 
 	/* Enable pci device */
 	ret = pci_enable_device(pdev);
 	if (ret) {
 		pr_err("%s : ERROR: failed to enable %s device\n", __func__,
 		       pci_name(pdev));
-		return ret;
+		goto err_platdata;
 	}
 	if (pci_request_regions(pdev, STMMAC_RESOURCE_NAME)) {
 		pr_err("%s: ERROR: failed to get PCI region\n", __func__);
@@ -91,15 +239,29 @@ static int stmmac_pci_probe(struct pci_dev *pdev,
 			pr_err("%s: ERROR: cannot map register memory aborting",
 			       __func__);
 			ret = -EIO;
-			goto err_out_map_failed;
+			goto err_iomap_failed;
 		}
 		break;
 	}
+	if (NULL == addr) {
+		pr_err("%s: couldn't find register memory\n", __func__);
+		ret = -EIO;
+		goto err_iomap_failed;
+	}
+
 	pci_set_master(pdev);
+	if (enable_msi == 1) {
+		ret = pci_enable_msi(pdev);
+		if (ret)
+			pr_info("stmmac MSI mode NOT enabled\n");
+		else
+			pr_info("stmmac MSI mode enabled\n");
+	}
 
-	stmmac_default_data();
+	pr_info("Vendor 0x%04x Device 0x%04x\n",
+		id->vendor, id->device);
 
-	priv = stmmac_dvr_probe(&(pdev->dev), &plat_dat, addr);
+	priv = stmmac_dvr_probe(&(pdev->dev), plat_dat, addr);
 	if (!priv) {
 		pr_err("%s: main driver probe failed", __func__);
 		ret = -ENODEV;
@@ -107,20 +269,36 @@ static int stmmac_pci_probe(struct pci_dev *pdev,
 	}
 	priv->dev->irq = pdev->irq;
 	priv->wol_irq = pdev->irq;
+	priv->irqmode_msi = enable_msi;
+	priv->pdev = pdev;
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	priv->lpi_irq = -ENXIO;
+#endif
 
 	pci_set_drvdata(pdev, priv->dev);
 
 	pr_debug("STMMAC platform driver registration completed");
+	bus_id++;
 
 	return 0;
 
 err_out:
 	pci_clear_master(pdev);
-err_out_map_failed:
+	iounmap(addr);
+err_iomap_failed:
 	pci_release_regions(pdev);
 err_out_req_reg_failed:
 	pci_disable_device(pdev);
-
+err_platdata:
+	if (plat_dat != NULL) {
+		if (plat_dat->dma_cfg != NULL)
+			kfree(plat_dat->dma_cfg);
+		if (plat_dat->mdio_bus_data != NULL)
+			kfree(plat_dat->mdio_bus_data);
+		kfree(plat_dat);
+	}
+err_out_map_failed:
+	bus_id++;
 	return ret;
 }
 
@@ -139,6 +317,19 @@ static void stmmac_pci_remove(struct pci_dev *pdev)
 	stmmac_dvr_remove(ndev);
 
 	pci_set_drvdata(pdev, NULL);
+
+	if (enable_msi == 1)
+		if (pci_dev_msi_enabled(pdev))
+			pci_disable_msi(pdev);
+
+	if (priv->plat != NULL) {
+		if (priv->plat->dma_cfg != NULL)
+			kfree(priv->plat->dma_cfg);
+		if (priv->plat->mdio_bus_data != NULL)
+			kfree(priv->plat->mdio_bus_data);
+		kfree(priv->plat);
+	}
+
 	pci_iounmap(pdev, priv->ioaddr);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
@@ -150,7 +341,11 @@ static int stmmac_pci_suspend(struct pci_dev *pdev, pm_message_t state)
 	struct net_device *ndev = pci_get_drvdata(pdev);
 	int ret;
 
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	ret = stmmac_freeze(ndev);
+#else
 	ret = stmmac_suspend(ndev);
+#endif
 	pci_save_state(pdev);
 	pci_set_power_state(pdev, pci_choose_state(pdev, state));
 
@@ -164,16 +359,14 @@ static int stmmac_pci_resume(struct pci_dev *pdev)
 	pci_set_power_state(pdev, PCI_D0);
 	pci_restore_state(pdev);
 
-	return stmmac_resume(ndev);
+	return stmmac_restore(ndev);
 }
 #endif
 
-#define STMMAC_VENDOR_ID 0x700
-#define STMMAC_DEVICE_ID 0x1108
-
 static DEFINE_PCI_DEVICE_TABLE(stmmac_id_table) = {
 	{PCI_DEVICE(STMMAC_VENDOR_ID, STMMAC_DEVICE_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_MAC)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, STMMAC_QUARK_ID)},
 	{}
 };
 
-- 
1.7.5.4

