From c2cf20e5c582b1e7685662b1322f9b16a0b02f2f Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 11 Nov 2013 10:40:11 +0800
Subject: [PATCH 02/12] intel-quark: 0.8.0 integration.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/Kconfig                                   |   28 +-
 arch/x86/boot/compressed/Makefile                  |    2 +-
 arch/x86/boot/compressed/misc.c                    |    8 -
 arch/x86/include/asm/cln.h                         |    4 +-
 arch/x86/include/asm/imr.h                         |    2 +-
 arch/x86/kernel/cpu/intel.c                        |   11 +
 arch/x86/kernel/setup.c                            |    5 +-
 arch/x86/platform/Makefile                         |    1 -
 arch/x86/platform/cln/Makefile                     |   16 -
 arch/x86/platform/cln/intel_cln_board_data.c       |  217 ----
 arch/x86/platform/cln/intel_cln_esram.c            | 1188 --------------------
 arch/x86/platform/cln/intel_cln_esram.h            |  107 --
 arch/x86/platform/cln/intel_cln_esram_test.c       |  602 ----------
 arch/x86/platform/cln/intel_cln_esram_test.h       |   43 -
 arch/x86/platform/cln/intel_cln_imr.c              |  716 ------------
 arch/x86/platform/cln/intel_cln_imr.h              |  148 ---
 arch/x86/platform/cln/intel_cln_imr_kernel.c       |  138 ---
 arch/x86/platform/cln/intel_cln_imr_test.c         |  357 ------
 arch/x86/platform/cln/intel_cln_layout_data.c      |  100 --
 .../x86/platform/cln/intel_cln_plat_clanton_hill.c |  205 ----
 .../x86/platform/cln/intel_cln_plat_clanton_peak.c |  122 --
 arch/x86/platform/cln/intel_cln_plat_cross_hill.c  |  373 ------
 arch/x86/platform/cln/intel_cln_plat_data.c        |  485 --------
 arch/x86/platform/cln/intel_cln_plat_izmir.c       |  263 -----
 arch/x86/platform/cln/intel_cln_plat_kips_bay.c    |  183 ---
 arch/x86/platform/cln/intel_cln_sb.c               |  263 -----
 arch/x86/platform/cln/intel_cln_smep_test.c        |  290 -----
 arch/x86/platform/efi/efi.c                        |   13 +-
 drivers/dma/Kconfig                                |    2 +-
 drivers/i2c/busses/Kconfig                         |    2 +-
 drivers/i2c/busses/i2c-designware-core.c           |    3 +
 drivers/iio/accel/Kconfig                          |    8 +
 drivers/iio/accel/Makefile                         |    1 +
 drivers/iio/accel/lis331dlh_intel_cln.c            |  675 +++++++++++
 drivers/iio/adc/ad7298.c                           |    2 +-
 drivers/iio/adc/max78m6610_lmu.c                   |   20 +-
 drivers/iio/common/Kconfig                         |    1 +
 drivers/iio/common/Makefile                        |    1 +
 drivers/iio/common/st_sensors/Kconfig              |   20 +
 drivers/iio/common/st_sensors/Makefile             |   10 +
 drivers/iio/common/st_sensors/st_sensors_buffer.c  |  116 ++
 drivers/iio/common/st_sensors/st_sensors_core.c    |  435 +++++++
 drivers/iio/common/st_sensors/st_sensors_i2c.c     |   80 ++
 drivers/iio/common/st_sensors/st_sensors_spi.c     |  128 +++
 drivers/iio/common/st_sensors/st_sensors_trigger.c |   78 ++
 drivers/mfd/Kconfig                                |    4 +-
 drivers/mfd/cy8c9540a.c                            |  217 +++-
 drivers/mfd/intel_cln_gip_gpio.c                   |    5 +-
 drivers/mfd/intel_cln_gip_i2c.c                    |    2 +-
 drivers/mfd/intel_cln_gip_test.c                   |    2 +-
 drivers/mfd/lpc_sch.c                              |    2 +-
 drivers/net/ethernet/stmicro/stmmac/common.h       |    2 +-
 .../net/ethernet/stmicro/stmmac/dwmac1000_dma.c    |    2 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |    4 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |    2 +-
 drivers/platform/x86/Kconfig                       |   72 +--
 drivers/platform/x86/Makefile                      |    5 +-
 drivers/platform/x86/intel_cln_ecc_scrub.c         |  766 -------------
 drivers/platform/x86/intel_cln_thermal.c           |  360 ------
 drivers/platform/x86/quark/Kconfig                 |   75 ++
 drivers/platform/x86/quark/Makefile                |   18 +
 drivers/platform/x86/quark/intel_cln_audio_ctrl.c  |  514 +++++++++
 drivers/platform/x86/quark/intel_cln_audio_ctrl.h  |   45 +
 drivers/platform/x86/quark/intel_cln_board_data.c  |  207 ++++
 drivers/platform/x86/quark/intel_cln_ecc_scrub.c   |  668 +++++++++++
 drivers/platform/x86/quark/intel_cln_esram.c       | 1144 +++++++++++++++++++
 drivers/platform/x86/quark/intel_cln_esram.h       |  107 ++
 drivers/platform/x86/quark/intel_cln_esram_test.c  |  602 ++++++++++
 drivers/platform/x86/quark/intel_cln_esram_test.h  |   43 +
 drivers/platform/x86/quark/intel_cln_imr.c         |  584 ++++++++++
 drivers/platform/x86/quark/intel_cln_imr.h         |  155 +++
 drivers/platform/x86/quark/intel_cln_imr_kernel.c  |  139 +++
 drivers/platform/x86/quark/intel_cln_imr_test.c    |  357 ++++++
 drivers/platform/x86/quark/intel_cln_layout_data.c |  100 ++
 .../x86/quark/intel_cln_plat_clanton_hill.c        |  197 ++++
 .../x86/quark/intel_cln_plat_clanton_peak.c        |   92 ++
 .../platform/x86/quark/intel_cln_plat_cross_hill.c |  387 +++++++
 drivers/platform/x86/quark/intel_cln_plat_data.c   |  455 ++++++++
 .../platform/x86/quark/intel_cln_plat_galileo.c    |  264 +++++
 .../platform/x86/quark/intel_cln_plat_kips_bay.c   |  176 +++
 drivers/platform/x86/quark/intel_cln_sb.c          |  252 +++++
 drivers/platform/x86/quark/intel_cln_smep_test.c   |  290 +++++
 drivers/platform/x86/quark/intel_cln_thermal.c     |  360 ++++++
 drivers/spi/Kconfig                                |    4 +-
 drivers/spi/spi-pxa2xx-pci.c                       |   10 +-
 drivers/spi/spi-pxa2xx.c                           |   38 +-
 drivers/usb/host/pci-quirks.c                      |    4 +-
 include/linux/iio/common/st_sensors.h              |  290 +++++
 include/linux/iio/common/st_sensors_i2c.h          |   20 +
 include/linux/iio/common/st_sensors_spi.h          |   20 +
 include/linux/platform_data/clanton.h              |    2 +-
 include/linux/platform_data/lis331dlh_intel_cln.h  |   36 +
 92 files changed, 9423 insertions(+), 7149 deletions(-)
 delete mode 100644 arch/x86/platform/cln/Makefile
 delete mode 100644 arch/x86/platform/cln/intel_cln_board_data.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_esram.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_esram.h
 delete mode 100644 arch/x86/platform/cln/intel_cln_esram_test.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_esram_test.h
 delete mode 100644 arch/x86/platform/cln/intel_cln_imr.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_imr.h
 delete mode 100644 arch/x86/platform/cln/intel_cln_imr_kernel.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_imr_test.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_layout_data.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_cross_hill.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_data.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_izmir.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_plat_kips_bay.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_sb.c
 delete mode 100644 arch/x86/platform/cln/intel_cln_smep_test.c
 create mode 100644 drivers/iio/accel/lis331dlh_intel_cln.c
 create mode 100644 drivers/iio/common/st_sensors/Kconfig
 create mode 100644 drivers/iio/common/st_sensors/Makefile
 create mode 100644 drivers/iio/common/st_sensors/st_sensors_buffer.c
 create mode 100644 drivers/iio/common/st_sensors/st_sensors_core.c
 create mode 100644 drivers/iio/common/st_sensors/st_sensors_i2c.c
 create mode 100644 drivers/iio/common/st_sensors/st_sensors_spi.c
 create mode 100644 drivers/iio/common/st_sensors/st_sensors_trigger.c
 delete mode 100644 drivers/platform/x86/intel_cln_ecc_scrub.c
 delete mode 100644 drivers/platform/x86/intel_cln_thermal.c
 create mode 100644 drivers/platform/x86/quark/Kconfig
 create mode 100644 drivers/platform/x86/quark/Makefile
 create mode 100644 drivers/platform/x86/quark/intel_cln_audio_ctrl.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_audio_ctrl.h
 create mode 100644 drivers/platform/x86/quark/intel_cln_board_data.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_ecc_scrub.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_esram.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_esram.h
 create mode 100644 drivers/platform/x86/quark/intel_cln_esram_test.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_esram_test.h
 create mode 100644 drivers/platform/x86/quark/intel_cln_imr.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_imr.h
 create mode 100644 drivers/platform/x86/quark/intel_cln_imr_kernel.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_imr_test.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_layout_data.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_data.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_galileo.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_sb.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_smep_test.c
 create mode 100644 drivers/platform/x86/quark/intel_cln_thermal.c
 create mode 100644 include/linux/iio/common/st_sensors.h
 create mode 100644 include/linux/iio/common/st_sensors_i2c.h
 create mode 100644 include/linux/iio/common/st_sensors_spi.h
 create mode 100644 include/linux/platform_data/lis331dlh_intel_cln.h

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 43c9464..38931fc 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -418,33 +418,13 @@ config X86_INTEL_CE
 	  This option compiles in support for the CE4100 SOC for settop
 	  boxes and media devices.
 
-config INTEL_CLN_SOC
-	bool "Intel Clanton platform support"
+config INTEL_QUARK_X1000_SOC
+	bool "Intel Quark X1000 SOC support"
 	depends on M586TSC
 	select ARCH_REQUIRE_GPIOLIB
 	---help---
-	  Clanton is a Lakemore based system on chip. This option enables
-	  probing for various PCI-IDs of several on-chip devices. This flag
-	  serves as the high-level dependency for both north-cluster and
-	  south-cluster dependencies associated with Clanton.
-
-choice
-	prompt "Clanton board type"
-	depends on INTEL_CLN_SOC
-	help
-	  There are different Clanton SoC boards, ranging from test boards
-	  (FPGA emulation, Silicon Verification Platform) to reference
-	  boards.
-
-	  If unsure, select FPGA emulation.
-
-config INTEL_CLN_SOC_FPGAEMU
-	bool "FPGA emulation"
-
-config INTEL_CLN_SOC_SVP
-	bool "SVP - Silicon Verification Platform"
-
-endchoice
+	  Quark X1000 SOC support . This option enables probing for various
+	  PCI-IDs of several on-chip devices provided by the X1000
 
 config X86_WANT_INTEL_MID
 	bool "Intel MID platform support"
diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 83745b0..7fc1225 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -26,7 +26,7 @@ HOST_EXTRACFLAGS += -I$(srctree)/tools/include
 
 VMLINUX_OBJS = $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
 	$(obj)/string.o $(obj)/cmdline.o $(obj)/early_serial_console.o \
-	$(obj)/piggy.o $(obj)/early_imr.o
+	$(obj)/piggy.o
 
 $(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone
 
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index 31686ee..88f7ff6 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -145,10 +145,6 @@ static int lines, cols;
 #include "../../../../lib/decompress_unlzo.c"
 #endif
 
-#ifdef CONFIG_INTEL_CLN_SOC
-extern void decompress_kernel_imr(struct boot_params * boot);
-#endif
-
 static void scroll(void)
 {
 	int i;
@@ -360,10 +356,6 @@ asmlinkage void decompress_kernel(void *rmode, memptr heap,
 		error("Wrong destination address");
 #endif
 
-#ifdef CONFIG_INTEL_CLN_SOC
-	decompress_kernel_imr(real_mode);
-#endif
-
 	debug_putstr("\nDecompressing Linux... ");
 	decompress(input_data, input_len, NULL, NULL, output, NULL, error);
 	parse_elf(output);
diff --git a/arch/x86/include/asm/cln.h b/arch/x86/include/asm/cln.h
index b172613..4a5b0e3 100644
--- a/arch/x86/include/asm/cln.h
+++ b/arch/x86/include/asm/cln.h
@@ -68,7 +68,7 @@ static inline void cln_pci_pvm_unmask(struct pci_dev * dev)
 }
 
 /* Convienence macros */
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
        #define mask_pvm(x) cln_pci_pvm_mask(x)
        #define unmask_pvm(x) cln_pci_pvm_unmask(x) 
 #else
@@ -77,7 +77,7 @@ static inline void cln_pci_pvm_unmask(struct pci_dev * dev)
 #endif
 
 /* Serial */
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
 	#define SERIAL_PORT_DFNS
 	#define BASE_BAUD 2764800
 #endif
diff --git a/arch/x86/include/asm/imr.h b/arch/x86/include/asm/imr.h
index b22012b..2c17eec 100644
--- a/arch/x86/include/asm/imr.h
+++ b/arch/x86/include/asm/imr.h
@@ -11,7 +11,7 @@
 #ifndef _ASM_X86_IMR_H
 #define _ASM_X86_IMR_H
 
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
 	extern int intel_cln_imr_runt_setparams(void);
 	extern int intel_cln_imr_lockall(void);
 #else
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 3e6ff6c..bed1341 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -143,6 +143,17 @@ static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 			setup_clear_cpu_cap(X86_FEATURE_ERMS);
 		}
 	}
+
+	/*
+	 * Quark X1000 PGE is advertised but not implemented. This matters since
+	 * cpu_has_pge is used to determine the type of TLB flushing to do. With
+	 * PGE not actually doing what it says on the tin writes to CR4.PGE do
+	 * nothing when we should be re-writing CR3 like a 486
+	 */
+	if (c->x86 == 5 && c->x86_model == 9){
+		printk(KERN_INFO "Disabling PGE capability bit\n");
+		setup_clear_cpu_cap(X86_FEATURE_PGE);
+	}
 }
 
 #ifdef CONFIG_X86_32
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 943afc1..c45af0b 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -763,7 +763,10 @@ void __init setup_arch(char **cmdline_p)
 			KERNEL_PGD_PTRS);
 
 	load_cr3(swapper_pg_dir);
-	__flush_tlb_all();
+	if (boot_cpu_data.x86 == 5 && boot_cpu_data.x86_model == 9)
+		__flush_tlb();
+	else
+		__flush_tlb_all();
 #else
 	printk(KERN_INFO "Command line: %s\n", boot_command_line);
 #endif
diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index 9892ddb..8d87439 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -1,7 +1,6 @@
 # Platform specific code goes here
 obj-y	+= ce4100/
 obj-y	+= efi/
-obj-y	+= cln/
 obj-y	+= geode/
 obj-y	+= iris/
 obj-y	+= mrst/
diff --git a/arch/x86/platform/cln/Makefile b/arch/x86/platform/cln/Makefile
deleted file mode 100644
index a60e30d..0000000
--- a/arch/x86/platform/cln/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_board_data.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_layout_data.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_data.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_clanton_hill.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_clanton_peak.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_cross_hill.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_kips_bay.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_izmir.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_sb.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr_kernel.o
-obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram.o
-obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr_test.o
-obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram_test.o
-#obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_smep_test.o
-
diff --git a/arch/x86/platform/cln/intel_cln_board_data.c b/arch/x86/platform/cln/intel_cln_board_data.c
deleted file mode 100644
index 6066598..0000000
--- a/arch/x86/platform/cln/intel_cln_board_data.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data accessor layer
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-
-#define DRIVER_NAME				"board_data"
-#define PFX					"MFH: "
-#define SPIFLASH_BASEADDR			0xFFF00000
-#define MFH_OFFSET				0x00008000
-#define PLATFORM_DATA_OFFSET			0x00010000
-#define MTD_PART_OFFSET				0x00050000
-#define MTD_PART_LEN				0x00040000
-#define MFH_PADDING				0x1E8
-#define MFH_MAGIC				0x5F4D4648
-#define FLASH_SIZE				(PLATFORM_DATA_OFFSET + 0x1000)
-
-/* MFH types supported @ version #1 */
-#define MFH_ITEM_FW_STAGE1			0x00000000
-#define MFH_ITEM_FW_STAGE1_SIGNED		0x00000001
-#define MFH_ITEM_FW_STAGE2			0x00000003
-#define MFH_ITEM_FW_STAGE2_SIGNED		0x00000004
-#define MFH_ITEM_FW_STAGE2_CONFIG		0x00000005
-#define MFH_ITEM_FW_STAGE2_CONFIG_SIGNED	0x00000006
-#define MFH_ITEM_FW_PARAMS			0x00000007
-#define MFH_ITEM_FW_RECOVERY			0x00000008
-#define MFH_ITEM_FW_RECOVERY_SIGNED		0x00000009
-#define MFH_ITEM_BOOTLOADER			0x0000000B
-#define MFH_ITEM_BOOTLOADER_SIGNED		0x0000000C
-#define MFH_ITEM_BOOTLOADER_CONFIG		0x0000000D
-#define MFH_ITEM_BOOTLOADER_CONFIG_SIGNED	0x0000000E
-#define MFH_ITEM_KERNEL				0x00000010
-#define MFH_ITEM_KERNEL_SIGNED			0x00000011
-#define MFH_ITEM_RAMDISK			0x00000012
-#define MFH_ITEM_RAMDISK_SIGNED			0x00000013
-#define MFH_ITEM_LOADABLE_PROGRAM		0x00000015
-#define MFH_ITEM_LOADABLE_PROGRAM_SIGNED	0x00000016
-#define MFH_ITEM_BUILD_INFO			0x00000018
-#define MFH_ITEM_VERSION			0x00000019
-
-struct intel_cln_mfh {
-	u32	id;
-	u32	ver;
-	u32	flags;
-	u32	next_block;
-	u32	item_count;
-	u32	boot_priority_list;
-	u8	padding[MFH_PADDING];
-};
-
-struct intel_cln_mfh_item {
-	u32	type;
-	u32	addr;
-	u32	len;
-	u32	res0;
-};
-
-static struct resource conf_res __initdata = {
-	.flags		= IORESOURCE_MEM,
-	.start		= 0,
-	.end		= 0,
-};
-
-static struct resource plat_res __initdata = {
-	.flags		= IORESOURCE_MEM,
-	.start		= 0,
-	.end		= 0,
-};
-
-static struct resource mtd_res __initdata = {
-	.flags		= IORESOURCE_MEM,
-	.start		= SPIFLASH_BASEADDR + MTD_PART_OFFSET,
-	.end		= SPIFLASH_BASEADDR + MTD_PART_OFFSET + MTD_PART_LEN - 1,
-};
-
-static struct platform_device conf_pdev = {
-	.name		= "cln-layout-conf",
-	.id		= -1,
-	.resource	= &conf_res,
-};
-
-static struct platform_device plat_pdev = {
-	.name		= "cln-plat",
-	.id		= -1,
-	.resource	= &plat_res,
-};
-
-struct kobject * board_data_kobj;
-EXPORT_SYMBOL_GPL(board_data_kobj);
-
-static bool mfh_plat_found = false;
-
-static long unsigned int flash_version_data;
-static ssize_t flash_version_show(struct kobject *kobj,
-                                struct kobj_attribute *attr, char *buf)
-{
-        return snprintf(buf, 12, "%#010lx\n", flash_version_data);
-}
-
-static struct kobj_attribute flash_version_attr =
-        __ATTR(flash_version, 0644, flash_version_show, NULL);
-
-/**
- * intel_cln_board_data_init
- *
- * Module entry point
- */
-static int __init intel_cln_board_data_init(void)
-{
-	extern struct kobject * firmware_kobj;
-	struct intel_cln_mfh __iomem * mfh;
-	struct intel_cln_mfh_item __iomem * item;
-	struct platform_device * pdev;
-	u32 count;
-	void __iomem * spi_data;
-
-	spi_data = ioremap(SPIFLASH_BASEADDR, FLASH_SIZE);
-	if (!spi_data)
-		return -ENODEV;
-
-	/* get mfh and first item pointer */	
-	mfh = spi_data + MFH_OFFSET;
-	if (mfh->id != MFH_MAGIC){
-		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
-		MFH_MAGIC, mfh->id, &mfh->id);
-		return -ENODEV;
-	}
-
-	pr_info(PFX"mfh @ 0x%p: id 0x%08lx ver 0x%08lx entries 0x%08lx\n",
-		mfh, (unsigned long)mfh->id, (unsigned long)mfh->ver,
-		(unsigned long)mfh->item_count);
-	item = (struct intel_cln_mfh_item __iomem *)
-		&mfh->padding [sizeof(u32) * mfh->boot_priority_list];
-	
-	/* board_data_kobj subordinate of firmware @ /sys/firmware/board_data */
-	board_data_kobj = kobject_create_and_add("board_data", firmware_kobj);
-	if (!board_data_kobj) {
-		pr_err(PFX"kset create error\n");
-		return -ENODEV;
-	}
-
-	/* Register flash regions as seperate platform devices */
-	for (count = 0; count < mfh->item_count; count++, item++){
-		pdev = NULL;
-
-		switch (item->type){
-		case MFH_ITEM_BUILD_INFO:
-			conf_res.start = item->addr;
-			conf_res.end = item->addr + item->len - 1;
-			pdev = &conf_pdev;
-			break;
-		case MFH_ITEM_VERSION:
-			flash_version_data = item->res0;
-			if(sysfs_create_file(board_data_kobj, 
-					&flash_version_attr.attr)) {
-                		pr_err("failed to create sysfs entry for flash version\n");
-				flash_version_data = 0;
-		        }
-			break;
-		default:
-			break;
-		}
-
-		if (pdev != NULL)
-			platform_device_register(pdev);
-	}
-
-	/* This ought to be encoded in the MFH ! */	
-	if (mfh_plat_found == false){
-		pr_err(PFX"Warning platform data MFH missing - using hardcoded "
-			"offsets\n");
-
-		/* Platform data */
-		plat_res.start = SPIFLASH_BASEADDR + PLATFORM_DATA_OFFSET;
-		/* Hardcode the size of header. */
-		count = 12 + *(uint32_t*)(spi_data + PLATFORM_DATA_OFFSET + sizeof(uint32_t));
-		plat_res.end = plat_res.start + count - 1;
-		platform_device_register(&plat_pdev);
-	}
-
-	iounmap(spi_data);
-	return 0;
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SPI Data API");
-MODULE_LICENSE("Dual BSD/GPL");
-module_init(intel_cln_board_data_init);
-
diff --git a/arch/x86/platform/cln/intel_cln_esram.c b/arch/x86/platform/cln/intel_cln_esram.c
deleted file mode 100644
index 91eaed7..0000000
--- a/arch/x86/platform/cln/intel_cln_esram.c
+++ /dev/null
@@ -1,1188 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton eSRAM overlay driver
- *
- * eSRAM is an on-chip fast access SRAM.
- *
- * This driver provides the ability to map a kallsyms derived symbol of
- * arbitrary length or a struct page entitiy.
- * A proc interface is provided to allow map of kernel structures, without
- * having to use the API from your code directly.
- *
- * Example:
- * echo ehci on > /proc/driver/esram/map
- *
- * An API is provided to allow for mapping of a) kernel symbols or b) pages.
- * eSRAM requires 4k physically aligned addresses to work - so a struct page
- * fits neatly into this.
- *
- * intel_cln_esram_map_sym(ohci_irq);
- * intel_cln_esram_map_page(virt_to_page(ohci_irq), "ohci_irq");
- * Are equivalent - with the exception that map_sym() can detect if a mapping
- * crosses a page-boundary, whereas map_page just maps one page. Generally use
- * map_sym() for code and map_page() for data
- *
- * To populte eSRAM we must copy data to a temporary buffer, overlay and
- * then copy data back to the eSRAM region.
- * 
- * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
- * to S0 we must repopulate eSRAM
- * Unmap code is included for reference however the cache coherency of unmap is
- * not guaranteed so the functionality is not exported by this code
- * 
- */
-#include <asm/cacheflush.h>
-#include <asm/desc.h>
-#include <asm/io.h>
-#include <asm/pgtable.h>
-#include <asm/special_insns.h>
-#include <asm-generic/uaccess.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kallsyms.h>
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-
-#include "intel_cln_esram.h"
-
-#define DRIVER_NAME			"intel-cln-esram"
-#define INTEL_CLN_ESRAM_PROCDIR		"driver/esram"
-#define STATS				"stats"
-#define MAPPED				"map"
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-/* Define size of pages, ECC scrub demark etc */
-#define MAX_PAGE_RETRIES		(100)
-#define MS_PER_HOUR			(3600000UL)
-#define ESRAM_PAGE_COUNT		INTEL_CLN_ESRAM_PAGE_COUNT
-#define ESRAM_PAGE_MASK			(0xFFFFF000)
-#define ESRAM_PAGE_SIZE			INTEL_CLN_ESRAM_PAGE_SIZE
-#define ESRAM_TOTAL_SIZE		(ESRAM_PAGE_COUNT * ESRAM_PAGE_SIZE)
-#define ECC_MAX_REFRESH_PERIOD		(48)
-#define ECC_DEFAULT_REFRESH_PERIOD	(24)
-#define ECC_DRAM_READSIZE		(512)		/* bytes per DRAM ECC */
-#define ECC_ESRAM_READSIZE		ESRAM_PAGE_SIZE	/* bytes per SRAM ECC */
-
-/* Register ID */
-#define ESRAM_PGPOOL_REG		(0x80)		/* PGPOOL */
-#define ESRAM_CTRL_REG			(0x81)		/* ESRAMCTRL */
-#define ESRAM_PGBLOCK_REG		(0x82)		/* Global page ctrl */
-#define ESCRM_ECCCERR_REG		(0x83)		/* Correctable ECC */
-#define ESRAM_ECCUCERR_REG		(0x84)		/* Uncorrectable ECC */
-
-/* Reg commands */
-#define ESRAM_CTRL_READ			(0x10)		/* Config reg */
-#define ESRAM_CTRL_WRITE		(0x11)		/* Config reg */
-#define ESRAM_PAGE_READ			(0x12)		/* Page config read */
-#define ESRAM_PAGE_WRITE		(0x13)		/* Page config write */
-
-/* ESRAMPGPOOL reg 0x80 - r/w opcodes 0x10/0x11 */
-#define ESRAM_PGPOOL_FLUSHING(x)	((x>>18)&0x1FF)
-#define ESRAM_PGPOOL_PGBUSY(x)		((x>>9)&0x1FF)
-
-/* ESRAMCTRL reg 0x81 - r/w opcodes 0x10/0x11 */
-#define ESRAM_CTRL_FLUSHPRI(x)		((x>>25)&0x03)	/* DRAM flush priority */
-#define ESRAM_CTRL_SIZE(x)		((x>>16)&0xFF)	/* # of 4k pages */
-#define ESRAM_CTRL_ECCTHRESH(x)		((x>>8)&0xFF)	/* ECC threshold */
-#define ESRAM_CTRL_THRESHMSG_EN		(0x00000080)	/* ECC notification */
-#define ESRAM_CTRL_ISAVAIL		(0x00000010)	/* ESRAM on die ? */
-#define ESRAM_CTRL_BLOCK_MODE		(0x00000008)	/* Block mode enable */
-#define ESRAM_CTRL_GLOBAL_LOCK		(0x00000004)	/* Global lock status */
-#define ESRAM_CTRL_FLUSHDISABLE		(0x00000002)	/* Global flush/dis */
-#define ESRAM_CTRL_SECDEC		(0x00000001)	/* ECC enable bit */
-
-/* PGBLOCK reg 0x82 - opcode 0x10/0x11 */
-#define ESRAM_PGBLOCK_FLUSHEN		(0x80000000)	/* Block flush enable */
-#define ESRAM_PGBLOCK_PGFLUSH		(0x40000000)	/* Flush the block */
-#define ESRAM_PGBLOCK_DISABLE		(0x20000000)	/* Block mode disable */
-#define ESRAM_PGBLOCK_ENABLE		(0x10000000)	/* Block mode enable */
-#define ESRAM_PGBLOCK_LOCK		(0x08000000)	/* Block mode lock en */
-#define ESRAM_PGBLOCK_INIT		(0x04000000)	/* Block init in prog */
-#define ESRAM_PGBLOCK_BUSY		(0x01000000)	/* Block is enabled */
-#define ESRAM_PGBLOCK_SYSADDR(x)	(x&0x000000FF)
-
-/* ESRAMPGCTRL - opcode 0x12/0x13 */
-#define ESRAM_PAGE_FLUSH_PAGE_EN	(0x80000000)	/* S3 autoflush */
-#define ESRAM_PAGE_FLUSH		(0x40000000)	/* Flush page to DRAM */
-#define ESRAM_PAGE_DISABLE		(0x20000000)	/* page disable bit */
-#define ESRAM_PAGE_EN			(0x10000000)	/* Page enable */
-#define ESRAM_PAGE_LOCK			(0x08000000)	/* Page lock en */
-#define ESRAM_PAGE_INITIALISING		(0x04000000)	/* Init in progress */
-#define ESRAM_PAGE_BUSY			(0x01000000)	/* Page busy */
-#define ESRAM_PAGE_MAP_SHIFT		(12)		/* Shift away 12 LSBs */
-
-/* Extra */
-#define ESRAM_MAP_OP			(0x01)
-#define ESRAM_UNMAP_OP			(0x00)
-
-/**
- * struct esram_refname
- *
- * Structure to hold a linked list of names
- */
-struct esram_refname {
-	char name[KSYM_SYMBOL_LEN];	/* Name of mapping */
-	struct list_head list;
-};
-
-/**
- * struct esram_page
- *
- * Represents an eSRAM page in our linked list
- */
-struct esram_page {
-
-	struct list_head list;		/* List entry descriptor */
-	struct list_head name_list;	/* Linked list for name references */
-	u32 id;				/* Page ID */
-	u32 phys_addr;			/* Physial address of page */
-	u32 refcount;			/* Reference count */
-	u32 vaddr;			/* Virtual address of page */
-
-};
-
-/**
- * struct intel_cln_esram_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_esram_dev{
-
-	/* Linux kernel structures */
-	struct list_head page_used;	/* Used pages */
-	struct list_head page_free;	/* Free pages */
-	spinlock_t slock;		/* Spinlock */
-	struct platform_device *pldev;	/* Platform device */
-	struct proc_dir_entry *pdir;	/* Proc directory */
-	struct proc_dir_entry *pmap;	/* /proc/drivers/esram/mapped */
-	struct proc_dir_entry *pstat;	/* /proc/drivers/esram/stats */
-
-	/* Actual data */
-	struct esram_page * pages;
-	u8 cbuf[ESRAM_PAGE_SIZE];
-
-	/* Stats */
-	u32 page_count;			/* As reported by silicon */
-	u32 page_disable_retries;	/* Aggreate count on disable */
-	u32 page_enable_retries;	/* Aggregate spin count page enable */
-	u32 page_free_ct;		/* Free pages for mapping code section */
-};
-
-static struct intel_cln_esram_dev esram_dev;
-
-#ifdef CONFIG_PROC_FS
-
-/* 
- * Kallsyms does not provide data addresses. To map important structures such as
- * the idt and gdt, we need to frig the lookup with the below. Other entities
- * can similarly be added. Note we map a page from the given address - anything
- * larger will require additional code to handle
- */
-struct esram_symex {
-	char * name;
-	void * vaddr;
-	u32 size;
-};
-
-static struct esram_symex esram_symex[] = 
-{
-	{
-		.name = "idt_table",
-		.vaddr = &idt_table,
-		.size = ESRAM_PAGE_SIZE,
-	},
-	{
-		.name = "gdt_page",
-		.vaddr = &gdt_page,
-		.size = ESRAM_PAGE_SIZE,
-	},
-};
-
-/**
- * intel_cln_esram_proc_stat_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates eSRAM state via /proc/driver/esram
- */
-static int intel_cln_esram_proc_stat_read(char * page, char ** start, off_t off,
-					  int count, int * eof, void * data)
-
-{
-	struct esram_page * epage = NULL;
-	int len = 0;
-	u32 pgpool = 0, ctrl = 0, pgblock = 0;
-	char * enabled = "enabled";
-	char * disabled = "disabled";
-
-	/* Display page-pool relevant data */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGPOOL_REG, &pgpool, 1);
-	len += snprintf(page, count,
-			"esram-pgpool\t\t\t: 0x%08x\n" 
-			"esram-pgpool.free\t\t: %u\n"
-			"esram-pgpool.flushing\t\t: %u\n",
-			pgpool,	ESRAM_PGPOOL_PGBUSY(pgpool)+1,
-			ESRAM_PGPOOL_FLUSHING(pgpool) + 1);
-	
-	/* Display ctrl reg - most of this is of interest */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	len += snprintf(page + len, count - len,
-			"esram-ctrl\t\t\t: 0x%08x\n"
-			"esram-ctrl.ecc\t\t\t: %s\n"
-			"esram-ctrl.ecc-theshold\t\t: %u\n"
-			"esram-ctrl.pages\t\t: %u\n"
-			"esram-ctrl.dram-flush-priorityi\t: %u\n",
-			ctrl, (ctrl & ESRAM_CTRL_SECDEC) ? enabled : disabled,
-			ESRAM_CTRL_ECCTHRESH(ctrl), ESRAM_CTRL_SIZE(ctrl)+1,
-			ESRAM_CTRL_FLUSHPRI(ctrl));
-
-	/* Display block ctrl/stat - we should be !block mode */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &pgblock, 1);
-	len += snprintf(page + len, count - len, "esram-block\t\t\t: 0x%08x\n",
-			pgblock);
-
-	/* Print ECC status regs */
-
-	/* Print per-page info */
-	len += snprintf(page + len, count - len, 
-			"free page\t\t\t: %u\nused page\t\t\t: %u\n"
-			"refresh  \t\t\t: %ums\npage enable retries\t\t: %u\n"
-			"page disable retries\t: %u\n",
-			esram_dev.page_free_ct, 
-			esram_dev.page_count-esram_dev.page_free_ct,
-			0,
-			esram_dev.page_enable_retries,
-			esram_dev.page_disable_retries);
-
-	spin_lock(&esram_dev.slock);
-	if(!list_empty(&esram_dev.page_free)){
-
-		epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
-		len += snprintf(page + len, count - len, 
-			"ecc next page \t\t\t: %u\n",epage->id);
-
-	}
-	spin_unlock(&esram_dev.slock);
-
-	/* Return len indicate eof */
-	*eof = 1;
-	return len;
-}
-
-/**
- * intel_cln_esram_proc_map_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- * 
- * Read back eSRAM mapped entries
- */
-static int
-intel_cln_esram_proc_map_read(char * page, char ** start, off_t off,
-				  int count, int * eof, void * data)
-
-{
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-	int len = 0;
-
-	spin_lock(&esram_dev.slock);
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		/* Print references */
-		list_for_each_entry(refname, &epage->name_list, list){
-			len += snprintf(page + len, count - len,
-				"%s ", refname->name);
-		}
-		/* Print data */
-		len += snprintf(page + len, count - len,
-			"\n\tPage virt 0x%08x phys 0x%08x\n"
-			"\tRefcount %u\n",
-			epage->vaddr, epage->phys_addr,
-			epage->refcount);
-	}
-	spin_unlock(&esram_dev.slock);
-
-	/* Return len indicate eof */
-	*eof = 1;
-	return len;
-}
-
-/**
- * intel_cln_esram_proc_map_write
- *
- * @param file: File pointer
- * @param buf: Data being sent from user-space
- * @param count: Number of bytes being sent
- * @param data: Statically set data in the /proc callback - unused
- * @return number of bytes successfully written or < 0 to indicate error
- *
- * Function allows user-space to switch mappings on/off with a simple
- * echo idt_table on > /proc/driver/esram/map type command
- */
-static int
-intel_cln_esram_proc_map_write(struct file *file, const char __user *buf, 
-			       unsigned long count, void *data )
-{
-	ssize_t ret = 0;
-	char * cbuf = NULL;
-	char * sbuf = NULL;
-	unsigned long vaddr = 0, i = 0;
-
-	if(count <= 1){
-		return -EINVAL;
-	}
-
-	/* Get input */
-	sbuf = cbuf = kzalloc(count+1, GFP_KERNEL);
-	if(cbuf == NULL){
-		return -ENOMEM;
-	}
-
-	ret = -EFAULT;	
-	if(copy_from_user(cbuf, buf, count))
-		goto done;
-
-	/* Fixup entity to scrub spaces */
-	while(sbuf < (cbuf + count)){
-		if(*sbuf == ' ' || *sbuf == '\r' || *sbuf =='\n'){
-			*sbuf = 0;
-			break;
-		}
-		sbuf++;
-	}
-
-	/* Check to see if we are being asked to map a non-kallsyms addr */
-	for(i = 0; i < sizeof(esram_symex)/sizeof(struct esram_symex); i++){
-		if(strcmp(cbuf, esram_symex[i].name) == 0){
-			ret = intel_cln_esram_map_range(
-				esram_symex[i].vaddr,
-				esram_symex[i].size,
-				esram_symex[i].name);
-			goto done;
-		}
-	}
-
-	/* This path relies on kallsyms to provide name/address data */
-	vaddr = kallsyms_lookup_name(cbuf);
-	if(vaddr == 0)
-		goto done;
-
-	ret = intel_cln_esram_map_symbol((void*)vaddr);
-done:
-	if(ret == 0)
-		ret = (ssize_t)count;
-	kfree(cbuf);
-	return ret;
-}
-
-/**
- * intel_cln_esram_add_procfs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Adds entries to procfs
- */
-static int intel_cln_esram_proc_add(void)
-{
-	esram_dev.pdir = proc_mkdir(INTEL_CLN_ESRAM_PROCDIR, NULL);
-	if(esram_dev.pdir == NULL){
-		return -ENOMEM;
-	}
-
-	esram_dev.pstat = create_proc_read_entry(STATS, 0, esram_dev.pdir,
-						 intel_cln_esram_proc_stat_read,
-						 NULL);
-	if(esram_dev.pstat == NULL){
-		return -EIO;
-	}
-
-	esram_dev.pmap = create_proc_entry(MAPPED, 0, esram_dev.pdir);
-	if(esram_dev.pmap == NULL){
-		return -EIO;
-	}
-	esram_dev.pmap->read_proc = intel_cln_esram_proc_map_read;
-	esram_dev.pmap->write_proc = intel_cln_esram_proc_map_write;
-	esram_dev.pmap->data = NULL;
-
-	return 0;
-}
-
-/**
- * intel_cln_esram_proc_remove
- *
- * @return nothing
- *
- * Removes /proc entires
- */
-static void intel_cln_esram_proc_remove(void)
-{
-	remove_proc_entry(MAPPED, esram_dev.pmap);
-	remove_proc_entry(STATS, esram_dev.pstat);
-	remove_proc_entry(INTEL_CLN_ESRAM_PROCDIR, NULL);
-}
-
-#else
-
-static int intel_cln_esram_proc_add(void){ return 0; }
-static void intel_cln_esram_proc_remove(void){ return; }
-
-#endif /* CONFIG_PROC_FS */
-
-/******************************************************************************
- *                                eSRAM Core
- ******************************************************************************/
-
-/**
- * intel_cln_esram_page_busy
- *
- * @param epage: Pointer to the page descriptor
- * @return boolean indicating whether or not a page is enabled
- */
-static int intel_cln_esram_page_busy(struct esram_page * epage, u8 lock)
-{
-	u32 reg = 0;
-
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, lock);
-	return (reg&(ESRAM_PAGE_BUSY | ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE));
-}
-
-/**
- * intel_cln_esram_fault
- *
- * Dump eSRAM registers and kernel panic
- * Nothing else to do at this point
- */
-void intel_cln_esram_fault(struct esram_page * epage, u32 lineno)
-{
-	u32 reg = 0, next = 0, prev = 0, prev_reg = 0;
-	u32 next_reg = 0, block = 0, ctrl = 0;
-
-	pr_err("eSRAM fault @ %s:%d\n", __FILE__, lineno);
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, 1);
-	pr_err("read page %d state 0x%08x\n", epage->id, reg);
-	if(epage->id == 0){
-		next = 1; prev = 127;
-	}else if(epage->id == 127){
-		next = 0; prev = 126;
-	}else{
-		next = epage->id+1;
-		prev = epage->id-1;
-	}
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, next, &next_reg, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, prev, &prev_reg, 1);
-
-	/* Get state */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
-
-	pr_err("eSRAM CTRL 0x%08x block 0x%08x\n", ctrl, block);
-	pr_err("Prev page %d state 0x%08x Next page %d state 0x%08x\n"
-		, next, next_reg, prev, prev_reg);
-	BUG();
-}
-
-
-/**
- * intel_cln_esram_page_enable
- *
- * @param epage: struct esram_page carries data to program to register
- * @param lock: Indicates whether to attain sb spinlock or not
- * 
- * Enable an eSRAM page spinning for page to become ready.
- */
-static void intel_cln_esram_page_enable(struct esram_page *epage, u8 lock)
-{
-	u32 ret = 0;
-
-	/* Fault if we try to enable a disabled page */
-	if(intel_cln_esram_page_busy(epage, lock)){
-		intel_cln_esram_fault(epage, __LINE__);
-	}
-
-	/* Program page mapping */
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id, 
-		ESRAM_PAGE_FLUSH_PAGE_EN | ESRAM_PAGE_EN | 
-			(epage->phys_addr>>ESRAM_PAGE_MAP_SHIFT), lock);
-	do {
-		/* Poll until page busy bit becomes true */
-		ret = intel_cln_esram_page_busy(epage, lock);
-
-		/* This branch should rarely if ever be true */
-		if(unlikely(ret == 0)){
-			esram_dev.page_enable_retries++;
-		}
-		
-	}while(ret == 0);
-}
-
-/**
- * intel_cln_esram_page_disable_sync
- *
- * @param epage: pointer to eSRAM page descriptor
- *
- * This function spins waiting for disable bit to clear, useful right after a
- * disable/disable-flush command. Interrupts are enabled here, sleeping is OK
- */
-static void intel_cln_esram_page_disable_sync(struct esram_page * epage)
-{
-	u32 ret = 0, retries = 0;
-	do {
-		/* Poll for busy bit clear */
-		ret = intel_cln_esram_page_busy(epage, 1);
-
-		/* This branch should rarely if ever be true */
-		if(unlikely(ret)){
-			esram_dev.page_disable_retries++;
-			retries++;
-		}
-
-		if(retries == MAX_PAGE_RETRIES){
-			intel_cln_esram_fault(epage, __LINE__);
-		}
-	}while(ret);
-}
-
-/**
- * intel_cln_esram_page_disable
- *
- * @param epage: struct esram_page carries data to program to register
- *
- * Disable the eSRAM page no flush. Interrupts are enabled here, sleeping is OK
- */
-static void intel_cln_esram_page_disable(struct esram_page *epage)
-{
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
-		ESRAM_PAGE_DISABLE, 1);
-	intel_cln_esram_page_disable_sync(epage);	
-}
-
-/**
- * intel_cln_esram_page_flush_disable
- *
- * @param epage: struct esram_page carries data to program to register
- *
- * Disable the eSRAM page - with flush. Note the architecture will block access
- * to the overlayed region until the flush has completed => irqs may be switched
- * on during this operation.
- */
-static void intel_cln_esram_page_flush_disable(struct esram_page *epage)
-{
-	
-
-	/* Do flush */
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
-		ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE, 1);
-
-	intel_cln_esram_page_disable_sync(epage);	
-}
-
-#if 0
-/**
- * intel_cln_esram_flush_disable_all
- *
- * Flushes and disables all enabled eSRAM pages
- */
-static void intel_cln_esram_page_flush_disable_all(void)
-{
-	struct esram_page * epage = NULL;
-	
-	spin_lock(&esram_dev.slock);
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		intel_cln_esram_page_flush_disable(epage);
-	}
-	spin_unlock(&esram_dev.slock);
-}
-#endif
-
-/**
- * intel_cln_esram_page_populate_atomic
- *
- * @param epage: Pointer to eSRAM page desciptor.
- * @return 0 placeholder, later versions may return error
- *
- * Function takes the mappings given in epage and uses the values to populate
- * an eSRAM page. The copy/enable/copy routine must be done atomically, since we
- * may be doing a memcpy() of an ISR for example.
- * For this reason we wrapper this entire call into a callback provided by 
- * side-band, which does a spin_lock_irqsave calls this function and then does
- * a spin_lock_irqrestore - thus guaranteeing atomicity of the below code and
- * respect for the locking strategy of the side-band driver
-  */
-static int intel_cln_esram_page_populate_atomic(struct esram_page * epage)
-{
-	unsigned long crz;
-
-	/* Copy away */	
-	memcpy(&esram_dev.cbuf, (void*)epage->vaddr, ESRAM_PAGE_SIZE);
-
-	/* If CR0.WP is true - flip it HSD # 4930660 */
-	crz = read_cr0();
-	if (crz & X86_CR0_WP){
-		write_cr0(crz & (~X86_CR0_WP));
-	}
-
-	/* Disable NMI */
-	outb(0x80, 0x70);
-	
-	/*  Enable page mapping */
-	intel_cln_esram_page_enable(epage, 0);
-	
-	/* Copy back - populating memory overlay */
-	memcpy((void*)epage->vaddr, &esram_dev.cbuf,  ESRAM_PAGE_SIZE);
-
-	/* Re-enable NMI */
-	outb(0x00, 0x70);
-
-	/* Restore CR0.WP if appropriate HSD # 4930660 */
-	if (crz & X86_CR0_WP){
-		write_cr0(crz);
-	}
-	return 0;
-}
-
-/**
- * intel_cln_esram_page_populate
- *
- * @param epage: Pointer to eSRAM page desciptor.
- * @return 0 on success < 0 on failure
- *
- * Populates the page. set_memory_rw/set_memory_ro require local irqs enabled.
- * intel_cln_esram_page_populate_atomic - needs irqs switched off since memory
- * can be inconsistent during the populate operation. Depopulate operations are
- * architecturally guaranteed
- */
-static int intel_cln_esram_page_populate(struct esram_page * epage)
-{
-	int flip_rw = 0, level = 0, ret = 0;
-	pte_t * pte = epage != NULL ? lookup_address(epage->vaddr, &level):NULL;
-
-	if(unlikely(pte == NULL)){
-		return -EINVAL;
-	}
-
-	/* Determine if we need to set writable */
-	flip_rw = !(pte_write(*pte));
-	
-	/* Ensure memory is r/w - do so before spin_lock_irqsave */
-	if(flip_rw){
-		ret = set_memory_rw(epage->vaddr, 1);
-		if (ret != 0){
-			pr_err("%s error during set_memory_rw = %d\n",
-				__func__, ret);
-			return ret;
-		}
-	}
-
-	/* Force ECC update @ disable only */
-	intel_cln_esram_page_enable(epage, 1);
-	intel_cln_esram_page_disable(epage);
-
-	/* Enable and populate eSRAM page using callback in sb with irqs off */
-	ret |= intel_cln_sb_runfn_lock(
-		(int (*)(void*))intel_cln_esram_page_populate_atomic,(void*)epage);
-
-	/* If we set memory writable - restore previous state */
-	if(flip_rw){
-		ret |= set_memory_ro(epage->vaddr, 1);
-		if (ret != 0){
-			pr_err("%s error during set_memory_ro = %d\n",
-				__func__, ret);
-			return ret;
-		}
-	}
-
-	return ret;
-}
-/**
- * intel_cln_esram_page_addref
- *
- * @param epage: eSRAM page descriptor
- * @param name: Name of reference to add
- * @return zero on success negative on error
- *
- */
-static int intel_cln_esram_page_addref(struct esram_page * epage, char * name)
-{
-	struct esram_refname * refname = NULL;
-	if(unlikely(epage == NULL || name == NULL)){
-		return -EINVAL;
-	}
-
-	refname = kzalloc(sizeof(struct esram_refname), GFP_KERNEL);
-	if(unlikely(refname == NULL)){
-		return -ENOMEM;
-	}
-		
-	/* Add to list */
-	strncpy(refname->name, name, sizeof(refname->name));
-	list_add(&refname->list, &epage->name_list);
-
-	/* Bump reference count */
-	epage->refcount++;
-	return 0;
-}
-
-
-/**
- * __intel_cln_esram_map_page
- *
- * @param page: Page to map
- * @param name: Name of the mapping
- * @return 0 success < 0 failure
- *
- * Overlay a vritual address rangne eeds to be aligned to a 4k address.
- * Since multiple items can live in a 4k range, it is possible when calling
- * into map_page() that a previous mapping will have already covered some or all
- * of the mapping we want. This is not an error case, if the map function finds
- * it is being asked to map a 4k range already mapped it returns 0, to indicate
- * the mapping has suceeded i.e. it's already been mapped. This is logical if
- * you think about it. In contrast being asked to unmap a region not mapped is
- * clearly an error...
- *
- */
-static int __intel_cln_esram_map_page(u32 vaddr, char * name)
-{
-	int ret = 0;	
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-
-	if(unlikely(name == NULL)){
-		return -EINVAL;
-	}
-
-	if(unlikely(esram_dev.page_free_ct == 0)){
-		return -ENOMEM;
-	}
-
-	/* Verify if we have already mapped */
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		if(epage->vaddr == vaddr){
-
-			/* Page already mapped */
-			list_for_each_entry(refname, &epage->name_list, list){
-				if(strcmp(refname->name, name)==0){
-					/* Page mapped at this name */
-					return -EINVAL;
-				}
-			}
-			/* New symbol in previous mapping */
-			return intel_cln_esram_page_addref(epage, name);
-		}
-	}
-
-	/* Enumerate eSRAM page structure */
-	epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
-	epage->phys_addr = virt_to_phys((void*)vaddr);
-	epage->vaddr = vaddr;
-	ret = intel_cln_esram_page_addref(epage, name);
-	if(unlikely(ret < 0)){
-		return ret;
-	}
-	
-	/* Populate page */
-	ret = intel_cln_esram_page_populate(epage);
-
-	/* Move to used list */
-	list_move(&epage->list, &esram_dev.page_used);
-	esram_dev.page_free_ct--;
-
-	return ret;
-}
-
-/**
- * __intel_cln_esram_unmap_page
- *
- * @param page: Page to unmap
- * @param name: Name of the mapping
- * @return 0 success < 0 failure
- *
- * Unmap a previously mapped virutal address range.
- * Must be 4k aligned
- *
- */
-static int __intel_cln_esram_unmap_page(u32 vaddr, char * name)
-{
-	u8 found = 0;
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-
-	/* Find physical address */
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		if(epage->vaddr == vaddr){
-			found = 1;
-			break;
-		}
-	}
-
-	/* Bail out on error */
-	if(found == 0){
-		pr_err("0x%08x not mapped\n", vaddr);
-		return -EINVAL;
-	}
-
-	/* Determine reference to delete */
-	found = 0;
-	list_for_each_entry(refname, &epage->name_list, list){
-		if(strcmp(refname->name,name)==0){
-			found = 1;
-			break;
-		}
-	}
-	if(unlikely(found == 0)){
-		pr_err("No mapping %s!\n", name);
-		return -EINVAL;
-	}
-
-	/* Remove entry decrement reference count */	
-	list_del(&refname->list);
-	kfree(refname);
-	if(--epage->refcount > 0){
-		return 0;
-	}
-
-	/* Flush and disable page */
-	intel_cln_esram_page_flush_disable(epage);
-
-	/* Move to free list tail - scrub entries come from head */
-	list_move_tail(&epage->list, &esram_dev.page_free);
-	esram_dev.page_free_ct++;
-
-	return 0;
-}
-
-/**
- *
- * __intel_cln_esram_page_op
- *
- * @param vaddr: Virtual address of symbol
- * @param size: Size/length of symbol
- * @param name: Name of mapping
- * @param map: Boolean indicates whether to map or unmap the page
- * @return 0 success < 0 failure
- *
- * This function maps/unmaps a pages/pages given at the given vaddr. If
- * the extent of the symbol @ vaddr crosses a page boundary, then we map
- * multiple pages. Other stuff inside the page, gets a performance boost 'for
- * free'. Any other data in the page that crosses the physical page boundary
- * will be partially mapped.
- */
-static int __intel_cln_esram_page_op(u32 vaddr, u32 size, char *name, u8 map)
-{
-	unsigned long offset = 0, page_offset = 0;
-	u32  pages = size/ESRAM_PAGE_SIZE + ((size%ESRAM_PAGE_SIZE) ? 1 : 0);
-	int ret = 0;
-
-	/* Compare required pages to available pages */
-	if(map == ESRAM_MAP_OP){
-		if(pages > esram_dev.page_free_ct)
-			return -ENOMEM;
-	}else{
-		if(pages > esram_dev.page_count - esram_dev.page_free_ct)
-			return -ENOMEM;
-	}
-
-	/* Align to 4k and iterate the mappings */	
-	vaddr = vaddr&ESRAM_PAGE_MASK;
-	while(size > 0){
-
-		/* Map the page */
-		spin_lock(&esram_dev.slock);
-		if(map == ESRAM_MAP_OP){
-			ret = __intel_cln_esram_map_page(vaddr, name);
-							 
-		}else{
-			ret = __intel_cln_esram_unmap_page(vaddr, name);
-		}
-		spin_unlock(&esram_dev.slock);
-		if(unlikely(ret != 0)){
-			break;
-		}
-
-		/* Calc appropriate offsets */
-		page_offset = offset_in_page(vaddr);
-		if(page_offset + size > ESRAM_PAGE_SIZE){
-
-			offset = ESRAM_PAGE_SIZE - page_offset;
-			size -= offset;
-			vaddr += ESRAM_PAGE_SIZE; 
-
-		}else{
-			size = 0;
-		}
-	}
-
-	return ret;
-}
-
-/******************************************************************************
- *                                 eSRAM API
- ******************************************************************************/
-
-/**
- * intel_cln_esram_map_range
- *
- * @param vaddr: Virtual address to start mapping (must be 4k aligned)
- * @param size: Size to map from
- * @param mapname: Mapping name
- * @return 0 success < 0 failure
- *
- * Map 4k increments at given address to eSRAM.
- */
-int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname)
-{
-	if(size == 0 || mapname == NULL || vaddr == NULL){
-		return -EINVAL;
-	}
-	return __intel_cln_esram_page_op((u32)vaddr, size, mapname, ESRAM_MAP_OP);
-}
-EXPORT_SYMBOL(intel_cln_esram_map_range);
-
-/**
- * intel_cln_esram_map_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
- * kernel text section symbol (kernel or loaded module)
- *
- * We get the size of the symbol from kallsyms. We guarantee to map the entire
- * size of the symbol - plus whatever padding is necessary to get alignment to
- * eSRAM_PAGE_SIZE 
- * Other stuff inside the mapped pages will get a performance boost 'for free'.
- * If this free boost is not what you want then 
- *
- *	1. Align to 4k
- *	2. Pad to 4k
- *	3. Call intel_cln_esram_map_range()
- */
-int intel_cln_esram_map_symbol(void * vaddr)
-{
-	long unsigned int size = 0, offset = 0;
-	char symname[KSYM_SYMBOL_LEN];
-	
-	kallsyms_lookup_size_offset((long unsigned int)vaddr, &size, &offset);
-	if(size == 0){
-		return -EINVAL;
-	}
-	sprint_symbol(symname, (u32)vaddr);
-
-	return __intel_cln_esram_page_op((u32)vaddr, size, symname, 1);
-}
-EXPORT_SYMBOL(intel_cln_esram_map_symbol);
-
-/******************************************************************************
- *                        Module/PowerManagement hooks 
- ******************************************************************************/
-
-/**
- * intel_cln_esram_suspend
- *
- * @param pdev: Platform device structure (unused)
- * @param pm: Power managment descriptor
- * @return 0 success < 0 failure
- *
- * For each enabled page - flush to DRAM and disable eSRAM page.
- * For each 4k region the architecture guarantees atomicity of flush/disable.
- * Hence any memory transactions to the affected region will stall until
- * flush/disable completes - hence interrupts are left on.
- */
-static int intel_cln_esram_suspend(struct device * pdev)
-{
-	/* Flush and disable of eSRAM pages is carried out automatically */
-	return 0;
-}
-
-/**
- * intel_cln_esram_resume
- *
- * @param pm: Power management descriptor
- * @return 0 success < 0 failure
- *
- * Runs after resume_noirq. Switches pages back to ro, if appropriate. We do
- * this here since interrupts will be on, as required by the function
- * set_memory_ro. If it were possible to set memory ro in resume_noirq we would
- * do it there instead
- */
-static int intel_cln_esram_resume(struct device * pdev)
-{
-	struct esram_page * epage = NULL;
-	int ret = 0;
-
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		ret |= intel_cln_esram_page_populate(epage);
-	}
-	
-	return ret;
-}
-
-
-/**
- * intel_cln_esram_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_esram_probe(struct platform_device * pdev)
-{
-	int ret = 0;
-	u32 block = 0, ctrl = 0, i = 0, pgstat = 0;
-
-	memset(&esram_dev, 0x00, sizeof(esram_dev));
-	INIT_LIST_HEAD(&esram_dev.page_used);
-	INIT_LIST_HEAD(&esram_dev.page_free);
-	spin_lock_init(&esram_dev.slock);
-	esram_dev.page_free_ct = 0;
-	
-	/* Ensure block mode disabled */
-	block = ESRAM_PGBLOCK_DISABLE;
-	sb_write(SB_ID_ESRAM, ESRAM_CTRL_WRITE, ESRAM_PGBLOCK_REG, block, 1);
-
-	/* Get state */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
-
-	/* Verify state is good to go */
-	if (ctrl & ESRAM_CTRL_GLOBAL_LOCK){
-		pr_err ("eSRAM global lock @ 0x%08x\n", ctrl);
-		return -ENODEV;
-	}
-
-	if (block & (ESRAM_PGBLOCK_LOCK | ESRAM_PGBLOCK_ENABLE)){
-		pr_err ("eSRAM lock @ 0x%08x\n", block);
-		return -ENODEV;
-	}
-	pr_info("eSRAM CTRL 0x%08x block 0x%08x\n", ctrl, block);
-
-	/* Calculate # of pages silicon supports */
-	esram_dev.page_count = ESRAM_CTRL_SIZE(ctrl) + 1;
-	esram_dev.page_free_ct = esram_dev.page_count;
-	pr_info("eSRAM pages %d\n", esram_dev.page_free_ct);
-
-	if(esram_dev.page_free_ct <= 1){
-		pr_err("Too few pages reported by eSRAM sub-system\n");
-		return -ENOMEM;
-	}
-
-	/* Allocate an appropriate number of pages */
-	esram_dev.pages = kzalloc(esram_dev.page_count *
-		sizeof(struct esram_page), GFP_KERNEL);
-	if (esram_dev.pages == NULL){
-		return -ENOMEM;
-	}
-
-	/* Initialise list of free pages, explicitely disable as we go */
-	for(i = 0; i < esram_dev.page_count; i++){
-		INIT_LIST_HEAD(&esram_dev.pages[i].name_list);
-		esram_dev.pages[i].id = i;
-		
-		/* Read & verify page state */
-		sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, i, &pgstat, 1);
-		if(pgstat & (ESRAM_PAGE_BUSY | ESRAM_PAGE_LOCK)){
-			pr_err("eSRAM page %d state 0x%08x err\n", i, pgstat);
-			ret = -ENODEV;
-			goto err;
-		}
-
-		list_add(&esram_dev.pages[i].list, &esram_dev.page_free);
-	}
-
-	return intel_cln_esram_proc_add();
-err:
-	kfree(esram_dev.pages);
-	return ret;
-}
-
-/**
- * intel_cln_esram_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_esram_remove(struct platform_device * pdev)
-{
-	intel_cln_esram_proc_remove();
-	kfree(esram_dev.pages);
-
-	return 0;
-}
-
-/*
- * Power management operations
- */
-static const struct dev_pm_ops intel_cln_esram_pm_ops = {
-	.suspend = intel_cln_esram_suspend,
-	.resume = intel_cln_esram_resume,
-};
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_esram_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-		.pm = &intel_cln_esram_pm_ops,
-	},
-	.probe = intel_cln_esram_probe,
-	.remove = intel_cln_esram_remove,
-};
-
-module_platform_driver(intel_cln_esram_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton eSRAM overlay/ECC-scrub driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/arch/x86/platform/cln/intel_cln_esram.h b/arch/x86/platform/cln/intel_cln_esram.h
deleted file mode 100644
index af6156a..0000000
--- a/arch/x86/platform/cln/intel_cln_esram.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton eSRAM overlay driver
- *
- * eSRAM is an on-chip fast access SRAM.
- *
- * This driver provides the ability to map a kallsyms derived symbol of
- * arbitrary length or a struct page entitiy.
- * A proc interface is provided to allow map/unmap of kernel structures, without
- * having to use the API from your code directly.
- *
- * Example:
- * echo ehci_irq on > /proc/driver/esram/map
- * echo ehci_irq off > /proc/driver/esram/map
- *
- * An API is provided to allow for mapping of a) kernel symbols or b) pages.
- * eSRAM requires 4k physically aligned addresses to work - so a struct page
- * fits neatly into this.
- *
- * To populte eSRAM we must copy data to a temporary buffer, overlay and
- * then copy data back to the eSRAM region.
- * 
- * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
- * to S0 we must repopulate eSRAM
- * 
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
- */
-#ifndef __INTEL_CLN_ESRAM_H__
-#define __INTEL_CLN_ESRAM_H__
-
-#include <linux/module.h>
-
-/* Basic size of an eSRAM page */
-#define	INTEL_CLN_ESRAM_PAGE_SIZE	(0x1000)
-#define INTEL_CLN_ESRAM_PAGE_COUNT	(0x80)
-/**
- * intel_cln_esram_map_range
- *
- * @param vaddr: Virtual address to start mapping (must be 4k aligned)
- * @param size: Size to map from
- * @param mapname: Mapping name
- * @return 0 success < 0 failure
- *
- * Map 4k increments at given address to eSRAM.
- */
-int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname);
-
-/**
- * intel_cln_esram_unmap_range
- *
- * @param vaddr: The virtual address to unmap
- * @return 0 success < 0 failure
- *
- * Logical corollary of esram_map_page
- */
-int intel_cln_esram_unmap_range(void * vaddr, u32 size, char * mapname);
-
-/**
- * intel_cln_esram_map_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
- * kernel text section symbol (kernel or loaded module)
- *
- * We get the size of the symbol from kallsyms. We guarantee to map the entire
- * size of the symbol - plus whatever padding is necessary to get alignment to
- * eSRAM_PAGE_SIZE 
- * Other stuff inside the mapped pages will get a performance boost 'for free'.
- * If this free boost is not what you want then 
- *	1. Align to 4k
- *	2. Pad to 4k
- *	3. Call intel_cln_esram_map_range()
- */
-int intel_cln_esram_map_symbol(void * vaddr);
-
-/**
- * intel_cln_esram_unmap_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Logical corollary to intel_cln_esram_map_symbol
- * Undoes any mapping of pages starting at sym for sym's size
- */
-int intel_cln_esram_unmap_symbol(void * vaddr);
-
-#endif /* __INTEL_CLN_ESRAM_H__ */
diff --git a/arch/x86/platform/cln/intel_cln_esram_test.c b/arch/x86/platform/cln/intel_cln_esram_test.c
deleted file mode 100644
index 3d0573d..0000000
--- a/arch/x86/platform/cln/intel_cln_esram_test.c
+++ /dev/null
@@ -1,602 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_esram_test.c
- *
- * Simple test module to provide test cases for ITS integration
- *
- */
-#include <linux/cdev.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kallsyms.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#include "intel_cln_esram.h"
-#include "intel_cln_esram_test.h"
-
-#define DRIVER_NAME			"intel_cln_esram_test"
-
-/**
- * struct intel_cln_esram_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_esram_test_dev{
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-	char * pdata;
-	u32 size;
-};
-
-static struct intel_cln_esram_test_dev esram_test_dev;
-static struct class *esram_test_class;
-static DEFINE_MUTEX(esram_test_mutex);
-static int esram_test_major;
-static char * name = "testmap";
-
-/******************************************************************************
- *                                eSRAM BIST
- ******************************************************************************/
-
-static int crc_cache = 0;
-
-unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
-{
-	if (first < end)
-		return end - first;
-	else
-		return (ULLONG_MAX - first) + end;	
-}
-
-
-/**
- * intel_cln_crctest
- *
- * Do a CRC32 of the specified region. Return the time taken in jiffies
- */
-static unsigned long long intel_cln_crctest(char * pdata, u32 crcsize)
-{
-	unsigned long long j1 = 0, j2 = 0;
-	
-	rdtscll(j1);
-
-	/* Flush LMT cache to introduce cache miss to our test */
-	__asm__ __volatile__("wbinvd\n");
-	crc32(0, pdata, crcsize);
-
-	rdtscll(j2);
-
-	return tsc_delta(j1, j2);
-}
-
-#ifdef __DEBUG__
-#define bist_err(x){\
-	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
-	return x;\
-}
-#else
-#define bist_err(x){\
-	return x;\
-}
-#endif
-/**
- * intel_cln_esram_perpage_overlay
- *
- * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
- */
-int intel_cln_esram_test_perpage_overlay(void)
-{
-
-	int ret = 0;
-	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-
-	/* Basic test of full range of memory */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-
-#if 0
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_pageref_count
- *
- * Ensure page reference couting works as expected
- */
-int intel_cln_esram_test_pagref_count(void)
-{
-	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE;
-	int ret = 0;
-
-	return 0;
-	/* Map a page */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Map a second time - and verify mapping fails */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-
-#if 0
-	/* Unmap - OK */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Verify second unmap operation fails */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-#endif	
-	return 0;
-}
-
-extern uint32_t get_crc32table_le(void);
-
-/**
- * intel_cln_esram_test_contig_perfmetric
- *
- * Do a CRC16 for a contigous area of memory
- * Map contigous area and get a CRC16
- *
- * Ensure overlayed data takes less time than regular unoverlayed DRAM
- */
-int intel_cln_esram_test_contig_perfmetric(void)
-{
-	u32 crcsize = 0x60000;
-	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
-	uint32_t crc32table_le = kallsyms_lookup_name("crc32table_le");
-	int ret = 0;
-
-	if (crc32table_le == 0){
-		pr_err("%s unable to fine symbol crc32table_le\n", __func__);
-		return -ENODEV;
-	}
-
-	/* Get raw data metric */
-	crc_cache = 1;
-	crc32_fullunmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
-
-	/* Map CRC16 symbol (algorithm) + code (data) */
-	ret = intel_cln_esram_map_symbol(crc32_le);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_map_symbol((void*)crc32table_le);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Map test data */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	/* Get metric */
-	crc_cache = 1;
-	crc32_fullmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
-#if 0
-	/* Tidy up */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_unmap_range(((void*)crc32_table),
-					  sizeof(crc32_table), name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_unmap_symbol(crc32);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
-	pr_info("%s mapped count %llu unmapped %llu\n",
-		__func__, crc32_fullmap, crc32_fullunmap);
-	return crc32_fullmap < crc32_fullunmap;
-}
-
-/**
- * intel_cln_esram_test_kernel_codemap
- *
- * Maps some kernel code - a data section and then calls the code contained
- * therein. Proves out the running overlayed eSRAM works
- */
-int intel_cln_esram_test_kernel_codemap(void)
-{
-#if 0
-	int ret = intel_cln_esram_map_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-	
-	/* run the mapped code */
-	msleep(1);
-
-	/* unmap */	
-	ret = intel_cln_esram_unmap_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_kernel_datamap
- *
- * Tests mapping/unmapping of a kernel data structure
- */
-int intel_cln_esram_test_kernel_datamap(void)
-{
-#if 0
-	unsigned long jtag = 0;
-	unsigned long ctrl = 0;
-
-	/* Map the interrupt descriptor table */
-	int ret = intel_cln_esram_map_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	jtag = jiffies;
-	/* Wait for jiffies to tick or timeout to occur (failure) */
-	while(jtag == jiffies){
-		ctrl++;
-	}
-
-	/* unmap */	
-	ret = intel_cln_esram_unmap_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_sub_unsub
- *
- * Subscribe and unsubscribe 100% of available eSRAM
- */
-int intel_cln_esram_test_sub_unsub(void)
-{
-	int ret = 0;
-	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE * INTEL_CLN_ESRAM_PAGE_COUNT;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-	/* Basic test of full range of memory */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-#if 0
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_over_sub
- *
- * Test oversubscription of eSRAM
- */
-int intel_cln_esram_test_over_sub(void)
-{
-	int ret = 0;
-	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE * (INTEL_CLN_ESRAM_PAGE_COUNT + 1);
-
-	/* Over subscribe should fail */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		//intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-		bist_err(-EFAULT);
-	}
-	return 0;
-}
-
-/*
- * File ops
- */
-static long esram_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	cmd -= CLN_ESRAM_IOCTL_BASE;
-	switch (cmd) {
-		case CLN_F_SW_APP_ESRAM_0:
-			/* Per page overlay */
-			ret = intel_cln_esram_test_perpage_overlay();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_1:
-			/* Verify page reference counting */
-			ret = intel_cln_esram_test_pagref_count();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_2:
-			/* Performance metric or overlay contig RAM */
-			ret = intel_cln_esram_test_contig_perfmetric();
-			if (ret == 1)
-				ret = 0;
-			break;
-
-		case CLN_F_SW_APP_ESRAM_3:
-			/* Verify mapping of kernel code section */
-			/* Covered by test #2 */
-			ret = 0; //intel_cln_esram_test_kernel_codemap();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_4:
-			/* Verify mapping of kernel data section (IDT) */
-			/* Covered by test #2 */
-			ret = 0; //intel_cln_esram_test_kernel_datamap();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_5:
-			/* Complete subscribe/unsubscribe eSRAM */
-			ret = intel_cln_esram_test_sub_unsub();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_6:
-			/* Over subscribe eSRAM */
-			ret = intel_cln_esram_test_over_sub();
-			break;
-
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int esram_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
-		mutex_unlock(&esram_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (esram_test_dev.opened) {
-		mutex_unlock(&esram_test_dev.open_lock);
-		mutex_unlock(&esram_test_mutex);
-		return -EINVAL;
-	}
-
-	esram_test_dev.opened++;
-	mutex_unlock(&esram_test_dev.open_lock);
-	mutex_unlock(&esram_test_mutex);
-
-	return 0;
-}
-
-static int esram_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_dev.open_lock);
-	esram_test_dev.opened = 0;
-	mutex_unlock(&esram_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations esram_test_file_ops = {
-	.open = esram_test_open,
-	.release = esram_test_release,
-	.unlocked_ioctl = esram_test_ioctl,
-	.llseek = no_llseek,
-};
-
-
-/**
- * intel_cln_esram_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_esram_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	esram_test_dev.size = INTEL_CLN_ESRAM_PAGE_COUNT * INTEL_CLN_ESRAM_PAGE_SIZE;
-
-	/* Get memory */
-	esram_test_dev.pdata = kzalloc(esram_test_dev.size, GFP_KERNEL);
-	if(unlikely(esram_test_dev.pdata == NULL)){
-		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
-		return -ENOMEM;
-	}
-
-	mutex_init(&esram_test_dev.open_lock);
-	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
-	esram_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(esram_test_class, NULL,
-				 MKDEV(esram_test_major, minor), NULL,
-				 "esramtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	printk(KERN_INFO "%s/%s/%s complete OK !!\n", __FUNCTION__, __DATE__,__TIME__);
-	return 0;
-
-}
-
-/**
- * intel_cln_esram_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_esram_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
-
-	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
-	cdev_del(&esram_test_dev.cdev);
-	kfree(esram_test_dev.pdata);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_esram_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_esram_test_remove,
-};
-
-/**
- * intel_cln_esram_init
- *
- * @return 0 success < 0 failure
- *
- * Module entry point
- */
-static int __init intel_cln_esram_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	esram_test_class = class_create(THIS_MODULE,"cln_esram_test");
-	if (IS_ERR(esram_test_class)) {
-		retval = PTR_ERR(esram_test_class);
-		printk(KERN_ERR "esram_test: can't register earam_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	esram_test_major = MAJOR(dev);
-
-	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
-	esram_test_dev.pldev = platform_create_bundle(
-		&intel_cln_esram_test_driver, intel_cln_esram_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(esram_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(esram_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(esram_test_class);
-err:
-	return retval;
-}
-
-/**
- * intel_cln_esram_exit
- *
- * Module exit
- */
-static void __exit intel_cln_esram_test_exit(void)
-{
-	platform_device_unregister(esram_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_esram_test_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton eSRAM ITS driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_init(intel_cln_esram_test_init);
-module_exit(intel_cln_esram_test_exit);
diff --git a/arch/x86/platform/cln/intel_cln_esram_test.h b/arch/x86/platform/cln/intel_cln_esram_test.h
deleted file mode 100644
index 98e4546..0000000
--- a/arch/x86/platform/cln/intel_cln_esram_test.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_esram_test.h
- *
- * Define integers for ioctl operation
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
- */
-
-#ifndef __INTEL_CLN_ESRAM_TEST_H__
-#define __INTEL_CLN_ESRAM_TEST_H__
-
-#define CLN_ESRAM_IOCTL_BASE	255
-#define CLN_F_SW_APP_ESRAM_0	0x00000000
-#define CLN_F_SW_APP_ESRAM_1	0x00000001
-#define CLN_F_SW_APP_ESRAM_2	0x00000002
-#define CLN_F_SW_APP_ESRAM_3	0x00000003
-#define CLN_F_SW_APP_ESRAM_4	0x00000004
-#define CLN_F_SW_APP_ESRAM_5	0x00000005
-#define CLN_F_SW_APP_ESRAM_6	0x00000006
-#define CLN_F_SW_APP_ESRAM_7	0x00000007
-#define CLN_F_SW_APP_ESRAM_8	0x00000008
-
-#endif /* __INTEL_CLN_ESRAM_TEST_H__ */
-
diff --git a/arch/x86/platform/cln/intel_cln_imr.c b/arch/x86/platform/cln/intel_cln_imr.c
deleted file mode 100644
index d955b52..0000000
--- a/arch/x86/platform/cln/intel_cln_imr.c
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * A total number of 8 IMRs have implemented by Clanton SoC,
- * Some IMRs might be already occupied by BIOS or Linux during
- * booting time.
- *
- * user can cat /proc/driver/imr/status for current imr usage report.
- *
- * To allocate imr, the input memory address format has to match the 1k algined
- * actual Physical address required by HW.
- *
- * The IMR alloc API will locate the next available IMR slot set up
- * with input memory region, then apply the input access right masks
- *
- * The IMR can be freed with the pre-allocated memory addresses.
- */
-
-#include <asm-generic/uaccess.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/proc_fs.h>
-
-#include "intel_cln_imr.h"
-#include <asm/imr.h>
-
-#define DRIVER_NAME	"intel-cln-imr"
-#define IMR_PROC_DIR	"driver/imr"
-#define IMR_PROC_FILE	"status"
-
-#define IMR_READ_MASK	0x1
-#define IMR_MAX_ID	7
-
-#ifndef phys_to_virt
-#define phys_to_virt __va
-#endif
-
-/* IMR HW register address structre */
-struct cln_imr_reg_t {
-	u8  imr_xl;   /* high address register */
-	u8  imr_xh;   /* low address register */
-	u8  imr_rm;   /* read mask register */
-	u8  imr_wm;   /* write mask register */
-} cln_imr_reg_t;
-
-/**
- * struct cln_imr_addr_t
- *
- * IMR memory address structure
- */
-struct cln_imr_addr_t {
-	u32 addr_low;      /* low boundary memroy address */
-	u32 addr_high;     /* high boundary memory address */
-	u32 read_mask;     /* read access right mask */
-	u32 write_mask;    /* write access right mask */
-} cln_imr_addr_t;
-
-/**
- * struct cln_imr_pack
- *
- * local IMR pack structure
- */
-struct cln_imr_pack {
-	bool occupied;       /* IMR occupied */
-	bool locked;         /* IMR lock */
-	struct cln_imr_reg_t reg;   /* predefined imr register address */
-	struct cln_imr_addr_t addr; /* IMR address region structure */
-	unsigned char info[MAX_INFO_SIZE]; /* IMR info */
-} cln_imr_pack;
-
-
-/* Predefined HW register address */
-static struct cln_imr_reg_t imr_reg_value[] = {
-	{ IMR0L, IMR0H, IMR0RM, IMR0WM },
-	{ IMR1L, IMR1H, IMR1RM, IMR1WM },
-	{ IMR2L, IMR2H, IMR2RM, IMR2WM },
-	{ IMR3L, IMR3H, IMR3RM, IMR3WM },
-	{ IMR4L, IMR4H, IMR4RM, IMR4WM },
-	{ IMR5L, IMR5H, IMR5RM, IMR5WM },
-	{ IMR6L, IMR6H, IMR6RM, IMR6WM },
-	{ IMR7L, IMR7H, IMR7RM, IMR7WM }
-};
-
-/* proc directory */
-struct proc_dir_entry *pdir;
-
-/* proc file interface /proc/drivers/imr/stats */
-struct proc_dir_entry *pstat;
-
-/**
- * module parameter
- * IMR slot should repersant the available IMR region from
- * linux boot and BIOS.
- *
- * For example: imr_bit_mask = 0x10111001
- * occupied IMR: 0, 3, 4, 5, 7
- * un-occupied IMR: 1, 2, 6
- */
-static int imr_bit_mask = 0xFF;
-module_param(imr_bit_mask, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(imr_bit_mask, "IMR bit mask");
-
-/**
- * module parameter
- * if IMR lock is a nozero value, all unlocked
- * imrs will be locked regardless the usage.
- */
-static int imr_lock = 1;
-module_param(imr_lock, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(imr_lock, "switch to lock unused IMR");
-
-/* local IMR data structure */
-struct cln_imr_pack local_imr[IMR_MAXID];
-
-/**
- * intel_cln_imr_read_reg
- *
- * @param reg: register address
- * @return nothing
- *
- * return register value from input address.
- */
-static inline uint32_t intel_cln_imr_read_reg(uint8_t reg)
-{
-	uint32_t temp = 0;
-
-	intel_cln_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE, reg, &temp, 0);
-	return temp;
-}
-
-/**
- * intel_cln_imr_update_local_data
- *
- * @return nothing
- *
- * Populate IMR data structure from HW.
- */
-static inline void intel_cln_imr_update_local_data(void)
-{
-	int i = 0;
-
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		local_imr[i].addr.addr_low =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
-		local_imr[i].addr.addr_high =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xh);
-		local_imr[i].addr.read_mask =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_rm);
-		local_imr[i].addr.write_mask =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_wm);
-
-		if (local_imr[i].addr.addr_low & IMR_LOCK_BIT)
-			local_imr[i].locked = true;
-
-		if (local_imr[i].addr.read_mask > 0 &&
-			local_imr[i].addr.read_mask < IMR_READ_ENABLE_ALL){
-			local_imr[i].occupied = true;
-		} else {
-			local_imr[i].occupied = false;
-			memcpy(local_imr[i].info, "NOT USED", MAX_INFO_SIZE);
-		}
-	}
-}
-
-/**
- * prepare_input_addr
- *
- * @param addr: input physical memory address
- * @return formated memory address
- *
- * 1. verify input memory address alignment
- * 2. apply IMR_REG_MASK to match the format required by HW
- */
-static inline uint32_t prepare_input_addr(uint32_t addr)
-{
-	if (addr & (IMR_MEM_ALIGN - 1))
-		return 0;
-
-	addr = (addr >> 8) & IMR_REG_MASK;
-	return addr;
-}
-
-/**
- * intel_cln_imr_find_free_entry
- *
- * @return the next free imr slot
- */
-int intel_cln_imr_find_free_entry(void)
-{
-	int i = 0;
-
-	intel_cln_imr_update_local_data();
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		if ((!local_imr[i].occupied) && (!local_imr[i].locked))
-			return i;
-	}
-
-	pr_err("%s: No more free IMR available.\n", __func__);
-	return -ENOMEM;
-}
-
-
-/**
- * intel_cln_remove_imr_entry
- *
- * @param id: imr slot id
- * @return nothing
- *
- * remove imr slot base on input id
- */
-void intel_cln_remove_imr_entry(int id)
-{
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_rm, IMR_READ_ENABLE_ALL,
-				0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_wm, IMR_WRITE_ENABLE_ALL,
-				0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xl, IMR_BASE_ADDR, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xh, IMR_BASE_ADDR, 0);
-}
-
-/**
- * intel_cln_imr_add_entry
- *
- * @param id: imr slot id
- * @param hi: hi memory address
- * @param lo: lo memory address
- * @param read: read access mask
- * @param write: write access mask
- * @return nothing
- *
- * Setup an IMR entry
- */
-static void intel_cln_imr_add_entry(int id, uint32_t hi,
-		uint32_t lo, uint32_t read, uint32_t write, bool lock)
-{
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xl, lo, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xh, hi, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_rm, read, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_wm, write, 0);
-	if (lock) {
-		lo |= IMR_LOCK_BIT;
-		intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-					imr_reg_value[id].imr_xl, lo, 0);
-	}
-}
-
-/**
- * intel_cln_imr_alloc
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- * @param read: IMR read mask value
- * @param write: IMR write mask value
- * @return nothing
- *
- * setup the next available IMR with customized read and write masks
- */
-int intel_cln_imr_alloc(uint32_t high, uint32_t low, uint32_t read,
-			uint32_t write, unsigned char *info, bool lock)
-{
-	int id = 0;
-
-	if (info == NULL)
-		return -EINVAL;
-
-	if ((low & IMR_LOCK_BIT) || (read == 0 || write == 0)) {
-		pr_err("%s: Invalid acces mode\n", __func__);
-		return -EINVAL;
-	}
-
-	/* Calculate aligned addresses and validate range */
-	high = prepare_input_addr(high);
-	low = prepare_input_addr(low);
-
-	/* Find a free entry */
-	id = intel_cln_imr_find_free_entry();
-	if (id < 0)
-		return -ENOMEM;
-
-	/* Add entry - locking as necessary */
-	intel_cln_imr_add_entry(id, high, low, (read & IMR_READ_ENABLE_ALL),
-				write, lock);
-
-	/* Name the new entry */
-	memcpy(local_imr[id].info, info, MAX_INFO_SIZE);
-
-	/* Update local data structures */
-	intel_cln_imr_update_local_data();
-
-	DBG("%s: allocate IMR %d %s\n", __func__, id,
-		lock ? "locked" : "unlocked");
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_alloc);
-
-/**
- * get_phy_addr
- * @return phy address value
- *
- * convert register format to physical address format.
- */
-static uint32_t get_phy_addr(uint32_t reg_value)
-{
-	reg_value = ((reg_value & IMR_REG_MASK) << 8);
-	return reg_value;
-}
-
-/**
- * intel_cln_imr_proc_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates IMR state via /proc/driver/imr
- */
-static int intel_cln_imr_proc_read(char *page, char **start, off_t off,
-		int count, int *eof, void *data)
-{
-	int len = 0;
-	int i = 0;
-	int size;
-	uint32_t hi_phy_addr, lo_phy_addr;
-
-	/* get the latest imr settings */
-	intel_cln_imr_update_local_data();
-
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		/* read back the actual  input physical memory address */
-		hi_phy_addr = get_phy_addr(local_imr[i].addr.addr_high);
-		lo_phy_addr = get_phy_addr(local_imr[i].addr.addr_low);
-
-		/* the IMR always protect extra 1k memory size above the input
-		 * high reg value
-		 */
-		size = ((hi_phy_addr - lo_phy_addr) / IMR_MEM_ALIGN) + 1;
-
-		len += snprintf(page+len, count,
-				"imr - id : %d\n"
-				"info     : %s\n"
-				"occupied : %s\n"
-				"locked   : %s\n"
-				"size     : %d kb\n"
-				"hi addr (phy): 0x%08x\n"
-				"lo addr (phy): 0x%08x\n"
-				"hi addr (vir): 0x%08x\n"
-				"lo addr (vir): 0x%08x\n"
-				"read mask  : 0x%08x\n"
-				"write mask : 0x%08x\n\n",
-				i,
-				local_imr[i].info,
-				local_imr[i].occupied ? "yes" : "no",
-				local_imr[i].locked ? "yes" : "no",
-				size,
-				hi_phy_addr,
-				lo_phy_addr,
-				(uint32_t)phys_to_virt(hi_phy_addr),
-				(uint32_t)phys_to_virt(lo_phy_addr),
-				local_imr[i].addr.read_mask,
-				local_imr[i].addr.write_mask);
-	}
-	*eof = 1;
-	return len;
-}
-
-/**
- * intel_cln_imr_proc_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Function allows user-space to operate IMRs through proc interface
- * e.g. "echo imr off 7 > /proc/drivers/imr/stats" to switch IMR 7 off
- * if its unlocked.
- */
-static int intel_cln_imr_proc_write(struct file *file, const char __user *buf,
-		unsigned long count, void *data)
-{
-	ssize_t ret = 0;
-	int id = 0;
-	char *cbuf = NULL;
-	char *sbuf = NULL;
-	char *cmd_id = NULL;
-	char *cmd = NULL;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	/* Get input */
-	sbuf = cbuf = kzalloc(count+1, GFP_KERNEL);
-	if (cbuf == NULL)
-		return -ENOMEM;
-
-	ret = -EFAULT;
-	if (copy_from_user(cbuf, (char *)buf, count))
-		goto done;
-
-	DBG("%s: input read: %s !\n", __func__, cbuf);
-	/* Parse for format "entity on" "entity off" */
-	while (sbuf < (cbuf + count)) {
-		if (*sbuf == ' ') {
-			*sbuf = 0;
-			sbuf++;
-
-			if (cmd_id && cmd)
-				break;
-			if (cmd == NULL)
-				cmd = sbuf;
-			else
-				cmd_id = sbuf;
-		}
-		sbuf++;
-	}
-
-	ret = -EINVAL;
-	if (cmd == NULL || cmd_id == NULL)
-		goto done;
-
-	if (strstr(cmd, "off"))
-		DBG("try to remove IMR: %s.\n", cmd_id);
-	else
-		goto done;
-
-	id = (int)(cmd_id[0]-'0');
-	if (id < 0 || id > IMR_MAX_ID)
-		goto done;
-
-	/* get latest imr hardware settings */
-	intel_cln_imr_update_local_data();
-
-	if (local_imr[id].locked) {
-		pr_err("%s: IMR locked !\n", __func__);
-		goto done;
-	}
-
-	intel_cln_remove_imr_entry(id);
-	intel_cln_imr_update_local_data();
-
-	ret = 0;
-done:
-	if (ret == 0)
-		ret = (ssize_t)count;
-
-	kfree(cbuf);
-	return ret;
-}
-
-
-/**
- * intel_cln_imr_free
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- * @return nothing
- *
- * remove the imr based on input memory region
- */
-int intel_cln_imr_free(uint32_t high, uint32_t low)
-{
-	int i = 0;
-
-	if (low > high) {
-		pr_err("%s: Invalid input address values.\n", __func__);
-		return -EINVAL;
-	}
-
-	high = prepare_input_addr(high);
-	if (!high) {
-		pr_err("%s: Invalid input memory address.\n", __func__);
-		return -EINVAL;
-	}
-
-	low = prepare_input_addr(low);
-	if (!low) {
-		pr_err("%s: Invalid input memory address.\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		if (local_imr[i].occupied
-			&& (local_imr[i].addr.addr_low == low)
-			&& (local_imr[i].addr.addr_high == high)
-			&& (!local_imr[i].locked)) {
-				intel_cln_remove_imr_entry(i);
-				intel_cln_imr_update_local_data();
-				return 0;
-			}
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL(intel_cln_imr_free);
-
-/**
- * intel_cln_imr_proc_remove
- *
- * @return nothing
- * Removes /proc entires
- */
-static void intel_cln_imr_proc_remove(void)
-{
-	remove_proc_entry(IMR_PROC_FILE, pdir);
-	remove_proc_entry(IMR_PROC_DIR, NULL);
-}
-
-/**
- * intel_cln_imr_proc_add
- *
- * @return nothing
- * add /proc/stat entry
- */
-static int intel_cln_imr_proc_add(void)
-{
-	pdir = proc_mkdir(IMR_PROC_DIR, NULL);
-	if (pdir == NULL) {
-		pr_err("%s: PROC dir create failed.\n", __func__);
-		return -ENOMEM;
-	}
-
-	pstat = create_proc_entry(IMR_PROC_FILE, 0, pdir);
-	if (pstat == NULL) {
-		pr_err("%s: PROC imr file create failed.\n", __func__);
-		return -EIO;
-	}
-	pstat->read_proc = intel_cln_imr_proc_read;
-	pstat->write_proc = intel_cln_imr_proc_write;
-	pstat->data = NULL;
-
-	return 0;
-}
-
-/**
- * intel_cln_imr_load_local_data
- *
- * @param mask: module parameter
- * @return nothing
- *
- * prepare local IMR data structure from input module parameter.
- */
-static void intel_cln_imr_load_local_data(int mask)
-{
-	int i = 0;
-
-	BUG_ON((mask > 255 || mask < 0));
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		local_imr[i].addr.addr_low =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
-
-		/* mask bit 1 means imr occupied*/
-		if (((mask>>i) & IMR_READ_MASK) == 0) {
-			if (!(local_imr[i].addr.addr_low & IMR_LOCK_BIT))
-				intel_cln_remove_imr_entry(i);
-		}
-	}
-
-	intel_cln_imr_update_local_data();
-}
-
-/**
- * intel_cln_imr_init_data
- *
- * @return nothing
- * initialize local_imr data structure
- */
-static void intel_cln_imr_init_data(void)
-{
-	int i = 0;
-
-	intel_cln_imr_update_local_data();
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		local_imr[i].reg = imr_reg_value[i];
-		memcpy(local_imr[i].info, "System Reserved Region",
-			MAX_INFO_SIZE);
-	}
-}
-
-/**
- * intel_cln_imr_lockall
- *
- * @param mask: module parameter
- * @return nothing
- *
- * lock up all un-locked IMRs
- */
-int intel_cln_imr_lockall(void)
-{
-	int i = 0;
-	uint32_t temp_addr;
-
-	/* Enumerate IMR data structures */
-	intel_cln_imr_init_data();
-	intel_cln_imr_load_local_data(imr_bit_mask);
-
-	/* Nothing else to do */
-	if (imr_lock == 0)
-		return -EINVAL;
-
-	/* Cycle through IMRs locking whichever are unlocked */
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		temp_addr = local_imr[i].addr.addr_low;
-		if (!(temp_addr & IMR_LOCK_BIT)) {
-
-			DBG("%s: locking IMR %d\n", __func__, i);
-			temp_addr |= IMR_LOCK_BIT;
-			intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-						local_imr[i].reg.imr_xl,
-						temp_addr, 0);
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_lockall);
-
-/**
- * intel_cln_imr_init
- *
- * @return 0 success < 0 failue
- *
- * module entry point
- */
-static int  __init intel_cln_imr_probe(struct platform_device * pdev)
-{
-	int ret;
-
-	/* initialise local imr data structure */
-	intel_cln_imr_init_data();
-
-	ret = intel_cln_imr_proc_add();
-	BUG_ON(ret != 0);
-
-	if(intel_cln_imr_runt_setparams() == 0){
-                intel_cln_imr_lockall();
-        }
-
-	pr_info("IMR setup complete\n");
-
-	return 0;
-}
-
-/**
- * intel_cln_imr_exit
- *
- * @return nothing
- * Module exit
- */
-static int intel_cln_imr_remove(struct platform_device * pdev)
-{
-	/* this will disable all the unlocked IMRs */
-	intel_cln_imr_proc_remove();
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_imr_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.probe = intel_cln_imr_probe,
-	.remove = intel_cln_imr_remove,
-};
-
-module_platform_driver(intel_cln_imr_driver);
-
-MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/arch/x86/platform/cln/intel_cln_imr.h b/arch/x86/platform/cln/intel_cln_imr.h
deleted file mode 100644
index 8ee2d70..0000000
--- a/arch/x86/platform/cln/intel_cln_imr.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * A total number of 8 IMRs have implemented by Clanton SoC,
- * some IMRs might be already occupied by BIOS or Linux booting time.
- *
- * Input addresses parameter required the actual Physical address.
- *
- * The IMR alloc API will locate the next available IMR slot set up
- * with input memory region, and apply with the default access right
- * (CPU & CPU_snoop enable).
- *
- * The alloc_mask API takes input read & write masks values to set up
- * IMR with customized access right.
- *
- * User can free IMR with pre-alloc specified addresses.
- */
-
-#ifndef __INTEL_CLN_IMR_H__
-#define __INTEL_CLN_IMR_H__
-
-#include <linux/intel_cln_sb.h>
-#include "asm/io.h"
-
-#define CFG_READ_OPCODE         0x10    /* BUnit Control Read */
-#define CFG_WRITE_OPCODE        0x11    /* BUnit control write */
-
-/* DRAM IMR register addresses */
-#define IMR0L			0x40
-#define IMR0H			0x41
-#define IMR0RM			0x42
-#define IMR0WM			0x43
-#define IMR1L			0x44
-#define IMR1H			0x45
-#define IMR1RM			0x46
-#define IMR1WM			0x47
-#define IMR2L			0x48
-#define IMR2H			0x49
-#define IMR2RM			0x4A
-#define IMR2WM			0x4B
-#define IMR3L			0x4C
-#define IMR3H			0x4D
-#define IMR3RM			0x4E
-#define IMR3WM			0x4F
-#define IMR4L			0x50
-#define IMR4H			0x51
-#define IMR4RM			0x52
-#define IMR4WM			0x53
-#define IMR5L			0x54
-#define IMR5H			0x55
-#define IMR5RM			0x56
-#define IMR5WM			0x57
-#define IMR6L			0x58
-#define IMR6H			0x59
-#define IMR6RM			0x5A
-#define IMR6WM			0x5B
-#define IMR7L			0x5C
-#define IMR7H			0x5D
-#define IMR7RM			0x5E
-#define IMR7WM			0x5F
-
-#define IMR_LOCK_BIT            0x80000000
-#define IMR_WRITE_ENABLE_ALL    0xFFFFFFFF
-#define IMR_READ_ENABLE_ALL     0xBFFFFFFF
-#define IMR_REG_MASK            0xFFFFFC
-
-#define IMR_ESRAM_FLUSH_INIT	0x80000000  /* esram flush */
-#define IMR_SNOOP_ENABLE	0x40000000  /* core snoops */
-#define IMR_PUNIT_ENABLE	0x20000000
-#define IMR_SMM_ENABLE		0x02        /* core SMM access */
-#define IMR_NON_SMM_ENABLE	0x01        /* core non-SMM access */
-#define IMR_BASE_ADDR           0x00
-#define IMR_MEM_ALIGN           0x400
-
-#define MAX_INFO_SIZE           64
-#define IMR_MAXID		8
-
-/* snoop + Non SMM write mask */
-#define IMR_DEFAULT_MASK	(IMR_SNOOP_ENABLE \
-				+ IMR_ESRAM_FLUSH_INIT \
-				+ IMR_NON_SMM_ENABLE)
-
-/* debug printk */
-#ifdef DEBUG
-#define DBG(args...) pr_info(args)
-#else
-#define DBG(args...)
-#endif
-
-extern unsigned long  _text;
-extern unsigned long  __init_begin;
-
-/**
- * intel_cln_imr_alloc
- *
- * @param high: the end of physical memory address
- * @param low: the start of physical memory address
- * @param read: IMR read mask value
- * @param write: IMR write maks value
- * @param info: imr information
- * @param lock: imr lock
- *
- * Setup imr with customised read/ write masks
- */
-int intel_cln_imr_alloc(u32 high, u32 low, u32 read, u32 write,
-			unsigned char *info, bool lock);
-
-/**
- * intel_cln_imr_free
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- *
- * remove the imr based on input memory region
- */
-int intel_cln_imr_free(u32 high, u32 low);
-
-/**
- * intel_cln_remove_imr_entry
- *
- * @param id: internal imr data struct id
- *
- * Remove imr based on input imr data structure id
- */
-void intel_cln_remove_imr_entry(int id);
-
-#endif
diff --git a/arch/x86/platform/cln/intel_cln_imr_kernel.c b/arch/x86/platform/cln/intel_cln_imr_kernel.c
deleted file mode 100644
index e53307e..0000000
--- a/arch/x86/platform/cln/intel_cln_imr_kernel.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * The IMR id 3 is pre-defined as the use for kernel data protection
- *
- * The early imr protects entire memory (from the beginning of kernel text
- * section to the top of memory) during linux boot time. In the linux run
- * time, the protection need to resize down to memory region that only
- * contains: kernel text, read only data, and initialized data section.
- *
- */
-#include <linux/errno.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/clanton.h>
-#include <linux/printk.h>
-#include "intel_cln_imr.h"
-
-/* pre-defined imr id for uncompressed kernel */
-#define IMR_KERNEL_ID	3
-
-/**
- * addr_hw_ready
- *
- * shift input address value to match HW required 1k aligned format
- */
-static inline uint32_t addr_hw_ready(uint32_t addr)
-{
-	/* memory alignment */
-	addr &= (~((1 << 10) - 1));
-
-	/* prepare input addr in HW required format */
-	addr = (addr >> 8) & IMR_REG_MASK;
-	return addr;
-}
-
-/**
- * void intel_cln_imr_runt_kerndata_setup
- *
- * Setup imr for kernel text, read only data section
- *
- * The read only data (rodata) section placed between text and initialized data
- * section by kernel.
- */
-static void intel_cln_imr_runt_kerndata_setup(void)
-{
-	uint32_t hi;
-	uint32_t lo;
-
-	hi = (uint32_t)virt_to_phys(&__init_begin);
-	lo = (uint32_t)virt_to_phys(&_text);
-
-	if (intel_cln_imr_alloc((hi - IMR_MEM_ALIGN), lo,
-				IMR_DEFAULT_MASK, IMR_DEFAULT_MASK,
-				"KERNEL RUNTIME DATA", 0)) {
-		pr_err("IMR: Set up runtime kernel data imr faild!\n");
-		return;
-	}
-}
-
-/**
- * intel_cln_imr_runt_oldkern_teardown
- *
- * remove the previous imr protection for uncompressed kernel data
- *
- */
-static void intel_cln_imr_runt_oldkern_teardown(void)
-{
-	intel_cln_remove_imr_entry(IMR_KERNEL_ID);
-}
-
-/**
- * intel_cln_imr_runt_setparams
- *
- * set imr range for text, read only, initialised data in linux run time
- */
-int intel_cln_imr_runt_setparams(void)
-{
-	if (intel_cln_plat_get_id() == CLANTON_PLAT_UNDEFINED)
-		return -ENODEV;
-
-	intel_cln_imr_runt_kerndata_setup();
-
-	/* Remove initial IMR */
-	intel_cln_imr_runt_oldkern_teardown();
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_runt_setparams);
-
-/**
- * intel_cln_imr_runt_init
- *
- * module entry point
- */
-static int  __init intel_cln_imr_runt_init(void)
-{
-	return 0;
-}
-
-/**
- * intel_cln_imr_runt_exit
- *
- * Module exit
- */
-static void __exit intel_cln_imr_runt_exit(void)
-{
-	/* do nothing */
-}
-
-MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
-
-subsys_initcall(intel_cln_imr_runt_init);
-module_exit(intel_cln_imr_runt_exit);
diff --git a/arch/x86/platform/cln/intel_cln_imr_test.c b/arch/x86/platform/cln/intel_cln_imr_test.c
deleted file mode 100644
index 2d98507..0000000
--- a/arch/x86/platform/cln/intel_cln_imr_test.c
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR Test module
- *
- */
-
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-#include "intel_cln_imr.h"
-
-#define DRIVER_NAME			"intel_cln_imr_test"
-
-/**
- * XXX intel_cln_sb.h needs to be updated with SB_ID_PUNIT and change
- * propagated. This is a workaround to make it look less ugly. */
-#define SB_ID_PUNIT			SB_ID_THERMAL
-
-/* Memory-mapped SPI Flash address */
-#define ILB_SPIFLASH_BASEADDR			0xFF800000
-/* PUnit DMA block transfer size, in bytes */
-#define SPI_DMA_BLOCK_SIZE			512
-
-/**************************** Exported to LISA *******************************/
-
-/*
- * Internally-used ioctl code. At the moment it is not reserved by any mainline
- * driver.
- */
-#define IMR_TEST_IOCTL_CODE			0xE1
-
-/*
- * Integers for ioctl operation.
- */
-#define IOCTL_CLN_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
-#define IOCTL_CLN_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
-
-/*****************************************************************************/
-
-/**
- * struct intel_cln_imr_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_imr_test_dev {
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-};
-
-static struct intel_cln_imr_test_dev imr_test_dev;
-static struct class *imr_test_class;
-static DEFINE_MUTEX(imr_test_mutex);
-static int imr_test_major;
-
-/* PUnit DMA registers over side-band */
-#define PUNIT_SPI_DMA_COUNT_REG		0x60
-#define PUNIT_SPI_DMA_DEST_REG		0x61
-#define PUNIT_SPI_DMA_SRC_REG		0x62
-
-/**
- * ilb_spi_dma_read 
- *
- * @param src: physical address in Legacy SPI Flash
- * @param dst: physical address of destination
- * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
- *
- * Read-access iLB SPI via PUnit DMA engine.
- * 
- */
-static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
-{
-	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
-		dma_block_count);
-
-	/* Setup source and destination addresses. */
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_SRC_REG, (u32) src, 0);
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_DEST_REG, (u32) dst, 0);
-
-	pr_info("%s: starting transaction\n", __func__);
-
-	/*
-	 * Setup the number of block to be copied over. Transaction will start
-	 * as soon as the register is filled with value.
-	 */
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_COUNT_REG, dma_block_count, 0);
-
-	/* Poll for completion. */
-	while (dma_block_count > 0) {
-		intel_cln_sb_read_reg(SB_ID_PUNIT, CFG_READ_OPCODE,
-			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count, 0); 
-	}
-
-	pr_info("%s: transaction completed\n", __func__);
-}
-
-/**
- * punit_dma_sanity_check 
- *
- * @return 0 if success, 1 if failure
- *
- * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
- * Flash block. 
- */
-static int punit_dma_sanity_check(void)
-{
-	int err = 0;
-	u32 *buffer = NULL;
-	u32 buf_ph_addr = 0;
-
-	/* Allocate 512B buffer for 1 SPI Flash block */
-	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
-        if (!buffer) {
-		err = -ENOMEM;
-		goto end;
-	}
-
-	/* DMA first SPI Flash block into buffer */
-	buf_ph_addr = (u32)virt_to_phys(buffer);
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
-
-	kfree(buffer);
-end:
-	return err;
-}
-
-/**
- * imr_violate_kernel_punit_dma 
- *
- * @return always 0
- *
- * PUnit-DMA access to the Uncompressed Kernel IMR.
- * This is based on set_imr_kernel_data() in intel_cln_imr.c. Find the physical
- * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
- * 
- */
-static int imr_violate_kernel_punit_dma(void)
-{
-	extern unsigned long _text;
-	u32 kernel_text = (u32)virt_to_phys(&_text);
-
-	/* We expect this to trigger an IMR violation reset */
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
-
-	/*
-	 * If we're still alive, we have a serious bug:
-	 * - we didn't appropriately target the IMR?
-	 * - if we have, weren't we prevented from accessing?
-	 * - if we weren't prevented, it's unlikely we're alive with a dirty
-	 *   text section
-	 */
-	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
-		__func__);
-
-	return 0;
-}
-
-/*
- * File ops
- */
-static long imr_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	switch (cmd) {
-		case IOCTL_CLN_SANITY_CHECK_PUNIT_DMA:
-			/* Check PUnit DMA actually works */
-			ret = punit_dma_sanity_check();
-			break;
-		case IOCTL_CLN_IMR_1:
-			/* Kernel IMR violation: PUnit DMA access */
-			ret = imr_violate_kernel_punit_dma();
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int imr_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
-		mutex_unlock(&imr_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (imr_test_dev.opened) {
-		mutex_unlock(&imr_test_dev.open_lock);
-		mutex_unlock(&imr_test_mutex);
-		return -EINVAL;
-	}
-
-	imr_test_dev.opened++;
-	mutex_unlock(&imr_test_dev.open_lock);
-	mutex_unlock(&imr_test_mutex);
-	return 0;
-}
-
-static int imr_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_dev.open_lock);
-	imr_test_dev.opened = 0;
-	mutex_unlock(&imr_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations imr_test_file_ops = {
-	.open = imr_test_open,
-	.release = imr_test_release,
-	.unlocked_ioctl = imr_test_ioctl,
-	.llseek = no_llseek,
-};
-
-/**
- * intel_cln_imr_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- */
-static int intel_cln_imr_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&imr_test_dev.open_lock);
-	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
-	imr_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(imr_test_class, NULL,
-				 MKDEV(imr_test_major, minor), NULL,
-				 "imrtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-
-	return 0;
-
-}
-
-static int intel_cln_imr_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
-
-	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
-	cdev_del(&imr_test_dev.cdev);
-
-	class_destroy(imr_test_class);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_imr_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_imr_test_remove,
-};
-
-/**
- * intel_cln_imr_test_init
- *
- * Load module.
- */
-static int __init intel_cln_imr_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	imr_test_class = class_create(THIS_MODULE,"cln_imr_test");
-	if (IS_ERR(imr_test_class)) {
-		retval = PTR_ERR(imr_test_class);
-		printk(KERN_ERR "imr_test: can't register imr_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	imr_test_major = MAJOR(dev);
-
-	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
-	imr_test_dev.pldev = platform_create_bundle(
-		&intel_cln_imr_test_driver, intel_cln_imr_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(imr_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(imr_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(imr_test_class);
-err:
-	return retval;
-}
-
-static void __exit intel_cln_imr_test_exit(void)
-{
-	platform_device_unregister(imr_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_imr_test_driver);
-}
-
-module_init(intel_cln_imr_test_init);
-module_exit(intel_cln_imr_test_exit);
-
-MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
-MODULE_DESCRIPTION("Clanton IMR test module");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/arch/x86/platform/cln/intel_cln_layout_data.c b/arch/x86/platform/cln/intel_cln_layout_data.c
deleted file mode 100644
index 124bccf..0000000
--- a/arch/x86/platform/cln/intel_cln_layout_data.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-
-#define DRIVER_NAME "cln-layout-conf"
-static char __iomem * layout_conf_data;
-static int len;
-
-static ssize_t layout_conf_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	ssize_t plen = len+1;
-	if( plen > PAGE_SIZE )
-		plen = PAGE_SIZE;
-	memcpy(buf, layout_conf_data, plen);
-	return plen;
-}
-
-static struct kobj_attribute layout_conf_attr = 
-	__ATTR(layout_conf, 0644, layout_conf_show, NULL);
-
-static int intel_cln_layout_data_probe(struct platform_device *pdev)
-{
-	extern struct kobject * board_data_kobj;
-	int ret = 0;
-
-	layout_conf_data = ioremap(pdev->resource->start,
-		resource_size(pdev->resource));
-	if (!layout_conf_data)
-		return -ENODEV;
-
-	len = resource_size(pdev->resource);
-	ret = sysfs_create_file(board_data_kobj, &layout_conf_attr.attr);
-	if (ret != 0){
-		pr_err("failed to create sysfs entry for layout config\n");
-		iounmap(layout_conf_data);
-		layout_conf_data = NULL;
-	}
-
-	return ret;
-}
-
-static int intel_cln_layout_data_remove(struct platform_device *pdev)
-{
-	extern struct kobject * board_data_kobj;
-
-	if (layout_conf_data){
-		sysfs_remove_file(board_data_kobj, &layout_conf_attr.attr);
-		iounmap(layout_conf_data);
-		
-	}
-	return 0;
-}
-
-static struct platform_driver cln_layout_data_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_layout_data_probe,
-	.remove		= intel_cln_layout_data_remove,
-};
-
-module_platform_driver(cln_layout_data_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SPI Data API");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c b/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
deleted file mode 100644
index 14a2fda..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME "cln-plat-clanton-hill"
-#define GPIO_RESTRICT_NAME "cln-gpio-restrict-nc"
-
-#define CLN_SPI_MAX_CLK_DEFAULT               5000000
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-
-/******************************************************************************
- *             ST Microelectronics LIS331DLH I2C Device Platform Data
- ******************************************************************************/
-#include <linux/platform_data/st_accel_i2c.h>
-
-/* GPIO interrupt pins connected to the LIS331DLH */
-#define ST_ACCEL_INT1_GPIO 15
-#define ST_ACCEL_INT2_GPIO 4
-
-static struct st_accel_i2c_platform_data st_accel_i2c_platform_data;
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Clanton Hill platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	struct spi_board_info spi_onboard_devs[] = {
-		{
-			.modalias = "ad7298",
-			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
-			.platform_data = &ad7298_platform_data,
-			.mode = SPI_MODE_2,
-			.bus_num = 0,
-			.chip_select = 0,
-			.controller_data = &cln_ffrd_spi_0_cs_0,
-		},
-	};
-
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-/**
- * intel_cln_i2c_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard I2C device(s) present on the Clanton Hill platform
- */
-static int intel_cln_i2c_add_onboard_devs(void)
-{
-	struct i2c_board_info i2c_onboard_devs[] = {
-		{
-			I2C_BOARD_INFO("intel-cln-max9867", 0x18),
-		},
-		{
-			I2C_BOARD_INFO("lis331dlh", 0x19),
-			.irq = gpio_to_irq(ST_ACCEL_INT1_GPIO),
-			.platform_data  = &st_accel_i2c_platform_data,
-		},
-	};
-	st_accel_i2c_platform_data.irq2 = gpio_to_irq(ST_ACCEL_INT2_GPIO);
-
-	return i2c_register_board_info(0, i2c_onboard_devs,
-			ARRAY_SIZE(i2c_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	struct gpio reserved_gpios[] = {
-		{
-			ST_ACCEL_INT1_GPIO,
-			GPIOF_IN,
-			"st_accel_i2c-int1"
-		},
-		{
-			ST_ACCEL_INT2_GPIO,
-			GPIOF_IN,
-			"st_accel_i2c-int2"
-		},
-	};
-
-	ret = intel_cln_spi_add_onboard_devs();
-	if (ret)
-		return ret;
-
-	ret = intel_cln_i2c_add_onboard_devs();
-	if (ret)
-		return ret;
-
-
-	ret = gpio_request_array(reserved_gpios,
-				 ARRAY_SIZE(reserved_gpios));
-
-	return ret;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_clanton_hill_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver);
-
-	return ret;
-}
-
-static int intel_cln_plat_clanton_hill_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_clanton_hill_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_clanton_hill_probe,
-	.remove		= intel_cln_plat_clanton_hill_remove,
-};
-
-module_platform_driver(cln_clanton_hill_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Cross Hill BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c b/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
deleted file mode 100644
index 104879e..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME "cln-plat-clanton-peak"
-#define GPIO_RESTRICT_NAME "cln-gpio-restrict-nc"
-
-static struct spi_board_info spi_onboard_devs[] = {
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.max_speed_hz = 50000000,
-		.bus_num = 0,
-	},
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-	},
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Clanton Peak platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	/* TODO */
-
-	return 0;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_clanton_peak_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = intel_cln_spi_add_onboard_devs();
-	if (ret)
-		return ret;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver);
-
-	return ret;
-}
-
-static int intel_cln_plat_clanton_peak_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver clanton_peak_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_clanton_peak_probe,
-	.remove		= intel_cln_plat_clanton_peak_remove,
-};
-
-module_platform_driver(clanton_peak_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Clanton Peak BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_cross_hill.c b/arch/x86/platform/cln/intel_cln_plat_cross_hill.c
deleted file mode 100644
index 2b7164a..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_cross_hill.c
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME "cln-plat-cross-hill"
-#define GPIO_RESTRICT_NAME_NC "cln-gpio-restrict-nc"
-#define GPIO_RESTRICT_NAME_SC "cln-gpio-restrict-sc"
-
-#define CLN_SPI_MAX_CLK_DEFAULT		5000000
-
-/*
- * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
- */
-#define SPI_BPEAK_RESET_GPIO 4
-#define SPI_BPEAK_ID0_GPIO   3
-#define SPI_BPEAK_ID1_GPIO   2
-#define SPI_BPEAK_ID2_GPIO   15
-#define SPI_BPEAK_ID3_GPIO   14
-
-static int nc_gpio_reg;
-static int sc_gpio_reg;
-
-/*
- * Blackburn Peak SPI daughterboard ID values
- */
-enum {
-	CLN_SPI_BPEAK_ID_ZB_TI = 0xA,
-	CLN_SPI_BPEAK_ID_ZB_DIGI,
-	CLN_SPI_BPEAK_ID_ZB_INFR_NXP,
-	CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
-	CLN_SPI_BPEAK_ID_ADC_MAXIM,
-	CLN_SPI_BPEAK_ID_NONE
-};
-
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_1 = {
-	.gpio_cs = 11,
-};
-
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Cross Hill platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	struct spi_board_info spi_onboard_devs[] = {
-		{
-			.modalias = "ad7298",
-			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
-			.platform_data = &ad7298_platform_data,
-			.mode = SPI_MODE_2,
-			.bus_num = 0,
-			.chip_select = 0,
-			.controller_data = &cln_ffrd_spi_0_cs_0,
-		},
-	};
-
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-
-/**
- * intel_cln_spi_get_bpeak_id
- *
- * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
- * @return 0 on success or standard errnos on failure
- *
- * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
- */
-static int intel_cln_spi_get_bpeak_id(u8 *bpeak_id)
-{
-	int ret = 0;
-	struct gpio spi_bpeak_id_gpios[] = {
-		{
-			SPI_BPEAK_RESET_GPIO,
-			GPIOF_OUT_INIT_HIGH,
-			"spi_bpeak_reset"
-		},
-		{
-			SPI_BPEAK_ID0_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id0"
-		},
-		{
-			SPI_BPEAK_ID1_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id1"
-		},
-		{
-			SPI_BPEAK_ID2_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id2"
-		},
-		{
-			SPI_BPEAK_ID3_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id3"
-		}
-	};
-
-	/*
-	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
-	 * while a RESET GPIO output is asserted (active-low)
-	 */
-	ret = gpio_request_array(spi_bpeak_id_gpios,
-			ARRAY_SIZE(spi_bpeak_id_gpios));
-	if (ret) {
-		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
-				__func__);
-		return ret;
-	}
-
-	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
-	*bpeak_id =
-		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
-	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
-
-	gpio_free_array(spi_bpeak_id_gpios,
-			ARRAY_SIZE(spi_bpeak_id_gpios));
-
-	return 0;
-}
-
-/**
- * intel_cln_spi_add_bpeak_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers SPI device(s) indicated by the ID value obtained from a
- * Blackburn Peak SPI daughterboard
- */
-static int intel_cln_spi_add_bpeak_devs(void)
-{
-	u8 spi_bpeak_id = 0;
-	int ret = 0;
-
-	ret = intel_cln_spi_get_bpeak_id(&spi_bpeak_id);
-	if (ret) {
-		pr_err("%s: failed to obtain Blackburn Peak ID\n",
-				__func__);
-		return ret;
-	}
-
-	switch (spi_bpeak_id) {
-
-	case CLN_SPI_BPEAK_ID_NONE:
-		break;
-	case CLN_SPI_BPEAK_ID_ADC_MAXIM:
-		{
-			struct spi_board_info spi_bpeak_devs[] = {
-				{
-				.modalias = "max78m6610_lmu",
-				.max_speed_hz = 2000000,
-				.platform_data = NULL,
-				.mode = SPI_MODE_3,
-				.bus_num = 1,
-				.chip_select = 0,
-				.controller_data = &cln_ffrd_spi_1_cs_0,
-				},
-			};
-
-			return spi_register_board_info(spi_bpeak_devs,
-						ARRAY_SIZE(spi_bpeak_devs));
-		}
-	case CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
-		{
-			struct spi_board_info spi_bpeak_devs[] = {
-				{
-				.modalias = "spidev",
-				.max_speed_hz = 1000000,
-				.platform_data = NULL,
-				.mode = SPI_MODE_0,
-				.bus_num = 1,
-				.chip_select = 0,
-				.controller_data = &cln_ffrd_spi_1_cs_0,
-				},
-
-				{
-				.modalias = "spidev",
-				.max_speed_hz = 1000000,
-				.platform_data = NULL,
-				.mode = SPI_MODE_0,
-				.bus_num = 1,
-				.chip_select = 1,
-				.controller_data = &cln_ffrd_spi_1_cs_1,
-				},
-
-			};
-
-			return spi_register_board_info(spi_bpeak_devs,
-						ARRAY_SIZE(spi_bpeak_devs));
-		}
-	/* TODO - add other Blackburn Peak variants when details available */
-	default:
-			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
-					__func__, spi_bpeak_id);
-			ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/** intel_cln_spi_devs_addon
- *
- * addon spi device when gpio support in place
- */
-static int intel_cln_spi_devs_addon(void)
-{
-	int ret = 0;
-
-	ret = intel_cln_spi_add_onboard_devs();
-	if (ret)
-		return ret;
-
-	ret = intel_cln_spi_add_bpeak_devs();
-
-	return ret;
-}
-
-/**
- * intel_cln_gpio_restrict_probe_nc
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe_nc(struct platform_device *pdev)
-{
-	int ret;
-	nc_gpio_reg = 1;
-
-	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
-		ret = intel_cln_spi_devs_addon();
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-/**
- * intel_cln_gpio_restrict_probe_sc
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe_sc(struct platform_device *pdev)
-{
-	int ret;
-	sc_gpio_reg = 1;
-
-	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
-		ret = intel_cln_spi_devs_addon();
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-static struct platform_driver gpio_restrict_pdriver_nc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_NC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_nc,
-};
-
-static struct platform_driver gpio_restrict_pdriver_sc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_SC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_sc,
-};
-
-static int intel_cln_plat_cross_hill_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
-	if (ret)
-		return ret;
-
-	return platform_driver_register(&gpio_restrict_pdriver_sc);
-}
-
-static int intel_cln_plat_cross_hill_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_cross_hill_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_cross_hill_probe,
-	.remove		= intel_cln_plat_cross_hill_remove,
-};
-
-module_platform_driver(cln_cross_hill_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Cross Hill BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_data.c b/arch/x86/platform/cln/intel_cln_plat_data.c
deleted file mode 100644
index b1d733a..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_data.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/clanton.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#define PREFIX		"CLN-PLT: "
-#define DRIVER_NAME 	"cln-plat"
-#define PLAT_MAGIC	0x54414450	/* PDAT */
-#define DESC_LEN	0x0A
-#define MAC_STRLEN	20
-#define MAC_LEN		6
-
-struct cln_plat_dat_hdr {
-	uint32_t magic;
-	uint32_t length;
-	uint32_t crc32;
-};
-
-struct cln_plat_data {
-	uint16_t plat_id;
-	uint16_t length;
-	uint8_t desc[DESC_LEN];
-	uint16_t version;
-};
-
-struct cln_bsp_reg {
-	struct platform_device pdev;
-	cln_plat_id_t id;
-};
-
-static struct cln_bsp_reg bsp_data [] = {
-	{
-		.pdev.name	= "cln-plat-clanton-peak",
-		.pdev.id	= -1,
-		.id		= CLANTON_PEAK,
-	},
-	{
-		.pdev.name	= "cln-plat-kips-bay",
-		.pdev.id	= -1,
-		.id		= KIPS_BAY,
-	},
-	{
-		.pdev.name	= "cln-plat-cross-hill",
-		.pdev.id	= -1,
-		.id		= CROSS_HILL,
-	},
-	{
-		.pdev.name	= "cln-plat-clanton-hill",
-		.pdev.id	= -1,
-		.id		= CLANTON_HILL,
-	},
-	{
-		.pdev.name	= "cln-plat-izmir",
-		.pdev.id	= -1,
-		.id		= IZMIR,
-	},
-
-};
-
-/**
- * struct cln_plat_data_list
- *
- * Structure to hold a linked list of platform data refs
- */
-struct cln_plat_data_list {
-	char name[DESC_LEN+1];
-	struct cln_plat_data * plat_data;
-	struct kobj_attribute plat_attr;
-	struct list_head list;
-};
-
-static char __iomem * plat_data;
-static char * plat_bin_name = 	"pdat_bin";
-static unsigned int plat_bin_size;
-static struct cln_plat_dat_hdr * plat_hdr;
-static struct list_head entry_list;
-
-/**
- * intel_cln_plat_sysfs_show_bin
- *
- * Generic show routine for any of the sysfs entries of this module
- */
-static ssize_t intel_cln_plat_sysfs_show_bin(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	ssize_t plen = plat_bin_size;
-	if( plen > PAGE_SIZE )
-		plen = PAGE_SIZE;
-
-	memcpy(buf, plat_data, plen);
-	return plen;
-}
-
-/**
- * intel_cln_plat_sysfs_show
- *
- * Generic show routine for any of the sysfs entries of this module
- */
-static ssize_t intel_cln_plat_sysfs_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	unsigned char * data;
-	char fmt[0x20];
-	struct cln_plat_data_list * plat_item_list;
-	ssize_t plen = 0;
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		if ( attr == &plat_item_list->plat_attr ){
-
-			/* Derive length */
-			plen = plat_item_list->plat_data->length;
-			if (unlikely(plen > PAGE_SIZE))
-				plen = PAGE_SIZE;
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Enumrate return */
-			switch (plat_item_list->plat_data->plat_id){
-			case PLAT_DATA_ID:
-			case PLAT_DATA_SN:
-				snprintf(fmt, sizeof(fmt), "0x%%0%dx\n",
-					 plen*2);
-				return sprintf(buf, fmt, *(int16_t*)data);
-			case PLAT_DATA_MAC0:
-			case PLAT_DATA_MAC1:
-				if (unlikely(plen != MAC_LEN)){
-					return sprintf(buf, "invalid mac\n");
-				}
-				return snprintf(buf, MAC_STRLEN,
-					"%02x:%02x:%02x:%02x:%02x:%02x\n",
-					data[0], data[1], data[2], data[3],
-					data[4], data[5]);
-			default:
-				/* Treat as string data */
-				return snprintf(buf, plen, "%s", data);
-			}
-		}
-	}
-	return 0;
-}
-
-/**
- * intel_cln_plat_cleanup
- *
- * Generic cleanup code for the platform data interface
- *
- */
-static void intel_cln_plat_cleanup (void)
-{
-	extern struct kobject * board_data_kobj;
-	struct cln_plat_data_list * plat_item_list;
-
-	if (plat_data != NULL){
-		iounmap(plat_data);
-		plat_data = NULL;
-	}
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		sysfs_remove_file(board_data_kobj,
-				  &plat_item_list->plat_attr.attr);
-		kfree(plat_item_list);
-	}
-}
-
-/**
- * intel_cln_plat_get_desc_len
- *
- * @param desc: Pointer to desc string
- * @return len on success < 0 failure
- *
- * Function called to get a bounds checked desc field from platfrom data
- *
- */
-static int intel_cln_plat_get_desc_len (char * desc)
-{
-	int len = 0;
-	if (desc == NULL){
-		return -EINVAL;
-	}
-
-	for(; *desc != '\0' && len < DESC_LEN; desc++, len++);
-	return len;
-}
-
-/**
- * intel_cln_plat_probe
- *
- * @param pdev: Pointer to platform device
- * @return 0 success < 0 failure
- *
- * Function called to probe platform device "cln-plat"
- *
- */
-static int intel_cln_plat_probe(struct platform_device *pdev)
-{
-	char __iomem * end_addr = NULL;
-	char __iomem * data = NULL;
-	cln_plat_id_t id = CLANTON_PLAT_UNDEFINED;
-	extern struct kobject * board_data_kobj;
-	struct cln_plat_data * plat_item = NULL;
-	struct cln_plat_data_list * plat_item_list = NULL;
-	u32 crc = 0;
-	int ret = 0, i = 0;
-
-	INIT_LIST_HEAD(&entry_list);
-	plat_hdr = ioremap(pdev->resource->start, resource_size(pdev->resource));
-	end_addr = (char*)plat_hdr + resource_size(pdev->resource);
-	plat_data = (char*)plat_hdr;
-	if (!plat_hdr)
-		return -ENODEV;
-
-	/* Verify header magic */
-	if (plat_hdr->magic != 	PLAT_MAGIC){
-		pr_err(PREFIX"Expected magic 0x%08x read 0x%08lx\n",
-			PLAT_MAGIC, (unsigned long)plat_hdr->magic);
-	}
-
-	/* Validate length is sane */
-	if ((char*)plat_hdr + sizeof(struct cln_plat_dat_hdr) +
-		plat_hdr->length > end_addr ||
-		plat_hdr->length < sizeof(struct cln_plat_data)){
-		pr_err(PREFIX"Invalid length 0x%08lx\n",
-			(unsigned long)plat_hdr->length);
-		return -ENODEV;
-	}
-
-	/* Point to real end addr */
-	end_addr = (char*)plat_hdr +
-			sizeof(struct cln_plat_dat_hdr) + plat_hdr->length;
-	plat_bin_size = end_addr - plat_data;
-
-	/* Get pointer to start of data */
-	plat_item = (struct cln_plat_data*)(plat_hdr+1);
-	data = ((char*)(plat_item)+sizeof(struct cln_plat_data));
-
-	/* Validate CRC32 */
-	crc = ~crc32(0xFFFFFFFF, plat_item, plat_hdr->length);
-	if (crc != plat_hdr->crc32){
-		pr_err(PREFIX"CRC 0x%08x header indicates 0x%08x - fatal!\n",
-			crc, plat_hdr->crc32);
-		return -EFAULT;
-	}
-
-	/* /sys/firmware/board_data/plat_bin - dump entire platform binary */
-	plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
-					 GFP_KERNEL);
-	if (unlikely(plat_item_list == NULL)) {
-		pr_err("kzalloc fail !\n");
-		intel_cln_plat_cleanup();
-		return -ENOMEM;
-	}
-	sysfs_attr_init(&plat_item_list->plat_attr.attr);
-	plat_item_list->plat_attr.attr.name = plat_bin_name;
-	plat_item_list->plat_attr.attr.mode = 0644;
-	plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show_bin;
-
-	ret = sysfs_create_file(board_data_kobj,
-				&plat_item_list->plat_attr.attr);
-	if (unlikely(ret != 0)){
-		intel_cln_plat_cleanup();
-		pr_err("failed to create sysfs entry\n");
-		return ret;
-	}
-
-	/* Iterate through each entry - add sysfs entry as appropriate */
-	while ( (char*)plat_item < end_addr){
-	
-		/* Bounds check */
-		if (data + plat_item->length > end_addr){
-			pr_err(PREFIX"Data 0x%p over-runs max-addr 0x%p\n",
-				data, end_addr);
-			break;
-		}
-
-		/* Extract data */
-		switch(plat_item->plat_id){
-		case PLAT_DATA_ID:
-			id = *((uint16_t*)data);
-			pr_info(PREFIX"Clanton Platform ID = %d\n", id);
-			break;
-		case PLAT_DATA_SN:
-		case PLAT_DATA_MAC0:
-		case PLAT_DATA_MAC1:
-			break;
-		default:
-			/* Unknown identifier */
-			break;
-		}
-
-		plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
-					 GFP_KERNEL);
-		if (unlikely(plat_item_list == NULL)) {
-			pr_err("kzalloc fail !\n");
-			intel_cln_plat_cleanup();
-			return -ENOMEM;
-		}
-
-		/* Get name of entity */
-		i = intel_cln_plat_get_desc_len(plat_item->desc);
-		if (i <= 0){
-			pr_err("desc len is %d!\n", i);
-			intel_cln_plat_cleanup();
-			return i;
-		}
-
-		memcpy(plat_item_list->name, plat_item->desc, i);
-		plat_item_list->plat_data = plat_item;
-
-		sysfs_attr_init(&plat_item_list->plat_attr.attr);
-		plat_item_list->plat_attr.attr.name = plat_item_list->name;
-		plat_item_list->plat_attr.attr.mode = 0644;
-		plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show;
-
-		ret = sysfs_create_file(board_data_kobj,
-					&plat_item_list->plat_attr.attr);
-		if (unlikely(ret != 0)){
-			intel_cln_plat_cleanup();
-			pr_err("failed to create sysfs entry\n");
-			return ret;
-		}
-
-		/* Add to list */
-		list_add(&plat_item_list->list, &entry_list);
-
-		/* Next */
-		plat_item = (struct cln_plat_data*)
-			(((char*)plat_item) + plat_item->length + sizeof(struct cln_plat_data));
-		data = ((char*)(plat_item) + sizeof(struct cln_plat_data));
-	}
-
-	/* Register BSP enabling platform code */
-	for (i = 0; i < sizeof(bsp_data)/sizeof(struct cln_bsp_reg); i++){
-		if (bsp_data[i].id == id){
-			platform_device_register(&bsp_data[i].pdev);
-		}
-	}
-
-	return ret;
-}
-
-/**
- * intel_cln_plat_remove
- *
- * @param pdev: Pointer to platform device
- * @return 0 success < 0 failure
- *
- * Function called to remove the platfrom device from kernel space
- *
- */
-static int intel_cln_plat_remove(struct platform_device *pdev)
-{
-	intel_cln_plat_cleanup();
-	return 0;
-}
-
-static struct platform_driver cln_plat_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_probe,
-	.remove		= intel_cln_plat_remove,
-};
-
-module_platform_driver(cln_plat_driver);
-
-/**
- * intel_cln_get_id
- *
- * @return platform id on success or < CLANTON_PLAT_UNDEFINED on error
- *
- * Function called to get platform id
- *
- */
-cln_plat_id_t intel_cln_plat_get_id(void)
-{
-	unsigned char * data;
-	struct cln_plat_data_list * plat_item_list;
-
-	if (plat_data == NULL)
-		return CLANTON_PLAT_UNDEFINED;
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-
-		/* Enumrate return */
-		if(plat_item_list->plat_data->plat_id == PLAT_DATA_ID){
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Return payload */
-			return *(int16_t*)data;
-		}
-	}
-	return CLANTON_PLAT_UNDEFINED;
-}
-EXPORT_SYMBOL(intel_cln_plat_get_id);
-
-/**
- * intel_cln_plat_get_mac
- *
- * @param id: Index of MAC address to find
- * @param mac: Output parameter for mac address
- *
- * @return 0 success < 0 failure
- *
- * Function called to remove the platfrom device from kernel space
- *
- */
-int intel_cln_plat_get_mac(plat_dataid_t id, char * mac)
-{
-	unsigned char * data;
-	unsigned int plen = 0;
-	struct cln_plat_data_list * plat_item_list;
-
-	if ((id != PLAT_DATA_MAC0 && id != PLAT_DATA_MAC1) || mac == NULL){
-		pr_err("invalid input id %d mac %p\n", id, mac);
-		return -EINVAL;
-	}
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		if(plat_item_list->plat_data->plat_id == id){
-
-			/* Derive length */
-			plen = plat_item_list->plat_data->length;
-			if (unlikely(plen != MAC_LEN)){
-				pr_err("%s mac len invalid!\n", __func__);
-				return -ENODEV;
-			}
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Good to go */
-			memcpy(mac, data, MAC_LEN);
-			return 0;
-		}
-	}
-	return -ENODEV;
-}
-EXPORT_SYMBOL(intel_cln_plat_get_mac);
-
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SPI Data API");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_izmir.c b/arch/x86/platform/cln/intel_cln_plat_izmir.c
deleted file mode 100644
index f205ee8..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_izmir.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c/at24.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
-#include <linux/i2c/at24.h>
-
-#define DRIVER_NAME 		"cln-plat-izmir"
-#define GPIO_RESTRICT_NAME 	"cln-gpio-restrict-sc"
-#define LPC_SCH_SPINAME		"spi-lpc-sch"
-
-#define CLN_SPI_MAX_CLK_DEFAULT		5000000
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-static struct at24_platform_data at24_platform_data = {
-	.byte_len = (11 * 1024),
-	.page_size = 1,
-	.flags = AT24_FLAG_ADDR16,
-};
-
-/******************************************************************************
- *                        Intel Izmir i2c clients
- ******************************************************************************/
-static struct i2c_board_info __initdata izmir_i2c_board_info[] = {
-	{
-		I2C_BOARD_INFO("cy8c9540a", 0x20),
-	},
-	{
-		I2C_BOARD_INFO("at24", 0x50),
-		.platform_data = &at24_platform_data,
-	},
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-#define LPC_SCH_SPI_BUS_ID 0x03
-
-static struct platform_device lpc_sch_spi = {
-	.name = "spi-lpc-sch-drv",
-	.id = LPC_SCH_SPI_BUS_ID,
-};
-
-/* TODO: extract this data from layout.conf encoded in flash */
-struct mtd_partition ilb_partitions [] = {
-	{
-		.name		= "grub",
-		.size		= 0x80400,
-		.offset		= 0,
-	},
-	{
-		.name		= "grub.conf",
-		.size		= 0x900,
-		.offset		= 0x80400,
-	},
-	{
-		.name		= "layout.conf",
-		.size		= 0x7e00,
-		.offset		= 0x708200,
-	},
-	{
-		.name		= "sketch",
-		.size		= 0x40000,
-		.offset		= 0x750000,
-	},
-	{
-		.name		= "raw",
-		.size		= 8192000,
-		.offset		= 0,
-
-	},
-};
-
-static struct flash_platform_data ilb_flash = {
-	.type = "s25fl064k",
-	.parts = ilb_partitions,
-	.nr_parts = ARRAY_SIZE(ilb_partitions),
-};
-
-static struct spi_board_info spi_onboard_devs[] = {
-	{
-		.modalias = "m25p80",
-		.platform_data = &ilb_flash,
-		.bus_num = LPC_SCH_SPI_BUS_ID,
-		.chip_select = 0,
-	},
-	{
-		.modalias = "ad7298",
-		.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
-		.platform_data = &ad7298_platform_data,
-		.mode = SPI_MODE_2,
-		.bus_num = 0,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_0_cs_0,
-	},
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_1_cs_0,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-	},
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Izmir platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = intel_cln_spi_add_onboard_devs();
-
-	return ret;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-/* LPC SPI */
-static int intel_cln_plat_izmir_lpcspi_probe(struct platform_device *pdev)
-{
-	lpc_sch_spi.resource = pdev->resource;
-	return platform_device_register(&lpc_sch_spi);
-}
-
-static struct platform_driver intel_cln_plat_izmir_lpcspi_pdriver = {
-	.driver		= {
-		.name	= LPC_SCH_SPINAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_izmir_lpcspi_probe,
-};
-
-static int intel_cln_plat_izmir_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	/* i2c */
-	ret = i2c_register_board_info(0, izmir_i2c_board_info,
-		ARRAY_SIZE(izmir_i2c_board_info));
-	if (ret) {
-		goto end;
-	}
-
-	/* gpio */
-	ret = platform_driver_register(&gpio_restrict_pdriver);
-	if (ret)
-		goto end;
-
-	/* legacy SPI */
-	ret = platform_driver_register(&intel_cln_plat_izmir_lpcspi_pdriver);
-	if (ret)
-		goto end;
-
-	
-end:
-	return ret;
-}
-
-static int intel_cln_plat_izmir_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_izmir_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_izmir_probe,
-	.remove		= intel_cln_plat_izmir_remove,
-};
-
-module_platform_driver(cln_izmir_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Izmir BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_plat_kips_bay.c b/arch/x86/platform/cln/intel_cln_plat_kips_bay.c
deleted file mode 100644
index 915e527..0000000
--- a/arch/x86/platform/cln/intel_cln_plat_kips_bay.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME "cln-plat-kips-bay"
-#define GPIO_RESTRICT_NAME "cln-gpio-restrict-sc"
-
-#define CLN_SPI_MAX_CLK_DEFAULT		5000000
-
-static int gpio_cs = 1;
-
-module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
-
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Kips Bay platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	int ret = 0;
-	struct spi_board_info spi0_onboard_devs[] = {
-		{
-			.modalias = "ad7298",
-			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
-			.platform_data = &ad7298_platform_data,
-			.mode = SPI_MODE_2,
-			.bus_num = 0,
-			.chip_select = 0,
-			.controller_data = &cln_ffrd_spi_0_cs_0,
-		},
-	};
-	struct spi_board_info spi1_onboard_devs_gpiocs[] = {
-		{
-			.modalias = "spidev",
-			.chip_select = 0,
-			.controller_data = NULL,
-			.max_speed_hz = 50000000,
-			.bus_num = 1,
-			.controller_data = &cln_ffrd_spi_1_cs_0,
-		},
-	};
-	struct spi_board_info spi1_onboard_devs[] = {
-		{
-			.modalias = "spidev",
-			.chip_select = 0,
-			.controller_data = NULL,
-			.max_speed_hz = 50000000,
-			.bus_num = 1,
-		},
-	};
-
-	ret = spi_register_board_info(spi0_onboard_devs,
-				      ARRAY_SIZE(spi0_onboard_devs));
-	if (ret)
-		return ret;
-
-	if (gpio_cs)
-		return spi_register_board_info(spi1_onboard_devs_gpiocs,
-					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
-	else
-		return spi_register_board_info(spi1_onboard_devs,
-					ARRAY_SIZE(spi1_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = intel_cln_spi_add_onboard_devs();
-
-	return ret;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_kips_bay_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver);
-
-	return ret;
-}
-
-static int intel_cln_plat_kips_bay_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_kips_bay_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_kips_bay_probe,
-	.remove		= intel_cln_plat_kips_bay_remove,
-};
-
-module_platform_driver(cln_kips_bay_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Kips Bay BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/arch/x86/platform/cln/intel_cln_sb.c b/arch/x86/platform/cln/intel_cln_sb.c
deleted file mode 100644
index ef3714d..0000000
--- a/arch/x86/platform/cln/intel_cln_sb.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton side-band driver
- *
- * Thread-safe sideband read/write routine.
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
- */
-
-#include <linux/errno.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-
-#define INTEL_CLN_SB_CMD_ADDR	(0x000000D0)
-#define INTEL_CLN_SB_DATA_ADDR	(0x000000D4)
-
-#define INTEL_CLN_SB_MCR_SHIFT	(24)
-#define INTEL_CLN_SB_PORT_SHIFT	(16)
-#define INTEL_CLN_SB_REG_SHIFT	(8)
-#define INTEL_CLN_SB_BYTEEN	(0xF0)	/* enable all 32 bits */
-
-/* Simple structure for module */
-struct intel_cln_sb_dev{
-	struct pci_dev * pdev;
-	spinlock_t slock;
-	u8 initialized;
-};
-
-static struct intel_cln_sb_dev sb_dev = {
-	.initialized = 0
-};
-
-/* Dependant drivers */
-struct platform_device pdev [] = {
-	{
-		.name = "intel-cln-esram",
-	},
-	{
-		.name = "intel-cln-imr",
-	},
-	{
-		.name = "intel-cln-ecc",
-	},
-	{
-		.name = "intel-cln-thrm",
-	},
-};
-
-/**
- * intel_cln_sb_read_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe read of side-band
- * command - can be different read op-code types - which is why we don't
- * hard-code this value directly into msg
- */
-void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock)
-{
-	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
-		  INTEL_CLN_SB_BYTEEN;
-
-	if(data == NULL)
-		return;
-
-	if (likely(lock == 1)) {
-		spin_lock(&sb_dev.slock);
-	}
-
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
-	pci_read_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
-
-	if(likely(lock == 1)){
-		spin_unlock(&sb_dev.slock);
-	}
-
-}
-EXPORT_SYMBOL(intel_cln_sb_read_reg);
-
-/**
- * intel_cln_sb_write_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe write of side-band
- */
-void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock)
-{
-	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
-		  INTEL_CLN_SB_BYTEEN;
-
-	if(likely(lock == 1)){
-		spin_lock(&sb_dev.slock);
-	}
-
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
-	
-	if(likely(lock == 1)){
-		spin_unlock(&sb_dev.slock);
-	}
-}
-EXPORT_SYMBOL(intel_cln_sb_write_reg);
-
-/**
- * intel_cln_sb_runfn_lock
- *
- * @param fn: Callback function - which requires side-band spinlock and !irq
- * @param arg: Callback argument
- * @return 0 on success < 0 on failure
- *
- * Runs the given function pointer inside of a call to the local spinlock using
- * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
- * guarantee atomicity, but, available to any other user of sideband provided
- * rules are respected.
- * Rules:
- *	fn may not sleep
- *	fn may not change the state of irqs	
- */
-int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg)
-{
-	unsigned long flags = 0;
-	int ret = 0;
-
-	if(unlikely(fn == NULL)){
-		return -EINVAL;
-	}
-	
-	/* Get spinlock with IRQs off */
-	spin_lock_irqsave(&sb_dev.slock, flags);
-
-	/* Run function atomically */
-	ret = fn(arg);
-
-	/* Release lock */
-	spin_unlock_irqrestore(&sb_dev.slock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL(intel_cln_sb_runfn_lock);
-
-/**
- * sb_probe
- *
- * @param dev: the PCI device matching
- * @param id: entry in the match table
- * @return 0
- *
- * Callback from PCI layer when dev/vendor ids match.
- * Sets up necessary resources
- */
-static int intel_cln_sb_probe(struct pci_dev *dev, const struct pci_device_id *id)
-{
-	int i = 0;
-
-	/* Init struct */
-	memset(&sb_dev, 0x00, sizeof(sb_dev));
-
-	/* Hook device */
-	sb_dev.pdev = dev;
-
-	/* Init locking structures */
-	spin_lock_init(&sb_dev.slock);
-
-	/* Set state */
-	sb_dev.initialized = 1;
-
-	/* Register side-band sub-ordinate drivers */
-	for (i = 0; i < sizeof(pdev)/sizeof(struct platform_device); i++){
-		platform_device_register(&pdev[i]);
-	}
-	pr_info("Intel Clanton side-band driver registered\n");
-	return 0;
-}
-
-/**
- * sb_remove
- *
- * @param pdev: PCI device
- * @return nothing
- *
- * Callback from PCI sub-system upon PCI dev removal
- */
-static void intel_cln_sb_remove(struct pci_dev *pdev)
-{
-}
-
-/* Clanton hardware */
-struct pci_device_id intel_cln_sb_ids[] = {
-        { PCI_VDEVICE(INTEL, 0x0958), 0},
-        { 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, intel_cln_sb_ids);
-
-/* PCI callbacks */
-static struct pci_driver intel_cln_sb_driver = {
-	.name = "intel_cln_sb",
-	.id_table = intel_cln_sb_ids,
-	.probe = intel_cln_sb_probe,
-	.remove = intel_cln_sb_remove,
-};
-
-/**
- * intel_cln_sb_init
- *
- * Module entry point
- */
-static int __init intel_cln_sb_init(void)
-{
-	return pci_register_driver(&intel_cln_sb_driver);
-}
-
-/**
- * intel_cln_sb_exit
- *
- * Module exit
- */
-static void __exit intel_cln_sb_exit(void)
-{
-	sb_dev.initialized = 0;
-	pci_unregister_driver(&intel_cln_sb_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SOC side-band driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-/* Initialise early since other drivers eSRAM, DRAM ECC and thermal depend */
-device_initcall(intel_cln_sb_init);
-module_exit(intel_cln_sb_exit);
diff --git a/arch/x86/platform/cln/intel_cln_smep_test.c b/arch/x86/platform/cln/intel_cln_smep_test.c
deleted file mode 100644
index 16f43db..0000000
--- a/arch/x86/platform/cln/intel_cln_smep_test.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_smep_test.c
- *
- * Simple test module to verify SMEP works as expected on MIA
- * DO NOT RELEASE THIS FILE OUTSIDE OF CLANTON GROUP
- * DO NOT ATTEMPT TO UPSTREAM THIS CODE - YOU WILL BE PUBLICLY EMBARRSSED !
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@intel.com>
- *
- */
-#include <asm/processor.h>
-#include <asm/processor-flags.h>
-#include <linux/cdev.h>
-#include <linux/crc16.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#define DRIVER_NAME			"intel_cln_smep_test"
-
-/**
- * struct intel_cln_smep_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_smep_test_dev{
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-	char * pdata;
-	u32 size;
-};
-
-static struct intel_cln_smep_test_dev smep_test_dev;
-static struct class *smep_test_class;
-static DEFINE_MUTEX(smep_test_mutex);
-static int smep_test_major;
-static char * name = "testmap";
-
-/**
- * smep_test_ioctl
- *
- * Allows user-space to command kernel switch SMEP on/off
- */
-static long smep_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int cr4 = 0;
-
-	cr4 = read_cr4();
-	printk(KERN_INFO "%s entry CR4 is 0x%08x\n", __FUNCTION__, cr4);
-
-	switch(cmd){
-		case 0:
-			printk(KERN_INFO "Switching SMEP off\n");
-			cr4 &= ~X86_CR4_SMEP;
-			
-			break;
-		case 1:
-			printk(KERN_INFO "Switching SMEP on\n");
-			cr4 |= X86_CR4_SMEP;
-			break;
-		default:
-			return -EINVAL;
-	}
-	/* Latch value */
-	write_cr4(cr4);
-
-	/* Print contents of CR4 */
-	cr4 = read_cr4();
-	printk(KERN_INFO "%s exit CR4 is 0x%08x\n", __FUNCTION__, cr4);
-	
-	return 0;
-}
-
-/**
- * smep_test_write
- *
- * Accepts a buffer from user-space and then tries to execute the contents
- * Be very careful
- */
-static ssize_t smep_test_write(struct file *file, const char __user *buf,
-						size_t count, loff_t *ppos)
-{
-	/* 
-	 * We assume we are passed a pointer to function of type
-	 * void fn(void)
-	 */
-	void (*fn)(void) = (void(*))buf;
-	if (count) {
-		printk(KERN_INFO "Will attempt exec %d bytes of ring3 code @ 0x%p\n",
-			count, buf);
-		fn();
-		printk(KERN_INFO "Exec of data @ 0x%p complete\n", buf);
-	}
-	return count;
-}
-
-static int smep_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&smep_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&smep_test_dev.open_lock)) {
-		mutex_unlock(&smep_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (smep_test_dev.opened) {
-		mutex_unlock(&smep_test_dev.open_lock);
-		mutex_unlock(&smep_test_mutex);
-		return -EINVAL;
-	}
-
-	smep_test_dev.opened++;
-	mutex_unlock(&smep_test_dev.open_lock);
-	mutex_unlock(&smep_test_mutex);
-	return 0;
-}
-
-static int smep_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&smep_test_dev.open_lock);
-	smep_test_dev.opened = 0;
-	mutex_unlock(&smep_test_dev.open_lock);
-
-	return 0;
-}
-
-
-
-static const struct file_operations smep_test_file_ops = {
-	.open = smep_test_open,
-	.release = smep_test_release,
-	.unlocked_ioctl = smep_test_ioctl,
-	.write		= smep_test_write,
-	.llseek = no_llseek,
-};
-
-
-/**
- * intel_cln_smep_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_smep_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&smep_test_dev.open_lock);
-	cdev_init(&smep_test_dev.cdev, &smep_test_file_ops);
-	smep_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&smep_test_dev.cdev, MKDEV(smep_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(smep_test_class, NULL,
-				 MKDEV(smep_test_major, minor), NULL,
-				 "smeptest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-	printk(KERN_INFO "%s complete OK - device /dev/smeptest%u\n", __FUNCTION__, minor);
-	return 0;
-
-}
-
-/**
- * intel_cln_smep_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_smep_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(smep_test_dev.cdev.dev);
-
-	device_destroy(smep_test_class, MKDEV(smep_test_major, minor));
-	cdev_del(&smep_test_dev.cdev);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_smep_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_smep_test_remove,
-};
-
-/**
- * intel_cln_smep_init
- *
- * @return 0 success < 0 failure
- *
- * Module entry point
- */
-static int __init intel_cln_smep_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	smep_test_class = class_create(THIS_MODULE,"cln_smep_test");
-	if (IS_ERR(smep_test_class)) {
-		retval = PTR_ERR(smep_test_class);
-		printk(KERN_ERR "smep_test: can't register earam_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "smep_test");
-	if (retval) {
-		printk(KERN_ERR "smep_test: can't register character device\n");
-		goto err_class;
-	}
-	smep_test_major = MAJOR(dev);
-
-	memset(&smep_test_dev, 0x00, sizeof(smep_test_dev));
-	smep_test_dev.pldev = platform_create_bundle(
-		&intel_cln_smep_test_driver, intel_cln_smep_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(smep_test_dev.pldev)){
-		printk(KERN_ERR "smep_test platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(smep_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(smep_test_class);
-err:
-	return retval;
-}
-
-/**
- * intel_cln_smep_exit
- *
- * Module exit
- */
-static void __exit intel_cln_smep_test_exit(void)
-{
-	platform_device_unregister(smep_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_smep_test_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SMEP test");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_init(intel_cln_smep_test_init);
-module_exit(intel_cln_smep_test_exit);
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 73db7cc..22d4ef3 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -885,15 +885,10 @@ void __init efi_enter_virtual_mode(void)
 
 	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
 		md = p;
-		if (!(md->attribute & EFI_MEMORY_RUNTIME)) {
-			if (!bgrt_map
-#ifdef CONFIG_X86_64
-			|| (md->type != EFI_BOOT_SERVICES_CODE &&
-			    md->type != EFI_BOOT_SERVICES_DATA)
-#endif
-			)
-				continue;
-		}
+		if (!((md->attribute & EFI_MEMORY_RUNTIME) || (bgrt_map &&
+		    (md->type == EFI_BOOT_SERVICES_CODE ||
+		    md->type == EFI_BOOT_SERVICES_DATA))))
+			continue;
 
 		size = md->num_pages << EFI_PAGE_SHIFT;
 		end = md->phys_addr + size;
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 5e5fd23..6381fbe 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -62,7 +62,7 @@ config INTEL_MID_PCI
 
 config INTEL_CLN_DMAC
 	tristate "Intel CLN DMA support for Peripheral DMA controllers"
-	depends on PCI && X86 && INTEL_CLN_SOC
+	depends on PCI && X86 && INTEL_QUARK_X1000_SOC
 	default n
 	help
 	  Enable support for the Intel(R) Clanton DMA engine present
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index a60f472..6bb265e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -370,7 +370,7 @@ config I2C_DESIGNWARE_PLATFORM
 
 config I2C_DESIGNWARE_PCI
 	tristate "Synopsys DesignWare PCI"
-	depends on PCI && !INTEL_CLN_SOC
+	depends on PCI && !INTEL_QUARK_X1000_SOC
 	select I2C_DESIGNWARE_CORE
 	help
 	  If you say yes to this option, support will be included for the
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index 45c0cc6..8485d63 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -366,6 +366,9 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
 	struct i2c_msg *msgs = dev->msgs;
 	u32 ic_con;
 
+	/* Disable interrupts */
+	i2c_dw_disable_int(dev);
+
 	/* Disable the adapter */
 	dw_writel(dev, 0, DW_IC_ENABLE);
 
diff --git a/drivers/iio/accel/Kconfig b/drivers/iio/accel/Kconfig
index 05e996f..5021a16 100644
--- a/drivers/iio/accel/Kconfig
+++ b/drivers/iio/accel/Kconfig
@@ -14,4 +14,12 @@ config HID_SENSOR_ACCEL_3D
 	  Say yes here to build support for the HID SENSOR
 	  accelerometers 3D.
 
+config IIO_LIS331DLH_INTEL_CLN
+	tristate "STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Clanton platform"
+	depends on INTEL_QUARK_X1000_SOC
+	depends on I2C && SYSFS
+	select IIO_ST_SENSORS_CORE
+	help
+	  Selects the LIS331DLH accelerometer driver for the Intel Clanton Hill platform
+
 endmenu
diff --git a/drivers/iio/accel/Makefile b/drivers/iio/accel/Makefile
index 5bc6855..16f8e38 100644
--- a/drivers/iio/accel/Makefile
+++ b/drivers/iio/accel/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_HID_SENSOR_ACCEL_3D) += hid-sensor-accel-3d.o
+obj-$(CONFIG_IIO_LIS331DLH_INTEL_CLN) += lis331dlh_intel_cln.o
diff --git a/drivers/iio/accel/lis331dlh_intel_cln.c b/drivers/iio/accel/lis331dlh_intel_cln.c
new file mode 100644
index 0000000..57998d0
--- /dev/null
+++ b/drivers/iio/accel/lis331dlh_intel_cln.c
@@ -0,0 +1,675 @@
+/*
+ * Intel Clanton Hill platform accelerometer driver
+ *
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * Derived from STMicroelectronics accelerometers driver by Denis Ciocca
+ *
+ * The Intel Clanton Hill platform hardware design includes an
+ * STMicroelectronics LIS331DLH accelerometer, intended to be used mainly for
+ * sensing orientation, movement and sudden impacts (e.g. vehicle collision)
+ *
+ * This driver plugs into the Linux Industrial-IO framework to provide a
+ * standardised user-space application interface for retreiving data and events
+ * from the accelerometer.
+ *
+ * The LIS331DLH is connected via I2C to the host CPU on the Clanton Hill
+ * platform and so this driver registers to the kernel as an I2C device driver
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include <linux/iio/common/st_sensors_i2c.h>
+
+#include <linux/platform_data/lis331dlh_intel_cln.h>
+
+/* DEFAULT VALUE FOR SENSORS */
+#define ST_ACCEL_DEFAULT_OUT_X_L_ADDR		0x28
+#define ST_ACCEL_DEFAULT_OUT_Y_L_ADDR		0x2a
+#define ST_ACCEL_DEFAULT_OUT_Z_L_ADDR		0x2c
+
+/* FULLSCALE */
+#define ST_ACCEL_FS_AVL_2G			2
+#define ST_ACCEL_FS_AVL_4G			4
+#define ST_ACCEL_FS_AVL_6G			6
+#define ST_ACCEL_FS_AVL_8G			8
+#define ST_ACCEL_FS_AVL_16G			16
+
+/* CUSTOM VALUES FOR SENSOR 2 */
+#define ST_ACCEL_2_WAI_EXP			0x32
+#define ST_ACCEL_2_ODR_ADDR			0x20
+#define ST_ACCEL_2_ODR_MASK			0x18
+#define ST_ACCEL_2_ODR_AVL_50HZ_VAL		0x00
+#define ST_ACCEL_2_ODR_AVL_100HZ_VAL		0x01
+#define ST_ACCEL_2_ODR_AVL_400HZ_VAL		0x02
+#define ST_ACCEL_2_ODR_AVL_1000HZ_VAL		0x03
+#define ST_ACCEL_2_PW_ADDR			0x20
+#define ST_ACCEL_2_PW_MASK			0xe0
+#define ST_ACCEL_2_PW_DOWN			0x00
+#define ST_ACCEL_2_PW_NORMAL		0x20
+#define ST_ACCEL_2_CTRL_REG1_XEN	0x01
+#define ST_ACCEL_2_CTRL_REG1_YEN	0x02
+#define ST_ACCEL_2_CTRL_REG1_ZEN	0x04
+#define ST_ACCEL_2_FS_ADDR			0x23
+#define ST_ACCEL_2_FS_MASK			0x30
+#define ST_ACCEL_2_FS_AVL_2_VAL			0X00
+#define ST_ACCEL_2_FS_AVL_4_VAL			0X01
+#define ST_ACCEL_2_FS_AVL_8_VAL			0x03
+#define ST_ACCEL_2_FS_AVL_2_GAIN		IIO_G_TO_M_S_2(1000)
+#define ST_ACCEL_2_FS_AVL_4_GAIN		IIO_G_TO_M_S_2(2000)
+#define ST_ACCEL_2_FS_AVL_8_GAIN		IIO_G_TO_M_S_2(3900)
+#define ST_ACCEL_2_BDU_ADDR			0x23
+#define ST_ACCEL_2_BDU_MASK			0x80
+#define ST_ACCEL_2_DRDY_IRQ_ADDR		0x22
+#define ST_ACCEL_2_DRDY_IRQ_MASK		0x02
+#define ST_ACCEL_2_THRESH_IRQ_ADDR		0x30
+#define ST_ACCEL_2_THRESH_IRQ_MASK		0x7f
+#define ST_ACCEL_2_INT1_CFG_ADDR		0x30
+#define ST_ACCEL_2_INT1_SRC_ADDR		0x31
+#define ST_ACCEL_2_INT1_THRESH_ADDR		0x32
+#define ST_ACCEL_2_INT1_DURATION_ADDR		0x33
+#define ST_ACCEL_2_INT2_CFG_ADDR		0x34
+#define ST_ACCEL_2_INT2_SRC_ADDR		0x35
+#define ST_ACCEL_2_INT2_THRESH_ADDR		0x36
+#define ST_ACCEL_2_INT2_DURATION_ADDR		0x37
+#define ST_ACCEL_2_INT_IA_MASK			0x40
+#define ST_ACCEL_2_INT_LIR_MASK			0x05
+#define ST_ACCEL_2_INT_SRC_HIGH_MASK	0x20
+#define ST_ACCEL_2_INT_CFG_XLIE_EN		0x01
+#define ST_ACCEL_2_INT_CFG_XHIE_EN		0x02
+#define ST_ACCEL_2_INT_CFG_YLIE_EN		0x04
+#define ST_ACCEL_2_INT_CFG_YHIE_EN		0x08
+#define ST_ACCEL_2_INT_CFG_ZLIE_EN		0x10
+#define ST_ACCEL_2_INT_CFG_ZHIE_EN		0x20
+
+#define ST_ACCEL_2_MULTIREAD_BIT		true
+#define CLN_ACCEL_INT2_WAKEUP_THRESH_VAL	0x7f
+
+static const u8 iio_modifier_map[] = {
+	IIO_NO_MOD,
+	IIO_MOD_X,
+	IIO_MOD_Y,
+	IIO_MOD_X_AND_Y,
+	IIO_MOD_Z,
+	IIO_MOD_X_AND_Z,
+	IIO_MOD_Y_AND_Z,
+	IIO_MOD_X_AND_Y_AND_Z,
+};
+
+/*  Threshold event ISR bottom half.  This function reads interrupt status
+ *  registers for INT1 to reset any active interrupt conditions
+ *  and pushes an IIO event if a threshold interrupt was active.
+ */
+static irqreturn_t lis331dlh_intel_cln_threshold_event_handler(
+	int irq,
+	void *private)
+{
+	int err;
+	u8 data;
+	u8 mask;
+	int i;
+	u64 iio_modifier;
+
+	struct st_sensor_data *sdata = iio_priv(private);
+	s64 timestamp = iio_get_time_ns();
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+			ST_ACCEL_2_INT1_SRC_ADDR,
+			&data);
+
+	if (err < 0)
+		goto st_sensors_read_err;
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+			ST_ACCEL_2_INT1_CFG_ADDR,
+				&mask);
+
+	if (err < 0)
+		goto st_sensors_read_err;
+
+	if (data & ST_ACCEL_2_INT_IA_MASK) {
+		data &= mask;
+
+		iio_modifier = 0;
+		for (i = 0; i < ST_SENSORS_NUMBER_DATA_CHANNELS; i++) {
+			iio_modifier <<= 1;
+			iio_modifier += !!(data & ST_ACCEL_2_INT_SRC_HIGH_MASK);
+			data <<= 2;
+		}
+
+		iio_modifier = iio_modifier_map[iio_modifier];
+
+		iio_push_event(private,
+				IIO_EVENT_CODE(IIO_ACCEL,
+				0, /* non differential */
+				iio_modifier,
+				IIO_EV_TYPE_THRESH,
+				IIO_EV_DIR_RISING, 0, 0, 0),
+				timestamp);
+	}
+
+st_sensors_read_err:
+	return IRQ_HANDLED;
+}
+
+static int lis331dlh_intel_cln_read_raw(
+	struct iio_dev *indio_dev,
+	struct iio_chan_spec const *ch,
+	int *val, int *val2, long mask)
+{
+	int err;
+	struct st_sensor_data *adata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		err = st_sensors_read_info_raw(indio_dev, ch, val);
+		if (err < 0)
+			goto read_error;
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = adata->current_fullscale->gain;
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+read_error:
+	return err;
+}
+
+static int lis331dlh_intel_cln_write_raw(
+	struct iio_dev *indio_dev,
+	struct iio_chan_spec const *chan,
+	int val, int val2, long mask)
+{
+	int err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		err = st_sensors_set_fullscale_by_gain(indio_dev, val2);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+
+static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
+static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
+static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
+
+static struct attribute *lis331dlh_intel_cln_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group lis331dlh_intel_cln_attribute_group = {
+	.attrs = lis331dlh_intel_cln_attributes,
+};
+
+static int lis331dlh_intel_cln_read_event_value(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int *val)
+{
+	int err;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_THRESH_ADDR, &data);
+
+	*val = (int) data;
+	return err;
+}
+
+static int lis331dlh_intel_cln_write_event_value(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int val)
+{
+	int err;
+	struct st_sensor_data *sdata;
+
+	/* range check */
+	if ((val < 0) || (val > 0x7f))
+		return -EINVAL;
+
+	sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_THRESH_ADDR, val);
+
+	return err;
+
+}
+
+/*  Configure the INT1 pin to fire an interrupt on a high threshold event.
+ */
+static int lis331dlh_intel_cln_configure_threshold_interrupt(
+	struct iio_dev *indio_dev, bool state)
+{
+	int err = 0;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->int_thresh == state)
+		return 0;
+
+	if (state) {
+		err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
+				NULL,
+				lis331dlh_intel_cln_threshold_event_handler,
+				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				"lis331dlh_intel_cln_threshold",
+				indio_dev);
+		if (err == 0) {
+			sdata->int_thresh = true;
+			err = sdata->tf->write_byte(
+				&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_DURATION_ADDR, 1);
+		}
+	} else {
+		free_irq(sdata->get_irq_data_ready(indio_dev), indio_dev);
+		sdata->int_thresh = false;
+	}
+
+	return err;
+}
+
+static int lis331dlh_intel_cln_read_event_config(
+	struct iio_dev *indio_dev,
+	u64 event_code)
+{
+	int err = 0;
+	u8 data, mask;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				   ST_ACCEL_2_INT1_CFG_ADDR,
+				   &data);
+
+	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
+
+	return !!(data & mask);
+}
+
+static int lis331dlh_intel_cln_write_event_config(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int state)
+{
+	int err;
+	u8 data;
+	u8 mask;
+
+	bool new_int_state;
+
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
+
+	err = st_sensors_write_data_with_mask(indio_dev,
+					      ST_ACCEL_2_INT1_CFG_ADDR,
+					      mask, state);
+
+	if (err == 0)
+		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					   ST_ACCEL_2_INT1_CFG_ADDR, &data);
+
+	if (err == 0) {
+		new_int_state = data & (ST_ACCEL_2_INT_CFG_XHIE_EN |
+					ST_ACCEL_2_INT_CFG_YHIE_EN |
+					ST_ACCEL_2_INT_CFG_ZHIE_EN);
+		err = lis331dlh_intel_cln_configure_threshold_interrupt(
+			indio_dev, new_int_state);
+	}
+
+	return err;
+}
+
+/*  Configure the INT2 pin to fire an interrupt on a threshold high event.  INT2
+ *  should be wired to a suspend well IRQ to wake up the host.
+ */
+static int lis331dlh_intel_cln_enable_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err = 0;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (err == 0)
+		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT2_THRESH_ADDR,
+					CLN_ACCEL_INT2_WAKEUP_THRESH_VAL);
+
+	/* Latch interrupt request on INT2 */
+	if (err == 0)
+		err = st_sensors_write_data_with_mask(
+			indio_dev, ST_ACCEL_2_DRDY_IRQ_ADDR,
+			ST_ACCEL_2_INT_LIR_MASK, 1);
+
+	if (err == 0)
+		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					    ST_ACCEL_2_INT2_DURATION_ADDR, 0);
+
+	if (err == 0)
+		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					    ST_ACCEL_2_INT2_CFG_ADDR,
+					    ST_ACCEL_2_INT_CFG_XHIE_EN |
+					    ST_ACCEL_2_INT_CFG_YHIE_EN);
+
+	/* Clean ST_ACCEL_2_INT2_SRC */
+	if (err == 0)
+		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					   ST_ACCEL_2_INT2_SRC_ADDR,
+					   &data);
+
+	return err;
+}
+
+static int lis331dlh_intel_cln_disable_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err = 0;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (err == 0)
+		err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					    ST_ACCEL_2_INT2_CFG_ADDR,
+					    0);
+
+	/* Clean ST_ACCEL_2_INT2_SRC */
+	if (err == 0)
+		err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					   ST_ACCEL_2_INT2_SRC_ADDR,
+					   &data);
+
+	return err;
+}
+
+static int lis331dlh_intel_cln_handle_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+	s64 timestamp = iio_get_time_ns();
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				   ST_ACCEL_2_INT2_SRC_ADDR,
+				   &data);
+
+	if (err == 0)
+		if (data & ST_ACCEL_2_INT_IA_MASK) {
+			iio_push_event(indio_dev,
+					IIO_EVENT_CODE(IIO_ACCEL,
+					0, /* non differential */
+					IIO_MOD_X_OR_Y_OR_Z,
+					IIO_EV_TYPE_THRESH,
+					IIO_EV_DIR_EITHER, 0, 0, 0),
+					timestamp);
+		}
+
+	return err;
+}
+
+static const struct iio_info accel_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &lis331dlh_intel_cln_attribute_group,
+	.read_raw = &lis331dlh_intel_cln_read_raw,
+	.write_raw = &lis331dlh_intel_cln_write_raw,
+	.read_event_config = &lis331dlh_intel_cln_read_event_config,
+	.write_event_config = &lis331dlh_intel_cln_write_event_config,
+	.read_event_value = &lis331dlh_intel_cln_read_event_value,
+	.write_event_value = &lis331dlh_intel_cln_write_event_value,
+};
+
+static const struct iio_chan_spec st_accel_12bit_channels[] = {
+	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Z_L_ADDR),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static struct st_sensors lis331dlh_intel_cln_sensor = {
+	.wai = ST_ACCEL_2_WAI_EXP,
+	.sensors_supported = {
+		[0] = "lis331dlh_cln",
+	},
+	.ch = (struct iio_chan_spec *)st_accel_12bit_channels,
+	.odr = {
+		.addr = ST_ACCEL_2_ODR_ADDR,
+		.mask = ST_ACCEL_2_ODR_MASK,
+		.odr_avl = {
+			{ 50, ST_ACCEL_2_ODR_AVL_50HZ_VAL, },
+			{ 100, ST_ACCEL_2_ODR_AVL_100HZ_VAL, },
+			{ 400, ST_ACCEL_2_ODR_AVL_400HZ_VAL, },
+			{ 1000, ST_ACCEL_2_ODR_AVL_1000HZ_VAL, },
+		},
+	},
+	.pw = {
+		.addr = ST_ACCEL_2_PW_ADDR,
+		.mask = ST_ACCEL_2_PW_MASK,
+		.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,
+		.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,
+	},
+	.enable_axis = {
+		.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,
+		.mask = ST_SENSORS_DEFAULT_AXIS_MASK,
+	},
+	.fs = {
+		.addr = ST_ACCEL_2_FS_ADDR,
+		.mask = ST_ACCEL_2_FS_MASK,
+		.fs_avl = {
+			[0] = {
+				.num = ST_ACCEL_FS_AVL_2G,
+				.value = ST_ACCEL_2_FS_AVL_2_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_2_GAIN,
+			},
+			[1] = {
+				.num = ST_ACCEL_FS_AVL_4G,
+				.value = ST_ACCEL_2_FS_AVL_4_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_4_GAIN,
+			},
+			[2] = {
+				.num = ST_ACCEL_FS_AVL_8G,
+				.value = ST_ACCEL_2_FS_AVL_8_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_8_GAIN,
+			},
+		},
+	},
+	.bdu = {
+		.addr = ST_ACCEL_2_BDU_ADDR,
+		.mask = ST_ACCEL_2_BDU_MASK,
+	},
+	.drdy_irq = {
+		.addr = ST_ACCEL_2_DRDY_IRQ_ADDR,
+		.mask = ST_ACCEL_2_DRDY_IRQ_MASK,
+	},
+	.multi_read_bit = ST_ACCEL_2_MULTIREAD_BIT,
+	.bootime = 2,
+};
+
+static int lis331dlh_intel_cln_probe(
+	struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct iio_dev *indio_dev;
+	struct st_sensor_data *adata;
+	struct lis331dlh_intel_cln_platform_data *pdata;
+	int ret = 0;
+
+	indio_dev = iio_device_alloc(sizeof(*adata));
+	if (indio_dev == NULL) {
+		ret = -ENOMEM;
+		goto iio_device_alloc_error;
+	}
+
+	i2c_set_clientdata(client, indio_dev);
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = client->name;
+
+	adata = iio_priv(indio_dev);
+	adata->dev = &client->dev;
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		pr_err("No platform data provided\n");
+		goto lis331dlh_intel_cln_init_err;
+	}
+
+	ret = gpio_to_irq(pdata->irq1_pin);
+	if (ret < 0) {
+		pr_err(
+			"Failed to obtain valid IRQ for GPIO %d, "
+			"gpio_to_irq returned %d\n",
+			pdata->irq1_pin, ret);
+		goto lis331dlh_intel_cln_init_err;
+	}
+	to_i2c_client(adata->dev)->irq = ret;
+
+	st_sensors_i2c_configure(indio_dev, client, adata);
+
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &accel_info;
+
+	ret = st_sensors_check_device_support(indio_dev,
+					      1, &lis331dlh_intel_cln_sensor);
+	if (ret < 0)
+		goto lis331dlh_intel_cln_init_err;
+
+	indio_dev->channels = adata->sensor->ch;
+	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
+
+	adata->multiread_bit = adata->sensor->multi_read_bit;
+	adata->current_fullscale = (struct st_sensor_fullscale_avl *)
+		&adata->sensor->fs.fs_avl[0];
+	adata->odr = adata->sensor->odr.odr_avl[0].hz;
+	adata->int_thresh = false;
+
+	ret = st_sensors_init_sensor(indio_dev);
+	if (ret < 0)
+		goto lis331dlh_intel_cln_init_err;
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto lis331dlh_intel_cln_init_err;
+
+	return 0;
+
+lis331dlh_intel_cln_init_err:
+	iio_device_free(indio_dev);
+iio_device_alloc_error:
+	return ret;
+}
+
+static int lis331dlh_intel_cln_remove(
+	struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct st_sensor_data *adata = iio_priv(indio_dev);
+
+	st_sensors_set_enable(indio_dev, false);
+
+	if (adata->int_thresh)
+		free_irq(adata->get_irq_data_ready(indio_dev), indio_dev);
+
+	iio_device_unregister(indio_dev);
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331dlh_intel_cln_suspend(
+	struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	lis331dlh_intel_cln_enable_wakeup_interrupt(indio_dev);
+
+	return 0;
+}
+
+static int lis331dlh_intel_cln_resume(
+	struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	lis331dlh_intel_cln_handle_wakeup_interrupt(indio_dev);
+	lis331dlh_intel_cln_disable_wakeup_interrupt(indio_dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops lis331dlh_intel_cln_pm_ops = {
+	.suspend = lis331dlh_intel_cln_suspend,
+	.resume = lis331dlh_intel_cln_resume,
+};
+
+#define LIS331DLH_INTEL_CLN_PM_OPS (&lis331dlh_intel_cln_pm_ops)
+#else
+#define LIS331DLH_INTEL_CLN_PM_OPS NULL
+#endif
+
+static const struct i2c_device_id lis331dlh_intel_cln_id_table[] = {
+	{ "lis331dlh_cln" },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, lis331dlh_intel_cln_id_table);
+
+static struct i2c_driver lis331dlh_intel_cln_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lis331dlh_cln",
+		.pm	= LIS331DLH_INTEL_CLN_PM_OPS,
+	},
+	.probe = lis331dlh_intel_cln_probe,
+	.remove = lis331dlh_intel_cln_remove,
+	.id_table = lis331dlh_intel_cln_id_table,
+};
+
+module_i2c_driver(lis331dlh_intel_cln_driver);
+
+MODULE_AUTHOR("Wojciech Ziemba <wojciech.ziemba@emutex.com>");
+MODULE_DESCRIPTION("STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Clanton platform");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/adc/ad7298.c b/drivers/iio/adc/ad7298.c
index 907a951..1a3292a 100644
--- a/drivers/iio/adc/ad7298.c
+++ b/drivers/iio/adc/ad7298.c
@@ -64,7 +64,7 @@ struct ad7298_state {
 		.indexed = 1,						\
 		.channel = index,					\
 		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT |		\
-		IIO_CHAN_INFO_SCALE_SHARED_BIT,				\
+		IIO_CHAN_INFO_SCALE_SEPARATE_BIT,				\
 		.address = index,					\
 		.scan_index = index,					\
 		.scan_type = {						\
diff --git a/drivers/iio/adc/max78m6610_lmu.c b/drivers/iio/adc/max78m6610_lmu.c
index 7e25533..f38ed57 100644
--- a/drivers/iio/adc/max78m6610_lmu.c
+++ b/drivers/iio/adc/max78m6610_lmu.c
@@ -1,7 +1,23 @@
 /*
  * max78m6610+lmu SPI protocol driver
  *
- * {% copyright %}
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
  *
  * This SPI protocol driver is developed for the Maxim 78M6610+LMU (eADC).
  * The driver is developed as a part of the Clanton BSP where integrated into
@@ -764,8 +780,8 @@ static int max78m6610_lmu_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 
-	iio_triggered_buffer_cleanup(indio_dev);
 	iio_device_unregister(indio_dev);
+	iio_triggered_buffer_cleanup(indio_dev);
 	iio_device_free(indio_dev);
 
 	return 0;
diff --git a/drivers/iio/common/Kconfig b/drivers/iio/common/Kconfig
index ed45ee5..0b6e97d 100644
--- a/drivers/iio/common/Kconfig
+++ b/drivers/iio/common/Kconfig
@@ -3,3 +3,4 @@
 #
 
 source "drivers/iio/common/hid-sensors/Kconfig"
+source "drivers/iio/common/st_sensors/Kconfig"
diff --git a/drivers/iio/common/Makefile b/drivers/iio/common/Makefile
index 8158400..c2352be 100644
--- a/drivers/iio/common/Makefile
+++ b/drivers/iio/common/Makefile
@@ -7,3 +7,4 @@
 #
 
 obj-y += hid-sensors/
+obj-y += st_sensors/
diff --git a/drivers/iio/common/st_sensors/Kconfig b/drivers/iio/common/st_sensors/Kconfig
new file mode 100644
index 0000000..d1b474a
--- /dev/null
+++ b/drivers/iio/common/st_sensors/Kconfig
@@ -0,0 +1,20 @@
+#
+# STMicroelectronics sensors common library
+#
+
+menu "STMicro sensors"
+config IIO_ST_SENSORS_I2C
+	tristate "IIO ST SENSORS"
+	help
+	  Enable SENSORS I2C option
+
+config IIO_ST_SENSORS_SPI
+	tristate "IIO SENSORS SPI"
+	help
+	  Enable IIO_ST_SENSORS_SPI
+
+config IIO_ST_SENSORS_CORE
+	tristate "IIO SENSORS CORE"
+	select IIO_ST_SENSORS_I2C if I2C
+	select IIO_ST_SENSORS_SPI if SPI_MASTER
+endmenu
diff --git a/drivers/iio/common/st_sensors/Makefile b/drivers/iio/common/st_sensors/Makefile
new file mode 100644
index 0000000..9f3e24f
--- /dev/null
+++ b/drivers/iio/common/st_sensors/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the STMicroelectronics sensor common modules.
+#
+
+obj-$(CONFIG_IIO_ST_SENSORS_I2C) += st_sensors_i2c.o
+obj-$(CONFIG_IIO_ST_SENSORS_SPI) += st_sensors_spi.o
+obj-$(CONFIG_IIO_ST_SENSORS_CORE) += st_sensors.o
+st_sensors-y := st_sensors_core.o
+st_sensors-$(CONFIG_IIO_BUFFER) += st_sensors_buffer.o
+st_sensors-$(CONFIG_IIO_TRIGGER) += st_sensors_trigger.o
diff --git a/drivers/iio/common/st_sensors/st_sensors_buffer.c b/drivers/iio/common/st_sensors/st_sensors_buffer.c
new file mode 100644
index 0000000..09b236d
--- /dev/null
+++ b/drivers/iio/common/st_sensors/st_sensors_buffer.c
@@ -0,0 +1,116 @@
+/*
+ * STMicroelectronics sensors buffer library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+#include <linux/interrupt.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/irqreturn.h>
+
+#include <linux/iio/common/st_sensors.h>
+
+
+int st_sensors_get_buffer_element(struct iio_dev *indio_dev, u8 *buf)
+{
+	int i, n = 0, len;
+	u8 addr[ST_SENSORS_NUMBER_DATA_CHANNELS];
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	for (i = 0; i < ST_SENSORS_NUMBER_DATA_CHANNELS; i++) {
+		if (test_bit(i, indio_dev->active_scan_mask)) {
+			addr[n] = indio_dev->channels[i].address;
+			n++;
+		}
+	}
+	switch (n) {
+	case 1:
+		len = sdata->tf->read_multiple_byte(&sdata->tb, sdata->dev,
+			addr[0], ST_SENSORS_BYTE_FOR_CHANNEL, buf,
+			sdata->multiread_bit);
+		break;
+	case 2:
+		if ((addr[1] - addr[0]) == ST_SENSORS_BYTE_FOR_CHANNEL) {
+			len = sdata->tf->read_multiple_byte(&sdata->tb,
+					sdata->dev, addr[0],
+					ST_SENSORS_BYTE_FOR_CHANNEL*n,
+					buf, sdata->multiread_bit);
+		} else {
+			u8 rx_array[ST_SENSORS_BYTE_FOR_CHANNEL*
+				    ST_SENSORS_NUMBER_DATA_CHANNELS];
+			len = sdata->tf->read_multiple_byte(&sdata->tb,
+				sdata->dev, addr[0],
+				ST_SENSORS_BYTE_FOR_CHANNEL*
+				ST_SENSORS_NUMBER_DATA_CHANNELS,
+				rx_array, sdata->multiread_bit);
+			if (len < 0)
+				goto read_data_channels_error;
+
+			for (i = 0; i < n * ST_SENSORS_NUMBER_DATA_CHANNELS;
+									i++) {
+				if (i < n)
+					buf[i] = rx_array[i];
+				else
+					buf[i] = rx_array[n + i];
+			}
+			len = ST_SENSORS_BYTE_FOR_CHANNEL*n;
+		}
+		break;
+	case 3:
+		len = sdata->tf->read_multiple_byte(&sdata->tb, sdata->dev,
+			addr[0], ST_SENSORS_BYTE_FOR_CHANNEL*
+			ST_SENSORS_NUMBER_DATA_CHANNELS,
+			buf, sdata->multiread_bit);
+		break;
+	default:
+		len = -EINVAL;
+		goto read_data_channels_error;
+	}
+	if (len != ST_SENSORS_BYTE_FOR_CHANNEL*n) {
+		len = -EIO;
+		goto read_data_channels_error;
+	}
+
+read_data_channels_error:
+	return len;
+}
+EXPORT_SYMBOL(st_sensors_get_buffer_element);
+
+irqreturn_t st_sensors_trigger_handler(int irq, void *p)
+{
+	int len;
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	len = st_sensors_get_buffer_element(indio_dev, sdata->buffer_data);
+	if (len < 0)
+		goto st_sensors_get_buffer_element_error;
+
+	if (indio_dev->scan_timestamp)
+		*(s64 *)((u8 *)sdata->buffer_data +
+				ALIGN(len, sizeof(s64))) = pf->timestamp;
+
+	iio_push_to_buffers(indio_dev, sdata->buffer_data);
+
+st_sensors_get_buffer_element_error:
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(st_sensors_trigger_handler);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ST-sensors buffer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c
new file mode 100644
index 0000000..9873869
--- /dev/null
+++ b/drivers/iio/common/st_sensors/st_sensors_core.c
@@ -0,0 +1,435 @@
+/*
+ * STMicroelectronics sensors core library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <asm/unaligned.h>
+
+#include <linux/iio/common/st_sensors.h>
+
+
+#define ST_SENSORS_WAI_ADDRESS		0x0f
+
+int st_sensors_write_data_with_mask(struct iio_dev *indio_dev,
+						u8 reg_addr, u8 mask, u8 data)
+{
+	int err;
+	u8 new_data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev, reg_addr, &new_data);
+	if (err < 0)
+		goto st_sensors_write_data_with_mask_error;
+
+	new_data = ((new_data & (~mask)) | ((data << __ffs(mask)) & mask));
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev, reg_addr, new_data);
+
+st_sensors_write_data_with_mask_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_write_data_with_mask);
+
+static int st_sensors_match_odr(struct st_sensors *sensor,
+			unsigned int odr, struct st_sensor_odr_avl *odr_out)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {
+		if (sensor->odr.odr_avl[i].hz == 0)
+			goto st_sensors_match_odr_error;
+
+		if (sensor->odr.odr_avl[i].hz == odr) {
+			odr_out->hz = sensor->odr.odr_avl[i].hz;
+			odr_out->value = sensor->odr.odr_avl[i].value;
+			ret = 0;
+			break;
+		}
+	}
+
+st_sensors_match_odr_error:
+	return ret;
+}
+
+int st_sensors_set_odr(struct iio_dev *indio_dev, unsigned int odr)
+{
+	int err;
+	struct st_sensor_odr_avl odr_out = {0, 0};
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = st_sensors_match_odr(sdata->sensor, odr, &odr_out);
+	if (err < 0)
+		goto st_sensors_match_odr_error;
+
+	if ((sdata->sensor->odr.addr == sdata->sensor->pw.addr) &&
+			(sdata->sensor->odr.mask == sdata->sensor->pw.mask)) {
+		if (sdata->enabled == true) {
+			err = st_sensors_write_data_with_mask(indio_dev,
+				sdata->sensor->odr.addr,
+				sdata->sensor->odr.mask,
+				odr_out.value);
+		} else {
+			err = 0;
+		}
+	} else {
+		err = st_sensors_write_data_with_mask(indio_dev,
+			sdata->sensor->odr.addr, sdata->sensor->odr.mask,
+			odr_out.value);
+	}
+	if (err >= 0)
+		sdata->odr = odr_out.hz;
+
+st_sensors_match_odr_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_set_odr);
+
+static int st_sensors_match_fs(struct st_sensors *sensor,
+					unsigned int fs, int *index_fs_avl)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {
+		if (sensor->fs.fs_avl[i].num == 0)
+			goto st_sensors_match_odr_error;
+
+		if (sensor->fs.fs_avl[i].num == fs) {
+			*index_fs_avl = i;
+			ret = 0;
+			break;
+		}
+	}
+
+st_sensors_match_odr_error:
+	return ret;
+}
+
+static int st_sensors_set_fullscale(struct iio_dev *indio_dev, unsigned int fs)
+{
+	int err, i = 0;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = st_sensors_match_fs(sdata->sensor, fs, &i);
+	if (err < 0)
+		goto st_accel_set_fullscale_error;
+
+	err = st_sensors_write_data_with_mask(indio_dev,
+				sdata->sensor->fs.addr,
+				sdata->sensor->fs.mask,
+				sdata->sensor->fs.fs_avl[i].value);
+	if (err < 0)
+		goto st_accel_set_fullscale_error;
+
+	sdata->current_fullscale = (struct st_sensor_fullscale_avl *)
+						&sdata->sensor->fs.fs_avl[i];
+	return err;
+
+st_accel_set_fullscale_error:
+	dev_err(&indio_dev->dev, "failed to set new fullscale.\n");
+	return err;
+}
+
+int st_sensors_set_enable(struct iio_dev *indio_dev, bool enable)
+{
+	u8 tmp_value;
+	int err = -EINVAL;
+	bool found = false;
+	struct st_sensor_odr_avl odr_out = {0, 0};
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (enable) {
+		tmp_value = sdata->sensor->pw.value_on;
+		if ((sdata->sensor->odr.addr == sdata->sensor->pw.addr) &&
+			(sdata->sensor->odr.mask == sdata->sensor->pw.mask)) {
+			err = st_sensors_match_odr(sdata->sensor,
+							sdata->odr, &odr_out);
+			if (err < 0)
+				goto set_enable_error;
+			tmp_value = odr_out.value;
+			found = true;
+		}
+		err = st_sensors_write_data_with_mask(indio_dev,
+				sdata->sensor->pw.addr,
+				sdata->sensor->pw.mask, tmp_value);
+		if (err < 0)
+			goto set_enable_error;
+
+		sdata->enabled = true;
+
+		if (found)
+			sdata->odr = odr_out.hz;
+	} else {
+		err = st_sensors_write_data_with_mask(indio_dev,
+				sdata->sensor->pw.addr,
+				sdata->sensor->pw.mask,
+				sdata->sensor->pw.value_off);
+		if (err < 0)
+			goto set_enable_error;
+
+		sdata->enabled = false;
+	}
+
+set_enable_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_set_enable);
+
+int st_sensors_set_axis_enable(struct iio_dev *indio_dev, u8 axis_enable)
+{
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	return st_sensors_write_data_with_mask(indio_dev,
+				sdata->sensor->enable_axis.addr,
+				sdata->sensor->enable_axis.mask, axis_enable);
+}
+EXPORT_SYMBOL(st_sensors_set_axis_enable);
+
+int st_sensors_init_sensor(struct iio_dev *indio_dev)
+{
+	int err;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_init(&sdata->tb.buf_lock);
+
+	err = st_sensors_set_enable(indio_dev, true);
+	if (err < 0)
+		goto init_error;
+
+	err = st_sensors_set_fullscale(indio_dev,
+						sdata->current_fullscale->num);
+	if (err < 0)
+		goto init_error;
+
+	err = st_sensors_set_odr(indio_dev, sdata->odr);
+	if (err < 0)
+		goto init_error;
+
+	/* set BDU */
+	err = st_sensors_write_data_with_mask(indio_dev,
+			sdata->sensor->bdu.addr, sdata->sensor->bdu.mask, true);
+	if (err < 0)
+		goto init_error;
+
+	err = st_sensors_set_axis_enable(indio_dev, ST_SENSORS_ENABLE_ALL_AXIS);
+
+init_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_init_sensor);
+
+int st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable)
+{
+	int err;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	/* Enable/Disable the interrupt generator 1. */
+	if (sdata->sensor->drdy_irq.ig1.en_addr > 0) {
+		err = st_sensors_write_data_with_mask(indio_dev,
+			sdata->sensor->drdy_irq.ig1.en_addr,
+			sdata->sensor->drdy_irq.ig1.en_mask, (int)enable);
+		if (err < 0)
+			goto st_accel_set_dataready_irq_error;
+	}
+
+	/* Enable/Disable the interrupt generator for data ready. */
+	err = st_sensors_write_data_with_mask(indio_dev,
+			sdata->sensor->drdy_irq.addr,
+			sdata->sensor->drdy_irq.mask, (int)enable);
+
+st_accel_set_dataready_irq_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_set_dataready_irq);
+
+int st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale)
+{
+	int err = -EINVAL, i;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	for (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {
+		if ((sdata->sensor->fs.fs_avl[i].gain == scale) &&
+				(sdata->sensor->fs.fs_avl[i].gain != 0)) {
+			err = 0;
+			break;
+		}
+	}
+	if (err < 0)
+		goto st_sensors_match_scale_error;
+
+	err = st_sensors_set_fullscale(indio_dev,
+					sdata->sensor->fs.fs_avl[i].num);
+
+st_sensors_match_scale_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_set_fullscale_by_gain);
+
+static int st_sensors_read_axis_data(struct iio_dev *indio_dev,
+							u8 ch_addr, int *data)
+{
+	int err;
+	u8 outdata[ST_SENSORS_BYTE_FOR_CHANNEL];
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_multiple_byte(&sdata->tb, sdata->dev,
+				ch_addr, ST_SENSORS_BYTE_FOR_CHANNEL,
+				outdata, sdata->multiread_bit);
+	if (err < 0)
+		goto read_error;
+
+	*data = (s16)get_unaligned_le16(outdata);
+
+read_error:
+	return err;
+}
+
+int st_sensors_read_info_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch, int *val)
+{
+	int err;
+
+	mutex_lock(&indio_dev->mlock);
+	err = st_sensors_read_axis_data(indio_dev, ch->address, val);
+	if (err < 0)
+		goto read_error;
+
+	*val = *val >> ch->scan_type.shift;
+	mutex_unlock(&indio_dev->mlock);
+
+	return err;
+
+read_error:
+	mutex_unlock(&indio_dev->mlock);
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_read_info_raw);
+
+int st_sensors_check_device_support(struct iio_dev *indio_dev,
+			int num_sensors_list, const struct st_sensors *sensors)
+{
+	u8 wai;
+	int i, n, err;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					ST_SENSORS_DEFAULT_WAI_ADDRESS, &wai);
+	if (err < 0) {
+		dev_err(&indio_dev->dev, "failed to read Who-Am-I register.\n");
+		goto read_wai_error;
+	}
+
+	for (i = 0; i < num_sensors_list; i++) {
+		if (sensors[i].wai == wai)
+			break;
+	}
+	if (i == num_sensors_list)
+		goto device_not_supported;
+
+	for (n = 0; n < ARRAY_SIZE(sensors[i].sensors_supported); n++) {
+		if (strcmp(indio_dev->name,
+				&sensors[i].sensors_supported[n][0]) == 0)
+			break;
+	}
+	if (n == ARRAY_SIZE(sensors[i].sensors_supported)) {
+		dev_err(&indio_dev->dev, "device name and WhoAmI mismatch.\n");
+		goto sensor_name_mismatch;
+	}
+
+	sdata->sensor = (struct st_sensors *)&sensors[i];
+
+	return i;
+
+device_not_supported:
+	dev_err(&indio_dev->dev, "device not supported: WhoAmI (0x%x).\n", wai);
+sensor_name_mismatch:
+	err = -ENODEV;
+read_wai_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_check_device_support);
+
+ssize_t st_sensors_sysfs_get_sampling_frequency(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct st_sensor_data *adata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", adata->odr);
+}
+EXPORT_SYMBOL(st_sensors_sysfs_get_sampling_frequency);
+
+ssize_t st_sensors_sysfs_set_sampling_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	unsigned int odr;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		goto conversion_error;
+
+	mutex_lock(&indio_dev->mlock);
+	err = st_sensors_set_odr(indio_dev, odr);
+	mutex_unlock(&indio_dev->mlock);
+
+conversion_error:
+	return err < 0 ? err : size;
+}
+EXPORT_SYMBOL(st_sensors_sysfs_set_sampling_frequency);
+
+ssize_t st_sensors_sysfs_sampling_frequency_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	for (i = 0; i < ST_SENSORS_ODR_LIST_MAX; i++) {
+		if (sdata->sensor->odr.odr_avl[i].hz == 0)
+			break;
+
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+					sdata->sensor->odr.odr_avl[i].hz);
+	}
+	mutex_unlock(&indio_dev->mlock);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+EXPORT_SYMBOL(st_sensors_sysfs_sampling_frequency_avail);
+
+ssize_t st_sensors_sysfs_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	for (i = 0; i < ST_SENSORS_FULLSCALE_AVL_MAX; i++) {
+		if (sdata->sensor->fs.fs_avl[i].num == 0)
+			break;
+
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+					sdata->sensor->fs.fs_avl[i].gain);
+	}
+	mutex_unlock(&indio_dev->mlock);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+EXPORT_SYMBOL(st_sensors_sysfs_scale_avail);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ST-sensors core");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/common/st_sensors/st_sensors_i2c.c b/drivers/iio/common/st_sensors/st_sensors_i2c.c
new file mode 100644
index 0000000..f8e82c5
--- /dev/null
+++ b/drivers/iio/common/st_sensors/st_sensors_i2c.c
@@ -0,0 +1,80 @@
+/*
+ * STMicroelectronics sensors i2c library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/iio/iio.h>
+
+#include <linux/iio/common/st_sensors_i2c.h>
+
+#define ST_SENSORS_I2C_MULTIREAD	0x80
+
+static unsigned int st_sensors_i2c_get_irq(struct iio_dev *indio_dev)
+{
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	return to_i2c_client(sdata->dev)->irq;
+}
+
+static int st_sensors_i2c_read_byte(struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 *res_byte)
+{
+	int err;
+
+	err = i2c_smbus_read_byte_data(to_i2c_client(dev), reg_addr);
+	if (err < 0)
+		goto st_accel_i2c_read_byte_error;
+
+	*res_byte = err & 0xff;
+
+st_accel_i2c_read_byte_error:
+	return err < 0 ? err : 0;
+}
+
+static int st_sensors_i2c_read_multiple_byte(
+		struct st_sensor_transfer_buffer *tb, struct device *dev,
+			u8 reg_addr, int len, u8 *data, bool multiread_bit)
+{
+	if (multiread_bit)
+		reg_addr |= ST_SENSORS_I2C_MULTIREAD;
+
+	return i2c_smbus_read_i2c_block_data(to_i2c_client(dev),
+							reg_addr, len, data);
+}
+
+static int st_sensors_i2c_write_byte(struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 data)
+{
+	return i2c_smbus_write_byte_data(to_i2c_client(dev), reg_addr, data);
+}
+
+static const struct st_sensor_transfer_function st_sensors_tf_i2c = {
+	.read_byte = st_sensors_i2c_read_byte,
+	.write_byte = st_sensors_i2c_write_byte,
+	.read_multiple_byte = st_sensors_i2c_read_multiple_byte,
+};
+
+void st_sensors_i2c_configure(struct iio_dev *indio_dev,
+		struct i2c_client *client, struct st_sensor_data *sdata)
+{
+	i2c_set_clientdata(client, indio_dev);
+
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = client->name;
+
+	sdata->tf = &st_sensors_tf_i2c;
+	sdata->get_irq_data_ready = st_sensors_i2c_get_irq;
+}
+EXPORT_SYMBOL(st_sensors_i2c_configure);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ST-sensors i2c driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/common/st_sensors/st_sensors_spi.c b/drivers/iio/common/st_sensors/st_sensors_spi.c
new file mode 100644
index 0000000..f0aa2f1
--- /dev/null
+++ b/drivers/iio/common/st_sensors/st_sensors_spi.c
@@ -0,0 +1,128 @@
+/*
+ * STMicroelectronics sensors spi library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/iio/iio.h>
+
+#include <linux/iio/common/st_sensors_spi.h>
+
+
+#define ST_SENSORS_SPI_MULTIREAD	0xc0
+#define ST_SENSORS_SPI_READ		0x80
+
+static unsigned int st_sensors_spi_get_irq(struct iio_dev *indio_dev)
+{
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	return to_spi_device(sdata->dev)->irq;
+}
+
+static int st_sensors_spi_read(struct st_sensor_transfer_buffer *tb,
+	struct device *dev, u8 reg_addr, int len, u8 *data, bool multiread_bit)
+{
+	struct spi_message msg;
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = tb->tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = tb->rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&tb->buf_lock);
+	if ((multiread_bit) && (len > 1))
+		tb->tx_buf[0] = reg_addr | ST_SENSORS_SPI_MULTIREAD;
+	else
+		tb->tx_buf[0] = reg_addr | ST_SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, tb->rx_buf, len*sizeof(u8));
+	mutex_unlock(&tb->buf_lock);
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&tb->buf_lock);
+	return err;
+}
+
+static int st_sensors_spi_read_byte(struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 *res_byte)
+{
+	return st_sensors_spi_read(tb, dev, reg_addr, 1, res_byte, false);
+}
+
+static int st_sensors_spi_read_multiple_byte(
+	struct st_sensor_transfer_buffer *tb, struct device *dev,
+			u8 reg_addr, int len, u8 *data, bool multiread_bit)
+{
+	return st_sensors_spi_read(tb, dev, reg_addr, len, data, multiread_bit);
+}
+
+static int st_sensors_spi_write_byte(struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 data)
+{
+	struct spi_message msg;
+	int err;
+
+	struct spi_transfer xfers = {
+		.tx_buf = tb->tx_buf,
+		.bits_per_word = 8,
+		.len = 2,
+	};
+
+	mutex_lock(&tb->buf_lock);
+	tb->tx_buf[0] = reg_addr;
+	tb->tx_buf[1] = data;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(dev), &msg);
+	mutex_unlock(&tb->buf_lock);
+
+	return err;
+}
+
+static const struct st_sensor_transfer_function st_sensors_tf_spi = {
+	.read_byte = st_sensors_spi_read_byte,
+	.write_byte = st_sensors_spi_write_byte,
+	.read_multiple_byte = st_sensors_spi_read_multiple_byte,
+};
+
+void st_sensors_spi_configure(struct iio_dev *indio_dev,
+			struct spi_device *spi, struct st_sensor_data *sdata)
+{
+	spi_set_drvdata(spi, indio_dev);
+
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = spi->modalias;
+
+	sdata->tf = &st_sensors_tf_spi;
+	sdata->get_irq_data_ready = st_sensors_spi_get_irq;
+}
+EXPORT_SYMBOL(st_sensors_spi_configure);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ST-sensors spi driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/common/st_sensors/st_sensors_trigger.c b/drivers/iio/common/st_sensors/st_sensors_trigger.c
new file mode 100644
index 0000000..8b4dd48
--- /dev/null
+++ b/drivers/iio/common/st_sensors/st_sensors_trigger.c
@@ -0,0 +1,78 @@
+/*
+ * STMicroelectronics sensors trigger library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+#include <linux/interrupt.h>
+
+#include <linux/iio/common/st_sensors.h>
+
+
+int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
+				const struct iio_trigger_ops *trigger_ops)
+{
+	int err;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	sdata->trig = iio_trigger_alloc("%s-trigger", indio_dev->name);
+	if (sdata->trig == NULL) {
+		err = -ENOMEM;
+		dev_err(&indio_dev->dev, "failed to allocate iio trigger.\n");
+		goto iio_trigger_alloc_error;
+	}
+
+	err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
+			iio_trigger_generic_data_rdy_poll,
+			NULL,
+			IRQF_SHARED | /* sharing with the accelerometer events*/
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			sdata->trig->name,
+			sdata->trig);
+	if (err)
+		goto request_irq_error;
+
+	sdata->trig->private_data = indio_dev;
+	sdata->trig->ops = trigger_ops;
+	sdata->trig->dev.parent = sdata->dev;
+
+	err = iio_trigger_register(sdata->trig);
+	if (err < 0) {
+		dev_err(&indio_dev->dev, "failed to register iio trigger.\n");
+		goto iio_trigger_register_error;
+	}
+	indio_dev->trig = sdata->trig;
+
+	return 0;
+
+iio_trigger_register_error:
+	free_irq(sdata->get_irq_data_ready(indio_dev), sdata->trig);
+request_irq_error:
+	iio_trigger_free(sdata->trig);
+iio_trigger_alloc_error:
+	return err;
+}
+EXPORT_SYMBOL(st_sensors_allocate_trigger);
+
+void st_sensors_deallocate_trigger(struct iio_dev *indio_dev)
+{
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	iio_trigger_unregister(sdata->trig);
+	free_irq(sdata->get_irq_data_ready(indio_dev), sdata->trig);
+	iio_trigger_free(sdata->trig);
+}
+EXPORT_SYMBOL(st_sensors_deallocate_trigger);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics ST-sensors trigger");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 7c3a556..05d1209 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -750,7 +750,7 @@ config CY8C9540A
 
 config INTEL_CLN_GIP
 	tristate "Intel Clanton GIP"
-	depends on PCI && X86 && INTEL_CLN_SOC
+	depends on PCI && X86 && INTEL_QUARK_X1000_SOC
 	depends on I2C
 	select GENERIC_IRQ_CHIP
 	help
@@ -763,7 +763,7 @@ config INTEL_CLN_GIP
 config INTEL_CLN_GIP_TEST
 	tristate "Intel Clanton GIP support for Integration Testing"
 	depends on INTEL_CLN_GIP
-	depends on INTEL_CLN_SOC_FPGAEMU || INTEL_CLN_SOC_SVP
+	depends on INTEL_QUARK_X1000_SOC_FPGAEMU || INTEL_QUARK_X1000_SOC_SVP
 	select I2C_CHARDEV
 	select GPIO_SYSFS
 	select SPI
diff --git a/drivers/mfd/cy8c9540a.c b/drivers/mfd/cy8c9540a.c
index 42af10b..9d83e32 100644
--- a/drivers/mfd/cy8c9540a.c
+++ b/drivers/mfd/cy8c9540a.c
@@ -25,6 +25,7 @@
  * Based on gpio-adp5588.
  */
 
+#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
@@ -43,6 +44,8 @@
 #define DEVID_FAMILY_CY8C9540A		0x40
 #define DEVID_FAMILY_MASK		0xf0
 #define NPORTS				6
+#define I2C_A0_ADDR_MASK		0x0001
+#define POR_SETTINGS_LEN		147
 
 /* Register offset  */
 #define REG_INPUT_PORT0			0x00
@@ -59,6 +62,50 @@
 #define REG_PWM_PULSE_W			0x2b
 #define REG_ENABLE			0x2d
 #define REG_DEVID_STAT			0x2e
+#define REG_CMD				0x30
+
+/* Commands */
+#define CMD_W_EEPROM_POR		0x03
+#define CMD_R_EEPROM_POR		0x04
+#define CMD_RECONF_DEV			0x07
+
+/* Galileo-specific POR default settings */
+#define POR_CMD_W_OFFS			2
+static u8 por_default[POR_SETTINGS_LEN + POR_CMD_W_OFFS] = {
+	REG_CMD, CMD_W_EEPROM_POR,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* Output */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* Interrupt mask */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* PWM */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Inversion */
+	0xe0, 0xe0, 0xff, 0xf3, 0x00, 0xff, 0xff, 0xff, /* Direction */
+	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* Port0 drive mode */
+	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* Port1 drive mode */
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Port2 drive mode */
+	0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,	/* Port3 drive mode */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,	/* Port4 drive mode */
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Port5 drive mode */
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Port6 drive mode */
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Port7 drive mode */
+	0x00, 0xff, 0x00,				/* PWM0 */
+	0x00, 0xff, 0x00,				/* PWM1 */
+	0x00, 0xff, 0x00,				/* PWM2 */
+	0x00, 0xff, 0x00,				/* PWM3 */
+	0x00, 0xff, 0x00,				/* PWM4 */
+	0x00, 0xff, 0x00,				/* PWM5 */
+	0x00, 0xff, 0x00,				/* PWM6 */
+	0x00, 0xff, 0x00,				/* PWM7 */
+	0x00, 0xff, 0x00,				/* PWM8 */
+	0x00, 0xff, 0x00,				/* PWM9 */
+	0x00, 0xff, 0x00,				/* PWM10 */
+	0x00, 0xff, 0x00,				/* PWM11 */
+	0x00, 0xff, 0x00,				/* PWM12 */
+	0x00, 0xff, 0x00,				/* PWM13 */
+	0x00, 0xff, 0x00,				/* PWM14 */
+	0x00, 0xff, 0x00,				/* PWM15 */
+	0xff,						/* PWM CLK divider */
+	0x02,						/* EEPROM enable */
+	0x00						/* CRC (placeholder) */
+};
 
 struct cy8c9540a {
 	struct i2c_client *client;
@@ -73,6 +120,10 @@ struct cy8c9540a {
 	u8 irq_mask_cache[NPORTS];
 	/* IRQ mask to be applied */
 	u8 irq_mask[NPORTS];
+	/* Descriptor for raw i2c transactions */
+	struct i2c_msg i2c_segments[2];
+	/* POR settings stored in the EEPROM */
+	u8 por_stored[POR_SETTINGS_LEN];
 };
 
 /* Per-port GPIO offset */
@@ -93,6 +144,7 @@ static const u8 cy8c9540a_port_offs[] = {
 #define PWM_CLK				0x00	/* see resulting PWM_TCLK_NS */
 #define PWM_TCLK_NS			31250	/* 32kHz */
 #define SOC_GPIO_INT_PIN		13
+#define SOC_GPIO_I2C_A0			7
 
 /* PWM-to-GPIO mapping (0 == first Cypress GPIO).  */
 #define PWM_UNUSED			-1
@@ -239,8 +291,10 @@ static int cy8c9540a_gpio_direction(struct gpio_chip *chip, unsigned gpio,
 	struct i2c_client *client = dev->client;
 	u8 port = cypress_get_port(gpio);
 
-	if (out) {
-		cy8c9540a_gpio_set_value(chip, gpio, val);
+	ret = cy8c9540a_gpio_set_drive(chip, gpio, out ?
+				       GPIOF_DRIVE_STRONG : GPIOF_DRIVE_HIZ);
+	if (ret) {
+		return ret;
 	}
 
 	mutex_lock(&dev->lock);
@@ -570,7 +624,7 @@ static int cy8c9540a_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 
 	/* Set pin as output driving high */
 	ret = cy8c9540a_gpio_direction(&dev->gpio_chip, gpio, 1, 1);
-	if (val < 0) {
+	if (ret < 0) {
 		dev_err(&client->dev, "can't set pwm%u as output\n", pwm->pwm);
 		return ret;
 	}
@@ -671,6 +725,89 @@ static const struct pwm_ops cy8c9540a_pwm_ops = {
 };
 
 /*
+ * cy8c9540a_set_por_default
+ *
+ * Ensure the expander is using platform-specific POR settings.
+ *
+ * Note SMBUS max transaction length is 32 bytes, so we have to fall back to
+ * raw i2c transfers.
+ */
+static int cy8c9540a_set_por_default(struct cy8c9540a *dev)
+{
+	int ret = 0;
+	struct i2c_client *client = dev->client;
+	int i = 0;
+	int segments = -1;
+	int crc_index = sizeof(por_default) - 1;
+	u8 reg_cmd_r_por[] = { REG_CMD, CMD_R_EEPROM_POR };
+
+	/* Read POR settings stored in EEPROM */
+	dev->i2c_segments[0].addr	= client->addr;
+	dev->i2c_segments[0].flags	= 0;	/* write */
+	dev->i2c_segments[0].len	= sizeof(reg_cmd_r_por);
+	dev->i2c_segments[0].buf	= reg_cmd_r_por;
+	dev->i2c_segments[1].addr	= client->addr;
+	dev->i2c_segments[1].flags	= I2C_M_RD;
+	dev->i2c_segments[1].len	= sizeof(dev->por_stored);
+	dev->i2c_segments[1].buf	= dev->por_stored;
+	segments = 2;
+	ret = i2c_transfer(client->adapter, dev->i2c_segments, segments);
+	if (segments != ret) {
+		dev_err(&client->dev, "can't read POR settings (ret=%d)\n", ret);
+		goto end;
+	} else {
+		ret = 0; 
+	}
+
+	/* Compute CRC for platform-defined POR settings */
+	por_default[crc_index] = 0;
+	for (i = POR_CMD_W_OFFS; i < crc_index; i ++) {
+		por_default[crc_index] ^= por_default[i];
+	}
+
+	/* Compare POR settings with platform-defined ones */
+	for (i = 0; i < sizeof(dev->por_stored); i ++) {
+		if (dev->por_stored[i] != por_default[i + POR_CMD_W_OFFS]) {
+			break;
+		}
+	}
+	if (sizeof(dev->por_stored) == i) {
+		goto end;
+	}
+
+	/* Update POR settings to EEPROM */
+
+	dev_info(&client->dev, "updating EEPROM with platform POR settings\n");
+
+	/* Store default POR settings into EEPROM */
+	dev->i2c_segments[0].addr	= client->addr;
+	dev->i2c_segments[0].flags	= 0;	/* write */
+	dev->i2c_segments[0].len	= sizeof(por_default);
+	dev->i2c_segments[0].buf	= por_default;
+	segments = 1;
+	ret = i2c_transfer(client->adapter, dev->i2c_segments, segments);
+	if (segments != ret) {
+		dev_err(&client->dev, "can't write POR settings (ret=%d)\n", ret);
+		goto end;
+	} else {
+		ret = 0; 
+	}
+
+	/* Let EEPROM terminate its last page write.  200ms as per datasheet. */
+	mdelay(200);
+
+	/* Reconfigure device with newly stored POR settings */
+	ret = i2c_smbus_write_byte_data(client, REG_CMD, CMD_RECONF_DEV);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't reconfigure device\n");
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+/*
  * cy8c9540a_setup
  *
  * Initialise the device with default setup.
@@ -680,28 +817,13 @@ static int cy8c9540a_setup(struct cy8c9540a *dev)
 {
 	int ret = 0;
 	struct i2c_client *client = dev->client;
-	int i = 0;
 	const u8 eeprom_enable_seq[] = {0x43, 0x4D, 0x53, 0x2};
 
-	/* Disable PWM, set all GPIOs as input.  */
-	for (i = 0; i < NPORTS; i ++) {
-		ret = i2c_smbus_write_byte_data(client, REG_PORT_SELECT, i);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't select port %u\n", i);
-			goto end;
-		}
-
-		ret = i2c_smbus_write_byte_data(client, REG_SELECT_PWM, 0x00);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't write to SELECT_PWM\n");
-			goto end;
-		}
-
-		ret = i2c_smbus_write_byte_data(client, REG_PIN_DIR, 0xff);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't write to PIN_DIR\n");
-			goto end;
-		}
+	/* Test/set platform-specific POR settings */
+	ret = cy8c9540a_set_por_default(dev);
+	if (ret) {
+		dev_err(&client->dev, "can't set POR settings (err=%d)\n", ret);
+		goto end;
 	}
 
 	/* Cache the output registers */
@@ -713,21 +835,6 @@ static int cy8c9540a_setup(struct cy8c9540a *dev)
 		goto end;
 	}
 
-	/* Set default PWM clock source.  */
-	for (i = 0; i < NPWM; i ++) {
-		ret = i2c_smbus_write_byte_data(client, REG_PWM_SELECT, i);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't select pwm %u\n", i);
-			goto end;
-		}
-
-		ret = i2c_smbus_write_byte_data(client, REG_PWM_CLK, PWM_CLK);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't write to REG_PWM_CLK\n");
-			goto end;
-		}
-	}
-
 	/* Enable the EEPROM */
 	ret = i2c_smbus_write_i2c_block_data(client, REG_ENABLE,
 					     sizeof(eeprom_enable_seq),
@@ -749,17 +856,40 @@ static int cy8c9540a_probe(struct i2c_client *client,
 	int ret = 0;
 	s32 dev_id = 0;
 
+	ret = gpio_request(SOC_GPIO_I2C_A0, "cy8c9540a-addr0");
+	if (ret) {
+		pr_err("%s: failed to request gpio%u\n", __func__,
+			SOC_GPIO_I2C_A0);
+		return ret;
+	}
+
+	/*
+	 * Galileo uses A0 Extendable Soft Addressing pin on the Cypress part.
+	 * The inverted value of A0 is exposed to a SoC GPIO.
+	 *
+	 * Work out the I2C address of the device based on A0.
+	 */
+	if (gpio_get_value(SOC_GPIO_I2C_A0)) {
+		client->addr &= ~I2C_A0_ADDR_MASK;
+	} else {
+		client->addr |= I2C_A0_ADDR_MASK;
+	}
+
 	if (!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C |
 					I2C_FUNC_SMBUS_I2C_BLOCK |
 					I2C_FUNC_SMBUS_BYTE_DATA)) {
-		dev_err(&client->dev, "SMBUS Byte/Block unsupported\n");
-		return -EIO;
+		dev_err(&client->dev, "i2c adapter doesn't support required "
+			"functionality\n");
+		ret = -EIO;
+		goto err_i2c_addr;
 	}
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (dev == NULL) {
 		dev_err(&client->dev, "failed to alloc memory\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_i2c_addr;
 	}
 
 	dev->client = client;
@@ -825,6 +955,7 @@ static int cy8c9540a_probe(struct i2c_client *client,
 	i2c_set_clientdata(client, dev);
 
 	return 0;
+
 err_gpiochip:
 	if(gpiochip_remove(&dev->gpio_chip))
 		dev_warn(&client->dev, "gpiochip_remove failed\n");
@@ -833,6 +964,8 @@ err_irq:
 err:
 	mutex_destroy(&dev->lock);
 	kfree(dev);
+err_i2c_addr:
+	gpio_free(SOC_GPIO_I2C_A0);
 
 	return ret;
 }
@@ -860,6 +993,8 @@ static int cy8c9540a_remove(struct i2c_client *client)
 	mutex_destroy(&dev->lock);
 	kfree(dev);
 
+	gpio_free(SOC_GPIO_I2C_A0);
+
 	return err;
 }
 
diff --git a/drivers/mfd/intel_cln_gip_gpio.c b/drivers/mfd/intel_cln_gip_gpio.c
index 15d4058..6e2bbbf 100644
--- a/drivers/mfd/intel_cln_gip_gpio.c
+++ b/drivers/mfd/intel_cln_gip_gpio.c
@@ -589,8 +589,9 @@ int intel_cln_gpio_probe(struct pci_dev *pdev)
 		goto err_free_irq_descs;
 
 	pr_info("%s UIO addr 0x%08x internal_addr 0x%08x size %lu memtype %d\n",
-		__func__, info->mem[0].addr, info->mem[0].internal_addr,
-		info->mem[0].size, info->mem[0].memtype);
+		__func__, (unsigned int)info->mem[0].addr,
+		(unsigned int)info->mem[0].internal_addr, info->mem[0].size,
+		info->mem[0].memtype);
 	igc->chip_types->chip.irq_mask = intel_cln_gpio_irq_mask;
 	igc->chip_types->chip.irq_unmask = intel_cln_gpio_irq_unmask;
 	igc->chip_types->chip.irq_set_type = intel_cln_gpio_irq_type;
diff --git a/drivers/mfd/intel_cln_gip_i2c.c b/drivers/mfd/intel_cln_gip_i2c.c
index f2fa6a5..3675e50 100644
--- a/drivers/mfd/intel_cln_gip_i2c.c
+++ b/drivers/mfd/intel_cln_gip_i2c.c
@@ -53,7 +53,7 @@ static struct dw_pci_controller cln_gip_i2c_controller = {
 	.tx_fifo_depth	= 16,
 	.rx_fifo_depth	= 16,
 	.clk_khz	=
-#ifdef CONFIG_INTEL_CLN_SOC_FPGAEMU
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
 			14000,
 #else
 			33000,
diff --git a/drivers/mfd/intel_cln_gip_test.c b/drivers/mfd/intel_cln_gip_test.c
index 61e2059..ea8d846 100644
--- a/drivers/mfd/intel_cln_gip_test.c
+++ b/drivers/mfd/intel_cln_gip_test.c
@@ -23,6 +23,7 @@
  * Clanton GIP + North-Cluster GPIO test module.
  */
 
+#include <asm/tsc.h>
 #include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -38,7 +39,6 @@
 #include <linux/spi/spi_gpio.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
-#include <asm/tsc.h>
 
 #define DRIVER_NAME			"intel_cln_gip_test"
 
diff --git a/drivers/mfd/lpc_sch.c b/drivers/mfd/lpc_sch.c
index 3ddbf70..d9a230d 100644
--- a/drivers/mfd/lpc_sch.c
+++ b/drivers/mfd/lpc_sch.c
@@ -68,7 +68,7 @@ static struct platform_device lpc_sch_spi = {
 };
 
 static struct mfd_cell lpc_sch_cells[] = {
-#ifndef CONFIG_INTEL_CLN_SOC
+#ifndef CONFIG_INTEL_QUARK_X1000_SOC
 	{
 		.name = "isch_smbus",
 		.num_resources = 1,
diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 5051bba..bf1a620 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -32,7 +32,7 @@
 #include <linux/init.h>
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 #define STMMAC_VLAN_TAG_USED
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
 #define STMMAC_VLAN_HASH
 #endif
 #include <linux/if_vlan.h>
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
index 34a0afc..a0c08e1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
@@ -59,7 +59,7 @@ static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb,
 	 * DMA transfers the data in 8, 16, 32, 64, 128 & 256 beats
 	 * depending on pbl value.
 	 */
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	value = DMA_BUS_MODE_RIX | (pbl << DMA_BUS_MODE_PBL_SHIFT);
 #else
 	value = DMA_BUS_MODE_PBL | ((pbl << DMA_BUS_MODE_PBL_SHIFT) |
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 325aaa1..7119a9b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -28,7 +28,7 @@
 	https://bugzilla.stlinux.com/
 *******************************************************************************/
 
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
 #include <asm/cln.h>
 #endif
 #include <linux/clk.h>
@@ -1546,7 +1546,7 @@ static netdev_features_t stmmac_fix_features(struct net_device *dev,
 	return features;
 }
 
-#if defined(CONFIG_INTEL_CLN_SOC)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
 	#define mask_pvm(x) cln_pci_pvm_mask(x)
 	#define unmask_pvm(x) cln_pci_pvm_unmask(x)
 #else
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 63c6272..39f7e92 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -33,7 +33,7 @@
 #define STMMAC_CLANTON_ID 0x0937
 #define MAX_INTERFACES	 0x02
 
-#if defined (CONFIG_INTEL_CLN_SOC)
+#if defined (CONFIG_INTEL_QUARK_X1000_SOC)
 static int enable_msi = 1;
 #else
 static int enable_msi = 0;
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 822fbe3..df3d9a1 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -671,75 +671,9 @@ config INTEL_MFLD_THERMAL
          Say Y here to enable thermal driver support for the  Intel Medfield
          platform.
 
-config INTEL_CLN_ESRAM
-	bool "eSRAM - embedded SRAM driver for Intel Clanton platform"
-	depends on INTEL_CLN_SOC && PM
-	select KALLSYMS
-	select CRC16
-	help
-	  Say Y here to enable eSRAM overlay and software-initiated ECC
-	  updates. eSRAM overlaying allows for code/data structures to be
-	  mapped into eSRAM thus providing far faster access to code/data
-	  than ordinary DRAM. Slower than cache RAM faster than DRAM.
-
-config INTEL_CLN_ECC_REFRESH_PERIOD
-	int "Choose eSRAM ECC coverage period"
-	depends on INTEL_CLN_ESRAM
-	default 24
-	help
-	  Select the period over which *RAM ECC codes should be refreshed.
-	  IA Core will periodically enable disabled eSRAM pages to ensure all of
-	  disabled eSRAM pages are 'address walked' in this period. A logical
-	  component within the silicon on Clanton will ensure DRAM (and
-	  overlayed eSRAM) pages by extension are similarly updated over the
-	  same period. This variable controlls how long a time this address
-	  walking algorithm should take. For a noisy environment like a
-	  sub-station or a satellite update frequently. For less noisy
-	  environments this value should be lower. Default 24 hours is right for
-	  most people. Set to zero to disable - this is NOT recommended. Max 48
-	  hours.
-
-config INTEL_CLN_ECC_SCRUB
-	tristate "Hardware ECC Scrub - /proc interface for Intel Clanton platform"
-	depends on INTEL_CLN_SOC
-	help
-	   Say Y here to enable support for accessing the hardware memory
-	   ECC Scrubber via the /proc interface.
-
-config INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-	bool "Hardware ECC Scrub - use config settings to override scrub vals"
-	depends on INTEL_CLN_ECC_SCRUB
-	help
-	  Say Y here to enable support to use config settings to override
-	  BIOS configured scrub values
-
-config INTEL_CLN_HW_ECC_REFRESH_RATE
-	int "Choose DRAM ECC refresh rate"
-	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-	default 20
-	help
-	  Range 0 - 255 mSec
-
-config INTEL_CLN_HW_ECC_REFRESH_SIZE
-	int "Choose DRAM ECC refresh size"
-	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-	default 512
-	help
-	  Range 64-512 bytes, multiples of 32
-
-config INTEL_CLN_ECC_SCRUB_S3_CONFIG
-	bool "Hardware ECC Scrub - linux manages S3 entry/resume for scrub"
-	depends on INTEL_CLN_ECC_SCRUB
-	help
-	  Say Y here to enable linux to manage S3 entry/resume for the
-	  hardware memory ECC Scrubber.
-
-config INTEL_CLN_THERMAL
-	tristate "Thermal driver for Intel Clanton platform"
-	depends on INTEL_CLN_SOC && THERMAL
-	help
-	  Say Y here to enable Clanton's Thermal driver plus the MSI's
-	  that can be hooked from the thermal sub-system
+if INTEL_QUARK_X1000_SOC
+source "drivers/platform/x86/quark/Kconfig"
+endif
 
 config INTEL_IPS
 	tristate "Intel Intelligent Power Sharing"
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 06dd3bc..b382e65 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -36,8 +36,6 @@ obj-$(CONFIG_TOPSTAR_LAPTOP)	+= topstar-laptop.o
 obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
 
 obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
-obj-$(CONFIG_INTEL_CLN_ECC_SCRUB) += intel_cln_ecc_scrub.o
-obj-$(CONFIG_INTEL_CLN_THERMAL)	+= intel_cln_thermal.o
 obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
@@ -52,5 +50,4 @@ obj-$(CONFIG_INTEL_MID_POWER_BUTTON)	+= intel_mid_powerbtn.o
 obj-$(CONFIG_INTEL_OAKTRAIL)	+= intel_oaktrail.o
 obj-$(CONFIG_SAMSUNG_Q10)	+= samsung-q10.o
 obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
-
-obj-$(CONFIG_INTEL_CLN_SPI_UPDATE)     += intel_cln_spi_update.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)     += quark/
diff --git a/drivers/platform/x86/intel_cln_ecc_scrub.c b/drivers/platform/x86/intel_cln_ecc_scrub.c
deleted file mode 100644
index dd5b434..0000000
--- a/drivers/platform/x86/intel_cln_ecc_scrub.c
+++ /dev/null
@@ -1,766 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton DRAM ECC Scrub driver
- *
- * !!!!!!! Description
- *
- */
-#include <asm-generic/uaccess.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/proc_fs.h>
-
-#define DRIVER_NAME			"intel-cln-ecc"
-#define INTEL_CLN_ECC_SCRUB_PROCDIR	"driver/ecc_scrub"
-#define STATUS				"status"
-#define CONTROL				"control"
-#define INTERVAL			"interval"
-#define ECC_BLOCK_SIZE			"block_size"
-
-#define CONTROL_USAGE		"ECC Scrub Control: invalid setting. "\
-				"Valid values are 1 or 0\n"
-#define CONTROL_SCRUB_ON_STR	"1\n"
-#define CONTROL_SCRUB_OFF_STR	"0\n"
-#define CONTROL_ON_STR		"on\n"
-#define CONTROL_OFF_STR		"off\n"
-
-#define INTERVAL_USAGE		"ECC Scrub Interval: invalid setting. "\
-				"Valid range is 1 - 255\n"
-#define SIZE_USAGE		"ECC Scrub Block Size: invalid setting. "\
-				"Valid range is 64 - 512\n"
-
-#define OVERRIDE_CONFIG_PARM_DESC	"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Config"
-
-#define OVERRIDE_START_PARM_DESC	"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Start address"
-
-#define OVERRIDE_END_PARM_DESC		"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub End address"
-
-#define OVERRIDE_NEXT_PARM_DESC		"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Next address"
-
-#define MAX_SCRUB_BLOCK_SIZE 512
-#define MIN_SCRUB_BLOCK_SIZE 64
-#define MAX_SCRUB_REFRESH 255
-#define MIN_SCRUB_REFRESH 0
-
-#define NOT_OVERRIDDEN 0xfffffffful
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-/* Register ID */
-#define ECC_SCRUB_CONFIG_REG		(0x50)
-#define ECC_SCRUB_START_MEM_REG		(0x76)
-#define ECC_SCRUB_END_MEM_REG		(0x77)
-#define ECC_SCRUB_NEXT_READ_REG		(0x7C)
-
-
-/* Reg commands */
-#define THERMAL_CTRL_READ		(0x10)
-#define THERMAL_CTRL_WRITE		(0x11)
-#define THERMAL_RESUME_SCRUB		(0xC2)
-#define THERMAL_PAUSE_SCRUB		(0xC3)
-
-/**
- * struct intel_cln_ecc_scrub_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_ecc_scrub_dev {
-
-	/* Linux kernel structures */
-	struct platform_device *pldev;		/* Platform device */
-	struct proc_dir_entry *pdir;		/* Proc directory */
-						/* /proc/driver/ecc_scrub/ */
-	struct proc_dir_entry *pcontrol;	/* ""/control */
-	struct proc_dir_entry *pstatus;		/* ""/status */
-	struct proc_dir_entry *pinterval;	/* ""/interval */
-	struct proc_dir_entry *psize;		/* ""/block_size */
-
-	/* Register copies */
-	u32 start_address;
-	u32 end_address;
-	u32 next_address;
-	u32 config;
-
-};
-
-static struct intel_cln_ecc_scrub_dev ecc_scrub_dev;
-
-static u32 ecc_scrub_config_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_start_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_end_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_next_override = NOT_OVERRIDDEN;
-
-#ifdef CONFIG_PROC_FS
-
-
-/**
- * intel_cln_ecc_scrub_stat_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /proc/driver/ecc_scrub/status
- */
-static int intel_cln_ecc_scrub_stat_read(char *page, char **start,
-					off_t off, int count,
-					int *eof, void *data)
-
-{
-	int len = 0, size = 0;
-	u32 reg_data = 0;
-	char *scrub_status = CONTROL_OFF_STR;
-
-	/* Display start of memory address */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
-		&reg_data, 1);
-	len += snprintf(page + len, count - len,
-			"ecc scrub mem start\t\t\t: 0x%08x\n", reg_data);
-
-
-	/* Display end of memory address */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
-		&reg_data, 1);
-	len += snprintf(page + len, count - len,
-			"ecc scrub mem end\t\t\t: 0x%08x\n", reg_data);
-
-	/* Display next address to be read */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
-		&reg_data, 1);
-	len += snprintf(page + len, count - len,
-			"ecc scrub next read\t\t\t: 0x%08x\n", reg_data);
-
-	/* Display config settings */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-
-	/* Interval is the lsbyte of the config reg, so mask out just
-	 * that byte in the data printed. */
-	len += snprintf(page + len, count - len,
-			"ecc scrub interval\t\t\t: %d\n",
-			(reg_data & 0x000000ff));
-
-	/* Size is indicated in bits 12:8 of register in
-	* terms of 32 byte blocks. */
-	size = ((reg_data & 0x00001f00) >> 8)*32;
-	len += snprintf(page + len, count - len,
-			"ecc scrub block_size\t\t\t: %d\n", size);
-
-	/* Status is indicated in bit 13 of register. */
-	if ((reg_data & 0x00002000) > 0)
-		scrub_status = CONTROL_ON_STR;
-
-	len += snprintf(page + len, count - len,
-			"ecc scrub status\t\t\t: %s\n", scrub_status);
-	*eof = 1;
-
-	return len;
-}
-
-/**
- * intel_cln_ecc_scrub_ctrl_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /proc/driver/ecc_scrub/control
- */
-static int intel_cln_ecc_scrub_ctrl_read(char *page, char **start,
-						 off_t off, int count,
-						 int *eof, void *data)
-
-{
-	int len = 0;
-	u32 reg_data = 0;
-	char *on_or_off = CONTROL_SCRUB_OFF_STR;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-	&reg_data, 1);
-
-	/* Status is indicated in bit 13 of register. */
-	if ((reg_data & 0x00002000) > 0)
-		/* interval > 0 assume scrubbing on */
-		on_or_off = CONTROL_SCRUB_ON_STR;
-
-	len += snprintf(page + len, count - len,
-			"%s", on_or_off);
-	*eof = 1;
-
-	return len;
-}
-
-/**
- * intel_cln_ecc_scrub_ctrl_write
- *
- * @param file: File pointer
- * @param buf: Data being sent from user-space
- * @param count: Number of bytes being sent
- * @param data: Statically set data in the /proc callback - unused
- * @return number of bytes successfully written or < 0 to indicate error
- *
- * Function allows user-space to switch on/off scrubbing with a simple
- * echo 1/0 > /proc/driver/ecc_scrub/control command
- */
-static int
-intel_cln_ecc_scrub_ctrl_write(struct file *file, const char __user *buf,
-			       unsigned long count, void *data)
-{
-	ssize_t ret = 0;
-	char *cbuf = NULL;
-
-	if (count <= 1)
-		return -EINVAL;
-
-
-	/* Get input */
-	cbuf = kzalloc(count+1, GFP_KERNEL);
-	if (cbuf == NULL)
-		return -ENOMEM;
-
-	ret = -EFAULT;
-	if (!copy_from_user(cbuf, buf, count)) {
-		ret = -EINVAL;
-
-		/* Check for command starting with "scrub"
-		*  and ending with "on" or "off" */
-
-		if (!strcmp(cbuf, CONTROL_SCRUB_ON_STR)) {
-				sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB,
-				0, 0, 1);
-				ret = 0;
-		} else if (!strcmp(cbuf, CONTROL_SCRUB_OFF_STR)) {
-			sb_write(SB_ID_THERMAL, THERMAL_PAUSE_SCRUB, 0,
-				 0, 1);
-			ret = 0;
-		}
-	}
-
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-
-	else if (ret == -EINVAL)
-		printk(CONTROL_USAGE);
-
-	kfree(cbuf);
-	return ret;
-}
-
-/**
- * intel_cln_ecc_scrub_intrvl_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /proc/driver/ecc_scrub/interval
- */
-static int intel_cln_ecc_scrub_intrvl_read(char *page, char **start,
-						 off_t off,
-						 int count, int *eof,
-						 void *data)
-
-{
-	int len = 0;
-	u32 reg_data = 0;
-
-	/* Interval is the lsbyte of the config reg,
-	* so mask out just that byte in the data printed. */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-	len += snprintf(page + len, count - len,
-			"%d\n", (reg_data & 0x000000ff));
-	*eof = 1;
-
-	return len;
-}
-
-/**
- * intel_cln_ecc_scrub_intrvl_write
- *
- * @param file: File pointer
- * @param buf: Data being sent from user-space
- * @param count: Number of bytes being sent
- * @param data: Statically set data in the /proc callback - unused
- * @return number of bytes successfully written or < 0 to indicate error
- *
- * Function allows user-space to set scrub interval with a value of 1-255
- * echo 1-255 > /proc/driver/ecc_scrub/interval type command
- */
-static int
-intel_cln_ecc_scrub_intrvl_write(struct file *file, const char __user *buf,
-			       unsigned long count, void *data)
-{
-	ssize_t ret = 0;
-	char *cbuf = NULL;
-	unsigned long val = 0;
-	u32 reg_data = 0;
-	int ret_temp = 0;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	/* Get input */
-	cbuf = kzalloc(count+1, GFP_KERNEL);
-	if (cbuf == NULL)
-		return -ENOMEM;
-
-	ret = -EFAULT;
-	if (!copy_from_user(cbuf, buf, count)) {
-		ret = -EINVAL;
-
-		ret_temp = kstrtoul(cbuf, 10, &val);
-
-		if (ret_temp)
-			return ret_temp;
-
-		if (val > MIN_SCRUB_REFRESH && val <= MAX_SCRUB_REFRESH) {
-			/* Need to read-modify-write config register. */
-			sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
-				ECC_SCRUB_CONFIG_REG,
-				&reg_data, 1);
-
-			reg_data &= 0xffffff00;	/* clear lsb. */
-			reg_data |= val;		/* now set interval. */
-
-			sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-				 ECC_SCRUB_CONFIG_REG,
-				 reg_data, 1);
-			ret = 0;
-		} else {
-			printk(INTERVAL_USAGE);
-		}
-
-	}
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-	kfree(cbuf);
-	return ret;
-}
-
-/**
- * intel_cln_ecc_scrub_size_read
- *
- * @param page: buffer to write data into
- * @param start: where the data has been written in the page
- * @param offset: same meaning as read system call
- * @param count: same meaning as read system call
- * @param eof: set if no more data needs to be returned
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /proc/driver/ecc_scrub/block_size
- */
-static int intel_cln_ecc_scrub_size_read(char *page, char **start,
-					off_t off,
-					int count, int *eof,
-					void *data)
-
-{
-	int len = 0;
-	int size = 0;
-	u32 reg_data = 0;
-
-	/* Size is indicated in bits 12:8 of config register
-	 * multiply x32 to get num bytes). */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-	size = ((reg_data & 0x00001f00) >> 8)*32;
-
-	len += snprintf(page + len, count - len,
-			"%d\n", size);
-	*eof = 1;
-
-	return len;
-}
-
-/**
- * intel_cln_ecc_scrub_size_write
- *
- * @param file: File pointer
- * @param buf: Data being sent from user-space
- * @param count: Number of bytes being sent
- * @param data: Statically set data in the /proc callback - unused
- * @return number of bytes successfully written or < 0 to indicate error
- *
- * Function allows user-space to set scrub block size of 64-512 with a simple
- * echo 64-512 > /proc/driver/ecc_scrub/block_size command
- */
-static int
-intel_cln_ecc_scrub_size_write(struct file *file, const char __user *buf,
-				unsigned long count, void *data)
-{
-	ssize_t ret = 0;
-	char *cbuf = NULL;
-	unsigned long val = 0;
-	u32 reg_data = 0;
-	int ret_temp = 0;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	/* Get input */
-	cbuf = kzalloc(count+1, GFP_KERNEL);
-	if (cbuf == NULL)
-		return -ENOMEM;
-
-	ret = -EFAULT;
-	if (!copy_from_user(cbuf, buf, count)) {
-		ret = -EINVAL;
-
-		ret_temp = kstrtoul(cbuf, 10, &val);
-
-		if (ret_temp)
-			return ret_temp;
-
-		if (val >= MIN_SCRUB_BLOCK_SIZE
-		   && val <= MAX_SCRUB_BLOCK_SIZE){
-			/* Need to read-modify-write config register. */
-			sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
-				ECC_SCRUB_CONFIG_REG,
-				&reg_data, 1);
-
-			reg_data &= 0xfffffe0ff;	/* clear bits 12:8 */
-			reg_data |= (val/32)<<8;	/* now set size */
-
-			sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-				 ECC_SCRUB_CONFIG_REG,
-				 reg_data, 1);
-			ret = 0;
-		} else {
-			printk(SIZE_USAGE);
-		}
-
-	}
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-	kfree(cbuf);
-	return ret;
-}
-
-/**
- * intel_cln_ecc_scrub_addfs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Adds entries to procfs
- */
-static int intel_cln_ecc_scrub_add(void)
-{
-	ecc_scrub_dev.pdir = proc_mkdir(INTEL_CLN_ECC_SCRUB_PROCDIR, NULL);
-	if (ecc_scrub_dev.pdir == NULL)
-		return -ENOMEM;
-
-
-	ecc_scrub_dev.pstatus = create_proc_read_entry(STATUS, 0,
-						 ecc_scrub_dev.pdir,
-						 intel_cln_ecc_scrub_stat_read,
-						 NULL);
-	if (ecc_scrub_dev.pstatus == NULL)
-		return -EIO;
-
-	ecc_scrub_dev.pcontrol = create_proc_entry(CONTROL, 0,
-						   ecc_scrub_dev.pdir);
-	if (ecc_scrub_dev.pcontrol == NULL)
-		return -EIO;
-
-	ecc_scrub_dev.pcontrol->read_proc = intel_cln_ecc_scrub_ctrl_read;
-	ecc_scrub_dev.pcontrol->write_proc = intel_cln_ecc_scrub_ctrl_write;
-	ecc_scrub_dev.pcontrol->data = NULL;
-
-	ecc_scrub_dev.pinterval = create_proc_entry(INTERVAL, 0,
-						    ecc_scrub_dev.pdir);
-	if (ecc_scrub_dev.pinterval == NULL)
-		return -EIO;
-
-	ecc_scrub_dev.pinterval->read_proc = intel_cln_ecc_scrub_intrvl_read;
-	ecc_scrub_dev.pinterval->write_proc = intel_cln_ecc_scrub_intrvl_write;
-	ecc_scrub_dev.pinterval->data = NULL;
-
-	ecc_scrub_dev.psize = create_proc_entry(ECC_BLOCK_SIZE, 0,
-						ecc_scrub_dev.pdir);
-	if (ecc_scrub_dev.psize == NULL)
-		return -EIO;
-
-	ecc_scrub_dev.psize->read_proc = intel_cln_ecc_scrub_size_read;
-	ecc_scrub_dev.psize->write_proc = intel_cln_ecc_scrub_size_write;
-	ecc_scrub_dev.psize->data = NULL;
-
-	return 0;
-}
-
-/**
- * intel_cln_ecc_scrub_proc_remove
- *
- * @return nothing
- *
- * Removes /proc entires
- */
-static void intel_cln_ecc_scrub_proc_remove(void)
-{
-	remove_proc_entry(CONTROL, ecc_scrub_dev.pcontrol);
-	remove_proc_entry(INTERVAL, ecc_scrub_dev.pinterval);
-	remove_proc_entry(ECC_BLOCK_SIZE, ecc_scrub_dev.pinterval);
-	remove_proc_entry(STATUS, ecc_scrub_dev.pstatus);
-	remove_proc_entry(INTEL_CLN_ECC_SCRUB_PROCDIR, NULL);
-}
-
-#else
-
-static int intel_cln_ecc_scrub_add(void){ return 0; }
-static void intel_cln_ecc_scrub_remove(void){ return; }
-
-#endif /* CONFIG_PROC_FS */
-
-/*****************************************************************************
- *                        Module/PowerManagement hooks
- *****************************************************************************/
-/**
- * intel_cln_ecc_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- */
-static int intel_cln_ecc_scrub_probe(struct platform_device *pdev)
-{
-	int value_overridden = 0;
-
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-	u32 scrubber_refresh = 0;
-	u32 scrubber_block_size = 0;
-	u32 config_settings = 0;
-#endif
-
-	memset(&ecc_scrub_dev, 0x00, sizeof(ecc_scrub_dev));
-
-	/* Update config settings, if directed so to do */
-	if (ecc_scrub_start_override != NOT_OVERRIDDEN) {
-		/* start of memory address */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_START_MEM_REG, ecc_scrub_start_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_end_override != NOT_OVERRIDDEN) {
-		/* end of memory address */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_END_MEM_REG, ecc_scrub_end_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_next_override != NOT_OVERRIDDEN) {
-		/* next address to be read */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_NEXT_READ_REG, ecc_scrub_next_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_config_override != NOT_OVERRIDDEN) {
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG, ecc_scrub_config_override, 1);
-
-			value_overridden = 1;
-	}
-
-	/* Config Reg can be updated by either command line or kconfig setting
-	 * in the case where we have both the command line takes precedence.*/
-
-	else {
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-		scrubber_refresh = CONFIG_INTEL_CLN_HW_ECC_REFRESH_RATE;
-		scrubber_block_size = CONFIG_INTEL_CLN_HW_ECC_REFRESH_SIZE;
-
-		if (scrubber_block_size > MAX_SCRUB_BLOCK_SIZE)
-			scrubber_block_size = MAX_SCRUB_BLOCK_SIZE;
-
-		else if (scrubber_block_size < MIN_SCRUB_BLOCK_SIZE)
-			scrubber_block_size = MIN_SCRUB_BLOCK_SIZE;
-
-		if (scrubber_refresh > MAX_SCRUB_REFRESH)
-			scrubber_refresh = MAX_SCRUB_REFRESH;
-
-
-		/* adjust block size to multiples of 32 -
-		 * as that is what the register setting actually expects. */
-		config_settings = scrubber_block_size/32;
-		config_settings <<= 8;
-		config_settings += scrubber_refresh;
-
-		/* config settings */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG, config_settings, 1);
-
-		value_overridden = 1;
-#endif
-	}
-
-	if (value_overridden)
-		sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
-
-	return intel_cln_ecc_scrub_add();
-}
-
-/**
- * intel_cln_ecc_scrub_suspend
- *
- * @param pdev: Platform device structure (unused)
- * @return 0 success < 0 failure
- *
- */
-static int intel_cln_ecc_scrub_suspend(struct device *pdev)
-{
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
-	u32 reg_data = 0;
-
-	/* Store off the 4 registers associated with scrubbing. */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.start_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.end_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.next_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.config = reg_data;
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_ecc_scrub_resume
- *
- * @param pdev: Platform device structure (unused)
- * @return 0 success < 0 failure
- */
-static int intel_cln_ecc_scrub_resume(struct device *pdev)
-{
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_START_MEM_REG,
-		 ecc_scrub_dev.start_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_END_MEM_REG,
-		 ecc_scrub_dev.end_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_NEXT_READ_REG,
-		 ecc_scrub_dev.next_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_CONFIG_REG,
-		 ecc_scrub_dev.config, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
-
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_ecc_scrub_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_ecc_scrub_remove(struct platform_device *pdev)
-{
-	intel_cln_ecc_scrub_proc_remove();
-
-	return 0;
-}
-
-/*
- * Power management operations
- */
-static const struct dev_pm_ops intel_cln_ecc_scrub_pm_ops = {
-	.suspend = intel_cln_ecc_scrub_suspend,
-	.resume = intel_cln_ecc_scrub_resume,
-};
-
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_ecc_scrub_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-		.pm = &intel_cln_ecc_scrub_pm_ops,
-	},
-	.probe = intel_cln_ecc_scrub_probe,
-	.remove = intel_cln_ecc_scrub_remove,
-};
-
-
-MODULE_AUTHOR("Derek Harnett <derek.harnett@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton DRAM ECC-scrub driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_param(ecc_scrub_config_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_config_override, OVERRIDE_CONFIG_PARM_DESC);
-
-module_param(ecc_scrub_start_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_start_override, OVERRIDE_START_PARM_DESC);
-
-module_param(ecc_scrub_end_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_end_override, OVERRIDE_END_PARM_DESC);
-
-module_param(ecc_scrub_next_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_next_override, OVERRIDE_NEXT_PARM_DESC);
-
-module_platform_driver(intel_cln_ecc_scrub_driver);
-
diff --git a/drivers/platform/x86/intel_cln_thermal.c b/drivers/platform/x86/intel_cln_thermal.c
deleted file mode 100644
index ce0da9cd..0000000
--- a/drivers/platform/x86/intel_cln_thermal.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Thermal driver
- */
-#include <linux/err.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/thermal.h>
-#include <linux/timer.h>
-
-#define DRIVER_NAME		"intel-cln-thrm"
-
-/* Definition of register locations for thermal management */
-#define THRM_CTRL_REG		(0x80)		/* Thermal control */
-#define THRM_MODE_REG		(0xB0)		/* Thermal mode */
-#define THRM_MODE_SENSOR_EN	(0x00008000)	/* Thermal mode sensor enable */
-#define THRM_TEMP_REG		(0xB1)		/* Thermal sensor temperature */
-#define THRM_TRPCLR_REG		(0xB2)		/* Catastropic/Hot trip/clear */
-#define THRM_AUXTRP_REG		(0xB3)		/* Aux0-Aux3 trip point */
-#define THRM_AUXCLR_REG		(0xB4)		/* Aux0-Aux3 clear trip */
-#define THRM_STATUS_REG		(0xB5)		/* Thermal sensor status */
-#define THRM_TRIPBEHAVE_REG	(0xB6)		/* Trip point behavior */
-#define THRM_MSIADDR_REG	(0xC5)		/* Thermal MSI addres reg */
-#define THRM_MSIDATA_REG	(0xC6)		/* Thermal MSI data reg */
-#define THRM_CTRL_READ		(0x10)		/* Config reg */
-#define THRM_CTRL_WRITE		(0x11)		/* Config reg */
-
-#define SOC_TSENSOR_REG		(0x34)
-#define SOC_TSENSOR_RST		(0x00000001)
-#define SOC_CTRL_READ		(0x06)
-#define SOC_CTRL_WRITE		(0x07)
-
-
-#define THRM_ZONE_COUNT		2		/* Only hot/critical relevant */
-#define ACTIVE_INTERVAL		(1000)
-#define IDLE_INTERVAL		(20000)
-#define MCELSIUS(x)		((x) * 1000)
-
-/* CPU Zone information */
-#define CATASTROPIC_ZONE	0
-#define HOT_ZONE		1
-#define AUX0_ZONE		2		/* Unused */
-#define AUX1_ZONE		3		/* Unused */
-#define AUX2_ZONE		4		/* Unused */
-#define AUX3_ZONE		5		/* Unused */
-#define MIN_USED_ZONE		CATASTROPIC_ZONE
-#define MAX_USED_ZONE		HOT_ZONE
-/*
- * Default catastrophic/hot trip values - in degrees celsius
- * Maximum temperature is 105 degrees
- */
-#define CRIT_TEMP	104
-#define HOT_TEMP	95
-#define RAW2CELSIUS_DIFF	50
-
-static int driver_enable = 1;
-module_param(driver_enable, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(driver_enable, "Disable Thermal Driver Polling");
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-struct intel_cln_therm_zone {
-	enum thermal_trip_type type;
-	int trip_value;
-};
-
-/**
- * struct intel_cln_thermal_dev
- *
- */
-struct intel_cln_thermal_dev {
-	enum thermal_device_mode mode;
-	struct intel_cln_therm_zone tzone[THRM_ZONE_COUNT];
-	struct mutex lock;
-	struct platform_device *pldev;		/* Platform device */
-	struct thermal_zone_device *therm_dev;	/* Thermal device */
-};
-
-static struct intel_cln_thermal_dev cln_tdev;
-
-/******************************************************************************
- *                        Thermal API implementation
- ******************************************************************************/
-
-/**
- * get_temp
- *
- * @param tz: Thermal zone descriptor
- *
- * Get the current temperature
- * We have exactly one thermal zone/sensor
- * Value passed is an unsigned long - our sensor reports up to -50 celsius so we
- * just clip at zero if the temperature is negative.
- */
-static int intel_cln_thermal_get_temp(struct thermal_zone_device *tz,
-				unsigned long *temp)
-{
-	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TEMP_REG, (u32 *)temp, 1);
-	*temp -= RAW2CELSIUS_DIFF;
-
-	/* Clip to unsigned output value if sensor is reporting sub-zero */
-	if ((int)*temp < 0)
-		*temp = 0;
-
-	*temp = MCELSIUS(*temp&0x000000FF);
-
-	return 0;
-}
-
-/**
- * get_trend
- *
- * Wears good clothes
- */
-static int intel_cln_thermal_get_trend(struct thermal_zone_device *tz,
-			int trip, enum thermal_trend *trend)
-{
-	if (tz->temperature >= trip)
-		*trend = THERMAL_TREND_RAISING;
-	else
-		*trend = THERMAL_TREND_DROPPING;
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_mode
- *
- * Get the mode
- */
-static int intel_cln_thermal_get_mode(struct thermal_zone_device *tz,
-				enum thermal_device_mode *mode)
-{
-	mutex_lock(&cln_tdev.lock);
-	*mode = cln_tdev.mode;
-	mutex_unlock(&cln_tdev.lock);
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_set_mode
- *
- * Set the mode
- */
-static int intel_cln_thermal_set_mode(struct thermal_zone_device *tz,
-				enum thermal_device_mode mode)
-{
-	mutex_lock(&cln_tdev.lock);
-
-	if (mode == THERMAL_DEVICE_ENABLED)
-		cln_tdev.therm_dev->polling_delay = IDLE_INTERVAL;
-	else
-		cln_tdev.therm_dev->polling_delay = 0;
-	cln_tdev.mode = mode;
-
-	mutex_unlock(&cln_tdev.lock);
-
-	thermal_zone_device_update(cln_tdev.therm_dev);
-	pr_info("thermal polling set for duration=%d msec\n",
-				cln_tdev.therm_dev->polling_delay);
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_type
- *
- * Get trip type
- */
-static int intel_cln_thermal_get_trip_type(struct thermal_zone_device *tz,
-				int trip, enum thermal_trip_type *type)
-{
-	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
-		return -EINVAL;
-
-	*type = cln_tdev.tzone[trip].type;
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_temp
- *
- * Get trip temp
- */
-static int intel_cln_thermal_get_trip_temp(struct thermal_zone_device *tz,
-				int trip, unsigned long *temp)
-{
-	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
-		return -EINVAL;
-
-	/* Convert the temperature into millicelsius */
-	*temp = cln_tdev.tzone[trip].trip_value;
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_type
- *
- * Get trip temp
- */
-static int intel_cln_thermal_get_crit_temp(struct thermal_zone_device *tz,
-				unsigned long *temp)
-{
-	/* Critical zone */
-	*temp = cln_tdev.tzone[CATASTROPIC_ZONE].trip_value;
-	return 0;
-}
-
-static struct thermal_zone_device_ops intel_cln_thrm_dev_ops = {
-	.get_temp = intel_cln_thermal_get_temp,
-	.get_trend = intel_cln_thermal_get_trend,
-	.get_mode = intel_cln_thermal_get_mode,
-	.set_mode = intel_cln_thermal_set_mode,
-	.get_trip_type = intel_cln_thermal_get_trip_type,
-	.get_trip_temp = intel_cln_thermal_get_trip_temp,
-	.get_crit_temp = intel_cln_thermal_get_crit_temp,
-};
-
-
-
-/**
- * intel_cln_init_zone
- *
- * Initialise a zone
- */
-static void intel_cln_thermal_init_zone(struct intel_cln_therm_zone *tz,
-				enum thermal_trip_type type, int trip_value)
-{
-	tz->type = type;
-	tz->trip_value = MCELSIUS(trip_value);
-}
-
-/******************************************************************************
- *                        Module Entry/Exit hooks
- ******************************************************************************/
-
-/**
- * intel_cln_thermal_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This routine registers a thermal device with the kernel's thermal management
- * sub-system
- */
-static int intel_cln_thermal_probe(struct platform_device *pdev)
-{
-	int err = 0;
-	int critical_temp = 0, hot_temp = 0;
-	uint32_t regval = 0;
-
-	if (driver_enable == 0)
-		return 0;
-
-	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
-
-	critical_temp = CRIT_TEMP;
-	hot_temp = HOT_TEMP;
-
-	/* Enumerate zone type data */
-	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
-	mutex_init(&cln_tdev.lock);
-
-	/* Set initial state disabled */
-	cln_tdev.mode = THERMAL_DEVICE_ENABLED;
-
-	intel_cln_thermal_init_zone(&cln_tdev.tzone[CATASTROPIC_ZONE],
-				  THERMAL_TRIP_CRITICAL, critical_temp);
-	intel_cln_thermal_init_zone(&cln_tdev.tzone[HOT_ZONE],
-				  THERMAL_TRIP_HOT, hot_temp);
-
-	/* Register a thermal zone */
-	cln_tdev.therm_dev = thermal_zone_device_register(DRIVER_NAME,
-			THRM_ZONE_COUNT, 0, 0, &intel_cln_thrm_dev_ops,
-			0, IDLE_INTERVAL, ACTIVE_INTERVAL);
-
-	if (IS_ERR(cln_tdev.therm_dev)) {
-		err = PTR_ERR(cln_tdev.therm_dev);
-		return err;
-	}
-
-	/* Read the BIOS configured hardware catastrophic trip temp */
-	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TRPCLR_REG, &regval, 1);
-	regval = (regval & 0xff) - 50;
-
-	pr_info("THRM: critical reset %d c hot %d c hardware failover %d c\n",
-		critical_temp, hot_temp, regval);
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_thermal_remove(struct platform_device *pdev)
-{
-	if (cln_tdev.therm_dev != NULL) {
-		thermal_zone_device_unregister(cln_tdev.therm_dev);
-		return 0;
-	}
-	return -EINVAL;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_thermal_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.probe = intel_cln_thermal_probe,
-	.remove = intel_cln_thermal_remove,
-};
-
-module_platform_driver(intel_cln_thermal_driver);
-
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton Thermal driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/Kconfig b/drivers/platform/x86/quark/Kconfig
new file mode 100644
index 0000000..5d47629
--- /dev/null
+++ b/drivers/platform/x86/quark/Kconfig
@@ -0,0 +1,75 @@
+config INTEL_CLN_ESRAM
+	bool "eSRAM - embedded SRAM driver for Intel Clanton platform"
+	depends on INTEL_QUARK_X1000_SOC && PM
+	select KALLSYMS
+	select CRC16
+	help
+	  Say Y here to enable eSRAM overlay and software-initiated ECC
+	  updates. eSRAM overlaying allows for code/data structures to be
+	  mapped into eSRAM thus providing far faster access to code/data
+	  than ordinary DRAM. Slower than cache RAM faster than DRAM.
+
+config INTEL_CLN_ECC_REFRESH_PERIOD
+	int "Choose eSRAM ECC coverage period"
+	depends on INTEL_CLN_ESRAM
+	default 24
+	help
+	  Select the period over which *RAM ECC codes should be refreshed.
+	  IA Core will periodically enable disabled eSRAM pages to ensure all of
+	  disabled eSRAM pages are 'address walked' in this period. A logical
+	  component within the silicon on Clanton will ensure DRAM (and
+	  overlayed eSRAM) pages by extension are similarly updated over the
+	  same period. This variable controlls how long a time this address
+	  walking algorithm should take. For a noisy environment like a
+	  sub-station or a satellite update frequently. For less noisy
+	  environments this value should be lower. Default 24 hours is right for
+	  most people. Set to zero to disable - this is NOT recommended. Max 48
+	  hours.
+
+config INTEL_CLN_ECC_SCRUB
+	bool "Hardware ECC Scrub - /proc interface for Intel Clanton platform"
+	depends on INTEL_QUARK_X1000_SOC
+	help
+	   Say Y here to enable support for accessing the hardware memory
+	   ECC Scrubber via the /proc interface.
+
+config INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	bool "Hardware ECC Scrub - use config settings to override scrub vals"
+	depends on INTEL_CLN_ECC_SCRUB
+	help
+	  Say Y here to enable support to use config settings to override
+	  BIOS configured scrub values
+
+config INTEL_CLN_HW_ECC_REFRESH_RATE
+	int "Choose DRAM ECC refresh rate"
+	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	default 20
+	help
+	  Range 0 - 255 mSec
+
+config INTEL_CLN_HW_ECC_REFRESH_SIZE
+	int "Choose DRAM ECC refresh size"
+	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	default 512
+	help
+	  Range 64-512 bytes, multiples of 32
+
+config INTEL_CLN_ECC_SCRUB_S3_CONFIG
+	bool "Hardware ECC Scrub - linux manages S3 entry/resume for scrub"
+	depends on INTEL_CLN_ECC_SCRUB
+	help
+	  Say Y here to enable linux to manage S3 entry/resume for the
+	  hardware memory ECC Scrubber.
+
+config INTEL_CLN_THERMAL
+	bool "Thermal driver for Intel Clanton platform"
+	depends on INTEL_QUARK_X1000_SOC
+	help
+	  Say Y here to enable Clanton's Thermal driver plus the MSI's
+	  that can be hooked from the thermal sub-system
+
+config INTEL_CLN_AUDIO_CTRL
+	tristate "Audio sub-system control driver for Intel Clanton platform"
+	depends on INTEL_QUARK_X1000_SOC
+	help
+	  Say Y here to enable Clanton's audio control driver
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
new file mode 100644
index 0000000..00c4ce7
--- /dev/null
+++ b/drivers/platform/x86/quark/Makefile
@@ -0,0 +1,18 @@
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_board_data.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_layout_data.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_data.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_clanton_hill.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_clanton_peak.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_cross_hill.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_kips_bay.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_galileo.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_sb.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr_kernel.o
+obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr_test.o
+obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram_test.o
+#obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_smep_test.o
+obj-$(CONFIG_INTEL_CLN_ECC_SCRUB) += intel_cln_ecc_scrub.o
+obj-$(CONFIG_INTEL_CLN_THERMAL)	+= intel_cln_thermal.o
+obj-$(CONFIG_INTEL_CLN_AUDIO_CTRL) += intel_cln_audio_ctrl.o
diff --git a/drivers/platform/x86/quark/intel_cln_audio_ctrl.c b/drivers/platform/x86/quark/intel_cln_audio_ctrl.c
new file mode 100644
index 0000000..95bfe78
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_audio_ctrl.c
@@ -0,0 +1,514 @@
+/*
+ * Intel Clanton platform audio control driver
+ *
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * The Intel Clanton Hill platform hardware design includes an audio subsystem
+ * with a number of interconnected audio interfaces.  This driver enables
+ * applications to choose which audio connections to enable for various
+ * application use cases.  The interconnections are selectable using GPIO output
+ * pins on the CPU.  This driver is also responsible for configuring a Maxim
+ * 9867 audio codec, a component of this audio subsystem, connected to the CPU
+ * via I2C.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <uapi/linux/ioctl.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+
+#include "intel_cln_audio_ctrl.h"
+
+#define DRIVER_NAME			"intel_cln_audio_ctrl"
+
+/*
+ * GPIO numbers to use for switching audio paths
+ */
+#define GPIO_AUDIO_S0   11
+#define GPIO_AUDIO_S1   12
+#define GPIO_AUDIO_S2   13
+
+#define GPIO_AUDIO_DEFAULT (INTEL_CLN_AUDIO_MODE_SPKR_MIC)
+
+/**
+ * struct intel_cln_audio_ctrl_data
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_audio_ctrl_priv {
+
+	/* i2c device descriptor for read/write access to MAX9867 registers */
+	struct i2c_client *max9867_i2c;
+
+	/* Char dev to provide user-space ioctl interface for audio control */
+	struct cdev cdev;
+	dev_t cdev_no;
+	struct class *cl;
+
+	/* Mutex to protect against concurrent access to the ioctl() handler */
+	struct mutex lock;
+
+	/* Current GPIO switch value */
+	unsigned char gpio_val;
+};
+
+static int
+intel_cln_audio_ctrl_open(struct inode *inode, struct file *filp)
+{
+	struct intel_cln_audio_ctrl_priv *priv;
+
+	priv = container_of(inode->i_cdev,
+			    struct intel_cln_audio_ctrl_priv,
+			    cdev);
+	filp->private_data = priv;
+
+	return 0;
+}
+
+static int
+intel_cln_audio_ctrl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/*
+ * Logic truth table for AUDIO_S[0-3] outputs, illustrating which paths are
+ * connected between audio interfaces A, B, C.  Each audio interface has one
+ * effective input (I) port and one effective output (O) port
+ *
+ * A = USB Codec (to Clanton CPU)
+ * B = Spkr/Mic  (to car audio system)
+ * C = I2S Codec (to Telit HE910)
+ *
+ * PATH examples:
+ *   AO-CO: A-Output connected to C-Output
+ *   BI-AI: B-Input connected to A-Input
+ *
+ * NOTE: Assume a CI-AI connection is available in ALL cases (sometimes unused)
+ *
+ * S2 S1 S0  PATHS             USE CASE
+ * -- -- --  ----------------- -------------------------------------------------
+ *  0  0  0  AO-CO             BT Headset call
+ *  0  0  1  AO-BO             Analog Driver Alerts (CI unused)
+ *  0  1  0  AO-CO,BI-AI       XX Unused/invalid (BI *and* CI connected to AI)
+ *  0  1  1  AO-BO,BI-AI       Archival Voice Record/Playback (or Driver Alerts)
+ *  1  0  0  AO-CO,BI-CO       XX Unused/invalid (A0 *and* BI connected to CO)
+ *  1  0  1  AO-BO,BI-CO       Analog hands-free call
+ *  1  1  0  AO-CO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
+ *  1  1  1  AO-BO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
+ *
+ *
+ * Mapping to IOCTLs (using more intuitive naming on the API):
+ *
+ * PATHS           IOCTL
+ * --------------- -------------------------------------------------------------
+ * AO-CO           INTEL_CLN_AUDIO_MODE_GSM_ONLY
+ * AO-BO           INTEL_CLN_AUDIO_MODE_SPKR_ONLY
+ * AO-BO,BI-AI     INTEL_CLN_AUDIO_MODE_SPKR_MIC
+ * AO-BO,BI-CO     INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC
+ */
+
+static int
+intel_cln_audio_ctrl_gpio_update(struct intel_cln_audio_ctrl_priv *priv)
+{
+	int ret = 0;
+	struct gpio audio_sw_gpios[] = {
+		{
+			GPIO_AUDIO_S2,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s2"
+		},
+		{
+			GPIO_AUDIO_S1,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s1"
+		},
+		{
+			GPIO_AUDIO_S0,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s0"
+		}
+	};
+
+	/*
+	 * Update the Audio Switch GPIO outputs according to the user selection
+	 */
+	ret = gpio_request_array(audio_sw_gpios,
+				 ARRAY_SIZE(audio_sw_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate audio control GPIO pins\n",
+		       __func__);
+		return ret;
+	}
+
+	gpio_set_value(GPIO_AUDIO_S2, (priv->gpio_val >> 2) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S1, (priv->gpio_val >> 1) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S0, (priv->gpio_val >> 0) & 0x1);
+
+	gpio_free_array(audio_sw_gpios,
+			ARRAY_SIZE(audio_sw_gpios));
+
+	return 0;
+}
+
+static long
+intel_cln_audio_ctrl_ioctl(struct file *filp,
+			   unsigned int cmd,
+			   unsigned long arg)
+{
+	struct intel_cln_audio_ctrl_priv *priv = filp->private_data;
+	int ret = 0;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case INTEL_CLN_AUDIO_MODE_IOC_GSM_ONLY:
+	case INTEL_CLN_AUDIO_MODE_IOC_SPKR_ONLY:
+	case INTEL_CLN_AUDIO_MODE_IOC_SPKR_MIC:
+	case INTEL_CLN_AUDIO_MODE_IOC_GSM_SPKR_MIC:
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	priv->gpio_val = _IOC_NR(cmd) & 0x7;
+	ret = intel_cln_audio_ctrl_gpio_update(priv);
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+static const struct file_operations intel_cln_audio_ctrl_fops = {
+	.owner = THIS_MODULE,
+	.open = intel_cln_audio_ctrl_open,
+	.release = intel_cln_audio_ctrl_release,
+	.unlocked_ioctl = intel_cln_audio_ctrl_ioctl
+};
+
+static int
+intel_cln_audio_ctrl_chrdev_init(struct intel_cln_audio_ctrl_priv *priv)
+{
+	/* Register a character dev interface (with ioctls)
+	 * to allow control of the audio subsystem switch
+	 */
+	int ret;
+	struct device *dev;
+
+	ret = alloc_chrdev_region(&priv->cdev_no, 0, 1,
+				  "intel_cln_audio_ctrl");
+	if (ret) {
+		pr_err("Failed to alloc chrdev: %d", ret);
+		return ret;
+	}
+
+	cdev_init(&priv->cdev, &intel_cln_audio_ctrl_fops);
+
+	ret = cdev_add(&priv->cdev, priv->cdev_no, 1);
+	if (ret) {
+		pr_err("Failed to add cdev: %d", ret);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return ret;
+	}
+
+	priv->cl = class_create(THIS_MODULE, "char");
+	if (IS_ERR(priv->cl)) {
+		pr_err("Failed to create device class: %ld",
+		       PTR_ERR(priv->cl));
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(priv->cl);
+	}
+
+	dev = device_create(priv->cl, NULL, priv->cdev_no, NULL,
+			    "intel_cln_audio_ctrl");
+	if (IS_ERR(dev)) {
+		pr_err("Failed to create device: %ld",
+		       PTR_ERR(priv->cl));
+		class_destroy(priv->cl);
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(dev);
+	}
+
+	return 0;
+}
+
+static int
+intel_cln_audio_ctrl_chrdev_remove(struct intel_cln_audio_ctrl_priv *priv)
+{
+	device_destroy(priv->cl, priv->cdev_no);
+	class_destroy(priv->cl);
+	cdev_del(&priv->cdev);
+	unregister_chrdev_region(priv->cdev_no, 1);
+
+	return 0;
+}
+
+
+ssize_t intel_cln_audio_ctrl_sysfs_show_mode(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct intel_cln_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	int ret;
+	char *mode;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (priv->gpio_val) {
+	case INTEL_CLN_AUDIO_MODE_GSM_ONLY:
+		mode = "gsm";
+		break;
+	case INTEL_CLN_AUDIO_MODE_SPKR_ONLY:
+		mode = "spkr";
+		break;
+	case INTEL_CLN_AUDIO_MODE_SPKR_MIC:
+		mode = "spkr_mic";
+		break;
+	case INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC:
+		mode = "gsm_spkr_mic";
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = scnprintf(buf, PAGE_SIZE, "%s\n", mode);
+
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+ssize_t intel_cln_audio_ctrl_sysfs_store_mode(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t count)
+{
+	struct intel_cln_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	char mode[16];
+	unsigned char gpio_val;
+	int ret = count;
+
+	sscanf(buf, "%15s", mode);
+
+	if (!strcmp(mode, "gsm"))
+		gpio_val = INTEL_CLN_AUDIO_MODE_GSM_ONLY;
+	else if (!strcmp(mode, "spkr"))
+		gpio_val = INTEL_CLN_AUDIO_MODE_SPKR_ONLY;
+	else if (!strcmp(mode, "spkr_mic"))
+		gpio_val = INTEL_CLN_AUDIO_MODE_SPKR_MIC;
+	else if (!strcmp(mode, "gsm_spkr_mic"))
+		gpio_val = INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC;
+	else
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	priv->gpio_val = gpio_val;
+	ret = intel_cln_audio_ctrl_gpio_update(priv);
+	if (ret)
+		goto exit;
+
+	ret = count;
+
+exit:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+/* Sysfs attribute descriptor (for alternative user-space interface) */
+static DEVICE_ATTR(audio_switch_mode, S_IWUSR | S_IRUGO,
+		   intel_cln_audio_ctrl_sysfs_show_mode,
+		   intel_cln_audio_ctrl_sysfs_store_mode);
+
+/******************************************************************************
+ *                                Module hooks
+ ******************************************************************************/
+
+static int
+intel_cln_max9867_init(struct i2c_client *client)
+{
+	int ret;
+
+	/* MAX9867 register configuration, from Telit HE910 DVI app-note */
+
+	u8 reg_cfg_seq1[] = {
+		0x04, /* Starting register address, followed by data */
+		0x00, /* 0x04 Interrupt Enable */
+		0x10, /* 0x05 System Clock */
+		0x90, /* 0x06 Audio Clock High */
+		0x00, /* 0x07 Audio Clock Low */
+		0x10, /* 0x08 Interface 1a */
+		0x0A, /* 0x09 Interface 1d */
+		0x33, /* 0x0A Codec Filters */
+		0x00, /* 0x0B DAC Gain/Sidetone */
+		0x00, /* 0x0C DAC Level */
+		0x33, /* 0x0D ADC Level */
+		0x4C, /* 0x0E Left Line Input Level */
+		0x4C, /* 0x0F Right Line Input Level */
+		0x00, /* 0x10 Left Volume Control */
+		0x00, /* 0x11 Right Volume Control */
+		0x14, /* 0x12 Left Mic Gain */
+		0x14, /* 0x13 Right Mic Gain */
+		/* Configuration */
+		0xA0, /* 0x14 Input */
+		0x00, /* 0x15 Microphone */
+		0x65  /* 0x16 Mode */
+	};
+
+	u8 reg_cfg_seq2[] = {
+		0x17, /* Starting register address, followed by data */
+		0xEF  /* 0x17 System Shutdown */
+	};
+
+	ret = i2c_master_send(client,
+			      reg_cfg_seq1, sizeof(reg_cfg_seq1));
+	if (ret != sizeof(reg_cfg_seq1)) {
+		pr_err("Failed to write MAX9867 config registers (set 1/2)");
+		return -EIO;
+	}
+
+	ret = i2c_master_send(client,
+			      reg_cfg_seq2, sizeof(reg_cfg_seq2));
+	if (ret != sizeof(reg_cfg_seq2)) {
+		pr_err("Failed to write MAX9867 config registers (set 2/2)");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int
+intel_cln_max9867_get_chip_rev(struct i2c_client *client)
+{
+	struct i2c_msg msg[2];
+	u8 data[2];
+	int ret;
+
+	data[0] = 0xFF;  /* Chip-revision register address = 0xFF */
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].buf = &data[0];
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = &data[1];
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+	return (ret == 2) ? data[1] : -EIO;
+}
+
+static int intel_cln_max9867_i2c_probe(struct i2c_client *client,
+				       const struct i2c_device_id *id)
+{
+	struct intel_cln_audio_ctrl_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv),
+			    GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+
+	priv->max9867_i2c = client;
+	mutex_init(&priv->lock);
+
+	ret = intel_cln_max9867_get_chip_rev(client);
+	if (ret >= 0)
+		pr_info("%s: Detected MAX9867 chip revision 0x%02X\n",
+			__func__, ret);
+	else {
+		pr_err("%s: Failed to read MAX9867 chip revision\n", __func__);
+		goto exit;
+	}
+
+	ret = intel_cln_max9867_init(client);
+	if (ret)
+		goto exit;
+
+	priv->gpio_val = GPIO_AUDIO_DEFAULT;
+	ret = intel_cln_audio_ctrl_gpio_update(priv);
+	if (ret)
+		goto exit;
+
+	/* Create a char dev interface, providing an ioctl config option */
+	ret = intel_cln_audio_ctrl_chrdev_init(priv);
+	if (ret)
+		goto exit;
+
+	/* Also create a sysfs interface, providing a cmd line config option */
+	ret = sysfs_create_file(&client->dev.kobj,
+				&dev_attr_audio_switch_mode.attr);
+
+exit:
+	return ret;
+}
+
+static int intel_cln_max9867_i2c_remove(struct i2c_client *client)
+{
+	struct intel_cln_audio_ctrl_priv *priv = i2c_get_clientdata(client);
+
+	intel_cln_audio_ctrl_chrdev_remove(priv);
+
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_audio_switch_mode.attr);
+
+	return 0;
+}
+
+static const struct i2c_device_id intel_cln_max9867_i2c_id[] = {
+	{"intel-cln-max9867", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, intel_cln_max9867_i2c_id);
+
+/* i2c codec control layer */
+static struct i2c_driver intel_cln_audio_ctrl_i2c_driver = {
+	.driver = {
+		.name = "intel_cln_audio_ctrl",
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_cln_max9867_i2c_probe,
+	.remove =  intel_cln_max9867_i2c_remove,
+	.id_table = intel_cln_max9867_i2c_id,
+};
+
+module_i2c_driver(intel_cln_audio_ctrl_i2c_driver);
+
+MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
+MODULE_DESCRIPTION("Intel Clanton platform audio control driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/intel_cln_audio_ctrl.h b/drivers/platform/x86/quark/intel_cln_audio_ctrl.h
new file mode 100644
index 0000000..b6c4692
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_audio_ctrl.h
@@ -0,0 +1,45 @@
+/*
+ * Intel Clanton platform audio control driver
+ *
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * See intel_cln_audio_ctrl.c for a detailed description
+ *
+ */
+
+#ifndef __INTEL_CLN_AUDIO_CTRL_H__
+#define __INTEL_CLN_AUDIO_CTRL_H__
+
+#include <linux/module.h>
+
+#define INTEL_CLN_AUDIO_MODE_GSM_ONLY       0x0
+#define INTEL_CLN_AUDIO_MODE_SPKR_ONLY      0x1
+#define INTEL_CLN_AUDIO_MODE_SPKR_MIC       0x3
+#define INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC   0x5
+
+#define INTEL_CLN_AUDIO_MODE_IOC_GSM_ONLY \
+	_IO('x', INTEL_CLN_AUDIO_MODE_GSM_ONLY)
+#define INTEL_CLN_AUDIO_MODE_IOC_SPKR_ONLY \
+	_IO('x', INTEL_CLN_AUDIO_MODE_SPKR_ONLY)
+#define INTEL_CLN_AUDIO_MODE_IOC_SPKR_MIC \
+	_IO('x', INTEL_CLN_AUDIO_MODE_SPKR_MIC)
+#define INTEL_CLN_AUDIO_MODE_IOC_GSM_SPKR_MIC \
+	_IO('x', INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC)
+
+#endif /* __INTEL_CLN_AUDIO_CTRL_H__ */
diff --git a/drivers/platform/x86/quark/intel_cln_board_data.c b/drivers/platform/x86/quark/intel_cln_board_data.c
new file mode 100644
index 0000000..da226c7
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_board_data.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data accessor layer
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define DRIVER_NAME				"board_data"
+#define PFX					"MFH: "
+#define SPIFLASH_BASEADDR			0xFFF00000
+#define MFH_OFFSET				0x00008000
+#define PLATFORM_DATA_OFFSET			0x00010000
+#define MTD_PART_OFFSET				0x00050000
+#define MTD_PART_LEN				0x00040000
+#define MFH_PADDING				0x1E8
+#define MFH_MAGIC				0x5F4D4648
+#define FLASH_SIZE				0x00400000
+
+/* MFH types supported @ version #1 */
+#define MFH_ITEM_FW_STAGE1			0x00000000
+#define MFH_ITEM_FW_STAGE1_SIGNED		0x00000001
+#define MFH_ITEM_FW_STAGE2			0x00000003
+#define MFH_ITEM_FW_STAGE2_SIGNED		0x00000004
+#define MFH_ITEM_FW_STAGE2_CONFIG		0x00000005
+#define MFH_ITEM_FW_STAGE2_CONFIG_SIGNED	0x00000006
+#define MFH_ITEM_FW_PARAMS			0x00000007
+#define MFH_ITEM_FW_RECOVERY			0x00000008
+#define MFH_ITEM_FW_RECOVERY_SIGNED		0x00000009
+#define MFH_ITEM_BOOTLOADER			0x0000000B
+#define MFH_ITEM_BOOTLOADER_SIGNED		0x0000000C
+#define MFH_ITEM_BOOTLOADER_CONFIG		0x0000000D
+#define MFH_ITEM_BOOTLOADER_CONFIG_SIGNED	0x0000000E
+#define MFH_ITEM_KERNEL				0x00000010
+#define MFH_ITEM_KERNEL_SIGNED			0x00000011
+#define MFH_ITEM_RAMDISK			0x00000012
+#define MFH_ITEM_RAMDISK_SIGNED			0x00000013
+#define MFH_ITEM_LOADABLE_PROGRAM		0x00000015
+#define MFH_ITEM_LOADABLE_PROGRAM_SIGNED	0x00000016
+#define MFH_ITEM_BUILD_INFO			0x00000018
+#define MFH_ITEM_VERSION			0x00000019
+
+struct intel_cln_mfh {
+	u32	id;
+	u32	ver;
+	u32	flags;
+	u32	next_block;
+	u32	item_count;
+	u32	boot_priority_list;
+	u8	padding[MFH_PADDING];
+};
+
+struct intel_cln_mfh_item {
+	u32	type;
+	u32	addr;
+	u32	len;
+	u32	res0;
+};
+
+static struct resource conf_res __initdata = {
+	.flags		= IORESOURCE_MEM,
+	.start		= 0,
+	.end		= 0,
+};
+
+static struct resource plat_res __initdata = {
+	.flags		= IORESOURCE_MEM,
+	.start		= 0,
+	.end		= 0,
+};
+
+static struct platform_device conf_pdev = {
+	.name		= "cln-layout-conf",
+	.id		= -1,
+	.resource	= &conf_res,
+};
+
+struct kobject * board_data_kobj;
+EXPORT_SYMBOL_GPL(board_data_kobj);
+
+static bool mfh_plat_found = false;
+
+static long unsigned int flash_version_data;
+static ssize_t flash_version_show(struct kobject *kobj,
+                                struct kobj_attribute *attr, char *buf)
+{
+        return snprintf(buf, 12, "%#010lx\n", flash_version_data);
+}
+
+static struct kobj_attribute flash_version_attr =
+        __ATTR(flash_version, 0644, flash_version_show, NULL);
+
+extern int intel_cln_plat_probe(struct resource * pres);
+
+/**
+ * intel_cln_board_data_init
+ *
+ * Module entry point
+ */
+static int __init intel_cln_board_data_init(void)
+{
+	extern struct kobject * firmware_kobj;
+	struct intel_cln_mfh __iomem * mfh;
+	struct intel_cln_mfh_item __iomem * item;
+	struct platform_device * pdev;
+	u32 count;
+	void __iomem * spi_data;
+	int ret = 0;
+
+	spi_data = ioremap(SPIFLASH_BASEADDR, FLASH_SIZE);
+	if (!spi_data)
+		return -ENODEV;
+
+	/* get mfh and first item pointer */	
+	mfh = spi_data + MFH_OFFSET;
+	if (mfh->id != MFH_MAGIC){
+		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
+		MFH_MAGIC, mfh->id, &mfh->id);
+		return -ENODEV;
+	}
+
+	pr_info(PFX"mfh @ 0x%p: id 0x%08lx ver 0x%08lx entries 0x%08lx\n",
+		mfh, (unsigned long)mfh->id, (unsigned long)mfh->ver,
+		(unsigned long)mfh->item_count);
+	item = (struct intel_cln_mfh_item __iomem *)
+		&mfh->padding [sizeof(u32) * mfh->boot_priority_list];
+	
+	/* board_data_kobj subordinate of firmware @ /sys/firmware/board_data */
+	board_data_kobj = kobject_create_and_add("board_data", firmware_kobj);
+	if (!board_data_kobj) {
+		pr_err(PFX"kset create error\n");
+		return -ENODEV;
+	}
+
+	/* Register flash regions as seperate platform devices */
+	for (count = 0; count < mfh->item_count; count++, item++){
+		pdev = NULL;
+
+		switch (item->type){
+		case MFH_ITEM_BUILD_INFO:
+			conf_res.start = item->addr;
+			conf_res.end = item->addr + item->len;
+			pdev = &conf_pdev;
+			break;
+		case MFH_ITEM_VERSION:
+			flash_version_data = item->res0;
+			if(sysfs_create_file(board_data_kobj, 
+					&flash_version_attr.attr)) {
+                		pr_err("failed to create sysfs entry for flash version\n");
+				flash_version_data = 0;
+		        }
+			break;
+		default:
+			break;
+		}
+
+		if (pdev != NULL)
+			platform_device_register(pdev);
+	}
+
+	/* This ought to be encoded in the MFH ! */	
+	if (mfh_plat_found == false){
+		pr_err(PFX"Warning platform data MFH missing - using hardcoded "
+			"offsets\n");
+
+		/* Platform data */
+		plat_res.start = SPIFLASH_BASEADDR + PLATFORM_DATA_OFFSET;
+		count = *(uint32_t*)(spi_data + PLATFORM_DATA_OFFSET + sizeof(uint32_t));
+		plat_res.end = count;
+		ret = intel_cln_plat_probe(&plat_res);
+	}
+
+	iounmap(spi_data);
+	return ret;
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+subsys_initcall(intel_cln_board_data_init);
+
diff --git a/drivers/platform/x86/quark/intel_cln_ecc_scrub.c b/drivers/platform/x86/quark/intel_cln_ecc_scrub.c
new file mode 100644
index 0000000..1fb46f6
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_ecc_scrub.c
@@ -0,0 +1,668 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton DRAM ECC Scrub driver
+ *
+ * !!!!!!! Description
+ *
+ */
+#include <asm-generic/uaccess.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+
+#define DRIVER_NAME			"intel-cln-ecc"
+#define INTEL_CLN_ECC_SCRUB_PROCDIR	"driver/ecc_scrub"
+#define STATUS				"status"
+#define CONTROL				"control"
+#define INTERVAL			"interval"
+#define ECC_BLOCK_SIZE			"block_size"
+
+#define CONTROL_USAGE		"ECC Scrub Control: invalid setting. "\
+				"Valid values are 1 or 0\n"
+#define CONTROL_SCRUB_ON_STR	"1\n"
+#define CONTROL_SCRUB_OFF_STR	"0\n"
+#define CONTROL_ON_STR		"on\n"
+#define CONTROL_OFF_STR		"off\n"
+
+#define INTERVAL_USAGE		"ECC Scrub Interval: invalid setting. "\
+				"Valid range is 1 - 255\n"
+#define SIZE_USAGE		"ECC Scrub Block Size: invalid setting. "\
+				"Valid range is 64 - 512\n"
+
+#define OVERRIDE_CONFIG_PARM_DESC	"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Config"
+
+#define OVERRIDE_START_PARM_DESC	"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Start address"
+
+#define OVERRIDE_END_PARM_DESC		"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub End address"
+
+#define OVERRIDE_NEXT_PARM_DESC		"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Next address"
+
+#define MAX_SCRUB_BLOCK_SIZE 512
+#define MIN_SCRUB_BLOCK_SIZE 64
+#define MAX_SCRUB_REFRESH 255
+#define MIN_SCRUB_REFRESH 0
+
+#define NOT_OVERRIDDEN 0xfffffffful
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+/* Register ID */
+#define ECC_SCRUB_CONFIG_REG		(0x50)
+#define ECC_SCRUB_START_MEM_REG		(0x76)
+#define ECC_SCRUB_END_MEM_REG		(0x77)
+#define ECC_SCRUB_NEXT_READ_REG		(0x7C)
+
+
+/* Reg commands */
+#define THERMAL_CTRL_READ		(0x10)
+#define THERMAL_CTRL_WRITE		(0x11)
+#define THERMAL_RESUME_SCRUB		(0xC2)
+#define THERMAL_PAUSE_SCRUB		(0xC3)
+
+/**
+ * struct intel_cln_ecc_scrub_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_ecc_scrub_dev {
+
+	/* Linux kernel structures */
+	struct platform_device *pldev;		/* Platform device */
+
+	/* Register copies */
+	u32 start_address;
+	u32 end_address;
+	u32 next_address;
+	u32 config;
+
+};
+
+static struct intel_cln_ecc_scrub_dev ecc_scrub_dev;
+
+static u32 ecc_scrub_config_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_start_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_end_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_next_override = NOT_OVERRIDDEN;
+
+/**
+ * intel_cln_ecc_scrub_stat_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/status
+ */
+static ssize_t
+intel_cln_ecc_scrub_stat_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int len = 0, size = 0;
+	unsigned int count = PAGE_SIZE;
+	u32 reg_data = 0;
+	char *scrub_status = CONTROL_OFF_STR;
+
+	/* Display start of memory address */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
+		&reg_data, 1);
+	len += snprintf(buf + len, count - len,
+			"ecc scrub mem start\t\t\t: 0x%08x\n", reg_data);
+
+
+	/* Display end of memory address */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
+		&reg_data, 1);
+	len += snprintf(buf + len, count - len,
+			"ecc scrub mem end\t\t\t: 0x%08x\n", reg_data);
+
+	/* Display next address to be read */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
+		&reg_data, 1);
+	len += snprintf(buf + len, count - len,
+			"ecc scrub next read\t\t\t: 0x%08x\n", reg_data);
+
+	/* Display config settings */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+
+	/* Interval is the lsbyte of the config reg, so mask out just
+	 * that byte in the data printed. */
+	len += snprintf(buf + len, count - len,
+			"ecc scrub interval\t\t\t: %d\n",
+			(reg_data & 0x000000ff));
+
+	/* Size is indicated in bits 12:8 of register in
+	* terms of 32 byte blocks. */
+	size = ((reg_data & 0x00001f00) >> 8)*32;
+	len += snprintf(buf + len, count - len,
+			"ecc scrub block_size\t\t\t: %d\n", size);
+
+	/* Status is indicated in bit 13 of register. */
+	if ((reg_data & 0x00002000) > 0)
+		scrub_status = CONTROL_ON_STR;
+
+	len += snprintf(buf + len, count - len,
+			"ecc scrub status\t\t\t: %s\n", scrub_status);
+	return len;
+}
+
+/**
+ * intel_cln_ecc_scrub_ctrl_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/control
+ */
+static ssize_t
+intel_cln_ecc_scrub_ctrl_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	unsigned int count = PAGE_SIZE;
+	u32 reg_data = 0;
+	char *on_or_off = CONTROL_SCRUB_OFF_STR;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+	&reg_data, 1);
+
+	/* Status is indicated in bit 13 of register. */
+	if ((reg_data & 0x00002000) > 0)
+		/* interval > 0 assume scrubbing on */
+		on_or_off = CONTROL_SCRUB_ON_STR;
+
+	return snprintf(buf, count,"%s", on_or_off);
+}
+
+/**
+ * intel_cln_ecc_scrub_ctrl_store
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: input buffer
+ * @param size: size of input data
+ * @return number of bytes successfully written
+ *
+ * Function allows user-space to switch on/off scrubbing with a simple
+ * echo 1/0 > /sys/device/platform/intel-cln-ecc/control command
+ */
+static ssize_t
+intel_cln_ecc_scrub_ctrl_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	ssize_t ret = 0;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	ret = -EINVAL;
+
+	/* Check for command starting with "scrub"
+	*  and ending with "on" or "off" */
+
+	if (!strcmp(buf, CONTROL_SCRUB_ON_STR)) {
+			sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB,
+			0, 0, 1);
+			ret = 0;
+	} else if (!strcmp(buf, CONTROL_SCRUB_OFF_STR)) {
+		sb_write(SB_ID_THERMAL, THERMAL_PAUSE_SCRUB, 0,
+			 0, 1);
+		ret = 0;
+	}
+
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+
+	else if (ret == -EINVAL)
+		printk(CONTROL_USAGE);
+
+	return ret;
+}
+
+/**
+ * intel_cln_ecc_scrub_intrvl_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/interval
+ */
+static ssize_t
+intel_cln_ecc_scrub_intrvl_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	u32 reg_data = 0;
+
+	/* Interval is the lsbyte of the config reg,
+	* so mask out just that byte in the data printed. */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", (reg_data & 0x000000ff));
+}
+
+/**
+ * intel_cln_ecc_scrub_intrvl_store
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: input buffer
+ * @param size: size of input data
+ * @return number of bytes successfully written
+ *
+ * Function allows user-space to set scrub interval with a value of 1-255
+ * echo 1-255 > /sys/device/platform/intel-cln-ecc/interval type command
+ */
+static ssize_t
+intel_cln_ecc_scrub_intrvl_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	ssize_t ret = 0;
+	unsigned long val = 0;
+	u32 reg_data = 0;
+	int ret_temp = 0;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	ret = -EINVAL;
+
+	ret_temp = kstrtoul(buf, 10, &val);
+
+	if (ret_temp)
+		return ret_temp;
+
+	if (val > MIN_SCRUB_REFRESH && val <= MAX_SCRUB_REFRESH) {
+		/* Need to read-modify-write config register. */
+		sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
+			ECC_SCRUB_CONFIG_REG,
+			&reg_data, 1);
+
+		reg_data &= 0xffffff00;	/* clear lsb. */
+		reg_data |= val;		/* now set interval. */
+
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG,
+			 reg_data, 1);
+		ret = 0;
+	} else {
+		printk(INTERVAL_USAGE);
+	}
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+	return ret;
+}
+
+/**
+ * intel_cln_ecc_scrub_size_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/block_size
+ */
+static ssize_t
+intel_cln_ecc_scrub_size_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int size = 0;
+	u32 reg_data = 0;
+
+	/* Size is indicated in bits 12:8 of config register
+	 * multiply x32 to get num bytes). */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+	size = ((reg_data & 0x00001f00) >> 8)*32;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", size);
+}
+
+/**
+ * intel_cln_ecc_scrub_size_store
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: input buffer
+ * @param size: size of input data
+ * @return number of bytes successfully written
+ *
+ * Function allows user-space to set scrub block size of 64-512 with a simple
+ * echo 64-512 > /sys/device/platform/intel-cln-ecc/block_size command
+ */
+static ssize_t
+intel_cln_ecc_scrub_size_store(struct device *dev, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	ssize_t ret = 0;
+	unsigned long val = 0;
+	u32 reg_data = 0;
+	int ret_temp = 0;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	ret = -EINVAL;
+	ret_temp = kstrtoul(buf, 10, &val);
+
+	if (ret_temp)
+		return ret_temp;
+
+	if (val >= MIN_SCRUB_BLOCK_SIZE && val <= MAX_SCRUB_BLOCK_SIZE){
+
+		/* Need to read-modify-write config register. */
+		sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
+			ECC_SCRUB_CONFIG_REG,
+			&reg_data, 1);
+
+		reg_data &= 0xfffffe0ff;	/* clear bits 12:8 */
+		reg_data |= (val/32)<<8;	/* now set size */
+
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG, reg_data, 1);
+		ret = 0;
+	} else {
+		printk(SIZE_USAGE);
+	}
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+
+	return ret;
+}
+
+static struct device_attribute dev_attr_status = {
+	.attr = {
+		.name = "status",
+		.mode = 0444,
+		},
+	.show = intel_cln_ecc_scrub_stat_show,
+};
+
+static struct device_attribute dev_attr_control = {
+	.attr = {
+		.name = "control",
+		.mode = 0644,
+		},
+	.show = intel_cln_ecc_scrub_ctrl_show,
+	.store = intel_cln_ecc_scrub_ctrl_store,
+};
+
+static struct device_attribute dev_attr_intrvl = {
+	.attr = {
+		.name = "interval",
+		.mode = 0644,
+		},
+	.show = intel_cln_ecc_scrub_intrvl_show,
+	.store = intel_cln_ecc_scrub_intrvl_store,
+};
+
+static struct device_attribute dev_attr_block_size = {
+	.attr = {
+		.name = "block_size",
+		.mode = 0644,
+		},
+	.show = intel_cln_ecc_scrub_size_show,
+	.store = intel_cln_ecc_scrub_size_store,
+};
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_status.attr,
+	&dev_attr_control.attr,
+	&dev_attr_intrvl.attr,
+	&dev_attr_block_size.attr,
+	NULL,
+};
+
+static struct attribute_group ecc_attrib_group = {
+	.attrs = platform_attributes
+};
+
+/*****************************************************************************
+ *                        Module/PowerManagement hooks
+ *****************************************************************************/
+/**
+ * intel_cln_ecc_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ */
+static int intel_cln_ecc_scrub_probe(struct platform_device *pdev)
+{
+	int value_overridden = 0;
+
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	u32 scrubber_refresh = 0;
+	u32 scrubber_block_size = 0;
+	u32 config_settings = 0;
+#endif
+
+	memset(&ecc_scrub_dev, 0x00, sizeof(ecc_scrub_dev));
+
+	/* Update config settings, if directed so to do */
+	if (ecc_scrub_start_override != NOT_OVERRIDDEN) {
+		/* start of memory address */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_START_MEM_REG, ecc_scrub_start_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_end_override != NOT_OVERRIDDEN) {
+		/* end of memory address */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_END_MEM_REG, ecc_scrub_end_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_next_override != NOT_OVERRIDDEN) {
+		/* next address to be read */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_NEXT_READ_REG, ecc_scrub_next_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_config_override != NOT_OVERRIDDEN) {
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG, ecc_scrub_config_override, 1);
+
+			value_overridden = 1;
+	}
+
+	/* Config Reg can be updated by either command line or kconfig setting
+	 * in the case where we have both the command line takes precedence.*/
+
+	else {
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+		scrubber_refresh = CONFIG_INTEL_CLN_HW_ECC_REFRESH_RATE;
+		scrubber_block_size = CONFIG_INTEL_CLN_HW_ECC_REFRESH_SIZE;
+
+		if (scrubber_block_size > MAX_SCRUB_BLOCK_SIZE)
+			scrubber_block_size = MAX_SCRUB_BLOCK_SIZE;
+
+		else if (scrubber_block_size < MIN_SCRUB_BLOCK_SIZE)
+			scrubber_block_size = MIN_SCRUB_BLOCK_SIZE;
+
+		if (scrubber_refresh > MAX_SCRUB_REFRESH)
+			scrubber_refresh = MAX_SCRUB_REFRESH;
+
+
+		/* adjust block size to multiples of 32 -
+		 * as that is what the register setting actually expects. */
+		config_settings = scrubber_block_size/32;
+		config_settings <<= 8;
+		config_settings += scrubber_refresh;
+
+		/* config settings */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG, config_settings, 1);
+
+		value_overridden = 1;
+#endif
+	}
+
+	if (value_overridden)
+		sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
+
+	return sysfs_create_group(&pdev->dev.kobj, &ecc_attrib_group);
+}
+
+/**
+ * intel_cln_ecc_scrub_suspend
+ *
+ * @param pdev: Platform device structure (unused)
+ * @return 0 success < 0 failure
+ *
+ */
+static int intel_cln_ecc_scrub_suspend(struct device *pdev)
+{
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
+	u32 reg_data = 0;
+
+	/* Store off the 4 registers associated with scrubbing. */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.start_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.end_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.next_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.config = reg_data;
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_ecc_scrub_resume
+ *
+ * @param pdev: Platform device structure (unused)
+ * @return 0 success < 0 failure
+ */
+static int intel_cln_ecc_scrub_resume(struct device *pdev)
+{
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_START_MEM_REG,
+		 ecc_scrub_dev.start_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_END_MEM_REG,
+		 ecc_scrub_dev.end_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_NEXT_READ_REG,
+		 ecc_scrub_dev.next_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_CONFIG_REG,
+		 ecc_scrub_dev.config, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
+
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_ecc_scrub_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_ecc_scrub_remove(struct platform_device *pdev)
+{
+	return sysfs_create_group(&pdev->dev.kobj, &ecc_attrib_group);
+}
+
+/*
+ * Power management operations
+ */
+static const struct dev_pm_ops intel_cln_ecc_scrub_pm_ops = {
+	.suspend = intel_cln_ecc_scrub_suspend,
+	.resume = intel_cln_ecc_scrub_resume,
+};
+
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_ecc_scrub_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &intel_cln_ecc_scrub_pm_ops,
+	},
+	.probe = intel_cln_ecc_scrub_probe,
+	.remove = intel_cln_ecc_scrub_remove,
+};
+
+
+MODULE_AUTHOR("Derek Harnett <derek.harnett@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton DRAM ECC-scrub driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_param(ecc_scrub_config_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_config_override, OVERRIDE_CONFIG_PARM_DESC);
+
+module_param(ecc_scrub_start_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_start_override, OVERRIDE_START_PARM_DESC);
+
+module_param(ecc_scrub_end_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_end_override, OVERRIDE_END_PARM_DESC);
+
+module_param(ecc_scrub_next_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_next_override, OVERRIDE_NEXT_PARM_DESC);
+
+module_platform_driver(intel_cln_ecc_scrub_driver);
+
diff --git a/drivers/platform/x86/quark/intel_cln_esram.c b/drivers/platform/x86/quark/intel_cln_esram.c
new file mode 100644
index 0000000..76d2024
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_esram.c
@@ -0,0 +1,1144 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A sysfs interface is provided to allow map of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo idt_table > /sys/devices/intel-cln-esram.0/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * intel_cln_esram_map_sym(ohci_irq);
+ * intel_cln_esram_map_page(virt_to_page(ohci_irq), "ohci_irq");
+ * Are equivalent - with the exception that map_sym() can detect if a mapping
+ * crosses a page-boundary, whereas map_page just maps one page. Generally use
+ * map_sym() for code and map_page() for data
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * Unmap code is included for reference however the cache coherency of unmap is
+ * not guaranteed so the functionality is not exported by this code
+ * 
+ */
+#include <asm/cacheflush.h>
+#include <asm/desc.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/special_insns.h>
+#include <asm-generic/uaccess.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+
+#include "intel_cln_esram.h"
+
+#define DRIVER_NAME			"intel-cln-esram"
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+/* Define size of pages, ECC scrub demark etc */
+#define MAX_PAGE_RETRIES		(100)
+#define MS_PER_HOUR			(3600000UL)
+#define ESRAM_PAGE_COUNT		INTEL_CLN_ESRAM_PAGE_COUNT
+#define ESRAM_PAGE_MASK			(0xFFFFF000)
+#define ESRAM_PAGE_SIZE			INTEL_CLN_ESRAM_PAGE_SIZE
+#define ESRAM_TOTAL_SIZE		(ESRAM_PAGE_COUNT * ESRAM_PAGE_SIZE)
+#define ECC_MAX_REFRESH_PERIOD		(48)
+#define ECC_DEFAULT_REFRESH_PERIOD	(24)
+#define ECC_DRAM_READSIZE		(512)		/* bytes per DRAM ECC */
+#define ECC_ESRAM_READSIZE		ESRAM_PAGE_SIZE	/* bytes per SRAM ECC */
+
+/* Register ID */
+#define ESRAM_PGPOOL_REG		(0x80)		/* PGPOOL */
+#define ESRAM_CTRL_REG			(0x81)		/* ESRAMCTRL */
+#define ESRAM_PGBLOCK_REG		(0x82)		/* Global page ctrl */
+#define ESCRM_ECCCERR_REG		(0x83)		/* Correctable ECC */
+#define ESRAM_ECCUCERR_REG		(0x84)		/* Uncorrectable ECC */
+
+/* Reg commands */
+#define ESRAM_CTRL_READ			(0x10)		/* Config reg */
+#define ESRAM_CTRL_WRITE		(0x11)		/* Config reg */
+#define ESRAM_PAGE_READ			(0x12)		/* Page config read */
+#define ESRAM_PAGE_WRITE		(0x13)		/* Page config write */
+
+/* ESRAMPGPOOL reg 0x80 - r/w opcodes 0x10/0x11 */
+#define ESRAM_PGPOOL_FLUSHING(x)	((x>>18)&0x1FF)
+#define ESRAM_PGPOOL_PGBUSY(x)		((x>>9)&0x1FF)
+
+/* ESRAMCTRL reg 0x81 - r/w opcodes 0x10/0x11 */
+#define ESRAM_CTRL_FLUSHPRI(x)		((x>>25)&0x03)	/* DRAM flush priority */
+#define ESRAM_CTRL_SIZE(x)		((x>>16)&0xFF)	/* # of 4k pages */
+#define ESRAM_CTRL_ECCTHRESH(x)		((x>>8)&0xFF)	/* ECC threshold */
+#define ESRAM_CTRL_THRESHMSG_EN		(0x00000080)	/* ECC notification */
+#define ESRAM_CTRL_ISAVAIL		(0x00000010)	/* ESRAM on die ? */
+#define ESRAM_CTRL_BLOCK_MODE		(0x00000008)	/* Block mode enable */
+#define ESRAM_CTRL_GLOBAL_LOCK		(0x00000004)	/* Global lock status */
+#define ESRAM_CTRL_FLUSHDISABLE		(0x00000002)	/* Global flush/dis */
+#define ESRAM_CTRL_SECDEC		(0x00000001)	/* ECC enable bit */
+
+/* PGBLOCK reg 0x82 - opcode 0x10/0x11 */
+#define ESRAM_PGBLOCK_FLUSHEN		(0x80000000)	/* Block flush enable */
+#define ESRAM_PGBLOCK_PGFLUSH		(0x40000000)	/* Flush the block */
+#define ESRAM_PGBLOCK_DISABLE		(0x20000000)	/* Block mode disable */
+#define ESRAM_PGBLOCK_ENABLE		(0x10000000)	/* Block mode enable */
+#define ESRAM_PGBLOCK_LOCK		(0x08000000)	/* Block mode lock en */
+#define ESRAM_PGBLOCK_INIT		(0x04000000)	/* Block init in prog */
+#define ESRAM_PGBLOCK_BUSY		(0x01000000)	/* Block is enabled */
+#define ESRAM_PGBLOCK_SYSADDR(x)	(x&0x000000FF)
+
+/* ESRAMPGCTRL - opcode 0x12/0x13 */
+#define ESRAM_PAGE_FLUSH_PAGE_EN	(0x80000000)	/* S3 autoflush */
+#define ESRAM_PAGE_FLUSH		(0x40000000)	/* Flush page to DRAM */
+#define ESRAM_PAGE_DISABLE		(0x20000000)	/* page disable bit */
+#define ESRAM_PAGE_EN			(0x10000000)	/* Page enable */
+#define ESRAM_PAGE_LOCK			(0x08000000)	/* Page lock en */
+#define ESRAM_PAGE_INITIALISING		(0x04000000)	/* Init in progress */
+#define ESRAM_PAGE_BUSY			(0x01000000)	/* Page busy */
+#define ESRAM_PAGE_MAP_SHIFT		(12)		/* Shift away 12 LSBs */
+
+/* Extra */
+#define ESRAM_MAP_OP			(0x01)
+#define ESRAM_UNMAP_OP			(0x00)
+
+/**
+ * struct esram_refname
+ *
+ * Structure to hold a linked list of names
+ */
+struct esram_refname {
+	char name[KSYM_SYMBOL_LEN];	/* Name of mapping */
+	struct list_head list;
+};
+
+/**
+ * struct esram_page
+ *
+ * Represents an eSRAM page in our linked list
+ */
+struct esram_page {
+
+	struct list_head list;		/* List entry descriptor */
+	struct list_head name_list;	/* Linked list for name references */
+	u32 id;				/* Page ID */
+	u32 phys_addr;			/* Physial address of page */
+	u32 refcount;			/* Reference count */
+	u32 vaddr;			/* Virtual address of page */
+
+};
+
+/**
+ * struct intel_cln_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_esram_dev{
+
+	/* Linux kernel structures */
+	struct list_head page_used;	/* Used pages */
+	struct list_head page_free;	/* Free pages */
+	spinlock_t slock;		/* Spinlock */
+	struct platform_device *pldev;	/* Platform device */
+
+	/* Actual data */
+	struct esram_page * pages;
+	u8 cbuf[ESRAM_PAGE_SIZE];
+
+	/* Stats */
+	u32 page_count;			/* As reported by silicon */
+	u32 page_disable_retries;	/* Aggreate count on disable */
+	u32 page_enable_retries;	/* Aggregate spin count page enable */
+	u32 page_free_ct;		/* Free pages for mapping code section */
+};
+
+static struct intel_cln_esram_dev esram_dev;
+
+/* 
+ * Kallsyms does not provide data addresses. To map important structures such as
+ * the idt and gdt, we need to frig the lookup with the below. Other entities
+ * can similarly be added. Note we map a page from the given address - anything
+ * larger will require additional code to handle
+ */
+struct esram_symex {
+	char * name;
+	void * vaddr;
+	u32 size;
+};
+
+static struct esram_symex esram_symex[] = 
+{
+	{
+		.name = "idt_table",
+		.vaddr = &idt_table,
+		.size = ESRAM_PAGE_SIZE,
+	},
+	{
+		.name = "gdt_page",
+		.vaddr = &gdt_page,
+		.size = ESRAM_PAGE_SIZE,
+	},
+};
+
+/**
+ * intel_cln_esram_stat_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates eSRAM state via /sys/device/intel-cln-esram.0/stat
+ */
+static ssize_t intel_cln_esram_stat_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+
+{
+	struct esram_page * epage = NULL;
+	int len = 0;
+	unsigned int count = PAGE_SIZE, size;
+	u32 pgpool = 0, ctrl = 0, pgblock = 0;
+	char * enabled = "enabled";
+	char * disabled = "disabled";
+
+	/* Display page-pool relevant data */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGPOOL_REG, &pgpool, 1);
+	size = snprintf(buf, count,
+			"esram-pgpool\t\t\t: 0x%08x\n" 
+			"esram-pgpool.free\t\t: %u\n"
+			"esram-pgpool.flushing\t\t: %u\n",
+			pgpool,	ESRAM_PGPOOL_PGBUSY(pgpool)+1,
+			ESRAM_PGPOOL_FLUSHING(pgpool) + 1);
+	len += size;
+	count -= size;
+	
+	/* Display ctrl reg - most of this is of interest */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	size = snprintf(buf + len, count - len,
+			"esram-ctrl\t\t\t: 0x%08x\n"
+			"esram-ctrl.ecc\t\t\t: %s\n"
+			"esram-ctrl.ecc-theshold\t\t: %u\n"
+			"esram-ctrl.pages\t\t: %u\n"
+			"esram-ctrl.dram-flush-priorityi\t: %u\n",
+			ctrl, (ctrl & ESRAM_CTRL_SECDEC) ? enabled : disabled,
+			ESRAM_CTRL_ECCTHRESH(ctrl), ESRAM_CTRL_SIZE(ctrl)+1,
+			ESRAM_CTRL_FLUSHPRI(ctrl));
+	len += size;
+	count -= size;
+
+	/* Display block ctrl/stat - we should be !block mode */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &pgblock, 1);
+	size = snprintf(buf + len, count - len, "esram-block\t\t\t: 0x%08x\n",
+			pgblock);
+	len += size;
+	count -= size;
+
+	/* Print ECC status regs */
+
+	/* Print per-page info */
+	size = snprintf(buf + len, count - len, 
+			"free page\t\t\t: %u\nused page\t\t\t: %u\n"
+			"refresh  \t\t\t: %ums\npage enable retries\t\t: %u\n"
+			"page disable retries\t: %u\n",
+			esram_dev.page_free_ct, 
+			esram_dev.page_count-esram_dev.page_free_ct,
+			0,
+			esram_dev.page_enable_retries,
+			esram_dev.page_disable_retries);
+	len += size;
+	count -= size;
+
+	spin_lock(&esram_dev.slock);
+	if(!list_empty(&esram_dev.page_free)){
+
+		epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+		size = snprintf(buf + len, count - len, 
+			"ecc next page \t\t\t: %u\n",epage->id);
+		len += size;
+		count -= size;
+
+
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	return len;
+}
+
+/**
+ * intel_cln_esram_map_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ * 
+ * Read back eSRAM mapped entries
+ */
+static ssize_t
+intel_cln_esram_map_show(struct device *dev,struct device_attribute *attr,
+			 char *buf)
+{
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+	int len = 0, size = 0;
+	unsigned int count = PAGE_SIZE;
+
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		/* Print references */
+		list_for_each_entry(refname, &epage->name_list, list){
+			size = snprintf(buf + len, count - len,
+				"%s ", refname->name);
+			len += size;
+			count -= size;
+		}
+		/* Print data */
+		size += snprintf(buf + len, count - len,
+			"\n\tPage virt 0x%08x phys 0x%08x\n"
+			"\tRefcount %u\n",
+			epage->vaddr, epage->phys_addr,
+			epage->refcount);
+		len += size;
+		count -= size;
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	return len;
+}
+
+/**
+ * intel_cln_esram_map_store
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: input buffer
+ * @param size: size of input data
+ * @return number of bytes successfully written
+ *
+ * Function allows user-space to switch mappings on/off with a simple
+ * echo idt_table > /sys/devices/intel-cln-esram.0/map type command
+ */
+static ssize_t
+intel_cln_esram_map_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	ssize_t ret = 0;
+	char * sbuf = NULL;
+	unsigned long vaddr = 0, i = 0;
+	unsigned int count = PAGE_SIZE;
+
+	if(count <= 1){
+		return -EINVAL;
+	}
+
+	/* Get input */
+	sbuf = (char*)buf;
+
+	/* Fixup entity to scrub spaces */
+	while(sbuf < (buf + count)){
+		if(*sbuf == ' ' || *sbuf == '\r' || *sbuf =='\n'){
+			*sbuf = 0;
+			break;
+		}
+		sbuf++;
+	}
+
+	/* Check to see if we are being asked to map a non-kallsyms addr */
+	for(i = 0; i < sizeof(esram_symex)/sizeof(struct esram_symex); i++){
+		if(strcmp(buf, esram_symex[i].name) == 0){
+			ret = intel_cln_esram_map_range(
+				esram_symex[i].vaddr,
+				esram_symex[i].size,
+				esram_symex[i].name);
+			goto done;
+		}
+	}
+
+	/* This path relies on kallsyms to provide name/address data */
+	vaddr = kallsyms_lookup_name(buf);
+	if(vaddr == 0)
+		goto done;
+
+	ret = intel_cln_esram_map_symbol((void*)vaddr);
+done:
+	if(ret == 0)
+		ret = (ssize_t)count;
+	return ret;
+}
+
+static struct device_attribute dev_attr_stats = {
+	.attr = {
+		.name = "stats",
+		.mode = 0444,
+		},
+	.show = intel_cln_esram_stat_show,
+};
+
+static struct device_attribute dev_attr_map = {
+	.attr = {
+		.name = "map",
+		.mode = 0644,
+		},
+	.show = intel_cln_esram_map_show,
+	.store = intel_cln_esram_map_store,
+};
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_stats.attr,
+	&dev_attr_map.attr,
+	NULL,
+};
+
+static struct attribute_group esram_attrib_group = {
+	.attrs = platform_attributes
+};
+
+/******************************************************************************
+ *                                eSRAM Core
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_page_busy
+ *
+ * @param epage: Pointer to the page descriptor
+ * @return boolean indicating whether or not a page is enabled
+ */
+static int intel_cln_esram_page_busy(struct esram_page * epage, u8 lock)
+{
+	u32 reg = 0;
+
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, lock);
+	return (reg&(ESRAM_PAGE_BUSY | ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE));
+}
+
+/**
+ * intel_cln_esram_fault
+ *
+ * Dump eSRAM registers and kernel panic
+ * Nothing else to do at this point
+ */
+void intel_cln_esram_fault(struct esram_page * epage, u32 lineno)
+{
+	u32 reg = 0, next = 0, prev = 0, prev_reg = 0;
+	u32 next_reg = 0, block = 0, ctrl = 0;
+
+	pr_err("eSRAM: fault @ %s:%d\n", __FILE__, lineno);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, 1);
+	pr_err("read page %d state 0x%08x\n", epage->id, reg);
+	if(epage->id == 0){
+		next = 1; prev = 127;
+	}else if(epage->id == 127){
+		next = 0; prev = 126;
+	}else{
+		next = epage->id+1;
+		prev = epage->id-1;
+	}
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, next, &next_reg, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, prev, &prev_reg, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	pr_err("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
+	pr_err("Prev page %d state 0x%08x Next page %d state 0x%08x\n"
+		, next, next_reg, prev, prev_reg);
+	BUG();
+}
+
+
+/**
+ * intel_cln_esram_page_enable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ * @param lock: Indicates whether to attain sb spinlock or not
+ * 
+ * Enable an eSRAM page spinning for page to become ready.
+ */
+static void intel_cln_esram_page_enable(struct esram_page *epage, u8 lock)
+{
+	u32 ret = 0;
+
+	/* Fault if we try to enable a disabled page */
+	if(intel_cln_esram_page_busy(epage, lock)){
+		intel_cln_esram_fault(epage, __LINE__);
+	}
+
+	/* Program page mapping */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id, 
+		ESRAM_PAGE_FLUSH_PAGE_EN | ESRAM_PAGE_EN | 
+			(epage->phys_addr>>ESRAM_PAGE_MAP_SHIFT), lock);
+	do {
+		/* Poll until page busy bit becomes true */
+		ret = intel_cln_esram_page_busy(epage, lock);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret == 0)){
+			esram_dev.page_enable_retries++;
+		}
+		
+	}while(ret == 0);
+}
+
+/**
+ * intel_cln_esram_page_disable_sync
+ *
+ * @param epage: pointer to eSRAM page descriptor
+ *
+ * This function spins waiting for disable bit to clear, useful right after a
+ * disable/disable-flush command. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_cln_esram_page_disable_sync(struct esram_page * epage)
+{
+	u32 ret = 0, retries = 0;
+	do {
+		/* Poll for busy bit clear */
+		ret = intel_cln_esram_page_busy(epage, 1);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret)){
+			esram_dev.page_disable_retries++;
+			retries++;
+		}
+
+		if(retries == MAX_PAGE_RETRIES){
+			intel_cln_esram_fault(epage, __LINE__);
+		}
+	}while(ret);
+}
+
+/**
+ * intel_cln_esram_page_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page no flush. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_cln_esram_page_disable(struct esram_page *epage)
+{
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_DISABLE, 1);
+	intel_cln_esram_page_disable_sync(epage);	
+}
+
+/**
+ * intel_cln_esram_page_flush_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page - with flush. Note the architecture will block access
+ * to the overlayed region until the flush has completed => irqs may be switched
+ * on during this operation.
+ */
+static void intel_cln_esram_page_flush_disable(struct esram_page *epage)
+{
+	
+
+	/* Do flush */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE, 1);
+
+	intel_cln_esram_page_disable_sync(epage);	
+}
+
+#if 0
+/**
+ * intel_cln_esram_flush_disable_all
+ *
+ * Flushes and disables all enabled eSRAM pages
+ */
+static void intel_cln_esram_page_flush_disable_all(void)
+{
+	struct esram_page * epage = NULL;
+	
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		intel_cln_esram_page_flush_disable(epage);
+	}
+	spin_unlock(&esram_dev.slock);
+}
+#endif
+
+/**
+ * intel_cln_esram_page_populate_atomic
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 placeholder, later versions may return error
+ *
+ * Function takes the mappings given in epage and uses the values to populate
+ * an eSRAM page. The copy/enable/copy routine must be done atomically, since we
+ * may be doing a memcpy() of an ISR for example.
+ * For this reason we wrapper this entire call into a callback provided by 
+ * side-band, which does a spin_lock_irqsave calls this function and then does
+ * a spin_lock_irqrestore - thus guaranteeing atomicity of the below code and
+ * respect for the locking strategy of the side-band driver
+  */
+static int intel_cln_esram_page_populate_atomic(struct esram_page * epage)
+{
+	unsigned long crz;
+
+	/* Copy away */	
+	memcpy(&esram_dev.cbuf, (void*)epage->vaddr, ESRAM_PAGE_SIZE);
+
+	/* If CR0.WP is true - flip it HSD # 4930660 */
+	crz = read_cr0();
+	if (crz & X86_CR0_WP){
+		write_cr0(crz & (~X86_CR0_WP));
+	}
+
+	/* Disable NMI */
+	outb(0x80, 0x70);
+	
+	/*  Enable page mapping */
+	intel_cln_esram_page_enable(epage, 0);
+	
+	/* Copy back - populating memory overlay */
+	memcpy((void*)epage->vaddr, &esram_dev.cbuf,  ESRAM_PAGE_SIZE);
+
+	/* Re-enable NMI */
+	outb(0x00, 0x70);
+
+	/* Restore CR0.WP if appropriate HSD # 4930660 */
+	if (crz & X86_CR0_WP){
+		write_cr0(crz);
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_esram_page_populate
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 on success < 0 on failure
+ *
+ * Populates the page. set_memory_rw/set_memory_ro require local irqs enabled.
+ * intel_cln_esram_page_populate_atomic - needs irqs switched off since memory
+ * can be inconsistent during the populate operation. Depopulate operations are
+ * architecturally guaranteed
+ */
+static int intel_cln_esram_page_populate(struct esram_page * epage)
+{
+	int flip_rw = 0, level = 0, ret = 0;
+	pte_t * pte = epage != NULL ? lookup_address(epage->vaddr, &level):NULL;
+
+	if(unlikely(pte == NULL)){
+		return -EINVAL;
+	}
+
+	/* Determine if we need to set writable */
+	flip_rw = !(pte_write(*pte));
+	
+	/* Ensure memory is r/w - do so before spin_lock_irqsave */
+	if(flip_rw){
+		ret = set_memory_rw(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_rw = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	/* Force ECC update @ disable only */
+	intel_cln_esram_page_enable(epage, 1);
+	intel_cln_esram_page_disable(epage);
+
+	/* Enable and populate eSRAM page using callback in sb with irqs off */
+	ret |= intel_cln_sb_runfn_lock(
+		(int (*)(void*))intel_cln_esram_page_populate_atomic,(void*)epage);
+
+	/* If we set memory writable - restore previous state */
+	if(flip_rw){
+		ret |= set_memory_ro(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_ro = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+/**
+ * intel_cln_esram_page_addref
+ *
+ * @param epage: eSRAM page descriptor
+ * @param name: Name of reference to add
+ * @return zero on success negative on error
+ *
+ */
+static int intel_cln_esram_page_addref(struct esram_page * epage, char * name)
+{
+	struct esram_refname * refname = NULL;
+	if(unlikely(epage == NULL || name == NULL)){
+		return -EINVAL;
+	}
+
+	refname = kzalloc(sizeof(struct esram_refname), GFP_KERNEL);
+	if(unlikely(refname == NULL)){
+		return -ENOMEM;
+	}
+		
+	/* Add to list */
+	strncpy(refname->name, name, sizeof(refname->name));
+	list_add(&refname->list, &epage->name_list);
+
+	/* Bump reference count */
+	epage->refcount++;
+	return 0;
+}
+
+
+/**
+ * __intel_cln_esram_map_page
+ *
+ * @param page: Page to map
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Overlay a vritual address rangne eeds to be aligned to a 4k address.
+ * Since multiple items can live in a 4k range, it is possible when calling
+ * into map_page() that a previous mapping will have already covered some or all
+ * of the mapping we want. This is not an error case, if the map function finds
+ * it is being asked to map a 4k range already mapped it returns 0, to indicate
+ * the mapping has suceeded i.e. it's already been mapped. This is logical if
+ * you think about it. In contrast being asked to unmap a region not mapped is
+ * clearly an error...
+ *
+ */
+static int __intel_cln_esram_map_page(u32 vaddr, char * name)
+{
+	int ret = 0;	
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	if(unlikely(name == NULL)){
+		return -EINVAL;
+	}
+
+	if(unlikely(esram_dev.page_free_ct == 0)){
+		return -ENOMEM;
+	}
+
+	/* Verify if we have already mapped */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+
+			/* Page already mapped */
+			list_for_each_entry(refname, &epage->name_list, list){
+				if(strcmp(refname->name, name)==0){
+					/* Page mapped at this name */
+					return -EINVAL;
+				}
+			}
+			/* New symbol in previous mapping */
+			return intel_cln_esram_page_addref(epage, name);
+		}
+	}
+
+	/* Enumerate eSRAM page structure */
+	epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+	epage->phys_addr = virt_to_phys((void*)vaddr);
+	epage->vaddr = vaddr;
+	ret = intel_cln_esram_page_addref(epage, name);
+	if(unlikely(ret < 0)){
+		return ret;
+	}
+	
+	/* Populate page */
+	ret = intel_cln_esram_page_populate(epage);
+
+	/* Move to used list */
+	list_move(&epage->list, &esram_dev.page_used);
+	esram_dev.page_free_ct--;
+
+	return ret;
+}
+
+/**
+ * __intel_cln_esram_unmap_page
+ *
+ * @param page: Page to unmap
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Unmap a previously mapped virutal address range.
+ * Must be 4k aligned
+ *
+ */
+static int __intel_cln_esram_unmap_page(u32 vaddr, char * name)
+{
+	u8 found = 0;
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	/* Find physical address */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+			found = 1;
+			break;
+		}
+	}
+
+	/* Bail out on error */
+	if(found == 0){
+		pr_err("0x%08x not mapped\n", vaddr);
+		return -EINVAL;
+	}
+
+	/* Determine reference to delete */
+	found = 0;
+	list_for_each_entry(refname, &epage->name_list, list){
+		if(strcmp(refname->name,name)==0){
+			found = 1;
+			break;
+		}
+	}
+	if(unlikely(found == 0)){
+		pr_err("No mapping %s!\n", name);
+		return -EINVAL;
+	}
+
+	/* Remove entry decrement reference count */	
+	list_del(&refname->list);
+	kfree(refname);
+	if(--epage->refcount > 0){
+		return 0;
+	}
+
+	/* Flush and disable page */
+	intel_cln_esram_page_flush_disable(epage);
+
+	/* Move to free list tail - scrub entries come from head */
+	list_move_tail(&epage->list, &esram_dev.page_free);
+	esram_dev.page_free_ct++;
+
+	return 0;
+}
+
+/**
+ *
+ * __intel_cln_esram_page_op
+ *
+ * @param vaddr: Virtual address of symbol
+ * @param size: Size/length of symbol
+ * @param name: Name of mapping
+ * @param map: Boolean indicates whether to map or unmap the page
+ * @return 0 success < 0 failure
+ *
+ * This function maps/unmaps a pages/pages given at the given vaddr. If
+ * the extent of the symbol @ vaddr crosses a page boundary, then we map
+ * multiple pages. Other stuff inside the page, gets a performance boost 'for
+ * free'. Any other data in the page that crosses the physical page boundary
+ * will be partially mapped.
+ */
+static int __intel_cln_esram_page_op(u32 vaddr, u32 size, char *name, u8 map)
+{
+	unsigned long offset = 0, page_offset = 0;
+	u32  pages = size/ESRAM_PAGE_SIZE + ((size%ESRAM_PAGE_SIZE) ? 1 : 0);
+	int ret = 0;
+
+	/* Compare required pages to available pages */
+	if(map == ESRAM_MAP_OP){
+		if(pages > esram_dev.page_free_ct)
+			return -ENOMEM;
+	}else{
+		if(pages > esram_dev.page_count - esram_dev.page_free_ct)
+			return -ENOMEM;
+	}
+
+	/* Align to 4k and iterate the mappings */	
+	vaddr = vaddr&ESRAM_PAGE_MASK;
+	while(size > 0){
+
+		/* Map the page */
+		spin_lock(&esram_dev.slock);
+		if(map == ESRAM_MAP_OP){
+			ret = __intel_cln_esram_map_page(vaddr, name);
+							 
+		}else{
+			ret = __intel_cln_esram_unmap_page(vaddr, name);
+		}
+		spin_unlock(&esram_dev.slock);
+		if(unlikely(ret != 0)){
+			break;
+		}
+
+		/* Calc appropriate offsets */
+		page_offset = offset_in_page(vaddr);
+		if(page_offset + size > ESRAM_PAGE_SIZE){
+
+			offset = ESRAM_PAGE_SIZE - page_offset;
+			size -= offset;
+			vaddr += ESRAM_PAGE_SIZE; 
+
+		}else{
+			size = 0;
+		}
+	}
+
+	return ret;
+}
+
+/******************************************************************************
+ *                                 eSRAM API
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname)
+{
+	if(size == 0 || mapname == NULL || vaddr == NULL){
+		return -EINVAL;
+	}
+	return __intel_cln_esram_page_op((u32)vaddr, size, mapname, ESRAM_MAP_OP);
+}
+EXPORT_SYMBOL(intel_cln_esram_map_range);
+
+/**
+ * intel_cln_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_cln_esram_map_range()
+ */
+int intel_cln_esram_map_symbol(void * vaddr)
+{
+	long unsigned int size = 0, offset = 0;
+	char symname[KSYM_SYMBOL_LEN];
+	
+	kallsyms_lookup_size_offset((long unsigned int)vaddr, &size, &offset);
+	if(size == 0){
+		return -EINVAL;
+	}
+	sprint_symbol(symname, (u32)vaddr);
+
+	return __intel_cln_esram_page_op((u32)vaddr, size, symname, 1);
+}
+EXPORT_SYMBOL(intel_cln_esram_map_symbol);
+
+/******************************************************************************
+ *                        Module/PowerManagement hooks 
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_suspend
+ *
+ * @param pdev: Platform device structure (unused)
+ * @param pm: Power managment descriptor
+ * @return 0 success < 0 failure
+ *
+ * For each enabled page - flush to DRAM and disable eSRAM page.
+ * For each 4k region the architecture guarantees atomicity of flush/disable.
+ * Hence any memory transactions to the affected region will stall until
+ * flush/disable completes - hence interrupts are left on.
+ */
+static int intel_cln_esram_suspend(struct device * pdev)
+{
+	/* Flush and disable of eSRAM pages is carried out automatically */
+	return 0;
+}
+
+/**
+ * intel_cln_esram_resume
+ *
+ * @param pm: Power management descriptor
+ * @return 0 success < 0 failure
+ *
+ * Runs after resume_noirq. Switches pages back to ro, if appropriate. We do
+ * this here since interrupts will be on, as required by the function
+ * set_memory_ro. If it were possible to set memory ro in resume_noirq we would
+ * do it there instead
+ */
+static int intel_cln_esram_resume(struct device * pdev)
+{
+	struct esram_page * epage = NULL;
+	int ret = 0;
+
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		ret |= intel_cln_esram_page_populate(epage);
+	}
+	
+	return ret;
+}
+
+
+/**
+ * intel_cln_esram_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_esram_probe(struct platform_device * pdev)
+{
+	int ret = 0;
+	u32 block = 0, ctrl = 0, i = 0, pgstat = 0;
+
+	memset(&esram_dev, 0x00, sizeof(esram_dev));
+	INIT_LIST_HEAD(&esram_dev.page_used);
+	INIT_LIST_HEAD(&esram_dev.page_free);
+	spin_lock_init(&esram_dev.slock);
+	esram_dev.page_free_ct = 0;
+	
+	/* Ensure block mode disabled */
+	block = ESRAM_PGBLOCK_DISABLE;
+	sb_write(SB_ID_ESRAM, ESRAM_CTRL_WRITE, ESRAM_PGBLOCK_REG, block, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	/* Verify state is good to go */
+	if (ctrl & ESRAM_CTRL_GLOBAL_LOCK){
+		pr_err ("eSRAM: global lock @ 0x%08x\n", ctrl);
+		return -ENODEV;
+	}
+
+	if (block & (ESRAM_PGBLOCK_LOCK | ESRAM_PGBLOCK_ENABLE)){
+		pr_err ("eSRAM: lock @ 0x%08x\n", block);
+		return -ENODEV;
+	}
+	pr_info("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
+
+	/* Calculate # of pages silicon supports */
+	esram_dev.page_count = ESRAM_CTRL_SIZE(ctrl) + 1;
+	esram_dev.page_free_ct = esram_dev.page_count;
+	pr_info("eSRAM: pages %d\n", esram_dev.page_free_ct);
+
+	if(esram_dev.page_free_ct <= 1){
+		pr_err("Too few pages reported by eSRAM sub-system\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate an appropriate number of pages */
+	esram_dev.pages = kzalloc(esram_dev.page_count *
+		sizeof(struct esram_page), GFP_KERNEL);
+	if (esram_dev.pages == NULL){
+		return -ENOMEM;
+	}
+
+	/* Initialise list of free pages, explicitely disable as we go */
+	for(i = 0; i < esram_dev.page_count; i++){
+		INIT_LIST_HEAD(&esram_dev.pages[i].name_list);
+		esram_dev.pages[i].id = i;
+		
+		/* Read & verify page state */
+		sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, i, &pgstat, 1);
+		if(pgstat & (ESRAM_PAGE_BUSY | ESRAM_PAGE_LOCK)){
+			pr_err("eSRAM: page %d state 0x%08x err\n", i, pgstat);
+			ret = -ENODEV;
+			goto err;
+		}
+
+		list_add(&esram_dev.pages[i].list, &esram_dev.page_free);
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &esram_attrib_group);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	kfree(esram_dev.pages);
+	return ret;
+}
+
+/*
+ * Power management operations
+ */
+static const struct dev_pm_ops intel_cln_esram_pm_ops = {
+	.suspend = intel_cln_esram_suspend,
+	.resume = intel_cln_esram_resume,
+};
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_esram_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &intel_cln_esram_pm_ops,
+	},
+	.probe = intel_cln_esram_probe,
+};
+
+module_platform_driver(intel_cln_esram_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton eSRAM overlay/ECC-scrub driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_cln_esram.h b/drivers/platform/x86/quark/intel_cln_esram.h
new file mode 100644
index 0000000..af6156a
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_esram.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A proc interface is provided to allow map/unmap of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo ehci_irq on > /proc/driver/esram/map
+ * echo ehci_irq off > /proc/driver/esram/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * 
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+#ifndef __INTEL_CLN_ESRAM_H__
+#define __INTEL_CLN_ESRAM_H__
+
+#include <linux/module.h>
+
+/* Basic size of an eSRAM page */
+#define	INTEL_CLN_ESRAM_PAGE_SIZE	(0x1000)
+#define INTEL_CLN_ESRAM_PAGE_COUNT	(0x80)
+/**
+ * intel_cln_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_cln_esram_unmap_range
+ *
+ * @param vaddr: The virtual address to unmap
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary of esram_map_page
+ */
+int intel_cln_esram_unmap_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_cln_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_cln_esram_map_range()
+ */
+int intel_cln_esram_map_symbol(void * vaddr);
+
+/**
+ * intel_cln_esram_unmap_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary to intel_cln_esram_map_symbol
+ * Undoes any mapping of pages starting at sym for sym's size
+ */
+int intel_cln_esram_unmap_symbol(void * vaddr);
+
+#endif /* __INTEL_CLN_ESRAM_H__ */
diff --git a/drivers/platform/x86/quark/intel_cln_esram_test.c b/drivers/platform/x86/quark/intel_cln_esram_test.c
new file mode 100644
index 0000000..3d0573d
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_esram_test.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_esram_test.c
+ *
+ * Simple test module to provide test cases for ITS integration
+ *
+ */
+#include <linux/cdev.h>
+#include <linux/crc32.h>
+#include <linux/crc32c.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#include "intel_cln_esram.h"
+#include "intel_cln_esram_test.h"
+
+#define DRIVER_NAME			"intel_cln_esram_test"
+
+/**
+ * struct intel_cln_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_esram_test_dev{
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+	char * pdata;
+	u32 size;
+};
+
+static struct intel_cln_esram_test_dev esram_test_dev;
+static struct class *esram_test_class;
+static DEFINE_MUTEX(esram_test_mutex);
+static int esram_test_major;
+static char * name = "testmap";
+
+/******************************************************************************
+ *                                eSRAM BIST
+ ******************************************************************************/
+
+static int crc_cache = 0;
+
+unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
+{
+	if (first < end)
+		return end - first;
+	else
+		return (ULLONG_MAX - first) + end;	
+}
+
+
+/**
+ * intel_cln_crctest
+ *
+ * Do a CRC32 of the specified region. Return the time taken in jiffies
+ */
+static unsigned long long intel_cln_crctest(char * pdata, u32 crcsize)
+{
+	unsigned long long j1 = 0, j2 = 0;
+	
+	rdtscll(j1);
+
+	/* Flush LMT cache to introduce cache miss to our test */
+	__asm__ __volatile__("wbinvd\n");
+	crc32(0, pdata, crcsize);
+
+	rdtscll(j2);
+
+	return tsc_delta(j1, j2);
+}
+
+#ifdef __DEBUG__
+#define bist_err(x){\
+	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
+	return x;\
+}
+#else
+#define bist_err(x){\
+	return x;\
+}
+#endif
+/**
+ * intel_cln_esram_perpage_overlay
+ *
+ * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
+ */
+int intel_cln_esram_test_perpage_overlay(void)
+{
+
+	int ret = 0;
+	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+
+	/* Basic test of full range of memory */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+
+#if 0
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_pageref_count
+ *
+ * Ensure page reference couting works as expected
+ */
+int intel_cln_esram_test_pagref_count(void)
+{
+	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE;
+	int ret = 0;
+
+	return 0;
+	/* Map a page */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map a second time - and verify mapping fails */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+
+#if 0
+	/* Unmap - OK */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Verify second unmap operation fails */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+#endif	
+	return 0;
+}
+
+extern uint32_t get_crc32table_le(void);
+
+/**
+ * intel_cln_esram_test_contig_perfmetric
+ *
+ * Do a CRC16 for a contigous area of memory
+ * Map contigous area and get a CRC16
+ *
+ * Ensure overlayed data takes less time than regular unoverlayed DRAM
+ */
+int intel_cln_esram_test_contig_perfmetric(void)
+{
+	u32 crcsize = 0x60000;
+	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
+	uint32_t crc32table_le = kallsyms_lookup_name("crc32table_le");
+	int ret = 0;
+
+	if (crc32table_le == 0){
+		pr_err("%s unable to fine symbol crc32table_le\n", __func__);
+		return -ENODEV;
+	}
+
+	/* Get raw data metric */
+	crc_cache = 1;
+	crc32_fullunmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
+
+	/* Map CRC16 symbol (algorithm) + code (data) */
+	ret = intel_cln_esram_map_symbol(crc32_le);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_map_symbol((void*)crc32table_le);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map test data */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	/* Get metric */
+	crc_cache = 1;
+	crc32_fullmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
+#if 0
+	/* Tidy up */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_unmap_range(((void*)crc32_table),
+					  sizeof(crc32_table), name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_unmap_symbol(crc32);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
+	pr_info("%s mapped count %llu unmapped %llu\n",
+		__func__, crc32_fullmap, crc32_fullunmap);
+	return crc32_fullmap < crc32_fullunmap;
+}
+
+/**
+ * intel_cln_esram_test_kernel_codemap
+ *
+ * Maps some kernel code - a data section and then calls the code contained
+ * therein. Proves out the running overlayed eSRAM works
+ */
+int intel_cln_esram_test_kernel_codemap(void)
+{
+#if 0
+	int ret = intel_cln_esram_map_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+	
+	/* run the mapped code */
+	msleep(1);
+
+	/* unmap */	
+	ret = intel_cln_esram_unmap_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_kernel_datamap
+ *
+ * Tests mapping/unmapping of a kernel data structure
+ */
+int intel_cln_esram_test_kernel_datamap(void)
+{
+#if 0
+	unsigned long jtag = 0;
+	unsigned long ctrl = 0;
+
+	/* Map the interrupt descriptor table */
+	int ret = intel_cln_esram_map_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	jtag = jiffies;
+	/* Wait for jiffies to tick or timeout to occur (failure) */
+	while(jtag == jiffies){
+		ctrl++;
+	}
+
+	/* unmap */	
+	ret = intel_cln_esram_unmap_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_sub_unsub
+ *
+ * Subscribe and unsubscribe 100% of available eSRAM
+ */
+int intel_cln_esram_test_sub_unsub(void)
+{
+	int ret = 0;
+	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE * INTEL_CLN_ESRAM_PAGE_COUNT;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+	/* Basic test of full range of memory */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+#if 0
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_over_sub
+ *
+ * Test oversubscription of eSRAM
+ */
+int intel_cln_esram_test_over_sub(void)
+{
+	int ret = 0;
+	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE * (INTEL_CLN_ESRAM_PAGE_COUNT + 1);
+
+	/* Over subscribe should fail */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		//intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+		bist_err(-EFAULT);
+	}
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long esram_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	cmd -= CLN_ESRAM_IOCTL_BASE;
+	switch (cmd) {
+		case CLN_F_SW_APP_ESRAM_0:
+			/* Per page overlay */
+			ret = intel_cln_esram_test_perpage_overlay();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_1:
+			/* Verify page reference counting */
+			ret = intel_cln_esram_test_pagref_count();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_2:
+			/* Performance metric or overlay contig RAM */
+			ret = intel_cln_esram_test_contig_perfmetric();
+			if (ret == 1)
+				ret = 0;
+			break;
+
+		case CLN_F_SW_APP_ESRAM_3:
+			/* Verify mapping of kernel code section */
+			/* Covered by test #2 */
+			ret = 0; //intel_cln_esram_test_kernel_codemap();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_4:
+			/* Verify mapping of kernel data section (IDT) */
+			/* Covered by test #2 */
+			ret = 0; //intel_cln_esram_test_kernel_datamap();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_5:
+			/* Complete subscribe/unsubscribe eSRAM */
+			ret = intel_cln_esram_test_sub_unsub();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_6:
+			/* Over subscribe eSRAM */
+			ret = intel_cln_esram_test_over_sub();
+			break;
+
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int esram_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
+		mutex_unlock(&esram_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (esram_test_dev.opened) {
+		mutex_unlock(&esram_test_dev.open_lock);
+		mutex_unlock(&esram_test_mutex);
+		return -EINVAL;
+	}
+
+	esram_test_dev.opened++;
+	mutex_unlock(&esram_test_dev.open_lock);
+	mutex_unlock(&esram_test_mutex);
+
+	return 0;
+}
+
+static int esram_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_dev.open_lock);
+	esram_test_dev.opened = 0;
+	mutex_unlock(&esram_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations esram_test_file_ops = {
+	.open = esram_test_open,
+	.release = esram_test_release,
+	.unlocked_ioctl = esram_test_ioctl,
+	.llseek = no_llseek,
+};
+
+
+/**
+ * intel_cln_esram_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_esram_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	esram_test_dev.size = INTEL_CLN_ESRAM_PAGE_COUNT * INTEL_CLN_ESRAM_PAGE_SIZE;
+
+	/* Get memory */
+	esram_test_dev.pdata = kzalloc(esram_test_dev.size, GFP_KERNEL);
+	if(unlikely(esram_test_dev.pdata == NULL)){
+		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
+		return -ENOMEM;
+	}
+
+	mutex_init(&esram_test_dev.open_lock);
+	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
+	esram_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(esram_test_class, NULL,
+				 MKDEV(esram_test_major, minor), NULL,
+				 "esramtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s/%s/%s complete OK !!\n", __FUNCTION__, __DATE__,__TIME__);
+	return 0;
+
+}
+
+/**
+ * intel_cln_esram_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_esram_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
+
+	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
+	cdev_del(&esram_test_dev.cdev);
+	kfree(esram_test_dev.pdata);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_esram_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_esram_test_remove,
+};
+
+/**
+ * intel_cln_esram_init
+ *
+ * @return 0 success < 0 failure
+ *
+ * Module entry point
+ */
+static int __init intel_cln_esram_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	esram_test_class = class_create(THIS_MODULE,"cln_esram_test");
+	if (IS_ERR(esram_test_class)) {
+		retval = PTR_ERR(esram_test_class);
+		printk(KERN_ERR "esram_test: can't register earam_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	esram_test_major = MAJOR(dev);
+
+	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
+	esram_test_dev.pldev = platform_create_bundle(
+		&intel_cln_esram_test_driver, intel_cln_esram_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(esram_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(esram_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(esram_test_class);
+err:
+	return retval;
+}
+
+/**
+ * intel_cln_esram_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_esram_test_exit(void)
+{
+	platform_device_unregister(esram_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_esram_test_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton eSRAM ITS driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_init(intel_cln_esram_test_init);
+module_exit(intel_cln_esram_test_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_esram_test.h b/drivers/platform/x86/quark/intel_cln_esram_test.h
new file mode 100644
index 0000000..98e4546
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_esram_test.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_esram_test.h
+ *
+ * Define integers for ioctl operation
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+
+#ifndef __INTEL_CLN_ESRAM_TEST_H__
+#define __INTEL_CLN_ESRAM_TEST_H__
+
+#define CLN_ESRAM_IOCTL_BASE	255
+#define CLN_F_SW_APP_ESRAM_0	0x00000000
+#define CLN_F_SW_APP_ESRAM_1	0x00000001
+#define CLN_F_SW_APP_ESRAM_2	0x00000002
+#define CLN_F_SW_APP_ESRAM_3	0x00000003
+#define CLN_F_SW_APP_ESRAM_4	0x00000004
+#define CLN_F_SW_APP_ESRAM_5	0x00000005
+#define CLN_F_SW_APP_ESRAM_6	0x00000006
+#define CLN_F_SW_APP_ESRAM_7	0x00000007
+#define CLN_F_SW_APP_ESRAM_8	0x00000008
+
+#endif /* __INTEL_CLN_ESRAM_TEST_H__ */
+
diff --git a/drivers/platform/x86/quark/intel_cln_imr.c b/drivers/platform/x86/quark/intel_cln_imr.c
new file mode 100644
index 0000000..b8259a6
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_imr.c
@@ -0,0 +1,584 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * A total number of 8 IMRs have implemented by Clanton SoC,
+ * Some IMRs might be already occupied by BIOS or Linux during
+ * booting time.
+ *
+ * A user can cat /sys/devices/platform/intel-cln-imr/status for current IMR
+ * status 
+ *
+ * To allocate an IMR addresses must be alinged to 1k
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, then apply the input access right masks
+ *
+ * The IMR can be freed with the pre-allocated memory addresses.
+ */
+
+#include <asm-generic/uaccess.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/proc_fs.h>
+
+#include "intel_cln_imr.h"
+#include <asm/imr.h>
+
+#define DRIVER_NAME	"intel-cln-imr"
+
+#define IMR_READ_MASK	0x1
+#define IMR_MAX_ID	7
+
+#ifndef phys_to_virt
+#define phys_to_virt __va
+#endif
+
+/* IMR HW register address structre */
+struct cln_imr_reg_t {
+	u8  imr_xl;   /* high address register */
+	u8  imr_xh;   /* low address register */
+	u8  imr_rm;   /* read mask register */
+	u8  imr_wm;   /* write mask register */
+} cln_imr_reg_t;
+
+/**
+ * struct cln_imr_addr_t
+ *
+ * IMR memory address structure
+ */
+struct cln_imr_addr_t {
+	u32 addr_low;      /* low boundary memroy address */
+	u32 addr_high;     /* high boundary memory address */
+	u32 read_mask;     /* read access right mask */
+	u32 write_mask;    /* write access right mask */
+} cln_imr_addr_t;
+
+/**
+ * struct cln_imr_pack
+ *
+ * local IMR pack structure
+ */
+struct cln_imr_pack {
+	bool occupied;       /* IMR occupied */
+	bool locked;         /* IMR lock */
+	struct cln_imr_reg_t reg;   /* predefined imr register address */
+	struct cln_imr_addr_t addr; /* IMR address region structure */
+	unsigned char info[MAX_INFO_SIZE]; /* IMR info */
+} cln_imr_pack;
+
+
+/* Predefined HW register address */
+static struct cln_imr_reg_t imr_reg_value[] = {
+	{ IMR0L, IMR0H, IMR0RM, IMR0WM },
+	{ IMR1L, IMR1H, IMR1RM, IMR1WM },
+	{ IMR2L, IMR2H, IMR2RM, IMR2WM },
+	{ IMR3L, IMR3H, IMR3RM, IMR3WM },
+	{ IMR4L, IMR4H, IMR4RM, IMR4WM },
+	{ IMR5L, IMR5H, IMR5RM, IMR5WM },
+	{ IMR6L, IMR6H, IMR6RM, IMR6WM },
+	{ IMR7L, IMR7H, IMR7RM, IMR7WM }
+};
+
+static struct platform_device *pdev;
+
+/**
+ * module parameter
+ * IMR slot should repersant the available IMR region from
+ * linux boot and BIOS.
+ *
+ * For example: imr_bit_mask = 0x10111001
+ * occupied IMR: 0, 3, 4, 5, 7
+ * un-occupied IMR: 1, 2, 6
+ */
+static int imr_bit_mask = 0xFF;
+module_param(imr_bit_mask, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_bit_mask, "IMR bit mask");
+
+/**
+ * module parameter
+ * if IMR lock is a nozero value, all unlocked
+ * imrs will be locked regardless the usage.
+ */
+static int imr_lock = 0;
+module_param(imr_lock, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_lock, "switch to lock unused IMR");
+
+/* local IMR data structure */
+struct cln_imr_pack local_imr[IMR_MAXID];
+
+/**
+ * intel_cln_imr_read_reg
+ *
+ * @param reg: register address
+ * @return nothing
+ *
+ * return register value from input address.
+ */
+static inline uint32_t intel_cln_imr_read_reg(uint8_t reg)
+{
+	uint32_t temp = 0;
+
+	intel_cln_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE, reg, &temp, 0);
+	return temp;
+}
+
+/**
+ * intel_clm_imr_latch_data
+ *
+ * @return nothing
+ *
+ * Populate IMR data structure from HW.
+ */
+static inline void intel_clm_imr_latch_data(void)
+{
+	int i = 0;
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		local_imr[i].addr.addr_low =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
+		local_imr[i].addr.addr_high =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xh);
+		local_imr[i].addr.read_mask =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_rm);
+		local_imr[i].addr.write_mask =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_wm);
+
+		if (local_imr[i].addr.addr_low & IMR_LOCK_BIT)
+			local_imr[i].locked = true;
+
+		if (local_imr[i].addr.read_mask > 0 &&
+			local_imr[i].addr.read_mask < IMR_READ_ENABLE_ALL){
+			local_imr[i].occupied = true;
+		} else {
+			local_imr[i].occupied = false;
+			memcpy(local_imr[i].info, "NOT USED", MAX_INFO_SIZE);
+		}
+	}
+}
+
+/**
+ * prepare_input_addr
+ *
+ * @param addr: input physical memory address
+ * @return formated memory address
+ *
+ * 1. verify input memory address alignment
+ * 2. apply IMR_REG_MASK to match the format required by HW
+ */
+static inline uint32_t prepare_input_addr(uint32_t addr)
+{
+	if (addr & (IMR_MEM_ALIGN - 1))
+		return 0;
+
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * intel_cln_imr_find_free_entry
+ *
+ * @return the next free imr slot
+ */
+static int intel_cln_imr_find_free_entry(void)
+{
+	int i = 0;
+
+	intel_clm_imr_latch_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if ((!local_imr[i].occupied) && (!local_imr[i].locked))
+			return i;
+	}
+
+	pr_err("%s: No more free IMR available.\n", __func__);
+	return -ENOMEM;
+}
+
+/**
+ * intel_cln_imr_add_entry
+ *
+ * @param id: imr slot id
+ * @param hi: hi memory address
+ * @param lo: lo memory address
+ * @param read: read access mask
+ * @param write: write access mask
+ * @return nothing
+ *
+ * Setup an IMR entry
+ */
+static void intel_cln_imr_add_entry(int id, uint32_t hi,
+		uint32_t lo, uint32_t read, uint32_t write, bool lock)
+{
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, lo, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, hi, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, read, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, write, 0);
+	if (lock) {
+		lo |= IMR_LOCK_BIT;
+		intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+					imr_reg_value[id].imr_xl, lo, 0);
+	}
+}
+
+/**
+ * get_phy_addr
+ * @return phy address value
+ *
+ * convert register format to physical address format.
+ */
+static uint32_t get_phy_addr(uint32_t reg_value)
+{
+	reg_value = ((reg_value & IMR_REG_MASK) << 8);
+	return reg_value;
+}
+
+
+
+/**
+ * intel_cln_imr_init_mask
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * prepare local IMR data structure from input module parameter.
+ */
+static void intel_cln_imr_init_mask(int mask)
+{
+	int i = 0;
+
+	BUG_ON((mask > 255 || mask < 0));
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].addr.addr_low =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
+
+		/* mask bit 1 means imr occupied*/
+		if (((mask>>i) & IMR_READ_MASK) == 0) {
+			if (!(local_imr[i].addr.addr_low & IMR_LOCK_BIT))
+				intel_cln_remove_imr_entry(i);
+		}
+	}
+}
+
+/**
+ * intel_cln_remove_imr_entry
+ *
+ * @param id: imr slot id
+ * @return nothing
+ *
+ * remove imr slot based on input id
+ */
+void intel_cln_remove_imr_entry(int id)
+{
+	if (id >= IMR_MAXID || local_imr[id].locked)
+		return;
+
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, IMR_READ_ENABLE_ALL,
+				0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, IMR_WRITE_ENABLE_ALL,
+				0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, IMR_BASE_ADDR, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, IMR_BASE_ADDR, 0);
+
+	intel_clm_imr_latch_data();
+
+}
+EXPORT_SYMBOL(intel_cln_remove_imr_entry);
+
+/**
+ * intel_cln_imr_alloc
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @param read: IMR read mask value
+ * @param write: IMR write mask value
+ * @return nothing
+ *
+ * setup the next available IMR with customized read and write masks
+ */
+int intel_cln_imr_alloc(uint32_t high, uint32_t low, uint32_t read,
+			uint32_t write, unsigned char *info, bool lock)
+{
+	int id = 0;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	if ((low & IMR_LOCK_BIT) || (read == 0 || write == 0)) {
+		pr_err("%s: Invalid acces mode\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Calculate aligned addresses and validate range */
+	high = prepare_input_addr(high);
+	low = prepare_input_addr(low);
+
+	/* Find a free entry */
+	id = intel_cln_imr_find_free_entry();
+	if (id < 0)
+		return -ENOMEM;
+
+	/* Add entry - locking as necessary */
+	intel_cln_imr_add_entry(id, high, low, (read & IMR_READ_ENABLE_ALL),
+				write, lock);
+
+	/* Name the new entry */
+	memcpy(local_imr[id].info, info, MAX_INFO_SIZE);
+
+	/* Update local data structures */
+	intel_clm_imr_latch_data();
+
+	pr_info("IMR alloc id %d 0x%08x - 0x%08x %s\n", id, low, high,
+		lock ? "locked" : "unlocked");
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_alloc);
+
+/**
+ * intel_cln_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @return nothing
+ *
+ * remove the imr based on input memory region
+ */
+int intel_cln_imr_free(uint32_t high, uint32_t low)
+{
+	int i = 0;
+
+	if (low > high) {
+		pr_err("%s: Invalid input address values.\n", __func__);
+		return -EINVAL;
+	}
+
+	high = prepare_input_addr(high);
+	if (!high) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	low = prepare_input_addr(low);
+	if (!low) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if (local_imr[i].occupied
+			&& (local_imr[i].addr.addr_low == low)
+			&& (local_imr[i].addr.addr_high == high)
+			&& (!local_imr[i].locked)) {
+				intel_cln_remove_imr_entry(i);
+				return 0;
+			}
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(intel_cln_imr_free);
+
+/**
+ * intel_cln_imr_init_data
+ *
+ * @return nothing
+ * initialize local_imr data structure
+ */
+static void intel_cln_imr_init_data(void)
+{
+	int i = 0;
+	char * res_str = "System Reserved Region";
+	int len = strlen(res_str);
+
+	intel_clm_imr_latch_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].reg = imr_reg_value[i];
+		memcpy(local_imr[i].info, res_str, len);
+	}
+}
+
+/**
+ * intel_cln_imr_lockall
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * lock up all un-locked IMRs
+ */
+int intel_cln_imr_lockall(void)
+{
+	int i = 0;
+	uint32_t temp_addr;
+
+	/* Enumerate IMR data structures */
+	intel_cln_imr_init_data();
+	intel_cln_imr_init_mask(imr_bit_mask);
+
+	/* Cycle through IMRs locking whichever are unlocked */
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		temp_addr = local_imr[i].addr.addr_low;
+		if (!(temp_addr & IMR_LOCK_BIT)) {
+
+			DBG("%s: locking IMR %d\n", __func__, i);
+			temp_addr |= IMR_LOCK_BIT;
+			intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+						local_imr[i].reg.imr_xl,
+						temp_addr, 0);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_lockall);
+
+/**
+ * intel_cln_imr_stat_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates IMR state via /sys/device/intel-cln-imr/stat
+ */
+static int intel_cln_imr_stat_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int len = 0;
+	int i = 0;
+	int size, count = PAGE_SIZE;
+	uint32_t hi_phy_addr, lo_phy_addr;
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		/* read back the actual  input physical memory address */
+		hi_phy_addr = get_phy_addr(local_imr[i].addr.addr_high);
+		lo_phy_addr = get_phy_addr(local_imr[i].addr.addr_low);
+
+		/* the IMR always protect extra 1k memory size above the input
+		 * high reg value
+		 */
+		size = ((hi_phy_addr - lo_phy_addr) / IMR_MEM_ALIGN) + 1;
+
+		size = snprintf(buf+len, count,
+				"imr - id : %d\n"
+				"info     : %s\n"
+				"occupied : %s\n"
+				"locked   : %s\n"
+				"size     : %d kb\n"
+				"hi addr (phy): 0x%08x\n"
+				"lo addr (phy): 0x%08x\n"
+				"hi addr (vir): 0x%08x\n"
+				"lo addr (vir): 0x%08x\n"
+				"read mask  : 0x%08x\n"
+				"write mask : 0x%08x\n\n",
+				i,
+				local_imr[i].info,
+				local_imr[i].occupied ? "yes" : "no",
+				local_imr[i].locked ? "yes" : "no",
+				size,
+				hi_phy_addr,
+				lo_phy_addr,
+				(uint32_t)phys_to_virt(hi_phy_addr),
+				(uint32_t)phys_to_virt(lo_phy_addr),
+				local_imr[i].addr.read_mask,
+				local_imr[i].addr.write_mask);
+		len += size;
+		count -= size;
+	}
+	return len;
+}
+
+static struct device_attribute dev_attr_stats = {
+	.attr = {
+		.name = "stat",
+		.mode = 0444, },
+	.show = intel_cln_imr_stat_show,
+};
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_stats.attr,
+	NULL,
+};
+
+static struct attribute_group imr_attrib_group = {
+	.attrs = platform_attributes
+};
+
+/**
+ * intel_cln_imr_init
+ *
+ * @return 0 success < 0 failue
+ *
+ * module entry point
+ */
+int  __init intel_cln_imr_init(void)
+{
+	int ret;
+
+	pdev = platform_device_alloc(DRIVER_NAME, -1);
+	if (!pdev)
+		return -ENOMEM;
+
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto fail_platform;
+
+	/* initialise local imr data structure */
+	intel_cln_imr_init_data();
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &imr_attrib_group);
+	if (ret)
+		goto fail_platform;
+
+	if(intel_cln_imr_runt_setparams() == 0 && imr_lock == 1){
+                intel_cln_imr_lockall();
+        }
+
+	return 0;
+
+fail_platform:
+	platform_device_del(pdev);
+	return ret;
+}
+EXPORT_SYMBOL(intel_cln_imr_init);
+
+MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_cln_imr.h b/drivers/platform/x86/quark/intel_cln_imr.h
new file mode 100644
index 0000000..3861d60
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_imr.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * A total number of 8 IMRs have implemented by Clanton SoC,
+ * some IMRs might be already occupied by BIOS or Linux booting time.
+ *
+ * Input addresses parameter required the actual Physical address.
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, and apply with the default access right
+ * (CPU & CPU_snoop enable).
+ *
+ * The alloc_mask API takes input read & write masks values to set up
+ * IMR with customized access right.
+ *
+ * User can free IMR with pre-alloc specified addresses.
+ */
+
+#ifndef __INTEL_CLN_IMR_H__
+#define __INTEL_CLN_IMR_H__
+
+#include <linux/intel_cln_sb.h>
+#include "asm/io.h"
+
+#define CFG_READ_OPCODE         0x10    /* BUnit Control Read */
+#define CFG_WRITE_OPCODE        0x11    /* BUnit control write */
+
+/* DRAM IMR register addresses */
+#define IMR0L			0x40
+#define IMR0H			0x41
+#define IMR0RM			0x42
+#define IMR0WM			0x43
+#define IMR1L			0x44
+#define IMR1H			0x45
+#define IMR1RM			0x46
+#define IMR1WM			0x47
+#define IMR2L			0x48
+#define IMR2H			0x49
+#define IMR2RM			0x4A
+#define IMR2WM			0x4B
+#define IMR3L			0x4C
+#define IMR3H			0x4D
+#define IMR3RM			0x4E
+#define IMR3WM			0x4F
+#define IMR4L			0x50
+#define IMR4H			0x51
+#define IMR4RM			0x52
+#define IMR4WM			0x53
+#define IMR5L			0x54
+#define IMR5H			0x55
+#define IMR5RM			0x56
+#define IMR5WM			0x57
+#define IMR6L			0x58
+#define IMR6H			0x59
+#define IMR6RM			0x5A
+#define IMR6WM			0x5B
+#define IMR7L			0x5C
+#define IMR7H			0x5D
+#define IMR7RM			0x5E
+#define IMR7WM			0x5F
+
+#define IMR_LOCK_BIT            0x80000000
+#define IMR_WRITE_ENABLE_ALL    0xFFFFFFFF
+#define IMR_READ_ENABLE_ALL     0xBFFFFFFF
+#define IMR_REG_MASK            0xFFFFFC
+
+#define IMR_ESRAM_FLUSH_INIT	0x80000000  /* esram flush */
+#define IMR_SNOOP_ENABLE	0x40000000  /* core snoops */
+#define IMR_PUNIT_ENABLE	0x20000000
+#define IMR_SMM_ENABLE		0x02        /* core SMM access */
+#define IMR_NON_SMM_ENABLE	0x01        /* core non-SMM access */
+#define IMR_BASE_ADDR           0x00
+#define IMR_MEM_ALIGN           0x400
+
+#define MAX_INFO_SIZE           64
+#define IMR_MAXID		8
+
+/* snoop + Non SMM write mask */
+#define IMR_DEFAULT_MASK	(IMR_SNOOP_ENABLE \
+				+ IMR_ESRAM_FLUSH_INIT \
+				+ IMR_NON_SMM_ENABLE)
+
+/* debug printk */
+#ifdef DEBUG
+#define DBG(args...) pr_info(args)
+#else
+#define DBG(args...)
+#endif
+
+extern unsigned long  _text;
+extern unsigned long  __init_begin;
+
+/**
+ * intel_cln_imr_alloc
+ *
+ * @param high: the end of physical memory address
+ * @param low: the start of physical memory address
+ * @param read: IMR read mask value
+ * @param write: IMR write maks value
+ * @param info: imr information
+ * @param lock: imr lock
+ *
+ * Setup imr with customised read/ write masks
+ */
+int intel_cln_imr_alloc(u32 high, u32 low, u32 read, u32 write,
+			unsigned char *info, bool lock);
+
+/**
+ * intel_cln_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ *
+ * remove the imr based on input memory region
+ */
+int intel_cln_imr_free(u32 high, u32 low);
+
+/**
+ * intel_cln_remove_imr_entry
+ *
+ * @param id: internal imr data struct id
+ *
+ * Remove imr based on input imr data structure id
+ */
+void intel_cln_remove_imr_entry(int id);
+
+/**
+ * intel_cln_imr_init
+ *
+ * Initialise IMRs
+ */
+int intel_cln_imr_init(void);
+
+#endif
diff --git a/drivers/platform/x86/quark/intel_cln_imr_kernel.c b/drivers/platform/x86/quark/intel_cln_imr_kernel.c
new file mode 100644
index 0000000..51e8676
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_imr_kernel.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * The IMR id 3 is pre-defined as the use for kernel data protection
+ *
+ * The early imr protects entire memory (from the beginning of kernel text
+ * section to the top of memory) during linux boot time. In the linux run
+ * time, the protection need to resize down to memory region that only
+ * contains: kernel text, read only data, and initialized data section.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/clanton.h>
+#include <linux/printk.h>
+#include "intel_cln_imr.h"
+
+/* pre-defined imr id for uncompressed kernel */
+#define IMR_KERNEL_ID	3
+
+/**
+ * addr_hw_ready
+ *
+ * shift input address value to match HW required 1k aligned format
+ */
+static inline uint32_t addr_hw_ready(uint32_t addr)
+{
+	/* memory alignment */
+	addr &= (~((1 << 10) - 1));
+
+	/* prepare input addr in HW required format */
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * void intel_cln_imr_runt_kerndata_setup
+ *
+ * Setup imr for kernel text, read only data section
+ *
+ * The read only data (rodata) section placed between text and initialized data
+ * section by kernel.
+ */
+static void intel_cln_imr_runt_kerndata_setup(void)
+{
+	uint32_t hi;
+	uint32_t lo;
+
+	hi = (uint32_t)virt_to_phys(&__init_begin);
+	lo = (uint32_t)virt_to_phys(&_text);
+
+	/* Set a locked IMR around the kernel .text section */
+	if (intel_cln_imr_alloc((hi - IMR_MEM_ALIGN), lo,
+				IMR_DEFAULT_MASK, IMR_DEFAULT_MASK,
+				"KERNEL RUNTIME DATA", 1)) {
+		pr_err("IMR: Set up runtime kernel data imr faild!\n");
+		return;
+	}
+}
+
+/**
+ * intel_cln_imr_teardown_unlocked
+ *
+ * Remove any unlocked IMR
+ *
+ */
+static void intel_cln_imr_teardown_unlocked(void)
+{
+	int i = 0;
+	for (i = 0; i < IMR_MAXID; i++)
+		intel_cln_remove_imr_entry(i);
+}
+
+/**
+ * intel_cln_imr_runt_setparams
+ *
+ * set imr range for text, read only, initialised data in linux run time
+ */
+int intel_cln_imr_runt_setparams(void)
+{
+	/* Setup an IMR around the kernel .text area */
+	intel_cln_imr_runt_kerndata_setup();
+
+	/* Remove any other unlocked IMR */
+	intel_cln_imr_teardown_unlocked();
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_runt_setparams);
+
+/**
+ * intel_cln_imr_runt_init
+ *
+ * module entry point
+ */
+static int  __init intel_cln_imr_runt_init(void)
+{
+	return 0;
+}
+
+/**
+ * intel_cln_imr_runt_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_imr_runt_exit(void)
+{
+	/* do nothing */
+}
+
+MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
+subsys_initcall(intel_cln_imr_runt_init);
+module_exit(intel_cln_imr_runt_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_imr_test.c b/drivers/platform/x86/quark/intel_cln_imr_test.c
new file mode 100644
index 0000000..2d98507
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_imr_test.c
@@ -0,0 +1,357 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR Test module
+ *
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include "intel_cln_imr.h"
+
+#define DRIVER_NAME			"intel_cln_imr_test"
+
+/**
+ * XXX intel_cln_sb.h needs to be updated with SB_ID_PUNIT and change
+ * propagated. This is a workaround to make it look less ugly. */
+#define SB_ID_PUNIT			SB_ID_THERMAL
+
+/* Memory-mapped SPI Flash address */
+#define ILB_SPIFLASH_BASEADDR			0xFF800000
+/* PUnit DMA block transfer size, in bytes */
+#define SPI_DMA_BLOCK_SIZE			512
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define IMR_TEST_IOCTL_CODE			0xE1
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_CLN_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_CLN_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
+
+/*****************************************************************************/
+
+/**
+ * struct intel_cln_imr_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_imr_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_cln_imr_test_dev imr_test_dev;
+static struct class *imr_test_class;
+static DEFINE_MUTEX(imr_test_mutex);
+static int imr_test_major;
+
+/* PUnit DMA registers over side-band */
+#define PUNIT_SPI_DMA_COUNT_REG		0x60
+#define PUNIT_SPI_DMA_DEST_REG		0x61
+#define PUNIT_SPI_DMA_SRC_REG		0x62
+
+/**
+ * ilb_spi_dma_read 
+ *
+ * @param src: physical address in Legacy SPI Flash
+ * @param dst: physical address of destination
+ * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
+ *
+ * Read-access iLB SPI via PUnit DMA engine.
+ * 
+ */
+static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
+{
+	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
+		dma_block_count);
+
+	/* Setup source and destination addresses. */
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_SRC_REG, (u32) src, 0);
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_DEST_REG, (u32) dst, 0);
+
+	pr_info("%s: starting transaction\n", __func__);
+
+	/*
+	 * Setup the number of block to be copied over. Transaction will start
+	 * as soon as the register is filled with value.
+	 */
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_COUNT_REG, dma_block_count, 0);
+
+	/* Poll for completion. */
+	while (dma_block_count > 0) {
+		intel_cln_sb_read_reg(SB_ID_PUNIT, CFG_READ_OPCODE,
+			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count, 0); 
+	}
+
+	pr_info("%s: transaction completed\n", __func__);
+}
+
+/**
+ * punit_dma_sanity_check 
+ *
+ * @return 0 if success, 1 if failure
+ *
+ * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
+ * Flash block. 
+ */
+static int punit_dma_sanity_check(void)
+{
+	int err = 0;
+	u32 *buffer = NULL;
+	u32 buf_ph_addr = 0;
+
+	/* Allocate 512B buffer for 1 SPI Flash block */
+	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
+        if (!buffer) {
+		err = -ENOMEM;
+		goto end;
+	}
+
+	/* DMA first SPI Flash block into buffer */
+	buf_ph_addr = (u32)virt_to_phys(buffer);
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
+
+	kfree(buffer);
+end:
+	return err;
+}
+
+/**
+ * imr_violate_kernel_punit_dma 
+ *
+ * @return always 0
+ *
+ * PUnit-DMA access to the Uncompressed Kernel IMR.
+ * This is based on set_imr_kernel_data() in intel_cln_imr.c. Find the physical
+ * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
+ * 
+ */
+static int imr_violate_kernel_punit_dma(void)
+{
+	extern unsigned long _text;
+	u32 kernel_text = (u32)virt_to_phys(&_text);
+
+	/* We expect this to trigger an IMR violation reset */
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
+
+	/*
+	 * If we're still alive, we have a serious bug:
+	 * - we didn't appropriately target the IMR?
+	 * - if we have, weren't we prevented from accessing?
+	 * - if we weren't prevented, it's unlikely we're alive with a dirty
+	 *   text section
+	 */
+	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
+		__func__);
+
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long imr_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_CLN_SANITY_CHECK_PUNIT_DMA:
+			/* Check PUnit DMA actually works */
+			ret = punit_dma_sanity_check();
+			break;
+		case IOCTL_CLN_IMR_1:
+			/* Kernel IMR violation: PUnit DMA access */
+			ret = imr_violate_kernel_punit_dma();
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int imr_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
+		mutex_unlock(&imr_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (imr_test_dev.opened) {
+		mutex_unlock(&imr_test_dev.open_lock);
+		mutex_unlock(&imr_test_mutex);
+		return -EINVAL;
+	}
+
+	imr_test_dev.opened++;
+	mutex_unlock(&imr_test_dev.open_lock);
+	mutex_unlock(&imr_test_mutex);
+	return 0;
+}
+
+static int imr_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_dev.open_lock);
+	imr_test_dev.opened = 0;
+	mutex_unlock(&imr_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations imr_test_file_ops = {
+	.open = imr_test_open,
+	.release = imr_test_release,
+	.unlocked_ioctl = imr_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_cln_imr_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_cln_imr_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&imr_test_dev.open_lock);
+	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
+	imr_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(imr_test_class, NULL,
+				 MKDEV(imr_test_major, minor), NULL,
+				 "imrtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_cln_imr_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
+
+	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
+	cdev_del(&imr_test_dev.cdev);
+
+	class_destroy(imr_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_imr_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_imr_test_remove,
+};
+
+/**
+ * intel_cln_imr_test_init
+ *
+ * Load module.
+ */
+static int __init intel_cln_imr_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	imr_test_class = class_create(THIS_MODULE,"cln_imr_test");
+	if (IS_ERR(imr_test_class)) {
+		retval = PTR_ERR(imr_test_class);
+		printk(KERN_ERR "imr_test: can't register imr_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	imr_test_major = MAJOR(dev);
+
+	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
+	imr_test_dev.pldev = platform_create_bundle(
+		&intel_cln_imr_test_driver, intel_cln_imr_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(imr_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(imr_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(imr_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_cln_imr_test_exit(void)
+{
+	platform_device_unregister(imr_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_imr_test_driver);
+}
+
+module_init(intel_cln_imr_test_init);
+module_exit(intel_cln_imr_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Clanton IMR test module");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_cln_layout_data.c b/drivers/platform/x86/quark/intel_cln_layout_data.c
new file mode 100644
index 0000000..124bccf
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_layout_data.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define DRIVER_NAME "cln-layout-conf"
+static char __iomem * layout_conf_data;
+static int len;
+
+static ssize_t layout_conf_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	ssize_t plen = len+1;
+	if( plen > PAGE_SIZE )
+		plen = PAGE_SIZE;
+	memcpy(buf, layout_conf_data, plen);
+	return plen;
+}
+
+static struct kobj_attribute layout_conf_attr = 
+	__ATTR(layout_conf, 0644, layout_conf_show, NULL);
+
+static int intel_cln_layout_data_probe(struct platform_device *pdev)
+{
+	extern struct kobject * board_data_kobj;
+	int ret = 0;
+
+	layout_conf_data = ioremap(pdev->resource->start,
+		resource_size(pdev->resource));
+	if (!layout_conf_data)
+		return -ENODEV;
+
+	len = resource_size(pdev->resource);
+	ret = sysfs_create_file(board_data_kobj, &layout_conf_attr.attr);
+	if (ret != 0){
+		pr_err("failed to create sysfs entry for layout config\n");
+		iounmap(layout_conf_data);
+		layout_conf_data = NULL;
+	}
+
+	return ret;
+}
+
+static int intel_cln_layout_data_remove(struct platform_device *pdev)
+{
+	extern struct kobject * board_data_kobj;
+
+	if (layout_conf_data){
+		sysfs_remove_file(board_data_kobj, &layout_conf_attr.attr);
+		iounmap(layout_conf_data);
+		
+	}
+	return 0;
+}
+
+static struct platform_driver cln_layout_data_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_layout_data_probe,
+	.remove		= intel_cln_layout_data_remove,
+};
+
+module_platform_driver(cln_layout_data_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c b/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
new file mode 100644
index 0000000..90da1c8
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-clanton-hill"
+#define GPIO_RESTRICT_NAME "cln-gpio-restrict-nc"
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+#define AD7298_MAX_EXT_VIN_EXT_BATT 30000
+#define AD7298_MAX_EXT_VIN_INT_BATT 9200
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN_EXT_BATT, AD7298_MAX_EXT_VIN_INT_BATT }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_0_cs_0,
+	},
+};
+
+/******************************************************************************
+ *             ST Microelectronics LIS331DLH I2C Device Platform Data
+ ******************************************************************************/
+#include <linux/platform_data/lis331dlh_intel_cln.h>
+
+/* GPIO interrupt pins connected to the LIS331DLH */
+#define ST_ACCEL_INT1_GPIO 15
+#define ST_ACCEL_INT2_GPIO 4
+
+static struct lis331dlh_intel_cln_platform_data lis331dlh_i2c_platform_data = {
+	.irq1_pin = ST_ACCEL_INT1_GPIO,
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		ST_ACCEL_INT1_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int1"
+	},
+	{
+		ST_ACCEL_INT2_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int2"
+	},
+};
+
+static struct i2c_board_info i2c_onboard_devs[] = {
+	{
+		I2C_BOARD_INFO("intel-cln-max9867", 0x18),
+	},
+	{
+		I2C_BOARD_INFO("lis331dlh_cln", 0x19),
+		.platform_data  = &lis331dlh_i2c_platform_data,
+	},
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Hill platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+				       ARRAY_SIZE(spi_onboard_devs));
+}
+
+/**
+ * intel_cln_i2c_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard I2C device(s) present on the Clanton Hill platform
+ */
+static int intel_cln_i2c_add_onboard_devs(void)
+{
+	return i2c_register_board_info(0, i2c_onboard_devs,
+			ARRAY_SIZE(i2c_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = gpio_request_array(reserved_gpios,
+				     ARRAY_SIZE(reserved_gpios));
+	if (ret == 0)
+		ret = intel_cln_spi_add_onboard_devs();
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+static int intel_cln_plat_clanton_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = intel_cln_i2c_add_onboard_devs();
+	if (ret == 0)
+		ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_cln_plat_clanton_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_clanton_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_clanton_hill_probe,
+	.remove		= intel_cln_plat_clanton_hill_remove,
+};
+
+module_platform_driver(cln_clanton_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Clanton Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c b/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
new file mode 100644
index 0000000..27ca0ea
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-clanton-peak"
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Peak platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+static int intel_cln_plat_clanton_peak_probe(struct platform_device *pdev)
+{
+	return intel_cln_spi_add_onboard_devs();
+}
+
+static int intel_cln_plat_clanton_peak_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver clanton_peak_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_clanton_peak_probe,
+	.remove		= intel_cln_plat_clanton_peak_remove,
+};
+
+module_platform_driver(clanton_peak_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Clanton Peak BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
diff --git a/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c b/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
new file mode 100644
index 0000000..b79ce01
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
@@ -0,0 +1,387 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-cross-hill"
+#define GPIO_RESTRICT_NAME_NC "cln-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC "cln-gpio-restrict-sc"
+
+/*
+ * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
+ */
+#define SPI_BPEAK_RESET_GPIO 4
+#define SPI_BPEAK_ID0_GPIO   3
+#define SPI_BPEAK_ID1_GPIO   2
+#define SPI_BPEAK_ID2_GPIO   15
+#define SPI_BPEAK_ID3_GPIO   14
+
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
+static int cross_hill_probe;
+
+/*
+ * Blackburn Peak SPI daughterboard ID values
+ */
+enum {
+	CLN_SPI_BPEAK_ID_ZB_TI = 0xA,
+	CLN_SPI_BPEAK_ID_ZB_DIGI,
+	CLN_SPI_BPEAK_ID_ZB_INFR_NXP,
+	CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
+	CLN_SPI_BPEAK_ID_ADC_MAXIM,
+	CLN_SPI_BPEAK_ID_NONE
+};
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_1 = {
+	.gpio_cs = 11,
+};
+
+static struct spi_board_info spi_generic_devs[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_1_cs_0,
+	},
+
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 1,
+		.controller_data = &cln_ffrd_spi_1_cs_1,
+	},
+
+};
+
+static struct spi_board_info spi_energy_adc_devs[] = {
+	{
+		.modalias = "max78m6610_lmu",
+		.max_speed_hz = 2000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_3,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_1_cs_0,
+	},
+};
+
+
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Cross Hill platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	struct spi_board_info spi_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = 5000000,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &cln_ffrd_spi_0_cs_0,
+		},
+	};
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_cln_spi_get_bpeak_id
+ *
+ * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
+ * @return 0 on success or standard errnos on failure
+ *
+ * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
+ */
+static int intel_cln_spi_get_bpeak_id(u8 *bpeak_id)
+{
+	int ret = 0;
+	struct gpio spi_bpeak_id_gpios[] = {
+		{
+			SPI_BPEAK_RESET_GPIO,
+			GPIOF_OUT_INIT_HIGH,
+			"spi_bpeak_reset"
+		},
+		{
+			SPI_BPEAK_ID0_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id0"
+		},
+		{
+			SPI_BPEAK_ID1_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id1"
+		},
+		{
+			SPI_BPEAK_ID2_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id2"
+		},
+		{
+			SPI_BPEAK_ID3_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id3"
+		}
+	};
+
+	/*
+	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
+	 * while a RESET GPIO output is asserted (active-low)
+	 */
+	ret = gpio_request_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
+				__func__);
+		return ret;
+	}
+
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
+	*bpeak_id =
+		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
+
+	gpio_free_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+
+	return 0;
+}
+
+/**
+ * intel_cln_spi_add_bpeak_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers SPI device(s) indicated by the ID value obtained from a
+ * Blackburn Peak SPI daughterboard
+ */
+static int intel_cln_spi_add_bpeak_devs(void)
+{
+	u8 spi_bpeak_id = 0;
+	int ret = 0;
+
+	ret = intel_cln_spi_get_bpeak_id(&spi_bpeak_id);
+	if (ret) {
+		pr_err("%s: failed to obtain Blackburn Peak ID\n",
+				__func__);
+		return ret;
+	}
+
+	switch (spi_bpeak_id) {
+
+	case CLN_SPI_BPEAK_ID_NONE:
+		break;
+
+	case CLN_SPI_BPEAK_ID_ADC_MAXIM:
+		{
+			return spi_register_board_info(spi_energy_adc_devs,
+					ARRAY_SIZE(spi_energy_adc_devs));
+		}
+	case CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
+		{
+			pr_debug("CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+		}
+	case CLN_SPI_BPEAK_ID_ZB_DIGI:
+		{
+			pr_debug("CLN_SPI_BPEAK_ID_ZB_DIGI load.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+
+		}
+	default:
+			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
+					__func__, spi_bpeak_id);
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/** intel_cln_spi_devs_addon
+ *
+ * addon spi device when gpio support in place
+ */
+static int intel_cln_spi_devs_addon(void)
+{
+	int ret = 0;
+
+	if (cross_hill_probe != 1) {
+
+		ret = intel_cln_spi_add_onboard_devs();
+		if (ret)
+			return ret;
+
+		ret = intel_cln_spi_add_bpeak_devs();
+
+		cross_hill_probe = 1;
+	}
+
+	return ret;
+}
+
+/**
+ * intel_cln_gpio_restrict_probe_nc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	int ret;
+	nc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_cln_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_gpio_restrict_probe_sc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	int ret;
+	sc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_cln_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe_sc,
+};
+
+static int intel_cln_plat_cross_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&gpio_restrict_pdriver_sc);
+}
+
+static int intel_cln_plat_cross_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_cross_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_cross_hill_probe,
+	.remove		= intel_cln_plat_cross_hill_remove,
+};
+
+module_platform_driver(cln_cross_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Cross Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_cln_plat_data.c b/drivers/platform/x86/quark/intel_cln_plat_data.c
new file mode 100644
index 0000000..059fcee
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_data.c
@@ -0,0 +1,455 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/crc32.h>
+#include <linux/crc32c.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/clanton.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define PREFIX		"CLN-PLT: "
+#define PLAT_MAGIC	0x54414450	/* PDAT */
+#define DESC_LEN	0x0A
+#define MAC_STRLEN	20
+#define MAC_LEN		6
+
+struct cln_plat_dat_hdr {
+	uint32_t magic;
+	uint32_t length;
+	uint32_t crc32;
+};
+
+struct cln_plat_data {
+	uint16_t plat_id;
+	uint16_t length;
+	uint8_t desc[DESC_LEN];
+	uint16_t version;
+};
+
+struct cln_bsp_reg {
+	struct platform_device pdev;
+	cln_plat_id_t id;
+};
+
+static struct cln_bsp_reg bsp_data [] = {
+	{
+		.pdev.name	= "cln-plat-clanton-peak",
+		.pdev.id	= -1,
+		.id		= CLANTON_PEAK,
+	},
+	{
+		.pdev.name	= "cln-plat-kips-bay",
+		.pdev.id	= -1,
+		.id		= KIPS_BAY,
+	},
+	{
+		.pdev.name	= "cln-plat-cross-hill",
+		.pdev.id	= -1,
+		.id		= CROSS_HILL,
+	},
+	{
+		.pdev.name	= "cln-plat-clanton-hill",
+		.pdev.id	= -1,
+		.id		= CLANTON_HILL,
+	},
+	{
+		.pdev.name	= "cln-plat-galileo",
+		.pdev.id	= -1,
+		.id		= IZMIR,
+	},
+
+};
+
+/**
+ * struct cln_plat_data_list
+ *
+ * Structure to hold a linked list of platform data refs
+ */
+struct cln_plat_data_list {
+	char name[DESC_LEN+1];
+	struct cln_plat_data * plat_data;
+	struct kobj_attribute plat_attr;
+	struct list_head list;
+};
+
+static char __iomem * plat_data;
+static char * plat_bin_name = 	"pdat_bin";
+static unsigned int plat_bin_size;
+static struct cln_plat_dat_hdr * plat_hdr;
+static struct list_head entry_list;
+
+/**
+ * intel_cln_plat_sysfs_show_bin
+ *
+ * Generic show routine for any of the sysfs entries of this module
+ */
+static ssize_t intel_cln_plat_sysfs_show_bin(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	ssize_t plen = plat_bin_size;
+	if( plen > PAGE_SIZE )
+		plen = PAGE_SIZE;
+
+	memcpy(buf, plat_data, plen);
+	return plen;
+}
+
+/**
+ * intel_cln_plat_sysfs_show
+ *
+ * Generic show routine for any of the sysfs entries of this module
+ */
+static ssize_t intel_cln_plat_sysfs_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	unsigned char * data;
+	char fmt[0x20];
+	struct cln_plat_data_list * plat_item_list;
+	ssize_t plen = 0;
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		if ( attr == &plat_item_list->plat_attr ){
+
+			/* Derive length */
+			plen = plat_item_list->plat_data->length;
+			if (unlikely(plen > PAGE_SIZE))
+				plen = PAGE_SIZE;
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Enumrate return */
+			switch (plat_item_list->plat_data->plat_id){
+			case PLAT_DATA_ID:
+			case PLAT_DATA_SN:
+				snprintf(fmt, sizeof(fmt), "0x%%0%dx\n",
+					 plen*2);
+				return sprintf(buf, fmt, *(int16_t*)data);
+			case PLAT_DATA_MAC0:
+			case PLAT_DATA_MAC1:
+				if (unlikely(plen != MAC_LEN)){
+					return sprintf(buf, "invalid mac\n");
+				}
+				return snprintf(buf, MAC_STRLEN,
+					"%02x:%02x:%02x:%02x:%02x:%02x\n",
+					data[0], data[1], data[2], data[3],
+					data[4], data[5]);
+			default:
+				/* Treat as string data */
+				return snprintf(buf, plen, "%s", data);
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_plat_cleanup
+ *
+ * Generic cleanup code for the platform data interface
+ *
+ */
+static void intel_cln_plat_cleanup (void)
+{
+	extern struct kobject * board_data_kobj;
+	struct cln_plat_data_list * plat_item_list;
+
+	if (plat_data != NULL){
+		iounmap(plat_data);
+		plat_data = NULL;
+	}
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		sysfs_remove_file(board_data_kobj,
+				  &plat_item_list->plat_attr.attr);
+		kfree(plat_item_list);
+	}
+}
+
+/**
+ * intel_cln_plat_get_desc_len
+ *
+ * @param desc: Pointer to desc string
+ * @return len on success < 0 failure
+ *
+ * Function called to get a bounds checked desc field from platfrom data
+ *
+ */
+static int intel_cln_plat_get_desc_len (char * desc)
+{
+	int len = 0;
+	if (desc == NULL){
+		return -EINVAL;
+	}
+
+	for(; *desc != '\0' && len < DESC_LEN; desc++, len++);
+	return len;
+}
+
+/**
+ * intel_cln_get_id
+ *
+ * @return platform id on success or < CLANTON_PLAT_UNDEFINED on error
+ *
+ * Function called to get platform id
+ *
+ */
+cln_plat_id_t intel_cln_plat_get_id(void)
+{
+	unsigned char * data;
+	struct cln_plat_data_list * plat_item_list;
+
+	if (plat_data == NULL)
+		return CLANTON_PLAT_UNDEFINED;
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+
+		/* Enumrate return */
+		if(plat_item_list->plat_data->plat_id == PLAT_DATA_ID){
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Return payload */
+			return *(int16_t*)data;
+		}
+	}
+	return CLANTON_PLAT_UNDEFINED;
+}
+EXPORT_SYMBOL(intel_cln_plat_get_id);
+
+/**
+ * intel_cln_plat_get_mac
+ *
+ * @param id: Index of MAC address to find
+ * @param mac: Output parameter for mac address
+ *
+ * @return 0 success < 0 failure
+ *
+ * Function called to remove the platfrom device from kernel space
+ *
+ */
+int intel_cln_plat_get_mac(plat_dataid_t id, char * mac)
+{
+	unsigned char * data;
+	unsigned int plen = 0;
+	struct cln_plat_data_list * plat_item_list;
+
+	if ((id != PLAT_DATA_MAC0 && id != PLAT_DATA_MAC1) || mac == NULL){
+		pr_err("invalid input id %d mac %p\n", id, mac);
+		return -EINVAL;
+	}
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		if(plat_item_list->plat_data->plat_id == id){
+
+			/* Derive length */
+			plen = plat_item_list->plat_data->length;
+			if (unlikely(plen != MAC_LEN)){
+				pr_err("%s mac len invalid!\n", __func__);
+				return -ENODEV;
+			}
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Good to go */
+			memcpy(mac, data, MAC_LEN);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+EXPORT_SYMBOL(intel_cln_plat_get_mac);
+
+
+/**
+ * intel_cln_plat_probe
+ *
+ * @param pdev: Pointer to platform device
+ * @return 0 success < 0 failure
+ *
+ * Function called to probe platform device "cln-plat"
+ *
+ */
+int intel_cln_plat_probe(struct resource * pres)
+{
+	char __iomem * end_addr = NULL;
+	char __iomem * data = NULL;
+	cln_plat_id_t id = CLANTON_PLAT_UNDEFINED;
+	extern struct kobject * board_data_kobj;
+	struct cln_plat_data * plat_item = NULL;
+	struct cln_plat_data_list * plat_item_list = NULL;
+	u32 crc = 0;
+	int ret = 0, i = 0;
+
+	INIT_LIST_HEAD(&entry_list);
+	plat_hdr = ioremap(pres->start, resource_size(pres));
+	end_addr = (char*)plat_hdr + resource_size(pres);
+	plat_data = (char*)plat_hdr;
+	if (!plat_hdr)
+		return -ENODEV;
+
+	/* Verify header magic */
+	if (plat_hdr->magic != 	PLAT_MAGIC){
+		pr_err(PREFIX"Expected magic 0x%08x read 0x%08lx\n",
+			PLAT_MAGIC, (unsigned long)plat_hdr->magic);
+	}
+
+	/* Validate length is sane */
+	if ((char*)plat_hdr + plat_hdr->length > end_addr ||
+		plat_hdr->length < sizeof(struct cln_plat_data)){
+		pr_err(PREFIX"Invalid length 0x%08lx\n",
+			(unsigned long)plat_hdr->length);
+		return -ENODEV;
+	}
+
+	/* Point to real end addr */
+	end_addr = (char*)plat_hdr +
+			sizeof(struct cln_plat_dat_hdr) + plat_hdr->length;
+	plat_bin_size = end_addr - plat_data;
+
+	/* Get pointer to start of data */
+	plat_item = (struct cln_plat_data*)(plat_hdr+1);
+	data = ((char*)(plat_item)+sizeof(struct cln_plat_data));
+
+	/* Validate CRC32 */
+	crc = ~crc32(0xFFFFFFFF, plat_item, plat_hdr->length);
+	if (crc != plat_hdr->crc32){
+		pr_err(PREFIX"CRC 0x%08x header indicates 0x%08x - fatal!\n",
+			crc, plat_hdr->crc32);
+		return -EFAULT;
+	}
+
+	/* /sys/firmware/board_data/plat_bin - dump entire platform binary */
+	plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
+					 GFP_KERNEL);
+	if (unlikely(plat_item_list == NULL)) {
+		pr_err("kzalloc fail !\n");
+		intel_cln_plat_cleanup();
+		return -ENOMEM;
+	}
+	sysfs_attr_init(&plat_item_list->plat_attr.attr);
+	plat_item_list->plat_attr.attr.name = plat_bin_name;
+	plat_item_list->plat_attr.attr.mode = 0644;
+	plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show_bin;
+
+	ret = sysfs_create_file(board_data_kobj,
+				&plat_item_list->plat_attr.attr);
+	if (unlikely(ret != 0)){
+		intel_cln_plat_cleanup();
+		pr_err("failed to create sysfs entry\n");
+		return ret;
+	}
+
+	/* Add to list */
+	list_add(&plat_item_list->list, &entry_list);
+
+	/* Iterate through each entry - add sysfs entry as appropriate */
+	while ( (char*)plat_item < end_addr){
+	
+		/* Bounds check */
+		if (data + plat_item->length > end_addr){
+			pr_err(PREFIX"Data 0x%p over-runs max-addr 0x%p\n",
+				data, end_addr);
+			break;
+		}
+
+		/* Extract data */
+		switch(plat_item->plat_id){
+		case PLAT_DATA_ID:
+			id = *((uint16_t*)data);
+			pr_info(PREFIX"Clanton Platform ID = %d\n", id);
+			break;
+		case PLAT_DATA_SN:
+		case PLAT_DATA_MAC0:
+		case PLAT_DATA_MAC1:
+			break;
+		default:
+			/* Unknown identifier */
+			break;
+		}
+
+		plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
+					 GFP_KERNEL);
+		if (unlikely(plat_item_list == NULL)) {
+			pr_err("kzalloc fail !\n");
+			intel_cln_plat_cleanup();
+			return -ENOMEM;
+		}
+
+		/* Get name of entity */
+		i = intel_cln_plat_get_desc_len(plat_item->desc);
+		if (i <= 0){
+			pr_err("desc len is %d!\n", i);
+			intel_cln_plat_cleanup();
+			return i;
+		}
+
+		memcpy(plat_item_list->name, plat_item->desc, i);
+		plat_item_list->plat_data = plat_item;
+
+		sysfs_attr_init(&plat_item_list->plat_attr.attr);
+		plat_item_list->plat_attr.attr.name = plat_item_list->name;
+		plat_item_list->plat_attr.attr.mode = 0644;
+		plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show;
+
+		ret = sysfs_create_file(board_data_kobj,
+					&plat_item_list->plat_attr.attr);
+		if (unlikely(ret != 0)){
+			intel_cln_plat_cleanup();
+			pr_err("failed to create sysfs entry\n");
+			return ret;
+		}
+
+		/* Add to list */
+		list_add(&plat_item_list->list, &entry_list);
+
+		/* Next */
+		plat_item = (struct cln_plat_data*)
+			(((char*)plat_item) + plat_item->length + sizeof(struct cln_plat_data));
+		data = ((char*)(plat_item) + sizeof(struct cln_plat_data));
+	}
+
+	/* Register BSP enabling platform code */
+	for (i = 0; i < sizeof(bsp_data)/sizeof(struct cln_bsp_reg); i++){
+		if (bsp_data[i].id == id){
+			platform_device_register(&bsp_data[i].pdev);
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_cln_plat_probe);
diff --git a/drivers/platform/x86/quark/intel_cln_plat_galileo.c b/drivers/platform/x86/quark/intel_cln_plat_galileo.c
new file mode 100644
index 0000000..48ce294
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_galileo.c
@@ -0,0 +1,264 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c/at24.h>
+
+#define DRIVER_NAME 		"cln-plat-galileo"
+#define GPIO_RESTRICT_NAME 	"cln-gpio-restrict-sc"
+#define LPC_SCH_SPINAME		"spi-lpc-sch"
+
+#define CLN_SPI_MAX_CLK_DEFAULT		5000000
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+static struct at24_platform_data at24_platform_data = {
+	.byte_len = (11 * 1024),
+	.page_size = 1,
+	.flags = AT24_FLAG_ADDR16,
+};
+
+/******************************************************************************
+ *                        Intel Izmir i2c clients
+ ******************************************************************************/
+static struct i2c_board_info __initdata galileo_i2c_board_info[] = {
+	{
+		/* Note following address may change at driver load time */
+		I2C_BOARD_INFO("cy8c9540a", 0x20),
+	},
+	{
+		I2C_BOARD_INFO("at24", 0x50),
+		.platform_data = &at24_platform_data,
+	},
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+#define LPC_SCH_SPI_BUS_ID 0x03
+
+static struct platform_device lpc_sch_spi = {
+	.name = "spi-lpc-sch-drv",
+	.id = LPC_SCH_SPI_BUS_ID,
+};
+
+/* TODO: extract this data from layout.conf encoded in flash */
+struct mtd_partition ilb_partitions [] = {
+	{
+		.name		= "grub",
+		.size		= 4096,
+		.offset		= 0,
+	},
+	{
+		.name		= "grub.conf",
+		.size		= 0xA00,
+		.offset		= 0x50500,
+	},
+	{
+		.name		= "layout.conf",
+		.size		= 4096,
+		.offset		= 0x708000,
+	},
+	{
+		.name		= "sketch",
+		.size		= 0x40000,
+		.offset		= 0x750000,
+	},
+	{
+		.name		= "raw",
+		.size		= 8192000,
+		.offset		= 0,
+
+	},
+};
+
+static struct flash_platform_data ilb_flash = {
+	.type = "s25fl064k",
+	.parts = ilb_partitions,
+	.nr_parts = ARRAY_SIZE(ilb_partitions),
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "m25p80",
+		.platform_data = &ilb_flash,
+		.bus_num = LPC_SCH_SPI_BUS_ID,
+		.chip_select = 0,
+	},
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_0_cs_0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_1_cs_0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Izmir platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = intel_cln_spi_add_onboard_devs();
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+/* LPC SPI */
+static int intel_cln_plat_galileo_lpcspi_probe(struct platform_device *pdev)
+{
+	lpc_sch_spi.resource = pdev->resource;
+	return platform_device_register(&lpc_sch_spi);
+}
+
+static struct platform_driver intel_cln_plat_galileo_lpcspi_pdriver = {
+	.driver		= {
+		.name	= LPC_SCH_SPINAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_galileo_lpcspi_probe,
+};
+
+static int intel_cln_plat_galileo_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	/* i2c */
+	ret = i2c_register_board_info(0, galileo_i2c_board_info,
+		ARRAY_SIZE(galileo_i2c_board_info));
+	if (ret) {
+		goto end;
+	}
+
+	/* gpio */
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+	if (ret)
+		goto end;
+
+#if 0
+	/* legacy SPI - TBD */
+	ret = platform_driver_register(&intel_cln_plat_galileo_lpcspi_pdriver);
+	if (ret)
+		goto end;
+#endif	
+end:
+	return ret;
+}
+
+static int intel_cln_plat_galileo_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_galileo_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_galileo_probe,
+	.remove		= intel_cln_plat_galileo_remove,
+};
+
+module_platform_driver(cln_galileo_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Galileo BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c b/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
new file mode 100644
index 0000000..1f3deb2
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
@@ -0,0 +1,176 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-kips-bay"
+#define GPIO_RESTRICT_NAME "cln-gpio-restrict-sc"
+
+static int gpio_cs = 1;
+
+module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+static struct spi_board_info spi0_onboard_devs[] = {
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_0_cs_0,
+	}
+};
+
+static struct spi_board_info spi1_onboard_devs_gpiocs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+		.controller_data = &cln_ffrd_spi_1_cs_0,
+	},
+};
+
+static struct spi_board_info spi1_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Kips Bay platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	int ret = 0;
+
+	ret = spi_register_board_info(spi0_onboard_devs,
+				      ARRAY_SIZE(spi0_onboard_devs));
+	if (ret)
+		return ret;
+
+	if (gpio_cs)
+		return spi_register_board_info(spi1_onboard_devs_gpiocs,
+					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
+	else
+		return spi_register_board_info(spi1_onboard_devs,
+					ARRAY_SIZE(spi1_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	return intel_cln_spi_add_onboard_devs();
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+static int intel_cln_plat_kips_bay_probe(struct platform_device *pdev)
+{
+	return platform_driver_register(&gpio_restrict_pdriver);
+}
+
+static int intel_cln_plat_kips_bay_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_kips_bay_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_kips_bay_probe,
+	.remove		= intel_cln_plat_kips_bay_remove,
+};
+
+module_platform_driver(cln_kips_bay_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Kips Bay BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_cln_sb.c b/drivers/platform/x86/quark/intel_cln_sb.c
new file mode 100644
index 0000000..be27d6a
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_sb.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton side-band driver
+ *
+ * Thread-safe sideband read/write routine.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
+ */
+
+#include <linux/errno.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include "intel_cln_imr.h"
+
+#define INTEL_CLN_SB_CMD_ADDR	(0x000000D0)
+#define INTEL_CLN_SB_DATA_ADDR	(0x000000D4)
+
+#define INTEL_CLN_SB_MCR_SHIFT	(24)
+#define INTEL_CLN_SB_PORT_SHIFT	(16)
+#define INTEL_CLN_SB_REG_SHIFT	(8)
+#define INTEL_CLN_SB_BYTEEN	(0xF0)	/* enable all 32 bits */
+
+/* Simple structure for module */
+struct intel_cln_sb_dev{
+	struct pci_dev * pdev;
+	spinlock_t slock;
+	u8 initialized;
+};
+
+static struct intel_cln_sb_dev sb_dev = {
+	.initialized = 0
+};
+
+/* Dependant drivers */
+static struct platform_device pdev [] = {
+	{
+		.name = "intel-cln-esram",
+	},
+	{
+		.name = "intel-cln-ecc",
+	},
+	{
+		.name = "intel-cln-thrm",
+	},
+};
+
+/**
+ * intel_cln_sb_read_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_CLN_SB_BYTEEN;
+
+	if(data == NULL)
+		return;
+
+	if (likely(lock == 1)) {
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
+	pci_read_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
+
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+
+}
+EXPORT_SYMBOL(intel_cln_sb_read_reg);
+
+/**
+ * intel_cln_sb_write_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_CLN_SB_BYTEEN;
+
+	if(likely(lock == 1)){
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
+	
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+}
+EXPORT_SYMBOL(intel_cln_sb_write_reg);
+
+/**
+ * intel_cln_sb_runfn_lock
+ *
+ * @param fn: Callback function - which requires side-band spinlock and !irq
+ * @param arg: Callback argument
+ * @return 0 on success < 0 on failure
+ *
+ * Runs the given function pointer inside of a call to the local spinlock using
+ * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
+ * guarantee atomicity, but, available to any other user of sideband provided
+ * rules are respected.
+ * Rules:
+ *	fn may not sleep
+ *	fn may not change the state of irqs	
+ */
+int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg)
+{
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if(unlikely(fn == NULL)){
+		return -EINVAL;
+	}
+	
+	/* Get spinlock with IRQs off */
+	spin_lock_irqsave(&sb_dev.slock, flags);
+
+	/* Run function atomically */
+	ret = fn(arg);
+
+	/* Release lock */
+	spin_unlock_irqrestore(&sb_dev.slock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_cln_sb_runfn_lock);
+
+/**
+ * sb_probe
+ *
+ * @param dev: the PCI device matching
+ * @param id: entry in the match table
+ * @return 0
+ *
+ * Callback from PCI layer when dev/vendor ids match.
+ * Sets up necessary resources
+ */
+static int intel_cln_sb_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int i = 0;
+
+	/* Init struct */
+	memset(&sb_dev, 0x00, sizeof(sb_dev));
+
+	/* Hook device */
+	sb_dev.pdev = dev;
+
+	/* Init locking structures */
+	spin_lock_init(&sb_dev.slock);
+
+	/* Set state */
+	sb_dev.initialized = 1;
+
+	/* Register side-band sub-ordinate drivers */
+	for (i = 0; i < sizeof(pdev)/sizeof(struct platform_device); i++){
+		/* Register side-band sub-ordinate drivers */
+		platform_device_register(&pdev[i]);
+	}
+	pr_info("Intel Clanton side-band driver registered\n");
+
+	/* Switch off boot-time IMRs nice and early */
+	return intel_cln_imr_init();
+}
+
+/**
+ * sb_remove
+ *
+ * @param pdev: PCI device
+ * @return nothing
+ *
+ * Callback from PCI sub-system upon PCI dev removal
+ */
+static void intel_cln_sb_remove(struct pci_dev *pdev)
+{
+}
+
+/* Clanton hardware */
+struct pci_device_id intel_cln_sb_ids[] = {
+        { PCI_VDEVICE(INTEL, 0x0958), 0},
+        { 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, intel_cln_sb_ids);
+
+/* PCI callbacks */
+static struct pci_driver intel_cln_sb_driver = {
+	.name = "intel_cln_sb",
+	.id_table = intel_cln_sb_ids,
+	.probe = intel_cln_sb_probe,
+	.remove = intel_cln_sb_remove,
+};
+
+/**
+ * intel_cln_sb_init
+ *
+ * Module entry point
+ */
+static int __init intel_cln_sb_init(void)
+{
+	return pci_register_driver(&intel_cln_sb_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SOC side-band driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+/* Initialise early since other drivers eSRAM, DRAM ECC and thermal depend */
+subsys_initcall(intel_cln_sb_init);
diff --git a/drivers/platform/x86/quark/intel_cln_smep_test.c b/drivers/platform/x86/quark/intel_cln_smep_test.c
new file mode 100644
index 0000000..16f43db
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_smep_test.c
@@ -0,0 +1,290 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_smep_test.c
+ *
+ * Simple test module to verify SMEP works as expected on MIA
+ * DO NOT RELEASE THIS FILE OUTSIDE OF CLANTON GROUP
+ * DO NOT ATTEMPT TO UPSTREAM THIS CODE - YOU WILL BE PUBLICLY EMBARRSSED !
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@intel.com>
+ *
+ */
+#include <asm/processor.h>
+#include <asm/processor-flags.h>
+#include <linux/cdev.h>
+#include <linux/crc16.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define DRIVER_NAME			"intel_cln_smep_test"
+
+/**
+ * struct intel_cln_smep_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_smep_test_dev{
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+	char * pdata;
+	u32 size;
+};
+
+static struct intel_cln_smep_test_dev smep_test_dev;
+static struct class *smep_test_class;
+static DEFINE_MUTEX(smep_test_mutex);
+static int smep_test_major;
+static char * name = "testmap";
+
+/**
+ * smep_test_ioctl
+ *
+ * Allows user-space to command kernel switch SMEP on/off
+ */
+static long smep_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int cr4 = 0;
+
+	cr4 = read_cr4();
+	printk(KERN_INFO "%s entry CR4 is 0x%08x\n", __FUNCTION__, cr4);
+
+	switch(cmd){
+		case 0:
+			printk(KERN_INFO "Switching SMEP off\n");
+			cr4 &= ~X86_CR4_SMEP;
+			
+			break;
+		case 1:
+			printk(KERN_INFO "Switching SMEP on\n");
+			cr4 |= X86_CR4_SMEP;
+			break;
+		default:
+			return -EINVAL;
+	}
+	/* Latch value */
+	write_cr4(cr4);
+
+	/* Print contents of CR4 */
+	cr4 = read_cr4();
+	printk(KERN_INFO "%s exit CR4 is 0x%08x\n", __FUNCTION__, cr4);
+	
+	return 0;
+}
+
+/**
+ * smep_test_write
+ *
+ * Accepts a buffer from user-space and then tries to execute the contents
+ * Be very careful
+ */
+static ssize_t smep_test_write(struct file *file, const char __user *buf,
+						size_t count, loff_t *ppos)
+{
+	/* 
+	 * We assume we are passed a pointer to function of type
+	 * void fn(void)
+	 */
+	void (*fn)(void) = (void(*))buf;
+	if (count) {
+		printk(KERN_INFO "Will attempt exec %d bytes of ring3 code @ 0x%p\n",
+			count, buf);
+		fn();
+		printk(KERN_INFO "Exec of data @ 0x%p complete\n", buf);
+	}
+	return count;
+}
+
+static int smep_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&smep_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&smep_test_dev.open_lock)) {
+		mutex_unlock(&smep_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (smep_test_dev.opened) {
+		mutex_unlock(&smep_test_dev.open_lock);
+		mutex_unlock(&smep_test_mutex);
+		return -EINVAL;
+	}
+
+	smep_test_dev.opened++;
+	mutex_unlock(&smep_test_dev.open_lock);
+	mutex_unlock(&smep_test_mutex);
+	return 0;
+}
+
+static int smep_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&smep_test_dev.open_lock);
+	smep_test_dev.opened = 0;
+	mutex_unlock(&smep_test_dev.open_lock);
+
+	return 0;
+}
+
+
+
+static const struct file_operations smep_test_file_ops = {
+	.open = smep_test_open,
+	.release = smep_test_release,
+	.unlocked_ioctl = smep_test_ioctl,
+	.write		= smep_test_write,
+	.llseek = no_llseek,
+};
+
+
+/**
+ * intel_cln_smep_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_smep_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&smep_test_dev.open_lock);
+	cdev_init(&smep_test_dev.cdev, &smep_test_file_ops);
+	smep_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&smep_test_dev.cdev, MKDEV(smep_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(smep_test_class, NULL,
+				 MKDEV(smep_test_major, minor), NULL,
+				 "smeptest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s complete OK - device /dev/smeptest%u\n", __FUNCTION__, minor);
+	return 0;
+
+}
+
+/**
+ * intel_cln_smep_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_smep_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(smep_test_dev.cdev.dev);
+
+	device_destroy(smep_test_class, MKDEV(smep_test_major, minor));
+	cdev_del(&smep_test_dev.cdev);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_smep_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_smep_test_remove,
+};
+
+/**
+ * intel_cln_smep_init
+ *
+ * @return 0 success < 0 failure
+ *
+ * Module entry point
+ */
+static int __init intel_cln_smep_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	smep_test_class = class_create(THIS_MODULE,"cln_smep_test");
+	if (IS_ERR(smep_test_class)) {
+		retval = PTR_ERR(smep_test_class);
+		printk(KERN_ERR "smep_test: can't register earam_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "smep_test");
+	if (retval) {
+		printk(KERN_ERR "smep_test: can't register character device\n");
+		goto err_class;
+	}
+	smep_test_major = MAJOR(dev);
+
+	memset(&smep_test_dev, 0x00, sizeof(smep_test_dev));
+	smep_test_dev.pldev = platform_create_bundle(
+		&intel_cln_smep_test_driver, intel_cln_smep_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(smep_test_dev.pldev)){
+		printk(KERN_ERR "smep_test platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(smep_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(smep_test_class);
+err:
+	return retval;
+}
+
+/**
+ * intel_cln_smep_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_smep_test_exit(void)
+{
+	platform_device_unregister(smep_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_smep_test_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SMEP test");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_init(intel_cln_smep_test_init);
+module_exit(intel_cln_smep_test_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_thermal.c b/drivers/platform/x86/quark/intel_cln_thermal.c
new file mode 100644
index 0000000..ce0da9cd
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_cln_thermal.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Thermal driver
+ */
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+#include <linux/timer.h>
+
+#define DRIVER_NAME		"intel-cln-thrm"
+
+/* Definition of register locations for thermal management */
+#define THRM_CTRL_REG		(0x80)		/* Thermal control */
+#define THRM_MODE_REG		(0xB0)		/* Thermal mode */
+#define THRM_MODE_SENSOR_EN	(0x00008000)	/* Thermal mode sensor enable */
+#define THRM_TEMP_REG		(0xB1)		/* Thermal sensor temperature */
+#define THRM_TRPCLR_REG		(0xB2)		/* Catastropic/Hot trip/clear */
+#define THRM_AUXTRP_REG		(0xB3)		/* Aux0-Aux3 trip point */
+#define THRM_AUXCLR_REG		(0xB4)		/* Aux0-Aux3 clear trip */
+#define THRM_STATUS_REG		(0xB5)		/* Thermal sensor status */
+#define THRM_TRIPBEHAVE_REG	(0xB6)		/* Trip point behavior */
+#define THRM_MSIADDR_REG	(0xC5)		/* Thermal MSI addres reg */
+#define THRM_MSIDATA_REG	(0xC6)		/* Thermal MSI data reg */
+#define THRM_CTRL_READ		(0x10)		/* Config reg */
+#define THRM_CTRL_WRITE		(0x11)		/* Config reg */
+
+#define SOC_TSENSOR_REG		(0x34)
+#define SOC_TSENSOR_RST		(0x00000001)
+#define SOC_CTRL_READ		(0x06)
+#define SOC_CTRL_WRITE		(0x07)
+
+
+#define THRM_ZONE_COUNT		2		/* Only hot/critical relevant */
+#define ACTIVE_INTERVAL		(1000)
+#define IDLE_INTERVAL		(20000)
+#define MCELSIUS(x)		((x) * 1000)
+
+/* CPU Zone information */
+#define CATASTROPIC_ZONE	0
+#define HOT_ZONE		1
+#define AUX0_ZONE		2		/* Unused */
+#define AUX1_ZONE		3		/* Unused */
+#define AUX2_ZONE		4		/* Unused */
+#define AUX3_ZONE		5		/* Unused */
+#define MIN_USED_ZONE		CATASTROPIC_ZONE
+#define MAX_USED_ZONE		HOT_ZONE
+/*
+ * Default catastrophic/hot trip values - in degrees celsius
+ * Maximum temperature is 105 degrees
+ */
+#define CRIT_TEMP	104
+#define HOT_TEMP	95
+#define RAW2CELSIUS_DIFF	50
+
+static int driver_enable = 1;
+module_param(driver_enable, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(driver_enable, "Disable Thermal Driver Polling");
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+struct intel_cln_therm_zone {
+	enum thermal_trip_type type;
+	int trip_value;
+};
+
+/**
+ * struct intel_cln_thermal_dev
+ *
+ */
+struct intel_cln_thermal_dev {
+	enum thermal_device_mode mode;
+	struct intel_cln_therm_zone tzone[THRM_ZONE_COUNT];
+	struct mutex lock;
+	struct platform_device *pldev;		/* Platform device */
+	struct thermal_zone_device *therm_dev;	/* Thermal device */
+};
+
+static struct intel_cln_thermal_dev cln_tdev;
+
+/******************************************************************************
+ *                        Thermal API implementation
+ ******************************************************************************/
+
+/**
+ * get_temp
+ *
+ * @param tz: Thermal zone descriptor
+ *
+ * Get the current temperature
+ * We have exactly one thermal zone/sensor
+ * Value passed is an unsigned long - our sensor reports up to -50 celsius so we
+ * just clip at zero if the temperature is negative.
+ */
+static int intel_cln_thermal_get_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TEMP_REG, (u32 *)temp, 1);
+	*temp -= RAW2CELSIUS_DIFF;
+
+	/* Clip to unsigned output value if sensor is reporting sub-zero */
+	if ((int)*temp < 0)
+		*temp = 0;
+
+	*temp = MCELSIUS(*temp&0x000000FF);
+
+	return 0;
+}
+
+/**
+ * get_trend
+ *
+ * Wears good clothes
+ */
+static int intel_cln_thermal_get_trend(struct thermal_zone_device *tz,
+			int trip, enum thermal_trend *trend)
+{
+	if (tz->temperature >= trip)
+		*trend = THERMAL_TREND_RAISING;
+	else
+		*trend = THERMAL_TREND_DROPPING;
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_mode
+ *
+ * Get the mode
+ */
+static int intel_cln_thermal_get_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode *mode)
+{
+	mutex_lock(&cln_tdev.lock);
+	*mode = cln_tdev.mode;
+	mutex_unlock(&cln_tdev.lock);
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_set_mode
+ *
+ * Set the mode
+ */
+static int intel_cln_thermal_set_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode mode)
+{
+	mutex_lock(&cln_tdev.lock);
+
+	if (mode == THERMAL_DEVICE_ENABLED)
+		cln_tdev.therm_dev->polling_delay = IDLE_INTERVAL;
+	else
+		cln_tdev.therm_dev->polling_delay = 0;
+	cln_tdev.mode = mode;
+
+	mutex_unlock(&cln_tdev.lock);
+
+	thermal_zone_device_update(cln_tdev.therm_dev);
+	pr_info("thermal polling set for duration=%d msec\n",
+				cln_tdev.therm_dev->polling_delay);
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_type
+ *
+ * Get trip type
+ */
+static int intel_cln_thermal_get_trip_type(struct thermal_zone_device *tz,
+				int trip, enum thermal_trip_type *type)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	*type = cln_tdev.tzone[trip].type;
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_temp
+ *
+ * Get trip temp
+ */
+static int intel_cln_thermal_get_trip_temp(struct thermal_zone_device *tz,
+				int trip, unsigned long *temp)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	/* Convert the temperature into millicelsius */
+	*temp = cln_tdev.tzone[trip].trip_value;
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_type
+ *
+ * Get trip temp
+ */
+static int intel_cln_thermal_get_crit_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	/* Critical zone */
+	*temp = cln_tdev.tzone[CATASTROPIC_ZONE].trip_value;
+	return 0;
+}
+
+static struct thermal_zone_device_ops intel_cln_thrm_dev_ops = {
+	.get_temp = intel_cln_thermal_get_temp,
+	.get_trend = intel_cln_thermal_get_trend,
+	.get_mode = intel_cln_thermal_get_mode,
+	.set_mode = intel_cln_thermal_set_mode,
+	.get_trip_type = intel_cln_thermal_get_trip_type,
+	.get_trip_temp = intel_cln_thermal_get_trip_temp,
+	.get_crit_temp = intel_cln_thermal_get_crit_temp,
+};
+
+
+
+/**
+ * intel_cln_init_zone
+ *
+ * Initialise a zone
+ */
+static void intel_cln_thermal_init_zone(struct intel_cln_therm_zone *tz,
+				enum thermal_trip_type type, int trip_value)
+{
+	tz->type = type;
+	tz->trip_value = MCELSIUS(trip_value);
+}
+
+/******************************************************************************
+ *                        Module Entry/Exit hooks
+ ******************************************************************************/
+
+/**
+ * intel_cln_thermal_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This routine registers a thermal device with the kernel's thermal management
+ * sub-system
+ */
+static int intel_cln_thermal_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	int critical_temp = 0, hot_temp = 0;
+	uint32_t regval = 0;
+
+	if (driver_enable == 0)
+		return 0;
+
+	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
+
+	critical_temp = CRIT_TEMP;
+	hot_temp = HOT_TEMP;
+
+	/* Enumerate zone type data */
+	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
+	mutex_init(&cln_tdev.lock);
+
+	/* Set initial state disabled */
+	cln_tdev.mode = THERMAL_DEVICE_ENABLED;
+
+	intel_cln_thermal_init_zone(&cln_tdev.tzone[CATASTROPIC_ZONE],
+				  THERMAL_TRIP_CRITICAL, critical_temp);
+	intel_cln_thermal_init_zone(&cln_tdev.tzone[HOT_ZONE],
+				  THERMAL_TRIP_HOT, hot_temp);
+
+	/* Register a thermal zone */
+	cln_tdev.therm_dev = thermal_zone_device_register(DRIVER_NAME,
+			THRM_ZONE_COUNT, 0, 0, &intel_cln_thrm_dev_ops,
+			0, IDLE_INTERVAL, ACTIVE_INTERVAL);
+
+	if (IS_ERR(cln_tdev.therm_dev)) {
+		err = PTR_ERR(cln_tdev.therm_dev);
+		return err;
+	}
+
+	/* Read the BIOS configured hardware catastrophic trip temp */
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TRPCLR_REG, &regval, 1);
+	regval = (regval & 0xff) - 50;
+
+	pr_info("THRM: critical reset %d c hot %d c hardware failover %d c\n",
+		critical_temp, hot_temp, regval);
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_thermal_remove(struct platform_device *pdev)
+{
+	if (cln_tdev.therm_dev != NULL) {
+		thermal_zone_device_unregister(cln_tdev.therm_dev);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_thermal_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_cln_thermal_probe,
+	.remove = intel_cln_thermal_remove,
+};
+
+module_platform_driver(intel_cln_thermal_driver);
+
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton Thermal driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index d57a0ed..fe922ef 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -37,11 +37,11 @@ config SPI_DEBUG
 
 config GEN3_SPI
         bool "Intel Media SOC SPI support"
-        depends on SPI && ARCH_GEN3 && INTEL_CLN_SOC
+        depends on SPI && ARCH_GEN3 && INTEL_QUARK_X1000_SOC
         default y
         help
           This option enables Intel Media SOC SPI support.
-          For Clanton this option depends on INTEL_CLN_SOC.
+          For Clanton this option depends on INTEL_QUARK_X1000_SOC.
 
 #
 # MASTER side ... talking to discrete SPI slave chips including microcontrollers
diff --git a/drivers/spi/spi-pxa2xx-pci.c b/drivers/spi/spi-pxa2xx-pci.c
index a6045b5..aa686b5 100644
--- a/drivers/spi/spi-pxa2xx-pci.c
+++ b/drivers/spi/spi-pxa2xx-pci.c
@@ -17,7 +17,7 @@
 #define CE5300_SOC_DEVICE_ID 0x0C40
 #define CE2600_SOC_DEVICE_ID 0x0931
 
-#ifdef CONFIG_INTEL_CLN_SOC_FPGAEMU
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
 #define CE4200_NUM_SPI_MASTER 1
 #else
 #define CE4200_NUM_SPI_MASTER 2
@@ -25,9 +25,9 @@
 
 #define CE4X00_SPI_MAX_SPEED  1843200
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 #define CE4200_NUM_CHIPSELECT 2
-#ifdef CONFIG_INTEL_CLN_SOC_FPGAEMU
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
 #define CE5X00_SPI_MAX_SPEED  3500000
 #else
 #define CE5X00_SPI_MAX_SPEED  50000000
@@ -41,7 +41,7 @@
 
 static int interface;
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 static int enable_msi = 1;
 #else
 static int enable_msi;
@@ -161,7 +161,7 @@ static int __devinit ce4100_spi_probe(struct pci_dev *dev,
 	ssp->irq = dev->irq;
 	ssp->port_id = pdev->id;
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	id = CE5300_SOC_DEVICE_ID;
 #else
 	intelce_get_soc_info(&id, NULL);
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index 7fcb883..91da7dd 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -33,7 +33,7 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/pm_runtime.h>
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 #include <asm/cln.h>
 #endif
 
@@ -94,7 +94,7 @@ DEFINE_SSP_REG(sscr1, 0x04)
 DEFINE_SSP_REG(sssr, 0x08)
 DEFINE_SSP_REG(ssitr, 0x0c)
 DEFINE_SSP_REG(ssdr, 0x10)
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 DEFINE_SSP_REG(dds_rate, 0x28) /* SSTO unused for clanton */
 #endif
 DEFINE_SSP_REG(ssto, 0x28)
@@ -108,7 +108,7 @@ DEFINE_SSP_REG(sspsp, 0x2c)
 #define QUEUE_RUNNING 0
 #define QUEUE_STOPPED 1
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 #define DDS_MAX     0x800000
 #define DDS_666666  0x666666
 #define DDS_400000  0x400000
@@ -120,7 +120,7 @@ DEFINE_SSP_REG(sspsp, 0x2c)
 #define DDS_10000   0x10000
 #define DDS_8000    0x8000
 
-#if defined(CONFIG_INTEL_CLN_SOC_FPGAEMU)
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU)
 /* these values are different on emulations where system clock is 14mhz */
 #define FSYS              14 /* mhz */
 #define BITRATE_50MHZ     3500000
@@ -200,9 +200,9 @@ DEFINE_SSP_REG(sspsp, 0x2c)
 #define BITRATE_MAX       BITRATE_50MHZ
 #define FSYS              200 /* mhz */
 
-#endif /* #if defined(CONFIG_INTEL_CLN_SOC_FPGAEMU) */
+#endif /* #if defined(CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU) */
 
-#endif /* CONFIG_INTEL_CLN_SOC */
+#endif /* CONFIG_INTEL_QUARK_X1000_SOC */
 
 struct driver_data {
 	/* Driver model hookup */
@@ -261,7 +261,7 @@ struct driver_data {
 struct chip_data {
 	u32 cr0;
 	u32 cr1;
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	u32 dds_rate;
 #endif
 	u32 psp;
@@ -1106,7 +1106,7 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 	if (!(status & mask))
 		return IRQ_NONE;
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	mask_pvm(drv_data->ssp->pcidev);
 #endif
 	if (!drv_data->cur_msg) {
@@ -1123,7 +1123,7 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 	ret = drv_data->transfer_handler(drv_data);
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	unmask_pvm(drv_data->ssp->pcidev);
 #endif
 	return ret;
@@ -1244,7 +1244,7 @@ static unsigned long spi_clk_get_rate(int ssp_type)
 }
 #endif
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 /*  see Clanton SPI data sheet for implementation rationale */
 u32 cln_set_clk_regvals(u32 rate, u32 *dds, u32 *clk_div)
 {
@@ -1410,7 +1410,7 @@ static unsigned int ssp_get_clk_div(struct ssp_device *ssp, int rate)
 	else
 		return ((ssp_clk / rate - 1) & 0xfff) << 8;
 }
-#endif /* CONFIG_INTEL_CLN_SOC */
+#endif /* CONFIG_INTEL_QUARK_X1000_SOC */
 
 static void pump_transfers(unsigned long data)
 {
@@ -1419,7 +1419,7 @@ static void pump_transfers(unsigned long data)
 	struct spi_transfer *transfer = NULL;
 	struct spi_transfer *previous = NULL;
 	struct chip_data *chip = NULL;
-#ifndef CONFIG_INTEL_CLN_SOC
+#ifndef CONFIG_INTEL_QUARK_X1000_SOC
 	struct ssp_device *ssp = drv_data->ssp;
 #else
 	u32 actual_speed = 0;
@@ -1525,7 +1525,7 @@ static void pump_transfers(unsigned long data)
 		if (transfer->bits_per_word)
 			bits = transfer->bits_per_word;
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 		actual_speed = cln_set_clk_regvals
 				(speed, &chip->dds_rate, &clk_div);
 		clk_div = (clk_div << 8);
@@ -1666,7 +1666,7 @@ static void pump_transfers(unsigned long data)
 
 	/* see if we need to reload the config registers */
 	if (drv_data->ssp_type == CE5X00_SSP) {
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 		if (read_dds_rate(reg) != chip->dds_rate)
 			write_dds_rate(chip->dds_rate, reg);
 #endif
@@ -1801,7 +1801,7 @@ static int setup(struct spi_device *spi)
 	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
 	struct ssp_device *ssp = drv_data->ssp;
 	unsigned int clk_div;
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	u32 actual_speed;
 #endif
 	uint tx_thres = TX_THRESH_DFLT;
@@ -1889,7 +1889,7 @@ static int setup(struct spi_device *spi)
 				 "to match bits_per_word\n");
 		}
 	}
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	actual_speed = cln_set_clk_regvals(spi->max_speed_hz,
 						&chip->dds_rate, &clk_div);
 	clk_div = (clk_div << 8);
@@ -1923,7 +1923,7 @@ static int setup(struct spi_device *spi)
 	}
 
 	chip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
 			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0)
 			| (((spi->mode & SPI_LOOP) != 0) ? SSCR1_LBM : 0);
@@ -2038,7 +2038,7 @@ static int __devinit pxa2xx_spi_probe(struct platform_device *pdev)
 #endif
 
 	/* the spi->mode bits understood by this driver: */
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
 #else
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
@@ -2119,7 +2119,7 @@ static int __devinit pxa2xx_spi_probe(struct platform_device *pdev)
 		write_sscr1(CE5X00_SSCR1_RxTresh(RX_THRESH_CE5X00_DFLT) |
 			    CE5X00_SSCR1_TxTresh(TX_THRESH_CE5X00_DFLT),
 			    drv_data->ioaddr);
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 		/* using the Motorola SPI protocol and use 8 bit frame */
 		write_sscr0(CE5X00_SSCR0_Motorola
 			    | CE5X00_SSCR0_DataSize(8),
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 558beb9..6204dcd 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -732,11 +732,11 @@ static int handshake(void __iomem *ptr, u32 mask, u32 done,
 	return -ETIMEDOUT;
 }
 
-#define PCI_DEVICE_ID_INTEL_CLN_SOC		0x0939
+#define PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC		0x0939
 bool usb_is_intel_cln(struct pci_dev *pdev)
 {
 	return pdev->vendor == PCI_VENDOR_ID_INTEL &&
-		pdev->device == PCI_DEVICE_ID_INTEL_CLN_SOC;
+		pdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;
 
 }
 EXPORT_SYMBOL_GPL(usb_is_intel_cln);
diff --git a/include/linux/iio/common/st_sensors.h b/include/linux/iio/common/st_sensors.h
new file mode 100644
index 0000000..337da33
--- /dev/null
+++ b/include/linux/iio/common/st_sensors.h
@@ -0,0 +1,290 @@
+/*
+ * STMicroelectronics sensors library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_H
+#define ST_SENSORS_H
+
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/irqreturn.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/events.h>
+
+#define ST_SENSORS_TX_MAX_LENGTH		2
+#define ST_SENSORS_RX_MAX_LENGTH		6
+
+#define ST_SENSORS_ODR_LIST_MAX			10
+#define ST_SENSORS_FULLSCALE_AVL_MAX		10
+
+#define ST_SENSORS_NUMBER_ALL_CHANNELS		4
+#define ST_SENSORS_NUMBER_DATA_CHANNELS		3
+#define ST_SENSORS_ENABLE_ALL_AXIS		0x07
+#define ST_SENSORS_BYTE_FOR_CHANNEL		2
+#define ST_SENSORS_SCAN_X			0
+#define ST_SENSORS_SCAN_Y			1
+#define ST_SENSORS_SCAN_Z			2
+#define ST_SENSORS_DEFAULT_12_REALBITS		12
+#define ST_SENSORS_DEFAULT_16_REALBITS		16
+#define ST_SENSORS_DEFAULT_POWER_ON_VALUE	0x01
+#define ST_SENSORS_DEFAULT_POWER_OFF_VALUE	0x00
+#define ST_SENSORS_DEFAULT_WAI_ADDRESS		0x0f
+#define ST_SENSORS_DEFAULT_AXIS_ADDR		0x20
+#define ST_SENSORS_DEFAULT_AXIS_MASK		0x07
+#define ST_SENSORS_DEFAULT_AXIS_N_BIT		3
+
+#define ST_SENSORS_MAX_NAME			17
+#define ST_SENSORS_MAX_4WAI			7
+
+#define ST_SENSORS_LSM_CHANNELS(device_type, index, mod, endian, bits, addr) \
+{ \
+	.type = device_type, \
+	.modified = 1, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.scan_index = index, \
+	.channel = mod, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = bits, \
+		.shift = 16 - bits, \
+		.storagebits = 16, \
+		.endianness = endian, \
+	}, \
+	.event_mask = IIO_EV_BIT(IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), \
+}
+
+#define ST_SENSOR_DEV_ATTR_SAMP_FREQ() \
+		IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO, \
+			st_sensors_sysfs_get_sampling_frequency, \
+			st_sensors_sysfs_set_sampling_frequency)
+
+#define ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL() \
+		IIO_DEV_ATTR_SAMP_FREQ_AVAIL( \
+			st_sensors_sysfs_sampling_frequency_avail)
+
+#define ST_SENSORS_DEV_ATTR_SCALE_AVAIL(name) \
+		IIO_DEVICE_ATTR(name, S_IRUGO, \
+			st_sensors_sysfs_scale_avail, NULL , 0);
+
+struct st_sensor_odr_avl {
+	unsigned int hz;
+	u8 value;
+};
+
+struct st_sensor_odr {
+	u8 addr;
+	u8 mask;
+	struct st_sensor_odr_avl odr_avl[ST_SENSORS_ODR_LIST_MAX];
+};
+
+struct st_sensor_power {
+	u8 addr;
+	u8 mask;
+	u8 value_off;
+	u8 value_on;
+};
+
+struct st_sensor_axis {
+	u8 addr;
+	u8 mask;
+};
+
+struct st_sensor_fullscale_avl {
+	unsigned int num;
+	u8 value;
+	unsigned int gain;
+	unsigned int gain2;
+};
+
+struct st_sensor_fullscale {
+	u8 addr;
+	u8 mask;
+	struct st_sensor_fullscale_avl fs_avl[ST_SENSORS_FULLSCALE_AVL_MAX];
+};
+
+/**
+ * struct st_sensor_bdu - ST sensor device block data update
+ * @addr: address of the register.
+ * @mask: mask to write the block data update flag.
+ */
+struct st_sensor_bdu {
+	u8 addr;
+	u8 mask;
+};
+
+/**
+ * struct st_sensor_data_ready_irq - ST sensor device data-ready interrupt
+ * @addr: address of the register.
+ * @mask: mask to write the on/off value.
+ * struct ig1 - represents the Interrupt Generator 1 of sensors.
+ * @en_addr: address of the enable ig1 register.
+ * @en_mask: mask to write the on/off value for enable.
+ */
+struct st_sensor_data_ready_irq {
+	u8 addr;
+	u8 mask;
+	struct {
+		u8 en_addr;
+		u8 en_mask;
+	} ig1;
+};
+
+/**
+ * struct st_sensor_transfer_buffer - ST sensor device I/O buffer
+ * @buf_lock: Mutex to protect rx and tx buffers.
+ * @tx_buf: Buffer used by SPI transfer function to send data to the sensors.
+ *	This buffer is used to avoid DMA not-aligned issue.
+ * @rx_buf: Buffer used by SPI transfer to receive data from sensors.
+ *	This buffer is used to avoid DMA not-aligned issue.
+ */
+struct st_sensor_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[ST_SENSORS_RX_MAX_LENGTH];
+	u8 tx_buf[ST_SENSORS_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/**
+ * struct st_sensor_transfer_function - ST sensor device I/O function
+ * @read_byte: Function used to read one byte.
+ * @write_byte: Function used to write one byte.
+ * @read_multiple_byte: Function used to read multiple byte.
+ */
+struct st_sensor_transfer_function {
+	int (*read_byte) (struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 *res_byte);
+	int (*write_byte) (struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 data);
+	int (*read_multiple_byte) (struct st_sensor_transfer_buffer *tb,
+		struct device *dev, u8 reg_addr, int len, u8 *data,
+							bool multiread_bit);
+};
+
+/**
+ * struct st_sensors - ST sensors list
+ * @wai: Contents of WhoAmI register.
+ * @sensors_supported: List of supported sensors by struct itself.
+ * @ch: IIO channels for the sensor.
+ * @odr: Output data rate register and ODR list available.
+ * @pw: Power register of the sensor.
+ * @enable_axis: Enable one or more axis of the sensor.
+ * @fs: Full scale register and full scale list available.
+ * @bdu: Block data update register.
+ * @drdy_irq: Data ready register of the sensor.
+ * @multi_read_bit: Use or not particular bit for [I2C/SPI] multi-read.
+ * @bootime: samples to discard when sensor passing from power-down to power-up.
+ */
+struct st_sensors {
+	u8 wai;
+	char sensors_supported[ST_SENSORS_MAX_4WAI][ST_SENSORS_MAX_NAME];
+	struct iio_chan_spec *ch;
+	struct st_sensor_odr odr;
+	struct st_sensor_power pw;
+	struct st_sensor_axis enable_axis;
+	struct st_sensor_fullscale fs;
+	struct st_sensor_bdu bdu;
+	struct st_sensor_data_ready_irq drdy_irq;
+	bool multi_read_bit;
+	unsigned int bootime;
+};
+
+/**
+ * struct st_sensor_data - ST sensor device status
+ * @dev: Pointer to instance of struct device (I2C or SPI).
+ * @trig: The trigger in use by the core driver.
+ * @sensor: Pointer to the current sensor struct in use.
+ * @current_fullscale: Maximum range of measure by the sensor.
+ * @enabled: Status of the sensor (false->off, true->on).
+ * @multiread_bit: Use or not particular bit for [I2C/SPI] multiread.
+ * @buffer_data: Data used by buffer part.
+ * @odr: Output data rate of the sensor [Hz].
+ * @get_irq_data_ready: Function to get the IRQ used for data ready signal.
+ * @tf: Transfer function structure used by I/O operations.
+ * @tb: Transfer buffers and mutex used by I/O operations.
+ */
+struct st_sensor_data {
+	struct device *dev;
+	struct iio_trigger *trig;
+	struct st_sensors *sensor;
+	struct st_sensor_fullscale_avl *current_fullscale;
+
+	bool enabled;
+	bool int_thresh;
+	bool multiread_bit;
+
+	char *buffer_data;
+
+	unsigned int odr;
+
+	unsigned int (*get_irq_data_ready) (struct iio_dev *indio_dev);
+
+	const struct st_sensor_transfer_function *tf;
+	struct st_sensor_transfer_buffer tb;
+};
+
+#ifdef CONFIG_IIO_BUFFER
+irqreturn_t st_sensors_trigger_handler(int irq, void *p);
+
+int st_sensors_get_buffer_element(struct iio_dev *indio_dev, u8 *buf);
+#endif
+
+#ifdef CONFIG_IIO_TRIGGER
+int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
+				const struct iio_trigger_ops *trigger_ops);
+
+void st_sensors_deallocate_trigger(struct iio_dev *indio_dev);
+
+#else
+static inline int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
+				const struct iio_trigger_ops *trigger_ops)
+{
+	return 0;
+}
+static inline void st_sensors_deallocate_trigger(struct iio_dev *indio_dev)
+{
+	return;
+}
+#endif
+
+int st_sensors_init_sensor(struct iio_dev *indio_dev);
+
+int st_sensors_write_data_with_mask(struct iio_dev *indio_dev,
+				u8 reg_addr, u8 mask, u8 data);
+
+int st_sensors_set_enable(struct iio_dev *indio_dev, bool enable);
+
+int st_sensors_set_axis_enable(struct iio_dev *indio_dev, u8 axis_enable);
+
+int st_sensors_set_odr(struct iio_dev *indio_dev, unsigned int odr);
+
+int st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable);
+
+int st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale);
+
+int st_sensors_read_info_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch, int *val);
+
+int st_sensors_check_device_support(struct iio_dev *indio_dev,
+			int num_sensors_list, const struct st_sensors *sensors);
+
+ssize_t st_sensors_sysfs_get_sampling_frequency(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t st_sensors_sysfs_set_sampling_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+
+ssize_t st_sensors_sysfs_sampling_frequency_avail(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t st_sensors_sysfs_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+#endif /* ST_SENSORS_H */
diff --git a/include/linux/iio/common/st_sensors_i2c.h b/include/linux/iio/common/st_sensors_i2c.h
new file mode 100644
index 0000000..67d8453
--- /dev/null
+++ b/include/linux/iio/common/st_sensors_i2c.h
@@ -0,0 +1,20 @@
+/*
+ * STMicroelectronics sensors i2c library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_I2C_H
+#define ST_SENSORS_I2C_H
+
+#include <linux/i2c.h>
+#include <linux/iio/common/st_sensors.h>
+
+void st_sensors_i2c_configure(struct iio_dev *indio_dev,
+		struct i2c_client *client, struct st_sensor_data *sdata);
+
+#endif /* ST_SENSORS_I2C_H */
diff --git a/include/linux/iio/common/st_sensors_spi.h b/include/linux/iio/common/st_sensors_spi.h
new file mode 100644
index 0000000..d964a35
--- /dev/null
+++ b/include/linux/iio/common/st_sensors_spi.h
@@ -0,0 +1,20 @@
+/*
+ * STMicroelectronics sensors spi library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_SPI_H
+#define ST_SENSORS_SPI_H
+
+#include <linux/spi/spi.h>
+#include <linux/iio/common/st_sensors.h>
+
+void st_sensors_spi_configure(struct iio_dev *indio_dev,
+			struct spi_device *spi, struct st_sensor_data *sdata);
+
+#endif /* ST_SENSORS_SPI_H */
diff --git a/include/linux/platform_data/clanton.h b/include/linux/platform_data/clanton.h
index bd24df0..95b5e6d 100644
--- a/include/linux/platform_data/clanton.h
+++ b/include/linux/platform_data/clanton.h
@@ -42,7 +42,7 @@ typedef enum {
 }plat_dataid_t;
 
 
-#ifdef CONFIG_INTEL_CLN_SOC
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
 extern cln_plat_id_t intel_cln_plat_get_id(void);
 extern int intel_cln_plat_get_mac(plat_dataid_t id, char * mac);
 #else
diff --git a/include/linux/platform_data/lis331dlh_intel_cln.h b/include/linux/platform_data/lis331dlh_intel_cln.h
new file mode 100644
index 0000000..00e3006
--- /dev/null
+++ b/include/linux/platform_data/lis331dlh_intel_cln.h
@@ -0,0 +1,36 @@
+/*
+ * Platform data for Intel Clanton Hill platform accelerometer driver
+ *
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H__
+#define __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H__
+
+/**
+ * struct lis331dlh_intel_cln_platform_data - Platform data for the ST Micro
+ *                                            accelerometer driver
+ * @irq1_pin: GPIO pin number for the threshold interrupt(INT1).
+ **/
+struct lis331dlh_intel_cln_platform_data {
+	int irq1_pin;
+};
+
+#endif /* LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H_ */
-- 
1.7.5.4

