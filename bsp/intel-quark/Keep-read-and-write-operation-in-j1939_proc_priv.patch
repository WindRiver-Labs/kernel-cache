From 18728d7fd7ec38fe502d5a2256b25c8d69945e3a Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 24 Dec 2014 17:00:51 +0800
Subject: [PATCH 17/31] Keep read and write operation in j1939_proc_priv.

Due to the API change of proc interface, create a private j1939 data structure
to hold the necessary callbacks.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 net/can/j1939/bus.c        |   10 ++++++----
 net/can/j1939/j1939-priv.h |   13 +++++++++++--
 net/can/j1939/proc.c       |   44 +++++++++++++++++++++++++++-----------------
 net/can/j1939/socket.c     |    6 ++++--
 net/can/j1939/transport.c  |    6 ++++--
 5 files changed, 52 insertions(+), 27 deletions(-)

diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
index 5b30ec7..00f8080 100644
--- a/net/can/j1939/bus.c
+++ b/net/can/j1939/bus.c
@@ -37,6 +37,8 @@ static struct {
 	spinlock_t lock;
 } segments;
 
+static struct j1939_proc_priv *addr_priv, *ecu_priv;
+
 struct j1939_segment *j1939_segment_find(int ifindex)
 {
 	struct j1939_segment *jseg;
@@ -493,8 +495,8 @@ int __init j1939bus_module_init(void)
 {
 	INIT_LIST_HEAD(&segments.list);
 	spin_lock_init(&segments.lock);
-	j1939_proc_add("addr", j1939_proc_addr, NULL);
-	j1939_proc_add("ecu", j1939_proc_ecu, NULL);
+	addr_priv = j1939_proc_add("addr", j1939_proc_addr, NULL);
+	ecu_priv = j1939_proc_add("ecu", j1939_proc_ecu, NULL);
 	return 0;
 }
 
@@ -518,8 +520,8 @@ void j1939bus_module_exit(void)
 	}
 	spin_unlock_bh(&segments.lock);
 
-	j1939_proc_remove("ecu");
-	j1939_proc_remove("addr");
+	j1939_proc_remove("ecu", ecu_priv);
+	j1939_proc_remove("addr", addr_priv);
 }
 
 
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index b6de553..04b27a1 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -22,6 +22,15 @@
 #include <linux/atomic.h>
 #include <linux/interrupt.h>
 
+typedef        int (*write_proc_t)(struct file *file, const char __user *buffer,
+			unsigned long count, void *data);
+
+struct j1939_proc_priv {
+	write_proc_t write_proc;
+	int (*seq_show)(struct seq_file *sqf, void *v);
+	struct proc_dir_entry *pde;
+};
+
 /* TODO: return ENETRESET on busoff. */
 
 #define ECUFLAG_LOCAL	0x01
@@ -177,10 +186,10 @@ extern struct j1939_ecu *j1939_ecu_find_segment_default_tx(
 extern void j1939_put_promisc_receiver(int ifindex);
 extern void j1939_get_promisc_receiver(int ifindex);
 
-extern int j1939_proc_add(const char *file,
+extern struct j1939_proc_priv *j1939_proc_add(const char *file,
 		int (*seq_show)(struct seq_file *sqf, void *v),
 		write_proc_t write);
-extern void j1939_proc_remove(const char *file);
+extern void j1939_proc_remove(const char *file, struct j1939_proc_priv *priv);
 
 extern const char j1939_procname[];
 /* j1939 printk */
diff --git a/net/can/j1939/proc.c b/net/can/j1939/proc.c
index 76acfa0..6365e09 100644
--- a/net/can/j1939/proc.c
+++ b/net/can/j1939/proc.c
@@ -23,10 +23,9 @@ static struct proc_dir_entry *rootdir;
 
 static int j1939_proc_open(struct inode *inode, struct file *file)
 {
-	struct proc_dir_entry *pde = PDE(inode);
-	int (*fn)(struct seq_file *sqf, void *v) = pde->data;
+	struct j1939_proc_priv *priv = PDE_DATA(inode);
 
-	return single_open(file, fn, pde);
+	return single_open(file, priv->seq_show, NULL);
 }
 
 /* copied from fs/proc/generic.c */
@@ -35,15 +34,13 @@ proc_file_write(struct file *file, const char __user *buffer,
 		size_t count, loff_t *ppos)
 {
 	struct inode *inode = file->f_path.dentry->d_inode;
-	struct proc_dir_entry *dp;
+	struct j1939_proc_priv *priv = PDE_DATA(inode);
 
-	dp = PDE(inode);
-
-	if (!dp->write_proc)
+	if (!priv->write_proc)
 		return -EIO;
 
 	/* FIXME: does this routine need ppos?  probably... */
-	return dp->write_proc(file, buffer, count, dp->data);
+	return priv->write_proc(file, buffer, count, NULL);
 }
 
 static const struct file_operations j1939_proc_ops = {
@@ -55,12 +52,13 @@ static const struct file_operations j1939_proc_ops = {
 	.release	= single_release,
 };
 
-int j1939_proc_add(const char *file,
+struct j1939_proc_priv *j1939_proc_add(const char *file,
 		int (*seq_show)(struct seq_file *sqf, void *v),
 		write_proc_t write)
 {
 	struct proc_dir_entry *pde;
 	int mode = 0;
+	struct j1939_proc_priv *priv;
 
 	if (seq_show)
 		mode |= 0444;
@@ -68,22 +66,34 @@ int j1939_proc_add(const char *file,
 		mode |= 0200;
 
 	if (!rootdir)
-		return -ENODEV;
-	pde = proc_create(file, mode, rootdir, &j1939_proc_ops);
+		return ERR_PTR(-ENODEV);
+
+
+	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return ERR_PTR(-ENOMEM);
+
+	priv->seq_show = seq_show;
+	priv->write_proc = write;
+
+	pde = proc_create_data(file, mode, rootdir, &j1939_proc_ops, priv);
 	if (!pde)
 		goto fail_create;
-	pde->data = seq_show;
-	pde->write_proc = write;
-	return 0;
+
+	priv->pde = pde;
+
+	return priv;
 
 fail_create:
-	return -ENOENT;
+	kfree(priv);
+	return ERR_PTR(-ENOENT);
 }
 EXPORT_SYMBOL(j1939_proc_add);
 
-void j1939_proc_remove(const char *file)
+void j1939_proc_remove(const char *file, struct j1939_proc_priv *priv)
 {
 	remove_proc_entry(file, rootdir);
+	kfree(priv);
 }
 EXPORT_SYMBOL(j1939_proc_remove);
 
@@ -99,6 +109,6 @@ __init int j1939_proc_module_init(void)
 void j1939_proc_module_exit(void)
 {
 	if (rootdir)
-		proc_net_remove(&init_net, j1939_procname);
+		remove_proc_entry(j1939_procname, init_net.proc_net);
 }
 
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 12fb581..782af6d 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -47,6 +47,8 @@ struct j1939_sock {
 	wait_queue_head_t waitq;
 };
 
+static struct j1939_proc_priv *sock_priv;
+
 static inline struct j1939_sock *j1939_sk(const struct sock *sk)
 {
 	return container_of(sk, struct j1939_sock, sk);
@@ -972,13 +974,13 @@ __init int j1939sk_module_init(void)
 	if (ret < 0)
 		pr_err("can: registration of j1939 protocol failed\n");
 	else
-		j1939_proc_add("sock", j1939sk_proc_show, NULL);
+		sock_priv = j1939_proc_add("sock", j1939sk_proc_show, NULL);
 	return ret;
 }
 
 void j1939sk_module_exit(void)
 {
-	j1939_proc_remove("sock");
+	j1939_proc_remove("sock", sock_priv);
 	can_proto_unregister(&j1939_can_proto);
 }
 
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 9f723c6..b32383c 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -49,6 +49,8 @@ static int block = 255;
 static int max_packet_size = 1024*100;
 static int retry_ms = 20;
 
+static struct j1939_proc_priv *transport_priv;
+
 struct session {
 	struct list_head list;
 	atomic_t refs;
@@ -1418,7 +1420,7 @@ int __init j1939tp_module_init(void)
 	s.notifier.notifier_call = j1939tp_notifier;
 	register_netdevice_notifier(&s.notifier);
 
-	j1939_proc_add("transport", j1939tp_proc_show, NULL);
+	transport_priv = j1939_proc_add("transport", j1939tp_proc_show, NULL);
 	j1939tp_table_header =
 		register_sysctl_paths(j1939tp_path, j1939tp_table);
 	init_waitqueue_head(&s.wait);
@@ -1433,7 +1435,7 @@ void j1939tp_module_exit(void)
 
 	unregister_sysctl_table(j1939tp_table_header);
 	unregister_netdevice_notifier(&s.notifier);
-	j1939_proc_remove("transport");
+	j1939_proc_remove("transport", transport_priv);
 	sessionlist_lock();
 	list_for_each_entry_safe(session, saved, &s.extsessionq, list) {
 		list_del_init(&session->list);
-- 
1.7.5.4

