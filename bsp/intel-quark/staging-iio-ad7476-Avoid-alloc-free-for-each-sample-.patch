From 98fbd4cfc92cb505f12c4513c691eb6802b6870a Mon Sep 17 00:00:00 2001
From: Lars-Peter Clausen <lars@metafoo.de>
Date: Mon, 10 Sep 2012 09:34:00 +0100
Subject: [PATCH 0894/1187] staging:iio:ad7476: Avoid alloc/free for each
 sample in buffered mode

commit 93e33d703030fe0348c1ff9d8f40bc6c2d82dc30	upstream

The ad7476 driver has only support for 1 channel ADCs. So the upper limit for
the buffer size is the size of one sample plus the size of the timestamp.
Preallocate a buffer large enough to hold this to avoid having to allocate and
free a new buffer for each sample being captured.

Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
Signed-off-by: Jonathan Cameron <jic23@kernel.org>
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/staging/iio/adc/ad7476.h      |    5 ++++-
 drivers/staging/iio/adc/ad7476_ring.c |   14 +++-----------
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/iio/adc/ad7476.h b/drivers/staging/iio/adc/ad7476.h
index 6085fad..c4f1150 100644
--- a/drivers/staging/iio/adc/ad7476.h
+++ b/drivers/staging/iio/adc/ad7476.h
@@ -33,8 +33,11 @@ struct ad7476_state {
 	/*
 	 * DMA (thus cache coherency maintenance) requires the
 	 * transfer buffers to live in their own cache lines.
+	 * Make the buffer large enough for one 16 bit sample and one 64 bit
+	 * aligned 64 bit timestamp.
 	 */
-	unsigned char			data[2] ____cacheline_aligned;
+	unsigned char data[ALIGN(2, sizeof(s64)) + sizeof(s64)]
+			____cacheline_aligned;
 };
 
 enum ad7476_supported_device_ids {
diff --git a/drivers/staging/iio/adc/ad7476_ring.c b/drivers/staging/iio/adc/ad7476_ring.c
index 940681f..3c869b0 100644
--- a/drivers/staging/iio/adc/ad7476_ring.c
+++ b/drivers/staging/iio/adc/ad7476_ring.c
@@ -26,28 +26,20 @@ static irqreturn_t ad7476_trigger_handler(int irq, void  *p)
 	struct iio_dev *indio_dev = pf->indio_dev;
 	struct ad7476_state *st = iio_priv(indio_dev);
 	s64 time_ns;
-	__u8 *rxbuf;
 	int b_sent;
 
-	rxbuf = kzalloc(indio_dev->scan_bytes, GFP_KERNEL);
-	if (rxbuf == NULL)
-		goto done;
-
-	b_sent = spi_read(st->spi, rxbuf,
-			  st->chip_info->channel[0].scan_type.storagebits / 8);
+	b_sent = spi_sync(st->spi, &st->msg);
 	if (b_sent < 0)
 		goto done;
 
 	time_ns = iio_get_time_ns();
 
 	if (indio_dev->scan_timestamp)
-		memcpy(rxbuf + indio_dev->scan_bytes - sizeof(s64),
-			&time_ns, sizeof(time_ns));
+		((s64 *)st->data)[1] = time_ns;
 
-	iio_push_to_buffer(indio_dev->buffer, rxbuf);
+	iio_push_to_buffer(indio_dev->buffer, st->data);
 done:
 	iio_trigger_notify_done(indio_dev->trig);
-	kfree(rxbuf);
 
 	return IRQ_HANDLED;
 }
-- 
1.7.5.4

