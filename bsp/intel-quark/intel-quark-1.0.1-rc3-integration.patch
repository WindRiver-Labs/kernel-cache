From eb13990dc431565ce520c1827a6ece5616aebf1a Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 25 Apr 2014 21:06:02 +0800
Subject: [PATCH 1/3] intel-quark: 1.0.1-rc3 integration.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/Kconfig                                   |    2 +-
 drivers/dma/intel_mid_dma_core.c                   |  119 +++--
 drivers/dma/intel_mid_dma_pci.c                    |   14 +-
 drivers/dma/intel_mid_dma_regs.h                   |   15 +
 drivers/dma/intel_qrk_dma_pci.c                    |    1 -
 drivers/gpio/Kconfig                               |    2 +-
 drivers/gpio/gpio-pca953x.c                        |  189 +++++-
 drivers/gpio/gpio-sch.c                            |   38 ++
 drivers/iio/adc/Kconfig                            |   12 +
 drivers/iio/adc/Makefile                           |    1 +
 drivers/iio/adc/adc1x8s102.c                       |  387 +++++++++++
 drivers/iio/adc/max78m6610_lmu.c                   |  582 +++++++++++++----
 drivers/mfd/Kconfig                                |   10 +
 drivers/mfd/Makefile                               |    2 +
 drivers/mfd/pca9685-core.c                         |  283 ++++++++
 drivers/mfd/pca9685-gpio.c                         |  108 ++++
 drivers/mfd/pca9685-pwm.c                          |  262 ++++++++
 drivers/mfd/pca9685.h                              |  110 ++++
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |   12 +
 drivers/platform/x86/quark/Makefile                |    1 +
 drivers/platform/x86/quark/intel_qrk_board_data.c  |    5 +-
 .../platform/x86/quark/intel_qrk_plat_cross_hill.c |   46 ++-
 .../x86/quark/intel_qrk_plat_galileo_gen2.c        |  392 ++++++++++++
 drivers/tty/serial/intel_quark_uart.c              |  674 ++++++++++----------
 include/linux/intel_mid_dma.h                      |    3 +
 include/linux/platform_data/adc1x8s102.h           |   30 +
 include/linux/platform_data/pca9685.h              |   51 ++
 27 files changed, 2812 insertions(+), 539 deletions(-)
 mode change 100644 => 100755 drivers/dma/intel_mid_dma_regs.h
 mode change 100644 => 100755 drivers/gpio/Kconfig
 mode change 100644 => 100755 drivers/gpio/gpio-pca953x.c
 mode change 100644 => 100755 drivers/iio/adc/Kconfig
 mode change 100644 => 100755 drivers/iio/adc/Makefile
 create mode 100644 drivers/iio/adc/adc1x8s102.c
 mode change 100644 => 100755 drivers/mfd/Kconfig
 mode change 100644 => 100755 drivers/mfd/Makefile
 create mode 100644 drivers/mfd/pca9685-core.c
 create mode 100644 drivers/mfd/pca9685-gpio.c
 create mode 100644 drivers/mfd/pca9685-pwm.c
 create mode 100644 drivers/mfd/pca9685.h
 mode change 100644 => 100755 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
 mode change 100644 => 100755 drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_galileo_gen2.c
 mode change 100644 => 100755 include/linux/intel_mid_dma.h
 create mode 100644 include/linux/platform_data/adc1x8s102.h
 create mode 100644 include/linux/platform_data/pca9685.h

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 3644878..f95afce 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1182,7 +1182,7 @@ config ARCH_PHYS_ADDR_T_64BIT
 	def_bool X86_64 || X86_PAE
 
 config ARCH_DMA_ADDR_T_64BIT
-	def_bool X86_64 || HIGHMEM64G
+	def_bool X86_64 || HIGHMEM64G && !INTEL_QUARK_X1000_SOC
 
 config DIRECT_GBPAGES
 	bool "Enable 1GB pages for kernel pagetables" if EXPERT
diff --git a/drivers/dma/intel_mid_dma_core.c b/drivers/dma/intel_mid_dma_core.c
index aeb7fd3..b869d6c 100644
--- a/drivers/dma/intel_mid_dma_core.c
+++ b/drivers/dma/intel_mid_dma_core.c
@@ -43,13 +43,6 @@
 #define LNW_PERIPHRAL_STATUS		0x0
 #define LNW_PERIPHRAL_MASK		0x8
 
-#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask) \
-	((kernel_ulong_t)&(struct intel_mid_dma_probe_info) {	\
-		.max_chan = (_max_chan),			\
-		.ch_base = (_ch_base),				\
-		.block_size = (_block_size),			\
-		.pimr_mask = (_pimr_mask),			\
-	})
 
 /*****************************************************************************
 Utility Functions*/
@@ -135,7 +128,7 @@ void dmac1_mask_periphral_intr(struct middma_device *mid)
  *
  * UnMasks the DMA periphral interrupt,
  * this is valid for DMAC1 family controllers only
- * This controller should have periphral mask registers already mapped
+ * This controller should have peripheral mask registers already mapped
  */
 void dmac1_unmask_periphral_intr(struct intel_mid_dma_chan *midc)
 {
@@ -228,6 +221,7 @@ static void midc_desc_put(struct intel_mid_dma_chan *midc,
 		spin_unlock_bh(&midc->lock);
 	}
 }
+
 /**
  * midc_dostart		-		begin a DMA transaction
  * @midc: channel for which txn is to be started
@@ -248,8 +242,9 @@ static void midc_dostart(struct intel_mid_dma_chan *midc,
 		/* The tasklet will hopefully advance the queue... */
 		return;
 	}
-	midc->busy = true;
+
 	/*write registers and en*/
+	midc->busy = true;
 	iowrite32(first->sar, midc->ch_regs + SAR);
 	iowrite32(first->dar, midc->ch_regs + DAR);
 	iowrite32(first->lli_phys, midc->ch_regs + LLP);
@@ -286,7 +281,6 @@ static void midc_descriptor_complete(struct intel_mid_dma_chan *midc,
 	dma_cookie_complete(txd);
 	callback_txd = txd->callback;
 	param_txd = txd->callback_param;
-
 	if (desc->lli != NULL) {
 		/*clear the DONE bit of completed LLI in memory*/
 		llitem = desc->lli + desc->current_lli;
@@ -315,6 +309,7 @@ static void midc_descriptor_complete(struct intel_mid_dma_chan *midc,
 	spin_lock_bh(&midc->lock);
 
 }
+
 /**
  * midc_scan_descriptors -		check the descriptors in channel
  *					mark completed when tx is completete
@@ -335,7 +330,8 @@ static void midc_scan_descriptors(struct middma_device *mid,
 			midc_descriptor_complete(midc, desc);
 	}
 	return;
-	}
+}
+
 /**
  * midc_lli_fill_sg -		Helper function to convert
  *				SG list to Linked List Items.
@@ -381,7 +377,7 @@ static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 				pr_debug("MDMA: LLI is configured in circular mode\n");
 				lli_next = desc->lli_phys;
 			} else {
-				lli_next = 0;
+				lli_next = (dma_addr_t)lli_bloc_desc; /* Needs to be !0 */
 				ctl_lo.ctlx.llp_dst_en = 0;
 				ctl_lo.ctlx.llp_src_en = 0;
 			}
@@ -399,11 +395,10 @@ static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 			lli_bloc_desc->sar  = mids->dma_slave.src_addr;
 			lli_bloc_desc->dar  = sg_phy_addr;
 		}
-		/*Copy values into block descriptor in system memroy*/
+		/*Copy values into block descriptor in system memory*/
 		lli_bloc_desc->llp = lli_next;
 		lli_bloc_desc->ctl_lo = ctl_lo.ctl_lo;
 		lli_bloc_desc->ctl_hi = ctl_hi.ctl_hi;
-
 		lli_bloc_desc++;
 	}
 	/*Copy very first LLI values to descriptor*/
@@ -552,7 +547,6 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 	return 0;
 }
 
-
 /**
  * intel_mid_dma_prep_memcpy -	Prep memcpy txn
  * @chan: chan for DMA transfer
@@ -589,11 +583,11 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	mids = midc->mid_slave;
 	BUG_ON(!mids);
 
-	pr_debug("MDMA:called for DMA %x CH %d Length %zu\n",
-				midc->dma->pci_id, midc->ch_id, len);
-	pr_debug("MDMA:Cfg passed Mode %x, Dirn %x, HS %x, Width %x\n",
+	pr_debug("MDMA:called for DMA %x CH %d Length %zu src_addr 0x%08x dst 0x%08x\n",
+				midc->dma->pci_id, midc->ch_id, len, (u32)src, (u32)dest);
+	pr_debug("MDMA:Cfg passed Mode %x, Dirn %d, Handshake %s, Width %x\n",
 			mids->cfg_mode, mids->dma_slave.direction,
-			mids->hs_mode, mids->dma_slave.src_addr_width);
+			mids->hs_mode == LNW_DMA_HW_HS ? "hardware" : "software" , mids->dma_slave.src_addr_width);
 
 	/*calculate CFG_LO*/
 	if (mids->hs_mode == LNW_DMA_SW_HS) {
@@ -629,6 +623,13 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 			cfg_hi.cfgx.protctl = 0x1; /*default value*/
 			cfg_hi.cfgx.src_per = cfg_hi.cfgx.dst_per =
 					midc->ch_id - midc->dma->chan_base;
+			/* Quark - set polarity active low - make a param */
+			if(midc->dma->is_quark){
+				cfg_lo.cfgx.dst_hs_pol = 0x1;
+				cfg_lo.cfgx.src_hs_pol = 0x1;
+				cfg_lo.cfgx.hs_sel_dst = 0x00;
+				cfg_lo.cfgx.hs_sel_src = 0x01;
+			}
 		}
 	}
 
@@ -638,13 +639,18 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	width = mids->dma_slave.src_addr_width;
 
 	ctl_hi.ctlx.block_ts = get_block_ts(len, width, midc->dma->block_size);
-	pr_debug("MDMA:calc len %d for block size %d\n",
+	pr_debug("MDMA:calc len (block_ts) %d for block size %d\n",
 				ctl_hi.ctlx.block_ts, midc->dma->block_size);
 	/*calculate CTL_LO*/
 	ctl_lo.ctl_lo = 0;
 	ctl_lo.ctlx.int_en = 1;
-	ctl_lo.ctlx.dst_msize = mids->dma_slave.src_maxburst;
-	ctl_lo.ctlx.src_msize = mids->dma_slave.dst_maxburst;
+	/* Note Quark: original driver inverted these two values - need to
+	 * resolve before integration - have we missed a trick ? */
+	ctl_lo.ctlx.dst_msize = mids->dma_slave.dst_maxburst;
+	ctl_lo.ctlx.src_msize = mids->dma_slave.src_maxburst;
+	pr_debug("MDMA:Cfg dst_msize 0x%x src_msize 0x%x\n", ctl_lo.ctlx.src_msize, ctl_lo.ctlx.dst_msize);
+	pr_debug("MDMA:Cfg mids->dma_slave.dst_maxburst 0x%x mids->dma_slave.src_maxburst 0x%x\n", mids->dma_slave.src_maxburst,
+mids->dma_slave.dst_maxburst);
 
 	/*
 	 * Here we need some translation from "enum dma_slave_buswidth"
@@ -673,9 +679,8 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 		}
 	}
 
-	pr_debug("MDMA:Calc CTL LO %x, CTL HI %x, CFG LO %x, CFG HI %x\n",
+	pr_debug("MDMA:Calc CTL LO 0x%x, CTL HI 0x%x, CFG LO 0x%x CFG HI 0x%x\n",
 		ctl_lo.ctl_lo, ctl_hi.ctl_hi, cfg_lo.cfg_lo, cfg_hi.cfg_hi);
-
 	enable_dma_interrupt(midc);
 
 	desc = midc_desc_get(midc);
@@ -734,7 +739,7 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_slave_sg(
 	mids = midc->mid_slave;
 	BUG_ON(!mids);
 
-	if (!midc->dma->pimr_mask) {
+	if (!midc->dma->is_quark && !midc->dma->pimr_mask) {
 		/* We can still handle sg list with only one item */
 		if (sg_len == 1) {
 			txd = intel_mid_dma_prep_memcpy(chan,
@@ -752,7 +757,8 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_slave_sg(
 	pr_debug("MDMA: SG Length = %d, direction = %d, Flags = %#lx\n",
 			sg_len, direction, flags);
 
-	txd = intel_mid_dma_prep_memcpy(chan, 0, 0, sg_dma_len(sgl), flags);
+	txd = intel_mid_dma_prep_memcpy(chan, mids->dma_slave.dst_addr,
+			mids->dma_slave.src_addr, sg_dma_len(sgl), flags);
 	if (NULL == txd) {
 		pr_err("MDMA: Prep memcpy failed\n");
 		return NULL;
@@ -1011,23 +1017,21 @@ static void dma_tasklet2(unsigned long data)
 irqreturn_t intel_mid_dma_interrupt(int irq, void *data)
 {
 	struct middma_device *mid = data;
-	u32 tfr_status, err_status;
+	u32 tfr_status, err_status, block_status;
 	int call_tasklet = 0;
 
 	tfr_status = ioread32(mid->dma_base + RAW_TFR);
+	block_status = ioread32(mid->dma_base + RAW_BLOCK);
 	err_status = ioread32(mid->dma_base + RAW_ERR);
-	if (!tfr_status && !err_status)
+	if (!tfr_status && !err_status && !block_status){
 		return IRQ_NONE;
+	}
 
 	/*DMA Interrupt*/
-#if 0
 	pr_debug("MDMA:Got an interrupt on irq %d\n", irq);
-	pr_debug("MDMA: Status %x, Mask %x\n", tfr_status, mid->intr_mask);
-#else
-	pr_info("MDMA:Got an interrupt on irq %d\n", irq);
-	pr_info("MDMA: Status %x, Mask %x\n", tfr_status, mid->intr_mask);
+	pr_debug("MDMA: raw_tfr %x, raw_err %x raw_block %x Mask %x\n",
+		tfr_status, err_status, block_status, mid->intr_mask);
 
-#endif
 	tfr_status &= mid->intr_mask;
 	if (tfr_status) {
 		/*need to disable intr*/
@@ -1044,7 +1048,7 @@ irqreturn_t intel_mid_dma_interrupt(int irq, void *data)
 	}
 	if (call_tasklet)
 		tasklet_schedule(&mid->tasklet);
-
+	
 	return IRQ_HANDLED;
 }
 EXPORT_SYMBOL(intel_mid_dma_interrupt);
@@ -1221,7 +1225,9 @@ void middma_shutdown(struct pci_dev *pdev, struct middma_device *device)
 * @state: PM message
 *
 * This function is called by OS when a power event occurs
+* TBD in 1.1 release 
 */
+#if 0
 static int dma_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
@@ -1233,15 +1239,18 @@ static int dma_suspend(struct device *dev)
 		if (device->ch[i].in_use)
 			return -EAGAIN;
 	}
-#if 0
-	dmac1_mask_periphral_intr(device);
-#endif
+
+	if(!device->is_quark){
+		dmac1_mask_periphral_intr(device);
+	}
+
 	device->state = SUSPENDED;
 	pci_save_state(pci);
 	pci_disable_device(pci);
 	pci_set_power_state(pci, PCI_D3hot);
 	return 0;
 }
+#endif
 
 /**
 * dma_resume - PCI resume function
@@ -1260,6 +1269,16 @@ int middma_resume(struct device *dev)
 	return 0;
 }
 
+/*
+* dma_runtime_suspend - PCI suspend function
+*
+* @pci: PCI device structure
+* @state: PM message
+*
+* This function is called by OS when a power event occurs
+* TBD in 1.1 release 
+*/
+#if 0
 static int dma_runtime_suspend(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -1268,7 +1287,18 @@ static int dma_runtime_suspend(struct device *dev)
 	device->state = SUSPENDED;
 	return 0;
 }
+#endif
 
+/*
+* dma_runtime_resume - PCI suspend function
+*
+* @pci: PCI device structure
+* @state: PM message
+*
+* This function is called by OS when a power event occurs
+* TBD in 1.1 release 
+*/
+#if 0
 static int dma_runtime_resume(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -1278,7 +1308,18 @@ static int dma_runtime_resume(struct device *dev)
 	iowrite32(REG_BIT0, device->dma_base + DMA_CFG);
 	return 0;
 }
+#endif
 
+/*
+* dma_runtime_idle - PCI suspend function
+*
+* @pci: PCI device structure
+* @state: PM message
+*
+* This function is called by OS when a power event occurs
+* TBD in 1.1 release 
+*/
+#if 0
 static int dma_runtime_idle(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
@@ -1292,4 +1333,4 @@ static int dma_runtime_idle(struct device *dev)
 
 	return pm_schedule_suspend(dev, 0);
 }
-
+#endif
diff --git a/drivers/dma/intel_mid_dma_pci.c b/drivers/dma/intel_mid_dma_pci.c
index bd753b9..b0d3ab1 100644
--- a/drivers/dma/intel_mid_dma_pci.c
+++ b/drivers/dma/intel_mid_dma_pci.c
@@ -23,6 +23,7 @@
  *
  *
  */
+#define DEBUG
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/pm_runtime.h>
@@ -30,19 +31,19 @@
 #include <linux/module.h>
 
 #include "intel_mid_dma_regs.h"
-//#include "intel_mid_dma_core.h"
 
 #define INTEL_MID_DMAC1_ID		0x0814
 #define INTEL_MID_DMAC2_ID		0x0813
 #define INTEL_MID_GP_DMAC2_ID		0x0827
 #define INTEL_MFLD_DMAC1_ID		0x0830
 
-#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask) \
+#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask, _is_quark) \
 	((kernel_ulong_t)&(struct intel_mid_dma_probe_info) {	\
 		.max_chan = (_max_chan),			\
 		.ch_base = (_ch_base),				\
 		.block_size = (_block_size),			\
 		.pimr_mask = (_pimr_mask),			\
+		.is_quark = (_is_quark),				\
 	})
 
 /**
@@ -105,6 +106,7 @@ static int intel_mid_dma_probe(struct pci_dev *pdev,
 	device->chan_base = info->ch_base;
 	device->block_size = info->block_size;
 	device->pimr_mask = info->pimr_mask;
+	device->is_quark = info->is_quark;
 
 	err = mid_setup_dma(pdev, device);
 	if (err)
@@ -242,10 +244,10 @@ static int dma_runtime_idle(struct device *dev)
 * PCI stuff
 */
 static struct pci_device_id intel_mid_dma_ids[] = {
-	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC1_ID),	INFO(2, 6, 4095, 0x200020)},
-	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC2_ID),	INFO(2, 0, 2047, 0)},
-	{ PCI_VDEVICE(INTEL, INTEL_MID_GP_DMAC2_ID),	INFO(2, 0, 2047, 0)},
-	{ PCI_VDEVICE(INTEL, INTEL_MFLD_DMAC1_ID),	INFO(4, 0, 4095, 0x400040)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC1_ID),	INFO(2, 6, 4095, 0x200020, 0)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC2_ID),	INFO(2, 0, 2047, 0, 0)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_GP_DMAC2_ID),	INFO(2, 0, 2047, 0, 0)},
+	{ PCI_VDEVICE(INTEL, INTEL_MFLD_DMAC1_ID),	INFO(4, 0, 4095, 0x400040, 0)},
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, intel_mid_dma_ids);
diff --git a/drivers/dma/intel_mid_dma_regs.h b/drivers/dma/intel_mid_dma_regs.h
old mode 100644
new mode 100755
index 4092fe3..fc90cdc
--- a/drivers/dma/intel_mid_dma_regs.h
+++ b/drivers/dma/intel_mid_dma_regs.h
@@ -169,14 +169,29 @@ static inline struct middma_device *to_middma_device(struct dma_device *common)
 	return container_of(common, struct middma_device, common);
 }
 
+#if CONFIG_INTEL_QUARK_X1000_SOC
 struct intel_mid_dma_lli {
 	dma_addr_t			sar;
 	dma_addr_t			dar;
 	dma_addr_t			llp;
 	u32				ctl_lo;
 	u32				ctl_hi;
+	u32				sstatx;
+	u32				dstatx;
 } __attribute__ ((packed));
 
+#else
+
+struct intel_mid_dma_lli {
+	dma_addr_t			sar;
+	dma_addr_t			dar;
+	dma_addr_t			llp;
+	u32				ctl_lo;
+	u32				ctl_hi;
+} __attribute__ ((packed));
+
+#endif
+
 static inline int test_ch_en(void __iomem *dma, u32 ch_no)
 {
 	u32 en_reg = ioread32(dma + DMA_CHAN_EN);
diff --git a/drivers/dma/intel_qrk_dma_pci.c b/drivers/dma/intel_qrk_dma_pci.c
index cbac334..c692e95 100644
--- a/drivers/dma/intel_qrk_dma_pci.c
+++ b/drivers/dma/intel_qrk_dma_pci.c
@@ -34,7 +34,6 @@
 #include <linux/intel_mid_dma.h>
 #include <linux/module.h>
 
-//#include "intel_mid_dma_core.h"
 #include "intel_mid_dma_regs.h"
 
 /**
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
old mode 100644
new mode 100755
index 732ec24..b5fa3e9
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -274,7 +274,7 @@ config GPIO_PCA953X
 
 config GPIO_PCA953X_IRQ
 	bool "Interrupt controller support for PCA953x"
-	depends on GPIO_PCA953X=y
+	depends on GPIO_PCA953X
 	help
 	  Say yes here to enable the pca953x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
old mode 100644
new mode 100755
index 09d5dad..ceb1a47
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -33,6 +33,12 @@
 #define PCA953X_INVERT		2
 #define PCA953X_DIRECTION	3
 
+#define PCAL953X_IN_LATCH	34
+#define PCAL953X_PUPD_EN	35
+#define PCAL953X_PUPD_SEL	36
+#define PCAL953X_INT_MASK	37
+#define PCAL953X_INT_STAT	38
+
 #define REG_ADDR_AI		0x80
 
 #define PCA957X_IN		0
@@ -48,6 +54,7 @@
 #define PCA_INT			0x0100
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
+#define PCAL953X_TYPE		0x4000
 
 static const struct i2c_device_id pca953x_id[] = {
 	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
@@ -58,6 +65,7 @@ static const struct i2c_device_id pca953x_id[] = {
 	{ "pca9539", 16 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9554", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "pca9555", 16 | PCA953X_TYPE | PCA_INT, },
+	{ "pcal9555a", 16 | PCAL953X_TYPE | PCA_INT, },
 	{ "pca9556", 8  | PCA953X_TYPE, },
 	{ "pca9557", 8  | PCA953X_TYPE, },
 	{ "pca9574", 8  | PCA957X_TYPE | PCA_INT, },
@@ -80,6 +88,8 @@ struct pca953x_chip {
 	unsigned gpio_start;
 	u32 reg_output;
 	u32 reg_direction;
+	u32 reg_pupd_en;
+	u32 reg_pupd_sel;
 	struct mutex i2c_lock;
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
@@ -206,9 +216,9 @@ static int pca953x_write_reg(struct pca953x_chip *chip, int reg, u32 val)
 						(reg << 2) | REG_ADDR_AI,
 						3,
 						(u8 *) &val);
-	}
-	else {
+	} else {
 		switch (chip->chip_type) {
+		case PCAL953X_TYPE:
 		case PCA953X_TYPE:
 			ret = i2c_smbus_write_word_data(chip->client,
 							reg << 1, val);
@@ -240,8 +250,7 @@ static int pca953x_read_reg(struct pca953x_chip *chip, int reg, u32 *val)
 	if (chip->gpio_chip.ngpio <= 8) {
 		ret = i2c_smbus_read_byte_data(chip->client, reg);
 		*val = ret;
-	}
-	else if (chip->gpio_chip.ngpio == 24) {
+	} else if (chip->gpio_chip.ngpio == 24) {
 		*val = 0;
 		ret = i2c_smbus_read_i2c_block_data(chip->client,
 						(reg << 2) | REG_ADDR_AI,
@@ -273,6 +282,7 @@ static int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)
 	reg_val = chip->reg_direction | (1u << off);
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -313,6 +323,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 		reg_val = chip->reg_output & ~(1u << off);
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_OUTPUT;
 		break;
@@ -329,6 +340,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 	/* then direction */
 	reg_val = chip->reg_direction & ~(1u << off);
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -357,6 +369,7 @@ static int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)
 
 	mutex_lock(&chip->i2c_lock);
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
 		break;
@@ -392,6 +405,7 @@ static void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
 		reg_val = chip->reg_output & ~(1u << off);
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_OUTPUT;
 		break;
@@ -408,6 +422,60 @@ exit:
 	mutex_unlock(&chip->i2c_lock);
 }
 
+static int pca953x_gpio_set_drive(struct gpio_chip *gc,
+				  unsigned off, unsigned mode)
+{
+	struct pca953x_chip *chip;
+	u32 pupd_en_reg_val, pupd_sel_reg_val;
+	int ret = 0;
+
+	chip = container_of(gc, struct pca953x_chip, gpio_chip);
+
+	if (chip->chip_type != PCAL953X_TYPE)
+		return -EINVAL;
+
+	mutex_lock(&chip->i2c_lock);
+
+	switch (mode) {
+	case GPIOF_DRIVE_PULLUP:
+		pupd_en_reg_val = chip->reg_pupd_en | (1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel | (1u << off);
+		break;
+	case GPIOF_DRIVE_PULLDOWN:
+		pupd_en_reg_val = chip->reg_pupd_en | (1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel & ~(1u << off);
+		break;
+	case GPIOF_DRIVE_STRONG:
+	case GPIOF_DRIVE_HIZ:
+		pupd_en_reg_val = chip->reg_pupd_en & ~(1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel;
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (pupd_en_reg_val != chip->reg_pupd_en) {
+		ret = pca953x_write_reg(chip, PCAL953X_PUPD_EN,
+					pupd_en_reg_val);
+		if (ret)
+			goto exit;
+		chip->reg_pupd_en = pupd_en_reg_val;
+	}
+
+	if (pupd_sel_reg_val != chip->reg_pupd_sel) {
+		ret = pca953x_write_reg(chip, PCAL953X_PUPD_SEL,
+					pupd_sel_reg_val);
+		if (ret)
+			goto exit;
+		chip->reg_pupd_sel = pupd_sel_reg_val;
+	}
+
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
 static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 {
 	struct gpio_chip *gc;
@@ -426,6 +494,9 @@ static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 	gc->dev = &chip->client->dev;
 	gc->owner = THIS_MODULE;
 	gc->names = chip->names;
+
+	if (chip->chip_type == PCAL953X_TYPE)
+		gc->set_drive = pca953x_gpio_set_drive;
 }
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
@@ -473,6 +544,15 @@ static void pca953x_irq_bus_sync_unlock(struct irq_data *d)
 		pca953x_gpio_direction_input(&chip->gpio_chip, level);
 		new_irqs &= ~(1 << level);
 	}
+ 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		/* Enable latch on interrupt-enabled inputs */
+		pca953x_write_reg(chip, PCAL953X_IN_LATCH,
+				  chip->irq_mask);
+		/* Unmask enabled interrupts */
+		pca953x_write_reg(chip, PCAL953X_INT_MASK,
+				  ~chip->irq_mask);
+	}
 
 	mutex_unlock(&chip->irq_lock);
 }
@@ -518,7 +598,26 @@ static u32 pca953x_irq_pending(struct pca953x_chip *chip)
 	u32 trigger;
 	int ret, offset = 0;
 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		/* Read the current interrupt status from the device */
+		ret = pca953x_read_reg(chip, PCAL953X_INT_STAT, &pending);
+		if (ret)
+			return 0;
+
+		/* Check latched inputs and clear interrupt status */
+		ret = pca953x_read_reg(chip, PCA953X_INPUT, &cur_stat);
+		if (ret)
+			return 0;
+
+		/* Apply filter for rising/falling edge selection */
+		pending &= (~cur_stat & chip->irq_trig_fall) |
+			(cur_stat & chip->irq_trig_raise);
+
+		return pending;
+	}
+
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
 		break;
@@ -660,37 +759,42 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 			     const struct i2c_device_id *id, int irq_base)
 {
 	struct i2c_client *client = chip->client;
-	int ret, offset = 0;
+	int ret = 0, offset = 0;
+	unsigned long flags;
 	u32 temporary;
 
 	if (irq_base != -1 && (id->driver_data & PCA_INT)) {
 		int lvl;
 
-		switch (chip->chip_type) {
-		case PCA953X_TYPE:
-			offset = PCA953X_INPUT;
-			break;
-		case PCA957X_TYPE:
-			offset = PCA957X_IN;
-			break;
-		}
-		ret = pca953x_read_reg(chip, offset, &temporary);
-		chip->irq_stat = temporary;
-		if (ret)
-			goto out_failed;
+		if (chip->chip_type != PCAL953X_TYPE) {
+			switch (chip->chip_type) {
+			case PCA953X_TYPE:
+				offset = PCA953X_INPUT;
+				break;
+			case PCA957X_TYPE:
+				offset = PCA957X_IN;
+				break;
+			}
+			ret = pca953x_read_reg(chip, offset, &temporary);
+			chip->irq_stat = temporary;
+			if (ret)
+				goto out_failed;
 
-		/*
-		 * There is no way to know which GPIO line generated the
-		 * interrupt.  We have to rely on the previous read for
-		 * this purpose.
-		 */
-		chip->irq_stat &= chip->reg_direction;
+			/*
+			 * There is no way to know which GPIO line generated the
+			 * interrupt.  We have to rely on the previous read for
+			 * this purpose.
+			 */
+			chip->irq_stat &= chip->reg_direction;
+		}
 		mutex_init(&chip->irq_lock);
 
-		chip->irq_base =
-		    irq_alloc_descs(-1, irq_base, chip->gpio_chip.ngpio, -1);
-		if (chip->irq_base < 0)
+		chip->irq_base = irq_alloc_descs(-1, irq_base,
+						 chip->gpio_chip.ngpio, -1);
+		if (chip->irq_base < 0) {
+			ret = chip->irq_base;
 			goto out_failed;
+		}
 
 		chip->domain = irq_domain_add_legacy(client->dev.of_node,
 						chip->gpio_chip.ngpio,
@@ -716,12 +820,17 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 			irq_set_noprobe(irq);
 #endif
 		}
+ 
+		if (chip->chip_type == PCAL953X_TYPE)
+			flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+		else
+			flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
 
 #ifndef CONFIG_GPIO_PCA9555_FRI2
 		ret = request_threaded_irq(client->irq,
 					   NULL,
 					   pca953x_irq_handler,
-					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+					   flags,
 					   dev_name(&client->dev), chip);
 		if (ret) {
 			dev_err(&client->dev, "failed to request irq %d\n",
@@ -755,6 +864,8 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 #endif
 
 		chip->gpio_chip.to_irq = pca953x_gpio_to_irq;
+	} else {
+		chip->irq_base = -1;
 	}
 
 	return 0;
@@ -856,6 +967,18 @@ pca953x_get_alt_pdata(struct i2c_client *client, int *gpio_base, u32 *invert)
 static int __devinit device_pca953x_init(struct pca953x_chip *chip, u32 invert)
 {
 	int ret;
+ 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		ret = pca953x_read_reg(chip, PCAL953X_PUPD_EN,
+				       &chip->reg_pupd_en);
+		if (ret)
+			goto out;
+
+		ret = pca953x_read_reg(chip, PCAL953X_PUPD_SEL,
+				       &chip->reg_pupd_sel);
+		if (ret)
+			goto out;
+	}
 
 	ret = pca953x_read_reg(chip, PCA953X_OUTPUT, &chip->reg_output);
 	if (ret)
@@ -927,16 +1050,18 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 	} else {
 		pca953x_get_alt_pdata(client, &chip->gpio_start, &invert);
 #ifdef CONFIG_OF_GPIO
-		/* If I2C node has no interrupts property, disable GPIO interrupts */
-		if (of_find_property(client->dev.of_node, "interrupts", NULL) ==
-		    NULL)
+		/* If I2C node has no interrupts property, disable
+		 * GPIO interrupts */
+		if (of_find_property(client->dev.of_node,
+				     "interrupts", NULL) == NULL)
 			irq_base = -1;
 #endif
 	}
 
 	chip->client = client;
 
-	chip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);
+	chip->chip_type = id->driver_data &
+		(PCAL953X_TYPE | PCA953X_TYPE | PCA957X_TYPE);
 
 	mutex_init(&chip->i2c_lock);
 
@@ -945,7 +1070,7 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 	 */
 	pca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);
 
-	if (chip->chip_type == PCA953X_TYPE)
+	if (chip->chip_type & (PCA953X_TYPE | PCAL953X_TYPE))
 		ret = device_pca953x_init(chip, invert);
 	else
 		ret = device_pca957x_init(chip, invert);
diff --git a/drivers/gpio/gpio-sch.c b/drivers/gpio/gpio-sch.c
index e25cc36..e04772d 100755
--- a/drivers/gpio/gpio-sch.c
+++ b/drivers/gpio/gpio-sch.c
@@ -26,6 +26,7 @@
 #include <linux/acpi.h>
 #include <linux/platform_device.h>
 #include <linux/pci_ids.h>
+#include <linux/uio_driver.h>
 
 #include <linux/gpio.h>
 #include <linux/interrupt.h>
@@ -60,6 +61,8 @@ static DEFINE_SPINLOCK(gpio_lock);
 
 static unsigned long gpio_ba;
 
+static struct uio_info *info;
+
 static int irq_num;
 
 struct sch_gpio_core_int_regvals {
@@ -605,6 +608,15 @@ static int __devinit sch_gpio_probe(struct platform_device *pdev)
 	if (!id)
 		return -ENODEV;
 
+	/* Get UIO memory */
+	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+ 	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+ 	if (!res)
+ 		return -EBUSY;
+
 	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
 	if (!res)
 		return -EBUSY;
@@ -708,8 +720,26 @@ static int __devinit sch_gpio_probe(struct platform_device *pdev)
 	sch_gpio_core_irqs_init(chip, sch_gpio_core.ngpio);
 	sch_gpio_resume_irqs_init(chip, sch_gpio_resume.ngpio);
 
+	/* UIO */
+	info->port[0].name = "gpio_regs";
+	info->port[0].start = res->start;
+	info->port[0].size = resource_size(res);
+	info->port[0].porttype = UIO_PORT_X86;
+	info->name = "sch_gpio";
+	info->version = "0.0.1";
+
+	if (uio_register_device(&pdev->dev, info))
+		goto err_sch_uio_register;
+
+	pr_info("%s UIO port addr 0x%04x size %lu porttype %d\n",
+		__func__, (unsigned int)info->port[0].start,
+		info->port[0].size, info->port[0].porttype);
+
 	return 0;
 
+err_sch_uio_register:
+	free_irq(irq_num, chip);
+
 err_sch_request_irq:
 	platform_device_unregister(&qrk_gpio_restrict_pdev);
 
@@ -741,6 +771,9 @@ err_sch_gpio_core:
 	kfree(chip);
 	chip_ptr = 0;
 
+	if (info != NULL)
+		kfree(info);
+
 	return err;
 }
 
@@ -752,6 +785,11 @@ static int __devexit sch_gpio_remove(struct platform_device *pdev)
 	struct sch_gpio *chip = platform_get_drvdata(pdev);
 
 	if (gpio_ba) {
+		if (info != NULL) {
+			uio_unregister_device(info);
+			kfree(info);
+		}
+
 		sch_gpio_resume_irqs_deinit(chip, sch_gpio_resume.ngpio);
 		sch_gpio_core_irqs_deinit(chip, sch_gpio_core.ngpio);
 
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
old mode 100644
new mode 100755
index 986bc22..1158326
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -137,4 +137,16 @@ config MAX78M6610_LMU
 	  To compile this driver as a module, choose M here: the
 	  module will be called max78m6610_lmu.
 
+config ADC1x8S102
+	tristate "Texas Instruments ADC1x8S102 driver"
+	depends on SPI
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	help
+	  Say yes here to build support for Texas Instruments ADC1x8S102 ADC.
+	  Provides direct access via sysfs.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called adc1x8s102
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
old mode 100644
new mode 100755
index 891ffa0..f3a77e0
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_LP8788_ADC) += lp8788_adc.o
 obj-$(CONFIG_MAX1363) += max1363.o
 obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
 obj-$(CONFIG_MAX78M6610_LMU) += max78m6610_lmu.o
+obj-$(CONFIG_ADC1x8S102) += adc1x8s102.o
diff --git a/drivers/iio/adc/adc1x8s102.c b/drivers/iio/adc/adc1x8s102.c
new file mode 100644
index 0000000..b4de3a9
--- /dev/null
+++ b/drivers/iio/adc/adc1x8s102.c
@@ -0,0 +1,387 @@
+/*
+ * ADC1x8S102 SPI ADC driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * This IIO device driver is is designed to work with the following
+ * analog to digital converters from Texas Instruments:
+ *  ADC108S102
+ *  ADC128S102
+ * The communication with ADC chip is via the SPI bus (mode 3).
+ */
+
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/types.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <linux/platform_data/adc1x8s102.h>
+#include <linux/regulator/consumer.h>
+
+/*
+ * Defining the ADC resolution being 12 bits, we can use the same driver for
+ * both ADC108S102 (10 bits resolution) and ADC128S102 (12 bits resolution)
+ * chips. The ADC108S102 effectively returns a 12-bit result with the 2
+ * least-significant bits unset.
+ */
+#define ADC1x8S102_BITS		12
+#define ADC1x8S102_MAX_CHANNELS	8
+
+/* 16-bit SPI command format:
+ *   [15:14] Ignored
+ *   [13:11] 3-bit channel address
+ *   [10:0]  Ignored
+ */
+#define ADC1x8S102_CMD(ch)		(((ch) << (8)) << (3))
+
+/*
+ * 16-bit SPI response format:
+ *   [15:12] Zeros
+ *   [11:0]  12-bit ADC sample (for ADC108S102, [1:0] will always be 0).
+ */
+#define ADC1x8S102_RES_DATA(res)	(res & ((1 << ADC1x8S102_BITS) - 1))
+
+struct adc1x8s102_state {
+	struct spi_device		*spi;
+	struct regulator		*reg;
+	u16				ext_vin;
+	/* SPI transfer used by triggered buffer handler*/
+	struct spi_transfer		ring_xfer;
+	/* SPI transfer used by direct scan */
+	struct spi_transfer		scan_single_xfer;
+	/* SPI message used by ring_xfer SPI transfer */
+	struct spi_message		ring_msg;
+	/* SPI message used by scan_single_xfer SPI transfer */
+	struct spi_message		scan_single_msg;
+
+	/* SPI message buffers:
+	 *  tx_buf: |C0|C1|C2|C3|C4|C5|C6|C7|XX|
+	 *  rx_buf: |XX|R0|R1|R2|R3|R4|R5|R6|R7|tt|tt|tt|tt|
+	 *
+	 *  tx_buf: 8 channel read commands, plus 1 dummy command
+	 *  rx_buf: 1 dummy response, 8 channel responses, plus 64-bit timestamp
+	 */
+	__be16				rx_buf[13] ____cacheline_aligned;
+	__be16				tx_buf[9];
+
+};
+
+#define ADC1X8S102_V_CHAN(index)					\
+	{								\
+		.type = IIO_VOLTAGE,					\
+		.indexed = 1,						\
+		.channel = index,					\
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT |		\
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT,		\
+		.address = index,					\
+		.scan_index = index,					\
+		.scan_type = {						\
+			.sign = 'u',					\
+			.realbits = ADC1x8S102_BITS,			\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+	}
+
+static const struct iio_chan_spec adc1x8s102_channels[] = {
+	ADC1X8S102_V_CHAN(0),
+	ADC1X8S102_V_CHAN(1),
+	ADC1X8S102_V_CHAN(2),
+	ADC1X8S102_V_CHAN(3),
+	ADC1X8S102_V_CHAN(4),
+	ADC1X8S102_V_CHAN(5),
+	ADC1X8S102_V_CHAN(6),
+	ADC1X8S102_V_CHAN(7),
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+};
+
+
+static int adc1x8s102_update_scan_mode(struct iio_dev *indio_dev,
+		unsigned long const *active_scan_mask)
+{
+	struct adc1x8s102_state *st;
+	int i, j;
+
+	st = iio_priv(indio_dev);
+
+	/* Fill in the first x shorts of tx_buf with the number of channels
+	 * enabled for sampling by the triggered buffer
+	 */
+	for (i = 0, j = 0; i < ADC1x8S102_MAX_CHANNELS; i++) {
+		if (test_bit(i, active_scan_mask)) {
+			st->tx_buf[j] = cpu_to_be16(ADC1x8S102_CMD(i));
+			j++;
+		}
+	}
+	/* One dummy command added, to clock in the last response */
+	st->tx_buf[j] = 0x00;
+
+	/* build SPI ring message */
+	st->ring_xfer.tx_buf = &st->tx_buf[0];
+	st->ring_xfer.rx_buf = &st->rx_buf[0];
+	st->ring_xfer.len = (j + 1) * sizeof(__be16);
+
+	spi_message_init(&st->ring_msg);
+	spi_message_add_tail(&st->ring_xfer, &st->ring_msg);
+
+	return 0;
+}
+
+
+static irqreturn_t adc1x8s102_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev;
+	struct adc1x8s102_state *st;
+	s64 time_ns = 0;
+	int b_sent;
+
+	indio_dev = pf->indio_dev;
+	st = iio_priv(indio_dev);
+
+	b_sent = spi_sync(st->spi, &st->ring_msg);
+	if (b_sent)
+		goto done;
+	if (indio_dev->scan_timestamp) {
+		time_ns = iio_get_time_ns();
+		memcpy((u8 *)st->rx_buf + st->ring_xfer.len, &time_ns,
+				sizeof(time_ns));
+	}
+
+	/* Skip the dummy response in the first slot */
+	iio_push_to_buffers(indio_dev, (u8 *)&st->rx_buf[1]);
+done:
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * returns:
+ * positive (>=0)  value => SUCCESS
+ * negative value => FAILURE
+ */
+static int adc1x8s102_scan_direct(struct adc1x8s102_state *st, unsigned ch)
+{
+	int ret;
+
+	if (ch >= ADC1x8S102_MAX_CHANNELS) {
+		dev_err(&st->spi->dev, "AD channel number too big: %u\n", ch);
+		return -1;
+	}
+
+	st->tx_buf[0] = cpu_to_be16(ADC1x8S102_CMD(ch));
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret)
+		return ret;
+
+	/* Skip the dummy response in the first slot */
+	return be16_to_cpu(st->rx_buf[1]);
+}
+
+
+/*
+ * returns:
+ * positive (>=0)  value => SUCCESS
+ * negative value => FAILURE
+ */
+static int adc1x8s102_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	int ret;
+	struct adc1x8s102_state *st;
+
+	st = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			ret = -EBUSY;
+			dev_warn(&st->spi->dev,
+			 "indio_dev->currentmode is INDIO_BUFFER_TRIGGERED\n");
+		} else {
+			ret = adc1x8s102_scan_direct(st, chan->address);
+		}
+		mutex_unlock(&indio_dev->mlock);
+
+		if (ret < 0)
+			return ret;
+		*val = ADC1x8S102_RES_DATA(ret);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_VOLTAGE:
+			if (NULL != st->reg)
+				*val = regulator_get_voltage(st->reg) / 1000;
+			else
+				*val = st->ext_vin;
+
+			*val2 = chan->scan_type.realbits;
+			return IIO_VAL_FRACTIONAL_LOG2;
+		default:
+			dev_warn(&st->spi->dev,
+				 "Invalid channel type %u for channel %d\n",
+				 chan->type, chan->channel);
+			return -EINVAL;
+		}
+	default:
+		dev_warn(&st->spi->dev, "Invalid IIO_CHAN_INFO: %lu\n", m);
+		return -EINVAL;
+	}
+}
+
+
+
+static const struct iio_info adc1x8s102_info = {
+	.read_raw		= &adc1x8s102_read_raw,
+	.update_scan_mode	= &adc1x8s102_update_scan_mode,
+	.driver_module		= THIS_MODULE,
+};
+
+
+static int adc1x8s102_probe(struct spi_device *spi)
+{
+	struct adc1x8s102_platform_data *pdata = spi->dev.platform_data;
+	struct adc1x8s102_state *st;
+	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
+	int ret;
+
+	if (NULL == indio_dev) {
+		dev_crit(&spi->dev, "Cannot allocate memory for indio_dev\n");
+		return -ENOMEM;
+	}
+
+	st = iio_priv(indio_dev);
+	if (NULL == pdata) {
+		dev_err(&spi->dev, "Cannot get adc1x8s102 platform data\n");
+		return -EFAULT;
+	}
+	st->ext_vin = pdata->ext_vin;
+
+	/* Use regulator, if available. */
+	st->reg = regulator_get(&spi->dev, "vref");
+	if (IS_ERR(st->reg)) {
+		ret = PTR_ERR(st->reg);
+		dev_warn(&spi->dev,
+			 "Cannot get 'vref' regulator\n");
+		goto error_free;
+	}
+	ret = regulator_enable(st->reg);
+	if (ret < 0) {
+		dev_warn(&spi->dev,
+			 "Cannot enable vref regulator\n");
+		goto error_put_reg;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+	st->spi = spi;
+
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = adc1x8s102_channels;
+	indio_dev->num_channels = ARRAY_SIZE(adc1x8s102_channels);
+	indio_dev->info = &adc1x8s102_info;
+
+	/* Setup default message */
+	st->scan_single_xfer.tx_buf = st->tx_buf;
+	st->scan_single_xfer.rx_buf = st->rx_buf;
+	st->scan_single_xfer.len = 2 * sizeof(__be16);
+	st->scan_single_xfer.cs_change = 0;
+
+	spi_message_init(&st->scan_single_msg);
+	spi_message_add_tail(&st->scan_single_xfer, &st->scan_single_msg);
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+			&adc1x8s102_trigger_handler, NULL);
+	if (ret)
+		goto error_disable_reg;
+
+	ret = iio_device_register(indio_dev);
+	if (ret) {
+		dev_err(&spi->dev,
+			"Failed to register IIO device\n");
+		goto error_cleanup_ring;
+	}
+	return 0;
+
+error_cleanup_ring:
+	iio_triggered_buffer_cleanup(indio_dev);
+error_disable_reg:
+	regulator_disable(st->reg);
+error_put_reg:
+	regulator_put(st->reg);
+error_free:
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+
+static int adc1x8s102_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev;
+	struct adc1x8s102_state *st;
+
+	indio_dev = spi_get_drvdata(spi);
+	if (NULL == indio_dev) {
+		dev_err(&spi->dev, "Cannot get spi_device drvdata\n");
+		return -EFAULT;
+	}
+
+	st = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+
+	iio_triggered_buffer_cleanup(indio_dev);
+
+	regulator_disable(st->reg);
+	regulator_put(st->reg);
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+
+static const struct spi_device_id adc1x8s102_id[] = {
+	{"adc1x8s102", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(spi, adc1x8s102_id);
+
+static struct spi_driver adc1x8s102_driver = {
+	.driver = {
+		.name	= "adc1x8s102",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= adc1x8s102_probe,
+	.remove		= adc1x8s102_remove,
+	.id_table	= adc1x8s102_id,
+};
+module_spi_driver(adc1x8s102_driver);
+
+MODULE_AUTHOR("Bogdan Pricop <bogdan.pricop@emutex.com>");
+MODULE_DESCRIPTION("Texas Instruments ADC1x8S102 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/adc/max78m6610_lmu.c b/drivers/iio/adc/max78m6610_lmu.c
index c427517..ebb2a85 100644
--- a/drivers/iio/adc/max78m6610_lmu.c
+++ b/drivers/iio/adc/max78m6610_lmu.c
@@ -3,21 +3,14 @@
  *
  * Copyright(c) 2013 Intel Corporation.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
  * This SPI protocol driver is developed for the Maxim 78M6610+LMU (eADC).
  * The driver is developed as a part of the Quark BSP where integrated into
@@ -103,8 +96,8 @@
 #define STATUS_MASK_RELAY1   (1 << 2)
 #define STATUS_MASK_RELAY2   (1 << 1)
 #define STATUS_MASK_RESET    (1)
-#define STATUS_MASK_STICKY   (0x73FFF0)
-#define STATUS_MASK_IGNORE   (0x00000F)
+#define STATUS_MASK_STICKY   (0x73FFF1)
+#define STATUS_MASK_IGNORE   (0x00000E)
 
 #define VSURG_VAL	0x13 /* Voltage surge alarm threshold */
 #define VSAG_VAL	0x14 /* Voltage sag alarm threshold */
@@ -167,6 +160,23 @@
 #define SPI_TB_WRITE(x)	((SPI_TB_ADDR_MASK_5_0(x) << 2)\
 			| SPI_OP_WRITE)
 
+#define TIMER_PERIOD_MS	90
+#define TIMER_PERIOD	msecs_to_jiffies(TIMER_PERIOD_MS)
+
+#define MASK0_INT	(STATUS_MASK_OV_AMP2 \
+			| STATUS_MASK_OV_AMP1 \
+			| STATUS_MASK_OV_WATT2 \
+			| STATUS_MASK_OV_WATT1 \
+			| STATUS_MASK_VB_SURGE \
+			| STATUS_MASK_VA_SURGE \
+			| STATUS_MASK_UN_VRMSB \
+			| STATUS_MASK_OV_VRMSB \
+			| STATUS_MASK_UN_VRMSA \
+			| STATUS_MASK_OV_VRMSA \
+			| STATUS_MASK_VB_SAG \
+			| STATUS_MASK_VA_SAG)
+
+
 /**
  * max78m6610_lmu_channels structure maps eADC measurement features to
  * IIO channels on the IIO sysfs user interface
@@ -814,6 +824,7 @@ struct max78m6610_lmu_state {
 	dev_t cdev_no;
 	struct class *cl;
 	u8	*bbuffer;
+	struct timer_list	max78m6610_timer;
 };
 
 /**
@@ -974,7 +985,7 @@ int __max78m6610_lmu_spi_reg_write(struct max78m6610_lmu_state *st,
 		ret = -EIO;
 	}
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -1514,8 +1525,11 @@ static ssize_t max78m6610_lmu_write_flash(struct device *dev,
 	return -1;
 }
 
+static inline int __max78m6610_lmu_mask0_set(struct max78m6610_lmu_state *st);
+static inline int __max78m6610_lmu_mask0_reset(struct max78m6610_lmu_state *st);
+
 /**
- * max78m6610_lmu_flash_save_cmd
+ * max78m6610_lmu_status_scan
  *
  * @param indio_dev: iio_dev pointer
  *
@@ -1528,9 +1542,12 @@ static ssize_t max78m6610_lmu_write_flash(struct device *dev,
 static int max78m6610_lmu_status_scan(struct iio_dev *indio_dev)
 {
 	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
-	unsigned status;
 	int ret;
 	u64 timestamp_ns = iio_get_time_ns();
+	static unsigned old_status;
+	unsigned new_status = 0x00;
+	u16 event_active;
+
 
 	mutex_lock(&indio_dev->mlock);
 	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
@@ -1538,151 +1555,228 @@ static int max78m6610_lmu_status_scan(struct iio_dev *indio_dev)
 		goto exit_unlock;
 	}
 
-	ret = __max78m6610_lmu_spi_reg_read(st, STATUS, &status);
+	/* Disable eADC interrupts - special-reset MASK0 */
+	ret = __max78m6610_lmu_mask0_reset(st);
 	if (ret) {
-		pr_err("Failed to read STATUS register\n");
+		pr_err("Failed to disable interrupts from MASK0!\n");
 		goto exit_unlock;
 	}
 
-	status &= ~STATUS_MASK_IGNORE;
-
-	/* Nothing more to do if no interesting status bits are set */
-	if (!status)
+	ret = __max78m6610_lmu_spi_reg_read(st, STATUS, &new_status);
+	if (ret) {
+		pr_err("Failed to read STATUS register\n");
 		goto exit_unlock;
+	}
+	new_status &= ~STATUS_MASK_IGNORE;
 
 	/* Not all of the event types used below are ideal, but there is a
 	 * limited set available and we want to use different event types for
 	 * the different events (e.g sag vs. min-threshold) to allow user
 	 * applications to distinguish them
 	 */
-	if (status & STATUS_MASK_VA_SAG) {
+	if ((new_status & STATUS_MASK_VA_SAG) ^
+			(old_status & STATUS_MASK_VA_SAG)) {
+		event_active = !!(new_status & STATUS_MASK_VA_SAG);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
-						    IIO_EV_TYPE_MAG,
-						    IIO_EV_DIR_FALLING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_FALLING,
+					IIO_EV_TYPE_MAG,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_VB_SAG) {
+	if ((new_status & STATUS_MASK_VB_SAG) ^
+			(old_status & STATUS_MASK_VB_SAG)) {
+		event_active = !!(new_status & STATUS_MASK_VB_SAG);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
-						    IIO_EV_TYPE_MAG,
-						    IIO_EV_DIR_FALLING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_FALLING,
+					IIO_EV_TYPE_MAG,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_VRMSA) {
+	if ((new_status & STATUS_MASK_OV_VRMSA) ^
+			(old_status & STATUS_MASK_OV_VRMSA)) {
+		event_active = !!(new_status & STATUS_MASK_OV_VRMSA);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_UN_VRMSA) {
+	if ((new_status & STATUS_MASK_UN_VRMSA) ^
+			(old_status & STATUS_MASK_UN_VRMSA)) {
+		event_active = !!(new_status & STATUS_MASK_UN_VRMSA);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_FALLING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_FALLING,
+					IIO_EV_TYPE_THRESH,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_VRMSB) {
+	if ((new_status & STATUS_MASK_OV_VRMSB) ^
+			(old_status & STATUS_MASK_OV_VRMSB)) {
+		event_active = !!(new_status & STATUS_MASK_OV_VRMSB);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_UN_VRMSB) {
+	if ((new_status & STATUS_MASK_UN_VRMSB) ^
+			(old_status & STATUS_MASK_UN_VRMSB)) {
+		event_active = !!(new_status & STATUS_MASK_UN_VRMSB);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_FALLING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_FALLING,
+					IIO_EV_TYPE_THRESH,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_VA_SURGE) {
+	if ((new_status & STATUS_MASK_VA_SURGE) ^
+			(old_status & STATUS_MASK_VA_SURGE)) {
+		event_active = !!(new_status & STATUS_MASK_VA_SURGE);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
-						    IIO_EV_TYPE_MAG,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_MAG,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_VB_SURGE) {
+	if ((new_status & STATUS_MASK_VB_SURGE) ^
+			(old_status & STATUS_MASK_VB_SURGE)) {
+		event_active = !!(new_status & STATUS_MASK_VB_SURGE);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
-						    IIO_EV_TYPE_MAG,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_VOLTAGE,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_MAG,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_WATT1) {
+	if ((new_status & STATUS_MASK_OV_WATT1) ^
+			(old_status & STATUS_MASK_OV_WATT1)) {
+		event_active = !!(new_status & STATUS_MASK_OV_WATT1);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_POWER, 0,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_POWER,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_WATT2) {
+	if ((new_status & STATUS_MASK_OV_WATT2) ^
+			(old_status & STATUS_MASK_OV_WATT2)) {
+		event_active = !!(new_status & STATUS_MASK_OV_WATT2);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_POWER, 1,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_POWER,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_AMP1) {
+	if ((new_status & STATUS_MASK_OV_AMP1) ^
+			(old_status & STATUS_MASK_OV_AMP1)) {
+		event_active = !!(new_status & STATUS_MASK_OV_AMP1);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_CURRENT, 0,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_CURRENT,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					0 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
-	if (status & STATUS_MASK_OV_AMP2) {
+	if ((new_status & STATUS_MASK_OV_AMP2) ^
+			(old_status & STATUS_MASK_OV_AMP2)) {
+		event_active = !!(new_status & STATUS_MASK_OV_AMP2);
 		iio_push_event(indio_dev,
-			       IIO_UNMOD_EVENT_CODE(IIO_CURRENT, 1,
-						    IIO_EV_TYPE_THRESH,
-						    IIO_EV_DIR_RISING),
-			       timestamp_ns);
+				IIO_EVENT_CODE(IIO_CURRENT,
+					0 /* diff */,
+					IIO_NO_MOD,
+					IIO_EV_DIR_RISING,
+					IIO_EV_TYPE_THRESH,
+					1 /* chan */,
+					0 /* chan1 */,
+					event_active /* chan2 */),
+				timestamp_ns);
 	}
 
+	/* Write reset register, clearing only bits that we've processed and
+	 * RESET bit if it was set at the time of the last read of STATUS */
 	ret = __max78m6610_lmu_spi_reg_write(st, STATUS_RESET,
-					     status & STATUS_MASK_STICKY);
+			new_status & STATUS_MASK_STICKY);
 	if (ret) {
 		pr_err("Failed to write STATUS_RESET register\n");
 		goto exit_unlock;
 	}
 
+	/* Save the current state of STATUS to be used next time as reference*/
+	old_status = new_status;
+	if (new_status & STATUS_MASK_STICKY) {
+		mod_timer(&st->max78m6610_timer, jiffies + TIMER_PERIOD);
+	} else {
+		del_timer(&st->max78m6610_timer);
+		/* Re-enable eADC interrupts by restoring the content
+		 * of MASK0 register */
+		ret = __max78m6610_lmu_mask0_set(st);
+		if (ret) {
+			pr_err("Failed to restore MASK0 register!\n");
+			goto exit_unlock;
+		}
+	}
+	mutex_unlock(&indio_dev->mlock);
+	return ret;
+
 exit_unlock:
+	/* if something failed setup the timer to fire again no matter what */
+	mod_timer(&st->max78m6610_timer, jiffies + TIMER_PERIOD);
 	mutex_unlock(&indio_dev->mlock);
 
 	return ret;
 }
 
-/**
- * max78m6610_lmu_write_status_scan
- *
- * @param dev: device descriptor associated with sysfs attribute node
- * @param attr: device sysfs attribute descriptor
- * @param buf: data written by user to the attribute node
- * @param len: length in bytes of data written by user
- *
- * This handles a write to this sysfs node from user-space, and invokes a
- * read of the status register on the MAX78M6610+LMU if an appropriate value
- * is written.  Valid input character values are 1, y and Y
- */
-static ssize_t max78m6610_lmu_write_status_scan(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t len)
-{
-	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
-	int ret = 0;
-
-	if (len < 1)
-		return -1;
-	switch (buf[0]) {
-	case '1':
-	case 'y':
-	case 'Y':
-		ret = max78m6610_lmu_status_scan(indio_dev);
-		return ret ? ret : len;
-	}
-	return -1;
-}
 
 /**
  * max78m6610_lmu_write_int
@@ -1736,16 +1830,20 @@ static const struct attribute_group max78m6610_lmu_attribute_group = {
 	.attrs = max78m6610_lmu_attributes,
 };
 
-/* Provides an option to poll for events (useful if interrupts unavailable) */
-static IIO_DEVICE_ATTR(do_status_scan, S_IWUSR, NULL,
-		       max78m6610_lmu_write_status_scan, 0);
+/* Provides an option to poll for events (useful if interrupts unavailable)
+ * The option to poll for events is no longer supported, but we need to have at
+ * least 1 event attribute to enable the IIO events.
+ * That's why this attribute is created with no _show and no _store handlers.
+ * */
+static IIO_DEVICE_ATTR(null, S_IWUSR, NULL, NULL, 0);
+
 
 /* Need to have at least 1 event attribute to enable IIO events.
  * Purposely not setting .event_mask for the channels because that would
  * enable the IIO events sysfs entries which are not suitable for this driver
  */
 static struct attribute *max78m6610_lmu_event_attributes[] = {
-	&iio_dev_attr_do_status_scan.dev_attr.attr,
+	&iio_dev_attr_null.dev_attr.attr,
 	NULL,
 };
 
@@ -2096,11 +2194,239 @@ max78m6610_lmu_chrdev_remove(struct max78m6610_lmu_state *st)
 	return 0;
 }
 
+
+/* Spinlock used to lock the external and timer interrupt handlers */
+static DEFINE_SPINLOCK(max78m6610_spinlock);
+
+/* Pointer used to pass iio_dev from top-half to bottom-half handler */
+static void *wq_indio_dev;
+
+/* Workqueue used for deffering the work in the bottom-half handler */
+static void max78m6610_lmu_irq_do_work(struct work_struct *max78m6610_lmu_wq);
+static DECLARE_WORK(max78m6610_lmu_wq, max78m6610_lmu_irq_do_work);
+
+
+/* max78m6610_lmu_irq_do_work
+ *
+ * @param max78m6610_lmu_wq: working item
+ *
+ * Worker function of the work queue which does the bottom-half processing of
+ * MAX78M6610 IRQ.
+ */
+static void max78m6610_lmu_irq_do_work(struct work_struct *max78m6610_lmu_wq)
+{
+	int ret = 0x00;
+
+	ret = max78m6610_lmu_status_scan((struct iio_dev *)wq_indio_dev);
+
+	if (ret)
+		pr_err("MAX78M6610 status scan failed; return code: %d\n", ret);
+}
+
+
+
+/* max78m6610_lmu_irq_handler
+ *
+ * @param irq: IRQ number
+ * @param private: The dev_id cookie passed to request_irq()
+ *
+ * @return:
+ *	IRQ_NONE	interrupt was not from this device
+ *	IRQ_HANDLED	interrupt was handled by this device
+ *	IRQ_WAKE_THREAD	handler requests to wake the handler thread
+ *
+ * Interrupt handler for eADC IRQ.
+ */
+static irqreturn_t max78m6610_lmu_irq_handler(int irq, void *private)
+{
+	spin_lock(&max78m6610_spinlock);
+
+	wq_indio_dev = private;
+	schedule_work(&max78m6610_lmu_wq);
+
+	spin_unlock(&max78m6610_spinlock);
+	return IRQ_HANDLED;
+}
+
+
+/* __max78m6610_lmu_mask0_reset
+ *
+ * @param indio_dev: iio_dev pointer
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Clears all bits of MASK0 register except RELAY2 bit.
+ *
+ * If MASK0 register is completely cleared (write 0x00 to it) while the MP0
+ * bit is already active, the MP0 bit is not de-activated.
+ * If MASK0 register's value != 0x00 and MASK0 & STATUS == 0, the MP0 bit is
+ * de-activated.
+ *
+ * (MP0 pin == 0) && (MASK0 & STATUS == 0) && (MASK0 != 0) => MP0 = 1
+ * (interrupt line is de-asserted)
+ */
+static inline int __max78m6610_lmu_mask0_reset(struct max78m6610_lmu_state *st)
+{
+	return __max78m6610_lmu_spi_reg_write(st, MASK0, STATUS_MASK_RELAY2);
+}
+
+
+/* __max78m6610_lmu_mask0_set
+ *
+ * @param st: eADC state structure
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Sets on eADC chip the MASK0 bits corresponding to the events we want to
+ * receive an interrupt for.
+ * If one wants to modify the events which the driver receives interrupt for, he
+ * must modify MASK0_INT macro
+ */
+static inline int __max78m6610_lmu_mask0_set(struct max78m6610_lmu_state *st)
+{
+	return __max78m6610_lmu_spi_reg_write(st, MASK0, MASK0_INT);
+}
+
+
+/* max78m6610_lmu_mask0_set_default
+ *
+ * @param indio_dev: IIO device
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Read MASK0 register, check if it's default value is already MASK0_INT,
+ * otherwise set MASK0 = MASK0_INT and save defaults into flash in order to
+ * change MASK0 default value.
+ */
+static int max78m6610_lmu_mask0_set_default(struct iio_dev *indio_dev)
+{
+	int ret = 0;
+	unsigned mask0 = 0x00;
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+
+	/* Read MASK0 value */
+	mutex_lock(&indio_dev->mlock);
+	ret = __max78m6610_lmu_spi_reg_read(st, MASK0, &mask0);
+	if (ret) {
+		pr_err("Failed to read MASK0 register! ret: %d\n", ret);
+		goto error_unlock;
+	}
+	mutex_unlock(&indio_dev->mlock);
+	if (mask0 != MASK0_INT) {
+		/* Tell eADC what events to generate interrupt for */
+		mutex_lock(&indio_dev->mlock);
+		ret = __max78m6610_lmu_mask0_set(st);
+		if (ret) {
+			pr_err("Failed to enable interrupts on eADC side!\n");
+			goto error_unlock;
+		}
+		mutex_unlock(&indio_dev->mlock);
+
+		/* Save MASK0 default to flash */
+		ret = max78m6610_lmu_flash_save_cmd(indio_dev);
+		if (ret) {
+			pr_err("Failed to save MASK0 default to flash!\n");
+			goto error_ret;
+		}
+	}
+	return 0;
+
+error_unlock:
+	mutex_unlock(&indio_dev->mlock);
+error_ret:
+	return ret;
+}
+
+
+/*
+ * max78m6610_lmu_irq_init
+ *
+ * @param indio_dev: IIO device
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Allocate memory for IIO triger, request the IRQ for eADC, set IIO triger
+ * parent and operations; register IIO trigger; set this trigger as default
+ * trigger; configure MASK0 default value.
+ */
+static int max78m6610_lmu_irq_init(struct iio_dev *indio_dev)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	if (st->spi->irq < 0) {
+		pr_warn("MAX78M6610+LMU IRQ not set. spi->irq: %d\n",
+				st->spi->irq);
+		return 0;
+	}
+
+	ret = request_irq(st->spi->irq, max78m6610_lmu_irq_handler,
+			IRQF_TRIGGER_FALLING, spi_get_device_id(st->spi)->name,
+			indio_dev);
+	if (ret) {
+		pr_err("Failed to request IRQ %d: request_irg returned %d.\n",
+				st->spi->irq, ret);
+		goto error_ret;
+	}
+
+	/* Check and set MASK0 default */
+	ret = max78m6610_lmu_mask0_set_default(indio_dev);
+	if (ret) {
+		pr_err("Failed to set MASK0 default!\n");
+		goto error_free_irq;
+	}
+
+	return 0;
+
+error_free_irq:
+	free_irq(st->spi->irq, indio_dev);
+error_ret:
+	return ret;
+}
+
+
+/* max78m6610_lmu_irq_remove
+ *
+ * @param indio_dev: IIO device
+ * @return N/A
+ *
+ * Unregister IIO trigger, release the IRQ and free IIO triger memory
+ */
+static void max78m6610_lmu_irq_remove(struct iio_dev *indio_dev)
+{
+	int ret;
+	u32 mask0 = 0x00;
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+
+	if (st->spi->irq < 0)
+		return;
+	/* Instruct MAX78M6610+LMU chip to stop generating interrupts on MP0 */
+	mutex_lock(&indio_dev->mlock);
+	ret = __max78m6610_lmu_spi_reg_write(st, MASK0, mask0);
+	if (ret)
+		pr_warn("Failed to write MASK0 register.\n");
+	mutex_unlock(&indio_dev->mlock);
+
+	free_irq(st->spi->irq, indio_dev);
+}
+
+/* max78m6610_lmu_timer_handler
+ *
+ * @param data: unused
+ * @reutnr N/A
+ *
+ * max78m6610_timer interrupt handler
+ */
+static void max78m6610_lmu_timer_handler(unsigned long data)
+{
+	spin_lock(&max78m6610_spinlock);
+	if (NULL != wq_indio_dev)
+		schedule_work(&max78m6610_lmu_wq);
+	spin_unlock(&max78m6610_spinlock);
+}
+
+
 /**
  * max78m6610_lmu_probe
  *
  * @param spi: spi device pointer
- * @return: return 0 or standard errorids if failure
+ * @return: return 0 or standard error ids if failure
  *
  * device driver probe funciton for iio_dev struct initialisation.
  */
@@ -2153,9 +2479,17 @@ static int max78m6610_lmu_probe(struct spi_device *spi)
 	ret = max78m6610_lmu_chrdev_init(st);
 	if (ret)
 		goto error_cleanup_ring;
+	/* Init the external GPIO interrupt */
+	ret = max78m6610_lmu_irq_init(indio_dev);
+	if (ret)
+		goto error_cleanup_chrdev;
+	/* Initialise the timer */
+	setup_timer(&st->max78m6610_timer, max78m6610_lmu_timer_handler, 0);
 
 	return 0;
 
+error_cleanup_chrdev:
+	max78m6610_lmu_chrdev_remove(st);
 error_cleanup_ring:
 	iio_triggered_buffer_cleanup(indio_dev);
 error_free:
@@ -2177,8 +2511,14 @@ static int max78m6610_lmu_remove(struct spi_device *spi)
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
 
+	del_timer(&st->max78m6610_timer);
+
+	max78m6610_lmu_irq_remove(indio_dev);
+
 	max78m6610_lmu_chrdev_remove(st);
+
 	iio_device_unregister(indio_dev);
+
 	iio_triggered_buffer_cleanup(indio_dev);
 	iio_device_free(indio_dev);
 
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
old mode 100644
new mode 100755
index 1a1cf2e..8b445a7a
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -750,6 +750,16 @@ config CY8C9540A
 	  Select this option to enable support for the CY8C9540 I/O expander.
 	  This device provides 40 interrupt-capable GPIOs, 8 PWMs and an EEPROM.
 
+config MFD_PCA9685
+	tristate "NPX Semiconductors PCA9685 (PWM/GPIO) driver"
+	depends on GPIOLIB && I2C && PWM
+	select REGMAP_I2C
+	help
+	  NPX PCA9685 I2C-bus PWM controller with GPIO output interface support.
+	  The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+	  Additionally, the driver allows the channels to be configured as GPIO
+	  interface (output only).
+
 config INTEL_QRK_GIP
 	tristate "Intel Quark GIP"
 	depends on PCI && X86 && INTEL_QUARK_X1000_SOC
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
old mode 100644
new mode 100755
index e2b0971..e019dc7
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -99,6 +99,8 @@ obj-$(CONFIG_MFD_DB5500_PRCMU)	+= db5500-prcmu.o
 obj-$(CONFIG_MFD_TIMBERDALE)    += timberdale.o
 obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
 obj-$(CONFIG_CY8C9540A)		+= cy8c9540a.o
+pca9685-objs			:= pca9685-core.o pca9685-gpio.o pca9685-pwm.o
+obj-$(CONFIG_MFD_PCA9685)	+= pca9685.o
 obj-$(CONFIG_INTEL_QRK_GIP)	+= intel_qrk_gip.o
 intel_qrk_gip-objs		:= intel_qrk_gip_core.o \
 					intel_qrk_gip_gpio.o \
diff --git a/drivers/mfd/pca9685-core.c b/drivers/mfd/pca9685-core.c
new file mode 100644
index 0000000..11cb8d9
--- /dev/null
+++ b/drivers/mfd/pca9685-core.c
@@ -0,0 +1,283 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include "pca9685.h"
+
+static unsigned int en_invrt;
+module_param(en_invrt, uint, 0);
+MODULE_PARM_DESC(en_invrt, "Enable output logic state inverted mode");
+
+static unsigned int en_open_dr;
+module_param(en_open_dr, uint, 0);
+MODULE_PARM_DESC(en_open_dr,
+	"The outputs are configured with an open-drain structure");
+
+static int gpio_base = -1; /*  requests dynamic ID allocation */
+module_param(gpio_base, int, 0);
+MODULE_PARM_DESC(gpio_base, "GPIO base number");
+
+static unsigned int pwm_period = PWM_PERIOD_DEF; /* PWM clock period */
+module_param(pwm_period, uint, 0);
+MODULE_PARM_DESC(pwm_period, "PWM clock period (nanoseconds)");
+
+static bool pca9685_register_volatile(struct device *dev, unsigned int reg)
+{
+	if (unlikely(reg == PCA9685_MODE1))
+		return true;
+	else
+		return false;
+}
+
+static struct regmap_config pca9685_regmap_i2c_config = {
+	.reg_bits     = 8,
+	.val_bits     = 8,
+	.max_register = PCA9685_NUMREGS,
+	.volatile_reg = pca9685_register_volatile,
+	.cache_type   = REGCACHE_RBTREE,
+};
+
+ssize_t pca9685_pwm_period_sysfs_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct pca9685 *pca = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", pca->pwm_period);
+}
+
+ssize_t pca9685_pwm_period_sysfs_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct pca9685 *pca = dev_get_drvdata(dev);
+	unsigned period_ns;
+	int ret;
+
+	sscanf(buf, "%u", &period_ns);
+
+	ret = pca9685_update_prescale(pca, period_ns, true);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+/* Sysfs attribute to allow PWM clock period adjustment at run-time
+ * NOTE: All active channels will switch off momentarily if the
+ * PWM clock period is changed
+ */
+static DEVICE_ATTR(pwm_period, S_IWUSR | S_IRUGO,
+		   pca9685_pwm_period_sysfs_show,
+		   pca9685_pwm_period_sysfs_store);
+
+static int pca9685_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct pca9685_pdata *pdata;
+	struct pca9685 *pca;
+	int ret;
+	int mode2;
+
+	pca = devm_kzalloc(&client->dev, sizeof(*pca), GFP_KERNEL);
+	if (unlikely(!pca))
+		return -ENOMEM;
+
+	pdata = client->dev.platform_data;
+	if (likely(pdata)) {
+		memcpy(pca->chan_mapping, pdata->chan_mapping,
+				ARRAY_SIZE(pca->chan_mapping));
+		pca->gpio_base = pdata->gpio_base;
+		en_invrt       = pdata->en_invrt;
+		en_open_dr     = pdata->en_open_dr;
+	} else {
+		dev_warn(&client->dev,
+			 "Platform data not provided."
+			 "Using default or mod params configuration.\n");
+		pca->gpio_base = gpio_base;
+		memset(pca->chan_mapping, PWM_CH_UNDEFINED,
+				ARRAY_SIZE(pca->chan_mapping));
+	}
+
+	if (unlikely(!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C |
+					I2C_FUNC_SMBUS_BYTE_DATA))) {
+		dev_err(&client->dev,
+				"i2c adapter doesn't support required functionality\n");
+		return -EIO;
+	}
+
+	pca->regmap = devm_regmap_init_i2c(client, &pca9685_regmap_i2c_config);
+	if (IS_ERR(pca->regmap)) {
+		ret = PTR_ERR(pca->regmap);
+		dev_err(&client->dev, "Failed to initialize register map: %d\n",
+			ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, pca);
+
+	/* registration of GPIO chip */
+	pca->gpio_chip.label     = "pca9685-gpio";
+	pca->gpio_chip.owner     = THIS_MODULE;
+	pca->gpio_chip.set       = pca9685_gpio_set;
+	pca->gpio_chip.get       = pca9685_gpio_get;
+	pca->gpio_chip.can_sleep = 1;
+	pca->gpio_chip.ngpio     = PCA9685_MAXCHAN;
+	pca->gpio_chip.base      = pca->gpio_base;
+	pca->gpio_chip.request   = pca9685_gpio_request;
+	pca->gpio_chip.free      = pca9685_gpio_free;
+
+	mutex_init(&pca->lock);
+
+	ret = gpiochip_add(&pca->gpio_chip);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "Could not register gpiochip, %d\n", ret);
+		goto err;
+	}
+
+	/* configure initial PWM settings */
+	ret = pca9685_init_pwm_regs(pca, pwm_period);
+	if (ret) {
+		pr_err("Failed to initialize PWM registers\n");
+		goto err_gpiochip;
+	}
+
+	/* registration of PWM chip */
+
+	regmap_read(pca->regmap, PCA9685_MODE2, &mode2);
+
+	/* update mode2 register */
+	if (en_invrt)
+		mode2 |= MODE2_INVRT;
+	else
+		mode2 &= ~MODE2_INVRT;
+
+	if (en_open_dr)
+		mode2 &= ~MODE2_OUTDRV;
+	else
+		mode2 |= MODE2_OUTDRV;
+
+	regmap_write(pca->regmap, PCA9685_MODE2, mode2);
+
+	pca->pwm_chip.ops  = &pca9685_pwm_ops;
+	/* add an extra channel for ALL_LED */
+	pca->pwm_chip.npwm = PCA9685_MAXCHAN + 1;
+	pca->pwm_chip.dev  = &client->dev;
+	pca->pwm_chip.base = -1;
+
+	ret = pwmchip_add(&pca->pwm_chip);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "pwmchip_add failed %d\n", ret);
+		goto err_gpiochip;
+	}
+
+	/* Also create a sysfs interface, providing a cmd line config option */
+	ret = sysfs_create_file(&client->dev.kobj, &dev_attr_pwm_period.attr);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "sysfs_create_file failed %d\n", ret);
+		goto err_pwmchip;
+	}
+
+	return ret;
+
+err_pwmchip:
+	if (unlikely(pwmchip_remove(&pca->pwm_chip)))
+		dev_warn(&client->dev, "%s failed\n", "pwmchip_remove()");
+
+err_gpiochip:
+	if (unlikely(gpiochip_remove(&pca->gpio_chip)))
+		dev_warn(&client->dev, "%s failed\n", "gpiochip_remove()");
+err:
+	mutex_destroy(&pca->lock);
+
+	return ret;
+}
+
+static int pca9685_remove(struct i2c_client *client)
+{
+	struct pca9685 *pca = i2c_get_clientdata(client);
+	int ret;
+
+	regmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,
+			MODE1_SLEEP);
+
+	ret = gpiochip_remove(&pca->gpio_chip);
+	if (unlikely(ret))
+		dev_err(&client->dev, "%s failed, %d\n",
+				"gpiochip_remove()", ret);
+
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_pwm_period.attr);
+
+	ret = pwmchip_remove(&pca->pwm_chip);
+	if (unlikely(ret))
+		dev_err(&client->dev, "%s failed, %d\n",
+				"pwmchip_remove()", ret);
+
+	mutex_destroy(&pca->lock);
+
+	return ret;
+}
+
+static const struct i2c_device_id pca9685_id[] = {
+	{ "pca9685", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, pca9685_id);
+
+static struct i2c_driver pca9685_i2c_driver = {
+	.driver = {
+		.name  = "mfd-pca9685",
+		.owner = THIS_MODULE,
+	},
+	.probe     = pca9685_probe,
+	.remove    = pca9685_remove,
+	.id_table  = pca9685_id,
+};
+
+static int __init pca9685_init(void)
+{
+	if (unlikely((pwm_period < PWM_PERIOD_MIN) ||
+		     (PWM_PERIOD_MAX < pwm_period))) {
+		pr_err("Invalid PWM period specified (valid range: %d-%d)\n",
+		       PWM_PERIOD_MIN, PWM_PERIOD_MAX);
+		return -EINVAL;
+	}
+
+	return i2c_add_driver(&pca9685_i2c_driver);
+}
+/* register after i2c postcore initcall */
+subsys_initcall(pca9685_init);
+
+static void __exit pca9685_exit(void)
+{
+	i2c_del_driver(&pca9685_i2c_driver);
+}
+module_exit(pca9685_exit);
+
+MODULE_AUTHOR("Wojciech Ziemba <wojciech.ziemba@emutex.com>");
+MODULE_DESCRIPTION("NPX Semiconductors PCA9685 (PWM/GPIO) driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685-gpio.c b/drivers/mfd/pca9685-gpio.c
new file mode 100644
index 0000000..7cfff86
--- /dev/null
+++ b/drivers/mfd/pca9685-gpio.c
@@ -0,0 +1,108 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/pwm.h>
+#include <linux/regmap.h>
+
+#include "pca9685.h"
+
+static inline struct pca9685 *gpio_to_pca(struct gpio_chip *gpio_chip)
+{
+	return container_of(gpio_chip, struct pca9685, gpio_chip);
+}
+
+static inline int is_gpio_allowed(const struct pca9685 *pca, unsigned channel)
+{
+	return pca->chan_mapping[channel] & PWM_CH_GPIO;
+}
+
+int pca9685_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+	struct pwm_device *pwm;
+	int ret = 0;
+	pca = gpio_to_pca(chip);
+
+	/* validate channel constrains */
+	if (!is_gpio_allowed(pca, offset))
+		return -ENODEV;
+
+	/* return busy if channel is already allocated for pwm */
+	pwm = &pca->pwm_chip.pwms[offset];
+	if (test_bit(PWMF_REQUESTED, &pwm->flags))
+		return -EBUSY;
+
+	/* clear the on counter */
+	regmap_write(pca->regmap, LED_N_ON_L(offset), 0x0);
+	regmap_write(pca->regmap, LED_N_ON_H(offset), 0x0);
+
+	/* clear the off counter */
+	regmap_write(pca->regmap, LED_N_OFF_L(offset), 0x0);
+	ret = regmap_write(pca->regmap, LED_N_OFF_H(offset), 0x0);
+
+	clear_sleep_bit(pca);
+
+	return ret;
+}
+
+void pca9685_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+
+	pca = gpio_to_pca(chip);
+
+	/* clear the on counter reg */
+	regmap_write(pca->regmap, LED_N_ON_L(offset), 0x0);
+	regmap_write(pca->regmap, LED_N_ON_H(offset), 0x0);
+
+	set_sleep_bit(pca);
+
+	return;
+}
+
+void pca9685_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct pca9685 *pca;
+
+	pca = gpio_to_pca(chip);
+
+	/* set the full-on bit */
+	regmap_write(pca->regmap,  LED_N_ON_H(offset), (value << 4) & LED_FULL);
+
+	return;
+}
+
+int pca9685_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+	unsigned int val;
+
+	pca = gpio_to_pca(chip);
+
+	/* read the full-on bit */
+	regmap_read(pca->regmap, LED_N_ON_H(offset), &val);
+
+	return !!val;
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685-pwm.c b/drivers/mfd/pca9685-pwm.c
new file mode 100644
index 0000000..13f82b8
--- /dev/null
+++ b/drivers/mfd/pca9685-pwm.c
@@ -0,0 +1,262 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include "pca9685.h"
+
+static inline struct pca9685 *pwm_to_pca(struct pwm_chip *pwm_chip)
+{
+	return container_of(pwm_chip, struct pca9685, pwm_chip);
+}
+
+static inline int period_ns_to_prescale(unsigned period_ns)
+{
+	return (DIV_ROUND_CLOSEST(OSC_CLK_MHZ * period_ns,
+			SAMPLE_RES * 1000)) - 1;
+}
+
+static inline int is_pwm_allowed(const struct pca9685 *pca, unsigned channel)
+{
+	return pca->chan_mapping[channel] & PWM_CH_PWM;
+}
+
+int pca9685_update_prescale(struct pca9685 *pca, unsigned period_ns,
+			    bool reconfigure_channels)
+{
+	int pre_scale, i;
+	struct pwm_device *pwm;
+	unsigned long long duty_scale;
+	unsigned long long new_duty_ns;
+
+	if (unlikely((period_ns < PWM_PERIOD_MIN) ||
+		     (PWM_PERIOD_MAX < period_ns))) {
+		pr_err("Invalid PWM period specified (valid range: %d-%d)\n",
+		       PWM_PERIOD_MIN, PWM_PERIOD_MAX);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pca->lock);
+
+	/* update pre_scale to the closest period */
+	pre_scale = period_ns_to_prescale(period_ns);
+	/* ensure sleep-mode bit is set
+	 * NOTE: All active channels will switch off for at least 500 usecs
+	 */
+	regmap_update_bits(pca->regmap, PCA9685_MODE1,
+			   MODE1_SLEEP, MODE1_SLEEP);
+	regmap_write(pca->regmap, PCA9685_PRESCALE, pre_scale);
+	/* clear sleep mode flag if at least 1 channel is active */
+	if (pca->active_cnt > 0) {
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				   MODE1_SLEEP, 0x0);
+		usleep_range(MODE1_RESTART_DELAY, MODE1_RESTART_DELAY * 2);
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				   MODE1_RESTART, MODE1_RESTART);
+	}
+
+	if (reconfigure_channels) {
+		for (i = 0; i < pca->pwm_chip.npwm; i++) {
+			pwm = &pca->pwm_chip.pwms[i];
+			pwm->period = period_ns;
+			if (pwm->duty_cycle > 0) {
+				/* Scale the rise time to maintain duty cycle */
+				duty_scale = period_ns;
+				duty_scale *= 1000000;
+				do_div(duty_scale, pca->pwm_period);
+				new_duty_ns = duty_scale * pwm->duty_cycle;
+				do_div(new_duty_ns, 1000000);
+				/* Update the duty_cycle */
+				pwm_config(pwm, (int)new_duty_ns, pwm->period);
+			}
+		}
+	}
+	pca->pwm_period = period_ns;
+
+	mutex_unlock(&pca->lock);
+	return 0;
+}
+
+int pca9685_init_pwm_regs(struct pca9685 *pca, unsigned period_ns)
+{
+	int ret, chan;
+
+	/* set MODE1_SLEEP */
+	ret = regmap_update_bits(pca->regmap, PCA9685_MODE1,
+					MODE1_SLEEP, MODE1_SLEEP);
+	if (unlikely(ret < 0))
+		return ret;
+
+	/* configure the initial PWM clock period */
+	ret = pca9685_update_prescale(pca, period_ns, false);
+	if (unlikely(ret < 0))
+		return ret;
+
+	/* reset PWM channel registers to power-on default values */
+	for (chan = 0; chan < PCA9685_MAXCHAN; chan++) {
+		ret = regmap_write(pca->regmap, LED_N_ON_L(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_ON_H(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_OFF_L(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_OFF_H(chan), LED_FULL);
+		if (unlikely(ret < 0))
+			return ret;
+	}
+	/* reset ALL_LED registers to power-on default values */
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_ON_L, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_ON_H, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_OFF_L, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_OFF_H, LED_FULL);
+	if (unlikely(ret < 0))
+		return ret;
+
+	return ret;
+}
+
+static int pca9685_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+				int duty_ns, int period_ns)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+	unsigned long long duty;
+	unsigned int	reg_on_h,
+			reg_off_l,
+			reg_off_h;
+	int full_off;
+
+	/* Changing PWM period for a single channel at run-time not allowed.
+	 * The PCA9685 PWM clock is shared across all PWM channels
+	 */
+	if (unlikely(period_ns != pwm->period))
+		return -EPERM;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN)) {
+		reg_on_h  = PCA9685_ALL_LED_ON_H;
+		reg_off_l = PCA9685_ALL_LED_OFF_L;
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	} else {
+		reg_on_h  = LED_N_ON_H(pwm->hwpwm);
+		reg_off_l = LED_N_OFF_L(pwm->hwpwm);
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+	}
+
+	duty = SAMPLE_RES * (unsigned long long)duty_ns;
+	duty = DIV_ROUND_UP_ULL(duty, period_ns);
+
+	if (duty >= SAMPLE_RES) /* set the LED_FULL bit */
+		return regmap_write(pca->regmap, reg_on_h, LED_FULL);
+	else /* clear the LED_FULL bit */
+		regmap_write(pca->regmap, reg_on_h, 0x00);
+
+	full_off = !test_bit(PWMF_ENABLED, &pwm->flags) << 4;
+
+	regmap_write(pca->regmap, reg_off_l, (int)duty & 0xff);
+
+	return regmap_write(pca->regmap, reg_off_h,
+			((int)duty >> 8 | full_off) & 0x1f);
+}
+
+static int pca9685_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+	int ret;
+
+	unsigned int reg_off_h;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN))
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	else
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+
+	/* clear the full-off bit */
+	ret = regmap_update_bits(pca->regmap, reg_off_h, LED_FULL, 0x0);
+
+	clear_sleep_bit(pca);
+
+	return ret;
+}
+
+static void pca9685_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+
+	unsigned int reg_off_h;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN))
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	else
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+
+	/* set the LED_OFF counter. */
+	regmap_update_bits(pca->regmap, reg_off_h, LED_FULL, LED_FULL);
+
+	set_sleep_bit(pca);
+
+	return;
+}
+
+static int pca9685_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca;
+	struct gpio_chip *gpio_chip;
+	unsigned channel = pwm->hwpwm;
+
+	pca = pwm_to_pca(chip);
+
+	/* validate channel constrains */
+	if (!is_pwm_allowed(pca, channel))
+		return -ENODEV;
+
+	/* return busy if channel is already allocated for gpio */
+	gpio_chip = &pca->gpio_chip;
+
+	if ((channel < PCA9685_MAXCHAN) &&
+		(gpiochip_is_requested(gpio_chip, channel)))
+			return -EBUSY;
+
+	pwm->period = pca->pwm_period;
+
+	return 0;
+}
+
+const struct pwm_ops pca9685_pwm_ops = {
+	.enable  = pca9685_pwm_enable,
+	.disable = pca9685_pwm_disable,
+	.config  = pca9685_pwm_config,
+	.request = pca9685_pwm_request,
+	.owner   = THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685.h b/drivers/mfd/pca9685.h
new file mode 100644
index 0000000..3627097
--- /dev/null
+++ b/drivers/mfd/pca9685.h
@@ -0,0 +1,110 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#ifndef __LINUX_MFD_PCA9685_H
+#define __LINUX_MFD_PCA9685_H
+
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/pwm.h>
+#include <linux/platform_data/pca9685.h>
+
+#define PCA9685_MODE1		0x00
+#define PCA9685_MODE2		0x01
+#define PCA9685_SUBADDR1	0x02
+#define PCA9685_SUBADDR2	0x03
+#define PCA9685_SUBADDR3	0x04
+#define PCA9685_LEDX_ON_L	0x06
+#define PCA9685_LEDX_ON_H	0x07
+#define PCA9685_LEDX_OFF_L	0x08
+#define PCA9685_LEDX_OFF_H	0x09
+
+#define PCA9685_ALL_LED_ON_L	0xFA
+#define PCA9685_ALL_LED_ON_H	0xFB
+#define PCA9685_ALL_LED_OFF_L	0xFC
+#define PCA9685_ALL_LED_OFF_H	0xFD
+#define PCA9685_PRESCALE	0xFE
+
+#define PCA9685_NUMREGS		0xFF
+
+#define LED_FULL		(1 << 4)
+#define MODE1_SLEEP		(1 << 4)
+#define MODE1_RESTART		(1 << 7)
+
+#define MODE1_RESTART_DELAY	500
+
+#define LED_N_ON_H(N)	(PCA9685_LEDX_ON_H +  (4 * (N)))
+#define LED_N_ON_L(N)	(PCA9685_LEDX_ON_L +  (4 * (N)))
+#define LED_N_OFF_H(N)	(PCA9685_LEDX_OFF_H + (4 * (N)))
+#define LED_N_OFF_L(N)	(PCA9685_LEDX_OFF_L + (4 * (N)))
+
+#define OSC_CLK_MHZ		      25 /* 25 MHz */
+#define SAMPLE_RES		    4096 /* 12 bits */
+#define PWM_PERIOD_MIN		  666666 /* ~1525 Hz */
+#define PWM_PERIOD_MAX		41666666 /* 24 Hz */
+#define PWM_PERIOD_DEF		 5000000 /* default 200 Hz */
+
+struct pca9685 {
+	struct gpio_chip	gpio_chip;
+	struct pwm_chip		pwm_chip;
+	struct regmap		*regmap;
+	struct mutex		lock; /* mutual exclusion semaphore */
+	/* Array of channel allocation constrains */
+	/* add an extra channel for ALL_LED */
+	u8	chan_mapping[PCA9685_MAXCHAN + 1];
+	int	gpio_base;
+	int	active_cnt;
+	int	pwm_exported_cnt;
+	int	pwm_period;
+};
+
+extern const struct pwm_ops pca9685_pwm_ops;
+
+int  pca9685_gpio_request(struct gpio_chip *chip, unsigned offset);
+void pca9685_gpio_free(struct gpio_chip *chip, unsigned offset);
+void pca9685_gpio_set(struct gpio_chip *chip, unsigned offset, int value);
+int  pca9685_gpio_get(struct gpio_chip *chip, unsigned offset);
+
+int pca9685_init_pwm_regs(struct pca9685 *pca, unsigned period_ns);
+int pca9685_update_prescale(struct pca9685 *pca, unsigned period_ns,
+			    bool reconfigure_channels);
+
+static inline void set_sleep_bit(struct pca9685 *pca)
+{
+	mutex_lock(&pca->lock);
+	/* set sleep mode flag if no more active LED channel*/
+	if (--pca->active_cnt == 0)
+		regmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,
+				MODE1_SLEEP);
+	mutex_unlock(&pca->lock);
+}
+
+static inline void clear_sleep_bit(struct pca9685 *pca)
+{
+	mutex_lock(&pca->lock);
+	/* clear sleep mode flag if at least 1 LED channel is active */
+	if (pca->active_cnt++ == 0)
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				MODE1_SLEEP, 0x0);
+
+	mutex_unlock(&pca->lock);
+}
+
+#endif	/* __LINUX_MFD_PCA9685_H */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
old mode 100644
new mode 100755
index 47ef2b1..9083430
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -43,7 +43,9 @@ module_param(enable_msi, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
 
 static int bus_id = 1;
+#if 0
 static char stmmac_mac_data[MAX_INTERFACES][ETH_ALEN];
+#endif
 
 struct stmmac_qrk_mac_data {
 	int phy_addr;
@@ -112,6 +114,16 @@ static struct stmmac_qrk_mac_data phy_data [] = {
 		.bus_id		= 2,
 		.name		= "Galileo",
 	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "GalileoGen2",
+	},
+	{
+		.phy_addr	= -1,			/* not connected */
+		.bus_id		= 2,
+		.name		= "GalileoGen2",
+	},
 };
 
 
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index 0a03469..8c917a5 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -4,6 +4,7 @@ obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_clanton_peak.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_cross_hill.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_kips_bay.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_galileo.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_galileo_gen2.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_sb.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_kernel.o
diff --git a/drivers/platform/x86/quark/intel_qrk_board_data.c b/drivers/platform/x86/quark/intel_qrk_board_data.c
index 2a0cc3b..8dc62e0 100644
--- a/drivers/platform/x86/quark/intel_qrk_board_data.c
+++ b/drivers/platform/x86/quark/intel_qrk_board_data.c
@@ -127,7 +127,10 @@ static struct platform_device bsp_data [] = {
 		.name	= "Galileo",
 		.id	= -1,
 	},
-
+	{
+		.name   = "GalileoGen2",
+		.id     = -1,
+	},
 };
 
 /**
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
old mode 100644
new mode 100755
index 98fa208..789795e
--- a/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
+++ b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
@@ -45,10 +45,27 @@
 #define SPI_BPEAK_ID2_GPIO   15
 #define SPI_BPEAK_ID3_GPIO   14
 
+/*
+ * GPIO number for eADC interrupt (MAX78M6610+LMU)
+ */
+#define GPIO_78M6610_INT	2
+
 static int nc_gpio_reg;
 static int sc_gpio_reg;
 
 static int cross_hill_probe;
+/*
+ * GPIOs used as interrupts by MAX78M6610+LMU eADC
+ * 
+ * Extend this array adding new elements at the end.
+ */
+static struct gpio crh_eadc_int_gpios[] = {
+	{
+		GPIO_78M6610_INT,
+		GPIOF_IN,
+		"max78m6610-int"
+	},
+};
 
 /*
  * Blackburn Peak SPI daughterboard ID values
@@ -157,6 +174,7 @@ static struct spi_board_info spi_generic_devs[] = {
 
 };
 
+/* For compatibility reason, new SPI energy modules must be added at the end */
 static struct spi_board_info spi_energy_adc_devs[] = {
 	{
 		.modalias = "max78m6610_lmu",
@@ -166,6 +184,7 @@ static struct spi_board_info spi_energy_adc_devs[] = {
 		.bus_num = 1,
 		.chip_select = 0,
 		.controller_data = &qrk_ffrd_spi_1_cs_0,
+		.irq = -1,
 	},
 };
 
@@ -332,8 +351,33 @@ static int intel_qrk_spi_add_bpeak_devs(void)
 
 	case QRK_SPI_BPEAK_ID_ADC_MAXIM:
 		{
-			return spi_register_board_info(spi_energy_adc_devs,
+			ret = gpio_request_array(crh_eadc_int_gpios,
+					ARRAY_SIZE(crh_eadc_int_gpios));
+			if (ret) {
+				pr_err("%s: Failed to allocate eADC interrupt GPIO pins!\n",
+						__func__);
+				return ret;
+			}
+			ret = gpio_to_irq(GPIO_78M6610_INT);
+			if (ret < 0) {
+				pr_err("%s: Failed to request IRQ for GPIO %u!\n",
+						__func__, GPIO_78M6610_INT);
+				goto error_gpio_free;
+			}
+			spi_energy_adc_devs[0].irq = ret;
+			ret = spi_register_board_info(spi_energy_adc_devs,
 					ARRAY_SIZE(spi_energy_adc_devs));
+			if (ret) {
+				pr_err("%s: Failed to register eADC module!\n",
+						__func__);
+				goto error_gpio_free;
+			}
+			return 0;
+error_gpio_free:
+			gpio_free_array(crh_eadc_int_gpios,
+					ARRAY_SIZE(crh_eadc_int_gpios));
+			spi_energy_adc_devs[0].irq = -1;
+			return ret;
 		}
 	case QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
 		{
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_galileo_gen2.c b/drivers/platform/x86/quark/intel_qrk_plat_galileo_gen2.c
new file mode 100644
index 0000000..7c09add
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_galileo_gen2.c
@@ -0,0 +1,392 @@
+/*
+ * Intel Quark Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c/pca953x.h>
+
+#define DRIVER_NAME		"GalileoGen2"
+#define GPIO_RESTRICT_NAME	"qrk-gpio-restrict-sc"
+#define LPC_SCH_SPINAME		"spi-lpc-sch"
+
+#define GPIO_PCAL9555A_EXP2_INT		9
+
+/* Option to allow GPIO 10 to be used for SPI1 chip-select */
+static int gpio_cs;
+
+module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
+
+/* Galileo Gen2 boards require i2c master to operate @400kHz 'fast mode' */
+static struct intel_qrk_gip_pdata gip_pdata = {
+	.i2c_std_mode = 0,
+};
+static struct intel_qrk_gip_pdata *galileo_gen2_gip_get_pdata(void)
+{
+	return &gip_pdata;
+}
+
+/******************************************************************************
+ *             Texas Instruments ADC1x8S102 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/adc1x8s102.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define ADC1x8S102_MAX_EXT_VIN 5000
+
+static const struct adc1x8s102_platform_data adc1x8s102_platform_data = {
+	.ext_vin = ADC1x8S102_MAX_EXT_VIN
+};
+
+#include "linux/i2c/pca953x.h"
+#define PCAL9555A_GPIO_BASE_OFFSET 16
+
+static struct pca953x_platform_data pcal9555a_platform_data_exp0 = {
+	.gpio_base = PCAL9555A_GPIO_BASE_OFFSET,
+	.irq_base = -1,
+};
+
+static struct pca953x_platform_data pcal9555a_platform_data_exp1 = {
+	.gpio_base = PCAL9555A_GPIO_BASE_OFFSET + 16,
+	.irq_base = -1,
+};
+
+static struct pca953x_platform_data pcal9555a_platform_data_exp2 = {
+	.gpio_base = PCAL9555A_GPIO_BASE_OFFSET + 32,
+};
+
+#include "linux/platform_data/pca9685.h"
+
+static struct pca9685_pdata pca9685_platform_data = {
+	.chan_mapping = {
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_PWM,
+		PWM_CH_GPIO, PWM_CH_GPIO,
+		PWM_CH_GPIO, PWM_CH_GPIO,
+		PWM_CH_DISABLED /* ALL_LED disabled */
+	},
+	.gpio_base = PCAL9555A_GPIO_BASE_OFFSET + 48,
+};
+
+/******************************************************************************
+ *                        Intel Galileo Gen2 i2c clients
+ ******************************************************************************/
+#define EEPROM_ADDR				0x54
+#define PCAL9555A_EXP0_ADDR			0x25
+#define PCAL9555A_EXP1_ADDR			0x26
+#define PCAL9555A_EXP2_ADDR			0x27
+#define PCA9685_ADDR				0x47
+
+static struct i2c_board_info probed_i2c_eeprom;
+static struct i2c_board_info probed_i2c_pcal9555a_exp0 = {
+	.platform_data = &pcal9555a_platform_data_exp0,
+};
+static struct i2c_board_info probed_i2c_pcal9555a_exp1 = {
+	.platform_data = &pcal9555a_platform_data_exp1,
+};
+static struct i2c_board_info probed_i2c_pcal9555a_exp2 = {
+	.platform_data = &pcal9555a_platform_data_exp2,
+};
+static struct i2c_board_info probed_i2c_pca9685 = {
+	.platform_data = &pca9685_platform_data,
+};
+
+static const unsigned short eeprom_i2c_addr[] = {
+	EEPROM_ADDR, I2C_CLIENT_END
+};
+static const unsigned short pcal9555a_exp0_i2c_addr[] = {
+	PCAL9555A_EXP0_ADDR, I2C_CLIENT_END
+};
+static const unsigned short pcal9555a_exp1_i2c_addr[] = {
+	PCAL9555A_EXP1_ADDR, I2C_CLIENT_END
+};
+static const unsigned short pcal9555a_exp2_i2c_addr[] = {
+	PCAL9555A_EXP2_ADDR, I2C_CLIENT_END
+};
+static const unsigned short pca9685_i2c_addr[] = {
+	PCA9685_ADDR, I2C_CLIENT_END
+};
+
+static int i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	/* Always return success: the I2C clients are already known.  */
+	return 1;
+}
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+#define LPC_SCH_SPI_BUS_ID 0x03
+
+/* TODO: extract this data from layout.conf encoded in flash */
+struct mtd_partition galileo_gen2_ilb_partitions[] = {
+	{
+		.name		= "grub",
+		.size		= 4096,
+		.offset		= 0,
+	},
+	{
+		.name		= "grub.conf",
+		.size		= 0xA00,
+		.offset		= 0x50500,
+	},
+	{
+		.name		= "layout.conf",
+		.size		= 4096,
+		.offset		= 0x708000,
+	},
+	{
+		.name		= "sketch",
+		.size		= 0x40000,
+		.offset		= 0x750000,
+	},
+	{
+		.name		= "raw",
+		.size		= 8192000,
+		.offset		= 0,
+
+	},
+};
+
+static struct flash_platform_data ilb_flash = {
+	.type = "s25fl064k",
+	.parts = galileo_gen2_ilb_partitions,
+	.nr_parts = ARRAY_SIZE(galileo_gen2_ilb_partitions),
+};
+
+static struct spi_board_info spi0_onboard_devs[] = {
+	{
+		.modalias = "m25p80",
+		.platform_data = &ilb_flash,
+		.bus_num = LPC_SCH_SPI_BUS_ID,
+		.chip_select = 0,
+	},
+	{
+		.modalias = "adc1x8s102",
+		.max_speed_hz = 16667000,
+		.platform_data = &adc1x8s102_platform_data,
+		.mode = SPI_MODE_3,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	},
+};
+
+static struct spi_board_info spi1_onboard_devs_gpiocs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+};
+
+static struct spi_board_info spi1_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Izmir platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	int ret = 0;
+
+	ret = spi_register_board_info(spi0_onboard_devs,
+				      ARRAY_SIZE(spi0_onboard_devs));
+	if (ret)
+		return ret;
+
+	if (gpio_cs)
+		return spi_register_board_info(spi1_onboard_devs_gpiocs,
+					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
+	else
+		return spi_register_board_info(spi1_onboard_devs,
+					ARRAY_SIZE(spi1_onboard_devs));
+}
+
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_PCAL9555A_EXP2_INT,
+		GPIOF_IN,
+		"pcal9555a-exp2-int",
+	},
+};
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ *
+ * Registers devices which are dependent on this GPIO driver
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct i2c_adapter *i2c_adap = NULL;
+	struct i2c_client *client = NULL;
+
+	/* Need to tell the PCA953X driver which GPIO IRQ to use for signalling
+	 * interrupts.  We can't get the IRQ until the GPIO driver is loaded.
+	 * Hence, we defer registration of the I2C devices until now
+	 */
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		return -EPROBE_DEFER;
+	}
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		dev_err(&client->dev, "failed to request reserved gpios\n");
+		goto end;
+	}
+
+	strlcpy(probed_i2c_eeprom.type, "24c08", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_eeprom,
+				       eeprom_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe 24c08 I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+	strlcpy(probed_i2c_pcal9555a_exp0.type, "pcal9555a", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_pcal9555a_exp0,
+				       pcal9555a_exp0_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe pcal9555a I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+	strlcpy(probed_i2c_pcal9555a_exp1.type, "pcal9555a", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_pcal9555a_exp1,
+				       pcal9555a_exp1_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe pcal9555a I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+	strlcpy(probed_i2c_pcal9555a_exp2.type, "pcal9555a", I2C_NAME_SIZE);
+	probed_i2c_pcal9555a_exp2.irq = gpio_to_irq(GPIO_PCAL9555A_EXP2_INT);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_pcal9555a_exp2,
+				       pcal9555a_exp2_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe pcal9555a I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+	strlcpy(probed_i2c_pca9685.type, "pca9685", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_pca9685,
+				       pca9685_i2c_addr, i2c_probe);
+	if (client == NULL) {
+		pr_err("%s: Failed to probe pca9685 I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+	ret = intel_qrk_spi_add_onboard_devs();
+
+end:
+	i2c_put_adapter(i2c_adap);
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_galileo_gen2_probe(struct platform_device *pdev)
+{
+	/* Assign GIP driver handle for board-specific settings */
+	intel_qrk_gip_get_pdata = galileo_gen2_gip_get_pdata;
+
+	/* gpio */
+	return platform_driver_register(&gpio_restrict_pdriver);
+}
+
+static int intel_qrk_plat_galileo_gen2_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_galileo_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_galileo_gen2_probe,
+	.remove		= intel_qrk_plat_galileo_gen2_remove,
+};
+
+module_platform_driver(qrk_galileo_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Galileo Gen2 BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
diff --git a/drivers/tty/serial/intel_quark_uart.c b/drivers/tty/serial/intel_quark_uart.c
index 5c0a01a..5bb6a00 100644
--- a/drivers/tty/serial/intel_quark_uart.c
+++ b/drivers/tty/serial/intel_quark_uart.c
@@ -38,6 +38,9 @@
 #include <linux/intel_mid_dma.h>
 #include <linux/debugfs.h>
 #include <linux/dmaengine.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
 
 enum {
 	QUARK_UART_HANDLED_RX_INT_SHIFT,
@@ -53,25 +56,27 @@ enum {
 	QUARK_UART_2LINE,
 };
 
-#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask) \
+#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask, _is_quark) \
 	((kernel_ulong_t)&(struct intel_mid_dma_probe_info) {	\
 		.max_chan = (_max_chan),			\
 		.ch_base = (_ch_base),				\
 		.block_size = (_block_size),			\
 		.pimr_mask = (_pimr_mask),			\
+		.is_quark = (_is_quark),			\
 	})
 
 #define QUARK_UART_DRIVER_DEVICE	"ttyQRK"
 #define QUARK_UART_FIFO_LEN		16
-//#define __QRK_DMA_DEBUG			/* TODO: remove all code of this type */
-
+#define QUARK_UART_MAXBURST		0x20
+#define QUARK_FIFO_FASTER_LEN		(QUARK_UART_MAXBURST/2)
 /* Set the max number of UART port
- * Intel EG20T QUARK: 4 port
- * LAPIS Semiconductor ML7213 IOH: 3 port
- * LAPIS Semiconductor ML7223 IOH: 2 port
+ * Intel QUARK X1000 : 2 port
 */
 #define QUARK_UART_NR 2
 
+/* Set the AHB address for DMA transfers */
+#define QUARK_UART_AHB_REG_BASE		0xFFFFF000
+
 #define QUARK_UART_HANDLED_RX_INT	(1<<((QUARK_UART_HANDLED_RX_INT_SHIFT)<<1))
 #define QUARK_UART_HANDLED_TX_INT	(1<<((QUARK_UART_HANDLED_TX_INT_SHIFT)<<1))
 #define QUARK_UART_HANDLED_RX_ERR_INT	(1<<((\
@@ -82,17 +87,17 @@ enum {
 
 #define QUARK_UART_HANDLED_LS_INT	(1<<((QUARK_UART_HANDLED_LS_INT_SHIFT)<<1))
 
-#define QUARK_UART_RBR		0x00
-#define QUARK_UART_THR		0x00
+#define QUARK_UART_RBR			0x00
+#define QUARK_UART_THR			0x00
 
-#define QUARK_UART_IER_MASK	(QUARK_UART_IER_ERBFI|QUARK_UART_IER_ETBEI|\
-				QUARK_UART_IER_ELSI|QUARK_UART_IER_EDSSI)
-#define QUARK_UART_IER_ERBFI	0x00000001
-#define QUARK_UART_IER_ETBEI	0x00000002
-#define QUARK_UART_IER_ELSI	0x00000004
-#define QUARK_UART_IER_EDSSI	0x00000008
+#define QUARK_UART_IER_MASK		(QUARK_UART_IER_ERBFI|QUARK_UART_IER_ETBEI|\
+					QUARK_UART_IER_ELSI|QUARK_UART_IER_EDSSI)
+#define QUARK_UART_IER_ERBFI		0x00000001
+#define QUARK_UART_IER_ETBEI		0x00000002
+#define QUARK_UART_IER_ELSI		0x00000004
+#define QUARK_UART_IER_EDSSI		0x00000008
 
-#define QUARK_UART_IIR_IP			0x00000001
+#define QUARK_UART_IIR_IP		0x00000001
 #define QUARK_UART_IIR_IID		0x00000006
 #define QUARK_UART_IIR_MSI		0x00000000
 #define QUARK_UART_IIR_TRI		0x00000002
@@ -101,7 +106,7 @@ enum {
 #define QUARK_UART_IIR_TOI		0x00000008
 #define QUARK_UART_IIR_FIFO256		0x00000020
 #define QUARK_UART_IIR_FIFO64		QUARK_UART_IIR_FIFO256
-#define QUARK_UART_IIR_FE			0x000000C0
+#define QUARK_UART_IIR_FE		0x000000C0
 
 #define QUARK_UART_FCR_FIFOE		0x00000001
 #define QUARK_UART_FCR_RFR		0x00000002
@@ -120,56 +125,56 @@ enum {
 #define QUARK_UART_FCR_RFTL4		QUARK_UART_FCR_RFTL64
 #define QUARK_UART_FCR_RFTL8		QUARK_UART_FCR_RFTL128
 #define QUARK_UART_FCR_RFTL14		QUARK_UART_FCR_RFTL224
-#define QUARK_UART_FCR_RFTL_SHIFT		6
+#define QUARK_UART_FCR_RFTL_SHIFT	6
 
-#define QUARK_UART_LCR_WLS	0x00000003
-#define QUARK_UART_LCR_STB	0x00000004
-#define QUARK_UART_LCR_PEN	0x00000008
-#define QUARK_UART_LCR_EPS	0x00000010
+#define QUARK_UART_LCR_WLS		0x00000003
+#define QUARK_UART_LCR_STB		0x00000004
+#define QUARK_UART_LCR_PEN		0x00000008
+#define QUARK_UART_LCR_EPS		0x00000010
 #define QUARK_UART_LCR_SP		0x00000020
 #define QUARK_UART_LCR_SB		0x00000040
-#define QUARK_UART_LCR_DLAB	0x00000080
+#define QUARK_UART_LCR_DLAB		0x00000080
 #define QUARK_UART_LCR_NP		0x00000000
 #define QUARK_UART_LCR_OP		QUARK_UART_LCR_PEN
 #define QUARK_UART_LCR_EP		(QUARK_UART_LCR_PEN | QUARK_UART_LCR_EPS)
 #define QUARK_UART_LCR_1P		(QUARK_UART_LCR_PEN | QUARK_UART_LCR_SP)
 #define QUARK_UART_LCR_0P		(QUARK_UART_LCR_PEN | QUARK_UART_LCR_EPS |\
-				QUARK_UART_LCR_SP)
+					QUARK_UART_LCR_SP)
 
-#define QUARK_UART_LCR_5BIT	0x00000000
-#define QUARK_UART_LCR_6BIT	0x00000001
-#define QUARK_UART_LCR_7BIT	0x00000002
-#define QUARK_UART_LCR_8BIT	0x00000003
+#define QUARK_UART_LCR_5BIT		0x00000000
+#define QUARK_UART_LCR_6BIT		0x00000001
+#define QUARK_UART_LCR_7BIT		0x00000002
+#define QUARK_UART_LCR_8BIT		0x00000003
 
-#define QUARK_UART_MCR_DTR	0x00000001
-#define QUARK_UART_MCR_RTS	0x00000002
-#define QUARK_UART_MCR_OUT	0x0000000C
-#define QUARK_UART_MCR_LOOP	0x00000010
-#define QUARK_UART_MCR_AFE	0x00000020
+#define QUARK_UART_MCR_DTR		0x00000001
+#define QUARK_UART_MCR_RTS		0x00000002
+#define QUARK_UART_MCR_OUT		0x0000000C
+#define QUARK_UART_MCR_LOOP		0x00000010
+#define QUARK_UART_MCR_AFE		0x00000020
 
 #define QUARK_UART_LSR_DR		0x00000001
-#define QUARK_UART_LSR_ERR	(1<<7)
-
-#define QUARK_UART_MSR_DCTS	0x00000001
-#define QUARK_UART_MSR_DDSR	0x00000002
-#define QUARK_UART_MSR_TERI	0x00000004
-#define QUARK_UART_MSR_DDCD	0x00000008
-#define QUARK_UART_MSR_CTS	0x00000010
-#define QUARK_UART_MSR_DSR	0x00000020
+#define QUARK_UART_LSR_ERR		(1<<7)
+
+#define QUARK_UART_MSR_DCTS		0x00000001
+#define QUARK_UART_MSR_DDSR		0x00000002
+#define QUARK_UART_MSR_TERI		0x00000004
+#define QUARK_UART_MSR_DDCD		0x00000008
+#define QUARK_UART_MSR_CTS		0x00000010
+#define QUARK_UART_MSR_DSR		0x00000020
 #define QUARK_UART_MSR_RI		0x00000040
-#define QUARK_UART_MSR_DCD	0x00000080
-#define QUARK_UART_MSR_DELTA	(QUARK_UART_MSR_DCTS | QUARK_UART_MSR_DDSR |\
-				QUARK_UART_MSR_TERI | QUARK_UART_MSR_DDCD)
+#define QUARK_UART_MSR_DCD		0x00000080
+#define QUARK_UART_MSR_DELTA		(QUARK_UART_MSR_DCTS | QUARK_UART_MSR_DDSR |\
+					QUARK_UART_MSR_TERI | QUARK_UART_MSR_DDCD)
 
-#define QUARK_UART_DLL		0x00
-#define QUARK_UART_DLM		0x01
+#define QUARK_UART_DLL			0x00
+#define QUARK_UART_DLM			0x01
 
 #define QUARK_UART_BRCSR		0x0E
 
-#define QUARK_UART_IID_RLS	(QUARK_UART_IIR_REI)
-#define QUARK_UART_IID_RDR	(QUARK_UART_IIR_RRI)
-#define QUARK_UART_IID_RDR_TO	(QUARK_UART_IIR_RRI | QUARK_UART_IIR_TOI)
-#define QUARK_UART_IID_THRE	(QUARK_UART_IIR_TRI)
+#define QUARK_UART_IID_RLS		(QUARK_UART_IIR_REI)
+#define QUARK_UART_IID_RDR		(QUARK_UART_IIR_RRI)
+#define QUARK_UART_IID_RDR_TO		(QUARK_UART_IIR_RRI | QUARK_UART_IIR_TOI)
+#define QUARK_UART_IID_THRE		(QUARK_UART_IIR_TRI)
 #define QUARK_UART_IID_MS		(QUARK_UART_IIR_MSI)
 
 #define QUARK_UART_HAL_PARITY_NONE	(QUARK_UART_LCR_NP)
@@ -189,29 +194,29 @@ enum {
 #define QUARK_UART_HAL_CLR_ALL_FIFO	(QUARK_UART_HAL_CLR_TX_FIFO | \
 					QUARK_UART_HAL_CLR_RX_FIFO)
 
-#define QUARK_UART_HAL_DMA_MODE0		0
+#define QUARK_UART_HAL_DMA_MODE0	0
 #define QUARK_UART_HAL_FIFO_DIS		0
 #define QUARK_UART_HAL_FIFO16		(QUARK_UART_FCR_FIFOE)
 #define QUARK_UART_HAL_FIFO256		(QUARK_UART_FCR_FIFOE | \
 					QUARK_UART_FCR_FIFO256)
 #define QUARK_UART_HAL_FIFO64		(QUARK_UART_HAL_FIFO256)
 #define QUARK_UART_HAL_TRIGGER1		(QUARK_UART_FCR_RFTL1)
-#define QUARK_UART_HAL_TRIGGER64		(QUARK_UART_FCR_RFTL64)
-#define QUARK_UART_HAL_TRIGGER128		(QUARK_UART_FCR_RFTL128)
-#define QUARK_UART_HAL_TRIGGER224		(QUARK_UART_FCR_RFTL224)
-#define QUARK_UART_HAL_TRIGGER16		(QUARK_UART_FCR_RFTL16)
-#define QUARK_UART_HAL_TRIGGER32		(QUARK_UART_FCR_RFTL32)
-#define QUARK_UART_HAL_TRIGGER56		(QUARK_UART_FCR_RFTL56)
+#define QUARK_UART_HAL_TRIGGER64	(QUARK_UART_FCR_RFTL64)
+#define QUARK_UART_HAL_TRIGGER128	(QUARK_UART_FCR_RFTL128)
+#define QUARK_UART_HAL_TRIGGER224	(QUARK_UART_FCR_RFTL224)
+#define QUARK_UART_HAL_TRIGGER16	(QUARK_UART_FCR_RFTL16)
+#define QUARK_UART_HAL_TRIGGER32	(QUARK_UART_FCR_RFTL32)
+#define QUARK_UART_HAL_TRIGGER56	(QUARK_UART_FCR_RFTL56)
 #define QUARK_UART_HAL_TRIGGER4		(QUARK_UART_FCR_RFTL4)
 #define QUARK_UART_HAL_TRIGGER8		(QUARK_UART_FCR_RFTL8)
-#define QUARK_UART_HAL_TRIGGER14		(QUARK_UART_FCR_RFTL14)
-#define QUARK_UART_HAL_TRIGGER_L		(QUARK_UART_FCR_RFTL64)
-#define QUARK_UART_HAL_TRIGGER_M		(QUARK_UART_FCR_RFTL128)
-#define QUARK_UART_HAL_TRIGGER_H		(QUARK_UART_FCR_RFTL224)
+#define QUARK_UART_HAL_TRIGGER14	(QUARK_UART_FCR_RFTL14)
+#define QUARK_UART_HAL_TRIGGER_L	(QUARK_UART_FCR_RFTL64)
+#define QUARK_UART_HAL_TRIGGER_M	(QUARK_UART_FCR_RFTL128)
+#define QUARK_UART_HAL_TRIGGER_H	(QUARK_UART_FCR_RFTL224)
 
 #define QUARK_UART_HAL_RX_INT		(QUARK_UART_IER_ERBFI)
 #define QUARK_UART_HAL_TX_INT		(QUARK_UART_IER_ETBEI)
-#define QUARK_UART_HAL_RX_ERR_INT		(QUARK_UART_IER_ELSI)
+#define QUARK_UART_HAL_RX_ERR_INT	(QUARK_UART_IER_ELSI)
 #define QUARK_UART_HAL_MS_INT		(QUARK_UART_IER_EDSSI)
 #define QUARK_UART_HAL_ALL_INT		(QUARK_UART_IER_MASK)
 
@@ -255,36 +260,36 @@ struct x1000_port {
 	unsigned int dmsr;
 	unsigned int fcr;
 	unsigned int mcr;
-	unsigned int use_dma;
+	unsigned int ier;
+	bool use_dma;
 	struct dma_async_tx_descriptor	*desc_tx;
 	struct dma_async_tx_descriptor	*desc_rx;
-#if 1
-	struct dma_chan			*chan_tx;
-	struct dma_chan			*chan_rx;
+	struct dma_chan			*tx_chan;
+	struct dma_chan			*rx_chan;
 	struct middma_device		mid_dma;
 	struct quark_uart_buffer	txbuf;
 	struct quark_uart_buffer	rxbuf;
 	struct intel_mid_dma_slave	dmas_rx;
 	struct intel_mid_dma_slave	dmas_tx;
-#else
-	struct quark_dma_slave		param_tx;
-	struct quark_dma_slave		param_rx;
-	struct dma_chan			*chan_tx;
-	struct dma_chan			*chan_rx;
-#endif
 	struct scatterlist		*sg_tx_p;
 	int				nent;
 	struct scatterlist		sg_rx;
 	int				tx_dma_use;
 	void				*rx_buf_virt;
 	dma_addr_t			rx_buf_dma;
-
 	struct dentry	*debugfs;
-
+	struct work_struct		work;
+	int dma_tx_in_flight;
 	/* protect the x1000_port private structure and io access to membase */
 	spinlock_t lock;
+	struct dma_slave_config tx_conf;
+	struct dma_slave_config rx_conf;
+	wait_queue_head_t 		w_queue;
+
 };
 
+static struct uart_driver quark_uart_driver;
+
 /**
  * struct quark_uart_driver_data - private data structure for UART-DMA
  * @port_type:			The number of DMA channel
@@ -295,19 +300,16 @@ struct quark_uart_driver_data {
 	int line_no;
 };
 
-#if 0
-static unsigned int mem_serial_in(struct uart_port *p, int offset)
+/**
+ * intel_qrk_dma_chan_filter
+ *
+ * Simple descriptor disjunct function
+ */
+static bool intel_qrk_dma_chan_filter(struct dma_chan * chan, void *param)
 {
-	offset = offset << p->regshift;
-	return readb(p->membase + offset);
+	return 1;
 }
 
-static void mem_serial_out(struct uart_port *p, int offset, int value)
-{
-	offset = offset << p->regshift;
-	writeb(value, p->membase + offset);
-}
-#endif
 
 /**
  * serial_in
@@ -344,6 +346,7 @@ static inline void serial_out(struct x1000_port *up, int offset, int value)
 static struct x1000_port *quark_uart_ports[QUARK_UART_NR];
 #endif
 static unsigned int default_baud = 115200;
+static bool use_dma = true;
 static const int trigger_level_256[4] = { 1, 64, 128, 224 };
 static const int trigger_level_64[4] = { 1, 16, 32, 56 };
 static const int trigger_level_16[4] = { 1, 4, 8, 14 };
@@ -353,7 +356,6 @@ static const int trigger_level_1[4] = { 1, 1, 1, 1 };
 
 #define QUARK_REGS_BUFSIZE	1024
 
-
 static ssize_t port_show_regs(struct file *file, char __user *user_buf,
 				size_t count, loff_t *ppos)
 {
@@ -404,6 +406,7 @@ static ssize_t port_show_regs(struct file *file, char __user *user_buf,
 	return ret;
 }
 
+
 static const struct file_operations port_regs_ops = {
 	.owner		= THIS_MODULE,
 	.open		= simple_open,
@@ -422,24 +425,17 @@ static void quark_uart_hal_enable_interrupt(struct x1000_port *priv,
 					  unsigned int flag)
 {
 	u8 ier = serial_in(priv, UART_IER);
-#ifdef __QRK_DMA_DEBUG
-//	pr_info("%s read IER %x\n", __func__, ier);
-#endif
 	ier |= flag & QUARK_UART_IER_MASK;
+	priv->ier = ier;
 	serial_out(priv, UART_IER, ier);
-#ifdef __QRK_DMA_DEBUG
-//	pr_info("%s wrote IER %x\n", __func__, ier);
-#endif
 }
 
 static void quark_uart_hal_disable_interrupt(struct x1000_port *priv,
 					   unsigned int flag)
 {
-#ifdef __QRK_DMA_DEBUG
-//	pr_info("%s entry\n", __func__);
-#endif
 	u8 ier = serial_in(priv, UART_IER);
 	ier &= ~(flag & QUARK_UART_IER_MASK);
+	priv->ier = ier;
 	serial_out(priv, UART_IER, ier);
 }
 
@@ -478,11 +474,6 @@ static int quark_uart_hal_set_line(struct x1000_port *priv, unsigned int baud,
 	lcr |= bits;
 	lcr |= stb;
 
-#ifdef __QRK_DMA_DEBUG
-	/* TODO: change this back to dev_dbg - BOD */
-	dev_info(priv->port.dev, "%s:baud = %u, div = %04x, lcr = %02x (%lu)\n",
-		 __func__, baud, div, lcr, jiffies);
-#endif
 	serial_out(priv, UART_LCR, QUARK_UART_LCR_DLAB);
 	serial_out(priv, QUARK_UART_DLL, dll);
 	serial_out(priv, QUARK_UART_DLM, dlm);
@@ -550,22 +541,15 @@ static int quark_uart_hal_set_fifo(struct x1000_port *priv,
 		    trigger_level_1[trigger >> QUARK_UART_FCR_RFTL_SHIFT];
 		break;
 	}
-#if 0
 	fcr =
 	    dmamode | fifo_size | trigger | QUARK_UART_FCR_RFR | QUARK_UART_FCR_TFR;
-#else
-	fcr =
-	    fifo_size | trigger | QUARK_UART_FCR_RFR | QUARK_UART_FCR_TFR;
 
-#endif
 	serial_out(priv, UART_FCR, QUARK_UART_FCR_FIFOE);
 	serial_out(priv,
 		 UART_FCR, QUARK_UART_FCR_FIFOE | QUARK_UART_FCR_RFR | QUARK_UART_FCR_TFR);
 	serial_out(priv, UART_FCR, fcr);
 	priv->fcr = fcr;
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s FCR set to %x\n", __func__, priv->fcr);
-#endif
+
 	return 0;
 }
 
@@ -691,101 +675,6 @@ static int dma_push_rx(struct x1000_port *priv, int size)
 	return room;
 }
 
-static void quark_free_dma(struct uart_port *port)
-{
-	struct x1000_port *priv;
-	priv = container_of(port, struct x1000_port, port);
-
-	if (priv->chan_tx) {
-		dma_release_channel(priv->chan_tx);
-		priv->chan_tx = NULL;
-	}
-	if (priv->chan_rx) {
-		dma_release_channel(priv->chan_rx);
-		priv->chan_rx = NULL;
-	}
-
-	if (priv->rx_buf_dma) {
-		dma_free_coherent(port->dev, port->fifosize, priv->rx_buf_virt,
-				  priv->rx_buf_dma);
-		priv->rx_buf_virt = NULL;
-		priv->rx_buf_dma = 0;
-	}
-
-	return;
-}
-
-static bool filter(struct dma_chan *chan, void *slave)
-{
-	#if 0
-	struct quark_dma_slave *param = slave;
-
-	if ((chan->chan_id == param->chan_id) && (param->dma_dev ==
-						  chan->device->dev)) {
-		chan->private = param;
-		return true;
-	} else {
-		return false;
-	}
-	#else
-	return true;
-	#endif
-}
-
-static void quark_request_dma(struct uart_port *port)
-{
-	dma_cap_mask_t mask;
-	struct dma_chan *chan;
-	struct pci_dev *dma_dev;
-#if 0
-	struct quark_dma_slave *param;
-#endif
-	struct x1000_port *priv =
-				container_of(port, struct x1000_port, port);
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
-
-	dma_dev = pci_get_bus_and_slot(priv->pdev->bus->number,
-				       PCI_DEVFN(0xa, 0)); /* Get DMA's dev
-								information */
-	/* Set Tx DMA */
-#if 0
-	param = &priv->param_tx;
-	param->dma_dev = &dma_dev->dev;
-	param->chan_id = priv->port.line * 2; /* Tx = 0, 2, 4, ... */
-
-	param->tx_reg = port->mapbase + UART_TX;
-#endif
-	chan = dma_request_channel(mask, filter, &priv->dmas_tx);
-	if (!chan) {
-		dev_err(priv->port.dev, "%s:dma_request_channel FAILS(Tx)\n",
-			__func__);
-		return;
-	}
-	priv->chan_tx = chan;
-#if 0
-	/* Set Rx DMA */
-	param = &priv->param_rx;
-	param->dma_dev = &dma_dev->dev;
-	param->chan_id = priv->port.line * 2 + 1; /* Rx = Tx + 1 */
-
-	param->rx_reg = port->mapbase + UART_RX;
-#endif
-	chan = dma_request_channel(mask, filter, &priv->dmas_rx);
-	if (!chan) {
-		dev_err(priv->port.dev, "%s:dma_request_channel FAILS(Rx)\n",
-			__func__);
-		dma_release_channel(priv->chan_tx);
-		priv->chan_tx = NULL;
-		return;
-	}
-
-	/* Get Consistent memory for DMA */
-	priv->rx_buf_virt = dma_alloc_coherent(port->dev, port->fifosize,
-				    &priv->rx_buf_dma, GFP_KERNEL);
-	priv->chan_rx = chan;
-}
-
 static void quark_dma_rx_complete(void *arg)
 {
 	struct x1000_port *priv = arg;
@@ -809,18 +698,32 @@ static void quark_dma_tx_complete(void *arg)
 	struct circ_buf *xmit = &port->state->xmit;
 	struct scatterlist *sg = priv->sg_tx_p;
 	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
 
 	for (i = 0; i < priv->nent; i++, sg++) {
 		xmit->tail += sg_dma_len(sg);
 		port->icount.tx += sg_dma_len(sg);
 	}
-	xmit->tail &= UART_XMIT_SIZE - 1;
+	/* Make sure that xmit->head and xmit->tail are equal
+	   to zero at the end of a transaction */
+	if(priv->tx_dma_use == 0)
+		xmit->head = xmit->tail = 0;
+	else
+		xmit->tail &= UART_XMIT_SIZE - 1;
 	async_tx_ack(priv->desc_tx);
 	dma_unmap_sg(port->dev, sg, priv->nent, DMA_TO_DEVICE);
 	priv->tx_dma_use = 0;
 	priv->nent = 0;
+	priv->tx_empty = 1;
 	kfree(priv->sg_tx_p);
+
 	quark_uart_hal_enable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+	priv->dma_tx_in_flight = 0;
+	wake_up(&priv->w_queue);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 static int pop_tx(struct x1000_port *priv, int size)
@@ -893,10 +796,21 @@ static int dma_handle_rx(struct x1000_port *priv)
 
 	sg_dma_address(sg) = priv->rx_buf_dma;
 
-	desc = dmaengine_prep_slave_sg(priv->chan_rx,
-			sg, 1, DMA_DEV_TO_MEM,
-			DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	/* Configure RX */
+	priv->rx_conf.dst_addr = sg_dma_address(sg);
+	priv->rx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	priv->rx_conf.dst_maxburst = LNW_DMA_MSIZE_1;
 
+	priv->rx_conf.src_addr = QUARK_UART_AHB_REG_BASE + QUARK_UART_THR;	/* Wants an AHB address */
+	priv->rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	priv->rx_conf.src_maxburst = LNW_DMA_MSIZE_4; 
+	priv->rx_conf.direction = DMA_DEV_TO_MEM;
+	priv->rx_conf.device_fc = false;
+
+	dmaengine_slave_config(priv->rx_chan, &priv->rx_conf);
+	desc = dmaengine_prep_slave_sg(priv->rx_chan,
+					sg, 1, DMA_DEV_TO_MEM,
+					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 	if (!desc)
 		return 0;
 
@@ -904,7 +818,7 @@ static int dma_handle_rx(struct x1000_port *priv)
 	desc->callback = quark_dma_rx_complete;
 	desc->callback_param = priv;
 	desc->tx_submit(desc);
-	dma_async_issue_pending(priv->chan_rx);
+	dma_async_issue_pending(priv->rx_chan);
 
 	return QUARK_UART_HANDLED_RX_INT;
 }
@@ -919,9 +833,10 @@ static unsigned int handle_tx(struct x1000_port *priv)
 	int tx_empty;
 
 	if (!priv->start_tx) {
-		dev_info(priv->port.dev, "%s:Tx isn't started. (%lu)\n",
+		dev_dbg(priv->port.dev, "%s:Tx isn't started. (%lu)\n",
 			__func__, jiffies);
 		quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+		wake_up(&priv->w_queue);
 		priv->tx_empty = 1;
 		return 0;
 	}
@@ -945,15 +860,17 @@ static unsigned int handle_tx(struct x1000_port *priv)
 	}
 
 	priv->tx_empty = tx_empty;
-
 	if (tx_empty) {
 		quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
-		uart_write_wakeup(port);
+		wake_up(&priv->w_queue);
+		if (port->state->port.tty != NULL)
+			uart_write_wakeup(port);
 	}
 
 	return QUARK_UART_HANDLED_TX_INT;
 }
 
+
 static unsigned int dma_handle_tx(struct x1000_port *priv)
 {
 	struct uart_port *port = &priv->port;
@@ -962,17 +879,18 @@ static unsigned int dma_handle_tx(struct x1000_port *priv)
 	int nent;
 	int fifo_size;
 	int tx_empty;
-	struct dma_async_tx_descriptor *desc;
 	int num;
 	int i;
 	int bytes;
 	int size;
 	int rem;
+	int ret;
 
 	if (!priv->start_tx) {
-		dev_info(priv->port.dev, "%s:Tx isn't started. (%lu)\n",
+		dev_dbg(priv->port.dev, "%s:Tx isn't started. (%lu)\n",
 			__func__, jiffies);
 		quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+		wake_up(&priv->w_queue);
 		priv->tx_empty = 1;
 		return 0;
 	}
@@ -981,11 +899,12 @@ static unsigned int dma_handle_tx(struct x1000_port *priv)
 		dev_dbg(priv->port.dev, "%s:Tx is not completed. (%lu)\n",
 			__func__, jiffies);
 		quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+		wake_up(&priv->w_queue);
 		priv->tx_empty = 1;
 		return 0;
 	}
 
-	fifo_size = max(priv->fifo_size, 1);
+	fifo_size = QUARK_UART_MAXBURST;
 	tx_empty = 1;
 	if (pop_tx_x(priv, xmit->buf)) {
 		quark_uart_hal_write(priv, xmit->buf, 1);
@@ -997,15 +916,37 @@ static unsigned int dma_handle_tx(struct x1000_port *priv)
 	bytes = min((int)CIRC_CNT(xmit->head, xmit->tail,
 			     UART_XMIT_SIZE), CIRC_CNT_TO_END(xmit->head,
 			     xmit->tail, UART_XMIT_SIZE));
+
 	if (!bytes) {
 		dev_dbg(priv->port.dev, "%s 0 bytes return\n", __func__);
 		quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
-		uart_write_wakeup(port);
+		wake_up(&priv->w_queue);
+		if (port->state->port.tty != NULL)
+			uart_write_wakeup(port);
 		return 0;
 	}
 
+	/* DMA block doesn't do !dword aligned */
+	if (bytes % 0x04){
+		if (bytes < 4){
+			ret = handle_tx(priv);
+			/* DMA transactions want to start DWORD aligned */
+			xmit->head = xmit->tail = 0;
+			return ret;
+		}
+		bytes &= 0xFFFFFFFC;
+	}
+
+	/* For small payloads its just faster to write the FIFO directly */
+	if (bytes < QUARK_FIFO_FASTER_LEN){
+		ret = handle_tx(priv);
+		/* DMA transactions want to start DWORD aligned */
+		xmit->head = xmit->tail = 0;
+		return ret;
+	}
+
 	if (bytes > fifo_size) {
-		num = bytes / fifo_size + 1;
+		num = bytes / fifo_size;
 		size = fifo_size;
 		rem = bytes % fifo_size;
 	} else {
@@ -1029,6 +970,7 @@ static unsigned int dma_handle_tx(struct x1000_port *priv)
 	sg = priv->sg_tx_p;
 
 	for (i = 0; i < num; i++, sg++) {
+		BUG_ON((int)xmit->buf & ~PAGE_MASK);
 		if (i == (num - 1))
 			sg_set_page(sg, virt_to_page(xmit->buf),
 				    rem, fifo_size * i);
@@ -1050,28 +992,18 @@ static unsigned int dma_handle_tx(struct x1000_port *priv)
 			      fifo_size * i;
 		sg_dma_address(sg) = (sg_dma_address(sg) &
 				    ~(UART_XMIT_SIZE - 1)) + sg->offset;
+
 		if (i == (nent - 1))
-			sg_dma_len(sg) = rem;
+			sg_dma_len(sg) = bytes;
 		else
 			sg_dma_len(sg) = size;
+		bytes -= size;
 	}
 
-	desc = dmaengine_prep_slave_sg(priv->chan_tx,
-					priv->sg_tx_p, nent, DMA_MEM_TO_DEV,
-					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-	if (!desc) {
-		dev_err(priv->port.dev, "%s:device_prep_slave_sg Failed\n",
-			__func__);
-		return 0;
-	}
-	dma_sync_sg_for_device(port->dev, priv->sg_tx_p, nent, DMA_TO_DEVICE);
-	priv->desc_tx = desc;
-	desc->callback = quark_dma_tx_complete;
-	desc->callback_param = priv;
-
-	desc->tx_submit(desc);
-
-	dma_async_issue_pending(priv->chan_tx);
+	priv->dma_tx_in_flight = 1;
+	quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+	wake_up(&priv->w_queue);
+	schedule_work(&priv->work);
 
 	return QUARK_UART_HANDLED_TX_INT;
 }
@@ -1117,6 +1049,42 @@ static void quark_uart_err_ir(struct x1000_port *priv, unsigned int lsr)
 	#define unmask_pvm(x)
 #endif
 
+static void quark_uart_work(struct work_struct *work)
+{
+	struct x1000_port *priv = container_of(work, struct x1000_port,work);
+	struct dma_async_tx_descriptor *desc;
+
+	if (priv == NULL) {
+		pr_err("ERR_X1000: tasklet Null param\n");
+		return;
+	}
+	/* Configure TX */
+	priv->tx_conf.src_addr = sg_dma_address(priv->sg_tx_p);
+	priv->tx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	priv->tx_conf.src_maxburst = LNW_DMA_MSIZE_1;
+	priv->tx_conf.dst_addr = QUARK_UART_AHB_REG_BASE + QUARK_UART_THR;	/* Wants an AHB address */
+	priv->tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	priv->tx_conf.dst_maxburst = LNW_DMA_MSIZE_4;
+	priv->tx_conf.direction = DMA_MEM_TO_DEV;
+	priv->tx_conf.device_fc = false;
+
+	dmaengine_slave_config(priv->tx_chan, &priv->tx_conf);
+	desc = dmaengine_prep_slave_sg(priv->tx_chan,
+					priv->sg_tx_p, priv->nent, DMA_MEM_TO_DEV,
+					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dev_err(priv->port.dev, "%s:device_prep_slave_sg Failed\n",
+			__func__);
+		return;
+	}
+	dma_sync_sg_for_device(priv->port.dev, priv->sg_tx_p, priv->nent, DMA_TO_DEVICE);
+	priv->desc_tx = desc;
+	desc->callback = quark_dma_tx_complete;
+	desc->callback_param = priv;
+	desc->tx_submit(desc);
+	dma_async_issue_pending(priv->tx_chan);
+}
+
 static irqreturn_t quark_uart_interrupt(int irq, void *dev_id)
 {
 	struct x1000_port *priv = dev_id;
@@ -1146,18 +1114,9 @@ static irqreturn_t quark_uart_interrupt(int irq, void *dev_id)
 			}
 			break;
 		case QUARK_UART_IID_RDR:	/* Received Data Ready */
-			if (priv->use_dma) {
-				quark_uart_hal_disable_interrupt(priv,
-						QUARK_UART_HAL_RX_INT |
-						QUARK_UART_HAL_RX_ERR_INT);
-				ret = dma_handle_rx(priv);
-				if (!ret)
-					quark_uart_hal_enable_interrupt(priv,
-						QUARK_UART_HAL_RX_INT |
-						QUARK_UART_HAL_RX_ERR_INT);
-			} else {
-				ret = handle_rx(priv);
-			}
+
+			(void)dma_handle_rx;   /*Not worth setup time*/
+			ret = handle_rx(priv);
 			break;
 		case QUARK_UART_IID_RDR_TO:	/* Received Data Ready
 						   (FIFO Timeout) */
@@ -1166,7 +1125,6 @@ static irqreturn_t quark_uart_interrupt(int irq, void *dev_id)
 		case QUARK_UART_IID_THRE:	/* Transmitter Holding Register
 						   Empty */
 			if (priv->use_dma)
-
 				ret = dma_handle_tx(priv);
 			else
 				ret = handle_tx(priv);
@@ -1254,45 +1212,48 @@ static void quark_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
 static void quark_uart_stop_tx(struct uart_port *port)
 {
 	struct x1000_port *priv;
+	unsigned long flags;
 	priv = container_of(port, struct x1000_port, port);
+
+	spin_lock_irqsave(&priv->lock, flags);
 	priv->start_tx = 0;
 	priv->tx_dma_use = 0;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 static void quark_uart_start_tx(struct uart_port *port)
 {
 	struct x1000_port *priv;
 
+	unsigned long flags;
 	priv = container_of(port, struct x1000_port, port);
 
+	spin_lock_irqsave(&priv->lock, flags);
 	if (priv->use_dma) {
 		if (priv->tx_dma_use) {
 			dev_dbg(priv->port.dev, "%s : Tx DMA is NOT empty.\n",
 				__func__);
-			return;
+			goto done;
 		}
 	}
 
-#ifdef __QRK_DMA_DEBUG
-	unsigned char iid = quark_uart_hal_get_iid(priv);
-	pr_info("%s enable interrupt IER %x FCR %x iid %x\n", __func__, serial_in(priv, UART_IER),
-		serial_in(priv, UART_FCR), iid);
-#endif
 	priv->start_tx = 1;
-	quark_uart_hal_enable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+	if( priv->dma_tx_in_flight == 0)
+		quark_uart_hal_enable_interrupt(priv, QUARK_UART_HAL_TX_INT);
+
+done:
+	spin_unlock_irqrestore(&priv->lock, flags);
+
 }
 
 static void quark_uart_stop_rx(struct uart_port *port)
 {
 	struct x1000_port *priv;
-			
 	priv = container_of(port, struct x1000_port, port);
+
+	wait_event(priv->w_queue,!(priv->ier & QUARK_UART_HAL_TX_INT) && !priv->dma_tx_in_flight);
 	priv->start_rx = 0;
-#ifdef __QRK_DMA_DEBUG
-	unsigned char iid;
-	iid = quark_uart_hal_get_iid(priv);
-	pr_info("%s IID is 0x%x USR 0x%x LSR 0x%x MSR 0x%x\n", __func__, iid, serial_in(priv,31), serial_in(priv, UART_LSR), serial_in(priv, UART_MSR));
-#endif
 	quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_RX_INT |
 					     QUARK_UART_HAL_RX_ERR_INT);
 }
@@ -1332,9 +1293,7 @@ static int quark_uart_startup(struct uart_port *port)
 		priv->uartclk = port->uartclk;
 	else
 		port->uartclk = priv->uartclk;
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s entry fifo size %d!\n", __func__, priv->fifo_size);
-#endif
+
 	quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_ALL_INT);
 	ret = quark_uart_hal_set_line(priv, default_baud,
 			      QUARK_UART_HAL_PARITY_NONE, QUARK_UART_HAL_8BIT,
@@ -1376,28 +1335,14 @@ static int quark_uart_startup(struct uart_port *port)
 	}
 
 	priv->trigger_level = trigger_level;
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s setting FCR fifo_size %d FIFO trig %d\n", __func__, fifo_size, priv->trigger);
-#endif
 	ret = quark_uart_hal_set_fifo(priv, QUARK_UART_HAL_DMA_MODE0,
 				    fifo_size, priv->trigger);
 	if (ret < 0)
 		return ret;
-	
-	if (priv->use_dma)
-		quark_request_dma(port);
-
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s enable interrupt IER %x FCR %x USR %x\n", __func__, serial_in(priv, UART_IER),
-		serial_in(priv, UART_FCR), serial_in(priv, 31));
-#endif
 	priv->start_rx = 1;
 	quark_uart_hal_enable_interrupt(priv, QUARK_UART_HAL_RX_INT |
 					    QUARK_UART_HAL_RX_ERR_INT);
 	uart_update_timeout(port, CS8, default_baud);
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s exit IER %x FCR %x USR %x\n", __func__, serial_in(priv, UART_IER), serial_in(priv, UART_FCR), serial_in(priv, 31));
-#endif
 	return 0;
 }
 
@@ -1406,10 +1351,10 @@ static void quark_uart_shutdown(struct uart_port *port)
 	struct x1000_port *priv;
 	int ret;
 
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s called!\n", __func__);
-#endif
 	priv = container_of(port, struct x1000_port, port);
+
+	wait_event(priv->w_queue, !(priv->dma_tx_in_flight));
+
 	quark_uart_hal_disable_interrupt(priv, QUARK_UART_HAL_ALL_INT);
 	quark_uart_hal_fifo_reset(priv, QUARK_UART_HAL_CLR_ALL_FIFO);
 	ret = quark_uart_hal_set_fifo(priv, QUARK_UART_HAL_DMA_MODE0,
@@ -1417,8 +1362,6 @@ static void quark_uart_shutdown(struct uart_port *port)
 	if (ret)
 		dev_err(priv->port.dev,
 			"quark_uart_hal_set_fifo Failed(ret=%d)\n", ret);
-
-	quark_free_dma(port);
 }
 
 /* Change the port parameters, including word length, parity, stop
@@ -1470,7 +1413,6 @@ static void quark_uart_set_termios(struct uart_port *port,
 	termios->c_cflag &= ~CMSPAR; /* Mark/Space parity is not supported */
 
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);
-
 	spin_lock_irqsave(&priv->lock, flags);
 	spin_lock(&port->lock);
 
@@ -1505,23 +1447,6 @@ static void quark_uart_release_port(struct uart_port *port)
 
 static int quark_uart_request_port(struct uart_port *port)
 {
-#if 0
-	struct x1000_port *priv;
-	int ret;
-	void __iomem *membase;
-
-	priv = container_of(port, struct x1000_port, port);
-	ret = pci_request_regions(priv->pdev, KBUILD_MODNAME);
-	if (ret < 0)
-		return -EBUSY;
-
-	membase = pci_iomap(priv->pdev, 1, 0);
-	if (!membase) {
-		pci_release_regions(priv->pdev);
-		return -EBUSY;
-	}
-	priv->membase = port->membase = membase;
-#endif
 	return 0;
 }
 
@@ -1529,9 +1454,6 @@ static void quark_uart_config_port(struct uart_port *port, int type)
 {
 	struct x1000_port *priv;
 
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s entry!\n", __func__);
-#endif
 	priv = container_of(port, struct x1000_port, port);
 	if (type & UART_CONFIG_TYPE) {
 		port->type = priv->port_type;
@@ -1543,25 +1465,20 @@ static int quark_uart_verify_port(struct uart_port *port,
 				struct serial_struct *serinfo)
 {
 	struct x1000_port *priv;
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s entry point !\n", __func__);
-#endif
 	priv = container_of(port, struct x1000_port, port);
+
 	if (serinfo->flags & UPF_LOW_LATENCY) {
 		dev_info(priv->port.dev,
 			"QUARK UART : Use PIO Mode (without DMA)\n");
-		priv->use_dma = 0;
+		priv->use_dma = false;
 		serinfo->flags &= ~UPF_LOW_LATENCY;
 	} else {
-#ifndef CONFIG_QUARK_DMA
-		dev_err(priv->port.dev, "%s : QUARK DMA is not Loaded.\n",
-			__func__);
-		return -EOPNOTSUPP;
-#endif
 		dev_info(priv->port.dev, "QUARK UART : Use DMA Mode\n");
+		#if 0
 		if (!priv->use_dma)
 			quark_request_dma(port);
-		priv->use_dma = 1;
+		#endif
+		priv->use_dma = true;
 	}
 
 	return 0;
@@ -1663,7 +1580,7 @@ static struct uart_ops quark_uart_ops = {
 	.startup = quark_uart_startup,
 	.shutdown = quark_uart_shutdown,
 	.set_termios = quark_uart_set_termios,
-/*	.pm		= quark_uart_pm,		Not supported yet */
+/*	.pm		= quark_uart_pm,	Not supported yet */
 /*	.set_wake	= quark_uart_set_wake,	Not supported yet */
 	.type = quark_uart_type,
 	.release_port = quark_uart_release_port,
@@ -1710,7 +1627,7 @@ quark_console_write(struct console *co, const char *s, unsigned int count)
 	if (priv->port.sysrq) {
 		/* call to uart_handle_sysrq_char already took the priv lock */
 		priv_locked = 0;
-		/* serial8250_handle_port() already took the port lock */
+		/* serialquark_uart_handle_port() already took the port lock */
 		port_locked = 0;
 	} else if (oops_in_progress) {
 		priv_locked = spin_trylock(&priv->lock);
@@ -1771,8 +1688,6 @@ static int __init quark_console_setup(struct console *co, char *options)
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
-static struct uart_driver quark_uart_driver;
-
 static struct console quark_console = {
 	.name		= QUARK_UART_DRIVER_DEVICE,
 	.write		= quark_console_write,
@@ -1792,31 +1707,29 @@ static struct uart_driver quark_uart_driver = {
 	.owner = THIS_MODULE,
 	.driver_name = KBUILD_MODNAME,
 	.dev_name = QUARK_UART_DRIVER_DEVICE,
-	.major = 0,
-	.minor = 0,
 	.nr = QUARK_UART_NR,
 	.cons = QUARK_CONSOLE,
 };
 
+static int line_no; /* eek! TODO */
+
 static struct x1000_port *quark_uart_init_port(struct pci_dev *pdev,
 					     const struct pci_device_id *id)
 {
 	struct x1000_port *priv;
 	int ret, len;
+	dma_cap_mask_t mask;
 	unsigned char *rxbuf;
 	char name[32];	/* for debugfs file name */
 	struct intel_mid_dma_probe_info * info = NULL;
 
-	dev_info(&pdev->dev,"QUARK UART-DMA (ID: %04x:%04x) pdev->irq %d\n",
+	dev_dbg(&pdev->dev,"QUARK UART-DMA (ID: %04x:%04x) pdev->irq %d\n",
 		pdev->vendor, pdev->device, pdev->irq);
 
 	info = (void*)id->driver_data;
 	dev_info(&pdev->dev,"QUARK UART-DMA : CH %d base %d block len %d per mask %x\n",
 		info->max_chan, info->ch_base, info->block_size, info->pimr_mask);
-#if 0
-	board = &drv_dat[id->driver_data];
-	port_type = board->port_type;
-#endif
+
 	priv = kzalloc(sizeof(struct x1000_port), GFP_KERNEL);
 	if (priv == NULL)
 		goto init_port_alloc_err;
@@ -1825,10 +1738,12 @@ static struct x1000_port *quark_uart_init_port(struct pci_dev *pdev,
 	if (!rxbuf)
 		goto init_port_free_txbuf;
 
+	priv->mid_dma.pdev = pci_dev_get(pdev);
 	pci_set_master(pdev);
 
 	spin_lock_init(&priv->lock);
 
+	/* UART regs */
 	priv->mapbase = pci_resource_start(pdev, 0);
 	len = pci_resource_len(pdev, 0);
 	priv->membase = ioremap_nocache(priv->mapbase, len);
@@ -1837,6 +1752,54 @@ static struct x1000_port *quark_uart_init_port(struct pci_dev *pdev,
 		goto init_port_free_txbuf;
 	}
 
+	/* DMA driver */
+	priv->mid_dma.max_chan = info->max_chan;		/* Max channels */
+	priv->mid_dma.chan_base = info->ch_base;		/* Index start */
+	priv->mid_dma.block_size = info->block_size;		/* MAX DMA block */
+	priv->mid_dma.pimr_mask = info->pimr_mask;		/* Per int regs bool */
+	priv->mid_dma.is_quark = info->is_quark;
+
+	ret = intel_qrk_dma_probe(pdev, &priv->mid_dma);
+	if(ret != 0){
+		dev_err(&pdev->dev, "Unable to init DMA sub-system\n");
+		goto init_port_free_uart_iomem;
+	}
+
+	/* Request DMA channels TODO: move to startup() once debugged on hw */
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	priv->rx_chan = dma_request_channel(mask, intel_qrk_dma_chan_filter, &priv->dmas_rx);
+	if(priv->rx_chan == NULL){
+		dev_err(&pdev->dev, "Unable to hook DMA RX channel\n");
+		goto init_port_free_dma_iomem;
+	};
+	priv->rx_buf_virt = dma_alloc_coherent(&pdev->dev, QUARK_UART_FIFO_LEN,
+				    &priv->rx_buf_dma, GFP_KERNEL);
+	if (priv->rx_buf_virt == NULL){
+		dev_err(&pdev->dev, "Unable to allocate %d bytes for DMA\n",
+			QUARK_UART_FIFO_LEN);
+		goto init_port_free_dma_iomem;
+	}
+
+	priv->dmas_rx.hs_mode = LNW_DMA_HW_HS;
+	priv->dmas_rx.cfg_mode = LNW_DMA_PER_TO_MEM;
+	/* Configure RX */
+
+	priv->tx_chan = dma_request_channel(mask, intel_qrk_dma_chan_filter, &priv->dmas_tx);
+	if(priv->tx_chan == NULL){
+		dev_err(&pdev->dev, "Unable to hook DMA RX channel\n");
+		goto init_port_free_dma_iomem;
+	};
+	priv->dmas_tx.hs_mode = LNW_DMA_HW_HS;
+	priv->dmas_tx.cfg_mode = LNW_DMA_MEM_TO_PER;
+
+	dev_info(&pdev->dev, "using %s for DMA RX %s for DMA TX DMA %s\n",
+			dev_name(&priv->rx_chan->dev->device),
+			dev_name(&priv->tx_chan->dev->device), use_dma ?
+			"enabled" : "disabled");
+
+	/* Setup UART port descriptor */
 	priv->pdev = pdev;
 	priv->tx_empty = 1;
 	priv->rxbuf.buf = rxbuf;
@@ -1852,8 +1815,10 @@ static struct x1000_port *quark_uart_init_port(struct pci_dev *pdev,
 	priv->port.ops = &quark_uart_ops;
 	priv->port.flags = UPF_BOOT_AUTOCONF;
 	priv->port.fifosize = QUARK_UART_FIFO_LEN;
-	priv->port.line = pdev->dev.id;
-	priv->trigger = QUARK_UART_HAL_TRIGGER_M;
+	priv->port.line = line_no; 
+	priv->trigger = QUARK_UART_HAL_TRIGGER_L;
+	priv->use_dma = use_dma;
+	use_dma = 0;
 
 	spin_lock_init(&priv->port.lock);
 	pci_set_drvdata(pdev, priv);
@@ -1862,33 +1827,41 @@ static struct x1000_port *quark_uart_init_port(struct pci_dev *pdev,
 
 	ret = request_irq(pdev->irq, quark_uart_interrupt, IRQF_SHARED,
 			KBUILD_MODNAME, priv);
-#ifdef __QRK_DMA_DEBUG
-	pr_info("%s request_irq %d use_dma %d irq=%d\n", __func__, ret, priv->use_dma, pdev->irq);
-#endif
-	if (ret < 0)
+	if (ret < 0){
+		dev_err(&pdev->dev, "Unable to request irq %d err %d\n",
+			pdev->irq, ret);
 		goto init_port_hal_free;
+	}
 
 #ifdef CONFIG_SERIAL_QUARK_UART_CONSOLE
-	quark_uart_ports[board->line_no] = priv;
+	quark_uart_ports[line_no++] = priv;
 #endif
 	ret = uart_add_one_port(&quark_uart_driver, &priv->port);
 
-	if (ret < 0)
+	if (ret < 0){
+		dev_err(&pdev->dev, "uart_add_one_port fail %d\n", ret);
 		goto init_port_hal_free;
+	}
 
 #ifdef CONFIG_DEBUG_FS
 	snprintf(name, sizeof(name), "uart%d_regs", pdev->dev.id);
 	priv->debugfs = debugfs_create_file(name, S_IFREG | S_IRUGO,
 				NULL, priv, &port_regs_ops);
 #endif
-
+	INIT_WORK(&priv->work, quark_uart_work);
+	init_waitqueue_head(&priv->w_queue);
 	return priv;
 
 init_port_hal_free:
-#ifdef CONFIG_SERIAL_QUARK_UART_CONSOLE
-	quark_uart_ports[board->line_no] = NULL;
-#endif
 	free_page((unsigned long)rxbuf);
+init_port_free_dma_iomem:
+init_port_free_uart_iomem:
+	if (sg_dma_address(&priv->sg_rx))
+		dma_free_coherent(priv->port.dev, priv->port.fifosize,
+			  sg_virt(&priv->sg_rx),
+			  sg_dma_address(&priv->sg_rx));
+
+	iounmap(priv->membase);
 init_port_free_txbuf:
 	kfree(priv);
 init_port_alloc_err:
@@ -1896,13 +1869,31 @@ init_port_alloc_err:
 	return NULL;
 }
 
-static void quark_uart_exit_port(struct x1000_port *priv)
+static void quark_uart_exit_port(struct pci_dev *pdev, struct x1000_port *priv)
 {
 
 #ifdef CONFIG_DEBUG_FS
 	if (priv->debugfs)
 		debugfs_remove(priv->debugfs);
 #endif
+	/* Shutdown DMA */
+	intel_qrk_dma_remove(pdev, &priv->mid_dma);
+
+	/* TODO: move to remove() when h/w proved out */
+	if (priv->tx_chan) {
+		dma_release_channel(priv->tx_chan);
+		priv->tx_chan = NULL;
+	}
+	if (priv->rx_chan) {
+		dma_release_channel(priv->rx_chan);
+		priv->rx_chan = NULL;
+	}
+
+	if (sg_dma_address(&priv->sg_rx))
+		dma_free_coherent(priv->port.dev, priv->port.fifosize,
+				  sg_virt(&priv->sg_rx),
+				  sg_dma_address(&priv->sg_rx));
+
 	free_irq(priv->port.irq, priv);
 	uart_remove_one_port(&quark_uart_driver, &priv->port);
 	pci_set_drvdata(priv->pdev, NULL);
@@ -1918,7 +1909,7 @@ static void quark_uart_pci_remove(struct pci_dev *pdev)
 #ifdef CONFIG_SERIAL_QUARK_UART_CONSOLE
 	quark_uart_ports[priv->port.line] = NULL;
 #endif
-	quark_uart_exit_port(priv);
+	quark_uart_exit_port(pdev, priv);
 	pci_disable_device(pdev);
 	kfree(priv);
 	return;
@@ -1928,6 +1919,10 @@ static int quark_uart_pci_suspend(struct pci_dev *pdev, pm_message_t state)
 {
 	struct x1000_port *priv = pci_get_drvdata(pdev);
 
+	/* Suspend DMA regs */
+	intel_qrk_dma_suspend(&priv->mid_dma);
+
+	/* Suspend UART regs */
 	uart_suspend_port(&quark_uart_driver, &priv->port);
 
 	pci_save_state(pdev);
@@ -1950,8 +1945,12 @@ static int quark_uart_pci_resume(struct pci_dev *pdev)
 		return ret;
 	}
 
+	/* Resume UART regs */
 	uart_resume_port(&quark_uart_driver, &priv->port);
 
+	/* Resume DMA regs */
+	intel_qrk_dma_resume(&priv->mid_dma);
+
 	return 0;
 }
 #else
@@ -1961,7 +1960,7 @@ static int quark_uart_pci_resume(struct pci_dev *pdev)
 
 struct pci_device_id quark_uart_pci_ids[] = {
 	/* channels = 2, offset = 0, block size = FIFO_LEN, pimr = 0 */
-        { PCI_VDEVICE(INTEL, 0x0936), INFO(2, 0, QUARK_UART_FIFO_LEN, 0)},
+        { PCI_VDEVICE(INTEL, 0x0936), INFO(2, 0, QUARK_UART_FIFO_LEN, 0, 1)},
         { 0 }
 };
 
@@ -2030,3 +2029,6 @@ MODULE_DESCRIPTION("Intel QUARK X1000 UART PCI Driver");
 module_param(default_baud, uint, S_IRUGO);
 MODULE_PARM_DESC(default_baud,
                  "Default BAUD for initial driver state and console (default 115200)");
+module_param(use_dma, bool, S_IRUGO);
+MODULE_PARM_DESC(use_dma,
+                 "Use DMA (default true)");
diff --git a/include/linux/intel_mid_dma.h b/include/linux/intel_mid_dma.h
old mode 100644
new mode 100755
index 4e385ea..7bf78f3
--- a/include/linux/intel_mid_dma.h
+++ b/include/linux/intel_mid_dma.h
@@ -172,6 +172,7 @@ struct middma_device {
 	int			block_size;
 	bool			ispci_fn;
 	unsigned int		pimr_mask;
+	unsigned int		is_quark;
 	enum intel_mid_dma_state state;
 };
 
@@ -182,12 +183,14 @@ struct middma_device {
  * @ch_base: offset from register base
  * @block_size: TBD
  * @pimr_mask: indicates if mask registers to be mapped
+ * @is_quark: indicates if this is quark silicon
  */
 struct intel_mid_dma_probe_info {
 	u8 max_chan;
 	u8 ch_base;
 	u16 block_size;
 	u32 pimr_mask;
+	u8 is_quark;
 };
 
 /**
diff --git a/include/linux/platform_data/adc1x8s102.h b/include/linux/platform_data/adc1x8s102.h
new file mode 100644
index 0000000..a32a499
--- /dev/null
+++ b/include/linux/platform_data/adc1x8s102.h
@@ -0,0 +1,30 @@
+/*
+ * ADC1x8S102 SPI ADC driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+
+#ifndef __LINUX_PLATFORM_DATA_ADC1x8S102_H__
+#define __LINUX_PLATFORM_DATA_ADC1x8S102_H__
+
+
+/**
+ * struct adc1x8s102_platform_data - Platform data for the adc1x8s102 ADC driver
+ * @ext_vin: External input voltage range for all voltage input channels
+ *	This is the voltage level of pin VA in millivolts
+ **/
+struct adc1x8s102_platform_data {
+	u16  ext_vin;
+};
+
+#endif /* __LINUX_PLATFORM_DATA_ADC1x8S102_H__ */
diff --git a/include/linux/platform_data/pca9685.h b/include/linux/platform_data/pca9685.h
new file mode 100644
index 0000000..903d30d
--- /dev/null
+++ b/include/linux/platform_data/pca9685.h
@@ -0,0 +1,51 @@
+/*
+ * Platform data for pca9685 driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _PLAT_PCA9685_H_
+#define _PLAT_PCA9685_H_
+
+#define PCA9685_MAXCHAN	16
+#define MODE2_INVRT	(1 << 4)
+#define MODE2_OUTDRV	(1 << 2)
+
+/* PWM channel allocation flags */
+enum {
+	PWM_CH_DISABLED  = 0,
+	PWM_CH_PWM       = 1 << 0,
+	PWM_CH_GPIO      = 1 << 1,
+	/* allow PWM or GPIO */
+	PWM_CH_UNDEFINED = PWM_CH_PWM | PWM_CH_GPIO,
+};
+
+/**
+ * struct pca9685_pdata - Platform data for pca9685 driver
+ * @chan_mapping: Array of channel allocation constrains
+ * @gpio_base: GPIO base
+ * mode2_flags: mode2 register modification flags: INVRT and OUTDRV
+ **/
+struct pca9685_pdata {
+	/* Array of channel allocation constrains */
+	/* add an extra channel for ALL_LED */
+	u8	chan_mapping[PCA9685_MAXCHAN + 1];
+	/* GPIO base */
+	int	gpio_base;
+	/* mode2 flags */
+	u8	en_invrt:1,   /* enable output logic state inverted mode */
+		en_open_dr:1, /* enable if outputs are configured with an
+						 open-drain structure */
+		unused:6;
+};
+
+#endif /* _PLAT_PCA9685_H_ */
-- 
1.7.5.4

