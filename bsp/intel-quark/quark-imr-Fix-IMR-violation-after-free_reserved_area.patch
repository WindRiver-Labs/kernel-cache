From 8cfeb98b70679abd4db50a7c206f110fa23184da Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Tue, 15 Dec 2015 13:04:59 +0800
Subject: [PATCH] quark/imr: Fix IMR violation after free_reserved_area()

.init* sections will be freed after calling free_reserved_area(). However,
IMR7 still settles down at this region and may cause IMR violationif this
region is allocated for I/O access.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/platform/intel-quark/imr.c |   11 +++++------
 1 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/arch/x86/platform/intel-quark/imr.c b/arch/x86/platform/intel-quark/imr.c
index bf18608..1fc9c25 100644
--- a/arch/x86/platform/intel-quark/imr.c
+++ b/arch/x86/platform/intel-quark/imr.c
@@ -629,7 +629,7 @@ static void intel_qrk_imr_lockall(struct imr_device *idev)
 static void __init imr_fixup_memmap(struct imr_device *idev)
 {
 	phys_addr_t base = virt_to_phys(&_text);
-	size_t size = virt_to_phys(&__init_begin) - base;
+	size_t size = virt_to_phys(&__end_rodata) - base;
 	int i;
 	int ret;
 
@@ -637,21 +637,20 @@ static void __init imr_fixup_memmap(struct imr_device *idev)
 	for (i = 0; i < idev->max_imr; i++)
 		imr_clear(i);
 
-
 	/*
 	 * Setup a locked IMR around the physical extent of the kernel
 	 * from the beginning of the .text secton to the end of the
-	 * .init_begin section as one physically contiguous block.
+	 * .rodata section as one physically contiguous block.
 	 */
 	if(imr_enable) {
 		ret = imr_add_range(base, size, IMR_CPU|IMR_ESRAM_FLUSH,
 				IMR_CPU|IMR_ESRAM_FLUSH|IMR_CPU_SNOOP, true);
 		if (ret < 0) {
 			pr_err("unable to setup IMR for kernel: (%p - %p)\n",
-					&_text, &__init_begin);
+					&_text, &__end_rodata);
 		} else {
-			pr_info("protecting kernel .text - .init_begin: %zu KiB (%p - %p)\n",
-					size / 1024, &_text, &__init_begin);
+			pr_info("protecting kernel .text - .rodata: %zu KiB (%p - %p)\n",
+					size / 1024, &_text, &__end_rodata);
 		}
 	}
 
-- 
1.7.5.4

