From 42e7517b71c7007eefe064f7a94832828327fd95 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Wed, 18 Mar 2015 14:37:17 +0800
Subject: [PATCH 10/32] Cypress and PCA9685

This patch is extracted from the previous patch authored by
Josef Ahmad <josef.ahmad@linux.intel.com>

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/mfd/Kconfig                   |   19 +
 drivers/mfd/Makefile                  |    3 +
 drivers/mfd/cy8c9540a.c               |  972 +++++++++++++++++++++++++++++++++
 drivers/mfd/pca9685-core.c            |  283 ++++++++++
 drivers/mfd/pca9685-gpio.c            |  108 ++++
 drivers/mfd/pca9685-pwm.c             |  262 +++++++++
 drivers/mfd/pca9685.h                 |  110 ++++
 include/asm-generic/gpio.h            |    5 +
 include/linux/gpio.h                  |   10 +
 include/linux/gpio/consumer.h         |    8 +
 include/linux/gpio/driver.h           |    4 +
 include/linux/mfd/cy8c9540a.h         |   31 +
 include/linux/platform_data/pca9685.h |   51 ++
 13 files changed, 1866 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mfd/cy8c9540a.c
 create mode 100644 drivers/mfd/pca9685-core.c
 create mode 100644 drivers/mfd/pca9685-gpio.c
 create mode 100644 drivers/mfd/pca9685-pwm.c
 create mode 100644 drivers/mfd/pca9685.h
 create mode 100644 include/linux/mfd/cy8c9540a.h
 create mode 100644 include/linux/platform_data/pca9685.h

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index ed1aa03..083571c 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1034,6 +1034,25 @@ config MFD_TIMBERDALE
 	The timberdale FPGA can be found on the Intel Atom development board
 	for in-vehicle infontainment, called Russellville.
 
+config CY8C9540A
+	tristate "Cypress CY8C9540 GPIO/PWM expander"
+	depends on GPIOLIB
+	depends on I2C
+	depends on PWM
+	help
+	  Select this option to enable support for the CY8C9540 I/O expander.
+	  This device provides 40 interrupt-capable GPIOs, 8 PWMs and an EEPROM.
+
+config MFD_PCA9685
+	tristate "NPX Semiconductors PCA9685 (PWM/GPIO) driver"
+	depends on GPIOLIB && I2C && PWM
+	select REGMAP_I2C
+	help
+	  NPX PCA9685 I2C-bus PWM controller with GPIO output interface support.
+	  The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+	  Additionally, the driver allows the channels to be configured as GPIO
+	  interface (output only).
+
 config MFD_TC3589X
 	bool "Toshiba TC35892 and variants"
 	depends on I2C=y
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index bd957ab..426179f 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -136,6 +136,9 @@ obj-$(CONFIG_MFD_TIMBERDALE)    += timberdale.o
 obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
 obj-$(CONFIG_MFD_KEMPLD)	+= kempld-core.o
 obj-$(CONFIG_MFD_INTEL_QUARK_I2C_GPIO)	+= intel_quark_i2c_gpio.o
+obj-$(CONFIG_CY8C9540A)		+= cy8c9540a.o
+pca9685-objs			:= pca9685-core.o pca9685-gpio.o pca9685-pwm.o
+obj-$(CONFIG_MFD_PCA9685)	+= pca9685.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
 obj-$(CONFIG_LPC_ICH)		+= lpc_ich.o
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
diff --git a/drivers/mfd/cy8c9540a.c b/drivers/mfd/cy8c9540a.c
new file mode 100644
index 0000000..284fc72
--- /dev/null
+++ b/drivers/mfd/cy8c9540a.c
@@ -0,0 +1,972 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+/*
+ * Driver for Cypress CY8C9540A I/O Expander and PWM
+ *
+ * The I/O Expander is I2C-controlled and provides 40 interrupt-capable GPIOs,
+ * 8 PWMs and an EEPROM.
+ * Note the device only supports I2C standard speed 100kHz.
+ *
+ * Based on gpio-adp5588.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/mfd/cy8c9540a.h>
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+
+#define DRV_NAME			"cy8c9540a"
+
+/* CY8C9540A settings */
+#define NGPIO				40
+#define PWM_MAX_PERIOD			0xff
+#define DEVID_FAMILY_CY8C9540A		0x40
+#define DEVID_FAMILY_MASK		0xf0
+#define NPORTS				6
+#define PWM_CLK				0x00	/* see resulting PWM_TCLK_NS */
+#define PWM_TCLK_NS			31250	/* 32kHz */
+
+/* Register offset  */
+#define REG_INPUT_PORT0			0x00
+#define REG_OUTPUT_PORT0		0x08
+#define REG_INTR_STAT_PORT0		0x10
+#define REG_PORT_SELECT			0x18
+#define REG_INTR_MASK			0x19
+#define REG_SELECT_PWM			0x1a
+#define REG_PIN_DIR			0x1c
+#define REG_DRIVE_PULLUP		0x1d
+#define REG_PWM_SELECT			0x28
+#define REG_PWM_CLK			0x29
+#define REG_PWM_PERIOD			0x2a
+#define REG_PWM_PULSE_W			0x2b
+#define REG_ENABLE			0x2d
+#define REG_DEVID_STAT			0x2e
+#define REG_CMD				0x30
+
+/* Commands */
+#define CMD_W_EEPROM_POR		0x03
+#define CMD_R_EEPROM_POR		0x04
+#define CMD_RECONF			0x07
+
+/* Max retries after I2C NAK */
+#define MAX_RETRIES			3
+
+/*
+ * Wait time for device to be ready.
+ * Note the time the part takes depends on the user configuration (mainly on
+ * the number of active interrupts).  The minimum delay here covers the
+ * worst-case scenario.
+ */
+#define SLEEP_US_MIN			4000
+#define SLEEP_US_MAX			4500
+
+/* Command string to store platform POR settings */
+#define POR_CMD_W_OFFS			2
+static u8 por_set[CY8C9540A_POR_SETTINGS_LEN + POR_CMD_W_OFFS] = {
+	[0] = REG_CMD,
+	[1] = CMD_W_EEPROM_POR,
+};
+
+struct cy8c9540a {
+	struct i2c_client *client;
+	struct gpio_chip gpio_chip;
+	struct pwm_chip pwm_chip;
+	struct mutex lock;
+	/* IRQ base stored from platform data */
+	int irq_base;
+	/* protect serialized access to the interrupt controller bus */
+	struct mutex irq_lock;
+	/* cached output registers */
+	u8 outreg_cache[NPORTS];
+	/* cached IRQ mask */
+	u8 irq_mask_cache[NPORTS];
+	/* IRQ mask to be applied */
+	u8 irq_mask[NPORTS];
+	/* Descriptor for raw i2c transactions */
+	struct i2c_msg i2c_segments[2];
+	/* POR settings stored in the EEPROM */
+	u8 por_stored[CY8C9540A_POR_SETTINGS_LEN];
+	/* PWM-to-GPIO mapping (0 == first gpio pin)  */
+	int pwm2gpio_mapping[CY8C9540A_NPWM];
+};
+
+/* Per-port GPIO offset */
+static const u8 cy8c9540a_port_offs[] = {
+	0,
+	8,
+	16,
+	20,
+	28,
+	36,
+};
+
+static inline u8 cypress_get_port(unsigned gpio)
+{
+	u8 i = 0;
+	for (i = 0; i < sizeof(cy8c9540a_port_offs) - 1; i ++) {
+		if (! (gpio / cy8c9540a_port_offs[i + 1]))
+			break;
+	}
+	return i;
+}
+
+static inline u8 cypress_get_offs(unsigned gpio, u8 port)
+{
+	return gpio - cy8c9540a_port_offs[port];
+}
+
+static int cy8c9540a_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
+{
+	s32 ret = 0;
+	u8 port = 0;
+	u8 in_reg = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, gpio_chip);
+	struct i2c_client *client = dev->client;
+
+	port = cypress_get_port(gpio);
+	in_reg = REG_INPUT_PORT0 + port;
+
+	ret = i2c_smbus_read_byte_data(client, in_reg);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't read input port%u\n", in_reg);
+	}
+
+	return !!(ret & BIT(cypress_get_offs(gpio, port)));
+}
+
+static void cy8c9540a_gpio_set_value(struct gpio_chip *chip,
+				   unsigned gpio, int val)
+{
+	s32 ret = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, gpio_chip);
+	struct i2c_client *client = dev->client;
+	u8 port = cypress_get_port(gpio);
+	u8 out_reg = REG_OUTPUT_PORT0 + port;
+
+	mutex_lock(&dev->lock);
+
+	if (val) {
+		dev->outreg_cache[port] |= BIT(cypress_get_offs(gpio, port));
+	} else {
+		dev->outreg_cache[port] &= ~BIT(cypress_get_offs(gpio, port));
+	}
+
+	ret = i2c_smbus_write_byte_data(client, out_reg,
+					dev->outreg_cache[port]);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write output port%u\n", port);
+	}
+
+	mutex_unlock(&dev->lock);
+}
+
+static int cy8c9540a_gpio_set_drive(struct gpio_chip *chip, unsigned gpio,
+					unsigned mode)
+{
+	s32 ret = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, gpio_chip);
+	struct i2c_client *client = dev->client;
+	u8 port = cypress_get_port(gpio);
+	u8 pin = cypress_get_offs(gpio, port);
+	u8 offs = 0;
+	u8 val = 0;
+
+	switch(mode) {
+	case GPIOF_DRIVE_PULLUP:
+		offs = 0x0;
+		break;
+	case GPIOF_DRIVE_STRONG:
+		offs = 0x4;
+		break;
+	case GPIOF_DRIVE_HIZ:
+		offs = 0x6;
+		break;
+	default:
+		/*
+		 * See databook for alternative modes.  This driver won't
+		 * support them though.
+		 */
+		return -EINVAL;
+		break;
+	}
+
+	mutex_lock(&dev->lock);
+
+	ret = i2c_smbus_write_byte_data(client, REG_PORT_SELECT, port);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't select port %u\n", port);
+		goto end;
+	}
+
+	ret = i2c_smbus_read_byte_data(client, REG_DRIVE_PULLUP + offs);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't read pin direction\n");
+		goto end;
+	}
+
+	val = (u8)(ret | BIT(pin));
+
+	ret = i2c_smbus_write_byte_data(client, REG_DRIVE_PULLUP + offs, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't set drive mode port %u\n", port);
+		goto end;
+	}
+
+	ret = 0;
+
+end:
+	mutex_unlock(&dev->lock);
+	return ret;
+}
+
+static int cy8c9540a_gpio_direction(struct gpio_chip *chip, unsigned gpio,
+					int out, int val)
+{
+	s32 ret = 0;
+	u8 pins = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, gpio_chip);
+	struct i2c_client *client = dev->client;
+	u8 port = cypress_get_port(gpio);
+
+	ret = cy8c9540a_gpio_set_drive(chip, gpio, out ?
+				       GPIOF_DRIVE_STRONG : GPIOF_DRIVE_HIZ);
+	if (ret) {
+		return ret;
+	}
+
+	mutex_lock(&dev->lock);
+
+	ret = i2c_smbus_write_byte_data(client, REG_PORT_SELECT, port);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't select port %u\n", port);
+		goto end;
+	}
+
+	ret = i2c_smbus_read_byte_data(client, REG_PIN_DIR);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't read pin direction\n");
+		goto end;
+	}
+
+	pins = (u8)ret & 0xff;
+	if (out) {
+		pins &= ~BIT(cypress_get_offs(gpio, port));
+	} else {
+		pins |= BIT(cypress_get_offs(gpio, port));
+	}
+
+	ret = i2c_smbus_write_byte_data(client, REG_PIN_DIR, pins);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write pin direction\n");
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+	return ret;
+}
+
+static int cy8c9540a_gpio_direction_output(struct gpio_chip *chip,
+					unsigned gpio, int val)
+{
+	return cy8c9540a_gpio_direction(chip, gpio, 1, val);
+}
+
+static int cy8c9540a_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+{
+	return cy8c9540a_gpio_direction(chip, gpio, 0, 0);
+}
+
+static void cy8c9540a_irq_bus_lock(struct irq_data *d)
+{
+	struct cy8c9540a *dev = irq_data_get_irq_chip_data(d);
+	mutex_lock(&dev->irq_lock);
+}
+
+static void cy8c9540a_irq_bus_sync_unlock(struct irq_data *d)
+{
+	struct cy8c9540a *dev = irq_data_get_irq_chip_data(d);
+	struct i2c_client *client = dev->client;
+	int ret = 0;
+	int i = 0;
+
+	for (i = 0; i < NPORTS; i++) {
+		if (dev->irq_mask_cache[i] ^ dev->irq_mask[i]) {
+			dev->irq_mask_cache[i] = dev->irq_mask[i];
+			ret = i2c_smbus_write_byte_data(client,
+					REG_PORT_SELECT, i);
+			if (ret < 0) {
+				dev_err(&client->dev,
+					"can't select port %u\n", i);
+				goto end;
+			}
+
+			ret = i2c_smbus_write_byte_data(client, REG_INTR_MASK,
+					dev->irq_mask[i]);
+			if (ret < 0) {
+				dev_err(&client->dev,
+					"can't write int mask on port %u\n", i);
+				goto end;
+			}
+
+		}
+	}
+
+end:
+	mutex_unlock(&dev->irq_lock);
+}
+
+static void cy8c9540a_irq_mask(struct irq_data *d)
+{
+	struct cy8c9540a *dev = irq_data_get_irq_chip_data(d);
+	unsigned gpio = d->irq - dev->irq_base;
+	u8 port = cypress_get_port(gpio);
+
+	dev->irq_mask[port] |= BIT(cypress_get_offs(gpio, port));
+}
+
+static void cy8c9540a_irq_unmask(struct irq_data *d)
+{
+	struct cy8c9540a *dev = irq_data_get_irq_chip_data(d);
+	unsigned gpio = d->irq - dev->irq_base;
+	u8 port = cypress_get_port(gpio);
+
+	dev->irq_mask[port] &= ~BIT(cypress_get_offs(gpio, port));
+}
+
+static int cy8c9540a_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
+{
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, gpio_chip);
+	return dev->irq_base + gpio;
+}
+
+static int cy8c9540a_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct cy8c9540a *dev = irq_data_get_irq_chip_data(d);
+	int ret = 0;
+
+	if ((type != IRQ_TYPE_EDGE_BOTH)) {
+		dev_err(&dev->client->dev, "irq %d: unsupported type %d\n",
+			d->irq, type);
+		ret = -EINVAL;
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static struct irq_chip cy8c9540a_irq_chip = {
+	.name			= "cy8c9540a-irq",
+	.irq_mask		= cy8c9540a_irq_mask,
+	.irq_unmask		= cy8c9540a_irq_unmask,
+	.irq_bus_lock		= cy8c9540a_irq_bus_lock,
+	.irq_bus_sync_unlock	= cy8c9540a_irq_bus_sync_unlock,
+	.irq_set_type		= cy8c9540a_irq_set_type,
+};
+
+static irqreturn_t cy8c9540a_irq_handler(int irq, void *devid)
+{
+	struct cy8c9540a *dev = devid;
+	u8 stat[NPORTS], pending = 0;
+	unsigned port = 0, gpio = 0, gpio_irq = 0;
+	int ret = 0;
+
+	ret = i2c_smbus_read_i2c_block_data(dev->client, REG_INTR_STAT_PORT0,
+		NPORTS, stat);	/* W1C  */
+	if (ret < 0) {
+		memset(stat, 0, sizeof(stat));
+	}
+
+	ret = IRQ_NONE;
+
+	for (port = 0; port < NPORTS; port ++) {
+		/* Databook doesn't specify if this is a post-mask status
+		   register or not.  Consider it 'raw' for safety.  */
+		mutex_lock(&dev->irq_lock);
+		pending = stat[port] & (~dev->irq_mask[port]);
+		mutex_unlock(&dev->irq_lock);
+
+		while (pending) {
+			ret = IRQ_HANDLED;
+			gpio = __ffs(pending);
+			pending &= ~BIT(gpio);
+			gpio_irq = dev->irq_base + cy8c9540a_port_offs[port]
+				+ gpio;
+			handle_nested_irq(gpio_irq);
+		}
+	}
+
+	return ret;
+}
+
+static int cy8c9540a_irq_setup(struct cy8c9540a *dev)
+{
+	struct i2c_client *client = dev->client;
+	u8 dummy[NPORTS];
+	unsigned gpio = 0;
+	int ret = 0;
+	int i = 0;
+
+	mutex_init(&dev->irq_lock);
+
+	/* Clear interrupt state */
+
+	ret = i2c_smbus_read_i2c_block_data(dev->client, REG_INTR_STAT_PORT0,
+		NPORTS, dummy);	/* W1C  */
+	if (ret < 0) {
+		dev_err(&client->dev, "couldn't clear int status\n");
+		goto err;
+	}
+
+	/* Initialise interrupt mask */
+
+	memset(dev->irq_mask_cache, 0xff, sizeof(dev->irq_mask_cache));
+	memset(dev->irq_mask, 0xff, sizeof(dev->irq_mask));
+	for (i = 0; i < NPORTS; i++) {
+		ret = i2c_smbus_write_byte_data(client, REG_PORT_SELECT, i);
+		if (ret < 0) {
+			dev_err(&client->dev, "can't select port %u\n", i);
+			goto err;
+		}
+
+		ret = i2c_smbus_write_byte_data(client, REG_INTR_MASK,
+				dev->irq_mask[i]);
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"can't write int mask on port %u\n", i);
+			goto err;
+		}
+	}
+
+	/* Allocate IRQ descriptors for Cypress GPIOs and set handler */
+
+	ret = irq_alloc_descs(dev->irq_base, dev->irq_base, NGPIO, 0);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to allocate IRQ numbers\n");
+		goto err;
+	}
+
+	for (gpio = 0; gpio < NGPIO; gpio++) {
+		int irq = gpio + dev->irq_base;
+		irq_set_chip_data(irq, dev);
+		irq_set_chip_and_handler(irq, &cy8c9540a_irq_chip,
+					 handle_edge_irq);
+		irq_set_nested_thread(irq, 1);
+		irq_set_noprobe(irq);
+	}
+
+	ret = request_threaded_irq(client->irq, NULL, cy8c9540a_irq_handler,
+				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT |
+				   IRQF_NO_SUSPEND,
+				   dev_name(&client->dev), dev);
+	if (ret) {
+		dev_err(&client->dev, "failed to request irq %d\n",
+			client->irq);
+		goto err_free_irq_descs;
+	}
+
+	return 0;
+
+err_free_irq_descs:
+	irq_free_descs(dev->irq_base, NGPIO);
+err:
+	mutex_destroy(&dev->irq_lock);
+	return ret;
+}
+
+static void cy8c9540a_irq_teardown(struct cy8c9540a *dev)
+{
+	struct i2c_client *client = dev->client;
+
+	irq_free_descs(dev->irq_base, NGPIO);
+	free_irq(client->irq, dev);
+	mutex_destroy(&dev->irq_lock);
+}
+
+static int cy8c9540a_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			     int duty_ns, int period_ns)
+{
+	int ret = 0;
+	int period = 0, duty = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, pwm_chip);
+	struct i2c_client *client = dev->client;
+
+	if (pwm->pwm >= CY8C9540A_NPWM) {
+		return -EINVAL;
+	}
+
+	period = period_ns / PWM_TCLK_NS;
+	duty = duty_ns / PWM_TCLK_NS;
+
+	/*
+	 * Check period's upper bound.  Note the duty cycle is already sanity
+	 * checked by the PWM framework.
+	 */
+	if (period > PWM_MAX_PERIOD) {
+		dev_err(&client->dev, "period must be within [0-%d]ns\n",
+			PWM_MAX_PERIOD * PWM_TCLK_NS);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+
+	ret = i2c_smbus_write_byte_data(client, REG_PWM_SELECT, (u8)pwm->pwm);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write to REG_PWM_SELECT\n");
+		goto end;
+	}
+
+	ret = i2c_smbus_write_byte_data(client, REG_PWM_PERIOD, (u8)period);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write to REG_PWM_PERIOD\n");
+		goto end;
+	}
+
+	ret = i2c_smbus_write_byte_data(client, REG_PWM_PULSE_W, (u8)duty);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write to REG_PWM_PULSE_W\n");
+		goto end;
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+
+static int cy8c9540a_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	s32 ret = 0;
+	int gpio = 0;
+	int port = 0, pin = 0;
+	u8 out_reg = 0;
+	u8 val = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, pwm_chip);
+	struct i2c_client *client = dev->client;
+
+	if (pwm->pwm >= CY8C9540A_NPWM) {
+		return -EINVAL;
+	}
+
+	gpio = dev->pwm2gpio_mapping[pwm->pwm];
+	port = cypress_get_port(gpio);
+	pin = cypress_get_offs(gpio, port);
+	out_reg = REG_OUTPUT_PORT0 + port;
+
+	/* Set pin as output driving high */
+	ret = cy8c9540a_gpio_direction(&dev->gpio_chip, gpio, 1, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't set pwm%u as output\n", pwm->pwm);
+		return ret;
+	}
+
+	mutex_lock(&dev->lock);
+
+	/* Enable PWM */
+	ret = i2c_smbus_read_byte_data(client, REG_SELECT_PWM);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't read REG_SELECT_PWM\n");
+		goto end;
+	}
+	val = (u8)(ret | BIT((u8)pin));
+	ret = i2c_smbus_write_byte_data(client, REG_SELECT_PWM, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write to SELECT_PWM\n");
+		goto end;
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+
+static void cy8c9540a_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	s32 ret = 0;
+	int gpio = 0;
+	int port = 0, pin = 0;
+	u8 val = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, pwm_chip);
+	struct i2c_client *client = dev->client;
+
+	if (pwm->pwm >= CY8C9540A_NPWM) {
+		return;
+	}
+
+	gpio = dev->pwm2gpio_mapping[pwm->pwm];
+	if (CY8C9540A_PWM_UNUSED == gpio) {
+		dev_err(&client->dev, "pwm%d is unused\n", pwm->pwm);
+		return;
+	}
+
+	port = cypress_get_port(gpio);
+	pin = cypress_get_offs(gpio, port);
+
+	mutex_lock(&dev->lock);
+
+	/* Disable PWM */
+	ret = i2c_smbus_read_byte_data(client, REG_SELECT_PWM);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't read REG_SELECT_PWM\n");
+		goto end;
+	}
+	val = (u8)(ret & ~BIT((u8)pin));
+	ret = i2c_smbus_write_byte_data(client, REG_SELECT_PWM, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't write to SELECT_PWM\n");
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+
+	return;
+}
+
+/*
+ * Some PWMs may be unavailable.  Prevent user from reserving them.
+ */
+static int cy8c9540a_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	int gpio = 0;
+	struct cy8c9540a *dev =
+	    container_of(chip, struct cy8c9540a, pwm_chip);
+	struct i2c_client *client = dev->client;
+
+	if (pwm->pwm >= CY8C9540A_NPWM) {
+		return -EINVAL;
+	}
+
+	gpio = dev->pwm2gpio_mapping[pwm->pwm];
+	if (CY8C9540A_PWM_UNUSED == gpio) {
+		dev_err(&client->dev, "pwm%d unavailable\n", pwm->pwm);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct pwm_ops cy8c9540a_pwm_ops = {
+	.request = cy8c9540a_pwm_request,
+	.config = cy8c9540a_pwm_config,
+	.enable = cy8c9540a_pwm_enable,
+	.disable = cy8c9540a_pwm_disable,
+};
+
+/*
+ * cy8c9540a_set_por_default
+ *
+ * Ensure the expander is using platform-specific POR settings.
+ *
+ * Note SMBUS max transaction length is 32 bytes, so we have to fall back to
+ * raw i2c transfers.
+ */
+static int cy8c9540a_set_por_default(struct cy8c9540a *dev)
+{
+	int ret = 0;
+	struct i2c_client *client = dev->client;
+	struct cy8c9540a_pdata *pdata = client->dev.platform_data;
+	int i = 0;
+	int segments = -1;
+	int crc_index = sizeof(por_set) - 1;
+	u8 reg_cmd_r_por[] = { REG_CMD, CMD_R_EEPROM_POR };
+
+	/* Populate platform POR setting table */
+	memcpy(por_set + POR_CMD_W_OFFS, pdata->por_default,
+	       sizeof(pdata->por_default));
+
+	/* Read POR settings stored in EEPROM */
+	dev->i2c_segments[0].addr	= client->addr;
+	dev->i2c_segments[0].flags	= 0;	/* write */
+	dev->i2c_segments[0].len	= sizeof(reg_cmd_r_por);
+	dev->i2c_segments[0].buf	= reg_cmd_r_por;
+	dev->i2c_segments[1].addr	= client->addr;
+	dev->i2c_segments[1].flags	= I2C_M_RD;
+	dev->i2c_segments[1].len	= sizeof(dev->por_stored);
+	dev->i2c_segments[1].buf	= dev->por_stored;
+	segments = 2;
+	ret = i2c_transfer(client->adapter, dev->i2c_segments, segments);
+	if (segments != ret) {
+		dev_err(&client->dev, "can't read POR settings (ret=%d)\n",
+				ret);
+		goto end;
+	} else {
+		ret = 0;
+	}
+
+	/* Compute CRC for platform-defined POR settings */
+	por_set[crc_index] = 0;
+	for (i = POR_CMD_W_OFFS; i < crc_index; i ++) {
+		por_set[crc_index] ^= por_set[i];
+	}
+
+	/* Compare POR settings with platform-defined ones */
+	for (i = 0; i < sizeof(dev->por_stored); i ++) {
+		if (dev->por_stored[i] != por_set[i + POR_CMD_W_OFFS]) {
+			break;
+		}
+	}
+	if (sizeof(dev->por_stored) == i) {
+		goto end;
+	}
+
+	/* Update POR settings to EEPROM */
+
+	dev_info(&client->dev, "updating EEPROM with platform POR settings\n");
+
+	/* Store default POR settings into EEPROM */
+	dev->i2c_segments[0].addr	= client->addr;
+	dev->i2c_segments[0].flags	= 0;	/* write */
+	dev->i2c_segments[0].len	= sizeof(por_set);
+	dev->i2c_segments[0].buf	= por_set;
+	segments = 1;
+	ret = i2c_transfer(client->adapter, dev->i2c_segments, segments);
+	if (segments != ret) {
+		dev_err(&client->dev, "can't write POR settings (ret=%d)\n",
+				ret);
+		goto end;
+	} else {
+		ret = 0;
+	}
+
+	/* Reconfigure device with newly stored POR settings */
+	for (i = 0; i < MAX_RETRIES; i++) {
+		usleep_range(SLEEP_US_MIN, SLEEP_US_MAX);
+
+		ret = i2c_smbus_write_byte_data(client, REG_CMD, CMD_RECONF);
+		if (0 == ret) {
+			break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_err(&client->dev, "can't reconfigure device\n");
+	}
+
+end:
+	return ret;
+}
+
+/*
+ * cy8c9540a_setup
+ *
+ * Initialise the device with default setup.
+ * No need to roll back if this fails.
+ */
+static int cy8c9540a_setup(struct cy8c9540a *dev)
+{
+	int ret = 0;
+	struct i2c_client *client = dev->client;
+	const u8 eeprom_enable_seq[] = {0x43, 0x4D, 0x53, 0x2};
+
+	/* Test/set platform-specific POR settings */
+	ret = cy8c9540a_set_por_default(dev);
+	if (ret) {
+		dev_err(&client->dev, "can't set POR settings (err=%d)\n", ret);
+		goto end;
+	}
+
+	/* Cache the output registers */
+	ret = i2c_smbus_read_i2c_block_data(dev->client, REG_OUTPUT_PORT0,
+					    sizeof(dev->outreg_cache),
+					    dev->outreg_cache);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't cache output registers\n");
+		goto end;
+	}
+
+	/* Enable the EEPROM */
+	ret = i2c_smbus_write_i2c_block_data(client, REG_ENABLE,
+					     sizeof(eeprom_enable_seq),
+					     eeprom_enable_seq);
+	if (ret < 0) {
+		dev_err(&client->dev, "can't enable EEPROM\n");
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static int cy8c9540a_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct cy8c9540a *dev;
+	struct gpio_chip *gc;
+	struct cy8c9540a_pdata *pdata = client->dev.platform_data;
+	int ret = 0;
+	s32 dev_id = 0;
+
+	if (NULL == pdata) {
+		pr_err("%s: platform data is missing\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C |
+					I2C_FUNC_SMBUS_I2C_BLOCK |
+					I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "i2c adapter doesn't support required "
+			"functionality\n");
+		return -EIO;
+	}
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev == NULL) {
+		dev_err(&client->dev, "failed to alloc memory\n");
+		return -ENOMEM;
+	}
+
+	dev->client = client;
+	dev->irq_base = pdata->irq_base;
+
+	gc = &dev->gpio_chip;
+	gc->direction_input = cy8c9540a_gpio_direction_input;
+	gc->direction_output = cy8c9540a_gpio_direction_output;
+	gc->get = cy8c9540a_gpio_get_value;
+	gc->set = cy8c9540a_gpio_set_value;
+	gc->set_drive = cy8c9540a_gpio_set_drive;
+
+	gc->can_sleep = 1;
+
+	gc->base = pdata->gpio_base;
+	gc->ngpio = NGPIO;
+	gc->label = client->name;
+	gc->owner = THIS_MODULE;
+	gc->to_irq = cy8c9540a_gpio_to_irq;
+
+	mutex_init(&dev->lock);
+
+	/* Whoami */
+	dev_id = i2c_smbus_read_byte_data(client, REG_DEVID_STAT);
+	if (dev_id < 0) {
+		dev_err(&client->dev, "can't read device ID\n");
+		ret = dev_id;
+		goto err;
+	}
+	dev_info(&client->dev, "dev_id=0x%x\n", dev_id & 0xff);
+	if (DEVID_FAMILY_CY8C9540A != (dev_id & DEVID_FAMILY_MASK)) {
+		dev_err(&client->dev, "unknown/unsupported dev_id 0x%x\n",
+			dev_id & 0xff);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	ret = cy8c9540a_setup(dev);
+	if (ret) {
+		goto err;
+	}
+
+	ret = cy8c9540a_irq_setup(dev);
+	if (ret) {
+		goto err;
+	}
+	ret = gpiochip_add(&dev->gpio_chip);
+	if (ret) {
+		dev_err(&client->dev, "gpiochip_add failed %d\n", ret);
+		goto err_irq;
+	}
+
+	dev->pwm_chip.dev = &client->dev;
+	dev->pwm_chip.ops = &cy8c9540a_pwm_ops;
+	dev->pwm_chip.base = pdata->pwm_base;
+	dev->pwm_chip.npwm = CY8C9540A_NPWM;
+
+	/* Populate platform-specific PWM-to-GPIO mapping table */
+	memcpy(dev->pwm2gpio_mapping, pdata->pwm2gpio_mapping,
+			sizeof(pdata->pwm2gpio_mapping));
+
+	ret = pwmchip_add(&dev->pwm_chip);
+	if (ret) {
+		dev_err(&client->dev, "pwmchip_add failed %d\n", ret);
+		goto err_gpiochip;
+	}
+
+	i2c_set_clientdata(client, dev);
+
+	return 0;
+
+err_gpiochip:
+	if(gpiochip_remove(&dev->gpio_chip))
+		dev_warn(&client->dev, "gpiochip_remove failed\n");
+err_irq:
+	cy8c9540a_irq_teardown(dev);
+err:
+	mutex_destroy(&dev->lock);
+	kfree(dev);
+
+	return ret;
+}
+
+static int cy8c9540a_remove(struct i2c_client *client)
+{
+	struct cy8c9540a *dev = i2c_get_clientdata(client);
+	int ret = 0;
+	int err = 0;
+
+	ret = pwmchip_remove(&dev->pwm_chip);
+	if (ret < 0) {
+		dev_err(&client->dev, "pwmchip_remove failed %d\n", ret);
+		err = ret;
+	}
+
+	ret = gpiochip_remove(&dev->gpio_chip);
+	if (ret) {
+		dev_err(&client->dev, "gpiochip_remove failed %d\n", ret);
+		err = ret;
+	}
+
+	cy8c9540a_irq_teardown(dev);
+
+	mutex_destroy(&dev->lock);
+	kfree(dev);
+
+	return err;
+}
+
+static const struct i2c_device_id cy8c9540a_id[] = {
+	{DRV_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, cy8c9540a_id);
+
+static struct i2c_driver cy8c9540a_driver = {
+	.driver = {
+		   .name = DRV_NAME,
+		   },
+	.probe = cy8c9540a_probe,
+	.remove = cy8c9540a_remove,
+	.id_table = cy8c9540a_id,
+};
+
+module_i2c_driver(cy8c9540a_driver);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@linux.intel.com>");
+MODULE_DESCRIPTION("GPIO/PWM driver for CY8C9540A I/O expander");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685-core.c b/drivers/mfd/pca9685-core.c
new file mode 100644
index 0000000..1c20952
--- /dev/null
+++ b/drivers/mfd/pca9685-core.c
@@ -0,0 +1,283 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include "pca9685.h"
+
+static unsigned int en_invrt;
+module_param(en_invrt, uint, 0);
+MODULE_PARM_DESC(en_invrt, "Enable output logic state inverted mode");
+
+static unsigned int en_open_dr;
+module_param(en_open_dr, uint, 0);
+MODULE_PARM_DESC(en_open_dr,
+	"The outputs are configured with an open-drain structure");
+
+static int gpio_base = -1; /*  requests dynamic ID allocation */
+module_param(gpio_base, int, 0);
+MODULE_PARM_DESC(gpio_base, "GPIO base number");
+
+static unsigned int pwm_period = PWM_PERIOD_DEF; /* PWM clock period */
+module_param(pwm_period, uint, 0);
+MODULE_PARM_DESC(pwm_period, "PWM clock period (nanoseconds)");
+
+static bool pca9685_register_volatile(struct device *dev, unsigned int reg)
+{
+	if (unlikely(reg == PCA9685_MODE1))
+		return true;
+	else
+		return false;
+}
+
+static struct regmap_config pca9685_regmap_i2c_config = {
+	.reg_bits     = 8,
+	.val_bits     = 8,
+	.max_register = PCA9685_NUMREGS,
+	.volatile_reg = pca9685_register_volatile,
+	.cache_type   = REGCACHE_RBTREE,
+};
+
+ssize_t pca9685_pwm_period_sysfs_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct pca9685 *pca = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", pca->pwm_period);
+}
+
+ssize_t pca9685_pwm_period_sysfs_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct pca9685 *pca = dev_get_drvdata(dev);
+	unsigned period_ns;
+	int ret;
+
+	sscanf(buf, "%u", &period_ns);
+
+	ret = pca9685_update_prescale(pca, period_ns, true);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+/* Sysfs attribute to allow PWM clock period adjustment at run-time
+ * NOTE: All active channels will switch off momentarily if the
+ * PWM clock period is changed
+ */
+static DEVICE_ATTR(pwm_period, S_IWUSR | S_IRUGO,
+		   pca9685_pwm_period_sysfs_show,
+		   pca9685_pwm_period_sysfs_store);
+
+static int pca9685_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct pca9685_pdata *pdata;
+	struct pca9685 *pca;
+	int ret;
+	int mode2;
+
+	pca = devm_kzalloc(&client->dev, sizeof(*pca), GFP_KERNEL);
+	if (unlikely(!pca))
+		return -ENOMEM;
+
+	pdata = client->dev.platform_data;
+	if (likely(pdata)) {
+		memcpy(pca->chan_mapping, pdata->chan_mapping,
+				ARRAY_SIZE(pca->chan_mapping));
+		pca->gpio_base = pdata->gpio_base;
+		en_invrt       = pdata->en_invrt;
+		en_open_dr     = pdata->en_open_dr;
+	} else {
+		dev_warn(&client->dev,
+			 "Platform data not provided."
+			 "Using default or mod params configuration.\n");
+		pca->gpio_base = gpio_base;
+		memset(pca->chan_mapping, PWM_CH_UNDEFINED,
+				ARRAY_SIZE(pca->chan_mapping));
+	}
+
+	if (unlikely(!i2c_check_functionality(client->adapter,
+					I2C_FUNC_I2C |
+					I2C_FUNC_SMBUS_BYTE_DATA))) {
+		dev_err(&client->dev,
+				"i2c adapter doesn't support required functionality\n");
+		return -EIO;
+	}
+
+	pca->regmap = devm_regmap_init_i2c(client, &pca9685_regmap_i2c_config);
+	if (IS_ERR(pca->regmap)) {
+		ret = PTR_ERR(pca->regmap);
+		dev_err(&client->dev, "Failed to initialize register map: %d\n",
+			ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, pca);
+
+	/* registration of GPIO chip */
+	pca->gpio_chip.label     = "pca9685-gpio";
+	pca->gpio_chip.owner     = THIS_MODULE;
+	pca->gpio_chip.set       = pca9685_gpio_set;
+	pca->gpio_chip.get       = pca9685_gpio_get;
+	pca->gpio_chip.can_sleep = 1;
+	pca->gpio_chip.ngpio     = PCA9685_MAXCHAN;
+	pca->gpio_chip.base      = pca->gpio_base;
+	pca->gpio_chip.request   = pca9685_gpio_request;
+	pca->gpio_chip.free      = pca9685_gpio_free;
+
+	mutex_init(&pca->lock);
+
+	ret = gpiochip_add(&pca->gpio_chip);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "Could not register gpiochip, %d\n", ret);
+		goto err;
+	}
+
+	/* configure initial PWM settings */
+	ret = pca9685_init_pwm_regs(pca, pwm_period);
+	if (ret) {
+		pr_err("Failed to initialize PWM registers\n");
+		goto err_gpiochip;
+	}
+
+	/* registration of PWM chip */
+
+	regmap_read(pca->regmap, PCA9685_MODE2, &mode2);
+
+	/* update mode2 register */
+	if (en_invrt)
+		mode2 |= MODE2_INVRT;
+	else
+		mode2 &= ~MODE2_INVRT;
+
+	if (en_open_dr)
+		mode2 &= ~MODE2_OUTDRV;
+	else
+		mode2 |= MODE2_OUTDRV;
+
+	regmap_write(pca->regmap, PCA9685_MODE2, mode2);
+
+	pca->pwm_chip.ops  = &pca9685_pwm_ops;
+	/* add an extra channel for ALL_LED */
+	pca->pwm_chip.npwm = PCA9685_MAXCHAN + 1;
+	pca->pwm_chip.dev  = &client->dev;
+	pca->pwm_chip.base = -1;
+
+	ret = pwmchip_add(&pca->pwm_chip);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "pwmchip_add failed %d\n", ret);
+		goto err_gpiochip;
+	}
+
+	/* Also create a sysfs interface, providing a cmd line config option */
+	ret = sysfs_create_file(&client->dev.kobj, &dev_attr_pwm_period.attr);
+	if (unlikely(ret < 0)) {
+		dev_err(&client->dev, "sysfs_create_file failed %d\n", ret);
+		goto err_pwmchip;
+	}
+
+	return ret;
+
+err_pwmchip:
+	if (unlikely(pwmchip_remove(&pca->pwm_chip)))
+		dev_warn(&client->dev, "%s failed\n", "pwmchip_remove()");
+
+err_gpiochip:
+	if (unlikely(gpiochip_remove(&pca->gpio_chip)))
+		dev_warn(&client->dev, "%s failed\n", "gpiochip_remove()");
+err:
+	mutex_destroy(&pca->lock);
+
+	return ret;
+}
+
+static int pca9685_remove(struct i2c_client *client)
+{
+	struct pca9685 *pca = i2c_get_clientdata(client);
+	int ret;
+
+	regmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,
+			MODE1_SLEEP);
+
+	ret = gpiochip_remove(&pca->gpio_chip);
+	if (unlikely(ret))
+		dev_err(&client->dev, "%s failed, %d\n",
+				"gpiochip_remove()", ret);
+
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_pwm_period.attr);
+
+	ret = pwmchip_remove(&pca->pwm_chip);
+	if (unlikely(ret))
+		dev_err(&client->dev, "%s failed, %d\n",
+				"pwmchip_remove()", ret);
+
+	mutex_destroy(&pca->lock);
+
+	return ret;
+}
+
+static const struct i2c_device_id pca9685_id[] = {
+	{ "pca9685", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, pca9685_id);
+
+static struct i2c_driver pca9685_i2c_driver = {
+	.driver = {
+		.name  = "mfd-pca9685",
+		.owner = THIS_MODULE,
+	},
+	.probe     = pca9685_probe,
+	.remove    = pca9685_remove,
+	.id_table  = pca9685_id,
+};
+
+static int __init pca9685_init(void)
+{
+	if (unlikely((pwm_period < PWM_PERIOD_MIN) ||
+		     (PWM_PERIOD_MAX < pwm_period))) {
+		pr_err("Invalid PWM period specified (valid range: %d-%d)\n",
+		       PWM_PERIOD_MIN, PWM_PERIOD_MAX);
+		return -EINVAL;
+	}
+
+	return i2c_add_driver(&pca9685_i2c_driver);
+}
+/* register after i2c postcore initcall */
+subsys_initcall(pca9685_init);
+
+static void __exit pca9685_exit(void)
+{
+	i2c_del_driver(&pca9685_i2c_driver);
+}
+module_exit(pca9685_exit);
+
+MODULE_AUTHOR("Wojciech Ziemba <wojciech.ziemba@emutex.com>");
+MODULE_DESCRIPTION("NPX Semiconductors PCA9685 (PWM/GPIO) driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685-gpio.c b/drivers/mfd/pca9685-gpio.c
new file mode 100644
index 0000000..ed348af
--- /dev/null
+++ b/drivers/mfd/pca9685-gpio.c
@@ -0,0 +1,108 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/pwm.h>
+#include <linux/regmap.h>
+
+#include "pca9685.h"
+
+static inline struct pca9685 *gpio_to_pca(struct gpio_chip *gpio_chip)
+{
+	return container_of(gpio_chip, struct pca9685, gpio_chip);
+}
+
+static inline int is_gpio_allowed(const struct pca9685 *pca, unsigned channel)
+{
+	return pca->chan_mapping[channel] & PWM_CH_GPIO;
+}
+
+int pca9685_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+	struct pwm_device *pwm;
+	int ret = 0;
+	pca = gpio_to_pca(chip);
+
+	/* validate channel constrains */
+	if (!is_gpio_allowed(pca, offset))
+		return -ENODEV;
+
+	/* return busy if channel is already allocated for pwm */
+	pwm = &pca->pwm_chip.pwms[offset];
+	if (test_bit(PWMF_REQUESTED, &pwm->flags))
+		return -EBUSY;
+
+	/* clear the on counter */
+	regmap_write(pca->regmap, LED_N_ON_L(offset), 0x0);
+	regmap_write(pca->regmap, LED_N_ON_H(offset), 0x0);
+
+	/* clear the off counter */
+	regmap_write(pca->regmap, LED_N_OFF_L(offset), 0x0);
+	ret = regmap_write(pca->regmap, LED_N_OFF_H(offset), 0x0);
+
+	clear_sleep_bit(pca);
+
+	return ret;
+}
+
+void pca9685_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+
+	pca = gpio_to_pca(chip);
+
+	/* clear the on counter reg */
+	regmap_write(pca->regmap, LED_N_ON_L(offset), 0x0);
+	regmap_write(pca->regmap, LED_N_ON_H(offset), 0x0);
+
+	set_sleep_bit(pca);
+
+	return;
+}
+
+void pca9685_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct pca9685 *pca;
+
+	pca = gpio_to_pca(chip);
+
+	/* set the full-on bit */
+	regmap_write(pca->regmap,  LED_N_ON_H(offset), (value << 4) & LED_FULL);
+
+	return;
+}
+
+int pca9685_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct pca9685 *pca;
+	unsigned int val;
+
+	pca = gpio_to_pca(chip);
+
+	/* read the full-on bit */
+	regmap_read(pca->regmap, LED_N_ON_H(offset), &val);
+
+	return !!val;
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685-pwm.c b/drivers/mfd/pca9685-pwm.c
new file mode 100644
index 0000000..0c05263
--- /dev/null
+++ b/drivers/mfd/pca9685-pwm.c
@@ -0,0 +1,262 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include "pca9685.h"
+
+static inline struct pca9685 *pwm_to_pca(struct pwm_chip *pwm_chip)
+{
+	return container_of(pwm_chip, struct pca9685, pwm_chip);
+}
+
+static inline int period_ns_to_prescale(unsigned period_ns)
+{
+	return (DIV_ROUND_CLOSEST(OSC_CLK_MHZ * period_ns,
+			SAMPLE_RES * 1000)) - 1;
+}
+
+static inline int is_pwm_allowed(const struct pca9685 *pca, unsigned channel)
+{
+	return pca->chan_mapping[channel] & PWM_CH_PWM;
+}
+
+int pca9685_update_prescale(struct pca9685 *pca, unsigned period_ns,
+			    bool reconfigure_channels)
+{
+	int pre_scale, i;
+	struct pwm_device *pwm;
+	unsigned long long duty_scale;
+	unsigned long long new_duty_ns;
+
+	if (unlikely((period_ns < PWM_PERIOD_MIN) ||
+		     (PWM_PERIOD_MAX < period_ns))) {
+		pr_err("Invalid PWM period specified (valid range: %d-%d)\n",
+		       PWM_PERIOD_MIN, PWM_PERIOD_MAX);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pca->lock);
+
+	/* update pre_scale to the closest period */
+	pre_scale = period_ns_to_prescale(period_ns);
+	/* ensure sleep-mode bit is set
+	 * NOTE: All active channels will switch off for at least 500 usecs
+	 */
+	regmap_update_bits(pca->regmap, PCA9685_MODE1,
+			   MODE1_SLEEP, MODE1_SLEEP);
+	regmap_write(pca->regmap, PCA9685_PRESCALE, pre_scale);
+	/* clear sleep mode flag if at least 1 channel is active */
+	if (pca->active_cnt > 0) {
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				   MODE1_SLEEP, 0x0);
+		usleep_range(MODE1_RESTART_DELAY, MODE1_RESTART_DELAY * 2);
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				   MODE1_RESTART, MODE1_RESTART);
+	}
+
+	if (reconfigure_channels) {
+		for (i = 0; i < pca->pwm_chip.npwm; i++) {
+			pwm = &pca->pwm_chip.pwms[i];
+			pwm->period = period_ns;
+			if (pwm->duty_cycle > 0) {
+				/* Scale the rise time to maintain duty cycle */
+				duty_scale = period_ns;
+				duty_scale *= 1000000;
+				do_div(duty_scale, pca->pwm_period);
+				new_duty_ns = duty_scale * pwm->duty_cycle;
+				do_div(new_duty_ns, 1000000);
+				/* Update the duty_cycle */
+				pwm_config(pwm, (int)new_duty_ns, pwm->period);
+			}
+		}
+	}
+	pca->pwm_period = period_ns;
+
+	mutex_unlock(&pca->lock);
+	return 0;
+}
+
+int pca9685_init_pwm_regs(struct pca9685 *pca, unsigned period_ns)
+{
+	int ret, chan;
+
+	/* set MODE1_SLEEP */
+	ret = regmap_update_bits(pca->regmap, PCA9685_MODE1,
+					MODE1_SLEEP, MODE1_SLEEP);
+	if (unlikely(ret < 0))
+		return ret;
+
+	/* configure the initial PWM clock period */
+	ret = pca9685_update_prescale(pca, period_ns, false);
+	if (unlikely(ret < 0))
+		return ret;
+
+	/* reset PWM channel registers to power-on default values */
+	for (chan = 0; chan < PCA9685_MAXCHAN; chan++) {
+		ret = regmap_write(pca->regmap, LED_N_ON_L(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_ON_H(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_OFF_L(chan), 0);
+		if (unlikely(ret < 0))
+			return ret;
+		ret = regmap_write(pca->regmap, LED_N_OFF_H(chan), LED_FULL);
+		if (unlikely(ret < 0))
+			return ret;
+	}
+	/* reset ALL_LED registers to power-on default values */
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_ON_L, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_ON_H, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_OFF_L, 0);
+	if (unlikely(ret < 0))
+		return ret;
+	ret = regmap_write(pca->regmap, PCA9685_ALL_LED_OFF_H, LED_FULL);
+	if (unlikely(ret < 0))
+		return ret;
+
+	return ret;
+}
+
+static int pca9685_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+				int duty_ns, int period_ns)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+	unsigned long long duty;
+	unsigned int	reg_on_h,
+			reg_off_l,
+			reg_off_h;
+	int full_off;
+
+	/* Changing PWM period for a single channel at run-time not allowed.
+	 * The PCA9685 PWM clock is shared across all PWM channels
+	 */
+	if (unlikely(period_ns != pwm->period))
+		return -EPERM;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN)) {
+		reg_on_h  = PCA9685_ALL_LED_ON_H;
+		reg_off_l = PCA9685_ALL_LED_OFF_L;
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	} else {
+		reg_on_h  = LED_N_ON_H(pwm->hwpwm);
+		reg_off_l = LED_N_OFF_L(pwm->hwpwm);
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+	}
+
+	duty = SAMPLE_RES * (unsigned long long)duty_ns;
+	duty = DIV_ROUND_UP_ULL(duty, period_ns);
+
+	if (duty >= SAMPLE_RES) /* set the LED_FULL bit */
+		return regmap_write(pca->regmap, reg_on_h, LED_FULL);
+	else /* clear the LED_FULL bit */
+		regmap_write(pca->regmap, reg_on_h, 0x00);
+
+	full_off = !test_bit(PWMF_ENABLED, &pwm->flags) << 4;
+
+	regmap_write(pca->regmap, reg_off_l, (int)duty & 0xff);
+
+	return regmap_write(pca->regmap, reg_off_h,
+			((int)duty >> 8 | full_off) & 0x1f);
+}
+
+static int pca9685_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+	int ret;
+
+	unsigned int reg_off_h;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN))
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	else
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+
+	/* clear the full-off bit */
+	ret = regmap_update_bits(pca->regmap, reg_off_h, LED_FULL, 0x0);
+
+	clear_sleep_bit(pca);
+
+	return ret;
+}
+
+static void pca9685_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca = pwm_to_pca(chip);
+
+	unsigned int reg_off_h;
+
+	if (unlikely(pwm->hwpwm >= PCA9685_MAXCHAN))
+		reg_off_h = PCA9685_ALL_LED_OFF_H;
+	else
+		reg_off_h = LED_N_OFF_H(pwm->hwpwm);
+
+	/* set the LED_OFF counter. */
+	regmap_update_bits(pca->regmap, reg_off_h, LED_FULL, LED_FULL);
+
+	set_sleep_bit(pca);
+
+	return;
+}
+
+static int pca9685_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct pca9685 *pca;
+	struct gpio_chip *gpio_chip;
+	unsigned channel = pwm->hwpwm;
+
+	pca = pwm_to_pca(chip);
+
+	/* validate channel constrains */
+	if (!is_pwm_allowed(pca, channel))
+		return -ENODEV;
+
+	/* return busy if channel is already allocated for gpio */
+	gpio_chip = &pca->gpio_chip;
+
+	if ((channel < PCA9685_MAXCHAN) &&
+		(gpiochip_is_requested(gpio_chip, channel)))
+			return -EBUSY;
+
+	pwm->period = pca->pwm_period;
+
+	return 0;
+}
+
+const struct pwm_ops pca9685_pwm_ops = {
+	.enable  = pca9685_pwm_enable,
+	.disable = pca9685_pwm_disable,
+	.config  = pca9685_pwm_config,
+	.request = pca9685_pwm_request,
+	.owner   = THIS_MODULE,
+};
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/pca9685.h b/drivers/mfd/pca9685.h
new file mode 100644
index 0000000..d678d30
--- /dev/null
+++ b/drivers/mfd/pca9685.h
@@ -0,0 +1,110 @@
+/*
+ * Driver for NPX PCA9685 I2C-bus PWM controller with GPIO output interface
+ * support.
+ *
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The I2C-bus LED controller provides 16-channel, 12-bit PWM Fm+.
+ * Additionally, the driver allows the channels to be configured as GPIO
+ * interface (output only).
+ */
+
+#ifndef __LINUX_MFD_PCA9685_H
+#define __LINUX_MFD_PCA9685_H
+
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/pwm.h>
+#include <linux/platform_data/pca9685.h>
+
+#define PCA9685_MODE1		0x00
+#define PCA9685_MODE2		0x01
+#define PCA9685_SUBADDR1	0x02
+#define PCA9685_SUBADDR2	0x03
+#define PCA9685_SUBADDR3	0x04
+#define PCA9685_LEDX_ON_L	0x06
+#define PCA9685_LEDX_ON_H	0x07
+#define PCA9685_LEDX_OFF_L	0x08
+#define PCA9685_LEDX_OFF_H	0x09
+
+#define PCA9685_ALL_LED_ON_L	0xFA
+#define PCA9685_ALL_LED_ON_H	0xFB
+#define PCA9685_ALL_LED_OFF_L	0xFC
+#define PCA9685_ALL_LED_OFF_H	0xFD
+#define PCA9685_PRESCALE	0xFE
+
+#define PCA9685_NUMREGS		0xFF
+
+#define LED_FULL		(1 << 4)
+#define MODE1_SLEEP		(1 << 4)
+#define MODE1_RESTART		(1 << 7)
+
+#define MODE1_RESTART_DELAY	500
+
+#define LED_N_ON_H(N)	(PCA9685_LEDX_ON_H +  (4 * (N)))
+#define LED_N_ON_L(N)	(PCA9685_LEDX_ON_L +  (4 * (N)))
+#define LED_N_OFF_H(N)	(PCA9685_LEDX_OFF_H + (4 * (N)))
+#define LED_N_OFF_L(N)	(PCA9685_LEDX_OFF_L + (4 * (N)))
+
+#define OSC_CLK_MHZ		      25 /* 25 MHz */
+#define SAMPLE_RES		    4096 /* 12 bits */
+#define PWM_PERIOD_MIN		  666666 /* ~1525 Hz */
+#define PWM_PERIOD_MAX		41666666 /* 24 Hz */
+#define PWM_PERIOD_DEF		 5000000 /* default 200 Hz */
+
+struct pca9685 {
+	struct gpio_chip	gpio_chip;
+	struct pwm_chip		pwm_chip;
+	struct regmap		*regmap;
+	struct mutex		lock; /* mutual exclusion semaphore */
+	/* Array of channel allocation constrains */
+	/* add an extra channel for ALL_LED */
+	u8	chan_mapping[PCA9685_MAXCHAN + 1];
+	int	gpio_base;
+	int	active_cnt;
+	int	pwm_exported_cnt;
+	int	pwm_period;
+};
+
+extern const struct pwm_ops pca9685_pwm_ops;
+
+int  pca9685_gpio_request(struct gpio_chip *chip, unsigned offset);
+void pca9685_gpio_free(struct gpio_chip *chip, unsigned offset);
+void pca9685_gpio_set(struct gpio_chip *chip, unsigned offset, int value);
+int  pca9685_gpio_get(struct gpio_chip *chip, unsigned offset);
+
+int pca9685_init_pwm_regs(struct pca9685 *pca, unsigned period_ns);
+int pca9685_update_prescale(struct pca9685 *pca, unsigned period_ns,
+			    bool reconfigure_channels);
+
+static inline void set_sleep_bit(struct pca9685 *pca)
+{
+	mutex_lock(&pca->lock);
+	/* set sleep mode flag if no more active LED channel*/
+	if (--pca->active_cnt == 0)
+		regmap_update_bits(pca->regmap, PCA9685_MODE1, MODE1_SLEEP,
+				MODE1_SLEEP);
+	mutex_unlock(&pca->lock);
+}
+
+static inline void clear_sleep_bit(struct pca9685 *pca)
+{
+	mutex_lock(&pca->lock);
+	/* clear sleep mode flag if at least 1 LED channel is active */
+	if (pca->active_cnt++ == 0)
+		regmap_update_bits(pca->regmap, PCA9685_MODE1,
+				MODE1_SLEEP, 0x0);
+
+	mutex_unlock(&pca->lock);
+}
+
+#endif	/* __LINUX_MFD_PCA9685_H */
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index 39a1d06..0fbdbd5 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -194,6 +194,11 @@ static inline int gpio_cansleep(unsigned gpio)
 	return 0;
 }
 
+static inline int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	return gpiod_set_drive(gpio_to_desc(gpio), mode);
+}
+
 static inline int gpio_get_value_cansleep(unsigned gpio)
 {
 	might_sleep();
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index b581b13..cf947fe 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -30,6 +30,11 @@
 #define GPIOF_EXPORT_DIR_FIXED	(GPIOF_EXPORT)
 #define GPIOF_EXPORT_DIR_CHANGEABLE (GPIOF_EXPORT | GPIOF_EXPORT_CHANGEABLE)
 
+#define GPIOF_DRIVE_PULLUP	(1 << 6)
+#define GPIOF_DRIVE_PULLDOWN	(1 << 7)
+#define GPIOF_DRIVE_STRONG	(1 << 8)
+#define GPIOF_DRIVE_HIZ		(1 << 9)
+
 /**
  * struct gpio - a structure describing a GPIO with configuration
  * @gpio:	the GPIO number
@@ -148,6 +153,11 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 	return -ENOSYS;
 }
 
+static inline int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	return -ENOSYS;
+}
+
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h
index 6837706..c89a1e1 100644
--- a/include/linux/gpio/consumer.h
+++ b/include/linux/gpio/consumer.h
@@ -111,6 +111,7 @@ int gpiod_get_raw_value_cansleep(const struct gpio_desc *desc);
 void gpiod_set_raw_value_cansleep(struct gpio_desc *desc, int value);
 
 int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce);
+int gpiod_set_drive(struct gpio_desc *desc, unsigned mode);
 
 int gpiod_is_active_low(const struct gpio_desc *desc);
 int gpiod_cansleep(const struct gpio_desc *desc);
@@ -271,6 +272,13 @@ static inline int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce)
 	return -ENOSYS;
 }
 
+static inline int gpiod_set_drive(struct gpio_desc *desc, unsigned mode)
+{
+	/* GPIO can never have been requested */
+	WARN_ON(1);
+	return -ENOSYS;
+}
+
 static inline int gpiod_is_active_low(const struct gpio_desc *desc)
 {
 	/* GPIO can never have been requested */
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index df749d7..939a399 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -34,6 +34,7 @@ struct seq_file;
  * @set: assigns output value for signal "offset"
  * @set_debounce: optional hook for setting debounce time for specified gpio in
  *      interrupt triggered gpio chips
+ * @set_drive: option hook for setting the drive signal for "offset"
  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
  *	implementation may not sleep
  * @dbg_show: optional routine to show contents in debugfs; default code
@@ -92,6 +93,9 @@ struct gpio_chip {
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset,
 						unsigned debounce);
+	int			(*set_drive)(struct gpio_chip *chip,
+						unsigned offset,
+						unsigned mode);
 
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);
diff --git a/include/linux/mfd/cy8c9540a.h b/include/linux/mfd/cy8c9540a.h
new file mode 100644
index 0000000..1334d4e
--- /dev/null
+++ b/include/linux/mfd/cy8c9540a.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef LINUX_CY8C9540A_PDATA_H
+#define LINUX_CY8C9540A_PDATA_H
+
+#include <linux/types.h>
+
+#define CY8C9540A_POR_SETTINGS_LEN		147
+#define CY8C9540A_NPWM				8
+#define CY8C9540A_PWM_UNUSED			-1
+
+struct cy8c9540a_pdata {
+	u8 por_default[CY8C9540A_POR_SETTINGS_LEN];
+	int pwm2gpio_mapping[CY8C9540A_NPWM];
+	int gpio_base;
+	int pwm_base;
+	int irq_base;
+};
+
+#endif
diff --git a/include/linux/platform_data/pca9685.h b/include/linux/platform_data/pca9685.h
new file mode 100644
index 0000000..dbb83f7
--- /dev/null
+++ b/include/linux/platform_data/pca9685.h
@@ -0,0 +1,51 @@
+/*
+ * Platform data for pca9685 driver
+ *
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _PLAT_PCA9685_H_
+#define _PLAT_PCA9685_H_
+
+#define PCA9685_MAXCHAN	16
+#define MODE2_INVRT	(1 << 4)
+#define MODE2_OUTDRV	(1 << 2)
+
+/* PWM channel allocation flags */
+enum {
+	PWM_CH_DISABLED  = 0,
+	PWM_CH_PWM       = 1 << 0,
+	PWM_CH_GPIO      = 1 << 1,
+	/* allow PWM or GPIO */
+	PWM_CH_UNDEFINED = PWM_CH_PWM | PWM_CH_GPIO,
+};
+
+/**
+ * struct pca9685_pdata - Platform data for pca9685 driver
+ * @chan_mapping: Array of channel allocation constrains
+ * @gpio_base: GPIO base
+ * mode2_flags: mode2 register modification flags: INVRT and OUTDRV
+ **/
+struct pca9685_pdata {
+	/* Array of channel allocation constrains */
+	/* add an extra channel for ALL_LED */
+	u8	chan_mapping[PCA9685_MAXCHAN + 1];
+	/* GPIO base */
+	int	gpio_base;
+	/* mode2 flags */
+	u8	en_invrt:1,   /* enable output logic state inverted mode */
+		en_open_dr:1, /* enable if outputs are configured with an
+						 open-drain structure */
+		unused:6;
+};
+
+#endif /* _PLAT_PCA9685_H_ */
-- 
1.7.5.4

