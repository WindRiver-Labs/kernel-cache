From f937313ea4ad6e4780ae071244d2be1cb92c93fd Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 27 Feb 2015 16:59:18 +0800
Subject: [PATCH 1/2] gpio-sch: support to save core well gpio states

source: intel quark BSP 1.1.0 vendor drop

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/gpio/gpio-sch.c |  141 ++++++++++++++++++++++++-----------------------
 1 files changed, 71 insertions(+), 70 deletions(-)

diff --git a/drivers/gpio/gpio-sch.c b/drivers/gpio/gpio-sch.c
index 70e588d..fdce3c2 100644
--- a/drivers/gpio/gpio-sch.c
+++ b/drivers/gpio/gpio-sch.c
@@ -2,6 +2,7 @@
  * GPIO interface for Intel Poulsbo SCH
  *
  *  Copyright (c) 2010 CompuLab Ltd
+ *  Copyright (c) 2014-2015 Intel Corporation
  *  Author: Denis Turischev <denis@compulab.co.il>
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -70,20 +71,26 @@ static struct uio_info *info;
 
 static int irq_num;
 
-struct sch_gpio_core_int_regvals {
+/* Cache register context */
+struct sch_gpio_context {
+	/* Core well generic registers */
 	u32 cgen;
 	u32 cgio;
 	u32 cglvl;
-	u32 cgtpe;
-	u32 cgtne;
 	u32 cggpe;
 	u32 cgsmi;
 	u32 cgnmien;
+	/* Core well interrupt trigger enable */
+	u32 cgtpe;
+	u32 cgtne;
+	/* Resume well interrupt trigger enable */
+	u32 rgtpe;
+	u32 rgtne;
 };
 
 struct sch_gpio {
 	int irq_base_core;
-	struct sch_gpio_core_int_regvals	lp_core;
+	struct sch_gpio_context context;
 	int irq_base_resume;
 	DECLARE_BITMAP(wake_irqs, MAX_GPIO_IRQS);
 };
@@ -157,30 +164,6 @@ static unsigned short sch_gpio_reg_get(unsigned short reg,
 	return curr_dirs;
 }
 
-void sch_gpio_resume_set_enable(unsigned gpio_num, int val)
-{
-	u8 curr_en;
-	unsigned short offset, bit;
-
-	spin_lock(&gpio_lock);
-
-	offset = RGEN + gpio_num / 8;
-	bit = gpio_num % 8;
-
-	curr_en = inb(gpio_ba + offset);
-
-	if (val) {
-		if (!(curr_en & (1 << bit)))
-			outb(curr_en | (1 << bit), gpio_ba + offset);
-	} else {
-		if ((curr_en & (1 << bit)))
-			outb(curr_en & ~(1 << bit), gpio_ba + offset);
-	}
-
-	spin_unlock(&gpio_lock);
-}
-EXPORT_SYMBOL_GPL(sch_gpio_resume_set_enable);
-
 static int sch_gpio_core_direction_in(struct gpio_chip *gc, unsigned  gpio_num)
 {
 	unsigned long flags = 0;
@@ -235,10 +218,19 @@ static struct gpio_chip sch_gpio_core = {
 
 static void sch_gpio_core_irq_enable(struct irq_data *d)
 {
-	u32 gpio_num = 0;
+	unsigned long flags = 0;
+	u32 gpio_num = d->irq - chip_ptr->irq_base_core;
+	struct sch_gpio_context *regs = &chip_ptr->context;
 
-	gpio_num = d->irq - chip_ptr->irq_base_core;
+	spin_lock_irqsave(&gpio_lock, flags);
+ 
+	if (regs->cgtpe & BIT(gpio_num))
+		sch_gpio_reg_set_if_clear(CGTPE, gpio_num);
+	if (regs->cgtne & BIT(gpio_num))
+		sch_gpio_reg_set_if_clear(CGTNE, gpio_num);
 	sch_gpio_reg_set_if_clear(CGGPE, gpio_num);
+ 
+	spin_unlock_irqrestore(&gpio_lock, flags);
 }
 
 static void sch_gpio_core_irq_disable(struct irq_data *d)
@@ -269,6 +261,7 @@ static int sch_gpio_core_irq_type(struct irq_data *d, unsigned type)
 	int ret = 0;
 	unsigned long flags = 0;
 	u32 gpio_num = 0;
+	struct sch_gpio_context *regs = &chip_ptr->context;
 
 	if (NULL == d) {
 		pr_err("%s(): null irq_data\n",  __func__);
@@ -298,7 +291,15 @@ static int sch_gpio_core_irq_type(struct irq_data *d, unsigned type)
 		break;
 	default:
 		ret = -EINVAL;
-	break;
+		break;
+	}
+
+	if (!ret) {
+		/* cache trigger setup */
+		regs->cgtpe &= ~BIT(gpio_num);
+		regs->cgtne &= ~BIT(gpio_num);
+		regs->cgtpe |= inl(gpio_ba + CGTPE) & BIT(gpio_num);
+		regs->cgtne |= inl(gpio_ba + CGTNE) & BIT(gpio_num);
 	}
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
@@ -359,40 +360,6 @@ static void sch_gpio_core_irq_disable_all(struct sch_gpio *chip,
 
 }
 
-void sch_gpio_core_save_state(struct sch_gpio_core_int_regvals *regs)
-{
-	 unsigned long flags = 0;
-	 spin_lock_irqsave(&gpio_lock, flags);
-
-	 regs->cgen      = inl(gpio_ba + CGEN);
-	 regs->cgio      = inl(gpio_ba + CGIO);
-	 regs->cglvl     = inl(gpio_ba + CGLV);
-	 regs->cgtpe     = inl(gpio_ba + CGTPE);
-	 regs->cgtne     = inl(gpio_ba + CGTNE);
-	 regs->cggpe     = inl(gpio_ba + CGGPE);
-	 regs->cgsmi     = inl(gpio_ba + CGSMI);
-	 regs->cgnmien   = inl(gpio_ba + CGNMIEN);
-
-	 spin_unlock_irqrestore(&gpio_lock, flags);
-}
-
-void sch_gpio_core_restore_state(struct sch_gpio_core_int_regvals *regs)
-{
-	 unsigned long flags = 0;
-	 spin_lock_irqsave(&gpio_lock, flags);
-
-	 outl(regs->cgio, gpio_ba + CGIO);
-	 outl(regs->cglvl, gpio_ba + CGLV);
-	 outl(regs->cgtpe, gpio_ba + CGTPE);
-	 outl(regs->cgtne, gpio_ba + CGTNE);
-	 outl(regs->cggpe, gpio_ba + CGGPE);
-	 outl(regs->cgsmi, gpio_ba + CGSMI);
-	 outl(regs->cgnmien, gpio_ba + CGNMIEN);
-	 outl(regs->cgen, gpio_ba + CGEN);
-
-	 spin_unlock_irqrestore(&gpio_lock, flags);
-}
-
 static int sch_gpio_resume_direction_in(struct gpio_chip *gc,
 					     unsigned gpio_num)
 {
@@ -447,10 +414,19 @@ static struct gpio_chip sch_gpio_resume = {
 
 static void sch_gpio_resume_irq_enable(struct irq_data *d)
 {
-	u32 gpio_num = 0;
+	unsigned long flags = 0;
+	u32 gpio_num = d->irq - chip_ptr->irq_base_resume;
+	struct sch_gpio_context *regs = &chip_ptr->context;
 
-	gpio_num = d->irq - chip_ptr->irq_base_resume;
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	if (regs->rgtpe & BIT(gpio_num))
+		sch_gpio_reg_set_if_clear(RGTPE, gpio_num);
+	if (regs->rgtne & BIT(gpio_num))
+		sch_gpio_reg_set_if_clear(RGTNE, gpio_num);
 	sch_gpio_reg_set_if_clear(RGGPE, gpio_num);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
 }
 
 static void sch_gpio_resume_irq_disable(struct irq_data *d)
@@ -483,6 +459,7 @@ static int sch_gpio_resume_irq_type(struct irq_data *d, unsigned type)
 	int ret = 0;
 	unsigned long flags = 0;
 	u32 gpio_num = 0;
+	struct sch_gpio_context *regs = &chip_ptr->context;
 
 	if (NULL == d) {
 		pr_err("%s(): null irq_data\n",  __func__);
@@ -515,6 +492,14 @@ static int sch_gpio_resume_irq_type(struct irq_data *d, unsigned type)
 		break;
 	}
 
+	if (!ret) {
+		/* cache trigger setup */
+		regs->rgtpe &= ~BIT(gpio_num);
+		regs->rgtne &= ~BIT(gpio_num);
+		regs->rgtpe |= inl(gpio_ba + RGTPE) & BIT(gpio_num);
+		regs->rgtne |= inl(gpio_ba + RGTNE) & BIT(gpio_num);
+	}
+
 	spin_unlock_irqrestore(&gpio_lock, flags);
 
 	return ret;
@@ -878,21 +863,37 @@ static int sch_gpio_suspend_sys(struct device *dev)
 
 /*
  * Saves the state of configuration registers for Core Well GPIOs.
+ * Don't touch Core Well interrupt triggers and SCI/GPE because they are
+ * handled by the irqchip subsystem.
  * Don't touch Suspend Well GPIO registers because they are alive and
  * functional in both S3 and S0 states.
  */
 static int sch_gpio_suspend_sys_noirq(struct device *dev)
 {
-	sch_gpio_core_save_state(&(chip_ptr->lp_core));
+	struct sch_gpio_context *regs = &chip_ptr->context;
+
+	regs->cgen	= inl(gpio_ba + CGEN);
+	regs->cgio	= inl(gpio_ba + CGIO);
+	regs->cglvl	= inl(gpio_ba + CGLV);
+	regs->cgsmi	= inl(gpio_ba + CGSMI);
+	regs->cgnmien	= inl(gpio_ba + CGNMIEN);
+
 	return 0;
 }
 
 /*
- * Restore the Core Well GPIOs configuration registers.
+ * Restore the context saved by sch_gpio_suspend_sys_noirq().
  */
 static int sch_gpio_resume_sys_noirq(struct device *dev)
 {
-	sch_gpio_core_restore_state(&(chip_ptr->lp_core));
+	struct sch_gpio_context *regs = &chip_ptr->context;
+
+	outl(regs->cgio,	gpio_ba + CGIO);
+	outl(regs->cglvl,	gpio_ba + CGLV);
+	outl(regs->cgsmi,	gpio_ba + CGSMI);
+	outl(regs->cgnmien,	gpio_ba + CGNMIEN);
+	outl(regs->cgen,	gpio_ba + CGEN);
+
 	return 0;
 }
 
-- 
1.7.5.4

