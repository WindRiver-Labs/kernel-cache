From 494009dd459ca90d22c13a5e1665ce4f38271cb7 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Thu, 6 Mar 2014 10:32:10 +0800
Subject: [PATCH 1/7] intel-quark: kernel patch integration based on 1.0.0
 drop.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/boot/compressed/early_imr.c               |  399 ------
 arch/x86/include/asm/cln.h                         |   85 --
 arch/x86/include/asm/imr.h                         |   10 +-
 arch/x86/include/asm/qrk.h                         |   85 ++
 arch/x86/include/asm/serial.h                      |    2 +-
 arch/x86/platform/efi/efi_capsule_update.c         |   15 +-
 drivers/dma/Makefile                               |    1 +
 drivers/dma/intel_cln_dma_pci.c                    |  155 ---
 drivers/dma/intel_mid_dma/Makefile                 |    2 +-
 drivers/dma/intel_qrk_dma_pci.c                    |  155 +++
 drivers/gpio/Kconfig                               |    6 +-
 drivers/gpio/gpio-sch.c                            |  751 ++++++++++--
 drivers/iio/accel/Kconfig                          |    4 +-
 drivers/iio/accel/Makefile                         |    2 +-
 drivers/iio/accel/lis331dlh_intel_cln.c            |  735 -----------
 drivers/iio/accel/lis331dlh_intel_qrk.c            |  735 +++++++++++
 drivers/iio/adc/max78m6610_lmu.c                   | 1272 ++++++++++++++++++--
 drivers/iio/common/st_sensors/st_sensors_buffer.c  |    3 +-
 drivers/iio/trigger/iio-trig-hrtimer.c             |   10 +-
 drivers/mfd/Kconfig                                |   18 +-
 drivers/mfd/Makefile                               |   12 +-
 drivers/mfd/cy8c9540a.c                            |    2 +-
 drivers/mfd/intel_cln_gip.h                        |  104 --
 drivers/mfd/intel_cln_gip_core.c                   |  335 -----
 drivers/mfd/intel_cln_gip_gpio.c                   |  660 ----------
 drivers/mfd/intel_cln_gip_i2c.c                    |  248 ----
 drivers/mfd/intel_cln_gip_pdata.c                  |   25 -
 drivers/mfd/intel_cln_gip_test.c                   | 1131 -----------------
 drivers/mfd/intel_qrk_gip.h                        |  104 ++
 drivers/mfd/intel_qrk_gip_core.c                   |  335 +++++
 drivers/mfd/intel_qrk_gip_gpio.c                   |  659 ++++++++++
 drivers/mfd/intel_qrk_gip_i2c.c                    |  248 ++++
 drivers/mfd/intel_qrk_gip_pdata.c                  |   25 +
 drivers/mfd/intel_qrk_gip_test.c                   | 1131 +++++++++++++++++
 drivers/mfd/lpc_sch.c                              |    8 +-
 drivers/mmc/host/sdhci-pci.c                       |    6 +-
 drivers/mtd/devices/Kconfig                        |    4 +-
 drivers/net/ethernet/stmicro/stmmac/Kconfig        |    2 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |    6 +-
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |   16 +-
 drivers/platform/x86/quark/Kconfig                 |   24 +-
 drivers/platform/x86/quark/Makefile                |   32 +-
 drivers/platform/x86/quark/intel_cln_audio_ctrl.c  |  514 --------
 drivers/platform/x86/quark/intel_cln_audio_ctrl.h  |   45 -
 drivers/platform/x86/quark/intel_cln_board_data.c  |  260 ----
 drivers/platform/x86/quark/intel_cln_ecc_scrub.c   |  668 ----------
 drivers/platform/x86/quark/intel_cln_esram.c       | 1144 ------------------
 drivers/platform/x86/quark/intel_cln_esram.h       |  107 --
 drivers/platform/x86/quark/intel_cln_esram_test.c  |  602 ---------
 drivers/platform/x86/quark/intel_cln_esram_test.h  |   43 -
 drivers/platform/x86/quark/intel_cln_imr.c         |  584 ---------
 drivers/platform/x86/quark/intel_cln_imr.h         |  155 ---
 drivers/platform/x86/quark/intel_cln_imr_kernel.c  |  139 ---
 drivers/platform/x86/quark/intel_cln_imr_test.c    |  357 ------
 drivers/platform/x86/quark/intel_cln_layout_data.c |  100 --
 .../x86/quark/intel_cln_plat_clanton_hill.c        |  196 ---
 .../x86/quark/intel_cln_plat_clanton_peak.c        |  227 ----
 .../platform/x86/quark/intel_cln_plat_cross_hill.c |  383 ------
 drivers/platform/x86/quark/intel_cln_plat_data.c   |  456 -------
 .../platform/x86/quark/intel_cln_plat_galileo.c    |  395 ------
 .../platform/x86/quark/intel_cln_plat_kips_bay.c   |  176 ---
 drivers/platform/x86/quark/intel_cln_sb.c          |  252 ----
 drivers/platform/x86/quark/intel_cln_smep_test.c   |  290 -----
 drivers/platform/x86/quark/intel_cln_thermal.c     |  360 ------
 drivers/platform/x86/quark/intel_qrk_audio_ctrl.c  |  514 ++++++++
 drivers/platform/x86/quark/intel_qrk_audio_ctrl.h  |   45 +
 drivers/platform/x86/quark/intel_qrk_board_data.c  |  260 ++++
 drivers/platform/x86/quark/intel_qrk_esram.c       | 1144 ++++++++++++++++++
 drivers/platform/x86/quark/intel_qrk_esram.h       |  107 ++
 drivers/platform/x86/quark/intel_qrk_esram_test.c  |  602 +++++++++
 drivers/platform/x86/quark/intel_qrk_esram_test.h  |   43 +
 drivers/platform/x86/quark/intel_qrk_imr.c         |  697 +++++++++++
 drivers/platform/x86/quark/intel_qrk_imr.h         |  157 +++
 drivers/platform/x86/quark/intel_qrk_imr_kernel.c  |  139 +++
 drivers/platform/x86/quark/intel_qrk_imr_test.c    |  357 ++++++
 .../x86/quark/intel_qrk_plat_clanton_hill.c        |  226 ++++
 .../x86/quark/intel_qrk_plat_clanton_peak.c        |  227 ++++
 .../platform/x86/quark/intel_qrk_plat_cross_hill.c |  392 ++++++
 .../platform/x86/quark/intel_qrk_plat_galileo.c    |  398 ++++++
 .../platform/x86/quark/intel_qrk_plat_kips_bay.c   |  176 +++
 drivers/platform/x86/quark/intel_qrk_sb.c          |  253 ++++
 drivers/platform/x86/quark/intel_qrk_thermal.c     |  360 ++++++
 drivers/spi/Kconfig                                |    2 +-
 drivers/spi/spi-pxa2xx-pci.c                       |    2 +-
 drivers/spi/spi-pxa2xx.c                           |   12 +-
 drivers/tty/serial/8250/8250_pci.c                 |   26 +-
 drivers/tty/serial/Kconfig                         |    4 +-
 drivers/tty/serial/intel_quark_uart.c              |    8 +-
 drivers/usb/gadget/Kconfig                         |    4 +-
 drivers/usb/gadget/pch_udc.c                       |   12 +-
 drivers/usb/host/ehci-pci.c                        |    4 +-
 drivers/usb/host/pci-quirks.c                      |    8 +-
 drivers/usb/host/pci-quirks.h                      |    4 +-
 include/linux/iio/st_sensors.h                     |  289 +++++
 include/linux/iio/st_sensors_i2c.h                 |   20 +
 include/linux/iio/st_sensors_spi.h                 |   20 +
 include/linux/intel_cln_sb.h                       |   90 --
 include/linux/intel_mid_dma.h                      |   11 +-
 include/linux/intel_qrk_sb.h                       |   92 ++
 include/linux/mfd/cy8c9540a.h                      |    2 +-
 include/linux/mfd/intel_cln_gip_pdata.h            |   32 -
 include/linux/mfd/intel_qrk_gip_pdata.h            |   32 +
 include/linux/pci_ids.h                            |    4 +-
 include/linux/platform_data/clanton.h              |   44 -
 include/linux/platform_data/lis331dlh_intel_cln.h  |   36 -
 include/linux/platform_data/lis331dlh_intel_qrk.h  |   36 +
 include/linux/platform_data/max78m6610_lmu.h       |   34 +
 include/linux/platform_data/quark.h                |   44 +
 108 files changed, 12106 insertions(+), 11878 deletions(-)
 delete mode 100644 arch/x86/boot/compressed/early_imr.c
 delete mode 100644 arch/x86/include/asm/cln.h
 create mode 100644 arch/x86/include/asm/qrk.h
 delete mode 100644 drivers/dma/intel_cln_dma_pci.c
 create mode 100644 drivers/dma/intel_qrk_dma_pci.c
 mode change 100644 => 100755 drivers/gpio/gpio-sch.c
 delete mode 100644 drivers/iio/accel/lis331dlh_intel_cln.c
 create mode 100644 drivers/iio/accel/lis331dlh_intel_qrk.c
 delete mode 100644 drivers/mfd/intel_cln_gip.h
 delete mode 100644 drivers/mfd/intel_cln_gip_core.c
 delete mode 100644 drivers/mfd/intel_cln_gip_gpio.c
 delete mode 100644 drivers/mfd/intel_cln_gip_i2c.c
 delete mode 100644 drivers/mfd/intel_cln_gip_pdata.c
 delete mode 100644 drivers/mfd/intel_cln_gip_test.c
 create mode 100644 drivers/mfd/intel_qrk_gip.h
 create mode 100644 drivers/mfd/intel_qrk_gip_core.c
 create mode 100644 drivers/mfd/intel_qrk_gip_gpio.c
 create mode 100644 drivers/mfd/intel_qrk_gip_i2c.c
 create mode 100644 drivers/mfd/intel_qrk_gip_pdata.c
 create mode 100644 drivers/mfd/intel_qrk_gip_test.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_audio_ctrl.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_audio_ctrl.h
 delete mode 100644 drivers/platform/x86/quark/intel_cln_board_data.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_ecc_scrub.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_esram.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_esram.h
 delete mode 100644 drivers/platform/x86/quark/intel_cln_esram_test.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_esram_test.h
 delete mode 100644 drivers/platform/x86/quark/intel_cln_imr.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_imr.h
 delete mode 100644 drivers/platform/x86/quark/intel_cln_imr_kernel.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_imr_test.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_layout_data.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_data.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_galileo.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_sb.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_smep_test.c
 delete mode 100644 drivers/platform/x86/quark/intel_cln_thermal.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_audio_ctrl.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_audio_ctrl.h
 create mode 100644 drivers/platform/x86/quark/intel_qrk_board_data.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_esram.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_esram.h
 create mode 100644 drivers/platform/x86/quark/intel_qrk_esram_test.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_esram_test.h
 create mode 100644 drivers/platform/x86/quark/intel_qrk_imr.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_imr.h
 create mode 100644 drivers/platform/x86/quark/intel_qrk_imr_kernel.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_imr_test.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_clanton_hill.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_clanton_peak.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_galileo.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_kips_bay.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_sb.c
 create mode 100644 drivers/platform/x86/quark/intel_qrk_thermal.c
 create mode 100644 include/linux/iio/st_sensors.h
 create mode 100644 include/linux/iio/st_sensors_i2c.h
 create mode 100644 include/linux/iio/st_sensors_spi.h
 delete mode 100644 include/linux/intel_cln_sb.h
 create mode 100644 include/linux/intel_qrk_sb.h
 delete mode 100644 include/linux/mfd/intel_cln_gip_pdata.h
 create mode 100644 include/linux/mfd/intel_qrk_gip_pdata.h
 delete mode 100644 include/linux/platform_data/clanton.h
 delete mode 100644 include/linux/platform_data/lis331dlh_intel_cln.h
 create mode 100644 include/linux/platform_data/lis331dlh_intel_qrk.h
 create mode 100644 include/linux/platform_data/max78m6610_lmu.h
 create mode 100644 include/linux/platform_data/quark.h

diff --git a/arch/x86/boot/compressed/early_imr.c b/arch/x86/boot/compressed/early_imr.c
deleted file mode 100644
index b5e9ab1..0000000
--- a/arch/x86/boot/compressed/early_imr.c
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * This file implements a simple binding to provide early isolated memory region
- * support (IMR) - with the primary goal of encapsulating kernel decompress
- * target area inside of an IMR before decompression takes place. To that end we
- * do some very very early PCI accesses here - required in order to waggle the
- * side-band bits associated with IMR support
- */
-#include <linux/io.h>
-
-#include "misc.h"
-
-#define INTEL_CLN_SB_CMD_ADDR		(0x000000D0)
-#define INTEL_CLN_SB_DATA_ADDR		(0x000000D4)
-
-#define INTEL_CLN_SB_MCR_SHIFT		(24)
-#define INTEL_CLN_SB_PORT_SHIFT		(16)
-#define INTEL_CLN_SB_REG_SHIFT		(8)
-#define INTEL_CLN_SB_BYTEEN		(0xF0)	/* enable all 32 bits */
-
-/* PCI config space reg definitions */
-#define PCI_VENDOR_ID			(0x00)
-#define PCI_DEVICE_ID			(0x02)
-#define PCI_CLASS_DEVICE		(0x0A)
-
-/* IMR related reg address */
-#define CFG_READ_OPCODE			(0x10)  /* Control Read */
-#define CFG_WRITE_OPCODE		(0x11)  /* Control write */
-#define DRAM_IMR0L			(0x40)  /* IMR0RL address */
-#define DRAM_IMR0H			(0x41)  /* IMR0RL address */
-#define DRAM_IMR0RM			(0x42)  /* IMR0RM address */
-#define DRAM_IMR0WM			(0x43)  /* IMR0WM address */
-#define DRAM_IMR1L			(0x44)  /* IMR1L address */
-#define DRAM_IMR1H			(0x45)  /* IMR1H address */
-#define DRAM_IMR1RM			(0x46)  /* IMR1RM address */
-#define DRAM_IMR1WM			(0x47)  /* IMR1WM address */
-#define DRAM_IMR3L			(0x4C)  /* IMR3L address */
-#define DRAM_IMR3H			(0x4D)  /* IMR3H address */
-#define DRAM_IMR3RM			(0x4E)  /* IMR3RM address */
-#define DRAM_IMR3WM			(0x4F)  /* IMR3WM address */
-#define DRAM_IMR7L			(0x5C)  /* IMR7RM address */
-#define DRAM_IMR7H			(0x5D)  /* IMR7RM address */
-#define DRAM_IMR7RM			(0x5E)  /* IMR7RM address */
-#define DRAM_IMR7WM			(0x5F)  /* IMR7WM address */
-
-#define IMR_WRITE_ENABLE_ALL		(0xFFFFFFFF)
-#define IMR_READ_ENABLE_ALL		(0xBFFFFFFF)
-#define IMR_BASE_ADDR			(0x0000)
-#define IMR_LOCK_BIT			(0x80000000)
-
-/* Mask of the last 2 bit of IMR address [23:2] */
-#define IMR_MASK			(0xFFFFFC)
-
-/* Mask that enables IMR access for Non-SMM Core, Core Snoops Only.*/
-#define IMR_SNOOP_NON_SMM_ENABLE	(0x40000001)
-
-/* Mask that enables IMR access for Non-SMM Core Only.*/
-#define IMR_NON_SMM_ENABLE		(0x00000001)
-
-/* Max Memory Address */
-#define MAX_MEM_ADDR			(0xFFFFFFFF)
-
-enum {
-	SB_ID_HUNIT = 0x03,
-	SB_ID_THERMAL = 0x04,
-	SB_ID_IMRID = 0x05,
-} cln_sb_id;
-
-struct sb_pci_dev {
-	unsigned int bus;
-	unsigned int dev_fn;
-};
-
-static struct sb_pci_dev sb_pcidev;
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-#define CONFIG_CMD(bus, dev_fn, where)\
-	(0x80000000 | (bus << 16) | (dev_fn << 8) | (where & ~3))
-/**
- * pci_read_config_word
- *
- * @param db_pcidev: Pointer to side-band PCI device
- * @param where: Register offset to read
- * @param value: Pointer to output parameter
- * @return nothing
- *
- * Utility function to allow simple PCI read of configuration space 16 bit field
- * via legacy PCI access mechanism.
- */
-static void pci_read_config_word(struct sb_pci_dev *sb_pcidev,
-				unsigned int where, unsigned short *value)
-{
-	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
-	*value = inw(0xCFC + (where&2));
-}
-
-/**
- * pci_read_config_dword
- *
- * @param db_pcidev: Pointer to side-band PCI device
- * @param where: Register offset to read
- * @param value: Pointer to output parameter
- * @return nothing
- *
- * Utility function to allow simple PCI read of configuration space 32 bit field
- * via legacy PCI access mechanism.
- */
-static void pci_read_config_dword(struct sb_pci_dev *sb_pcidev,
-				unsigned int where, unsigned int *value)
-{
-	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
-	*value = inl(0xCFC);
-}
-
-/**
- * pci_write_config_word
- *
- * @param db_pcidev: Pointer to side-band PCI device
- * @param where: Register offset to read
- * @param value: Value to stuff into destination register
- * @return nothing
- *
- * Utility function to allow simple PCI write of configuration space 16 bit
- * field via legacy PCI access mechanism.
- */
-static void pci_write_config_word(struct sb_pci_dev *sb_pcidev,
-				unsigned int where, unsigned short value)
-{
-	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
-	outw(value, 0xCFC + (where&2));
-}
-
-/**
- * pci_write_config_dword
- *
- * @param db_pcidev: Pointer to side-band PCI device
- * @param where: Register offset to read
- * @param value: Value to stuff into destination register
- * @return nothing
- *
- * Utility function to allow simple PCI write of configuration space 32 bit
- * field via legacy PCI access mechanism.
- */
-static void pci_write_config_dword(struct sb_pci_dev *sb_pcidev,
-				unsigned int where, unsigned int value)
-{
-	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
-	outl(value, 0xCFC);
-}
-
-/**
- * intel_cln_early_sb_read_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe read of side-band
- * command - can be different read op-code types - which is why we don't
- * hard-code this value directly into msg
- */
-static void intel_cln_early_sb_read_reg(int id, uint8_t cmd, uint8_t reg,
-					uint32_t *data)
-{
-	uint32_t msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) |
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000) |
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00) |
-		  INTEL_CLN_SB_BYTEEN;
-
-	if (data == NULL)
-		return;
-
-	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_CMD_ADDR, msg);
-	pci_read_config_dword(&sb_pcidev, INTEL_CLN_SB_DATA_ADDR, data);
-}
-
-/**
- * intel_cln_early_sb_write_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe write of side-band
- */
-static void intel_cln_early_sb_write_reg(int id, uint8_t cmd, uint8_t reg,
-					uint32_t data)
-{
-	uint32_t msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) |
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000) |
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00) |
-		  INTEL_CLN_SB_BYTEEN;
-
-	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_DATA_ADDR, data);
-	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_CMD_ADDR, msg);
-}
-
-/* Clanton hardware */
-#define PCI_VENDOR_ID_INTEL		(0x8086)
-#define PCI_DEVICE_ID_CLANTON_SB	(0x0958)
-
-/**
- * sb_probe
- *
- * @param dev: the PCI device matching
- * @param id: entry in the match table
- * @return 0
- *
- * Callback from PCI layer when dev/vendor ids match.
- * Sets up necessary resources
- */
-static int intel_cln_early_sb_probe(void)
-{
-	int found = 0;
-	uint16_t class;
-	uint16_t device, vendor;
-
-	sb_pcidev.bus = 0;
-	for (sb_pcidev.dev_fn = 0; sb_pcidev.dev_fn < 0xFF;
-		sb_pcidev.dev_fn++) {
-		/* Only probe function 0 on single fn devices */
-		pci_read_config_word(&sb_pcidev, PCI_CLASS_DEVICE, &class);
-
-		if (class == 0xffff)
-			continue;
-
-		pci_read_config_word(&sb_pcidev, PCI_VENDOR_ID, &vendor);
-		pci_read_config_word(&sb_pcidev, PCI_DEVICE_ID, &device);
-
-		/* Do early PCI UART init */
-		if (vendor == PCI_VENDOR_ID_INTEL) {
-			if (device == PCI_DEVICE_ID_CLANTON_SB) {
-				/* Found */
-				found = 1;
-				break;
-			}
-		}
-	}
-
-	if (found == 0)
-		return -1;
-
-	return 0;
-}
-
-
-
-
-/**
- * addr_hw_ready
- *
- * shift input address value to match HW required 1k aligned format
- */
-static inline uint32_t addr_hw_ready(uint32_t addr)
-{
-	/* memory alignment */
-	addr &= (~((1 << 10) - 1));
-
-	/* prepare input addr in HW required format */
-	addr = (addr >> 8) & IMR_MASK;
-	return addr;
-}
-
-/**
- * cln_remove_imr
- *
- * @return nothing
- *
- * write default values to reg to set imr free
- */
-static void cln_remove_imr(uint8_t reg_l, uint8_t reg_h, uint8_t reg_rm,
-			uint8_t reg_wm)
-{
-	uint32_t tmp_addr;
-
-	intel_cln_early_sb_read_reg(SB_ID_IMRID, CFG_READ_OPCODE, reg_l,
-				&tmp_addr);
-	if (tmp_addr & IMR_LOCK_BIT) {
-		/* Failure to teardown an IMR means we can't guarantee DMA to
-		 * the now 'IMR free' region will succeed - so we bug out
-		 */
-		error_putstr("IMR LOCKED !\n");
-		while (1)
-			asm("hlt");
-		return;
-	}
-
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_rm,
-				IMR_READ_ENABLE_ALL);
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_wm,
-				IMR_WRITE_ENABLE_ALL);
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_h,
-				IMR_BASE_ADDR);
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_l,
-				IMR_BASE_ADDR);
-}
-
-/**
- * cln_remove_imr_grub
- *
- * @return nothing
- * remove imr protection from grub,
- * set imr rw masks to default
- */
-static void cln_remove_imr_grub(void)
-{
-	cln_remove_imr(DRAM_IMR0L, DRAM_IMR0H, DRAM_IMR0RM, DRAM_IMR0WM);
-}
-
-/**
- * cln_remove_imr_boot_params
- *
- * @return nothing
- * remove imr protection from grub,
- * set imr rw masks to default
- */
-static void cln_remove_imr_boot_params(void)
-{
-	cln_remove_imr(DRAM_IMR1L, DRAM_IMR1H, DRAM_IMR1RM, DRAM_IMR1WM);
-}
-
-/**
- * cln_remove_imr_bzimage
- *
- * @return nothing
- * remove imr protection from bzImage,
- * set imr rw masks to default
- */
-static void cln_remove_imr_bzimage(void)
-{
-	cln_remove_imr(DRAM_IMR7L, DRAM_IMR7H, DRAM_IMR7RM, DRAM_IMR7WM);
-}
-
-/**
- * decompress_kernel_imr
- *
- * @param command: Command to send to destination identifier
- * @return nothing
- *
- * Early in the boot process it is not possible to get the address of
- * &__init_end, so instead we setup a temporary IMR from LOAD_PHYSICAL_ADDR to
- * 2^32 -1. While this IMR is active DMA to this address range is invalid.
- * Later when the address of __init_end is available (inside the decompressed
- * kernel) we setup a new IMR for a smaller range and tear down this IMR, to
- * ensure at all times an IMR is protecting critical sections of the .text
- * section
- */
-void decompress_kernel_imr(struct boot_params *boot)
-{
-	uint32_t imr_hi_addr;
-	uint32_t imr_lo_addr;
-
-	if (intel_cln_early_sb_probe() != 0) {
-		debug_putstr("NO Early SB support !\n");
-		return;
-	}
-
-	/* Set extent of initial decompress IMR */
-	imr_lo_addr = addr_hw_ready(LOAD_PHYSICAL_ADDR);
-	imr_hi_addr = addr_hw_ready(MAX_MEM_ADDR);
-
-	/* Set boundaries and access rights of new IMR */
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
-				DRAM_IMR3H, imr_hi_addr);
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
-				DRAM_IMR3L, imr_lo_addr);
-
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
-					DRAM_IMR3RM, IMR_NON_SMM_ENABLE);
-	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
-					DRAM_IMR3WM, IMR_SNOOP_NON_SMM_ENABLE);
-
-	/* Teardown unused IMRs */
-	cln_remove_imr_boot_params();
-	cln_remove_imr_bzimage();
-	cln_remove_imr_grub();
-}
diff --git a/arch/x86/include/asm/cln.h b/arch/x86/include/asm/cln.h
deleted file mode 100644
index 4a5b0e3..0000000
--- a/arch/x86/include/asm/cln.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-#ifndef _ASM_X86_CLN_H
-#define _ASM_X86_CLN_H
-
-#include <linux/pci.h>
-#include <linux/msi.h>
-
-/**
- * cln_pci_pvm_mask
- *
- * Mask PVM bit on a per function basis. Clanton SC components have but one
- * vector each - so we mask for what we need
- */
-static inline void cln_pci_pvm_mask(struct pci_dev * dev)
-{
-	struct msi_desc *entry;
-	int mask_bits = 1;
-
-	if(unlikely(dev->msi_enabled == 0))
-		return;
-
-	entry = list_first_entry(&dev->msi_list, struct msi_desc, list);
-
-	if(unlikely(entry == NULL))
-		return;
-
-	pci_write_config_dword(dev, entry->mask_pos, mask_bits);
-}
-
-/**
- * cln_pci_pvm_mask
- *
- * UnMask PVM bit on a per function basis. Clanton SC components have but one
- * vector each - so we unmask for what we need
- */
-static inline void cln_pci_pvm_unmask(struct pci_dev * dev)
-{
-	struct msi_desc *entry;
-	int mask_bits = 0;
-
-	if(unlikely(dev->msi_enabled == 0))
-		return;
-
-	entry = list_first_entry(&dev->msi_list, struct msi_desc, list);
-
-	if(unlikely(entry == NULL))
-		return;
-
-	pci_write_config_dword(dev, entry->mask_pos, mask_bits);
-}
-
-/* Convienence macros */
-#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-       #define mask_pvm(x) cln_pci_pvm_mask(x)
-       #define unmask_pvm(x) cln_pci_pvm_unmask(x) 
-#else
-       #define mask_pvm(x)
-       #define unmask_pvm(x)
-#endif
-
-/* Serial */
-#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-	#define SERIAL_PORT_DFNS
-	#define BASE_BAUD 2764800
-#endif
-
-#endif /* _ASM_X86_CLN_H */
diff --git a/arch/x86/include/asm/imr.h b/arch/x86/include/asm/imr.h
index 2c17eec..876d499 100644
--- a/arch/x86/include/asm/imr.h
+++ b/arch/x86/include/asm/imr.h
@@ -1,5 +1,5 @@
 /*
- * imr.h: Intel Clanton platform imr setup code
+ * imr.h: Intel Quark platform imr setup code
  *
  * (C) Copyright 2012 Intel Corporation
  *
@@ -12,11 +12,11 @@
 #define _ASM_X86_IMR_H
 
 #if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-	extern int intel_cln_imr_runt_setparams(void);
-	extern int intel_cln_imr_lockall(void);
+	extern int intel_qrk_imr_runt_setparams(void);
+	extern int intel_qrk_imr_lockall(void);
 #else
-	static void intel_cln_imr_runt_setparams(void){}
-	static void intel_cln_imr_lockall(void){}
+	static void intel_qrk_imr_runt_setparams(void){}
+	static void intel_qrk_imr_lockall(void){}
 #endif
 
 #endif /* _ASM_X86_IMR_H */
diff --git a/arch/x86/include/asm/qrk.h b/arch/x86/include/asm/qrk.h
new file mode 100644
index 0000000..bd65b86
--- /dev/null
+++ b/arch/x86/include/asm/qrk.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+#ifndef _ASM_X86_QRK_H
+#define _ASM_X86_QRK_H
+
+#include <linux/pci.h>
+#include <linux/msi.h>
+
+/**
+ * qrk_pci_pvm_mask
+ *
+ * Mask PVM bit on a per function basis. Quark SC components have but one
+ * vector each - so we mask for what we need
+ */
+static inline void qrk_pci_pvm_mask(struct pci_dev * dev)
+{
+	struct msi_desc *entry;
+	int mask_bits = 1;
+
+	if(unlikely(dev->msi_enabled == 0))
+		return;
+
+	entry = list_first_entry(&dev->msi_list, struct msi_desc, list);
+
+	if(unlikely(entry == NULL))
+		return;
+
+	pci_write_config_dword(dev, entry->mask_pos, mask_bits);
+}
+
+/**
+ * qrk_pci_pvm_mask
+ *
+ * UnMask PVM bit on a per function basis. Quark SC components have but one
+ * vector each - so we unmask for what we need
+ */
+static inline void qrk_pci_pvm_unmask(struct pci_dev * dev)
+{
+	struct msi_desc *entry;
+	int mask_bits = 0;
+
+	if(unlikely(dev->msi_enabled == 0))
+		return;
+
+	entry = list_first_entry(&dev->msi_list, struct msi_desc, list);
+
+	if(unlikely(entry == NULL))
+		return;
+
+	pci_write_config_dword(dev, entry->mask_pos, mask_bits);
+}
+
+/* Convienence macros */
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+       #define mask_pvm(x) qrk_pci_pvm_mask(x)
+       #define unmask_pvm(x) qrk_pci_pvm_unmask(x) 
+#else
+       #define mask_pvm(x)
+       #define unmask_pvm(x)
+#endif
+
+/* Serial */
+#if defined(CONFIG_INTEL_QUARK_X1000_SOC)
+	#define SERIAL_PORT_DFNS
+	#define BASE_BAUD 2764800
+#endif
+
+#endif /* _ASM_X86_QRK_H */
diff --git a/arch/x86/include/asm/serial.h b/arch/x86/include/asm/serial.h
index 3965f86..9bcaf85 100644
--- a/arch/x86/include/asm/serial.h
+++ b/arch/x86/include/asm/serial.h
@@ -1,7 +1,7 @@
 #ifndef _ASM_X86_SERIAL_H
 #define _ASM_X86_SERIAL_H
 
-#include <asm/cln.h>
+#include <asm/qrk.h>
 
 /*
  * This assumes you have a 1.8432 MHz clock for your UART.
diff --git a/arch/x86/platform/efi/efi_capsule_update.c b/arch/x86/platform/efi/efi_capsule_update.c
index ccd4268..3420e35 100644
--- a/arch/x86/platform/efi/efi_capsule_update.c
+++ b/arch/x86/platform/efi/efi_capsule_update.c
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2013 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -18,7 +18,7 @@
  * Intel Corporation
  */
 #define DEBUG
-#include <asm/cln.h>
+#include <asm/qrk.h>
 #include <linux/errno.h>
 #include <linux/firmware.h>
 #include <linux/init.h>
@@ -45,7 +45,7 @@ static struct device *dev;
 static struct list_head sg_list;
 static char fpath[MAX_PATH];
 static bool path_set = false;
-static int csh_jump = CSH_HDR_SIZE;		/* Clanton EDK wants CSH jump */
+static int csh_jump = CSH_HDR_SIZE;		/* Quark EDK wants CSH jump */
 
 /**
  * efi_capsule_trigger_update
@@ -59,14 +59,13 @@ static int efi_capsule_trigger_update(void)
 	u32 nblocks = 0, i = 0, total_size = 0, data_len = 0, offset = 0;
 	efi_capsule_header_t *chdr = NULL;
 	efi_blk_desc_t * desc_block = NULL;
-	//u8 ** data = NULL;
 	u8 * data = NULL;
 
 	if (path_set == false)
 		return -ENODEV;
 
 	ret = request_firmware(&fw_entry, fpath, dev);
-	if (ret){
+	if (ret || fw_entry == NULL){
 		pr_err(PFX"unable to load firmware %s\n", fpath);
 		return ret;
 	}
@@ -123,7 +122,7 @@ static int efi_capsule_trigger_update(void)
 		}
 		pr_debug(PFX "block %d length %u data @ phys 0x%08x virt %x\n",
 			i, (int)desc_block[i].length,
-			(unsigned int)desc_block[i].data_block, data);
+			(unsigned int)desc_block[i].data_block, (unsigned int)data);
 	}
 
 	if (i > nblocks-1){
@@ -244,7 +243,7 @@ static void efi_capsule_device_release(struct device *dev)
 
 #define SYSFS_ERRTXT "Error adding sysfs entry!\n"
 /**
- * intel_cln_capsule_update_init
+ * intel_qrk_capsule_update_init
  *
  * @return 0 success < 0 failure
  *
@@ -316,7 +315,7 @@ err:
 }
 
 /**
- * intel_cln_esram_exit
+ * intel_qrk_esram_exit
  *
  * Module exit
  */
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 59c10e5..4f265c8 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -4,6 +4,7 @@ ccflags-$(CONFIG_DMADEVICES_VDEBUG) += -DVERBOSE_DEBUG
 obj-$(CONFIG_DMA_ENGINE) += dmaengine.o
 obj-$(CONFIG_NET_DMA) += iovlock.o
 obj-$(CONFIG_INTEL_MID_DMAC) += intel_mid_dma.o
+intel_mid_dma-objs := intel_mid_dma_core.o intel_qrk_dma_pci.o intel_mid_dma_pci.o
 obj-$(CONFIG_DMATEST) += dmatest.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
diff --git a/drivers/dma/intel_cln_dma_pci.c b/drivers/dma/intel_cln_dma_pci.c
deleted file mode 100644
index cb3d6e7..0000000
--- a/drivers/dma/intel_cln_dma_pci.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-
-/*
- *  intel_quark_dma_pci.c
- *
- *  Author: Bryan O'Donoghue <bryan.odonoghue@intel.com>
- *  This is an entry point for Intel Quark based DMAC on Quark's UART
- *  specifically we don't have a dedicated PCI function, instead we have DMAC
- *  regs hung off of a PCI BAR. This entry/exit allows re-use of the core
- *  DMA API for MID devices manipulated to suit our BAR setup
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- */
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/pm_runtime.h>
-#include <linux/intel_mid_dma.h>
-#include <linux/module.h>
-
-//#include "intel_mid_dma_core.h"
-#include "intel_mid_dma_regs.h"
-
-/**
- * intel_mid_dma_probe -	PCI Probe
- * @pdev: Controller PCI device structure
- * @id: pci device id structure
- *
- * Initialize the PCI device, map BARs, query driver data.
- * Call mid_setup_dma to complete contoller and chan initilzation
- */
-int intel_cln_dma_probe(struct pci_dev *pdev,
-					struct middma_device *device)
-{
-	u32 base_addr, bar_size;
-	int err;
-
-	dev_info(&pdev->dev, "MDMA: probe for %x\n", pdev->device);
-	dev_info(&pdev->dev, "MDMA: CH %d, base %d, block len %d, Periphral mask %x\n",
-				device->max_chan, device->chan_base,
-				device->block_size, device->pimr_mask);
-
-	device->pdev = pci_dev_get(pdev);
-
-	base_addr = pci_resource_start(pdev, 1);
-	bar_size  = pci_resource_len(pdev, 1);
-	device->dma_base = ioremap_nocache(base_addr, DMA_REG_SIZE);
-	if (!device->dma_base) {
-		pr_err("ERR_MDMA:ioremap failed\n");
-		err = -ENOMEM;
-		goto err_ioremap;
-	}
-
-	dev_info(&pdev->dev, "Remapped BAR 0x%08x to virt 0x%p\n",
-		base_addr, device->dma_base);
-
-	err = mid_setup_dma(pdev, device);
-	if (err)
-		goto err_dma;
-
-	return 0;
-
-err_dma:
-	iounmap(device->dma_base);
-err_ioremap:
-	pr_err("ERR_MDMA:Probe failed %d\n", err);
-	return err;
-}
-EXPORT_SYMBOL(intel_cln_dma_probe);
-
-/**
- * intel_mid_dma_remove -	PCI remove
- * @pdev: Controller PCI device structure
- *
- * Free up all resources and data
- * Call shutdown_dma to complete contoller and chan cleanup
- */
-void intel_cln_dma_remove(struct pci_dev *pdev, struct middma_device *device)
-{
-	//middma_shutdown(pdev, device);
-}
-EXPORT_SYMBOL(intel_cln_dma_remove);
-
-/* Power Management */
-/*
-* dma_suspend - PCI suspend function
-*
-* @pci: PCI device structure
-* @state: PM message
-*
-* This function is called by OS when a power event occurs
-*/
-int intel_cln_dma_suspend(struct middma_device *device)
-{
-	int i = 0;
-	pr_debug("MDMA: dma_suspend called\n");
-
-	for (i = 0; i < device->max_chan; i++) {
-		if (device->ch[i].in_use)
-			return -EAGAIN;
-	}
-#if 0
-	dmac1_mask_periphral_intr(device);
-#endif
-	device->state = SUSPENDED;
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_dma_suspend);
-
-/**
-* dma_resume - PCI resume function
-*
-* @pci:	PCI device structure
-*
-* This function is called by OS when a power event occurs
-*/
-int intel_cln_dma_resume(struct middma_device *device)
-{
-	//return middma_resume(device);
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_dma_resume);
-
-static int intel_cln_dma_runtime_suspend(struct middma_device *device)
-{
-	device->state = SUSPENDED;
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_dma_runtime_suspend);
-
-static int intel_cln_dma_runtime_resume(struct middma_device *device)
-{
-	device->state = RUNNING;
-	iowrite32(REG_BIT0, device->dma_base + DMA_CFG);
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_dma_runtime_resume);
-
-
diff --git a/drivers/dma/intel_mid_dma/Makefile b/drivers/dma/intel_mid_dma/Makefile
index 6b38f9f..6ec8b97 100644
--- a/drivers/dma/intel_mid_dma/Makefile
+++ b/drivers/dma/intel_mid_dma/Makefile
@@ -1,3 +1,3 @@
 obj-$(CONFIG_INTEL_MID_DMAC) += intel_mid_dma.o
-intel_mid_dma-objs:= intel_cln_dma_pci.o intel_mid_dma_pci.o
+intel_mid_dma-objs:= intel_qrk_dma_pci.o intel_mid_dma_pci.o
 
diff --git a/drivers/dma/intel_qrk_dma_pci.c b/drivers/dma/intel_qrk_dma_pci.c
new file mode 100644
index 0000000..cbac334
--- /dev/null
+++ b/drivers/dma/intel_qrk_dma_pci.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ *  intel_quark_dma_pci.c
+ *
+ *  Author: Bryan O'Donoghue <bryan.odonoghue@intel.com>
+ *  This is an entry point for Intel Quark based DMAC on Quark's UART
+ *  specifically we don't have a dedicated PCI function, instead we have DMAC
+ *  regs hung off of a PCI BAR. This entry/exit allows re-use of the core
+ *  DMA API for MID devices manipulated to suit our BAR setup
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/module.h>
+
+//#include "intel_mid_dma_core.h"
+#include "intel_mid_dma_regs.h"
+
+/**
+ * intel_mid_dma_probe -	PCI Probe
+ * @pdev: Controller PCI device structure
+ * @id: pci device id structure
+ *
+ * Initialize the PCI device, map BARs, query driver data.
+ * Call mid_setup_dma to complete contoller and chan initilzation
+ */
+int intel_qrk_dma_probe(struct pci_dev *pdev,
+					struct middma_device *device)
+{
+	u32 base_addr, bar_size;
+	int err;
+
+	dev_info(&pdev->dev, "MDMA: probe for %x\n", pdev->device);
+	dev_info(&pdev->dev, "MDMA: CH %d, base %d, block len %d, Periphral mask %x\n",
+				device->max_chan, device->chan_base,
+				device->block_size, device->pimr_mask);
+
+	device->pdev = pci_dev_get(pdev);
+
+	base_addr = pci_resource_start(pdev, 1);
+	bar_size  = pci_resource_len(pdev, 1);
+	device->dma_base = ioremap_nocache(base_addr, DMA_REG_SIZE);
+	if (!device->dma_base) {
+		pr_err("ERR_MDMA:ioremap failed\n");
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	dev_info(&pdev->dev, "Remapped BAR 0x%08x to virt 0x%p\n",
+		base_addr, device->dma_base);
+
+	err = mid_setup_dma(pdev, device);
+	if (err)
+		goto err_dma;
+
+	return 0;
+
+err_dma:
+	iounmap(device->dma_base);
+err_ioremap:
+	pr_err("ERR_MDMA:Probe failed %d\n", err);
+	return err;
+}
+EXPORT_SYMBOL(intel_qrk_dma_probe);
+
+/**
+ * intel_mid_dma_remove -	PCI remove
+ * @pdev: Controller PCI device structure
+ *
+ * Free up all resources and data
+ * Call shutdown_dma to complete contoller and chan cleanup
+ */
+void intel_qrk_dma_remove(struct pci_dev *pdev, struct middma_device *device)
+{
+	//middma_shutdown(pdev, device);
+}
+EXPORT_SYMBOL(intel_qrk_dma_remove);
+
+/* Power Management */
+/*
+* dma_suspend - PCI suspend function
+*
+* @pci: PCI device structure
+* @state: PM message
+*
+* This function is called by OS when a power event occurs
+*/
+int intel_qrk_dma_suspend(struct middma_device *device)
+{
+	int i = 0;
+	pr_debug("MDMA: dma_suspend called\n");
+
+	for (i = 0; i < device->max_chan; i++) {
+		if (device->ch[i].in_use)
+			return -EAGAIN;
+	}
+#if 0
+	dmac1_mask_periphral_intr(device);
+#endif
+	device->state = SUSPENDED;
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_dma_suspend);
+
+/**
+* dma_resume - PCI resume function
+*
+* @pci:	PCI device structure
+*
+* This function is called by OS when a power event occurs
+*/
+int intel_qrk_dma_resume(struct middma_device *device)
+{
+	//return middma_resume(device);
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_dma_resume);
+
+static int intel_qrk_dma_runtime_suspend(struct middma_device *device)
+{
+	device->state = SUSPENDED;
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_dma_runtime_suspend);
+
+static int intel_qrk_dma_runtime_resume(struct middma_device *device)
+{
+	device->state = RUNNING;
+	iowrite32(REG_BIT0, device->dma_base + DMA_CFG);
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_dma_runtime_resume);
+
+
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index d769abf..732ec24 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -168,13 +168,13 @@ config GPIO_VR41XX
 	  Say yes here to support the NEC VR4100 series General-purpose I/O Uint
 
 config GPIO_SCH
-	tristate "Intel SCH/TunnelCreek/Clanton GPIO"
+	tristate "Intel SCH/TunnelCreek/Quark GPIO"
 	depends on PCI && X86
 	select MFD_CORE
 	select LPC_SCH
 	help
 	  Say yes here to support GPIO interface on Intel Poulsbo SCH,
-	  Intel Tunnel Creek processor or Intel Clanton SoC.
+	  Intel Tunnel Creek processor or Intel Quark SoC.
 	  The Intel SCH contains a total of 14 GPIO pins. Ten GPIOs are
 	  powered by the core power rail and are turned off during sleep
 	  modes (S3 and higher). The remaining four GPIOs are powered by
@@ -183,7 +183,7 @@ config GPIO_SCH
 	  system from the Suspend-to-RAM state.
 	  The Intel Tunnel Creek processor has 5 GPIOs powered by the
 	  core power rail and 9 from suspend power supply.
-	  The Intel Clanton has 2 GPIOs powered by the core power well and 6
+	  The Intel Quark has 2 GPIOs powered by the core power well and 6
 	  form the suspend power well.
 
 config GPIO_NANO_8044
diff --git a/drivers/gpio/gpio-sch.c b/drivers/gpio/gpio-sch.c
old mode 100644
new mode 100755
index 4482f7e..e25cc36
--- a/drivers/gpio/gpio-sch.c
+++ b/drivers/gpio/gpio-sch.c
@@ -28,97 +28,175 @@
 #include <linux/pci_ids.h>
 
 #include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
 
 static DEFINE_SPINLOCK(gpio_lock);
 
 #define CGEN	(0x00)
 #define CGIO	(0x04)
 #define CGLV	(0x08)
-#define CGPE	(0x14)
+
+#define CGTPE	(0x0C)
+#define CGTNE	(0x10)
+#define CGGPE	(0x14)
+#define CGSMI	(0x18)
+#define CGTS	(0x1C)
 
 #define RGEN	(0x20)
 #define RGIO	(0x24)
 #define RGLV	(0x28)
-#define RGPE	(0x34)
 
-static unsigned short gpio_ba;
+#define RGTPE   (0x2C)
+#define RGTNE   (0x30)
+#define RGGPE   (0x34)
+#define RGSMI   (0x38)
+#define RGTS    (0x3C)
 
-static void cln_gpio_restrict_release(struct device *dev) {}
-static struct platform_device cln_gpio_restrict_pdev = 
-{
-	.name	= "cln-gpio-restrict-nc",
-	.dev.release = cln_gpio_restrict_release,
+#define CGNMIEN (0x40)
+#define RGNMIEN (0x44)
+
+#define RESOURCE_IRQ	9
+
+static unsigned long gpio_ba;
+
+static int irq_num;
+
+struct sch_gpio_core_int_regvals {
+	u8 cgtpe;
+	u8 cgtne;
+	u8 cggpe;
+	u8 cgsmi;
+	u8 cgnmien;
 };
 
-static int sch_gpio_core_direction_in(struct gpio_chip *gc, unsigned  gpio_num)
+struct  sch_gpio_resume_int_regvals {
+	u8 rgtpe;
+	u8 rgtne;
+	u8 rggpe;
+	u8 rgsmi;
+	u8 rgnmien;
+};
+
+struct sch_gpio {
+	int irq_base_core;
+	struct sch_gpio_core_int_regvals	initial_core;
+	struct sch_gpio_core_int_regvals        lp_core;
+	int irq_base_resume;
+	struct sch_gpio_resume_int_regvals        initial_resume;
+	struct sch_gpio_resume_int_regvals        lp_resume;
+};
+
+static struct sch_gpio *chip_ptr;
+
+static void qrk_gpio_restrict_release(struct device *dev) {}
+static struct platform_device qrk_gpio_restrict_pdev = {
+	.name	= "qrk-gpio-restrict-nc",
+	.dev.release = qrk_gpio_restrict_release,
+};
+
+static void sch_gpio_reg_clear_if_set(unsigned short reg,
+					unsigned short gpio_num)
 {
 	u8 curr_dirs;
 	unsigned short offset, bit;
 
-	spin_lock(&gpio_lock);
-
-	offset = CGIO + gpio_num / 8;
+	offset = reg + gpio_num / 8;
 	bit = gpio_num % 8;
 
 	curr_dirs = inb(gpio_ba + offset);
 
-	if (!(curr_dirs & (1 << bit)))
-		outb(curr_dirs | (1 << bit), gpio_ba + offset);
-
-	spin_unlock(&gpio_lock);
-	return 0;
+	if (curr_dirs & (1 << bit))
+		outb(curr_dirs & ~(1 << bit), gpio_ba + offset);
 }
 
-static int sch_gpio_core_get(struct gpio_chip *gc, unsigned gpio_num)
+static void sch_gpio_reg_set_if_clear(unsigned short reg,
+					unsigned short gpio_num)
 {
-	int res;
+	u8 curr_dirs;
 	unsigned short offset, bit;
 
-	offset = CGLV + gpio_num / 8;
+	offset = reg + gpio_num / 8;
 	bit = gpio_num % 8;
 
-	res = !!(inb(gpio_ba + offset) & (1 << bit));
-	return res;
+	curr_dirs = inb(gpio_ba + offset);
+
+	if (!(curr_dirs & (1 << bit)))
+		outb(curr_dirs | (1 << bit), gpio_ba + offset);
 }
 
-static void sch_gpio_core_set(struct gpio_chip *gc, unsigned gpio_num, int val)
+static void sch_gpio_reg_set(unsigned short reg, unsigned short gpio_num,
+				int val)
 {
-	u8 curr_vals;
+	u8 curr_dirs;
 	unsigned short offset, bit;
 
-	spin_lock(&gpio_lock);
-
-	offset = CGLV + gpio_num / 8;
+	offset = reg + gpio_num / 8;
 	bit = gpio_num % 8;
 
-	curr_vals = inb(gpio_ba + offset);
+	curr_dirs = inb(gpio_ba + offset);
 
 	if (val)
-		outb(curr_vals | (1 << bit), gpio_ba + offset);
+		outb(curr_dirs | (1 << bit), gpio_ba + offset);
 	else
-		outb((curr_vals & ~(1 << bit)), gpio_ba + offset);
-	spin_unlock(&gpio_lock);
+		outb(curr_dirs & ~(1 << bit), gpio_ba + offset);
 }
 
-static int sch_gpio_core_direction_out(struct gpio_chip *gc,
-					unsigned gpio_num, int val)
+static unsigned short sch_gpio_reg_get(unsigned short reg,
+					unsigned short gpio_num)
 {
 	u8 curr_dirs;
 	unsigned short offset, bit;
 
-	sch_gpio_core_set(gc, gpio_num, val);
+	offset = reg + gpio_num / 8;
+	bit = gpio_num % 8;
 
-	spin_lock(&gpio_lock);
+	curr_dirs = !!(inb(gpio_ba + offset) & (1 << bit));
+	
+	return curr_dirs;
+}
 
-	offset = CGIO + gpio_num / 8;
-	bit = gpio_num % 8;
+static int sch_gpio_core_direction_in(struct gpio_chip *gc, unsigned  gpio_num)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_set_if_clear(CGIO, gpio_num);
+	spin_unlock_irqrestore(&gpio_lock, flags);
 
-	curr_dirs = inb(gpio_ba + offset);
-	if (curr_dirs & (1 << bit))
-		outb(curr_dirs & ~(1 << bit), gpio_ba + offset);
+	return 0;
+}
+
+static int sch_gpio_core_get(struct gpio_chip *gc, unsigned gpio_num)
+{
+	int res;
+	res = sch_gpio_reg_get(CGLV, gpio_num);
 
-	spin_unlock(&gpio_lock);
+	return res;
+}
+
+static void sch_gpio_core_set(struct gpio_chip *gc, unsigned gpio_num, int val)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_set(CGLV, gpio_num, val);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+}
+
+static int sch_gpio_core_direction_out(struct gpio_chip *gc,
+					unsigned gpio_num, int val)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_clear_if_set(CGIO, gpio_num);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	
 	return 0;
+}	
+	
+static int sch_gpio_core_to_irq(struct gpio_chip *gc, unsigned offset)
+{
+	return chip_ptr->irq_base_core + offset;
 }
 
 static struct gpio_chip sch_gpio_core = {
@@ -128,63 +206,197 @@ static struct gpio_chip sch_gpio_core = {
 	.get			= sch_gpio_core_get,
 	.direction_output	= sch_gpio_core_direction_out,
 	.set			= sch_gpio_core_set,
+	.to_irq			= sch_gpio_core_to_irq,
 };
 
-static int sch_gpio_resume_direction_in(struct gpio_chip *gc,
-					unsigned gpio_num)
+static void sch_gpio_core_irq_enable(struct irq_data *d)
 {
-	u8 curr_dirs;
+	u32 gpio_num = 0;
 
-	spin_lock(&gpio_lock);
+	gpio_num = d->irq - chip_ptr->irq_base_core;
+	sch_gpio_reg_set_if_clear(CGGPE, gpio_num);
+}
 
-	curr_dirs = inb(gpio_ba + RGIO);
+static void sch_gpio_core_irq_disable(struct irq_data *d)
+{
+	u32 gpio_num = 0;
 
-	if (!(curr_dirs & (1 << gpio_num)))
-		outb(curr_dirs | (1 << gpio_num) , gpio_ba + RGIO);
+	gpio_num = d->irq - chip_ptr->irq_base_core;
+	sch_gpio_reg_clear_if_set(CGGPE, gpio_num);
+}
 
-	spin_unlock(&gpio_lock);
-	return 0;
+static void sch_gpio_core_irq_ack(struct irq_data *d)
+{
+	u32 gpio_num = 0;
+
+	gpio_num = d->irq - chip_ptr->irq_base_core;
+	sch_gpio_reg_set(CGTS, gpio_num, 1);
 }
 
-static int sch_gpio_resume_get(struct gpio_chip *gc, unsigned gpio_num)
+static int sch_gpio_core_irq_type(struct irq_data *d, unsigned type)
 {
-	return !!(inb(gpio_ba + RGLV) & (1 << gpio_num));
+	int ret = 0;
+	unsigned long flags = 0;
+	u32 gpio_num = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n",  __func__);
+		return -EFAULT;
+	}
+
+	gpio_num = d->irq - chip_ptr->irq_base_core;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		sch_gpio_reg_clear_if_set(CGTNE, gpio_num);
+		sch_gpio_reg_set_if_clear(CGTPE, gpio_num);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		sch_gpio_reg_clear_if_set(CGTPE, gpio_num);
+		sch_gpio_reg_set_if_clear(CGTNE, gpio_num);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		sch_gpio_reg_set_if_clear(CGTPE, gpio_num);
+		sch_gpio_reg_set_if_clear(CGTNE, gpio_num);
+		break;
+	case IRQ_TYPE_NONE:
+		sch_gpio_reg_clear_if_set(CGTPE, gpio_num);
+		sch_gpio_reg_clear_if_set(CGTNE, gpio_num);
+		break;
+	default:
+		ret = -EINVAL;
+	break;
+	}
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return ret;
 }
 
-static void sch_gpio_resume_set(struct gpio_chip *gc,
-				unsigned gpio_num, int val)
+static struct irq_chip sch_irq_core = {
+	.irq_ack		= sch_gpio_core_irq_ack,
+	.irq_set_type		= sch_gpio_core_irq_type,
+	.irq_enable		= sch_gpio_core_irq_enable,
+	.irq_disable		= sch_gpio_core_irq_disable,
+};
+
+static void sch_gpio_core_irqs_init(struct sch_gpio *chip, unsigned int num)
 {
-	u8 curr_vals;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		irq_set_chip_data(i + chip->irq_base_core, chip);
+		irq_set_chip_and_handler_name(i + chip->irq_base_core,
+						&sch_irq_core,
+						handle_simple_irq,
+						"sch_gpio_irq_core");
+	}
+}
 
-	spin_lock(&gpio_lock);
+static void sch_gpio_core_irqs_deinit(struct sch_gpio *chip, unsigned int num)
+{
+	int i;
 
-	curr_vals = inb(gpio_ba + RGLV);
+	for (i = 0; i < num; i++) {
+		irq_set_chip_data(i + chip->irq_base_core, 0);
+		irq_set_chip_and_handler_name(i + chip->irq_base_core,
+						0, 0, 0);
+	}
+}
 
-	if (val)
-		outb(curr_vals | (1 << gpio_num), gpio_ba + RGLV);
-	else
-		outb((curr_vals & ~(1 << gpio_num)), gpio_ba + RGLV);
+static void sch_gpio_core_irq_disable_all(struct sch_gpio *chip,
+						unsigned int num)
+{
+	unsigned long flags = 0;
+	u32 gpio_num = 0;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	for (gpio_num = 0; gpio_num < num; gpio_num++) {
+		sch_gpio_reg_clear_if_set(CGTPE, gpio_num);
+		sch_gpio_reg_clear_if_set(CGTNE, gpio_num);
+		sch_gpio_reg_clear_if_set(CGGPE, gpio_num);
+		sch_gpio_reg_clear_if_set(CGSMI, gpio_num);
+		sch_gpio_reg_clear_if_set(CGNMIEN, gpio_num);
+		/* clear any pending interrupt */
+		sch_gpio_reg_set(CGTS, gpio_num, 1);
+	}
 
-	spin_unlock(&gpio_lock);
+	spin_unlock_irqrestore(&gpio_lock, flags);
 }
 
-static int sch_gpio_resume_direction_out(struct gpio_chip *gc,
-					unsigned gpio_num, int val)
+void sch_gpio_core_save_state(struct sch_gpio_core_int_regvals *regs)
 {
-	u8 curr_dirs;
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	regs->cgtpe	= inb(gpio_ba + CGTPE);
+	regs->cgtne	= inb(gpio_ba + CGTNE);
+	regs->cggpe	= inb(gpio_ba + CGGPE);
+	regs->cgsmi	= inb(gpio_ba + CGSMI);
+	regs->cgnmien	= inb(gpio_ba + CGNMIEN);
 
-	sch_gpio_resume_set(gc, gpio_num, val);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+
+void sch_gpio_core_restore_state(struct sch_gpio_core_int_regvals *regs)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
 
-	spin_lock(&gpio_lock);
+	outb(regs->cgtpe, gpio_ba + CGTPE);
+	outb(regs->cgtne, gpio_ba + CGTNE);
+	outb(regs->cggpe, gpio_ba + CGGPE);
+	outb(regs->cgsmi, gpio_ba + CGSMI);
+	outb(regs->cgnmien, gpio_ba + CGNMIEN);
 
-	curr_dirs = inb(gpio_ba + RGIO);
-	if (curr_dirs & (1 << gpio_num))
-		outb(curr_dirs & ~(1 << gpio_num), gpio_ba + RGIO);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
 
-	spin_unlock(&gpio_lock);
+static int sch_gpio_resume_direction_in(struct gpio_chip *gc,
+					unsigned gpio_num)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_set_if_clear(RGIO, gpio_num);
+	spin_unlock_irqrestore(&gpio_lock, flags);
 	return 0;
 }
 
+static int sch_gpio_resume_get(struct gpio_chip *gc, unsigned gpio_num)
+{
+	int res;
+	res = sch_gpio_reg_get(RGLV, gpio_num);
+	return res;
+}
+
+static void sch_gpio_resume_set(struct gpio_chip *gc, unsigned gpio_num,
+					int val)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_set(RGLV, gpio_num, val);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+}
+
+static int sch_gpio_resume_direction_out(struct gpio_chip *gc,
+					unsigned gpio_num, int val)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+	sch_gpio_reg_clear_if_set(RGIO, gpio_num);
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	return 0;
+}
+
+static int sch_gpio_resume_to_irq(struct gpio_chip *gc, unsigned offset)
+{
+	return chip_ptr->irq_base_resume + offset;
+}
+
 static struct gpio_chip sch_gpio_resume = {
 	.label			= "sch_gpio_resume",
 	.owner			= THIS_MODULE,
@@ -192,13 +404,203 @@ static struct gpio_chip sch_gpio_resume = {
 	.get			= sch_gpio_resume_get,
 	.direction_output	= sch_gpio_resume_direction_out,
 	.set			= sch_gpio_resume_set,
+	.to_irq			= sch_gpio_resume_to_irq,
 };
 
+static void sch_gpio_resume_irq_enable(struct irq_data *d)
+{
+	u32 gpio_num = 0;
+
+	gpio_num = d->irq - chip_ptr->irq_base_resume;
+	sch_gpio_reg_set_if_clear(RGGPE, gpio_num);
+}
+
+static void sch_gpio_resume_irq_disable(struct irq_data *d)
+{
+	u32 gpio_num = 0;
+
+	gpio_num = d->irq - chip_ptr->irq_base_resume;
+	sch_gpio_reg_clear_if_set(RGGPE, gpio_num);
+}
+
+static void sch_gpio_resume_irq_ack(struct irq_data *d)
+{
+	u32 gpio_num = 0;
+
+	gpio_num = d->irq - chip_ptr->irq_base_resume;
+	sch_gpio_reg_set(RGTS, gpio_num, 1);
+}
+
+static int sch_gpio_resume_irq_type(struct irq_data *d, unsigned type)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+	u32 gpio_num = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n",  __func__);
+		return -EFAULT;
+	}
+
+	gpio_num = d->irq - chip_ptr->irq_base_resume;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		sch_gpio_reg_clear_if_set(RGTNE, gpio_num);
+		sch_gpio_reg_set_if_clear(RGTPE, gpio_num);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		sch_gpio_reg_clear_if_set(RGTPE, gpio_num);
+		sch_gpio_reg_set_if_clear(RGTNE, gpio_num);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		sch_gpio_reg_set_if_clear(RGTPE, gpio_num);
+		sch_gpio_reg_set_if_clear(RGTNE, gpio_num);
+		break;
+	case IRQ_TYPE_NONE:
+		sch_gpio_reg_clear_if_set(RGTPE, gpio_num);
+		sch_gpio_reg_clear_if_set(RGTNE, gpio_num);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return ret;
+}
+
+static struct irq_chip sch_irq_resume = {
+	.irq_ack		= sch_gpio_resume_irq_ack,
+	.irq_set_type		= sch_gpio_resume_irq_type,
+	.irq_enable		= sch_gpio_resume_irq_enable,
+	.irq_disable		= sch_gpio_resume_irq_disable,
+};
+
+static void sch_gpio_resume_irqs_init(struct sch_gpio *chip, unsigned int num)
+{
+	int i;
+
+	for (i = 0; i < num; i++) {
+		irq_set_chip_data(i + chip->irq_base_resume, chip);
+		irq_set_chip_and_handler_name(i + chip->irq_base_resume,
+						&sch_irq_resume,
+						handle_simple_irq,
+						"sch_gpio_irq_resume");
+	}
+}
+
+static void sch_gpio_resume_irqs_deinit(struct sch_gpio *chip, unsigned int num)
+{
+	int i;
+
+	for (i = 0; i < num; i++) {
+		irq_set_chip_data(i + chip->irq_base_core, 0);
+		irq_set_chip_and_handler_name(i + chip->irq_base_core,
+						0, 0, 0);
+	}
+}
+
+static void sch_gpio_resume_irq_disable_all(struct sch_gpio *chip,
+						unsigned int num)
+{
+	unsigned long flags = 0;
+	u32 gpio_num = 0;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	for (gpio_num = 0; gpio_num < num; gpio_num++) {
+		sch_gpio_reg_clear_if_set(RGTPE, gpio_num);
+		sch_gpio_reg_clear_if_set(RGTNE, gpio_num);
+		sch_gpio_reg_clear_if_set(RGGPE, gpio_num);
+		sch_gpio_reg_clear_if_set(RGSMI, gpio_num);
+		sch_gpio_reg_clear_if_set(RGNMIEN, gpio_num);
+		/* clear any pending interrupt */
+		sch_gpio_reg_set(RGTS, gpio_num, 1);
+	}
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+
+void sch_gpio_resume_save_state(struct sch_gpio_resume_int_regvals *regs)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	regs->rgtpe	= inb(gpio_ba + RGTPE);
+	regs->rgtne	= inb(gpio_ba + RGTNE);
+	regs->rggpe	= inb(gpio_ba + RGGPE);
+	regs->rgsmi	= inb(gpio_ba + RGSMI);
+	regs->rgnmien	= inb(gpio_ba + RGNMIEN);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+
+void sch_gpio_resume_restore_state(struct sch_gpio_resume_int_regvals *regs)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	outb(regs->rgtpe, gpio_ba + RGTPE);
+	outb(regs->rgtne, gpio_ba + RGTNE);
+	outb(regs->rggpe, gpio_ba + RGGPE);
+	outb(regs->rgsmi, gpio_ba + RGSMI);
+	outb(regs->rgnmien, gpio_ba + RGNMIEN);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+
+static irqreturn_t sch_gpio_irq_handler(int irq, void *dev_id)
+{
+	int res;
+	int i, ret = IRQ_NONE;
+
+	for (i = 0; i < sch_gpio_core.ngpio; i++) {
+
+		res = sch_gpio_reg_get(CGTS, i);
+		if (res) {
+			/* clear by setting TS to 1 */
+			sch_gpio_reg_set(CGTS, i, 1);
+
+			generic_handle_irq(chip_ptr->irq_base_core + i);
+			ret = IRQ_HANDLED;
+		}
+	}
+
+	for (i = 0; i < sch_gpio_resume.ngpio; i++) {
+
+		res = sch_gpio_reg_get(RGTS, i);
+		if (res) {
+			/* clear by setting TS to 1 */
+			sch_gpio_reg_set(RGTS, i, 1);
+
+			generic_handle_irq(chip_ptr->irq_base_resume + i);
+			ret = IRQ_HANDLED;
+		}
+	}
+
+	return ret;
+}
+
 static int __devinit sch_gpio_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+	struct sch_gpio *chip;
 	int err, id;
 
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	chip_ptr = chip;
+
+	sch_gpio_core_save_state(&(chip->initial_core));
+	sch_gpio_resume_save_state(&(chip->initial_resume));
+
 	id = pdev->id;
 	if (!id)
 		return -ENODEV;
@@ -211,60 +613,54 @@ static int __devinit sch_gpio_probe(struct platform_device *pdev)
 		return -EBUSY;
 
 	gpio_ba = res->start;
+	
+	irq_num = RESOURCE_IRQ;
 
 	switch (id) {
-		case PCI_DEVICE_ID_INTEL_SCH_LPC:
-			sch_gpio_core.base = 0;
-			sch_gpio_core.ngpio = 10;
-
-			sch_gpio_resume.base = 10;
-			sch_gpio_resume.ngpio = 4;
-
-			/*
-			 * GPIO[6:0] enabled by default
-			 * GPIO7 is configured by the CMC as SLPIOVR
-			 * Enable GPIO[9:8] core powered gpios explicitly
-			 */
-			outb(0x3, gpio_ba + CGEN + 1);
-			/*
-			 * SUS_GPIO[2:0] enabled by default
-			 * Enable SUS_GPIO3 resume powered gpio explicitly
-			 */
-			outb(0x8, gpio_ba + RGEN);
-			break;
-
-		case PCI_DEVICE_ID_INTEL_ITC_LPC:
-			sch_gpio_core.base = 0;
-			sch_gpio_core.ngpio = 5;
-
-			sch_gpio_resume.base = 5;
-			sch_gpio_resume.ngpio = 9;
-			break;
-
-		case PCI_DEVICE_ID_INTEL_CLANTON_ILB:
-			sch_gpio_core.base = 0;
-			sch_gpio_core.ngpio = 2;
-
-			sch_gpio_resume.base = 2;
-			sch_gpio_resume.ngpio = 6;
-			break;
-
-		default:
-			return -ENODEV;
+	case PCI_DEVICE_ID_INTEL_SCH_LPC:
+		sch_gpio_core.base = 0;
+		sch_gpio_core.ngpio = 10;
+
+		sch_gpio_resume.base = 10;
+		sch_gpio_resume.ngpio = 4;
+
+		/*
+		 * GPIO[6:0] enabled by default
+		 * GPIO7 is configured by the CMC as SLPIOVR
+		 * Enable GPIO[9:8] core powered gpios explicitly
+		 */
+		outb(0x3, gpio_ba + CGEN + 1);
+		/*
+		 * SUS_GPIO[2:0] enabled by default
+		 * Enable SUS_GPIO3 resume powered gpio explicitly
+		 */
+		outb(0x8, gpio_ba + RGEN);
+		break;
+
+	case PCI_DEVICE_ID_INTEL_ITC_LPC:
+		sch_gpio_core.base = 0;
+		sch_gpio_core.ngpio = 5;
+
+		sch_gpio_resume.base = 5;
+		sch_gpio_resume.ngpio = 9;
+		break;
+
+	case PCI_DEVICE_ID_INTEL_QUARK_ILB:
+		sch_gpio_core.base = 0;
+		sch_gpio_core.ngpio = 2;
+
+		sch_gpio_resume.base = 2;
+		sch_gpio_resume.ngpio = 6;
+		break;
+
+	default:
+		err = -ENODEV;
+		goto err_sch_gpio_core;
 	}
 
 	sch_gpio_core.dev = &pdev->dev;
 	sch_gpio_resume.dev = &pdev->dev;
 
-	pr_info("Initial Core-Well GPE %x Resume-Well GPE %x\n",
-		inb(gpio_ba + CGPE), inb(gpio_ba + RGPE));
-
-	outb(0, gpio_ba + CGPE);
-	outb(0, gpio_ba + RGPE);
-
-	pr_info("New Core-Well GPE %x Resume-Well GPE %x\n",
-		inb(gpio_ba + CGPE), inb(gpio_ba + RGPE));
-
 	err = gpiochip_add(&sch_gpio_core);
 	if (err < 0)
 		goto err_sch_gpio_core;
@@ -273,50 +669,145 @@ static int __devinit sch_gpio_probe(struct platform_device *pdev)
 	if (err < 0)
 		goto err_sch_gpio_resume;
 
-	err = platform_device_register(&cln_gpio_restrict_pdev);
+	chip->irq_base_core = irq_alloc_descs(-1, 0,
+						sch_gpio_core.ngpio,
+						NUMA_NO_NODE);
+	if (chip->irq_base_core < 0) {
+		dev_err(&pdev->dev, "failure adding GPIO core IRQ descs\n");
+		chip->irq_base_core = -1;
+		goto err_sch_intr_core;
+	}
+
+	chip->irq_base_resume = irq_alloc_descs(-1, 0,
+						sch_gpio_resume.ngpio,
+						NUMA_NO_NODE);
+	if (chip->irq_base_resume < 0) {
+		dev_err(&pdev->dev, "failure adding GPIO resume IRQ descs\n");
+		chip->irq_base_resume = -1;
+		goto err_sch_intr_resume;
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	err = platform_device_register(&qrk_gpio_restrict_pdev);
 	if (err < 0)
-		goto err_sch_gpio_resume;
+		goto err_sch_gpio_device_register;
+
+	/* disable interrupts */
+	sch_gpio_core_irq_disable_all(chip, sch_gpio_core.ngpio);
+	sch_gpio_resume_irq_disable_all(chip, sch_gpio_resume.ngpio);
+
+	err = request_irq(irq_num, sch_gpio_irq_handler,
+				IRQF_SHARED, KBUILD_MODNAME, chip);
+	if (err != 0) {
+			dev_err(&pdev->dev,
+				"%s request_irq failed\n", __func__);
+			goto err_sch_request_irq;
+	}
+
+	sch_gpio_core_irqs_init(chip, sch_gpio_core.ngpio);
+	sch_gpio_resume_irqs_init(chip, sch_gpio_resume.ngpio);
 
 	return 0;
 
+err_sch_request_irq:
+	platform_device_unregister(&qrk_gpio_restrict_pdev);
+
+err_sch_gpio_device_register:
+	irq_free_descs(chip->irq_base_resume, sch_gpio_resume.ngpio);
+
+err_sch_intr_resume:
+	irq_free_descs(chip->irq_base_core, sch_gpio_core.ngpio);
+
+err_sch_intr_core:
+	err = gpiochip_remove(&sch_gpio_resume);
+	if (err)
+		dev_err(&pdev->dev, "%s failed, %d\n",
+		"resume gpiochip_remove()", err);
+
 err_sch_gpio_resume:
 	err = gpiochip_remove(&sch_gpio_core);
 	if (err)
 		dev_err(&pdev->dev, "%s failed, %d\n",
-				"gpiochip_remove()", err);
+		"core gpiochip_remove()", err);
 
 err_sch_gpio_core:
 	release_region(res->start, resource_size(res));
 	gpio_ba = 0;
 
+	sch_gpio_resume_restore_state(&(chip->initial_resume));
+	sch_gpio_core_restore_state(&(chip->initial_core));
+
+	kfree(chip);
+	chip_ptr = 0;
+
 	return err;
 }
 
 static int __devexit sch_gpio_remove(struct platform_device *pdev)
 {
+	int err = 0;	
 	struct resource *res;
+
+	struct sch_gpio *chip = platform_get_drvdata(pdev);
+
 	if (gpio_ba) {
-		int err;
+		sch_gpio_resume_irqs_deinit(chip, sch_gpio_resume.ngpio);
+		sch_gpio_core_irqs_deinit(chip, sch_gpio_core.ngpio);
 
-		platform_device_unregister(&cln_gpio_restrict_pdev);
+		if (irq_num > 0)
+			free_irq(irq_num, chip);
 
-		err  = gpiochip_remove(&sch_gpio_core);
+		platform_device_unregister(&qrk_gpio_restrict_pdev);
+
+		irq_free_descs(chip->irq_base_resume,
+				sch_gpio_resume.ngpio);
+
+		irq_free_descs(chip->irq_base_core, sch_gpio_core.ngpio);
+
+		err = gpiochip_remove(&sch_gpio_resume);
 		if (err)
 			dev_err(&pdev->dev, "%s failed, %d\n",
-				"gpiochip_remove()", err);
-		err = gpiochip_remove(&sch_gpio_resume);
+				"resume gpiochip_remove()", err);
+
+		err  = gpiochip_remove(&sch_gpio_core);
 		if (err)
 			dev_err(&pdev->dev, "%s failed, %d\n",
-				"gpiochip_remove()", err);
+				"core gpiochip_remove()", err);
 
 		res = platform_get_resource(pdev, IORESOURCE_IO, 0);
 
 		release_region(res->start, resource_size(res));
 		gpio_ba = 0;
-
-		return err;
 	}
 
+	sch_gpio_resume_restore_state(&(chip->initial_resume));
+	sch_gpio_core_restore_state(&(chip->initial_core));
+
+	kfree(chip);
+
+	chip_ptr = 0;
+
+	return err;
+}
+
+static int sch_gpio_suspend_sys(struct platform_device *pdev,
+				pm_message_t state)
+{
+	sch_gpio_core_save_state(&(chip_ptr->lp_core));
+	sch_gpio_resume_save_state(&(chip_ptr->lp_resume));
+
+	sch_gpio_resume_restore_state(&(chip_ptr->initial_resume));
+	sch_gpio_core_restore_state(&(chip_ptr->initial_core));
+
+	return 0;
+}
+
+static int sch_gpio_resume_sys(struct platform_device *pdev)
+{
+	sch_gpio_resume_restore_state(&(chip_ptr->lp_resume));
+	sch_gpio_core_restore_state(&(chip_ptr->lp_core));
+
 	return 0;
 }
 
@@ -327,6 +818,8 @@ static struct platform_driver sch_gpio_driver = {
 	},
 	.probe		= sch_gpio_probe,
 	.remove		= __devexit_p(sch_gpio_remove),
+	.suspend	= sch_gpio_suspend_sys,
+	.resume		= sch_gpio_resume_sys,
 };
 
 module_platform_driver(sch_gpio_driver);
diff --git a/drivers/iio/accel/Kconfig b/drivers/iio/accel/Kconfig
index 5021a16..0597a81 100644
--- a/drivers/iio/accel/Kconfig
+++ b/drivers/iio/accel/Kconfig
@@ -14,8 +14,8 @@ config HID_SENSOR_ACCEL_3D
 	  Say yes here to build support for the HID SENSOR
 	  accelerometers 3D.
 
-config IIO_LIS331DLH_INTEL_CLN
-	tristate "STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Clanton platform"
+config IIO_LIS331DLH_INTEL_QRK
+	tristate "STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Quark platform"
 	depends on INTEL_QUARK_X1000_SOC
 	depends on I2C && SYSFS
 	select IIO_ST_SENSORS_CORE
diff --git a/drivers/iio/accel/Makefile b/drivers/iio/accel/Makefile
index 16f8e38..5f99629 100644
--- a/drivers/iio/accel/Makefile
+++ b/drivers/iio/accel/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-$(CONFIG_HID_SENSOR_ACCEL_3D) += hid-sensor-accel-3d.o
-obj-$(CONFIG_IIO_LIS331DLH_INTEL_CLN) += lis331dlh_intel_cln.o
+obj-$(CONFIG_IIO_LIS331DLH_INTEL_QRK) += lis331dlh_intel_qrk.o
diff --git a/drivers/iio/accel/lis331dlh_intel_cln.c b/drivers/iio/accel/lis331dlh_intel_cln.c
deleted file mode 100644
index c76c30a..0000000
--- a/drivers/iio/accel/lis331dlh_intel_cln.c
+++ /dev/null
@@ -1,735 +0,0 @@
-/*
- * Intel Clanton Hill platform accelerometer driver
- *
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- *
- * Derived from STMicroelectronics accelerometers driver by Denis Ciocca
- *
- * The Intel Clanton Hill platform hardware design includes an
- * STMicroelectronics LIS331DLH accelerometer, intended to be used mainly for
- * sensing orientation, movement and sudden impacts (e.g. vehicle collision)
- *
- * This driver plugs into the Linux Industrial-IO framework to provide a
- * standardised user-space application interface for retreiving data and events
- * from the accelerometer.
- *
- * The LIS331DLH is connected via I2C to the host CPU on the Clanton Hill
- * platform and so this driver registers to the kernel as an I2C device driver
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <linux/iio/iio.h>
-#include <linux/iio/sysfs.h>
-#include <linux/iio/events.h>
-
-#include <linux/iio/common/st_sensors.h>
-#include <linux/iio/common/st_sensors_i2c.h>
-
-#include <linux/platform_data/lis331dlh_intel_cln.h>
-
-/* DEFAULT VALUE FOR SENSORS */
-#define ST_ACCEL_DEFAULT_OUT_X_L_ADDR		0x28
-#define ST_ACCEL_DEFAULT_OUT_Y_L_ADDR		0x2a
-#define ST_ACCEL_DEFAULT_OUT_Z_L_ADDR		0x2c
-
-/* FULLSCALE */
-#define ST_ACCEL_FS_AVL_2G			2
-#define ST_ACCEL_FS_AVL_4G			4
-#define ST_ACCEL_FS_AVL_6G			6
-#define ST_ACCEL_FS_AVL_8G			8
-#define ST_ACCEL_FS_AVL_16G			16
-
-/* CUSTOM VALUES FOR SENSOR 2 */
-#define ST_ACCEL_2_WAI_EXP			0x32
-#define ST_ACCEL_2_ODR_ADDR			0x20
-#define ST_ACCEL_2_ODR_MASK			0x18
-#define ST_ACCEL_2_ODR_AVL_50HZ_VAL		0x00
-#define ST_ACCEL_2_ODR_AVL_100HZ_VAL		0x01
-#define ST_ACCEL_2_ODR_AVL_400HZ_VAL		0x02
-#define ST_ACCEL_2_ODR_AVL_1000HZ_VAL		0x03
-#define ST_ACCEL_2_PW_ADDR			0x20
-#define ST_ACCEL_2_PW_MASK			0xe0
-#define ST_ACCEL_2_PW_DOWN			0x00
-#define ST_ACCEL_2_PW_NORMAL		0x20
-#define ST_ACCEL_2_CTRL_REG1_XEN	0x01
-#define ST_ACCEL_2_CTRL_REG1_YEN	0x02
-#define ST_ACCEL_2_CTRL_REG1_ZEN	0x04
-#define ST_ACCEL_2_FS_ADDR			0x23
-#define ST_ACCEL_2_FS_MASK			0x30
-#define ST_ACCEL_2_FS_AVL_2_VAL			0X00
-#define ST_ACCEL_2_FS_AVL_4_VAL			0X01
-#define ST_ACCEL_2_FS_AVL_8_VAL			0x03
-#define ST_ACCEL_2_FS_AVL_2_GAIN		IIO_G_TO_M_S_2(1000)
-#define ST_ACCEL_2_FS_AVL_4_GAIN		IIO_G_TO_M_S_2(2000)
-#define ST_ACCEL_2_FS_AVL_8_GAIN		IIO_G_TO_M_S_2(3900)
-#define ST_ACCEL_2_BDU_ADDR			0x23
-#define ST_ACCEL_2_BDU_MASK			0x80
-#define ST_ACCEL_2_DRDY_IRQ_ADDR		0x22
-#define ST_ACCEL_2_DRDY_IRQ_MASK		0x02
-#define ST_ACCEL_2_THRESH_IRQ_ADDR		0x30
-#define ST_ACCEL_2_THRESH_IRQ_MASK		0x7f
-#define ST_ACCEL_2_INT1_CFG_ADDR		0x30
-#define ST_ACCEL_2_INT1_SRC_ADDR		0x31
-#define ST_ACCEL_2_INT1_THRESH_ADDR		0x32
-#define ST_ACCEL_2_INT1_DURATION_ADDR		0x33
-#define ST_ACCEL_2_INT2_CFG_ADDR		0x34
-#define ST_ACCEL_2_INT2_SRC_ADDR		0x35
-#define ST_ACCEL_2_INT2_THRESH_ADDR		0x36
-#define ST_ACCEL_2_INT2_DURATION_ADDR		0x37
-#define ST_ACCEL_2_INT_IA_MASK			0x40
-#define ST_ACCEL_2_INT_LIR_MASK			0x05
-#define ST_ACCEL_2_INT_SRC_HIGH_MASK	0x20
-#define ST_ACCEL_2_INT_CFG_XLIE_EN		0x01
-#define ST_ACCEL_2_INT_CFG_XHIE_EN		0x02
-#define ST_ACCEL_2_INT_CFG_YLIE_EN		0x04
-#define ST_ACCEL_2_INT_CFG_YHIE_EN		0x08
-#define ST_ACCEL_2_INT_CFG_ZLIE_EN		0x10
-#define ST_ACCEL_2_INT_CFG_ZHIE_EN		0x20
-
-#define ST_ACCEL_2_MULTIREAD_BIT		true
-#define ST_ACCEL_2_THRESH_VAL_MIN		0x00
-#define ST_ACCEL_2_THRESH_VAL_MAX		0x7f
-#define CLN_ACCEL_INT2_WAKEUP_THRESH_VAL	0x7f
-
-#define CLN_ACCEL_INT1_DISABLED			0
-#define CLN_ACCEL_INT1_ENABLED			1
-
-#define CLN_ACCEL_LSM_CHANNELS(device_type, index, mod, endian, bits, addr) \
-{ \
-	.type = device_type, \
-	.modified = 1, \
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
-			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
-	.scan_index = index, \
-	.channel = mod, \
-	.channel2 = mod, \
-	.address = addr, \
-	.scan_type = { \
-		.sign = 's', \
-		.realbits = bits, \
-		.shift = 16 - bits, \
-		.storagebits = 16, \
-		.endianness = endian, \
-	}, \
-	.event_mask = IIO_EV_BIT(IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), \
-}
-
-static const u8 iio_modifier_map[] = {
-	IIO_NO_MOD,
-	IIO_MOD_X,
-	IIO_MOD_Y,
-	IIO_MOD_X_AND_Y,
-	IIO_MOD_Z,
-	IIO_MOD_X_AND_Z,
-	IIO_MOD_Y_AND_Z,
-	IIO_MOD_X_AND_Y_AND_Z,
-};
-
-/*  Threshold event ISR bottom half.  This function reads interrupt status
- *  registers for INT1 to reset any active interrupt conditions
- *  and pushes an IIO event if a threshold interrupt was active.
- */
-static irqreturn_t lis331dlh_intel_cln_threshold_event_handler(
-	int irq,
-	void *private)
-{
-	int err;
-	u8 data;
-	u8 mask;
-	int i;
-	u64 iio_modifier;
-
-	struct st_sensor_data *sdata = iio_priv(private);
-	s64 timestamp = iio_get_time_ns();
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-			ST_ACCEL_2_INT1_SRC_ADDR,
-			&data);
-
-	if (err < 0)
-		goto st_sensors_read_err;
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-			ST_ACCEL_2_INT1_CFG_ADDR,
-				&mask);
-
-	if (err < 0)
-		goto st_sensors_read_err;
-
-	if (data & ST_ACCEL_2_INT_IA_MASK) {
-		data &= mask;
-
-		iio_modifier = 0;
-		for (i = 0; i < ST_SENSORS_NUMBER_DATA_CHANNELS; i++) {
-			iio_modifier <<= 1;
-			iio_modifier += !!(data & ST_ACCEL_2_INT_SRC_HIGH_MASK);
-			data <<= 2;
-		}
-
-		iio_modifier = iio_modifier_map[iio_modifier];
-
-		iio_push_event(private,
-				IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				0,
-				iio_modifier,
-				IIO_EV_TYPE_THRESH,
-				IIO_EV_DIR_RISING),
-				timestamp);
-	}
-
-st_sensors_read_err:
-	return IRQ_HANDLED;
-}
-
-static inline int lis331dlh_intel_cln_read_info_raw(struct iio_dev *indio_dev,
-				struct iio_chan_spec const *ch, int *val)
-{
-	int err;
-
-	mutex_lock(&indio_dev->mlock);
-	err = st_sensors_read_axis_data(indio_dev, ch->address, val);
-
-	if (unlikely(err < 0))
-		goto read_error;
-
-	*val = *val >> ch->scan_type.shift;
-	mutex_unlock(&indio_dev->mlock);
-
-	return err;
-
-read_error:
-	mutex_unlock(&indio_dev->mlock);
-	return err;
-}
-
-static int lis331dlh_intel_cln_read_raw(
-	struct iio_dev *indio_dev,
-	struct iio_chan_spec const *ch,
-	int *val, int *val2, long mask)
-{
-	int err;
-	struct st_sensor_data *adata = iio_priv(indio_dev);
-
-	switch (mask) {
-	case IIO_CHAN_INFO_RAW:
-		err = lis331dlh_intel_cln_read_info_raw(indio_dev, ch, val);
-		if (unlikely(err < 0))
-			goto read_error;
-
-		return IIO_VAL_INT;
-	case IIO_CHAN_INFO_SCALE:
-		*val = 0;
-		*val2 = adata->current_fullscale->gain;
-		return IIO_VAL_INT_PLUS_MICRO;
-	default:
-		return -EINVAL;
-	}
-
-read_error:
-	return err;
-}
-
-static int lis331dlh_intel_cln_write_raw(
-	struct iio_dev *indio_dev,
-	struct iio_chan_spec const *chan,
-	int val, int val2, long mask)
-{
-	int err;
-
-	switch (mask) {
-	case IIO_CHAN_INFO_SCALE:
-		err = st_sensors_set_fullscale_by_gain(indio_dev, val2);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return err;
-}
-
-static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
-static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
-static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
-
-static struct attribute *lis331dlh_intel_cln_attributes[] = {
-	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
-	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
-	&iio_dev_attr_sampling_frequency.dev_attr.attr,
-	NULL,
-};
-
-static const struct attribute_group lis331dlh_intel_cln_attribute_group = {
-	.attrs = lis331dlh_intel_cln_attributes,
-};
-
-static int lis331dlh_intel_cln_read_event_value(
-	struct iio_dev *indio_dev,
-	u64 event_code,
-	int *val)
-{
-	int err;
-	u8 data;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-				ST_ACCEL_2_INT1_THRESH_ADDR, &data);
-
-	*val = (int) data;
-	return err;
-}
-
-static int lis331dlh_intel_cln_write_event_value(
-	struct iio_dev *indio_dev,
-	u64 event_code,
-	int val)
-{
-	int err;
-	struct st_sensor_data *sdata;
-
-	/* range check */
-	if (unlikely((val < ST_ACCEL_2_THRESH_VAL_MIN) ||
-				 (val > ST_ACCEL_2_THRESH_VAL_MAX)))
-		return -EINVAL;
-
-	sdata = iio_priv(indio_dev);
-
-	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-				ST_ACCEL_2_INT1_THRESH_ADDR, val);
-
-	return err;
-}
-
-/*  Configure the INT1 pin to fire an interrupt on a high threshold event.
- */
-static int lis331dlh_intel_cln_configure_threshold_interrupt(
-	struct iio_dev *indio_dev, u8 state)
-{
-	int err = 0;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-
-	if (sdata->sensor->drdy_irq.ig1.en_mask == state)
-		return 0;
-
-	if (state == CLN_ACCEL_INT1_ENABLED) {
-		err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
-				NULL,
-				lis331dlh_intel_cln_threshold_event_handler,
-				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
-				"lis331dlh_intel_cln_threshold",
-				indio_dev);
-		if (likely(err == 0)) {
-			sdata->sensor->drdy_irq.ig1.en_mask =
-					CLN_ACCEL_INT1_ENABLED;
-			err = sdata->tf->write_byte(
-				&sdata->tb, sdata->dev,
-				ST_ACCEL_2_INT1_DURATION_ADDR, 1);
-		}
-	} else {
-		free_irq(sdata->get_irq_data_ready(indio_dev), indio_dev);
-		sdata->sensor->drdy_irq.ig1.en_mask = CLN_ACCEL_INT1_DISABLED;
-	}
-
-	return err;
-}
-
-static int lis331dlh_intel_cln_read_event_config(
-	struct iio_dev *indio_dev,
-	u64 event_code)
-{
-	int err = 0;
-	u8 data, mask;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-				   ST_ACCEL_2_INT1_CFG_ADDR,
-				   &data);
-
-	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
-
-	return !!(data & mask);
-}
-
-static int lis331dlh_intel_cln_write_event_config(
-	struct iio_dev *indio_dev,
-	u64 event_code,
-	int state)
-{
-	int err;
-	u8 data;
-	u8 mask;
-
-	bool new_int_state;
-
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
-
-	err = st_sensors_write_data_with_mask(indio_dev,
-					ST_ACCEL_2_INT1_CFG_ADDR,
-					mask, state);
-	if (unlikely(err < 0))
-		goto write_event_err;
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-					ST_ACCEL_2_INT1_CFG_ADDR, &data);
-	if (unlikely(err < 0))
-		goto write_event_err;
-
-	new_int_state = data & (ST_ACCEL_2_INT_CFG_XHIE_EN |
-					ST_ACCEL_2_INT_CFG_YHIE_EN |
-					ST_ACCEL_2_INT_CFG_ZHIE_EN);
-	err = lis331dlh_intel_cln_configure_threshold_interrupt(
-			indio_dev, new_int_state);
-
-write_event_err:
-	return err;
-}
-
-/*  Configure the INT2 pin to fire an interrupt on a threshold high event.  INT2
- *  should be wired to a suspend well IRQ to wake up the host.
- */
-static int lis331dlh_intel_cln_enable_wakeup_interrupt(
-	struct iio_dev *indio_dev)
-{
-	int err = 0;
-	u8 data;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-
-	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-					ST_ACCEL_2_INT2_THRESH_ADDR,
-					CLN_ACCEL_INT2_WAKEUP_THRESH_VAL);
-	if (unlikely(err < 0))
-		goto enable_wakeup_int_err;
-
-	/* Latch interrupt request on INT2 */
-	err = st_sensors_write_data_with_mask(
-			indio_dev, ST_ACCEL_2_DRDY_IRQ_ADDR,
-			ST_ACCEL_2_INT_LIR_MASK, 1);
-	if (unlikely(err < 0))
-		goto enable_wakeup_int_err;
-
-	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-					ST_ACCEL_2_INT2_DURATION_ADDR, 0);
-	if (unlikely(err < 0))
-		goto enable_wakeup_int_err;
-
-	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-						ST_ACCEL_2_INT2_CFG_ADDR,
-						ST_ACCEL_2_INT_CFG_XHIE_EN |
-						ST_ACCEL_2_INT_CFG_YHIE_EN);
-	if (unlikely(err < 0))
-		goto enable_wakeup_int_err;
-
-	/* Clean ST_ACCEL_2_INT2_SRC */
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-						ST_ACCEL_2_INT2_SRC_ADDR,
-						&data);
-
-enable_wakeup_int_err:
-	return err;
-}
-
-static int lis331dlh_intel_cln_disable_wakeup_interrupt(
-	struct iio_dev *indio_dev)
-{
-	int err = 0;
-	u8 data;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-
-	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
-						ST_ACCEL_2_INT2_CFG_ADDR,
-						0);
-	if (unlikely(err < 0))
-		goto disable_wakeup_int_err;
-
-	/* Clean ST_ACCEL_2_INT2_SRC */
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-						ST_ACCEL_2_INT2_SRC_ADDR,
-						&data);
-	if (unlikely(err < 0))
-		goto disable_wakeup_int_err;
-
-disable_wakeup_int_err:
-	return err;
-}
-
-static int lis331dlh_intel_cln_handle_wakeup_interrupt(
-	struct iio_dev *indio_dev)
-{
-	int err;
-	u8 data;
-	struct st_sensor_data *sdata = iio_priv(indio_dev);
-	s64 timestamp = iio_get_time_ns();
-
-	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
-				   ST_ACCEL_2_INT2_SRC_ADDR,
-				   &data);
-	if (unlikely(err < 0))
-		goto handle_wakeup_int_err;
-
-	if (data & ST_ACCEL_2_INT_IA_MASK) {
-		iio_push_event(indio_dev,
-				IIO_MOD_EVENT_CODE(IIO_ACCEL,
-				0,
-				IIO_MOD_X_OR_Y_OR_Z,
-				IIO_EV_TYPE_THRESH,
-				IIO_EV_DIR_EITHER),
-				timestamp);
-	}
-
-handle_wakeup_int_err:
-	return err;
-}
-
-static const struct iio_info accel_info = {
-	.driver_module = THIS_MODULE,
-	.attrs = &lis331dlh_intel_cln_attribute_group,
-	.read_raw = &lis331dlh_intel_cln_read_raw,
-	.write_raw = &lis331dlh_intel_cln_write_raw,
-	.read_event_config = &lis331dlh_intel_cln_read_event_config,
-	.write_event_config = &lis331dlh_intel_cln_write_event_config,
-	.read_event_value = &lis331dlh_intel_cln_read_event_value,
-	.write_event_value = &lis331dlh_intel_cln_write_event_value,
-};
-
-static const struct iio_chan_spec st_accel_12bit_channels[] = {
-	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
-		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_X_L_ADDR),
-	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
-		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Y_L_ADDR),
-	CLN_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
-		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Z_L_ADDR),
-	IIO_CHAN_SOFT_TIMESTAMP(3)
-};
-
-static struct st_sensors lis331dlh_intel_cln_sensor = {
-	.wai = ST_ACCEL_2_WAI_EXP,
-	.sensors_supported = {
-		[0] = "lis331dlh_cln",
-	},
-	.ch = (struct iio_chan_spec *)st_accel_12bit_channels,
-	.odr = {
-		.addr = ST_ACCEL_2_ODR_ADDR,
-		.mask = ST_ACCEL_2_ODR_MASK,
-		.odr_avl = {
-			{ 50, ST_ACCEL_2_ODR_AVL_50HZ_VAL, },
-			{ 100, ST_ACCEL_2_ODR_AVL_100HZ_VAL, },
-			{ 400, ST_ACCEL_2_ODR_AVL_400HZ_VAL, },
-			{ 1000, ST_ACCEL_2_ODR_AVL_1000HZ_VAL, },
-		},
-	},
-	.pw = {
-		.addr = ST_ACCEL_2_PW_ADDR,
-		.mask = ST_ACCEL_2_PW_MASK,
-		.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,
-		.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,
-	},
-	.enable_axis = {
-		.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,
-		.mask = ST_SENSORS_DEFAULT_AXIS_MASK,
-	},
-	.fs = {
-		.addr = ST_ACCEL_2_FS_ADDR,
-		.mask = ST_ACCEL_2_FS_MASK,
-		.fs_avl = {
-			[0] = {
-				.num = ST_ACCEL_FS_AVL_2G,
-				.value = ST_ACCEL_2_FS_AVL_2_VAL,
-				.gain = ST_ACCEL_2_FS_AVL_2_GAIN,
-			},
-			[1] = {
-				.num = ST_ACCEL_FS_AVL_4G,
-				.value = ST_ACCEL_2_FS_AVL_4_VAL,
-				.gain = ST_ACCEL_2_FS_AVL_4_GAIN,
-			},
-			[2] = {
-				.num = ST_ACCEL_FS_AVL_8G,
-				.value = ST_ACCEL_2_FS_AVL_8_VAL,
-				.gain = ST_ACCEL_2_FS_AVL_8_GAIN,
-			},
-		},
-	},
-	.bdu = {
-		.addr = ST_ACCEL_2_BDU_ADDR,
-		.mask = ST_ACCEL_2_BDU_MASK,
-	},
-	.drdy_irq = {
-		.addr = ST_ACCEL_2_DRDY_IRQ_ADDR,
-		.mask = ST_ACCEL_2_DRDY_IRQ_MASK,
-	},
-	.multi_read_bit = ST_ACCEL_2_MULTIREAD_BIT,
-	.bootime = 2,
-};
-
-static int lis331dlh_intel_cln_probe(
-	struct i2c_client *client,
-	const struct i2c_device_id *id)
-{
-	struct iio_dev *indio_dev;
-	struct st_sensor_data *adata;
-	struct lis331dlh_intel_cln_platform_data *pdata;
-	int ret = 0;
-
-	indio_dev = iio_device_alloc(sizeof(*adata));
-	if (unlikely(indio_dev == NULL)) {
-		ret = -ENOMEM;
-		goto iio_device_alloc_error;
-	}
-
-	i2c_set_clientdata(client, indio_dev);
-	indio_dev->dev.parent = &client->dev;
-	indio_dev->name = client->name;
-
-	adata = iio_priv(indio_dev);
-	adata->dev = &client->dev;
-
-	pdata = client->dev.platform_data;
-	if (unlikely(!pdata)) {
-		pr_err("No platform data provided\n");
-		goto lis331dlh_intel_cln_init_err;
-	}
-
-	ret = gpio_to_irq(pdata->irq1_pin);
-	if (unlikely(ret < 0)) {
-		pr_err(
-			"Failed to obtain valid IRQ for GPIO %d, "
-			"gpio_to_irq returned %d\n",
-			pdata->irq1_pin, ret);
-		goto lis331dlh_intel_cln_init_err;
-	}
-	to_i2c_client(adata->dev)->irq = ret;
-
-	st_sensors_i2c_configure(indio_dev, client, adata);
-
-	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->info = &accel_info;
-
-	ret = st_sensors_check_device_support(indio_dev,
-						1, &lis331dlh_intel_cln_sensor);
-	if (unlikely(ret < 0))
-		goto lis331dlh_intel_cln_init_err;
-
-	indio_dev->channels = adata->sensor->ch;
-	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
-
-	adata->multiread_bit = adata->sensor->multi_read_bit;
-	adata->current_fullscale = (struct st_sensor_fullscale_avl *)
-		&adata->sensor->fs.fs_avl[0];
-	adata->odr = adata->sensor->odr.odr_avl[0].hz;
-
-	adata->sensor->drdy_irq.ig1.en_mask = CLN_ACCEL_INT1_DISABLED;
-
-	ret = st_sensors_init_sensor(indio_dev);
-	if (unlikely(ret < 0))
-		goto lis331dlh_intel_cln_init_err;
-
-	ret = st_sensors_set_enable(indio_dev, true);
-	if (unlikely(ret < 0))
-		goto lis331dlh_intel_cln_init_err;
-
-	ret = iio_device_register(indio_dev);
-	if (unlikely(ret))
-		goto lis331dlh_intel_cln_init_err;
-
-	return 0;
-
-lis331dlh_intel_cln_init_err:
-	iio_device_free(indio_dev);
-iio_device_alloc_error:
-	return ret;
-}
-
-static int lis331dlh_intel_cln_remove(
-	struct i2c_client *client)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(client);
-	struct st_sensor_data *adata = iio_priv(indio_dev);
-
-	st_sensors_set_enable(indio_dev, false);
-
-	if (adata->sensor->drdy_irq.ig1.en_mask == CLN_ACCEL_INT1_ENABLED)
-		free_irq(adata->get_irq_data_ready(indio_dev), indio_dev);
-
-	iio_device_unregister(indio_dev);
-
-	iio_device_free(indio_dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int lis331dlh_intel_cln_suspend(
-	struct device *dev)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-
-	lis331dlh_intel_cln_enable_wakeup_interrupt(indio_dev);
-
-	return 0;
-}
-
-static int lis331dlh_intel_cln_resume(
-	struct device *dev)
-{
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
-
-	lis331dlh_intel_cln_handle_wakeup_interrupt(indio_dev);
-	lis331dlh_intel_cln_disable_wakeup_interrupt(indio_dev);
-
-	return 0;
-}
-
-static const struct dev_pm_ops lis331dlh_intel_cln_pm_ops = {
-	.suspend = lis331dlh_intel_cln_suspend,
-	.resume = lis331dlh_intel_cln_resume,
-};
-
-#define LIS331DLH_INTEL_CLN_PM_OPS (&lis331dlh_intel_cln_pm_ops)
-#else
-#define LIS331DLH_INTEL_CLN_PM_OPS NULL
-#endif
-
-static const struct i2c_device_id lis331dlh_intel_cln_id_table[] = {
-	{ "lis331dlh_cln" },
-	{},
-};
-MODULE_DEVICE_TABLE(i2c, lis331dlh_intel_cln_id_table);
-
-static struct i2c_driver lis331dlh_intel_cln_driver = {
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = "lis331dlh_cln",
-		.pm	= LIS331DLH_INTEL_CLN_PM_OPS,
-	},
-	.probe = lis331dlh_intel_cln_probe,
-	.remove = lis331dlh_intel_cln_remove,
-	.id_table = lis331dlh_intel_cln_id_table,
-};
-
-module_i2c_driver(lis331dlh_intel_cln_driver);
-
-MODULE_AUTHOR("Wojciech Ziemba <wojciech.ziemba@emutex.com>");
-MODULE_DESCRIPTION("STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Clanton platform");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/accel/lis331dlh_intel_qrk.c b/drivers/iio/accel/lis331dlh_intel_qrk.c
new file mode 100644
index 0000000..6b49c6f
--- /dev/null
+++ b/drivers/iio/accel/lis331dlh_intel_qrk.c
@@ -0,0 +1,735 @@
+/*
+ * Intel Clanton Hill platform accelerometer driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * Derived from STMicroelectronics accelerometers driver by Denis Ciocca
+ *
+ * The Intel Clanton Hill platform hardware design includes an
+ * STMicroelectronics LIS331DLH accelerometer, intended to be used mainly for
+ * sensing orientation, movement and sudden impacts (e.g. vehicle collision)
+ *
+ * This driver plugs into the Linux Industrial-IO framework to provide a
+ * standardised user-space application interface for retreiving data and events
+ * from the accelerometer.
+ *
+ * The LIS331DLH is connected via I2C to the host CPU on the Clanton Hill
+ * platform and so this driver registers to the kernel as an I2C device driver
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include <linux/iio/common/st_sensors_i2c.h>
+
+#include <linux/platform_data/lis331dlh_intel_qrk.h>
+
+/* DEFAULT VALUE FOR SENSORS */
+#define ST_ACCEL_DEFAULT_OUT_X_L_ADDR		0x28
+#define ST_ACCEL_DEFAULT_OUT_Y_L_ADDR		0x2a
+#define ST_ACCEL_DEFAULT_OUT_Z_L_ADDR		0x2c
+
+/* FULLSCALE */
+#define ST_ACCEL_FS_AVL_2G			2
+#define ST_ACCEL_FS_AVL_4G			4
+#define ST_ACCEL_FS_AVL_6G			6
+#define ST_ACCEL_FS_AVL_8G			8
+#define ST_ACCEL_FS_AVL_16G			16
+
+/* CUSTOM VALUES FOR SENSOR 2 */
+#define ST_ACCEL_2_WAI_EXP			0x32
+#define ST_ACCEL_2_ODR_ADDR			0x20
+#define ST_ACCEL_2_ODR_MASK			0x18
+#define ST_ACCEL_2_ODR_AVL_50HZ_VAL		0x00
+#define ST_ACCEL_2_ODR_AVL_100HZ_VAL		0x01
+#define ST_ACCEL_2_ODR_AVL_400HZ_VAL		0x02
+#define ST_ACCEL_2_ODR_AVL_1000HZ_VAL		0x03
+#define ST_ACCEL_2_PW_ADDR			0x20
+#define ST_ACCEL_2_PW_MASK			0xe0
+#define ST_ACCEL_2_PW_DOWN			0x00
+#define ST_ACCEL_2_PW_NORMAL		0x20
+#define ST_ACCEL_2_CTRL_REG1_XEN	0x01
+#define ST_ACCEL_2_CTRL_REG1_YEN	0x02
+#define ST_ACCEL_2_CTRL_REG1_ZEN	0x04
+#define ST_ACCEL_2_FS_ADDR			0x23
+#define ST_ACCEL_2_FS_MASK			0x30
+#define ST_ACCEL_2_FS_AVL_2_VAL			0X00
+#define ST_ACCEL_2_FS_AVL_4_VAL			0X01
+#define ST_ACCEL_2_FS_AVL_8_VAL			0x03
+#define ST_ACCEL_2_FS_AVL_2_GAIN		IIO_G_TO_M_S_2(1000)
+#define ST_ACCEL_2_FS_AVL_4_GAIN		IIO_G_TO_M_S_2(2000)
+#define ST_ACCEL_2_FS_AVL_8_GAIN		IIO_G_TO_M_S_2(3900)
+#define ST_ACCEL_2_BDU_ADDR			0x23
+#define ST_ACCEL_2_BDU_MASK			0x80
+#define ST_ACCEL_2_DRDY_IRQ_ADDR		0x22
+#define ST_ACCEL_2_DRDY_IRQ_MASK		0x02
+#define ST_ACCEL_2_THRESH_IRQ_ADDR		0x30
+#define ST_ACCEL_2_THRESH_IRQ_MASK		0x7f
+#define ST_ACCEL_2_INT1_CFG_ADDR		0x30
+#define ST_ACCEL_2_INT1_SRC_ADDR		0x31
+#define ST_ACCEL_2_INT1_THRESH_ADDR		0x32
+#define ST_ACCEL_2_INT1_DURATION_ADDR		0x33
+#define ST_ACCEL_2_INT2_CFG_ADDR		0x34
+#define ST_ACCEL_2_INT2_SRC_ADDR		0x35
+#define ST_ACCEL_2_INT2_THRESH_ADDR		0x36
+#define ST_ACCEL_2_INT2_DURATION_ADDR		0x37
+#define ST_ACCEL_2_INT_IA_MASK			0x40
+#define ST_ACCEL_2_INT_LIR_MASK			0x05
+#define ST_ACCEL_2_INT_SRC_HIGH_MASK	0x20
+#define ST_ACCEL_2_INT_CFG_XLIE_EN		0x01
+#define ST_ACCEL_2_INT_CFG_XHIE_EN		0x02
+#define ST_ACCEL_2_INT_CFG_YLIE_EN		0x04
+#define ST_ACCEL_2_INT_CFG_YHIE_EN		0x08
+#define ST_ACCEL_2_INT_CFG_ZLIE_EN		0x10
+#define ST_ACCEL_2_INT_CFG_ZHIE_EN		0x20
+
+#define ST_ACCEL_2_MULTIREAD_BIT		true
+#define ST_ACCEL_2_THRESH_VAL_MIN		0x00
+#define ST_ACCEL_2_THRESH_VAL_MAX		0x7f
+#define QRK_ACCEL_INT2_WAKEUP_THRESH_VAL	0x7f
+
+#define QRK_ACCEL_INT1_DISABLED			0
+#define QRK_ACCEL_INT1_ENABLED			1
+
+#define QRK_ACCEL_LSM_CHANNELS(device_type, index, mod, endian, bits, addr) \
+{ \
+	.type = device_type, \
+	.modified = 1, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.scan_index = index, \
+	.channel = mod, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = bits, \
+		.shift = 16 - bits, \
+		.storagebits = 16, \
+		.endianness = endian, \
+	}, \
+	.event_mask = IIO_EV_BIT(IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), \
+}
+
+static const u8 iio_modifier_map[] = {
+	IIO_NO_MOD,
+	IIO_MOD_X,
+	IIO_MOD_Y,
+	IIO_MOD_X_AND_Y,
+	IIO_MOD_Z,
+	IIO_MOD_X_AND_Z,
+	IIO_MOD_Y_AND_Z,
+	IIO_MOD_X_AND_Y_AND_Z,
+};
+
+/*  Threshold event ISR bottom half.  This function reads interrupt status
+ *  registers for INT1 to reset any active interrupt conditions
+ *  and pushes an IIO event if a threshold interrupt was active.
+ */
+static irqreturn_t lis331dlh_intel_qrk_threshold_event_handler(
+	int irq,
+	void *private)
+{
+	int err;
+	u8 data;
+	u8 mask;
+	int i;
+	u64 iio_modifier;
+
+	struct st_sensor_data *sdata = iio_priv(private);
+	s64 timestamp = iio_get_time_ns();
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+			ST_ACCEL_2_INT1_SRC_ADDR,
+			&data);
+
+	if (err < 0)
+		goto st_sensors_read_err;
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+			ST_ACCEL_2_INT1_CFG_ADDR,
+				&mask);
+
+	if (err < 0)
+		goto st_sensors_read_err;
+
+	if (data & ST_ACCEL_2_INT_IA_MASK) {
+		data &= mask;
+
+		iio_modifier = 0;
+		for (i = 0; i < ST_SENSORS_NUMBER_DATA_CHANNELS; i++) {
+			iio_modifier <<= 1;
+			iio_modifier += !!(data & ST_ACCEL_2_INT_SRC_HIGH_MASK);
+			data <<= 2;
+		}
+
+		iio_modifier = iio_modifier_map[iio_modifier];
+
+		iio_push_event(private,
+				IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				0,
+				iio_modifier,
+				IIO_EV_TYPE_THRESH,
+				IIO_EV_DIR_RISING),
+				timestamp);
+	}
+
+st_sensors_read_err:
+	return IRQ_HANDLED;
+}
+
+static inline int lis331dlh_intel_qrk_read_info_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch, int *val)
+{
+	int err;
+
+	mutex_lock(&indio_dev->mlock);
+	err = st_sensors_read_axis_data(indio_dev, ch->address, val);
+
+	if (unlikely(err < 0))
+		goto read_error;
+
+	*val = *val >> ch->scan_type.shift;
+	mutex_unlock(&indio_dev->mlock);
+
+	return err;
+
+read_error:
+	mutex_unlock(&indio_dev->mlock);
+	return err;
+}
+
+static int lis331dlh_intel_qrk_read_raw(
+	struct iio_dev *indio_dev,
+	struct iio_chan_spec const *ch,
+	int *val, int *val2, long mask)
+{
+	int err;
+	struct st_sensor_data *adata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		err = lis331dlh_intel_qrk_read_info_raw(indio_dev, ch, val);
+		if (unlikely(err < 0))
+			goto read_error;
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = adata->current_fullscale->gain;
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+read_error:
+	return err;
+}
+
+static int lis331dlh_intel_qrk_write_raw(
+	struct iio_dev *indio_dev,
+	struct iio_chan_spec const *chan,
+	int val, int val2, long mask)
+{
+	int err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		err = st_sensors_set_fullscale_by_gain(indio_dev, val2);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
+static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
+static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_accel_scale_available);
+
+static struct attribute *lis331dlh_intel_qrk_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group lis331dlh_intel_qrk_attribute_group = {
+	.attrs = lis331dlh_intel_qrk_attributes,
+};
+
+static int lis331dlh_intel_qrk_read_event_value(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int *val)
+{
+	int err;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_THRESH_ADDR, &data);
+
+	*val = (int) data;
+	return err;
+}
+
+static int lis331dlh_intel_qrk_write_event_value(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int val)
+{
+	int err;
+	struct st_sensor_data *sdata;
+
+	/* range check */
+	if (unlikely((val < ST_ACCEL_2_THRESH_VAL_MIN) ||
+				 (val > ST_ACCEL_2_THRESH_VAL_MAX)))
+		return -EINVAL;
+
+	sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_THRESH_ADDR, val);
+
+	return err;
+}
+
+/*  Configure the INT1 pin to fire an interrupt on a high threshold event.
+ */
+static int lis331dlh_intel_qrk_configure_threshold_interrupt(
+	struct iio_dev *indio_dev, u8 state)
+{
+	int err = 0;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	if (sdata->sensor->drdy_irq.ig1.en_mask == state)
+		return 0;
+
+	if (state == QRK_ACCEL_INT1_ENABLED) {
+		err = request_threaded_irq(sdata->get_irq_data_ready(indio_dev),
+				NULL,
+				lis331dlh_intel_qrk_threshold_event_handler,
+				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				"lis331dlh_intel_qrk_threshold",
+				indio_dev);
+		if (likely(err == 0)) {
+			sdata->sensor->drdy_irq.ig1.en_mask =
+					QRK_ACCEL_INT1_ENABLED;
+			err = sdata->tf->write_byte(
+				&sdata->tb, sdata->dev,
+				ST_ACCEL_2_INT1_DURATION_ADDR, 1);
+		}
+	} else {
+		free_irq(sdata->get_irq_data_ready(indio_dev), indio_dev);
+		sdata->sensor->drdy_irq.ig1.en_mask = QRK_ACCEL_INT1_DISABLED;
+	}
+
+	return err;
+}
+
+static int lis331dlh_intel_qrk_read_event_config(
+	struct iio_dev *indio_dev,
+	u64 event_code)
+{
+	int err = 0;
+	u8 data, mask;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				   ST_ACCEL_2_INT1_CFG_ADDR,
+				   &data);
+
+	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
+
+	return !!(data & mask);
+}
+
+static int lis331dlh_intel_qrk_write_event_config(
+	struct iio_dev *indio_dev,
+	u64 event_code,
+	int state)
+{
+	int err;
+	u8 data;
+	u8 mask;
+
+	bool new_int_state;
+
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+	mask = 1 << ((IIO_EVENT_CODE_EXTRACT_MODIFIER(event_code) << 1) - 1);
+
+	err = st_sensors_write_data_with_mask(indio_dev,
+					ST_ACCEL_2_INT1_CFG_ADDR,
+					mask, state);
+	if (unlikely(err < 0))
+		goto write_event_err;
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT1_CFG_ADDR, &data);
+	if (unlikely(err < 0))
+		goto write_event_err;
+
+	new_int_state = data & (ST_ACCEL_2_INT_CFG_XHIE_EN |
+					ST_ACCEL_2_INT_CFG_YHIE_EN |
+					ST_ACCEL_2_INT_CFG_ZHIE_EN);
+	err = lis331dlh_intel_qrk_configure_threshold_interrupt(
+			indio_dev, new_int_state);
+
+write_event_err:
+	return err;
+}
+
+/*  Configure the INT2 pin to fire an interrupt on a threshold high event.  INT2
+ *  should be wired to a suspend well IRQ to wake up the host.
+ */
+static int lis331dlh_intel_qrk_enable_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err = 0;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT2_THRESH_ADDR,
+					QRK_ACCEL_INT2_WAKEUP_THRESH_VAL);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
+
+	/* Latch interrupt request on INT2 */
+	err = st_sensors_write_data_with_mask(
+			indio_dev, ST_ACCEL_2_DRDY_IRQ_ADDR,
+			ST_ACCEL_2_INT_LIR_MASK, 1);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+					ST_ACCEL_2_INT2_DURATION_ADDR, 0);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_CFG_ADDR,
+						ST_ACCEL_2_INT_CFG_XHIE_EN |
+						ST_ACCEL_2_INT_CFG_YHIE_EN);
+	if (unlikely(err < 0))
+		goto enable_wakeup_int_err;
+
+	/* Clean ST_ACCEL_2_INT2_SRC */
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_SRC_ADDR,
+						&data);
+
+enable_wakeup_int_err:
+	return err;
+}
+
+static int lis331dlh_intel_qrk_disable_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err = 0;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+
+	err = sdata->tf->write_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_CFG_ADDR,
+						0);
+	if (unlikely(err < 0))
+		goto disable_wakeup_int_err;
+
+	/* Clean ST_ACCEL_2_INT2_SRC */
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+						ST_ACCEL_2_INT2_SRC_ADDR,
+						&data);
+	if (unlikely(err < 0))
+		goto disable_wakeup_int_err;
+
+disable_wakeup_int_err:
+	return err;
+}
+
+static int lis331dlh_intel_qrk_handle_wakeup_interrupt(
+	struct iio_dev *indio_dev)
+{
+	int err;
+	u8 data;
+	struct st_sensor_data *sdata = iio_priv(indio_dev);
+	s64 timestamp = iio_get_time_ns();
+
+	err = sdata->tf->read_byte(&sdata->tb, sdata->dev,
+				   ST_ACCEL_2_INT2_SRC_ADDR,
+				   &data);
+	if (unlikely(err < 0))
+		goto handle_wakeup_int_err;
+
+	if (data & ST_ACCEL_2_INT_IA_MASK) {
+		iio_push_event(indio_dev,
+				IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				0,
+				IIO_MOD_X_OR_Y_OR_Z,
+				IIO_EV_TYPE_THRESH,
+				IIO_EV_DIR_EITHER),
+				timestamp);
+	}
+
+handle_wakeup_int_err:
+	return err;
+}
+
+static const struct iio_info accel_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &lis331dlh_intel_qrk_attribute_group,
+	.read_raw = &lis331dlh_intel_qrk_read_raw,
+	.write_raw = &lis331dlh_intel_qrk_write_raw,
+	.read_event_config = &lis331dlh_intel_qrk_read_event_config,
+	.write_event_config = &lis331dlh_intel_qrk_write_event_config,
+	.read_event_value = &lis331dlh_intel_qrk_read_event_value,
+	.write_event_value = &lis331dlh_intel_qrk_write_event_value,
+};
+
+static const struct iio_chan_spec st_accel_12bit_channels[] = {
+	QRK_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_X_L_ADDR),
+	QRK_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Y_L_ADDR),
+	QRK_ACCEL_LSM_CHANNELS(IIO_ACCEL, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
+		ST_SENSORS_DEFAULT_12_REALBITS, ST_ACCEL_DEFAULT_OUT_Z_L_ADDR),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static struct st_sensors lis331dlh_intel_qrk_sensor = {
+	.wai = ST_ACCEL_2_WAI_EXP,
+	.sensors_supported = {
+		[0] = "lis331dlh_qrk",
+	},
+	.ch = (struct iio_chan_spec *)st_accel_12bit_channels,
+	.odr = {
+		.addr = ST_ACCEL_2_ODR_ADDR,
+		.mask = ST_ACCEL_2_ODR_MASK,
+		.odr_avl = {
+			{ 50, ST_ACCEL_2_ODR_AVL_50HZ_VAL, },
+			{ 100, ST_ACCEL_2_ODR_AVL_100HZ_VAL, },
+			{ 400, ST_ACCEL_2_ODR_AVL_400HZ_VAL, },
+			{ 1000, ST_ACCEL_2_ODR_AVL_1000HZ_VAL, },
+		},
+	},
+	.pw = {
+		.addr = ST_ACCEL_2_PW_ADDR,
+		.mask = ST_ACCEL_2_PW_MASK,
+		.value_on = ST_SENSORS_DEFAULT_POWER_ON_VALUE,
+		.value_off = ST_SENSORS_DEFAULT_POWER_OFF_VALUE,
+	},
+	.enable_axis = {
+		.addr = ST_SENSORS_DEFAULT_AXIS_ADDR,
+		.mask = ST_SENSORS_DEFAULT_AXIS_MASK,
+	},
+	.fs = {
+		.addr = ST_ACCEL_2_FS_ADDR,
+		.mask = ST_ACCEL_2_FS_MASK,
+		.fs_avl = {
+			[0] = {
+				.num = ST_ACCEL_FS_AVL_2G,
+				.value = ST_ACCEL_2_FS_AVL_2_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_2_GAIN,
+			},
+			[1] = {
+				.num = ST_ACCEL_FS_AVL_4G,
+				.value = ST_ACCEL_2_FS_AVL_4_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_4_GAIN,
+			},
+			[2] = {
+				.num = ST_ACCEL_FS_AVL_8G,
+				.value = ST_ACCEL_2_FS_AVL_8_VAL,
+				.gain = ST_ACCEL_2_FS_AVL_8_GAIN,
+			},
+		},
+	},
+	.bdu = {
+		.addr = ST_ACCEL_2_BDU_ADDR,
+		.mask = ST_ACCEL_2_BDU_MASK,
+	},
+	.drdy_irq = {
+		.addr = ST_ACCEL_2_DRDY_IRQ_ADDR,
+		.mask = ST_ACCEL_2_DRDY_IRQ_MASK,
+	},
+	.multi_read_bit = ST_ACCEL_2_MULTIREAD_BIT,
+	.bootime = 2,
+};
+
+static int lis331dlh_intel_qrk_probe(
+	struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct iio_dev *indio_dev;
+	struct st_sensor_data *adata;
+	struct lis331dlh_intel_qrk_platform_data *pdata;
+	int ret = 0;
+
+	indio_dev = iio_device_alloc(sizeof(*adata));
+	if (unlikely(indio_dev == NULL)) {
+		ret = -ENOMEM;
+		goto iio_device_alloc_error;
+	}
+
+	i2c_set_clientdata(client, indio_dev);
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = client->name;
+
+	adata = iio_priv(indio_dev);
+	adata->dev = &client->dev;
+
+	pdata = client->dev.platform_data;
+	if (unlikely(!pdata)) {
+		pr_err("No platform data provided\n");
+		goto lis331dlh_intel_qrk_init_err;
+	}
+
+	ret = gpio_to_irq(pdata->irq1_pin);
+	if (unlikely(ret < 0)) {
+		pr_err(
+			"Failed to obtain valid IRQ for GPIO %d, "
+			"gpio_to_irq returned %d\n",
+			pdata->irq1_pin, ret);
+		goto lis331dlh_intel_qrk_init_err;
+	}
+	to_i2c_client(adata->dev)->irq = ret;
+
+	st_sensors_i2c_configure(indio_dev, client, adata);
+
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &accel_info;
+
+	ret = st_sensors_check_device_support(indio_dev,
+						1, &lis331dlh_intel_qrk_sensor);
+	if (unlikely(ret < 0))
+		goto lis331dlh_intel_qrk_init_err;
+
+	indio_dev->channels = adata->sensor->ch;
+	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
+
+	adata->multiread_bit = adata->sensor->multi_read_bit;
+	adata->current_fullscale = (struct st_sensor_fullscale_avl *)
+		&adata->sensor->fs.fs_avl[0];
+	adata->odr = adata->sensor->odr.odr_avl[0].hz;
+
+	adata->sensor->drdy_irq.ig1.en_mask = QRK_ACCEL_INT1_DISABLED;
+
+	ret = st_sensors_init_sensor(indio_dev);
+	if (unlikely(ret < 0))
+		goto lis331dlh_intel_qrk_init_err;
+
+	ret = st_sensors_set_enable(indio_dev, true);
+	if (unlikely(ret < 0))
+		goto lis331dlh_intel_qrk_init_err;
+
+	ret = iio_device_register(indio_dev);
+	if (unlikely(ret))
+		goto lis331dlh_intel_qrk_init_err;
+
+	return 0;
+
+lis331dlh_intel_qrk_init_err:
+	iio_device_free(indio_dev);
+iio_device_alloc_error:
+	return ret;
+}
+
+static int lis331dlh_intel_qrk_remove(
+	struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct st_sensor_data *adata = iio_priv(indio_dev);
+
+	st_sensors_set_enable(indio_dev, false);
+
+	if (adata->sensor->drdy_irq.ig1.en_mask == QRK_ACCEL_INT1_ENABLED)
+		free_irq(adata->get_irq_data_ready(indio_dev), indio_dev);
+
+	iio_device_unregister(indio_dev);
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331dlh_intel_qrk_suspend(
+	struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	lis331dlh_intel_qrk_enable_wakeup_interrupt(indio_dev);
+
+	return 0;
+}
+
+static int lis331dlh_intel_qrk_resume(
+	struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	lis331dlh_intel_qrk_handle_wakeup_interrupt(indio_dev);
+	lis331dlh_intel_qrk_disable_wakeup_interrupt(indio_dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops lis331dlh_intel_qrk_pm_ops = {
+	.suspend = lis331dlh_intel_qrk_suspend,
+	.resume = lis331dlh_intel_qrk_resume,
+};
+
+#define LIS331DLH_INTEL_QRK_PM_OPS (&lis331dlh_intel_qrk_pm_ops)
+#else
+#define LIS331DLH_INTEL_QRK_PM_OPS NULL
+#endif
+
+static const struct i2c_device_id lis331dlh_intel_qrk_id_table[] = {
+	{ "lis331dlh_qrk" },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, lis331dlh_intel_qrk_id_table);
+
+static struct i2c_driver lis331dlh_intel_qrk_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lis331dlh_qrk",
+		.pm	= LIS331DLH_INTEL_QRK_PM_OPS,
+	},
+	.probe = lis331dlh_intel_qrk_probe,
+	.remove = lis331dlh_intel_qrk_remove,
+	.id_table = lis331dlh_intel_qrk_id_table,
+};
+
+module_i2c_driver(lis331dlh_intel_qrk_driver);
+
+MODULE_AUTHOR("Wojciech Ziemba <wojciech.ziemba@emutex.com>");
+MODULE_DESCRIPTION("STMicroelectronics LIS331DLH accelerometer i2c driver for Intel Quark platform");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/adc/max78m6610_lmu.c b/drivers/iio/adc/max78m6610_lmu.c
index 5a72f8e..c427517 100644
--- a/drivers/iio/adc/max78m6610_lmu.c
+++ b/drivers/iio/adc/max78m6610_lmu.c
@@ -1,7 +1,7 @@
 /*
  * max78m6610+lmu SPI protocol driver
  *
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2013 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
@@ -20,50 +20,120 @@
  * Intel Corporation
  *
  * This SPI protocol driver is developed for the Maxim 78M6610+LMU (eADC).
- * The driver is developed as a part of the Clanton BSP where integrated into
- * Clanton Evaluation Boards Cross Hill Industrial-E.
+ * The driver is developed as a part of the Quark BSP where integrated into
+ * Quark Evaluation Boards Cross Hill Industrial-E.
  *
  * The Maxim 78M6610+LMU is an energy measurement processor (EMP) for
  * load monitoring on single or spilt-phase AC loads. It supports varies
  * interface configuration protocols through I/O pins.
  *
- * With 3 wire serial input/output interfaces provided by Clanton SoC,
+ * With 3 wire serial input/output interfaces provided by Quark SoC,
  * the 78M6610+LMU can be connected directly as SPI slave device.
  */
 
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/buffer.h>
 #include <linux/iio/types.h>
 #include <linux/iio/trigger.h>
 #include <linux/iio/trigger_consumer.h>
 #include <linux/iio/triggered_buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
+#include <linux/platform_data/max78m6610_lmu.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spidev.h>
 #include <linux/version.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
 
-#define INSTAN_VA       0x33 /* instaneous Voltage for VA source */
-#define INSTAN_IA       0x44 /* instaneous Current for IA source */
-#define INSTAN_PA       0x5C /* instaneous Active Power for source A*/
-#define INSTAN_PQA      0x5E /* instaneous Reactive Power for source A*/
-#define VA_RMS          0x2B /* RMS voltage for VA source */
-#define IA_RMS          0x3E /* RMS current for VA source */
-#define WATT_A          0x4B /* Active Power for source A */
-#define VAR_A           0x51 /* Reactive power for source A */
-#define VA_A            0x4E /* Volt-Amperes for source A */
-#define PFA             0x65 /* Source A Power Factor */
-
-#define INSTAN_VB       0x34 /* instaneous Voltage for VB source */
-#define INSTAN_IB       0x45 /* instaneous Current for IB source */
-#define INSTAN_PB       0x5D /* instaneous Active Power for source B*/
-#define INSTAN_PQB      0x5F /* instaneous Voltage for VB source */
-#define VB_RMS          0x2C /* RMS voltage for VB source */
-#define IB_RMS          0x3F /* RMS current for VB source */
-#define WATT_B          0x4C /* Active Power for source B */
-#define VAR_B           0x52 /* Reactive power for source B */
-#define VA_B            0x4F /* Volt-amperes for source B */
-#define PFB             0x66 /* Source B Power Factor */
+/* Calibration registers */
+#define COMMAND         0x00 /* Command Register */
+#define SAMPLES         0x03 /* High-rate samples per low-rate */
+#define CALCYCS         0x04 /* Number of Calibration Cycles to Average */
+#define PHASECOMP1      0x05 /* Phase compensation for S1 input */
+#define PHASECOMP3      0x06 /* Phase compensation for S3 input */
+#define S1_GAIN         0x07 /* Input S1 Gain Calibration */
+#define S0_GAIN         0x08 /* Input S0 Gain Calibration */
+#define S3_GAIN         0x09 /* Input S3 Gain Calibration */
+#define S2_GAIN         0x0A /* Input S2 Gain Calibration */
+#define S1_OFFSET       0x0D /* Input S1 Offset Calibration */
+#define S0_OFFSET       0x0B /* Input S0 Offset Calibration */
+#define S3_OFFSET       0x0E /* Input S3 Offset Calibration */
+#define S2_OFFSET       0x0C /* Input S2 Offset Calibration */
+#define VTARGET         0x12 /* Voltage Calibration Target */
+#define ITARGET         0x39 /* Current Calibration Target */
+
+#define CALCMD_S0_GAIN  0xCA2030 /* Calibrate Voltage Gain for Input S0 */
+#define CALCMD_S1_GAIN  0xCA0830 /* Calibrate Current Gain for Input S1 */
+#define CALCMD_S2_GAIN  0xCA4030 /* Calibrate Voltage Gain for Input S2 */
+#define CALCMD_S3_GAIN  0xCA1030 /* Calibrate Current Gain for Input S3 */
+#define CALCMD_S0_OFFS  0xCA2210 /* Calibrate Voltage Offset for Input S0 */
+#define CALCMD_S1_OFFS  0xCA0A10 /* Calibrate Current Offset for Input S1 */
+#define CALCMD_S2_OFFS  0xCA4210 /* Calibrate Voltage Offset for Input S2 */
+#define CALCMD_S3_OFFS  0xCA1210 /* Calibrate Current Offset for Input S3 */
+#define FLASHSAVE_CMD   0xACC210 /* Save calibration coefficients to flash */
+
+/* Interrupt status registers */
+#define MASK0           0x02 /* Status bit mask for MP0 pin */
+#define STATUS          0x0F /* Status of device and alarms */
+#define STATUS_RESET    0x11 /* Used to Reset Status bits */
+#define STATUS_MASK_DRDY     (1 << 23)
+#define STATUS_MASK_MMUPD    (1 << 22)
+#define STATUS_MASK_VA_SAG   (1 << 21)
+#define STATUS_MASK_VB_SAG   (1 << 20)
+#define STATUS_MASK_SIGN_VA  (1 << 19)
+#define STATUS_MASK_SIGN_VB  (1 << 18)
+#define STATUS_MASK_OV_TEMP  (1 << 17)
+#define STATUS_MASK_UN_TEMP  (1 << 16)
+#define STATUS_MASK_OV_FREQ  (1 << 15)
+#define STATUS_MASK_UN_FREQ  (1 << 14)
+#define STATUS_MASK_OV_VRMSA (1 << 13)
+#define STATUS_MASK_UN_VRMSA (1 << 12)
+#define STATUS_MASK_OV_VRMSB (1 << 11)
+#define STATUS_MASK_UN_VRMSB (1 << 10)
+#define STATUS_MASK_VA_SURGE (1 << 9)
+#define STATUS_MASK_VB_SURGE (1 << 8)
+#define STATUS_MASK_OV_WATT1 (1 << 7)
+#define STATUS_MASK_OV_WATT2 (1 << 6)
+#define STATUS_MASK_OV_AMP1  (1 << 5)
+#define STATUS_MASK_OV_AMP2  (1 << 4)
+#define STATUS_MASK_XSTATE   (1 << 3)
+#define STATUS_MASK_RELAY1   (1 << 2)
+#define STATUS_MASK_RELAY2   (1 << 1)
+#define STATUS_MASK_RESET    (1)
+#define STATUS_MASK_STICKY   (0x73FFF0)
+#define STATUS_MASK_IGNORE   (0x00000F)
+
+#define VSURG_VAL	0x13 /* Voltage surge alarm threshold */
+#define VSAG_VAL	0x14 /* Voltage sag alarm threshold */
+#define VRMS_MIN	0x15 /* Voltage lower alarm limit */
+#define VRMS_MAX	0x16 /* Voltage upper alarm limit */
+#define IRMS_MAX	0x27 /* Over Current alarm limit */
+#define WATT_MAX	0x32 /* Power alarm limit */
+
+#define INSTAN_VA       0x1D /* instaneous Voltage for VA source */
+#define INSTAN_IA       0x25 /* instaneous Current for IA source */
+#define INSTAN_PA       0x2E /* instaneous Active Power for source A*/
+#define INSTAN_PQA      0x30 /* instaneous Reactive Power for source A*/
+#define VA_RMS          0x17 /* RMS voltage for VA source */
+#define IA_RMS          0x1F /* RMS current for VA source */
+#define WATT_A          0x28 /* Active Power for source A */
+#define VAR_A           0x2C /* Reactive power for source A */
+#define VA_A            0x2A /* Volt-Amperes for source A */
+#define PFA             0x33 /* Source A Power Factor */
+
+#define INSTAN_VB       0x1E /* instaneous Voltage for VB source */
+#define INSTAN_IB       0x26 /* instaneous Current for IB source */
+#define INSTAN_PB       0x2F /* instaneous Active Power for source B*/
+#define INSTAN_PQB      0x31 /* instaneous Voltage for VB source */
+#define VB_RMS          0x18 /* RMS voltage for VB source */
+#define IB_RMS          0x20 /* RMS current for VB source */
+#define WATT_B          0x29 /* Active Power for source B */
+#define VAR_B           0x2D /* Reactive power for source B */
+#define VA_B            0x2B /* Volt-amperes for source B */
+#define PFB             0x34 /* Source B Power Factor */
 
 /* Addr bit 6-7: ADDR6, ADDR7 */
 #define SPI_CB_ADDR_MASK_7_6(x)	(((x) & 0xC0) >> 6)
@@ -81,6 +151,11 @@
 #define SPI_MSG_LEN	5
 #define RX_OFFSET	1
 #define SPI_BBUFFER_LEN 4096
+/* All registers on the device are 24-bit */
+#define REG_WIDTH	24
+#define SAMPLE_INTERVAL_USEC 250 /* High-rate sample interval (microseconds) */
+#define RESET_DELAY_MSEC 100
+#define INTR_GPIO        2
 
 /* SPI message Control byte */
 #define SPI_CB(x)	((SPI_CB_NBR_ACC << 4)\
@@ -89,11 +164,12 @@
 /* SPI message Transaction byte */
 #define SPI_TB_READ(x)	((SPI_TB_ADDR_MASK_5_0(x) << 2)\
 			| SPI_OP_READ)
-
+#define SPI_TB_WRITE(x)	((SPI_TB_ADDR_MASK_5_0(x) << 2)\
+			| SPI_OP_WRITE)
 
 /**
  * max78m6610_lmu_channels structure maps eADC measurement features to
- * correlates IIO channels
+ * IIO channels on the IIO sysfs user interface
  */
 static const struct iio_chan_spec max78m6610_lmu_channels[] = {
 	/* IIO Channels for source A */
@@ -369,9 +445,9 @@ static const struct iio_chan_spec max78m6610_lmu_channels[] = {
 		.scan_index = 16,
 		.scan_type = {
 			.sign = 's',
-			.realbits = 32, /* data type S.22 */
+			.realbits = 32,
 			.storagebits = 32,
-			.shift = 22,
+			.shift = 22, /* data type S.22 */
 		},
 	},
 	{
@@ -422,6 +498,294 @@ static const struct iio_chan_spec max78m6610_lmu_channels[] = {
 			.shift = 23,
 		},
 	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "phasecomp",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = PHASECOMP1,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 1,
+		.extend_name = "phasecomp",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = PHASECOMP3,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_target_rms",
+		.info_mask = IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_RAW),
+		.address = VTARGET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_target_rms",
+		.info_mask = IIO_CHAN_INFO_SHARED_BIT(IIO_CHAN_INFO_RAW),
+		.address = ITARGET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_gain",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S0_GAIN,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 1,
+		.channel = 1,
+		.extend_name = "calib_gain",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S2_GAIN,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_gain",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S1_GAIN,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 1,
+		.extend_name = "calib_gain",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S3_GAIN,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 21,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_offset",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S0_OFFSET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 1,
+		.channel = 1,
+		.extend_name = "calib_offset",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S2_OFFSET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 0,
+		.extend_name = "calib_offset",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S1_OFFSET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 1,
+		.channel = 1,
+		.extend_name = "calib_offset",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = S3_OFFSET,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "surge_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = VSURG_VAL,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "sag_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = VSAG_VAL,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "rms_min_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = VRMS_MIN,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_VOLTAGE,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "rms_max_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = VRMS_MAX,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_CURRENT,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "rms_max_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = IRMS_MAX,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
+	{
+		.type = IIO_POWER,
+		.indexed = 0,
+		.channel = 0,
+		.extend_name = "active_max_threshold",
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.address = WATT_MAX,
+		.scan_index = -1,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 32,
+			.storagebits = 32,
+			.shift = 23,
+		},
+		.output = 1,
+	},
 
 	IIO_CHAN_SOFT_TIMESTAMP(20),
 };
@@ -433,6 +797,7 @@ static const struct iio_chan_spec max78m6610_lmu_channels[] = {
 struct max78m6610_lmu_state {
 	struct spi_device	*spi;
 	struct iio_dev_attr	*iio_attr;
+	struct iio_trigger      *trig;
 	struct spi_transfer	ring_xfer[MAX_CHAN_NUM];
 	struct spi_transfer	scan_single_xfer;
 	struct spi_message	ring_msg;
@@ -441,6 +806,7 @@ struct max78m6610_lmu_state {
 	u8	tx_buf[SPI_MSG_LEN * MAX_CHAN_NUM];
 	u8	rx_buf[SPI_MSG_LEN * MAX_CHAN_NUM + sizeof(s64)];
 
+	int reset_gpio;
 
 	/* Char dev to provide ioctl interface for f/w upgrade
 	 * or low-level register access */
@@ -468,8 +834,6 @@ static void ret_fraction_log2(int *val, int *val2)
 	tmp = *val;
 
 	if (*val < 0) {
-		pr_debug("%s: before shr: tmp=0x%016llX, *val=0x%08X, tmp=%lld, *val=%d\n",
-				__func__, tmp, *val, tmp, *val);
 		/* the do_div function will return trash if the value
 		 * of input is negative. We need to treat tmp as
 		 * a positive number for calculation.
@@ -489,9 +853,6 @@ static void ret_fraction_log2(int *val, int *val2)
 		 * correct output format.
 		 */
 		*val2 = *val2 ^ SIGN_CONVERT;
-		pr_debug("%s: at the end: *val=0x%08x, tmp=%lld, *val=%d\n",
-				__func__, *val, tmp, *val);
-
 	} else {
 
 		tmp = tmp * 1000000000LL >> (*val2);
@@ -501,6 +862,122 @@ static void ret_fraction_log2(int *val, int *val2)
 }
 
 /**
+ * intplusnano_to_regval
+ *
+ * @param val_int:  Integer part of floating point value
+ * @param val_nano: Fractional part of floating point value
+ * @param frac_bits: The number of fractional bits to produce for this register
+ * @param regval: The resulting 24-bit signed fixed-point register value
+ * @return: 0 on success, non-zero on error
+ *
+ * As the kernel doesn't allow floating point numbers, IIO
+ * will split them into separate integer and fractional parts.  This function
+ * then converts them into fixed-point signed register values for the MAX78M6610
+ */
+static int intplusnano_to_regval(int val_int, int val_nano,
+				 int fract_bits, u32 *regval)
+{
+	int i, max_int, negative = 0;
+
+	/* Maximum integer value must be 24 bits minus sign and fraction_bits */
+	max_int = 1 << (REG_WIDTH - fract_bits - 1);
+
+	if ((val_int >= max_int) ||
+	    (val_int < -max_int) ||
+	    ((val_int == -max_int) && (val_nano != 0))) {
+		pr_err("Input value exceeds maximum allowed range\n");
+		return -EINVAL;
+	}
+
+	*regval = abs(val_int) << fract_bits;
+
+	/* Set the sign-bit, if input is negative */
+	if ((val_int < 0) || (val_nano < 0))
+		negative = 1;
+
+	val_nano = abs(val_nano);
+
+	/* Divide the fractional part down by negative powers of 2*/
+	for (i = fract_bits-1; i >= 0 && val_nano; i--) {
+		val_nano = val_nano << 1;
+		if (val_nano >= 1000000000LL) {
+			*regval |= (1 << i);
+			val_nano -= 1000000000LL;
+		}
+	}
+
+	/* Get 2s complement of number if negative */
+	if (negative)
+		*regval = (~(*regval) + 1) & ((1 << REG_WIDTH) - 1);
+
+	return 0;
+}
+
+/**
+ * __max78m6610_lmu_spi_reg_read
+ *
+ * @param st: Driver state data
+ * @param regaddr: The register word address to read
+ * @param regval: The 24-bit register value obtained by the read operation
+ * @return: 0 on success, non-zero on error
+ *
+ * Issues a SPI transaction to read a single register on the device.
+ * Performs endian byte swap before returning the register data.
+ */
+static inline
+int __max78m6610_lmu_spi_reg_read(struct max78m6610_lmu_state *st,
+				  u8 regaddr,
+				  u32 *regval)
+{
+	int ret;
+
+	st->tx_buf[0] = SPI_CB(regaddr);
+	st->tx_buf[1] = SPI_TB_READ(regaddr);
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret) {
+		pr_err("spi_sync return error: %d\n", ret);
+		return -EIO;
+	}
+
+	*regval = (st->rx_buf[2] << 16) | (st->rx_buf[3] << 8) | st->rx_buf[4];
+
+	return 0;
+}
+
+/**
+ * __max78m6610_lmu_spi_reg_write
+ *
+ * @param st: Driver state data
+ * @param regaddr: The register word address to write
+ * @param regval: The 24-bit value to write to the register
+ * @return: 0 on success, non-zero on error
+ *
+ * Issues a SPI transaction to write a single register on the device.
+ * Performs endian byte swap before writing the register data.
+ */
+static inline
+int __max78m6610_lmu_spi_reg_write(struct max78m6610_lmu_state *st,
+				   u8 regaddr,
+				   u32 regval)
+{
+	int ret;
+
+	st->tx_buf[0] = SPI_CB(regaddr);
+	st->tx_buf[1] = SPI_TB_WRITE(regaddr);
+	st->tx_buf[2] = regval >> 16;
+	st->tx_buf[3] = regval >> 8;
+	st->tx_buf[4] = regval & 0xFF;
+
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret) {
+		pr_err("spi_sync return non-zero value\n");
+		ret = -EIO;
+	}
+
+	return 0;
+}
+
+/**
  * max78m6610_lmu_update_scan_mode
  *
  * @param indio_dev: iio_dev pointer.
@@ -604,40 +1081,6 @@ done:
 }
 
 /**
- * max78m6610_lmu_scan_direct
- *
- * @param st: max78m6610 state structure pointer
- * @param addr: register address
- * @return: signed 32-bits result value or standard errno on failure.
- *
- * buildup SPI message to scan HW register based on input address.
- */
-static int max78m6610_lmu_scan_direct(struct max78m6610_lmu_state *st,
-				unsigned addr)
-{
-	int ret;
-	u32 *rx_buf_32 = NULL;
-
-	pr_debug("build SPI request msg to addr 0x%02x\n", addr);
-
-	st->tx_buf[0] = SPI_CB(addr);
-	st->tx_buf[1] = SPI_TB_READ(addr);
-
-	ret = spi_sync(st->spi, &st->scan_single_msg);
-	if (ret) {
-		pr_err("spi_sync return non-zero value\n");
-		return -EIO;
-	}
-
-	rx_buf_32 = (uint32_t *)&(st->rx_buf[RX_OFFSET]);
-	*rx_buf_32 = be32_to_cpu(*rx_buf_32) & DATA_BIT_MASK;
-
-	ret = sign_extend32(*rx_buf_32, SIGN_BIT_NUM);
-
-	return ret;
-}
-
-/**
  * max78m6610_lmu_read_raw
  *
  * @param indio_dev: iio_dev pointer
@@ -659,6 +1102,7 @@ static int max78m6610_lmu_read_raw(struct iio_dev *indio_dev,
 			   long m)
 {
 	int ret;
+	u32 regval;
 	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
 
 	switch (m) {
@@ -666,14 +1110,16 @@ static int max78m6610_lmu_read_raw(struct iio_dev *indio_dev,
 	case IIO_CHAN_INFO_RAW:
 		mutex_lock(&indio_dev->mlock);
 		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
-			ret = -EBUSY;
-			return ret;
-		} else {
-			ret = max78m6610_lmu_scan_direct(st, chan->address);
+			mutex_unlock(&indio_dev->mlock);
+			return -EBUSY;
 		}
+
+		ret = __max78m6610_lmu_spi_reg_read(st, chan->address, &regval);
 		mutex_unlock(&indio_dev->mlock);
+		if (ret)
+			return ret;
 
-		*val = ret;
+		*val = sign_extend32(regval, SIGN_BIT_NUM);
 		*val2 = chan->scan_type.shift;
 
 		ret_fraction_log2(val, val2);
@@ -715,13 +1161,620 @@ static int max78m6610_lmu_read_raw(struct iio_dev *indio_dev,
 	return -EINVAL;
 }
 
+/**
+ * max78m6610_lmu_write_raw
+ *
+ * @param indio_dev: iio_dev pointer
+ * @param chan: pointer to iio channel spec struct
+ * @param val: input value pointer
+ * @param val2: input value 2 ponter
+ * @parma m: write mask indicating IIO info type
+ * @return: status indicating success (zero) or fail (non-zero)
+ *
+ * This function will be invoked on a request to write a value to the device.
+ * Write mask specifies an IIO value type, val and val2 contain the integer and
+ * fractional elements of the floating point input value (INT+NANO).
+ */
+static int max78m6610_lmu_write_raw(struct iio_dev *indio_dev,
+				    struct iio_chan_spec const *chan,
+				    int val,
+				    int val2,
+				    long m)
+{
+	int ret;
+	u32 regval;
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	switch (m) {
+
+	case IIO_CHAN_INFO_RAW:
+		ret = intplusnano_to_regval(val, val2,
+					    chan->scan_type.shift, &regval);
+		if (ret)
+			goto exit_unlock;
+
+		ret = __max78m6610_lmu_spi_reg_write(st, chan->address, regval);
+		break;
+
+	default:
+		pr_err("Invalid channel selected for writing\n");
+		ret = -EINVAL;
+		goto exit_unlock;
+	}
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_write_raw_get_fmt
+ *
+ * @param indio_dev: iio_dev pointer
+ * @param chan: pointer to iio channel spec struct
+ * @param mask: specifies which value to be written
+ * @return: the format specifier for the channel value to be written
+ *
+ * IIO will query the expected format of the input value, and will then
+ * interpret and format it correctly before passing it to
+ * max78m6610_lmu_write_raw().  In all cases, we expect floating point
+ * numbers as input, which IIO will convert into integer and fractional parts
+ */
+static int max78m6610_lmu_write_raw_get_fmt(struct iio_dev *indio_dev,
+					    struct iio_chan_spec const *chan,
+					    long mask)
+{
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+
+/**
+ * max78m6610_lmu_reg_access
+ *
+ * @param indio_dev: iio_dev pointer
+ * @param reg: register address
+ * @param writeval: register value to write (ignored if readval is set)
+ * @parma readval: pointer to return register read result (set NULL for write)
+ * @return: status indicating success (zero) or fail (non-zero)
+ *
+ * This function allows direct read/write access MAX78M6610+LMU registers
+ * for debug only
+ */
+static int max78m6610_lmu_reg_access(struct iio_dev *indio_dev,
+				     unsigned reg, unsigned writeval,
+				     unsigned *readval)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	if (readval)
+		ret = __max78m6610_lmu_spi_reg_read(st, reg, readval);
+	else
+		ret = __max78m6610_lmu_spi_reg_write(st, reg, writeval);
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_reset
+ *
+ * @param indio_dev: iio_dev pointer
+ *
+ * Executes a reset of the MAX78M6610+LMU by briefly asserting the
+ * hardware reset signal for the device.  Volatile register values
+ * will revert to power-on default values.
+ */
+static int max78m6610_lmu_reset(struct iio_dev *indio_dev)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	int ret = 0;
+	int gpio = st->reset_gpio;
+
+	struct gpio device_reset_gpio = {
+		gpio,
+		GPIOF_OUT_INIT_HIGH,
+		"max78m6610_lmu_reset"
+	};
+
+	if (gpio < 0) {
+		pr_err("Reset GPIO has not been configured\n");
+		return -ENXIO;
+	}
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	ret = gpio_request_array(&device_reset_gpio, 1);
+	if (ret) {
+		pr_err("%s: Failed to allocate Device Reset GPIO pin\n",
+				__func__);
+		goto exit_unlock;
+	}
+	gpio_set_value(gpio, 0);
+	msleep(RESET_DELAY_MSEC);
+	gpio_set_value(gpio, 1);
+	msleep(RESET_DELAY_MSEC);
+
+	gpio_free_array(&device_reset_gpio, 1);
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_write_reset
+ *
+ * @param dev: device descriptor associated with sysfs attribute node
+ * @param attr: device sysfs attribute descriptor
+ * @param buf: data written by user to the attribute node
+ * @param len: length in bytes of data written by user
+ *
+ * This handles a write to this sysfs node from user-space, and invokes a
+ * reset of the MAX78M6610+LMU if an appropriate value is written.
+ * Valid input character values are 1, y and Y
+ */
+static ssize_t max78m6610_lmu_write_reset(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	int ret = 0;
+
+	if (len < 1)
+		return -1;
+	switch (buf[0]) {
+	case '1':
+	case 'y':
+	case 'Y':
+		ret = max78m6610_lmu_reset(indio_dev);
+		return ret ? ret : len;
+	}
+	return -1;
+}
+
+/**
+ * max78m6610_lmu_calib_cmd
+ *
+ * @param indio_dev: iio_dev pointer
+ * @param calib_command: 24-bit calibration command value
+ *
+ * Executes a specified calibration command on the MAX78M6610+LMU
+ * The calib_command input value is written directly to the COMMAND
+ * register on the device, to invoke a selected automatic calibration
+ * routine.  The driver waits until the calibration completes, and then
+ * checks the status (depending on the specific command)
+ */
+static int max78m6610_lmu_calib_cmd(struct iio_dev *indio_dev,
+				    u32 calib_command)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	u32 samples, calcycs;
+	unsigned delay_ms;
+	int max_retries = 5;
+	int ret = 0;
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	/* Calculate the delay required for calibration to complete */
+	ret = __max78m6610_lmu_spi_reg_read(st, SAMPLES, &samples);
+	if (ret)
+		goto exit_unlock;
+	ret = __max78m6610_lmu_spi_reg_read(st, CALCYCS, &calcycs);
+	if (ret)
+		goto exit_unlock;
+	delay_ms = (samples * calcycs * SAMPLE_INTERVAL_USEC)/1000;
+
+	ret = __max78m6610_lmu_spi_reg_write(st, COMMAND, calib_command);
+	if (ret)
+		goto exit_unlock;
+
+	do {
+		/* Wait for the calibration to complete */
+		mdelay(delay_ms);
+
+		ret = __max78m6610_lmu_spi_reg_read(st, COMMAND,
+						    &calib_command);
+		if (ret)
+			goto exit_unlock;
+	} while ((calib_command & 0xFF0000) && (max_retries--));
+
+	if (max_retries <= 0) {
+		pr_err("Timed out waiting for calibration to complete\n");
+		ret = -EIO;
+		goto exit_unlock;
+	}
+
+	/* Gain calibration commands (bit 9 unset) can be checked for failure */
+	if ((!(calib_command & 0x000200)) && (calib_command & 0x007800)) {
+		pr_err("Calibration failed: COMMAND=0x%06X\n", calib_command);
+		ret = -EFAULT;
+	}
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_write_calib
+ *
+ * @param dev: device descriptor associated with sysfs attribute node
+ * @param attr: device sysfs attribute descriptor
+ * @param buf: data written by user to the attribute node
+ * @param len: length in bytes of data written by user
+ *
+ * This handles a write to this sysfs node from user-space, and invokes a
+ * calibration command on the MAX78M6610+LMU if an appropriate value is written.
+ * Valid input character values are 1, y and Y.
+ * The handler is re-used for multiple calibration commands, so the command
+ * value is passed transparently via the attribute address field
+ */
+static ssize_t max78m6610_lmu_write_calib(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	int ret = 0;
+
+	if (len < 1)
+		return -1;
+	switch (buf[0]) {
+	case '1':
+	case 'y':
+	case 'Y':
+		ret = max78m6610_lmu_calib_cmd(indio_dev, this_attr->address);
+		return ret ? ret : len;
+	}
+	return -1;
+}
+
+/**
+ * max78m6610_lmu_flash_save_cmd
+ *
+ * @param indio_dev: iio_dev pointer
+ *
+ * Executes a flash-save command on the MAX78M6610+LMU.
+ * This saves all current volatile register values to flash on the device,
+ * making them persistent across device resets or power cycles.
+ */
+static int max78m6610_lmu_flash_save_cmd(struct iio_dev *indio_dev)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	ret = __max78m6610_lmu_spi_reg_write(st, COMMAND, FLASHSAVE_CMD);
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_write_flash
+ *
+ * @param dev: device descriptor associated with sysfs attribute node
+ * @param attr: device sysfs attribute descriptor
+ * @param buf: data written by user to the attribute node
+ * @param len: length in bytes of data written by user
+ *
+ * This handles a write to this sysfs node from user-space, and invokes a
+ * flash-save command on the MAX78M6610+LMU if an appropriate value is written.
+ * Valid input character values are 1, y and Y.
+ */
+static ssize_t max78m6610_lmu_write_flash(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	int ret = 0;
+
+	if (len < 1)
+		return -1;
+	switch (buf[0]) {
+	case '1':
+	case 'y':
+	case 'Y':
+		ret = max78m6610_lmu_flash_save_cmd(indio_dev);
+		return ret ? ret : len;
+	}
+	return -1;
+}
+
+/**
+ * max78m6610_lmu_flash_save_cmd
+ *
+ * @param indio_dev: iio_dev pointer
+ *
+ * Executes a read of the STATUS register on the MAX78M6610+LMU.
+ * Event status bits are checked, and event notifications are raised for
+ * user-space applications if any events are asserted. Event status bits are
+ * sticky and are cleared by setting the corresponding bit in the STATUS_RESET
+ * register to allow further occurances of the same event to be detected
+ */
+static int max78m6610_lmu_status_scan(struct iio_dev *indio_dev)
+{
+	struct max78m6610_lmu_state *st = iio_priv(indio_dev);
+	unsigned status;
+	int ret;
+	u64 timestamp_ns = iio_get_time_ns();
+
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+		ret = -EBUSY;
+		goto exit_unlock;
+	}
+
+	ret = __max78m6610_lmu_spi_reg_read(st, STATUS, &status);
+	if (ret) {
+		pr_err("Failed to read STATUS register\n");
+		goto exit_unlock;
+	}
+
+	status &= ~STATUS_MASK_IGNORE;
+
+	/* Nothing more to do if no interesting status bits are set */
+	if (!status)
+		goto exit_unlock;
+
+	/* Not all of the event types used below are ideal, but there is a
+	 * limited set available and we want to use different event types for
+	 * the different events (e.g sag vs. min-threshold) to allow user
+	 * applications to distinguish them
+	 */
+	if (status & STATUS_MASK_VA_SAG) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
+						    IIO_EV_TYPE_MAG,
+						    IIO_EV_DIR_FALLING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_VB_SAG) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
+						    IIO_EV_TYPE_MAG,
+						    IIO_EV_DIR_FALLING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_VRMSA) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_UN_VRMSA) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_FALLING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_VRMSB) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_UN_VRMSB) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_FALLING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_VA_SURGE) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 0,
+						    IIO_EV_TYPE_MAG,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_VB_SURGE) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,
+						    IIO_EV_TYPE_MAG,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_WATT1) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_POWER, 0,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_WATT2) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_POWER, 1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_AMP1) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_CURRENT, 0,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+	if (status & STATUS_MASK_OV_AMP2) {
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(IIO_CURRENT, 1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			       timestamp_ns);
+	}
+
+	ret = __max78m6610_lmu_spi_reg_write(st, STATUS_RESET,
+					     status & STATUS_MASK_STICKY);
+	if (ret) {
+		pr_err("Failed to write STATUS_RESET register\n");
+		goto exit_unlock;
+	}
+
+exit_unlock:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/**
+ * max78m6610_lmu_write_status_scan
+ *
+ * @param dev: device descriptor associated with sysfs attribute node
+ * @param attr: device sysfs attribute descriptor
+ * @param buf: data written by user to the attribute node
+ * @param len: length in bytes of data written by user
+ *
+ * This handles a write to this sysfs node from user-space, and invokes a
+ * read of the status register on the MAX78M6610+LMU if an appropriate value
+ * is written.  Valid input character values are 1, y and Y
+ */
+static ssize_t max78m6610_lmu_write_status_scan(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	int ret = 0;
+
+	if (len < 1)
+		return -1;
+	switch (buf[0]) {
+	case '1':
+	case 'y':
+	case 'Y':
+		ret = max78m6610_lmu_status_scan(indio_dev);
+		return ret ? ret : len;
+	}
+	return -1;
+}
+
+/**
+ * max78m6610_lmu_write_int
+ *
+ * @param dev: device descriptor associated with sysfs attribute node
+ * @param attr: device sysfs attribute descriptor
+ * @param buf: data written by user to the attribute node
+ * @param len: length in bytes of data written by user
+ *
+ * This is a generic handler to write integer values to any integer registers
+ * which are exposed as device sysfs attributes on the user interface.
+ * The attribute address field specifies which register to write.
+ */
+
+static IIO_DEVICE_ATTR(do_reset, S_IWUSR, NULL,
+		       max78m6610_lmu_write_reset, 0);
+static IIO_DEVICE_ATTR(do_voltage0_gain_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S0_GAIN);
+static IIO_DEVICE_ATTR(do_current0_gain_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S1_GAIN);
+static IIO_DEVICE_ATTR(do_voltage1_gain_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S2_GAIN);
+static IIO_DEVICE_ATTR(do_current1_gain_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S3_GAIN);
+static IIO_DEVICE_ATTR(do_voltage0_offset_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S0_OFFS);
+static IIO_DEVICE_ATTR(do_current0_offset_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S1_OFFS);
+static IIO_DEVICE_ATTR(do_voltage1_offset_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S2_OFFS);
+static IIO_DEVICE_ATTR(do_current1_offset_calib, S_IWUSR, NULL,
+		       max78m6610_lmu_write_calib, CALCMD_S3_OFFS);
+static IIO_DEVICE_ATTR(do_save_to_flash, S_IWUSR, NULL,
+		       max78m6610_lmu_write_flash, 0);
+
+static struct attribute *max78m6610_lmu_attributes[] = {
+	&iio_dev_attr_do_reset.dev_attr.attr,
+	&iio_dev_attr_do_voltage0_gain_calib.dev_attr.attr,
+	&iio_dev_attr_do_current0_gain_calib.dev_attr.attr,
+	&iio_dev_attr_do_voltage1_gain_calib.dev_attr.attr,
+	&iio_dev_attr_do_current1_gain_calib.dev_attr.attr,
+	&iio_dev_attr_do_voltage0_offset_calib.dev_attr.attr,
+	&iio_dev_attr_do_current0_offset_calib.dev_attr.attr,
+	&iio_dev_attr_do_voltage1_offset_calib.dev_attr.attr,
+	&iio_dev_attr_do_current1_offset_calib.dev_attr.attr,
+	&iio_dev_attr_do_save_to_flash.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group max78m6610_lmu_attribute_group = {
+	.attrs = max78m6610_lmu_attributes,
+};
+
+/* Provides an option to poll for events (useful if interrupts unavailable) */
+static IIO_DEVICE_ATTR(do_status_scan, S_IWUSR, NULL,
+		       max78m6610_lmu_write_status_scan, 0);
+
+/* Need to have at least 1 event attribute to enable IIO events.
+ * Purposely not setting .event_mask for the channels because that would
+ * enable the IIO events sysfs entries which are not suitable for this driver
+ */
+static struct attribute *max78m6610_lmu_event_attributes[] = {
+	&iio_dev_attr_do_status_scan.dev_attr.attr,
+	NULL,
+};
+
+static struct attribute_group max78m6610_lmu_event_attribute_group = {
+	.attrs = max78m6610_lmu_event_attributes,
+};
+
+
 /* Driver specific iio info structure */
 static const struct iio_info max78m6610_lmu_info = {
 	.read_raw = max78m6610_lmu_read_raw,
+	.write_raw = max78m6610_lmu_write_raw,
+	.write_raw_get_fmt = max78m6610_lmu_write_raw_get_fmt,
+	.debugfs_reg_access = max78m6610_lmu_reg_access,
 	.update_scan_mode = max78m6610_lmu_update_scan_mode,
+	.event_attrs = &max78m6610_lmu_event_attribute_group,
+	.attrs = &max78m6610_lmu_attribute_group,
 	.driver_module = THIS_MODULE,
 };
 
+/**
+ * max78m6610_lmu_open
+ *
+ * @param inode: inode descriptor associated with char device
+ * @param filp: file object pointer
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * This handles an open syscall on the character device node
+ */
 static int
 max78m6610_lmu_open(struct inode *inode, struct file *filp)
 {
@@ -744,6 +1797,15 @@ max78m6610_lmu_open(struct inode *inode, struct file *filp)
 	return ret;
 }
 
+/**
+ * max78m6610_lmu_release
+ *
+ * @param inode: inode descriptor associated with char device
+ * @param filp: file object pointer
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * This handles a close syscall on the character device node
+ */
 static int
 max78m6610_lmu_release(struct inode *inode, struct file *filp)
 {
@@ -756,6 +1818,21 @@ max78m6610_lmu_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
+/**
+ * spidev_message
+ *
+ * @param st: driver state information
+ * @param u_xfers: spi transfer descriptor array
+ * @param n_xfers: number of spi transfer descriptors
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Translates a set of user-space SPI transfer requests to kernel-space
+ * equivalent, using bounce-buffers for the data, and invokes spi_sync()
+ * to execute the bi-directional SPI transfers
+ *
+ * The implementation below was borrowed directly from the spidev kernel driver
+ * with minor modifications to fit it in here
+ */
 static int spidev_message(struct max78m6610_lmu_state *st,
 			  struct spi_ioc_transfer *u_xfers,
 			  unsigned n_xfers)
@@ -848,6 +1925,19 @@ done:
 	return status;
 }
 
+/**
+ * max78m6610_lmu_ioctl
+ *
+ * @param filp: file object pointer
+ * @param cmd: ioctl command
+ * @param arg: optional data argument
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * This handles an ioctl syscall on the character device node.  This handler
+ * supports only the SPI_IOC_MESSAGE ioctl command defined in spidev.h
+ * The implementation below was borrowed from the spidev driver, with some minor
+ * modifications to remove support for other ioctl commands not needed here
+ */
 static long
 max78m6610_lmu_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
@@ -924,6 +2014,24 @@ static const struct file_operations max78m6610_lmu_fops = {
 	.unlocked_ioctl = max78m6610_lmu_ioctl,
 };
 
+/**
+ * max78m6610_lmu_chrdev_init
+ *
+ * @param st: driver state information
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Creates a character device to implement a subset of the spidev user-interface
+ * API, namely full-duplex SPI transfers via the ioctl() interface.
+ * The intention is to provide user-space applications with direct access to the
+ * underlying SPI device if required.  The user-space application is, in this
+ * mode of operation, responsible for directly constructing the SPI messages
+ * required by the MAX78M6610 and those messages are passed transparently
+ * through this driver.  This is needed, for example, to facilitate binary-only
+ * firmware update applications, but may also be used by user-space applications
+ * to access any device registers which have not been exposed by this driver.
+ *
+ * The device node created will appear in the filesystem as /dev/max78m6610_lmu
+ */
 static int
 max78m6610_lmu_chrdev_init(struct max78m6610_lmu_state *st)
 {
@@ -969,6 +2077,14 @@ max78m6610_lmu_chrdev_init(struct max78m6610_lmu_state *st)
 	return 0;
 }
 
+/**
+ * max78m6610_lmu_chrdev_remove
+ *
+ * @param st: driver state information
+ * @return 0 on success, non-zero errno otherwise
+ *
+ * Remove the character device created by max78m6610_lmu_chrdev_init()
+ */
 static int
 max78m6610_lmu_chrdev_remove(struct max78m6610_lmu_state *st)
 {
@@ -992,6 +2108,7 @@ static int max78m6610_lmu_probe(struct spi_device *spi)
 {
 	struct max78m6610_lmu_state *st;
 	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
+	struct max78m6610_lmu_platform_data *pdata = spi->dev.platform_data;
 	int ret;
 
 	if (indio_dev == NULL)
@@ -1001,6 +2118,11 @@ static int max78m6610_lmu_probe(struct spi_device *spi)
 	spi_set_drvdata(spi, indio_dev);
 	st->spi = spi;
 
+	if (pdata)
+		st->reset_gpio = pdata->reset_gpio;
+	else
+		st->reset_gpio = -1;
+
 	indio_dev->name = spi_get_device_id(spi)->name;
 	indio_dev->dev.parent = &spi->dev;
 	indio_dev->modes = INDIO_DIRECT_MODE;
diff --git a/drivers/iio/common/st_sensors/st_sensors_buffer.c b/drivers/iio/common/st_sensors/st_sensors_buffer.c
index 09b236d..a269b7d 100644
--- a/drivers/iio/common/st_sensors/st_sensors_buffer.c
+++ b/drivers/iio/common/st_sensors/st_sensors_buffer.c
@@ -57,8 +57,7 @@ int st_sensors_get_buffer_element(struct iio_dev *indio_dev, u8 *buf)
 			if (len < 0)
 				goto read_data_channels_error;
 
-			for (i = 0; i < n * ST_SENSORS_NUMBER_DATA_CHANNELS;
-									i++) {
+			for (i = 0; n + i < sizeof(rx_array); i++){
 				if (i < n)
 					buf[i] = rx_array[i];
 				else
diff --git a/drivers/iio/trigger/iio-trig-hrtimer.c b/drivers/iio/trigger/iio-trig-hrtimer.c
index 3f7d5b8..5dc30e5 100644
--- a/drivers/iio/trigger/iio-trig-hrtimer.c
+++ b/drivers/iio/trigger/iio-trig-hrtimer.c
@@ -2,7 +2,7 @@
  * Industrial I/O - hrtimer trigger support
  *
  * Copyright 2013 STMicroelectronics Inc.
- * Denis Ciocca <denis.ciocca@xxxxxx>
+ * Denis Ciocca <denis.ciocca@st.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published by
@@ -86,9 +86,15 @@ static const struct attribute_group *iio_hrtimer_trig_groups[] = {
 	NULL,
 };
 
+/* Nothing to actually do upon release */
+static void iio_hrtimer_trig_release(struct device *dev)
+{
+}
+
 static struct device iio_hrtimer_trig_dev = {
 	.bus = &iio_bus_type,
 	.groups = iio_hrtimer_trig_groups,
+	.release = &iio_hrtimer_trig_release,
 };
 
 static int iio_hrtimer_trig_set_state(struct iio_trigger *trig, bool state)
@@ -277,6 +283,6 @@ static void __exit iio_hrtimer_trig_exit(void)
 }
 module_exit(iio_hrtimer_trig_exit);
 
-MODULE_AUTHOR("Denis Ciocca <denis.ciocca@xxxxxx>");
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
 MODULE_DESCRIPTION("Hrtimer trigger for the iio subsystem");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 5eee673..cc13477 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -749,21 +749,21 @@ config CY8C9540A
 	  Select this option to enable support for the CY8C9540 I/O expander.
 	  This device provides 40 interrupt-capable GPIOs, 8 PWMs and an EEPROM.
 
-config INTEL_CLN_GIP
-	tristate "Intel Clanton GIP"
+config INTEL_QRK_GIP
+	tristate "Intel Quark GIP"
 	depends on PCI && X86 && INTEL_QUARK_X1000_SOC
 	depends on I2C
 	select GENERIC_IRQ_CHIP
 	help
-	  GIP driver for Clanton SoC.
-	  Clanton GIP is a single PCI function exporting a GPIO and an I2C
+	  GIP driver for Quark SoC.
+	  Quark GIP is a single PCI function exporting a GPIO and an I2C
 	  controller, namely Synopsys DesignWare GPIO and Synopsys DesignWare
 	  I2C. The GPIO interface exports a total amount of 8 interrupt-capable
 	  GPIO.
 
-config INTEL_CLN_GIP_TEST
-	tristate "Intel Clanton GIP support for Integration Testing"
-	depends on INTEL_CLN_GIP
+config INTEL_QRK_GIP_TEST
+	tristate "Intel Quark GIP support for Integration Testing"
+	depends on INTEL_QRK_GIP
 	select I2C_CHARDEV
 	select GPIO_SYSFS
 	select SPI
@@ -772,11 +772,11 @@ config INTEL_CLN_GIP_TEST
 	select SPI_MASTER
 	select SPI_SPIDEV
 	help
-	  Clanton GIP automated Integration Testing package.
+	  Quark GIP automated Integration Testing package.
 	  It selects kernel components needed for GPIO and I2C tests as per
 	  Integration Test Specification, and it also adds a kernel-space
 	  facility for testing the GPIO.
-	  Note this module is also used to test the Clanton Legacy GPIO.
+	  Note this module is also used to test the Quark Legacy GPIO.
 
 config LPC_SCH
 	tristate "Intel SCH LPC"
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 992f71a..e2b0971 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -99,13 +99,13 @@ obj-$(CONFIG_MFD_DB5500_PRCMU)	+= db5500-prcmu.o
 obj-$(CONFIG_MFD_TIMBERDALE)    += timberdale.o
 obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
 obj-$(CONFIG_CY8C9540A)		+= cy8c9540a.o
-obj-$(CONFIG_INTEL_CLN_GIP)	+= intel_cln_gip.o
-intel_cln_gip-objs		:= intel_cln_gip_core.o \
-					intel_cln_gip_gpio.o \
-					intel_cln_gip_i2c.o \
+obj-$(CONFIG_INTEL_QRK_GIP)	+= intel_qrk_gip.o
+intel_qrk_gip-objs		:= intel_qrk_gip_core.o \
+					intel_qrk_gip_gpio.o \
+					intel_qrk_gip_i2c.o \
 					../i2c/busses/i2c-designware-core.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_gip_pdata.o
-obj-$(CONFIG_INTEL_CLN_GIP_TEST)+= intel_cln_gip_test.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_gip_pdata.o
+obj-$(CONFIG_INTEL_QRK_GIP_TEST)+= intel_qrk_gip_test.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
 obj-$(CONFIG_MFD_JANZ_CMODIO)	+= janz-cmodio.o
diff --git a/drivers/mfd/cy8c9540a.c b/drivers/mfd/cy8c9540a.c
index 0e4ea5e..444e5ab 100644
--- a/drivers/mfd/cy8c9540a.c
+++ b/drivers/mfd/cy8c9540a.c
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2013 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
diff --git a/drivers/mfd/intel_cln_gip.h b/drivers/mfd/intel_cln_gip.h
deleted file mode 100644
index 80472ae..0000000
--- a/drivers/mfd/intel_cln_gip.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton GIP (GPIO/I2C) driver
- */
-
-#ifndef __INTEL_CLNGIP_H__
-#define __INTEL_CLNGIP_H__
-
-#include <linux/i2c.h>
-#include <linux/mfd/intel_cln_gip_pdata.h>
-#include <linux/pci.h>
-#include "../i2c/busses/i2c-designware-core.h"
-
-/* PCI BAR for register base address */
-#define GIP_I2C_BAR		0
-#define GIP_GPIO_BAR		1
-
-/**
- * intel_cln_gpio_probe
- *
- * @param pdev: Pointer to GIP PCI device
- * @return 0 success < 0 failure
- *
- * Perform GPIO-specific probing on behalf of the top-level GIP driver.
- */
-int intel_cln_gpio_probe(struct pci_dev *pdev);
-
-/**
- * intel_cln_gpio_remove
- *
- * @param pdev: Pointer to GIP PCI device
- *
- * Perform GPIO-specific resource release on behalf of the top-level GIP driver.
- */
-void intel_cln_gpio_remove(struct pci_dev *pdev);
-
-/**
- * intel_cln_gpio_isr
- *
- * @param irq: IRQ number to be served
- * @param dev_id: used to distinguish the device (for shared interrupts)
- *
- * Perform GPIO-specific ISR of the top-level GIP driver.
- */
-irqreturn_t intel_cln_gpio_isr(int irq, void *dev_id);
-
-/**
- * intel_cln_gpio_save_state
- *
- * Save GPIO register state for system-wide suspend events and mask out
- * interrupts.
- */
-void intel_cln_gpio_save_state(void);
-
-/**
- * intel_cln_gpio_restore_state
- *
- * Restore GPIO register state for system-wide resume events and clear out
- * spurious interrupts.
- */
-void intel_cln_gpio_restore_state(void);
-
-/**
- * intel_cln_i2c_probe
- * @param pdev: Pointer to GIP PCI device
- * @param drvdata: private driver data
- * @param drvdata: GIP platform-specific settings
- * @return 0 success < 0 failure
- *
- * Perform I2C-specific probing on behalf of the top-level GIP driver.
- */
-int intel_cln_i2c_probe(struct pci_dev *pdev, 
-			struct dw_i2c_dev **drvdata,
-			struct intel_cln_gip_pdata *pdata);
-
-/**
- * intel_cln_i2c_remove
- * @param pdev: Pointer to GIP PCI device
- * @param dev: Pointer to I2C private data 
- *
- * Perform I2C-specific resource release on behalf of the top-level GIP driver.
- */
-void intel_cln_i2c_remove(struct pci_dev *pdev,
-	struct dw_i2c_dev *dev);
-
-#endif /* __INTEL_CLNGIP_H__ */
diff --git a/drivers/mfd/intel_cln_gip_core.c b/drivers/mfd/intel_cln_gip_core.c
deleted file mode 100644
index 24f175d..0000000
--- a/drivers/mfd/intel_cln_gip_core.c
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton GIP (GPIO/I2C) PCI driver
- *
- *  PCI glue logic for Clanton GIP driver.
- *  Clanton GIP is a single PCI function exporting a GPIO and an I2C device.
- *  The PCI driver performs the bus-dependent probe/release operations, and
- *  call into GPIO/I2C specific modules for handling the two diffrerent
- *  functionalities.
- */
-
-#include <asm/cln.h>
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/mfd/intel_cln_gip_pdata.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include "intel_cln_gip.h"
-
-static unsigned int enable_msi = 1;
-module_param(enable_msi, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
-
-static unsigned int i2c = 1;
-module_param(i2c, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(i2c, "Register I2C adapter");
-
-static unsigned int gpio = 1;
-module_param(gpio, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(gpio, "Register GPIO chip");
-
-/* GIP private data, supporting only a single instance of the device. */
-struct intel_cln_gip_data {
-	struct pci_dev *pci_device;
-	struct dw_i2c_dev *i2c_drvdata;
-	struct intel_cln_gip_pdata *pdata;
-};
-
-/**
- * intel_cln_gip_handler
- *
- * @param irq: IRQ number to be served
- * @param dev_id: device private data
- *
- * Top-level interrupt handler for GIP driver.
- * It calls into the appropriate sub-routines and gathers the return values.
- */
-static irqreturn_t intel_cln_gip_handler(int irq, void *dev_id)
-{
-	irqreturn_t ret_i2c = IRQ_NONE;
-	irqreturn_t ret_gpio = IRQ_NONE;
-	struct intel_cln_gip_data *data = (struct intel_cln_gip_data *)dev_id;
-
-	mask_pvm(data->pci_device);
-
-	if (likely(i2c)) {
-		/* Only I2C gets platform data */
-		ret_i2c = i2c_dw_isr(irq, data->i2c_drvdata);
-	}
-
-	if (likely(gpio)) {
-		ret_gpio = intel_cln_gpio_isr(irq, NULL);
-	}
-
-	unmask_pvm(data->pci_device);
-
-	if (likely(IRQ_HANDLED == ret_i2c || IRQ_HANDLED == ret_gpio))
-		return IRQ_HANDLED;
-
-	/* Each sub-ISR routine returns either IRQ_HANDLED or IRQ_NONE. */
-	return IRQ_NONE;
-}
-
-static DEFINE_PCI_DEVICE_TABLE(intel_cln_gip_ids) = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0934), },
-	{ 0, }
-};
-MODULE_DEVICE_TABLE(pci, intel_cln_gip_ids);
-
-#ifdef CONFIG_PM
-
-/**
- * cln_gip_suspend
- * 
- * @param device: Pointer to device
- * @return 0 success < 0 failure
- *
- * Prepare GIP for system-wide transition to sleep state.
- * Save context, disable GPIO chip and I2C adapter, transition PCI device into
- * low-power state.
- */
-static int cln_gip_suspend(struct device *dev)
-{
-	int err = 0;
-	struct intel_cln_gip_data *data = NULL;
-	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
-	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
-
-	i2c_dw_disable(data->i2c_drvdata);
-	intel_cln_gpio_save_state();
-
-	err = pci_save_state(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "pci_save_state failed\n");
-		return err;
-	}
-
-	err = pci_set_power_state(pdev, PCI_D3hot);
-	if (err) {
-		dev_err(&pdev->dev, "pci_set_power_state failed\n");
-		return err;
-	}
-
-	return 0;
-}
-
-/**
- * cln_gip_resume
- * 
- * @param device: Pointer to device
- * @return 0 success < 0 failure
- *
- * Prepare GIP for system-wide transition to fully active state.
- * Set PCI device into full-power state, restore context, enable I2C adapter
- * and GPIO chip.
- */
-static int cln_gip_resume(struct device *dev)
-{
-	int err = 0;
-	struct intel_cln_gip_data *data = NULL;
-	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
-	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
-
-	err = pci_set_power_state(pdev, PCI_D0);
-	if (err) {
-		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
-		return err;
-	}
-
-	pci_restore_state(pdev);
-
-	intel_cln_gpio_restore_state();
-	i2c_dw_init(data->i2c_drvdata);
-
-	return 0;
-}
-
-#else
-#define cln_gip_suspend		NULL
-#define cln_gip_resume		NULL
-#endif
-
-static const struct dev_pm_ops cln_gip_pm_ops = {
-	.resume         = cln_gip_resume,
-	.suspend        = cln_gip_suspend,
-};
-
-/**
- * intel_cln_gip_probe
- *
- * @param pdev: Pointer to GIP PCI device
- * @param id: GIP PCI Device ID
- * @return 0 success < 0 failure
- *
- * GIP PCI driver probing. Calls into the appropriate probe routines for GPIO
- * and I2C too.
- */
-static int intel_cln_gip_probe(struct pci_dev *pdev,
-				const struct pci_device_id *id)
-{
-	int retval = 0;
-	struct intel_cln_gip_data *gip_drvdata = NULL;
-
-	retval = pci_enable_device(pdev);
-	if (retval)
-		return retval;
-
-	retval = pci_request_regions(pdev, "cln-gip");
-	if (retval) {
-		dev_err(&pdev->dev, "error requesting PCI region\n");
-		goto err_pcidev_disable;
-	}
-
-	gip_drvdata = kzalloc(sizeof(struct intel_cln_gip_data), GFP_KERNEL);
-	if (NULL == gip_drvdata) {
-		retval = -ENOMEM;
-		goto err_pciregions_release;
-	}
-	pci_set_drvdata(pdev, gip_drvdata);
-
-	gip_drvdata->pci_device = pdev; 
-
-	/* Retrieve platform data if there is any */
-	if (*intel_cln_gip_get_pdata) {
-		gip_drvdata->pdata = intel_cln_gip_get_pdata();
-	}
-
-	if (gpio) {
-		retval = intel_cln_gpio_probe(pdev);
-		if (retval)
-			goto err_release_drvdata;
-	}
-
-	if (i2c) {
-		retval = intel_cln_i2c_probe(pdev,
-			(struct dw_i2c_dev **)&gip_drvdata->i2c_drvdata,
-			gip_drvdata->pdata);
-		if (retval)
-			goto err_release_drvdata;
-	}
-
-	if (enable_msi) {
-		pci_set_master(pdev);
-		retval = pci_enable_msi(pdev);
-		if (retval)
-			goto err_release_drvdata;
-	}
-
-	/*
-	 * Request a shared IRQ.
-	 * Since the dev_id cannot be NULL, it points to PCI device descriptor
-	 * if I2C is not registered.
-	 */
-	retval = request_irq(pdev->irq, intel_cln_gip_handler, IRQF_SHARED,
-			"intel_cln_gip", gip_drvdata);
-	if (retval) {
-		dev_err(&pdev->dev, "error requesting IRQ\n");
-		goto err;
-	}
-
-	return 0;
-
-err_release_drvdata:
-	pci_set_drvdata(pdev, NULL);
-	kfree(gip_drvdata);
-err:
-	if (enable_msi)
-		pci_disable_msi(pdev);
-err_pciregions_release:
-	pci_release_regions(pdev);
-err_pcidev_disable:
-	pci_disable_device(pdev);
-
-	return retval;
-}
-
-/**
- * intel_cln_gip_remove
- *
- * @param pdev: Pointer to GIP PCI device
- *
- * Release resources. Calls into GPIO/I2C dedicate routines too.
- */
-static void intel_cln_gip_remove(struct pci_dev *pdev)
-{
-	struct intel_cln_gip_data *data = NULL;
-
-	data = (struct intel_cln_gip_data *)pci_get_drvdata(pdev);
-
-	if (NULL == data) {
-		dev_err(&pdev->dev, "%s: failure getting driver data\n",
-			__func__);
-		return;
-	}
-
-	free_irq(pdev->irq, data);
-
-	if (enable_msi) {
-		pci_clear_master(pdev);
-		if (pci_dev_msi_enabled(pdev))
-			pci_disable_msi(pdev);
-	}
-
-	if (i2c)
-		intel_cln_i2c_remove(pdev, data->i2c_drvdata);
-
-	if (gpio)
-		intel_cln_gpio_remove(pdev);
-
-	pci_set_drvdata(pdev, NULL);
-	kfree(data);
-
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-}
-
-static struct pci_driver intel_cln_gip_driver = {
-	.name =		"intel_cln_gip",
-	.id_table	= intel_cln_gip_ids,
-	.probe		= intel_cln_gip_probe,
-	.remove		= intel_cln_gip_remove,
-	.driver         = {
-		.pm     = &cln_gip_pm_ops,
-	},
-};
-
-static int intel_cln_gip_init(void)
-{
-	return pci_register_driver(&intel_cln_gip_driver);
-}
-
-static void intel_cln_gip_exit(void)
-{
-	pci_unregister_driver(&intel_cln_gip_driver);
-}
-
-module_init(intel_cln_gip_init);
-module_exit(intel_cln_gip_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Clanton GIP driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/mfd/intel_cln_gip_gpio.c b/drivers/mfd/intel_cln_gip_gpio.c
deleted file mode 100644
index 6e2bbbf..0000000
--- a/drivers/mfd/intel_cln_gip_gpio.c
+++ /dev/null
@@ -1,660 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton GIP (GPIO/I2C) - GPIO-specific PCI and core driver
- *
- *  PCI glue logic and core driver for Clanton GIP/GPIO.
- *  The GIP GPIO device is the DesignWare GPIO. This file defines the PCI glue
- *  for this driver and as well as the core logic for the device.
- *  Please note only a single instance of the GPIO device is supported.
- *  The default number of GPIO is 8, all interrupt-capable.
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/platform_device.h>
-#include <linux/uio_driver.h>
-#include "intel_cln_gip.h"
-
-static void cln_gpio_restrict_release(struct device *dev) {}
-static struct platform_device cln_gpio_restrict_pdev = 
-{
-	.name	= "cln-gpio-restrict-sc",
-	.dev.release = cln_gpio_restrict_release,
-};
-struct uio_info *info;
-
-/* The base GPIO number under GPIOLIB framework */
-#define INTEL_CLN_GIP_GPIO_BASE		8
-
-/* The default number of South-Cluster GPIO on Clanton. */
-#define INTEL_CLN_GIP_NGPIO		8
-
-/*
- * The default base IRQ for searching and allocating the range of GPIO IRQ
- * descriptors.
- */
-#define INTEL_CLN_GIP_GPIO_IRQBASE	56
-
-/* The GPIO private data. */
-static struct gpio_chip *gc;
-static struct irq_chip_generic *igc;
-static void __iomem *reg_base;
-static spinlock_t lock;
-static int irq_base;
-static unsigned int n_gpio = INTEL_CLN_GIP_NGPIO;
-static unsigned int gpio_irqbase = INTEL_CLN_GIP_GPIO_IRQBASE;
-
-/* Store GPIO context across system-wide suspend/resume transitions */
-static struct gpio_saved_regs {
-	u32 data;
-	u32 dir;
-	u32 int_en;
-	u32 int_mask; 
-	u32 int_type; 
-	u32 int_pol; 
-	u32 int_deb; 
-} saved_regs;
-
-/* PortA registers set. Note other ports are unused */
-#define PORTA_DATA			0x00	/* Data */
-#define PORTA_DIR			0x04	/* Direction */
-#define PORTA_INT_EN			0x30	/* Interrupt enable */
-#define PORTA_INT_MASK			0x34	/* Interrupt mask */
-#define PORTA_INT_TYPE_LEVEL		0x38	/* Interrupt level*/
-#define PORTA_INT_POLARITY		0x3c	/* Interrupt polarity */
-#define PORTA_INT_STATUS		0x40	/* Interrupt status */
-#define PORTA_INT_RAW_STATUS		0x44	/* Interrupt raw status */
-#define PORTA_DEBOUNCE			0x48	/* Debounce enable */
-#define PORTA_INT_EOI			0x4c	/* Clear interrupt */
-#define PORTA_EXT			0x50	/* External */
-
-module_param(n_gpio, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(n_gpio, "Number of GPIO");
-
-module_param(gpio_irqbase, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(gpio_irqbase, "Base IRQ for GPIO range");
-
-/**
- * intel_cln_gpio_get
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- * @return 0 if GPIO is deasserted, 1 if GPIO is asserted
- *
- * Read back the value of a GPIO.
- */
-static int intel_cln_gpio_get(struct gpio_chip *chip, unsigned offset)
-{
-	void __iomem *reg_ext = reg_base + PORTA_EXT;
-	u32 val_ext = ioread32(reg_ext);
-
-	val_ext &= BIT(offset % 32);
-	return (val_ext > 0);
-}
-
-/**
- * intel_cln_gpio_set
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- *
- * Set value of a GPIO.
- */
-static void intel_cln_gpio_set(struct gpio_chip *chip, unsigned offset,
-				int value)
-{
-	void __iomem *reg_data = reg_base + PORTA_DATA;
-	u32 val_data = 0;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lock, flags);
-
-	val_data = ioread32(reg_data);
-	if (value)
-		iowrite32(val_data | BIT(offset % 32), reg_data);
-	else
-		iowrite32(val_data & ~BIT(offset % 32), reg_data);
-
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_direction_input
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- * @return always 0 (success)
- *
- * Set direction of a GPIO as input.
- */
-static int intel_cln_gpio_direction_input(struct gpio_chip *chip,
-						unsigned offset)
-{
-	u32 val_dir = 0;
-	void __iomem *reg_dir = reg_base + PORTA_DIR;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lock, flags);
-
-	val_dir = ioread32(reg_dir);
-	iowrite32(val_dir & ~BIT(offset % 32), reg_dir);
-
-	spin_unlock_irqrestore(&lock, flags);
-
-	return 0;
-}
-
-/**
- * intel_cln_gpio_direction_output
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- * @param value: value to be driven to the GPIO
- * @return always 0 (success)
- *
- * Set the default value of a GPIO, and then set direction as output.
- */
-static int intel_cln_gpio_direction_output(struct gpio_chip *chip,
-			unsigned offset, int value)
-{
-	u32 val_dir = 0;
-	void __iomem *reg_dir = reg_base + PORTA_DIR;
-	unsigned long flags = 0;
-
-	/* Ensure glitch-free operation. */
-	intel_cln_gpio_set(chip, offset, value);
-
-	spin_lock_irqsave(&lock, flags);
-
-	val_dir = ioread32(reg_dir);
-	iowrite32(val_dir | BIT(offset % 32), reg_dir);
-
-	spin_unlock_irqrestore(&lock, flags);
-
-	return 0;
-}
-
-/**
- * intel_cln_gpio_set_debounce
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- * @param debounce: 1 to enable, 0 to disable
- * @return always 0 (success)
- *
- * Enable/disable interrupt debounce logic for a GPIO.
- */
-static int intel_cln_gpio_set_debounce(struct gpio_chip *chip,
-				 unsigned offset, unsigned debounce)
-{
-	u32 val_deb = 0;
-	void __iomem *reg_deb = reg_base + PORTA_DEBOUNCE;
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lock, flags);
-
-	val_deb = ioread32(reg_deb);
-	if (debounce)
-		iowrite32(val_deb | BIT(offset % 32), reg_deb);
-	else
-		iowrite32(val_deb & ~BIT(offset % 32), reg_deb);
-
-	spin_unlock_irqrestore(&lock, flags);
-
-	return 0;
-}
-
-/**
- * intel_cln_gpio_irq_type
- * @param irq_data: Pointer to information about the IRQ
- * @param type: set the triggering type of the interrupt
- * @return always 0 (success)
- *
- * Set interrupt triggering type for a GPIO.
- */
-static int intel_cln_gpio_irq_type(struct irq_data *d, unsigned type)
-{
-	int ret = 0;
-	unsigned long flags = 0;
-	void __iomem *reg_level = reg_base + PORTA_INT_TYPE_LEVEL;
-	void __iomem *reg_pol = reg_base + PORTA_INT_POLARITY;
-	u32 val_level = 0;
-	u32 val_pol = 0;
-	u32 gpio = 0;
-
-	if (NULL == d) {
-		pr_err("%s(): null irq_data\n",  __func__);
-		return -EFAULT;
-	}
-
-	gpio = d->irq - irq_base;
-
-	spin_lock_irqsave(&lock, flags);
-
-	val_level = ioread32(reg_level);
-	val_pol = ioread32(reg_pol);
-
-	switch (type) {
-	case IRQ_TYPE_EDGE_RISING:
-		iowrite32(val_level | BIT(gpio % 32), reg_level);
-		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		iowrite32(val_level | BIT(gpio % 32), reg_level);
-		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
-		break;
-	case IRQ_TYPE_LEVEL_HIGH:
-		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
-		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
-		break;
-	case IRQ_TYPE_LEVEL_LOW:
-		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
-		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	spin_unlock_irqrestore(&lock, flags);
-
-	return ret;
-}
-
-/**
- * intel_cln_gpio_irq_unmask
- * @param irq_data: Pointer to information about the IRQ
- *
- * Unmask interrupts for a GPIO.
- */
-static void intel_cln_gpio_irq_unmask(struct irq_data *d)
-{
-	unsigned long flags = 0;
-	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
-	u32 val_mask = 0;
-	unsigned gpio = 0;
-
-	if (NULL == d) {
-		pr_err("%s(): null irq_data\n", __func__);
-		return;
-	}
-
-	gpio = d->irq - irq_base;
-
-	spin_lock_irqsave(&lock, flags);
-	val_mask =  ioread32(reg_mask);
-	iowrite32(val_mask | BIT(gpio % 32), reg_mask);
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_irq_mask
- * @param irq_data: Pointer to information about the IRQ
- *
- * Mask interrupts for a GPIO.
- */
-static void intel_cln_gpio_irq_mask(struct irq_data *d)
-{
-	unsigned long flags = 0;
-	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
-	u32 val_mask = 0;
-	unsigned gpio = 0;
-
-	if (NULL == d) {
-		pr_err("%s(): null irq_data\n", __func__);
-		return;
-	}
-
-	gpio = d->irq - irq_base;
-
-	spin_lock_irqsave(&lock, flags);
-	val_mask =  ioread32(reg_mask);
-	iowrite32(val_mask & ~BIT(gpio % 32), reg_mask);
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_irq_enable
- * @param irq_data: Pointer to information about the IRQ
- *
- * Enable interrupts for a GPIO.
- */
-static void intel_cln_gpio_irq_enable(struct irq_data *d)
-{
-	unsigned long flags = 0;
-	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
-	u32 val_inte = 0;
-	unsigned gpio = 0;
-
-	if (NULL == d) {
-		pr_err("%s(): null irq_data\n", __func__);
-		return;
-	}
-
-	gpio = d->irq - irq_base;
-
-	spin_lock_irqsave(&lock, flags);
-	val_inte =  ioread32(reg_inte);
-	iowrite32(val_inte | BIT(gpio % 32), reg_inte);
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_irq_disable
- * @param irq_data: Pointer to information about the IRQ
- *
- * Disable interrupts for a GPIO.
- */
-static void intel_cln_gpio_irq_disable(struct irq_data *d)
-{
-	unsigned long flags = 0;
-	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
-	u32 val_inte = 0;
-	unsigned gpio = 0;
-
-	if (NULL == d) {
-		pr_err("%s(): null irq_data\n", __func__);
-		return;
-	}
-
-	gpio = d->irq - irq_base;
-
-	spin_lock_irqsave(&lock, flags);
-	val_inte =  ioread32(reg_inte);
-	iowrite32(val_inte & ~BIT(gpio % 32), reg_inte);
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_to_irq
- * @param chip: Pointer to GPIO chip registered by GPIOLIB
- * @param offset: the GPIO number within the GPIOLIB chip
- * @return IRQ associated to GPIO
- *
- * Compute the IRQ number based on the GPIO.
- */
-static int intel_cln_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	return irq_base + offset;
-}
-
-/**
- * intel_cln_gpio_isr
- * @param irq: IRQ number
- * @param dev_id: cookie used to tell what instance of the driver the interrupt
- *                belongs to
- * @return IRQ_HANDLED if interrupt served, IRQ_NONE if no interrupt pending
- *
- * Interrupt Service Routine for GPIO. Identify which GPIOs (if any) is pending
- * for interrupt to be served, acknowledge the interrupt and serve it.
- */
-irqreturn_t intel_cln_gpio_isr(int irq, void *dev_id)
-{
-	irqreturn_t ret = IRQ_NONE;
-	u32 pending = 0, gpio = 0;
-	void __iomem *reg_pending = reg_base + PORTA_INT_STATUS;
-	void __iomem *reg_eoi = reg_base + PORTA_INT_EOI;
-
-	/* Which pin (if any) triggered the interrupt */
-	while ((pending = ioread32(reg_pending))) {
-		/*
-		 * Acknowledge all the asserted GPIO interrupt lines before
-		 * serving them, so that we don't lose an edge.
-		 * This has only effect on edge-triggered interrupts.
-		 */
-		iowrite32(pending, reg_eoi);
-
-		/* Serve each asserted interrupt */
-		do {
-			gpio = __ffs(pending);
-			generic_handle_irq(
-				gpio_to_irq(INTEL_CLN_GIP_GPIO_BASE + gpio));
-			pending &= ~BIT(gpio);
-			ret = IRQ_HANDLED;
-		} while(pending);
-	}
-
-	return ret;
-}
-
-/**
- * intel_cln_gpio_save_state
- *
- * Save GPIO register state for system-wide suspend events and mask out
- * interrupts.
- */
-void intel_cln_gpio_save_state(void)
-{
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lock, flags);
-
-	saved_regs.int_mask = ioread32(reg_base + PORTA_INT_MASK);
-	saved_regs.int_en = ioread32(reg_base + PORTA_INT_EN);
-	saved_regs.int_deb = ioread32(reg_base + PORTA_DEBOUNCE);
-	saved_regs.int_pol = ioread32(reg_base + PORTA_INT_POLARITY);
-	saved_regs.int_type = ioread32(reg_base + PORTA_INT_TYPE_LEVEL);
-	saved_regs.dir = ioread32(reg_base + PORTA_DIR);
-	saved_regs.data = ioread32(reg_base + PORTA_DATA);
-
-	/* Mask out interrupts */
-	iowrite32(0xffffffff, reg_base + PORTA_INT_MASK);
-
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_restore_state
- *
- * Restore GPIO register state for system-wide resume events and clear out
- * spurious interrupts.
- */
-void intel_cln_gpio_restore_state(void)
-{
-	unsigned long flags = 0;
-
-	spin_lock_irqsave(&lock, flags);
-
-	iowrite32(saved_regs.data, reg_base + PORTA_DATA);
-	iowrite32(saved_regs.dir, reg_base + PORTA_DIR);
-	iowrite32(saved_regs.int_type, reg_base + PORTA_INT_TYPE_LEVEL);
-	iowrite32(saved_regs.int_pol, reg_base + PORTA_INT_POLARITY);
-	iowrite32(saved_regs.int_deb, reg_base + PORTA_DEBOUNCE);
-	iowrite32(saved_regs.int_en, reg_base + PORTA_INT_EN);
-	iowrite32(saved_regs.int_mask, reg_base + PORTA_INT_MASK);
-
-	/* Clear out spurious interrupts */
-	iowrite32(0xffffffff, reg_base + PORTA_INT_EOI);
-
-	spin_unlock_irqrestore(&lock, flags);
-}
-
-/**
- * intel_cln_gpio_probe
- * @param pdev: Pointer to GIP PCI device
- * @return 0 success < 0 failure
- *
- * Perform GPIO-specific probing on behalf of the top-level GIP driver.
- * Initiate the GPIO device.
- */
-int intel_cln_gpio_probe(struct pci_dev *pdev)
-{
-	int retval = 0;
-	resource_size_t start = 0, len = 0;
-
-	/* Get UIO memory */
-	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
-
-	/* Determine the address of the GPIO area */
-	start = pci_resource_start(pdev, GIP_GPIO_BAR);
-	len = pci_resource_len(pdev, GIP_GPIO_BAR);
-	if (!start || len == 0) {
-		dev_err(&pdev->dev, "bar%d not set\n", GIP_GPIO_BAR);
-		retval = -ENODEV;
-		goto exit;
-	}
-
-	reg_base = ioremap_nocache(start, len);
-	if (NULL == reg_base) {
-		dev_err(&pdev->dev, "I/O memory remapping failed\n");
-		retval = -EFAULT;
-		goto exit;
-	}
-
-	memset(&saved_regs, 0x0, sizeof(saved_regs));
-
-	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
-	if (!gc) {
-		retval = -ENOMEM;
-		goto err_iounmap;
-	}
-
-	if (n_gpio == 0 || n_gpio > INTEL_CLN_GIP_NGPIO) {
-		dev_err(&pdev->dev, "n_gpio outside range [1,%d]\n",
-			INTEL_CLN_GIP_NGPIO);
-		retval = -EINVAL;
-		goto err_free_gpiochip;
-	}
-
-	gc->label = "intel_cln_gip_gpio";
-	gc->owner = THIS_MODULE;
-	gc->direction_input = intel_cln_gpio_direction_input;
-	gc->direction_output = intel_cln_gpio_direction_output;
-	gc->get = intel_cln_gpio_get;
-	gc->set = intel_cln_gpio_set;
-	gc->set_debounce = intel_cln_gpio_set_debounce;
-	gc->to_irq = intel_cln_gpio_to_irq;
-	gc->base = INTEL_CLN_GIP_GPIO_BASE;
-	gc->ngpio = n_gpio;
-	gc->can_sleep = 0;
-	retval = gpiochip_add(gc);
-	if (retval) {
-		dev_err(&pdev->dev, "failure adding GPIO chip\n");
-		goto err_free_gpiochip;
-	}
-
-	spin_lock_init(&lock);
-
-	/*
-	 * Allocate a range of IRQ descriptor for the available GPIO.
-	 * IRQs are allocated dynamically.
-	 */
-	irq_base = irq_alloc_descs(-1, gpio_irqbase, n_gpio, NUMA_NO_NODE);
-	if (irq_base < 0) {
-		dev_err(&pdev->dev, "failure adding GPIO IRQ descriptors\n");
-		goto err_remove_gpiochip;
-	}
-
-	retval = platform_device_register(&cln_gpio_restrict_pdev);
-	if (retval < 0){
-		goto err_free_irq_descs;
-	}
-
-	igc = irq_alloc_generic_chip("intel_cln_gip_gpio", 1, irq_base,
-			reg_base, handle_simple_irq);
-	if (NULL == igc) {
-		retval = -ENOMEM;
-		goto err_free_irq_descs;
-	}
-
-	/* UIO */
-	info->mem[0].addr = start;
-	info->mem[0].internal_addr = reg_base;
-	info->mem[0].size = len;
-	info->mem[0].memtype = UIO_MEM_PHYS;
-	info->mem[0].name = "gpio_regs";
-	info->name = "gpio uio";
-	info->version = "0.0.1";
-
-	if (uio_register_device(&pdev->dev, info))
-		goto err_free_irq_descs;
-
-	pr_info("%s UIO addr 0x%08x internal_addr 0x%08x size %lu memtype %d\n",
-		__func__, (unsigned int)info->mem[0].addr,
-		(unsigned int)info->mem[0].internal_addr, info->mem[0].size,
-		info->mem[0].memtype);
-	igc->chip_types->chip.irq_mask = intel_cln_gpio_irq_mask;
-	igc->chip_types->chip.irq_unmask = intel_cln_gpio_irq_unmask;
-	igc->chip_types->chip.irq_set_type = intel_cln_gpio_irq_type;
-	igc->chip_types->chip.irq_enable = intel_cln_gpio_irq_enable;
-	igc->chip_types->chip.irq_disable = intel_cln_gpio_irq_disable;
-
-	irq_setup_generic_chip(igc, IRQ_MSK(n_gpio), IRQ_GC_INIT_MASK_CACHE,
-			IRQ_NOREQUEST | IRQ_NOPROBE, 0);
-
-	return 0;
-
-err_free_irq_descs:
-	irq_free_descs(irq_base, n_gpio);
-err_remove_gpiochip:
-	if (0 != gpiochip_remove(gc))
-		dev_err(&pdev->dev, "failed removing gpio_chip\n");
-err_free_gpiochip:
-	kfree(gc);
-err_iounmap:
-	iounmap(reg_base);
-exit:
-	if (info != NULL)
-		kfree(info);
-	return retval;
-}
-
-/**
- * intel_cln_gpio_remove
- * @param pdev: Pointer to GIP PCI device
- *
- * Perform GPIO-specific resource release on behalf of the top-level GIP
- * driver.
- */
-void intel_cln_gpio_remove(struct pci_dev *pdev)
-{
-	if (NULL == igc) {
-		dev_err(&pdev->dev, "null pointer to irq_generic_chip\n");
-		return;
-	}
-	if (NULL == gc) {
-		dev_err(&pdev->dev, "null pointer to gpio_chip\n");
-		return;
-	}
-
-	/* Tear down IRQ descriptors */
-	irq_remove_generic_chip(igc, IRQ_MSK(n_gpio), 0,
-		IRQ_NOREQUEST | IRQ_NOPROBE);
-	kfree(igc);
-	irq_free_descs(irq_base, n_gpio);
-
-	platform_device_unregister(&cln_gpio_restrict_pdev);
-
-	/* Release GPIO chip */
-	if (0 != gpiochip_remove(gc))
-		dev_err(&pdev->dev, "failed removing gpio_chip\n");
-
-
-	if (info != NULL){
-		uio_unregister_device(info);
-		iounmap(info->mem[0].internal_addr);
-		kfree(info);
-	}
-
-	kfree(gc);
-	iounmap(reg_base);
-}
diff --git a/drivers/mfd/intel_cln_gip_i2c.c b/drivers/mfd/intel_cln_gip_i2c.c
deleted file mode 100644
index 279ebb3..0000000
--- a/drivers/mfd/intel_cln_gip_i2c.c
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton GIP (GPIO/I2C) - I2C-specific PCI driver
- *
- *  PCI glue logic for Clanton GIP/I2C.
- *  The GIP I2C device is the DesignWare I2C. This file defines the PCI glue
- *  for this driver and is heavily based on
- *  on drivers/i2c/busses/i2c-designware-pcidrv.c.  Also, it relies on
- *  drivers/i2c/busses/i2c-designware-core.c for the core logic.
- *  Please note only a single instance of the I2C device is supported.
- */
-
-#include <linux/errno.h>
-#include <linux/i2c.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include "intel_cln_gip.h"
-
-enum dw_pci_ctl_id_t {
-	clanton_0,
-};
-
-/*
- * By default, driver operates in fast mode (400kHz).
- *
- * Standard mode operation (100kHz) can be forced via, in order of priority:
- * 1. setting the following i2c_std_mode module parameter to 1
- * 2. setting the platform data i2c_std_mode parameter to 1
- *
- * Note in both cases, setting i2c_std_mode to 0 means forcing fast mode
- * operation.
- */
-static unsigned int i2c_std_mode = -1;
-module_param(i2c_std_mode, uint, S_IRUSR);
-MODULE_PARM_DESC(i2c_std_mode, "Set to 1 to force I2C standard mode");
-
-#define INTEL_CLN_STD_CFG  (DW_IC_CON_MASTER |			\
-				DW_IC_CON_SLAVE_DISABLE |	\
-				DW_IC_CON_RESTART_EN)
-
-static struct dw_pci_controller cln_gip_i2c_controller = {
-	.bus_num	= 0,
-	.bus_cfg	= INTEL_CLN_STD_CFG | DW_IC_CON_SPEED_FAST,
-	.tx_fifo_depth	= 16,
-	.rx_fifo_depth	= 16,
-	.clk_khz	=
-#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
-			14000,
-#else
-			33000,
-#endif
-	.explicit_stop	= 1,
-};
-
-static struct i2c_algorithm i2c_dw_algo = {
-	.master_xfer	= i2c_dw_xfer,
-	.functionality	= i2c_dw_func,
-};
-
-/**
- * i2c_dw_get_clk_rate_khz
- * @param dev: Pointer to I2C device private data
- * @return clock rate in kHz
- *
- * Ancillary function returning the frequency of the clock supplied to the
- * interface.
- */
-static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
-{
-	return dev->controller->clk_khz;
-}
-
-/**
- * intel_cln_i2c_probe
- * @param pdev: Pointer to GIP PCI device
- * @param drvdata: private driver data
- * @return 0 success < 0 failure
- *
- * Perform I2C-specific probing on behalf of the top-level GIP driver.
- * Also call into I2C core driver routines for initiating the device.
- */
-int intel_cln_i2c_probe(struct pci_dev *pdev,
-			struct dw_i2c_dev **drvdata,
-			struct intel_cln_gip_pdata *pdata)
-{
-	int retval = 0;
-	resource_size_t start = 0, len = 0;
-	struct dw_i2c_dev *dev = NULL;
-	struct i2c_adapter *adap = NULL;
-	void __iomem *reg_base = NULL;
-	struct dw_pci_controller *controller = NULL;
-	int std_mode = -1;
-
-	controller = &cln_gip_i2c_controller;
-
-	/* Clanton default configuration is fast mode, unless otherwise forced */
-	if (-1 != i2c_std_mode) {
-		switch (i2c_std_mode) {
-		case 0:
-		case 1:
-			std_mode = i2c_std_mode;
-			break;
-		default:
-			dev_err(&pdev->dev, "invalid i2c_std_mode param val %d."
-				" Using driver default\n", i2c_std_mode);
-			break;
-		}
-	} else if (pdata) {
-		switch (pdata->i2c_std_mode) {
-		case 0:
-		case 1:
-			std_mode = pdata->i2c_std_mode;
-			break;
-		default:
-			dev_err(&pdev->dev, "invalid i2c_std_mode pdata val %d."
-				" Usign driver default\n", pdata->i2c_std_mode);
-			break;
-		}
-	}
-	if (-1 != std_mode) {
-		if (0 == std_mode) {
-			controller->bus_cfg |= DW_IC_CON_SPEED_FAST;
-			controller->bus_cfg &= ~DW_IC_CON_SPEED_STD;
-		} else {
-			controller->bus_cfg &= ~DW_IC_CON_SPEED_FAST;
-			controller->bus_cfg |= DW_IC_CON_SPEED_STD;
-		}
-		dev_info(&pdev->dev, "i2c speed set to %skHz\n",
-			 std_mode ? "100" : "400");
-	}
-
-	/* Determine the address of the I2C area */
-	start = pci_resource_start(pdev, GIP_I2C_BAR);
-	len = pci_resource_len(pdev, GIP_I2C_BAR);
-	if (!start || len == 0) {
-		dev_err(&pdev->dev, "bar%d not set\n", GIP_I2C_BAR);
-		retval = -ENODEV;
-		goto err;
-	}
-
-	reg_base = ioremap_nocache(start, len);
-	if (!reg_base) {
-		dev_err(&pdev->dev, "I/O memory remapping failed\n");
-		retval = -ENOMEM;
-		goto err;
-	}
-
-	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
-	if (!dev) {
-		retval = -ENOMEM;
-		goto err_iounmap;
-	}
-
-	init_completion(&dev->cmd_complete);
-	mutex_init(&dev->lock);
-	dev->clk = NULL;
-	dev->controller = controller;
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-	dev->base = reg_base;
-	dev->dev = get_device(&pdev->dev);
-	dev->functionality =
-		I2C_FUNC_I2C |
-		I2C_FUNC_10BIT_ADDR |
-		I2C_FUNC_SMBUS_BYTE |
-		I2C_FUNC_SMBUS_BYTE_DATA |
-		I2C_FUNC_SMBUS_WORD_DATA |
-		I2C_FUNC_SMBUS_I2C_BLOCK;
-	dev->master_cfg =  controller->bus_cfg;
-
-	*drvdata = dev;
-
-	dev->tx_fifo_depth = controller->tx_fifo_depth;
-	dev->rx_fifo_depth = controller->rx_fifo_depth;
-	dev->explicit_stop = controller->explicit_stop;
-	retval = i2c_dw_init(dev);
-	if (retval)
-		goto err_release_drvdata;
-
-	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
-	adap->owner = THIS_MODULE;
-	adap->class = 0;
-	adap->algo = &i2c_dw_algo;
-	adap->dev.parent = &pdev->dev;
-	adap->nr = controller->bus_num;
-	snprintf(adap->name, sizeof(adap->name), "intel_cln_gip_i2c");
-
-	i2c_dw_disable_int(dev);
-	i2c_dw_clear_int(dev);
-	retval = i2c_add_numbered_adapter(adap);
-	if (retval) {
-		dev_err(&pdev->dev, "failure adding I2C adapter\n");
-		goto err_release_drvdata;
-	}
-
-	return 0;
-
-err_release_drvdata:
-	put_device(&pdev->dev);
-	kfree(dev);
-err_iounmap:
-	iounmap(reg_base);
-err:
-	return retval;
-}
-
-/**
- * intel_cln_i2c_remove
- * @param pdev: Pointer to GIP PCI device
- * @param dev: Pointer to I2C private data 
- *
- * Perform I2C-specific resource release on behalf of the top-level GIP driver.
- */
-void intel_cln_i2c_remove(struct pci_dev *pdev,
-	struct dw_i2c_dev *dev)
-{
-
-	if (NULL == dev) {
-		dev_err(&pdev->dev, "%s: failure getting driver data\n",
-			__func__);
-		return;
-	}
-
-	i2c_dw_disable(dev);
-	i2c_del_adapter(&dev->adapter);
-	iounmap(dev->base);
-
-	kfree(dev);
-}
diff --git a/drivers/mfd/intel_cln_gip_pdata.c b/drivers/mfd/intel_cln_gip_pdata.c
deleted file mode 100644
index 853efdd..0000000
--- a/drivers/mfd/intel_cln_gip_pdata.c
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-
-#include <linux/module.h>
-#include <linux/mfd/intel_cln_gip_pdata.h>
-
-struct intel_cln_gip_pdata *(*intel_cln_gip_get_pdata)(void) = NULL;
-EXPORT_SYMBOL_GPL(intel_cln_gip_get_pdata);
diff --git a/drivers/mfd/intel_cln_gip_test.c b/drivers/mfd/intel_cln_gip_test.c
deleted file mode 100644
index 5ac17dd..0000000
--- a/drivers/mfd/intel_cln_gip_test.c
+++ /dev/null
@@ -1,1131 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton GIP (GPIO/I2C) Test module
- *
- * Clanton GIP + North-Cluster GPIO test module.
- */
-
-#include <linux/cdev.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/gpio.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-#include <linux/workqueue.h>
-#include <asm/tsc.h>
-
-#define DRIVER_NAME			"intel_cln_gip_test"
-
-/**************************** Exported to LISA *******************************/
-
-/*
- * Internally-used ioctl code. At the moment it is not reserved by any mainline
- * driver.
- */
-#define GIP_TEST_IOCTL_CODE			0xE0
-
-/*
- * Integers for ioctl operation.
- */
-#define IOCTL_CLN_GPIO_11			_IO(GIP_TEST_IOCTL_CODE, 0x00)
-#define IOCTL_CLN_GPIO_11_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x01)
-#define IOCTL_CLN_GPIO_12			_IO(GIP_TEST_IOCTL_CODE, 0x02)
-#define IOCTL_CLN_GPIO_12_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x03)
-#define IOCTL_CLN_GPIO_13			_IO(GIP_TEST_IOCTL_CODE, 0x04)
-#define IOCTL_CLN_GPIO_13_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x05)
-#define IOCTL_CLN_GPIO_14			_IO(GIP_TEST_IOCTL_CODE, 0x06)
-#define IOCTL_CLN_GPIO_14_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x07)
-#define IOCTL_CLN_GPIO_15			_IO(GIP_TEST_IOCTL_CODE, 0x08)
-#define IOCTL_CLN_GPIO_15_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x09)
-#define IOCTL_CLN_GPIO_16			_IO(GIP_TEST_IOCTL_CODE, 0x0A)
-#define IOCTL_CLN_GPIO_16_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0B)
-#define IOCTL_CLN_GPIO_17			_IO(GIP_TEST_IOCTL_CODE, 0x0C)
-#define IOCTL_CLN_GPIO_17_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0D)
-#define IOCTL_CLN_GPIO_19			_IO(GIP_TEST_IOCTL_CODE, 0x0E)
-#define IOCTL_CLN_GPIO_19_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0F)
-#define IOCTL_CLN_GPIO_20			_IO(GIP_TEST_IOCTL_CODE, 0x10)
-#define IOCTL_CLN_GPIO_20_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x11)
-#define IOCTL_CLN_GPIO_21			_IO(GIP_TEST_IOCTL_CODE, 0x12)
-#define IOCTL_CLN_GPIO_21_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x13)
-#define IOCTL_CLN_GPIO_24			_IO(GIP_TEST_IOCTL_CODE, 0x14)
-#define IOCTL_CLN_GPIO_26			_IO(GIP_TEST_IOCTL_CODE, 0x15)
-#define IOCTL_CLN_GPIO_26_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x16)
-/* Exercise callbacks for S0/S3 power-state transitions and vice-versa */
-#define IOCTL_CLN_GIP_SYSTEM_SUSPEND		_IO(GIP_TEST_IOCTL_CODE, 0x17)
-#define IOCTL_CLN_GIP_SYSTEM_RESUME		_IO(GIP_TEST_IOCTL_CODE, 0x18)
-#define IOCTL_CLN_GPIO_NMI_ENABLE		_IO(GIP_TEST_IOCTL_CODE, 0x19)
-#define IOCTL_CLN_GPIO_NMI_DISABLE		_IO(GIP_TEST_IOCTL_CODE, 0x1A)
-
-#define GPIO_INT_EDGE_POS_LABEL			"gpio-edge-pos"
-#define GPIO_INT_EDGE_NEG_LABEL			"gpio-edge-neg"
-#define GPIO_INT_LEVEL_HIGH_LABEL		"gpio-level-hi"
-#define GPIO_INT_LEVEL_LOW_LABEL		"gpio-level-lo"
-#define GPIO_INT_BASIC_LABEL			"gpio-edge-pos-basic"
-#define GPIO_PM_TEST_IRQ_LABEL			"gpio_pm_test_irq"
-
-/*
- * Board GPIO numbers.
- * Mapping between the North/South cluster GPIO and GPIOLIB IDs.
- */
-#define SUT_GPIO_NC_0				0x00
-#define SUT_GPIO_NC_1				0x01
-#define SUT_GPIO_NC_2				0x02
-#define SUT_GPIO_NC_7				0x07
-#define SUT_GPIO_SC_0				0x08
-#define SUT_GPIO_SC_1				0x09
-#define SUT_GPIO_SC_6				0x0E
-#define SUT_GPIO_SC_7				0x0F
-
-/*
- * Bitbanged SPI bus numbers.
- */
-#define GPIO_NC_BITBANG_SPI_BUS			0x0
-#define GPIO_SC_BITBANG_SPI_BUS			0x1
-
-/*****************************************************************************/
-
-/**
- * struct intel_cln_gip_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_gip_test_dev {
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-};
-
-static struct intel_cln_gip_test_dev gip_test_dev;
-static struct class *gip_test_class;
-static DEFINE_MUTEX(gip_test_mutex);
-static int gip_test_major;
-
-/*
- * Level-triggered interrupt variables
- */
-/* Level-triggered GPIO workqueue */
-static struct delayed_work work;
-/* Level-triggered interrupt counter */
-static unsigned int level_int_count;
-/* By default, a level-triggered interrupt is a low-level triggered */
-static int level_high_triggered = 0;
-
-/*
- * Interrupt performance metrics variables and parameters
- */
-/* How many captures */
-#define INT_PERF_TEST_CAPTURES			10000
-/* Timestamp for latency test interrupt handler */
-static cycles_t perf_t1;
-/* Captures to be returned to user space */
-static cycles_t deltas[INT_PERF_TEST_CAPTURES];
-/* Couldn't find the actual define for this */
-#define UINT64_MAX		0xFFFFFFFFFFFFFFFFULL
-
-static irqreturn_t gpio_pm_test_handler(int irq, void *dev_id)
-{
-	/* Do nothing, just acknowledge the IRQ subsystem */
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpio_latency_handler(int irq, void *dev_id)
-{
-	/* t0 */
-	perf_t1 = get_cycles();
-
-	gpio_set_value(SUT_GPIO_SC_0, 0);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpio_basic_handler(int irq, void *dev_id)
-{
-	/* Do nothing, just acknowledge the IRQ subsystem */
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpio_pos_edge_handler(int irq, void *dev_id)
-{
-	/* Do nothing, just acknowledge the IRQ subsystem */
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpio_neg_edge_handler(int irq, void *dev_id)
-{
-	/* Do nothing, just acknowledge the IRQ subsystem */
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t gpio_level_handler(int irq, void *dev_id)
-{
-	/* Untrigger the interrupt */
-	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 0 : 1);
-
-	level_int_count ++;
-	if (level_int_count < 1000) {
-		/* Next task due in a jiffy */
-		schedule_delayed_work(&work, 1);
-	} else if (level_int_count == 1000){
-		/* OK */
-	} else {
-		/*
-		 * We may get spurious interrupts. This because the TE requires
-		 * some time to drive the actual value to the GPIO.
-		 */
-		pr_info("Spurious interrupt\n");
-	}
-
-	return IRQ_HANDLED;
-}
-
-static void gpio_level_drive(struct work_struct *work)
-{
-	/* TE to trigger the interrupt */
-	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 1 : 0);
-}
-
-/**
- * gpio_sc_level_int
- *
- * Request level triggered IRQ for SUT_GPIO_SC_6 and register
- * SUT_GPIO_SC_7 as output GPIO.
- * If positive equals to 0, the IRQ is high-level triggered.
- * Otherwise, low-level triggered.
- * Mask the IRQ if requested.
- */
-static int gpio_sc_level_int(int positive, int masking)
-{
-	int ret = 0;
-	int irq = -1;
-
-	unsigned long out_init_val =
-		(positive ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);
-
-	level_high_triggered = positive;
-
-	/* Initialise workqueue task */
-	INIT_DELAYED_WORK(&work, gpio_level_drive);
-
-	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
-		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
-		ret = -1;
-		goto fail;
-	}
-	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
-		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
-		ret = -1;
-		goto fail;
-	}
-
-	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_hi_level");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
-		goto fail;
-	}
-	ret = gpio_request_one(SUT_GPIO_SC_7, out_init_val, "gpio_output");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
-		goto fail_release_first_gpio;
-	}
-
-	irq = gpio_to_irq(SUT_GPIO_SC_6);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
-		goto fail_release_second_gpio;
-	}
-
-	if (0 != (ret = request_irq(irq, gpio_level_handler,
-			positive ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW,
-			positive ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_LEVEL_LOW_LABEL,
-			NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
-		goto fail_release_second_gpio;
-	}
-
-	level_int_count = 0;
-
-	pr_info("Registered output gpio%d and IRQ for gpio%d\n", SUT_GPIO_SC_7,
-		SUT_GPIO_SC_6);
-
-	if (masking) {
-		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
-		pr_info("Masked gpio%d IRQ\n", SUT_GPIO_SC_6);
-	}
-
-	/*
-	 * Submit task to workqueue to drive the external Test Equipment.
-	 * Note the task is delayed long enough to have Aarvark already set up.
-	 * This because Aardvark has to ignore the initial glitches during the
-	 * previous GPIO setup phase. 
-	 */
-	schedule_delayed_work(&work, 20 * HZ);
-
-	return 0;
-
-fail_release_second_gpio:
-	gpio_free(SUT_GPIO_SC_7);
-fail_release_first_gpio:
-	gpio_free(SUT_GPIO_SC_6);
-fail:
-	pr_err("%s() failed\n", __func__);
-
-	return ret;
-}
-
-/**
- * gpio_sc_level_int_teardown
- *
- * Release resources reserved by gpio_sc_level_int().
- */
-static int gpio_sc_level_int_teardown(void)
-{
-	int irq = -1;
-
-	if (0 != cancel_delayed_work_sync(&work))
-		pr_warn("delayed work was still pending\n");
-
-	irq = gpio_to_irq(SUT_GPIO_SC_6);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
-	} else {
-		free_irq(irq, NULL);
-	}
-
-	/* Make sure no handler is still running by this time */
-	mdelay(20);
-
-	gpio_free(SUT_GPIO_SC_7);
-	gpio_free(SUT_GPIO_SC_6);
-
-	return 0;
-}
-
-/*
- * gpio_sc_interrupt_perf
- *
- * Performs a basic GPIO interrupt latency test by timestamping delta between
- * interrupt driven and handled over a GPIO loopback.
- *
- * Returns to userspace the array of deltas obtained during each capture.
- * A total amount of INT_PERF_TEST_CAPTURES captures is performed.
- *
- */
-static int gpio_sc_interrupt_perf(unsigned long user_memloc)
-{
-	int ret = 0;
-	int irq = -1;
-	int gpio_input = SUT_GPIO_SC_1;
-	int gpio_output = SUT_GPIO_SC_0;
-	unsigned int i = 0;
-	cycles_t perf_t0 = 0;
-	cycles_t delta = 0;
-
-	/* Casting pointer to user-space location to write */
-	cycles_t __user *user_ptr = (cycles_t __user *)user_memloc;
-
-	/* Can we copy the captures array into user-space location? */
-	if (!access_ok(VERIFY_WRITE, user_ptr, sizeof(deltas))) {
-		pr_err("can't copy 0x%x bytes to user-space address 0x%p\n",
-			sizeof(deltas),user_ptr);
-		return -EFAULT;
-	}
-
-	/* Setup the GPIO */
-	if (!gpio_is_valid(gpio_input)) {
-		pr_err("gpio%d is invalid\n", gpio_input);
-		ret = -1;
-		goto fail;
-	}
-	if (!gpio_is_valid(gpio_output)) {
-		pr_err("gpio%d is invalid\n", gpio_output);
-		ret = -1;
-		goto fail;
-	}
-	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_intperf_in");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
-		goto fail;
-	}
-	ret = gpio_request_one(gpio_output, GPIOF_OUT_INIT_LOW, "gpio_intperf_out");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", gpio_output, ret);
-		goto fail_release_input_gpio;
-	}
-
-	/* Setup IRQ handler for input GPIO */
-	irq = gpio_to_irq(gpio_input);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio_input);
-		goto fail_release_output_gpio;
-	}
-	if (0 != (ret = request_irq(irq, gpio_latency_handler,
-			IRQF_TRIGGER_RISING, "gpio_latency_handler", NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", gpio_input);
-		goto fail_release_output_gpio;
-	}
-
-	/* Perform test */
-	for (i = 0; i < INT_PERF_TEST_CAPTURES; i ++) {
-		/* t0 */
-		perf_t0 = get_cycles();
-
-		/* Trigger interrupt */
-		gpio_set_value(gpio_output, 1);
-		mdelay(2);
-
-		/* Check for wrap-around and store delta */
-		if(perf_t0 < perf_t1) {
-			delta = perf_t1 - perf_t0;
-		} else {
-			delta = perf_t1 + (UINT64_MAX - perf_t0);
-		}
-		deltas[i] = delta;
-	}
-
-	/* Expose results to userspace */
-	ret = copy_to_user(user_ptr, &deltas, sizeof(deltas));
-
-	/* Release resources */
-
-	free_irq(irq, NULL);
-
-fail_release_output_gpio:
-	gpio_free(gpio_output);
-fail_release_input_gpio:
-	gpio_free(gpio_input);
-fail:
-	if (0 != ret) {
-		pr_err("%s() failed\n", __func__);
-	}
-
-	return ret;
-}
-
-/**
- * gpio_sc_pm_test_int
- *
- * Request rising edge-triggered IRQ for SUT_GPIO_SC_0
- */
-static int gpio_sc_pm_test_int(void)
-{
-	int ret = 0;
-	int irq = -1;
-	int gpio_input = SUT_GPIO_SC_0;
-
-	/* Setup the GPIO */
-	if (!gpio_is_valid(gpio_input)) {
-		pr_err("gpio%d is invalid\n", gpio_input);
-		ret = -1;
-		goto fail;
-	}
-	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_pm_test_in");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
-		goto fail;
-	}
-
-	/* Setup IRQ handler for input GPIO */
-	irq = gpio_to_irq(gpio_input);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio_input);
-		goto fail_release_input_gpio;
-	}
-	if (0 != (ret = request_irq(irq, gpio_pm_test_handler,
-			IRQF_TRIGGER_RISING, GPIO_PM_TEST_IRQ_LABEL, NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", gpio_input);
-		goto fail_release_input_gpio;
-	}
-
-	return 0;
-
-fail_release_input_gpio:
-	gpio_free(gpio_input);
-fail:
-	return ret;
-}
-
-/**
- * gpio_sc_pm_test_int
- *
- * Release resources reserved by gpio_sc_edge_int()
- */
-static int gpio_sc_pm_test_int_teardown(void)
-{
-	int irq = -1;
-
-	irq = gpio_to_irq(SUT_GPIO_SC_0);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_0);
-	} else {
-		free_irq(irq, NULL);
-	}
-
-	gpio_free(SUT_GPIO_SC_0);
-
-	return 0;
-}
-
-/**
- * gpio_sc_edge_int
- *
- * Request IRQ for SUT_GPIO_SC_6 and SUT_GPIO_SC_7, respectively positive-edge
- * and negative edge-triggered.
- * Mask the IRQs if requested.
- */
-static int gpio_sc_edge_int(int masking)
-{
-	int ret = 0;
-	int irq_pos = -1, irq_neg = -1;
-
-	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
-		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
-		ret = -1;
-		goto fail;
-	}
-	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
-		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
-		ret = -1;
-		goto fail;
-	}
-
-	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_pos_edge");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
-		goto fail;
-	}
-	ret = gpio_request_one(SUT_GPIO_SC_7, GPIOF_IN, "gpio_neg_edge");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
-		goto fail_release_first_gpio;
-	}
-
-	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
-	if (irq_pos < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
-		goto fail_release_second_gpio;
-	}
-	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
-	if (irq_neg < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
-		goto fail_release_second_gpio;
-	}
-
-	if (0 != (ret = request_irq(irq_pos, gpio_pos_edge_handler,
-			IRQF_TRIGGER_RISING, GPIO_INT_EDGE_POS_LABEL, NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
-		goto fail_release_second_gpio;
-	}
-	if (0 != (ret = request_irq(irq_neg, gpio_neg_edge_handler,
-			IRQF_TRIGGER_FALLING, GPIO_INT_EDGE_NEG_LABEL, NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_7);
-		goto fail_release_first_gpio_irq;
-	}
-
-	pr_info("Registered gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
-		SUT_GPIO_SC_7);
-
-	if (masking) {
-		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
-		disable_irq(gpio_to_irq(SUT_GPIO_SC_7));
-		pr_info("Masked gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
-			SUT_GPIO_SC_7);
-	}
-
-	return 0;
-
-fail_release_first_gpio_irq:
-	free_irq(irq_pos, NULL);
-fail_release_second_gpio:
-	gpio_free(SUT_GPIO_SC_7);
-fail_release_first_gpio:
-	gpio_free(SUT_GPIO_SC_6);
-fail:
-	pr_err("%s() failed\n", __func__);
-
-	return ret;
-}
-
-/**
- * gpio_sc_edge_int_teardown
- *
- * Release resources reserved by gpio_sc_edge_int()
- */
-static int gpio_sc_edge_int_teardown(void)
-{
-	int irq_pos = -1, irq_neg = -1;
-
-	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
-	if (irq_neg < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
-	} else {
-		free_irq(irq_neg, NULL);
-	}
-	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
-	if (irq_pos < 0) {
-		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
-	} else {
-		free_irq(irq_pos, NULL);
-	}
-
-	gpio_free(SUT_GPIO_SC_7);
-	gpio_free(SUT_GPIO_SC_6);
-
-	return 0;
-}
-
-/**
- * gpio_sc_basic_int
- *
- * Register rising-edge interrupt handler on SUT_GPIO_SC_1
- */
-static int gpio_sc_basic_int(void)
-{
-	int ret = 0;
-	int irq = -1;
-	unsigned int gpio = SUT_GPIO_SC_1;
-
-	if (!gpio_is_valid(gpio)) {
-		pr_err("gpio%d is invalid\n", gpio);
-		ret = -1;
-		goto fail;
-	}
-
-	ret = gpio_request_one(gpio, GPIOF_IN, "gpio_pos_edge_basic");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
-		goto fail;
-	}
-
-	irq = gpio_to_irq(gpio);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio);
-		goto fail_release_gpio;
-	}
-
-	if (0 != (ret = request_irq(irq, gpio_basic_handler,
-			IRQF_TRIGGER_RISING, GPIO_INT_BASIC_LABEL, NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", gpio);
-		goto fail_release_gpio;
-	}
-
-	pr_info("Registered gpio%d IRQ\n", gpio);
-
-	return 0;
-
-fail_release_gpio:
-	gpio_free(gpio);
-fail:
-	pr_err("%s() failed\n", __func__);
-
-	return ret;
-}
-
-/**
- * gpio_sc_basic_int_teardown
- *
- * Release resources reserved by gpio_sc_basic_int()
- */
-static int gpio_sc_basic_int_teardown(void)
-{
-	int irq = -1;
-	unsigned int gpio = SUT_GPIO_SC_1;
-
-	irq = gpio_to_irq(gpio);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio);
-	} else {
-		free_irq(irq, NULL);
-	}
-
-	gpio_free(gpio);
-
-	return 0;
-}
-
-/**
- * gpio_spidev_register
- *
- * Register a bitbanged SPI platform device and export a `spidev' to userspace.
- * For North Cluster and South Cluster.
- */
-static int gpio_spidev_register(int north_cluster)
-{
-	/* Not needed anymore */
-	return 0;
-}
-
-/**
- * gpio_spidev_unregister
- *
- * Release a bitbanged SPI platform device and its `spidev' interface.
- * For North Cluster and South Cluster.
- */
-static int gpio_spidev_unregister(int north_cluster)
-{
-	/* Not needed anymore */
-	return 0;
-}
-
-/**
- * gip_system_power_transition 
- *
- * @param state: 0 if transition to S3, !0 if transition to S0
- * @return 0 success < 0 failure
- *
- * Exercise system-wide suspend/resume power management transitions.
- * 
- */
-static int gip_system_power_transition(int state)
-{
-	struct pci_dev *gip = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, NULL);
-	if (NULL == gip) {
-		pr_err("can't find GIP PCI device\n");
-		return -ENOENT;
-	}
-
-	if (0 == state) {
-		gip->driver->driver.pm->suspend(&gip->dev);
-	} else {
-		gip->driver->driver.pm->resume(&gip->dev);
-	}
-
-	/* Decrement reference count of PCI device */
-	if (NULL != pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, gip)) {
-		pr_warn("found duplicate of GIP PCI device?!\n");
-	}
-
-	return 0;
-}
-
-/**
- * gpio_nmi_enable 
- *
- * @param enable: 0 to disable, !0 to enable
- * @return 0 success < 0 failure
- *
- * Hack the legacy GPIO hardware to enable rising-edge triggered NMI on Core
- * Well gpio0.
- * 
- */
-static int gpio_nmi_enable(int enable)
-{
-	unsigned int base_u32 = 0x0;
-	unsigned short base = 0x0;
-	struct pci_dev *ilb = pci_get_device(PCI_VENDOR_ID_INTEL,
-					     PCI_DEVICE_ID_INTEL_CLANTON_ILB,
-					     NULL);
-	/* Assume interrupts are disabled by default by BIOS */
-	unsigned char gpio = enable ? 0x01 : 0x00; 
-
-	if (NULL == ilb) {
-		pr_err("can't find iLB device\n");
-		return -ENOENT;
-	}
-
-	/* The GPIO base address is @ offset 0x44.  Sussed out from driver */
-	pci_read_config_dword(ilb, 0x44, &base_u32);
-	if (0x0 == base_u32) {
-		pr_err("can't read iLB GPIO baseaddr\n");
-		return -ENOENT;
-	}
-	base = (unsigned short)base_u32;
-
-	/*
-	 * Prepare for rising edge NMI triggering.  This assumes the pin
-	 * is already set as input.
-	 */
-#define CGTPE		0x0C	/* Core Well trigger positive edge */
-#define CGTS		0x1C	/* Core Well trigges status - W1C */
-#define CGNMIEN		0x40	/* Core Well NMI enable */
-	outb(0x01, base + CGTS);
-	outb(gpio, base + CGTPE);
-	outb(gpio, base + CGNMIEN);
-#undef CGTPE
-#undef CGTS
-#undef CGNMIEN
-
-	return 0;
-}
-
-/**
- * gpio_sc_debounce
- *
- * Enable GPIO debounce functionality for SC_GPIO_1 (edge and level triggered)
- *
- */
-static int gpio_sc_debounce(int level)
-{
-	int ret = 0;
-	int irq = -1;
-	int gpio = SUT_GPIO_SC_0;
-
-	if (!gpio_is_valid(gpio)) {
-		pr_err("gpio%d is invalid\n", gpio);
-		ret = -1;
-		goto fail;
-	}
-
-	ret = gpio_request_one(gpio, GPIOF_IN,
-		level ? "gpio_level_mask" : "gpio_edge_mask");
-	if (ret) {
-		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
-		goto fail;
-	}
-
-	irq = gpio_to_irq(gpio);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio);
-		goto fail_release_gpio;
-	}
-
-	/*
-	 * Register IRQ. gpio_pos_edge_handler will do for both level and edge
-	 * interrupts, as it's nooping.
-	 */
-	if (0 != (ret = request_irq(irq, gpio_pos_edge_handler,
-			level ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_RISING,
-			level ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_EDGE_POS_LABEL,
-			NULL))) {
-		pr_err("can't request IRQ for gpio%d\n", gpio);
-		goto fail_release_gpio;
-	}
-
-	/* Set debounce */
-	if (0 != (ret = gpio_set_debounce(gpio, 1))) {
-		pr_err("can't set debounce for gpio%d\n", gpio);
-		goto fail_free_irq;
-	}
-
-	return 0;
-
-fail_free_irq:
-	free_irq(irq, NULL);
-fail_release_gpio:
-	gpio_free(gpio);
-fail:
-	pr_err("%s() failed\n", __func__);
-
-	return ret;
-}
-
-/**
- * gpio_sc_debounce_teardown
- *
- * Undo gpio_sc_debounce
- *
- */
-static int gpio_sc_debounce_teardown(int level)
-{
-	int irq = -1;
-	unsigned int gpio = SUT_GPIO_SC_0;
-
-	irq = gpio_to_irq(gpio);
-	if (irq < 0) {
-		pr_err("can't map gpio%d to IRQ\n", gpio);
-	} else {
-		free_irq(irq, NULL);
-	}
-
-	gpio_free(gpio);
-
-	return 0;
-}
-
-/*
- * File ops
- */
-static long gip_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	switch (cmd) {
-		case IOCTL_CLN_GPIO_11:
-			/* Edge-triggered interrupts */
-			ret = gpio_sc_edge_int(0);
-			break;
-		case IOCTL_CLN_GPIO_11_CLEANUP:
-			/* Edge-triggered interrupts cleanup */
-			ret = gpio_sc_edge_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_12:
-			/* Edge-triggered interrupts (masking) */
-			ret = gpio_sc_edge_int(1);
-			break;
-		case IOCTL_CLN_GPIO_12_CLEANUP:
-			/* Edge-triggered interrupts (masking) cleanup */
-			ret = gpio_sc_edge_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_13:
-			/* GPIO debounce (edge) */
-			ret = gpio_sc_debounce(0);
-			break;
-		case IOCTL_CLN_GPIO_13_CLEANUP:
-			/* GPIO debounce cleanup (edge) */
-			ret = gpio_sc_debounce_teardown(0);
-			break;
-		case IOCTL_CLN_GPIO_14:
-			/* High-level triggered interrupts */
-			ret = gpio_sc_level_int(1, 0);
-			break;
-		case IOCTL_CLN_GPIO_14_CLEANUP:
-			/* High-level triggered interrupts cleanup */
-			ret = gpio_sc_level_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_15:
-			/* Low-level triggered interrupts */
-			ret = gpio_sc_level_int(0, 0);
-			break;
-		case IOCTL_CLN_GPIO_15_CLEANUP:
-			/*Low-level triggered interrupts cleanup */
-			ret = gpio_sc_level_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_16:
-			/* Level triggered interrupts (masking) */
-			ret = gpio_sc_level_int(1, 1);
-			break;
-		case IOCTL_CLN_GPIO_16_CLEANUP:
-			/* Level triggered interrupts (masking) cleanup */
-			ret = gpio_sc_level_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_17:
-			/* GPIO debounce (level) */
-			ret = gpio_sc_debounce(1);
-			break;
-		case IOCTL_CLN_GPIO_17_CLEANUP:
-			/* GPIO debounce cleanup (level) */
-			ret = gpio_sc_debounce_teardown(1);
-			break;
-		case IOCTL_CLN_GPIO_19:
-			/* Register IRQ for SC_GPIO0 (PM transitions test) */
-			ret = gpio_sc_pm_test_int();
-			break;
-		case IOCTL_CLN_GPIO_19_CLEANUP:
-			/* Free IRQ for SC_GPIO0 (PM transitions test) */
-			ret = gpio_sc_pm_test_int_teardown();
-			break;
-		case IOCTL_CLN_GPIO_20:
-			/* NC bitbanged SPI */
-			ret = gpio_spidev_register(1);
-			break;
-		case IOCTL_CLN_GPIO_20_CLEANUP:
-			/* NC bitbanged SPI cleanup */
-			ret = gpio_spidev_unregister(1);
-			break;
-		case IOCTL_CLN_GPIO_21:
-			/* SC bitbanged SPI */
-			ret = gpio_spidev_register(0);
-			break;
-		case IOCTL_CLN_GPIO_21_CLEANUP:
-			/* SC bitbanged SPI cleanup */
-			ret = gpio_spidev_unregister(0);
-			break;
-		case IOCTL_CLN_GPIO_24:
-			/*
-			 * SC GPIO interrupt performance test.
-			 * Note it's shared between CLN_GPIO_24 and CLN_GPIO_25
-			 * plus it doesn't need any cleanup call.
-			 */
-			ret = gpio_sc_interrupt_perf(arg);
-			break;
-		case IOCTL_CLN_GPIO_26:
-			/* Interrupt for basic loopback test */
-			ret = gpio_sc_basic_int();
-			break;
-		case IOCTL_CLN_GPIO_26_CLEANUP:
-			/* Interrupt for basic loopback test cleanup */
-			ret = gpio_sc_basic_int_teardown();
-			break;
-		case IOCTL_CLN_GIP_SYSTEM_SUSPEND:
-			ret = gip_system_power_transition(0);
-			break;
-		case IOCTL_CLN_GIP_SYSTEM_RESUME:
-			ret = gip_system_power_transition(1);
-			break;
-		case IOCTL_CLN_GPIO_NMI_ENABLE:
-			ret = gpio_nmi_enable(1);
-			break;
-		case IOCTL_CLN_GPIO_NMI_DISABLE:
-			ret = gpio_nmi_enable(0);
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int gip_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&gip_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&gip_test_dev.open_lock)) {
-		mutex_unlock(&gip_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (gip_test_dev.opened) {
-		mutex_unlock(&gip_test_dev.open_lock);
-		mutex_unlock(&gip_test_mutex);
-		return -EINVAL;
-	}
-
-	gip_test_dev.opened++;
-	mutex_unlock(&gip_test_dev.open_lock);
-	mutex_unlock(&gip_test_mutex);
-	return 0;
-}
-
-static int gip_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&gip_test_dev.open_lock);
-	gip_test_dev.opened = 0;
-	mutex_unlock(&gip_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations gip_test_file_ops = {
-	.open = gip_test_open,
-	.release = gip_test_release,
-	.unlocked_ioctl = gip_test_ioctl,
-	.llseek = no_llseek,
-};
-
-/**
- * intel_cln_gip_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- */
-static int intel_cln_gip_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&gip_test_dev.open_lock);
-	cdev_init(&gip_test_dev.cdev, &gip_test_file_ops);
-	gip_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&gip_test_dev.cdev, MKDEV(gip_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(gip_test_class, NULL,
-				 MKDEV(gip_test_major, minor), NULL,
-				 "giptest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-
-	return 0;
-
-}
-
-static int intel_cln_gip_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(gip_test_dev.cdev.dev);
-
-	device_destroy(gip_test_class, MKDEV(gip_test_major, minor));
-	cdev_del(&gip_test_dev.cdev);
-
-	class_destroy(gip_test_class);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_gip_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_gip_test_remove,
-};
-
-/**
- * intel_cln_gip_test_init
- *
- * Load module.
- */
-static int __init intel_cln_gip_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	gip_test_class = class_create(THIS_MODULE,"cln_gip_test");
-	if (IS_ERR(gip_test_class)) {
-		retval = PTR_ERR(gip_test_class);
-		printk(KERN_ERR "gip_test: can't register gip_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "gip_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	gip_test_major = MAJOR(dev);
-
-	memset(&gip_test_dev, 0x00, sizeof(gip_test_dev));
-	gip_test_dev.pldev = platform_create_bundle(
-		&intel_cln_gip_test_driver, intel_cln_gip_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(gip_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(gip_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(gip_test_class);
-err:
-	return retval;
-}
-
-static void __exit intel_cln_gip_test_exit(void)
-{
-	platform_device_unregister(gip_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_gip_test_driver);
-}
-
-module_init(intel_cln_gip_test_init);
-module_exit(intel_cln_gip_test_exit);
-
-MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
-MODULE_DESCRIPTION("Clanton GIP test module");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/drivers/mfd/intel_qrk_gip.h b/drivers/mfd/intel_qrk_gip.h
new file mode 100644
index 0000000..d1e8316
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) driver
+ */
+
+#ifndef __INTEL_QRKGIP_H__
+#define __INTEL_QRKGIP_H__
+
+#include <linux/i2c.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/pci.h>
+#include "../i2c/busses/i2c-designware-core.h"
+
+/* PCI BAR for register base address */
+#define GIP_I2C_BAR		0
+#define GIP_GPIO_BAR		1
+
+/**
+ * intel_qrk_gpio_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_qrk_gpio_probe(struct pci_dev *pdev);
+
+/**
+ * intel_qrk_gpio_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_gpio_remove(struct pci_dev *pdev);
+
+/**
+ * intel_qrk_gpio_isr
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: used to distinguish the device (for shared interrupts)
+ *
+ * Perform GPIO-specific ISR of the top-level GIP driver.
+ */
+irqreturn_t intel_qrk_gpio_isr(int irq, void *dev_id);
+
+/**
+ * intel_qrk_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_qrk_gpio_save_state(void);
+
+/**
+ * intel_qrk_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_qrk_gpio_restore_state(void);
+
+/**
+ * intel_qrk_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @param drvdata: GIP platform-specific settings
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_qrk_i2c_probe(struct pci_dev *pdev, 
+			struct dw_i2c_dev **drvdata,
+			struct intel_qrk_gip_pdata *pdata);
+
+/**
+ * intel_qrk_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data 
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev);
+
+#endif /* __INTEL_QRKGIP_H__ */
diff --git a/drivers/mfd/intel_qrk_gip_core.c b/drivers/mfd/intel_qrk_gip_core.c
new file mode 100644
index 0000000..8b8727b
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_core.c
@@ -0,0 +1,335 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) PCI driver
+ *
+ *  PCI glue logic for Quark GIP driver.
+ *  Quark GIP is a single PCI function exporting a GPIO and an I2C device.
+ *  The PCI driver performs the bus-dependent probe/release operations, and
+ *  call into GPIO/I2C specific modules for handling the two diffrerent
+ *  functionalities.
+ */
+
+#include <asm/qrk.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_qrk_gip.h"
+
+static unsigned int enable_msi = 1;
+module_param(enable_msi, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+static unsigned int i2c = 1;
+module_param(i2c, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(i2c, "Register I2C adapter");
+
+static unsigned int gpio = 1;
+module_param(gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio, "Register GPIO chip");
+
+/* GIP private data, supporting only a single instance of the device. */
+struct intel_qrk_gip_data {
+	struct pci_dev *pci_device;
+	struct dw_i2c_dev *i2c_drvdata;
+	struct intel_qrk_gip_pdata *pdata;
+};
+
+/**
+ * intel_qrk_gip_handler
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: device private data
+ *
+ * Top-level interrupt handler for GIP driver.
+ * It calls into the appropriate sub-routines and gathers the return values.
+ */
+static irqreturn_t intel_qrk_gip_handler(int irq, void *dev_id)
+{
+	irqreturn_t ret_i2c = IRQ_NONE;
+	irqreturn_t ret_gpio = IRQ_NONE;
+	struct intel_qrk_gip_data *data = (struct intel_qrk_gip_data *)dev_id;
+
+	mask_pvm(data->pci_device);
+
+	if (likely(i2c)) {
+		/* Only I2C gets platform data */
+		ret_i2c = i2c_dw_isr(irq, data->i2c_drvdata);
+	}
+
+	if (likely(gpio)) {
+		ret_gpio = intel_qrk_gpio_isr(irq, NULL);
+	}
+
+	unmask_pvm(data->pci_device);
+
+	if (likely(IRQ_HANDLED == ret_i2c || IRQ_HANDLED == ret_gpio))
+		return IRQ_HANDLED;
+
+	/* Each sub-ISR routine returns either IRQ_HANDLED or IRQ_NONE. */
+	return IRQ_NONE;
+}
+
+static DEFINE_PCI_DEVICE_TABLE(intel_qrk_gip_ids) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0934), },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_qrk_gip_ids);
+
+#ifdef CONFIG_PM
+
+/**
+ * qrk_gip_suspend
+ * 
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to sleep state.
+ * Save context, disable GPIO chip and I2C adapter, transition PCI device into
+ * low-power state.
+ */
+static int qrk_gip_suspend(struct device *dev)
+{
+	int err = 0;
+	struct intel_qrk_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	i2c_dw_disable(data->i2c_drvdata);
+	intel_qrk_gpio_save_state();
+
+	err = pci_save_state(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "pci_save_state failed\n");
+		return err;
+	}
+
+	err = pci_set_power_state(pdev, PCI_D3hot);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * qrk_gip_resume
+ * 
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to fully active state.
+ * Set PCI device into full-power state, restore context, enable I2C adapter
+ * and GPIO chip.
+ */
+static int qrk_gip_resume(struct device *dev)
+{
+	int err = 0;
+	struct intel_qrk_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	err = pci_set_power_state(pdev, PCI_D0);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
+		return err;
+	}
+
+	pci_restore_state(pdev);
+
+	intel_qrk_gpio_restore_state();
+	i2c_dw_init(data->i2c_drvdata);
+
+	return 0;
+}
+
+#else
+#define qrk_gip_suspend		NULL
+#define qrk_gip_resume		NULL
+#endif
+
+static const struct dev_pm_ops qrk_gip_pm_ops = {
+	.resume         = qrk_gip_resume,
+	.suspend        = qrk_gip_suspend,
+};
+
+/**
+ * intel_qrk_gip_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @param id: GIP PCI Device ID
+ * @return 0 success < 0 failure
+ *
+ * GIP PCI driver probing. Calls into the appropriate probe routines for GPIO
+ * and I2C too.
+ */
+static int intel_qrk_gip_probe(struct pci_dev *pdev,
+				const struct pci_device_id *id)
+{
+	int retval = 0;
+	struct intel_qrk_gip_data *gip_drvdata = NULL;
+
+	retval = pci_enable_device(pdev);
+	if (retval)
+		return retval;
+
+	retval = pci_request_regions(pdev, "qrk-gip");
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting PCI region\n");
+		goto err_pcidev_disable;
+	}
+
+	gip_drvdata = kzalloc(sizeof(struct intel_qrk_gip_data), GFP_KERNEL);
+	if (NULL == gip_drvdata) {
+		retval = -ENOMEM;
+		goto err_pciregions_release;
+	}
+	pci_set_drvdata(pdev, gip_drvdata);
+
+	gip_drvdata->pci_device = pdev; 
+
+	/* Retrieve platform data if there is any */
+	if (*intel_qrk_gip_get_pdata) {
+		gip_drvdata->pdata = intel_qrk_gip_get_pdata();
+	}
+
+	if (gpio) {
+		retval = intel_qrk_gpio_probe(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (i2c) {
+		retval = intel_qrk_i2c_probe(pdev,
+			(struct dw_i2c_dev **)&gip_drvdata->i2c_drvdata,
+			gip_drvdata->pdata);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (enable_msi) {
+		pci_set_master(pdev);
+		retval = pci_enable_msi(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	/*
+	 * Request a shared IRQ.
+	 * Since the dev_id cannot be NULL, it points to PCI device descriptor
+	 * if I2C is not registered.
+	 */
+	retval = request_irq(pdev->irq, intel_qrk_gip_handler, IRQF_SHARED,
+			"intel_qrk_gip", gip_drvdata);
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting IRQ\n");
+		goto err;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	pci_set_drvdata(pdev, NULL);
+	kfree(gip_drvdata);
+err:
+	if (enable_msi)
+		pci_disable_msi(pdev);
+err_pciregions_release:
+	pci_release_regions(pdev);
+err_pcidev_disable:
+	pci_disable_device(pdev);
+
+	return retval;
+}
+
+/**
+ * intel_qrk_gip_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Release resources. Calls into GPIO/I2C dedicate routines too.
+ */
+static void intel_qrk_gip_remove(struct pci_dev *pdev)
+{
+	struct intel_qrk_gip_data *data = NULL;
+
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	if (NULL == data) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	free_irq(pdev->irq, data);
+
+	if (enable_msi) {
+		pci_clear_master(pdev);
+		if (pci_dev_msi_enabled(pdev))
+			pci_disable_msi(pdev);
+	}
+
+	if (i2c)
+		intel_qrk_i2c_remove(pdev, data->i2c_drvdata);
+
+	if (gpio)
+		intel_qrk_gpio_remove(pdev);
+
+	pci_set_drvdata(pdev, NULL);
+	kfree(data);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver intel_qrk_gip_driver = {
+	.name =		"intel_qrk_gip",
+	.id_table	= intel_qrk_gip_ids,
+	.probe		= intel_qrk_gip_probe,
+	.remove		= intel_qrk_gip_remove,
+	.driver         = {
+		.pm     = &qrk_gip_pm_ops,
+	},
+};
+
+static int intel_qrk_gip_init(void)
+{
+	return pci_register_driver(&intel_qrk_gip_driver);
+}
+
+static void intel_qrk_gip_exit(void)
+{
+	pci_unregister_driver(&intel_qrk_gip_driver);
+}
+
+module_init(intel_qrk_gip_init);
+module_exit(intel_qrk_gip_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Quark GIP driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/mfd/intel_qrk_gip_gpio.c b/drivers/mfd/intel_qrk_gip_gpio.c
new file mode 100644
index 0000000..ef19e2f
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_gpio.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) - GPIO-specific PCI and core driver
+ *
+ *  PCI glue logic and core driver for Quark GIP/GPIO.
+ *  The GIP GPIO device is the DesignWare GPIO. This file defines the PCI glue
+ *  for this driver and as well as the core logic for the device.
+ *  Please note only a single instance of the GPIO device is supported.
+ *  The default number of GPIO is 8, all interrupt-capable.
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include "intel_qrk_gip.h"
+
+static void qrk_gpio_restrict_release(struct device *dev) {}
+static struct platform_device qrk_gpio_restrict_pdev = 
+{
+	.name	= "qrk-gpio-restrict-sc",
+	.dev.release = qrk_gpio_restrict_release,
+};
+struct uio_info *info;
+
+/* The base GPIO number under GPIOLIB framework */
+#define INTEL_QRK_GIP_GPIO_BASE		8
+
+/* The default number of South-Cluster GPIO on Quark. */
+#define INTEL_QRK_GIP_NGPIO		8
+
+/*
+ * The default base IRQ for searching and allocating the range of GPIO IRQ
+ * descriptors.
+ */
+#define INTEL_QRK_GIP_GPIO_IRQBASE	56
+
+/* The GPIO private data. */
+static struct gpio_chip *gc;
+static struct irq_chip_generic *igc;
+static void __iomem *reg_base;
+static spinlock_t lock;
+static int irq_base;
+static unsigned int n_gpio = INTEL_QRK_GIP_NGPIO;
+static unsigned int gpio_irqbase = INTEL_QRK_GIP_GPIO_IRQBASE;
+
+/* Store GPIO context across system-wide suspend/resume transitions */
+static struct gpio_saved_regs {
+	u32 data;
+	u32 dir;
+	u32 int_en;
+	u32 int_mask; 
+	u32 int_type; 
+	u32 int_pol; 
+	u32 int_deb; 
+} saved_regs;
+
+/* PortA registers set. Note other ports are unused */
+#define PORTA_DATA			0x00	/* Data */
+#define PORTA_DIR			0x04	/* Direction */
+#define PORTA_INT_EN			0x30	/* Interrupt enable */
+#define PORTA_INT_MASK			0x34	/* Interrupt mask */
+#define PORTA_INT_TYPE_LEVEL		0x38	/* Interrupt level*/
+#define PORTA_INT_POLARITY		0x3c	/* Interrupt polarity */
+#define PORTA_INT_STATUS		0x40	/* Interrupt status */
+#define PORTA_INT_RAW_STATUS		0x44	/* Interrupt raw status */
+#define PORTA_DEBOUNCE			0x48	/* Debounce enable */
+#define PORTA_INT_EOI			0x4c	/* Clear interrupt */
+#define PORTA_EXT			0x50	/* External */
+
+module_param(n_gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(n_gpio, "Number of GPIO");
+
+module_param(gpio_irqbase, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_irqbase, "Base IRQ for GPIO range");
+
+/**
+ * intel_qrk_gpio_get
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return 0 if GPIO is deasserted, 1 if GPIO is asserted
+ *
+ * Read back the value of a GPIO.
+ */
+static int intel_qrk_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *reg_ext = reg_base + PORTA_EXT;
+	u32 val_ext = ioread32(reg_ext);
+
+	val_ext &= BIT(offset % 32);
+	return (val_ext > 0);
+}
+
+/**
+ * intel_qrk_gpio_set
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ *
+ * Set value of a GPIO.
+ */
+static void intel_qrk_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	void __iomem *reg_data = reg_base + PORTA_DATA;
+	u32 val_data = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_data = ioread32(reg_data);
+	if (value)
+		iowrite32(val_data | BIT(offset % 32), reg_data);
+	else
+		iowrite32(val_data & ~BIT(offset % 32), reg_data);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_direction_input
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return always 0 (success)
+ *
+ * Set direction of a GPIO as input.
+ */
+static int intel_qrk_gpio_direction_input(struct gpio_chip *chip,
+						unsigned offset)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir & ~BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_direction_output
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param value: value to be driven to the GPIO
+ * @return always 0 (success)
+ *
+ * Set the default value of a GPIO, and then set direction as output.
+ */
+static int intel_qrk_gpio_direction_output(struct gpio_chip *chip,
+			unsigned offset, int value)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	/* Ensure glitch-free operation. */
+	intel_qrk_gpio_set(chip, offset, value);
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir | BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_set_debounce
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param debounce: 1 to enable, 0 to disable
+ * @return always 0 (success)
+ *
+ * Enable/disable interrupt debounce logic for a GPIO.
+ */
+static int intel_qrk_gpio_set_debounce(struct gpio_chip *chip,
+				 unsigned offset, unsigned debounce)
+{
+	u32 val_deb = 0;
+	void __iomem *reg_deb = reg_base + PORTA_DEBOUNCE;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_deb = ioread32(reg_deb);
+	if (debounce)
+		iowrite32(val_deb | BIT(offset % 32), reg_deb);
+	else
+		iowrite32(val_deb & ~BIT(offset % 32), reg_deb);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_irq_type
+ * @param irq_data: Pointer to information about the IRQ
+ * @param type: set the triggering type of the interrupt
+ * @return always 0 (success)
+ *
+ * Set interrupt triggering type for a GPIO.
+ */
+static int intel_qrk_gpio_irq_type(struct irq_data *d, unsigned type)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+	void __iomem *reg_level = reg_base + PORTA_INT_TYPE_LEVEL;
+	void __iomem *reg_pol = reg_base + PORTA_INT_POLARITY;
+	u32 val_level = 0;
+	u32 val_pol = 0;
+	u32 gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n",  __func__);
+		return -EFAULT;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_level = ioread32(reg_level);
+	val_pol = ioread32(reg_pol);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_irq_unmask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Unmask interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_unmask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask | BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_mask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Mask interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_mask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask & ~BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_enable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Enable interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_enable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte | BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_disable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Disable interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_disable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte & ~BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_to_irq
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return IRQ associated to GPIO
+ *
+ * Compute the IRQ number based on the GPIO.
+ */
+static int intel_qrk_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	return irq_base + offset;
+}
+
+/**
+ * intel_qrk_gpio_isr
+ * @param irq: IRQ number
+ * @param dev_id: cookie used to tell what instance of the driver the interrupt
+ *                belongs to
+ * @return IRQ_HANDLED if interrupt served, IRQ_NONE if no interrupt pending
+ *
+ * Interrupt Service Routine for GPIO. Identify which GPIOs (if any) is pending
+ * for interrupt to be served, acknowledge the interrupt and serve it.
+ */
+irqreturn_t intel_qrk_gpio_isr(int irq, void *dev_id)
+{
+	irqreturn_t ret = IRQ_NONE;
+	u32 pending = 0, gpio = 0;
+	void __iomem *reg_pending = reg_base + PORTA_INT_STATUS;
+	void __iomem *reg_eoi = reg_base + PORTA_INT_EOI;
+
+	/* Which pin (if any) triggered the interrupt */
+	while ((pending = ioread32(reg_pending))) {
+		/*
+		 * Acknowledge all the asserted GPIO interrupt lines before
+		 * serving them, so that we don't lose an edge.
+		 * This has only effect on edge-triggered interrupts.
+		 */
+		iowrite32(pending, reg_eoi);
+
+		/* Serve each asserted interrupt */
+		do {
+			gpio = __ffs(pending);
+			generic_handle_irq(
+				gpio_to_irq(INTEL_QRK_GIP_GPIO_BASE + gpio));
+			pending &= ~BIT(gpio);
+			ret = IRQ_HANDLED;
+		} while(pending);
+	}
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_qrk_gpio_save_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	saved_regs.int_mask = ioread32(reg_base + PORTA_INT_MASK);
+	saved_regs.int_en = ioread32(reg_base + PORTA_INT_EN);
+	saved_regs.int_deb = ioread32(reg_base + PORTA_DEBOUNCE);
+	saved_regs.int_pol = ioread32(reg_base + PORTA_INT_POLARITY);
+	saved_regs.int_type = ioread32(reg_base + PORTA_INT_TYPE_LEVEL);
+	saved_regs.dir = ioread32(reg_base + PORTA_DIR);
+	saved_regs.data = ioread32(reg_base + PORTA_DATA);
+
+	/* Mask out interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_MASK);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_qrk_gpio_restore_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	iowrite32(saved_regs.data, reg_base + PORTA_DATA);
+	iowrite32(saved_regs.dir, reg_base + PORTA_DIR);
+	iowrite32(saved_regs.int_type, reg_base + PORTA_INT_TYPE_LEVEL);
+	iowrite32(saved_regs.int_pol, reg_base + PORTA_INT_POLARITY);
+	iowrite32(saved_regs.int_deb, reg_base + PORTA_DEBOUNCE);
+	iowrite32(saved_regs.int_en, reg_base + PORTA_INT_EN);
+	iowrite32(saved_regs.int_mask, reg_base + PORTA_INT_MASK);
+
+	/* Clear out spurious interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_EOI);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ * Initiate the GPIO device.
+ */
+int intel_qrk_gpio_probe(struct pci_dev *pdev)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+
+	/* Get UIO memory */
+	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	/* Determine the address of the GPIO area */
+	start = pci_resource_start(pdev, GIP_GPIO_BAR);
+	len = pci_resource_len(pdev, GIP_GPIO_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_GPIO_BAR);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (NULL == reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	memset(&saved_regs, 0x0, sizeof(saved_regs));
+
+	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
+	if (!gc) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	if (n_gpio == 0 || n_gpio > INTEL_QRK_GIP_NGPIO) {
+		dev_err(&pdev->dev, "n_gpio outside range [1,%d]\n",
+			INTEL_QRK_GIP_NGPIO);
+		retval = -EINVAL;
+		goto err_free_gpiochip;
+	}
+
+	gc->label = "intel_qrk_gip_gpio";
+	gc->owner = THIS_MODULE;
+	gc->direction_input = intel_qrk_gpio_direction_input;
+	gc->direction_output = intel_qrk_gpio_direction_output;
+	gc->get = intel_qrk_gpio_get;
+	gc->set = intel_qrk_gpio_set;
+	gc->set_debounce = intel_qrk_gpio_set_debounce;
+	gc->to_irq = intel_qrk_gpio_to_irq;
+	gc->base = INTEL_QRK_GIP_GPIO_BASE;
+	gc->ngpio = n_gpio;
+	gc->can_sleep = 0;
+	retval = gpiochip_add(gc);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding GPIO chip\n");
+		goto err_free_gpiochip;
+	}
+
+	spin_lock_init(&lock);
+
+	/*
+	 * Allocate a range of IRQ descriptor for the available GPIO.
+	 * IRQs are allocated dynamically.
+	 */
+	irq_base = irq_alloc_descs(-1, gpio_irqbase, n_gpio, NUMA_NO_NODE);
+	if (irq_base < 0) {
+		dev_err(&pdev->dev, "failure adding GPIO IRQ descriptors\n");
+		goto err_remove_gpiochip;
+	}
+
+	retval = platform_device_register(&qrk_gpio_restrict_pdev);
+	if (retval < 0){
+		goto err_free_irq_descs;
+	}
+
+	igc = irq_alloc_generic_chip("intel_qrk_gip_gpio", 1, irq_base,
+			reg_base, handle_simple_irq);
+	if (NULL == igc) {
+		retval = -ENOMEM;
+		goto err_free_irq_descs;
+	}
+
+	/* UIO */
+	info->mem[0].addr = start;
+	info->mem[0].internal_addr = reg_base;
+	info->mem[0].size = len;
+	info->mem[0].memtype = UIO_MEM_PHYS;
+	info->mem[0].name = "gpio_regs";
+	info->name = "gpio uio";
+	info->version = "0.0.1";
+
+	if (uio_register_device(&pdev->dev, info))
+		goto err_free_irq_descs;
+
+	pr_info("%s UIO addr 0x%08x internal_addr 0x%08x size %lu memtype %d\n",
+		__func__, (unsigned int)info->mem[0].addr,
+		(unsigned int)info->mem[0].internal_addr, info->mem[0].size,
+		info->mem[0].memtype);
+	igc->chip_types->chip.irq_mask = intel_qrk_gpio_irq_mask;
+	igc->chip_types->chip.irq_unmask = intel_qrk_gpio_irq_unmask;
+	igc->chip_types->chip.irq_set_type = intel_qrk_gpio_irq_type;
+	igc->chip_types->chip.irq_enable = intel_qrk_gpio_irq_enable;
+	igc->chip_types->chip.irq_disable = intel_qrk_gpio_irq_disable;
+
+	irq_setup_generic_chip(igc, IRQ_MSK(n_gpio), IRQ_GC_INIT_MASK_CACHE,
+			IRQ_NOREQUEST | IRQ_NOPROBE, 0);
+
+	return 0;
+
+err_free_irq_descs:
+	irq_free_descs(irq_base, n_gpio);
+err_remove_gpiochip:
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+err_free_gpiochip:
+	kfree(gc);
+err_iounmap:
+	iounmap(reg_base);
+exit:
+	if (info != NULL)
+		kfree(info);
+	return retval;
+}
+
+/**
+ * intel_qrk_gpio_remove
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP
+ * driver.
+ */
+void intel_qrk_gpio_remove(struct pci_dev *pdev)
+{
+	if (NULL == igc) {
+		dev_err(&pdev->dev, "null pointer to irq_generic_chip\n");
+		return;
+	}
+	if (NULL == gc) {
+		dev_err(&pdev->dev, "null pointer to gpio_chip\n");
+		return;
+	}
+
+	/* Tear down IRQ descriptors */
+	irq_remove_generic_chip(igc, IRQ_MSK(n_gpio), 0,
+		IRQ_NOREQUEST | IRQ_NOPROBE);
+	kfree(igc);
+	irq_free_descs(irq_base, n_gpio);
+
+	platform_device_unregister(&qrk_gpio_restrict_pdev);
+
+	/* Release GPIO chip */
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+
+
+	if (info != NULL){
+		uio_unregister_device(info);
+		kfree(info);
+	}
+
+	kfree(gc);
+	iounmap(reg_base);
+}
diff --git a/drivers/mfd/intel_qrk_gip_i2c.c b/drivers/mfd/intel_qrk_gip_i2c.c
new file mode 100644
index 0000000..9ecbeb5
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_i2c.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) - I2C-specific PCI driver
+ *
+ *  PCI glue logic for Quark GIP/I2C.
+ *  The GIP I2C device is the DesignWare I2C. This file defines the PCI glue
+ *  for this driver and is heavily based on
+ *  on drivers/i2c/busses/i2c-designware-pcidrv.c.  Also, it relies on
+ *  drivers/i2c/busses/i2c-designware-core.c for the core logic.
+ *  Please note only a single instance of the I2C device is supported.
+ */
+
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_qrk_gip.h"
+
+enum dw_pci_ctl_id_t {
+	quark_0,
+};
+
+/*
+ * By default, driver operates in fast mode (400kHz).
+ *
+ * Standard mode operation (100kHz) can be forced via, in order of priority:
+ * 1. setting the following i2c_std_mode module parameter to 1
+ * 2. setting the platform data i2c_std_mode parameter to 1
+ *
+ * Note in both cases, setting i2c_std_mode to 0 means forcing fast mode
+ * operation.
+ */
+static unsigned int i2c_std_mode = -1;
+module_param(i2c_std_mode, uint, S_IRUSR);
+MODULE_PARM_DESC(i2c_std_mode, "Set to 1 to force I2C standard mode");
+
+#define INTEL_QRK_STD_CFG  (DW_IC_CON_MASTER |			\
+				DW_IC_CON_SLAVE_DISABLE |	\
+				DW_IC_CON_RESTART_EN)
+
+static struct dw_pci_controller qrk_gip_i2c_controller = {
+	.bus_num	= 0,
+	.bus_cfg	= INTEL_QRK_STD_CFG | DW_IC_CON_SPEED_FAST,
+	.tx_fifo_depth	= 16,
+	.rx_fifo_depth	= 16,
+	.clk_khz	=
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
+			14000,
+#else
+			33000,
+#endif
+	.explicit_stop	= 1,
+};
+
+static struct i2c_algorithm i2c_dw_algo = {
+	.master_xfer	= i2c_dw_xfer,
+	.functionality	= i2c_dw_func,
+};
+
+/**
+ * i2c_dw_get_clk_rate_khz
+ * @param dev: Pointer to I2C device private data
+ * @return clock rate in kHz
+ *
+ * Ancillary function returning the frequency of the clock supplied to the
+ * interface.
+ */
+static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+{
+	return dev->controller->clk_khz;
+}
+
+/**
+ * intel_qrk_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ * Also call into I2C core driver routines for initiating the device.
+ */
+int intel_qrk_i2c_probe(struct pci_dev *pdev,
+			struct dw_i2c_dev **drvdata,
+			struct intel_qrk_gip_pdata *pdata)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+	struct dw_i2c_dev *dev = NULL;
+	struct i2c_adapter *adap = NULL;
+	void __iomem *reg_base = NULL;
+	struct dw_pci_controller *controller = NULL;
+	int std_mode = -1;
+
+	controller = &qrk_gip_i2c_controller;
+
+	/* Quark default configuration is fast mode, unless otherwise forced */
+	if (-1 != i2c_std_mode) {
+		switch (i2c_std_mode) {
+		case 0:
+		case 1:
+			std_mode = i2c_std_mode;
+			break;
+		default:
+			dev_err(&pdev->dev, "invalid i2c_std_mode param val %d."
+				" Using driver default\n", i2c_std_mode);
+			break;
+		}
+	} else if (pdata) {
+		switch (pdata->i2c_std_mode) {
+		case 0:
+		case 1:
+			std_mode = pdata->i2c_std_mode;
+			break;
+		default:
+			dev_err(&pdev->dev, "invalid i2c_std_mode pdata val %d."
+				" Usign driver default\n", pdata->i2c_std_mode);
+			break;
+		}
+	}
+	if (-1 != std_mode) {
+		if (0 == std_mode) {
+			controller->bus_cfg |= DW_IC_CON_SPEED_FAST;
+			controller->bus_cfg &= ~DW_IC_CON_SPEED_STD;
+		} else {
+			controller->bus_cfg &= ~DW_IC_CON_SPEED_FAST;
+			controller->bus_cfg |= DW_IC_CON_SPEED_STD;
+		}
+		dev_info(&pdev->dev, "i2c speed set to %skHz\n",
+			 std_mode ? "100" : "400");
+	}
+
+	/* Determine the address of the I2C area */
+	start = pci_resource_start(pdev, GIP_I2C_BAR);
+	len = pci_resource_len(pdev, GIP_I2C_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_I2C_BAR);
+		retval = -ENODEV;
+		goto err;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (!reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->clk = NULL;
+	dev->controller = controller;
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+	dev->base = reg_base;
+	dev->dev = get_device(&pdev->dev);
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->master_cfg =  controller->bus_cfg;
+
+	*drvdata = dev;
+
+	dev->tx_fifo_depth = controller->tx_fifo_depth;
+	dev->rx_fifo_depth = controller->rx_fifo_depth;
+	dev->explicit_stop = controller->explicit_stop;
+	retval = i2c_dw_init(dev);
+	if (retval)
+		goto err_release_drvdata;
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = 0;
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->nr = controller->bus_num;
+	snprintf(adap->name, sizeof(adap->name), "intel_qrk_gip_i2c");
+
+	i2c_dw_disable_int(dev);
+	i2c_dw_clear_int(dev);
+	retval = i2c_add_numbered_adapter(adap);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding I2C adapter\n");
+		goto err_release_drvdata;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	put_device(&pdev->dev);
+	kfree(dev);
+err_iounmap:
+	iounmap(reg_base);
+err:
+	return retval;
+}
+
+/**
+ * intel_qrk_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data 
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev)
+{
+
+	if (NULL == dev) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	i2c_dw_disable(dev);
+	i2c_del_adapter(&dev->adapter);
+	iounmap(dev->base);
+
+	kfree(dev);
+}
diff --git a/drivers/mfd/intel_qrk_gip_pdata.c b/drivers/mfd/intel_qrk_gip_pdata.c
new file mode 100644
index 0000000..a764215
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_pdata.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+
+struct intel_qrk_gip_pdata *(*intel_qrk_gip_get_pdata)(void) = NULL;
+EXPORT_SYMBOL_GPL(intel_qrk_gip_get_pdata);
diff --git a/drivers/mfd/intel_qrk_gip_test.c b/drivers/mfd/intel_qrk_gip_test.c
new file mode 100644
index 0000000..2b07e9e
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_test.c
@@ -0,0 +1,1131 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) Test module
+ *
+ * Quark GIP + North-Cluster GPIO test module.
+ */
+
+#include <asm/tsc.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#define DRIVER_NAME			"intel_qrk_gip_test"
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define GIP_TEST_IOCTL_CODE			0xE0
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_QRK_GPIO_11			_IO(GIP_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_QRK_GPIO_11_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x01)
+#define IOCTL_QRK_GPIO_12			_IO(GIP_TEST_IOCTL_CODE, 0x02)
+#define IOCTL_QRK_GPIO_12_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x03)
+#define IOCTL_QRK_GPIO_13			_IO(GIP_TEST_IOCTL_CODE, 0x04)
+#define IOCTL_QRK_GPIO_13_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x05)
+#define IOCTL_QRK_GPIO_14			_IO(GIP_TEST_IOCTL_CODE, 0x06)
+#define IOCTL_QRK_GPIO_14_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x07)
+#define IOCTL_QRK_GPIO_15			_IO(GIP_TEST_IOCTL_CODE, 0x08)
+#define IOCTL_QRK_GPIO_15_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x09)
+#define IOCTL_QRK_GPIO_16			_IO(GIP_TEST_IOCTL_CODE, 0x0A)
+#define IOCTL_QRK_GPIO_16_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0B)
+#define IOCTL_QRK_GPIO_17			_IO(GIP_TEST_IOCTL_CODE, 0x0C)
+#define IOCTL_QRK_GPIO_17_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0D)
+#define IOCTL_QRK_GPIO_19			_IO(GIP_TEST_IOCTL_CODE, 0x0E)
+#define IOCTL_QRK_GPIO_19_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0F)
+#define IOCTL_QRK_GPIO_20			_IO(GIP_TEST_IOCTL_CODE, 0x10)
+#define IOCTL_QRK_GPIO_20_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x11)
+#define IOCTL_QRK_GPIO_21			_IO(GIP_TEST_IOCTL_CODE, 0x12)
+#define IOCTL_QRK_GPIO_21_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x13)
+#define IOCTL_QRK_GPIO_24			_IO(GIP_TEST_IOCTL_CODE, 0x14)
+#define IOCTL_QRK_GPIO_26			_IO(GIP_TEST_IOCTL_CODE, 0x15)
+#define IOCTL_QRK_GPIO_26_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x16)
+/* Exercise callbacks for S0/S3 power-state transitions and vice-versa */
+#define IOCTL_QRK_GIP_SYSTEM_SUSPEND		_IO(GIP_TEST_IOCTL_CODE, 0x17)
+#define IOCTL_QRK_GIP_SYSTEM_RESUME		_IO(GIP_TEST_IOCTL_CODE, 0x18)
+#define IOCTL_QRK_GPIO_NMI_ENABLE		_IO(GIP_TEST_IOCTL_CODE, 0x19)
+#define IOCTL_QRK_GPIO_NMI_DISABLE		_IO(GIP_TEST_IOCTL_CODE, 0x1A)
+
+#define GPIO_INT_EDGE_POS_LABEL			"gpio-edge-pos"
+#define GPIO_INT_EDGE_NEG_LABEL			"gpio-edge-neg"
+#define GPIO_INT_LEVEL_HIGH_LABEL		"gpio-level-hi"
+#define GPIO_INT_LEVEL_LOW_LABEL		"gpio-level-lo"
+#define GPIO_INT_BASIC_LABEL			"gpio-edge-pos-basic"
+#define GPIO_PM_TEST_IRQ_LABEL			"gpio_pm_test_irq"
+
+/*
+ * Board GPIO numbers.
+ * Mapping between the North/South cluster GPIO and GPIOLIB IDs.
+ */
+#define SUT_GPIO_NC_0				0x00
+#define SUT_GPIO_NC_1				0x01
+#define SUT_GPIO_NC_2				0x02
+#define SUT_GPIO_NC_7				0x07
+#define SUT_GPIO_SC_0				0x08
+#define SUT_GPIO_SC_1				0x09
+#define SUT_GPIO_SC_6				0x0E
+#define SUT_GPIO_SC_7				0x0F
+
+/*
+ * Bitbanged SPI bus numbers.
+ */
+#define GPIO_NC_BITBANG_SPI_BUS			0x0
+#define GPIO_SC_BITBANG_SPI_BUS			0x1
+
+/*****************************************************************************/
+
+/**
+ * struct intel_qrk_gip_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_qrk_gip_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_qrk_gip_test_dev gip_test_dev;
+static struct class *gip_test_class;
+static DEFINE_MUTEX(gip_test_mutex);
+static int gip_test_major;
+
+/*
+ * Level-triggered interrupt variables
+ */
+/* Level-triggered GPIO workqueue */
+static struct delayed_work work;
+/* Level-triggered interrupt counter */
+static unsigned int level_int_count;
+/* By default, a level-triggered interrupt is a low-level triggered */
+static int level_high_triggered = 0;
+
+/*
+ * Interrupt performance metrics variables and parameters
+ */
+/* How many captures */
+#define INT_PERF_TEST_CAPTURES			10000
+/* Timestamp for latency test interrupt handler */
+static cycles_t perf_t1;
+/* Captures to be returned to user space */
+static cycles_t deltas[INT_PERF_TEST_CAPTURES];
+/* Couldn't find the actual define for this */
+#define UINT64_MAX		0xFFFFFFFFFFFFFFFFULL
+
+static irqreturn_t gpio_pm_test_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_latency_handler(int irq, void *dev_id)
+{
+	/* t0 */
+	perf_t1 = get_cycles();
+
+	gpio_set_value(SUT_GPIO_SC_0, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_basic_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_pos_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_neg_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_level_handler(int irq, void *dev_id)
+{
+	/* Untrigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 0 : 1);
+
+	level_int_count ++;
+	if (level_int_count < 1000) {
+		/* Next task due in a jiffy */
+		schedule_delayed_work(&work, 1);
+	} else if (level_int_count == 1000){
+		/* OK */
+	} else {
+		/*
+		 * We may get spurious interrupts. This because the TE requires
+		 * some time to drive the actual value to the GPIO.
+		 */
+		pr_info("Spurious interrupt\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void gpio_level_drive(struct work_struct *work)
+{
+	/* TE to trigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 1 : 0);
+}
+
+/**
+ * gpio_sc_level_int
+ *
+ * Request level triggered IRQ for SUT_GPIO_SC_6 and register
+ * SUT_GPIO_SC_7 as output GPIO.
+ * If positive equals to 0, the IRQ is high-level triggered.
+ * Otherwise, low-level triggered.
+ * Mask the IRQ if requested.
+ */
+static int gpio_sc_level_int(int positive, int masking)
+{
+	int ret = 0;
+	int irq = -1;
+
+	unsigned long out_init_val =
+		(positive ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);
+
+	level_high_triggered = positive;
+
+	/* Initialise workqueue task */
+	INIT_DELAYED_WORK(&work, gpio_level_drive);
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_hi_level");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, out_init_val, "gpio_output");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_level_handler,
+			positive ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW,
+			positive ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_LEVEL_LOW_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	level_int_count = 0;
+
+	pr_info("Registered output gpio%d and IRQ for gpio%d\n", SUT_GPIO_SC_7,
+		SUT_GPIO_SC_6);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		pr_info("Masked gpio%d IRQ\n", SUT_GPIO_SC_6);
+	}
+
+	/*
+	 * Submit task to workqueue to drive the external Test Equipment.
+	 * Note the task is delayed long enough to have Aarvark already set up.
+	 * This because Aardvark has to ignore the initial glitches during the
+	 * previous GPIO setup phase. 
+	 */
+	schedule_delayed_work(&work, 20 * HZ);
+
+	return 0;
+
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_level_int_teardown
+ *
+ * Release resources reserved by gpio_sc_level_int().
+ */
+static int gpio_sc_level_int_teardown(void)
+{
+	int irq = -1;
+
+	if (0 != cancel_delayed_work_sync(&work))
+		pr_warn("delayed work was still pending\n");
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	/* Make sure no handler is still running by this time */
+	mdelay(20);
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/*
+ * gpio_sc_interrupt_perf
+ *
+ * Performs a basic GPIO interrupt latency test by timestamping delta between
+ * interrupt driven and handled over a GPIO loopback.
+ *
+ * Returns to userspace the array of deltas obtained during each capture.
+ * A total amount of INT_PERF_TEST_CAPTURES captures is performed.
+ *
+ */
+static int gpio_sc_interrupt_perf(unsigned long user_memloc)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_1;
+	int gpio_output = SUT_GPIO_SC_0;
+	unsigned int i = 0;
+	cycles_t perf_t0 = 0;
+	cycles_t delta = 0;
+
+	/* Casting pointer to user-space location to write */
+	cycles_t __user *user_ptr = (cycles_t __user *)user_memloc;
+
+	/* Can we copy the captures array into user-space location? */
+	if (!access_ok(VERIFY_WRITE, user_ptr, sizeof(deltas))) {
+		pr_err("can't copy 0x%x bytes to user-space address 0x%p\n",
+			sizeof(deltas),user_ptr);
+		return -EFAULT;
+	}
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(gpio_output)) {
+		pr_err("gpio%d is invalid\n", gpio_output);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_intperf_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_output, GPIOF_OUT_INIT_LOW, "gpio_intperf_out");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_output, ret);
+		goto fail_release_input_gpio;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_latency_handler,
+			IRQF_TRIGGER_RISING, "gpio_latency_handler", NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+
+	/* Perform test */
+	for (i = 0; i < INT_PERF_TEST_CAPTURES; i ++) {
+		/* t0 */
+		perf_t0 = get_cycles();
+
+		/* Trigger interrupt */
+		gpio_set_value(gpio_output, 1);
+		mdelay(2);
+
+		/* Check for wrap-around and store delta */
+		if(perf_t0 < perf_t1) {
+			delta = perf_t1 - perf_t0;
+		} else {
+			delta = perf_t1 + (UINT64_MAX - perf_t0);
+		}
+		deltas[i] = delta;
+	}
+
+	/* Expose results to userspace */
+	ret = copy_to_user(user_ptr, &deltas, sizeof(deltas));
+
+	/* Release resources */
+
+	free_irq(irq, NULL);
+
+fail_release_output_gpio:
+	gpio_free(gpio_output);
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	if (0 != ret) {
+		pr_err("%s() failed\n", __func__);
+	}
+
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Request rising edge-triggered IRQ for SUT_GPIO_SC_0
+ */
+static int gpio_sc_pm_test_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_0;
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_pm_test_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_pm_test_handler,
+			IRQF_TRIGGER_RISING, GPIO_PM_TEST_IRQ_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+
+	return 0;
+
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_pm_test_int_teardown(void)
+{
+	int irq = -1;
+
+	irq = gpio_to_irq(SUT_GPIO_SC_0);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_0);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_0);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_edge_int
+ *
+ * Request IRQ for SUT_GPIO_SC_6 and SUT_GPIO_SC_7, respectively positive-edge
+ * and negative edge-triggered.
+ * Mask the IRQs if requested.
+ */
+static int gpio_sc_edge_int(int masking)
+{
+	int ret = 0;
+	int irq_pos = -1, irq_neg = -1;
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_pos_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, GPIOF_IN, "gpio_neg_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq_pos, gpio_pos_edge_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_EDGE_POS_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	if (0 != (ret = request_irq(irq_neg, gpio_neg_edge_handler,
+			IRQF_TRIGGER_FALLING, GPIO_INT_EDGE_NEG_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_7);
+		goto fail_release_first_gpio_irq;
+	}
+
+	pr_info("Registered gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+		SUT_GPIO_SC_7);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_7));
+		pr_info("Masked gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+			SUT_GPIO_SC_7);
+	}
+
+	return 0;
+
+fail_release_first_gpio_irq:
+	free_irq(irq_pos, NULL);
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_edge_int_teardown
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_edge_int_teardown(void)
+{
+	int irq_pos = -1, irq_neg = -1;
+
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+	} else {
+		free_irq(irq_neg, NULL);
+	}
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq_pos, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_basic_int
+ *
+ * Register rising-edge interrupt handler on SUT_GPIO_SC_1
+ */
+static int gpio_sc_basic_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN, "gpio_pos_edge_basic");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_basic_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_BASIC_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	pr_info("Registered gpio%d IRQ\n", gpio);
+
+	return 0;
+
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_basic_int_teardown
+ *
+ * Release resources reserved by gpio_sc_basic_int()
+ */
+static int gpio_sc_basic_int_teardown(void)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/**
+ * gpio_spidev_register
+ *
+ * Register a bitbanged SPI platform device and export a `spidev' to userspace.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_register(int north_cluster)
+{
+	/* Not needed anymore */
+	return 0;
+}
+
+/**
+ * gpio_spidev_unregister
+ *
+ * Release a bitbanged SPI platform device and its `spidev' interface.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_unregister(int north_cluster)
+{
+	/* Not needed anymore */
+	return 0;
+}
+
+/**
+ * gip_system_power_transition 
+ *
+ * @param state: 0 if transition to S3, !0 if transition to S0
+ * @return 0 success < 0 failure
+ *
+ * Exercise system-wide suspend/resume power management transitions.
+ * 
+ */
+static int gip_system_power_transition(int state)
+{
+	struct pci_dev *gip = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, NULL);
+	if (NULL == gip) {
+		pr_err("can't find GIP PCI device\n");
+		return -ENOENT;
+	}
+
+	if (0 == state) {
+		gip->driver->driver.pm->suspend(&gip->dev);
+	} else {
+		gip->driver->driver.pm->resume(&gip->dev);
+	}
+
+	/* Decrement reference count of PCI device */
+	if (NULL != pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, gip)) {
+		pr_warn("found duplicate of GIP PCI device?!\n");
+	}
+
+	return 0;
+}
+
+/**
+ * gpio_nmi_enable 
+ *
+ * @param enable: 0 to disable, !0 to enable
+ * @return 0 success < 0 failure
+ *
+ * Hack the legacy GPIO hardware to enable rising-edge triggered NMI on Core
+ * Well gpio0.
+ * 
+ */
+static int gpio_nmi_enable(int enable)
+{
+	unsigned int base_u32 = 0x0;
+	unsigned short base = 0x0;
+	struct pci_dev *ilb = pci_get_device(PCI_VENDOR_ID_INTEL,
+					     PCI_DEVICE_ID_INTEL_QUARK_ILB,
+					     NULL);
+	/* Assume interrupts are disabled by default by BIOS */
+	unsigned char gpio = enable ? 0x01 : 0x00; 
+
+	if (NULL == ilb) {
+		pr_err("can't find iLB device\n");
+		return -ENOENT;
+	}
+
+	/* The GPIO base address is @ offset 0x44.  Sussed out from driver */
+	pci_read_config_dword(ilb, 0x44, &base_u32);
+	if (0x0 == base_u32) {
+		pr_err("can't read iLB GPIO baseaddr\n");
+		return -ENOENT;
+	}
+	base = (unsigned short)base_u32;
+
+	/*
+	 * Prepare for rising edge NMI triggering.  This assumes the pin
+	 * is already set as input.
+	 */
+#define CGTPE		0x0C	/* Core Well trigger positive edge */
+#define CGTS		0x1C	/* Core Well trigges status - W1C */
+#define CGNMIEN		0x40	/* Core Well NMI enable */
+	outb(0x01, base + CGTS);
+	outb(gpio, base + CGTPE);
+	outb(gpio, base + CGNMIEN);
+#undef CGTPE
+#undef CGTS
+#undef CGNMIEN
+
+	return 0;
+}
+
+/**
+ * gpio_sc_debounce
+ *
+ * Enable GPIO debounce functionality for SC_GPIO_1 (edge and level triggered)
+ *
+ */
+static int gpio_sc_debounce(int level)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio = SUT_GPIO_SC_0;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN,
+		level ? "gpio_level_mask" : "gpio_edge_mask");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/*
+	 * Register IRQ. gpio_pos_edge_handler will do for both level and edge
+	 * interrupts, as it's nooping.
+	 */
+	if (0 != (ret = request_irq(irq, gpio_pos_edge_handler,
+			level ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_RISING,
+			level ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_EDGE_POS_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/* Set debounce */
+	if (0 != (ret = gpio_set_debounce(gpio, 1))) {
+		pr_err("can't set debounce for gpio%d\n", gpio);
+		goto fail_free_irq;
+	}
+
+	return 0;
+
+fail_free_irq:
+	free_irq(irq, NULL);
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_debounce_teardown
+ *
+ * Undo gpio_sc_debounce
+ *
+ */
+static int gpio_sc_debounce_teardown(int level)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_0;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long gip_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_QRK_GPIO_11:
+			/* Edge-triggered interrupts */
+			ret = gpio_sc_edge_int(0);
+			break;
+		case IOCTL_QRK_GPIO_11_CLEANUP:
+			/* Edge-triggered interrupts cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_12:
+			/* Edge-triggered interrupts (masking) */
+			ret = gpio_sc_edge_int(1);
+			break;
+		case IOCTL_QRK_GPIO_12_CLEANUP:
+			/* Edge-triggered interrupts (masking) cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_13:
+			/* GPIO debounce (edge) */
+			ret = gpio_sc_debounce(0);
+			break;
+		case IOCTL_QRK_GPIO_13_CLEANUP:
+			/* GPIO debounce cleanup (edge) */
+			ret = gpio_sc_debounce_teardown(0);
+			break;
+		case IOCTL_QRK_GPIO_14:
+			/* High-level triggered interrupts */
+			ret = gpio_sc_level_int(1, 0);
+			break;
+		case IOCTL_QRK_GPIO_14_CLEANUP:
+			/* High-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_15:
+			/* Low-level triggered interrupts */
+			ret = gpio_sc_level_int(0, 0);
+			break;
+		case IOCTL_QRK_GPIO_15_CLEANUP:
+			/*Low-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_16:
+			/* Level triggered interrupts (masking) */
+			ret = gpio_sc_level_int(1, 1);
+			break;
+		case IOCTL_QRK_GPIO_16_CLEANUP:
+			/* Level triggered interrupts (masking) cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_17:
+			/* GPIO debounce (level) */
+			ret = gpio_sc_debounce(1);
+			break;
+		case IOCTL_QRK_GPIO_17_CLEANUP:
+			/* GPIO debounce cleanup (level) */
+			ret = gpio_sc_debounce_teardown(1);
+			break;
+		case IOCTL_QRK_GPIO_19:
+			/* Register IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int();
+			break;
+		case IOCTL_QRK_GPIO_19_CLEANUP:
+			/* Free IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_20:
+			/* NC bitbanged SPI */
+			ret = gpio_spidev_register(1);
+			break;
+		case IOCTL_QRK_GPIO_20_CLEANUP:
+			/* NC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(1);
+			break;
+		case IOCTL_QRK_GPIO_21:
+			/* SC bitbanged SPI */
+			ret = gpio_spidev_register(0);
+			break;
+		case IOCTL_QRK_GPIO_21_CLEANUP:
+			/* SC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(0);
+			break;
+		case IOCTL_QRK_GPIO_24:
+			/*
+			 * SC GPIO interrupt performance test.
+			 * Note it's shared between QRK_GPIO_24 and QRK_GPIO_25
+			 * plus it doesn't need any cleanup call.
+			 */
+			ret = gpio_sc_interrupt_perf(arg);
+			break;
+		case IOCTL_QRK_GPIO_26:
+			/* Interrupt for basic loopback test */
+			ret = gpio_sc_basic_int();
+			break;
+		case IOCTL_QRK_GPIO_26_CLEANUP:
+			/* Interrupt for basic loopback test cleanup */
+			ret = gpio_sc_basic_int_teardown();
+			break;
+		case IOCTL_QRK_GIP_SYSTEM_SUSPEND:
+			ret = gip_system_power_transition(0);
+			break;
+		case IOCTL_QRK_GIP_SYSTEM_RESUME:
+			ret = gip_system_power_transition(1);
+			break;
+		case IOCTL_QRK_GPIO_NMI_ENABLE:
+			ret = gpio_nmi_enable(1);
+			break;
+		case IOCTL_QRK_GPIO_NMI_DISABLE:
+			ret = gpio_nmi_enable(0);
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int gip_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&gip_test_dev.open_lock)) {
+		mutex_unlock(&gip_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (gip_test_dev.opened) {
+		mutex_unlock(&gip_test_dev.open_lock);
+		mutex_unlock(&gip_test_mutex);
+		return -EINVAL;
+	}
+
+	gip_test_dev.opened++;
+	mutex_unlock(&gip_test_dev.open_lock);
+	mutex_unlock(&gip_test_mutex);
+	return 0;
+}
+
+static int gip_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_dev.open_lock);
+	gip_test_dev.opened = 0;
+	mutex_unlock(&gip_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations gip_test_file_ops = {
+	.open = gip_test_open,
+	.release = gip_test_release,
+	.unlocked_ioctl = gip_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_qrk_gip_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_qrk_gip_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&gip_test_dev.open_lock);
+	cdev_init(&gip_test_dev.cdev, &gip_test_file_ops);
+	gip_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&gip_test_dev.cdev, MKDEV(gip_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(gip_test_class, NULL,
+				 MKDEV(gip_test_major, minor), NULL,
+				 "giptest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_qrk_gip_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(gip_test_dev.cdev.dev);
+
+	device_destroy(gip_test_class, MKDEV(gip_test_major, minor));
+	cdev_del(&gip_test_dev.cdev);
+
+	class_destroy(gip_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_gip_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_qrk_gip_test_remove,
+};
+
+/**
+ * intel_qrk_gip_test_init
+ *
+ * Load module.
+ */
+static int __init intel_qrk_gip_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	gip_test_class = class_create(THIS_MODULE,"qrk_gip_test");
+	if (IS_ERR(gip_test_class)) {
+		retval = PTR_ERR(gip_test_class);
+		printk(KERN_ERR "gip_test: can't register gip_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "gip_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	gip_test_major = MAJOR(dev);
+
+	memset(&gip_test_dev, 0x00, sizeof(gip_test_dev));
+	gip_test_dev.pldev = platform_create_bundle(
+		&intel_qrk_gip_test_driver, intel_qrk_gip_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(gip_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(gip_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(gip_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_qrk_gip_test_exit(void)
+{
+	platform_device_unregister(gip_test_dev.pldev);
+	platform_driver_unregister(&intel_qrk_gip_test_driver);
+}
+
+module_init(intel_qrk_gip_test_init);
+module_exit(intel_qrk_gip_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Quark GIP test module");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/mfd/lpc_sch.c b/drivers/mfd/lpc_sch.c
index d9a230d..2f6b00d 100644
--- a/drivers/mfd/lpc_sch.c
+++ b/drivers/mfd/lpc_sch.c
@@ -97,7 +97,7 @@ static struct mfd_cell tunnelcreek_cells[] = {
 static DEFINE_PCI_DEVICE_TABLE(lpc_sch_ids) = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SCH_LPC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ITC_LPC) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CLANTON_ILB) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_QUARK_ILB) },
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, lpc_sch_ids);
@@ -111,8 +111,8 @@ static int __devinit lpc_sch_probe(struct pci_dev *dev,
 	int i;
 	int ret;
 
-	/* Clanton does not support iLB SMBUS */
-	if (id->device != PCI_DEVICE_ID_INTEL_CLANTON_ILB) {
+	/* Quark does not support iLB SMBUS */
+	if (id->device != PCI_DEVICE_ID_INTEL_QUARK_ILB) {
 		pci_read_config_dword(dev, SMBASE, &base_addr_cfg);
 		if (!(base_addr_cfg & (1 << 31))) {
 			dev_err(&dev->dev, "Decode of the SMBus I/O range disabled\n");
@@ -151,7 +151,7 @@ static int __devinit lpc_sch_probe(struct pci_dev *dev,
 		goto out_dev;
 
 	/* Add RCBA SPI device */
-	if (id->device == PCI_DEVICE_ID_INTEL_CLANTON_ILB) {
+	if (id->device == PCI_DEVICE_ID_INTEL_QUARK_ILB) {
 		pci_read_config_dword(dev, LPC_BIOS_CNTL, &bios_cntl);
 		pr_info("%s BIOS_CNTL 0x%08x\n", __func__, bios_cntl);
 
diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c
index 7ccb948..f965687 100644
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@ -161,7 +161,7 @@ static const struct sdhci_pci_fixes sdhci_cafe = {
 			  SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
 };
 
-static const struct sdhci_pci_fixes sdhci_intel_cln = {
+static const struct sdhci_pci_fixes sdhci_intel_qrk = {
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
 
@@ -780,10 +780,10 @@ static const struct pci_device_id pci_ids[] __devinitdata = {
 
 	{
 		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_CLN_SD,
+		.device		= PCI_DEVICE_ID_INTEL_QRK_SD,
 		.subvendor	= PCI_ANY_ID,
 		.subdevice	= PCI_ANY_ID,
-		.driver_data	= (kernel_ulong_t)&sdhci_intel_cln,
+		.driver_data	= (kernel_ulong_t)&sdhci_intel_qrk,
 	},
 
 	{
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 137dbe9..1e40d56 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -151,8 +151,8 @@ config MTD_MTDRAM
 	  provide storage.  You probably want to say 'N' unless you're
 	  testing stuff.
 
-config MTD_MTD_CLN_ROM
-	bool "Simple R/O drive for SPI flash in Clanton x86 legacy block"
+config MTD_MTD_QRK_ROM
+	bool "Simple R/O drive for SPI flash in Quark x86 legacy block"
 	help
 	  Driver to enable reading directly from legacy block SPI /sketch part
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 4e10f27..c959209 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -62,7 +62,7 @@ config STMMAC_PTP
 	select PTP_1588_CLOCK
 	---help---
 	  Say Y here if you want support for 1588 Timestamping with a
-	  Clanton device, using the PTP 1588 Clock support. This is
+	  Quark device, using the PTP 1588 Clock support. This is
 	  required to enable timestamping support for the device.
 
 	  If unsure, say N.
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index e532aa5..cb289f7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -29,7 +29,7 @@
 *******************************************************************************/
 
 #if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-#include <asm/cln.h>
+#include <asm/qrk.h>
 #endif
 #include <linux/clk.h>
 #include <linux/kernel.h>
@@ -1550,8 +1550,8 @@ static netdev_features_t stmmac_fix_features(struct net_device *dev,
 }
 
 #if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-	#define mask_pvm(x) cln_pci_pvm_mask(x)
-	#define unmask_pvm(x) cln_pci_pvm_unmask(x)
+	#define mask_pvm(x) qrk_pci_pvm_mask(x)
+	#define unmask_pvm(x) qrk_pci_pvm_unmask(x)
 #else
 	#define mask_pvm(x)
 	#define unmask_pvm(x)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 26b3c57..47ef2b1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -25,13 +25,13 @@
 
 #include <linux/dmi.h>
 #include <linux/pci.h>
-#include <linux/platform_data/clanton.h>
+#include <linux/platform_data/quark.h>
 #include "stmmac.h"
 
 /* List of supported PCI device IDs */
 #define STMMAC_VENDOR_ID 0x700
 #define STMMAC_DEVICE_ID 0x1108
-#define STMMAC_CLANTON_ID 0x0937
+#define STMMAC_QUARK_ID 0x0937
 #define MAX_INTERFACES	 0x02
 
 #if defined (CONFIG_INTEL_QUARK_X1000_SOC)
@@ -45,13 +45,13 @@ MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
 static int bus_id = 1;
 static char stmmac_mac_data[MAX_INTERFACES][ETH_ALEN];
 
-struct stmmac_cln_mac_data {
+struct stmmac_qrk_mac_data {
 	int phy_addr;
 	int bus_id;
 	const char *name;
 };
 
-static struct stmmac_cln_mac_data phy_data [] = {
+static struct stmmac_qrk_mac_data phy_data [] = {
 	{
 		.phy_addr	= -1,			/* not connected */
 		.bus_id		= 1,
@@ -123,7 +123,7 @@ static int stmmac_find_phy_addr(int mdio_bus_id)
 	if (board_name == NULL)
 		return -1;
 
-	for (; i < sizeof(phy_data)/sizeof(struct stmmac_cln_mac_data); i++){
+	for (; i < sizeof(phy_data)/sizeof(struct stmmac_qrk_mac_data); i++){
 		if ((!strcmp(phy_data[i].name, board_name)) &&
 			phy_data[i].bus_id == mdio_bus_id)
 			return phy_data[i].phy_addr;
@@ -147,7 +147,7 @@ static int stmmac_default_data(struct plat_stmmacenet_data *plat_dat,
 	if (plat_dat->dma_cfg == NULL)
 		return -ENOMEM;
 
-	if (id->device ==  STMMAC_CLANTON_ID) {
+	if (id->device ==  STMMAC_QUARK_ID) {
 
 		phy_addr = stmmac_find_phy_addr(mdio_bus_id);
 		if (phy_addr == -1)
@@ -205,7 +205,7 @@ void stmmac_pci_find_mac (struct stmmac_priv * priv, unsigned int mdio_bus_id)
 	if (priv == NULL || id >= MAX_INTERFACES)
 		return;
 
-	if (intel_cln_plat_get_mac(PLAT_DATA_MAC0+id,
+	if (intel_qrk_plat_get_mac(PLAT_DATA_MAC0+id,
 		(char*)&stmmac_mac_data[id]) == 0){
 		memcpy(priv->dev->dev_addr, &stmmac_mac_data[id], ETH_ALEN);
 	}
@@ -378,7 +378,7 @@ static int stmmac_pci_resume(struct pci_dev *pdev)
 static DEFINE_PCI_DEVICE_TABLE(stmmac_id_table) = {
 	{PCI_DEVICE(STMMAC_VENDOR_ID, STMMAC_DEVICE_ID)},
 	{PCI_DEVICE(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_MAC)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, STMMAC_CLANTON_ID)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, STMMAC_QUARK_ID)},
 	{}
 };
 
diff --git a/drivers/platform/x86/quark/Kconfig b/drivers/platform/x86/quark/Kconfig
index 2565830..0e2c722 100644
--- a/drivers/platform/x86/quark/Kconfig
+++ b/drivers/platform/x86/quark/Kconfig
@@ -1,5 +1,5 @@
-config INTEL_CLN_ESRAM
-	bool "eSRAM - embedded SRAM driver for Intel Clanton platform"
+config INTEL_QRK_ESRAM
+	bool "eSRAM - embedded SRAM driver for Intel Quark platform"
 	depends on INTEL_QUARK_X1000_SOC && PM
 	select KALLSYMS
 	select CRC16
@@ -9,15 +9,15 @@ config INTEL_CLN_ESRAM
 	  mapped into eSRAM thus providing far faster access to code/data
 	  than ordinary DRAM. Slower than cache RAM faster than DRAM.
 
-config INTEL_CLN_ECC_REFRESH_PERIOD
+config INTEL_QRK_ECC_REFRESH_PERIOD
 	int "Choose eSRAM ECC coverage period"
-	depends on INTEL_CLN_ESRAM
+	depends on INTEL_QRK_ESRAM
 	default 24
 	help
 	  Select the period over which *RAM ECC codes should be refreshed.
 	  IA Core will periodically enable disabled eSRAM pages to ensure all of
 	  disabled eSRAM pages are 'address walked' in this period. A logical
-	  component within the silicon on Clanton will ensure DRAM (and
+	  component within the silicon on Quark will ensure DRAM (and
 	  overlayed eSRAM) pages by extension are similarly updated over the
 	  same period. This variable controlls how long a time this address
 	  walking algorithm should take. For a noisy environment like a
@@ -26,16 +26,16 @@ config INTEL_CLN_ECC_REFRESH_PERIOD
 	  most people. Set to zero to disable - this is NOT recommended. Max 48
 	  hours.
 
-config INTEL_CLN_THERMAL
-	tristate "Thermal driver for Intel Clanton platform"
-	depends on INTEL_QUARK_X1000_SOC && THERMAL
+config INTEL_QRK_THERMAL
+	bool "Thermal driver for Intel Quark platform"
+	depends on INTEL_QUARK_X1000_SOC
 	help
-	  Say Y here to enable Clanton's Thermal driver plus the MSI's
+	  Say Y here to enable Quark's Thermal driver plus the MSI's
 	  that can be hooked from the thermal sub-system
 
-config INTEL_CLN_AUDIO_CTRL
-	tristate "Audio sub-system control driver for Intel Clanton platform"
+config INTEL_QRK_AUDIO_CTRL
+	tristate "Audio sub-system control driver for Intel Quark platform"
 	depends on INTEL_QUARK_X1000_SOC
 	help
-	  Say Y here to enable Clanton's audio control driver
+	  Say Y here to enable Quark's audio control driver
 
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index 523423b..0a03469 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -1,18 +1,14 @@
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_board_data.o
-#obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_layout_data.o
-#obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_data.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_clanton_hill.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_clanton_peak.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_cross_hill.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_kips_bay.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_plat_galileo.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_sb.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr_kernel.o
-obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram.o
-obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_cln_imr_test.o
-obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram_test.o
-#obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_smep_test.o
-#obj-$(CONFIG_INTEL_CLN_ECC_SCRUB)	+= intel_cln_ecc_scrub.o
-obj-$(CONFIG_INTEL_CLN_THERMAL)	+= intel_cln_thermal.o
-obj-$(CONFIG_INTEL_CLN_AUDIO_CTRL) += intel_cln_audio_ctrl.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_board_data.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_clanton_hill.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_clanton_peak.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_cross_hill.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_kips_bay.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_galileo.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_sb.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_kernel.o
+obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_test.o
+obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram_test.o
+obj-$(CONFIG_INTEL_QRK_THERMAL)	+= intel_qrk_thermal.o
+obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL) += intel_qrk_audio_ctrl.o
diff --git a/drivers/platform/x86/quark/intel_cln_audio_ctrl.c b/drivers/platform/x86/quark/intel_cln_audio_ctrl.c
deleted file mode 100644
index ae9f88b..0000000
--- a/drivers/platform/x86/quark/intel_cln_audio_ctrl.c
+++ /dev/null
@@ -1,514 +0,0 @@
-/*
- * Intel Clanton platform audio control driver
- *
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- *
- * The Intel Clanton Hill platform hardware design includes an audio subsystem
- * with a number of interconnected audio interfaces.  This driver enables
- * applications to choose which audio connections to enable for various
- * application use cases.  The interconnections are selectable using GPIO output
- * pins on the CPU.  This driver is also responsible for configuring a Maxim
- * 9867 audio codec, a component of this audio subsystem, connected to the CPU
- * via I2C.
- */
-
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/types.h>
-#include <linux/err.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <linux/ioctl.h>
-#include <linux/mutex.h>
-#include <linux/sysfs.h>
-
-#include "intel_cln_audio_ctrl.h"
-
-#define DRIVER_NAME			"intel_cln_audio_ctrl"
-
-/*
- * GPIO numbers to use for switching audio paths
- */
-#define GPIO_AUDIO_S0   11
-#define GPIO_AUDIO_S1   12
-#define GPIO_AUDIO_S2   13
-
-#define GPIO_AUDIO_DEFAULT (INTEL_CLN_AUDIO_MODE_SPKR_MIC)
-
-/**
- * struct intel_cln_audio_ctrl_data
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_audio_ctrl_priv {
-
-	/* i2c device descriptor for read/write access to MAX9867 registers */
-	struct i2c_client *max9867_i2c;
-
-	/* Char dev to provide user-space ioctl interface for audio control */
-	struct cdev cdev;
-	dev_t cdev_no;
-	struct class *cl;
-
-	/* Mutex to protect against concurrent access to the ioctl() handler */
-	struct mutex lock;
-
-	/* Current GPIO switch value */
-	unsigned char gpio_val;
-};
-
-static int
-intel_cln_audio_ctrl_open(struct inode *inode, struct file *filp)
-{
-	struct intel_cln_audio_ctrl_priv *priv;
-
-	priv = container_of(inode->i_cdev,
-			    struct intel_cln_audio_ctrl_priv,
-			    cdev);
-	filp->private_data = priv;
-
-	return 0;
-}
-
-static int
-intel_cln_audio_ctrl_release(struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-/*
- * Logic truth table for AUDIO_S[0-3] outputs, illustrating which paths are
- * connected between audio interfaces A, B, C.  Each audio interface has one
- * effective input (I) port and one effective output (O) port
- *
- * A = USB Codec (to Clanton CPU)
- * B = Spkr/Mic  (to car audio system)
- * C = I2S Codec (to Telit HE910)
- *
- * PATH examples:
- *   AO-CO: A-Output connected to C-Output
- *   BI-AI: B-Input connected to A-Input
- *
- * NOTE: Assume a CI-AI connection is available in ALL cases (sometimes unused)
- *
- * S2 S1 S0  PATHS             USE CASE
- * -- -- --  ----------------- -------------------------------------------------
- *  0  0  0  AO-CO             BT Headset call
- *  0  0  1  AO-BO             Analog Driver Alerts (CI unused)
- *  0  1  0  AO-CO,BI-AI       XX Unused/invalid (BI *and* CI connected to AI)
- *  0  1  1  AO-BO,BI-AI       Archival Voice Record/Playback (or Driver Alerts)
- *  1  0  0  AO-CO,BI-CO       XX Unused/invalid (A0 *and* BI connected to CO)
- *  1  0  1  AO-BO,BI-CO       Analog hands-free call
- *  1  1  0  AO-CO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
- *  1  1  1  AO-BO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
- *
- *
- * Mapping to IOCTLs (using more intuitive naming on the API):
- *
- * PATHS           IOCTL
- * --------------- -------------------------------------------------------------
- * AO-CO           INTEL_CLN_AUDIO_MODE_GSM_ONLY
- * AO-BO           INTEL_CLN_AUDIO_MODE_SPKR_ONLY
- * AO-BO,BI-AI     INTEL_CLN_AUDIO_MODE_SPKR_MIC
- * AO-BO,BI-CO     INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC
- */
-
-static int
-intel_cln_audio_ctrl_gpio_update(struct intel_cln_audio_ctrl_priv *priv)
-{
-	int ret = 0;
-	struct gpio audio_sw_gpios[] = {
-		{
-			GPIO_AUDIO_S2,
-			GPIOF_OUT_INIT_LOW,
-			"audio_s2"
-		},
-		{
-			GPIO_AUDIO_S1,
-			GPIOF_OUT_INIT_LOW,
-			"audio_s1"
-		},
-		{
-			GPIO_AUDIO_S0,
-			GPIOF_OUT_INIT_LOW,
-			"audio_s0"
-		}
-	};
-
-	/*
-	 * Update the Audio Switch GPIO outputs according to the user selection
-	 */
-	ret = gpio_request_array(audio_sw_gpios,
-				 ARRAY_SIZE(audio_sw_gpios));
-	if (ret) {
-		pr_err("%s: Failed to allocate audio control GPIO pins\n",
-		       __func__);
-		return ret;
-	}
-
-	gpio_set_value(GPIO_AUDIO_S2, (priv->gpio_val >> 2) & 0x1);
-	gpio_set_value(GPIO_AUDIO_S1, (priv->gpio_val >> 1) & 0x1);
-	gpio_set_value(GPIO_AUDIO_S0, (priv->gpio_val >> 0) & 0x1);
-
-	gpio_free_array(audio_sw_gpios,
-			ARRAY_SIZE(audio_sw_gpios));
-
-	return 0;
-}
-
-static long
-intel_cln_audio_ctrl_ioctl(struct file *filp,
-			   unsigned int cmd,
-			   unsigned long arg)
-{
-	struct intel_cln_audio_ctrl_priv *priv = filp->private_data;
-	int ret = 0;
-
-	ret = mutex_lock_interruptible(&priv->lock);
-	if (ret)
-		return ret;
-
-	switch (cmd) {
-	case INTEL_CLN_AUDIO_MODE_IOC_GSM_ONLY:
-	case INTEL_CLN_AUDIO_MODE_IOC_SPKR_ONLY:
-	case INTEL_CLN_AUDIO_MODE_IOC_SPKR_MIC:
-	case INTEL_CLN_AUDIO_MODE_IOC_GSM_SPKR_MIC:
-		break;
-	default:
-		ret = -EINVAL;
-		goto exit;
-	}
-
-	priv->gpio_val = _IOC_NR(cmd) & 0x7;
-	ret = intel_cln_audio_ctrl_gpio_update(priv);
-exit:
-	mutex_unlock(&priv->lock);
-	return ret;
-}
-
-static const struct file_operations intel_cln_audio_ctrl_fops = {
-	.owner = THIS_MODULE,
-	.open = intel_cln_audio_ctrl_open,
-	.release = intel_cln_audio_ctrl_release,
-	.unlocked_ioctl = intel_cln_audio_ctrl_ioctl
-};
-
-static int
-intel_cln_audio_ctrl_chrdev_init(struct intel_cln_audio_ctrl_priv *priv)
-{
-	/* Register a character dev interface (with ioctls)
-	 * to allow control of the audio subsystem switch
-	 */
-	int ret;
-	struct device *dev;
-
-	ret = alloc_chrdev_region(&priv->cdev_no, 0, 1,
-				  "intel_cln_audio_ctrl");
-	if (ret) {
-		pr_err("Failed to alloc chrdev: %d", ret);
-		return ret;
-	}
-
-	cdev_init(&priv->cdev, &intel_cln_audio_ctrl_fops);
-
-	ret = cdev_add(&priv->cdev, priv->cdev_no, 1);
-	if (ret) {
-		pr_err("Failed to add cdev: %d", ret);
-		unregister_chrdev_region(priv->cdev_no, 1);
-		return ret;
-	}
-
-	priv->cl = class_create(THIS_MODULE, "char");
-	if (IS_ERR(priv->cl)) {
-		pr_err("Failed to create device class: %ld",
-		       PTR_ERR(priv->cl));
-		cdev_del(&priv->cdev);
-		unregister_chrdev_region(priv->cdev_no, 1);
-		return PTR_ERR(priv->cl);
-	}
-
-	dev = device_create(priv->cl, NULL, priv->cdev_no, NULL,
-			    "intel_cln_audio_ctrl");
-	if (IS_ERR(dev)) {
-		pr_err("Failed to create device: %ld",
-		       PTR_ERR(priv->cl));
-		class_destroy(priv->cl);
-		cdev_del(&priv->cdev);
-		unregister_chrdev_region(priv->cdev_no, 1);
-		return PTR_ERR(dev);
-	}
-
-	return 0;
-}
-
-static int
-intel_cln_audio_ctrl_chrdev_remove(struct intel_cln_audio_ctrl_priv *priv)
-{
-	device_destroy(priv->cl, priv->cdev_no);
-	class_destroy(priv->cl);
-	cdev_del(&priv->cdev);
-	unregister_chrdev_region(priv->cdev_no, 1);
-
-	return 0;
-}
-
-
-ssize_t intel_cln_audio_ctrl_sysfs_show_mode(struct device *dev,
-					     struct device_attribute *attr,
-					     char *buf)
-{
-	struct intel_cln_audio_ctrl_priv *priv = dev_get_drvdata(dev);
-	int ret;
-	char *mode;
-
-	ret = mutex_lock_interruptible(&priv->lock);
-	if (ret)
-		return ret;
-
-	switch (priv->gpio_val) {
-	case INTEL_CLN_AUDIO_MODE_GSM_ONLY:
-		mode = "gsm";
-		break;
-	case INTEL_CLN_AUDIO_MODE_SPKR_ONLY:
-		mode = "spkr";
-		break;
-	case INTEL_CLN_AUDIO_MODE_SPKR_MIC:
-		mode = "spkr_mic";
-		break;
-	case INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC:
-		mode = "gsm_spkr_mic";
-		break;
-	default:
-		ret = -EINVAL;
-		goto exit;
-	}
-
-	ret = scnprintf(buf, PAGE_SIZE, "%s\n", mode);
-
-exit:
-	mutex_unlock(&priv->lock);
-	return ret;
-}
-
-ssize_t intel_cln_audio_ctrl_sysfs_store_mode(struct device *dev,
-					      struct device_attribute *attr,
-					      const char *buf, size_t count)
-{
-	struct intel_cln_audio_ctrl_priv *priv = dev_get_drvdata(dev);
-	char mode[16];
-	unsigned char gpio_val;
-	int ret = count;
-
-	sscanf(buf, "%15s", mode);
-
-	if (!strcmp(mode, "gsm"))
-		gpio_val = INTEL_CLN_AUDIO_MODE_GSM_ONLY;
-	else if (!strcmp(mode, "spkr"))
-		gpio_val = INTEL_CLN_AUDIO_MODE_SPKR_ONLY;
-	else if (!strcmp(mode, "spkr_mic"))
-		gpio_val = INTEL_CLN_AUDIO_MODE_SPKR_MIC;
-	else if (!strcmp(mode, "gsm_spkr_mic"))
-		gpio_val = INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC;
-	else
-		return -EINVAL;
-
-	ret = mutex_lock_interruptible(&priv->lock);
-	if (ret)
-		return ret;
-
-	priv->gpio_val = gpio_val;
-	ret = intel_cln_audio_ctrl_gpio_update(priv);
-	if (ret)
-		goto exit;
-
-	ret = count;
-
-exit:
-	mutex_unlock(&priv->lock);
-
-	return ret;
-}
-
-/* Sysfs attribute descriptor (for alternative user-space interface) */
-static DEVICE_ATTR(audio_switch_mode, S_IWUSR | S_IRUGO,
-		   intel_cln_audio_ctrl_sysfs_show_mode,
-		   intel_cln_audio_ctrl_sysfs_store_mode);
-
-/******************************************************************************
- *                                Module hooks
- ******************************************************************************/
-
-static int
-intel_cln_max9867_init(struct i2c_client *client)
-{
-	int ret;
-
-	/* MAX9867 register configuration, from Telit HE910 DVI app-note */
-
-	u8 reg_cfg_seq1[] = {
-		0x04, /* Starting register address, followed by data */
-		0x00, /* 0x04 Interrupt Enable */
-		0x10, /* 0x05 System Clock */
-		0x90, /* 0x06 Audio Clock High */
-		0x00, /* 0x07 Audio Clock Low */
-		0x10, /* 0x08 Interface 1a */
-		0x0A, /* 0x09 Interface 1d */
-		0x33, /* 0x0A Codec Filters */
-		0x00, /* 0x0B DAC Gain/Sidetone */
-		0x00, /* 0x0C DAC Level */
-		0x33, /* 0x0D ADC Level */
-		0x4C, /* 0x0E Left Line Input Level */
-		0x4C, /* 0x0F Right Line Input Level */
-		0x00, /* 0x10 Left Volume Control */
-		0x00, /* 0x11 Right Volume Control */
-		0x14, /* 0x12 Left Mic Gain */
-		0x14, /* 0x13 Right Mic Gain */
-		/* Configuration */
-		0xA0, /* 0x14 Input */
-		0x00, /* 0x15 Microphone */
-		0x65  /* 0x16 Mode */
-	};
-
-	u8 reg_cfg_seq2[] = {
-		0x17, /* Starting register address, followed by data */
-		0xEF  /* 0x17 System Shutdown */
-	};
-
-	ret = i2c_master_send(client,
-			      reg_cfg_seq1, sizeof(reg_cfg_seq1));
-	if (ret != sizeof(reg_cfg_seq1)) {
-		pr_err("Failed to write MAX9867 config registers (set 1/2)");
-		return -EIO;
-	}
-
-	ret = i2c_master_send(client,
-			      reg_cfg_seq2, sizeof(reg_cfg_seq2));
-	if (ret != sizeof(reg_cfg_seq2)) {
-		pr_err("Failed to write MAX9867 config registers (set 2/2)");
-		return -EIO;
-	}
-
-	return 0;
-}
-
-static int
-intel_cln_max9867_get_chip_rev(struct i2c_client *client)
-{
-	struct i2c_msg msg[2];
-	u8 data[2];
-	int ret;
-
-	data[0] = 0xFF;  /* Chip-revision register address = 0xFF */
-	msg[0].addr = client->addr;
-	msg[0].flags = 0;
-	msg[0].buf = &data[0];
-	msg[0].len = 1;
-
-	msg[1].addr = client->addr;
-	msg[1].flags = I2C_M_RD;
-	msg[1].buf = &data[1];
-	msg[1].len = 1;
-
-	ret = i2c_transfer(client->adapter, &msg[0], 2);
-	return (ret == 2) ? data[1] : -EIO;
-}
-
-static int intel_cln_max9867_i2c_probe(struct i2c_client *client,
-				       const struct i2c_device_id *id)
-{
-	struct intel_cln_audio_ctrl_priv *priv;
-	int ret;
-
-	priv = devm_kzalloc(&client->dev, sizeof(*priv),
-			    GFP_KERNEL);
-	if (priv == NULL)
-		return -ENOMEM;
-
-	i2c_set_clientdata(client, priv);
-
-	priv->max9867_i2c = client;
-	mutex_init(&priv->lock);
-
-	ret = intel_cln_max9867_get_chip_rev(client);
-	if (ret >= 0)
-		pr_info("%s: Detected MAX9867 chip revision 0x%02X\n",
-			__func__, ret);
-	else {
-		pr_err("%s: Failed to read MAX9867 chip revision\n", __func__);
-		goto exit;
-	}
-
-	ret = intel_cln_max9867_init(client);
-	if (ret)
-		goto exit;
-
-	priv->gpio_val = GPIO_AUDIO_DEFAULT;
-	ret = intel_cln_audio_ctrl_gpio_update(priv);
-	if (ret)
-		goto exit;
-
-	/* Create a char dev interface, providing an ioctl config option */
-	ret = intel_cln_audio_ctrl_chrdev_init(priv);
-	if (ret)
-		goto exit;
-
-	/* Also create a sysfs interface, providing a cmd line config option */
-	ret = sysfs_create_file(&client->dev.kobj,
-				&dev_attr_audio_switch_mode.attr);
-
-exit:
-	return ret;
-}
-
-static int intel_cln_max9867_i2c_remove(struct i2c_client *client)
-{
-	struct intel_cln_audio_ctrl_priv *priv = i2c_get_clientdata(client);
-
-	intel_cln_audio_ctrl_chrdev_remove(priv);
-
-	sysfs_remove_file(&client->dev.kobj, &dev_attr_audio_switch_mode.attr);
-
-	return 0;
-}
-
-static const struct i2c_device_id intel_cln_max9867_i2c_id[] = {
-	{"intel-cln-max9867", 0},
-	{}
-};
-MODULE_DEVICE_TABLE(i2c, intel_cln_max9867_i2c_id);
-
-/* i2c codec control layer */
-static struct i2c_driver intel_cln_audio_ctrl_i2c_driver = {
-	.driver = {
-		.name = "intel_cln_audio_ctrl",
-		.owner = THIS_MODULE,
-	},
-	.probe = intel_cln_max9867_i2c_probe,
-	.remove =  intel_cln_max9867_i2c_remove,
-	.id_table = intel_cln_max9867_i2c_id,
-};
-
-module_i2c_driver(intel_cln_audio_ctrl_i2c_driver);
-
-MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
-MODULE_DESCRIPTION("Intel Clanton platform audio control driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/intel_cln_audio_ctrl.h b/drivers/platform/x86/quark/intel_cln_audio_ctrl.h
deleted file mode 100644
index b6c4692..0000000
--- a/drivers/platform/x86/quark/intel_cln_audio_ctrl.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Intel Clanton platform audio control driver
- *
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- *
- * See intel_cln_audio_ctrl.c for a detailed description
- *
- */
-
-#ifndef __INTEL_CLN_AUDIO_CTRL_H__
-#define __INTEL_CLN_AUDIO_CTRL_H__
-
-#include <linux/module.h>
-
-#define INTEL_CLN_AUDIO_MODE_GSM_ONLY       0x0
-#define INTEL_CLN_AUDIO_MODE_SPKR_ONLY      0x1
-#define INTEL_CLN_AUDIO_MODE_SPKR_MIC       0x3
-#define INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC   0x5
-
-#define INTEL_CLN_AUDIO_MODE_IOC_GSM_ONLY \
-	_IO('x', INTEL_CLN_AUDIO_MODE_GSM_ONLY)
-#define INTEL_CLN_AUDIO_MODE_IOC_SPKR_ONLY \
-	_IO('x', INTEL_CLN_AUDIO_MODE_SPKR_ONLY)
-#define INTEL_CLN_AUDIO_MODE_IOC_SPKR_MIC \
-	_IO('x', INTEL_CLN_AUDIO_MODE_SPKR_MIC)
-#define INTEL_CLN_AUDIO_MODE_IOC_GSM_SPKR_MIC \
-	_IO('x', INTEL_CLN_AUDIO_MODE_GSM_SPKR_MIC)
-
-#endif /* __INTEL_CLN_AUDIO_CTRL_H__ */
diff --git a/drivers/platform/x86/quark/intel_cln_board_data.c b/drivers/platform/x86/quark/intel_cln_board_data.c
deleted file mode 100644
index ecbeb31..0000000
--- a/drivers/platform/x86/quark/intel_cln_board_data.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data accessor layer
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/dmi.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-
-#define DRIVER_NAME				"board_data"
-#define PFX					"MFH: "
-#define SPIFLASH_BASEADDR			0xFFF00000
-#define MFH_OFFSET				0x00008000
-#define PLATFORM_DATA_OFFSET			0x00010000
-#define MTD_PART_OFFSET				0x00050000
-#define MTD_PART_LEN				0x00040000
-#define MFH_PADDING				0x1E8
-#define MFH_MAGIC				0x5F4D4648
-#define FLASH_SIZE				(PLATFORM_DATA_OFFSET + 0x1000)
-
-/* MFH types supported @ version #1 */
-#define MFH_ITEM_FW_STAGE1			0x00000000
-#define MFH_ITEM_FW_STAGE1_SIGNED		0x00000001
-#define MFH_ITEM_FW_STAGE2			0x00000003
-#define MFH_ITEM_FW_STAGE2_SIGNED		0x00000004
-#define MFH_ITEM_FW_STAGE2_CONFIG		0x00000005
-#define MFH_ITEM_FW_STAGE2_CONFIG_SIGNED	0x00000006
-#define MFH_ITEM_FW_PARAMS			0x00000007
-#define MFH_ITEM_FW_RECOVERY			0x00000008
-#define MFH_ITEM_FW_RECOVERY_SIGNED		0x00000009
-#define MFH_ITEM_BOOTLOADER			0x0000000B
-#define MFH_ITEM_BOOTLOADER_SIGNED		0x0000000C
-#define MFH_ITEM_BOOTLOADER_CONFIG		0x0000000D
-#define MFH_ITEM_BOOTLOADER_CONFIG_SIGNED	0x0000000E
-#define MFH_ITEM_KERNEL				0x00000010
-#define MFH_ITEM_KERNEL_SIGNED			0x00000011
-#define MFH_ITEM_RAMDISK			0x00000012
-#define MFH_ITEM_RAMDISK_SIGNED			0x00000013
-#define MFH_ITEM_LOADABLE_PROGRAM		0x00000015
-#define MFH_ITEM_LOADABLE_PROGRAM_SIGNED	0x00000016
-#define MFH_ITEM_BUILD_INFO			0x00000018
-#define MFH_ITEM_VERSION			0x00000019
-
-struct intel_cln_mfh {
-	u32	id;
-	u32	ver;
-	u32	flags;
-	u32	next_block;
-	u32	item_count;
-	u32	boot_priority_list;
-	u8	padding[MFH_PADDING];
-};
-
-struct intel_cln_mfh_item {
-	u32	type;
-	u32	addr;
-	u32	len;
-	u32	res0;
-};
-
-struct kobject * board_data_kobj;
-EXPORT_SYMBOL_GPL(board_data_kobj);
-
-static long unsigned int flash_version_data;
-static ssize_t flash_version_show(struct kobject *kobj,
-                                struct kobj_attribute *attr, char *buf)
-{
-        return snprintf(buf, 12, "%#010lx\n", flash_version_data);
-}
-
-static struct kobj_attribute flash_version_attr =
-        __ATTR(flash_version, 0644, flash_version_show, NULL);
-
-extern int intel_cln_plat_probe(struct resource * pres);
-
-#define DEFAULT_BOARD "Galileo"
-
-static struct platform_device bsp_data [] = {
-	{
-		.name	= "QuarkEmulation",
-		.id	= -1,
-	},
-	{
-		.name	= "ClantonPeakSVP",
-		.id	= -1,
-	},
-	{
-		.name	= "KipsBay",
-		.id	= -1,
-	},
-	{
-		.name	= "CrossHill",
-		.id	= -1,
-	},
-	{
-		.name	= "ClantonHill",
-		.id	= -1,
-	},
-	{
-		.name	= "Galileo",
-		.id	= -1,
-	},
-
-};
-
-/**
- * add_firmware_sysfs_entry
- *
- * Add an entry in sysfs consistent with Galileo IDE's expected location
- * covers current software versions and legacy code < Intel Galileo BIOS 0.9.0
- *
- */
-static int add_firmware_sysfs_entry(const char * board_name)
-{
-	pr_info("Intel Quark Board %s Firmware Version %#010lx\n",
-				board_name, flash_version_data);
-
-	/* board_data_kobj subordinate of firmware @ /sys/firmware/board_data */
-	board_data_kobj = kobject_create_and_add("board_data", firmware_kobj);
-	if (!board_data_kobj) {
-		pr_err(PFX"kset create error\n");
-		return -ENODEV;
-	}
-	return sysfs_create_file(board_data_kobj, &flash_version_attr.attr);
-}
-
-/**
- * intel_cln_board_data_init_legacy
- *
- * Module entry point for older BIOS versions
- * Allows more recent kernels to boot on Galileo boards with BIOS before release
- * 0.9.0
- */
-static int __init intel_cln_board_data_init_legacy(void)
-{
-	extern struct kobject * firmware_kobj;
-	struct intel_cln_mfh __iomem * mfh;
-	struct intel_cln_mfh_item __iomem * item;
-	struct platform_device * pdev;
-	u32 i;
-	char * board_name = NULL;
-	void __iomem * spi_data;
-	int ret = 0;
-
-	spi_data = ioremap(SPIFLASH_BASEADDR, FLASH_SIZE);
-	if (!spi_data)
-		return -ENODEV;
-
-	/* get mfh and first item pointer */	
-	mfh = spi_data + MFH_OFFSET;
-	if (mfh->id != MFH_MAGIC){
-		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
-		MFH_MAGIC, mfh->id, &mfh->id);
-		return -ENODEV;
-	}
-
-	pr_info(PFX"Booting on an old BIOS assuming %s board\n", DEFAULT_BOARD);
-	pr_info(PFX"mfh @ 0x%p: id 0x%08lx ver 0x%08lx entries 0x%08lx\n",
-		mfh, (unsigned long)mfh->id, (unsigned long)mfh->ver,
-		(unsigned long)mfh->item_count);
-	item = (struct intel_cln_mfh_item __iomem *)
-		&mfh->padding [sizeof(u32) * mfh->boot_priority_list];
-
-	/* Register a default board */
-	for (i = 0; i < sizeof(bsp_data)/sizeof(struct platform_device); i++){
-		if (!strcmp(bsp_data[i].name, DEFAULT_BOARD)){
-			board_name = (char*)bsp_data[i].name;
-			platform_device_register(&bsp_data[i]);
-		}
-	}
-
-	/* Register flash regions as seperate platform devices */
-	for (i = 0; i < mfh->item_count; i++, item++){
-		pdev = NULL;
-
-		switch (item->type){
-		case MFH_ITEM_VERSION:
-			flash_version_data = item->res0;
-			ret = add_firmware_sysfs_entry(board_name);
-			break;
-		default:
-			break;
-		}
-	}
-	iounmap(spi_data);
-	return ret;
-}
-
-/**
- * intel_cln_board_data_init_legacy
- *
- * Module entry point for older BIOS versions
- */
-static int __init intel_cln_board_data_init(void)
-{
-	bool found = false;
-	const char * bios_version = dmi_get_system_info(DMI_BIOS_VERSION);
-	const char * board_name = dmi_get_system_info(DMI_BOARD_NAME);
-	extern struct kobject * firmware_kobj;
-	int ret = 0;
-	u32 i;
-
-	/* BIOS later than version 0.9.0 contains the right DMI data */
-	for (i = 0; board_name != NULL && bios_version != NULL && 
-		i < sizeof(bsp_data)/sizeof(struct platform_device); i++){
-	
-		if (!strcmp(bsp_data[i].name, board_name)){
-
-			/* Register board */
-			platform_device_register(&bsp_data[i]);
-			found = true;
-
-			/* Galileo IDE expects this entry */
-			flash_version_data = simple_strtoul(bios_version, NULL, 16);
-			ret = add_firmware_sysfs_entry(bsp_data[i].name);
-
-			break;
-		}
-	}
-
-	/* For older BIOS without DMI data we read the data directly from flash */
-	if (found == false){
-		ret = intel_cln_board_data_init_legacy();
-	}
-
-	return ret;
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SPI Data API");
-MODULE_LICENSE("Dual BSD/GPL");
-subsys_initcall(intel_cln_board_data_init);
-
diff --git a/drivers/platform/x86/quark/intel_cln_ecc_scrub.c b/drivers/platform/x86/quark/intel_cln_ecc_scrub.c
deleted file mode 100644
index 1fb46f6..0000000
--- a/drivers/platform/x86/quark/intel_cln_ecc_scrub.c
+++ /dev/null
@@ -1,668 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton DRAM ECC Scrub driver
- *
- * !!!!!!! Description
- *
- */
-#include <asm-generic/uaccess.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/proc_fs.h>
-
-#define DRIVER_NAME			"intel-cln-ecc"
-#define INTEL_CLN_ECC_SCRUB_PROCDIR	"driver/ecc_scrub"
-#define STATUS				"status"
-#define CONTROL				"control"
-#define INTERVAL			"interval"
-#define ECC_BLOCK_SIZE			"block_size"
-
-#define CONTROL_USAGE		"ECC Scrub Control: invalid setting. "\
-				"Valid values are 1 or 0\n"
-#define CONTROL_SCRUB_ON_STR	"1\n"
-#define CONTROL_SCRUB_OFF_STR	"0\n"
-#define CONTROL_ON_STR		"on\n"
-#define CONTROL_OFF_STR		"off\n"
-
-#define INTERVAL_USAGE		"ECC Scrub Interval: invalid setting. "\
-				"Valid range is 1 - 255\n"
-#define SIZE_USAGE		"ECC Scrub Block Size: invalid setting. "\
-				"Valid range is 64 - 512\n"
-
-#define OVERRIDE_CONFIG_PARM_DESC	"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Config"
-
-#define OVERRIDE_START_PARM_DESC	"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Start address"
-
-#define OVERRIDE_END_PARM_DESC		"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub End address"
-
-#define OVERRIDE_NEXT_PARM_DESC		"Clanton ECC Scrub - "\
-					"Override BIOS settings "\
-					"for Scrub Next address"
-
-#define MAX_SCRUB_BLOCK_SIZE 512
-#define MIN_SCRUB_BLOCK_SIZE 64
-#define MAX_SCRUB_REFRESH 255
-#define MIN_SCRUB_REFRESH 0
-
-#define NOT_OVERRIDDEN 0xfffffffful
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-/* Register ID */
-#define ECC_SCRUB_CONFIG_REG		(0x50)
-#define ECC_SCRUB_START_MEM_REG		(0x76)
-#define ECC_SCRUB_END_MEM_REG		(0x77)
-#define ECC_SCRUB_NEXT_READ_REG		(0x7C)
-
-
-/* Reg commands */
-#define THERMAL_CTRL_READ		(0x10)
-#define THERMAL_CTRL_WRITE		(0x11)
-#define THERMAL_RESUME_SCRUB		(0xC2)
-#define THERMAL_PAUSE_SCRUB		(0xC3)
-
-/**
- * struct intel_cln_ecc_scrub_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_ecc_scrub_dev {
-
-	/* Linux kernel structures */
-	struct platform_device *pldev;		/* Platform device */
-
-	/* Register copies */
-	u32 start_address;
-	u32 end_address;
-	u32 next_address;
-	u32 config;
-
-};
-
-static struct intel_cln_ecc_scrub_dev ecc_scrub_dev;
-
-static u32 ecc_scrub_config_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_start_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_end_override = NOT_OVERRIDDEN;
-static u32 ecc_scrub_next_override = NOT_OVERRIDDEN;
-
-/**
- * intel_cln_ecc_scrub_stat_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/status
- */
-static ssize_t
-intel_cln_ecc_scrub_stat_show(struct device *dev, struct device_attribute *attr,
-			      char *buf)
-{
-	int len = 0, size = 0;
-	unsigned int count = PAGE_SIZE;
-	u32 reg_data = 0;
-	char *scrub_status = CONTROL_OFF_STR;
-
-	/* Display start of memory address */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
-		&reg_data, 1);
-	len += snprintf(buf + len, count - len,
-			"ecc scrub mem start\t\t\t: 0x%08x\n", reg_data);
-
-
-	/* Display end of memory address */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
-		&reg_data, 1);
-	len += snprintf(buf + len, count - len,
-			"ecc scrub mem end\t\t\t: 0x%08x\n", reg_data);
-
-	/* Display next address to be read */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
-		&reg_data, 1);
-	len += snprintf(buf + len, count - len,
-			"ecc scrub next read\t\t\t: 0x%08x\n", reg_data);
-
-	/* Display config settings */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-
-	/* Interval is the lsbyte of the config reg, so mask out just
-	 * that byte in the data printed. */
-	len += snprintf(buf + len, count - len,
-			"ecc scrub interval\t\t\t: %d\n",
-			(reg_data & 0x000000ff));
-
-	/* Size is indicated in bits 12:8 of register in
-	* terms of 32 byte blocks. */
-	size = ((reg_data & 0x00001f00) >> 8)*32;
-	len += snprintf(buf + len, count - len,
-			"ecc scrub block_size\t\t\t: %d\n", size);
-
-	/* Status is indicated in bit 13 of register. */
-	if ((reg_data & 0x00002000) > 0)
-		scrub_status = CONTROL_ON_STR;
-
-	len += snprintf(buf + len, count - len,
-			"ecc scrub status\t\t\t: %s\n", scrub_status);
-	return len;
-}
-
-/**
- * intel_cln_ecc_scrub_ctrl_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/control
- */
-static ssize_t
-intel_cln_ecc_scrub_ctrl_show(struct device *dev, struct device_attribute *attr,
-			      char *buf)
-{
-	unsigned int count = PAGE_SIZE;
-	u32 reg_data = 0;
-	char *on_or_off = CONTROL_SCRUB_OFF_STR;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-	&reg_data, 1);
-
-	/* Status is indicated in bit 13 of register. */
-	if ((reg_data & 0x00002000) > 0)
-		/* interval > 0 assume scrubbing on */
-		on_or_off = CONTROL_SCRUB_ON_STR;
-
-	return snprintf(buf, count,"%s", on_or_off);
-}
-
-/**
- * intel_cln_ecc_scrub_ctrl_store
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: input buffer
- * @param size: size of input data
- * @return number of bytes successfully written
- *
- * Function allows user-space to switch on/off scrubbing with a simple
- * echo 1/0 > /sys/device/platform/intel-cln-ecc/control command
- */
-static ssize_t
-intel_cln_ecc_scrub_ctrl_store(struct device *dev,
-			       struct device_attribute *attr, const char *buf,
-			       size_t count)
-{
-	ssize_t ret = 0;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	ret = -EINVAL;
-
-	/* Check for command starting with "scrub"
-	*  and ending with "on" or "off" */
-
-	if (!strcmp(buf, CONTROL_SCRUB_ON_STR)) {
-			sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB,
-			0, 0, 1);
-			ret = 0;
-	} else if (!strcmp(buf, CONTROL_SCRUB_OFF_STR)) {
-		sb_write(SB_ID_THERMAL, THERMAL_PAUSE_SCRUB, 0,
-			 0, 1);
-		ret = 0;
-	}
-
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-
-	else if (ret == -EINVAL)
-		printk(CONTROL_USAGE);
-
-	return ret;
-}
-
-/**
- * intel_cln_ecc_scrub_intrvl_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/interval
- */
-static ssize_t
-intel_cln_ecc_scrub_intrvl_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	u32 reg_data = 0;
-
-	/* Interval is the lsbyte of the config reg,
-	* so mask out just that byte in the data printed. */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", (reg_data & 0x000000ff));
-}
-
-/**
- * intel_cln_ecc_scrub_intrvl_store
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: input buffer
- * @param size: size of input data
- * @return number of bytes successfully written
- *
- * Function allows user-space to set scrub interval with a value of 1-255
- * echo 1-255 > /sys/device/platform/intel-cln-ecc/interval type command
- */
-static ssize_t
-intel_cln_ecc_scrub_intrvl_store(struct device *dev,
-				 struct device_attribute *attr, const char *buf,
-				 size_t count)
-{
-	ssize_t ret = 0;
-	unsigned long val = 0;
-	u32 reg_data = 0;
-	int ret_temp = 0;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	ret = -EINVAL;
-
-	ret_temp = kstrtoul(buf, 10, &val);
-
-	if (ret_temp)
-		return ret_temp;
-
-	if (val > MIN_SCRUB_REFRESH && val <= MAX_SCRUB_REFRESH) {
-		/* Need to read-modify-write config register. */
-		sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
-			ECC_SCRUB_CONFIG_REG,
-			&reg_data, 1);
-
-		reg_data &= 0xffffff00;	/* clear lsb. */
-		reg_data |= val;		/* now set interval. */
-
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG,
-			 reg_data, 1);
-		ret = 0;
-	} else {
-		printk(INTERVAL_USAGE);
-	}
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-	return ret;
-}
-
-/**
- * intel_cln_ecc_scrub_size_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates ecc_scrub state via /sys/device/platform/intel-cln-ecc/block_size
- */
-static ssize_t
-intel_cln_ecc_scrub_size_show(struct device *dev, struct device_attribute *attr,
-			      char *buf)
-{
-	int size = 0;
-	u32 reg_data = 0;
-
-	/* Size is indicated in bits 12:8 of config register
-	 * multiply x32 to get num bytes). */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-	size = ((reg_data & 0x00001f00) >> 8)*32;
-
-	return snprintf(buf, PAGE_SIZE, "%d\n", size);
-}
-
-/**
- * intel_cln_ecc_scrub_size_store
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: input buffer
- * @param size: size of input data
- * @return number of bytes successfully written
- *
- * Function allows user-space to set scrub block size of 64-512 with a simple
- * echo 64-512 > /sys/device/platform/intel-cln-ecc/block_size command
- */
-static ssize_t
-intel_cln_ecc_scrub_size_store(struct device *dev, struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	ssize_t ret = 0;
-	unsigned long val = 0;
-	u32 reg_data = 0;
-	int ret_temp = 0;
-
-	if (count <= 1)
-		return -EINVAL;
-
-	ret = -EINVAL;
-	ret_temp = kstrtoul(buf, 10, &val);
-
-	if (ret_temp)
-		return ret_temp;
-
-	if (val >= MIN_SCRUB_BLOCK_SIZE && val <= MAX_SCRUB_BLOCK_SIZE){
-
-		/* Need to read-modify-write config register. */
-		sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
-			ECC_SCRUB_CONFIG_REG,
-			&reg_data, 1);
-
-		reg_data &= 0xfffffe0ff;	/* clear bits 12:8 */
-		reg_data |= (val/32)<<8;	/* now set size */
-
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG, reg_data, 1);
-		ret = 0;
-	} else {
-		printk(SIZE_USAGE);
-	}
-
-	if (ret == 0)
-		ret = (ssize_t)count;
-
-	return ret;
-}
-
-static struct device_attribute dev_attr_status = {
-	.attr = {
-		.name = "status",
-		.mode = 0444,
-		},
-	.show = intel_cln_ecc_scrub_stat_show,
-};
-
-static struct device_attribute dev_attr_control = {
-	.attr = {
-		.name = "control",
-		.mode = 0644,
-		},
-	.show = intel_cln_ecc_scrub_ctrl_show,
-	.store = intel_cln_ecc_scrub_ctrl_store,
-};
-
-static struct device_attribute dev_attr_intrvl = {
-	.attr = {
-		.name = "interval",
-		.mode = 0644,
-		},
-	.show = intel_cln_ecc_scrub_intrvl_show,
-	.store = intel_cln_ecc_scrub_intrvl_store,
-};
-
-static struct device_attribute dev_attr_block_size = {
-	.attr = {
-		.name = "block_size",
-		.mode = 0644,
-		},
-	.show = intel_cln_ecc_scrub_size_show,
-	.store = intel_cln_ecc_scrub_size_store,
-};
-
-static struct attribute *platform_attributes[] = {
-	&dev_attr_status.attr,
-	&dev_attr_control.attr,
-	&dev_attr_intrvl.attr,
-	&dev_attr_block_size.attr,
-	NULL,
-};
-
-static struct attribute_group ecc_attrib_group = {
-	.attrs = platform_attributes
-};
-
-/*****************************************************************************
- *                        Module/PowerManagement hooks
- *****************************************************************************/
-/**
- * intel_cln_ecc_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- */
-static int intel_cln_ecc_scrub_probe(struct platform_device *pdev)
-{
-	int value_overridden = 0;
-
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-	u32 scrubber_refresh = 0;
-	u32 scrubber_block_size = 0;
-	u32 config_settings = 0;
-#endif
-
-	memset(&ecc_scrub_dev, 0x00, sizeof(ecc_scrub_dev));
-
-	/* Update config settings, if directed so to do */
-	if (ecc_scrub_start_override != NOT_OVERRIDDEN) {
-		/* start of memory address */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_START_MEM_REG, ecc_scrub_start_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_end_override != NOT_OVERRIDDEN) {
-		/* end of memory address */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_END_MEM_REG, ecc_scrub_end_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_next_override != NOT_OVERRIDDEN) {
-		/* next address to be read */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_NEXT_READ_REG, ecc_scrub_next_override, 1);
-
-			value_overridden = 1;
-	}
-	if (ecc_scrub_config_override != NOT_OVERRIDDEN) {
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG, ecc_scrub_config_override, 1);
-
-			value_overridden = 1;
-	}
-
-	/* Config Reg can be updated by either command line or kconfig setting
-	 * in the case where we have both the command line takes precedence.*/
-
-	else {
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
-		scrubber_refresh = CONFIG_INTEL_CLN_HW_ECC_REFRESH_RATE;
-		scrubber_block_size = CONFIG_INTEL_CLN_HW_ECC_REFRESH_SIZE;
-
-		if (scrubber_block_size > MAX_SCRUB_BLOCK_SIZE)
-			scrubber_block_size = MAX_SCRUB_BLOCK_SIZE;
-
-		else if (scrubber_block_size < MIN_SCRUB_BLOCK_SIZE)
-			scrubber_block_size = MIN_SCRUB_BLOCK_SIZE;
-
-		if (scrubber_refresh > MAX_SCRUB_REFRESH)
-			scrubber_refresh = MAX_SCRUB_REFRESH;
-
-
-		/* adjust block size to multiples of 32 -
-		 * as that is what the register setting actually expects. */
-		config_settings = scrubber_block_size/32;
-		config_settings <<= 8;
-		config_settings += scrubber_refresh;
-
-		/* config settings */
-		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
-			 ECC_SCRUB_CONFIG_REG, config_settings, 1);
-
-		value_overridden = 1;
-#endif
-	}
-
-	if (value_overridden)
-		sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
-
-	return sysfs_create_group(&pdev->dev.kobj, &ecc_attrib_group);
-}
-
-/**
- * intel_cln_ecc_scrub_suspend
- *
- * @param pdev: Platform device structure (unused)
- * @return 0 success < 0 failure
- *
- */
-static int intel_cln_ecc_scrub_suspend(struct device *pdev)
-{
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
-	u32 reg_data = 0;
-
-	/* Store off the 4 registers associated with scrubbing. */
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.start_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.end_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.next_address = reg_data;
-
-	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
-		&reg_data, 1);
-	ecc_scrub_dev.config = reg_data;
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_ecc_scrub_resume
- *
- * @param pdev: Platform device structure (unused)
- * @return 0 success < 0 failure
- */
-static int intel_cln_ecc_scrub_resume(struct device *pdev)
-{
-#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_START_MEM_REG,
-		 ecc_scrub_dev.start_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_END_MEM_REG,
-		 ecc_scrub_dev.end_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_NEXT_READ_REG,
-		 ecc_scrub_dev.next_address, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_CONFIG_REG,
-		 ecc_scrub_dev.config, 1);
-
-	sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
-
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_ecc_scrub_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_ecc_scrub_remove(struct platform_device *pdev)
-{
-	return sysfs_create_group(&pdev->dev.kobj, &ecc_attrib_group);
-}
-
-/*
- * Power management operations
- */
-static const struct dev_pm_ops intel_cln_ecc_scrub_pm_ops = {
-	.suspend = intel_cln_ecc_scrub_suspend,
-	.resume = intel_cln_ecc_scrub_resume,
-};
-
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_ecc_scrub_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-		.pm = &intel_cln_ecc_scrub_pm_ops,
-	},
-	.probe = intel_cln_ecc_scrub_probe,
-	.remove = intel_cln_ecc_scrub_remove,
-};
-
-
-MODULE_AUTHOR("Derek Harnett <derek.harnett@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton DRAM ECC-scrub driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_param(ecc_scrub_config_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_config_override, OVERRIDE_CONFIG_PARM_DESC);
-
-module_param(ecc_scrub_start_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_start_override, OVERRIDE_START_PARM_DESC);
-
-module_param(ecc_scrub_end_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_end_override, OVERRIDE_END_PARM_DESC);
-
-module_param(ecc_scrub_next_override, uint, 0644);
-MODULE_PARM_DESC(ecc_scrub_next_override, OVERRIDE_NEXT_PARM_DESC);
-
-module_platform_driver(intel_cln_ecc_scrub_driver);
-
diff --git a/drivers/platform/x86/quark/intel_cln_esram.c b/drivers/platform/x86/quark/intel_cln_esram.c
deleted file mode 100644
index 76d2024..0000000
--- a/drivers/platform/x86/quark/intel_cln_esram.c
+++ /dev/null
@@ -1,1144 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton eSRAM overlay driver
- *
- * eSRAM is an on-chip fast access SRAM.
- *
- * This driver provides the ability to map a kallsyms derived symbol of
- * arbitrary length or a struct page entitiy.
- * A sysfs interface is provided to allow map of kernel structures, without
- * having to use the API from your code directly.
- *
- * Example:
- * echo idt_table > /sys/devices/intel-cln-esram.0/map
- *
- * An API is provided to allow for mapping of a) kernel symbols or b) pages.
- * eSRAM requires 4k physically aligned addresses to work - so a struct page
- * fits neatly into this.
- *
- * intel_cln_esram_map_sym(ohci_irq);
- * intel_cln_esram_map_page(virt_to_page(ohci_irq), "ohci_irq");
- * Are equivalent - with the exception that map_sym() can detect if a mapping
- * crosses a page-boundary, whereas map_page just maps one page. Generally use
- * map_sym() for code and map_page() for data
- *
- * To populte eSRAM we must copy data to a temporary buffer, overlay and
- * then copy data back to the eSRAM region.
- * 
- * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
- * to S0 we must repopulate eSRAM
- * Unmap code is included for reference however the cache coherency of unmap is
- * not guaranteed so the functionality is not exported by this code
- * 
- */
-#include <asm/cacheflush.h>
-#include <asm/desc.h>
-#include <asm/io.h>
-#include <asm/pgtable.h>
-#include <asm/special_insns.h>
-#include <asm-generic/uaccess.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kallsyms.h>
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/seq_file.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/timer.h>
-
-#include "intel_cln_esram.h"
-
-#define DRIVER_NAME			"intel-cln-esram"
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-/* Define size of pages, ECC scrub demark etc */
-#define MAX_PAGE_RETRIES		(100)
-#define MS_PER_HOUR			(3600000UL)
-#define ESRAM_PAGE_COUNT		INTEL_CLN_ESRAM_PAGE_COUNT
-#define ESRAM_PAGE_MASK			(0xFFFFF000)
-#define ESRAM_PAGE_SIZE			INTEL_CLN_ESRAM_PAGE_SIZE
-#define ESRAM_TOTAL_SIZE		(ESRAM_PAGE_COUNT * ESRAM_PAGE_SIZE)
-#define ECC_MAX_REFRESH_PERIOD		(48)
-#define ECC_DEFAULT_REFRESH_PERIOD	(24)
-#define ECC_DRAM_READSIZE		(512)		/* bytes per DRAM ECC */
-#define ECC_ESRAM_READSIZE		ESRAM_PAGE_SIZE	/* bytes per SRAM ECC */
-
-/* Register ID */
-#define ESRAM_PGPOOL_REG		(0x80)		/* PGPOOL */
-#define ESRAM_CTRL_REG			(0x81)		/* ESRAMCTRL */
-#define ESRAM_PGBLOCK_REG		(0x82)		/* Global page ctrl */
-#define ESCRM_ECCCERR_REG		(0x83)		/* Correctable ECC */
-#define ESRAM_ECCUCERR_REG		(0x84)		/* Uncorrectable ECC */
-
-/* Reg commands */
-#define ESRAM_CTRL_READ			(0x10)		/* Config reg */
-#define ESRAM_CTRL_WRITE		(0x11)		/* Config reg */
-#define ESRAM_PAGE_READ			(0x12)		/* Page config read */
-#define ESRAM_PAGE_WRITE		(0x13)		/* Page config write */
-
-/* ESRAMPGPOOL reg 0x80 - r/w opcodes 0x10/0x11 */
-#define ESRAM_PGPOOL_FLUSHING(x)	((x>>18)&0x1FF)
-#define ESRAM_PGPOOL_PGBUSY(x)		((x>>9)&0x1FF)
-
-/* ESRAMCTRL reg 0x81 - r/w opcodes 0x10/0x11 */
-#define ESRAM_CTRL_FLUSHPRI(x)		((x>>25)&0x03)	/* DRAM flush priority */
-#define ESRAM_CTRL_SIZE(x)		((x>>16)&0xFF)	/* # of 4k pages */
-#define ESRAM_CTRL_ECCTHRESH(x)		((x>>8)&0xFF)	/* ECC threshold */
-#define ESRAM_CTRL_THRESHMSG_EN		(0x00000080)	/* ECC notification */
-#define ESRAM_CTRL_ISAVAIL		(0x00000010)	/* ESRAM on die ? */
-#define ESRAM_CTRL_BLOCK_MODE		(0x00000008)	/* Block mode enable */
-#define ESRAM_CTRL_GLOBAL_LOCK		(0x00000004)	/* Global lock status */
-#define ESRAM_CTRL_FLUSHDISABLE		(0x00000002)	/* Global flush/dis */
-#define ESRAM_CTRL_SECDEC		(0x00000001)	/* ECC enable bit */
-
-/* PGBLOCK reg 0x82 - opcode 0x10/0x11 */
-#define ESRAM_PGBLOCK_FLUSHEN		(0x80000000)	/* Block flush enable */
-#define ESRAM_PGBLOCK_PGFLUSH		(0x40000000)	/* Flush the block */
-#define ESRAM_PGBLOCK_DISABLE		(0x20000000)	/* Block mode disable */
-#define ESRAM_PGBLOCK_ENABLE		(0x10000000)	/* Block mode enable */
-#define ESRAM_PGBLOCK_LOCK		(0x08000000)	/* Block mode lock en */
-#define ESRAM_PGBLOCK_INIT		(0x04000000)	/* Block init in prog */
-#define ESRAM_PGBLOCK_BUSY		(0x01000000)	/* Block is enabled */
-#define ESRAM_PGBLOCK_SYSADDR(x)	(x&0x000000FF)
-
-/* ESRAMPGCTRL - opcode 0x12/0x13 */
-#define ESRAM_PAGE_FLUSH_PAGE_EN	(0x80000000)	/* S3 autoflush */
-#define ESRAM_PAGE_FLUSH		(0x40000000)	/* Flush page to DRAM */
-#define ESRAM_PAGE_DISABLE		(0x20000000)	/* page disable bit */
-#define ESRAM_PAGE_EN			(0x10000000)	/* Page enable */
-#define ESRAM_PAGE_LOCK			(0x08000000)	/* Page lock en */
-#define ESRAM_PAGE_INITIALISING		(0x04000000)	/* Init in progress */
-#define ESRAM_PAGE_BUSY			(0x01000000)	/* Page busy */
-#define ESRAM_PAGE_MAP_SHIFT		(12)		/* Shift away 12 LSBs */
-
-/* Extra */
-#define ESRAM_MAP_OP			(0x01)
-#define ESRAM_UNMAP_OP			(0x00)
-
-/**
- * struct esram_refname
- *
- * Structure to hold a linked list of names
- */
-struct esram_refname {
-	char name[KSYM_SYMBOL_LEN];	/* Name of mapping */
-	struct list_head list;
-};
-
-/**
- * struct esram_page
- *
- * Represents an eSRAM page in our linked list
- */
-struct esram_page {
-
-	struct list_head list;		/* List entry descriptor */
-	struct list_head name_list;	/* Linked list for name references */
-	u32 id;				/* Page ID */
-	u32 phys_addr;			/* Physial address of page */
-	u32 refcount;			/* Reference count */
-	u32 vaddr;			/* Virtual address of page */
-
-};
-
-/**
- * struct intel_cln_esram_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_esram_dev{
-
-	/* Linux kernel structures */
-	struct list_head page_used;	/* Used pages */
-	struct list_head page_free;	/* Free pages */
-	spinlock_t slock;		/* Spinlock */
-	struct platform_device *pldev;	/* Platform device */
-
-	/* Actual data */
-	struct esram_page * pages;
-	u8 cbuf[ESRAM_PAGE_SIZE];
-
-	/* Stats */
-	u32 page_count;			/* As reported by silicon */
-	u32 page_disable_retries;	/* Aggreate count on disable */
-	u32 page_enable_retries;	/* Aggregate spin count page enable */
-	u32 page_free_ct;		/* Free pages for mapping code section */
-};
-
-static struct intel_cln_esram_dev esram_dev;
-
-/* 
- * Kallsyms does not provide data addresses. To map important structures such as
- * the idt and gdt, we need to frig the lookup with the below. Other entities
- * can similarly be added. Note we map a page from the given address - anything
- * larger will require additional code to handle
- */
-struct esram_symex {
-	char * name;
-	void * vaddr;
-	u32 size;
-};
-
-static struct esram_symex esram_symex[] = 
-{
-	{
-		.name = "idt_table",
-		.vaddr = &idt_table,
-		.size = ESRAM_PAGE_SIZE,
-	},
-	{
-		.name = "gdt_page",
-		.vaddr = &gdt_page,
-		.size = ESRAM_PAGE_SIZE,
-	},
-};
-
-/**
- * intel_cln_esram_stat_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates eSRAM state via /sys/device/intel-cln-esram.0/stat
- */
-static ssize_t intel_cln_esram_stat_show(struct device *dev,
-					 struct device_attribute *attr,
-					 char *buf)
-
-{
-	struct esram_page * epage = NULL;
-	int len = 0;
-	unsigned int count = PAGE_SIZE, size;
-	u32 pgpool = 0, ctrl = 0, pgblock = 0;
-	char * enabled = "enabled";
-	char * disabled = "disabled";
-
-	/* Display page-pool relevant data */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGPOOL_REG, &pgpool, 1);
-	size = snprintf(buf, count,
-			"esram-pgpool\t\t\t: 0x%08x\n" 
-			"esram-pgpool.free\t\t: %u\n"
-			"esram-pgpool.flushing\t\t: %u\n",
-			pgpool,	ESRAM_PGPOOL_PGBUSY(pgpool)+1,
-			ESRAM_PGPOOL_FLUSHING(pgpool) + 1);
-	len += size;
-	count -= size;
-	
-	/* Display ctrl reg - most of this is of interest */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	size = snprintf(buf + len, count - len,
-			"esram-ctrl\t\t\t: 0x%08x\n"
-			"esram-ctrl.ecc\t\t\t: %s\n"
-			"esram-ctrl.ecc-theshold\t\t: %u\n"
-			"esram-ctrl.pages\t\t: %u\n"
-			"esram-ctrl.dram-flush-priorityi\t: %u\n",
-			ctrl, (ctrl & ESRAM_CTRL_SECDEC) ? enabled : disabled,
-			ESRAM_CTRL_ECCTHRESH(ctrl), ESRAM_CTRL_SIZE(ctrl)+1,
-			ESRAM_CTRL_FLUSHPRI(ctrl));
-	len += size;
-	count -= size;
-
-	/* Display block ctrl/stat - we should be !block mode */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &pgblock, 1);
-	size = snprintf(buf + len, count - len, "esram-block\t\t\t: 0x%08x\n",
-			pgblock);
-	len += size;
-	count -= size;
-
-	/* Print ECC status regs */
-
-	/* Print per-page info */
-	size = snprintf(buf + len, count - len, 
-			"free page\t\t\t: %u\nused page\t\t\t: %u\n"
-			"refresh  \t\t\t: %ums\npage enable retries\t\t: %u\n"
-			"page disable retries\t: %u\n",
-			esram_dev.page_free_ct, 
-			esram_dev.page_count-esram_dev.page_free_ct,
-			0,
-			esram_dev.page_enable_retries,
-			esram_dev.page_disable_retries);
-	len += size;
-	count -= size;
-
-	spin_lock(&esram_dev.slock);
-	if(!list_empty(&esram_dev.page_free)){
-
-		epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
-		size = snprintf(buf + len, count - len, 
-			"ecc next page \t\t\t: %u\n",epage->id);
-		len += size;
-		count -= size;
-
-
-	}
-	spin_unlock(&esram_dev.slock);
-
-	/* Return len indicate eof */
-	return len;
-}
-
-/**
- * intel_cln_esram_map_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- * 
- * Read back eSRAM mapped entries
- */
-static ssize_t
-intel_cln_esram_map_show(struct device *dev,struct device_attribute *attr,
-			 char *buf)
-{
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-	int len = 0, size = 0;
-	unsigned int count = PAGE_SIZE;
-
-	spin_lock(&esram_dev.slock);
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		/* Print references */
-		list_for_each_entry(refname, &epage->name_list, list){
-			size = snprintf(buf + len, count - len,
-				"%s ", refname->name);
-			len += size;
-			count -= size;
-		}
-		/* Print data */
-		size += snprintf(buf + len, count - len,
-			"\n\tPage virt 0x%08x phys 0x%08x\n"
-			"\tRefcount %u\n",
-			epage->vaddr, epage->phys_addr,
-			epage->refcount);
-		len += size;
-		count -= size;
-	}
-	spin_unlock(&esram_dev.slock);
-
-	/* Return len indicate eof */
-	return len;
-}
-
-/**
- * intel_cln_esram_map_store
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: input buffer
- * @param size: size of input data
- * @return number of bytes successfully written
- *
- * Function allows user-space to switch mappings on/off with a simple
- * echo idt_table > /sys/devices/intel-cln-esram.0/map type command
- */
-static ssize_t
-intel_cln_esram_map_store(struct device *dev, struct device_attribute *attr,
-			  const char *buf, size_t size)
-{
-	ssize_t ret = 0;
-	char * sbuf = NULL;
-	unsigned long vaddr = 0, i = 0;
-	unsigned int count = PAGE_SIZE;
-
-	if(count <= 1){
-		return -EINVAL;
-	}
-
-	/* Get input */
-	sbuf = (char*)buf;
-
-	/* Fixup entity to scrub spaces */
-	while(sbuf < (buf + count)){
-		if(*sbuf == ' ' || *sbuf == '\r' || *sbuf =='\n'){
-			*sbuf = 0;
-			break;
-		}
-		sbuf++;
-	}
-
-	/* Check to see if we are being asked to map a non-kallsyms addr */
-	for(i = 0; i < sizeof(esram_symex)/sizeof(struct esram_symex); i++){
-		if(strcmp(buf, esram_symex[i].name) == 0){
-			ret = intel_cln_esram_map_range(
-				esram_symex[i].vaddr,
-				esram_symex[i].size,
-				esram_symex[i].name);
-			goto done;
-		}
-	}
-
-	/* This path relies on kallsyms to provide name/address data */
-	vaddr = kallsyms_lookup_name(buf);
-	if(vaddr == 0)
-		goto done;
-
-	ret = intel_cln_esram_map_symbol((void*)vaddr);
-done:
-	if(ret == 0)
-		ret = (ssize_t)count;
-	return ret;
-}
-
-static struct device_attribute dev_attr_stats = {
-	.attr = {
-		.name = "stats",
-		.mode = 0444,
-		},
-	.show = intel_cln_esram_stat_show,
-};
-
-static struct device_attribute dev_attr_map = {
-	.attr = {
-		.name = "map",
-		.mode = 0644,
-		},
-	.show = intel_cln_esram_map_show,
-	.store = intel_cln_esram_map_store,
-};
-
-static struct attribute *platform_attributes[] = {
-	&dev_attr_stats.attr,
-	&dev_attr_map.attr,
-	NULL,
-};
-
-static struct attribute_group esram_attrib_group = {
-	.attrs = platform_attributes
-};
-
-/******************************************************************************
- *                                eSRAM Core
- ******************************************************************************/
-
-/**
- * intel_cln_esram_page_busy
- *
- * @param epage: Pointer to the page descriptor
- * @return boolean indicating whether or not a page is enabled
- */
-static int intel_cln_esram_page_busy(struct esram_page * epage, u8 lock)
-{
-	u32 reg = 0;
-
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, lock);
-	return (reg&(ESRAM_PAGE_BUSY | ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE));
-}
-
-/**
- * intel_cln_esram_fault
- *
- * Dump eSRAM registers and kernel panic
- * Nothing else to do at this point
- */
-void intel_cln_esram_fault(struct esram_page * epage, u32 lineno)
-{
-	u32 reg = 0, next = 0, prev = 0, prev_reg = 0;
-	u32 next_reg = 0, block = 0, ctrl = 0;
-
-	pr_err("eSRAM: fault @ %s:%d\n", __FILE__, lineno);
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, 1);
-	pr_err("read page %d state 0x%08x\n", epage->id, reg);
-	if(epage->id == 0){
-		next = 1; prev = 127;
-	}else if(epage->id == 127){
-		next = 0; prev = 126;
-	}else{
-		next = epage->id+1;
-		prev = epage->id-1;
-	}
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, next, &next_reg, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, prev, &prev_reg, 1);
-
-	/* Get state */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
-
-	pr_err("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
-	pr_err("Prev page %d state 0x%08x Next page %d state 0x%08x\n"
-		, next, next_reg, prev, prev_reg);
-	BUG();
-}
-
-
-/**
- * intel_cln_esram_page_enable
- *
- * @param epage: struct esram_page carries data to program to register
- * @param lock: Indicates whether to attain sb spinlock or not
- * 
- * Enable an eSRAM page spinning for page to become ready.
- */
-static void intel_cln_esram_page_enable(struct esram_page *epage, u8 lock)
-{
-	u32 ret = 0;
-
-	/* Fault if we try to enable a disabled page */
-	if(intel_cln_esram_page_busy(epage, lock)){
-		intel_cln_esram_fault(epage, __LINE__);
-	}
-
-	/* Program page mapping */
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id, 
-		ESRAM_PAGE_FLUSH_PAGE_EN | ESRAM_PAGE_EN | 
-			(epage->phys_addr>>ESRAM_PAGE_MAP_SHIFT), lock);
-	do {
-		/* Poll until page busy bit becomes true */
-		ret = intel_cln_esram_page_busy(epage, lock);
-
-		/* This branch should rarely if ever be true */
-		if(unlikely(ret == 0)){
-			esram_dev.page_enable_retries++;
-		}
-		
-	}while(ret == 0);
-}
-
-/**
- * intel_cln_esram_page_disable_sync
- *
- * @param epage: pointer to eSRAM page descriptor
- *
- * This function spins waiting for disable bit to clear, useful right after a
- * disable/disable-flush command. Interrupts are enabled here, sleeping is OK
- */
-static void intel_cln_esram_page_disable_sync(struct esram_page * epage)
-{
-	u32 ret = 0, retries = 0;
-	do {
-		/* Poll for busy bit clear */
-		ret = intel_cln_esram_page_busy(epage, 1);
-
-		/* This branch should rarely if ever be true */
-		if(unlikely(ret)){
-			esram_dev.page_disable_retries++;
-			retries++;
-		}
-
-		if(retries == MAX_PAGE_RETRIES){
-			intel_cln_esram_fault(epage, __LINE__);
-		}
-	}while(ret);
-}
-
-/**
- * intel_cln_esram_page_disable
- *
- * @param epage: struct esram_page carries data to program to register
- *
- * Disable the eSRAM page no flush. Interrupts are enabled here, sleeping is OK
- */
-static void intel_cln_esram_page_disable(struct esram_page *epage)
-{
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
-		ESRAM_PAGE_DISABLE, 1);
-	intel_cln_esram_page_disable_sync(epage);	
-}
-
-/**
- * intel_cln_esram_page_flush_disable
- *
- * @param epage: struct esram_page carries data to program to register
- *
- * Disable the eSRAM page - with flush. Note the architecture will block access
- * to the overlayed region until the flush has completed => irqs may be switched
- * on during this operation.
- */
-static void intel_cln_esram_page_flush_disable(struct esram_page *epage)
-{
-	
-
-	/* Do flush */
-	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
-		ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE, 1);
-
-	intel_cln_esram_page_disable_sync(epage);	
-}
-
-#if 0
-/**
- * intel_cln_esram_flush_disable_all
- *
- * Flushes and disables all enabled eSRAM pages
- */
-static void intel_cln_esram_page_flush_disable_all(void)
-{
-	struct esram_page * epage = NULL;
-	
-	spin_lock(&esram_dev.slock);
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		intel_cln_esram_page_flush_disable(epage);
-	}
-	spin_unlock(&esram_dev.slock);
-}
-#endif
-
-/**
- * intel_cln_esram_page_populate_atomic
- *
- * @param epage: Pointer to eSRAM page desciptor.
- * @return 0 placeholder, later versions may return error
- *
- * Function takes the mappings given in epage and uses the values to populate
- * an eSRAM page. The copy/enable/copy routine must be done atomically, since we
- * may be doing a memcpy() of an ISR for example.
- * For this reason we wrapper this entire call into a callback provided by 
- * side-band, which does a spin_lock_irqsave calls this function and then does
- * a spin_lock_irqrestore - thus guaranteeing atomicity of the below code and
- * respect for the locking strategy of the side-band driver
-  */
-static int intel_cln_esram_page_populate_atomic(struct esram_page * epage)
-{
-	unsigned long crz;
-
-	/* Copy away */	
-	memcpy(&esram_dev.cbuf, (void*)epage->vaddr, ESRAM_PAGE_SIZE);
-
-	/* If CR0.WP is true - flip it HSD # 4930660 */
-	crz = read_cr0();
-	if (crz & X86_CR0_WP){
-		write_cr0(crz & (~X86_CR0_WP));
-	}
-
-	/* Disable NMI */
-	outb(0x80, 0x70);
-	
-	/*  Enable page mapping */
-	intel_cln_esram_page_enable(epage, 0);
-	
-	/* Copy back - populating memory overlay */
-	memcpy((void*)epage->vaddr, &esram_dev.cbuf,  ESRAM_PAGE_SIZE);
-
-	/* Re-enable NMI */
-	outb(0x00, 0x70);
-
-	/* Restore CR0.WP if appropriate HSD # 4930660 */
-	if (crz & X86_CR0_WP){
-		write_cr0(crz);
-	}
-	return 0;
-}
-
-/**
- * intel_cln_esram_page_populate
- *
- * @param epage: Pointer to eSRAM page desciptor.
- * @return 0 on success < 0 on failure
- *
- * Populates the page. set_memory_rw/set_memory_ro require local irqs enabled.
- * intel_cln_esram_page_populate_atomic - needs irqs switched off since memory
- * can be inconsistent during the populate operation. Depopulate operations are
- * architecturally guaranteed
- */
-static int intel_cln_esram_page_populate(struct esram_page * epage)
-{
-	int flip_rw = 0, level = 0, ret = 0;
-	pte_t * pte = epage != NULL ? lookup_address(epage->vaddr, &level):NULL;
-
-	if(unlikely(pte == NULL)){
-		return -EINVAL;
-	}
-
-	/* Determine if we need to set writable */
-	flip_rw = !(pte_write(*pte));
-	
-	/* Ensure memory is r/w - do so before spin_lock_irqsave */
-	if(flip_rw){
-		ret = set_memory_rw(epage->vaddr, 1);
-		if (ret != 0){
-			pr_err("%s error during set_memory_rw = %d\n",
-				__func__, ret);
-			return ret;
-		}
-	}
-
-	/* Force ECC update @ disable only */
-	intel_cln_esram_page_enable(epage, 1);
-	intel_cln_esram_page_disable(epage);
-
-	/* Enable and populate eSRAM page using callback in sb with irqs off */
-	ret |= intel_cln_sb_runfn_lock(
-		(int (*)(void*))intel_cln_esram_page_populate_atomic,(void*)epage);
-
-	/* If we set memory writable - restore previous state */
-	if(flip_rw){
-		ret |= set_memory_ro(epage->vaddr, 1);
-		if (ret != 0){
-			pr_err("%s error during set_memory_ro = %d\n",
-				__func__, ret);
-			return ret;
-		}
-	}
-
-	return ret;
-}
-/**
- * intel_cln_esram_page_addref
- *
- * @param epage: eSRAM page descriptor
- * @param name: Name of reference to add
- * @return zero on success negative on error
- *
- */
-static int intel_cln_esram_page_addref(struct esram_page * epage, char * name)
-{
-	struct esram_refname * refname = NULL;
-	if(unlikely(epage == NULL || name == NULL)){
-		return -EINVAL;
-	}
-
-	refname = kzalloc(sizeof(struct esram_refname), GFP_KERNEL);
-	if(unlikely(refname == NULL)){
-		return -ENOMEM;
-	}
-		
-	/* Add to list */
-	strncpy(refname->name, name, sizeof(refname->name));
-	list_add(&refname->list, &epage->name_list);
-
-	/* Bump reference count */
-	epage->refcount++;
-	return 0;
-}
-
-
-/**
- * __intel_cln_esram_map_page
- *
- * @param page: Page to map
- * @param name: Name of the mapping
- * @return 0 success < 0 failure
- *
- * Overlay a vritual address rangne eeds to be aligned to a 4k address.
- * Since multiple items can live in a 4k range, it is possible when calling
- * into map_page() that a previous mapping will have already covered some or all
- * of the mapping we want. This is not an error case, if the map function finds
- * it is being asked to map a 4k range already mapped it returns 0, to indicate
- * the mapping has suceeded i.e. it's already been mapped. This is logical if
- * you think about it. In contrast being asked to unmap a region not mapped is
- * clearly an error...
- *
- */
-static int __intel_cln_esram_map_page(u32 vaddr, char * name)
-{
-	int ret = 0;	
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-
-	if(unlikely(name == NULL)){
-		return -EINVAL;
-	}
-
-	if(unlikely(esram_dev.page_free_ct == 0)){
-		return -ENOMEM;
-	}
-
-	/* Verify if we have already mapped */
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		if(epage->vaddr == vaddr){
-
-			/* Page already mapped */
-			list_for_each_entry(refname, &epage->name_list, list){
-				if(strcmp(refname->name, name)==0){
-					/* Page mapped at this name */
-					return -EINVAL;
-				}
-			}
-			/* New symbol in previous mapping */
-			return intel_cln_esram_page_addref(epage, name);
-		}
-	}
-
-	/* Enumerate eSRAM page structure */
-	epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
-	epage->phys_addr = virt_to_phys((void*)vaddr);
-	epage->vaddr = vaddr;
-	ret = intel_cln_esram_page_addref(epage, name);
-	if(unlikely(ret < 0)){
-		return ret;
-	}
-	
-	/* Populate page */
-	ret = intel_cln_esram_page_populate(epage);
-
-	/* Move to used list */
-	list_move(&epage->list, &esram_dev.page_used);
-	esram_dev.page_free_ct--;
-
-	return ret;
-}
-
-/**
- * __intel_cln_esram_unmap_page
- *
- * @param page: Page to unmap
- * @param name: Name of the mapping
- * @return 0 success < 0 failure
- *
- * Unmap a previously mapped virutal address range.
- * Must be 4k aligned
- *
- */
-static int __intel_cln_esram_unmap_page(u32 vaddr, char * name)
-{
-	u8 found = 0;
-	struct esram_page * epage = NULL;
-	struct esram_refname * refname = NULL;
-
-	/* Find physical address */
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		if(epage->vaddr == vaddr){
-			found = 1;
-			break;
-		}
-	}
-
-	/* Bail out on error */
-	if(found == 0){
-		pr_err("0x%08x not mapped\n", vaddr);
-		return -EINVAL;
-	}
-
-	/* Determine reference to delete */
-	found = 0;
-	list_for_each_entry(refname, &epage->name_list, list){
-		if(strcmp(refname->name,name)==0){
-			found = 1;
-			break;
-		}
-	}
-	if(unlikely(found == 0)){
-		pr_err("No mapping %s!\n", name);
-		return -EINVAL;
-	}
-
-	/* Remove entry decrement reference count */	
-	list_del(&refname->list);
-	kfree(refname);
-	if(--epage->refcount > 0){
-		return 0;
-	}
-
-	/* Flush and disable page */
-	intel_cln_esram_page_flush_disable(epage);
-
-	/* Move to free list tail - scrub entries come from head */
-	list_move_tail(&epage->list, &esram_dev.page_free);
-	esram_dev.page_free_ct++;
-
-	return 0;
-}
-
-/**
- *
- * __intel_cln_esram_page_op
- *
- * @param vaddr: Virtual address of symbol
- * @param size: Size/length of symbol
- * @param name: Name of mapping
- * @param map: Boolean indicates whether to map or unmap the page
- * @return 0 success < 0 failure
- *
- * This function maps/unmaps a pages/pages given at the given vaddr. If
- * the extent of the symbol @ vaddr crosses a page boundary, then we map
- * multiple pages. Other stuff inside the page, gets a performance boost 'for
- * free'. Any other data in the page that crosses the physical page boundary
- * will be partially mapped.
- */
-static int __intel_cln_esram_page_op(u32 vaddr, u32 size, char *name, u8 map)
-{
-	unsigned long offset = 0, page_offset = 0;
-	u32  pages = size/ESRAM_PAGE_SIZE + ((size%ESRAM_PAGE_SIZE) ? 1 : 0);
-	int ret = 0;
-
-	/* Compare required pages to available pages */
-	if(map == ESRAM_MAP_OP){
-		if(pages > esram_dev.page_free_ct)
-			return -ENOMEM;
-	}else{
-		if(pages > esram_dev.page_count - esram_dev.page_free_ct)
-			return -ENOMEM;
-	}
-
-	/* Align to 4k and iterate the mappings */	
-	vaddr = vaddr&ESRAM_PAGE_MASK;
-	while(size > 0){
-
-		/* Map the page */
-		spin_lock(&esram_dev.slock);
-		if(map == ESRAM_MAP_OP){
-			ret = __intel_cln_esram_map_page(vaddr, name);
-							 
-		}else{
-			ret = __intel_cln_esram_unmap_page(vaddr, name);
-		}
-		spin_unlock(&esram_dev.slock);
-		if(unlikely(ret != 0)){
-			break;
-		}
-
-		/* Calc appropriate offsets */
-		page_offset = offset_in_page(vaddr);
-		if(page_offset + size > ESRAM_PAGE_SIZE){
-
-			offset = ESRAM_PAGE_SIZE - page_offset;
-			size -= offset;
-			vaddr += ESRAM_PAGE_SIZE; 
-
-		}else{
-			size = 0;
-		}
-	}
-
-	return ret;
-}
-
-/******************************************************************************
- *                                 eSRAM API
- ******************************************************************************/
-
-/**
- * intel_cln_esram_map_range
- *
- * @param vaddr: Virtual address to start mapping (must be 4k aligned)
- * @param size: Size to map from
- * @param mapname: Mapping name
- * @return 0 success < 0 failure
- *
- * Map 4k increments at given address to eSRAM.
- */
-int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname)
-{
-	if(size == 0 || mapname == NULL || vaddr == NULL){
-		return -EINVAL;
-	}
-	return __intel_cln_esram_page_op((u32)vaddr, size, mapname, ESRAM_MAP_OP);
-}
-EXPORT_SYMBOL(intel_cln_esram_map_range);
-
-/**
- * intel_cln_esram_map_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
- * kernel text section symbol (kernel or loaded module)
- *
- * We get the size of the symbol from kallsyms. We guarantee to map the entire
- * size of the symbol - plus whatever padding is necessary to get alignment to
- * eSRAM_PAGE_SIZE 
- * Other stuff inside the mapped pages will get a performance boost 'for free'.
- * If this free boost is not what you want then 
- *
- *	1. Align to 4k
- *	2. Pad to 4k
- *	3. Call intel_cln_esram_map_range()
- */
-int intel_cln_esram_map_symbol(void * vaddr)
-{
-	long unsigned int size = 0, offset = 0;
-	char symname[KSYM_SYMBOL_LEN];
-	
-	kallsyms_lookup_size_offset((long unsigned int)vaddr, &size, &offset);
-	if(size == 0){
-		return -EINVAL;
-	}
-	sprint_symbol(symname, (u32)vaddr);
-
-	return __intel_cln_esram_page_op((u32)vaddr, size, symname, 1);
-}
-EXPORT_SYMBOL(intel_cln_esram_map_symbol);
-
-/******************************************************************************
- *                        Module/PowerManagement hooks 
- ******************************************************************************/
-
-/**
- * intel_cln_esram_suspend
- *
- * @param pdev: Platform device structure (unused)
- * @param pm: Power managment descriptor
- * @return 0 success < 0 failure
- *
- * For each enabled page - flush to DRAM and disable eSRAM page.
- * For each 4k region the architecture guarantees atomicity of flush/disable.
- * Hence any memory transactions to the affected region will stall until
- * flush/disable completes - hence interrupts are left on.
- */
-static int intel_cln_esram_suspend(struct device * pdev)
-{
-	/* Flush and disable of eSRAM pages is carried out automatically */
-	return 0;
-}
-
-/**
- * intel_cln_esram_resume
- *
- * @param pm: Power management descriptor
- * @return 0 success < 0 failure
- *
- * Runs after resume_noirq. Switches pages back to ro, if appropriate. We do
- * this here since interrupts will be on, as required by the function
- * set_memory_ro. If it were possible to set memory ro in resume_noirq we would
- * do it there instead
- */
-static int intel_cln_esram_resume(struct device * pdev)
-{
-	struct esram_page * epage = NULL;
-	int ret = 0;
-
-	list_for_each_entry(epage, &esram_dev.page_used, list){
-		ret |= intel_cln_esram_page_populate(epage);
-	}
-	
-	return ret;
-}
-
-
-/**
- * intel_cln_esram_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_esram_probe(struct platform_device * pdev)
-{
-	int ret = 0;
-	u32 block = 0, ctrl = 0, i = 0, pgstat = 0;
-
-	memset(&esram_dev, 0x00, sizeof(esram_dev));
-	INIT_LIST_HEAD(&esram_dev.page_used);
-	INIT_LIST_HEAD(&esram_dev.page_free);
-	spin_lock_init(&esram_dev.slock);
-	esram_dev.page_free_ct = 0;
-	
-	/* Ensure block mode disabled */
-	block = ESRAM_PGBLOCK_DISABLE;
-	sb_write(SB_ID_ESRAM, ESRAM_CTRL_WRITE, ESRAM_PGBLOCK_REG, block, 1);
-
-	/* Get state */
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
-	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
-
-	/* Verify state is good to go */
-	if (ctrl & ESRAM_CTRL_GLOBAL_LOCK){
-		pr_err ("eSRAM: global lock @ 0x%08x\n", ctrl);
-		return -ENODEV;
-	}
-
-	if (block & (ESRAM_PGBLOCK_LOCK | ESRAM_PGBLOCK_ENABLE)){
-		pr_err ("eSRAM: lock @ 0x%08x\n", block);
-		return -ENODEV;
-	}
-	pr_info("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
-
-	/* Calculate # of pages silicon supports */
-	esram_dev.page_count = ESRAM_CTRL_SIZE(ctrl) + 1;
-	esram_dev.page_free_ct = esram_dev.page_count;
-	pr_info("eSRAM: pages %d\n", esram_dev.page_free_ct);
-
-	if(esram_dev.page_free_ct <= 1){
-		pr_err("Too few pages reported by eSRAM sub-system\n");
-		return -ENOMEM;
-	}
-
-	/* Allocate an appropriate number of pages */
-	esram_dev.pages = kzalloc(esram_dev.page_count *
-		sizeof(struct esram_page), GFP_KERNEL);
-	if (esram_dev.pages == NULL){
-		return -ENOMEM;
-	}
-
-	/* Initialise list of free pages, explicitely disable as we go */
-	for(i = 0; i < esram_dev.page_count; i++){
-		INIT_LIST_HEAD(&esram_dev.pages[i].name_list);
-		esram_dev.pages[i].id = i;
-		
-		/* Read & verify page state */
-		sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, i, &pgstat, 1);
-		if(pgstat & (ESRAM_PAGE_BUSY | ESRAM_PAGE_LOCK)){
-			pr_err("eSRAM: page %d state 0x%08x err\n", i, pgstat);
-			ret = -ENODEV;
-			goto err;
-		}
-
-		list_add(&esram_dev.pages[i].list, &esram_dev.page_free);
-	}
-
-	ret = sysfs_create_group(&pdev->dev.kobj, &esram_attrib_group);
-	if (ret)
-		goto err;
-
-	return 0;
-err:
-	kfree(esram_dev.pages);
-	return ret;
-}
-
-/*
- * Power management operations
- */
-static const struct dev_pm_ops intel_cln_esram_pm_ops = {
-	.suspend = intel_cln_esram_suspend,
-	.resume = intel_cln_esram_resume,
-};
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_esram_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-		.pm = &intel_cln_esram_pm_ops,
-	},
-	.probe = intel_cln_esram_probe,
-};
-
-module_platform_driver(intel_cln_esram_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton eSRAM overlay/ECC-scrub driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/drivers/platform/x86/quark/intel_cln_esram.h b/drivers/platform/x86/quark/intel_cln_esram.h
deleted file mode 100644
index af6156a..0000000
--- a/drivers/platform/x86/quark/intel_cln_esram.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton eSRAM overlay driver
- *
- * eSRAM is an on-chip fast access SRAM.
- *
- * This driver provides the ability to map a kallsyms derived symbol of
- * arbitrary length or a struct page entitiy.
- * A proc interface is provided to allow map/unmap of kernel structures, without
- * having to use the API from your code directly.
- *
- * Example:
- * echo ehci_irq on > /proc/driver/esram/map
- * echo ehci_irq off > /proc/driver/esram/map
- *
- * An API is provided to allow for mapping of a) kernel symbols or b) pages.
- * eSRAM requires 4k physically aligned addresses to work - so a struct page
- * fits neatly into this.
- *
- * To populte eSRAM we must copy data to a temporary buffer, overlay and
- * then copy data back to the eSRAM region.
- * 
- * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
- * to S0 we must repopulate eSRAM
- * 
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
- */
-#ifndef __INTEL_CLN_ESRAM_H__
-#define __INTEL_CLN_ESRAM_H__
-
-#include <linux/module.h>
-
-/* Basic size of an eSRAM page */
-#define	INTEL_CLN_ESRAM_PAGE_SIZE	(0x1000)
-#define INTEL_CLN_ESRAM_PAGE_COUNT	(0x80)
-/**
- * intel_cln_esram_map_range
- *
- * @param vaddr: Virtual address to start mapping (must be 4k aligned)
- * @param size: Size to map from
- * @param mapname: Mapping name
- * @return 0 success < 0 failure
- *
- * Map 4k increments at given address to eSRAM.
- */
-int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname);
-
-/**
- * intel_cln_esram_unmap_range
- *
- * @param vaddr: The virtual address to unmap
- * @return 0 success < 0 failure
- *
- * Logical corollary of esram_map_page
- */
-int intel_cln_esram_unmap_range(void * vaddr, u32 size, char * mapname);
-
-/**
- * intel_cln_esram_map_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
- * kernel text section symbol (kernel or loaded module)
- *
- * We get the size of the symbol from kallsyms. We guarantee to map the entire
- * size of the symbol - plus whatever padding is necessary to get alignment to
- * eSRAM_PAGE_SIZE 
- * Other stuff inside the mapped pages will get a performance boost 'for free'.
- * If this free boost is not what you want then 
- *	1. Align to 4k
- *	2. Pad to 4k
- *	3. Call intel_cln_esram_map_range()
- */
-int intel_cln_esram_map_symbol(void * vaddr);
-
-/**
- * intel_cln_esram_unmap_symbol
- *
- * @param vaddr: Virtual address of the symbol
- * @return 0 success < 0 failure
- *
- * Logical corollary to intel_cln_esram_map_symbol
- * Undoes any mapping of pages starting at sym for sym's size
- */
-int intel_cln_esram_unmap_symbol(void * vaddr);
-
-#endif /* __INTEL_CLN_ESRAM_H__ */
diff --git a/drivers/platform/x86/quark/intel_cln_esram_test.c b/drivers/platform/x86/quark/intel_cln_esram_test.c
deleted file mode 100644
index 3d0573d..0000000
--- a/drivers/platform/x86/quark/intel_cln_esram_test.c
+++ /dev/null
@@ -1,602 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_esram_test.c
- *
- * Simple test module to provide test cases for ITS integration
- *
- */
-#include <linux/cdev.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/kallsyms.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#include "intel_cln_esram.h"
-#include "intel_cln_esram_test.h"
-
-#define DRIVER_NAME			"intel_cln_esram_test"
-
-/**
- * struct intel_cln_esram_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_esram_test_dev{
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-	char * pdata;
-	u32 size;
-};
-
-static struct intel_cln_esram_test_dev esram_test_dev;
-static struct class *esram_test_class;
-static DEFINE_MUTEX(esram_test_mutex);
-static int esram_test_major;
-static char * name = "testmap";
-
-/******************************************************************************
- *                                eSRAM BIST
- ******************************************************************************/
-
-static int crc_cache = 0;
-
-unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
-{
-	if (first < end)
-		return end - first;
-	else
-		return (ULLONG_MAX - first) + end;	
-}
-
-
-/**
- * intel_cln_crctest
- *
- * Do a CRC32 of the specified region. Return the time taken in jiffies
- */
-static unsigned long long intel_cln_crctest(char * pdata, u32 crcsize)
-{
-	unsigned long long j1 = 0, j2 = 0;
-	
-	rdtscll(j1);
-
-	/* Flush LMT cache to introduce cache miss to our test */
-	__asm__ __volatile__("wbinvd\n");
-	crc32(0, pdata, crcsize);
-
-	rdtscll(j2);
-
-	return tsc_delta(j1, j2);
-}
-
-#ifdef __DEBUG__
-#define bist_err(x){\
-	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
-	return x;\
-}
-#else
-#define bist_err(x){\
-	return x;\
-}
-#endif
-/**
- * intel_cln_esram_perpage_overlay
- *
- * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
- */
-int intel_cln_esram_test_perpage_overlay(void)
-{
-
-	int ret = 0;
-	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-
-	/* Basic test of full range of memory */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-
-#if 0
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_pageref_count
- *
- * Ensure page reference couting works as expected
- */
-int intel_cln_esram_test_pagref_count(void)
-{
-	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE;
-	int ret = 0;
-
-	return 0;
-	/* Map a page */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Map a second time - and verify mapping fails */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-
-#if 0
-	/* Unmap - OK */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Verify second unmap operation fails */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-#endif	
-	return 0;
-}
-
-extern uint32_t get_crc32table_le(void);
-
-/**
- * intel_cln_esram_test_contig_perfmetric
- *
- * Do a CRC16 for a contigous area of memory
- * Map contigous area and get a CRC16
- *
- * Ensure overlayed data takes less time than regular unoverlayed DRAM
- */
-int intel_cln_esram_test_contig_perfmetric(void)
-{
-	u32 crcsize = 0x60000;
-	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
-	uint32_t crc32table_le = kallsyms_lookup_name("crc32table_le");
-	int ret = 0;
-
-	if (crc32table_le == 0){
-		pr_err("%s unable to fine symbol crc32table_le\n", __func__);
-		return -ENODEV;
-	}
-
-	/* Get raw data metric */
-	crc_cache = 1;
-	crc32_fullunmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
-
-	/* Map CRC16 symbol (algorithm) + code (data) */
-	ret = intel_cln_esram_map_symbol(crc32_le);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_map_symbol((void*)crc32table_le);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Map test data */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	/* Get metric */
-	crc_cache = 1;
-	crc32_fullmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
-#if 0
-	/* Tidy up */
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_unmap_range(((void*)crc32_table),
-					  sizeof(crc32_table), name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_cln_esram_unmap_symbol(crc32);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
-	pr_info("%s mapped count %llu unmapped %llu\n",
-		__func__, crc32_fullmap, crc32_fullunmap);
-	return crc32_fullmap < crc32_fullunmap;
-}
-
-/**
- * intel_cln_esram_test_kernel_codemap
- *
- * Maps some kernel code - a data section and then calls the code contained
- * therein. Proves out the running overlayed eSRAM works
- */
-int intel_cln_esram_test_kernel_codemap(void)
-{
-#if 0
-	int ret = intel_cln_esram_map_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-	
-	/* run the mapped code */
-	msleep(1);
-
-	/* unmap */	
-	ret = intel_cln_esram_unmap_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_kernel_datamap
- *
- * Tests mapping/unmapping of a kernel data structure
- */
-int intel_cln_esram_test_kernel_datamap(void)
-{
-#if 0
-	unsigned long jtag = 0;
-	unsigned long ctrl = 0;
-
-	/* Map the interrupt descriptor table */
-	int ret = intel_cln_esram_map_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	jtag = jiffies;
-	/* Wait for jiffies to tick or timeout to occur (failure) */
-	while(jtag == jiffies){
-		ctrl++;
-	}
-
-	/* unmap */	
-	ret = intel_cln_esram_unmap_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_sub_unsub
- *
- * Subscribe and unsubscribe 100% of available eSRAM
- */
-int intel_cln_esram_test_sub_unsub(void)
-{
-	int ret = 0;
-	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE * INTEL_CLN_ESRAM_PAGE_COUNT;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-	/* Basic test of full range of memory */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-#if 0
-	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_cln_esram_test_over_sub
- *
- * Test oversubscription of eSRAM
- */
-int intel_cln_esram_test_over_sub(void)
-{
-	int ret = 0;
-	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE * (INTEL_CLN_ESRAM_PAGE_COUNT + 1);
-
-	/* Over subscribe should fail */
-	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		//intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
-		bist_err(-EFAULT);
-	}
-	return 0;
-}
-
-/*
- * File ops
- */
-static long esram_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	cmd -= CLN_ESRAM_IOCTL_BASE;
-	switch (cmd) {
-		case CLN_F_SW_APP_ESRAM_0:
-			/* Per page overlay */
-			ret = intel_cln_esram_test_perpage_overlay();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_1:
-			/* Verify page reference counting */
-			ret = intel_cln_esram_test_pagref_count();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_2:
-			/* Performance metric or overlay contig RAM */
-			ret = intel_cln_esram_test_contig_perfmetric();
-			if (ret == 1)
-				ret = 0;
-			break;
-
-		case CLN_F_SW_APP_ESRAM_3:
-			/* Verify mapping of kernel code section */
-			/* Covered by test #2 */
-			ret = 0; //intel_cln_esram_test_kernel_codemap();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_4:
-			/* Verify mapping of kernel data section (IDT) */
-			/* Covered by test #2 */
-			ret = 0; //intel_cln_esram_test_kernel_datamap();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_5:
-			/* Complete subscribe/unsubscribe eSRAM */
-			ret = intel_cln_esram_test_sub_unsub();
-			break;
-
-		case CLN_F_SW_APP_ESRAM_6:
-			/* Over subscribe eSRAM */
-			ret = intel_cln_esram_test_over_sub();
-			break;
-
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int esram_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
-		mutex_unlock(&esram_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (esram_test_dev.opened) {
-		mutex_unlock(&esram_test_dev.open_lock);
-		mutex_unlock(&esram_test_mutex);
-		return -EINVAL;
-	}
-
-	esram_test_dev.opened++;
-	mutex_unlock(&esram_test_dev.open_lock);
-	mutex_unlock(&esram_test_mutex);
-
-	return 0;
-}
-
-static int esram_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_dev.open_lock);
-	esram_test_dev.opened = 0;
-	mutex_unlock(&esram_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations esram_test_file_ops = {
-	.open = esram_test_open,
-	.release = esram_test_release,
-	.unlocked_ioctl = esram_test_ioctl,
-	.llseek = no_llseek,
-};
-
-
-/**
- * intel_cln_esram_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_esram_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	esram_test_dev.size = INTEL_CLN_ESRAM_PAGE_COUNT * INTEL_CLN_ESRAM_PAGE_SIZE;
-
-	/* Get memory */
-	esram_test_dev.pdata = kzalloc(esram_test_dev.size, GFP_KERNEL);
-	if(unlikely(esram_test_dev.pdata == NULL)){
-		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
-		return -ENOMEM;
-	}
-
-	mutex_init(&esram_test_dev.open_lock);
-	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
-	esram_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(esram_test_class, NULL,
-				 MKDEV(esram_test_major, minor), NULL,
-				 "esramtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	printk(KERN_INFO "%s/%s/%s complete OK !!\n", __FUNCTION__, __DATE__,__TIME__);
-	return 0;
-
-}
-
-/**
- * intel_cln_esram_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_esram_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
-
-	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
-	cdev_del(&esram_test_dev.cdev);
-	kfree(esram_test_dev.pdata);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_esram_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_esram_test_remove,
-};
-
-/**
- * intel_cln_esram_init
- *
- * @return 0 success < 0 failure
- *
- * Module entry point
- */
-static int __init intel_cln_esram_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	esram_test_class = class_create(THIS_MODULE,"cln_esram_test");
-	if (IS_ERR(esram_test_class)) {
-		retval = PTR_ERR(esram_test_class);
-		printk(KERN_ERR "esram_test: can't register earam_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	esram_test_major = MAJOR(dev);
-
-	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
-	esram_test_dev.pldev = platform_create_bundle(
-		&intel_cln_esram_test_driver, intel_cln_esram_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(esram_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(esram_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(esram_test_class);
-err:
-	return retval;
-}
-
-/**
- * intel_cln_esram_exit
- *
- * Module exit
- */
-static void __exit intel_cln_esram_test_exit(void)
-{
-	platform_device_unregister(esram_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_esram_test_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton eSRAM ITS driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_init(intel_cln_esram_test_init);
-module_exit(intel_cln_esram_test_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_esram_test.h b/drivers/platform/x86/quark/intel_cln_esram_test.h
deleted file mode 100644
index 98e4546..0000000
--- a/drivers/platform/x86/quark/intel_cln_esram_test.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_esram_test.h
- *
- * Define integers for ioctl operation
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
- */
-
-#ifndef __INTEL_CLN_ESRAM_TEST_H__
-#define __INTEL_CLN_ESRAM_TEST_H__
-
-#define CLN_ESRAM_IOCTL_BASE	255
-#define CLN_F_SW_APP_ESRAM_0	0x00000000
-#define CLN_F_SW_APP_ESRAM_1	0x00000001
-#define CLN_F_SW_APP_ESRAM_2	0x00000002
-#define CLN_F_SW_APP_ESRAM_3	0x00000003
-#define CLN_F_SW_APP_ESRAM_4	0x00000004
-#define CLN_F_SW_APP_ESRAM_5	0x00000005
-#define CLN_F_SW_APP_ESRAM_6	0x00000006
-#define CLN_F_SW_APP_ESRAM_7	0x00000007
-#define CLN_F_SW_APP_ESRAM_8	0x00000008
-
-#endif /* __INTEL_CLN_ESRAM_TEST_H__ */
-
diff --git a/drivers/platform/x86/quark/intel_cln_imr.c b/drivers/platform/x86/quark/intel_cln_imr.c
deleted file mode 100644
index b8259a6..0000000
--- a/drivers/platform/x86/quark/intel_cln_imr.c
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * A total number of 8 IMRs have implemented by Clanton SoC,
- * Some IMRs might be already occupied by BIOS or Linux during
- * booting time.
- *
- * A user can cat /sys/devices/platform/intel-cln-imr/status for current IMR
- * status 
- *
- * To allocate an IMR addresses must be alinged to 1k
- *
- * The IMR alloc API will locate the next available IMR slot set up
- * with input memory region, then apply the input access right masks
- *
- * The IMR can be freed with the pre-allocated memory addresses.
- */
-
-#include <asm-generic/uaccess.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/proc_fs.h>
-
-#include "intel_cln_imr.h"
-#include <asm/imr.h>
-
-#define DRIVER_NAME	"intel-cln-imr"
-
-#define IMR_READ_MASK	0x1
-#define IMR_MAX_ID	7
-
-#ifndef phys_to_virt
-#define phys_to_virt __va
-#endif
-
-/* IMR HW register address structre */
-struct cln_imr_reg_t {
-	u8  imr_xl;   /* high address register */
-	u8  imr_xh;   /* low address register */
-	u8  imr_rm;   /* read mask register */
-	u8  imr_wm;   /* write mask register */
-} cln_imr_reg_t;
-
-/**
- * struct cln_imr_addr_t
- *
- * IMR memory address structure
- */
-struct cln_imr_addr_t {
-	u32 addr_low;      /* low boundary memroy address */
-	u32 addr_high;     /* high boundary memory address */
-	u32 read_mask;     /* read access right mask */
-	u32 write_mask;    /* write access right mask */
-} cln_imr_addr_t;
-
-/**
- * struct cln_imr_pack
- *
- * local IMR pack structure
- */
-struct cln_imr_pack {
-	bool occupied;       /* IMR occupied */
-	bool locked;         /* IMR lock */
-	struct cln_imr_reg_t reg;   /* predefined imr register address */
-	struct cln_imr_addr_t addr; /* IMR address region structure */
-	unsigned char info[MAX_INFO_SIZE]; /* IMR info */
-} cln_imr_pack;
-
-
-/* Predefined HW register address */
-static struct cln_imr_reg_t imr_reg_value[] = {
-	{ IMR0L, IMR0H, IMR0RM, IMR0WM },
-	{ IMR1L, IMR1H, IMR1RM, IMR1WM },
-	{ IMR2L, IMR2H, IMR2RM, IMR2WM },
-	{ IMR3L, IMR3H, IMR3RM, IMR3WM },
-	{ IMR4L, IMR4H, IMR4RM, IMR4WM },
-	{ IMR5L, IMR5H, IMR5RM, IMR5WM },
-	{ IMR6L, IMR6H, IMR6RM, IMR6WM },
-	{ IMR7L, IMR7H, IMR7RM, IMR7WM }
-};
-
-static struct platform_device *pdev;
-
-/**
- * module parameter
- * IMR slot should repersant the available IMR region from
- * linux boot and BIOS.
- *
- * For example: imr_bit_mask = 0x10111001
- * occupied IMR: 0, 3, 4, 5, 7
- * un-occupied IMR: 1, 2, 6
- */
-static int imr_bit_mask = 0xFF;
-module_param(imr_bit_mask, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(imr_bit_mask, "IMR bit mask");
-
-/**
- * module parameter
- * if IMR lock is a nozero value, all unlocked
- * imrs will be locked regardless the usage.
- */
-static int imr_lock = 0;
-module_param(imr_lock, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(imr_lock, "switch to lock unused IMR");
-
-/* local IMR data structure */
-struct cln_imr_pack local_imr[IMR_MAXID];
-
-/**
- * intel_cln_imr_read_reg
- *
- * @param reg: register address
- * @return nothing
- *
- * return register value from input address.
- */
-static inline uint32_t intel_cln_imr_read_reg(uint8_t reg)
-{
-	uint32_t temp = 0;
-
-	intel_cln_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE, reg, &temp, 0);
-	return temp;
-}
-
-/**
- * intel_clm_imr_latch_data
- *
- * @return nothing
- *
- * Populate IMR data structure from HW.
- */
-static inline void intel_clm_imr_latch_data(void)
-{
-	int i = 0;
-
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		local_imr[i].addr.addr_low =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
-		local_imr[i].addr.addr_high =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xh);
-		local_imr[i].addr.read_mask =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_rm);
-		local_imr[i].addr.write_mask =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_wm);
-
-		if (local_imr[i].addr.addr_low & IMR_LOCK_BIT)
-			local_imr[i].locked = true;
-
-		if (local_imr[i].addr.read_mask > 0 &&
-			local_imr[i].addr.read_mask < IMR_READ_ENABLE_ALL){
-			local_imr[i].occupied = true;
-		} else {
-			local_imr[i].occupied = false;
-			memcpy(local_imr[i].info, "NOT USED", MAX_INFO_SIZE);
-		}
-	}
-}
-
-/**
- * prepare_input_addr
- *
- * @param addr: input physical memory address
- * @return formated memory address
- *
- * 1. verify input memory address alignment
- * 2. apply IMR_REG_MASK to match the format required by HW
- */
-static inline uint32_t prepare_input_addr(uint32_t addr)
-{
-	if (addr & (IMR_MEM_ALIGN - 1))
-		return 0;
-
-	addr = (addr >> 8) & IMR_REG_MASK;
-	return addr;
-}
-
-/**
- * intel_cln_imr_find_free_entry
- *
- * @return the next free imr slot
- */
-static int intel_cln_imr_find_free_entry(void)
-{
-	int i = 0;
-
-	intel_clm_imr_latch_data();
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		if ((!local_imr[i].occupied) && (!local_imr[i].locked))
-			return i;
-	}
-
-	pr_err("%s: No more free IMR available.\n", __func__);
-	return -ENOMEM;
-}
-
-/**
- * intel_cln_imr_add_entry
- *
- * @param id: imr slot id
- * @param hi: hi memory address
- * @param lo: lo memory address
- * @param read: read access mask
- * @param write: write access mask
- * @return nothing
- *
- * Setup an IMR entry
- */
-static void intel_cln_imr_add_entry(int id, uint32_t hi,
-		uint32_t lo, uint32_t read, uint32_t write, bool lock)
-{
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xl, lo, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xh, hi, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_rm, read, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_wm, write, 0);
-	if (lock) {
-		lo |= IMR_LOCK_BIT;
-		intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-					imr_reg_value[id].imr_xl, lo, 0);
-	}
-}
-
-/**
- * get_phy_addr
- * @return phy address value
- *
- * convert register format to physical address format.
- */
-static uint32_t get_phy_addr(uint32_t reg_value)
-{
-	reg_value = ((reg_value & IMR_REG_MASK) << 8);
-	return reg_value;
-}
-
-
-
-/**
- * intel_cln_imr_init_mask
- *
- * @param mask: module parameter
- * @return nothing
- *
- * prepare local IMR data structure from input module parameter.
- */
-static void intel_cln_imr_init_mask(int mask)
-{
-	int i = 0;
-
-	BUG_ON((mask > 255 || mask < 0));
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		local_imr[i].addr.addr_low =
-			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
-
-		/* mask bit 1 means imr occupied*/
-		if (((mask>>i) & IMR_READ_MASK) == 0) {
-			if (!(local_imr[i].addr.addr_low & IMR_LOCK_BIT))
-				intel_cln_remove_imr_entry(i);
-		}
-	}
-}
-
-/**
- * intel_cln_remove_imr_entry
- *
- * @param id: imr slot id
- * @return nothing
- *
- * remove imr slot based on input id
- */
-void intel_cln_remove_imr_entry(int id)
-{
-	if (id >= IMR_MAXID || local_imr[id].locked)
-		return;
-
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_rm, IMR_READ_ENABLE_ALL,
-				0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_wm, IMR_WRITE_ENABLE_ALL,
-				0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xl, IMR_BASE_ADDR, 0);
-	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-				imr_reg_value[id].imr_xh, IMR_BASE_ADDR, 0);
-
-	intel_clm_imr_latch_data();
-
-}
-EXPORT_SYMBOL(intel_cln_remove_imr_entry);
-
-/**
- * intel_cln_imr_alloc
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- * @param read: IMR read mask value
- * @param write: IMR write mask value
- * @return nothing
- *
- * setup the next available IMR with customized read and write masks
- */
-int intel_cln_imr_alloc(uint32_t high, uint32_t low, uint32_t read,
-			uint32_t write, unsigned char *info, bool lock)
-{
-	int id = 0;
-
-	if (info == NULL)
-		return -EINVAL;
-
-	if ((low & IMR_LOCK_BIT) || (read == 0 || write == 0)) {
-		pr_err("%s: Invalid acces mode\n", __func__);
-		return -EINVAL;
-	}
-
-	/* Calculate aligned addresses and validate range */
-	high = prepare_input_addr(high);
-	low = prepare_input_addr(low);
-
-	/* Find a free entry */
-	id = intel_cln_imr_find_free_entry();
-	if (id < 0)
-		return -ENOMEM;
-
-	/* Add entry - locking as necessary */
-	intel_cln_imr_add_entry(id, high, low, (read & IMR_READ_ENABLE_ALL),
-				write, lock);
-
-	/* Name the new entry */
-	memcpy(local_imr[id].info, info, MAX_INFO_SIZE);
-
-	/* Update local data structures */
-	intel_clm_imr_latch_data();
-
-	pr_info("IMR alloc id %d 0x%08x - 0x%08x %s\n", id, low, high,
-		lock ? "locked" : "unlocked");
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_alloc);
-
-/**
- * intel_cln_imr_free
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- * @return nothing
- *
- * remove the imr based on input memory region
- */
-int intel_cln_imr_free(uint32_t high, uint32_t low)
-{
-	int i = 0;
-
-	if (low > high) {
-		pr_err("%s: Invalid input address values.\n", __func__);
-		return -EINVAL;
-	}
-
-	high = prepare_input_addr(high);
-	if (!high) {
-		pr_err("%s: Invalid input memory address.\n", __func__);
-		return -EINVAL;
-	}
-
-	low = prepare_input_addr(low);
-	if (!low) {
-		pr_err("%s: Invalid input memory address.\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		if (local_imr[i].occupied
-			&& (local_imr[i].addr.addr_low == low)
-			&& (local_imr[i].addr.addr_high == high)
-			&& (!local_imr[i].locked)) {
-				intel_cln_remove_imr_entry(i);
-				return 0;
-			}
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL(intel_cln_imr_free);
-
-/**
- * intel_cln_imr_init_data
- *
- * @return nothing
- * initialize local_imr data structure
- */
-static void intel_cln_imr_init_data(void)
-{
-	int i = 0;
-	char * res_str = "System Reserved Region";
-	int len = strlen(res_str);
-
-	intel_clm_imr_latch_data();
-
-	for (i = 0; i < IMR_MAXID; i++) {
-		local_imr[i].reg = imr_reg_value[i];
-		memcpy(local_imr[i].info, res_str, len);
-	}
-}
-
-/**
- * intel_cln_imr_lockall
- *
- * @param mask: module parameter
- * @return nothing
- *
- * lock up all un-locked IMRs
- */
-int intel_cln_imr_lockall(void)
-{
-	int i = 0;
-	uint32_t temp_addr;
-
-	/* Enumerate IMR data structures */
-	intel_cln_imr_init_data();
-	intel_cln_imr_init_mask(imr_bit_mask);
-
-	/* Cycle through IMRs locking whichever are unlocked */
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		temp_addr = local_imr[i].addr.addr_low;
-		if (!(temp_addr & IMR_LOCK_BIT)) {
-
-			DBG("%s: locking IMR %d\n", __func__, i);
-			temp_addr |= IMR_LOCK_BIT;
-			intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
-						local_imr[i].reg.imr_xl,
-						temp_addr, 0);
-		}
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_lockall);
-
-/**
- * intel_cln_imr_stat_show
- *
- * @param dev: pointer to device
- * @param attr: attribute pointer
- * @param buf: output buffer
- * @return number of bytes successfully read
- *
- * Populates IMR state via /sys/device/intel-cln-imr/stat
- */
-static int intel_cln_imr_stat_show(struct device *dev,
-				   struct device_attribute *attr,
-				   char *buf)
-{
-	int len = 0;
-	int i = 0;
-	int size, count = PAGE_SIZE;
-	uint32_t hi_phy_addr, lo_phy_addr;
-
-	for (i = 0; i < IMR_MAXID; i++) {
-
-		/* read back the actual  input physical memory address */
-		hi_phy_addr = get_phy_addr(local_imr[i].addr.addr_high);
-		lo_phy_addr = get_phy_addr(local_imr[i].addr.addr_low);
-
-		/* the IMR always protect extra 1k memory size above the input
-		 * high reg value
-		 */
-		size = ((hi_phy_addr - lo_phy_addr) / IMR_MEM_ALIGN) + 1;
-
-		size = snprintf(buf+len, count,
-				"imr - id : %d\n"
-				"info     : %s\n"
-				"occupied : %s\n"
-				"locked   : %s\n"
-				"size     : %d kb\n"
-				"hi addr (phy): 0x%08x\n"
-				"lo addr (phy): 0x%08x\n"
-				"hi addr (vir): 0x%08x\n"
-				"lo addr (vir): 0x%08x\n"
-				"read mask  : 0x%08x\n"
-				"write mask : 0x%08x\n\n",
-				i,
-				local_imr[i].info,
-				local_imr[i].occupied ? "yes" : "no",
-				local_imr[i].locked ? "yes" : "no",
-				size,
-				hi_phy_addr,
-				lo_phy_addr,
-				(uint32_t)phys_to_virt(hi_phy_addr),
-				(uint32_t)phys_to_virt(lo_phy_addr),
-				local_imr[i].addr.read_mask,
-				local_imr[i].addr.write_mask);
-		len += size;
-		count -= size;
-	}
-	return len;
-}
-
-static struct device_attribute dev_attr_stats = {
-	.attr = {
-		.name = "stat",
-		.mode = 0444, },
-	.show = intel_cln_imr_stat_show,
-};
-
-static struct attribute *platform_attributes[] = {
-	&dev_attr_stats.attr,
-	NULL,
-};
-
-static struct attribute_group imr_attrib_group = {
-	.attrs = platform_attributes
-};
-
-/**
- * intel_cln_imr_init
- *
- * @return 0 success < 0 failue
- *
- * module entry point
- */
-int  __init intel_cln_imr_init(void)
-{
-	int ret;
-
-	pdev = platform_device_alloc(DRIVER_NAME, -1);
-	if (!pdev)
-		return -ENOMEM;
-
-	ret = platform_device_add(pdev);
-	if (ret)
-		goto fail_platform;
-
-	/* initialise local imr data structure */
-	intel_cln_imr_init_data();
-
-	ret = sysfs_create_group(&pdev->dev.kobj, &imr_attrib_group);
-	if (ret)
-		goto fail_platform;
-
-	if(intel_cln_imr_runt_setparams() == 0 && imr_lock == 1){
-                intel_cln_imr_lockall();
-        }
-
-	return 0;
-
-fail_platform:
-	platform_device_del(pdev);
-	return ret;
-}
-EXPORT_SYMBOL(intel_cln_imr_init);
-
-MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/drivers/platform/x86/quark/intel_cln_imr.h b/drivers/platform/x86/quark/intel_cln_imr.h
deleted file mode 100644
index 3861d60..0000000
--- a/drivers/platform/x86/quark/intel_cln_imr.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * A total number of 8 IMRs have implemented by Clanton SoC,
- * some IMRs might be already occupied by BIOS or Linux booting time.
- *
- * Input addresses parameter required the actual Physical address.
- *
- * The IMR alloc API will locate the next available IMR slot set up
- * with input memory region, and apply with the default access right
- * (CPU & CPU_snoop enable).
- *
- * The alloc_mask API takes input read & write masks values to set up
- * IMR with customized access right.
- *
- * User can free IMR with pre-alloc specified addresses.
- */
-
-#ifndef __INTEL_CLN_IMR_H__
-#define __INTEL_CLN_IMR_H__
-
-#include <linux/intel_cln_sb.h>
-#include "asm/io.h"
-
-#define CFG_READ_OPCODE         0x10    /* BUnit Control Read */
-#define CFG_WRITE_OPCODE        0x11    /* BUnit control write */
-
-/* DRAM IMR register addresses */
-#define IMR0L			0x40
-#define IMR0H			0x41
-#define IMR0RM			0x42
-#define IMR0WM			0x43
-#define IMR1L			0x44
-#define IMR1H			0x45
-#define IMR1RM			0x46
-#define IMR1WM			0x47
-#define IMR2L			0x48
-#define IMR2H			0x49
-#define IMR2RM			0x4A
-#define IMR2WM			0x4B
-#define IMR3L			0x4C
-#define IMR3H			0x4D
-#define IMR3RM			0x4E
-#define IMR3WM			0x4F
-#define IMR4L			0x50
-#define IMR4H			0x51
-#define IMR4RM			0x52
-#define IMR4WM			0x53
-#define IMR5L			0x54
-#define IMR5H			0x55
-#define IMR5RM			0x56
-#define IMR5WM			0x57
-#define IMR6L			0x58
-#define IMR6H			0x59
-#define IMR6RM			0x5A
-#define IMR6WM			0x5B
-#define IMR7L			0x5C
-#define IMR7H			0x5D
-#define IMR7RM			0x5E
-#define IMR7WM			0x5F
-
-#define IMR_LOCK_BIT            0x80000000
-#define IMR_WRITE_ENABLE_ALL    0xFFFFFFFF
-#define IMR_READ_ENABLE_ALL     0xBFFFFFFF
-#define IMR_REG_MASK            0xFFFFFC
-
-#define IMR_ESRAM_FLUSH_INIT	0x80000000  /* esram flush */
-#define IMR_SNOOP_ENABLE	0x40000000  /* core snoops */
-#define IMR_PUNIT_ENABLE	0x20000000
-#define IMR_SMM_ENABLE		0x02        /* core SMM access */
-#define IMR_NON_SMM_ENABLE	0x01        /* core non-SMM access */
-#define IMR_BASE_ADDR           0x00
-#define IMR_MEM_ALIGN           0x400
-
-#define MAX_INFO_SIZE           64
-#define IMR_MAXID		8
-
-/* snoop + Non SMM write mask */
-#define IMR_DEFAULT_MASK	(IMR_SNOOP_ENABLE \
-				+ IMR_ESRAM_FLUSH_INIT \
-				+ IMR_NON_SMM_ENABLE)
-
-/* debug printk */
-#ifdef DEBUG
-#define DBG(args...) pr_info(args)
-#else
-#define DBG(args...)
-#endif
-
-extern unsigned long  _text;
-extern unsigned long  __init_begin;
-
-/**
- * intel_cln_imr_alloc
- *
- * @param high: the end of physical memory address
- * @param low: the start of physical memory address
- * @param read: IMR read mask value
- * @param write: IMR write maks value
- * @param info: imr information
- * @param lock: imr lock
- *
- * Setup imr with customised read/ write masks
- */
-int intel_cln_imr_alloc(u32 high, u32 low, u32 read, u32 write,
-			unsigned char *info, bool lock);
-
-/**
- * intel_cln_imr_free
- *
- * @param high: high boundary of memory address
- * @param low: low boundary of memorry address
- *
- * remove the imr based on input memory region
- */
-int intel_cln_imr_free(u32 high, u32 low);
-
-/**
- * intel_cln_remove_imr_entry
- *
- * @param id: internal imr data struct id
- *
- * Remove imr based on input imr data structure id
- */
-void intel_cln_remove_imr_entry(int id);
-
-/**
- * intel_cln_imr_init
- *
- * Initialise IMRs
- */
-int intel_cln_imr_init(void);
-
-#endif
diff --git a/drivers/platform/x86/quark/intel_cln_imr_kernel.c b/drivers/platform/x86/quark/intel_cln_imr_kernel.c
deleted file mode 100644
index 51e8676..0000000
--- a/drivers/platform/x86/quark/intel_cln_imr_kernel.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR driver
- *
- * IMR stand for Insolate Memory Region, supported by Clanton SoC.
- *
- * The IMR id 3 is pre-defined as the use for kernel data protection
- *
- * The early imr protects entire memory (from the beginning of kernel text
- * section to the top of memory) during linux boot time. In the linux run
- * time, the protection need to resize down to memory region that only
- * contains: kernel text, read only data, and initialized data section.
- *
- */
-#include <linux/errno.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/clanton.h>
-#include <linux/printk.h>
-#include "intel_cln_imr.h"
-
-/* pre-defined imr id for uncompressed kernel */
-#define IMR_KERNEL_ID	3
-
-/**
- * addr_hw_ready
- *
- * shift input address value to match HW required 1k aligned format
- */
-static inline uint32_t addr_hw_ready(uint32_t addr)
-{
-	/* memory alignment */
-	addr &= (~((1 << 10) - 1));
-
-	/* prepare input addr in HW required format */
-	addr = (addr >> 8) & IMR_REG_MASK;
-	return addr;
-}
-
-/**
- * void intel_cln_imr_runt_kerndata_setup
- *
- * Setup imr for kernel text, read only data section
- *
- * The read only data (rodata) section placed between text and initialized data
- * section by kernel.
- */
-static void intel_cln_imr_runt_kerndata_setup(void)
-{
-	uint32_t hi;
-	uint32_t lo;
-
-	hi = (uint32_t)virt_to_phys(&__init_begin);
-	lo = (uint32_t)virt_to_phys(&_text);
-
-	/* Set a locked IMR around the kernel .text section */
-	if (intel_cln_imr_alloc((hi - IMR_MEM_ALIGN), lo,
-				IMR_DEFAULT_MASK, IMR_DEFAULT_MASK,
-				"KERNEL RUNTIME DATA", 1)) {
-		pr_err("IMR: Set up runtime kernel data imr faild!\n");
-		return;
-	}
-}
-
-/**
- * intel_cln_imr_teardown_unlocked
- *
- * Remove any unlocked IMR
- *
- */
-static void intel_cln_imr_teardown_unlocked(void)
-{
-	int i = 0;
-	for (i = 0; i < IMR_MAXID; i++)
-		intel_cln_remove_imr_entry(i);
-}
-
-/**
- * intel_cln_imr_runt_setparams
- *
- * set imr range for text, read only, initialised data in linux run time
- */
-int intel_cln_imr_runt_setparams(void)
-{
-	/* Setup an IMR around the kernel .text area */
-	intel_cln_imr_runt_kerndata_setup();
-
-	/* Remove any other unlocked IMR */
-	intel_cln_imr_teardown_unlocked();
-
-	return 0;
-}
-EXPORT_SYMBOL(intel_cln_imr_runt_setparams);
-
-/**
- * intel_cln_imr_runt_init
- *
- * module entry point
- */
-static int  __init intel_cln_imr_runt_init(void)
-{
-	return 0;
-}
-
-/**
- * intel_cln_imr_runt_exit
- *
- * Module exit
- */
-static void __exit intel_cln_imr_runt_exit(void)
-{
-	/* do nothing */
-}
-
-MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("Dual BSD/GPL");
-
-subsys_initcall(intel_cln_imr_runt_init);
-module_exit(intel_cln_imr_runt_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_imr_test.c b/drivers/platform/x86/quark/intel_cln_imr_test.c
deleted file mode 100644
index 2d98507..0000000
--- a/drivers/platform/x86/quark/intel_cln_imr_test.c
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton IMR Test module
- *
- */
-
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-#include "intel_cln_imr.h"
-
-#define DRIVER_NAME			"intel_cln_imr_test"
-
-/**
- * XXX intel_cln_sb.h needs to be updated with SB_ID_PUNIT and change
- * propagated. This is a workaround to make it look less ugly. */
-#define SB_ID_PUNIT			SB_ID_THERMAL
-
-/* Memory-mapped SPI Flash address */
-#define ILB_SPIFLASH_BASEADDR			0xFF800000
-/* PUnit DMA block transfer size, in bytes */
-#define SPI_DMA_BLOCK_SIZE			512
-
-/**************************** Exported to LISA *******************************/
-
-/*
- * Internally-used ioctl code. At the moment it is not reserved by any mainline
- * driver.
- */
-#define IMR_TEST_IOCTL_CODE			0xE1
-
-/*
- * Integers for ioctl operation.
- */
-#define IOCTL_CLN_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
-#define IOCTL_CLN_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
-
-/*****************************************************************************/
-
-/**
- * struct intel_cln_imr_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_cln_imr_test_dev {
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-};
-
-static struct intel_cln_imr_test_dev imr_test_dev;
-static struct class *imr_test_class;
-static DEFINE_MUTEX(imr_test_mutex);
-static int imr_test_major;
-
-/* PUnit DMA registers over side-band */
-#define PUNIT_SPI_DMA_COUNT_REG		0x60
-#define PUNIT_SPI_DMA_DEST_REG		0x61
-#define PUNIT_SPI_DMA_SRC_REG		0x62
-
-/**
- * ilb_spi_dma_read 
- *
- * @param src: physical address in Legacy SPI Flash
- * @param dst: physical address of destination
- * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
- *
- * Read-access iLB SPI via PUnit DMA engine.
- * 
- */
-static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
-{
-	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
-		dma_block_count);
-
-	/* Setup source and destination addresses. */
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_SRC_REG, (u32) src, 0);
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_DEST_REG, (u32) dst, 0);
-
-	pr_info("%s: starting transaction\n", __func__);
-
-	/*
-	 * Setup the number of block to be copied over. Transaction will start
-	 * as soon as the register is filled with value.
-	 */
-	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
-		PUNIT_SPI_DMA_COUNT_REG, dma_block_count, 0);
-
-	/* Poll for completion. */
-	while (dma_block_count > 0) {
-		intel_cln_sb_read_reg(SB_ID_PUNIT, CFG_READ_OPCODE,
-			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count, 0); 
-	}
-
-	pr_info("%s: transaction completed\n", __func__);
-}
-
-/**
- * punit_dma_sanity_check 
- *
- * @return 0 if success, 1 if failure
- *
- * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
- * Flash block. 
- */
-static int punit_dma_sanity_check(void)
-{
-	int err = 0;
-	u32 *buffer = NULL;
-	u32 buf_ph_addr = 0;
-
-	/* Allocate 512B buffer for 1 SPI Flash block */
-	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
-        if (!buffer) {
-		err = -ENOMEM;
-		goto end;
-	}
-
-	/* DMA first SPI Flash block into buffer */
-	buf_ph_addr = (u32)virt_to_phys(buffer);
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
-
-	kfree(buffer);
-end:
-	return err;
-}
-
-/**
- * imr_violate_kernel_punit_dma 
- *
- * @return always 0
- *
- * PUnit-DMA access to the Uncompressed Kernel IMR.
- * This is based on set_imr_kernel_data() in intel_cln_imr.c. Find the physical
- * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
- * 
- */
-static int imr_violate_kernel_punit_dma(void)
-{
-	extern unsigned long _text;
-	u32 kernel_text = (u32)virt_to_phys(&_text);
-
-	/* We expect this to trigger an IMR violation reset */
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
-
-	/*
-	 * If we're still alive, we have a serious bug:
-	 * - we didn't appropriately target the IMR?
-	 * - if we have, weren't we prevented from accessing?
-	 * - if we weren't prevented, it's unlikely we're alive with a dirty
-	 *   text section
-	 */
-	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
-		__func__);
-
-	return 0;
-}
-
-/*
- * File ops
- */
-static long imr_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	switch (cmd) {
-		case IOCTL_CLN_SANITY_CHECK_PUNIT_DMA:
-			/* Check PUnit DMA actually works */
-			ret = punit_dma_sanity_check();
-			break;
-		case IOCTL_CLN_IMR_1:
-			/* Kernel IMR violation: PUnit DMA access */
-			ret = imr_violate_kernel_punit_dma();
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int imr_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
-		mutex_unlock(&imr_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (imr_test_dev.opened) {
-		mutex_unlock(&imr_test_dev.open_lock);
-		mutex_unlock(&imr_test_mutex);
-		return -EINVAL;
-	}
-
-	imr_test_dev.opened++;
-	mutex_unlock(&imr_test_dev.open_lock);
-	mutex_unlock(&imr_test_mutex);
-	return 0;
-}
-
-static int imr_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_dev.open_lock);
-	imr_test_dev.opened = 0;
-	mutex_unlock(&imr_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations imr_test_file_ops = {
-	.open = imr_test_open,
-	.release = imr_test_release,
-	.unlocked_ioctl = imr_test_ioctl,
-	.llseek = no_llseek,
-};
-
-/**
- * intel_cln_imr_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- */
-static int intel_cln_imr_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&imr_test_dev.open_lock);
-	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
-	imr_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(imr_test_class, NULL,
-				 MKDEV(imr_test_major, minor), NULL,
-				 "imrtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-
-	return 0;
-
-}
-
-static int intel_cln_imr_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
-
-	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
-	cdev_del(&imr_test_dev.cdev);
-
-	class_destroy(imr_test_class);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_imr_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_imr_test_remove,
-};
-
-/**
- * intel_cln_imr_test_init
- *
- * Load module.
- */
-static int __init intel_cln_imr_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	imr_test_class = class_create(THIS_MODULE,"cln_imr_test");
-	if (IS_ERR(imr_test_class)) {
-		retval = PTR_ERR(imr_test_class);
-		printk(KERN_ERR "imr_test: can't register imr_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	imr_test_major = MAJOR(dev);
-
-	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
-	imr_test_dev.pldev = platform_create_bundle(
-		&intel_cln_imr_test_driver, intel_cln_imr_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(imr_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(imr_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(imr_test_class);
-err:
-	return retval;
-}
-
-static void __exit intel_cln_imr_test_exit(void)
-{
-	platform_device_unregister(imr_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_imr_test_driver);
-}
-
-module_init(intel_cln_imr_test_init);
-module_exit(intel_cln_imr_test_exit);
-
-MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
-MODULE_DESCRIPTION("Clanton IMR test module");
-MODULE_LICENSE("Dual BSD/GPL");
-
diff --git a/drivers/platform/x86/quark/intel_cln_layout_data.c b/drivers/platform/x86/quark/intel_cln_layout_data.c
deleted file mode 100644
index 124bccf..0000000
--- a/drivers/platform/x86/quark/intel_cln_layout_data.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-
-#define DRIVER_NAME "cln-layout-conf"
-static char __iomem * layout_conf_data;
-static int len;
-
-static ssize_t layout_conf_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	ssize_t plen = len+1;
-	if( plen > PAGE_SIZE )
-		plen = PAGE_SIZE;
-	memcpy(buf, layout_conf_data, plen);
-	return plen;
-}
-
-static struct kobj_attribute layout_conf_attr = 
-	__ATTR(layout_conf, 0644, layout_conf_show, NULL);
-
-static int intel_cln_layout_data_probe(struct platform_device *pdev)
-{
-	extern struct kobject * board_data_kobj;
-	int ret = 0;
-
-	layout_conf_data = ioremap(pdev->resource->start,
-		resource_size(pdev->resource));
-	if (!layout_conf_data)
-		return -ENODEV;
-
-	len = resource_size(pdev->resource);
-	ret = sysfs_create_file(board_data_kobj, &layout_conf_attr.attr);
-	if (ret != 0){
-		pr_err("failed to create sysfs entry for layout config\n");
-		iounmap(layout_conf_data);
-		layout_conf_data = NULL;
-	}
-
-	return ret;
-}
-
-static int intel_cln_layout_data_remove(struct platform_device *pdev)
-{
-	extern struct kobject * board_data_kobj;
-
-	if (layout_conf_data){
-		sysfs_remove_file(board_data_kobj, &layout_conf_attr.attr);
-		iounmap(layout_conf_data);
-		
-	}
-	return 0;
-}
-
-static struct platform_driver cln_layout_data_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_layout_data_probe,
-	.remove		= intel_cln_layout_data_remove,
-};
-
-module_platform_driver(cln_layout_data_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SPI Data API");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c b/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
deleted file mode 100644
index 7dac528..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_clanton_hill.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME		"ClantonHill"
-#define GPIO_RESTRICT_NAME	"cln-gpio-restrict-nc"
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-#define AD7298_MAX_EXT_VIN_EXT_BATT 30000
-#define AD7298_MAX_EXT_VIN_INT_BATT 9200
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN_EXT_BATT, AD7298_MAX_EXT_VIN_INT_BATT }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct spi_board_info spi_onboard_devs[] = {
-	{
-		.modalias = "ad7298",
-		.max_speed_hz = 5000000,
-		.platform_data = &ad7298_platform_data,
-		.mode = SPI_MODE_2,
-		.bus_num = 0,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_0_cs_0,
-	},
-};
-
-/******************************************************************************
- *             ST Microelectronics LIS331DLH I2C Device Platform Data
- ******************************************************************************/
-#include <linux/platform_data/lis331dlh_intel_cln.h>
-
-/* GPIO interrupt pins connected to the LIS331DLH */
-#define ST_ACCEL_INT1_GPIO 15
-#define ST_ACCEL_INT2_GPIO 4
-
-static struct lis331dlh_intel_cln_platform_data lis331dlh_i2c_platform_data = {
-	.irq1_pin = ST_ACCEL_INT1_GPIO,
-};
-
-static struct gpio reserved_gpios[] = {
-	{
-		ST_ACCEL_INT1_GPIO,
-		GPIOF_IN,
-		"st_accel_i2c-int1"
-	},
-	{
-		ST_ACCEL_INT2_GPIO,
-		GPIOF_IN,
-		"st_accel_i2c-int2"
-	},
-};
-
-static struct i2c_board_info i2c_onboard_devs[] = {
-	{
-		I2C_BOARD_INFO("intel-cln-max9867", 0x18),
-	},
-	{
-		I2C_BOARD_INFO("lis331dlh_cln", 0x19),
-		.platform_data  = &lis331dlh_i2c_platform_data,
-	},
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Clanton Hill platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	return spi_register_board_info(spi_onboard_devs,
-				       ARRAY_SIZE(spi_onboard_devs));
-}
-
-/**
- * intel_cln_i2c_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard I2C device(s) present on the Clanton Hill platform
- */
-static int intel_cln_i2c_add_onboard_devs(void)
-{
-	return i2c_register_board_info(0, i2c_onboard_devs,
-			ARRAY_SIZE(i2c_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	int ret = gpio_request_array(reserved_gpios,
-				     ARRAY_SIZE(reserved_gpios));
-	if (ret == 0)
-		ret = intel_cln_spi_add_onboard_devs();
-
-	return ret;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_clanton_hill_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = intel_cln_i2c_add_onboard_devs();
-	if (ret == 0)
-		ret = platform_driver_register(&gpio_restrict_pdriver);
-
-	return ret;
-}
-
-static int intel_cln_plat_clanton_hill_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_clanton_hill_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_clanton_hill_probe,
-	.remove		= intel_cln_plat_clanton_hill_remove,
-};
-
-module_platform_driver(cln_clanton_hill_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Clanton Hill BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c b/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
deleted file mode 100644
index 0341606..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_clanton_peak.c
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Clanton Peak board entry point
- *
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/spi_bitbang.h>
-#include <linux/spi/spi_gpio.h>
-
-#define DRIVER_NAME		"ClantonPeakSVP"
-#define GPIO_RESTRICT_NAME_NC	"cln-gpio-restrict-nc"
-#define GPIO_RESTRICT_NAME_SC	"cln-gpio-restrict-sc"
-
-
-/* GPIO connected to Test Equipment */
-#define SUT_GPIO_NC_3				0x03
-#define SUT_GPIO_NC_4				0x04
-#define SUT_GPIO_NC_5				0x05
-#define SUT_GPIO_NC_6				0x06
-#define SUT_GPIO_SC_2				0x0A
-#define SUT_GPIO_SC_3				0x0B
-#define SUT_GPIO_SC_4				0x0C
-#define SUT_GPIO_SC_5				0x0D
-
-#define GPIO_NC_BITBANG_SPI_BUS			2
-#define GPIO_SC_BITBANG_SPI_BUS			3
-
-static struct spi_board_info spi_onboard_devs[] = {
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.max_speed_hz = 50000000,
-		.bus_num = 0,
-	},
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-	},
-};
-
-/*
- * Define platform data for bitbanged SPI devices.
- * Assign GPIO to SCK/MOSI/MISO
- */
-static struct spi_gpio_platform_data spi_gpio_nc_data = {
-	.sck = SUT_GPIO_NC_3,
-	.mosi = SUT_GPIO_NC_4,
-	.miso = SUT_GPIO_NC_5,
-	.num_chipselect = 1,
-};
-static struct spi_gpio_platform_data spi_gpio_sc_data = {
-	.sck = SUT_GPIO_SC_2,
-	.mosi = SUT_GPIO_SC_3,
-	.miso = SUT_GPIO_SC_4,
-	.num_chipselect = 1,
-};
-
-/*
- * Board information for bitbanged SPI devices.
- */
-static const struct spi_board_info spi_gpio_nc_bi[] = {
-	{
-	.modalias	= "spidev",
-	.max_speed_hz	= 1000,
-	.bus_num	= GPIO_NC_BITBANG_SPI_BUS,
-	.mode		= SPI_MODE_0,
-	.platform_data	= &spi_gpio_nc_data,
-	/* Assign GPIO to CS */
-	.controller_data = (void *)SUT_GPIO_NC_6,
-	},
-};
-static const struct spi_board_info spi_gpio_sc_bi[] = {
-	{
-	.modalias	= "spidev",
-	.max_speed_hz	= 1000,
-	.bus_num	= GPIO_SC_BITBANG_SPI_BUS,
-	.mode		= SPI_MODE_0,
-	.platform_data	= &spi_gpio_sc_data,
-	/* Assign GPIO to CS */
-	.controller_data = (void *)SUT_GPIO_SC_5,
-	},
-};
-
-static struct platform_device spi_gpio_nc_pd = {
-	.name	= "spi_gpio",
-	.id	= GPIO_NC_BITBANG_SPI_BUS,
-	.dev	= {
-		.platform_data = &spi_gpio_nc_data,
-	},
-};
-
-static struct platform_device spi_gpio_sc_pd = {
-	.name	= "spi_gpio",
-	.id	= GPIO_SC_BITBANG_SPI_BUS,
-	.dev	= {
-		.platform_data = &spi_gpio_sc_data,
-	},
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Clanton Peak platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-static int register_bitbanged_spi(int nc)
-{
-	int ret = 0;
-
-	ret = platform_device_register(nc ? &spi_gpio_nc_pd : &spi_gpio_sc_pd);
-	if (ret)
-		goto err;
-
-	ret = spi_register_board_info(nc ? spi_gpio_nc_bi : spi_gpio_sc_bi,
-				      nc ? ARRAY_SIZE(spi_gpio_nc_bi) : 
-				           ARRAY_SIZE(spi_gpio_sc_bi));
-	if (ret)
-		goto err_unregister;
-
-	return 0;
-
-err_unregister:
-	platform_device_unregister(nc ? &spi_gpio_nc_pd : &spi_gpio_sc_pd);
-err:
-	return ret;
-}
-
-static int intel_cln_gpio_restrict_probe_nc(struct platform_device *pdev)
-{
-	return register_bitbanged_spi(1);
-}
-
-static int intel_cln_gpio_restrict_probe_sc(struct platform_device *pdev)
-{
-	return register_bitbanged_spi(0);
-}
-
-static struct platform_driver gpio_restrict_pdriver_nc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_NC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_nc,
-};
-
-static struct platform_driver gpio_restrict_pdriver_sc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_SC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_sc,
-};
-
-static int intel_cln_plat_clanton_peak_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
-	if (ret) {
-		pr_err("%s: couldn't register %s platform driver\n",
-		       __func__, gpio_restrict_pdriver_nc.driver.name);
-	}
-
-	ret = platform_driver_register(&gpio_restrict_pdriver_sc);
-	if (ret) {
-		pr_err("%s: couldn't register %s platform driver\n",
-		       __func__, gpio_restrict_pdriver_sc.driver.name);
-	}
-		
-	return intel_cln_spi_add_onboard_devs();
-}
-
-static int intel_cln_plat_clanton_peak_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver clanton_peak_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_clanton_peak_probe,
-	.remove		= intel_cln_plat_clanton_peak_remove,
-};
-
-module_platform_driver(clanton_peak_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Clanton Peak BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
diff --git a/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c b/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
deleted file mode 100644
index 263c07b..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_cross_hill.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * CrossHill board entry point
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME		"CrossHill"
-#define GPIO_RESTRICT_NAME_NC	"cln-gpio-restrict-nc"
-#define GPIO_RESTRICT_NAME_SC	"cln-gpio-restrict-sc"
-
-/*
- * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
- */
-#define SPI_BPEAK_RESET_GPIO 4
-#define SPI_BPEAK_ID0_GPIO   3
-#define SPI_BPEAK_ID1_GPIO   2
-#define SPI_BPEAK_ID2_GPIO   15
-#define SPI_BPEAK_ID3_GPIO   14
-
-static int nc_gpio_reg;
-static int sc_gpio_reg;
-
-static int cross_hill_probe;
-
-/*
- * Blackburn Peak SPI daughterboard ID values
- */
-enum {
-	CLN_SPI_BPEAK_ID_ZB_TI = 0xA,
-	CLN_SPI_BPEAK_ID_ZB_DIGI,
-	CLN_SPI_BPEAK_ID_ZB_INFR_NXP,
-	CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
-	CLN_SPI_BPEAK_ID_ADC_MAXIM,
-	CLN_SPI_BPEAK_ID_NONE
-};
-
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_1 = {
-	.gpio_cs = 11,
-};
-
-static struct spi_board_info spi_generic_devs[] = {
-	{
-		.modalias = "spidev",
-		.max_speed_hz = 50000000,
-		.platform_data = NULL,
-		.mode = SPI_MODE_0,
-		.bus_num = 1,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_1_cs_0,
-	},
-
-	{
-		.modalias = "spidev",
-		.max_speed_hz = 50000000,
-		.platform_data = NULL,
-		.mode = SPI_MODE_0,
-		.bus_num = 1,
-		.chip_select = 1,
-		.controller_data = &cln_ffrd_spi_1_cs_1,
-	},
-
-};
-
-static struct spi_board_info spi_energy_adc_devs[] = {
-	{
-		.modalias = "max78m6610_lmu",
-		.max_speed_hz = 2000000,
-		.platform_data = NULL,
-		.mode = SPI_MODE_3,
-		.bus_num = 1,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_1_cs_0,
-	},
-};
-
-
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Cross Hill platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	struct spi_board_info spi_onboard_devs[] = {
-		{
-			.modalias = "ad7298",
-			.max_speed_hz = 5000000,
-			.platform_data = &ad7298_platform_data,
-			.mode = SPI_MODE_2,
-			.bus_num = 0,
-			.chip_select = 0,
-			.controller_data = &cln_ffrd_spi_0_cs_0,
-		},
-	};
-
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-
-/**
- * intel_cln_spi_get_bpeak_id
- *
- * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
- * @return 0 on success or standard errnos on failure
- *
- * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
- */
-static int intel_cln_spi_get_bpeak_id(u8 *bpeak_id)
-{
-	int ret = 0;
-	struct gpio spi_bpeak_id_gpios[] = {
-		{
-			SPI_BPEAK_RESET_GPIO,
-			GPIOF_OUT_INIT_HIGH,
-			"spi_bpeak_reset"
-		},
-		{
-			SPI_BPEAK_ID0_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id0"
-		},
-		{
-			SPI_BPEAK_ID1_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id1"
-		},
-		{
-			SPI_BPEAK_ID2_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id2"
-		},
-		{
-			SPI_BPEAK_ID3_GPIO,
-			GPIOF_IN,
-			"spi_bpeak_id3"
-		}
-	};
-
-	/*
-	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
-	 * while a RESET GPIO output is asserted (active-low)
-	 */
-	ret = gpio_request_array(spi_bpeak_id_gpios,
-			ARRAY_SIZE(spi_bpeak_id_gpios));
-	if (ret) {
-		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
-				__func__);
-		return ret;
-	}
-
-	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
-	*bpeak_id =
-		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
-		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
-	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
-
-	gpio_free_array(spi_bpeak_id_gpios,
-			ARRAY_SIZE(spi_bpeak_id_gpios));
-
-	return 0;
-}
-
-/**
- * intel_cln_spi_add_bpeak_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers SPI device(s) indicated by the ID value obtained from a
- * Blackburn Peak SPI daughterboard
- */
-static int intel_cln_spi_add_bpeak_devs(void)
-{
-	u8 spi_bpeak_id = 0;
-	int ret = 0;
-
-	ret = intel_cln_spi_get_bpeak_id(&spi_bpeak_id);
-	if (ret) {
-		pr_err("%s: failed to obtain Blackburn Peak ID\n",
-				__func__);
-		return ret;
-	}
-
-	switch (spi_bpeak_id) {
-
-	case CLN_SPI_BPEAK_ID_NONE:
-		break;
-
-	case CLN_SPI_BPEAK_ID_ADC_MAXIM:
-		{
-			return spi_register_board_info(spi_energy_adc_devs,
-					ARRAY_SIZE(spi_energy_adc_devs));
-		}
-	case CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
-		{
-			pr_debug("CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL.\n");
-			return spi_register_board_info(spi_generic_devs,
-					ARRAY_SIZE(spi_generic_devs));
-		}
-	case CLN_SPI_BPEAK_ID_ZB_DIGI:
-		{
-			pr_debug("CLN_SPI_BPEAK_ID_ZB_DIGI load.\n");
-			return spi_register_board_info(spi_generic_devs,
-					ARRAY_SIZE(spi_generic_devs));
-
-		}
-	default:
-			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
-					__func__, spi_bpeak_id);
-			ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/** intel_cln_spi_devs_addon
- *
- * addon spi device when gpio support in place
- */
-static int intel_cln_spi_devs_addon(void)
-{
-	int ret = 0;
-
-	if (cross_hill_probe != 1) {
-
-		ret = intel_cln_spi_add_onboard_devs();
-		if (ret)
-			return ret;
-
-		ret = intel_cln_spi_add_bpeak_devs();
-
-		cross_hill_probe = 1;
-	}
-
-	return ret;
-}
-
-/**
- * intel_cln_gpio_restrict_probe_nc
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe_nc(struct platform_device *pdev)
-{
-	int ret;
-	nc_gpio_reg = 1;
-
-	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
-		ret = intel_cln_spi_devs_addon();
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-/**
- * intel_cln_gpio_restrict_probe_sc
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe_sc(struct platform_device *pdev)
-{
-	int ret;
-	sc_gpio_reg = 1;
-
-	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
-		ret = intel_cln_spi_devs_addon();
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-
-static struct platform_driver gpio_restrict_pdriver_nc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_NC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_nc,
-};
-
-static struct platform_driver gpio_restrict_pdriver_sc = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME_SC,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe_sc,
-};
-
-static int intel_cln_plat_cross_hill_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
-	if (ret)
-		return ret;
-
-	return platform_driver_register(&gpio_restrict_pdriver_sc);
-}
-
-static int intel_cln_plat_cross_hill_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_cross_hill_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_cross_hill_probe,
-	.remove		= intel_cln_plat_cross_hill_remove,
-};
-
-module_platform_driver(cln_cross_hill_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Cross Hill BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/drivers/platform/x86/quark/intel_cln_plat_data.c b/drivers/platform/x86/quark/intel_cln_plat_data.c
deleted file mode 100644
index 959c066..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_data.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <asm/io.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/clanton.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#define PREFIX		"CLN-PLT: "
-#define PLAT_MAGIC	0x54414450	/* PDAT */
-#define DESC_LEN	0x0A
-#define MAC_STRLEN	20
-#define MAC_LEN		6
-
-struct cln_plat_dat_hdr {
-	uint32_t magic;
-	uint32_t length;
-	uint32_t crc32;
-};
-
-struct cln_plat_data {
-	uint16_t plat_id;
-	uint16_t length;
-	uint8_t desc[DESC_LEN];
-	uint16_t version;
-};
-
-struct cln_bsp_reg {
-	struct platform_device pdev;
-	cln_plat_id_t id;
-};
-
-static struct cln_bsp_reg bsp_data [] = {
-	{
-		.pdev.name	= "cln-plat-clanton-peak",
-		.pdev.id	= -1,
-		.id		= CLANTON_PEAK,
-	},
-	{
-		.pdev.name	= "cln-plat-kips-bay",
-		.pdev.id	= -1,
-		.id		= KIPS_BAY,
-	},
-	{
-		.pdev.name	= "cln-plat-cross-hill",
-		.pdev.id	= -1,
-		.id		= CROSS_HILL,
-	},
-	{
-		.pdev.name	= "cln-plat-clanton-hill",
-		.pdev.id	= -1,
-		.id		= CLANTON_HILL,
-	},
-	{
-		.pdev.name	= "cln-plat-galileo",
-		.pdev.id	= -1,
-		.id		= IZMIR,
-	},
-
-};
-
-/**
- * struct cln_plat_data_list
- *
- * Structure to hold a linked list of platform data refs
- */
-struct cln_plat_data_list {
-	char name[DESC_LEN+1];
-	struct cln_plat_data * plat_data;
-	struct kobj_attribute plat_attr;
-	struct list_head list;
-};
-
-static char __iomem * plat_data;
-static char * plat_bin_name = 	"pdat_bin";
-static unsigned int plat_bin_size;
-static struct cln_plat_dat_hdr * plat_hdr;
-static struct list_head entry_list;
-
-/**
- * intel_cln_plat_sysfs_show_bin
- *
- * Generic show routine for any of the sysfs entries of this module
- */
-static ssize_t intel_cln_plat_sysfs_show_bin(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	ssize_t plen = plat_bin_size;
-	if( plen > PAGE_SIZE )
-		plen = PAGE_SIZE;
-
-	memcpy(buf, plat_data, plen);
-	return plen;
-}
-
-/**
- * intel_cln_plat_sysfs_show
- *
- * Generic show routine for any of the sysfs entries of this module
- */
-static ssize_t intel_cln_plat_sysfs_show(struct kobject *kobj,
-				struct kobj_attribute *attr, char *buf)
-{
-	unsigned char * data;
-	char fmt[0x20];
-	struct cln_plat_data_list * plat_item_list;
-	ssize_t plen = 0;
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		if ( attr == &plat_item_list->plat_attr ){
-
-			/* Derive length */
-			plen = plat_item_list->plat_data->length;
-			if (unlikely(plen > PAGE_SIZE))
-				plen = PAGE_SIZE;
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Enumrate return */
-			switch (plat_item_list->plat_data->plat_id){
-			case PLAT_DATA_ID:
-			case PLAT_DATA_SN:
-				snprintf(fmt, sizeof(fmt), "0x%%0%dx\n",
-					 plen*2);
-				return sprintf(buf, fmt, *(int16_t*)data);
-			case PLAT_DATA_MAC0:
-			case PLAT_DATA_MAC1:
-				if (unlikely(plen != MAC_LEN)){
-					return sprintf(buf, "invalid mac\n");
-				}
-				return snprintf(buf, MAC_STRLEN,
-					"%02x:%02x:%02x:%02x:%02x:%02x\n",
-					data[0], data[1], data[2], data[3],
-					data[4], data[5]);
-			default:
-				/* Treat as string data */
-				return snprintf(buf, plen, "%s", data);
-			}
-		}
-	}
-	return 0;
-}
-
-/**
- * intel_cln_plat_cleanup
- *
- * Generic cleanup code for the platform data interface
- *
- */
-static void intel_cln_plat_cleanup (void)
-{
-	extern struct kobject * board_data_kobj;
-	struct cln_plat_data_list * plat_item_list;
-
-	if (plat_data != NULL){
-		iounmap(plat_data);
-		plat_data = NULL;
-	}
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		sysfs_remove_file(board_data_kobj,
-				  &plat_item_list->plat_attr.attr);
-		kfree(plat_item_list);
-	}
-}
-
-/**
- * intel_cln_plat_get_desc_len
- *
- * @param desc: Pointer to desc string
- * @return len on success < 0 failure
- *
- * Function called to get a bounds checked desc field from platfrom data
- *
- */
-static int intel_cln_plat_get_desc_len (char * desc)
-{
-	int len = 0;
-	if (desc == NULL){
-		return -EINVAL;
-	}
-
-	for(; *desc != '\0' && len < DESC_LEN; desc++, len++);
-	return len;
-}
-
-/**
- * intel_cln_get_id
- *
- * @return platform id on success or < CLANTON_PLAT_UNDEFINED on error
- *
- * Function called to get platform id
- *
- */
-cln_plat_id_t intel_cln_plat_get_id(void)
-{
-	unsigned char * data;
-	struct cln_plat_data_list * plat_item_list;
-
-	if (plat_data == NULL)
-		return CLANTON_PLAT_UNDEFINED;
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-
-		/* Enumrate return */
-		if(plat_item_list->plat_data->plat_id == PLAT_DATA_ID){
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Return payload */
-			return *(int16_t*)data;
-		}
-	}
-	return CLANTON_PLAT_UNDEFINED;
-}
-EXPORT_SYMBOL(intel_cln_plat_get_id);
-
-/**
- * intel_cln_plat_get_mac
- *
- * @param id: Index of MAC address to find
- * @param mac: Output parameter for mac address
- *
- * @return 0 success < 0 failure
- *
- * Function called to remove the platfrom device from kernel space
- *
- */
-int intel_cln_plat_get_mac(plat_dataid_t id, char * mac)
-{
-	unsigned char * data;
-	unsigned int plen = 0;
-	struct cln_plat_data_list * plat_item_list;
-
-	if ((id != PLAT_DATA_MAC0 && id != PLAT_DATA_MAC1) || mac == NULL){
-		pr_err("invalid input id %d mac %p\n", id, mac);
-		return -EINVAL;
-	}
-
-	list_for_each_entry(plat_item_list, &entry_list, list){
-		if(plat_item_list->plat_data->plat_id == id){
-
-			/* Derive length */
-			plen = plat_item_list->plat_data->length;
-			if (unlikely(plen != MAC_LEN)){
-				pr_err("%s mac len invalid!\n", __func__);
-				return -ENODEV;
-			}
-
-			/* Hook data */
-			data =(char*)(plat_item_list->plat_data);
-			data += +sizeof(struct cln_plat_data);
-
-			/* Good to go */
-			memcpy(mac, data, MAC_LEN);
-			return 0;
-		}
-	}
-	return -ENODEV;
-}
-EXPORT_SYMBOL(intel_cln_plat_get_mac);
-
-
-/**
- * intel_cln_plat_probe
- *
- * @param pdev: Pointer to platform device
- * @return 0 success < 0 failure
- *
- * Function called to probe platform device "cln-plat"
- *
- */
-int intel_cln_plat_probe(struct resource * pres)
-{
-	char __iomem * end_addr = NULL;
-	char __iomem * data = NULL;
-	cln_plat_id_t id = CLANTON_PLAT_UNDEFINED;
-	extern struct kobject * board_data_kobj;
-	struct cln_plat_data * plat_item = NULL;
-	struct cln_plat_data_list * plat_item_list = NULL;
-	u32 crc = 0;
-	int ret = 0, i = 0;
-
-	INIT_LIST_HEAD(&entry_list);
-	plat_hdr = ioremap(pres->start, resource_size(pres));
-	end_addr = (char*)plat_hdr + resource_size(pres);
-	plat_data = (char*)plat_hdr;
-	if (!plat_hdr)
-		return -ENODEV;
-
-	/* Verify header magic */
-	if (plat_hdr->magic != 	PLAT_MAGIC){
-		pr_err(PREFIX"Expected magic 0x%08x read 0x%08lx\n",
-			PLAT_MAGIC, (unsigned long)plat_hdr->magic);
-	}
-
-	/* Validate length is sane */
-	if ((char*)plat_hdr + sizeof(struct cln_plat_dat_hdr) +
-		plat_hdr->length > end_addr ||
-		plat_hdr->length < sizeof(struct cln_plat_data)){
-		pr_err(PREFIX"Invalid length 0x%08lx\n",
-			(unsigned long)plat_hdr->length);
-		return -ENODEV;
-	}
-
-	/* Point to real end addr */
-	end_addr = (char*)plat_hdr +
-			sizeof(struct cln_plat_dat_hdr) + plat_hdr->length;
-	plat_bin_size = end_addr - plat_data;
-
-	/* Get pointer to start of data */
-	plat_item = (struct cln_plat_data*)(plat_hdr+1);
-	data = ((char*)(plat_item)+sizeof(struct cln_plat_data));
-
-	/* Validate CRC32 */
-	crc = ~crc32(0xFFFFFFFF, plat_item, plat_hdr->length);
-	if (crc != plat_hdr->crc32){
-		pr_err(PREFIX"CRC 0x%08x header indicates 0x%08x - fatal!\n",
-			crc, plat_hdr->crc32);
-		return -EFAULT;
-	}
-
-	/* /sys/firmware/board_data/plat_bin - dump entire platform binary */
-	plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
-					 GFP_KERNEL);
-	if (unlikely(plat_item_list == NULL)) {
-		pr_err("kzalloc fail !\n");
-		intel_cln_plat_cleanup();
-		return -ENOMEM;
-	}
-	sysfs_attr_init(&plat_item_list->plat_attr.attr);
-	plat_item_list->plat_attr.attr.name = plat_bin_name;
-	plat_item_list->plat_attr.attr.mode = 0644;
-	plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show_bin;
-
-	ret = sysfs_create_file(board_data_kobj,
-				&plat_item_list->plat_attr.attr);
-	if (unlikely(ret != 0)){
-		intel_cln_plat_cleanup();
-		pr_err("failed to create sysfs entry\n");
-		return ret;
-	}
-
-	/* Add to list */
-	list_add(&plat_item_list->list, &entry_list);
-
-	/* Iterate through each entry - add sysfs entry as appropriate */
-	while ( (char*)plat_item < end_addr){
-	
-		/* Bounds check */
-		if (data + plat_item->length > end_addr){
-			pr_err(PREFIX"Data 0x%p over-runs max-addr 0x%p\n",
-				data, end_addr);
-			break;
-		}
-
-		/* Extract data */
-		switch(plat_item->plat_id){
-		case PLAT_DATA_ID:
-			id = *((uint16_t*)data);
-			pr_info(PREFIX"Clanton Platform ID = %d\n", id);
-			break;
-		case PLAT_DATA_SN:
-		case PLAT_DATA_MAC0:
-		case PLAT_DATA_MAC1:
-			break;
-		default:
-			/* Unknown identifier */
-			break;
-		}
-
-		plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
-					 GFP_KERNEL);
-		if (unlikely(plat_item_list == NULL)) {
-			pr_err("kzalloc fail !\n");
-			intel_cln_plat_cleanup();
-			return -ENOMEM;
-		}
-
-		/* Get name of entity */
-		i = intel_cln_plat_get_desc_len(plat_item->desc);
-		if (i <= 0){
-			pr_err("desc len is %d!\n", i);
-			intel_cln_plat_cleanup();
-			return i;
-		}
-
-		memcpy(plat_item_list->name, plat_item->desc, i);
-		plat_item_list->plat_data = plat_item;
-
-		sysfs_attr_init(&plat_item_list->plat_attr.attr);
-		plat_item_list->plat_attr.attr.name = plat_item_list->name;
-		plat_item_list->plat_attr.attr.mode = 0644;
-		plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show;
-
-		ret = sysfs_create_file(board_data_kobj,
-					&plat_item_list->plat_attr.attr);
-		if (unlikely(ret != 0)){
-			intel_cln_plat_cleanup();
-			pr_err("failed to create sysfs entry\n");
-			return ret;
-		}
-
-		/* Add to list */
-		list_add(&plat_item_list->list, &entry_list);
-
-		/* Next */
-		plat_item = (struct cln_plat_data*)
-			(((char*)plat_item) + plat_item->length + sizeof(struct cln_plat_data));
-		data = ((char*)(plat_item) + sizeof(struct cln_plat_data));
-	}
-
-	/* Register BSP enabling platform code */
-	for (i = 0; i < sizeof(bsp_data)/sizeof(struct cln_bsp_reg); i++){
-		if (bsp_data[i].id == id){
-			platform_device_register(&bsp_data[i].pdev);
-		}
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL(intel_cln_plat_probe);
diff --git a/drivers/platform/x86/quark/intel_cln_plat_galileo.c b/drivers/platform/x86/quark/intel_cln_plat_galileo.c
deleted file mode 100644
index 9aeed94..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_galileo.c
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/i2c/at24.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/mfd/cy8c9540a.h>
-#include <linux/mfd/intel_cln_gip_pdata.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
-#include <linux/i2c/at24.h>
-
-#define DRIVER_NAME 		"Galileo"
-#define GPIO_RESTRICT_NAME 	"cln-gpio-restrict-sc"
-#define LPC_SCH_SPINAME		"spi-lpc-sch"
-
-#define CLN_SPI_MAX_CLK_DEFAULT		5000000
-
-/* GPIO line used to detect the LSB of the Cypress i2c address */
-#define GPIO_CYPRESS_A0			7
-/* GPIO line Cypress interrupts are routed to (in S0 power state) */
-#define GPIO_CYPRESS_INT_S0		13
-/* GPIO line Cypress interrupts are routed to (in S3 power state) */
-#define GPIO_CYPRESS_INT_S3		2
-
-/* Cypress i2c address depending on A0 value */
-#define CYPRESS_ADDR_A0_1		0x20
-#define CYPRESS_ADDR_A0_0		0x21
-
-/******************************************************************************
- *                   Cypress I/O Expander Platform Data
- ******************************************************************************/
-static struct cy8c9540a_pdata cy8c9540a_platform_data = {
-	.por_default		= {
-		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* Output */
-		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* Int mask */
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* PWM */
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Inversion */
-		0xe0, 0xe0, 0xff, 0xf3, 0x00, 0xff, 0xff, 0xff, /* Direction */
-		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* P0 drive */
-		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* P1 drive */
-		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P2 drive */
-		0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,	/* P3 drive */
-		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,	/* P4 drive */
-		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P5 drive */
-		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P6 drive */
-		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P7 drive */
-		0x00, 0xff, 0x00,				/* PWM0 */
-		0x00, 0xff, 0x00,				/* PWM1 */
-		0x00, 0xff, 0x00,				/* PWM2 */
-		0x00, 0xff, 0x00,				/* PWM3 */
-		0x00, 0xff, 0x00,				/* PWM4 */
-		0x00, 0xff, 0x00,				/* PWM5 */
-		0x00, 0xff, 0x00,				/* PWM6 */
-		0x00, 0xff, 0x00,				/* PWM7 */
-		0x00, 0xff, 0x00,				/* PWM8 */
-		0x00, 0xff, 0x00,				/* PWM9 */
-		0x00, 0xff, 0x00,				/* PWM10 */
-		0x00, 0xff, 0x00,				/* PWM11 */
-		0x00, 0xff, 0x00,				/* PWM12 */
-		0x00, 0xff, 0x00,				/* PWM13 */
-		0x00, 0xff, 0x00,				/* PWM14 */
-		0x00, 0xff, 0x00,				/* PWM15 */
-		0xff,						/* PWM CLKdiv */
-		0x02,						/* EEPROM en */
-		0x00						/* CRC */
-	},
-	.pwm2gpio_mapping	= {
-		CY8C9540A_PWM_UNUSED,
-		3,
-		CY8C9540A_PWM_UNUSED,
-		2,
-		9,
-		1,
-		8,
-		0,
-	},
-	.gpio_base		= 16,
-	.pwm_base		= 0,
-	.irq_base		= 64, 
-}; 
-
-/* Cypress expander requires i2c master to operate @100kHz 'standard mode' */
-static struct intel_cln_gip_pdata gip_pdata = {
-	.i2c_std_mode = 1,
-};
-static struct intel_cln_gip_pdata *galileo_gip_get_pdata(void)
-{
-	return &gip_pdata;
-}
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-static struct at24_platform_data at24_platform_data = {
-	.byte_len = (11 * 1024),
-	.page_size = 1,
-	.flags = AT24_FLAG_ADDR16,
-};
-
-/******************************************************************************
- *                        Intel Izmir i2c clients
- ******************************************************************************/
-static struct i2c_board_info __initdata static_i2c_board_info[] = {
-	{
-		I2C_BOARD_INFO("at24", 0x50),
-		.platform_data = &at24_platform_data,
-	},
-};
-static struct i2c_board_info probed_i2c_cypress = {
-	.platform_data = &cy8c9540a_platform_data,
-};
-static struct i2c_adapter *i2c_adap;
-static const unsigned short cypress_i2c_addr[] =
-	{ CYPRESS_ADDR_A0_1, CYPRESS_ADDR_A0_0, I2C_CLIENT_END };
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-#define LPC_SCH_SPI_BUS_ID 0x03
-
-/* TODO: extract this data from layout.conf encoded in flash */
-struct mtd_partition ilb_partitions [] = {
-	{
-		.name		= "grub",
-		.size		= 0x80400,
-		.offset		= 0,
-	},
-	{
-		.name		= "grub.conf",
-		.size		= 0xA00,
-		.offset		= 0x80400,
-	},
-	{
-		.name		= "layout.conf",
-		.size		= 4096,
-		.offset		= 0x4FF000,
-	},
-	{
-		.name		= "sketch",
-		.size		= 0x40000,
-		.offset		= 0x750000,
-	},
-	{
-		.name		= "raw",
-		.size		= 8192000,
-		.offset		= 0,
-
-	},
-};
-
-static struct flash_platform_data ilb_flash = {
-	.type = "s25fl064k",
-	.parts = ilb_partitions,
-	.nr_parts = ARRAY_SIZE(ilb_partitions),
-};
-
-static struct spi_board_info spi_onboard_devs[] = {
-	{
-		.modalias = "m25p80",
-		.platform_data = &ilb_flash,
-		.bus_num = LPC_SCH_SPI_BUS_ID,
-		.chip_select = 0,
-	},
-	{
-		.modalias = "ad7298",
-		.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
-		.platform_data = &ad7298_platform_data,
-		.mode = SPI_MODE_2,
-		.bus_num = 0,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_0_cs_0,
-	},
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_1_cs_0,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-	},
-};
-
-static struct gpio reserved_gpios[] = {
-	{
-		GPIO_CYPRESS_A0,
-		GPIOF_IN,
-		"cy8c9540a-a0",
-	},
-	{
-		GPIO_CYPRESS_INT_S0,
-		GPIOF_IN,
-		"cy8c9540a-int-s0",
-	},
-	{
-		GPIO_CYPRESS_INT_S3,
-		GPIOF_IN,
-		"cy8c9540a-int-s3",
-	},
-};
-
-static int cypress_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
-{
-	if (gpio_get_value(GPIO_CYPRESS_A0) && CYPRESS_ADDR_A0_1 == addr)
-		return 1;
-	if (!gpio_get_value(GPIO_CYPRESS_A0) && CYPRESS_ADDR_A0_0 == addr)
-		return 1;
-	return 0;
-}
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Izmir platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-
-	return spi_register_board_info(spi_onboard_devs,
-			ARRAY_SIZE(spi_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Register devices that depend on GPIOs.
- * Note this function makes extensive use of the probe deferral mechanism:
- * gpio_request() for a GPIO that is not yet available returns
- * -EPROBE_DEFER.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct i2c_client *cypress = NULL;
-	static int spi_done;
-	static int gpios_done;
-
-	if (spi_done)
-		goto gpios;
-
-	ret = intel_cln_spi_add_onboard_devs();
-	if (ret)
-		goto end;
-
-	spi_done = 1;
-
-gpios:
-	if (gpios_done)
-		goto i2c;
-
-	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
-	if (ret)
-		goto end;
-
-	probed_i2c_cypress.irq = gpio_to_irq(GPIO_CYPRESS_INT_S0);
-
-	gpios_done = 1;
-
-i2c:
-	i2c_adap = i2c_get_adapter(0);
-	if (NULL == i2c_adap) {
-		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
-			__func__);
-		ret = -EPROBE_DEFER;
-		goto end;
-	}
-	strlcpy(probed_i2c_cypress.type, "cy8c9540a", I2C_NAME_SIZE);
-	cypress = i2c_new_probed_device(i2c_adap, &probed_i2c_cypress,
-					cypress_i2c_addr, cypress_i2c_probe);
-	i2c_put_adapter(i2c_adap);
-
-	if (NULL == cypress) {
-		pr_err("%s: can't probe Cypress Expander\n", __func__);
-		ret = -ENODEV;
-		goto end;
-	}
-
-end:
-	return ret;
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_galileo_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-
-	/* Assign GIP driver handle for board-specific settings */
-	intel_cln_gip_get_pdata = galileo_gip_get_pdata;
-
-	/* i2c */
-	ret = i2c_register_board_info(0, static_i2c_board_info,
-		ARRAY_SIZE(static_i2c_board_info));
-	if (ret) {
-		goto end;
-	}
-
-	/* gpio */
-	ret = platform_driver_register(&gpio_restrict_pdriver);
-	if (ret)
-		goto end;
-
-#if 0
-	/* legacy SPI - TBD */
-	ret = platform_driver_register(&intel_cln_plat_galileo_lpcspi_pdriver);
-	if (ret)
-		goto end;
-#endif	
-end:
-	return ret;
-}
-
-static int intel_cln_plat_galileo_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_galileo_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_galileo_probe,
-	.remove		= intel_cln_plat_galileo_remove,
-};
-
-module_platform_driver(cln_galileo_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Galileo BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c b/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
deleted file mode 100644
index f701e69..0000000
--- a/drivers/platform/x86/quark/intel_cln_plat_kips_bay.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Legacy Platform Data Layout.conf accessor
- *
- * Simple Legacy SPI flash access layer
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
- */
-
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spi/pxa2xx_spi.h>
-#include <linux/spi/spi.h>
-
-#define DRIVER_NAME		"KipsBay"
-#define GPIO_RESTRICT_NAME	"cln-gpio-restrict-sc"
-
-static int gpio_cs = 1;
-
-module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
-
-
-/******************************************************************************
- *             Analog Devices AD7298 SPI Device Platform Data
- ******************************************************************************/
-#include "linux/platform_data/ad7298.h"
-
-/* Maximum input voltage allowed for each ADC input, in milliVolts */
-#define AD7298_MAX_EXT_VIN 5000
-
-static const struct ad7298_platform_data ad7298_platform_data = {
-	.ext_ref = false,
-	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
-		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
-};
-
-/******************************************************************************
- *                 Intel Clanton SPI Controller Data
- ******************************************************************************/
-static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
-	.gpio_cs = 8,
-};
-
-static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
-	.gpio_cs = 10,
-};
-
-static struct spi_board_info spi0_onboard_devs[] = {
-	{
-		.modalias = "ad7298",
-		.max_speed_hz = 5000000,
-		.platform_data = &ad7298_platform_data,
-		.mode = SPI_MODE_2,
-		.bus_num = 0,
-		.chip_select = 0,
-		.controller_data = &cln_ffrd_spi_0_cs_0,
-	}
-};
-
-static struct spi_board_info spi1_onboard_devs_gpiocs[] = {
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.controller_data = NULL,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-		.controller_data = &cln_ffrd_spi_1_cs_0,
-	},
-};
-
-static struct spi_board_info spi1_onboard_devs[] = {
-	{
-		.modalias = "spidev",
-		.chip_select = 0,
-		.controller_data = NULL,
-		.max_speed_hz = 50000000,
-		.bus_num = 1,
-	},
-};
-
-/**
- * intel_cln_spi_add_onboard_devs
- *
- * @return 0 on success or standard errnos on failure
- *
- * Registers onboard SPI device(s) present on the Kips Bay platform
- */
-static int intel_cln_spi_add_onboard_devs(void)
-{
-	int ret = 0;
-
-	ret = spi_register_board_info(spi0_onboard_devs,
-				      ARRAY_SIZE(spi0_onboard_devs));
-	if (ret)
-		return ret;
-
-	if (gpio_cs)
-		return spi_register_board_info(spi1_onboard_devs_gpiocs,
-					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
-	else
-		return spi_register_board_info(spi1_onboard_devs,
-					ARRAY_SIZE(spi1_onboard_devs));
-}
-
-
-/**
- * intel_cln_gpio_restrict_probe
- *
- * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
- * GPIOs are never released nor accessed by this driver.
- */
-static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
-{
-	return intel_cln_spi_add_onboard_devs();
-}
-
-static struct platform_driver gpio_restrict_pdriver = {
-	.driver		= {
-		.name	= GPIO_RESTRICT_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_gpio_restrict_probe,
-};
-
-static int intel_cln_plat_kips_bay_probe(struct platform_device *pdev)
-{
-	return platform_driver_register(&gpio_restrict_pdriver);
-}
-
-static int intel_cln_plat_kips_bay_remove(struct platform_device *pdev)
-{
-	return 0;
-}
-
-static struct platform_driver cln_kips_bay_driver = {
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= intel_cln_plat_kips_bay_probe,
-	.remove		= intel_cln_plat_kips_bay_remove,
-};
-
-module_platform_driver(cln_kips_bay_driver);
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
-MODULE_DESCRIPTION("Kips Bay BSP Data");
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_ALIAS("platform:"DRIVER_NAME);
-
diff --git a/drivers/platform/x86/quark/intel_cln_sb.c b/drivers/platform/x86/quark/intel_cln_sb.c
deleted file mode 100644
index be27d6a..0000000
--- a/drivers/platform/x86/quark/intel_cln_sb.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton side-band driver
- *
- * Thread-safe sideband read/write routine.
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
- */
-
-#include <linux/errno.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-#include "intel_cln_imr.h"
-
-#define INTEL_CLN_SB_CMD_ADDR	(0x000000D0)
-#define INTEL_CLN_SB_DATA_ADDR	(0x000000D4)
-
-#define INTEL_CLN_SB_MCR_SHIFT	(24)
-#define INTEL_CLN_SB_PORT_SHIFT	(16)
-#define INTEL_CLN_SB_REG_SHIFT	(8)
-#define INTEL_CLN_SB_BYTEEN	(0xF0)	/* enable all 32 bits */
-
-/* Simple structure for module */
-struct intel_cln_sb_dev{
-	struct pci_dev * pdev;
-	spinlock_t slock;
-	u8 initialized;
-};
-
-static struct intel_cln_sb_dev sb_dev = {
-	.initialized = 0
-};
-
-/* Dependant drivers */
-static struct platform_device pdev [] = {
-	{
-		.name = "intel-cln-esram",
-	},
-	{
-		.name = "intel-cln-ecc",
-	},
-	{
-		.name = "intel-cln-thrm",
-	},
-};
-
-/**
- * intel_cln_sb_read_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe read of side-band
- * command - can be different read op-code types - which is why we don't
- * hard-code this value directly into msg
- */
-void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock)
-{
-	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
-		  INTEL_CLN_SB_BYTEEN;
-
-	if(data == NULL)
-		return;
-
-	if (likely(lock == 1)) {
-		spin_lock(&sb_dev.slock);
-	}
-
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
-	pci_read_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
-
-	if(likely(lock == 1)){
-		spin_unlock(&sb_dev.slock);
-	}
-
-}
-EXPORT_SYMBOL(intel_cln_sb_read_reg);
-
-/**
- * intel_cln_sb_write_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe write of side-band
- */
-void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock)
-{
-	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
-		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
-		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
-		  INTEL_CLN_SB_BYTEEN;
-
-	if(likely(lock == 1)){
-		spin_lock(&sb_dev.slock);
-	}
-
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
-	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
-	
-	if(likely(lock == 1)){
-		spin_unlock(&sb_dev.slock);
-	}
-}
-EXPORT_SYMBOL(intel_cln_sb_write_reg);
-
-/**
- * intel_cln_sb_runfn_lock
- *
- * @param fn: Callback function - which requires side-band spinlock and !irq
- * @param arg: Callback argument
- * @return 0 on success < 0 on failure
- *
- * Runs the given function pointer inside of a call to the local spinlock using
- * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
- * guarantee atomicity, but, available to any other user of sideband provided
- * rules are respected.
- * Rules:
- *	fn may not sleep
- *	fn may not change the state of irqs	
- */
-int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg)
-{
-	unsigned long flags = 0;
-	int ret = 0;
-
-	if(unlikely(fn == NULL)){
-		return -EINVAL;
-	}
-	
-	/* Get spinlock with IRQs off */
-	spin_lock_irqsave(&sb_dev.slock, flags);
-
-	/* Run function atomically */
-	ret = fn(arg);
-
-	/* Release lock */
-	spin_unlock_irqrestore(&sb_dev.slock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL(intel_cln_sb_runfn_lock);
-
-/**
- * sb_probe
- *
- * @param dev: the PCI device matching
- * @param id: entry in the match table
- * @return 0
- *
- * Callback from PCI layer when dev/vendor ids match.
- * Sets up necessary resources
- */
-static int intel_cln_sb_probe(struct pci_dev *dev, const struct pci_device_id *id)
-{
-	int i = 0;
-
-	/* Init struct */
-	memset(&sb_dev, 0x00, sizeof(sb_dev));
-
-	/* Hook device */
-	sb_dev.pdev = dev;
-
-	/* Init locking structures */
-	spin_lock_init(&sb_dev.slock);
-
-	/* Set state */
-	sb_dev.initialized = 1;
-
-	/* Register side-band sub-ordinate drivers */
-	for (i = 0; i < sizeof(pdev)/sizeof(struct platform_device); i++){
-		/* Register side-band sub-ordinate drivers */
-		platform_device_register(&pdev[i]);
-	}
-	pr_info("Intel Clanton side-band driver registered\n");
-
-	/* Switch off boot-time IMRs nice and early */
-	return intel_cln_imr_init();
-}
-
-/**
- * sb_remove
- *
- * @param pdev: PCI device
- * @return nothing
- *
- * Callback from PCI sub-system upon PCI dev removal
- */
-static void intel_cln_sb_remove(struct pci_dev *pdev)
-{
-}
-
-/* Clanton hardware */
-struct pci_device_id intel_cln_sb_ids[] = {
-        { PCI_VDEVICE(INTEL, 0x0958), 0},
-        { 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, intel_cln_sb_ids);
-
-/* PCI callbacks */
-static struct pci_driver intel_cln_sb_driver = {
-	.name = "intel_cln_sb",
-	.id_table = intel_cln_sb_ids,
-	.probe = intel_cln_sb_probe,
-	.remove = intel_cln_sb_remove,
-};
-
-/**
- * intel_cln_sb_init
- *
- * Module entry point
- */
-static int __init intel_cln_sb_init(void)
-{
-	return pci_register_driver(&intel_cln_sb_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SOC side-band driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-/* Initialise early since other drivers eSRAM, DRAM ECC and thermal depend */
-subsys_initcall(intel_cln_sb_init);
diff --git a/drivers/platform/x86/quark/intel_cln_smep_test.c b/drivers/platform/x86/quark/intel_cln_smep_test.c
deleted file mode 100644
index 16f43db..0000000
--- a/drivers/platform/x86/quark/intel_cln_smep_test.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/**
- * intel_cln_smep_test.c
- *
- * Simple test module to verify SMEP works as expected on MIA
- * DO NOT RELEASE THIS FILE OUTSIDE OF CLANTON GROUP
- * DO NOT ATTEMPT TO UPSTREAM THIS CODE - YOU WILL BE PUBLICLY EMBARRSSED !
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@intel.com>
- *
- */
-#include <asm/processor.h>
-#include <asm/processor-flags.h>
-#include <linux/cdev.h>
-#include <linux/crc16.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#define DRIVER_NAME			"intel_cln_smep_test"
-
-/**
- * struct intel_cln_smep_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_cln_smep_test_dev{
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-	char * pdata;
-	u32 size;
-};
-
-static struct intel_cln_smep_test_dev smep_test_dev;
-static struct class *smep_test_class;
-static DEFINE_MUTEX(smep_test_mutex);
-static int smep_test_major;
-static char * name = "testmap";
-
-/**
- * smep_test_ioctl
- *
- * Allows user-space to command kernel switch SMEP on/off
- */
-static long smep_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int cr4 = 0;
-
-	cr4 = read_cr4();
-	printk(KERN_INFO "%s entry CR4 is 0x%08x\n", __FUNCTION__, cr4);
-
-	switch(cmd){
-		case 0:
-			printk(KERN_INFO "Switching SMEP off\n");
-			cr4 &= ~X86_CR4_SMEP;
-			
-			break;
-		case 1:
-			printk(KERN_INFO "Switching SMEP on\n");
-			cr4 |= X86_CR4_SMEP;
-			break;
-		default:
-			return -EINVAL;
-	}
-	/* Latch value */
-	write_cr4(cr4);
-
-	/* Print contents of CR4 */
-	cr4 = read_cr4();
-	printk(KERN_INFO "%s exit CR4 is 0x%08x\n", __FUNCTION__, cr4);
-	
-	return 0;
-}
-
-/**
- * smep_test_write
- *
- * Accepts a buffer from user-space and then tries to execute the contents
- * Be very careful
- */
-static ssize_t smep_test_write(struct file *file, const char __user *buf,
-						size_t count, loff_t *ppos)
-{
-	/* 
-	 * We assume we are passed a pointer to function of type
-	 * void fn(void)
-	 */
-	void (*fn)(void) = (void(*))buf;
-	if (count) {
-		printk(KERN_INFO "Will attempt exec %d bytes of ring3 code @ 0x%p\n",
-			count, buf);
-		fn();
-		printk(KERN_INFO "Exec of data @ 0x%p complete\n", buf);
-	}
-	return count;
-}
-
-static int smep_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&smep_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&smep_test_dev.open_lock)) {
-		mutex_unlock(&smep_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (smep_test_dev.opened) {
-		mutex_unlock(&smep_test_dev.open_lock);
-		mutex_unlock(&smep_test_mutex);
-		return -EINVAL;
-	}
-
-	smep_test_dev.opened++;
-	mutex_unlock(&smep_test_dev.open_lock);
-	mutex_unlock(&smep_test_mutex);
-	return 0;
-}
-
-static int smep_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&smep_test_dev.open_lock);
-	smep_test_dev.opened = 0;
-	mutex_unlock(&smep_test_dev.open_lock);
-
-	return 0;
-}
-
-
-
-static const struct file_operations smep_test_file_ops = {
-	.open = smep_test_open,
-	.release = smep_test_release,
-	.unlocked_ioctl = smep_test_ioctl,
-	.write		= smep_test_write,
-	.llseek = no_llseek,
-};
-
-
-/**
- * intel_cln_smep_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_cln_smep_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&smep_test_dev.open_lock);
-	cdev_init(&smep_test_dev.cdev, &smep_test_file_ops);
-	smep_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&smep_test_dev.cdev, MKDEV(smep_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(smep_test_class, NULL,
-				 MKDEV(smep_test_major, minor), NULL,
-				 "smeptest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-	printk(KERN_INFO "%s complete OK - device /dev/smeptest%u\n", __FUNCTION__, minor);
-	return 0;
-
-}
-
-/**
- * intel_cln_smep_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_smep_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(smep_test_dev.cdev.dev);
-
-	device_destroy(smep_test_class, MKDEV(smep_test_major, minor));
-	cdev_del(&smep_test_dev.cdev);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_smep_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_cln_smep_test_remove,
-};
-
-/**
- * intel_cln_smep_init
- *
- * @return 0 success < 0 failure
- *
- * Module entry point
- */
-static int __init intel_cln_smep_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	smep_test_class = class_create(THIS_MODULE,"cln_smep_test");
-	if (IS_ERR(smep_test_class)) {
-		retval = PTR_ERR(smep_test_class);
-		printk(KERN_ERR "smep_test: can't register earam_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "smep_test");
-	if (retval) {
-		printk(KERN_ERR "smep_test: can't register character device\n");
-		goto err_class;
-	}
-	smep_test_major = MAJOR(dev);
-
-	memset(&smep_test_dev, 0x00, sizeof(smep_test_dev));
-	smep_test_dev.pldev = platform_create_bundle(
-		&intel_cln_smep_test_driver, intel_cln_smep_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(smep_test_dev.pldev)){
-		printk(KERN_ERR "smep_test platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(smep_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(smep_test_class);
-err:
-	return retval;
-}
-
-/**
- * intel_cln_smep_exit
- *
- * Module exit
- */
-static void __exit intel_cln_smep_test_exit(void)
-{
-	platform_device_unregister(smep_test_dev.pldev);
-	platform_driver_unregister(&intel_cln_smep_test_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton SMEP test");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_init(intel_cln_smep_test_init);
-module_exit(intel_cln_smep_test_exit);
diff --git a/drivers/platform/x86/quark/intel_cln_thermal.c b/drivers/platform/x86/quark/intel_cln_thermal.c
deleted file mode 100644
index 0e83a55..0000000
--- a/drivers/platform/x86/quark/intel_cln_thermal.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton Thermal driver
- */
-#include <linux/err.h>
-#include <linux/fs.h>
-#include <linux/intel_cln_sb.h>
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/printk.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/thermal.h>
-#include <linux/timer.h>
-
-#define DRIVER_NAME		"intel-cln-thrm"
-
-/* Definition of register locations for thermal management */
-#define THRM_CTRL_REG		(0x80)		/* Thermal control */
-#define THRM_MODE_REG		(0xB0)		/* Thermal mode */
-#define THRM_MODE_SENSOR_EN	(0x00008000)	/* Thermal mode sensor enable */
-#define THRM_TEMP_REG		(0xB1)		/* Thermal sensor temperature */
-#define THRM_TRPCLR_REG		(0xB2)		/* Catastropic/Hot trip/clear */
-#define THRM_AUXTRP_REG		(0xB3)		/* Aux0-Aux3 trip point */
-#define THRM_AUXCLR_REG		(0xB4)		/* Aux0-Aux3 clear trip */
-#define THRM_STATUS_REG		(0xB5)		/* Thermal sensor status */
-#define THRM_TRIPBEHAVE_REG	(0xB6)		/* Trip point behavior */
-#define THRM_MSIADDR_REG	(0xC5)		/* Thermal MSI addres reg */
-#define THRM_MSIDATA_REG	(0xC6)		/* Thermal MSI data reg */
-#define THRM_CTRL_READ		(0x10)		/* Config reg */
-#define THRM_CTRL_WRITE		(0x11)		/* Config reg */
-
-#define SOC_TSENSOR_REG		(0x34)
-#define SOC_TSENSOR_RST		(0x00000001)
-#define SOC_CTRL_READ		(0x06)
-#define SOC_CTRL_WRITE		(0x07)
-
-
-#define THRM_ZONE_COUNT		2		/* Only hot/critical relevant */
-#define ACTIVE_INTERVAL		(1000)
-#define IDLE_INTERVAL		(20000)
-#define MCELSIUS(x)		((x) * 1000)
-
-/* CPU Zone information */
-#define CATASTROPIC_ZONE	0
-#define HOT_ZONE		1
-#define AUX0_ZONE		2		/* Unused */
-#define AUX1_ZONE		3		/* Unused */
-#define AUX2_ZONE		4		/* Unused */
-#define AUX3_ZONE		5		/* Unused */
-#define MIN_USED_ZONE		CATASTROPIC_ZONE
-#define MAX_USED_ZONE		HOT_ZONE
-/*
- * Default catastrophic/hot trip values - in degrees celsius
- * Maximum temperature is 105 degrees
- */
-#define CRIT_TEMP	104
-#define HOT_TEMP	95
-#define RAW2CELSIUS_DIFF	50
-
-static int driver_enable = 1;
-module_param(driver_enable, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(driver_enable, "Disable Thermal Driver Polling");
-
-/* Shorten fn names to fit 80 char limit */
-#ifndef sb_read
-#define sb_read				intel_cln_sb_read_reg
-#endif
-#ifndef sb_write
-#define sb_write			intel_cln_sb_write_reg
-#endif
-
-struct intel_cln_therm_zone {
-	enum thermal_trip_type type;
-	int trip_value;
-};
-
-/**
- * struct intel_cln_thermal_dev
- *
- */
-struct intel_cln_thermal_dev {
-	enum thermal_device_mode mode;
-	struct intel_cln_therm_zone tzone[THRM_ZONE_COUNT];
-	struct mutex lock;
-	struct platform_device *pldev;		/* Platform device */
-	struct thermal_zone_device *therm_dev;	/* Thermal device */
-};
-
-static struct intel_cln_thermal_dev cln_tdev;
-
-/******************************************************************************
- *                        Thermal API implementation
- ******************************************************************************/
-
-/**
- * get_temp
- *
- * @param tz: Thermal zone descriptor
- *
- * Get the current temperature
- * We have exactly one thermal zone/sensor
- * Value passed is an unsigned long - our sensor reports up to -50 celsius so we
- * just clip at zero if the temperature is negative.
- */
-static int intel_cln_thermal_get_temp(struct thermal_zone_device *tz,
-				unsigned long *temp)
-{
-	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TEMP_REG, (u32 *)temp, 1);
-	*temp -= RAW2CELSIUS_DIFF;
-
-	/* Clip to unsigned output value if sensor is reporting sub-zero */
-	if ((int)*temp < 0)
-		*temp = 0;
-
-	*temp = MCELSIUS(*temp&0x000000FF);
-
-	return 0;
-}
-
-/**
- * get_trend
- *
- * Wears good clothes
- */
-static int intel_cln_thermal_get_trend(struct thermal_zone_device *tz,
-			int trip, enum thermal_trend *trend)
-{
-	if (tz->temperature >= trip)
-		*trend = THERMAL_TREND_RAISING;
-	else
-		*trend = THERMAL_TREND_DROPPING;
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_mode
- *
- * Get the mode
- */
-static int intel_cln_thermal_get_mode(struct thermal_zone_device *tz,
-				enum thermal_device_mode *mode)
-{
-	mutex_lock(&cln_tdev.lock);
-	*mode = cln_tdev.mode;
-	mutex_unlock(&cln_tdev.lock);
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_set_mode
- *
- * Set the mode
- */
-static int intel_cln_thermal_set_mode(struct thermal_zone_device *tz,
-				enum thermal_device_mode mode)
-{
-	mutex_lock(&cln_tdev.lock);
-
-	if (mode == THERMAL_DEVICE_ENABLED)
-		cln_tdev.therm_dev->polling_delay = IDLE_INTERVAL;
-	else
-		cln_tdev.therm_dev->polling_delay = 0;
-	cln_tdev.mode = mode;
-
-	mutex_unlock(&cln_tdev.lock);
-
-	thermal_zone_device_update(cln_tdev.therm_dev);
-	pr_info("thermal polling set for duration=%d msec\n",
-				cln_tdev.therm_dev->polling_delay);
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_type
- *
- * Get trip type
- */
-static int intel_cln_thermal_get_trip_type(struct thermal_zone_device *tz,
-				int trip, enum thermal_trip_type *type)
-{
-	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
-		return -EINVAL;
-
-	*type = cln_tdev.tzone[trip].type;
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_temp
- *
- * Get trip temp
- */
-static int intel_cln_thermal_get_trip_temp(struct thermal_zone_device *tz,
-				int trip, unsigned long *temp)
-{
-	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
-		return -EINVAL;
-
-	/* Convert the temperature into millicelsius */
-	*temp = cln_tdev.tzone[trip].trip_value;
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_get_trip_type
- *
- * Get trip temp
- */
-static int intel_cln_thermal_get_crit_temp(struct thermal_zone_device *tz,
-				unsigned long *temp)
-{
-	/* Critical zone */
-	*temp = cln_tdev.tzone[CATASTROPIC_ZONE].trip_value;
-	return 0;
-}
-
-static struct thermal_zone_device_ops intel_cln_thrm_dev_ops = {
-	.get_temp = intel_cln_thermal_get_temp,
-	.get_trend = intel_cln_thermal_get_trend,
-	.get_mode = intel_cln_thermal_get_mode,
-	.set_mode = intel_cln_thermal_set_mode,
-	.get_trip_type = intel_cln_thermal_get_trip_type,
-	.get_trip_temp = intel_cln_thermal_get_trip_temp,
-	.get_crit_temp = intel_cln_thermal_get_crit_temp,
-};
-
-
-
-/**
- * intel_cln_init_zone
- *
- * Initialise a zone
- */
-static void intel_cln_thermal_init_zone(struct intel_cln_therm_zone *tz,
-				enum thermal_trip_type type, int trip_value)
-{
-	tz->type = type;
-	tz->trip_value = MCELSIUS(trip_value);
-}
-
-/******************************************************************************
- *                        Module Entry/Exit hooks
- ******************************************************************************/
-
-/**
- * intel_cln_thermal_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This routine registers a thermal device with the kernel's thermal management
- * sub-system
- */
-static int intel_cln_thermal_probe(struct platform_device *pdev)
-{
-	int err = 0;
-	int critical_temp = 0, hot_temp = 0;
-	uint32_t regval = 0;
-
-	if (driver_enable == 0)
-		return 0;
-
-	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
-
-	critical_temp = CRIT_TEMP;
-	hot_temp = HOT_TEMP;
-
-	/* Enumerate zone type data */
-	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
-	mutex_init(&cln_tdev.lock);
-
-	/* Set initial state disabled */
-	cln_tdev.mode = THERMAL_DEVICE_ENABLED;
-
-	intel_cln_thermal_init_zone(&cln_tdev.tzone[CATASTROPIC_ZONE],
-				  THERMAL_TRIP_CRITICAL, critical_temp);
-	intel_cln_thermal_init_zone(&cln_tdev.tzone[HOT_ZONE],
-				  THERMAL_TRIP_HOT, hot_temp);
-
-	/* Register a thermal zone */
-	cln_tdev.therm_dev = thermal_zone_device_register(DRIVER_NAME,
-			THRM_ZONE_COUNT, NULL, &intel_cln_thrm_dev_ops,
-			0, 0, IDLE_INTERVAL, ACTIVE_INTERVAL);
-
-	if (IS_ERR(cln_tdev.therm_dev)) {
-		err = PTR_ERR(cln_tdev.therm_dev);
-		return err;
-	}
-
-	/* Read the BIOS configured hardware catastrophic trip temp */
-	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TRPCLR_REG, &regval, 1);
-	regval = (regval & 0xff) - 50;
-
-	pr_info("THRM: critical reset %d c hot %d c hardware failover %d c\n",
-		critical_temp, hot_temp, regval);
-
-	return 0;
-}
-
-/**
- * intel_cln_thermal_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_cln_thermal_remove(struct platform_device *pdev)
-{
-	if (cln_tdev.therm_dev != NULL) {
-		thermal_zone_device_unregister(cln_tdev.therm_dev);
-		return 0;
-	}
-	return -EINVAL;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_cln_thermal_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.probe = intel_cln_thermal_probe,
-	.remove = intel_cln_thermal_remove,
-};
-
-module_platform_driver(intel_cln_thermal_driver);
-
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Clanton Thermal driver");
-MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/intel_qrk_audio_ctrl.c b/drivers/platform/x86/quark/intel_qrk_audio_ctrl.c
new file mode 100644
index 0000000..ffc3791
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_audio_ctrl.c
@@ -0,0 +1,514 @@
+/*
+ * Intel Quark platform audio control driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * The Intel Clanton Hill platform hardware design includes an audio subsystem
+ * with a number of interconnected audio interfaces.  This driver enables
+ * applications to choose which audio connections to enable for various
+ * application use cases.  The interconnections are selectable using GPIO output
+ * pins on the CPU.  This driver is also responsible for configuring a Maxim
+ * 9867 audio codec, a component of this audio subsystem, connected to the CPU
+ * via I2C.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <uapi/linux/ioctl.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+
+#include "intel_qrk_audio_ctrl.h"
+
+#define DRIVER_NAME			"intel_qrk_audio_ctrl"
+
+/*
+ * GPIO numbers to use for switching audio paths
+ */
+#define GPIO_AUDIO_S0   11
+#define GPIO_AUDIO_S1   12
+#define GPIO_AUDIO_S2   13
+
+#define GPIO_AUDIO_DEFAULT (INTEL_QRK_AUDIO_MODE_SPKR_MIC)
+
+/**
+ * struct intel_qrk_audio_ctrl_data
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_qrk_audio_ctrl_priv {
+
+	/* i2c device descriptor for read/write access to MAX9867 registers */
+	struct i2c_client *max9867_i2c;
+
+	/* Char dev to provide user-space ioctl interface for audio control */
+	struct cdev cdev;
+	dev_t cdev_no;
+	struct class *cl;
+
+	/* Mutex to protect against concurrent access to the ioctl() handler */
+	struct mutex lock;
+
+	/* Current GPIO switch value */
+	unsigned char gpio_val;
+};
+
+static int
+intel_qrk_audio_ctrl_open(struct inode *inode, struct file *filp)
+{
+	struct intel_qrk_audio_ctrl_priv *priv;
+
+	priv = container_of(inode->i_cdev,
+			    struct intel_qrk_audio_ctrl_priv,
+			    cdev);
+	filp->private_data = priv;
+
+	return 0;
+}
+
+static int
+intel_qrk_audio_ctrl_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/*
+ * Logic truth table for AUDIO_S[0-3] outputs, illustrating which paths are
+ * connected between audio interfaces A, B, C.  Each audio interface has one
+ * effective input (I) port and one effective output (O) port
+ *
+ * A = USB Codec (to Quark CPU)
+ * B = Spkr/Mic  (to car audio system)
+ * C = I2S Codec (to Telit HE910)
+ *
+ * PATH examples:
+ *   AO-CO: A-Output connected to C-Output
+ *   BI-AI: B-Input connected to A-Input
+ *
+ * NOTE: Assume a CI-AI connection is available in ALL cases (sometimes unused)
+ *
+ * S2 S1 S0  PATHS             USE CASE
+ * -- -- --  ----------------- -------------------------------------------------
+ *  0  0  0  AO-CO             BT Headset call
+ *  0  0  1  AO-BO             Analog Driver Alerts (CI unused)
+ *  0  1  0  AO-CO,BI-AI       XX Unused/invalid (BI *and* CI connected to AI)
+ *  0  1  1  AO-BO,BI-AI       Archival Voice Record/Playback (or Driver Alerts)
+ *  1  0  0  AO-CO,BI-CO       XX Unused/invalid (A0 *and* BI connected to CO)
+ *  1  0  1  AO-BO,BI-CO       Analog hands-free call
+ *  1  1  0  AO-CO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
+ *  1  1  1  AO-BO,BI-AI,BI-CO XX Unused/invalid (BI connected to AI *and* CO)
+ *
+ *
+ * Mapping to IOCTLs (using more intuitive naming on the API):
+ *
+ * PATHS           IOCTL
+ * --------------- -------------------------------------------------------------
+ * AO-CO           INTEL_QRK_AUDIO_MODE_GSM_ONLY
+ * AO-BO           INTEL_QRK_AUDIO_MODE_SPKR_ONLY
+ * AO-BO,BI-AI     INTEL_QRK_AUDIO_MODE_SPKR_MIC
+ * AO-BO,BI-CO     INTEL_QRK_AUDIO_MODE_GSM_SPKR_MIC
+ */
+
+static int
+intel_qrk_audio_ctrl_gpio_update(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	int ret = 0;
+	struct gpio audio_sw_gpios[] = {
+		{
+			GPIO_AUDIO_S2,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s2"
+		},
+		{
+			GPIO_AUDIO_S1,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s1"
+		},
+		{
+			GPIO_AUDIO_S0,
+			GPIOF_OUT_INIT_LOW,
+			"audio_s0"
+		}
+	};
+
+	/*
+	 * Update the Audio Switch GPIO outputs according to the user selection
+	 */
+	ret = gpio_request_array(audio_sw_gpios,
+				 ARRAY_SIZE(audio_sw_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate audio control GPIO pins\n",
+		       __func__);
+		return ret;
+	}
+
+	gpio_set_value(GPIO_AUDIO_S2, (priv->gpio_val >> 2) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S1, (priv->gpio_val >> 1) & 0x1);
+	gpio_set_value(GPIO_AUDIO_S0, (priv->gpio_val >> 0) & 0x1);
+
+	gpio_free_array(audio_sw_gpios,
+			ARRAY_SIZE(audio_sw_gpios));
+
+	return 0;
+}
+
+static long
+intel_qrk_audio_ctrl_ioctl(struct file *filp,
+			   unsigned int cmd,
+			   unsigned long arg)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = filp->private_data;
+	int ret = 0;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case INTEL_QRK_AUDIO_MODE_IOC_GSM_ONLY:
+	case INTEL_QRK_AUDIO_MODE_IOC_SPKR_ONLY:
+	case INTEL_QRK_AUDIO_MODE_IOC_SPKR_MIC:
+	case INTEL_QRK_AUDIO_MODE_IOC_GSM_SPKR_MIC:
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	priv->gpio_val = _IOC_NR(cmd) & 0x7;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+static const struct file_operations intel_qrk_audio_ctrl_fops = {
+	.owner = THIS_MODULE,
+	.open = intel_qrk_audio_ctrl_open,
+	.release = intel_qrk_audio_ctrl_release,
+	.unlocked_ioctl = intel_qrk_audio_ctrl_ioctl
+};
+
+static int
+intel_qrk_audio_ctrl_chrdev_init(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	/* Register a character dev interface (with ioctls)
+	 * to allow control of the audio subsystem switch
+	 */
+	int ret;
+	struct device *dev;
+
+	ret = alloc_chrdev_region(&priv->cdev_no, 0, 1,
+				  "intel_qrk_audio_ctrl");
+	if (ret) {
+		pr_err("Failed to alloc chrdev: %d", ret);
+		return ret;
+	}
+
+	cdev_init(&priv->cdev, &intel_qrk_audio_ctrl_fops);
+
+	ret = cdev_add(&priv->cdev, priv->cdev_no, 1);
+	if (ret) {
+		pr_err("Failed to add cdev: %d", ret);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return ret;
+	}
+
+	priv->cl = class_create(THIS_MODULE, "char");
+	if (IS_ERR(priv->cl)) {
+		pr_err("Failed to create device class: %ld",
+		       PTR_ERR(priv->cl));
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(priv->cl);
+	}
+
+	dev = device_create(priv->cl, NULL, priv->cdev_no, NULL,
+			    "intel_qrk_audio_ctrl");
+	if (IS_ERR(dev)) {
+		pr_err("Failed to create device: %ld",
+		       PTR_ERR(priv->cl));
+		class_destroy(priv->cl);
+		cdev_del(&priv->cdev);
+		unregister_chrdev_region(priv->cdev_no, 1);
+		return PTR_ERR(dev);
+	}
+
+	return 0;
+}
+
+static int
+intel_qrk_audio_ctrl_chrdev_remove(struct intel_qrk_audio_ctrl_priv *priv)
+{
+	device_destroy(priv->cl, priv->cdev_no);
+	class_destroy(priv->cl);
+	cdev_del(&priv->cdev);
+	unregister_chrdev_region(priv->cdev_no, 1);
+
+	return 0;
+}
+
+
+ssize_t intel_qrk_audio_ctrl_sysfs_show_mode(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	int ret;
+	char *mode;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	switch (priv->gpio_val) {
+	case INTEL_QRK_AUDIO_MODE_GSM_ONLY:
+		mode = "gsm";
+		break;
+	case INTEL_QRK_AUDIO_MODE_SPKR_ONLY:
+		mode = "spkr";
+		break;
+	case INTEL_QRK_AUDIO_MODE_SPKR_MIC:
+		mode = "spkr_mic";
+		break;
+	case INTEL_QRK_AUDIO_MODE_GSM_SPKR_MIC:
+		mode = "gsm_spkr_mic";
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	ret = scnprintf(buf, PAGE_SIZE, "%s\n", mode);
+
+exit:
+	mutex_unlock(&priv->lock);
+	return ret;
+}
+
+ssize_t intel_qrk_audio_ctrl_sysfs_store_mode(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t count)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = dev_get_drvdata(dev);
+	char mode[16];
+	unsigned char gpio_val;
+	int ret = count;
+
+	sscanf(buf, "%15s", mode);
+
+	if (!strcmp(mode, "gsm"))
+		gpio_val = INTEL_QRK_AUDIO_MODE_GSM_ONLY;
+	else if (!strcmp(mode, "spkr"))
+		gpio_val = INTEL_QRK_AUDIO_MODE_SPKR_ONLY;
+	else if (!strcmp(mode, "spkr_mic"))
+		gpio_val = INTEL_QRK_AUDIO_MODE_SPKR_MIC;
+	else if (!strcmp(mode, "gsm_spkr_mic"))
+		gpio_val = INTEL_QRK_AUDIO_MODE_GSM_SPKR_MIC;
+	else
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&priv->lock);
+	if (ret)
+		return ret;
+
+	priv->gpio_val = gpio_val;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+	if (ret)
+		goto exit;
+
+	ret = count;
+
+exit:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+/* Sysfs attribute descriptor (for alternative user-space interface) */
+static DEVICE_ATTR(audio_switch_mode, S_IWUSR | S_IRUGO,
+		   intel_qrk_audio_ctrl_sysfs_show_mode,
+		   intel_qrk_audio_ctrl_sysfs_store_mode);
+
+/******************************************************************************
+ *                                Module hooks
+ ******************************************************************************/
+
+static int
+intel_qrk_max9867_init(struct i2c_client *client)
+{
+	int ret;
+
+	/* MAX9867 register configuration, from Telit HE910 DVI app-note */
+
+	u8 reg_cfg_seq1[] = {
+		0x04, /* Starting register address, followed by data */
+		0x00, /* 0x04 Interrupt Enable */
+		0x10, /* 0x05 System Clock */
+		0x90, /* 0x06 Audio Clock High */
+		0x00, /* 0x07 Audio Clock Low */
+		0x10, /* 0x08 Interface 1a */
+		0x0A, /* 0x09 Interface 1d */
+		0x33, /* 0x0A Codec Filters */
+		0x00, /* 0x0B DAC Gain/Sidetone */
+		0x00, /* 0x0C DAC Level */
+		0x33, /* 0x0D ADC Level */
+		0x4C, /* 0x0E Left Line Input Level */
+		0x4C, /* 0x0F Right Line Input Level */
+		0x00, /* 0x10 Left Volume Control */
+		0x00, /* 0x11 Right Volume Control */
+		0x14, /* 0x12 Left Mic Gain */
+		0x14, /* 0x13 Right Mic Gain */
+		/* Configuration */
+		0xA0, /* 0x14 Input */
+		0x00, /* 0x15 Microphone */
+		0x65  /* 0x16 Mode */
+	};
+
+	u8 reg_cfg_seq2[] = {
+		0x17, /* Starting register address, followed by data */
+		0xEF  /* 0x17 System Shutdown */
+	};
+
+	ret = i2c_master_send(client,
+			      reg_cfg_seq1, sizeof(reg_cfg_seq1));
+	if (ret != sizeof(reg_cfg_seq1)) {
+		pr_err("Failed to write MAX9867 config registers (set 1/2)");
+		return -EIO;
+	}
+
+	ret = i2c_master_send(client,
+			      reg_cfg_seq2, sizeof(reg_cfg_seq2));
+	if (ret != sizeof(reg_cfg_seq2)) {
+		pr_err("Failed to write MAX9867 config registers (set 2/2)");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int
+intel_qrk_max9867_get_chip_rev(struct i2c_client *client)
+{
+	struct i2c_msg msg[2];
+	u8 data[2];
+	int ret;
+
+	data[0] = 0xFF;  /* Chip-revision register address = 0xFF */
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].buf = &data[0];
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = &data[1];
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+	return (ret == 2) ? data[1] : -EIO;
+}
+
+static int intel_qrk_max9867_i2c_probe(struct i2c_client *client,
+				       const struct i2c_device_id *id)
+{
+	struct intel_qrk_audio_ctrl_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv),
+			    GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+
+	priv->max9867_i2c = client;
+	mutex_init(&priv->lock);
+
+	ret = intel_qrk_max9867_get_chip_rev(client);
+	if (ret >= 0)
+		pr_info("%s: Detected MAX9867 chip revision 0x%02X\n",
+			__func__, ret);
+	else {
+		pr_err("%s: Failed to read MAX9867 chip revision\n", __func__);
+		goto exit;
+	}
+
+	ret = intel_qrk_max9867_init(client);
+	if (ret)
+		goto exit;
+
+	priv->gpio_val = GPIO_AUDIO_DEFAULT;
+	ret = intel_qrk_audio_ctrl_gpio_update(priv);
+	if (ret)
+		goto exit;
+
+	/* Create a char dev interface, providing an ioctl config option */
+	ret = intel_qrk_audio_ctrl_chrdev_init(priv);
+	if (ret)
+		goto exit;
+
+	/* Also create a sysfs interface, providing a cmd line config option */
+	ret = sysfs_create_file(&client->dev.kobj,
+				&dev_attr_audio_switch_mode.attr);
+
+exit:
+	return ret;
+}
+
+static int intel_qrk_max9867_i2c_remove(struct i2c_client *client)
+{
+	struct intel_qrk_audio_ctrl_priv *priv = i2c_get_clientdata(client);
+
+	intel_qrk_audio_ctrl_chrdev_remove(priv);
+
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_audio_switch_mode.attr);
+
+	return 0;
+}
+
+static const struct i2c_device_id intel_qrk_max9867_i2c_id[] = {
+	{"intel-qrk-max9867", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, intel_qrk_max9867_i2c_id);
+
+/* i2c codec control layer */
+static struct i2c_driver intel_qrk_audio_ctrl_i2c_driver = {
+	.driver = {
+		.name = "intel_qrk_audio_ctrl",
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_qrk_max9867_i2c_probe,
+	.remove =  intel_qrk_max9867_i2c_remove,
+	.id_table = intel_qrk_max9867_i2c_id,
+};
+
+module_i2c_driver(intel_qrk_audio_ctrl_i2c_driver);
+
+MODULE_AUTHOR("Dan O'Donovan <dan@emutex.com>");
+MODULE_DESCRIPTION("Intel Quark platform audio control driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/platform/x86/quark/intel_qrk_audio_ctrl.h b/drivers/platform/x86/quark/intel_qrk_audio_ctrl.h
new file mode 100644
index 0000000..581d0e2
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_audio_ctrl.h
@@ -0,0 +1,45 @@
+/*
+ * Intel Quark platform audio control driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ * See intel_qrk_audio_ctrl.c for a detailed description
+ *
+ */
+
+#ifndef __INTEL_QRK_AUDIO_CTRL_H__
+#define __INTEL_QRK_AUDIO_CTRL_H__
+
+#include <linux/module.h>
+
+#define INTEL_QRK_AUDIO_MODE_GSM_ONLY       0x0
+#define INTEL_QRK_AUDIO_MODE_SPKR_ONLY      0x1
+#define INTEL_QRK_AUDIO_MODE_SPKR_MIC       0x3
+#define INTEL_QRK_AUDIO_MODE_GSM_SPKR_MIC   0x5
+
+#define INTEL_QRK_AUDIO_MODE_IOC_GSM_ONLY \
+	_IO('x', INTEL_QRK_AUDIO_MODE_GSM_ONLY)
+#define INTEL_QRK_AUDIO_MODE_IOC_SPKR_ONLY \
+	_IO('x', INTEL_QRK_AUDIO_MODE_SPKR_ONLY)
+#define INTEL_QRK_AUDIO_MODE_IOC_SPKR_MIC \
+	_IO('x', INTEL_QRK_AUDIO_MODE_SPKR_MIC)
+#define INTEL_QRK_AUDIO_MODE_IOC_GSM_SPKR_MIC \
+	_IO('x', INTEL_QRK_AUDIO_MODE_GSM_SPKR_MIC)
+
+#endif /* __INTEL_QRK_AUDIO_CTRL_H__ */
diff --git a/drivers/platform/x86/quark/intel_qrk_board_data.c b/drivers/platform/x86/quark/intel_qrk_board_data.c
new file mode 100644
index 0000000..db7f76a
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_board_data.c
@@ -0,0 +1,260 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark Legacy Platform Data accessor layer
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/dmi.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define DRIVER_NAME				"board_data"
+#define PFX					"MFH: "
+#define SPIFLASH_BASEADDR			0xFFF00000
+#define MFH_OFFSET				0x00008000
+#define PLATFORM_DATA_OFFSET			0x00010000
+#define MTD_PART_OFFSET				0x00050000
+#define MTD_PART_LEN				0x00040000
+#define MFH_PADDING				0x1E8
+#define MFH_MAGIC				0x5F4D4648
+#define FLASH_SIZE				0x00400000
+
+/* MFH types supported @ version #1 */
+#define MFH_ITEM_FW_STAGE1			0x00000000
+#define MFH_ITEM_FW_STAGE1_SIGNED		0x00000001
+#define MFH_ITEM_FW_STAGE2			0x00000003
+#define MFH_ITEM_FW_STAGE2_SIGNED		0x00000004
+#define MFH_ITEM_FW_STAGE2_CONFIG		0x00000005
+#define MFH_ITEM_FW_STAGE2_CONFIG_SIGNED	0x00000006
+#define MFH_ITEM_FW_PARAMS			0x00000007
+#define MFH_ITEM_FW_RECOVERY			0x00000008
+#define MFH_ITEM_FW_RECOVERY_SIGNED		0x00000009
+#define MFH_ITEM_BOOTLOADER			0x0000000B
+#define MFH_ITEM_BOOTLOADER_SIGNED		0x0000000C
+#define MFH_ITEM_BOOTLOADER_CONFIG		0x0000000D
+#define MFH_ITEM_BOOTLOADER_CONFIG_SIGNED	0x0000000E
+#define MFH_ITEM_KERNEL				0x00000010
+#define MFH_ITEM_KERNEL_SIGNED			0x00000011
+#define MFH_ITEM_RAMDISK			0x00000012
+#define MFH_ITEM_RAMDISK_SIGNED			0x00000013
+#define MFH_ITEM_LOADABLE_PROGRAM		0x00000015
+#define MFH_ITEM_LOADABLE_PROGRAM_SIGNED	0x00000016
+#define MFH_ITEM_BUILD_INFO			0x00000018
+#define MFH_ITEM_VERSION			0x00000019
+
+struct intel_qrk_mfh {
+	u32	id;
+	u32	ver;
+	u32	flags;
+	u32	next_block;
+	u32	item_count;
+	u32	boot_priority_list;
+	u8	padding[MFH_PADDING];
+};
+
+struct intel_qrk_mfh_item {
+	u32	type;
+	u32	addr;
+	u32	len;
+	u32	res0;
+};
+
+struct kobject * board_data_kobj;
+EXPORT_SYMBOL_GPL(board_data_kobj);
+
+static long unsigned int flash_version_data;
+static ssize_t flash_version_show(struct kobject *kobj,
+                                struct kobj_attribute *attr, char *buf)
+{
+        return snprintf(buf, 12, "%#010lx\n", flash_version_data);
+}
+
+static struct kobj_attribute flash_version_attr =
+        __ATTR(flash_version, 0644, flash_version_show, NULL);
+
+extern int intel_qrk_plat_probe(struct resource * pres);
+
+#define DEFAULT_BOARD "Galileo"
+
+static struct platform_device bsp_data [] = {
+	{
+		.name	= "QuarkEmulation",
+		.id	= -1,
+	},
+	{
+		.name	= "ClantonPeakSVP",
+		.id	= -1,
+	},
+	{
+		.name	= "KipsBay",
+		.id	= -1,
+	},
+	{
+		.name	= "CrossHill",
+		.id	= -1,
+	},
+	{
+		.name	= "ClantonHill",
+		.id	= -1,
+	},
+	{
+		.name	= "Galileo",
+		.id	= -1,
+	},
+
+};
+
+/**
+ * add_firmware_sysfs_entry
+ *
+ * Add an entry in sysfs consistent with Galileo IDE's expected location
+ * covers current software versions and legacy code < Intel Galileo BIOS 0.9.0
+ *
+ */
+static int add_firmware_sysfs_entry(const char * board_name)
+{
+	extern struct kobject * firmware_kobj;
+
+	pr_info("Intel Quark Board %s Firmware Version %#010lx\n",
+				board_name, flash_version_data);
+
+	/* board_data_kobj subordinate of firmware @ /sys/firmware/board_data */
+	board_data_kobj = kobject_create_and_add("board_data", firmware_kobj);
+	if (!board_data_kobj) {
+		pr_err(PFX"kset create error\n");
+		return -ENODEV;
+	}
+	return sysfs_create_file(board_data_kobj, &flash_version_attr.attr);
+}
+
+/**
+ * intel_qrk_board_data_init_legacy
+ *
+ * Module entry point for older BIOS versions
+ * Allows more recent kernels to boot on Galileo boards with BIOS before release
+ * 0.9.0
+ */
+static int __init intel_qrk_board_data_init_legacy(void)
+{
+	struct intel_qrk_mfh __iomem * mfh;
+	struct intel_qrk_mfh_item __iomem * item;
+	struct platform_device * pdev;
+	u32 i;
+	char * board_name = NULL;
+	void __iomem * spi_data;
+	int ret = 0;
+
+	spi_data = ioremap(SPIFLASH_BASEADDR, FLASH_SIZE);
+	if (!spi_data)
+		return -ENODEV;
+
+	/* get mfh and first item pointer */	
+	mfh = spi_data + MFH_OFFSET;
+	if (mfh->id != MFH_MAGIC){
+		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
+		MFH_MAGIC, mfh->id, &mfh->id);
+		return -ENODEV;
+	}
+
+	pr_info(PFX"Booting on an old BIOS assuming %s board\n", DEFAULT_BOARD);
+	pr_info(PFX"mfh @ 0x%p: id 0x%08lx ver 0x%08lx entries 0x%08lx\n",
+		mfh, (unsigned long)mfh->id, (unsigned long)mfh->ver,
+		(unsigned long)mfh->item_count);
+	item = (struct intel_qrk_mfh_item __iomem *)
+		&mfh->padding [sizeof(u32) * mfh->boot_priority_list];
+
+	/* Register a default board */
+	for (i = 0; i < sizeof(bsp_data)/sizeof(struct platform_device); i++){
+		if (!strcmp(bsp_data[i].name, DEFAULT_BOARD)){
+			board_name = (char*)bsp_data[i].name;
+			platform_device_register(&bsp_data[i]);
+		}
+	}
+
+	/* Register flash regions as seperate platform devices */
+	for (i = 0; i < mfh->item_count; i++, item++){
+		pdev = NULL;
+
+		switch (item->type){
+		case MFH_ITEM_VERSION:
+			flash_version_data = item->res0;
+			ret = add_firmware_sysfs_entry(board_name);
+			break;
+		default:
+			break;
+		}
+	}
+	iounmap(spi_data);
+	return ret;
+}
+
+/**
+ * intel_qrk_board_data_init_legacy
+ *
+ * Module entry point for older BIOS versions
+ */
+static int __init intel_qrk_board_data_init(void)
+{
+	bool found = false;
+	const char * bios_version = dmi_get_system_info(DMI_BIOS_VERSION);
+	const char * board_name = dmi_get_system_info(DMI_BOARD_NAME);
+	int ret = 0;
+	u32 i;
+
+	/* BIOS later than version 0.9.0 contains the right DMI data */
+	for (i = 0; board_name != NULL && bios_version != NULL && 
+		i < sizeof(bsp_data)/sizeof(struct platform_device); i++){
+	
+		if (!strcmp(bsp_data[i].name, board_name)){
+
+			/* Register board */
+			platform_device_register(&bsp_data[i]);
+			found = true;
+
+			/* Galileo IDE expects this entry */
+			flash_version_data = simple_strtoul(bios_version, NULL, 16);
+			ret = add_firmware_sysfs_entry(bsp_data[i].name);
+
+			break;
+		}
+	}
+
+	/* For older BIOS without DMI data we read the data directly from flash */
+	if (found == false){
+		ret = intel_qrk_board_data_init_legacy();
+	}
+
+	return ret;
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Quark SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+subsys_initcall(intel_qrk_board_data_init);
+
diff --git a/drivers/platform/x86/quark/intel_qrk_esram.c b/drivers/platform/x86/quark/intel_qrk_esram.c
new file mode 100644
index 0000000..55adb41
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_esram.c
@@ -0,0 +1,1144 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A sysfs interface is provided to allow map of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo idt_table > /sys/devices/intel-qrk-esram.0/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * intel_qrk_esram_map_sym(ohci_irq);
+ * intel_qrk_esram_map_page(virt_to_page(ohci_irq), "ohci_irq");
+ * Are equivalent - with the exception that map_sym() can detect if a mapping
+ * crosses a page-boundary, whereas map_page just maps one page. Generally use
+ * map_sym() for code and map_page() for data
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * Unmap code is included for reference however the cache coherency of unmap is
+ * not guaranteed so the functionality is not exported by this code
+ * 
+ */
+#include <asm/cacheflush.h>
+#include <asm/desc.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/special_insns.h>
+#include <asm-generic/uaccess.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+
+#include "intel_qrk_esram.h"
+
+#define DRIVER_NAME			"intel-qrk-esram"
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_qrk_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_qrk_sb_write_reg
+#endif
+
+/* Define size of pages, ECC scrub demark etc */
+#define MAX_PAGE_RETRIES		(100)
+#define MS_PER_HOUR			(3600000UL)
+#define ESRAM_PAGE_COUNT		INTEL_QRK_ESRAM_PAGE_COUNT
+#define ESRAM_PAGE_MASK			(0xFFFFF000)
+#define ESRAM_PAGE_SIZE			INTEL_QRK_ESRAM_PAGE_SIZE
+#define ESRAM_TOTAL_SIZE		(ESRAM_PAGE_COUNT * ESRAM_PAGE_SIZE)
+#define ECC_MAX_REFRESH_PERIOD		(48)
+#define ECC_DEFAULT_REFRESH_PERIOD	(24)
+#define ECC_DRAM_READSIZE		(512)		/* bytes per DRAM ECC */
+#define ECC_ESRAM_READSIZE		ESRAM_PAGE_SIZE	/* bytes per SRAM ECC */
+
+/* Register ID */
+#define ESRAM_PGPOOL_REG		(0x80)		/* PGPOOL */
+#define ESRAM_CTRL_REG			(0x81)		/* ESRAMCTRL */
+#define ESRAM_PGBLOCK_REG		(0x82)		/* Global page ctrl */
+#define ESCRM_ECCCERR_REG		(0x83)		/* Correctable ECC */
+#define ESRAM_ECCUCERR_REG		(0x84)		/* Uncorrectable ECC */
+
+/* Reg commands */
+#define ESRAM_CTRL_READ			(0x10)		/* Config reg */
+#define ESRAM_CTRL_WRITE		(0x11)		/* Config reg */
+#define ESRAM_PAGE_READ			(0x12)		/* Page config read */
+#define ESRAM_PAGE_WRITE		(0x13)		/* Page config write */
+
+/* ESRAMPGPOOL reg 0x80 - r/w opcodes 0x10/0x11 */
+#define ESRAM_PGPOOL_FLUSHING(x)	((x>>18)&0x1FF)
+#define ESRAM_PGPOOL_PGBUSY(x)		((x>>9)&0x1FF)
+
+/* ESRAMCTRL reg 0x81 - r/w opcodes 0x10/0x11 */
+#define ESRAM_CTRL_FLUSHPRI(x)		((x>>25)&0x03)	/* DRAM flush priority */
+#define ESRAM_CTRL_SIZE(x)		((x>>16)&0xFF)	/* # of 4k pages */
+#define ESRAM_CTRL_ECCTHRESH(x)		((x>>8)&0xFF)	/* ECC threshold */
+#define ESRAM_CTRL_THRESHMSG_EN		(0x00000080)	/* ECC notification */
+#define ESRAM_CTRL_ISAVAIL		(0x00000010)	/* ESRAM on die ? */
+#define ESRAM_CTRL_BLOCK_MODE		(0x00000008)	/* Block mode enable */
+#define ESRAM_CTRL_GLOBAL_LOCK		(0x00000004)	/* Global lock status */
+#define ESRAM_CTRL_FLUSHDISABLE		(0x00000002)	/* Global flush/dis */
+#define ESRAM_CTRL_SECDEC		(0x00000001)	/* ECC enable bit */
+
+/* PGBLOCK reg 0x82 - opcode 0x10/0x11 */
+#define ESRAM_PGBLOCK_FLUSHEN		(0x80000000)	/* Block flush enable */
+#define ESRAM_PGBLOCK_PGFLUSH		(0x40000000)	/* Flush the block */
+#define ESRAM_PGBLOCK_DISABLE		(0x20000000)	/* Block mode disable */
+#define ESRAM_PGBLOCK_ENABLE		(0x10000000)	/* Block mode enable */
+#define ESRAM_PGBLOCK_LOCK		(0x08000000)	/* Block mode lock en */
+#define ESRAM_PGBLOCK_INIT		(0x04000000)	/* Block init in prog */
+#define ESRAM_PGBLOCK_BUSY		(0x01000000)	/* Block is enabled */
+#define ESRAM_PGBLOCK_SYSADDR(x)	(x&0x000000FF)
+
+/* ESRAMPGCTRL - opcode 0x12/0x13 */
+#define ESRAM_PAGE_FLUSH_PAGE_EN	(0x80000000)	/* S3 autoflush */
+#define ESRAM_PAGE_FLUSH		(0x40000000)	/* Flush page to DRAM */
+#define ESRAM_PAGE_DISABLE		(0x20000000)	/* page disable bit */
+#define ESRAM_PAGE_EN			(0x10000000)	/* Page enable */
+#define ESRAM_PAGE_LOCK			(0x08000000)	/* Page lock en */
+#define ESRAM_PAGE_INITIALISING		(0x04000000)	/* Init in progress */
+#define ESRAM_PAGE_BUSY			(0x01000000)	/* Page busy */
+#define ESRAM_PAGE_MAP_SHIFT		(12)		/* Shift away 12 LSBs */
+
+/* Extra */
+#define ESRAM_MAP_OP			(0x01)
+#define ESRAM_UNMAP_OP			(0x00)
+
+/**
+ * struct esram_refname
+ *
+ * Structure to hold a linked list of names
+ */
+struct esram_refname {
+	char name[KSYM_SYMBOL_LEN];	/* Name of mapping */
+	struct list_head list;
+};
+
+/**
+ * struct esram_page
+ *
+ * Represents an eSRAM page in our linked list
+ */
+struct esram_page {
+
+	struct list_head list;		/* List entry descriptor */
+	struct list_head name_list;	/* Linked list for name references */
+	u32 id;				/* Page ID */
+	u32 phys_addr;			/* Physial address of page */
+	u32 refcount;			/* Reference count */
+	u32 vaddr;			/* Virtual address of page */
+
+};
+
+/**
+ * struct intel_qrk_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_qrk_esram_dev{
+
+	/* Linux kernel structures */
+	struct list_head page_used;	/* Used pages */
+	struct list_head page_free;	/* Free pages */
+	spinlock_t slock;		/* Spinlock */
+	struct platform_device *pldev;	/* Platform device */
+
+	/* Actual data */
+	struct esram_page * pages;
+	u8 cbuf[ESRAM_PAGE_SIZE];
+
+	/* Stats */
+	u32 page_count;			/* As reported by silicon */
+	u32 page_disable_retries;	/* Aggreate count on disable */
+	u32 page_enable_retries;	/* Aggregate spin count page enable */
+	u32 page_free_ct;		/* Free pages for mapping code section */
+};
+
+static struct intel_qrk_esram_dev esram_dev;
+
+/* 
+ * Kallsyms does not provide data addresses. To map important structures such as
+ * the idt and gdt, we need to frig the lookup with the below. Other entities
+ * can similarly be added. Note we map a page from the given address - anything
+ * larger will require additional code to handle
+ */
+struct esram_symex {
+	char * name;
+	void * vaddr;
+	u32 size;
+};
+
+static struct esram_symex esram_symex[] = 
+{
+	{
+		.name = "idt_table",
+		.vaddr = &idt_table,
+		.size = ESRAM_PAGE_SIZE,
+	},
+	{
+		.name = "gdt_page",
+		.vaddr = &gdt_page,
+		.size = ESRAM_PAGE_SIZE,
+	},
+};
+
+/**
+ * intel_qrk_esram_stat_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates eSRAM state via /sys/device/intel-qrk-esram.0/stat
+ */
+static ssize_t intel_qrk_esram_stat_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+
+{
+	struct esram_page * epage = NULL;
+	int len = 0;
+	unsigned int count = PAGE_SIZE, size;
+	u32 pgpool = 0, ctrl = 0, pgblock = 0;
+	char * enabled = "enabled";
+	char * disabled = "disabled";
+
+	/* Display page-pool relevant data */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGPOOL_REG, &pgpool, 1);
+	size = snprintf(buf, count,
+			"esram-pgpool\t\t\t: 0x%08x\n" 
+			"esram-pgpool.free\t\t: %u\n"
+			"esram-pgpool.flushing\t\t: %u\n",
+			pgpool,	ESRAM_PGPOOL_PGBUSY(pgpool)+1,
+			ESRAM_PGPOOL_FLUSHING(pgpool) + 1);
+	len += size;
+	count -= size;
+	
+	/* Display ctrl reg - most of this is of interest */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	size = snprintf(buf + len, count - len,
+			"esram-ctrl\t\t\t: 0x%08x\n"
+			"esram-ctrl.ecc\t\t\t: %s\n"
+			"esram-ctrl.ecc-theshold\t\t: %u\n"
+			"esram-ctrl.pages\t\t: %u\n"
+			"esram-ctrl.dram-flush-priorityi\t: %u\n",
+			ctrl, (ctrl & ESRAM_CTRL_SECDEC) ? enabled : disabled,
+			ESRAM_CTRL_ECCTHRESH(ctrl), ESRAM_CTRL_SIZE(ctrl)+1,
+			ESRAM_CTRL_FLUSHPRI(ctrl));
+	len += size;
+	count -= size;
+
+	/* Display block ctrl/stat - we should be !block mode */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &pgblock, 1);
+	size = snprintf(buf + len, count - len, "esram-block\t\t\t: 0x%08x\n",
+			pgblock);
+	len += size;
+	count -= size;
+
+	/* Print ECC status regs */
+
+	/* Print per-page info */
+	size = snprintf(buf + len, count - len, 
+			"free page\t\t\t: %u\nused page\t\t\t: %u\n"
+			"refresh  \t\t\t: %ums\npage enable retries\t\t: %u\n"
+			"page disable retries\t: %u\n",
+			esram_dev.page_free_ct, 
+			esram_dev.page_count-esram_dev.page_free_ct,
+			0,
+			esram_dev.page_enable_retries,
+			esram_dev.page_disable_retries);
+	len += size;
+	count -= size;
+
+	spin_lock(&esram_dev.slock);
+	if(!list_empty(&esram_dev.page_free)){
+
+		epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+		size = snprintf(buf + len, count - len, 
+			"ecc next page \t\t\t: %u\n",epage->id);
+		len += size;
+		count -= size;
+
+
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	return len;
+}
+
+/**
+ * intel_qrk_esram_map_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ * 
+ * Read back eSRAM mapped entries
+ */
+static ssize_t
+intel_qrk_esram_map_show(struct device *dev,struct device_attribute *attr,
+			 char *buf)
+{
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+	int len = 0, size = 0;
+	unsigned int count = PAGE_SIZE;
+
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		/* Print references */
+		list_for_each_entry(refname, &epage->name_list, list){
+			size = snprintf(buf + len, count - len,
+				"%s ", refname->name);
+			len += size;
+			count -= size;
+		}
+		/* Print data */
+		size += snprintf(buf + len, count - len,
+			"\n\tPage virt 0x%08x phys 0x%08x\n"
+			"\tRefcount %u\n",
+			epage->vaddr, epage->phys_addr,
+			epage->refcount);
+		len += size;
+		count -= size;
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	return len;
+}
+
+/**
+ * intel_qrk_esram_map_store
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: input buffer
+ * @param size: size of input data
+ * @return number of bytes successfully written
+ *
+ * Function allows user-space to switch mappings on/off with a simple
+ * echo idt_table > /sys/devices/intel-qrk-esram.0/map type command
+ */
+static ssize_t
+intel_qrk_esram_map_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	ssize_t ret = 0;
+	char * sbuf = NULL;
+	unsigned long vaddr = 0, i = 0;
+	unsigned int count = PAGE_SIZE;
+
+	if(count <= 1){
+		return -EINVAL;
+	}
+
+	/* Get input */
+	sbuf = (char*)buf;
+
+	/* Fixup entity to scrub spaces */
+	while(sbuf < (buf + count)){
+		if(*sbuf == ' ' || *sbuf == '\r' || *sbuf =='\n'){
+			*sbuf = 0;
+			break;
+		}
+		sbuf++;
+	}
+
+	/* Check to see if we are being asked to map a non-kallsyms addr */
+	for(i = 0; i < sizeof(esram_symex)/sizeof(struct esram_symex); i++){
+		if(strcmp(buf, esram_symex[i].name) == 0){
+			ret = intel_qrk_esram_map_range(
+				esram_symex[i].vaddr,
+				esram_symex[i].size,
+				esram_symex[i].name);
+			goto done;
+		}
+	}
+
+	/* This path relies on kallsyms to provide name/address data */
+	vaddr = kallsyms_lookup_name(buf);
+	if(vaddr == 0)
+		goto done;
+
+	ret = intel_qrk_esram_map_symbol((void*)vaddr);
+done:
+	if(ret == 0)
+		ret = (ssize_t)count;
+	return ret;
+}
+
+static struct device_attribute dev_attr_stats = {
+	.attr = {
+		.name = "stats",
+		.mode = 0444,
+		},
+	.show = intel_qrk_esram_stat_show,
+};
+
+static struct device_attribute dev_attr_map = {
+	.attr = {
+		.name = "map",
+		.mode = 0644,
+		},
+	.show = intel_qrk_esram_map_show,
+	.store = intel_qrk_esram_map_store,
+};
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_stats.attr,
+	&dev_attr_map.attr,
+	NULL,
+};
+
+static struct attribute_group esram_attrib_group = {
+	.attrs = platform_attributes
+};
+
+/******************************************************************************
+ *                                eSRAM Core
+ ******************************************************************************/
+
+/**
+ * intel_qrk_esram_page_busy
+ *
+ * @param epage: Pointer to the page descriptor
+ * @return boolean indicating whether or not a page is enabled
+ */
+static int intel_qrk_esram_page_busy(struct esram_page * epage, u8 lock)
+{
+	u32 reg = 0;
+
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, lock);
+	return (reg&(ESRAM_PAGE_BUSY | ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE));
+}
+
+/**
+ * intel_qrk_esram_fault
+ *
+ * Dump eSRAM registers and kernel panic
+ * Nothing else to do at this point
+ */
+void intel_qrk_esram_fault(struct esram_page * epage, u32 lineno)
+{
+	u32 reg = 0, next = 0, prev = 0, prev_reg = 0;
+	u32 next_reg = 0, block = 0, ctrl = 0;
+
+	pr_err("eSRAM: fault @ %s:%d\n", __FILE__, lineno);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, 1);
+	pr_err("read page %d state 0x%08x\n", epage->id, reg);
+	if(epage->id == 0){
+		next = 1; prev = 127;
+	}else if(epage->id == 127){
+		next = 0; prev = 126;
+	}else{
+		next = epage->id+1;
+		prev = epage->id-1;
+	}
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, next, &next_reg, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, prev, &prev_reg, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	pr_err("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
+	pr_err("Prev page %d state 0x%08x Next page %d state 0x%08x\n"
+		, next, next_reg, prev, prev_reg);
+	BUG();
+}
+
+
+/**
+ * intel_qrk_esram_page_enable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ * @param lock: Indicates whether to attain sb spinlock or not
+ * 
+ * Enable an eSRAM page spinning for page to become ready.
+ */
+static void intel_qrk_esram_page_enable(struct esram_page *epage, u8 lock)
+{
+	u32 ret = 0;
+
+	/* Fault if we try to enable a disabled page */
+	if(intel_qrk_esram_page_busy(epage, lock)){
+		intel_qrk_esram_fault(epage, __LINE__);
+	}
+
+	/* Program page mapping */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id, 
+		ESRAM_PAGE_FLUSH_PAGE_EN | ESRAM_PAGE_EN | 
+			(epage->phys_addr>>ESRAM_PAGE_MAP_SHIFT), lock);
+	do {
+		/* Poll until page busy bit becomes true */
+		ret = intel_qrk_esram_page_busy(epage, lock);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret == 0)){
+			esram_dev.page_enable_retries++;
+		}
+		
+	}while(ret == 0);
+}
+
+/**
+ * intel_qrk_esram_page_disable_sync
+ *
+ * @param epage: pointer to eSRAM page descriptor
+ *
+ * This function spins waiting for disable bit to clear, useful right after a
+ * disable/disable-flush command. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_qrk_esram_page_disable_sync(struct esram_page * epage)
+{
+	u32 ret = 0, retries = 0;
+	do {
+		/* Poll for busy bit clear */
+		ret = intel_qrk_esram_page_busy(epage, 1);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret)){
+			esram_dev.page_disable_retries++;
+			retries++;
+		}
+
+		if(retries == MAX_PAGE_RETRIES){
+			intel_qrk_esram_fault(epage, __LINE__);
+		}
+	}while(ret);
+}
+
+/**
+ * intel_qrk_esram_page_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page no flush. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_qrk_esram_page_disable(struct esram_page *epage)
+{
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_DISABLE, 1);
+	intel_qrk_esram_page_disable_sync(epage);	
+}
+
+/**
+ * intel_qrk_esram_page_flush_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page - with flush. Note the architecture will block access
+ * to the overlayed region until the flush has completed => irqs may be switched
+ * on during this operation.
+ */
+static void intel_qrk_esram_page_flush_disable(struct esram_page *epage)
+{
+	
+
+	/* Do flush */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE, 1);
+
+	intel_qrk_esram_page_disable_sync(epage);	
+}
+
+#if 0
+/**
+ * intel_qrk_esram_flush_disable_all
+ *
+ * Flushes and disables all enabled eSRAM pages
+ */
+static void intel_qrk_esram_page_flush_disable_all(void)
+{
+	struct esram_page * epage = NULL;
+	
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		intel_qrk_esram_page_flush_disable(epage);
+	}
+	spin_unlock(&esram_dev.slock);
+}
+#endif
+
+/**
+ * intel_qrk_esram_page_populate_atomic
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 placeholder, later versions may return error
+ *
+ * Function takes the mappings given in epage and uses the values to populate
+ * an eSRAM page. The copy/enable/copy routine must be done atomically, since we
+ * may be doing a memcpy() of an ISR for example.
+ * For this reason we wrapper this entire call into a callback provided by 
+ * side-band, which does a spin_lock_irqsave calls this function and then does
+ * a spin_lock_irqrestore - thus guaranteeing atomicity of the below code and
+ * respect for the locking strategy of the side-band driver
+  */
+static int intel_qrk_esram_page_populate_atomic(struct esram_page * epage)
+{
+	unsigned long crz;
+
+	/* Copy away */	
+	memcpy(&esram_dev.cbuf, (void*)epage->vaddr, ESRAM_PAGE_SIZE);
+
+	/* If CR0.WP is true - flip it HSD # 4930660 */
+	crz = read_cr0();
+	if (crz & X86_CR0_WP){
+		write_cr0(crz & (~X86_CR0_WP));
+	}
+
+	/* Disable NMI */
+	outb(0x80, 0x70);
+	
+	/*  Enable page mapping */
+	intel_qrk_esram_page_enable(epage, 0);
+	
+	/* Copy back - populating memory overlay */
+	memcpy((void*)epage->vaddr, &esram_dev.cbuf,  ESRAM_PAGE_SIZE);
+
+	/* Re-enable NMI */
+	outb(0x00, 0x70);
+
+	/* Restore CR0.WP if appropriate HSD # 4930660 */
+	if (crz & X86_CR0_WP){
+		write_cr0(crz);
+	}
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_page_populate
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 on success < 0 on failure
+ *
+ * Populates the page. set_memory_rw/set_memory_ro require local irqs enabled.
+ * intel_qrk_esram_page_populate_atomic - needs irqs switched off since memory
+ * can be inconsistent during the populate operation. Depopulate operations are
+ * architecturally guaranteed
+ */
+static int intel_qrk_esram_page_populate(struct esram_page * epage)
+{
+	int flip_rw = 0, level = 0, ret = 0;
+	pte_t * pte = epage != NULL ? lookup_address(epage->vaddr, &level):NULL;
+
+	if(unlikely(pte == NULL)){
+		return -EINVAL;
+	}
+
+	/* Determine if we need to set writable */
+	flip_rw = !(pte_write(*pte));
+	
+	/* Ensure memory is r/w - do so before spin_lock_irqsave */
+	if(flip_rw){
+		ret = set_memory_rw(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_rw = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	/* Force ECC update @ disable only */
+	intel_qrk_esram_page_enable(epage, 1);
+	intel_qrk_esram_page_disable(epage);
+
+	/* Enable and populate eSRAM page using callback in sb with irqs off */
+	ret |= intel_qrk_sb_runfn_lock(
+		(int (*)(void*))intel_qrk_esram_page_populate_atomic,(void*)epage);
+
+	/* If we set memory writable - restore previous state */
+	if(flip_rw){
+		ret |= set_memory_ro(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_ro = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+/**
+ * intel_qrk_esram_page_addref
+ *
+ * @param epage: eSRAM page descriptor
+ * @param name: Name of reference to add
+ * @return zero on success negative on error
+ *
+ */
+static int intel_qrk_esram_page_addref(struct esram_page * epage, char * name)
+{
+	struct esram_refname * refname = NULL;
+	if(unlikely(epage == NULL || name == NULL)){
+		return -EINVAL;
+	}
+
+	refname = kzalloc(sizeof(struct esram_refname), GFP_KERNEL);
+	if(unlikely(refname == NULL)){
+		return -ENOMEM;
+	}
+		
+	/* Add to list */
+	strncpy(refname->name, name, sizeof(refname->name));
+	list_add(&refname->list, &epage->name_list);
+
+	/* Bump reference count */
+	epage->refcount++;
+	return 0;
+}
+
+
+/**
+ * __intel_qrk_esram_map_page
+ *
+ * @param page: Page to map
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Overlay a vritual address rangne eeds to be aligned to a 4k address.
+ * Since multiple items can live in a 4k range, it is possible when calling
+ * into map_page() that a previous mapping will have already covered some or all
+ * of the mapping we want. This is not an error case, if the map function finds
+ * it is being asked to map a 4k range already mapped it returns 0, to indicate
+ * the mapping has suceeded i.e. it's already been mapped. This is logical if
+ * you think about it. In contrast being asked to unmap a region not mapped is
+ * clearly an error...
+ *
+ */
+static int __intel_qrk_esram_map_page(u32 vaddr, char * name)
+{
+	int ret = 0;	
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	if(unlikely(name == NULL)){
+		return -EINVAL;
+	}
+
+	if(unlikely(esram_dev.page_free_ct == 0)){
+		return -ENOMEM;
+	}
+
+	/* Verify if we have already mapped */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+
+			/* Page already mapped */
+			list_for_each_entry(refname, &epage->name_list, list){
+				if(strcmp(refname->name, name)==0){
+					/* Page mapped at this name */
+					return -EINVAL;
+				}
+			}
+			/* New symbol in previous mapping */
+			return intel_qrk_esram_page_addref(epage, name);
+		}
+	}
+
+	/* Enumerate eSRAM page structure */
+	epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+	epage->phys_addr = virt_to_phys((void*)vaddr);
+	epage->vaddr = vaddr;
+	ret = intel_qrk_esram_page_addref(epage, name);
+	if(unlikely(ret < 0)){
+		return ret;
+	}
+	
+	/* Populate page */
+	ret = intel_qrk_esram_page_populate(epage);
+
+	/* Move to used list */
+	list_move(&epage->list, &esram_dev.page_used);
+	esram_dev.page_free_ct--;
+
+	return ret;
+}
+
+/**
+ * __intel_qrk_esram_unmap_page
+ *
+ * @param page: Page to unmap
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Unmap a previously mapped virutal address range.
+ * Must be 4k aligned
+ *
+ */
+static int __intel_qrk_esram_unmap_page(u32 vaddr, char * name)
+{
+	u8 found = 0;
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	/* Find physical address */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+			found = 1;
+			break;
+		}
+	}
+
+	/* Bail out on error */
+	if(found == 0){
+		pr_err("0x%08x not mapped\n", vaddr);
+		return -EINVAL;
+	}
+
+	/* Determine reference to delete */
+	found = 0;
+	list_for_each_entry(refname, &epage->name_list, list){
+		if(strcmp(refname->name,name)==0){
+			found = 1;
+			break;
+		}
+	}
+	if(unlikely(found == 0)){
+		pr_err("No mapping %s!\n", name);
+		return -EINVAL;
+	}
+
+	/* Remove entry decrement reference count */	
+	list_del(&refname->list);
+	kfree(refname);
+	if(--epage->refcount > 0){
+		return 0;
+	}
+
+	/* Flush and disable page */
+	intel_qrk_esram_page_flush_disable(epage);
+
+	/* Move to free list tail - scrub entries come from head */
+	list_move_tail(&epage->list, &esram_dev.page_free);
+	esram_dev.page_free_ct++;
+
+	return 0;
+}
+
+/**
+ *
+ * __intel_qrk_esram_page_op
+ *
+ * @param vaddr: Virtual address of symbol
+ * @param size: Size/length of symbol
+ * @param name: Name of mapping
+ * @param map: Boolean indicates whether to map or unmap the page
+ * @return 0 success < 0 failure
+ *
+ * This function maps/unmaps a pages/pages given at the given vaddr. If
+ * the extent of the symbol @ vaddr crosses a page boundary, then we map
+ * multiple pages. Other stuff inside the page, gets a performance boost 'for
+ * free'. Any other data in the page that crosses the physical page boundary
+ * will be partially mapped.
+ */
+static int __intel_qrk_esram_page_op(u32 vaddr, u32 size, char *name, u8 map)
+{
+	unsigned long offset = 0, page_offset = 0;
+	u32  pages = size/ESRAM_PAGE_SIZE + ((size%ESRAM_PAGE_SIZE) ? 1 : 0);
+	int ret = 0;
+
+	/* Compare required pages to available pages */
+	if(map == ESRAM_MAP_OP){
+		if(pages > esram_dev.page_free_ct)
+			return -ENOMEM;
+	}else{
+		if(pages > esram_dev.page_count - esram_dev.page_free_ct)
+			return -ENOMEM;
+	}
+
+	/* Align to 4k and iterate the mappings */	
+	vaddr = vaddr&ESRAM_PAGE_MASK;
+	while(size > 0){
+
+		/* Map the page */
+		spin_lock(&esram_dev.slock);
+		if(map == ESRAM_MAP_OP){
+			ret = __intel_qrk_esram_map_page(vaddr, name);
+							 
+		}else{
+			ret = __intel_qrk_esram_unmap_page(vaddr, name);
+		}
+		spin_unlock(&esram_dev.slock);
+		if(unlikely(ret != 0)){
+			break;
+		}
+
+		/* Calc appropriate offsets */
+		page_offset = offset_in_page(vaddr);
+		if(page_offset + size > ESRAM_PAGE_SIZE){
+
+			offset = ESRAM_PAGE_SIZE - page_offset;
+			size -= offset;
+			vaddr += ESRAM_PAGE_SIZE; 
+
+		}else{
+			size = 0;
+		}
+	}
+
+	return ret;
+}
+
+/******************************************************************************
+ *                                 eSRAM API
+ ******************************************************************************/
+
+/**
+ * intel_qrk_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_qrk_esram_map_range(void * vaddr, u32 size, char * mapname)
+{
+	if(size == 0 || mapname == NULL || vaddr == NULL){
+		return -EINVAL;
+	}
+	return __intel_qrk_esram_page_op((u32)vaddr, size, mapname, ESRAM_MAP_OP);
+}
+EXPORT_SYMBOL(intel_qrk_esram_map_range);
+
+/**
+ * intel_qrk_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_qrk_esram_map_range()
+ */
+int intel_qrk_esram_map_symbol(void * vaddr)
+{
+	long unsigned int size = 0, offset = 0;
+	char symname[KSYM_SYMBOL_LEN];
+	
+	kallsyms_lookup_size_offset((long unsigned int)vaddr, &size, &offset);
+	if(size == 0){
+		return -EINVAL;
+	}
+	sprint_symbol(symname, (u32)vaddr);
+
+	return __intel_qrk_esram_page_op((u32)vaddr, size, symname, 1);
+}
+EXPORT_SYMBOL(intel_qrk_esram_map_symbol);
+
+/******************************************************************************
+ *                        Module/PowerManagement hooks 
+ ******************************************************************************/
+
+/**
+ * intel_qrk_esram_suspend
+ *
+ * @param pdev: Platform device structure (unused)
+ * @param pm: Power managment descriptor
+ * @return 0 success < 0 failure
+ *
+ * For each enabled page - flush to DRAM and disable eSRAM page.
+ * For each 4k region the architecture guarantees atomicity of flush/disable.
+ * Hence any memory transactions to the affected region will stall until
+ * flush/disable completes - hence interrupts are left on.
+ */
+static int intel_qrk_esram_suspend(struct device * pdev)
+{
+	/* Flush and disable of eSRAM pages is carried out automatically */
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_resume
+ *
+ * @param pm: Power management descriptor
+ * @return 0 success < 0 failure
+ *
+ * Runs after resume_noirq. Switches pages back to ro, if appropriate. We do
+ * this here since interrupts will be on, as required by the function
+ * set_memory_ro. If it were possible to set memory ro in resume_noirq we would
+ * do it there instead
+ */
+static int intel_qrk_esram_resume(struct device * pdev)
+{
+	struct esram_page * epage = NULL;
+	int ret = 0;
+
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		ret |= intel_qrk_esram_page_populate(epage);
+	}
+	
+	return ret;
+}
+
+
+/**
+ * intel_qrk_esram_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_qrk_esram_probe(struct platform_device * pdev)
+{
+	int ret = 0;
+	u32 block = 0, ctrl = 0, i = 0, pgstat = 0;
+
+	memset(&esram_dev, 0x00, sizeof(esram_dev));
+	INIT_LIST_HEAD(&esram_dev.page_used);
+	INIT_LIST_HEAD(&esram_dev.page_free);
+	spin_lock_init(&esram_dev.slock);
+	esram_dev.page_free_ct = 0;
+	
+	/* Ensure block mode disabled */
+	block = ESRAM_PGBLOCK_DISABLE;
+	sb_write(SB_ID_ESRAM, ESRAM_CTRL_WRITE, ESRAM_PGBLOCK_REG, block, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	/* Verify state is good to go */
+	if (ctrl & ESRAM_CTRL_GLOBAL_LOCK){
+		pr_err ("eSRAM: global lock @ 0x%08x\n", ctrl);
+		return -ENODEV;
+	}
+
+	if (block & (ESRAM_PGBLOCK_LOCK | ESRAM_PGBLOCK_ENABLE)){
+		pr_err ("eSRAM: lock @ 0x%08x\n", block);
+		return -ENODEV;
+	}
+	pr_info("eSRAM: CTRL 0x%08x block 0x%08x\n", ctrl, block);
+
+	/* Calculate # of pages silicon supports */
+	esram_dev.page_count = ESRAM_CTRL_SIZE(ctrl) + 1;
+	esram_dev.page_free_ct = esram_dev.page_count;
+	pr_info("eSRAM: pages %d\n", esram_dev.page_free_ct);
+
+	if(esram_dev.page_free_ct <= 1){
+		pr_err("Too few pages reported by eSRAM sub-system\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate an appropriate number of pages */
+	esram_dev.pages = kzalloc(esram_dev.page_count *
+		sizeof(struct esram_page), GFP_KERNEL);
+	if (esram_dev.pages == NULL){
+		return -ENOMEM;
+	}
+
+	/* Initialise list of free pages, explicitely disable as we go */
+	for(i = 0; i < esram_dev.page_count; i++){
+		INIT_LIST_HEAD(&esram_dev.pages[i].name_list);
+		esram_dev.pages[i].id = i;
+		
+		/* Read & verify page state */
+		sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, i, &pgstat, 1);
+		if(pgstat & (ESRAM_PAGE_BUSY | ESRAM_PAGE_LOCK)){
+			pr_err("eSRAM: page %d state 0x%08x err\n", i, pgstat);
+			ret = -ENODEV;
+			goto err;
+		}
+
+		list_add(&esram_dev.pages[i].list, &esram_dev.page_free);
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &esram_attrib_group);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	kfree(esram_dev.pages);
+	return ret;
+}
+
+/*
+ * Power management operations
+ */
+static const struct dev_pm_ops intel_qrk_esram_pm_ops = {
+	.suspend = intel_qrk_esram_suspend,
+	.resume = intel_qrk_esram_resume,
+};
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_esram_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &intel_qrk_esram_pm_ops,
+	},
+	.probe = intel_qrk_esram_probe,
+};
+
+module_platform_driver(intel_qrk_esram_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Quark eSRAM overlay/ECC-scrub driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_qrk_esram.h b/drivers/platform/x86/quark/intel_qrk_esram.h
new file mode 100644
index 0000000..71aaba1
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_esram.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A proc interface is provided to allow map/unmap of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo ehci_irq on > /proc/driver/esram/map
+ * echo ehci_irq off > /proc/driver/esram/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * 
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+#ifndef __INTEL_QRK_ESRAM_H__
+#define __INTEL_QRK_ESRAM_H__
+
+#include <linux/module.h>
+
+/* Basic size of an eSRAM page */
+#define	INTEL_QRK_ESRAM_PAGE_SIZE	(0x1000)
+#define INTEL_QRK_ESRAM_PAGE_COUNT	(0x80)
+/**
+ * intel_qrk_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_qrk_esram_map_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_qrk_esram_unmap_range
+ *
+ * @param vaddr: The virtual address to unmap
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary of esram_map_page
+ */
+int intel_qrk_esram_unmap_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_qrk_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_qrk_esram_map_range()
+ */
+int intel_qrk_esram_map_symbol(void * vaddr);
+
+/**
+ * intel_qrk_esram_unmap_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary to intel_qrk_esram_map_symbol
+ * Undoes any mapping of pages starting at sym for sym's size
+ */
+int intel_qrk_esram_unmap_symbol(void * vaddr);
+
+#endif /* __INTEL_QRK_ESRAM_H__ */
diff --git a/drivers/platform/x86/quark/intel_qrk_esram_test.c b/drivers/platform/x86/quark/intel_qrk_esram_test.c
new file mode 100644
index 0000000..544ad57
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_esram_test.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_qrk_esram_test.c
+ *
+ * Simple test module to provide test cases for ITS integration
+ *
+ */
+#include <linux/cdev.h>
+#include <linux/crc32.h>
+#include <linux/crc32c.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#include "intel_qrk_esram.h"
+#include "intel_qrk_esram_test.h"
+
+#define DRIVER_NAME			"intel_qrk_esram_test"
+
+/**
+ * struct intel_qrk_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_qrk_esram_test_dev{
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+	char * pdata;
+	u32 size;
+};
+
+static struct intel_qrk_esram_test_dev esram_test_dev;
+static struct class *esram_test_class;
+static DEFINE_MUTEX(esram_test_mutex);
+static int esram_test_major;
+static char * name = "testmap";
+
+/******************************************************************************
+ *                                eSRAM BIST
+ ******************************************************************************/
+
+static int crc_cache = 0;
+
+unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
+{
+	if (first < end)
+		return end - first;
+	else
+		return (ULLONG_MAX - first) + end;	
+}
+
+
+/**
+ * intel_qrk_crctest
+ *
+ * Do a CRC32 of the specified region. Return the time taken in jiffies
+ */
+static unsigned long long intel_qrk_crctest(char * pdata, u32 crcsize)
+{
+	unsigned long long j1 = 0, j2 = 0;
+	
+	rdtscll(j1);
+
+	/* Flush LMT cache to introduce cache miss to our test */
+	__asm__ __volatile__("wbinvd\n");
+	crc32(0, pdata, crcsize);
+
+	rdtscll(j2);
+
+	return tsc_delta(j1, j2);
+}
+
+#ifdef __DEBUG__
+#define bist_err(x){\
+	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
+	return x;\
+}
+#else
+#define bist_err(x){\
+	return x;\
+}
+#endif
+/**
+ * intel_qrk_esram_perpage_overlay
+ *
+ * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
+ */
+int intel_qrk_esram_test_perpage_overlay(void)
+{
+
+	int ret = 0;
+	u32 idx = 0, size = INTEL_QRK_ESRAM_PAGE_SIZE;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+
+	/* Basic test of full range of memory */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+
+#if 0
+	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_test_pageref_count
+ *
+ * Ensure page reference couting works as expected
+ */
+int intel_qrk_esram_test_pagref_count(void)
+{
+	u32 size = INTEL_QRK_ESRAM_PAGE_SIZE;
+	int ret = 0;
+
+	return 0;
+	/* Map a page */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map a second time - and verify mapping fails */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+
+#if 0
+	/* Unmap - OK */
+	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Verify second unmap operation fails */
+	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+#endif	
+	return 0;
+}
+
+extern uint32_t get_crc32table_le(void);
+
+/**
+ * intel_qrk_esram_test_contig_perfmetric
+ *
+ * Do a CRC16 for a contigous area of memory
+ * Map contigous area and get a CRC16
+ *
+ * Ensure overlayed data takes less time than regular unoverlayed DRAM
+ */
+int intel_qrk_esram_test_contig_perfmetric(void)
+{
+	u32 crcsize = 0x60000;
+	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
+	uint32_t crc32table_le = kallsyms_lookup_name("crc32table_le");
+	int ret = 0;
+
+	if (crc32table_le == 0){
+		pr_err("%s unable to fine symbol crc32table_le\n", __func__);
+		return -ENODEV;
+	}
+
+	/* Get raw data metric */
+	crc_cache = 1;
+	crc32_fullunmap = intel_qrk_crctest(esram_test_dev.pdata, crcsize);
+
+	/* Map CRC16 symbol (algorithm) + code (data) */
+	ret = intel_qrk_esram_map_symbol(crc32_le);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_qrk_esram_map_symbol((void*)crc32table_le);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map test data */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	/* Get metric */
+	crc_cache = 1;
+	crc32_fullmap = intel_qrk_crctest(esram_test_dev.pdata, crcsize);
+#if 0
+	/* Tidy up */
+	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_qrk_esram_unmap_range(((void*)crc32_table),
+					  sizeof(crc32_table), name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_qrk_esram_unmap_symbol(crc32);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
+	pr_info("%s mapped count %llu unmapped %llu\n",
+		__func__, crc32_fullmap, crc32_fullunmap);
+	return crc32_fullmap < crc32_fullunmap;
+}
+
+/**
+ * intel_qrk_esram_test_kernel_codemap
+ *
+ * Maps some kernel code - a data section and then calls the code contained
+ * therein. Proves out the running overlayed eSRAM works
+ */
+int intel_qrk_esram_test_kernel_codemap(void)
+{
+#if 0
+	int ret = intel_qrk_esram_map_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+	
+	/* run the mapped code */
+	msleep(1);
+
+	/* unmap */	
+	ret = intel_qrk_esram_unmap_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_test_kernel_datamap
+ *
+ * Tests mapping/unmapping of a kernel data structure
+ */
+int intel_qrk_esram_test_kernel_datamap(void)
+{
+#if 0
+	unsigned long jtag = 0;
+	unsigned long ctrl = 0;
+
+	/* Map the interrupt descriptor table */
+	int ret = intel_qrk_esram_map_range(idt_table, INTEL_QRK_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	jtag = jiffies;
+	/* Wait for jiffies to tick or timeout to occur (failure) */
+	while(jtag == jiffies){
+		ctrl++;
+	}
+
+	/* unmap */	
+	ret = intel_qrk_esram_unmap_range(idt_table, INTEL_QRK_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_test_sub_unsub
+ *
+ * Subscribe and unsubscribe 100% of available eSRAM
+ */
+int intel_qrk_esram_test_sub_unsub(void)
+{
+	int ret = 0;
+	u32 idx = 0, size = INTEL_QRK_ESRAM_PAGE_SIZE * INTEL_QRK_ESRAM_PAGE_COUNT;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+	/* Basic test of full range of memory */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+#if 0
+	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_qrk_esram_test_over_sub
+ *
+ * Test oversubscription of eSRAM
+ */
+int intel_qrk_esram_test_over_sub(void)
+{
+	int ret = 0;
+	u32 size = INTEL_QRK_ESRAM_PAGE_SIZE * (INTEL_QRK_ESRAM_PAGE_COUNT + 1);
+
+	/* Over subscribe should fail */
+	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		//intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
+		bist_err(-EFAULT);
+	}
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long esram_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	cmd -= QRK_ESRAM_IOCTL_BASE;
+	switch (cmd) {
+		case QRK_F_SW_APP_ESRAM_0:
+			/* Per page overlay */
+			ret = intel_qrk_esram_test_perpage_overlay();
+			break;
+
+		case QRK_F_SW_APP_ESRAM_1:
+			/* Verify page reference counting */
+			ret = intel_qrk_esram_test_pagref_count();
+			break;
+
+		case QRK_F_SW_APP_ESRAM_2:
+			/* Performance metric or overlay contig RAM */
+			ret = intel_qrk_esram_test_contig_perfmetric();
+			if (ret == 1)
+				ret = 0;
+			break;
+
+		case QRK_F_SW_APP_ESRAM_3:
+			/* Verify mapping of kernel code section */
+			/* Covered by test #2 */
+			ret = 0; //intel_qrk_esram_test_kernel_codemap();
+			break;
+
+		case QRK_F_SW_APP_ESRAM_4:
+			/* Verify mapping of kernel data section (IDT) */
+			/* Covered by test #2 */
+			ret = 0; //intel_qrk_esram_test_kernel_datamap();
+			break;
+
+		case QRK_F_SW_APP_ESRAM_5:
+			/* Complete subscribe/unsubscribe eSRAM */
+			ret = intel_qrk_esram_test_sub_unsub();
+			break;
+
+		case QRK_F_SW_APP_ESRAM_6:
+			/* Over subscribe eSRAM */
+			ret = intel_qrk_esram_test_over_sub();
+			break;
+
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int esram_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
+		mutex_unlock(&esram_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (esram_test_dev.opened) {
+		mutex_unlock(&esram_test_dev.open_lock);
+		mutex_unlock(&esram_test_mutex);
+		return -EINVAL;
+	}
+
+	esram_test_dev.opened++;
+	mutex_unlock(&esram_test_dev.open_lock);
+	mutex_unlock(&esram_test_mutex);
+
+	return 0;
+}
+
+static int esram_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_dev.open_lock);
+	esram_test_dev.opened = 0;
+	mutex_unlock(&esram_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations esram_test_file_ops = {
+	.open = esram_test_open,
+	.release = esram_test_release,
+	.unlocked_ioctl = esram_test_ioctl,
+	.llseek = no_llseek,
+};
+
+
+/**
+ * intel_qrk_esram_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_qrk_esram_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	esram_test_dev.size = INTEL_QRK_ESRAM_PAGE_COUNT * INTEL_QRK_ESRAM_PAGE_SIZE;
+
+	/* Get memory */
+	esram_test_dev.pdata = kzalloc(esram_test_dev.size, GFP_KERNEL);
+	if(unlikely(esram_test_dev.pdata == NULL)){
+		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
+		return -ENOMEM;
+	}
+
+	mutex_init(&esram_test_dev.open_lock);
+	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
+	esram_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(esram_test_class, NULL,
+				 MKDEV(esram_test_major, minor), NULL,
+				 "esramtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s/%s/%s complete OK !!\n", __FUNCTION__, __DATE__,__TIME__);
+	return 0;
+
+}
+
+/**
+ * intel_qrk_esram_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_qrk_esram_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
+
+	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
+	cdev_del(&esram_test_dev.cdev);
+	kfree(esram_test_dev.pdata);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_esram_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_qrk_esram_test_remove,
+};
+
+/**
+ * intel_qrk_esram_init
+ *
+ * @return 0 success < 0 failure
+ *
+ * Module entry point
+ */
+static int __init intel_qrk_esram_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	esram_test_class = class_create(THIS_MODULE,"qrk_esram_test");
+	if (IS_ERR(esram_test_class)) {
+		retval = PTR_ERR(esram_test_class);
+		printk(KERN_ERR "esram_test: can't register earam_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	esram_test_major = MAJOR(dev);
+
+	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
+	esram_test_dev.pldev = platform_create_bundle(
+		&intel_qrk_esram_test_driver, intel_qrk_esram_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(esram_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(esram_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(esram_test_class);
+err:
+	return retval;
+}
+
+/**
+ * intel_qrk_esram_exit
+ *
+ * Module exit
+ */
+static void __exit intel_qrk_esram_test_exit(void)
+{
+	platform_device_unregister(esram_test_dev.pldev);
+	platform_driver_unregister(&intel_qrk_esram_test_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Quark eSRAM ITS driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_init(intel_qrk_esram_test_init);
+module_exit(intel_qrk_esram_test_exit);
diff --git a/drivers/platform/x86/quark/intel_qrk_esram_test.h b/drivers/platform/x86/quark/intel_qrk_esram_test.h
new file mode 100644
index 0000000..35ad2d8
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_esram_test.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_qrk_esram_test.h
+ *
+ * Define integers for ioctl operation
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+
+#ifndef __INTEL_QRK_ESRAM_TEST_H__
+#define __INTEL_QRK_ESRAM_TEST_H__
+
+#define QRK_ESRAM_IOCTL_BASE	255
+#define QRK_F_SW_APP_ESRAM_0	0x00000000
+#define QRK_F_SW_APP_ESRAM_1	0x00000001
+#define QRK_F_SW_APP_ESRAM_2	0x00000002
+#define QRK_F_SW_APP_ESRAM_3	0x00000003
+#define QRK_F_SW_APP_ESRAM_4	0x00000004
+#define QRK_F_SW_APP_ESRAM_5	0x00000005
+#define QRK_F_SW_APP_ESRAM_6	0x00000006
+#define QRK_F_SW_APP_ESRAM_7	0x00000007
+#define QRK_F_SW_APP_ESRAM_8	0x00000008
+
+#endif /* __INTEL_QRK_ESRAM_TEST_H__ */
+
diff --git a/drivers/platform/x86/quark/intel_qrk_imr.c b/drivers/platform/x86/quark/intel_qrk_imr.c
new file mode 100644
index 0000000..8865307
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_imr.c
@@ -0,0 +1,697 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Quark SoC.
+ *
+ * A total number of 8 IMRs have implemented by Quark SoC,
+ * Some IMRs might be already occupied by BIOS or Linux during
+ * booting time.
+ *
+ * A user can cat /sys/devices/platform/intel-qrk-imr/status for current IMR
+ * status 
+ *
+ * To allocate an IMR addresses must be alinged to 1k
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, then apply the input access right masks
+ *
+ * The IMR can be freed with the pre-allocated memory addresses.
+ */
+
+#include <asm-generic/uaccess.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/proc_fs.h>
+
+#include "intel_qrk_imr.h"
+#include <asm/imr.h>
+
+#define DRIVER_NAME	"intel-qrk-imr"
+
+#define IMR_READ_MASK	0x1
+#define IMR_MAX_ID	7
+
+#ifndef phys_to_virt
+#define phys_to_virt __va
+#endif
+
+/* IMR HW register address structre */
+struct qrk_imr_reg_t {
+	u8  imr_xl;   /* high address register */
+	u8  imr_xh;   /* low address register */
+	u8  imr_rm;   /* read mask register */
+	u8  imr_wm;   /* write mask register */
+} qrk_imr_reg_t;
+
+/**
+ * struct qrk_imr_addr_t
+ *
+ * IMR memory address structure
+ */
+struct qrk_imr_addr_t {
+	u32 addr_low;      /* low boundary memroy address */
+	u32 addr_high;     /* high boundary memory address */
+	u32 read_mask;     /* read access right mask */
+	u32 write_mask;    /* write access right mask */
+} qrk_imr_addr_t;
+
+/**
+ * struct qrk_imr_pack
+ *
+ * local IMR pack structure
+ */
+struct qrk_imr_pack {
+	bool occupied;       /* IMR occupied */
+	bool locked;         /* IMR lock */
+	struct qrk_imr_reg_t reg;   /* predefined imr register address */
+	struct qrk_imr_addr_t addr; /* IMR address region structure */
+	unsigned char info[MAX_INFO_SIZE]; /* IMR info */
+} qrk_imr_pack;
+
+
+/* Predefined HW register address */
+static struct qrk_imr_reg_t imr_reg_value[] = {
+	{ IMR0L, IMR0H, IMR0RM, IMR0WM },
+	{ IMR1L, IMR1H, IMR1RM, IMR1WM },
+	{ IMR2L, IMR2H, IMR2RM, IMR2WM },
+	{ IMR3L, IMR3H, IMR3RM, IMR3WM },
+	{ IMR4L, IMR4H, IMR4RM, IMR4WM },
+	{ IMR5L, IMR5H, IMR5RM, IMR5WM },
+	{ IMR6L, IMR6H, IMR6RM, IMR6WM },
+	{ IMR7L, IMR7H, IMR7RM, IMR7WM }
+};
+
+static struct platform_device *pdev;
+
+/**
+ * module parameter
+ * IMR slot should repersant the available IMR region from
+ * linux boot and BIOS.
+ *
+ * For example: imr_bit_mask = 0x10111001
+ * occupied IMR: 0, 3, 4, 5, 7
+ * un-occupied IMR: 1, 2, 6
+ */
+static int imr_bit_mask = 0xFF;
+module_param(imr_bit_mask, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_bit_mask, "IMR bit mask");
+
+/**
+ * module parameter
+ * if IMR lock is a nozero value, all unlocked
+ * imrs will be locked regardless the usage.
+ */
+static int imr_lock = 0;
+module_param(imr_lock, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_lock, "switch to lock unused IMR");
+
+/* local IMR data structure */
+struct qrk_imr_pack local_imr[IMR_MAXID];
+
+static unsigned short host_id;
+
+/**
+ * intel_qrk_imr_read_reg
+ *
+ * @param reg: register address
+ * @return nothing
+ *
+ * return register value from input address.
+ */
+static inline uint32_t intel_qrk_imr_read_reg(uint8_t reg)
+{
+	uint32_t temp = 0;
+
+	intel_qrk_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE, reg, &temp, 0);
+	return temp;
+}
+
+/**
+ * intel_clm_imr_latch_data
+ *
+ * @return nothing
+ *
+ * Populate IMR data structure from HW.
+ */
+static inline void intel_clm_imr_latch_data(void)
+{
+	int i = 0;
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		local_imr[i].addr.addr_low =
+			intel_qrk_imr_read_reg(imr_reg_value[i].imr_xl);
+		local_imr[i].addr.addr_high =
+			intel_qrk_imr_read_reg(imr_reg_value[i].imr_xh);
+		local_imr[i].addr.read_mask =
+			intel_qrk_imr_read_reg(imr_reg_value[i].imr_rm);
+		local_imr[i].addr.write_mask =
+			intel_qrk_imr_read_reg(imr_reg_value[i].imr_wm);
+
+		if (local_imr[i].addr.addr_low & IMR_LOCK_BIT)
+			local_imr[i].locked = true;
+
+		if (local_imr[i].addr.read_mask > 0 &&
+			local_imr[i].addr.read_mask < IMR_READ_ENABLE_ALL){
+			local_imr[i].occupied = true;
+		} else {
+			local_imr[i].occupied = false;
+			memcpy(local_imr[i].info, "NOT USED", MAX_INFO_SIZE);
+		}
+	}
+}
+
+/**
+ * prepare_input_addr
+ *
+ * @param addr: input physical memory address
+ * @return formated memory address
+ *
+ * 1. verify input memory address alignment
+ * 2. apply IMR_REG_MASK to match the format required by HW
+ */
+static inline uint32_t prepare_input_addr(uint32_t addr)
+{
+	if (addr & (IMR_MEM_ALIGN - 1))
+		return 0;
+
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * intel_qrk_imr_find_free_entry
+ *
+ * @return the next free imr slot
+ */
+static int intel_qrk_imr_find_free_entry(void)
+{
+	int i = 0;
+
+	intel_clm_imr_latch_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if ((!local_imr[i].occupied) && (!local_imr[i].locked))
+			return i;
+	}
+
+	pr_err("%s: No more free IMR available.\n", __func__);
+	return -ENOMEM;
+}
+
+
+/**
+ * sb_write_chk
+ *
+ * @param id: Sideband identifier
+ * @param cmd: Command to send to destination identifier
+ * @param reg: Target register w/r to qrk_sb_id
+ * @param data: Data to write to target register
+ * @return nothing
+ *
+ * Set SB register and read back to verify register has been updated.
+ */
+static void sb_write_chk(qrk_sb_id id, u8 cmd, u8 reg, u32 data)
+{
+	u32 data_verify = 0;
+
+	intel_qrk_sb_write_reg(id, cmd, reg, data, 0);
+	intel_qrk_sb_read_reg(id, cmd, reg, &data_verify, 0);
+	BUG_ON(data != data_verify);
+}
+
+/**
+ * imr_add_entry
+ *
+ * @param id: imr slot id
+ * @param hi: hi memory address
+ * @param lo: lo memory address
+ * @param read: read access mask
+ * @param write: write access mask
+ * @return nothing
+ *
+ */
+static inline void imr_add_entry(int id, uint32_t hi, uint32_t lo,
+				 uint32_t read, uint32_t write, bool lock)
+{
+	u32 val = 0;
+
+	intel_qrk_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE,
+			      imr_reg_value[id].imr_xl, &val, 0);
+	val &= ~IMR_EN;
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_xl,
+		     val);
+
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_rm,
+		     read);
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_wm,
+		     write);
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_xh,
+		      hi);
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_xl,
+		      lo);
+}
+
+/**
+ * x1000_imr_add_entry
+ *
+ * @param id: imr slot id
+ * @param hi: hi memory address
+ * @param lo: lo memory address
+ * @param read: read access mask
+ * @param write: write access mask
+ * @return nothing
+ *
+ */
+static inline void x1000_imr_add_entry(int id, uint32_t hi, uint32_t lo,
+				       uint32_t read, uint32_t write, bool lock)
+{
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, lo, 0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, hi, 0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, read, 0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, write, 0);
+}
+
+/**
+ * intel_qrk_imr_add_entry
+ *
+ * @param id: imr slot id
+ * @param hi: hi memory address
+ * @param lo: lo memory address
+ * @param read: read access mask
+ * @param write: write access mask
+ * @return nothing
+ *
+ * Setup an IMR entry
+ */
+static void intel_qrk_imr_add_entry(int id, uint32_t hi,
+		uint32_t lo, uint32_t read, uint32_t write, bool lock)
+{
+	if (PCI_DEVICE_ID_X1000_HOST_BRIDGE == host_id)
+		x1000_imr_add_entry(id, hi, lo, read, write, lock);
+	else
+		imr_add_entry(id, hi, lo, read, write, lock);
+
+	if (lock) {
+		lo |= IMR_LOCK_BIT;
+		intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+					imr_reg_value[id].imr_xl, lo, 0);
+	}
+}
+
+/**
+ * get_phy_addr
+ * @return phy address value
+ *
+ * convert register format to physical address format.
+ */
+static uint32_t get_phy_addr(uint32_t reg_value)
+{
+	reg_value = ((reg_value & IMR_REG_MASK) << 8);
+	return reg_value;
+}
+
+
+
+/**
+ * intel_qrk_imr_init_mask
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * prepare local IMR data structure from input module parameter.
+ */
+static void intel_qrk_imr_init_mask(int mask)
+{
+	int i = 0;
+
+	BUG_ON((mask > 255 || mask < 0));
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].addr.addr_low =
+			intel_qrk_imr_read_reg(imr_reg_value[i].imr_xl);
+
+		/* mask bit 1 means imr occupied*/
+		if (((mask>>i) & IMR_READ_MASK) == 0) {
+			if (!(local_imr[i].addr.addr_low & IMR_LOCK_BIT))
+				intel_qrk_remove_imr_entry(i);
+		}
+	}
+}
+
+/**
+ * imr_rm_entry
+ *
+ * @param id: imr slot id
+ * @return nothing
+ *
+ */
+static inline void imr_rm_entry(int id)
+{
+	u32 val = 0;
+
+	intel_qrk_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE,
+			      imr_reg_value[id].imr_xl, &val, 0);
+	val &= ~IMR_EN;
+	sb_write_chk(SB_ID_ESRAM, CFG_WRITE_OPCODE, imr_reg_value[id].imr_xl,
+		     val);
+}
+
+/**
+ * x1000_imr_rm_entry
+ *
+ * @param id: imr slot id
+ * @return nothing
+ *
+ */
+static inline void x1000_imr_rm_entry(int id)
+{
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, IMR_READ_ENABLE_ALL,
+				0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, IMR_WRITE_ENABLE_ALL,
+				0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, IMR_BASE_ADDR, 0);
+	intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, IMR_BASE_ADDR, 0);
+}
+
+/**
+ * intel_qrk_remove_imr_entry
+ *
+ * @param id: imr slot id
+ * @return nothing
+ *
+ * remove imr slot based on input id
+ */
+void intel_qrk_remove_imr_entry(int id)
+{
+	if (id >= IMR_MAXID || local_imr[id].locked)
+		return;
+
+	if (PCI_DEVICE_ID_X1000_HOST_BRIDGE == host_id)
+		x1000_imr_rm_entry(id);
+	else
+		imr_rm_entry(id);
+
+	intel_clm_imr_latch_data();
+
+}
+EXPORT_SYMBOL(intel_qrk_remove_imr_entry);
+
+/**
+ * intel_qrk_imr_alloc
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @param read: IMR read mask value
+ * @param write: IMR write mask value
+ * @return nothing
+ *
+ * setup the next available IMR with customized read and write masks
+ */
+int intel_qrk_imr_alloc(uint32_t high, uint32_t low, uint32_t read,
+			uint32_t write, unsigned char *info, bool lock)
+{
+	int id = 0;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	if ((low & IMR_LOCK_BIT) || (read == 0 || write == 0)) {
+		pr_err("%s: Invalid acces mode\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Calculate aligned addresses and validate range */
+	high = prepare_input_addr(high);
+	low = prepare_input_addr(low);
+
+	/* Find a free entry */
+	id = intel_qrk_imr_find_free_entry();
+	if (id < 0)
+		return -ENOMEM;
+
+	/* Add entry - locking as necessary */
+	intel_qrk_imr_add_entry(id, high, low, (read & IMR_READ_ENABLE_ALL),
+				write, lock);
+
+	/* Name the new entry */
+	memcpy(local_imr[id].info, info, MAX_INFO_SIZE);
+
+	/* Update local data structures */
+	intel_clm_imr_latch_data();
+
+	pr_info("IMR alloc id %d 0x%08x - 0x%08x %s\n", id, low, high,
+		lock ? "locked" : "unlocked");
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_imr_alloc);
+
+/**
+ * intel_qrk_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @return nothing
+ *
+ * remove the imr based on input memory region
+ */
+int intel_qrk_imr_free(uint32_t high, uint32_t low)
+{
+	int i = 0;
+
+	if (low > high) {
+		pr_err("%s: Invalid input address values.\n", __func__);
+		return -EINVAL;
+	}
+
+	high = prepare_input_addr(high);
+	if (!high) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	low = prepare_input_addr(low);
+	if (!low) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if (local_imr[i].occupied
+			&& (local_imr[i].addr.addr_low == low)
+			&& (local_imr[i].addr.addr_high == high)
+			&& (!local_imr[i].locked)) {
+				intel_qrk_remove_imr_entry(i);
+				return 0;
+			}
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(intel_qrk_imr_free);
+
+/**
+ * intel_qrk_imr_init_data
+ *
+ * @return nothing
+ * initialize local_imr data structure
+ */
+static void intel_qrk_imr_init_data(void)
+{
+	int i = 0;
+	char * res_str = "System Reserved Region";
+	int len = strlen(res_str);
+
+	intel_clm_imr_latch_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].reg = imr_reg_value[i];
+		memcpy(local_imr[i].info, res_str, len);
+	}
+}
+
+/**
+ * intel_qrk_imr_lockall
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * lock up all un-locked IMRs
+ */
+int intel_qrk_imr_lockall(void)
+{
+	int i = 0;
+	uint32_t temp_addr;
+
+	/* Enumerate IMR data structures */
+	intel_qrk_imr_init_data();
+	intel_qrk_imr_init_mask(imr_bit_mask);
+
+	/* Cycle through IMRs locking whichever are unlocked */
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		temp_addr = local_imr[i].addr.addr_low;
+		if (!(temp_addr & IMR_LOCK_BIT)) {
+
+			DBG("%s: locking IMR %d\n", __func__, i);
+			temp_addr |= IMR_LOCK_BIT;
+			intel_qrk_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+						local_imr[i].reg.imr_xl,
+						temp_addr, 0);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_imr_lockall);
+
+/**
+ * intel_qrk_imr_stat_show
+ *
+ * @param dev: pointer to device
+ * @param attr: attribute pointer
+ * @param buf: output buffer
+ * @return number of bytes successfully read
+ *
+ * Populates IMR state via /sys/device/intel-qrk-imr/stat
+ */
+static int intel_qrk_imr_stat_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int len = 0;
+	int i = 0;
+	int size, count = PAGE_SIZE;
+	uint32_t hi_phy_addr, lo_phy_addr;
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		/* read back the actual  input physical memory address */
+		hi_phy_addr = get_phy_addr(local_imr[i].addr.addr_high);
+		lo_phy_addr = get_phy_addr(local_imr[i].addr.addr_low);
+
+		/* the IMR always protect extra 1k memory size above the input
+		 * high reg value
+		 */
+		size = ((hi_phy_addr - lo_phy_addr) / IMR_MEM_ALIGN) + 1;
+
+		size = snprintf(buf+len, count,
+				"imr - id : %d\n"
+				"info     : %s\n"
+				"occupied : %s\n"
+				"locked   : %s\n"
+				"size     : %d kb\n"
+				"hi addr (phy): 0x%08x\n"
+				"lo addr (phy): 0x%08x\n"
+				"hi addr (vir): 0x%08x\n"
+				"lo addr (vir): 0x%08x\n"
+				"read mask  : 0x%08x\n"
+				"write mask : 0x%08x\n\n",
+				i,
+				local_imr[i].info,
+				local_imr[i].occupied ? "yes" : "no",
+				local_imr[i].locked ? "yes" : "no",
+				size,
+				hi_phy_addr,
+				lo_phy_addr,
+				(uint32_t)phys_to_virt(hi_phy_addr),
+				(uint32_t)phys_to_virt(lo_phy_addr),
+				local_imr[i].addr.read_mask,
+				local_imr[i].addr.write_mask);
+		len += size;
+		count -= size;
+	}
+	return len;
+}
+
+static struct device_attribute dev_attr_stats = {
+	.attr = {
+		.name = "stat",
+		.mode = 0444, },
+	.show = intel_qrk_imr_stat_show,
+};
+
+static struct attribute *platform_attributes[] = {
+	&dev_attr_stats.attr,
+	NULL,
+};
+
+static struct attribute_group imr_attrib_group = {
+	.attrs = platform_attributes
+};
+
+/**
+ * intel_qrk_imr_init
+ *
+ * @param dev_id: Host Bridge's PCI device ID
+ * @return 0 success < 0 failue
+ *
+ * module entry point
+ */
+int intel_qrk_imr_init(unsigned short dev_id)
+{
+	int ret;
+
+	host_id = dev_id;
+
+	pdev = platform_device_alloc(DRIVER_NAME, -1);
+	if (!pdev)
+		return -ENOMEM;
+
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto fail_platform;
+
+	/* initialise local imr data structure */
+	intel_qrk_imr_init_data();
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &imr_attrib_group);
+	if (ret)
+		goto fail_platform;
+
+	if(intel_qrk_imr_runt_setparams() == 0 && imr_lock == 1){
+                intel_qrk_imr_lockall();
+        }
+
+	return 0;
+
+fail_platform:
+	platform_device_del(pdev);
+	return ret;
+}
+EXPORT_SYMBOL(intel_qrk_imr_init);
+
+MODULE_DESCRIPTION("Intel Quark SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_qrk_imr.h b/drivers/platform/x86/quark/intel_qrk_imr.h
new file mode 100644
index 0000000..9f16c61
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_imr.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Quark SoC.
+ *
+ * A total number of 8 IMRs have implemented by Quark SoC,
+ * some IMRs might be already occupied by BIOS or Linux booting time.
+ *
+ * Input addresses parameter required the actual Physical address.
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, and apply with the default access right
+ * (CPU & CPU_snoop enable).
+ *
+ * The alloc_mask API takes input read & write masks values to set up
+ * IMR with customized access right.
+ *
+ * User can free IMR with pre-alloc specified addresses.
+ */
+
+#ifndef __INTEL_QRK_IMR_H__
+#define __INTEL_QRK_IMR_H__
+
+#include <linux/intel_qrk_sb.h>
+#include "asm/io.h"
+
+#define CFG_READ_OPCODE         0x10    /* BUnit Control Read */
+#define CFG_WRITE_OPCODE        0x11    /* BUnit control write */
+
+/* DRAM IMR register addresses */
+#define IMR0L			0x40
+#define IMR0H			0x41
+#define IMR0RM			0x42
+#define IMR0WM			0x43
+#define IMR1L			0x44
+#define IMR1H			0x45
+#define IMR1RM			0x46
+#define IMR1WM			0x47
+#define IMR2L			0x48
+#define IMR2H			0x49
+#define IMR2RM			0x4A
+#define IMR2WM			0x4B
+#define IMR3L			0x4C
+#define IMR3H			0x4D
+#define IMR3RM			0x4E
+#define IMR3WM			0x4F
+#define IMR4L			0x50
+#define IMR4H			0x51
+#define IMR4RM			0x52
+#define IMR4WM			0x53
+#define IMR5L			0x54
+#define IMR5H			0x55
+#define IMR5RM			0x56
+#define IMR5WM			0x57
+#define IMR6L			0x58
+#define IMR6H			0x59
+#define IMR6RM			0x5A
+#define IMR6WM			0x5B
+#define IMR7L			0x5C
+#define IMR7H			0x5D
+#define IMR7RM			0x5E
+#define IMR7WM			0x5F
+
+#define IMR_EN			0x40000000
+#define IMR_LOCK_BIT            0x80000000
+#define IMR_WRITE_ENABLE_ALL    0xFFFFFFFF
+#define IMR_READ_ENABLE_ALL     0xBFFFFFFF
+#define IMR_REG_MASK            0xFFFFFC
+
+#define IMR_ESRAM_FLUSH_INIT	0x80000000  /* esram flush */
+#define IMR_SNOOP_ENABLE	0x40000000  /* core snoops */
+#define IMR_PUNIT_ENABLE	0x20000000
+#define IMR_SMM_ENABLE		0x02        /* core SMM access */
+#define IMR_NON_SMM_ENABLE	0x01        /* core non-SMM access */
+#define IMR_BASE_ADDR           0x00
+#define IMR_MEM_ALIGN           0x400
+
+#define MAX_INFO_SIZE           64
+#define IMR_MAXID		8
+
+/* snoop + Non SMM write mask */
+#define IMR_DEFAULT_MASK	(IMR_SNOOP_ENABLE \
+				+ IMR_ESRAM_FLUSH_INIT \
+				+ IMR_NON_SMM_ENABLE)
+
+/* debug printk */
+#ifdef DEBUG
+#define DBG(args...) pr_info(args)
+#else
+#define DBG(args...)
+#endif
+
+extern unsigned long  _text;
+extern unsigned long  __init_begin;
+
+/**
+ * intel_qrk_imr_alloc
+ *
+ * @param high: the end of physical memory address
+ * @param low: the start of physical memory address
+ * @param read: IMR read mask value
+ * @param write: IMR write maks value
+ * @param info: imr information
+ * @param lock: imr lock
+ *
+ * Setup imr with customised read/ write masks
+ */
+int intel_qrk_imr_alloc(u32 high, u32 low, u32 read, u32 write,
+			unsigned char *info, bool lock);
+
+/**
+ * intel_qrk_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ *
+ * remove the imr based on input memory region
+ */
+int intel_qrk_imr_free(u32 high, u32 low);
+
+/**
+ * intel_qrk_remove_imr_entry
+ *
+ * @param id: internal imr data struct id
+ *
+ * Remove imr based on input imr data structure id
+ */
+void intel_qrk_remove_imr_entry(int id);
+
+/**
+ * intel_qrk_imr_init
+ *
+ * @param dev_id: Host Bridge's PCI device ID
+ * Initialise IMRs
+ */
+int intel_qrk_imr_init(unsigned short dev_id);
+
+#endif
diff --git a/drivers/platform/x86/quark/intel_qrk_imr_kernel.c b/drivers/platform/x86/quark/intel_qrk_imr_kernel.c
new file mode 100644
index 0000000..fdfaea3
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_imr_kernel.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Quark SoC.
+ *
+ * The IMR id 3 is pre-defined as the use for kernel data protection
+ *
+ * The early imr protects entire memory (from the beginning of kernel text
+ * section to the top of memory) during linux boot time. In the linux run
+ * time, the protection need to resize down to memory region that only
+ * contains: kernel text, read only data, and initialized data section.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/quark.h>
+#include <linux/printk.h>
+#include "intel_qrk_imr.h"
+
+/* pre-defined imr id for uncompressed kernel */
+#define IMR_KERNEL_ID	3
+
+/**
+ * addr_hw_ready
+ *
+ * shift input address value to match HW required 1k aligned format
+ */
+static inline uint32_t addr_hw_ready(uint32_t addr)
+{
+	/* memory alignment */
+	addr &= (~((1 << 10) - 1));
+
+	/* prepare input addr in HW required format */
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * void intel_qrk_imr_runt_kerndata_setup
+ *
+ * Setup imr for kernel text, read only data section
+ *
+ * The read only data (rodata) section placed between text and initialized data
+ * section by kernel.
+ */
+static void intel_qrk_imr_runt_kerndata_setup(void)
+{
+	uint32_t hi;
+	uint32_t lo;
+
+	hi = (uint32_t)virt_to_phys(&__init_begin);
+	lo = (uint32_t)virt_to_phys(&_text);
+
+	/* Set a locked IMR around the kernel .text section */
+	if (intel_qrk_imr_alloc((hi - IMR_MEM_ALIGN), lo,
+				IMR_DEFAULT_MASK, IMR_DEFAULT_MASK,
+				"KERNEL RUNTIME DATA", 1)) {
+		pr_err("IMR: Set up runtime kernel data imr faild!\n");
+		return;
+	}
+}
+
+/**
+ * intel_qrk_imr_teardown_unlocked
+ *
+ * Remove any unlocked IMR
+ *
+ */
+static void intel_qrk_imr_teardown_unlocked(void)
+{
+	int i = 0;
+	for (i = 0; i < IMR_MAXID; i++)
+		intel_qrk_remove_imr_entry(i);
+}
+
+/**
+ * intel_qrk_imr_runt_setparams
+ *
+ * set imr range for text, read only, initialised data in linux run time
+ */
+int intel_qrk_imr_runt_setparams(void)
+{
+	/* Setup an IMR around the kernel .text area */
+	intel_qrk_imr_runt_kerndata_setup();
+
+	/* Remove any other unlocked IMR */
+	intel_qrk_imr_teardown_unlocked();
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_qrk_imr_runt_setparams);
+
+/**
+ * intel_qrk_imr_runt_init
+ *
+ * module entry point
+ */
+static int  __init intel_qrk_imr_runt_init(void)
+{
+	return 0;
+}
+
+/**
+ * intel_qrk_imr_runt_exit
+ *
+ * Module exit
+ */
+static void __exit intel_qrk_imr_runt_exit(void)
+{
+	/* do nothing */
+}
+
+MODULE_DESCRIPTION("Intel Quark SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
+subsys_initcall(intel_qrk_imr_runt_init);
+module_exit(intel_qrk_imr_runt_exit);
diff --git a/drivers/platform/x86/quark/intel_qrk_imr_test.c b/drivers/platform/x86/quark/intel_qrk_imr_test.c
new file mode 100644
index 0000000..4f2096a
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_imr_test.c
@@ -0,0 +1,357 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark IMR Test module
+ *
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include "intel_qrk_imr.h"
+
+#define DRIVER_NAME			"intel_qrk_imr_test"
+
+/**
+ * XXX intel_qrk_sb.h needs to be updated with SB_ID_PUNIT and change
+ * propagated. This is a workaround to make it look less ugly. */
+#define SB_ID_PUNIT			SB_ID_THERMAL
+
+/* Memory-mapped SPI Flash address */
+#define ILB_SPIFLASH_BASEADDR			0xFF800000
+/* PUnit DMA block transfer size, in bytes */
+#define SPI_DMA_BLOCK_SIZE			512
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define IMR_TEST_IOCTL_CODE			0xE1
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_QRK_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_QRK_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
+
+/*****************************************************************************/
+
+/**
+ * struct intel_qrk_imr_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_qrk_imr_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_qrk_imr_test_dev imr_test_dev;
+static struct class *imr_test_class;
+static DEFINE_MUTEX(imr_test_mutex);
+static int imr_test_major;
+
+/* PUnit DMA registers over side-band */
+#define PUNIT_SPI_DMA_COUNT_REG		0x60
+#define PUNIT_SPI_DMA_DEST_REG		0x61
+#define PUNIT_SPI_DMA_SRC_REG		0x62
+
+/**
+ * ilb_spi_dma_read 
+ *
+ * @param src: physical address in Legacy SPI Flash
+ * @param dst: physical address of destination
+ * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
+ *
+ * Read-access iLB SPI via PUnit DMA engine.
+ * 
+ */
+static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
+{
+	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
+		dma_block_count);
+
+	/* Setup source and destination addresses. */
+	intel_qrk_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_SRC_REG, (u32) src, 0);
+	intel_qrk_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_DEST_REG, (u32) dst, 0);
+
+	pr_info("%s: starting transaction\n", __func__);
+
+	/*
+	 * Setup the number of block to be copied over. Transaction will start
+	 * as soon as the register is filled with value.
+	 */
+	intel_qrk_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_COUNT_REG, dma_block_count, 0);
+
+	/* Poll for completion. */
+	while (dma_block_count > 0) {
+		intel_qrk_sb_read_reg(SB_ID_PUNIT, CFG_READ_OPCODE,
+			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count, 0); 
+	}
+
+	pr_info("%s: transaction completed\n", __func__);
+}
+
+/**
+ * punit_dma_sanity_check 
+ *
+ * @return 0 if success, 1 if failure
+ *
+ * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
+ * Flash block. 
+ */
+static int punit_dma_sanity_check(void)
+{
+	int err = 0;
+	u32 *buffer = NULL;
+	u32 buf_ph_addr = 0;
+
+	/* Allocate 512B buffer for 1 SPI Flash block */
+	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
+        if (!buffer) {
+		err = -ENOMEM;
+		goto end;
+	}
+
+	/* DMA first SPI Flash block into buffer */
+	buf_ph_addr = (u32)virt_to_phys(buffer);
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
+
+	kfree(buffer);
+end:
+	return err;
+}
+
+/**
+ * imr_violate_kernel_punit_dma 
+ *
+ * @return always 0
+ *
+ * PUnit-DMA access to the Uncompressed Kernel IMR.
+ * This is based on set_imr_kernel_data() in intel_qrk_imr.c. Find the physical
+ * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
+ * 
+ */
+static int imr_violate_kernel_punit_dma(void)
+{
+	extern unsigned long _text;
+	u32 kernel_text = (u32)virt_to_phys(&_text);
+
+	/* We expect this to trigger an IMR violation reset */
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
+
+	/*
+	 * If we're still alive, we have a serious bug:
+	 * - we didn't appropriately target the IMR?
+	 * - if we have, weren't we prevented from accessing?
+	 * - if we weren't prevented, it's unlikely we're alive with a dirty
+	 *   text section
+	 */
+	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
+		__func__);
+
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long imr_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_QRK_SANITY_CHECK_PUNIT_DMA:
+			/* Check PUnit DMA actually works */
+			ret = punit_dma_sanity_check();
+			break;
+		case IOCTL_QRK_IMR_1:
+			/* Kernel IMR violation: PUnit DMA access */
+			ret = imr_violate_kernel_punit_dma();
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int imr_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
+		mutex_unlock(&imr_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (imr_test_dev.opened) {
+		mutex_unlock(&imr_test_dev.open_lock);
+		mutex_unlock(&imr_test_mutex);
+		return -EINVAL;
+	}
+
+	imr_test_dev.opened++;
+	mutex_unlock(&imr_test_dev.open_lock);
+	mutex_unlock(&imr_test_mutex);
+	return 0;
+}
+
+static int imr_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_dev.open_lock);
+	imr_test_dev.opened = 0;
+	mutex_unlock(&imr_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations imr_test_file_ops = {
+	.open = imr_test_open,
+	.release = imr_test_release,
+	.unlocked_ioctl = imr_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_qrk_imr_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_qrk_imr_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&imr_test_dev.open_lock);
+	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
+	imr_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(imr_test_class, NULL,
+				 MKDEV(imr_test_major, minor), NULL,
+				 "imrtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_qrk_imr_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
+
+	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
+	cdev_del(&imr_test_dev.cdev);
+
+	class_destroy(imr_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_imr_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_qrk_imr_test_remove,
+};
+
+/**
+ * intel_qrk_imr_test_init
+ *
+ * Load module.
+ */
+static int __init intel_qrk_imr_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	imr_test_class = class_create(THIS_MODULE,"qrk_imr_test");
+	if (IS_ERR(imr_test_class)) {
+		retval = PTR_ERR(imr_test_class);
+		printk(KERN_ERR "imr_test: can't register imr_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	imr_test_major = MAJOR(dev);
+
+	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
+	imr_test_dev.pldev = platform_create_bundle(
+		&intel_qrk_imr_test_driver, intel_qrk_imr_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(imr_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(imr_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(imr_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_qrk_imr_test_exit(void)
+{
+	platform_device_unregister(imr_test_dev.pldev);
+	platform_driver_unregister(&intel_qrk_imr_test_driver);
+}
+
+module_init(intel_qrk_imr_test_init);
+module_exit(intel_qrk_imr_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Quark IMR test module");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_clanton_hill.c b/drivers/platform/x86/quark/intel_qrk_plat_clanton_hill.c
new file mode 100644
index 0000000..3c489e8
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_clanton_hill.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME		"ClantonHill"
+#define GPIO_RESTRICT_NAME	"qrk-gpio-restrict-nc"
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+#define AD7298_MAX_EXT_VIN_EXT_BATT 30000
+#define AD7298_MAX_EXT_VIN_INT_BATT 9200
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN_EXT_BATT, AD7298_MAX_EXT_VIN_INT_BATT }
+};
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	},
+};
+
+/******************************************************************************
+ *             ST Microelectronics LIS331DLH I2C Device Platform Data
+ ******************************************************************************/
+#include <linux/platform_data/lis331dlh_intel_qrk.h>
+
+/* GPIO interrupt pins connected to the LIS331DLH */
+#define ST_ACCEL_INT1_GPIO 15
+#define ST_ACCEL_INT2_GPIO 4
+
+static struct lis331dlh_intel_qrk_platform_data lis331dlh_i2c_platform_data = {
+	.irq1_pin = ST_ACCEL_INT1_GPIO,
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		ST_ACCEL_INT1_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int1"
+	},
+	{
+		ST_ACCEL_INT2_GPIO,
+		GPIOF_IN,
+		"st_accel_i2c-int2"
+	},
+};
+
+/* I2C device addresses */
+#define MAX9867_ADDR				0x18
+#define LIS331DLH_ADDR				0x19
+
+static struct i2c_adapter *i2c_adap;
+static struct i2c_board_info probed_i2c_lis331dlh = {
+	.platform_data = &lis331dlh_i2c_platform_data,
+};
+static struct i2c_board_info probed_i2c_max9867;
+static const unsigned short max9867_i2c_addr[] =
+	{ MAX9867_ADDR, I2C_CLIENT_END };
+static const unsigned short lis331dlh_i2c_addr[] =
+	{ LIS331DLH_ADDR, I2C_CLIENT_END };
+
+static int i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	/* Always return success: the I2C clients are already known.  */
+	return 1;
+}
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Hill platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+				       ARRAY_SIZE(spi_onboard_devs));
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	static int gpio_done, spi_done;
+	struct i2c_client *max9867 = NULL, *lis331dlh = NULL;
+
+	if (gpio_done)
+		goto spi;
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret)
+		goto end;
+	gpio_done = 1;
+
+spi:
+	if (spi_done)
+		goto i2c;
+	ret = intel_qrk_spi_add_onboard_devs();
+	if (ret)
+		goto end;
+	spi_done = 1;
+i2c:
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+	strlcpy(probed_i2c_max9867.type, "intel-qrk-max9867", I2C_NAME_SIZE);
+	max9867 = i2c_new_probed_device(i2c_adap, &probed_i2c_max9867,
+					max9867_i2c_addr, i2c_probe);
+	strlcpy(probed_i2c_lis331dlh.type, "lis331dlh_qrk", I2C_NAME_SIZE);
+	lis331dlh = i2c_new_probed_device(i2c_adap, &probed_i2c_lis331dlh,
+					lis331dlh_i2c_addr, i2c_probe);
+	i2c_put_adapter(i2c_adap);
+
+	if (NULL == max9867 || NULL == lis331dlh) {
+		pr_err("%s: can't probe I2C devices\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_clanton_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_qrk_plat_clanton_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_clanton_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_clanton_hill_probe,
+	.remove		= intel_qrk_plat_clanton_hill_remove,
+};
+
+module_platform_driver(qrk_clanton_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Clanton Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_clanton_peak.c b/drivers/platform/x86/quark/intel_qrk_plat_clanton_peak.c
new file mode 100644
index 0000000..9edcef7
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_clanton_peak.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Clanton Peak board entry point
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/spi/spi_gpio.h>
+
+#define DRIVER_NAME		"ClantonPeakSVP"
+#define GPIO_RESTRICT_NAME_NC	"qrk-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC	"qrk-gpio-restrict-sc"
+
+
+/* GPIO connected to Test Equipment */
+#define SUT_GPIO_NC_3				0x03
+#define SUT_GPIO_NC_4				0x04
+#define SUT_GPIO_NC_5				0x05
+#define SUT_GPIO_NC_6				0x06
+#define SUT_GPIO_SC_2				0x0A
+#define SUT_GPIO_SC_3				0x0B
+#define SUT_GPIO_SC_4				0x0C
+#define SUT_GPIO_SC_5				0x0D
+
+#define GPIO_NC_BITBANG_SPI_BUS			2
+#define GPIO_SC_BITBANG_SPI_BUS			3
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/*
+ * Define platform data for bitbanged SPI devices.
+ * Assign GPIO to SCK/MOSI/MISO
+ */
+static struct spi_gpio_platform_data spi_gpio_nc_data = {
+	.sck = SUT_GPIO_NC_3,
+	.mosi = SUT_GPIO_NC_4,
+	.miso = SUT_GPIO_NC_5,
+	.num_chipselect = 1,
+};
+static struct spi_gpio_platform_data spi_gpio_sc_data = {
+	.sck = SUT_GPIO_SC_2,
+	.mosi = SUT_GPIO_SC_3,
+	.miso = SUT_GPIO_SC_4,
+	.num_chipselect = 1,
+};
+
+/*
+ * Board information for bitbanged SPI devices.
+ */
+static const struct spi_board_info spi_gpio_nc_bi[] = {
+	{
+	.modalias	= "spidev",
+	.max_speed_hz	= 1000,
+	.bus_num	= GPIO_NC_BITBANG_SPI_BUS,
+	.mode		= SPI_MODE_0,
+	.platform_data	= &spi_gpio_nc_data,
+	/* Assign GPIO to CS */
+	.controller_data = (void *)SUT_GPIO_NC_6,
+	},
+};
+static const struct spi_board_info spi_gpio_sc_bi[] = {
+	{
+	.modalias	= "spidev",
+	.max_speed_hz	= 1000,
+	.bus_num	= GPIO_SC_BITBANG_SPI_BUS,
+	.mode		= SPI_MODE_0,
+	.platform_data	= &spi_gpio_sc_data,
+	/* Assign GPIO to CS */
+	.controller_data = (void *)SUT_GPIO_SC_5,
+	},
+};
+
+static struct platform_device spi_gpio_nc_pd = {
+	.name	= "spi_gpio",
+	.id	= GPIO_NC_BITBANG_SPI_BUS,
+	.dev	= {
+		.platform_data = &spi_gpio_nc_data,
+	},
+};
+
+static struct platform_device spi_gpio_sc_pd = {
+	.name	= "spi_gpio",
+	.id	= GPIO_SC_BITBANG_SPI_BUS,
+	.dev	= {
+		.platform_data = &spi_gpio_sc_data,
+	},
+};
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Peak platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+static int register_bitbanged_spi(int nc)
+{
+	int ret = 0;
+
+	ret = platform_device_register(nc ? &spi_gpio_nc_pd : &spi_gpio_sc_pd);
+	if (ret)
+		goto err;
+
+	ret = spi_register_board_info(nc ? spi_gpio_nc_bi : spi_gpio_sc_bi,
+				      nc ? ARRAY_SIZE(spi_gpio_nc_bi) : 
+				           ARRAY_SIZE(spi_gpio_sc_bi));
+	if (ret)
+		goto err_unregister;
+
+	return 0;
+
+err_unregister:
+	platform_device_unregister(nc ? &spi_gpio_nc_pd : &spi_gpio_sc_pd);
+err:
+	return ret;
+}
+
+static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	return register_bitbanged_spi(1);
+}
+
+static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	return register_bitbanged_spi(0);
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_sc,
+};
+
+static int intel_qrk_plat_clanton_peak_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret) {
+		pr_err("%s: couldn't register %s platform driver\n",
+		       __func__, gpio_restrict_pdriver_nc.driver.name);
+	}
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_sc);
+	if (ret) {
+		pr_err("%s: couldn't register %s platform driver\n",
+		       __func__, gpio_restrict_pdriver_sc.driver.name);
+	}
+		
+	return intel_qrk_spi_add_onboard_devs();
+}
+
+static int intel_qrk_plat_clanton_peak_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver clanton_peak_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_clanton_peak_probe,
+	.remove		= intel_qrk_plat_clanton_peak_remove,
+};
+
+module_platform_driver(clanton_peak_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Clanton Peak BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
new file mode 100644
index 0000000..eb1960a
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
@@ -0,0 +1,392 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * CrossHill board entry point
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME		"CrossHill"
+#define GPIO_RESTRICT_NAME_NC	"qrk-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC	"qrk-gpio-restrict-sc"
+
+/*
+ * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
+ */
+#define SPI_BPEAK_RESET_GPIO 4
+#define SPI_BPEAK_ID0_GPIO   3
+#define SPI_BPEAK_ID1_GPIO   2
+#define SPI_BPEAK_ID2_GPIO   15
+#define SPI_BPEAK_ID3_GPIO   14
+
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
+static int cross_hill_probe;
+
+/*
+ * Blackburn Peak SPI daughterboard ID values
+ */
+enum {
+	QRK_SPI_BPEAK_ID_ZB_TI = 0xA,
+	QRK_SPI_BPEAK_ID_ZB_DIGI,
+	QRK_SPI_BPEAK_ID_ZB_INFR_NXP,
+	QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
+	QRK_SPI_BPEAK_ID_ADC_MAXIM,
+	QRK_SPI_BPEAK_ID_NONE
+};
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *             Maxim 78M6610+LMU SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/max78m6610_lmu.h"
+
+static const struct max78m6610_lmu_platform_data max78m6610_lmu_pdata = {
+	.reset_gpio = SPI_BPEAK_RESET_GPIO,
+};
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_1 = {
+	.gpio_cs = 11,
+};
+
+static struct spi_board_info spi_generic_devs[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 1,
+		.controller_data = &qrk_ffrd_spi_1_cs_1,
+	},
+
+};
+
+static struct spi_board_info spi_energy_adc_devs[] = {
+	{
+		.modalias = "max78m6610_lmu",
+		.max_speed_hz = 2000000,
+		.platform_data = &max78m6610_lmu_pdata,
+		.mode = SPI_MODE_3,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+};
+
+
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Cross Hill platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	struct spi_board_info spi_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = 5000000,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &qrk_ffrd_spi_0_cs_0,
+		},
+	};
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_qrk_spi_get_bpeak_id
+ *
+ * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
+ * @return 0 on success or standard errnos on failure
+ *
+ * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
+ */
+static int intel_qrk_spi_get_bpeak_id(u8 *bpeak_id)
+{
+	int ret = 0;
+	struct gpio spi_bpeak_id_gpios[] = {
+		{
+			SPI_BPEAK_RESET_GPIO,
+			GPIOF_OUT_INIT_HIGH,
+			"spi_bpeak_reset"
+		},
+		{
+			SPI_BPEAK_ID0_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id0"
+		},
+		{
+			SPI_BPEAK_ID1_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id1"
+		},
+		{
+			SPI_BPEAK_ID2_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id2"
+		},
+		{
+			SPI_BPEAK_ID3_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id3"
+		}
+	};
+
+	/*
+	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
+	 * while a RESET GPIO output is asserted (active-low)
+	 */
+	ret = gpio_request_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
+				__func__);
+		return ret;
+	}
+
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
+	*bpeak_id =
+		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
+
+	gpio_free_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+
+	return 0;
+}
+
+/**
+ * intel_qrk_spi_add_bpeak_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers SPI device(s) indicated by the ID value obtained from a
+ * Blackburn Peak SPI daughterboard
+ */
+static int intel_qrk_spi_add_bpeak_devs(void)
+{
+	u8 spi_bpeak_id = 0;
+	int ret = 0;
+
+	ret = intel_qrk_spi_get_bpeak_id(&spi_bpeak_id);
+	if (ret) {
+		pr_err("%s: failed to obtain Blackburn Peak ID\n",
+				__func__);
+		return ret;
+	}
+
+	switch (spi_bpeak_id) {
+
+	case QRK_SPI_BPEAK_ID_NONE:
+		break;
+
+	case QRK_SPI_BPEAK_ID_ADC_MAXIM:
+		{
+			return spi_register_board_info(spi_energy_adc_devs,
+					ARRAY_SIZE(spi_energy_adc_devs));
+		}
+	case QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
+		{
+			pr_debug("QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+		}
+	case QRK_SPI_BPEAK_ID_ZB_DIGI:
+		{
+			pr_debug("QRK_SPI_BPEAK_ID_ZB_DIGI load.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+
+		}
+	default:
+			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
+					__func__, spi_bpeak_id);
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/** intel_qrk_spi_devs_addon
+ *
+ * addon spi device when gpio support in place
+ */
+static int intel_qrk_spi_devs_addon(void)
+{
+	int ret = 0;
+
+	if (cross_hill_probe != 1) {
+
+		ret = intel_qrk_spi_add_onboard_devs();
+		if (ret)
+			return ret;
+
+		ret = intel_qrk_spi_add_bpeak_devs();
+
+		cross_hill_probe = 1;
+	}
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_nc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	int ret;
+	nc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_qrk_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_sc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	int ret;
+	sc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_qrk_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_sc,
+};
+
+static int intel_qrk_plat_cross_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&gpio_restrict_pdriver_sc);
+}
+
+static int intel_qrk_plat_cross_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_cross_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_cross_hill_probe,
+	.remove		= intel_qrk_plat_cross_hill_remove,
+};
+
+module_platform_driver(qrk_cross_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Cross Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_galileo.c b/drivers/platform/x86/quark/intel_qrk_plat_galileo.c
new file mode 100644
index 0000000..0df0ac0
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_galileo.c
@@ -0,0 +1,398 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/mfd/cy8c9540a.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c/at24.h>
+
+#define DRIVER_NAME 		"Galileo"
+#define GPIO_RESTRICT_NAME 	"qrk-gpio-restrict-sc"
+#define LPC_SCH_SPINAME		"spi-lpc-sch"
+
+/* GPIO line used to detect the LSB of the Cypress i2c address */
+#define GPIO_CYPRESS_A0			7
+/* GPIO line Cypress interrupts are routed to (in S0 power state) */
+#define GPIO_CYPRESS_INT_S0		13
+/* GPIO line Cypress interrupts are routed to (in S3 power state) */
+#define GPIO_CYPRESS_INT_S3		2
+
+/* Cypress i2c address depending on A0 value */
+#define CYPRESS_ADDR_A0_1		0x20
+#define CYPRESS_ADDR_A0_0		0x21
+#define EEPROM_ADDR_A0_1		0x50
+#define EEPROM_ADDR_A0_0		0x51
+
+/******************************************************************************
+ *                   Cypress I/O Expander Platform Data
+ ******************************************************************************/
+static struct cy8c9540a_pdata cy8c9540a_platform_data = {
+	.por_default		= {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,	/* Output */
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, /* Int mask */
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* PWM */
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Inversion */
+		0xe0, 0xe0, 0xff, 0xf3, 0x00, 0xff, 0xff, 0xff, /* Direction */
+		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* P0 drive */
+		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,	/* P1 drive */
+		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P2 drive */
+		0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,	/* P3 drive */
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,	/* P4 drive */
+		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P5 drive */
+		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P6 drive */
+		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* P7 drive */
+		0x00, 0xff, 0x00,				/* PWM0 */
+		0x00, 0xff, 0x00,				/* PWM1 */
+		0x00, 0xff, 0x00,				/* PWM2 */
+		0x00, 0xff, 0x00,				/* PWM3 */
+		0x00, 0xff, 0x00,				/* PWM4 */
+		0x00, 0xff, 0x00,				/* PWM5 */
+		0x00, 0xff, 0x00,				/* PWM6 */
+		0x00, 0xff, 0x00,				/* PWM7 */
+		0x00, 0xff, 0x00,				/* PWM8 */
+		0x00, 0xff, 0x00,				/* PWM9 */
+		0x00, 0xff, 0x00,				/* PWM10 */
+		0x00, 0xff, 0x00,				/* PWM11 */
+		0x00, 0xff, 0x00,				/* PWM12 */
+		0x00, 0xff, 0x00,				/* PWM13 */
+		0x00, 0xff, 0x00,				/* PWM14 */
+		0x00, 0xff, 0x00,				/* PWM15 */
+		0xff,						/* PWM CLKdiv */
+		0x02,						/* EEPROM en */
+		0x00						/* CRC */
+	},
+	.pwm2gpio_mapping	= {
+		CY8C9540A_PWM_UNUSED,
+		3,
+		CY8C9540A_PWM_UNUSED,
+		2,
+		9,
+		1,
+		8,
+		0,
+	},
+	.gpio_base		= 16,
+	.pwm_base		= 0,
+	.irq_base		= 64, 
+}; 
+
+/* Cypress expander requires i2c master to operate @100kHz 'standard mode' */
+static struct intel_qrk_gip_pdata gip_pdata = {
+	.i2c_std_mode = 1,
+};
+static struct intel_qrk_gip_pdata *galileo_gip_get_pdata(void)
+{
+	return &gip_pdata;
+}
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+static struct at24_platform_data at24_platform_data = {
+	.byte_len = (11 * 1024),
+	.page_size = 1,
+	.flags = AT24_FLAG_ADDR16,
+};
+
+/******************************************************************************
+ *                        Intel Izmir i2c clients
+ ******************************************************************************/
+static struct i2c_board_info probed_i2c_cypress = {
+	.platform_data = &cy8c9540a_platform_data,
+};
+static struct i2c_board_info probed_i2c_eeprom = {
+	.platform_data = &at24_platform_data,
+};
+static struct i2c_adapter *i2c_adap;
+static const unsigned short cypress_i2c_addr[] =
+	{ CYPRESS_ADDR_A0_1, CYPRESS_ADDR_A0_0, I2C_CLIENT_END };
+static const unsigned short eeprom_i2c_addr[] =
+	{ EEPROM_ADDR_A0_1, EEPROM_ADDR_A0_0, I2C_CLIENT_END };
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+#define LPC_SCH_SPI_BUS_ID 0x03
+
+/* TODO: extract this data from layout.conf encoded in flash */
+struct mtd_partition ilb_partitions [] = {
+	{
+		.name		= "grub",
+		.size		= 4096,
+		.offset		= 0,
+	},
+	{
+		.name		= "grub.conf",
+		.size		= 0xA00,
+		.offset		= 0x50500,
+	},
+	{
+		.name		= "layout.conf",
+		.size		= 4096,
+		.offset		= 0x708000,
+	},
+	{
+		.name		= "sketch",
+		.size		= 0x40000,
+		.offset		= 0x750000,
+	},
+	{
+		.name		= "raw",
+		.size		= 8192000,
+		.offset		= 0,
+
+	},
+};
+
+static struct flash_platform_data ilb_flash = {
+	.type = "s25fl064k",
+	.parts = ilb_partitions,
+	.nr_parts = ARRAY_SIZE(ilb_partitions),
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "m25p80",
+		.platform_data = &ilb_flash,
+		.bus_num = LPC_SCH_SPI_BUS_ID,
+		.chip_select = 0,
+	},
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_CYPRESS_A0,
+		GPIOF_IN,
+		"cy8c9540a-a0",
+	},
+	{
+		GPIO_CYPRESS_INT_S0,
+		GPIOF_IN,
+		"cy8c9540a-int-s0",
+	},
+	{
+		GPIO_CYPRESS_INT_S3,
+		GPIOF_IN,
+		"cy8c9540a-int-s3",
+	},
+};
+
+static int eeprom_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	if (gpio_get_value(GPIO_CYPRESS_A0) && EEPROM_ADDR_A0_1 == addr)
+		return 1;
+	if (!gpio_get_value(GPIO_CYPRESS_A0) && EEPROM_ADDR_A0_0 == addr)
+		return 1;
+	return 0;
+}
+static int cypress_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	if (gpio_get_value(GPIO_CYPRESS_A0) && CYPRESS_ADDR_A0_1 == addr)
+		return 1;
+	if (!gpio_get_value(GPIO_CYPRESS_A0) && CYPRESS_ADDR_A0_0 == addr)
+		return 1;
+	return 0;
+}
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Izmir platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Register devices that depend on GPIOs.
+ * Note this function makes extensive use of the probe deferral mechanism:
+ * gpio_request() for a GPIO that is not yet available returns
+ * -EPROBE_DEFER.
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct i2c_client *cypress = NULL, *eeprom = NULL;
+	static int spi_done;
+	static int gpios_done;
+
+	if (spi_done)
+		goto gpios;
+
+	ret = intel_qrk_spi_add_onboard_devs();
+	if (ret)
+		goto end;
+
+	spi_done = 1;
+
+gpios:
+	if (gpios_done)
+		goto i2c;
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret)
+		goto end;
+
+	probed_i2c_cypress.irq = gpio_to_irq(GPIO_CYPRESS_INT_S0);
+
+	gpios_done = 1;
+
+i2c:
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+	strlcpy(probed_i2c_cypress.type, "cy8c9540a", I2C_NAME_SIZE);
+	cypress = i2c_new_probed_device(i2c_adap, &probed_i2c_cypress,
+					cypress_i2c_addr, cypress_i2c_probe);
+	strlcpy(probed_i2c_eeprom.type, "at24", I2C_NAME_SIZE);
+	eeprom = i2c_new_probed_device(i2c_adap, &probed_i2c_eeprom,
+					eeprom_i2c_addr, eeprom_i2c_probe);
+	i2c_put_adapter(i2c_adap);
+
+	if (NULL == cypress || NULL == eeprom) {
+		pr_err("%s: can't probe Cypress Expander\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_galileo_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	/* Assign GIP driver handle for board-specific settings */
+	intel_qrk_gip_get_pdata = galileo_gip_get_pdata;
+
+	/* gpio */
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+	if (ret)
+		goto end;
+
+#if 0
+	/* legacy SPI - TBD */
+	ret = platform_driver_register(&intel_qrk_plat_galileo_lpcspi_pdriver);
+	if (ret)
+		goto end;
+#endif	
+end:
+	return ret;
+}
+
+static int intel_qrk_plat_galileo_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_galileo_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_galileo_probe,
+	.remove		= intel_qrk_plat_galileo_remove,
+};
+
+module_platform_driver(qrk_galileo_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Galileo BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_kips_bay.c b/drivers/platform/x86/quark/intel_qrk_plat_kips_bay.c
new file mode 100644
index 0000000..5e94b4b
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_kips_bay.c
@@ -0,0 +1,176 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME		"KipsBay"
+#define GPIO_RESTRICT_NAME	"qrk-gpio-restrict-sc"
+
+static int gpio_cs = 1;
+
+module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+static struct spi_board_info spi0_onboard_devs[] = {
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = 5000000,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_0_cs_0,
+	}
+};
+
+static struct spi_board_info spi1_onboard_devs_gpiocs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+};
+
+static struct spi_board_info spi1_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = NULL,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Kips Bay platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	int ret = 0;
+
+	ret = spi_register_board_info(spi0_onboard_devs,
+				      ARRAY_SIZE(spi0_onboard_devs));
+	if (ret)
+		return ret;
+
+	if (gpio_cs)
+		return spi_register_board_info(spi1_onboard_devs_gpiocs,
+					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
+	else
+		return spi_register_board_info(spi1_onboard_devs,
+					ARRAY_SIZE(spi1_onboard_devs));
+}
+
+
+/**
+ * intel_qrk_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe(struct platform_device *pdev)
+{
+	return intel_qrk_spi_add_onboard_devs();
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe,
+};
+
+static int intel_qrk_plat_kips_bay_probe(struct platform_device *pdev)
+{
+	return platform_driver_register(&gpio_restrict_pdriver);
+}
+
+static int intel_qrk_plat_kips_bay_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_kips_bay_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_kips_bay_probe,
+	.remove		= intel_qrk_plat_kips_bay_remove,
+};
+
+module_platform_driver(qrk_kips_bay_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Kips Bay BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/drivers/platform/x86/quark/intel_qrk_sb.c b/drivers/platform/x86/quark/intel_qrk_sb.c
new file mode 100644
index 0000000..658c41f
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_sb.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark side-band driver
+ *
+ * Thread-safe sideband read/write routine.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
+ */
+
+#include <linux/errno.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include "intel_qrk_imr.h"
+
+#define INTEL_QRK_SB_CMD_ADDR	(0x000000D0)
+#define INTEL_QRK_SB_DATA_ADDR	(0x000000D4)
+
+#define INTEL_QRK_SB_MCR_SHIFT	(24)
+#define INTEL_QRK_SB_PORT_SHIFT	(16)
+#define INTEL_QRK_SB_REG_SHIFT	(8)
+#define INTEL_QRK_SB_BYTEEN	(0xF0)	/* enable all 32 bits */
+
+/* Simple structure for module */
+struct intel_qrk_sb_dev{
+	struct pci_dev * pdev;
+	spinlock_t slock;
+	u8 initialized;
+};
+
+static struct intel_qrk_sb_dev sb_dev = {
+	.initialized = 0
+};
+
+/* Dependant drivers */
+static struct platform_device pdev [] = {
+	{
+		.name = "intel-qrk-esram",
+	},
+	{
+		.name = "intel-qrk-ecc",
+	},
+	{
+		.name = "intel-qrk-thrm",
+	},
+};
+
+/**
+ * intel_qrk_sb_read_reg
+ *
+ * @param qrk_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to qrk_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+void intel_qrk_sb_read_reg(qrk_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_QRK_SB_MCR_SHIFT) | 
+		  ((id << INTEL_QRK_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_QRK_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_QRK_SB_BYTEEN;
+
+	if(data == NULL)
+		return;
+
+	if (likely(lock == 1)) {
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_QRK_SB_CMD_ADDR, msg);
+	pci_read_config_dword(sb_dev.pdev, INTEL_QRK_SB_DATA_ADDR, data);
+
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+
+}
+EXPORT_SYMBOL(intel_qrk_sb_read_reg);
+
+/**
+ * intel_qrk_sb_write_reg
+ *
+ * @param qrk_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to qrk_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+void intel_qrk_sb_write_reg(qrk_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_QRK_SB_MCR_SHIFT) | 
+		  ((id << INTEL_QRK_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_QRK_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_QRK_SB_BYTEEN;
+
+	if(likely(lock == 1)){
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_QRK_SB_DATA_ADDR, data);
+	pci_write_config_dword(sb_dev.pdev, INTEL_QRK_SB_CMD_ADDR, msg);
+	
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+}
+EXPORT_SYMBOL(intel_qrk_sb_write_reg);
+
+/**
+ * intel_qrk_sb_runfn_lock
+ *
+ * @param fn: Callback function - which requires side-band spinlock and !irq
+ * @param arg: Callback argument
+ * @return 0 on success < 0 on failure
+ *
+ * Runs the given function pointer inside of a call to the local spinlock using
+ * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
+ * guarantee atomicity, but, available to any other user of sideband provided
+ * rules are respected.
+ * Rules:
+ *	fn may not sleep
+ *	fn may not change the state of irqs	
+ */
+int intel_qrk_sb_runfn_lock(int (*fn)( void * arg ), void * arg)
+{
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if(unlikely(fn == NULL)){
+		return -EINVAL;
+	}
+	
+	/* Get spinlock with IRQs off */
+	spin_lock_irqsave(&sb_dev.slock, flags);
+
+	/* Run function atomically */
+	ret = fn(arg);
+
+	/* Release lock */
+	spin_unlock_irqrestore(&sb_dev.slock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_qrk_sb_runfn_lock);
+
+/**
+ * sb_probe
+ *
+ * @param dev: the PCI device matching
+ * @param id: entry in the match table
+ * @return 0
+ *
+ * Callback from PCI layer when dev/vendor ids match.
+ * Sets up necessary resources
+ */
+static int intel_qrk_sb_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int i = 0;
+
+	/* Init struct */
+	memset(&sb_dev, 0x00, sizeof(sb_dev));
+
+	/* Hook device */
+	sb_dev.pdev = dev;
+
+	/* Init locking structures */
+	spin_lock_init(&sb_dev.slock);
+
+	/* Set state */
+	sb_dev.initialized = 1;
+
+	/* Register side-band sub-ordinate drivers */
+	for (i = 0; i < sizeof(pdev)/sizeof(struct platform_device); i++){
+		/* Register side-band sub-ordinate drivers */
+		platform_device_register(&pdev[i]);
+	}
+	pr_info("Intel Quark side-band driver registered\n");
+
+	/* Switch off boot-time IMRs nice and early */
+	return intel_qrk_imr_init(dev->device);
+}
+
+/**
+ * sb_remove
+ *
+ * @param pdev: PCI device
+ * @return nothing
+ *
+ * Callback from PCI sub-system upon PCI dev removal
+ */
+static void intel_qrk_sb_remove(struct pci_dev *pdev)
+{
+}
+
+/* Quark hardware */
+struct pci_device_id intel_qrk_sb_ids[] = {
+        { PCI_VDEVICE(INTEL, PCI_DEVICE_ID_X1000_HOST_BRIDGE), 0},
+        { PCI_VDEVICE(INTEL, 0x12C0), 0},
+        { 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, intel_qrk_sb_ids);
+
+/* PCI callbacks */
+static struct pci_driver intel_qrk_sb_driver = {
+	.name = "intel_qrk_sb",
+	.id_table = intel_qrk_sb_ids,
+	.probe = intel_qrk_sb_probe,
+	.remove = intel_qrk_sb_remove,
+};
+
+/**
+ * intel_qrk_sb_init
+ *
+ * Module entry point
+ */
+static int __init intel_qrk_sb_init(void)
+{
+	return pci_register_driver(&intel_qrk_sb_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Quark SOC side-band driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+/* Initialise early since other drivers eSRAM, DRAM ECC and thermal depend */
+subsys_initcall(intel_qrk_sb_init);
diff --git a/drivers/platform/x86/quark/intel_qrk_thermal.c b/drivers/platform/x86/quark/intel_qrk_thermal.c
new file mode 100644
index 0000000..d603d8b
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_thermal.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark Thermal driver
+ */
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_qrk_sb.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+#include <linux/timer.h>
+
+#define DRIVER_NAME		"intel-qrk-thrm"
+
+/* Definition of register locations for thermal management */
+#define THRM_CTRL_REG		(0x80)		/* Thermal control */
+#define THRM_MODE_REG		(0xB0)		/* Thermal mode */
+#define THRM_MODE_SENSOR_EN	(0x00008000)	/* Thermal mode sensor enable */
+#define THRM_TEMP_REG		(0xB1)		/* Thermal sensor temperature */
+#define THRM_TRPCLR_REG		(0xB2)		/* Catastropic/Hot trip/clear */
+#define THRM_AUXTRP_REG		(0xB3)		/* Aux0-Aux3 trip point */
+#define THRM_AUXCLR_REG		(0xB4)		/* Aux0-Aux3 clear trip */
+#define THRM_STATUS_REG		(0xB5)		/* Thermal sensor status */
+#define THRM_TRIPBEHAVE_REG	(0xB6)		/* Trip point behavior */
+#define THRM_MSIADDR_REG	(0xC5)		/* Thermal MSI addres reg */
+#define THRM_MSIDATA_REG	(0xC6)		/* Thermal MSI data reg */
+#define THRM_CTRL_READ		(0x10)		/* Config reg */
+#define THRM_CTRL_WRITE		(0x11)		/* Config reg */
+
+#define SOC_TSENSOR_REG		(0x34)
+#define SOC_TSENSOR_RST		(0x00000001)
+#define SOC_CTRL_READ		(0x06)
+#define SOC_CTRL_WRITE		(0x07)
+
+
+#define THRM_ZONE_COUNT		2		/* Only hot/critical relevant */
+#define ACTIVE_INTERVAL		(1000)
+#define IDLE_INTERVAL		(20000)
+#define MCELSIUS(x)		((x) * 1000)
+
+/* CPU Zone information */
+#define CATASTROPIC_ZONE	0
+#define HOT_ZONE		1
+#define AUX0_ZONE		2		/* Unused */
+#define AUX1_ZONE		3		/* Unused */
+#define AUX2_ZONE		4		/* Unused */
+#define AUX3_ZONE		5		/* Unused */
+#define MIN_USED_ZONE		CATASTROPIC_ZONE
+#define MAX_USED_ZONE		HOT_ZONE
+/*
+ * Default catastrophic/hot trip values - in degrees celsius
+ * Maximum temperature is 105 degrees
+ */
+#define CRIT_TEMP	104
+#define HOT_TEMP	95
+#define RAW2CELSIUS_DIFF	50
+
+static int driver_enable = 1;
+module_param(driver_enable, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(driver_enable, "Disable Thermal Driver Polling");
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_qrk_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_qrk_sb_write_reg
+#endif
+
+struct intel_qrk_therm_zone {
+	enum thermal_trip_type type;
+	int trip_value;
+};
+
+/**
+ * struct intel_qrk_thermal_dev
+ *
+ */
+struct intel_qrk_thermal_dev {
+	enum thermal_device_mode mode;
+	struct intel_qrk_therm_zone tzone[THRM_ZONE_COUNT];
+	struct mutex lock;
+	struct platform_device *pldev;		/* Platform device */
+	struct thermal_zone_device *therm_dev;	/* Thermal device */
+};
+
+static struct intel_qrk_thermal_dev qrk_tdev;
+
+/******************************************************************************
+ *                        Thermal API implementation
+ ******************************************************************************/
+
+/**
+ * get_temp
+ *
+ * @param tz: Thermal zone descriptor
+ *
+ * Get the current temperature
+ * We have exactly one thermal zone/sensor
+ * Value passed is an unsigned long - our sensor reports up to -50 celsius so we
+ * just clip at zero if the temperature is negative.
+ */
+static int intel_qrk_thermal_get_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TEMP_REG, (u32 *)temp, 1);
+	*temp -= RAW2CELSIUS_DIFF;
+
+	/* Clip to unsigned output value if sensor is reporting sub-zero */
+	if ((int)*temp < 0)
+		*temp = 0;
+
+	*temp = MCELSIUS(*temp&0x000000FF);
+
+	return 0;
+}
+
+/**
+ * get_trend
+ *
+ * Wears good clothes
+ */
+static int intel_qrk_thermal_get_trend(struct thermal_zone_device *tz,
+			int trip, enum thermal_trend *trend)
+{
+	if (tz->temperature >= trip)
+		*trend = THERMAL_TREND_RAISING;
+	else
+		*trend = THERMAL_TREND_DROPPING;
+
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_get_mode
+ *
+ * Get the mode
+ */
+static int intel_qrk_thermal_get_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode *mode)
+{
+	mutex_lock(&qrk_tdev.lock);
+	*mode = qrk_tdev.mode;
+	mutex_unlock(&qrk_tdev.lock);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_set_mode
+ *
+ * Set the mode
+ */
+static int intel_qrk_thermal_set_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode mode)
+{
+	mutex_lock(&qrk_tdev.lock);
+
+	if (mode == THERMAL_DEVICE_ENABLED)
+		qrk_tdev.therm_dev->polling_delay = IDLE_INTERVAL;
+	else
+		qrk_tdev.therm_dev->polling_delay = 0;
+	qrk_tdev.mode = mode;
+
+	mutex_unlock(&qrk_tdev.lock);
+
+	thermal_zone_device_update(qrk_tdev.therm_dev);
+	pr_info("thermal polling set for duration=%d msec\n",
+				qrk_tdev.therm_dev->polling_delay);
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_get_trip_type
+ *
+ * Get trip type
+ */
+static int intel_qrk_thermal_get_trip_type(struct thermal_zone_device *tz,
+				int trip, enum thermal_trip_type *type)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	*type = qrk_tdev.tzone[trip].type;
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_get_trip_temp
+ *
+ * Get trip temp
+ */
+static int intel_qrk_thermal_get_trip_temp(struct thermal_zone_device *tz,
+				int trip, unsigned long *temp)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	/* Convert the temperature into millicelsius */
+	*temp = qrk_tdev.tzone[trip].trip_value;
+
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_get_trip_type
+ *
+ * Get trip temp
+ */
+static int intel_qrk_thermal_get_crit_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	/* Critical zone */
+	*temp = qrk_tdev.tzone[CATASTROPIC_ZONE].trip_value;
+	return 0;
+}
+
+static struct thermal_zone_device_ops intel_qrk_thrm_dev_ops = {
+	.get_temp = intel_qrk_thermal_get_temp,
+	.get_trend = intel_qrk_thermal_get_trend,
+	.get_mode = intel_qrk_thermal_get_mode,
+	.set_mode = intel_qrk_thermal_set_mode,
+	.get_trip_type = intel_qrk_thermal_get_trip_type,
+	.get_trip_temp = intel_qrk_thermal_get_trip_temp,
+	.get_crit_temp = intel_qrk_thermal_get_crit_temp,
+};
+
+
+
+/**
+ * intel_qrk_init_zone
+ *
+ * Initialise a zone
+ */
+static void intel_qrk_thermal_init_zone(struct intel_qrk_therm_zone *tz,
+				enum thermal_trip_type type, int trip_value)
+{
+	tz->type = type;
+	tz->trip_value = MCELSIUS(trip_value);
+}
+
+/******************************************************************************
+ *                        Module Entry/Exit hooks
+ ******************************************************************************/
+
+/**
+ * intel_qrk_thermal_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This routine registers a thermal device with the kernel's thermal management
+ * sub-system
+ */
+static int intel_qrk_thermal_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	int critical_temp = 0, hot_temp = 0;
+	uint32_t regval = 0;
+
+	if (driver_enable == 0)
+		return 0;
+
+	memset(&qrk_tdev, 0x00, sizeof(qrk_tdev));
+
+	critical_temp = CRIT_TEMP;
+	hot_temp = HOT_TEMP;
+
+	/* Enumerate zone type data */
+	memset(&qrk_tdev, 0x00, sizeof(qrk_tdev));
+	mutex_init(&qrk_tdev.lock);
+
+	/* Set initial state disabled */
+	qrk_tdev.mode = THERMAL_DEVICE_ENABLED;
+
+	intel_qrk_thermal_init_zone(&qrk_tdev.tzone[CATASTROPIC_ZONE],
+				  THERMAL_TRIP_CRITICAL, critical_temp);
+	intel_qrk_thermal_init_zone(&qrk_tdev.tzone[HOT_ZONE],
+				  THERMAL_TRIP_HOT, hot_temp);
+
+	/* Register a thermal zone */
+	qrk_tdev.therm_dev = thermal_zone_device_register(DRIVER_NAME,
+			THRM_ZONE_COUNT, 0, 0, &intel_qrk_thrm_dev_ops,
+			0, IDLE_INTERVAL, ACTIVE_INTERVAL);
+
+	if (IS_ERR(qrk_tdev.therm_dev)) {
+		err = PTR_ERR(qrk_tdev.therm_dev);
+		return err;
+	}
+
+	/* Read the BIOS configured hardware catastrophic trip temp */
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TRPCLR_REG, &regval, 1);
+	regval = (regval & 0xff) - 50;
+
+	pr_info("THRM: critical reset %d c hot %d c hardware failover %d c\n",
+		critical_temp, hot_temp, regval);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_thermal_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_qrk_thermal_remove(struct platform_device *pdev)
+{
+	if (qrk_tdev.therm_dev != NULL) {
+		thermal_zone_device_unregister(qrk_tdev.therm_dev);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_thermal_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_qrk_thermal_probe,
+	.remove = intel_qrk_thermal_remove,
+};
+
+module_platform_driver(intel_qrk_thermal_driver);
+
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Quark Thermal driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index fe922ef..0e3b27d 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -41,7 +41,7 @@ config GEN3_SPI
         default y
         help
           This option enables Intel Media SOC SPI support.
-          For Clanton this option depends on INTEL_QUARK_X1000_SOC.
+          For Quark this option depends on INTEL_QUARK_X1000_SOC.
 
 #
 # MASTER side ... talking to discrete SPI slave chips including microcontrollers
diff --git a/drivers/spi/spi-pxa2xx-pci.c b/drivers/spi/spi-pxa2xx-pci.c
index aa686b5..9fcfb38 100644
--- a/drivers/spi/spi-pxa2xx-pci.c
+++ b/drivers/spi/spi-pxa2xx-pci.c
@@ -8,7 +8,7 @@
 #include <linux/module.h>
 #include <linux/spi/pxa2xx_spi.h>
 #include <linux/irq.h>
-#include <linux/platform_data/clanton.h>
+#include <linux/platform_data/quark.h>
 
 /* defined here to avoid including arch/x86/pci/intel_media_proc_gen3.c */
 #define CE3100_SOC_DEVICE_ID 0x2E50
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index 91da7dd..88f8857 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -34,7 +34,7 @@
 #include <linux/delay.h>
 #include <linux/pm_runtime.h>
 #ifdef CONFIG_INTEL_QUARK_X1000_SOC
-#include <asm/cln.h>
+#include <asm/qrk.h>
 #endif
 
 #include <asm/irq.h>
@@ -95,7 +95,7 @@ DEFINE_SSP_REG(sssr, 0x08)
 DEFINE_SSP_REG(ssitr, 0x0c)
 DEFINE_SSP_REG(ssdr, 0x10)
 #ifdef CONFIG_INTEL_QUARK_X1000_SOC
-DEFINE_SSP_REG(dds_rate, 0x28) /* SSTO unused for clanton */
+DEFINE_SSP_REG(dds_rate, 0x28) /* SSTO unused for quark */
 #endif
 DEFINE_SSP_REG(ssto, 0x28)
 DEFINE_SSP_REG(sspsp, 0x2c)
@@ -1245,8 +1245,8 @@ static unsigned long spi_clk_get_rate(int ssp_type)
 #endif
 
 #ifdef CONFIG_INTEL_QUARK_X1000_SOC
-/*  see Clanton SPI data sheet for implementation rationale */
-u32 cln_set_clk_regvals(u32 rate, u32 *dds, u32 *clk_div)
+/*  see Quark SPI data sheet for implementation rationale */
+u32 qrk_set_clk_regvals(u32 rate, u32 *dds, u32 *clk_div)
 {
 	if (rate <= BITRATE_MAX && rate >= BITRATE_MIN) {
 		if (rate >= BITRATE_50MHZ) {
@@ -1526,7 +1526,7 @@ static void pump_transfers(unsigned long data)
 			bits = transfer->bits_per_word;
 
 #ifdef CONFIG_INTEL_QUARK_X1000_SOC
-		actual_speed = cln_set_clk_regvals
+		actual_speed = qrk_set_clk_regvals
 				(speed, &chip->dds_rate, &clk_div);
 		clk_div = (clk_div << 8);
 #else
@@ -1890,7 +1890,7 @@ static int setup(struct spi_device *spi)
 		}
 	}
 #ifdef CONFIG_INTEL_QUARK_X1000_SOC
-	actual_speed = cln_set_clk_regvals(spi->max_speed_hz,
+	actual_speed = qrk_set_clk_regvals(spi->max_speed_hz,
 						&chip->dds_rate, &clk_div);
 	clk_div = (clk_div << 8);
 #else
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index 58cd75d..951e993 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -27,13 +27,13 @@
 
 #include "8250.h"
 
-/* CLANTON FPGA */
+/* QUARK FPGA */
 #define SERIAL_DEBUG_PCI
 
 /* TODO: Bryan remove ! */
-static unsigned int clanton_enable_msi = 0;
-module_param(clanton_enable_msi, uint, 0644);
-MODULE_PARM_DESC(clanton_enable_msi, "Enable MSI operation on Clanton 8250-PCI");
+static unsigned int quark_enable_msi = 0;
+module_param(quark_enable_msi, uint, 0644);
+MODULE_PARM_DESC(quark_enable_msi, "Enable MSI operation on Quark 8250-PCI");
 
 /*
  * init function returns:
@@ -162,10 +162,10 @@ afavlab_setup(struct serial_private *priv, const struct pciserial_board *board,
 }
 
 /*
- * UART parameters for Intel Clanton setup
+ * UART parameters for Intel Quark setup
  */
 static int
-pci_intel_cln_setup(struct serial_private *priv,
+pci_intel_qrk_setup(struct serial_private *priv,
 		const struct pciserial_board *board,
 		struct uart_port *port, int idx)
 {
@@ -1305,7 +1305,7 @@ static struct pci_serial_quirk pci_serial_quirks[] __refdata = {
 		.device		= 0x0936,
 		.subvendor	= PCI_ANY_ID,
 		.subdevice	= PCI_ANY_ID,
-		.setup		= pci_intel_cln_setup,
+		.setup		= pci_intel_qrk_setup,
 	},
 
 	/*
@@ -1925,7 +1925,7 @@ enum pci_board_num_t {
 	pbn_oxsemi_4_4000000,
 	pbn_oxsemi_8_4000000,
 	pbn_intel_cb,
-	pbn_intel_cln,
+	pbn_intel_qrk,
 	pbn_intel_i960,
 	pbn_sgi_ioc3,
 	pbn_computone_4,
@@ -2494,7 +2494,7 @@ static struct pciserial_board pci_boards[] __devinitdata = {
 		.reg_shift	= 2,
 		.first_offset	= 0x10000,
 	},
-	[pbn_intel_cln] = {
+	[pbn_intel_qrk] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 1,
 		.base_baud	= 2764800,
@@ -2929,9 +2929,9 @@ pciserial_init_one(struct pci_dev *dev, const struct pci_device_id *ent)
 		return rc;
 
 	/* TODO: Bryan remove ! */
-	if(clanton_enable_msi == 1){
+	if(quark_enable_msi == 1){
 		if(pci_enable_msi(dev)!=0){
-			printk(KERN_ERR "CLANTON/DEBUG unable to enable MSIs on serial port!\n");
+			printk(KERN_ERR "QUARK/DEBUG unable to enable MSIs on serial port!\n");
 		}
 	}
 
@@ -3743,11 +3743,11 @@ static struct pci_device_id serial_pci_tbl[] = {
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
 		pbn_b2_bt_2_115200 },
  	/*
-	 * Clanton descriptor
+	 * Quark descriptor
 	 */
 	{	PCI_VENDOR_ID_INTEL, 0x0936,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0,
-		pbn_intel_cln },
+		pbn_intel_qrk },
 
 	/*
 	 * EKF addition for i960 Boards form EKF with serial port
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 0e1ef54b..8af0eae 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1269,7 +1269,7 @@ config SERIAL_QUARK_UART
 	depends on PCI
 	select SERIAL_CORE
 	select DMADEVICES
-	select INTEL_CLN_DMAC
+	select INTEL_QRK_DMAC
 	help
 	  This driver is for Intel(R) Quark X1000 UART with DMA enabled.
 	  If you don't want DMA then you should use the standard 8250_pci
@@ -1280,7 +1280,7 @@ config SERIAL_QUARK_UART_CONSOLE
 	depends on SERIAL_QUARK_UART=y
 	select SERIAL_CORE_CONSOLE
 	help
-	  Say Y here if you wish to use the Clanton UART as the system console
+	  Say Y here if you wish to use the Quark UART as the system console
 	  (the system  console is the device which receives all kernel messages and
 	  warnings and which allows logins in single user mode).
 
diff --git a/drivers/tty/serial/intel_quark_uart.c b/drivers/tty/serial/intel_quark_uart.c
index 1377bdd..5c0a01a 100644
--- a/drivers/tty/serial/intel_quark_uart.c
+++ b/drivers/tty/serial/intel_quark_uart.c
@@ -19,7 +19,7 @@
 #define SUPPORT_SYSRQ
 #endif
 #if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-#include <asm/cln.h>
+#include <asm/qrk.h>
 #endif
 #include <linux/kernel.h>
 #include <linux/serial_reg.h>
@@ -228,7 +228,7 @@ enum {
 #define DEFAULT_UARTCLK			44236800	/* 2.76 MHz * 16 */
 
 /**
- * struct inel_cln_uart_buffer
+ * struct inel_qrk_uart_buffer
  *
  * Descriptor for a UART bufer
  */
@@ -1110,8 +1110,8 @@ static void quark_uart_err_ir(struct x1000_port *priv, unsigned int lsr)
 }
 
 #if defined(CONFIG_INTEL_QUARK_X1000_SOC)
-	#define mask_pvm(x) cln_pci_pvm_mask(x)
-	#define unmask_pvm(x) cln_pci_pvm_unmask(x)
+	#define mask_pvm(x) qrk_pci_pvm_mask(x)
+	#define unmask_pvm(x) qrk_pci_pvm_unmask(x)
 #else
 	#define mask_pvm(x)
 	#define unmask_pvm(x)
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index ecefb9d..7219a60 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -480,7 +480,7 @@ config USB_LANGWELL
 	   gadget drivers to also be dynamically linked.
 
 config USB_EG20T
-	tristate "Intel CLN/EG20T PCH/LAPIS Semiconductor IOH(ML7213/ML7831) UDC"
+	tristate "Intel QRK/EG20T PCH/LAPIS Semiconductor IOH(ML7213/ML7831) UDC"
 	depends on PCI
 	select USB_GADGET_DUALSPEED
 	help
@@ -502,6 +502,8 @@ config USB_EG20T
 	  ML7213/ML7831 is companion chip for Intel Atom E6xx series.
 	  ML7213/ML7831 is completely compatible for Intel EG20T PCH.
 
+	  This driver can be used with Intel's Quark SOC platform
+
 config USB_CI13XXX_MSM
 	tristate "MIPS USB CI13xxx for MSM"
 	depends on ARCH_MSM
diff --git a/drivers/usb/gadget/pch_udc.c b/drivers/usb/gadget/pch_udc.c
index 48798d1..53270f3 100644
--- a/drivers/usb/gadget/pch_udc.c
+++ b/drivers/usb/gadget/pch_udc.c
@@ -6,7 +6,7 @@
  * the Free Software Foundation; version 2 of the License.
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-#include <asm/cln.h>
+#include <asm/qrk.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
@@ -384,10 +384,10 @@ struct pch_udc_dev {
 	struct pch_vbus_gpio_data	vbus_gpio;
 };
 
-#define PCH_UDC_PCI_BAR_CLANTON		0
+#define PCH_UDC_PCI_BAR_QUARK		0
 #define PCH_UDC_PCI_BAR_EG20T		1
 #define PCI_DEVICE_ID_INTEL_EG20T_UDC	0x8808
-#define PCI_DEVICE_ID_INTEL_CLANTON_UDC	0x0939
+#define PCI_DEVICE_ID_INTEL_QUARK_UDC	0x0939
 #define PCI_VENDOR_ID_ROHM		0x10DB
 #define PCI_DEVICE_ID_ML7213_IOH_UDC	0x801D
 #define PCI_DEVICE_ID_ML7831_IOH_UDC	0x8808
@@ -3211,8 +3211,8 @@ static int pch_udc_probe(struct pci_dev *pdev,
 	pci_set_drvdata(pdev, dev);
 
 	/* Determine BAR based on PCI ID */
-	if(id->device == PCI_DEVICE_ID_INTEL_CLANTON_UDC){
-		dev->bar = PCH_UDC_PCI_BAR_CLANTON;
+	if(id->device == PCI_DEVICE_ID_INTEL_QUARK_UDC){
+		dev->bar = PCH_UDC_PCI_BAR_QUARK;
 	}else {
 		dev->bar = PCH_UDC_PCI_BAR_EG20T;
 	}
@@ -3300,7 +3300,7 @@ finished:
 
 static DEFINE_PCI_DEVICE_TABLE(pch_udc_pcidev_id) = {
 	{
-		PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CLANTON_UDC),
+		PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_QUARK_UDC),
 		.class = (PCI_CLASS_SERIAL_USB << 8) | 0xfe,
 		.class_mask = 0xffffffff,
 	},
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 85e5317..1da4c48 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -42,8 +42,8 @@ static int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)
 		ehci_dbg(ehci, "MWI active\n");
 
 	/* Reset the threshold limit */
-	if(unlikely(usb_is_intel_cln(pdev)))
-		usb_set_cln_bulk_thresh(pdev);
+	if(unlikely(usb_is_intel_qrk(pdev)))
+		usb_set_qrk_bulk_thresh(pdev);
 
 	return 0;
 }
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 6204dcd..8e31509 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -733,17 +733,17 @@ static int handshake(void __iomem *ptr, u32 mask, u32 done,
 }
 
 #define PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC		0x0939
-bool usb_is_intel_cln(struct pci_dev *pdev)
+bool usb_is_intel_qrk(struct pci_dev *pdev)
 {
 	return pdev->vendor == PCI_VENDOR_ID_INTEL &&
 		pdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;
 
 }
-EXPORT_SYMBOL_GPL(usb_is_intel_cln);
+EXPORT_SYMBOL_GPL(usb_is_intel_qrk);
 
 #define EHCI_INSNREG01		0x84
 #define EHCI_INSNREG01_THRESH	0x007F007F	/* Threshold value */
-void usb_set_cln_bulk_thresh(struct pci_dev *pdev)
+void usb_set_qrk_bulk_thresh(struct pci_dev *pdev)
 {
 	void __iomem *base, *op_reg_base;
 	u8 cap_length;
@@ -772,7 +772,7 @@ void usb_set_cln_bulk_thresh(struct pci_dev *pdev)
 	iounmap(base);
 
 }
-EXPORT_SYMBOL_GPL(usb_set_cln_bulk_thresh);
+EXPORT_SYMBOL_GPL(usb_set_qrk_bulk_thresh);
 
 #define PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI	0x8C31
 #define PCI_DEVICE_ID_INTEL_LYNX_POINT_LP_XHCI	0x9C31
diff --git a/drivers/usb/host/pci-quirks.h b/drivers/usb/host/pci-quirks.h
index 3bca8f7..80ffdee 100644
--- a/drivers/usb/host/pci-quirks.h
+++ b/drivers/usb/host/pci-quirks.h
@@ -9,8 +9,8 @@ void usb_amd_dev_put(void);
 void usb_amd_quirk_pll_disable(void);
 void usb_amd_quirk_pll_enable(void);
 bool usb_is_intel_switchable_xhci(struct pci_dev *pdev);
-bool usb_is_intel_cln(struct pci_dev *pdev);
-void usb_set_cln_bulk_thresh(struct pci_dev *pdev);
+bool usb_is_intel_qrk(struct pci_dev *pdev);
+void usb_set_qrk_bulk_thresh(struct pci_dev *pdev);
 void usb_enable_xhci_ports(struct pci_dev *xhci_pdev);
 void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
 #else
diff --git a/include/linux/iio/st_sensors.h b/include/linux/iio/st_sensors.h
new file mode 100644
index 0000000..56d0495
--- /dev/null
+++ b/include/linux/iio/st_sensors.h
@@ -0,0 +1,289 @@
+/*
+ * STMicroelectronics sensors library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_H
+#define ST_SENSORS_H
+
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/irqreturn.h>
+#include <linux/iio/trigger.h>
+
+#define ST_SENSORS_TX_MAX_LENGTH		2
+#define ST_SENSORS_RX_MAX_LENGTH		6
+
+#define ST_SENSORS_ODR_LIST_MAX			10
+#define ST_SENSORS_FULLSCALE_AVL_MAX		10
+
+#define ST_SENSORS_NUMBER_ALL_CHANNELS		4
+#define ST_SENSORS_NUMBER_DATA_CHANNELS		3
+#define ST_SENSORS_ENABLE_ALL_AXIS		0x07
+#define ST_SENSORS_BYTE_FOR_CHANNEL		2
+#define ST_SENSORS_SCAN_X			0
+#define ST_SENSORS_SCAN_Y			1
+#define ST_SENSORS_SCAN_Z			2
+#define ST_SENSORS_DEFAULT_12_REALBITS		12
+#define ST_SENSORS_DEFAULT_16_REALBITS		16
+#define ST_SENSORS_DEFAULT_POWER_ON_VALUE	0x01
+#define ST_SENSORS_DEFAULT_POWER_OFF_VALUE	0x00
+#define ST_SENSORS_DEFAULT_WAI_ADDRESS		0x0f
+#define ST_SENSORS_DEFAULT_AXIS_ADDR		0x20
+#define ST_SENSORS_DEFAULT_AXIS_MASK		0x07
+#define ST_SENSORS_DEFAULT_AXIS_N_BIT		3
+
+#define ST_SENSORS_MAX_NAME			17
+#define ST_SENSORS_MAX_4WAI			7
+
+#define ST_SENSORS_LSM_CHANNELS(device_type, index, mod, endian, bits, addr) \
+{ \
+	.type = device_type, \
+	.modified = 1, \
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT | \
+			IIO_CHAN_INFO_SCALE_SEPARATE_BIT, \
+	.scan_index = index, \
+	.channel2 = mod, \
+	.address = addr, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = bits, \
+		.shift = 16 - bits, \
+		.storagebits = 16, \
+		.endianness = endian, \
+	}, \
+}
+
+#define ST_SENSOR_DEV_ATTR_SAMP_FREQ() \
+		IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO, \
+			st_sensors_sysfs_get_sampling_frequency, \
+			st_sensors_sysfs_set_sampling_frequency)
+
+#define ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL() \
+		IIO_DEV_ATTR_SAMP_FREQ_AVAIL( \
+			st_sensors_sysfs_sampling_frequency_avail)
+
+#define ST_SENSORS_DEV_ATTR_SCALE_AVAIL(name) \
+		IIO_DEVICE_ATTR(name, S_IRUGO, \
+			st_sensors_sysfs_scale_avail, NULL , 0);
+
+struct st_sensor_odr_avl {
+	unsigned int hz;
+	u8 value;
+};
+
+struct st_sensor_odr {
+	u8 addr;
+	u8 mask;
+	struct st_sensor_odr_avl odr_avl[ST_SENSORS_ODR_LIST_MAX];
+};
+
+struct st_sensor_power {
+	u8 addr;
+	u8 mask;
+	u8 value_off;
+	u8 value_on;
+};
+
+struct st_sensor_axis {
+	u8 addr;
+	u8 mask;
+};
+
+struct st_sensor_fullscale_avl {
+	unsigned int num;
+	u8 value;
+	unsigned int gain;
+	unsigned int gain2;
+};
+
+struct st_sensor_fullscale {
+	u8 addr;
+	u8 mask;
+	struct st_sensor_fullscale_avl fs_avl[ST_SENSORS_FULLSCALE_AVL_MAX];
+};
+
+/**
+ * struct st_sensor_bdu - ST sensor device block data update
+ * @addr: address of the register.
+ * @mask: mask to write the block data update flag.
+ */
+struct st_sensor_bdu {
+	u8 addr;
+	u8 mask;
+};
+
+/**
+ * struct st_sensor_data_ready_irq - ST sensor device data-ready interrupt
+ * @addr: address of the register.
+ * @mask: mask to write the on/off value.
+ * struct ig1 - represents the Interrupt Generator 1 of sensors.
+ * @en_addr: address of the enable ig1 register.
+ * @en_mask: mask to write the on/off value for enable.
+ */
+struct st_sensor_data_ready_irq {
+	u8 addr;
+	u8 mask;
+	struct {
+		u8 en_addr;
+		u8 en_mask;
+	} ig1;
+};
+
+/**
+ * struct st_sensor_transfer_buffer - ST sensor device I/O buffer
+ * @buf_lock: Mutex to protect rx and tx buffers.
+ * @tx_buf: Buffer used by SPI transfer function to send data to the sensors.
+ *	This buffer is used to avoid DMA not-aligned issue.
+ * @rx_buf: Buffer used by SPI transfer to receive data from sensors.
+ *	This buffer is used to avoid DMA not-aligned issue.
+ */
+struct st_sensor_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[ST_SENSORS_RX_MAX_LENGTH];
+	u8 tx_buf[ST_SENSORS_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/**
+ * struct st_sensor_transfer_function - ST sensor device I/O function
+ * @read_byte: Function used to read one byte.
+ * @write_byte: Function used to write one byte.
+ * @read_multiple_byte: Function used to read multiple byte.
+ */
+struct st_sensor_transfer_function {
+	int (*read_byte) (struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 *res_byte);
+	int (*write_byte) (struct st_sensor_transfer_buffer *tb,
+				struct device *dev, u8 reg_addr, u8 data);
+	int (*read_multiple_byte) (struct st_sensor_transfer_buffer *tb,
+		struct device *dev, u8 reg_addr, int len, u8 *data,
+							bool multiread_bit);
+};
+
+/**
+ * struct st_sensors - ST sensors list
+ * @wai: Contents of WhoAmI register.
+ * @sensors_supported: List of supported sensors by struct itself.
+ * @ch: IIO channels for the sensor.
+ * @odr: Output data rate register and ODR list available.
+ * @pw: Power register of the sensor.
+ * @enable_axis: Enable one or more axis of the sensor.
+ * @fs: Full scale register and full scale list available.
+ * @bdu: Block data update register.
+ * @drdy_irq: Data ready register of the sensor.
+ * @multi_read_bit: Use or not particular bit for [I2C/SPI] multi-read.
+ * @bootime: samples to discard when sensor passing from power-down to power-up.
+ */
+struct st_sensors {
+	u8 wai;
+	char sensors_supported[ST_SENSORS_MAX_4WAI][ST_SENSORS_MAX_NAME];
+	struct iio_chan_spec *ch;
+	struct st_sensor_odr odr;
+	struct st_sensor_power pw;
+	struct st_sensor_axis enable_axis;
+	struct st_sensor_fullscale fs;
+	struct st_sensor_bdu bdu;
+	struct st_sensor_data_ready_irq drdy_irq;
+	bool multi_read_bit;
+	unsigned int bootime;
+};
+
+/**
+ * struct st_sensor_data - ST sensor device status
+ * @dev: Pointer to instance of struct device (I2C or SPI).
+ * @trig: The trigger in use by the core driver.
+ * @sensor: Pointer to the current sensor struct in use.
+ * @current_fullscale: Maximum range of measure by the sensor.
+ * @enabled: Status of the sensor (false->off, true->on).
+ * @multiread_bit: Use or not particular bit for [I2C/SPI] multiread.
+ * @buffer_data: Data used by buffer part.
+ * @odr: Output data rate of the sensor [Hz].
+ * @get_irq_data_ready: Function to get the IRQ used for data ready signal.
+ * @tf: Transfer function structure used by I/O operations.
+ * @tb: Transfer buffers and mutex used by I/O operations.
+ */
+struct st_sensor_data {
+	struct device *dev;
+	struct iio_trigger *trig;
+	struct st_sensors *sensor;
+	struct st_sensor_fullscale_avl *current_fullscale;
+
+	bool enabled;
+	bool multiread_bit;
+
+	char *buffer_data;
+
+	unsigned int odr;
+
+	unsigned int (*get_irq_data_ready) (struct iio_dev *indio_dev);
+
+	const struct st_sensor_transfer_function *tf;
+	struct st_sensor_transfer_buffer tb;
+};
+
+#ifdef CONFIG_IIO_BUFFER
+irqreturn_t st_sensors_trigger_handler(int irq, void *p);
+
+int st_sensors_get_buffer_element(struct iio_dev *indio_dev, u8 *buf);
+#endif
+
+#ifdef CONFIG_IIO_TRIGGER
+int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
+				const struct iio_trigger_ops *trigger_ops);
+
+void st_sensors_deallocate_trigger(struct iio_dev *indio_dev);
+
+#else
+static inline int st_sensors_allocate_trigger(struct iio_dev *indio_dev,
+				const struct iio_trigger_ops *trigger_ops)
+{
+	return 0;
+}
+static inline void st_sensors_deallocate_trigger(struct iio_dev *indio_dev)
+{
+	return;
+}
+#endif
+
+int st_sensors_init_sensor(struct iio_dev *indio_dev);
+
+int st_sensors_write_data_with_mask(struct iio_dev *indio_dev,
+				u8 reg_addr, u8 mask, u8 data);
+
+int st_sensors_set_enable(struct iio_dev *indio_dev, bool enable);
+
+int st_sensors_set_axis_enable(struct iio_dev *indio_dev, u8 axis_enable);
+
+int st_sensors_set_odr(struct iio_dev *indio_dev, unsigned int odr);
+
+int st_sensors_set_dataready_irq(struct iio_dev *indio_dev, bool enable);
+
+int st_sensors_set_fullscale_by_gain(struct iio_dev *indio_dev, int scale);
+
+int st_sensors_read_axis_data(struct iio_dev *indio_dev,
+							u8 ch_addr, int *data);
+
+int st_sensors_read_info_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch, int *val);
+
+int st_sensors_check_device_support(struct iio_dev *indio_dev,
+			int num_sensors_list, const struct st_sensors *sensors);
+
+ssize_t st_sensors_sysfs_get_sampling_frequency(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t st_sensors_sysfs_set_sampling_frequency(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+
+ssize_t st_sensors_sysfs_sampling_frequency_avail(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+ssize_t st_sensors_sysfs_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf);
+
+#endif /* ST_SENSORS_H */
diff --git a/include/linux/iio/st_sensors_i2c.h b/include/linux/iio/st_sensors_i2c.h
new file mode 100644
index 0000000..67d8453
--- /dev/null
+++ b/include/linux/iio/st_sensors_i2c.h
@@ -0,0 +1,20 @@
+/*
+ * STMicroelectronics sensors i2c library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_I2C_H
+#define ST_SENSORS_I2C_H
+
+#include <linux/i2c.h>
+#include <linux/iio/common/st_sensors.h>
+
+void st_sensors_i2c_configure(struct iio_dev *indio_dev,
+		struct i2c_client *client, struct st_sensor_data *sdata);
+
+#endif /* ST_SENSORS_I2C_H */
diff --git a/include/linux/iio/st_sensors_spi.h b/include/linux/iio/st_sensors_spi.h
new file mode 100644
index 0000000..d964a35
--- /dev/null
+++ b/include/linux/iio/st_sensors_spi.h
@@ -0,0 +1,20 @@
+/*
+ * STMicroelectronics sensors spi library driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef ST_SENSORS_SPI_H
+#define ST_SENSORS_SPI_H
+
+#include <linux/spi/spi.h>
+#include <linux/iio/common/st_sensors.h>
+
+void st_sensors_spi_configure(struct iio_dev *indio_dev,
+			struct spi_device *spi, struct st_sensor_data *sdata);
+
+#endif /* ST_SENSORS_SPI_H */
diff --git a/include/linux/intel_cln_sb.h b/include/linux/intel_cln_sb.h
deleted file mode 100644
index 6092fc0..0000000
--- a/include/linux/intel_cln_sb.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton side-band driver
- *
- * Thread-safe sideband read/write routine.
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
- */
-
-#ifndef __INTEL_CLN_SB_H__
-#define __INTEL_CLN_SB_H__
-
-#include <linux/types.h>
-
-typedef enum {
-	SB_ID_HUNIT = 0x03,
-	SB_ID_THERMAL = 0x04,
-	SB_ID_ESRAM = 0x05,
-	SB_ID_SOC = 0x31,
-}cln_sb_id;
-
-/**
- * intel_cln_sb_read_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe read of side-band
- * command - can be different read op-code types - which is why we don't
- * hard-code this value directly into msg
- */
-void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock);
-
-/**
- * intel_cln_sb_write_reg
- *
- * @param cln_sb_id: Sideband identifier
- * @param command: Command to send to destination identifier
- * @param reg: Target register w/r to cln_sb_id
- * @return nothing
- *
- * Utility function to allow thread-safe write of side-band
- */
-void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock);
-
-/**
- * intel_cln_sb_runfn_lock
- *
- * @param fn: Callback function - which requires side-band spinlock and !irq
- * @param arg: Callback argument
- * @return 0 on success < 0 on failure
- *
- * Runs the given function pointer inside of a call to the local spinlock using
- * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
- * guarantee atomicity, but, available to any other user of sideband provided
- * rules are respected.
- * Rules:
- *	fn may not sleep
- *	fn may not change the state of irqs	
- */
-int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg);
-
-/**
- * intel_cln_sb_initialized
- *
- * False if sideband running on non-Clanton system
- */
-int intel_cln_sb_initialized(void);
-
-#endif /* __INTEL_CLN_SB_H__ */
diff --git a/include/linux/intel_mid_dma.h b/include/linux/intel_mid_dma.h
index 825dde1..4e385ea 100644
--- a/include/linux/intel_mid_dma.h
+++ b/include/linux/intel_mid_dma.h
@@ -226,7 +226,7 @@ void mid_dma_shutdown(struct pci_dev *pdev, struct middma_device *device);
  * Initialize the PCI device, map BARs, query driver data.
  * Call intel_setup_dma to complete contoller and chan initilzation
  */
-int intel_cln_dma_probe(struct pci_dev *pdev,
+int intel_qrk_dma_probe(struct pci_dev *pdev,
 			struct middma_device *device);
 /**
  * intel_mid_dma_remove -	PCI remove
@@ -235,7 +235,7 @@ int intel_cln_dma_probe(struct pci_dev *pdev,
  * Free up all resources and data
  * Call shutdown_dma to complete contoller and chan cleanup
  */
-void intel_cln_dma_remove(struct pci_dev *pdev, struct middma_device *device);
+void intel_qrk_dma_remove(struct pci_dev *pdev, struct middma_device *device);
 
 /* Power Management */
 /*
@@ -246,16 +246,17 @@ void intel_cln_dma_remove(struct pci_dev *pdev, struct middma_device *device);
 *
 * This function is called by OS when a power event occurs
 */
-int intel_cln_dma_suspend(struct middma_device *device);
+int intel_qrk_dma_suspend(struct middma_device *device);
 
 /**
-* intel_cln_dma_resume - PCI resume function
+* intel_qrk_dma_resume - PCI resume function
+
 *
 * @pci:	PCI device structure
 *
 * This function is called by OS when a power event occurs
 */
-int intel_cln_dma_resume(struct middma_device *device);
+int intel_qrk_dma_resume(struct middma_device *device);
 
 
 #endif /*__INTEL_MID_DMA_H__*/
diff --git a/include/linux/intel_qrk_sb.h b/include/linux/intel_qrk_sb.h
new file mode 100644
index 0000000..65d9b5e
--- /dev/null
+++ b/include/linux/intel_qrk_sb.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark side-band driver
+ *
+ * Thread-safe sideband read/write routine.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
+ */
+
+#ifndef __INTEL_QRK_SB_H__
+#define __INTEL_QRK_SB_H__
+
+#include <linux/types.h>
+
+#define PCI_DEVICE_ID_X1000_HOST_BRIDGE			0x0958
+
+typedef enum {
+	SB_ID_HUNIT = 0x03,
+	SB_ID_THERMAL = 0x04,
+	SB_ID_ESRAM = 0x05,
+	SB_ID_SOC = 0x31,
+}qrk_sb_id;
+
+/**
+ * intel_qrk_sb_read_reg
+ *
+ * @param qrk_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to qrk_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+void intel_qrk_sb_read_reg(qrk_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock);
+
+/**
+ * intel_qrk_sb_write_reg
+ *
+ * @param qrk_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to qrk_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+void intel_qrk_sb_write_reg(qrk_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock);
+
+/**
+ * intel_qrk_sb_runfn_lock
+ *
+ * @param fn: Callback function - which requires side-band spinlock and !irq
+ * @param arg: Callback argument
+ * @return 0 on success < 0 on failure
+ *
+ * Runs the given function pointer inside of a call to the local spinlock using
+ * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
+ * guarantee atomicity, but, available to any other user of sideband provided
+ * rules are respected.
+ * Rules:
+ *	fn may not sleep
+ *	fn may not change the state of irqs	
+ */
+int intel_qrk_sb_runfn_lock(int (*fn)( void * arg ), void * arg);
+
+/**
+ * intel_qrk_sb_initialized
+ *
+ * False if sideband running on non-Quark system
+ */
+int intel_qrk_sb_initialized(void);
+
+#endif /* __INTEL_QRK_SB_H__ */
diff --git a/include/linux/mfd/cy8c9540a.h b/include/linux/mfd/cy8c9540a.h
index 0fe1d70..a32c6f0 100644
--- a/include/linux/mfd/cy8c9540a.h
+++ b/include/linux/mfd/cy8c9540a.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ * Copyright(c) 2013 Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
diff --git a/include/linux/mfd/intel_cln_gip_pdata.h b/include/linux/mfd/intel_cln_gip_pdata.h
deleted file mode 100644
index 183f881..0000000
--- a/include/linux/mfd/intel_cln_gip_pdata.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-
-#ifndef LINUX_INTEL_CLN_GIP_DATA_H
-#define LINUX_INTEL_CLN_GIP_DATA_H
-
-struct pci_dev;
-
-struct intel_cln_gip_pdata {
-	int		i2c_std_mode;
-};
-
-extern struct intel_cln_gip_pdata *(*intel_cln_gip_get_pdata)(void);
-
-#endif
diff --git a/include/linux/mfd/intel_qrk_gip_pdata.h b/include/linux/mfd/intel_qrk_gip_pdata.h
new file mode 100644
index 0000000..1378f5c
--- /dev/null
+++ b/include/linux/mfd/intel_qrk_gip_pdata.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+#ifndef LINUX_INTEL_QRK_GIP_DATA_H
+#define LINUX_INTEL_QRK_GIP_DATA_H
+
+struct pci_dev;
+
+struct intel_qrk_gip_pdata {
+	int		i2c_std_mode;
+};
+
+extern struct intel_qrk_gip_pdata *(*intel_qrk_gip_get_pdata)(void);
+
+#endif
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 1d6d464..3c04429 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2504,7 +2504,7 @@
 #define PCI_DEVICE_ID_INTEL_MFD_EMMC0	0x0823
 #define PCI_DEVICE_ID_INTEL_MFD_EMMC1	0x0824
 #define PCI_DEVICE_ID_INTEL_MRST_SD2	0x084F
-#define PCI_DEVICE_ID_INTEL_CLANTON_ILB	0x095E
+#define PCI_DEVICE_ID_INTEL_QUARK_ILB	0x095E
 #define PCI_DEVICE_ID_INTEL_I960	0x0960
 #define PCI_DEVICE_ID_INTEL_I960RM	0x0962
 #define PCI_DEVICE_ID_INTEL_8257X_SOL	0x1062
@@ -2526,7 +2526,7 @@
 #define PCI_DEVICE_ID_INTEL_82840_HB	0x1a21
 #define PCI_DEVICE_ID_INTEL_82845_HB	0x1a30
 #define PCI_DEVICE_ID_INTEL_IOAT	0x1a38
-#define PCI_DEVICE_ID_INTEL_CLN_SD	0x08A7
+#define PCI_DEVICE_ID_INTEL_QRK_SD	0x08A7
 #define PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MIN	0x1c41
 #define PCI_DEVICE_ID_INTEL_COUGARPOINT_LPC_MAX	0x1c5f
 #define PCI_DEVICE_ID_INTEL_PATSBURG_LPC_0	0x1d40
diff --git a/include/linux/platform_data/clanton.h b/include/linux/platform_data/clanton.h
deleted file mode 100644
index 7f2622e..0000000
--- a/include/linux/platform_data/clanton.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- */
-/*
- * Intel Clanton platform data definition
- */
-
-#ifndef _PDATA_CLANTON_H
-#define _PDATA_CLANTON_H
-
-typedef enum  {
-	CLANTON_PLAT_UNDEFINED = 0,
-	CLANTON_EMULATION = 1,
-	CLANTON_PEAK = 2,
-	KIPS_BAY = 3,
-	CROSS_HILL = 4,
-	CLANTON_HILL = 5,
-	GALILEO = 6,
-}cln_plat_id_t;
-
-typedef enum {
-	PLAT_DATA_ID = 1,
-	PLAT_DATA_SN = 2,
-	PLAT_DATA_MAC0 = 3,
-	PLAT_DATA_MAC1 = 4,
-}plat_dataid_t;
-
-#endif /* _PDATA_CLANTON_H */
diff --git a/include/linux/platform_data/lis331dlh_intel_cln.h b/include/linux/platform_data/lis331dlh_intel_cln.h
deleted file mode 100644
index 00e3006..0000000
--- a/include/linux/platform_data/lis331dlh_intel_cln.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Platform data for Intel Clanton Hill platform accelerometer driver
- *
- * Copyright(c) 2013 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Contact Information:
- * Intel Corporation
- *
- */
-
-#ifndef __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H__
-#define __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H__
-
-/**
- * struct lis331dlh_intel_cln_platform_data - Platform data for the ST Micro
- *                                            accelerometer driver
- * @irq1_pin: GPIO pin number for the threshold interrupt(INT1).
- **/
-struct lis331dlh_intel_cln_platform_data {
-	int irq1_pin;
-};
-
-#endif /* LINUX_PLATFORM_DATA_LIS331DLH_INTEL_CLN_H_ */
diff --git a/include/linux/platform_data/lis331dlh_intel_qrk.h b/include/linux/platform_data/lis331dlh_intel_qrk.h
new file mode 100644
index 0000000..703c927
--- /dev/null
+++ b/include/linux/platform_data/lis331dlh_intel_qrk.h
@@ -0,0 +1,36 @@
+/*
+ * Platform data for Intel Clanton Hill platform accelerometer driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ *
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_QRK_H__
+#define __LINUX_PLATFORM_DATA_LIS331DLH_INTEL_QRK_H__
+
+/**
+ * struct lis331dlh_intel_qrk_platform_data - Platform data for the ST Micro
+ *                                            accelerometer driver
+ * @irq1_pin: GPIO pin number for the threshold interrupt(INT1).
+ **/
+struct lis331dlh_intel_qrk_platform_data {
+	int irq1_pin;
+};
+
+#endif /* LINUX_PLATFORM_DATA_LIS331DLH_INTEL_QRK_H_ */
diff --git a/include/linux/platform_data/max78m6610_lmu.h b/include/linux/platform_data/max78m6610_lmu.h
new file mode 100644
index 0000000..d05d513
--- /dev/null
+++ b/include/linux/platform_data/max78m6610_lmu.h
@@ -0,0 +1,34 @@
+/*
+ * Platform data for max78m6610+lmu SPI protocol driver
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_MAX78M6610_LMU_H__
+#define __LINUX_PLATFORM_DATA_MAX78M6610_LMU_H__
+
+/**
+ * struct max78m6610_lmu_platform_data - Platform data for the max78m6610_lmu
+ *                                       ADC driver
+ * @reset_gpio: GPIO pin number reserved for MAX78M6610+LMU device reset
+ **/
+struct max78m6610_lmu_platform_data {
+	int reset_gpio;
+};
+
+#endif /* IIO_ADC_MAX78M6610_LMU_H_ */
diff --git a/include/linux/platform_data/quark.h b/include/linux/platform_data/quark.h
new file mode 100644
index 0000000..85f5508
--- /dev/null
+++ b/include/linux/platform_data/quark.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Quark platform data definition
+ */
+
+#ifndef _PDATA_QUARK_H
+#define _PDATA_QUARK_H
+
+typedef enum  {
+	QUARK_PLAT_UNDEFINED = 0,
+	QUARK_EMULATION = 1,
+	QUARK_PEAK = 2,
+	KIPS_BAY = 3,
+	CROSS_HILL = 4,
+	QUARK_HILL = 5,
+	GALILEO = 6,
+}qrk_plat_id_t;
+
+typedef enum {
+	PLAT_DATA_ID = 1,
+	PLAT_DATA_SN = 2,
+	PLAT_DATA_MAC0 = 3,
+	PLAT_DATA_MAC1 = 4,
+}plat_dataid_t;
+
+#endif /* _PDATA_QUARK_H */
-- 
1.7.5.4

