From cf38b96f2b1dc06c8a92652591fd943073cba018 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Mon, 6 Jul 2015 14:39:00 +0800
Subject: [PATCH 63/65] platform: Add SLB9645TT TPM device for CrossHill

This patch adds the SLB9645TT Infineon TPM device on
CrossHill platform file.

The code changes are based on SLB9645TT TPM device on
Reliance Creek platform file. However, both the RESET
and INTERRUPT GPIO pins have to be changed after checking
the schematics of Cross Hill.

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
Change-Id: I23687a95a72239603a6ddcbc05ccd5d78ae3b012
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/5610
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 .../intel-quark/intel_quark_platform_cross_hill.c  |  171 +++++++++++---------
 1 files changed, 94 insertions(+), 77 deletions(-)

diff --git a/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c b/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
index c07ac34..62952f0 100644
--- a/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
+++ b/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
@@ -29,6 +29,11 @@
 #define SPI_BPEAK_ID2_GPIO   15
 #define SPI_BPEAK_ID3_GPIO   14
 
+/* GPIO line used to reset SLB9645TT */
+#define GPIO_SLB9645TT_RESET	7
+/* GPIO line SLB9645TT interrupt are routed to */
+#define GPIO_SLB9645TT_INT	0
+
 /*
  * GPIO number for eADC interrupt (MAX78M6610+LMU)
  */
@@ -64,38 +69,6 @@ enum {
 	QRK_SPI_BPEAK_ID_NONE
 };
 
-/* GPIO line used to reset SLB9645TT */
-#define GPIO_SLB9645TT_RESET		7
-/* GPIO line SLB9645TT interrupt are routed to */
-#define GPIO_SLB9645TT_INT		0
-
-#define SLB9645TT_ADDR			0x20
-
-struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
-	.gpio_reset = GPIO_SLB9645TT_RESET,
-	.gpio_irq = GPIO_SLB9645TT_INT,
-};
-
-static struct i2c_board_info probed_slb9645tt = {
-	.platform_data = &slb9645tt_platform_data,
-};
-
-static const unsigned short slb9645tt_i2c_addr[] =
-	{ SLB9645TT_ADDR, I2C_CLIENT_END };
-
-static struct gpio reserved_gpios[] = {
-	{
-		GPIO_SLB9645TT_RESET,
-		GPIOF_OUT_INIT_HIGH,
-		"slb96455tt-reset",
-	},
-	{
-		GPIO_SLB9645TT_INT,
-		GPIOF_IN,
-		"slb96455tt-int",
-	},
-};
-
 /******************************************************************************
  *             Analog Devices AD7298 SPI Device Platform Data
  ******************************************************************************/
@@ -173,51 +146,6 @@ static struct spi_board_info spi_energy_adc_devs[] = {
 	},
 };
 
-static int slb9645tt_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
-{
-	return gpio_get_value(GPIO_SLB9645TT_RESET);
-}
-
-static int intel_qrk_slb9645tt_probe(void)
-{
-	struct i2c_adapter *i2c_adap;
-	struct i2c_client *slb9645tt;
-	int ret;
-
-	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
-	if (ret) {
-		pr_err("%s: unable to reserve the GPIOs for slb9645tt, Deferring..\n",
-			__func__);
-		return -EPROBE_DEFER;
-	}
-
-	probed_slb9645tt.irq = gpio_to_irq(GPIO_SLB9645TT_INT);
-
-	i2c_adap = i2c_get_adapter(0);
-	if (!i2c_adap) {
-		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
-			__func__);
-		ret = -EPROBE_DEFER;
-		goto err;
-	}
-
-	strlcpy(probed_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
-	slb9645tt = i2c_new_probed_device(i2c_adap, &probed_slb9645tt,
-					  slb9645tt_i2c_addr, slb9645tt_i2c_probe);
-	i2c_put_adapter(i2c_adap);
-
-	if (!slb9645tt) {
-		pr_err("%s: can't probe slb9645tt\n", __func__);
-		ret = -ENODEV;
-		goto err;
-        }
-
-	return 0;
-err:
-	gpio_free_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
-	return ret;
-}
-
 /**
  * intel_qrk_spi_add_onboard_devs
  *
@@ -243,6 +171,36 @@ static int intel_qrk_spi_add_onboard_devs(void)
 			ARRAY_SIZE(spi_onboard_devs));
 }
 
+/******************************************************************************
+ *             Trust Platform Module
+ ******************************************************************************/
+#define SLB9645TT_ADDR		0x20
+
+struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
+	.gpio_reset = GPIO_SLB9645TT_RESET,
+	.gpio_irq = GPIO_SLB9645TT_INT,
+};
+
+static struct i2c_board_info probed_slb9645tt = {
+	.platform_data = &slb9645tt_platform_data,
+};
+
+static const unsigned short slb9645tt_i2c_addr[] = {
+	SLB9645TT_ADDR, I2C_CLIENT_END
+};
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_SLB9645TT_RESET,
+		GPIOF_OUT_INIT_HIGH,
+		"slb96455tt-reset",
+	},
+	{
+		GPIO_SLB9645TT_INT,
+		GPIOF_IN,
+		"slb96455tt-int",
+	},
+};
 
 /**
  * intel_qrk_spi_get_bpeak_id
@@ -405,6 +363,57 @@ static int intel_qrk_spi_devs_addon(void)
 	return ret;
 }
 
+static int slb9645tt_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return gpio_get_value(GPIO_SLB9645TT_RESET);
+}
+
+/*
+ * intel_qrk_tpm_dev_probe
+ *
+ * add and register TPM I2C device on the platform
+ */
+static int intel_qrk_tpm_dev_probe(void)
+{
+	struct i2c_adapter *i2c_adap;
+	struct i2c_client *slb9645tt;
+	int ret = 0;
+
+	/* Reserve GPIOs for I2C device interrupts */
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		pr_err("%s: failed to request reserved gpios\n", __func__);
+		return ret;
+	}
+
+	/* Register onboard TPM device */
+	probed_slb9645tt.irq = gpio_to_irq(GPIO_SLB9645TT_INT);
+
+	i2c_adap = i2c_get_adapter(0);
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapted not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto err;
+	}
+	strlcpy(probed_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
+	slb9645tt = i2c_new_probed_device(i2c_adap, &probed_slb9645tt,
+					  slb9645tt_i2c_addr,
+					  slb9645tt_i2c_probe);
+	i2c_put_adapter(i2c_adap);
+
+	if (!slb9645tt) {
+		pr_err("%s: can't probe slb9645tt\n", __func__);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	return 0;
+err:
+	gpio_free_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	return ret;
+}
+
 /**
  * intel_qrk_gpio_restrict_probe_nc
  *
@@ -420,6 +429,10 @@ static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
 		ret = intel_qrk_spi_devs_addon();
 		if (ret)
 			return ret;
+
+		ret = intel_qrk_tpm_dev_probe();
+		if (ret)
+			return ret;
 	}
 	return 0;
 }
@@ -439,6 +452,10 @@ static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
 		ret = intel_qrk_spi_devs_addon();
 		if (ret)
 			return ret;
+
+		ret = intel_qrk_tpm_dev_probe();
+		if (ret)
+			return ret;
 	}
 	return 0;
 }
-- 
1.7.5.4

