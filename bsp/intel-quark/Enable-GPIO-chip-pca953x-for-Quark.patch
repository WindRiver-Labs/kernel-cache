From c925cfca29605dc14a76adec7a95fbfcb25a548a Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Mon, 5 Jan 2015 11:17:59 +0800
Subject: [PATCH 13/31] Enable GPIO chip pca953x for Quark.

source: Intel vendor drop 1.1.0-rc2

This patchset adds the PCAL953X model support and enhances GPIO drive types
including pull-up, pull-down, strong and high-z.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/gpio/Kconfig        |    4 +-
 drivers/gpio/gpio-pca953x.c |  320 ++++++++++++++++++++++++++++++++++++++++---
 drivers/gpio/gpiolib.c      |  130 +++++++++++++++++
 include/asm-generic/gpio.h  |    4 +
 include/linux/gpio.h        |   10 ++
 5 files changed, 447 insertions(+), 21 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 0f5a9cf..4d07a90 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -272,6 +272,8 @@ config GPIO_SCH
 	  The Intel Centerton processor has a total of 30 GPIO pins.
 	  Twenty-one are powered by the core power rail and 9 from the
 	  suspend power supply.
+	  The Intel Quark has 2 GPIOs powered by the core power well and 6
+	  form the suspend power well.
 
 config GPIO_ICH
 	tristate "Intel ICH GPIO"
@@ -391,7 +393,7 @@ config GPIO_PCA953X
 
 config GPIO_PCA953X_IRQ
 	bool "Interrupt controller support for PCA953x"
-	depends on GPIO_PCA953X=y
+	depends on GPIO_PCA953X
 	help
 	  Say yes here to enable the pca953x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index 426c51d..8274957 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -29,6 +29,12 @@
 #define PCA953X_INVERT		2
 #define PCA953X_DIRECTION	3
 
+#define PCAL953X_IN_LATCH	34
+#define PCAL953X_PUPD_EN	35
+#define PCAL953X_PUPD_SEL	36
+#define PCAL953X_INT_MASK	37
+#define PCAL953X_INT_STAT	38
+
 #define REG_ADDR_AI		0x80
 
 #define PCA957X_IN		0
@@ -44,6 +50,7 @@
 #define PCA_INT			0x0100
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
+#define PCAL953X_TYPE		0x4000
 
 static const struct i2c_device_id pca953x_id[] = {
 	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT, },
@@ -55,6 +62,7 @@ static const struct i2c_device_id pca953x_id[] = {
 	{ "pca9539", 16 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9554", 8  | PCA953X_TYPE | PCA_INT, },
 	{ "pca9555", 16 | PCA953X_TYPE | PCA_INT, },
+	{ "pcal9555a",16| PCAL953X_TYPE | PCA_INT, },
 	{ "pca9556", 8  | PCA953X_TYPE, },
 	{ "pca9557", 8  | PCA953X_TYPE, },
 	{ "pca9574", 8  | PCA957X_TYPE | PCA_INT, },
@@ -81,6 +89,8 @@ struct pca953x_chip {
 	unsigned gpio_start;
 	u8 reg_output[MAX_BANK];
 	u8 reg_direction[MAX_BANK];
+	u32 reg_pupd_en;
+	u32 reg_pupd_sel;
 	struct mutex i2c_lock;
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
@@ -148,6 +158,7 @@ static int pca953x_write_regs(struct pca953x_chip *chip, int reg, u8 *val)
 					NBANK(chip), val);
 	} else {
 		switch (chip->chip_type) {
+		case PCAL953X_TYPE:
 		case PCA953X_TYPE:
 			ret = i2c_smbus_write_word_data(chip->client,
 							reg << 1, (u16) *val);
@@ -210,6 +221,7 @@ static int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)
 	reg_val = chip->reg_direction[off / BANK_SZ] | (1u << (off % BANK_SZ));
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -247,6 +259,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 			& ~(1u << (off % BANK_SZ));
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_OUTPUT;
 		break;
@@ -263,6 +276,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 	/* then direction */
 	reg_val = chip->reg_direction[off / BANK_SZ] & ~(1u << (off % BANK_SZ));
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -291,6 +305,7 @@ static int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)
 
 	mutex_lock(&chip->i2c_lock);
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
 		break;
@@ -344,6 +359,60 @@ exit:
 	mutex_unlock(&chip->i2c_lock);
 }
 
+static int pca953x_gpio_set_drive(struct gpio_chip *gc,
+				  unsigned off, unsigned mode)
+{
+	struct pca953x_chip *chip;
+	u32 pupd_en_reg_val, pupd_sel_reg_val;
+	int ret = 0;
+
+	chip = container_of(gc, struct pca953x_chip, gpio_chip);
+
+	if (chip->chip_type != PCAL953X_TYPE)
+		return -EINVAL;
+
+	mutex_lock(&chip->i2c_lock);
+
+	switch (mode) {
+	case GPIOF_DRIVE_PULLUP:
+		pupd_en_reg_val = chip->reg_pupd_en | (1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel | (1u << off);
+		break;
+	case GPIOF_DRIVE_PULLDOWN:
+		pupd_en_reg_val = chip->reg_pupd_en | (1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel & ~(1u << off);
+		break;
+	case GPIOF_DRIVE_STRONG:
+	case GPIOF_DRIVE_HIZ:
+		pupd_en_reg_val = chip->reg_pupd_en & ~(1u << off);
+		pupd_sel_reg_val = chip->reg_pupd_sel;
+		break;
+	default:
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (pupd_en_reg_val != chip->reg_pupd_en) {
+		ret = pca953x_write_regs(chip, PCAL953X_PUPD_EN,
+					 (u8 *)&pupd_en_reg_val);
+		if (ret)
+			goto exit;
+		chip->reg_pupd_en = pupd_en_reg_val;
+	}
+
+	if (pupd_sel_reg_val != chip->reg_pupd_sel) {
+		ret = pca953x_write_regs(chip, PCAL953X_PUPD_SEL,
+					 (u8 *)&pupd_sel_reg_val);
+		if (ret)
+			goto exit;
+		chip->reg_pupd_sel = pupd_sel_reg_val;
+	}
+
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
 static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 {
 	struct gpio_chip *gc;
@@ -362,6 +431,9 @@ static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 	gc->dev = &chip->client->dev;
 	gc->owner = THIS_MODULE;
 	gc->names = chip->names;
+
+	if (chip->chip_type == PCAL953X_TYPE)
+		gc->set_drive = pca953x_gpio_set_drive;
 }
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
@@ -413,6 +485,18 @@ static void pca953x_irq_bus_sync_unlock(struct irq_data *d)
 		}
 	}
 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		u16 mask = *(u16 *)chip->irq_mask;
+
+		/* Enable latch on interrupt-enabled inputs */
+		pca953x_write_regs(chip, PCAL953X_IN_LATCH,
+				   (u8 *) &mask);
+		/* Unmask enabled interrupts */
+		mask = ~mask;
+		pca953x_write_regs(chip, PCAL953X_INT_MASK,
+				   (u8 *) &mask);
+	}
+
 	mutex_unlock(&chip->irq_lock);
 }
 
@@ -458,6 +542,27 @@ static u8 pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
 	u8 trigger[MAX_BANK], triggers = 0;
 	int ret, i, offset = 0;
 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		/* Read the current interrupt status from the device */
+		ret = pca953x_read_regs(chip, PCAL953X_INT_STAT, pending);
+		if (ret)
+			return 0;
+
+		/* Check latched inputs and clear interrupt status */
+		ret = pca953x_read_regs(chip, PCA953X_INPUT, cur_stat);
+		if (ret)
+			return 0;
+
+		/* Apply filter for rising/falling edge selection */
+		for (i = 0; i < NBANK(chip); i++) {
+			pending[i] &= (~cur_stat[i] & chip->irq_trig_fall[i]) |
+				(cur_stat[i] & chip->irq_trig_raise[i]);
+			pendings += pending[i];
+		}
+
+		return pendings;
+	}
+
 	switch (chip->chip_type) {
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
@@ -549,25 +654,27 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 	if (irq_base != -1
 			&& (id->driver_data & PCA_INT)) {
 
-		switch (chip->chip_type) {
-		case PCA953X_TYPE:
-			offset = PCA953X_INPUT;
-			break;
-		case PCA957X_TYPE:
-			offset = PCA957X_IN;
-			break;
+		if (chip->chip_type != PCAL953X_TYPE) {
+			switch (chip->chip_type) {
+			case PCA953X_TYPE:
+				offset = PCA953X_INPUT;
+				break;
+			case PCA957X_TYPE:
+				offset = PCA957X_IN;
+				break;
+			}
+			ret = pca953x_read_regs(chip, offset, chip->irq_stat);
+			if (ret)
+				return ret;
+
+			/*
+			 * There is no way to know which GPIO line generated the
+			 * interrupt.  We have to rely on the previous read for
+			 * this purpose.
+			 */
+			for (i = 0; i < NBANK(chip); i++)
+				chip->irq_stat[i] &= chip->reg_direction[i];
 		}
-		ret = pca953x_read_regs(chip, offset, chip->irq_stat);
-		if (ret)
-			return ret;
-
-		/*
-		 * There is no way to know which GPIO line generated the
-		 * interrupt.  We have to rely on the previous read for
-		 * this purpose.
-		 */
-		for (i = 0; i < NBANK(chip); i++)
-			chip->irq_stat[i] &= chip->reg_direction[i];
 		mutex_init(&chip->irq_lock);
 
 		chip->domain = irq_domain_add_simple(client->dev.of_node,
@@ -658,6 +765,18 @@ static int device_pca953x_init(struct pca953x_chip *chip, u32 invert)
 	int ret;
 	u8 val[MAX_BANK];
 
+	if (chip->chip_type == PCAL953X_TYPE) {
+		ret = pca953x_read_regs(chip, PCAL953X_PUPD_EN,
+				       (u8 *)&chip->reg_pupd_en);
+		if (ret)
+			goto out;
+
+		ret = pca953x_read_regs(chip, PCAL953X_PUPD_SEL,
+				       (u8 *)&chip->reg_pupd_sel);
+		if (ret)
+			goto out;
+	}
+
 	ret = pca953x_read_regs(chip, PCA953X_OUTPUT, chip->reg_output);
 	if (ret)
 		goto out;
@@ -748,7 +867,8 @@ static int pca953x_probe(struct i2c_client *client,
 
 	chip->client = client;
 
-	chip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);
+	chip->chip_type = id->driver_data &
+		(PCAL953X_TYPE | PCA953X_TYPE | PCA957X_TYPE);
 
 	mutex_init(&chip->i2c_lock);
 
@@ -757,7 +877,7 @@ static int pca953x_probe(struct i2c_client *client,
 	 */
 	pca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);
 
-	if (chip->chip_type == PCA953X_TYPE)
+	if (chip->chip_type & (PCA953X_TYPE | PCAL953X_TYPE))
 		ret = device_pca953x_init(chip, invert);
 	else
 		ret = device_pca957x_init(chip, invert);
@@ -809,6 +929,165 @@ static int pca953x_remove(struct i2c_client *client)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+
+/*
+ * There is nothing to be done before the system goes to S3 - the registers
+ * values are stored in driver's cache.
+ * */
+#define pca953x_suspend NULL
+
+/**
+ * pca953x_resume - resume PM callback
+ * @dev - pointer to device
+ * Returns 0 if succes, negative value otherwhise
+ *
+ * Restore registers state from driver's cache. If restoring one or more
+ * registers fail, it keeps trying to restore the rest of the registers and
+ * returns only the last error code.
+ */
+static int pca953x_resume(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct pca953x_chip *chip = i2c_get_clientdata(i2c);
+	struct pca953x_platform_data *pdata;
+	int ret = 0;
+	u32 invert = 0;
+	int err = 0;
+	u16 mask, val;
+
+	/* Retrieve invert from platform data */
+	pdata = i2c->dev.platform_data;
+	if (pdata)
+		invert = pdata->invert;
+	else
+		pca953x_get_alt_pdata(i2c, &chip->gpio_start, &invert);
+
+	mutex_lock(&chip->i2c_lock);
+
+	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
+		/* Restore the pull-up/pull-down enable & selection registers */
+		ret = pca953x_write_regs(chip, PCAL953X_PUPD_EN,
+					 (u8 *)&chip->reg_pupd_en);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring pull-up enable register: %d\n",
+				ret);
+			err = ret;
+		}
+
+		ret = pca953x_write_regs(chip, PCAL953X_PUPD_SEL,
+					 (u8 *)&chip->reg_pupd_sel);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring pull-up select register: %d\n",
+				ret);
+			err = ret;
+		}
+
+		mask = *(u16 *)chip->irq_mask;
+		/* Restore latch on interrupt-enabled inputs */
+		ret = pca953x_write_regs(chip, PCAL953X_IN_LATCH,
+					 (u8 *)&mask);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring input latch register: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Unmask enabled interrupts */
+		mask = ~mask;
+		ret = pca953x_write_regs(chip, PCAL953X_INT_MASK,
+					 (u8 *)&mask);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring interrupt mask register: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Continue restoring outport and direction port registers */
+	case PCA953X_TYPE:
+		/* Restore platform specific polarity inversion */
+		ret = pca953x_write_regs(chip, PCA953X_INVERT, (u8 *)&invert);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring polarity inversion: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Restore output port register(s) */
+		ret = pca953x_write_regs(chip, PCA953X_OUTPUT, chip->reg_output);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring output port register: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Restore GPIOs directions - configuration register(s) */
+		ret = pca953x_write_regs(chip, PCA953X_DIRECTION,
+				chip->reg_direction);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring direction register: %d\n",
+				ret);
+			err = ret;
+		}
+		break;
+	case PCA957X_TYPE:
+		/* Restore platform specific polarity inversion */
+		ret = pca953x_write_regs(chip, PCA957X_INVRT, (u8 *)&invert);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring polarity inversion: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Restore output port register(s) */
+		ret = pca953x_write_regs(chip, PCA957X_OUT, chip->reg_output);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring output port register: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Restore GPIOs directions - configuration register(s) */
+		ret = pca953x_write_regs(chip, PCA957X_CFG, chip->reg_direction);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring direction register: %d\n",
+				ret);
+			err = ret;
+		}
+		/* Enable back register 6 and 7 to controll pull-up and
+		 * pull-down */
+		val = 0x202;
+		ret = pca953x_write_regs(chip, PCA957X_BKEN, (u8 *)&val);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Error restoring bus-hold register: %d\n",
+				ret);
+			err = ret;
+		}
+
+		break;
+	}
+
+	mutex_unlock(&chip->i2c_lock);
+	return err;
+}
+#else /* !CONFIG_PM */
+
+#define pca953x_suspend NULL
+#define pca953x_resume  NULL
+
+#endif /* CONFIG_PM */
+
+const struct dev_pm_ops pca953x_pm_ops = {
+	.suspend	= pca953x_suspend,
+	.resume		= pca953x_resume,
+};
+
 static const struct of_device_id pca953x_dt_ids[] = {
 	{ .compatible = "nxp,pca9505", },
 	{ .compatible = "nxp,pca9534", },
@@ -842,6 +1121,7 @@ static struct i2c_driver pca953x_driver = {
 	.driver = {
 		.name	= "pca953x",
 		.of_match_table = pca953x_dt_ids,
+		.pm	= &pca953x_pm_ops,
 	},
 	.probe		= pca953x_probe,
 	.remove		= pca953x_remove,
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index c2534d6..0f27e91 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -60,11 +60,17 @@ struct gpio_desc {
 #define FLAG_ACTIVE_LOW	6	/* sysfs value has active low */
 #define FLAG_OPEN_DRAIN	7	/* Gpio is open drain type */
 #define FLAG_OPEN_SOURCE 8	/* Gpio is open source type */
+#define FLAG_PULLUP	9	/* Gpio drive is resistive pullup */
+#define FLAG_PULLDOWN	10	/* Gpio drive is resistive pulldown */
+#define FLAG_STRONG	11	/* Gpio drive is strong (fast output) */
+#define FLAG_HIZ	12	/* Gpio drive is Hi-Z (input) */
 
 #define ID_SHIFT	16	/* add new flags before this one */
 
 #define GPIO_FLAGS_MASK		((1 << ID_SHIFT) - 1)
 #define GPIO_TRIGGER_MASK	(BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))
+#define GPIO_DRIVE_MASK		(BIT(FLAG_PULLUP) | BIT(FLAG_PULLDOWN) \
+				| BIT(FLAG_STRONG) | BIT(FLAG_HIZ))
 
 #ifdef CONFIG_DEBUG_FS
 	const char		*label;
@@ -261,6 +267,10 @@ static DEFINE_MUTEX(sysfs_lock);
  *      * is read/write as zero/nonzero
  *      * also affects existing and subsequent "falling" and "rising"
  *        /edge configuration
+ *   /drive
+ *      * sets signal drive mode
+ *      * is read/write as "pullup", "pulldown", "strong" or "hiz"
+ *
  */
 
 static ssize_t gpio_direction_show(struct device *dev,
@@ -583,9 +593,85 @@ static ssize_t gpio_active_low_store(struct device *dev,
 static const DEVICE_ATTR(active_low, 0644,
 		gpio_active_low_show, gpio_active_low_store);
 
+static ssize_t gpio_drive_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags)) {
+		status = -EIO;
+	} else {
+		if (test_bit(FLAG_PULLUP, &desc->flags))
+			status = sprintf(buf, "pullup\n");
+		else if (test_bit(FLAG_PULLDOWN, &desc->flags))
+			status = sprintf(buf, "pulldown\n");
+		else if (test_bit(FLAG_STRONG, &desc->flags))
+			status = sprintf(buf, "strong\n");
+		else if (test_bit(FLAG_HIZ, &desc->flags))
+			status = sprintf(buf, "hiz\n");
+		else
+			status = -EINVAL;
+	}
+
+	mutex_unlock(&sysfs_lock);
+	return status;
+}
+
+static ssize_t gpio_drive_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpio_desc	*desc = dev_get_drvdata(dev);
+	unsigned		gpio = desc - gpio_desc;
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else {
+		if (sysfs_streq(buf, "pullup")) {
+			status = gpio_set_drive(gpio, GPIOF_DRIVE_PULLUP);
+			if (!status) {
+				desc->flags &= ~GPIO_DRIVE_MASK;
+				set_bit(FLAG_PULLUP, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "pulldown")) {
+			status = gpio_set_drive(gpio, GPIOF_DRIVE_PULLDOWN);
+			if (!status) {
+				desc->flags &= ~GPIO_DRIVE_MASK;
+				set_bit(FLAG_PULLDOWN, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "strong")) {
+			status = gpio_set_drive(gpio, GPIOF_DRIVE_STRONG);
+			if (!status) {
+				desc->flags &= ~GPIO_DRIVE_MASK;
+				set_bit(FLAG_STRONG, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "hiz")) {
+			status = gpio_set_drive(gpio, GPIOF_DRIVE_HIZ);
+			if (!status) {
+				desc->flags &= ~GPIO_DRIVE_MASK;
+				set_bit(FLAG_HIZ, &desc->flags);
+			}
+		} else {
+			status = -EINVAL;
+		}
+	}
+
+	mutex_unlock(&sysfs_lock);
+	return status ? : size;
+}
+
+static const DEVICE_ATTR(drive, 0644,
+		gpio_drive_show, gpio_drive_store);
+
 static const struct attribute *gpio_attrs[] = {
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
+	&dev_attr_drive.attr,
 	NULL,
 };
 
@@ -1802,6 +1888,50 @@ int gpio_set_debounce(unsigned gpio, unsigned debounce)
 }
 EXPORT_SYMBOL_GPL(gpio_set_debounce);
 
+/**
+ * gpio_set_drive - sets drive @mode for a @gpio
+ * @gpio: the gpio to set the drive mode
+ * @mode: the drive mode
+ */
+int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	unsigned long		flags;
+	struct gpio_chip	*chip;
+	struct gpio_desc	*desc = &gpio_desc[gpio];
+	int			status = -EINVAL;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	if (!gpio_is_valid(gpio))
+		goto fail;
+	chip = desc->chip;
+	if (!chip || !chip->set || !chip->set_drive)
+		goto fail;
+	gpio -= chip->base;
+	if (gpio >= chip->ngpio)
+		goto fail;
+	status = gpio_ensure_requested(desc);
+	if (status < 0)
+		goto fail;
+
+	/* now we know the gpio is valid and chip won't vanish */
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	might_sleep_if(chip->can_sleep);
+
+	return chip->set_drive(chip, gpio, mode);
+
+fail:
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	if (status)
+		pr_debug("%s: gpio-%d status %d\n",
+			__func__, gpio, status);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpio_set_drive);
+
 /* I/O calls are only valid after configuration completed; the relevant
  * "is this a valid GPIO" error checks should already have been done.
  *
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index bde6469..584bd9b 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -67,6 +67,7 @@ struct gpio_desc;
  * @direction_output: configures signal "offset" as output, or returns error
  * @set_debounce: optional hook for setting debounce time for specified gpio in
  *      interrupt triggered gpio chips
+ * @set_drive: optional hook for setting the drive signal for "offset"
  * @set: assigns output value for signal "offset"
  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
  *	implementation may not sleep
@@ -117,6 +118,8 @@ struct gpio_chip {
 						unsigned offset, int value);
 	int			(*set_debounce)(struct gpio_chip *chip,
 						unsigned offset, unsigned debounce);
+	int			(*set_drive)(struct gpio_chip *chip,
+					     unsigned offset, unsigned mode);
 
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
@@ -176,6 +179,7 @@ extern int gpio_direction_input(unsigned gpio);
 extern int gpio_direction_output(unsigned gpio, int value);
 
 extern int gpio_set_debounce(unsigned gpio, unsigned debounce);
+extern int gpio_set_drive(unsigned gpio, unsigned mode);
 
 extern int gpio_get_value_cansleep(unsigned gpio);
 extern void gpio_set_value_cansleep(unsigned gpio, int value);
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index 552e3f4..f9183c1 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -27,6 +27,11 @@
 #define GPIOF_EXPORT_DIR_FIXED	(GPIOF_EXPORT)
 #define GPIOF_EXPORT_DIR_CHANGEABLE (GPIOF_EXPORT | GPIOF_EXPORT_CHANGEABLE)
 
+#define GPIOF_DRIVE_PULLUP	(1 << 6)
+#define GPIOF_DRIVE_PULLDOWN	(1 << 7)
+#define GPIOF_DRIVE_STRONG	(1 << 8)
+#define GPIOF_DRIVE_HIZ		(1 << 9)
+
 /**
  * struct gpio - a structure describing a GPIO with configuration
  * @gpio:	the GPIO number
@@ -136,6 +141,11 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 	return -ENOSYS;
 }
 
+static inline int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	return -ENOSYS;
+}
+
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
-- 
1.7.5.4

