From bf6fd7433ea1b31f070c10b4f5a0fb3c7b99b758 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 14 Jan 2015 10:06:17 +0800
Subject: [PATCH 31/31] spi-pxa2xx: enable MSI support and fix detection
 failure.

Use PCI function as port_id to identify SPI master instead for Quark
SoC specific.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/spi/spi-pxa2xx-pci.c |   27 ++++++++++++++++++++++++---
 drivers/spi/spi-pxa2xx.c     |   14 +++++++++++++-
 include/linux/pxa2xx_ssp.h   |    1 +
 3 files changed, 38 insertions(+), 4 deletions(-)

diff --git a/drivers/spi/spi-pxa2xx-pci.c b/drivers/spi/spi-pxa2xx-pci.c
index bb27065..919d390 100644
--- a/drivers/spi/spi-pxa2xx-pci.c
+++ b/drivers/spi/spi-pxa2xx-pci.c
@@ -30,6 +30,14 @@ struct pxa2xx_spi_pci_config {
 	int rx_chan_id;
 };
 
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+static int enable_msi = 1;
+#else
+static int enable_msi;
+#endif
+module_param(enable_msi, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
 static struct pxa2xx_spi_pci_config spi_pci_configs[] = {
 	[PORT_CE4100] = {
 		.type = PXA25x_SSP,
@@ -52,7 +60,7 @@ static struct pxa2xx_spi_pci_config spi_pci_configs[] = {
 	[PORT_QUARK_X1000] = {
 		.type = QUARK_X1000_SSP,
 		.port_id = -1,
-		.num_cs = 1,
+		.num_cs = 4,
 	},
 };
 
@@ -88,15 +96,28 @@ static int pxa2xx_spi_probe(struct pci_dev *dev,
 	       	spi_pdata.enable_dma = c->rx_slave_id >= 0 && c->tx_slave_id >= 0;
 
 	ssp = &spi_pdata.ssp;
+	ssp->pcidev = dev;
 	ssp->phys_base = pci_resource_start(dev, 0);
 	ssp->mmio_base = pcim_iomap_table(dev)[0];
 	if (!ssp->mmio_base) {
 		dev_err(&dev->dev, "failed to ioremap() registers\n");
 		return -EIO;
 	}
-	ssp->clk =  devm_clk_get(&dev->dev, NULL);
+
+	pci_set_master(dev);
+	if (enable_msi == 1) {
+		ret = pci_enable_msi(dev);
+		if (ret) {
+			dev_dbg(&dev->dev, "failed to allocate MSI entry\n");
+		}
+	}
+
+	ssp->clk = devm_clk_get(&dev->dev, NULL);
 	ssp->irq = dev->irq;
-	ssp->port_id = (c->bus_num >= 0) ? c->bus_num : dev->devfn;
+	if (c->type != QUARK_X1000_SSP)
+		ssp->port_id = (c->bus_num >= 0) ? c->bus_num : dev->devfn;
+	else
+		ssp->port_id = PCI_FUNC(dev->devfn);
 	ssp->type = c->type;
 
 	memset(&pi, 0, sizeof(pi));
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index d69b485..dfffbab 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -38,6 +38,9 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/delay.h>
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+#include <asm/qrk.h>
+#endif
 
 #include "spi-pxa2xx.h"
 
@@ -675,6 +678,7 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 	u32 sccr1_reg;
 	u32 mask = drv_data->mask_sr;
 	u32 status;
+	irqreturn_t ret;
 
 	/*
 	 * The IRQ might be shared with other peripherals so we must first
@@ -695,6 +699,10 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 	if (!(status & mask))
 		return IRQ_NONE;
 
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	mask_pvm(drv_data->ssp->pcidev);
+#endif
+
 	if (!drv_data->cur_msg) {
 
 		write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
@@ -710,7 +718,11 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
-	return drv_data->transfer_handler(drv_data);
+	ret = drv_data->transfer_handler(drv_data);
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC
+	unmask_pvm(drv_data->ssp->pcidev);
+#endif
+	return ret;
 }
 
 /*
diff --git a/include/linux/pxa2xx_ssp.h b/include/linux/pxa2xx_ssp.h
index afb8507..b2cd28d 100644
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -210,6 +210,7 @@ struct ssp_device {
 	int		irq;
 	int		drcmr_rx;
 	int		drcmr_tx;
+	struct pci_dev	*pcidev;
 };
 
 /**
-- 
1.7.5.4

