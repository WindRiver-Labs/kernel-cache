From b990cde9eba77a72621ea24be3d20814a6f77cd1 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Tue, 22 Apr 2014 16:00:53 +0800
Subject: [PATCH 3/9] Add glue driver for TPM slb9645tt chip used on Cross
 Hill.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 .../intel-quark/intel_quark_platform_cross_hill.c  |   81 +++++++++++++++++++-
 include/linux/platform_data/tpm_i2c_infenion.h     |   24 ++++++
 2 files changed, 104 insertions(+), 1 deletions(-)
 create mode 100644 include/linux/platform_data/tpm_i2c_infenion.h

diff --git a/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c b/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
index 130447e..a031857 100644
--- a/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
+++ b/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
@@ -14,6 +14,7 @@
 #include <linux/printk.h>
 #include <linux/spi/pxa2xx_spi.h>
 #include <linux/spi/spi.h>
+#include <linux/platform_data/tpm_i2c_infenion.h>
 
 #define DRIVER_NAME		"CrossHill"
 #define GPIO_RESTRICT_NAME_NC	"qrk-gpio-restrict-nc"
@@ -63,6 +64,37 @@ enum {
 	QRK_SPI_BPEAK_ID_NONE
 };
 
+/* GPIO line used to reset SLB9645TT */
+#define GPIO_SLB9645TT_RESET		7
+/* GPIO line SLB9645TT interrupt are routed to */
+#define GPIO_SLB9645TT_INT		0
+
+#define SLB9645TT_ADDR			0x20
+
+struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
+	.gpio_reset = GPIO_SLB9645TT_RESET,
+	.gpio_irq = GPIO_SLB9645TT_INT,
+};
+
+static struct i2c_board_info probed_slb9645tt = {
+	.platform_data = &slb9645tt_platform_data,
+};
+
+static const unsigned short slb9645tt_i2c_addr[] =
+	{ SLB9645TT_ADDR, I2C_CLIENT_END };
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_SLB9645TT_RESET,
+		GPIOF_OUT_INIT_HIGH,
+		"slb96455tt-reset",
+	},
+	{
+		GPIO_SLB9645TT_INT,
+		GPIOF_IN,
+		"slb96455tt-int",
+	},
+};
 
 /******************************************************************************
  *             Analog Devices AD7298 SPI Device Platform Data
@@ -141,7 +173,50 @@ static struct spi_board_info spi_energy_adc_devs[] = {
 	},
 };
 
+static int slb9645tt_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return gpio_get_value(GPIO_SLB9645TT_RESET);
+}
+
+static int intel_qrk_slb9645tt_probe(void)
+{
+	struct i2c_adapter *i2c_adap;
+	struct i2c_client *slb9645tt;
+	int ret;
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		pr_err("%s: unable to reserve the GPIOs for slb9645tt\n",
+			__func__);
+		return ret;
+	}
+
+	probed_slb9645tt.irq = gpio_to_irq(GPIO_SLB9645TT_INT);
+
+	i2c_adap = i2c_get_adapter(0);
+	if (!i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto err;
+	}
+
+	strlcpy(probed_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
+	slb9645tt = i2c_new_probed_device(i2c_adap, &probed_slb9645tt,
+					  slb9645tt_i2c_addr, slb9645tt_i2c_probe);
+	i2c_put_adapter(i2c_adap);
 
+	if (!slb9645tt) {
+		pr_err("%s: can't probe slb9645tt\n", __func__);
+		ret = -ENODEV;
+		goto err;
+        }
+
+	return 0;
+err:
+	gpio_free_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	return ret;
+}
 
 /**
  * intel_qrk_spi_add_onboard_devs
@@ -348,6 +423,8 @@ static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
 		ret = intel_qrk_spi_devs_addon();
 		if (ret)
 			return ret;
+
+		return intel_qrk_slb9645tt_probe();
 	}
 	return 0;
 }
@@ -367,6 +444,8 @@ static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
 		ret = intel_qrk_spi_devs_addon();
 		if (ret)
 			return ret;
+
+		return intel_qrk_slb9645tt_probe();
 	}
 	return 0;
 }
@@ -389,7 +468,7 @@ static struct platform_driver gpio_restrict_pdriver_sc = {
 
 static int intel_qrk_plat_cross_hill_probe(struct platform_device *pdev)
 {
-	int ret = 0;
+	int ret;
 
 	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
 	if (ret)
diff --git a/include/linux/platform_data/tpm_i2c_infenion.h b/include/linux/platform_data/tpm_i2c_infenion.h
new file mode 100644
index 0000000..cfd4cd0
--- /dev/null
+++ b/include/linux/platform_data/tpm_i2c_infenion.h
@@ -0,0 +1,24 @@
+/*
+ * Infenion TPM i2c driver
+ *
+ * Copyright 2014 Wind River Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_TPM_I2C_INFENION_H__
+#define __LINUX_PLATFORM_DATA_TPM_I2C_INFENION_H__
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+
+struct tpm_i2c_infenion_platform_data {
+	int gpio_irq;
+	int gpio_reset;
+	struct i2c_client *client;
+	u8 *tpm_i2c_buffer[2]; /* 0 Request 1 Response */
+	struct completion irq_detection;
+	struct mutex lock;
+};
+
+#endif	/* __LINUX_PLATFORM_DATA_TPM_I2C_INFENION_H__ */
-- 
1.7.5.4

