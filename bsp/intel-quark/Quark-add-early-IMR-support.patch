From 123cfabb457d3f0dc6720734900d6ec045d6d16e Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 2 Oct 2013 15:21:57 +0800
Subject: [PATCH 1161/1187] Quark: add early IMR support.

This feature implements a simple binding to provide early isolated memory
region support (IMR) - with the primary goal of encapsulating kernel
decompress target area inside of an IMR before decompression takes place.
To that end we do some very very early PCI accesses here - required in
order to waggle the side-band bits associated with IMR support.

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/boot/compressed/Makefile    |    2 +-
 arch/x86/boot/compressed/early_imr.c |  399 ++++++++++++++++++++++++++++++++++
 arch/x86/boot/compressed/misc.c      |    8 +
 arch/x86/include/asm/imr.h           |   22 ++
 4 files changed, 430 insertions(+), 1 deletions(-)
 create mode 100644 arch/x86/boot/compressed/early_imr.c
 create mode 100644 arch/x86/include/asm/imr.h

diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 7fc1225..83745b0 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -26,7 +26,7 @@ HOST_EXTRACFLAGS += -I$(srctree)/tools/include
 
 VMLINUX_OBJS = $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
 	$(obj)/string.o $(obj)/cmdline.o $(obj)/early_serial_console.o \
-	$(obj)/piggy.o
+	$(obj)/piggy.o $(obj)/early_imr.o
 
 $(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone
 
diff --git a/arch/x86/boot/compressed/early_imr.c b/arch/x86/boot/compressed/early_imr.c
new file mode 100644
index 0000000..b5e9ab1
--- /dev/null
+++ b/arch/x86/boot/compressed/early_imr.c
@@ -0,0 +1,399 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * This file implements a simple binding to provide early isolated memory region
+ * support (IMR) - with the primary goal of encapsulating kernel decompress
+ * target area inside of an IMR before decompression takes place. To that end we
+ * do some very very early PCI accesses here - required in order to waggle the
+ * side-band bits associated with IMR support
+ */
+#include <linux/io.h>
+
+#include "misc.h"
+
+#define INTEL_CLN_SB_CMD_ADDR		(0x000000D0)
+#define INTEL_CLN_SB_DATA_ADDR		(0x000000D4)
+
+#define INTEL_CLN_SB_MCR_SHIFT		(24)
+#define INTEL_CLN_SB_PORT_SHIFT		(16)
+#define INTEL_CLN_SB_REG_SHIFT		(8)
+#define INTEL_CLN_SB_BYTEEN		(0xF0)	/* enable all 32 bits */
+
+/* PCI config space reg definitions */
+#define PCI_VENDOR_ID			(0x00)
+#define PCI_DEVICE_ID			(0x02)
+#define PCI_CLASS_DEVICE		(0x0A)
+
+/* IMR related reg address */
+#define CFG_READ_OPCODE			(0x10)  /* Control Read */
+#define CFG_WRITE_OPCODE		(0x11)  /* Control write */
+#define DRAM_IMR0L			(0x40)  /* IMR0RL address */
+#define DRAM_IMR0H			(0x41)  /* IMR0RL address */
+#define DRAM_IMR0RM			(0x42)  /* IMR0RM address */
+#define DRAM_IMR0WM			(0x43)  /* IMR0WM address */
+#define DRAM_IMR1L			(0x44)  /* IMR1L address */
+#define DRAM_IMR1H			(0x45)  /* IMR1H address */
+#define DRAM_IMR1RM			(0x46)  /* IMR1RM address */
+#define DRAM_IMR1WM			(0x47)  /* IMR1WM address */
+#define DRAM_IMR3L			(0x4C)  /* IMR3L address */
+#define DRAM_IMR3H			(0x4D)  /* IMR3H address */
+#define DRAM_IMR3RM			(0x4E)  /* IMR3RM address */
+#define DRAM_IMR3WM			(0x4F)  /* IMR3WM address */
+#define DRAM_IMR7L			(0x5C)  /* IMR7RM address */
+#define DRAM_IMR7H			(0x5D)  /* IMR7RM address */
+#define DRAM_IMR7RM			(0x5E)  /* IMR7RM address */
+#define DRAM_IMR7WM			(0x5F)  /* IMR7WM address */
+
+#define IMR_WRITE_ENABLE_ALL		(0xFFFFFFFF)
+#define IMR_READ_ENABLE_ALL		(0xBFFFFFFF)
+#define IMR_BASE_ADDR			(0x0000)
+#define IMR_LOCK_BIT			(0x80000000)
+
+/* Mask of the last 2 bit of IMR address [23:2] */
+#define IMR_MASK			(0xFFFFFC)
+
+/* Mask that enables IMR access for Non-SMM Core, Core Snoops Only.*/
+#define IMR_SNOOP_NON_SMM_ENABLE	(0x40000001)
+
+/* Mask that enables IMR access for Non-SMM Core Only.*/
+#define IMR_NON_SMM_ENABLE		(0x00000001)
+
+/* Max Memory Address */
+#define MAX_MEM_ADDR			(0xFFFFFFFF)
+
+enum {
+	SB_ID_HUNIT = 0x03,
+	SB_ID_THERMAL = 0x04,
+	SB_ID_IMRID = 0x05,
+} cln_sb_id;
+
+struct sb_pci_dev {
+	unsigned int bus;
+	unsigned int dev_fn;
+};
+
+static struct sb_pci_dev sb_pcidev;
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+#define CONFIG_CMD(bus, dev_fn, where)\
+	(0x80000000 | (bus << 16) | (dev_fn << 8) | (where & ~3))
+/**
+ * pci_read_config_word
+ *
+ * @param db_pcidev: Pointer to side-band PCI device
+ * @param where: Register offset to read
+ * @param value: Pointer to output parameter
+ * @return nothing
+ *
+ * Utility function to allow simple PCI read of configuration space 16 bit field
+ * via legacy PCI access mechanism.
+ */
+static void pci_read_config_word(struct sb_pci_dev *sb_pcidev,
+				unsigned int where, unsigned short *value)
+{
+	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
+	*value = inw(0xCFC + (where&2));
+}
+
+/**
+ * pci_read_config_dword
+ *
+ * @param db_pcidev: Pointer to side-band PCI device
+ * @param where: Register offset to read
+ * @param value: Pointer to output parameter
+ * @return nothing
+ *
+ * Utility function to allow simple PCI read of configuration space 32 bit field
+ * via legacy PCI access mechanism.
+ */
+static void pci_read_config_dword(struct sb_pci_dev *sb_pcidev,
+				unsigned int where, unsigned int *value)
+{
+	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
+	*value = inl(0xCFC);
+}
+
+/**
+ * pci_write_config_word
+ *
+ * @param db_pcidev: Pointer to side-band PCI device
+ * @param where: Register offset to read
+ * @param value: Value to stuff into destination register
+ * @return nothing
+ *
+ * Utility function to allow simple PCI write of configuration space 16 bit
+ * field via legacy PCI access mechanism.
+ */
+static void pci_write_config_word(struct sb_pci_dev *sb_pcidev,
+				unsigned int where, unsigned short value)
+{
+	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
+	outw(value, 0xCFC + (where&2));
+}
+
+/**
+ * pci_write_config_dword
+ *
+ * @param db_pcidev: Pointer to side-band PCI device
+ * @param where: Register offset to read
+ * @param value: Value to stuff into destination register
+ * @return nothing
+ *
+ * Utility function to allow simple PCI write of configuration space 32 bit
+ * field via legacy PCI access mechanism.
+ */
+static void pci_write_config_dword(struct sb_pci_dev *sb_pcidev,
+				unsigned int where, unsigned int value)
+{
+	outl(CONFIG_CMD(sb_pcidev->bus, sb_pcidev->dev_fn, where), 0xCF8);
+	outl(value, 0xCFC);
+}
+
+/**
+ * intel_cln_early_sb_read_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+static void intel_cln_early_sb_read_reg(int id, uint8_t cmd, uint8_t reg,
+					uint32_t *data)
+{
+	uint32_t msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) |
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000) |
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00) |
+		  INTEL_CLN_SB_BYTEEN;
+
+	if (data == NULL)
+		return;
+
+	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_CMD_ADDR, msg);
+	pci_read_config_dword(&sb_pcidev, INTEL_CLN_SB_DATA_ADDR, data);
+}
+
+/**
+ * intel_cln_early_sb_write_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+static void intel_cln_early_sb_write_reg(int id, uint8_t cmd, uint8_t reg,
+					uint32_t data)
+{
+	uint32_t msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) |
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000) |
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00) |
+		  INTEL_CLN_SB_BYTEEN;
+
+	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_DATA_ADDR, data);
+	pci_write_config_dword(&sb_pcidev, INTEL_CLN_SB_CMD_ADDR, msg);
+}
+
+/* Clanton hardware */
+#define PCI_VENDOR_ID_INTEL		(0x8086)
+#define PCI_DEVICE_ID_CLANTON_SB	(0x0958)
+
+/**
+ * sb_probe
+ *
+ * @param dev: the PCI device matching
+ * @param id: entry in the match table
+ * @return 0
+ *
+ * Callback from PCI layer when dev/vendor ids match.
+ * Sets up necessary resources
+ */
+static int intel_cln_early_sb_probe(void)
+{
+	int found = 0;
+	uint16_t class;
+	uint16_t device, vendor;
+
+	sb_pcidev.bus = 0;
+	for (sb_pcidev.dev_fn = 0; sb_pcidev.dev_fn < 0xFF;
+		sb_pcidev.dev_fn++) {
+		/* Only probe function 0 on single fn devices */
+		pci_read_config_word(&sb_pcidev, PCI_CLASS_DEVICE, &class);
+
+		if (class == 0xffff)
+			continue;
+
+		pci_read_config_word(&sb_pcidev, PCI_VENDOR_ID, &vendor);
+		pci_read_config_word(&sb_pcidev, PCI_DEVICE_ID, &device);
+
+		/* Do early PCI UART init */
+		if (vendor == PCI_VENDOR_ID_INTEL) {
+			if (device == PCI_DEVICE_ID_CLANTON_SB) {
+				/* Found */
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (found == 0)
+		return -1;
+
+	return 0;
+}
+
+
+
+
+/**
+ * addr_hw_ready
+ *
+ * shift input address value to match HW required 1k aligned format
+ */
+static inline uint32_t addr_hw_ready(uint32_t addr)
+{
+	/* memory alignment */
+	addr &= (~((1 << 10) - 1));
+
+	/* prepare input addr in HW required format */
+	addr = (addr >> 8) & IMR_MASK;
+	return addr;
+}
+
+/**
+ * cln_remove_imr
+ *
+ * @return nothing
+ *
+ * write default values to reg to set imr free
+ */
+static void cln_remove_imr(uint8_t reg_l, uint8_t reg_h, uint8_t reg_rm,
+			uint8_t reg_wm)
+{
+	uint32_t tmp_addr;
+
+	intel_cln_early_sb_read_reg(SB_ID_IMRID, CFG_READ_OPCODE, reg_l,
+				&tmp_addr);
+	if (tmp_addr & IMR_LOCK_BIT) {
+		/* Failure to teardown an IMR means we can't guarantee DMA to
+		 * the now 'IMR free' region will succeed - so we bug out
+		 */
+		error_putstr("IMR LOCKED !\n");
+		while (1)
+			asm("hlt");
+		return;
+	}
+
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_rm,
+				IMR_READ_ENABLE_ALL);
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_wm,
+				IMR_WRITE_ENABLE_ALL);
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_h,
+				IMR_BASE_ADDR);
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE, reg_l,
+				IMR_BASE_ADDR);
+}
+
+/**
+ * cln_remove_imr_grub
+ *
+ * @return nothing
+ * remove imr protection from grub,
+ * set imr rw masks to default
+ */
+static void cln_remove_imr_grub(void)
+{
+	cln_remove_imr(DRAM_IMR0L, DRAM_IMR0H, DRAM_IMR0RM, DRAM_IMR0WM);
+}
+
+/**
+ * cln_remove_imr_boot_params
+ *
+ * @return nothing
+ * remove imr protection from grub,
+ * set imr rw masks to default
+ */
+static void cln_remove_imr_boot_params(void)
+{
+	cln_remove_imr(DRAM_IMR1L, DRAM_IMR1H, DRAM_IMR1RM, DRAM_IMR1WM);
+}
+
+/**
+ * cln_remove_imr_bzimage
+ *
+ * @return nothing
+ * remove imr protection from bzImage,
+ * set imr rw masks to default
+ */
+static void cln_remove_imr_bzimage(void)
+{
+	cln_remove_imr(DRAM_IMR7L, DRAM_IMR7H, DRAM_IMR7RM, DRAM_IMR7WM);
+}
+
+/**
+ * decompress_kernel_imr
+ *
+ * @param command: Command to send to destination identifier
+ * @return nothing
+ *
+ * Early in the boot process it is not possible to get the address of
+ * &__init_end, so instead we setup a temporary IMR from LOAD_PHYSICAL_ADDR to
+ * 2^32 -1. While this IMR is active DMA to this address range is invalid.
+ * Later when the address of __init_end is available (inside the decompressed
+ * kernel) we setup a new IMR for a smaller range and tear down this IMR, to
+ * ensure at all times an IMR is protecting critical sections of the .text
+ * section
+ */
+void decompress_kernel_imr(struct boot_params *boot)
+{
+	uint32_t imr_hi_addr;
+	uint32_t imr_lo_addr;
+
+	if (intel_cln_early_sb_probe() != 0) {
+		debug_putstr("NO Early SB support !\n");
+		return;
+	}
+
+	/* Set extent of initial decompress IMR */
+	imr_lo_addr = addr_hw_ready(LOAD_PHYSICAL_ADDR);
+	imr_hi_addr = addr_hw_ready(MAX_MEM_ADDR);
+
+	/* Set boundaries and access rights of new IMR */
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
+				DRAM_IMR3H, imr_hi_addr);
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
+				DRAM_IMR3L, imr_lo_addr);
+
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
+					DRAM_IMR3RM, IMR_NON_SMM_ENABLE);
+	intel_cln_early_sb_write_reg(SB_ID_IMRID, CFG_WRITE_OPCODE,
+					DRAM_IMR3WM, IMR_SNOOP_NON_SMM_ENABLE);
+
+	/* Teardown unused IMRs */
+	cln_remove_imr_boot_params();
+	cln_remove_imr_bzimage();
+	cln_remove_imr_grub();
+}
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index 88f7ff6..31686ee 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -145,6 +145,10 @@ static int lines, cols;
 #include "../../../../lib/decompress_unlzo.c"
 #endif
 
+#ifdef CONFIG_INTEL_CLN_SOC
+extern void decompress_kernel_imr(struct boot_params * boot);
+#endif
+
 static void scroll(void)
 {
 	int i;
@@ -356,6 +360,10 @@ asmlinkage void decompress_kernel(void *rmode, memptr heap,
 		error("Wrong destination address");
 #endif
 
+#ifdef CONFIG_INTEL_CLN_SOC
+	decompress_kernel_imr(real_mode);
+#endif
+
 	debug_putstr("\nDecompressing Linux... ");
 	decompress(input_data, input_len, NULL, NULL, output, NULL, error);
 	parse_elf(output);
diff --git a/arch/x86/include/asm/imr.h b/arch/x86/include/asm/imr.h
new file mode 100644
index 0000000..b22012b
--- /dev/null
+++ b/arch/x86/include/asm/imr.h
@@ -0,0 +1,22 @@
+/*
+ * imr.h: Intel Clanton platform imr setup code
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_IMR_H
+#define _ASM_X86_IMR_H
+
+#if defined(CONFIG_INTEL_CLN_SOC)
+	extern int intel_cln_imr_runt_setparams(void);
+	extern int intel_cln_imr_lockall(void);
+#else
+	static void intel_cln_imr_runt_setparams(void){}
+	static void intel_cln_imr_lockall(void){}
+#endif
+
+#endif /* _ASM_X86_IMR_H */
-- 
1.7.5.4

