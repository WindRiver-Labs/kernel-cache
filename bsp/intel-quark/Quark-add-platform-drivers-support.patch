From c77baa4f2671f9f2126faf438fa41275029c87ce Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 2 Oct 2013 15:41:29 +0800
Subject: [PATCH 1162/1187] Quark: add platform drivers support.

This patch integrates the platform drivers for Quark SoC, including:

    - board data
    - layout data
    - platform data
    - Side Band
    - IMR
    - ECC
    - Thermal

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 arch/x86/platform/Makefile                         |    1 +
 arch/x86/platform/cln/Makefile                     |   16 +
 arch/x86/platform/cln/intel_cln_board_data.c       |  216 ++++
 arch/x86/platform/cln/intel_cln_esram.c            | 1188 ++++++++++++++++++++
 arch/x86/platform/cln/intel_cln_esram.h            |  107 ++
 arch/x86/platform/cln/intel_cln_esram_test.c       |  602 ++++++++++
 arch/x86/platform/cln/intel_cln_esram_test.h       |   43 +
 arch/x86/platform/cln/intel_cln_imr.c              |  716 ++++++++++++
 arch/x86/platform/cln/intel_cln_imr.h              |  148 +++
 arch/x86/platform/cln/intel_cln_imr_kernel.c       |  138 +++
 arch/x86/platform/cln/intel_cln_imr_test.c         |  357 ++++++
 arch/x86/platform/cln/intel_cln_layout_data.c      |  100 ++
 .../x86/platform/cln/intel_cln_plat_clanton_hill.c |  205 ++++
 .../x86/platform/cln/intel_cln_plat_clanton_peak.c |  122 ++
 arch/x86/platform/cln/intel_cln_plat_cross_hill.c  |  348 ++++++
 arch/x86/platform/cln/intel_cln_plat_data.c        |  487 ++++++++
 arch/x86/platform/cln/intel_cln_plat_izmir.c       |  263 +++++
 arch/x86/platform/cln/intel_cln_plat_kips_bay.c    |  183 +++
 arch/x86/platform/cln/intel_cln_sb.c               |  263 +++++
 arch/x86/platform/cln/intel_cln_smep_test.c        |  290 +++++
 drivers/platform/x86/Kconfig                       |   70 ++
 drivers/platform/x86/Makefile                      |    4 +
 drivers/platform/x86/intel_cln_ecc_scrub.c         |  766 +++++++++++++
 drivers/platform/x86/intel_cln_thermal.c           |  360 ++++++
 include/linux/intel_cln_sb.h                       |   90 ++
 include/linux/platform_data/clanton.h              |   58 +
 include/linux/platform_data/st_accel_i2c.h         |   32 +
 27 files changed, 7173 insertions(+), 0 deletions(-)
 create mode 100644 arch/x86/platform/cln/Makefile
 create mode 100644 arch/x86/platform/cln/intel_cln_board_data.c
 create mode 100644 arch/x86/platform/cln/intel_cln_esram.c
 create mode 100644 arch/x86/platform/cln/intel_cln_esram.h
 create mode 100644 arch/x86/platform/cln/intel_cln_esram_test.c
 create mode 100644 arch/x86/platform/cln/intel_cln_esram_test.h
 create mode 100644 arch/x86/platform/cln/intel_cln_imr.c
 create mode 100644 arch/x86/platform/cln/intel_cln_imr.h
 create mode 100644 arch/x86/platform/cln/intel_cln_imr_kernel.c
 create mode 100644 arch/x86/platform/cln/intel_cln_imr_test.c
 create mode 100644 arch/x86/platform/cln/intel_cln_layout_data.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_cross_hill.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_data.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_izmir.c
 create mode 100644 arch/x86/platform/cln/intel_cln_plat_kips_bay.c
 create mode 100644 arch/x86/platform/cln/intel_cln_sb.c
 create mode 100644 arch/x86/platform/cln/intel_cln_smep_test.c
 create mode 100644 drivers/platform/x86/intel_cln_ecc_scrub.c
 create mode 100644 drivers/platform/x86/intel_cln_thermal.c
 create mode 100644 include/linux/intel_cln_sb.h
 create mode 100644 include/linux/platform_data/clanton.h
 create mode 100644 include/linux/platform_data/st_accel_i2c.h

diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index 8d87439..9892ddb 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -1,6 +1,7 @@
 # Platform specific code goes here
 obj-y	+= ce4100/
 obj-y	+= efi/
+obj-y	+= cln/
 obj-y	+= geode/
 obj-y	+= iris/
 obj-y	+= mrst/
diff --git a/arch/x86/platform/cln/Makefile b/arch/x86/platform/cln/Makefile
new file mode 100644
index 0000000..a60e30d
--- /dev/null
+++ b/arch/x86/platform/cln/Makefile
@@ -0,0 +1,16 @@
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_board_data.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_layout_data.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_data.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_clanton_hill.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_clanton_peak.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_cross_hill.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_kips_bay.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_plat_izmir.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_sb.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr_kernel.o
+obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram.o
+obj-$(CONFIG_INTEL_CLN_SOC)	+= intel_cln_imr_test.o
+obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_esram_test.o
+#obj-$(CONFIG_INTEL_CLN_ESRAM)	+= intel_cln_smep_test.o
+
diff --git a/arch/x86/platform/cln/intel_cln_board_data.c b/arch/x86/platform/cln/intel_cln_board_data.c
new file mode 100644
index 0000000..180ec5e
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_board_data.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data accessor layer
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define DRIVER_NAME				"board_data"
+#define PFX					"MFH: "
+#define SPIFLASH_BASEADDR			0xFFF00000
+#define MFH_OFFSET				0x00008000
+#define PLATFORM_DATA_OFFSET			0x00010000
+#define MTD_PART_OFFSET				0x00050000
+#define MTD_PART_LEN				0x00040000
+#define MFH_PADDING				0x1E8
+#define MFH_MAGIC				0x5F4D4648
+#define FLASH_SIZE				0x00400000
+
+/* MFH types supported @ version #1 */
+#define MFH_ITEM_FW_STAGE1			0x00000000
+#define MFH_ITEM_FW_STAGE1_SIGNED		0x00000001
+#define MFH_ITEM_FW_STAGE2			0x00000003
+#define MFH_ITEM_FW_STAGE2_SIGNED		0x00000004
+#define MFH_ITEM_FW_STAGE2_CONFIG		0x00000005
+#define MFH_ITEM_FW_STAGE2_CONFIG_SIGNED	0x00000006
+#define MFH_ITEM_FW_PARAMS			0x00000007
+#define MFH_ITEM_FW_RECOVERY			0x00000008
+#define MFH_ITEM_FW_RECOVERY_SIGNED		0x00000009
+#define MFH_ITEM_BOOTLOADER			0x0000000B
+#define MFH_ITEM_BOOTLOADER_SIGNED		0x0000000C
+#define MFH_ITEM_BOOTLOADER_CONFIG		0x0000000D
+#define MFH_ITEM_BOOTLOADER_CONFIG_SIGNED	0x0000000E
+#define MFH_ITEM_KERNEL				0x00000010
+#define MFH_ITEM_KERNEL_SIGNED			0x00000011
+#define MFH_ITEM_RAMDISK			0x00000012
+#define MFH_ITEM_RAMDISK_SIGNED			0x00000013
+#define MFH_ITEM_LOADABLE_PROGRAM		0x00000015
+#define MFH_ITEM_LOADABLE_PROGRAM_SIGNED	0x00000016
+#define MFH_ITEM_BUILD_INFO			0x00000018
+#define MFH_ITEM_VERSION			0x00000019
+
+struct intel_cln_mfh {
+	u32	id;
+	u32	ver;
+	u32	flags;
+	u32	next_block;
+	u32	item_count;
+	u32	boot_priority_list;
+	u8	padding[MFH_PADDING];
+};
+
+struct intel_cln_mfh_item {
+	u32	type;
+	u32	addr;
+	u32	len;
+	u32	res0;
+};
+
+static struct resource conf_res __initdata = {
+	.flags		= IORESOURCE_MEM,
+	.start		= 0,
+	.end		= 0,
+};
+
+static struct resource plat_res __initdata = {
+	.flags		= IORESOURCE_MEM,
+	.start		= 0,
+	.end		= 0,
+};
+
+static struct resource mtd_res __initdata = {
+	.flags		= IORESOURCE_MEM,
+	.start		= SPIFLASH_BASEADDR + MTD_PART_OFFSET,
+	.end		= SPIFLASH_BASEADDR + MTD_PART_OFFSET + MTD_PART_LEN,
+};
+
+static struct platform_device conf_pdev = {
+	.name		= "cln-layout-conf",
+	.id		= -1,
+	.resource	= &conf_res,
+};
+
+static struct platform_device plat_pdev = {
+	.name		= "cln-plat",
+	.id		= -1,
+	.resource	= &plat_res,
+};
+
+struct kobject * board_data_kobj;
+EXPORT_SYMBOL_GPL(board_data_kobj);
+
+static bool mfh_plat_found = false;
+
+static long unsigned int flash_version_data;
+static ssize_t flash_version_show(struct kobject *kobj,
+                                struct kobj_attribute *attr, char *buf)
+{
+        return snprintf(buf, 12, "%#010lx\n", flash_version_data);
+}
+
+static struct kobj_attribute flash_version_attr =
+        __ATTR(flash_version, 0644, flash_version_show, NULL);
+
+/**
+ * intel_cln_board_data_init
+ *
+ * Module entry point
+ */
+static int __init intel_cln_board_data_init(void)
+{
+	extern struct kobject * firmware_kobj;
+	struct intel_cln_mfh __iomem * mfh;
+	struct intel_cln_mfh_item __iomem * item;
+	struct platform_device * pdev;
+	u32 count;
+	void __iomem * spi_data;
+
+	spi_data = ioremap(SPIFLASH_BASEADDR, FLASH_SIZE);
+	if (!spi_data)
+		return -ENODEV;
+
+	/* get mfh and first item pointer */	
+	mfh = spi_data + MFH_OFFSET;
+	if (mfh->id != MFH_MAGIC){
+		pr_err(PFX"Bad MFH magic want 0x%08x found 0x%08x @ 0x%p\n",
+		MFH_MAGIC, mfh->id, &mfh->id);
+		return -ENODEV;
+	}
+
+	pr_info(PFX"mfh @ 0x%p: id 0x%08lx ver 0x%08lx entries 0x%08lx\n",
+		mfh, (unsigned long)mfh->id, (unsigned long)mfh->ver,
+		(unsigned long)mfh->item_count);
+	item = (struct intel_cln_mfh_item __iomem *)
+		&mfh->padding [sizeof(u32) * mfh->boot_priority_list];
+	
+	/* board_data_kobj subordinate of firmware @ /sys/firmware/board_data */
+	board_data_kobj = kobject_create_and_add("board_data", firmware_kobj);
+	if (!board_data_kobj) {
+		pr_err(PFX"kset create error\n");
+		return -ENODEV;
+	}
+
+	/* Register flash regions as seperate platform devices */
+	for (count = 0; count < mfh->item_count; count++, item++){
+		pdev = NULL;
+
+		switch (item->type){
+		case MFH_ITEM_BUILD_INFO:
+			conf_res.start = item->addr;
+			conf_res.end = item->addr + item->len;
+			pdev = &conf_pdev;
+			break;
+		case MFH_ITEM_VERSION:
+			flash_version_data = item->res0;
+			if(sysfs_create_file(board_data_kobj, 
+					&flash_version_attr.attr)) {
+                		pr_err("failed to create sysfs entry for flash version\n");
+				flash_version_data = 0;
+		        }
+			break;
+		default:
+			break;
+		}
+
+		if (pdev != NULL)
+			platform_device_register(pdev);
+	}
+
+	/* This ought to be encoded in the MFH ! */	
+	if (mfh_plat_found == false){
+		pr_err(PFX"Warning platform data MFH missing - using hardcoded "
+			"offsets\n");
+
+		/* Platform data */
+		plat_res.start = SPIFLASH_BASEADDR + PLATFORM_DATA_OFFSET;
+		count = *(uint32_t*)(spi_data + PLATFORM_DATA_OFFSET + sizeof(uint32_t));
+		plat_res.end = count;
+		platform_device_register(&plat_pdev);
+	}
+
+	iounmap(spi_data);
+	return 0;
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+module_init(intel_cln_board_data_init);
+
diff --git a/arch/x86/platform/cln/intel_cln_esram.c b/arch/x86/platform/cln/intel_cln_esram.c
new file mode 100644
index 0000000..91eaed7
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_esram.c
@@ -0,0 +1,1188 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A proc interface is provided to allow map of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo ehci on > /proc/driver/esram/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * intel_cln_esram_map_sym(ohci_irq);
+ * intel_cln_esram_map_page(virt_to_page(ohci_irq), "ohci_irq");
+ * Are equivalent - with the exception that map_sym() can detect if a mapping
+ * crosses a page-boundary, whereas map_page just maps one page. Generally use
+ * map_sym() for code and map_page() for data
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * Unmap code is included for reference however the cache coherency of unmap is
+ * not guaranteed so the functionality is not exported by this code
+ * 
+ */
+#include <asm/cacheflush.h>
+#include <asm/desc.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/special_insns.h>
+#include <asm-generic/uaccess.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+
+#include "intel_cln_esram.h"
+
+#define DRIVER_NAME			"intel-cln-esram"
+#define INTEL_CLN_ESRAM_PROCDIR		"driver/esram"
+#define STATS				"stats"
+#define MAPPED				"map"
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+/* Define size of pages, ECC scrub demark etc */
+#define MAX_PAGE_RETRIES		(100)
+#define MS_PER_HOUR			(3600000UL)
+#define ESRAM_PAGE_COUNT		INTEL_CLN_ESRAM_PAGE_COUNT
+#define ESRAM_PAGE_MASK			(0xFFFFF000)
+#define ESRAM_PAGE_SIZE			INTEL_CLN_ESRAM_PAGE_SIZE
+#define ESRAM_TOTAL_SIZE		(ESRAM_PAGE_COUNT * ESRAM_PAGE_SIZE)
+#define ECC_MAX_REFRESH_PERIOD		(48)
+#define ECC_DEFAULT_REFRESH_PERIOD	(24)
+#define ECC_DRAM_READSIZE		(512)		/* bytes per DRAM ECC */
+#define ECC_ESRAM_READSIZE		ESRAM_PAGE_SIZE	/* bytes per SRAM ECC */
+
+/* Register ID */
+#define ESRAM_PGPOOL_REG		(0x80)		/* PGPOOL */
+#define ESRAM_CTRL_REG			(0x81)		/* ESRAMCTRL */
+#define ESRAM_PGBLOCK_REG		(0x82)		/* Global page ctrl */
+#define ESCRM_ECCCERR_REG		(0x83)		/* Correctable ECC */
+#define ESRAM_ECCUCERR_REG		(0x84)		/* Uncorrectable ECC */
+
+/* Reg commands */
+#define ESRAM_CTRL_READ			(0x10)		/* Config reg */
+#define ESRAM_CTRL_WRITE		(0x11)		/* Config reg */
+#define ESRAM_PAGE_READ			(0x12)		/* Page config read */
+#define ESRAM_PAGE_WRITE		(0x13)		/* Page config write */
+
+/* ESRAMPGPOOL reg 0x80 - r/w opcodes 0x10/0x11 */
+#define ESRAM_PGPOOL_FLUSHING(x)	((x>>18)&0x1FF)
+#define ESRAM_PGPOOL_PGBUSY(x)		((x>>9)&0x1FF)
+
+/* ESRAMCTRL reg 0x81 - r/w opcodes 0x10/0x11 */
+#define ESRAM_CTRL_FLUSHPRI(x)		((x>>25)&0x03)	/* DRAM flush priority */
+#define ESRAM_CTRL_SIZE(x)		((x>>16)&0xFF)	/* # of 4k pages */
+#define ESRAM_CTRL_ECCTHRESH(x)		((x>>8)&0xFF)	/* ECC threshold */
+#define ESRAM_CTRL_THRESHMSG_EN		(0x00000080)	/* ECC notification */
+#define ESRAM_CTRL_ISAVAIL		(0x00000010)	/* ESRAM on die ? */
+#define ESRAM_CTRL_BLOCK_MODE		(0x00000008)	/* Block mode enable */
+#define ESRAM_CTRL_GLOBAL_LOCK		(0x00000004)	/* Global lock status */
+#define ESRAM_CTRL_FLUSHDISABLE		(0x00000002)	/* Global flush/dis */
+#define ESRAM_CTRL_SECDEC		(0x00000001)	/* ECC enable bit */
+
+/* PGBLOCK reg 0x82 - opcode 0x10/0x11 */
+#define ESRAM_PGBLOCK_FLUSHEN		(0x80000000)	/* Block flush enable */
+#define ESRAM_PGBLOCK_PGFLUSH		(0x40000000)	/* Flush the block */
+#define ESRAM_PGBLOCK_DISABLE		(0x20000000)	/* Block mode disable */
+#define ESRAM_PGBLOCK_ENABLE		(0x10000000)	/* Block mode enable */
+#define ESRAM_PGBLOCK_LOCK		(0x08000000)	/* Block mode lock en */
+#define ESRAM_PGBLOCK_INIT		(0x04000000)	/* Block init in prog */
+#define ESRAM_PGBLOCK_BUSY		(0x01000000)	/* Block is enabled */
+#define ESRAM_PGBLOCK_SYSADDR(x)	(x&0x000000FF)
+
+/* ESRAMPGCTRL - opcode 0x12/0x13 */
+#define ESRAM_PAGE_FLUSH_PAGE_EN	(0x80000000)	/* S3 autoflush */
+#define ESRAM_PAGE_FLUSH		(0x40000000)	/* Flush page to DRAM */
+#define ESRAM_PAGE_DISABLE		(0x20000000)	/* page disable bit */
+#define ESRAM_PAGE_EN			(0x10000000)	/* Page enable */
+#define ESRAM_PAGE_LOCK			(0x08000000)	/* Page lock en */
+#define ESRAM_PAGE_INITIALISING		(0x04000000)	/* Init in progress */
+#define ESRAM_PAGE_BUSY			(0x01000000)	/* Page busy */
+#define ESRAM_PAGE_MAP_SHIFT		(12)		/* Shift away 12 LSBs */
+
+/* Extra */
+#define ESRAM_MAP_OP			(0x01)
+#define ESRAM_UNMAP_OP			(0x00)
+
+/**
+ * struct esram_refname
+ *
+ * Structure to hold a linked list of names
+ */
+struct esram_refname {
+	char name[KSYM_SYMBOL_LEN];	/* Name of mapping */
+	struct list_head list;
+};
+
+/**
+ * struct esram_page
+ *
+ * Represents an eSRAM page in our linked list
+ */
+struct esram_page {
+
+	struct list_head list;		/* List entry descriptor */
+	struct list_head name_list;	/* Linked list for name references */
+	u32 id;				/* Page ID */
+	u32 phys_addr;			/* Physial address of page */
+	u32 refcount;			/* Reference count */
+	u32 vaddr;			/* Virtual address of page */
+
+};
+
+/**
+ * struct intel_cln_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_esram_dev{
+
+	/* Linux kernel structures */
+	struct list_head page_used;	/* Used pages */
+	struct list_head page_free;	/* Free pages */
+	spinlock_t slock;		/* Spinlock */
+	struct platform_device *pldev;	/* Platform device */
+	struct proc_dir_entry *pdir;	/* Proc directory */
+	struct proc_dir_entry *pmap;	/* /proc/drivers/esram/mapped */
+	struct proc_dir_entry *pstat;	/* /proc/drivers/esram/stats */
+
+	/* Actual data */
+	struct esram_page * pages;
+	u8 cbuf[ESRAM_PAGE_SIZE];
+
+	/* Stats */
+	u32 page_count;			/* As reported by silicon */
+	u32 page_disable_retries;	/* Aggreate count on disable */
+	u32 page_enable_retries;	/* Aggregate spin count page enable */
+	u32 page_free_ct;		/* Free pages for mapping code section */
+};
+
+static struct intel_cln_esram_dev esram_dev;
+
+#ifdef CONFIG_PROC_FS
+
+/* 
+ * Kallsyms does not provide data addresses. To map important structures such as
+ * the idt and gdt, we need to frig the lookup with the below. Other entities
+ * can similarly be added. Note we map a page from the given address - anything
+ * larger will require additional code to handle
+ */
+struct esram_symex {
+	char * name;
+	void * vaddr;
+	u32 size;
+};
+
+static struct esram_symex esram_symex[] = 
+{
+	{
+		.name = "idt_table",
+		.vaddr = &idt_table,
+		.size = ESRAM_PAGE_SIZE,
+	},
+	{
+		.name = "gdt_page",
+		.vaddr = &gdt_page,
+		.size = ESRAM_PAGE_SIZE,
+	},
+};
+
+/**
+ * intel_cln_esram_proc_stat_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates eSRAM state via /proc/driver/esram
+ */
+static int intel_cln_esram_proc_stat_read(char * page, char ** start, off_t off,
+					  int count, int * eof, void * data)
+
+{
+	struct esram_page * epage = NULL;
+	int len = 0;
+	u32 pgpool = 0, ctrl = 0, pgblock = 0;
+	char * enabled = "enabled";
+	char * disabled = "disabled";
+
+	/* Display page-pool relevant data */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGPOOL_REG, &pgpool, 1);
+	len += snprintf(page, count,
+			"esram-pgpool\t\t\t: 0x%08x\n" 
+			"esram-pgpool.free\t\t: %u\n"
+			"esram-pgpool.flushing\t\t: %u\n",
+			pgpool,	ESRAM_PGPOOL_PGBUSY(pgpool)+1,
+			ESRAM_PGPOOL_FLUSHING(pgpool) + 1);
+	
+	/* Display ctrl reg - most of this is of interest */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	len += snprintf(page + len, count - len,
+			"esram-ctrl\t\t\t: 0x%08x\n"
+			"esram-ctrl.ecc\t\t\t: %s\n"
+			"esram-ctrl.ecc-theshold\t\t: %u\n"
+			"esram-ctrl.pages\t\t: %u\n"
+			"esram-ctrl.dram-flush-priorityi\t: %u\n",
+			ctrl, (ctrl & ESRAM_CTRL_SECDEC) ? enabled : disabled,
+			ESRAM_CTRL_ECCTHRESH(ctrl), ESRAM_CTRL_SIZE(ctrl)+1,
+			ESRAM_CTRL_FLUSHPRI(ctrl));
+
+	/* Display block ctrl/stat - we should be !block mode */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &pgblock, 1);
+	len += snprintf(page + len, count - len, "esram-block\t\t\t: 0x%08x\n",
+			pgblock);
+
+	/* Print ECC status regs */
+
+	/* Print per-page info */
+	len += snprintf(page + len, count - len, 
+			"free page\t\t\t: %u\nused page\t\t\t: %u\n"
+			"refresh  \t\t\t: %ums\npage enable retries\t\t: %u\n"
+			"page disable retries\t: %u\n",
+			esram_dev.page_free_ct, 
+			esram_dev.page_count-esram_dev.page_free_ct,
+			0,
+			esram_dev.page_enable_retries,
+			esram_dev.page_disable_retries);
+
+	spin_lock(&esram_dev.slock);
+	if(!list_empty(&esram_dev.page_free)){
+
+		epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+		len += snprintf(page + len, count - len, 
+			"ecc next page \t\t\t: %u\n",epage->id);
+
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	*eof = 1;
+	return len;
+}
+
+/**
+ * intel_cln_esram_proc_map_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ * 
+ * Read back eSRAM mapped entries
+ */
+static int
+intel_cln_esram_proc_map_read(char * page, char ** start, off_t off,
+				  int count, int * eof, void * data)
+
+{
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+	int len = 0;
+
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		/* Print references */
+		list_for_each_entry(refname, &epage->name_list, list){
+			len += snprintf(page + len, count - len,
+				"%s ", refname->name);
+		}
+		/* Print data */
+		len += snprintf(page + len, count - len,
+			"\n\tPage virt 0x%08x phys 0x%08x\n"
+			"\tRefcount %u\n",
+			epage->vaddr, epage->phys_addr,
+			epage->refcount);
+	}
+	spin_unlock(&esram_dev.slock);
+
+	/* Return len indicate eof */
+	*eof = 1;
+	return len;
+}
+
+/**
+ * intel_cln_esram_proc_map_write
+ *
+ * @param file: File pointer
+ * @param buf: Data being sent from user-space
+ * @param count: Number of bytes being sent
+ * @param data: Statically set data in the /proc callback - unused
+ * @return number of bytes successfully written or < 0 to indicate error
+ *
+ * Function allows user-space to switch mappings on/off with a simple
+ * echo idt_table on > /proc/driver/esram/map type command
+ */
+static int
+intel_cln_esram_proc_map_write(struct file *file, const char __user *buf, 
+			       unsigned long count, void *data )
+{
+	ssize_t ret = 0;
+	char * cbuf = NULL;
+	char * sbuf = NULL;
+	unsigned long vaddr = 0, i = 0;
+
+	if(count <= 1){
+		return -EINVAL;
+	}
+
+	/* Get input */
+	sbuf = cbuf = kzalloc(count+1, GFP_KERNEL);
+	if(cbuf == NULL){
+		return -ENOMEM;
+	}
+
+	ret = -EFAULT;	
+	if(copy_from_user(cbuf, buf, count))
+		goto done;
+
+	/* Fixup entity to scrub spaces */
+	while(sbuf < (cbuf + count)){
+		if(*sbuf == ' ' || *sbuf == '\r' || *sbuf =='\n'){
+			*sbuf = 0;
+			break;
+		}
+		sbuf++;
+	}
+
+	/* Check to see if we are being asked to map a non-kallsyms addr */
+	for(i = 0; i < sizeof(esram_symex)/sizeof(struct esram_symex); i++){
+		if(strcmp(cbuf, esram_symex[i].name) == 0){
+			ret = intel_cln_esram_map_range(
+				esram_symex[i].vaddr,
+				esram_symex[i].size,
+				esram_symex[i].name);
+			goto done;
+		}
+	}
+
+	/* This path relies on kallsyms to provide name/address data */
+	vaddr = kallsyms_lookup_name(cbuf);
+	if(vaddr == 0)
+		goto done;
+
+	ret = intel_cln_esram_map_symbol((void*)vaddr);
+done:
+	if(ret == 0)
+		ret = (ssize_t)count;
+	kfree(cbuf);
+	return ret;
+}
+
+/**
+ * intel_cln_esram_add_procfs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Adds entries to procfs
+ */
+static int intel_cln_esram_proc_add(void)
+{
+	esram_dev.pdir = proc_mkdir(INTEL_CLN_ESRAM_PROCDIR, NULL);
+	if(esram_dev.pdir == NULL){
+		return -ENOMEM;
+	}
+
+	esram_dev.pstat = create_proc_read_entry(STATS, 0, esram_dev.pdir,
+						 intel_cln_esram_proc_stat_read,
+						 NULL);
+	if(esram_dev.pstat == NULL){
+		return -EIO;
+	}
+
+	esram_dev.pmap = create_proc_entry(MAPPED, 0, esram_dev.pdir);
+	if(esram_dev.pmap == NULL){
+		return -EIO;
+	}
+	esram_dev.pmap->read_proc = intel_cln_esram_proc_map_read;
+	esram_dev.pmap->write_proc = intel_cln_esram_proc_map_write;
+	esram_dev.pmap->data = NULL;
+
+	return 0;
+}
+
+/**
+ * intel_cln_esram_proc_remove
+ *
+ * @return nothing
+ *
+ * Removes /proc entires
+ */
+static void intel_cln_esram_proc_remove(void)
+{
+	remove_proc_entry(MAPPED, esram_dev.pmap);
+	remove_proc_entry(STATS, esram_dev.pstat);
+	remove_proc_entry(INTEL_CLN_ESRAM_PROCDIR, NULL);
+}
+
+#else
+
+static int intel_cln_esram_proc_add(void){ return 0; }
+static void intel_cln_esram_proc_remove(void){ return; }
+
+#endif /* CONFIG_PROC_FS */
+
+/******************************************************************************
+ *                                eSRAM Core
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_page_busy
+ *
+ * @param epage: Pointer to the page descriptor
+ * @return boolean indicating whether or not a page is enabled
+ */
+static int intel_cln_esram_page_busy(struct esram_page * epage, u8 lock)
+{
+	u32 reg = 0;
+
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, lock);
+	return (reg&(ESRAM_PAGE_BUSY | ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE));
+}
+
+/**
+ * intel_cln_esram_fault
+ *
+ * Dump eSRAM registers and kernel panic
+ * Nothing else to do at this point
+ */
+void intel_cln_esram_fault(struct esram_page * epage, u32 lineno)
+{
+	u32 reg = 0, next = 0, prev = 0, prev_reg = 0;
+	u32 next_reg = 0, block = 0, ctrl = 0;
+
+	pr_err("eSRAM fault @ %s:%d\n", __FILE__, lineno);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, epage->id, &reg, 1);
+	pr_err("read page %d state 0x%08x\n", epage->id, reg);
+	if(epage->id == 0){
+		next = 1; prev = 127;
+	}else if(epage->id == 127){
+		next = 0; prev = 126;
+	}else{
+		next = epage->id+1;
+		prev = epage->id-1;
+	}
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, next, &next_reg, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, prev, &prev_reg, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	pr_err("eSRAM CTRL 0x%08x block 0x%08x\n", ctrl, block);
+	pr_err("Prev page %d state 0x%08x Next page %d state 0x%08x\n"
+		, next, next_reg, prev, prev_reg);
+	BUG();
+}
+
+
+/**
+ * intel_cln_esram_page_enable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ * @param lock: Indicates whether to attain sb spinlock or not
+ * 
+ * Enable an eSRAM page spinning for page to become ready.
+ */
+static void intel_cln_esram_page_enable(struct esram_page *epage, u8 lock)
+{
+	u32 ret = 0;
+
+	/* Fault if we try to enable a disabled page */
+	if(intel_cln_esram_page_busy(epage, lock)){
+		intel_cln_esram_fault(epage, __LINE__);
+	}
+
+	/* Program page mapping */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id, 
+		ESRAM_PAGE_FLUSH_PAGE_EN | ESRAM_PAGE_EN | 
+			(epage->phys_addr>>ESRAM_PAGE_MAP_SHIFT), lock);
+	do {
+		/* Poll until page busy bit becomes true */
+		ret = intel_cln_esram_page_busy(epage, lock);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret == 0)){
+			esram_dev.page_enable_retries++;
+		}
+		
+	}while(ret == 0);
+}
+
+/**
+ * intel_cln_esram_page_disable_sync
+ *
+ * @param epage: pointer to eSRAM page descriptor
+ *
+ * This function spins waiting for disable bit to clear, useful right after a
+ * disable/disable-flush command. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_cln_esram_page_disable_sync(struct esram_page * epage)
+{
+	u32 ret = 0, retries = 0;
+	do {
+		/* Poll for busy bit clear */
+		ret = intel_cln_esram_page_busy(epage, 1);
+
+		/* This branch should rarely if ever be true */
+		if(unlikely(ret)){
+			esram_dev.page_disable_retries++;
+			retries++;
+		}
+
+		if(retries == MAX_PAGE_RETRIES){
+			intel_cln_esram_fault(epage, __LINE__);
+		}
+	}while(ret);
+}
+
+/**
+ * intel_cln_esram_page_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page no flush. Interrupts are enabled here, sleeping is OK
+ */
+static void intel_cln_esram_page_disable(struct esram_page *epage)
+{
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_DISABLE, 1);
+	intel_cln_esram_page_disable_sync(epage);	
+}
+
+/**
+ * intel_cln_esram_page_flush_disable
+ *
+ * @param epage: struct esram_page carries data to program to register
+ *
+ * Disable the eSRAM page - with flush. Note the architecture will block access
+ * to the overlayed region until the flush has completed => irqs may be switched
+ * on during this operation.
+ */
+static void intel_cln_esram_page_flush_disable(struct esram_page *epage)
+{
+	
+
+	/* Do flush */
+	sb_write(SB_ID_ESRAM, ESRAM_PAGE_WRITE, epage->id,
+		ESRAM_PAGE_FLUSH | ESRAM_PAGE_DISABLE, 1);
+
+	intel_cln_esram_page_disable_sync(epage);	
+}
+
+#if 0
+/**
+ * intel_cln_esram_flush_disable_all
+ *
+ * Flushes and disables all enabled eSRAM pages
+ */
+static void intel_cln_esram_page_flush_disable_all(void)
+{
+	struct esram_page * epage = NULL;
+	
+	spin_lock(&esram_dev.slock);
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		intel_cln_esram_page_flush_disable(epage);
+	}
+	spin_unlock(&esram_dev.slock);
+}
+#endif
+
+/**
+ * intel_cln_esram_page_populate_atomic
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 placeholder, later versions may return error
+ *
+ * Function takes the mappings given in epage and uses the values to populate
+ * an eSRAM page. The copy/enable/copy routine must be done atomically, since we
+ * may be doing a memcpy() of an ISR for example.
+ * For this reason we wrapper this entire call into a callback provided by 
+ * side-band, which does a spin_lock_irqsave calls this function and then does
+ * a spin_lock_irqrestore - thus guaranteeing atomicity of the below code and
+ * respect for the locking strategy of the side-band driver
+  */
+static int intel_cln_esram_page_populate_atomic(struct esram_page * epage)
+{
+	unsigned long crz;
+
+	/* Copy away */	
+	memcpy(&esram_dev.cbuf, (void*)epage->vaddr, ESRAM_PAGE_SIZE);
+
+	/* If CR0.WP is true - flip it HSD # 4930660 */
+	crz = read_cr0();
+	if (crz & X86_CR0_WP){
+		write_cr0(crz & (~X86_CR0_WP));
+	}
+
+	/* Disable NMI */
+	outb(0x80, 0x70);
+	
+	/*  Enable page mapping */
+	intel_cln_esram_page_enable(epage, 0);
+	
+	/* Copy back - populating memory overlay */
+	memcpy((void*)epage->vaddr, &esram_dev.cbuf,  ESRAM_PAGE_SIZE);
+
+	/* Re-enable NMI */
+	outb(0x00, 0x70);
+
+	/* Restore CR0.WP if appropriate HSD # 4930660 */
+	if (crz & X86_CR0_WP){
+		write_cr0(crz);
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_esram_page_populate
+ *
+ * @param epage: Pointer to eSRAM page desciptor.
+ * @return 0 on success < 0 on failure
+ *
+ * Populates the page. set_memory_rw/set_memory_ro require local irqs enabled.
+ * intel_cln_esram_page_populate_atomic - needs irqs switched off since memory
+ * can be inconsistent during the populate operation. Depopulate operations are
+ * architecturally guaranteed
+ */
+static int intel_cln_esram_page_populate(struct esram_page * epage)
+{
+	int flip_rw = 0, level = 0, ret = 0;
+	pte_t * pte = epage != NULL ? lookup_address(epage->vaddr, &level):NULL;
+
+	if(unlikely(pte == NULL)){
+		return -EINVAL;
+	}
+
+	/* Determine if we need to set writable */
+	flip_rw = !(pte_write(*pte));
+	
+	/* Ensure memory is r/w - do so before spin_lock_irqsave */
+	if(flip_rw){
+		ret = set_memory_rw(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_rw = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	/* Force ECC update @ disable only */
+	intel_cln_esram_page_enable(epage, 1);
+	intel_cln_esram_page_disable(epage);
+
+	/* Enable and populate eSRAM page using callback in sb with irqs off */
+	ret |= intel_cln_sb_runfn_lock(
+		(int (*)(void*))intel_cln_esram_page_populate_atomic,(void*)epage);
+
+	/* If we set memory writable - restore previous state */
+	if(flip_rw){
+		ret |= set_memory_ro(epage->vaddr, 1);
+		if (ret != 0){
+			pr_err("%s error during set_memory_ro = %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+/**
+ * intel_cln_esram_page_addref
+ *
+ * @param epage: eSRAM page descriptor
+ * @param name: Name of reference to add
+ * @return zero on success negative on error
+ *
+ */
+static int intel_cln_esram_page_addref(struct esram_page * epage, char * name)
+{
+	struct esram_refname * refname = NULL;
+	if(unlikely(epage == NULL || name == NULL)){
+		return -EINVAL;
+	}
+
+	refname = kzalloc(sizeof(struct esram_refname), GFP_KERNEL);
+	if(unlikely(refname == NULL)){
+		return -ENOMEM;
+	}
+		
+	/* Add to list */
+	strncpy(refname->name, name, sizeof(refname->name));
+	list_add(&refname->list, &epage->name_list);
+
+	/* Bump reference count */
+	epage->refcount++;
+	return 0;
+}
+
+
+/**
+ * __intel_cln_esram_map_page
+ *
+ * @param page: Page to map
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Overlay a vritual address rangne eeds to be aligned to a 4k address.
+ * Since multiple items can live in a 4k range, it is possible when calling
+ * into map_page() that a previous mapping will have already covered some or all
+ * of the mapping we want. This is not an error case, if the map function finds
+ * it is being asked to map a 4k range already mapped it returns 0, to indicate
+ * the mapping has suceeded i.e. it's already been mapped. This is logical if
+ * you think about it. In contrast being asked to unmap a region not mapped is
+ * clearly an error...
+ *
+ */
+static int __intel_cln_esram_map_page(u32 vaddr, char * name)
+{
+	int ret = 0;	
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	if(unlikely(name == NULL)){
+		return -EINVAL;
+	}
+
+	if(unlikely(esram_dev.page_free_ct == 0)){
+		return -ENOMEM;
+	}
+
+	/* Verify if we have already mapped */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+
+			/* Page already mapped */
+			list_for_each_entry(refname, &epage->name_list, list){
+				if(strcmp(refname->name, name)==0){
+					/* Page mapped at this name */
+					return -EINVAL;
+				}
+			}
+			/* New symbol in previous mapping */
+			return intel_cln_esram_page_addref(epage, name);
+		}
+	}
+
+	/* Enumerate eSRAM page structure */
+	epage = list_first_entry(&esram_dev.page_free, struct esram_page, list);
+	epage->phys_addr = virt_to_phys((void*)vaddr);
+	epage->vaddr = vaddr;
+	ret = intel_cln_esram_page_addref(epage, name);
+	if(unlikely(ret < 0)){
+		return ret;
+	}
+	
+	/* Populate page */
+	ret = intel_cln_esram_page_populate(epage);
+
+	/* Move to used list */
+	list_move(&epage->list, &esram_dev.page_used);
+	esram_dev.page_free_ct--;
+
+	return ret;
+}
+
+/**
+ * __intel_cln_esram_unmap_page
+ *
+ * @param page: Page to unmap
+ * @param name: Name of the mapping
+ * @return 0 success < 0 failure
+ *
+ * Unmap a previously mapped virutal address range.
+ * Must be 4k aligned
+ *
+ */
+static int __intel_cln_esram_unmap_page(u32 vaddr, char * name)
+{
+	u8 found = 0;
+	struct esram_page * epage = NULL;
+	struct esram_refname * refname = NULL;
+
+	/* Find physical address */
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		if(epage->vaddr == vaddr){
+			found = 1;
+			break;
+		}
+	}
+
+	/* Bail out on error */
+	if(found == 0){
+		pr_err("0x%08x not mapped\n", vaddr);
+		return -EINVAL;
+	}
+
+	/* Determine reference to delete */
+	found = 0;
+	list_for_each_entry(refname, &epage->name_list, list){
+		if(strcmp(refname->name,name)==0){
+			found = 1;
+			break;
+		}
+	}
+	if(unlikely(found == 0)){
+		pr_err("No mapping %s!\n", name);
+		return -EINVAL;
+	}
+
+	/* Remove entry decrement reference count */	
+	list_del(&refname->list);
+	kfree(refname);
+	if(--epage->refcount > 0){
+		return 0;
+	}
+
+	/* Flush and disable page */
+	intel_cln_esram_page_flush_disable(epage);
+
+	/* Move to free list tail - scrub entries come from head */
+	list_move_tail(&epage->list, &esram_dev.page_free);
+	esram_dev.page_free_ct++;
+
+	return 0;
+}
+
+/**
+ *
+ * __intel_cln_esram_page_op
+ *
+ * @param vaddr: Virtual address of symbol
+ * @param size: Size/length of symbol
+ * @param name: Name of mapping
+ * @param map: Boolean indicates whether to map or unmap the page
+ * @return 0 success < 0 failure
+ *
+ * This function maps/unmaps a pages/pages given at the given vaddr. If
+ * the extent of the symbol @ vaddr crosses a page boundary, then we map
+ * multiple pages. Other stuff inside the page, gets a performance boost 'for
+ * free'. Any other data in the page that crosses the physical page boundary
+ * will be partially mapped.
+ */
+static int __intel_cln_esram_page_op(u32 vaddr, u32 size, char *name, u8 map)
+{
+	unsigned long offset = 0, page_offset = 0;
+	u32  pages = size/ESRAM_PAGE_SIZE + ((size%ESRAM_PAGE_SIZE) ? 1 : 0);
+	int ret = 0;
+
+	/* Compare required pages to available pages */
+	if(map == ESRAM_MAP_OP){
+		if(pages > esram_dev.page_free_ct)
+			return -ENOMEM;
+	}else{
+		if(pages > esram_dev.page_count - esram_dev.page_free_ct)
+			return -ENOMEM;
+	}
+
+	/* Align to 4k and iterate the mappings */	
+	vaddr = vaddr&ESRAM_PAGE_MASK;
+	while(size > 0){
+
+		/* Map the page */
+		spin_lock(&esram_dev.slock);
+		if(map == ESRAM_MAP_OP){
+			ret = __intel_cln_esram_map_page(vaddr, name);
+							 
+		}else{
+			ret = __intel_cln_esram_unmap_page(vaddr, name);
+		}
+		spin_unlock(&esram_dev.slock);
+		if(unlikely(ret != 0)){
+			break;
+		}
+
+		/* Calc appropriate offsets */
+		page_offset = offset_in_page(vaddr);
+		if(page_offset + size > ESRAM_PAGE_SIZE){
+
+			offset = ESRAM_PAGE_SIZE - page_offset;
+			size -= offset;
+			vaddr += ESRAM_PAGE_SIZE; 
+
+		}else{
+			size = 0;
+		}
+	}
+
+	return ret;
+}
+
+/******************************************************************************
+ *                                 eSRAM API
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname)
+{
+	if(size == 0 || mapname == NULL || vaddr == NULL){
+		return -EINVAL;
+	}
+	return __intel_cln_esram_page_op((u32)vaddr, size, mapname, ESRAM_MAP_OP);
+}
+EXPORT_SYMBOL(intel_cln_esram_map_range);
+
+/**
+ * intel_cln_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_cln_esram_map_range()
+ */
+int intel_cln_esram_map_symbol(void * vaddr)
+{
+	long unsigned int size = 0, offset = 0;
+	char symname[KSYM_SYMBOL_LEN];
+	
+	kallsyms_lookup_size_offset((long unsigned int)vaddr, &size, &offset);
+	if(size == 0){
+		return -EINVAL;
+	}
+	sprint_symbol(symname, (u32)vaddr);
+
+	return __intel_cln_esram_page_op((u32)vaddr, size, symname, 1);
+}
+EXPORT_SYMBOL(intel_cln_esram_map_symbol);
+
+/******************************************************************************
+ *                        Module/PowerManagement hooks 
+ ******************************************************************************/
+
+/**
+ * intel_cln_esram_suspend
+ *
+ * @param pdev: Platform device structure (unused)
+ * @param pm: Power managment descriptor
+ * @return 0 success < 0 failure
+ *
+ * For each enabled page - flush to DRAM and disable eSRAM page.
+ * For each 4k region the architecture guarantees atomicity of flush/disable.
+ * Hence any memory transactions to the affected region will stall until
+ * flush/disable completes - hence interrupts are left on.
+ */
+static int intel_cln_esram_suspend(struct device * pdev)
+{
+	/* Flush and disable of eSRAM pages is carried out automatically */
+	return 0;
+}
+
+/**
+ * intel_cln_esram_resume
+ *
+ * @param pm: Power management descriptor
+ * @return 0 success < 0 failure
+ *
+ * Runs after resume_noirq. Switches pages back to ro, if appropriate. We do
+ * this here since interrupts will be on, as required by the function
+ * set_memory_ro. If it were possible to set memory ro in resume_noirq we would
+ * do it there instead
+ */
+static int intel_cln_esram_resume(struct device * pdev)
+{
+	struct esram_page * epage = NULL;
+	int ret = 0;
+
+	list_for_each_entry(epage, &esram_dev.page_used, list){
+		ret |= intel_cln_esram_page_populate(epage);
+	}
+	
+	return ret;
+}
+
+
+/**
+ * intel_cln_esram_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_esram_probe(struct platform_device * pdev)
+{
+	int ret = 0;
+	u32 block = 0, ctrl = 0, i = 0, pgstat = 0;
+
+	memset(&esram_dev, 0x00, sizeof(esram_dev));
+	INIT_LIST_HEAD(&esram_dev.page_used);
+	INIT_LIST_HEAD(&esram_dev.page_free);
+	spin_lock_init(&esram_dev.slock);
+	esram_dev.page_free_ct = 0;
+	
+	/* Ensure block mode disabled */
+	block = ESRAM_PGBLOCK_DISABLE;
+	sb_write(SB_ID_ESRAM, ESRAM_CTRL_WRITE, ESRAM_PGBLOCK_REG, block, 1);
+
+	/* Get state */
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_CTRL_REG, &ctrl, 1);
+	sb_read(SB_ID_ESRAM, ESRAM_CTRL_READ, ESRAM_PGBLOCK_REG, &block, 1);
+
+	/* Verify state is good to go */
+	if (ctrl & ESRAM_CTRL_GLOBAL_LOCK){
+		pr_err ("eSRAM global lock @ 0x%08x\n", ctrl);
+		return -ENODEV;
+	}
+
+	if (block & (ESRAM_PGBLOCK_LOCK | ESRAM_PGBLOCK_ENABLE)){
+		pr_err ("eSRAM lock @ 0x%08x\n", block);
+		return -ENODEV;
+	}
+	pr_info("eSRAM CTRL 0x%08x block 0x%08x\n", ctrl, block);
+
+	/* Calculate # of pages silicon supports */
+	esram_dev.page_count = ESRAM_CTRL_SIZE(ctrl) + 1;
+	esram_dev.page_free_ct = esram_dev.page_count;
+	pr_info("eSRAM pages %d\n", esram_dev.page_free_ct);
+
+	if(esram_dev.page_free_ct <= 1){
+		pr_err("Too few pages reported by eSRAM sub-system\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate an appropriate number of pages */
+	esram_dev.pages = kzalloc(esram_dev.page_count *
+		sizeof(struct esram_page), GFP_KERNEL);
+	if (esram_dev.pages == NULL){
+		return -ENOMEM;
+	}
+
+	/* Initialise list of free pages, explicitely disable as we go */
+	for(i = 0; i < esram_dev.page_count; i++){
+		INIT_LIST_HEAD(&esram_dev.pages[i].name_list);
+		esram_dev.pages[i].id = i;
+		
+		/* Read & verify page state */
+		sb_read(SB_ID_ESRAM, ESRAM_PAGE_READ, i, &pgstat, 1);
+		if(pgstat & (ESRAM_PAGE_BUSY | ESRAM_PAGE_LOCK)){
+			pr_err("eSRAM page %d state 0x%08x err\n", i, pgstat);
+			ret = -ENODEV;
+			goto err;
+		}
+
+		list_add(&esram_dev.pages[i].list, &esram_dev.page_free);
+	}
+
+	return intel_cln_esram_proc_add();
+err:
+	kfree(esram_dev.pages);
+	return ret;
+}
+
+/**
+ * intel_cln_esram_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_esram_remove(struct platform_device * pdev)
+{
+	intel_cln_esram_proc_remove();
+	kfree(esram_dev.pages);
+
+	return 0;
+}
+
+/*
+ * Power management operations
+ */
+static const struct dev_pm_ops intel_cln_esram_pm_ops = {
+	.suspend = intel_cln_esram_suspend,
+	.resume = intel_cln_esram_resume,
+};
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_esram_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &intel_cln_esram_pm_ops,
+	},
+	.probe = intel_cln_esram_probe,
+	.remove = intel_cln_esram_remove,
+};
+
+module_platform_driver(intel_cln_esram_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton eSRAM overlay/ECC-scrub driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/arch/x86/platform/cln/intel_cln_esram.h b/arch/x86/platform/cln/intel_cln_esram.h
new file mode 100644
index 0000000..af6156a
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_esram.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton eSRAM overlay driver
+ *
+ * eSRAM is an on-chip fast access SRAM.
+ *
+ * This driver provides the ability to map a kallsyms derived symbol of
+ * arbitrary length or a struct page entitiy.
+ * A proc interface is provided to allow map/unmap of kernel structures, without
+ * having to use the API from your code directly.
+ *
+ * Example:
+ * echo ehci_irq on > /proc/driver/esram/map
+ * echo ehci_irq off > /proc/driver/esram/map
+ *
+ * An API is provided to allow for mapping of a) kernel symbols or b) pages.
+ * eSRAM requires 4k physically aligned addresses to work - so a struct page
+ * fits neatly into this.
+ *
+ * To populte eSRAM we must copy data to a temporary buffer, overlay and
+ * then copy data back to the eSRAM region.
+ * 
+ * When entering S3 - we must save eSRAM state to DRAM, and similarly on restore
+ * to S0 we must repopulate eSRAM
+ * 
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+#ifndef __INTEL_CLN_ESRAM_H__
+#define __INTEL_CLN_ESRAM_H__
+
+#include <linux/module.h>
+
+/* Basic size of an eSRAM page */
+#define	INTEL_CLN_ESRAM_PAGE_SIZE	(0x1000)
+#define INTEL_CLN_ESRAM_PAGE_COUNT	(0x80)
+/**
+ * intel_cln_esram_map_range
+ *
+ * @param vaddr: Virtual address to start mapping (must be 4k aligned)
+ * @param size: Size to map from
+ * @param mapname: Mapping name
+ * @return 0 success < 0 failure
+ *
+ * Map 4k increments at given address to eSRAM.
+ */
+int intel_cln_esram_map_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_cln_esram_unmap_range
+ *
+ * @param vaddr: The virtual address to unmap
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary of esram_map_page
+ */
+int intel_cln_esram_unmap_range(void * vaddr, u32 size, char * mapname);
+
+/**
+ * intel_cln_esram_map_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Maps a series of 4k chunks starting at vaddr&0xFFFFF000. vaddr shall be a
+ * kernel text section symbol (kernel or loaded module)
+ *
+ * We get the size of the symbol from kallsyms. We guarantee to map the entire
+ * size of the symbol - plus whatever padding is necessary to get alignment to
+ * eSRAM_PAGE_SIZE 
+ * Other stuff inside the mapped pages will get a performance boost 'for free'.
+ * If this free boost is not what you want then 
+ *	1. Align to 4k
+ *	2. Pad to 4k
+ *	3. Call intel_cln_esram_map_range()
+ */
+int intel_cln_esram_map_symbol(void * vaddr);
+
+/**
+ * intel_cln_esram_unmap_symbol
+ *
+ * @param vaddr: Virtual address of the symbol
+ * @return 0 success < 0 failure
+ *
+ * Logical corollary to intel_cln_esram_map_symbol
+ * Undoes any mapping of pages starting at sym for sym's size
+ */
+int intel_cln_esram_unmap_symbol(void * vaddr);
+
+#endif /* __INTEL_CLN_ESRAM_H__ */
diff --git a/arch/x86/platform/cln/intel_cln_esram_test.c b/arch/x86/platform/cln/intel_cln_esram_test.c
new file mode 100644
index 0000000..3d0573d
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_esram_test.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_esram_test.c
+ *
+ * Simple test module to provide test cases for ITS integration
+ *
+ */
+#include <linux/cdev.h>
+#include <linux/crc32.h>
+#include <linux/crc32c.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kallsyms.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#include "intel_cln_esram.h"
+#include "intel_cln_esram_test.h"
+
+#define DRIVER_NAME			"intel_cln_esram_test"
+
+/**
+ * struct intel_cln_esram_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_esram_test_dev{
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+	char * pdata;
+	u32 size;
+};
+
+static struct intel_cln_esram_test_dev esram_test_dev;
+static struct class *esram_test_class;
+static DEFINE_MUTEX(esram_test_mutex);
+static int esram_test_major;
+static char * name = "testmap";
+
+/******************************************************************************
+ *                                eSRAM BIST
+ ******************************************************************************/
+
+static int crc_cache = 0;
+
+unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
+{
+	if (first < end)
+		return end - first;
+	else
+		return (ULLONG_MAX - first) + end;	
+}
+
+
+/**
+ * intel_cln_crctest
+ *
+ * Do a CRC32 of the specified region. Return the time taken in jiffies
+ */
+static unsigned long long intel_cln_crctest(char * pdata, u32 crcsize)
+{
+	unsigned long long j1 = 0, j2 = 0;
+	
+	rdtscll(j1);
+
+	/* Flush LMT cache to introduce cache miss to our test */
+	__asm__ __volatile__("wbinvd\n");
+	crc32(0, pdata, crcsize);
+
+	rdtscll(j2);
+
+	return tsc_delta(j1, j2);
+}
+
+#ifdef __DEBUG__
+#define bist_err(x){\
+	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
+	return x;\
+}
+#else
+#define bist_err(x){\
+	return x;\
+}
+#endif
+/**
+ * intel_cln_esram_perpage_overlay
+ *
+ * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
+ */
+int intel_cln_esram_test_perpage_overlay(void)
+{
+
+	int ret = 0;
+	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+
+	/* Basic test of full range of memory */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+
+#if 0
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_pageref_count
+ *
+ * Ensure page reference couting works as expected
+ */
+int intel_cln_esram_test_pagref_count(void)
+{
+	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE;
+	int ret = 0;
+
+	return 0;
+	/* Map a page */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map a second time - and verify mapping fails */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+
+#if 0
+	/* Unmap - OK */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Verify second unmap operation fails */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		bist_err(-EFAULT);
+	}
+#endif	
+	return 0;
+}
+
+extern uint32_t get_crc32table_le(void);
+
+/**
+ * intel_cln_esram_test_contig_perfmetric
+ *
+ * Do a CRC16 for a contigous area of memory
+ * Map contigous area and get a CRC16
+ *
+ * Ensure overlayed data takes less time than regular unoverlayed DRAM
+ */
+int intel_cln_esram_test_contig_perfmetric(void)
+{
+	u32 crcsize = 0x60000;
+	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
+	uint32_t crc32table_le = kallsyms_lookup_name("crc32table_le");
+	int ret = 0;
+
+	if (crc32table_le == 0){
+		pr_err("%s unable to fine symbol crc32table_le\n", __func__);
+		return -ENODEV;
+	}
+
+	/* Get raw data metric */
+	crc_cache = 1;
+	crc32_fullunmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
+
+	/* Map CRC16 symbol (algorithm) + code (data) */
+	ret = intel_cln_esram_map_symbol(crc32_le);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_map_symbol((void*)crc32table_le);
+	if(ret){
+		bist_err(ret);
+	}
+
+	/* Map test data */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	/* Get metric */
+	crc_cache = 1;
+	crc32_fullmap = intel_cln_crctest(esram_test_dev.pdata, crcsize);
+#if 0
+	/* Tidy up */
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_unmap_range(((void*)crc32_table),
+					  sizeof(crc32_table), name);
+	if(ret){
+		bist_err(ret);
+	}
+	ret = intel_cln_esram_unmap_symbol(crc32);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
+	pr_info("%s mapped count %llu unmapped %llu\n",
+		__func__, crc32_fullmap, crc32_fullunmap);
+	return crc32_fullmap < crc32_fullunmap;
+}
+
+/**
+ * intel_cln_esram_test_kernel_codemap
+ *
+ * Maps some kernel code - a data section and then calls the code contained
+ * therein. Proves out the running overlayed eSRAM works
+ */
+int intel_cln_esram_test_kernel_codemap(void)
+{
+#if 0
+	int ret = intel_cln_esram_map_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+	
+	/* run the mapped code */
+	msleep(1);
+
+	/* unmap */	
+	ret = intel_cln_esram_unmap_symbol(msleep);
+	if(ret){
+		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_kernel_datamap
+ *
+ * Tests mapping/unmapping of a kernel data structure
+ */
+int intel_cln_esram_test_kernel_datamap(void)
+{
+#if 0
+	unsigned long jtag = 0;
+	unsigned long ctrl = 0;
+
+	/* Map the interrupt descriptor table */
+	int ret = intel_cln_esram_map_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+	
+	jtag = jiffies;
+	/* Wait for jiffies to tick or timeout to occur (failure) */
+	while(jtag == jiffies){
+		ctrl++;
+	}
+
+	/* unmap */	
+	ret = intel_cln_esram_unmap_range(idt_table, INTEL_CLN_ESRAM_PAGE_SIZE, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_sub_unsub
+ *
+ * Subscribe and unsubscribe 100% of available eSRAM
+ */
+int intel_cln_esram_test_sub_unsub(void)
+{
+	int ret = 0;
+	u32 idx = 0, size = INTEL_CLN_ESRAM_PAGE_SIZE * INTEL_CLN_ESRAM_PAGE_COUNT;
+
+	/* Set a known state */
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		*((u32*)&esram_test_dev.pdata[idx]) = idx;
+	}
+
+	/* Basic test of full range of memory */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+	for(idx = 0; idx < size; idx += sizeof(u32)){
+		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
+			pr_err("Entry %d is 0x%08x require 0x%08x",
+				idx, esram_test_dev.pdata[idx], idx);
+			bist_err(-EIO);
+		}
+	}
+#if 0
+	ret = intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+	if(ret){
+		bist_err(ret);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_esram_test_over_sub
+ *
+ * Test oversubscription of eSRAM
+ */
+int intel_cln_esram_test_over_sub(void)
+{
+	int ret = 0;
+	u32 size = INTEL_CLN_ESRAM_PAGE_SIZE * (INTEL_CLN_ESRAM_PAGE_COUNT + 1);
+
+	/* Over subscribe should fail */
+	ret = intel_cln_esram_map_range(esram_test_dev.pdata, size, name);
+	if(ret == 0){
+		//intel_cln_esram_unmap_range(esram_test_dev.pdata, size, name);
+		bist_err(-EFAULT);
+	}
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long esram_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	cmd -= CLN_ESRAM_IOCTL_BASE;
+	switch (cmd) {
+		case CLN_F_SW_APP_ESRAM_0:
+			/* Per page overlay */
+			ret = intel_cln_esram_test_perpage_overlay();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_1:
+			/* Verify page reference counting */
+			ret = intel_cln_esram_test_pagref_count();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_2:
+			/* Performance metric or overlay contig RAM */
+			ret = intel_cln_esram_test_contig_perfmetric();
+			if (ret == 1)
+				ret = 0;
+			break;
+
+		case CLN_F_SW_APP_ESRAM_3:
+			/* Verify mapping of kernel code section */
+			/* Covered by test #2 */
+			ret = 0; //intel_cln_esram_test_kernel_codemap();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_4:
+			/* Verify mapping of kernel data section (IDT) */
+			/* Covered by test #2 */
+			ret = 0; //intel_cln_esram_test_kernel_datamap();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_5:
+			/* Complete subscribe/unsubscribe eSRAM */
+			ret = intel_cln_esram_test_sub_unsub();
+			break;
+
+		case CLN_F_SW_APP_ESRAM_6:
+			/* Over subscribe eSRAM */
+			ret = intel_cln_esram_test_over_sub();
+			break;
+
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int esram_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
+		mutex_unlock(&esram_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (esram_test_dev.opened) {
+		mutex_unlock(&esram_test_dev.open_lock);
+		mutex_unlock(&esram_test_mutex);
+		return -EINVAL;
+	}
+
+	esram_test_dev.opened++;
+	mutex_unlock(&esram_test_dev.open_lock);
+	mutex_unlock(&esram_test_mutex);
+
+	return 0;
+}
+
+static int esram_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&esram_test_dev.open_lock);
+	esram_test_dev.opened = 0;
+	mutex_unlock(&esram_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations esram_test_file_ops = {
+	.open = esram_test_open,
+	.release = esram_test_release,
+	.unlocked_ioctl = esram_test_ioctl,
+	.llseek = no_llseek,
+};
+
+
+/**
+ * intel_cln_esram_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_esram_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	esram_test_dev.size = INTEL_CLN_ESRAM_PAGE_COUNT * INTEL_CLN_ESRAM_PAGE_SIZE;
+
+	/* Get memory */
+	esram_test_dev.pdata = kzalloc(esram_test_dev.size, GFP_KERNEL);
+	if(unlikely(esram_test_dev.pdata == NULL)){
+		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
+		return -ENOMEM;
+	}
+
+	mutex_init(&esram_test_dev.open_lock);
+	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
+	esram_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(esram_test_class, NULL,
+				 MKDEV(esram_test_major, minor), NULL,
+				 "esramtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		kfree(esram_test_dev.pdata);
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s/%s/%s complete OK !!\n", __FUNCTION__, __DATE__,__TIME__);
+	return 0;
+
+}
+
+/**
+ * intel_cln_esram_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_esram_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
+
+	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
+	cdev_del(&esram_test_dev.cdev);
+	kfree(esram_test_dev.pdata);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_esram_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_esram_test_remove,
+};
+
+/**
+ * intel_cln_esram_init
+ *
+ * @return 0 success < 0 failure
+ *
+ * Module entry point
+ */
+static int __init intel_cln_esram_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	esram_test_class = class_create(THIS_MODULE,"cln_esram_test");
+	if (IS_ERR(esram_test_class)) {
+		retval = PTR_ERR(esram_test_class);
+		printk(KERN_ERR "esram_test: can't register earam_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	esram_test_major = MAJOR(dev);
+
+	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
+	esram_test_dev.pldev = platform_create_bundle(
+		&intel_cln_esram_test_driver, intel_cln_esram_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(esram_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(esram_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(esram_test_class);
+err:
+	return retval;
+}
+
+/**
+ * intel_cln_esram_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_esram_test_exit(void)
+{
+	platform_device_unregister(esram_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_esram_test_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton eSRAM ITS driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_init(intel_cln_esram_test_init);
+module_exit(intel_cln_esram_test_exit);
diff --git a/arch/x86/platform/cln/intel_cln_esram_test.h b/arch/x86/platform/cln/intel_cln_esram_test.h
new file mode 100644
index 0000000..98e4546
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_esram_test.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_esram_test.h
+ *
+ * Define integers for ioctl operation
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
+ */
+
+#ifndef __INTEL_CLN_ESRAM_TEST_H__
+#define __INTEL_CLN_ESRAM_TEST_H__
+
+#define CLN_ESRAM_IOCTL_BASE	255
+#define CLN_F_SW_APP_ESRAM_0	0x00000000
+#define CLN_F_SW_APP_ESRAM_1	0x00000001
+#define CLN_F_SW_APP_ESRAM_2	0x00000002
+#define CLN_F_SW_APP_ESRAM_3	0x00000003
+#define CLN_F_SW_APP_ESRAM_4	0x00000004
+#define CLN_F_SW_APP_ESRAM_5	0x00000005
+#define CLN_F_SW_APP_ESRAM_6	0x00000006
+#define CLN_F_SW_APP_ESRAM_7	0x00000007
+#define CLN_F_SW_APP_ESRAM_8	0x00000008
+
+#endif /* __INTEL_CLN_ESRAM_TEST_H__ */
+
diff --git a/arch/x86/platform/cln/intel_cln_imr.c b/arch/x86/platform/cln/intel_cln_imr.c
new file mode 100644
index 0000000..d955b52
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_imr.c
@@ -0,0 +1,716 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * A total number of 8 IMRs have implemented by Clanton SoC,
+ * Some IMRs might be already occupied by BIOS or Linux during
+ * booting time.
+ *
+ * user can cat /proc/driver/imr/status for current imr usage report.
+ *
+ * To allocate imr, the input memory address format has to match the 1k algined
+ * actual Physical address required by HW.
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, then apply the input access right masks
+ *
+ * The IMR can be freed with the pre-allocated memory addresses.
+ */
+
+#include <asm-generic/uaccess.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/proc_fs.h>
+
+#include "intel_cln_imr.h"
+#include <asm/imr.h>
+
+#define DRIVER_NAME	"intel-cln-imr"
+#define IMR_PROC_DIR	"driver/imr"
+#define IMR_PROC_FILE	"status"
+
+#define IMR_READ_MASK	0x1
+#define IMR_MAX_ID	7
+
+#ifndef phys_to_virt
+#define phys_to_virt __va
+#endif
+
+/* IMR HW register address structre */
+struct cln_imr_reg_t {
+	u8  imr_xl;   /* high address register */
+	u8  imr_xh;   /* low address register */
+	u8  imr_rm;   /* read mask register */
+	u8  imr_wm;   /* write mask register */
+} cln_imr_reg_t;
+
+/**
+ * struct cln_imr_addr_t
+ *
+ * IMR memory address structure
+ */
+struct cln_imr_addr_t {
+	u32 addr_low;      /* low boundary memroy address */
+	u32 addr_high;     /* high boundary memory address */
+	u32 read_mask;     /* read access right mask */
+	u32 write_mask;    /* write access right mask */
+} cln_imr_addr_t;
+
+/**
+ * struct cln_imr_pack
+ *
+ * local IMR pack structure
+ */
+struct cln_imr_pack {
+	bool occupied;       /* IMR occupied */
+	bool locked;         /* IMR lock */
+	struct cln_imr_reg_t reg;   /* predefined imr register address */
+	struct cln_imr_addr_t addr; /* IMR address region structure */
+	unsigned char info[MAX_INFO_SIZE]; /* IMR info */
+} cln_imr_pack;
+
+
+/* Predefined HW register address */
+static struct cln_imr_reg_t imr_reg_value[] = {
+	{ IMR0L, IMR0H, IMR0RM, IMR0WM },
+	{ IMR1L, IMR1H, IMR1RM, IMR1WM },
+	{ IMR2L, IMR2H, IMR2RM, IMR2WM },
+	{ IMR3L, IMR3H, IMR3RM, IMR3WM },
+	{ IMR4L, IMR4H, IMR4RM, IMR4WM },
+	{ IMR5L, IMR5H, IMR5RM, IMR5WM },
+	{ IMR6L, IMR6H, IMR6RM, IMR6WM },
+	{ IMR7L, IMR7H, IMR7RM, IMR7WM }
+};
+
+/* proc directory */
+struct proc_dir_entry *pdir;
+
+/* proc file interface /proc/drivers/imr/stats */
+struct proc_dir_entry *pstat;
+
+/**
+ * module parameter
+ * IMR slot should repersant the available IMR region from
+ * linux boot and BIOS.
+ *
+ * For example: imr_bit_mask = 0x10111001
+ * occupied IMR: 0, 3, 4, 5, 7
+ * un-occupied IMR: 1, 2, 6
+ */
+static int imr_bit_mask = 0xFF;
+module_param(imr_bit_mask, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_bit_mask, "IMR bit mask");
+
+/**
+ * module parameter
+ * if IMR lock is a nozero value, all unlocked
+ * imrs will be locked regardless the usage.
+ */
+static int imr_lock = 1;
+module_param(imr_lock, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(imr_lock, "switch to lock unused IMR");
+
+/* local IMR data structure */
+struct cln_imr_pack local_imr[IMR_MAXID];
+
+/**
+ * intel_cln_imr_read_reg
+ *
+ * @param reg: register address
+ * @return nothing
+ *
+ * return register value from input address.
+ */
+static inline uint32_t intel_cln_imr_read_reg(uint8_t reg)
+{
+	uint32_t temp = 0;
+
+	intel_cln_sb_read_reg(SB_ID_ESRAM, CFG_READ_OPCODE, reg, &temp, 0);
+	return temp;
+}
+
+/**
+ * intel_cln_imr_update_local_data
+ *
+ * @return nothing
+ *
+ * Populate IMR data structure from HW.
+ */
+static inline void intel_cln_imr_update_local_data(void)
+{
+	int i = 0;
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		local_imr[i].addr.addr_low =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
+		local_imr[i].addr.addr_high =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xh);
+		local_imr[i].addr.read_mask =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_rm);
+		local_imr[i].addr.write_mask =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_wm);
+
+		if (local_imr[i].addr.addr_low & IMR_LOCK_BIT)
+			local_imr[i].locked = true;
+
+		if (local_imr[i].addr.read_mask > 0 &&
+			local_imr[i].addr.read_mask < IMR_READ_ENABLE_ALL){
+			local_imr[i].occupied = true;
+		} else {
+			local_imr[i].occupied = false;
+			memcpy(local_imr[i].info, "NOT USED", MAX_INFO_SIZE);
+		}
+	}
+}
+
+/**
+ * prepare_input_addr
+ *
+ * @param addr: input physical memory address
+ * @return formated memory address
+ *
+ * 1. verify input memory address alignment
+ * 2. apply IMR_REG_MASK to match the format required by HW
+ */
+static inline uint32_t prepare_input_addr(uint32_t addr)
+{
+	if (addr & (IMR_MEM_ALIGN - 1))
+		return 0;
+
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * intel_cln_imr_find_free_entry
+ *
+ * @return the next free imr slot
+ */
+int intel_cln_imr_find_free_entry(void)
+{
+	int i = 0;
+
+	intel_cln_imr_update_local_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if ((!local_imr[i].occupied) && (!local_imr[i].locked))
+			return i;
+	}
+
+	pr_err("%s: No more free IMR available.\n", __func__);
+	return -ENOMEM;
+}
+
+
+/**
+ * intel_cln_remove_imr_entry
+ *
+ * @param id: imr slot id
+ * @return nothing
+ *
+ * remove imr slot base on input id
+ */
+void intel_cln_remove_imr_entry(int id)
+{
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, IMR_READ_ENABLE_ALL,
+				0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, IMR_WRITE_ENABLE_ALL,
+				0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, IMR_BASE_ADDR, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, IMR_BASE_ADDR, 0);
+}
+
+/**
+ * intel_cln_imr_add_entry
+ *
+ * @param id: imr slot id
+ * @param hi: hi memory address
+ * @param lo: lo memory address
+ * @param read: read access mask
+ * @param write: write access mask
+ * @return nothing
+ *
+ * Setup an IMR entry
+ */
+static void intel_cln_imr_add_entry(int id, uint32_t hi,
+		uint32_t lo, uint32_t read, uint32_t write, bool lock)
+{
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xl, lo, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_xh, hi, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_rm, read, 0);
+	intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+				imr_reg_value[id].imr_wm, write, 0);
+	if (lock) {
+		lo |= IMR_LOCK_BIT;
+		intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+					imr_reg_value[id].imr_xl, lo, 0);
+	}
+}
+
+/**
+ * intel_cln_imr_alloc
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @param read: IMR read mask value
+ * @param write: IMR write mask value
+ * @return nothing
+ *
+ * setup the next available IMR with customized read and write masks
+ */
+int intel_cln_imr_alloc(uint32_t high, uint32_t low, uint32_t read,
+			uint32_t write, unsigned char *info, bool lock)
+{
+	int id = 0;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	if ((low & IMR_LOCK_BIT) || (read == 0 || write == 0)) {
+		pr_err("%s: Invalid acces mode\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Calculate aligned addresses and validate range */
+	high = prepare_input_addr(high);
+	low = prepare_input_addr(low);
+
+	/* Find a free entry */
+	id = intel_cln_imr_find_free_entry();
+	if (id < 0)
+		return -ENOMEM;
+
+	/* Add entry - locking as necessary */
+	intel_cln_imr_add_entry(id, high, low, (read & IMR_READ_ENABLE_ALL),
+				write, lock);
+
+	/* Name the new entry */
+	memcpy(local_imr[id].info, info, MAX_INFO_SIZE);
+
+	/* Update local data structures */
+	intel_cln_imr_update_local_data();
+
+	DBG("%s: allocate IMR %d %s\n", __func__, id,
+		lock ? "locked" : "unlocked");
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_alloc);
+
+/**
+ * get_phy_addr
+ * @return phy address value
+ *
+ * convert register format to physical address format.
+ */
+static uint32_t get_phy_addr(uint32_t reg_value)
+{
+	reg_value = ((reg_value & IMR_REG_MASK) << 8);
+	return reg_value;
+}
+
+/**
+ * intel_cln_imr_proc_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates IMR state via /proc/driver/imr
+ */
+static int intel_cln_imr_proc_read(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = 0;
+	int i = 0;
+	int size;
+	uint32_t hi_phy_addr, lo_phy_addr;
+
+	/* get the latest imr settings */
+	intel_cln_imr_update_local_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		/* read back the actual  input physical memory address */
+		hi_phy_addr = get_phy_addr(local_imr[i].addr.addr_high);
+		lo_phy_addr = get_phy_addr(local_imr[i].addr.addr_low);
+
+		/* the IMR always protect extra 1k memory size above the input
+		 * high reg value
+		 */
+		size = ((hi_phy_addr - lo_phy_addr) / IMR_MEM_ALIGN) + 1;
+
+		len += snprintf(page+len, count,
+				"imr - id : %d\n"
+				"info     : %s\n"
+				"occupied : %s\n"
+				"locked   : %s\n"
+				"size     : %d kb\n"
+				"hi addr (phy): 0x%08x\n"
+				"lo addr (phy): 0x%08x\n"
+				"hi addr (vir): 0x%08x\n"
+				"lo addr (vir): 0x%08x\n"
+				"read mask  : 0x%08x\n"
+				"write mask : 0x%08x\n\n",
+				i,
+				local_imr[i].info,
+				local_imr[i].occupied ? "yes" : "no",
+				local_imr[i].locked ? "yes" : "no",
+				size,
+				hi_phy_addr,
+				lo_phy_addr,
+				(uint32_t)phys_to_virt(hi_phy_addr),
+				(uint32_t)phys_to_virt(lo_phy_addr),
+				local_imr[i].addr.read_mask,
+				local_imr[i].addr.write_mask);
+	}
+	*eof = 1;
+	return len;
+}
+
+/**
+ * intel_cln_imr_proc_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Function allows user-space to operate IMRs through proc interface
+ * e.g. "echo imr off 7 > /proc/drivers/imr/stats" to switch IMR 7 off
+ * if its unlocked.
+ */
+static int intel_cln_imr_proc_write(struct file *file, const char __user *buf,
+		unsigned long count, void *data)
+{
+	ssize_t ret = 0;
+	int id = 0;
+	char *cbuf = NULL;
+	char *sbuf = NULL;
+	char *cmd_id = NULL;
+	char *cmd = NULL;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	/* Get input */
+	sbuf = cbuf = kzalloc(count+1, GFP_KERNEL);
+	if (cbuf == NULL)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (copy_from_user(cbuf, (char *)buf, count))
+		goto done;
+
+	DBG("%s: input read: %s !\n", __func__, cbuf);
+	/* Parse for format "entity on" "entity off" */
+	while (sbuf < (cbuf + count)) {
+		if (*sbuf == ' ') {
+			*sbuf = 0;
+			sbuf++;
+
+			if (cmd_id && cmd)
+				break;
+			if (cmd == NULL)
+				cmd = sbuf;
+			else
+				cmd_id = sbuf;
+		}
+		sbuf++;
+	}
+
+	ret = -EINVAL;
+	if (cmd == NULL || cmd_id == NULL)
+		goto done;
+
+	if (strstr(cmd, "off"))
+		DBG("try to remove IMR: %s.\n", cmd_id);
+	else
+		goto done;
+
+	id = (int)(cmd_id[0]-'0');
+	if (id < 0 || id > IMR_MAX_ID)
+		goto done;
+
+	/* get latest imr hardware settings */
+	intel_cln_imr_update_local_data();
+
+	if (local_imr[id].locked) {
+		pr_err("%s: IMR locked !\n", __func__);
+		goto done;
+	}
+
+	intel_cln_remove_imr_entry(id);
+	intel_cln_imr_update_local_data();
+
+	ret = 0;
+done:
+	if (ret == 0)
+		ret = (ssize_t)count;
+
+	kfree(cbuf);
+	return ret;
+}
+
+
+/**
+ * intel_cln_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ * @return nothing
+ *
+ * remove the imr based on input memory region
+ */
+int intel_cln_imr_free(uint32_t high, uint32_t low)
+{
+	int i = 0;
+
+	if (low > high) {
+		pr_err("%s: Invalid input address values.\n", __func__);
+		return -EINVAL;
+	}
+
+	high = prepare_input_addr(high);
+	if (!high) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	low = prepare_input_addr(low);
+	if (!low) {
+		pr_err("%s: Invalid input memory address.\n", __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		if (local_imr[i].occupied
+			&& (local_imr[i].addr.addr_low == low)
+			&& (local_imr[i].addr.addr_high == high)
+			&& (!local_imr[i].locked)) {
+				intel_cln_remove_imr_entry(i);
+				intel_cln_imr_update_local_data();
+				return 0;
+			}
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(intel_cln_imr_free);
+
+/**
+ * intel_cln_imr_proc_remove
+ *
+ * @return nothing
+ * Removes /proc entires
+ */
+static void intel_cln_imr_proc_remove(void)
+{
+	remove_proc_entry(IMR_PROC_FILE, pdir);
+	remove_proc_entry(IMR_PROC_DIR, NULL);
+}
+
+/**
+ * intel_cln_imr_proc_add
+ *
+ * @return nothing
+ * add /proc/stat entry
+ */
+static int intel_cln_imr_proc_add(void)
+{
+	pdir = proc_mkdir(IMR_PROC_DIR, NULL);
+	if (pdir == NULL) {
+		pr_err("%s: PROC dir create failed.\n", __func__);
+		return -ENOMEM;
+	}
+
+	pstat = create_proc_entry(IMR_PROC_FILE, 0, pdir);
+	if (pstat == NULL) {
+		pr_err("%s: PROC imr file create failed.\n", __func__);
+		return -EIO;
+	}
+	pstat->read_proc = intel_cln_imr_proc_read;
+	pstat->write_proc = intel_cln_imr_proc_write;
+	pstat->data = NULL;
+
+	return 0;
+}
+
+/**
+ * intel_cln_imr_load_local_data
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * prepare local IMR data structure from input module parameter.
+ */
+static void intel_cln_imr_load_local_data(int mask)
+{
+	int i = 0;
+
+	BUG_ON((mask > 255 || mask < 0));
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].addr.addr_low =
+			intel_cln_imr_read_reg(imr_reg_value[i].imr_xl);
+
+		/* mask bit 1 means imr occupied*/
+		if (((mask>>i) & IMR_READ_MASK) == 0) {
+			if (!(local_imr[i].addr.addr_low & IMR_LOCK_BIT))
+				intel_cln_remove_imr_entry(i);
+		}
+	}
+
+	intel_cln_imr_update_local_data();
+}
+
+/**
+ * intel_cln_imr_init_data
+ *
+ * @return nothing
+ * initialize local_imr data structure
+ */
+static void intel_cln_imr_init_data(void)
+{
+	int i = 0;
+
+	intel_cln_imr_update_local_data();
+
+	for (i = 0; i < IMR_MAXID; i++) {
+		local_imr[i].reg = imr_reg_value[i];
+		memcpy(local_imr[i].info, "System Reserved Region",
+			MAX_INFO_SIZE);
+	}
+}
+
+/**
+ * intel_cln_imr_lockall
+ *
+ * @param mask: module parameter
+ * @return nothing
+ *
+ * lock up all un-locked IMRs
+ */
+int intel_cln_imr_lockall(void)
+{
+	int i = 0;
+	uint32_t temp_addr;
+
+	/* Enumerate IMR data structures */
+	intel_cln_imr_init_data();
+	intel_cln_imr_load_local_data(imr_bit_mask);
+
+	/* Nothing else to do */
+	if (imr_lock == 0)
+		return -EINVAL;
+
+	/* Cycle through IMRs locking whichever are unlocked */
+	for (i = 0; i < IMR_MAXID; i++) {
+
+		temp_addr = local_imr[i].addr.addr_low;
+		if (!(temp_addr & IMR_LOCK_BIT)) {
+
+			DBG("%s: locking IMR %d\n", __func__, i);
+			temp_addr |= IMR_LOCK_BIT;
+			intel_cln_sb_write_reg(SB_ID_ESRAM, CFG_WRITE_OPCODE,
+						local_imr[i].reg.imr_xl,
+						temp_addr, 0);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_lockall);
+
+/**
+ * intel_cln_imr_init
+ *
+ * @return 0 success < 0 failue
+ *
+ * module entry point
+ */
+static int  __init intel_cln_imr_probe(struct platform_device * pdev)
+{
+	int ret;
+
+	/* initialise local imr data structure */
+	intel_cln_imr_init_data();
+
+	ret = intel_cln_imr_proc_add();
+	BUG_ON(ret != 0);
+
+	if(intel_cln_imr_runt_setparams() == 0){
+                intel_cln_imr_lockall();
+        }
+
+	pr_info("IMR setup complete\n");
+
+	return 0;
+}
+
+/**
+ * intel_cln_imr_exit
+ *
+ * @return nothing
+ * Module exit
+ */
+static int intel_cln_imr_remove(struct platform_device * pdev)
+{
+	/* this will disable all the unlocked IMRs */
+	intel_cln_imr_proc_remove();
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_imr_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_cln_imr_probe,
+	.remove = intel_cln_imr_remove,
+};
+
+module_platform_driver(intel_cln_imr_driver);
+
+MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/arch/x86/platform/cln/intel_cln_imr.h b/arch/x86/platform/cln/intel_cln_imr.h
new file mode 100644
index 0000000..8ee2d70
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_imr.h
@@ -0,0 +1,148 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * A total number of 8 IMRs have implemented by Clanton SoC,
+ * some IMRs might be already occupied by BIOS or Linux booting time.
+ *
+ * Input addresses parameter required the actual Physical address.
+ *
+ * The IMR alloc API will locate the next available IMR slot set up
+ * with input memory region, and apply with the default access right
+ * (CPU & CPU_snoop enable).
+ *
+ * The alloc_mask API takes input read & write masks values to set up
+ * IMR with customized access right.
+ *
+ * User can free IMR with pre-alloc specified addresses.
+ */
+
+#ifndef __INTEL_CLN_IMR_H__
+#define __INTEL_CLN_IMR_H__
+
+#include <linux/intel_cln_sb.h>
+#include "asm/io.h"
+
+#define CFG_READ_OPCODE         0x10    /* BUnit Control Read */
+#define CFG_WRITE_OPCODE        0x11    /* BUnit control write */
+
+/* DRAM IMR register addresses */
+#define IMR0L			0x40
+#define IMR0H			0x41
+#define IMR0RM			0x42
+#define IMR0WM			0x43
+#define IMR1L			0x44
+#define IMR1H			0x45
+#define IMR1RM			0x46
+#define IMR1WM			0x47
+#define IMR2L			0x48
+#define IMR2H			0x49
+#define IMR2RM			0x4A
+#define IMR2WM			0x4B
+#define IMR3L			0x4C
+#define IMR3H			0x4D
+#define IMR3RM			0x4E
+#define IMR3WM			0x4F
+#define IMR4L			0x50
+#define IMR4H			0x51
+#define IMR4RM			0x52
+#define IMR4WM			0x53
+#define IMR5L			0x54
+#define IMR5H			0x55
+#define IMR5RM			0x56
+#define IMR5WM			0x57
+#define IMR6L			0x58
+#define IMR6H			0x59
+#define IMR6RM			0x5A
+#define IMR6WM			0x5B
+#define IMR7L			0x5C
+#define IMR7H			0x5D
+#define IMR7RM			0x5E
+#define IMR7WM			0x5F
+
+#define IMR_LOCK_BIT            0x80000000
+#define IMR_WRITE_ENABLE_ALL    0xFFFFFFFF
+#define IMR_READ_ENABLE_ALL     0xBFFFFFFF
+#define IMR_REG_MASK            0xFFFFFC
+
+#define IMR_ESRAM_FLUSH_INIT	0x80000000  /* esram flush */
+#define IMR_SNOOP_ENABLE	0x40000000  /* core snoops */
+#define IMR_PUNIT_ENABLE	0x20000000
+#define IMR_SMM_ENABLE		0x02        /* core SMM access */
+#define IMR_NON_SMM_ENABLE	0x01        /* core non-SMM access */
+#define IMR_BASE_ADDR           0x00
+#define IMR_MEM_ALIGN           0x400
+
+#define MAX_INFO_SIZE           64
+#define IMR_MAXID		8
+
+/* snoop + Non SMM write mask */
+#define IMR_DEFAULT_MASK	(IMR_SNOOP_ENABLE \
+				+ IMR_ESRAM_FLUSH_INIT \
+				+ IMR_NON_SMM_ENABLE)
+
+/* debug printk */
+#ifdef DEBUG
+#define DBG(args...) pr_info(args)
+#else
+#define DBG(args...)
+#endif
+
+extern unsigned long  _text;
+extern unsigned long  __init_begin;
+
+/**
+ * intel_cln_imr_alloc
+ *
+ * @param high: the end of physical memory address
+ * @param low: the start of physical memory address
+ * @param read: IMR read mask value
+ * @param write: IMR write maks value
+ * @param info: imr information
+ * @param lock: imr lock
+ *
+ * Setup imr with customised read/ write masks
+ */
+int intel_cln_imr_alloc(u32 high, u32 low, u32 read, u32 write,
+			unsigned char *info, bool lock);
+
+/**
+ * intel_cln_imr_free
+ *
+ * @param high: high boundary of memory address
+ * @param low: low boundary of memorry address
+ *
+ * remove the imr based on input memory region
+ */
+int intel_cln_imr_free(u32 high, u32 low);
+
+/**
+ * intel_cln_remove_imr_entry
+ *
+ * @param id: internal imr data struct id
+ *
+ * Remove imr based on input imr data structure id
+ */
+void intel_cln_remove_imr_entry(int id);
+
+#endif
diff --git a/arch/x86/platform/cln/intel_cln_imr_kernel.c b/arch/x86/platform/cln/intel_cln_imr_kernel.c
new file mode 100644
index 0000000..e53307e
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_imr_kernel.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR driver
+ *
+ * IMR stand for Insolate Memory Region, supported by Clanton SoC.
+ *
+ * The IMR id 3 is pre-defined as the use for kernel data protection
+ *
+ * The early imr protects entire memory (from the beginning of kernel text
+ * section to the top of memory) during linux boot time. In the linux run
+ * time, the protection need to resize down to memory region that only
+ * contains: kernel text, read only data, and initialized data section.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/clanton.h>
+#include <linux/printk.h>
+#include "intel_cln_imr.h"
+
+/* pre-defined imr id for uncompressed kernel */
+#define IMR_KERNEL_ID	3
+
+/**
+ * addr_hw_ready
+ *
+ * shift input address value to match HW required 1k aligned format
+ */
+static inline uint32_t addr_hw_ready(uint32_t addr)
+{
+	/* memory alignment */
+	addr &= (~((1 << 10) - 1));
+
+	/* prepare input addr in HW required format */
+	addr = (addr >> 8) & IMR_REG_MASK;
+	return addr;
+}
+
+/**
+ * void intel_cln_imr_runt_kerndata_setup
+ *
+ * Setup imr for kernel text, read only data section
+ *
+ * The read only data (rodata) section placed between text and initialized data
+ * section by kernel.
+ */
+static void intel_cln_imr_runt_kerndata_setup(void)
+{
+	uint32_t hi;
+	uint32_t lo;
+
+	hi = (uint32_t)virt_to_phys(&__init_begin);
+	lo = (uint32_t)virt_to_phys(&_text);
+
+	if (intel_cln_imr_alloc((hi - IMR_MEM_ALIGN), lo,
+				IMR_DEFAULT_MASK, IMR_DEFAULT_MASK,
+				"KERNEL RUNTIME DATA", 0)) {
+		pr_err("IMR: Set up runtime kernel data imr faild!\n");
+		return;
+	}
+}
+
+/**
+ * intel_cln_imr_runt_oldkern_teardown
+ *
+ * remove the previous imr protection for uncompressed kernel data
+ *
+ */
+static void intel_cln_imr_runt_oldkern_teardown(void)
+{
+	intel_cln_remove_imr_entry(IMR_KERNEL_ID);
+}
+
+/**
+ * intel_cln_imr_runt_setparams
+ *
+ * set imr range for text, read only, initialised data in linux run time
+ */
+int intel_cln_imr_runt_setparams(void)
+{
+	if (intel_cln_plat_get_id() == CLANTON_PLAT_UNDEFINED)
+		return -ENODEV;
+
+	intel_cln_imr_runt_kerndata_setup();
+
+	/* Remove initial IMR */
+	intel_cln_imr_runt_oldkern_teardown();
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_cln_imr_runt_setparams);
+
+/**
+ * intel_cln_imr_runt_init
+ *
+ * module entry point
+ */
+static int  __init intel_cln_imr_runt_init(void)
+{
+	return 0;
+}
+
+/**
+ * intel_cln_imr_runt_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_imr_runt_exit(void)
+{
+	/* do nothing */
+}
+
+MODULE_DESCRIPTION("Intel Clanton SOC IMR API ");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+
+subsys_initcall(intel_cln_imr_runt_init);
+module_exit(intel_cln_imr_runt_exit);
diff --git a/arch/x86/platform/cln/intel_cln_imr_test.c b/arch/x86/platform/cln/intel_cln_imr_test.c
new file mode 100644
index 0000000..2d98507
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_imr_test.c
@@ -0,0 +1,357 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton IMR Test module
+ *
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include "intel_cln_imr.h"
+
+#define DRIVER_NAME			"intel_cln_imr_test"
+
+/**
+ * XXX intel_cln_sb.h needs to be updated with SB_ID_PUNIT and change
+ * propagated. This is a workaround to make it look less ugly. */
+#define SB_ID_PUNIT			SB_ID_THERMAL
+
+/* Memory-mapped SPI Flash address */
+#define ILB_SPIFLASH_BASEADDR			0xFF800000
+/* PUnit DMA block transfer size, in bytes */
+#define SPI_DMA_BLOCK_SIZE			512
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define IMR_TEST_IOCTL_CODE			0xE1
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_CLN_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_CLN_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
+
+/*****************************************************************************/
+
+/**
+ * struct intel_cln_imr_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_imr_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_cln_imr_test_dev imr_test_dev;
+static struct class *imr_test_class;
+static DEFINE_MUTEX(imr_test_mutex);
+static int imr_test_major;
+
+/* PUnit DMA registers over side-band */
+#define PUNIT_SPI_DMA_COUNT_REG		0x60
+#define PUNIT_SPI_DMA_DEST_REG		0x61
+#define PUNIT_SPI_DMA_SRC_REG		0x62
+
+/**
+ * ilb_spi_dma_read 
+ *
+ * @param src: physical address in Legacy SPI Flash
+ * @param dst: physical address of destination
+ * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
+ *
+ * Read-access iLB SPI via PUnit DMA engine.
+ * 
+ */
+static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
+{
+	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
+		dma_block_count);
+
+	/* Setup source and destination addresses. */
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_SRC_REG, (u32) src, 0);
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_DEST_REG, (u32) dst, 0);
+
+	pr_info("%s: starting transaction\n", __func__);
+
+	/*
+	 * Setup the number of block to be copied over. Transaction will start
+	 * as soon as the register is filled with value.
+	 */
+	intel_cln_sb_write_reg(SB_ID_PUNIT, CFG_WRITE_OPCODE,
+		PUNIT_SPI_DMA_COUNT_REG, dma_block_count, 0);
+
+	/* Poll for completion. */
+	while (dma_block_count > 0) {
+		intel_cln_sb_read_reg(SB_ID_PUNIT, CFG_READ_OPCODE,
+			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count, 0); 
+	}
+
+	pr_info("%s: transaction completed\n", __func__);
+}
+
+/**
+ * punit_dma_sanity_check 
+ *
+ * @return 0 if success, 1 if failure
+ *
+ * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
+ * Flash block. 
+ */
+static int punit_dma_sanity_check(void)
+{
+	int err = 0;
+	u32 *buffer = NULL;
+	u32 buf_ph_addr = 0;
+
+	/* Allocate 512B buffer for 1 SPI Flash block */
+	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
+        if (!buffer) {
+		err = -ENOMEM;
+		goto end;
+	}
+
+	/* DMA first SPI Flash block into buffer */
+	buf_ph_addr = (u32)virt_to_phys(buffer);
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
+
+	kfree(buffer);
+end:
+	return err;
+}
+
+/**
+ * imr_violate_kernel_punit_dma 
+ *
+ * @return always 0
+ *
+ * PUnit-DMA access to the Uncompressed Kernel IMR.
+ * This is based on set_imr_kernel_data() in intel_cln_imr.c. Find the physical
+ * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
+ * 
+ */
+static int imr_violate_kernel_punit_dma(void)
+{
+	extern unsigned long _text;
+	u32 kernel_text = (u32)virt_to_phys(&_text);
+
+	/* We expect this to trigger an IMR violation reset */
+	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
+
+	/*
+	 * If we're still alive, we have a serious bug:
+	 * - we didn't appropriately target the IMR?
+	 * - if we have, weren't we prevented from accessing?
+	 * - if we weren't prevented, it's unlikely we're alive with a dirty
+	 *   text section
+	 */
+	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
+		__func__);
+
+	return 0;
+}
+
+/*
+ * File ops
+ */
+static long imr_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_CLN_SANITY_CHECK_PUNIT_DMA:
+			/* Check PUnit DMA actually works */
+			ret = punit_dma_sanity_check();
+			break;
+		case IOCTL_CLN_IMR_1:
+			/* Kernel IMR violation: PUnit DMA access */
+			ret = imr_violate_kernel_punit_dma();
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int imr_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
+		mutex_unlock(&imr_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (imr_test_dev.opened) {
+		mutex_unlock(&imr_test_dev.open_lock);
+		mutex_unlock(&imr_test_mutex);
+		return -EINVAL;
+	}
+
+	imr_test_dev.opened++;
+	mutex_unlock(&imr_test_dev.open_lock);
+	mutex_unlock(&imr_test_mutex);
+	return 0;
+}
+
+static int imr_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&imr_test_dev.open_lock);
+	imr_test_dev.opened = 0;
+	mutex_unlock(&imr_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations imr_test_file_ops = {
+	.open = imr_test_open,
+	.release = imr_test_release,
+	.unlocked_ioctl = imr_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_cln_imr_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_cln_imr_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&imr_test_dev.open_lock);
+	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
+	imr_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(imr_test_class, NULL,
+				 MKDEV(imr_test_major, minor), NULL,
+				 "imrtest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_cln_imr_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
+
+	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
+	cdev_del(&imr_test_dev.cdev);
+
+	class_destroy(imr_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_imr_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_imr_test_remove,
+};
+
+/**
+ * intel_cln_imr_test_init
+ *
+ * Load module.
+ */
+static int __init intel_cln_imr_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	imr_test_class = class_create(THIS_MODULE,"cln_imr_test");
+	if (IS_ERR(imr_test_class)) {
+		retval = PTR_ERR(imr_test_class);
+		printk(KERN_ERR "imr_test: can't register imr_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	imr_test_major = MAJOR(dev);
+
+	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
+	imr_test_dev.pldev = platform_create_bundle(
+		&intel_cln_imr_test_driver, intel_cln_imr_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(imr_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(imr_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(imr_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_cln_imr_test_exit(void)
+{
+	platform_device_unregister(imr_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_imr_test_driver);
+}
+
+module_init(intel_cln_imr_test_init);
+module_exit(intel_cln_imr_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Clanton IMR test module");
+MODULE_LICENSE("Dual BSD/GPL");
+
diff --git a/arch/x86/platform/cln/intel_cln_layout_data.c b/arch/x86/platform/cln/intel_cln_layout_data.c
new file mode 100644
index 0000000..124bccf
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_layout_data.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define DRIVER_NAME "cln-layout-conf"
+static char __iomem * layout_conf_data;
+static int len;
+
+static ssize_t layout_conf_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	ssize_t plen = len+1;
+	if( plen > PAGE_SIZE )
+		plen = PAGE_SIZE;
+	memcpy(buf, layout_conf_data, plen);
+	return plen;
+}
+
+static struct kobj_attribute layout_conf_attr = 
+	__ATTR(layout_conf, 0644, layout_conf_show, NULL);
+
+static int intel_cln_layout_data_probe(struct platform_device *pdev)
+{
+	extern struct kobject * board_data_kobj;
+	int ret = 0;
+
+	layout_conf_data = ioremap(pdev->resource->start,
+		resource_size(pdev->resource));
+	if (!layout_conf_data)
+		return -ENODEV;
+
+	len = resource_size(pdev->resource);
+	ret = sysfs_create_file(board_data_kobj, &layout_conf_attr.attr);
+	if (ret != 0){
+		pr_err("failed to create sysfs entry for layout config\n");
+		iounmap(layout_conf_data);
+		layout_conf_data = NULL;
+	}
+
+	return ret;
+}
+
+static int intel_cln_layout_data_remove(struct platform_device *pdev)
+{
+	extern struct kobject * board_data_kobj;
+
+	if (layout_conf_data){
+		sysfs_remove_file(board_data_kobj, &layout_conf_attr.attr);
+		iounmap(layout_conf_data);
+		
+	}
+	return 0;
+}
+
+static struct platform_driver cln_layout_data_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_layout_data_probe,
+	.remove		= intel_cln_layout_data_remove,
+};
+
+module_platform_driver(cln_layout_data_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c b/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
new file mode 100644
index 0000000..14a2fda
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_clanton_hill.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-clanton-hill"
+#define GPIO_RESTRICT_NAME "cln-gpio-restrict-nc"
+
+#define CLN_SPI_MAX_CLK_DEFAULT               5000000
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+
+/******************************************************************************
+ *             ST Microelectronics LIS331DLH I2C Device Platform Data
+ ******************************************************************************/
+#include <linux/platform_data/st_accel_i2c.h>
+
+/* GPIO interrupt pins connected to the LIS331DLH */
+#define ST_ACCEL_INT1_GPIO 15
+#define ST_ACCEL_INT2_GPIO 4
+
+static struct st_accel_i2c_platform_data st_accel_i2c_platform_data;
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Hill platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	struct spi_board_info spi_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &cln_ffrd_spi_0_cs_0,
+		},
+	};
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+/**
+ * intel_cln_i2c_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard I2C device(s) present on the Clanton Hill platform
+ */
+static int intel_cln_i2c_add_onboard_devs(void)
+{
+	struct i2c_board_info i2c_onboard_devs[] = {
+		{
+			I2C_BOARD_INFO("intel-cln-max9867", 0x18),
+		},
+		{
+			I2C_BOARD_INFO("lis331dlh", 0x19),
+			.irq = gpio_to_irq(ST_ACCEL_INT1_GPIO),
+			.platform_data  = &st_accel_i2c_platform_data,
+		},
+	};
+	st_accel_i2c_platform_data.irq2 = gpio_to_irq(ST_ACCEL_INT2_GPIO);
+
+	return i2c_register_board_info(0, i2c_onboard_devs,
+			ARRAY_SIZE(i2c_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	struct gpio reserved_gpios[] = {
+		{
+			ST_ACCEL_INT1_GPIO,
+			GPIOF_IN,
+			"st_accel_i2c-int1"
+		},
+		{
+			ST_ACCEL_INT2_GPIO,
+			GPIOF_IN,
+			"st_accel_i2c-int2"
+		},
+	};
+
+	ret = intel_cln_spi_add_onboard_devs();
+	if (ret)
+		return ret;
+
+	ret = intel_cln_i2c_add_onboard_devs();
+	if (ret)
+		return ret;
+
+
+	ret = gpio_request_array(reserved_gpios,
+				 ARRAY_SIZE(reserved_gpios));
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+static int intel_cln_plat_clanton_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_cln_plat_clanton_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_clanton_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_clanton_hill_probe,
+	.remove		= intel_cln_plat_clanton_hill_remove,
+};
+
+module_platform_driver(cln_clanton_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Cross Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c b/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
new file mode 100644
index 0000000..104879e
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_clanton_peak.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-clanton-peak"
+#define GPIO_RESTRICT_NAME "cln-gpio-restrict-nc"
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Clanton Peak platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	/* TODO */
+
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+static int intel_cln_plat_clanton_peak_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = intel_cln_spi_add_onboard_devs();
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_cln_plat_clanton_peak_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver clanton_peak_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_clanton_peak_probe,
+	.remove		= intel_cln_plat_clanton_peak_remove,
+};
+
+module_platform_driver(clanton_peak_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Clanton Peak BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_cross_hill.c b/arch/x86/platform/cln/intel_cln_plat_cross_hill.c
new file mode 100644
index 0000000..b170bd1
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_cross_hill.c
@@ -0,0 +1,348 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-cross-hill"
+#define GPIO_RESTRICT_NAME_NC "cln-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC "cln-gpio-restrict-sc"
+
+#define CLN_SPI_MAX_CLK_DEFAULT		5000000
+
+/*
+ * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
+ */
+#define SPI_BPEAK_RESET_GPIO 4
+#define SPI_BPEAK_ID0_GPIO   3
+#define SPI_BPEAK_ID1_GPIO   2
+#define SPI_BPEAK_ID2_GPIO   15
+#define SPI_BPEAK_ID3_GPIO   14
+
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
+/*
+ * Blackburn Peak SPI daughterboard ID values
+ */
+enum {
+	CLN_SPI_BPEAK_ID_ZB_TI = 0xA,
+	CLN_SPI_BPEAK_ID_ZB_DIGI,
+	CLN_SPI_BPEAK_ID_ZB_INFR_NXP,
+	CLN_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
+	CLN_SPI_BPEAK_ID_ADC_MAXIM,
+	CLN_SPI_BPEAK_ID_NONE
+};
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+#if 0
+/* TODO - not needed until dual-device blackburn peak modules are added */
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_1 = {
+	.gpio_cs = 11,
+};
+#endif
+
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Cross Hill platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	struct spi_board_info spi_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &cln_ffrd_spi_0_cs_0,
+		},
+	};
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_cln_spi_get_bpeak_id
+ *
+ * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
+ * @return 0 on success or standard errnos on failure
+ *
+ * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
+ */
+static int intel_cln_spi_get_bpeak_id(u8 *bpeak_id)
+{
+	int ret = 0;
+	struct gpio spi_bpeak_id_gpios[] = {
+		{
+			SPI_BPEAK_RESET_GPIO,
+			GPIOF_OUT_INIT_HIGH,
+			"spi_bpeak_reset"
+		},
+		{
+			SPI_BPEAK_ID0_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id0"
+		},
+		{
+			SPI_BPEAK_ID1_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id1"
+		},
+		{
+			SPI_BPEAK_ID2_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id2"
+		},
+		{
+			SPI_BPEAK_ID3_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id3"
+		}
+	};
+
+	/*
+	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
+	 * while a RESET GPIO output is asserted (active-low)
+	 */
+	ret = gpio_request_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
+				__func__);
+		return ret;
+	}
+
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
+	*bpeak_id =
+		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
+
+	gpio_free_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+
+	return 0;
+}
+
+/**
+ * intel_cln_spi_add_bpeak_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers SPI device(s) indicated by the ID value obtained from a
+ * Blackburn Peak SPI daughterboard
+ */
+static int intel_cln_spi_add_bpeak_devs(void)
+{
+	u8 spi_bpeak_id = 0;
+	int ret = 0;
+
+	ret = intel_cln_spi_get_bpeak_id(&spi_bpeak_id);
+	if (ret) {
+		pr_err("%s: failed to obtain Blackburn Peak ID\n",
+				__func__);
+		return ret;
+	}
+
+	switch (spi_bpeak_id) {
+
+	case CLN_SPI_BPEAK_ID_NONE:
+		break;
+	case CLN_SPI_BPEAK_ID_ADC_MAXIM:
+		{
+			struct spi_board_info spi_bpeak_devs[] = {
+				{
+				.modalias = "max78m6610_lmu",
+				.max_speed_hz = 2000000,
+				.platform_data = NULL,
+				.mode = SPI_MODE_3,
+				.bus_num = 1,
+				.chip_select = 0,
+				.controller_data = &cln_ffrd_spi_1_cs_0,
+				},
+			};
+
+			return spi_register_board_info(spi_bpeak_devs,
+						ARRAY_SIZE(spi_bpeak_devs));
+		}
+	/* TODO - add other Blackburn Peak variants when details available */
+	default:
+			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
+					__func__, spi_bpeak_id);
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/** intel_cln_spi_devs_addon
+ *
+ * addon spi device when gpio support in place
+ */
+static int intel_cln_spi_devs_addon(void)
+{
+	int ret = 0;
+
+	ret = intel_cln_spi_add_onboard_devs();
+	if (ret)
+		return ret;
+
+	ret = intel_cln_spi_add_bpeak_devs();
+
+	return ret;
+}
+
+/**
+ * intel_cln_gpio_restrict_probe_nc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	int ret;
+	nc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_cln_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_gpio_restrict_probe_sc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	int ret;
+	sc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_cln_spi_devs_addon();
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe_sc,
+};
+
+static int intel_cln_plat_cross_hill_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&gpio_restrict_pdriver_sc);
+}
+
+static int intel_cln_plat_cross_hill_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_cross_hill_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_cross_hill_probe,
+	.remove		= intel_cln_plat_cross_hill_remove,
+};
+
+module_platform_driver(cln_cross_hill_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Cross Hill BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_data.c b/arch/x86/platform/cln/intel_cln_plat_data.c
new file mode 100644
index 0000000..12e6b27
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_data.c
@@ -0,0 +1,487 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <asm/io.h>
+#include <linux/crc32.h>
+#include <linux/crc32c.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/clanton.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define PREFIX		"CLN-PLT: "
+#define DRIVER_NAME 	"cln-plat"
+#define PLAT_MAGIC	0x54414450	/* PDAT */
+#define DESC_LEN	0x0A
+#define MAC_STRLEN	20
+#define MAC_LEN		6
+
+struct cln_plat_dat_hdr {
+	uint32_t magic;
+	uint32_t length;
+	uint32_t crc32;
+};
+
+struct cln_plat_data {
+	uint16_t plat_id;
+	uint16_t length;
+	uint8_t desc[DESC_LEN];
+	uint16_t version;
+};
+
+struct cln_bsp_reg {
+	struct platform_device pdev;
+	cln_plat_id_t id;
+};
+
+static struct cln_bsp_reg bsp_data [] = {
+	{
+		.pdev.name	= "cln-plat-clanton-peak",
+		.pdev.id	= -1,
+		.id		= CLANTON_PEAK,
+	},
+	{
+		.pdev.name	= "cln-plat-kips-bay",
+		.pdev.id	= -1,
+		.id		= KIPS_BAY,
+	},
+	{
+		.pdev.name	= "cln-plat-cross-hill",
+		.pdev.id	= -1,
+		.id		= CROSS_HILL,
+	},
+	{
+		.pdev.name	= "cln-plat-clanton-hill",
+		.pdev.id	= -1,
+		.id		= CLANTON_HILL,
+	},
+	{
+		.pdev.name	= "cln-plat-izmir",
+		.pdev.id	= -1,
+		.id		= IZMIR,
+	},
+
+};
+
+/**
+ * struct cln_plat_data_list
+ *
+ * Structure to hold a linked list of platform data refs
+ */
+struct cln_plat_data_list {
+	char name[DESC_LEN+1];
+	struct cln_plat_data * plat_data;
+	struct kobj_attribute plat_attr;
+	struct list_head list;
+};
+
+static char __iomem * plat_data;
+static char * plat_bin_name = 	"pdat_bin";
+static unsigned int plat_bin_size;
+static struct cln_plat_dat_hdr * plat_hdr;
+static struct list_head entry_list;
+
+/**
+ * intel_cln_plat_sysfs_show_bin
+ *
+ * Generic show routine for any of the sysfs entries of this module
+ */
+static ssize_t intel_cln_plat_sysfs_show_bin(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	ssize_t plen = plat_bin_size;
+	if( plen > PAGE_SIZE )
+		plen = PAGE_SIZE;
+
+	memcpy(buf, plat_data, plen);
+	return plen;
+}
+
+/**
+ * intel_cln_plat_sysfs_show
+ *
+ * Generic show routine for any of the sysfs entries of this module
+ */
+static ssize_t intel_cln_plat_sysfs_show(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
+{
+	unsigned char * data;
+	char fmt[0x20];
+	struct cln_plat_data_list * plat_item_list;
+	ssize_t plen = 0;
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		if ( attr == &plat_item_list->plat_attr ){
+
+			/* Derive length */
+			plen = plat_item_list->plat_data->length;
+			if (unlikely(plen > PAGE_SIZE))
+				plen = PAGE_SIZE;
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Enumrate return */
+			switch (plat_item_list->plat_data->plat_id){
+			case PLAT_DATA_ID:
+			case PLAT_DATA_SN:
+				snprintf(fmt, sizeof(fmt), "0x%%0%dx\n",
+					 plen*2);
+				return sprintf(buf, fmt, *(int16_t*)data);
+			case PLAT_DATA_MAC0:
+			case PLAT_DATA_MAC1:
+				if (unlikely(plen != MAC_LEN)){
+					return sprintf(buf, "invalid mac\n");
+				}
+				return snprintf(buf, MAC_STRLEN,
+					"%02x:%02x:%02x:%02x:%02x:%02x\n",
+					data[0], data[1], data[2], data[3],
+					data[4], data[5]);
+			default:
+				/* Treat as string data */
+				return snprintf(buf, plen, "%s", data);
+			}
+		}
+	}
+	return 0;
+}
+
+/**
+ * intel_cln_plat_cleanup
+ *
+ * Generic cleanup code for the platform data interface
+ *
+ */
+static void intel_cln_plat_cleanup (void)
+{
+	extern struct kobject * board_data_kobj;
+	struct cln_plat_data_list * plat_item_list;
+
+	if (plat_data != NULL){
+		iounmap(plat_data);
+		plat_data = NULL;
+	}
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		sysfs_remove_file(board_data_kobj,
+				  &plat_item_list->plat_attr.attr);
+		kfree(plat_item_list);
+	}
+}
+
+/**
+ * intel_cln_plat_get_desc_len
+ *
+ * @param desc: Pointer to desc string
+ * @return len on success < 0 failure
+ *
+ * Function called to get a bounds checked desc field from platfrom data
+ *
+ */
+static int intel_cln_plat_get_desc_len (char * desc)
+{
+	int len = 0;
+	if (desc == NULL){
+		return -EINVAL;
+	}
+
+	for(; *desc != '\0' && len < DESC_LEN; desc++, len++);
+	return len;
+}
+
+/**
+ * intel_cln_plat_probe
+ *
+ * @param pdev: Pointer to platform device
+ * @return 0 success < 0 failure
+ *
+ * Function called to probe platform device "cln-plat"
+ *
+ */
+static int intel_cln_plat_probe(struct platform_device *pdev)
+{
+	char __iomem * end_addr = NULL;
+	char __iomem * data = NULL;
+	cln_plat_id_t id = CLANTON_PLAT_UNDEFINED;
+	extern struct kobject * board_data_kobj;
+	struct cln_plat_data * plat_item = NULL;
+	struct cln_plat_data_list * plat_item_list = NULL;
+	u32 crc = 0;
+	int ret = 0, i = 0;
+
+	INIT_LIST_HEAD(&entry_list);
+	plat_hdr = ioremap(pdev->resource->start, resource_size(pdev->resource));
+	end_addr = (char*)plat_hdr + resource_size(pdev->resource);
+	plat_data = (char*)plat_hdr;
+	if (!plat_hdr)
+		return -ENODEV;
+
+	/* Verify header magic */
+	if (plat_hdr->magic != 	PLAT_MAGIC){
+		pr_err(PREFIX"Expected magic 0x%08x read 0x%08lx\n",
+			PLAT_MAGIC, (unsigned long)plat_hdr->magic);
+	}
+
+	/* Validate length is sane */
+	if ((char*)plat_hdr + plat_hdr->length > end_addr ||
+		plat_hdr->length < sizeof(struct cln_plat_data)){
+		pr_err(PREFIX"Invalid length 0x%08lx\n",
+			(unsigned long)plat_hdr->length);
+		return -ENODEV;
+	}
+
+	/* Point to real end addr */
+	end_addr = (char*)plat_hdr +
+			sizeof(struct cln_plat_dat_hdr) + plat_hdr->length;
+	plat_bin_size = end_addr - plat_data;
+
+	/* Get pointer to start of data */
+	plat_item = (struct cln_plat_data*)(plat_hdr+1);
+	data = ((char*)(plat_item)+sizeof(struct cln_plat_data));
+
+	/* Validate CRC32 */
+	crc = ~crc32(0xFFFFFFFF, plat_item, plat_hdr->length);
+	if (crc != plat_hdr->crc32){
+		pr_err(PREFIX"CRC 0x%08x header indicates 0x%08x - fatal!\n",
+			crc, plat_hdr->crc32);
+		return -EFAULT;
+	}
+
+	/* /sys/firmware/board_data/plat_bin - dump entire platform binary */
+	plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
+					 GFP_KERNEL);
+	if (unlikely(plat_item_list == NULL)) {
+		pr_err("kzalloc fail !\n");
+		intel_cln_plat_cleanup();
+		return -ENOMEM;
+	}
+	sysfs_attr_init(&plat_item_list->plat_attr.attr);
+	plat_item_list->plat_attr.attr.name = plat_bin_name;
+	plat_item_list->plat_attr.attr.mode = 0644;
+	plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show_bin;
+
+	ret = sysfs_create_file(board_data_kobj,
+				&plat_item_list->plat_attr.attr);
+	if (unlikely(ret != 0)){
+		intel_cln_plat_cleanup();
+		pr_err("failed to create sysfs entry\n");
+		return ret;
+	}
+
+	/* Add to list */
+	list_add(&plat_item_list->list, &entry_list);
+
+	/* Iterate through each entry - add sysfs entry as appropriate */
+	while ( (char*)plat_item < end_addr){
+	
+		/* Bounds check */
+		if (data + plat_item->length > end_addr){
+			pr_err(PREFIX"Data 0x%p over-runs max-addr 0x%p\n",
+				data, end_addr);
+			break;
+		}
+
+		/* Extract data */
+		switch(plat_item->plat_id){
+		case PLAT_DATA_ID:
+			id = *((uint16_t*)data);
+			pr_info(PREFIX"Clanton Platform ID = %d\n", id);
+			break;
+		case PLAT_DATA_SN:
+		case PLAT_DATA_MAC0:
+		case PLAT_DATA_MAC1:
+			break;
+		default:
+			/* Unknown identifier */
+			break;
+		}
+
+		plat_item_list = kzalloc(sizeof(struct cln_plat_data_list),
+					 GFP_KERNEL);
+		if (unlikely(plat_item_list == NULL)) {
+			pr_err("kzalloc fail !\n");
+			intel_cln_plat_cleanup();
+			return -ENOMEM;
+		}
+
+		/* Get name of entity */
+		i = intel_cln_plat_get_desc_len(plat_item->desc);
+		if (i <= 0){
+			pr_err("desc len is %d!\n", i);
+			intel_cln_plat_cleanup();
+			return i;
+		}
+
+		memcpy(plat_item_list->name, plat_item->desc, i);
+		plat_item_list->plat_data = plat_item;
+
+		sysfs_attr_init(&plat_item_list->plat_attr.attr);
+		plat_item_list->plat_attr.attr.name = plat_item_list->name;
+		plat_item_list->plat_attr.attr.mode = 0644;
+		plat_item_list->plat_attr.show = intel_cln_plat_sysfs_show;
+
+		ret = sysfs_create_file(board_data_kobj,
+					&plat_item_list->plat_attr.attr);
+		if (unlikely(ret != 0)){
+			intel_cln_plat_cleanup();
+			pr_err("failed to create sysfs entry\n");
+			return ret;
+		}
+
+		/* Add to list */
+		list_add(&plat_item_list->list, &entry_list);
+
+		/* Next */
+		plat_item = (struct cln_plat_data*)
+			(((char*)plat_item) + plat_item->length + sizeof(struct cln_plat_data));
+		data = ((char*)(plat_item) + sizeof(struct cln_plat_data));
+	}
+
+	/* Register BSP enabling platform code */
+	for (i = 0; i < sizeof(bsp_data)/sizeof(struct cln_bsp_reg); i++){
+		if (bsp_data[i].id == id){
+			platform_device_register(&bsp_data[i].pdev);
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * intel_cln_plat_remove
+ *
+ * @param pdev: Pointer to platform device
+ * @return 0 success < 0 failure
+ *
+ * Function called to remove the platfrom device from kernel space
+ *
+ */
+static int intel_cln_plat_remove(struct platform_device *pdev)
+{
+	intel_cln_plat_cleanup();
+	return 0;
+}
+
+static struct platform_driver cln_plat_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_probe,
+	.remove		= intel_cln_plat_remove,
+};
+
+module_platform_driver(cln_plat_driver);
+
+/**
+ * intel_cln_get_id
+ *
+ * @return platform id on success or < CLANTON_PLAT_UNDEFINED on error
+ *
+ * Function called to get platform id
+ *
+ */
+cln_plat_id_t intel_cln_plat_get_id(void)
+{
+	unsigned char * data;
+	struct cln_plat_data_list * plat_item_list;
+
+	if (plat_data == NULL)
+		return CLANTON_PLAT_UNDEFINED;
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+
+		/* Enumrate return */
+		if(plat_item_list->plat_data->plat_id == PLAT_DATA_ID){
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Return payload */
+			return *(int16_t*)data;
+		}
+	}
+	return CLANTON_PLAT_UNDEFINED;
+}
+EXPORT_SYMBOL(intel_cln_plat_get_id);
+
+/**
+ * intel_cln_plat_get_mac
+ *
+ * @param id: Index of MAC address to find
+ * @param mac: Output parameter for mac address
+ *
+ * @return 0 success < 0 failure
+ *
+ * Function called to remove the platfrom device from kernel space
+ *
+ */
+int intel_cln_plat_get_mac(plat_dataid_t id, char * mac)
+{
+	unsigned char * data;
+	unsigned int plen = 0;
+	struct cln_plat_data_list * plat_item_list;
+
+	if ((id != PLAT_DATA_MAC0 && id != PLAT_DATA_MAC1) || mac == NULL){
+		pr_err("invalid input id %d mac %p\n", id, mac);
+		return -EINVAL;
+	}
+
+	list_for_each_entry(plat_item_list, &entry_list, list){
+		if(plat_item_list->plat_data->plat_id == id){
+
+			/* Derive length */
+			plen = plat_item_list->plat_data->length;
+			if (unlikely(plen != MAC_LEN)){
+				pr_err("%s mac len invalid!\n", __func__);
+				return -ENODEV;
+			}
+
+			/* Hook data */
+			data =(char*)(plat_item_list->plat_data);
+			data += +sizeof(struct cln_plat_data);
+
+			/* Good to go */
+			memcpy(mac, data, MAC_LEN);
+			return 0;
+		}
+	}
+	return -ENODEV;
+}
+EXPORT_SYMBOL(intel_cln_plat_get_mac);
+
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SPI Data API");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_izmir.c b/arch/x86/platform/cln/intel_cln_plat_izmir.c
new file mode 100644
index 0000000..e8fefc0
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_izmir.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c/at24.h>
+
+#define DRIVER_NAME 		"cln-plat-izmir"
+#define GPIO_RESTRICT_NAME 	"cln-gpio-restrict-sc"
+#define LPC_SCH_SPINAME		"spi-lpc-sch"
+
+#define CLN_SPI_MAX_CLK_DEFAULT		5000000
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+static struct at24_platform_data at24_platform_data = {
+	.byte_len = (11 * 1024),
+	.page_size = 1,
+	.flags = AT24_FLAG_ADDR16,
+};
+
+/******************************************************************************
+ *                        Intel Izmir i2c clients
+ ******************************************************************************/
+static struct i2c_board_info __initdata izmir_i2c_board_info[] = {
+	{
+		I2C_BOARD_INFO("cy8c9540a", 0x20),
+	},
+	{
+		I2C_BOARD_INFO("at24", 0x50),
+		.platform_data = &at24_platform_data,
+	},
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+#define LPC_SCH_SPI_BUS_ID 0x03
+
+static struct platform_device lpc_sch_spi = {
+	.name = "spi-lpc-sch-drv",
+	.id = LPC_SCH_SPI_BUS_ID,
+};
+
+/* TODO: extract this data from layout.conf encoded in flash */
+struct mtd_partition ilb_partitions [] = {
+	{
+		.name		= "grub",
+		.size		= 4096,
+		.offset		= 0,
+	},
+	{
+		.name		= "grub.conf",
+		.size		= 0xA00,
+		.offset		= 0x50500,
+	},
+	{
+		.name		= "layout.conf",
+		.size		= 4096,
+		.offset		= 0x708000,
+	},
+	{
+		.name		= "sketch",
+		.size		= 0x40000,
+		.offset		= 0x750000,
+	},
+	{
+		.name		= "raw",
+		.size		= 8192000,
+		.offset		= 0,
+
+	},
+};
+
+static struct flash_platform_data ilb_flash = {
+	.type = "s25fl064k",
+	.parts = ilb_partitions,
+	.nr_parts = ARRAY_SIZE(ilb_partitions),
+};
+
+static struct spi_board_info spi_onboard_devs[] = {
+	{
+		.modalias = "m25p80",
+		.platform_data = &ilb_flash,
+		.bus_num = LPC_SCH_SPI_BUS_ID,
+		.chip_select = 0,
+	},
+	{
+		.modalias = "ad7298",
+		.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
+		.platform_data = &ad7298_platform_data,
+		.mode = SPI_MODE_2,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_0_cs_0,
+	},
+	{
+		.modalias = "spidev",
+		.chip_select = 0,
+		.controller_data = &cln_ffrd_spi_1_cs_0,
+		.max_speed_hz = 50000000,
+		.bus_num = 1,
+	},
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Izmir platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = intel_cln_spi_add_onboard_devs();
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+/* LPC SPI */
+static int intel_cln_plat_izmir_lpcspi_probe(struct platform_device *pdev)
+{
+	lpc_sch_spi.resource = pdev->resource;
+	return platform_device_register(&lpc_sch_spi);
+}
+
+static struct platform_driver intel_cln_plat_izmir_lpcspi_pdriver = {
+	.driver		= {
+		.name	= LPC_SCH_SPINAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_izmir_lpcspi_probe,
+};
+
+static int intel_cln_plat_izmir_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	/* i2c */
+	ret = i2c_register_board_info(0, izmir_i2c_board_info,
+		ARRAY_SIZE(izmir_i2c_board_info));
+	if (ret) {
+		goto end;
+	}
+
+	/* gpio */
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+	if (ret)
+		goto end;
+
+	/* legacy SPI */
+	ret = platform_driver_register(&intel_cln_plat_izmir_lpcspi_pdriver);
+	if (ret)
+		goto end;
+
+	
+end:
+	return ret;
+}
+
+static int intel_cln_plat_izmir_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_izmir_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_izmir_probe,
+	.remove		= intel_cln_plat_izmir_remove,
+};
+
+module_platform_driver(cln_izmir_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Izmir BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_plat_kips_bay.c b/arch/x86/platform/cln/intel_cln_plat_kips_bay.c
new file mode 100644
index 0000000..915e527
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_plat_kips_bay.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Legacy Platform Data Layout.conf accessor
+ *
+ * Simple Legacy SPI flash access layer
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2013
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "cln-plat-kips-bay"
+#define GPIO_RESTRICT_NAME "cln-gpio-restrict-sc"
+
+#define CLN_SPI_MAX_CLK_DEFAULT		5000000
+
+static int gpio_cs = 1;
+
+module_param(gpio_cs, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_cs, "Enable GPIO chip-select for SPI channel 1");
+
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *                 Intel Clanton SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip cln_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip cln_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+/**
+ * intel_cln_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Kips Bay platform
+ */
+static int intel_cln_spi_add_onboard_devs(void)
+{
+	int ret = 0;
+	struct spi_board_info spi0_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = CLN_SPI_MAX_CLK_DEFAULT,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &cln_ffrd_spi_0_cs_0,
+		},
+	};
+	struct spi_board_info spi1_onboard_devs_gpiocs[] = {
+		{
+			.modalias = "spidev",
+			.chip_select = 0,
+			.controller_data = NULL,
+			.max_speed_hz = 50000000,
+			.bus_num = 1,
+			.controller_data = &cln_ffrd_spi_1_cs_0,
+		},
+	};
+	struct spi_board_info spi1_onboard_devs[] = {
+		{
+			.modalias = "spidev",
+			.chip_select = 0,
+			.controller_data = NULL,
+			.max_speed_hz = 50000000,
+			.bus_num = 1,
+		},
+	};
+
+	ret = spi_register_board_info(spi0_onboard_devs,
+				      ARRAY_SIZE(spi0_onboard_devs));
+	if (ret)
+		return ret;
+
+	if (gpio_cs)
+		return spi_register_board_info(spi1_onboard_devs_gpiocs,
+					ARRAY_SIZE(spi1_onboard_devs_gpiocs));
+	else
+		return spi_register_board_info(spi1_onboard_devs,
+					ARRAY_SIZE(spi1_onboard_devs));
+}
+
+
+/**
+ * intel_cln_gpio_restrict_probe
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_cln_gpio_restrict_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = intel_cln_spi_add_onboard_devs();
+
+	return ret;
+}
+
+static struct platform_driver gpio_restrict_pdriver = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_gpio_restrict_probe,
+};
+
+static int intel_cln_plat_kips_bay_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver);
+
+	return ret;
+}
+
+static int intel_cln_plat_kips_bay_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver cln_kips_bay_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_cln_plat_kips_bay_probe,
+	.remove		= intel_cln_plat_kips_bay_remove,
+};
+
+module_platform_driver(cln_kips_bay_driver);
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@intel.com>");
+MODULE_DESCRIPTION("Kips Bay BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
+
diff --git a/arch/x86/platform/cln/intel_cln_sb.c b/arch/x86/platform/cln/intel_cln_sb.c
new file mode 100644
index 0000000..ef3714d
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_sb.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton side-band driver
+ *
+ * Thread-safe sideband read/write routine.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
+ */
+
+#include <linux/errno.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+
+#define INTEL_CLN_SB_CMD_ADDR	(0x000000D0)
+#define INTEL_CLN_SB_DATA_ADDR	(0x000000D4)
+
+#define INTEL_CLN_SB_MCR_SHIFT	(24)
+#define INTEL_CLN_SB_PORT_SHIFT	(16)
+#define INTEL_CLN_SB_REG_SHIFT	(8)
+#define INTEL_CLN_SB_BYTEEN	(0xF0)	/* enable all 32 bits */
+
+/* Simple structure for module */
+struct intel_cln_sb_dev{
+	struct pci_dev * pdev;
+	spinlock_t slock;
+	u8 initialized;
+};
+
+static struct intel_cln_sb_dev sb_dev = {
+	.initialized = 0
+};
+
+/* Dependant drivers */
+struct platform_device pdev [] = {
+	{
+		.name = "intel-cln-esram",
+	},
+	{
+		.name = "intel-cln-imr",
+	},
+	{
+		.name = "intel-cln-ecc",
+	},
+	{
+		.name = "intel-cln-thrm",
+	},
+};
+
+/**
+ * intel_cln_sb_read_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_CLN_SB_BYTEEN;
+
+	if(data == NULL)
+		return;
+
+	if (likely(lock == 1)) {
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
+	pci_read_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
+
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+
+}
+EXPORT_SYMBOL(intel_cln_sb_read_reg);
+
+/**
+ * intel_cln_sb_write_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock)
+{
+	u32 msg = (cmd << INTEL_CLN_SB_MCR_SHIFT) | 
+		  ((id << INTEL_CLN_SB_PORT_SHIFT) & 0xFF0000)| 
+		  ((reg << INTEL_CLN_SB_REG_SHIFT) & 0xFF00)|
+		  INTEL_CLN_SB_BYTEEN;
+
+	if(likely(lock == 1)){
+		spin_lock(&sb_dev.slock);
+	}
+
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_DATA_ADDR, data);
+	pci_write_config_dword(sb_dev.pdev, INTEL_CLN_SB_CMD_ADDR, msg);
+	
+	if(likely(lock == 1)){
+		spin_unlock(&sb_dev.slock);
+	}
+}
+EXPORT_SYMBOL(intel_cln_sb_write_reg);
+
+/**
+ * intel_cln_sb_runfn_lock
+ *
+ * @param fn: Callback function - which requires side-band spinlock and !irq
+ * @param arg: Callback argument
+ * @return 0 on success < 0 on failure
+ *
+ * Runs the given function pointer inside of a call to the local spinlock using
+ * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
+ * guarantee atomicity, but, available to any other user of sideband provided
+ * rules are respected.
+ * Rules:
+ *	fn may not sleep
+ *	fn may not change the state of irqs	
+ */
+int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg)
+{
+	unsigned long flags = 0;
+	int ret = 0;
+
+	if(unlikely(fn == NULL)){
+		return -EINVAL;
+	}
+	
+	/* Get spinlock with IRQs off */
+	spin_lock_irqsave(&sb_dev.slock, flags);
+
+	/* Run function atomically */
+	ret = fn(arg);
+
+	/* Release lock */
+	spin_unlock_irqrestore(&sb_dev.slock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_cln_sb_runfn_lock);
+
+/**
+ * sb_probe
+ *
+ * @param dev: the PCI device matching
+ * @param id: entry in the match table
+ * @return 0
+ *
+ * Callback from PCI layer when dev/vendor ids match.
+ * Sets up necessary resources
+ */
+static int intel_cln_sb_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int i = 0;
+
+	/* Init struct */
+	memset(&sb_dev, 0x00, sizeof(sb_dev));
+
+	/* Hook device */
+	sb_dev.pdev = dev;
+
+	/* Init locking structures */
+	spin_lock_init(&sb_dev.slock);
+
+	/* Set state */
+	sb_dev.initialized = 1;
+
+	/* Register side-band sub-ordinate drivers */
+	for (i = 0; i < sizeof(pdev)/sizeof(struct platform_device); i++){
+		platform_device_register(&pdev[i]);
+	}
+	pr_info("Intel Clanton side-band driver registered\n");
+	return 0;
+}
+
+/**
+ * sb_remove
+ *
+ * @param pdev: PCI device
+ * @return nothing
+ *
+ * Callback from PCI sub-system upon PCI dev removal
+ */
+static void intel_cln_sb_remove(struct pci_dev *pdev)
+{
+}
+
+/* Clanton hardware */
+struct pci_device_id intel_cln_sb_ids[] = {
+        { PCI_VDEVICE(INTEL, 0x0958), 0},
+        { 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, intel_cln_sb_ids);
+
+/* PCI callbacks */
+static struct pci_driver intel_cln_sb_driver = {
+	.name = "intel_cln_sb",
+	.id_table = intel_cln_sb_ids,
+	.probe = intel_cln_sb_probe,
+	.remove = intel_cln_sb_remove,
+};
+
+/**
+ * intel_cln_sb_init
+ *
+ * Module entry point
+ */
+static int __init intel_cln_sb_init(void)
+{
+	return pci_register_driver(&intel_cln_sb_driver);
+}
+
+/**
+ * intel_cln_sb_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_sb_exit(void)
+{
+	sb_dev.initialized = 0;
+	pci_unregister_driver(&intel_cln_sb_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SOC side-band driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+/* Initialise early since other drivers eSRAM, DRAM ECC and thermal depend */
+device_initcall(intel_cln_sb_init);
+module_exit(intel_cln_sb_exit);
diff --git a/arch/x86/platform/cln/intel_cln_smep_test.c b/arch/x86/platform/cln/intel_cln_smep_test.c
new file mode 100644
index 0000000..16f43db
--- /dev/null
+++ b/arch/x86/platform/cln/intel_cln_smep_test.c
@@ -0,0 +1,290 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/**
+ * intel_cln_smep_test.c
+ *
+ * Simple test module to verify SMEP works as expected on MIA
+ * DO NOT RELEASE THIS FILE OUTSIDE OF CLANTON GROUP
+ * DO NOT ATTEMPT TO UPSTREAM THIS CODE - YOU WILL BE PUBLICLY EMBARRSSED !
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@intel.com>
+ *
+ */
+#include <asm/processor.h>
+#include <asm/processor-flags.h>
+#include <linux/cdev.h>
+#include <linux/crc16.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define DRIVER_NAME			"intel_cln_smep_test"
+
+/**
+ * struct intel_cln_smep_dev
+ *
+ * Structre to represent module state/data/etc
+ */
+struct intel_cln_smep_test_dev{
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+	char * pdata;
+	u32 size;
+};
+
+static struct intel_cln_smep_test_dev smep_test_dev;
+static struct class *smep_test_class;
+static DEFINE_MUTEX(smep_test_mutex);
+static int smep_test_major;
+static char * name = "testmap";
+
+/**
+ * smep_test_ioctl
+ *
+ * Allows user-space to command kernel switch SMEP on/off
+ */
+static long smep_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int cr4 = 0;
+
+	cr4 = read_cr4();
+	printk(KERN_INFO "%s entry CR4 is 0x%08x\n", __FUNCTION__, cr4);
+
+	switch(cmd){
+		case 0:
+			printk(KERN_INFO "Switching SMEP off\n");
+			cr4 &= ~X86_CR4_SMEP;
+			
+			break;
+		case 1:
+			printk(KERN_INFO "Switching SMEP on\n");
+			cr4 |= X86_CR4_SMEP;
+			break;
+		default:
+			return -EINVAL;
+	}
+	/* Latch value */
+	write_cr4(cr4);
+
+	/* Print contents of CR4 */
+	cr4 = read_cr4();
+	printk(KERN_INFO "%s exit CR4 is 0x%08x\n", __FUNCTION__, cr4);
+	
+	return 0;
+}
+
+/**
+ * smep_test_write
+ *
+ * Accepts a buffer from user-space and then tries to execute the contents
+ * Be very careful
+ */
+static ssize_t smep_test_write(struct file *file, const char __user *buf,
+						size_t count, loff_t *ppos)
+{
+	/* 
+	 * We assume we are passed a pointer to function of type
+	 * void fn(void)
+	 */
+	void (*fn)(void) = (void(*))buf;
+	if (count) {
+		printk(KERN_INFO "Will attempt exec %d bytes of ring3 code @ 0x%p\n",
+			count, buf);
+		fn();
+		printk(KERN_INFO "Exec of data @ 0x%p complete\n", buf);
+	}
+	return count;
+}
+
+static int smep_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&smep_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&smep_test_dev.open_lock)) {
+		mutex_unlock(&smep_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (smep_test_dev.opened) {
+		mutex_unlock(&smep_test_dev.open_lock);
+		mutex_unlock(&smep_test_mutex);
+		return -EINVAL;
+	}
+
+	smep_test_dev.opened++;
+	mutex_unlock(&smep_test_dev.open_lock);
+	mutex_unlock(&smep_test_mutex);
+	return 0;
+}
+
+static int smep_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&smep_test_dev.open_lock);
+	smep_test_dev.opened = 0;
+	mutex_unlock(&smep_test_dev.open_lock);
+
+	return 0;
+}
+
+
+
+static const struct file_operations smep_test_file_ops = {
+	.open = smep_test_open,
+	.release = smep_test_release,
+	.unlocked_ioctl = smep_test_ioctl,
+	.write		= smep_test_write,
+	.llseek = no_llseek,
+};
+
+
+/**
+ * intel_cln_smep_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This driver manages eSRAM on a per-page basis. Therefore if we find block
+ * mode is enabled, or any global, block-level or page-level locks are in place
+ * at module initialisation time - we bail out.
+ */
+static int intel_cln_smep_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&smep_test_dev.open_lock);
+	cdev_init(&smep_test_dev.cdev, &smep_test_file_ops);
+	smep_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&smep_test_dev.cdev, MKDEV(smep_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(smep_test_class, NULL,
+				 MKDEV(smep_test_major, minor), NULL,
+				 "smeptest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+	printk(KERN_INFO "%s complete OK - device /dev/smeptest%u\n", __FUNCTION__, minor);
+	return 0;
+
+}
+
+/**
+ * intel_cln_smep_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_smep_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(smep_test_dev.cdev.dev);
+
+	device_destroy(smep_test_class, MKDEV(smep_test_major, minor));
+	cdev_del(&smep_test_dev.cdev);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_smep_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_cln_smep_test_remove,
+};
+
+/**
+ * intel_cln_smep_init
+ *
+ * @return 0 success < 0 failure
+ *
+ * Module entry point
+ */
+static int __init intel_cln_smep_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	smep_test_class = class_create(THIS_MODULE,"cln_smep_test");
+	if (IS_ERR(smep_test_class)) {
+		retval = PTR_ERR(smep_test_class);
+		printk(KERN_ERR "smep_test: can't register earam_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "smep_test");
+	if (retval) {
+		printk(KERN_ERR "smep_test: can't register character device\n");
+		goto err_class;
+	}
+	smep_test_major = MAJOR(dev);
+
+	memset(&smep_test_dev, 0x00, sizeof(smep_test_dev));
+	smep_test_dev.pldev = platform_create_bundle(
+		&intel_cln_smep_test_driver, intel_cln_smep_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(smep_test_dev.pldev)){
+		printk(KERN_ERR "smep_test platform_create_bundle fail!\n"); 
+		retval = PTR_ERR(smep_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(smep_test_class);
+err:
+	return retval;
+}
+
+/**
+ * intel_cln_smep_exit
+ *
+ * Module exit
+ */
+static void __exit intel_cln_smep_test_exit(void)
+{
+	platform_device_unregister(smep_test_dev.pldev);
+	platform_driver_unregister(&intel_cln_smep_test_driver);
+}
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton SMEP test");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_init(intel_cln_smep_test_init);
+module_exit(intel_cln_smep_test_exit);
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 2a262f5..1c5ce3c 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -671,6 +671,76 @@ config INTEL_MFLD_THERMAL
          Say Y here to enable thermal driver support for the  Intel Medfield
          platform.
 
+config INTEL_CLN_ESRAM
+	bool "eSRAM - embedded SRAM driver for Intel Clanton platform"
+	depends on INTEL_CLN_SOC && PM
+	select KALLSYMS
+	select CRC16
+	help
+	  Say Y here to enable eSRAM overlay and software-initiated ECC
+	  updates. eSRAM overlaying allows for code/data structures to be
+	  mapped into eSRAM thus providing far faster access to code/data
+	  than ordinary DRAM. Slower than cache RAM faster than DRAM.
+
+config INTEL_CLN_ECC_REFRESH_PERIOD
+	int "Choose eSRAM ECC coverage period"
+	depends on INTEL_CLN_ESRAM
+	default 24
+	help
+	  Select the period over which *RAM ECC codes should be refreshed.
+	  IA Core will periodically enable disabled eSRAM pages to ensure all of
+	  disabled eSRAM pages are 'address walked' in this period. A logical
+	  component within the silicon on Clanton will ensure DRAM (and
+	  overlayed eSRAM) pages by extension are similarly updated over the
+	  same period. This variable controlls how long a time this address
+	  walking algorithm should take. For a noisy environment like a
+	  sub-station or a satellite update frequently. For less noisy
+	  environments this value should be lower. Default 24 hours is right for
+	  most people. Set to zero to disable - this is NOT recommended. Max 48
+	  hours.
+
+config INTEL_CLN_ECC_SCRUB
+	bool "Hardware ECC Scrub - /proc interface for Intel Clanton platform"
+	depends on INTEL_CLN_SOC
+	help
+	   Say Y here to enable support for accessing the hardware memory
+	   ECC Scrubber via the /proc interface.
+
+config INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	bool "Hardware ECC Scrub - use config settings to override scrub vals"
+	depends on INTEL_CLN_ECC_SCRUB
+	help
+	  Say Y here to enable support to use config settings to override
+	  BIOS configured scrub values
+
+config INTEL_CLN_HW_ECC_REFRESH_RATE
+	int "Choose DRAM ECC refresh rate"
+	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	default 20
+	help
+	  Range 0 - 255 mSec
+
+config INTEL_CLN_HW_ECC_REFRESH_SIZE
+	int "Choose DRAM ECC refresh size"
+	depends on INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	default 512
+	help
+	  Range 64-512 bytes, multiples of 32
+
+config INTEL_CLN_ECC_SCRUB_S3_CONFIG
+	bool "Hardware ECC Scrub - linux manages S3 entry/resume for scrub"
+	depends on INTEL_CLN_ECC_SCRUB
+	help
+	  Say Y here to enable linux to manage S3 entry/resume for the
+	  hardware memory ECC Scrubber.
+
+config INTEL_CLN_THERMAL
+	bool "Thermal driver for Intel Clanton platform"
+	depends on INTEL_CLN_SOC
+	help
+	  Say Y here to enable Clanton's Thermal driver plus the MSI's
+	  that can be hooked from the thermal sub-system
+
 config INTEL_IPS
 	tristate "Intel Intelligent Power Sharing"
 	depends on ACPI
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index bf7e4f9..06dd3bc 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -36,6 +36,8 @@ obj-$(CONFIG_TOPSTAR_LAPTOP)	+= topstar-laptop.o
 obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
 
 obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
+obj-$(CONFIG_INTEL_CLN_ECC_SCRUB) += intel_cln_ecc_scrub.o
+obj-$(CONFIG_INTEL_CLN_THERMAL)	+= intel_cln_thermal.o
 obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
@@ -50,3 +52,5 @@ obj-$(CONFIG_INTEL_MID_POWER_BUTTON)	+= intel_mid_powerbtn.o
 obj-$(CONFIG_INTEL_OAKTRAIL)	+= intel_oaktrail.o
 obj-$(CONFIG_SAMSUNG_Q10)	+= samsung-q10.o
 obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
+
+obj-$(CONFIG_INTEL_CLN_SPI_UPDATE)     += intel_cln_spi_update.o
diff --git a/drivers/platform/x86/intel_cln_ecc_scrub.c b/drivers/platform/x86/intel_cln_ecc_scrub.c
new file mode 100644
index 0000000..dd5b434
--- /dev/null
+++ b/drivers/platform/x86/intel_cln_ecc_scrub.c
@@ -0,0 +1,766 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton DRAM ECC Scrub driver
+ *
+ * !!!!!!! Description
+ *
+ */
+#include <asm-generic/uaccess.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+
+#define DRIVER_NAME			"intel-cln-ecc"
+#define INTEL_CLN_ECC_SCRUB_PROCDIR	"driver/ecc_scrub"
+#define STATUS				"status"
+#define CONTROL				"control"
+#define INTERVAL			"interval"
+#define ECC_BLOCK_SIZE			"block_size"
+
+#define CONTROL_USAGE		"ECC Scrub Control: invalid setting. "\
+				"Valid values are 1 or 0\n"
+#define CONTROL_SCRUB_ON_STR	"1\n"
+#define CONTROL_SCRUB_OFF_STR	"0\n"
+#define CONTROL_ON_STR		"on\n"
+#define CONTROL_OFF_STR		"off\n"
+
+#define INTERVAL_USAGE		"ECC Scrub Interval: invalid setting. "\
+				"Valid range is 1 - 255\n"
+#define SIZE_USAGE		"ECC Scrub Block Size: invalid setting. "\
+				"Valid range is 64 - 512\n"
+
+#define OVERRIDE_CONFIG_PARM_DESC	"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Config"
+
+#define OVERRIDE_START_PARM_DESC	"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Start address"
+
+#define OVERRIDE_END_PARM_DESC		"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub End address"
+
+#define OVERRIDE_NEXT_PARM_DESC		"Clanton ECC Scrub - "\
+					"Override BIOS settings "\
+					"for Scrub Next address"
+
+#define MAX_SCRUB_BLOCK_SIZE 512
+#define MIN_SCRUB_BLOCK_SIZE 64
+#define MAX_SCRUB_REFRESH 255
+#define MIN_SCRUB_REFRESH 0
+
+#define NOT_OVERRIDDEN 0xfffffffful
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+/* Register ID */
+#define ECC_SCRUB_CONFIG_REG		(0x50)
+#define ECC_SCRUB_START_MEM_REG		(0x76)
+#define ECC_SCRUB_END_MEM_REG		(0x77)
+#define ECC_SCRUB_NEXT_READ_REG		(0x7C)
+
+
+/* Reg commands */
+#define THERMAL_CTRL_READ		(0x10)
+#define THERMAL_CTRL_WRITE		(0x11)
+#define THERMAL_RESUME_SCRUB		(0xC2)
+#define THERMAL_PAUSE_SCRUB		(0xC3)
+
+/**
+ * struct intel_cln_ecc_scrub_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_cln_ecc_scrub_dev {
+
+	/* Linux kernel structures */
+	struct platform_device *pldev;		/* Platform device */
+	struct proc_dir_entry *pdir;		/* Proc directory */
+						/* /proc/driver/ecc_scrub/ */
+	struct proc_dir_entry *pcontrol;	/* ""/control */
+	struct proc_dir_entry *pstatus;		/* ""/status */
+	struct proc_dir_entry *pinterval;	/* ""/interval */
+	struct proc_dir_entry *psize;		/* ""/block_size */
+
+	/* Register copies */
+	u32 start_address;
+	u32 end_address;
+	u32 next_address;
+	u32 config;
+
+};
+
+static struct intel_cln_ecc_scrub_dev ecc_scrub_dev;
+
+static u32 ecc_scrub_config_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_start_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_end_override = NOT_OVERRIDDEN;
+static u32 ecc_scrub_next_override = NOT_OVERRIDDEN;
+
+#ifdef CONFIG_PROC_FS
+
+
+/**
+ * intel_cln_ecc_scrub_stat_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /proc/driver/ecc_scrub/status
+ */
+static int intel_cln_ecc_scrub_stat_read(char *page, char **start,
+					off_t off, int count,
+					int *eof, void *data)
+
+{
+	int len = 0, size = 0;
+	u32 reg_data = 0;
+	char *scrub_status = CONTROL_OFF_STR;
+
+	/* Display start of memory address */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
+		&reg_data, 1);
+	len += snprintf(page + len, count - len,
+			"ecc scrub mem start\t\t\t: 0x%08x\n", reg_data);
+
+
+	/* Display end of memory address */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
+		&reg_data, 1);
+	len += snprintf(page + len, count - len,
+			"ecc scrub mem end\t\t\t: 0x%08x\n", reg_data);
+
+	/* Display next address to be read */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
+		&reg_data, 1);
+	len += snprintf(page + len, count - len,
+			"ecc scrub next read\t\t\t: 0x%08x\n", reg_data);
+
+	/* Display config settings */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+
+	/* Interval is the lsbyte of the config reg, so mask out just
+	 * that byte in the data printed. */
+	len += snprintf(page + len, count - len,
+			"ecc scrub interval\t\t\t: %d\n",
+			(reg_data & 0x000000ff));
+
+	/* Size is indicated in bits 12:8 of register in
+	* terms of 32 byte blocks. */
+	size = ((reg_data & 0x00001f00) >> 8)*32;
+	len += snprintf(page + len, count - len,
+			"ecc scrub block_size\t\t\t: %d\n", size);
+
+	/* Status is indicated in bit 13 of register. */
+	if ((reg_data & 0x00002000) > 0)
+		scrub_status = CONTROL_ON_STR;
+
+	len += snprintf(page + len, count - len,
+			"ecc scrub status\t\t\t: %s\n", scrub_status);
+	*eof = 1;
+
+	return len;
+}
+
+/**
+ * intel_cln_ecc_scrub_ctrl_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /proc/driver/ecc_scrub/control
+ */
+static int intel_cln_ecc_scrub_ctrl_read(char *page, char **start,
+						 off_t off, int count,
+						 int *eof, void *data)
+
+{
+	int len = 0;
+	u32 reg_data = 0;
+	char *on_or_off = CONTROL_SCRUB_OFF_STR;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+	&reg_data, 1);
+
+	/* Status is indicated in bit 13 of register. */
+	if ((reg_data & 0x00002000) > 0)
+		/* interval > 0 assume scrubbing on */
+		on_or_off = CONTROL_SCRUB_ON_STR;
+
+	len += snprintf(page + len, count - len,
+			"%s", on_or_off);
+	*eof = 1;
+
+	return len;
+}
+
+/**
+ * intel_cln_ecc_scrub_ctrl_write
+ *
+ * @param file: File pointer
+ * @param buf: Data being sent from user-space
+ * @param count: Number of bytes being sent
+ * @param data: Statically set data in the /proc callback - unused
+ * @return number of bytes successfully written or < 0 to indicate error
+ *
+ * Function allows user-space to switch on/off scrubbing with a simple
+ * echo 1/0 > /proc/driver/ecc_scrub/control command
+ */
+static int
+intel_cln_ecc_scrub_ctrl_write(struct file *file, const char __user *buf,
+			       unsigned long count, void *data)
+{
+	ssize_t ret = 0;
+	char *cbuf = NULL;
+
+	if (count <= 1)
+		return -EINVAL;
+
+
+	/* Get input */
+	cbuf = kzalloc(count+1, GFP_KERNEL);
+	if (cbuf == NULL)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (!copy_from_user(cbuf, buf, count)) {
+		ret = -EINVAL;
+
+		/* Check for command starting with "scrub"
+		*  and ending with "on" or "off" */
+
+		if (!strcmp(cbuf, CONTROL_SCRUB_ON_STR)) {
+				sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB,
+				0, 0, 1);
+				ret = 0;
+		} else if (!strcmp(cbuf, CONTROL_SCRUB_OFF_STR)) {
+			sb_write(SB_ID_THERMAL, THERMAL_PAUSE_SCRUB, 0,
+				 0, 1);
+			ret = 0;
+		}
+	}
+
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+
+	else if (ret == -EINVAL)
+		printk(CONTROL_USAGE);
+
+	kfree(cbuf);
+	return ret;
+}
+
+/**
+ * intel_cln_ecc_scrub_intrvl_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /proc/driver/ecc_scrub/interval
+ */
+static int intel_cln_ecc_scrub_intrvl_read(char *page, char **start,
+						 off_t off,
+						 int count, int *eof,
+						 void *data)
+
+{
+	int len = 0;
+	u32 reg_data = 0;
+
+	/* Interval is the lsbyte of the config reg,
+	* so mask out just that byte in the data printed. */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+	len += snprintf(page + len, count - len,
+			"%d\n", (reg_data & 0x000000ff));
+	*eof = 1;
+
+	return len;
+}
+
+/**
+ * intel_cln_ecc_scrub_intrvl_write
+ *
+ * @param file: File pointer
+ * @param buf: Data being sent from user-space
+ * @param count: Number of bytes being sent
+ * @param data: Statically set data in the /proc callback - unused
+ * @return number of bytes successfully written or < 0 to indicate error
+ *
+ * Function allows user-space to set scrub interval with a value of 1-255
+ * echo 1-255 > /proc/driver/ecc_scrub/interval type command
+ */
+static int
+intel_cln_ecc_scrub_intrvl_write(struct file *file, const char __user *buf,
+			       unsigned long count, void *data)
+{
+	ssize_t ret = 0;
+	char *cbuf = NULL;
+	unsigned long val = 0;
+	u32 reg_data = 0;
+	int ret_temp = 0;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	/* Get input */
+	cbuf = kzalloc(count+1, GFP_KERNEL);
+	if (cbuf == NULL)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (!copy_from_user(cbuf, buf, count)) {
+		ret = -EINVAL;
+
+		ret_temp = kstrtoul(cbuf, 10, &val);
+
+		if (ret_temp)
+			return ret_temp;
+
+		if (val > MIN_SCRUB_REFRESH && val <= MAX_SCRUB_REFRESH) {
+			/* Need to read-modify-write config register. */
+			sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
+				ECC_SCRUB_CONFIG_REG,
+				&reg_data, 1);
+
+			reg_data &= 0xffffff00;	/* clear lsb. */
+			reg_data |= val;		/* now set interval. */
+
+			sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+				 ECC_SCRUB_CONFIG_REG,
+				 reg_data, 1);
+			ret = 0;
+		} else {
+			printk(INTERVAL_USAGE);
+		}
+
+	}
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+	kfree(cbuf);
+	return ret;
+}
+
+/**
+ * intel_cln_ecc_scrub_size_read
+ *
+ * @param page: buffer to write data into
+ * @param start: where the data has been written in the page
+ * @param offset: same meaning as read system call
+ * @param count: same meaning as read system call
+ * @param eof: set if no more data needs to be returned
+ * @return number of bytes successfully read
+ *
+ * Populates ecc_scrub state via /proc/driver/ecc_scrub/block_size
+ */
+static int intel_cln_ecc_scrub_size_read(char *page, char **start,
+					off_t off,
+					int count, int *eof,
+					void *data)
+
+{
+	int len = 0;
+	int size = 0;
+	u32 reg_data = 0;
+
+	/* Size is indicated in bits 12:8 of config register
+	 * multiply x32 to get num bytes). */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+	size = ((reg_data & 0x00001f00) >> 8)*32;
+
+	len += snprintf(page + len, count - len,
+			"%d\n", size);
+	*eof = 1;
+
+	return len;
+}
+
+/**
+ * intel_cln_ecc_scrub_size_write
+ *
+ * @param file: File pointer
+ * @param buf: Data being sent from user-space
+ * @param count: Number of bytes being sent
+ * @param data: Statically set data in the /proc callback - unused
+ * @return number of bytes successfully written or < 0 to indicate error
+ *
+ * Function allows user-space to set scrub block size of 64-512 with a simple
+ * echo 64-512 > /proc/driver/ecc_scrub/block_size command
+ */
+static int
+intel_cln_ecc_scrub_size_write(struct file *file, const char __user *buf,
+				unsigned long count, void *data)
+{
+	ssize_t ret = 0;
+	char *cbuf = NULL;
+	unsigned long val = 0;
+	u32 reg_data = 0;
+	int ret_temp = 0;
+
+	if (count <= 1)
+		return -EINVAL;
+
+	/* Get input */
+	cbuf = kzalloc(count+1, GFP_KERNEL);
+	if (cbuf == NULL)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (!copy_from_user(cbuf, buf, count)) {
+		ret = -EINVAL;
+
+		ret_temp = kstrtoul(cbuf, 10, &val);
+
+		if (ret_temp)
+			return ret_temp;
+
+		if (val >= MIN_SCRUB_BLOCK_SIZE
+		   && val <= MAX_SCRUB_BLOCK_SIZE){
+			/* Need to read-modify-write config register. */
+			sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ,
+				ECC_SCRUB_CONFIG_REG,
+				&reg_data, 1);
+
+			reg_data &= 0xfffffe0ff;	/* clear bits 12:8 */
+			reg_data |= (val/32)<<8;	/* now set size */
+
+			sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+				 ECC_SCRUB_CONFIG_REG,
+				 reg_data, 1);
+			ret = 0;
+		} else {
+			printk(SIZE_USAGE);
+		}
+
+	}
+
+	if (ret == 0)
+		ret = (ssize_t)count;
+	kfree(cbuf);
+	return ret;
+}
+
+/**
+ * intel_cln_ecc_scrub_addfs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Adds entries to procfs
+ */
+static int intel_cln_ecc_scrub_add(void)
+{
+	ecc_scrub_dev.pdir = proc_mkdir(INTEL_CLN_ECC_SCRUB_PROCDIR, NULL);
+	if (ecc_scrub_dev.pdir == NULL)
+		return -ENOMEM;
+
+
+	ecc_scrub_dev.pstatus = create_proc_read_entry(STATUS, 0,
+						 ecc_scrub_dev.pdir,
+						 intel_cln_ecc_scrub_stat_read,
+						 NULL);
+	if (ecc_scrub_dev.pstatus == NULL)
+		return -EIO;
+
+	ecc_scrub_dev.pcontrol = create_proc_entry(CONTROL, 0,
+						   ecc_scrub_dev.pdir);
+	if (ecc_scrub_dev.pcontrol == NULL)
+		return -EIO;
+
+	ecc_scrub_dev.pcontrol->read_proc = intel_cln_ecc_scrub_ctrl_read;
+	ecc_scrub_dev.pcontrol->write_proc = intel_cln_ecc_scrub_ctrl_write;
+	ecc_scrub_dev.pcontrol->data = NULL;
+
+	ecc_scrub_dev.pinterval = create_proc_entry(INTERVAL, 0,
+						    ecc_scrub_dev.pdir);
+	if (ecc_scrub_dev.pinterval == NULL)
+		return -EIO;
+
+	ecc_scrub_dev.pinterval->read_proc = intel_cln_ecc_scrub_intrvl_read;
+	ecc_scrub_dev.pinterval->write_proc = intel_cln_ecc_scrub_intrvl_write;
+	ecc_scrub_dev.pinterval->data = NULL;
+
+	ecc_scrub_dev.psize = create_proc_entry(ECC_BLOCK_SIZE, 0,
+						ecc_scrub_dev.pdir);
+	if (ecc_scrub_dev.psize == NULL)
+		return -EIO;
+
+	ecc_scrub_dev.psize->read_proc = intel_cln_ecc_scrub_size_read;
+	ecc_scrub_dev.psize->write_proc = intel_cln_ecc_scrub_size_write;
+	ecc_scrub_dev.psize->data = NULL;
+
+	return 0;
+}
+
+/**
+ * intel_cln_ecc_scrub_proc_remove
+ *
+ * @return nothing
+ *
+ * Removes /proc entires
+ */
+static void intel_cln_ecc_scrub_proc_remove(void)
+{
+	remove_proc_entry(CONTROL, ecc_scrub_dev.pcontrol);
+	remove_proc_entry(INTERVAL, ecc_scrub_dev.pinterval);
+	remove_proc_entry(ECC_BLOCK_SIZE, ecc_scrub_dev.pinterval);
+	remove_proc_entry(STATUS, ecc_scrub_dev.pstatus);
+	remove_proc_entry(INTEL_CLN_ECC_SCRUB_PROCDIR, NULL);
+}
+
+#else
+
+static int intel_cln_ecc_scrub_add(void){ return 0; }
+static void intel_cln_ecc_scrub_remove(void){ return; }
+
+#endif /* CONFIG_PROC_FS */
+
+/*****************************************************************************
+ *                        Module/PowerManagement hooks
+ *****************************************************************************/
+/**
+ * intel_cln_ecc_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ */
+static int intel_cln_ecc_scrub_probe(struct platform_device *pdev)
+{
+	int value_overridden = 0;
+
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+	u32 scrubber_refresh = 0;
+	u32 scrubber_block_size = 0;
+	u32 config_settings = 0;
+#endif
+
+	memset(&ecc_scrub_dev, 0x00, sizeof(ecc_scrub_dev));
+
+	/* Update config settings, if directed so to do */
+	if (ecc_scrub_start_override != NOT_OVERRIDDEN) {
+		/* start of memory address */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_START_MEM_REG, ecc_scrub_start_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_end_override != NOT_OVERRIDDEN) {
+		/* end of memory address */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_END_MEM_REG, ecc_scrub_end_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_next_override != NOT_OVERRIDDEN) {
+		/* next address to be read */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_NEXT_READ_REG, ecc_scrub_next_override, 1);
+
+			value_overridden = 1;
+	}
+	if (ecc_scrub_config_override != NOT_OVERRIDDEN) {
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG, ecc_scrub_config_override, 1);
+
+			value_overridden = 1;
+	}
+
+	/* Config Reg can be updated by either command line or kconfig setting
+	 * in the case where we have both the command line takes precedence.*/
+
+	else {
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_OVERRIDE_CONFIG
+		scrubber_refresh = CONFIG_INTEL_CLN_HW_ECC_REFRESH_RATE;
+		scrubber_block_size = CONFIG_INTEL_CLN_HW_ECC_REFRESH_SIZE;
+
+		if (scrubber_block_size > MAX_SCRUB_BLOCK_SIZE)
+			scrubber_block_size = MAX_SCRUB_BLOCK_SIZE;
+
+		else if (scrubber_block_size < MIN_SCRUB_BLOCK_SIZE)
+			scrubber_block_size = MIN_SCRUB_BLOCK_SIZE;
+
+		if (scrubber_refresh > MAX_SCRUB_REFRESH)
+			scrubber_refresh = MAX_SCRUB_REFRESH;
+
+
+		/* adjust block size to multiples of 32 -
+		 * as that is what the register setting actually expects. */
+		config_settings = scrubber_block_size/32;
+		config_settings <<= 8;
+		config_settings += scrubber_refresh;
+
+		/* config settings */
+		sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE,
+			 ECC_SCRUB_CONFIG_REG, config_settings, 1);
+
+		value_overridden = 1;
+#endif
+	}
+
+	if (value_overridden)
+		sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
+
+	return intel_cln_ecc_scrub_add();
+}
+
+/**
+ * intel_cln_ecc_scrub_suspend
+ *
+ * @param pdev: Platform device structure (unused)
+ * @return 0 success < 0 failure
+ *
+ */
+static int intel_cln_ecc_scrub_suspend(struct device *pdev)
+{
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
+	u32 reg_data = 0;
+
+	/* Store off the 4 registers associated with scrubbing. */
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_START_MEM_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.start_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_END_MEM_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.end_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_NEXT_READ_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.next_address = reg_data;
+
+	sb_read(SB_ID_THERMAL, THERMAL_CTRL_READ, ECC_SCRUB_CONFIG_REG,
+		&reg_data, 1);
+	ecc_scrub_dev.config = reg_data;
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_ecc_scrub_resume
+ *
+ * @param pdev: Platform device structure (unused)
+ * @return 0 success < 0 failure
+ */
+static int intel_cln_ecc_scrub_resume(struct device *pdev)
+{
+#ifdef CONFIG_INTEL_CLN_ECC_SCRUB_S3_CONFIG
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_START_MEM_REG,
+		 ecc_scrub_dev.start_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_END_MEM_REG,
+		 ecc_scrub_dev.end_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_NEXT_READ_REG,
+		 ecc_scrub_dev.next_address, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_CTRL_WRITE, ECC_SCRUB_CONFIG_REG,
+		 ecc_scrub_dev.config, 1);
+
+	sb_write(SB_ID_THERMAL, THERMAL_RESUME_SCRUB, 0, 0, 1);
+
+#endif
+	return 0;
+}
+
+/**
+ * intel_cln_ecc_scrub_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_ecc_scrub_remove(struct platform_device *pdev)
+{
+	intel_cln_ecc_scrub_proc_remove();
+
+	return 0;
+}
+
+/*
+ * Power management operations
+ */
+static const struct dev_pm_ops intel_cln_ecc_scrub_pm_ops = {
+	.suspend = intel_cln_ecc_scrub_suspend,
+	.resume = intel_cln_ecc_scrub_resume,
+};
+
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_ecc_scrub_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &intel_cln_ecc_scrub_pm_ops,
+	},
+	.probe = intel_cln_ecc_scrub_probe,
+	.remove = intel_cln_ecc_scrub_remove,
+};
+
+
+MODULE_AUTHOR("Derek Harnett <derek.harnett@intel.com>");
+MODULE_DESCRIPTION("Intel Clanton DRAM ECC-scrub driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_param(ecc_scrub_config_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_config_override, OVERRIDE_CONFIG_PARM_DESC);
+
+module_param(ecc_scrub_start_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_start_override, OVERRIDE_START_PARM_DESC);
+
+module_param(ecc_scrub_end_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_end_override, OVERRIDE_END_PARM_DESC);
+
+module_param(ecc_scrub_next_override, uint, 0644);
+MODULE_PARM_DESC(ecc_scrub_next_override, OVERRIDE_NEXT_PARM_DESC);
+
+module_platform_driver(intel_cln_ecc_scrub_driver);
+
diff --git a/drivers/platform/x86/intel_cln_thermal.c b/drivers/platform/x86/intel_cln_thermal.c
new file mode 100644
index 0000000..ce0da9cd
--- /dev/null
+++ b/drivers/platform/x86/intel_cln_thermal.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton Thermal driver
+ */
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/intel_cln_sb.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+#include <linux/timer.h>
+
+#define DRIVER_NAME		"intel-cln-thrm"
+
+/* Definition of register locations for thermal management */
+#define THRM_CTRL_REG		(0x80)		/* Thermal control */
+#define THRM_MODE_REG		(0xB0)		/* Thermal mode */
+#define THRM_MODE_SENSOR_EN	(0x00008000)	/* Thermal mode sensor enable */
+#define THRM_TEMP_REG		(0xB1)		/* Thermal sensor temperature */
+#define THRM_TRPCLR_REG		(0xB2)		/* Catastropic/Hot trip/clear */
+#define THRM_AUXTRP_REG		(0xB3)		/* Aux0-Aux3 trip point */
+#define THRM_AUXCLR_REG		(0xB4)		/* Aux0-Aux3 clear trip */
+#define THRM_STATUS_REG		(0xB5)		/* Thermal sensor status */
+#define THRM_TRIPBEHAVE_REG	(0xB6)		/* Trip point behavior */
+#define THRM_MSIADDR_REG	(0xC5)		/* Thermal MSI addres reg */
+#define THRM_MSIDATA_REG	(0xC6)		/* Thermal MSI data reg */
+#define THRM_CTRL_READ		(0x10)		/* Config reg */
+#define THRM_CTRL_WRITE		(0x11)		/* Config reg */
+
+#define SOC_TSENSOR_REG		(0x34)
+#define SOC_TSENSOR_RST		(0x00000001)
+#define SOC_CTRL_READ		(0x06)
+#define SOC_CTRL_WRITE		(0x07)
+
+
+#define THRM_ZONE_COUNT		2		/* Only hot/critical relevant */
+#define ACTIVE_INTERVAL		(1000)
+#define IDLE_INTERVAL		(20000)
+#define MCELSIUS(x)		((x) * 1000)
+
+/* CPU Zone information */
+#define CATASTROPIC_ZONE	0
+#define HOT_ZONE		1
+#define AUX0_ZONE		2		/* Unused */
+#define AUX1_ZONE		3		/* Unused */
+#define AUX2_ZONE		4		/* Unused */
+#define AUX3_ZONE		5		/* Unused */
+#define MIN_USED_ZONE		CATASTROPIC_ZONE
+#define MAX_USED_ZONE		HOT_ZONE
+/*
+ * Default catastrophic/hot trip values - in degrees celsius
+ * Maximum temperature is 105 degrees
+ */
+#define CRIT_TEMP	104
+#define HOT_TEMP	95
+#define RAW2CELSIUS_DIFF	50
+
+static int driver_enable = 1;
+module_param(driver_enable, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(driver_enable, "Disable Thermal Driver Polling");
+
+/* Shorten fn names to fit 80 char limit */
+#ifndef sb_read
+#define sb_read				intel_cln_sb_read_reg
+#endif
+#ifndef sb_write
+#define sb_write			intel_cln_sb_write_reg
+#endif
+
+struct intel_cln_therm_zone {
+	enum thermal_trip_type type;
+	int trip_value;
+};
+
+/**
+ * struct intel_cln_thermal_dev
+ *
+ */
+struct intel_cln_thermal_dev {
+	enum thermal_device_mode mode;
+	struct intel_cln_therm_zone tzone[THRM_ZONE_COUNT];
+	struct mutex lock;
+	struct platform_device *pldev;		/* Platform device */
+	struct thermal_zone_device *therm_dev;	/* Thermal device */
+};
+
+static struct intel_cln_thermal_dev cln_tdev;
+
+/******************************************************************************
+ *                        Thermal API implementation
+ ******************************************************************************/
+
+/**
+ * get_temp
+ *
+ * @param tz: Thermal zone descriptor
+ *
+ * Get the current temperature
+ * We have exactly one thermal zone/sensor
+ * Value passed is an unsigned long - our sensor reports up to -50 celsius so we
+ * just clip at zero if the temperature is negative.
+ */
+static int intel_cln_thermal_get_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TEMP_REG, (u32 *)temp, 1);
+	*temp -= RAW2CELSIUS_DIFF;
+
+	/* Clip to unsigned output value if sensor is reporting sub-zero */
+	if ((int)*temp < 0)
+		*temp = 0;
+
+	*temp = MCELSIUS(*temp&0x000000FF);
+
+	return 0;
+}
+
+/**
+ * get_trend
+ *
+ * Wears good clothes
+ */
+static int intel_cln_thermal_get_trend(struct thermal_zone_device *tz,
+			int trip, enum thermal_trend *trend)
+{
+	if (tz->temperature >= trip)
+		*trend = THERMAL_TREND_RAISING;
+	else
+		*trend = THERMAL_TREND_DROPPING;
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_mode
+ *
+ * Get the mode
+ */
+static int intel_cln_thermal_get_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode *mode)
+{
+	mutex_lock(&cln_tdev.lock);
+	*mode = cln_tdev.mode;
+	mutex_unlock(&cln_tdev.lock);
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_set_mode
+ *
+ * Set the mode
+ */
+static int intel_cln_thermal_set_mode(struct thermal_zone_device *tz,
+				enum thermal_device_mode mode)
+{
+	mutex_lock(&cln_tdev.lock);
+
+	if (mode == THERMAL_DEVICE_ENABLED)
+		cln_tdev.therm_dev->polling_delay = IDLE_INTERVAL;
+	else
+		cln_tdev.therm_dev->polling_delay = 0;
+	cln_tdev.mode = mode;
+
+	mutex_unlock(&cln_tdev.lock);
+
+	thermal_zone_device_update(cln_tdev.therm_dev);
+	pr_info("thermal polling set for duration=%d msec\n",
+				cln_tdev.therm_dev->polling_delay);
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_type
+ *
+ * Get trip type
+ */
+static int intel_cln_thermal_get_trip_type(struct thermal_zone_device *tz,
+				int trip, enum thermal_trip_type *type)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	*type = cln_tdev.tzone[trip].type;
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_temp
+ *
+ * Get trip temp
+ */
+static int intel_cln_thermal_get_trip_temp(struct thermal_zone_device *tz,
+				int trip, unsigned long *temp)
+{
+	if (trip < MIN_USED_ZONE || trip > MAX_USED_ZONE)
+		return -EINVAL;
+
+	/* Convert the temperature into millicelsius */
+	*temp = cln_tdev.tzone[trip].trip_value;
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_get_trip_type
+ *
+ * Get trip temp
+ */
+static int intel_cln_thermal_get_crit_temp(struct thermal_zone_device *tz,
+				unsigned long *temp)
+{
+	/* Critical zone */
+	*temp = cln_tdev.tzone[CATASTROPIC_ZONE].trip_value;
+	return 0;
+}
+
+static struct thermal_zone_device_ops intel_cln_thrm_dev_ops = {
+	.get_temp = intel_cln_thermal_get_temp,
+	.get_trend = intel_cln_thermal_get_trend,
+	.get_mode = intel_cln_thermal_get_mode,
+	.set_mode = intel_cln_thermal_set_mode,
+	.get_trip_type = intel_cln_thermal_get_trip_type,
+	.get_trip_temp = intel_cln_thermal_get_trip_temp,
+	.get_crit_temp = intel_cln_thermal_get_crit_temp,
+};
+
+
+
+/**
+ * intel_cln_init_zone
+ *
+ * Initialise a zone
+ */
+static void intel_cln_thermal_init_zone(struct intel_cln_therm_zone *tz,
+				enum thermal_trip_type type, int trip_value)
+{
+	tz->type = type;
+	tz->trip_value = MCELSIUS(trip_value);
+}
+
+/******************************************************************************
+ *                        Module Entry/Exit hooks
+ ******************************************************************************/
+
+/**
+ * intel_cln_thermal_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ *
+ * This routine registers a thermal device with the kernel's thermal management
+ * sub-system
+ */
+static int intel_cln_thermal_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	int critical_temp = 0, hot_temp = 0;
+	uint32_t regval = 0;
+
+	if (driver_enable == 0)
+		return 0;
+
+	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
+
+	critical_temp = CRIT_TEMP;
+	hot_temp = HOT_TEMP;
+
+	/* Enumerate zone type data */
+	memset(&cln_tdev, 0x00, sizeof(cln_tdev));
+	mutex_init(&cln_tdev.lock);
+
+	/* Set initial state disabled */
+	cln_tdev.mode = THERMAL_DEVICE_ENABLED;
+
+	intel_cln_thermal_init_zone(&cln_tdev.tzone[CATASTROPIC_ZONE],
+				  THERMAL_TRIP_CRITICAL, critical_temp);
+	intel_cln_thermal_init_zone(&cln_tdev.tzone[HOT_ZONE],
+				  THERMAL_TRIP_HOT, hot_temp);
+
+	/* Register a thermal zone */
+	cln_tdev.therm_dev = thermal_zone_device_register(DRIVER_NAME,
+			THRM_ZONE_COUNT, 0, 0, &intel_cln_thrm_dev_ops,
+			0, IDLE_INTERVAL, ACTIVE_INTERVAL);
+
+	if (IS_ERR(cln_tdev.therm_dev)) {
+		err = PTR_ERR(cln_tdev.therm_dev);
+		return err;
+	}
+
+	/* Read the BIOS configured hardware catastrophic trip temp */
+	sb_read(SB_ID_THERMAL, THRM_CTRL_READ, THRM_TRPCLR_REG, &regval, 1);
+	regval = (regval & 0xff) - 50;
+
+	pr_info("THRM: critical reset %d c hot %d c hardware failover %d c\n",
+		critical_temp, hot_temp, regval);
+
+	return 0;
+}
+
+/**
+ * intel_cln_thermal_remove
+ *
+ * @return 0 success < 0 failure
+ *
+ * Removes a platform device
+ */
+static int intel_cln_thermal_remove(struct platform_device *pdev)
+{
+	if (cln_tdev.therm_dev != NULL) {
+		thermal_zone_device_unregister(cln_tdev.therm_dev);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_cln_thermal_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = intel_cln_thermal_probe,
+	.remove = intel_cln_thermal_remove,
+};
+
+module_platform_driver(intel_cln_thermal_driver);
+
+
+MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Clanton Thermal driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/include/linux/intel_cln_sb.h b/include/linux/intel_cln_sb.h
new file mode 100644
index 0000000..6092fc0
--- /dev/null
+++ b/include/linux/intel_cln_sb.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton side-band driver
+ *
+ * Thread-safe sideband read/write routine.
+ *
+ * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com> 2012
+ */
+
+#ifndef __INTEL_CLN_SB_H__
+#define __INTEL_CLN_SB_H__
+
+#include <linux/types.h>
+
+typedef enum {
+	SB_ID_HUNIT = 0x03,
+	SB_ID_THERMAL = 0x04,
+	SB_ID_ESRAM = 0x05,
+	SB_ID_SOC = 0x31,
+}cln_sb_id;
+
+/**
+ * intel_cln_sb_read_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe read of side-band
+ * command - can be different read op-code types - which is why we don't
+ * hard-code this value directly into msg
+ */
+void intel_cln_sb_read_reg(cln_sb_id id, u8 cmd, u8 reg, u32 *data, u8 lock);
+
+/**
+ * intel_cln_sb_write_reg
+ *
+ * @param cln_sb_id: Sideband identifier
+ * @param command: Command to send to destination identifier
+ * @param reg: Target register w/r to cln_sb_id
+ * @return nothing
+ *
+ * Utility function to allow thread-safe write of side-band
+ */
+void intel_cln_sb_write_reg(cln_sb_id id, u8 cmd, u8 reg, u32 data, u8 lock);
+
+/**
+ * intel_cln_sb_runfn_lock
+ *
+ * @param fn: Callback function - which requires side-band spinlock and !irq
+ * @param arg: Callback argument
+ * @return 0 on success < 0 on failure
+ *
+ * Runs the given function pointer inside of a call to the local spinlock using
+ * spin_lock_irqsave/spin_unlock_irqrestore. Needed for the eSRAMv1 driver to
+ * guarantee atomicity, but, available to any other user of sideband provided
+ * rules are respected.
+ * Rules:
+ *	fn may not sleep
+ *	fn may not change the state of irqs	
+ */
+int intel_cln_sb_runfn_lock(int (*fn)( void * arg ), void * arg);
+
+/**
+ * intel_cln_sb_initialized
+ *
+ * False if sideband running on non-Clanton system
+ */
+int intel_cln_sb_initialized(void);
+
+#endif /* __INTEL_CLN_SB_H__ */
diff --git a/include/linux/platform_data/clanton.h b/include/linux/platform_data/clanton.h
new file mode 100644
index 0000000..bd24df0
--- /dev/null
+++ b/include/linux/platform_data/clanton.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Intel Clanton platform data definition
+ */
+
+#ifndef _PDATA_CLANTON_H
+#define _PDATA_CLANTON_H
+
+typedef enum  {
+	CLANTON_PLAT_UNDEFINED = 0,
+	CLANTON_EMULATION = 1,
+	CLANTON_PEAK = 2,
+	KIPS_BAY = 3,
+	CROSS_HILL = 4,
+	CLANTON_HILL = 5,
+	IZMIR = 6,
+}cln_plat_id_t;
+
+typedef enum {
+	PLAT_DATA_ID = 1,
+	PLAT_DATA_SN = 2,
+	PLAT_DATA_MAC0 = 3,
+	PLAT_DATA_MAC1 = 4,
+}plat_dataid_t;
+
+
+#ifdef CONFIG_INTEL_CLN_SOC
+extern cln_plat_id_t intel_cln_plat_get_id(void);
+extern int intel_cln_plat_get_mac(plat_dataid_t id, char * mac);
+#else
+static inline cln_plat_id_t intel_cln_plat_get_id(void)
+{
+	return CLANTON_PLAT_UNDEFINED;
+}
+static int intel_cln_plat_get_mac(plat_dataid_t id, char * mac)
+{
+	return -ENODEV;
+}
+#endif
+#endif /* _PDATA_CLANTON_H */
diff --git a/include/linux/platform_data/st_accel_i2c.h b/include/linux/platform_data/st_accel_i2c.h
new file mode 100644
index 0000000..1dc3d93
--- /dev/null
+++ b/include/linux/platform_data/st_accel_i2c.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright(c) 2013 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_ST_ACCEL_H__
+#define __LINUX_PLATFORM_DATA_ST_ACCEL_H__
+
+/**
+ * struct st_accel_i2c_platform_data - Platform data for the ST Micro accelerometer driver
+ * @irq2: IRQ number for the second INT pin.
+ **/
+struct st_accel_i2c_platform_data {
+	int irq2;
+};
+
+#endif /* LINUX_PLATFORM_DATA_ST_ACCEL_H_ */
-- 
1.7.5.4

