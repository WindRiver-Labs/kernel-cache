From a6ec061efd84279a3bf1c9fe18bfa6a1d6f4b11c Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Wed, 31 Jul 2013 10:21:30 +0800
Subject: [PATCH 1174/1187] Revert "stmmac: add the Energy Efficient Ethernet
 support"

This reverts commit 0e5b3d623333c52e1ded81ab98de673e0ede443b.

Conflicts:

	drivers/net/ethernet/stmicro/stmmac/common.h
	drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
	drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
	drivers/net/ethernet/stmicro/stmmac/stmmac.h
	drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
	drivers/net/ethernet/stmicro/stmmac/stmmac_main.c

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/common.h       |   20 +---
 drivers/net/ethernet/stmicro/stmmac/dwmac1000.h    |   20 ---
 .../net/ethernet/stmicro/stmmac/dwmac1000_core.c   |   97 +-----------
 .../net/ethernet/stmicro/stmmac/dwmac100_core.c    |    4 +-
 drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h    |    1 -
 drivers/net/ethernet/stmicro/stmmac/stmmac.h       |    9 -
 .../net/ethernet/stmicro/stmmac/stmmac_ethtool.c   |   54 -------
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c  |  168 ++------------------
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |    3 -
 .../net/ethernet/stmicro/stmmac/stmmac_platform.c  |    2 -
 10 files changed, 19 insertions(+), 359 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 26833ae..5051bba 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -117,12 +117,6 @@ struct stmmac_extra_stats {
 	unsigned long mmc_tx_irq_n;
 	unsigned long mmc_rx_irq_n;
 	unsigned long mmc_rx_csum_offload_irq_n;
-	/* EEE */
-	unsigned long irq_tx_path_in_lpi_mode_n;
-	unsigned long irq_tx_path_exit_lpi_mode_n;
-	unsigned long irq_rx_path_in_lpi_mode_n;
-	unsigned long irq_rx_path_exit_lpi_mode_n;
-	unsigned long phy_eee_wakeup_error_n;
 };
 
 /* CSR Frequency Access Defines*/
@@ -205,10 +199,6 @@ enum core_specific_irq_mask {
 	core_mmc_rx_irq = 2,
 	core_mmc_rx_csum_offload_irq = 4,
 	core_irq_receive_pmt_irq = 8,
-	core_irq_tx_path_in_lpi_mode = 16,
-	core_irq_tx_path_exit_lpi_mode = 32,
-	core_irq_rx_path_in_lpi_mode = 64,
-	core_irq_rx_path_exit_lpi_mode = 128,
 };
 
 /* DMA HW capabilities */
@@ -257,10 +247,6 @@ struct dma_features {
 #define MAC_ENABLE_TX		0x00000008	/* Transmitter Enable */
 #define MAC_RNABLE_RX		0x00000004	/* Receiver Enable */
 
-/* Default LPI timers */
-#define STMMAC_DEFAULT_LIT_LS_TIMER	0x3E8
-#define STMMAC_DEFAULT_TWT_LS_TIMER	0x0
-
 struct stmmac_desc_ops {
 	/* DMA RX descriptor ring initialization */
 	void (*init_rx_desc) (struct dma_desc *p, unsigned int ring_size,
@@ -334,7 +320,7 @@ struct stmmac_ops {
 	/* Dump MAC registers */
 	void (*dump_regs) (void __iomem *ioaddr);
 	/* Handle extra events on specific interrupts hw dependent */
-	int (*host_irq_status) (struct stmmac_priv * priv);
+	void (*host_irq_status) (struct stmmac_priv * priv);
 	/* Multicast filter setting */
 	void (*set_filter) (struct net_device *dev, int id);
 	/* Flow control setting */
@@ -350,10 +336,6 @@ struct stmmac_ops {
 	/* Enable/Disable VLAN Hash filters */
 	int (*vlan_rx_add_vid)(struct stmmac_priv *priv, unsigned short vid);
 	int (*vlan_rx_kill_vid)(struct stmmac_priv *priv, unsigned short vid);
-	void (*set_eee_mode) (void __iomem *ioaddr);
-	void (*reset_eee_mode) (void __iomem *ioaddr);
-	void (*set_eee_timer) (void __iomem *ioaddr, int ls, int tw);
-	void (*set_eee_pls) (void __iomem *ioaddr, int link);
 };
 
 struct mac_link {
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
index 3042098..f2e82dd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
@@ -38,7 +38,6 @@
 
 #define GMAC_INT_STATUS		0x00000038	/* interrupt status register */
 enum dwmac1000_irq_status {
-	lpiis_irq = 0x400,
 	time_stamp_irq = 0x0200,
 	mmc_rx_csum_offload_irq = 0x0080,
 	mmc_tx_irq = 0x0040,
@@ -70,25 +69,6 @@ enum power_event {
 	power_down = 0x00000001,
 };
 
-/* Energy Efficient Ethernet (EEE)
- *
- * LPI status, timer and control register offset
- */
-#define LPI_CTRL_STATUS	0x0030
-#define LPI_TIMER_CTRL	0x0034
-
-/* LPI control and status defines */
-#define LPI_CTRL_STATUS_LPITXA	0x00080000	/* Enable LPI TX Automate */
-#define LPI_CTRL_STATUS_PLSEN	0x00040000	/* Enable PHY Link Status */
-#define LPI_CTRL_STATUS_PLS	0x00020000	/* PHY Link Status */
-#define LPI_CTRL_STATUS_LPIEN	0x00010000	/* LPI Enable */
-#define LPI_CTRL_STATUS_RLPIST	0x00000200	/* Receive LPI state */
-#define LPI_CTRL_STATUS_TLPIST	0x00000100	/* Transmit LPI state */
-#define LPI_CTRL_STATUS_RLPIEX	0x00000008	/* Receive LPI Exit */
-#define LPI_CTRL_STATUS_RLPIEN	0x00000004	/* Receive LPI Entry */
-#define LPI_CTRL_STATUS_TLPIEX	0x00000002	/* Transmit LPI Exit */
-#define LPI_CTRL_STATUS_TLPIEN	0x00000001	/* Transmit LPI Entry */
-
 /* GMAC HW ADDR regs */
 #define GMAC_ADDR_HIGH(reg)	(((reg > 15) ? 0x00000800 : 0x00000040) + \
 				(reg * 8))
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index b6d04ca..830b9a9 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -203,66 +203,33 @@ static void dwmac1000_pmt(void __iomem *ioaddr, unsigned long mode)
 	writel(pmt, ioaddr + GMAC_PMT);
 }
 
-
 #ifndef CONFIG_STMMAC_PTP
 #define stmmac_ptp_check_pps_event(x){}
 #endif
 
-static int dwmac1000_irq_status(struct stmmac_priv *priv)
+static void dwmac1000_irq_status(struct stmmac_priv *priv)
 {
 	u32 intr_status = readl(priv->ioaddr + GMAC_INT_STATUS);
-	int status = 0;
 
 	/* Not used events (e.g. MMC interrupts) are not handled. */
-	if ((intr_status & mmc_tx_irq)) {
+	if ((intr_status & mmc_tx_irq))
 		CHIP_DBG(KERN_INFO "GMAC: MMC tx interrupt: 0x%08x\n",
 		    readl(priv->ioaddr + GMAC_MMC_TX_INTR));
-		status |= core_mmc_tx_irq;
-	}
-	if (unlikely(intr_status & mmc_rx_irq)) {
+	if (unlikely(intr_status & mmc_rx_irq))
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx interrupt: 0x%08x\n",
 		    readl(priv->ioaddr + GMAC_MMC_RX_INTR));
-		status |= core_mmc_rx_irq;
-	}
-	if (unlikely(intr_status & mmc_rx_csum_offload_irq)) {
+	if (unlikely(intr_status & mmc_rx_csum_offload_irq))
 		CHIP_DBG(KERN_INFO "GMAC: MMC rx csum offload: 0x%08x\n",
 		    readl(priv->ioaddr + GMAC_MMC_RX_CSUM_OFFLOAD));
-		status |= core_mmc_rx_csum_offload_irq;
-	}
 	if (unlikely(intr_status & pmt_irq)) {
-		CHIP_DBG(KERN_INFO "GMAC: received Magic frame\n");
+		CHIP_DBG(KERN_DEBUG "GMAC: received Magic frame\n");
 		/* clear the PMT bits 5 and 6 by reading the PMT
 		 * status register. */
 		readl(priv->ioaddr + GMAC_PMT);
-		status |= core_irq_receive_pmt_irq;
-	}
-	/* MAC trx/rx EEE LPI entry/exit interrupts */
-	if (intr_status & lpiis_irq) {
-		/* Clean LPI interrupt by reading the Reg 12 */
-		u32 lpi_status = readl(priv->ioaddr + LPI_CTRL_STATUS);
-
-		if (lpi_status & LPI_CTRL_STATUS_TLPIEN) {
-			CHIP_DBG(KERN_INFO "GMAC TX entered in LPI\n");
-			status |= core_irq_tx_path_in_lpi_mode;
-		}
-		if (lpi_status & LPI_CTRL_STATUS_TLPIEX) {
-			CHIP_DBG(KERN_INFO "GMAC TX exit from LPI\n");
-			status |= core_irq_tx_path_exit_lpi_mode;
-		}
-		if (lpi_status & LPI_CTRL_STATUS_RLPIEN) {
-			CHIP_DBG(KERN_INFO "GMAC RX entered in LPI\n");
-			status |= core_irq_rx_path_in_lpi_mode;
-		}
-		if (lpi_status & LPI_CTRL_STATUS_RLPIEX) {
-			CHIP_DBG(KERN_INFO "GMAC RX exit from LPI\n");
-			status |= core_irq_rx_path_exit_lpi_mode;
-		}
 	}
 	if (unlikely(intr_status & time_stamp_irq)){
 		stmmac_ptp_check_pps_event(priv);
 	}
-
-	return status;
 }
 
 static unsigned int dwmac1000_calc_vlan_4bit_crc ( const char * vlan )
@@ -362,56 +329,6 @@ static int dwmac1000_vlan_rx_kill_vid(struct stmmac_priv *priv, unsigned short v
 	return 0;
 }
 
-static void  dwmac1000_set_eee_mode(void __iomem *ioaddr)
-{
-	u32 value;
-
-	/* Enable the link status receive on RGMII, SGMII ore SMII
-	 * receive path and instruct the transmit to enter in LPI
-	 * state. */
-	value = readl(ioaddr + LPI_CTRL_STATUS);
-	value |= LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA;
-	writel(value, ioaddr + LPI_CTRL_STATUS);
-}
-
-static void  dwmac1000_reset_eee_mode(void __iomem *ioaddr)
-{
-	u32 value;
-
-	value = readl(ioaddr + LPI_CTRL_STATUS);
-	value &= ~(LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA);
-	writel(value, ioaddr + LPI_CTRL_STATUS);
-}
-
-static void  dwmac1000_set_eee_pls(void __iomem *ioaddr, int link)
-{
-	u32 value;
-
-	value = readl(ioaddr + LPI_CTRL_STATUS);
-
-	if (link)
-		value |= LPI_CTRL_STATUS_PLS;
-	else
-		value &= ~LPI_CTRL_STATUS_PLS;
-
-	writel(value, ioaddr + LPI_CTRL_STATUS);
-}
-
-static void  dwmac1000_set_eee_timer(void __iomem *ioaddr, int ls, int tw)
-{
-	int value = ((tw & 0xffff)) | ((ls & 0x7ff) << 16);
-
-	/* Program the timers in the LPI timer control register:
-	 * LS: minimum time (ms) for which the link
-	 *  status from PHY should be ok before transmitting
-	 *  the LPI pattern.
-	 * TW: minimum time (us) for which the core waits
-	 *  after it has stopped transmitting the LPI pattern.
-	 */
-	writel(value, ioaddr + LPI_TIMER_CTRL);
-}
-
-
 static const struct stmmac_ops dwmac1000_ops = {
 	.core_init = dwmac1000_core_init,
 	.set_rx_ipc = dwmac1000_set_rx_ipc,
@@ -424,10 +341,6 @@ static const struct stmmac_ops dwmac1000_ops = {
 	.get_umac_addr = dwmac1000_get_umac_addr,
 	.vlan_rx_add_vid = dwmac1000_vlan_rx_add_vid,
 	.vlan_rx_kill_vid = dwmac1000_vlan_rx_kill_vid,
-	.set_eee_mode =  dwmac1000_set_eee_mode,
-	.reset_eee_mode =  dwmac1000_reset_eee_mode,
-	.set_eee_timer =  dwmac1000_set_eee_timer,
-	.set_eee_pls =  dwmac1000_set_eee_pls,
 };
 
 struct mac_device_info *dwmac1000_setup(void __iomem *ioaddr)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
index 43472c0..0763a8d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
@@ -72,9 +72,9 @@ static int dwmac100_set_rx_ipc(void __iomem *ioaddr, bool on)
 	return 0;
 }
 
-static int dwmac100_irq_status(struct stmmac_priv *priv)
+static void dwmac100_irq_status(struct stmmac_priv *priv)
 {
-	return 0;
+	return;
 }
 
 static void dwmac100_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h b/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h
index ab4896e..6b0026b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac_dma.h
@@ -76,7 +76,6 @@
 #define DMA_INTR_DEFAULT_MASK	(DMA_INTR_NORMAL | DMA_INTR_ABNORMAL)
 
 /* DMA Status register defines */
-#define DMA_STATUS_GLPII	0x40000000	/* GMAC LPI interrupt */
 #define DMA_STATUS_GPI		0x10000000	/* PMT interrupt */
 #define DMA_STATUS_GMI		0x08000000	/* MMC interrupt */
 #define DMA_STATUS_GLI		0x04000000	/* GMAC Line interface int */
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 066d734..7a2f7d1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -100,12 +100,6 @@ struct stmmac_priv {
 	int synopsys_id;
 	int irqmode_msi;
 	struct pci_dev * pdev;
-	struct timer_list eee_ctrl_timer;
-	bool tx_path_in_lpi_mode;
-	int lpi_irq;
-	int eee_enabled;
-	int eee_active;
-	int tx_lpi_timer;
 	struct timer_list txtimer;
 	u32 tx_count_frames;
 	u32 tx_coal_frames;
@@ -186,9 +180,6 @@ static inline int stmmac_clk_get(struct stmmac_priv *priv)
 }
 #endif /* CONFIG_HAVE_CLK */
 
-void stmmac_disable_eee_mode(struct stmmac_priv *priv);
-bool stmmac_eee_init(struct stmmac_priv *priv);
-
 #ifdef CONFIG_STMMAC_PLATFORM
 extern struct platform_driver stmmac_pltfr_driver;
 static inline int stmmac_register_platform(void)
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 0644dcd..71caf0a7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -103,12 +103,6 @@ static const struct stmmac_stats stmmac_gstrings_stats[] = {
 	STMMAC_STAT(mmc_tx_irq_n),
 	STMMAC_STAT(mmc_rx_irq_n),
 	STMMAC_STAT(mmc_rx_csum_offload_irq_n),
-	/* EEE */
-	STMMAC_STAT(irq_tx_path_in_lpi_mode_n),
-	STMMAC_STAT(irq_tx_path_exit_lpi_mode_n),
-	STMMAC_STAT(irq_rx_path_in_lpi_mode_n),
-	STMMAC_STAT(irq_rx_path_exit_lpi_mode_n),
-	STMMAC_STAT(phy_eee_wakeup_error_n),
 };
 #define STMMAC_STATS_LEN ARRAY_SIZE(stmmac_gstrings_stats)
 
@@ -388,11 +382,6 @@ static void stmmac_get_ethtool_stats(struct net_device *dev,
 					     (*(u32 *)p);
 			}
 		}
-		if (priv->eee_enabled) {
-			int val = phy_get_eee_err(priv->phydev);
-			if (val)
-				priv->xstats.phy_eee_wakeup_error_n = val;
-		}
 	}
 	for (i = 0; i < STMMAC_STATS_LEN; i++) {
 		char *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;
@@ -491,46 +480,6 @@ static int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	return 0;
 }
 
-static int stmmac_ethtool_op_get_eee(struct net_device *dev,
-				     struct ethtool_eee *edata)
-{
-	struct stmmac_priv *priv = netdev_priv(dev);
-
-	if (!priv->dma_cap.eee)
-		return -EOPNOTSUPP;
-
-	edata->eee_enabled = priv->eee_enabled;
-	edata->eee_active = priv->eee_active;
-	edata->tx_lpi_timer = priv->tx_lpi_timer;
-
-	return phy_ethtool_get_eee(priv->phydev, edata);
-}
-
-static int stmmac_ethtool_op_set_eee(struct net_device *dev,
-				     struct ethtool_eee *edata)
-{
-	struct stmmac_priv *priv = netdev_priv(dev);
-
-	priv->eee_enabled = edata->eee_enabled;
-
-	if (!priv->eee_enabled)
-		stmmac_disable_eee_mode(priv);
-	else {
-		/* We are asking for enabling the EEE but it is safe
-		 * to verify all by invoking the eee_init function.
-		 * In case of failure it will return an error.
-		 */
-		priv->eee_enabled = stmmac_eee_init(priv);
-		if (!priv->eee_enabled)
-			return -EOPNOTSUPP;
-
-		/* Do not change tx_lpi_timer in case of failure */
-		priv->tx_lpi_timer = edata->tx_lpi_timer;
-	}
-
-	return phy_ethtool_set_eee(priv->phydev, edata);
-}
-
 static u32 stmmac_usec2riwt(u32 usec, struct stmmac_priv *priv)
 {
 	unsigned long clk = clk_get_rate(priv->stmmac_clk);
@@ -628,10 +577,7 @@ static const struct ethtool_ops stmmac_ethtool_ops = {
 	.get_strings = stmmac_get_strings,
 	.get_wol = stmmac_get_wol,
 	.set_wol = stmmac_set_wol,
-	.get_eee = stmmac_ethtool_op_get_eee,
-	.set_eee = stmmac_ethtool_op_set_eee,
 	.get_sset_count	= stmmac_get_sset_count,
-	.get_ts_info = ethtool_op_get_ts_info,
 	.get_coalesce = stmmac_get_coalesce,
 	.set_coalesce = stmmac_set_coalesce,
 };
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 90e3219..661d49e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -127,12 +127,6 @@ static const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
 				      NETIF_MSG_LINK | NETIF_MSG_IFUP |
 				      NETIF_MSG_IFDOWN | NETIF_MSG_TIMER);
 
-#define STMMAC_DEFAULT_LPI_TIMER	1000
-static int eee_timer = STMMAC_DEFAULT_LPI_TIMER;
-module_param(eee_timer, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(eee_timer, "LPI tx expiration time in msec");
-#define STMMAC_LPI_TIMER(x) (jiffies + msecs_to_jiffies(x))
-
 static irqreturn_t stmmac_interrupt(int irq, void *dev_id);
 
 #ifdef CONFIG_STMMAC_DEBUG_FS
@@ -165,8 +159,6 @@ static void stmmac_verify_args(void)
 		flow_ctrl = FLOW_OFF;
 	if (unlikely((pause < 0) || (pause > 0xffff)))
 		pause = PAUSE_TIME;
-	if (eee_timer < 0)
-		eee_timer = STMMAC_DEFAULT_LPI_TIMER;
 }
 
 static void stmmac_clk_csr_set(struct stmmac_priv *priv)
@@ -230,85 +222,6 @@ static inline void stmmac_hw_fix_mac_speed(struct stmmac_priv *priv)
 					  phydev->speed);
 }
 
-static void stmmac_enable_eee_mode(struct stmmac_priv *priv)
-{
-	/* Check and enter in LPI mode */
-	if ((priv->dirty_tx == priv->cur_tx) &&
-	    (priv->tx_path_in_lpi_mode == false))
-		priv->hw->mac->set_eee_mode(priv->ioaddr);
-}
-
-void stmmac_disable_eee_mode(struct stmmac_priv *priv)
-{
-	/* Exit and disable EEE in case of we are are in LPI state. */
-	priv->hw->mac->reset_eee_mode(priv->ioaddr);
-	del_timer_sync(&priv->eee_ctrl_timer);
-	priv->tx_path_in_lpi_mode = false;
-}
-
-/**
- * stmmac_eee_ctrl_timer
- * @arg : data hook
- * Description:
- *  If there is no data transfer and if we are not in LPI state,
- *  then MAC Transmitter can be moved to LPI state.
- */
-static void stmmac_eee_ctrl_timer(unsigned long arg)
-{
-	struct stmmac_priv *priv = (struct stmmac_priv *)arg;
-
-	stmmac_enable_eee_mode(priv);
-	mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_TIMER(eee_timer));
-}
-
-/**
- * stmmac_eee_init
- * @priv: private device pointer
- * Description:
- *  If the EEE support has been enabled while configuring the driver,
- *  if the GMAC actually supports the EEE (from the HW cap reg) and the
- *  phy can also manage EEE, so enable the LPI state and start the timer
- *  to verify if the tx path can enter in LPI state.
- */
-bool stmmac_eee_init(struct stmmac_priv *priv)
-{
-	bool ret = false;
-
-	/* MAC core supports the EEE feature. */
-	if (priv->dma_cap.eee) {
-		/* Check if the PHY supports EEE */
-		if (phy_init_eee(priv->phydev, 1))
-			goto out;
-
-		priv->eee_active = 1;
-		init_timer(&priv->eee_ctrl_timer);
-		priv->eee_ctrl_timer.function = stmmac_eee_ctrl_timer;
-		priv->eee_ctrl_timer.data = (unsigned long)priv;
-		priv->eee_ctrl_timer.expires = STMMAC_LPI_TIMER(eee_timer);
-		add_timer(&priv->eee_ctrl_timer);
-
-		priv->hw->mac->set_eee_timer(priv->ioaddr,
-					     STMMAC_DEFAULT_LIT_LS_TIMER,
-					     priv->tx_lpi_timer);
-
-		pr_info("stmmac: Energy-Efficient Ethernet initialized\n");
-
-		ret = true;
-	}
-out:
-	return ret;
-}
-
-static void stmmac_eee_adjust(struct stmmac_priv *priv)
-{
-	/* When the EEE has been already initialised we have to
-	 * modify the PLS bit in the LPI ctrl & status reg according
-	 * to the PHY link status. For this reason.
-	 */
-	if (priv->eee_enabled)
-		priv->hw->mac->set_eee_pls(priv->ioaddr, priv->phydev->link);
-}
-
 /**
  * stmmac_adjust_link
  * @dev: net device structure
@@ -329,7 +242,6 @@ static void stmmac_adjust_link(struct net_device *dev)
 	    phydev->addr, phydev->link);
 
 	spin_lock_irqsave(&priv->lock, flags);
-
 	if (phydev->link) {
 		u32 ctrl = readl(priv->ioaddr + MAC_CTRL_REG);
 
@@ -396,8 +308,6 @@ static void stmmac_adjust_link(struct net_device *dev)
 	if (new_state && netif_msg_link(priv))
 		phy_print_status(phydev);
 
-	stmmac_eee_adjust(priv);
-
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	DBG(probe, DEBUG, "stmmac_adjust_link: exiting\n");
@@ -415,7 +325,7 @@ static int stmmac_init_phy(struct net_device *dev)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 	struct phy_device *phydev;
-	char phy_id_fmt[MII_BUS_ID_SIZE + 3];
+	char phy_id[MII_BUS_ID_SIZE + 3];
 	char bus_id[MII_BUS_ID_SIZE];
 	int interface = priv->plat->interface;
 	priv->oldlink = 0;
@@ -429,12 +339,11 @@ static int stmmac_init_phy(struct net_device *dev)
 		snprintf(bus_id, MII_BUS_ID_SIZE, "stmmac-%x",
 				priv->plat->bus_id);
 
-	snprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
 		 priv->plat->phy_addr);
-	pr_debug("stmmac_init_phy:  trying to attach to %s\n", phy_id_fmt);
+	pr_debug("stmmac_init_phy:  trying to attach to %s\n", phy_id);
 
-	phydev = phy_connect(dev, phy_id_fmt, &stmmac_adjust_link, 0,
-			     interface);
+	phydev = phy_connect(dev, phy_id, &stmmac_adjust_link, 0, interface);
 
 	if (IS_ERR(phydev)) {
 		pr_err("%s: Could not attach to PHY\n", dev->name);
@@ -808,11 +717,6 @@ static void stmmac_tx_clean(struct stmmac_priv *priv)
 		}
 		netif_tx_unlock(priv->dev);
 	}
-
-	if ((priv->eee_enabled) && (!priv->tx_path_in_lpi_mode)) {
-		stmmac_enable_eee_mode(priv);
-		mod_timer(&priv->eee_ctrl_timer, STMMAC_LPI_TIMER(eee_timer));
-	}
 	spin_unlock(&priv->tx_lock);
 }
 
@@ -1138,17 +1042,6 @@ static int stmmac_open(struct net_device *dev)
 		}
 	}
 
-	/* Request the IRQ lines */
-	if (priv->lpi_irq != -ENXIO) {
-		ret = request_irq(priv->lpi_irq, stmmac_interrupt, IRQF_SHARED,
-				  dev->name, dev);
-		if (unlikely(ret < 0)) {
-			pr_err("%s: ERROR: allocating the LPI IRQ %d (%d)\n",
-			       __func__, priv->lpi_irq, ret);
-			goto open_error_lpiirq;
-		}
-	}
-
 	/* Enable the MAC Rx/Tx */
 	stmmac_set_mac(priv->ioaddr, true);
 
@@ -1186,9 +1079,6 @@ static int stmmac_open(struct net_device *dev)
 	if (priv->phydev)
 		phy_start(priv->phydev);
 
-	priv->tx_lpi_timer = STMMAC_DEFAULT_TWT_LS_TIMER;
-	priv->eee_enabled = stmmac_eee_init(priv);
-
 	stmmac_init_tx_coalesce(priv);
 
 	if ((priv->use_riwt) && (priv->hw->dma->rx_watchdog)) {
@@ -1202,10 +1092,6 @@ static int stmmac_open(struct net_device *dev)
 
 	return 0;
 
-open_error_lpiirq:
-	if (priv->wol_irq != dev->irq)
-		free_irq(priv->wol_irq, dev);
-
 open_error_wolirq:
 	free_irq(dev->irq, dev);
 
@@ -1228,9 +1114,6 @@ static int stmmac_release(struct net_device *dev)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 
-	if (priv->eee_enabled)
-		del_timer_sync(&priv->eee_ctrl_timer);
-
 	/* Stop and disconnect the PHY */
 	if (priv->phydev) {
 		phy_stop(priv->phydev);
@@ -1249,8 +1132,6 @@ static int stmmac_release(struct net_device *dev)
 	free_irq(dev->irq, dev);
 	if (priv->wol_irq != dev->irq)
 		free_irq(priv->wol_irq, dev);
-	if (priv->lpi_irq != -ENXIO)
-		free_irq(priv->lpi_irq, dev);
 
 	/* Stop TX/RX DMA and clear the descriptors */
 	priv->hw->dma->stop_tx(priv->ioaddr);
@@ -1300,9 +1181,6 @@ static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	spin_lock(&priv->tx_lock);
 
-	if (priv->tx_path_in_lpi_mode)
-		stmmac_disable_eee_mode(priv);
-
 	entry = priv->cur_tx % txsize;
 
 #ifdef STMMAC_XMIT_DEBUG
@@ -1705,36 +1583,10 @@ static irqreturn_t stmmac_interrupt(int irq, void *dev_id)
 	mask_pvm(priv->pdev);
 
 	/* To handle GMAC own interrupts */
-	if (priv->plat->has_gmac) {
-		int status = priv->hw->mac->host_irq_status(priv);
-
-		if (unlikely(status)) {
-			if (status & core_mmc_tx_irq)
-				priv->xstats.mmc_tx_irq_n++;
-			if (status & core_mmc_rx_irq)
-				priv->xstats.mmc_rx_irq_n++;
-			if (status & core_mmc_rx_csum_offload_irq)
-				priv->xstats.mmc_rx_csum_offload_irq_n++;
-			if (status & core_irq_receive_pmt_irq)
-				priv->xstats.irq_receive_pmt_irq_n++;
-
-			/* For LPI we need to save the tx status */
-			if (status & core_irq_tx_path_in_lpi_mode) {
-				priv->xstats.irq_tx_path_in_lpi_mode_n++;
-				priv->tx_path_in_lpi_mode = true;
-			}
-			if (status & core_irq_tx_path_exit_lpi_mode) {
-				priv->xstats.irq_tx_path_exit_lpi_mode_n++;
-				priv->tx_path_in_lpi_mode = false;
-			}
-			if (status & core_irq_rx_path_in_lpi_mode)
-				priv->xstats.irq_rx_path_in_lpi_mode_n++;
-			if (status & core_irq_rx_path_exit_lpi_mode)
-				priv->xstats.irq_rx_path_exit_lpi_mode_n++;
-		}
-	}
+	if (priv->plat->has_gmac)
+		/* To handle GMAC own interrupts */
+		priv->hw->mac->host_irq_status(priv);
 
-	/* To handle DMA interrupts */
 	stmmac_dma_interrupt(priv);
 
 	unmask_pvm(priv->pdev);
@@ -2397,9 +2249,11 @@ static int __init stmmac_cmdline_opt(char *str)
 		} else if (!strncmp(opt, "pause:", 6)) {
 			if (kstrtoint(opt + 6, 0, &pause))
 				goto err;
-		} else if (!strncmp(opt, "eee_timer:", 6)) {
-			if (kstrtoint(opt + 10, 0, &eee_timer))
+#ifdef CONFIG_STMMAC_TIMER
+		} else if (!strncmp(opt, "tmrate:", 7)) {
+			if (kstrtoint(opt + 7, 0, &tmrate))
 				goto err;
+#endif
 		}
 	}
 	return 0;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index fe76d67..63c6272 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -285,9 +285,6 @@ static int stmmac_pci_probe(struct pci_dev *pdev,
 	priv->wol_irq = pdev->irq;
 	priv->irqmode_msi = enable_msi;
 	priv->pdev = pdev;
-	#ifdef CONFIG_INTEL_CLN_SOC
-	priv->lpi_irq = -ENXIO;
-	#endif
 	pci_set_drvdata(pdev, priv->dev);
 
 	pr_debug("STMMAC platform driver registration completed");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index b77b913..509155d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -149,8 +149,6 @@ static int stmmac_pltfr_probe(struct platform_device *pdev)
 	if (priv->wol_irq == -ENXIO)
 		priv->wol_irq = priv->dev->irq;
 
-	priv->lpi_irq = platform_get_irq_byname(pdev, "eth_lpi");
-
 	platform_set_drvdata(pdev, priv->dev);
 
 	pr_debug("STMMAC platform driver registration completed");
-- 
1.7.5.4

