From 70e2ba3dd4ce120a62b739c9633fb09ec3b9aaa8 Mon Sep 17 00:00:00 2001
From: Mihai Ene <mihai.ene@windriver.com>
Date: Mon, 18 Aug 2014 19:19:02 +0300
Subject: [PATCH] quark: add aiot-x1000 platform support

The aiot-x1000 platform (see http://www.aaeon.com)
requires the addition of the following items:

  - two ethernet interface
  - SLB9645TT TPM
  - Fintek F75111 gpio

Signed-off-by: Mihai Ene <mihai.ene@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |   10 +
 drivers/platform/x86/quark/Makefile                |    1 +
 drivers/platform/x86/quark/intel_qrk_board_data.c  |    4 +
 .../platform/x86/quark/intel_qrk_plat_aiot_x1000.c |  647 ++++++++++++++++++++
 .../platform/x86/quark/intel_qrk_plat_cross_hill.c |    2 +-
 5 files changed, 663 insertions(+), 1 deletions(-)
 create mode 100644 drivers/platform/x86/quark/intel_qrk_plat_aiot_x1000.c

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 1348361..45ab69c 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -134,6 +134,16 @@ static struct stmmac_qrk_mac_data phy_data [] = {
 		.bus_id		= 2,
 		.name		= "EcsGen2",
 	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "AiotX1000",
+	},
+	{
+		.phy_addr 	= 1,
+		.bus_id		= 2,
+		.name		= "AiotX1000",
+	},
 };
 
 
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index f6135e8..2cc5c75 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_sb.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_kernel.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_ecsgen2.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_aiot_x1000.o
 obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_imr_test.o
 obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram_test.o
diff --git a/drivers/platform/x86/quark/intel_qrk_board_data.c b/drivers/platform/x86/quark/intel_qrk_board_data.c
index 83d7e23..e5c66db 100644
--- a/drivers/platform/x86/quark/intel_qrk_board_data.c
+++ b/drivers/platform/x86/quark/intel_qrk_board_data.c
@@ -135,6 +135,10 @@ static struct platform_device bsp_data [] = {
 		.name	= "EcsGen2",
 		.id	= -1,
 	},
+	{
+		.name	= "AiotX1000",
+		.id	= -1,
+	},
 };
 
 /**
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_aiot_x1000.c b/drivers/platform/x86/quark/intel_qrk_plat_aiot_x1000.c
new file mode 100644
index 0000000..708c784
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_aiot_x1000.c
@@ -0,0 +1,647 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ * Copyright(c) 2014 Wind River System.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Wind River Systems, Inc
+ */
+/*
+ * AiotX1000 board entry point
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_data/tpm_i2c_infenion.h>
+
+#define DRIVER_NAME		"AiotX1000"
+#define GPIO_RESTRICT_NAME_NC	"qrk-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC	"qrk-gpio-restrict-sc"
+
+/*
+ * GPIO numbers to use for reading 4-bit Blackburn Peak SPI daughterboard ID
+ */
+#define SPI_BPEAK_RESET_GPIO 4
+#define SPI_BPEAK_ID0_GPIO   3
+#define SPI_BPEAK_ID1_GPIO   2
+#define SPI_BPEAK_ID2_GPIO   15
+#define SPI_BPEAK_ID3_GPIO   14
+
+/*
+ * GPIO number for eADC interrupt (MAX78M6610+LMU)
+ */
+#define GPIO_78M6610_INT	2
+
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
+static int aiot_x1000_probe;
+/*
+ * GPIOs used as interrupts by MAX78M6610+LMU eADC
+ *
+ * Extend this array adding new elements at the end.
+ */
+static struct gpio crh_eadc_int_gpios[] = {
+	{
+		GPIO_78M6610_INT,
+		GPIOF_IN,
+		"max78m6610-int"
+	},
+};
+
+/*
+ * Blackburn Peak SPI daughterboard ID values
+ */
+enum {
+	QRK_SPI_BPEAK_ID_ZB_TI = 0xA,
+	QRK_SPI_BPEAK_ID_ZB_DIGI,
+	QRK_SPI_BPEAK_ID_ZB_INFR_NXP,
+	QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL,
+	QRK_SPI_BPEAK_ID_ADC_MAXIM,
+	QRK_SPI_BPEAK_ID_NONE
+};
+
+/* GPIO line used to reset SLB9645TT */
+#define GPIO_SLB9645TT_RESET		7
+/* GPIO line SLB9645TT interrupt are routed to */
+#define GPIO_SLB9645TT_INT		0
+
+#define SLB9645TT_ADDR			0x20
+
+static struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
+	.gpio_reset = GPIO_SLB9645TT_RESET,
+	.gpio_irq = GPIO_SLB9645TT_INT,
+};
+
+static struct i2c_board_info probed_slb9645tt = {
+	.platform_data = &slb9645tt_platform_data,
+};
+
+static const unsigned short slb9645tt_i2c_addr[] =
+	{ SLB9645TT_ADDR, I2C_CLIENT_END };
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_SLB9645TT_RESET,
+		GPIOF_OUT_INIT_HIGH,
+		"slb96455tt-reset",
+	},
+	{
+		GPIO_SLB9645TT_INT,
+		GPIOF_IN,
+		"slb96455tt-int",
+	},
+};
+
+/******************************************************************************
+ *             Fintec F75111 GPIO SPI Device Platform Data
+ ******************************************************************************/
+#include <linux/f75111.h>
+
+#define F75111_ADDR		0x37
+
+/*
+ * GPIO
+ */
+static struct f75111_gpio aiot_x1000_gpios[] = {
+	{
+		.pin = F75111_GP10,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP11,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP12,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP14,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP15,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP16,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP17,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP20,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP21,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP22,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP23,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP24,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP25,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP26,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP27,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+	{
+		.pin = F75111_GP30,
+		.mode = F75111_PIN_MODE_GPIO,
+	},
+};
+
+static struct f75111_pdata aiot_x1000_f75111_data = {
+	.gpio_base = 16,
+	.gpios = aiot_x1000_gpios,
+	.size = ARRAY_SIZE(aiot_x1000_gpios),
+	.leds_data = NULL,
+};
+
+static struct i2c_board_info probed_f75111 = {
+		.platform_data = &aiot_x1000_f75111_data,
+};
+
+static const unsigned short f75111_i2c_addr[] =
+	{ F75111_ADDR, I2C_CLIENT_END };
+
+/******************************************************************************
+ *             Analog Devices AD7298 SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/ad7298.h"
+
+/* Maximum input voltage allowed for each ADC input, in milliVolts */
+#define AD7298_MAX_EXT_VIN 5000
+
+static const struct ad7298_platform_data ad7298_platform_data = {
+	.ext_ref = false,
+	.ext_vin_max = { AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN,
+		AD7298_MAX_EXT_VIN, AD7298_MAX_EXT_VIN }
+};
+
+/******************************************************************************
+ *             Maxim 78M6610+LMU SPI Device Platform Data
+ ******************************************************************************/
+#include "linux/platform_data/max78m6610_lmu.h"
+
+static const struct max78m6610_lmu_platform_data max78m6610_lmu_pdata = {
+	.reset_gpio = SPI_BPEAK_RESET_GPIO,
+};
+
+/******************************************************************************
+ *                 Intel Quark SPI Controller Data
+ ******************************************************************************/
+static struct pxa2xx_spi_chip qrk_ffrd_spi_0_cs_0 = {
+	.gpio_cs = 8,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_0 = {
+	.gpio_cs = 10,
+};
+
+static struct pxa2xx_spi_chip qrk_ffrd_spi_1_cs_1 = {
+	.gpio_cs = 11,
+};
+
+static struct spi_board_info spi_generic_devs[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+	},
+
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 50000000,
+		.platform_data = NULL,
+		.mode = SPI_MODE_0,
+		.bus_num = 1,
+		.chip_select = 1,
+		.controller_data = &qrk_ffrd_spi_1_cs_1,
+	},
+
+};
+
+/* For compatibility reason, new SPI energy modules must be added at the end */
+static struct spi_board_info spi_energy_adc_devs[] = {
+	{
+		.modalias = "max78m6610_lmu",
+		.max_speed_hz = 2000000,
+		.platform_data = &max78m6610_lmu_pdata,
+		.mode = SPI_MODE_3,
+		.bus_num = 1,
+		.chip_select = 0,
+		.controller_data = &qrk_ffrd_spi_1_cs_0,
+		.irq = -1,
+	},
+};
+
+static int slb9645tt_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return gpio_get_value(GPIO_SLB9645TT_RESET);
+}
+
+static int intel_qrk_slb9645tt_probe(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_client *slb9645tt;
+	int ret;
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		pr_err("%s: unable to reserve the GPIOs for slb9645tt\n",
+			__func__);
+		return ret;
+	}
+
+	probed_slb9645tt.irq = gpio_to_irq(GPIO_SLB9645TT_INT);
+
+	strlcpy(probed_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
+	slb9645tt = i2c_new_probed_device(i2c_adap, &probed_slb9645tt,
+					  slb9645tt_i2c_addr, slb9645tt_i2c_probe);
+
+	if (!slb9645tt) {
+		pr_err("%s: can't probe slb9645tt\n", __func__);
+		ret = -ENODEV;
+		goto err;
+        }
+
+	return 0;
+err:
+	gpio_free_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	return ret;
+}
+
+static int f75111_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return 1;
+}
+
+static int intel_qrk_f75111_probe(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_client *f75111;
+	int ret;
+
+	strlcpy(probed_f75111.type, "f75111", I2C_NAME_SIZE);
+	f75111 = i2c_new_probed_device(i2c_adap, &probed_f75111,
+					f75111_i2c_addr, f75111_i2c_probe);
+
+	if (!f75111) {
+		pr_err("%s: can't probe f75111\n", __func__);
+		ret = -ENODEV;
+		goto err;
+        }
+
+	return 0;
+err:
+	return ret;
+}
+
+/**
+ * intel_qrk_spi_add_onboard_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers onboard SPI device(s) present on the Aiot X1000 platform
+ */
+static int intel_qrk_spi_add_onboard_devs(void)
+{
+	struct spi_board_info spi_onboard_devs[] = {
+		{
+			.modalias = "ad7298",
+			.max_speed_hz = 5000000,
+			.platform_data = &ad7298_platform_data,
+			.mode = SPI_MODE_2,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &qrk_ffrd_spi_0_cs_0,
+		},
+	};
+
+	return spi_register_board_info(spi_onboard_devs,
+			ARRAY_SIZE(spi_onboard_devs));
+}
+
+
+/**
+ * intel_qrk_spi_get_bpeak_id
+ *
+ * @param bpeak_id: The Blackburn Peak SPI ID obtained from the daughterboard
+ * @return 0 on success or standard errnos on failure
+ *
+ * Reads an ID from GPIO-connected pins on Blackburn peak SPI daughterboard
+ */
+static int intel_qrk_spi_get_bpeak_id(u8 *bpeak_id)
+{
+	int ret = 0;
+	struct gpio spi_bpeak_id_gpios[] = {
+		{
+			SPI_BPEAK_RESET_GPIO,
+			GPIOF_OUT_INIT_HIGH,
+			"spi_bpeak_reset"
+		},
+		{
+			SPI_BPEAK_ID0_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id0"
+		},
+		{
+			SPI_BPEAK_ID1_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id1"
+		},
+		{
+			SPI_BPEAK_ID2_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id2"
+		},
+		{
+			SPI_BPEAK_ID3_GPIO,
+			GPIOF_IN,
+			"spi_bpeak_id3"
+		}
+	};
+
+	/*
+	 * Read a 4-bit ID value from ID GPIO inputs, which are only valid
+	 * while a RESET GPIO output is asserted (active-low)
+	 */
+	ret = gpio_request_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate Blackburn Peak ID GPIO pins\n",
+				__func__);
+		return ret;
+	}
+
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 0);
+	*bpeak_id =
+		(gpio_get_value(SPI_BPEAK_ID3_GPIO) ? 1 << 3 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID2_GPIO) ? 1 << 2 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID1_GPIO) ? 1 << 1 : 0) |
+		(gpio_get_value(SPI_BPEAK_ID0_GPIO) ? 1      : 0);
+	gpio_set_value(SPI_BPEAK_RESET_GPIO, 1);
+
+	gpio_free_array(spi_bpeak_id_gpios,
+			ARRAY_SIZE(spi_bpeak_id_gpios));
+
+	return 0;
+}
+
+/**
+ * intel_qrk_spi_add_bpeak_devs
+ *
+ * @return 0 on success or standard errnos on failure
+ *
+ * Registers SPI device(s) indicated by the ID value obtained from a
+ * Blackburn Peak SPI daughterboard
+ */
+static int intel_qrk_spi_add_bpeak_devs(void)
+{
+	u8 spi_bpeak_id = 0;
+	int ret = 0;
+
+	ret = intel_qrk_spi_get_bpeak_id(&spi_bpeak_id);
+	if (ret) {
+		pr_err("%s: failed to obtain Blackburn Peak ID\n",
+				__func__);
+		return ret;
+	}
+
+	switch (spi_bpeak_id) {
+
+	case QRK_SPI_BPEAK_ID_NONE:
+		break;
+
+	case QRK_SPI_BPEAK_ID_ADC_MAXIM:
+		{
+			ret = gpio_request_array(crh_eadc_int_gpios,
+					ARRAY_SIZE(crh_eadc_int_gpios));
+			if (ret) {
+				pr_err("%s: Failed to allocate eADC interrupt GPIO pins!\n",
+						__func__);
+				return ret;
+			}
+			ret = gpio_to_irq(GPIO_78M6610_INT);
+			if (ret < 0) {
+				pr_err("%s: Failed to request IRQ for GPIO %u!\n",
+						__func__, GPIO_78M6610_INT);
+				goto error_gpio_free;
+			}
+			spi_energy_adc_devs[0].irq = ret;
+			ret = spi_register_board_info(spi_energy_adc_devs,
+					ARRAY_SIZE(spi_energy_adc_devs));
+			if (ret) {
+				pr_err("%s: Failed to register eADC module!\n",
+						__func__);
+				goto error_gpio_free;
+			}
+			return 0;
+error_gpio_free:
+			gpio_free_array(crh_eadc_int_gpios,
+					ARRAY_SIZE(crh_eadc_int_gpios));
+			spi_energy_adc_devs[0].irq = -1;
+			return ret;
+		}
+	case QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL:
+		{
+			pr_debug("QRK_SPI_BPEAK_ID_ZB_EXEGIN_ATMEL.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+		}
+	case QRK_SPI_BPEAK_ID_ZB_DIGI:
+		{
+			pr_debug("QRK_SPI_BPEAK_ID_ZB_DIGI load.\n");
+			return spi_register_board_info(spi_generic_devs,
+					ARRAY_SIZE(spi_generic_devs));
+
+		}
+	default:
+			pr_err("%s: Unsupported Blackburn Peak SPI ID %u\n",
+					__func__, spi_bpeak_id);
+			ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/** intel_qrk_spi_devs_addon
+ *
+ * addon spi device when gpio support in place
+ */
+static int intel_qrk_spi_devs_addon(void)
+{
+	int ret = 0;
+
+	if (aiot_x1000_probe != 1) {
+
+		ret = intel_qrk_spi_add_onboard_devs();
+		if (ret)
+			return ret;
+
+		ret = intel_qrk_spi_add_bpeak_devs();
+
+		aiot_x1000_probe = 1;
+	}
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_nc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	int ret;
+	nc_gpio_reg = 1;
+        struct i2c_adapter *i2c_adap;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_qrk_spi_devs_addon();
+		if (ret)
+			return ret;
+
+                i2c_adap = i2c_get_adapter(0);
+                if (!i2c_adap) {
+                        pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+                                __func__);
+                        return -EPROBE_DEFER;
+                }
+
+		ret = intel_qrk_slb9645tt_probe(i2c_adap);
+		ret = intel_qrk_f75111_probe(i2c_adap);
+
+		i2c_put_adapter(i2c_adap);
+
+		return ret;
+	}
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_sc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	int ret;
+	sc_gpio_reg = 1;
+        struct i2c_adapter *i2c_adap;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
+		ret = intel_qrk_spi_devs_addon();
+		if (ret)
+			return ret;
+
+                i2c_adap = i2c_get_adapter(0);
+                if (!i2c_adap) {
+                        pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+                                __func__);
+                        return -EPROBE_DEFER;
+                }
+
+		ret = intel_qrk_slb9645tt_probe(i2c_adap);
+		ret = intel_qrk_f75111_probe(i2c_adap);
+
+		i2c_put_adapter(i2c_adap);
+
+		return ret;
+	}
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_sc,
+};
+
+static int intel_qrk_plat_aiot_x1000_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&gpio_restrict_pdriver_sc);
+}
+
+static int intel_qrk_plat_aiot_x1000_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_aiot_x1000_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_aiot_x1000_probe,
+	.remove		= intel_qrk_plat_aiot_x1000_remove,
+};
+
+module_platform_driver(qrk_aiot_x1000_driver);
+
+MODULE_AUTHOR("Mihai Ene <mihai.ene@windriver.com>");
+MODULE_DESCRIPTION("Aiot X1000 BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
index 789795e..d837cb0 100755
--- a/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
+++ b/drivers/platform/x86/quark/intel_qrk_plat_cross_hill.c
@@ -86,7 +86,7 @@ enum {
 
 #define SLB9645TT_ADDR			0x20
 
-struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
+static struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
 	.gpio_reset = GPIO_SLB9645TT_RESET,
 	.gpio_irq = GPIO_SLB9645TT_INT,
 };
-- 
1.7.5.4

