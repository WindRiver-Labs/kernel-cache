From 3c195c1e82d07a968647c49d60251df39f3d07da Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Tue, 7 Jul 2015 11:30:47 +0800
Subject: [PATCH 59/65] mfd: Add test modules for regression performance
 testing

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
Change-Id: I47a8eb87c635ac7175a4be521352af51d39ae6fd
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/5596
Reviewed-by: Fung, Joshua <joshua.fung@intel.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/mfd/ILatIntDrv.c       |  966 ++++++++++++++++++++++++++++++++++++++++
 drivers/mfd/Kconfig            |   10 +
 drivers/mfd/Makefile           |    2 +
 drivers/mfd/lat_mem_rd_esram.c |  323 ++++++++++++++
 drivers/mfd/latint_ioctl.h     |  238 ++++++++++
 5 files changed, 1539 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mfd/ILatIntDrv.c
 create mode 100644 drivers/mfd/lat_mem_rd_esram.c
 create mode 100644 drivers/mfd/latint_ioctl.h

diff --git a/drivers/mfd/ILatIntDrv.c b/drivers/mfd/ILatIntDrv.c
new file mode 100644
index 0000000..c6e8178
--- /dev/null
+++ b/drivers/mfd/ILatIntDrv.c
@@ -0,0 +1,966 @@
+/******************************************************************************
+* @file  ILatIntDrv.c 
+*
+* GPL LICENSE SUMMARY
+* 
+*   Copyright(c) 2010 Intel Corporation. All rights reserved.
+* 
+*   This program is free software; you can redistribute it and/or modify 
+*   it under the terms of version 2 of the GNU General Public License as
+*   published by the Free Software Foundation.
+* 
+*   This program is distributed in the hope that it will be useful, but 
+*   WITHOUT ANY WARRANTY; without even the implied warranty of 
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+*   General Public License for more details.
+* 
+*   You should have received a copy of the GNU General Public License 
+*   along with this program; if not, write to the Free Software 
+*   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+*   The full GNU General Public License is included in this distribution 
+*   in the file called LICENSE.GPL.
+* 
+*   Contact Information:
+*   Intel Corporation
+* 
+*  version: FPGA_LatInt0.1.1
+******************************************************************************/
+
+#ifndef CONFIG_PCI
+# error "This driver needs PCI support to be available"
+#endif
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+//#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <linux/time.h>
+#include <linux/sched.h>
+#include <asm/dma.h>
+
+#define __CONF_DRV__ 0
+#include "latint_ioctl.h"
+
+#ifdef DEBUG
+#define PRINTK(fmt, args...)  printk(KERN_WARNING "ILatIntDrv DEBUG: %s:%d " fmt "\n", __FUNCTION__,__LINE__, ## args)
+#define EPRINTK(fmt, args...) printk(KERN_ERR     "ILatIntDrv ERROR: %s:%d " fmt "\n", __FUNCTION__,__LINE__, ## args)
+#else
+#define PRINTK(args...)
+#define EPRINTK(args...)
+#endif
+
+MODULE_DESCRIPTION("Intel PCIe Interrupt Testing Driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_VERSION("0.1.1");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, pciext_pci_tbl);
+
+#define SUCCESS 							0
+#define DEVICE_NAME 						"ILatIntDrv"	/* Dev name as it appears in /proc/devices   */
+
+/**********************************
+ * TYPE DEFINITIONS
+ *********************************/
+struct pciext_dev_s 
+{
+	struct pciext_pci_info_s device;   /* PCI Device */
+	/* Linked list of device_handles */
+	struct pciext_dev_s *pnext;
+	struct pciext_dev_s *pprev;
+};
+
+static bool cleanup = 0;
+/*  
+ *  Prototypes 
+ */
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static int device_mmap(struct file *file, struct vm_area_struct * vma);
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+static int device_pci_shutdown(void);
+
+static int pciext_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void pciext_remove(struct pci_dev *pdev);
+static void pciext_cleanup_device(struct pciext_dev_s *pciext_dev);
+
+static struct pciext_dev_s *pciext_table_check(struct pci_dev *pdev);
+static struct pciext_dev_s *pciext_table_get_device(unsigned int device_id);
+static void pciext_device_table_add(struct pciext_dev_s *pciext_dev);
+static int pciext_device_table_remove(struct pciext_dev_s *pciext_dev);
+static unsigned int pciext_table_get_device_count(void);
+
+static int bind_irq(unsigned int * vector);
+static void unbind_irq(unsigned int *vector);
+static irqreturn_t pciext_interrupt_handler(int irg, void *dev_id);
+
+static struct pci_device_id pciext_pci_tbl[] = 
+{
+	/*PCI device table */
+	{ PCI_DEVICE(PCIEXT_PCI_VENDOR_ID, PCIEXT_DEVICE_ID) },
+	{0,}
+};
+
+static int _major;		/* _major number assigned to our device driver */
+static int _device_open = 0;	/* Is device open? Used to prevent multiple access to device */
+
+
+DECLARE_WAIT_QUEUE_HEAD(pciext_drv_q);
+
+/* structure of function pointers for the device */
+static struct file_operations fops = 
+{
+	.open = device_open,
+	.release = device_release,
+	.mmap = device_mmap,
+	.unlocked_ioctl = device_ioctl	
+};
+
+/* structure of pci functions for the device */
+static struct pci_driver pciext_driver =
+{
+	.name = DEVICE_NAME,
+	.id_table = pciext_pci_tbl,
+	.probe = pciext_probe,
+	.remove = pciext_remove,
+};
+
+/*pointer to a linked list of PCI devices that the driver is managing*/
+static struct pciext_dev_s *pciext_table = NULL;
+
+
+
+
+
+/*
+ * This function is called when the module is loaded
+ */
+static int __init pciext_init_module(void)
+{
+
+	PRINTK("PCIe Peripheral Device Driver Module Initialization: VendorID %x DeviceID %x",
+        PCIEXT_PCI_VENDOR_ID, PCIEXT_DEVICE_ID);
+
+	_major = register_chrdev(0, DEVICE_NAME, &fops);
+
+	if (_major < 0) 
+	{
+		EPRINTK("Registering char device failed with %d for master", _major);
+		return _major;
+	} 
+	else 
+		PRINTK("Char Dev Drv with _major %d", _major);
+
+	return pci_register_driver(&pciext_driver);
+
+}
+
+/*
+ * This function is called when the module is unloaded
+ */
+static void pciext_cleanup_module(void)
+{
+
+	struct pciext_pci_info_s *pci_info = NULL;
+	struct pciext_dev_s * pciext_dev = NULL;
+
+
+	pciext_dev = pciext_table_get_device(PCIEXT_DEVICE_ID);
+	if (pciext_dev != NULL)
+	{	
+		pci_info = &(pciext_dev->device);
+		unbind_irq(&pci_info->irq);
+		pci_disable_msi(pci_info->pdev);
+
+		PRINTK("Pci device id 0x%x Unregistered", (unsigned int)pciext_dev->device.device_id);
+	}
+	else
+		PRINTK("Device 0x%x NOT FOUND.",PCIEXT_DEVICE_ID);
+
+
+	PRINTK("FPGA Driver Module Cleanup");
+
+	if (cleanup == 1)
+		device_pci_shutdown();
+
+
+
+	/* 
+	* Unregister the device 
+	*/
+	pci_unregister_driver(&pciext_driver);
+	unregister_chrdev(_major, DEVICE_NAME);
+
+}
+
+/* 
+ * Called when a process tries to open the device file, like
+ * "cat /dev/mycharfile"
+ */
+static int device_open(struct inode *inode, struct file *file)
+{
+
+	PRINTK("Device open");	
+	if (try_module_get(THIS_MODULE))
+	{
+		_device_open++;
+		return SUCCESS;
+	}
+
+	return -EBUSY;
+}
+
+/* 
+ * Called when a process closes the device file.
+ */
+static int device_release(struct inode *inode, struct file *file)
+{
+	_device_open--;		/* We're now ready for our next caller */
+
+	/* 
+	 * Decrement the usage count, or else once you opened the file, you'll
+	 * never get rid of the module. 
+	 */
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+/*
+ * Called when the user-space library calls the mmap libc function */
+static int device_mmap(struct file *file, struct vm_area_struct * vma)
+{
+	struct pciext_dev_s *ptr = NULL;
+	unsigned long start = vma->vm_start;
+	unsigned long size  = vma->vm_end - vma->vm_start;
+	unsigned long pgoff = vma->vm_pgoff;
+	unsigned long pfn=0;
+
+	unsigned int _DEVICE = pgoff / 0x10;
+	unsigned int _AREA = pgoff % 0x10;
+	
+	struct timer_info_s *timer_info;
+//	struct big_buffer_s *big_buff;
+#ifdef DEBUG_MMAP_WORKING
+    uint64_t *largeBuffer;
+#endif
+
+    PRINTK("LatIntDrv:::device_mmap():::beginning memory mapping...");
+	switch (_AREA) 
+	{
+	
+		case MMAP_BAR0:
+		{
+			ptr = pciext_table_get_device(_DEVICE);
+			if (ptr == NULL)
+			{
+				EPRINTK("MMAP_BAR0: NULL pointer");
+				return -EAGAIN;
+			}
+
+			pfn = ptr->device.pci_bars[PCIEXT_BAR0].base_addr >> PAGE_SHIFT;
+			vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+			PRINTK("Mapped BAR0");
+			break;
+		}		
+		case MMAP_BAR2:
+		{
+			ptr = pciext_table_get_device(_DEVICE);
+			if (ptr == NULL)
+			{
+				EPRINTK("MMAP_BAR2: NULL pointer");
+				return -EAGAIN;
+			}
+
+			pfn = ptr->device.pci_bars[PCIEXT_BAR2].base_addr >> PAGE_SHIFT;
+			vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+			PRINTK("Mapped BAR2");
+			break;
+		}
+		case MMAP_TIMER:	// Mapping timer info to user
+		{
+			ptr = pciext_table_get_device(_DEVICE);
+			if (ptr == NULL)
+				return -EAGAIN;
+			pfn = page_to_pfn(virt_to_page(ptr->device.kern_timer_va));
+
+			PRINTK("Mapped Timer Info");
+			timer_info = (struct timer_info_s *)ptr->device.kern_timer_va;	
+
+			break;
+	
+		}
+#ifdef DEBUG_MMAP_WORKING
+		case MMAP_TEST:	// Mapping struct containing big latency buffer to user
+		{
+            ptr = pciext_table_get_device(_DEVICE);
+			if (ptr == NULL)
+				return -EAGAIN;
+			pfn = page_to_pfn(virt_to_page(ptr->device.kern_buffer_va));
+			
+			PRINTK("Mapped largeBuffer to user space");
+			largeBuffer = (uint64_t*)ptr->device.kern_buffer_va;	
+			break;
+		}
+#endif
+		default:
+		{
+			EPRINTK("Wrong memory area!");
+			return -EAGAIN;
+		}
+	}
+
+	if (remap_pfn_range(vma, start, pfn, size, vma->vm_page_prot)) 
+	{
+		EPRINTK("remap_pfn_range failed");
+		return -EAGAIN;
+	}
+
+	return 0;
+
+}
+
+/* Called when the user-space library issue the IOCTL with CPRI_IOCTL_INIT parameter */
+static int device_pci_init(unsigned long arg)
+{
+	int ret_code=0;
+	return ret_code;
+}
+
+/* Called when the user-space library issue the IOCTL with CPRI_IOCTL_SHUTDOWN parameter */
+static int device_pci_shutdown(void)
+{
+	return 0;
+}
+
+/* Called when the user-space library issue the IOCTL with CPRI_IOCTL_GET_DEVICE parameter */
+static int device_get_devices(struct pciext_function_s *args)
+{
+	struct pciext_function_s _tmp;
+	struct pciext_dev_s *_device = NULL;
+	EPRINTK("ILatIntDrv: inside device_get_devices in ILatIntDrv");
+
+	unsigned int logicalDevice=0;
+	if (copy_from_user (&_tmp, args, sizeof(struct pciext_function_s)))
+	{
+		EPRINTK("ILatIntDrv: copy_to_user failed!!!");
+		return -EFAULT;
+	}
+
+	_device = pciext_table_get_device(_tmp.device_id);
+	if (_device == NULL) 
+	{
+		EPRINTK("Device 0x%x NOT FOUND.",(unsigned int) _tmp.device_id);
+		return -EFAULT;
+	}
+
+	//we are using pairs of logical device in 2 by 2: ALTERA_DEVICE_ID, and ALTERA_DEVICE_ID +1
+	logicalDevice= _tmp.device_id-PCIEXT_DEVICE_ID;
+	_tmp.device_id = _device->device.device_id;
+	_tmp.irq = _device->device.irq;
+	_tmp.num_bars = _device->device.num_bars;
+	_tmp.kern_timer_va = _device->device.kern_timer_va;
+	_tmp.lib_timer_va = _device->device.lib_timer_va;
+#ifdef DEBUG_MMAP_WORKING
+	// new stuff for big_buffer 
+    _tmp.kern_buffer_va = _device->device.kern_buffer_va;
+	_tmp.lib_buffer_va = _device->device.lib_buffer_va;
+#endif
+	memcpy(_tmp.pci_bars, _device->device.pci_bars, sizeof(_tmp.pci_bars));
+
+	if (copy_to_user (args, &_tmp, sizeof(struct pciext_function_s)))
+	{
+		EPRINTK("ILatIntDrv: second copy_to_user failed!!!");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/* Called when the user-space library issue the IOCTL with pciext_IOCTL_DEVICE_COUNT parameter */
+static int device_get_device_count(UINT *args)
+{
+	unsigned int count = 0;
+
+	count = pciext_table_get_device_count() ;
+
+	if (copy_to_user((unsigned long*)args, &count, sizeof(unsigned int)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result = -ENOIOCTLCMD;
+	printk("ILatIntDrv: sizeof(pciext_function_s) = %d\n", sizeof(struct pciext_function_s));
+
+	switch (cmd) 
+	{
+		case PCIEXT_IOCTL_INIT:
+		{
+			result = device_pci_init(arg);
+			break;
+		}
+		
+		case PCIEXT_IOCTL_SHUTDOWN:
+		{
+			result = device_pci_shutdown();
+			break;
+		}
+		case PCIEXT_IOCTL_GET_DEVICE:
+		{
+			result = device_get_devices((struct pciext_function_s *)arg);
+			break;
+		}
+		case PCIEXT_IOCTL_DEVICE_COUNT:
+		{
+			result = device_get_device_count((UINT *)arg);
+			break;
+		}
+
+		default:
+		{
+			EPRINTK("Unknown ioctl: %u", cmd);
+			break;
+		}
+	}
+	return result;
+}
+
+/**********************************************************
+		    PCI STUFF 
+***********************************************************/
+
+
+static int pciext_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct pciext_dev_s *pciextLogicalDevice;
+
+	struct pciext_pci_info_s *pci_info = NULL;
+
+	struct timer_info_s *timer_info;
+#ifdef DEBUG_MMAP_WORKING
+    uint64_t *largeBuffer;
+#endif
+	int new_device = 0;
+	int status = 0;
+	int i=0;
+	uint16_t wValue;
+	PRINTK("Probing device");
+	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) 
+	{
+		if(pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)))
+		{
+			PRINTK ("PCIe device using 32 bits mask FAILED!!!!");
+
+			if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(24))) 
+			{
+				if(pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(24)))
+				{
+					EPRINTK ("PCIe device using 24 bits mask FAILED!!!!");
+	 
+					EPRINTK( "No suitable DMA available, aborting.");
+					return -ENODEV;
+				}
+			}
+		}
+	}
+
+	/* Ensure have valid device */
+	if (ent->device != PCIEXT_DEVICE_ID) 
+	{
+		EPRINTK("invalid device 0x%x found..!!", ent->device);
+		return -ENODEV;
+	}
+
+	/* Check device Table for an existing device structure */
+	pciextLogicalDevice = pciext_table_check(pdev);
+	if (pciextLogicalDevice == NULL) 
+	{
+		pciextLogicalDevice = kzalloc(sizeof(struct pciext_dev_s), GFP_KERNEL);
+		if (pciextLogicalDevice == NULL)
+		{
+			EPRINTK("failed to allocate memory for device structure %d",i);
+			return -ENOMEM;
+		}	
+		new_device = 1;
+	} else 
+	{
+		new_device = 0;
+		PRINTK("no new device?");
+	}
+
+	/* enable PCI device */
+	if (pci_enable_device(pdev)) 
+	{
+		EPRINTK("PCI Enable Device Error");
+		pciext_cleanup_device(pciextLogicalDevice);
+
+		return -EIO;
+	}
+
+	pci_set_master(pdev);
+
+	status = pci_set_mwi(pdev);
+	if (status)
+		PRINTK (" Warning: enabling mwi failed");
+
+	status=0;
+
+	if ((ent->device == PCIEXT_DEVICE_ID ))
+	{
+		PRINTK(" Requesting regions for %s", DEVICE_NAME);
+		status = pci_request_regions(pdev, DEVICE_NAME);
+	}
+
+	if (status!=0) 
+	{
+		EPRINTK("PCI request regions failed for %s",DEVICE_NAME);	
+		pciext_cleanup_device(pciextLogicalDevice);
+		return -EIO;
+	}
+	
+	/* Puts PCIe endpoint in MSI interrupt mode */
+	
+
+	pci_read_config_word(pdev,PCI_COMMAND,&wValue);
+	wValue |= 0x0400;
+	pci_write_config_word(pdev,PCI_COMMAND,wValue);	// Setting bit10 in COMMAND disables legacy interrupt
+	pci_read_config_word(pdev,0x52,&wValue);
+	wValue |= 0x0001;
+	pci_write_config_word(pdev,0x52,wValue);	// Setting bit0 of MSI Ctrl/Status reg enables MSI interrupt
+	
+	status = pci_enable_msi(pdev);
+	if (status!=0) 
+	{
+		EPRINTK("PCI MSI enabling failed for %s",DEVICE_NAME);	
+	}
+
+	pci_info = &pciextLogicalDevice->device;
+
+	/*
+	 * Setup PCI Info structure
+	 */
+	pci_info->pdev = pdev;
+	pci_info->device_id = ent->device;
+	pci_info->irq = pdev->irq;
+
+	PRINTK("FPGA Device BARs:");
+
+	pci_info->num_bars = PCIEXT_BARS_COUNT;
+	for (i=0;i<PCIEXT_BARS_COUNT;i++)	// i is BAR no
+	{
+		pci_info->pci_bars[i].base_addr = pci_resource_start(pdev, i);
+		pci_info->pci_bars[i].size = pci_resource_len(pdev, i);
+
+		/* map the device memory region into kernel virtual address space */
+		pci_info->pci_bars[i].virt_addr = ioremap(pci_info->pci_bars[i].base_addr,
+		    pci_info->pci_bars[i].size);
+
+		PRINTK("Bar %d: Start Virt Addr %p",
+			i, pci_info->pci_bars[i].virt_addr);
+		PRINTK("       Start Phys Addr %lx", pci_info->pci_bars[i].base_addr);
+		PRINTK("       Length %lu bytes", pci_info->pci_bars[i].size);
+	}	
+	PRINTK("IRQ_LEVEL: %i ", pdev->irq);
+
+
+	/* Allocate the Shared memory for use with the FPGA */
+	if (ent->device == PCIEXT_DEVICE_ID)
+	{
+		/* Initialisation Block */
+		if (pdev == NULL || pci_info == NULL) 
+		{
+			EPRINTK ("Can't allocate on the PCI peripheral PCI pointer is NULL.");
+			return -ENOMEM;
+		}
+		// Allocate memory for timer info
+		pci_info->kern_timer_ptr = kzalloc(((sizeof(struct timer_info_s)/PAGE_SIZE)+3)*PAGE_SIZE, GFP_KERNEL);
+       	if(pci_info->kern_timer_ptr == NULL){
+            EPRINTK("failed to allocate memory for device structure %d",i);
+			return -ENOMEM; 
+        }
+        pci_info->kern_timer_va = (int *)((((unsigned long)pci_info->kern_timer_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+		SetPageReserved(virt_to_page(((unsigned long)pci_info->kern_timer_va))); // On Page boundry
+
+        // increment i to indicate next area
+        i++;
+
+		// initialize values of the timer_info struct
+		timer_info = (struct timer_info_s *)pci_info->kern_timer_va;	
+		timer_info->period = 110;
+		timer_info->latency_min = 111;
+		timer_info->latency_avg = 112;
+		timer_info->latency_max = 113;
+
+	    /* set buffer size for storing latency measurements [JMW] */  
+	    timer_info->buffer_size = LATENCY_BUFFER_SIZE;
+
+        PRINTK("timer_info struct initialized successfully");
+#ifdef DEBUG_MMAP_WORKING
+        // Allocate memory for largeBuffer
+		pci_info->kern_buffer_ptr = kzalloc(sizeof(uint64_t)*BIG_BUFFER_SIZE, GFP_KERNEL); // was GFP_ATOMIC | __GFP_NOFAIL
+	  	if(pci_info->kern_buffer_ptr == NULL){                            
+            EPRINTK("failed to allocate memory for device structure %d",i); 
+       	    return -ENOMEM;                                                  
+        }
+        pci_info->kern_buffer_va = (int *)((((unsigned long)pci_info->kern_buffer_ptr) + PAGE_SIZE - 1) & PAGE_MASK);
+		SetPageReserved(virt_to_page(((unsigned long)pci_info->kern_buffer_va))); // On Page boundry
+
+        largeBuffer = (uint64_t *)pci_info->kern_buffer_va;
+        // initialize values of the array to zero with memset
+#endif
+	}
+
+	/* Now Bind the IRQ */
+	PRINTK("Binding PCI Conf IRQ");
+
+	if (bind_irq(&pci_info->irq))
+	{
+		EPRINTK("Unable to Register FPGA IRQ");
+		return -EINTR;
+	}
+
+	/* Add  device to table */
+	if (new_device) 
+	{
+		pciext_device_table_add(pciextLogicalDevice);
+	}
+	return status;
+}
+
+/* Checks if the driver is configured to manage the given PCI device */
+static struct pciext_dev_s *pciext_table_check(struct pci_dev *pdev)
+{
+	struct pciext_dev_s *ptr = pciext_table;
+	while (ptr != NULL) 
+	{
+		if (ptr->device.pdev == pdev) 
+			return ptr;
+		ptr = ptr->pnext;
+	}
+	return ptr;
+}
+
+/* Retrieves a device, given the DEVICE_ID, from the devices table */
+static struct pciext_dev_s *pciext_table_get_device(unsigned int device_id)
+{
+	struct pciext_dev_s *ptr = pciext_table;
+
+	/*
+	 *check for existing device
+	 */
+	while (ptr != NULL) 
+	{
+		if (ptr->device.device_id == device_id) 
+			return ptr;
+		ptr = ptr->pnext;
+	}
+	return NULL;
+}
+
+/* Gets the number of devices going through the devices table */
+static unsigned int pciext_table_get_device_count()
+{
+	struct pciext_dev_s *ptr = pciext_table;
+	unsigned int i = 0;
+
+/*
+*check for existing device
+*/
+	while (ptr != NULL)
+	{
+		ptr = ptr->pnext;
+		i++;
+	}
+	return i;
+}
+
+/* Add a device to the devices table*/
+static void pciext_device_table_add(struct pciext_dev_s *pciext_dev)
+{
+	PRINTK("Adding deviceID %x",(unsigned int) 	pciext_dev->device.device_id);
+	if (pciext_dev == NULL) 
+	{
+		EPRINTK("NULL pointer provided");
+		return;
+	}
+
+	if (pciext_table == NULL) 
+	{
+		pciext_table = pciext_dev;
+		pciext_dev->pnext = NULL;
+		pciext_dev->pprev = NULL;
+	} else 
+	{
+		pciext_dev->pnext = pciext_table;
+		pciext_table->pprev = pciext_dev;
+		pciext_dev->pprev = NULL;
+		pciext_table = pciext_dev;
+	}
+
+}
+
+/* Remove a device from the devices table*/
+static int pciext_device_table_remove(struct pciext_dev_s *pciext_dev)
+{
+	struct pciext_dev_s *prev = NULL;
+	struct pciext_dev_s *next = NULL;
+
+	if (!pciext_dev) 
+		return -ENODEV;
+
+	prev = pciext_dev->pprev;
+	next = pciext_dev->pnext;
+
+	if (prev) 
+	{
+		prev->pnext = pciext_dev->pnext;
+		if (next)
+			next->pprev = prev;
+	} else 
+	{
+		pciext_table = pciext_dev->pnext;
+		if (next)
+			next->pprev = NULL;
+	}
+	return 0;
+}
+
+
+/*
+ * Remove a PCI device
+ */
+static void pciext_remove(struct pci_dev *pdev)
+{
+	struct pciext_dev_s *pciext_dev = NULL;
+	int i = 0;
+
+	/* Find the device structure */
+	pciext_dev = pciext_table_check(pdev);
+	if (pciext_dev == NULL) 
+	{
+		EPRINTK("failed to find pciext_dev");
+		return;
+	}
+
+	for (i = 0; i < pciext_dev->device.num_bars; i++) {
+		iounmap(pciext_dev->device.pci_bars[i].virt_addr);
+	}
+	PRINTK("Unmapped 0x%x BARS",(unsigned int)pciext_dev->device.num_bars);
+	pciext_dev->device.num_bars = 0;
+	
+	// clear reserved page for timer info
+    ClearPageReserved(virt_to_page( (unsigned long)pciext_dev->device.kern_timer_va));
+	kfree(pciext_dev->device.kern_timer_ptr);
+
+#ifdef DEBUG_MMAP_WORKING
+    // clear reserved pages for largeBuffer
+    ClearPageReserved(virt_to_page( (unsigned long)pciext_dev->device.kern_buffer_va));
+	kfree(pciext_dev->device.kern_buffer_ptr);
+#endif
+
+	pciext_cleanup_device(pciext_dev);
+
+	PRINTK("Device 0x%x Removal Completed",(unsigned int)pciext_dev->device.device_id);
+	return;
+}
+
+/*
+ * Release the memory regions that belong to a PCI Device and disable
+ * the device
+ */
+static void pciext_cleanup_device(struct pciext_dev_s *pciext_dev)
+{
+	int status = 0;
+
+	if (pciext_dev == NULL) {
+		EPRINTK("NULL pointer provided");
+		return;
+	}
+
+	if (pciext_dev->device.pdev) 
+	{
+		pci_release_regions(pciext_dev->device.pdev);
+		pci_disable_device(pciext_dev->device.pdev);
+	}
+
+	/* Remove the device from the device table */
+	status = pciext_device_table_remove(pciext_dev);
+	if (status != 0) {
+		EPRINTK("failed to remove pciext_dev from device table");
+	}
+
+	kfree(pciext_dev);
+
+	return;
+}
+/*
+static __inline__ uint64_t readTimestampCounter(void)
+{
+	uint64_t a, d;
+	__asm__ __volatile__("rdtsc" : "=a" (a), "=d" (d));
+
+	return ((uint64_t)a) | (((uint64_t)d) << 32); 
+}*/
+static __inline__ unsigned long long readTimestampCounter(void)
+{
+  unsigned hi, lo;
+  __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
+  return ( (unsigned long long)lo)|( ((unsigned long long)hi)<<32 );
+}
+
+
+/******************************************************************
+ **	       INTERRUPTS				    ***
+ ******************************************************************/
+
+/*
+ * Bind the interrupt handler for a slot
+ */
+int bind_irq(unsigned int * vector)
+{
+	if (request_irq (*vector, pciext_interrupt_handler, IRQF_SHARED, "FPGA_DEV", vector)) 
+	{
+		EPRINTK("Failed to bind FPGA IRQ Level: %u", *vector);
+		return -EPERM;
+	}
+	
+    PRINTK("Bind IRQ Level successful: %u", *vector);
+
+	return 0;
+}
+
+/*
+ * Unbind the interrupt handler for a slot
+ */
+void unbind_irq(unsigned int *vector)
+{
+	free_irq(*vector, vector);
+	PRINTK("Unbind IRQ Level successful: %u", *vector);
+}
+
+
+/*
+ * Interrupt handler for FPGA (ISR Top Half)
+ */
+static irqreturn_t pciext_interrupt_handler(int irg, void *dev_id)
+{
+	struct pciext_dev_s *pciext = NULL;
+	struct timer_info_s *timer_info;
+    uint32_t latency;
+	uint64_t timestamp;
+    //uint64_t index;
+    unsigned long index;
+    unsigned long num_interrupts = 0;
+#ifdef SPIKE_DETECTION
+	const uint32_t usFPGA = 125; // ==125E6 * 1E-6
+    const uint32_t MAX_SPIKE_SIZE = 300 * usFPGA;
+#endif
+#ifdef DEBUG_MMAP_WORKING
+//    int bigBuffSize = BIG_BUFFER_SIZE;
+	uint64_t *largeBuffer;
+    //uint64_t index2;
+    unsigned long index2;
+#endif
+	/* CPRI_RX function */
+	pciext = pciext_table_get_device(PCIEXT_DEVICE_ID);
+	if (pciext == NULL)
+	{
+		PRINTK("Null PCIe Device");
+		return IRQ_NONE;
+	}
+	// Trigger FPGA timer snapshot
+	iowrite16(0,pciext->device.pci_bars[2].virt_addr+TIMER_SNAPL); 
+	// Reset interrupt;
+	iowrite16(0,pciext->device.pci_bars[2].virt_addr+0x5000);
+
+	// get timer_info from kernel memory
+	timer_info = pciext->device.kern_timer_va;
+
+    // Latency since last FPGA interrupt
+ 	latency = timer_info->period-(  ioread16(pciext->device.pci_bars[2].virt_addr+TIMER_SNAPL)+
+                            (ioread16(pciext->device.pci_bars[2].virt_addr+TIMER_SNAPH)<<16));
+	
+	// Update jitter
+	if ( unlikely(timer_info->last_timestamp == 0) )
+	{
+		timer_info->last_timestamp = timestamp = readTimestampCounter();
+		timer_info->no_interrupts=0;
+		timer_info->jitter_avg = 0;
+		timer_info->latency_avg = 0;
+	}
+	else
+	{
+		timestamp = readTimestampCounter()-timer_info->last_timestamp;
+		if (timestamp > timer_info->jitter_max)
+			timer_info->jitter_max = timestamp;
+		if (timestamp < timer_info->jitter_min)
+			timer_info->jitter_min = timestamp;
+		timer_info->last_timestamp += timestamp;
+		timer_info->jitter_avg +=timestamp;
+	}
+
+	// Update latency statistics
+    if (latency > timer_info->latency_max)
+		timer_info->latency_max = latency;
+    if (latency < timer_info->latency_min)
+		timer_info->latency_min = latency;
+	timer_info->latency_avg +=latency;
+
+	// Check if latency spikes above limit
+#ifdef SPIKE_DETECTION
+    // spike is statistically unlikely so mark it to prevent branch prediction
+	if ( unlikely(latency > MAX_SPIKE_SIZE) ){
+		// turn off tracing on the host
+        tracing_off();
+        
+        // issue a "stop" command to the FPGA card so it stops generating interrupts 
+        // 0x0008 is the value and TIMER_CONTROL is the offset
+	    iowrite16(0x0008, pciext->device.pci_bars[2].virt_addr+TIMER_CONTROL); 
+
+        // Set Qsys interrupt enable 0
+        // 0x0000 is the value and AVALON_INT_ENABLE is the offset
+        iowrite16(0x0000, pciext->device.pci_bars[2].virt_addr+AVALON_INT_ENABLE);  
+        
+        // the following line issues an unconditional kernel printk to mark the spike 
+        printk(KERN_WARNING "ILatIntDrv: %s:%d: FPGA latency spike detected (%d us) -> tracing_off\n", __FUNCTION__,__LINE__,latency/usFPGA);
+//		PRINTK("FPGA Latency spike detected: %d us.  Tracing is now off.", latency/usFPGA );
+	}
+#endif
+
+    num_interrupts = timer_info->no_interrupts;
+
+    /* append latency measurements to buffer in a circular fashion */
+    //index = num_interrupts % timer_info->buffer_size;
+    index = (num_interrupts-1) % LATENCY_BUFFER_SIZE;
+    timer_info->latency_buffer[index] = latency;
+
+#ifdef DEBUG_MMAP_WORKING
+    // get big_buffer from kernel memory
+ 	largeBuffer = pciext->device.kern_buffer_va;
+ 	
+	// append latency to largeBuffer in a circular fashion
+	index2 = (num_interrupts-1) % BIG_BUFFER_SIZE;
+	largeBuffer[index2] = latency;
+#endif
+
+    /* update the number of interrupts performed */
+	timer_info->no_interrupts++;
+
+	return IRQ_HANDLED;
+//	return IRQ_NONE;
+
+}
+
+module_init(pciext_init_module);
+module_exit(pciext_cleanup_module);
+
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 9957fa5..408dd9d 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1089,6 +1089,16 @@ config INTEL_QRK_GIP_TEST
 	  Quark GIP automated Integration Testing package.
 	  It selects kernel components needed for GPIO and I2C tests as per
 
+config QUARK_INTERRUPT_TEST
+	tristate "Intel Quark PCI Interrupt Testing"
+	help
+	  Quark test driver for PCI interrupt on Altera FPGA
+
+config QUARK_LMBENCH_TEST
+	tristate "Intel Quark  LMBench Test for ESRAM"
+	help
+	  Quark test driver for LMBench for ESRAM
+
 config MFD_TC3589X
 	bool "Toshiba TC35892 and variants"
 	depends on I2C=y
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 54576d1..4aeb29d 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -146,6 +146,8 @@ intel_qrk_gip-objs		:= intel_qrk_gip_core.o \
 					../i2c/busses/i2c-designware-core.o
 obj-$(CONFIG_X86_INTEL_QUARK)	+= intel_qrk_gip_pdata.o
 obj-$(CONFIG_INTEL_QRK_GIP_TEST)+= intel_qrk_gip_test.o
+obj-$(CONFIG_QUARK_INTERRUPT_TEST)	+= ILatIntDrv.o
+obj-$(CONFIG_QUARK_LMBENCH_TEST)	+= lat_mem_rd_esram.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
 obj-$(CONFIG_LPC_ICH)		+= lpc_ich.o
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
diff --git a/drivers/mfd/lat_mem_rd_esram.c b/drivers/mfd/lat_mem_rd_esram.c
new file mode 100644
index 0000000..b4275c2
--- /dev/null
+++ b/drivers/mfd/lat_mem_rd_esram.c
@@ -0,0 +1,323 @@
+/*****************************************************************************
+ * <COPYRIGHT_TAG>
+ *****************************************************************************/
+/**************************************************************************
+* @ingroup lmbench_GENERAL
+*
+* @file lat_mem_rd_esram.c
+*
+* @description main file in the lmbench Driver
+*
+* @author: brian.furlong@intel.com
+*
+**************************************************************************/
+/* lmbench Driver specific include files */
+#include <linux/module.h>	/* Needed by all modules */
+#include <linux/kernel.h>	/* Needed for KERN_INFO */
+#include <linux/slab.h>
+#include <linux/time.h>
+#include "../../arch/x86/platform/intel-quark/intel_qrk_esram.h"
+#define N       1000000	/* Don't change this */
+#define	MEMTRIES	4
+#define	LOWER	512
+#define MAP_SIZE 524288 //mapping 512kB to esram
+
+MODULE_AUTHOR("Intel(R) Corporation");
+MODULE_DESCRIPTION("Lmbench Test Driver ESRAM");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION("1.0.0");
+
+static size_t stride = 8;
+module_param(stride, int, S_IRUGO); //stride size can be passed in
+
+static int isEsram = 0;
+char	*id = "$Id$\n";
+void	loads(char *addr, size_t range, size_t stride);
+size_t	step(size_t k);
+static struct timeval start_tv, stop_tv;
+volatile unsigned long long int	use_result_dummy;
+size_t	len;
+char   *addr;
+void
+tvsub(struct timeval * tdiff, struct timeval * t1, struct timeval * t0)
+{
+	tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
+	tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
+	if (tdiff->tv_usec < 0 && tdiff->tv_sec > 0) {
+		tdiff->tv_sec--;
+		tdiff->tv_usec += 1000000;
+		if(tdiff->tv_usec < 0)
+        {
+            printk(KERN_EMERG "Assertion failed\n");
+            return;
+        }
+	}
+
+	/* time shouldn't go backwards!!! */
+	if (tdiff->tv_usec < 0 || t1->tv_sec < t0->tv_sec) {
+		tdiff->tv_sec = 0;
+		tdiff->tv_usec = 0;
+	}
+}
+
+void
+use_pointer(void *result) 
+{ 
+    use_result_dummy += (int)result; 
+}
+
+unsigned long long int tvdelta(struct timeval *start, struct timeval *stop)
+{
+	struct timeval td;
+	unsigned long long int usecs;
+
+	tvsub(&td, stop, start);
+	usecs = td.tv_sec;
+	usecs *= 1000000;
+	usecs += td.tv_usec;
+	return (usecs);
+}
+
+/*
+ * Stop timing and return real time in microseconds.
+ */
+unsigned long long int stop(struct timeval *begin, struct timeval *end)
+{
+	if (end == NULL) {
+		end = &stop_tv;
+	}
+	(void) do_gettimeofday(end);
+#ifdef	RUSAGE
+	getrusage(RUSAGE_SELF, &ru_stop);
+#endif
+
+	if (begin == NULL) {
+		begin = &start_tv;
+	}
+	return tvdelta(begin, end);
+}
+
+size_t
+step(size_t k)
+{
+	if (k < 1024) {
+		k = k * 2;
+        } else if (k < 4*1024) {
+		k += 1024;
+	} else {
+		size_t s;
+
+		for (s = 32 * 1024; s <= k; s *= 2)
+			;
+		k += s / 16;
+	}
+	return (k);
+}
+
+/*
+ * Start timing now.
+ */
+void
+start(struct timeval *tv)
+{
+	if (tv == NULL) {
+		tv = &start_tv;
+	}
+#ifdef	RUSAGE
+	getrusage(RUSAGE_SELF, &ru_start);
+#endif
+	(void) do_gettimeofday(tv);
+}
+
+int main(void)
+{
+    printk(KERN_EMERG "lmbench: start\n");
+
+	size_t	range;
+    
+    //2MB array size
+    len = 2097152; //2 * (1024 * 1024)
+    printk(KERN_EMERG "lmbench: about to kmalloc\n");
+
+    addr = (char *)kmalloc(len, GFP_KERNEL);
+    printk(KERN_EMERG "lmbench: kmalloc successful. Mapping to esram... Size of addr = %d\n", sizeof(addr));
+
+    //if running esram test, map array to esram
+    if(isEsram){
+        printk(KERN_EMERG "lmbench: mapping ESRAM isEsram = 1");
+        //map part of array to esram
+        int ret = intel_qrk_esram_map_range((void *)addr, MAP_SIZE, "lat_mem_rd memory");
+        printk(KERN_EMERG "lmbench: ret = %d\n", ret);
+    }
+    else
+        printk(KERN_EMERG "lmbench: isEsram = 0");
+    
+    printk(KERN_EMERG "\"stride=%d\n", stride);
+    for (range = LOWER; range <= len; range = step(range)) {
+        loads(addr, range, stride);
+    }
+    printk(KERN_EMERG "\n");
+
+    return 0;
+}
+
+
+void
+loads(char *addr, size_t range, size_t stride)
+{
+	register char **p = 0 /* lint */;
+	size_t	i;
+	int	tries = 0;
+	int	result = 0x7fffffff;
+	double	time;
+
+     	if (stride & (sizeof(char *) - 1)) {
+		printk(KERN_EMERG "lat_mem_rd: stride must be aligned.\n");
+		return;
+	}
+	
+	if (range < stride) {
+		return;
+	}
+
+	/*
+	 * First create a list of pointers.
+	 *
+	 * This used to go forwards, we want to go backwards to try and defeat
+	 * HP's fetch ahead.
+	 *
+	 * We really need to do a random pattern once we are doing one hit per 
+	 * page.
+	 */
+	for (i = stride; i < range; i += stride) {
+		*(char **)&addr[i] = (char*)&addr[i - stride];
+	}
+	*(char **)&addr[0] = (char*)&addr[i - stride];
+	p = (char**)&addr[0];
+
+	/*
+	 * Now walk them and time it.
+	 */
+        for (tries = 0; tries < MEMTRIES; ++tries) {
+                /* time loop with loads */
+#define	ONE	p = (char **)*p;
+#define	FIVE	ONE ONE ONE ONE ONE
+#define	TEN	FIVE FIVE
+#define	FIFTY	TEN TEN TEN TEN TEN
+#define	HUNDRED	FIFTY FIFTY
+		i = N;
+                start(0);
+                while (i >= 1000) {
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			HUNDRED
+			i -= 1000;
+                }
+		i = stop(0,0);
+		use_pointer((void *)p);
+		if (i < result) {
+			result = i;
+		}
+	}
+	/*
+	 * We want to get to nanoseconds / load.  We don't want to
+	 * lose any precision in the process.  What we have is the
+	 * milliseconds it took to do N loads, where N is 1 million,
+	 * and we expect that each load took between 10 and 2000
+	 * nanoseconds.
+	 *
+	 * We want just the memory latency time, not including the
+	 * time to execute the load instruction.  We allow one clock
+	 * for the instruction itself.  So we need to subtract off
+	 * N * clk nanoseconds.
+	 *
+	 * lmbench 2.0 - do the subtration later, in the summary.
+	 * Doing it here was problematic.
+	 *
+	 * XXX - we do not account for loop overhead here.
+	 */
+	//time = (double)result;
+	time *= 1000.;				/* convert to nanoseconds */
+	time /= (double)N;			/* nanosecs per load */
+	//printk("%.5f %.3f\n", range / (1024. * 1024), time);
+    printk(KERN_EMERG "%d, %d\n", range, result);
+    //printk("%d.%d %d.%d\n", range_front, range_back, time_front, time_back);
+}
+
+/*****************************************************************************
+ * @name lmbench_init_module
+ * @ingroup lmbench_GENERAL
+ * @description Function that is called when the lmbench driver is loaded
+ * into the OS. This function has to allocate all the resources required
+ * for the driver to support the clients
+*****************************************************************************/
+static int lmbench_init_module(void) {
+    
+    printk(KERN_EMERG "lmbench: Initialising module.\n");
+    
+    printk(KERN_EMERG "Results come out in following format:\nRange (bytes): XXXXX Result (divide by 1000 to get nanosesonds): XXXXX\n");
+
+    
+   // printk(KERN_EMERG "lmbench: DRAM tests...\n");
+ //   main();
+    
+    //run esram tests
+    isEsram = 1;
+    printk(KERN_EMERG "lmbench: about to begin mapping to ESRAM\n");
+    main();
+    
+    
+    //map functions to esram
+    /*int ret_main = intel_cln_esram_map_symbol(main);
+    int ret_loads = intel_cln_esram_map_symbol(loads);
+    int ret_start = intel_cln_esram_map_symbol(start);
+    int ret_stop = intel_cln_esram_map_symbol(stop);
+    int ret_step = intel_cln_esram_map_symbol(step);
+    int ret_tvsub = intel_cln_esram_map_symbol(tvsub);  
+    int ret_tvdelta = intel_cln_esram_map_symbol(tvdelta);    
+    
+
+	printk(KERN_EMERG "lmbench: esram mapping errors = %d %d %d %d %d %d %d\n", ret_main, ret_loads, ret_start, ret_stop, ret_step, ret_tvsub, ret_tvdelta);
+*/
+    
+	return 0;
+
+} /* end of lmbench_init_module */
+
+/*****************************************************************************
+ * @name lmbench_cleanup_module
+ * @ingroup lmbench_GENERAL
+ * @description Function that is called when the lmbench driver is unloaded
+ * from the OS. This function has to clear and free all the resources.
+*****************************************************************************/
+static void lmbench_cleanup_module(void) {
+	
+	printk("lmbench: Unloading module.\n");
+    
+ /*   int ret_main = intel_cln_esram_unmap_symbol(main);
+    int ret_loads = intel_cln_esram_unmap_symbol(loads);
+    int ret_start = intel_cln_esram_unmap_symbol(start);
+    int ret_stop = intel_cln_esram_unmap_symbol(stop);
+    int ret_step = intel_cln_esram_unmap_symbol(step);
+    int ret_tvsub = intel_cln_esram_unmap_symbol(tvsub);  
+    int ret_tvdelta = intel_cln_esram_unmap_symbol(tvdelta);    
+    
+
+    printk("lmbench: esram unmapping errors = %d %d %d %d %d %d %d\n", ret_main, ret_loads, ret_start, ret_stop, ret_step, ret_tvsub, ret_tvdelta);
+   */ 
+    
+ //   int ret_len = intel_qrk_esram_unmap_range((void *)addr, MAP_SIZE, "lat_mem_rd memory");
+    //printk(KERN_EMERG "lmbench: Unmapping len %d \n", ret_len);
+
+} /* end of lmbench_cleanup_module */
+
+
+module_init(lmbench_init_module);
+module_exit(lmbench_cleanup_module);
diff --git a/drivers/mfd/latint_ioctl.h b/drivers/mfd/latint_ioctl.h
new file mode 100644
index 0000000..2558366
--- /dev/null
+++ b/drivers/mfd/latint_ioctl.h
@@ -0,0 +1,238 @@
+/******************************************************************************
+* @file  latint_ioctl.h 
+*
+* GPL LICENSE SUMMARY
+* 
+*   Copyright(c) 2010 Intel Corporation. All rights reserved.
+* 
+*   This program is free software; you can redistribute it and/or modify 
+*   it under the terms of version 2 of the GNU General Public License as
+*   published by the Free Software Foundation.
+* 
+*   This program is distributed in the hope that it will be useful, but 
+*   WITHOUT ANY WARRANTY; without even the implied warranty of 
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+*   General Public License for more details.
+* 
+*   You should have received a copy of the GNU General Public License 
+*   along with this program; if not, write to the Free Software 
+*   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+*   The full GNU General Public License is included in this distribution 
+*   in the file called LICENSE.GPL.
+* 
+*   Contact Information:
+*   Intel Corporation
+* 
+*  version: FPGA_Latint.L.0.1.1
+*
+******************************************************************************/
+#ifndef LATINT_IOCTL_H
+#define LATINT_IOCTL_H
+
+// comment out DEBUG_MMAP_WORKING to disable largeBuffer in all driver/user-space components
+#define DEBUG_MMAP_WORKING
+
+// uncomment SPIKE_DETECTION to enable the tracing_off() function when spike exceeded
+//#define SPIKE_DETECTION
+
+// uncomment DEBUG to enable debug mode in the driver and user_space code
+#define DEBUG
+
+#define MAX_PCI_BARS      	 			6    /*Max No. of BARS for any device */
+
+#define PCIEXT_DEVICE_ID				0x0004
+#define PCIEXT_PCI_VENDOR_ID				0x1172
+
+#define PCIEXT_BARS_COUNT 				3	// 3 BARS
+
+/* Used to index the BARS array */
+#define PCIEXT_BAR0 					0
+#define PCIEXT_BAR2 					2
+
+/* Used to offset the BARS address space */
+#define PCIEXT_BAR_HW 					0
+
+#define PCIEXT_BAR0_LENGTH				4194304
+#define PCIEXT_BAR2_LENGTH				32768
+
+#define MMAP_BAR0					0x0
+#define MMAP_BAR2					0x2
+#define MMAP_TIMER					0x3
+#define	MMAP_TEST					0x4
+//#define MMAP_DATA                  			0x5
+
+
+/* BAR2 register space */
+#define	TIME_STATUS		    0x5000
+#define	TIMER_CONTROL		0x5004
+#define	TIMER_PERIODL		0x5008
+#define	TIMER_PERIODH		0x500C
+#define	TIMER_SNAPL		    0x5010
+#define	TIMER_SNAPH		    0x5014
+
+#define	AVALON_INT_STATUS	0x0040
+#define AVALON_INT_ENABLE	0x0050
+
+
+#define WORDTYPE            uint32_t
+#define WORDSIZE            sizeof(WORDTYPE)
+
+
+#define SYSTEMTESTS_PRIORITY    90
+#define STACK_SIZE              8192
+
+/* IOCTLs commands */
+#define PCIEXT_CMD_MAGIC			'e'
+#define PCIEXT_CMD_INIT				(0)
+#define PCIEXT_CMD_SHUTDOWN			(1)
+#define PCIEXT_CMD_GET_DEVICE			(2)
+#define PCIEXT_CMD_GET_DEVICE_COUNT		(3)
+
+#define PCIEXT_IOCTL_INIT			_IOWR(PCIEXT_CMD_MAGIC, PCIEXT_CMD_INIT, unsigned int)
+#define PCIEXT_IOCTL_SHUTDOWN			_IOWR(PCIEXT_CMD_MAGIC, PCIEXT_CMD_SHUTDOWN, unsigned int)
+#define PCIEXT_IOCTL_GET_DEVICE			_IOWR(PCIEXT_CMD_MAGIC, PCIEXT_CMD_GET_DEVICE, struct pciext_function_s)
+#define PCIEXT_IOCTL_DEVICE_COUNT		_IOWR(PCIEXT_CMD_MAGIC, PCIEXT_CMD_GET_DEVICE_COUNT, UINT)
+
+
+#define DMA_OFFSET_IN_BAR				0x0000
+#define CRA_OFFSET_IN_BAR				0x4000
+#define CRA_OFFSET_ADDRESS_TRASLATION_OFFSET		0x1000
+#define CRA_OFFSET_ADDRESS_TRASLATION			( CRA_OFFSET_ADDRESS_TRASLATION_OFFSET + CRA_OFFSET_IN_BAR )
+#define CRA_LENGTH					0x8000
+
+#define ALTERA_CRA_OFFSET				0x1000
+#define ALTERA_CRA_ADDRESS_TRANSLATION_MASK		((UINT*)(0xFFFFFF00LL))
+
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE					4096
+#endif
+
+#define NUMBER_OF_FPGA					1
+#define DEVICE_IDS					2
+
+#define E_THREAD_ABORTED							(-1)
+#define E_PACKET_ABORTED 							(-2)
+
+// short-term buffer size - 100k
+#define LATENCY_BUFFER_SIZE 100000 
+//static const uint64_t LATENCY_BUFFER_SIZE = 100000;
+
+// BIG_BUFFER_SIZE for long-term latency data - 1M
+#define BIG_BUFFER_SIZE 500000
+//static const uint64_t BIG_BUFFER_SIZE = 500000;
+//static const unsigned long BIG_BUFFER_SIZE = 500000;
+
+#ifdef __x86_64__
+typedef uint64_t UINT;
+#else
+typedef uint32_t UINT;
+#endif
+
+#ifndef __CONF_DRV__
+typedef uint64_t dma_addr_t;
+#endif
+
+/* added a buffer to hold the latency measurements [JMW]*/
+typedef struct timer_info_s 
+{
+	uint64_t	latency_min;
+	uint64_t	latency_max;
+	uint64_t	latency_avg;
+	uint64_t	jitter_min;
+	uint64_t	jitter_max;
+	uint64_t	jitter_avg;
+	uint64_t	no_interrupts;
+	uint64_t	last_timestamp;
+	uint32_t	period;
+	uint64_t	buffer_size;
+	uint64_t 	latency_buffer[LATENCY_BUFFER_SIZE];	
+} timer_info_t;
+
+#if 0
+/* added a large buffer ptr to hold the long-term (1M) latency measurements [JMW]*/
+typedef struct big_buffer_s
+{
+	uint64_t	buffer_size;
+	uint64_t*	latency_data;
+} big_buffer_t;
+#endif
+
+typedef struct function_bar_s 
+{
+	unsigned long base_addr;    		/* read from PCI config */
+	void * virt_addr;			/* mapped to kernel VA */
+	unsigned long size;         		/* size of BAR */
+} function_bar_t;
+
+/*
+ * PCI information
+ */
+struct pciext_pci_info_s 
+{
+#ifdef __CONF_DRV__
+	struct pci_dev *pdev;
+#endif
+	UINT device_id;
+	unsigned int irq;
+	UINT num_bars;
+	void * kern_timer_va;
+	void * kern_timer_ptr;
+	function_bar_t pci_bars[MAX_PCI_BARS];
+	unsigned int * lib_timer_va;
+#ifdef DEBUG_MMAP_WORKING
+    // new stuff for the big buffer:::
+	void * kern_buffer_va;
+	void * kern_buffer_ptr;
+	unsigned int * lib_buffer_va;
+#endif
+//	void * kmalloc_ptr;
+//	uint32_t* writeBuffer[TOTAL_DMA_ENGINES];
+//	uint32_t* readBuffer[TOTAL_DMA_ENGINES];
+//	dma_addr_t writeBufferDma[TOTAL_DMA_ENGINES];
+//	dma_addr_t readBufferDma[TOTAL_DMA_ENGINES];
+};
+
+typedef struct pciext_function_s 
+{
+	UINT device_id;
+	unsigned int irq;
+	UINT num_bars;
+	UINT bar_0_virtaddr;
+	UINT bar_2_virtaddr;
+	void * kern_timer_va;
+	UINT* writeBuffer;
+	UINT* readBuffer;
+	dma_addr_t writeBufferDma;
+	dma_addr_t readBufferDma;
+	function_bar_t pci_bars[MAX_PCI_BARS];
+	void * lib_timer_va;
+// new stuff for big buffer::
+#ifdef DEBUG_MMAP_WORKING
+    void * kern_buffer_va;
+	void * lib_buffer_va;
+#endif
+} pciext_function_t;
+
+typedef enum
+{
+	FALSE = 0,
+	TRUE
+} boolean;
+
+
+typedef struct
+{
+	boolean reserved;
+	unsigned int pciextIndex;
+	boolean pciextEnabled;
+	boolean master;
+
+	pciext_function_t pciextFunction;
+
+} pciext_device_t;
+
+#endif
+
+
+
-- 
1.7.5.4

