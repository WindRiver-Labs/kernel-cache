From f6920b734f2c1ef989ff562bad64afffddf587b1 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 12 Sep 2014 10:35:35 +0800
Subject: [PATCH] intel-quark: add Nexcom ESI-100 board support.

The following items are needed to be enabled by modifing kernel code:

- SLB9645TT TPM
- Single Ethernet Port (MAC0)

Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c   |   10 +
 drivers/platform/x86/quark/Makefile                |    1 +
 drivers/platform/x86/quark/intel_qrk_board_data.c  |    4 +
 drivers/platform/x86/quark/intel_qrk_plat_esi100.c |  195 ++++++++++++++++++++
 4 files changed, 210 insertions(+), 0 deletions(-)
 create mode 100755 drivers/platform/x86/quark/intel_qrk_plat_esi100.c

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
index 8dd98f0..462a648 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -154,6 +154,16 @@ static struct stmmac_qrk_mac_data phy_data [] = {
 		.bus_id		= 2,
 		.name		= "ReliaGate",
 	},
+	{
+		.phy_addr	= 1,
+		.bus_id		= 1,
+		.name		= "ESI100",
+	},
+	{
+		.phy_addr	= -1,
+		.bus_id		= 2,
+		.name		= "ESI100",
+	}
 };
 
 
diff --git a/drivers/platform/x86/quark/Makefile b/drivers/platform/x86/quark/Makefile
index 7dfd6de..2cb6e4f 100644
--- a/drivers/platform/x86/quark/Makefile
+++ b/drivers/platform/x86/quark/Makefile
@@ -17,3 +17,4 @@ obj-$(CONFIG_INTEL_QRK_THERMAL)	+= intel_qrk_thermal.o
 obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL) += intel_qrk_audio_ctrl.o
 obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_reliagate.o
 obj-$(CONFIG_INTEL_QRK_AUDIO_CTRL_RELIAGATE)	+= intel_qrk_audio_ctrl_reliagate.o
+obj-$(CONFIG_INTEL_QUARK_X1000_SOC)	+= intel_qrk_plat_esi100.o
diff --git a/drivers/platform/x86/quark/intel_qrk_board_data.c b/drivers/platform/x86/quark/intel_qrk_board_data.c
index 92eebfb..8f3adf4 100644
--- a/drivers/platform/x86/quark/intel_qrk_board_data.c
+++ b/drivers/platform/x86/quark/intel_qrk_board_data.c
@@ -143,6 +143,10 @@ static struct platform_device bsp_data [] = {
 		.name	= "ReliaGate",
 		.id	= -1,
 	},
+	{
+		.name	= "ESI100",
+		.id	= -1,
+	},
 };
 
 /**
diff --git a/drivers/platform/x86/quark/intel_qrk_plat_esi100.c b/drivers/platform/x86/quark/intel_qrk_plat_esi100.c
new file mode 100755
index 0000000..d73d440
--- /dev/null
+++ b/drivers/platform/x86/quark/intel_qrk_plat_esi100.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+/*
+ * Nexcom ESI-100 board entry point
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/platform_data/tpm_i2c_infenion.h>
+
+#define DRIVER_NAME		"ESI100"
+#define GPIO_RESTRICT_NAME_NC	"qrk-gpio-restrict-nc"
+#define GPIO_RESTRICT_NAME_SC	"qrk-gpio-restrict-sc"
+
+static int nc_gpio_reg;
+static int sc_gpio_reg;
+
+/* GPIO line used to reset SLB9645TT */
+#define GPIO_SLB9645TT_RESET		7
+/* GPIO line SLB9645TT interrupt are routed to */
+#define GPIO_SLB9645TT_INT		0
+
+#define SLB9645TT_ADDR			0x20
+
+static struct tpm_i2c_infenion_platform_data slb9645tt_platform_data = {
+	.gpio_reset = GPIO_SLB9645TT_RESET,
+	.gpio_irq = GPIO_SLB9645TT_INT,
+};
+
+static struct i2c_board_info probed_slb9645tt = {
+	.platform_data = &slb9645tt_platform_data,
+};
+
+static const unsigned short slb9645tt_i2c_addr[] =
+	{ SLB9645TT_ADDR, I2C_CLIENT_END };
+
+static struct gpio reserved_gpios[] = {
+	{
+		GPIO_SLB9645TT_RESET,
+		GPIOF_OUT_INIT_HIGH,
+		"slb96455tt-reset",
+	},
+	{
+		GPIO_SLB9645TT_INT,
+		GPIOF_IN,
+		"slb96455tt-int",
+	},
+};
+
+static int slb9645tt_i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return gpio_get_value(GPIO_SLB9645TT_RESET);
+}
+
+static int intel_qrk_slb9645tt_probe(void)
+{
+	struct i2c_adapter *i2c_adap;
+	struct i2c_client *slb9645tt;
+	int ret;
+
+	ret = gpio_request_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		pr_err("%s: unable to reserve the GPIOs for slb9645tt\n",
+			__func__);
+		return ret;
+	}
+
+	probed_slb9645tt.irq = gpio_to_irq(GPIO_SLB9645TT_INT);
+
+	i2c_adap = i2c_get_adapter(0);
+	if (!i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+			__func__);
+		ret = -EPROBE_DEFER;
+		goto err;
+	}
+
+	strlcpy(probed_slb9645tt.type, "slb9645tt", I2C_NAME_SIZE);
+	slb9645tt = i2c_new_probed_device(i2c_adap, &probed_slb9645tt,
+					  slb9645tt_i2c_addr, slb9645tt_i2c_probe);
+	i2c_put_adapter(i2c_adap);
+
+	if (!slb9645tt) {
+		pr_err("%s: can't probe slb9645tt\n", __func__);
+		ret = -ENODEV;
+		goto err;
+        }
+
+	return 0;
+err:
+	gpio_free_array(reserved_gpios, ARRAY_SIZE(reserved_gpios));
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_nc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_nc(struct platform_device *pdev)
+{
+	nc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1)
+		return intel_qrk_slb9645tt_probe();
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_restrict_probe_sc
+ *
+ * Make GPIOs pertaining to Firmware inaccessible by requesting them.  The
+ * GPIOs are never released nor accessed by this driver.
+ */
+static int intel_qrk_gpio_restrict_probe_sc(struct platform_device *pdev)
+{
+	sc_gpio_reg = 1;
+
+	if (nc_gpio_reg == 1 && sc_gpio_reg == 1)
+		return intel_qrk_slb9645tt_probe();
+
+	return 0;
+}
+
+static struct platform_driver gpio_restrict_pdriver_nc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_NC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_nc,
+};
+
+static struct platform_driver gpio_restrict_pdriver_sc = {
+	.driver		= {
+		.name	= GPIO_RESTRICT_NAME_SC,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_gpio_restrict_probe_sc,
+};
+
+static int intel_qrk_plat_esi100_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_driver_register(&gpio_restrict_pdriver_nc);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&gpio_restrict_pdriver_sc);
+}
+
+static int intel_qrk_plat_esi100_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver qrk_esi100_driver = {
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= intel_qrk_plat_esi100_probe,
+	.remove		= intel_qrk_plat_esi100_remove,
+};
+
+module_platform_driver(qrk_esi100_driver);
+
+MODULE_AUTHOR("Lans Zhang <jia.zhang@windriver.com>");
+MODULE_DESCRIPTION("ESI-100 BSP Data");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:"DRIVER_NAME);
\ No newline at end of file
-- 
1.7.5.4

