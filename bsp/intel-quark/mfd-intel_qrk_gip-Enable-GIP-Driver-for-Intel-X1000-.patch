From 99349a41a3f86e0f11546be5d4d35ab669133dd9 Mon Sep 17 00:00:00 2001
From: "Tan, Raymond" <raymond.tan@intel.com>
Date: Mon, 13 Apr 2015 13:34:56 +0800
Subject: [PATCH] mfd: intel_qrk_gip: Enable GIP Driver for Intel X1000 SoC

This patch is to enable the GIP for Quark X1000 SoC. It was
part of a larger patch from Quark BSP R1.1 and it was adapted
to kernel version 3.14.

The explicit_stop logic of the original is removed, due to there
have been changes made in mainline to restart the i2c transaction.

The original author of this driver is
Josef Ahmad <josef.ahmad@linux.intel.com>

Signed-off-by: Tan, Raymond <raymond.tan@intel.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>

diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index d66b6cbc9edc..b4371276be28 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -34,6 +34,14 @@
 #define DW_IC_CON_RESTART_EN		0x20
 #define DW_IC_CON_SLAVE_DISABLE		0x40
 
+struct dw_pci_controller {
+	u32 bus_num;
+	u32 bus_cfg;
+	u32 tx_fifo_depth;
+	u32 rx_fifo_depth;
+	u32 clk_khz;
+	u8  explicit_stop;
+};
 
 /**
  * struct dw_i2c_dev - private i2c-designware data
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 101b97fbb024..d56ebb5f4ca9 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1055,6 +1055,32 @@ config MFD_PCA9685
 	  Additionally, the driver allows the channels to be configured as GPIO
 	  interface (output only).
 
+config INTEL_QRK_GIP
+	tristate "Intel Quark GIP"
+	depends on PCI && X86 && X86_INTEL_QUARK
+	depends on I2C
+	select GENERIC_IRQ_CHIP
+	help
+	  GIP driver for Quark SoC.
+	  Quark GIP is a single PCI function exporting a GPIO and an I2C
+	  controller, namely Synopsys DesignWare GPIO and Synopsys DesignWare
+	  I2C.  The GPIO interface exports a total amount of 8 interrupt-capable
+	  GPIOs.
+
+config INTEL_QRK_GIP_TEST
+	tristate "Intel Quark GIP support for Integration Testing"
+	depends on INTEL_QRK_GIP
+	select I2C_CHARDEV
+	select GPIO_SYSFS
+	select SPI
+	select SPI_BITBANG
+	select SPI_GPIO
+	select SPI_MASTER
+	select SPI_SPIDEV
+	help
+	  Quark GIP automated Integration Testing package.
+	  It selects kernel components needed for GPIO and I2C tests as per
+
 config MFD_TC3589X
 	bool "Toshiba TC35892 and variants"
 	depends on I2C=y
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 426179f26778..43c8368e58b5 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -139,6 +139,12 @@ obj-$(CONFIG_MFD_INTEL_QUARK_I2C_GPIO)	+= intel_quark_i2c_gpio.o
 obj-$(CONFIG_CY8C9540A)		+= cy8c9540a.o
 pca9685-objs			:= pca9685-core.o pca9685-gpio.o pca9685-pwm.o
 obj-$(CONFIG_MFD_PCA9685)	+= pca9685.o
+obj-$(CONFIG_INTEL_QRK_GIP)	+= intel_qrk_gip.o
+intel_qrk_gip-objs		:= intel_qrk_gip_core.o \
+					intel_qrk_gip_gpio.o \
+					intel_qrk_gip_i2c.o \
+					../i2c/busses/i2c-designware-core.o
+obj-$(CONFIG_X86_INTEL_QUARK)	+= intel_qrk_gip_pdata.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
 obj-$(CONFIG_LPC_ICH)		+= lpc_ich.o
 obj-$(CONFIG_MFD_RDC321X)	+= rdc321x-southbridge.o
diff --git a/drivers/mfd/intel_qrk_gip.h b/drivers/mfd/intel_qrk_gip.h
new file mode 100644
index 000000000000..0b40638c9111
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) driver
+ */
+
+#ifndef __INTEL_QRKGIP_H__
+#define __INTEL_QRKGIP_H__
+
+#include <linux/i2c.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/pci.h>
+#include "../i2c/busses/i2c-designware-core.h"
+
+/* PCI BAR for register base address */
+#define GIP_I2C_BAR		0
+#define GIP_GPIO_BAR		1
+
+/**
+ * intel_qrk_gpio_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_qrk_gpio_probe(struct pci_dev *pdev);
+
+/**
+ * intel_qrk_gpio_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_gpio_remove(struct pci_dev *pdev);
+
+/**
+ * intel_qrk_gpio_isr
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: used to distinguish the device (for shared interrupts)
+ *
+ * Perform GPIO-specific ISR of the top-level GIP driver.
+ */
+irqreturn_t intel_qrk_gpio_isr(int irq, void *dev_id);
+
+/**
+ * intel_qrk_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_qrk_gpio_save_state(void);
+
+/**
+ * intel_qrk_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_qrk_gpio_restore_state(void);
+
+/**
+ * intel_qrk_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @param drvdata: GIP platform-specific settings
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ */
+int intel_qrk_i2c_probe(struct pci_dev *pdev,
+			struct dw_i2c_dev **drvdata,
+			struct intel_qrk_gip_pdata *pdata);
+
+/**
+ * intel_qrk_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev);
+
+#endif /* __INTEL_QRKGIP_H__ */
diff --git a/drivers/mfd/intel_qrk_gip_core.c b/drivers/mfd/intel_qrk_gip_core.c
new file mode 100644
index 000000000000..08644a0c832f
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_core.c
@@ -0,0 +1,328 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) PCI driver
+ *
+ *  PCI glue logic for Quark GIP driver.
+ *  Quark GIP is a single PCI function exporting a GPIO and an I2C device.
+ *  The PCI driver performs the bus-dependent probe/release operations, and
+ *  call into GPIO/I2C specific modules for handling the two diffrerent
+ *  functionalities.
+ */
+
+#include <asm/qrk.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_qrk_gip.h"
+
+static unsigned int enable_msi = 1;
+module_param(enable_msi, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(enable_msi, "Enable PCI MSI mode");
+
+static unsigned int i2c = 1;
+module_param(i2c, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(i2c, "Register I2C adapter");
+
+static unsigned int gpio = 1;
+module_param(gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio, "Register GPIO chip");
+
+/* GIP private data, supporting only a single instance of the device. */
+struct intel_qrk_gip_data {
+	struct pci_dev *pci_device;
+	struct dw_i2c_dev *i2c_drvdata;
+	struct intel_qrk_gip_pdata *pdata;
+};
+
+/**
+ * intel_qrk_gip_handler
+ *
+ * @param irq: IRQ number to be served
+ * @param dev_id: device private data
+ *
+ * Top-level interrupt handler for GIP driver.
+ * It calls into the appropriate sub-routines and gathers the return values.
+ */
+static irqreturn_t intel_qrk_gip_handler(int irq, void *dev_id)
+{
+	irqreturn_t ret_i2c = IRQ_NONE;
+	irqreturn_t ret_gpio = IRQ_NONE;
+	struct intel_qrk_gip_data *data = (struct intel_qrk_gip_data *)dev_id;
+
+	mask_pvm(data->pci_device);
+
+	if (likely(i2c)) {
+		/* Only I2C gets platform data */
+		ret_i2c = i2c_dw_isr(irq, data->i2c_drvdata);
+	}
+
+	if (likely(gpio)) {
+		ret_gpio = intel_qrk_gpio_isr(irq, NULL);
+	}
+
+	unmask_pvm(data->pci_device);
+
+	if (likely(IRQ_HANDLED == ret_i2c || IRQ_HANDLED == ret_gpio))
+		return IRQ_HANDLED;
+
+	/* Each sub-ISR routine returns either IRQ_HANDLED or IRQ_NONE. */
+	return IRQ_NONE;
+}
+
+static DEFINE_PCI_DEVICE_TABLE(intel_qrk_gip_ids) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0934), },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_qrk_gip_ids);
+
+#ifdef CONFIG_PM
+
+/**
+ * qrk_gip_suspend
+ *
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to sleep state.
+ * Save context, disable GPIO chip and I2C adapter, transition PCI device into
+ * low-power state.
+ */
+static int qrk_gip_suspend(struct device *dev)
+{
+	int err = 0;
+	struct intel_qrk_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	i2c_dw_disable(data->i2c_drvdata);
+	intel_qrk_gpio_save_state();
+
+	err = pci_save_state(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "pci_save_state failed\n");
+		return err;
+	}
+
+	err = pci_set_power_state(pdev, PCI_D3hot);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * qrk_gip_resume
+ *
+ * @param device: Pointer to device
+ * @return 0 success < 0 failure
+ *
+ * Prepare GIP for system-wide transition to fully active state.
+ * Set PCI device into full-power state, restore context, enable I2C adapter
+ * and GPIO chip.
+ */
+static int qrk_gip_resume(struct device *dev)
+{
+	int err = 0;
+	struct intel_qrk_gip_data *data = NULL;
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	err = pci_set_power_state(pdev, PCI_D0);
+	if (err) {
+		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
+		return err;
+	}
+
+	pci_restore_state(pdev);
+
+	intel_qrk_gpio_restore_state();
+	i2c_dw_init(data->i2c_drvdata);
+
+	return 0;
+}
+
+#else
+#define qrk_gip_suspend		NULL
+#define qrk_gip_resume		NULL
+#endif
+
+static const struct dev_pm_ops qrk_gip_pm_ops = {
+	.resume         = qrk_gip_resume,
+	.suspend        = qrk_gip_suspend,
+};
+
+/**
+ * intel_qrk_gip_probe
+ *
+ * @param pdev: Pointer to GIP PCI device
+ * @param id: GIP PCI Device ID
+ * @return 0 success < 0 failure
+ *
+ * GIP PCI driver probing. Calls into the appropriate probe routines for GPIO
+ * and I2C too.
+ */
+static int intel_qrk_gip_probe(struct pci_dev *pdev,
+				const struct pci_device_id *id)
+{
+	int retval = 0;
+	struct intel_qrk_gip_data *gip_drvdata = NULL;
+
+	retval = pci_enable_device(pdev);
+	if (retval)
+		return retval;
+
+	retval = pci_request_regions(pdev, "qrk-gip");
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting PCI region\n");
+		goto err_pcidev_disable;
+	}
+
+	gip_drvdata = kzalloc(sizeof(struct intel_qrk_gip_data), GFP_KERNEL);
+	if (NULL == gip_drvdata) {
+		retval = -ENOMEM;
+		goto err_pciregions_release;
+	}
+	pci_set_drvdata(pdev, gip_drvdata);
+
+	gip_drvdata->pci_device = pdev;
+
+	/* Retrieve platform data if there is any */
+	if (*intel_qrk_gip_get_pdata) {
+		gip_drvdata->pdata = intel_qrk_gip_get_pdata();
+	}
+
+	if (gpio) {
+		retval = intel_qrk_gpio_probe(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (i2c) {
+		retval = intel_qrk_i2c_probe(pdev,
+			(struct dw_i2c_dev **)&gip_drvdata->i2c_drvdata,
+			gip_drvdata->pdata);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	if (enable_msi) {
+		pci_set_master(pdev);
+		retval = pci_enable_msi(pdev);
+		if (retval)
+			goto err_release_drvdata;
+	}
+
+	/*
+	 * Request a shared IRQ.
+	 * Since the dev_id cannot be NULL, it points to PCI device descriptor
+	 * if I2C is not registered.
+	 */
+	retval = request_irq(pdev->irq, intel_qrk_gip_handler, IRQF_SHARED,
+			"intel_qrk_gip", gip_drvdata);
+	if (retval) {
+		dev_err(&pdev->dev, "error requesting IRQ\n");
+		goto err;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	pci_set_drvdata(pdev, NULL);
+	kfree(gip_drvdata);
+err:
+	if (enable_msi)
+		pci_disable_msi(pdev);
+err_pciregions_release:
+	pci_release_regions(pdev);
+err_pcidev_disable:
+	pci_disable_device(pdev);
+
+	return retval;
+}
+
+/**
+ * intel_qrk_gip_remove
+ *
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Release resources. Calls into GPIO/I2C dedicate routines too.
+ */
+static void intel_qrk_gip_remove(struct pci_dev *pdev)
+{
+	struct intel_qrk_gip_data *data = NULL;
+
+	data = (struct intel_qrk_gip_data *)pci_get_drvdata(pdev);
+
+	if (NULL == data) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	free_irq(pdev->irq, data);
+
+	if (enable_msi) {
+		pci_clear_master(pdev);
+		if (pci_dev_msi_enabled(pdev))
+			pci_disable_msi(pdev);
+	}
+
+	if (i2c)
+		intel_qrk_i2c_remove(pdev, data->i2c_drvdata);
+
+	if (gpio)
+		intel_qrk_gpio_remove(pdev);
+
+	pci_set_drvdata(pdev, NULL);
+	kfree(data);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver intel_qrk_gip_driver = {
+	.name =		"intel_qrk_gip",
+	.id_table	= intel_qrk_gip_ids,
+	.probe		= intel_qrk_gip_probe,
+	.remove		= intel_qrk_gip_remove,
+	.driver         = {
+		.pm     = &qrk_gip_pm_ops,
+	},
+};
+
+static int intel_qrk_gip_init(void)
+{
+	return pci_register_driver(&intel_qrk_gip_driver);
+}
+
+static void intel_qrk_gip_exit(void)
+{
+	pci_unregister_driver(&intel_qrk_gip_driver);
+}
+
+module_init(intel_qrk_gip_init);
+module_exit(intel_qrk_gip_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Quark GIP driver");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/mfd/intel_qrk_gip_gpio.c b/drivers/mfd/intel_qrk_gip_gpio.c
new file mode 100644
index 000000000000..ce9ec24558a9
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_gpio.c
@@ -0,0 +1,671 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) - GPIO-specific PCI and core driver
+ *
+ *  PCI glue logic and core driver for Quark GIP/GPIO.
+ *  The GIP GPIO device is the DesignWare GPIO. This file defines the PCI glue
+ *  for this driver and as well as the core logic for the device.
+ *  Please note only a single instance of the GPIO device is supported.
+ *  The default number of GPIO is 8, all interrupt-capable.
+ */
+
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include "intel_qrk_gip.h"
+
+static void qrk_gpio_restrict_release(struct device *dev) {}
+static struct platform_device qrk_gpio_restrict_pdev =
+{
+	.name	= "qrk-gpio-restrict-sc",
+	.dev.release = qrk_gpio_restrict_release,
+};
+struct uio_info *info;
+
+/* The base GPIO number under GPIOLIB framework */
+#define INTEL_QRK_GIP_GPIO_BASE		8
+
+/* The default number of South-Cluster GPIO on Quark. */
+#define INTEL_QRK_GIP_NGPIO		8
+
+/*
+ * The default base IRQ for searching and allocating the range of GPIO IRQ
+ * descriptors.
+ */
+#define INTEL_QRK_GIP_GPIO_IRQBASE	56
+
+/* The GPIO private data. */
+static struct gpio_chip *gc;
+static struct irq_chip_generic *igc;
+static void __iomem *reg_base;
+static spinlock_t lock;
+static int irq_base;
+static unsigned int n_gpio = INTEL_QRK_GIP_NGPIO;
+static unsigned int gpio_irqbase = INTEL_QRK_GIP_GPIO_IRQBASE;
+
+/* Store GPIO context across system-wide suspend/resume transitions */
+static struct gpio_saved_regs {
+	u32 data;
+	u32 dir;
+	u32 int_en;
+	u32 int_mask;
+	u32 int_type;
+	u32 int_pol;
+	u32 int_deb;
+} saved_regs;
+
+/* PortA registers set. Note other ports are unused */
+#define PORTA_DATA			0x00	/* Data */
+#define PORTA_DIR			0x04	/* Direction */
+#define PORTA_INT_EN			0x30	/* Interrupt enable */
+#define PORTA_INT_MASK			0x34	/* Interrupt mask */
+#define PORTA_INT_TYPE_LEVEL		0x38	/* Interrupt level*/
+#define PORTA_INT_POLARITY		0x3c	/* Interrupt polarity */
+#define PORTA_INT_STATUS		0x40	/* Interrupt status */
+#define PORTA_INT_RAW_STATUS		0x44	/* Interrupt raw status */
+#define PORTA_DEBOUNCE			0x48	/* Debounce enable */
+#define PORTA_INT_EOI			0x4c	/* Clear interrupt */
+#define PORTA_EXT			0x50	/* External */
+
+module_param(n_gpio, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(n_gpio, "Number of GPIO");
+
+module_param(gpio_irqbase, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(gpio_irqbase, "Base IRQ for GPIO range");
+
+/**
+ * intel_qrk_gpio_get
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return 0 if GPIO is deasserted, 1 if GPIO is asserted
+ *
+ * Read back the value of a GPIO.
+ */
+static int intel_qrk_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *reg_ext = reg_base + PORTA_EXT;
+	u32 val_ext = ioread32(reg_ext);
+
+	val_ext &= BIT(offset % 32);
+	return (val_ext > 0);
+}
+
+/**
+ * intel_qrk_gpio_set
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ *
+ * Set value of a GPIO.
+ */
+static void intel_qrk_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	void __iomem *reg_data = reg_base + PORTA_DATA;
+	u32 val_data = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_data = ioread32(reg_data);
+	if (value)
+		iowrite32(val_data | BIT(offset % 32), reg_data);
+	else
+		iowrite32(val_data & ~BIT(offset % 32), reg_data);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_direction_input
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return always 0 (success)
+ *
+ * Set direction of a GPIO as input.
+ */
+static int intel_qrk_gpio_direction_input(struct gpio_chip *chip,
+						unsigned offset)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir & ~BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_direction_output
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param value: value to be driven to the GPIO
+ * @return always 0 (success)
+ *
+ * Set the default value of a GPIO, and then set direction as output.
+ */
+static int intel_qrk_gpio_direction_output(struct gpio_chip *chip,
+			unsigned offset, int value)
+{
+	u32 val_dir = 0;
+	void __iomem *reg_dir = reg_base + PORTA_DIR;
+	unsigned long flags = 0;
+
+	/* Ensure glitch-free operation. */
+	intel_qrk_gpio_set(chip, offset, value);
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_dir = ioread32(reg_dir);
+	iowrite32(val_dir | BIT(offset % 32), reg_dir);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_set_debounce
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @param debounce: 1 to enable, 0 to disable
+ * @return always 0 (success)
+ *
+ * Enable/disable interrupt debounce logic for a GPIO.
+ */
+static int intel_qrk_gpio_set_debounce(struct gpio_chip *chip,
+				 unsigned offset, unsigned debounce)
+{
+	u32 val_deb = 0;
+	void __iomem *reg_deb = reg_base + PORTA_DEBOUNCE;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_deb = ioread32(reg_deb);
+	if (debounce)
+		iowrite32(val_deb | BIT(offset % 32), reg_deb);
+	else
+		iowrite32(val_deb & ~BIT(offset % 32), reg_deb);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+}
+
+/**
+ * intel_qrk_gpio_irq_type
+ * @param irq_data: Pointer to information about the IRQ
+ * @param type: set the triggering type of the interrupt
+ * @return always 0 (success)
+ *
+ * Set interrupt triggering type for a GPIO.
+ *
+ * intel_qrk_gpio_irq_type() is called with irq_desc lock held.
+ *
+ */
+static int intel_qrk_gpio_irq_type(struct irq_data *d, unsigned type)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+	void __iomem *reg_level = reg_base + PORTA_INT_TYPE_LEVEL;
+	void __iomem *reg_pol = reg_base + PORTA_INT_POLARITY;
+	u32 val_level = 0;
+	u32 val_pol = 0;
+	u32 gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n",  __func__);
+		return -EFAULT;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+
+	val_level = ioread32(reg_level);
+	val_pol = ioread32(reg_pol);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		iowrite32(val_level | BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol | BIT(gpio % 32), reg_pol);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		iowrite32(val_level & ~BIT(gpio % 32), reg_level);
+		iowrite32(val_pol & ~BIT(gpio % 32), reg_pol);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
+		__irq_set_handler_locked(d->irq, handle_level_irq);
+	} else if (type & IRQ_TYPE_EDGE_BOTH) {
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_irq_unmask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Unmask interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_unmask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask & ~BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_mask
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Mask interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_mask(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_mask = reg_base + PORTA_INT_MASK;
+	u32 val_mask = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_mask =  ioread32(reg_mask);
+	iowrite32(val_mask | BIT(gpio % 32), reg_mask);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_enable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Enable interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_enable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte | BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_disable
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Disable interrupts for a GPIO.
+ */
+static void intel_qrk_gpio_irq_disable(struct irq_data *d)
+{
+	unsigned long flags = 0;
+	void __iomem *reg_inte = reg_base + PORTA_INT_EN;
+	u32 val_inte = 0;
+	unsigned gpio = 0;
+
+	if (NULL == d) {
+		pr_err("%s(): null irq_data\n", __func__);
+		return;
+	}
+
+	gpio = d->irq - irq_base;
+
+	spin_lock_irqsave(&lock, flags);
+	val_inte =  ioread32(reg_inte);
+	iowrite32(val_inte & ~BIT(gpio % 32), reg_inte);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_irq_ack
+ * @param irq_data: Pointer to information about the IRQ
+ *
+ * Acknowledge the edge triggered interrupt by writing the appropriate bit to
+ * the gpio_porta_eoi register. This function is called by the irq flow
+ * handler.
+ */
+static void intel_qrk_gpio_irq_ack(struct irq_data *d)
+{
+	void __iomem *reg_eoi = reg_base + PORTA_INT_EOI;
+	u32 line = d->irq - irq_base;
+
+	iowrite32(BIT(line), reg_eoi);
+}
+
+/**
+ * intel_qrk_gpio_to_irq
+ * @param chip: Pointer to GPIO chip registered by GPIOLIB
+ * @param offset: the GPIO number within the GPIOLIB chip
+ * @return IRQ associated to GPIO
+ *
+ * Compute the IRQ number based on the GPIO.
+ */
+static int intel_qrk_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	return irq_base + offset;
+}
+
+/**
+ * intel_qrk_gpio_isr
+ * @param irq: IRQ number
+ * @param dev_id: cookie used to tell what instance of the driver the interrupt
+ *                belongs to
+ * @return IRQ_HANDLED if interrupt served, IRQ_NONE if no interrupt pending
+ *
+ * Interrupt Service Routine for GPIO. Identify which GPIOs (if any) is pending
+ * for interrupt to be served, acknowledge the interrupt and serve it.
+ */
+irqreturn_t intel_qrk_gpio_isr(int irq, void *dev_id)
+{
+	irqreturn_t ret = IRQ_NONE;
+	u32 pending = 0, gpio = 0;
+	void __iomem *reg_pending = reg_base + PORTA_INT_STATUS;
+
+	/* Which pin (if any) triggered the interrupt */
+	while ((pending = ioread32(reg_pending))) {
+
+		/* Serve each asserted interrupt */
+		do {
+			gpio = __ffs(pending);
+			generic_handle_irq(
+				gpio_to_irq(INTEL_QRK_GIP_GPIO_BASE + gpio));
+			pending &= ~BIT(gpio);
+			ret = IRQ_HANDLED;
+		} while(pending);
+	}
+
+	return ret;
+}
+
+/**
+ * intel_qrk_gpio_save_state
+ *
+ * Save GPIO register state for system-wide suspend events and mask out
+ * interrupts.
+ */
+void intel_qrk_gpio_save_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	saved_regs.int_mask = ioread32(reg_base + PORTA_INT_MASK);
+	saved_regs.int_en = ioread32(reg_base + PORTA_INT_EN);
+	saved_regs.int_deb = ioread32(reg_base + PORTA_DEBOUNCE);
+	saved_regs.int_pol = ioread32(reg_base + PORTA_INT_POLARITY);
+	saved_regs.int_type = ioread32(reg_base + PORTA_INT_TYPE_LEVEL);
+	saved_regs.dir = ioread32(reg_base + PORTA_DIR);
+	saved_regs.data = ioread32(reg_base + PORTA_DATA);
+
+	/* Mask out interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_MASK);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_restore_state
+ *
+ * Restore GPIO register state for system-wide resume events and clear out
+ * spurious interrupts.
+ */
+void intel_qrk_gpio_restore_state(void)
+{
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	iowrite32(saved_regs.data, reg_base + PORTA_DATA);
+	iowrite32(saved_regs.dir, reg_base + PORTA_DIR);
+	iowrite32(saved_regs.int_type, reg_base + PORTA_INT_TYPE_LEVEL);
+	iowrite32(saved_regs.int_pol, reg_base + PORTA_INT_POLARITY);
+	iowrite32(saved_regs.int_deb, reg_base + PORTA_DEBOUNCE);
+	iowrite32(saved_regs.int_en, reg_base + PORTA_INT_EN);
+	iowrite32(saved_regs.int_mask, reg_base + PORTA_INT_MASK);
+
+	/* Clear out spurious interrupts */
+	iowrite32(0xffffffff, reg_base + PORTA_INT_EOI);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+/**
+ * intel_qrk_gpio_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @return 0 success < 0 failure
+ *
+ * Perform GPIO-specific probing on behalf of the top-level GIP driver.
+ * Initiate the GPIO device.
+ */
+int intel_qrk_gpio_probe(struct pci_dev *pdev)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+
+	/* Get UIO memory */
+	info = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	/* Determine the address of the GPIO area */
+	start = pci_resource_start(pdev, GIP_GPIO_BAR);
+	len = pci_resource_len(pdev, GIP_GPIO_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_GPIO_BAR);
+		retval = -ENODEV;
+		goto exit;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (NULL == reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	memset(&saved_regs, 0x0, sizeof(saved_regs));
+
+	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
+	if (!gc) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	if (n_gpio == 0 || n_gpio > INTEL_QRK_GIP_NGPIO) {
+		dev_err(&pdev->dev, "n_gpio outside range [1,%d]\n",
+			INTEL_QRK_GIP_NGPIO);
+		retval = -EINVAL;
+		goto err_free_gpiochip;
+	}
+
+	gc->label = "intel_qrk_gip_gpio";
+	gc->owner = THIS_MODULE;
+	gc->direction_input = intel_qrk_gpio_direction_input;
+	gc->direction_output = intel_qrk_gpio_direction_output;
+	gc->get = intel_qrk_gpio_get;
+	gc->set = intel_qrk_gpio_set;
+	gc->set_debounce = intel_qrk_gpio_set_debounce;
+	gc->to_irq = intel_qrk_gpio_to_irq;
+	gc->base = INTEL_QRK_GIP_GPIO_BASE;
+	gc->ngpio = n_gpio;
+	gc->can_sleep = 0;
+	retval = gpiochip_add(gc);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding GPIO chip\n");
+		goto err_free_gpiochip;
+	}
+
+	spin_lock_init(&lock);
+
+	/*
+	 * Allocate a range of IRQ descriptor for the available GPIO.
+	 * IRQs are allocated dynamically.
+	 */
+	irq_base = irq_alloc_descs(-1, gpio_irqbase, n_gpio, NUMA_NO_NODE);
+	if (irq_base < 0) {
+		dev_err(&pdev->dev, "failure adding GPIO IRQ descriptors\n");
+		goto err_remove_gpiochip;
+	}
+
+	retval = platform_device_register(&qrk_gpio_restrict_pdev);
+	if (retval < 0){
+		goto err_free_irq_descs;
+	}
+
+	igc = irq_alloc_generic_chip("intel_qrk_gip_gpio", 1, irq_base,
+			reg_base, handle_simple_irq);
+	if (NULL == igc) {
+		retval = -ENOMEM;
+		goto err_free_irq_descs;
+	}
+
+	/* UIO */
+	info->mem[0].addr = start;
+	info->mem[0].internal_addr = reg_base;
+	info->mem[0].size = len;
+	info->mem[0].memtype = UIO_MEM_PHYS;
+	info->mem[0].name = "gpio_regs";
+	info->name = "gpio uio";
+	info->version = "0.0.1";
+
+	if (uio_register_device(&pdev->dev, info))
+		goto err_free_irq_descs;
+
+	pr_info("%s UIO addr 0x%08x internal_addr 0x%08x size %lu memtype %d\n",
+		__func__, (unsigned int)info->mem[0].addr,
+		(unsigned int)info->mem[0].internal_addr, info->mem[0].size,
+		info->mem[0].memtype);
+	igc->chip_types->chip.irq_mask = intel_qrk_gpio_irq_mask;
+	igc->chip_types->chip.irq_unmask = intel_qrk_gpio_irq_unmask;
+	igc->chip_types->chip.irq_set_type = intel_qrk_gpio_irq_type;
+	igc->chip_types->chip.irq_enable = intel_qrk_gpio_irq_enable;
+	igc->chip_types->chip.irq_disable = intel_qrk_gpio_irq_disable;
+	igc->chip_types->chip.irq_ack = intel_qrk_gpio_irq_ack;
+
+	irq_setup_generic_chip(igc, IRQ_MSK(n_gpio), IRQ_GC_INIT_MASK_CACHE,
+			IRQ_NOREQUEST | IRQ_NOPROBE, 0);
+
+	return 0;
+
+err_free_irq_descs:
+	irq_free_descs(irq_base, n_gpio);
+err_remove_gpiochip:
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+err_free_gpiochip:
+	kfree(gc);
+err_iounmap:
+	iounmap(reg_base);
+exit:
+	if (info != NULL)
+		kfree(info);
+	return retval;
+}
+
+/**
+ * intel_qrk_gpio_remove
+ * @param pdev: Pointer to GIP PCI device
+ *
+ * Perform GPIO-specific resource release on behalf of the top-level GIP
+ * driver.
+ */
+void intel_qrk_gpio_remove(struct pci_dev *pdev)
+{
+	if (NULL == igc) {
+		dev_err(&pdev->dev, "null pointer to irq_generic_chip\n");
+		return;
+	}
+	if (NULL == gc) {
+		dev_err(&pdev->dev, "null pointer to gpio_chip\n");
+		return;
+	}
+
+	/* Tear down IRQ descriptors */
+	irq_remove_generic_chip(igc, IRQ_MSK(n_gpio), 0,
+		IRQ_NOREQUEST | IRQ_NOPROBE);
+	kfree(igc);
+	irq_free_descs(irq_base, n_gpio);
+
+	platform_device_unregister(&qrk_gpio_restrict_pdev);
+
+	/* Release GPIO chip */
+	if (0 != gpiochip_remove(gc))
+		dev_err(&pdev->dev, "failed removing gpio_chip\n");
+
+
+	if (info != NULL){
+		uio_unregister_device(info);
+		kfree(info);
+	}
+
+	kfree(gc);
+	iounmap(reg_base);
+}
diff --git a/drivers/mfd/intel_qrk_gip_i2c.c b/drivers/mfd/intel_qrk_gip_i2c.c
new file mode 100644
index 000000000000..754bac21936d
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_i2c.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) - I2C-specific PCI driver
+ *
+ *  PCI glue logic for Quark GIP/I2C.
+ *  The GIP I2C device is the DesignWare I2C. This file defines the PCI glue
+ *  for this driver and is heavily based on
+ *  on drivers/i2c/busses/i2c-designware-pcidrv.c.  Also, it relies on
+ *  drivers/i2c/busses/i2c-designware-core.c for the core logic.
+ *  Please note only a single instance of the I2C device is supported.
+ */
+
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include "intel_qrk_gip.h"
+
+enum dw_pci_ctl_id_t {
+	quark_0,
+};
+
+/*
+ * By default, driver operates in fast mode (400kHz).
+ *
+ * Standard mode operation (100kHz) can be forced via, in order of priority:
+ * 1. setting the following i2c_std_mode module parameter to 1
+ * 2. setting the platform data i2c_std_mode parameter to 1
+ *
+ * Note in both cases, setting i2c_std_mode to 0 means forcing fast mode
+ * operation.
+ */
+static unsigned int i2c_std_mode = -1;
+module_param(i2c_std_mode, uint, S_IRUSR);
+MODULE_PARM_DESC(i2c_std_mode, "Set to 1 to force I2C standard mode");
+
+#define INTEL_QRK_STD_CFG  (DW_IC_CON_MASTER |			\
+				DW_IC_CON_SLAVE_DISABLE |	\
+				DW_IC_CON_RESTART_EN)
+
+static struct dw_pci_controller qrk_gip_i2c_controller = {
+	.bus_num	= 0,
+	.bus_cfg	= INTEL_QRK_STD_CFG | DW_IC_CON_SPEED_FAST,
+	.tx_fifo_depth	= 16,
+	.rx_fifo_depth	= 16,
+	.clk_khz	=
+#ifdef CONFIG_INTEL_QUARK_X1000_SOC_FPGAEMU
+			14000,
+#else
+			33000,
+#endif
+	//.explicit_stop	= 1,
+};
+
+static struct i2c_algorithm i2c_dw_algo = {
+	.master_xfer	= i2c_dw_xfer,
+	.functionality	= i2c_dw_func,
+};
+
+/**
+ * i2c_dw_get_clk_rate_khz
+ * @param dev: Pointer to I2C device private data
+ * @return clock rate in kHz
+ *
+ * Ancillary function returning the frequency of the clock supplied to the
+ * interface.
+ */
+static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+{
+	return dev->controller->clk_khz;
+}
+
+/**
+ * intel_qrk_i2c_probe
+ * @param pdev: Pointer to GIP PCI device
+ * @param drvdata: private driver data
+ * @return 0 success < 0 failure
+ *
+ * Perform I2C-specific probing on behalf of the top-level GIP driver.
+ * Also call into I2C core driver routines for initiating the device.
+ */
+int intel_qrk_i2c_probe(struct pci_dev *pdev,
+			struct dw_i2c_dev **drvdata,
+			struct intel_qrk_gip_pdata *pdata)
+{
+	int retval = 0;
+	resource_size_t start = 0, len = 0;
+	struct dw_i2c_dev *dev = NULL;
+	struct i2c_adapter *adap = NULL;
+	void __iomem *reg_base = NULL;
+	struct dw_pci_controller *controller = NULL;
+	int std_mode = -1;
+
+	controller = &qrk_gip_i2c_controller;
+
+	/* Quark default configuration is fast mode, unless otherwise forced */
+	if (-1 != i2c_std_mode) {
+		switch (i2c_std_mode) {
+		case 0:
+		case 1:
+			std_mode = i2c_std_mode;
+			break;
+		default:
+			dev_err(&pdev->dev, "invalid i2c_std_mode param val %d."
+				" Using driver default\n", i2c_std_mode);
+			break;
+		}
+	} else if (pdata) {
+		switch (pdata->i2c_std_mode) {
+		case 0:
+		case 1:
+			std_mode = pdata->i2c_std_mode;
+			break;
+		default:
+			dev_err(&pdev->dev, "invalid i2c_std_mode pdata val %d."
+				" Usign driver default\n", pdata->i2c_std_mode);
+			break;
+		}
+	}
+	if (-1 != std_mode) {
+		if (0 == std_mode) {
+			controller->bus_cfg |= DW_IC_CON_SPEED_FAST;
+			controller->bus_cfg &= ~DW_IC_CON_SPEED_STD;
+		} else {
+			controller->bus_cfg &= ~DW_IC_CON_SPEED_FAST;
+			controller->bus_cfg |= DW_IC_CON_SPEED_STD;
+		}
+		dev_info(&pdev->dev, "i2c speed set to %skHz\n",
+			 std_mode ? "100" : "400");
+	}
+
+	/* Determine the address of the I2C area */
+	start = pci_resource_start(pdev, GIP_I2C_BAR);
+	len = pci_resource_len(pdev, GIP_I2C_BAR);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "bar%d not set\n", GIP_I2C_BAR);
+		retval = -ENODEV;
+		goto err;
+	}
+
+	reg_base = ioremap_nocache(start, len);
+	if (!reg_base) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev) {
+		retval = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->clk = NULL;
+	dev->controller = controller;
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+	dev->base = reg_base;
+	dev->dev = get_device(&pdev->dev);
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->master_cfg =  controller->bus_cfg;
+
+	*drvdata = dev;
+
+	dev->tx_fifo_depth = controller->tx_fifo_depth;
+	dev->rx_fifo_depth = controller->rx_fifo_depth;
+	//dev->explicit_stop = controller->explicit_stop;
+
+	/* dw_i2c_dev additional parameters in Kernel 3.14 */
+	dev->sda_hold_time	= 0;
+	dev->sda_falling_time	= 300;
+	dev->scl_falling_time	= 300;
+	dev->ss_hcnt		= 0;
+	dev->ss_lcnt		= 0;
+	dev->fs_hcnt		= 0;
+	dev->fs_lcnt		= 0;
+
+	retval = i2c_dw_init(dev);
+	if (retval)
+		goto err_release_drvdata;
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = 0;
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->nr = controller->bus_num;
+	snprintf(adap->name, sizeof(adap->name), "intel_qrk_gip_i2c");
+
+	i2c_dw_disable_int(dev);
+	i2c_dw_clear_int(dev);
+	retval = i2c_add_numbered_adapter(adap);
+	if (retval) {
+		dev_err(&pdev->dev, "failure adding I2C adapter\n");
+		goto err_release_drvdata;
+	}
+
+	return 0;
+
+err_release_drvdata:
+	put_device(&pdev->dev);
+	kfree(dev);
+err_iounmap:
+	iounmap(reg_base);
+err:
+	return retval;
+}
+
+/**
+ * intel_qrk_i2c_remove
+ * @param pdev: Pointer to GIP PCI device
+ * @param dev: Pointer to I2C private data
+ *
+ * Perform I2C-specific resource release on behalf of the top-level GIP driver.
+ */
+void intel_qrk_i2c_remove(struct pci_dev *pdev,
+	struct dw_i2c_dev *dev)
+{
+
+	if (NULL == dev) {
+		dev_err(&pdev->dev, "%s: failure getting driver data\n",
+			__func__);
+		return;
+	}
+
+	i2c_dw_disable(dev);
+	i2c_del_adapter(&dev->adapter);
+	iounmap(dev->base);
+
+	kfree(dev);
+}
diff --git a/drivers/mfd/intel_qrk_gip_pdata.c b/drivers/mfd/intel_qrk_gip_pdata.c
new file mode 100644
index 000000000000..597bfac0da4d
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_pdata.c
@@ -0,0 +1,18 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+
+struct intel_qrk_gip_pdata *(*intel_qrk_gip_get_pdata)(void) = NULL;
+EXPORT_SYMBOL_GPL(intel_qrk_gip_get_pdata);
diff --git a/drivers/mfd/intel_qrk_gip_test.c b/drivers/mfd/intel_qrk_gip_test.c
new file mode 100644
index 000000000000..05ef3393619a
--- /dev/null
+++ b/drivers/mfd/intel_qrk_gip_test.c
@@ -0,0 +1,1246 @@
+/*
+ * Copyright(c) 2013-2015 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+/*
+ * Intel Quark GIP (GPIO/I2C) Test module
+ *
+ * Quark GIP + North-Cluster GPIO test module.
+ */
+
+#include <asm/tsc.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#define DRIVER_NAME			"intel_qrk_gip_test"
+
+/**************************** Exported to LISA *******************************/
+
+/*
+ * Internally-used ioctl code. At the moment it is not reserved by any mainline
+ * driver.
+ */
+#define GIP_TEST_IOCTL_CODE			0xE0
+
+/*
+ * Integers for ioctl operation.
+ */
+#define IOCTL_QRK_GPIO_11			_IO(GIP_TEST_IOCTL_CODE, 0x00)
+#define IOCTL_QRK_GPIO_11_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x01)
+#define IOCTL_QRK_GPIO_12			_IO(GIP_TEST_IOCTL_CODE, 0x02)
+#define IOCTL_QRK_GPIO_12_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x03)
+#define IOCTL_QRK_GPIO_13			_IO(GIP_TEST_IOCTL_CODE, 0x04)
+#define IOCTL_QRK_GPIO_13_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x05)
+#define IOCTL_QRK_GPIO_14			_IO(GIP_TEST_IOCTL_CODE, 0x06)
+#define IOCTL_QRK_GPIO_14_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x07)
+#define IOCTL_QRK_GPIO_15			_IO(GIP_TEST_IOCTL_CODE, 0x08)
+#define IOCTL_QRK_GPIO_15_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x09)
+#define IOCTL_QRK_GPIO_16			_IO(GIP_TEST_IOCTL_CODE, 0x0A)
+#define IOCTL_QRK_GPIO_16_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0B)
+#define IOCTL_QRK_GPIO_17			_IO(GIP_TEST_IOCTL_CODE, 0x0C)
+#define IOCTL_QRK_GPIO_17_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0D)
+#define IOCTL_QRK_GPIO_19			_IO(GIP_TEST_IOCTL_CODE, 0x0E)
+#define IOCTL_QRK_GPIO_19_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x0F)
+#define IOCTL_QRK_GPIO_20			_IO(GIP_TEST_IOCTL_CODE, 0x10)
+#define IOCTL_QRK_GPIO_20_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x11)
+#define IOCTL_QRK_GPIO_21			_IO(GIP_TEST_IOCTL_CODE, 0x12)
+#define IOCTL_QRK_GPIO_21_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x13)
+#define IOCTL_QRK_GPIO_24			_IO(GIP_TEST_IOCTL_CODE, 0x14)
+#define IOCTL_QRK_GPIO_26			_IO(GIP_TEST_IOCTL_CODE, 0x15)
+#define IOCTL_QRK_GPIO_26_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x16)
+#define IOCTL_QRK_GPIO_28			_IO(GIP_TEST_IOCTL_CODE, 0x1B)
+#define IOCTL_QRK_GPIO_28_CLEANUP		_IO(GIP_TEST_IOCTL_CODE, 0x1C)
+/* Exercise callbacks for S0/S3 power-state transitions and vice-versa */
+#define IOCTL_QRK_GIP_SYSTEM_SUSPEND		_IO(GIP_TEST_IOCTL_CODE, 0x17)
+#define IOCTL_QRK_GIP_SYSTEM_RESUME		_IO(GIP_TEST_IOCTL_CODE, 0x18)
+#define IOCTL_QRK_GPIO_NMI_ENABLE		_IO(GIP_TEST_IOCTL_CODE, 0x19)
+#define IOCTL_QRK_GPIO_NMI_DISABLE		_IO(GIP_TEST_IOCTL_CODE, 0x1A)
+
+#define GPIO_INT_EDGE_POS_LABEL			"gpio-edge-pos"
+#define GPIO_INT_EDGE_NEG_LABEL			"gpio-edge-neg"
+#define GPIO_INT_LEVEL_HIGH_LABEL		"gpio-level-hi"
+#define GPIO_INT_LEVEL_LOW_LABEL		"gpio-level-lo"
+#define GPIO_INT_BASIC_LABEL			"gpio-edge-pos-basic"
+#define GPIO_PM_TEST_IRQ_LABEL			"gpio_pm_test_irq"
+
+/*
+ * Board GPIO numbers.
+ * Mapping between the North/South cluster GPIO and GPIOLIB IDs.
+ */
+#define SUT_GPIO_NC_0				0x00
+#define SUT_GPIO_NC_1				0x01
+#define SUT_GPIO_NC_2				0x02
+#define SUT_GPIO_NC_7				0x07
+#define SUT_GPIO_SC_0				0x08
+#define SUT_GPIO_SC_1				0x09
+#define SUT_GPIO_SC_6				0x0E
+#define SUT_GPIO_SC_7				0x0F
+
+/*
+ * Bitbanged SPI bus numbers.
+ */
+#define GPIO_NC_BITBANG_SPI_BUS			0x0
+#define GPIO_SC_BITBANG_SPI_BUS			0x1
+
+/*****************************************************************************/
+
+/**
+ * struct intel_qrk_gip_dev
+ *
+ * Structure to represent module state/data/etc
+ */
+struct intel_qrk_gip_test_dev {
+	unsigned int opened;
+	struct platform_device *pldev;	/* Platform device */
+	struct cdev cdev;
+	struct mutex open_lock;
+};
+
+static struct intel_qrk_gip_test_dev gip_test_dev;
+static struct class *gip_test_class;
+static DEFINE_MUTEX(gip_test_mutex);
+static int gip_test_major;
+
+/*
+ * Level-triggered interrupt variables
+ */
+/* Level-triggered GPIO workqueue */
+static struct delayed_work work;
+/* Level-triggered interrupt counter */
+static unsigned int level_int_count;
+/* By default, a level-triggered interrupt is a low-level triggered */
+static int level_high_triggered = 0;
+
+/*
+ * Interrupt performance metrics variables and parameters
+ */
+/* How many captures */
+#define INT_PERF_TEST_CAPTURES			10000
+/* Timestamp for latency test interrupt handler */
+static cycles_t perf_t1;
+/* Captures to be returned to user space */
+static cycles_t deltas[INT_PERF_TEST_CAPTURES];
+/* Couldn't find the actual define for this */
+#define UINT64_MAX		0xFFFFFFFFFFFFFFFFULL
+
+/*
+ * Threaded interrupt test variables
+ */
+static int gpio_irq = 0;
+static struct timer_list timer;
+static unsigned delay = (HZ/50);
+static int timer_count = 0;
+
+
+static irqreturn_t gpio_pm_test_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_latency_handler(int irq, void *dev_id)
+{
+	/* t0 */
+	perf_t1 = get_cycles();
+
+	gpio_set_value(SUT_GPIO_SC_0, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_basic_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_pos_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_neg_edge_handler(int irq, void *dev_id)
+{
+	/* Do nothing, just acknowledge the IRQ subsystem */
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t gpio_level_handler(int irq, void *dev_id)
+{
+	/* Untrigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 0 : 1);
+
+	level_int_count ++;
+	if (level_int_count < 1000) {
+		/* Next task due in a jiffy */
+		schedule_delayed_work(&work, 1);
+	} else if (level_int_count == 1000){
+		/* OK */
+	} else {
+		/*
+		 * We may get spurious interrupts. This because the TE requires
+		 * some time to drive the actual value to the GPIO.
+		 */
+		pr_info("Spurious interrupt\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void gpio_level_drive(struct work_struct *work)
+{
+	/* TE to trigger the interrupt */
+	gpio_set_value(SUT_GPIO_SC_7, level_high_triggered ? 1 : 0);
+}
+
+/**
+ * gpio_sc_level_int
+ *
+ * Request level triggered IRQ for SUT_GPIO_SC_6 and register
+ * SUT_GPIO_SC_7 as output GPIO.
+ * If positive equals to 0, the IRQ is high-level triggered.
+ * Otherwise, low-level triggered.
+ * Mask the IRQ if requested.
+ */
+static int gpio_sc_level_int(int positive, int masking)
+{
+	int ret = 0;
+	int irq = -1;
+
+	unsigned long out_init_val =
+		(positive ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);
+
+	level_high_triggered = positive;
+
+	/* Initialise workqueue task */
+	INIT_DELAYED_WORK(&work, gpio_level_drive);
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_hi_level");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, out_init_val, "gpio_output");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_level_handler,
+			positive ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_LOW,
+			positive ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_LEVEL_LOW_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+
+	level_int_count = 0;
+
+	pr_info("Registered output gpio%d and IRQ for gpio%d\n", SUT_GPIO_SC_7,
+		SUT_GPIO_SC_6);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		pr_info("Masked gpio%d IRQ\n", SUT_GPIO_SC_6);
+	}
+
+	/*
+	 * Submit task to workqueue to drive the external Test Equipment.
+	 * Note the task is delayed long enough to have Aarvark already set up.
+	 * This because Aardvark has to ignore the initial glitches during the
+	 * previous GPIO setup phase.
+	 */
+	schedule_delayed_work(&work, 20 * HZ);
+
+	return 0;
+
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_level_int_teardown
+ *
+ * Release resources reserved by gpio_sc_level_int().
+ */
+static int gpio_sc_level_int_teardown(void)
+{
+	int irq = -1;
+
+	if (0 != cancel_delayed_work_sync(&work))
+		pr_warn("delayed work was still pending\n");
+
+	irq = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	/* Make sure no handler is still running by this time */
+	mdelay(20);
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/*
+ * gpio_sc_interrupt_perf
+ *
+ * Performs a basic GPIO interrupt latency test by timestamping delta between
+ * interrupt driven and handled over a GPIO loopback.
+ *
+ * Returns to userspace the array of deltas obtained during each capture.
+ * A total amount of INT_PERF_TEST_CAPTURES captures is performed.
+ *
+ */
+static int gpio_sc_interrupt_perf(unsigned long user_memloc)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_1;
+	int gpio_output = SUT_GPIO_SC_0;
+	unsigned int i = 0;
+	cycles_t perf_t0 = 0;
+	cycles_t delta = 0;
+
+	/* Casting pointer to user-space location to write */
+	cycles_t __user *user_ptr = (cycles_t __user *)user_memloc;
+
+	/* Can we copy the captures array into user-space location? */
+	if (!access_ok(VERIFY_WRITE, user_ptr, sizeof(deltas))) {
+		pr_err("can't copy 0x%x bytes to user-space address 0x%p\n",
+			sizeof(deltas),user_ptr);
+		return -EFAULT;
+	}
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(gpio_output)) {
+		pr_err("gpio%d is invalid\n", gpio_output);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_intperf_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_output, GPIOF_OUT_INIT_LOW, "gpio_intperf_out");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_output, ret);
+		goto fail_release_input_gpio;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_latency_handler,
+			IRQF_TRIGGER_RISING, "gpio_latency_handler", NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_output_gpio;
+	}
+
+	/* Perform test */
+	for (i = 0; i < INT_PERF_TEST_CAPTURES; i ++) {
+		/* t0 */
+		perf_t0 = get_cycles();
+
+		/* Trigger interrupt */
+		gpio_set_value(gpio_output, 1);
+		mdelay(2);
+
+		/* Check for wrap-around and store delta */
+		if(perf_t0 < perf_t1) {
+			delta = perf_t1 - perf_t0;
+		} else {
+			delta = perf_t1 + (UINT64_MAX - perf_t0);
+		}
+		deltas[i] = delta;
+	}
+
+	/* Expose results to userspace */
+	ret = copy_to_user(user_ptr, &deltas, sizeof(deltas));
+
+	/* Release resources */
+
+	free_irq(irq, NULL);
+
+fail_release_output_gpio:
+	gpio_free(gpio_output);
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	if (0 != ret) {
+		pr_err("%s() failed\n", __func__);
+	}
+
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Request rising edge-triggered IRQ for SUT_GPIO_SC_0
+ */
+static int gpio_sc_pm_test_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio_input = SUT_GPIO_SC_0;
+
+	/* Setup the GPIO */
+	if (!gpio_is_valid(gpio_input)) {
+		pr_err("gpio%d is invalid\n", gpio_input);
+		ret = -1;
+		goto fail;
+	}
+	ret = gpio_request_one(gpio_input, GPIOF_IN, "gpio_pm_test_in");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio_input, ret);
+		goto fail;
+	}
+
+	/* Setup IRQ handler for input GPIO */
+	irq = gpio_to_irq(gpio_input);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+	if (0 != (ret = request_irq(irq, gpio_pm_test_handler,
+			IRQF_TRIGGER_RISING, GPIO_PM_TEST_IRQ_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio_input);
+		goto fail_release_input_gpio;
+	}
+
+	return 0;
+
+fail_release_input_gpio:
+	gpio_free(gpio_input);
+fail:
+	return ret;
+}
+
+/**
+ * gpio_sc_pm_test_int
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_pm_test_int_teardown(void)
+{
+	int irq = -1;
+
+	irq = gpio_to_irq(SUT_GPIO_SC_0);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_0);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_0);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_edge_int
+ *
+ * Request IRQ for SUT_GPIO_SC_6 and SUT_GPIO_SC_7, respectively positive-edge
+ * and negative edge-triggered.
+ * Mask the IRQs if requested.
+ */
+static int gpio_sc_edge_int(int masking)
+{
+	int ret = 0;
+	int irq_pos = -1, irq_neg = -1;
+
+	if (!gpio_is_valid(SUT_GPIO_SC_6)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_6);
+		ret = -1;
+		goto fail;
+	}
+	if (!gpio_is_valid(SUT_GPIO_SC_7)) {
+		pr_err("gpio%d is invalid\n", SUT_GPIO_SC_7);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(SUT_GPIO_SC_6, GPIOF_IN, "gpio_pos_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_6, ret);
+		goto fail;
+	}
+	ret = gpio_request_one(SUT_GPIO_SC_7, GPIOF_IN, "gpio_neg_edge");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_7, ret);
+		goto fail_release_first_gpio;
+	}
+
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+		goto fail_release_second_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq_pos, gpio_pos_edge_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_EDGE_POS_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_6);
+		goto fail_release_second_gpio;
+	}
+	if (0 != (ret = request_irq(irq_neg, gpio_neg_edge_handler,
+			IRQF_TRIGGER_FALLING, GPIO_INT_EDGE_NEG_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", SUT_GPIO_SC_7);
+		goto fail_release_first_gpio_irq;
+	}
+
+	pr_info("Registered gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+		SUT_GPIO_SC_7);
+
+	if (masking) {
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_6));
+		disable_irq(gpio_to_irq(SUT_GPIO_SC_7));
+		pr_info("Masked gpio%d and gpio%d IRQs\n", SUT_GPIO_SC_6,
+			SUT_GPIO_SC_7);
+	}
+
+	return 0;
+
+fail_release_first_gpio_irq:
+	free_irq(irq_pos, NULL);
+fail_release_second_gpio:
+	gpio_free(SUT_GPIO_SC_7);
+fail_release_first_gpio:
+	gpio_free(SUT_GPIO_SC_6);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_edge_int_teardown
+ *
+ * Release resources reserved by gpio_sc_edge_int()
+ */
+static int gpio_sc_edge_int_teardown(void)
+{
+	int irq_pos = -1, irq_neg = -1;
+
+	irq_neg = gpio_to_irq(SUT_GPIO_SC_7);
+	if (irq_neg < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_7);
+	} else {
+		free_irq(irq_neg, NULL);
+	}
+	irq_pos = gpio_to_irq(SUT_GPIO_SC_6);
+	if (irq_pos < 0) {
+		pr_err("can't map gpio%d to IRQ\n", SUT_GPIO_SC_6);
+	} else {
+		free_irq(irq_pos, NULL);
+	}
+
+	gpio_free(SUT_GPIO_SC_7);
+	gpio_free(SUT_GPIO_SC_6);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_basic_int
+ *
+ * Register rising-edge interrupt handler on SUT_GPIO_SC_1
+ */
+static int gpio_sc_basic_int(void)
+{
+	int ret = 0;
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN, "gpio_pos_edge_basic");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	if (0 != (ret = request_irq(irq, gpio_basic_handler,
+			IRQF_TRIGGER_RISING, GPIO_INT_BASIC_LABEL, NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	pr_info("Registered gpio%d IRQ\n", gpio);
+
+	return 0;
+
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_basic_int_teardown
+ *
+ * Release resources reserved by gpio_sc_basic_int()
+ */
+static int gpio_sc_basic_int_teardown(void)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_1;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/**
+ * gpio_spidev_register
+ *
+ * Register a bitbanged SPI platform device and export a `spidev' to userspace.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_register(int north_cluster)
+{
+	/* Not needed anymore */
+	return 0;
+}
+
+/**
+ * gpio_spidev_unregister
+ *
+ * Release a bitbanged SPI platform device and its `spidev' interface.
+ * For North Cluster and South Cluster.
+ */
+static int gpio_spidev_unregister(int north_cluster)
+{
+	/* Not needed anymore */
+	return 0;
+}
+
+/**
+ * gip_system_power_transition
+ *
+ * @param state: 0 if transition to S3, !0 if transition to S0
+ * @return 0 success < 0 failure
+ *
+ * Exercise system-wide suspend/resume power management transitions.
+ *
+ */
+static int gip_system_power_transition(int state)
+{
+	struct pci_dev *gip = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, NULL);
+	if (NULL == gip) {
+		pr_err("can't find GIP PCI device\n");
+		return -ENOENT;
+	}
+
+	if (0 == state) {
+		gip->driver->driver.pm->suspend(&gip->dev);
+	} else {
+		gip->driver->driver.pm->resume(&gip->dev);
+	}
+
+	/* Decrement reference count of PCI device */
+	if (NULL != pci_get_device(PCI_VENDOR_ID_INTEL, 0x0934, gip)) {
+		pr_warn("found duplicate of GIP PCI device?!\n");
+	}
+
+	return 0;
+}
+
+/**
+ * gpio_nmi_enable
+ *
+ * @param enable: 0 to disable, !0 to enable
+ * @return 0 success < 0 failure
+ *
+ * Hack the legacy GPIO hardware to enable rising-edge triggered NMI on Core
+ * Well gpio0.
+ *
+ */
+static int gpio_nmi_enable(int enable)
+{
+	unsigned int base_u32 = 0x0;
+	unsigned short base = 0x0;
+	struct pci_dev *ilb = pci_get_device(PCI_VENDOR_ID_INTEL,
+					     PCI_DEVICE_ID_INTEL_QUARK_ILB,
+					     NULL);
+	/* Assume interrupts are disabled by default by BIOS */
+	unsigned char gpio = enable ? 0x01 : 0x00;
+
+	if (NULL == ilb) {
+		pr_err("can't find iLB device\n");
+		return -ENOENT;
+	}
+
+	/* The GPIO base address is @ offset 0x44.  Sussed out from driver */
+	pci_read_config_dword(ilb, 0x44, &base_u32);
+	if (0x0 == base_u32) {
+		pr_err("can't read iLB GPIO baseaddr\n");
+		return -ENOENT;
+	}
+	base = (unsigned short)base_u32;
+
+	/*
+	 * Prepare for rising edge NMI triggering.  This assumes the pin
+	 * is already set as input.
+	 */
+#define CGTPE		0x0C	/* Core Well trigger positive edge */
+#define CGTS		0x1C	/* Core Well trigges status - W1C */
+#define CGNMIEN		0x40	/* Core Well NMI enable */
+	outb(0x01, base + CGTS);
+	outb(gpio, base + CGTPE);
+	outb(gpio, base + CGNMIEN);
+#undef CGTPE
+#undef CGTS
+#undef CGNMIEN
+
+	return 0;
+}
+
+/**
+ * gpio_sc_debounce
+ *
+ * Enable GPIO debounce functionality for SC_GPIO_1 (edge and level triggered)
+ *
+ */
+static int gpio_sc_debounce(int level)
+{
+	int ret = 0;
+	int irq = -1;
+	int gpio = SUT_GPIO_SC_0;
+
+	if (!gpio_is_valid(gpio)) {
+		pr_err("gpio%d is invalid\n", gpio);
+		ret = -1;
+		goto fail;
+	}
+
+	ret = gpio_request_one(gpio, GPIOF_IN,
+		level ? "gpio_level_mask" : "gpio_edge_mask");
+	if (ret) {
+		pr_err("can't request gpio%d (error %d)\n", gpio, ret);
+		goto fail;
+	}
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/*
+	 * Register IRQ. gpio_pos_edge_handler will do for both level and edge
+	 * interrupts, as it's nooping.
+	 */
+	if (0 != (ret = request_irq(irq, gpio_pos_edge_handler,
+			level ? IRQF_TRIGGER_HIGH : IRQF_TRIGGER_RISING,
+			level ? GPIO_INT_LEVEL_HIGH_LABEL : GPIO_INT_EDGE_POS_LABEL,
+			NULL))) {
+		pr_err("can't request IRQ for gpio%d\n", gpio);
+		goto fail_release_gpio;
+	}
+
+	/* Set debounce */
+	if (0 != (ret = gpio_set_debounce(gpio, 1))) {
+		pr_err("can't set debounce for gpio%d\n", gpio);
+		goto fail_free_irq;
+	}
+
+	return 0;
+
+fail_free_irq:
+	free_irq(irq, NULL);
+fail_release_gpio:
+	gpio_free(gpio);
+fail:
+	pr_err("%s() failed\n", __func__);
+
+	return ret;
+}
+
+/**
+ * gpio_sc_debounce_teardown
+ *
+ * Undo gpio_sc_debounce
+ *
+ */
+static int gpio_sc_debounce_teardown(int level)
+{
+	int irq = -1;
+	unsigned int gpio = SUT_GPIO_SC_0;
+
+	irq = gpio_to_irq(gpio);
+	if (irq < 0) {
+		pr_err("can't map gpio%d to IRQ\n", gpio);
+	} else {
+		free_irq(irq, NULL);
+	}
+
+	gpio_free(gpio);
+
+	return 0;
+}
+
+/**
+ * gpio_sc_threaded_interrupt_handler
+ *
+ * Threaded interrupt handler
+ */
+static irqreturn_t gpio_sc_threaded_interrupt_handler(int irq, void* dev_id)
+{
+    gpio_set_value(SUT_GPIO_SC_0, 1);
+
+    return IRQ_HANDLED;
+}
+
+/**
+ * gpio_sc_threaded_timer_handler
+ *
+ * Threaded timer handler
+ */
+static void gpio_sc_threaded_timer_handler(unsigned long ptr)
+{
+	if (timer_count < 1000) {
+		mod_timer(&timer, jiffies + delay);
+		gpio_set_value(SUT_GPIO_SC_0, 0);
+		timer_count++;
+	}
+}
+
+/**
+ * gpio_sc_threaded
+ *
+ * Threaded interrupt test
+ */
+static int gpio_sc_threaded(void)
+{
+    int err = 0;
+
+    err = gpio_request_one(SUT_GPIO_SC_0, GPIOF_OUT_INIT_HIGH, "gpio_out");
+    if (err < 0) {
+        pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_0, err);
+        goto err_return;
+    }
+
+    err = gpio_request_one(SUT_GPIO_SC_1, GPIOF_IN, "gpio_high_level");
+    if (err < 0) {
+        pr_err("can't request gpio%d (error %d)\n", SUT_GPIO_SC_1, err);
+        goto err_free_gpio_return;
+    }
+
+    gpio_irq = gpio_to_irq(SUT_GPIO_SC_1);
+    if (gpio_irq < 0) {
+        pr_err("failed to get IRQ for pin %d.\n", SUT_GPIO_SC_1);
+        goto err_free_irq_return;
+    }
+
+    err = request_threaded_irq(
+        gpio_irq,
+        NULL,
+        gpio_sc_threaded_interrupt_handler,
+        IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+        "threaded_irq_test",
+        NULL
+        );
+    if (err < 0) {
+        pr_err("failed to enable IRQ %d for pin %d error code: %d.\n",
+                gpio_irq, SUT_GPIO_SC_1, err);
+        goto err_free_irq_return;
+    }
+
+    pr_info("beginning GPIO threaded IRQ test.\n");
+
+    init_timer(&timer);
+    timer.expires = jiffies + delay;
+    timer.function = gpio_sc_threaded_timer_handler;
+    add_timer(&timer);
+
+    return 0;
+
+err_free_irq_return:
+    gpio_free(SUT_GPIO_SC_1);
+err_free_gpio_return:
+    gpio_free(SUT_GPIO_SC_0);
+err_return:
+    return err;
+}
+
+/**
+ * gpio_sc_threaded_teardown
+ *
+ * Threaded interrupt test teardown
+ */
+static int gpio_sc_threaded_teardown(void)
+{
+    free_irq(gpio_irq, NULL);
+
+    if (del_timer_sync(&timer) == 1)
+		pr_err("Removed active timer.\n");
+
+    gpio_free(SUT_GPIO_SC_1);
+    gpio_free(SUT_GPIO_SC_0);
+
+    pr_info("unloaded IRQ toggle test.\n");
+
+    return 0;
+}
+
+/*
+ * File ops
+ */
+static long gip_test_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+
+	switch (cmd) {
+		case IOCTL_QRK_GPIO_11:
+			/* Edge-triggered interrupts */
+			ret = gpio_sc_edge_int(0);
+			break;
+		case IOCTL_QRK_GPIO_11_CLEANUP:
+			/* Edge-triggered interrupts cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_12:
+			/* Edge-triggered interrupts (masking) */
+			ret = gpio_sc_edge_int(1);
+			break;
+		case IOCTL_QRK_GPIO_12_CLEANUP:
+			/* Edge-triggered interrupts (masking) cleanup */
+			ret = gpio_sc_edge_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_13:
+			/* GPIO debounce (edge) */
+			ret = gpio_sc_debounce(0);
+			break;
+		case IOCTL_QRK_GPIO_13_CLEANUP:
+			/* GPIO debounce cleanup (edge) */
+			ret = gpio_sc_debounce_teardown(0);
+			break;
+		case IOCTL_QRK_GPIO_14:
+			/* High-level triggered interrupts */
+			ret = gpio_sc_level_int(1, 0);
+			break;
+		case IOCTL_QRK_GPIO_14_CLEANUP:
+			/* High-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_15:
+			/* Low-level triggered interrupts */
+			ret = gpio_sc_level_int(0, 0);
+			break;
+		case IOCTL_QRK_GPIO_15_CLEANUP:
+			/*Low-level triggered interrupts cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_16:
+			/* Level triggered interrupts (masking) */
+			ret = gpio_sc_level_int(1, 1);
+			break;
+		case IOCTL_QRK_GPIO_16_CLEANUP:
+			/* Level triggered interrupts (masking) cleanup */
+			ret = gpio_sc_level_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_17:
+			/* GPIO debounce (level) */
+			ret = gpio_sc_debounce(1);
+			break;
+		case IOCTL_QRK_GPIO_17_CLEANUP:
+			/* GPIO debounce cleanup (level) */
+			ret = gpio_sc_debounce_teardown(1);
+			break;
+		case IOCTL_QRK_GPIO_19:
+			/* Register IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int();
+			break;
+		case IOCTL_QRK_GPIO_19_CLEANUP:
+			/* Free IRQ for SC_GPIO0 (PM transitions test) */
+			ret = gpio_sc_pm_test_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_20:
+			/* NC bitbanged SPI */
+			ret = gpio_spidev_register(1);
+			break;
+		case IOCTL_QRK_GPIO_20_CLEANUP:
+			/* NC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(1);
+			break;
+		case IOCTL_QRK_GPIO_21:
+			/* SC bitbanged SPI */
+			ret = gpio_spidev_register(0);
+			break;
+		case IOCTL_QRK_GPIO_21_CLEANUP:
+			/* SC bitbanged SPI cleanup */
+			ret = gpio_spidev_unregister(0);
+			break;
+		case IOCTL_QRK_GPIO_24:
+			/*
+			 * SC GPIO interrupt performance test.
+			 * Note it's shared between QRK_GPIO_24 and QRK_GPIO_25
+			 * plus it doesn't need any cleanup call.
+			 */
+			ret = gpio_sc_interrupt_perf(arg);
+			break;
+		case IOCTL_QRK_GPIO_26:
+			/* Interrupt for basic loopback test */
+			ret = gpio_sc_basic_int();
+			break;
+		case IOCTL_QRK_GPIO_26_CLEANUP:
+			/* Interrupt for basic loopback test cleanup */
+			ret = gpio_sc_basic_int_teardown();
+			break;
+		case IOCTL_QRK_GPIO_28:
+			/* Threaded interrupt */
+			ret = gpio_sc_threaded();
+			break;
+		case IOCTL_QRK_GPIO_28_CLEANUP:
+			/* Threaded interrupt cleanup*/
+			ret = gpio_sc_threaded_teardown();
+			break;
+		case IOCTL_QRK_GIP_SYSTEM_SUSPEND:
+			ret = gip_system_power_transition(0);
+			break;
+		case IOCTL_QRK_GIP_SYSTEM_RESUME:
+			ret = gip_system_power_transition(1);
+			break;
+		case IOCTL_QRK_GPIO_NMI_ENABLE:
+			ret = gpio_nmi_enable(1);
+			break;
+		case IOCTL_QRK_GPIO_NMI_DISABLE:
+			ret = gpio_nmi_enable(0);
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+static int gip_test_open(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_mutex);
+	nonseekable_open(inode, file);
+
+	if (mutex_lock_interruptible(&gip_test_dev.open_lock)) {
+		mutex_unlock(&gip_test_mutex);
+		return -ERESTARTSYS;
+	}
+
+	if (gip_test_dev.opened) {
+		mutex_unlock(&gip_test_dev.open_lock);
+		mutex_unlock(&gip_test_mutex);
+		return -EINVAL;
+	}
+
+	gip_test_dev.opened++;
+	mutex_unlock(&gip_test_dev.open_lock);
+	mutex_unlock(&gip_test_mutex);
+	return 0;
+}
+
+static int gip_test_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&gip_test_dev.open_lock);
+	gip_test_dev.opened = 0;
+	mutex_unlock(&gip_test_dev.open_lock);
+
+	return 0;
+}
+
+static const struct file_operations gip_test_file_ops = {
+	.open = gip_test_open,
+	.release = gip_test_release,
+	.unlocked_ioctl = gip_test_ioctl,
+	.llseek = no_llseek,
+};
+
+/**
+ * intel_qrk_gip_test_probe
+ *
+ * @param pdev: Platform device
+ * @return 0 success < 0 failure
+ *
+ * Callback from platform sub-system to probe
+ */
+static int intel_qrk_gip_test_probe(struct platform_device * pdev)
+{
+	int retval = 0;
+	unsigned int minor = 0;
+
+	mutex_init(&gip_test_dev.open_lock);
+	cdev_init(&gip_test_dev.cdev, &gip_test_file_ops);
+	gip_test_dev.cdev.owner = THIS_MODULE;
+
+	retval = cdev_add(&gip_test_dev.cdev, MKDEV(gip_test_major, minor), 1);
+	if (retval) {
+		printk(KERN_ERR "chardev registration failed\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(device_create(gip_test_class, NULL,
+				 MKDEV(gip_test_major, minor), NULL,
+				 "giptest%u", minor))){
+		dev_err(&pdev->dev, "can't create device\n");
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int intel_qrk_gip_test_remove(struct platform_device * pdev)
+{
+	unsigned int minor = MINOR(gip_test_dev.cdev.dev);
+
+	device_destroy(gip_test_class, MKDEV(gip_test_major, minor));
+	cdev_del(&gip_test_dev.cdev);
+
+	class_destroy(gip_test_class);
+
+	return 0;
+}
+
+/*
+ * Platform structures useful for interface to PM subsystem
+ */
+static struct platform_driver intel_qrk_gip_test_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.remove = intel_qrk_gip_test_remove,
+};
+
+/**
+ * intel_qrk_gip_test_init
+ *
+ * Load module.
+ */
+static int __init intel_qrk_gip_test_init(void)
+{
+	int retval = 0;
+	dev_t dev;
+
+	gip_test_class = class_create(THIS_MODULE,"qrk_gip_test");
+	if (IS_ERR(gip_test_class)) {
+		retval = PTR_ERR(gip_test_class);
+		printk(KERN_ERR "gip_test: can't register gip_test class\n");
+		goto err;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, 1, "gip_test");
+	if (retval) {
+		printk(KERN_ERR "earam_test: can't register character device\n");
+		goto err_class;
+	}
+	gip_test_major = MAJOR(dev);
+
+	memset(&gip_test_dev, 0x00, sizeof(gip_test_dev));
+	gip_test_dev.pldev = platform_create_bundle(
+		&intel_qrk_gip_test_driver, intel_qrk_gip_test_probe, NULL, 0, NULL, 0);
+
+	if(IS_ERR(gip_test_dev.pldev)){
+		printk(KERN_ERR "platform_create_bundle fail!\n");
+		retval = PTR_ERR(gip_test_dev.pldev);
+		goto err_class;
+	}
+
+	return 0;
+
+err_class:
+	class_destroy(gip_test_class);
+err:
+	return retval;
+}
+
+static void __exit intel_qrk_gip_test_exit(void)
+{
+	platform_device_unregister(gip_test_dev.pldev);
+	platform_driver_unregister(&intel_qrk_gip_test_driver);
+}
+
+module_init(intel_qrk_gip_test_init);
+module_exit(intel_qrk_gip_test_exit);
+
+MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
+MODULE_DESCRIPTION("Quark GIP test module");
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/include/linux/mfd/intel_qrk_gip_pdata.h b/include/linux/mfd/intel_qrk_gip_pdata.h
new file mode 100644
index 000000000000..62f53084360f
--- /dev/null
+++ b/include/linux/mfd/intel_qrk_gip_pdata.h
@@ -0,0 +1,16 @@
+/*
+ * {% copyright %}
+ */
+
+#ifndef LINUX_INTEL_QRK_GIP_DATA_H
+#define LINUX_INTEL_QRK_GIP_DATA_H
+
+struct pci_dev;
+
+struct intel_qrk_gip_pdata {
+	int		i2c_std_mode;
+};
+
+extern struct intel_qrk_gip_pdata *(*intel_qrk_gip_get_pdata)(void);
+
+#endif
-- 
2.1.0

