From b51106aec0affe5c3133b9f979bf8d48063f997a Mon Sep 17 00:00:00 2001
From: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date: Tue, 8 Mar 2016 17:46:17 +0200
Subject: [PATCH 2541/4706] drm/i915: Split intel_get_shared_dpll() into
 smaller functions

commit a4780b7744c2833ba762d64576f661a9dae045f1 upstream

Make the code neater by splitting the code for platforms with fixed PLL
to their own functions and splitting the logic for finding a shareable
or unused pll from the logic for setting it up.

Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1457451987-17466-4-git-send-email-ander.conselvan.de.oliveira@intel.com
---
 drivers/gpu/drm/i915/intel_dpll_mgr.c |  109 ++++++++++++++++++++++-----------
 1 files changed, 74 insertions(+), 35 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dpll_mgr.c b/drivers/gpu/drm/i915/intel_dpll_mgr.c
index 6be0cd0..11effe3 100644
--- a/drivers/gpu/drm/i915/intel_dpll_mgr.c
+++ b/drivers/gpu/drm/i915/intel_dpll_mgr.c
@@ -145,52 +145,65 @@ void intel_disable_shared_dpll(struct intel_crtc *crtc)
 	intel_display_power_put(dev_priv, POWER_DOMAIN_PLLS);
 }
 
-struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc,
-						struct intel_crtc_state *crtc_state)
+static enum intel_dpll_id
+ibx_get_fixed_dpll(struct intel_crtc *crtc,
+		   struct intel_crtc_state *crtc_state)
 {
-	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
+	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
 	struct intel_shared_dpll *pll;
-	struct intel_shared_dpll_config *shared_dpll;
 	enum intel_dpll_id i;
-	int max = dev_priv->num_shared_dpll;
 
-	shared_dpll = intel_atomic_get_shared_dpll_state(crtc_state->base.state);
+	/* Ironlake PCH has a fixed PLL->PCH pipe mapping. */
+	i = (enum intel_dpll_id) crtc->pipe;
+	pll = &dev_priv->shared_dplls[i];
 
-	if (HAS_PCH_IBX(dev_priv->dev)) {
-		/* Ironlake PCH has a fixed PLL->PCH pipe mapping. */
-		i = (enum intel_dpll_id) crtc->pipe;
-		pll = &dev_priv->shared_dplls[i];
+	DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
+		      crtc->base.base.id, pll->name);
 
-		DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
-			      crtc->base.base.id, pll->name);
+	return i;
+}
 
-		WARN_ON(shared_dpll[i].crtc_mask);
+static enum intel_dpll_id
+bxt_get_fixed_dpll(struct intel_crtc *crtc,
+		   struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+	struct intel_encoder *encoder;
+	struct intel_digital_port *intel_dig_port;
+	struct intel_shared_dpll *pll;
+	enum intel_dpll_id i;
 
-		goto found;
-	}
+	/* PLL is attached to port in bxt */
+	encoder = intel_ddi_get_crtc_new_encoder(crtc_state);
+	if (WARN_ON(!encoder))
+		return DPLL_ID_PRIVATE;
 
-	if (IS_BROXTON(dev_priv->dev)) {
-		/* PLL is attached to port in bxt */
-		struct intel_encoder *encoder;
-		struct intel_digital_port *intel_dig_port;
+	intel_dig_port = enc_to_dig_port(&encoder->base);
+	/* 1:1 mapping between ports and PLLs */
+	i = (enum intel_dpll_id)intel_dig_port->port;
+	pll = &dev_priv->shared_dplls[i];
+	DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
+		crtc->base.base.id, pll->name);
 
-		encoder = intel_ddi_get_crtc_new_encoder(crtc_state);
-		if (WARN_ON(!encoder))
-			return NULL;
+	return i;
+}
 
-		intel_dig_port = enc_to_dig_port(&encoder->base);
-		/* 1:1 mapping between ports and PLLs */
-		i = (enum intel_dpll_id)intel_dig_port->port;
-		pll = &dev_priv->shared_dplls[i];
-		DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
-			crtc->base.base.id, pll->name);
-		WARN_ON(shared_dpll[i].crtc_mask);
+static enum intel_dpll_id
+intel_find_shared_dpll(struct intel_crtc *crtc,
+		       struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
+	struct intel_shared_dpll *pll;
+	struct intel_shared_dpll_config *shared_dpll;
+	enum intel_dpll_id i;
+	int max = dev_priv->num_shared_dpll;
 
-		goto found;
-	} else if (INTEL_INFO(dev_priv)->gen < 9 && HAS_DDI(dev_priv))
+	if (INTEL_INFO(dev_priv)->gen < 9 && HAS_DDI(dev_priv))
 		/* Do not consider SPLL */
 		max = 2;
 
+	shared_dpll = intel_atomic_get_shared_dpll_state(crtc_state->base.state);
+
 	for (i = 0; i < max; i++) {
 		pll = &dev_priv->shared_dplls[i];
 
@@ -205,7 +218,7 @@ struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc,
 				      crtc->base.base.id, pll->name,
 				      shared_dpll[i].crtc_mask,
 				      pll->active);
-			goto found;
+			return i;
 		}
 	}
 
@@ -215,13 +228,39 @@ struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc,
 		if (shared_dpll[i].crtc_mask == 0) {
 			DRM_DEBUG_KMS("CRTC:%d allocated %s\n",
 				      crtc->base.base.id, pll->name);
-			goto found;
+			return i;
 		}
 	}
 
-	return NULL;
+	return DPLL_ID_PRIVATE;
+}
+
+struct intel_shared_dpll *
+intel_get_shared_dpll(struct intel_crtc *crtc,
+		      struct intel_crtc_state *crtc_state)
+{
+	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
+	struct intel_shared_dpll *pll;
+	struct intel_shared_dpll_config *shared_dpll;
+	enum intel_dpll_id i;
+
+	shared_dpll = intel_atomic_get_shared_dpll_state(crtc_state->base.state);
+
+	if (HAS_PCH_IBX(dev_priv->dev)) {
+		i = ibx_get_fixed_dpll(crtc, crtc_state);
+		WARN_ON(shared_dpll[i].crtc_mask);
+	} else if (IS_BROXTON(dev_priv->dev)) {
+		i = bxt_get_fixed_dpll(crtc, crtc_state);
+		WARN_ON(shared_dpll[i].crtc_mask);
+	} else {
+		i = intel_find_shared_dpll(crtc, crtc_state);
+	}
+
+	if (i < 0)
+		return NULL;
+
+	pll = &dev_priv->shared_dplls[i];
 
-found:
 	if (shared_dpll[i].crtc_mask == 0)
 		shared_dpll[i].hw_state =
 			crtc_state->dpll_hw_state;
-- 
1.7.5.4

