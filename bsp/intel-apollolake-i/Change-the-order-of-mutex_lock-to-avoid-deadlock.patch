From 4cc3b70de561aa9dc24bcd3043e0f44462391413 Mon Sep 17 00:00:00 2001
From: "Xiong, James" <james.xiong@intel.com>
Date: Thu, 26 May 2016 16:44:16 -0700
Subject: [PATCH 1446/2508] Change the order of mutex_lock to avoid deadlock

commit 4d94d2cd312da84bfef5fdbe48e73301da0cf91b from
https://github.com/01org/linux-apollolake-i

Locking two mutexes in reverse order in multiple threads could run into
race condition and end up with dead lock.

Change the locking order to lock mode_config.mutex first then acquire other
drm_modeset mutexes.

Function intel_splash_screen_init doesn't need the protection of these
mutexes, call this function before acquiring mutexes.

Handle drm_modeset_lock_all_ctx failure [Matt]

Signed-off-by: Xiong, James <james.xiong@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/intel_initial_modeset.c |   31 +++++++++++++------------
 1 files changed, 16 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
index 76f6a71..6e1fc46 100644
--- a/drivers/gpu/drm/i915/intel_initial_modeset.c
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -548,26 +548,33 @@ static void modeset_config_fn(struct work_struct *work)
 	bool found = false;
 	unsigned long long start = sched_clock();
 
+	intel_splash_screen_init(dev);
+
 	state = drm_atomic_state_alloc(dev);
 	if (!state)
 		return;
 
+	mutex_lock(&dev->mode_config.mutex);
+
 	drm_modeset_acquire_init(&ctx, 0);
 	state->acquire_ctx = &ctx;
-	drm_modeset_lock_all_ctx(dev, &ctx);
-
-	intel_splash_screen_init(dev);
-
 retry:
+	ret = drm_modeset_lock_all_ctx(dev, &ctx);
+	if (ret == -EDEADLK) {
+		drm_modeset_backoff(&ctx);
+		goto retry;
+	} else if(ret) {
+		goto out;
+	}
+
 	ret = disable_planes(dev, state);
 	if (ret)
-		goto early_fail;
+		goto fail;
 
 	/*
 	 * For each connector that we want to set up, update the atomic
 	 * state to include the connector and crtc mode.
 	 */
-	mutex_lock(&dev->mode_config.mutex);
 	drm_for_each_connector(connector, dev) {
 		struct drm_encoder *encoder;
 
@@ -608,22 +615,13 @@ retry:
 	dev_priv->profile.initial_mode_get_config = sched_clock() - start;
 
 	if (found) {
-		ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
-				       state->acquire_ctx);
-		if (ret)
-			goto fail;
-
 		ret = drm_atomic_commit(state);
 		if (ret)
 			goto fail;
 	}
-	mutex_unlock(&dev->mode_config.mutex);
 	goto out;
 
 fail:
-	mutex_unlock(&dev->mode_config.mutex);
-
-early_fail:
 	if (ret == -EDEADLK) {
 		DRM_DEBUG_KMS("modeset commit deadlock, retry...\n");
 		drm_modeset_backoff(&ctx);
@@ -641,6 +639,9 @@ out:
 	}
 	drm_modeset_drop_locks(&ctx);
 	drm_modeset_acquire_fini(&ctx);
+
+	mutex_unlock(&dev->mode_config.mutex);
+
 	dev_priv->profile.initial_mode_run = sched_clock() - start;
 }
 
-- 
1.7.5.4

