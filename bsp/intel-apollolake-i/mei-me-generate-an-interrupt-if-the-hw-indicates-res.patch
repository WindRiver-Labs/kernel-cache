From 37cb9d9fa0c2646e23455ba2d1bce24b73598490 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Wed, 30 Nov 2016 10:08:03 +0200
Subject: [PATCH 4628/4706] mei: me: generate an interrupt if the hw indicates
 reset.

commit ec9a65b3c1659714287e89b7acd5f6eb8729015f from
git://git.yoctoproject.org/linux-yocto-4.1

Unblock the reset flow if there was an interrupt miss in the FW by
generating an interrupt on the host side towards the firmware (HIG).
In case the interrupt is superfluous, FW will ignore it.
The effected platforms are skylake and newer.

Change-Id: I7352613a74a16aa1bc757aa37fa75e83e0dfd4d3
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/hw-me.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c
index 8fc1510..6e0c551 100644
--- a/drivers/misc/mei/hw-me.c
+++ b/drivers/misc/mei/hw-me.c
@@ -366,6 +366,19 @@ static bool mei_me_hw_is_ready(struct mei_device *dev)
 }
 
 /**
+ * mei_me_hw_is_resetting - check whether the me(hw) is in reset
+ *
+ * @dev: mei device
+ * Return: bool
+ */
+static bool mei_me_hw_is_resetting(struct mei_device *dev)
+{
+	u32 mecsr = mei_me_mecsr_read(dev);
+
+	return (mecsr & ME_RST_HRA) == ME_RST_HRA;
+}
+
+/**
  * mei_me_hw_ready_wait - wait until the me(hw) has turned ready
  *  or timeout is reached
  *
@@ -1195,6 +1208,9 @@ irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)
 		goto end;
 	}
 
+	if (mei_me_hw_is_resetting(dev))
+		mei_hcsr_set_hig(dev);
+
 	mei_me_pg_intr(dev, hcsr & H_CSR_IS_MASK);
 
 	/*  check if we need to start the dev */
-- 
1.7.5.4

