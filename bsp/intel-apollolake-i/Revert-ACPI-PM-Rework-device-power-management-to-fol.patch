From 52583e413ef510c25e5750f3adab20835cd026a9 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 19 Apr 2017 16:57:17 +0800
Subject: [PATCH 2/7] Revert "ACPI / PM: Rework device power management to
 follow ACPI 6"

This commit 7705631fced2("ACPI / PM: Rework device power management to
follow ACPI 6") doesn't fix any real issue, but just try to be
compatible with the ACPI 6. A side effect of this change is that the
PCI_D3hot is mapped to ACPI_STATE_D3_HOT instead of ACPI_STATE_D3_COLD.

But there is a bug in the Leaf Hill ACPI table, the _S3W() of the PCIe
bridge to which the Ethernet PCIe card is attached return 3(S3hot).
But the WOL function only work when we put it to 4(S3cold) state.
The commit 7705631fced2 just expose this bug. So we revert this commit
to workaround this ACPI bug.

Signed-off-by: Kevin Hao <kexin.hao@windriver>
---
 drivers/acpi/device_pm.c |   99 ++++++++++++++++++---------------------------
 drivers/acpi/fan.c       |    5 +-
 drivers/acpi/power.c     |    3 +-
 drivers/acpi/scan.c      |   26 +++++++++---
 drivers/pci/pci-acpi.c   |    2 +-
 include/acpi/acpi_bus.h  |    3 +-
 6 files changed, 66 insertions(+), 72 deletions(-)

diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index da08678..89bae5d 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -94,16 +94,17 @@ int acpi_device_get_power(struct acpi_device *device, int *state)
 
 		/*
 		 * The power resources settings may indicate a power state
-		 * shallower than the actual power state of the device, because
-		 * the same power resources may be referenced by other devices.
+		 * shallower than the actual power state of the device.
 		 *
-		 * For systems predating ACPI 4.0 we assume that D3hot is the
-		 * deepest state that can be supported.
+		 * Moreover, on systems predating ACPI 4.0, if the device
+		 * doesn't depend on any power resources and _PSC returns 3,
+		 * that means "power off".  We need to maintain compatibility
+		 * with those systems.
 		 */
 		if (psc > result && psc < ACPI_STATE_D3_COLD)
 			result = psc;
 		else if (result == ACPI_STATE_UNKNOWN)
-			result = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_HOT : psc;
+			result = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_COLD : psc;
 	}
 
 	/*
@@ -148,8 +149,8 @@ static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
  */
 int acpi_device_set_power(struct acpi_device *device, int state)
 {
-	int target_state = state;
 	int result = 0;
+	bool cut_power = false;
 
 	if (!device || !device->flags.power_manageable
 	    || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))
@@ -164,21 +165,11 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return 0;
 	}
 
-	if (state == ACPI_STATE_D3_COLD) {
-		/*
-		 * For transitions to D3cold we need to execute _PS3 and then
-		 * possibly drop references to the power resources in use.
-		 */
-		state = ACPI_STATE_D3_HOT;
-		/* If _PR3 is not available, use D3hot as the target state. */
-		if (!device->power.states[ACPI_STATE_D3_COLD].flags.valid)
-			target_state = state;
-	} else if (!device->power.states[state].flags.valid) {
+	if (!device->power.states[state].flags.valid) {
 		dev_warn(&device->dev, "Power state %s not supported\n",
 			 acpi_power_state_string(state));
 		return -ENODEV;
 	}
-
 	if (!device->power.flags.ignore_parent &&
 	    device->parent && (state < device->parent->power.state)) {
 		dev_warn(&device->dev,
@@ -188,38 +179,39 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		return -ENODEV;
 	}
 
+	/* For D3cold we should first transition into D3hot. */
+	if (state == ACPI_STATE_D3_COLD
+	    && device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {
+		state = ACPI_STATE_D3_HOT;
+		cut_power = true;
+	}
+
+	if (state < device->power.state && state != ACPI_STATE_D0
+	    && device->power.state >= ACPI_STATE_D3_HOT) {
+		dev_warn(&device->dev,
+			 "Cannot transition to non-D0 state from D3\n");
+		return -ENODEV;
+	}
+
 	/*
 	 * Transition Power
 	 * ----------------
-	 * In accordance with ACPI 6, _PSx is executed before manipulating power
-	 * resources, unless the target state is D0, in which case _PS0 is
-	 * supposed to be executed after turning the power resources on.
+	 * In accordance with the ACPI specification first apply power (via
+	 * power resources) and then evaluate _PSx.
 	 */
-	if (state > ACPI_STATE_D0) {
-		/*
-		 * According to ACPI 6, devices cannot go from lower-power
-		 * (deeper) states to higher-power (shallower) states.
-		 */
-		if (state < device->power.state) {
-			dev_warn(&device->dev, "Cannot transition from %s to %s\n",
-				 acpi_power_state_string(device->power.state),
-				 acpi_power_state_string(state));
-			return -ENODEV;
-		}
-
-		result = acpi_dev_pm_explicit_set(device, state);
+	if (device->power.flags.power_resources) {
+		result = acpi_power_transition(device, state);
 		if (result)
 			goto end;
+	}
+	result = acpi_dev_pm_explicit_set(device, state);
+	if (result)
+		goto end;
 
-		if (device->power.flags.power_resources)
-			result = acpi_power_transition(device, target_state);
-	} else {
-		if (device->power.flags.power_resources) {
-			result = acpi_power_transition(device, ACPI_STATE_D0);
-			if (result)
-				goto end;
-		}
-		result = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);
+	if (cut_power) {
+		device->power.state = state;
+		state = ACPI_STATE_D3_COLD;
+		result = acpi_power_transition(device, state);
 	}
 
  end:
@@ -227,7 +219,7 @@ int acpi_device_set_power(struct acpi_device *device, int state)
 		dev_warn(&device->dev, "Failed to change power state to %s\n",
 			 acpi_power_state_string(state));
 	} else {
-		device->power.state = target_state;
+		device->power.state = state;
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 				  "Device [%s] transitioned to %s\n",
 				  device->pnp.bus_id,
@@ -268,24 +260,13 @@ int acpi_bus_init_power(struct acpi_device *device)
 		return result;
 
 	if (state < ACPI_STATE_D3_COLD && device->power.flags.power_resources) {
-		/* Reference count the power resources. */
 		result = acpi_power_on_resources(device, state);
 		if (result)
 			return result;
 
-		if (state == ACPI_STATE_D0) {
-			/*
-			 * If _PSC is not present and the state inferred from
-			 * power resources appears to be D0, it still may be
-			 * necessary to execute _PS0 at this point, because
-			 * another device using the same power resources may
-			 * have been put into D0 previously and that's why we
-			 * see D0 here.
-			 */
-			result = acpi_dev_pm_explicit_set(device, state);
-			if (result)
-				return result;
-		}
+		result = acpi_dev_pm_explicit_set(device, state);
+		if (result)
+			return result;
 	} else if (state == ACPI_STATE_UNKNOWN) {
 		/*
 		 * No power resources and missing _PSC?  Cross fingers and make
@@ -618,12 +599,12 @@ int acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)
 	if (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)
 		return -EINVAL;
 
-	if (d_max_in > ACPI_STATE_D2) {
+	if (d_max_in > ACPI_STATE_D3_HOT) {
 		enum pm_qos_flags_status stat;
 
 		stat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);
 		if (stat == PM_QOS_FLAGS_ALL)
-			d_max_in = ACPI_STATE_D2;
+			d_max_in = ACPI_STATE_D3_HOT;
 	}
 
 	adev = ACPI_COMPANION(dev);
diff --git a/drivers/acpi/fan.c b/drivers/acpi/fan.c
index e297a48..67e6aba 100644
--- a/drivers/acpi/fan.c
+++ b/drivers/acpi/fan.c
@@ -154,9 +154,8 @@ static int fan_get_state(struct acpi_device *device, unsigned long *state)
 	if (result)
 		return result;
 
-	*state = acpi_state == ACPI_STATE_D3_COLD
-			|| acpi_state == ACPI_STATE_D3_HOT ?
-		0 : (acpi_state == ACPI_STATE_D0 ? 1 : -1);
+	*state = (acpi_state == ACPI_STATE_D3_COLD ? 0 :
+		 (acpi_state == ACPI_STATE_D0 ? 1 : -1));
 	return 0;
 }
 
diff --git a/drivers/acpi/power.c b/drivers/acpi/power.c
index fcd4ce6..0dd8c17 100644
--- a/drivers/acpi/power.c
+++ b/drivers/acpi/power.c
@@ -683,8 +683,7 @@ int acpi_power_get_inferred_state(struct acpi_device *device, int *state)
 		}
 	}
 
-	*state = device->power.states[ACPI_STATE_D3_COLD].flags.valid ?
-		ACPI_STATE_D3_COLD : ACPI_STATE_D3_HOT;
+	*state = ACPI_STATE_D3_COLD;
 	return 0;
 }
 
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 87bc20c..d017c25 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -941,9 +941,15 @@ static void acpi_bus_init_power_state(struct acpi_device *device, int state)
 	if (acpi_has_method(device->handle, pathname))
 		ps->flags.explicit_set = 1;
 
-	/* State is valid if there are means to put the device into it. */
-	if (!list_empty(&ps->resources) || ps->flags.explicit_set)
+	/*
+	 * State is valid if there are means to put the device into it.
+	 * D3hot is only valid if _PR3 present.
+	 */
+	if (!list_empty(&ps->resources)
+	    || (ps->flags.explicit_set && state < ACPI_STATE_D3_HOT)) {
 		ps->flags.valid = 1;
+		ps->flags.os_accessible = 1;
+	}
 
 	ps->power = -1;		/* Unknown - driver assigned */
 	ps->latency = -1;	/* Unknown - driver assigned */
@@ -979,13 +985,21 @@ static void acpi_bus_get_power_flags(struct acpi_device *device)
 		acpi_bus_init_power_state(device, i);
 
 	INIT_LIST_HEAD(&device->power.states[ACPI_STATE_D3_COLD].resources);
-	if (!list_empty(&device->power.states[ACPI_STATE_D3_HOT].resources))
-		device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
 
-	/* Set defaults for D0 and D3hot states (always valid) */
+	/* Set defaults for D0 and D3 states (always valid) */
 	device->power.states[ACPI_STATE_D0].flags.valid = 1;
 	device->power.states[ACPI_STATE_D0].power = 100;
-	device->power.states[ACPI_STATE_D3_HOT].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3_COLD].flags.valid = 1;
+	device->power.states[ACPI_STATE_D3_COLD].power = 0;
+
+	/* Set D3cold's explicit_set flag if _PS3 exists. */
+	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set)
+		device->power.states[ACPI_STATE_D3_COLD].flags.explicit_set = 1;
+
+	/* Presence of _PS3 or _PRx means we can put the device into D3 cold */
+	if (device->power.states[ACPI_STATE_D3_HOT].flags.explicit_set ||
+			device->power.flags.power_resources)
+		device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible = 1;
 
 	if (acpi_bus_init_power(device))
 		device->flags.power_manageable = 0;
diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 314a625..6f6f175 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -420,7 +420,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
 		[PCI_D2] = ACPI_STATE_D2,
-		[PCI_D3hot] = ACPI_STATE_D3_HOT,
+		[PCI_D3hot] = ACPI_STATE_D3_COLD,
 		[PCI_D3cold] = ACPI_STATE_D3_COLD,
 	};
 	int error = -EINVAL;
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index ffa2ade..dbcd01f 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -270,6 +270,7 @@ struct acpi_device_power_flags {
 struct acpi_device_power_state {
 	struct {
 		u8 valid:1;
+		u8 os_accessible:1;
 		u8 explicit_set:1;	/* _PSx present? */
 		u8 reserved:6;
 	} flags;
@@ -658,7 +659,7 @@ static inline bool acpi_device_can_wakeup(struct acpi_device *adev)
 
 static inline bool acpi_device_can_poweroff(struct acpi_device *adev)
 {
-	return adev->power.states[ACPI_STATE_D3_COLD].flags.valid;
+	return adev->power.states[ACPI_STATE_D3_COLD].flags.os_accessible;
 }
 
 #else	/* CONFIG_ACPI */
-- 
1.7.5.4

