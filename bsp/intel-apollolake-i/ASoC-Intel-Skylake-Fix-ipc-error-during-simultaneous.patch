From d2dc9c0877c205d08bbb4cbcf5fa5347fb8ec27b Mon Sep 17 00:00:00 2001
From: "Pawse, GuruprasadX" <guruprasadx.pawse@intel.com>
Date: Fri, 20 May 2016 18:58:20 +0530
Subject: [PATCH 1973/2508] ASoC: Intel: Skylake: Fix ipc error during
 simultaneous extractor and injector

commit 7f856dd9d66b3c52afd3c63f8f2d4115824e65db from
https://github.com/01org/linux-apollolake-i

In an simultaneous extractor-injector usecase, the injector probe point
was getting set before the stream is opened and before any DMA is attached
which should not be the case. This patch ensures that the injector probe
point is not set unless a new compr playback stream is opened and
a DMA is attached.

This patch also resolves the issue with probe disconnect.

Change-Id: Ifef3c5e33ab48b106feb3d6066444d9ba00cc00d
Signed-off-by: Pawse, GuruprasadX <guruprasadx.pawse@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9395
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/skl-topology.c |   16 ++++++++++++----
 1 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-topology.c b/sound/soc/intel/skylake/skl-topology.c
index 2d037b0..d618dff 100644
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@ -1534,19 +1534,27 @@ static int skl_tplg_tlv_probe_set(struct snd_kcontrol *kcontrol,
 			return -EINVAL;
 
 		if (pconfig->probe_count) {
-			if (ap->is_connect == SKL_PROBE_CONNECT) {
+			/* In the case of extraction, additional probe points can be set when
+			 * the stream is in progress and the driver can immediately send the
+			 * connect IPC. But in the case of injector, for each probe point
+			 * connection a new stream with the DAI number corresponding to that
+			 * control has to be opened. Hence below check ensures that the
+			 * connect IPC is sent only in case of extractor.
+			 */
+			if ((ap->is_connect == SKL_PROBE_CONNECT)
+				&& (ap->is_ext_inj == SKL_PROBE_EXTRACT)) {
 
 				memcpy(&connect_point.params, &ap->params, sizeof(u32));
-				connect_point.connection = ap->is_connect;
+				connect_point.connection = ap->is_ext_inj;
 				memcpy(&connect_point.node_id, (&ap->node_id), sizeof(u32));
 				return skl_set_module_params(skl->skl_sst, (void *)&connect_point,
-						sizeof(struct probe_pt_param), &ap->is_connect, mconfig);
+						sizeof(struct probe_pt_param), ap->is_connect, mconfig);
 
 			} else if (ap->is_connect == SKL_PROBE_DISCONNECT) {
 
 				disconnect_point = (int)ap->params;
 				return skl_set_module_params(skl->skl_sst, (void *)&disconnect_point,
-						sizeof(disconnect_point), &ap->is_connect, mconfig);
+						sizeof(disconnect_point), ap->is_connect, mconfig);
 			}
 		}
 	}
-- 
1.7.5.4

