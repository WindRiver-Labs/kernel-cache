From 2cf57f1d4e0b88d65de6e793af77b07a8129a89b Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Sun, 6 Nov 2016 08:17:31 +0200
Subject: [PATCH 4641/4706] mei: dal: add api to set/unset ta id exclusive
 access

commit 9b66d4b0768553a00269f6df5f270aa016ed8d5d from
git://git.yoctoproject.org/linux-yocto-4.1

Add api to kdi to set and unset exclusive access to a trusted applet,
so no one else can open session to that applet. The access owner
is the interface itself.

Change-Id: Ic860a7e02b3705ad39cff0111c96b1104392973c
Signed-off-by: Yael Samet <yael.samet@intel.com>
---
 drivers/misc/mei/dal/dal_kdi.c |   93 ++++++++++++++++++++++++++++++++++++++++
 include/linux/dal.h            |    5 ++
 2 files changed, 98 insertions(+), 0 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 78556af..a83b075 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -452,6 +452,99 @@ int dal_close_session(u64 handle, u64 session_handle)
 }
 EXPORT_SYMBOL(dal_close_session);
 
+/**
+ * dal_set_exclusive_access - set given uuid exclusive
+ *
+ * @handle: kdi handle
+ * @ta_id: trusted applet id
+ *
+ * Return:
+ *    DAL_KDI_SUCCESS
+ *    DAL_KDI_STATUS_INTERNAL_ERROR
+ *    DAL_KDI_STATUS_TA_EXIST
+ *    DAL_KDI_STATUS_NON_EXCLUSIVENESS_TA;
+ */
+int dal_set_ta_exclusive_access(u64 handle, uuid_be ta_id)
+{
+	struct dal_device *ddev;
+	struct device *dev;
+	struct dal_client *dc;
+	int ret;
+
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	mutex_lock(&kdi_lock);
+
+	dev = dal_find_dev(DAL_MEI_DEVICE_IVM);
+	if (!dev) {
+		dev_err(dev, "can't find device\n");
+		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+		goto unlock;
+	}
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KDI];
+
+	ret = dal_access_policy_add(ddev, ta_id, dc);
+	if (ret == -EEXIST)
+		ret = DAL_KDI_STATUS_TA_EXIST;
+	else if (ret == -EPERM)
+		ret = DAL_KDI_STATUS_NON_EXCLUSIVENESS_TA;
+	else if (ret)
+		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+
+	put_device(dev);
+unlock:
+	mutex_unlock(&kdi_lock);
+	return ret;
+}
+EXPORT_SYMBOL(dal_set_ta_exclusive_access);
+
+/**
+ * dal_unset_ta_exclusive_access - remove exclusiveness from uuid
+ *
+ * @handle: kdi handle
+ * @ta_id: trusted applet id
+ *
+ * Return:
+ */
+int dal_unset_ta_exclusive_access(u64 handle, uuid_be ta_id)
+{
+	struct dal_device *ddev;
+	struct device *dev;
+	struct dal_client *dc;
+	int ret;
+
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	mutex_lock(&kdi_lock);
+
+	dev = dal_find_dev(DAL_MEI_DEVICE_IVM);
+	if (!dev) {
+		mutex_unlock(&kdi_lock);
+		dev_err(dev, "can't find device\n");
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+	}
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KDI];
+
+	ret = dal_access_policy_remove(ddev, ta_id, dc);
+	if (ret == -ENOENT)
+		ret = DAL_KDI_STATUS_TA_NOT_FOUND;
+	else if (ret == -EPERM)
+		ret = DAL_KDI_STATUS_OPERATION_NOT_PERMITTED;
+
+	put_device(dev);
+
+	mutex_unlock(&kdi_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dal_unset_ta_exclusive_access);
+
 #define KDI_MAJOR_VER         "1"
 #define KDI_MINOR_VER         "0"
 #define KDI_HOTFIX_VER        "0"
diff --git a/include/linux/dal.h b/include/linux/dal.h
index e4ed319..0e60118 100644
--- a/include/linux/dal.h
+++ b/include/linux/dal.h
@@ -62,6 +62,7 @@
 #define _DAL_H_
 
 #include <linux/types.h>
+#include <linux/uuid.h>
 
 #define DAL_VERSION_LEN             32
 
@@ -178,4 +179,8 @@ int dal_send_and_receive(u64 handle, u64 session_handle,
  */
 int dal_close_session(u64 handle, u64 session_handle);
 
+int dal_set_ta_exclusive_access(u64 handle, uuid_be ta_id);
+
+int dal_unset_ta_exclusive_access(u64 handle, uuid_be ta_id);
+
 #endif /* _DAL_H_ */
-- 
1.7.5.4

