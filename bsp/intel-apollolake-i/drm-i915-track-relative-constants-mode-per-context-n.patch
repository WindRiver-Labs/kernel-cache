From e7fddf90b30e5759c6f3f0b35d62ec42232b228b Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:12 -0700
Subject: [PATCH 1358/2508] drm/i915: track relative-constants-mode
 per-context not per-device

commit 457ee1df78b13af3721ab81ff584da3816e4d6af from
https://github.com/01org/linux-apollolake-i

'relative_constants_mode' has always been tracked per-device, but this
is wrong in execlists (or GuC) mode, as INSTPM is saved and restored
with the logical context, and the per-context value could therefore get
out of sync with the tracked value. This patch moves the tracking
element from the dev_priv structure into the intel_context structure,
with corresponding adjustments to the code that initialises and uses it.

Test case (if anyone wants to write it) would be to create two contexts,
submit a batch with a non-default mode in the first context, submit a
batch with the default mode in the other context, submit another batch
in the first context, but this time in default mode. The driver will
fail to insert the instructions to reset INSTPM into the first context's
ringbuffer.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=92448

For: VIZ-2021
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_drv.h            |    4 ++--
 drivers/gpu/drm/i915/i915_gem.c            |    2 --
 drivers/gpu/drm/i915/i915_gem_context.c    |    3 +++
 drivers/gpu/drm/i915/i915_gem_execbuffer.c |    6 +++---
 drivers/gpu/drm/i915/intel_lrc.c           |    6 +++---
 5 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 2ea39c4..b266424 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -886,6 +886,8 @@ struct intel_context {
 	struct i915_ctx_sched_info sched_info;
 	struct i915_hw_ppgtt *ppgtt;
 
+	int relative_constants_mode;
+
 	/* Legacy ring buffer submission */
 	struct {
 		struct drm_i915_gem_object *rcs_state;
@@ -1783,8 +1785,6 @@ struct drm_i915_private {
 
 	const struct intel_device_info info;
 
-	int relative_constants_mode;
-
 	void __iomem *regs;
 
 	struct intel_uncore uncore;
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index f06c742..2f43d00 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -5552,8 +5552,6 @@ i915_gem_load_init(struct drm_device *dev)
 				i915_scheduler_work_handler);
 	init_waitqueue_head(&dev_priv->gpu_error.reset_queue);
 
-	dev_priv->relative_constants_mode = I915_EXEC_CONSTANTS_REL_GENERAL;
-
 	/*
 	 * Set initial sequence number for requests.
 	 * Using this number allows the wraparound to happen early,
diff --git a/drivers/gpu/drm/i915/i915_gem_context.c b/drivers/gpu/drm/i915/i915_gem_context.c
index 81f837d..6aad576 100644
--- a/drivers/gpu/drm/i915/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/i915_gem_context.c
@@ -251,6 +251,9 @@ __create_hw_context(struct drm_device *dev,
 	 * is no remap info, it will be a NOP. */
 	ctx->remap_slice = (1 << NUM_L3_SLICES(dev)) - 1;
 
+	/* First execbuffer will override this */
+	ctx->relative_constants_mode = -1;
+
 	ctx->hang_stats.ban_period_seconds = DRM_I915_CTX_BAN_PERIOD;
 
 	return ctx;
diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index b592311..357dfc3 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -1229,7 +1229,7 @@ i915_gem_ringbuffer_submission(struct i915_execbuffer_params *params,
 			return -EINVAL;
 		}
 
-		if (params->instp_mode != dev_priv->relative_constants_mode) {
+		if (params->instp_mode != params->ctx->relative_constants_mode) {
 			if (INTEL_INFO(dev)->gen < 4) {
 				DRM_DEBUG("no rel constants on pre-gen4\n");
 				return -EINVAL;
@@ -1352,14 +1352,14 @@ int i915_gem_ringbuffer_submission_final(struct i915_execbuffer_params *params)
 	     "%s didn't clear reload\n", engine->name);
 
 	if (engine == &dev_priv->engine[RCS] &&
-	    params->instp_mode != dev_priv->relative_constants_mode) {
+	    params->instp_mode != params->ctx->relative_constants_mode) {
 		intel_ring_emit(engine, MI_NOOP);
 		intel_ring_emit(engine, MI_LOAD_REGISTER_IMM(1));
 		intel_ring_emit_reg(engine, INSTPM);
 		intel_ring_emit(engine, params->instp_mask << 16 | params->instp_mode);
 		intel_ring_advance(engine);
 
-		dev_priv->relative_constants_mode = params->instp_mode;
+		params->ctx->relative_constants_mode = params->instp_mode;
 	}
 
 	if (params->args_flags & I915_EXEC_GEN7_SOL_RESET) {
diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
index 2ebe036..3b9a392 100644
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -991,7 +991,7 @@ int intel_execlists_submission(struct i915_execbuffer_params *params,
 			return -EINVAL;
 		}
 
-		if (params->instp_mode != dev_priv->relative_constants_mode) {
+		if (params->instp_mode != params->ctx->relative_constants_mode) {
 			if (params->instp_mode == I915_EXEC_CONSTANTS_REL_SURFACE) {
 				DRM_DEBUG("rel surface constants mode invalid on gen5+\n");
 				return -EINVAL;
@@ -1105,14 +1105,14 @@ int intel_execlists_submission_final(struct i915_execbuffer_params *params)
 		goto err;
 
 	if (engine == &dev_priv->engine[RCS] &&
-	    params->instp_mode != dev_priv->relative_constants_mode) {
+	    params->instp_mode != params->ctx->relative_constants_mode) {
 		intel_logical_ring_emit(ringbuf, MI_NOOP);
 		intel_logical_ring_emit(ringbuf, MI_LOAD_REGISTER_IMM(1));
 		intel_logical_ring_emit_reg(ringbuf, INSTPM);
 		intel_logical_ring_emit(ringbuf, params->instp_mask << 16 | params->instp_mode);
 		intel_logical_ring_advance(ringbuf);
 
-		dev_priv->relative_constants_mode = params->instp_mode;
+		params->ctx->relative_constants_mode = params->instp_mode;
 	}
 
 	exec_start = params->batch_obj_vm_offset +
-- 
1.7.5.4

