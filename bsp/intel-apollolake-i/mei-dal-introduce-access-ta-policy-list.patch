From 6dc0ee6ff75cfe72c03cce29d0e090cf3ab39c8f Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Sat, 5 Nov 2016 01:31:59 +0200
Subject: [PATCH 4638/4706] mei: dal: introduce access ta policy list.

commit 90df748b1474f8e614c16fc273dc969c427b1fa9 from
git://git.yoctoproject.org/linux-yocto-4.1

The infrastructure for limiting access to a trusted
application.

Change-Id: I3157be43852bd302eb43eb4a086635128391e4d3
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Yael Samet <yael.samet@intel.com>
---
 drivers/misc/mei/dal/Makefile        |    1 +
 drivers/misc/mei/dal/dal_dev.h       |    8 ++
 drivers/misc/mei/dal/dal_ta_access.c |  190 ++++++++++++++++++++++++++++++++++
 3 files changed, 199 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/mei/dal/dal_ta_access.c

diff --git a/drivers/misc/mei/dal/Makefile b/drivers/misc/mei/dal/Makefile
index 312fccc..e1b2057 100644
--- a/drivers/misc/mei/dal/Makefile
+++ b/drivers/misc/mei/dal/Makefile
@@ -4,6 +4,7 @@ obj-$(CONFIG_INTEL_MEI_DAL) += mei_dal.o
 mei_dal-objs := dal_class.o
 mei_dal-objs += dal_cdev.o
 mei_dal-objs += dal_kdi.o
+mei_dal-objs += dal_ta_access.o
 mei_dal-objs += admin_pack_ext.o
 mei_dal-objs += admin_pack_int.o
 mei_dal-objs += bhp_impl.o
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 02383d6..5be9ff0 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -225,4 +225,12 @@ void dal_dc_print(struct device *dev, struct dal_client *dc);
 int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf);
 void dal_dc_destroy(struct dal_device *ddev, enum dal_intf intf);
 
+int dal_access_policy_add(struct dal_device *ddev, uuid_be app_id, void *owner);
+int dal_access_policy_remove(struct dal_device *ddev,
+			     uuid_be app_id, void *owner);
+int dal_access_policy_allowed(struct dal_device *ddev,
+			      uuid_be app_id, void *owner);
+void dal_access_list_free(struct dal_device *ddev);
+int dal_access_list_init(struct dal_device *ddev);
+
 #endif  /* _DAL_KDI_H_ */
diff --git a/drivers/misc/mei/dal/dal_ta_access.c b/drivers/misc/mei/dal/dal_ta_access.c
new file mode 100644
index 0000000..1b31ce8
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_ta_access.c
@@ -0,0 +1,190 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/uuid.h>
+
+#include <linux/mei_cl_bus.h>
+#include "dal_dev.h"
+
+struct dal_access_policy {
+	struct list_head list;
+	uuid_be app_id;
+	void *owner;
+};
+
+static struct list_head *dal_dev_get_access_list(struct dal_device *ddev)
+{
+	return dev_get_drvdata(&ddev->dev);
+}
+
+static struct dal_access_policy *
+dal_access_policy_alloc(uuid_be app_id, void *owner)
+{
+	struct dal_access_policy *e;
+
+	e = kzalloc(sizeof(*e), GFP_KERNEL);
+	if (!e)
+		return NULL;
+
+	INIT_LIST_HEAD(&e->list);
+	e->app_id = app_id;
+	e->owner = owner;
+
+	return e;
+}
+
+static struct dal_access_policy *
+dal_access_policy_find(struct list_head *access_list, uuid_be app_id)
+{
+	struct dal_access_policy *e;
+
+	list_for_each_entry(e, access_list, list) {
+		if (!uuid_be_cmp(e->app_id, app_id))
+			return e;
+	}
+	return NULL;
+}
+
+int dal_access_policy_add(struct dal_device *ddev, uuid_be app_id, void *owner)
+{
+	struct list_head *access_list = dal_dev_get_access_list(ddev);
+	struct dal_access_policy *e;
+
+	e = dal_access_policy_find(access_list, app_id);
+	if (e) {
+		if (!e->owner)
+			return -EPERM;
+
+		return -EEXIST;
+	}
+
+	e = dal_access_policy_alloc(app_id, owner);
+	if (!e)
+		return -ENOMEM;
+
+	list_add_tail(&e->list, access_list);
+	return 0;
+}
+
+int dal_access_policy_remove(struct dal_device *ddev,
+			     uuid_be app_id, void *owner)
+{
+	struct list_head *access_list = dal_dev_get_access_list(ddev);
+	struct dal_access_policy *e;
+
+	e = dal_access_policy_find(access_list, app_id);
+	if (!e)
+		return -ENOENT;
+
+	if (!e->owner || e->owner != owner)
+		return -EPERM;
+
+	list_del(&e->list);
+	kfree(e);
+	return 0;
+}
+
+int dal_access_policy_allowed(struct dal_device *ddev,
+			      uuid_be app_id, void *owner)
+{
+	struct list_head *access_list = dal_dev_get_access_list(ddev);
+	struct dal_access_policy *e;
+
+	e = dal_access_policy_find(access_list, app_id);
+	if (!e)
+		return 0;
+
+	if (e->owner && e->owner != owner)
+		return -EPERM;
+
+	return 0;
+}
+
+void dal_access_list_free(struct dal_device *ddev)
+{
+	struct list_head *access_list = dal_dev_get_access_list(ddev);
+	struct dal_access_policy *e, *n;
+
+	if  (!access_list)
+		return;
+
+	list_for_each_entry_safe(e, n, access_list, list) {
+		list_del(&e->list);
+		kfree(e);
+	}
+
+	kfree(access_list);
+	dev_set_drvdata(&ddev->dev, NULL);
+}
+
+int dal_access_list_init(struct dal_device *ddev)
+{
+	struct list_head *access_list;
+
+	access_list = kzalloc(sizeof(*access_list), GFP_KERNEL);
+	if (!access_list)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(access_list);
+	dev_set_drvdata(&ddev->dev, access_list);
+
+	return 0;
+}
-- 
1.7.5.4

