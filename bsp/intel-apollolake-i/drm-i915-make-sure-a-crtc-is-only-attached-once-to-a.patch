From 3dbdd0ba0714edd0277e5a35fe3388f849a44738 Mon Sep 17 00:00:00 2001
From: "Xiong, James" <james.xiong@intel.com>
Date: Tue, 14 Jun 2016 11:59:47 -0700
Subject: [PATCH 1453/2508] drm/i915: make sure a crtc is only attached once
 to a single encoder

commit 99b5a53f82bd06b708a92505722716d518cf44f3 from
https://github.com/01org/linux-apollolake-i

Signed-off-by: Xiong, James <james.xiong@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
[mattrope: Added blank line suggested by Bob]
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/intel_initial_modeset.c |   37 +++++++++++++++----------
 1 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
index bdb4925..e1dcb9e 100644
--- a/drivers/gpu/drm/i915/intel_initial_modeset.c
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -92,18 +92,27 @@ static bool use_connector(struct drm_connector *connector)
 	return false;
 }
 
-static void attach_crtc(struct drm_device *dev, struct drm_encoder *encoder)
+static bool attach_crtc(struct drm_device *dev, struct drm_encoder *encoder,
+			uint32_t *used_crtcs)
 {
 	struct drm_crtc *possible_crtc;
 
+	if(encoder->crtc != NULL &&
+	   !(*used_crtcs & drm_crtc_mask(encoder->crtc))) {
+		*used_crtcs |= drm_crtc_mask(encoder->crtc);
+		return true;
+	}
+
 	drm_for_each_crtc(possible_crtc, dev) {
-		if (!(encoder->possible_crtcs & drm_crtc_mask(possible_crtc)))
-			continue;
-		if (possible_crtc->state->enable)
+		if (!(encoder->possible_crtcs & drm_crtc_mask(possible_crtc))
+		    || (*used_crtcs & drm_crtc_mask(possible_crtc)))
 			continue;
+		*used_crtcs |= drm_crtc_mask(possible_crtc);
 		encoder->crtc = possible_crtc;
-		break;
+		return true;
 	}
+
+	return false;
 }
 
 static struct drm_encoder *get_encoder(struct drm_device *dev,
@@ -114,17 +123,8 @@ static struct drm_encoder *get_encoder(struct drm_device *dev,
 
 	connector_funcs = connector->helper_private;
 	encoder = connector_funcs->best_encoder(connector);
-	if (!encoder) {
-		DRM_DEBUG_KMS("connector %s has no encoder\n",
-			      connector->name);
-		return NULL;
-	}
 
-	if (!encoder->crtc) {
-		attach_crtc(dev, encoder);
-		if (!encoder->crtc)
-			return NULL;
-	}
+	WARN_ON(encoder != NULL);
 
 	return encoder;
 }
@@ -544,6 +544,7 @@ static void modeset_config_fn(struct work_struct *work)
 	struct drm_plane *plane;
 	int ret;
 	bool found = false;
+	uint32_t used_crtcs;
 	unsigned long long start = sched_clock();
 
 	intel_splash_screen_init(dev);
@@ -569,6 +570,7 @@ retry:
 	if (ret)
 		goto fail;
 
+	used_crtcs = 0;
 	/*
 	 * For each connector that we want to set up, update the atomic
 	 * state to include the connector and crtc mode.
@@ -579,6 +581,8 @@ retry:
 		if (use_connector(connector)) {
 			if (!(encoder = get_encoder(dev, connector)))
 				continue;
+			if (!attach_crtc(dev, encoder, &used_crtcs))
+				continue;
 
 			ret = update_atomic_state(dev, state,
 					    connector, encoder);
@@ -589,6 +593,7 @@ retry:
 	}
 
 	if (!found) {
+		used_crtcs = 0;
 		/* Try to detect attached connectors */
 		drm_for_each_connector(connector, dev) {
 			struct drm_encoder *encoder;
@@ -598,6 +603,8 @@ retry:
 			if (connector->status == connector_status_connected) {
 				if (!(encoder = get_encoder(dev, connector)))
 					continue;
+				if (!attach_crtc(dev, encoder, &used_crtcs))
+					continue;
 
 				ret = update_atomic_state(dev, state,
 							  connector, encoder);
-- 
1.7.5.4

