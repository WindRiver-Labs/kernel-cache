From a942dac3909a69be74a2d7b37b244bd543905d01 Mon Sep 17 00:00:00 2001
From: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date: Mon, 4 Jul 2016 16:11:56 +0300
Subject: [PATCH 2318/2508] tpm_crb: runtime power management

commit a0d2df4b97633b0f2592e05297834ef2ff4d756a from
https://github.com/01org/linux-apollolake-i

The register TPM_CRB_CTRL_REQ_0 contains bits goIdle and cmdReady for
invoking the chip to suspend and resume. This commit implements runtime
PM for tpm_crb by using these bits.

The legacy ACPI start (SMI + DMA) based devices do not support these
bits. Thus this functionality only is enabled only for CRB start (MMIO)
based devices.

We introduce two new callbacks for resuming and pausing a TPM device.
TPM hardware drivers can choose their way to implement these callbacks
(for example using runtime PM framework). Since the usage pattern in
CRB driver is at this point so trivial I chose to not take it into
use yet.

Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
---
 drivers/char/tpm/tpm-interface.c |    7 ++++++
 drivers/char/tpm/tpm_crb.c       |   44 ++++++++++++++++++++++++++++++++++++++
 include/linux/tpm.h              |    3 +-
 3 files changed, 53 insertions(+), 1 deletions(-)

diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 7cba092..3434ae5 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -351,6 +351,11 @@ ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,
 	}
 
 	mutex_lock(&chip->tpm_mutex);
+	if (chip->ops->resume) {
+		rc = chip->ops->resume(chip);
+		if (rc)
+			goto out;
+	}
 
 	rc = chip->ops->send(chip, (u8 *) buf, count);
 	if (rc < 0) {
@@ -393,6 +398,8 @@ out_recv:
 		dev_err(&chip->dev,
 			"tpm_transmit: tpm_recv: error %zd\n", rc);
 out:
+	if (chip->ops->pause)
+		chip->ops->pause(chip);
 	mutex_unlock(&chip->tpm_mutex);
 	return rc;
 }
diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index c89e907..105fad0 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -83,6 +83,46 @@ struct crb_priv {
 	u8 __iomem *rsp;
 };
 
+static int __maybe_unused crb_pause(struct tpm_chip *chip)
+{
+	struct crb_priv *priv = chip->vendor.priv;
+	u32 req;
+
+	if (priv->flags & CRB_FL_ACPI_START)
+		return 0;
+
+	req = ioread32(&priv->cca->req);
+	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_GO_IDLE), &priv->cca->req);
+	msleep(chip->timeout_c);
+
+	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_GO_IDLE) {
+		dev_warn(&chip->dev, "goIdle timed out\n");
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+static int __maybe_unused crb_resume(struct tpm_chip *chip)
+{
+	struct crb_priv *priv = chip->vendor.priv;
+	u32 req;
+
+	if (priv->flags & CRB_FL_ACPI_START)
+		return 0;
+
+	req = ioread32(&priv->cca->req);
+	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_CMD_READY), &priv->cca->req);
+	msleep(chip->timeout_c);
+
+	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_CMD_READY) {
+		dev_warn(&chip->dev, "cmdReady timed out\n");
+		return -ETIME;
+	}
+
+	return 0;
+}
+
 static SIMPLE_DEV_PM_OPS(crb_pm, tpm_pm_suspend, tpm_pm_resume);
 
 static u8 crb_status(struct tpm_chip *chip)
@@ -192,6 +232,10 @@ static const struct tpm_class_ops tpm_crb = {
 	.recv = crb_recv,
 	.send = crb_send,
 	.cancel = crb_cancel,
+#ifdef CONFIG_PM
+	.resume = crb_resume,
+	.pause = crb_pause,
+#endif
 	.req_canceled = crb_req_canceled,
 	.req_complete_mask = CRB_DRV_STS_COMPLETE,
 	.req_complete_val = CRB_DRV_STS_COMPLETE,
diff --git a/include/linux/tpm.h b/include/linux/tpm.h
index 706e63e..f1d9b79 100644
--- a/include/linux/tpm.h
+++ b/include/linux/tpm.h
@@ -43,7 +43,8 @@ struct tpm_class_ops {
 	u8 (*status) (struct tpm_chip *chip);
 	bool (*update_timeouts)(struct tpm_chip *chip,
 				unsigned long *timeout_cap);
-
+	int (*pause)(struct tpm_chip *chip);
+	int (*resume)(struct tpm_chip *chip);
 };
 
 #if defined(CONFIG_TCG_TPM) || defined(CONFIG_TCG_TPM_MODULE)
-- 
1.7.5.4

