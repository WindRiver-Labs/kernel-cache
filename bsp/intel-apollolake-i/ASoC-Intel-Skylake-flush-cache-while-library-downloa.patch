From 6e602db9dd1ec88b7bd0d5559581106c00ed24da Mon Sep 17 00:00:00 2001
From: G Kranthi <gudishax.kranthikumar@intel.com>
Date: Tue, 16 Feb 2016 01:17:50 +0530
Subject: [PATCH 1877/2508] ASoC: Intel: Skylake: flush cache while library
 download

commit 254c8aa8b41e2ef8d60639e28cd1886c065e4df0 from
https://github.com/01org/linux-apollolake-i

Flush the cache before triggering the library download
DMA.

Also Re-position the Library download function so that
it is aligned with other code branches.

Tracked-On: https://jira01.devtools.intel.com/browse/OAM-20107
Change-Id: I2967d2716c8fbf81b99b3dc80e25b5b2d6112068
Signed-off-by: Ramesh Babu <ramesh.babu@intel.com>
Reviewed-on: https://android.intel.com:443/470502
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/8257
---
 sound/soc/intel/skylake/bxt-sst.c |  129 ++++++++++++++++++++-----------------
 1 files changed, 69 insertions(+), 60 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 1374c1c..7f04697 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -179,66 +179,6 @@ int bxt_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 }
 EXPORT_SYMBOL_GPL(bxt_sst_dsp_init);
 
-static int bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
-{
-	struct snd_dma_buffer dmab;
-	struct skl_sst *skl = ctx->thread_context;
-	struct firmware *fw = NULL;
-	struct skl_ext_manifest_header *hdr;
-	u32 size;
-	const void *data;
-	int ret = 0, i, dma_id, stream_tag;
-
-	for (i = 1; i < minfo->lib_count; i++) {
-		fw = NULL;
-		ret = request_firmware(&fw, minfo->lib[i].name, ctx->dev);
-		if (ret < 0) {
-			dev_err(ctx->dev, "Request firmware failed %d for library: %s\n", ret, minfo->lib[i].name);
-			goto load_library_failed;
-		}
-
-		size = fw->size;
-		data = fw->data;
-		hdr = (struct skl_ext_manifest_header *)fw->data;
-		if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID) {
-			dev_dbg(ctx->dev, "Found Extended manifest in Library Binary\n");
-			if (hdr->ext_manifest_len >= fw->size) {
-				ret = -EINVAL;
-				goto load_library_failed;
-			}
-			size = fw->size - hdr->ext_manifest_len;
-			data = fw->data + hdr->ext_manifest_len;
-		}
-
-		dev_dbg(ctx->dev, "Starting to preapre host dma for library name \
-			: %s of size:%zx\n", minfo->lib[i].name, size);
-		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, size,
-						&dmab);
-		if (stream_tag <= 0) {
-			dev_err(ctx->dev, "Failed to prepare DMA engine for \
-				FW loading, err: %x\n", stream_tag);
-			ret = stream_tag;
-			goto load_library_failed;
-		}
-		dma_id = stream_tag - 1;
-		memcpy(dmab.area, data, size);
-
-		ctx->dsp_ops.trigger(ctx->dev, true, stream_tag);
-		ret = skl_sst_ipc_load_library(&skl->ipc, dma_id, i);
-		if (ret < 0)
-			dev_err(ctx->dev, "Load Library  IPC failed: %d for library: %s\n", ret, minfo->lib[i].name);
-
-		ctx->dsp_ops.trigger(ctx->dev, false, stream_tag);
-		ctx->dsp_ops.cleanup(ctx->dev, &dmab, stream_tag);
-		release_firmware(fw);
-	}
-
-	return ret;
-
-load_library_failed:
-	release_firmware(fw);
-	return ret;
-}
 
 /* First boot sequence has some extra steps due to a ROM bug on BXT.
  * Due to the bug core 0 waits for power status on core 1. The work
@@ -648,6 +588,75 @@ sst_load_base_firmware_failed:
 	return ret;
 }
 
+static int bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
+{
+	struct snd_dma_buffer dmab;
+	struct skl_sst *skl = ctx->thread_context;
+	struct firmware *fw = NULL;
+	struct skl_ext_manifest_header *hdr;
+	u32 size;
+	const void *data;
+	int ret = 0, i, dma_id, stream_tag;
+
+	for (i = 1; i < minfo->lib_count; i++) {
+		fw = NULL;
+		ret = request_firmware(&fw, minfo->lib[i].name, ctx->dev);
+		if (ret < 0) {
+			dev_err(ctx->dev, "Request firmware failed %d for library: %s\n", ret, minfo->lib[i].name);
+			goto load_library_failed;
+		}
+
+		size = fw->size;
+		data = fw->data;
+		hdr = (struct skl_ext_manifest_header *)fw->data;
+		if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID) {
+			dev_dbg(ctx->dev, "Found Extended manifest in Library Binary\n");
+			/* Check for extended manifest is not grater than FW size*/
+			if (hdr->ext_manifest_len >= fw->size) {
+				ret = -EINVAL;
+				goto load_library_failed;
+			}
+
+			size = fw->size - hdr->ext_manifest_len;
+			data = (u8 *)fw->data + hdr->ext_manifest_len;
+		}
+
+		dev_dbg(ctx->dev, "Starting to preapre host dma for library name \
+			: %s of size:%zx\n", minfo->lib[i].name, size);
+		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, size,
+						&dmab);
+		if (stream_tag <= 0) {
+			dev_err(ctx->dev, "Failed to prepare DMA engine for \
+				FW loading, err: %x\n", stream_tag);
+			ret = stream_tag;
+			goto load_library_failed;
+		}
+		dma_id = stream_tag - 1;
+		memcpy(dmab.area, data, size);
+
+		/* make sure Library is flushed to DDR */
+		clflush_cache_range(dmab.area, size);
+
+		ctx->dsp_ops.trigger(ctx->dev, true, stream_tag);
+		ret = skl_sst_ipc_load_library(&skl->ipc, dma_id, i);
+		if (ret < 0) {
+			dev_err(ctx->dev, "Load Library  IPC failed: %d for library: %s\n", ret, minfo->lib[i].name);
+			dev_info(ctx->dev, "Error code=0x%x: FW status=0x%x\n",
+					sst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),
+					sst_dsp_shim_read(ctx, BXT_ADSP_REG_FW_STATUS));
+		}
+
+		ctx->dsp_ops.trigger(ctx->dev, false, stream_tag);
+		ctx->dsp_ops.cleanup(ctx->dev, &dmab, stream_tag);
+		release_firmware(fw);
+	}
+
+	return ret;
+
+load_library_failed:
+	release_firmware(fw);
+	return ret;
+}
 
 void bxt_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)
 {
-- 
1.7.5.4

