From 9f4ce21969e4dd4289dcc565b719265350dd43a9 Mon Sep 17 00:00:00 2001
From: Evyatar Vaalani <evyatar.vaalani@intel.com>
Date: Wed, 24 Aug 2016 11:58:41 +0300
Subject: [PATCH 20/68] mei: dal: revamp bh to dal error translation

commit 877cce5a0f351fab59d4b229368707cbce547c91 from
git://git.yoctoproject.org/linux-yocto-4.1

Use bh_err_to_kdi_err function to translate
bh errors to dal errors.

Change-Id: I8e9b85a08ce99761c6b233009089ba72023e4348
Signed-off-by: Evyatar Vaalani <evyatar.vaalani@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_kdi.c |  119 +++++++++++++++++++++++-----------------
 include/linux/dal.h            |    3 +-
 2 files changed, 71 insertions(+), 51 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index acbfa4c..f2c468a 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -77,6 +77,37 @@ static struct mutex kdi_lock;
 #define BH_MSG_MAGIC_LENGTH            4
 #define BH_MSG_SEQUENCE_OFFSET         8
 
+static int bh_err_to_kdi_err(int bh_err)
+{
+	switch (bh_err) {
+	case BH_SUCCESS:
+		return DAL_KDI_SUCCESS;
+	case BPE_INTERNAL_ERROR:
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+	case BPE_INVALID_PARAMS:
+	case BHE_INVALID_PARAMS:
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+	case BHE_INVALID_HANDLE:
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+	case BPE_NOT_INIT:
+		return DAL_KDI_STATUS_NOT_INITIALIZED;
+	case BPE_NO_CONNECTION_TO_FIRMWARE:
+		return DAL_KDI_STATUS_NO_FW_CONNECTION;
+	case BPE_OUT_OF_MEMORY:
+	case BHE_OUT_OF_MEMORY:
+		return DAL_KDI_STATUS_OUT_OF_MEMORY;
+	case BHE_INSUFFICIENT_BUFFER:
+	case BHE_APPLET_SMALL_BUFFER:
+		return DAL_KDI_STATUS_BUFFER_TOO_SMALL;
+	case BPE_OUT_OF_RESOURCE:
+		return DAL_KDI_STATUS_OUT_OF_RESOURCE;
+	case BHE_SESSION_NUM_EXCEED:
+		return DAL_KDI_STATUS_MAX_SESSIONS_REACHED;
+	default:
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+	}
+}
+
 static bool kdi_check_handle(u64 handle)
 {
 	return (handle == (u64)dal_class);
@@ -89,7 +120,7 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 	struct ac_ins_jta_pack_ext pack;
 	char *ta_pkg;
 	int ta_pkg_size;
-	int ret;
+	int ret, bh_err;
 
 	if (!jta_id || !buffer || !buffer_length || !handle)
 		return DAL_KDI_STATUS_INVALID_PARAMS;
@@ -103,11 +134,11 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 		return DAL_KDI_STATUS_INVALID_PARAMS;
 	}
 
-	ret = acp_pload_ins_jta(buffer, buffer_length, &pack);
-
+	bh_err = acp_pload_ins_jta(buffer, buffer_length, &pack);
+	ret = bh_err_to_kdi_err(bh_err);
 	if (ret) {
-		pr_err("acp_pload_ins_jta() return %d", ret);
-		return DAL_KDI_STATUS_INVALID_PARAMS;
+		pr_err("acp_pload_ins_jta() return %d", bh_err);
+		return ret;
 	}
 
 	ta_pkg = pack.ta_pack;
@@ -121,8 +152,10 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 
 	ta_pkg_size = buffer_length - ta_pkg_size;
 
-	return bhp_open_ta_session(handle, jta_id, ta_pkg,
-				   ta_pkg_size, init_param, init_param_length);
+	bh_err = bhp_open_ta_session(handle, jta_id, ta_pkg, ta_pkg_size,
+				     init_param, init_param_length);
+
+	return bh_err_to_kdi_err(bh_err);
 }
 
 static bool kdi_is_mei_ready(void)
@@ -203,7 +236,7 @@ static void kdi_destroy_kernel_clients(void)
 
 int kdi_init(u32 flags, u64 *handle)
 {
-	int ret;
+	int ret, bh_err;
 
 	if (!handle)
 		return DAL_KDI_STATUS_INVALID_PARAMS;
@@ -216,6 +249,7 @@ int kdi_init(u32 flags, u64 *handle)
 		goto end;
 	}
 
+	ret = DAL_KDI_SUCCESS;
 	if (atomic_inc_return(&kdi_ref_count) == 1) {
 		mutex_init(&kdi_lock);
 		pr_debug("ref count == 1, performing init\n");
@@ -227,17 +261,15 @@ int kdi_init(u32 flags, u64 *handle)
 			goto end;
 		}
 
-		ret = bhp_init_internal(NULL);
-		if (ret != BH_SUCCESS) {
-			pr_debug("BHP_Init failed with status = %d\n", ret);
-			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+		bh_err = bhp_init_internal(NULL);
+		if (bh_err) {
+			pr_err("BHP_Init failed with status = %d\n", bh_err);
+			ret = bh_err_to_kdi_err(bh_err);
 			*handle = DAL_KDI_INVALID_HANDLE;
 		}
 	}
 
 	*handle = (u64)dal_class;
-	ret = DAL_KDI_SUCCESS;
-
 end:
 	return ret;
 }
@@ -245,7 +277,7 @@ EXPORT_SYMBOL(kdi_init);
 
 int kdi_deinit(u64 handle)
 {
-	int ret;
+	int ret, bh_err;
 
 	/* TODO: add a kernel cleanup code to module deinit possible flow:
 	 * one kernel module invokes init and a different one invokes deinit
@@ -255,21 +287,16 @@ int kdi_deinit(u64 handle)
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
+	ret = DAL_KDI_SUCCESS;
 	if (atomic_dec_and_test(&kdi_ref_count)) {
-		pr_debug("ref count == 0, performing cleanup\n");
-		ret = bhp_deinit_internal();
-		if (ret != BH_SUCCESS) {
-			pr_debug("bhp_deinit_internal failed with status = %d\n",
-				 ret);
-			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
-		} else {
-			ret = DAL_KDI_SUCCESS;
-		}
+		bh_err = bhp_deinit_internal();
+		if (bh_err)
+			pr_warn("bhp_deinit_internal failed: = %d\n", bh_err);
+
+		ret = bh_err_to_kdi_err(ret);
 
 		mutex_destroy(&kdi_lock);
 		kdi_destroy_kernel_clients();
-	} else {
-		ret = DAL_KDI_SUCCESS;
 	}
 
 	return ret;
@@ -297,13 +324,8 @@ int dal_create_session(u64 handle,
 	ret = kdi_create_session(session_handle, app_id,
 				 acp_pkg, acp_pkg_len,
 				 init_param, init_param_len);
-
-	if (ret != BH_SUCCESS) {
-		pr_err("kdi_create_session failed with status = %d\n", ret);
-		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
-	} else {
-		ret = DAL_KDI_SUCCESS;
-	}
+	if (ret)
+		pr_err("kdi_create_session failed = %d\n", ret);
 
 	mutex_unlock(&kdi_lock);
 
@@ -320,7 +342,7 @@ int dal_send_and_receive(u64 handle,
 			 size_t *output_len,
 			 int *response_code)
 {
-	int ret;
+	int ret, bh_err;
 
 	if (!kdi_is_init_done())
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
@@ -330,15 +352,13 @@ int dal_send_and_receive(u64 handle,
 
 	mutex_lock(&kdi_lock);
 
-	ret = bhp_send_and_recv(session_handle, command_id, input, input_len,
-			(void **)output, output_len, response_code);
+	bh_err = bhp_send_and_recv(session_handle, command_id, input, input_len,
+				   (void **)output, output_len, response_code);
 
-	if (ret != BH_SUCCESS) {
-		pr_err("bhp_send_and_recv failed with status = %d\n", ret);
-		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
-	} else {
-		ret = DAL_KDI_SUCCESS;
-	}
+	if (bh_err)
+		pr_err("bhp_send_and_recv failed with status = %d\n", bh_err);
+
+	ret = bh_err_to_kdi_err(bh_err);
 
 	mutex_unlock(&kdi_lock);
 
@@ -348,7 +368,7 @@ EXPORT_SYMBOL(dal_send_and_receive);
 
 int dal_close_session(u64 handle, u64 session_handle)
 {
-	int ret;
+	int ret, bh_err;
 
 	if (!kdi_is_init_done())
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
@@ -358,14 +378,13 @@ int dal_close_session(u64 handle, u64 session_handle)
 
 	mutex_lock(&kdi_lock);
 
-	ret = bhp_close_ta_session(session_handle);
+	bh_err = bhp_close_ta_session(session_handle);
+
+	if (bh_err)
+		pr_err("hp_close_ta_session failed = %d\n", bh_err);
+
+	ret = bh_err_to_kdi_err(bh_err);
 
-	if (ret != BH_SUCCESS) {
-		pr_err("hp_close_ta_session failed with status = %d\n", ret);
-		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
-	} else {
-		ret = DAL_KDI_SUCCESS;
-	}
 	mutex_unlock(&kdi_lock);
 
 	return ret;
diff --git a/include/linux/dal.h b/include/linux/dal.h
index beb5497..52ccb27 100644
--- a/include/linux/dal.h
+++ b/include/linux/dal.h
@@ -76,7 +76,7 @@ struct dal_version_info {
 	u32 reserved[4];
 };
 
-#define DAL_KDI_SUCCESS							0x0
+#define DAL_KDI_SUCCESS                         0x000
 #define DAL_KDI_STATUS_INTERNAL_ERROR           0xA00
 #define DAL_KDI_STATUS_INVALID_PARAMS           0xA01
 #define DAL_KDI_STATUS_INVALID_HANDLE           0xA02
@@ -87,6 +87,7 @@ struct dal_version_info {
 #define DAL_KDI_STATUS_BUFFER_TOO_SMALL         0xA07
 #define DAL_KDI_STATUS_OUT_OF_RESOURCE          0xA08
 #define DAL_KDI_STATUS_NOT_READY                0xA09
+#define DAL_KDI_STATUS_MAX_SESSIONS_REACHED     0xA0A
 
 #define DAL_KDI_INVALID_HANDLE    0
 
-- 
1.7.5.4

