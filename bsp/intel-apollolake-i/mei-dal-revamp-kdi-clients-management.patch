From 71c9e89c2000f86085e3fe4dd454f982d7fa70f7 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 24 Aug 2016 14:14:50 +0300
Subject: [PATCH 23/68] mei: dal: revamp kdi clients management.

commit 593111d45b70cfb895b5c8de39ed6d5a08cc5dcb from
git://git.yoctoproject.org/linux-yocto-4.1

Handle kdi via the class interface, this should
resovled correctly power management transitions
of the bus device.

Change-Id: Ibcab352d1f64751be1e23de23b24d538463d3e78
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_kdi.c |  161 ++++++++++++---------------------------
 1 files changed, 50 insertions(+), 111 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 3f67065..2ea2dcc 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -72,7 +72,7 @@
 #include "dal_dev.h"
 
 static atomic_t kdi_ref_count = ATOMIC_INIT(0);
-static struct mutex kdi_lock;
+static DEFINE_MUTEX(kdi_lock);
 
 #define BH_MSG_MAGIC_LENGTH            4
 #define BH_MSG_SEQUENCE_OFFSET         8
@@ -108,11 +108,35 @@ static int bh_err_to_kdi_err(int bh_err)
 	}
 }
 
-static bool kdi_check_handle(u64 handle)
+static int kdi_add_dev(struct device *dev,
+		       struct class_interface *class_intf)
 {
-	return (handle == (u64)dal_class);
+	int ret;
+	struct dal_device *ddev;
+
+	ddev = to_dal_device(dev);
+	mutex_lock(&ddev->context_lock);
+	ret = dal_dc_setup(ddev, DAL_INTF_KDI);
+	mutex_unlock(&ddev->context_lock);
+	return ret;
+}
+
+static void kdi_rm_dev(struct device *dev,
+		       struct class_interface *class_intf)
+{
+	struct dal_device *ddev;
+
+	ddev = to_dal_device(dev);
+	mutex_lock(&ddev->context_lock);
+	dal_dc_destroy(ddev, DAL_INTF_KDI);
+	mutex_unlock(&ddev->context_lock);
 }
 
+static struct class_interface kdi_interface __refdata = {
+	.add_dev        = kdi_add_dev,
+	.remove_dev     = kdi_rm_dev,
+};
+
 static int kdi_create_session(u64 *handle, const char *jta_id,
 			      const u8 *buffer, size_t buffer_length,
 			      const u8 *init_param, size_t init_param_length)
@@ -158,75 +182,9 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 	return bh_err_to_kdi_err(bh_err);
 }
 
-static bool kdi_is_mei_ready(void)
-{
-	struct device *dev;
-	int i;
-
-	/* TODO: don't use loop here there is
-	 * already an iterator  over class list
-	 */
-	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
-		dev = dal_find_dev(i);
-		if (!dev || !dev->parent)
-			return false;
-
-		put_device(dev);
-	}
-
-	return true;
-}
-
-static int kdi_create_kernel_clients(void)
+static inline bool kdi_check_handle(u64 handle)
 {
-	struct device *dev;
-	struct dal_device *ddev;
-	int i;
-	int ret;
-
-	/* FIXME: use an iterrator */
-	/* Check that all the device are init */
-	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
-		dev = dal_find_dev(i);
-		if (!dev || !dev->parent) {
-			pr_err("device=%d is NULL\n", i);
-			return -EFAULT;
-		}
-		ddev = to_dal_device(dev);
-		ret = dal_dc_setup(ddev, DAL_INTF_KDI);
-		put_device(dev);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static bool kdi_is_init_done(void)
-{
-	return (atomic_read(&kdi_ref_count) >= 1);
-}
-
-/* FIMXE: not sure this is needed at all
- * this will be destroyed using class release function
- */
-
-static void kdi_destroy_kernel_clients(void)
-{
-	struct device *dev;
-	struct dal_device *ddev;
-	int i;
-
-	/* use iterator */
-	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
-		dev = dal_find_dev(i);
-		if (!dev || !dev->parent)
-			continue;
-		/* TODO: just call destroy kdic ...  */
-		ddev = to_dal_device(dev);
-		dal_dc_destroy(ddev, DAL_INTF_KDI);
-		put_device(dev);
-	}
+	return (handle == (u64)dal_class);
 }
 
 int kdi_init(u32 flags, u64 *handle)
@@ -236,37 +194,25 @@ int kdi_init(u32 flags, u64 *handle)
 	if (!handle)
 		return DAL_KDI_STATUS_INVALID_PARAMS;
 
-	/* Check that all the device are ready */
-	if (!kdi_is_mei_ready()) {
-		pr_err("dal_init(): mei devices was not initialized\n");
-		ret = DAL_KDI_STATUS_NOT_READY;
-		*handle = DAL_KDI_INVALID_HANDLE;
-		goto end;
-	}
+	if (atomic_inc_return(&kdi_ref_count) > 1)
+		goto out;
 
-	ret = DAL_KDI_SUCCESS;
-	if (atomic_inc_return(&kdi_ref_count) == 1) {
-		mutex_init(&kdi_lock);
-		pr_debug("ref count == 1, performing init\n");
-		if (kdi_create_kernel_clients() < 0) {
-			kdi_destroy_kernel_clients();
-			atomic_dec(&kdi_ref_count);
-			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
-			*handle = DAL_KDI_INVALID_HANDLE;
-			goto end;
-		}
-
-		bh_err = bhp_init_internal(NULL);
-		if (bh_err) {
-			pr_err("BHP_Init failed with status = %d\n", bh_err);
-			ret = bh_err_to_kdi_err(bh_err);
-			*handle = DAL_KDI_INVALID_HANDLE;
-		}
+	kdi_interface.class = dal_class;
+	ret = class_interface_register(&kdi_interface);
+	if (ret)
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+
+	bh_err = bhp_init_internal(NULL);
+	ret = bh_err_to_kdi_err(bh_err);
+	if (bh_err) {
+		class_interface_unregister(&kdi_interface);
+		pr_err("BHP_Init failed with status = %d\n", bh_err);
+		return ret;
 	}
+out:
 
 	*handle = (u64)dal_class;
-end:
-	return ret;
+	return DAL_KDI_SUCCESS;
 }
 EXPORT_SYMBOL(kdi_init);
 
@@ -274,24 +220,17 @@ int kdi_deinit(u64 handle)
 {
 	int ret, bh_err;
 
-	/* TODO: add a kernel cleanup code to module deinit possible flow:
-	 * one kernel module invokes init and a different one invokes deinit
-	 */
-
 	/* check handle first */
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
 	ret = DAL_KDI_SUCCESS;
-	if (atomic_dec_and_test(&kdi_ref_count)) {
+	if (atomic_dec_if_positive(&kdi_ref_count) == 0) {
+		class_interface_unregister(&kdi_interface);
 		bh_err = bhp_deinit_internal();
+		ret = bh_err_to_kdi_err(bh_err);
 		if (bh_err)
 			pr_warn("bhp_deinit_internal failed: = %d\n", bh_err);
-
-		ret = bh_err_to_kdi_err(ret);
-
-		mutex_destroy(&kdi_lock);
-		kdi_destroy_kernel_clients();
 	}
 
 	return ret;
@@ -308,7 +247,7 @@ int dal_create_session(u64 handle,
 {
 	int ret;
 
-	if (!kdi_is_init_done())
+	if (atomic_read(&kdi_ref_count) == 0)
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
 
 	if (!kdi_check_handle(handle))
@@ -339,7 +278,7 @@ int dal_send_and_receive(u64 handle,
 {
 	int ret, bh_err;
 
-	if (!kdi_is_init_done())
+	if (atomic_read(&kdi_ref_count) == 0)
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
 
 	if (!kdi_check_handle(handle))
@@ -365,7 +304,7 @@ int dal_close_session(u64 handle, u64 session_handle)
 {
 	int ret, bh_err;
 
-	if (!kdi_is_init_done())
+	if (atomic_read(&kdi_ref_count) == 0)
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
 
 	if (!kdi_check_handle(handle))
-- 
1.7.5.4

