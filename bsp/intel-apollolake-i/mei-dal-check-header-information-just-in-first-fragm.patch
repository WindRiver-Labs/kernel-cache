From c79d59ef9c0d3c5ba40a655403d327b8c215b2ec Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Sun, 27 Nov 2016 12:10:48 +0200
Subject: [PATCH 4645/4706] mei: dal: check header information just in first
 fragment

commit 117b27a368d797085dc882824f362b4dea7af6af from
git://git.yoctoproject.org/linux-yocto-4.1

check if msg is hdr just on the first fragment.
otherwise you may look at 4 bytes of msg which is 2 or 3 bytes length.

Change-Id: I8bd2ec997593ef81ed5b5e0bad8457a6a4fec52b
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/bhp_impl.h    |   19 ++++++----
 drivers/misc/mei/dal/bhp_impl_ta.c |   68 +++++++----------------------------
 drivers/misc/mei/dal/dal_class.c   |   63 ++++++++++++++-------------------
 3 files changed, 52 insertions(+), 98 deletions(-)

diff --git a/drivers/misc/mei/dal/bhp_impl.h b/drivers/misc/mei/dal/bhp_impl.h
index c92e2e8..3d2d13a 100644
--- a/drivers/misc/mei/dal/bhp_impl.h
+++ b/drivers/misc/mei/dal/bhp_impl.h
@@ -174,26 +174,29 @@ int bh_do_open_vm(uuid_be sdid, int *conn_idx, int mode);
 /* decrease vm connection counter by 1 */
 int bh_do_close_vm(int conn_idx);
 
-/* return error when invalid msg */
-typedef int (*bh_filter_func)(const char *msg, size_t count, void *ctx);
-int bh_filter_msg(const char *msg, size_t count, void *ctx,
+/* returns hdr if msg is cmd hdr, otherwise returns NULL */
+const struct bhp_command_header *bh_msg_cmd_hdr(const void *msg, size_t len);
+
+/* return error when invalid hdr */
+typedef int (*bh_filter_func)(const struct bhp_command_header *hdr,
+			      size_t count, void *ctx);
+int bh_filter_hdr(const struct bhp_command_header *hdr, size_t count, void *ctx,
 		  const bh_filter_func tbl[]);
 /* true when msg it is open sessio cmd */
-bool bh_msg_is_cmd_open_session(const char *msg);
+bool bh_msg_is_cmd_open_session(const struct bhp_command_header *hdr);
 
 /* retrives ta_id from the open session */
-const uuid_be *bh_open_session_ta_id(const char *hdr, size_t count);
+const uuid_be *bh_open_session_ta_id(const struct bhp_command_header *hdr,
+				     size_t count);
 
 /* prepare and return response of access denied error */
 void bh_prep_access_denied_response(const char *cmd,
 				    struct bhp_response_header *res);
 
-/* true when sequence is in kernel space seq range */
-bool bh_is_kdi_hdr(const char *msg);
+bool bh_msg_is_cmd(const char *msg, size_t len);
 
 bool bh_msg_is_response(const char *hdr);
 bool bh_msg_is_spooler(const char *hdr);
-bool bh_msg_is_cmd(const char *hdr);
 
 #define mutex_enter(s) {}
 #define mutex_exit(s)  {}
diff --git a/drivers/misc/mei/dal/bhp_impl_ta.c b/drivers/misc/mei/dal/bhp_impl_ta.c
index 801abd4..f2a88cf 100644
--- a/drivers/misc/mei/dal/bhp_impl_ta.c
+++ b/drivers/misc/mei/dal/bhp_impl_ta.c
@@ -130,54 +130,37 @@ bool bh_msg_is_spooler(const char *hdr)
 }
 
 /* Check for command msg */
-bool bh_msg_is_cmd(const char *hdr)
+bool bh_msg_is_cmd(const char *msg, size_t len)
 {
-	return !memcmp(hdr, BH_MSG_CMD_MAGIC, sizeof(BH_MSG_CMD_MAGIC));
+	return (len >= sizeof(struct bhp_command_header)) &&
+		!memcmp(msg, BH_MSG_CMD_MAGIC, sizeof(BH_MSG_CMD_MAGIC));
 }
 
-static bool bh_cmd_is_valid(struct bhp_command_header *hdr, size_t len)
+const struct bhp_command_header *bh_msg_cmd_hdr(const void *msg, size_t len)
 {
-	return (len >= sizeof(struct bhp_command_header));
-}
-
-static const
-struct bhp_command_header *bh_msg_cmd_hdr(const char *msg, size_t len)
-{
-	struct bhp_command_header *hdr;
-
-	if (!bh_msg_is_cmd(msg))
+	/* check that len is valid before checking the hdr MAGIC,
+	in case that len is smaller than the MAGIC size */
+	if (!bh_msg_is_cmd(msg, len))
 		return NULL;
 
-	hdr = (struct bhp_command_header *)msg;
-
-	if (!bh_cmd_is_valid(hdr, len))
-		return NULL;
-
-	return hdr;
+	return msg;
 }
 
-bool bh_msg_is_cmd_open_session(const char *msg)
+bool bh_msg_is_cmd_open_session(const struct bhp_command_header *hdr)
 {
-	struct bhp_command_header *hdr;
-
-	if (!bh_msg_is_cmd(msg))
-		return 0;
-
-	hdr = (struct bhp_command_header *)msg;
 	return hdr->id == BHP_CMD_OPEN_JTASESSION;
 }
 
-const uuid_be *bh_open_session_ta_id(const char *hdr, size_t count)
+const uuid_be *bh_open_session_ta_id(const struct bhp_command_header *hdr,
+				     size_t count)
 {
-	struct bhp_command_header *cmd_hdr;
 	struct bhp_open_jtasession_cmd *open_cmd;
 
 	if (count < sizeof(struct bhp_command_header) +
 		sizeof(struct bhp_open_jtasession_cmd))
 		return NULL;
 
-	cmd_hdr = (struct bhp_command_header *)hdr;
-	open_cmd = (struct bhp_open_jtasession_cmd *)cmd_hdr->cmd;
+	open_cmd = (struct bhp_open_jtasession_cmd *)hdr->cmd;
 
 	return &open_cmd->appid;
 }
@@ -672,25 +655,14 @@ int bhp_close_ta_session(const u64 handle)
 	return ret;
 }
 
-int bh_filter_msg(const char *msg, size_t count, void *ctx,
+int bh_filter_hdr(const struct bhp_command_header *hdr, size_t count, void *ctx,
 		  const bh_filter_func tbl[])
 {
 	int i;
 	int ret;
-	const struct bhp_command_header *hdr;
-
-	if (count < BHP_MSG_MAGIC_LENGTH)
-		return -EINVAL;
-
-	if (!bh_msg_is_cmd(msg))
-		return 0;
-
-	hdr = bh_msg_cmd_hdr(msg, count);
-	if (!hdr)
-		return -EINVAL;
 
 	for (i = 0; tbl[i]; i++) {
-		ret = tbl[i](msg, count, ctx);
+		ret = tbl[i](hdr, count, ctx);
 		if (ret < 0)
 			return ret;
 	}
@@ -707,15 +679,3 @@ void bh_prep_access_denied_response(const char *cmd,
 	res->code = BHE_OPERATION_NOT_PERMITTED;
 	res->seq = cmd_hdr->seq;
 }
-
-bool bh_is_kdi_hdr(const char *msg)
-{
-	const struct bhp_command_header *cmd_hdr;
-
-	if (!bh_msg_is_cmd(msg))
-		return 0;
-
-	cmd_hdr = (const struct bhp_command_header *)msg;
-
-	return cmd_hdr->seq >= MSG_SEQ_START_NUMBER;
-}
diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index c46af6c..460c5bb 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -187,27 +187,34 @@ static int dal_send_error_access_denied(struct dal_client *dc)
 	return 0;
 }
 
-static int dal_validate_access(const char *msg, size_t count, void *ctx)
+static int dal_validate_access(const struct bhp_command_header *hdr,
+			       size_t count, void *ctx)
 {
 	struct dal_client *dc = ctx;
 	struct dal_device *ddev = dc->ddev;
 	const uuid_be *ta_id;
 
-	if (!bh_msg_is_cmd_open_session(msg))
+	if (!bh_msg_is_cmd_open_session(hdr))
 		return 0;
 
-	ta_id = bh_open_session_ta_id(msg, count);
+	ta_id = bh_open_session_ta_id(hdr, count);
 	if (!ta_id)
 		return -EINVAL;
 
 	return dal_access_policy_allowed(ddev, *ta_id, dc);
 }
 
-static int dal_validate_seq(const char *msg, size_t count, void *ctx)
+static bool bh_is_kdi_hdr(const struct bhp_command_header *hdr)
+{
+	return hdr->seq >= MSG_SEQ_START_NUMBER;
+}
+
+static int dal_validate_seq(const struct bhp_command_header *hdr,
+			    size_t count, void *ctx)
 {
 	struct dal_client *dc = ctx;
 
-	if (dc->intf != DAL_INTF_KDI && bh_is_kdi_hdr(msg))
+	if (dc->intf != DAL_INTF_KDI && bh_is_kdi_hdr(hdr))
 		return -EPERM;
 
 	return 0;
@@ -223,7 +230,6 @@ static const bh_filter_func dal_write_filter_tbl[] = {
 ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 {
 	struct dal_device *ddev = dc->ddev;
-	struct bhp_command_header *header;
 	struct device *dev;
 	ssize_t wr;
 	ssize_t ret;
@@ -247,7 +253,15 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	/* put dc in write queue*/
 	if (ddev->current_write_client != dc) {
 		/* adding client to write queue - this is the first fragment */
-		ret = bh_filter_msg(dc->write_buffer, count, dc, dal_write_filter_tbl);
+		const struct bhp_command_header *hdr;
+
+		hdr = bh_msg_cmd_hdr(dc->write_buffer, count);
+		if (!hdr) {
+			mutex_unlock(&ddev->write_queue_lock);
+			return -EINVAL;
+		}
+
+		ret = bh_filter_hdr(hdr, count, dc, dal_write_filter_tbl);
 		if (ret == -EPERM) {
 			ret = dal_send_error_access_denied(dc);
 			ret = ret ?: count;
@@ -257,6 +271,11 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 			return ret;
 		}
 
+		dc->bytes_sent_to_fw = 0;
+		dc->expected_msg_size_to_fw = hdr->h.length;
+		dev_dbg(dev, "This is first fragment - client type %d, cmd id = %d",
+				intf, hdr->id);
+
 		if (kfifo_is_empty(&ddev->write_queue))
 			ddev->current_write_client = dc;
 
@@ -308,37 +327,9 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 
 	/* update client byte sent */
 	dc->bytes_sent_to_fw += count;
-
-	/* get msg header */
-	header = (struct bhp_command_header *)dc->write_buffer;
-
-	/*
-	 * if this the spooler open session then don't do anything else,
-	 * as the response from the FW is async and may never occur
-	 */
-	/* TODO: we can remove this check and look only on the size */
-	if (bh_msg_is_spooler(dc->write_buffer)) {
-		ret = wr;
-		dev_dbg(dev, "SPOOLER msg command id = %d", header->id);
-		goto out;
-	}
-
 	ret = wr;
-	/* header msg is being sent,
-	 * this is the first fragment of the message
-	 */
-	if (bh_msg_is_cmd(dc->write_buffer)) {
-		dc->expected_msg_size_to_fw = header->h.length;
-		dev_dbg(dev, "This is first fragment - client type %d",
-				intf);
-		dev_dbg(dev, "command id = %d", header->id);
-
-		dc->bytes_sent_to_fw = count;
-		/* if there's extra data, mark it */
-		if (dc->expected_msg_size_to_fw > count)
-			goto write_more;
 
-	} else if (dc->bytes_sent_to_fw != dc->expected_msg_size_to_fw) {
+	if (dc->bytes_sent_to_fw != dc->expected_msg_size_to_fw) {
 		dev_dbg(dev, "expecting to write more data to FW - client type %d",
 				intf);
 		goto write_more;
-- 
1.7.5.4

