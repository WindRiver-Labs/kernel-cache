From b73bc0cea43270cab991c5928ab3bc38f96e46aa Mon Sep 17 00:00:00 2001
From: Bob Paauwe <bob.j.paauwe@intel.com>
Date: Fri, 22 Apr 2016 16:43:27 -0700
Subject: [PATCH 1430/2508] drm/i915/splash: Allow connectors to share splash
 screen image data.

commit 42ce302879766edd65e9458b75e85c3527e0740d from
https://github.com/01org/linux-apollolake-i

If multiple connectors are using the same splash screen image data file,
only request_firmware for the first instance and only allocate one
framebuffer.  All connectors using the same image data file will share
the framebuffer.

Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: James Xiong <james.xiong@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_drv.h              |    1 +
 drivers/gpu/drm/i915/intel_initial_modeset.c |  163 +++++++++++++++++---------
 2 files changed, 110 insertions(+), 54 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 2143ff5..1b1f68d 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1036,6 +1036,7 @@ struct splash_screen_info {
 	const struct firmware *fw;
 	struct drm_i915_gem_object *obj;
 	char *connector_name;
+	char *image_name;
 	int width;
 	int height;
 	int pitch;
diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
index 2080b67..2a852be 100644
--- a/drivers/gpu/drm/i915/intel_initial_modeset.c
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -152,7 +152,36 @@ intel_splash_screen_fb(struct drm_device *dev,
 	return fb;
 }
 
-static bool intel_splash_screen_init(struct drm_device *dev)
+static bool shared_image(struct drm_i915_private *dev_priv,
+			 char *image,
+			 struct splash_screen_info *info)
+{
+	struct splash_screen_info *splash_info;
+
+	list_for_each_entry(splash_info, &dev_priv->splash_list, link) {
+		if (strcmp(splash_info->image_name, image) == 0) {
+			info->image_name = NULL;
+			info->fw = NULL;
+			info->obj = splash_info->obj;
+			return true;
+		}
+	}
+	return false;
+}
+
+static struct splash_screen_info *match_splash_info(
+					struct drm_i915_private *dev_priv,
+					char* name)
+{
+	struct splash_screen_info *splash_info, *info = NULL;
+	list_for_each_entry(splash_info, &dev_priv->splash_list, link) {
+		if (strcmp(splash_info->connector_name, name) == 0)
+			info = splash_info;
+	}
+	return info;
+}
+
+static void intel_splash_screen_init(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct splash_screen_info *splash_info;
@@ -164,12 +193,20 @@ static bool intel_splash_screen_init(struct drm_device *dev)
 	INIT_LIST_HEAD(&dev_priv->splash_list);
 
 	if (splash[0] == '\0')
-		return false;
+		return;
 
 	splash_dup = kstrdup(splash, GFP_KERNEL);
 	splash_str = splash_dup;
 
-	/* Pull connector names and splash optionsfrom string */
+	/*
+	 * The loop condition find the connector name portion of the
+	 * string.  Once we have that, we parse the following fields
+	 * from the string:
+	 *  Image data file name, image data width, image data height,
+	 *  crtc rectangle (x, y, w, h).
+	 * Then the loop condition will execute again to get the next
+	 * connector name.
+	 */
 	while ((sep = strchr(splash_str, ':'))) {
 		splash_info = kzalloc(sizeof(struct splash_screen_info),
 				      GFP_KERNEL);
@@ -180,16 +217,25 @@ static bool intel_splash_screen_init(struct drm_device *dev)
 		splash_info->connector_name = kstrdup(splash_str, GFP_KERNEL);
 		splash_str = sep + 1;
 
-		/* Pull firmware file name from string */
+		/*
+		 * Pull firmware file name from string and check to see
+		 * if this image has been previously loaded.  request
+		 * firmware only needs to be called once for each file.
+		 */
 		sep = strchr(splash_str, ':');
 		if (sep == NULL)
 			goto fail;
 
 		*sep = '\0';
-		request_firmware(&splash_info->fw, splash_str,
-				 &dev_priv->dev->pdev->dev);
-		if (splash_info->fw == NULL)
-			goto fail;
+
+		if (!shared_image(dev_priv, splash_str, splash_info)) {
+			splash_info->image_name = kstrdup(splash_str,
+							  GFP_KERNEL);
+			request_firmware(&splash_info->fw, splash_str,
+					 &dev_priv->dev->pdev->dev);
+			if (splash_info->fw == NULL)
+				goto fail;
+		}
 		splash_str = sep + 1;
 
 		/* Pull splash screen width, height, crtc */
@@ -202,20 +248,24 @@ static bool intel_splash_screen_init(struct drm_device *dev)
 					&splash_info->crtc_w,
 					&splash_info->crtc_h);
 
-		/*
-		 * If splash image is baked into the kernel, we just get
-		 * a pointer.  Otherwise we'll get a list of pages.
-		 */
-		fw_npages = DIV_ROUND_UP_ULL(splash_info->fw->size, PAGE_SIZE);
-		if (splash_info->fw->pages == NULL)
-			splash_info->obj = i915_gem_object_create_splash(
+		/* Only do this we haven't mapped this firmware image before */
+		if (splash_info->fw) {
+			/*
+			 * If splash image is baked into the kernel, we just get
+			 * a pointer.  Otherwise we'll get a list of pages.
+			 */
+			fw_npages = DIV_ROUND_UP_ULL(splash_info->fw->size,
+						     PAGE_SIZE);
+			if (splash_info->fw->pages == NULL)
+				splash_info->obj = i915_gem_object_create_splash(
 					dev,
 					splash_info->fw->data,
 					fw_npages);
-		else
-			splash_info->obj = i915_gem_object_create_splash_pages(
+			else
+				splash_info->obj = i915_gem_object_create_splash_pages(
 					dev,
 					splash_info->fw->pages, fw_npages);
+		}
 
 		list_add_tail(&splash_info->link, &dev_priv->splash_list);
 
@@ -228,19 +278,18 @@ static bool intel_splash_screen_init(struct drm_device *dev)
 	}
 
 	kfree(splash_dup);
-
-	return true;
+	return;
 
 fail:
 	/* Clean up failed entry data */
 	release_firmware(splash_info->fw);
 	kfree(splash_info->connector_name);
+	kfree(splash_info->image_name);
 	kfree(splash_info);
 	kfree(splash_dup);
-	return true;
+	return;
 }
 
-
 static struct drm_display_mode *get_modeline(struct drm_i915_private *dev_priv,
 					     struct drm_connector *connector,
 					     int width, int height)
@@ -377,17 +426,37 @@ static int update_primary_plane_state(struct drm_atomic_state *state,
 	return 0;
 }
 
+static void create_splash_fb(struct drm_device *dev,
+				struct splash_screen_info *splash)
+{
+	struct splash_screen_info *splash_info;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	if (splash->fw) {
+		splash->fb = intel_splash_screen_fb(dev, splash);
+		if (IS_ERR(splash->fb))
+			splash->fb = NULL;
+	}
+
+	if (splash->fb)
+		list_for_each_entry(splash_info, &dev_priv->splash_list, link)
+			if (splash->obj == splash_info->obj &&
+			    splash != splash_info) {
+				splash_info->fb = splash->fb;
+				drm_framebuffer_reference(splash_info->fb);
+			}
+}
+
 static int update_atomic_state(struct drm_device *dev,
 			       struct drm_atomic_state *state,
-			       struct splash_screen_info *splash_info,
 			       struct drm_connector *connector,
 			       struct drm_encoder *encoder)
-
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_display_mode *mode;
 	struct drm_crtc *crtc = encoder->crtc;
 	int ret;
+	struct splash_screen_info *splash_info;
 
 	mode = get_modeline(dev_priv, connector,
 			    dev->mode_config.max_width,
@@ -405,11 +474,17 @@ static int update_atomic_state(struct drm_device *dev,
 		return ret;
 
 	/* set up primary plane if a splash screen is requested */
-	if (splash_info && splash_info->fb) {
-		ret = update_primary_plane_state(state, splash_info,
-						 crtc, mode);
-		if (ret)
-			return ret;
+	splash_info = match_splash_info(dev_priv, connector->name);
+	if (splash_info) {
+		if (splash_info->fb == NULL)
+			create_splash_fb(dev, splash_info);
+		if (splash_info->fb) {
+			ret = update_primary_plane_state(state,
+							 splash_info,
+							 crtc, mode);
+			if (ret)
+				return ret;
+		}
 	}
 	return 0;
 }
@@ -460,7 +535,6 @@ static void modeset_config_fn(struct work_struct *work)
 	struct drm_modeset_acquire_ctx ctx;
 	struct drm_plane *plane;
 	int ret;
-	struct splash_screen_info *splash_info, *info;
 	bool found = false;
 	unsigned long long start = sched_clock();
 
@@ -472,14 +546,7 @@ static void modeset_config_fn(struct work_struct *work)
 	state->acquire_ctx = &ctx;
 	drm_modeset_lock_all_ctx(dev, &ctx);
 
-	if (intel_splash_screen_init(dev)) {
-		list_for_each_entry(splash_info, &dev_priv->splash_list, link) {
-			splash_info->fb = intel_splash_screen_fb(dev,
-								 splash_info);
-			if (IS_ERR(splash_info->fb);
-			    splash_info->fb = NULL;
-		}
-	}
+	intel_splash_screen_init(dev);
 
 retry:
 	ret = disable_planes(dev, state);
@@ -494,18 +561,11 @@ retry:
 	drm_for_each_connector(connector, dev) {
 		struct drm_encoder *encoder;
 
-		info = NULL;
 		if (use_connector(connector)) {
 			if (!(encoder = get_encoder(dev, connector)))
 				continue;
 
-			list_for_each_entry(splash_info,
-					    &dev_priv->splash_list, link) {
-				if (strcmp(splash_info->connector_name,
-					   connector->name) == 0)
-					info = splash_info;
-			}
-			ret = update_atomic_state(dev, state, info,
+			ret = update_atomic_state(dev, state,
 					    connector, encoder);
 			if (ret)
 				goto fail;
@@ -518,21 +578,13 @@ retry:
 		drm_for_each_connector(connector, dev) {
 			struct drm_encoder *encoder;
 
-			info = NULL;
 			connector->status = connector->funcs->detect(connector,
 								     true);
 			if (connector->status == connector_status_connected) {
 				if (!(encoder = get_encoder(dev, connector)))
 					continue;
 
-				list_for_each_entry(splash_info,
-						    &dev_priv->splash_list,
-						    link) {
-					if (strcmp(splash_info->connector_name,
-						   connector->name) == 0)
-						info = splash_info;
-				}
-				ret = update_atomic_state(dev, state, info,
+				ret = update_atomic_state(dev, state,
 							  connector, encoder);
 				if (ret)
 					goto fail;
@@ -634,8 +686,11 @@ void intel_initial_mode_config_fini(struct drm_device *dev)
 
 	list_for_each_entry_safe(splash_info, tmp,
 				 &dev_priv->splash_list, link) {
+		if (splash_info->fb)
+			drm_framebuffer_unreference(splash_info->fb);
 		release_firmware(splash_info->fw);
 		kfree(splash_info->connector_name);
+		kfree(splash_info->image_name);
 		kfree(splash_info);
 	}
 }
-- 
1.7.5.4

