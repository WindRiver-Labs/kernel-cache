From b8d20a5cfb40692246a9531c3a35d54f11613171 Mon Sep 17 00:00:00 2001
From: Bob Paauwe <bob.j.paauwe@intel.com>
Date: Wed, 9 Dec 2015 16:19:30 -0800
Subject: [PATCH 1246/2508] drm/i915: Add driver profiling to help
 initialization tuning. (v2)

commit d6b53cf6574542ddbb21c50822d7e61d70dfb8a3 from
https://github.com/01org/linux-apollolake-i

Add ability to get some "lite" profiling information about the
the driver load process. Add a debugfs entry that reports the time
taken by various driver activities; the driver load, the framebuffer
device initialization, the GUC firmware load and the csr firmware load.

The GUC firmware load is currently a serial in-line process so this
time is also included in the overall driver load time.

If the file is queried before all the asynchrous processes complete,
their values will be reported as 0.

v2: Added csr firmware load profile (Matt)
    Moved guc firmware load tracking closer to actual load function (Bob)

Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c     |   20 ++++++++++++++++++++
 drivers/gpu/drm/i915/i915_dma.c         |    5 +++++
 drivers/gpu/drm/i915/i915_drv.h         |    8 ++++++++
 drivers/gpu/drm/i915/intel_csr.c        |    2 ++
 drivers/gpu/drm/i915/intel_fbdev.c      |    5 +++++
 drivers/gpu/drm/i915/intel_guc_loader.c |    3 +++
 6 files changed, 43 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index d02f8ce..94add4c 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -2389,6 +2389,25 @@ static int i915_rps_boost_info(struct seq_file *m, void *data)
 	return 0;
 }
 
+static int i915_timing_info(struct seq_file *m, void *data)
+{
+	struct drm_info_node *node = m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	seq_printf(m, "Timing info\n");
+	seq_printf(m, "  Driver load time: %lldms\n",
+		   (dev_priv->profile.driver_load / 1000000));
+	seq_printf(m, "  Frambuffer device load time: %lldms\n",
+		   (dev_priv->profile.fbdev_load / 1000000));
+	seq_printf(m, "  GUC firmware load time: %lldms\n",
+		   (dev_priv->profile.guc_load / 1000000));
+	seq_printf(m, "  CSR firmware load time: %lldms\n",
+		   (dev_priv->profile.csr_load / 1000000));
+
+	return 0;
+}
+
 static int i915_llc(struct seq_file *m, void *data)
 {
 	struct drm_info_node *node = m->private;
@@ -5394,6 +5413,7 @@ static const struct drm_info_list i915_debugfs_list[] = {
 	{"i915_sseu_status", i915_sseu_status, 0},
 	{"i915_drrs_status", i915_drrs_status, 0},
 	{"i915_rps_boost_info", i915_rps_boost_info, 0},
+	{"i915_timing_info", i915_timing_info, 0},
 };
 #define I915_DEBUGFS_ENTRIES ARRAY_SIZE(i915_debugfs_list)
 
diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index 210e666..4d5a7a4 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -1337,6 +1337,9 @@ int i915_driver_load(struct drm_device *dev, unsigned long flags)
 {
 	struct drm_i915_private *dev_priv;
 	int ret = 0;
+	unsigned long long start_tm;
+
+	start_tm = sched_clock();
 
 	dev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);
 	if (dev_priv == NULL)
@@ -1383,6 +1386,8 @@ int i915_driver_load(struct drm_device *dev, unsigned long flags)
 
 	intel_runtime_pm_put(dev_priv);
 
+	dev_priv->profile.driver_load = sched_clock() - start_tm;
+
 	printk(KERN_INFO "IOTG i915 forklift 2016-03-25\n");
 
 	return 0;
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 9978239..7227929 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1635,6 +1635,13 @@ struct intel_pipe_crc {
 	wait_queue_head_t wq;
 };
 
+struct intel_load_profiles {
+	unsigned long long driver_load;
+	unsigned long long fbdev_load;
+	unsigned long long guc_load;
+	unsigned long long csr_load;
+};
+
 struct i915_frontbuffer_tracking {
 	struct mutex lock;
 
@@ -1831,6 +1838,7 @@ struct drm_i915_private {
 #ifdef CONFIG_DEBUG_FS
 	struct intel_pipe_crc pipe_crc[I915_MAX_PIPES];
 #endif
+	struct intel_load_profiles profile;
 
 	/* dpll and cdclk state is protected by connection_mutex */
 	int num_shared_dpll;
diff --git a/drivers/gpu/drm/i915/intel_csr.c b/drivers/gpu/drm/i915/intel_csr.c
index 3f57cb9..085b58b 100644
--- a/drivers/gpu/drm/i915/intel_csr.c
+++ b/drivers/gpu/drm/i915/intel_csr.c
@@ -392,6 +392,7 @@ static void csr_load_work_fn(struct work_struct *work)
 	struct intel_csr *csr;
 	const struct firmware *fw;
 	int ret;
+	unsigned long long start = sched_clock();
 
 	dev_priv = container_of(work, typeof(*dev_priv), csr.work);
 	csr = &dev_priv->csr;
@@ -418,6 +419,7 @@ static void csr_load_work_fn(struct work_struct *work)
 	}
 
 	release_firmware(fw);
+	dev_priv->profile.csr_load = sched_clock() - start;
 }
 
 /**
diff --git a/drivers/gpu/drm/i915/intel_fbdev.c b/drivers/gpu/drm/i915/intel_fbdev.c
index 5e0dcb3..2d28a84 100644
--- a/drivers/gpu/drm/i915/intel_fbdev.c
+++ b/drivers/gpu/drm/i915/intel_fbdev.c
@@ -729,11 +729,16 @@ static void intel_fbdev_initial_config(void *data, async_cookie_t cookie)
 {
 	struct drm_i915_private *dev_priv = data;
 	struct intel_fbdev *ifbdev = dev_priv->fbdev;
+	unsigned long long start_tm;
+
+	start_tm = sched_clock();
 
 	/* Due to peculiar init order wrt to hpd handling this is separate. */
 	if (drm_fb_helper_initial_config(&ifbdev->helper,
 					 ifbdev->preferred_bpp))
 		intel_fbdev_fini(dev_priv->dev);
+
+	dev_priv->profile.fbdev_load = sched_clock() - start_tm;
 }
 
 void intel_fbdev_initial_config_async(struct drm_device *dev)
diff --git a/drivers/gpu/drm/i915/intel_guc_loader.c b/drivers/gpu/drm/i915/intel_guc_loader.c
index b4976f9..fe2f558 100644
--- a/drivers/gpu/drm/i915/intel_guc_loader.c
+++ b/drivers/gpu/drm/i915/intel_guc_loader.c
@@ -587,6 +587,7 @@ void intel_guc_ucode_init(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_guc_fw *guc_fw = &dev_priv->guc.guc_fw;
 	const char *fw_path;
+	unsigned long long start;
 
 	if (!HAS_GUC_SCHED(dev))
 		i915.enable_guc_submission = false;
@@ -619,10 +620,12 @@ void intel_guc_ucode_init(struct drm_device *dev)
 		return;
 	}
 
+	start = sched_clock();
 	guc_fw->guc_fw_fetch_status = GUC_FIRMWARE_PENDING;
 	DRM_DEBUG_DRIVER("GuC firmware pending, path %s\n", fw_path);
 	guc_fw_fetch(dev, guc_fw);
 	/* status must now be FAIL or SUCCESS */
+	dev_priv->profile.guc_load = sched_clock() - start;
 }
 
 /**
-- 
1.7.5.4

