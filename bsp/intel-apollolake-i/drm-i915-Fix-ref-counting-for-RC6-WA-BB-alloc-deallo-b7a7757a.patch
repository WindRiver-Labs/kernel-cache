From 6c54b6a2d352fe3180f4ac90ce93287678ec4eb3 Mon Sep 17 00:00:00 2001
From: Andrzej Datczuk <andrzej.datczuk@intel.com>
Date: Wed, 22 Jun 2016 13:51:50 +0200
Subject: [PATCH 4467/4706] drm/i915: Fix ref counting for RC6 WA BB
 alloc/dealloc

commit 0314925edb913c4dbe1a395c472667927237d26f from
git://git.yoctoproject.org/linux-yocto-4.1

This patch fixes incorrect states of RC6 WA BB allocation reference
counter which resulted in RC6 WA BB deallocation when there was stil
one client attached.

This change should eliminate error message 'RC6 WA BB not ready'
showing in logs from i915 kernel.

drm_gem_object_unreference changed to a locked version because
dev->struct_mutex is already grabbed there. The unlocked version
was trying to grab this mutex again when trying to free the gem object.

Signed-off-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_perfmon.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_perfmon.c b/drivers/gpu/drm/i915/i915_perfmon.c
index 33a9480..904d484 100644
--- a/drivers/gpu/drm/i915/i915_perfmon.c
+++ b/drivers/gpu/drm/i915/i915_perfmon.c
@@ -586,7 +586,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 				       PAGE_SIZE, PIN_MAPPABLE);
 	if (ret) {
 		ret = PTR_ERR(vma);
-		i915_gem_object_put_unlocked(dev_priv->rc6_wa_bb.obj);
+		i915_gem_object_put(dev_priv->rc6_wa_bb.obj);
 		goto unlock;
 	}
 	dev_priv->rc6_wa_bb.vma = vma;
@@ -595,7 +595,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 						true);
 	if (ret) {
 		i915_vma_unpin(vma);
-		i915_gem_object_put_unlocked(dev_priv->rc6_wa_bb.obj);
+		i915_gem_object_put(dev_priv->rc6_wa_bb.obj);
 		goto unlock;
 	}
 
@@ -607,7 +607,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 
 	if (!dev_priv->rc6_wa_bb.address) {
 		i915_vma_unpin(vma);
-		i915_gem_object_put_unlocked(dev_priv->rc6_wa_bb.obj);
+		i915_gem_object_put(dev_priv->rc6_wa_bb.obj);
 		ret =  -ENOMEM;
 		goto unlock;
 	}
@@ -620,6 +620,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 
 unlock:
 	if (ret) {
+		atomic_dec(&dev_priv->rc6_wa_bb.enable);
 		dev_priv->rc6_wa_bb.obj = NULL;
 		dev_priv->rc6_wa_bb.vma = NULL;
 		dev_priv->rc6_wa_bb.offset = 0;
@@ -638,7 +639,7 @@ static void deallocate_wa_bb(struct drm_i915_private *dev_priv)
 	if (atomic_read(&dev_priv->rc6_wa_bb.enable) == 0)
 		goto unlock;
 
-	if (atomic_dec_return(&dev_priv->rc6_wa_bb.enable) > 1)
+	if (atomic_dec_return(&dev_priv->rc6_wa_bb.enable) > 0)
 		goto unlock;
 
 	I915_WRITE(GEN8_RC6_WA_BB, 0);
-- 
1.7.5.4

