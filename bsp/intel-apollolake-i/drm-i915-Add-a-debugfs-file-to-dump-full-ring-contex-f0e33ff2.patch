From a2d62a93aedbfe1f0ce5b5eaf2b74927c59fb9a9 Mon Sep 17 00:00:00 2001
From: Armin Reese <armin.c.reese@intel.com>
Date: Fri, 11 Mar 2016 13:33:47 -0800
Subject: [PATCH 4392/4706] drm/i915: Add a debugfs file to dump full ring
 contexts

commit 0e2d6e2e1f3e9be679c341caa9d2c72ebfa3b44c from
git://git.yoctoproject.org/linux-yocto-4.1

A 'cat' of the debugfs file i915_dump_lrc, dumps only the
first 1536 bytes of each ring's register state context.
It does not provide information about the ring's hardware
status page or the remaining portion of the register state
context.  This patch adds the file i915_context_dump
which displays the ring's hardware status page along with
the ring's full register state context.  Being able to view
the latter in its entirety will be very useful in debugging
issues arising from incorect context setup.

v1: Original patch
v2: reuse existing functions, add pid info in output, simplify zero skip logic.

Tracked-On: https://jira01.devtools.intel.com/browse/VIZ-6174
Change-Id: I891b85b92fcd420680e221f7e535aeeefc6a9e47
Signed-off-by: Armin Reese <armin.c.reese@intel.com>
Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
[Jeff: Modify so that a request to dump just the abbreviated LRC starts
 at the proper page.]
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c |   95 ++++++++++++++++++++++++++++------
 1 files changed, 78 insertions(+), 17 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 4beed9b..488e305 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -45,6 +45,11 @@ static inline struct drm_i915_private *node_to_i915(struct drm_info_node *node)
 	return to_i915(node->minor->dev);
 }
 
+enum {
+	LRC_CONTEXT_DUMP,       /* First 1536 bytes of register state ctx */
+	FULL_CONTEXT_DUMP,      /* Full context (HW status + reg state ctx) */
+};
+
 /* As the drm_debugfs_init() routines are called before dev->dev_private is
  * allocated we need to hook into the minor for release. */
 static int
@@ -1957,11 +1962,13 @@ static int i915_context_status(struct seq_file *m, void *unused)
 
 static void i915_dump_lrc_obj(struct seq_file *m,
 			      struct i915_gem_context *ctx,
-			      struct intel_engine_cs *engine)
+			      struct intel_engine_cs *engine,
+			      unsigned long dump_flag)
 {
 	struct i915_vma *vma = ctx->engine[engine->id].state;
 	struct page *page;
-	int j;
+	struct sg_page_iter sg_iter;
+	int i;
 
 	seq_printf(m, "CONTEXT: %s %u\n", engine->name, ctx->hw_id);
 
@@ -1979,18 +1986,55 @@ static void i915_dump_lrc_obj(struct seq_file *m,
 		return;
 	}
 
-	page = i915_gem_object_get_page(vma->obj, LRC_STATE_PN);
-	if (page) {
-		u32 *reg_state = kmap_atomic(page);
+	i = 0;
+	for_each_sg_page(vma->pages->sgl, &sg_iter,
+			 vma->pages->nents, 0) {
+		/* Dump only the first page of LRC state if requested */
+		if (dump_flag == LRC_CONTEXT_DUMP && i != LRC_STATE_PN) {
+			i++;
+			continue;
+		}
 
-		for (j = 0; j < 0x600 / sizeof(u32) / 4; j += 4) {
-			seq_printf(m,
-				   "\t[0x%04x] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-				   j * 4,
-				   reg_state[j], reg_state[j + 1],
-				   reg_state[j + 2], reg_state[j + 3]);
+		page = sg_page_iter_page(&sg_iter);
+		if (!WARN_ON(page == NULL)) {
+			int j;
+			uint32_t *reg_state;
+			int run_length = 0;
+			unsigned long page_offset = vma->node.start + i*PAGE_SIZE;
+
+			reg_state = kmap_atomic(page);
+
+			seq_printf(m, "Context object Page: %d\n", i);
+			for (j = 0; j < PAGE_SIZE / sizeof(u32); j += 4) {
+				if (reg_state[j + 0] == 0 && reg_state[j + 1] == 0 &&
+				    reg_state[j + 2] == 0 && reg_state[j + 3] == 0) {
+					run_length += 4;
+					continue;
+				}
+
+				if (run_length > 0) {
+					seq_printf(m, "\t[0x%08lx - 0x%08lx]: 0x00000000\n",
+						   page_offset + (j * 4) - (run_length * 4),
+						   page_offset + (j * 4) - 1);
+
+					run_length = 0;
+				}
+
+				seq_printf(m, "\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+					   page_offset + (j * 4),
+					   reg_state[j + 0], reg_state[j + 1],
+					   reg_state[j + 2], reg_state[j + 3]);
+			}
+
+			if (run_length > 0) {
+				seq_printf(m, "\t[0x%08lx - 0x%08lx]: 0x00000000\n",
+					   page_offset + (j * 4) - (run_length * 4),
+					   page_offset + (j * 4) - 1);
+				run_length = 0;
+			}
+			kunmap_atomic(reg_state);
 		}
-		kunmap_atomic(reg_state);
+		++i;
 	}
 
 	seq_putc(m, '\n');
@@ -1998,11 +2042,13 @@ static void i915_dump_lrc_obj(struct seq_file *m,
 
 static int i915_dump_lrc(struct seq_file *m, void *unused)
 {
-	struct drm_i915_private *dev_priv = node_to_i915(m->private);
+	struct drm_info_node *node = (struct drm_info_node *) m->private;
+	struct drm_i915_private *dev_priv = node_to_i915(node);
 	struct drm_device *dev = &dev_priv->drm;
 	struct intel_engine_cs *engine;
 	struct i915_gem_context *ctx;
-	int ret;
+	uintptr_t dump_flag = (uintptr_t) node->info_ent->data;
+	int ret, i;
 
 	if (!i915.enable_execlists) {
 		seq_printf(m, "Logical Ring Contexts are disabled\n");
@@ -2014,8 +2060,22 @@ static int i915_dump_lrc(struct seq_file *m, void *unused)
 		return ret;
 
 	list_for_each_entry(ctx, &dev_priv->context_list, link)
-		for_each_engine(engine, dev_priv)
-			i915_dump_lrc_obj(m, ctx, engine);
+		for_each_engine_id(engine, dev_priv, i) {
+			struct i915_vma *ctx_obj = ctx->engine[i].state;
+			if (ctx_obj == NULL) {
+				seq_printf(m, "Context on %s with no gem object\n",
+					   engine->name);
+				continue;
+			}
+
+			if (ctx->file_priv) {
+				seq_printf(m, "CONTEXT: %s (PID: %u, UH:%d)\n",
+					   engine->name,
+					   pid_nr(ctx->file_priv->file->pid),
+					   ctx->user_handle);
+				i915_dump_lrc_obj(m, ctx, engine, dump_flag);
+			}
+		}
 
 	mutex_unlock(&dev->struct_mutex);
 
@@ -5311,7 +5371,8 @@ static const struct drm_info_list i915_debugfs_list[] = {
 	{"i915_vbt", i915_vbt, 0},
 	{"i915_gem_framebuffer", i915_gem_framebuffer_info, 0},
 	{"i915_context_status", i915_context_status, 0},
-	{"i915_dump_lrc", i915_dump_lrc, 0},
+	{"i915_dump_lrc", i915_dump_lrc, 0, (void *) LRC_CONTEXT_DUMP},
+	{"i915_context_dump", i915_dump_lrc, 0, (void *) FULL_CONTEXT_DUMP},
 	{"i915_execlists", i915_execlists, 0},
 	{"i915_forcewake_domains", i915_forcewake_domains, 0},
 	{"i915_swizzle_info", i915_swizzle_info, 0},
-- 
1.7.5.4

