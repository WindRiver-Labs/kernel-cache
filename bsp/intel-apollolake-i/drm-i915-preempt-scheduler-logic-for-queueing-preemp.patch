From a5f73a9df098afcc7ffe1baf9c436c6b257aa8d6 Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:17 -0700
Subject: [PATCH 1363/2508] drm/i915/preempt: scheduler logic for queueing
 preemptive requests

commit 0bf5782cc98c031b9689e14e6d7fa2343150def8 from
https://github.com/01org/linux-apollolake-i

This is the very first stage of the scheduler's preemption logic, where
it determines whether a request should be marked as potentially
preemptive, at the point where it is added to the scheduler's queue.
Subsequent logic will determine how to handle the request on the basis
of the flags set here.

Actually-preemptive requests are disabled via a module parameter at this
early stage, as the rest of the logic to process them isn't in place
yet.

For: VIZ-2021
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
[mattrope: Moved 'enable_preemption' out of bool param section]
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_params.c    |    4 +++
 drivers/gpu/drm/i915/i915_params.h    |    1 +
 drivers/gpu/drm/i915/i915_scheduler.c |   44 ++++++++++++++++++++++++++++++--
 3 files changed, 46 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_params.c b/drivers/gpu/drm/i915/i915_params.c
index ad80f44..2488b1d 100644
--- a/drivers/gpu/drm/i915/i915_params.c
+++ b/drivers/gpu/drm/i915/i915_params.c
@@ -62,6 +62,7 @@ struct i915_params i915 __read_mostly = {
 	.hpd_sense_invert = -1,
 	.enable_ipc = 0,
 	.enable_scheduler = 1,
+	.enable_preemption = 0,
 };
 
 module_param_named(modeset, i915.modeset, int, 0400);
@@ -230,3 +231,6 @@ MODULE_PARM_DESC(enable_ipc,
 		 "Enable Isochronous Priority Control (default: false)");
 module_param_named_unsafe(enable_scheduler, i915.enable_scheduler, int, 0600);
 MODULE_PARM_DESC(enable_scheduler, "Enable scheduler (0 = disable, 1 = enable [default])");
+
+module_param_named_unsafe(enable_preemption, i915.enable_preemption, int, 0600);
+MODULE_PARM_DESC(enable_preemption, "Enable pre-emption within scheduler  (0 = disable [default], 1 = enable)");
diff --git a/drivers/gpu/drm/i915/i915_params.h b/drivers/gpu/drm/i915/i915_params.h
index 4831510..0773ef4 100644
--- a/drivers/gpu/drm/i915/i915_params.h
+++ b/drivers/gpu/drm/i915/i915_params.h
@@ -53,6 +53,7 @@ struct i915_params {
 	int edp_vswing;
 	unsigned int inject_load_failure;
 	int enable_scheduler;
+	int enable_preemption;
 	int hpd_sense_invert;
 	/* leave bools at the end to not create holes */
 	bool enable_hangcheck;
diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index 2f4fd4f..2003f03 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -50,10 +50,13 @@ bool i915_scheduler_is_enabled(struct drm_device *dev)
 
 const char *i915_qe_state_str(struct i915_scheduler_queue_entry *node)
 {
+	uint32_t sched_flags = node->params.request->scheduler_flags;
 	static char	str[50];
 	char		*ptr = str;
 
 	*(ptr++) = node->bumped ? 'B' : '-',
+	*(ptr++) = (sched_flags & I915_REQ_SF_PREEMPT) ? 'P' : '-';
+	*(ptr++) = (sched_flags & I915_REQ_SF_WAS_PREEMPT) ? 'p' : '-';
 	*(ptr++) = i915_gem_request_completed(node->params.request) ? 'C' : '-';
 
 	*ptr = 0;
@@ -76,6 +79,12 @@ char i915_scheduler_queue_status_chr(enum i915_scheduler_queue_status status)
 	case I915_SQS_FLYING:
 	return 'F';
 
+	case I915_SQS_OVERTAKING:
+	return 'O';
+
+	case I915_SQS_PREEMPTED:
+	return 'P';
+
 	case I915_SQS_COMPLETE:
 	return 'C';
 
@@ -107,6 +116,12 @@ const char *i915_scheduler_queue_status_str(
 	case I915_SQS_FLYING:
 	return "Flying";
 
+	case I915_SQS_OVERTAKING:
+	return "Overtaking";
+
+	case I915_SQS_PREEMPTED:
+	return "Preempted";
+
 	case I915_SQS_COMPLETE:
 	return "Complete";
 
@@ -245,6 +260,7 @@ static void i915_scheduler_node_fly(struct i915_scheduler_queue_entry *node)
 	struct drm_i915_private *dev_priv = node->params.dev->dev_private;
 	struct i915_scheduler *scheduler = dev_priv->scheduler;
 	struct intel_engine_cs *engine = node->params.engine;
+	struct drm_i915_gem_request *req = node->params.request;
 
 	assert_scheduler_lock_held(scheduler);
 
@@ -257,7 +273,10 @@ static void i915_scheduler_node_fly(struct i915_scheduler_queue_entry *node)
 	 */
 	list_add(&node->link, &scheduler->node_queue[engine->id]);
 
-	node->status = I915_SQS_FLYING;
+	if (req->scheduler_flags & I915_REQ_SF_PREEMPT)
+		node->status = I915_SQS_OVERTAKING;
+	else
+		node->status = I915_SQS_FLYING;
 
 	trace_i915_scheduler_fly(engine, node);
 	trace_i915_scheduler_node_state_change(engine, node);
@@ -739,7 +758,7 @@ int i915_scheduler_queue_execbuffer(struct i915_scheduler_queue_entry *qe)
 	struct i915_scheduler *scheduler = dev_priv->scheduler;
 	struct intel_engine_cs *engine = qe->params.engine;
 	struct i915_scheduler_queue_entry *node;
-	bool not_flying;
+	bool not_flying, want_preempt;
 	int i, e;
 	int incomplete;
 
@@ -817,6 +836,25 @@ int i915_scheduler_queue_execbuffer(struct i915_scheduler_queue_entry *qe)
 	not_flying = i915_scheduler_count_flying(scheduler, engine) <
 						 scheduler->min_flying;
 
+	want_preempt = node->priority >= scheduler->priority_level_preempt;
+
+	if (!i915.enable_preemption)
+		want_preempt = false;
+
+	/* Pre-emption is not yet implemented in non-execlist mode */
+	if (!i915.enable_execlists)
+		want_preempt = false;
+
+	/* Pre-emption is not yet implemented in non-GUC mode */
+	if (!i915.enable_guc_submission)
+		want_preempt = false;
+
+	if (want_preempt) {
+		node->params.request->scheduler_flags |=
+			I915_REQ_SF_WAS_PREEMPT | I915_REQ_SF_PREEMPT;
+		scheduler->stats[engine->id].preempts_queued++;
+	}
+
 	scheduler->stats[engine->id].queued++;
 
 	trace_i915_scheduler_queue(engine, node);
@@ -824,7 +862,7 @@ int i915_scheduler_queue_execbuffer(struct i915_scheduler_queue_entry *qe)
 
 	spin_unlock_irq(&scheduler->lock);
 
-	if (not_flying)
+	if (not_flying || want_preempt)
 		i915_scheduler_submit(engine);
 
 	return 0;
-- 
1.7.5.4

