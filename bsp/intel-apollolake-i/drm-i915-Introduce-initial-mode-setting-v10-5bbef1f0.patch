From 894a7e8fac48fb6f4853b9aa6312151e5b1a405f Mon Sep 17 00:00:00 2001
From: Bob Paauwe <bob.j.paauwe@intel.com>
Date: Fri, 22 Apr 2016 16:43:18 -0700
Subject: [PATCH 4419/4706] drm/i915: Introduce initial mode setting (v10)

commit bcef8e99d9737a67296dfadb7fd8c916d617d3c9 from
git://git.yoctoproject.org/linux-yocto-4.1

For very specific use cases it may be desirable to have the kernel
driver do an initial mode set and/or splash screen type display without
having to enable a framebuffer console.

A primary goal for this feature is to have the display lit up as soon
as possible.  A non-goal is the ability to detect and adapt to the
display configurations. In other words, the  display configuration will
be a known/fixed configuration.  In addition, it is expected that the
EDID information will be present and optimized so mode list creation
and taversal time is minimized.

Add a new module parameter that replaces the normal fbdev initialization
with a new initial mode set.  When the parameter is off, follow the normal
program flow and (if configured) initialize fbdev and a framebuffer
console.  When the parameter is on, do an atomic mode set with everything
off (no crtc's enabled).

This creates the framework for the modesetting and framebuffer code
in the following commits.

v2: Move comment down and format in kerneldoc format (Matt)
    Remove unused include files (Matt)
    Remove unused variables (Bob)
    Major code reorganizations and remove dependencies on fb helper code.
v3: Remove the modeset_info structure.
    Merge the initial modesetting code to create a complete implementation.
    Rename width/height to max_width/max_height in set_display_mode (Matt)
    Fix out of date comment about allocating empty framebuffer (Matt)
v4: Remove the modeset structure abstraction and use atomic state directly.
v5: Remove redundent call to drm_atomic_add_affected_connectors(). (Chi)
    Fix atomic commit locking. (Bob)
v6: Remove the modeset_info structure and pass state around instead. (Matt)
v7: Change the initial split of the first two commits.  This commit now
    sets an initial config with everything off.  The next commit adds
    checking connector status and turns on those with attached displays.
v8: Tweak the docbook info and add to drm.tmpl (Matt)
    Change disable_planes to propogate errors (Matt)
    Remove the expliced setting of disabled planes crtc & src rect (Matt)
    Remove any old framebuffers after disabling the plane (Bob)
    Move the atomic commit and uplevel the backoff code handling (Matt)
v9: Property handle initial framebuffer dereference here by moving it
    up from a later patch.
    Rename file to intel_initial_modeset.c to be less confusing (Matt)
    Change module paramter to a boolean (Matt)
    Use a workqueue instead of async schedule (Matt)
v10: remove double ;; (Matt)
     Change DRM_ERROR to DRM_DEBUG_KSM on deadlock (Matt)

Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Reviewed-by: James Xiong <james.xiong@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/Makefile                |    3 +
 drivers/gpu/drm/i915/i915_drv.c              |   21 +++-
 drivers/gpu/drm/i915/i915_drv.h              |    2 +
 drivers/gpu/drm/i915/i915_params.c           |    5 +
 drivers/gpu/drm/i915/i915_params.h           |    1 +
 drivers/gpu/drm/i915/intel_drv.h             |    4 +
 drivers/gpu/drm/i915/intel_initial_modeset.c |  141 ++++++++++++++++++++++++++
 7 files changed, 171 insertions(+), 6 deletions(-)
 create mode 100644 drivers/gpu/drm/i915/intel_initial_modeset.c

diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index 62cd1b1..006d89d 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -119,6 +119,9 @@ endif
 i915-y += i915_ext_ioctl.o
 i915-y += i915_gem_userdata.o
 
+# initial modeset
+i915-y += intel_initial_modeset.o
+
 obj-$(CONFIG_DRM_I915)  += i915.o
 
 CFLAGS_i915_trace_points.o := -I$(src)
diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c
index 1b24eb5..7f33743 100644
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -629,9 +629,11 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (INTEL_INFO(dev)->num_pipes == 0)
 		return 0;
 
-	ret = intel_fbdev_init(dev);
-	if (ret)
-		goto cleanup_gem;
+	if (!i915.enable_initial_modeset) {
+		ret = intel_fbdev_init(dev);
+		if (ret)
+			goto cleanup_gem;
+	}
 
 	/* Only enable hotplug handling once the fbdev is fully set up. */
 	intel_hpd_init(dev_priv);
@@ -1146,7 +1148,10 @@ static void i915_driver_register(struct drm_i915_private *dev_priv)
 	 * irqs are fully enabled. We do it last so that the async config
 	 * cannot run before the connectors are registered.
 	 */
-	intel_fbdev_initial_config_async(dev);
+	if (i915.enable_initial_modeset)
+		intel_initial_mode_config_init(dev);
+	else
+		intel_fbdev_initial_config_async(dev);
 }
 
 /**
@@ -1286,7 +1291,10 @@ void i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct pci_dev *pdev = dev_priv->drm.pdev;
 
-	intel_fbdev_fini(dev);
+	if (!i915.enable_initial_modeset)
+		intel_fbdev_fini(dev);
+	else
+		intel_initial_mode_config_fini(dev);
 
 	if (i915_gem_suspend(dev))
 		DRM_ERROR("failed to idle hardware; continuing to unload!\n");
@@ -1364,7 +1372,8 @@ static int i915_driver_open(struct drm_device *dev, struct drm_file *file)
  */
 static void i915_driver_lastclose(struct drm_device *dev)
 {
-	intel_fbdev_restore_mode(dev);
+	if (!i915.enable_initial_modeset)
+		intel_fbdev_restore_mode(dev);
 	vga_switcheroo_process_delayed_switch();
 }
 
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 49e1913..87ed7fc 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1946,6 +1946,8 @@ struct drm_i915_private {
 #endif
 	struct intel_load_profiles profile;
 
+	struct work_struct initial_modeset_work;
+
 	/* dpll and cdclk state is protected by connection_mutex */
 	int num_shared_dpll;
 	struct intel_shared_dpll shared_dplls[I915_NUM_PLLS];
diff --git a/drivers/gpu/drm/i915/i915_params.c b/drivers/gpu/drm/i915/i915_params.c
index 02b007e..fac12b2 100644
--- a/drivers/gpu/drm/i915/i915_params.c
+++ b/drivers/gpu/drm/i915/i915_params.c
@@ -64,6 +64,7 @@ struct i915_params i915 __read_mostly = {
 	.enable_dpcd_backlight = false,
 	.enable_gvt = false,
 	.enable_ipc = 0,
+	.enable_initial_modeset = false,
 };
 
 module_param_named(modeset, i915.modeset, int, 0400);
@@ -242,3 +243,7 @@ MODULE_PARM_DESC(enable_gvt,
 module_param_named_unsafe(enable_ipc, i915.enable_ipc, bool, 0400);
 MODULE_PARM_DESC(enable_ipc,
 		 "Enable Isochronous Priority Control (default: false)");
+
+module_param_named_unsafe(enable_initial_modeset, i915.enable_initial_modeset, bool, 0400);
+MODULE_PARM_DESC(enable_initial_modeset,
+		 "Do initial modeset for TSD usecase (default : false)");
diff --git a/drivers/gpu/drm/i915/i915_params.h b/drivers/gpu/drm/i915/i915_params.h
index 004ebff..a1d9fad 100644
--- a/drivers/gpu/drm/i915/i915_params.h
+++ b/drivers/gpu/drm/i915/i915_params.h
@@ -67,6 +67,7 @@ struct i915_params {
 	bool enable_dpcd_backlight;
 	bool enable_gvt;
 	bool enable_ipc;
+	bool enable_initial_modeset;
 };
 
 extern struct i915_params i915 __read_mostly;
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 2468b0e..6ef3aad 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -1504,6 +1504,10 @@ static inline void intel_fbdev_restore_mode(struct drm_device *dev)
 }
 #endif
 
+/* initial modesetting support */
+extern void intel_initial_mode_config_init(struct drm_device *dev);
+extern void intel_initial_mode_config_fini(struct drm_device *dev);
+
 /* intel_fbc.c */
 void intel_fbc_choose_crtc(struct drm_i915_private *dev_priv,
 			   struct drm_atomic_state *state);
diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
new file mode 100644
index 0000000..e4c6994
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -0,0 +1,141 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions: *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/**
+ * DOC: Boot-time mode setting.
+ *
+ * There exists a use case where the kernel graphics needs to be initialized
+ * with a valid display configuration with full display pipeline programming
+ * in place before user space is initialized and without a fbdev & fb console.
+ *
+ * The primary motivation is to allow early user space applications to
+ * display a frame (or frames) as soon as possible after user space starts.
+ * Eliminating the time it takes userspace to program the display configuration
+ * benefits this use case.
+ *
+ * By doing all the display programming in the kernel, it can be done in
+ * parallel with other kernel startup tasks without adding significant
+ * elapshed time before user space starts.
+ */
+
+#include "intel_drv.h"
+#include "i915_drv.h"
+
+
+static int disable_planes(struct drm_device *dev,
+			  struct drm_atomic_state *state)
+{
+	struct drm_plane *plane;
+	int ret;
+
+	drm_for_each_plane(plane, dev) {
+		struct drm_plane_state *plane_state;
+
+		plane->old_fb = plane->fb;
+
+		plane_state = drm_atomic_get_plane_state(state, plane);
+		if (IS_ERR(plane_state)) {
+			return PTR_ERR(plane_state);
+		}
+
+		ret = drm_atomic_plane_set_property(plane, plane_state,
+					dev->mode_config.rotation_property,
+					BIT(DRM_ROTATE_0));
+		WARN_ON(ret);
+
+		ret = drm_atomic_set_crtc_for_plane(plane_state, NULL);
+		if (ret != 0)
+			return ret;
+
+		drm_atomic_set_fb_for_plane(plane_state, NULL);
+	}
+
+	return 0;
+}
+
+/*
+ * The modeset_config is scheduled to run via an async
+ * schedule call from the main driver load.
+ */
+static void modeset_config_fn(struct work_struct *work)
+{
+	struct drm_i915_private *dev_priv =
+		container_of(work, typeof(*dev_priv), initial_modeset_work);
+	struct drm_device *dev = &dev_priv->drm;
+	struct drm_atomic_state *state;
+	struct drm_modeset_acquire_ctx ctx;
+	struct drm_plane *plane;
+	int ret;
+
+	state = drm_atomic_state_alloc(dev);
+	if (!state)
+		return;
+
+	drm_modeset_acquire_init(&ctx, 0);
+	state->acquire_ctx = &ctx;
+	drm_modeset_lock_all_ctx(dev, &ctx);
+
+	ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
+			       state->acquire_ctx);
+	if (ret)
+		goto out;
+
+retry:
+	ret = disable_planes(dev, state);
+	if (ret == 0)
+		ret = drm_atomic_commit(state);
+
+	if (ret == -EDEADLK) {
+		DRM_DEBUG_KMS("modeset commit deadlock, retry...\n");
+		drm_modeset_backoff(&ctx);
+		drm_atomic_state_clear(state);
+		goto retry;
+	}
+
+out:
+	if (ret)
+		drm_atomic_state_free(state);
+	else
+		drm_for_each_plane(plane, dev) {
+			if (plane->old_fb)
+				drm_framebuffer_unreference(plane->old_fb);
+		}
+
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+}
+
+void intel_initial_mode_config_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	INIT_WORK(&dev_priv->initial_modeset_work, modeset_config_fn);
+	schedule_work(&dev_priv->initial_modeset_work);
+}
+
+void intel_initial_mode_config_fini(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	flush_work(&dev_priv->initial_modeset_work);
+}
-- 
1.7.5.4

