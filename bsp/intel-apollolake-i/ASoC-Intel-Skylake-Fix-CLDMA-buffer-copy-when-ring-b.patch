From 13b4d83953f4e70ffd60d88d167b1b160bfb8349 Mon Sep 17 00:00:00 2001
From: Jeeja KP <jeeja.kp@intel.com>
Date: Tue, 15 Sep 2015 22:04:26 +0530
Subject: [PATCH 1687/2508] ASoC: Intel: Skylake: Fix CLDMA buffer copy when
 ring buffer wrap occurs

commit 4c557bb5a78e9139692150406810ada578278980 from
https://github.com/01org/linux-apollolake-i

When downloading the firmware/module, if ring buffer boundary is
reached, need to wrap to the zeroth position. When copying the
buffer, need to copy till end of buffer and the remaining buffer
needs to be copied from zeroth position. Copy was not handled
correctly in case when wrap condition is reached which caused
invalid data to be copied resulting in invalid module hash failure.
This patch fixes the issue by handling copy at the boundary
condition correctly.

Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
---
 sound/soc/intel/skylake/skl-sst-cldma.c |   15 +++++++++++++++
 1 files changed, 15 insertions(+), 0 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-sst-cldma.c b/sound/soc/intel/skylake/skl-sst-cldma.c
index 44748ba..b20e34c 100644
--- a/sound/soc/intel/skylake/skl-sst-cldma.c
+++ b/sound/soc/intel/skylake/skl-sst-cldma.c
@@ -175,6 +175,21 @@ static void skl_cldma_fill_buffer(struct sst_dsp *ctx, unsigned int size,
 			ctx->cl_dev.dma_buffer_offset, trigger);
 	dev_dbg(ctx->dev, "spib position: %d\n", ctx->cl_dev.curr_spib_pos);
 
+	/*
+	 * Check if the size exceeds buffer boundry. if exceeds max_buffer
+	 * size, then copy till buffer size and then remaining buffer copy
+	 * to the start of ring buffer.
+	 */
+	if (ctx->cl_dev.dma_buffer_offset + size > ctx->cl_dev.bufsize) {
+		unsigned int size_b = ctx->cl_dev.bufsize -
+					ctx->cl_dev.dma_buffer_offset;
+		memcpy(ctx->cl_dev.dmab_data.area + ctx->cl_dev.dma_buffer_offset,
+			curr_pos, size_b);
+		size -= size_b;
+		curr_pos += size_b;
+		ctx->cl_dev.dma_buffer_offset = 0;
+	}
+
 	memcpy(ctx->cl_dev.dmab_data.area + ctx->cl_dev.dma_buffer_offset,
 			curr_pos, size);
 
-- 
1.7.5.4

