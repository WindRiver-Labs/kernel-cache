From 7bc200dfcbb2385c78c95c1ef38b21dab583c3e3 Mon Sep 17 00:00:00 2001
From: Guneshwor Singh <guneshwor.o.singh@intel.com>
Date: Fri, 20 Nov 2015 04:33:03 +0530
Subject: [PATCH 1829/2508] ASoC: Intel: Cannonlake: Add DSP library functions
 for CNL platform

commit b77e4a34359b044972edd136eb8cad3a93d5c527 from
https://github.com/01org/linux-apollolake-i

This adds the necessary DSP functions specific for the Cannonlake platform.
Firmware download is done using host DMA.

Change-Id: I9b04147cdcdab9027ac091fe371cd3d75743ca3b
Signed-off-by: Guneshwor Singh <guneshwor.o.singh@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7592
Reviewed-by: Shah, Hardik T <hardik.t.shah@intel.com>
Tested-by: Shah, Hardik T <hardik.t.shah@intel.com>
---
 sound/soc/intel/skylake/Makefile  |    4 +-
 sound/soc/intel/skylake/cnl-sst.c |  509 +++++++++++++++++++++++++++++++++++++
 sound/soc/intel/skylake/skl.c     |   23 ++-
 3 files changed, 530 insertions(+), 6 deletions(-)
 create mode 100644 sound/soc/intel/skylake/cnl-sst.c

diff --git a/sound/soc/intel/skylake/Makefile b/sound/soc/intel/skylake/Makefile
index 2a6f7d9..c46aa60 100644
--- a/sound/soc/intel/skylake/Makefile
+++ b/sound/soc/intel/skylake/Makefile
@@ -8,7 +8,7 @@ endif
 obj-$(CONFIG_SND_SOC_INTEL_SKYLAKE) += snd-soc-skl.o
 
 # Skylake IPC Support
-snd-soc-skl-ipc-objs := skl-sst-ipc.o skl-sst-dsp.o skl-sst-cldma.o \
-		skl-sst.o bxt-sst.o
+snd-soc-skl-ipc-objs := skl-sst-ipc.o skl-sst-dsp.o cnl-sst-dsp.o \
+	skl-sst-cldma.o skl-sst.o bxt-sst.o cnl-sst.o
 
 obj-$(CONFIG_SND_SOC_INTEL_SKYLAKE) += snd-soc-skl-ipc.o
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
new file mode 100644
index 0000000..8d0aeffa
--- /dev/null
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -0,0 +1,509 @@
+/*
+ * cnl-sst.c - HDA DSP library functions for CNL platform
+ *
+ * Copyright (C) 2015-16, Intel Corporation.
+ *
+ * Author: Guneshwor Singh <guneshwor.o.singh@intel.com>
+ *
+ * Modified from:
+ *	HDA DSP library functions for SKL platform
+ *	Copyright (C) 2014-15, Intel Corporation.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as version 2, as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <asm/cacheflush.h>
+
+#include "../common/sst-dsp.h"
+#include "../common/sst-dsp-priv.h"
+#include "../common/sst-ipc.h"
+#include "cnl-sst-dsp.h"
+#include "skl-sst-dsp.h"
+#include "skl-sst-ipc.h"
+
+#define FW_ROM_INIT_DONE                0x1
+#define CNL_IPC_PURGE_FW		0x01004000
+#define CNL_ROM_INIT_HIPCIDA_TIMEOUT    500
+#define CNL_ROM_INIT_DONE_TIMEOUT	500
+#define CNL_FW_ROM_BASEFW_ENTERED_TIMEOUT	500
+#define CNL_FW_ROM_BASEFW_ENTERED	0x5
+
+/* Intel HD Audio SRAM Window 0*/
+#define CNL_ADSP_SRAM0_BASE	0x80000
+
+/* Firmware status window */
+#define CNL_ADSP_FW_STATUS	CNL_ADSP_SRAM0_BASE
+#define CNL_ADSP_ERROR_CODE	(CNL_ADSP_FW_STATUS + 0x4)
+
+#define CNL_INSTANCE_ID		0
+#define CNL_BASE_FW_MODULE_ID	0
+
+void cnl_ipc_int_enable(struct sst_dsp *ctx)
+{
+	sst_dsp_shim_update_bits(ctx, CNL_ADSP_REG_ADSPIC,
+		CNL_ADSPIC_IPC, CNL_ADSPIC_IPC);
+}
+
+void cnl_ipc_int_disable(struct sst_dsp *ctx)
+{
+	sst_dsp_shim_update_bits_unlocked(ctx, CNL_ADSP_REG_ADSPIC,
+		CNL_ADSPIC_IPC, 0);
+}
+
+void cnl_ipc_op_int_enable(struct sst_dsp *ctx)
+{
+	/* enable IPC DONE interrupt */
+	sst_dsp_shim_update_bits(ctx, CNL_ADSP_REG_HIPCCTL,
+		CNL_ADSP_REG_HIPCCTL_DONE, CNL_ADSP_REG_HIPCCTL_DONE);
+
+	/* Enable IPC BUSY interrupt */
+	sst_dsp_shim_update_bits(ctx, CNL_ADSP_REG_HIPCCTL,
+		CNL_ADSP_REG_HIPCCTL_BUSY, CNL_ADSP_REG_HIPCCTL_BUSY);
+}
+
+bool cnl_ipc_int_status(struct sst_dsp *ctx)
+{
+	return sst_dsp_shim_read_unlocked(ctx,
+		CNL_ADSP_REG_ADSPIS) & CNL_ADSPIS_IPC;
+}
+
+void cnl_ipc_free(struct sst_generic_ipc *ipc)
+{
+	/* Disable IPC DONE interrupt */
+	sst_dsp_shim_update_bits(ipc->dsp, CNL_ADSP_REG_HIPCCTL,
+		CNL_ADSP_REG_HIPCCTL_DONE, 0);
+
+	/* Disable IPC BUSY interrupt */
+	sst_dsp_shim_update_bits(ipc->dsp, CNL_ADSP_REG_HIPCCTL,
+		CNL_ADSP_REG_HIPCCTL_BUSY, 0);
+
+	sst_ipc_fini(ipc);
+}
+
+static int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
+		u32 fwsize)
+{
+
+	int ret, i, stream_tag;
+	u32 reg;
+	u32 pages;
+
+	dev_dbg(ctx->dev, "Starting to prepare host dma fwsize=0x%x\n", fwsize);
+	stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fwsize, &ctx->dmab);
+	if (stream_tag <= 0) {
+		dev_err(ctx->dev, "DMA prepare failed: 0x%x\n", stream_tag);
+		return stream_tag;
+	}
+
+	ctx->dsp_ops.stream_tag = stream_tag;
+	pages = (fwsize + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	memcpy(ctx->dmab.area, fwdata, fwsize);
+
+	/* purge FW request */
+	sst_dsp_shim_write(ctx, CNL_ADSP_REG_HIPCIDR,
+			CNL_ADSP_REG_HIPCIDR_BUSY |
+			CNL_IPC_PURGE_FW | (stream_tag - 1));
+
+	ret = cnl_dsp_enable_core(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Boot dsp core failed ret: %d\n", ret);
+		ret = -EIO;
+		goto base_fw_load_failed;
+	}
+
+	for (i = CNL_ROM_INIT_HIPCIDA_TIMEOUT; i > 0; --i) {
+		reg = sst_dsp_shim_read(ctx, CNL_ADSP_REG_HIPCIDA);
+
+		if (reg & CNL_ADSP_REG_HIPCIDA_DONE) {
+			sst_dsp_shim_update_bits_forced(ctx,
+					CNL_ADSP_REG_HIPCIDA,
+					CNL_ADSP_REG_HIPCIDA_DONE,
+					CNL_ADSP_REG_HIPCIDA_DONE);
+			break;
+		}
+
+		mdelay(1);
+	}
+
+	if (!i) {
+		dev_err(ctx->dev, "HIPCIDA done timeout: 0x%x\n", reg);
+		sst_dsp_shim_update_bits(ctx, CNL_ADSP_REG_HIPCIDA,
+				CNL_ADSP_REG_HIPCIDA_DONE,
+				CNL_ADSP_REG_HIPCIDA_DONE);
+	}
+
+	/* enable interrupt */
+	cnl_ipc_int_enable(ctx);
+	cnl_ipc_op_int_enable(ctx);
+
+	/* poll for ROM init done */
+	for (i = CNL_ROM_INIT_DONE_TIMEOUT; i > 0; --i) {
+		if (FW_ROM_INIT_DONE ==
+			(sst_dsp_shim_read(ctx, CNL_ADSP_FW_STATUS) &
+				CNL_FW_STS_MASK)) {
+				dev_dbg(ctx->dev, "ROM loaded\n");
+			break;
+		}
+		mdelay(1);
+	}
+	if (!i) {
+		dev_err(ctx->dev, "ROM init done timeout: 0x%x\n", reg);
+		ret = -EIO;
+		goto base_fw_load_failed;
+	}
+
+	return 0;
+base_fw_load_failed:
+	cnl_dsp_disable_core(ctx);
+	ctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);
+	return ret;
+}
+
+static int sst_transfer_fw_host_dma(struct sst_dsp *ctx)
+{
+	int ret = 0;
+	int stream_tag = 0;
+
+	ctx->dsp_ops.trigger(ctx->dev, true, ctx->dsp_ops.stream_tag);
+	ret = sst_dsp_register_poll(ctx, CNL_ADSP_FW_STATUS, CNL_FW_STS_MASK,
+			CNL_FW_ROM_BASEFW_ENTERED,
+			CNL_FW_ROM_BASEFW_ENTERED_TIMEOUT,
+			"Firmware boot");
+
+	ctx->dsp_ops.trigger(ctx->dev, false, stream_tag);
+	ctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);
+	return ret;
+}
+
+static int cnl_load_base_firmware(struct sst_dsp *ctx)
+{
+	int ret = 0;
+	const struct firmware *fw = NULL;
+	struct skl_sst *cnl = ctx->thread_context;
+
+	ret = request_firmware(&fw, "dsp_fw_release.bin", ctx->dev);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Request firmware failed: 0x%x\n", ret);
+		goto cnl_load_base_firmware_failed;
+	}
+
+	ret = cnl_prepare_fw(ctx, fw->data, fw->size);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Prepare firmware failed: 0x%x\n", ret);
+		goto cnl_load_base_firmware_failed;
+	}
+
+	ret = sst_transfer_fw_host_dma(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Transfer firmware failed: 0x%x\n", ret);
+		goto cnl_load_base_firmware_failed;
+	} else {
+		dev_dbg(ctx->dev, "Firmware download successful\n");
+		ret = wait_event_timeout(cnl->boot_wait, cnl->boot_complete,
+					msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
+		if (ret == 0) {
+			dev_err(ctx->dev, "DSP boot failed, FW Ready timed-out\n");
+			cnl_dsp_disable_core(ctx);
+			ret = -EIO;
+		} else {
+
+			skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+			ret = 0;
+		}
+	}
+
+cnl_load_base_firmware_failed:
+	release_firmware(fw);
+	return ret;
+}
+
+static int cnl_set_dsp_D0(struct sst_dsp *ctx)
+{
+	int ret = 0;
+	struct skl_sst *cnl = ctx->thread_context;
+
+	cnl->boot_complete = false;
+
+	ret = cnl_dsp_enable_core(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "enable dsp core failed: %d\n", ret);
+		return ret;
+	}
+
+	/* enable interrupt */
+	cnl_ipc_int_enable(ctx);
+	cnl_ipc_op_int_enable(ctx);
+
+	ret = wait_event_timeout(cnl->boot_wait, cnl->boot_complete,
+					msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
+	if (ret == 0) {
+		dev_err(ctx->dev, "DSP boot timeout: 0x%x\n",
+			sst_dsp_shim_read_unlocked(ctx, CNL_ADSP_FW_STATUS));
+		cnl_dsp_disable_core(ctx);
+		return -EIO;
+	}
+
+	skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+	return 0;
+}
+
+static int cnl_set_dsp_D3(struct sst_dsp *ctx)
+{
+	int ret;
+	struct skl_ipc_dxstate_info dx;
+	struct skl_sst *cnl = ctx->thread_context;
+
+	dev_dbg(ctx->dev, "In %s:\n", __func__);
+	mutex_lock(&ctx->mutex);
+	if (!is_skl_dsp_running(ctx)) {
+		mutex_unlock(&ctx->mutex);
+		return 0;
+	}
+	mutex_unlock(&ctx->mutex);
+
+	dx.core_mask = CNL_DSP_CORES_MASK;
+	dx.dx_mask = SKL_IPC_D3_MASK;
+	ret = skl_ipc_set_dx(&cnl->ipc,
+			     CNL_INSTANCE_ID,
+			     CNL_BASE_FW_MODULE_ID,
+			     &dx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to set DSP to D3 state\n");
+		return ret;
+	}
+
+	ret = cnl_dsp_disable_core(ctx);
+	if (ret < 0) {
+		dev_err(ctx->dev, "disable dsp core failed: %d\n", ret);
+		ret = -EIO;
+	}
+	skl_dsp_set_state_locked(ctx, SKL_DSP_RESET);
+
+	return ret;
+}
+
+static unsigned int cnl_get_errorcode(struct sst_dsp *ctx)
+{
+	 return sst_dsp_shim_read(ctx, CNL_ADSP_ERROR_CODE);
+}
+
+static struct skl_dsp_fw_ops cnl_fw_ops = {
+	.set_state_D0 = cnl_set_dsp_D0,
+	.set_state_D3 = cnl_set_dsp_D3,
+	.load_fw = cnl_load_base_firmware,
+	.get_fw_errcode = cnl_get_errorcode,
+};
+
+static struct sst_ops cnl_ops = {
+	.irq_handler = cnl_dsp_sst_interrupt,
+	.write = sst_shim32_write,
+	.read = sst_shim32_read,
+	.ram_read = sst_memcpy_fromio_32,
+	.ram_write = sst_memcpy_toio_32,
+	.free = cnl_dsp_free,
+};
+
+#define IPC_GLB_NOTIFY_RSP_SHIFT	29
+#define IPC_GLB_NOTIFY_RSP_MASK		0x1
+#define IPC_GLB_NOTIFY_RSP_TYPE(x)	(((x) >> IPC_GLB_NOTIFY_RSP_SHIFT) \
+					& IPC_GLB_NOTIFY_RSP_MASK)
+
+static irqreturn_t cnl_dsp_irq_thread_handler(int irq, void *context)
+{
+	struct sst_dsp *dsp = context;
+	struct skl_sst *cnl = sst_dsp_get_thread_context(dsp);
+	struct sst_generic_ipc *ipc = &cnl->ipc;
+	struct skl_ipc_header header = {0};
+	u32 hipcida, hipctdr, hipctdd;
+	int ipc_irq = 0;
+
+	/* Here we handle IPC interrupts only */
+	if (!(dsp->intr_status & CNL_ADSPIS_IPC))
+		return IRQ_NONE;
+
+	hipcida = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCIDA);
+	hipctdr = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCTDR);
+
+	/* reply message from DSP */
+	if (hipcida & CNL_ADSP_REG_HIPCIDA_DONE) {
+		sst_dsp_shim_update_bits(dsp, CNL_ADSP_REG_HIPCCTL,
+			CNL_ADSP_REG_HIPCCTL_DONE, 0);
+
+		/* clear DONE bit - tell DSP we have completed the operation */
+		sst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCIDA,
+			CNL_ADSP_REG_HIPCIDA_DONE, CNL_ADSP_REG_HIPCIDA_DONE);
+
+		ipc_irq = 1;
+
+		/* unmask Done interrupt */
+		sst_dsp_shim_update_bits(dsp, CNL_ADSP_REG_HIPCCTL,
+			CNL_ADSP_REG_HIPCCTL_DONE, CNL_ADSP_REG_HIPCCTL_DONE);
+	}
+
+	/* New message from DSP */
+	if (hipctdr & CNL_ADSP_REG_HIPCTDR_BUSY) {
+		hipctdd = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCTDD);
+		header.primary = hipctdr;
+		header.extension = hipctdd;
+		dev_dbg(dsp->dev, "IPC irq: Firmware respond primary:%x",
+						header.primary);
+		dev_dbg(dsp->dev, "IPC irq: Firmware respond extension:%x",
+						header.extension);
+
+		if (IPC_GLB_NOTIFY_RSP_TYPE(header.primary)) {
+			/* Handle Immediate reply from DSP Core */
+			skl_ipc_process_reply(ipc, header);
+		} else {
+			dev_dbg(dsp->dev, "IPC irq: Notification from firmware\n");
+			skl_ipc_process_notification(ipc, header);
+		}
+		/* clear busy interrupt */
+		sst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCTDR,
+			CNL_ADSP_REG_HIPCTDR_BUSY, CNL_ADSP_REG_HIPCTDR_BUSY);
+
+		/* set done bit to ack DSP */
+		sst_dsp_shim_update_bits_forced(dsp, CNL_ADSP_REG_HIPCTDA,
+			CNL_ADSP_REG_HIPCTDA_DONE, CNL_ADSP_REG_HIPCTDA_DONE);
+		ipc_irq = 1;
+	}
+
+	if (ipc_irq == 0)
+		return IRQ_NONE;
+
+	cnl_ipc_int_enable(dsp);
+
+	/* continue to send any remaining messages... */
+	queue_kthread_work(&ipc->kworker, &ipc->kwork);
+
+	return IRQ_HANDLED;
+}
+
+static struct sst_dsp_device cnl_dev = {
+	.thread = cnl_dsp_irq_thread_handler,
+	.ops = &cnl_ops,
+};
+
+static void cnl_ipc_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)
+{
+	struct skl_ipc_header *header = (struct skl_ipc_header *)(&msg->header);
+
+	if (msg->tx_size)
+		sst_dsp_outbox_write(ipc->dsp, msg->tx_data, msg->tx_size);
+	sst_dsp_shim_write_unlocked(ipc->dsp, CNL_ADSP_REG_HIPCIDD,
+						header->extension);
+	sst_dsp_shim_write_unlocked(ipc->dsp, CNL_ADSP_REG_HIPCIDR,
+		header->primary | CNL_ADSP_REG_HIPCIDR_BUSY);
+}
+
+static bool cnl_ipc_is_dsp_busy(struct sst_dsp *dsp)
+{
+	u32 hipcidr;
+
+	hipcidr = sst_dsp_shim_read_unlocked(dsp, CNL_ADSP_REG_HIPCIDR);
+	return (hipcidr & CNL_ADSP_REG_HIPCIDR_BUSY);
+}
+
+static int cnl_ipc_init(struct device *dev, struct skl_sst *cnl)
+{
+	struct sst_generic_ipc *ipc;
+	int err;
+
+	ipc = &cnl->ipc;
+	ipc->dsp = cnl->dsp;
+	ipc->dev = dev;
+
+	ipc->tx_data_max_size = CNL_ADSP_W1_SZ;
+	ipc->rx_data_max_size = CNL_ADSP_W0_UP_SZ;
+
+	err = sst_ipc_init(ipc);
+	if (err)
+		return err;
+
+	/* Overriding tx_msg and is_dsp_busy since IPC registers are changed for CNL */
+	ipc->ops.tx_msg = cnl_ipc_tx_msg;
+	ipc->ops.tx_data_copy = skl_ipc_tx_data_copy;
+	ipc->ops.is_dsp_busy = cnl_ipc_is_dsp_busy;
+
+	return 0;
+}
+
+int cnl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
+		struct skl_dsp_loader_ops dsp_ops, struct skl_sst **dsp)
+{
+	struct skl_sst *cnl;
+	struct sst_dsp *sst;
+	int ret;
+
+	cnl = devm_kzalloc(dev, sizeof(*cnl), GFP_KERNEL);
+	if (cnl == NULL)
+		return -ENOMEM;
+
+	cnl->dev = dev;
+	cnl_dev.thread_context = cnl;
+
+	cnl->dsp = skl_dsp_ctx_init(dev, &cnl_dev, irq);
+	if (!cnl->dsp) {
+		dev_err(cnl->dev, "%s: no device\n", __func__);
+		return -ENODEV;
+	}
+
+	sst = cnl->dsp;
+
+	sst->dsp_ops = dsp_ops;
+	sst->fw_ops = cnl_fw_ops;
+	sst->addr.lpe = mmio_base;
+	sst->addr.shim = mmio_base;
+	sst_dsp_mailbox_init(sst, (CNL_ADSP_SRAM0_BASE + CNL_ADSP_W0_STAT_SZ),
+			CNL_ADSP_W0_UP_SZ, CNL_ADSP_SRAM1_BASE, CNL_ADSP_W1_SZ);
+
+
+	ret = cnl_ipc_init(dev, cnl);
+	if (ret)
+		return ret;
+
+	cnl->boot_complete = false;
+	init_waitqueue_head(&cnl->boot_wait);
+
+	ret = sst->fw_ops.load_fw(sst);
+	if (ret < 0) {
+		dev_err(dev, "Load base fw failed : %d", ret);
+		return ret;
+	}
+
+	if (dsp)
+		*dsp = cnl;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cnl_sst_dsp_init);
+
+void cnl_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)
+{
+	cnl_ipc_free(&ctx->ipc);
+	ctx->dsp->cl_dev.ops.cl_cleanup_controller(ctx->dsp);
+	if (ctx->dsp->addr.lpe)
+		iounmap(ctx->dsp->addr.lpe);
+
+	ctx->dsp->ops->free(ctx->dsp);
+}
+EXPORT_SYMBOL_GPL(cnl_sst_dsp_cleanup);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Intel Cannonlake IPC driver");
diff --git a/sound/soc/intel/skylake/skl.c b/sound/soc/intel/skylake/skl.c
index da3bd6d..a06c4bf 100644
--- a/sound/soc/intel/skylake/skl.c
+++ b/sound/soc/intel/skylake/skl.c
@@ -287,6 +287,12 @@ static struct sst_machines *sst_acpi_find_machine(
 	return NULL;
 }
 
+/* TODO fill codec acpi name */
+static struct sst_machines sst_cnl_devdata[] = {
+	{ "dummy", "mrgfld_florida" },
+	{ "dummy", "mrgfld_florida" },
+};
+
 static int skl_machine_device_register(struct skl *skl, void *driver_data)
 {
 	struct hdac_bus *bus = ebus_to_hbus(&skl->ebus);
@@ -304,11 +310,15 @@ static int skl_machine_device_register(struct skl *skl, void *driver_data)
 		mach = sst_acpi_find_machine(mach);
 		if (mach == NULL) {
 			dev_err(bus->dev, "No matching machine driver found\n");
-			return -ENODEV;
+			if (skl->pci->device == 0x9df0) {
+				dev_warn(bus->dev, "Taking hardcoded machine driver for CNL FPGA platform\n");
+				mach = sst_cnl_devdata;
+				goto cnl_continue;
+			}
 		}
-
+		return -ENODEV;
 	}
-
+cnl_continue:
 	dev_dbg(bus->dev, "Machine driver found:%s\n", mach->machine);
 	pdev = platform_device_alloc(mach->machine, -1);
 	if (pdev == NULL) {
@@ -651,7 +661,7 @@ static void skl_remove(struct pci_dev *pci)
 	if (pci_dev_run_wake(pci))
 		pm_runtime_get_noresume(&pci->dev);
 	pci_dev_put(pci);
-	
+
 	skl_debugfs_exit(skl->debugfs);
 	skl->debugfs = NULL;
 	skl_platform_unregister(&pci->dev);
@@ -687,6 +697,9 @@ static const struct pci_device_id skl_ids[] = {
 	/* BXT-P*/
 	{ PCI_DEVICE(0x8086, 0x5a98),
 		.driver_data = (unsigned long)&sst_bxtp_devdata},
+	/* CNL */
+	{ PCI_DEVICE(0x8086, 0x9df0),
+		.driver_data = (unsigned long)&sst_cnl_devdata},
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, skl_ids);
@@ -698,7 +711,9 @@ static struct pci_driver skl_driver = {
 	.probe = skl_probe,
 	.remove = skl_remove,
 	.driver = {
+#if 0
 		.pm = &skl_pm,
+#endif
 	},
 };
 module_pci_driver(skl_driver);
-- 
1.7.5.4

