From b16dad201267219b639dfc947925c5da023f8932 Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Tue, 17 May 2016 16:04:28 +0530
Subject: [PATCH 1971/2508] ASoC: Intel: Skylake: Re-download FW and library
 on resuming from S3

commit 287aac8441b620910b92fed9e70e1fb16f4eee3c from
https://github.com/01org/linux-apollolake-i

On platforms like BXT, where IMR is used to hold FW and library code,
the IMR may be invalidated during S3. Hence the FW and libraries need
to be re-loaded. On platforms like SKL which do not have IMR, FW is
re-loaded on every D3-D0 transition.

Change-Id: I3bbd63af64373aba2d1340c890d15d9bbbbcdfef
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9328
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c      |    6 ++++++
 sound/soc/intel/skylake/cnl-sst.c      |    6 ++++++
 sound/soc/intel/skylake/skl-messages.c |    2 +-
 sound/soc/intel/skylake/skl-sst-dsp.c  |   14 +++++++++++++-
 sound/soc/intel/skylake/skl-sst.c      |    2 +-
 sound/soc/intel/skylake/skl.c          |   13 ++++++++++++-
 6 files changed, 39 insertions(+), 4 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index e2903fd..ee2bf08 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -429,6 +429,12 @@ int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 
 	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
 
+	/* Re-download FW and library if needed. e.g. on coming back from S3 */
+	if (skl->fw_loaded == false) {
+		dev_dbg(ctx->dev, "Re-downloading FW on Resume\n");
+		return bxt_sst_dsp_init_fw(ctx->dev, skl);
+	}
+
 #ifdef BXT_ROM_BUG_WA
 	/* If core 0 is being turned on, turn on core 1 as well */
 	if (core_id == SKL_DSP_CORE0_ID)
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 01b8301..8ea0226 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -325,6 +325,12 @@ static int cnl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 
 	cnl->boot_complete = false;
 
+	/* Re-download FW and library if needed. e.g. on coming back from S3 */
+	if (cnl->fw_loaded == false) {
+		dev_dbg(ctx->dev, "Re-downloading FW on Resume\n");
+		return cnl_sst_dsp_init_fw(ctx->dev, cnl);
+	}
+
 	ret = cnl_dsp_enable_core(ctx, core_mask);
 	if (ret < 0) {
 		dev_err(ctx->dev, "enable DSP core %d failed: %d\n",
diff --git a/sound/soc/intel/skylake/skl-messages.c b/sound/soc/intel/skylake/skl-messages.c
index c8f26ab..b2c3dc0 100644
--- a/sound/soc/intel/skylake/skl-messages.c
+++ b/sound/soc/intel/skylake/skl-messages.c
@@ -364,7 +364,7 @@ int skl_resume_dsp(struct skl *skl)
 	snd_hdac_ext_bus_ppcap_enable(&skl->ebus, true);
 	snd_hdac_ext_bus_ppcap_int_enable(&skl->ebus, true);
 
-	if (ctx && ctx->fw_loaded) {
+	if (ctx) {
 		ret = skl_dsp_wake(ctx->dsp);
 		if (ret < 0)
 			return ret;
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.c b/sound/soc/intel/skylake/skl-sst-dsp.c
index 159c6db..764722c 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.c
+++ b/sound/soc/intel/skylake/skl-sst-dsp.c
@@ -338,6 +338,8 @@ irqreturn_t skl_dsp_sst_interrupt(int irq, void *dev_id)
 int skl_dsp_get_core(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret = 0;
+	bool update_usage_count = true;
+	struct skl_sst *skl = ctx->thread_context;
 
 	if (core_id >= ctx->core_info.cores) {
 		dev_err(ctx->dev, "invalid core id: %d\n", core_id);
@@ -347,11 +349,21 @@ int skl_dsp_get_core(struct sst_dsp *ctx, unsigned int core_id)
 	if (ctx->core_info.core_state[core_id] == SKL_DSP_RUNNING)
 		ctx->core_info.core_usage_count[core_id]++;
 	else if (ctx->core_info.core_state[core_id] == SKL_DSP_RESET) {
+		/*
+		 * If we are trying to get the core on resuming from S3, the FW
+		 * will be re downloaded by the set_state_D0() function. The
+		 * core_usage_counter gets initialized on FW re-load. So this
+		 * counter should not be updated here.
+		 */
+		if (skl->fw_loaded == false)
+			update_usage_count = false;
+
 		ret = ctx->fw_ops.set_state_D0(ctx, core_id);
 		if (ret < 0)
 			dev_err(ctx->dev, "unable to get core%d\n", core_id);
 		else
-			ctx->core_info.core_usage_count[core_id]++;
+			if (update_usage_count)
+				ctx->core_info.core_usage_count[core_id]++;
 	}
 	dev_info(ctx->dev, "%s:core id=%d:state=%d:usage_count=%d\n", __func__,
 			core_id, ctx->core_info.core_state[core_id],
diff --git a/sound/soc/intel/skylake/skl-sst.c b/sound/soc/intel/skylake/skl-sst.c
index 7f9ce8b..b2540de 100644
--- a/sound/soc/intel/skylake/skl-sst.c
+++ b/sound/soc/intel/skylake/skl-sst.c
@@ -162,7 +162,7 @@ static int skl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 
 	/* If core0 is being turned on, we need to load the FW */
 	if (core_id == SKL_DSP_CORE0_ID) {
-		ret = skl_load_base_firmware(ctx);
+		ret = skl_sst_dsp_init_fw(ctx->dev, skl);
 		if (ret < 0) {
 			dev_err(ctx->dev, "unable to load firmware\n");
 			return ret;
diff --git a/sound/soc/intel/skylake/skl.c b/sound/soc/intel/skylake/skl.c
index 6822a4b..76c1c4d 100644
--- a/sound/soc/intel/skylake/skl.c
+++ b/sound/soc/intel/skylake/skl.c
@@ -32,6 +32,8 @@
 #include <sound/hda_i915.h>
 #include <sound/compress_driver.h>
 #include "skl.h"
+#include "skl-sst-dsp.h"
+#include "skl-sst-ipc.h"
 
 static char *machine = NULL;
 
@@ -271,8 +273,17 @@ static int skl_suspend(struct device *dev)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
 	struct hdac_ext_bus *ebus = pci_get_drvdata(pci);
+	struct skl *skl = ebus_to_skl(ebus);
+	struct skl_sst *ctx = skl->skl_sst;
+	int ret;
 
-	return _skl_suspend(ebus);
+	ret = _skl_suspend(ebus);
+	if (ret < 0)
+		return ret;
+
+	ctx->fw_loaded = false;
+
+	return ret;
 }
 
 static int skl_resume(struct device *dev)
-- 
1.7.5.4

