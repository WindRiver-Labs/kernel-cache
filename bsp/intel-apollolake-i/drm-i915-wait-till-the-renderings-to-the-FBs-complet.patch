From e59b6d028a875c29fbc61196cfa5730eb7c9f828 Mon Sep 17 00:00:00 2001
From: "Xiong, James" <james.xiong@intel.com>
Date: Tue, 6 Sep 2016 13:23:24 -0700
Subject: [PATCH 64/68] drm/i915: wait till the renderings to the FBs complete
 for async atomic flip

commit 2ae06c40c22c8b30f9a8432726bdc00f3addd15b from
git://git.yoctoproject.org/linux-yocto-4.1

In async mode, The fb was flipped without waiting for the rendering to be
finished and caused flickering. The fix is to move the waiting to a function
shared by both sync and async code path, and apply waiting for both.

Note: the problem's been fixed in the latest upstream, this patch is only
for yocto gold release and no longer required once the latest upstream is
pulled in for MR1/MR2.

[removed unused plane and plane_state variables during commit - Bob]

Reviewed-by: Dongwon Kim <dongwon.kim@intel.com>
Signed-off-by: Xiong, James <james.xiong@intel.com>
Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/i915/intel_display.c |   55 +++++++++++++---------------------
 1 files changed, 21 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index a84691e..37b47d4 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -13587,9 +13587,7 @@ static int intel_atomic_prepare_commit(struct drm_device *dev,
 				       bool async)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct drm_plane_state *plane_state;
 	struct drm_crtc_state *crtc_state;
-	struct drm_plane *plane;
 	struct drm_crtc *crtc;
 	int i, ret;
 
@@ -13610,38 +13608,6 @@ static int intel_atomic_prepare_commit(struct drm_device *dev,
 		return ret;
 
 	ret = drm_atomic_helper_prepare_planes(dev, state);
-	if (!ret && !async && !i915_reset_in_progress(&dev_priv->gpu_error)) {
-		u32 reset_counter;
-
-		reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
-		mutex_unlock(&dev->struct_mutex);
-
-		for_each_plane_in_state(state, plane, plane_state, i) {
-			struct intel_plane_state *intel_plane_state =
-				to_intel_plane_state(plane_state);
-
-			if (!intel_plane_state->wait_req)
-				continue;
-
-			ret = __i915_wait_request(intel_plane_state->wait_req,
-						  reset_counter,
-						  I915_WAIT_REQUEST_INTERRUPTIBLE,
-						  NULL, NULL);
-
-			/* Swallow -EIO errors to allow updates during hw lockup. */
-			if (ret == -EIO)
-				ret = 0;
-
-			if (ret)
-				break;
-		}
-
-		if (!ret)
-			return 0;
-
-		mutex_lock(&dev->struct_mutex);
-		drm_atomic_helper_cleanup_planes(dev, state);
-	}
 
 	mutex_unlock(&dev->struct_mutex);
 	return ret;
@@ -13762,8 +13728,29 @@ static void finish_atomic_commit(struct work_struct *work)
 	bool hw_check = intel_state->modeset;
 	unsigned long put_domains[I915_MAX_PIPES] = {};
 	unsigned crtc_vblank_mask = 0;
+	struct drm_plane *plane;
+	struct drm_plane_state *plane_state;
+	u32 reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
 	int i;
 
+	for_each_plane_in_state(state, plane, plane_state, i) {
+		struct intel_plane_state *intel_plane_state;
+
+		if (plane_state == state->planes[i]->state)
+			continue;
+
+		intel_plane_state =
+			to_intel_plane_state(state->planes[i]->state);
+
+		if (!intel_plane_state->wait_req)
+			continue;
+
+		__i915_wait_request(intel_plane_state->wait_req,
+			reset_counter,
+			I915_WAIT_REQUEST_INTERRUPTIBLE,
+			NULL, NULL);
+	}
+
 	if (intel_state->modeset)
 		intel_display_power_get(dev_priv, POWER_DOMAIN_MODESET);
 
-- 
1.7.5.4

