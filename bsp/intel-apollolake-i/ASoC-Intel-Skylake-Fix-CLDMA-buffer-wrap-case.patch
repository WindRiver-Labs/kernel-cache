From c884a2a28fcc9272a1e6203f4dc7ef1f7e516327 Mon Sep 17 00:00:00 2001
From: Jeeja KP <jeeja.kp@intel.com>
Date: Fri, 13 Nov 2015 19:22:10 +0530
Subject: [PATCH 2002/2508] ASoC: Intel: Skylake: Fix CLDMA buffer wrap case

commit 68ae9890d38c7018c69e0e55d8215cbd4dd99faf from
https://github.com/01org/linux-apollolake-i

When downloading the firmware/module, if the ring buffer boundary
is reached, we need to wrap to the zeroth position. On next copy
we need to copy till end of buffer and the remaining buffer needs
to be copied from zeroth position.

In this case copy was not handled correctly when wrap condition
is reached which caused invalid data to be copied resulting in
invalid hash failure.

This patch fixes the issue by handling copy at the boundary
condition correctly.

Change-Id: I72dc4d17c9d9fb1b6ea5885ddaac3e235d68f9a8
Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
Signed-off-by: Vinod Koul <vinod.koul@intel.com>
Signed-off-by: Mark Brown <broonie@kernel.org>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9606
Reviewed-by: B, Jayachandran <jayachandran.b@intel.com>
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Jayanti, Satya Charitardha <satya.charitardha.jayanti@intel.com>
---
 sound/soc/intel/skylake/skl-sst-cldma.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-sst-cldma.c b/sound/soc/intel/skylake/skl-sst-cldma.c
index facbb53..b03d9db 100644
--- a/sound/soc/intel/skylake/skl-sst-cldma.c
+++ b/sound/soc/intel/skylake/skl-sst-cldma.c
@@ -181,9 +181,9 @@ static void skl_cldma_fill_buffer(struct sst_dsp *ctx, unsigned int size,
 	dev_dbg(ctx->dev, "spib position: %d\n", ctx->cl_dev.curr_spib_pos);
 
 	/*
-	 * Check if the size exceeds buffer boundry. if exceeds max_buffer
-	 * size, then copy till buffer size and then remaining buffer copy
-	 * to the start of ring buffer.
+	 * Check if the size exceeds buffer boundary. If it exceeds
+	 * max_buffer size, then copy till buffer size and then copy
+	 * remaining buffer from the start of ring buffer.
 	 */
 	if (ctx->cl_dev.dma_buffer_offset + size > ctx->cl_dev.bufsize) {
 		unsigned int size_b = ctx->cl_dev.bufsize -
-- 
1.7.5.4

