From f40f34fba73866b325f908f81b884915596a62d3 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Fri, 17 Jun 2016 09:33:19 +0200
Subject: [PATCH 3328/4706] drm: Only do the hw.lock cleanup in master_relase
 for !MODESET

commit 0de4cc99c66d2a46e92cd201f7939121d9a1bb23 upstream

Another place gone where modern drivers could have hit
dev->struct_mutex.

To avoid too deeply nesting control flow rework it a bit.

v2: Review from Chris:
- remove spurious newline.
- fix file_priv->master like for the !file_priv->is_master case.

Cc: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1466148814-8194-2-git-send-email-daniel.vetter@ffwll.ch
---
 drivers/gpu/drm/drm_auth.c |   20 +++++++++++---------
 1 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/drm_auth.c b/drivers/gpu/drm/drm_auth.c
index e015a7e..54ad64a 100644
--- a/drivers/gpu/drm/drm_auth.c
+++ b/drivers/gpu/drm/drm_auth.c
@@ -246,11 +246,13 @@ int drm_master_open(struct drm_file *file_priv)
 void drm_master_release(struct drm_file *file_priv)
 {
 	struct drm_device *dev = file_priv->minor->dev;
+	struct drm_master *master = file_priv->master;
 
 	mutex_lock(&dev->master_mutex);
-	if (file_priv->is_master) {
-		struct drm_master *master = file_priv->master;
+	if (!file_priv->is_master)
+		goto out;
 
+	if (!drm_core_check_feature(dev, DRIVER_MODESET)) {
 		/*
 		 * Since the master is disappearing, so is the
 		 * possibility to lock.
@@ -264,15 +266,15 @@ void drm_master_release(struct drm_file *file_priv)
 			wake_up_interruptible_all(&master->lock.lock_queue);
 		}
 		mutex_unlock(&dev->struct_mutex);
-
-		if (file_priv->minor->master == file_priv->master) {
-			/* drop the reference held my the minor */
-			if (dev->driver->master_drop)
-				dev->driver->master_drop(dev, file_priv, true);
-			drm_master_put(&file_priv->minor->master);
-		}
 	}
 
+	if (file_priv->minor->master == file_priv->master) {
+		/* drop the reference held my the minor */
+		if (dev->driver->master_drop)
+			dev->driver->master_drop(dev, file_priv, true);
+		drm_master_put(&file_priv->minor->master);
+	}
+out:
 	/* drop the master reference held by the file priv */
 	if (file_priv->master)
 		drm_master_put(&file_priv->master);
-- 
1.7.5.4

