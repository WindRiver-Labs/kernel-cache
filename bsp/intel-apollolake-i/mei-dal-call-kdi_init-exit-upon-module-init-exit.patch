From ea8d62edf7689bcc59557da0096ca1784cc9d408 Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Sun, 18 Dec 2016 14:14:24 +0200
Subject: [PATCH 4651/4706] mei: dal: call kdi_init/exit upon module init/exit

commit 3ce275d788e04b59a9e7ea0f8b5bc497a0518ef8 from
git://git.yoctoproject.org/linux-yocto-4.1

Due to removing the communication with FW from the init flow
kdi initialization can be moved to the dal module init handler.
The same pays for exit function.

Change-Id: Icb431239a19f879c8f497d98884a2714a0aecf23
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_class.c |    8 ++
 drivers/misc/mei/dal/dal_dev.h   |    3 +
 drivers/misc/mei/dal/dal_kdi.c   |  131 ++++++++++++++++++--------------------
 3 files changed, 72 insertions(+), 70 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index b4c246f..f943c23 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -720,6 +720,8 @@ static void __exit mei_dal_exit(void)
 
 	dal_dev_exit();
 
+	dal_kdi_exit();
+
 	class_destroy(dal_class);
 }
 
@@ -737,6 +739,10 @@ static int __init mei_dal_init(void)
 	if (ret < 0)
 		goto err_class;
 
+	ret = dal_kdi_init();
+	if (ret)
+		goto err_dev;
+
 	ret = mei_cldev_driver_register(&dal_driver);
 	if (ret < 0) {
 		pr_err("mei_cl_driver_register failed with status = %d\n", ret);
@@ -746,6 +752,8 @@ static int __init mei_dal_init(void)
 	return 0;
 
 err:
+	dal_kdi_exit();
+err_dev:
 	dal_dev_exit();
 err_class:
 	class_destroy(dal_class);
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 14e313c..7f29f86 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -236,4 +236,7 @@ int dal_access_list_init(struct dal_device *ddev);
 int kdi_send(unsigned int handle, const unsigned char *buf,
 	     size_t len, u64 seq);
 int kdi_recv(unsigned int handle, unsigned char *buf, size_t *count);
+
+int dal_kdi_init(void);
+void dal_kdi_exit(void);
 #endif  /* _DAL_KDI_H_ */
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 7b21933..2126dbb 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -71,7 +71,6 @@
 #include "bhp_impl.h"
 #include "dal_dev.h"
 
-static atomic_t kdi_ref_count = ATOMIC_INIT(0);
 static DEFINE_MUTEX(kdi_lock);
 
 #define BH_MSG_MAGIC_LENGTH            4
@@ -116,35 +115,6 @@ static int bh_err_to_kdi_err(int bh_err)
 	}
 }
 
-static int kdi_add_dev(struct device *dev,
-		       struct class_interface *class_intf)
-{
-	int ret;
-	struct dal_device *ddev;
-
-	ddev = to_dal_device(dev);
-	mutex_lock(&ddev->context_lock);
-	ret = dal_dc_setup(ddev, DAL_INTF_KDI);
-	mutex_unlock(&ddev->context_lock);
-	return ret;
-}
-
-static void kdi_rm_dev(struct device *dev,
-		       struct class_interface *class_intf)
-{
-	struct dal_device *ddev;
-
-	ddev = to_dal_device(dev);
-	mutex_lock(&ddev->context_lock);
-	dal_dc_destroy(ddev, DAL_INTF_KDI);
-	mutex_unlock(&ddev->context_lock);
-}
-
-static struct class_interface kdi_interface __refdata = {
-	.add_dev        = kdi_add_dev,
-	.remove_dev     = kdi_rm_dev,
-};
-
 int kdi_send(unsigned int handle, const unsigned char *buf,
 	     size_t len, u64 seq)
 {
@@ -312,28 +282,9 @@ static inline bool kdi_check_handle(u64 handle)
 
 int kdi_init(u32 flags, u64 *handle)
 {
-	int ret, bh_err;
-
 	if (!handle)
 		return DAL_KDI_STATUS_INVALID_PARAMS;
 
-	if (atomic_inc_return(&kdi_ref_count) > 1)
-		goto out;
-
-	kdi_interface.class = dal_class;
-	ret = class_interface_register(&kdi_interface);
-	if (ret)
-		return DAL_KDI_STATUS_INTERNAL_ERROR;
-
-	bh_err = bhp_init_internal();
-	ret = bh_err_to_kdi_err(bh_err);
-	if (bh_err) {
-		class_interface_unregister(&kdi_interface);
-		pr_err("BHP_Init failed with status = %d\n", bh_err);
-		return ret;
-	}
-out:
-
 	*handle = (u64)dal_class;
 	return DAL_KDI_SUCCESS;
 }
@@ -341,22 +292,11 @@ EXPORT_SYMBOL(kdi_init);
 
 int kdi_deinit(u64 handle)
 {
-	int ret, bh_err;
-
 	/* check handle first */
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
-	ret = DAL_KDI_SUCCESS;
-	if (atomic_dec_if_positive(&kdi_ref_count) == 0) {
-		class_interface_unregister(&kdi_interface);
-		bh_err = bhp_deinit_internal();
-		ret = bh_err_to_kdi_err(bh_err);
-		if (bh_err)
-			pr_warn("bhp_deinit_internal failed: = %d\n", bh_err);
-	}
-
-	return ret;
+	return 0;
 }
 EXPORT_SYMBOL(kdi_deinit);
 
@@ -370,9 +310,6 @@ int dal_create_session(u64 handle,
 {
 	int ret;
 
-	if (atomic_read(&kdi_ref_count) == 0)
-		return DAL_KDI_STATUS_NOT_INITIALIZED;
-
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
@@ -401,9 +338,6 @@ int dal_send_and_receive(u64 handle,
 {
 	int ret, bh_err;
 
-	if (atomic_read(&kdi_ref_count) == 0)
-		return DAL_KDI_STATUS_NOT_INITIALIZED;
-
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
@@ -427,9 +361,6 @@ int dal_close_session(u64 handle, u64 session_handle)
 {
 	int ret, bh_err;
 
-	if (atomic_read(&kdi_ref_count) == 0)
-		return DAL_KDI_STATUS_NOT_INITIALIZED;
-
 	if (!kdi_check_handle(handle))
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 
@@ -560,3 +491,63 @@ int dal_get_version_info(struct dal_version_info *version_info)
 	return 0;
 }
 EXPORT_SYMBOL(dal_get_version_info);
+
+static int kdi_add_dev(struct device *dev,
+		       struct class_interface *class_intf)
+{
+	int ret;
+	struct dal_device *ddev;
+
+	ddev = to_dal_device(dev);
+	mutex_lock(&ddev->context_lock);
+	ret = dal_dc_setup(ddev, DAL_INTF_KDI);
+	mutex_unlock(&ddev->context_lock);
+	return ret;
+}
+
+static void kdi_rm_dev(struct device *dev,
+		       struct class_interface *class_intf)
+{
+	struct dal_device *ddev;
+
+	ddev = to_dal_device(dev);
+	mutex_lock(&ddev->context_lock);
+	dal_dc_destroy(ddev, DAL_INTF_KDI);
+	mutex_unlock(&ddev->context_lock);
+}
+
+static struct class_interface kdi_interface __refdata = {
+	.add_dev    = kdi_add_dev,
+	.remove_dev = kdi_rm_dev,
+};
+
+int dal_kdi_init(void)
+{
+	int bh_err;
+	int ret;
+
+	bh_err = bhp_init_internal();
+	if (bh_err) {
+		pr_err("bhp_init: failed with status = 0x%x\n", bh_err);
+		return  -EFAULT;
+	}
+
+	kdi_interface.class = dal_class;
+	ret = class_interface_register(&kdi_interface);
+	if (ret) {
+		pr_err("failed reister class interface = %d\n", ret);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	bhp_deinit_internal();
+	return ret;
+}
+
+void dal_kdi_exit(void)
+{
+	bhp_deinit_internal();
+	class_interface_unregister(&kdi_interface);
+}
-- 
1.7.5.4

