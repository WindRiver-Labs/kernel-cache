From 8e39ae0971857a4779a730cbd79507459b581932 Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Wed, 10 Feb 2016 18:39:11 -0800
Subject: [PATCH 1412/2508] drm: Add infrastructure for CRTC background color
 property (v2)

commit 3a4557e9651947ec46f0f23d9980d375193360c2 from
https://github.com/01org/linux-apollolake-i

To support CRTC background color, we need a way of communicating RGB
color values to the DRM.  However there is often a mismatch between how
userspace wants to represent the color value vs how it must be
programmed into the hardware; this mismatch can easily lead to
non-obvious bugs.  Let's create a kernel-side property type that
standardizes the user<->kernel format and add some macros that allow
drivers to extract the bits they care about without having to worry
about the internal representation.  This RGBA property type may also be
useful for future properties like color keys.

These properties are still exposed to userspace as range properties, so
the only userspace change we need are some helpers to build RGBA values
appropriately.

v2:
 - Just use 'struct rgba' rather than a typedef as our opaque RGBA
   datatype. (Emil)
 - Actually use drm_property_create_rgba() to create the background
   color property. (Bob)
 - Add helper to build 64-bit RGBA internal value in appropriate format
   (e.g., for the initial value when attaching a property).  (Bob)

Cc: dri-devel@lists.freedesktop.org
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/drm_atomic.c |    4 ++
 drivers/gpu/drm/drm_crtc.c   |   39 ++++++++++++++++++
 include/drm/drm_crtc.h       |   92 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 135 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c
index a2596eb..58e950a 100644
--- a/drivers/gpu/drm/drm_atomic.c
+++ b/drivers/gpu/drm/drm_atomic.c
@@ -456,6 +456,8 @@ int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
 
 	if (property == config->prop_active)
 		state->active = val;
+	else if (property == config->prop_background_color)
+		state->background_color.v = val;
 	else if (property == config->prop_mode_id) {
 		struct drm_property_blob *mode =
 			drm_property_lookup_blob(dev, val);
@@ -528,6 +530,8 @@ drm_atomic_crtc_get_property(struct drm_crtc *crtc,
 		*val = (state->ctm) ? state->ctm->base.id : 0;
 	else if (property == config->gamma_lut_property)
 		*val = (state->gamma_lut) ? state->gamma_lut->base.id : 0;
+	else if (property == config->prop_background_color)
+		*val = state->background_color.v;
 	else if (crtc->funcs->atomic_get_property)
 		return crtc->funcs->atomic_get_property(crtc, state, property, val);
 	else
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 88b69ff..2fb5cf0 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -3955,6 +3955,30 @@ struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
 EXPORT_SYMBOL(drm_property_create_bool);
 
 /**
+ * drm_property_create_rgba - create a new RGBA property type
+ * @dev: drm device
+ * @flags: flags specifying the property type
+ * @name: name of the property
+ *
+ * This creates a new generic drm property which can then be attached to a drm
+ * object with drm_object_attach_property. The returned property object must be
+ * freed with drm_property_destroy.
+ *
+ * Userspace should use the DRM_RGBA() macro to build values with the proper
+ * bit layout.
+ *
+ * Returns:
+ * A pointer to the newly created property on success, NULL on failure.
+ */
+struct drm_property *drm_property_create_rgba(struct drm_device *dev, int flags,
+					      const char *name)
+{
+	return drm_property_create_range(dev, flags, name,
+					 0, GENMASK_ULL(63, 0));
+}
+EXPORT_SYMBOL(drm_property_create_rgba);
+
+/**
  * drm_property_add_enum - add a possible value to an enumeration property
  * @property: enumeration property to change
  * @index: index of the new enumeration
@@ -5967,6 +5991,21 @@ struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 EXPORT_SYMBOL(drm_mode_create_rotation_property);
 
 /**
+ * drm_mode_create_background_color_property - create CRTC color property
+ * @dev: DRM device
+ *
+ * Creates a property to represent CRTC background/canvas color.  Called by a
+ * driver the first time it's needed, must be attached to desired CRTC's.
+ */
+struct drm_property *
+drm_mode_create_background_color_property(struct drm_device *dev)
+{
+	return drm_property_create_rgba(dev, DRM_MODE_PROP_ATOMIC,
+					 "background_color");
+}
+EXPORT_SYMBOL(drm_mode_create_background_color_property);
+
+/**
  * DOC: Tile group
  *
  * Tile groups are used to represent tiled monitors with a unique
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index fb96727..f18a425 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -297,6 +297,90 @@ struct drm_connector_helper_funcs;
 struct drm_plane_helper_funcs;
 
 /**
+ * struct drm_rgba - RGBA property value type
+ * @v: Internal representation of RGBA, stored in 16bpc format
+ *
+ * Structure to abstract away the representation of RGBA values with precision
+ * up to 16 bits per color component.  This is primarily intended for use with
+ * DRM properties that need to take a color value since we don't want userspace
+ * to have to worry about the bit layout expected by the underlying hardware.
+ *
+ * We wrap the value in a structure here so that the compiler will flag any
+ * accidental attempts by driver code to directly attempt bitwise operations
+ * that could potentially misinterpret the value.  Drivers should instead use
+ * the DRM_RGBA_{RED,GREEN,BLUE,ALPHA}BITS() macros to obtain the component
+ * bits and then build values in the format their hardware expects.
+ */
+struct drm_rgba {
+	uint64_t v;
+};
+
+/**
+ * drm_rgba - Build RGBA property values
+ * @bpc: Bits per component value for @red, @green, @blue, and @alpha parameters
+ * @red: Red component value
+ * @green: Green component value
+ * @blue: Blue component value
+ * @alpha: Alpha component value
+ *
+ * Helper to build RGBA 16bpc color values with the bits laid out in the format
+ * expected by DRM RGBA properties.
+ *
+ * Returns:
+ * An RGBA structure encapsulating the requested RGBA value.
+ */
+static inline struct drm_rgba
+drm_rgba(unsigned bpc,
+	 uint16_t red,
+	 uint16_t green,
+	 uint16_t blue,
+	 uint16_t alpha)
+{
+	int shift;
+	struct drm_rgba val;
+
+	if (WARN_ON(bpc > 16))
+		bpc = 16;
+
+	/*
+	 * If we were provided with fewer than 16 bpc, shift the value we
+	 * received into the most significant bits.
+	 */
+	shift = 16 - bpc;
+
+	val.v = red << shift;
+	val.v <<= 16;
+	val.v |= green << shift;
+	val.v <<= 16;
+	val.v |= blue << shift;
+	val.v <<= 16;
+	val.v |= alpha << shift;
+
+	return val;
+}
+
+static inline uint16_t
+drm_rgba_bits(struct drm_rgba c, unsigned compshift, unsigned bits) {
+	uint64_t val;
+
+	if (WARN_ON(bits > 16))
+		bits = 16;
+
+	val = c.v & GENMASK_ULL(compshift + 15, compshift);
+	return val >> (compshift + 16 - bits);
+}
+
+/*
+ * Macros to access the individual color components of an RGBA property value.
+ * If the requested number of bits is less than 16, only the most significant
+ * bits of the color component will be returned.
+ */
+#define DRM_RGBA_REDBITS(c, bits)   drm_rgba_bits(c, 48, bits)
+#define DRM_RGBA_GREENBITS(c, bits) drm_rgba_bits(c, 32, bits)
+#define DRM_RGBA_BLUEBITS(c, bits)  drm_rgba_bits(c, 16, bits)
+#define DRM_RGBA_ALPHABITS(c, bits) drm_rgba_bits(c, 0, bits)
+
+/**
  * struct drm_crtc_state - mutable CRTC state
  * @crtc: backpointer to the CRTC
  * @enable: whether the CRTC should be enabled, gates all other state
@@ -319,6 +403,7 @@ struct drm_plane_helper_funcs;
  * @ctm: Transformation matrix
  * @gamma_lut: Lookup table for converting pixel data after the
  *	conversion matrix
+ * @background_color: background/canvas color of regions not covered by planes
  * @event: optional pointer to a DRM event to signal upon completion of the
  * 	state update
  * @state: backpointer to global drm_atomic_state
@@ -368,6 +453,9 @@ struct drm_crtc_state {
 	struct drm_property_blob *ctm;
 	struct drm_property_blob *gamma_lut;
 
+	/* CRTC background color */
+	struct drm_rgba background_color;
+
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;
@@ -2127,6 +2215,7 @@ struct drm_mode_config {
 	struct drm_property *prop_crtc_id;
 	struct drm_property *prop_active;
 	struct drm_property *prop_mode_id;
+	struct drm_property *prop_background_color;
 
 	/* DVI-I properties */
 	struct drm_property *dvi_i_subconnector_property;
@@ -2408,6 +2497,8 @@ struct drm_property *drm_property_create_object(struct drm_device *dev,
 					 int flags, const char *name, uint32_t type);
 struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
 					 const char *name);
+struct drm_property *drm_property_create_rgba(struct drm_device *dev,
+					      int flags, const char *name);
 struct drm_property_blob *drm_property_create_blob(struct drm_device *dev,
                                                    size_t length,
                                                    const void *data);
@@ -2540,6 +2631,7 @@ extern int drm_format_plane_height(int height, uint32_t format, int plane);
 extern const char *drm_get_format_name(uint32_t format);
 extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 							      unsigned int supported_rotations);
+extern struct drm_property *drm_mode_create_background_color_property(struct drm_device *dev);
 extern unsigned int drm_rotation_simplify(unsigned int rotation,
 					  unsigned int supported_rotations);
 
-- 
1.7.5.4

