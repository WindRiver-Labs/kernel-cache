From e8d15d60edb9a86d2321a039da7dd1c5d26be979 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Thu, 4 Feb 2016 12:30:57 +0200
Subject: [PATCH 0080/2508] spi: pxa2xx: Fix too early chipselect deassert

commit 7a8d44bc89e5cddcd5c0704a11a90484d36ba6ba upstream

There is a chance that chipselect is deasserted too early while the last
clock cycle is still running. Protocol analyzers will see this as a failed
last byte. This is more likely to occur with slow bitrates, for instance
at 25 kbps.

Reason for this is when using SPI mode 0 that both SPI host controller and
SPI slave will drive the data lines at the falling edge of clock signal
and sample at the rising edge. Receive FIFO gets the last bit now at the
rising edge and code sees transfer to be finished either by the interrupt
in PIO mode or by the DMA completion in DMA mode.

The SSP Time Out register SSTO should take care of delaying the
completion but it does not seems to have effect at least on Intel
Skylake and Broxton even when using long enough values. Depending on
timing code may get into point where chipselect is deasserted while the
last clock cycle is still running at its second half cycle.

Fix this by adding a wait loop in giveback() that waits until SSP becomes
idle before deasserting the chipselect.

Reported-by: Weifeng Voon <weifeng.voon@intel.com>
Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Signed-off-by: Mark Brown <broonie@kernel.org>
---
 drivers/spi/spi-pxa2xx.c |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index 9b9a528..ce66cf4 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -496,6 +496,7 @@ static void giveback(struct driver_data *drv_data)
 {
 	struct spi_transfer* last_transfer;
 	struct spi_message *msg;
+	unsigned long timeout;
 
 	msg = drv_data->cur_msg;
 	drv_data->cur_msg = NULL;
@@ -508,6 +509,12 @@ static void giveback(struct driver_data *drv_data)
 	if (last_transfer->delay_usecs)
 		udelay(last_transfer->delay_usecs);
 
+	/* Wait until SSP becomes idle before deasserting the CS */
+	timeout = jiffies + msecs_to_jiffies(10);
+	while (pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY &&
+	       !time_after(jiffies, timeout))
+		cpu_relax();
+
 	/* Drop chip select UNLESS cs_change is true or we are returning
 	 * a message with an error, or next message is for another chip
 	 */
-- 
1.7.5.4

