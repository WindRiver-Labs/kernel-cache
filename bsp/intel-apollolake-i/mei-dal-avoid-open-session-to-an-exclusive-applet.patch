From e83b9b85b6627fc876e57e632a7d6a7bfec1c40c Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Thu, 3 Nov 2016 09:26:33 +0200
Subject: [PATCH 4642/4706] mei: dal: avoid open session to an exclusive
 applet

commit 863d970ca45de4c4398e2d272a90efd835aa4f69 from
git://git.yoctoproject.org/linux-yocto-4.1

Apply filter on the message command headers.
Command header is alwyas the first fragment of the packet.

Change-Id: I75eaf162c6e373d52234bfef1a5f4ef658370742
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/bhp_impl.h    |   18 ++++++
 drivers/misc/mei/dal/bhp_impl_ta.c |  120 ++++++++++++++++++++++++++++++++++--
 drivers/misc/mei/dal/dal_class.c   |  101 ++++++++++++++++++++----------
 3 files changed, 201 insertions(+), 38 deletions(-)

diff --git a/drivers/misc/mei/dal/bhp_impl.h b/drivers/misc/mei/dal/bhp_impl.h
index b65fc154..9d2b331 100644
--- a/drivers/misc/mei/dal/bhp_impl.h
+++ b/drivers/misc/mei/dal/bhp_impl.h
@@ -174,6 +174,24 @@ int bh_do_open_vm(uuid_be sdid, int *conn_idx, int mode);
 /* decrease vm connection counter by 1 */
 int bh_do_close_vm(int conn_idx);
 
+/* return error when invalid msg */
+typedef int (*bh_filter_func)(const char *msg, size_t count, void *ctx);
+int bh_filter_msg(const char *msg, size_t count, void *ctx,
+		  const bh_filter_func tbl[]);
+/* true when msg it is open sessio cmd */
+bool bh_msg_is_cmd_open_session(const char *msg);
+
+/* retrives ta_id from the open session */
+const uuid_be *bh_open_session_ta_id(const char *hdr, size_t count);
+
+/* prepare and return response of access denied error */
+void bh_prep_access_denied_response(const char *cmd,
+				    struct bhp_response_header *res);
+
+bool bh_msg_is_response(const char *hdr);
+bool bh_msg_is_spooler(const char *hdr);
+bool bh_msg_is_cmd(const char *hdr);
+
 #define mutex_enter(s) {}
 #define mutex_exit(s)  {}
 
diff --git a/drivers/misc/mei/dal/bhp_impl_ta.c b/drivers/misc/mei/dal/bhp_impl_ta.c
index faa2f03..a61ea1b 100644
--- a/drivers/misc/mei/dal/bhp_impl_ta.c
+++ b/drivers/misc/mei/dal/bhp_impl_ta.c
@@ -73,11 +73,6 @@
 #include "bh_errcode.h"
 #include "bhp_impl.h"
 
-enum bhp_vm_mode {
-	BHP_OPEN_VM_QUERY_MODE = 0,
-	BHP_OPEN_VM_NORMAL_MODE = 1
-};
-
 static bool uuid_is_valid_hyphenless(const char *uuid_str)
 {
 	unsigned int i;
@@ -115,6 +110,84 @@ static int __uuid_be_to_bin(const char *uuid_str, uuid_be *uuid)
 	return uuid_be_to_bin(uuid_str, uuid);
 }
 
+/*
+ * 4 bytes array to identify BH headers
+ */
+static const u8 BH_MSG_SPLR_MAGIC[]  = {0x53, 0x50, 0x4c, 0x52};
+static const u8 BH_MSG_RESP_MAGIC[]  = {0xff, 0xa5, 0xaa, 0x55};
+static const u8 BH_MSG_CMD_MAGIC[]   = {0xff, 0xa3, 0xaa, 0x55};
+
+/* Check for response msg */
+bool bh_msg_is_response(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_RESP_MAGIC, sizeof(BH_MSG_RESP_MAGIC));
+}
+
+/* Check for spoolar msg */
+bool bh_msg_is_spooler(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_SPLR_MAGIC, sizeof(BH_MSG_SPLR_MAGIC));
+}
+
+/* Check for command msg */
+bool bh_msg_is_cmd(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_CMD_MAGIC, sizeof(BH_MSG_CMD_MAGIC));
+}
+
+static bool bh_cmd_is_valid(struct bhp_command_header *hdr, size_t len)
+{
+	return (len >= sizeof(struct bhp_command_header));
+}
+
+static const
+struct bhp_command_header *bh_msg_cmd_hdr(const char *msg, size_t len)
+{
+	struct bhp_command_header *hdr;
+
+	if (!bh_msg_is_cmd(msg))
+		return NULL;
+
+	hdr = (struct bhp_command_header *)msg;
+
+	if (!bh_cmd_is_valid(hdr, len))
+		return NULL;
+
+	return hdr;
+}
+
+bool bh_msg_is_cmd_open_session(const char *msg)
+{
+	struct bhp_command_header *hdr;
+
+	if (!bh_msg_is_cmd(msg))
+		return 0;
+
+	hdr = (struct bhp_command_header *)msg;
+	return hdr->id == BHP_CMD_OPEN_JTASESSION;
+}
+
+const uuid_be *bh_open_session_ta_id(const char *hdr, size_t count)
+{
+	struct bhp_command_header *cmd_hdr;
+	struct bhp_open_jtasession_cmd *open_cmd;
+
+	if (count < sizeof(struct bhp_command_header) +
+		sizeof(struct bhp_open_jtasession_cmd))
+		return NULL;
+
+	cmd_hdr = (struct bhp_command_header *)hdr;
+	open_cmd = (struct bhp_open_jtasession_cmd *)cmd_hdr->cmd;
+
+	return &open_cmd->appid;
+}
+
+
+enum bhp_vm_mode {
+	BHP_OPEN_VM_QUERY_MODE = 0,
+	BHP_OPEN_VM_NORMAL_MODE = 1
+};
+
 /* try to session_enter for IVM, then SVM */
 static struct bh_response_record *
 session_enter_vm(u64 seq, int *conn_idx, int lock_session)
@@ -598,3 +671,40 @@ int bhp_close_ta_session(const u64 handle)
 
 	return ret;
 }
+
+int bh_filter_msg(const char *msg, size_t count, void *ctx,
+		  const bh_filter_func tbl[])
+{
+	int i;
+	int ret;
+	const struct bhp_command_header *hdr;
+
+	if (count < BHP_MSG_MAGIC_LENGTH)
+		return -EINVAL;
+
+	if (!bh_msg_is_cmd(msg))
+		return 0;
+
+	hdr = bh_msg_cmd_hdr(msg, count);
+	if (!hdr)
+		return -EINVAL;
+
+	for (i = 0; tbl[i]; i++) {
+		ret = tbl[i](msg, count, ctx);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+void bh_prep_access_denied_response(const char *cmd,
+				    struct bhp_response_header *res)
+{
+	struct bhp_command_header *cmd_hdr = (struct bhp_command_header *)cmd;
+
+	memcpy(res->h.magic, BHP_MSG_RESPONSE_MAGIC, BHP_MSG_MAGIC_LENGTH);
+	res->h.length = sizeof(struct bhp_response_header);
+	res->code = BHE_OPERATION_NOT_PERMITTED;
+	res->seq = cmd_hdr->seq;
+}
+
diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index d18825c..52361ea 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -89,31 +89,6 @@
  */
 struct class *dal_class;
 
-/*
- * 4 bytes array to identify BH headers
- */
-static const u8 BH_MSG_SPLR_MAGIC[]  = {0x53, 0x50, 0x4c, 0x52};
-static const u8 BH_MSG_RESP_MAGIC[]  = {0xff, 0xa5, 0xaa, 0x55};
-static const u8 BH_MSG_CMD_MAGIC[]   = {0xff, 0xa3, 0xaa, 0x55};
-
-/* Check for response msg */
-static inline bool dal_msg_is_response(const char *hdr)
-{
-	return !memcmp(hdr, BH_MSG_RESP_MAGIC, sizeof(BH_MSG_RESP_MAGIC));
-}
-
-/* Check for spoolar msg */
-static inline bool dal_msg_is_spooler(const char *hdr)
-{
-	return !memcmp(hdr, BH_MSG_SPLR_MAGIC, sizeof(BH_MSG_SPLR_MAGIC));
-}
-
-/* Check for command msg */
-static inline bool dal_msg_is_cmd(const char *hdr)
-{
-	return !memcmp(hdr, BH_MSG_CMD_MAGIC, sizeof(BH_MSG_CMD_MAGIC));
-}
-
 /* comperator for cl devices */
 static int dal_dev_match(struct device *dev, const void *data)
 {
@@ -183,6 +158,56 @@ static int dal_wait_for_write(struct dal_device *ddev, struct dal_client *dc)
 	return 0;
 }
 
+/* put response msg with error code 'access denied' in client's queue */
+static int dal_send_error_access_denied(struct dal_client *dc)
+{
+	struct dal_device *ddev = dc->ddev;
+	struct bhp_response_header res;
+	size_t len;
+	int ret;
+
+	mutex_lock(&ddev->context_lock);
+
+	bh_prep_access_denied_response(dc->write_buffer, &res);
+	len = sizeof(res);
+
+	ret = kfifo_in(&dc->read_queue, &len, sizeof(len));
+	ret += kfifo_in(&dc->read_queue, &res, len);
+	if (ret < len + sizeof(len)) {
+		dev_err(&ddev->dev, "queue is full - access denied MSG THROWN");
+		mutex_unlock(&ddev->context_lock);
+		return -ENOMEM;
+	}
+
+	dev_dbg(&ddev->dev, "calls wake_up_interruptible\n");
+	wake_up_interruptible(&ddev->wq);
+
+	mutex_unlock(&ddev->context_lock);
+
+	return 0;
+}
+
+static int dal_validate_access(const char *msg, size_t count, void *ctx)
+{
+	struct dal_client *dc = ctx;
+	struct dal_device *ddev = dc->ddev;
+	const uuid_be *ta_id;
+
+	if (!bh_msg_is_cmd_open_session(msg))
+		return 0;
+
+	ta_id = bh_open_session_ta_id(msg, count);
+	if (!ta_id)
+		return -EINVAL;
+
+	return dal_access_policy_allowed(ddev, *ta_id, dc);
+}
+
+static const bh_filter_func dal_write_filter_tbl[] = {
+	dal_validate_access,
+	NULL,
+};
+
 /* Write BH msg via MEI*/
 ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 {
@@ -191,7 +216,7 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	struct device *dev;
 	ssize_t wr;
 	ssize_t ret;
-	int status; /* debug */
+	int status;
 	enum dal_intf intf = dc->intf;
 	struct dal_client *curr_wc; /* debug */
 
@@ -206,11 +231,21 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 
 	/* update client on latest msg seq number*/
 	dc->seq = seq;
-	dev_dbg(dev, "current_write_client seq = %llu",
-			dc->seq);
+	dev_dbg(dev, "current_write_client seq = %llu", dc->seq);
 
 	/* put dc in write queue*/
 	if (ddev->current_write_client != dc) {
+		/* adding client to write queue - this is the first fragment */
+		ret = bh_filter_msg(dc->write_buffer, count, dc, dal_write_filter_tbl);
+		if (ret == -EPERM) {
+			ret = dal_send_error_access_denied(dc);
+			ret = ret ?: count;
+		}
+		if (ret) {
+			mutex_unlock(&ddev->write_queue_lock);
+			return ret;
+		}
+
 		if (kfifo_is_empty(&ddev->write_queue))
 			ddev->current_write_client = dc;
 
@@ -271,7 +306,7 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	 * as the response from the FW is async and may never occur
 	 */
 	/* TODO: we can remove this check and look only on the size */
-	if (dal_msg_is_spooler(dc->write_buffer)) {
+	if (bh_msg_is_spooler(dc->write_buffer)) {
 		ret = wr;
 		dev_dbg(dev, "SPOOLER msg command id = %d", header->id);
 		goto out;
@@ -281,7 +316,7 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	/* header msg is being sent,
 	 * this is the first fragment of the message
 	 */
-	if (dal_msg_is_cmd(dc->write_buffer)) {
+	if (bh_msg_is_cmd(dc->write_buffer)) {
 		dc->expected_msg_size_to_fw = header->h.length;
 		dev_dbg(dev, "This is first fragment - client type %d",
 				intf);
@@ -367,7 +402,7 @@ static void dal_dc_update_read_state(struct dal_client *dc, ssize_t len)
 			(struct transport_msg_header *)dc->ddev->bh_fw_msg.msg;
 
 	/* check BH msg magic, if it exists this is the header */
-	if (dal_msg_is_response(ddev->bh_fw_msg.msg)) {
+	if (bh_msg_is_response(ddev->bh_fw_msg.msg)) {
 		dc->expected_msg_size_from_fw = header->length;
 		dev_dbg(&ddev->dev, "expected_msg_size_from_fw = %d bytes read = %zd",
 			dc->expected_msg_size_from_fw, len);
@@ -439,11 +474,11 @@ static void dal_recv_cb(struct mei_cl_device *cldev, u32 events, void *context)
 	 *
 	 * Do not change the order of this ifs
 	 */
-	if (dal_msg_is_response(ddev->bh_fw_msg.msg)) {
+	if (bh_msg_is_response(ddev->bh_fw_msg.msg)) {
 		intf = get_client_by_squence_number(ddev);
 		dev_dbg(&ddev->dev, "recv_cb(): Client set by sequence number");
 		dc = ddev->clients[intf];
-	} else if (dal_msg_is_spooler(ddev->bh_fw_msg.msg)) {
+	} else if (bh_msg_is_spooler(ddev->bh_fw_msg.msg)) {
 		intf = DAL_INTF_CDEV;
 		dev_dbg(&ddev->dev, "recv_cb(): EVENT msg received");
 		dc = ddev->clients[intf];
-- 
1.7.5.4

