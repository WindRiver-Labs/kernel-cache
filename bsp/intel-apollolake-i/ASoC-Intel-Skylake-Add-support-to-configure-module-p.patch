From 50c398228c57365b4ae46bb4542b43cb239a917b Mon Sep 17 00:00:00 2001
From: Jeeja KP <jeeja.kp@intel.com>
Date: Mon, 10 Aug 2015 05:45:25 +0530
Subject: [PATCH 1703/2508] ASoC: Intel: Skylake: Add support to configure
 module params

commit 30ea7f236d2138c9151a066780df7bac5c659df8 from
https://github.com/01org/linux-apollolake-i

This adds support to configure module parameter during module
initialization or after module init using set module param
required by the DSP firmware sequence.

Signed-off-by: Jeeja KP <jeeja.kp@intel.com>
---
 sound/soc/intel/skylake/skl-topology.c       |   87 +++++++++++++++++++++++++-
 sound/soc/intel/skylake/skl-topology.h       |    3 +
 sound/soc/intel/skylake/skl-tplg-interface.h |    2 +
 3 files changed, 91 insertions(+), 1 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-topology.c b/sound/soc/intel/skylake/skl-topology.c
index 9cfd272..5b14647 100644
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@ -314,6 +314,83 @@ static int skl_tplg_alloc_pipe_widget(struct device *dev,
 }
 
 /*
+ * some modules can have mutiple params set from user control and
+ * need to be set after module is initalized. if set_param flag is
+ * set module params will be done after module is initalised.
+ */
+static int skl_tplg_set_module_params(struct snd_soc_dapm_widget *w,
+						struct skl_sst *ctx)
+{
+	int i, ret;
+	struct skl_module_cfg *mconfig = w->priv;
+	const struct snd_kcontrol_new *k;
+	struct soc_bytes_ext *sb;
+	struct skl_algo_data *bc;
+	struct skl_specific_cfg *sp_cfg;
+
+	if (mconfig->formats_config.caps_size > 0 &&
+		mconfig->formats_config.set_params) {
+		sp_cfg = &mconfig->formats_config;
+		ret = skl_set_module_params(ctx, (void *)sp_cfg->caps,
+							sp_cfg->caps_size,
+							sp_cfg->param_id,
+							mconfig);
+		if (ret < 0)
+			return ret;
+	}
+
+	for (i = 0; i < w->num_kcontrols; i++) {
+		k = &w->kcontrol_news[i];
+		if (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
+			sb = (void *) k->private_value;
+			bc = (struct skl_algo_data *)sb->dobj.private;
+
+			if (bc->set_params) {
+				ret = skl_set_module_params(ctx,
+							(void *)bc->params,
+							bc->max,
+							bc->param_id,
+							mconfig);
+				if (ret < 0)
+					return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * some module param can set from user control and this is required as
+ * when module is initailzed. if module param is required in init it is
+ * identifed by set_param flag. if set_param flag is not set, then this
+ * parameter needs to set as part of module init.
+ */
+static int skl_tplg_set_module_init_data(struct snd_soc_dapm_widget *w)
+{
+	const struct snd_kcontrol_new *k;
+	struct soc_bytes_ext *sb;
+	struct skl_algo_data *bc;
+	struct skl_module_cfg *mconfig = w->priv;
+	int i;
+
+	for (i = 0; i < w->num_kcontrols; i++) {
+		k = &w->kcontrol_news[i];
+		if (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
+			sb = (void *) k->private_value;
+			bc = (struct skl_algo_data *)sb->dobj.private;
+			if (bc->set_params)
+				continue;
+			mconfig->formats_config.caps = (u32 *)&bc->params;
+			mconfig->formats_config.caps_size = bc->max;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
  * Inside a pipe instance, we can have various modules. These modules need
  * to instantiated in DSP by invoking INIT_MODULE IPC, which is achieved by
  * skl_init_module() routine, so invoke that for all modules in a pipeline
@@ -340,9 +417,15 @@ skl_tplg_init_pipe_modules(struct skl *skl, struct skl_pipe *pipe)
 		 * FE/BE params
 		 */
 		skl_tplg_update_module_params(w, ctx);
+
+		skl_tplg_set_module_init_data(w);
 		ret = skl_init_module(ctx, mconfig);
 		if (ret < 0)
 			return ret;
+
+		ret = skl_tplg_set_module_params(w, ctx);
+		if (ret < 0)
+			return ret;
 	}
 
 	return 0;
@@ -1268,7 +1351,9 @@ static int skl_tplg_widget_load(struct snd_soc_component *cmpnt,
 		return -ENOMEM;
 
 	memcpy(mconfig->formats_config.caps, dfw_config->caps.caps,
-					 dfw_config->caps.caps_size);
+						 dfw_config->caps.caps_size);
+	mconfig->formats_config.param_id = dfw_config->caps.param_id;
+	mconfig->formats_config.set_params = dfw_config->caps.set_params;
 
 bind_event:
 	if (tplg_w->event_type == 0) {
diff --git a/sound/soc/intel/skylake/skl-topology.h b/sound/soc/intel/skylake/skl-topology.h
index bc7bcd1..83a788b 100644
--- a/sound/soc/intel/skylake/skl-topology.h
+++ b/sound/soc/intel/skylake/skl-topology.h
@@ -206,6 +206,8 @@ struct skl_module_pin {
 };
 
 struct skl_specific_cfg {
+	bool set_params;
+	u32 param_id;
 	u32 caps_size;
 	u32 *caps;
 };
@@ -285,6 +287,7 @@ struct skl_module_cfg {
 
 struct skl_algo_data {
 	u32 param_id;
+	bool set_params;
 	u32 max;
 	char *params;
 };
diff --git a/sound/soc/intel/skylake/skl-tplg-interface.h b/sound/soc/intel/skylake/skl-tplg-interface.h
index c7051c1..c16367d 100644
--- a/sound/soc/intel/skylake/skl-tplg-interface.h
+++ b/sound/soc/intel/skylake/skl-tplg-interface.h
@@ -160,6 +160,8 @@ struct skl_dfw_module_fmt {
 } __packed;
 
 struct skl_dfw_module_caps {
+	u8 set_params;
+	u32 param_id;
 	u32 caps_size;
 	u32 caps[HDA_SST_CFG_MAX];
 };
-- 
1.7.5.4

