From e238af4aa88163d547d6c120594b304ba2ef0575 Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:20 -0700
Subject: [PATCH 1366/2508] drm/i915/preempt: don't allow nonbatch ctx init
 when the scheduler is busy

commit d033e907ae557566b3adf29f004c4aa452dcf0ad from
https://github.com/01org/linux-apollolake-i

If the scheduler is busy (e.g. processing a preemption) it will need to
be able to acquire the struct_mutex, so we can't allow untracked
requests to bypass the scheduler and go directly to the hardware (much
confusion will result). Since untracked requests are used only for
initialisation of logical contexts, we can avoid the problem by forcing
any thread trying to initialise a context at an unfortunate time to drop
the mutex and retry later.

*v?* Add documentation.

For: VIZ-2021
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_scheduler.c |   13 +++++++++++++
 drivers/gpu/drm/i915/i915_scheduler.h |    1 +
 drivers/gpu/drm/i915/intel_lrc.c      |    8 ++++++++
 3 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index 55d183b..15ac69b 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -1880,6 +1880,19 @@ bool i915_scheduler_is_engine_preempting(struct intel_engine_cs *engine)
 }
 
 /**
+ * i915_scheduler_is_engine_busy - is the scheduler busy on the given engine?
+ * @engine: Engine to query
+ * Returns true if the scheduler is busy and cannot immediately perform
+ * operations such as submitting a batch buffer to the hardware or false
+ * if it is not.
+ */
+bool i915_scheduler_is_engine_busy(struct intel_engine_cs *engine)
+{
+	/* Currently only pre-emption ties up the scheduler. */
+	return i915_scheduler_is_engine_preempting(engine);
+}
+
+/**
  * i915_scheduler_is_engine_flying - does the given engine have in flight batches?
  * @engine: Engine to query
  * Used by TDR to distinguish hung engines (not moving but with work to do)
diff --git a/drivers/gpu/drm/i915/i915_scheduler.h b/drivers/gpu/drm/i915/i915_scheduler.h
index ddbdd39..ceef0bd 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.h
+++ b/drivers/gpu/drm/i915/i915_scheduler.h
@@ -187,6 +187,7 @@ bool i915_scheduler_notify_request(struct drm_i915_gem_request *req);
 void i915_scheduler_wakeup(struct drm_device *dev);
 bool i915_scheduler_is_engine_flying(struct intel_engine_cs *engine);
 bool i915_scheduler_is_engine_preempting(struct intel_engine_cs *engine);
+bool i915_scheduler_is_engine_busy(struct intel_engine_cs *engine);
 void i915_scheduler_work_handler(struct work_struct *work);
 int i915_scheduler_flush(struct intel_engine_cs *engine, bool is_locked);
 int i915_scheduler_flush_stamp(struct intel_engine_cs *engine,
diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
index fe640fd..4e0a0e6 100644
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -2819,6 +2819,14 @@ int intel_lr_context_deferred_alloc(struct intel_context *ctx,
 	WARN_ON(ctx->legacy_hw_ctx.rcs_state != NULL);
 	WARN_ON(ctx->engine[engine->id].state);
 
+	/* Don't submit non-scheduler requests while the scheduler is busy */
+	if (i915_scheduler_is_engine_busy(engine)) {
+		mutex_unlock(&dev->struct_mutex);
+		msleep(1);
+		mutex_lock(&dev->struct_mutex);
+		return -EAGAIN;
+	}
+
 	context_size = round_up(intel_lr_context_size(engine), 4096);
 
 	/* One extra page as the sharing data between driver and GuC */
-- 
1.7.5.4

