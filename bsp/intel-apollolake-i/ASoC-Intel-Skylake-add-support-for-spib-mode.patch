From 51c8b189922391247711ef32b25e88ddad807578 Mon Sep 17 00:00:00 2001
From: Ramesh Babu <ramesh.babu@intel.com>
Date: Mon, 23 May 2016 11:39:19 +0530
Subject: [PATCH 1995/2508] ASoC: Intel: Skylake: add support for spib mode

commit dfb67fb40f7764181bd742507c6414f209eaa3ce from
https://github.com/01org/linux-apollolake-i

Skylake audio controller sports SPIB capability,
which can be used to inform position of appl pointer
to host DMA controller. When SPIB mode is enabled,
driver could write the appl pointer position in SPIB
register. Host DMA will make sure it won't read/write
beyond bytes specified in SPIB register.

SPIB mode will be useful in low power use cases, where
DSP could pre-fetch large buffers to avoid frequent
wakes due to interrupts.

Skylake driver makes use of no_rewind flag and
appl_ptr_update callback to enable and update SPIB
register respectively.

Change-Id: Id71ae9de08bddf7abc79de79781bc63b842e4a47
Signed-off-by: Ramesh Babu <ramesh.babu@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9566
---
 sound/soc/intel/skylake/skl-pcm.c |   45 +++++++++++++++++++++++++++++++++++-
 1 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-pcm.c b/sound/soc/intel/skylake/skl-pcm.c
index 9faada7..5ce597e 100644
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -226,7 +226,10 @@ static int skl_get_format(struct snd_pcm_substream *substream,
 static int skl_pcm_prepare(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *dai)
 {
+	struct hdac_ext_bus *ebus = dev_get_drvdata(dai->dev);
 	struct hdac_ext_stream *stream = get_hdac_ext_stream(substream);
+	struct hdac_stream *hstream = hdac_stream(stream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int format_val;
 	int err;
 
@@ -245,6 +248,10 @@ static int skl_pcm_prepare(struct snd_pcm_substream *substream,
 	if (err < 0)
 		return err;
 
+	/* enable SPIB if no_rewinds flag is set */
+	if (runtime->no_rewinds)
+		snd_hdac_ext_stream_spbcap_enable(ebus, 1, hstream->index);
+
 	hdac_stream(stream)->prepared = 1;
 
 	return err;
@@ -314,9 +321,16 @@ static int skl_pcm_hw_free(struct snd_pcm_substream *substream,
 {
 	struct hdac_ext_bus *ebus = dev_get_drvdata(dai->dev);
 	struct hdac_ext_stream *stream = get_hdac_ext_stream(substream);
+	struct hdac_stream *hstream = hdac_stream(stream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 
 	dev_dbg(dai->dev, "%s: %s\n", __func__, dai->name);
 
+	if (runtime->no_rewinds) {
+		snd_hdac_ext_stream_set_spib(ebus, stream, 0);
+		snd_hdac_ext_stream_spbcap_enable(ebus, 0, hstream->index);
+	}
+
 	snd_hdac_stream_cleanup(hdac_stream(stream));
 	hdac_stream(stream)->prepared = 0;
 
@@ -392,6 +406,7 @@ static int skl_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct skl_module_cfg *mconfig;
 	struct hdac_ext_bus *ebus = get_bus_ctx(substream);
 	struct hdac_ext_stream *stream = get_hdac_ext_stream(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_soc_dapm_widget *w;
 	int ret;
 
@@ -418,8 +433,9 @@ static int skl_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 			snd_hdac_ext_stream_set_dpibr(ebus, stream,
 							stream->dpib);
 			snd_hdac_ext_stream_set_lpib(stream, stream->lpib);
+			if (runtime->no_rewinds)
+				snd_hdac_ext_stream_set_spib(ebus, stream, stream->spib);
 		}
-
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		/*
@@ -1299,6 +1315,31 @@ static int skl_platform_pcm_trigger(struct snd_pcm_substream *substream,
 	return 0;
 }
 
+/* update SPIB register with appl position */
+static int skl_appl_ptr_update(struct snd_pcm_substream *substream)
+{
+	struct hdac_ext_bus *ebus = get_bus_ctx(substream);
+	struct hdac_ext_stream *estream = get_hdac_ext_stream(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	ssize_t appl_pos, buf_size;
+	u32 spib;
+
+	/* Use spib mode only if no_rewind mode is set */
+	if (runtime->no_rewinds == 0)
+		return 0;
+
+	appl_pos = frames_to_bytes(runtime, runtime->control->appl_ptr);
+	buf_size = frames_to_bytes(runtime, runtime->buffer_size);
+
+	spib = appl_pos % buf_size;
+
+	/* spib should be programed between 1 to Buffer size */
+	spib = (spib == 0) ? buf_size : spib;
+	snd_hdac_ext_stream_set_spib(ebus, estream, spib);
+
+	return 0;
+}
+
 /* calculate runtime delay from LPIB */
 static int skl_get_delay_from_lpib(struct hdac_ext_bus *ebus,
 				struct hdac_ext_stream *sstream,
@@ -1356,7 +1397,6 @@ static unsigned int skl_get_position(struct hdac_ext_stream *hstream,
 						 + codec_delay;
 		substream->runtime->delay += delay;
 	}
-
 	return pos;
 }
 
@@ -1436,6 +1476,7 @@ static struct snd_pcm_ops skl_platform_ops = {
 	.get_time_info =  skl_get_time_info,
 	.mmap = snd_pcm_lib_default_mmap,
 	.page = snd_pcm_sgbuf_ops_page,
+	.appl_ptr_update = skl_appl_ptr_update,
 };
 
 static void skl_pcm_free(struct snd_pcm *pcm)
-- 
1.7.5.4

