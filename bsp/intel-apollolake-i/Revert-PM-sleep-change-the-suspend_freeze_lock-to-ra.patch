From 8ed36d6a241e03d97bb20f83aef1db77260ebea1 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 27 Apr 2017 10:23:57 +0800
Subject: [PATCH 2/3] Revert "PM / sleep: change the suspend_freeze_lock to
 raw spinlock"

We have converted the suspend_freeze_lock to raw spin lock in order to
fix a sleeping function called in an atomic context bug when doing S3
suspend on rt kernel. But this is not the right fix, there are still
more spin lock such as events_lock, wait_queue_head_t.lock acquired
within the section protected by suspend_freeze_lock. So revert this
conversion and we will fix this issue in the following patch.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 kernel/power/suspend.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 28851df..db920b1 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -40,7 +40,7 @@ static const struct platform_freeze_ops *freeze_ops;
 static DECLARE_WAIT_QUEUE_HEAD(suspend_freeze_wait_head);
 
 enum freeze_state __read_mostly suspend_freeze_state;
-static DEFINE_RAW_SPINLOCK(suspend_freeze_lock);
+static DEFINE_SPINLOCK(suspend_freeze_lock);
 
 void freeze_set_ops(const struct platform_freeze_ops *ops)
 {
@@ -56,12 +56,12 @@ static void freeze_begin(void)
 
 static void freeze_enter(void)
 {
-	raw_spin_lock_irq(&suspend_freeze_lock);
+	spin_lock_irq(&suspend_freeze_lock);
 	if (pm_wakeup_pending())
 		goto out;
 
 	suspend_freeze_state = FREEZE_STATE_ENTER;
-	raw_spin_unlock_irq(&suspend_freeze_lock);
+	spin_unlock_irq(&suspend_freeze_lock);
 
 	get_online_cpus();
 	cpuidle_resume();
@@ -77,23 +77,23 @@ static void freeze_enter(void)
 	cpuidle_pause();
 	put_online_cpus();
 
-	raw_spin_lock_irq(&suspend_freeze_lock);
+	spin_lock_irq(&suspend_freeze_lock);
 
  out:
 	suspend_freeze_state = FREEZE_STATE_NONE;
-	raw_spin_unlock_irq(&suspend_freeze_lock);
+	spin_unlock_irq(&suspend_freeze_lock);
 }
 
 void freeze_wake(void)
 {
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&suspend_freeze_lock, flags);
+	spin_lock_irqsave(&suspend_freeze_lock, flags);
 	if (suspend_freeze_state > FREEZE_STATE_NONE) {
 		suspend_freeze_state = FREEZE_STATE_WAKE;
 		wake_up(&suspend_freeze_wait_head);
 	}
-	raw_spin_unlock_irqrestore(&suspend_freeze_lock, flags);
+	spin_unlock_irqrestore(&suspend_freeze_lock, flags);
 }
 EXPORT_SYMBOL_GPL(freeze_wake);
 
-- 
1.7.5.4

