From 5bf16b216b90f295737353791da69c815516193d Mon Sep 17 00:00:00 2001
From: "Xiong, James" <james.xiong@intel.com>
Date: Thu, 26 May 2016 16:44:16 -0700
Subject: [PATCH 4430/4706] Change the order of mutex_lock to avoid deadlock

commit 932d8bbc4e4199d0b1d4907a145b1f0ce9c3a7e3 from
git://git.yoctoproject.org/linux-yocto-4.1

Locking two mutexes in reverse order in multiple threads could run into
race condition and end up with dead lock.

Change the locking order to lock mode_config.mutex first then acquire other
drm_modeset mutexes.

Function intel_splash_screen_init doesn't need the protection of these
mutexes, call this function before acquiring mutexes.

Handle drm_modeset_lock_all_ctx failure [Matt]

Signed-off-by: Xiong, James <james.xiong@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/intel_initial_modeset.c |   30 +++++++++++++-------------
 1 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
index 9816412..5186ccf 100644
--- a/drivers/gpu/drm/i915/intel_initial_modeset.c
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -545,26 +545,33 @@ static void modeset_config_fn(struct work_struct *work)
 	int ret;
 	bool found = false;
 
+	intel_splash_screen_init(dev);
+
 	state = drm_atomic_state_alloc(dev);
 	if (!state)
 		return;
 
+	mutex_lock(&dev->mode_config.mutex);
+
 	drm_modeset_acquire_init(&ctx, 0);
 	state->acquire_ctx = &ctx;
-	drm_modeset_lock_all_ctx(dev, &ctx);
-
-	intel_splash_screen_init(dev);
-
 retry:
+	ret = drm_modeset_lock_all_ctx(dev, &ctx);
+	if (ret == -EDEADLK) {
+		drm_modeset_backoff(&ctx);
+		goto retry;
+	} else if(ret) {
+		goto out;
+	}
+
 	ret = disable_planes(dev, state);
 	if (ret)
-		goto early_fail;
+		goto fail;
 
 	/*
 	 * For each connector that we want to set up, update the atomic
 	 * state to include the connector and crtc mode.
 	 */
-	mutex_lock(&dev->mode_config.mutex);
 	drm_for_each_connector(connector, dev) {
 		struct drm_encoder *encoder;
 
@@ -603,22 +610,13 @@ retry:
 	}
 
 	if (found) {
-		ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
-				       state->acquire_ctx);
-		if (ret)
-			goto fail;
-
 		ret = drm_atomic_commit(state);
 		if (ret)
 			goto fail;
 	}
-	mutex_unlock(&dev->mode_config.mutex);
 	goto out;
 
 fail:
-	mutex_unlock(&dev->mode_config.mutex);
-
-early_fail:
 	if (ret == -EDEADLK) {
 		DRM_DEBUG_KMS("modeset commit deadlock, retry...\n");
 		drm_modeset_backoff(&ctx);
@@ -636,6 +634,8 @@ out:
 	}
 	drm_modeset_drop_locks(&ctx);
 	drm_modeset_acquire_fini(&ctx);
+
+	mutex_unlock(&dev->mode_config.mutex);
 }
 
 void intel_initial_mode_config_init(struct drm_device *dev)
-- 
1.7.5.4

