From d6fc15ea3fcf8d17bee950ba8eb8b9f2e74e1bf8 Mon Sep 17 00:00:00 2001
From: Michel Thierry <michel.thierry@intel.com>
Date: Thu, 18 Aug 2016 13:45:58 -0700
Subject: [PATCH 37/68] MUST_REBASE [VPG]: drm/i915: Add
 I915_GEM_GET_APERTURE2 ioctl

commit a43a09dd84c19ff905c3048de8c18b0c3f60588c from
git://git.yoctoproject.org/linux-yocto-4.1

And return map_total_size, map_available_size & map_largest_size.
OpenGL driver can use this information to check if a map_ggtt is likely
to fail, and fall back to an alternative path.

At the moment this is an internal requirement; unless there is an
opensource user it cannot be merged upstream, hence marked as
MUST_REBASE.

v2: Read the right stuff this time.
v3: Make it a new ioctl.
v4: Estimate available mappable region using only pinned vmas.
v5: Ported to kernel 4.1.0 (broxton), note the new value for
I915_PARAM_HAS_GET_APERTURE2, 0x808 instead of 0x804. It also includes
the mutex lock/unlock squashme patch.

Tracked-On: https://jira01.devtools.intel.com/browse/OAM-24494
Change-Id: I8fa1c82b05e33fe7506d22f185e0ce0189ce5965
Signed-off-by: Michel Thierry <michel.thierry@intel.com>
Reviewed-on: https://android.intel.com:443/485050
Signed-off-by: Michel Thierry <michel.thierry@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/i915/i915_dma.c       |    3 +
 drivers/gpu/drm/i915/i915_drv.h       |    2 +
 drivers/gpu/drm/i915/i915_ext_ioctl.c |    2 +
 drivers/gpu/drm/i915/i915_gem.c       |  132 +++++++++++++++++++++++++++++++++
 include/uapi/drm/i915_drm.h           |   30 ++++++++
 5 files changed, 169 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index cf0c802..23d21c1 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -235,6 +235,9 @@ static int i915_getparam(struct drm_device *dev, void *data,
 	case I915_PARAM_HAS_EXEC_SOFTPIN:
 		value = 1;
 		break;
+	case I915_PARAM_HAS_GET_APERTURE2:
+		value = 1;
+		break;
 	case I915_PARAM_HAS_POOLED_EU:
 		value = HAS_POOLED_EU(dev);
 		break;
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 5426143..4e79691 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -3062,6 +3062,8 @@ int i915_gem_userptr_ioctl(struct drm_device *dev, void *data,
 			   struct drm_file *file);
 int i915_gem_get_aperture_ioctl(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
+int i915_gem_get_aperture_ioctl2(struct drm_device *dev, void *data,
+				 struct drm_file *file);
 int i915_gem_wait_ioctl(struct drm_device *dev, void *data,
 			struct drm_file *file_priv);
 void i915_gem_load_init(struct drm_device *dev);
diff --git a/drivers/gpu/drm/i915/i915_ext_ioctl.c b/drivers/gpu/drm/i915/i915_ext_ioctl.c
index c3d0d6e..0873c58 100644
--- a/drivers/gpu/drm/i915/i915_ext_ioctl.c
+++ b/drivers/gpu/drm/i915/i915_ext_ioctl.c
@@ -169,6 +169,8 @@ err_i1:
 const struct drm_ioctl_desc i915_ext_ioctls[] = {
 	EXT_IOCTL_DEF(DRM_IOCTL_I915_EXT_USERDATA, i915_gem_userdata_ioctl,
 			DRM_UNLOCKED|DRM_CONTROL_ALLOW|DRM_RENDER_ALLOW),
+	EXT_IOCTL_DEF(DRM_IOCTL_I915_GEM_GET_APERTURE2, i915_gem_get_aperture_ioctl2,
+			DRM_UNLOCKED|DRM_RENDER_ALLOW),
 };
 
 int i915_max_ext_ioctl = ARRAY_SIZE(i915_ext_ioctls);
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 92bf8da..fefa2a5 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -33,6 +33,7 @@
 #include "i915_trace.h"
 #include "intel_drv.h"
 #include "i915_scheduler.h"
+#include <linux/list_sort.h>
 #include <linux/shmem_fs.h>
 #include <linux/slab.h>
 #include <linux/swap.h>
@@ -155,6 +156,137 @@ i915_gem_get_aperture_ioctl(struct drm_device *dev, void *data,
 	return 0;
 }
 
+/**
+ * Detached struct to hold a vma temp list in i915_gem_get_aperture_ioctl2
+ */
+struct i915_vma_list_entry {
+	struct i915_vma *vma;
+	struct list_head vma_ap_link; /* link in the temp aperture ioctl list */
+};
+
+static
+struct i915_vma_list_entry *i915_vma_list_entry_create(struct i915_vma *vma)
+{
+	struct i915_vma_list_entry *vma_list_entry;
+
+	vma_list_entry = kmalloc(sizeof(*vma_list_entry), GFP_KERNEL);
+	if (vma_list_entry == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&vma_list_entry->vma_ap_link);
+	vma_list_entry->vma = vma;
+	return vma_list_entry;
+}
+
+static inline bool vma_in_mappable_region(struct i915_vma *vma, u32 map_limit)
+{
+	return (vma->node.start < map_limit) && i915_is_ggtt(vma->vm);
+}
+
+static int vma_rank_by_node_start(void *priv,
+				  struct list_head *A,
+				  struct list_head *B)
+{
+	struct i915_vma_list_entry *a =
+		list_entry(A, struct i915_vma_list_entry, vma_ap_link);
+	struct i915_vma_list_entry *b =
+		list_entry(B, struct i915_vma_list_entry, vma_ap_link);
+
+	return a->vma->node.start - b->vma->node.start;
+}
+
+int
+i915_gem_get_aperture_ioctl2(struct drm_device *dev, void *data,
+			     struct drm_file *file)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct drm_i915_gem_get_aperture2 *args = data;
+	struct i915_ggtt *ggtt = &dev_priv->ggtt;
+	struct i915_vma *vma;
+	struct i915_vma_list_entry *vma_list_entry;
+	struct list_head map_list;
+	size_t pinned;
+	u64 map_space, map_largest, last, size;
+	const u32 map_limit = dev_priv->ggtt.mappable_end;
+
+	INIT_LIST_HEAD(&map_list);
+	pinned = 0;
+	mutex_lock(&dev->struct_mutex);
+	list_for_each_entry(vma, &ggtt->base.active_list, vm_link) {
+		if (vma->pin_count) {
+			pinned += vma->node.size;
+
+			if (vma_in_mappable_region(vma, map_limit)) {
+				vma_list_entry = i915_vma_list_entry_create(vma);
+				if (IS_ERR(vma_list_entry)) {
+					DRM_ERROR("No vma in inactive list\n");
+					mutex_unlock(&dev->struct_mutex);
+					return PTR_ERR(vma_list_entry);
+				}
+				list_add(&vma_list_entry->vma_ap_link, &map_list);
+			}
+		}
+	}
+
+	list_for_each_entry(vma, &ggtt->base.inactive_list, vm_link) {
+		if (vma->pin_count) {
+			pinned += vma->node.size;
+
+			if (vma_in_mappable_region(vma, map_limit)) {
+				vma_list_entry = i915_vma_list_entry_create(vma);
+				if (IS_ERR(vma_list_entry)) {
+					DRM_ERROR("No vma in active list\n");
+					mutex_unlock(&dev->struct_mutex);
+					return PTR_ERR(vma_list_entry);
+				}
+				list_add(&vma_list_entry->vma_ap_link, &map_list);
+			}
+		}
+	}
+
+	last = map_largest = map_space = size = 0;
+	list_sort(NULL, &map_list, vma_rank_by_node_start);
+	if (list_empty(&map_list))
+		DRM_DEBUG_DRIVER("map_list empty");
+
+	while (!list_empty(&map_list)) {
+		vma_list_entry = list_first_entry(&map_list, typeof(*vma_list_entry), vma_ap_link);
+		vma = vma_list_entry->vma;
+		list_del_init(&vma_list_entry->vma_ap_link);
+
+		size = vma->node.start - last;
+		if (size > map_largest)
+			map_largest = size;
+		map_space += size;
+		last = vma->node.start + vma->node.size;
+		kfree(vma_list_entry);
+	}
+
+	if (last < map_limit) {
+		size = map_limit - last;
+		if (size > map_largest)
+			map_largest = size;
+		map_space += size;
+	}
+	mutex_unlock(&dev->struct_mutex);
+
+	args->aper_size = dev_priv->ggtt.base.total;
+	args->aper_available_size = args->aper_size - pinned;
+	args->map_available_size = map_space;
+	args->map_largest_size = map_largest;
+	args->map_total_size = dev_priv->ggtt.mappable_end;
+
+	DRM_DEBUG_DRIVER("aper_size = %llu\n", args->aper_size);
+	DRM_DEBUG_DRIVER("aper_available_size = %llu\n",
+			 args->aper_available_size);
+	DRM_DEBUG_DRIVER("map_available_size = %llu\n",
+			 args->map_available_size);
+	DRM_DEBUG_DRIVER("map_largest_size = %llu\n", args->map_largest_size);
+	DRM_DEBUG_DRIVER("map_total_size = %llu\n", args->map_total_size);
+
+	return 0;
+}
+
 static int
 i915_gem_object_get_pages_phys(struct drm_i915_gem_object *obj)
 {
diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 3c8d680..6b90a24 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -255,9 +255,12 @@ struct i915_ext_ioctl_data {
 
 /* Extended ioctl definitions */
 #define DRM_I915_EXT_USERDATA		0x0
+#define DRM_I915_GEM_GET_APERTURE2	0x1
 
 #define DRM_IOCTL_I915_EXT_USERDATA \
 	DRM_IOWR(DRM_I915_EXT_USERDATA, struct drm_i915_gem_userdata_blk)
+#define DRM_IOCTL_I915_GEM_GET_APERTURE2 \
+	DRM_IOR(DRM_I915_GEM_GET_APERTURE2, struct drm_i915_gem_get_aperture2)
 
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
@@ -396,6 +399,7 @@ typedef struct drm_i915_irq_wait {
 /* This helps to avoid conflicts with new upstream values */
 #define I915_PARAM_HAS_POOLED_EU         0x800
 #define I915_PARAM_MIN_EU_IN_POOL        0x801
+#define I915_PARAM_HAS_GET_APERTURE2     0x802
 
 typedef struct drm_i915_getparam {
 	__s32 param;
@@ -1042,6 +1046,32 @@ struct drm_i915_gem_get_aperture {
 	__u64 aper_available_size;
 };
 
+struct drm_i915_gem_get_aperture2 {
+	/** Total size of the aperture used by i915_gem_execbuffer, in bytes */
+	__u64 aper_size;
+
+	/**
+	 * Available space in the aperture used by i915_gem_execbuffer, in
+	 * bytes
+	 */
+	__u64 aper_available_size;
+
+	/**
+	 * Total space in the mappable region of the aperture, in bytes
+	 */
+	__u64 map_total_size;
+
+	/**
+	 * Available space in the mappable region of the aperture, in bytes
+	 */
+	__u64 map_available_size;
+
+	/**
+	 * Single largest available region inside the mappable region, in bytes.
+	 */
+	__u64 map_largest_size;
+};
+
 struct drm_i915_get_pipe_from_crtc_id {
 	/** ID of CRTC being requested **/
 	__u32 crtc_id;
-- 
1.7.5.4

