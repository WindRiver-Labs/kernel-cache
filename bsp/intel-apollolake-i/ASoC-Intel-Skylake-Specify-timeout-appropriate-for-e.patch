From e598321c0e40dff95756f90d1e84592574b89b2a Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Tue, 8 Mar 2016 13:02:51 +0530
Subject: [PATCH 1911/2508] ASoC: Intel: Skylake: Specify timeout appropriate
 for each IPC

commit 854c8382ec69d68bb783203898cdd8faea59951f from
https://github.com/01org/linux-apollolake-i

Different IPC messages may need different wait times for response
from FW. Hence specifying a single default timeout for all IPCs
does not work. Eg. The load library IPCs in BXT may take more
than 300ms for FW response. Hence specify the timeout as appropriate
for the particular kind of IPC message.

Change-Id: Idaaa3abcfc494c69eeaaefb05c4da923bcf9814c
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-23222
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/8362
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/skl-sst-ipc.c |   52 +++++++++++++++++++++------------
 sound/soc/intel/skylake/skl-sst-ipc.h |    5 ++-
 2 files changed, 37 insertions(+), 20 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index 8d0a3b2..b7af412 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -305,11 +305,11 @@ static void skl_ipc_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)
 /* Helper function to send IPC */
 static int _skl_ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 		void *tx_data, size_t tx_bytes, void *rx_data,
-		size_t rx_bytes, bool wait)
+		size_t rx_bytes, bool wait, int timeout)
 {
 	if (wait)
-		return	sst_ipc_tx_message_wait(ipc, header, tx_data, tx_bytes,
-				rx_data, rx_bytes);
+		return	sst_ipc_tx_message_wait_timeout(ipc, header, tx_data,
+				tx_bytes, rx_data, rx_bytes, timeout);
 	else
 		return sst_ipc_tx_message_nowait(ipc, header, tx_data, tx_bytes);
 }
@@ -322,7 +322,7 @@ static int _skl_ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
  */
 static int skl_ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 		void *tx_data, size_t tx_bytes,
-		void *rx_data, size_t rx_bytes, bool wait)
+		void *rx_data, size_t rx_bytes, bool wait, int timeout)
 {
 	int ret;
 	struct sst_dsp *dsp = ipc->dsp;
@@ -335,7 +335,7 @@ static int skl_ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 	}
 
 	ret = _skl_ipc_tx_message(ipc, header, tx_data, tx_bytes, rx_data,
-			rx_bytes, wait);
+			rx_bytes, wait, timeout);
 	if (ret < 0)
 		return ret;
 
@@ -644,7 +644,8 @@ int skl_ipc_create_pipeline(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_PPL_MEM_SIZE(ppl_mem_size);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: create pipeline fail, err: %d\n", ret);
 		return ret;
@@ -666,7 +667,8 @@ int skl_ipc_delete_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: delete pipeline failed, err %d\n", ret);
 		return ret;
@@ -690,7 +692,8 @@ int skl_ipc_set_pipeline_state(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_PPL_STATE(state);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set pipeline state failed, err: %d\n", ret);
 		return ret;
@@ -713,7 +716,8 @@ skl_ipc_save_pipeline(struct sst_generic_ipc *ipc, u8 instance_id, int dma_id)
 
 	header.extension = IPC_DMA_ID(dma_id);
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: save pipeline failed, err: %d\n", ret);
 		return ret;
@@ -735,7 +739,8 @@ int skl_ipc_restore_pipeline(struct sst_generic_ipc *ipc, u8 instance_id)
 	header.primary |= IPC_INSTANCE_ID(instance_id);
 
 	dev_dbg(ipc->dev, "In %s header=%d\n", __func__, header.primary);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: restore  pipeline failed, err: %d\n", ret);
 		return ret;
@@ -761,7 +766,8 @@ int skl_ipc_set_dx(struct sst_generic_ipc *ipc, u8 instance_id,
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
 	ret = skl_ipc_tx_message(ipc, *ipc_header,
-				dx, sizeof(*dx), NULL, 0, true);
+				dx, sizeof(*dx), NULL, 0, true,
+				SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: set dx failed, err %d\n", ret);
 		return ret;
@@ -794,7 +800,8 @@ int skl_ipc_init_instance(struct sst_generic_ipc *ipc,
 	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
 			 header.primary, header.extension);
 	ret = skl_ipc_tx_message(ipc, *ipc_header, param_data,
-			msg->param_data_size, NULL, 0, true);
+			msg->param_data_size, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: init instance failed\n");
@@ -826,7 +833,8 @@ int skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,
 
 	dev_dbg(ipc->dev, "In %s hdr=%x ext=%x\n", __func__, header.primary,
 			 header.extension);
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: bind/unbind faileden");
 		return ret;
@@ -850,7 +858,8 @@ int skl_ipc_load_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
 
 	dev_dbg(ipc->dev, "In %s hdr=%x\n", __func__, header.primary);
 	ret = skl_ipc_tx_message(ipc, *ipc_header, data,
-				(sizeof(u16) * module_cnt), NULL, 0, true);
+				(sizeof(u16) * module_cnt), NULL, 0, true,
+				SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: load modules failed err=%d\n", ret);
 		return ret;
@@ -874,7 +883,8 @@ int skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
 
 	dev_dbg(ipc->dev, "In %s hdr=%x\n", __func__, header.primary);
 	ret = skl_ipc_tx_message(ipc, *ipc_header, data,
-				(sizeof(u16) * module_cnt), NULL, 0, true);
+				(sizeof(u16) * module_cnt), NULL, 0, true,
+				SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0) {
 		dev_err(ipc->dev, "ipc: unload modules failed err=%d\n", ret);
 		return ret;
@@ -917,7 +927,8 @@ int skl_ipc_set_large_config(struct sst_generic_ipc *ipc,
 			(unsigned)data_offset, (unsigned)tx_size);
 		ret = skl_ipc_tx_message(ipc, *ipc_header,
 					  ((char *)param) + data_offset,
-					  tx_size, NULL, 0, true);
+					  tx_size, NULL, 0, true,
+					  SKL_IPC_DEFAULT_TIMEOUT);
 		if (ret < 0) {
 			dev_err(ipc->dev,
 				"ipc: set large config fail, err: %d\n", ret);
@@ -982,7 +993,8 @@ int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 
 		ret = skl_ipc_tx_message(ipc, *ipc_header,
 			((char *)txparam), size, ((char *)param) + data_offset,
-					      rx_size, true);
+					      rx_size, true,
+					      SKL_IPC_DEFAULT_TIMEOUT);
 
 		if (ret < 0) {
 			dev_err(ipc->dev,
@@ -1017,7 +1029,8 @@ int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_MOD_INSTANCE_ID(table_id);
 	header.primary |= IPC_MOD_ID(dma_id);
 
-	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_LOAD_LIB_TIMEOUT);
 
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: load lib failed\n");
@@ -1049,7 +1062,8 @@ int skl_ipc_set_d0ix(struct sst_generic_ipc *ipc, struct skl_ipc_d0ix_msg *msg)
 	 * This is because the wrapper function will call D0i3 APIs. But that
 	 * should not be done when sending D0ix IPC itself.
 	 */
-	ret = _skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true);
+	ret = _skl_ipc_tx_message(ipc, *ipc_header, NULL, 0, NULL, 0, true,
+			SKL_IPC_DEFAULT_TIMEOUT);
 	if (ret < 0)
 		dev_err(ipc->dev, "ipc: set d0ix failed, err %d\n", ret);
 
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index 9b01948..3ade699 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -111,7 +111,10 @@ struct skl_log_state_msg {
 	struct	skl_log_state logs_core[2];
 };
 
-#define SKL_IPC_BOOT_MSECS		3000
+/* Timeout values in milliseconds for response from FW */
+#define SKL_IPC_BOOT_MSECS              3000
+#define SKL_IPC_LOAD_LIB_TIMEOUT        3000
+#define SKL_IPC_DEFAULT_TIMEOUT         300
 
 #define SKL_IPC_D3_MASK	0
 #define SKL_IPC_D0_MASK	3
-- 
1.7.5.4

