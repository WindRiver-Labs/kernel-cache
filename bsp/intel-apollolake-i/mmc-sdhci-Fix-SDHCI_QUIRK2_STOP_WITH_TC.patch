From 441d8807dc64f62239da83caa08109a08dd6b9fc Mon Sep 17 00:00:00 2001
From: Lim Key Seong <key.seong.lim@intel.com>
Date: Mon, 5 Sep 2016 17:26:56 +0800
Subject: [PATCH 03/68] mmc: sdhci: Fix SDHCI_QUIRK2_STOP_WITH_TC

commit 22b14c2cf32ef4be795b623b406bf84d9cb14812 from
git://git.yoctoproject.org/linux-yocto-4.1

Multi-block data transfers can specify the number of blocks either using a
Set Block Count command (CMD23) or by sending a STOP command (CMD12) after
the required number of blocks has transferred. CMD23 is preferred, but some
cards don't support it. CMD12 with R1b response is used for writes, and
R1 response for reads.

Some SDHCI host controllers give a Transfer Complete (TC) interrupt for the
STOP command (CMD12) whether or not a R1b response has been specified. The
quirk SDHCI_QUIRK2_STOP_WITH_TC identifies those host controllers, but the
implementation only considers the case where the TC interrupt arrives at
the same time as the Command Complete (CC) interrupt. However,
occasionally TC arrives before CC. That is harmless, but does generate an
error message "Got data interrupt 0x00000002 even though no data operation
was in progress".

A simpler approach is to force R1b response onto all data transfer STOP
commands, because SDHCI will handle TC before CC in the general case, so do
that.

Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
Signed-off-by: Lim Key Seong <key.seong.lim@intel.com>
---
 drivers/mmc/host/sdhci.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 33bf05f..6512c1e 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1377,6 +1377,10 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 		}
 	}
 
+	if ((host->quirks2 & SDHCI_QUIRK2_STOP_WITH_TC) && mrq->data &&
+	    mrq->data->stop)
+		mrq->data->stop->flags |= MMC_RSP_BUSY;
+
 	host->mrq = mrq;
 
 	if (!present || host->flags & SDHCI_DEVICE_DEAD) {
@@ -2344,9 +2348,6 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask, u32 *mask)
 
 		/* The controller does not support the end-of-busy IRQ,
 		 * fall through and take the SDHCI_INT_RESPONSE */
-	} else if ((host->quirks2 & SDHCI_QUIRK2_STOP_WITH_TC) &&
-		   host->cmd->opcode == MMC_STOP_TRANSMISSION && !host->data) {
-		*mask &= ~SDHCI_INT_DATA_END;
 	}
 
 	if (intmask & SDHCI_INT_RESPONSE)
-- 
1.7.5.4

