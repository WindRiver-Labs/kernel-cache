From 2de5304e31eeff6d0d0c17c5d61b56111c727316 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Mon, 5 Sep 2016 01:45:55 +0300
Subject: [PATCH 4650/4706] mei: dal: revamp acp parser code

commit 576c298eec18360a559fe7a6ca7d110744541d65 from
git://git.yoctoproject.org/linux-yocto-4.1

Linuxize ACP parser code.

Change-Id: Idd0f1f30e2b98dd1d741adb27f10a992faba8699
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Yael Samet <yael.samet@intel.com>
---
 drivers/misc/mei/dal/admin_pack_ext.c  |   14 ++--
 drivers/misc/mei/dal/admin_pack_int.c  |  164 ++++++++++++++++---------------
 drivers/misc/mei/dal/bh_acp_internal.h |   14 ++-
 3 files changed, 100 insertions(+), 92 deletions(-)

diff --git a/drivers/misc/mei/dal/admin_pack_ext.c b/drivers/misc/mei/dal/admin_pack_ext.c
index d08abec..66a9781 100644
--- a/drivers/misc/mei/dal/admin_pack_ext.c
+++ b/drivers/misc/mei/dal/admin_pack_ext.c
@@ -70,7 +70,7 @@ static int acp_load_pack(const char *raw_pack, unsigned int size,
 	struct ac_ins_jta_pack_ext *pack_ext;
 	struct ac_ins_jta_prop_ext *prop_ext;
 
-	if (pr_init(raw_pack, size, &pr) != BH_SUCCESS)
+	if (pr_init(&pr, raw_pack, size) != BH_SUCCESS)
 		return BHE_INVALID_BPK_FILE;
 
 	if (cmd_id != AC_INSTALL_JTA_PROP) {
@@ -104,7 +104,8 @@ static int acp_load_pack(const char *raw_pack, unsigned int size,
 	default:
 		return BHE_BAD_PARAMETER;
 	}
-	if (pr_is_end(&pr) != BH_SUCCESS)
+
+	if (!pr_is_end(&pr))
 		return BHE_INVALID_BPK_FILE;
 
 	return ret;
@@ -119,8 +120,8 @@ int acp_pload_ins_jta(const void *raw_data, unsigned int size,
 		return BHE_BAD_PARAMETER;
 
 	ret = acp_load_pack((const char *)raw_data + BH_ACP_CSS_HEADER_LENGTH,
-			size - BH_ACP_CSS_HEADER_LENGTH,
-			AC_INSTALL_JTA, (struct ac_pack *)pack);
+			    size - BH_ACP_CSS_HEADER_LENGTH,
+			    AC_INSTALL_JTA, (struct ac_pack *)pack);
 
 	return ret;
 }
@@ -146,9 +147,8 @@ int acp_get_cmd_id(const void *raw_data, unsigned int size, int *cmd_id)
 
 	*cmd_id = AC_CMD_INVALID;
 
-	ret = pr_init((const char *)raw_data + BH_ACP_CSS_HEADER_LENGTH,
-			size - BH_ACP_CSS_HEADER_LENGTH,
-			&pr);
+	ret = pr_init(&pr, raw_data + BH_ACP_CSS_HEADER_LENGTH,
+		      size - BH_ACP_CSS_HEADER_LENGTH);
 	if (ret != BH_SUCCESS)
 		return BHE_INVALID_BPK_FILE;
 
diff --git a/drivers/misc/mei/dal/admin_pack_int.c b/drivers/misc/mei/dal/admin_pack_int.c
index b197779..7b42cd8 100644
--- a/drivers/misc/mei/dal/admin_pack_int.c
+++ b/drivers/misc/mei/dal/admin_pack_int.c
@@ -75,14 +75,15 @@
 
 #define PR_ALIGN 4
 
-int pr_init(const char *data, unsigned int n, struct pack_reader *out)
+int pr_init(struct pack_reader *pr, const char *data, unsigned int n)
 {
 	/* check integer overflow */
 	if ((size_t)data > SIZE_MAX - n)
 		return BHE_INVALID_BPK_FILE;
 
-	out->cur = out->head = data;
-	out->total = n;
+	pr->cur = data;
+	pr->head = data;
+	pr->total = n;
 	return BH_SUCCESS;
 }
 
@@ -141,113 +142,122 @@ static int pr_move(struct pack_reader *pr, size_t n_move)
 	return BH_SUCCESS;
 }
 
-static int pr_is_safe_to_read(const struct pack_reader *pr, size_t n_move)
+static bool pr_is_safe_to_read(const struct pack_reader *pr, size_t n_move)
 {
 	/* pointer overflow */
 	if ((size_t)pr->cur > SIZE_MAX - n_move)
-		return BHE_INVALID_BPK_FILE;
+		return false;
 
 	if (pr->cur + n_move > pr->head + pr->total)
-		return BHE_INVALID_BPK_FILE;
+		return false;
 
-	return BH_SUCCESS;
+	return true;
 }
 
-int pr_is_end(struct pack_reader *pr)
+bool pr_is_end(struct pack_reader *pr)
 {
-	if (pr->cur == pr->head + pr->total)
-		return BH_SUCCESS;
-	else
-		return BHE_INVALID_BPK_FILE;
+	return (pr->cur == pr->head + pr->total);
 }
 
 static int acp_load_reasons(struct pack_reader *pr,
 			    struct ac_ins_reasons **reasons)
 {
 	size_t len;
+	struct ac_ins_reasons *r;
+
+	if (!pr_is_safe_to_read(pr, sizeof(*r)))
+		return BHE_INVALID_BPK_FILE;
+
+	r = (struct ac_ins_reasons *)pr->cur;
+
+	if (r->len > BH_MAX_ACP_INS_REASONS_LENGTH)
+		return BHE_INVALID_BPK_FILE;
 
-	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_reasons))
-			== BH_SUCCESS) {
-		*reasons = (struct ac_ins_reasons *) (pr->cur);
-		if ((*reasons)->len > BH_MAX_ACP_INS_REASONS_LENGTH)
-			return BHE_INVALID_BPK_FILE;
-		len = sizeof(struct ac_ins_reasons) +
-				(*reasons)->len * sizeof((*reasons)->data[0]);
-		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
-			return pr_align_move(pr, len);
-	}
-	return BHE_INVALID_BPK_FILE;
+	len = sizeof(*r) + r->len * sizeof(r->data[0]);
+	if (!pr_is_safe_to_read(pr, len))
+		return BHE_INVALID_BPK_FILE;
+
+	*reasons = r;
+	return pr_align_move(pr, len);
 }
 
 static int acp_load_taid_list(struct pack_reader *pr,
 			      struct bh_ta_id_list **taid_list)
 {
 	size_t len;
+	struct bh_ta_id_list *t;
+
+	if (!pr_is_safe_to_read(pr, sizeof(*t)))
+		return BHE_INVALID_BPK_FILE;
 
-	if (pr_is_safe_to_read(pr, sizeof(struct bh_ta_id_list)) ==
-			BH_SUCCESS) {
-		*taid_list = (struct bh_ta_id_list *) (pr->cur);
-		if ((*taid_list)->num > BH_MAX_ACP_USED_SERVICES)
-			return BHE_INVALID_BPK_FILE;
+	t = (struct bh_ta_id_list *)pr->cur;
+	if (t->num > BH_MAX_ACP_USED_SERVICES)
+		return BHE_INVALID_BPK_FILE;
+
+	len = sizeof(*t) + t->num * sizeof(t->list[0]);
 
-		len = sizeof(struct bh_ta_id_list) +
-				(*taid_list)->num *
-				sizeof((*taid_list)->list[0]);
+	if (!pr_is_safe_to_read(pr, len))
+		return BHE_INVALID_BPK_FILE;
 
-		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
-			return pr_align_move(pr, len);
-	}
-	return BHE_INVALID_BPK_FILE;
+	*taid_list = t;
+	return pr_align_move(pr, len);
 }
 
 static int acp_load_prop(struct pack_reader *pr, struct bh_prop_list **prop)
 {
 	size_t len;
+	struct bh_prop_list *p;
+
+	if (!pr_is_safe_to_read(pr, sizeof(*p)))
+		return BHE_INVALID_BPK_FILE;
 
-	if (pr_is_safe_to_read(pr, sizeof(struct bh_prop_list)) == BH_SUCCESS) {
-		*prop = (struct bh_prop_list *)pr->cur;
-		if ((*prop)->len > BH_MAX_ACP_PROPS_LENGTH)
-			return BHE_INVALID_BPK_FILE;
+	p = (struct bh_prop_list *)pr->cur;
+	if (p->len > BH_MAX_ACP_PROPS_LENGTH)
+		return BHE_INVALID_BPK_FILE;
 
-		len = sizeof(struct bh_prop_list) +
-				(*prop)->len * sizeof((*prop)->data[0]);
+	len = sizeof(*p) + p->len * sizeof(p->data[0]);
 
-		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
-			return pr_align_move(pr, len);
-	}
-	return BHE_INVALID_BPK_FILE;
+	if (!pr_is_safe_to_read(pr, len))
+		return BHE_INVALID_BPK_FILE;
+
+	*prop = p;
+	return pr_align_move(pr, len);
 }
 
 int acp_load_ta_pack(struct pack_reader *pr, char **ta_pack)
 {
 	size_t len;
+	char *t;
 
 	/*8 byte align to obey jeff rule*/
-	if (pr_8b_align_move(pr, 0) == BH_SUCCESS) {
-		*ta_pack = (char *)pr->cur;
-
-		/*
-		 *assume ta pack is the last item of one package,
-		 *move cursor to the end directly
-		 */
-		if (pr->cur > pr->head + pr->total)
-			return BHE_INVALID_BPK_FILE;
-		len = pr->head + pr->total - pr->cur;
-		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
-			return pr_move(pr, len);
-	}
-	return BHE_INVALID_BPK_FILE;
+	if (pr_8b_align_move(pr, 0) != BH_SUCCESS)
+		return BHE_INVALID_BPK_FILE;
+
+	t = (char *)pr->cur;
+
+	/*
+	 *assume ta pack is the last item of one package,
+	 *move cursor to the end directly
+	 */
+	if (pr->cur > pr->head + pr->total)
+		return BHE_INVALID_BPK_FILE;
+
+	len = pr->head + pr->total - pr->cur;
+	if (!pr_is_safe_to_read(pr, len))
+		return BHE_INVALID_BPK_FILE;
+
+	*ta_pack = t;
+	return pr_move(pr, len);
 }
 
 static int acp_load_ins_jta_prop_head(struct pack_reader *pr,
 				      struct ac_ins_jta_prop_header **head)
 {
-	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_jta_prop_header))
-			== BH_SUCCESS) {
-		*head = (struct ac_ins_jta_prop_header *) (pr->cur);
-		return pr_align_move(pr, sizeof(struct ac_ins_jta_prop_header));
-	}
-	return BHE_INVALID_BPK_FILE;
+	if (!pr_is_safe_to_read(pr, sizeof(struct ac_ins_jta_prop_header)))
+		return BHE_INVALID_BPK_FILE;
+
+	*head = (struct ac_ins_jta_prop_header *)pr->cur;
+	return pr_align_move(pr, sizeof(struct ac_ins_jta_prop_header));
 }
 
 int acp_load_ins_jta_prop(struct pack_reader *pr, struct ac_ins_jta_prop *pack)
@@ -281,12 +291,11 @@ out:
 static int acp_load_ins_jta_head(struct pack_reader *pr,
 				 struct ac_ins_ta_header **head)
 {
-	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_ta_header)) ==
-			BH_SUCCESS) {
-		*head = (struct ac_ins_ta_header *) (pr->cur);
-		return pr_align_move(pr, sizeof(struct ac_ins_ta_header));
-	}
-	return BHE_INVALID_BPK_FILE;
+	if (!pr_is_safe_to_read(pr, sizeof(struct ac_ins_ta_header)))
+		return BHE_INVALID_BPK_FILE;
+
+	*head = (struct ac_ins_ta_header *)pr->cur;
+	return pr_align_move(pr, sizeof(struct ac_ins_ta_header));
 }
 
 int acp_load_ins_jta(struct pack_reader *pr, struct ac_ins_jta_pack *pack)
@@ -306,12 +315,9 @@ int acp_load_ins_jta(struct pack_reader *pr, struct ac_ins_jta_pack *pack)
 
 int acp_load_pack_head(struct pack_reader *pr, struct ac_pack_header **head)
 {
-	int is_safe_to_read;
-
-	is_safe_to_read = pr_is_safe_to_read(pr, sizeof(struct ac_pack_header));
-	if (is_safe_to_read == BH_SUCCESS) {
-		*head = (struct ac_pack_header *) (pr->cur);
-		return pr_align_move(pr, sizeof(struct ac_pack_header));
-	}
-	return BHE_INVALID_BPK_FILE;
+	if (!pr_is_safe_to_read(pr, sizeof(struct ac_pack_header)))
+		return BHE_INVALID_BPK_FILE;
+
+	*head = (struct ac_pack_header *)pr->cur;
+	return pr_align_move(pr, sizeof(struct ac_pack_header));
 }
diff --git a/drivers/misc/mei/dal/bh_acp_internal.h b/drivers/misc/mei/dal/bh_acp_internal.h
index 990e9e6..a342f19 100644
--- a/drivers/misc/mei/dal/bh_acp_internal.h
+++ b/drivers/misc/mei/dal/bh_acp_internal.h
@@ -68,9 +68,12 @@
 /* Intel CSS Header + CSS Cypto Block which prefixes each signed ACP pkg */
 #define BH_ACP_CSS_HEADER_LENGTH    (128 + 520)
 
-/*
- * PackReader hold a reference of raw pack and read
- * items with alignment support
+/**
+ * struct pack_reader - hold a reference of raw pack and read
+ *     items with alignment support
+ * @cur   : current reader position
+ * @head  : buffer  head
+ * @total : bytes in the buffer
  */
 struct pack_reader {
 	const char *cur;
@@ -78,10 +81,9 @@ struct pack_reader {
 	unsigned int total;
 };
 
-int pr_init(const char *data, unsigned int n, struct pack_reader *out);
+int pr_init(struct pack_reader *pr, const char *data, unsigned int n);
 
-/*whether pack reader reaches the end of buffer, alignment considered*/
-int pr_is_end(struct pack_reader *pr);
+bool pr_is_end(struct pack_reader *pr);
 
 int acp_load_pack_head(struct pack_reader *pr, struct ac_pack_header **head);
 
-- 
1.7.5.4

