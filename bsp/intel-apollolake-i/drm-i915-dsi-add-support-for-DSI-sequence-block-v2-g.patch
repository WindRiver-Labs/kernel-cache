From c2655abe5edcea8d6f61fe12da91449af99e2230 Mon Sep 17 00:00:00 2001
From: Jani Nikula <jani.nikula@intel.com>
Date: Fri, 18 Mar 2016 13:11:10 +0200
Subject: [PATCH 2709/4706] drm/i915/dsi: add support for DSI sequence block
 v2 gpio element
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 1d96a4a8ace6c1b08c7d203d9533b14e59f2200b upstream

In sequence block v2, and only in v2, the gpio source (i.e. IOSF port)
is specified separately.

v2: initialize gpio_source to 0 and handle v1 and v2 in the same branch

Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/87152feec8f921dc82502af1b29c0956b0d360bb.1458299160.git.jani.nikula@intel.com
---
 drivers/gpu/drm/i915/intel_dsi_panel_vbt.c |   22 ++++++++++++++++++----
 1 files changed, 18 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dsi_panel_vbt.c b/drivers/gpu/drm/i915/intel_dsi_panel_vbt.c
index f687b2e..af1a47b 100644
--- a/drivers/gpu/drm/i915/intel_dsi_panel_vbt.c
+++ b/drivers/gpu/drm/i915/intel_dsi_panel_vbt.c
@@ -198,7 +198,7 @@ static const u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, const u8 *data)
 
 static const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)
 {
-	u8 gpio_index, action;
+	u8 gpio_source, gpio_index, action, port;
 	u16 function, pad;
 	u32 val;
 	struct drm_device *dev = intel_dsi->base.base.dev;
@@ -209,6 +209,12 @@ static const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)
 
 	gpio_index = *data++;
 
+	/* gpio source in sequence v2 only */
+	if (dev_priv->vbt.dsi.seq_version == 2)
+		gpio_source = (*data >> 1) & 3;
+	else
+		gpio_source = 0;
+
 	/* pull up/down */
 	action = *data++ & 1;
 
@@ -225,6 +231,15 @@ static const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)
 	if (dev_priv->vbt.dsi.seq_version >= 3) {
 		DRM_DEBUG_KMS("GPIO element v3 not supported\n");
 		goto out;
+	} else {
+		if (gpio_source == 0) {
+			port = IOSF_PORT_GPIO_NC;
+		} else if (gpio_source == 1) {
+			port = IOSF_PORT_GPIO_SC;
+		} else {
+			DRM_DEBUG_KMS("unknown gpio source %u\n", gpio_source);
+			goto out;
+		}
 	}
 
 	function = gtable[gpio_index].function_reg;
@@ -234,15 +249,14 @@ static const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)
 	if (!gtable[gpio_index].init) {
 		/* program the function */
 		/* FIXME: remove constant below */
-		vlv_iosf_sb_write(dev_priv, IOSF_PORT_GPIO_NC, function,
-				  0x2000CC00);
+		vlv_iosf_sb_write(dev_priv, port, function, 0x2000CC00);
 		gtable[gpio_index].init = 1;
 	}
 
 	val = 0x4 | action;
 
 	/* pull up/down */
-	vlv_iosf_sb_write(dev_priv, IOSF_PORT_GPIO_NC, pad, val);
+	vlv_iosf_sb_write(dev_priv, port, pad, val);
 	mutex_unlock(&dev_priv->sb_lock);
 
 out:
-- 
1.7.5.4

