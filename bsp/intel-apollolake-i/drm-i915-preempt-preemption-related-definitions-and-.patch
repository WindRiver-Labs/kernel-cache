From 55a1d346a2a7e0ad7a4c814c32b4d400c4f3b442 Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:16 -0700
Subject: [PATCH 1362/2508] drm/i915/preempt: preemption-related definitions
 and statistics

commit f69f263a14911576922a179c9f9440da040a4205 from
https://github.com/01org/linux-apollolake-i

For: VIZ-2021
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c   |   20 +++++++++++++++++
 drivers/gpu/drm/i915/i915_drv.h       |    1 +
 drivers/gpu/drm/i915/i915_scheduler.h |   39 +++++++++++++++++++++++++++++++-
 3 files changed, 58 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 924caa5..4b00e82 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -3693,6 +3693,7 @@ static int i915_scheduler_info(struct seq_file *m, void *unused)
 	struct intel_engine_cs *engine;
 	char   str[50 * (I915_NUM_ENGINES + 1)], name[50], *ptr;
 	int ret, i, e;
+	uint32_t pa[I915_NUM_ENGINES], pd[I915_NUM_ENGINES];
 
 	ret = mutex_lock_interruptible(&dev->mode_config.mutex);
 	if (ret)
@@ -3709,17 +3710,34 @@ static int i915_scheduler_info(struct seq_file *m, void *unused)
 		seq_printf(m, "%s\n", str);				\
 	} while (0)
 
+	for_each_engine_id(engine, dev_priv, e) {
+		pa[e] = intel_read_status_page(engine,
+						I915_PREEMPTIVE_ACTIVE_SEQNO);
+		pd[e] = intel_read_status_page(engine,
+						I915_PREEMPTIVE_DONE_SEQNO);
+	}
+
 	PRINT_VAR("Engine name:",           "s", dev_priv->engine[e].name);
 	PRINT_VAR("  Engine seqno",         "d", engine->get_seqno(engine, false));
+	PRINT_VAR("  Preemption active",    "d", pa[e]);
+	PRINT_VAR("  Preemption done",      "d", pd[e]);
 	seq_putc(m, '\n');
 
 	seq_puts(m, "Batch submissions:\n");
 	PRINT_VAR("  Queued",               "u", stats[e].queued);
 	PRINT_VAR("  Submitted",            "u", stats[e].submitted);
+	PRINT_VAR("  Preempted",            "u", stats[e].preempted);
 	PRINT_VAR("  Completed",            "u", stats[e].completed);
 	PRINT_VAR("  Expired",              "u", stats[e].expired);
 	seq_putc(m, '\n');
 
+	seq_puts(m, "Preemptions:\n");
+	PRINT_VAR("  Preempts queued",      "u", stats[e].preempts_queued);
+	PRINT_VAR("  Preempts submitted",   "u", stats[e].preempts_submitted);
+	PRINT_VAR("  Preempts completed",   "u", stats[e].preempts_completed);
+	PRINT_VAR("  Max preempted",        "u", stats[e].max_preempted);
+	seq_putc(m, '\n');
+
 	seq_puts(m, "Flush counts:\n");
 	PRINT_VAR("  By object",            "u", stats[e].flush_obj);
 	PRINT_VAR("  By request",           "u", stats[e].flush_req);
@@ -3730,6 +3748,8 @@ static int i915_scheduler_info(struct seq_file *m, void *unused)
 	seq_putc(m, '\n');
 
 	seq_puts(m, "Miscellaneous:\n");
+	PRINT_VAR("  Non batch launched",   "u", stats[e].non_batch);
+	PRINT_VAR("  Non batch landed",     "u", stats[e].non_batch_done);
 	PRINT_VAR("  ExecEarly retry",      "u", stats[e].exec_early);
 	PRINT_VAR("  ExecFinal requeue",    "u", stats[e].exec_again);
 	PRINT_VAR("  ExecFinal killed",     "u", stats[e].exec_dead);
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 239209d..d37748a 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -2389,6 +2389,7 @@ struct drm_i915_gem_request {
 	struct pid *pid;
 
 	struct i915_scheduler_queue_entry *scheduler_qe;
+	uint32_t scheduler_flags;
 
 	/**
 	 * The ELSP only accepts two elements at a time, so we queue
diff --git a/drivers/gpu/drm/i915/i915_scheduler.h b/drivers/gpu/drm/i915/i915_scheduler.h
index 6d7451c..3c76e97 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.h
+++ b/drivers/gpu/drm/i915/i915_scheduler.h
@@ -25,6 +25,16 @@
 #ifndef _I915_SCHEDULER_H_
 #define _I915_SCHEDULER_H_
 
+/* Flag bits for drm_i915_gem_request::scheduler_flags */
+enum {
+	/* Request not submitted via scheduler */
+	I915_REQ_SF_UNTRACKED        = (1 << 0),
+	/* Request was originally preemptive */
+	I915_REQ_SF_WAS_PREEMPT      = (1 << 1),
+	/* Request is preemptive */
+	I915_REQ_SF_PREEMPT          = (1 << 2),
+};
+
 enum i915_scheduler_queue_status {
 	/* Limbo: */
 	I915_SQS_NONE = 0,
@@ -34,6 +44,10 @@ enum i915_scheduler_queue_status {
 	I915_SQS_POPPED,
 	/* Sent to hardware for processing: */
 	I915_SQS_FLYING,
+	/* Sent to hardware for high-priority processing: */
+	I915_SQS_OVERTAKING,
+	/* Previously submitted, but not completed */
+	I915_SQS_PREEMPTED,
 	/* Finished processing on the hardware: */
 	I915_SQS_COMPLETE,
 	/* Killed by watchdog or catastrophic submission failure: */
@@ -45,11 +59,20 @@ char i915_scheduler_queue_status_chr(enum i915_scheduler_queue_status status);
 const char *i915_scheduler_queue_status_str(
 				enum i915_scheduler_queue_status status);
 
-#define I915_SQS_IS_QUEUED(node)	(((node)->status == I915_SQS_QUEUED))
-#define I915_SQS_IS_FLYING(node)	(((node)->status == I915_SQS_FLYING))
+#define I915_SQS_IS_QUEUED(node)	(((node)->status == I915_SQS_QUEUED) || \
+					 ((node)->status == I915_SQS_PREEMPTED))
+#define I915_SQS_IS_FLYING(node)	(((node)->status == I915_SQS_FLYING) || \
+					 ((node)->status == I915_SQS_OVERTAKING))
 #define I915_SQS_IS_COMPLETE(node)	(((node)->status == I915_SQS_COMPLETE) || \
 					 ((node)->status == I915_SQS_DEAD))
 
+#define I915_SQS_CASE_QUEUED		I915_SQS_QUEUED:		\
+					case I915_SQS_PREEMPTED
+#define I915_SQS_CASE_FLYING		I915_SQS_FLYING:		\
+					case I915_SQS_OVERTAKING
+#define I915_SQS_CASE_COMPLETE		I915_SQS_COMPLETE:		\
+					case I915_SQS_DEAD
+
 struct i915_scheduler_obj_entry {
 	struct drm_i915_gem_object *obj;
 	bool read_only;
@@ -87,9 +110,15 @@ struct i915_scheduler_stats {
 	/* Batch buffer counts: */
 	uint32_t queued;
 	uint32_t submitted;
+	uint32_t preempted;
 	uint32_t completed;
 	uint32_t expired;
 
+	uint32_t preempts_queued;
+	uint32_t preempts_submitted;
+	uint32_t preempts_completed;
+	uint32_t max_preempted;
+
 	/* Other stuff: */
 	uint32_t flush_obj;
 	uint32_t flush_req;
@@ -98,6 +127,8 @@ struct i915_scheduler_stats {
 	uint32_t flush_bump;
 	uint32_t flush_submit;
 
+	uint32_t non_batch;
+	uint32_t non_batch_done;
 	uint32_t exec_early;
 	uint32_t exec_again;
 	uint32_t exec_dead;
@@ -129,6 +160,10 @@ enum {
 	I915_SF_INTERRUPTS_ENABLED  = (1 << 0),
 	I915_SF_SUBMITTING          = (1 << 1),
 
+	/* Preemption-related state */
+	I915_SF_PREEMPTING          = (1 << 4),
+	I915_SF_PREEMPTED           = (1 << 5),
+
 	/* Dump/debug flags */
 	I915_SF_DUMP_FORCE          = (1 << 8),
 	I915_SF_DUMP_DETAILS        = (1 << 9),
-- 
1.7.5.4

