From a42b6767388e09848eef2fda6960c6f2c5247bd2 Mon Sep 17 00:00:00 2001
From: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
Date: Wed, 11 Jan 2017 14:15:31 +0800
Subject: [PATCH 4676/4706] usb: dwc3: call _DSM for core soft reset

commit cd78b8067c6e8aa8d37b5eb7ffb33b3034ba4ed7 from
git://git.yoctoproject.org/linux-yocto-4.1

The issue is, if core soft reset is issued while Intel Apollo Lake USB mux
is in Host role mode, it takes close to 7 minutes before we are able to
switch USB mux from Host mode to Device mode. This is due to RTL bug.

The workaround is to let BIOS issues the core soft reset via _DSM method.
It will ensure that USB mux is in Device role mode before issuing core
soft reset, and will inform the driver whether the reset is success within
the timeout value, or the timeout is exceeded.

Signed-off-by: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
---
 drivers/usb/dwc3/core.c          |   44 ++++++++++++++++++++++++++++++++++++++
 drivers/usb/dwc3/core.h          |    3 ++
 drivers/usb/dwc3/dwc3-pci.c      |    7 ++++++
 drivers/usb/dwc3/platform_data.h |    2 +
 4 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index d3cc2ba..d3a3d64 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -61,6 +61,35 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
 }
 
 /**
+ * WORKAROUND: We let BIOS issues the core soft reset to Device
+ * controller for Intel Apollo Lake, via _DSM method.
+ *
+ * The issue is, if core soft reset is issued while Intel Apollo Lake
+ * USB mux is in Host role mode, it takes close to 7 minutes before
+ * we are able to switch USB mux from Host mode to Device mode.
+ */
+static int dwc3_pci_dsm_soft_reset(struct device *dev)
+{
+	int			ret = -ETIMEDOUT;
+	union acpi_object	*obj;
+
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(dev),
+				"732b85d5-b7a7-4a1b-9ba0-4bbd00ffd511",
+				1, 6, NULL);
+	if (!obj) {
+		dev_err(dev, "failed to evaluate _DSM\n");
+		return -EIO;
+	}
+
+	if (obj->type == ACPI_TYPE_INTEGER)
+		ret = (obj->integer.value == 0) ? 0 : -ETIMEDOUT;
+	dev_dbg(dev, "dwc3_pci_dsm_soft_reset() ret= %d\n", ret);
+
+	ACPI_FREE(obj);
+	return ret;
+}
+
+/**
  * dwc3_core_soft_reset - Issues core soft reset and PHY reset
  * @dwc: pointer to our context structure
  */
@@ -90,6 +119,11 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 	if (dwc->dr_mode == USB_DR_MODE_HOST)
 		return 0;
 
+	if (dwc->has_dsm_for_softreset) {
+		dev_dbg(dwc->dev, "calling dwc3_pci_dsm_soft_reset()");
+		return dwc3_pci_dsm_soft_reset(dwc->dev);
+	}
+
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 	reg |= DWC3_DCTL_CSFTRST;
 	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
@@ -114,6 +148,11 @@ static int dwc3_soft_reset(struct dwc3 *dwc)
 	unsigned long timeout;
 	u32 reg;
 
+	if (dwc->has_dsm_for_softreset) {
+		dev_dbg(dwc->dev, "calling dwc3_pci_dsm_soft_reset()");
+		return dwc3_pci_dsm_soft_reset(dwc->dev);
+	}
+
 	timeout = jiffies + msecs_to_jiffies(500);
 	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
 	do {
@@ -928,6 +967,9 @@ static int dwc3_probe(struct platform_device *pdev)
 	device_property_read_u32(dev, "snps,quirk-frame-length-adjustment",
 				 &dwc->fladj);
 
+	dwc->has_dsm_for_softreset = device_property_read_bool(dev,
+				"has_dsm_for_softreset");
+
 	if (pdata) {
 		dwc->maximum_speed = pdata->maximum_speed;
 		dwc->has_lpm_erratum = pdata->has_lpm_erratum;
@@ -959,6 +1001,8 @@ static int dwc3_probe(struct platform_device *pdev)
 
 		dwc->hsphy_interface = pdata->hsphy_interface;
 		dwc->fladj = pdata->fladj_value;
+
+		dwc->has_dsm_for_softreset = pdata->has_dsm_for_softreset;
 	}
 
 	/* default to superspeed if no maximum_speed passed */
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 6797560..0c6da74 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -732,6 +732,7 @@ struct dwc3_scratchpad_array {
  * 	1	- -3.5dB de-emphasis
  * 	2	- No de-emphasis
  * 	3	- Reserved
+ * @has_dsm_for_softreset: set if we want to use BIOS to do core soft reset
  */
 struct dwc3 {
 	struct usb_ctrlrequest	*ctrl_req;
@@ -872,6 +873,8 @@ struct dwc3 {
 
 	unsigned		tx_de_emphasis_quirk:1;
 	unsigned		tx_de_emphasis:2;
+
+	unsigned		has_dsm_for_softreset:1;
 };
 
 /* -------------------------------------------------------------------------- */
diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 2812724..8ccb8ec 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -109,8 +109,15 @@ static int dwc3_pci_quirks(struct dwc3_pci *dwc)
 	    (pdev->device == PCI_DEVICE_ID_INTEL_BXT ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_BXT_M ||
 	     pdev->device == PCI_DEVICE_ID_INTEL_APL)) {
+		struct dwc3_platform_data pdata;
+
+		memset(&pdata, 0, sizeof(pdata));
+		pdata.has_dsm_for_softreset = true;
+
 		acpi_str_to_uuid(PCI_INTEL_BXT_DSM_UUID, dwc->uuid);
 		dwc->has_dsm_for_pm = true;
+
+		return platform_device_add_data(dwc3, &pdata, sizeof(pdata));
 	}
 
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
diff --git a/drivers/usb/dwc3/platform_data.h b/drivers/usb/dwc3/platform_data.h
index 2bb4d3a..bd4e29b 100644
--- a/drivers/usb/dwc3/platform_data.h
+++ b/drivers/usb/dwc3/platform_data.h
@@ -50,4 +50,6 @@ struct dwc3_platform_data {
 	u32 fladj_value;
 
 	const char *hsphy_interface;
+
+	unsigned has_dsm_for_softreset:1;
 };
-- 
1.7.5.4

