From f0510f19693eaf87e5b2587121ac5ff6e80e35e9 Mon Sep 17 00:00:00 2001
From: Bob Paauwe <bob.j.paauwe@intel.com>
Date: Fri, 22 Apr 2016 16:43:18 -0700
Subject: [PATCH 1421/2508] drm/i915: Introduce initial mode setting (v10)

commit 5b8b4a3ebc277166c872c7d85e7c37d769b82d3b from
https://github.com/01org/linux-apollolake-i

For very specific use cases it may be desirable to have the kernel
driver do an initial mode set and/or splash screen type display without
having to enable a framebuffer console.

A primary goal for this feature is to have the display lit up as soon
as possible.  A non-goal is the ability to detect and adapt to the
display configurations. In other words, the  display configuration will
be a known/fixed configuration.  In addition, it is expected that the
EDID information will be present and optimized so mode list creation
and taversal time is minimized.

Add a new module parameter that replaces the normal fbdev initialization
with a new initial mode set.  When the parameter is off, follow the normal
program flow and (if configured) initialize fbdev and a framebuffer
console.  When the parameter is on, do an atomic mode set with everything
off (no crtc's enabled).

This creates the framework for the modesetting and framebuffer code
in the following commits.

v2: Move comment down and format in kerneldoc format (Matt)
    Remove unused include files (Matt)
    Remove unused variables (Bob)
    Major code reorganizations and remove dependencies on fb helper code.
v3: Remove the modeset_info structure.
    Merge the initial modesetting code to create a complete implementation.
    Rename width/height to max_width/max_height in set_display_mode (Matt)
    Fix out of date comment about allocating empty framebuffer (Matt)
v4: Remove the modeset structure abstraction and use atomic state directly.
v5: Remove redundent call to drm_atomic_add_affected_connectors(). (Chi)
    Fix atomic commit locking. (Bob)
v6: Remove the modeset_info structure and pass state around instead. (Matt)
v7: Change the initial split of the first two commits.  This commit now
    sets an initial config with everything off.  The next commit adds
    checking connector status and turns on those with attached displays.
v8: Tweak the docbook info and add to drm.tmpl (Matt)
    Change disable_planes to propogate errors (Matt)
    Remove the expliced setting of disabled planes crtc & src rect (Matt)
    Remove any old framebuffers after disabling the plane (Bob)
    Move the atomic commit and uplevel the backoff code handling (Matt)
v9: Property handle initial framebuffer dereference here by moving it
    up from a later patch.
    Rename file to intel_initial_modeset.c to be less confusing (Matt)
    Change module paramter to a boolean (Matt)
    Use a workqueue instead of async schedule (Matt)
v10: remove double ;; (Matt)
     Change DRM_ERROR to DRM_DEBUG_KSM on deadlock (Matt)

Signed-off-by: Bob Paauwe <bob.j.paauwe@intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Reviewed-by: James Xiong <james.xiong@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 Documentation/DocBook/drm.tmpl               |    6 +
 drivers/gpu/drm/i915/Makefile                |    3 +
 drivers/gpu/drm/i915/i915_dma.c              |   22 +++-
 drivers/gpu/drm/i915/i915_drv.h              |    1 +
 drivers/gpu/drm/i915/i915_params.c           |    5 +
 drivers/gpu/drm/i915/i915_params.h           |    1 +
 drivers/gpu/drm/i915/intel_drv.h             |    4 +
 drivers/gpu/drm/i915/intel_initial_modeset.c |  141 ++++++++++++++++++++++++++
 8 files changed, 177 insertions(+), 6 deletions(-)
 create mode 100644 drivers/gpu/drm/i915/intel_initial_modeset.c

diff --git a/Documentation/DocBook/drm.tmpl b/Documentation/DocBook/drm.tmpl
index a16f4ef..2857341 100644
--- a/Documentation/DocBook/drm.tmpl
+++ b/Documentation/DocBook/drm.tmpl
@@ -3230,6 +3230,12 @@ int num_ioctls;</synopsis>
 !Idrivers/gpu/drm/i915/intel_bios.c
 !Idrivers/gpu/drm/i915/intel_vbt_defs.h
       </sect2>
+
+      <sect2>
+       <title>Boot-time mode setting</title>
+!Pdrivers/gpu/drm/i915/intel_modeset.c boot-time mode setting
+!Idrivers/gpu/drm/i915/intel_modeset.c
+      </sect2>
     </sect1>
 
     <sect1>
diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index 2aa44d2..d7680c8 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -105,6 +105,9 @@ i915-y += i915_dma.o
 # perfmon
 i915-y += i915_perfmon.o
 
+# initial modeset
+i915-y += intel_initial_modeset.o
+
 obj-$(CONFIG_DRM_I915)  += i915.o
 
 CFLAGS_i915_trace_points.o := -I$(src)
diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index 6b7ba22..1305483 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -489,9 +489,11 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	if (INTEL_INFO(dev)->num_pipes == 0)
 		return 0;
 
-	ret = intel_fbdev_init(dev);
-	if (ret)
-		goto cleanup_gem;
+	if (!i915.enable_initial_modeset) {
+		ret = intel_fbdev_init(dev);
+		if (ret)
+			goto cleanup_gem;
+	}
 
 	/* Only enable hotplug handling once the fbdev is fully set up. */
 	intel_hpd_init(dev_priv);
@@ -506,7 +508,10 @@ static int i915_load_modeset_init(struct drm_device *dev)
 	 * scanning against hotplug events. Hence do this first and ignore the
 	 * tiny window where we will loose hotplug notifactions.
 	 */
-	intel_fbdev_initial_config_async(dev);
+	if (i915.enable_initial_modeset)
+		intel_initial_mode_config_init(dev);
+	else
+		intel_fbdev_initial_config_async(dev);
 
 	drm_kms_helper_poll_init(dev);
 
@@ -1467,7 +1472,10 @@ int i915_driver_unload(struct drm_device *dev)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int ret;
 
-	intel_fbdev_fini(dev);
+	if (!i915.enable_initial_modeset)
+		intel_fbdev_fini(dev);
+	else
+		intel_initial_mode_config_fini(dev);
 
 	ret = i915_gem_suspend(dev);
 	if (ret) {
@@ -1557,7 +1565,9 @@ int i915_driver_open(struct drm_device *dev, struct drm_file *file)
  */
 void i915_driver_lastclose(struct drm_device *dev)
 {
-	intel_fbdev_restore_mode(dev);
+	if (!i915.enable_initial_modeset) {
+		intel_fbdev_restore_mode(dev);
+	}
 	vga_switcheroo_process_delayed_switch();
 }
 
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index bd94182..3bd9e0f 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1939,6 +1939,7 @@ struct drm_i915_private {
 	struct intel_pipe_crc pipe_crc[I915_MAX_PIPES];
 #endif
 	struct intel_load_profiles profile;
+	struct work_struct initial_modeset_work;
 
 	/* dpll and cdclk state is protected by connection_mutex */
 	int num_shared_dpll;
diff --git a/drivers/gpu/drm/i915/i915_params.c b/drivers/gpu/drm/i915/i915_params.c
index b02d5da..300a0ea 100644
--- a/drivers/gpu/drm/i915/i915_params.c
+++ b/drivers/gpu/drm/i915/i915_params.c
@@ -64,6 +64,7 @@ struct i915_params i915 __read_mostly = {
 	.enable_scheduler = 1,
 	.enable_preemption = 1,
 	.enable_dpcd_backlight = false,
+	.enable_initial_modeset = false,
 };
 
 module_param_named(modeset, i915.modeset, int, 0400);
@@ -238,3 +239,7 @@ MODULE_PARM_DESC(enable_preemption, "Enable pre-emption within scheduler  (0 = d
 module_param_named(enable_dpcd_backlight, i915.enable_dpcd_backlight, bool, 0600);
 MODULE_PARM_DESC(enable_dpcd_backlight,
 	"Enable support for DPCD backlight control (default:false)");
+
+module_param_named_unsafe(enable_initial_modeset, i915.enable_initial_modeset, bool, 0400);
+MODULE_PARM_DESC(enable_initial_modeset,
+		 "Do initial modeset for TSD usecase (default : false)");
diff --git a/drivers/gpu/drm/i915/i915_params.h b/drivers/gpu/drm/i915/i915_params.h
index 56ad42c..65bd589 100644
--- a/drivers/gpu/drm/i915/i915_params.h
+++ b/drivers/gpu/drm/i915/i915_params.h
@@ -67,6 +67,7 @@ struct i915_params {
 	bool enable_dp_mst;
 	bool enable_ipc;
 	bool enable_dpcd_backlight;
+	bool enable_initial_modeset;
 };
 
 extern struct i915_params i915 __read_mostly;
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 695be5d..972cf48 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -1417,6 +1417,10 @@ static inline void intel_fbdev_restore_mode(struct drm_device *dev)
 }
 #endif
 
+/* initial modesetting support */
+extern void intel_initial_mode_config_init(struct drm_device *dev);
+extern void intel_initial_mode_config_fini(struct drm_device *dev);
+
 /* intel_fbc.c */
 void intel_fbc_choose_crtc(struct drm_i915_private *dev_priv,
 			   struct drm_atomic_state *state);
diff --git a/drivers/gpu/drm/i915/intel_initial_modeset.c b/drivers/gpu/drm/i915/intel_initial_modeset.c
new file mode 100644
index 0000000..a90e61a
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_initial_modeset.c
@@ -0,0 +1,141 @@
+/*
+ *
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions: *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/**
+ * DOC: Boot-time mode setting.
+ *
+ * There exists a use case where the kernel graphics needs to be initialized
+ * with a valid display configuration with full display pipeline programming
+ * in place before user space is initialized and without a fbdev & fb console.
+ *
+ * The primary motivation is to allow early user space applications to
+ * display a frame (or frames) as soon as possible after user space starts.
+ * Eliminating the time it takes userspace to program the display configuration
+ * benefits this use case.
+ *
+ * By doing all the display programming in the kernel, it can be done in
+ * parallel with other kernel startup tasks without adding significant
+ * elapshed time before user space starts.
+ */
+
+#include "intel_drv.h"
+#include "i915_drv.h"
+
+
+static int disable_planes(struct drm_device *dev,
+			  struct drm_atomic_state *state)
+{
+	struct drm_plane *plane;
+	int ret;
+
+	drm_for_each_plane(plane, dev) {
+		struct drm_plane_state *plane_state;
+
+		plane->old_fb = plane->fb;
+
+		plane_state = drm_atomic_get_plane_state(state, plane);
+		if (IS_ERR(plane_state)) {
+			return PTR_ERR(plane_state);
+		}
+
+		ret = drm_atomic_plane_set_property(plane, plane_state,
+					dev->mode_config.rotation_property,
+					BIT(DRM_ROTATE_0));
+		WARN_ON(ret);
+
+		ret = drm_atomic_set_crtc_for_plane(plane_state, NULL);
+		if (ret != 0)
+			return ret;
+
+		drm_atomic_set_fb_for_plane(plane_state, NULL);
+	}
+
+	return 0;
+}
+
+/*
+ * The modeset_config is scheduled to run via an async
+ * schedule call from the main driver load.
+ */
+static void modeset_config_fn(struct work_struct *work)
+{
+	struct drm_i915_private *dev_priv =
+		container_of(work, typeof(*dev_priv), initial_modeset_work);
+	struct drm_device *dev = dev_priv->dev;
+	struct drm_atomic_state *state;
+	struct drm_modeset_acquire_ctx ctx;
+	struct drm_plane *plane;
+	int ret;
+
+	state = drm_atomic_state_alloc(dev);
+	if (!state)
+		return;
+
+	drm_modeset_acquire_init(&ctx, 0);
+	state->acquire_ctx = &ctx;
+	drm_modeset_lock_all_ctx(dev, &ctx);
+
+	ret = drm_modeset_lock(&dev->mode_config.connection_mutex,
+			       state->acquire_ctx);
+	if (ret)
+		goto out;
+
+retry:
+	ret = disable_planes(dev, state);
+	if (ret == 0)
+		ret = drm_atomic_commit(state);
+
+	if (ret == -EDEADLK) {
+		DRM_DEBUG_KMS("modeset commit deadlock, retry...\n");
+		drm_modeset_backoff(&ctx);
+		drm_atomic_state_clear(state);
+		goto retry;
+	}
+
+out:
+	if (ret)
+		drm_atomic_state_free(state);
+	else
+		drm_for_each_plane(plane, dev) {
+			if (plane->old_fb)
+				drm_framebuffer_unreference(plane->old_fb);
+		}
+
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+}
+
+void intel_initial_mode_config_init(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	INIT_WORK(&dev_priv->initial_modeset_work, modeset_config_fn);
+	schedule_work(&dev_priv->initial_modeset_work);
+}
+
+void intel_initial_mode_config_fini(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = to_i915(dev);
+
+	flush_work(&dev_priv->initial_modeset_work);
+}
-- 
1.7.5.4

