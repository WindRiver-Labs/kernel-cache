From 4fad4195998aaa000e35ce8d28ffabb4f591665e Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Sun, 18 Dec 2016 11:29:15 +0200
Subject: [PATCH 4649/4706] mei: dal: remove kdi_transport send/recv ops

commit f72d76ec4a08ead6c7a330767a78d1fe1e25c84c from
git://git.yoctoproject.org/linux-yocto-4.1

Call kdi_send and kdi_recv explicitly from bhp instead of
via transport op, there is not really other possible
transport to use and we can safely remove this abstraction.
Adjust kdi_send and kdi_recv signatures to reflect the usage.

Change-Id: I4ccdc149137c3d9e37d4eab7465096f997c66f5c
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/bhp_exp.h  |    8 +----
 drivers/misc/mei/dal/bhp_impl.c |   65 ++++++++++++---------------------------
 drivers/misc/mei/dal/dal_dev.h  |    3 ++
 drivers/misc/mei/dal/dal_kdi.c  |   16 +++------
 4 files changed, 29 insertions(+), 63 deletions(-)

diff --git a/drivers/misc/mei/dal/bhp_exp.h b/drivers/misc/mei/dal/bhp_exp.h
index df5878d..d35f1a9 100644
--- a/drivers/misc/mei/dal/bhp_exp.h
+++ b/drivers/misc/mei/dal/bhp_exp.h
@@ -65,12 +65,6 @@
 
 #include "bh_errcode.h"
 
-struct bhp_transport {
-	int (*send)(unsigned int handle,
-		    unsigned char *buf, unsigned int len, u64 seq);
-	int (*recv)(unsigned int handle, unsigned char *buf, unsigned int *len);
-};
-
 /**
  * Invoke this function before using other API.
  * It will try to connect ME processes(Launcher, SDM and I-VM),
@@ -84,7 +78,7 @@ struct bhp_transport {
  * @return BPE_INTERNAL_ERROR if receiver thread cannot be
  * created or other internal failure
  */
-int bhp_init_internal(const struct bhp_transport *transport);
+int bhp_init_internal(void);
 
 /**
  * Invoke this function before exiting.
diff --git a/drivers/misc/mei/dal/bhp_impl.c b/drivers/misc/mei/dal/bhp_impl.c
index 88b8fec..ba025ea 100644
--- a/drivers/misc/mei/dal/bhp_impl.c
+++ b/drivers/misc/mei/dal/bhp_impl.c
@@ -67,7 +67,6 @@
 static unsigned int init_state = DEINITED;
 static u64 sequence_number = MSG_SEQ_START_NUMBER;
 static struct bh_connection_item connections[MAX_CONNECTIONS];
-static struct bhp_transport bhp_transport;
 
 /*
  * increment_seq_number():
@@ -346,53 +345,48 @@ bool bhp_is_initialized(void)
 static char skip_buffer[DAL_MAX_BUFFER_SIZE] = {0};
 static int bh_transport_recv(unsigned int handle, void *buffer, size_t size)
 {
-	size_t got = 0;
+	size_t got;
 	size_t count = 0;
-	int status = 0;
+	int ret;
+	char *buf = buffer;
 
 	if (handle > DAL_MEI_DEVICE_MAX)
 		return BPE_COMMS_ERROR;
 
 	while (size - count > 0) {
+		got = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
+		if (buf)
+			ret = kdi_recv(handle, buf + count, &got);
+		else
+			ret = kdi_recv(handle, skip_buffer, &got);
 
-		if (buffer) {
-			got = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
-			status = bhp_transport.recv(handle,
-					(unsigned char *) buffer + count,
-					(unsigned int *) &got);
-		} else {
-			got = min_t(size_t, DAL_MAX_BUFFER_SIZE, size - count);
-			status = bhp_transport.recv(handle,
-					skip_buffer, (unsigned int *) &got);
-		}
-
-		if (status != 0)
-			return BPE_COMMS_ERROR;
+		if (ret != BH_SUCCESS)
+			return ret;
 
 		count += got;
 	}
 
-	return status == BH_SUCCESS && count == size ? BH_SUCCESS : status;
+	return ret == BH_SUCCESS && count == size ? BH_SUCCESS : ret;
 }
 
 static int bh_transport_send(unsigned int handle, const void *buffer,
 			     unsigned int size, u64 seq)
 {
-	unsigned int written = 0;
+	size_t chunk_sz;
 	unsigned int count = 0;
-	int status = 0;
+	int ret;
+	const char *buf = buffer;
 
 	if (handle > DAL_MEI_DEVICE_MAX)
 		return BPE_COMMS_ERROR;
 
 	while (size - count > 0) {
-		written = min_t(u32, size - count, DAL_MAX_BUFFER_SIZE);
-		status = bhp_transport.send(handle,
-				(unsigned char *)buffer + count, written, seq);
-		if (status != 0)
-			return BPE_COMMS_ERROR;
+		chunk_sz = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
+		ret = kdi_send(handle, buf + count, chunk_sz, seq);
+		if (ret != BH_SUCCESS)
+			return ret;
 
-		count += written;
+		count += chunk_sz;
 	}
 
 	return BH_SUCCESS;
@@ -512,16 +506,6 @@ static int bh_recv_message(int conn_idx, u64 *seq)
 	return ret;
 }
 
-static int bh_transport_init(const struct bhp_transport *context)
-{
-	memcpy(&bhp_transport, context, sizeof(struct bhp_transport));
-
-	if (!bhp_transport.send || !bhp_transport.recv)
-		return BPE_INVALID_PARAMS;
-
-	return BH_SUCCESS;
-}
-
 static void bh_do_connect(int conn_idx)
 {
 	struct bh_connection_item *conn = &connections[conn_idx];
@@ -614,21 +598,12 @@ int bh_cmd_transfer(int conn_idx, void *cmd, unsigned int clen,
 	return ret;
 }
 
-int bhp_init_internal(const struct bhp_transport *transport)
+int bhp_init_internal(void)
 {
-	int ret;
-
 	if (bhp_is_initialized())
 		return BPE_INITIALIZED_ALREADY;
 
-	if (!transport)
-		return BPE_INVALID_PARAMS;
-
 	/* step 1: init connections to each process */
-	ret = bh_transport_init(transport);
-	if (ret)
-		return ret;
-
 	bh_connections_init();
 
 	/* RESET flow removed to allow JHI and KDI to coexist */
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 5be9ff0..14e313c 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -233,4 +233,7 @@ int dal_access_policy_allowed(struct dal_device *ddev,
 void dal_access_list_free(struct dal_device *ddev);
 int dal_access_list_init(struct dal_device *ddev);
 
+int kdi_send(unsigned int handle, const unsigned char *buf,
+	     size_t len, u64 seq);
+int kdi_recv(unsigned int handle, unsigned char *buf, size_t *count);
 #endif  /* _DAL_KDI_H_ */
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index af2faa64..7b21933 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -145,8 +145,8 @@ static struct class_interface kdi_interface __refdata = {
 	.remove_dev     = kdi_rm_dev,
 };
 
-static int kdi_send(unsigned int handle,
-		    unsigned char *buf, unsigned int len, u64 seq)
+int kdi_send(unsigned int handle, const unsigned char *buf,
+	     size_t len, u64 seq)
 {
 	enum dal_dev_type mei_device;
 	struct dal_device *ddev;
@@ -193,8 +193,7 @@ out:
 	return ret;
 }
 
-static int kdi_recv(unsigned int handle,
-		    unsigned char *buf, unsigned int *count)
+int kdi_recv(unsigned int handle, unsigned char *buf, size_t *count)
 {
 	enum dal_dev_type mei_device;
 	struct dal_device *ddev;
@@ -241,7 +240,7 @@ static int kdi_recv(unsigned int handle,
 	}
 
 	if (len > *count) {
-		dev_err(&ddev->dev, "could not copy buffer: src size = %zd > dest size = %u\n",
+		dev_err(&ddev->dev, "could not copy buffer: src size = %zd > dest size = %zd\n",
 			len, *count);
 		ret = BPE_COMMS_ERROR;
 		goto out;
@@ -261,11 +260,6 @@ out:
 	return ret;
 }
 
-static struct bhp_transport kdi_transport = {
-	.send = kdi_send,
-	.recv = kdi_recv,
-};
-
 static int kdi_create_session(u64 *handle, const char *jta_id,
 			      const u8 *buffer, size_t buffer_length,
 			      const u8 *init_param, size_t init_param_length)
@@ -331,7 +325,7 @@ int kdi_init(u32 flags, u64 *handle)
 	if (ret)
 		return DAL_KDI_STATUS_INTERNAL_ERROR;
 
-	bh_err = bhp_init_internal(&kdi_transport);
+	bh_err = bhp_init_internal();
 	ret = bh_err_to_kdi_err(bh_err);
 	if (bh_err) {
 		class_interface_unregister(&kdi_interface);
-- 
1.7.5.4

