From 3bcb7d55ed738ed2f7c085a2bcacb3272a2f2e33 Mon Sep 17 00:00:00 2001
From: Jon Bloomfield <jon.bloomfield@intel.com>
Date: Mon, 27 Jun 2016 13:25:40 -0700
Subject: [PATCH 1481/2508] drm/i915: Introduce extended ioctl interface

commit 0516952883e7278376dc88f3be2bc32e53164f66 from
https://github.com/01org/linux-apollolake-i

Adds a new extended ioctl mechanism, allowing several discrete
ioctls to share a single device ioctl.

Extended ioctls are defined similarly to the standard ioctls:
    In include/uapi/drm/i915_drm.h:
    	struct myfunc_iface
    	{
    		...
    	};

    	#define DRM_I915_EXT_MYFUNC 0x1 /* Any value from 0x00-0xFF */

    	#define DRM_IOCTL_I915_EXT_MYFUNC \
    		DRM_IOWR(DRM_I915_EXT_MYFUNC, struct myfunc_iface)

    In drivers/gpu/drm/i915/i915_ext_ioctl.h:
    	int i915_myfunc(struct drm_device *dev, void *data,
    			struct drm_file *file_priv);

    In drivers/gpu/drm/i915/i915_ext_ioctl.c:
    	const struct drm_ioctl_desc i915_ext_ioctls[] = {
    	    ...

    	    EXT_IOCTL_DEF(I915_EXT_MYFUNC, i915_myfunc,
    		DRM_UNLOCKED|DRM_CONTROL_ALLOW|DRM_RENDER_ALLOW),
    	    ...
    	 };

The interface allows for multiple groups of extended ioctls, by providing a
table field. This could be used in the future to select from one of many
extended ioctl tables. Currently the table is fixed at 0, and only a single
table (i915_ext_ioctls) is permitted.

v2: Use u64 instead of void * for args to avoid 32-bit/64-bit
    userspace/kernelspace issues.

v3: Removed checkpatch warnings (Whitespace/error string split over two
    lines)

v4: Fixed drm_global_mutex compilation warning with include of
    drm_internal.h in i915_ext_ioctl.c

v5: Added EXT_IOCTL_DEF in i915_ext_ioctl.c to handle changes in new
    kernel to DRM_IOCTL_DEF_DRV.

Tracked-On:
Issue: VIZ-3781
Signed-off-by: Jon Bloomfield <jon.bloomfield@intel.com>
Signed-off-by: Robert Beckett <robert.beckett@intel.com>
[Jeff: Export drm_global_mutex from drm to support i915 as a module]
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
[mattrope: checkpatch tweaks]
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>

Conflicts:
	drivers/gpu/drm/i915/Makefile
	drivers/gpu/drm/i915/i915_dma.c
	include/uapi/drm/i915_drm.h
---
 drivers/gpu/drm/drm_fops.c            |    1 +
 drivers/gpu/drm/i915/Makefile         |    3 +
 drivers/gpu/drm/i915/i915_dma.c       |    9 ++
 drivers/gpu/drm/i915/i915_ext_ioctl.c |  171 +++++++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/i915_ext_ioctl.h |   36 +++++++
 include/uapi/drm/i915_drm.h           |   22 ++++
 6 files changed, 242 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpu/drm/i915/i915_ext_ioctl.c
 create mode 100644 drivers/gpu/drm/i915/i915_ext_ioctl.h

diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c
index aeef58e..b35b6c1 100644
--- a/drivers/gpu/drm/drm_fops.c
+++ b/drivers/gpu/drm/drm_fops.c
@@ -43,6 +43,7 @@
 
 /* from BKL pushdown */
 DEFINE_MUTEX(drm_global_mutex);
+EXPORT_SYMBOL(drm_global_mutex);
 
 /**
  * DOC: file operations
diff --git a/drivers/gpu/drm/i915/Makefile b/drivers/gpu/drm/i915/Makefile
index ff4fe01..f258b0a 100644
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -109,6 +109,9 @@ i915-y += i915_perfmon.o
 # initial modeset
 i915-y += intel_initial_modeset.o
 
+# Extended ioctl interface
+i915-y += i915_ext_ioctl.o
+
 obj-$(CONFIG_DRM_I915)  += i915.o
 
 CFLAGS_i915_trace_points.o := -I$(src)
diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index 50db6a4..cf0c802 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -50,6 +50,7 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/oom.h>
+#include "i915_ext_ioctl.h"
 #include "iotg_build.h"
 
 static unsigned int i915_load_fail_count;
@@ -1654,6 +1655,14 @@ const struct drm_ioctl_desc i915_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_GETPARAM, i915_gem_context_getparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_GEM_CONTEXT_SETPARAM, i915_gem_context_setparam_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(I915_PERFMON, i915_perfmon_ioctl, DRM_UNLOCKED),
+
+/*
+ * Extended ioctl layers extra ioctls into a single master ioctl
+ * Must allow full access to this ioctl - The i915_extended_ioctl
+ * handler will apply appropriate tests for the underlying ioctl
+ */
+	DRM_IOCTL_DEF_DRV(I915_EXT_IOCTL, i915_extended_ioctl,
+			  DRM_UNLOCKED|DRM_CONTROL_ALLOW|DRM_RENDER_ALLOW),
 };
 
 int i915_max_ioctl = ARRAY_SIZE(i915_ioctls);
diff --git a/drivers/gpu/drm/i915/i915_ext_ioctl.c b/drivers/gpu/drm/i915/i915_ext_ioctl.c
new file mode 100644
index 0000000..ceebe89
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_ext_ioctl.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jon Bloomfield <jon.bloomfield@intel.com>
+ *
+ */
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
+#include "i915_drv.h"
+#include "i915_ext_ioctl.h"
+#include "../drm_internal.h"
+
+const struct drm_ioctl_desc i915_ext_ioctls[];
+int i915_max_ext_ioctl;
+
+int i915_extended_ioctl(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv)
+{
+	struct i915_ext_ioctl_data *args = data;
+	const struct drm_ioctl_desc *ioctl = NULL;
+	drm_ioctl_t *func;
+	unsigned int cmd = args->sub_cmd;
+	void __user *arg = to_user_ptr(args->args_ptr);
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	int retcode = -EINVAL;
+	char stack_kdata[128];
+	char *kdata = NULL;
+	unsigned int usize, asize;
+
+	DRM_DEBUG("sub_nr=%u, table=%u, available ext_ioctls=%d\n",
+			nr,
+			(unsigned int)args->table,
+			i915_max_ext_ioctl);
+
+	/* table is reserved for future expansion, and must be 0 */
+	if (args->table > 0) {
+		DRM_ERROR("table range error\n");
+		goto err_i1;
+	} else if (nr >= i915_max_ext_ioctl) {
+		DRM_ERROR("sub_nr range error\n");
+		goto err_i1;
+	} else {
+		u32 drv_size;
+
+		DRM_DEBUG("sub_nr is in range\n");
+
+		ioctl = &i915_ext_ioctls[nr];
+		drv_size = _IOC_SIZE(ioctl->cmd);
+		usize = asize = _IOC_SIZE(cmd);
+		if (drv_size > asize)
+			asize = drv_size;
+
+		cmd = ioctl->cmd;
+	}
+
+	DRM_DEBUG("pid=%d, dev=0x%lx, auth=%d, %s\n",
+		task_pid_nr(current),
+		(long)old_encode_dev(file_priv->minor->kdev->devt),
+		file_priv->authenticated, ioctl->name);
+
+	/* Do not trust userspace, use our own definition */
+	func = ioctl->func;
+
+	if (unlikely(!func)) {
+		DRM_DEBUG("no function\n");
+		retcode = -EINVAL;
+		goto err_i1;
+	}
+
+	retcode = drm_ioctl_permit(ioctl->flags, file_priv);
+	if (unlikely(retcode))
+		goto err_i1;
+
+	if (cmd & (IOC_IN | IOC_OUT)) {
+		if (asize <= sizeof(stack_kdata)) {
+			kdata = stack_kdata;
+		} else {
+			kdata = kmalloc(asize, GFP_KERNEL);
+			if (!kdata) {
+				DRM_ERROR("nomem\n");
+				retcode = -ENOMEM;
+				goto err_i1;
+			}
+		}
+
+		if (cmd & IOC_IN) {
+			if (copy_from_user(kdata, arg, usize) != 0) {
+				DRM_ERROR("copy in failed\n");
+				retcode = -EFAULT;
+				goto err_i1;
+			}
+		} else {
+			memset(kdata, 0, usize);
+			if (asize > usize)
+				memset(kdata + usize, 0, asize - usize);
+		}
+	}
+
+	if (ioctl->flags & DRM_UNLOCKED) {
+		retcode = func(dev, kdata, file_priv);
+	} else {
+		mutex_lock(&drm_global_mutex);
+		retcode = func(dev, kdata, file_priv);
+		mutex_unlock(&drm_global_mutex);
+	}
+	DRM_DEBUG("sub-func returned %d\n", retcode);
+
+	if (cmd & IOC_OUT) {
+		if (copy_to_user(arg, kdata, usize) != 0) {
+			DRM_ERROR("copy out failed\n");
+			retcode = -EFAULT;
+		} else
+			DRM_DEBUG("copy-out succeeded\n");
+	}
+
+
+err_i1:
+	if (!ioctl) {
+		DRM_ERROR("%s: pid=%d, dev=0x%lx, auth=%d, cmd=0x%x, nr=0x%x\n",
+			  "invalid ioctl",
+			  task_pid_nr(current),
+			  (long)old_encode_dev(file_priv->minor->kdev->devt),
+			  file_priv->authenticated, cmd, nr);
+	}
+
+	if (kdata != stack_kdata)
+		kfree(kdata);
+	if (retcode)
+		DRM_ERROR("ret = %d\n", retcode);
+	return retcode;
+}
+
+/*
+ * ----------------------------------------------------------------------------
+ * Extended ioctl interface table
+ * Format is identical to the standard ioctls
+ * ----------------------------------------------------------------------------
+ */
+
+#define EXT_IOCTL_DEF(ioctl, _func, _flags)	\
+	[DRM_IOCTL_NR(ioctl)] = {		\
+		.cmd = ioctl,			\
+		.func = _func,			\
+		.flags = _flags,		\
+		.name = #ioctl			\
+	}
+
+const struct drm_ioctl_desc i915_ext_ioctls[] = {
+};
+
+int i915_max_ext_ioctl = ARRAY_SIZE(i915_ext_ioctls);
diff --git a/drivers/gpu/drm/i915/i915_ext_ioctl.h b/drivers/gpu/drm/i915/i915_ext_ioctl.h
new file mode 100644
index 0000000..158fa7a
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_ext_ioctl.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jon Bloomfield <jon.bloomfield@intel.com>
+ *
+ */
+
+#ifndef _I915_EXT_IOCTL_H_
+#define _I915_EXT_IOCTL_H_
+
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
+
+extern int i915_extended_ioctl(struct drm_device *dev, void *data,
+			       struct drm_file *file_priv);
+#endif
diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 9e85fec..6f9f59f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -154,6 +154,21 @@ typedef struct _drm_i915_sarea {
 
 } drm_i915_sarea_t;
 
+struct i915_ext_ioctl_data {
+	u32 sub_cmd;	/* Extended ioctl to call */
+	u8  table;	/* Reserved, must be zero */
+	u8  pad1;	/* Alignment pad */
+	u16 pad2;	/* Alignment pad */
+
+	/*
+	 * User-space pointer could be 32-bits or 64-bits
+	 * so use u64 to guarantee compatibility with 64-bit kernels
+	 * This obviates the need to provide both a compat_ioctl and standard
+	 * ioctl for this interface
+	 */
+	u64 args_ptr;
+};
+
 /* due to userspace building against these headers we need some compat here */
 #define planeA_x pipeA_x
 #define planeA_y pipeA_y
@@ -234,6 +249,9 @@ typedef struct _drm_i915_sarea {
 
 #define DRM_I915_PERFMON		0x3e
 
+/* Special, two-level, extended ioctl */
+#define DRM_I915_EXT_IOCTL		0x5F
+
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
 #define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
@@ -288,6 +306,10 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)
 #define DRM_IOCTL_I915_PERFMON 			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_PERFMON, struct drm_i915_perfmon)
 
+#define DRM_IOCTL_I915_EXT_IOCTL	\
+		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_EXT_IOCTL, \
+		struct i915_ext_ioctl_data)
+
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
  */
-- 
1.7.5.4

