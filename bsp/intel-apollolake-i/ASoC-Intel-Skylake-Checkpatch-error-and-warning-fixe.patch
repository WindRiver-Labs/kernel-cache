From 3b1dfa9b27340e6dc3cadae9a4aa4020a7e64372 Mon Sep 17 00:00:00 2001
From: "Kranthikumar, GudishaX" <gudishax.kranthikumar@intel.com>
Date: Wed, 20 Jul 2016 01:32:24 +0530
Subject: [PATCH 2147/2508] ASoC: Intel: Skylake: Checkpatch error and warning
 fixes

commit eb7d8c3d09f950359eb9fc9d83aa49c83f1f194c from
https://github.com/01org/linux-apollolake-i

Change-Id: I6dd6c436ec799374ddab59d494e8ac14cda7f37e
Signed-off-by: Kranthikumar, GudishaX <gudishax.kranthikumar@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/10456
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Jayanti, Satya Charitardha <satya.charitardha.jayanti@intel.com>
[Kevin: Just some minor context mods in order to port to wrlinux]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 sound/soc/intel/skylake/bxt-sst.c      |   10 ++++----
 sound/soc/intel/skylake/cnl-sst.c      |    3 +-
 sound/soc/intel/skylake/skl-messages.c |    8 +++++-
 sound/soc/intel/skylake/skl-pcm.c      |    8 +++---
 sound/soc/intel/skylake/skl-probe.c    |    3 +-
 sound/soc/intel/skylake/skl-sst-dsp.h  |   10 ++++----
 sound/soc/intel/skylake/skl-sst-ipc.c  |   16 +++++++-------
 sound/soc/intel/skylake/skl-sst-ipc.h  |    2 +-
 sound/soc/intel/skylake/skl-topology.c |   35 ++++++++++++++++---------------
 sound/soc/intel/skylake/skl.c          |   10 ++++----
 10 files changed, 55 insertions(+), 50 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index e2502b2..307366a 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -59,7 +59,7 @@
 #define BXT_ADSP_SRAM1_BASE	0xA0000
 #define BXT_ADSP_W0_STAT_SZ	0x1000
 #define BXT_ADSP_W0_UP_SZ	0x1000
-#define BXT_ADSP_W1_SZ  	0x1000
+#define BXT_ADSP_W1_SZ		0x1000
 
 /* Delay before scheduling D0i3 entry */
 #define BXT_D0I3_DELAY 5000
@@ -658,13 +658,13 @@ static int bxt_load_library(struct sst_dsp *ctx)
 			data = (u8 *)fw->data + hdr->ext_manifest_len;
 		}
 
-		dev_dbg(ctx->dev, "Starting to preapre host dma for library name \
-			: %s of size:%zx\n", minfo->lib[i].name, (size_t)size);
+		dev_dbg(ctx->dev, "Starting to preapre host dma for library name : %s of size:%zx\n",
+						minfo->lib[i].name, (size_t)size);
 		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, size,
 						&dmab);
 		if (stream_tag <= 0) {
-			dev_err(ctx->dev, "Failed to prepare DMA engine for \
-				FW loading, err: %x\n", stream_tag);
+			dev_err(ctx->dev, "Failed to prepare DMA engine for FW loading, err: %x\n",
+						stream_tag);
 			ret = stream_tag;
 			goto load_library_failed;
 		}
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 699d79b..fd3e3f3 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -280,8 +280,7 @@ static int cnl_load_base_firmware(struct sst_dsp *ctx)
 	size = ctx->fw->size;
 	data = ctx->fw->data;
 	hdr = (struct skl_ext_manifest_header *)ctx->fw->data;
-	if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID)
-	{
+	if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID) {
 		dev_dbg(ctx->dev, "Found Extended manifest in FW Binary\n");
 		if (hdr->ext_manifest_len >= ctx->fw->size) {
 			ret = -EINVAL;
diff --git a/sound/soc/intel/skylake/skl-messages.c b/sound/soc/intel/skylake/skl-messages.c
index e24708a..0b068d0 100644
--- a/sound/soc/intel/skylake/skl-messages.c
+++ b/sound/soc/intel/skylake/skl-messages.c
@@ -155,6 +155,7 @@ static int skl_dsp_trigger(struct device *dev, bool start, int stream_tag)
 	struct hdac_ext_bus *ebus = dev_get_drvdata(dev);
 	struct hdac_stream *stream;
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
+
 	if (!bus)
 		return -ENODEV;
 
@@ -175,6 +176,7 @@ static int skl_dsp_cleanup(struct device *dev, struct snd_dma_buffer *dmab,
 	struct hdac_stream *stream;
 	struct hdac_ext_stream *estream;
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
+
 	if (!bus)
 		return -ENODEV;
 
@@ -195,7 +197,8 @@ static int skl_dsp_cleanup(struct device *dev, struct snd_dma_buffer *dmab,
 static struct skl_dsp_loader_ops skl_get_loader_ops(void)
 {
 	struct skl_dsp_loader_ops loader_ops;
-	memset(&loader_ops,0,sizeof(struct skl_dsp_loader_ops));
+
+	memset(&loader_ops, 0, sizeof(struct skl_dsp_loader_ops));
 
 	loader_ops.alloc_dma_buf = skl_alloc_dma_buf;
 	loader_ops.free_dma_buf = skl_free_dma_buf;
@@ -206,7 +209,8 @@ static struct skl_dsp_loader_ops skl_get_loader_ops(void)
 static struct skl_dsp_loader_ops bxt_get_loader_ops(void)
 {
 	struct skl_dsp_loader_ops loader_ops;
-	memset(&loader_ops,0,sizeof(struct skl_dsp_loader_ops));
+
+	memset(&loader_ops, 0, sizeof(struct skl_dsp_loader_ops));
 
 	loader_ops.alloc_dma_buf = skl_alloc_dma_buf;
 	loader_ops.free_dma_buf = skl_free_dma_buf;
diff --git a/sound/soc/intel/skylake/skl-pcm.c b/sound/soc/intel/skylake/skl-pcm.c
index b5c8f4c..03d6a61 100644
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -487,7 +487,6 @@ static int skl_pcm_trigger(struct snd_pcm_substream *substream, int cmd,
 		if (ret < 0)
 			return ret;
 		return skl_run_pipe(ctx, mconfig->pipe);
-		break;
 
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
@@ -699,7 +698,7 @@ static int skl_trace_compr_open(struct snd_compr_stream *substream,
 
 	ret = pm_runtime_get_sync(skl_sst->dev);
 	if (ret < 0) {
-		dev_err(skl_sst->dev,"trace open:pm_runtime_get failed\n");
+		dev_err(skl_sst->dev, "trace open:pm_runtime_get failed\n");
 		return ret;
 	}
 
@@ -1181,7 +1180,7 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 			SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |
 			SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |
 			SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |
-			SNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_64000 ,
+			SNDRV_PCM_RATE_192000 | SNDRV_PCM_RATE_64000,
 		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
 			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
 	},
@@ -1627,6 +1626,7 @@ static int skl_platform_soc_probe(struct snd_soc_platform *platform)
 	int ret = 0;
 	struct skl *skl = ebus_to_skl(ebus);
 	struct platform_info *dbg_info;
+
 	if (ebus->ppcap) {
 		ret = skl_tplg_init(platform, ebus);
 		if (ret < 0) {
@@ -1677,7 +1677,7 @@ static int skl_platform_soc_remove(struct snd_soc_platform *platform)
 
 	if (skl->tplg) {
 		release_firmware(skl->tplg);
-		skl->tplg= NULL;
+		skl->tplg = NULL;
 	}
 	return 0;
 }
diff --git a/sound/soc/intel/skylake/skl-probe.c b/sound/soc/intel/skylake/skl-probe.c
index f216c5a..a19265a 100644
--- a/sound/soc/intel/skylake/skl-probe.c
+++ b/sound/soc/intel/skylake/skl-probe.c
@@ -49,7 +49,8 @@ static int set_injector_stream(struct hdac_ext_stream *stream,
 	struct skl_probe_config *pconfig =  &skl->skl_sst->probe_config;
 	int i;
 
-	if ((i = skl_get_probe_index(dai, pconfig)) != -1) {
+	i = skl_get_probe_index(dai, pconfig);
+	if (i != -1) {
 		pconfig->iprobe[i].stream = stream;
 		pconfig->iprobe[i].dma_id =
 				hdac_stream(stream)->stream_tag - 1;
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.h b/sound/soc/intel/skylake/skl-sst-dsp.h
index 16607a7..5e06335 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.h
+++ b/sound/soc/intel/skylake/skl-sst-dsp.h
@@ -206,11 +206,11 @@ struct skl_module_table {
 };
 
 struct skl_ext_manifest_header {
-    u32  ext_manifest_id;
-    u32  ext_manifest_len;
-    u16  ext_manifest_version_major;
-    u16  ext_manifest_version_minor;
-    u32  ext_manifest_entries;
+	u32  ext_manifest_id;
+	u32  ext_manifest_len;
+	u16  ext_manifest_version_major;
+	u16  ext_manifest_version_minor;
+	u32  ext_manifest_entries;
 } __packed;
 
 void skl_cldma_process_intr(struct sst_dsp *ctx);
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index 6f76c83..d82b7c4 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -444,9 +444,9 @@ skl_process_log_buffer(struct sst_dsp *sst, struct skl_ipc_header header)
 		return;
 	}
 	if (skl_dsp_get_buff_users(sst, core) > 2) {
-		dev_err(sst->dev, "Can't handle log buffer notification, \
-			previous writer is not finished yet !\n \
-			dropping log buffer\n");
+		dev_err(sst->dev, "Can't handle log buffer notification,");
+		dev_err(sst->dev, "previous writer is not finished yet!\n");
+		dev_err(sst->dev, "dropping log buffer\n");
 		return;
 	}
 	skl_dsp_get_log_buff(sst, core);
@@ -1023,7 +1023,7 @@ int skl_ipc_bind_unbind(struct sst_generic_ipc *ipc,
 EXPORT_SYMBOL_GPL(skl_ipc_bind_unbind);
 
 int skl_ipc_load_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
-							void* data)
+							void *data)
 {
 	struct skl_ipc_header header = {0};
 	u64 *ipc_header = (u64 *)(&header);
@@ -1142,10 +1142,10 @@ int skl_ipc_get_large_config(struct sst_generic_ipc *ipc,
 	header.primary |= IPC_MOD_INSTANCE_ID(msg->instance_id);
 	header.primary |= IPC_MOD_ID(msg->module_id);
 
-	if(!size)
-                header.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);
-        else
-                header.extension = IPC_DATA_OFFSET_SZ(size);
+	if (!size)
+		header.extension = IPC_DATA_OFFSET_SZ(msg->param_data_size);
+	else
+		header.extension = IPC_DATA_OFFSET_SZ(size);
 
 	header.extension |= IPC_LARGE_PARAM_ID(msg->large_param_id);
 	header.extension |= IPC_FINAL_BLOCK(1);
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index e0b0554..c9ca5d8 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -222,7 +222,7 @@ int skl_ipc_bind_unbind(struct sst_generic_ipc *sst_ipc,
 		struct skl_ipc_bind_unbind_msg *msg);
 
 int skl_ipc_load_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
-							void* data);
+							void *data);
 
 int skl_ipc_unload_modules(struct sst_generic_ipc *ipc, u8 module_cnt,
 							void *data);
diff --git a/sound/soc/intel/skylake/skl-topology.c b/sound/soc/intel/skylake/skl-topology.c
index c0ca762..83482d0 100644
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@ -403,11 +403,11 @@ static void skl_tplg_update_params(struct skl_module_fmt *fmt,
 	if (fixup & SKL_CH_FIXUP_MASK) {
 		fmt->channels = params->ch;
 		skl_tplg_update_chmap(fmt, fmt->channels);
-		if (fmt->channels == 1) {
+		if (fmt->channels == 1)
 			fmt->ch_cfg = SKL_CH_CFG_MONO;
-		} else if (fmt->channels == 2) {
+		else if (fmt->channels == 2)
 			fmt->ch_cfg = SKL_CH_CFG_STEREO;
-		}
+
 	}
 	if (fixup & SKL_FMT_FIXUP_MASK) {
 		fmt->valid_bit_depth = skl_get_bit_depth(params->s_fmt);
@@ -651,7 +651,8 @@ int skl_tplg_attach_probe_dma(struct snd_soc_dapm_widget *w,
 	struct skl_attach_probe_dma ad;
 	struct skl_probe_config *pconfig = &ctx->probe_config;
 
-	if ((i = skl_get_probe_index(dai, pconfig)) != -1) {
+	i = skl_get_probe_index(dai, pconfig);
+	if (i != -1) {
 		ad.node_id.node.vindex = pconfig->iprobe[i].dma_id;
 		ad.node_id.node.dma_type = SKL_DMA_HDA_HOST_OUTPUT_CLASS;
 		ad.node_id.node.rsvd = 0;
@@ -688,7 +689,7 @@ int skl_tplg_set_probe_params(struct snd_soc_dapm_widget *w,
 		if (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
 			sb = (void *) k->private_value;
 			bc = (struct skl_probe_data *)sb->dobj.private;
-			pr_debug("bc->is_ext_inj = %d, bc->params = %d, bc->is_connect = %d \n",
+			pr_debug("bc->is_ext_inj = %d, bc->params = %d, bc->is_connect = %d\n",
 						bc->is_ext_inj, bc->params, bc->is_connect);
 			if (!(bc->is_ext_inj == SKL_PROBE_INJECT ||
 					bc->is_ext_inj == SKL_PROBE_INJECT_REEXTRACT))
@@ -710,11 +711,11 @@ int skl_tplg_set_probe_params(struct snd_soc_dapm_widget *w,
 				sb = (void *) k->private_value;
 				bc = (struct skl_probe_data *)sb->dobj.private;
 
-				pr_debug("bc->is_ext_inj = %d, bc->params = %d, bc->is_connect = %d \n",
+				pr_debug("bc->is_ext_inj = %d, bc->params = %d, bc->is_connect = %d\n",
 							bc->is_ext_inj, bc->params, bc->is_connect);
 				if (bc->is_ext_inj == SKL_PROBE_EXTRACT &&
 						pconfig->eprobe[i].set == 1) {
-					pr_debug("Retrieving the exractor params \n");
+					pr_debug("Retrieving the exractor params\n");
 					prb_pt_param[n].params = (int)bc->params;
 					prb_pt_param[n].connection = bc->is_ext_inj;
 					prb_pt_param[n].node_id = -1;
@@ -1100,9 +1101,9 @@ static int skl_tplg_bind_sinks(struct snd_soc_dapm_widget *w,
  * A PGA represents a module in a pipeline. So in the Pre-PMU event of PGA
  * we need to do following:
  *   - Bind to sink pipeline
- *   	Since the sink pipes can be running and we don't get mixer event on
- *   	connect for already running mixer, we need to find the sink pipes
- *   	here and bind to them. This way dynamic connect works.
+ *	Since the sink pipes can be running and we don't get mixer event on
+ *	connect for already running mixer, we need to find the sink pipes
+ *	here and bind to them. This way dynamic connect works.
  *   - Start sink pipeline, if not running
  *   - Then run current pipe
  */
@@ -1140,7 +1141,7 @@ static struct snd_soc_dapm_widget *skl_get_src_dsp_widget(
 	struct snd_soc_dapm_widget *src_w = NULL;
 	struct skl_sst *ctx = skl->skl_sst;
 
-	snd_soc_dapm_widget_for_each_source_path(w,p) {
+	snd_soc_dapm_widget_for_each_source_path(w, p) {
 		src_w = p->source;
 		if (!p->connect)
 			continue;
@@ -1152,9 +1153,9 @@ static struct snd_soc_dapm_widget *skl_get_src_dsp_widget(
 		 * be any widgets type and we are only interested if they are
 		 * ones used for SKL so check that first
 		 */
-		if ((p->source->priv != NULL) && is_skl_dsp_widget_type(p->source)) {
+		if ((p->source->priv != NULL) && is_skl_dsp_widget_type(p->source))
 			return p->source;
-		}
+
 	}
 
 	if (src_w != NULL)
@@ -1591,7 +1592,7 @@ static int skl_tplg_tlv_control_get(struct snd_kcontrol *kcontrol,
 	dev_dbg(dapm->dev, "size = %u (%#x), max = %#x\n", size, size, bc->max);
 
 	if (w->power) {
-		if (bc->param_id == 0xFF){
+		if (bc->param_id == 0xFF) {
 			msg.module_id = mconfig->id.module_id;
 			msg.instance_id = mconfig->id.instance_id;
 			msg.param_data_size = bc->max;
@@ -1649,7 +1650,7 @@ static int skl_tplg_tlv_control_set(struct snd_kcontrol *kcontrol,
 	if (ac->params && (ac->access_type == SKL_WIDGET_WRITE ||
 				ac->access_type == SKL_WIDGET_READ_WRITE)) {
 		memset(ac->params, 0, ac->max);
-                /* skip copying first two u32 words from user which is the TLV header */
+		/* skip copying first two u32 words from user which is the TLV header */
 		if (copy_from_user(ac->params,
 				   ((unsigned char *)data) + 2*sizeof(u32),
 				   size - 2*sizeof(u32)))
@@ -1753,7 +1754,7 @@ static int skl_tplg_tlv_probe_set(struct snd_kcontrol *kcontrol,
 					offset, sizeof(ap->params)))
 			return -EIO;
 
-		dev_dbg(dapm->dev, "connect state = %d, extract_inject = %d, params = %d \n",
+		dev_dbg(dapm->dev, "connect state = %d, extract_inject = %d, params = %d\n",
 						ap->is_connect, ap->is_ext_inj, ap->params);
 
 		ret = skl_cache_probe_param(kcontrol, ap, skl->skl_sst);
@@ -2231,7 +2232,7 @@ static void skl_tplg_fill_fmt(struct skl_module_fmt *dst_fmt,
 static void skl_load_widget_params(struct skl_dfw_module *dfw_config,
 				struct skl_module_cfg *mconfig)
 {
-	switch(dfw_config->module_type) {
+	switch (dfw_config->module_type) {
 	case SKL_MODULE_TYPE_GAIN:
 		mconfig->gain_data.ramp_duration = 0;
 		mconfig->gain_data.ramp_type = SKL_CURVE_NONE;
diff --git a/sound/soc/intel/skylake/skl.c b/sound/soc/intel/skylake/skl.c
index 6d10221..8138f61 100644
--- a/sound/soc/intel/skylake/skl.c
+++ b/sound/soc/intel/skylake/skl.c
@@ -41,7 +41,7 @@
  * and use alternative methods like debugfs if available
  */
 #define SKL_USE_NHLT_FROM_BIOS 0
-static char *machine = NULL;
+static char *machine;
 
 module_param(machine, charp, 0444);
 MODULE_PARM_DESC(machine, "machine driver string for Intel soundcard.");
@@ -159,7 +159,7 @@ static void update_pci_dword(struct pci_dev *pci,
  * @dev: device pointer
  * @enable: enable/disable flag
  */
- void skl_enable_miscbdcge(struct device *dev, bool enable)
+void skl_enable_miscbdcge(struct device *dev, bool enable)
 {
 	struct pci_dev *pci = to_pci_dev(dev);
 	u32 val;
@@ -330,7 +330,7 @@ static int skl_suspend(struct device *dev)
 	struct hdac_ext_bus *ebus = pci_get_drvdata(pci);
 	struct skl *skl = ebus_to_skl(ebus);
 	struct skl_sst *ctx = skl->skl_sst;
-	int ret=0;
+	int ret = 0;
 	struct hdac_bus *bus = ebus_to_hbus(ebus);
 
 	/*
@@ -779,9 +779,9 @@ static int skl_first_init(struct hdac_ext_bus *ebus)
 	snd_hdac_set_codec_wakeup(bus, false);
 
 	/* codec detection */
-	if (!bus->codec_mask) {
+	if (!bus->codec_mask)
 		dev_info(bus->dev, "no hda codecs found!\n");
-	}
+
 
 	return 0;
 }
-- 
1.7.5.4

