From de666734c069c3888dfb15cdf1c2f2545dc1f1fa Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:02 -0700
Subject: [PATCH 1348/2508] drm/i915/error: track, capture & print ringbuffer
 submission activity

commit fc36a1888ff7648ffe63ea469ee744323c6aff26 from
https://github.com/01org/linux-apollolake-i

For: VIZ-2021
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_drv.h         |    2 ++
 drivers/gpu/drm/i915/i915_gem.c         |   14 +++++++++++---
 drivers/gpu/drm/i915/i915_gpu_error.c   |   13 +++++++++++++
 drivers/gpu/drm/i915/intel_ringbuffer.h |   14 ++++++++++++++
 4 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 9ae4e78..f488789 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -532,6 +532,8 @@ struct drm_i915_error_state {
 
 		u64 ctx_desc;
 
+		struct intel_ringbuffer req_ring;
+
 		struct drm_i915_error_object {
 			int page_count;
 			u64 gtt_offset;
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index b9bca02..7f5a1af 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -2705,10 +2705,18 @@ void __i915_add_request(struct drm_i915_gem_request *request,
 	 * to explicitly hold another reference here.
 	 */
 	request->batch_obj = obj;
-
-	request->emitted_jiffies = jiffies;
 	request->previous_seqno = engine->last_submitted_seqno;
-	engine->last_submitted_seqno = request->seqno;
+
+	if (engine->last_submitted_ringbuf == ringbuf)
+		ringbuf->resubmission_count += 1;
+	else
+		ringbuf->resubmission_count = 1;
+	engine->last_submitted_ringbuf = ringbuf;
+	ringbuf->total_submission_count += 1;
+	ringbuf->last_submitted_tail = request->tail;
+	ringbuf->last_submitted_seqno = engine->last_submitted_seqno =
+								request->seqno;
+	ringbuf->last_submitted_jiffies = request->emitted_jiffies = jiffies;
 	list_add_tail(&request->list, &engine->request_list);
 
 	trace_i915_gem_request_add(request);
diff --git a/drivers/gpu/drm/i915/i915_gpu_error.c b/drivers/gpu/drm/i915/i915_gpu_error.c
index bb8dea8..151451a 100644
--- a/drivers/gpu/drm/i915/i915_gpu_error.c
+++ b/drivers/gpu/drm/i915/i915_gpu_error.c
@@ -526,12 +526,24 @@ int i915_error_state_to_str(struct drm_i915_error_state_buf *m,
 		}
 
 		if ((obj = error->ring[i].req_ringbuffer)) {
+			struct intel_ringbuffer *irb = &error->ring[i].req_ring;
+
 			err_printf(m, "%s --- ringbuffer = 0x%08x; %d pages (ctx_desc 0x%08x_%08x)\n",
 				   dev_priv->engine[i].name,
 				   lower_32_bits(obj->gtt_offset),
 				   obj->page_count,
 				   upper_32_bits(error->ring[i].ctx_desc),
 				   lower_32_bits(error->ring[i].ctx_desc));
+			err_printf(m, "\t\tringbuffer head 0x%08x tail 0x%08x space 0x%08x lrh 0x%08x\n",
+				   irb->head, irb->tail, irb->space,
+				   irb->last_retired_head);
+			err_printf(m, "\t\t%llu submission(s), %d consecutive, last at %ld: tail 0x%08x seqno %08x (%d)\n",
+				   irb->total_submission_count,
+				   irb->resubmission_count,
+				   irb->last_submitted_jiffies,
+				   irb->last_submitted_tail,
+				   irb->last_submitted_seqno,
+				   irb->last_submitted_seqno);
 			print_error_obj(m, obj);
 		}
 
@@ -1194,6 +1206,7 @@ static void i915_gem_record_rings(struct drm_device *dev,
 		error->ring[i].ctx_desc = ctx_desc;
 		error->ring[i].req_ringbuffer =
 			i915_error_ggtt_object_create(dev_priv, rbuf->obj);
+		error->ring[i].req_ring = *rbuf;
 
 		error->ring[i].hws_page =
 			i915_error_ggtt_object_create(dev_priv,
diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.h b/drivers/gpu/drm/i915/intel_ringbuffer.h
index 95d65b5..3de4d2b 100644
--- a/drivers/gpu/drm/i915/intel_ringbuffer.h
+++ b/drivers/gpu/drm/i915/intel_ringbuffer.h
@@ -126,6 +126,19 @@ struct intel_ringbuffer {
 	 * we can detect new retirements.
 	 */
 	u32 last_retired_head;
+
+	/*
+	 * Consecutive resubmissions are opportunities for the h/w to do
+	 * a 'lite restore' rather than a full context switch. Let's note
+	 * when that happens, in case it's useful for hang diagnosis.
+	 */
+	u32 resubmission_count;
+	u64 total_submission_count;
+
+	/* Info about last time this ringbuffer was submitted (to GuC) */
+	unsigned long last_submitted_jiffies;
+	u32 last_submitted_seqno;
+	u32 last_submitted_tail;
 };
 
 struct	intel_context;
@@ -311,6 +324,7 @@ struct  intel_engine_cs {
 	 * inspecting request list.
 	 */
 	u32 last_submitted_seqno;
+	struct intel_ringbuffer *last_submitted_ringbuf;
 
 	/*
 	 * Deferred free list to allow unreferencing requests from interrupt
-- 
1.7.5.4

