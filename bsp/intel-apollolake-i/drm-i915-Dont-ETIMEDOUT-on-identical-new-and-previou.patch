From 8f312b603fa3ba5f233a50b138f55d57c8413f22 Mon Sep 17 00:00:00 2001
From: Rodrigo Vivi <rodrigo.vivi@intel.com>
Date: Thu, 23 Jul 2015 16:35:50 -0700
Subject: [PATCH 1183/4706] drm/i915: Dont -ETIMEDOUT on identical new and
 previous (count, crc).

commit aabc95dcf200908993573b2019ff5210121bcba9 upstream

By Vesa DP 1.2 spec TEST_CRC_COUNT is a "4 bit wrap counter which
increments each time the TEST_CRC_x_x are updated."

However if we are trying to verify the screen hasn't changed we get
same (count, crc) pair twice. Without this patch we would return
-ETIMEOUT in this case.

So, if in 6 vblanks the pair (count, crc) hasn't changed we
return it anyway instead of returning error and let test case decide
if it was right or not.

Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
Reviewed-by: Rafael Antognolli <rafael.antognolli@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
---
 drivers/gpu/drm/i915/intel_dp.c |   21 +++++++++++++++------
 1 files changed, 15 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 16d8fab..e2d565c 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -4078,6 +4078,7 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 	u8 buf;
 	int count, ret;
 	int attempts = 6;
+	bool old_equal_new;
 
 	ret = intel_dp_sink_crc_start(intel_dp);
 	if (ret)
@@ -4092,6 +4093,7 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 			goto stop;
 		}
 		count = buf & DP_TEST_COUNT_MASK;
+
 		/*
 		 * Count might be reset during the loop. In this case
 		 * last known count needs to be reset as well.
@@ -4103,17 +4105,24 @@ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
 			ret = -EIO;
 			goto stop;
 		}
-	} while (--attempts && (count == 0 || (count == intel_dp->sink_crc.last_count &&
-					       !memcmp(intel_dp->sink_crc.last_crc, crc,
-						       6 * sizeof(u8)))));
+
+		old_equal_new = (count == intel_dp->sink_crc.last_count &&
+				 !memcmp(intel_dp->sink_crc.last_crc, crc,
+					 6 * sizeof(u8)));
+
+	} while (--attempts && (count == 0 || old_equal_new));
 
 	intel_dp->sink_crc.last_count = buf & DP_TEST_COUNT_MASK;
 	memcpy(intel_dp->sink_crc.last_crc, crc, 6 * sizeof(u8));
 
 	if (attempts == 0) {
-		DRM_DEBUG_KMS("Panel is unable to calculate CRC after 6 vblanks\n");
-		ret = -ETIMEDOUT;
-		goto stop;
+		if (old_equal_new) {
+			DRM_DEBUG_KMS("Unreliable Sink CRC counter: Current returned CRC is identical to the previous one\n");
+		} else {
+			DRM_ERROR("Panel is unable to calculate any CRC after 6 vblanks\n");
+			ret = -ETIMEDOUT;
+			goto stop;
+		}
 	}
 
 stop:
-- 
1.7.5.4

