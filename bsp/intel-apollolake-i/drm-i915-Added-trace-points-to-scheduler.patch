From 23920a4e1db607d18e0575f95a2fb694627f96d1 Mon Sep 17 00:00:00 2001
From: John Harrison <John.C.Harrison@Intel.com>
Date: Fri, 8 Apr 2016 13:44:28 -0700
Subject: [PATCH 1325/2508] drm/i915: Added trace points to scheduler

commit 776d33058f2944c47085b1530c396d8dced6df88 from
https://github.com/01org/linux-apollolake-i

Added trace points to the scheduler to track all the various events,
node state transitions and other interesting things that occur.

v2: Updated for new request completion tracking implementation.

v3: Updated for changes to node kill code.

v4: Wrapped some long lines to keep the style checker happy.

For: VIZ-1587
Signed-off-by: John Harrison <John.C.Harrison@Intel.com>
Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_gem_execbuffer.c |    2 +
 drivers/gpu/drm/i915/i915_scheduler.c      |   26 ++++
 drivers/gpu/drm/i915/i915_trace.h          |  196 ++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/intel_lrc.c           |    2 +
 4 files changed, 226 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index ebeee8e..f8b93b5 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -1263,6 +1263,8 @@ i915_gem_ringbuffer_submission(struct i915_execbuffer_params *params,
 
 	i915_gem_execbuffer_move_to_active(vmas, params->request);
 
+	trace_i915_gem_ring_queue(engine, params);
+
 	qe = container_of(params, typeof(*qe), params);
 	ret = i915_scheduler_queue_execbuffer(qe);
 	if (ret)
diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index bbf84fb..502b554 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -95,6 +95,8 @@ static void i915_scheduler_node_requeue(struct i915_scheduler_queue_entry *node)
 	/* Seqno will be reassigned on relaunch */
 	node->params.request->seqno = 0;
 	node->status = I915_SQS_QUEUED;
+	trace_i915_scheduler_unfly(node->params.engine, node);
+	trace_i915_scheduler_node_state_change(node->params.engine, node);
 }
 
 /*
@@ -105,7 +107,11 @@ static void i915_scheduler_node_kill(struct i915_scheduler_queue_entry *node)
 {
 	WARN_ON(I915_SQS_IS_COMPLETE(node));
 
+	if (I915_SQS_IS_FLYING(node))
+		trace_i915_scheduler_unfly(node->params.engine, node);
+
 	node->status = I915_SQS_DEAD;
+	trace_i915_scheduler_node_state_change(node->params.engine, node);
 }
 
 /* Mark a node as in flight on the hardware. */
@@ -128,6 +134,9 @@ static void i915_scheduler_node_fly(struct i915_scheduler_queue_entry *node)
 
 	node->status = I915_SQS_FLYING;
 
+	trace_i915_scheduler_fly(engine, node);
+	trace_i915_scheduler_node_state_change(engine, node);
+
 	if (!(scheduler->flags[engine->id] & I915_SF_INTERRUPTS_ENABLED)) {
 		bool success = true;
 
@@ -286,6 +295,8 @@ static int i915_scheduler_pop_from_queue_locked(struct intel_engine_cs *engine,
 		INIT_LIST_HEAD(&best->link);
 		best->status = I915_SQS_POPPED;
 
+		trace_i915_scheduler_node_state_change(engine, best);
+
 		ret = 0;
 	} else {
 		/* Can only get here if:
@@ -303,6 +314,8 @@ static int i915_scheduler_pop_from_queue_locked(struct intel_engine_cs *engine,
 		}
 	}
 
+	trace_i915_scheduler_pop_from_queue(engine, best);
+
 	*pop_node = best;
 	return ret;
 }
@@ -511,6 +524,8 @@ static int i915_scheduler_queue_execbuffer_bypass(struct i915_scheduler_queue_en
 	struct i915_scheduler *scheduler = dev_priv->scheduler;
 	int ret;
 
+	trace_i915_scheduler_queue(qe->params.engine, qe);
+
 	intel_ring_reserved_space_cancel(qe->params.request->ringbuf);
 
 	scheduler->flags[qe->params.engine->id] |= I915_SF_SUBMITTING;
@@ -643,6 +658,9 @@ int i915_scheduler_queue_execbuffer(struct i915_scheduler_queue_entry *qe)
 	not_flying = i915_scheduler_count_flying(scheduler, engine) <
 						 scheduler->min_flying;
 
+	trace_i915_scheduler_queue(engine, node);
+	trace_i915_scheduler_node_state_change(engine, node);
+
 	spin_unlock_irq(&scheduler->lock);
 
 	if (not_flying)
@@ -672,6 +690,8 @@ bool i915_scheduler_notify_request(struct drm_i915_gem_request *req)
 	struct i915_scheduler_queue_entry *node = req->scheduler_qe;
 	unsigned long flags;
 
+	trace_i915_scheduler_landing(req);
+
 	if (!node)
 		return false;
 
@@ -685,6 +705,8 @@ bool i915_scheduler_notify_request(struct drm_i915_gem_request *req)
 	else
 		node->status = I915_SQS_COMPLETE;
 
+	trace_i915_scheduler_node_state_change(req->engine, node);
+
 	spin_unlock_irqrestore(&scheduler->lock, flags);
 
 	return true;
@@ -892,6 +914,8 @@ static bool i915_scheduler_remove(struct i915_scheduler *scheduler,
 	/* Launch more packets now? */
 	do_submit = (queued > 0) && (flying < scheduler->min_flying);
 
+	trace_i915_scheduler_remove(engine, min_seqno, do_submit);
+
 	spin_unlock_irq(&scheduler->lock);
 
 	return do_submit;
@@ -927,6 +951,8 @@ static void i915_scheduler_process_work(struct intel_engine_cs *engine)
 		node = list_first_entry(&remove, typeof(*node), link);
 		list_del(&node->link);
 
+		trace_i915_scheduler_destroy(engine, node);
+
 		/* Free up all the DRM references */
 		i915_scheduler_clean_node(node);
 
diff --git a/drivers/gpu/drm/i915/i915_trace.h b/drivers/gpu/drm/i915/i915_trace.h
index 59a6266..c4ce3fa 100644
--- a/drivers/gpu/drm/i915/i915_trace.h
+++ b/drivers/gpu/drm/i915/i915_trace.h
@@ -9,6 +9,7 @@
 #include "i915_drv.h"
 #include "intel_drv.h"
 #include "intel_ringbuffer.h"
+#include "i915_scheduler.h"
 
 #undef TRACE_SYSTEM
 #define TRACE_SYSTEM i915
@@ -815,6 +816,201 @@ TRACE_EVENT(switch_mm,
 		  __entry->dev, __entry->ring, __entry->to, __entry->vm)
 );
 
+TRACE_EVENT(i915_scheduler_queue,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = engine->id;
+			   __entry->uniq   = node ? node->params.request->uniq  : 0;
+			   __entry->seqno  = node ? node->params.request->seqno : 0;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno)
+);
+
+TRACE_EVENT(i915_scheduler_fly,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = engine->id;
+			   __entry->uniq   = node ? node->params.request->uniq  : 0;
+			   __entry->seqno  = node ? node->params.request->seqno : 0;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno)
+);
+
+TRACE_EVENT(i915_scheduler_unfly,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = engine->id;
+			   __entry->uniq   = node ? node->params.request->uniq  : 0;
+			   __entry->seqno  = node ? node->params.request->seqno : 0;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno)
+);
+
+TRACE_EVENT(i915_scheduler_landing,
+	    TP_PROTO(struct drm_i915_gem_request *req),
+	    TP_ARGS(req),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     __field(u32, status)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = req->engine->id;
+			   __entry->uniq   = req->uniq;
+			   __entry->seqno  = req->seqno;
+			   __entry->status = req->scheduler_qe ?
+						req->scheduler_qe->status : ~0U;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d, status=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno,
+		      __entry->status)
+);
+
+TRACE_EVENT(i915_scheduler_remove,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     u32 min_seqno, bool do_submit),
+	    TP_ARGS(engine, min_seqno, do_submit),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, min_seqno)
+			     __field(bool, do_submit)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine    = engine->id;
+			   __entry->min_seqno = min_seqno;
+			   __entry->do_submit = do_submit;
+			   ),
+
+	    TP_printk("engine=%d, min_seqno = %d, do_submit=%d",
+		      __entry->engine, __entry->min_seqno, __entry->do_submit)
+);
+
+TRACE_EVENT(i915_scheduler_destroy,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = engine->id;
+			   __entry->uniq   = node ? node->params.request->uniq  : 0;
+			   __entry->seqno  = node ? node->params.request->seqno : 0;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno)
+);
+
+TRACE_EVENT(i915_scheduler_pop_from_queue,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine = engine->id;
+			   __entry->uniq   = node ? node->params.request->uniq  : 0;
+			   __entry->seqno  = node ? node->params.request->seqno : 0;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno)
+);
+
+TRACE_EVENT(i915_scheduler_node_state_change,
+	    TP_PROTO(struct intel_engine_cs *engine,
+		     struct i915_scheduler_queue_entry *node),
+	    TP_ARGS(engine, node),
+
+	    TP_STRUCT__entry(
+			     __field(u32, engine)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     __field(u32, status)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->engine  = engine->id;
+			   __entry->uniq    = node ? node->params.request->uniq  : 0;
+			   __entry->seqno   = node->params.request->seqno;
+			   __entry->status  = node->status;
+			   ),
+
+	    TP_printk("engine=%d, uniq=%d, seqno=%d, status=%d",
+		      __entry->engine, __entry->uniq, __entry->seqno,
+		      __entry->status)
+);
+
+TRACE_EVENT(i915_gem_ring_queue,
+	    TP_PROTO(struct intel_engine_cs *ring,
+		     struct i915_execbuffer_params *params),
+	    TP_ARGS(ring, params),
+
+	    TP_STRUCT__entry(
+			     __field(u32, ring)
+			     __field(u32, uniq)
+			     __field(u32, seqno)
+			     ),
+
+	    TP_fast_assign(
+			   __entry->ring  = ring->id;
+			   __entry->uniq  = params->request->uniq;
+			   __entry->seqno = params->request->seqno;
+			   ),
+
+	    TP_printk("ring=%d, uniq=%d, seqno=%d", __entry->ring,
+		      __entry->uniq, __entry->seqno)
+);
+
 #endif /* _I915_TRACE_H_ */
 
 /* This part must be outside protection */
diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c
index cb040dd..9118aae 100644
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -990,6 +990,8 @@ int intel_execlists_submission(struct i915_execbuffer_params *params,
 
 	i915_gem_execbuffer_move_to_active(vmas, params->request);
 
+	trace_i915_gem_ring_queue(engine, params);
+
 	qe = container_of(params, typeof(*qe), params);
 	ret = i915_scheduler_queue_execbuffer(qe);
 	if (ret)
-- 
1.7.5.4

