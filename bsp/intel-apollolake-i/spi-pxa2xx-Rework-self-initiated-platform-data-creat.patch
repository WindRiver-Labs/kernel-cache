From f06419ada8a10f6f61291dd17bffb298279ec8d3 Mon Sep 17 00:00:00 2001
From: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date: Wed, 28 Oct 2015 15:13:43 +0200
Subject: [PATCH 0026/2508] spi: pxa2xx: Rework self-initiated platform data
 creation for non-ACPI

commit 0db642151ad80967e9e1c2abf3e19bd7902ecdc9 upstream

Extend the pxa2xx_spi_acpi_get_pdata() so that it can create platform data
also on platforms that do not support ACPI or if CONFIG_ACPI is not set.
Now it is expected that "pxa2xx-spi" platform device is either created with
explicit platform data or has an ACPI companion device.

However there is only little in pxa2xx_spi_acpi_get_pdata() that is really
dependent on ACPI companion and it can be reworked to cover also cases
where "pxa2xx-spi" device doesn't have ACPI companion and is created
without platform data.

Do this by renaming the pxa2xx_spi_acpi_get_pdata(), moving it outside of
CONFIG_ACPI test and changing a few runtime tests there to support non-ACPI
case. Only port/bus ID setting based on ACPI _UID is dependent on ACPI and
is moved to own function inside CONFIG_ACPI.

Purpose of this to support non-ACPI case for those PCI enumerated compound
devices that integrate both LPSS SPI host controller and integrated DMA
engine under the same PCI ID and which are registered in MFD layer instead
of in spi-pxa2xx-pci.c.

Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Signed-off-by: Mark Brown <broonie@kernel.org>
---
 drivers/spi/spi-pxa2xx.c |   38 ++++++++++++++++++++++++++------------
 1 files changed, 26 insertions(+), 12 deletions(-)

diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index db1bed3..d631785 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -1303,6 +1303,7 @@ static void cleanup(struct spi_device *spi)
 	kfree(chip);
 }
 
+#ifdef CONFIG_PCI
 #ifdef CONFIG_ACPI
 
 static const struct acpi_device_id pxa2xx_spi_acpi_match[] = {
@@ -1316,6 +1317,23 @@ static const struct acpi_device_id pxa2xx_spi_acpi_match[] = {
 };
 MODULE_DEVICE_TABLE(acpi, pxa2xx_spi_acpi_match);
 
+static int pxa2xx_spi_get_port_id(struct acpi_device *adev)
+{
+	unsigned int devid;
+	int port_id = -1;
+
+	if (adev && adev->pnp.unique_id &&
+	    !kstrtouint(adev->pnp.unique_id, 0, &devid))
+		port_id = devid;
+	return port_id;
+}
+#else /* !CONFIG_ACPI */
+static int pxa2xx_spi_get_port_id(struct acpi_device *adev)
+{
+	return -1;
+}
+#endif
+
 /*
  * PCI IDs of compound devices that integrate both host controller and private
  * integrated DMA engine. Please note these are not used in module
@@ -1350,7 +1368,7 @@ static bool pxa2xx_spi_idma_filter(struct dma_chan *chan, void *param)
 }
 
 static struct pxa2xx_spi_master *
-pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
+pxa2xx_spi_init_pdata(struct platform_device *pdev)
 {
 	struct pxa2xx_spi_master *pdata;
 	struct acpi_device *adev;
@@ -1358,19 +1376,18 @@ pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
 	struct resource *res;
 	const struct acpi_device_id *adev_id = NULL;
 	const struct pci_device_id *pcidev_id = NULL;
-	unsigned int devid;
 	int type;
 
 	adev = ACPI_COMPANION(&pdev->dev);
-	if (!adev)
-		return NULL;
 
 	if (dev_is_pci(pdev->dev.parent))
 		pcidev_id = pci_match_id(pxa2xx_spi_pci_compound_match,
 					 to_pci_dev(pdev->dev.parent));
-	else
+	else if (adev)
 		adev_id = acpi_match_device(pdev->dev.driver->acpi_match_table,
 					    &pdev->dev);
+	else
+		return NULL;
 
 	if (adev_id)
 		type = (int)adev_id->driver_data;
@@ -1404,10 +1421,7 @@ pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
 	ssp->irq = platform_get_irq(pdev, 0);
 	ssp->type = type;
 	ssp->pdev = pdev;
-
-	ssp->port_id = -1;
-	if (adev->pnp.unique_id && !kstrtouint(adev->pnp.unique_id, 0, &devid))
-		ssp->port_id = devid;
+	ssp->port_id = pxa2xx_spi_get_port_id(adev);
 
 	pdata->num_chipselect = 1;
 	pdata->enable_dma = true;
@@ -1415,9 +1429,9 @@ pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
 	return pdata;
 }
 
-#else
+#else /* !CONFIG_PCI */
 static inline struct pxa2xx_spi_master *
-pxa2xx_spi_acpi_get_pdata(struct platform_device *pdev)
+pxa2xx_spi_init_pdata(struct platform_device *pdev)
 {
 	return NULL;
 }
@@ -1436,7 +1450,7 @@ static int pxa2xx_spi_probe(struct platform_device *pdev)
 
 	platform_info = dev_get_platdata(dev);
 	if (!platform_info) {
-		platform_info = pxa2xx_spi_acpi_get_pdata(pdev);
+		platform_info = pxa2xx_spi_init_pdata(pdev);
 		if (!platform_info) {
 			dev_err(&pdev->dev, "missing platform data\n");
 			return -ENODEV;
-- 
1.7.5.4

