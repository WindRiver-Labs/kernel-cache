From 1e718210126bf300a55835e0ca7234351abe0d0e Mon Sep 17 00:00:00 2001
From: Jayasankar <jayasankarx.nara@intel.com>
Date: Tue, 15 Nov 2016 17:24:10 +0800
Subject: [PATCH 5/7] igb: Do not disconnect netdevice from system during
 runtime suspend

commit 123633c1ad01945075c41ba8bb73cc96a246bb67 from
git://git.yoctoproject.org/linux-yocto-4.1

During runtime suspend in __igb_shutdown() function do not
mark device as removed from system, in igb_down() function
do not indicate loss of carrier and do not stop upper layers
from calling transmit function.

Signed-off-by: Jayasankar <jayasankarx.nara@intel.com>
Signed-off-by: Lai, Poey Seng <poey.seng.lai@intel.com>
---
 drivers/net/ethernet/intel/igb/igb_main.c |   32 ++++++++++++++++++++++------
 1 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 6a15917..4ef4887 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -1771,19 +1771,29 @@ void igb_down(struct igb_adapter *adapter)
 	struct e1000_hw *hw = &adapter->hw;
 	u32 tctl, rctl;
 	int i;
-
+	struct pci_dev *pdev = adapter->pdev;
 	/* signal that we're down so the interrupt handler does not
 	 * reschedule our watchdog timer
 	 */
-	set_bit(__IGB_DOWN, &adapter->state);
+	/* While in suspend state the i210 FW is not doing Link Down
+	 * so no need to set state to __IGB_DOWN
+	*/
+	if (!(pdev->dev.power.runtime_status == RPM_SUSPENDING))
+		set_bit(__IGB_DOWN, &adapter->state);
 
 	/* disable receives in the hardware */
 	rctl = rd32(E1000_RCTL);
 	wr32(E1000_RCTL, rctl & ~E1000_RCTL_EN);
 	/* flush and sleep below */
 
-	netif_carrier_off(netdev);
-	netif_tx_stop_all_queues(netdev);
+	/* for supporting runtime pm based on activity monitoring
+	 * do not stop the queue so that apps can continue using
+	 * the net device as they are not aware of runtime suspend
+	 */
+	if (!(pdev->dev.power.runtime_status == RPM_SUSPENDING)) {
+		netif_carrier_off(netdev);
+		netif_tx_stop_all_queues(netdev);
+	}
 
 	/* disable transmits in the hardware */
 	tctl = rd32(E1000_TCTL);
@@ -1795,7 +1805,11 @@ void igb_down(struct igb_adapter *adapter)
 
 	igb_irq_disable(adapter);
 
-	adapter->flags &= ~IGB_FLAG_NEED_LINK_UPDATE;
+	/* While in suspend state the i210 FW is not doing Link Down
+	 * so no need to clear flag IGB_FLAG_NEED_LINK_UPDATE
+	 */
+	if (!(pdev->dev.power.runtime_status == RPM_SUSPENDING))
+		adapter->flags &= ~IGB_FLAG_NEED_LINK_UPDATE;
 
 	for (i = 0; i < adapter->num_q_vectors; i++) {
 		if (adapter->q_vector[i]) {
@@ -7357,8 +7371,12 @@ static int __igb_shutdown(struct pci_dev *pdev, bool *enable_wake,
 #ifdef CONFIG_PM
 	int retval = 0;
 #endif
-
-	netif_device_detach(netdev);
+	/* For supporting runtime pm based on activity monitoring
+	 * do not disconnect net device from stack while entering
+	 * runtime suspend
+	 */
+	if (!runtime)
+		netif_device_detach(netdev);
 
 	if (netif_running(netdev))
 		__igb_close(netdev, true);
-- 
1.7.5.4

