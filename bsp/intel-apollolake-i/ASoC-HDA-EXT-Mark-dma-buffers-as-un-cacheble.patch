From a377307b18298c917d8178ed91bf483fbd451636 Mon Sep 17 00:00:00 2001
From: Ramesh Babu <ramesh.babu@intel.com>
Date: Tue, 17 Nov 2015 02:33:39 +0530
Subject: [PATCH 1783/2508] ASoC: HDA: EXT: Mark dma buffers as un-cacheble

commit 9bd674a5f7f7cbfccce0c6f4e0a8a42bc98fb210 from
https://github.com/01org/linux-apollolake-i

Driver shouldn't not assume HDA DMA has snooping
enabled. Driver should always allocate non-cached
memory.

Change-Id: I5b21643d88d7692967c83f4696eb9e3eb7a90178
Signed-off-by: Ramesh Babu <ramesh.babu@intel.com>
Signed-off-by: Hardik T Shah <hardik.t.shah@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7412
---
 sound/hda/ext/hdac_ext_bus.c |   36 +++++++++++++++++++++++++++++++++++-
 1 files changed, 35 insertions(+), 1 deletions(-)

diff --git a/sound/hda/ext/hdac_ext_bus.c b/sound/hda/ext/hdac_ext_bus.c
index 4449d1a9..89a0c3e 100644
--- a/sound/hda/ext/hdac_ext_bus.c
+++ b/sound/hda/ext/hdac_ext_bus.c
@@ -19,6 +19,8 @@
 
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <asm/pgtable.h>
+#include <asm/cacheflush.h>
 #include <sound/hdaudio_ext.h>
 
 MODULE_DESCRIPTION("HDA extended core");
@@ -54,14 +56,46 @@ static u8 hdac_ext_readb(u8 __iomem *addr)
 	return readb(addr);
 }
 
+static void hdac_ext_mark_pages_uc(struct snd_dma_buffer *dmab, bool enable)
+{
+	int pages;
+
+	if (!dmab || !dmab->area || !dmab->bytes)
+		return;
+
+#ifdef CONFIG_SND_DMA_SGBUF
+	if (dmab->dev.type == SNDRV_DMA_TYPE_DEV_SG) {
+		struct snd_sg_buf *sgbuf = dmab->private_data;
+
+		if (enable)
+			set_pages_array_uc(sgbuf->page_table, sgbuf->pages);
+		else
+			set_pages_array_wb(sgbuf->page_table, sgbuf->pages);
+		return;
+	}
+#endif
+	pages = (dmab->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (enable)
+		set_memory_uc((unsigned long)dmab->area, pages);
+	else
+		set_memory_wb((unsigned long)dmab->area, pages);
+}
+
 static int hdac_ext_dma_alloc_pages(struct hdac_bus *bus, int type,
 			   size_t size, struct snd_dma_buffer *buf)
 {
-	return snd_dma_alloc_pages(type, bus->dev, size, buf);
+	int ret;
+
+	ret = snd_dma_alloc_pages(type, bus->dev, size, buf);
+	if (ret < 0)
+		return ret;
+	hdac_ext_mark_pages_uc(buf, true);
+	return ret;
 }
 
 static void hdac_ext_dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)
 {
+	hdac_ext_mark_pages_uc(buf, false);
 	snd_dma_free_pages(buf);
 }
 
-- 
1.7.5.4

