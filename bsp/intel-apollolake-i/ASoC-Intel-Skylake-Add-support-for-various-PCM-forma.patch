From 6f894292bcdde1494d3c4a94749bedae920027b4 Mon Sep 17 00:00:00 2001
From: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Date: Tue, 7 Jun 2016 13:43:39 +0530
Subject: [PATCH 1974/2508] ASoC: Intel: Skylake: Add support for various PCM
 formats

commit d2f5cab8ca58e9774dc8bd276b3af8efd4245d56 from
https://github.com/01org/linux-apollolake-i

Add support for S24_LE, S24_3LE, S32_LE and FLOAT PCM formats.
The sample type field of the gateway copiers have to be
set such that the format is conveyed to the DSP. Based on this,
the copier will do a type conversion

Change-Id: I7a6ff9d2b078db086ddf9a1907b7aaac0ad7e922
Signed-off-by: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9550
Reviewed-by: B, Jayachandran <jayachandran.b@intel.com>
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/skl-messages.c |    1 +
 sound/soc/intel/skylake/skl-pcm.c      |   33 +++++++++++++++++----
 sound/soc/intel/skylake/skl-topology.c |   48 +++++++++++++++++++++++--------
 sound/soc/intel/skylake/skl-topology.h |   12 ++++++-
 4 files changed, 72 insertions(+), 22 deletions(-)

diff --git a/sound/soc/intel/skylake/skl-messages.c b/sound/soc/intel/skylake/skl-messages.c
index b2c3dc0..c9ccd49 100644
--- a/sound/soc/intel/skylake/skl-messages.c
+++ b/sound/soc/intel/skylake/skl-messages.c
@@ -429,6 +429,7 @@ static void skl_set_base_module_format(struct skl_sst *ctx,
 	base_cfg->audio_fmt.bit_depth = format->bit_depth;
 	base_cfg->audio_fmt.valid_bit_depth = format->valid_bit_depth;
 	base_cfg->audio_fmt.ch_cfg = format->ch_cfg;
+	base_cfg->audio_fmt.sample_type = format->sample_type;
 
 	dev_dbg(ctx->dev, "bit_depth=%x valid_bd=%x ch_config=%x\n",
 			format->bit_depth, format->valid_bit_depth,
diff --git a/sound/soc/intel/skylake/skl-pcm.c b/sound/soc/intel/skylake/skl-pcm.c
index 831f749..127e378 100644
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -51,7 +51,11 @@ static struct snd_pcm_hardware azx_pcm_hw = {
 				 SNDRV_PCM_INFO_HAS_WALL_CLOCK | /* legacy */
 				 SNDRV_PCM_INFO_HAS_LINK_ATIME |
 				 SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
-	.formats =		SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.formats =		SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_FLOAT_LE |
+				SNDRV_PCM_FMTBIT_S24_3LE |
+				SNDRV_PCM_FMTBIT_S32_LE,
 	.rates =		SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
 	.rate_min =		8000,
 	.rate_max =		192000,
@@ -298,7 +302,10 @@ static int skl_pcm_hw_params(struct snd_pcm_substream *substream,
 	m_cfg = skl_tplg_fe_get_cpr_module(dai, p_params.stream);
 	if (m_cfg) {
 		skl_set_cpr_gtw_dma_fifo_size(dai, m_cfg);
-		skl_tplg_update_pipe_params(dai->dev, m_cfg, &p_params);
+		skl_tplg_update_pipe_params(dai->dev,
+					m_cfg,
+					&p_params,
+					params_format(params));
 	}
 
 	return 0;
@@ -823,7 +830,11 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 		.channels_min = HDA_MONO,
 		.channels_max = HDA_STEREO,
 		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+				SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_S24_3LE |
+				SNDRV_PCM_FMTBIT_FLOAT_LE |
+				SNDRV_PCM_FMTBIT_S32_LE,
 	},
 	.capture = {
 		.stream_name = "System Capture",
@@ -831,7 +842,9 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 		.channels_max = HDA_STEREO,
 		.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_32000 |
 			SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_8000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_S24_3LE |
+				SNDRV_PCM_FMTBIT_S32_LE,
 	},
 },
 {
@@ -920,7 +933,9 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 		.channels_max = HDA_STEREO,
 		.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |
 			SNDRV_PCM_RATE_8000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE |
+			SNDRV_PCM_FMTBIT_FLOAT_LE,
 	},
 },
 {
@@ -932,7 +947,9 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 		.channels_max = HDA_QUAD,
 		.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |
 			SNDRV_PCM_RATE_8000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE |
+			SNDRV_PCM_FMTBIT_FLOAT_LE,
 	},
 },
 {
@@ -944,7 +961,9 @@ static struct snd_soc_dai_driver skl_platform_dai[] = {
 		.channels_max = HDA_QUAD,
 		.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_16000 |
 			SNDRV_PCM_RATE_8000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE |
+			SNDRV_PCM_FMTBIT_FLOAT_LE,
 	},
 },
 {
diff --git a/sound/soc/intel/skylake/skl-topology.c b/sound/soc/intel/skylake/skl-topology.c
index d618dff..5ae1049 100644
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@ -1569,7 +1569,8 @@ static int skl_tplg_tlv_probe_set(struct snd_kcontrol *kcontrol,
  */
 int skl_tplg_update_pipe_params(struct device *dev,
 			struct skl_module_cfg *mconfig,
-			struct skl_pipe_params *params)
+			struct skl_pipe_params *params,
+			snd_pcm_format_t fmt)
 {
 	struct skl_pipe *pipe = mconfig->pipe;
 	struct skl_module_fmt *format = NULL;
@@ -1584,26 +1585,47 @@ int skl_tplg_update_pipe_params(struct device *dev,
 	/* set the hw_params */
 	format->s_freq = params->s_freq;
 	format->channels = params->ch;
-	format->valid_bit_depth = skl_get_bit_depth(params->s_fmt);
 
 	/*
-	 * 16 bit is 16 bit container whereas 24 bit is in 32 bit
-	 * container so update bit depth accordingly
-	 */
-	switch (format->valid_bit_depth) {
-	case SKL_DEPTH_16BIT:
-		format->bit_depth = format->valid_bit_depth;
+		* set copier sample type as follows
+		* 0 : if data is MSB aligned in the container
+		* 1 : if data is LSB aligned in the container
+		* 4 : if float
+	*/
+	switch (fmt) {
+	case SKL_FMT_S16LE:
+		format->valid_bit_depth = SKL_DEPTH_16BIT;
+		format->bit_depth = SKL_DEPTH_16BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_INT_MSB;
+		break;
+
+	case SKL_FMT_S24LE:
+		format->valid_bit_depth = SKL_DEPTH_24BIT;
+		format->bit_depth = SKL_DEPTH_32BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_INT_LSB;
 		break;
 
-	case SKL_DEPTH_24BIT:
-	case SKL_DEPTH_32BIT:
+	case SKL_FMT_S32LE:
+		format->valid_bit_depth = SKL_DEPTH_32BIT;
 		format->bit_depth = SKL_DEPTH_32BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_INT_MSB;
+		break;
+
+	case SKL_FMT_FLOATLE:
+		format->valid_bit_depth = SKL_DEPTH_32BIT;
+		format->bit_depth = SKL_DEPTH_32BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_FLOAT;
+		break;
+
+	case SKL_FMT_S24_3LE:
+		format->valid_bit_depth = SKL_DEPTH_24BIT;
+		format->bit_depth = SKL_DEPTH_24BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_INT_MSB;
 		break;
 
 	default:
-		dev_err(dev, "Invalid bit depth %x for pipe\n",
-				format->valid_bit_depth);
-		return -EINVAL;
+		format->bit_depth = SKL_DEPTH_32BIT;
+		format->sample_type = SKL_SAMPLE_TYPE_INT_MSB;
 	}
 
 	/* take care of fractional rates, round to next integer */
diff --git a/sound/soc/intel/skylake/skl-topology.h b/sound/soc/intel/skylake/skl-topology.h
index ef106b2..c050b1d 100644
--- a/sound/soc/intel/skylake/skl-topology.h
+++ b/sound/soc/intel/skylake/skl-topology.h
@@ -60,6 +60,13 @@ enum skl_bitdepth {
 	SKL_DEPTH_INVALID
 };
 
+enum skl_format {
+	SKL_FMT_S16LE = 2,
+	SKL_FMT_S24LE = 6,
+	SKL_FMT_S32LE = 10,
+	SKL_FMT_FLOATLE = 14,
+	SKL_FMT_S24_3LE = 32
+};
 
 enum skl_s_freq {
 	SKL_FS_8000 = 8000,
@@ -398,8 +405,9 @@ int skl_tplg_init(struct snd_soc_platform *platform,
 struct skl_module_cfg *skl_tplg_fe_get_cpr_module(
 		struct snd_soc_dai *dai, int stream);
 int skl_tplg_update_pipe_params(struct device *dev,
-		struct skl_module_cfg *mconfig, struct skl_pipe_params *params);
-
+			struct skl_module_cfg *mconfig,
+			struct skl_pipe_params *params,
+			snd_pcm_format_t fmt);
 void skl_tplg_update_d0i3_stream_count(struct snd_soc_dai *dai, bool open);
 
 int skl_create_pipeline(struct skl_sst *ctx, struct skl_pipe *pipe);
-- 
1.7.5.4

