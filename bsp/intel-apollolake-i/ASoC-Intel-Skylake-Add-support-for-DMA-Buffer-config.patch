From deb22fad98a3b4f35ca693cf5adce07954c2a5d0 Mon Sep 17 00:00:00 2001
From: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Date: Thu, 30 Jun 2016 14:05:56 +0530
Subject: [PATCH 2059/2508] ASoC: Intel: Skylake: Add support for DMA Buffer
 configuration

commit 8c4ab88613b11a8cc75dcf21e8440e191d76b4ce from
https://github.com/01org/linux-apollolake-i

DMA buffer configuration refers to managing the HW Buffers
at gateway copiers. This information originates from topology
and is sent as an IPC to the ADSP after firmware
download and subsequent D0/D3 cycles.
If the topology doesnt have such content, no IPC would be sent
and the memory organization lies with the FW.

Change-Id: I0ab922d0a40d4a78cead8d9dae8d8cbe64b69850
Signed-off-by: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/9957
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Jayanti, Satya Charitardha <satya.charitardha.jayanti@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c            |   14 +++++++++
 sound/soc/intel/skylake/skl-sst-ipc.c        |   41 ++++++++++++++++++++++++++
 sound/soc/intel/skylake/skl-sst-ipc.h        |    2 +
 sound/soc/intel/skylake/skl-topology.c       |   10 ++++++
 sound/soc/intel/skylake/skl-tplg-interface.h |   38 +++++++++++++++++++++++-
 5 files changed, 104 insertions(+), 1 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 4d14b87..fbfdc6b 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -495,6 +495,13 @@ int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 					core_id);
 			goto err;
 		}
+	} else {
+		/* set dma config if available for CORE0 boot only */
+		if (skl->manifest.cfg.dmacfg.size) {
+			skl_ipc_set_dma_cfg(&skl->ipc, BXT_INSTANCE_ID,
+					BXT_BASE_FW_MODULE_ID,
+					(u32 *)(&skl->manifest.cfg.dmacfg));
+		}
 	}
 
 	ctx->core_info.core_state[core_id] = SKL_DSP_RUNNING;
@@ -597,6 +604,13 @@ static int bxt_load_base_firmware(struct sst_dsp *ctx)
 		} else {
 			skl_dsp_init_core_state(ctx);
 			ret = 0;
+			/* set dma config if available */
+			if (skl->manifest.cfg.dmacfg.size) {
+				skl_ipc_set_dma_cfg(&skl->ipc,
+					BXT_INSTANCE_ID,
+					BXT_BASE_FW_MODULE_ID,
+					(u32 *)(&skl->manifest.cfg.dmacfg));
+			}
 		}
 	}
 sst_load_base_firmware_failed:
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index f62cff3..a8dc4ea 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -192,6 +192,8 @@
 #define IPC_D0IX_STREAMING(x)		(((x) & IPC_D0IX_STREAMING_MASK) \
 					<< IPC_D0IX_STREAMING_SHIFT)
 
+#define SET_LARGE_CFG_FW_CONFIG		7
+#define SKL_FW_CONFIG_DMA_CFG_SET       4
 
 enum skl_ipc_msg_target {
 	IPC_FW_GEN_MSG = 0,
@@ -1179,3 +1181,42 @@ int skl_ipc_set_d0ix(struct sst_generic_ipc *ipc, struct skl_ipc_d0ix_msg *msg)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(skl_ipc_set_d0ix);
+
+int skl_ipc_set_dma_cfg(struct sst_generic_ipc *ipc, u8 instance_id,
+			u16 module_id, u32 *data)
+{
+	struct skl_ipc_header header = {0};
+	u64 *ipc_header = (u64 *)(&header);
+	int ret;
+	u32 type_offset = 0, size_offset = 1, tx_size;
+
+	header.primary = IPC_MSG_TARGET(IPC_MOD_MSG);
+	header.primary |= IPC_MSG_DIR(IPC_MSG_REQUEST);
+	header.primary |= IPC_GLB_TYPE(IPC_MOD_LARGE_CONFIG_SET);
+	header.primary |= IPC_MOD_INSTANCE_ID(instance_id);
+	header.primary |= IPC_MOD_ID(module_id);
+
+	header.extension = IPC_DATA_OFFSET_SZ(data[size_offset]);
+	header.extension |= IPC_LARGE_PARAM_ID(SET_LARGE_CFG_FW_CONFIG);
+	header.extension |= IPC_FINAL_BLOCK(1);
+	header.extension |= IPC_INITIAL_BLOCK(1);
+
+	/* fill the type as per ADSP requirement */
+	data[type_offset] = SKL_FW_CONFIG_DMA_CFG_SET;
+
+	/* size of total message = size of payload + size of headers*/
+	tx_size = data[size_offset] + (2 * sizeof(u32));
+
+	dev_dbg(ipc->dev, "In %s primary =%x ext=%x\n", __func__,
+				header.primary, header.extension);
+
+	ret = skl_ipc_tx_message(ipc, *ipc_header,
+				(char *)data,
+				tx_size, NULL, 0, true,
+				SKL_IPC_DEFAULT_TIMEOUT);
+	if (ret < 0)
+		dev_err(ipc->dev, "ipc: set dma config failed, err %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(skl_ipc_set_dma_cfg);
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index 18e7d90..c870db6 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -237,6 +237,8 @@ int skl_sst_ipc_load_library(struct sst_generic_ipc *ipc, u8 dma_id,
 
 int skl_ipc_set_d0ix(struct sst_generic_ipc *ipc,
 		struct skl_ipc_d0ix_msg *msg);
+int skl_ipc_set_dma_cfg(struct sst_generic_ipc *ipc, u8 instance_id,
+		u16 module_id, u32 *data);
 int skl_dsp_enable_logging(struct sst_generic_ipc *ipc, int core, int enable);
 
 void skl_ipc_int_enable(struct sst_dsp *dsp);
diff --git a/sound/soc/intel/skylake/skl-topology.c b/sound/soc/intel/skylake/skl-topology.c
index f621876..ad4e963 100644
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@ -2336,6 +2336,16 @@ static int skl_manifest_load(struct snd_soc_component *cmpnt,
 
 	minfo = &skl->skl_sst->manifest;
 	mdata = manifest->priv.data;
+
+	memcpy(&minfo->cfg.mem_sts, mdata, (sizeof(minfo->cfg.mem_sts)));
+	mdata += sizeof(struct skl_mem_status);
+	memcpy(&minfo->cfg.slw_frq, mdata, (sizeof(minfo->cfg.slw_frq)));
+	mdata += sizeof(struct skl_dsp_freq);
+	memcpy(&minfo->cfg.fst_frq, mdata, (sizeof(minfo->cfg.fst_frq)));
+	mdata += sizeof(struct skl_dsp_freq);
+	memcpy(&minfo->cfg.dmacfg, mdata, (sizeof(minfo->cfg.dmacfg)));
+	mdata += sizeof(struct skl_dma_buff_cfg);
+
 	minfo->lib_count = *mdata;
 
 	if (minfo->lib_count > HDA_MAX_LIB) {
diff --git a/sound/soc/intel/skylake/skl-tplg-interface.h b/sound/soc/intel/skylake/skl-tplg-interface.h
index f55e8df..938084c 100644
--- a/sound/soc/intel/skylake/skl-tplg-interface.h
+++ b/sound/soc/intel/skylake/skl-tplg-interface.h
@@ -36,7 +36,7 @@
 
 #define LIB_NAME_LENGTH 512
 #define HDA_MAX_LIB    16
-
+#define MAX_DMA_CFG    24
 #define SKL_UUID_STR_SZ 40
 /* Event types goes here */
 /* Reserve event type 0 for no event handlers */
@@ -272,9 +272,45 @@ struct lib_info {
 	char name[LIB_NAME_LENGTH];
 } __packed;
 
+struct skl_dma_config {
+	u32 min_size;
+	u32 max_size;
+} __packed;
+
+struct skl_mem_status {
+	u32 type;
+	u32 size;
+	u32 mem_reclaim;
+} __packed;
+
+struct skl_dsp_freq {
+	u32 type;
+	u32 size;
+	u32 freq;
+} __packed;
+
+struct skl_dma_buff_cfg {
+	u32 type;
+	u32 size;
+	struct skl_dma_config dma_cfg[MAX_DMA_CFG];
+} __packed;
+
+struct fw_cfg_info {
+	struct skl_mem_status mem_sts;
+	struct skl_dsp_freq slw_frq;
+	struct skl_dsp_freq fst_frq;
+	struct skl_dma_buff_cfg dmacfg;
+} __packed;
+
 struct skl_dfw_manifest {
+
+	/* fw config info */
+	struct fw_cfg_info cfg;
+
+	/* library info */
 	u8 lib_count;
 	struct lib_info *lib;
+
 } __packed;
 
 #endif
-- 
1.7.5.4

