From 5e088abc9a76a0321d5829e386619759c2e06a73 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 24 Aug 2016 15:00:59 +0300
Subject: [PATCH 24/68] mei: dal: move kdi transport handlers to dal_kdi.c

commit bd457c819904847c862968de172db7d0a9955841 from
git://git.yoctoproject.org/linux-yocto-4.1

Move kdi specific transfer out of bh, and clean up
the API.

Change-Id: I2d7fbc04fd8856a9e31a43d6b474fb697cea0db7
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/bhp_exp.h  |   14 +----
 drivers/misc/mei/dal/bhp_impl.c |  127 +--------------------------------------
 drivers/misc/mei/dal/dal_kdi.c  |  116 +++++++++++++++++++++++++++++++++++-
 3 files changed, 121 insertions(+), 136 deletions(-)

diff --git a/drivers/misc/mei/dal/bhp_exp.h b/drivers/misc/mei/dal/bhp_exp.h
index 474a43f..de79e0b 100644
--- a/drivers/misc/mei/dal/bhp_exp.h
+++ b/drivers/misc/mei/dal/bhp_exp.h
@@ -65,18 +65,10 @@
 
 #include "bh_shared_errcode.h"
 
-typedef int (*bhp_transport_send)(unsigned int handle,
-				  unsigned char *buffer,
-				  unsigned int length,
-				  u64 seq);
-
-typedef int (*bhp_transport_recv)(unsigned int handle,
-				  unsigned char *buffer,
-				  unsigned int *length);
-
 struct bhp_transport {
-	bhp_transport_send send;
-	bhp_transport_recv recv;
+	int (*send)(unsigned int handle,
+		    unsigned char *buf, unsigned int len, u64 seq);
+	int (*recv)(unsigned int handle, unsigned char *buf, unsigned int *len);
 };
 
 /**
diff --git a/drivers/misc/mei/dal/bhp_impl.c b/drivers/misc/mei/dal/bhp_impl.c
index 8c85756..71379ee 100644
--- a/drivers/misc/mei/dal/bhp_impl.c
+++ b/drivers/misc/mei/dal/bhp_impl.c
@@ -64,28 +64,13 @@
 #include "bhp_exp.h"
 #include "dal_dev.h"
 
-static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
-			   const void *data, unsigned int dlen, u64 seq);
-static int bh_recv_message(int conn_idx, u64 *seq);
-
-static int kdi_send_wrapper(unsigned int handle,
-		unsigned char *buffer, unsigned int length, u64 seq);
-
-static int kdi_recv_wrapper(unsigned int handle,
-		unsigned char *buffer, unsigned int *length);
-
 static unsigned int init_state = DEINITED;
 static u64 sequence_number = MSG_SEQ_START_NUMBER;
 static struct bh_connection_item connections[MAX_CONNECTIONS];
 
-/* transport func list, set during init */
-static struct bhp_transport bhp_transport = {
-	kdi_send_wrapper,
-	kdi_recv_wrapper
-};
-
 /* the isd-id in the firmware, got during init */
 static struct bh_sd_id isd_uuid;
+static struct bhp_transport bhp_transport;
 
 /*
  * increment_seq_number():
@@ -110,113 +95,6 @@ static u64 increment_sequence_number(void)
 	return ret;
 }
 
-static int kdi_send_wrapper(unsigned int handle,
-		unsigned char *buffer, unsigned int length, u64 seq)
-{
-	enum dal_dev_type mei_device;
-	struct dal_device *ddev;
-	struct dal_client *dc;
-	struct device *dev;
-	ssize_t ret;
-
-	mei_device = (enum dal_dev_type) handle;
-
-	if (!buffer || mei_device < DAL_MEI_DEVICE_IVM ||
-			mei_device >= DAL_MEI_DEVICE_MAX)
-		return BPE_INVALID_PARAMS;
-
-	if (!length)
-		return BH_SUCCESS;
-
-	dev = dal_find_dev(mei_device);
-	if (!dev) {
-		dev_err(dev, "can't find device\n");
-		return BPE_INTERNAL_ERROR;
-	}
-
-	ddev = to_dal_device(dev);
-	dc = ddev->clients[DAL_INTF_KDI];
-	if (!dc) {
-		dev_err(dev, "client is NULL\n");
-		ret = BPE_INTERNAL_ERROR;
-		goto out;
-	}
-
-	/* copy data to client object */
-	memcpy(dc->write_buffer, buffer, length);
-
-	ret = dal_write(dc, length, seq);
-
-	if (ret <= 0)
-		ret = BPE_COMMS_ERROR;
-	else
-		ret = BH_SUCCESS;
-
-out:
-	put_device(dev);
-	return ret;
-}
-
-/* This is only for tmp read data to client */
-static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
-static int kdi_recv_wrapper(unsigned int handle,
-		unsigned char *buffer, unsigned int *length)
-{
-	enum dal_dev_type mei_device;
-	struct dal_device *ddev;
-	struct dal_client *dc;
-	struct device *dev;
-	ssize_t ret;
-
-	mei_device = (enum dal_dev_type) handle;
-
-	if (!buffer || !length || mei_device < DAL_MEI_DEVICE_IVM ||
-			mei_device >= DAL_MEI_DEVICE_MAX)
-		return BPE_INVALID_PARAMS;
-
-	dev = dal_find_dev(mei_device);
-	if (!dev)
-		return BPE_INTERNAL_ERROR;
-
-	ddev = to_dal_device(dev);
-	dc = ddev->clients[DAL_INTF_KDI];
-	if (!dc) {
-		dev_err(dev, "client is NULL\n");
-		ret = BPE_INTERNAL_ERROR;
-		goto out;
-	}
-
-	ret = dal_read(dc);
-
-	if (ret != 0)
-		goto out;
-
-	if (kfifo_is_empty(&dc->read_queue)) {
-		ret = 0;
-		goto out;
-	}
-
-	ret = kfifo_out(&dc->read_queue,
-			&bh_msg[ddev->device_id], sizeof(struct dal_bh_msg));
-	dev_dbg(&ddev->dev, "kfifo_out() ret = %zd\n", ret);
-
-	if (bh_msg[ddev->device_id].len > *length) {
-		dev_dbg(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %u\n",
-			bh_msg[ddev->device_id].len, *length);
-		ret = BPE_COMMS_ERROR;
-		goto out;
-	}
-
-	memcpy(buffer, bh_msg[ddev->device_id].msg,
-			bh_msg[ddev->device_id].len);
-
-	*length = bh_msg[ddev->device_id].len;
-	ret = BH_SUCCESS;
-
-out:
-	put_device(dev);
-	return ret;
-}
 
 struct RR_MAP_INFO {
 	struct list_head link;
@@ -780,7 +658,8 @@ int bhp_init_internal(const struct bhp_transport *transport)
 	if (bhp_is_initialized())
 		return BPE_INITIALIZED_ALREADY;
 
-	transport = &bhp_transport;
+	if (!transport)
+		return BPE_INVALID_PARAMS;
 
 	/* step 1: init connections to each process */
 	ret = bh_transport_init(transport);
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 2ea2dcc..70bcf71 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -137,6 +137,120 @@ static struct class_interface kdi_interface __refdata = {
 	.remove_dev     = kdi_rm_dev,
 };
 
+static int kdi_send(unsigned int handle,
+		    unsigned char *buf, unsigned int len, u64 seq)
+{
+	enum dal_dev_type mei_device;
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	struct device *dev;
+	ssize_t ret;
+
+	mei_device = (enum dal_dev_type)handle;
+
+	if (!buf)
+		return BPE_INVALID_PARAMS;
+
+	if (mei_device < DAL_MEI_DEVICE_IVM || mei_device >= DAL_MEI_DEVICE_MAX)
+		return BPE_INVALID_PARAMS;
+
+	if (!len)
+		return BH_SUCCESS;
+
+	dev = dal_find_dev(mei_device);
+	if (!dev) {
+		dev_err(dev, "can't find device\n");
+		return BPE_INTERNAL_ERROR;
+	}
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KDI];
+	if (!dc) {
+		dev_err(dev, "client is NULL\n");
+		ret = BPE_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* copy data to client object */
+	memcpy(dc->write_buffer, buf, len);
+	ret = dal_write(dc, len, seq);
+
+	if (ret <= 0)
+		ret = BPE_COMMS_ERROR;
+	else
+		ret = BH_SUCCESS;
+
+out:
+	put_device(dev);
+	return ret;
+}
+
+/* This is only for tmp read data to client */
+static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
+static int kdi_recv(unsigned int handle,
+		    unsigned char *buf, unsigned int *len)
+{
+	enum dal_dev_type mei_device;
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	struct device *dev;
+	ssize_t ret;
+
+	mei_device = (enum dal_dev_type)handle;
+
+	if (!buf || !len)
+		return BPE_INVALID_PARAMS;
+
+	if (mei_device < DAL_MEI_DEVICE_IVM || mei_device >= DAL_MEI_DEVICE_MAX)
+		return BPE_INVALID_PARAMS;
+
+	dev = dal_find_dev(mei_device);
+	if (!dev)
+		return BPE_INTERNAL_ERROR;
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KDI];
+	if (!dc) {
+		dev_err(dev, "client is NULL\n");
+		ret = BPE_INTERNAL_ERROR;
+		goto out;
+	}
+
+	ret = dal_read(dc);
+
+	if (ret != 0)
+		goto out;
+
+	if (kfifo_is_empty(&dc->read_queue)) {
+		ret = 0;
+		goto out;
+	}
+
+	ret = kfifo_out(&dc->read_queue,
+			&bh_msg[ddev->device_id], sizeof(struct dal_bh_msg));
+
+	if (bh_msg[ddev->device_id].len > *len) {
+		dev_dbg(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %u\n",
+			bh_msg[ddev->device_id].len, *len);
+		ret = BPE_COMMS_ERROR;
+		goto out;
+	}
+
+	memcpy(buf, bh_msg[ddev->device_id].msg, bh_msg[ddev->device_id].len);
+
+	*len = bh_msg[ddev->device_id].len;
+	ret = BH_SUCCESS;
+
+out:
+	put_device(dev);
+	return ret;
+}
+
+static struct bhp_transport kdi_transport = {
+	.send = kdi_send,
+	.recv = kdi_recv,
+};
+
 static int kdi_create_session(u64 *handle, const char *jta_id,
 			      const u8 *buffer, size_t buffer_length,
 			      const u8 *init_param, size_t init_param_length)
@@ -202,7 +316,7 @@ int kdi_init(u32 flags, u64 *handle)
 	if (ret)
 		return DAL_KDI_STATUS_INTERNAL_ERROR;
 
-	bh_err = bhp_init_internal(NULL);
+	bh_err = bhp_init_internal(&kdi_transport);
 	ret = bh_err_to_kdi_err(bh_err);
 	if (bh_err) {
 		class_interface_unregister(&kdi_interface);
-- 
1.7.5.4

