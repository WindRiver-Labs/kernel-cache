From 7af70ce9cc20e6a69bb0b2c5ec146f5c84ea8257 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Sat, 28 Nov 2015 11:05:39 +0100
Subject: [PATCH 0540/2508] drm/i915: fix fdi related fifo underruns on hsw
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 6b6985169017e554d80a8c2befdadbd81d13c2a2 upstream

Similar to

commit 37ca8d4ccd9860df0747aa2ea281a3c9c4bf8826
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Oct 30 19:20:27 2015 +0200

    drm/i915: Enable PCH FIFO underruns later on ILK/SNB/IVB

we can only enable fifo underrun reporting when using the fdi/lpt
after everything is set up and after a bit of waiting. The waiting
is required, enabling it right after enabling encoders will first trigger
an underrun on the pch and then, 1 frame later, an underrun on the
cpu. Two vblank waits after encoder enabling seems enough to curb it.

And similar to

Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 20 22:09:18 2015 +0200

    drm/i915: Suppress spurious CPU FIFO underruns on ILK-IVB

we also need to make sure cpu fifo underrun reporting is disabled when
enabling the fdi rx/tx and pch transcoder&port. But somehow this is
only needed when enabling, not also when disabling.

Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1448705139-12534-1-git-send-email-daniel.vetter@ffwll.ch
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91578
Tested-by: Mika Kahola <mika.kahola@intel.com>
Reviewed-by: Mika Kahola <mika.kahola@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
---
 drivers/gpu/drm/i915/intel_display.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index a8a9c6e..03e59f1 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -5000,7 +5000,11 @@ static void haswell_crtc_enable(struct drm_crtc *crtc)
 
 	intel_crtc->active = true;
 
-	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
+	if (intel_crtc->config->has_pch_encoder)
+		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);
+	else
+		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
+
 	for_each_encoder_on_crtc(dev, crtc, encoder) {
 		if (encoder->pre_enable)
 			encoder->pre_enable(encoder);
@@ -5044,9 +5048,13 @@ static void haswell_crtc_enable(struct drm_crtc *crtc)
 		intel_opregion_notify_encoder(encoder, true);
 	}
 
-	if (intel_crtc->config->has_pch_encoder)
+	if (intel_crtc->config->has_pch_encoder) {
+		intel_wait_for_vblank(dev, pipe);
+		intel_wait_for_vblank(dev, pipe);
+		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
 		intel_set_pch_fifo_underrun_reporting(dev_priv, TRANSCODER_A,
 						      true);
+	}
 
 	/* If we change the relative order between pipe/planes enabling, we need
 	 * to change the workaround. */
-- 
1.7.5.4

