From 03ff870e363ba74a9c8540d8b5f475e6f63c6cee Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Tue, 5 Jan 2016 17:39:34 +0530
Subject: [PATCH 1843/2508] ASoC: Intel: Skylake: Workaround for BXT DSP ROM
 bug

commit 196778134cddac07869350e2643d2bc3a7e7c034 from
https://github.com/01org/linux-apollolake-i

BXT Audio DSP ROM has a bug due to which when core 0 is
powered ON, it waits for core1 power status to be ON.
This patch implements a workaround that is to enable
core 1 also momentarily when core 0 is turned ON and then
turn core 1 OFF.

Change-Id: Id2e60d0da253154fa69a5f492db4ce0668d58b09
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7976
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c |   40 +++++++++++++++++++++++++++++++++++++
 1 files changed, 40 insertions(+), 0 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index dc70c86..669884b 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -198,6 +198,14 @@ load_library_failed:
 	return ret;
 }
 
+/* First boot sequence has some extra steps due to a ROM bug on BXT.
+ * Due to the bug core 0 waits for power status on core 1. The work
+ * around is to power up core 1 also momentarily, keep it in reset/stall
+ * and then turn it off
+ */
+
+#define BXT_ROM_BUG_WA
+
 static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 		u32 fwsize)
 {
@@ -217,10 +225,19 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 	ctx->dsp_ops.stream_tag = stream_tag;
 	memcpy(ctx->dmab.area, fwdata, fwsize);
 
+#ifdef BXT_ROM_BUG_WA
+	/* Step 1.a: Power up core 0 and core1 (Extra step due to ROM bug) */
+	ret = skl_dsp_core_power_up(ctx, SKL_DSP_CORE0_MASK | SKL_DSP_CORE_MASK(1));
+	if (ret < 0) {
+		dev_err(ctx->dev, "dsp core0/1 power up failed\n");
+		goto prepare_fw_load_failed;
+	}
+#else
 	/* Step 1: Power up core0 */
 	ret = skl_dsp_core_power_up(ctx, SKL_DSP_CORE0_MASK);
 	if (ret < 0)
 		goto prepare_fw_load_failed;
+#endif
 
 	/* Step 2: Purge FW request */
 	sst_dsp_shim_write(ctx, SKL_ADSP_REG_HIPCI, SKL_ADSP_REG_HIPCI_BUSY |
@@ -258,6 +275,14 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 	}
 	dev_dbg(ctx->dev, "******HIPCIE reg: 0x%x\n", reg);
 
+#ifdef BXT_ROM_BUG_WA
+	/* Step 5.a: power down core1 (Extra step due to ROM bug) */
+	ret = skl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));
+	if (ret < 0) {
+		dev_err(ctx->dev, "dsp core1 power down failed\n");
+		goto prepare_fw_load_failed;
+	}
+#endif
 	/* Step 6: enable Interrupt */
 	skl_ipc_int_enable(ctx);
 	skl_ipc_op_int_enable(ctx);
@@ -282,6 +307,9 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 
 prepare_fw_load_failed:
 	ctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);
+#ifdef BXT_ROM_BUG_WA
+	skl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));
+#endif
 	skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 	return ret;
 }
@@ -312,7 +340,15 @@ int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 
 	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
 
+#ifdef BXT_ROM_BUG_WA
+	/* If core 0 is being turned on, turn on core 1 as well */
+	if (core_id == SKL_DSP_CORE0_ID)
+		ret = skl_dsp_core_power_up(ctx, core_mask | SKL_DSP_CORE_MASK(1));
+	else
+		ret = skl_dsp_core_power_up(ctx, core_mask);
+#else
 	ret = skl_dsp_core_power_up(ctx, core_mask);
+#endif
 	if (ret < 0)
 		goto err;
 
@@ -333,6 +369,10 @@ int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 				skl->boot_complete,
 				msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
 
+#ifdef BXT_ROM_BUG_WA
+		/* If core 1 was turned on to workaround the ROM bug, turn it off */
+		skl_dsp_core_power_down(ctx, SKL_DSP_CORE_MASK(1));
+#endif
 		if (ret == 0) {
 			dev_err(ctx->dev, "%s: error DSP boot timeout\n", __func__);
 			dev_err(ctx->dev, "Error code=0x%x: FW status=0x%x\n",
-- 
1.7.5.4

