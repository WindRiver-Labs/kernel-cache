From f5c404214ef49174e4c0501e6fe91b7c8869245b Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Wed, 21 Dec 2016 10:04:00 +0200
Subject: [PATCH 4652/4706] mei: dal: remove kdi_handle, kdi_init & kdi_deinit

commit cd0c00c08807e5ffd22b7326dbdb01a174b8a4b4 from
git://git.yoctoproject.org/linux-yocto-4.1

Remove use of kdi_handle, kdi_init and kdi_deinit functions.
The handle wasn't used, and the functions did nothing,
we decided that there is no future need of them.

Change-Id: I9314e9cc5181ff77a555c4e9fcbc6fb6c8d67df8
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_kdi.c |   70 +++++----------------------------------
 include/linux/dal.h            |   43 ++++--------------------
 2 files changed, 17 insertions(+), 96 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 2126dbb..2a22523 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -275,48 +275,15 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 	return bh_err_to_kdi_err(bh_err);
 }
 
-static inline bool kdi_check_handle(u64 handle)
-{
-	return (handle == (u64)dal_class);
-}
-
-int kdi_init(u32 flags, u64 *handle)
-{
-	if (!handle)
-		return DAL_KDI_STATUS_INVALID_PARAMS;
-
-	*handle = (u64)dal_class;
-	return DAL_KDI_SUCCESS;
-}
-EXPORT_SYMBOL(kdi_init);
-
-int kdi_deinit(u64 handle)
-{
-	/* check handle first */
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
-	return 0;
-}
-EXPORT_SYMBOL(kdi_deinit);
-
-int dal_create_session(u64 handle,
-		       u64 *session_handle,
-		       const char *app_id,
-		       const u8 *acp_pkg,
-		       size_t acp_pkg_len,
-		       const u8 *init_param,
-		       size_t init_param_len)
+int dal_create_session(u64 *session_handle,  const char *app_id,
+		       const u8 *acp_pkg, size_t acp_pkg_len,
+		       const u8 *init_param, size_t init_param_len)
 {
 	int ret;
 
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
 	mutex_lock(&kdi_lock);
 
-	ret = kdi_create_session(session_handle, app_id,
-				 acp_pkg, acp_pkg_len,
+	ret = kdi_create_session(session_handle, app_id, acp_pkg, acp_pkg_len,
 				 init_param, init_param_len);
 	if (ret)
 		pr_err("kdi_create_session failed = %d\n", ret);
@@ -327,20 +294,12 @@ int dal_create_session(u64 handle,
 }
 EXPORT_SYMBOL(dal_create_session);
 
-int dal_send_and_receive(u64 handle,
-			 u64 session_handle,
-			 int command_id,
-			 const u8 *input,
-			 size_t input_len,
-			 u8 **output,
-			 size_t *output_len,
+int dal_send_and_receive(u64 session_handle, int command_id, const u8 *input,
+			 size_t input_len, u8 **output, size_t *output_len,
 			 int *response_code)
 {
 	int ret, bh_err;
 
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
 	mutex_lock(&kdi_lock);
 
 	bh_err = bhp_send_and_recv(session_handle, command_id, input, input_len,
@@ -357,13 +316,10 @@ int dal_send_and_receive(u64 handle,
 }
 EXPORT_SYMBOL(dal_send_and_receive);
 
-int dal_close_session(u64 handle, u64 session_handle)
+int dal_close_session(u64 session_handle)
 {
 	int ret, bh_err;
 
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
 	mutex_lock(&kdi_lock);
 
 	bh_err = bhp_close_ta_session(session_handle);
@@ -382,7 +338,6 @@ EXPORT_SYMBOL(dal_close_session);
 /**
  * dal_set_exclusive_access - set given uuid exclusive
  *
- * @handle: kdi handle
  * @ta_id: trusted applet id
  *
  * Return:
@@ -391,16 +346,13 @@ EXPORT_SYMBOL(dal_close_session);
  *    DAL_KDI_STATUS_TA_EXIST
  *    DAL_KDI_STATUS_NON_EXCLUSIVENESS_TA;
  */
-int dal_set_ta_exclusive_access(u64 handle, uuid_be ta_id)
+int dal_set_ta_exclusive_access(uuid_be ta_id)
 {
 	struct dal_device *ddev;
 	struct device *dev;
 	struct dal_client *dc;
 	int ret;
 
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
 	mutex_lock(&kdi_lock);
 
 	dev = dal_find_dev(DAL_MEI_DEVICE_IVM);
@@ -431,21 +383,17 @@ EXPORT_SYMBOL(dal_set_ta_exclusive_access);
 /**
  * dal_unset_ta_exclusive_access - remove exclusiveness from uuid
  *
- * @handle: kdi handle
  * @ta_id: trusted applet id
  *
  * Return:
  */
-int dal_unset_ta_exclusive_access(u64 handle, uuid_be ta_id)
+int dal_unset_ta_exclusive_access(uuid_be ta_id)
 {
 	struct dal_device *ddev;
 	struct device *dev;
 	struct dal_client *dc;
 	int ret;
 
-	if (!kdi_check_handle(handle))
-		return DAL_KDI_STATUS_INVALID_HANDLE;
-
 	mutex_lock(&kdi_lock);
 
 	dev = dal_find_dev(DAL_MEI_DEVICE_IVM);
diff --git a/include/linux/dal.h b/include/linux/dal.h
index e34a9f2..5a3b1e3 100644
--- a/include/linux/dal.h
+++ b/include/linux/dal.h
@@ -103,27 +103,6 @@ struct dal_version_info {
 #define KDI_INIT_FLAGS_NONE       0
 
 /**
- * kdi_init -  Init KDI kernel interface.
- * NOTE: Before calling kdi init we assuming that user space api
- *       called.
- *
- * @falgs:    flag for init flow
- * @handle:   pointer to get handle
- *
- * Return: 0 for success < 0 otherwise
- */
-int kdi_init(u32 flags, u64 *handle);
-
-/**
- * kdi_deinit -  deinit KDI kernel interface.
- *
- * @handle:   kdi handle
- *
- * Return: 0 for success < 0 otherwise
- */
-int kdi_deinit(u64 handle);
-
-/**
  * dal_get_version_info - return DAL version.
  *
  * @version_info:   pointer to KDI version struct
@@ -135,7 +114,6 @@ int dal_get_version_info(struct dal_version_info *version_info);
 /**
  * dal_create_session - will open session to an applet
  *
- * @handle:            kdi handle
  * @session_handle:    pointer to get the session handle
  * @app_id:            applet id
  * @acp_pkg:           applet acp data
@@ -145,15 +123,13 @@ int dal_get_version_info(struct dal_version_info *version_info);
  *
  * Return: 0 for success fail otherwise
  */
-int dal_create_session(u64 handle, u64 *session_handle,
-		       const char *app_id, const u8 *acp_pkg,
-		       size_t acp_pkg_len, const u8 *init_param,
-		       size_t init_param_len);
+int dal_create_session(u64 *session_handle, const char *app_id,
+		       const u8 *acp_pkg, size_t acp_pkg_len,
+		       const u8 *init_param, size_t init_param_len);
 
 /**
  * dal_send_and_receive - send and receive data to/from the applet
  *
- * @handle:            kdi handle
  * @session_handle:    session handle
  * @command_id:        command id
  * @input:             send buffer
@@ -164,24 +140,21 @@ int dal_create_session(u64 handle, u64 *session_handle,
  *
  * Return: 0 for success fail otherwise
  */
-int dal_send_and_receive(u64 handle, u64 session_handle,
-			 int command_id, const u8 *input,
-			 size_t input_len, u8 **output,
-			 size_t *output_len,
+int dal_send_and_receive(u64 session_handle, int command_id, const u8 *input,
+			 size_t input_len, u8 **output, size_t *output_len,
 			 int *response_code);
 
 /**
  * dal_close_session - close an open applet session
  *
- * @handle:            kdi handle
  * @session_handle:    session handle
  *
  * Return: 0 for success fail otherwise
  */
-int dal_close_session(u64 handle, u64 session_handle);
+int dal_close_session(u64 session_handle);
 
-int dal_set_ta_exclusive_access(u64 handle, uuid_be ta_id);
+int dal_set_ta_exclusive_access(uuid_be ta_id);
 
-int dal_unset_ta_exclusive_access(u64 handle, uuid_be ta_id);
+int dal_unset_ta_exclusive_access(uuid_be ta_id);
 
 #endif /* _DAL_H_ */
-- 
1.7.5.4

