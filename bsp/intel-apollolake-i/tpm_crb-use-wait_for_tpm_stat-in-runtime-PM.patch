From fdc56c5ed3fd7d46541d87d985adced62ed8fcf2 Mon Sep 17 00:00:00 2001
From: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Date: Sun, 26 Jun 2016 08:13:26 +0300
Subject: [PATCH 2319/2508] tpm_crb: use wait_for_tpm_stat() in runtime PM

commit 664fe6950d981df232a32c3b091be49db8e54390 from
https://github.com/01org/linux-apollolake-i

Use wait_for_tpm_stat() instead of sleeping 200 ms in runtime PM, which
works by sleeping 5 ms and polling for the status change. This is done
in order to ensure minimum latency.

Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
---
 drivers/char/tpm/tpm_crb.c |   18 ++++++++++++++----
 1 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index 105fad0..d9447a9 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -68,6 +68,8 @@ struct crb_control_area {
 
 enum crb_status {
 	CRB_DRV_STS_COMPLETE	= BIT(0),
+	CRB_DRV_STS_READY	= BIT(1),
+	CRB_DRV_STS_IDLE	= BIT(2),
 };
 
 enum crb_flags {
@@ -93,9 +95,9 @@ static int __maybe_unused crb_pause(struct tpm_chip *chip)
 
 	req = ioread32(&priv->cca->req);
 	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_GO_IDLE), &priv->cca->req);
-	msleep(chip->timeout_c);
 
-	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_GO_IDLE) {
+	if (wait_for_tpm_stat(chip, CRB_DRV_STS_IDLE, TPM2_TIMEOUT_C, NULL,
+			      false)) {
 		dev_warn(&chip->dev, "goIdle timed out\n");
 		return -ETIME;
 	}
@@ -113,9 +115,9 @@ static int __maybe_unused crb_resume(struct tpm_chip *chip)
 
 	req = ioread32(&priv->cca->req);
 	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_CMD_READY), &priv->cca->req);
-	msleep(chip->timeout_c);
 
-	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_CMD_READY) {
+	if (wait_for_tpm_stat(chip, CRB_DRV_STS_READY, TPM2_TIMEOUT_C, NULL,
+			      false)) {
 		dev_warn(&chip->dev, "cmdReady timed out\n");
 		return -ETIME;
 	}
@@ -134,6 +136,14 @@ static u8 crb_status(struct tpm_chip *chip)
 	    CRB_START_INVOKE)
 		sts |= CRB_DRV_STS_COMPLETE;
 
+	if ((ioread32(&priv->cca->req) & CRB_CTRL_REQ_CMD_READY) !=
+	    CRB_CTRL_REQ_CMD_READY)
+		sts |= CRB_DRV_STS_READY;
+
+	if ((ioread32(&priv->cca->req) & CRB_CTRL_REQ_GO_IDLE) !=
+	    CRB_CTRL_REQ_GO_IDLE)
+		sts |= CRB_DRV_STS_IDLE;
+
 	return sts;
 }
 
-- 
1.7.5.4

