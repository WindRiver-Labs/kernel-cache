From e98986b6c0d20c8535a812f8518e8b12be013b17 Mon Sep 17 00:00:00 2001
From: Guneshwor Singh <guneshwor.o.singh@intel.com>
Date: Fri, 20 Nov 2015 21:42:45 +0530
Subject: [PATCH 1833/2508] Add support for CNL FPGA

commit 84b969e25cacadcaf846d94d4fa9ce9c59032006 from
https://github.com/01org/linux-apollolake-i

This includes IMR allocation

Change-Id: If53609cd8626c5ab94a418b48b241f6a8572f5fb
Signed-off-by: Guneshwor Singh <guneshwor.o.singh@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7500
Reviewed-by: Shah, Hardik T <hardik.t.shah@intel.com>
Tested-by: Shah, Hardik T <hardik.t.shah@intel.com>
---
 sound/soc/intel/Kconfig               |    5 +++
 sound/soc/intel/common/sst-dsp-priv.h |    2 +-
 sound/soc/intel/common/sst-ipc.c      |    2 +-
 sound/soc/intel/skylake/cnl-sst.c     |   57 +++++++++++++++++++++++++++++++++
 4 files changed, 64 insertions(+), 2 deletions(-)

diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
index f1a6597..86c9240 100644
--- a/sound/soc/intel/Kconfig
+++ b/sound/soc/intel/Kconfig
@@ -247,3 +247,8 @@ config SND_SOC_INTEL_CNL_WM8281_MACH
         sound card.
         Say Y if you have such a device
         If unsure select "N".
+
+config SND_SOC_INTEL_CNL_FPGA
+	bool "Enable CNL FPGA board settings"
+	help
+	  Say Y here to enable the support for CNL audio FPGA Device.
diff --git a/sound/soc/intel/common/sst-dsp-priv.h b/sound/soc/intel/common/sst-dsp-priv.h
index c790540..fd456fb 100644
--- a/sound/soc/intel/common/sst-dsp-priv.h
+++ b/sound/soc/intel/common/sst-dsp-priv.h
@@ -320,7 +320,7 @@ struct sst_dsp {
 	u32 intr_status;
 	const struct firmware *fw;
 	struct snd_dma_buffer dmab;
-#if IS_ENABLED(CONFIG_SND_HDA_INTEL_SKL_FPGA)
+#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
         struct snd_dma_buffer dsp_fw_buf;
 #endif
 };
diff --git a/sound/soc/intel/common/sst-ipc.c b/sound/soc/intel/common/sst-ipc.c
index 58a6343..9e17878 100644
--- a/sound/soc/intel/common/sst-ipc.c
+++ b/sound/soc/intel/common/sst-ipc.c
@@ -34,7 +34,7 @@
 #include "sst-ipc.h"
 
 /* IPC message timeout (msecs) */
-#define IPC_TIMEOUT_MSECS	300
+#define IPC_TIMEOUT_MSECS	3000
 
 #define IPC_EMPTY_LIST_SIZE	8
 
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 8d0aeffa..f8baec8 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -97,6 +97,54 @@ void cnl_ipc_free(struct sst_generic_ipc *ipc)
 	sst_ipc_fini(ipc);
 }
 
+#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
+
+#define CNL_IMR_MEMSIZE					0x400000  /*4MB*/
+#define HDA_ADSP_REG_ADSPCS_IMR_CACHED_TLB_START	0x100
+#define HDA_ADSP_REG_ADSPCS_IMR_UNCACHED_TLB_START	0x200
+#define HDA_ADSP_REG_ADSPCS_IMR_SIZE	0x8
+/* Needed for presilicon platform based on FPGA */
+static int cnl_fpga_alloc_imr(struct sst_dsp *ctx)
+{
+	u32 pages;
+	u32 fw_size = CNL_IMR_MEMSIZE;
+	int ret;
+
+	ret = ctx->dsp_ops.alloc_dma_buf(ctx->dev, &ctx->dsp_fw_buf, fw_size);
+
+	if (ret < 0) {
+		dev_err(ctx->dev, "Alloc buffer for base fw failed: %x\n", ret);
+		return ret;
+	}
+
+	pages = (fw_size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+
+	dev_dbg(ctx->dev, "sst_cnl_fpga_alloc_imr pages=0x%x\n", pages);
+	set_memory_uc((unsigned long)ctx->dsp_fw_buf.area, pages);
+
+	writeq(virt_to_phys(ctx->dsp_fw_buf.area) + 1,
+		 ctx->addr.shim + HDA_ADSP_REG_ADSPCS_IMR_CACHED_TLB_START);
+	writeq(virt_to_phys(ctx->dsp_fw_buf.area) + 1,
+		 ctx->addr.shim + HDA_ADSP_REG_ADSPCS_IMR_UNCACHED_TLB_START);
+
+	writel(CNL_IMR_MEMSIZE, ctx->addr.shim
+	       + HDA_ADSP_REG_ADSPCS_IMR_CACHED_TLB_START
+	       + HDA_ADSP_REG_ADSPCS_IMR_SIZE);
+	writel(CNL_IMR_MEMSIZE, ctx->addr.shim
+	       + HDA_ADSP_REG_ADSPCS_IMR_UNCACHED_TLB_START
+	       + HDA_ADSP_REG_ADSPCS_IMR_SIZE);
+
+	memset(ctx->dsp_fw_buf.area, 0, fw_size);
+
+	return 0;
+}
+
+static inline void cnl_fpga_free_imr(struct sst_dsp *ctx)
+{
+	ctx->dsp_ops.free_dma_buf(ctx->dev, &ctx->dsp_fw_buf);
+}
+
+#endif
 static int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 		u32 fwsize)
 {
@@ -105,6 +153,11 @@ static int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 	u32 reg;
 	u32 pages;
 
+#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
+	ret = cnl_fpga_alloc_imr(ctx);
+	if (ret < 0)
+		return ret;
+#endif
 	dev_dbg(ctx->dev, "Starting to prepare host dma fwsize=0x%x\n", fwsize);
 	stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fwsize, &ctx->dmab);
 	if (stream_tag <= 0) {
@@ -114,6 +167,7 @@ static int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 
 	ctx->dsp_ops.stream_tag = stream_tag;
 	pages = (fwsize + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	set_memory_uc((unsigned long)ctx->dmab.area, pages);
 	memcpy(ctx->dmab.area, fwdata, fwsize);
 
 	/* purge FW request */
@@ -173,6 +227,9 @@ static int cnl_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 base_fw_load_failed:
 	cnl_dsp_disable_core(ctx);
 	ctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);
+#if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
+	cnl_fpga_free_imr(ctx);
+#endif
 	return ret;
 }
 
-- 
1.7.5.4

