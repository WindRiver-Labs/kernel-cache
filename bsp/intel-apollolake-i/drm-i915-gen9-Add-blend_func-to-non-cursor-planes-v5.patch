From e250fc5eb85c708fcb85c7ee90c688728c749fc8 Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Fri, 12 Feb 2016 15:47:13 -0800
Subject: [PATCH 1415/2508] drm/i915/gen9: Add blend_func to non-cursor planes
 (v5)

commit c7b4f71a22321c8817d349cdc18483268ba37316 from
https://github.com/01org/linux-apollolake-i

This patch adds the blend functions, and as per the
blend function, updates the plane control register values

V2: Add blend support for all RGB8888 formats
Fix the reg writes on plane_ctl_alpha bits.

v3 (by Matt):
 - Squash in patch to drop alpha for non-ARGB formats
 - Squash in primary plane support
 - Move blend style selection to check function
 - Rework logic to map factors to blend style
 - Check for pixel formats that our hardware can't blend
 - Drop formats our hardware doesn't support

v4 (by Matt):
 - Use GENMASK_ULL() rather than GENMASK() to build 64-bit mask

v5 (by Matt):
 - Fix alpha test at end of check to only take effect if alpha was
   actually asked for; fixes the complete breakage of RGB565 and
   similar formats.

Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
Signed-off-by: vandita kulkarni <vandita.kulkarni@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/intel_atomic_plane.c |   16 ++++
 drivers/gpu/drm/i915/intel_display.c      |  136 ++++++++++++++++++++++++++---
 drivers/gpu/drm/i915/intel_drv.h          |   14 +++-
 drivers/gpu/drm/i915/intel_sprite.c       |    4 +-
 4 files changed, 155 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_atomic_plane.c b/drivers/gpu/drm/i915/intel_atomic_plane.c
index 7de7721..81c8b71 100644
--- a/drivers/gpu/drm/i915/intel_atomic_plane.c
+++ b/drivers/gpu/drm/i915/intel_atomic_plane.c
@@ -56,6 +56,7 @@ intel_create_plane_state(struct drm_plane *plane)
 
 	state->base.plane = plane;
 	state->base.rotation = BIT(DRM_ROTATE_0);
+	state->base.blend_mode.func = DRM_BLEND_FUNC(AUTO, AUTO);
 	state->ckey.flags = I915_SET_COLORKEY_NONE;
 
 	return state;
@@ -114,6 +115,7 @@ static int intel_plane_atomic_check(struct drm_plane *plane,
 	struct intel_plane *intel_plane = to_intel_plane(plane);
 	struct intel_plane_state *intel_state = to_intel_plane_state(state);
 	struct drm_crtc_state *drm_crtc_state;
+	enum drm_blend_factor src_factor, dst_factor;
 	int ret;
 
 	crtc = crtc ? crtc : plane->state->crtc;
@@ -185,6 +187,20 @@ static int intel_plane_atomic_check(struct drm_plane *plane,
 	if (ret)
 		return ret;
 
+	if (state->blend_mode.func & ~GENMASK_ULL(31, 0)) {
+		DRM_DEBUG_KMS("Invalid bits in blend mode function (0x%llx)!\n",
+			      state->blend_mode.func);
+		return -EINVAL;
+	}
+
+	src_factor = DRM_BLEND_FUNC_SRC_FACTOR(state->blend_mode.func);
+	dst_factor = DRM_BLEND_FUNC_DST_FACTOR(state->blend_mode.func);
+	if ((src_factor == DRM_BLEND_FACTOR_AUTO) ^
+	    (dst_factor == DRM_BLEND_FACTOR_AUTO)) {
+		DRM_DEBUG_KMS("Invalid mix of auto and non-auto blend factors!");
+		return -EINVAL;
+	}
+
 	return intel_plane_atomic_calc_changes(&crtc_state->base, state);
 }
 
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index e578f03..8010b0eb 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -2901,28 +2901,41 @@ static void skl_detach_scalers(struct intel_crtc *intel_crtc)
 	}
 }
 
-u32 skl_plane_ctl_format(uint32_t pixel_format)
+u32 skl_plane_ctl_format(uint32_t pixel_format, enum i915_alpha alpha)
 {
+	u32 plane_ctl_alpha;
+
+	switch (alpha) {
+	case I915_ALPHA_NONE:
+		plane_ctl_alpha = PLANE_CTL_ALPHA_DISABLE;
+		break;
+	case I915_ALPHA_PREMUL:
+		plane_ctl_alpha = PLANE_CTL_ALPHA_SW_PREMULTIPLY;
+		break;
+	case I915_ALPHA_NON_PREMUL:
+		plane_ctl_alpha = PLANE_CTL_ALPHA_HW_PREMULTIPLY;
+		break;
+	default:
+		MISSING_CASE(alpha);
+		plane_ctl_alpha = PLANE_CTL_ALPHA_DISABLE;
+	}
+
 	switch (pixel_format) {
 	case DRM_FORMAT_C8:
 		return PLANE_CTL_FORMAT_INDEXED;
 	case DRM_FORMAT_RGB565:
 		return PLANE_CTL_FORMAT_RGB_565;
-	case DRM_FORMAT_XBGR8888:
-		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;
-	case DRM_FORMAT_XRGB8888:
 		return PLANE_CTL_FORMAT_XRGB_8888;
-	/*
-	 * XXX: For ARBG/ABGR formats we default to expecting scanout buffers
-	 * to be already pre-multiplied. We need to add a knob (or a different
-	 * DRM_FORMAT) for user-space to configure that.
-	 */
 	case DRM_FORMAT_ABGR8888:
-		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX |
-			PLANE_CTL_ALPHA_SW_PREMULTIPLY;
+	case DRM_FORMAT_XBGR8888:
+		return PLANE_CTL_FORMAT_XRGB_8888 |
+		       PLANE_CTL_ORDER_RGBX |
+		       plane_ctl_alpha;
 	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XRGB8888:
 		return PLANE_CTL_FORMAT_XRGB_8888 |
-			PLANE_CTL_ALPHA_SW_PREMULTIPLY;
+		       PLANE_CTL_ORDER_BGRX |
+		       plane_ctl_alpha;
 	case DRM_FORMAT_XRGB2101010:
 		return PLANE_CTL_FORMAT_XRGB_2101010;
 	case DRM_FORMAT_XBGR2101010:
@@ -3011,7 +3024,8 @@ static void skylake_update_primary_plane(struct drm_plane *plane,
 		    PLANE_CTL_PIPE_GAMMA_ENABLE |
 		    PLANE_CTL_PIPE_CSC_ENABLE;
 
-	plane_ctl |= skl_plane_ctl_format(fb->pixel_format);
+	plane_ctl |= skl_plane_ctl_format(fb->pixel_format, plane_state->alpha);
+
 	plane_ctl |= skl_plane_ctl_tiling(fb->modifier[0]);
 	plane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;
 	plane_ctl |= skl_plane_ctl_rotation(rotation);
@@ -11804,6 +11818,79 @@ static bool needs_scaling(struct intel_plane_state *state)
 	return (src_w != dst_w || src_h != dst_h);
 }
 
+static int intel_plane_state_check_blend(struct drm_plane_state *plane_state)
+{
+	struct drm_device *dev = plane_state->state->dev;
+	struct intel_plane_state *state = to_intel_plane_state(plane_state);
+	const struct drm_framebuffer *fb = plane_state->fb;
+	const struct drm_blend_mode *mode = &state->base.blend_mode;
+	bool has_per_pixel_blending;
+
+	/*
+	 * We don't install the properties pre-SKL, so this is SKL+ specific
+	 * code for now.
+	 */
+	if (INTEL_INFO(dev)->gen < 9)
+		return 0;
+
+	if (!fb)
+		return 0;
+
+	switch (fb->pixel_format) {
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_ARGB8888:
+		has_per_pixel_blending = true;
+	default:
+		has_per_pixel_blending = false;
+	}
+
+
+	switch (mode->func) {
+	/*
+	 * The 'AUTO' behaviour is the default and keeps compatibility with
+	 * kernels before the introduction of the blend_func property:
+	 *   - pre-multiplied alpha if the fb has an alpha channel
+	 *   - disabled otherwise
+	 */
+	case DRM_BLEND_FUNC(AUTO, AUTO):
+	case DRM_BLEND_FUNC(ONE, ONE_MINUS_SRC_ALPHA):
+		state->alpha = has_per_pixel_blending ?
+			I915_ALPHA_PREMUL : I915_ALPHA_NONE;
+		break;
+	/* fbs without an alpha channel, or dropping the alpha channel */
+	case DRM_BLEND_FUNC(ONE, ZERO):
+		state->alpha = I915_ALPHA_NONE;
+		break;
+	/* non pre-multiplied alpha */
+	case DRM_BLEND_FUNC(SRC_ALPHA, ONE_MINUS_SRC_ALPHA):
+		state->alpha = has_per_pixel_blending ?
+			I915_ALPHA_NON_PREMUL : I915_ALPHA_NONE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * Make sure we don't try to do blending on pixel formats that can't
+	 * support it (i.e., non-RGB8888 formats).
+	 */
+	switch (fb->pixel_format) {
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_XRGB8888:
+		break;
+	default:
+		if (state->alpha != I915_ALPHA_NONE) {
+			DRM_DEBUG_KMS("Format %s does not support per-pixel alpha blending!",
+				      drm_get_format_name(fb->pixel_format));
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
 				    struct drm_plane_state *plane_state)
 {
@@ -11898,6 +11985,12 @@ int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
 	    !needs_scaling(old_plane_state))
 		pipe_config->disable_lp_wm = true;
 
+	if (plane->type != DRM_PLANE_TYPE_CURSOR) {
+		ret = intel_plane_state_check_blend(plane_state);
+		if (ret)
+			return ret;
+	}
+
 	return 0;
 }
 
@@ -14079,6 +14172,9 @@ static struct drm_plane *intel_primary_plane_create(struct drm_device *dev,
 	if (INTEL_INFO(dev)->gen >= 4)
 		intel_create_rotation_property(dev, primary);
 
+	if (INTEL_INFO(dev)->gen == 9)
+		intel_plane_add_blend_properties(primary);
+
 	drm_plane_helper_add(&primary->base, &intel_plane_helper_funcs);
 
 	return &primary->base;
@@ -14102,6 +14198,20 @@ void intel_create_rotation_property(struct drm_device *dev, struct intel_plane *
 				plane->base.state->rotation);
 }
 
+void intel_plane_add_blend_properties(struct intel_plane *plane)
+{
+	struct drm_device *dev = plane->base.dev;
+	struct drm_property *prop;
+
+	if (INTEL_INFO(dev)->gen < 9)
+		return;
+
+	prop = dev->mode_config.prop_blend_func;
+	if (prop)
+		drm_object_attach_property(&plane->base.base, prop,
+					   DRM_BLEND_FUNC(AUTO, AUTO));
+}
+
 static int
 intel_check_cursor_plane(struct drm_plane *plane,
 			 struct intel_crtc_state *crtc_state,
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 02a3ad4..462a0ba 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -315,6 +315,12 @@ struct intel_atomic_state {
 	struct skl_wm_values wm_results;
 };
 
+enum i915_alpha {
+	I915_ALPHA_NONE,
+	I915_ALPHA_PREMUL,
+	I915_ALPHA_NON_PREMUL
+};
+
 struct intel_plane_state {
 	struct drm_plane_state base;
 	struct drm_rect src;
@@ -341,6 +347,10 @@ struct intel_plane_state {
 	 *     update_scaler_plane.
 	 */
 	int scaler_id;
+	/*
+	 * blending related hw states
+	 */
+	enum i915_alpha alpha;
 
 	struct drm_intel_sprite_colorkey ckey;
 
@@ -1216,6 +1226,7 @@ intel_rotation_90_or_270(unsigned int rotation)
 
 void intel_create_rotation_property(struct drm_device *dev,
 					struct intel_plane *plane);
+void intel_plane_add_blend_properties(struct intel_plane *plane);
 
 void assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,
 				    enum pipe pipe);
@@ -1286,11 +1297,12 @@ void intel_mode_from_pipe_config(struct drm_display_mode *mode,
 int skl_update_scaler_crtc(struct intel_crtc_state *crtc_state);
 int skl_max_scale(struct intel_crtc *crtc, struct intel_crtc_state *crtc_state);
 
+u32 skl_plane_ctl_format(uint32_t pixel_format, enum i915_alpha alpha);
+
 u32 intel_plane_obj_offset(struct intel_plane *intel_plane,
 			   struct drm_i915_gem_object *obj,
 			   unsigned int plane);
 
-u32 skl_plane_ctl_format(uint32_t pixel_format);
 u32 skl_plane_ctl_tiling(uint64_t fb_modifier);
 u32 skl_plane_ctl_rotation(unsigned int rotation);
 
diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c
index 8821533..1580599 100644
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@ -210,7 +210,8 @@ skl_update_plane(struct drm_plane *drm_plane,
 		PLANE_CTL_PIPE_GAMMA_ENABLE |
 		PLANE_CTL_PIPE_CSC_ENABLE;
 
-	plane_ctl |= skl_plane_ctl_format(fb->pixel_format);
+	plane_ctl |= skl_plane_ctl_format(fb->pixel_format,
+					plane_state->alpha);
 	plane_ctl |= skl_plane_ctl_tiling(fb->modifier[0]);
 
 	plane_ctl |= skl_plane_ctl_rotation(rotation);
@@ -1116,6 +1117,7 @@ intel_plane_init(struct drm_device *dev, enum pipe pipe, int plane)
 	}
 
 	intel_create_rotation_property(dev, intel_plane);
+	intel_plane_add_blend_properties(intel_plane);
 
 	drm_plane_helper_add(&intel_plane->base, &intel_plane_helper_funcs);
 
-- 
1.7.5.4

