From ab50fd4d5c40225e33cc4b8abcf11d932ff5dcb3 Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Tue, 12 Jan 2016 20:38:02 +0530
Subject: [PATCH 1848/2508] ASoC: Intel: Skylake: Enable BXT Streaming D0i3
 support

commit 06287ca095520326332aacaa61afd3689a12cb41 from
https://github.com/01org/linux-apollolake-i

This patch adds support for streaming D0i3 power state
on BXT.

At the end of each IPC, if the conditions for D0i3
entry are appropriate, a D0i3 task is scheduled with
a delay. At the start of each IPC any pending D0i3 entry
task is canceled and if the DSP is indeed in D0i3 state,
it is brought back to D0i0 state before sending the IPC.
The delayed task helps avoid unnecessary D0i3<-->D0i0
transitions.

Change-Id: Ie8b3ceb43b27756f938524842730a67e160354fe
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Signed-off-by: Pardha Saradhi K <pardha.saradhi.kesapragada@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7981
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c     |  101 +++++++++++++++++++++++++++++++++
 sound/soc/intel/skylake/skl-sst-dsp.h |    3 +
 sound/soc/intel/skylake/skl-sst-ipc.c |   22 ++++++--
 sound/soc/intel/skylake/skl-sst-ipc.h |    1 +
 4 files changed, 122 insertions(+), 5 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 669884b..671e3239 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -52,9 +52,15 @@
 #define BXT_ADSP_W0_UP_SZ	0x800
 #define BXT_ADSP_W1_SZ  0x1000
 
+/* Delay before scheduling D0i3 entry */
+#define BXT_D0I3_DELAY 5000
+
 static int bxt_load_base_firmware(struct sst_dsp *ctx);
 static int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id);
 static int bxt_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id);
+static int bxt_schedule_dsp_D0i3(struct sst_dsp *ctx);
+static int bxt_set_dsp_D0i0(struct sst_dsp *ctx);
+static void bxt_set_dsp_D0i3(struct work_struct *work);
 static int bxt_load_library(struct sst_dsp *ctx,
 		struct skl_dfw_manifest *minfo);
 
@@ -66,6 +72,8 @@ static unsigned int bxt_get_errorcode(struct sst_dsp *ctx)
 static struct skl_dsp_fw_ops bxt_fw_ops = {
 	.set_state_D0 = bxt_set_dsp_D0,
 	.set_state_D3 = bxt_set_dsp_D3,
+	.set_state_D0i3 = bxt_schedule_dsp_D0i3,
+	.set_state_D0i0 = bxt_set_dsp_D0i0,
 	.load_fw = bxt_load_base_firmware,
 	.get_fw_errcode = bxt_get_errorcode,
 	.load_library = bxt_load_library,
@@ -132,6 +140,8 @@ int bxt_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 	skl->boot_complete = false;
 	init_waitqueue_head(&skl->boot_wait);
 
+	INIT_DELAYED_WORK(&skl->d0i3_data.d0i3_work, bxt_set_dsp_D0i3);
+
 	ret = sst->fw_ops.load_fw(sst);
 	if (ret < 0) {
 		dev_err(dev, "Load base fw failed : %x", ret);
@@ -330,6 +340,97 @@ static int sst_transfer_fw_host_dma(struct sst_dsp *ctx)
 	return ret;
 }
 
+static void bxt_set_dsp_D0i3(struct work_struct *work)
+{
+	int ret;
+	struct skl_ipc_d0ix_msg msg;
+	struct skl_sst *skl = container_of(work,
+			struct skl_sst, d0i3_data.d0i3_work.work);
+	struct sst_dsp *ctx = skl->dsp;
+
+	dev_dbg(ctx->dev, "In %s:\n", __func__);
+
+	/* D0i3 entry allowed only if core 0 alone is running */
+	if (SKL_DSP_CORE0_MASK != skl_dsp_get_enabled_cores(ctx)) {
+		dev_warn(ctx->dev,
+				"D0i3 allowed when only core0 running:Exit\n");
+		return;
+	}
+
+	msg.instance_id = 0;
+	msg.module_id = 0;
+	msg.wake = 1;
+	msg.streaming = 1;
+
+	ret =  skl_ipc_set_d0ix(&skl->ipc, &msg);
+
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to set DSP to D0i3 state\n");
+		return;
+	}
+	/* Set Vendor specific register D0I3C.I3 to enable D0i3*/
+	if (skl->update_d0i3c)
+		skl->update_d0i3c(skl->dev, true);
+
+	ctx->core_info.core_state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING_D0I3;
+}
+
+static int bxt_schedule_dsp_D0i3(struct sst_dsp *ctx)
+{
+	struct skl_sst *skl = ctx->thread_context;
+	struct skl_d0i3_data *d0i3_data = &skl->d0i3_data;
+
+	/* Schedule D0i3 if DSP the stream counts are appropriate */
+
+	if ((d0i3_data->d0i3_stream_count > 0) &&
+			(d0i3_data->non_d0i3_stream_count == 0)) {
+
+		dev_dbg(ctx->dev, "%s: Schedule D0i3\n", __func__);
+
+		schedule_delayed_work(&d0i3_data->d0i3_work,
+				msecs_to_jiffies(BXT_D0I3_DELAY));
+	}
+
+	return 0;
+}
+
+static int bxt_set_dsp_D0i0(struct sst_dsp *ctx)
+{
+	int ret;
+	struct skl_ipc_d0ix_msg msg;
+	struct skl_sst *skl = ctx->thread_context;
+
+	dev_dbg(ctx->dev, "In %s:\n", __func__);
+
+	/* First Cancel any pending attempt to put DSP to D0i3 */
+	cancel_delayed_work_sync(&skl->d0i3_data.d0i3_work);
+
+	/* If DSP is currently in D0i3, bring it to D0i0 */
+	if (ctx->core_info.core_state[SKL_DSP_CORE0_ID] != SKL_DSP_RUNNING_D0I3)
+		return 0;
+
+	dev_dbg(ctx->dev, "Set DSP to D0i0\n");
+
+	msg.instance_id = 0;
+	msg.module_id = 0;
+	msg.streaming = 1;
+	msg.wake = 0;
+
+	/* Clear Vendor specific register D0I3C.I3 to disable D0i3*/
+	if (skl->update_d0i3c)
+		skl->update_d0i3c(skl->dev, false);
+
+	ret =  skl_ipc_set_d0ix(&skl->ipc, &msg);
+	if (ret < 0) {
+		dev_err(ctx->dev, "Failed to set DSP to D0i0\n");
+		return ret;
+	}
+
+	ctx->core_info.core_state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING;
+
+	return 0;
+}
+
 int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret;
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.h b/sound/soc/intel/skylake/skl-sst-dsp.h
index e7f67f7..18fc0df 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.h
+++ b/sound/soc/intel/skylake/skl-sst-dsp.h
@@ -125,6 +125,7 @@ struct skl_dfw_manifest;
 
 enum skl_dsp_states {
 	SKL_DSP_RUNNING = 1,
+	SKL_DSP_RUNNING_D0I3, /* Running in D0i3 state*/
 	SKL_DSP_RESET,
 };
 
@@ -136,6 +137,8 @@ struct skl_dsp_fw_ops {
 	int (*parse_fw)(struct sst_dsp *ctx);
 	int (*set_state_D0)(struct sst_dsp *ctx, unsigned int core_id);
 	int (*set_state_D3)(struct sst_dsp *ctx, unsigned int core_id);
+	int (*set_state_D0i3)(struct sst_dsp *ctx);
+	int (*set_state_D0i0)(struct sst_dsp *ctx);
 	unsigned int (*get_fw_errcode)(struct sst_dsp *ctx);
 	int (*load_mod)(struct sst_dsp *ctx, u16 mod_id, char *mod_name);
 	int (*unload_mod)(struct sst_dsp *ctx, u16 mod_id);
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.c b/sound/soc/intel/skylake/skl-sst-ipc.c
index 7dcafa1..66275d8 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.c
+++ b/sound/soc/intel/skylake/skl-sst-ipc.c
@@ -321,14 +321,26 @@ static int skl_ipc_tx_message(struct sst_generic_ipc *ipc, u64 header,
 		void *tx_data, size_t tx_bytes,
 		void *rx_data, size_t rx_bytes, bool wait)
 {
-	/* TODO: Bring DSP to D0i0 before sending current IPC */
-	/* D0i0 API (if supported on the platform) to be called here */
+	int ret;
+	struct sst_dsp *dsp = ipc->dsp;
+
+	/* Bring DSP to D0i0 before sending current IPC */
+	if (dsp->fw_ops.set_state_D0i0) {
+		ret = dsp->fw_ops.set_state_D0i0(dsp);
+		if (ret < 0)
+			return ret;
+	}
 
-	return _skl_ipc_tx_message(ipc, header, tx_data, tx_bytes, rx_data,
+	ret = _skl_ipc_tx_message(ipc, header, tx_data, tx_bytes, rx_data,
 			rx_bytes, wait);
+	if (ret < 0)
+		return ret;
 
-	/* TODO: Attempt D0i3 after sending current IPC */
-	/* D0i3 delayed work (if supported on the platform) to be called here */
+	/* Attempt D0i3 after sending current IPC */
+	if (dsp->fw_ops.set_state_D0i3)
+		ret = dsp->fw_ops.set_state_D0i3(dsp);
+
+	return ret;
 }
 
 static struct ipc_message *skl_ipc_reply_get_msg(struct sst_generic_ipc *ipc,
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index cf4fb71..5174f15 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -48,6 +48,7 @@ struct skl_ipc_header {
 struct skl_d0i3_data {
 	int d0i3_stream_count;
 	int non_d0i3_stream_count;
+	struct delayed_work d0i3_work;
 };
 
 struct skl_sst {
-- 
1.7.5.4

