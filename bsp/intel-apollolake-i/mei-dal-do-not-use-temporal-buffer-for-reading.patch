From ef35e49d29c5429d37ad820d79e180e5c6c59c82 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 24 Aug 2016 14:40:23 +0300
Subject: [PATCH 25/68] mei: dal: do not use temporal buffer for reading

commit 7f1ea2dbaf3af609102848796f73b1fd09a35aa5 from
git://git.yoctoproject.org/linux-yocto-4.1

A temporal buffer was used because the message length was set at the
end of the dal_bh_msg structure and could not be checked prior
of copying of the data.

Change-Id: Ic81a33655624d4093c9177363a6fe68124c88994
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_cdev.c  |   24 +++++++++++-------------
 drivers/misc/mei/dal/dal_class.c |    7 +++----
 drivers/misc/mei/dal/dal_dev.h   |    4 ++--
 drivers/misc/mei/dal/dal_kdi.c   |   31 +++++++++++++++++++------------
 4 files changed, 35 insertions(+), 31 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_cdev.c b/drivers/misc/mei/dal/dal_cdev.c
index 6881080..ad76dac 100644
--- a/drivers/misc/mei/dal/dal_cdev.c
+++ b/drivers/misc/mei/dal/dal_cdev.c
@@ -127,15 +127,14 @@ static int dal_dev_release(struct inode *inode, struct file *fp)
 	return 0;
 }
 
-/* This is only for tmp read data to client */
-static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
-#define BH_MSG_HEADER_LENGTH           32
-static ssize_t dal_dev_read(struct file *fp, char __user *buff,
+static ssize_t dal_dev_read(struct file *fp, char __user *buf,
 			    size_t count, loff_t *offp)
 {
 	struct dal_client *dc = fp->private_data;
 	struct dal_device *ddev = dc->ddev;
 	ssize_t ret;
+	size_t len;
+	unsigned int copied;
 
 	ret = dal_read(dc);
 
@@ -145,23 +144,22 @@ static ssize_t dal_dev_read(struct file *fp, char __user *buff,
 	if (kfifo_is_empty(&dc->read_queue))
 		return 0;
 
-	ret = kfifo_out(&dc->read_queue, &bh_msg[ddev->device_id],
-			sizeof(struct dal_bh_msg));
-	dev_dbg(&ddev->dev, "kfifo_out() ret = %zd\n", ret);
-
-	if (bh_msg[ddev->device_id].len > count) {
+	ret = kfifo_out(&dc->read_queue, &len, sizeof(len));
+	if (len > count) {
 		dev_dbg(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %zu\n",
-			bh_msg[ddev->device_id].len, count);
+			len, count);
 		return -EFAULT;
 	}
 
-	if (copy_to_user(buff, bh_msg[ddev->device_id].msg,
-			 bh_msg[ddev->device_id].len)) {
+	ret = kfifo_to_user(&dc->read_queue, buf, count, &copied);
+	if (ret) {
 		dev_dbg(&ddev->dev, "copy_to_user() failed\n");
 		return -EFAULT;
 	}
 
-	return bh_msg[ddev->device_id].len;
+	/*FIXME: need to drop rest of the data */
+
+	return copied;
 }
 
 static ssize_t dal_dev_write(struct file *fp, const char __user *buff,
diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index 6dfb1cd..4e28d74 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -483,10 +483,9 @@ static void dal_recv_cb(struct mei_cl_device *cldev, u32 events, void *context)
 	 * save new msg in queue,
 	 * if the queue is full all new messages will be thrown
 	 */
-	ret = kfifo_in(&dc->read_queue, &ddev->bh_fw_msg,
-		       sizeof(struct dal_bh_msg));
-	if (ret < sizeof(struct dal_bh_msg))
-		dev_dbg(&ddev->dev, "queue is full - MSG THROWN");
+	ret = kfifo_in(&dc->read_queue, &ddev->bh_fw_msg, len + sizeof(len));
+	if (ret < len + sizeof(len))
+		dev_err(&ddev->dev, "queue is full - MSG THROWN");
 
 	dal_dc_update_read_state(dc, len);
 
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 22dfa03..4b30947 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -126,12 +126,12 @@ struct dal_client;
 /**
  * struct dal_bh_msg: represent msg sent from the FW.
  *
- * @msg: message buffer
  * @len: message length
+ * @msg: message buffer
  */
 struct dal_bh_msg {
+	size_t  len;
 	char msg[DAL_MAX_BUFFER_SIZE];
-	ssize_t  len;
 };
 
 /**
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 70bcf71..7ebd94c 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -185,20 +185,19 @@ out:
 	return ret;
 }
 
-/* This is only for tmp read data to client */
-static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
 static int kdi_recv(unsigned int handle,
-		    unsigned char *buf, unsigned int *len)
+		    unsigned char *buf, unsigned int *count)
 {
 	enum dal_dev_type mei_device;
 	struct dal_device *ddev;
 	struct dal_client *dc;
 	struct device *dev;
 	ssize_t ret;
+	size_t len;
 
 	mei_device = (enum dal_dev_type)handle;
 
-	if (!buf || !len)
+	if (!buf || !count)
 		return BPE_INVALID_PARAMS;
 
 	if (mei_device < DAL_MEI_DEVICE_IVM || mei_device >= DAL_MEI_DEVICE_MAX)
@@ -226,21 +225,29 @@ static int kdi_recv(unsigned int handle,
 		goto out;
 	}
 
-	ret = kfifo_out(&dc->read_queue,
-			&bh_msg[ddev->device_id], sizeof(struct dal_bh_msg));
+	ret = kfifo_out(&dc->read_queue, &len, sizeof(len));
+	if (ret != sizeof(len)) {
+		dev_err(&ddev->dev, "could not copy buffer: cannot fetch size");
+		ret = BPE_COMMS_ERROR;
+		goto out;
+	}
 
-	if (bh_msg[ddev->device_id].len > *len) {
-		dev_dbg(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %u\n",
-			bh_msg[ddev->device_id].len, *len);
+	if (len > *count) {
+		dev_err(&ddev->dev, "could not copy buffer: src size = %zd > dest size = %u\n",
+			len, *count);
 		ret = BPE_COMMS_ERROR;
 		goto out;
 	}
 
-	memcpy(buf, bh_msg[ddev->device_id].msg, bh_msg[ddev->device_id].len);
+	ret = kfifo_out(&dc->read_queue, buf, len);
+	if (ret != len) {
+		dev_err(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %zd\n",
+			len, ret);
+		ret = BPE_COMMS_ERROR;
+	}
 
-	*len = bh_msg[ddev->device_id].len;
+	*count = len;
 	ret = BH_SUCCESS;
-
 out:
 	put_device(dev);
 	return ret;
-- 
1.7.5.4

