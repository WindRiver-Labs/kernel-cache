From 7e99f54dbde5a61194cee7dd8e87b8827ff80309 Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Wed, 20 Jul 2016 21:29:42 +0530
Subject: [PATCH 4690/4706] ASoC: Intel: Skylake: Exit gracefully on base
 FW/library load failure

commit 071d40b8c26cea60bb6b169875d7afc576cb4619 from
git://git.yoctoproject.org/linux-yocto-4.1

FW/Library load failure was causing kernel crashes. Inorder to handle
such failures exit and gracefully, the following changes are done.

1. Added a flag "is_first_boot" to specify if the first boot after power
up is yet to be done. Before first boot completes or on failure of first
boot due to FW/Library load issues, this flag will remain true.

2. If first boot is yet to be done(i.e. flag = true)  do not call
the DSP suspend/resume functions.  But the controller suspend/resume
will still work.

3. On failure of soc probe due to FW/lib load failure or otherwise,
set the platform pointer of skl_sst  to NULL. This is because, on
soc probe failure the memory for soc_platform stucture will be freed,
hence the copy of this pointer in skl_sst should be set to NULL to
avoid improper access during controller suspend.

Change-Id: Id287d5bdf5a21f1c678d57342ccf135ec1163a49
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/10553
Reviewed-by: Koul, Vinod <vinod.koul@intel.com>
Reviewed-by: Jayanti, Satya Charitardha <satya.charitardha.jayanti@intel.com>
Tested-by: Jayanti, Satya Charitardha <satya.charitardha.jayanti@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c      |    3 +++
 sound/soc/intel/skylake/cnl-sst.c      |    5 +++++
 sound/soc/intel/skylake/skl-messages.c |   12 ++++++++++--
 sound/soc/intel/skylake/skl-pcm.c      |    9 ++++++---
 sound/soc/intel/skylake/skl-sst-ipc.h  |    3 +++
 sound/soc/intel/skylake/skl-sst.c      |    6 +++++-
 6 files changed, 32 insertions(+), 6 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 101a339..ac5c0cc 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -162,6 +162,7 @@ int bxt_sst_dsp_init_hw(struct device *dev, struct skl_sst **dsp,
 
 	sst->core_info.cores = 2;
 	sst->num_i2s_ports = d->num_ssp;
+	skl->is_first_boot = true;
 
 	skl->boot_complete = false;
 	init_waitqueue_head(&skl->boot_wait);
@@ -195,6 +196,8 @@ int bxt_sst_dsp_init_fw(struct device *dev, struct skl_sst *ctx)
 		}
 	}
 
+	/* First boot successfully done */
+	ctx->is_first_boot = false;
 	dev_dbg(dev, "Exit %s\n", __func__);
 	return 0;
 }
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index 42a5d899..1b2d4dd 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -751,6 +751,7 @@ int cnl_sst_dsp_init_hw(struct device *dev, struct skl_sst **dsp,
 		return ret;
 
 	sst->core_info.cores = 4;
+	cnl->is_first_boot = true;
 
 	cnl->boot_complete = false;
 	init_waitqueue_head(&cnl->boot_wait);
@@ -782,6 +783,10 @@ int cnl_sst_dsp_init_fw(struct device *dev, struct skl_sst *ctx)
 			return ret;
 		}
 	}
+
+	/* First boot successfully done */
+	ctx->is_first_boot = false;
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cnl_sst_dsp_init_fw);
diff --git a/sound/soc/intel/skylake/skl-messages.c b/sound/soc/intel/skylake/skl-messages.c
index ac97b19..8f079a5 100644
--- a/sound/soc/intel/skylake/skl-messages.c
+++ b/sound/soc/intel/skylake/skl-messages.c
@@ -307,8 +307,7 @@ int skl_init_dsp_fw(struct skl *skl)
 	ret = dsp_ops[index].init_fw(bus->dev, skl->skl_sst);
 
 	if (ret < 0) {
-		skl_free_dsp(skl);
-		dev_err(bus->dev, "Firmware load failed\n");
+		dev_err(bus->dev, "Firmware or Library load failed\n");
 		pm_runtime_put_sync(bus->dev);
 		return ret;
 	}
@@ -349,12 +348,17 @@ int skl_suspend_dsp(struct skl *skl)
 	if (!skl->ebus.ppcap)
 		return 0;
 
+	/* Do not proceed to DSP suspend if DSP 1st boot is yet to be done */
+	if (ctx->is_first_boot == true)
+		goto disable_ppcap;
+
 	if (ctx && ctx->fw_loaded) {
 		ret = skl_dsp_sleep(ctx->dsp);
 		if (ret < 0)
 			return ret;
 	}
 
+disable_ppcap:
 	/* disable ppcap interrupt */
 	snd_hdac_ext_bus_ppcap_int_enable(&skl->ebus, false);
 	snd_hdac_ext_bus_ppcap_enable(&skl->ebus, false);
@@ -375,6 +379,10 @@ int skl_resume_dsp(struct skl *skl)
 	snd_hdac_ext_bus_ppcap_enable(&skl->ebus, true);
 	snd_hdac_ext_bus_ppcap_int_enable(&skl->ebus, true);
 
+	/* just return if DSP 1st boot is yet to be done */
+	if (ctx->is_first_boot == true)
+		return 0;
+
 	if (ctx) {
 		ret = skl_dsp_wake(ctx->dsp);
 		if (ret < 0)
diff --git a/sound/soc/intel/skylake/skl-pcm.c b/sound/soc/intel/skylake/skl-pcm.c
index c5cd7c2..0e68915 100644
--- a/sound/soc/intel/skylake/skl-pcm.c
+++ b/sound/soc/intel/skylake/skl-pcm.c
@@ -1703,7 +1703,7 @@ static int skl_platform_soc_probe(struct snd_soc_platform *platform)
 		ret = skl_tplg_init(platform, ebus);
 		if (ret < 0) {
 			dev_dbg(bus->dev, "error failed while initializing topology\n");
-			return ret;
+			goto out_free;
 		}
 		skl->skl_sst->update_d0i3c = skl_update_d0i3c;
 		skl->skl_sst->platform = platform;
@@ -1719,8 +1719,10 @@ static int skl_platform_soc_probe(struct snd_soc_platform *platform)
 
 	skl_get_probe_widget(platform, skl);
 	dbg_info = kzalloc(sizeof(struct platform_info), GFP_KERNEL);
-	if (!dbg_info)
-		return -ENOMEM;
+	if (!dbg_info) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
 
 	dbg_info->sram0_base = skl->skl_sst->dsp->addr.sram0_base;
 	dbg_info->sram1_base = skl->skl_sst->dsp->addr.sram1_base;
@@ -1738,6 +1740,7 @@ static int skl_platform_soc_probe(struct snd_soc_platform *platform)
 
 	return ret;
 out_free:
+	skl->skl_sst->platform = NULL;
 	skl->init_failed = 1;
 	return ret;
 }
diff --git a/sound/soc/intel/skylake/skl-sst-ipc.h b/sound/soc/intel/skylake/skl-sst-ipc.h
index a1d6565..70e2da1 100644
--- a/sound/soc/intel/skylake/skl-sst-ipc.h
+++ b/sound/soc/intel/skylake/skl-sst-ipc.h
@@ -127,6 +127,9 @@ struct skl_sst {
 	void (*enable_miscbdcge)(struct device *dev, bool enable);
 	/*Is CGCTL.MISCBDCGE disabled*/
 	bool miscbdcg_disabled;
+
+	/* is first boot yet to be done? */
+	bool is_first_boot;
 };
 
 struct skl_ipc_init_instance_msg {
diff --git a/sound/soc/intel/skylake/skl-sst.c b/sound/soc/intel/skylake/skl-sst.c
index ca76a98..8402ce3 100644
--- a/sound/soc/intel/skylake/skl-sst.c
+++ b/sound/soc/intel/skylake/skl-sst.c
@@ -495,6 +495,7 @@ int skl_sst_dsp_init_hw(struct device *dev, struct skl_sst **dsp, struct dsp_ini
 
 	sst->core_info.cores = 2;
 	sst->num_i2s_ports = d->num_ssp;
+	skl->is_first_boot = true;
 
 	if (dsp)
 		*dsp = skl;
@@ -510,8 +511,11 @@ int skl_sst_dsp_init_fw(struct device *dev, struct skl_sst *ctx)
 	ret = ctx->dsp->fw_ops.load_fw(ctx->dsp);
 	if (ret < 0)
 		dev_err(dev, "Load base fw failed : %d", ret);
-	else
+	else {
 		ctx->fw_loaded = true;
+		/* First boot successfully done */
+		ctx->is_first_boot = false;
+	}
 
 	return ret;
 }
-- 
1.7.5.4

