From e3837d34fe75747feaccc81d5a83cc67f550b499 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 14 Sep 2016 11:25:47 +0300
Subject: [PATCH 28/68] Revert "tpm_crb: runtime power management"

commit 9a3d399c229ba97ea1a5fc07391854faa96e3242 from
git://git.yoctoproject.org/linux-yocto-4.1

This reverts commit a0d2df4b97633b0f2592e05297834ef2ff4d756a.
---
 drivers/char/tpm/tpm-interface.c |    7 ------
 drivers/char/tpm/tpm_crb.c       |   44 --------------------------------------
 include/linux/tpm.h              |    3 +-
 3 files changed, 1 insertions(+), 53 deletions(-)

diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 3434ae5..7cba092 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -351,11 +351,6 @@ ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,
 	}
 
 	mutex_lock(&chip->tpm_mutex);
-	if (chip->ops->resume) {
-		rc = chip->ops->resume(chip);
-		if (rc)
-			goto out;
-	}
 
 	rc = chip->ops->send(chip, (u8 *) buf, count);
 	if (rc < 0) {
@@ -398,8 +393,6 @@ out_recv:
 		dev_err(&chip->dev,
 			"tpm_transmit: tpm_recv: error %zd\n", rc);
 out:
-	if (chip->ops->pause)
-		chip->ops->pause(chip);
 	mutex_unlock(&chip->tpm_mutex);
 	return rc;
 }
diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index 105fad0..c89e907 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -83,46 +83,6 @@ struct crb_priv {
 	u8 __iomem *rsp;
 };
 
-static int __maybe_unused crb_pause(struct tpm_chip *chip)
-{
-	struct crb_priv *priv = chip->vendor.priv;
-	u32 req;
-
-	if (priv->flags & CRB_FL_ACPI_START)
-		return 0;
-
-	req = ioread32(&priv->cca->req);
-	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_GO_IDLE), &priv->cca->req);
-	msleep(chip->timeout_c);
-
-	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_GO_IDLE) {
-		dev_warn(&chip->dev, "goIdle timed out\n");
-		return -ETIME;
-	}
-
-	return 0;
-}
-
-static int __maybe_unused crb_resume(struct tpm_chip *chip)
-{
-	struct crb_priv *priv = chip->vendor.priv;
-	u32 req;
-
-	if (priv->flags & CRB_FL_ACPI_START)
-		return 0;
-
-	req = ioread32(&priv->cca->req);
-	iowrite32(cpu_to_le32(req | CRB_CTRL_REQ_CMD_READY), &priv->cca->req);
-	msleep(chip->timeout_c);
-
-	if (ioread32(&priv->cca->req) & CRB_CTRL_REQ_CMD_READY) {
-		dev_warn(&chip->dev, "cmdReady timed out\n");
-		return -ETIME;
-	}
-
-	return 0;
-}
-
 static SIMPLE_DEV_PM_OPS(crb_pm, tpm_pm_suspend, tpm_pm_resume);
 
 static u8 crb_status(struct tpm_chip *chip)
@@ -232,10 +192,6 @@ static const struct tpm_class_ops tpm_crb = {
 	.recv = crb_recv,
 	.send = crb_send,
 	.cancel = crb_cancel,
-#ifdef CONFIG_PM
-	.resume = crb_resume,
-	.pause = crb_pause,
-#endif
 	.req_canceled = crb_req_canceled,
 	.req_complete_mask = CRB_DRV_STS_COMPLETE,
 	.req_complete_val = CRB_DRV_STS_COMPLETE,
diff --git a/include/linux/tpm.h b/include/linux/tpm.h
index f1d9b79..706e63e 100644
--- a/include/linux/tpm.h
+++ b/include/linux/tpm.h
@@ -43,8 +43,7 @@ struct tpm_class_ops {
 	u8 (*status) (struct tpm_chip *chip);
 	bool (*update_timeouts)(struct tpm_chip *chip,
 				unsigned long *timeout_cap);
-	int (*pause)(struct tpm_chip *chip);
-	int (*resume)(struct tpm_chip *chip);
+
 };
 
 #if defined(CONFIG_TCG_TPM) || defined(CONFIG_TCG_TPM_MODULE)
-- 
1.7.5.4

