From bf259bbcdf1f9715d4ebd98b8fa93a9f87e13e50 Mon Sep 17 00:00:00 2001
From: Evyatar Vaalani <evyatar.vaalani@intel.com>
Date: Thu, 8 Sep 2016 14:44:20 +0300
Subject: [PATCH 26/68] mei: dal: remove write pending flag from dal_device

commit 12703ffb17edda0181ed7e3af809febf52c8fb1c from
git://git.yoctoproject.org/linux-yocto-4.1

On write we saved pending write flag for write in fragments.
With code restructuring we can remove the usage of this flag.

Change-Id: I3c57517afa834de3683bfc95bff3782999a92cbf
Signed-off-by: Evyatar Vaalani <evyatar.vaalani@intel.com>
---
 drivers/misc/mei/dal/dal_class.c |   72 ++++++++++++++++----------------------
 drivers/misc/mei/dal/dal_dev.h   |    3 +-
 2 files changed, 31 insertions(+), 44 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index 4e28d74..0a70c54 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -209,8 +209,6 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	dev_dbg(dev, "current_write_client seq = %llu",
 			dc->seq);
 
-	ddev->is_write_pending = true;
-
 	/* put dc in write queue*/
 	if (ddev->current_write_client != dc) {
 		if (kfifo_is_empty(&ddev->write_queue))
@@ -225,7 +223,7 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 			dev_dbg(dev, "queue is full probably a bug");
 
 			mutex_unlock(&ddev->write_queue_lock);
-			goto cleanup;
+			return -EBUSY;
 		}
 	}
 
@@ -237,8 +235,8 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	mutex_unlock(&ddev->write_queue_lock);
 	ret = dal_wait_for_write(ddev, dc);
 	if (ret < 0) {
-		ddev->is_write_pending = false;
-		goto cleanup;
+		mutex_lock(&ddev->context_lock);
+		goto out;
 	}
 
 	dev_dbg(dev, "before mei_cldev_send - client type %d", intf);
@@ -252,8 +250,8 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 		dev_err(dev, "mei_cl_send() failed, write_bytes != count (%zd != %zu)\n",
 			wr, count);
 		ret = -EFAULT;
-		ddev->is_write_pending = false;
-		goto cleanup;
+		mutex_lock(&ddev->context_lock);
+		goto out;
 	}
 
 	dev_dbg(dev, "wrote %zu bytes to fw - client type %d", wr, intf);
@@ -275,12 +273,11 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 	/* TODO: we can remove this check and look only on the size */
 	if (dal_msg_is_spooler(dc->write_buffer)) {
 		ret = wr;
-		ddev->is_write_pending = false;
-		dev_dbg(dev, "SPOOLER msg command id = %d",
-				header->id);
-		goto cleanup;
+		dev_dbg(dev, "SPOOLER msg command id = %d", header->id);
+		goto out;
 	}
 
+	ret = wr;
 	/* header msg is being sent,
 	 * this is the first fragment of the message
 	 */
@@ -290,45 +287,36 @@ ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
 				intf);
 		dev_dbg(dev, "command id = %d", header->id);
 
-		/* if there's extra data, mark it */
-		if (dc->expected_msg_size_to_fw <= count)
-			ddev->is_write_pending = false;
-
 		dc->bytes_sent_to_fw = count;
-	}
+		/* if there's extra data, mark it */
+		if (dc->expected_msg_size_to_fw > count)
+			goto write_more;
 
-	/* another fragment which is not the last */
-	else if (dc->bytes_sent_to_fw != dc->expected_msg_size_to_fw) {
-		ddev->is_write_pending = true;
+	} else if (dc->bytes_sent_to_fw != dc->expected_msg_size_to_fw) {
 		dev_dbg(dev, "expecting to write more data to FW - client type %d",
 				intf);
-	} else {
-		/* this is the last fragment */
-		ddev->is_write_pending = false;
+		goto write_more;
 	}
 
-	ret = wr;
-
-cleanup:
-	if (!ddev->is_write_pending) {
-		dev_dbg(&ddev->dev, "removing CURRENT_WRITER\n");
-		/* init current to NULL */
-		ddev->current_write_client = NULL;
-		/* remove current dc from the queue */
-		status = kfifo_out(&ddev->write_queue, &curr_wc, sizeof(dc));
-		dev_dbg(&ddev->dev, "kfifo_out returned %d\n", status);
-
-		/* set new dal client as current,
-		 * if fifo empty current writer wont change
-		 */
-		status = kfifo_out_peek(&ddev->write_queue,
-					&ddev->current_write_client,
-					sizeof(dc));
-		dev_dbg(&ddev->dev, "kfifo_out_peek returned %d\n", status);
+out:
+	dev_dbg(&ddev->dev, "removing CURRENT_WRITER\n");
+	/* init current to NULL */
+	ddev->current_write_client = NULL;
+	/* remove current dc from the queue */
+	status = kfifo_out(&ddev->write_queue, &curr_wc, sizeof(dc));
+	dev_dbg(&ddev->dev, "kfifo_out returned %d\n", status);
+
+	/* set new dal client as current,
+	 * if fifo empty current writer wont change
+	 */
+	status = kfifo_out_peek(&ddev->write_queue,
+				&ddev->current_write_client,
+				sizeof(dc));
+	dev_dbg(&ddev->dev, "kfifo_out_peek returned %d\n", status);
 
-		wake_up_interruptible(&ddev->wq);
-	}
+	wake_up_interruptible(&ddev->wq);
 
+write_more:
 	mutex_unlock(&ddev->context_lock);
 
 	return ret;
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 4b30947..d919727 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -145,7 +145,7 @@ struct dal_bh_msg {
  * structures - for current client in write function
  * @rd_wq: a wait queue, for synchronizing requests in a FIFO manner
  * @clients: the clients on this device ( userspace or kernel ).
- * @num_user_space_clients: ttrack the number of times the device file has
+ * @num_user_space_clients: track the number of times the device file has
  * been opened
  * @bh_fw_msg: a struct represent msg kdi receive from the FW.
  * @current_write_client: stores the current client being served,
@@ -171,7 +171,6 @@ struct dal_device {
 	struct dal_client *current_read_client;
 
 	struct mei_cl_device *cldev;
-	bool is_write_pending;
 
 	bool is_device_removed;
 
-- 
1.7.5.4

