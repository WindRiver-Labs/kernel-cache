From 9dd3d79ecbbc58b9e3ae5a8fc401f769582e369c Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Wed, 10 Feb 2016 18:39:11 -0800
Subject: [PATCH 4404/4706] drm: Add infrastructure for CRTC background color
 property (v2)

commit 956100baf6657e2c2fc321c1325ea7e770292e52 from
git://git.yoctoproject.org/linux-yocto-4.1

To support CRTC background color, we need a way of communicating RGB
color values to the DRM.  However there is often a mismatch between how
userspace wants to represent the color value vs how it must be
programmed into the hardware; this mismatch can easily lead to
non-obvious bugs.  Let's create a kernel-side property type that
standardizes the user<->kernel format and add some macros that allow
drivers to extract the bits they care about without having to worry
about the internal representation.  This RGBA property type may also be
useful for future properties like color keys.

These properties are still exposed to userspace as range properties, so
the only userspace change we need are some helpers to build RGBA values
appropriately.

v2:
 - Just use 'struct rgba' rather than a typedef as our opaque RGBA
   datatype. (Emil)
 - Actually use drm_property_create_rgba() to create the background
   color property. (Bob)
 - Add helper to build 64-bit RGBA internal value in appropriate format
   (e.g., for the initial value when attaching a property).  (Bob)

Cc: dri-devel@lists.freedesktop.org
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
Reviewed-by: Bob Paauwe <bob.j.paauwe@intel.com>
---
 drivers/gpu/drm/drm_atomic.c   |    4 ++
 drivers/gpu/drm/drm_blend.c    |   15 +++++++
 drivers/gpu/drm/drm_property.c |   24 +++++++++++
 include/drm/drm_blend.h        |   87 ++++++++++++++++++++++++++++++++++++++++
 include/drm/drm_crtc.h         |   10 +++++
 include/drm/drm_property.h     |    2 +
 6 files changed, 142 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c
index e6862a7..70fdc18 100644
--- a/drivers/gpu/drm/drm_atomic.c
+++ b/drivers/gpu/drm/drm_atomic.c
@@ -466,6 +466,8 @@ int drm_atomic_crtc_set_property(struct drm_crtc *crtc,
 
 	if (property == config->prop_active)
 		state->active = val;
+	else if (property == config->prop_background_color)
+		state->background_color.v = val;
 	else if (property == config->prop_mode_id) {
 		struct drm_property_blob *mode =
 			drm_property_lookup_blob(dev, val);
@@ -538,6 +540,8 @@ drm_atomic_crtc_get_property(struct drm_crtc *crtc,
 		*val = (state->ctm) ? state->ctm->base.id : 0;
 	else if (property == config->gamma_lut_property)
 		*val = (state->gamma_lut) ? state->gamma_lut->base.id : 0;
+	else if (property == config->prop_background_color)
+		*val = state->background_color.v;
 	else if (crtc->funcs->atomic_get_property)
 		return crtc->funcs->atomic_get_property(crtc, state, property, val);
 	else
diff --git a/drivers/gpu/drm/drm_blend.c b/drivers/gpu/drm/drm_blend.c
index 85172a9..9cf3b91 100644
--- a/drivers/gpu/drm/drm_blend.c
+++ b/drivers/gpu/drm/drm_blend.c
@@ -194,6 +194,21 @@ unsigned int drm_rotation_simplify(unsigned int rotation,
 EXPORT_SYMBOL(drm_rotation_simplify);
 
 /**
+ * drm_mode_create_background_color_property - create CRTC color property
+ * @dev: DRM device
+ *
+ * Creates a property to represent CRTC background/canvas color.  Called by a
+ * driver the first time it's needed, must be attached to desired CRTC's.
+ */
+struct drm_property *
+drm_mode_create_background_color_property(struct drm_device *dev)
+{
+	return drm_property_create_rgba(dev, DRM_MODE_PROP_ATOMIC,
+					"background_color");
+}
+EXPORT_SYMBOL(drm_mode_create_background_color_property);
+
+/**
  * drm_plane_create_zpos_property - create mutable zpos property
  * @plane: drm plane
  * @zpos: initial value of zpos property
diff --git a/drivers/gpu/drm/drm_property.c b/drivers/gpu/drm/drm_property.c
index a4d81cf..7c52832 100644
--- a/drivers/gpu/drm/drm_property.c
+++ b/drivers/gpu/drm/drm_property.c
@@ -355,6 +355,30 @@ struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
 EXPORT_SYMBOL(drm_property_create_bool);
 
 /**
+ * drm_property_create_rgba - create a new RGBA property type
+ * @dev: drm device
+ * @flags: flags specifying the property type
+ * @name: name of the property
+ *
+ * This creates a new generic drm property which can then be attached to a drm
+ * object with drm_object_attach_property. The returned property object must be
+ * freed with drm_property_destroy.
+ *
+ * Userspace should use the DRM_RGBA() macro to build values with the proper
+ * bit layout.
+ *
+ * Returns:
+ * A pointer to the newly created property on success, NULL on failure.
+ */
+struct drm_property *drm_property_create_rgba(struct drm_device *dev, int flags,
+					      const char *name)
+{
+	return drm_property_create_range(dev, flags, name,
+					 0, GENMASK_ULL(63, 0));
+}
+EXPORT_SYMBOL(drm_property_create_rgba);
+
+/**
  * drm_property_add_enum - add a possible value to an enumeration property
  * @property: enumeration property to change
  * @index: index of the new enumeration
diff --git a/include/drm/drm_blend.h b/include/drm/drm_blend.h
index 36baa17..1f23dcb 100644
--- a/include/drm/drm_blend.h
+++ b/include/drm/drm_blend.h
@@ -29,6 +29,25 @@
 struct drm_device;
 struct drm_atomic_state;
 
+/**
+ * struct drm_rgba - RGBA property value type
+ * @v: Internal representation of RGBA, stored in 16bpc format
+ *
+ * Structure to abstract away the representation of RGBA values with precision
+ * up to 16 bits per color component.  This is primarily intended for use with
+ * DRM properties that need to take a color value since we don't want userspace
+ * to have to worry about the bit layout expected by the underlying hardware.
+ *
+ * We wrap the value in a structure here so that the compiler will flag any
+ * accidental attempts by driver code to directly attempt bitwise operations
+ * that could potentially misinterpret the value.  Drivers should instead use
+ * the DRM_RGBA_{RED,GREEN,BLUE,ALPHA}BITS() macros to obtain the component
+ * bits and then build values in the format their hardware expects.
+ */
+struct drm_rgba {
+	uint64_t v;
+};
+
 /*
  * Rotation property bits. DRM_ROTATE_<degrees> rotates the image by the
  * specified amount in degrees in counter clockwise direction. DRM_REFLECT_X and
@@ -52,6 +71,8 @@ struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
 unsigned int drm_rotation_simplify(unsigned int rotation,
 				   unsigned int supported_rotations);
 
+struct drm_property *drm_mode_create_background_color_property(struct drm_device *dev);
+
 int drm_plane_create_zpos_property(struct drm_plane *plane,
 				   unsigned int zpos,
 				   unsigned int min, unsigned int max);
@@ -59,4 +80,70 @@ int drm_plane_create_zpos_immutable_property(struct drm_plane *plane,
 					     unsigned int zpos);
 int drm_atomic_normalize_zpos(struct drm_device *dev,
 			      struct drm_atomic_state *state);
+
+/**
+ * drm_rgba - Build RGBA property values
+ * @bpc: Bits per component value for @red, @green, @blue, and @alpha parameters
+ * @red: Red component value
+ * @green: Green component value
+ * @blue: Blue component value
+ * @alpha: Alpha component value
+ *
+ * Helper to build RGBA 16bpc color values with the bits laid out in the format
+ * expected by DRM RGBA properties.
+ *
+ * Returns:
+ * An RGBA structure encapsulating the requested RGBA value.
+ */
+static inline struct drm_rgba
+drm_rgba(unsigned bpc,
+	 uint16_t red,
+	 uint16_t green,
+	 uint16_t blue,
+	 uint16_t alpha)
+{
+	int shift;
+	struct drm_rgba val;
+
+	if (WARN_ON(bpc > 16))
+		bpc = 16;
+
+	/*
+	 * If we were provided with fewer than 16 bpc, shift the value we
+	 * received into the most significant bits.
+	 */
+	shift = 16 - bpc;
+
+	val.v = red << shift;
+	val.v <<= 16;
+	val.v |= green << shift;
+	val.v <<= 16;
+	val.v |= blue << shift;
+	val.v <<= 16;
+	val.v |= alpha << shift;
+
+	return val;
+}
+
+static inline uint16_t
+drm_rgba_bits(struct drm_rgba c, unsigned compshift, unsigned bits) {
+	uint64_t val;
+
+	if (WARN_ON(bits > 16))
+		bits = 16;
+
+	val = c.v & GENMASK_ULL(compshift + 15, compshift);
+	return val >> (compshift + 16 - bits);
+}
+
+/*
+ * Macros to access the individual color components of an RGBA property value.
+ * If the requested number of bits is less than 16, only the most significant
+ * bits of the color component will be returned.
+ */
+#define DRM_RGBA_REDBITS(c, bits)   drm_rgba_bits(c, 48, bits)
+#define DRM_RGBA_GREENBITS(c, bits) drm_rgba_bits(c, 32, bits)
+#define DRM_RGBA_BLUEBITS(c, bits)  drm_rgba_bits(c, 16, bits)
+#define DRM_RGBA_ALPHABITS(c, bits) drm_rgba_bits(c, 0, bits)
+
 #endif
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 555afdc..9efec24 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -109,6 +109,7 @@ struct drm_plane_helper_funcs;
  * @ctm: Transformation matrix
  * @gamma_lut: Lookup table for converting pixel data after the
  *	conversion matrix
+ * @background_color: background/canvas color of regions not covered by planes
  * @state: backpointer to global drm_atomic_state
  *
  * Note that the distinction between @enable and @active is rather subtile:
@@ -197,6 +198,10 @@ struct drm_crtc_state {
 	 * for a detailed discussion of the constraints it needs to be used
 	 * safely.
 	 */
+
+	/* CRTC background color */
+	struct drm_rgba background_color;
+
 	struct drm_pending_vblank_event *event;
 
 	struct drm_atomic_state *state;
@@ -1178,6 +1183,11 @@ struct drm_mode_config {
 	struct drm_property *prop_mode_id;
 
 	/**
+	 * @prop_background_color: RGBA background color for CRTC.
+	 */
+	struct drm_property *prop_background_color;
+
+	/**
 	 * @dvi_i_subconnector_property: Optional DVI-I property to
 	 * differentiate between analog or digital mode.
 	 */
diff --git a/include/drm/drm_property.h b/include/drm/drm_property.h
index 43c4b6a..ae6ddfb 100644
--- a/include/drm/drm_property.h
+++ b/include/drm/drm_property.h
@@ -259,6 +259,8 @@ struct drm_property *drm_property_create_object(struct drm_device *dev,
 						int flags, const char *name, uint32_t type);
 struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
 					      const char *name);
+struct drm_property *drm_property_create_rgba(struct drm_device *dev, int flags,
+					      const char *name);
 int drm_property_add_enum(struct drm_property *property, int index,
 			  uint64_t value, const char *name);
 void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
-- 
1.7.5.4

