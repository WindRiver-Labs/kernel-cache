From f0f1c26818d3dabf6e9537884d2ee393aedc67c6 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 2 Jun 2016 17:39:14 +0200
Subject: [PATCH 3217/4706] drm/atomic-docs: Spelling fixups

commit 60c9e19003763cf2f234f30411c7bafa82dd1c65 upstream

Eric nicely pointed these out, but I failed at git add and lost them.
This fixes up

commit 2f196b7c4b82eeff3574eb2999e78add33ef4361
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jun 2 16:21:44 2016 +0200

    drm/atomic: Add drm_atomic_crtc_state_for_each_plane_state

to actually do what it says on the tin^Wcommit message.

Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
---
 include/drm/drm_atomic.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h
index d9504df..d12cfb9 100644
--- a/include/drm/drm_atomic.h
+++ b/include/drm/drm_atomic.h
@@ -124,9 +124,9 @@ drm_atomic_get_existing_connector_state(struct drm_atomic_state *state,
  *
  * Note that this function is in general unsafe since it doesn't check for the
  * required locking for access state structures. Drivers must ensure that it is
- * save to access the returned state structure through other means. One commone
+ * safe to access the returned state structure through other means. One common
  * example is when planes are fixed to a single CRTC, and the driver knows that
- * the CRTC locks is held already. In that case holding the CRTC locks gives a
+ * the CRTC lock is held already. In that case holding the CRTC lock gives a
  * read-lock on all planes connected to that CRTC. But if planes can be
  * reassigned things get more tricky. In that case it's better to use
  * drm_atomic_get_plane_state and wire up full error handling.
-- 
1.7.5.4

