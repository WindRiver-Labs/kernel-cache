From 81793e2170a19690a015bc5803204e2fc3af2e6c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 13 May 2016 23:41:35 +0300
Subject: [PATCH 3253/4706] drm/i915: Store BXT DE PLL vco and ref clocks in
 dev_priv
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 83d7c81f6a6a28b7c3f3512b1d09d37593aaa43b upstream

We have need to know the DE PLL refclk and output frequency in various
cdclk calculations, so let's store those in dev_priv.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1463172100-24715-17-git-send-email-ville.syrjala@linux.intel.com
Reviewed-by: Imre Deak <imre.deak@intel.com>
---
 drivers/gpu/drm/i915/intel_display.c |   27 ++++++++++++++++++++++++++-
 1 files changed, 26 insertions(+), 1 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 053ae64..d1e02ac 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -5334,7 +5334,7 @@ static void intel_update_cdclk(struct drm_device *dev)
 
 	dev_priv->cdclk_freq = dev_priv->display.get_display_clock_speed(dev);
 
-	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
+	if (INTEL_GEN(dev_priv) >= 9)
 		DRM_DEBUG_DRIVER("Current CD clock rate: %d kHz, VCO: %d kHz, ref: %d kHz\n",
 				 dev_priv->cdclk_freq, dev_priv->cdclk_pll.vco,
 				 dev_priv->cdclk_pll.ref);
@@ -5365,6 +5365,8 @@ static void bxt_de_pll_disable(struct drm_i915_private *dev_priv)
 	/* Timeout 200us */
 	if (wait_for((I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK) == 0, 1))
 		DRM_ERROR("timeout waiting for DE PLL unlock\n");
+
+	dev_priv->cdclk_pll.vco = 0;
 }
 
 static void bxt_de_pll_enable(struct drm_i915_private *dev_priv, u32 ratio)
@@ -5381,6 +5383,8 @@ static void bxt_de_pll_enable(struct drm_i915_private *dev_priv, u32 ratio)
 	/* Timeout 200us */
 	if (wait_for((I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK) != 0, 1))
 		DRM_ERROR("timeout waiting for DE PLL lock\n");
+
+	dev_priv->cdclk_pll.vco = ratio * dev_priv->cdclk_pll.ref;
 }
 
 static void broxton_set_cdclk(struct drm_i915_private *dev_priv, int cdclk)
@@ -6697,6 +6701,25 @@ static int skylake_get_display_clock_speed(struct drm_device *dev)
 	return dev_priv->cdclk_pll.ref;
 }
 
+static void bxt_de_pll_update(struct drm_i915_private *dev_priv)
+{
+	u32 val;
+
+	dev_priv->cdclk_pll.ref = 19200;
+
+	val = I915_READ(BXT_DE_PLL_ENABLE);
+	if ((val & BXT_DE_PLL_PLL_ENABLE) == 0) {
+		dev_priv->cdclk_pll.vco = 0;
+		return;
+	}
+
+	WARN_ON((val & BXT_DE_PLL_LOCK) == 0);
+
+	val = I915_READ(BXT_DE_PLL_CTL);
+	dev_priv->cdclk_pll.vco = (val & BXT_DE_PLL_RATIO_MASK) *
+		dev_priv->cdclk_pll.ref;
+}
+
 static int broxton_get_display_clock_speed(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
@@ -6705,6 +6728,8 @@ static int broxton_get_display_clock_speed(struct drm_device *dev)
 	uint32_t pll_enab = I915_READ(BXT_DE_PLL_ENABLE);
 	int cdclk;
 
+	bxt_de_pll_update(dev_priv);
+
 	if (!(pll_enab & BXT_DE_PLL_PLL_ENABLE))
 		return 19200;
 
-- 
1.7.5.4

