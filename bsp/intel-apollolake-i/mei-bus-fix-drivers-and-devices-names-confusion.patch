From a5dd269fbbcd156684c54889de20804345155760 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Thu, 23 Jul 2015 15:08:33 +0300
Subject: [PATCH 2343/2508] mei: bus: fix drivers and devices names confusion

commit b37719c31f8448ba36abc218a96663b4a6c66eb6 upstream

In the mei bus layer there is use of different variables
of driver and device types with no clear naming convention.
There are generic struct device and struct driver,
then mei_cl_{device, driver}, and finally mei_device which
in this context serves as a bus device.

The patch sets following naming convention:

the variables of type struct device remains dev
the variables of type struct driver remains drv
the variables of type struct mei_cl_device are now cldev
the variables of type struct mei_cl_driver are now cldrv
the variables of type struct mei_device are now bus, in bus
layer context

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/misc/mei/bus.c     |  260 ++++++++++++++++++++++----------------------
 drivers/misc/mei/mei_dev.h |   12 +-
 drivers/misc/mei/nfc.c     |   80 +++++++-------
 3 files changed, 176 insertions(+), 176 deletions(-)

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 458aa5a..18c37af 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -32,22 +32,22 @@
 
 static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 	const struct mei_cl_device_id *id;
 	const uuid_le *uuid;
 	const char *name;
 
-	if (!device)
+	if (!cldev)
 		return 0;
 
-	uuid = mei_me_cl_uuid(device->me_cl);
-	name = device->name;
+	uuid = mei_me_cl_uuid(cldev->me_cl);
+	name = cldev->name;
 
-	if (!driver || !driver->id_table)
+	if (!cldrv || !cldrv->id_table)
 		return 0;
 
-	id = driver->id_table;
+	id = cldrv->id_table;
 
 	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 
@@ -68,54 +68,54 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 
 static int mei_cl_device_probe(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
 	struct mei_cl_device_id id;
 
-	if (!device)
+	if (!cldev)
 		return 0;
 
-	driver = to_mei_cl_driver(dev->driver);
-	if (!driver || !driver->probe)
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv || !cldrv->probe)
 		return -ENODEV;
 
 	dev_dbg(dev, "Device probe\n");
 
-	strlcpy(id.name, device->name, sizeof(id.name));
+	strlcpy(id.name, cldev->name, sizeof(id.name));
 
-	return driver->probe(device, &id);
+	return cldrv->probe(cldev, &id);
 }
 
 static int mei_cl_device_remove(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
 
-	if (!device || !dev->driver)
+	if (!cldev || !dev->driver)
 		return 0;
 
-	if (device->event_cb) {
-		device->event_cb = NULL;
-		cancel_work_sync(&device->event_work);
+	if (cldev->event_cb) {
+		cldev->event_cb = NULL;
+		cancel_work_sync(&cldev->event_work);
 	}
 
-	driver = to_mei_cl_driver(dev->driver);
-	if (!driver->remove) {
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv->remove) {
 		dev->driver = NULL;
 
 		return 0;
 	}
 
-	return driver->remove(device);
+	return cldrv->remove(cldev);
 }
 
 static ssize_t name_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "%s", device->name);
+	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -124,8 +124,8 @@ static DEVICE_ATTR_RO(name);
 static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	size_t len;
 
 	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
@@ -137,12 +137,12 @@ static DEVICE_ATTR_RO(uuid);
 static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	size_t len;
 
 	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
-		device->name, MEI_CL_UUID_ARGS(uuid->b));
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -158,17 +158,17 @@ ATTRIBUTE_GROUPS(mei_cl_dev);
 
 static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 
 	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MEI_CL_NAME=%s", device->name))
+	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
 		return -ENOMEM;
 
 	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
-		device->name, MEI_CL_UUID_ARGS(uuid->b)))
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
 		return -ENOMEM;
 
 	return 0;
@@ -185,121 +185,121 @@ static struct bus_type mei_cl_bus_type = {
 
 static void mei_cl_dev_release(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 
-	if (!device)
+	if (!cldev)
 		return;
 
-	mei_me_cl_put(device->me_cl);
-	kfree(device);
+	mei_me_cl_put(cldev->me_cl);
+	kfree(cldev);
 }
 
 static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
 					 uuid_le uuid)
 {
 	struct mei_cl *cl;
 
-	list_for_each_entry(cl, &dev->device_list, device_link) {
-		if (cl->device && cl->device->me_cl &&
-		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->device->me_cl)))
+	list_for_each_entry(cl, &bus->device_list, device_link) {
+		if (cl->cldev && cl->cldev->me_cl &&
+		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
 			return cl;
 	}
 
 	return NULL;
 }
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
+struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
 					char *name)
 {
-	struct mei_cl_device *device;
+	struct mei_cl_device *cldev;
 	int status;
 
-	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
-	if (!device)
+	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!cldev)
 		return NULL;
 
-	device->me_cl = mei_me_cl_get(me_cl);
-	if (!device->me_cl) {
-		kfree(device);
+	cldev->me_cl = mei_me_cl_get(me_cl);
+	if (!cldev->me_cl) {
+		kfree(cldev);
 		return NULL;
 	}
 
-	device->cl = cl;
-	device->dev.parent = dev->dev;
-	device->dev.bus = &mei_cl_bus_type;
-	device->dev.type = &mei_cl_device_type;
+	cldev->cl = cl;
+	cldev->dev.parent = bus->dev;
+	cldev->dev.bus = &mei_cl_bus_type;
+	cldev->dev.type = &mei_cl_device_type;
 
-	strlcpy(device->name, name, sizeof(device->name));
+	strlcpy(cldev->name, name, sizeof(cldev->name));
 
-	dev_set_name(&device->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
+	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
 
-	status = device_register(&device->dev);
+	status = device_register(&cldev->dev);
 	if (status) {
-		dev_err(dev->dev, "Failed to register MEI device\n");
-		mei_me_cl_put(device->me_cl);
-		kfree(device);
+		dev_err(bus->dev, "Failed to register MEI device\n");
+		mei_me_cl_put(cldev->me_cl);
+		kfree(cldev);
 		return NULL;
 	}
 
-	cl->device = device;
+	cl->cldev = cldev;
 
-	dev_dbg(&device->dev, "client %s registered\n", name);
+	dev_dbg(&cldev->dev, "client %s registered\n", name);
 
-	return device;
+	return cldev;
 }
 EXPORT_SYMBOL_GPL(mei_cl_add_device);
 
-void mei_cl_remove_device(struct mei_cl_device *device)
+void mei_cl_remove_device(struct mei_cl_device *cldev)
 {
-	device_unregister(&device->dev);
+	device_unregister(&cldev->dev);
 }
 EXPORT_SYMBOL_GPL(mei_cl_remove_device);
 
-int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
+int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 {
 	int err;
 
-	driver->driver.name = driver->name;
-	driver->driver.owner = owner;
-	driver->driver.bus = &mei_cl_bus_type;
+	cldrv->driver.name = cldrv->name;
+	cldrv->driver.owner = owner;
+	cldrv->driver.bus = &mei_cl_bus_type;
 
-	err = driver_register(&driver->driver);
+	err = driver_register(&cldrv->driver);
 	if (err)
 		return err;
 
-	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
+	pr_debug("mei: driver [%s] registered\n", cldrv->driver.name);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
 
-void mei_cl_driver_unregister(struct mei_cl_driver *driver)
+void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
 {
-	driver_unregister(&driver->driver);
+	driver_unregister(&cldrv->driver);
 
-	pr_debug("mei: driver [%s] unregistered\n", driver->driver.name);
+	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
 ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl_cb *cb = NULL;
 	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 	if (!mei_cl_is_connected(cl)) {
 		rets = -ENODEV;
 		goto out;
@@ -327,7 +327,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	rets = mei_cl_write(cl, cb, blocking);
 
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 	if (rets < 0)
 		mei_io_cb_free(cb);
 
@@ -336,7 +336,7 @@ out:
 
 ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl_cb *cb;
 	size_t r_length;
 	ssize_t rets;
@@ -344,9 +344,9 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	cb = mei_cl_read_cb(cl, NULL);
 	if (cb)
@@ -358,7 +358,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 
-		mutex_unlock(&dev->device_lock);
+		mutex_unlock(&bus->device_lock);
 
 		if (wait_event_interruptible(cl->rx_wait,
 				(!list_empty(&cl->rd_completed)) ||
@@ -369,7 +369,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 			return -ERESTARTSYS;
 		}
 
-		mutex_lock(&dev->device_lock);
+		mutex_lock(&bus->device_lock);
 
 		if (!mei_cl_is_connected(cl)) {
 			rets = -EBUSY;
@@ -396,14 +396,14 @@ copy:
 free:
 	mei_io_cb_free(cb);
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
 	return rets;
 }
 
-ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = device->cl;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
@@ -412,9 +412,9 @@ ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 }
 EXPORT_SYMBOL_GPL(mei_cl_send);
 
-ssize_t mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = device->cl;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
@@ -425,108 +425,108 @@ EXPORT_SYMBOL_GPL(mei_cl_recv);
 
 static void mei_bus_event_work(struct work_struct *work)
 {
-	struct mei_cl_device *device;
+	struct mei_cl_device *cldev;
 
-	device = container_of(work, struct mei_cl_device, event_work);
+	cldev = container_of(work, struct mei_cl_device, event_work);
 
-	if (device->event_cb)
-		device->event_cb(device, device->events, device->event_context);
+	if (cldev->event_cb)
+		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 
-	device->events = 0;
+	cldev->events = 0;
 
 	/* Prepare for the next read */
-	mei_cl_read_start(device->cl, 0, NULL);
+	mei_cl_read_start(cldev->cl, 0, NULL);
 }
 
-int mei_cl_register_event_cb(struct mei_cl_device *device,
+int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 			  mei_cl_event_cb_t event_cb, void *context)
 {
-	if (device->event_cb)
+	if (cldev->event_cb)
 		return -EALREADY;
 
-	device->events = 0;
-	device->event_cb = event_cb;
-	device->event_context = context;
-	INIT_WORK(&device->event_work, mei_bus_event_work);
+	cldev->events = 0;
+	cldev->event_cb = event_cb;
+	cldev->event_context = context;
+	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 
-	mei_cl_read_start(device->cl, 0, NULL);
+	mei_cl_read_start(cldev->cl, 0, NULL);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 
-void *mei_cl_get_drvdata(const struct mei_cl_device *device)
+void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
 {
-	return dev_get_drvdata(&device->dev);
+	return dev_get_drvdata(&cldev->dev);
 }
 EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 
-void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
+void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
 {
-	dev_set_drvdata(&device->dev, data);
+	dev_set_drvdata(&cldev->dev, data);
 }
 EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
-int mei_cl_enable_device(struct mei_cl_device *device)
+int mei_cl_enable_device(struct mei_cl_device *cldev)
 {
 	int err;
-	struct mei_device *dev;
-	struct mei_cl *cl = device->cl;
+	struct mei_device *bus;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	if (mei_cl_is_connected(cl)) {
-		mutex_unlock(&dev->device_lock);
-		dev_warn(dev->dev, "Already connected");
+		mutex_unlock(&bus->device_lock);
+		dev_warn(bus->dev, "Already connected");
 		return -EBUSY;
 	}
 
-	err = mei_cl_connect(cl, device->me_cl, NULL);
+	err = mei_cl_connect(cl, cldev->me_cl, NULL);
 	if (err < 0) {
-		mutex_unlock(&dev->device_lock);
-		dev_err(dev->dev, "Could not connect to the ME client");
+		mutex_unlock(&bus->device_lock);
+		dev_err(bus->dev, "Could not connect to the ME client");
 
 		return err;
 	}
 
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
-	if (device->event_cb)
-		mei_cl_read_start(device->cl, 0, NULL);
+	if (cldev->event_cb)
+		mei_cl_read_start(cldev->cl, 0, NULL);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 
-int mei_cl_disable_device(struct mei_cl_device *device)
+int mei_cl_disable_device(struct mei_cl_device *cldev)
 {
 	int err;
-	struct mei_device *dev;
-	struct mei_cl *cl = device->cl;
+	struct mei_device *bus;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	device->event_cb = NULL;
+	cldev->event_cb = NULL;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
-		dev_err(dev->dev, "Already disconnected");
+		dev_err(bus->dev, "Already disconnected");
 		err = 0;
 		goto out;
 	}
 
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
-		dev_err(dev->dev, "Could not disconnect from the ME client");
+		dev_err(bus->dev, "Could not disconnect from the ME client");
 		goto out;
 	}
 
@@ -534,7 +534,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 	mei_cl_flush_queues(cl, NULL);
 
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 	return err;
 
 }
@@ -542,14 +542,14 @@ EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 
 void mei_cl_bus_rx_event(struct mei_cl *cl)
 {
-	struct mei_cl_device *device = cl->device;
+	struct mei_cl_device *cldev = cl->cldev;
 
-	if (!device || !device->event_cb)
+	if (!cldev || !cldev->event_cb)
 		return;
 
-	set_bit(MEI_CL_EVENT_RX, &device->events);
+	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 
-	schedule_work(&device->event_work);
+	schedule_work(&cldev->event_work);
 }
 
 int __init mei_cl_bus_init(void)
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 453f6a3..bc65fb4 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -240,7 +240,7 @@ struct mei_cl_cb {
  * @rd_pending: pending read credits
  * @rd_completed: completed read
  *
- * @device: device on the mei client bus
+ * @cldev: device on the mei client bus
  * @device_link:  link to bus clients
  */
 struct mei_cl {
@@ -261,7 +261,7 @@ struct mei_cl {
 	struct list_head rd_completed;
 
 	/* MEI CL bus data */
-	struct mei_cl_device *device;
+	struct mei_cl_device *cldev;
 	struct list_head device_link;
 };
 
@@ -330,20 +330,20 @@ struct mei_hw_ops {
 
 /* MEI bus API*/
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
+struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
 					char *name);
-void mei_cl_remove_device(struct mei_cl_device *device);
+void mei_cl_remove_device(struct mei_cl_device *cldev);
 
 ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking);
 ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
 void mei_cl_bus_rx_event(struct mei_cl *cl);
-void mei_cl_bus_remove_devices(struct mei_device *dev);
+void mei_cl_bus_remove_devices(struct mei_device *bus);
 int mei_cl_bus_init(void);
 void mei_cl_bus_exit(void);
-struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev, uuid_le uuid);
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus, uuid_le uuid);
 
 /**
  * enum mei_pg_event - power gating transition events
diff --git a/drivers/misc/mei/nfc.c b/drivers/misc/mei/nfc.c
index 290ef30..47aa152 100644
--- a/drivers/misc/mei/nfc.c
+++ b/drivers/misc/mei/nfc.c
@@ -152,12 +152,12 @@ static void mei_nfc_free(struct mei_nfc_dev *ndev)
 
 static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 
 	if (!ndev->cl)
 		return -ENODEV;
 
-	dev = ndev->cl->dev;
+	bus = ndev->cl->dev;
 
 	switch (ndev->vendor_id) {
 	case MEI_NFC_VENDOR_INSIDE:
@@ -167,7 +167,7 @@ static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
 			return 0;
 
 		default:
-			dev_err(dev->dev, "Unknown radio type 0x%x\n",
+			dev_err(bus->dev, "Unknown radio type 0x%x\n",
 				ndev->radio_type);
 
 			return -EINVAL;
@@ -179,14 +179,14 @@ static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
 			ndev->bus_name = "pn544";
 			return 0;
 		default:
-			dev_err(dev->dev, "Unknown radio type 0x%x\n",
+			dev_err(bus->dev, "Unknown radio type 0x%x\n",
 				ndev->radio_type);
 
 			return -EINVAL;
 		}
 
 	default:
-		dev_err(dev->dev, "Unknown vendor ID 0x%x\n",
+		dev_err(bus->dev, "Unknown vendor ID 0x%x\n",
 			ndev->vendor_id);
 
 		return -EINVAL;
@@ -197,7 +197,7 @@ static int mei_nfc_build_bus_name(struct mei_nfc_dev *ndev)
 
 static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl *cl;
 
 	struct mei_nfc_cmd cmd;
@@ -207,7 +207,7 @@ static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 	int bytes_recv, ret;
 
 	cl = ndev->cl_info;
-	dev = cl->dev;
+	bus = cl->dev;
 
 	memset(&cmd, 0, sizeof(struct mei_nfc_cmd));
 	cmd.command = MEI_NFC_CMD_MAINTENANCE;
@@ -216,7 +216,7 @@ static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 
 	ret = __mei_cl_send(cl, (u8 *)&cmd, sizeof(struct mei_nfc_cmd), 1);
 	if (ret < 0) {
-		dev_err(dev->dev, "Could not send IF version cmd\n");
+		dev_err(bus->dev, "Could not send IF version cmd\n");
 		return ret;
 	}
 
@@ -230,7 +230,7 @@ static int mei_nfc_if_version(struct mei_nfc_dev *ndev)
 
 	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length);
 	if (bytes_recv < 0 || bytes_recv < sizeof(struct mei_nfc_reply)) {
-		dev_err(dev->dev, "Could not read IF version\n");
+		dev_err(bus->dev, "Could not read IF version\n");
 		ret = -EIO;
 		goto err;
 	}
@@ -248,7 +248,7 @@ err:
 
 static void mei_nfc_init(struct work_struct *work)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl_device *cldev;
 	struct mei_nfc_dev *ndev;
 	struct mei_cl *cl_info;
@@ -257,57 +257,57 @@ static void mei_nfc_init(struct work_struct *work)
 	ndev = container_of(work, struct mei_nfc_dev, init_work);
 
 	cl_info = ndev->cl_info;
-	dev = cl_info->dev;
+	bus = cl_info->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	/* check for valid client id */
-	me_cl_info = mei_me_cl_by_uuid(dev, &mei_nfc_info_guid);
+	me_cl_info = mei_me_cl_by_uuid(bus, &mei_nfc_info_guid);
 	if (!me_cl_info) {
-		mutex_unlock(&dev->device_lock);
-		dev_info(dev->dev, "nfc: failed to find the info client\n");
+		mutex_unlock(&bus->device_lock);
+		dev_info(bus->dev, "nfc: failed to find the info client\n");
 		goto err;
 	}
 
 	if (mei_cl_connect(cl_info, me_cl_info, NULL) < 0) {
 		mei_me_cl_put(me_cl_info);
-		mutex_unlock(&dev->device_lock);
-		dev_err(dev->dev, "Could not connect to the NFC INFO ME client");
+		mutex_unlock(&bus->device_lock);
+		dev_err(bus->dev, "Could not connect to the NFC INFO ME client");
 
 		goto err;
 	}
 	mei_me_cl_put(me_cl_info);
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
 	if (mei_nfc_if_version(ndev) < 0) {
-		dev_err(dev->dev, "Could not get the NFC interface version");
+		dev_err(bus->dev, "Could not get the NFC interface version");
 
 		goto err;
 	}
 
-	dev_info(dev->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
+	dev_info(bus->dev, "NFC MEI VERSION: IVN 0x%x Vendor ID 0x%x Type 0x%x\n",
 		ndev->fw_ivn, ndev->vendor_id, ndev->radio_type);
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	if (mei_cl_disconnect(cl_info) < 0) {
-		mutex_unlock(&dev->device_lock);
-		dev_err(dev->dev, "Could not disconnect the NFC INFO ME client");
+		mutex_unlock(&bus->device_lock);
+		dev_err(bus->dev, "Could not disconnect the NFC INFO ME client");
 
 		goto err;
 	}
 
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
 	if (mei_nfc_build_bus_name(ndev) < 0) {
-		dev_err(dev->dev, "Could not build the bus ID name\n");
+		dev_err(bus->dev, "Could not build the bus ID name\n");
 		return;
 	}
 
-	cldev = mei_cl_add_device(dev, ndev->me_cl, ndev->cl,
+	cldev = mei_cl_add_device(bus, ndev->me_cl, ndev->cl,
 				  ndev->bus_name);
 	if (!cldev) {
-		dev_err(dev->dev, "Could not add the NFC device to the MEI bus\n");
+		dev_err(bus->dev, "Could not add the NFC device to the MEI bus\n");
 
 		goto err;
 	}
@@ -318,14 +318,14 @@ static void mei_nfc_init(struct work_struct *work)
 	return;
 
 err:
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 	mei_nfc_free(ndev);
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
 }
 
 
-int mei_nfc_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
+int mei_nfc_host_init(struct mei_device *bus, struct mei_me_client *me_cl)
 {
 	struct mei_nfc_dev *ndev;
 	struct mei_cl *cl_info, *cl;
@@ -335,7 +335,7 @@ int mei_nfc_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
 	/* in case of internal reset bail out
 	 * as the device is already setup
 	 */
-	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
+	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
 	if (cl)
 		return 0;
 
@@ -351,23 +351,23 @@ int mei_nfc_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
 		goto err;
 	}
 
-	cl_info = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+	cl_info = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
 	if (IS_ERR(cl_info)) {
 		ret = PTR_ERR(cl_info);
 		goto err;
 	}
 
-	list_add_tail(&cl_info->device_link, &dev->device_list);
+	list_add_tail(&cl_info->device_link, &bus->device_list);
 
 	ndev->cl_info = cl_info;
 
-	cl = mei_cl_alloc_linked(dev, MEI_HOST_CLIENT_ID_ANY);
+	cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
 	if (IS_ERR(cl)) {
 		ret = PTR_ERR(cl);
 		goto err;
 	}
 
-	list_add_tail(&cl->device_link, &dev->device_list);
+	list_add_tail(&cl->device_link, &bus->device_list);
 
 	ndev->cl = cl;
 
@@ -382,17 +382,17 @@ err:
 	return ret;
 }
 
-void mei_nfc_host_exit(struct mei_device *dev)
+void mei_nfc_host_exit(struct mei_device *bus)
 {
 	struct mei_nfc_dev *ndev;
 	struct mei_cl *cl;
 	struct mei_cl_device *cldev;
 
-	cl = mei_cl_bus_find_cl_by_uuid(dev, mei_nfc_guid);
+	cl = mei_cl_bus_find_cl_by_uuid(bus, mei_nfc_guid);
 	if (!cl)
 		return;
 
-	cldev = cl->device;
+	cldev = cl->cldev;
 	if (!cldev)
 		return;
 
@@ -407,9 +407,9 @@ void mei_nfc_host_exit(struct mei_device *dev)
 	 */
 	mei_cl_remove_device(cldev);
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 	mei_nfc_free(ndev);
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 }
 
 
-- 
1.7.5.4

