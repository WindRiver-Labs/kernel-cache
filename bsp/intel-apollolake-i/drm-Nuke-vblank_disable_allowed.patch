From 23cf3cd98ec16dee9a6b43e5f6917d95ff1f0817 Mon Sep 17 00:00:00 2001
From: Matt Roper <matthew.d.roper@intel.com>
Date: Mon, 12 Dec 2016 15:31:26 -0800
Subject: [PATCH 2953/4706] drm: Nuke ->vblank_disable_allowed

commit 5d25eac0ec21b11be534c6b7c64db758424ac0e9 from
git://git.yoctoproject.org/linux-yocto-4.1

This was added in

commit 0a3e67a4caac273a3bfc4ced3da364830b1ab241
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Sep 30 12:14:26 2008 -0700

    drm: Rework vblank-wait handling to allow interrupt reduction.

to stay backwards-compatible with old UMS code that didn't even tell
the kernel when it did a modeset, so that the kernel could
save/restore vblank counters. At worst this means vblanks will be
somewhat funky on a setup that very likely no one still runs.

So let's just nuke it.

Plan B would be to set it unconditionally in drm_vblank_init for kms
drivers, instead of in each driver separately. So if this patch breaks
anything please only restore the hunks in drmP.h and drm_irq.c, plus
add a check for DRIVER_MODESET in drm_vblank_init.

Stumbled over this in a discussion on irc with Chris.

Cc: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Liviu Dudau <liviu.dudau@arm.com>
Cc: Russell King <rmk+kernel@arm.linux.org.uk>
Cc: Thierry Reding <thierry.reding@gmail.com>
Cc: Eric Anholt <eric@anholt.net>
Cc: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Cc: Inki Dae <inki.dae@samsung.com>
Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
Cc: Mark Yao <mark.yao@rock-chips.com>
Cc: Sascha Hauer <s.hauer@pengutronix.de>
Cc: Philipp Zabel <p.zabel@pengutronix.de>
Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Tested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit fcee59065e58498682c60069cc6fb90694bab27e)
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>

# Conflicts:
#	drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c
---
 drivers/gpu/drm/drm_irq.c       |    6 ------
 drivers/gpu/drm/i915/i915_dma.c |    3 ---
 include/drm/drmP.h              |    8 --------
 3 files changed, 0 insertions(+), 17 deletions(-)

diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c
index 3c1a6f1..0fac801 100644
--- a/drivers/gpu/drm/drm_irq.c
+++ b/drivers/gpu/drm/drm_irq.c
@@ -348,9 +348,6 @@ static void vblank_disable_fn(unsigned long arg)
 	unsigned int pipe = vblank->pipe;
 	unsigned long irqflags;
 
-	if (!dev->vblank_disable_allowed)
-		return;
-
 	spin_lock_irqsave(&dev->vbl_lock, irqflags);
 	if (atomic_read(&vblank->refcount) == 0 && vblank->enabled) {
 		DRM_DEBUG("disabling vblank on crtc %u\n", pipe);
@@ -437,8 +434,6 @@ int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs)
 			 "get_vblank_timestamp == NULL\n");
 	}
 
-	dev->vblank_disable_allowed = false;
-
 	return 0;
 
 err:
@@ -1585,7 +1580,6 @@ void drm_vblank_post_modeset(struct drm_device *dev, unsigned int pipe)
 
 	if (vblank->inmodeset) {
 		spin_lock_irqsave(&dev->vbl_lock, irqflags);
-		dev->vblank_disable_allowed = true;
 		drm_reset_vblank_timestamp(dev, pipe);
 		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
 
diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index 5c76150..15615fb 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -476,9 +476,6 @@ static int i915_load_modeset_init(struct drm_device *dev)
 
 	intel_modeset_gem_init(dev);
 
-	/* Always safe in the mode setting case. */
-	/* FIXME: do pre/post-mode set stuff in core KMS code */
-	dev->vblank_disable_allowed = true;
 	if (INTEL_INFO(dev)->num_pipes == 0)
 		return 0;
 
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index 7d025c1..d517049 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -815,14 +815,6 @@ struct drm_device {
 	int irq;
 
 	/*
-	 * At load time, disabling the vblank interrupt won't be allowed since
-	 * old clients may not call the modeset ioctl and therefore misbehave.
-	 * Once the modeset ioctl *has* been called though, we can safely
-	 * disable them when unused.
-	 */
-	bool vblank_disable_allowed;
-
-	/*
 	 * If true, vblank interrupt will be disabled immediately when the
 	 * refcount drops to zero, as opposed to via the vblank disable
 	 * timer.
-- 
1.7.5.4

