From 44001dbb97a3fe6e3bf7afec901ee75c8ab900c1 Mon Sep 17 00:00:00 2001
From: Yael Samet <yael.samet@intel.com>
Date: Wed, 11 Jan 2017 08:53:27 +0200
Subject: [PATCH 4657/4706] mei: dal: use errno for errors caused by the drive

commit 559f4655520af86adf7719a721b776aa4419a2d9 from
git://git.yoctoproject.org/linux-yocto-4.1

Use errno codes rather than custom when the error is
in the driver. Use internal error codes only when the error
came from the FW.

Change-Id: I2ad796667fcd07ac7e5ba289ea23c40d2b4b184d
Signed-off-by: Yael Samet <yael.samet@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/admin_pack_ext.c |   16 ++--
 drivers/misc/mei/dal/admin_pack_int.c |   73 +++++++++---------
 drivers/misc/mei/dal/bhp_impl.c       |   89 +++++++++++-----------
 drivers/misc/mei/dal/bhp_impl_ta.c    |   96 ++++++++++++------------
 drivers/misc/mei/dal/dal_kdi.c        |  132 +++++++++++++++------------------
 include/linux/dal.h                   |   27 +++----
 6 files changed, 209 insertions(+), 224 deletions(-)

diff --git a/drivers/misc/mei/dal/admin_pack_ext.c b/drivers/misc/mei/dal/admin_pack_ext.c
index 66a9781..79300d5 100644
--- a/drivers/misc/mei/dal/admin_pack_ext.c
+++ b/drivers/misc/mei/dal/admin_pack_ext.c
@@ -58,6 +58,7 @@
  *
  *****************************************************************************/
 #include <linux/kernel.h>
+#include <linux/errno.h>
 
 #include "bh_acp_exp.h"
 #include "bh_acp_internal.h"
@@ -70,8 +71,9 @@ static int acp_load_pack(const char *raw_pack, unsigned int size,
 	struct ac_ins_jta_pack_ext *pack_ext;
 	struct ac_ins_jta_prop_ext *prop_ext;
 
-	if (pr_init(&pr, raw_pack, size) != BH_SUCCESS)
-		return BHE_INVALID_BPK_FILE;
+	ret = pr_init(&pr, raw_pack, size);
+	if (ret)
+		return ret;
 
 	if (cmd_id != AC_INSTALL_JTA_PROP) {
 		ret = acp_load_pack_head(&pr, &pack->head);
@@ -80,7 +82,7 @@ static int acp_load_pack(const char *raw_pack, unsigned int size,
 	}
 
 	if (cmd_id != AC_INSTALL_JTA_PROP && cmd_id != pack->head->cmd_id)
-		return BHE_BAD_PARAMETER;
+		return -EINVAL;
 
 	switch (cmd_id) {
 	case AC_INSTALL_JTA:
@@ -102,11 +104,11 @@ static int acp_load_pack(const char *raw_pack, unsigned int size,
 		ret = acp_load_ta_pack(&pr, &prop_ext->jeff_pack);
 		break;
 	default:
-		return BHE_BAD_PARAMETER;
+		return -EINVAL;
 	}
 
 	if (!pr_is_end(&pr))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	return ret;
 }
@@ -117,7 +119,7 @@ int acp_pload_ins_jta(const void *raw_data, unsigned int size,
 	int ret;
 
 	if (!raw_data || size <= BH_ACP_CSS_HEADER_LENGTH || !pack)
-		return BHE_BAD_PARAMETER;
+		return -EINVAL;
 
 	ret = acp_load_pack((const char *)raw_data + BH_ACP_CSS_HEADER_LENGTH,
 			    size - BH_ACP_CSS_HEADER_LENGTH,
@@ -130,7 +132,7 @@ int acp_pload_ins_jta_prop(const void *raw_data, unsigned int size,
 			   struct ac_ins_jta_prop_ext *pack)
 {
 	if (!raw_data || !pack)
-		return BHE_BAD_PARAMETER;
+		return -EINVAL;
 
 	return acp_load_pack(raw_data, size, AC_INSTALL_JTA_PROP,
 			    (struct ac_pack *)pack);
diff --git a/drivers/misc/mei/dal/admin_pack_int.c b/drivers/misc/mei/dal/admin_pack_int.c
index 7b42cd8..4dee31e 100644
--- a/drivers/misc/mei/dal/admin_pack_int.c
+++ b/drivers/misc/mei/dal/admin_pack_int.c
@@ -67,6 +67,7 @@
 
 #include <linux/kernel.h>
 #include <linux/printk.h>
+#include <linux/errno.h>
 
 #include "bh_errcode.h"
 #include "bh_acp_format.h"
@@ -79,12 +80,12 @@ int pr_init(struct pack_reader *pr, const char *data, unsigned int n)
 {
 	/* check integer overflow */
 	if ((size_t)data > SIZE_MAX - n)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	pr->cur = data;
 	pr->head = data;
 	pr->total = n;
-	return BH_SUCCESS;
+	return 0;
 }
 
 static int pr_8b_align_move(struct pack_reader *pr, size_t n_move)
@@ -94,18 +95,18 @@ static int pr_8b_align_move(struct pack_reader *pr, size_t n_move)
 	size_t len_from_head = new_cur - pr->head;
 
 	if ((size_t)pr->cur > SIZE_MAX - n_move || new_cur < pr->head)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	offset = ((8 - (len_from_head & 7)) & 7);
 	if ((size_t)new_cur > SIZE_MAX - offset)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	new_cur = new_cur + offset;
 	if (new_cur > pr->head + pr->total)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	pr->cur = new_cur;
-	return BH_SUCCESS;
+	return 0;
 }
 
 static int pr_align_move(struct pack_reader *pr, size_t n_move)
@@ -115,18 +116,18 @@ static int pr_align_move(struct pack_reader *pr, size_t n_move)
 	size_t offset;
 
 	if ((size_t)pr->cur > SIZE_MAX - n_move || new_cur < pr->head)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	offset = ((4 - (len_from_head & 3)) & 3);
 	if ((size_t)new_cur > SIZE_MAX - offset)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	new_cur = new_cur + offset;
 	if (new_cur > pr->head + pr->total)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	pr->cur = new_cur;
-	return BH_SUCCESS;
+	return 0;
 }
 
 static int pr_move(struct pack_reader *pr, size_t n_move)
@@ -136,10 +137,10 @@ static int pr_move(struct pack_reader *pr, size_t n_move)
 	/* integer overflow or out of acp pkg size */
 	if ((size_t)pr->cur > SIZE_MAX - n_move ||
 	    new_cur > pr->head + pr->total)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	pr->cur = new_cur;
-	return BH_SUCCESS;
+	return 0;
 }
 
 static bool pr_is_safe_to_read(const struct pack_reader *pr, size_t n_move)
@@ -166,16 +167,16 @@ static int acp_load_reasons(struct pack_reader *pr,
 	struct ac_ins_reasons *r;
 
 	if (!pr_is_safe_to_read(pr, sizeof(*r)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	r = (struct ac_ins_reasons *)pr->cur;
 
 	if (r->len > BH_MAX_ACP_INS_REASONS_LENGTH)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	len = sizeof(*r) + r->len * sizeof(r->data[0]);
 	if (!pr_is_safe_to_read(pr, len))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*reasons = r;
 	return pr_align_move(pr, len);
@@ -188,16 +189,16 @@ static int acp_load_taid_list(struct pack_reader *pr,
 	struct bh_ta_id_list *t;
 
 	if (!pr_is_safe_to_read(pr, sizeof(*t)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	t = (struct bh_ta_id_list *)pr->cur;
 	if (t->num > BH_MAX_ACP_USED_SERVICES)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	len = sizeof(*t) + t->num * sizeof(t->list[0]);
 
 	if (!pr_is_safe_to_read(pr, len))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*taid_list = t;
 	return pr_align_move(pr, len);
@@ -209,16 +210,16 @@ static int acp_load_prop(struct pack_reader *pr, struct bh_prop_list **prop)
 	struct bh_prop_list *p;
 
 	if (!pr_is_safe_to_read(pr, sizeof(*p)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	p = (struct bh_prop_list *)pr->cur;
 	if (p->len > BH_MAX_ACP_PROPS_LENGTH)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	len = sizeof(*p) + p->len * sizeof(p->data[0]);
 
 	if (!pr_is_safe_to_read(pr, len))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*prop = p;
 	return pr_align_move(pr, len);
@@ -230,8 +231,8 @@ int acp_load_ta_pack(struct pack_reader *pr, char **ta_pack)
 	char *t;
 
 	/*8 byte align to obey jeff rule*/
-	if (pr_8b_align_move(pr, 0) != BH_SUCCESS)
-		return BHE_INVALID_BPK_FILE;
+	if (pr_8b_align_move(pr, 0))
+		return -EINVAL;
 
 	t = (char *)pr->cur;
 
@@ -240,11 +241,11 @@ int acp_load_ta_pack(struct pack_reader *pr, char **ta_pack)
 	 *move cursor to the end directly
 	 */
 	if (pr->cur > pr->head + pr->total)
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	len = pr->head + pr->total - pr->cur;
 	if (!pr_is_safe_to_read(pr, len))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*ta_pack = t;
 	return pr_move(pr, len);
@@ -254,7 +255,7 @@ static int acp_load_ins_jta_prop_head(struct pack_reader *pr,
 				      struct ac_ins_jta_prop_header **head)
 {
 	if (!pr_is_safe_to_read(pr, sizeof(struct ac_ins_jta_prop_header)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*head = (struct ac_ins_jta_prop_header *)pr->cur;
 	return pr_align_move(pr, sizeof(struct ac_ins_jta_prop_header));
@@ -265,23 +266,23 @@ int acp_load_ins_jta_prop(struct pack_reader *pr, struct ac_ins_jta_prop *pack)
 	int ret;
 
 	ret = acp_load_ins_jta_prop_head(pr, &pack->head);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto out;
 
 	ret = acp_load_reasons(pr, &pack->post_reasons);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto out;
 
 	ret = acp_load_reasons(pr, &pack->reg_reasons);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto out;
 
 	ret = acp_load_prop(pr, &pack->prop);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto out;
 
 	ret = acp_load_taid_list(pr, &pack->used_service_list);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 out:
@@ -292,7 +293,7 @@ static int acp_load_ins_jta_head(struct pack_reader *pr,
 				 struct ac_ins_ta_header **head)
 {
 	if (!pr_is_safe_to_read(pr, sizeof(struct ac_ins_ta_header)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*head = (struct ac_ins_ta_header *)pr->cur;
 	return pr_align_move(pr, sizeof(struct ac_ins_ta_header));
@@ -303,20 +304,18 @@ int acp_load_ins_jta(struct pack_reader *pr, struct ac_ins_jta_pack *pack)
 	int ret;
 
 	ret = acp_load_prop(pr, &pack->ins_cond);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 	ret = acp_load_ins_jta_head(pr, &pack->head);
-	if (ret != BH_SUCCESS)
-		return ret;
 
-	return BH_SUCCESS;
+	return ret;
 }
 
 int acp_load_pack_head(struct pack_reader *pr, struct ac_pack_header **head)
 {
 	if (!pr_is_safe_to_read(pr, sizeof(struct ac_pack_header)))
-		return BHE_INVALID_BPK_FILE;
+		return -EINVAL;
 
 	*head = (struct ac_pack_header *)pr->cur;
 	return pr_align_move(pr, sizeof(struct ac_pack_header));
diff --git a/drivers/misc/mei/dal/bhp_impl.c b/drivers/misc/mei/dal/bhp_impl.c
index bc0d7d1..72c90ba 100644
--- a/drivers/misc/mei/dal/bhp_impl.c
+++ b/drivers/misc/mei/dal/bhp_impl.c
@@ -351,7 +351,7 @@ static int bh_transport_recv(unsigned int handle, void *buffer, size_t size)
 	char *buf = buffer;
 
 	if (handle > DAL_MEI_DEVICE_MAX)
-		return BPE_COMMS_ERROR;
+		return -ENODEV;
 
 	while (size - count > 0) {
 		got = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
@@ -360,13 +360,16 @@ static int bh_transport_recv(unsigned int handle, void *buffer, size_t size)
 		else
 			ret = kdi_recv(handle, skip_buffer, &got);
 
-		if (ret != BH_SUCCESS)
+		if (ret)
 			return ret;
 
 		count += got;
 	}
 
-	return ret == BH_SUCCESS && count == size ? BH_SUCCESS : ret;
+	if (count != size)
+		return -EFAULT;
+
+	return 0;
 }
 
 static int bh_transport_send(unsigned int handle, const void *buffer,
@@ -378,32 +381,32 @@ static int bh_transport_send(unsigned int handle, const void *buffer,
 	const char *buf = buffer;
 
 	if (handle > DAL_MEI_DEVICE_MAX)
-		return BPE_COMMS_ERROR;
+		return -ENODEV;
 
 	while (size - count > 0) {
 		chunk_sz = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
 		ret = kdi_send(handle, buf + count, chunk_sz, seq);
-		if (ret != BH_SUCCESS)
+		if (ret)
 			return ret;
 
 		count += chunk_sz;
 	}
 
-	return BH_SUCCESS;
+	return 0;
 }
 
 int bh_do_open_vm(uuid_be sdid, int *conn_idx, int mode)
 {
 	if (!conn_idx)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	*conn_idx = CONN_IDX_IVM;
-	return BH_SUCCESS;
+	return 0;
 }
 
 int bh_do_close_vm(int conn_idx)
 {
-	return BH_SUCCESS;
+	return 0;
 }
 
 static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
@@ -414,12 +417,12 @@ static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
 	struct bhp_command_header *h = NULL;
 
 	if (!rr)
-		return BPE_INTERNAL_ERROR;
+		return -EFAULT;
 
 	mutex_enter(connections[conn_idx].bhm_send);
 
 	if (clen < sizeof(struct bhp_command_header) || !cmd || !rr)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	rr->buffer = NULL;
 	rr->length = 0;
@@ -431,10 +434,10 @@ static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
 	h->seq = seq;
 
 	ret = bh_transport_send(conn_idx, cmd, clen, seq);
-	if (ret == BH_SUCCESS && dlen > 0)
+	if (!ret && dlen > 0)
 		ret = bh_transport_send(conn_idx, (void *) data, dlen, seq);
 
-	if (ret != BH_SUCCESS)
+	if (ret)
 		rrmap_remove(conn_idx, seq, false);
 
 	mutex_exit(connections[conn_idx].bhm_send);
@@ -454,13 +457,13 @@ static int bh_recv_message(int conn_idx, u64 *seq)
 
 	ret = bh_transport_recv(conn_idx,
 			(char *) head, sizeof(struct bhp_response_header));
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 	/* check magic */
 	if (memcmp(BHP_MSG_RESPONSE_MAGIC,
 			head->h.magic, BHP_MSG_MAGIC_LENGTH) != 0)
-		return BPE_MESSAGE_ILLEGAL;
+		return -EBADMSG;
 
 	/* verify rr */
 	rr = rrmap_remove(conn_idx, head->seq, false);
@@ -469,15 +472,15 @@ static int bh_recv_message(int conn_idx, u64 *seq)
 		dlen = head->h.length - sizeof(struct bhp_response_header);
 		data = kzalloc(dlen, GFP_KERNEL);
 		ret = bh_transport_recv(conn_idx, data, dlen);
-		if (ret == BH_SUCCESS && data == NULL)
-			ret = BPE_OUT_OF_MEMORY;
+		if (!ret && !data)
+			ret = -ENOMEM;
 	}
 
 	if (rr) {
 		rr->buffer = data;
 		rr->length = dlen;
 
-		if (ret == BH_SUCCESS)
+		if (!ret)
 			rr->code = (int) head->code;
 		else
 			rr->code = ret;
@@ -538,7 +541,7 @@ static int bh_do_disconnect(int conn_idx)
 	INIT_LIST_HEAD(&conn->rr_map_list_header);
 	memset(&conn->sdid, 0, sizeof(uuid_be));
 
-	return BH_SUCCESS;
+	return 0;
 }
 
 static void bh_connections_init(void)
@@ -569,30 +572,29 @@ int bh_cmd_transfer(int conn_idx, void *cmd, unsigned int clen,
 		const void *data, unsigned int dlen, u64 seq)
 {
 	int ret;
-	u32 retry_count;
+	u32 retry_count = 0;
 	u64 seq_response = 0;
 
 	ret = bh_send_message(conn_idx, cmd, clen, data, dlen, seq);
+	if (ret)
+		return ret;
 
-	if (ret == BH_SUCCESS) {
-		retry_count = 0;
-		do {
-			ret = bh_recv_message(conn_idx, &seq_response);
-			if (ret == BH_SUCCESS) {
-				pr_debug("bh_cmd_transfer(): recv message with seq=%llu\n",
-						seq_response);
-				if (seq_response == seq)
-					break;
-			}
-			pr_debug("bh_cmd_transfer(): recv message with seq=%llu != seq_response=%llu\n",
-					seq, seq_response);
-			retry_count++;
-		} while (retry_count < MAX_RETRY_COUNT);
-
-		if (retry_count == MAX_RETRY_COUNT) {
-			pr_debug("bh_cmd_transfer(): out of retry attempts\n");
-			ret = BPE_INTERNAL_ERROR;
+	do {
+		ret = bh_recv_message(conn_idx, &seq_response);
+		if (!ret) {
+			pr_debug("bh_cmd_transfer(): recv message with seq=%llu\n",
+					seq_response);
+			if (seq_response == seq)
+				break;
 		}
+		pr_debug("bh_cmd_transfer(): recv message with seq=%llu != seq_response=%llu\n",
+				seq, seq_response);
+		retry_count++;
+	} while (retry_count < MAX_RETRY_COUNT);
+
+	if (retry_count == MAX_RETRY_COUNT) {
+		pr_debug("bh_cmd_transfer(): out of retry attempts\n");
+		ret = -EFAULT;
 	}
 
 	return ret;
@@ -601,7 +603,7 @@ int bh_cmd_transfer(int conn_idx, void *cmd, unsigned int clen,
 int bhp_init_internal(void)
 {
 	if (bhp_is_initialized())
-		return BPE_INITIALIZED_ALREADY;
+		return 0;
 
 	/* step 1: init connections to each process */
 	bh_connections_init();
@@ -610,15 +612,15 @@ int bhp_init_internal(void)
 	/* this assignment is atomic operation */
 	WRITE_ONCE(init_state, INITED);
 
-	return BH_SUCCESS;
+	return 0;
 }
 
 int bhp_deinit_internal(void)
 {
-	int ret;
+	int ret = 0;
 
 	if (!bhp_is_initialized())
-		return BPE_NOT_INIT;
+		return 0;
 
 	mutex_enter(bhm_gInit);
 
@@ -626,9 +628,6 @@ int bhp_deinit_internal(void)
 		/* RESET flow removed to allow JHI and KDI to coexist */
 		bh_connections_deinit();
 		WRITE_ONCE(init_state, DEINITED);
-		ret = BH_SUCCESS;
-	} else {
-		ret = BPE_NOT_INIT;
 	}
 
 	mutex_exit(bhm_gInit);
diff --git a/drivers/misc/mei/dal/bhp_impl_ta.c b/drivers/misc/mei/dal/bhp_impl_ta.c
index 3db0969..5c7145b 100644
--- a/drivers/misc/mei/dal/bhp_impl_ta.c
+++ b/drivers/misc/mei/dal/bhp_impl_ta.c
@@ -194,7 +194,7 @@ static int bh_proxy_get_sd_by_ta(uuid_be taid, uuid_be *sdid)
 	memset(&rr, 0, sizeof(rr));
 
 	if (!sdid)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	h->id = BHP_CMD_GET_SD_BY_TA;
 	cmd->taid = taid;
@@ -203,10 +203,10 @@ static int bh_proxy_get_sd_by_ta(uuid_be taid, uuid_be *sdid)
 			sizeof(*h) + sizeof(*cmd), NULL, 0,
 			rrmap_add(CONN_IDX_SDM, &rr));
 
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr.code;
 
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto cleanup;
 
 	if (rr.buffer && rr.length ==
@@ -215,7 +215,7 @@ static int bh_proxy_get_sd_by_ta(uuid_be taid, uuid_be *sdid)
 				(struct bhp_get_sd_by_ta_response *) rr.buffer;
 		*sdid = resp->sdid;
 	} else
-		ret = BPE_MESSAGE_ILLEGAL;
+		ret = -EBADMSG;
 
 cleanup:
 	kfree(rr.buffer);
@@ -243,7 +243,7 @@ static int bh_proxy_check_svl_ta_blocked_state(uuid_be taid)
 	ret = bh_cmd_transfer(CONN_IDX_SDM, (char *) h,
 			sizeof(*h) + sizeof(*cmd), NULL, 0,
 			rrmap_add(CONN_IDX_SDM, &rr));
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr.code;
 
 	kfree(rr.buffer);
@@ -266,45 +266,45 @@ static int bh_proxy_listJTAPackages(int conn_idx, int *count,
 	memset(&rr, 0, sizeof(rr));
 
 	if (!bhp_is_initialized())
-		return BPE_NOT_INIT;
+		return -EFAULT;
 
 	if (!count || !app_ids)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
+
+	*app_ids = NULL;
+	*count = 0;
 
 	h->id = BHP_CMD_LIST_TA_PACKAGES;
 
 	ret = bh_cmd_transfer(conn_idx, (char *)h, sizeof(*h),
 			     NULL, 0, rrmap_add(conn_idx, &rr));
-
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr.code;
-
-	*app_ids = NULL;
-	*count = 0;
-
-	if (ret != BH_SUCCESS)
+	if (ret)
 		goto out;
 
 	if (!rr.buffer) {
-		ret = BPE_MESSAGE_ILLEGAL;
+		ret = -EBADMSG;
 		goto out;
 	}
 
 	resp = (struct bhp_list_ta_packages_response *)rr.buffer;
-	if (!resp->count)
+	if (!resp->count) {
+		ret = -EBADMSG;
 		goto out;
+	}
 
 	if (rr.length != sizeof(uuid_be) *
 			 resp->count +
 			sizeof(struct bhp_list_ta_packages_response)) {
-		ret = BPE_MESSAGE_ILLEGAL;
+		ret = -EBADMSG;
 		goto out;
 	}
 
 	outbuf = kcalloc(resp->count, sizeof(uuid_be), GFP_KERNEL);
 
 	if (!outbuf) {
-		ret = BPE_OUT_OF_MEMORY;
+		ret = -ENOMEM;
 		goto out;
 	}
 	for (i = 0; i < resp->count; i++)
@@ -335,7 +335,7 @@ static int bh_proxy_download_javata(
 	memset(&rr, 0, sizeof(rr));
 
 	if (!ta_pkg || !pkg_len)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	h->id = BHP_CMD_DOWNLOAD_JAVATA;
 	cmd->appid = ta_id;
@@ -343,7 +343,7 @@ static int bh_proxy_download_javata(
 	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
 			ta_pkg, pkg_len, rrmap_add(conn_idx, &rr));
 
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr.code;
 
 	kfree(rr.buffer);
@@ -372,13 +372,13 @@ static int bh_proxy_openjtasession(
 	memset(cmdbuf, 0, sizeof(cmdbuf));
 
 	if (!handle)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 	if (!init_buffer && init_len > 0)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	rr = kzalloc(sizeof(struct bh_response_record), GFP_KERNEL);
 	if (!rr)
-		return BPE_OUT_OF_MEMORY;
+		return -ENOMEM;
 
 	memset(rr, 0, sizeof(struct bh_response_record));
 
@@ -392,7 +392,7 @@ static int bh_proxy_openjtasession(
 	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
 			     (char *) init_buffer, init_len, seq);
 
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr->code;
 
 	kfree(rr->buffer);
@@ -405,12 +405,12 @@ static int bh_proxy_openjtasession(
 		 */
 		ret = bh_proxy_download_javata(conn_idx, ta_id,
 					       ta_pkg, pkg_len);
-		if (ret == BH_SUCCESS) {
+		if (!ret) {
 			ret = bh_cmd_transfer(conn_idx, (char *)h,
 					sizeof(*h) + sizeof(*cmd),
 					(char *)init_buffer, init_len, seq);
 
-			if (ret == BH_SUCCESS)
+			if (!ret)
 				ret = rr->code;
 
 			kfree(rr->buffer);
@@ -418,7 +418,7 @@ static int bh_proxy_openjtasession(
 		}
 	}
 
-	if (ret == BH_SUCCESS) {
+	if (!ret) {
 		*handle = (u64) seq;
 		session_exit(conn_idx, rr, seq, 0);
 	} else {
@@ -448,36 +448,36 @@ int bhp_open_ta_session(u64 *session, const char *app_id,
 	int i;
 
 	if (!app_id || !session)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (!ta_pkg || !pkg_len)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (!init_buffer && init_len != 0)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (__uuid_be_to_bin(app_id, &ta_id))
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	*session = 0;
 
 	/* 1.1: get the TA's sdid */
 	ret = bh_proxy_get_sd_by_ta(ta_id, &sdid);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 	ret = bh_proxy_check_svl_ta_blocked_state(ta_id);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 	/* 1.2: get corresponding vm conn_idx */
 	ret = bh_do_open_vm(sdid, &conn_idx, BHP_OPEN_VM_NORMAL_MODE);
-	if (ret != BH_SUCCESS)
+	if (ret)
 		return ret;
 
 	/* 2.1: check whether the ta pkg existed in VM or not */
 	ret = bh_proxy_listJTAPackages(conn_idx, &count, &app_ids);
-	if (ret == BH_SUCCESS) {
+	if (!ret) {
 		for (i = 0; i < count; i++) {
 			if (!uuid_be_cmp(ta_id, app_ids[i])) {
 				ta_existed = 1;
@@ -491,7 +491,7 @@ int bhp_open_ta_session(u64 *session, const char *app_id,
 	if (!ta_existed) {
 		ret = bh_proxy_download_javata(conn_idx,
 					       ta_id, ta_pkg, pkg_len);
-		if (ret != BH_SUCCESS && ret != BHE_PACKAGE_EXIST)
+		if (ret && ret != BHE_PACKAGE_EXIST)
 			goto cleanup;
 	}
 
@@ -506,7 +506,7 @@ cleanup:
 	 * closeVM only when this process failed and vm has not been closed
 	 * inside openjtasession, otherwise the session is created.
 	 */
-	if (ret != BH_SUCCESS && !vm_conn_closed)
+	if (ret && !vm_conn_closed)
 		bh_do_close_vm(conn_idx);
 
 	return ret;
@@ -529,20 +529,20 @@ int bhp_send_and_recv(const u64 handle, int command_id,
 	memset(cmdbuf, 0, sizeof(cmdbuf));
 
 	if (!bhp_is_initialized())
-		return BPE_NOT_INIT;
+		return -EFAULT;
 
 	if (!input && length != 0)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (!output_length)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (output)
 		*output = NULL;
 
 	rr = session_enter_vm(seq, &conn_idx, 1);
 	if (!rr)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	rr->buffer = NULL;
 	h->id = BHP_CMD_SENDANDRECV;
@@ -554,13 +554,13 @@ int bhp_send_and_recv(const u64 handle, int command_id,
 	ret = bh_cmd_transfer(conn_idx, (char *)h, sizeof(*h) + sizeof(*cmd),
 			      (char *) input, length, seq);
 
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr->code;
 
 	if (rr->killed)
 		ret = BHE_UNCAUGHT_EXCEPTION;
 
-	if (ret == BH_SUCCESS) {
+	if (!ret) {
 		struct bhp_snr_response *resp = NULL;
 
 		if (rr->buffer &&
@@ -578,15 +578,15 @@ int bhp_send_and_recv(const u64 handle, int command_id,
 						memcpy(*output,
 						       resp->buffer, len);
 					else
-						ret = BPE_OUT_OF_MEMORY;
+						ret = -ENOMEM;
 
 				} else
-					ret = BHE_APPLET_SMALL_BUFFER;
+					ret = -EMSGSIZE;
 			}
 
 			*output_length = len;
 		} else
-			ret = BPE_MESSAGE_TOO_SHORT;
+			ret = -EBADMSG;
 
 	} else if (ret == BHE_APPLET_SMALL_BUFFER && rr->buffer &&
 		   rr->length == sizeof(struct bhp_snr_bof_response)) {
@@ -623,7 +623,7 @@ int bhp_close_ta_session(const u64 handle)
 
 	rr = session_enter_vm(seq, &conn_idx, 1);
 	if (!rr)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	h->id = BHP_CMD_CLOSE_JTASESSION;
 	cmd->ta_session_id = rr->addr;
@@ -631,7 +631,7 @@ int bhp_close_ta_session(const u64 handle)
 	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
 			      NULL, 0, seq);
 
-	if (ret == BH_SUCCESS)
+	if (!ret)
 		ret = rr->code;
 
 	if (rr->killed)
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index 2fbf5cd..159a497 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -77,11 +77,17 @@ static DEFINE_MUTEX(kdi_lock);
 #define BH_MSG_MAGIC_LENGTH            4
 #define BH_MSG_SEQUENCE_OFFSET         8
 
-static int bh_err_to_kdi_err(int bh_err)
+static int to_kdi_err(int err)
 {
-	switch (bh_err) {
-	case BH_SUCCESS:
-		return DAL_KDI_SUCCESS;
+
+	if (err)
+		pr_info("got error: %d\n", err);
+
+	if (err <=0)
+		return err;
+
+	/* err > 0: is error from FW */
+	switch (err) {
 	case BPE_INTERNAL_ERROR:
 		return DAL_KDI_STATUS_INTERNAL_ERROR;
 	case BPE_INVALID_PARAMS:
@@ -91,8 +97,6 @@ static int bh_err_to_kdi_err(int bh_err)
 		return DAL_KDI_STATUS_INVALID_HANDLE;
 	case BPE_NOT_INIT:
 		return DAL_KDI_STATUS_NOT_INITIALIZED;
-	case BPE_NO_CONNECTION_TO_FIRMWARE:
-		return DAL_KDI_STATUS_NO_FW_CONNECTION;
 	case BPE_OUT_OF_MEMORY:
 	case BHE_OUT_OF_MEMORY:
 		return DAL_KDI_STATUS_OUT_OF_MEMORY;
@@ -111,6 +115,10 @@ static int bh_err_to_kdi_err(int bh_err)
 		return DAL_KDI_STATUS_APPLET_CRASHED;
 	case BHE_TA_PACKAGE_HASH_VERIFY_FAIL:
 		return DAL_KDI_STATUS_INVALID_ACP;
+	case BHE_PACKAGE_NOT_FOUND:
+		return DAL_KDI_STATUS_TA_NOT_FOUND;
+	case BHE_PACKAGE_EXIST:
+		return DAL_KDI_STATUS_TA_EXIST;
 	default:
 		return DAL_KDI_STATUS_INTERNAL_ERROR;
 	}
@@ -123,42 +131,41 @@ int kdi_send(unsigned int handle, const unsigned char *buf,
 	struct dal_device *ddev;
 	struct dal_client *dc;
 	struct device *dev;
-	ssize_t ret;
+	ssize_t wr;
+	int ret;
 
 	mei_device = (enum dal_dev_type)handle;
 
 	if (!buf)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (mei_device < DAL_MEI_DEVICE_IVM || mei_device >= DAL_MEI_DEVICE_MAX)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (!len)
-		return BH_SUCCESS;
+		return 0;
 
 	dev = dal_find_dev(mei_device);
 	if (!dev) {
 		dev_err(dev, "can't find device\n");
-		return BPE_INTERNAL_ERROR;
+		return -ENODEV;
 	}
 
 	ddev = to_dal_device(dev);
 	dc = ddev->clients[DAL_INTF_KDI];
 	if (!dc) {
 		dev_err(dev, "client is NULL\n");
-		ret = BPE_INTERNAL_ERROR;
+		ret = -EFAULT;
 		goto out;
 	}
 
 	/* copy data to client object */
 	memcpy(dc->write_buffer, buf, len);
-	ret = dal_write(dc, len, seq);
-
-	if (ret <= 0)
-		ret = BPE_COMMS_ERROR;
+	wr = dal_write(dc, len, seq);
+	if (wr > 0)
+		ret = 0;
 	else
-		ret = BH_SUCCESS;
-
+		ret = wr;
 out:
 	put_device(dev);
 	return ret;
@@ -176,44 +183,43 @@ int kdi_recv(unsigned int handle, unsigned char *buf, size_t *count)
 	mei_device = (enum dal_dev_type)handle;
 
 	if (!buf || !count)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	if (mei_device < DAL_MEI_DEVICE_IVM || mei_device >= DAL_MEI_DEVICE_MAX)
-		return BPE_INVALID_PARAMS;
+		return -EINVAL;
 
 	dev = dal_find_dev(mei_device);
 	if (!dev)
-		return BPE_INTERNAL_ERROR;
+		return -ENODEV;
 
 	ddev = to_dal_device(dev);
 	dc = ddev->clients[DAL_INTF_KDI];
 	if (!dc) {
 		dev_err(dev, "client is NULL\n");
-		ret = BPE_INTERNAL_ERROR;
+		ret = -EFAULT;
 		goto out;
 	}
 
 	ret = dal_read(dc);
 
-	if (ret != 0)
+	if (ret)
 		goto out;
 
 	if (kfifo_is_empty(&dc->read_queue)) {
-		ret = 0;
 		goto out;
 	}
 
 	ret = kfifo_out(&dc->read_queue, &len, sizeof(len));
 	if (ret != sizeof(len)) {
 		dev_err(&ddev->dev, "could not copy buffer: cannot fetch size");
-		ret = BPE_COMMS_ERROR;
+		ret = -EFAULT;
 		goto out;
 	}
 
 	if (len > *count) {
 		dev_err(&ddev->dev, "could not copy buffer: src size = %zd > dest size = %zd\n",
 			len, *count);
-		ret = BPE_COMMS_ERROR;
+		ret = -EMSGSIZE;
 		goto out;
 	}
 
@@ -221,11 +227,11 @@ int kdi_recv(unsigned int handle, unsigned char *buf, size_t *count)
 	if (ret != len) {
 		dev_err(&ddev->dev, "could not copy buffer: src size = %zd, dest size = %zd\n",
 			len, ret);
-		ret = BPE_COMMS_ERROR;
+		ret = -EFAULT;
 	}
 
 	*count = len;
-	ret = BH_SUCCESS;
+	ret = 0;
 out:
 	put_device(dev);
 	return ret;
@@ -238,10 +244,10 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 	struct ac_ins_jta_pack_ext pack;
 	char *ta_pkg;
 	int ta_pkg_size;
-	int ret, bh_err;
+	int ret;
 
 	if (!jta_id || !buffer || !buffer_length || !handle)
-		return DAL_KDI_STATUS_INVALID_PARAMS;
+		return -EINVAL;
 
 	/* init_param are optional, but if they exists the length should be
 	 * positive and if param buffer is not exists the length must be 0
@@ -249,31 +255,30 @@ static int kdi_create_session(u64 *handle, const char *jta_id,
 	if (!init_param && init_param_length != 0) {
 		pr_err("INVALID_PARAMS init_param %p init_param_length %zu",
 		       init_param, init_param_length);
-		return DAL_KDI_STATUS_INVALID_PARAMS;
+		return -EINVAL;
 	}
 
-	bh_err = acp_pload_ins_jta(buffer, buffer_length, &pack);
-	ret = bh_err_to_kdi_err(bh_err);
+	ret = acp_pload_ins_jta(buffer, buffer_length, &pack);
 	if (ret) {
-		pr_err("acp_pload_ins_jta() return %d", bh_err);
-		return ret;
+		pr_err("acp_pload_ins_jta() return %d", ret);
+		return to_kdi_err(ret);
 	}
 
 	ta_pkg = pack.ta_pack;
 	if (!ta_pkg)
-		return DAL_KDI_STATUS_INTERNAL_ERROR;
+		return -EINVAL;
 
 	ta_pkg_size = ta_pkg - (char *)buffer;
 
 	if (ta_pkg_size < 0 || (unsigned int)ta_pkg_size > buffer_length)
-		return DAL_KDI_STATUS_INTERNAL_ERROR;
+		return -EINVAL;
 
 	ta_pkg_size = buffer_length - ta_pkg_size;
 
-	bh_err = bhp_open_ta_session(handle, jta_id, ta_pkg, ta_pkg_size,
+	ret = bhp_open_ta_session(handle, jta_id, ta_pkg, ta_pkg_size,
 				     init_param, init_param_length);
 
-	return bh_err_to_kdi_err(bh_err);
+	return to_kdi_err(ret);
 }
 
 int dal_create_session(u64 *session_handle,  const char *app_id,
@@ -291,7 +296,7 @@ int dal_create_session(u64 *session_handle,  const char *app_id,
 
 	mutex_unlock(&kdi_lock);
 
-	return ret;
+	return to_kdi_err(ret);
 }
 EXPORT_SYMBOL(dal_create_session);
 
@@ -299,40 +304,36 @@ int dal_send_and_receive(u64 session_handle, int command_id, const u8 *input,
 			 size_t input_len, u8 **output, size_t *output_len,
 			 int *response_code)
 {
-	int ret, bh_err;
+	int ret;
 
 	mutex_lock(&kdi_lock);
 
-	bh_err = bhp_send_and_recv(session_handle, command_id, input, input_len,
+	ret = bhp_send_and_recv(session_handle, command_id, input, input_len,
 				   (void **)output, output_len, response_code);
 
-	if (bh_err)
-		pr_err("bhp_send_and_recv failed with status = %d\n", bh_err);
-
-	ret = bh_err_to_kdi_err(bh_err);
+	if (ret)
+		pr_err("bhp_send_and_recv failed with status = %d\n", ret);
 
 	mutex_unlock(&kdi_lock);
 
-	return ret;
+	return to_kdi_err(ret);
 }
 EXPORT_SYMBOL(dal_send_and_receive);
 
 int dal_close_session(u64 session_handle)
 {
-	int ret, bh_err;
+	int ret;
 
 	mutex_lock(&kdi_lock);
 
-	bh_err = bhp_close_ta_session(session_handle);
-
-	if (bh_err)
-		pr_err("hp_close_ta_session failed = %d\n", bh_err);
+	ret = bhp_close_ta_session(session_handle);
 
-	ret = bh_err_to_kdi_err(bh_err);
+	if (ret)
+		pr_err("hp_close_ta_session failed = %d\n", ret);
 
 	mutex_unlock(&kdi_lock);
 
-	return ret;
+	return to_kdi_err(ret);
 }
 EXPORT_SYMBOL(dal_close_session);
 
@@ -359,7 +360,7 @@ int dal_set_ta_exclusive_access(uuid_be ta_id)
 	dev = dal_find_dev(DAL_MEI_DEVICE_IVM);
 	if (!dev) {
 		dev_err(dev, "can't find device\n");
-		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+		ret = -ENODEV;
 		goto unlock;
 	}
 
@@ -367,12 +368,6 @@ int dal_set_ta_exclusive_access(uuid_be ta_id)
 	dc = ddev->clients[DAL_INTF_KDI];
 
 	ret = dal_access_policy_add(ddev, ta_id, dc);
-	if (ret == -EEXIST)
-		ret = DAL_KDI_STATUS_TA_EXIST;
-	else if (ret == -EPERM)
-		ret = DAL_KDI_STATUS_NON_EXCLUSIVENESS_TA;
-	else if (ret)
-		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
 
 	put_device(dev);
 unlock:
@@ -401,17 +396,13 @@ int dal_unset_ta_exclusive_access(uuid_be ta_id)
 	if (!dev) {
 		mutex_unlock(&kdi_lock);
 		dev_err(dev, "can't find device\n");
-		return DAL_KDI_STATUS_INTERNAL_ERROR;
+		return -ENODEV;
 	}
 
 	ddev = to_dal_device(dev);
 	dc = ddev->clients[DAL_INTF_KDI];
 
 	ret = dal_access_policy_remove(ddev, ta_id, dc);
-	if (ret == -ENOENT)
-		ret = DAL_KDI_STATUS_TA_NOT_FOUND;
-	else if (ret == -EPERM)
-		ret = DAL_KDI_STATUS_OPERATION_NOT_PERMITTED;
 
 	put_device(dev);
 
@@ -472,13 +463,12 @@ static struct class_interface kdi_interface __refdata = {
 
 int dal_kdi_init(void)
 {
-	int bh_err;
 	int ret;
 
-	bh_err = bhp_init_internal();
-	if (bh_err) {
-		pr_err("bhp_init: failed with status = 0x%x\n", bh_err);
-		return  -EFAULT;
+	ret = bhp_init_internal();
+	if (ret) {
+		pr_err("bhp_init: failed with status = 0x%x\n", ret);
+		return to_kdi_err(ret);
 	}
 
 	kdi_interface.class = dal_class;
diff --git a/include/linux/dal.h b/include/linux/dal.h
index 5a3b1e3..5d0833c 100644
--- a/include/linux/dal.h
+++ b/include/linux/dal.h
@@ -81,22 +81,17 @@ struct dal_version_info {
 #define DAL_KDI_STATUS_INTERNAL_ERROR           0xA00
 #define DAL_KDI_STATUS_INVALID_PARAMS           0xA01
 #define DAL_KDI_STATUS_INVALID_HANDLE           0xA02
-#define DAL_KDI_STATUS_ILLEGAL_USAGE            0xA03
-#define DAL_KDI_STATUS_NOT_INITIALIZED          0xA04
-#define DAL_KDI_STATUS_NO_FW_CONNECTION         0xA05
-#define DAL_KDI_STATUS_OUT_OF_MEMORY            0xA06
-#define DAL_KDI_STATUS_BUFFER_TOO_SMALL         0xA07
-#define DAL_KDI_STATUS_OUT_OF_RESOURCE          0xA08
-#define DAL_KDI_STATUS_NOT_READY                0xA09
-#define DAL_KDI_STATUS_MAX_SESSIONS_REACHED     0xA0A
-#define DAL_KDI_STATUS_UNCAUGHT_EXCEPTION       0xA0B
-#define DAL_KDI_STATUS_WD_TIMEOUT               0xA0C
-#define DAL_KDI_STATUS_APPLET_CRASHED           0xA0D
-#define DAL_KDI_STATUS_TA_NOT_FOUND             0xA0E
-#define DAL_KDI_STATUS_NON_EXCLUSIVENESS_TA     0xA0F
-#define DAL_KDI_STATUS_TA_EXIST                 0xA10
-#define DAL_KDI_STATUS_OPERATION_NOT_PERMITTED  0xA11
-#define DAL_KDI_STATUS_INVALID_ACP              0xA12
+#define DAL_KDI_STATUS_NOT_INITIALIZED          0xA03
+#define DAL_KDI_STATUS_OUT_OF_MEMORY            0xA04
+#define DAL_KDI_STATUS_BUFFER_TOO_SMALL         0xA05
+#define DAL_KDI_STATUS_OUT_OF_RESOURCE          0xA06
+#define DAL_KDI_STATUS_MAX_SESSIONS_REACHED     0xA07
+#define DAL_KDI_STATUS_UNCAUGHT_EXCEPTION       0xA08
+#define DAL_KDI_STATUS_WD_TIMEOUT               0xA09
+#define DAL_KDI_STATUS_APPLET_CRASHED           0xA0A
+#define DAL_KDI_STATUS_TA_NOT_FOUND             0xA0B
+#define DAL_KDI_STATUS_TA_EXIST                 0xA0C
+#define DAL_KDI_STATUS_INVALID_ACP              0xA0D
 
 #define DAL_KDI_INVALID_HANDLE    0
 
-- 
1.7.5.4

