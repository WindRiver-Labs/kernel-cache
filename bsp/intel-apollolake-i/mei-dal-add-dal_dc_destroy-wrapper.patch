From 740eb54288584c6868251d2068698e38b84daa56 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 24 Aug 2016 12:18:00 +0300
Subject: [PATCH 21/68] mei: dal: add dal_dc_destroy wrapper

commit 5927e506b8f9d251c37e745d43ecb405e3fdc56c from
git://git.yoctoproject.org/linux-yocto-4.1

Use dal_dc_destroy instead of open coded dal client destruction

Change-Id: I477d250699fdd792d4a989ff9a3c52a1a3d061bb
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/dal/dal_cdev.c  |    6 +-----
 drivers/misc/mei/dal/dal_class.c |   13 +++++++++++++
 drivers/misc/mei/dal/dal_dev.h   |    3 ++-
 drivers/misc/mei/dal/dal_kdi.c   |    7 +------
 4 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/drivers/misc/mei/dal/dal_cdev.c b/drivers/misc/mei/dal/dal_cdev.c
index 9754a8d..6881080 100644
--- a/drivers/misc/mei/dal/dal_cdev.c
+++ b/drivers/misc/mei/dal/dal_cdev.c
@@ -118,11 +118,7 @@ static int dal_dev_release(struct inode *inode, struct file *fp)
 		return -ERESTARTSYS;
 	}
 
-	dev_dbg(&ddev->dev, "free user space client");
-	ddev->clients[dc->intf] = NULL;
-
-	kfifo_free(&dc->read_queue);
-	kfree(dc);
+	dal_dc_destroy(ddev, dc->intf);
 
 	mutex_unlock(&ddev->context_lock);
 
diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
index e835fbc..79ebe1c 100644
--- a/drivers/misc/mei/dal/dal_class.c
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -506,6 +506,19 @@ out:
 	dev_dbg(&cldev->dev, "recv_cb(): unlock\n");
 }
 
+void dal_dc_destroy(struct dal_device *ddev, enum dal_intf intf)
+{
+	struct dal_client *dc;
+
+	dc = ddev->clients[intf];
+	if (!dc)
+		return;
+
+	kfifo_free(&dc->read_queue);
+	kfree(dc);
+	ddev->clients[intf] = NULL;
+}
+
 int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf)
 {
 	int ret;
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
index 9ecaba1..22dfa03 100644
--- a/drivers/misc/mei/dal/dal_dev.h
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -220,10 +220,11 @@ struct dal_client {
 ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq);
 ssize_t dal_read(struct  dal_client *dc);
 
-void dal_dc_print(struct device *dev, struct dal_client *dc);
 
 struct device *dal_find_dev(enum dal_dev_type device_id);
 
+void dal_dc_print(struct device *dev, struct dal_client *dc);
 int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf);
+void dal_dc_destroy(struct dal_device *ddev, enum dal_intf intf);
 
 #endif  /* _DAL_KDI_H_ */
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
index f2c468a..3f67065 100644
--- a/drivers/misc/mei/dal/dal_kdi.c
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -215,7 +215,6 @@ static void kdi_destroy_kernel_clients(void)
 {
 	struct device *dev;
 	struct dal_device *ddev;
-	struct dal_client *dc;
 	int i;
 
 	/* use iterator */
@@ -225,11 +224,7 @@ static void kdi_destroy_kernel_clients(void)
 			continue;
 		/* TODO: just call destroy kdic ...  */
 		ddev = to_dal_device(dev);
-		dev_dbg(&ddev->dev, "kdi_destroy_kernel_clients(): free kernel space client");
-		dc = ddev->clients[DAL_INTF_KDI];
-		kfifo_free(&dc->read_queue);
-		kfree(dc);
-		ddev->clients[DAL_INTF_KDI] = NULL;
+		dal_dc_destroy(ddev, DAL_INTF_KDI);
 		put_device(dev);
 	}
 }
-- 
1.7.5.4

