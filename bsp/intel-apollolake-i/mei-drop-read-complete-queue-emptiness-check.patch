From 12671af419056e63e5fe359059465af28af3ed46 Mon Sep 17 00:00:00 2001
From: Alexander Usyskin <alexander.usyskin@intel.com>
Date: Mon, 9 Nov 2015 15:21:59 +0200
Subject: [PATCH 2461/2508] mei: drop read complete queue emptiness check

commit 4adfbbd6b2af3c4998686e6cee55b1ad7fadb779 from
https://github.com/01org/linux-apollolake-i

In the course of the read flow we want to wait for read completion only
if the read queue is empty.
However the calling list_empty(&cl->rd_completed) is a duplication as the
same check was performed by mei_cl_read_cb() and the waiting is skipped
if it returns not NULL.

Change-Id: I6c32fd036a3af0e9e32a2e47aa7ded4d47f04c01
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/bus.c  |    3 ++-
 drivers/misc/mei/main.c |    3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1f33fea..63411dd 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -126,7 +126,8 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		goto out;
 
 	/* wait on event only if there is no other waiter */
-	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+	/* synchronized under device mutex */
+	if (!waitqueue_active(&cl->rx_wait)) {
 
 		mutex_unlock(&bus->device_lock);
 
diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c
index a8d0471..3326bde 100644
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@ -183,7 +183,8 @@ static ssize_t mei_read(struct file *file, char __user *ubuf,
 		goto out;
 	}
 
-	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+	/* synchronized under device mutex */
+	if (!waitqueue_active(&cl->rx_wait)) {
 		if (file->f_flags & O_NONBLOCK) {
 			rets = -EAGAIN;
 			goto out;
-- 
1.7.5.4

