From 9c07392712b142f457caa5dcd0e4472cec5dbd2d Mon Sep 17 00:00:00 2001
From: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date: Tue, 21 Apr 2015 17:13:00 +0300
Subject: [PATCH 0263/4706] drm/i915: Extract mode_changed computation out of
 stage_output_config()

commit 462a425aa541703a320b15f7f7f5b64de7e0eb47 upstream

This should make the conversion to atomic easier, by splitting the
initialization of the atomic state from the logic that decides if a
modeset is needed.

Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
---
 drivers/gpu/drm/i915/intel_display.c |   73 +++++++++++++++++++---------------
 1 files changed, 41 insertions(+), 32 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 819dbee..0c471eb 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -12607,6 +12607,10 @@ static void
 intel_set_config_compute_mode_changes(struct drm_mode_set *set,
 				      struct intel_set_config *config)
 {
+	struct drm_device *dev = set->crtc->dev;
+	struct intel_connector *connector;
+	struct intel_encoder *encoder;
+	struct intel_crtc *crtc;
 
 	/* We should be able to check here if the fb has the same properties
 	 * and then just flip_or_move it */
@@ -12650,6 +12654,36 @@ intel_set_config_compute_mode_changes(struct drm_mode_set *set,
 		config->mode_changed = true;
 	}
 
+	for_each_intel_connector(dev, connector) {
+		if (&connector->new_encoder->base == connector->base.encoder)
+			continue;
+
+		config->mode_changed = true;
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] encoder changed, full mode switch\n",
+			      connector->base.base.id,
+			      connector->base.name);
+	}
+
+	for_each_intel_encoder(dev, encoder) {
+		if (&encoder->new_crtc->base == encoder->base.crtc)
+			continue;
+
+		DRM_DEBUG_KMS("[ENCODER:%d:%s] crtc changed, full mode switch\n",
+			      encoder->base.base.id,
+			      encoder->base.name);
+		config->mode_changed = true;
+	}
+
+	for_each_intel_crtc(dev, crtc) {
+		if (crtc->new_enabled == crtc->base.state->enable)
+			continue;
+
+		DRM_DEBUG_KMS("[CRTC:%d] %sabled, full mode switch\n",
+			      crtc->base.base.id,
+			      crtc->new_enabled ? "en" : "dis");
+		config->mode_changed = true;
+	}
+
 	DRM_DEBUG_KMS("computed changes for [CRTC:%d], mode_changed=%d, fb_changed=%d\n",
 			set->crtc->base.id, config->mode_changed, config->fb_changed);
 }
@@ -12657,7 +12691,6 @@ intel_set_config_compute_mode_changes(struct drm_mode_set *set,
 static int
 intel_modeset_stage_output_state(struct drm_device *dev,
 				 struct drm_mode_set *set,
-				 struct intel_set_config *config,
 				 struct drm_atomic_state *state)
 {
 	struct intel_connector *connector;
@@ -12693,14 +12726,6 @@ intel_modeset_stage_output_state(struct drm_device *dev,
 				connector->base.base.id,
 				connector->base.name);
 		}
-
-
-		if (&connector->new_encoder->base != connector->base.encoder) {
-			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] encoder changed, full mode switch\n",
-				      connector->base.base.id,
-				      connector->base.name);
-			config->mode_changed = true;
-		}
 	}
 	/* connector->new_encoder is now updated for all connectors. */
 
@@ -12753,15 +12778,6 @@ intel_modeset_stage_output_state(struct drm_device *dev,
 			encoder->new_crtc = NULL;
 		else if (num_connectors > 1)
 			return -EINVAL;
-
-		/* Only now check for crtc changes so we don't miss encoders
-		 * that will be disabled. */
-		if (&encoder->new_crtc->base != encoder->base.crtc) {
-			DRM_DEBUG_KMS("[ENCODER:%d:%s] crtc changed, full mode switch\n",
-				      encoder->base.base.id,
-				      encoder->base.name);
-			config->mode_changed = true;
-		}
 	}
 	/* Now we've also updated encoder->new_crtc for all encoders. */
 	for_each_intel_connector(dev, connector) {
@@ -12787,13 +12803,6 @@ intel_modeset_stage_output_state(struct drm_device *dev,
 				break;
 			}
 		}
-
-		if (crtc->new_enabled != crtc->base.state->enable) {
-			DRM_DEBUG_KMS("[CRTC:%d] %sabled, full mode switch\n",
-				      crtc->base.base.id,
-				      crtc->new_enabled ? "en" : "dis");
-			config->mode_changed = true;
-		}
 	}
 
 	return 0;
@@ -12865,12 +12874,6 @@ static int intel_crtc_set_config(struct drm_mode_set *set)
 	save_set.y = set->crtc->y;
 	save_set.fb = set->crtc->primary->fb;
 
-	/* Compute whether we need a full modeset, only an fb base update or no
-	 * change at all. In the future we might also check whether only the
-	 * mode changed, e.g. for LVDS where we only change the panel fitter in
-	 * such cases. */
-	intel_set_config_compute_mode_changes(set, config);
-
 	state = drm_atomic_state_alloc(dev);
 	if (!state) {
 		ret = -ENOMEM;
@@ -12879,10 +12882,16 @@ static int intel_crtc_set_config(struct drm_mode_set *set)
 
 	state->acquire_ctx = dev->mode_config.acquire_ctx;
 
-	ret = intel_modeset_stage_output_state(dev, set, config, state);
+	ret = intel_modeset_stage_output_state(dev, set, state);
 	if (ret)
 		goto fail;
 
+	/* Compute whether we need a full modeset, only an fb base update or no
+	 * change at all. In the future we might also check whether only the
+	 * mode changed, e.g. for LVDS where we only change the panel fitter in
+	 * such cases. */
+	intel_set_config_compute_mode_changes(set, config);
+
 	pipe_config = intel_modeset_compute_config(set->crtc, set->mode,
 						   state,
 						   &modeset_pipes,
-- 
1.7.5.4

