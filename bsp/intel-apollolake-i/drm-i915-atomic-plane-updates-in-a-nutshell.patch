From ab058a682db3bd9d96d65300047cb169853345c8 Mon Sep 17 00:00:00 2001
From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date: Fri, 2 Oct 2015 11:22:00 -0700
Subject: [PATCH 0680/4706] drm/i915: atomic plane updates in a nutshell

commit 1ca407b0d3c8bc770482990426c62573483d4367 from
git://git.yoctoproject.org/linux-yocto-4.1

Now that all planes are added during a modeset we can use the
calculated changes before disabling a plane, and then either commit
or force disable a plane before disabling the crtc.

The code is shared with atomic_begin/flush, except watermark updating
and vblank evasion are not used.

This is needed for proper atomic suspend/resume support.

Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=90868
Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Tested-by(IVB): Matt Roper <matthew.d.roper@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

(cherry picked from commit a539205a1628e76cbaae35c8ba64d503c6aa619b)
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>

Conflicts:
	drivers/gpu/drm/i915/intel_display.c
---
 drivers/gpu/drm/i915/intel_display.c |   99 +++++++---------------------------
 drivers/gpu/drm/i915/intel_sprite.c  |    4 +-
 2 files changed, 21 insertions(+), 82 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index a102a7f..83ee31a 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -2217,28 +2217,6 @@ static void intel_disable_pipe(struct intel_crtc *crtc)
 		intel_wait_for_pipe_off(crtc);
 }
 
-/**
- * intel_enable_primary_hw_plane - enable the primary plane on a given pipe
- * @plane:  plane to be enabled
- * @crtc: crtc for the plane
- *
- * Enable @plane on @crtc, making sure that the pipe is running first.
- */
-static void intel_enable_primary_hw_plane(struct drm_plane *plane,
-					  struct drm_crtc *crtc)
-{
-	struct drm_device *dev = plane->dev;
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
-
-	/* If the pipe isn't enabled, we can't pump pixels and may hang */
-	assert_pipe_enabled(dev_priv, intel_crtc->pipe);
-	to_intel_plane_state(plane->state)->visible = true;
-
-	dev_priv->display.update_primary_plane(crtc, plane->fb,
-					       crtc->x, crtc->y);
-}
-
 static bool need_vtd_wa(struct drm_device *dev)
 {
 #ifdef CONFIG_INTEL_IOMMU
@@ -4518,20 +4496,6 @@ static void ironlake_pfit_enable(struct intel_crtc *crtc)
 	}
 }
 
-static void intel_enable_sprite_planes(struct drm_crtc *crtc)
-{
-	struct drm_device *dev = crtc->dev;
-	enum pipe pipe = to_intel_crtc(crtc)->pipe;
-	struct drm_plane *plane;
-	struct intel_plane *intel_plane;
-
-	drm_for_each_legacy_plane(plane, &dev->mode_config.plane_list) {
-		intel_plane = to_intel_plane(plane);
-		if (intel_plane->pipe == pipe)
-			intel_plane_restore(&intel_plane->base);
-	}
-}
-
 void hsw_enable_ips(struct intel_crtc *crtc)
 {
 	struct drm_device *dev = crtc->base.dev;
@@ -4830,27 +4794,6 @@ static void intel_pre_plane_update(struct intel_crtc *crtc)
 		intel_pre_disable_primary(&crtc->base);
 }
 
-static void intel_crtc_enable_planes(struct drm_crtc *crtc)
-{
-	struct drm_device *dev = crtc->dev;
-	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
-	int pipe = intel_crtc->pipe;
-
-	intel_enable_primary_hw_plane(crtc->primary, crtc);
-	intel_enable_sprite_planes(crtc);
-	if (to_intel_plane_state(crtc->cursor->state)->visible)
-		intel_crtc_update_cursor(crtc, true);
-
-	intel_post_enable_primary(crtc);
-
-	/*
-	 * FIXME: Once we grow proper nuclear flip support out of this we need
-	 * to compute the mask of flip planes precisely. For the time being
-	 * consider this a flip to a NULL plane.
-	 */
-	intel_frontbuffer_flip(dev, INTEL_FRONTBUFFER_ALL_MASK(pipe));
-}
-
 static void intel_crtc_disable_planes(struct drm_crtc *crtc, unsigned plane_mask)
 {
 	struct drm_device *dev = crtc->dev;
@@ -4861,10 +4804,6 @@ static void intel_crtc_disable_planes(struct drm_crtc *crtc, unsigned plane_mask
 	if (!intel_crtc->active)
 		return;
 
-	intel_crtc_wait_for_pending_flips(crtc);
-
-	intel_pre_disable_primary(crtc);
-
 	intel_crtc_dpms_overlay_disable(intel_crtc);
 
 	drm_for_each_plane_mask(p, dev, plane_mask)
@@ -6288,6 +6227,11 @@ static void intel_crtc_disable_noatomic(struct drm_crtc *crtc)
 	if (!intel_crtc->active)
 		return;
 
+	if (to_intel_plane_state(crtc->primary->state)->visible) {
+		intel_crtc_wait_for_pending_flips(crtc);
+		intel_pre_disable_primary(crtc);
+	}
+
 	intel_crtc_disable_planes(crtc, crtc->state->plane_mask);
 	dev_priv->display.crtc_disable(crtc);
 
@@ -11804,10 +11748,6 @@ int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
 	if (old_plane_state->base.fb && !fb)
 		intel_crtc->atomic.disabled_planes |= 1 << i;
 
-	/* don't run rest during modeset yet */
-	if (!intel_crtc->active || mode_changed)
-		return 0;
-
 	was_visible = old_plane_state->visible;
 	visible = to_intel_plane_state(plane_state)->visible;
 
@@ -13265,15 +13205,18 @@ static int __intel_set_mode(struct drm_atomic_state *state)
 	drm_atomic_helper_swap_state(dev, state);
 
 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
+		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+
 		if (!needs_modeset(crtc->state))
 			continue;
 
 		any_ms = true;
-		if (!crtc_state->active)
-			continue;
+		intel_pre_plane_update(intel_crtc);
 
-		intel_crtc_disable_planes(crtc, crtc_state->plane_mask);
-		dev_priv->display.crtc_disable(crtc);
+		if (crtc_state->active) {
+			intel_crtc_disable_planes(crtc, crtc_state->plane_mask);
+			dev_priv->display.crtc_disable(crtc);
+		}
 	}
 
 	/* Only after disabling all output pipelines that will be changed can we
@@ -13287,14 +13230,11 @@ static int __intel_set_mode(struct drm_atomic_state *state)
 
 	/* Now enable the clocks, plane, pipe, and connectors that we set up. */
 	for_each_crtc_in_state(state, crtc, crtc_state, i) {
-		if (!needs_modeset(crtc->state) || !crtc->state->active) {
-			drm_atomic_helper_commit_planes_on_crtc(crtc_state);
-			continue;
+		if (needs_modeset(crtc->state) && crtc->state->active) {
+			update_scanline_offset(to_intel_crtc(crtc));
+			dev_priv->display.crtc_enable(crtc);
 		}
 
-		update_scanline_offset(to_intel_crtc(crtc));
-
-		dev_priv->display.crtc_enable(crtc);
 		drm_atomic_helper_commit_planes_on_crtc(crtc_state);
 	}
 
@@ -13862,7 +13802,7 @@ intel_commit_primary_plane(struct drm_plane *plane,
 	crtc->x = src->x1 >> 16;
 	crtc->y = src->y1 >> 16;
 
-	if (!intel_crtc->active)
+	if (!crtc->state->active)
 		return;
 
 	if (state->visible)
@@ -13888,7 +13828,8 @@ static void intel_begin_crtc_commit(struct drm_crtc *crtc)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 
-	intel_pre_plane_update(intel_crtc);
+	if (!needs_modeset(crtc->state))
+		intel_pre_plane_update(intel_crtc);
 
 	if (intel_crtc->atomic.update_wm)
 		intel_update_watermarks(crtc);
@@ -13896,7 +13837,7 @@ static void intel_begin_crtc_commit(struct drm_crtc *crtc)
 	intel_runtime_pm_get(dev_priv);
 
 	/* Perform vblank evasion around commit operation */
-	if (crtc->state->active && !needs_modeset(crtc->state))
+	if (crtc->state->active)
 		intel_crtc->atomic.evade =
 			intel_pipe_update_start(intel_crtc,
 						&intel_crtc->atomic.start_vbl_count);
@@ -14104,7 +14045,7 @@ intel_commit_cursor_plane(struct drm_plane *plane,
 	intel_crtc->cursor_bo = obj;
 
 update:
-	if (intel_crtc->active)
+	if (crtc->state->active)
 		intel_crtc_update_cursor(crtc, state->visible);
 }
 
diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c
index 699311a..b605ad8 100644
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@ -924,16 +924,14 @@ intel_commit_sprite_plane(struct drm_plane *plane,
 			  struct intel_plane_state *state)
 {
 	struct drm_crtc *crtc = state->base.crtc;
-	struct intel_crtc *intel_crtc;
 	struct intel_plane *intel_plane = to_intel_plane(plane);
 	struct drm_framebuffer *fb = state->base.fb;
 
 	crtc = crtc ? crtc : plane->crtc;
-	intel_crtc = to_intel_crtc(crtc);
 
 	plane->fb = fb;
 
-	if (!intel_crtc->active)
+	if (!crtc->state->active)
 		return;
 
 	if (state->visible) {
-- 
1.7.5.4

