From 4a875a36f05df6fff8fff2c8e8f2dd747b02ab13 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Thu, 23 Jul 2015 15:08:43 +0300
Subject: [PATCH 2353/2508] mei: bus: enable running fixup routines before
 device registration

commit 71ce789115f878a07e4a6c43d6006cea6aee1078 upstream

Split the device registration into allocation and device struct
initialization, device setup, and the final device registration.
This why it is possible to run fixups and quirks during the setup stage
on an initialized device. Each fixup routine effects do_match flag.
If the flag is set to false at the end the device won't be
registered on the bus.

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/misc/mei/bus-fixup.c |   30 ++++++++++++++
 drivers/misc/mei/bus.c       |   91 +++++++++++++++++++++++++++++++++++-------
 drivers/misc/mei/mei_dev.h   |    2 +-
 include/linux/mei_cl_bus.h   |    4 ++
 4 files changed, 111 insertions(+), 16 deletions(-)

diff --git a/drivers/misc/mei/bus-fixup.c b/drivers/misc/mei/bus-fixup.c
index 47aa152..865e33b 100644
--- a/drivers/misc/mei/bus-fixup.c
+++ b/drivers/misc/mei/bus-fixup.c
@@ -20,12 +20,15 @@
 #include <linux/moduleparam.h>
 #include <linux/device.h>
 #include <linux/slab.h>
+#include <linux/uuid.h>
 
 #include <linux/mei_cl_bus.h>
 
 #include "mei_dev.h"
 #include "client.h"
 
+#define MEI_UUID_ANY NULL_UUID_LE
+
 struct mei_nfc_cmd {
 	u8 command;
 	u8 status;
@@ -412,4 +415,31 @@ void mei_nfc_host_exit(struct mei_device *bus)
 	mutex_unlock(&bus->device_lock);
 }
 
+#define MEI_FIXUP(_uuid, _hook) { _uuid, _hook }
+
+static struct mei_fixup {
+
+	const uuid_le uuid;
+	void (*hook)(struct mei_cl_device *cldev);
+} mei_fixups[] = {};
+
+/**
+ * mei_cl_dev_fixup - run fixup handlers
+ *
+ * @cldev: me client device
+ */
+void mei_cl_dev_fixup(struct mei_cl_device *cldev)
+{
+	struct mei_fixup *f;
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mei_fixups); i++) {
+
+		f = &mei_fixups[i];
+		if (uuid_le_cmp(f->uuid, MEI_UUID_ANY) == 0 ||
+		    uuid_le_cmp(f->uuid, *uuid) == 0)
+			f->hook(cldev);
+	}
+}
 
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 34b14dd..68b7756 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -436,6 +436,9 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 	if (!cldev)
 		return 0;
 
+	if (!cldev->do_match)
+		return 0;
+
 	if (!cldrv || !cldrv->id_table)
 		return 0;
 
@@ -634,6 +637,76 @@ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
 	return NULL;
 }
 
+/**
+ * mei_cl_dev_alloc - initialize and allocate mei client device
+ *
+ * @bus: mei device
+ * @me_cl: me client
+ *
+ * Return: allocated device structur or NULL on allocation failure
+ */
+static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
+					      struct mei_me_client *me_cl)
+{
+	struct mei_cl_device *cldev;
+
+	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!cldev)
+		return NULL;
+
+	device_initialize(&cldev->dev);
+	cldev->dev.parent = bus->dev;
+	cldev->dev.bus    = &mei_cl_bus_type;
+	cldev->dev.type   = &mei_cl_device_type;
+	cldev->bus        = mei_dev_bus_get(bus);
+	cldev->me_cl      = mei_me_cl_get(me_cl);
+	cldev->is_added   = 0;
+	INIT_LIST_HEAD(&cldev->bus_list);
+
+	return cldev;
+}
+
+/**
+ * mei_cl_dev_setup - setup me client device
+ *    run fix up routines and set the device name
+ *
+ * @bus: mei device
+ * @cldev: me client device
+ *
+ * Return: true if the device is eligible for enumeration
+ */
+static bool mei_cl_dev_setup(struct mei_device *bus,
+			     struct mei_cl_device *cldev)
+{
+	cldev->do_match = 1;
+	mei_cl_dev_fixup(cldev);
+
+	if (cldev->do_match)
+		dev_set_name(&cldev->dev, "mei:%s:%pUl",
+			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+
+	return cldev->do_match == 1;
+}
+
+/**
+ * mei_cl_bus_dev_add - add me client devices
+ *
+ * @cldev: me client device
+ *
+ * Return: 0 on success; < 0 on failre
+ */
+static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+{
+	int ret;
+
+	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+	ret = device_add(&cldev->dev);
+	if (!ret)
+		cldev->is_added = 1;
+
+	return ret;
+}
+
 struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
@@ -642,28 +715,16 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 	struct mei_cl_device *cldev;
 	int status;
 
-	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	cldev = mei_cl_dev_alloc(bus, me_cl);
 	if (!cldev)
 		return NULL;
 
-	cldev->me_cl = mei_me_cl_get(me_cl);
-	if (!cldev->me_cl) {
-		kfree(cldev);
-		return NULL;
-	}
-
 	cldev->cl = cl;
-	cldev->dev.parent = bus->dev;
-	cldev->dev.bus = &mei_cl_bus_type;
-	cldev->dev.type = &mei_cl_device_type;
-	cldev->bus      = mei_dev_bus_get(bus);
-	INIT_LIST_HEAD(&cldev->bus_list);
-
 	strlcpy(cldev->name, name, sizeof(cldev->name));
 
-	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
+	mei_cl_dev_setup(bus, cldev);
 
-	status = device_register(&cldev->dev);
+	status = mei_cl_bus_dev_add(cldev);
 	if (status) {
 		dev_err(bus->dev, "Failed to register MEI device\n");
 		mei_me_cl_put(cldev->me_cl);
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 882e6f7..ad59ab7 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -335,7 +335,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_cl *cl,
 					char *name);
 void mei_cl_remove_device(struct mei_cl_device *cldev);
-
+void mei_cl_dev_fixup(struct mei_cl_device *dev);
 ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking);
 ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length);
diff --git a/include/linux/mei_cl_bus.h b/include/linux/mei_cl_bus.h
index 8523913..81ab56d 100644
--- a/include/linux/mei_cl_bus.h
+++ b/include/linux/mei_cl_bus.h
@@ -29,6 +29,8 @@ typedef void (*mei_cl_event_cb_t)(struct mei_cl_device *device,
  *	events (e.g. Rx buffer pending) notifications.
  * @event_context: event callback run context
  * @events: Events bitmask sent to the driver.
+ *
+ * @do_match: wheather device can be matched with a driver
  * @is_added: device is already scanned
  * @priv_data: client private data
  */
@@ -45,6 +47,8 @@ struct mei_cl_device {
 	mei_cl_event_cb_t event_cb;
 	void *event_context;
 	unsigned long events;
+
+	unsigned int do_match:1;
 	unsigned int is_added:1;
 
 	void *priv_data;
-- 
1.7.5.4

