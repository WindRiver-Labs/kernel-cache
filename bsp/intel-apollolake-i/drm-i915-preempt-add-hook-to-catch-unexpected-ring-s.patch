From 25fb7bc52b329745888dd692c46c9638c2003b06 Mon Sep 17 00:00:00 2001
From: Dave Gordon <david.s.gordon@intel.com>
Date: Fri, 8 Apr 2016 13:53:22 -0700
Subject: [PATCH 1368/2508] drm/i915/preempt: add hook to catch 'unexpected'
 ring submissions

commit e17f19e693344c7a52dee95d37b35e075d137735 from
https://github.com/01org/linux-apollolake-i

Author: John Harrison <John.C.Harrison@Intel.com>
Date:   Thu Apr 10 10:41:06 2014 +0100

The scheduler needs to know what each seqno that pops out of the ring is
referring to. This change adds a hook into the the 'submit some random
work that got forgotten about' clean up code to inform the scheduler
that a new seqno has been sent to the ring for some non-batch buffer
operation.

Reworked for latest scheduler+preemption by Dave Gordon: with the newer
implementation, knowing about untracked requests is merely helpful for
debugging rather than being mandatory, as we have already taken steps to
prevent untracked requests intruding at awkward moments!

v2: Removed unnecessary debug spew.

For: VIZ-2021
Signed-off-by: John Harrison <John.C.Harrison@Intel.com>
Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_gem.c       |    4 ++++
 drivers/gpu/drm/i915/i915_gpu_error.c |    2 ++
 drivers/gpu/drm/i915/i915_scheduler.c |   23 +++++++++++++++++++++++
 drivers/gpu/drm/i915/i915_scheduler.h |    1 +
 4 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index aad8b9a..f69a635 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -2679,6 +2679,10 @@ void __i915_add_request(struct drm_i915_gem_request *request,
 		WARN_ON(request->seqno != dev_priv->last_seqno);
 	}
 
+	/* Notify the scheduler, if it doesn't already track this request */
+	if (!request->scheduler_qe)
+		i915_scheduler_fly_request(request);
+
 	/* Record the position of the start of the request so that
 	 * should we detect the updated seqno part-way through the
 	 * GPU processing the request, we never over-estimate the
diff --git a/drivers/gpu/drm/i915/i915_gpu_error.c b/drivers/gpu/drm/i915/i915_gpu_error.c
index 1c413d5..b6a389ca 100644
--- a/drivers/gpu/drm/i915/i915_gpu_error.c
+++ b/drivers/gpu/drm/i915/i915_gpu_error.c
@@ -1376,6 +1376,8 @@ static void i915_gem_record_rings(struct drm_device *dev,
 				i915_gem_obj_ggtt_offset(request->ringbuf->obj);
 			erq->scheduler_state = !sqe ? 'u' :
 				i915_scheduler_queue_status_chr(sqe->status);
+			if (request->scheduler_flags & I915_REQ_SF_UNTRACKED)
+				erq->scheduler_state = 'U';
 		}
 	}
 }
diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index 49ca327..58ab495 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -290,6 +290,29 @@ static void i915_scheduler_node_fly(struct i915_scheduler_queue_entry *node)
 	}
 }
 
+/* An untracked request is being launched ... */
+void i915_scheduler_fly_request(struct drm_i915_gem_request *req)
+{
+	struct drm_i915_private *dev_priv = req->i915;
+	struct i915_scheduler *scheduler = dev_priv->scheduler;
+
+	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
+
+	/* This shouldn't happen */
+	WARN_ON(i915_scheduler_is_engine_busy(req->engine));
+
+	/* We don't expect to see nodes that are already tracked */
+	if (!WARN_ON(req->scheduler_qe)) {
+		/*
+		 * Untracked node (e.g. context initialisation batch buffer),
+		 * must not be inside scheduler submission path.
+		 */
+		WARN_ON((scheduler->flags[req->engine->id] & I915_SF_SUBMITTING));
+		scheduler->stats[req->engine->id].non_batch++;
+		req->scheduler_flags |= I915_REQ_SF_UNTRACKED;
+	}
+}
+
 static uint32_t i915_scheduler_count_flying(struct i915_scheduler *scheduler,
 					    struct intel_engine_cs *engine)
 {
diff --git a/drivers/gpu/drm/i915/i915_scheduler.h b/drivers/gpu/drm/i915/i915_scheduler.h
index 5d9549c..eabf10e 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.h
+++ b/drivers/gpu/drm/i915/i915_scheduler.h
@@ -190,6 +190,7 @@ bool i915_scheduler_is_engine_flying(struct intel_engine_cs *engine);
 bool i915_scheduler_is_engine_preempting(struct intel_engine_cs *engine);
 bool i915_scheduler_is_engine_busy(struct intel_engine_cs *engine);
 void i915_scheduler_work_handler(struct work_struct *work);
+void i915_scheduler_fly_request(struct drm_i915_gem_request *req);
 int i915_scheduler_flush(struct intel_engine_cs *engine, bool is_locked);
 int i915_scheduler_flush_stamp(struct intel_engine_cs *engine,
 			       unsigned long stamp, bool is_locked);
-- 
1.7.5.4

