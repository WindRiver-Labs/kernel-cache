From d089a12c479dad4a43d73a2fa129eda3b212863c Mon Sep 17 00:00:00 2001
From: Andrzej Datczuk <andrzej.datczuk@intel.com>
Date: Wed, 22 Jun 2016 13:51:50 +0200
Subject: [PATCH 1458/2508] drm/i915: Fix ref counting for RC6 WA BB
 alloc/dealloc

commit 78fa46f13cbf31e39d9c17af18db0faa7e018aea from
https://github.com/01org/linux-apollolake-i

This patch fixes incorrect states of RC6 WA BB allocation reference
counter which resulted in RC6 WA BB deallocation when there was stil
one client attached.

This change should eliminate error message 'RC6 WA BB not ready'
showing in logs from i915 kernel.

drm_gem_object_unreference changed to a locked version because
dev->struct_mutex is already grabbed there. The unlocked version
was trying to grab this mutex again when trying to free the gem object.

Signed-off-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_perfmon.c |   12 +++++-------
 1 files changed, 5 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_perfmon.c b/drivers/gpu/drm/i915/i915_perfmon.c
index 6356a99..76b84bf 100644
--- a/drivers/gpu/drm/i915/i915_perfmon.c
+++ b/drivers/gpu/drm/i915/i915_perfmon.c
@@ -589,8 +589,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 			PAGE_SIZE, PIN_MAPPABLE);
 
 	if (ret) {
-		drm_gem_object_unreference_unlocked(
-			&dev_priv->rc6_wa_bb.obj->base);
+		drm_gem_object_unreference(&dev_priv->rc6_wa_bb.obj->base);
 		goto unlock;
 	}
 
@@ -598,8 +597,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 						true);
 	if (ret) {
 		i915_gem_object_ggtt_unpin(dev_priv->rc6_wa_bb.obj);
-		drm_gem_object_unreference_unlocked(
-			&dev_priv->rc6_wa_bb.obj->base);
+		drm_gem_object_unreference(&dev_priv->rc6_wa_bb.obj->base);
 		goto unlock;
 	}
 
@@ -612,8 +610,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 
 	if (!dev_priv->rc6_wa_bb.address) {
 		i915_gem_object_ggtt_unpin(dev_priv->rc6_wa_bb.obj);
-		drm_gem_object_unreference_unlocked(
-			&dev_priv->rc6_wa_bb.obj->base);
+		drm_gem_object_unreference(&dev_priv->rc6_wa_bb.obj->base);
 		ret =  -ENOMEM;
 		goto unlock;
 	}
@@ -627,6 +624,7 @@ static int allocate_wa_bb(struct drm_i915_private *dev_priv)
 
 unlock:
 	if (ret) {
+		atomic_dec(&dev_priv->rc6_wa_bb.enable);
 		dev_priv->rc6_wa_bb.obj = NULL;
 		dev_priv->rc6_wa_bb.offset = 0;
 	}
@@ -644,7 +642,7 @@ static void deallocate_wa_bb(struct drm_i915_private *dev_priv)
 	if (atomic_read(&dev_priv->rc6_wa_bb.enable) == 0)
 		goto unlock;
 
-	if (atomic_dec_return(&dev_priv->rc6_wa_bb.enable) > 1)
+	if (atomic_dec_return(&dev_priv->rc6_wa_bb.enable) > 0)
 		goto unlock;
 
 	I915_WRITE(GEN8_RC6_WA_BB, 0);
-- 
1.7.5.4

