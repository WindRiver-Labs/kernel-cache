From 7ca8fdfc5f743cdffe15e1feb817c990d4504821 Mon Sep 17 00:00:00 2001
From: Jayachandran B <jayachandran.b@intel.com>
Date: Wed, 30 Sep 2015 17:09:18 +0530
Subject: [PATCH 1842/2508] ASoC: Intel: Skylake: DSP bootup/shut down
 sequence updates

commit 7eaf08d1910c76001001b5c3845aee36383d79d0 from
https://github.com/01org/linux-apollolake-i

This patch does the following:
1. The BXT DSP initial boot up sequence is modified to conform to
   the recommended sequence by FW.
2. The functions that manipulate the DSP control/status register
   (ADSPCS) are modified to operate based on a given core mask
   This will be useful to turn on/off individual cores.
3. The D0/D3 functions are modified to operate based on a
   given core id.
4. Added get_core/put_core APIs to power up/power down cores.

Change-Id: I1e578530fa363b3774c16d0f8d60b530d04e94b6
Signed-off-by: Jayachandran B <jayachandran.b@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/7975
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/common/sst-dsp-priv.h |    9 ++
 sound/soc/intel/skylake/bxt-sst.c     |  173 +++++++++++++++--------
 sound/soc/intel/skylake/cnl-sst.c     |   29 ++--
 sound/soc/intel/skylake/skl-sst-dsp.c |  257 +++++++++++++++++++++++----------
 sound/soc/intel/skylake/skl-sst-dsp.h |   78 +++++++----
 sound/soc/intel/skylake/skl-sst.c     |   91 ++++++++----
 6 files changed, 426 insertions(+), 211 deletions(-)

diff --git a/sound/soc/intel/common/sst-dsp-priv.h b/sound/soc/intel/common/sst-dsp-priv.h
index fd456fb..4c4ace6 100644
--- a/sound/soc/intel/common/sst-dsp-priv.h
+++ b/sound/soc/intel/common/sst-dsp-priv.h
@@ -259,6 +259,14 @@ struct sst_mem_block {
 	struct list_head list;		/* Map list of free/used blocks */
 };
 
+#define SKL_DSP_MAX_CORES  4
+
+struct skl_dsp_core_info {
+	unsigned int cores; /* Number of DSP cores on the SoC */
+	int core_state[SKL_DSP_MAX_CORES];
+	int core_usage_count[SKL_DSP_MAX_CORES];
+};
+
 /*
  * Generic SST Shim Interface.
  */
@@ -320,6 +328,7 @@ struct sst_dsp {
 	u32 intr_status;
 	const struct firmware *fw;
 	struct snd_dma_buffer dmab;
+	struct skl_dsp_core_info core_info;
 #if IS_ENABLED(CONFIG_SND_SOC_INTEL_CNL_FPGA)
         struct snd_dma_buffer dsp_fw_buf;
 #endif
diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 3868912..dc70c86 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -53,8 +53,8 @@
 #define BXT_ADSP_W1_SZ  0x1000
 
 static int bxt_load_base_firmware(struct sst_dsp *ctx);
-static int bxt_set_dsp_D0(struct sst_dsp *ctx);
-static int bxt_set_dsp_D3(struct sst_dsp *ctx);
+static int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id);
+static int bxt_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id);
 static int bxt_load_library(struct sst_dsp *ctx,
 		struct skl_dfw_manifest *minfo);
 
@@ -127,6 +127,8 @@ int bxt_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 	if (ret)
 		return ret;
 
+	sst->core_info.cores = 2;
+
 	skl->boot_complete = false;
 	init_waitqueue_head(&skl->boot_wait);
 
@@ -205,26 +207,36 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 	u32 reg;
 	int stream_tag;
 
-	dev_dbg(ctx->dev, "starting to prepare host dma fwsize=%x\n", fwsize);
+	dev_dbg(ctx->dev, "starting to prepare host dma: fwsize=%d\n", fwsize);
 	stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fwsize, &ctx->dmab);
-	if (stream_tag < 0) {
-		dev_err(ctx->dev, "Failed to prepare DMA engine for FW loading, err: %x\n", stream_tag);
+	if (stream_tag <= 0) {
+		dev_err(ctx->dev, "Failed to prepare DMA engine for FW loading, err: %d\n", stream_tag);
 		return stream_tag;
 	}
 
 	ctx->dsp_ops.stream_tag = stream_tag;
 	memcpy(ctx->dmab.area, fwdata, fwsize);
-	/* Purge FW request */
+
+	/* Step 1: Power up core0 */
+	ret = skl_dsp_core_power_up(ctx, SKL_DSP_CORE0_MASK);
+	if (ret < 0)
+		goto prepare_fw_load_failed;
+
+	/* Step 2: Purge FW request */
 	sst_dsp_shim_write(ctx, SKL_ADSP_REG_HIPCI, SKL_ADSP_REG_HIPCI_BUSY |
 					 BXT_IPC_PURGE_FW | (stream_tag - 1));
 
-	ret = skl_dsp_enable_core(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "Boot dsp core failed ret: %d\n", ret);
-		ret = -EIO;
-		goto base_fw_load_failed;
-	}
+	/* Step 3: Unset core0 reset state */
+	ret = skl_dsp_core_unset_reset_state(ctx, SKL_DSP_CORE0_MASK);
+	if (ret < 0)
+		goto prepare_fw_load_failed;
 
+	/* Step 4: unstall/run core0 */
+	dev_dbg(ctx->dev, "unstall/run core0...");
+	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
+			SKL_ADSPCS_CSTALL_MASK(SKL_DSP_CORE0_MASK), 0);
+
+	/* Step 5: Wait for DONE Bit */
 	for (i = BXT_ROM_INIT_HIPCIE_TIMEOUT; i > 0; --i) {
 		reg = sst_dsp_shim_read(ctx, SKL_ADSP_REG_HIPCIE);
 
@@ -245,10 +257,12 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 				SKL_ADSP_REG_HIPCIE_DONE);
 	}
 	dev_dbg(ctx->dev, "******HIPCIE reg: 0x%x\n", reg);
-	/*enable Interrupt */
+
+	/* Step 6: enable Interrupt */
 	skl_ipc_int_enable(ctx);
 	skl_ipc_op_int_enable(ctx);
 
+	/* Step 7: Wait for ROM init */
 	for (i = BXT_ROM_INIT_DONE_TIMEOUT; i > 0; --i) {
 		if (FW_ROM_INIT_DONE ==
 			(sst_dsp_shim_read(ctx, BXT_ADSP_REG_FW_STATUS) &
@@ -261,12 +275,14 @@ static int sst_bxt_prepare_fw(struct sst_dsp *ctx, const void *fwdata,
 	if (!i) {
 		dev_err(ctx->dev, "Timeout waiting for ROM init done, reg: 0x%x\n", reg);
 		ret = -EIO;
-		goto base_fw_load_failed;
+		goto prepare_fw_load_failed;
 	}
-	return ret;
-base_fw_load_failed:
+
+	return 0;
+
+prepare_fw_load_failed:
 	ctx->dsp_ops.cleanup(ctx->dev, &ctx->dmab, stream_tag);
-	skl_dsp_disable_core(ctx);
+	skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 	return ret;
 }
 
@@ -286,69 +302,108 @@ static int sst_transfer_fw_host_dma(struct sst_dsp *ctx)
 	return ret;
 }
 
-int bxt_set_dsp_D0(struct sst_dsp *ctx)
+int bxt_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 {
-	int ret = 0;
+	int ret;
+	struct skl_ipc_dxstate_info dx;
 	struct skl_sst *skl = ctx->thread_context;
+	unsigned int core_mask = SKL_DSP_CORE_MASK(core_id);
 
-	dev_dbg(ctx->dev, "In %s:\n", __func__);
 
-	skl->boot_complete = false;
+	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
 
-	ret = skl_dsp_enable_core(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "enable dsp core failed ret: %d\n", ret);
-		return ret;
+	ret = skl_dsp_core_power_up(ctx, core_mask);
+	if (ret < 0)
+		goto err;
+
+	if (core_id == SKL_DSP_CORE0_ID) {
+		dev_dbg(ctx->dev, "Enable Interrupts\n");
+		/* Enable interrupt after SPA is set and before DSP is unstalled */
+		skl_ipc_int_enable(ctx);
+		skl_ipc_op_int_enable(ctx);
+		skl->boot_complete = false;
 	}
 
-	/*enable interrupt*/
-	skl_ipc_int_enable(ctx);
-	skl_ipc_op_int_enable(ctx);
+	ret = skl_dsp_start_core(ctx, core_mask);
+	if (ret < 0)
+		goto err;
 
-	ret = wait_event_timeout(skl->boot_wait, skl->boot_complete,
-					msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
-	if (ret == 0) {
-		dev_err(ctx->dev, "ipc: error DSP boot timeout\n");
-		dev_err(ctx->dev, "Error code=0x%x: FW status=0x%x\n",
-			sst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),
-			sst_dsp_shim_read(ctx, BXT_ADSP_REG_FW_STATUS));
-		return -EIO;
+	if (core_id == SKL_DSP_CORE0_ID) {
+		ret = wait_event_timeout(skl->boot_wait,
+				skl->boot_complete,
+				msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
+
+		if (ret == 0) {
+			dev_err(ctx->dev, "%s: error DSP boot timeout\n", __func__);
+			dev_err(ctx->dev, "Error code=0x%x: FW status=0x%x\n",
+					sst_dsp_shim_read(ctx, BXT_ADSP_ERROR_CODE),
+					sst_dsp_shim_read(ctx, BXT_ADSP_REG_FW_STATUS));
+			dev_err(ctx->dev, "Failed to set core0 to D0 state\n");
+			ret = -EIO;
+			goto err;
+		}
 	}
 
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+	/*
+	 * If any core other than core 0 is being moved to D0, send the
+	 * set dx IPC for the core.
+	 * NOTE: As per the current BXT FW implementation, set dx can be
+	 * sent for core 0 also though set dx is not necessary for core 0. So
+	 * the following check for other cores is not strictly needed for BXT.
+	 * However, set dx is not being sent for core 0 in the following code
+	 * in order not to make any assumption about set dx support for core 0
+	 * in FW for platforms that may reuse this driver.
+	 */
+	if (core_id != SKL_DSP_CORE0_ID) {
+		dx.core_mask = core_mask;
+		dx.dx_mask = core_mask;
+
+		ret = skl_ipc_set_dx(&skl->ipc, BXT_INSTANCE_ID,
+					BXT_BASE_FW_MODULE_ID, &dx);
+		if (ret < 0) {
+			dev_err(ctx->dev, "Failed to set dsp to D0:core id = %d\n",
+					core_id);
+			goto err;
+		}
+	}
+
+	ctx->core_info.core_state[core_id] = SKL_DSP_RUNNING;
 	return 0;
+err:
+	skl_dsp_disable_core(ctx, core_mask);
+	return ret;
 }
 
-static int bxt_set_dsp_D3(struct sst_dsp *ctx)
+static int bxt_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)
 {
-	int ret = 0;
+	int ret;
 	struct skl_ipc_dxstate_info dx;
 	struct skl_sst *skl = ctx->thread_context;
+	unsigned int core_mask = SKL_DSP_CORE_MASK(core_id);
 
-	dev_dbg(ctx->dev, "In %s:\n", __func__);
+	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
 
-	if (!is_skl_dsp_running(ctx))
-		return ret;
-
-	dx.core_mask = SKL_DSP_CORE0_MASK;
-	dx.dx_mask = SKL_IPC_D3_MASK;
+	dx.core_mask = core_mask;
+	dx.dx_mask = 0;
 
 	dev_dbg(ctx->dev, "core mask=%x dx_mask=%x\n",
-				 dx.core_mask, dx.dx_mask);
-	ret = skl_ipc_set_dx(&skl->ipc, BXT_INSTANCE_ID, BXT_BASE_FW_MODULE_ID, &dx);
+			dx.core_mask, dx.dx_mask);
 
-	if (ret < 0) {
-		dev_err(ctx->dev, "Failed to set DSP to D3 state\n");
+	ret = skl_ipc_set_dx(&skl->ipc, BXT_INSTANCE_ID,
+				BXT_BASE_FW_MODULE_ID, &dx);
+	if (ret < 0)
+		dev_err(ctx->dev,
+			"Failed to set DSP to D3:core id = %d;Continue reset\n",
+			core_id);
+
+	ret = skl_dsp_disable_core(ctx, core_mask);
+
+	if (ret < 0)
 		return ret;
-	}
 
-	ret = skl_dsp_disable_core(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "disbale dsp core failed ret: %d\n", ret);
-		ret = -EIO;
-	}
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RESET);
+	ctx->core_info.core_state[core_id] = SKL_DSP_RESET;
 	return 0;
+
 }
 
 static int bxt_load_base_firmware(struct sst_dsp *ctx)
@@ -391,17 +446,17 @@ static int bxt_load_base_firmware(struct sst_dsp *ctx)
 
 	if (ret < 0) {
 		dev_err(ctx->dev, "Transfer firmware failed %d\n", ret);
-		skl_dsp_disable_core(ctx);
+		skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 	} else {
 		dev_dbg(ctx->dev, "Firmware download successful\n");
 		ret = wait_event_timeout(skl->boot_wait, skl->boot_complete,
 						msecs_to_jiffies(SKL_IPC_BOOT_MSECS));
 		if (ret == 0) {
 			dev_err(ctx->dev, "DSP boot failed, FW Ready timed-out\n");
-			skl_dsp_disable_core(ctx);
+			skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 			ret = -EIO;
 		} else {
-			skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+			skl_dsp_init_core_state(ctx);
 			ret = 0;
 		}
 	}
diff --git a/sound/soc/intel/skylake/cnl-sst.c b/sound/soc/intel/skylake/cnl-sst.c
index f8baec8..90cb2b4 100644
--- a/sound/soc/intel/skylake/cnl-sst.c
+++ b/sound/soc/intel/skylake/cnl-sst.c
@@ -281,7 +281,7 @@ static int cnl_load_base_firmware(struct sst_dsp *ctx)
 			ret = -EIO;
 		} else {
 
-			skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+			skl_dsp_init_core_state(ctx);
 			ret = 0;
 		}
 	}
@@ -291,7 +291,7 @@ cnl_load_base_firmware_failed:
 	return ret;
 }
 
-static int cnl_set_dsp_D0(struct sst_dsp *ctx)
+static int cnl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret = 0;
 	struct skl_sst *cnl = ctx->thread_context;
@@ -317,23 +317,17 @@ static int cnl_set_dsp_D0(struct sst_dsp *ctx)
 		return -EIO;
 	}
 
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+	ctx->core_info.core_state[core_id] = SKL_DSP_RUNNING;
 	return 0;
 }
 
-static int cnl_set_dsp_D3(struct sst_dsp *ctx)
+static int cnl_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret;
 	struct skl_ipc_dxstate_info dx;
 	struct skl_sst *cnl = ctx->thread_context;
 
 	dev_dbg(ctx->dev, "In %s:\n", __func__);
-	mutex_lock(&ctx->mutex);
-	if (!is_skl_dsp_running(ctx)) {
-		mutex_unlock(&ctx->mutex);
-		return 0;
-	}
-	mutex_unlock(&ctx->mutex);
 
 	dx.core_mask = CNL_DSP_CORES_MASK;
 	dx.dx_mask = SKL_IPC_D3_MASK;
@@ -341,17 +335,18 @@ static int cnl_set_dsp_D3(struct sst_dsp *ctx)
 			     CNL_INSTANCE_ID,
 			     CNL_BASE_FW_MODULE_ID,
 			     &dx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "Failed to set DSP to D3 state\n");
-		return ret;
-	}
+	if (ret < 0)
+		dev_err(ctx->dev,
+			"Failed to set DSP to D3:core id = %d;Continue reset\n",
+			core_id);
 
 	ret = cnl_dsp_disable_core(ctx);
 	if (ret < 0) {
 		dev_err(ctx->dev, "disable dsp core failed: %d\n", ret);
-		ret = -EIO;
+		return -EIO;
 	}
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RESET);
+
+	ctx->core_info.core_state[core_id] = SKL_DSP_RESET;
 
 	return ret;
 }
@@ -535,6 +530,8 @@ int cnl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 	if (ret)
 		return ret;
 
+	sst->core_info.cores = 4;
+
 	cnl->boot_complete = false;
 	init_waitqueue_head(&cnl->boot_wait);
 
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.c b/sound/soc/intel/skylake/skl-sst-dsp.c
index 215dd44..159c6db 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.c
+++ b/sound/soc/intel/skylake/skl-sst-dsp.c
@@ -27,192 +27,243 @@
 #define SKL_DSP_PD_TO		50
 #define SKL_DSP_RESET_TO	50
 
-void skl_dsp_set_state_locked(struct sst_dsp *ctx, int state)
+/* Initialize core power state and usage count. To be called after successful
+ * first boot. Hence core 0 will be running and other cores will be reset
+ */
+void skl_dsp_init_core_state(struct sst_dsp *ctx)
 {
-	mutex_lock(&ctx->mutex);
-	ctx->sst_state = state;
-	mutex_unlock(&ctx->mutex);
+	int i;
+
+	ctx->core_info.core_state[SKL_DSP_CORE0_ID] = SKL_DSP_RUNNING;
+	ctx->core_info.core_usage_count[SKL_DSP_CORE0_ID] = 1;
+
+	for (i = SKL_DSP_CORE0_ID + 1; i < SKL_DSP_MAX_CORES; i++) {
+		ctx->core_info.core_state[i] = SKL_DSP_RESET;
+		ctx->core_info.core_usage_count[i] = 0;
+	}
+}
+
+/* Get the mask for all enabled cores */
+unsigned int skl_dsp_get_enabled_cores(struct sst_dsp  *ctx)
+{
+	u32 val;
+	unsigned int core_mask;
+	unsigned en_cores_mask;
+
+	core_mask = SKL_DSP_CORES_MASK(ctx->core_info.cores);
+
+	val = sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS);
+
+	/* Cores having CPA bit set */
+	en_cores_mask = (val & SKL_ADSPCS_CPA_MASK(core_mask)) >> SKL_ADSPCS_CPA_SHIFT;
+	/* And cores having CRST bit cleared */
+	en_cores_mask &= (~val & SKL_ADSPCS_CRST_MASK(core_mask)) >> SKL_ADSPCS_CRST_SHIFT;
+	/* And cores having CSTALL bit cleared */
+	en_cores_mask &= (~val & SKL_ADSPCS_CSTALL_MASK(core_mask)) >> SKL_ADSPCS_CSTALL_SHIFT;
+	en_cores_mask &= core_mask;
+
+	dev_dbg(ctx->dev, "DSP enabled cores mask = %x\n", en_cores_mask);
+
+	return en_cores_mask;
 }
 
-static int skl_dsp_core_set_reset_state(struct sst_dsp  *ctx)
+static int skl_dsp_core_set_reset_state(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int ret;
 
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
+
 	/* update bits */
 	sst_dsp_shim_update_bits_unlocked(ctx,
-			SKL_ADSP_REG_ADSPCS, SKL_ADSPCS_CRST_MASK,
-			SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK));
+			SKL_ADSP_REG_ADSPCS, SKL_ADSPCS_CRST_MASK(core_mask),
+			SKL_ADSPCS_CRST_MASK(core_mask));
 
 	/* poll with timeout to check if operation successful */
 	ret = sst_dsp_register_poll(ctx,
 			SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CRST_MASK,
-			SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK),
+			SKL_ADSPCS_CRST_MASK(core_mask),
+			SKL_ADSPCS_CRST_MASK(core_mask),
 			SKL_DSP_RESET_TO,
 			"Set reset");
 	if ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &
-				SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK)) !=
-				SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK)) {
-		dev_err(ctx->dev, "Set reset state failed\n");
+				SKL_ADSPCS_CRST_MASK(core_mask)) !=
+				SKL_ADSPCS_CRST_MASK(core_mask)) {
+		dev_err(ctx->dev, "Set reset state failed; core_mask = %x\n",
+				core_mask);
 		ret = -EIO;
 	}
 
 	return ret;
 }
 
-static int skl_dsp_core_unset_reset_state(struct sst_dsp  *ctx)
+int skl_dsp_core_unset_reset_state(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int ret;
 
-	dev_dbg(ctx->dev, "In %s\n", __func__);
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 
 	/* update bits */
 	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
-					SKL_ADSPCS_CRST_MASK, 0);
+			SKL_ADSPCS_CRST_MASK(core_mask), 0);
 
 	/* poll with timeout to check if operation successful */
 	ret = sst_dsp_register_poll(ctx,
 			SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CRST_MASK,
+			SKL_ADSPCS_CRST_MASK(core_mask),
 			0,
 			SKL_DSP_RESET_TO,
 			"Unset reset");
 
 	if ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &
-				 SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK)) != 0) {
-		dev_err(ctx->dev, "Unset reset state failed\n");
+				SKL_ADSPCS_CRST_MASK(core_mask)) != 0) {
+		dev_err(ctx->dev, "Unset reset state failed; core_mask = %x\n",
+				core_mask);
 		ret = -EIO;
 	}
 
 	return ret;
 }
 
-static bool is_skl_dsp_core_enable(struct sst_dsp  *ctx)
+static bool is_skl_dsp_core_enable(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int val;
 	bool is_enable;
 
 	val = sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS);
 
-	is_enable = ((val & SKL_ADSPCS_CPA(SKL_DSP_CORES_MASK)) &&
-			(val & SKL_ADSPCS_SPA(SKL_DSP_CORES_MASK)) &&
-			!(val & SKL_ADSPCS_CRST(SKL_DSP_CORES_MASK)) &&
-			!(val & SKL_ADSPCS_CSTALL(SKL_DSP_CORES_MASK)));
 
-	dev_dbg(ctx->dev, "DSP core is enabled=%d\n", is_enable);
+	is_enable = ((val & SKL_ADSPCS_CPA_MASK(core_mask)) &&
+			(val & SKL_ADSPCS_SPA_MASK(core_mask)) &&
+			!(val & SKL_ADSPCS_CRST_MASK(core_mask)) &&
+			!(val & SKL_ADSPCS_CSTALL_MASK(core_mask)));
+
+	dev_dbg(ctx->dev, "DSP core(s) enabled?=%d : core_mask = %x\n",
+			is_enable, core_mask);
 	return is_enable;
 }
 
-static int skl_dsp_reset_core(struct sst_dsp *ctx)
+static int skl_dsp_reset_core(struct sst_dsp *ctx, unsigned int core_mask)
 {
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 	/* stall core */
 	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CSTALL_MASK,
-			SKL_ADSPCS_CSTALL(SKL_DSP_CORES_MASK));
+			SKL_ADSPCS_CSTALL_MASK(core_mask),
+			SKL_ADSPCS_CSTALL_MASK(core_mask));
 
 	/* set reset state */
-	return skl_dsp_core_set_reset_state(ctx);
+	return skl_dsp_core_set_reset_state(ctx, core_mask);
 }
 
-static int skl_dsp_start_core(struct sst_dsp *ctx)
+int skl_dsp_start_core(struct sst_dsp *ctx, unsigned int core_mask)
 {
 	int ret;
 
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 	/* unset reset state */
-	ret = skl_dsp_core_unset_reset_state(ctx);
-	if (ret < 0) {
-		dev_dbg(ctx->dev, "dsp unset reset fails\n");
+	ret = skl_dsp_core_unset_reset_state(ctx, core_mask);
+	if (ret < 0)
 		return ret;
-	}
 
 	/* run core */
-	dev_dbg(ctx->dev, "run core...\n");
+	dev_dbg(ctx->dev, "unstall/run core: core_mask = %x\n", core_mask);
 	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CSTALL_MASK, 0);
+			SKL_ADSPCS_CSTALL_MASK(core_mask), 0);
 
-	if (!is_skl_dsp_core_enable(ctx)) {
-		skl_dsp_reset_core(ctx);
-		dev_err(ctx->dev, "DSP core enable failed\n");
+	if (!is_skl_dsp_core_enable(ctx, core_mask)) {
+		skl_dsp_reset_core(ctx, core_mask);
+		dev_err(ctx->dev, "DSP start core failed: core_mask = %x\n",
+				core_mask);
 		ret = -EIO;
 	}
 
 	return ret;
 }
 
-static int skl_dsp_core_power_up(struct sst_dsp  *ctx)
+int skl_dsp_core_power_up(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int ret;
 
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 	/* update bits */
 	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_SPA_MASK, SKL_ADSPCS_SPA(SKL_DSP_CORES_MASK));
+			SKL_ADSPCS_SPA_MASK(core_mask),
+			SKL_ADSPCS_SPA_MASK(core_mask));
 
 	/* poll with timeout to check if operation successful */
 	ret = sst_dsp_register_poll(ctx,
 			SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CPA_MASK,
-			SKL_ADSPCS_CPA(SKL_DSP_CORES_MASK),
+			SKL_ADSPCS_CPA_MASK(core_mask),
+			SKL_ADSPCS_CPA_MASK(core_mask),
 			SKL_DSP_PU_TO,
 			"Power up");
 
 	if ((sst_dsp_shim_read_unlocked(ctx, SKL_ADSP_REG_ADSPCS) &
-			SKL_ADSPCS_CPA(SKL_DSP_CORES_MASK)) !=
-			SKL_ADSPCS_CPA(SKL_DSP_CORES_MASK)) {
-		dev_err(ctx->dev, "DSP core power up failed\n");
+			SKL_ADSPCS_CPA_MASK(core_mask)) !=
+			SKL_ADSPCS_CPA_MASK(core_mask)) {
+		dev_err(ctx->dev, "DSP core power up failed: core_mask = %x\n",
+				core_mask);
 		ret = -EIO;
 	}
 
 	return ret;
 }
 
-static int skl_dsp_core_power_down(struct sst_dsp  *ctx)
+int skl_dsp_core_power_down(struct sst_dsp  *ctx, unsigned int core_mask)
 {
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 	/* update bits */
 	sst_dsp_shim_update_bits_unlocked(ctx, SKL_ADSP_REG_ADSPCS,
-					SKL_ADSPCS_SPA_MASK, 0);
+			SKL_ADSPCS_SPA_MASK(core_mask), 0);
 
 	/* poll with timeout to check if operation successful */
 	return sst_dsp_register_poll(ctx,
 			SKL_ADSP_REG_ADSPCS,
-			SKL_ADSPCS_CPA_MASK,
+			SKL_ADSPCS_CPA_MASK(core_mask),
 			0,
 			SKL_DSP_PD_TO,
 			"Power down");
 }
 
-int skl_dsp_enable_core(struct sst_dsp  *ctx)
+int skl_dsp_enable_core(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int ret;
 
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
 	/* power up */
-	ret = skl_dsp_core_power_up(ctx);
+	ret = skl_dsp_core_power_up(ctx, core_mask);
 	if (ret < 0) {
-		dev_dbg(ctx->dev, "dsp core power up failed\n");
+		dev_dbg(ctx->dev, "dsp core power up failed: core_mask = %x\n",
+				core_mask);
 		return ret;
 	}
 
-	return skl_dsp_start_core(ctx);
+	return skl_dsp_start_core(ctx, core_mask);
 }
 
-int skl_dsp_disable_core(struct sst_dsp  *ctx)
+int skl_dsp_disable_core(struct sst_dsp  *ctx, unsigned int core_mask)
 {
 	int ret;
 
-	ret = skl_dsp_reset_core(ctx);
+	dev_dbg(ctx->dev, "In %s : core_mask = %x\n", __func__, core_mask);
+
+	ret = skl_dsp_reset_core(ctx, core_mask);
 	if (ret < 0) {
-		dev_err(ctx->dev, "dsp core reset failed\n");
+		dev_err(ctx->dev, "dsp core reset failed: core_mask = %x\n",
+				core_mask);
 		return ret;
 	}
 
 	/* power down core*/
-	ret = skl_dsp_core_power_down(ctx);
+	ret = skl_dsp_core_power_down(ctx, core_mask);
 	if (ret < 0) {
-		dev_err(ctx->dev, "dsp core power down failed\n");
+		dev_err(ctx->dev, "dsp core power down failed:core_mask = %x\n",
+				core_mask);
 		return ret;
 	}
 
-	if (is_skl_dsp_core_enable(ctx)) {
-		dev_err(ctx->dev, "DSP core disable failed\n");
+	if (is_skl_dsp_core_enable(ctx, core_mask)) {
+		dev_err(ctx->dev, "DSP core disable failed: core_mask = %x\n",
+				core_mask);
 		ret = -EIO;
 	}
 
@@ -223,28 +274,28 @@ int skl_dsp_boot(struct sst_dsp *ctx)
 {
 	int ret;
 
-	if (is_skl_dsp_core_enable(ctx)) {
-		dev_dbg(ctx->dev, "dsp core is already enabled, so reset the dap core\n");
-		ret = skl_dsp_reset_core(ctx);
+	if (is_skl_dsp_core_enable(ctx, SKL_DSP_CORE0_MASK)) {
+		dev_dbg(ctx->dev, "dsp core0 already enabled,so reset core0\n");
+		ret = skl_dsp_reset_core(ctx, SKL_DSP_CORE0_MASK);
 		if (ret < 0) {
-			dev_err(ctx->dev, "dsp reset failed\n");
+			dev_err(ctx->dev, "dsp core0 reset failed\n");
 			return ret;
 		}
 
-		ret = skl_dsp_start_core(ctx);
+		ret = skl_dsp_start_core(ctx, SKL_DSP_CORE0_MASK);
 		if (ret < 0) {
-			dev_err(ctx->dev, "dsp start failed\n");
+			dev_err(ctx->dev, "dsp core0 start failed\n");
 			return ret;
 		}
 	} else {
-		dev_dbg(ctx->dev, "disable and enable to make sure DSP is invalid state\n");
-		ret = skl_dsp_disable_core(ctx);
+		dev_dbg(ctx->dev, "disable and enable to ensure DSP is in valid state\n");
+		ret = skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 
 		if (ret < 0) {
-			dev_err(ctx->dev, "dsp disable core failes\n");
+			dev_err(ctx->dev, "dsp core0 disable failed\n");
 			return ret;
 		}
-		ret = skl_dsp_enable_core(ctx);
+		ret = skl_dsp_enable_core(ctx, SKL_DSP_CORE0_MASK);
 	}
 
 	return ret;
@@ -280,16 +331,72 @@ irqreturn_t skl_dsp_sst_interrupt(int irq, void *dev_id)
 
 	return result;
 }
+/*
+ * skl_dsp_get_core/skl_dsp_put_core will be called inside DAPM context
+ * within the dapm mutex. Hence no separate lock is used.
+ */
+int skl_dsp_get_core(struct sst_dsp *ctx, unsigned int core_id)
+{
+	int ret = 0;
+
+	if (core_id >= ctx->core_info.cores) {
+		dev_err(ctx->dev, "invalid core id: %d\n", core_id);
+		return -EINVAL;
+	}
+
+	if (ctx->core_info.core_state[core_id] == SKL_DSP_RUNNING)
+		ctx->core_info.core_usage_count[core_id]++;
+	else if (ctx->core_info.core_state[core_id] == SKL_DSP_RESET) {
+		ret = ctx->fw_ops.set_state_D0(ctx, core_id);
+		if (ret < 0)
+			dev_err(ctx->dev, "unable to get core%d\n", core_id);
+		else
+			ctx->core_info.core_usage_count[core_id]++;
+	}
+	dev_info(ctx->dev, "%s:core id=%d:state=%d:usage_count=%d\n", __func__,
+			core_id, ctx->core_info.core_state[core_id],
+			ctx->core_info.core_usage_count[core_id]);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(skl_dsp_get_core);
+
+int skl_dsp_put_core(struct sst_dsp *ctx, unsigned int core_id)
+{
+	int ret = 0;
+
+	if (core_id >= ctx->core_info.cores) {
+		dev_err(ctx->dev, "invalid core id: %d\n", core_id);
+		return -EINVAL;
+	}
+
+	if (ctx->core_info.core_usage_count[core_id] > 1)
+		ctx->core_info.core_usage_count[core_id]--;
+	else {
+		ret = ctx->fw_ops.set_state_D3(ctx, core_id);
+		if (ret < 0)
+			dev_err(ctx->dev, "unable to put core%d\n", core_id);
+		else
+			ctx->core_info.core_usage_count[core_id]--;
+	}
+	dev_info(ctx->dev, "%s:core id=%d:state=%d:usage_count=%d\n", __func__,
+			core_id, ctx->core_info.core_state[core_id],
+			ctx->core_info.core_usage_count[core_id]);
+
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(skl_dsp_put_core);
 
 int skl_dsp_wake(struct sst_dsp *ctx)
 {
-	return ctx->fw_ops.set_state_D0(ctx);
+	return skl_dsp_get_core(ctx, SKL_DSP_CORE0_ID);
 }
 EXPORT_SYMBOL_GPL(skl_dsp_wake);
 
 int skl_dsp_sleep(struct sst_dsp *ctx)
 {
-	return ctx->fw_ops.set_state_D3(ctx);
+	return skl_dsp_put_core(ctx, SKL_DSP_CORE0_ID);
 }
 EXPORT_SYMBOL_GPL(skl_dsp_sleep);
 
@@ -335,12 +442,6 @@ void skl_dsp_free(struct sst_dsp *dsp)
 	skl_ipc_int_disable(dsp);
 
 	free_irq(dsp->irq, dsp);
-	skl_dsp_disable_core(dsp);
+	skl_dsp_disable_core(dsp, SKL_DSP_CORE0_MASK);
 }
 EXPORT_SYMBOL_GPL(skl_dsp_free);
-
-bool is_skl_dsp_running(struct sst_dsp *ctx)
-{
-	return (ctx->sst_state == SKL_DSP_RUNNING);
-}
-EXPORT_SYMBOL_GPL(is_skl_dsp_running);
diff --git a/sound/soc/intel/skylake/skl-sst-dsp.h b/sound/soc/intel/skylake/skl-sst-dsp.h
index c501106..e7f67f7 100644
--- a/sound/soc/intel/skylake/skl-sst-dsp.h
+++ b/sound/soc/intel/skylake/skl-sst-dsp.h
@@ -73,35 +73,52 @@ struct skl_dfw_manifest;
 #define SKL_ADSPIC_IPC			1
 #define SKL_ADSPIS_IPC			1
 
-/* ADSPCS - Audio DSP Control & Status */
-#define SKL_DSP_CORES		2
+/* Core ID of core0 */
+#define SKL_DSP_CORE0_ID		0
+
+/* Mask for a given core index, c; c = 0, 1.. number of supported cores - 1 */
+#define SKL_DSP_CORE_MASK(c)   (1 << (c))
+
+/*
+ * Core 0 mask = SKL_DSP_CORE_MASK(0); Defined separately
+ * since it is used often
+ */
 #define SKL_DSP_CORE0_MASK	1
-#define SKL_DSP_CORES_MASK	((1 << SKL_DSP_CORES) - 1)
 
-/* Core Reset - asserted high */
+/* Mask for a given number of cores, nc;
+ * in typical use, nc = number of supported cores
+ */
+#define SKL_DSP_CORES_MASK(nc)     ((1 << (nc)) - 1)
+
+/* ADSPCS - Audio DSP Control & Status */
+
+/*
+ * Core Reset - asserted high
+ * CRST Mask for a given core mask pattern, cm
+ */
 #define SKL_ADSPCS_CRST_SHIFT	0
-#define SKL_ADSPCS_CRST_MASK	(SKL_DSP_CORES_MASK << SKL_ADSPCS_CRST_SHIFT)
-#define SKL_ADSPCS_CRST(x)	((x << SKL_ADSPCS_CRST_SHIFT) & SKL_ADSPCS_CRST_MASK)
+#define SKL_ADSPCS_CRST_MASK(cm)       ((cm) << SKL_ADSPCS_CRST_SHIFT)
 
-/* Core run/stall - when set to '1' core is stalled */
+/*
+ * Core run/stall - when set to '1' core is stalled
+ * CSTALL Mask for a given core mask pattern, cm
+ */
 #define SKL_ADSPCS_CSTALL_SHIFT	8
-#define SKL_ADSPCS_CSTALL_MASK	(SKL_DSP_CORES_MASK <<	\
-					SKL_ADSPCS_CSTALL_SHIFT)
-#define SKL_ADSPCS_CSTALL(x)	((x << SKL_ADSPCS_CSTALL_SHIFT) &	\
-				SKL_ADSPCS_CSTALL_MASK)
+#define SKL_ADSPCS_CSTALL_MASK(cm)     ((cm) << SKL_ADSPCS_CSTALL_SHIFT)
 
-/* Set Power Active - when set to '1' turn cores on */
+/*
+ * Set Power Active - when set to '1' turn cores on
+ * SPA Mask for a given core mask pattern, cm
+ */
 #define SKL_ADSPCS_SPA_SHIFT	16
-#define SKL_ADSPCS_SPA_MASK	(SKL_DSP_CORES_MASK << SKL_ADSPCS_SPA_SHIFT)
-#define SKL_ADSPCS_SPA(x)	((x << SKL_ADSPCS_SPA_SHIFT) & SKL_ADSPCS_SPA_MASK)
+#define SKL_ADSPCS_SPA_MASK(cm)        ((cm) << SKL_ADSPCS_SPA_SHIFT)
 
-/* Current Power Active - power status of cores, set by hardware */
+/*
+ * Current Power Active - power status of cores, set by hardware
+ * CPA Mask for a given core mask pattern, cm
+ */
 #define SKL_ADSPCS_CPA_SHIFT	24
-#define SKL_ADSPCS_CPA_MASK	(SKL_DSP_CORES_MASK << SKL_ADSPCS_CPA_SHIFT)
-#define SKL_ADSPCS_CPA(x)	((x << SKL_ADSPCS_CPA_SHIFT) & SKL_ADSPCS_CPA_MASK)
-
-#define SST_DSP_POWER_D0	0x0  /* full On */
-#define SST_DSP_POWER_D3	0x3  /* Off */
+#define SKL_ADSPCS_CPA_MASK(cm)        ((cm) << SKL_ADSPCS_CPA_SHIFT)
 
 /** FW Extended Manifest Header id = $AE1 */
 #define SKL_EXT_MANIFEST_MAGIC_HEADER_ID   0x31454124
@@ -117,8 +134,8 @@ struct skl_dsp_fw_ops {
 	int (*load_library)(struct sst_dsp *ctx,
 		struct skl_dfw_manifest *minfo);
 	int (*parse_fw)(struct sst_dsp *ctx);
-	int (*set_state_D0)(struct sst_dsp *ctx);
-	int (*set_state_D3)(struct sst_dsp *ctx);
+	int (*set_state_D0)(struct sst_dsp *ctx, unsigned int core_id);
+	int (*set_state_D3)(struct sst_dsp *ctx, unsigned int core_id);
 	unsigned int (*get_fw_errcode)(struct sst_dsp *ctx);
 	int (*load_mod)(struct sst_dsp *ctx, u16 mod_id, char *mod_name);
 	int (*unload_mod)(struct sst_dsp *ctx, u16 mod_id);
@@ -164,17 +181,26 @@ void skl_cldma_process_intr(struct sst_dsp *ctx);
 void skl_cldma_int_disable(struct sst_dsp *ctx);
 int skl_cldma_prepare(struct sst_dsp *ctx);
 
-void skl_dsp_set_state_locked(struct sst_dsp *ctx, int state);
 struct sst_dsp *skl_dsp_ctx_init(struct device *dev,
 		struct sst_dsp_device *sst_dev, int irq);
-int skl_dsp_enable_core(struct sst_dsp  *ctx);
-int skl_dsp_disable_core(struct sst_dsp  *ctx);
-bool is_skl_dsp_running(struct sst_dsp *ctx);
+
+unsigned int skl_dsp_get_enabled_cores(struct sst_dsp  *ctx);
+void skl_dsp_init_core_state(struct sst_dsp *ctx);
+int skl_dsp_enable_core(struct sst_dsp  *ctx, unsigned int core_mask);
+int skl_dsp_disable_core(struct sst_dsp  *ctx, unsigned int core_mask);
+int skl_dsp_core_power_up(struct sst_dsp  *ctx, unsigned int core_mask);
+int skl_dsp_core_power_down(struct sst_dsp  *ctx, unsigned int core_mask);
+int skl_dsp_core_unset_reset_state(struct sst_dsp  *ctx, unsigned int core_mask);
+int skl_dsp_start_core(struct sst_dsp *ctx, unsigned int core_mask);
+
 irqreturn_t skl_dsp_sst_interrupt(int irq, void *dev_id);
 int skl_dsp_wake(struct sst_dsp *ctx);
 int skl_dsp_sleep(struct sst_dsp *ctx);
 void skl_dsp_free(struct sst_dsp *dsp);
 
+int skl_dsp_get_core(struct sst_dsp *ctx, unsigned int core_id);
+int skl_dsp_put_core(struct sst_dsp *ctx, unsigned int core_id);
+
 int skl_dsp_boot(struct sst_dsp *ctx);
 int skl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 		struct skl_dsp_loader_ops dsp_ops, struct skl_sst **dsp);
diff --git a/sound/soc/intel/skylake/skl-sst.c b/sound/soc/intel/skylake/skl-sst.c
index 4a47aaa..54fed0a 100644
--- a/sound/soc/intel/skylake/skl-sst.c
+++ b/sound/soc/intel/skylake/skl-sst.c
@@ -82,7 +82,6 @@ static int skl_load_base_firmware(struct sst_dsp *ctx)
 		ret = request_firmware(&ctx->fw, "dsp_fw_release.bin", ctx->dev);
 		if (ret < 0) {
 			dev_err(ctx->dev, "Request firmware failed %d\n", ret);
-			skl_dsp_disable_core(ctx);
 			return -EIO;
 		}
 	}
@@ -134,66 +133,92 @@ static int skl_load_base_firmware(struct sst_dsp *ctx)
 		}
 
 		dev_dbg(ctx->dev, "Download firmware successful%d\n", ret);
-		skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+		skl_dsp_init_core_state(ctx);
 	}
 	return 0;
 
 skl_load_base_firmware_failed:
-	skl_dsp_disable_core(ctx);
+	skl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);
 	release_firmware(ctx->fw);
 	ctx->fw = NULL;
 	return ret;
 }
 
-static int skl_set_dsp_D0(struct sst_dsp *ctx)
+static int skl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret;
+	struct skl_ipc_dxstate_info dx;
+	struct skl_sst *skl = ctx->thread_context;
+	unsigned int core_mask = SKL_DSP_CORE_MASK(core_id);
 
-	ret = skl_load_base_firmware(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "unable to load firmware\n");
-		return ret;
+	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
+
+	/* If core0 is being turned on, we need to load the FW */
+	if (core_id == SKL_DSP_CORE0_ID) {
+		ret = skl_load_base_firmware(ctx);
+		if (ret < 0) {
+			dev_err(ctx->dev, "unable to load firmware\n");
+			return ret;
+		}
 	}
 
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RUNNING);
+	/*
+	 * If any core other than core 0 is being moved to D0, enable the core
+	 * and send the set dx IPC for the core.
+	 */
+	if (core_id != SKL_DSP_CORE0_ID) {
+		ret = skl_dsp_enable_core(ctx, core_mask);
+		if (ret < 0)
+			return ret;
+
+		dx.core_mask = core_mask;
+		dx.dx_mask = core_mask;
+
+		ret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID,
+					SKL_BASE_FW_MODULE_ID, &dx);
+		if (ret < 0) {
+			dev_err(ctx->dev, "Failed to set dsp to D0:core id= %d\n",
+					core_id);
+			skl_dsp_disable_core(ctx, core_mask);
+		}
+	}
+
+	ctx->core_info.core_state[core_id] = SKL_DSP_RUNNING;
 
 	return ret;
 }
 
-static int skl_set_dsp_D3(struct sst_dsp *ctx)
+static int skl_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)
 {
 	int ret;
 	struct skl_ipc_dxstate_info dx;
 	struct skl_sst *skl = ctx->thread_context;
+	unsigned int core_mask = SKL_DSP_CORE_MASK(core_id);
 
-	dev_dbg(ctx->dev, "In %s:\n", __func__);
-	mutex_lock(&ctx->mutex);
-	if (!is_skl_dsp_running(ctx)) {
-		mutex_unlock(&ctx->mutex);
-		return 0;
-	}
-	mutex_unlock(&ctx->mutex);
+	dev_dbg(ctx->dev, "In %s : core id = %d\n", __func__, core_id);
 
-	dx.core_mask = SKL_DSP_CORE0_MASK;
+	dx.core_mask = core_mask;
 	dx.dx_mask = SKL_IPC_D3_MASK;
+
 	ret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID, SKL_BASE_FW_MODULE_ID, &dx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "Failed to set DSP to D3 state\n");
-		return ret;
+	if (ret < 0)
+		dev_err(ctx->dev,
+			"Failed to set DSP to D3:core_id = %d\n;Continue reset",
+			core_id);
+
+	if (core_id == SKL_DSP_CORE0_ID) {
+		/* disable Interrupt */
+		ctx->cl_dev.ops.cl_cleanup_controller(ctx);
+		skl_cldma_int_disable(ctx);
+		skl_ipc_op_int_disable(ctx);
+		skl_ipc_int_disable(ctx);
 	}
 
-	ret = skl_dsp_disable_core(ctx);
-	if (ret < 0) {
-		dev_err(ctx->dev, "disable dsp core failed ret: %d\n", ret);
-		ret = -EIO;
-	}
-	skl_dsp_set_state_locked(ctx, SKL_DSP_RESET);
+	ret = skl_dsp_disable_core(ctx, core_mask);
+	if (ret < 0)
+		return ret;
 
-	/* disable Interrupt */
-	ctx->cl_dev.ops.cl_cleanup_controller(ctx);
-	skl_cldma_int_disable(ctx);
-	skl_ipc_op_int_disable(ctx);
-	skl_ipc_int_disable(ctx);
+	ctx->core_info.core_state[core_id] = SKL_DSP_RESET;
 
 	return ret;
 }
@@ -439,6 +464,8 @@ int skl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,
 	if (ret)
 		return ret;
 
+	sst->core_info.cores = 2;
+
 	ret = sst->fw_ops.load_fw(sst);
 	if (ret < 0) {
 		dev_err(dev, "Load base fw failed : %d", ret);
-- 
1.7.5.4

