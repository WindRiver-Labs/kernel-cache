From 98bd3b76c1b5a4610b07ecd470fd8ed27cc14c4f Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 26 Apr 2017 20:03:40 +0800
Subject: [PATCH 1/3] x86: rtc: change rtc_lock to raw spin lock

I got the following call trace on rt kernel when doing freeze suspend:
  BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:917
  in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
  Preemption disabled at:[<ffffffff81097d1c>] cpu_startup_entry+0x17c/0x4c0

  CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.1.21-rt13-WR8.0.0.0_preempt-rt+ #234
  Hardware name: Intel Corp. Broxton P/NOTEBOOK, BIOS APLIRVPA.X64.0138.B35.1608091058 08/09/2016
   0000000000000000 ffffffff82003d68 ffffffff81a6bff5 0000000000000000
   ffffffff820144a0 ffffffff82003d88 ffffffff8107dcf7 ffffffff8200b040
   ffffffff82003e18 ffffffff82003da8 ffffffff81a730e4 ffffffff823c3e90
  Call Trace:
   [<ffffffff81a6bff5>] dump_stack+0x54/0x6f
   [<ffffffff8107dcf7>] ___might_sleep+0xe7/0x170
   [<ffffffff81a730e4>] rt_spin_lock+0x24/0x60
   [<ffffffff8100d79a>] mach_get_cmos_time+0x2a/0x1a0
   [<ffffffff8140ef67>] ? debug_smp_processor_id+0x17/0x20
   [<ffffffff8100d94f>] read_persistent_clock+0xf/0x20
   [<ffffffff810c77fa>] read_persistent_clock64+0x1a/0x30
   [<ffffffff810d0fc1>] ? __tick_nohz_idle_enter+0x2f1/0x4c0
   [<ffffffff810c7a3e>] timekeeping_suspend+0x1e/0x2c0
   [<ffffffff810cf23d>] tick_freeze+0x7d/0x90
   [<ffffffff8178b70f>] cpuidle_enter_freeze+0x7f/0xd0
   [<ffffffff81097feb>] cpu_startup_entry+0x44b/0x4c0
   [<ffffffff81a67305>] rest_init+0x85/0x90
   [<ffffffff8214cf71>] start_kernel+0x41a/0x427
   [<ffffffff8214c303>] x86_64_start_reservations+0x2f/0x31
   [<ffffffff8214c46e>] x86_64_start_kernel+0x169/0x178

So change rtc_lock to a raw spinlock to fix this issue.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/x86/include/asm/floppy.h           |    8 +-
 arch/x86/kernel/bootflag.c              |    8 +-
 arch/x86/kernel/reboot.c                |    4 +-
 arch/x86/kernel/rtc.c                   |    6 +-
 arch/x86/kernel/smpboot.c               |    8 +-
 arch/x86/platform/efi/efi_64.c          |   16 +++---
 drivers/acpi/acpi_cmos_rtc.c            |    4 +-
 drivers/char/mwave/smapi.c              |    8 +-
 drivers/char/nvram.c                    |   44 +++++++-------
 drivers/char/rtc.c                      |  102 +++++++++++++++---------------
 drivers/firmware/dcdbas.c               |    8 +-
 drivers/firmware/efi/runtime-wrappers.c |   18 +++---
 drivers/rtc/rtc-cmos.c                  |   44 +++++++-------
 drivers/rtc/rtc-mrst.c                  |   52 ++++++++--------
 include/asm-generic/rtc.h               |   14 ++--
 include/linux/mc146818rtc.h             |    2 +-
 16 files changed, 173 insertions(+), 173 deletions(-)

diff --git a/arch/x86/include/asm/floppy.h b/arch/x86/include/asm/floppy.h
index 1c7eefe..1e28706 100644
--- a/arch/x86/include/asm/floppy.h
+++ b/arch/x86/include/asm/floppy.h
@@ -257,9 +257,9 @@ static int FDC2 = -1;
 ({							\
 	unsigned long flags;				\
 	unsigned char val;				\
-	spin_lock_irqsave(&rtc_lock, flags);		\
+	raw_spin_lock_irqsave(&rtc_lock, flags);		\
 	val = (CMOS_READ(0x10) >> 4) & 15;		\
-	spin_unlock_irqrestore(&rtc_lock, flags);	\
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);	\
 	val;						\
 })
 
@@ -267,9 +267,9 @@ static int FDC2 = -1;
 ({							\
 	unsigned long flags;				\
 	unsigned char val;				\
-	spin_lock_irqsave(&rtc_lock, flags);		\
+	raw_spin_lock_irqsave(&rtc_lock, flags);		\
 	val = CMOS_READ(0x10) & 15;			\
-	spin_unlock_irqrestore(&rtc_lock, flags);	\
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);	\
 	val;						\
 })
 
diff --git a/arch/x86/kernel/bootflag.c b/arch/x86/kernel/bootflag.c
index 5de7f4c..d922ced 100644
--- a/arch/x86/kernel/bootflag.c
+++ b/arch/x86/kernel/bootflag.c
@@ -44,9 +44,9 @@ static void __init sbf_write(u8 v)
 		printk(KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n",
 			sbf_port, v);
 
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		CMOS_WRITE(v, sbf_port);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	}
 }
 
@@ -58,9 +58,9 @@ static u8 __init sbf_read(void)
 	if (sbf_port == -1)
 		return 0;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	v = CMOS_READ(sbf_port);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	return v;
 }
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index 0549ae3..eae072f 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -82,9 +82,9 @@ void __noreturn machine_real_restart(unsigned int type)
 	 * `outb_p' is needed instead of just `outb'.  Use it to be on the
 	 * safe side.  (Yes, CMOS_WRITE does outb_p's. -  Paul G.)
 	 */
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 	CMOS_WRITE(0x00, 0x8f);
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	/*
 	 * Switch back to the initial page table.
diff --git a/arch/x86/kernel/rtc.c b/arch/x86/kernel/rtc.c
index 62c48da..201d458 100644
--- a/arch/x86/kernel/rtc.c
+++ b/arch/x86/kernel/rtc.c
@@ -29,7 +29,7 @@ EXPORT_SYMBOL(cmos_lock);
 /* For two digit years assume time is always after that */
 #define CMOS_YEARS_OFFS 2000
 
-DEFINE_SPINLOCK(rtc_lock);
+DEFINE_RAW_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
 /*
@@ -65,7 +65,7 @@ void mach_get_cmos_time(struct timespec *now)
 	unsigned int status, year, mon, day, hour, min, sec, century = 0;
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 
 	/*
 	 * If UIP is clear, then we have >= 244 microseconds before
@@ -92,7 +92,7 @@ void mach_get_cmos_time(struct timespec *now)
 	status = CMOS_READ(RTC_CONTROL);
 	WARN_ON_ONCE(RTC_ALWAYS_BCD && (status & RTC_DM_BINARY));
 
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	if (RTC_ALWAYS_BCD || !(status & RTC_DM_BINARY)) {
 		sec = bcd2bin(sec);
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 065d809..30eabb4 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -103,9 +103,9 @@ static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	CMOS_WRITE(0xa, 0xf);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	local_flush_tlb();
 	pr_debug("1.\n");
 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_HIGH)) =
@@ -129,9 +129,9 @@ static inline void smpboot_restore_warm_reset_vector(void)
 	 * Paranoid:  Set warm reset code and vector here back
 	 * to default values.
 	 */
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	CMOS_WRITE(0, 0xf);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	*((volatile u32 *)phys_to_virt(TRAMPOLINE_PHYS_LOW)) = 0;
 }
diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c
index a0ac0f9..88175a1 100644
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@ -396,14 +396,14 @@ static efi_status_t efi_thunk_get_time(efi_time_t *tm, efi_time_cap_t *tc)
 	efi_status_t status;
 	u32 phys_tm, phys_tc;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 
 	phys_tm = virt_to_phys(tm);
 	phys_tc = virt_to_phys(tc);
 
 	status = efi_thunk(get_time, phys_tm, phys_tc);
 
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	return status;
 }
@@ -413,13 +413,13 @@ static efi_status_t efi_thunk_set_time(efi_time_t *tm)
 	efi_status_t status;
 	u32 phys_tm;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 
 	phys_tm = virt_to_phys(tm);
 
 	status = efi_thunk(set_time, phys_tm);
 
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	return status;
 }
@@ -431,7 +431,7 @@ efi_thunk_get_wakeup_time(efi_bool_t *enabled, efi_bool_t *pending,
 	efi_status_t status;
 	u32 phys_enabled, phys_pending, phys_tm;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 
 	phys_enabled = virt_to_phys(enabled);
 	phys_pending = virt_to_phys(pending);
@@ -440,7 +440,7 @@ efi_thunk_get_wakeup_time(efi_bool_t *enabled, efi_bool_t *pending,
 	status = efi_thunk(get_wakeup_time, phys_enabled,
 			     phys_pending, phys_tm);
 
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	return status;
 }
@@ -451,13 +451,13 @@ efi_thunk_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
 	efi_status_t status;
 	u32 phys_tm;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 
 	phys_tm = virt_to_phys(tm);
 
 	status = efi_thunk(set_wakeup_time, enabled, phys_tm);
 
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	return status;
 }
diff --git a/drivers/acpi/acpi_cmos_rtc.c b/drivers/acpi/acpi_cmos_rtc.c
index 81dc750..bc66da5 100644
--- a/drivers/acpi/acpi_cmos_rtc.c
+++ b/drivers/acpi/acpi_cmos_rtc.c
@@ -41,7 +41,7 @@ acpi_cmos_rtc_space_handler(u32 function, acpi_physical_address address,
 	if (function != ACPI_WRITE && function != ACPI_READ)
 		return AE_BAD_PARAMETER;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	for (i = 0; i < DIV_ROUND_UP(bits, 8); ++i, ++address, ++value)
 		if (function == ACPI_READ)
@@ -49,7 +49,7 @@ acpi_cmos_rtc_space_handler(u32 function, acpi_physical_address address,
 		else
 			CMOS_WRITE(*value, address);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return AE_OK;
 }
diff --git a/drivers/char/mwave/smapi.c b/drivers/char/mwave/smapi.c
index 6187fd1..f8795ae 100644
--- a/drivers/char/mwave/smapi.c
+++ b/drivers/char/mwave/smapi.c
@@ -541,17 +541,17 @@ int smapi_init(void)
 
 	PRINTK_1(TRACE_SMAPI, "smapi::smapi_init entry\n");
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	usSmapiID = CMOS_READ(0x7C);
 	usSmapiID |= (CMOS_READ(0x7D) << 8);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	PRINTK_2(TRACE_SMAPI, "smapi::smapi_init usSmapiID %x\n", usSmapiID);
 
 	if (usSmapiID == 0x5349) {
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		g_usSmapiPort = CMOS_READ(0x7E);
 		g_usSmapiPort |= (CMOS_READ(0x7F) << 8);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 		if (g_usSmapiPort == 0) {
 			PRINTK_ERROR("smapi::smapi_init, ERROR unable to read from SMAPI port\n");
 		} else {
diff --git a/drivers/char/nvram.c b/drivers/char/nvram.c
index 9df78e2..ea00343 100644
--- a/drivers/char/nvram.c
+++ b/drivers/char/nvram.c
@@ -149,9 +149,9 @@ unsigned char nvram_read_byte(int i)
 	unsigned long flags;
 	unsigned char c;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	c = __nvram_read_byte(i);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return c;
 }
 EXPORT_SYMBOL(nvram_read_byte);
@@ -167,9 +167,9 @@ void nvram_write_byte(unsigned char c, int i)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	__nvram_write_byte(c, i);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 }
 EXPORT_SYMBOL(nvram_write_byte);
 
@@ -184,9 +184,9 @@ int nvram_check_checksum(void)
 	unsigned long flags;
 	int rv;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	rv = __nvram_check_checksum();
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return rv;
 }
 EXPORT_SYMBOL(nvram_check_checksum);
@@ -201,9 +201,9 @@ void nvram_set_checksum(void)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	__nvram_set_checksum();
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 }
 #endif  /*  0  */
 
@@ -237,7 +237,7 @@ static ssize_t nvram_read(struct file *file, char __user *buf,
 	unsigned i = *ppos;
 	unsigned char *tmp;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	if (!__nvram_check_checksum())
 		goto checksum_err;
@@ -245,7 +245,7 @@ static ssize_t nvram_read(struct file *file, char __user *buf,
 	for (tmp = contents; count-- > 0 && i < NVRAM_BYTES; ++i, ++tmp)
 		*tmp = __nvram_read_byte(i);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (copy_to_user(buf, contents, tmp - contents))
 		return -EFAULT;
@@ -255,7 +255,7 @@ static ssize_t nvram_read(struct file *file, char __user *buf,
 	return tmp - contents;
 
 checksum_err:
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return -EIO;
 }
 
@@ -277,7 +277,7 @@ static ssize_t nvram_write(struct file *file, const char __user *buf,
 	if (copy_from_user(contents, buf, count))
 		return -EFAULT;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	if (!__nvram_check_checksum())
 		goto checksum_err;
@@ -287,14 +287,14 @@ static ssize_t nvram_write(struct file *file, const char __user *buf,
 
 	__nvram_set_checksum();
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	*ppos = i;
 
 	return tmp - contents;
 
 checksum_err:
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return -EIO;
 }
 
@@ -311,13 +311,13 @@ static long nvram_ioctl(struct file *file, unsigned int cmd,
 			return -EACCES;
 
 		mutex_lock(&nvram_mutex);
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 
 		for (i = 0; i < NVRAM_BYTES; ++i)
 			__nvram_write_byte(0, i);
 		__nvram_set_checksum();
 
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		mutex_unlock(&nvram_mutex);
 		return 0;
 
@@ -328,9 +328,9 @@ static long nvram_ioctl(struct file *file, unsigned int cmd,
 			return -EACCES;
 
 		mutex_lock(&nvram_mutex);
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 		__nvram_set_checksum();
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		mutex_unlock(&nvram_mutex);
 		return 0;
 
@@ -391,10 +391,10 @@ static int nvram_proc_read(struct seq_file *seq, void *offset)
 	unsigned char contents[NVRAM_BYTES];
 	int i = 0;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	for (i = 0; i < NVRAM_BYTES; ++i)
 		contents[i] = __nvram_read_byte(i);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	mach_proc_infos(contents, seq, offset);
 
@@ -526,9 +526,9 @@ static void pc_proc_infos(unsigned char *nvram, struct seq_file *seq,
 	int checksum;
 	int type;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	checksum = __nvram_check_checksum();
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	seq_printf(seq, "Checksum status: %svalid\n", checksum ? "" : "not ");
 
diff --git a/drivers/char/rtc.c b/drivers/char/rtc.c
index 3525996..9c4fb91 100644
--- a/drivers/char/rtc.c
+++ b/drivers/char/rtc.c
@@ -157,16 +157,16 @@ static void mask_rtc_irq_bit_locked(unsigned char bit);
 
 static inline void set_rtc_irq_bit(unsigned char bit)
 {
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	set_rtc_irq_bit_locked(bit);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 }
 
 static void mask_rtc_irq_bit(unsigned char bit)
 {
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	mask_rtc_irq_bit_locked(bit);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 }
 #endif
 
@@ -219,9 +219,9 @@ static inline unsigned char rtc_is_updating(void)
 	unsigned long flags;
 	unsigned char uip;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return uip;
 }
 
@@ -245,7 +245,7 @@ static irqreturn_t rtc_interrupt(int irq, void *dev_id)
 	 *	the last read in the remainder of rtc_irq_data.
 	 */
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 	rtc_irq_data += 0x100;
 	rtc_irq_data &= ~0xff;
 	if (is_hpet_enabled()) {
@@ -262,7 +262,7 @@ static irqreturn_t rtc_interrupt(int irq, void *dev_id)
 	if (rtc_status & RTC_TIMER_ON)
 		mod_timer(&rtc_irq_timer, jiffies + HZ/rtc_freq + 2*HZ/100);
 
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	/* Now do the rest of the actions */
 	spin_lock(&rtc_task_lock);
@@ -359,10 +359,10 @@ static ssize_t rtc_read(struct file *file, char __user *buf,
 
 		__set_current_state(TASK_INTERRUPTIBLE);
 
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 		data = rtc_irq_data;
 		rtc_irq_data = 0;
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 
 		if (data != 0)
 			break;
@@ -432,13 +432,13 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		/* can be called from isr via rtc_control() */
 		unsigned long flags;
 
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		mask_rtc_irq_bit_locked(RTC_PIE);
 		if (rtc_status & RTC_TIMER_ON) {
 			rtc_status &= ~RTC_TIMER_ON;
 			del_timer(&rtc_irq_timer);
 		}
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 		return 0;
 	}
@@ -455,14 +455,14 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 						(!capable(CAP_SYS_RESOURCE)))
 			return -EACCES;
 
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		if (!(rtc_status & RTC_TIMER_ON)) {
 			mod_timer(&rtc_irq_timer, jiffies + HZ/rtc_freq +
 					2*HZ/100);
 			rtc_status |= RTC_TIMER_ON;
 		}
 		set_rtc_irq_bit_locked(RTC_PIE);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 		return 0;
 	}
@@ -506,7 +506,7 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		min = alm_tm.tm_min;
 		sec = alm_tm.tm_sec;
 
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 		if (hpet_set_alarm_time(hrs, min, sec)) {
 			/*
 			 * Fallthru and set alarm time in CMOS too,
@@ -533,7 +533,7 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		CMOS_WRITE(hrs, RTC_HOURS_ALARM);
 		CMOS_WRITE(min, RTC_MINUTES_ALARM);
 		CMOS_WRITE(sec, RTC_SECONDS_ALARM);
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 
 		return 0;
 	}
@@ -585,7 +585,7 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		if (yrs > 255)		/* They are unsigned */
 			return -EINVAL;
 
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 #ifdef CONFIG_MACH_DECSTATION
 		real_yrs = yrs;
 		yrs = 72;
@@ -604,7 +604,7 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		 * whether the chip is in binary mode or not.
 		 */
 		if (yrs > 169) {
-			spin_unlock_irq(&rtc_lock);
+			raw_spin_unlock_irq(&rtc_lock);
 			return -EINVAL;
 		}
 		if (yrs >= 100)
@@ -638,7 +638,7 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 		CMOS_WRITE(save_control, RTC_CONTROL);
 		CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
 
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		return 0;
 	}
 #ifdef RTC_IRQ
@@ -677,16 +677,16 @@ static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, int kernel)
 
 		rtc_freq = arg;
 
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		if (hpet_set_periodic_freq(arg)) {
-			spin_unlock_irqrestore(&rtc_lock, flags);
+			raw_spin_unlock_irqrestore(&rtc_lock, flags);
 			return 0;
 		}
 
 		val = CMOS_READ(RTC_FREQ_SELECT) & 0xf0;
 		val |= (16 - tmp);
 		CMOS_WRITE(val, RTC_FREQ_SELECT);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 		return 0;
 	}
 #endif
@@ -729,7 +729,7 @@ static long rtc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  */
 static int rtc_open(struct inode *inode, struct file *file)
 {
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	if (rtc_status & RTC_IS_OPEN)
 		goto out_busy;
@@ -737,11 +737,11 @@ static int rtc_open(struct inode *inode, struct file *file)
 	rtc_status |= RTC_IS_OPEN;
 
 	rtc_irq_data = 0;
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return 0;
 
 out_busy:
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return -EBUSY;
 }
 
@@ -763,7 +763,7 @@ static int rtc_release(struct inode *inode, struct file *file)
 	 * in use, and clear the data.
 	 */
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	if (!hpet_mask_rtc_irq_bit(RTC_PIE | RTC_AIE | RTC_UIE)) {
 		tmp = CMOS_READ(RTC_CONTROL);
 		tmp &=  ~RTC_PIE;
@@ -776,15 +776,15 @@ static int rtc_release(struct inode *inode, struct file *file)
 		rtc_status &= ~RTC_TIMER_ON;
 		del_timer(&rtc_irq_timer);
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 no_irq:
 #endif
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	rtc_irq_data = 0;
 	rtc_status &= ~RTC_IS_OPEN;
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return 0;
 }
@@ -799,9 +799,9 @@ static unsigned int rtc_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &rtc_wait, wait);
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	l = rtc_irq_data;
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (l != 0)
 		return POLLIN | POLLRDNORM;
@@ -816,21 +816,21 @@ int rtc_register(rtc_task_t *task)
 #else
 	if (task == NULL || task->func == NULL)
 		return -EINVAL;
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	if (rtc_status & RTC_IS_OPEN) {
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		return -EBUSY;
 	}
 	spin_lock(&rtc_task_lock);
 	if (rtc_callback) {
 		spin_unlock(&rtc_task_lock);
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		return -EBUSY;
 	}
 	rtc_status |= RTC_IS_OPEN;
 	rtc_callback = task;
 	spin_unlock(&rtc_task_lock);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return 0;
 #endif
 }
@@ -843,11 +843,11 @@ int rtc_unregister(rtc_task_t *task)
 #else
 	unsigned char tmp;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	spin_lock(&rtc_task_lock);
 	if (rtc_callback != task) {
 		spin_unlock(&rtc_task_lock);
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		return -ENXIO;
 	}
 	rtc_callback = NULL;
@@ -867,7 +867,7 @@ int rtc_unregister(rtc_task_t *task)
 	}
 	rtc_status &= ~RTC_IS_OPEN;
 	spin_unlock(&rtc_task_lock);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 	return 0;
 #endif
 }
@@ -1079,10 +1079,10 @@ no_irq:
 	if (rtc_is_updating() != 0)
 		msleep(20);
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	year = CMOS_READ(RTC_YEAR);
 	ctrl = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
 		year = bcd2bin(year);       /* This should never happen... */
@@ -1114,7 +1114,7 @@ no_irq:
 	if (rtc_has_irq == 0)
 		goto no_irq2;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	rtc_freq = 1024;
 	if (!hpet_set_periodic_freq(rtc_freq)) {
 		/*
@@ -1124,7 +1124,7 @@ no_irq:
 		CMOS_WRITE(((CMOS_READ(RTC_FREQ_SELECT) & 0xF0) | 0x06),
 			   RTC_FREQ_SELECT);
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 no_irq2:
 #endif
 
@@ -1175,10 +1175,10 @@ static void rtc_dropped_irq(unsigned long data)
 {
 	unsigned long freq;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	if (hpet_rtc_dropped_irq()) {
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 		return;
 	}
 
@@ -1192,7 +1192,7 @@ static void rtc_dropped_irq(unsigned long data)
 
 	freq = rtc_freq;
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	printk_ratelimited(KERN_WARNING "rtc: lost some interrupts at %ldHz.\n",
 			   freq);
@@ -1217,11 +1217,11 @@ static int rtc_proc_show(struct seq_file *seq, void *v)
 	unsigned char batt, ctrl;
 	unsigned long freq;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	batt = CMOS_READ(RTC_VALID) & RTC_VRT;
 	ctrl = CMOS_READ(RTC_CONTROL);
 	freq = rtc_freq;
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 
 	rtc_get_rtc_time(&tm);
@@ -1319,7 +1319,7 @@ static void rtc_get_rtc_time(struct rtc_time *rtc_tm)
 	 * RTC has RTC_DAY_OF_WEEK, we should usually ignore it, as it is
 	 * only updated by the RTC when initially set to a non-zero value.
 	 */
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	rtc_tm->tm_sec = CMOS_READ(RTC_SECONDS);
 	rtc_tm->tm_min = CMOS_READ(RTC_MINUTES);
 	rtc_tm->tm_hour = CMOS_READ(RTC_HOURS);
@@ -1333,7 +1333,7 @@ static void rtc_get_rtc_time(struct rtc_time *rtc_tm)
 	real_year = CMOS_READ(RTC_DEC_YEAR);
 #endif
 	ctrl = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
 		rtc_tm->tm_sec = bcd2bin(rtc_tm->tm_sec);
@@ -1368,12 +1368,12 @@ static void get_rtc_alm_time(struct rtc_time *alm_tm)
 	 * Only the values that we read from the RTC are set. That
 	 * means only tm_hour, tm_min, and tm_sec.
 	 */
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	alm_tm->tm_sec = CMOS_READ(RTC_SECONDS_ALARM);
 	alm_tm->tm_min = CMOS_READ(RTC_MINUTES_ALARM);
 	alm_tm->tm_hour = CMOS_READ(RTC_HOURS_ALARM);
 	ctrl = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
 		alm_tm->tm_sec = bcd2bin(alm_tm->tm_sec);
diff --git a/drivers/firmware/dcdbas.c b/drivers/firmware/dcdbas.c
index 829eec8..3cf33fa 100644
--- a/drivers/firmware/dcdbas.c
+++ b/drivers/firmware/dcdbas.c
@@ -361,7 +361,7 @@ static int host_control_smi(void)
 
 	switch (host_control_smi_type) {
 	case HC_SMITYPE_TYPE1:
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		/* write SMI data buffer physical address */
 		data = (u8 *)&smi_data_buf_phys_addr;
 		for (index = PE1300_CMOS_CMD_STRUCT_PTR;
@@ -379,7 +379,7 @@ static int host_control_smi(void)
 
 		/* generate SMM call */
 		outb(ESM_APM_CMD, PCAT_APM_CONTROL_PORT);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 		/* wait a few to see if it executed */
 		num_ticks = TIMEOUT_USEC_SHORT_SEMA_BLOCKING;
@@ -393,7 +393,7 @@ static int host_control_smi(void)
 
 	case HC_SMITYPE_TYPE2:
 	case HC_SMITYPE_TYPE3:
-		spin_lock_irqsave(&rtc_lock, flags);
+		raw_spin_lock_irqsave(&rtc_lock, flags);
 		/* write SMI data buffer physical address */
 		data = (u8 *)&smi_data_buf_phys_addr;
 		for (index = PE1400_CMOS_CMD_STRUCT_PTR;
@@ -411,7 +411,7 @@ static int host_control_smi(void)
 
 		/* restore RTC index pointer since it was written to above */
 		CMOS_READ(RTC_REG_C);
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 		/* read control port back to serialize write */
 		cmd_status = inb(PE1400_APM_CONTROL_PORT);
diff --git a/drivers/firmware/efi/runtime-wrappers.c b/drivers/firmware/efi/runtime-wrappers.c
index 228bbf9..a105f88 100644
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@ -93,18 +93,18 @@ static DEFINE_SPINLOCK(efi_runtime_lock);
  * functions serialize with other CMOS accesses in the kernel, as the EFI time
  * functions may choose to also use the legacy CMOS RTC.
  */
-__weak DEFINE_SPINLOCK(rtc_lock);
+__weak DEFINE_RAW_SPINLOCK(rtc_lock);
 
 static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
 {
 	unsigned long flags;
 	efi_status_t status;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	spin_lock(&efi_runtime_lock);
 	status = efi_call_virt(get_time, tm, tc);
 	spin_unlock(&efi_runtime_lock);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return status;
 }
 
@@ -113,11 +113,11 @@ static efi_status_t virt_efi_set_time(efi_time_t *tm)
 	unsigned long flags;
 	efi_status_t status;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	spin_lock(&efi_runtime_lock);
 	status = efi_call_virt(set_time, tm);
 	spin_unlock(&efi_runtime_lock);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return status;
 }
 
@@ -128,11 +128,11 @@ static efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,
 	unsigned long flags;
 	efi_status_t status;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	spin_lock(&efi_runtime_lock);
 	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
 	spin_unlock(&efi_runtime_lock);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return status;
 }
 
@@ -141,11 +141,11 @@ static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
 	unsigned long flags;
 	efi_status_t status;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	spin_lock(&efi_runtime_lock);
 	status = efi_call_virt(set_wakeup_time, enabled, tm);
 	spin_unlock(&efi_runtime_lock);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return status;
 }
 
diff --git a/drivers/rtc/rtc-cmos.c b/drivers/rtc/rtc-cmos.c
index a82556a..bfba895 100644
--- a/drivers/rtc/rtc-cmos.c
+++ b/drivers/rtc/rtc-cmos.c
@@ -223,7 +223,7 @@ static int cmos_read_alarm(struct device *dev, struct rtc_wkalrm *t)
 	t->time.tm_mday = -1;
 	t->time.tm_mon = -1;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	t->time.tm_sec = CMOS_READ(RTC_SECONDS_ALARM);
 	t->time.tm_min = CMOS_READ(RTC_MINUTES_ALARM);
 	t->time.tm_hour = CMOS_READ(RTC_HOURS_ALARM);
@@ -242,7 +242,7 @@ static int cmos_read_alarm(struct device *dev, struct rtc_wkalrm *t)
 	}
 
 	rtc_control = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (!(rtc_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
 		if (((unsigned)t->time.tm_sec) < 0x60)
@@ -350,7 +350,7 @@ static int cmos_set_alarm(struct device *dev, struct rtc_wkalrm *t)
 		sec = (sec < 60) ? bin2bcd(sec) : 0xff;
 	}
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	/* next rtc irq must not be from previous alarm setting */
 	cmos_irq_disable(cmos, RTC_AIE);
@@ -375,7 +375,7 @@ static int cmos_set_alarm(struct device *dev, struct rtc_wkalrm *t)
 	if (t->enabled)
 		cmos_irq_enable(cmos, RTC_AIE);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return 0;
 }
@@ -435,14 +435,14 @@ static int cmos_alarm_irq_enable(struct device *dev, unsigned int enabled)
 	if (alarm_disable_quirk)
 		return 0;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 
 	if (enabled)
 		cmos_irq_enable(cmos, RTC_AIE);
 	else
 		cmos_irq_disable(cmos, RTC_AIE);
 
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return 0;
 }
 
@@ -453,10 +453,10 @@ static int cmos_procfs(struct device *dev, struct seq_file *seq)
 	struct cmos_rtc	*cmos = dev_get_drvdata(dev);
 	unsigned char	rtc_control, valid;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	rtc_control = CMOS_READ(RTC_CONTROL);
 	valid = CMOS_READ(RTC_VALID);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	/* NOTE:  at least ICH6 reports battery status using a different
 	 * (non-RTC) bit; and SQWE is ignored on many current systems.
@@ -520,7 +520,7 @@ cmos_nvram_read(struct file *filp, struct kobject *kobj,
 		count = attr->size - off;
 
 	off += NVRAM_OFFSET;
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	for (retval = 0; count; count--, off++, retval++) {
 		if (off < 128)
 			*buf++ = CMOS_READ(off);
@@ -529,7 +529,7 @@ cmos_nvram_read(struct file *filp, struct kobject *kobj,
 		else
 			break;
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return retval;
 }
@@ -556,7 +556,7 @@ cmos_nvram_write(struct file *filp, struct kobject *kobj,
 	 * NVRAM to update, updating checksums is also part of its job.
 	 */
 	off += NVRAM_OFFSET;
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	for (retval = 0; count; count--, off++, retval++) {
 		/* don't trash RTC registers */
 		if (off == cmos->day_alrm
@@ -570,7 +570,7 @@ cmos_nvram_write(struct file *filp, struct kobject *kobj,
 		else
 			break;
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return retval;
 }
@@ -595,7 +595,7 @@ static irqreturn_t cmos_interrupt(int irq, void *p)
 	u8		irqstat;
 	u8		rtc_control;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 
 	/* When the HPET interrupt handler calls us, the interrupt
 	 * status is passed as arg1 instead of the irq number.  But
@@ -628,7 +628,7 @@ static irqreturn_t cmos_interrupt(int irq, void *p)
 		hpet_mask_rtc_irq_bit(RTC_AIE);
 		CMOS_READ(RTC_INTR_FLAGS);
 	}
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	if (is_intr(irqstat)) {
 		rtc_update_irq(p, 1, irqstat);
@@ -737,7 +737,7 @@ cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
 
 	rename_region(ports, dev_name(&cmos_rtc.rtc->dev));
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 
 	if (!(flags & CMOS_RTC_FLAGS_NOFREQ)) {
 		/* force periodic irq to CMOS reset default of 1024Hz;
@@ -757,7 +757,7 @@ cmos_do_probe(struct device *dev, struct resource *ports, int rtc_irq)
 
 	rtc_control = CMOS_READ(RTC_CONTROL);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	/* FIXME:
 	 * <asm-generic/rtc.h> doesn't know 12-hour mode either.
@@ -827,10 +827,10 @@ cleanup0:
 
 static void cmos_do_shutdown(int rtc_irq)
 {
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	if (is_valid_irq(rtc_irq))
 		cmos_irq_disable(&cmos_rtc, RTC_IRQMASK);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 }
 
 static void __exit cmos_do_remove(struct device *dev)
@@ -868,7 +868,7 @@ static int cmos_suspend(struct device *dev)
 	unsigned char	tmp;
 
 	/* only the alarm might be a wakeup event source */
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	cmos->suspend_ctrl = tmp = CMOS_READ(RTC_CONTROL);
 	if (tmp & (RTC_PIE|RTC_AIE|RTC_UIE)) {
 		unsigned char	mask;
@@ -883,7 +883,7 @@ static int cmos_suspend(struct device *dev)
 
 		cmos_checkintr(cmos, tmp);
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (tmp & RTC_AIE) {
 		cmos->enabled_wake = 1;
@@ -926,7 +926,7 @@ static int cmos_resume(struct device *dev)
 		cmos->enabled_wake = 0;
 	}
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	tmp = cmos->suspend_ctrl;
 	cmos->suspend_ctrl = 0;
 	/* re-enable any irqs previously active */
@@ -953,7 +953,7 @@ static int cmos_resume(struct device *dev)
 			hpet_mask_rtc_irq_bit(RTC_AIE);
 		} while (mask & RTC_AIE);
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	dev_dbg(dev, "resume, ctrl %02x\n", tmp);
 
diff --git a/drivers/rtc/rtc-mrst.c b/drivers/rtc/rtc-mrst.c
index 548ea6f..8591949 100644
--- a/drivers/rtc/rtc-mrst.c
+++ b/drivers/rtc/rtc-mrst.c
@@ -67,9 +67,9 @@ static inline unsigned char vrtc_is_updating(void)
 	unsigned char uip;
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	uip = (vrtc_cmos_read(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return uip;
 }
 
@@ -93,14 +93,14 @@ static int mrst_read_time(struct device *dev, struct rtc_time *time)
 	if (vrtc_is_updating())
 		mdelay(20);
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	time->tm_sec = vrtc_cmos_read(RTC_SECONDS);
 	time->tm_min = vrtc_cmos_read(RTC_MINUTES);
 	time->tm_hour = vrtc_cmos_read(RTC_HOURS);
 	time->tm_mday = vrtc_cmos_read(RTC_DAY_OF_MONTH);
 	time->tm_mon = vrtc_cmos_read(RTC_MONTH);
 	time->tm_year = vrtc_cmos_read(RTC_YEAR);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	/* Adjust for the 1972/1900 */
 	time->tm_year += 72;
@@ -126,7 +126,7 @@ static int mrst_set_time(struct device *dev, struct rtc_time *time)
 		return -EINVAL;
 	yrs -= 72;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 
 	vrtc_cmos_write(yrs, RTC_YEAR);
 	vrtc_cmos_write(mon, RTC_MONTH);
@@ -135,7 +135,7 @@ static int mrst_set_time(struct device *dev, struct rtc_time *time)
 	vrtc_cmos_write(min, RTC_MINUTES);
 	vrtc_cmos_write(sec, RTC_SECONDS);
 
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	ret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETTIME);
 	return ret;
@@ -158,13 +158,13 @@ static int mrst_read_alarm(struct device *dev, struct rtc_wkalrm *t)
 	t->time.tm_year = -1;
 
 	/* vRTC only supports binary mode */
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	t->time.tm_sec = vrtc_cmos_read(RTC_SECONDS_ALARM);
 	t->time.tm_min = vrtc_cmos_read(RTC_MINUTES_ALARM);
 	t->time.tm_hour = vrtc_cmos_read(RTC_HOURS_ALARM);
 
 	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	t->enabled = !!(rtc_control & RTC_AIE);
 	t->pending = 0;
@@ -226,7 +226,7 @@ static int mrst_set_alarm(struct device *dev, struct rtc_wkalrm *t)
 	min = t->time.tm_min;
 	sec = t->time.tm_sec;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	/* Next rtc irq must not be from previous alarm setting */
 	mrst_irq_disable(mrst, RTC_AIE);
 
@@ -235,17 +235,17 @@ static int mrst_set_alarm(struct device *dev, struct rtc_wkalrm *t)
 	vrtc_cmos_write(min, RTC_MINUTES_ALARM);
 	vrtc_cmos_write(sec, RTC_SECONDS_ALARM);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	ret = intel_scu_ipc_simple_command(IPCMSG_VRTC, IPC_CMD_VRTC_SETALARM);
 	if (ret)
 		return ret;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	if (t->enabled)
 		mrst_irq_enable(mrst, RTC_AIE);
 
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	return 0;
 }
@@ -256,12 +256,12 @@ static int mrst_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
 	struct mrst_rtc	*mrst = dev_get_drvdata(dev);
 	unsigned long	flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	if (enabled)
 		mrst_irq_enable(mrst, RTC_AIE);
 	else
 		mrst_irq_disable(mrst, RTC_AIE);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return 0;
 }
 
@@ -272,10 +272,10 @@ static int mrst_procfs(struct device *dev, struct seq_file *seq)
 {
 	unsigned char	rtc_control, valid;
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	rtc_control = vrtc_cmos_read(RTC_CONTROL);
 	valid = vrtc_cmos_read(RTC_VALID);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	seq_printf(seq,
 		   "periodic_IRQ\t: %s\n"
@@ -311,10 +311,10 @@ static irqreturn_t mrst_rtc_irq(int irq, void *p)
 {
 	u8 irqstat;
 
-	spin_lock(&rtc_lock);
+	raw_spin_lock(&rtc_lock);
 	/* This read will clear all IRQ flags inside Reg C */
 	irqstat = vrtc_cmos_read(RTC_INTR_FLAGS);
-	spin_unlock(&rtc_lock);
+	raw_spin_unlock(&rtc_lock);
 
 	irqstat &= RTC_IRQMASK | RTC_IRQF;
 	if (is_intr(irqstat)) {
@@ -358,10 +358,10 @@ static int vrtc_mrst_do_probe(struct device *dev, struct resource *iomem,
 
 	rename_region(iomem, dev_name(&mrst_rtc.rtc->dev));
 
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	mrst_irq_disable(&mrst_rtc, RTC_PIE | RTC_AIE);
 	rtc_control = vrtc_cmos_read(RTC_CONTROL);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (!(rtc_control & RTC_24H) || (rtc_control & (RTC_DM_BINARY)))
 		dev_dbg(dev, "TODO: support more than 24-hr BCD mode\n");
@@ -390,9 +390,9 @@ cleanup0:
 
 static void rtc_mrst_do_shutdown(void)
 {
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	mrst_irq_disable(&mrst_rtc, RTC_IRQMASK);
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 }
 
 static void rtc_mrst_do_remove(struct device *dev)
@@ -422,7 +422,7 @@ static int mrst_suspend(struct device *dev)
 	unsigned char	tmp;
 
 	/* Only the alarm might be a wakeup event source */
-	spin_lock_irq(&rtc_lock);
+	raw_spin_lock_irq(&rtc_lock);
 	mrst->suspend_ctrl = tmp = vrtc_cmos_read(RTC_CONTROL);
 	if (tmp & (RTC_PIE | RTC_AIE)) {
 		unsigned char	mask;
@@ -436,7 +436,7 @@ static int mrst_suspend(struct device *dev)
 
 		mrst_checkintr(mrst, tmp);
 	}
-	spin_unlock_irq(&rtc_lock);
+	raw_spin_unlock_irq(&rtc_lock);
 
 	if (tmp & RTC_AIE) {
 		mrst->enabled_wake = 1;
@@ -472,7 +472,7 @@ static int mrst_resume(struct device *dev)
 			mrst->enabled_wake = 0;
 		}
 
-		spin_lock_irq(&rtc_lock);
+		raw_spin_lock_irq(&rtc_lock);
 		do {
 			vrtc_cmos_write(tmp, RTC_CONTROL);
 
@@ -484,7 +484,7 @@ static int mrst_resume(struct device *dev)
 			rtc_update_irq(mrst->rtc, 1, mask);
 			tmp &= ~RTC_AIE;
 		} while (mask & RTC_AIE);
-		spin_unlock_irq(&rtc_lock);
+		raw_spin_unlock_irq(&rtc_lock);
 	}
 
 	dev_dbg(&mrst_rtc.rtc->dev, "resume, ctrl %02x\n", tmp);
diff --git a/include/asm-generic/rtc.h b/include/asm-generic/rtc.h
index fa86f24..2ef4275 100644
--- a/include/asm-generic/rtc.h
+++ b/include/asm-generic/rtc.h
@@ -36,9 +36,9 @@ static inline unsigned char rtc_is_updating(void)
 	unsigned char uip;
 	unsigned long flags;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 	return uip;
 }
 
@@ -69,7 +69,7 @@ static inline unsigned int __get_rtc_time(struct rtc_time *time)
 	 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
 	 * by the RTC when initially set to a non-zero value.
 	 */
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 	time->tm_sec = CMOS_READ(RTC_SECONDS);
 	time->tm_min = CMOS_READ(RTC_MINUTES);
 	time->tm_hour = CMOS_READ(RTC_HOURS);
@@ -80,7 +80,7 @@ static inline unsigned int __get_rtc_time(struct rtc_time *time)
 	real_year = CMOS_READ(RTC_DEC_YEAR);
 #endif
 	ctrl = CMOS_READ(RTC_CONTROL);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	if (!(ctrl & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
 	{
@@ -133,7 +133,7 @@ static inline int __set_rtc_time(struct rtc_time *time)
 	if (yrs > 255)	/* They are unsigned */
 		return -EINVAL;
 
-	spin_lock_irqsave(&rtc_lock, flags);
+	raw_spin_lock_irqsave(&rtc_lock, flags);
 #ifdef CONFIG_MACH_DECSTATION
 	real_yrs = yrs;
 	leap_yr = ((!((yrs + 1900) % 4) && ((yrs + 1900) % 100)) ||
@@ -154,7 +154,7 @@ static inline int __set_rtc_time(struct rtc_time *time)
 	 * whether the chip is in binary mode or not.
 	 */
 	if (yrs > 169) {
-		spin_unlock_irqrestore(&rtc_lock, flags);
+		raw_spin_unlock_irqrestore(&rtc_lock, flags);
 		return -EINVAL;
 	}
 
@@ -189,7 +189,7 @@ static inline int __set_rtc_time(struct rtc_time *time)
 	CMOS_WRITE(save_control, RTC_CONTROL);
 	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
 
-	spin_unlock_irqrestore(&rtc_lock, flags);
+	raw_spin_unlock_irqrestore(&rtc_lock, flags);
 
 	return 0;
 }
diff --git a/include/linux/mc146818rtc.h b/include/linux/mc146818rtc.h
index 433e0c7..46e2c51 100644
--- a/include/linux/mc146818rtc.h
+++ b/include/linux/mc146818rtc.h
@@ -17,7 +17,7 @@
 
 #ifdef __KERNEL__
 #include <linux/spinlock.h>		/* spinlock_t */
-extern spinlock_t rtc_lock;		/* serialize CMOS RAM access */
+extern raw_spinlock_t rtc_lock;		/* serialize CMOS RAM access */
 
 /* Some RTCs extend the mc146818 register set to support alarms of more
  * than 24 hours in the future; or dates that include a century code.
-- 
1.7.5.4

