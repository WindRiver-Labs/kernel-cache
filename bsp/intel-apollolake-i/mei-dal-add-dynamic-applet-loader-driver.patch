From 6bcbbab8fad8242cf47ef07b8308efe51dc3c7d3 Mon Sep 17 00:00:00 2001
From: Evyatar Vaalani <evyatar.vaalani@intel.com>
Date: Thu, 25 Feb 2016 03:42:16 +0200
Subject: [PATCH 2505/2508] mei: dal: add dynamic applet loader driver

commit a9bd124be090e2a0fc73ae3c5bd27dee03f178d3 from
https://github.com/01org/linux-apollolake-i

Dynamic Application Loader enables loading and running
java applets inside MEI security engine.

The DAL driver binds to 3 MEI bus devicese and exposes them
to the user space via character devices and for in-kernel
usage via in-kernel API.

Both API are still subject to change
The driver is enabled with CONFIG_INTEL_MEI_DAL=y/m

Change-Id: I56df0f08e0d9c91efc0e8bb53a612545038138f6
Signed-off-by: Evyatar Vaalani <evyatar.vaalani@intel.com>
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
---
 drivers/misc/mei/Kconfig                 |    1 +
 drivers/misc/mei/Makefile                |    1 +
 drivers/misc/mei/dal/Kconfig             |    6 +
 drivers/misc/mei/dal/Makefile            |    9 +
 drivers/misc/mei/dal/README              |   28 +
 drivers/misc/mei/dal/admin_pack_ext.c    |  161 ++++++
 drivers/misc/mei/dal/admin_pack_int.c    |  317 +++++++++++
 drivers/misc/mei/dal/bh_acp_exp.h        |   87 +++
 drivers/misc/mei/dal/bh_acp_format.h     |  187 +++++++
 drivers/misc/mei/dal/bh_acp_internal.h   |   94 ++++
 drivers/misc/mei/dal/bh_shared_errcode.h |  207 +++++++
 drivers/misc/mei/dal/bh_shared_types.h   |  103 ++++
 drivers/misc/mei/dal/bhp_exp.h           |  176 ++++++
 drivers/misc/mei/dal/bhp_heci.h          |  202 +++++++
 drivers/misc/mei/dal/bhp_impl.c          |  882 ++++++++++++++++++++++++++++++
 drivers/misc/mei/dal/bhp_impl.h          |  177 ++++++
 drivers/misc/mei/dal/bhp_impl_ta.c       |  647 ++++++++++++++++++++++
 drivers/misc/mei/dal/dal_cdev.c          |  241 ++++++++
 drivers/misc/mei/dal/dal_cdev.h          |   68 +++
 drivers/misc/mei/dal/dal_class.c         |  720 ++++++++++++++++++++++++
 drivers/misc/mei/dal/dal_dev.h           |  229 ++++++++
 drivers/misc/mei/dal/dal_kdi.c           |  393 +++++++++++++
 include/linux/dal.h                      |  173 ++++++
 23 files changed, 5109 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/mei/dal/Kconfig
 create mode 100644 drivers/misc/mei/dal/Makefile
 create mode 100644 drivers/misc/mei/dal/README
 create mode 100644 drivers/misc/mei/dal/admin_pack_ext.c
 create mode 100644 drivers/misc/mei/dal/admin_pack_int.c
 create mode 100644 drivers/misc/mei/dal/bh_acp_exp.h
 create mode 100644 drivers/misc/mei/dal/bh_acp_format.h
 create mode 100644 drivers/misc/mei/dal/bh_acp_internal.h
 create mode 100644 drivers/misc/mei/dal/bh_shared_errcode.h
 create mode 100644 drivers/misc/mei/dal/bh_shared_types.h
 create mode 100644 drivers/misc/mei/dal/bhp_exp.h
 create mode 100644 drivers/misc/mei/dal/bhp_heci.h
 create mode 100644 drivers/misc/mei/dal/bhp_impl.c
 create mode 100644 drivers/misc/mei/dal/bhp_impl.h
 create mode 100644 drivers/misc/mei/dal/bhp_impl_ta.c
 create mode 100644 drivers/misc/mei/dal/dal_cdev.c
 create mode 100644 drivers/misc/mei/dal/dal_cdev.h
 create mode 100644 drivers/misc/mei/dal/dal_class.c
 create mode 100644 drivers/misc/mei/dal/dal_dev.h
 create mode 100644 drivers/misc/mei/dal/dal_kdi.c
 create mode 100644 include/linux/dal.h

diff --git a/drivers/misc/mei/Kconfig b/drivers/misc/mei/Kconfig
index 2a82520..7453b1b 100644
--- a/drivers/misc/mei/Kconfig
+++ b/drivers/misc/mei/Kconfig
@@ -45,3 +45,4 @@ config INTEL_MEI_TXE
 	  Intel Bay Trail
 
 source "drivers/misc/mei/spd/Kconfig"
+source "drivers/misc/mei/dal/Kconfig"
diff --git a/drivers/misc/mei/Makefile b/drivers/misc/mei/Makefile
index ee761e0..8cee036 100644
--- a/drivers/misc/mei/Makefile
+++ b/drivers/misc/mei/Makefile
@@ -25,3 +25,4 @@ mei-$(CONFIG_EVENT_TRACING) += mei-trace.o
 CFLAGS_mei-trace.o = -I$(src)
 
 obj-$(CONFIG_INTEL_MEI_SPD) += spd/
+obj-$(CONFIG_INTEL_MEI_DAL) += dal/
diff --git a/drivers/misc/mei/dal/Kconfig b/drivers/misc/mei/dal/Kconfig
new file mode 100644
index 0000000..8b9cef9
--- /dev/null
+++ b/drivers/misc/mei/dal/Kconfig
@@ -0,0 +1,6 @@
+config INTEL_MEI_DAL
+	tristate "Dynamic Application Loader for ME"
+	depends on INTEL_MEI
+	help
+	  Dynamic Application Loader enables running java applets
+	  for user space clients and kernel space clients.
diff --git a/drivers/misc/mei/dal/Makefile b/drivers/misc/mei/dal/Makefile
new file mode 100644
index 0000000..7574e7f
--- /dev/null
+++ b/drivers/misc/mei/dal/Makefile
@@ -0,0 +1,9 @@
+ccflags-y += -DDEBUG
+obj-$(CONFIG_INTEL_MEI_DAL) += mei_dal.o
+mei_dal-objs := dal_class.o
+mei_dal-objs += dal_cdev.o
+mei_dal-objs += dal_kdi.o
+mei_dal-objs += admin_pack_ext.o
+mei_dal-objs += admin_pack_int.o
+mei_dal-objs += bhp_impl.o
+mei_dal-objs += bhp_impl_ta.o
diff --git a/drivers/misc/mei/dal/README b/drivers/misc/mei/dal/README
new file mode 100644
index 0000000..15ddd24
--- /dev/null
+++ b/drivers/misc/mei/dal/README
@@ -0,0 +1,28 @@
+1. Base:
+	Description:
+		- base dal infrastucture
+		- registeration
+		- io
+	Files:
+		dal_class.c
+	Prefix:
+		dal_XXX
+2. User space API:
+	Description:
+		character device api
+	Files:
+		dal_cdev.c dal_cdev.h
+	Prefix:
+		dal_dev_XXX
+3. Kernel space API:
+	Description:
+		- kernel api
+	FIles:
+		dal_kdi.c
+	Prefix:
+
+4. BH Plugin:
+	Prefix:
+		bh_XXXX
+
+TOOD:
diff --git a/drivers/misc/mei/dal/admin_pack_ext.c b/drivers/misc/mei/dal/admin_pack_ext.c
new file mode 100644
index 0000000..d08abec
--- /dev/null
+++ b/drivers/misc/mei/dal/admin_pack_ext.c
@@ -0,0 +1,161 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#include <linux/kernel.h>
+
+#include "bh_acp_exp.h"
+#include "bh_acp_internal.h"
+
+static int acp_load_pack(const char *raw_pack, unsigned int size,
+			 int cmd_id, struct ac_pack *pack)
+{
+	int ret;
+	struct pack_reader pr;
+	struct ac_ins_jta_pack_ext *pack_ext;
+	struct ac_ins_jta_prop_ext *prop_ext;
+
+	if (pr_init(raw_pack, size, &pr) != BH_SUCCESS)
+		return BHE_INVALID_BPK_FILE;
+
+	if (cmd_id != AC_INSTALL_JTA_PROP) {
+		ret = acp_load_pack_head(&pr, &pack->head);
+		if (ret)
+			return ret;
+	}
+
+	if (cmd_id != AC_INSTALL_JTA_PROP && cmd_id != pack->head->cmd_id)
+		return BHE_BAD_PARAMETER;
+
+	switch (cmd_id) {
+	case AC_INSTALL_JTA:
+		pack_ext = (struct ac_ins_jta_pack_ext *)pack;
+		ret = acp_load_ins_jta(&pr, &pack_ext->cmd_pack);
+		if (ret)
+			break;
+		ret = acp_load_ta_pack(&pr, &pack_ext->ta_pack);
+		break;
+	case AC_INSTALL_JTA_PROP:
+		prop_ext = (struct ac_ins_jta_prop_ext *)pack;
+		ret = acp_load_ins_jta_prop(&pr, &prop_ext->cmd_pack);
+		if (ret)
+			break;
+		/* Note: the next section is JEFF file,
+		 * and not ta_pack(JTA_properties+JEFF file),
+		 * but we could reuse the ACP_load_ta_pack() here.
+		 */
+		ret = acp_load_ta_pack(&pr, &prop_ext->jeff_pack);
+		break;
+	default:
+		return BHE_BAD_PARAMETER;
+	}
+	if (pr_is_end(&pr) != BH_SUCCESS)
+		return BHE_INVALID_BPK_FILE;
+
+	return ret;
+}
+
+int acp_pload_ins_jta(const void *raw_data, unsigned int size,
+		      struct ac_ins_jta_pack_ext *pack)
+{
+	int ret;
+
+	if (!raw_data || size <= BH_ACP_CSS_HEADER_LENGTH || !pack)
+		return BHE_BAD_PARAMETER;
+
+	ret = acp_load_pack((const char *)raw_data + BH_ACP_CSS_HEADER_LENGTH,
+			size - BH_ACP_CSS_HEADER_LENGTH,
+			AC_INSTALL_JTA, (struct ac_pack *)pack);
+
+	return ret;
+}
+
+int acp_pload_ins_jta_prop(const void *raw_data, unsigned int size,
+			   struct ac_ins_jta_prop_ext *pack)
+{
+	if (!raw_data || !pack)
+		return BHE_BAD_PARAMETER;
+
+	return acp_load_pack(raw_data, size, AC_INSTALL_JTA_PROP,
+			    (struct ac_pack *)pack);
+}
+
+int acp_get_cmd_id(const void *raw_data, unsigned int size, int *cmd_id)
+{
+	int ret;
+	struct pack_reader pr;
+	struct ac_pack_header *ph = NULL;
+
+	if (!raw_data || size <= BH_ACP_CSS_HEADER_LENGTH || !cmd_id)
+		return BHE_BAD_PARAMETER;
+
+	*cmd_id = AC_CMD_INVALID;
+
+	ret = pr_init((const char *)raw_data + BH_ACP_CSS_HEADER_LENGTH,
+			size - BH_ACP_CSS_HEADER_LENGTH,
+			&pr);
+	if (ret != BH_SUCCESS)
+		return BHE_INVALID_BPK_FILE;
+
+	ret = acp_load_pack_head(&pr, &ph);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	*cmd_id = ph->cmd_id;
+	return BH_SUCCESS;
+}
diff --git a/drivers/misc/mei/dal/admin_pack_int.c b/drivers/misc/mei/dal/admin_pack_int.c
new file mode 100644
index 0000000..77b61d3
--- /dev/null
+++ b/drivers/misc/mei/dal/admin_pack_int.c
@@ -0,0 +1,317 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+/*
+ * @file  admin_pack_int.cpp
+ * @brief This file implements internal atomic api of admin command parsing
+ *        The counter part which generate admin package is BPKT
+ * @author Wenlong Feng(wenlong.feng@intel.com)
+ */
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+
+#include "bh_shared_errcode.h"
+#include "bh_acp_format.h"
+#include "bh_acp_internal.h"
+#include "bh_acp_exp.h"
+
+#define PR_ALIGN 4
+
+int pr_init(const char *data, unsigned int n, struct pack_reader *out)
+{
+	/* check integer overflow */
+	if ((size_t)data > SIZE_MAX - n)
+		return BHE_INVALID_BPK_FILE;
+
+	out->cur = out->head = data;
+	out->total = n;
+	return BH_SUCCESS;
+}
+
+static int pr_8b_align_move(struct pack_reader *pr, size_t n_move)
+{
+	unsigned long offset;
+	const char *new_cur = pr->cur + n_move;
+	size_t len_from_head = new_cur - pr->head;
+
+	if ((size_t)pr->cur > SIZE_MAX - n_move || new_cur < pr->head)
+		return BHE_INVALID_BPK_FILE;
+
+	offset = ((8 - (len_from_head & 7)) & 7);
+	if ((size_t)new_cur > SIZE_MAX - offset)
+		return BHE_INVALID_BPK_FILE;
+
+	new_cur = new_cur + offset;
+	if (new_cur > pr->head + pr->total)
+		return BHE_INVALID_BPK_FILE;
+
+	pr->cur = new_cur;
+	return BH_SUCCESS;
+}
+
+static int pr_align_move(struct pack_reader *pr, size_t n_move)
+{
+	const char *new_cur = pr->cur + n_move;
+	size_t len_from_head = new_cur - pr->head;
+	size_t offset;
+
+	if ((size_t)pr->cur > SIZE_MAX - n_move || new_cur < pr->head)
+		return BHE_INVALID_BPK_FILE;
+
+	offset = ((4 - (len_from_head & 3)) & 3);
+	if ((size_t)new_cur > SIZE_MAX - offset)
+		return BHE_INVALID_BPK_FILE;
+
+	new_cur = new_cur + offset;
+	if (new_cur > pr->head + pr->total)
+		return BHE_INVALID_BPK_FILE;
+
+	pr->cur = new_cur;
+	return BH_SUCCESS;
+}
+
+static int pr_move(struct pack_reader *pr, size_t n_move)
+{
+	const char *new_cur = pr->cur + n_move;
+
+	/* integer overflow or out of acp pkg size */
+	if ((size_t)pr->cur > SIZE_MAX - n_move ||
+	    new_cur > pr->head + pr->total)
+		return BHE_INVALID_BPK_FILE;
+
+	pr->cur = new_cur;
+	return BH_SUCCESS;
+}
+
+static int pr_is_safe_to_read(const struct pack_reader *pr, size_t n_move)
+{
+	/* pointer overflow */
+	if ((size_t)pr->cur > SIZE_MAX - n_move)
+		return BHE_INVALID_BPK_FILE;
+
+	if (pr->cur + n_move > pr->head + pr->total)
+		return BHE_INVALID_BPK_FILE;
+
+	return BH_SUCCESS;
+}
+
+int pr_is_end(struct pack_reader *pr)
+{
+	if (pr->cur == pr->head + pr->total)
+		return BH_SUCCESS;
+	else
+		return BHE_INVALID_BPK_FILE;
+}
+
+static int acp_load_reasons(struct pack_reader *pr,
+			    struct ac_ins_reasons **reasons)
+{
+	size_t len;
+
+	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_reasons))
+			== BH_SUCCESS) {
+		*reasons = (struct ac_ins_reasons *) (pr->cur);
+		if ((*reasons)->len > BH_MAX_ACP_INS_REASONS_LENGTH)
+			return BHE_INVALID_BPK_FILE;
+		len = sizeof(struct ac_ins_reasons) +
+				(*reasons)->len * sizeof((*reasons)->data[0]);
+		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
+			return pr_align_move(pr, len);
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+static int acp_load_taid_list(struct pack_reader *pr,
+			      struct bh_ta_id_list **taid_list)
+{
+	size_t len;
+
+	if (pr_is_safe_to_read(pr, sizeof(struct bh_ta_id_list)) ==
+			BH_SUCCESS) {
+		*taid_list = (struct bh_ta_id_list *) (pr->cur);
+		if ((*taid_list)->num > BH_MAX_ACP_USED_SERVICES)
+			return BHE_INVALID_BPK_FILE;
+
+		len = sizeof(struct bh_ta_id_list) +
+				(*taid_list)->num *
+				sizeof((*taid_list)->list[0]);
+
+		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
+			return pr_align_move(pr, len);
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+static int acp_load_prop(struct pack_reader *pr, struct bh_prop_list **prop)
+{
+	size_t len;
+
+	if (pr_is_safe_to_read(pr, sizeof(struct bh_prop_list)) == BH_SUCCESS) {
+		*prop = (struct bh_prop_list *)pr->cur;
+		if ((*prop)->len > BH_MAX_ACP_PROPS_LENGTH)
+			return BHE_INVALID_BPK_FILE;
+
+		len = sizeof(struct bh_prop_list) +
+				(*prop)->len * sizeof((*prop)->data[0]);
+
+		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
+			return pr_align_move(pr, len);
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+int acp_load_ta_pack(struct pack_reader *pr, char **ta_pack)
+{
+	size_t len;
+
+	/*8 byte align to obey jeff rule*/
+	if (pr_8b_align_move(pr, 0) == BH_SUCCESS) {
+		*ta_pack = (char *)pr->cur;
+
+		/*
+		 *assume ta pack is the last item of one package,
+		 *move cursor to the end directly
+		 */
+		if (pr->cur > pr->head + pr->total)
+			return BHE_INVALID_BPK_FILE;
+		len = pr->head + pr->total - pr->cur;
+		if (pr_is_safe_to_read(pr, len) == BH_SUCCESS)
+			return pr_move(pr, len);
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+static int acp_load_ins_jta_prop_head(struct pack_reader *pr,
+				      struct ac_ins_jta_prop_header **head)
+{
+	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_jta_prop_header))
+			== BH_SUCCESS) {
+		*head = (struct ac_ins_jta_prop_header *) (pr->cur);
+		return pr_align_move(pr, sizeof(struct ac_ins_jta_prop_header));
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+int acp_load_ins_jta_prop(struct pack_reader *pr, struct ac_ins_jta_prop *pack)
+{
+	int ret;
+
+	ret = acp_load_ins_jta_prop_head(pr, &pack->head);
+	if (ret != BH_SUCCESS)
+		goto out;
+
+	ret = acp_load_reasons(pr, &pack->post_reasons);
+	if (ret != BH_SUCCESS)
+		goto out;
+
+	ret = acp_load_reasons(pr, &pack->reg_reasons);
+	if (ret != BH_SUCCESS)
+		goto out;
+
+	ret = acp_load_prop(pr, &pack->prop);
+	if (ret != BH_SUCCESS)
+		goto out;
+
+	ret = acp_load_taid_list(pr, &pack->used_service_list);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+out:
+	return ret;
+}
+
+static int acp_load_ins_jta_head(struct pack_reader *pr,
+				 struct ac_ins_ta_header **head)
+{
+	if (pr_is_safe_to_read(pr, sizeof(struct ac_ins_ta_header)) ==
+			BH_SUCCESS) {
+		*head = (struct ac_ins_ta_header *) (pr->cur);
+		return pr_align_move(pr, sizeof(struct ac_ins_ta_header));
+	}
+	return BHE_INVALID_BPK_FILE;
+}
+
+int acp_load_ins_jta(struct pack_reader *pr, struct ac_ins_jta_pack *pack)
+{
+	int ret;
+
+	ret = acp_load_prop(pr, &pack->ins_cond);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	ret = acp_load_ins_jta_head(pr, &pack->head);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	return BH_SUCCESS;
+}
+
+int acp_load_pack_head(struct pack_reader *pr, struct ac_pack_header **head)
+{
+	int is_safe_to_read;
+
+	is_safe_to_read = pr_is_safe_to_read(pr, sizeof(struct ac_pack_header));
+	if (is_safe_to_read == BH_SUCCESS) {
+		*head = (struct ac_pack_header *) (pr->cur);
+		return pr_align_move(pr, sizeof(struct ac_pack_header));
+	}
+	return BHE_INVALID_BPK_FILE;
+}
diff --git a/drivers/misc/mei/dal/bh_acp_exp.h b/drivers/misc/mei/dal/bh_acp_exp.h
new file mode 100644
index 0000000..498b9ba
--- /dev/null
+++ b/drivers/misc/mei/dal/bh_acp_exp.h
@@ -0,0 +1,87 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __BH_ACP_EXP_H
+#define __BH_ACP_EXP_H
+
+#include "bh_shared_errcode.h"
+#include "bh_acp_format.h"
+
+struct ac_ins_jta_pack_ext {
+	struct ac_pack_header *head;
+	struct ac_ins_jta_pack cmd_pack;
+	char *ta_pack;
+} __packed;
+
+struct ac_ins_jta_prop_ext {
+	struct ac_ins_jta_prop cmd_pack;
+	char *jeff_pack;
+} __packed;
+
+
+int acp_pload_ins_jta(const void *raw_data, unsigned int size,
+		      struct ac_ins_jta_pack_ext *pack);
+
+int acp_pload_ins_jta_prop(const void *raw_data, unsigned int size,
+			   struct ac_ins_jta_prop_ext *pack);
+
+int acp_get_cmd_id(const void *raw_data, unsigned int size, int *cmd_id);
+
+#endif /* __BH_ACP_EXP_H */
diff --git a/drivers/misc/mei/dal/bh_acp_format.h b/drivers/misc/mei/dal/bh_acp_format.h
new file mode 100644
index 0000000..10b3894
--- /dev/null
+++ b/drivers/misc/mei/dal/bh_acp_format.h
@@ -0,0 +1,187 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef BH_ACP_FORMAT_H
+#define BH_ACP_FORMAT_H
+
+#include "bh_shared_types.h"
+
+/* make sure those limitation values are adjusted to real world */
+#define BH_MAX_ACP_INS_REASONS_LENGTH 1024
+#define BH_MAX_ACP_USED_SERVICES 20
+#define BH_MAX_ACP_PROPS_LENGTH 2048
+
+enum ac_cmd_id {
+
+	AC_CMD_INVALID,
+	AC_INSTALL_SD,
+	AC_UNINSTALL_SD,
+	AC_INSTALL_JTA,
+	AC_UNINSTALL_JTA,
+	AC_INSTALL_NTA,
+	AC_UNINSTALL_NTA,
+	AC_UPDATE_SVL,
+	AC_INSTALL_JTA_PROP,
+	AC_CMD_NUM
+};
+
+enum ac_ta_type {
+	AC_TA_TYPE_BOTH,
+	AC_TA_TYPE_JAVA,
+	AC_TA_TYPE_NATIVE,
+};
+
+#pragma pack(1)
+
+struct ac_pack_header {
+	/*ACP Header*/
+	u8 magic[4];
+	u8 version;
+	u8 little_endian;
+	u16 reserved;
+	u32 size;/*total package size in byte except signature*/
+	u32 cmd_id;
+	u32 svn;
+
+	/*Section Index*/
+	u32 idx_num;
+	u32 idx_condition;
+	/*TBD: BH_U32 idx_encrypt;*/
+	u32 idx_data;
+};
+
+struct ac_name {
+	u8 len;/*the size of data in byte*/
+	s8 data[0];
+};
+
+struct bh_ta_id_list {
+	u32 num;
+	struct bh_ta_id list[0];
+};
+
+/*
+ * Firmware properties are formatted as "type\0key\0value\0"
+ * Example: "string\0name\0Tom\0int\0Age\013\0"
+ */
+struct bh_prop_list {
+	u32 num; /*number of properties*/
+	u32 len; /*the size of data in byte*/
+	s8 data[0];
+};
+
+struct ac_ins_reasons {
+	/* NOTE: len means the amount of items in data,
+	 * when counting total bytes, you need to multiply
+	 * it with sizeof(data[0])
+	 */
+	u32 len;
+	u32 data[0];
+};
+
+#pragma pack()
+
+#pragma pack(1)
+
+/*
+ * below structures are the parsing result that application layer should use
+ * they are in-memory representation of admin packages
+ */
+struct ac_pack {
+	struct ac_pack_header *head;
+	/*the type of data depends on head->cmd_id*/
+	char data[0];
+/*--ACSignature is appendeded after command package*/
+};
+
+struct ac_ins_ta_header {
+	struct bh_ta_id ta_id;
+	u32 ta_svn;
+	u8 hash_alg_type;
+	u8 ta_reserved[3];
+	struct bh_pack_hash hash;
+};
+/*header struct shared between JTA and NTA*/
+
+struct ac_ins_jta_pack {
+	struct bh_prop_list *ins_cond;
+	struct ac_ins_ta_header *head;
+};
+
+struct ac_ins_jta_prop_header {
+	u32 mem_quota;
+	u8 ta_encrypted;
+	u8 padding;
+	u16 allowed_inter_session_num;
+	u64 ac_groups;
+	u32 timeout;
+};
+
+struct ac_ins_jta_prop {
+	struct ac_ins_jta_prop_header *head;
+	struct ac_ins_reasons *post_reasons;
+	struct ac_ins_reasons *reg_reasons;
+	struct bh_prop_list *prop;
+	struct bh_ta_id_list *used_service_list;
+};
+
+#pragma pack()
+
+#endif
diff --git a/drivers/misc/mei/dal/bh_acp_internal.h b/drivers/misc/mei/dal/bh_acp_internal.h
new file mode 100644
index 0000000..d9667bc
--- /dev/null
+++ b/drivers/misc/mei/dal/bh_acp_internal.h
@@ -0,0 +1,94 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _BH_ACP_INTERNAL_H
+#define _BH_ACP_INTERNAL_H
+
+#include "bh_shared_types.h"
+#include "bh_shared_errcode.h"
+#include "bh_acp_format.h"
+
+/* Intel CSS Header + CSS Cypto Block which prefixes each signed ACP pkg */
+#define BH_ACP_CSS_HEADER_LENGTH    (128 + 520)
+
+/*
+ * PackReader hold a reference of raw pack and read
+ * items with alignment support
+ */
+struct pack_reader {
+	const char *cur;
+	const char *head;
+	unsigned int total;
+};
+
+int pr_init(const char *data, unsigned int n, struct pack_reader *out);
+
+/*whether pack reader reaches the end of buffer, alignment considered*/
+int pr_is_end(struct pack_reader *pr);
+
+int acp_load_pack_head(struct pack_reader *pr, struct ac_pack_header **head);
+
+int acp_load_ins_jta(struct pack_reader *pr, struct ac_ins_jta_pack *pack);
+
+int acp_load_ta_pack(struct pack_reader *pr, char **ta_pack);
+
+int acp_load_ins_jta_prop(struct pack_reader *pr, struct ac_ins_jta_prop *pack);
+
+#endif /*_BH_ACP_INTERNAL_H */
diff --git a/drivers/misc/mei/dal/bh_shared_errcode.h b/drivers/misc/mei/dal/bh_shared_errcode.h
new file mode 100644
index 0000000..063af27
--- /dev/null
+++ b/drivers/misc/mei/dal/bh_shared_errcode.h
@@ -0,0 +1,207 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __BH_SHARED_ERRCODE_H
+#define __BH_SHARED_ERRCODE_H
+
+/*
+ * BH Error codes numbers across Beihai Host and Firmware.
+ */
+
+#define BH_SUCCESS                              0x000
+
+/* BHP specific error code section */
+
+#define BPE_NOT_INIT                            0x001
+#define BPE_SERVICE_UNAVAILABLE                 0x002
+#define BPE_INTERNAL_ERROR                      0x003
+#define BPE_COMMS_ERROR                         0x004
+#define BPE_OUT_OF_MEMORY                       0x005
+#define BPE_INVALID_PARAMS                      0x006
+#define BPE_MESSAGE_TOO_SHORT                   0x007
+#define BPE_MESSAGE_ILLEGAL                     0x008
+#define BPE_NO_CONNECTION_TO_FIRMWARE           0x009
+#define BPE_NOT_IMPLEMENT                       0x00A
+#define BPE_OUT_OF_RESOURCE                     0x00B
+#define BPE_INITIALIZED_ALREADY                 0x00C
+#define BPE_CONNECT_FAILED                      0x00D
+
+/* General error code section for Beihai on FW: 0x100 */
+
+#define BHE_OUT_OF_MEMORY                       0x101
+#define BHE_BAD_PARAMETER                       0x102
+#define BHE_INSUFFICIENT_BUFFER                 0x103
+#define BHE_MUTEX_INIT_FAIL                     0x104
+#define BHE_COND_INIT_FAIL                      0x105
+#define BHE_WD_TIMEOUT                          0x106
+#define BHE_FAILED                              0x107
+#define BHE_INVALID_HANDLE                      0x108
+#define BHE_IPC_ERR_DEFAULT                     0x109
+#define BHE_IPC_ERR_PLATFORM                    0x10A
+#define BHE_IPC_SRV_INIT_FAIL                   0x10B
+
+/* VM communication error code section:         0x200 */
+
+#define BHE_MAILBOX_NOT_FOUND                   0x201
+#define BHE_APPLET_CRASHED                      BHE_MAILBOX_NOT_FOUND
+#define BHE_MSG_QUEUE_IS_FULL                   0x202
+#define BHE_MAILBOX_DENIED                      0x203
+
+/* VM InternalAppletCommunication error         0x240 */
+
+#define BHE_IAC_INTERNAL_SESSION_NUM_EXCEED     0x241
+#define BHE_IAC_CLIENT_SLOT_FULL                0x242
+#define BHE_IAC_SERVICETA_EXITED                0x243
+#define BHE_IAC_EXIST_INTERNAL_SESSION          0x244
+#define BHE_IAC_SERVICETA_UNCAUGHT_EXCEPTION    0x245
+#define BHE_IAC_SERVICE_SESSION_NOT_FOUND       0x246
+#define BHE_IAC_SERVICE_HOST_SESSION_NUM_EXCEED 0x247
+
+/* Firmware thread/mutex error code section:     0x280 */
+#define BHE_THREAD_ERROR                        0x281
+#define BHE_THREAD_TIMED_OUT                    0x282
+
+/* Applet manager error code section:            0x300 */
+
+#define BHE_LOAD_JEFF_FAIL                      0x303
+#define BHE_PACKAGE_NOT_FOUND                   0x304
+#define BHE_EXIST_LIVE_SESSION                  0x305
+#define BHE_VM_INSTANCE_INIT_FAIL               0x306
+#define BHE_QUERY_PROP_NOT_SUPPORT              0x307
+#define BHE_INVALID_BPK_FILE                    0x308
+#define BHE_PACKAGE_EXIST                       0x309
+#define BHE_VM_INSTNACE_NOT_FOUND               0x312
+#define BHE_STARTING_JDWP_FAIL                  0x313
+#define BHE_GROUP_CHECK_FAIL                    0x314
+#define BHE_SDID_UNMATCH                        0x315
+#define BHE_APPPACK_UNINITED                    0x316
+#define BHE_SESSION_NUM_EXCEED                  0x317
+#define BHE_TA_PACKAGE_HASH_VERIFY_FAIL         0x318
+#define BHE_SWITCH_ISD                          0x319
+
+/* VM Applet instance error code section:        0x400 */
+#define BHE_APPLET_GENERIC                      0x400
+#define BHE_UNCAUGHT_EXCEPTION                  0x401
+/* Bad parameters to applet */
+#define BHE_APPLET_BAD_PARAMETER                0x402
+/* Small response buffer */
+#define BHE_APPLET_SMALL_BUFFER                 0x403
+/* Bad state */
+#define BHE_BAD_STATE                           0x404
+
+/*TODO: Should be removed these UI error code when integrate with ME 9 */
+#define BHE_UI_EXCEPTION                        0x501
+#define BHE_UI_ILLEGAL_USE                      0x502
+#define BHE_UI_ILLEGAL_PARAMETER                0x503
+#define BHE_UI_NOT_INITIALIZED                  0x504
+#define BHE_UI_NOT_SUPPORTED                    0x505
+#define BHE_UI_OUT_OF_RESOURCES                 0x506
+
+/* BeiHai VMInternalError code section:          0x600 */
+#define BHE_UNKNOWN                             0x602
+#define BHE_MAGIC_UNMATCH                       0x603
+#define BHE_UNIMPLEMENTED                       0x604
+#define BHE_INTR                                0x605
+#define BHE_CLOSED                              0x606
+/* TODO: no used error, should remove*/
+#define BHE_BUFFER_OVERFLOW                     0x607
+#define BHE_NOT_SUPPORTED                       0x608
+#define BHE_WEAR_OUT_VIOLATION                  0x609
+#define BHE_NOT_FOUND                           0x610
+#define BHE_INVALID_PARAMS                      0x611
+#define BHE_ACCESS_DENIED                       0x612
+#define BHE_INVALID                             0x614
+#define BHE_TIMEOUT                             0x615
+
+/* SDM specific error code section:              0x800 */
+#define BHE_SDM_FAILED                          0x800
+#define BHE_SDM_NOT_FOUND                       0x801
+#define BHE_SDM_ALREADY_EXIST                   0x803
+#define BHE_SDM_TATYPE_MISMATCH                 0x804
+#define BHE_SDM_TA_NUMBER_LIMIT                 0x805
+#define BHE_SDM_SIGNAGURE_VERIFY_FAIL           0x806
+#define BHE_SDM_PERMGROUP_CHECK_FAIL            0x807
+#define BHE_SDM_INSTALL_CONDITION_FAIL          0x808
+#define BHE_SDM_SVN_CHECK_FAIL                  0x809
+#define BHE_SDM_TA_DB_NO_FREE_SLOT              0x80A
+#define BHE_SDM_SD_DB_NO_FREE_SLOT              0x80B
+#define BHE_SDM_SVL_DB_NO_FREE_SLOT             0x80C
+#define BHE_SDM_SVL_CHECK_FAIL                  0x80D
+#define BHE_SDM_DB_READ_FAIL                    0x80E
+#define BHE_SDM_DB_WRITE_FAIL                   0x80F
+
+/* Launcher specific error code section:         0x900 */
+#define BHE_LAUNCHER_INIT_FAILED                0x901
+#define BHE_SD_NOT_INSTALLED                    0x902
+#define BHE_NTA_NOT_INSTALLED                   0x903
+#define BHE_PROCESS_SPAWN_FAILED                0x904
+#define BHE_PROCESS_KILL_FAILED                 0x905
+#define BHE_PROCESS_ALREADY_RUNNING             0x906
+#define BHE_PROCESS_IN_TERMINATING              0x907
+#define BHE_PROCESS_NOT_EXIST                   0x908
+#define BHE_PLATFORM_API_ERR                    0x909
+#define BHE_PROCESS_NUM_EXCEED                  0x09A
+
+/*
+ * BeihaiHAL Layer error code section:
+ * 0x1000,0x2000 reserved here, defined in CSG BeihaiStatusHAL.h
+ */
+
+#endif /* __BH_SHARED_ERRCODE_H */
diff --git a/drivers/misc/mei/dal/bh_shared_types.h b/drivers/misc/mei/dal/bh_shared_types.h
new file mode 100644
index 0000000..e90d519
--- /dev/null
+++ b/drivers/misc/mei/dal/bh_shared_types.h
@@ -0,0 +1,103 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+
+#ifndef __BH_SHARED_TYPES_H
+#define __BH_SHARED_TYPES_H
+
+#include <linux/types.h>
+
+#define BH_GUID_LENGTH 16
+#define BH_MAX_PACK_HASH_LEN 32
+
+struct bh_pack_hash {
+	u8 data[BH_MAX_PACK_HASH_LEN];
+};
+
+struct bh_ta_id {
+	u8 data[BH_GUID_LENGTH];
+};
+
+#define BH_TAID_LEN sizeof(struct bh_ta_id)
+
+struct bh_sd_id {
+	u8 data[BH_GUID_LENGTH];
+};
+
+#define BH_SDID_LEN sizeof(struct bh_sd_id)
+
+/**
+ * struct _bh_ta_install_condition_list_t:
+ *	 install_condition is like properties,
+ *	 and formatted as "type\0key\0value\0".
+ *	 Example: "string\0name\0Tom\0int\0Age\013\0"
+ *
+ * @is_user_space_client: number of properties
+ * @read_buffer: the size of data in byte
+ * @data: the data
+ */
+struct _bh_ta_install_condition_list_t {
+	u32 num;
+	u32 len;
+	s8 data[0];
+};
+
+#endif /* __BH_SHARED_TYPES_H */
+
diff --git a/drivers/misc/mei/dal/bhp_exp.h b/drivers/misc/mei/dal/bhp_exp.h
new file mode 100644
index 0000000..474a43f
--- /dev/null
+++ b/drivers/misc/mei/dal/bhp_exp.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __BHP_EXP_H__
+#define __BHP_EXP_H__
+
+#include <linux/kernel.h>
+
+#include "bh_shared_errcode.h"
+
+typedef int (*bhp_transport_send)(unsigned int handle,
+				  unsigned char *buffer,
+				  unsigned int length,
+				  u64 seq);
+
+typedef int (*bhp_transport_recv)(unsigned int handle,
+				  unsigned char *buffer,
+				  unsigned int *length);
+
+struct bhp_transport {
+	bhp_transport_send send;
+	bhp_transport_recv recv;
+};
+
+/**
+ * Invoke this function before using other API.
+ * It will try to connect ME processes(Launcher, SDM and I-VM),
+ * and create receiving threads
+ * for those process and do other initialization.
+ *
+ *
+ * @return BH_SUCCESS if initialization was successful
+ *
+ * @return BPE_NO_CONNECTION_TO_FIRMWARE if failed to HECI initialization
+ * @return BPE_INTERNAL_ERROR if receiver thread cannot be
+ * created or other internal failure
+ */
+int bhp_init_internal(const struct bhp_transport *transport);
+
+
+/**
+ * Invoke this function before exiting.
+ * If BHP_Init is not called, this function will do nothing.
+ * If anything goes wrong, please call this function to release resources.
+ *
+ * @return BH_SUCCESS if success
+ */
+int bhp_deinit_internal(void);
+
+/**
+ * Send Reset command to SDM, Launcher and VM, to let them enter initial state.
+ * This function will be blocked until receiving all the responses.
+ *
+ * @return BH_SUCCESS if success.
+ */
+int bhp_reset(void);
+
+/**
+ * Open Session to specified Java TA.
+ * The Firmware side might need to spawn the VM process,
+ * and create the TA instance.
+ * This function will also connect to the VM process's heci address.
+ * This function will block until VM replied the response.
+ * Please call BHP_Deinit() to clean up when anything goes wrong.
+ *
+ * @param session [OUT] the ta session handle, which is used in
+ * the function BHP_SendAndRecv.
+ * @param ta_id [IN] the applet ID (UUID) to create session.
+ * @param ta_pkg [in] TA binary package, i.e, .bpk data.
+ * @param pkg_len [in] The length of TA binary package in bytes.
+ * @param init_param [IN] the input buffer of the CreateSession command.
+ * @param param_len [IN] the length of init_param in bytes
+ *
+ * @return BH_SUCCESS if success
+ *
+ */
+int bhp_open_ta_session(u64 *session,
+			const char *ta_id,
+			const u8 *ta_pkg,
+			size_t pkg_len,
+			const u8 *init_param,
+			size_t param_len);
+
+/**
+ * Send a CloseTASession command to VM to close the specified Java TA session.
+ * This function will be blocked until VM replies the response.
+ *
+ * @param pSession [IN] the java ta session handle to close.
+ *
+ * @return BH_SUCCESS if success
+ *
+ */
+int bhp_close_ta_session(const u64 handle);
+
+/**
+ * Send a SendAndRecv command to VM. This function will be blocked until VM
+ * replies the response.
+ *
+ * @param handle [IN] the java ta session handle.
+ * @param command_id [IN] the command ID.
+ * @param input [IN] the input buffer to be sent to TA.
+ * @param length [IN] the length of input buffer.
+ * @param output [OUT] the pointer to output buffer.
+ * @param output_length [IN/OUT] the expected maximum length of output
+ * buffer / the actually length of output buffer.
+ * @param response_code [OUT] the command result, which is set by
+ * IntelApplet.setResponseCode()
+ *
+ * @return BH_SUCCESS if success
+ *
+ */
+int bhp_send_and_recv(const u64 handle,
+		      int command_id,
+		      const void *input,
+		      size_t length,
+		      void **output,
+		      size_t *output_length,
+		      int *response_code);
+#endif /* __BHP_EXP_H__ */
diff --git a/drivers/misc/mei/dal/bhp_heci.h b/drivers/misc/mei/dal/bhp_heci.h
new file mode 100644
index 0000000..16f1323
--- /dev/null
+++ b/drivers/misc/mei/dal/bhp_heci.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+/*
+ * @file  bhp_heci.h
+ * @brief This file defines heci command and response format
+ * for Beihai Host Proxy (BHP) module.
+ * @author
+ * @version
+ *
+ */
+
+#ifndef __BHP_HECI_H
+#define __BHP_HECI_H
+
+#include "bh_shared_types.h"
+#include "bh_shared_errcode.h"
+
+#define BHP_MSG_MAGIC_LENGTH (4)
+#define BHP_MSG_CMD_MAGIC "\xff\xa3\xaa\x55"
+#define BHP_MSG_RESPONSE_MAGIC "\xff\xa5\xaa\x55"
+
+enum bhp_command_id {
+
+	BHP_CMD_INIT = 0,
+	BHP_CMD_DEINIT,
+	BHP_CMD_VERIFY_JAVATA,
+	BHP_CMD_DOWNLOAD_JAVATA,
+	BHP_CMD_OPEN_JTASESSION,
+	BHP_CMD_CLOSE_JTASESSION,
+	BHP_CMD_FORCECLOSE_JTASESSION,
+	BHP_CMD_SENDANDRECV,
+	BHP_CMD_SENDANDRECV_INTERNAL,
+	BHP_CMD_RUN_NATIVETA,
+	BHP_CMD_STOP_NATIVETA,
+	BHP_CMD_OPEN_SDSESSION,
+	BHP_CMD_CLOSE_SDSESSION,
+	BHP_CMD_INSTALL_SD,
+	BHP_CMD_UNINSTALL_SD,
+	BHP_CMD_INSTALL_JAVATA,
+	BHP_CMD_UNINSTALL_JAVATA,
+	BHP_CMD_INSTALL_NATIVETA,
+	BHP_CMD_UNINSTALL_NATIVETA,
+	BHP_CMD_LIST_SD,
+	BHP_CMD_LIST_TA,
+	BHP_CMD_RESET,
+	BHP_CMD_LIST_TA_PROPERTIES,
+	BHP_CMD_QUERY_TA_PROPERTY,
+	BHP_CMD_LIST_JTA_SESSIONS,
+	BHP_CMD_LIST_TA_PACKAGES,
+	BHP_CMD_GET_ISD,
+	BHP_CMD_GET_SD_BY_TA,
+	BHP_CMD_LAUNCH_VM,
+	BHP_CMD_CLOSE_VM,
+	BHP_CMD_QUERY_NATIVETA_STATUS,
+	BHP_CMD_QUERY_SD_STATUS,
+	BHP_CMD_LIST_DOWNLOADED_NTA,
+	BHP_CMD_UPDATE_SVL,
+	BHP_CMD_CHECK_SVL_TA_BLOCKED_STATE,
+	BHP_CMD_QUERY_TEE_METADATA,
+	BHP_CMD_MAX
+};
+
+struct transport_msg_header {
+	u8 magic[BHP_MSG_MAGIC_LENGTH];
+	u32 length;
+};
+
+struct bhp_command_header {
+	struct transport_msg_header h;
+	u64 seq;
+	enum bhp_command_id id;
+	u8 pad[4];
+	s8 cmd[0];
+};
+
+struct bhp_response_header {
+	struct transport_msg_header h;
+	u64 seq;
+	u64 addr;
+	int code;
+	u8 pad[4];
+	s8 data[0];
+};
+
+struct bhp_download_javata_cmd {
+	struct bh_ta_id appid;
+	s8 appblob[0];
+};
+
+struct bhp_open_jtasession_cmd {
+	struct bh_ta_id appid;
+	s8 buffer[0];
+};
+
+struct bhp_close_jtasession_cmd {
+	u64 ta_session_id;
+};
+
+struct bhp_snr_cmd {
+	u64 ta_session_id;
+	s32 command;
+	u32 outlen;
+	s8 buffer[0];
+};
+
+struct bhp_check_svl_ta_blocked_state_cmd {
+	struct bh_ta_id taid;
+};
+
+struct bhp_reset_launcher_response {
+	u32 count; /* count of svm heci ports */
+	s32 vm_heci_port_list[0];
+};
+
+struct bhp_get_sd_by_ta_cmd {
+	struct bh_ta_id taid;
+};
+
+struct bhp_get_sd_by_ta_response {
+	struct bh_sd_id sdid;
+};
+
+struct bhp_get_isd_response {
+	struct bh_sd_id sdid;
+};
+
+struct bhp_snr_response {
+	/* field response comes from java BIG endian */
+	s32 response;
+	s8 buffer[0];
+};
+
+struct bhp_snr_bof_response {
+	/* field response comes from java BIG endian */
+	s32 response;
+	u32 request_length;
+};
+
+struct bhp_list_ta_packages_response {
+	u32 count;
+	struct bh_ta_id app_ids[0];
+};
+
+#endif /* __BHP_HECI_H */
diff --git a/drivers/misc/mei/dal/bhp_impl.c b/drivers/misc/mei/dal/bhp_impl.c
new file mode 100644
index 0000000..2b76b56
--- /dev/null
+++ b/drivers/misc/mei/dal/bhp_impl.c
@@ -0,0 +1,882 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#include <linux/printk.h>
+#include <linux/mei_cl_bus.h>
+#include "bhp_impl.h"
+#include "bhp_exp.h"
+#include "dal_dev.h"
+
+static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
+			   const void *data, unsigned int dlen, u64 seq);
+static int bh_recv_message(int conn_idx, u64 *seq);
+
+static int bh_proxy_reset_svm(int conn_idx);
+
+static int kdi_send_wrapper(unsigned int handle,
+		unsigned char *buffer, unsigned int length, u64 seq);
+
+static int kdi_recv_wrapper(unsigned int handle,
+		unsigned char *buffer, unsigned int *length);
+
+static unsigned int init_state = DEINITED;
+static u64 sequence_number = MSG_SEQ_START_NUMBER;
+static struct bh_connection_item connections[MAX_CONNECTIONS];
+
+/* transport func list, set during init */
+static struct bhp_transport bhp_transport = {
+	kdi_send_wrapper,
+	kdi_recv_wrapper
+};
+
+/* the isd-id in the firmware, got during init */
+static struct bh_sd_id isd_uuid;
+
+/*
+ * increment_seq_number():
+ * increase the shared variable sequence_number by 1 and wrap around if needed.
+ * note: sequence_number is shared resource among all connections/threads.
+ */
+static u64 increment_sequence_number(void)
+{
+	u64 ret = 0;
+
+	mutex_enter(bhm_seqno);
+	sequence_number++;
+	/* wrap around. sequence_number must
+	 * not be 0, as required by Firmware VM
+	 */
+	if (sequence_number == 0)
+		sequence_number = MSG_SEQ_START_NUMBER;
+
+	ret = sequence_number;
+	mutex_exit(bhm_seqno);
+
+	return ret;
+}
+
+static int kdi_send_wrapper(unsigned int handle,
+		unsigned char *buffer, unsigned int length, u64 seq)
+{
+	enum dal_dev_type mei_device;
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	struct device *dev;
+	ssize_t ret;
+
+	mei_device = (enum dal_dev_type) handle;
+
+	if (!buffer || mei_device < DAL_MEI_DEVICE_IVM ||
+			mei_device >= DAL_MEI_DEVICE_MAX)
+		return BPE_INVALID_PARAMS;
+
+	if (!length)
+		return BH_SUCCESS;
+
+	dev = dal_find_dev(mei_device);
+	if (!dev) {
+		dev_err(dev, "can't find device\n");
+		return BPE_INTERNAL_ERROR;
+	}
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KERNEL_SPACE];
+	if (!dc) {
+		dev_err(dev, "client is NULL\n");
+		ret = BPE_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* copy data to client object */
+	memcpy(dc->write_buffer, buffer, length);
+
+	ret = dal_write(dc, length, seq);
+
+	if (ret <= 0)
+		ret = BPE_COMMS_ERROR;
+	else
+		ret = BH_SUCCESS;
+
+out:
+	put_device(dev);
+	return ret;
+}
+
+/* This is only for tmp read data to client */
+static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
+static int kdi_recv_wrapper(unsigned int handle,
+		unsigned char *buffer, unsigned int *length)
+{
+	enum dal_dev_type mei_device;
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	struct device *dev;
+	ssize_t ret;
+
+	mei_device = (enum dal_dev_type) handle;
+
+	if (!buffer || !length || mei_device < DAL_MEI_DEVICE_IVM ||
+			mei_device >= DAL_MEI_DEVICE_MAX)
+		return BPE_INVALID_PARAMS;
+
+	dev = dal_find_dev(mei_device);
+	if (!dev)
+		return BPE_INTERNAL_ERROR;
+
+	ddev = to_dal_device(dev);
+	dc = ddev->clients[DAL_INTF_KERNEL_SPACE];
+	if (!dc) {
+		dev_err(dev, "client is NULL\n");
+		ret = BPE_INTERNAL_ERROR;
+		goto out;
+	}
+
+	ret = dal_read(dc);
+
+	if (ret != 0)
+		goto out;
+
+	if (kfifo_is_empty(&dc->read_queue)) {
+		ret = 0;
+		goto out;
+	}
+
+	ret = kfifo_out(&dc->read_queue,
+			&bh_msg[ddev->device_id], sizeof(struct dal_bh_msg));
+	dev_dbg(&ddev->cldev->dev, "kfifo_out() ret = %zd\n", ret);
+
+	if (bh_msg[ddev->device_id].len > *length) {
+		dev_dbg(&ddev->cldev->dev, "could not copy buffer. ");
+		dev_dbg(&ddev->cldev->dev, "src buffer size = %zd, dest buffer size = %u\n",
+				bh_msg[ddev->device_id].len, *length);
+		ret = BPE_COMMS_ERROR;
+		goto out;
+	}
+
+	memcpy(buffer, bh_msg[ddev->device_id].msg,
+			bh_msg[ddev->device_id].len);
+
+	*length = bh_msg[ddev->device_id].len;
+	ret = BH_SUCCESS;
+
+out:
+	put_device(dev);
+	return ret;
+}
+
+struct RR_MAP_INFO {
+	struct list_head link;
+	u64 seq;
+	struct bh_response_record *rr;
+};
+
+#if 0 /* for debug */
+static void rrmap_dump(struct list_head *rr_map_header)
+{
+	struct list_head *pos;
+	struct RR_MAP_INFO *rrmap_info;
+	size_t count;
+
+	count = 0;
+
+	list_for_each(pos, rr_map_header) {
+		rrmap_info = list_entry(pos, struct RR_MAP_INFO, link);
+		if (rrmap_info) {
+			pr_debug("rrmap_dump: [%02x] seq: %llu, rr->addr: %llu",
+				  count, rrmap_info->seq, rrmap_info->rr->addr);
+			count++;
+		}
+	}
+}
+#endif
+
+static struct RR_MAP_INFO *rrmap_find_by_addr(struct list_head *rr_map_header,
+					      u64 seq)
+{
+	struct list_head *pos;
+	struct RR_MAP_INFO *rrmap_info;
+
+	list_for_each(pos, rr_map_header)
+	{
+
+		rrmap_info = list_entry(pos, struct RR_MAP_INFO, link);
+		if (rrmap_info && rrmap_info->seq == seq)
+			return rrmap_info;
+	}
+
+	return NULL;
+}
+
+u64 rrmap_add(int conn_idx, struct bh_response_record *rr)
+{
+	u64 seq = increment_sequence_number();
+	struct RR_MAP_INFO *rrmap_info;
+
+	/* TODO: check if malloc succeeded: need to refactor the usage
+	 * of rrmap_add() to check and handle errors
+	 */
+	rrmap_info = kzalloc(sizeof(struct RR_MAP_INFO), GFP_KERNEL);
+
+	rrmap_info->seq = seq;
+	rrmap_info->rr = rr;
+
+	list_add_tail(&rrmap_info->link,
+		     &connections[conn_idx].rr_map_list_header);
+
+	return rrmap_info->seq;
+}
+
+/**
+ * in the original BHP they use a map, in the kernel we don't have a map.
+ * we're using a list.
+ * in BHP they simply delete an element from the map.
+ * so in order to remove a record which is a session we added a parameter
+ * 'remove_record'.
+ */
+static struct bh_response_record *rrmap_remove(int conn_idx, u64 seq,
+					       bool remove_record)
+{
+	struct RR_MAP_INFO *rrmap_info;
+	struct bh_response_record *rr = NULL;
+
+	rrmap_info =
+		rrmap_find_by_addr(&connections[conn_idx].rr_map_list_header,
+				   seq);
+
+	if (rrmap_info != NULL) {
+		rr = rrmap_info->rr;
+		if (!rr->is_session || remove_record) {
+			list_del_init(&rrmap_info->link);
+			kfree(rrmap_info);
+		}
+	}
+
+	return rr;
+}
+
+static struct bh_response_record *addr2record(int conn_idx, u64 seq)
+{
+	struct bh_response_record *rr = NULL;
+	struct RR_MAP_INFO *rrmap_info;
+
+	rrmap_info =
+		rrmap_find_by_addr(&connections[conn_idx].rr_map_list_header,
+				   seq);
+
+	if (rrmap_info != NULL)
+		rr = rrmap_info->rr;
+
+	return rr;
+}
+
+static void destroy_session(struct bh_response_record *session)
+{
+	if (session)
+		kfree(session->buffer);
+	kfree(session);
+}
+
+struct bh_response_record *session_enter(int conn_idx, u64 seq,
+					 int lock_session)
+{
+	struct bh_response_record *session = NULL;
+	struct RR_MAP_INFO *rrmap_info;
+
+	mutex_enter(connections[conn_idx].bhm_rrmap);
+
+	rrmap_info =
+		rrmap_find_by_addr(&connections[conn_idx].rr_map_list_header,
+				   seq);
+
+	if (rrmap_info) {
+
+		if (rrmap_info->rr->is_session && !rrmap_info->rr->killed) {
+			session = rrmap_info->rr;
+
+			if (session->count < MAX_SESSION_LIMIT)
+				session->count++;
+			else
+				session = NULL;
+		}
+	}
+
+	mutex_exit(connections[conn_idx].bhm_rrmap);
+
+	if (session && lock_session) {
+		mutex_enter(session->session_lock);
+
+		/* check whether session has been
+		 * killed before session operation
+		 */
+		if (session->killed) {
+			session_exit(conn_idx, session, seq, 1);
+			session = NULL;
+		}
+	}
+
+	return session;
+}
+
+void session_exit(int conn_idx, struct bh_response_record *session,
+		  u64 seq, int unlock_session)
+{
+	bool close_vm_conn = false;
+
+	mutex_enter(connections[conn_idx].bhm_rrmap);
+	session->count--;
+
+	if (session->count == 0 && session->killed) {
+		rrmap_remove(conn_idx, seq, true);
+
+		if (unlock_session)
+			mutex_exit(session->session_lock);
+
+		destroy_session(session);
+		if (conn_idx >= CONN_IDX_SVM)
+			close_vm_conn = true;
+	} else {
+		if (unlock_session)
+			mutex_exit(session->session_lock);
+	}
+
+	mutex_exit(connections[conn_idx].bhm_rrmap);
+
+	/* remove the VM conn counter of
+	 * this session:only for connected SVM
+	 */
+	if (close_vm_conn)
+		bh_do_close_vm(conn_idx);
+}
+
+void session_close(int conn_idx, struct bh_response_record *session,
+		   u64 seq, int unlock_session)
+{
+	bool close_vm_conn = false;
+
+	mutex_enter(connections[conn_idx].bhm_rrmap);
+	session->count--;
+
+	if (session->count == 0) {
+		rrmap_remove(conn_idx, seq, true);
+		if (unlock_session)
+			mutex_exit(session->session_lock);
+		destroy_session(session);
+
+		if (conn_idx >= CONN_IDX_SVM)
+			close_vm_conn = true;
+	} else {
+		session->killed = true;
+		if (unlock_session)
+			mutex_exit(session->session_lock);
+	}
+
+	mutex_exit(connections[conn_idx].bhm_rrmap);
+
+	/* remove the VM conn counter of
+	 * this session:only for connected SVM
+	 */
+	if (close_vm_conn)
+		bh_do_close_vm(conn_idx);
+}
+
+static void session_kill(int conn_idx, struct bh_response_record *session,
+			 u64 seq, bool is_caller_svm_recv_thread)
+{
+	bool close_vm_conn = false;
+
+	mutex_enter(connections[conn_idx].bhm_rrmap);
+	session->killed = true;
+	if (session->count == 0) {
+
+		rrmap_remove(conn_idx, seq, true);
+		destroy_session(session);
+		if (conn_idx >= CONN_IDX_SVM)
+			close_vm_conn = true;
+	}
+	mutex_exit(connections[conn_idx].bhm_rrmap);
+
+	/* decrease the VM connection counter of this session:
+	 * only for connected SVM
+	 */
+	if (close_vm_conn) {
+
+		if (!is_caller_svm_recv_thread)
+			bh_do_close_vm(conn_idx);
+
+		else {
+			mutex_enter(connections[conn_idx].lock);
+			if (connections[conn_idx].conn_count != 1)
+				connections[conn_idx].conn_count--;
+
+			mutex_exit(connections[conn_idx].lock);
+		}
+	}
+}
+
+bool bhp_is_initialized(void)
+{
+	return (READ_ONCE(init_state) == INITED);
+}
+
+static char skip_buffer[DAL_MAX_BUFFER_SIZE] = {0};
+static int bh_transport_recv(unsigned int handle, void *buffer, size_t size)
+{
+	size_t got = 0;
+	size_t count = 0;
+	int status = 0;
+
+	if (handle > DAL_MEI_DEVICE_MAX)
+		return BPE_COMMS_ERROR;
+
+	while (size - count > 0) {
+
+		if (buffer) {
+			got = min_t(size_t, size - count, DAL_MAX_BUFFER_SIZE);
+			status = bhp_transport.recv(handle,
+					(unsigned char *) buffer + count,
+					(unsigned int *) &got);
+		} else {
+			got = min_t(size_t, DAL_MAX_BUFFER_SIZE, size - count);
+			status = bhp_transport.recv(handle,
+					skip_buffer, (unsigned int *) &got);
+		}
+
+		if (status != 0)
+			return BPE_COMMS_ERROR;
+
+		count += got;
+	}
+
+	return status == BH_SUCCESS && count == size ? BH_SUCCESS : status;
+}
+
+static int bh_transport_send(unsigned int handle, const void *buffer,
+			     unsigned int size, u64 seq)
+{
+	unsigned int written = 0;
+	unsigned int count = 0;
+	int status = 0;
+
+	if (handle > DAL_MEI_DEVICE_MAX)
+		return BPE_COMMS_ERROR;
+
+	while (size - count > 0) {
+
+		written = min_t(u32, size - count, DAL_MAX_BUFFER_SIZE);
+		status = bhp_transport.send(handle,
+				(unsigned char *)buffer + count, written, seq);
+		if (status != 0)
+			return BPE_COMMS_ERROR;
+
+		count += written;
+	}
+
+	return BH_SUCCESS;
+}
+
+int bh_do_open_vm(struct bh_sd_id sdid, int *conn_idx, int mode)
+{
+
+	if (!conn_idx)
+		return BPE_INVALID_PARAMS;
+
+	if (memcmp(&sdid, &isd_uuid, sizeof(struct bh_sd_id)) == 0) {
+		*conn_idx = CONN_IDX_IVM;
+		return BH_SUCCESS;
+	}
+
+	return BPE_INVALID_PARAMS;
+}
+
+int bh_do_close_vm(int conn_idx)
+{
+	int ret;
+	unsigned int count = 0;
+
+	/* only close connected SVM */
+	if (conn_idx <= CONN_IDX_IVM || connections[conn_idx].handle == 0)
+		return BH_SUCCESS;
+
+	mutex_enter(connections[conn_idx].lock);
+
+	count = (--connections[conn_idx].conn_count);
+
+	if (count == 0)
+		ret = bh_proxy_reset_svm(conn_idx);
+	else
+		ret = BH_SUCCESS;
+
+	mutex_exit(connections[conn_idx].lock);
+
+	return ret;
+}
+
+static int bh_send_message(int conn_idx, void *cmd, unsigned int clen,
+		const void *data, unsigned int dlen, u64 seq)
+{
+	int ret;
+	struct bh_response_record *rr = addr2record(conn_idx, seq);
+	struct bhp_command_header *h = NULL;
+
+	if (!rr)
+		return BPE_INTERNAL_ERROR;
+
+	mutex_enter(connections[conn_idx].bhm_send);
+
+	if (clen < sizeof(struct bhp_command_header) || !cmd || !rr)
+		return BPE_INVALID_PARAMS;
+
+	rr->buffer = NULL;
+	rr->length = 0;
+
+	memcpy(cmd, BHP_MSG_CMD_MAGIC, BHP_MSG_MAGIC_LENGTH);
+
+	h = (struct bhp_command_header *) cmd;
+	h->h.length = clen + dlen;
+	h->seq = seq;
+
+	ret = bh_transport_send(conn_idx, cmd, clen, seq);
+	if (ret == BH_SUCCESS && dlen > 0)
+		ret = bh_transport_send(conn_idx, (void *) data, dlen, seq);
+
+	if (ret != BH_SUCCESS)
+		rrmap_remove(conn_idx, seq, false);
+
+	mutex_exit(connections[conn_idx].bhm_send);
+
+	return ret;
+}
+
+static int bh_recv_message(int conn_idx, u64 *seq)
+{
+	int ret;
+	struct bhp_response_header headbuf;
+	struct bhp_response_header *head = &headbuf;
+	char *data = NULL;
+	unsigned int dlen = 0;
+	struct bh_response_record *rr = NULL;
+	int session_killed;
+
+	ret = bh_transport_recv(conn_idx,
+			(char *) head, sizeof(struct bhp_response_header));
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	/* check magic */
+	if (memcmp(BHP_MSG_RESPONSE_MAGIC,
+			head->h.magic, BHP_MSG_MAGIC_LENGTH) != 0)
+		return BPE_MESSAGE_ILLEGAL;
+
+	/* verify rr */
+	rr = rrmap_remove(conn_idx, head->seq, false);
+
+	if (head->h.length > sizeof(struct bhp_response_header)) {
+		dlen = head->h.length - sizeof(struct bhp_response_header);
+		data = kzalloc(dlen, GFP_KERNEL);
+		ret = bh_transport_recv(conn_idx, data, dlen);
+		if (ret == BH_SUCCESS && data == NULL)
+			ret = BPE_OUT_OF_MEMORY;
+	}
+
+	if (rr) {
+		rr->buffer = data;
+		rr->length = dlen;
+
+		if (ret == BH_SUCCESS)
+			rr->code = (int) head->code;
+		else
+			rr->code = ret;
+
+		if (head->addr)
+			rr->addr = head->addr;
+
+		session_killed = (rr->is_session &&
+				(rr->code == BHE_WD_TIMEOUT ||
+				rr->code == BHE_UNCAUGHT_EXCEPTION ||
+				rr->code == BHE_APPLET_CRASHED));
+
+		/* set killed flag before wake up send_wait thread */
+		if (session_killed) {
+			rr->killed = true;
+			session_kill(conn_idx, rr, head->seq, true);
+		}
+
+	} else {
+		kfree(data);
+	}
+
+	if (seq)
+		*seq = head->seq;
+
+	return ret;
+}
+
+static int bh_transport_init(const struct bhp_transport *context)
+{
+	memcpy(&bhp_transport, context, sizeof(struct bhp_transport));
+
+	if (!bhp_transport.send || !bhp_transport.recv)
+		return BPE_INVALID_PARAMS;
+
+	return BH_SUCCESS;
+}
+
+static void bh_do_connect(int conn_idx)
+{
+	struct bh_connection_item *conn = &connections[conn_idx];
+
+	conn->handle = 0;
+	conn->conn_count = 0;
+	INIT_LIST_HEAD(&conn->rr_map_list_header);
+	memset(&conn->sdid, 0x00, sizeof(struct bh_sd_id));
+}
+
+static int bh_do_disconnect(int conn_idx)
+{
+	struct list_head *pos, *tmp;
+	struct RR_MAP_INFO *rrmap_info;
+	struct bh_connection_item *conn;
+
+	conn = &connections[conn_idx];
+
+	conn->conn_count = 0;
+	conn->handle = 0;
+
+	list_for_each_safe(pos, tmp, &conn->rr_map_list_header) {
+		rrmap_info = list_entry(pos, struct RR_MAP_INFO, link);
+		if (rrmap_info) {
+			list_del(pos);
+			kfree(rrmap_info);
+		}
+	}
+
+	INIT_LIST_HEAD(&conn->rr_map_list_header);
+	memset(&conn->sdid, 0x00, sizeof(struct bh_sd_id));
+
+	return BH_SUCCESS;
+}
+
+static void bh_connections_init(void)
+{
+	int i;
+
+	for (i = CONN_IDX_START; i < MAX_CONNECTIONS; i++) {
+		connections[i].conn_count = 0;
+		connections[i].handle = 0;
+		INIT_LIST_HEAD(&connections[i].rr_map_list_header);
+	}
+
+	/* connect to predefined heci ports, except SVM */
+	for (i = CONN_IDX_START; i < CONN_IDX_SVM; i++)
+		bh_do_connect(i);
+}
+
+static void bh_connections_deinit(void)
+{
+	int i = 0;
+
+	for (i = CONN_IDX_START; i < MAX_CONNECTIONS; i++)
+		bh_do_disconnect(i);
+}
+
+static int bh_proxy_reset(int conn_idx)
+{
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bh_response_record rr;
+	int ret;
+
+	h->id = BHP_CMD_RESET;
+
+	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h),
+			NULL, 0, rrmap_add(conn_idx, &rr));
+
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	kfree(rr.buffer);
+
+	return ret;
+}
+
+static int bh_proxy_reset_svm(int conn_idx)
+{
+	if (conn_idx <= CONN_IDX_IVM || connections[conn_idx].handle == 0)
+		return BPE_INVALID_PARAMS;
+
+	return bh_proxy_reset(conn_idx);
+}
+
+/* get isd uuid from SDM in Firmware side. */
+static int bh_proxy_get_isd(void)
+{
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bh_response_record rr;
+	struct bhp_get_isd_response *resp;
+	int ret;
+
+	h->id = BHP_CMD_GET_ISD;
+
+	ret = bh_cmd_transfer(CONN_IDX_SDM, (char *) h, sizeof(*h),
+			NULL, 0, rrmap_add(CONN_IDX_SDM, &rr));
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	if (ret == BH_SUCCESS) {
+		if (rr.buffer &&
+		    rr.length == sizeof(struct bhp_get_isd_response)) {
+			resp = (struct bhp_get_isd_response *)rr.buffer;
+			isd_uuid = resp->sdid;
+		} else
+			ret = BPE_MESSAGE_ILLEGAL;
+	}
+
+	kfree(rr.buffer);
+	return ret;
+}
+
+#define MAX_RETRY_COUNT   (3)
+int bh_cmd_transfer(int conn_idx, void *cmd, unsigned int clen,
+		const void *data, unsigned int dlen, u64 seq)
+{
+	int ret;
+	u32 retry_count;
+	u64 seq_response = 0;
+
+	ret = bh_send_message(conn_idx, cmd, clen, data, dlen, seq);
+
+	if (ret == BH_SUCCESS) {
+		retry_count = 0;
+		do {
+			ret = bh_recv_message(conn_idx, &seq_response);
+			if (ret == BH_SUCCESS) {
+				pr_debug("bh_cmd_transfer(): recv message with seq=%llu\n",
+						seq_response);
+				if (seq_response == seq)
+					break;
+			}
+			pr_debug("bh_cmd_transfer(): recv message with seq=%llu != seq_response=%llu\n",
+					seq, seq_response);
+			retry_count++;
+		} while (retry_count < MAX_RETRY_COUNT);
+
+		if (retry_count == MAX_RETRY_COUNT) {
+			pr_debug("bh_cmd_transfer(): out of retry attempts\n");
+			ret = BPE_INTERNAL_ERROR;
+		}
+	}
+
+	return ret;
+}
+
+int bhp_init_internal(const struct bhp_transport *transport)
+{
+	int ret;
+
+	if (bhp_is_initialized())
+		return BPE_INITIALIZED_ALREADY;
+
+	transport = &bhp_transport;
+
+	/* step 1: init connections to each process */
+	ret = bh_transport_init(transport);
+	if (ret)
+		return ret;
+
+	bh_connections_init();
+
+	/* RESET flow removed to allow JHI and KDI to coexist */
+
+	/* step 3: get isd-uuid from SDM */
+	ret = bh_proxy_get_isd();
+	if (ret) {
+		bh_connections_deinit();
+		return ret;
+	}
+
+	/* this assignment is atomic operation */
+	WRITE_ONCE(init_state, INITED);
+
+	return BH_SUCCESS;
+}
+
+int bhp_deinit_internal(void)
+{
+	int ret;
+
+	if (!bhp_is_initialized())
+		return BPE_NOT_INIT;
+
+	mutex_enter(bhm_gInit);
+
+	if (bhp_is_initialized()) {
+		/* RESET flow removed to allow JHI and KDI to coexist */
+		bh_connections_deinit();
+		WRITE_ONCE(init_state, DEINITED);
+		ret = BH_SUCCESS;
+	} else {
+		ret = BPE_NOT_INIT;
+	}
+
+	mutex_exit(bhm_gInit);
+
+	return ret;
+}
diff --git a/drivers/misc/mei/dal/bhp_impl.h b/drivers/misc/mei/dal/bhp_impl.h
new file mode 100644
index 0000000..0fbf807
--- /dev/null
+++ b/drivers/misc/mei/dal/bhp_impl.h
@@ -0,0 +1,177 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _BHP_IMPL_H_
+#define _BHP_IMPL_H_
+
+#include "bh_shared_types.h"
+#include "bhp_exp.h"
+#include "bh_acp_exp.h"
+#include "bhp_heci.h"
+#include <linux/list.h>
+#include <linux/slab.h>
+
+/** struct bh_response_record
+ *   represents a beihai response record
+ *
+ * @code: the response code from firmware
+ * @length: length of the response buffer
+ * @buffer: the response buffer
+ * @addr: remote address in firmware
+ * @is_session: whether this record relates with session
+ * @killed: whether this session is killed or not,
+ * valid only if is_session is true
+ * @count: the count of users who are using this session,
+ * valid only for is_session is 1
+ */
+struct bh_response_record {
+	int code;
+	unsigned int length;
+	void *buffer;
+	u64 addr;
+	bool is_session;
+	bool killed;
+	unsigned int count;
+};
+
+/** struct bh_connection_item
+ *   represents a vm connection
+ *
+ * @handle: physical connection handle
+ * @rr_map_list_header: the list
+ * @conn_count: VM connection counter, only valid for VM
+ * @sdid: remote the sd id it serves, only valid for VM
+ */
+struct bh_connection_item {
+	unsigned int handle;
+	struct list_head rr_map_list_header;
+	unsigned int conn_count;
+	struct bh_sd_id sdid;
+};
+
+/* maximum concurrent activities on one session */
+#define MAX_SESSION_LIMIT 20
+
+/* heci command header buffer size in bytes */
+#define CMDBUF_SIZE 100
+
+/* TODO: review to avoid seq conflicts */
+# define MSG_SEQ_START_NUMBER (1UL << 32)
+
+/**
+ * enum bhp_connection_index -
+ *   represents a connection index to the different clients
+ *
+ * @CONN_IDX_IVM:
+ * @CONN_IDX_SDM:
+ * @CONN_IDX_LAUNCHER:
+ * @CONN_IDX_SVM:
+ */
+enum bhp_connection_index {
+	CONN_IDX_START = 0,
+	CONN_IDX_IVM = 0,
+	CONN_IDX_SDM = 1,
+	CONN_IDX_LAUNCHER = 2,
+	CONN_IDX_SVM = 3,
+	MAX_CONNECTIONS
+};
+
+/**
+ * enum bhp_state - represents the current state of bhp.
+ *
+ * @DEINITED:
+ * @INITED:
+ */
+enum bhp_state {
+	DEINITED = 0,
+	INITED = 1,
+};
+
+/* whether BHP is inited or not */
+bool bhp_is_initialized(void);
+
+/* Add a rr to rrmap and return a new seq number. */
+u64 rrmap_add(int conn_idx, struct bh_response_record *rr);
+
+/* session enter with session handle seq */
+struct bh_response_record *session_enter(int conn_idx, u64 seq,
+					 int lock_session);
+
+/* session exit */
+void session_exit(int conn_idx, struct bh_response_record *session,
+		  u64 seq, int unlock_session);
+
+/* session close */
+void session_close(int conn_idx, struct bh_response_record *session,
+		   u64 seq, int unlock_session);
+
+/* send one message through mei */
+int bh_cmd_transfer(int conn_idx, void *cmd, unsigned int clen,
+		    const void *data, unsigned int dlen, u64 seq);
+
+/* open vm connection for sdid and increase vm connection counter by 1 */
+int bh_do_open_vm(struct bh_sd_id sdid, int *conn_idx, int mode);
+
+/* decrease vm connection counter by 1 */
+int bh_do_close_vm(int conn_idx);
+
+#define mutex_enter(s) {}
+#define mutex_exit(s)  {}
+
+#endif /* _BHP_IMPL_H_ */
diff --git a/drivers/misc/mei/dal/bhp_impl_ta.c b/drivers/misc/mei/dal/bhp_impl_ta.c
new file mode 100644
index 0000000..be2a337
--- /dev/null
+++ b/drivers/misc/mei/dal/bhp_impl_ta.c
@@ -0,0 +1,647 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+/*
+ *
+ * @file  bhp_impl_ta.cpp
+ * @brief This file implements Beihai Host Proxy (BHP) module TA related API.
+ * @author
+ * @version
+ *
+ */
+
+#include <linux/string.h>
+#include "bh_shared_errcode.h"
+#include "bhp_impl.h"
+
+enum bhp_vm_mode {
+	BHP_OPEN_VM_QUERY_MODE = 0,
+	BHP_OPEN_VM_NORMAL_MODE = 1
+};
+
+static int char2hex(char c)
+{
+	if (c >= '0' && c <= '9')
+		return (c - '0');
+	else if (c >= 'a' && c <= 'f')
+		return (c - 'a' + 0xA);
+	else
+		return (c - 'A' + 0xA);
+}
+
+static int string_check1_uuid(const char *str)
+{
+	int i;
+
+	for (i = 0; i < BH_GUID_LENGTH * 2; i++, str++)
+		if (!((*str >= '0' && *str <= '9') ||
+				(*str >= 'a' && *str <= 'f') ||
+				(*str >= 'A' && *str <= 'F')))
+			return 0;
+
+	/* incorrect string length */
+	if (*str != 0)
+		return 0;
+
+	return 1;
+}
+
+static int string_check2_uuid(const char *str)
+{
+	int i;
+
+	for (i = 0; i < BH_GUID_LENGTH * 2; i++, str++) {
+
+		if (*str == '-' && (i == 8 || i == 12 || i == 16 || i == 20))
+			str++;
+
+		if (!((*str >= '0' && *str <= '9') ||
+				(*str >= 'a' && *str <= 'f') ||
+				(*str >= 'A' && *str <= 'F')))
+			return 0;
+	}
+
+	/* incorrect string length */
+	if (*str != 0)
+		return 0;
+
+	return 1;
+}
+
+static s32 string_to_uuid(const s8 *str, s8 *uuid)
+{
+	int i;
+
+	if (!string_check1_uuid(str) && !string_check2_uuid(str))
+		return 0;
+
+	for (i = 0; i < BH_GUID_LENGTH; i++, uuid++) {
+
+		if (*str == '-')
+			str++;
+
+		*uuid = (s8) char2hex(*str++);
+		*uuid <<= 4;
+		*uuid += (s8) char2hex(*str++);
+	}
+	return 1;
+}
+
+static void byte_order_swapi(int *i)
+{
+	int i_tmp = *i;
+	char *c = (char *) i;
+	char *c_tmp = (char *) &i_tmp;
+
+	c[0] = c_tmp[3];
+	c[1] = c_tmp[2];
+	c[2] = c_tmp[1];
+	c[3] = c_tmp[0];
+}
+
+/* try to session_enter for IVM, then SVM */
+static struct bh_response_record *
+session_enter_vm(u64 seq, int *conn_idx, int lock_session)
+{
+	struct bh_response_record *rr = NULL;
+
+	if (!conn_idx)
+		return NULL;
+
+	rr = session_enter(CONN_IDX_IVM, seq, lock_session);
+	if (rr)
+		*conn_idx = CONN_IDX_IVM;
+
+	return rr;
+}
+
+static int bh_proxy_get_sd_by_ta(struct bh_ta_id taid, struct bh_sd_id *sdid)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bhp_get_sd_by_ta_cmd *cmd =
+			(struct bhp_get_sd_by_ta_cmd *) h->cmd;
+	struct bh_response_record rr;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+	memset(&rr, 0x00, sizeof(rr));
+
+	if (!sdid)
+		return BPE_INVALID_PARAMS;
+
+	h->id = BHP_CMD_GET_SD_BY_TA;
+	cmd->taid = taid;
+
+	ret = bh_cmd_transfer(CONN_IDX_SDM, (char *) h,
+			sizeof(*h) + sizeof(*cmd), NULL, 0,
+			rrmap_add(CONN_IDX_SDM, &rr));
+
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	if (ret != BH_SUCCESS)
+		goto cleanup;
+
+	if (rr.buffer && rr.length ==
+			sizeof(struct bhp_get_sd_by_ta_response)) {
+		struct bhp_get_sd_by_ta_response *resp =
+				(struct bhp_get_sd_by_ta_response *) rr.buffer;
+		*sdid = resp->sdid;
+	} else
+		ret = BPE_MESSAGE_ILLEGAL;
+
+cleanup:
+	kfree(rr.buffer);
+
+	return ret;
+}
+
+static int bh_proxy_check_svl_ta_blocked_state(struct bh_ta_id taid)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bhp_check_svl_ta_blocked_state_cmd *cmd =
+			(struct bhp_check_svl_ta_blocked_state_cmd *) h->cmd;
+	struct bh_response_record rr;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+	memset(&rr, 0x00, sizeof(rr));
+
+	h->id = BHP_CMD_CHECK_SVL_TA_BLOCKED_STATE;
+	cmd->taid = taid;
+	memcpy(&cmd->taid, &taid,
+			sizeof(struct bhp_check_svl_ta_blocked_state_cmd));
+
+	ret = bh_cmd_transfer(CONN_IDX_SDM, (char *) h,
+			sizeof(*h) + sizeof(*cmd), NULL, 0,
+			rrmap_add(CONN_IDX_SDM, &rr));
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	kfree(rr.buffer);
+
+	return ret;
+}
+
+static int bh_proxy_listJTAPackages(int conn_idx, int *count,
+				    struct bh_ta_id **app_ids)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bh_response_record rr;
+	struct bhp_list_ta_packages_response *resp;
+	struct bh_ta_id *outbuf;
+	unsigned int i;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+	memset(&rr, 0x00, sizeof(rr));
+
+	if (!bhp_is_initialized())
+		return BPE_NOT_INIT;
+
+	if (!count || !app_ids)
+		return BPE_INVALID_PARAMS;
+
+	h->id = BHP_CMD_LIST_TA_PACKAGES;
+
+	ret = bh_cmd_transfer(conn_idx, (char *)h, sizeof(*h),
+			     NULL, 0, rrmap_add(conn_idx, &rr));
+
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	*app_ids = NULL;
+	*count = 0;
+
+	if (ret != BH_SUCCESS)
+		goto out;
+
+	if (!rr.buffer) {
+		ret = BPE_MESSAGE_ILLEGAL;
+		goto out;
+	}
+
+	resp = (struct bhp_list_ta_packages_response *)rr.buffer;
+	if (!resp->count)
+		goto out;
+
+	if (rr.length != sizeof(struct bh_ta_id) *
+			 resp->count +
+			sizeof(struct bhp_list_ta_packages_response)) {
+		ret = BPE_MESSAGE_ILLEGAL;
+		goto out;
+	}
+
+	outbuf = kcalloc(resp->count, sizeof(struct bh_ta_id), GFP_KERNEL);
+
+	if (!outbuf) {
+		ret = BPE_OUT_OF_MEMORY;
+		goto out;
+	}
+	for (i = 0; i < resp->count; i++)
+		outbuf[i] = resp->app_ids[i];
+
+	*app_ids = outbuf;
+	*count = resp->count;
+
+out:
+	kfree(rr.buffer);
+	return ret;
+}
+
+static int bh_proxy_download_javata(
+		int conn_idx,
+		struct bh_ta_id ta_id,
+		const char *ta_pkg,
+		unsigned int pkg_len)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bhp_download_javata_cmd *cmd =
+			(struct bhp_download_javata_cmd *) h->cmd;
+	struct bh_response_record rr;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+	memset(&rr, 0x00, sizeof(rr));
+
+	if (!ta_pkg || !pkg_len)
+		return BPE_INVALID_PARAMS;
+
+	h->id = BHP_CMD_DOWNLOAD_JAVATA;
+	cmd->appid = ta_id;
+
+	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
+			ta_pkg, pkg_len, rrmap_add(conn_idx, &rr));
+
+	if (ret == BH_SUCCESS)
+		ret = rr.code;
+
+	kfree(rr.buffer);
+
+	return ret;
+}
+
+static int bh_proxy_openjtasession(
+		int conn_idx,
+		struct bh_ta_id ta_id,
+		const char *init_buffer,
+		unsigned int init_len,
+		u64 *handle,
+		int *vm_conn_closed,
+		const char *ta_pkg,
+		unsigned int pkg_len)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *) cmdbuf;
+	struct bhp_open_jtasession_cmd *cmd =
+			(struct bhp_open_jtasession_cmd *) h->cmd;
+	struct bh_response_record *rr = NULL;
+	u64 seq;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+
+	if (!handle)
+		return BPE_INVALID_PARAMS;
+	if (!init_buffer && init_len > 0)
+		return BPE_INVALID_PARAMS;
+
+	rr = kzalloc(sizeof(struct bh_response_record), GFP_KERNEL);
+	if (!rr)
+		return BPE_OUT_OF_MEMORY;
+
+	memset(rr, 0, sizeof(struct bh_response_record));
+
+	rr->count = 1;
+	rr->is_session = true;
+	seq = rrmap_add(conn_idx, rr);
+
+	h->id = BHP_CMD_OPEN_JTASESSION;
+	cmd->appid = ta_id;
+
+	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
+			     (char *) init_buffer, init_len, seq);
+
+	if (ret == BH_SUCCESS)
+		ret = rr->code;
+
+	kfree(rr->buffer);
+	rr->buffer = NULL;
+
+	if (ret == BHE_PACKAGE_NOT_FOUND) {
+		/*
+		 * VM might delete the TA pkg when no live session.
+		 * Download the TA pkg and open session again
+		 */
+		ret = bh_proxy_download_javata(conn_idx, ta_id,
+					       ta_pkg, pkg_len);
+		if (ret == BH_SUCCESS) {
+			ret = bh_cmd_transfer(conn_idx, (char *)h,
+					sizeof(*h) + sizeof(*cmd),
+					(char *)init_buffer, init_len, seq);
+
+			if (ret == BH_SUCCESS)
+				ret = rr->code;
+
+			kfree(rr->buffer);
+			rr->buffer = NULL;
+		}
+	}
+
+	if (ret == BH_SUCCESS) {
+		*handle = (u64) seq;
+		session_exit(conn_idx, rr, seq, 0);
+	} else {
+		/*
+		 * bh_do_closeVM() will be called in following
+		 * session_close(), as rr->count is 1
+		 */
+		session_close(conn_idx, rr, seq, 0);
+		*vm_conn_closed = 1;
+	}
+
+	return ret;
+}
+
+int bhp_open_ta_session(u64 *session, const char *app_id,
+			const u8 *ta_pkg, size_t pkg_len,
+			const u8 *init_buffer, size_t init_len)
+{
+	int ret;
+	struct bh_ta_id ta_id;
+	int conn_idx = 0;
+	int vm_conn_closed = 0;
+	struct bh_sd_id sdid;
+	int ta_existed = 0;
+	int count = 0;
+	struct bh_ta_id *app_ids = NULL;
+	int i;
+
+	if (!app_id || !session)
+		return BPE_INVALID_PARAMS;
+
+	if (!ta_pkg || !pkg_len)
+		return BPE_INVALID_PARAMS;
+
+	if (!init_buffer && init_len != 0)
+		return BPE_INVALID_PARAMS;
+
+	if (!string_to_uuid(app_id, (char *) &ta_id))
+		return BPE_INVALID_PARAMS;
+
+	*session = 0;
+
+	/* 1.1: get the TA's sdid */
+	ret = bh_proxy_get_sd_by_ta(ta_id, &sdid);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	ret = bh_proxy_check_svl_ta_blocked_state(ta_id);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	/* 1.2: get corresponding vm conn_idx */
+	ret = bh_do_open_vm(sdid, &conn_idx, BHP_OPEN_VM_NORMAL_MODE);
+	if (ret != BH_SUCCESS)
+		return ret;
+
+	/* 2.1: check whether the ta pkg existed in VM or not */
+	ret = bh_proxy_listJTAPackages(conn_idx, &count, &app_ids);
+	if (ret == BH_SUCCESS) {
+		for (i = 0; i < count; i++) {
+			if (!memcmp(&ta_id, &app_ids[i], sizeof(struct bh_ta_id))) {
+				ta_existed = 1;
+				break;
+			}
+		}
+		kfree(app_ids);
+	}
+
+	/* 2.2: download ta pkg if not existed. */
+	if (!ta_existed) {
+		ret = bh_proxy_download_javata(conn_idx,
+					       ta_id, ta_pkg, pkg_len);
+		if (ret != BH_SUCCESS && ret != BHE_PACKAGE_EXIST)
+			goto cleanup;
+	}
+
+	/* 3: send opensession cmd to VM */
+	ret = bh_proxy_openjtasession(conn_idx, ta_id,
+				      init_buffer, init_len,
+				      session, &vm_conn_closed,
+				      ta_pkg, pkg_len);
+
+cleanup:
+	/*
+	 * closeVM only when this process failed and vm has not been closed
+	 * inside openjtasession, otherwise the session is created.
+	 */
+	if (ret != BH_SUCCESS && !vm_conn_closed)
+		bh_do_close_vm(conn_idx);
+
+	return ret;
+}
+
+int bhp_send_and_recv(const u64 handle, int command_id,
+		      const void *input, size_t length,
+		      void **output, size_t *output_length,
+		      int *response_code)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *)cmdbuf;
+	struct bhp_snr_cmd *cmd = (struct bhp_snr_cmd *)h->cmd;
+	u64 seq = (u64) handle;
+	struct bh_response_record *rr = NULL;
+	int conn_idx = 0;
+	unsigned int len;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+
+	if (!bhp_is_initialized())
+		return BPE_NOT_INIT;
+
+	if (!input && length != 0)
+		return BPE_INVALID_PARAMS;
+
+	if (!output_length)
+		return BPE_INVALID_PARAMS;
+
+	if (output)
+		*output = NULL;
+
+	rr = session_enter_vm(seq, &conn_idx, 1);
+	if (!rr)
+		return BPE_INVALID_PARAMS;
+
+	rr->buffer = NULL;
+	h->id = BHP_CMD_SENDANDRECV;
+
+	cmd->ta_session_id = rr->addr;
+	cmd->command = command_id;
+	cmd->outlen = *output_length;
+
+	ret = bh_cmd_transfer(conn_idx, (char *)h, sizeof(*h) + sizeof(*cmd),
+			      (char *) input, length, seq);
+
+	if (ret == BH_SUCCESS)
+		ret = rr->code;
+
+	if (rr->killed)
+		ret = BHE_UNCAUGHT_EXCEPTION;
+
+	if (ret == BH_SUCCESS) {
+		struct bhp_snr_response *resp = NULL;
+
+		if (rr->buffer &&
+		    rr->length >= sizeof(struct bhp_snr_response)) {
+			resp = (struct bhp_snr_response *)rr->buffer;
+			if (response_code) {
+				*response_code = resp->response;
+				byte_order_swapi(response_code);
+			}
+
+			len = rr->length - sizeof(struct bhp_snr_response);
+
+			if (len > 0) {
+				if (output && *output_length >= len) {
+					*output = kzalloc(len, GFP_KERNEL);
+					if (*output)
+						memcpy(*output,
+						       resp->buffer, len);
+					else
+						ret = BPE_OUT_OF_MEMORY;
+
+				} else
+					ret = BHE_APPLET_SMALL_BUFFER;
+
+			}
+
+			*output_length = len;
+		} else
+			ret = BPE_MESSAGE_TOO_SHORT;
+
+	} else if (ret == BHE_APPLET_SMALL_BUFFER && rr->buffer &&
+		   rr->length == sizeof(struct bhp_snr_bof_response)) {
+
+		struct bhp_snr_bof_response *resp =
+				(struct bhp_snr_bof_response *)rr->buffer;
+
+		if (response_code) {
+			*response_code = resp->response;
+			byte_order_swapi(response_code);
+		}
+
+		*output_length = resp->request_length;
+		byte_order_swapi((int *) output_length);
+	}
+
+	kfree(rr->buffer);
+	rr->buffer = NULL;
+
+	session_exit(conn_idx, rr, seq, 1);
+
+	return ret;
+}
+
+int bhp_close_ta_session(const u64 handle)
+{
+	int ret;
+	char cmdbuf[CMDBUF_SIZE];
+	struct bhp_command_header *h = (struct bhp_command_header *)cmdbuf;
+	struct bhp_close_jtasession_cmd *cmd =
+			(struct bhp_close_jtasession_cmd *)h->cmd;
+	struct bh_response_record *rr;
+	u64 seq = (u64)handle;
+	int conn_idx = 0;
+
+	memset(cmdbuf, 0x00, sizeof(cmdbuf));
+
+	rr = session_enter_vm(seq, &conn_idx, 1);
+	if (!rr)
+		return BPE_INVALID_PARAMS;
+
+	h->id = BHP_CMD_CLOSE_JTASESSION;
+	cmd->ta_session_id = rr->addr;
+
+	ret = bh_cmd_transfer(conn_idx, (char *) h, sizeof(*h) + sizeof(*cmd),
+			      NULL, 0, seq);
+
+	if (ret == BH_SUCCESS)
+		ret = rr->code;
+
+	if (rr->killed)
+		ret = BHE_UNCAUGHT_EXCEPTION;
+
+	/*
+	 * internal session exists, so we should not close the hmc session.
+	 * It means that host app should call this API at approciate time later.
+	 */
+	if (ret == BHE_IAC_EXIST_INTERNAL_SESSION)
+		session_exit(conn_idx, rr, seq, 1);
+	else
+		session_close(conn_idx, rr, seq, 1);
+
+	return ret;
+}
diff --git a/drivers/misc/mei/dal/dal_cdev.c b/drivers/misc/mei/dal/dal_cdev.c
new file mode 100644
index 0000000..2072911
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_cdev.c
@@ -0,0 +1,241 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/cdev.h>
+#include <linux/printk.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/notifier.h>
+#include <linux/dal.h>
+
+#include "dal_dev.h"
+#include "dal_cdev.h"
+
+/* KDI user space devices major and minor numbers */
+static dev_t dal_devt;
+
+static int dal_dev_open(struct inode *inode, struct file *fp)
+{
+	int ret;
+	struct dal_device *ddev;
+
+	ddev = container_of(inode->i_cdev, struct dal_device, cdev);
+	if (!ddev)
+		return -ENODEV;
+
+	/* single open */
+	if (test_and_set_bit(DAL_DEV_OPENED, &ddev->status))
+		return -EBUSY;
+
+	ret = dal_dc_setup(ddev, DAL_INTF_USER_SPACE);
+	if (ret)
+		goto err;
+
+	fp->private_data = ddev->clients[DAL_INTF_USER_SPACE];
+
+	return nonseekable_open(inode, fp);
+
+err:
+	clear_bit(DAL_DEV_OPENED, &ddev->status);
+	return ret;
+}
+
+static int dal_dev_release(struct inode *inode, struct file *fp)
+{
+	struct dal_client *dc = fp->private_data;
+	struct dal_device *ddev = dc->ddev;
+
+	if (mutex_lock_interruptible(&ddev->context_lock)) {
+		dev_err(&ddev->dev, "signal interrupted");
+		return -ERESTARTSYS;
+	}
+
+	dev_dbg(&ddev->dev, "free user space client");
+	ddev->clients[dc->intf] = NULL;
+
+	kfifo_free(&dc->read_queue);
+	kfree(dc);
+
+	mutex_unlock(&ddev->context_lock);
+
+	clear_bit(DAL_DEV_OPENED, &ddev->status);
+
+	return 0;
+}
+
+/* This is only for tmp read data to client */
+static struct dal_bh_msg bh_msg[DAL_MEI_DEVICE_MAX];
+#define BH_MSG_HEADER_LENGTH           32
+static ssize_t dal_dev_read(struct file *fp, char __user *buff,
+			    size_t count, loff_t *offp)
+{
+	struct dal_client *dc = fp->private_data;
+	struct dal_device *ddev = dc->ddev;
+	ssize_t ret;
+
+	ret = dal_read(dc);
+
+	if (ret != 0)
+		return ret;
+
+	if (kfifo_is_empty(&dc->read_queue))
+		return 0;
+
+	ret = kfifo_out(&dc->read_queue, &bh_msg[ddev->device_id],
+			sizeof(struct dal_bh_msg));
+	dev_dbg(&ddev->dev, "kfifo_out() ret = %zd\n", ret);
+
+	if (bh_msg[ddev->device_id].len > count) {
+		dev_dbg(&ddev->dev, "could not copy buffer. ");
+		dev_dbg(&ddev->dev, "src buffer size = %zd, dest buffer size = %zu\n",
+				bh_msg[ddev->device_id].len, count);
+		return -EFAULT;
+	}
+
+	if (copy_to_user(buff, bh_msg[ddev->device_id].msg,
+			 bh_msg[ddev->device_id].len)) {
+		dev_dbg(&ddev->dev, "copy_to_user() failed\n");
+		return -EFAULT;
+	}
+
+	return bh_msg[ddev->device_id].len;
+}
+
+static ssize_t dal_dev_write(struct file *fp, const char __user *buff,
+			     size_t count, loff_t *offp)
+{
+	struct dal_device *ddev;
+	struct dal_client *dc = fp->private_data;
+
+	ddev = dc->ddev;
+
+	if (count > DAL_MAX_BUFFER_SIZE) {
+		dev_err(&ddev->dev, "count is too big, count = %zu\n", count);
+		return -EMSGSIZE;
+	}
+
+	if (count == 0)
+		return 0;
+
+	if (!buff)
+		return -EINVAL;
+
+	if (copy_from_user(dc->write_buffer, buff, count))
+		return -EFAULT;
+
+	return dal_write(dc, count, 0);
+}
+
+static const struct file_operations mei_dal_fops = {
+	.owner    = THIS_MODULE,
+	.open     = dal_dev_open,
+	.release  = dal_dev_release,
+	.read     = dal_dev_read,
+	.write    = dal_dev_write,
+	.llseek   = no_llseek,
+};
+
+void dal_dev_del(struct dal_device *ddev)
+{
+	cdev_del(&ddev->cdev);
+}
+
+void dal_dev_setup(struct dal_device *ddev)
+{
+	dev_t devno;
+
+	cdev_init(&ddev->cdev, &mei_dal_fops);
+	devno = MKDEV(MAJOR(dal_devt), ddev->device_id);
+	ddev->cdev.owner = THIS_MODULE;
+	ddev->dev.devt = devno;
+	ddev->cdev.kobj.parent = &ddev->dev.kobj;
+}
+
+int dal_dev_add(struct dal_device *ddev)
+{
+	return cdev_add(&ddev->cdev, ddev->dev.devt, 1);
+}
+
+int __init dal_dev_init(void)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&dal_devt, 0, DAL_MEI_DEVICE_MAX, "dal");
+	if (ret < 0)
+		pr_err("failed allocate chrdev region = %d\n", ret);
+
+	return ret;
+}
+
+void dal_dev_exit(void)
+{
+	unregister_chrdev_region(dal_devt, DAL_MEI_DEVICE_MAX);
+}
diff --git a/drivers/misc/mei/dal/dal_cdev.h b/drivers/misc/mei/dal/dal_cdev.h
new file mode 100644
index 0000000..9179a95
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_cdev.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef __MEI_DAL_DEV_H__
+#define __MEI_DAL_DEV_H__
+void dal_dev_del(struct dal_device *ddev);
+void dal_dev_setup(struct dal_device *ddev);
+int dal_dev_add(struct dal_device *ddev);
+int __init dal_dev_init(void);
+void dal_dev_exit(void);
+#endif /* __MEI_DAL_DEV_H__ */
diff --git a/drivers/misc/mei/dal/dal_class.c b/drivers/misc/mei/dal/dal_class.c
new file mode 100644
index 0000000..a66fa42
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_class.c
@@ -0,0 +1,720 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/cdev.h>
+#include <linux/printk.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/notifier.h>
+#include <linux/dal.h>
+
+#include "bhp_impl.h"
+#include "dal_dev.h"
+#include "dal_cdev.h"
+
+/*
+ * this class contains the 3 mei_cl_device, ivm, sdm, rtm.
+ * it is initialized during dal_probe and is used by the kernel space kdi
+ * to send/recv data to/from mei.
+ *
+ * this class must be initialized before the kernel space kdi uses it.
+ */
+struct class *dal_class;
+
+/*
+ * 4 bytes array to identify BH headers
+ */
+static const u8 BH_MSG_SPLR_MAGIC[]  = {0x53, 0x50, 0x4c, 0x52};
+static const u8 BH_MSG_RESP_MAGIC[]  = {0xff, 0xa5, 0xaa, 0x55};
+static const u8 BH_MSG_CMD_MAGIC[]   = {0xff, 0xa3, 0xaa, 0x55};
+
+/* Check for response msg */
+static inline bool dal_msg_is_response(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_RESP_MAGIC, sizeof(BH_MSG_RESP_MAGIC));
+}
+
+/* Check for spoolar msg */
+static inline bool dal_msg_is_spooler(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_SPLR_MAGIC, sizeof(BH_MSG_SPLR_MAGIC));
+}
+
+/* Check for command msg */
+static inline bool dal_msg_is_cmd(const char *hdr)
+{
+	return !memcmp(hdr, BH_MSG_CMD_MAGIC, sizeof(BH_MSG_CMD_MAGIC));
+}
+
+/* comperator for cl devices */
+static int dal_dev_match(struct device *dev, const void *data)
+{
+	struct dal_device *ddev;
+	const enum dal_dev_type *device_id =
+			(enum dal_dev_type *)data;
+
+	ddev = container_of(dev, struct dal_device, dev);
+
+	return ddev->device_id == *device_id;
+}
+
+/* find device in dal_class object */
+struct device *dal_find_dev(enum dal_dev_type device_id)
+{
+	return class_find_device(dal_class, NULL, &device_id, dal_dev_match);
+}
+
+/* prints client data */
+void dal_dc_print(struct device *dev, struct dal_client *dc)
+{
+	if (!dc) {
+		dev_dbg(dev, "dc is null\n");
+		return;
+	}
+
+	dev_dbg(dev, "client data:\n"
+		     "is_user_space_client = %d\n"
+		     "read_buffer_size = %zu\n"
+		     "expected_msg_size_from_fw = %d\n"
+		     "expected_msg_size_to_fw = %d\n"
+		     "bytes_rcvd_from_fw = %d\n"
+		     "bytes_sent_to_fw = %d\n"
+		     "bytes_sent_to_host = %d\n",
+		dc->intf,
+		dc->read_buffer_size,
+		dc->expected_msg_size_from_fw,
+		dc->expected_msg_size_to_fw,
+		dc->bytes_rcvd_from_fw,
+		dc->bytes_sent_to_fw,
+		dc->bytes_sent_to_host);
+}
+
+/* wait until we can write to MEI,
+ * on success will return with the mutex locked
+ */
+static int dal_wait_for_write(struct dal_device *ddev, struct dal_client *dc)
+{
+	/*
+	 * wait until current write client is null OR
+	 * we are the current writer
+	 */
+	if (wait_event_interruptible(ddev->wq,
+				     !ddev->current_write_client ||
+				     ddev->current_write_client == dc ||
+				     ddev->is_device_removed)) {
+		dev_err(&ddev->dev, "wait_for_write(): signal interrupted\n");
+		return -ERESTARTSYS;
+	}
+
+	/* if the device was removed indicate that to the caller */
+	if (ddev->is_device_removed) {
+		dev_dbg(&ddev->dev, "wait_for_write(): woke up, device was removed\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/* Write BH msg via MEI*/
+ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq)
+{
+	struct dal_device *ddev = dc->ddev;
+	struct bhp_command_header *header;
+	struct device *dev;
+	ssize_t wr;
+	ssize_t ret;
+	int status; /* debug */
+	enum dal_intf intf = dc->intf;
+	struct dal_client *curr_wc; /* debug */
+
+	dev = &ddev->dev;
+
+	dev_dbg(dev, "client interface %d", intf);
+	dal_dc_print(dev, dc);
+
+	/* lock for adding new client that want to write to fifo */
+	dev_dbg(dev, "before write_queue_lock - client type %d", intf);
+	mutex_lock(&ddev->write_queue_lock);
+
+	ddev->is_write_pending = true;
+
+	/* put dc in write queue*/
+	if (ddev->current_write_client != dc) {
+		if (kfifo_is_empty(&ddev->write_queue))
+			ddev->current_write_client = dc;
+
+		ret = kfifo_in(&ddev->write_queue, dc, sizeof(dc));
+		dev_dbg(dev, "kfifo_in returned %zu - client type %d",
+			ret, intf);
+		dev_dbg(dev, "kfifo_avail = %d",
+			kfifo_avail(&ddev->write_queue));
+		if (ret < sizeof(dc)) {
+			dev_dbg(dev, "queue is full probably a bug");
+
+			mutex_unlock(&ddev->write_queue_lock);
+			goto cleanup;
+		}
+	}
+
+	dev_dbg(dev, "dal_write_mutex_unlock - client type %d\n", intf);
+	dev_dbg(dev, "dal_write(): before wait_for_write - client type %d",
+			intf);
+
+	/* wait for current writer to finish his write session */
+	mutex_unlock(&ddev->write_queue_lock);
+	ret = dal_wait_for_write(ddev, dc);
+	if (ret < 0) {
+		ddev->is_write_pending = false;
+		goto cleanup;
+	}
+
+	dev_dbg(dev, "before mei_cldev_send - client type %d", intf);
+	print_hex_dump_bytes("Buffer to send:",
+			DUMP_PREFIX_NONE, dc->write_buffer, count);
+
+	/* send msg via MEI */
+	wr = mei_cldev_send(ddev->cldev, dc->write_buffer, count);
+	if (wr != count) {
+		/* TODO: check if dev_err is debug only */
+		dev_err(dev, "mei_cl_send() failed, write_bytes != count (%zd != %zu)\n",
+			wr, count);
+		ret = -EFAULT;
+		ddev->is_write_pending = false;
+		goto cleanup;
+	}
+
+	dev_dbg(dev, "wrote %zu bytes to fw - client type %d", wr, intf);
+
+	/* lock to prevent write to MEI while reading from MEI */
+	/* TODO: check if this lock is needed */
+	mutex_lock(&ddev->context_lock);
+
+	/* update client byte sent */
+	dc->bytes_sent_to_fw += count;
+
+	/* get msg header */
+	header = (struct bhp_command_header *)dc->write_buffer;
+
+	/*
+	 * if this the spooler open session then don't do anything else,
+	 * as the response from the FW is async and may never occur
+	 */
+	/* TODO: we can remove this check and look only on the size */
+	if (dal_msg_is_spooler(dc->write_buffer)) {
+		ret = wr;
+		ddev->is_write_pending = false;
+		dev_dbg(dev, "SPOOLER msg command id = %d",
+				header->id);
+		goto cleanup;
+	}
+
+	/* header msg is being sent,
+	 * this is the first fragment of the message
+	 */
+	if (dal_msg_is_cmd(dc->write_buffer)) {
+		dc->expected_msg_size_to_fw = header->h.length;
+		dev_dbg(dev, "This is first fragment - client type %d",
+				intf);
+		dev_dbg(dev, "command id = %d", header->id);
+
+		/* if there's extra data, mark it */
+		if (dc->expected_msg_size_to_fw <= count)
+			ddev->is_write_pending = false;
+
+		dc->bytes_sent_to_fw = count;
+	}
+
+	/* another fragment which is not the last */
+	else if (dc->bytes_sent_to_fw != dc->expected_msg_size_to_fw) {
+		ddev->is_write_pending = true;
+		dev_dbg(dev, "expecting to write more data to FW - client type %d",
+				intf);
+	} else {
+		/* this is the last fragment */
+		ddev->is_write_pending = false;
+	}
+
+	/* update client on latest msg seq number*/
+	ddev->current_write_client->seq = seq;
+	dev_dbg(dev, "current_write_client seq = %llu",
+		ddev->current_write_client->seq);
+
+	ret = wr;
+
+cleanup:
+	if (!ddev->is_write_pending) {
+		dev_dbg(&ddev->dev, "removing CURRENT_WRITER\n");
+		/* init current to NULL */
+		ddev->current_write_client = NULL;
+		/* remove current dc from the queue */
+		status = kfifo_out(&ddev->write_queue, &curr_wc, sizeof(dc));
+		dev_dbg(&ddev->dev, "kfifo_out returned %d\n", status);
+
+		/* set new dal client as current,
+		 * if fifo empty current writer wont change
+		 */
+		status = kfifo_out_peek(&ddev->write_queue,
+					&ddev->current_write_client,
+					sizeof(dc));
+		dev_dbg(&ddev->dev, "kfifo_out_peek returned %d\n", status);
+
+		wake_up_interruptible(&ddev->wq);
+	}
+
+	mutex_unlock(&ddev->context_lock);
+
+	return ret;
+}
+
+/*
+ * blocking function, it waits until the caller (dc)
+ * will have data on his read_queue
+ */
+ssize_t dal_read(struct dal_client *dc)
+{
+	struct dal_device *ddev = dc->ddev;
+	struct device *dev = &ddev->dev;
+
+	dal_dc_print(dev, dc);
+
+	dev_dbg(dev, "before wait_for_data_to_read() - client type %d kfifo status %d",
+		dc->intf, kfifo_is_empty(&dc->read_queue));
+
+	/* wait until there is data in the read_queue */
+	wait_event_interruptible(ddev->wq, !kfifo_is_empty(&dc->read_queue) ||
+				 ddev->is_device_removed);
+
+	dev_dbg(dev, "after wait_for_data_to_read() - client type %d",
+		dc->intf);
+
+	/* FIXME: use reference counter */
+	if (ddev->is_device_removed) {
+		dev_dbg(&ddev->cldev->dev, "woke up, device was removed\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*
+ * update all relevant client state variables according to the
+ * msg received header or payload - this function called from only
+ * 'dal_recv_cb' which is under lock.
+ */
+static void update_client_read_state(struct dal_client *dc,
+				     struct mei_cl_device *cldev,
+				     int bytes_read)
+{
+	struct transport_msg_header *header =
+			(struct transport_msg_header *)dc->ddev->bh_fw_msg.msg;
+
+	/* check BH msg magic, if it exists this is the header */
+	if (dal_msg_is_response(dc->ddev->bh_fw_msg.msg)) {
+		dc->expected_msg_size_from_fw = header->length;
+		dev_dbg(&cldev->dev, "update_client_read_state():");
+		dev_dbg(&cldev->dev, "expected_msg_size_from_fw = %d bytes read = %d",
+			dc->expected_msg_size_from_fw, bytes_read);
+
+		/* clear data from the past. */
+		dc->bytes_sent_to_host = 0;
+		dc->bytes_rcvd_from_fw = 0;
+	}
+
+	/* update number of bytes rcvd */
+	dc->bytes_rcvd_from_fw += bytes_read;
+	dc->read_buffer_size += bytes_read;
+}
+
+/*
+ * get interface (user space OR kernel space) to send the received msg
+ */
+static enum dal_intf get_client_by_squence_number(struct dal_device *ddev)
+{
+	struct bhp_response_header *head;
+
+	if (!ddev->clients[DAL_INTF_KERNEL_SPACE])
+		return DAL_INTF_USER_SPACE;
+
+	head = (struct bhp_response_header *)ddev->bh_fw_msg.msg;
+
+	dev_dbg(&ddev->dev, "msg seq = %llu", head->seq);
+
+	if (head->seq == ddev->clients[DAL_INTF_KERNEL_SPACE]->seq)
+		return DAL_INTF_KERNEL_SPACE;
+
+	return DAL_INTF_USER_SPACE;
+}
+
+static void dal_recv_cb(struct mei_cl_device *cldev, u32 events, void *context)
+{
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	enum dal_intf intf;
+	ssize_t len;
+	ssize_t ret;
+	bool is_unexpected_msg = false;
+
+	if (!(events & BIT(MEI_CL_EVENT_RX)))
+		return;
+
+	ddev = mei_cldev_get_drvdata(cldev);
+
+	/*
+	 * read the msg from MEI
+	 */
+	len = mei_cldev_recv(cldev, ddev->bh_fw_msg.msg, DAL_MAX_BUFFER_SIZE);
+	if (len < 0) {
+		dev_err(&cldev->dev, "recv failed %zd\n", len);
+		return;
+	}
+
+	/*
+	 * lock to prevent read from MEI while writing to MEI and to
+	 * deal with just one msg at the same time
+	 */
+	mutex_lock(&ddev->context_lock);
+
+	/* save msg len */
+	ddev->bh_fw_msg.len = len;
+
+	/*
+	 * set to where the msg should sent.
+	 *
+	 * Do not change the order of this ifs
+	 */
+	if (dal_msg_is_response(ddev->bh_fw_msg.msg)) {
+		intf = get_client_by_squence_number(ddev);
+		dev_dbg(&ddev->dev, "recv_cb(): Client set by sequence number");
+		dc = ddev->clients[intf];
+	} else if (dal_msg_is_spooler(ddev->bh_fw_msg.msg)) {
+		intf = DAL_INTF_USER_SPACE;
+		dev_dbg(&ddev->dev, "recv_cb(): EVENT msg received");
+		dc = ddev->clients[intf];
+	} else if (!ddev->current_read_client) {
+		intf = DAL_INTF_USER_SPACE;
+		dev_dbg(&ddev->dev, "recv_cb(): EXTRA msg received - curr == NULL");
+		dc = ddev->clients[intf];
+		is_unexpected_msg = true;
+	} else {
+		dc = ddev->current_read_client;
+		dev_dbg(&ddev->dev, "recv_cb(): FRAGMENT msg received - curr != NULL");
+	}
+
+	if (!dc) {/* TODO: fix me - why device removed */
+		dev_dbg(&ddev->dev, "recv_cb(): dc is null");
+		goto out;
+	}
+
+	/* save the current read client */
+	ddev->current_read_client = dc;
+	dev_dbg(&cldev->dev, "read client type %d data from mei client seq =  %llu ",
+		dc->intf, dc->seq);
+
+	/*
+	 * save new msg in queue,
+	 * if the queue is full all new messages will be thrown
+	 */
+	ret = kfifo_in(&dc->read_queue, &ddev->bh_fw_msg,
+		       sizeof(struct dal_bh_msg));
+	if (ret < sizeof(struct dal_bh_msg))
+		dev_dbg(&ddev->dev, "queue is full - MSG THROWN");
+
+	update_client_read_state(dc, cldev, len);
+
+	/*
+	 * To clear current client we check if the whole msg received
+	 * for the current client
+	 */
+	if (is_unexpected_msg ||
+	    (dc->bytes_rcvd_from_fw == dc->expected_msg_size_from_fw)) {
+		dev_dbg(&ddev->dev, "recv_cb(): setting CURRENT_READER to NULL\n");
+		ddev->current_read_client = NULL;
+	}
+	/* wake up all clients waiting for read or write */
+	wake_up_interruptible(&ddev->wq);
+
+out:
+	mutex_unlock(&ddev->context_lock);
+	dev_dbg(&cldev->dev, "recv_cb(): unlock\n");
+}
+
+int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf)
+{
+	int ret;
+	struct dal_client *dc;
+	size_t readq_sz = DAL_MAX_BUFFER_PER_CLIENT * sizeof(struct dal_bh_msg);
+
+	if (ddev->clients[intf]) {
+		dev_err(&ddev->dev, "client already set\n");
+		return -EINVAL;
+	}
+
+	dc = kzalloc(sizeof(*dc), GFP_KERNEL);
+	if (!dc)
+		return  -ENOMEM;
+
+	ret = kfifo_alloc(&dc->read_queue, readq_sz, GFP_KERNEL);
+	if (ret) {
+		kfree(dc);
+		return ret;
+	}
+
+	dc->intf = intf;
+	dc->ddev = ddev;
+	ddev->clients[intf] = dc;
+	return 0;
+}
+
+/* FIXME: should be under lock ? */
+static int dal_remove(struct mei_cl_device *cldev)
+{
+	struct dal_device *ddev = mei_cldev_get_drvdata(cldev);
+
+	dal_dev_del(ddev);
+
+	ddev->is_device_removed = true;
+	/* make sure the above is set */
+	smp_mb();
+	/* wakeup write waiters so we can unload */
+	if (waitqueue_active(&ddev->wq))
+		wake_up_interruptible(&ddev->wq);
+
+	kfifo_free(&ddev->write_queue);
+
+	device_del(&ddev->dev);
+
+	mei_cldev_set_drvdata(cldev, NULL);
+
+	mei_cldev_disable(cldev);
+
+	put_device(&ddev->dev);
+
+	return 0;
+}
+
+static void dal_class_release(struct device *dev)
+{
+	struct dal_device *ddev = to_dal_device(dev);
+
+	kfree(ddev);
+}
+
+static int dal_probe(struct mei_cl_device *cldev,
+		     const struct mei_cl_device_id *id)
+{
+	struct dal_device *ddev;
+	int ret;
+
+	ddev = kzalloc(sizeof(*ddev), GFP_KERNEL);
+	if (!ddev)
+		return -ENOMEM;
+
+	/* initialize the mutex and wait queue */
+	mutex_init(&ddev->context_lock);
+	mutex_init(&ddev->write_queue_lock);
+	init_waitqueue_head(&ddev->wq);
+	ddev->cldev = cldev;
+	ddev->device_id = id->driver_info;
+
+	ret = mei_cldev_enable(cldev);
+	if (ret < 0) {
+		dev_err(&cldev->dev, "mei_cl_enable_device() failed with ret = %d\n",
+			ret);
+		goto free_context;
+	}
+
+	ret = kfifo_alloc(&ddev->write_queue,
+			  sizeof(struct dal_client *) * DAL_CLIENTS_PER_DEVICE,
+			  GFP_KERNEL);
+	if (ret != 0)
+		goto free_context;
+
+	/* save pointer to the context in the device */
+	mei_cldev_set_drvdata(cldev, ddev);
+
+	/* register to mei bus callbacks */
+	ret = mei_cldev_register_event_cb(cldev, BIT(MEI_CL_EVENT_RX),
+					  dal_recv_cb, NULL);
+	if (ret) {
+		dev_err(&cldev->dev, "mei_cl_register_event_cb() failed ret = %d\n",
+			ret);
+		goto disable_cldev;
+	}
+
+	ddev->dev.parent = &cldev->dev;
+	ddev->dev.class  = dal_class;
+	ddev->dev.release = dal_class_release;
+	dev_set_name(&ddev->dev, "dal%d", ddev->device_id);
+
+	dal_dev_setup(ddev);
+
+	ret = device_register(&ddev->dev);
+	if (ret) {
+		dev_err(&cldev->dev, "unable to register device\n");
+		goto err_dev_create;
+	}
+
+	ret = dal_dev_add(ddev);
+	if (ret)
+		goto err_dev_create;
+
+	return 0;
+
+err_dev_create:
+	dal_dev_del(ddev);
+
+disable_cldev:
+	mei_cldev_disable(cldev);
+	dal_remove(cldev);
+	kfifo_free(&ddev->write_queue);
+
+free_context:
+	kfree(ddev);
+
+	return ret;
+}
+
+/* DAL FW HECI client GUIDs */
+#define IVM_UUID UUID_LE(0x3c4852d6, 0xd47b, 0x4f46, \
+			 0xb0, 0x5e, 0xb5, 0xed, 0xc1, 0xaa, 0x44, 0x0e)
+#define SDM_UUID UUID_LE(0xdba4d603, 0xd7ed, 0x4931, \
+			 0x88, 0x23, 0x17, 0xad, 0x58, 0x57, 0x05, 0xd5)
+#define RTM_UUID UUID_LE(0x5565a099, 0x7fe2, 0x45c1, \
+			 0xa2, 0x2b, 0xd7, 0xe9, 0xdf, 0xea, 0x9a, 0x2e)
+
+#define DAL_DEV_ID(__uuid, __device_type) \
+	{.uuid = __uuid,                  \
+	 .version = MEI_CL_VERSION_ANY,   \
+	 .driver_info = __device_type}
+
+static const struct mei_cl_device_id dal_device_id[] = {
+	DAL_DEV_ID(IVM_UUID, DAL_MEI_DEVICE_IVM),
+	DAL_DEV_ID(SDM_UUID, DAL_MEI_DEVICE_SDM),
+	DAL_DEV_ID(RTM_UUID, DAL_MEI_DEVICE_RTM),
+	/* required last entry */
+	{ }
+};
+MODULE_DEVICE_TABLE(mei, dal_device_id);
+
+static struct mei_cl_driver dal_driver = {
+	.id_table = dal_device_id,
+	.name = KBUILD_MODNAME,
+
+	.probe  = dal_probe,
+	.remove = dal_remove,
+};
+
+static void __exit mei_dal_exit(void)
+{
+	pr_info("Kernel DAL Interface shutdown\n");
+
+	mei_cldev_driver_unregister(&dal_driver);
+
+	dal_dev_exit();
+
+	class_destroy(dal_class);
+}
+
+static int __init mei_dal_init(void)
+{
+	int ret;
+
+	dal_class = class_create(THIS_MODULE, "dal");
+	if (IS_ERR(dal_class)) {
+		pr_err("couldn't create class\n");
+		return PTR_ERR(dal_class);
+	}
+
+	ret = dal_dev_init();
+	if (ret < 0)
+		goto err_class;
+
+	ret = mei_cldev_driver_register(&dal_driver);
+	if (ret < 0) {
+		pr_err("mei_cl_driver_register failed with status = %d\n", ret);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	dal_dev_exit();
+err_class:
+	class_destroy(dal_class);
+	return ret;
+}
+
+module_init(mei_dal_init);
+module_exit(mei_dal_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) MEI Dynamic Application Loader (DAL)");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/mei/dal/dal_dev.h b/drivers/misc/mei/dal/dal_dev.h
new file mode 100644
index 0000000..7f49abc
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_dev.h
@@ -0,0 +1,229 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#ifndef _DAL_KDI_H_
+#define _DAL_KDI_H_
+
+#include <linux/types.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/kfifo.h>
+
+#define DAL_MAX_BUFFER_SIZE            4096
+
+#define DAL_MAX_BUFFER_PER_CLIENT      10 /* TODO: arbitrary number */
+#define DAL_CLIENTS_PER_DEVICE         2
+
+/*
+ * this array contains  pointers to 3 mei_cl_device, ivm, sdm, rtm.
+ * it is initialized during dal_probe and is used by the kernel space kdi
+ * to send/recv data to/from mei.
+ *
+ * this array must be initialized before the kernel space kdi uses it.
+ */
+extern struct class *dal_class;
+
+/**
+ * enum intf_intf - represents dal interface type
+ *
+ * @DAL_INTF_KERNEL_SPACE:  kernel space interface
+ * @DAL_INTF_USER_SPACE:  user space /dev/interface
+ */
+enum dal_intf {
+	DAL_INTF_KERNEL_SPACE,
+	DAL_INTF_USER_SPACE,
+};
+
+/** enum dal_notify_action_type:
+ *   represents the actions dal_mei inform on
+ */
+enum dal_notify_action_type {
+	DAL_NOTIFY_ACTION_IVM_REGISTERED,
+	DAL_NOTIFY_ACTION_SDM_REGISTERED,
+	DAL_NOTIFY_ACTION_RTM_REGISTERED,
+
+	DAL_NOTIFY_ACTION_IVM_UNREGISTERED,
+	DAL_NOTIFY_ACTION_SDM_UNREGISTERED,
+	DAL_NOTIFY_ACTION_RTM_UNREGISTERED,
+
+	DAL_NOTIFY_ACTION_MAX
+};
+
+/** enum dal_dev_type:
+ *   represents the devices that are exposed to userspace
+ *
+ * @DAL_MEI_DEVICE_IVM: IVM - Intel/Issuer Virtual Machine
+ * @DAL_MEI_DEVICE_SDM: SDM - Security Domain Manager
+ * @DAL_MEI_DEVICE_RTM: RTM - Run Time Manager (Launcher)
+ * @DAL_MEI_DEVICE_SVM: SVM - Secondary Virtual Machine
+ */
+enum dal_dev_type {
+	DAL_MEI_DEVICE_IVM,
+	DAL_MEI_DEVICE_SDM,
+	DAL_MEI_DEVICE_RTM,
+
+	DAL_MEI_DEVICE_MAX
+};
+
+struct dal_client;
+
+/**
+ * struct dal_bh_msg: represent msg sent from the FW.
+ *
+ * @msg: message buffer
+ * @len: message length
+ */
+struct dal_bh_msg {
+	char msg[DAL_MAX_BUFFER_SIZE];
+	ssize_t  len;
+};
+
+/**
+ * struct dal_device: represents the context for a device,
+ *        each device has a context (i.e IVM, SDM, RTM)
+ *
+ * @cdev: the character device structure.
+ * @context_lock:  a lock for synchronizing access to sensitive
+ * variables/data structures
+ * @write_queue_lock: synchronizing access to write queue
+ * structures - for current client in write function
+ * @rd_wq: a wait queue, for synchronizing requests in a FIFO manner
+ * @clients: the clients on this device ( userspace or kernel ).
+ * @num_user_space_clients: ttrack the number of times the device file has
+ * been opened
+ * @bh_fw_msg: a struct represent msg kdi receive from the FW.
+ * @current_write_client: stores the current client being served,
+ * (needed since rcv is async, need to know who the received data belongs to)
+ * @cldev: the MEI CL device which corresponds to a single DAL FW HECI client
+ * @is_device_remove: a variable that signals that the device is removed
+ * and waiting threads on queue should wake up.
+ * @device_id: saves device type id.
+ */
+struct dal_device {
+	struct device dev;
+	struct cdev cdev;
+#define DAL_DEV_OPENED 0
+	unsigned long status;
+
+	struct mutex context_lock;
+	struct mutex write_queue_lock;
+	wait_queue_head_t wq;
+	struct kfifo write_queue;
+	struct dal_client *clients[DAL_CLIENTS_PER_DEVICE];
+	struct dal_bh_msg bh_fw_msg;
+	struct dal_client *current_write_client;
+	struct dal_client *current_read_client;
+
+	struct mei_cl_device *cldev;
+	bool is_write_pending;
+
+	bool is_device_removed;
+
+	int device_id;
+};
+
+#define to_dal_device(d) container_of(d, struct dal_device, dev)
+
+/**
+ * struct dal_client: represents the host client
+ *
+ * @is_user_space_client:  indicates whether this client is user
+ * space or kernel space
+ * @read_buffer: buffer containing data received from DAL FW for this client
+ * @write_buffer: buffer containing data to send to DAL FW
+ * @rcv_callback_queue: a wait queue for synchronizing mei rcv callback and
+ * read operations
+ * @is_buffer_busy: indicates whether buffer is busy or is it ok to copy
+ * data from mei.
+ * @read_buffer_size: the amount of data in read_buffer
+ * @expected_msg_size_from_fw: the expected msg size from FW
+ * @expected_msg_size_to_fw: the expected msg size that will be sent to FW
+ * @bytes_rcvd_from_fw: number of bytes that were received from FW
+ * @bytes_sent_to_fw: number of bytes that were sent to FW
+ * @bytes_sent_to_host: number of bytes that were sent to host
+ * @is_another_write_pending: indicates whether this client has another
+ * write pending - required to prevent kernel/user space sending
+ * interleaving writes
+ */
+struct dal_client {
+	struct dal_device *ddev;
+	struct kfifo read_queue;
+	char write_buffer[DAL_MAX_BUFFER_SIZE];
+	enum dal_intf intf;
+
+	size_t read_buffer_size;
+
+	u64 seq;
+	u32 expected_msg_size_from_fw;
+	u32 expected_msg_size_to_fw;
+	u32 bytes_rcvd_from_fw;
+	u32 bytes_sent_to_fw;
+	u32 bytes_sent_to_host;
+};
+
+ssize_t dal_write(struct dal_client *dc, size_t count, u64 seq);
+ssize_t dal_read(struct  dal_client *dc);
+
+void dal_dc_print(struct device *dev, struct dal_client *dc);
+
+struct device *dal_find_dev(enum dal_dev_type device_id);
+
+int dal_dc_setup(struct dal_device *ddev, enum dal_intf intf);
+
+#endif  /* _DAL_KDI_H_ */
diff --git a/drivers/misc/mei/dal/dal_kdi.c b/drivers/misc/mei/dal/dal_kdi.c
new file mode 100644
index 0000000..2219d2a
--- /dev/null
+++ b/drivers/misc/mei/dal/dal_kdi.c
@@ -0,0 +1,393 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/atomic.h>
+#include <linux/module.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mei.h>
+#include <linux/sched.h>
+#include <linux/dal.h>
+
+#include "bhp_exp.h"
+#include "bhp_impl.h"
+#include "dal_dev.h"
+
+static atomic_t kdi_ref_count = ATOMIC_INIT(0);
+static struct mutex kdi_lock;
+
+#define BH_MSG_MAGIC_LENGTH            4
+#define BH_MSG_SEQUENCE_OFFSET         8
+
+static bool kdi_check_handle(u64 handle)
+{
+	return (handle == (u64)dal_class);
+}
+
+static int kdi_create_session(u64 *handle, const char *jta_id,
+			      const u8 *buffer, size_t buffer_length,
+			      const u8 *init_param, size_t init_param_length)
+{
+	struct ac_ins_jta_pack_ext pack;
+	char *ta_pkg;
+	int ta_pkg_size;
+	int ret;
+
+	if (!jta_id || !buffer || !buffer_length || !handle)
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+
+	/* init_param are optional, but if they exists the length should be
+	 * positive and if param buffer is not exists the length must be 0
+	 */
+	if (!init_param && init_param_length != 0) {
+		pr_err("INVALID_PARAMS init_param %p init_param_length %zu",
+		       init_param, init_param_length);
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+	}
+
+	ret = acp_pload_ins_jta(buffer, buffer_length, &pack);
+
+	if (ret) {
+		pr_err("acp_pload_ins_jta() return %d", ret);
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+	}
+
+	ta_pkg = pack.ta_pack;
+	if (!ta_pkg)
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+
+	ta_pkg_size = ta_pkg - (char *)buffer;
+
+	if (ta_pkg_size < 0 || (unsigned int)ta_pkg_size > buffer_length)
+		return DAL_KDI_STATUS_INTERNAL_ERROR;
+
+	ta_pkg_size = buffer_length - ta_pkg_size;
+
+	return bhp_open_ta_session(handle, jta_id, ta_pkg,
+				   ta_pkg_size, init_param, init_param_length);
+}
+
+static bool kdi_is_mei_ready(void)
+{
+	struct device *dev;
+	int i;
+
+	/* TODO: don't use loop here there is
+	 * already an iterator  over class list
+	 */
+	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
+		dev = dal_find_dev(i);
+		if (!dev || !dev->parent)
+			return false;
+
+		put_device(dev);
+	}
+
+	return true;
+}
+
+static int kdi_create_kernel_clients(void)
+{
+	struct device *dev;
+	struct dal_device *ddev;
+	int i;
+	int ret;
+
+	/* FIXME: use an iterrator */
+	/* Check that all the device are init */
+	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
+		dev = dal_find_dev(i);
+		if (!dev || !dev->parent) {
+			pr_err("device=%d is NULL\n", i);
+			return -EFAULT;
+		}
+		ddev = to_dal_device(dev);
+		ret = dal_dc_setup(ddev, DAL_INTF_KERNEL_SPACE);
+		put_device(dev);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static bool kdi_is_init_done(void)
+{
+	return (atomic_read(&kdi_ref_count) >= 1);
+}
+
+/* FIMXE: not sure this is needed at all
+ * this will be destroyed using class release function
+ */
+
+static void kdi_destroy_kernel_clients(void)
+{
+	struct device *dev;
+	struct dal_device *ddev;
+	struct dal_client *dc;
+	int i;
+
+	/* use iterator */
+	for (i = 0; i < DAL_MEI_DEVICE_MAX; ++i) {
+		dev = dal_find_dev(i);
+		if (!dev || !dev->parent)
+			continue;
+		/* TODO: just call destroy kdic ...  */
+		ddev = to_dal_device(dev);
+		dev_dbg(&ddev->dev, "kdi_destroy_kernel_clients(): free kernel space client");
+		dc = ddev->clients[DAL_INTF_KERNEL_SPACE];
+		kfifo_free(&dc->read_queue);
+		kfree(dc);
+		ddev->clients[DAL_INTF_KERNEL_SPACE] = NULL;
+		put_device(dev);
+	}
+}
+
+int kdi_init(u32 flags, u64 *handle)
+{
+	int ret;
+
+	if (!handle)
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+
+	/* Check that all the device are ready */
+	if (!kdi_is_mei_ready()) {
+		pr_err("dal_init(): mei devices was not initialized\n");
+		ret = DAL_KDI_STATUS_NOT_READY;
+		*handle = DAL_KDI_INVALID_HANDLE;
+		goto end;
+	}
+
+	if (atomic_inc_return(&kdi_ref_count) == 1) {
+		mutex_init(&kdi_lock);
+		pr_debug("ref count == 1, performing init\n");
+		if (kdi_create_kernel_clients() < 0) {
+			kdi_destroy_kernel_clients();
+			atomic_dec(&kdi_ref_count);
+			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+			*handle = DAL_KDI_INVALID_HANDLE;
+			goto end;
+		}
+
+		ret = bhp_init_internal(NULL);
+		if (ret != BH_SUCCESS) {
+			pr_debug("BHP_Init failed with status = %d\n", ret);
+			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+			*handle = DAL_KDI_INVALID_HANDLE;
+		}
+	}
+
+	*handle = (u64)dal_class;
+	ret = DAL_KDI_SUCCESS;
+
+end:
+	return ret;
+}
+EXPORT_SYMBOL(kdi_init);
+
+int kdi_deinit(u64 handle)
+{
+	int ret;
+
+	/* TODO: add a kernel cleanup code to module deinit possible flow:
+	 * one kernel module invokes init and a different one invokes deinit
+	 */
+
+	/* check handle first */
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	if (atomic_dec_and_test(&kdi_ref_count)) {
+		pr_debug("ref count == 0, performing cleanup\n");
+		ret = bhp_deinit_internal();
+		if (ret != BH_SUCCESS) {
+			pr_debug("bhp_deinit_internal failed with status = %d\n",
+				 ret);
+			ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+		} else {
+			ret = DAL_KDI_SUCCESS;
+		}
+
+		mutex_destroy(&kdi_lock);
+		kdi_destroy_kernel_clients();
+	} else {
+		ret = DAL_KDI_SUCCESS;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(kdi_deinit);
+
+int dal_create_session(u64 handle,
+		       u64 *session_handle,
+		       const char *app_id,
+		       const u8 *acp_pkg,
+		       size_t acp_pkg_len,
+		       const u8 *init_param,
+		       size_t init_param_len)
+{
+	int ret;
+
+	if (!kdi_is_init_done())
+		return DAL_KDI_STATUS_NOT_INITIALIZED;
+
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	mutex_lock(&kdi_lock);
+
+	ret = kdi_create_session(session_handle, app_id,
+				 acp_pkg, acp_pkg_len,
+				 init_param, init_param_len);
+
+	if (ret != BH_SUCCESS) {
+		pr_err("kdi_create_session failed with status = %d\n", ret);
+		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+	} else {
+		ret = DAL_KDI_SUCCESS;
+	}
+
+	mutex_unlock(&kdi_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dal_create_session);
+
+int dal_send_and_receive(u64 handle,
+			 u64 session_handle,
+			 int command_id,
+			 const u8 *input,
+			 size_t input_len,
+			 u8 **output,
+			 size_t *output_len,
+			 int *response_code)
+{
+	int ret;
+
+	if (!kdi_is_init_done())
+		return DAL_KDI_STATUS_NOT_INITIALIZED;
+
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	mutex_lock(&kdi_lock);
+
+	ret = bhp_send_and_recv(session_handle, command_id, input, input_len,
+			(void **)output, output_len, response_code);
+
+	if (ret != BH_SUCCESS) {
+		pr_err("bhp_send_and_recv failed with status = %d\n", ret);
+		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+	} else {
+		ret = DAL_KDI_SUCCESS;
+	}
+
+	mutex_unlock(&kdi_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dal_send_and_receive);
+
+int dal_close_session(u64 handle, u64 session_handle)
+{
+	int ret;
+
+	if (!kdi_is_init_done())
+		return DAL_KDI_STATUS_NOT_INITIALIZED;
+
+	if (!kdi_check_handle(handle))
+		return DAL_KDI_STATUS_INVALID_HANDLE;
+
+	mutex_lock(&kdi_lock);
+
+	ret = bhp_close_ta_session(session_handle);
+
+	if (ret != BH_SUCCESS) {
+		pr_err("hp_close_ta_session failed with status = %d\n", ret);
+		ret = DAL_KDI_STATUS_INTERNAL_ERROR;
+	} else {
+		ret = DAL_KDI_SUCCESS;
+	}
+	mutex_unlock(&kdi_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dal_close_session);
+
+#define KDI_MAJOR_VER         "1"
+#define KDI_MINOR_VER         "0"
+#define KDI_HOTFIX_VER        "0"
+
+#define KDI_VERSION KDI_MAJOR_VER "." \
+		    KDI_MINOR_VER "." \
+		    KDI_HOTFIX_VER
+
+int dal_get_version_info(struct dal_version_info *version_info)
+{
+	if (!version_info)
+		return DAL_KDI_STATUS_INVALID_PARAMS;
+
+	memset(version_info, 0x00, sizeof(*version_info));
+	snprintf(version_info->version, DAL_VERSION_LEN, "%s", KDI_VERSION);
+
+	return 0;
+}
+EXPORT_SYMBOL(dal_get_version_info);
diff --git a/include/linux/dal.h b/include/linux/dal.h
new file mode 100644
index 0000000..beb5497
--- /dev/null
+++ b/include/linux/dal.h
@@ -0,0 +1,173 @@
+/******************************************************************************
+ * Intel mei_dal Linux driver
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-mei@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _DAL_H_
+#define _DAL_H_
+
+#include <linux/types.h>
+
+#define DAL_VERSION_LEN             32
+
+/**
+ * struct dal_version_info -
+ *
+ * @version: current dal version.
+ * @reserved: reserved bytes for future use.
+ */
+struct dal_version_info {
+	char version[DAL_VERSION_LEN];
+	u32 reserved[4];
+};
+
+#define DAL_KDI_SUCCESS							0x0
+#define DAL_KDI_STATUS_INTERNAL_ERROR           0xA00
+#define DAL_KDI_STATUS_INVALID_PARAMS           0xA01
+#define DAL_KDI_STATUS_INVALID_HANDLE           0xA02
+#define DAL_KDI_STATUS_ILLEGAL_USAGE            0xA03
+#define DAL_KDI_STATUS_NOT_INITIALIZED          0xA04
+#define DAL_KDI_STATUS_NO_FW_CONNECTION         0xA05
+#define DAL_KDI_STATUS_OUT_OF_MEMORY            0xA06
+#define DAL_KDI_STATUS_BUFFER_TOO_SMALL         0xA07
+#define DAL_KDI_STATUS_OUT_OF_RESOURCE          0xA08
+#define DAL_KDI_STATUS_NOT_READY                0xA09
+
+#define DAL_KDI_INVALID_HANDLE    0
+
+#define KDI_INIT_FLAGS_NONE       0
+
+/**
+ * kdi_init -  Init KDI kernel interface.
+ * NOTE: Before calling kdi init we assuming that user space api
+ *       called.
+ *
+ * @falgs:    flag for init flow
+ * @handle:   pointer to get handle
+ *
+ * Return: 0 for success < 0 otherwise
+ */
+int kdi_init(u32 flags, u64 *handle);
+
+/**
+ * kdi_deinit -  deinit KDI kernel interface.
+ *
+ * @handle:   kdi handle
+ *
+ * Return: 0 for success < 0 otherwise
+ */
+int kdi_deinit(u64 handle);
+
+/**
+ * dal_get_version_info - return DAL version.
+ *
+ * @version_info:   pointer to KDI version struct
+ *
+ * Return: 0 for success fail otherwise
+ */
+int dal_get_version_info(struct dal_version_info *version_info);
+
+/**
+ * dal_create_session - will open session to an applet
+ *
+ * @handle:            kdi handle
+ * @session_handle:    pointer to get the session handle
+ * @app_id:            applet id
+ * @acp_pkg:           applet acp data
+ * @acp_pkg_len:       applet acp data size
+ * @init_param:		   applet init param
+ * @init_param_len:    applet init param size
+ *
+ * Return: 0 for success fail otherwise
+ */
+int dal_create_session(u64 handle, u64 *session_handle,
+		       const char *app_id, const u8 *acp_pkg,
+		       size_t acp_pkg_len, const u8 *init_param,
+		       size_t init_param_len);
+
+/**
+ * dal_send_and_receive - send and receive data to/from the applet
+ *
+ * @handle:            kdi handle
+ * @session_handle:    session handle
+ * @command_id:        command id
+ * @input:             send buffer
+ * @input_len:         send buffer size
+ * @output:            output buffer
+ * @output_len:        outout buffer size
+ * @response_code:     return code from the applet
+ *
+ * Return: 0 for success fail otherwise
+ */
+int dal_send_and_receive(u64 handle, u64 session_handle,
+			 int command_id, const u8 *input,
+			 size_t input_len, u8 **output,
+			 size_t *output_len,
+			 int *response_code);
+
+/**
+ * dal_close_session - close an open applet session
+ *
+ * @handle:            kdi handle
+ * @session_handle:    session handle
+ *
+ * Return: 0 for success fail otherwise
+ */
+int dal_close_session(u64 handle, u64 session_handle);
+
+#endif /* _DAL_H_ */
-- 
1.7.5.4

