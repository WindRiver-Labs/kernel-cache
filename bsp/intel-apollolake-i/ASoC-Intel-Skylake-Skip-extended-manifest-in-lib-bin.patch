From 7fb482d49d51ce3055b977a1acf881f8c81f2082 Mon Sep 17 00:00:00 2001
From: G Kranthi <gudishax.kranthikumar@intel.com>
Date: Thu, 18 Feb 2016 21:06:41 +0530
Subject: [PATCH 1860/2508] ASoC: Intel: Skylake: Skip extended manifest in
 lib binary

commit 84d855da5cf687a23347173924c5f0993c5bf222 from
https://github.com/01org/linux-apollolake-i

Loadable library could have extended manifest header as
a part of library image. The extended manifest is meant for
offline tools and it should not be loaded to dsp memory.

Check if the given fw image has extended manigest and
if yes, then skip it then load into dsp.

Change-Id: I619ea03b759e0e7d1ba7fa134074c48c2db9b8b8
Signed-off-by: G Kranthi <gudishax.kranthikumar@intel.com>
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/8194
Reviewed-by: Babu, Ramesh <ramesh.babu@intel.com>
Tested-by: Babu, Ramesh <ramesh.babu@intel.com>
---
 sound/soc/intel/skylake/bxt-sst.c |   30 +++++++++++++++++++++++++-----
 1 files changed, 25 insertions(+), 5 deletions(-)

diff --git a/sound/soc/intel/skylake/bxt-sst.c b/sound/soc/intel/skylake/bxt-sst.c
index 0ade383..569a1c2 100644
--- a/sound/soc/intel/skylake/bxt-sst.c
+++ b/sound/soc/intel/skylake/bxt-sst.c
@@ -182,7 +182,10 @@ static int bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
 {
 	struct snd_dma_buffer dmab;
 	struct skl_sst *skl = ctx->thread_context;
-	const struct firmware *fw = NULL;
+	struct firmware *fw = NULL;
+	struct skl_ext_manifest_header *hdr;
+	u32 size;
+	const void *data;
 	int ret = 0, i, dma_id, stream_tag;
 
 	for (i = 1; i < minfo->lib_count; i++) {
@@ -193,9 +196,22 @@ static int bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
 			goto load_library_failed;
 		}
 
+		size = fw->size;
+		data = fw->data;
+		hdr = (struct skl_ext_manifest_header *)fw->data;
+		if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID) {
+			dev_dbg(ctx->dev, "Found Extended manifest in Library Binary\n");
+			if (hdr->ext_manifest_len >= fw->size) {
+				ret = -EINVAL;
+				goto load_library_failed;
+			}
+			size = fw->size - hdr->ext_manifest_len;
+			data = fw->data + hdr->ext_manifest_len;
+		}
+
 		dev_dbg(ctx->dev, "Starting to preapre host dma for library name \
-			: %s of size:%zx\n", minfo->lib[i].name, fw->size);
-		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, fw->size,
+			: %s of size:%zx\n", minfo->lib[i].name, size);
+		stream_tag = ctx->dsp_ops.prepare(ctx->dev, 0x40, size,
 						&dmab);
 		if (stream_tag <= 0) {
 			dev_err(ctx->dev, "Failed to prepare DMA engine for \
@@ -204,7 +220,7 @@ static int bxt_load_library(struct sst_dsp *ctx, struct skl_dfw_manifest *minfo)
 			goto load_library_failed;
 		}
 		dma_id = stream_tag - 1;
-		memcpy(dmab.area, fw->data, fw->size);
+		memcpy(dmab.area, data, size);
 
 		ctx->dsp_ops.trigger(ctx->dev, true, stream_tag);
 		ret = skl_sst_ipc_load_library(&skl->ipc, dma_id, i);
@@ -584,8 +600,12 @@ static int bxt_load_base_firmware(struct sst_dsp *ctx)
 	hdr = (struct skl_ext_manifest_header *)fw->data;
 	if (hdr->ext_manifest_id == SKL_EXT_MANIFEST_MAGIC_HEADER_ID) {
 		dev_dbg(ctx->dev, "Found Extended manifest in FW Binary\n");
+		if (hdr->ext_manifest_len >= fw->size) {
+			ret = -EINVAL;
+			goto sst_load_base_firmware_failed;
+		}
 		size = fw->size - hdr->ext_manifest_len;
-		data = (u8 *)fw->data + hdr->ext_manifest_len;
+		data = fw->data + hdr->ext_manifest_len;
 	}
 
 	ret = sst_bxt_prepare_fw(ctx, data, size);
-- 
1.7.5.4

