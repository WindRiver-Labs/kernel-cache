From a7af95cfa5e6152cb9f25f6ba36e55ae17b7c926 Mon Sep 17 00:00:00 2001
From: Armin Reese <armin.c.reese@intel.com>
Date: Fri, 11 Mar 2016 13:33:47 -0800
Subject: [PATCH 1385/2508] drm/i915: Add a debugfs file to dump full ring
 contexts

commit 726beabac76adbc121bf74aa7d92b328499c24b5 from
https://github.com/01org/linux-apollolake-i

A 'cat' of the debugfs file i915_dump_lrc, dumps only the
first 1536 bytes of each ring's register state context.
It does not provide information about the ring's hardware
status page or the remaining portion of the register state
context.  This patch adds the file i915_context_dump
which displays the ring's hardware status page along with
the ring's full register state context.  Being able to view
the latter in its entirety will be very useful in debugging
issues arising from incorect context setup.

v1: Original patch
v2: reuse existing functions, add pid info in output, simplify zero skip logic.

Tracked-On: https://jira01.devtools.intel.com/browse/VIZ-6174
Change-Id: I891b85b92fcd420680e221f7e535aeeefc6a9e47
Signed-off-by: Armin Reese <armin.c.reese@intel.com>
Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
[Jeff: Modify so that a request to dump just the abbreviated LRC starts
 at the proper page.]
Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c |   99 +++++++++++++++++++++++++++--------
 1 files changed, 77 insertions(+), 22 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index 50f8b58..08d0c20 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -47,6 +47,11 @@ enum {
 	PINNED_LIST,
 };
 
+enum {
+	LRC_CONTEXT_DUMP,       /* First 1536 bytes of register state ctx */
+	FULL_CONTEXT_DUMP,      /* Full context (HW status + reg state ctx) */
+};
+
 /* As the drm_debugfs_init() routines are called before dev->dev_private is
  * allocated we need to hook into the minor for release. */
 static int
@@ -2211,19 +2216,14 @@ static int i915_context_status(struct seq_file *m, void *unused)
 
 static void i915_dump_lrc_obj(struct seq_file *m,
 			      struct intel_context *ctx,
-			      struct intel_engine_cs *engine)
+			      struct intel_engine_cs *engine,
+			      unsigned long dump_flag)
 {
 	struct page *page;
-	uint32_t *reg_state;
-	int j;
+	struct sg_page_iter sg_iter;
 	struct drm_i915_gem_object *ctx_obj = ctx->engine[engine->id].state;
 	unsigned long ggtt_offset = 0;
-
-	if (ctx_obj == NULL) {
-		seq_printf(m, "Context on %s with no gem object\n",
-			   engine->name);
-		return;
-	}
+	int i;
 
 	seq_printf(m, "CONTEXT: %s %u\n", engine->name,
 		   intel_execlists_ctx_id(ctx, engine));
@@ -2238,17 +2238,55 @@ static void i915_dump_lrc_obj(struct seq_file *m,
 		return;
 	}
 
-	page = i915_gem_object_get_page(ctx_obj, LRC_STATE_PN);
-	if (!WARN_ON(page == NULL)) {
-		reg_state = kmap_atomic(page);
+	i = 0;
+	for_each_sg_page(ctx_obj->pages->sgl, &sg_iter,
+			 ctx_obj->pages->nents, 0) {
+		/* Dump only the first page of LRC state if requested */
+		if (dump_flag == LRC_CONTEXT_DUMP && i != LRC_STATE_PN) {
+			i++;
+			continue;
+		}
+
+		page = sg_page_iter_page(&sg_iter);
+		if (!WARN_ON(page == NULL)) {
+			int j;
+			uint32_t *reg_state;
+			int run_length = 0;
+			unsigned long page_offset = ggtt_offset + i*PAGE_SIZE;
+
+			reg_state = kmap_atomic(page);
+
+			seq_printf(m, "Context object Page: %d\n", i);
+			for (j = 0; j < PAGE_SIZE / sizeof(u32); j += 4) {
+				if (reg_state[j + 0] == 0 && reg_state[j + 1] == 0 &&
+				    reg_state[j + 2] == 0 && reg_state[j + 3] == 0) {
+					run_length += 4;
+					continue;
+				}
+
+				if (run_length > 0) {
+					seq_printf(m, "\t[0x%08lx - 0x%08lx]: 0x00000000\n",
+						   page_offset + (j * 4) - (run_length * 4),
+						   page_offset + (j * 4) - 1);
+
+					run_length = 0;
+				}
+
+				seq_printf(m, "\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+					   page_offset + (j * 4),
+					   reg_state[j + 0], reg_state[j + 1],
+					   reg_state[j + 2], reg_state[j + 3]);
+			}
 
-		for (j = 0; j < 0x600 / sizeof(u32) / 4; j += 4) {
-			seq_printf(m, "\t[0x%08lx] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-				   ggtt_offset + 4096 + (j * 4),
-				   reg_state[j], reg_state[j + 1],
-				   reg_state[j + 2], reg_state[j + 3]);
+			if (run_length > 0) {
+				seq_printf(m, "\t[0x%08lx - 0x%08lx]: 0x00000000\n",
+					   page_offset + (j * 4) - (run_length * 4),
+					   page_offset + (j * 4) - 1);
+				run_length = 0;
+			}
+			kunmap_atomic(reg_state);
 		}
-		kunmap_atomic(reg_state);
+		++i;
 	}
 
 	seq_putc(m, '\n');
@@ -2261,7 +2299,8 @@ static int i915_dump_lrc(struct seq_file *m, void *unused)
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct intel_engine_cs *engine;
 	struct intel_context *ctx;
-	int ret;
+	uintptr_t dump_flag = (uintptr_t) node->info_ent->data;
+	int ret, i;
 
 	if (!i915.enable_execlists) {
 		seq_printf(m, "Logical Ring Contexts are disabled\n");
@@ -2274,8 +2313,23 @@ static int i915_dump_lrc(struct seq_file *m, void *unused)
 
 	list_for_each_entry(ctx, &dev_priv->context_list, link)
 		if (ctx != dev_priv->kernel_context)
-			for_each_engine(engine, dev_priv)
-				i915_dump_lrc_obj(m, ctx, engine);
+			for_each_engine_id(engine, dev_priv, i) {
+				struct drm_i915_gem_object *ctx_obj =
+					ctx->engine[i].state;
+				if (ctx_obj == NULL) {
+					seq_printf(m, "Context on %s with no gem object\n",
+						   engine->name);
+					continue;
+				}
+
+				if (ctx->file_priv) {
+					seq_printf(m, "CONTEXT: %s (PID: %u, UH:%d)\n",
+						   engine->name,
+						   pid_nr(ctx->file_priv->file->pid),
+						   ctx->user_handle);
+					i915_dump_lrc_obj(m, ctx, engine, dump_flag);
+				}
+			}
 
 	mutex_unlock(&dev->struct_mutex);
 
@@ -5740,7 +5794,8 @@ static const struct drm_info_list i915_debugfs_list[] = {
 	{"i915_vbt", i915_vbt, 0},
 	{"i915_gem_framebuffer", i915_gem_framebuffer_info, 0},
 	{"i915_context_status", i915_context_status, 0},
-	{"i915_dump_lrc", i915_dump_lrc, 0},
+	{"i915_dump_lrc", i915_dump_lrc, 0, (void *) LRC_CONTEXT_DUMP},
+	{"i915_context_dump", i915_dump_lrc, 0, (void *) FULL_CONTEXT_DUMP},
 	{"i915_execlists", i915_execlists, 0},
 	{"i915_forcewake_domains", i915_forcewake_domains, 0},
 	{"i915_swizzle_info", i915_swizzle_info, 0},
-- 
1.7.5.4

