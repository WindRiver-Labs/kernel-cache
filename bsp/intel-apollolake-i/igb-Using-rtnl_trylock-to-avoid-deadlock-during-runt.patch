From 5deed194710b5393d2f79924372d95a55ee5aede Mon Sep 17 00:00:00 2001
From: Jayasankar <jayasankarx.nara@intel.com>
Date: Thu, 29 Dec 2016 11:37:47 +0800
Subject: [PATCH 7/7] igb: Using rtnl_trylock to avoid deadlock during runtime
 resume

commit 9ba143931b7f2a2bd90ea52ec6fcbf77f11c63bf from
git://git.yoctoproject.org/linux-yocto-4.1

Network device ioctl function in net/core/dev_ioctl.c is acquiring
rtnl_lock for some ioctl commands like ethtool(SIOCETHTOOL) before
calling the driver op function. Invoking runtime resume for handling
such ioctl and acquiring rtnl_lock in igb_resume() function is causing
deadlock. To avoid deadlock in such cases using rtnl_trylock.

While runtime resuming is in progress, device runtime state will be
RESUMING and there is no other activity can happen on net_device
structure until the runtime state changes to ACTIVE. With the current
design while resuming is in progress, if any of the net device
operations callback is called, the callback will not proceed until the
state is changed to ACTIVE. So there is no chance of simultaneous access
even if we use trylock.

Signed-off-by: Jayasankar <jayasankarx.nara@intel.com>
Signed-off-by: Chuah, Kim Tatt <kim.tatt.chuah@intel.com>
Signed-off-by: Lai, Poey Seng <poey.seng.lai@intel.com>
---
 drivers/net/ethernet/intel/igb/igb_main.c |   21 ++++++++++++++++++---
 1 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 1aae76c..646007d 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -7479,6 +7479,7 @@ static int igb_resume(struct device *dev)
 	struct igb_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
 	u32 err;
+	int status;
 
 	pci_set_power_state(pdev, PCI_D0);
 	pci_restore_state(pdev);
@@ -7512,9 +7513,23 @@ static int igb_resume(struct device *dev)
 	wr32(E1000_WUS, ~0);
 
 	if (netdev->flags & IFF_UP) {
-		rtnl_lock();
-		err = __igb_open(netdev, true);
-		rtnl_unlock();
+		if (!(pdev->dev.power.runtime_status == RPM_RESUMING)) {
+			/* normal resume */
+			rtnl_lock();
+			err = __igb_open(netdev, true);
+			rtnl_unlock();
+		} else {
+			/* Ensure that rtnl_lock is held. If it was previously
+			 * held, it is safe to proceed as it should be held by
+			 * the caller, such as in ethtool case, and not by any
+			 * other thread while runtime resuming.
+			 */
+			status = rtnl_trylock();
+			err = __igb_open(netdev, true);
+			if (status == 1)
+				rtnl_unlock();
+		}
+
 		if (err)
 			return err;
 	}
-- 
1.7.5.4

