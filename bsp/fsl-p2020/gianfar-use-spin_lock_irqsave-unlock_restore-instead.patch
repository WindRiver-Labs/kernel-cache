From cce6cdc29c5db6893ba05d8c0b7d66036a45f6fb Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Thu, 18 Oct 2012 16:34:43 +0800
Subject: [PATCH] gianfar: use spin_lock_irqsave/unlock_restore instead of spin_lock/unlock_irq

The below Call Trace is threw in process of using kgdboe to debug
kernel.

netpoll_send_skb(): eth1 enabled interrupts in poll (gfar_start_xmit+0x0/0x774)
KGDB: re-enter exception: ALL breakpoints killed
Call Trace:
[cfbf3ac0] [c0008c14] show_stack+0x10c/0x1c0 (unreliable)
[cfbf3b10] [c064b050] dump_stack+0x24/0x34
[cfbf3b20] [c00a9590] kgdb_handle_exception+0x190/0x1b0
[cfbf3b70] [c00116b0] kgdb_handle_breakpoint+0x4c/0x90
[cfbf3b80] [c0643d3c] program_check_exception+0x238/0x254
[cfbf3b90] [c0010954] ret_from_except_full+0x0/0x4c
--- Exception: 700 at netpoll_send_skb_on_dev+0x1f0/0x21c
  LR = netpoll_send_skb_on_dev+0x1f0/0x21c
[cfbf3c90] [c055e2f4] netpoll_send_udp+0x1c4/0x1d8
[cfbf3cc0] [d106a2a4] eth_flush_buf+0x50/0x8c [kgdboe]
[cfbf3cd0] [d106a320] eth_put_char+0x40/0x50 [kgdboe]
[cfbf3ce0] [c00a9a18] put_packet+0x78/0x150
[cfbf3d10] [c00aa518] gdb_serial_stub+0x1fc/0xd58
[cfbf3d90] [c00a8efc] kgdb_cpu_enter+0x2e8/0x648
[cfbf3df0] [c00a9480] kgdb_handle_exception+0x80/0x1b0
[cfbf3e40] [c00116b0] kgdb_handle_breakpoint+0x4c/0x90
[cfbf3e50] [c0643d3c] program_check_exception+0x238/0x254
[cfbf3e60] [c0010954] ret_from_except_full+0x0/0x4c

The issue is introduced by the following commit.
[
gianfar: Optimize Tx/Rx ring cleanup using TSTAT/RSTAT

In Rx/Tx cleanup functions divide the total cleanup bugdet
only among active queues. i.e calcute budget_per_queue
based on active queues indicated by rstat/tstat instead
of using num_queues (total number of queues).
]

We need to use spin_lock_irqsave()/spin_unlock_irqrestore instead of
spin_lock_irq/spin_unlock_irq in gfar_poll_rx and gfar_poll_tx since
gfar_netpoll() will eventually trigger these two functions when local CPU
interrupts are disabled.

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   10 ++++++----
 1 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 5a0b98b..3131651 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -3909,6 +3909,7 @@ static int gfar_poll_rx(struct napi_struct *napi, int budget)
 	struct gfar_priv_rx_q *rx_queue = NULL;
 	int rx_cleaned = 0, budget_per_queue = 0, rx_cleaned_per_queue = 0;
 	int i, num_act_qs = 0, napi_done = 1;
+	unsigned long flags;
 	u32 imask, ievent, rstat, rstat_local, rstat_rxf, rstat_rhalt = 0, mask;
 
 	rstat = gfar_read(&regs->rstat);
@@ -3950,7 +3951,7 @@ static int gfar_poll_rx(struct napi_struct *napi, int budget)
 	if (napi_done) {
 		napi_complete(napi);
 		gfar_configure_rx_coalescing(priv, gfargrp->rx_bit_map);
-		spin_lock_irq(&gfargrp->grplock);
+		spin_lock_irqsave(&gfargrp->grplock, flags);
 		imask = gfar_read(&regs->imask);
 		imask |= IMASK_DEFAULT_RX;
 		gfar_write(&regs->imask, imask);
@@ -3962,7 +3963,7 @@ static int gfar_poll_rx(struct napi_struct *napi, int budget)
 			gfar_write(&gfargrp->regs->ievent, IEVENT_RX_MASK);
 			napi_schedule(napi);
 		}
-		spin_unlock_irq(&gfargrp->grplock);
+		spin_unlock_irqrestore(&gfargrp->grplock, flags);
 	}
 
 	return rx_cleaned;
@@ -3978,6 +3979,7 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 	int tx_cleaned = 0, budget_per_queue = 0, tx_cleaned_per_queue = 0;
 	int i, num_act_qs = 0, napi_done = 1;
 	u32 imask, tstat, tstat_local, mask;
+	unsigned long flags;
 
 
 	tstat = gfar_read(&regs->tstat);
@@ -4008,11 +4010,11 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 	if (napi_done) {
 		napi_complete(napi);
 		gfar_configure_tx_coalescing(priv, gfargrp->tx_bit_map);
-		spin_lock_irq(&gfargrp->grplock);
+		spin_lock_irqsave(&gfargrp->grplock, flags);
 		imask = gfar_read(&regs->imask);
 		imask |= IMASK_DEFAULT_TX;
 		gfar_write(&regs->imask, imask);
-		spin_unlock_irq(&gfargrp->grplock);
+		spin_unlock_irqrestore(&gfargrp->grplock, flags);
 	}
 
 	return tx_cleaned;
-- 
1.7.0.2

