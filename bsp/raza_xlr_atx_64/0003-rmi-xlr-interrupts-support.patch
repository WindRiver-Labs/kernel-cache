From 25f86c7e8bce69d8b96ae2f40f340ec52434d96a Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 16 Dec 2008 19:06:56 +0800
Subject: [PATCH] rmi xlr interrupts support

phoenix/irq.c is platform irq dispatch code.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
new file mode 100644
index 0000000..723db5b
--- /dev/null
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -0,0 +1,504 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/errno.h>
+#include <asm/signal.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/kgdb.h>
+#include <asm/mipsregs.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/msidef.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/debug.h>
+#include <asm/thread_info.h>
+
+/*
+ * These are the routines that handle all the low level interrupt stuff. 
+ * Actions handled here are: initialization of the interrupt map, requesting of
+ * interrupt lines by handlers, dispatching if interrupts to handlers, probing
+ * for interrupt lines 
+*/
+
+extern void phoenix_timer_interrupt(struct pt_regs *regs, int irq);
+extern void phoenix_smp_time_init(void);
+extern void *ht_config_base;
+extern int link0, link1;
+
+__u64 phnx_irq_mask;
+spinlock_t phnx_pic_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned int pic_startup(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return EINVAL;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/* 
+	 * What happens if this irq was previously not ack'ed? 
+	 * Assume, that doesn't happen?
+	*/
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+
+	/* 
+	 * By default all the interrupts are initialized as level senstive 
+	 * fix for the PCMCIA flash 
+	*/
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE,
+					  reg | (1 << 6) | (1 << 30) | (1 << 31));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return 0;
+}
+
+static void pic_unmask(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/*
+	 * What happens if this irq was previously not ack'ed? 
+	 * Assume, that doesn't happen?
+	*/
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+
+	/* 
+	 * By default all the interrupts are initialized as level senstive 
+	 * fix for the PCMCIA flash 
+	*/
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE,
+					  reg | (1 << 6) | (1 << 30) | (1 << 31));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return;
+}
+
+static void pic_ack(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_reg_t *pci_mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+	phoenix_reg_t *ht_mmio = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+
+	/* XLS PCIE : the Little Endian region */
+	phoenix_reg_t *pcie_mmio_le = NULL;
+
+	unsigned long i, flags;
+	phoenix_reg_t reg;
+
+#ifdef	XLS
+	if (is_xls()) {
+		pcie_mmio_le = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
+	}
+#endif
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	/* Interrupt (level sensitive ) acknowledge method for the PCMCIA flash */
+	if (irq == 21) {
+		reg = *(unsigned char *) (unsigned long) (0xffffffffBD0001f7ULL);
+		reg = *(unsigned int *) (unsigned long) (0xffffffffBEF19180ULL);
+		for (i = 0; i < 0x100; i++);
+		*(unsigned int *) (unsigned long) (0xffffffffBEF19180ULL) = reg;
+		for (i = 0; i < 0x1000; i++);
+		reg = *(unsigned int *) (unsigned long) (0xffffffffBEF19180ULL);
+	}
+
+	/* Deal with All PCI-Interrupts.. Brigde ACK */
+	if ((irq == 24) && (!is_xls()))
+		phoenix_read_reg(pci_mmio, (0x140 >> 2));
+
+	if (irq == 23) {
+
+		/* HyperTransport: Clear INT Status */
+		phoenix_read_reg(ht_mmio, (0x700 >> 2));
+
+		/* 
+		 *  ---------------------------------------------------------
+		 *  Generating EOI.
+		 *  Clear Interrupts by directly writing to PLX's CFG Space. 
+		 *  1. setup the off value in register 0xB8
+		 *     (Interrupt Discovery Configuration, bits 23-16). 
+		 *  2. clear the interrupt by setting the IRR bit 
+		 *     (bit 63) in reg 0xBC (IRDR). 
+		 *  ---------------------------------------------------------
+		 *  If more devices are added to HT, we have to use the EOI 
+		 *  broadcast.
+		 *  ---------------------------------------------------------
+		 *  NOTE: Send EOI for all interrupts (INT A, B, C and D).
+		 *  Bridge Cards, if plugged into the slot, may re-route 
+		 *  interrupts. E.g: Intel Bridge 31154 eval board re-routes 
+		 *  INTA of the endpoint to INTC of PLX.
+		 *  ---------------------------------------------------------
+		*/
+#ifdef CONFIG_PCI
+		/* Generate EOI for INTA */
+		*(volatile uint32_t *) (ht_config_base + 0x008b8) = 0x08c01180;
+		*(volatile uint32_t *) (ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTB */
+		*(volatile uint32_t *) (ht_config_base + 0x008b8) = 0x08c01380;
+		*(volatile uint32_t *) (ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTC */
+		*(volatile uint32_t *) (ht_config_base + 0x008b8) = 0x08c01580;
+		*(volatile uint32_t *) (ht_config_base + 0x008bc) = 0x00000080;
+
+		/* Generate EOI for INTD */
+		*(volatile uint32_t *) (ht_config_base + 0x008b8) = 0x08c01780;
+		*(volatile uint32_t *) (ht_config_base + 0x008bc) = 0x00000080;
+#endif
+	}
+
+	/* Ack the PCIE Block MSI Status Register(s) */
+	if (is_xls()) {
+		if (irq == 34) {
+			/*Link0 */
+			phoenix_write_reg(pcie_mmio_le, (0x90 >> 2), 0xffffffff);
+		}
+		if (irq == 35) {
+			/*Link1 */
+			phoenix_write_reg(pcie_mmio_le, (0x94 >> 2), 0xffffffff);
+		}
+		if (irq == 31) {
+			/*Link2 */
+			phoenix_write_reg(pcie_mmio_le, (0x190 >> 2), 0xffffffff);
+		}
+		if (irq == 32) {
+			/*Link3 */
+			phoenix_write_reg(pcie_mmio_le, (0x194 >> 2), 0xffffffff);
+		}
+	}
+
+	/* 
+	 * If edge triggered IRQ, ack it immediately, else when the device
+	 * interrupt condition is cleared, we may lose interrupts 
+	*/
+	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_end(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	/* If level triggered, ack it after the device condition is cleared */
+	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (irq - PIC_IRQ_BASE)));
+
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_shutdown(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	/* 
+	 * What happens if this irq is currently pending an ack? 
+	 * Assume, that doesn't happen?
+	*/
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE,
+					  (reg & ~(1 << 31)));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static void pic_set_affinity(unsigned int irq, cpumask_t mask)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+
+	if (!PIC_IRQ_IS_IRT(irq))
+		return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE,
+					  (uint32_t) (mask.bits[0]));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static struct irq_chip phnx_pic = {
+	.name = "Phoenix-PIC",
+	.unmask = pic_unmask,
+	.mask = pic_shutdown,
+	.ack = pic_ack,
+	.end = pic_end,
+	.set_affinity = pic_set_affinity
+};
+
+static void rsvd_pic_handler_1_1(unsigned int irq)
+{
+	dbg_msg("Requesting a reserved irq (%d)??", irq);
+	return;
+}
+
+static void rsvd_pic_handler_1(unsigned int irq)
+{
+	dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static void rsvd_pic_handler_2(unsigned int irq, cpumask_t mask)
+{
+	dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static struct irq_chip phnx_rsvd_pic = {
+	.name = "Phoenix-RSVD-PIC",
+	.unmask = rsvd_pic_handler_1_1,
+	.mask = rsvd_pic_handler_1,
+	.ack = rsvd_pic_handler_1,
+	.end = rsvd_pic_handler_1,
+	.set_affinity = rsvd_pic_handler_2
+};
+
+static irqreturn_t phnx_rsvd_irq_handler(int irq, void *dev_id)
+{
+	printk("handler for reserved irq %d\n", irq);
+	return IRQ_NONE;
+}
+
+static struct irqaction phnx_rsvd_action = {
+	.handler = phnx_rsvd_irq_handler,
+	.flags = 0,
+	.name = "phnx_rsvd_action",
+	.dev_id = 0,
+	.next = 0
+};
+
+void __init init_phoenix_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, &phnx_pic);
+	}
+
+#ifdef CONFIG_REMOTE_DEBUG
+	irq_desc[IRQ_REMOTE_DEBUG].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_REMOTE_DEBUG].action = phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
+#endif
+
+#ifdef CONFIG_SMP
+	irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &phnx_rsvd_action;
+
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &phnx_rsvd_action;
+
+#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
+	/* PR: New IPI added here for netrx balancing */
+	irq_desc[IRQ_IPI_NETRX].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_NETRX].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << IRQ_IPI_NETRX);
+#endif
+
+	phnx_irq_mask |=
+		((1ULL << IRQ_IPI_SMP_FUNCTION) | (1ULL << IRQ_IPI_SMP_RESCHEDULE));
+#endif
+
+	/* msgring interrupt */
+	irq_desc[IRQ_MSGRING].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_MSGRING].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << IRQ_MSGRING);
+
+	/* msgring timeout interrupt */
+	irq_desc[PIC_TIMER_0_IRQ].chip = &phnx_rsvd_pic;
+	irq_desc[PIC_TIMER_0_IRQ].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << PIC_TIMER_0_IRQ);
+
+	phnx_irq_mask |= (1ULL << IRQ_DUMMY_UART);
+
+	/*
+	 * unmask all PIC related interrupts. If no handler is installed by the 
+	 * drivers, it'll just ack the interrupt and return 
+	*/
+	for (i = PIC_IRT_FIRST_IRQ; i <= PIC_IRT_LAST_IRQ(); i++)
+		phnx_irq_mask |= (1ULL << i);
+
+}
+
+void do_phnx_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+#ifdef CONFIG_SMP
+#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
+	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE
+		|| irq == IRQ_IPI_NETRX) {
+#else
+	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
+#endif
+		phoenix_ipi_handler(irq, regs);
+		return;
+	}
+#endif
+	if (irq == IRQ_MSGRING || irq == PIC_TIMER_0_IRQ)
+		phnx_msgring_int_handler(irq, regs);
+	else
+		do_IRQ(irq);
+}
+
+
+void __init phoenix_smp_init(void)
+{
+	/* Set up kseg0 to be cachable coherent */
+	change_c0_config(CONF_CM_CMASK, _page_cachable_default >> _CACHE_SHIFT);
+
+	/* set interrupt mask for non-zero cpus */
+	write_64bit_cp0_eimr(phnx_irq_mask | (1 << IRQ_TIMER));
+}
+
+/* 
+ * MSI hook-up routines for RMI Boards;
+ * Arch-dependent implementation called
+ * from generic msi.c routines.
+*/
+struct irq_chip phnx_pic_msi = {
+	.name = "Phoenix-PIC-MSI",
+	.startup = pic_startup,
+	.shutdown = pic_shutdown,
+	.ack = pic_ack,
+	.end = pic_end,
+	.set_affinity = pic_set_affinity
+};
+
+void destroy_irq(unsigned int irq)
+{
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+void __init arch_init_irq(void)
+{
+	/* 
+	 * TODO:
+	 * Initialize the irq registers on the PIC to route
+	 * interrupts to appropriate pins
+	*/
+
+	/* Initialize the irq descriptors */
+	init_phoenix_irqs();
+	write_64bit_cp0_eimr(phnx_irq_mask | (1 << IRQ_TIMER));
+}
+
+static int __flb(uint64_t dw)
+{   
+	int ret;
+#ifdef CONFIG_64BIT
+    asm (
+			".set mips64\n\t"
+			"dclz %0, %1"
+			: "=r" (ret) : "r" (dw)
+		);
+#else
+	asm (
+			".set mips64\n\t"
+			"dsll %L1, %L1, 32\n\t"
+			"dsrl %L1, %L1, 32\n\t"
+			"dsll %M1, %M1, 32\n\t"
+			"or %L1, %L1, %M1\n\t"
+			"dclz %0, %L1\n\t"
+			".set mips0"
+			: "=r" (ret)
+			: "r" (dw)
+		);
+#endif        
+
+    return 63 - ret;
+}   
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	uint64_t eirr;
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+	int i = 0;
+
+	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
+
+	i = __flb(eirr);
+
+	if (i == -1) {
+		printk("no interrupt !!\n");
+		return;
+	}
+
+	/*ack eirr */
+	write_64bit_cp0_eirr(1ULL << i);
+
+	do_phnx_IRQ(i, pt_regs);
+	return;
+}
diff --git a/include/asm-mips/mach-phoenix/irq.h b/include/asm-mips/mach-phoenix/irq.h
new file mode 100644
index 0000000..e848500
--- /dev/null
+++ b/include/asm-mips/mach-phoenix/irq.h
@@ -0,0 +1,18 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright 2008 Wind River System, Inc.
+ *
+ * Author: Jack Tan <jack.tan@windriver.com>
+ *
+ */
+#ifndef __ASM_MACH_PHOENIX_IRQ_H
+#define __ASM_MACH_PHOENIX_IRQ_H
+
+#include_next <irq.h>
+
+#define	MIPS_CPU_IRQ_BASE	0
+
+#endif /* __ASM_MACH_PHOENIX_IRQ_H */
