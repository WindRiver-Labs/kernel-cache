From e3a2e1c6ebe052058dd323c86f9797eb21c38b9e Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Sat, 11 Jul 2009 17:21:21 -0400
Subject: [PATCH 4/6] RMI/kexec: Reset devices upon booting

This is needed for kexec to work properly. The message rings need
to be shut off, the pending interrupts cleared and acked, the
message ring timer shut off and the GMACs reset.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/mips/rmi/phoenix/irq.c     |    9 +++++
 arch/mips/rmi/phoenix/on_chip.c |   76 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 85 insertions(+), 0 deletions(-)

diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index ae05652..2e14493 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -389,11 +389,20 @@ void __init init_phoenix_irqs(void)
 
 }
 
+extern void on_chip_shutoff_msgring(void);
+
 void __init phoenix_smp_init(void)
 {
 	/* Set up kseg0 to be cachable coherent */
 	change_c0_config(CONF_CM_CMASK, _page_cachable_default >> _CACHE_SHIFT);
 
+	/* shutoff message ring on current CPU */
+	on_chip_shutoff_msgring();
+
+	/* clear all pending interrupts (don't touch timer and soft,
+	 * they're special) */
+	write_64bit_cp0_eirr(0xffffffffffffff7c);
+
 	/* set interrupt mask for non-zero cpus */
 	write_64bit_cp0_eimr(phnx_irq_mask | (1 << IRQ_TIMER));
 }
diff --git a/arch/mips/rmi/phoenix/on_chip.c b/arch/mips/rmi/phoenix/on_chip.c
index 4910caa..71d7e94 100644
--- a/arch/mips/rmi/phoenix/on_chip.c
+++ b/arch/mips/rmi/phoenix/on_chip.c
@@ -40,6 +40,7 @@
 #include <asm/rmi/debug.h>
 #include <asm/rmi/phnx_user_mac.h>
 #include <asm/rmi/sim.h>
+#include <asm/rmi/gpio.h>
 
 unsigned long phoenix_io_base = (unsigned long)(DEFAULT_PHOENIX_IO_BASE);
 extern int xlr_loader_support;
@@ -572,6 +573,8 @@ static void pic_init(void)
 
 		/* Bind all PIC irqs to boot cpu */
 		phoenix_write_reg(mmio, PIC_IRT_0_BASE + i, thread_mask);
+		/* ACK all IRQs in case they're pending */
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << i));
 
 		/*
 		 * Use local scheduling and high polarity for all IRTs
@@ -583,10 +586,83 @@ static void pic_init(void)
 
 atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS] __cacheline_aligned;
 
+/* Timer 0 is used for timeouts on the fast messaging network (FMN):
+ * if coming in here from a kexec call, it might still throw interrupts
+ * to CPUs not ready to handle them
+ */
+static void on_chip_shutoff_timer_0(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	__u32 control_reg;
+
+	control_reg = pic_read_control();
+	control_reg &= ~(1<<8);
+	pic_write_control(control_reg);
+	phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (PIC_TIMER_0_IRQ - PIC_IRQ_BASE)));
+}
+
+/* need COP2 to be accessible */
+void on_chip_msgring_drain_msgs(void)
+{
+	unsigned int bucket_empty_bm;
+	int bucket;
+	int size, code, stid;
+	struct msgrng_msg msg;
+
+	/* loop is just to be safe, but should only hit once in theory */
+	for(;;) {
+		bucket_empty_bm = (msgrng_read_status() >> 24) & 0xff;
+
+		/* all buckets empty, break*/
+		if (bucket_empty_bm == 0xff) break;
+
+		/* loop and drop messages */
+		for (bucket = 0; bucket < 8; bucket++) {
+			if ((bucket_empty_bm & (1 << bucket)) ||
+				!((1 << bucket) & 0xff))
+				continue;
+
+			(void)message_receive(bucket, &size, &code, &stid, &msg);
+		}
+	}
+}
+
+/* Message ring of the fast messaging network (FMN):
+ * if coming in here from a kexec call, it might still throw interrupts
+ * to CPUs not ready to handle them
+ */
+void on_chip_shutoff_msgring(void)
+{
+	unsigned long flags = 0;
+	msgrng_enable(flags);
+
+	/* shut everything off the hard way */
+	msgrng_write_config(0);
+	/* drain queues */
+	on_chip_msgring_drain_msgs();
+
+	msgrng_disable(flags);
+}
+
+extern void rmi_reset_gmacs(void);
 void on_chip_init(void)
 {
 	int i=0, j=0;
 
+	/* Upon a reboot from kexec, some devices can be left in an state
+	 * different than from coming up from the boot loader. Put them in
+	 * a known state.
+	 *
+	 * If coming up from the boot loader (ie. first kernel), it is still
+	 * safe to perform this. The boot loader resets the gmacs just
+	 * before jumping to the kernel, so the call here does not really
+	 * do anything, and the message rings should be on hold (timer 0 is
+	 * used by the message rings, it should not be activated yet).
+	 */
+	rmi_reset_gmacs();
+	on_chip_shutoff_timer_0();
+	on_chip_shutoff_msgring();
+
 	/* Set phoenix_io_base to the run time value */
 	spin_lock_init(&msgrng_lock);
 
-- 
1.6.3.1

