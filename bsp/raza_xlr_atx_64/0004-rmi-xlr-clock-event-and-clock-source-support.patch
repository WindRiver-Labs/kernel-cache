From 8382038bbb9f1055f6d581a0c68de095e7a0d6a6 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 16 Dec 2008 19:06:57 +0800
Subject: [PATCH] rmi xlr clock event and clock source support

There are 8 timers in XLR's on-chip Programmable Interrupt Controller.
vCPU0 (the first boot up thread) use PIC's timer7 as its timer interrupt
source (clock event) and other 30 vCPUs use mips compare/count as its timer
interrupt source.

And we use PIC's timer6 as its hardware clock source.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/kernel/cevt-phoenix.c |  153 +++++++++++++++++++++++++++++++++++++++
 arch/mips/kernel/csrc-phoenix.c |   68 +++++++++++++++++
 arch/mips/kernel/time.c         |    4 +
 arch/mips/rmi/phoenix/time.c    |   36 +++++++++
 4 files changed, 261 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/kernel/cevt-phoenix.c
 create mode 100644 arch/mips/kernel/csrc-phoenix.c
 create mode 100644 arch/mips/rmi/phoenix/time.c

diff --git a/arch/mips/kernel/cevt-phoenix.c b/arch/mips/kernel/cevt-phoenix.c
new file mode 100644
index 0000000..3b8651f
--- /dev/null
+++ b/arch/mips/kernel/cevt-phoenix.c
@@ -0,0 +1,153 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/clocksource.h>
+#include <linux/interrupt.h>
+#include <linux/percpu.h>
+
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/rmi/mips-exts.h>
+
+#define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
+
+static void phoenix_set_mode(enum clock_event_mode mode,
+                           struct clock_event_device *evt)
+{
+	unsigned int cpu = hard_smp_processor_id();
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long long delta = PIC_CLKS_PER_TIMER_TICK;
+
+	if (smp_processor_id() != 0) {
+		BUG();
+		return;
+	}
+
+	switch (mode) {
+		case CLOCK_EVT_MODE_PERIODIC:
+			phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_0, (delta & 0xffffffff));
+			phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_1,
+							  (delta >> 32) & 0xffffffff);
+			phoenix_write_reg(mmio, PIC_IRT_0_TIMER_7, (1 << cpu));
+			phoenix_write_reg(mmio, PIC_IRT_1_TIMER_7,
+							  (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_7_IRQ));
+			pic_update_control(1 << (8 + 7));
+			break;
+
+		case CLOCK_EVT_MODE_ONESHOT:
+			/* Stop the timer until we actually program a shot */
+		case CLOCK_EVT_MODE_SHUTDOWN:
+		case CLOCK_EVT_MODE_UNUSED:
+			phoenix_write_reg(mmio, PIC_IRT_0_TIMER_7, 0);
+			pic_update_control(1 << (8 + 7));
+			break;
+
+		case CLOCK_EVT_MODE_RESUME:
+			phoenix_write_reg(mmio, PIC_IRT_0_TIMER_7, (1 << cpu));
+			phoenix_write_reg(mmio, PIC_IRT_1_TIMER_7,
+							  (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_7_IRQ));
+			pic_update_control(1 << (8 + 7));
+			break;
+			;
+	}
+}
+
+static int phoenix_next_event(unsigned long dlt, struct clock_event_device *cd)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	int cpu = (phoenix_cpu_id() << 2) | phoenix_thr_id();
+	unsigned long long delta = (unsigned long long)dlt;
+
+	if (smp_processor_id() != 0) {
+		BUG();
+		return 0;
+	}
+
+	phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_0, (delta & 0xffffffff));
+	phoenix_write_reg(mmio, PIC_TIMER_7_MAXVAL_1,
+					  (delta >> 32) & 0xffffffff);
+	phoenix_write_reg(mmio, PIC_IRT_0_TIMER_7, (1 << cpu));
+	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_7,
+					  (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_7_IRQ));
+	pic_update_control(1 << (8 + 7));
+
+	return 0;
+}
+
+static irqreturn_t phoenix_timer7_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+
+	/* ack the pic */
+	phoenix_write_reg(mmio, PIC_INT_ACK,
+					  (1 << (PIC_TIMER_7_IRQ - PIC_IRQ_BASE)));
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static void phoenix_event_handler(struct clock_event_device *dev)
+{
+
+}
+
+static struct irqaction phoenix_irqaction = {
+	.handler	= phoenix_timer7_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU,
+	.name		= "phoenix-timer7",
+};
+
+/* This clock event is for cpu0 */
+static struct clock_event_device phoenix_timer7_clockevent = {
+	.name		= "phoenix-timer7",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.cpumask	= CPU_MASK_CPU0,
+	.set_next_event	= phoenix_next_event,
+	.set_mode	= phoenix_set_mode,
+	.event_handler	= phoenix_event_handler,
+};
+
+void __cpuinit phoenix_clockevent_init(void)
+{
+	struct irqaction *action = &phoenix_irqaction;
+	struct clock_event_device *cd = &phoenix_timer7_clockevent;
+
+	if (smp_processor_id() != 0) {
+		BUG();
+		return;
+	}
+
+	clockevent_set_clock(cd, PIC_CLKS_PER_SEC);
+	cd->max_delta_ns	= clockevent_delta2ns(ULONG_MAX, cd);
+	cd->min_delta_ns	= clockevent_delta2ns(2, cd);
+	cd->rating		= 200 + PIC_CLKS_PER_SEC / 10000000;
+	cd->irq			= PIC_TIMER_7_IRQ;
+	clockevents_register_device(cd);
+
+	action->mask	= CPU_MASK_CPU0;
+	action->dev_id	= cd;
+
+	setup_irq(PIC_TIMER_7_IRQ, action);
+}
diff --git a/arch/mips/kernel/csrc-phoenix.c b/arch/mips/kernel/csrc-phoenix.c
new file mode 100644
index 0000000..d848eba
--- /dev/null
+++ b/arch/mips/kernel/csrc-phoenix.c
@@ -0,0 +1,68 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/clocksource.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+
+#include <asm/rmi/pic.h>
+
+#define	PIC_TIMER6_MAX_VAL	0xffffffff
+
+cycle_t xlr_hpt_read(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	uint32_t counter = 0;
+
+	counter = phoenix_read_reg(mmio, PIC_TIMER_6_COUNTER_0);
+
+	return (cycle_t) (PIC_TIMER6_MAX_VAL - counter);
+}
+
+struct clocksource phoenix_clocksource = {
+	.name	= "phoenix-timer6",
+	.rating	= 200 + PIC_CLKS_PER_SEC / 10000000,
+	.read	= xlr_hpt_read,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+void __init phoenix_clocksource_init(void)
+{
+	struct clocksource *cs = &phoenix_clocksource;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+
+	/* Use PIC Timer 6 as a free running counter */
+	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_0, 0xffffffff);
+	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_1, 0x0);
+	/* we Don't need interrupts */
+	phoenix_write_reg(mmio, PIC_IRT_0_TIMER_6, 0);
+	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_6,
+					  (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_6_IRQ));
+	pic_update_control(1 << (8 + 6));
+
+	clocksource_set_clock(cs, PIC_CLKS_PER_SEC);
+	clocksource_register(cs);
+}
diff --git a/arch/mips/kernel/time.c b/arch/mips/kernel/time.c
index 75e45b5..d5cb70e 100644
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -119,6 +119,7 @@ void __init plat_timer_setup(void)
 	BUG();
 }
 
+#ifndef CONFIG_CPU_PHOENIX
 static __init int cpu_has_mfc0_count_bug(void)
 {
 	switch (current_cpu_type()) {
@@ -150,11 +151,14 @@ static __init int cpu_has_mfc0_count_bug(void)
 
 	return 0;
 }
+#endif
 
 void __init time_init(void)
 {
 	plat_time_init();
 
+#ifndef CONFIG_CPU_PHOENIX
 	if (!mips_clockevent_init() || !cpu_has_mfc0_count_bug())
 		init_mips_clocksource();
+#endif
 }
diff --git a/arch/mips/rmi/phoenix/time.c b/arch/mips/rmi/phoenix/time.c
new file mode 100644
index 0000000..23f2932
--- /dev/null
+++ b/arch/mips/rmi/phoenix/time.c
@@ -0,0 +1,36 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <asm/time.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/debug.h>
+
+extern void __init phoenix_clocksource_init(void);
+extern void __cpuinit phoenix_clockevent_init(void);
+
+void __init plat_time_init(void)
+{
+	mips_hpt_frequency = PIC_CLKS_PER_SEC;
+
+	phoenix_clocksource_init();
+	phoenix_clockevent_init();
+}
+
-- 
1.6.0.2.GIT

