From 2fc689806e6c913ba046d928d8338a2ce2957ecf Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 17 Dec 2008 10:28:18 +0800
Subject: [PATCH] rmi xlr spi4 driver

RMI XLR SPI4 driver.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/net/Kconfig                      |    8 +
 drivers/net/Makefile                     |    1 +
 drivers/net/rmi_spi4/Makefile            |    5 +
 drivers/net/rmi_spi4/meigsii_reg.h       |  458 +++
 drivers/net/rmi_spi4/os_layer.c          |   91 +
 drivers/net/rmi_spi4/os_layer.h          |   51 +
 drivers/net/rmi_spi4/rmi_spi4.c          |  844 ++++++
 drivers/net/rmi_spi4/rmi_spi4.h          |  220 ++
 drivers/net/rmi_spi4/rmi_spi4_config.h   |  138 +
 drivers/net/rmi_spi4/rmi_vits_driver.c   |  282 ++
 drivers/net/rmi_spi4/rmi_vits_driver.h   |   52 +
 drivers/net/rmi_spi4/rmi_vits_eth.c      | 1076 +++++++
 drivers/net/rmi_spi4/rmi_vits_eth.h      |  153 +
 drivers/net/rmi_spi4/rmi_vits_wrapper.c  |   84 +
 drivers/net/rmi_spi4/rmi_vits_wrapper.h  |   45 +
 drivers/net/rmi_spi4/vitesse_common.h    |  271 ++
 drivers/net/rmi_spi4/vitesse_highlevel.c | 4611 ++++++++++++++++++++++++++++++
 drivers/net/rmi_spi4/vitesse_highlevel.h | 1396 +++++++++
 drivers/net/rmi_spi4/vitesse_io.c        |  200 ++
 drivers/net/rmi_spi4/vitesse_io.h        |   78 +
 drivers/net/rmi_spi4/vitesse_phy_ctrl.c  |  435 +++
 drivers/net/rmi_spi4/vitesse_phy_ctrl.h  |  299 ++
 22 files changed, 10798 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/rmi_spi4/Makefile
 create mode 100644 drivers/net/rmi_spi4/meigsii_reg.h
 create mode 100644 drivers/net/rmi_spi4/os_layer.c
 create mode 100644 drivers/net/rmi_spi4/os_layer.h
 create mode 100644 drivers/net/rmi_spi4/rmi_spi4.c
 create mode 100644 drivers/net/rmi_spi4/rmi_spi4.h
 create mode 100644 drivers/net/rmi_spi4/rmi_spi4_config.h
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_driver.c
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_driver.h
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_eth.c
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_eth.h
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_wrapper.c
 create mode 100644 drivers/net/rmi_spi4/rmi_vits_wrapper.h
 create mode 100644 drivers/net/rmi_spi4/vitesse_common.h
 create mode 100644 drivers/net/rmi_spi4/vitesse_highlevel.c
 create mode 100644 drivers/net/rmi_spi4/vitesse_highlevel.h
 create mode 100644 drivers/net/rmi_spi4/vitesse_io.c
 create mode 100644 drivers/net/rmi_spi4/vitesse_io.h
 create mode 100644 drivers/net/rmi_spi4/vitesse_phy_ctrl.c
 create mode 100644 drivers/net/rmi_spi4/vitesse_phy_ctrl.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 280f7de..ddcf874 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -26,6 +26,14 @@ menuconfig NETDEVICES
 # that for each of the symbols.
 if NETDEVICES
 
+config PHOENIX_SPI4
+	bool 'Support for on-chip SPI4 interfaces'
+	depends on RMI_PHOENIX
+	default y
+	---help---
+	  With the Vitesse SPI4 daughter card, this driver will abstract the
+	  20 SPI4 channels as Gigabit ethernet interfaces.
+
 config IFB
 	tristate "Intermediate Functional Block support"
 	depends on NET_CLS_ACT
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index de81c8a..ac4ce71 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -120,6 +120,7 @@ obj-$(CONFIG_ES3210) += es3210.o 8390.o
 obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_SB1250_MAC) += sb1250-mac.o
+obj-$(CONFIG_PHOENIX_SPI4) += rmi_spi4/
 obj-$(CONFIG_B44) += b44.o
 obj-$(CONFIG_FORCEDETH) += forcedeth.o
 obj-$(CONFIG_NE_H8300) += ne-h8300.o
diff --git a/drivers/net/rmi_spi4/Makefile b/drivers/net/rmi_spi4/Makefile
new file mode 100644
index 0000000..1839156
--- /dev/null
+++ b/drivers/net/rmi_spi4/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the rmi_spi4 ethernet driver
+#
+obj-$(CONFIG_PHOENIX_SPI4) += os_layer.o rmi_spi4.o rmi_vits_eth.o vitesse_highlevel.o \
+                            vitesse_io.o vitesse_phy_ctrl.o rmi_vits_driver.o  rmi_vits_wrapper.o
diff --git a/drivers/net/rmi_spi4/meigsii_reg.h b/drivers/net/rmi_spi4/meigsii_reg.h
new file mode 100644
index 0000000..924b714
--- /dev/null
+++ b/drivers/net/rmi_spi4/meigsii_reg.h
@@ -0,0 +1,458 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/************************************************************-*- mode: C -*-*/
+/*                                                                          */
+/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
+/*                           All Rights Reserved.                           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                            Copyright Notice:                             */
+/*                                                                          */
+/*  Unpublished rights reserved under the copyright laws of the             */
+/*  United States of America, other countries and international treaties.   */
+/*  The software is provided without fee.                                   */  
+/*  Permission to use,  copy, store, modify, disclose, transmit or          */
+/*  distribute the software is granted, provided that this copyright        */
+/*  notice must appear in any copy, modification, disclosure,               */
+/*  transmission or distribution of the software.                           */
+/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
+/*  trade secret and proprietary rights in the software.                    */
+/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
+/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
+/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                                                                          */
+/*  meigsii_reg.h  -- Definitions for Meigs-II chip internal registers.     */
+/*                                                                          */
+/*                                                                          */
+/* The general rule used for naming the registers is to prefix M2_ to the   */
+/* register name as described in the datasheet, using all capital letters.  */
+/* However, there are a few deviations, which are kept to a minimum and     */
+/* pointed out in the code using comments.                                  */
+/*                                                                          */
+/*                                                                          */
+/*                                                                          */
+/****************************************************************************/
+#ifndef _MEIGSII_REG_H
+#define _MEIGSII_REG_H
+
+
+/*
+ * Register Addressing:
+ *
+ * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+ * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ * |Block ID| Sub Block |    Register Address   |WS|
+ * +--------+--+--+--+--+--+--+--+--+--+--+--+--+--+
+ *
+ * The WS (Word Select) bit selects between the most or least
+ * significant 16 bits of the register. Which one it selects
+ * depends on the endian mode set in the Parallel Interface
+ * setup register.
+ */
+
+/* Meigs-II Block IDs */
+
+#define M2_BLK_MACS     1       /* Port - Sub Block: 0-10)                */
+#define M2_BLK_FIFO     2       /* FIFOs - Sub Block: 0 Ingress           */
+                                /*                    1 Egress            */
+#define M2_BLK_MIIM     3       /* MII Management - Sub Block: 0-1)       */
+#define M2_BLK_STAT     4       /* Statistics - Sub Block: 0-10)          */
+#define M2_BLK_SPI4     5       /* SPI-4.2 I/F - Sub Block: 0)            */
+#define M2_BLK_SYSTEM   7       /* System Regs - Sub Block: 1 Aggregator  */
+                                /*                          2 Ram BIST    */
+                                /*                          F Regs/CPU IF */
+
+
+/* Meigs-II Sub Block IDs */
+
+#define M2_SUBBLK_MIIM_0 0      /* MII Management Sub Block 0 */
+#define M2_SUBBLK_MIIM_1 1      /* MII Management Sub Block 1 */
+
+
+
+/* System Block Registers (Block ID: SYSTEM) */
+/* Subblock Control 0x0F */
+#define M2_SUBBLK_CTRL      0x0F
+/* Subblock Aggregator 0x01 */
+#define M2_SUBBLK_AGGR      0x01
+/* Subblock BIST 0x02 */
+#define M2_SUBBLK_BIST      0x02
+
+
+/* Block without subblocks -- currently only the value of '0' is used */
+#define M2_SUBBLK_NONE      0x00
+
+/* Two fifo's subblocks */
+#define M2_SUBBLK_INGRESS   0x00
+#define M2_SUBBLK_EGRESS    0x01
+
+/* 10x1G mac subblocks + 1x10G mac */
+#define M2_SUBBLK_MAC_10G   0x0A
+
+
+
+#define M2_CHIPID           0x00    /* Chip Identification */
+#define M2_BLADE_ID         0x01    /* Blade Identification */
+#define M2_SW_RESET         0x02    /* Global Software Reset */
+#define M2_IFACE_MODE       0x07    /* Interface Mode */
+#define M2_CRC_CNT          0x0A    /* CRC Error Count */
+#define M2_CRC_CFG          0x0B    /* CRC Configuration */
+#define M2E_SI_INSERT_BYTES 0x0F    /* SI insert bytes on read */
+#define M2_SI_TRANSFER_SEL  0x18    /* SI Transfer Select */
+#define M2_PLL_CLK_SPEED    0x19    /* Clock Speed Selection */
+#define M2_SYS_CLK_SELECT   0x1C    /* System Clock Select */
+#define M2_GPIO_CTRL        0x1D    /* GPIO Control */
+#define M2_GPIO_OUT         0x1E    /* GPIO Out */
+#define M2_GPIO_IN          0x1F    /* GPIO In */
+#define M2_CPU_TRANSFER_SEL 0x20    /* CPU Transfer Select */
+#define M2_LOCAL_DATA       0xFE    /* Local CPU Data */
+#define M2_LOCAL_STATUS     0xFF    /* Local CPU Status */
+
+/* System Block Registers (Block ID: SYSTEM) */
+/* Subblock Aggregator 0x01 */
+#define M2_AGGR_SETUP       0x00    /* Aggregator Setup */
+#define M2_PMAP_TABLE       0x01    /* Port Map Table */
+#define M2_MPLS_BIT0        0x08    /* MPLS Bit0 Position */
+#define M2_MPLS_BIT1        0x09    /* MPLS Bit1 Position */
+#define M2_MPLS_BIT2        0x0A    /* MPLS Bit2 Position */
+#define M2_MPLS_BIT3        0x0B    /* MPLS Bit3 Position */
+#define M2_MPLS_BITMASK     0x0C    /* MPLS Bit Mask */
+#define M2_PRE_BIT0POS      0x10    /* Preamble Bit0 Position */
+#define M2_PRE_BIT1POS      0x11    /* Preamble Bit1 Position */
+#define M2_PRE_BIT2POS      0x12    /* Preamble Bit2 Position */
+#define M2_PRE_BIT3POS      0x13    /* Preamble Bit3 Position */
+#define M2_PRE_ERR_CNT      0x14    /* Preamble Parity Error Counter */
+
+/* System Block Registers (Block ID: SYSTEM) */
+/* Subblock BIST 0x02 */
+
+#define M2_RAM_BIST_CMD     0x00    /* RAM BIST Command */
+#define M2_RAM_BIST_RESULT  0x01    /* RAM BIST Read Status & Read Result */
+
+/* System Block Registers (Block ID: SYSTEM) */
+/* Subblock BIST 0x02, Indirect BIST Register */
+
+#define M2_BIST_PORT_SELECT 0x00    /* BIST Port Select */
+#define M2_BIST_COMMAND     0x01    /* BIST Command */
+#define M2_BIST_STATUS      0x02    /* BIST Status */
+#define M2_BIST_ERR_CNT_LSB 0x03    /* BIST Error Count LSB */
+#define M2_BIST_ERR_CNT_MSB 0x04    /* BIST Error Count MSB */
+#define M2_BIST_ERR_SEL_LSB 0x05    /* BIST Error Select LSB */
+#define M2_BIST_ERR_SEL_MSB 0x06    /* BIST Error Select MSB */
+#define M2_BIST_ERROR_STATE 0x07    /* BIST Error State */
+#define M2_BIST_ERR_ADR0    0x08    /* BIST Error Address 0 */
+#define M2_BIST_ERR_ADR1    0x09    /* BIST Error Address 1 */
+#define M2_BIST_ERR_ADR2    0x0A    /* BIST Error Address 2 */
+#define M2_BIST_ERR_ADR3    0x0B    /* BIST Error Address 3 */
+
+/* FIFO Block Registers (Block ID: FIFO) */
+/* Subblock Ingress 0x00 */
+/* Subblock Egress 0x01 */
+/* These values are actually base addresses where the actual port
+ * address is obtained by adding the port # (0-9) to the address
+ */
+
+#define M2_TEST             0x00    /* Mode & Test */
+#define M2_TOP_BOTTOM       0x10    /* FIFO Buffer Top & Bottom */
+#define M2_TAIL             0x20    /* Write Pointer */
+#define M2_HEAD             0x30    /* Read Pointer */
+#define M2_HIGH_LOW_WM      0x40    /* Flow Control Water Marks */
+#define M2_CT_THRHLD        0x50    /* Cut Through Threshold */
+#define M2_FIFO_DROP_CNT    0x60    /* Drop & CRC Error Counter */
+#define M2_DEBUG_BUF_CNT    0x70    /* Input Side Debug Counter */
+
+/* FIFO Block Registers (Block ID: FIFO) */
+/* Subblock Ingress 0x00 */
+/* Subblock Egress 0x01 */
+
+#define M2_TRAFFIC_SHAPER_BUCKET0  0x0A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET1  0x1A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET2  0x2A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET3  0x3A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET4  0x4A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET5  0x5A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET6  0x6A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET7  0x7A    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET8  0x0B    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET9  0x1B    /* Traffic Shaper Bucket Setting */
+#define M2_TRAFFIC_SHAPER_BUCKET10 0x2B    /* Traffic Shaper Bucket Setting */
+
+#define M2_TRAFFIC_SHAPER_CTRL     0x3B    /* Traffic Shaper Control Register */
+
+
+#define M2_SRAM_ADR         0x0E    /* SRAM Address in FIFO Buffer */
+#define M2_SRAM_WR_STRB     0x1E    /* SRAM Write Storage Block */
+#define M2_SRAM_RD_STRB     0x2E    /* SRAM Read Storage Block */
+#define M2_SRAM_DATA_0      0x3E    /* Bytes  3-0 of Data in Block */
+#define M2_SRAM_DATA_1      0x4E    /* Bytes  7-4 of Data in Block */
+#define M2_SRAM_DATA_2      0x5E    /* Bytes 11-8 of Data in Block */
+#define M2_SRAM_DATA_3      0x6E    /* Bytes 15-12 of Data in Block */
+#define M2_DATA_BLK_TYPE    0x7E    /* Data Block Type */
+
+
+/* FIFO Block Registers (Block ID: FIFO) */
+/* Subblock Ingress 0x00 */
+
+#define M2_ING_CONTROL      0x0F    /* Ingress Control */
+
+/* FIFO Block Registers (Block ID: FIFO) */
+/* Subblock Egress 0x01 */
+
+#define M2_EGR_CONTROL      0x0F    /* Egress Control */
+
+/* FIFO Block Registers (Block ID: FIFO) */
+/* Subblock Ingress 0x00 */
+/* Subblock Egress 0x01 */
+
+#define M2_AGE_TIMER        0x1F    /* Age Timer */
+#define M2_AGE_INC          0x2F    /* Age Increment */
+#define M2_DEBUG_OUT        0x3F    /* Output Side Debug Counter Control */
+#define M2_DEBUG_CNT        0x4F    /* Output Side Debug Counter */
+
+
+/* SPI-4.2 Host Interface Block Registers (Block ID: SPI4) */
+/* Subblock SPI-4.2 Interface 0x00 */
+
+#define M2_SPI4_MISC        0x00    /* Miscellaneous */
+#define M2_SPI4_STATUS      0x01    /* CML Status */
+#define M2_SPI4_ING_SETUP0  0x02    /* Ingress Status Channel Setup */
+#define M2_SPI4_ING_SETUP1  0x03    /* Ingress Data Training Setup */
+#define M2_SPI4_ING_SETUP2  0x04    /* Ingress Data Burst Sizes Setup */
+#define M2_SPI4_EGR_SETUP0  0x05    /* Egress Status Channel Setup */
+#define M2_SPI4_DBG_CNT     0x10    /* Debug Counters (Add Port # 0 - 9) */
+#define M2_SPI4_DBG_SETUP   0x1A    /* Counters Setup */
+
+#define M2_SPI4_TEST        0x20    /* Test Setup */
+#define M2_TPGEN_UP0        0x21    /* Test Pattern Generator User Pattern0 */
+#define M2_TPGEN_UP1        0x22    /* Test Pattern Generator User Pattern1 */
+#define M2_TPCHK_UP0        0x23    /* Test Pattern Checker User Pattern0 */
+#define M2_TPCHK_UP1        0x24    /* Test Pattern Checker User Pattern1 */
+#define M2_TPSAM_P0         0x25    /* Sampled Pattern 0 */
+#define M2_TPSAM_P1         0x26    /* Sampled Pattern 1 */
+#define M2_TPERR_CNT        0x27    /* Pattern Checker Error Counter */
+#define M2_SPI4_STICKY      0x30    /* Sticky Bits */
+
+#define M2_SPI4_DBG_INH     0x31    /* MeigsII Core Egress & Ingress Inhibit */
+#define M2_SPI4_DBG_STATUS  0x32    /* Sampled Ingress Status Channel */
+#define M2_SPI4_DBG_GRANT   0x33    /* Ingress Status Channel Granted
+                                       Credit Value */
+
+/* MAC Block Registers (Block ID: MAC) */
+/* Subblock 10 GbE 0x0A */
+
+#define M2_MISC_10G          0x00    /* Miscellaneous 10GbE Setup */
+#define M2_PAUSE             0x01    /* Pause */
+#define M2_MAX_LEN           0x02    /* Max Length */
+#define M2_MAC_HIGH_ADDR     0x03    /* MAC High Address */
+#define M2_MAC_LOW_ADDR      0x04    /* MAC Low Address */
+#define M2_NORMALIZER        0x05    /* Normalizer Control */
+#define M2_STICKY_RX         0x06    /* RX Debug */
+#define M2_DENORM            0x07    /* Denormalizer Control */
+#define M2_STICKY_TX         0x08    /* TX Debug */
+#define M2_MAC_RXHIGH        0x0A    /* XGMII Lane 0-3 Debug */
+#define M2_MAC_RXLOW         0x0B    /* XGMII Lane 4-7 Debug */
+#define M2_MAC_TX_STICKY     0x0C    /* MAC TX State Sticky Debug */
+#define M2_MAC_TX_RUNNING    0x0D    /* MAC TX State Running Debug */
+#define M2_TX_ABORT_AGE      0x14    /* Aged TX Frames Discards Counter */
+#define M2_TX_ABORT_SHORT    0x15    /* Short TX Frames Discards Counter */
+#define M2_TX_ABORT_TAXI     0x16    /* Taxi Error TX Frames Discards 
+                                        Counter */
+#define M2_TX_ABORT_UNDERRUN 0x17    /* TX Underrun Abort Discards Counter */
+#define M2_TX_DENORM_DISCARD 0x18    /* TX Denormalizer Discards Counter */
+
+#define M2_XAUI_STAT_A       0x20    /* XAUI Status Register A */
+#define M2_XAUI_STAT_B       0x21    /* XAUI Status Register B */
+#define M2_XAUI_STAT_C       0x22    /* XAUI Status Register C */
+#define M2_XAUI_CONF_A       0x23    /* XAUI Configuration Register A */
+#define M2_XAUI_CONF_B       0x24    /* XAUI Configuration Register B */
+#define M2_XAUI_CODE_GRP_CNT 0x25    /* XAUI Code Group Error Counter */
+#define M2_XAUI_CONF_TEST_A  0x26    /* XAUI Test Register A */
+#define M2_PDERRCNT          0x27    /* XAUI Test Register B */
+
+/* MAC Block Registers (Block ID: MAC) */
+/* Subblock Tri-Speed MACs 0x00-0x09 */
+
+#define M2_MODE_CFG          0x00    /* Mode Configuration */
+#define M2_PAUSE_CFG         0x01    /* Pause Configuration */
+#define M2_MAXLEN_CFG        0x02    /* Max Length Configuration */
+#define M2_MAC_ADDR_HIGH_CFG 0x03    /* MAC Address Configuration - High */
+#define M2_MAC_ADDR_LOW_CFG  0x04    /* MAC Address Configuration - Low */
+/* Following #define is duplicate of 10 GbE version, so redefine the name
+ * to avoid namespace collision, although, the value is equivalent, so
+ * it's benign to use either #define
+ */
+#define M2_TRI_NORMALIZER    0x05    /* Tri-Speed MAC Normalizer */
+#define M2_PCS_STATUS        0x06    /* PCS Status */
+#define M2_PCS_STATUS_DBG    0x07    /* PCS Status Debug */
+#define M2_PCS_CTRL          0x08    /* PCS Control */
+#define M2_PCS_CONFIG        0x09    /* PCS Configuration */
+#define M2_STICK_BIT         0x0A    /* Sticky Bits */
+#define M2_DEV_SETUP         0x0B    /* Tri-Speed MAC Clock/Reset Setup */
+#define M2_DROP_CNT          0x0C    /* Drop Counter */
+#define M2_PORT_POS          0x0D    /* Preamble Port Position */
+#define M2_SERDES_CONF       0x0F    /* SerDes Configuration */
+#define M2_SERDES_TEST       0x10    /* SerDes Test */
+#define M2_SERDES_STAT       0x11    /* SerDes Status */
+#define M2_SERDES_COM_CNT    0x12    /* SerDes Comma Detect Counter */
+
+
+#define M2E_TRI_MULTI_DBG    0x0E    /* Multidebug register */
+
+
+/* M2_DENORM is already defined as 0x07 for 10 GbE, but it's 0x15 for
+ * tri-speed macs.  This is an unfortunate name collision in the manual,
+ * so define it as M2_TRI_DENORM for tri-speed macs. Unfortunately, it is
+ * not benign to mix up the tri-speed and 10G #defines!!!
+ */
+
+#define M2_TRI_DENORM        0x15    /* Frame Denormalization */
+
+#define M2E_TX_IFG           0x18    /* Tx Inter Frame Gap configuration */
+#define M2E_ADV_HDX_CFG      0x19    /* Advance Half Duplex configuration */
+
+
+/* Only Campbell-I have the following GFP-T registers */
+#define C1_GFPT_CONFIG       0x1A    /* GFP-T block configuration */
+#define C1_GFPT_CLIENT1      0x1B    /* Client signal configuration */
+#define C1_GFPT_CLIENT2      0x1C    /* Rate adaptation configuration */
+#define C1_GFPT_BLOCK_CODE   0x1D    /* GFP-T block encode */
+#define C1_GFPT_FRM_LEN      0x1E    /* GFP-T Frame length */
+#define C1_GFPT_HEAD_ENA     0x1F    /* GFP-T header expectation/generation */
+#define C1_GFPT_BIT_ERR_CORR  0x20   /* Bit error correction configuration */
+#define C1_GFPT_BIT_ERR_POS1  0x21   /* Bit error insertion position 1 */
+#define C1_GFPT_BIT_ERR_POS2  0x22   /* Bit error insertion position 2 */
+#define C1_GFPT_BIT_ERR_ONCE  0x23   /* Force bit error insertion once or continuously */
+#define C1_GFPT_BIT_ERR_FORCE 0x24   /* Force bit error insert at pos1 and/or pos2 */
+#define C1_GFPT_STATUS       0x25    /* GFPT Status */
+#define C1_GFPT_PCS_RX       0x26    /* PCS RX Setup */
+#define C1_GFPT_PCS_TX       0x27    /* PCS TX Setup */
+
+
+/* Statistics Block Registers (Block ID: STATISTICS) */
+/* Subblock Tri-Speed MACs 0x00-0x09 */
+
+#define M2_RX_IN_BYTES       0x00    /* RX # of Nibbles or Bytes */
+#define M2_RX_SYMBOL_CARRIER 0x01    /* RX # of Symbol Errors, No Collisions */
+#define M2_RX_PAUSE          0x02    /* RX # of Pause Control Frames */
+#define M2_RX_UNSUP_OPCODE   0x03    /* RX # of Unsupported Opcode Frames */
+#define M2_RX_OK_BYTES       0x04    /* RX # of Bytes in Valid Frames */
+#define M2_RX_BAD_BYTES      0x05    /* RX # of Bytes in Error Frames */
+#define M2_RX_UNICAST        0x06    /* RX # of Valid Unicast Frames */
+#define M2_RX_MULTICAST      0x07    /* RX # of Valid Multicast Frames */
+#define M2_RX_BROADCAST      0x08    /* RX # of Valid Broadcast Frames */
+#define M2_RX_CRC            0x09    /* RX # of CRC Error Only Frames */
+#define M2_RX_ALIGNMENT      0x0A    /* RX # of Alignment Error Frames */
+#define M2_RX_UNDERSIZE      0x0B    /* RX # of Undersize Well Formed Frames */
+#define M2_RX_FRAGMENTS      0x0C    /* RX # of Undersize with CRC Error */
+#define M2_RX_IN_RANGE_LENGTH_ERROR 0x0D    /* RX # of Frames with Legal
+                                               Lengths but Mismatch */
+#define M2_RX_OUT_OF_RANGE_ERROR    0x0E    /* RX # of Frames with Illegal
+                                               Length Field */
+
+/* NOTE: Names for RX_SIZE_ and TX_SIZE_ registers deviate from manual names
+ * for typing convenience
+ */
+
+#define M2_RX_OVERSIZE       0x0F    /* RX # of Oversize Well Formed Frames */
+#define M2_RX_JABBERS        0x10    /* RX # of Oversize with CRC Error */
+#define M2_RX_SIZE_64        0x11    /* RX # of 64 Byte Frames */
+#define M2_RX_SIZE_65        0x12    /* RX # of 65-127 Byte Frames */
+#define M2_RX_SIZE_128       0x13    /* RX # of 128-255 Byte Frames */
+#define M2_RX_SIZE_256       0x14    /* RX # of 256-511 Byte Frames */
+#define M2_RX_SIZE_512       0x15    /* RX # of 512-1023 Byte Frames */
+#define M2_RX_SIZE_1024      0x16    /* RX # of 1024-1518 Byte Frames */
+#define M2_RX_SIZE_1519      0x17    /* RX # of > 1518 Byte Allowed Frames */
+
+
+#define M2_TX_OUT_BYTES      0x18    /* TX # of Bytes (Good, Bad, Framing) */
+#define M2_TX_PAUSE          0x19    /* TX # of Pause Control Frames */
+#define M2_TX_OK_BYTES       0x1A    /* TX # of Bytes Successful */
+#define M2_TX_UNICAST        0x1B    /* TX # of Unicast Frames */
+#define M2_TX_MULTICAST      0x1C    /* TX # of Multicast Frames */
+#define M2_TX_BROADCAST      0x1D    /* TX # of Broadcast Frames */
+#define M2_TX_MULTIPLE_COLL  0x1E    /* TX # of Frames Successful After
+                                        Multiple Collisions */
+#define M2_TX_LATE_COL       0x1F    /* TX # of Late Collisions Detected */
+#define M2_TX_XCOLL          0x20    /* TX # of Frames Lost Due to 
+                                        Excessive Collisions */
+#define M2_TX_DEFER          0x21    /* TX # of Frames Deferred on First Try */
+#define M2_TX_XDEFER         0x22    /* TX # of Frames Sent with Excessive
+                                        Deferral*/
+#define M2_TX_CSENSE         0x23    /* TX # of Carrier Sense Error at End
+                                        of Frame Transmission*/
+#define M2_TX_SIZE_64        0x24    /* TX # of 64 Byte Frames */
+#define M2_TX_SIZE_65        0x25    /* TX # of 65-127 Byte Frames */
+#define M2_TX_SIZE_128       0x26    /* TX # of 128-255 Byte Frames */
+#define M2_TX_SIZE_256       0x27    /* TX # of 256-511 Byte Frames */
+#define M2_TX_SIZE_512       0x28    /* TX # of 512-1023 Byte Frames */
+#define M2_TX_SIZE_1024      0x29    /* TX # of 1024-1518 Byte Frames */
+#define M2_TX_SIZE_1519      0x2A    /* TX # of > 1518 Byte Allowed Frames */
+#define M2_TX_SINGLE_COL     0x2B    /* TX # of Single Collision Transmits */
+#define M2_TX_BACKOFF2       0x2C    /* TX # of Frames 2 backoff/collision */
+#define M2_TX_BACKOFF3       0x2D    /* TX # of Frames 3 backoff/collision */
+#define M2_TX_BACKOFF4       0x2E    /* TX # of Frames 4 backoff/collision */
+#define M2_TX_BACKOFF5       0x2F    /* TX # of Frames 5 backoff/collision */
+#define M2_TX_BACKOFF6       0x30    /* TX # of Frames 6 backoff/collision */
+#define M2_TX_BACKOFF7       0x31    /* TX # of Frames 7 backoff/collision */
+#define M2_TX_BACKOFF8       0x32    /* TX # of Frames 8 backoff/collision */
+#define M2_TX_BACKOFF9       0x33    /* TX # of Frames 9 backoff/collision */
+#define M2_TX_BACKOFF10      0x34    /* TX # of Frames 10 backoff/collision */
+#define M2_TX_BACKOFF11      0x35    /* TX # of Frames 11 backoff/collision */
+#define M2_TX_BACKOFF12      0x36    /* TX # of Frames 12 backoff/collision */
+#define M2_TX_BACKOFF13      0x37    /* TX # of Frames 13 backoff/collision */
+#define M2_TX_BACKOFF14      0x38    /* TX # of Frames 14 backoff/collision */
+#define M2_TX_BACKOFF15      0x39    /* TX # of Frames 15 backoff/collision */
+#define M2_TX_UNDERRUN       0x3A    /* TX # of FIFO Underrun Frame Drops */
+
+
+#define M2_RX_XGMII_PROT_ERR 0x3B    /* XGMII_RX Interface Protocol Errors */
+                                     /* NOTE: Only Available on 10 GbE MAC */
+
+#define M2_RX_IPG_SHRINK     0x3C    /* IPG Shrink Detected Counter */
+
+#define M2_STAT_STICKY1G     0x3E    /* Tri-Speed MAC Sticky Bits */
+#define M2_STAT_STICKY10G    0x3E    /* 10 GbE MAC Sticky Bits */
+
+#define M2_STAT_INIT         0x3F    /* Clears Statistics in all Tri-Speed
+                                        or 10 GbE depending on subblock */
+
+/* MII Management Block Registers (Block ID: MIIM) */
+/* Subblock Management #0-1 0x00-0x01 */
+
+#define M2_MIIM_STATUS       0x00    /* MII-M Status */
+#define M2_MIIM_CMD          0x01    /* MII-M Command */
+#define M2_MIIM_DATA         0x02    /* MII-M Data */
+#define M2_MIIM_PRESCALE     0x03    /* MII-M MDC Pre-Scale */
+
+
+/*************   Most oftern used bits and bitmasks       ******************** */
+#define M2_NORMALIZER_BIT_NLE    0x00000004
+#define M2_NORMALIZER_BIT_NH     0x00000002
+#define M2_NORMALIZER_BIT_PH     0x00000001
+
+
+#define M2_DENORMAL_BIT_EXP_NH   0x00000002
+#define M2_DENORMAL_BIT_ECP_PH   0x00000001
+
+
+#endif /* _MEIGSII_REG_H */
+/****************************************************************************/
+/*                                                                          */
+/*  End of file.                                                            */
+/*                                                                          */
+/****************************************************************************/
diff --git a/drivers/net/rmi_spi4/os_layer.c b/drivers/net/rmi_spi4/os_layer.c
new file mode 100644
index 0000000..432693b
--- /dev/null
+++ b/drivers/net/rmi_spi4/os_layer.c
@@ -0,0 +1,91 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/gfp.h>
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#include "os_layer.h"
+
+#define PHNX_RX_BUF_SIZE (MAX_FRAME_SIZE+SPI4_BYTE_OFFSET+MAC_PREPAD+ \
+		                MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
+
+void os_free_buffer(char *addr)
+{
+	kfree(addr);
+	return;
+}
+
+char* os_malloc(unsigned long size)
+{
+	return	kmalloc(size, GFP_KERNEL);
+}
+
+char* os_malloc_buffer()
+{
+	return  kmalloc(PHNX_RX_BUF_SIZE, GFP_KERNEL);
+}
+
+void* os_cacheline_aligned_kmalloc(int size)
+{
+
+	void *buf = kmalloc(size+SMP_CACHE_BYTES, GFP_KERNEL);
+	if (buf){
+		buf = (void *)(CACHELINE_ALIGNED_ADDR(
+			(unsigned long)buf+SMP_CACHE_BYTES));
+	}
+	return buf;
+}
+
+struct sk_buff *os_alloc_skb(void)
+{
+	int offset=0;
+	struct sk_buff *skb = __dev_alloc_skb(PHNX_RX_BUF_SIZE, GFP_KERNEL);
+
+	if (!skb) {
+		return NULL;
+	}
+
+	/* align the data to the next cache line */
+	offset = ((unsigned long)skb->data + SMP_CACHE_BYTES) &
+		~(SMP_CACHE_BYTES - 1);
+	skb_reserve(skb, (offset - (unsigned long)skb->data));
+
+	return skb;
+}
+
+void os_free(struct sk_buff *skb)
+{
+	dev_kfree_skb_irq(skb);
+
+	return;
+}
diff --git a/drivers/net/rmi_spi4/os_layer.h b/drivers/net/rmi_spi4/os_layer.h
new file mode 100644
index 0000000..9d4d7da
--- /dev/null
+++ b/drivers/net/rmi_spi4/os_layer.h
@@ -0,0 +1,51 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_OS_LAYER_H
+#define _ASM_RMI_OS_LAYER_H
+
+#include "rmi_spi4_config.h"
+
+extern char* os_malloc(unsigned long size);
+
+extern char* os_malloc_buffer(void);
+
+extern void* os_cacheline_aligned_kmalloc(int size);
+
+extern struct sk_buff *os_alloc_skb(void);
+
+extern void os_free(struct sk_buff *skb);
+
+extern void os_free_buffer(char *addr);
+
+#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+
+#endif /* _ASM_RMI_OS_LAYER_H */
diff --git a/drivers/net/rmi_spi4/rmi_spi4.c b/drivers/net/rmi_spi4/rmi_spi4.c
new file mode 100644
index 0000000..7f5b73c
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_spi4.c
@@ -0,0 +1,844 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/cache.h>
+
+#include "os_layer.h"
+#include "rmi_spi4.h"
+#include "rmi_spi4_config.h"
+#include <asm/rmi/phoenix_mac.h>
+#include <asm/rmi/msgring.h>
+#include "rmi_vits_driver.h"
+
+#define CLEAR_INT 0xf
+#define CLEAR_TX_STATUS 0x0f
+#define CLEAR_RX_STATUS 0x1f
+#define MAX_BUCKET 64
+#define RMI_SPI4_MAX_THREADS 32
+#define RMI_SPI4_DEBUG 0
+#define MAX_NUM_MSGRNG_STN_CC   128
+/*this array contains the freeback bucket id for the corresponding ports*/
+int port_buk_map[RMI_SPI4_MAX_THREADS];
+
+unsigned long g_dip4_error[RMI_SPI4_MAX_THREADS];
+extern cpumask_t cpu_online_map;
+
+extern int xlr_loader_support;
+extern int xlr_loader_sharedcore;
+
+spi4_driver_data* spi4_data[TOTAL_SPI4];
+
+static void spi4_msgring_handler(int 	bucket, 
+					int 	size, 
+					int 	code, 
+					int 	stid, 
+					struct msgrng_msg *msg, 
+					void 	*data);
+
+extern void rx_indication(int port, char* addr, int len);
+extern void tx_complete(int port, char* addr);
+
+extern uint32_t dev_tree_en;
+extern int fdt_get_spi4_bucket_conf(int instance, char buckets[], int bklen, char credits[], int crlen);
+
+#if RMI_SPI4_DEBUG
+void spi4_init_read_counter(unsigned int	*mmio)
+{
+	mmio[0x236] = 0; /* read count0 of debugcount0 */
+	mmio[0x237] = 0; /* read count1 of debugcount0 */
+
+	mmio[0x23a] = 0; /* read count0 of debugcount1 */
+	mmio[0x23b] = 0; /* read count1 of debugcount1 */
+
+	return;
+}
+
+void spi4_write_select(unsigned int  *mmio,int write_select,	int bit_no)
+{
+	long value;
+	value = 1<<bit_no;
+	printk("write_select=%d, bit no=%d,value=0x%lx\n", 
+		write_select, bit_no,value);
+	switch(write_select){
+	case 0:
+		mmio[0x234] = value;
+		break;
+	case 1:
+		mmio[0x235] = value;
+		break;
+	case 2:
+		mmio[0x238] = value;
+		break;
+	case 3:
+		mmio[0x239] = value;
+		break;
+	default:
+		printk("wrong write select\n");
+	}
+	return;
+}
+
+void spi4_print_debug_value(unsigned int  *mmio)
+{
+
+	printk(" Read counter0 = %d\n", mmio[0x236]);
+	printk(" Read counter1 = %d\n", mmio[0x237]);
+	printk(" Read counter3 = %d\n", mmio[0x23a]);
+	printk(" Read counter4 = %d\n", mmio[0x23b]);
+
+	return;
+}
+
+#endif
+/*******************************************************************************
+*
+* Function name	:	spi4_configure_pde_spray_mode
+* Input		:	spi4 slot
+* Description	:	This function will program the PDE for the given 
+*	spi4 slot. Based on the cpu mask, it will check the enabled cpu and 
+*	then calculates the bucket mapp, with this bucket map it will program
+*	all the 4 classes of PDE .
+*	
+* RETURNS: void
+*******************************************************************************/
+static int spi4_configure_pde_spray_mode(uint32 slot)
+{
+
+	int i, cpu=0, bucket=0;
+	__u64 bucket_map = 0;
+	char buckets[MAX_NUM_MSGRNG_STN_CC], credits[MAX_NUM_MSGRNG_STN_CC];
+
+	spi4_driver_data*   driver_data;
+	unsigned int        *mmio;
+
+	driver_data = spi4_data[slot];
+	mmio = driver_data->mmio;
+
+
+	for (i=0;i<RMI_SPI4_MAX_THREADS;i++) {
+		if (cpu_isset(i, cpu_online_map)) {
+			cpu = cpu_logical_map(i);
+			bucket = ((cpu >> 2)<<3)|(cpu & 0x03);
+			bucket_map |= (1ULL << bucket);
+		}
+	}
+	phoenix_write_reg(mmio, R_PDE_CLASS_0, (bucket_map & 0xffffffff));
+	phoenix_write_reg(mmio, R_PDE_CLASS_0+1, 
+				((bucket_map>>RMI_SPI4_MAX_THREADS) & 0xffffffff));
+
+	phoenix_write_reg(mmio, R_PDE_CLASS_1, (bucket_map & 0xffffffff));
+	phoenix_write_reg(mmio, R_PDE_CLASS_1+1, 
+				((bucket_map>>RMI_SPI4_MAX_THREADS) & 0xffffffff));
+
+	phoenix_write_reg(mmio, R_PDE_CLASS_2, (bucket_map & 0xffffffff));
+	phoenix_write_reg(mmio, R_PDE_CLASS_2+1,
+			 ((bucket_map>>RMI_SPI4_MAX_THREADS) & 0xffffffff));
+
+	phoenix_write_reg(mmio, R_PDE_CLASS_3, (bucket_map & 0xffffffff));
+	phoenix_write_reg(mmio, R_PDE_CLASS_3+1, 
+			((bucket_map>>RMI_SPI4_MAX_THREADS) & 0xffffffff));
+
+	for(i = 0; i<RMI_SPI4_MAX_THREADS; i++){
+		port_buk_map[i] = ((i>>2)<<3)|(i&0x03);
+	}
+
+	if(dev_tree_en) {
+		if(fdt_get_spi4_bucket_conf(slot, buckets, XLR_MAX_SPI4_CHANNEL + 2, 
+							credits, MAX_NUM_MSGRNG_STN_CC) < 0)
+			printk("Erron in spi4 bucket get\n");
+
+		for(i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
+			phoenix_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE+i, buckets[i]);
+
+		phoenix_write_reg(mmio, R_XGS_JFR_BUCKET_SIZE, buckets[i++]);
+		phoenix_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE, buckets[i++]);
+
+		for(i=0;i<MAX_NUM_MSGRNG_STN_CC;i++) 
+			phoenix_write_reg(mmio, R_CC_CPU0_0 + i, credits[i]);
+
+		return SPI4_CONFIG_PDE_SUCCESS;
+	}
+
+	if(slot == SPI4_0){
+		for(i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
+			phoenix_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE+i, 
+			bucket_sizes.bucket[MSGRNG_STNID_XGS0_TX+i]);
+		}
+		phoenix_write_reg(mmio, R_XGS_JFR_BUCKET_SIZE, 
+			bucket_sizes.bucket[MSGRNG_STNID_XMAC0JFR]);
+
+		phoenix_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE, 
+			bucket_sizes.bucket[MSGRNG_STNID_XMAC0RFR]);
+
+		for(i=0;i<128;i++){
+			phoenix_write_reg(mmio, R_CC_CPU0_0 + i, 
+			cc_table_xgs_0.counters[i>>3][i&0x07]);
+		}
+	}
+	else if(slot == SPI4_1){
+		for(i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
+			phoenix_write_reg(mmio, R_XGS_TX0_BUCKET_SIZE+i, 
+				bucket_sizes.bucket[MSGRNG_STNID_XGS1_TX+i]);
+
+		phoenix_write_reg(mmio, R_XGS_JFR_BUCKET_SIZE, 
+			bucket_sizes.bucket[MSGRNG_STNID_XMAC1JFR]);
+
+		phoenix_write_reg(mmio, R_XGS_RFR_BUCKET_SIZE, 
+			bucket_sizes.bucket[MSGRNG_STNID_XMAC1RFR]);
+
+		for(i=0;i<128;i++)
+			phoenix_write_reg(mmio, R_CC_CPU0_0 + i, 
+				cc_table_xgs_1.counters[i>>3][i&0x07]);
+	}
+	return SPI4_CONFIG_PDE_SUCCESS;
+}
+
+static void spi4_free_spill_memory(spi4_driver_data*   driver_data)
+{
+	if(driver_data->frin_spill != NULL)
+		kfree(driver_data->frin_spill);
+	
+	if(driver_data->frout_spill != NULL)
+		kfree(driver_data->frout_spill);
+	
+	if(driver_data->class_0_spill != NULL)
+		kfree(driver_data->class_0_spill);
+
+	if(driver_data->class_1_spill != NULL)
+		kfree(driver_data->class_1_spill);
+
+	if(driver_data->class_2_spill != NULL)
+		kfree(driver_data->class_2_spill);
+
+	if(driver_data->class_3_spill != NULL)
+		kfree(driver_data->class_3_spill);
+
+	return;
+}	
+
+static void* config_spill(unsigned int *mmio, int reg_start_0,
+		int 	reg_start_1,
+		int 	reg_size, 
+		int 	size,
+		void**	spill_orig)
+{
+
+	__u32 spill_size = CACHELINE_ALIGNED_ADDR(size);
+	void *spill = os_cacheline_aligned_kmalloc(spill_size);
+	__u64 phys_addr = 0;
+
+	if (!spill) {
+		return NULL;
+	}
+	*spill_orig = spill;
+	phys_addr = virt_to_phys(spill);
+	phoenix_write_reg(mmio, reg_start_0, ((phys_addr >> 5) & 0xffffffff));
+
+	phoenix_write_reg(mmio, reg_start_1, ((phys_addr >> 37) & 0x07));
+
+	phoenix_write_reg(mmio, reg_size, spill_size);
+
+	return spill;
+}
+
+/*******************************************************************************
+* Function name :       spi4_configure_spill_memory
+* Input         :
+* Description   :       This function programs the freein, free out and class0, 
+*	class1, class2 spill memory
+* RETURNS       :       void
+*******************************************************************************/
+
+static int spi4_configure_spill_memory(uint32 slot)
+{
+
+	spi4_driver_data*   driver_data;
+	unsigned int        *mmio;
+
+	driver_data = spi4_data[slot];
+	mmio = driver_data->mmio;
+
+	if(config_spill(mmio,R_REG_FRIN_SPILL_MEM_START_0,
+			R_REG_FRIN_SPILL_MEM_START_1,R_REG_FRIN_SPILL_MEM_SIZE,
+			MAX_FRIN_SPILL * sizeof(struct fr_desc),
+			&driver_data->frin_spill) == NULL){
+		return SPI4_CONFIG_SPILL_FAIL ;
+	}
+
+	if(config_spill(mmio, R_FROUT_SPILL_MEM_START_0,
+			R_FROUT_SPILL_MEM_START_1,
+			R_FROUT_SPILL_MEM_SIZE,
+			(2* MAX_FROUT_SPILL * sizeof(struct fr_desc)),
+			&driver_data->frout_spill) == NULL){
+			spi4_free_spill_memory(driver_data);
+		return SPI4_CONFIG_SPILL_FAIL ;	
+	}
+
+	if(config_spill(mmio, R_CLASS0_SPILL_MEM_START_0,
+			R_CLASS0_SPILL_MEM_START_1,
+			R_CLASS0_SPILL_MEM_SIZE,
+			MAX_CLASS_0_SPILL * sizeof(union rx_tx_desc),
+			&driver_data->class_0_spill) == NULL){
+			spi4_free_spill_memory(driver_data);
+		return SPI4_CONFIG_SPILL_FAIL;
+	}
+
+	if(config_spill(mmio,R_CLASS1_SPILL_MEM_START_0,
+			R_CLASS1_SPILL_MEM_START_1,
+			R_CLASS1_SPILL_MEM_SIZE,
+			MAX_CLASS_1_SPILL * sizeof(union rx_tx_desc),
+			&driver_data->class_1_spill) == NULL){
+			spi4_free_spill_memory(driver_data);
+		return SPI4_CONFIG_SPILL_FAIL ;
+	}
+
+
+	if(config_spill(mmio,R_CLASS2_SPILL_MEM_START_0,
+			R_CLASS2_SPILL_MEM_START_1,
+			R_CLASS2_SPILL_MEM_SIZE,
+			MAX_CLASS_2_SPILL * sizeof(union rx_tx_desc),
+			&driver_data->class_2_spill) == NULL){
+			spi4_free_spill_memory(driver_data);
+		return SPI4_CONFIG_SPILL_FAIL ;
+	}
+
+	if( config_spill(mmio, R_CLASS3_SPILL_MEM_START_0,
+			R_CLASS3_SPILL_MEM_START_1,
+			R_CLASS3_SPILL_MEM_SIZE,
+			MAX_CLASS_3_SPILL * sizeof(union rx_tx_desc),
+			&driver_data->class_3_spill) == NULL){
+			spi4_free_spill_memory(driver_data);
+		return SPI4_CONFIG_SPILL_FAIL ;
+	}
+
+	return SPI4_CONFIG_SPILL_SUCCESS;
+}
+
+
+/*******************************************************************************
+*
+* Function name :       spi4_register_msgrng_handler
+* Input         :       spi4 slot
+* Description   :       This function will register message ring handler for the 
+*       given spi4. Registered function will be called whenever msg will be send 
+*	by the spi4. 
+* RETURNS	: 	int
+*			1 - fail
+*			0 - success
+*******************************************************************************/
+
+static int spi4_register_msgrng_handler(uint32 slot)
+{
+
+	if(slot == SPI4_0){
+		if (register_msgring_handler(TX_STN_XGS_0, 
+		spi4_msgring_handler, NULL)) {
+			return SPI4_REGISTER_MSGRING_FAIL;
+		}
+	}	
+	else if(slot == SPI4_1){
+		if (register_msgring_handler(TX_STN_XGS_1, 
+		spi4_msgring_handler, NULL)) {
+			return SPI4_REGISTER_MSGRING_FAIL;
+		}
+	}
+	else{
+		/*invalid spi4*/
+		return SPI4_SLOT_ERROR;
+	}
+
+	return SPI4_REGISTER_MSGRING_SUCESS;
+}
+
+static int spi4_validate_config_params(void)
+{
+	if(XLR_TOTAL_CHANNELS > XLR_MAX_SPI4_CHANNEL){
+		printk("invalid total channels\n");
+		return SPI4_CALENDER_LEN_ERROR ;
+	}
+	if(XLR_SPI4_TX_MAXBURST1 > XLR_MAX_TX_BURST){
+		printk("invalid TX max burst1\n");
+		return SPI4_TX_MAXBURST1_ERROR;
+	}
+	if(XLR_SPI4_TX_MAXBURST2 > XLR_MAX_TX_BURST){
+		printk("invalid TX max burst2\n");
+		return SPI4_TX_MAXBURST2_ERROR;
+	}
+	if(XLR_SPI4_RX_MAXBURST1 > XLR_MAX_RX_BURST){
+		printk("invalid RX max burst1\n");
+		return SPI4_RX_MAXBURST1_ERROR;
+	}
+	if(XLR_SPI4_RX_MAXBURST2 > XLR_MAX_RX_BURST){
+		printk("invalid RX max burst2\n");
+		return SPI4_RX_MAXBURST2_ERROR;
+	}
+	if(XLR_SPI4_TX_MAXBURST2 < XLR_SPI4_TX_MAXBURST1){
+		printk("invalid TX max bursts\n");
+		return SPI4_TX_MAX_BURST_ERROR;
+	}
+	if(XLR_SPI4_RX_MAXBURST2 < XLR_SPI4_RX_MAXBURST1){
+		printk("invalid RX max bursts\n");
+		return SPI4_RX_MAX_BURST_ERROR ;
+	}
+	if(SPI4_BYTE_OFFSET > XLR_MAX_SPI4_BYTE_OFFSET){
+		printk("invalid byte offset\n");
+		return SPI4_BYTE_OFFSET_ERROR;
+	}
+	return SPI4_PARAMS_VALID;
+}	
+
+static void spi4_disable_tx_rx(unsigned int	*mmio)
+{
+	uint32  reg_val;
+	
+	reg_val = phoenix_read_reg(mmio, SPI4_CNTRL_REG);
+	reg_val &= ~(0xa);
+	phoenix_write_reg(mmio, SPI4_CNTRL_REG, reg_val ) ;
+
+	return;
+}	
+
+/*******************************************************************************
+*
+* Function name :       spi4_init
+* Input         :       spi4 slot, callback function
+* Description   :       This function will initialize the given spi4. It resets 
+*	the spi4, programs the tx calender, max burst, DMA and spi4 channels 
+*	and FIFO. 
+* RETURNS: void
+*******************************************************************************/
+
+unsigned int spi4_init(uint32 	slot, spi4_callback_func calbk_func )
+{
+	uint32	reg_val, byte_offset=0;
+	int i;
+	unsigned int 			*mmio, spi4_ret_value;
+	spi4_driver_data*		driver_data;
+	int tx_fifo_base[XLR_MAX_SPI4_CHANNEL];
+	int tx_fifo_size[XLR_MAX_SPI4_CHANNEL];
+	int rx_fifo_base[XLR_MAX_SPI4_CHANNEL];
+	int rx_fifo_size[XLR_MAX_SPI4_CHANNEL];
+
+	/* if support for loading apps on same core as Linux is enabled */
+	if(xlr_loader_support && xlr_loader_sharedcore)
+		return -EINVAL;
+
+	if((slot < SPI4_0) || (slot > SPI4_1)){
+		return SPI4_SLOT_ERROR;
+	}
+	driver_data = (spi4_driver_data*) os_malloc(sizeof(spi4_driver_data));
+	
+	if(driver_data == NULL){
+		return SPI4_MALLOC_FAIL;
+	}
+	driver_data->frin_spill =driver_data->frout_spill = NULL; 
+	driver_data->class_0_spill = driver_data->class_1_spill = NULL;
+	driver_data->class_2_spill = driver_data->class_3_spill = NULL; 
+
+	spi4_data[slot] = driver_data;
+
+	/*initilizing the spi4 and elements of the driver data*/
+	driver_data->calbk_func  = calbk_func;
+	driver_data->spi4_slot   = slot;
+	driver_data->tx_calendar = driver_data->rx_calendar = XLR_TOTAL_CHANNELS;
+	driver_data->tx_cal_sequence = TX_CAL_SEQ;
+	driver_data->rx_cal_sequence = RX_CAL_SEQ;	
+	driver_data->tx_maxburst1 = XLR_SPI4_TX_MAXBURST1;
+	driver_data->tx_maxburst2 = XLR_SPI4_TX_MAXBURST2;
+	driver_data->rx_maxburst1 = XLR_SPI4_RX_MAXBURST1;
+	driver_data->rx_maxburst2 = XLR_SPI4_RX_MAXBURST2;
+
+	spi4_ret_value = spi4_validate_config_params();
+	if(spi4_ret_value != SPI4_PARAMS_VALID){
+		printk("invalid configuration parameters\n");
+		return spi4_ret_value ;
+	}
+
+	if(slot == SPI4_0)
+		driver_data->mmio = (uint32*)(phoenix_io_base +  SPI4_0_BASE_ADDR);
+	else 
+		driver_data->mmio = (uint32*)(phoenix_io_base +  SPI4_1_BASE_ADDR);
+
+	mmio = driver_data->mmio;
+
+	/*configuring the IP registers*/
+	reg_val = phoenix_read_reg(mmio, SPI4_CNTRL_REG);
+	reg_val &= ~(0xa);
+	phoenix_write_reg(mmio, SPI4_CNTRL_REG, reg_val ) ; 
+
+	/*programming the Hungry thresholds*/
+	phoenix_write_reg(mmio, R_SPIHNGY0, 0x04040404);
+	phoenix_write_reg(mmio, R_SPIHNGY1, 0x04040404 );
+	phoenix_write_reg(mmio, R_SPIHNGY2, 0x04040404);
+	phoenix_write_reg(mmio, R_SPIHNGY3, 0x04040404);
+
+	/*programming the starving thresholds*/
+	phoenix_write_reg(mmio, R_SPISTRV0, 0x06060606);
+	phoenix_write_reg(mmio, R_SPISTRV1, 0x06060606);
+	phoenix_write_reg(mmio, R_SPISTRV2, 0x06060606);
+	phoenix_write_reg(mmio, R_SPISTRV3, 0x06060606);
+
+	phoenix_write_reg(mmio, 0x50, 4);/* F_ALPHA */
+	/*programming the DMA credits*/
+	phoenix_write_reg(mmio, R_DMACR0, 0xffffffff);
+	phoenix_write_reg(mmio, R_DMACR1, 0xffffffff);
+	phoenix_write_reg(mmio, R_DMACR2, 0xffffffff);
+	phoenix_write_reg(mmio, R_DMACR3, 
+		(0xff<<24)|(2<<21)|(2<<18)|(2<<12)|(2<<9)|(2<<6)|(2<<3)|(2<<0));
+
+	vtss_rmi_init(slot+1);
+
+	for(i=0; i<8; i++){
+		byte_offset <<= 3 ;
+		byte_offset |= SPI4_BYTE_OFFSET ; 	
+	}
+ 	phoenix_write_reg(mmio,DESC_PKT_CTRL_1,byte_offset);
+ 	phoenix_write_reg(mmio,DESC_PKT_CTRL_2,byte_offset);
+	phoenix_write_reg(mmio, PAD_CALIB_0,0x02030);
+
+	/*configure: TX cal, RX cal and cal seq*/
+	phoenix_write_reg(mmio, SPI4_TX_CAL_LEN, driver_data->tx_calendar);
+	phoenix_write_reg(mmio, SPI4_RX_CAL_LEN, driver_data->rx_calendar);
+	phoenix_write_reg(mmio, SPI4_TX_CAL_MAX , driver_data->tx_cal_sequence);
+	phoenix_write_reg(mmio, SPI4_RX_CAL_MAX, driver_data->rx_cal_sequence);
+
+	for(i=0;i< driver_data->tx_calendar; i++){
+		phoenix_write_reg(mmio,SPI4_TX_CAL_X, (i | (i<<16)));
+	}
+	for(i=0;i< driver_data->rx_calendar; i++){
+		phoenix_write_reg(mmio,SPI4_RX_CAL_X, (i | (i<<16)));
+	}
+
+	phoenix_write_reg(mmio, R_TX_CONTROL,
+      		((1<<W_TX_CONTROL__TxThreshold) | TX_THRESHOLD_SIZE));
+
+	phoenix_write_reg(mmio, R_RX_CONTROL, 1);
+
+	phoenix_write_reg(mmio, R_DESC_PACK_CTRL,
+			((1<< W_DESC_PACK_CTRL__RegularSize) | REG_FRAME_SIZE));
+
+	phoenix_write_reg(mmio, R_L2ALLOCCTRL, 0x2);
+
+	mdelay(5);
+
+	phoenix_write_reg(mmio, SPI4_INTR_REG, CLEAR_INT);
+	phoenix_write_reg(mmio, SPI4_TX_STATUS , CLEAR_TX_STATUS);
+	phoenix_write_reg(mmio, SPI4_RX_STATUS, CLEAR_RX_STATUS);
+
+	/* change rx maxburst 1 */
+	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
+		phoenix_write_reg(mmio, SPI4_RX_MAXBURST1_I,
+				XLR_SPI4_RX_MAXBURST1 + (i << XLR_MAX_SPI4_CHANNEL));
+
+	/* change rx maxburst 2 */
+	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++)
+		phoenix_write_reg(mmio, SPI4_RX_MAXBURST2_I,
+       		XLR_SPI4_RX_MAXBURST2 + (i << XLR_MAX_SPI4_CHANNEL));
+
+	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
+		tx_fifo_base[i]  = i*8;  
+		tx_fifo_size[i]  = 8 ; 
+		rx_fifo_base[i]  = i*32;  
+		rx_fifo_size[i]  = 32 ; 
+	}
+
+	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
+		phoenix_write_reg(mmio, SPI4_TX_FIFO_BASE_I,
+				tx_fifo_base[i] + (i<<XLR_MAX_SPI4_CHANNEL));
+		phoenix_write_reg(mmio, SPI4_RX_FIFO_BASE_I,
+				rx_fifo_base[i] + (i<<XLR_MAX_SPI4_CHANNEL));
+	}
+
+ 	for (i=0;i<XLR_MAX_SPI4_CHANNEL;i++){
+		phoenix_write_reg(mmio, SPI4_TX_FIFO_DEPTH_I,
+				tx_fifo_size[i] + (i<< XLR_MAX_SPI4_CHANNEL));
+		phoenix_write_reg(mmio, SPI4_RX_FIFO_DEPTH_I,
+				rx_fifo_size[i] + (i<< XLR_MAX_SPI4_CHANNEL));
+	}
+
+	phoenix_write_reg(mmio, 0x78, 4);
+	phoenix_write_reg(mmio, SPI4_CNTRL_REG, 0x00000e0f);
+
+	mdelay(10);
+
+	i = phoenix_read_reg(mmio, SPI4_TX_STATUS);
+	if(!(i & SPI4_TX_STATUS_TX_SYNC)){
+		spi4_disable_tx_rx(mmio);
+		printk("TX path no sync\n");
+		return SPI4_TX_SYNC_FAIL;
+	}
+
+	i = phoenix_read_reg(mmio, SPI4_RX_STATUS);
+	if(!(i & SPI4_RX_STATUS_RX_SYNC)){
+		spi4_disable_tx_rx(mmio);
+		printk("RX path no sync\n");
+		return SPI4_RX_SYNC_FAIL;
+	}
+	
+	spi4_ret_value = spi4_configure_spill_memory(slot);
+	if(spi4_ret_value != SPI4_CONFIG_SPILL_SUCCESS){
+		spi4_disable_tx_rx(mmio);
+		printk("spill memory configuration failed\n");
+		return spi4_ret_value;
+	}
+
+	spi4_ret_value = spi4_configure_pde_spray_mode(slot);
+	if(spi4_ret_value != SPI4_CONFIG_PDE_SUCCESS){
+		spi4_disable_tx_rx(mmio);
+		spi4_free_spill_memory(driver_data);
+		printk("pde configuration failed\n");
+		return spi4_ret_value ;
+	}
+
+	spi4_ret_value = spi4_register_msgrng_handler(slot);
+	if(spi4_ret_value != SPI4_REGISTER_MSGRING_SUCESS){
+		spi4_disable_tx_rx(mmio);
+		spi4_free_spill_memory(driver_data);
+		printk("registering msgring handler failed\n");
+		return spi4_ret_value ;
+	}
+
+	return SPI4_INIT_SUCCESS;
+
+}
+/*******************************************************************************
+* Function name :       spi4_msgring_handler
+* Input         :       
+* Description   :       This function will be called when spi4 sends any msg. 
+*	It handles TX_DONE and RX_IND mesg and informs the same to registered
+*	function by the upper application.
+* RETURNS       :       void
+*******************************************************************************/
+static void spi4_msgring_handler(int 	bucket, 	int size, 
+			int	code, 		int stid,
+			struct 	msgrng_msg *msg, void *data)
+{
+
+	unsigned int slot, port, ctrl, length;
+	unsigned long addr = 0;
+	unsigned int  error=0, th_id;
+	char*	ptr;
+	spi4_driver_data*   driver_data;
+
+
+	if(stid == MSGRNG_STNID_XGS0FR)
+		slot = SPI4_0;
+	else if(stid == MSGRNG_STNID_XGS1FR)
+		slot = SPI4_1;
+	else{
+		printk("ERROR: wrong slot\n");
+		return;
+	}
+	driver_data = spi4_data[slot];
+	port = get_port(msg->msg0);
+
+	length = get_length(msg->msg0);
+	if(length == 0)
+		ctrl = CTRL_REG_FREE;
+	else
+		ctrl = CTRL_SNGL;
+
+	if (ctrl == CTRL_REG_FREE ) {
+		/*TX complete*/
+		addr = msg->msg0 & 0xffffffffffULL;
+    	addr = (unsigned long) phys_to_virt(addr);
+		ptr = (char*) addr;
+		(*driver_data->calbk_func)
+				(SPI4_TX_DONE,slot,bucket,ptr,length, error);
+	}	
+	else if(ctrl == CTRL_SNGL || ctrl == CTRL_START){
+		/*RX indication*/
+		addr = (unsigned long) bus_to_virt(get_address(msg->msg0));
+		ptr = (char*) addr;
+		error = ((msg->msg0 >> 62)& 0x01);
+
+		if((port >= XLR_TOTAL_CHANNELS)){
+			/*
+			 * if wrong port is received, then treat that as error packet
+			 * and try to replenish it
+			*/
+			error = 1; 
+		}
+		
+		if(error){
+			spi4_program_rx_desc(slot,ptr);
+			th_id = hard_smp_processor_id();
+			g_dip4_error[th_id]++;
+		}
+		else{
+			length -=  (SPI4_BYTE_OFFSET + MAC_CRC_LEN );
+			(*driver_data->calbk_func)
+					(SPI4_RX_IND,slot,port,ptr,length, error);
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* Function name :       spi4_tx
+* Input         :
+* Description   :       This function will be called by the upper application
+*	to transmit data. Before doing TX it makes sure TX and RX path are in 
+*	sync.
+* RETURNS       :       int
+*			1 - fail
+*			0 - success
+*******************************************************************************/
+
+int spi4_tx(unsigned int thr_id, uint32 slot,  uint32 spi4_port, 
+						char* data, unsigned char* skb,uint32 len)
+{
+	unsigned int 		msgrng_flags;
+	spi4_driver_data*   	driver_data;
+	struct msgrng_msg 	msg;
+	int	stid=0, ret =0;
+
+	driver_data = spi4_data[slot];
+
+	stid = spi4_make_desc_tx(thr_id, &msg,  driver_data->spi4_slot,
+													spi4_port, TYPE_SPI4, virt_to_phys(data), 
+													(unsigned long) skb, len);
+
+	__sync();
+	msgrng_access_enable(msgrng_flags);
+	if (message_send_retry(2, MSGRNG_CODE_SPI4, stid, &msg)){
+		ret =  SPI4_TX_FAIL;
+	}
+	msgrng_access_disable(msgrng_flags);
+	return ret;
+}
+
+/*******************************************************************************
+* Function name :       spi4_program_rx_desc
+* Input         :
+* Description   :       This function will make a regular free descriptor 
+*	and sends it to spi4.
+* RETURNS       :       int
+*                       1 - fail
+*                       0 - success
+*******************************************************************************/
+
+void spi4_program_rx_desc(uint32 slot, 	
+			char* addr)
+{
+	unsigned long msgrng_flags;
+	int stid = 0;
+	struct msgrng_msg msg;
+	spi4_driver_data* driver_data;
+
+	driver_data = spi4_data[slot];
+
+	stid = spi4_make_desc_rfr(&msg, driver_data->spi4_slot,
+				TYPE_SPI4 , virt_to_bus(addr));
+	__sync();
+	msgrng_access_enable(msgrng_flags);
+	while (message_send(1, MSGRNG_CODE_SPI4, stid, &msg));
+	msgrng_access_disable(msgrng_flags);
+
+	return ;	
+}
+
+
+/*******************************************************************************
+* Function name :       spi4_open
+* Input         :
+* Description   :       This function enable TX and RX of the spi4 also sends 
+*	a jumbo frame.
+* RETURNS       :       void
+*******************************************************************************/
+
+int spi4_open(uint32 slot)
+{
+	spi4_driver_data*	driver_data;
+	unsigned int        	*mmio;
+
+	driver_data = spi4_data[slot];
+	if(driver_data == NULL){
+		return  SPI4_SLOT_ERROR;
+	}
+
+	mmio = driver_data->mmio;
+	if(mmio == NULL){
+		return SPI4_MMIO_ERROR;
+	}
+
+	return SPI4_OPEN_SUCCESS;
+}
+
+/*******************************************************************************
+* Function name :       spi4_close
+* Input         :
+* Description   :       This function disable TX and RX of the spi4 .
+* RETURNS       :       void
+*******************************************************************************/
+
+void spi4_close(uint32 slot)
+{
+	spi4_driver_data* driver_data;
+	unsigned int *mmio;
+	unsigned int tmp;
+
+	driver_data = spi4_data[slot];
+	mmio = driver_data->mmio;
+
+	tmp = phoenix_read_reg(mmio, R_TX_CONTROL);
+	tmp &= ~(1<<W_TX_CONTROL__TxThreshold);
+	phoenix_write_reg(mmio, R_TX_CONTROL, tmp);
+
+	tmp = phoenix_read_reg(mmio, R_RX_CONTROL);
+	tmp &= ~(1<<O_RX_CONTROL__RxEnable) ;
+	phoenix_write_reg(mmio, R_RX_CONTROL, tmp);
+
+	tmp = phoenix_read_reg(mmio, SPI4_CNTRL_REG);
+	tmp &= ~(TX_ENABLE |  RX_ENABLE);
+	phoenix_write_reg(mmio, SPI4_CNTRL_REG, tmp);
+
+	return;
+}
+
+int spi4_read_reg(uint32 slot, uint32 addr)
+{
+	spi4_driver_data*   driver_data;
+	unsigned int        *mmio;
+	unsigned int        tmp;
+
+	driver_data = spi4_data[slot];
+	mmio = driver_data->mmio;
+
+	tmp = phoenix_read_reg(mmio, addr);
+	return tmp;
+}
diff --git a/drivers/net/rmi_spi4/rmi_spi4.h b/drivers/net/rmi_spi4/rmi_spi4.h
new file mode 100644
index 0000000..b89f162
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_spi4.h
@@ -0,0 +1,220 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_SPI4_H
+#define _ASM_RMI_SPI4_H
+
+#include <linux/types.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/phoenix_mac.h>
+#include <asm/rmi/sim.h>
+#include "rmi_spi4_config.h"
+
+
+#define RMI_SPI4_MAX_THREADS 32
+#define RMI_SPI4_PORTS_PER_CARD XLR_TOTAL_CHANNELS
+
+
+#define MAX_SPILL_SIZE          (MAX_NUM_DESC + 128)
+#define MAX_FRIN_SPILL          (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+#define MAX_FROUT_SPILL         (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+#define MAX_CLASS_0_SPILL       (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+#define MAX_CLASS_1_SPILL       (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+#define MAX_CLASS_2_SPILL       (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+#define MAX_CLASS_3_SPILL       (MAX_SPILL_SIZE * RMI_SPI4_PORTS_PER_CARD)
+
+
+
+#define SPI4_0_BASE_ADDR			0x10000
+#define SPI4_1_BASE_ADDR			0x12000
+#define XLR_MAX_SPI4_CHANNEL		0x10
+#define XLR_MAX_SPI4_BYTE_OFFSET	7
+#define XLR_MAX_TX_BURST			8
+#define XLR_MAX_RX_BURST			32
+#define TX_CAL_SEQ					0x01
+#define RX_CAL_SEQ					0x01
+
+#define TOTAL_SPI4					2
+#define SPI4_0						0
+#define SPI4_1						1
+
+/* SPI4 registers */
+#define SPI4_TX_CAL_LEN				0x0
+#define SPI4_TX_CAL_MAX				0x04
+#define SPI4_TX_CAL_X				0x08
+#define SPI4_RX_CAL_LEN				0x18
+#define SPI4_RX_CAL_X				0x20
+#define SPI4_RX_CAL_MAX				0x1c
+#define SPI4_TX_MAXBURST1_I			0x30
+#define	SPI4_TX_MAXBURST2_I			0x34
+#define SPI4_RX_MAXBURST1_I			0x38
+#define	SPI4_RX_MAXBURST2_I			0x3c
+
+/* spi4 control register and its bit fields */
+#define SPI4_CNTRL_REG	0x6c
+#define	TX_RESET		0x1
+#define	TX_ENABLE		0x2
+#define	RX_RESET		0x04
+#define	RX_ENABLE		0x08
+#define	RX_CAL_Y		0x10
+#define	USR_SHAL_LPB	0x20
+#define	USR_DEEP_LPB	0x40
+#define	SPI_SHAL_LPB	0x80
+#define	SPI_DEP_LPB		0x100
+#define	DDL_ENABLE		0x200
+#define	FIFO_SW_RESET	0x400
+#define	RX_TRAIN_RESET 	0x800
+#define	RX_TRAIN_LOS		0x1000
+#define	TX_FRM_ERR_EN		0x2000
+#define	MORE_TRN_EN			0x4000
+#define	ERL_TRN_EN			0x8000
+#define	SYNC_PAT_EN			0x10000
+
+#define SPI4_INTR_REG			0x70
+#define	SPI4_TX_STATUS			0x7c
+#define	SPI4_TX_STATUS_TX_SYNC	0x4
+#define	SPI4_RX_STATUS			0x80
+#define SPI4_RX_STATUS_RX_SYNC	0x02
+#define	SPI4_RX_FIFO_DEPTH_I	0x88
+#define	SPI4_RX_FIFO_BASE_I		0x90
+#define	SPI4_TX_FIFO_DEPTH_I	0x8c
+#define	SPI4_TX_FIFO_BASE_I		0x94
+
+/* glue logic registers */
+#define DESC_PKT_CTRL_1		0xa9
+#define DESC_PKT_CTRL_2		0xaa
+#define PAD_CALIB_0			0x231
+#define RX_P_PRESET			0x1
+#define RX_N_PRESET			0x02
+#define	TX_P_PRESET			0x4
+#define TX_N_PRESET			0x08
+#define	RX_EN_COUNTER		0x10
+#define	TX_EN_COUNTER		0x20
+#define	CAL_PRESET			0
+#define	HSTL_TERMINATION	0x1000
+#define	LVDS_TERMINATION	0x2000
+
+/********** CPLD register **************/
+#define  CPLD_MISC_STATUS_REG	0x0e
+#define SPI4_MASK_BIT1			1
+
+typedef struct _spi4_driver_data
+{
+	uint32 tx_calendar;			/* number of ports */
+	uint32 tx_cal_sequence;
+
+	uint32 rx_calendar;			/* number of ports */
+	uint32 rx_cal_sequence;
+
+	uint32 tx_maxburst1;
+	uint32 tx_maxburst2;
+
+	uint32 rx_maxburst1;
+	uint32 rx_maxburst2;
+
+	uint32 *mmio;
+	uint spi4_slot;
+
+	spi4_callback_func calbk_func;
+
+	void *frin_spill;
+	void *frout_spill;
+	void *class_0_spill;
+	void *class_1_spill;
+	void *class_2_spill;
+	void *class_3_spill;
+
+} spi4_driver_data;
+
+/* spi4 descriptors */
+#define PORT_MASK 0xf
+#define DESK_CTRL_MASK 0x7
+#define DESC_CTRL_OFFSET  61
+#define DESC_LEN_MASK 0x3fff
+#define DESC_LEN_OFFSET 40
+#define DESC_ERROR_OFFSET 60
+#define DESC_ERROR_MASK 0x01
+
+#define get_error(a) ((((a)>> DESC_ERROR_OFFSET) & DESC_ERROR_MASK ))
+#define get_port(a) ((a)&(PORT_MASK))
+#define get_ctrl(a) (((a)>>(DESC_CTRL_OFFSET))& (DESK_CTRL_MASK))
+#define get_length(a) (((a) >> (DESC_LEN_OFFSET)) & (DESC_LEN_MASK))
+#define get_address(a) (((a)&(0xffffffffe0ULL)))
+
+#define SPI4_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
+extern int port_buk_map[];
+
+static inline int spi4_make_desc_tx(unsigned int thr_id,
+									struct msgrng_msg *msg,
+									int id,
+									int port,
+									int type,
+									unsigned long addr,
+									unsigned long skb, int len)
+{
+	int tx_stid = 0;
+	int fr_stid = 0;
+
+	tx_stid = msgrng_xgmac_stid_tx(id);
+	tx_stid += port;
+	fr_stid = port_buk_map[thr_id];
+
+	msg->msg0 = (((uint64_t) 1 << 63) |
+				 (((uint64_t) 127) << 54) |
+				 ((uint64_t) len << 40) | ((uint64_t) addr & 0xffffffffffULL)
+		);
+
+	msg->msg1 = (((uint64_t) 1 << 63) |
+				 (((uint64_t) fr_stid) << 54) |
+				 ((uint64_t) 0 << 40) |
+				 ((uint64_t) virt_to_phys((void *) skb) & 0xffffffffffULL)
+		);
+
+	msg->msg2 = msg->msg3 = 0;
+
+	return tx_stid;
+
+}
+
+static inline int spi4_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
+									 unsigned long addr)
+{
+	int stid = 0;
+
+	stid = msgrng_xgmac_stid_rfr(id);
+
+	msg->msg0 = (uint64_t) addr & 0xffffffffe0ULL;
+	msg->msg1 = msg->msg2 = msg->msg3 = 0;
+
+	return stid;
+}
+
+#endif /* _ASM_RMI_SPI4_H */
diff --git a/drivers/net/rmi_spi4/rmi_spi4_config.h b/drivers/net/rmi_spi4/rmi_spi4_config.h
new file mode 100644
index 0000000..02145a3
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_spi4_config.h
@@ -0,0 +1,138 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_SPI4_CONFIG_H
+#define _ASM_RMI_SPI4_CONFIG_H
+
+#include <linux/types.h>
+
+typedef unsigned int uint32;
+
+/* configuration parameters*/
+
+/*
+ * indicates how many spi4 channels currently need to be used
+ * by the upper driver
+*/
+#define XLR_TOTAL_CHANNELS 0xa
+
+/* 
+ * indicates number of 16 byte blocks that fifo can accept
+ * during fifo starving for the transmit path
+*/
+#define XLR_SPI4_TX_MAXBURST1    0x8
+
+/* 
+ * indicates number of 16 byte blocks that fifo can accept
+ * during fifo hungry for the transmit path
+*/
+#define XLR_SPI4_TX_MAXBURST2    0x8
+
+/*
+ * indicates number of 16 byte blocks that fifo can accept
+ * during fifo starving for the receive path
+*/
+#define XLR_SPI4_RX_MAXBURST1    0x8
+
+/* 
+ * indicates number of 16 byte blocks that fifo can accept
+ * during fifo hungry for the receive path
+*/
+#define XLR_SPI4_RX_MAXBURST2    0x8
+
+
+
+/* 
+ * folowing are the configuration parameters for the ethrnet mac 
+ * driver 
+*/
+
+/* threshold for tx starts*/
+#define TX_THRESHOLD_SIZE      	512
+
+/* max buffer size for the tx and rx*/
+#define REG_FRAME_SIZE 		1536
+#define MAX_FRAME_SIZE          REG_FRAME_SIZE
+
+/* indicates byte offset for rx data start from the rx buffer */
+#define SPI4_BYTE_OFFSET        2
+
+#define MAC_CRC_LEN             4
+#define MAC_SKB_BACK_PTR_SIZE   SMP_CACHE_BYTES
+#define MAC_PREPAD              0
+
+/* number of descriptors for each spi4 channel given for the rx data*/
+#define MAX_NUM_DESC            512
+
+typedef void (*spi4_callback_func)(uint32,uint32, uint32, char*, 
+		uint32, uint32 error);
+
+enum spi4_callback_cmd{
+	SPI4_TX_DONE ,
+	SPI4_RX_IND
+};
+
+/* exported API*/
+extern unsigned int spi4_init(uint32   slot, spi4_callback_func);
+extern void spi4_program_rx_desc(uint32  slot,  char*);
+extern int spi4_open(uint32 slot);
+extern void spi4_close(uint32 slot);
+extern int spi4_tx(unsigned int thr_id, uint32 slot,  uint32 spi4_port,
+                char* data, unsigned char* skb,uint32 len);
+extern int spi4_read_reg(uint32 slot, uint32 addr);
+
+
+enum spi4_returns{
+	SPI4_PASS = 0x0,
+	SPI4_TX_FAIL,
+	SPI4_SLOT_ERROR,
+	SPI4_MALLOC_FAIL,
+	SPI4_TX_SYNC_FAIL,
+	SPI4_RX_SYNC_FAIL,
+	SPI4_INIT_SUCCESS,
+	SPI4_CALENDER_LEN_ERROR,
+	SPI4_TX_MAXBURST1_ERROR,
+	SPI4_TX_MAXBURST2_ERROR,
+	SPI4_RX_MAXBURST1_ERROR,
+	SPI4_RX_MAXBURST2_ERROR,
+	SPI4_TX_MAX_BURST_ERROR,
+	SPI4_RX_MAX_BURST_ERROR,
+	SPI4_BYTE_OFFSET_ERROR,
+	SPI4_PARAMS_VALID,
+	SPI4_CONFIG_SPILL_FAIL,
+	SPI4_CONFIG_SPILL_SUCCESS,
+	SPI4_CONFIG_PDE_SUCCESS,
+	SPI4_REGISTER_MSGRING_FAIL,
+	SPI4_REGISTER_MSGRING_SUCESS,
+	SPI4_MMIO_ERROR,
+	SPI4_OPEN_SUCCESS,
+
+};
+#endif /* _ASM_RMI_SPI4_CONFIG_H */
diff --git a/drivers/net/rmi_spi4/rmi_vits_driver.c b/drivers/net/rmi_spi4/rmi_vits_driver.c
new file mode 100644
index 0000000..b9542e1
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_driver.c
@@ -0,0 +1,282 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <asm/rmi/iomap.h>
+#include "rmi_spi4_config.h"
+#include "rmi_vits_wrapper.h"
+#include "rmi_vits_driver.h"
+#include "vitesse_common.h"
+#include "vitesse_highlevel.h"
+#include "vitesse_io.h"
+#include "vitesse_phy_ctrl.h"
+#include <asm/rmi/debug.h>
+#include "meigsii_reg.h"
+#include <linux/kernel.h>
+
+vtss_mapped_port_t eds_ports_table[VTSS_PORT_ARRAY_SIZE] = {
+
+	/* chip_port, miim_controller, phy_addr */
+	/* logical port 0 doesn't exsist */
+	{         -1,              -1,     -1  }, 
+	{          0,               0,     0x3 },
+	{          1,               0,     0x2 },
+	{          2,               0,     0x1 },
+	{          3,               0,     0x0 },
+	{          4,               0,     0x7 },
+	{          5,               0,     0x6 },
+	{          6,               0,     0x5 },
+	{          7,               0,     0x4 },
+	{          8,               0,     0xb },
+	{          9,               0,     0xa },
+	{         10,               1,     0x1 }  /* This is 10g port */
+};
+
+
+void vtss_eds_init( vtss_mac_major_mode_t mmode, vtss_port_interface_t pmode, BOOL fc)
+{
+	vtss_rc phy_val;
+
+	/* Note that the (R/)GMII ports must be mapped before calling this function */
+
+	int ports_in_use = XLR_TOTAL_CHANNELS; /* all 10 GMII ports are used */
+	int portnum = 0;       
+	vtss_system_setup_t sys_setup;
+	vtss_fifo_setup_t   egress_fifo_setup;
+	vtss_fifo_setup_t   ingress_fifo_setup;
+	vtss_port_setup_t   port_1G_setup;
+	vtss_spi4_setup_t   spi4_setup;
+	vtss_fifo_fc_watermarks_t fc_watermarks;
+	vtss_mac_t smac = {{0,0,0,0,0,0}};
+
+	/* Reset I/O-level software (will also reset the chip) */
+	vtss_chip_reset();
+
+	/* Prepare major mode for runtime calls */
+	vtss_major_mode_set(mmode);
+
+	/* Mapping logical ports with physical ports */
+	vtss_port_map_set(eds_ports_table);
+
+	/* Setup of basic system parameters -- clock, endianess, etc.. */
+	vtss_system_setup_get_default_values( &sys_setup, mmode);
+	vtss_system_setup( &sys_setup);
+
+	/* Setup Host interface */
+	vtss_spi4_setup_get_default_values( &spi4_setup, mmode);
+	vtss_spi4_setup( &spi4_setup);
+
+	/* Setup FIFO */
+	vtss_fifo_setup_get_default_values( &ingress_fifo_setup, 
+				&egress_fifo_setup, mmode);
+	vtss_fifo_setup( &ingress_fifo_setup, &egress_fifo_setup);
+
+
+	/* Setup logical ports */
+	for (portnum = 1; portnum <= ports_in_use; portnum++) {
+
+		phy_val = vtss_phy_reset(portnum) ;
+		if(phy_val != VTSS_OK)
+			printk("Not able to reset phy=%d\n",portnum);
+
+		vtss_port_setup_get_default_values( &port_1G_setup, mmode);
+		/* Change default gmii to pmode */
+		port_1G_setup.interface_mode.interface_type = pmode;
+
+		if (fc) {
+			/* Change flowcontrol settings i MAC */
+			smac.addr[5] = portnum;
+			port_1G_setup.flowcontrol.smac = smac;
+			port_1G_setup.flowcontrol.obey = 1;
+			port_1G_setup.flowcontrol.generate = 1;
+
+			/* Change watermarks settings in FIFO buffer 
+			 * to be used for flowcontrol Ingress for port 
+			 * flowcontrol. Egress for SPI4 flowcontrol */
+			fc_watermarks.low_watermark = 0xc6;
+			fc_watermarks.high_watermark = 0xca;
+			vtss_fifo_watermarks_set( portnum, &fc_watermarks,
+						 &fc_watermarks);
+		}
+		if(vtss_port_setup( portnum, &port_1G_setup))
+			printk("Not able to set the port=%d\n",portnum);
+		if(vtss_port_set_mode(portnum, VTSS_SPEED_100M, 1)!= VTSS_OK)
+			printk("not able to set 100mb\n");	
+
+		/* Port enable */
+		vtss_port_set_enable( portnum, 1, 1);
+	}
+}
+
+
+
+void vtss_rmi_init(int device_number) 
+{
+	long egr_control, crc_cfg, crc_add;
+	int loop;
+	int  portnum  ;
+	unsigned long	tx_rx_status;
+
+	ulong value;
+	BOOL  flow_ena;
+	vtss_mac_major_mode_t eds_mmode; /* major mode */
+	vtss_port_interface_t eds_pmode; /* port  mode */ 
+
+	megis_phoenix_init(device_number);
+
+	/* Reset I/O layer, configure operating system driver, and reset chip */
+	vtss_io_reset();
+
+	/* Get Chip ID */
+	value = vtss_chip_id_get();
+
+
+	/* Initialize MAC to major mode and port mode */
+	eds_mmode = VTSS_MAC_MAJOR_MODE_SPI4_1G; /* default SPI4<->1G*/
+	eds_pmode = VTSS_PORT_INTERFACE_RGMII; /* default RGMII */
+	flow_ena = 0; 
+
+	vtss_eds_init( eds_mmode, eds_pmode, flow_ena);
+
+	/* reset training period  */
+	vtss_io_write(M2_BLK_SPI4,0,M2_SPI4_ING_SETUP1, 0x1000f);
+
+	/* setup debug counter to count ingress fifo events */
+	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TEST, 0x00010000);
+	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_DEBUG_BUF_CNT, 0x00010000);
+
+	/* Setting IFG to small value */
+	for(loop=0; loop<=10; loop++){
+		vtss_io_write(M2_BLK_MACS, loop, M2E_TX_IFG, 0x6);
+	}
+
+	/* not to drop frame with crc error in egress */
+	crc_cfg = vtss_io_read(M2_BLK_SYSTEM,M2_SUBBLK_CTRL,0xb);
+	crc_cfg |= 1<<5;
+	vtss_io_write(M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 0xb, crc_cfg);
+
+	egr_control = vtss_io_read(M2_BLK_FIFO,M2_SUBBLK_EGRESS,M2_EGR_CONTROL);
+	egr_control |= 1<<18;
+	vtss_io_write(M2_BLK_FIFO,M2_SUBBLK_EGRESS,M2_EGR_CONTROL, egr_control);
+
+	for(portnum=0; portnum < XLR_TOTAL_CHANNELS; portnum++){
+			crc_add = vtss_io_read(M2_BLK_MACS, portnum, M2_TRI_DENORM);
+			crc_add &= ~(1<<5); /* clear 5th bit crc_upd */
+			crc_add |= 1<<4;  /* set 4th bit crc_add */
+			vtss_io_write(M2_BLK_MACS, portnum, 
+						M2_TRI_DENORM,crc_add);
+			crc_add = vtss_io_read(M2_BLK_MACS, 
+						portnum, M2_TRI_DENORM);
+
+				crc_add = vtss_io_read(M2_BLK_MACS, 
+						portnum, M2_DEV_SETUP);
+			tx_rx_status = vtss_io_read(M2_BLK_MACS, portnum, M2_MODE_CFG);
+			tx_rx_status &= ~(0X3) ; /* DISABLE TX RX */
+	  	vtss_io_write(M2_BLK_MACS, portnum, M2_MODE_CFG, tx_rx_status);
+		}
+	
+
+	/* setup debug counter to count egress fifo events */
+	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TEST, 0x00010000);
+	vtss_io_write(M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_DEBUG_BUF_CNT, 0);
+
+
+	/* setup debug counter to count spi4 egress traffic */
+	vtss_io_write(M2_BLK_SPI4, 0, M2_SPI4_DBG_CNT, 0);
+	vtss_io_write(M2_BLK_SPI4, 0, M2_SPI4_DBG_SETUP, 0x00000002);
+
+	return;
+}
+
+
+int vtss_rmi_monitor_phy_status(int port, int *speed, int *duplexity)
+{
+	vtss_rc ret, dup;
+	vtss_phy_status_t   status;
+
+	ret = vtss_phy_status_get(port, &status);
+	if(ret != VTSS_OK){
+		return 0;
+	}
+	dup = ret = vtss_phy_read(port, 0x1c);
+	if(ret<0) return 0;
+
+	ret >>=3;
+	ret &= 0x3;
+	switch(ret){
+		case 2:
+			(*speed) =(int) SPEED_1000M;
+			break;
+		case 1:
+			(*speed )= (int)SPEED_100M;
+			break;
+		case 0:
+			(*speed) = (int)SPEED_10M;
+			break;
+		default:
+			(*speed) = (int)UNDEFINED_SPEED;
+	}
+	dup >>= 5;
+	dup &= 0x01;
+	if(dup){
+		(*duplexity) = 1;
+	}
+	else{
+		(*duplexity) = 0;
+	}
+
+	return 1;
+}
+
+int vtss_rmi_change_port_status(int port, int speed, int duplexity)
+{
+	int i;
+
+	switch(speed){
+	case SPEED_1000M:
+		speed = VTSS_SPEED_1G;
+		break;
+	case SPEED_100M:
+		speed = VTSS_SPEED_100M;
+		break;
+	case SPEED_10M:
+		speed = VTSS_SPEED_10M;
+		break;
+	default :
+		speed = VTSS_SPEED_1G;
+	}
+	i = vtss_port_set_mode(port, speed, duplexity);
+	if(i == VTSS_OK ){
+		return 1;
+	}
+	else{
+		return 0;
+	}
+}
+
diff --git a/drivers/net/rmi_spi4/rmi_vits_driver.h b/drivers/net/rmi_spi4/rmi_vits_driver.h
new file mode 100644
index 0000000..d9fe746
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_driver.h
@@ -0,0 +1,52 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_VITS_DRIVER_H
+#define _ASM_RMI_VITS_DRIVER_H
+
+#include "vitesse_highlevel.h"
+
+typedef enum _vits_driver_speed{
+	SPEED_10M = 1,
+	SPEED_100M,
+	SPEED_1000M,
+	UNDEFINED_SPEED
+}vits_driver_speed;
+
+
+/* driver function prototypes */
+void vtss_eds_init( vtss_mac_major_mode_t mmode, 
+		vtss_port_interface_t pmode, BOOL fc);
+void vtss_rmi_init(int device_number);
+int vtss_rmi_monitor_phy_status(int port, int *speed, int *duplexity);
+int vtss_rmi_change_port_status(int port, int speed, int duplexity);
+
+
+#endif
diff --git a/drivers/net/rmi_spi4/rmi_vits_eth.c b/drivers/net/rmi_spi4/rmi_vits_eth.c
new file mode 100644
index 0000000..99fb4be
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_eth.c
@@ -0,0 +1,1076 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "rmi_vits_eth.h"
+#include "rmi_spi4_config.h"
+#include "os_layer.h"
+
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/sim.h>
+#include "meigsii_reg.h"
+#include "rmi_vits_wrapper.h"
+#include "rmi_vits_driver.h"
+#include "vitesse_common.h"
+#include "vitesse_highlevel.h"
+#include "vitesse_io.h"
+#include "vitesse_phy_ctrl.h"
+
+#include <asm/rmi/phoenix_mac.h>
+
+#define DRV_NAME  "rmi_vits_spi4"
+#define DRV_VERSION "0.1"
+#define DRV_RELDATE "10Aug2005"
+
+#define PHY_MONITOR	1
+#define RMI_SPI4_MAX_CPUS 8
+#define SPI4_FRIN_THRESHOLD 16
+#define RMI_SPI4_TX_MAX_COUNTER 100
+#define MAKE_CACHE_ALIGN ~(0x1f)
+#define RMI_SPI4_DEBUG 0
+
+enum vits_returns
+{
+	VITS_PROGRAM_RX_DESC_FAIL,
+	VITS_PROGRAM_RX_DESC_SUCCESS,
+	VITS_COMMON_INIT_SUCCESS,
+};
+
+struct net_device *spi4_dev[RMI_SPI4_MAX_PORTS];
+
+typedef struct _driver_data
+{
+
+	struct net_device *dev;
+	spinlock_t lock;
+
+	uint port;					/* this is eth port: 0-19 */
+	uint slot;
+	uint spi4_port;				/* this is spi4 port :0-9 */
+	uint own;
+	uint speed;
+	uint duplex;
+	uint autoneg;
+	uint type;
+	struct net_device_stats stats;
+	atomic_t frin_to_be_sent[RMI_SPI4_MAX_CPUS];
+
+} driver_data;
+
+unsigned int g_spi4_card_flag;
+static spinlock_t pending_tx_lock[RMI_SPI4_MAX_PORTS] __cacheline_aligned;
+static spinlock_t base_change = SPIN_LOCK_UNLOCKED;
+
+struct timer_list link_monitor_timer;
+extern unsigned long g_dip4_error[];
+static struct work_struct vits_frin_replenish_work[RMI_SPI4_MAX_CPUS];
+
+void set_ethtool_ops(struct net_device *netdev);
+
+void rmi_vits_rx_tx_done(uint32 cmd, uint32 slot, uint32 port,
+						 char *addr, uint32 len, uint32 error);
+
+
+unsigned char spi4_check_daughter_cards(void);
+static __inline__ struct sk_buff *spi4_get_skb_back_ptr(unsigned long addr)
+{
+	unsigned long *back_ptr =
+		(unsigned long *) (addr - MAC_SKB_BACK_PTR_SIZE);
+
+	/* this function should be used only for newly allocated packets.
+	 * It assumes the first cacheline is for the back pointer related
+	 * book keeping info
+	 */
+	return (struct sk_buff *) (*back_ptr);
+}
+
+static __inline__ void spi4_put_skb_back_ptr(struct sk_buff *skb)
+{
+	unsigned long *back_ptr = (unsigned long *) skb->data;
+
+	/* this function should be used only for newly allocated
+	 * packets. It assumes  the first cacheline is for the back
+	 * pointer related book keeping info
+	 */
+	skb_reserve(skb, MAC_SKB_BACK_PTR_SIZE);
+
+	*back_ptr = (unsigned long) skb;
+}
+
+void change_vits_base(int port)
+{
+	if (port < RMI_SPI4_PORTS_PER_CARD) {
+		megis_phoenix_init(1);
+	}
+	else {
+		megis_phoenix_init(2);
+	}
+	return;
+}
+extern uint32_t dev_tree_en;
+extern int fdt_get_spi4_ppties(int slot, int *spi4_list,
+							   unsigned long *spi4_addr, int *spi4_own);
+
+/*******************************************************************************
+* Function name :       rmi_link_monitor
+* Input         :
+* Description   :       This function monitors all the phy channels and if speed
+*	or duplexity changed, then it changes the mac's speed and duplexity.
+* RETURNS       :       void
+*******************************************************************************/
+
+void rmi_link_monitor(unsigned long data)
+{
+
+	int i, port, cpu, thr_id, slot;
+	struct net_device *dev;
+	driver_data *priv;
+	int speed, duplexity;
+	unsigned int flags;
+
+	cpu = phoenix_cpu_id();
+	thr_id = phoenix_thr_id();
+
+	spin_lock_irqsave(&base_change, flags);
+	for (i = 0; i < RMI_SPI4_MAX_PORTS; i++) {
+		slot = active_port[i].slot;
+
+		if ((spi4_slot[slot] == INVALID_SLOT) ||
+			(active_port[i].port == INVALID_PORT))
+			continue;
+
+		if (!(g_spi4_card_flag & (1 << slot)))
+			continue;
+
+		change_vits_base(i);
+
+		if (active_port[i].slot == SPI4_0)
+			port = active_port[i].port;
+		else if (active_port[i].slot == SPI4_1)
+			port = (active_port[i].port) - RMI_SPI4_PORTS_PER_CARD;
+		else {
+			printk("ERROR: wrong slot should never happen\n");
+			continue;
+		}
+
+		/*if the link is down for the particular port just continue
+		   for the remaining ports */
+		port++;
+		if (!vtss_rmi_monitor_phy_status(port, &speed, &duplexity)) {
+			continue;
+		}
+		dev = spi4_dev[i];
+		if (!dev)
+			continue;
+		priv = netdev_priv(dev);
+		if (speed == UNDEFINED_SPEED) {
+			continue;
+		}
+#if RMI_SPI4_DEBUG
+		printk("new speed=%d, old_speed=%d\n", speed, priv->speed);
+#endif
+		if ((priv->speed != speed) || (priv->duplex != duplexity)) {
+#if RMI_SPI4_DEBUG
+			printk("speed change to port=%d : speed=%d, dup=%d\n",
+				   port, speed, duplexity);
+#endif
+			if (vtss_rmi_change_port_status(port, speed, duplexity)) {
+				priv->speed = speed;
+				priv->duplex = duplexity;
+			}
+		}
+	}							
+
+	spin_unlock_irqrestore(&base_change, flags);
+	link_monitor_timer.expires = jiffies + HZ;
+	add_timer(&link_monitor_timer);
+
+	return;
+}
+
+
+
+static int rmi_vits_open(struct net_device *dev)
+{
+	unsigned int vits_port;
+	unsigned long tx_rx_status;
+	driver_data *priv = netdev_priv(dev);
+	unsigned int flags;
+
+#if RMI_SPI4_DEBUG
+	printk("opening the spi4 interface: %d\n", priv->port);
+#endif
+
+	spin_lock_irqsave(&base_change, flags);
+	if (priv->port < RMI_SPI4_PORTS_PER_CARD) {
+		vits_port = priv->port;
+	}
+	else {
+		vits_port = priv->port - RMI_SPI4_PORTS_PER_CARD;
+	}
+	change_vits_base(priv->port);
+	tx_rx_status = vtss_io_read(M2_BLK_MACS, vits_port, M2_MODE_CFG);
+	tx_rx_status |= 0x3;		/* enable TX and RX */
+	vtss_io_write(M2_BLK_MACS, vits_port, M2_MODE_CFG, tx_rx_status);
+
+	spin_unlock_irqrestore(&base_change, flags);
+	return 0;
+}
+
+static int rmi_vits_close(struct net_device *dev)
+{
+	unsigned int vits_port;
+	unsigned long tx_rx_status;
+	unsigned int flags;
+
+	driver_data *priv = netdev_priv(dev);
+
+#if RMI_SPI4_DEBUG
+	printk("closing the spi4 interface: %d\n", priv->port);
+#endif
+	spin_lock_irqsave(&base_change, flags);
+	if (priv->port < RMI_SPI4_PORTS_PER_CARD) {
+		vits_port = priv->port;
+	}
+	else {
+		vits_port = priv->port - RMI_SPI4_PORTS_PER_CARD;
+	}
+	change_vits_base(priv->port);
+	tx_rx_status = vtss_io_read(M2_BLK_MACS, vits_port, M2_MODE_CFG);
+	tx_rx_status &= ~(0x3);		/* disable TX and RX */
+	vtss_io_write(M2_BLK_MACS, vits_port, M2_MODE_CFG, tx_rx_status);
+	spin_unlock_irqrestore(&base_change, flags);
+	return 0;
+}
+
+#if RMI_SPI4_DEBUG
+void print_stats(vtss_port_counters_t * stat)
+{
+
+	printk("out byte		: %ld\n", stat->tx_out_bytes);
+	printk("tx_pause		: %ld\n", stat->tx_pause);
+	printk("tx_ok_by		: %ld\n", stat->tx_ok_bytes);
+	printk("tx_unicast		: %ld\n", stat->tx_unicast);
+	printk("tx_multicast		: %ld\n", stat->tx_multicast);
+	printk("tx_broadcast		: %ld\n", stat->tx_broadcast);
+	printk("tx_multiple_coll	: %ld\n", stat->tx_multiple_coll);
+	printk("tx_late_coll		: %ld\n", stat->tx_late_coll);
+	printk("tx_xcoll		: %ld\n", stat->tx_xcoll);
+	printk("tx_defer		: %ld\n", stat->tx_defer);
+	printk("tx_xdefer		: %ld\n", stat->tx_xdefer);
+	printk("tx_carrier_sense	: %ld\n", stat->tx_carrier_sense);
+	printk("tx_size_64		: %ld\n", stat->tx_size_64);
+	printk("tx_size_65_to_127	: %ld\n", stat->tx_size_65_to_127);
+	printk("tx_size_128_to_255	: %ld\n", stat->tx_size_128_to_255);
+	printk("tx_size_256_to_511	: %ld\n", stat->tx_size_256_to_511);
+
+	printk("tx_single_coll		: %ld\n", stat->tx_single_coll);
+	printk("tx_backoff2		: %ld\n", stat->tx_backoff2);
+	printk("tx_backoff3		: %ld\n", stat->tx_backoff3);
+	printk("\n");
+	printk("tx_underrun		: %ld\n", stat->tx_underrun);
+	printk("ingress_overflow_drop	: %ld\n", stat->ingress_overflow_drop);
+	printk("egress_overflow_drop	: %ld\n", stat->egress_overflow_drop);
+	printk("\n");
+
+
+	printk("rx_in_bytes            : %ld\n", stat->rx_in_bytes);
+	printk("rx_ok_bytes            : %ld\n", stat->rx_ok_bytes);
+	printk("rx_bad_bytes           : %ld\n", stat->rx_bad_bytes);
+	printk("rx_unicast             : %ld\n", stat->rx_unicast);
+	printk("rx_multicast           : %ld\n", stat->rx_multicast);
+	printk("rx_broadcast           : %ld\n", stat->rx_broadcast);
+	printk("rx_crc                 : %ld\n", stat->rx_crc);
+	printk("rx_undersize           : %ld\n", stat->rx_undersize);
+	printk("rx_fragments           : %ld\n", stat->rx_fragments);
+	printk("rx_in_range_error      : %ld\n", stat->rx_in_range_error);
+	printk("rx_out_of_range_error  : %ld\n", stat->rx_out_of_range_error);
+	printk("rx_oversize            : %ld\n", stat->rx_oversize);
+
+	printk("\n");
+	printk("\n");
+
+	return;
+}
+
+void rmi_vits_dump_dbg_regs(struct net_device *dev)
+{
+
+	int port;
+	long reg_value;
+
+	driver_data *priv = netdev_priv(dev);
+	if (priv->slot == SPI4_0)
+		port = priv->port;
+	else if (priv->slot == SPI4_1)
+		port = priv->port - RMI_SPI4_PORTS_PER_CARD;
+	else
+		return;
+
+	port++;
+	reg_value = spi4_read_reg(priv->slot, R_TX_CONTROL);
+	printk("GLUE REG: TX CONTROL addr : A0 = %lx\n", reg_value);
+	reg_value = spi4_read_reg(priv->slot, SPI4_TX_STATUS);
+	printk("TX STATUS = 0x%lx\n", reg_value);
+	reg_value = spi4_read_reg(priv->slot, SPI4_RX_STATUS);
+	printk("RX STATUS = 0x%lx\n", reg_value);
+	reg_value = spi4_read_reg(priv->slot, 0x70);
+	printk("INT REG = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(1, port, 0x0a);
+	printk("VTSS reg stick_bit - addr 0x0a = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(1, port, 0x0c);
+	printk("VTSS reg drop count - addr 0x0c = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(7, 0xf, 0x0a);
+	printk("VTSS reg egr crc count -(7,f,a)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(7, 0xf, 0x0b);
+	printk("VTSS reg crc config -(7,f,b)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x0f);
+	printk("VTSS reg EGR_CONTROL -(2,1,f)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x60);
+	printk("VTSS reg EGR DROP COUNT -(2,1,60)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x61);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,61)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x62);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,62)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x63);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,63)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x64);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,64)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x65);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,65)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x66);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,66)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x67);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,67)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x68);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,68)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(2, 1, 0x69);
+	printk("VTSS reg EGR DROP COUNT  -(2,1,69)  = 0x%lx\n", reg_value);
+	reg_value = vtss_io_read(5, 0, 0x30);
+	printk("VTSS reg spi4_sticky : host spi:   -(5,0,30)  = 0x%lx\n",
+		   reg_value);
+
+	return;
+}
+#endif
+
+int rmi_vits_collect_stats(struct net_device *dev,
+						   vtss_port_counters_t * stat)
+{
+	int port;
+	driver_data *priv = netdev_priv(dev);
+
+	if (priv->slot == SPI4_0)
+		port = priv->port;
+	else if (priv->slot == SPI4_1)
+		port = priv->port - RMI_SPI4_PORTS_PER_CARD;
+	else
+		return 1;
+	change_vits_base(priv->port);
+	/* this is for the VTSS API, which will search the port data structure */
+	port++;
+	if (vtss_port_counters_get((const vtss_port_no_t) port, stat) == VTSS_OK) {
+		return 0;
+	}
+	return 1;
+}
+
+/*
+   VTSS API for clearing stat has some problem, one can't clear for a
+   particular port, it will clear all the ports, so currently stat clear
+   is not done
+ */
+static struct net_device_stats *rmi_vits_get_stats(struct net_device *dev)
+{
+	unsigned int flags, i;
+	unsigned long total_dip4 = 0;
+	vtss_port_counters_t stat;
+	driver_data *priv = netdev_priv(dev);
+
+	spin_lock_irqsave(&base_change, flags);
+	if ((priv->slot == INVALID_SLOT) || (priv->port == INVALID_PORT)) {
+		spin_unlock_irqrestore(&base_change, flags);
+		return &priv->stats;
+	}
+	if (rmi_vits_collect_stats(dev, &stat)) {
+		spin_unlock_irqrestore(&base_change, flags);
+		return &priv->stats;
+	}
+
+	/*update the vits stats to dev stats */
+	priv->stats.rx_packets = stat.rx_unicast + stat.rx_broadcast;
+	priv->stats.tx_packets = stat.tx_unicast;
+	priv->stats.rx_bytes = stat.rx_ok_bytes;
+	priv->stats.tx_bytes = stat.tx_ok_bytes;
+	priv->stats.rx_fifo_errors = stat.ingress_overflow_drop;
+	priv->stats.tx_fifo_errors = stat.egress_overflow_drop;
+	priv->stats.multicast = stat.rx_multicast;
+	for (i = 0; i < RMI_SPI4_MAX_THREADS; i++) {
+		total_dip4 += g_dip4_error[i];
+	}
+	priv->stats.rx_errors = total_dip4;
+	priv->stats.rx_crc_errors = stat.rx_crc;
+	priv->stats.multicast = stat.rx_multicast;
+	spin_unlock_irqrestore(&base_change, flags);
+	return &priv->stats;
+
+}
+
+static int rmi_vits_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	unsigned int thr_id, ret = 0;
+	unsigned eth_port;
+	unsigned int flags;
+	driver_data *priv = netdev_priv(dev);
+
+#if RMI_SPI4_DEBUG
+	printk("[%s]: port=%d, skb=%p, len=%d\n",
+		   __func__, priv->port, skb, skb->len);
+	for (i = 0; i < skb->len; i++)
+		printk("%x  ", skb->data[i]);
+	printk("\n");
+#endif
+	thr_id = hard_smp_processor_id();
+	if (spi4_tx(thr_id, priv->slot, priv->spi4_port, skb->data,
+				(unsigned char *) skb, skb->len)) {
+		eth_port = priv->port;
+		spin_lock_irqsave(&pending_tx_lock[eth_port], flags);
+		/* now once again attempt to send, in case, by this time
+		   if any TX_DONE happend for the corresponding port */
+		if (spi4_tx(thr_id, priv->slot, priv->spi4_port, skb->data,
+					(unsigned char *) skb, skb->len)) {
+			netif_stop_queue(dev);
+			ret = 1;
+		}
+		else {
+			ret = 0;
+		}
+		spin_unlock_irqrestore(&pending_tx_lock[eth_port], flags);
+	}
+
+	return ret;
+}
+
+
+int rmi_vits_program_rx_desc(unsigned int slot, int total_desc)
+{
+	int i;
+	struct sk_buff *skb = 0;
+	unsigned int ret = VITS_PROGRAM_RX_DESC_SUCCESS;
+
+	for (i = 0; i < total_desc; i++) {
+		skb = os_alloc_skb();
+		if (!skb) {
+			printk("ERROR: alloc skb failed\n");
+			ret = VITS_PROGRAM_RX_DESC_FAIL;
+			break;
+		}
+		spi4_put_skb_back_ptr(skb);
+		spi4_program_rx_desc(slot, skb->data);
+	}
+	return ret;
+}
+
+/*******************************************************************************
+* Function name :       rmi_vits_frin_replenish
+* Input         :
+* Description   :       This function replenish RX desc for all ports for
+*	a cpu on which it is scheduled.
+* RETURNS       :       void
+*******************************************************************************/
+static void rmi_vits_frin_replenish(struct work_struct *data)
+{
+	int done = 0;
+	int cpu = phoenix_cpu_id();
+
+	driver_data *priv;
+	struct net_device *dev;
+	atomic_t *frin_to_be_sent;
+	int i;
+
+	while (1) {
+		done = 0;
+		for (i = 0; i < RMI_SPI4_MAX_PORTS; i++) {
+			if (active_port[i].port == INVALID_PORT) {
+				goto skip;
+			}
+			dev = spi4_dev[i];
+			if (dev == NULL) {
+				goto skip;
+			}
+			priv = netdev_priv(dev);
+			frin_to_be_sent = &priv->frin_to_be_sent[cpu];
+			if (atomic_read(frin_to_be_sent) < 0) {
+				printk("ERROR: wrong frin_to_be_sent\n");
+			}
+
+			/* continue if the port is not owned by linux */
+			if (priv->own == 0)
+				continue;
+
+			if (!atomic_read(frin_to_be_sent))
+				goto skip;
+			if (rmi_vits_program_rx_desc(priv->slot, 1) ==
+				VITS_PROGRAM_RX_DESC_SUCCESS) {
+				atomic_dec(frin_to_be_sent);
+			}
+			continue;
+		  skip:
+			done++;
+		}
+		if (done == RMI_SPI4_MAX_PORTS)
+			break;
+	}
+	return;
+}
+
+/*******************************************************************************
+* Function name :    	rmi_vits_rx_tx_done
+* Input         :
+* Description   :       This function handles the TX DONE and RX IND. It keeps
+*	track the RX desc to be replenish, if it crosses the water mark then
+*	schedules the replenish work item.
+* RETURNS       :       void
+*******************************************************************************/
+
+void rmi_vits_rx_tx_done(uint32 cmd, uint32 slot,
+						 uint32 port, char *addr, uint32 len, uint32 error)
+{
+	struct net_device *dev;
+	struct sk_buff *skb = 0;
+	int cpu;
+	driver_data *priv;
+	unsigned int eth_interface;
+
+	cpu = phoenix_cpu_id();
+	switch (cmd) {
+		case SPI4_TX_DONE:
+			/*in TX_DONE case, port indicates bucket */
+			skb = (struct sk_buff *) addr;
+
+			if (skb == NULL) {
+				printk("ERROR - TX_DONE: null skb \n");
+				return;
+			}
+			priv = netdev_priv(skb->dev);
+			eth_interface = priv->port;
+			spin_lock(&pending_tx_lock[eth_interface]);
+			if (netif_queue_stopped(skb->dev)) {
+				netif_wake_queue(skb->dev);
+			}
+			spin_unlock(&pending_tx_lock[eth_interface]);
+			os_free(skb);
+			break;
+		case SPI4_RX_IND:
+#if RMI_SPI4_DEBUG
+			printk("[%s]RX_IND :   port=%d\n", __func__, priv->port);
+#endif
+
+			if (slot == SPI4_0) {
+				eth_interface = port;
+			}
+			else if (slot == SPI4_1) {
+				eth_interface = port + RMI_SPI4_PORTS_PER_CARD;
+			}
+			else {
+				printk("[%s] ERROR!!! invalid slot\n", __func__);
+				return;
+			}
+			dev = spi4_dev[eth_interface];
+			if (dev == NULL) {
+				printk("[%s]ERROR!! eth interface=%d , port=%d , \
+					not registered\n", __func__, eth_interface, port);
+				return;
+			}
+
+			priv = netdev_priv(dev);
+			skb = spi4_get_skb_back_ptr((unsigned long) addr);
+			if (!skb) {
+				printk("NULL skb pointer in RX handling\n");
+				return;
+			}
+			skb->dev = dev;
+			skb_reserve(skb, MAC_PREPAD + SPI4_BYTE_OFFSET);
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, skb->dev);
+			/* schedule work to do replenishing */
+			if (atomic_inc_return(&priv->frin_to_be_sent[cpu]) >
+				SPI4_FRIN_THRESHOLD) {
+				schedule_work(&vits_frin_replenish_work[cpu]);
+			}
+
+#if RMI_SPI4_DEBUG
+			{
+				int loop;
+				printk("[%s] skb: len=%d, data is:\n",
+					   __func__, skb->len);
+				for (loop = 0; loop < skb->len; loop++)
+					printk("%x  ", skb->data[loop]);
+				printk("\n");
+
+			}
+#endif
+			netif_rx(skb);
+			break;
+	}
+	return;
+}
+
+
+
+/****************************************************************************
+* Function name :       spi4_check_daughter_cards
+* Input         :
+* Description   :       This function reads the cpld register and checks
+*                       whether any spi4 daughter card present on the board.
+* RETURNS       :       0-if no spi4 cards present
+*                       1-if only spi4-A present
+*                       2-if only spi4-B present
+*                       3-if both spi4-A and spi4-B present
+****************************************************************************/
+unsigned char spi4_check_daughter_cards(void)
+{
+	unsigned char value, flag = 0;
+	unsigned long cpld_base;
+	unsigned char *mmio;
+
+	cpld_base = (unsigned long) (PHOENIX_CPLD_OFFSET);
+	mmio = (unsigned char *) cpld_base;
+	value = phoenix_read_reg(mmio, CPLD_MISC_STATUS_REG);
+
+
+	value = value >> 3;
+	if (!(value & SPI4_MASK_BIT1))
+		flag = 1;
+
+	value = value >> 1;
+	if (!(value & SPI4_MASK_BIT1))
+		flag |= 2;
+
+	return flag;
+
+}
+
+/*******************************************************************************
+* Function name :	rmi_vits_common_init
+* Input         :
+* Description   :       This function calls the spi4 drivers functions to
+*	ititilize the spi4, configure spills and programs RX desc.
+* RETURNS       :       void
+*******************************************************************************/
+
+int rmi_vits_common_init(unsigned int slot)
+{
+	unsigned int spi4_ret_value;
+	static int work_init = 0;
+
+
+	spi4_ret_value =
+		spi4_init(slot, (spi4_callback_func) rmi_vits_rx_tx_done);
+	if (spi4_ret_value != SPI4_INIT_SUCCESS)
+		return spi4_ret_value;
+
+	if (!xlr_hybrid_user_mac()) {
+		spi4_ret_value = rmi_vits_program_rx_desc(slot,
+												  (int) MAX_NUM_DESC *
+												  XLR_TOTAL_CHANNELS);
+		if (spi4_ret_value != VITS_PROGRAM_RX_DESC_SUCCESS) {
+			return spi4_ret_value;
+		}
+	}
+
+	spi4_ret_value = spi4_open(slot);
+	if (spi4_ret_value != SPI4_OPEN_SUCCESS) {
+		return spi4_ret_value;
+	}
+
+	if (xlr_hybrid_user_mac())
+		return VITS_COMMON_INIT_SUCCESS;
+
+	if (!work_init) {
+		for (slot = 0; slot < RMI_SPI4_MAX_CPUS; slot++) {
+			INIT_WORK(&vits_frin_replenish_work[slot],
+					  rmi_vits_frin_replenish);
+		}
+		work_init = 1;
+	}
+	return VITS_COMMON_INIT_SUCCESS;
+}
+
+/*******************************************************************************
+* Function name :      	rmi_vits_init
+* Input         :
+* Description   :       This function allocates the dev data structure for the
+*	eth drivers and initializes it
+* RETURNS       :       void
+*******************************************************************************/
+
+int rmi_vits_init(void)
+{
+	unsigned int slot, port_start, port_end;
+	struct net_device *dev = 0;
+	driver_data *priv = 0;
+
+	int i = 0;
+	int ret = 0, port_register_flag = 0;
+	int spi4_own = 1, spi4_list = 0x0;
+	unsigned long spi4_addr;
+
+	if (xlr_hybrid_rmios_tcpip_stack())
+		return -1;
+
+	if (xlr_hybrid_user_mac())
+		printk("Initializing spi4 driver in hybrid mode\n");
+	else
+		printk("Initializing spi4 ethernet driver\n");
+
+	if (!(xlr_board_atx_i()) || is_xls()) {
+		printk(KERN_INFO "This board does not support spi4\n");
+		return -1;
+	}
+
+	g_spi4_card_flag = spi4_check_daughter_cards();
+
+	if (!g_spi4_card_flag) {
+		printk(KERN_INFO "rmi_spi4: No SPI4 cards detected\n");
+		return -1;
+	}
+
+	for (slot = 0; slot < RMI_SPI4_MAX_SLOTS; slot++) {
+		if (spi4_slot[slot] == INVALID_SLOT)
+			continue;
+
+		if (!(g_spi4_card_flag & (1 << slot)))
+			continue;
+
+		/* No need to register the device this spi4 slot is disabled 
+		   Register the device if it exist . */
+		if (dev_tree_en) {
+			fdt_get_spi4_ppties(slot, &spi4_list, &spi4_addr, &spi4_own);
+			if (!spi4_list)
+				continue;
+		}
+
+		printk("<0>initializing spi4-%d\n", slot);
+		if (spi4_own
+			&& (rmi_vits_common_init(slot) != VITS_COMMON_INIT_SUCCESS)) {
+			printk("initialization failed for spi4-%d\n", slot);
+			continue;
+		}
+
+		if (slot == SPI4_0) {
+			port_start = 0;
+			port_end = RMI_SPI4_PORTS_PER_CARD;
+		}
+		else if (slot == SPI4_1) {
+			port_start = 0 + RMI_SPI4_PORTS_PER_CARD;
+			port_end = RMI_SPI4_MAX_PORTS;
+		}
+		else {
+			port_start = port_end = 0;
+		}
+		for (i = port_start; i < port_end; i++) {
+			if ((active_port[i].slot == INVALID_SLOT) ||
+				(active_port[i].port == INVALID_PORT))
+				continue;
+
+			if (!xlr_hybrid_user_mac())
+				printk("Registering spi%d eth interface\n", i);
+
+			dev = alloc_etherdev(sizeof(driver_data));
+			if (!dev) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			spi4_dev[i] = dev;
+			priv = netdev_priv(dev);
+			priv->dev = dev;
+			ether_setup(dev);
+
+			sprintf(dev->name, "%s%d", "spi", i);
+			dev->open = rmi_vits_open;
+			dev->hard_start_xmit = rmi_vits_xmit;
+			dev->stop = rmi_vits_close;
+			dev->get_stats = rmi_vits_get_stats;
+
+			/* initializing priv member */
+			spin_lock_init(&priv->lock);
+			priv->port = (uint) active_port[i].port;
+			priv->slot = (uint) active_port[i].slot;
+			if (priv->slot == SPI4_0) {
+				priv->spi4_port = priv->port;
+			}
+			else {
+				priv->spi4_port = priv->port - RMI_SPI4_PORTS_PER_CARD;
+			}
+			priv->type = (uint) TYPE_SPI4;
+			/*this is the default link configuration */
+			priv->speed = SPEED_100M;
+			priv->duplex = 1;
+			priv->autoneg = 1;
+			priv->own = spi4_own;
+
+			dev->dev_addr[0] = 0x0;
+			dev->dev_addr[1] = 0x0f;
+			dev->dev_addr[2] = 0x30;
+			dev->dev_addr[3] = 0x00;
+			dev->dev_addr[4] = 0x01;
+			dev->dev_addr[5] = i;
+
+			if (!xlr_hybrid_user_mac()) {
+				ret = register_netdev(dev);
+				if (ret) {
+					printk("Unable to register %s  eth interface \n",
+						   dev->name);
+					free_netdev(dev);
+					continue;
+				}
+				printk("%s eth interface is registered\n", dev->name);
+				set_ethtool_ops(dev);
+			}
+			else {
+				rmi_vits_open(dev);
+			}
+			port_register_flag = 1;
+		}
+	}
+
+	if (port_register_flag) {
+		/* starting a timer to monitor the link */
+		init_timer(&link_monitor_timer);
+		link_monitor_timer.expires = jiffies + 2 * HZ / 100;
+		link_monitor_timer.function = rmi_link_monitor;
+		add_timer(&link_monitor_timer);
+	}
+  out:
+	if (ret < 0) {
+		printk("Error, ret = %d\n", ret);
+	}
+	return ret;
+}
+
+
+
+void rmi_vits_exit(void)
+{
+	struct net_device *dev;
+	int i;
+
+	for (i = 0; i < RMI_SPI4_MAX_PORTS; i++) {
+		dev = spi4_dev[i];
+		if (!dev)
+			continue;
+		printk("unregistering dev%d\n", i);
+		unregister_netdev(dev);
+		free_netdev(dev);
+	}
+}
+
+/*******************************************************************************
+* Function name :       spi4_get_settings
+* Input         :
+* Description   :       This function provides info about speed, duplexity,
+*	autoneg to ethtool commands.
+* RETURNS       :       void
+*******************************************************************************/
+
+static int spi4_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
+{
+
+	driver_data *priv = netdev_priv(dev);
+
+
+	ecmd->supported = (SUPPORTED_10baseT_Half |
+					   SUPPORTED_10baseT_Full |
+					   SUPPORTED_100baseT_Half |
+					   SUPPORTED_100baseT_Full |
+					   SUPPORTED_1000baseT_Full | SUPPORTED_Autoneg);
+
+	ecmd->advertising = ADVERTISED_TP;
+
+	switch (priv->speed) {
+		case SPEED_1000M:
+			ecmd->speed = SPEED_1000;
+			break;
+
+		case SPEED_100M:
+			ecmd->speed = SPEED_100;
+			break;
+
+		case SPEED_10M:
+			ecmd->speed = SPEED_10;
+			break;
+
+	}
+	ecmd->duplex = priv->duplex;
+	ecmd->port = priv->port;
+	ecmd->autoneg = priv->autoneg;
+	return 0;
+}
+
+/*******************************************************************************
+* Function name :       spi4_set_settings
+* Input         :
+* Description   :       This function provides ethtool to set speed, duplexity,
+*       autoneg to ethtool commands.
+* RETURNS       :       void
+*******************************************************************************/
+
+static int
+spi4_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)
+{
+
+	unsigned int flags;
+	driver_data *priv = netdev_priv(netdev);
+	vtss_phy_control_t phy_cnt;
+	int speed, driver_speed;
+	int ret = 0;
+	int port;
+	vtss_pcs_autoneg_control_t autoneg;
+
+	/*
+	   only speed and duplexity parameters are supported
+	 */
+	spin_lock_irqsave(&base_change, flags);
+	port = active_port[ecmd->port].port;
+	if (port == INVALID_PORT) {
+		spin_unlock_irqrestore(&base_change, flags);
+		return -EINVAL;
+	}
+	change_vits_base(port);
+	port++;						/* this is to make the vtss APIs to get the correct PHY port */
+	if (vtss_phy_control_get(port, &phy_cnt) == VTSS_OK) {
+#if RMI_SPI4_DEBUG
+		printk("phy status read success\n");
+#endif
+	}
+	else {
+		spin_unlock_irqrestore(&base_change, flags);
+#if RMI_SPI4_DEBUG
+		printk("phy status read failed\n");
+#endif
+		return 1;
+	}
+
+
+	if (ecmd->autoneg == AUTONEG_ENABLE) {
+		phy_cnt.autoneg_enable = 1;
+	}
+	else {
+		phy_cnt.autoneg_enable = 0;
+	}
+	if (priv->autoneg != phy_cnt.autoneg_enable) {
+		/*changeing the autoneg */
+		autoneg.enable = phy_cnt.autoneg_enable;
+		if (vtss_pcs_autoneg_control_set(port, &autoneg) == VTSS_OK) {
+			priv->autoneg = phy_cnt.autoneg_enable;
+		}
+		else {
+			spin_unlock_irqrestore(&base_change, flags);
+			return 1;
+		}
+	}
+	phy_cnt.fdx = ecmd->duplex;
+	switch (ecmd->speed) {
+		case SPEED_1000:
+			speed = (int) VTSS_SPEED_1G;
+			driver_speed = SPEED_1000M;
+			break;
+		case SPEED_100:
+			speed = (int) VTSS_SPEED_100M;
+			driver_speed = SPEED_100M;
+			break;
+		case SPEED_10:
+			speed = (int) VTSS_SPEED_10M;
+			driver_speed = SPEED_10M;
+			break;
+		default:
+			spin_unlock_irqrestore(&base_change, flags);
+			return -EINVAL;
+	}
+
+	phy_cnt.speed = speed;
+	if (vtss_port_set_mode(port, speed, ecmd->duplex) != VTSS_OK) {
+		ret = 1;
+	}
+	if (ret) {
+		/*mac speed is not success so, no need to change phy speed */
+		return ret;
+	}
+
+	if (vtss_phy_control_set(port, &phy_cnt) != VTSS_OK) {
+		ret = 1;
+	}
+
+	if (ret == 0) {
+		/*update the speed, and duplexity */
+		priv->speed = driver_speed;
+		priv->duplex = ecmd->duplex;
+	}
+
+	spin_unlock_irqrestore(&base_change, flags);
+	return ret;
+}
+
+
+static void
+spi4_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
+{
+
+	printk("[%s]: \n", __func__);
+	strcpy(drvinfo->driver, DRV_NAME);
+	strcpy(drvinfo->version, DRV_VERSION);
+	strcpy(drvinfo->fw_version, "N/A");
+	return;
+}
+
+struct ethtool_ops spi4_ethtool_ops = {
+	.get_settings = spi4_get_settings,
+	.set_settings = spi4_set_settings,
+	.get_drvinfo = spi4_get_drvinfo
+};
+
+void set_ethtool_ops(struct net_device *netdev)
+{
+	SET_ETHTOOL_OPS(netdev, &spi4_ethtool_ops);
+}
+
+module_init(rmi_vits_init);
+module_exit(rmi_vits_exit);
diff --git a/drivers/net/rmi_spi4/rmi_vits_eth.h b/drivers/net/rmi_spi4/rmi_vits_eth.h
new file mode 100644
index 0000000..87680db
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_eth.h
@@ -0,0 +1,153 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_VITS_ETH_H
+#define _ASM_RMI_VITS_ETH_H
+
+#include "rmi_spi4.h"
+
+#define INVALID_SLOT 	100
+#define INVALID_PORT	100
+
+#define RMI_SPI4_MAX_PORTS 20 
+#define RMI_SPI4_MAX_SLOTS 2
+
+#define PORT_0 0
+#define PORT_1 1
+#define PORT_2 2
+#define PORT_3 3 
+#define PORT_4 4
+#define PORT_5 5
+#define PORT_6 6
+#define PORT_7 7
+#define PORT_8 8
+#define PORT_9 9
+#define PORT_10 10
+#define PORT_11 11
+#define PORT_12 12
+#define PORT_13 13
+#define PORT_14 14
+#define PORT_15 15 
+#define PORT_16 16
+#define PORT_17 17
+#define PORT_18 18
+#define PORT_19 19
+
+struct spi4_port{
+	int	slot; /* value should be either SPI4_0 or SPI4_1 */
+	int port;
+	unsigned long	io_base;
+};
+
+int spi4_slot[] = {SPI4_0,SPI4_1};
+static struct spi4_port active_port[] = {
+	{
+		.slot=SPI4_0,
+		.port=PORT_0
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_1
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_2
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_3
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_4
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_5
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_6
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_7
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_8
+	},
+	{
+		.slot=SPI4_0,
+		.port=PORT_9
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_10
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_11
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_12
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_13
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_14
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_15
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_16
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_17
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_18
+	},
+	{
+		.slot=SPI4_1,
+		.port=PORT_19
+	},
+
+};
+#endif /* _ASM_RMI_VITS_ETH_H */
diff --git a/drivers/net/rmi_spi4/rmi_vits_wrapper.c b/drivers/net/rmi_spi4/rmi_vits_wrapper.c
new file mode 100644
index 0000000..1924cfb
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_wrapper.c
@@ -0,0 +1,84 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <asm/rmi/iomap.h>
+#include "rmi_vits_wrapper.h"
+#include <asm/rmi/debug.h>
+
+volatile unsigned int *megis = (unsigned int*)(long)VITESS_BASE_ADDR_1;
+
+/* function to setup CS_2 area correctly */
+void megis_phoenix_init(int vitess_device) 
+{
+	if (vitess_device == 1)
+		megis = (unsigned int*)(long)VITESS_BASE_ADDR_1;
+
+	if (vitess_device == 2)
+		megis = (unsigned int*)(long)VITESS_BASE_ADDR_2;
+	return;
+}  
+
+/* function to convert from littleE to bigE */
+unsigned int swizzle(unsigned int _in) 
+{
+	unsigned int i;
+	i = (((_in & 0xff00ff00) >> 8) | ((_in & 0x00ff00ff) << 8));
+	return i;
+}
+
+/* lower level register write routines */
+void megis_write(unsigned int _block, unsigned int _sub, 
+		unsigned int _addr, unsigned int value) 
+{
+	int lvalue = swizzle(value);
+	megis[(  (_block << 12) + (_sub << 8) + (_addr))] = lvalue; 
+	return;
+}
+
+/* lower level register read routine */
+unsigned int megis_read(unsigned int _block, unsigned int _sub, 
+			unsigned int _addr) 
+{
+	unsigned int i;
+	i =  megis[((_block << 12) + (_sub << 8) + (_addr))];
+	i = swizzle(i);
+	return i;
+}
+
+/* lower level posted register read routine */
+unsigned int megis_pread(unsigned int _block, unsigned int _sub, 
+							unsigned int _addr) 
+{
+	unsigned int i;
+	i =  megis[((_block << 12) + (_sub << 8) + (_addr))];
+	i =  megis[((_block << 12) + (_sub << 8) + (0xfe))];
+	i = swizzle(i);
+	return i;
+}
diff --git a/drivers/net/rmi_spi4/rmi_vits_wrapper.h b/drivers/net/rmi_spi4/rmi_vits_wrapper.h
new file mode 100644
index 0000000..a88295c
--- /dev/null
+++ b/drivers/net/rmi_spi4/rmi_vits_wrapper.h
@@ -0,0 +1,45 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_VITS_WRAPPER_H
+#define _ASM_RMI_VITS_WRAPPER_H 
+
+#define VITESS_BASE_ADDR_1 0xffffffffBD800000ULL
+#define VITESS_BASE_ADDR_2 0xffffffffBD820000ULL
+
+/* lower level access functions */
+void megis_phoenix_init(int vitess_device);
+unsigned int swizzle(unsigned int _in);
+void megis_write(unsigned int _block, unsigned int _sub, 
+					unsigned int _addr, unsigned int value);
+unsigned int megis_read(unsigned int _block, unsigned int _sub, unsigned int _addr);
+unsigned int megis_pread(unsigned int _block, unsigned int _sub, unsigned int _addr);
+
+#endif /* _ASM_RMI_VITS_WRAPPER_H */
diff --git a/drivers/net/rmi_spi4/vitesse_common.h b/drivers/net/rmi_spi4/vitesse_common.h
new file mode 100644
index 0000000..644b11c
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_common.h
@@ -0,0 +1,271 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/*
+
+ vitesse_common.h  -- Vitesse common definitions
+
+ This file is used by the Vitesse Switch/Mac API software.
+ Modify it to fit your configuration.
+
+ Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
+ Unpublished rights reserved under the copyright laws of the United States of 
+ America, other countries and international treaties. The software is provided
+ without fee. Permission to use, copy, store, modify, disclose, transmit or 
+ distribute the software is granted, provided that this copyright notice must 
+ appear in any copy, modification, disclosure, transmission or distribution of 
+ the software. Vitesse Semiconductor Corporation retains all ownership, 
+ copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
+ HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
+ WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
+ PARTICULAR USE AND NON-INFRINGEMENT.
+ 
+*/
+#include <linux/types.h>
+
+#define VSC7323
+
+#ifndef _VITESSE_COMMON_H
+#define _VITESSE_COMMON_H 
+
+/* ================================================================= *
+ *  Basic types:
+ *    uint, ulong, ushort, uchar - unsigned standard types.
+ *    longlong, ulonglong - 64 bit integers.
+ *    BOOL - The boolean type. false: 0, true: anything but 0.
+ * ================================================================= */
+
+typedef unsigned char       uchar;
+
+#ifdef __GNUC__
+typedef long long           longlong;
+typedef unsigned long long  ulonglong;
+#endif /* __GNUC__ */
+#ifdef _MSC_VER
+typedef __int64             longlong;
+typedef unsigned __int64    ulonglong;
+#endif /* _MSC_VER */
+
+typedef int     	        BOOL;
+
+/* ================================================================= *
+ *  Custom types
+ * ================================================================= */
+
+/* Big counter type, may be 32 or 64 bits depending on the OS */
+/* You may redefine it to ulong or ulonglong */
+typedef ulonglong vtss_counter_t;
+
+
+/* ================================================================= *
+ *  Macros:
+ *    VTSS_ASSERT(expr) - Call assert(expr).
+ *    VTSS_NSLEEP(nsec) - Sleep at least nsec nanoseconds.
+ *    VTSS_MSLEEP(msec) - Sleep at least msec milliseconds.
+ *  Notes:
+ *    VTSS_NSLEEP uses busy waiting, so it should only be used for
+ *    very short intervals.
+ *    VTSS_MSLEEP should not use busy waiting, but may do so.
+ * ================================================================= */
+
+/* VTSS_ASSERT(expr): Call assert(). */
+#if !defined(VTSS_ASSERT)
+/* You may define your own VTSS_ASSERT here. */
+#endif
+
+#ifndef _POSIX_C_SOURCE
+#define _POSIX_C_SOURCE 0
+#endif
+
+#if !defined(VTSS_ASSERT) && (_POSIX_C_SOURCE > 0)
+#include <assert.h>
+#define VTSS_ASSERT(expr) { assert(expr); }
+#endif
+
+/* - VTSS_NSLEEP(nsec) -------------------------------------------------- */
+#define VTSS_NSLEEP(nsec)
+
+/* VTSS_NSLEEP(nsec): Sleep nsec nanoseconds. Use busy waiting. */
+#if !defined(VTSS_NSLEEP)
+/* You may define your own VTSS_NSLEEP here. */
+#endif
+
+#if !defined(VTSS_NSLEEP) && defined(_BSD_SOURCE)
+/* The function "gettimeofday" is available, so use it. */
+#include <sys/time.h>
+#define VTSS_NSLEEP(nsec) { \
+    struct timeval tve, tv; \
+    gettimeofday(&tve,NULL); \
+    tve.tv_usec+=(nsec+999)/1000;\
+    if (tve.tv_usec>=1000000) { tve.tv_sec+=tve.tv_usec/1000000; tve.tv_usec%=1000000; } \
+    do { gettimeofday(&tv,NULL); } \
+    while ( timercmp(&tv,&tve,<) ); \
+}
+#endif /* _BSD_SOURCE */
+#if !defined(VTSS_NSLEEP) && ( (_POSIX_C_SOURCE - 0) >= 199309L )
+/* The function "nanosleep" is available, so use it. */
+#include <time.h>
+#include <errno.h>
+#define VTSS_NSLEEP(nsec) {struct timespec ts = { 0, nsec }; while (nanosleep(&ts,&ts)==-1 && errno==EINTR) ;}
+#endif /* (_POSIX_C_SOURCE - 0) >= 199309L */
+#if !defined(VTSS_NSLEEP) && defined(_WIN32)
+#define VTSS_NSLEEP(nsec) {VOID Sleep(DWORD); Sleep((nsec+999999)/1000000);}
+#endif /* _WIN32 */
+/* VTSS_NSLEEP is required by the API. */
+#if defined(__VTSS_LIBRARY__) && !defined(VTSS_NSLEEP)
+#error Macro function VTSS_NSLEEP must be defined in vitesse_common.h.
+#endif /* __VTSS_LIBRARY__ && !VTSS_NSLEEP */
+
+/* - VTSS_MSLEEP(msec) -------------------------------------------------- */
+#define VTSS_MSLEEP(msec)
+
+/* VTSS_MSLEEP(msec): Sleep msec milliseconds. Avoid busy waiting. */
+#if !defined(VTSS_MSLEEP)
+/* You may define your own VTSS_MSLEEP here. */
+#endif
+
+#if !defined(VTSS_MSLEEP) && ( (_POSIX_C_SOURCE - 0) >= 199309L )
+/* The function "nanosleep" is available, so use it. */
+#include <time.h>
+#include <errno.h>
+#define VTSS_MSLEEP(msec) { \
+    struct timespec ts; \
+    ts.tv_sec = msec/1000; \
+    ts.tv_nsec = (msec%1000)*1000000; \
+    while (nanosleep(&ts,&ts)==-1 && errno==EINTR) ; \
+}
+#endif /* (_POSIX_C_SOURCE - 0) >= 199309L */
+#if !defined(VTSS_MSLEEP) && defined(_WIN32)
+#define VTSS_MSLEEP(msec) {VOID Sleep(DWORD); Sleep(msec);}
+#endif /* _WIN32 */
+/* VTSS_MSLEEP is required by the API. */
+#if defined(__VTSS_LIBRARY__) && !defined(VTSS_MSLEEP)
+#error Macro function VTSS_MSLEEP must be defined in vitesse_common.h.
+#endif /* __VTSS_LIBRARY__ && !VTSS_MSLEEP */
+
+
+/* ================================================================= *
+ *  Debugging Macros:
+ *    VTSS_E(args) - Error.
+ *    VTSS_D(args) - Debug.
+ *    VTSS_N(args) - Noise.
+ *
+ *    Usage Example: VTSS_E(("Port %d",port_no));
+ * ================================================================= */
+
+#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N)
+/* You may define your own VTSS_E, VTSS_D and VTSS_N here. */
+#endif
+
+#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N) && defined(SWITCH_APP_TRACE)
+/* Debugging for an VTSS internal application. */
+#include <stdio.h>
+#include <stdarg.h>
+
+extern const char *vtss_trace_func;
+extern int vtss_trace_line;
+extern int vtss_trace_layer;
+extern int vtss_trace_level;
+void vtss_api_trace(int level, BOOL debug, const char *func, int line, char *msg);
+void vtss_trace(const char *fmt, ...);
+
+#define E(args); {vtss_trace_level=1, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__func__; vtss_trace_line=__LINE__; vtss_trace args;}
+#define D(args); {vtss_trace_level=2, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__func__; vtss_trace_line=__LINE__; vtss_trace args;}
+#define N(args); {vtss_trace_level=3, vtss_trace_layer=VTSS_TRACE_LAYER, vtss_trace_func=__func__; vtss_trace_line=__LINE__; vtss_trace args;}
+#endif
+
+#if !defined(VTSS_E) && !defined(VTSS_D) && !defined(VTSS_N)
+#if (_POSIX_C_SOURCE > 0)
+/* Fallback to debugging using printf. */
+#include <stdio.h>
+#define VTSS_E(args) { printf("E:%s#%d: ",__func__,__LINE__); printf args; printf("\n"); }
+#define VTSS_D(args) { printf("D:%s#%d: ",__func__,__LINE__); printf args; printf("\n"); }
+#define VTSS_N(args) { printf("N:%s#%d: ",__func__,__LINE__); printf args; printf("\n"); }
+#else
+/* Fallback to no debugging. */
+#define VTSS_E(args)
+#define VTSS_D(args)
+#define VTSS_N(args)
+#endif
+#endif
+
+
+/* ================================================================= *
+ *  No changes should be needed below this line
+ * ================================================================= */
+
+#if !defined(MEIGS2) && !defined(MEIGS2E) && !defined(CAMPBELL) && \
+    !defined(VSC7321) && !defined(VSC7323) && !defined(VSC7331) 
+#warning Device MEIGS2, MEIGS2E, CAMPBELL, VSC7321, VSC7323 or VSC7331 should be defined.
+#endif
+
+/* ================================================================= *
+ *  Various definitions and macros
+ * ================================================================= */
+
+/* MAKEBOOL01(value): Convert BOOL value to 0 (false) or 1 (true). */
+/* Use this to ensure BOOL values returned are always 1 or 0. */
+#ifndef MAKEBOOL01
+#define MAKEBOOL01(value) ((value)?1:0)
+#endif
+#ifndef TRUE
+#define TRUE MAKEBOOL01(1)
+#endif
+#ifndef FALSE
+#define FALSE MAKEBOOL01(0)
+#endif
+
+/* - Basic defines/macros: NULL, offsetof() ------------------------ */
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+#endif
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+/* - Compiler Hints ------------------------------------------------ */
+
+#ifdef __GNUC__
+/* "__attribute__ ((const))" informs the GNU C compiler that a
+ * function does not change any states anywhere
+ */
+#define __VTSS_ATTRIB_CONST_FUNCTION__ __attribute__ ((const))
+#else
+#define __VTSS_ATTRIB_CONST_FUNCTION__ /* no "const" compiler hint */
+#endif
+
+
+/* ================================================================= *
+ *  Private data and functions (used internally by VTSS library)
+ * ================================================================= */
+#ifdef __VTSS_LIBRARY__
+
+/* - Compiler Hints ------------------------------------------------ */
+
+#ifdef __GNUC__
+/* "__attribute__ ((unused))" informs the GNU C compiler that a
+ * variable is not used, so we don't get a warning about it
+ */
+#define __VTSS_ATTRIB_UNUSED_VARIABLE__ __attribute__ ((unused))
+#else
+#define __VTSS_ATTRIB_UNUSED_VARIABLE__ /* no "unused" compiler hint */
+#endif
+
+#endif /* __VTSS_LIBRARY__ */
+
+#endif /* _VITESSE_COMMON_H_ */
diff --git a/drivers/net/rmi_spi4/vitesse_highlevel.c b/drivers/net/rmi_spi4/vitesse_highlevel.c
new file mode 100644
index 0000000..6b89043
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_highlevel.c
@@ -0,0 +1,4611 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/************************************************************-*- mode: C -*-*/
+/*                                                                          */
+/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
+/*                           All Rights Reserved.                           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                            Copyright Notice:                             */
+/*                                                                          */
+/*  Unpublished rights reserved under the copyright laws of the United      */
+/*  States of America, other countries and international treaties.          */
+/*                                                                          */
+/*      The software is provided without fee.                               */
+/*                                                                          */
+/*  Permission to use,  copy, store, modify, disclose, transmit or          */
+/*  distribute the software is granted, provided that this copyright notice */
+/*  must appear in any copy, modification, disclosure, transmission or      */
+/*  distribution of the software.                                           */
+/*                                                                          */
+/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
+/*  trade secret and proprietary rights in the software.                    */
+/*                                                                          */
+/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
+/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
+/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
+/*                                                                          */
+/*    $Id: vitesse_highlevel.c,v 1.1.2.6 2008/05/22 02:59:56 kmurthy Exp $         */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*  File content:                                                           */
+/*                                                                          */
+/*  vitesse_highlevel.c -- a set of functions for configuration of various  */
+/*                  system features in a MeigsII/MeigsIIe/Campbell chip     */
+/*                                                                          */
+/****************************************************************************/
+#define __MEIGSII_LIBRARY__
+
+
+
+#include "vitesse_highlevel.h"
+#include "meigsii_reg.h"
+#include "vitesse_io.h"
+#include <asm/rmi/debug.h>
+#include <linux/kernel.h>
+
+#define SET_BIT( A,SHIFT)    A |=  ((ulong)1<<SHIFT)
+#define CLR_BIT( A,SHIFT)    A &= ~((ulong)1<<SHIFT)
+
+#define SET_BITS_MASKED( result, value, mask)  \
+	result = (result & ~(mask))|(value & mask)
+
+
+/****************************************************************************/
+/*                                                                          */
+/*   Type definitions                                                       */
+/*                                                                          */
+/****************************************************************************/
+typedef struct _vtss_device_setup_t {
+
+	vtss_mac_major_mode_t    mmode;
+	ulong                    chip_id;
+
+} vtss_device_setup_t;
+
+/*
+   The related NLE bit selects the way data is transmitted internally in the 
+   device and is always used when the normalized header is used.
+ */
+typedef struct _m2_header_t {
+
+	BOOL use_norm_hdr;
+	BOOL use_prm_hdr;
+	/*
+	   BOOL mpls_normalize;
+	   BOOL vlan_normalize;
+	 */
+} m2_header_t;
+
+
+/* control of the use of header in ingress direction */
+static vtss_rc vtss_hdr_insert( BOOL enable, m2_header_t hdr);
+
+/* Enabling/disabling use of the header in different blocks */
+static void vtss_fifo_use_hdr( int fifo, BOOL enable, m2_header_t hdr);
+
+static void vtss_aggr_use_header( BOOL enable, m2_header_t hdr);
+
+
+static void vtss_port10G_header_insert( BOOL enable, m2_header_t hdr);
+
+static void vtss_port1G_header_insert( int ppn, BOOL enable, 
+		const m2_header_t hdr);
+
+/* vtss_rc vtss_device_major_mode_setup( vtss_mac_major_mode_t mm); */
+
+
+/****************************************************************************/
+/*                                                                          */
+/*   Global data                                                            */
+/*                                                                          */
+/****************************************************************************/
+
+static vtss_mapped_port_t vtss_logical_ports[VTSS_PORT_ARRAY_SIZE] = {
+	{ -1, -1, -1},
+	{ -1, -1, -1},
+};
+
+static vtss_device_setup_t vtss_device_setup = {
+	VTSS_MAC_MAJOR_MODE_UNDEFINED,
+	0,  /* chip id */
+};
+
+
+/* Current state of 1G ports */
+static vtss_port_setup_t vtss_1G_ports_setup[VTSS_PORT_ARRAY_SIZE];/* = {} */
+
+
+/* Pointer to the global device setup structure */
+static vtss_device_setup_t *pdevice = &vtss_device_setup;
+
+
+/*******************************************************************************
+
+  Function vtss_port_map_set()
+  =================================================================================
+
+	Description:
+	The function initializes internally kept port mapping structure based on 
+	the information received from the user 
+
+
+	Syntax
+	vtss_rc  vtss_port_map_set( const vtss_mapped_port_t 
+	mapped_ports[VTSS_PORT_ARRAY_SIZE]);
+
+	Arguments:
+	mapped_ports    an array mapping logical port numbers to physical 
+	(on-chip) port numbers, MIIM controller channel and
+	PHY addresses.
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+
+ *******************************************************************************/
+vtss_rc vtss_port_map_set( const vtss_mapped_port_t 
+		mapped_ports[VTSS_PORT_ARRAY_SIZE])
+{
+	int i;
+	for (i=0;i<VTSS_PORT_ARRAY_SIZE; i++) {
+		vtss_logical_ports[i] = mapped_ports[i];
+	}
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function vtss_port_mapped()
+  =================================================================================
+
+	Description:
+	Checks whether the logical port is mapped to any physical port or not.
+
+	Syntax
+	BOOL vtss_port_mapped( const vtss_port_no_t port_no )
+
+	Arguments:
+	port_no     logical port number
+
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+
+ *******************************************************************************/
+BOOL vtss_port_mapped( const vtss_port_no_t port_no )
+{
+	return (vtss_logical_ports[port_no].chip_port != -1);
+}
+
+
+/*******************************************************************************
+
+  Function vtss_chip_reset()
+	================================================================================
+
+	Description:
+	Performs a software reset of the chip
+
+
+	Syntax
+	void vtss_chip_reset(void);
+
+	Arguments:
+	None
+
+	Return code:
+	None
+
+*******************************************************************************/
+void vtss_chip_reset(void)
+{
+
+	/* Reset the chip */
+	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_SW_RESET, M2_SW_GLOBAL_RESET);
+	VTSS_NSLEEP(VTSS_T_RESET);
+
+}
+
+
+/*******************************************************************************
+
+  Function vtss_get_chip_id()
+	================================================================================
+
+	Description:
+	Returns the content of the chip identification register
+
+	NOTE: -----------------------------    
+	|  device         chip id   |
+	-----------------------------
+	|  VSC7321       0x0F407321 |
+	|  VSC7323       0x073230E9 |
+	|  VSC7331       0x073310E9 |
+	-----------------------------
+
+	Syntax
+	ulong vtss_chip_id_get(void);
+
+
+	Arguments:
+	None
+
+
+	Return code:
+	The content of the chip identification register.
+
+ *******************************************************************************/
+ulong vtss_chip_id_get(void)
+{
+	vtss_device_setup_t *pvds = pdevice;
+	pvds->chip_id = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CHIPID);
+	return pvds->chip_id;
+}
+
+
+/*******************************************************************************
+
+  Function vtss_major_mode_set( )
+  ================================================================================
+
+	Description:
+	Prepares the system to run in one of the major modes.
+	This function must be called only once after reset. If the function is 
+	called when the system is up and running it will return an error.
+	It is not allowed to call this function with VTSS_MAC_MAJOR_MODE_UNDEFINED
+	as an argument.
+
+	NOTE:
+
+
+	Syntax
+	vtss_rc vtss_major_mode_set( vtss_mac_major_mode_t mm);
+
+	Arguments:
+	mm     select the major mode for the session
+
+
+	Return code:
+	VTSS_OK                  successful completion
+	VTSS_WRONG_PARAMETER     if called after the major mode has been set
+
+ *******************************************************************************/
+vtss_rc vtss_major_mode_set( vtss_mac_major_mode_t mm)
+{
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+
+	if (mm == VTSS_MAC_MAJOR_MODE_UNDEFINED) {
+		return VTSS_WRONG_PARAMETER;
+	}
+
+	if ( VTSS_MAC_MAJOR_MODE_UNDEFINED != pvds->mmode) { 
+		return VTSS_WRONG_PARAMETER;
+	} else {
+		pvds->mmode = mm;
+	}
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ *
+ * Description: Performs several low-level initialization operations on the chip.
+ *              The function must be called after start-up or chip reset.
+ *
+ * NOTE:        This function does not perform COMPLETE initialization of the chip.
+ *
+ * \param:      psystem   pointer to a structure with configuration data
+ *
+ * \return:     VTSS_OK   if operation completed successfully or
+ *              VTSS_WRONG_PARAMETER
+ *
+ **************************************************************************kbp*/
+vtss_rc vtss_system_setup( vtss_system_setup_t *ps)
+{
+	ulong reg  = 0;
+
+	/* Setup Serial and Parallel CPU interfaces */
+	/* Assuming order of bits in a byte big-endian, 
+		however it can be changed */
+	if ( ps->big_endian == FALSE) {
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_SI_TRANSFER_SEL, M2_LTL_END_BYTE_BIG_END_BIT);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_CPU_TRANSFER_SEL, M2_LTL_END_BYTE_BIG_END_BIT);
+	} else {
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_SI_TRANSFER_SEL, M2_BIG_END_BYTE_BIG_END_BIT);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_CPU_TRANSFER_SEL, M2_BIG_END_BYTE_BIG_END_BIT);
+	}
+
+
+#if !defined MEIGS2 && !defined VSC7321
+	/* Set-up wait states on serial read when frequency > 0.5MHz 
+	   to match the chip response time on reads of 1 us. */
+	if ( ps->si_dummy_bytes < 8 ) {
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+				M2E_SI_INSERT_BYTES, ps->si_dummy_bytes);
+	} else {
+		return VTSS_WRONG_PARAMETER;
+	}
+#endif
+
+	reg = 0;
+	/* Take SerDes PLL out of reset when not in Single Channel mode */
+	if ( ps->rx_chain_mode_10G == FALSE) { SET_BIT( reg, 7); }
+
+	/* Setup SerDes reference clock sources */
+	if ( ps->serdes_ref_clk_external == FALSE) {
+		/* NB: serdes_ref_clk_external must be 
+			TRUE when using VSC7323 or VSC7331 */
+#if !defined MEIGS2 && !defined VSC7321
+		return VTSS_WRONG_PARAMETER;
+#endif
+	} else {
+		SET_BIT( reg, 1);
+	}
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+			M2_PLL_CLK_SPEED, reg, 0x82);
+
+	/* Setup System reference clock sources */
+	if ( ps->system_ref_clk_extern == FALSE) {
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_SYS_CLK_SELECT, 0);
+	} else {
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_SYS_CLK_SELECT, 1);
+	}
+
+	reg = 0;
+	/* Setup interface mode */
+	if( ps->single_chip_mode != FALSE) { SET_BIT( reg, 3); SET_BIT( reg, 2); }
+	if( ps->rx_chain_mode_10G != FALSE) { SET_BIT( reg, 1); SET_BIT( reg, 0); }
+	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, reg);
+
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ *
+ * Description: This is a supplementary function.
+ *              It configures a structure referenced by the pointer to the
+ *              default values for the chosen major mode.
+ *
+ * \param:      ps        pointer to a structure, which will be filled out
+ *              mjm       mode the device will run
+ *
+ * \return:     VTSS_OK   if operation completed successfully or
+ *
+ **************************************************************************kbp*/
+vtss_rc vtss_system_setup_get_default_values( vtss_system_setup_t *ps,
+		vtss_mac_major_mode_t mjm)
+{
+
+	/* TRUE (default):  CPU interface runs as big-endian */
+	ps->big_endian = TRUE;
+
+
+	/* Number of dummy bytes that will be inserted in the 
+	   reply before valid data when serial interface is used
+	   at high frequency. Set to 0 if not used */
+	ps->si_dummy_bytes = 0;  
+
+
+	/* Select the source of the serdes reference clock */
+	/* TRUE (default):  external source of the reference clock */
+	/* FALSE         :  internal source of the reference clock */
+	/* NOTE!!   MUST be TRUE when using VSC7323 or VSC7331 */
+	ps->serdes_ref_clk_external = TRUE;
+
+
+	/* Select the source of the system clock */
+	/* FALSE (default): system clock uses internal source */
+	/* TRUE             system clock uses GPIO15 as system clock input */
+	ps->system_ref_clk_extern = FALSE; 
+
+
+	/* Single Chip Aggregation or trunking mode */
+	if ( mjm == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR || 
+			mjm == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK) {
+		ps->single_chip_mode = TRUE; 
+	} else {
+		ps->single_chip_mode = FALSE;
+	}
+
+
+	/* Single Channel mode */
+	if ( mjm == VTSS_MAC_MAJOR_MODE_SPI4_10G) {
+		ps->rx_chain_mode_10G = TRUE;  /* SPI4.2<->10G mode */
+	} else {
+		ps->rx_chain_mode_10G = FALSE; /* all other modes */
+	}
+
+	return VTSS_OK;
+}
+
+
+/****************************************************************************/
+/*                                                                          */
+/*   1G(triple speed) port setup                                            */
+/*                                                                          */
+/****************************************************************************/
+
+
+
+/*******************************************************************************
+
+  Function 
+  ================================================================================
+
+	Description:
+	Configures 10M/100M/1G port according to the structure provided.
+
+
+	Syntax
+	vtss_rc vtss_port_setup( vtss_port_no_t portnum, vtss_port_setup_t* ps);
+
+	Arguments:
+	portnum      logical port to be initialized
+	ps           pointer to the setup structure
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+	VTSS_PORT_NOT_MAPPED
+	VTSS_MAJOR_MODE_NOT_SET
+	VTSS_WRONG_MAJOR_MODE
+	VTSS_WRONG_PARAMETER
+
+ *******************************************************************************/
+vtss_rc vtss_port_setup( vtss_port_no_t portnum, vtss_port_setup_t* ps)
+{
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+
+	ulong mode_cfg_reg = 0;
+	ulong dev_setup_reg_value = 0x80; /* Bit 7 shall be set to 1 */
+	ulong pcs_enable = 0;
+	ulong pause_reg_value = 0;
+	ulong reg = 0;
+
+	/* Some hardcoded values */
+	BOOL use_back_seed = FALSE;
+	/*  ulong backseed = 0; */
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+	/* Check the physical port number */
+	if (ppn < 0) { 
+		printk("[%s]port=%d not mapped\n",__func__,portnum);
+		return VTSS_PORT_NOT_MAPPED; 
+	}
+
+
+	/* Check major mode */
+	switch ( pvds->mmode) {
+	/* valid major modes */
+	case VTSS_MAC_MAJOR_MODE_SPI4_1G:      /* SPI4 <-> 10x1G */
+	case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:  /* Single Chip aggr */
+	case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* Single Chip trunking */
+		break;
+
+	/* Error - major mode undefined */
+	case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+		return VTSS_MAJOR_MODE_NOT_SET;
+
+	/* Error - wrong major mode */
+	case VTSS_MAC_MAJOR_MODE_SPI4_10G:     /* SPI4 <-> 1x10G */
+	case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:   /* */
+	case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+	default:
+		printk("[%s]wrong major mode=%d\n",__func__,pvds->mmode);
+		return VTSS_WRONG_MAJOR_MODE;
+	}
+
+#if defined MEIGS2 || defined VSC7321
+	/* VSC7321 (Meigs-II) requires BOTH fields being either set or cleared */
+	if (ps->flowcontrol.obey != ps->flowcontrol.generate) { return VTSS_WRONG_PARAMETER; }
+#endif
+
+	/* -------------------- Device Setup Register ------------------------ */
+
+	/* While changing speed, the port must be in reset state */
+	SET_BIT( dev_setup_reg_value, 0);
+
+	/* Select speed and interface for the device */
+	switch (ps->interface_mode.speed) {
+	case VTSS_SPEED_10M:
+		SET_BITS_MASKED( dev_setup_reg_value, M2_1G_PORT_CLOCK_MODE_10M<<1, 
+				M2_1G_PORT_CLOCK_MODE_MASK<<1);
+		break;
+	case VTSS_SPEED_100M:
+		SET_BITS_MASKED( dev_setup_reg_value, M2_1G_PORT_CLOCK_MODE_100M<<1, 
+				M2_1G_PORT_CLOCK_MODE_MASK<<1);
+		break;
+	case VTSS_SPEED_1G:
+	case VTSS_SPEED_ETH_GFPT:
+	case VTSS_SPEED_FC2_GFPT: /* 6    Gbit/s Fibre Channel */
+	case VTSS_SPEED_FC4_GFPT: /* 7    Gbit/s Fibre Channel */
+	case VTSS_SPEED_1FC_GFPT: /* 8    1Gbit/s Fibre Channel or FICON*/
+	case VTSS_SPEED_2FC_GFPT: /* 9    2Gbit/s Fibre Channel */
+	case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
+	case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
+
+	if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_SERDES) {
+		SET_BITS_MASKED( dev_setup_reg_value, 
+			M2_1G_PORT_CLOCK_MODE_1G_SERDES<<1, 
+			M2_1G_PORT_CLOCK_MODE_MASK<<1);
+
+	} else if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_TBI) {
+		SET_BITS_MASKED( dev_setup_reg_value, 
+			M2E_1G_PORT_CLOCK_MODE_TBI<<1, 
+			M2_1G_PORT_CLOCK_MODE_MASK<<1);
+
+	} else {
+		SET_BITS_MASKED( dev_setup_reg_value, 
+			M2_1G_PORT_CLOCK_MODE_1G_GMII<<1, 
+			M2_1G_PORT_CLOCK_MODE_MASK<<1);
+	}
+
+	/* Overrule setting by disable Ingress CRC updating when in GFP-T mode */
+	if (ps->interface_mode.speed != VTSS_SPEED_1G) { ps->crc_update = FALSE; }
+		break;
+
+	default:
+		printk("1G port #%d. Wrong speed: %d\n", ppn, ps->interface_mode.speed);
+		return VTSS_WRONG_PARAMETER;
+	}
+
+	/* Set-up selected interface */
+	switch ( ps->interface_mode.interface_type) {
+	case VTSS_PORT_INTERFACE_GMII:
+		/* Invert (R)GMII_TX_clock when GMII */
+		SET_BIT( dev_setup_reg_value, 6); 
+			break;
+#if !defined MEIGS2 && !defined VSC7321
+	case VTSS_PORT_INTERFACE_RGMII:
+		SET_BIT( dev_setup_reg_value, 4);   /* Enable RGMII */
+		break;
+#endif
+	case VTSS_PORT_INTERFACE_SERDES:
+		SET_BIT( pcs_enable, 0);            /* Enable Ethernet PCS */
+		break;
+	case VTSS_PORT_INTERFACE_TBI:
+		/* Disable Signal detect */
+		vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, 0, (ulong)3<<22);
+		SET_BIT( dev_setup_reg_value, 23);  /* Enable TBI */
+		SET_BIT( dev_setup_reg_value, 22);  /* Invert TBI_TX_clock when TBI */
+		SET_BIT( pcs_enable, 0);            /* Enable Ethernet PCS */
+		break;
+	default:
+		printk("1G port #%d. Wrong interface type: %d\n", 
+			ppn, ps->interface_mode.interface_type);
+		break;
+	}
+
+
+	/* -------------------- Mode config Register ------------------------ */
+
+	/* interframe gaps */  
+	SET_BITS_MASKED( mode_cfg_reg, ps->frame_gaps.ifg1 << 6, VTSS_IFG_MASK << 6);
+	SET_BITS_MASKED( mode_cfg_reg, ps->frame_gaps.ifg2 << 10, VTSS_IFG_MASK << 10);
+
+	/* duplex mode */
+	if ( ps->fdx != FALSE) {
+		SET_BIT( mode_cfg_reg, 2);
+		if (ps->interface_mode.speed == VTSS_SPEED_1G) { SET_BIT( mode_cfg_reg, 3); }
+	}
+
+	/* vlan_awr */
+	if ( ps->vlan_aware != FALSE) { SET_BIT( mode_cfg_reg, 4); }
+
+	/* drop_on_length_error */
+	if ( ps->drop_on_length_error != FALSE) { SET_BIT( mode_cfg_reg, 15); }
+
+	/* Write to device Mode configureation register */
+	vtss_io_write( M2_BLK_MACS, ppn, M2_MODE_CFG, mode_cfg_reg);
+
+	/* Clear load_seed bit */
+	if (use_back_seed) { 
+		vtss_io_writemasked( M2_BLK_MACS, ppn, 
+				M2_MODE_CFG, 0, (ulong)1<<14); 
+	}
+
+	/* -------------------- Update other Register ------------------------ */
+
+	/* Set flow control */
+	pause_reg_value = (ps->tx_pause_value & VTSS_PORT_1G_TX_PAUSE_MASK);
+	if( ps->enable_tx_pause_xon_xoff != FALSE){ 
+		SET_BIT( pause_reg_value, 17); 
+	}
+	vtss_io_write( M2_BLK_MACS, ppn, M2_PAUSE_CFG, pause_reg_value);
+
+	/* VSC7321 (Meigs-II) requires both bits to be set */
+	vtss_port_flow_control_mode( portnum, ps->flowcontrol.obey, ps->flowcontrol.generate);
+
+	/* Set-up MAC address. Will be written if flowcontrol setup is requested. */
+	if( ps->flowcontrol.obey != FALSE || ps->flowcontrol.generate != FALSE ) {
+		ulong mac_addr_low_reg = 
+			(ps->flowcontrol.smac.addr[2] << 16)| 
+			(ps->flowcontrol.smac.addr[1] <<  8)|
+			ps->flowcontrol.smac.addr[0];
+
+		ulong mac_addr_high_reg = 
+			(ps->flowcontrol.smac.addr[5] << 16)| 
+			(ps->flowcontrol.smac.addr[4] <<  8)|
+			ps->flowcontrol.smac.addr[3];
+
+		vtss_io_write( M2_BLK_MACS, ppn, M2_MAC_ADDR_HIGH_CFG, mac_addr_high_reg);
+		vtss_io_write( M2_BLK_MACS, ppn, M2_MAC_ADDR_LOW_CFG, mac_addr_low_reg);
+	}
+
+	/* Write to device max length register */
+	vtss_io_write( M2_BLK_MACS, ppn, M2_MAXLEN_CFG, 
+			ps->maxframelength & VTSS_MAX_FRAME_LENGTH_MASK);
+
+	/* Change Egress CT_THRSHLD to maxframelength when set to store&forward */
+	if (( pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_1G )|| 
+		(pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_10G )){
+		if ( vtss_io_read ( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+					M2_CT_THRHLD + ppn) == 0 ) { 
+			vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+					M2_CT_THRHLD + ppn, ps->maxframelength>>5); 
+		}
+	}
+
+	/* HOLD device clock in reset while changing the clock-mode */
+	/* vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, 0x1, 0x1); */
+
+	/* Write to device PCS config register */
+	vtss_io_write( M2_BLK_MACS, ppn, M2_PCS_CONFIG, pcs_enable);
+
+	/* Write to device setup register */
+	vtss_io_write( M2_BLK_MACS, ppn, M2_DEV_SETUP, dev_setup_reg_value);
+
+	/* Configure 1G SERDES */
+	if (ps->interface_mode.interface_type == VTSS_PORT_INTERFACE_SERDES) {
+		/* Apply RESET to SERDES. This will keep it reset */
+		vtss_io_write( 	M2_BLK_MACS, ppn, M2_SERDES_TEST, 
+				VTSS_SERDES_RESET_AND_ENABLE);
+		/* Write the serdes configuration word */
+		vtss_io_write( M2_BLK_MACS, ppn, M2_SERDES_CONF, 
+				VTSS_SERDES_CONFIG_WORD);
+		/* Take SERDES out of reset */
+		vtss_io_write( M2_BLK_MACS, ppn, M2_SERDES_TEST, 
+				VTSS_SERDES_ENABLE);
+	}
+
+	/* Take the MAC block out of RESET */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, 0, 0x1);
+
+	/* --------------- Update Normalizer Register ------------- */
+
+	/* Set-up port number in fake preamble header */
+	reg = ((ps->prm_hdr_value & 0xF)<<12);
+
+	/* Insert fake preamble header */
+	if( ps->prm_hdr_insert != FALSE) { SET_BIT( reg, 0); }
+
+	/* Insert Normalized header */
+	if( ps->norm_hdr_insert != FALSE) {
+		SET_BIT( reg, 1);
+	} else {
+		SET_BIT( reg, 2); /* NLE */
+	}
+
+	/* Disable Ingress CRC updating */
+	if( ps->crc_update == FALSE) { SET_BIT( reg, 9); }
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, reg, (ulong)0xF207);
+
+	/* ----------- Update De-Normalizer Register --------- */
+
+	reg = 0;
+	if ( ps->norm_hdr_expect != FALSE) { SET_BIT( reg, 1); }
+	if ( ps->prm_hdr_expect != FALSE) { SET_BIT( reg, 0); }
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_DENORM, reg, (ulong)0x3);
+
+	/* Egress CRC-32 Checker after SPI4 must be disabled to 
+		let bad frames pass through */
+	if( VTSS_OK != vtss_port_fcs_modify( portnum, ps->fcs_modify)){
+		/* Issue a warning */
+		printk("[%s] not able to modify fcs\n",__func__);
+	}
+
+	/* Save user data to the global structure */
+	vtss_1G_ports_setup[ppn] = *ps;
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function void vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
+  vtss_mac_major_mode_t mmode)
+
+	================================================================================
+
+	Description:
+	Supplementary function: fills the structure referenced by the pointer 
+	with the default values for a given major_mode.
+	By default the port is setup to run in 1G GMII mode.
+
+	NOTE: 
+	Requires global port mapping table to be initialized
+
+	Syntax
+	void vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
+	vtss_mac_major_mode_t mmode);
+
+	Arguments:
+	ps           pointer to a structure that will be filled with default data
+	mmode        one of the major modes
+
+	Return code:
+	VTSS_OK
+
+ *******************************************************************************/
+vtss_rc vtss_port_setup_get_default_values( vtss_port_setup_t* ps,
+		vtss_mac_major_mode_t mmode)
+{
+
+	vtss_mac_t mac_addr = {{0,0,0,0,0,0}};
+
+
+	switch ( mmode) {
+		/* valid major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	/* By default 1G GMII interface is assumed */
+	ps->interface_mode.interface_type = VTSS_PORT_INTERFACE_GMII;
+	ps->interface_mode.speed = VTSS_SPEED_1G;
+
+
+	ps->fdx = TRUE; /* Full duplex: TRUE, half duplex: FALSE */
+
+	/* Flow control setup */
+	ps->flowcontrol.obey = FALSE;
+	ps->flowcontrol.generate = FALSE;
+	ps->flowcontrol.smac = mac_addr;
+
+
+	ps->enable_tx_pause_xon_xoff = TRUE;
+	ps->tx_pause_value = VTSS_PORT_1G_TX_PAUSE_VALUE;
+
+
+	/* interframe gaps for 1G speed */
+	ps->frame_gaps.ifg1 = VTSS_IFG1_1G;
+	ps->frame_gaps.ifg2 = VTSS_IFG2_1G;
+
+	ps->maxframelength = VTSS_MAX_FRAME_LENGTH; /* Max frame length. */
+
+	ps->vlan_aware = FALSE;
+
+	ps->drop_on_length_error = FALSE;
+
+	ps->crc_update = FALSE;
+	ps->fcs_modify = VTSS_FCS_DO_NOTHING;
+
+
+
+	/* The following two fields are hw related */
+	ps->invert_gtx_tx_clock = TRUE;  /* HW related */
+	ps->invert_rx_clock     = FALSE; /* HW related */
+
+
+	switch ( mmode) {
+		/* valid major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+			ps->norm_hdr_insert = FALSE;
+			ps->prm_hdr_insert = FALSE;
+			ps->prm_hdr_value = 0;
+
+			ps->norm_hdr_expect = FALSE;
+			ps->prm_hdr_expect = FALSE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+			ps->norm_hdr_insert = TRUE;
+			ps->prm_hdr_insert = FALSE;
+			ps->prm_hdr_value = 0;
+
+			ps->norm_hdr_expect = FALSE;
+			ps->prm_hdr_expect = FALSE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			/* by default configured to preamble trunking */
+			ps->norm_hdr_insert = TRUE;
+			ps->prm_hdr_insert = TRUE;
+			ps->prm_hdr_value = 0;
+
+			ps->norm_hdr_expect = FALSE;
+			ps->prm_hdr_expect = TRUE;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			/* these cases are needed only to make the compiler happy */
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	return VTSS_OK;
+}
+
+
+/*----------------  Run-time funcitons  ---------------------------------------*/
+/*******************************************************************************
+
+  Function  vtss_port_set_mode( )
+	================================================================================
+
+	Description:
+	Configure speed and duplex mode of a 10M/100M/1G port
+
+	NOTE: 
+
+
+	Registers affected:
+	DEV_SETUP     0xB
+	MODE_CFG      0x0
+
+
+	Syntax
+	vtss_rc vtss_port_set_mode( vtss_port_no_t portnum, vtss_speed_t speed, 
+	BOOL fdx);
+
+	Arguments:
+	portnum   logical port number
+	speed     10M, 100M, 1G
+	fdx       TRUE - full duplex, FALSE -- half duplex
+
+	Return code:
+	VTSS_OK                 if operation completed successfully
+	VTSS_PORT_NOT_MAPPED    if the logical port is not mapped
+	VTSS_WRONG_PARAMETER    wrong value or combination of input parameters
+
+*******************************************************************************/
+vtss_rc vtss_port_set_mode( 	vtss_port_no_t 	portnum, 
+				vtss_speed_t 	speed, 
+				BOOL 		fdx)
+{
+
+	ulong dev_setup_reg = 0;
+	ulong mode_cfg_reg = 0, mode_cfg_reg_mask = 0;
+	ulong old_value = 0;
+	uchar ifg1 = 0, ifg2 = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/* 1G requre full duplex mode */
+	if ((speed == VTSS_SPEED_1G) && (!fdx)) {
+		return VTSS_WRONG_PARAMETER;
+	}
+
+
+	switch (speed) {
+		case VTSS_SPEED_10M:
+			SET_BIT( dev_setup_reg, 1);
+
+			ifg1 = (fdx) ? VTSS_IFG1_10M_FDX : VTSS_IFG1_10M_HDX;
+			ifg2 = (fdx) ? VTSS_IFG2_10M_FDX : VTSS_IFG2_10M_HDX;
+
+			break;
+		case VTSS_SPEED_100M:
+			SET_BIT( dev_setup_reg, 2);
+
+			ifg1 = (fdx) ? VTSS_IFG1_10M_FDX : VTSS_IFG1_10M_HDX;
+			ifg2 = (fdx) ? VTSS_IFG2_10M_FDX : VTSS_IFG2_10M_HDX;
+
+			break;
+		case VTSS_SPEED_1G:
+			if ( vtss_1G_ports_setup[ppn].interface_mode.interface_type == 
+					VTSS_PORT_INTERFACE_SERDES) {
+				SET_BIT( dev_setup_reg, 3);
+			} else {
+				SET_BIT( dev_setup_reg, 2);
+				SET_BIT( dev_setup_reg, 1);
+			}
+
+			ifg1 = VTSS_IFG1_1G;
+			ifg2 = VTSS_IFG2_1G;
+
+			SET_BIT( mode_cfg_reg, 3); /*GIGA mode*/
+
+			break;
+		default:
+			printk("1G port #%d. Wrong speed: %d\n", ppn, speed);
+			return VTSS_WRONG_PARAMETER;
+	}
+
+	SET_BIT( mode_cfg_reg_mask, 3);
+
+	/* Prepare port for reset */
+	SET_BIT( dev_setup_reg, 0);
+
+	if(fdx) {
+		SET_BIT( mode_cfg_reg, 2);
+	}
+	SET_BIT( mode_cfg_reg_mask, 2);
+
+	SET_BITS_MASKED( mode_cfg_reg, (ulong)ifg1<<6, (ulong)VTSS_IFG_MASK<<6);
+	SET_BITS_MASKED( mode_cfg_reg, (ulong)ifg2<<10, (ulong)VTSS_IFG_MASK<<10);
+	/* set the mode_cfg_reg mask */
+	SET_BITS_MASKED( mode_cfg_reg_mask, (ulong)VTSS_IFG_MASK<<6, 
+			(ulong)VTSS_IFG_MASK<<6);
+	SET_BITS_MASKED( mode_cfg_reg_mask, (ulong)VTSS_IFG_MASK<<10, 
+			(ulong)VTSS_IFG_MASK<<10);
+
+	/* Read the current value */
+	old_value = 0x3 & vtss_io_read( M2_BLK_MACS, ppn, M2_MODE_CFG); 
+	/* Disable port */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, 0, 0x3);
+
+	/* Change the mode */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG,
+			mode_cfg_reg, mode_cfg_reg_mask);
+
+	/* Write device setup register. It will also reset the port */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP,
+			dev_setup_reg, 0xF);
+
+	/* leave reset state */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP,
+			0, 0x1);
+
+	/* Restore old RX and TX values */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, old_value, 0x3);
+
+
+	/* Update global data */
+	vtss_1G_ports_setup[ppn].interface_mode.speed = speed;
+	vtss_1G_ports_setup[ppn].fdx = fdx;
+	vtss_1G_ports_setup[ppn].frame_gaps.ifg1 = ifg1;
+	vtss_1G_ports_setup[ppn].frame_gaps.ifg2 = ifg2;
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function vtss_port_set_enable()
+================================================================================
+
+	Description:
+	Enable/disable rx, tx or both in a 10M/100M/1G port 
+
+	NOTE: 
+
+
+	Syntax
+	vtss_rc vtss_port_set_enable( vtss_port_no_t portnum, 
+	BOOL rx_en, BOOL tx_en);
+
+	Arguments:
+	portnum      logical port number
+	rx_en        if TRUE, enables reception of Ethernet frames
+	if FALSE, disables reception of Ethernet frames
+	tx_en        if TRUE, enables transmission of Ethernet frames
+	if FALSE, disables transmission of Ethernet frames
+
+	Return code:
+	VTSS_OK                if operation completed successfully
+	VTSS_PORT_NOT_MAPPED   if the logical port is not mapped
+
+ *******************************************************************************/
+vtss_rc vtss_port_set_enable( vtss_port_no_t portnum, BOOL rx_en, BOOL tx_en)
+{
+	ulong mode_cfg_reg = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	if(rx_en) {
+		SET_BIT(mode_cfg_reg, 1);
+	}
+	if(tx_en) {
+		SET_BIT(mode_cfg_reg, 0);
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_MODE_CFG, mode_cfg_reg, 0x3);
+
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+	Function vtss_port_fcs_modify()
+	================================================================================
+
+	Description:
+	Set CRC adding/updating mode (done in the denormalizer).
+
+	NOTE:
+	Only in egress direction.
+	SPI4 block must not discard frames with incorrect FCS.
+
+
+	Syntax
+	vtss_rc vtss_port_fcs_modify( vtss_port_no_t portnum, vtss_fcs_modify_t mc);
+
+	Arguments:
+	portnum     logical port number
+	mc          select the way FCS is modified
+
+	Return code:
+	VTSS_OK                 if operation completed successfully
+	VTSS_PORT_NOT_MAPPED    logical port not mapped
+
+ *******************************************************************************/
+vtss_rc vtss_port_fcs_modify( vtss_port_no_t portnum, vtss_fcs_modify_t mc)
+{
+	ulong denorm_reg = 0;
+	ulong mask = (1<<5)|(1<<4);
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/* 
+	 * Meigs2 has two independent bits: UPDATE and ADD, which should always have
+	 * opposite values
+	*/
+	switch ( mc) {
+		case  VTSS_FCS_DO_NOTHING:
+			/* denorm_reg is already set to 0 */
+			break;
+		case VTSS_FCS_UPDATE:
+			SET_BIT( denorm_reg, 5);
+			/* CLR_BIT( denorm_reg, 4); denorm_reg is already set to 0 */
+			break;
+		case VTSS_FCS_ADD:
+			SET_BIT( denorm_reg, 4);
+			/* CLR_BIT( denorm_reg, 5); denorm_reg is already set to 0 */
+			break;
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_DENORM, denorm_reg, mask);
+
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function 
+  ================================================================================
+
+	Description:
+	Discard/do_not_discard  Ethernet frames with wrong FCS in ingress direciton
+
+	NOTE: 
+	Not only frames with incorrect FCS will be allowed upstream, but also 
+	all wrong frames including fragments.
+
+	Syntax
+	vtss_rc vtss_port_check_fcs( vtss_port_no_t portnum, BOOL check);
+
+	Arguments:
+	portnum   logical port number
+	check     TRUE   -- frames with wrong FCS are discarded (default)
+	FALSE  -- frames with wrong FCS are forwarded upstream
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+	VTSS_FEATURE_NOT_SUPPORTED
+	VTSS_PORT_NOT_MAPPED   logical port not mapped
+
+ *******************************************************************************/
+vtss_rc vtss_port_check_fcs( vtss_port_no_t portnum, BOOL check)
+{
+
+#if defined MEIGS2 || defined VSC7321
+
+	/* MEIGS2 always discards ingress frames with bad FCS */
+	/* it is not possible to disable this feature */
+	return VTSS_FEATURE_NOT_SUPPORTED;
+
+#else
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+	ulong norm_reg_value = 0;
+	ulong mdbg_reg_value = 0;
+	ulong gress_test_reg = 0;
+	ulong gress = M2_SUBBLK_INGRESS;
+
+	vtss_device_setup_t *pvds = pdevice;
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/* Only one global device per API is currently supported */
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			gress = M2_SUBBLK_EGRESS;
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	if (check) {
+		SET_BIT( norm_reg_value, 9); /* NO_CRC update */
+		SET_BITS_MASKED( mdbg_reg_value, 0x3, 0x3); /* SET_FAIL & KEEP_BAD */
+		SET_BIT( gress_test_reg, 4); /* NO_DROP_IN_FRM */
+	} else {
+		/* bits are already cleared, just write them down */
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, 
+			norm_reg_value, 1<<9);
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2E_TRI_MULTI_DBG, 
+			mdbg_reg_value, 0x3);
+
+	vtss_io_writemasked(M2_BLK_FIFO, gress, ppn,
+			gress_test_reg, 1<<4);
+
+	return VTSS_OK;
+
+#endif
+}
+
+
+/*******************************************************************************
+
+  Function   vtss_port_forward_pause_frames( )
+  ================================================================================
+
+	Description: 
+	Allow pause frames pass through the device. By default 10M/100M/1G block
+	prevents propagation of pause frames through the device.
+
+	NOTE: 
+
+	Syntax
+	vtss_rc vtss_port_forward_pause_frames( vtss_port_no_t portnum, BOOL allow);
+
+	Arguments:
+	portnum   number of the logical port
+	allow     if TRUE, allows pause frames pass through the device
+	if FALSE, pause frames will not be allowed to pass
+
+	Return code:
+	VTSS_OK               if operation completed successfully
+	VTSS_PORT_NOT_MAPPED  logical port is not mapped to any physical port
+
+ *******************************************************************************/
+vtss_rc vtss_port_forward_pause_frames( vtss_port_no_t portnum, BOOL allow)
+{
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_TRI_NORMALIZER, (allow)?0:(1<<6), 1<<6);
+	return VTSS_OK;
+}
+
+
+
+/*******************************************************************************
+
+  Function vtss_port_flow_control_mode( )
+
+  ================================================================================
+
+	Description:
+	Select different modes of flow control on Ethernet interface.
+
+	Terminology:
+	obey        obeys pause frames received from Ethernet 
+	generate    generate pause frames/backpressure upon request from the 
+	destination (FIFO or the host interface)
+
+	NOTE:
+	If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
+
+	IMPORTANT
+	VSC7321 supports only symmetrical flow control and requires both
+	arguments to be set to TRUE.
+
+	Syntax
+	vtss_rc vtss_port_flow_control_mode( vtss_port_no_t port_num, 
+	BOOL fc_obey, 
+	BOOL fc_generate)
+
+	Arguments:
+	obey        if TRUE, obeys pause frames from Ethernet
+	if FALSE, disregard pause frames from Ethernet
+	generate    if TRUE, generate pause frames/backpressure upon request 
+	from the destination block (FIFO or the host interface)
+
+
+	Return code:
+	VTSS_OK               if operation completed successfully
+	VTSS_PORT_NOT_MAPPED  logical port is not mapped to any physical port
+
+ *******************************************************************************/
+vtss_rc vtss_port_flow_control_mode( vtss_port_no_t port_num, 
+		BOOL fc_obey, 
+		BOOL fc_generate)
+{
+	ulong pause_reg_value = 0;
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+#if defined MEIGS2 || defined VSC7321
+
+	if(fc_obey && fc_generate) {
+
+		/* The only mode supported in Meigs-II*/
+		SET_BIT( pause_reg_value, 16);
+		/* IMPORTANT:                                                */
+		/* tx_pause_value and mac_address must be already initialized */
+
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PAUSE_CFG, pause_reg_value, 1<<16);
+
+#else /* VSC7323 && VSC7331*/
+
+	if(fc_obey && fc_generate) {
+		SET_BIT( pause_reg_value, 16);
+	} else if (fc_obey) {
+		SET_BIT( pause_reg_value, 18);
+		CLR_BIT( pause_reg_value, 16);
+	} else if (fc_generate) {
+		SET_BIT( pause_reg_value, 19);
+		/* SET_BIT( pause_reg_value, 17); */
+		CLR_BIT( pause_reg_value, 16);
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PAUSE_CFG, 
+			pause_reg_value, 0xD<<16);
+
+#endif
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function vtss_port_counters_clear(  )
+
+  ================================================================================
+
+	Description:
+	Clears counter for the logical port 
+
+	NOTE:
+	In its current form this funciton clears counters in all 1G ports.
+	This behaviour will be corrected in the next release.
+
+
+	Syntax
+	vtss_rc vtss_port_counters_clear( const vtss_port_no_t portnum );
+
+	Arguments:
+
+
+	Return code:
+
+ *******************************************************************************/
+vtss_rc vtss_port_counters_clear( const vtss_port_no_t portnum )
+{
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/* Writing to this register clears counters in all 1G ports */
+	vtss_io_write( M2_BLK_STAT, ppn, M2_STAT_INIT, 0x0);
+
+	return VTSS_OK;
+}
+
+/*******************************************************************************
+
+  Function  vtss_port_counters_get()
+
+  ================================================================================
+
+	Description:
+	Clears counter for the logical port 
+
+	Syntax
+	vtss_rc vtss_port_counters_get( const vtss_port_no_t  portnum,
+	vtss_port_counters_t *pcounters)
+
+	Arguments:
+	portnum   number of the logical port
+	pc 
+
+	Return code:
+
+ *******************************************************************************/
+vtss_rc vtss_port_counters_get( const vtss_port_no_t  portnum,
+		vtss_port_counters_t *pc)
+{
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	pc->rx_in_bytes = vtss_io_read(M2_BLK_STAT, ppn, M2_RX_IN_BYTES);
+	pc->rx_symbol_carrier = vtss_io_read( M2_BLK_STAT, ppn, 
+			M2_RX_SYMBOL_CARRIER);
+	pc->rx_pause = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_PAUSE);
+	pc->rx_unsup_opcode = vtss_io_read( M2_BLK_STAT, ppn, 
+					M2_RX_UNSUP_OPCODE);
+
+	pc->rx_ok_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_OK_BYTES);
+	pc->rx_bad_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_BAD_BYTES);
+
+	pc->rx_unicast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_UNICAST);
+	pc->rx_multicast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_MULTICAST);
+	pc->rx_broadcast = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_BROADCAST);
+	pc->rx_crc = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_CRC);
+	pc->rx_alignment = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_ALIGNMENT); 
+	pc->rx_undersize = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_UNDERSIZE);
+
+	pc->rx_fragments = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_FRAGMENTS);
+	pc->rx_in_range_error = vtss_io_read( M2_BLK_STAT, ppn, 
+			M2_RX_IN_RANGE_LENGTH_ERROR);
+	pc->rx_out_of_range_error = vtss_io_read( M2_BLK_STAT, ppn, 
+			M2_RX_OUT_OF_RANGE_ERROR);
+	pc->rx_oversize = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_OVERSIZE);
+	pc->rx_jabbers = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_JABBERS);
+	pc->rx_size_64 = vtss_io_read( M2_BLK_STAT, ppn, M2_RX_SIZE_64);
+
+	pc->rx_size_65_to_127 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_65);
+	pc->rx_size_128_to_255 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_128);
+	pc->rx_size_256_to_511 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_256);
+	pc->rx_size_512_to_1023 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_512);
+	pc->rx_size_1024_to_1518 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_1024);
+	pc->rx_size_1519_to_max = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_SIZE_1519);
+
+	pc->rx_xgmii_prot_err = 0; /* Only on 10G MAC port */
+
+	pc->rx_ipg_shrink = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_RX_IPG_SHRINK);
+
+
+	pc->tx_out_bytes = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_OUT_BYTES);
+	pc->tx_pause = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_PAUSE);
+	pc->tx_ok_bytes = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_OK_BYTES);
+
+	pc->tx_unicast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_UNICAST);
+	pc->tx_multicast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_MULTICAST);
+	pc->tx_broadcast = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BROADCAST);
+
+	pc->tx_multiple_coll = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_MULTIPLE_COLL);
+	pc->tx_late_coll = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_LATE_COL);
+	pc->tx_xcoll = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_XCOLL);
+	pc->tx_defer = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_DEFER);
+	pc->tx_xdefer = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_XDEFER);
+	pc->tx_carrier_sense = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_CSENSE);
+
+
+	pc->tx_size_64 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_SIZE_64);
+	pc->tx_size_65_to_127 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_65);
+	pc->tx_size_128_to_255 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_128);
+	pc->tx_size_256_to_511 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_256);
+	pc->tx_size_512_to_1023 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_512);
+	pc->tx_size_1024_to_1518 = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_1024);
+	pc->tx_size_1519_to_max = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SIZE_1519);
+
+
+	pc->tx_single_coll = vtss_io_read( M2_BLK_STAT, ppn, 
+						M2_TX_SINGLE_COL);
+	pc->tx_backoff2 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF2);
+	pc->tx_backoff3 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF3);
+	pc->tx_backoff4 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF4);
+	pc->tx_backoff5 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF5);
+	pc->tx_backoff6 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF6);
+	pc->tx_backoff7 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF7);
+	pc->tx_backoff8 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF8);
+	pc->tx_backoff9 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF9);
+	pc->tx_backoff10 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF10);
+	pc->tx_backoff11 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF11);
+	pc->tx_backoff12 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF12);
+	pc->tx_backoff13 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF13);
+	pc->tx_backoff14 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF14);
+	pc->tx_backoff15 = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_BACKOFF15);
+
+	pc->tx_underrun = vtss_io_read( M2_BLK_STAT, ppn, M2_TX_UNDERRUN);
+
+
+	/* 10G is not properly being handled for the drop counters */
+	/* It must reflect the major mode: 10G as single or multi channel, kbp */
+
+	pc->ingress_overflow_drop = 
+		vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_FIFO_DROP_CNT+ppn);
+	pc->egress_overflow_drop = 
+		vtss_io_read( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_FIFO_DROP_CNT+ppn);
+
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function   
+
+  ================================================================================
+
+	Description:
+	Configure 1G MAC block to insert normalisation of incoming ethernet frames.
+	Works in the direction from 1G MAC to the ingress FIFO.
+
+	NOTE. If an element in the 'hdr' structure is set to FALSE, that type of 
+	header is left unmodified. 
+
+	Syntax
+
+
+
+	Arguments:
+	ppn        physical port (port-on-chip)
+	enable     action to be taken -- enable or disable header insertion
+	hdr        normalized header/preamble header structure
+
+
+	Return code:
+
+ *******************************************************************************/
+static void vtss_port1G_header_insert( int ppn, BOOL enable, 
+		const m2_header_t hdr)
+{
+	ulong reg = 0, reg_mask = 0;
+
+	if ( hdr.use_norm_hdr) {
+
+		if (enable == TRUE) {
+			reg |= M2_NORMALIZER_BIT_NH;
+			/* Norm hdr requires NLE bit to be set */
+			reg |= M2_NORMALIZER_BIT_NLE;
+		}
+		/* else -- do nothing, the bits are already cleared */
+
+		reg_mask |= M2_NORMALIZER_BIT_NH;
+		reg_mask |= M2_NORMALIZER_BIT_NLE;
+	}
+
+	if ( hdr.use_prm_hdr) {
+		if (enable == TRUE)
+			reg |= M2_NORMALIZER_BIT_PH;
+
+		reg_mask |= M2_NORMALIZER_BIT_PH;
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_NORMALIZER, reg, reg_mask);
+
+	return;
+}
+
+
+/*******************************************************************************
+ *
+ *      Autonegotiation functions. Used when TBI or Serdes is enabled.
+ *
+ ******************************************************************************/
+
+/*
+ * Returns the autonegotiation advertisment word and the status (enabled/disabled) 
+ * of the autonegotiation.
+ */
+vtss_rc vtss_pcs_autoneg_control_get( const vtss_port_no_t  port_num,
+		vtss_pcs_autoneg_control_t * const        control )
+{
+
+	ulong reg_value = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	reg_value = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_CTRL);
+
+	control->advertisement.fdx = ( (reg_value >> 5) & 0x1) ? TRUE : FALSE;
+	control->advertisement.hdx = ( (reg_value >> 6) & 0x1) ? TRUE : FALSE;
+
+	control->advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
+		((reg_value >> 7) & 0x1) ? TRUE : FALSE;
+
+	control->advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
+		((reg_value >> 8) & 0x1) ? TRUE : FALSE;
+
+	switch ( ( reg_value >> 12) & 0x3) {
+
+	case VTSS_1000BASEX_LINK_OK:
+		control->advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
+		break;
+	case VTSS_1000BASEX_OFFLINE:
+		control->advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
+		break;
+	case VTSS_1000BASEX_LINK_FAILURE:
+		control->advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
+		break;
+	case VTSS_1000BASEX_AUTONEG_ERROR:
+		control->advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
+		break;
+	}
+
+	control->advertisement.acknowledge = ((reg_value>>14) & 0x1)?TRUE:FALSE;
+
+	control->advertisement.next_page = ( ( reg_value>>15) & 0x1)?TRUE:FALSE;
+
+
+	control->enable = ( ( reg_value>>17) & 0x1)?TRUE:FALSE;
+
+	return VTSS_OK;
+}
+
+/*
+   Enables/disables autonegotiation in the PCS module and sets advertisment word
+ */
+vtss_rc vtss_pcs_autoneg_control_set( const vtss_port_no_t port_num,
+		const vtss_pcs_autoneg_control_t * const  control )
+{
+
+	ulong reg_value = 0, reg_mask = 0;
+
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR: 
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	if ( control->enable == TRUE) {
+		/* 
+		 * Autonegotiation must be enabled and the advertisment word must be 
+		 * written down 
+		*/
+
+		if ( control->advertisement.fdx == TRUE) {
+			SET_BIT( reg_value, 5);
+		} 
+		SET_BIT(reg_mask, 5);
+
+		if ( control->advertisement.hdx) {
+			SET_BIT( reg_value, 6);
+		}
+		SET_BIT( reg_mask, 6);
+
+		if ( control->advertisement.symmetric_pause) { /* a.k.a. PAUSE (PS1) */
+			SET_BIT( reg_value, 7);
+		}
+		SET_BIT(reg_mask, 7);
+
+		if ( control->advertisement.asymmetric_pause) { /* a.k.a. ASM_DIR (PS2) */
+			SET_BIT( reg_value, 8);
+		}
+		SET_BIT( reg_mask, 8);
+
+		switch ( control->advertisement.remote_fault) {
+			case VTSS_1000BASEX_LINK_OK:
+				CLR_BIT( reg_value, 12);
+				CLR_BIT( reg_value, 13);
+				break;
+			case VTSS_1000BASEX_OFFLINE:
+				CLR_BIT( reg_value, 12);
+				SET_BIT( reg_value, 13);
+				break;
+			case VTSS_1000BASEX_LINK_FAILURE:
+				SET_BIT( reg_value, 12);
+				CLR_BIT( reg_value, 13);
+				break;
+			case VTSS_1000BASEX_AUTONEG_ERROR:
+				SET_BIT( reg_value, 12);
+				SET_BIT( reg_value, 13);
+				break;
+		}
+		SET_BIT( reg_mask, 12);
+		SET_BIT( reg_mask, 13);
+
+		if( control->advertisement.acknowledge == TRUE) {
+			SET_BIT( reg_value, 14);
+		}
+		SET_BIT( reg_mask, 14);
+
+		if ( control->advertisement.next_page == TRUE) {
+			SET_BIT( reg_value, 15);
+		}
+		SET_BIT( reg_mask, 15);
+
+		/* enable and restart autoneg bits */
+		SET_BIT( reg_value, 16);
+		SET_BIT( reg_value, 17);
+
+		SET_BIT( reg_mask, 16);
+		SET_BIT( reg_mask, 17);
+
+		/* and the write_strobe: used in Meigs2, harmless in VSC7323/7331 */
+		SET_BIT( reg_value, 31);
+		SET_BIT( reg_mask, 31);
+
+	} else {
+		/* restart autoneg bits must be set when disabling autoneg */
+		SET_BIT( reg_value, 16);
+		/* disable autoneg */
+		CLR_BIT( reg_value, 17);
+
+		SET_BIT( reg_mask, 16);
+		SET_BIT( reg_mask, 17);
+
+		/* and the write_strobe: used in Meigs2, harmless in VSC7323/7331 */
+		SET_BIT( reg_value, 31);
+		SET_BIT( reg_mask, 31);
+
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, reg_value, reg_mask);
+
+	return VTSS_OK;
+}
+
+
+/*
+   Restarts autonegotiation, does not check whether autonegotiation is enabled
+ */
+vtss_rc vtss_pcs_autoneg_restart( const vtss_port_no_t  port_num )
+{
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/*
+	 * Autoneg restart bit#16
+	 * Write strobe bit#31 -- used in VSC7321, harmless in VSC7323/7331
+	 */
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, 
+			0x8001<<16, 0x8001<<16);
+
+	return VTSS_OK;
+}
+
+/*  
+    Return the status of the current status of the link partner
+ */
+vtss_rc vtss_pcs_autoneg_status_get( const vtss_port_no_t port_num,
+		vtss_pcs_autoneg_status_t *paneg)
+{
+	ulong reg_value = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	reg_value = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
+
+	/*  Read XMIT_MODE: bits #18-19  */
+	switch ( ( reg_value >> 18) & 0x3) {
+
+		case VTSS_PCS_ANEG_STATE_IDLE:      /* Idle */
+			paneg->aneg_state = VTSS_PCS_ANEG_STATE_IDLE;
+			break;
+		case VTSS_PCS_ANEG_STATE_CONFIG:    /* Config (i.e. ANEG in progress) */
+			paneg->aneg_state = VTSS_PCS_ANEG_STATE_CONFIG;
+			break;
+		case VTSS_PCS_ANEG_STATE_DATA:      /* Data */
+			paneg->aneg_state = VTSS_PCS_ANEG_STATE_DATA;
+			break;
+		default:
+			paneg->aneg_state = VTSS_PCS_ANEG_STATE_NOTVALID;
+	}
+
+	/* ANC:  autoneg complete bit #16 */
+	paneg->aneg_complete = ( (reg_value >> 16) & 0x1) ? TRUE : FALSE;
+
+	paneg->partner_advertisement.fdx = ( (reg_value >> 5) & 0x1) ? TRUE : FALSE;
+	paneg->partner_advertisement.hdx = ( (reg_value >> 6) & 0x1) ? TRUE : FALSE;
+
+	paneg->partner_advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
+		((reg_value >> 7) & 0x1) ? TRUE : FALSE;
+
+	paneg->partner_advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
+		((reg_value >> 8) & 0x1) ? TRUE : FALSE;
+
+	switch ( ( reg_value >> 12) & 0x3) {
+
+		case VTSS_1000BASEX_LINK_OK:
+			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
+			break;
+		case VTSS_1000BASEX_OFFLINE:
+			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
+			break;
+		case VTSS_1000BASEX_LINK_FAILURE:
+			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
+			break;
+		case VTSS_1000BASEX_AUTONEG_ERROR:
+			paneg->partner_advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
+			break;
+	}
+
+	paneg->partner_advertisement.acknowledge = ((reg_value>>14) & 0x1)?TRUE:FALSE;
+
+	paneg->partner_advertisement.next_page = ( ( reg_value>>15) & 0x1)?TRUE:FALSE;
+
+	return VTSS_OK;
+}
+
+/* Returns more detailed status than vtss_pcs_autoneg_status_get */
+vtss_rc vtss_pcs_status_get( const vtss_port_no_t       port_num,
+		vtss_pcs_status_t * const  pstatus )
+{
+	ulong pcs_status = 0;
+	ulong pcs_ctrl = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	pcs_status = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
+	pcs_ctrl = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_CTRL);
+
+	/*  Read XMIT_MODE: bits #18-19  */
+	switch ( ( pcs_status >> 18) & 0x3) {
+
+		case VTSS_PCS_ANEG_STATE_IDLE:  /* Idle */
+			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_IDLE;
+			break;
+		case VTSS_PCS_ANEG_STATE_CONFIG:    /* Config (i.e. ANEG in progress) */
+			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_CONFIG;
+			break;
+		case VTSS_PCS_ANEG_STATE_DATA:       /* Data */
+			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_DATA;
+			break;
+		default:
+			pstatus->autoneg.aneg_state = VTSS_PCS_ANEG_STATE_NOTVALID;
+	}
+
+	/* ANC:  autoneg complete bit #16 */
+	pstatus->autoneg.aneg_complete = ( (pcs_status >> 16) & 0x1) ? TRUE : FALSE;
+
+	/* 
+	 * SHOW_LDC_TOP bit of the PCS_CTRL register (bit #25) selects how to 
+	 * interpret bits 24..31 of the PCS_STATUS register
+	*/
+	if ( ( pcs_ctrl >> 25) & 0x1) { /* the link down counter is 8 bit long */
+
+		pstatus->show_ldc_top = TRUE;
+
+		pstatus->losync = FALSE;
+
+		pstatus->pcs_in_sync = FALSE;
+
+		/* link down counter is 8bit long */
+		pstatus->link_down_counter = (pcs_status >> 24) & 0xFF;
+
+	} else { /* the link down counter is 6 bit long */
+
+		pstatus->show_ldc_top = FALSE;;
+
+		pstatus->losync = 
+			((pcs_status >> 31) & 0x1) ? TRUE : FALSE;
+
+		pstatus->pcs_in_sync = 
+			((pcs_status >> 30) & 0x1) ? TRUE : FALSE;
+
+		/* link down counter is only 6 bits long */
+		pstatus->link_down_counter = (pcs_status >> 24) & 0x3F;
+
+	}
+
+	/*
+	 * signal_detected indicates that there is light in the fiber; 
+	 * require SD_EN in the PCS_CTRL register to be set 
+	*/
+	pstatus->signal_detected = 
+		((pcs_status >> 23) & 0x1) ? TRUE : FALSE;
+
+	pstatus->jtp_lock = 
+		((pcs_status >> 22) & 0x1) ? TRUE : FALSE;
+
+	pstatus->jtp_error = 
+		((pcs_status >> 21) & 0x1) ? TRUE : FALSE;
+
+	/* link_status:  FALSE if link has been down since last status read */
+	pstatus->link_status_ok =
+		((pcs_status >> 20) & 0x1) ? TRUE : FALSE;
+
+	pstatus->autoneg.partner_advertisement.fdx = ( (pcs_status >> 5) & 0x1) ? TRUE : FALSE;
+	pstatus->autoneg.partner_advertisement.hdx = ( (pcs_status >> 6) & 0x1) ? TRUE : FALSE;
+
+	pstatus->autoneg.partner_advertisement.symmetric_pause =   /* a.k.a. PAUSE (PS1) */
+		((pcs_status >> 7) & 0x1) ? TRUE : FALSE;
+
+	pstatus->autoneg.partner_advertisement.asymmetric_pause = /* a.k.a. ASM_DIR (PS2) */
+		((pcs_status >> 8) & 0x1) ? TRUE : FALSE;
+
+	switch ( ( pcs_status >> 12) & 0x3) {
+
+		case VTSS_1000BASEX_LINK_OK:
+			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_OK;
+			break;
+		case VTSS_1000BASEX_OFFLINE:
+			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_OFFLINE;
+			break;
+		case VTSS_1000BASEX_LINK_FAILURE:
+			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_LINK_FAILURE;
+			break;
+		case VTSS_1000BASEX_AUTONEG_ERROR:
+			pstatus->autoneg.partner_advertisement.remote_fault = VTSS_1000BASEX_AUTONEG_ERROR;
+			break;
+	}
+
+	pstatus->autoneg.partner_advertisement.acknowledge = ((pcs_status>>14) & 0x1)?TRUE:FALSE;
+
+	pstatus->autoneg.partner_advertisement.next_page = ( ( pcs_status>>15) & 0x1)?TRUE:FALSE;
+
+	return VTSS_OK;
+}
+
+vtss_rc vtss_serdes_signal_detect_setup( const vtss_port_no_t port_num,
+		BOOL enable,
+		BOOL sd_polarity_high,
+		BOOL sd_source_extern)
+{
+	ulong reg = 0, mask = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	if ( enable == TRUE) {
+
+		/* set Signal Detect source */
+		if ( sd_source_extern == TRUE)
+			SET_BIT( reg, 8);
+		SET_BIT( mask, 8);
+		vtss_io_writemasked( M2_BLK_MACS, ppn, M2_DEV_SETUP, reg, mask);
+		reg = mask = 0;
+
+		/* and now Polarity and Enable */
+		SET_BIT( reg, 22); /* Signal Detect Enable */
+
+		if ( sd_polarity_high == TRUE)
+			SET_BIT( reg, 23); /* Signal Detect Polarity */
+
+		SET_BIT( mask, 22);
+		SET_BIT( mask, 23);
+
+	} else {
+		/* Disable serdes Signal Detect */
+		SET_BIT( mask, 22);
+	}
+
+	/* write_strobe used in Meigs2, otherwise harmless */
+	SET_BIT( reg, 31);
+	SET_BIT( mask, 31);
+
+	vtss_io_writemasked( M2_BLK_MACS, ppn, M2_PCS_CTRL, reg, mask);
+
+	return VTSS_OK;
+}
+
+vtss_rc vtss_serdes_extern_signal_detect_status_get(const vtss_port_no_t port_num, 
+		BOOL *pstatus)
+{
+	ulong reg = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[port_num].chip_port;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* right major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR: /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* single chip trunking */
+			break;
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+
+	reg = vtss_io_read( M2_BLK_MACS, ppn, M2_PCS_STATUS);
+
+	if ( (reg >> 23) & 0x1 ) { /* bit 23 is set */
+		*pstatus = TRUE;
+	} else {
+		*pstatus = FALSE;
+	}
+
+	return VTSS_OK;
+}
+
+
+/*****************************************************************************/
+/*                                                                           */
+/*        10G port setup                                                     */
+/*                                                                           */
+/*****************************************************************************/
+/* Setup 10G port */
+vtss_rc vtss_10Gport_setup( vtss_port_no_t port_num, vtss_10Gport_setup_t* ps)
+{
+	ulong misc_reg_value = 0;
+	ulong reg_mask = 0;
+	ulong reg_value = 0;
+
+	ulong max_len_reg_value = 0;
+
+	ulong pause_reg_value = 0;
+
+	ulong denorm_reg = 0;
+
+	m2_header_t hdr;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+
+	printk("10G port setup.\n");
+
+	/* check for appropriate major mode */
+	switch ( pvds->mmode) {
+		/* Suppported modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			break;
+
+			/* Undefined major mode */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+			/* Wrong mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	if (VTSS_SPEED_10G != ps->interface_mode.speed) {
+		printk("10G port. Wrong speed: %d\n", ps->interface_mode.speed);
+		return VTSS_WRONG_PARAMETER;
+	}
+
+	if (VTSS_PORT_INTERFACE_XAUI != ps->interface_mode.interface_type) {
+		printk("10G port. Wrong interface type: %d\n", 
+					ps->interface_mode.interface_type);
+		return VTSS_WRONG_PARAMETER;
+	}
+
+	/* -------------------  MISC  ------------------------- */
+
+	/* Enable the 10G block */
+	SET_BIT( misc_reg_value, 1);
+	SET_BIT( misc_reg_value, 0);
+
+	if ( ps->vlan_aware)           { SET_BIT( misc_reg_value, 2); }
+	if ( ps->prm_hdr_insert)       { SET_BIT( misc_reg_value, 3); }
+	if ( ps->pace_mode)            { SET_BIT( misc_reg_value, 5); }
+	if ( ps->drop_in_range_error)  { SET_BIT( misc_reg_value, 6); }
+	if ( ps->drop_on_length_error) { SET_BIT( misc_reg_value, 7); }
+	if ( ps->sfd_check)            { SET_BIT( misc_reg_value, 8); }
+
+	/* It is recommended to set 3-bit LFS_MODE bitfield to 000b */
+	SET_BITS_MASKED( misc_reg_value, 0, (ulong)7<<9);
+	SET_BITS_MASKED( reg_mask, (ulong)7<<9, (ulong)7<<9);
+
+	if ( ps->ext_sop_check_enable) { SET_BIT( misc_reg_value, 13); }
+	if ( ps->ext_eop_check_enable) { SET_BIT( misc_reg_value, 14); }
+
+	/* Before writing the value down to the register, take the 10g block 
+	   out of reset */
+	CLR_BIT( misc_reg_value, 31);
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MISC_10G, 
+			misc_reg_value, 0XFFFFFFFF);
+
+
+	/* -------------------  DENORM  ------------------------- */
+
+	/* For this to work SPI4(when used) must be set to let bad frames 
+	   pass through */
+	switch ( ps->fcs_modify) {
+		case  VTSS_FCS_DO_NOTHING:
+			/* bits are cleared, do nothing */
+			break;
+		case VTSS_FCS_UPDATE:
+			SET_BIT( denorm_reg, 5);
+			/* bit #4 is cleared */
+			break;
+		case VTSS_FCS_ADD:
+			SET_BIT( denorm_reg, 4);
+			/* bit #5 is cleared */
+			break;
+	}
+
+	if( ps->norm_hdr_expect == TRUE) { SET_BIT(denorm_reg, 1); }
+	if( ps->prm_hdr_expect  == TRUE) { SET_BIT(denorm_reg, 0); }
+
+	/* Denormalizer register */
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_DENORM, denorm_reg, 0x3f);
+
+	/* -------------------  Flowcontrol  ----------------------- */
+	if(ps->flowcontrol.obey || ps->flowcontrol.generate) {
+		/* Mac address will be written if flowcontrol setup is requested */
+		ulong mac_addr_low_reg = 
+			(ps->flowcontrol.smac.addr[3] << 16)| 
+			(ps->flowcontrol.smac.addr[4] <<  8)|
+			ps->flowcontrol.smac.addr[5];
+
+		ulong mac_addr_high_reg = 
+			(ps->flowcontrol.smac.addr[0] << 16)| 
+			(ps->flowcontrol.smac.addr[1] <<  8)|
+			ps->flowcontrol.smac.addr[2];
+
+		vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, 
+				M2_MAC_HIGH_ADDR, mac_addr_high_reg);
+		vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, 
+				M2_MAC_LOW_ADDR, mac_addr_low_reg);
+
+		if (ps->flowcontrol.obey) {
+			SET_BIT( pause_reg_value, 17);
+		}
+		if (ps->flowcontrol.generate) {
+			SET_BIT( pause_reg_value, 16);
+		}
+
+
+	}
+
+	if( ps->enable_tx_pause_xon_xoff == TRUE) {
+		SET_BIT( pause_reg_value, 18);
+	}
+
+	/*  TX pause value */
+	SET_BITS_MASKED( pause_reg_value, ps->tx_pause_value,
+			VTSS_PORT_10G_TX_PAUSE_MASK);
+	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_PAUSE, pause_reg_value);
+
+	/* maxframelength */
+	SET_BITS_MASKED( max_len_reg_value, ps->maxframelength, 
+			VTSS_MAX_FRAME_LENGTH_MASK);
+
+	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAX_LEN, max_len_reg_value);
+
+	/* -------------------  NORMALIZER  ------------------------- */
+	/* RxChainMode must be set in the system block */
+
+	/* 10G port always reads data from the FIFO (i.e. in egress direction) on 
+	   frame-interleaved basis, thus normalised header is needed */
+	/* Chip major mode must be defined at this point */
+	hdr.use_norm_hdr = TRUE;
+	hdr.use_prm_hdr = FALSE;
+
+	reg_value = reg_mask =  0;
+	if ( ps->norm_hdr_insert == TRUE ) {
+		SET_BIT(reg_value, 1); /* NH bit */
+		/* NLE must be cleared */
+	} else {
+		/* witout normalized header NLE must be set */
+		SET_BIT(reg_value, 2);
+	}
+	SET_BIT(reg_mask, 1); /* NH bit */
+	SET_BIT(reg_mask, 2); /* NLE bit */
+
+	if ( ps->prm_hdr_insert == TRUE) {
+		SET_BIT( reg_value, 0);
+	}
+	SET_BIT( reg_mask, 0);
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_NORMALIZER,
+			reg_value, reg_mask);
+
+	/* -------------------  XAUI  ------------------------- */
+
+	/* Power-up control */
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_B,
+			0x4, 0x7);
+
+	/* Reset the block */
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
+			(ulong)1<<31, (ulong)1<<31);
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
+			0, (ulong)1<<31);
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_XAUI_CONF_A,
+			(ulong)1<<31, (ulong)1<<31);
+
+	return VTSS_OK;
+}
+
+
+/* 
+   Supplementary function: fills the structure referenced by the pointer 
+   with the default values for a given major_mode.
+ */
+vtss_rc vtss_10Gport_setup_get_default_values( vtss_10Gport_setup_t* psetup,
+		vtss_mac_major_mode_t major_mode)
+{
+	vtss_mac_t smac_addr = {{0,0,0,0,0,0}};
+
+	switch ( major_mode) {
+		/* Suppported modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			break;
+
+			/* Wrong mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	psetup->interface_mode.interface_type = VTSS_PORT_INTERFACE_XAUI;
+	psetup->interface_mode.speed          = VTSS_SPEED_10G;
+
+	psetup->flowcontrol.obey     = TRUE;
+	psetup->flowcontrol.generate = TRUE;
+	psetup->flowcontrol.smac     = smac_addr;
+
+	psetup->enable_tx_pause_xon_xoff = TRUE;
+	psetup->tx_pause_value           = VTSS_PORT_10G_TX_PAUSE_VALUE;
+
+	psetup->maxframelength = VTSS_MAX_FRAME_LENGTH; /* Max frame length. */
+
+	psetup->vlan_aware = FALSE;
+	psetup->pace_mode = FALSE;
+	psetup->drop_on_length_error = FALSE;
+	psetup->drop_in_range_error = FALSE;
+
+	psetup->fcs_modify = VTSS_FCS_DO_NOTHING;
+
+	psetup->ext_eop_check_enable = FALSE;
+	psetup->ext_sop_check_enable = FALSE;
+
+	switch ( major_mode) {
+		/* Suppported modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
+			psetup->norm_hdr_insert = FALSE;
+			psetup->prm_hdr_insert = FALSE;
+			psetup->norm_hdr_expect = FALSE;
+			psetup->prm_hdr_expect = FALSE;
+			psetup->sfd_check = TRUE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+			psetup->norm_hdr_insert = FALSE;
+			psetup->prm_hdr_insert = FALSE;
+			psetup->norm_hdr_expect = TRUE;
+			psetup->prm_hdr_expect = FALSE;
+			psetup->sfd_check = TRUE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+			psetup->norm_hdr_insert = FALSE;
+			psetup->prm_hdr_insert = TRUE;
+			psetup->norm_hdr_expect = TRUE;
+			psetup->prm_hdr_expect = TRUE;
+			psetup->sfd_check = FALSE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+			psetup->norm_hdr_insert = TRUE;
+			psetup->prm_hdr_insert = FALSE;
+			psetup->norm_hdr_expect = TRUE;
+			psetup->prm_hdr_expect = FALSE;
+			psetup->sfd_check = TRUE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			psetup->norm_hdr_insert = TRUE;
+			psetup->prm_hdr_insert = TRUE;
+			psetup->norm_hdr_expect = TRUE;
+			psetup->prm_hdr_expect = TRUE;
+			psetup->sfd_check = FALSE;
+			break;
+
+		/* Wrong mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	return VTSS_OK;
+}
+
+/* Enable/disable rx, tx or both in a 10G port */
+vtss_rc vtss_10Gport_set_enable( vtss_port_no_t port_num, 
+		BOOL rx_en, BOOL tx_en)
+{
+	ulong mode_cfg_reg = 0;
+	ulong mode_cfg_reg_mask = 0x3; /* two bits are affected */
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+
+	/* check for appropriate major mode */
+	switch ( pvds->mmode) {
+		/* Suppported modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:      /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			break;
+			/* Undefined major mode */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+			/* Wrong mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	if(rx_en) {
+		SET_BIT(mode_cfg_reg, 1);
+	}
+	if(tx_en) {
+		SET_BIT(mode_cfg_reg, 0);
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MISC_10G, 
+			mode_cfg_reg, mode_cfg_reg_mask);
+
+	return VTSS_OK;
+}
+
+/* Set CRC adding/updating mode */
+vtss_rc vtss_10Gport_fcs_modify( vtss_port_no_t port_num, vtss_fcs_modify_t mc)
+{
+	ulong denorm_reg = 0;
+	ulong denorm_reg_mask = (1<<5)|(1<<4);
+
+	/*
+	 * Meigs2 has two independent bits: UPDATE and ADD, which should always have
+	 * opposite values
+	*/
+	switch ( mc) {
+		case  VTSS_FCS_DO_NOTHING:
+			break;
+		case VTSS_FCS_UPDATE:
+			SET_BIT( denorm_reg, 5);
+			CLR_BIT( denorm_reg, 4);
+			break;
+		case VTSS_FCS_ADD:
+			SET_BIT( denorm_reg, 4);
+			CLR_BIT( denorm_reg, 5);
+			break;
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_DENORM, 
+			denorm_reg, denorm_reg_mask);
+
+	return VTSS_OK;
+}
+
+
+/* 
+ * Allow pause frames pass through the device. By default 10G block
+ * prevents propagation of pause frames through the device.
+*/
+vtss_rc vtss_10Gport_forward_pause_frames( vtss_port_no_t port_num, BOOL allow)
+{
+
+	/*!!! DROP_PAUSE bit (bit #5) is different from its counterpart in 1G ports*/
+	ulong norm_reg = (allow)?0:(1<<5);
+	ulong norm_reg_mask = 1<<5;
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_NORMALIZER, 
+			norm_reg, norm_reg_mask);
+	return VTSS_OK;
+}
+
+/*
+   obey -- obeys pause frames from external Eth client 
+   generate -- generate pause frames/backpressure upon request from the 
+   destination (FIFO or the host interface)
+
+   If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
+ */
+vtss_rc vtss_10Gport_flow_control_mode( vtss_port_no_t port_num, 
+		BOOL fc_obey, 
+		BOOL fc_generate)
+{
+	ulong pause_reg_value = 0;
+	ulong pause_reg_mask = ((ulong)1<<16)|(1<<17);
+
+
+
+	if (fc_obey) {
+		SET_BIT( pause_reg_value, 17);
+	} 
+
+	if (fc_generate) {
+		SET_BIT( pause_reg_value, 16);
+	}
+
+	vtss_io_writemasked( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_PAUSE, 
+			pause_reg_value, pause_reg_mask);
+
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function   vtss_10Gport_signal_detect
+
+  ================================================================================
+
+	Description:
+	Once a 10G Base-X optical module is connected to the XAUI port,
+	this function can use to drive an GPIO connected LED to visualize 
+	signal detection/link status. The CPU must poll this function.
+
+	Syntax
+
+	Arguments: None
+
+	Return code: TRUE/FALSE
+
+ *******************************************************************************/
+BOOL vtss_10Gport_signal_detect(void)
+{
+	ulong mac_tx_sticky_value = 0;
+
+	/* Clear sticky-bits in MAC_TX_STICKY */
+	vtss_io_write( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAC_TX_STICKY, 0x1f);
+	mac_tx_sticky_value = vtss_io_read( M2_BLK_MACS, M2_SUBBLK_MAC_10G, M2_MAC_TX_STICKY);
+
+	return (mac_tx_sticky_value & ((ulong)1 << 4))?(FALSE):(TRUE);
+}
+
+
+/*******************************************************************************
+
+  Function   
+
+  ================================================================================
+
+	Description:
+	Works in the direction from MAC to FIFO.
+
+	Syntax
+
+	Arguments:
+	hdr   normalized header/preamble header structure
+
+	Return code:
+
+ *******************************************************************************/
+static void vtss_port10G_header_insert( BOOL enable, const m2_header_t hdr)
+{
+	ulong reg = 0, reg_mask = 0;
+
+	if ( hdr.use_norm_hdr) {
+
+		if( enable == TRUE) {
+			SET_BIT( reg, 1);
+			/* Normalized header requires the NLE bit set */
+			SET_BIT( reg, 2);
+		}
+
+		SET_BIT( reg_mask,1);
+		SET_BIT( reg_mask,2);
+	}
+
+
+	if ( hdr.use_prm_hdr) {
+		if ( enable == TRUE)
+			SET_BIT( reg, 0);
+
+		SET_BIT( reg_mask, 0);
+	}
+
+
+	/* If any changes, write to the register */
+	if( reg_mask) {
+		vtss_io_writemasked( M2_BLK_MACS, M2_PHYS_PORT_10G, M2_NORMALIZER, 
+				reg, reg_mask);
+	}
+
+	return;
+}
+
+/******************************************************************************
+ *
+ * Description: Set up the SPI4.2 block 
+ *
+ * \param:      ps       Pointer to a structure which determines configuration
+ *
+ * \return:     VTSS_OK  Operation completed successfully.
+ *              VTSS_WRONG_MAJOR_MODE
+ *              VTSS_MAJOR_MODE_NOT_SET
+ *              VTSS_WRONG_PARAMETER
+ *
+ **************************************************************************kbp*/
+vtss_rc vtss_spi4_setup( vtss_spi4_setup_t* ps)
+{
+	ulong reg  = 0;
+	ulong mask = 0;
+	ulong active_ports = 0;
+	ulong pll_clk_speed = 0;
+	int i;
+	m2_header_t hdr;
+	BOOL hdr_present;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	switch ( pvds->mmode) {
+		/* valid major modes */
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:  /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
+			break;
+
+			/* Error - major mode undefined */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+			/* Error - wrong major mode */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:  /* Single Chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK: /* Single Chip trunking */
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	/* Burst size from ingress FIFO -> SPI4 */
+	reg = ps->burst_size & 0xF;
+
+	/* Selection between burst or frame interleaved scheduling
+	   is done in the ingress FIFO: CM bit in ing_ctrl_reg */
+	hdr.use_norm_hdr = TRUE; hdr.use_prm_hdr = FALSE;
+	switch ( ps->sch_mode) {
+#if !defined MEIGS2 && !defined VSC7321
+		case VTSS_SPI4_BURST_MODE_WITH_HEADER:
+			vtss_hdr_insert( TRUE, hdr);
+			SET_BIT( reg, 4); /* set CM bit */
+			break;
+#endif
+		case VTSS_SPI4_BURST_MODE:
+			SET_BIT( reg, 4); /* set CM bit */
+			break;
+		case VTSS_SPI4_FRAME_MODE:
+			CLR_BIT( reg, 4); /* clear CM bit */
+			vtss_hdr_insert( TRUE, hdr);
+			break;
+		default:
+			return VTSS_WRONG_PARAMETER;
+	}
+	/* Write to ingress fifo control register */
+	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_ING_CONTROL, reg, 0x1F);
+
+
+	/* Set-up Header Stripper located before Ingress SPI4.2 */
+	if( ps->norm_hdr_strip == FALSE) {
+		vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, 0, (ulong)1<<4);
+	} else {
+		vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, (ulong)1<<4, (ulong)1<<4);
+	}
+
+
+	/* Set-up FCS/CRC-32 Checker located after Egress SPI4.2 */
+	if ( ps->norm_hdr_expect != FALSE) {
+		hdr_present = TRUE;
+		if ( ps->prm_hdr_expect != FALSE) {
+			reg = 0x0; /* hdr_size = 16 bytes */
+		} else {
+			reg = 0x9; /* hdr_size = 9 bytes */
+		}
+	} else {
+		if ( ps->prm_hdr_expect != FALSE) {
+			hdr_present = TRUE;
+			reg = 0x7; /* hdr_size = 7 bytes */
+		} else {
+			hdr_present = FALSE; /* no header */
+			reg = 0x0; /* hdr_size = 0 bytes */
+		}
+	}
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CRC_CFG,
+			((hdr_present)?((ulong)1<<4):0) | reg, 0x1F);
+
+
+	/******************    SPI4  MISC register  setup    ************************/
+
+	/* SPI4 output frequency 390(default), 312, 195, 156 MHz */
+	reg = 0x1; mask = 0x11;
+	switch ( ps->spi4_output_freq) {
+		case VTSS_SPI4_OUTPUT_FREQ_390MHZ:
+			SET_BIT( pll_clk_speed, 0);
+			break;
+#if defined MEIGS2 || defined VSC7321
+		case VTSS_SPI4_OUTPUT_FREQ_312MHZ:
+			break;
+		case VTSS_SPI4_OUTPUT_FREQ_156MHZ:
+			SET_BIT( reg, 4);
+			break;
+#endif
+		case VTSS_SPI4_OUTPUT_FREQ_195MHZ:
+			SET_BIT( pll_clk_speed, 0);
+			SET_BIT( reg, 4);
+			break;
+		default:
+			return VTSS_WRONG_PARAMETER;
+	}
+	/* Select SPI4 clock source from either SerDes or XAUI PLL */
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_PLL_CLK_SPEED, 
+			pll_clk_speed, 0x1);
+
+
+	/* 1. Power-up CML logic
+	   2. Release reset on CML logic and set-up RQC
+
+	   3. Set-up rest
+	   Always assert bit 18, SD; spi4_swap_bytes in order to be spi4 compliant
+	   Always de-assert bits 29-31: SPI clock reset bits */
+
+	/* Power-up CML logic */
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
+
+	/* Set-up RQC. Board dependent. */
+	if ( ps->spi4_data_clock_skew != FALSE)  { SET_BIT( reg, 2); }
+	SET_BIT( mask, 2);
+
+	/* Release reset on CML logic */
+	SET_BIT( reg, 3); SET_BIT( mask, 3);
+
+	/* Release reset on CML logic and set-up RQC */
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
+
+	/* Bit SD. Swap bytes in order to be spi4 compliant */
+	SET_BIT( reg, 18); SET_BIT( mask, 18);
+
+	/* Enable all clocks */
+	SET_BITS_MASKED( mask, (ulong)7<<29, (ulong)7<<29);
+
+	/* Bit WI. Board dependent. */
+	if ( ps->spi4_swap_ingress_data != FALSE) { SET_BIT( reg, 9); }
+	SET_BIT( mask, 9);
+
+	/* Bit WE. Board dependent. */
+	if ( ps->spi4_swap_egress_data != FALSE) { SET_BIT( reg, 8); }
+	SET_BIT( mask, 8);
+
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_MISC, reg, mask);
+
+
+	/******************    SPI4_ING_SETUP0 register setup   *********************/
+
+	/* Calendar length is defined by number of ports. Calculate active ports */
+	for(i=0; i<VTSS_PORT_ARRAY_SIZE; i++) {
+		ulong ppn = vtss_logical_ports[i].chip_port;
+		if ( ppn != -1) {
+			SET_BIT(active_ports, ppn);
+		}
+	}
+	/* Setup active ports, kbp_test: active_ports = 0x3FF;*/
+	reg = active_ports & 0x3FF; mask = 0x3FF;
+
+	/* SPI4_calendar_order */
+	if ( ps->spi4_calendar_order_ascending == FALSE) { SET_BIT( reg, 10); }
+	SET_BIT( mask, 10);
+
+	/* SPI4_calendar_m */
+	SET_BITS_MASKED( reg, (ulong)(ps->spi4_calendar_m)<<12, 0xF<<12);
+	SET_BITS_MASKED( mask, 0xF<<12, 0xF<<12);
+
+	/* write to spi4_ingress_setup0_reg register */
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP0, reg, mask);
+
+	/* Parameters of the training mode (only in ingress direction) */
+	vtss_io_write( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP1,
+			(ps->alpha<<16) | (ps->tsperiod));
+
+
+	/******************    SPI4_ING_SETUP2 register setup   *********************/
+
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_ING_SETUP2,
+			(ps->maxburst2<<24) | (ps->maxburst1<<16) | ps->burst_size, 
+			0xFFFF000F);
+
+
+	/******************    SPI4_EGR_SETUP0 register setup   *********************/
+
+	/* Setup active ports */
+	reg = active_ports & 0x3FF; mask = 0x3FF;
+
+	/* Shift status clock output. Board dependent. */
+	if ( ps->spi4_status_clock_skew != FALSE) { SET_BIT( reg, 18); }
+	SET_BIT( mask, 18);
+
+	/* SPI4_calendar_order */
+	if ( ps->spi4_calendar_order_ascending == FALSE) { SET_BIT( reg, 10); }
+	SET_BIT( mask, 10);
+
+	/* SPI4_calendar_m */
+	SET_BITS_MASKED( reg, (ulong)(ps->spi4_calendar_m)<<12, 0xF<<12);
+	SET_BITS_MASKED( mask, 0xF<<12, 0xF<<12);
+
+	/* write to spi4_egress_setup0_reg register. */
+	vtss_io_writemasked( M2_BLK_SPI4, M2_SUBBLK_NONE, M2_SPI4_EGR_SETUP0, reg, mask);
+
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ *
+ * Description: Configures a user provided structure with default values for
+ *              the selected major mode.
+ *
+ * \param:      ps       Pointer to a structure which determines configuration
+ *              mode     Major mode
+ *
+ * \return:     VTSS_OK  Operation completed successfully.
+ *              VTSS_MAJOR_MODE_NOT_SET
+ *
+ **************************************************************************kbp*/
+vtss_rc vtss_spi4_setup_get_default_values( vtss_spi4_setup_t* ps, 
+		vtss_mac_major_mode_t mode)
+{
+
+	/* By default in the ingress direction SPI4.2 runs in burst interleaved mode*/
+	ps->sch_mode   = VTSS_SPI4_BURST_MODE;
+	ps->burst_size = VTSS_SPI4_BURST_SIZE;
+	ps->maxburst1  = VTSS_SPI4_MAX_BURST_1;
+	ps->maxburst2  = VTSS_SPI4_MAX_BURST_2;
+
+
+	/* Parameters of the training mode (only in ingress direction) */
+#if defined MEIGS2 || defined VSC7321
+	ps->tm = VTSS_SPI4_TRAINING_OFF;
+#else
+	ps->tm = VTSS_SPI4_TRAINING_AUTO;
+#endif
+	ps->alpha    = 1;
+	ps->tsperiod = 0;
+
+	/* spi4 output frequency: 390(default), 312, 195, 156 MHz */
+	ps->spi4_output_freq = VTSS_SPI4_OUTPUT_FREQ_390MHZ;
+
+	/* For the description of the following four elements refer to the desription 
+	   of the SPI4 misc register in the datasheet */
+	ps->spi4_swap_ingress_data = FALSE;  /* Board dependent */ /* Bit WI, SPI4 MISC reg*/
+	ps->spi4_swap_egress_data  = FALSE;  /* Board dependent */ /* Bit WE, SPI4 MISC reg*/
+	ps->spi4_data_clock_skew   = FALSE;  /* Board dependent */
+	ps->spi4_status_clock_skew = FALSE;  /* Board dependent */
+
+	/* calendar length is defined by number of ports */
+	ps->spi4_calendar_order_ascending = TRUE;
+	ps->spi4_calendar_m = 1;
+
+	/* normalized and preamble headers */
+	/* ingress direction: strip the norm header before sending it over SPI4 */
+	/* if normalization is not used (i.e there is no header to strip) this 
+	   parameter must be set to FALSE */
+	ps->norm_hdr_strip = FALSE;
+
+
+	/* egress direction: expect/do not expect headers  */
+	switch (mode) {
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:  /* SPI4 <-> 10x1G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G: /* SPI4 <-> 1x10G */
+			ps->prm_hdr_expect = FALSE;
+			ps->norm_hdr_expect = FALSE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+			ps->prm_hdr_expect = FALSE;
+			ps->norm_hdr_expect = TRUE;
+			break;
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
+			ps->prm_hdr_expect = TRUE;
+			ps->norm_hdr_expect = TRUE;
+			break;
+		default:
+			/* VTSS_MAC_MAJOR_MODE_10G_1G_AGGR  - Single Chip aggr */
+			/* VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK - Single Chip trunking */
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+
+  Function  vtss_spi4_fcs_check_enable()
+  ================================================================================
+
+	Description:
+	The function turns on/off FCS check of Ethernet frames arriving from the 
+	host interface. This is done for all channels simultaneously.
+
+
+	NOTE. FCS check in the SPI4 block must be OFF, if FCS will be modified
+	(added/updated) in Ethernet port(s) in the egress direction
+
+	Syntax
+	vtss_rc vtss_spi4_fcs_check_enable( BOOL check_fcs);
+
+	Arguments:
+	check_fcs    TRUE  -- turns FCS check ON
+	FALSE -- turns FCS check OFF
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+
+ *******************************************************************************/
+vtss_rc vtss_spi4_fcs_check_enable( BOOL check_fcs)
+{
+	ulong fcs = 0;
+
+	if (check_fcs) {
+		/* CLR_BIT(fcs,5); Already cleared */
+	} else {
+		/*ignore fcs check*/
+		SET_BIT(fcs,5);
+	}
+
+	vtss_io_writemasked(M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_CRC_CFG,
+			fcs, 1<<5);
+
+	return VTSS_OK;
+}
+
+
+
+
+/*******************************************************************************
+
+  Function  vtss_spi4_keep_norm_header()
+  ================================================================================
+
+	Description:
+	The function controls whether to strip the normalised header or to keep it.
+	Usually the normalised header is stripped before the frame is sent over 
+	SPI4. However, if the remove receiver can use information in the header, 
+	keeping it may be an advantage.
+
+
+	NOTE. Works in ingress direction
+
+	Syntax
+	vtss_rc vtss_spi4_keep_norm_header( BOOL keep);
+
+	Arguments:
+	keep     TRUE  -- the noramlised header is not stripped
+	FALSE -- the noramlised header is stripped (Default)
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+
+ *******************************************************************************/
+vtss_rc vtss_spi4_keep_norm_header( BOOL keep)
+{
+	ulong reg_value = 0, reg_mask = 0;
+
+
+	if ( keep == TRUE)
+		SET_BIT( reg_value, 4);
+
+	SET_BIT( reg_mask, 4);
+
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_IFACE_MODE, 
+			reg_value, reg_mask);
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************/
+/***        Flow Control Configuration        *********************************/
+/******************************************************************************/
+
+/* 
+
+   transparent off -- filling of the FIFO causes generation of pause frames
+   transparent on  -- destination (host i/f), not FIFO, requests pause frames
+
+Note:
+
+ */
+/*******************************************************************************
+
+  Function 
+  ================================================================================
+
+	Description:
+	Function vtss_device_transparent_flow_control_mode() selects FIFO flow 
+	control mode 
+
+	NOTE: 
+	This mode is enabled for all 10/100/1000 Eth ports simultaneously.
+	This functions does not set RX_PAUSE or TX_PAUSE bits in 1G port blocks,
+	the user need to do it after calling this function.
+
+
+	Syntax
+	vtss_rc vtss_device_transparent_flow_control_mode( BOOL ingress_enable,
+	BOOL egress_enable);
+
+
+	Arguments:
+	ingress_enable      when set to TRUE, SPI4.2 flow control signals will 
+	cause generation of Ethernet flow control frames
+	egress_enable       when set to TRUE, Ethernet flow control frames will
+	translate to SPI4.2 flow control signals
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+
+ *******************************************************************************/
+vtss_rc vtss_device_transparent_flow_control_mode( BOOL ingress_enable,
+		BOOL egress_enable)
+{
+	ulong gress_ctrl_reg = 0;
+	ulong gress = M2_SUBBLK_INGRESS;
+
+
+	if (ingress_enable) {
+		SET_BIT( gress_ctrl_reg, 11); /* IPT bit */
+		SET_BIT( gress_ctrl_reg, 12); /* IGI bit */
+	} 
+	vtss_io_writemasked(M2_BLK_FIFO, gress, M2_ING_CONTROL,
+			gress_ctrl_reg, (1<<11)|(1<<12));
+
+
+	gress_ctrl_reg = 0;
+	gress = M2_SUBBLK_EGRESS;
+
+	if (egress_enable) {
+		/* In egress direction use the MFE bit, not IPT/IGI */
+		SET_BIT( gress_ctrl_reg, 15);
+	}
+	vtss_io_writemasked(M2_BLK_FIFO, gress, M2_EGR_CONTROL,
+			gress_ctrl_reg, 1<<15);
+
+	/* Remember to set RX_PAUSE_EN, TX_PAUSE_EN or PAUSE_EN bits in the PAUSE_CFG 
+	   register of 1G ports */
+
+
+	return VTSS_OK;
+}
+
+
+
+
+/******************************************************************************/
+/***        FIFO Configuration                       **************************/
+/******************************************************************************/
+
+
+/*-----------------  FIFO setup funcitons   ----------------------------------*/
+
+
+/*******************************************************************************
+
+  Function vtss_fifo_setup()
+  ================================================================================
+
+	Description:
+	Initializes the FIFO block based on the information in the provided 
+	structures. If the pointer to the structure is set to NULL, the corresponding
+	FIFO will not be initialized (it will be left in its current state).
+
+	The function must be called after start-up and may be called at run-
+	time to reconfigure the FIFO. 
+
+	NOTE: port mapping table must be initialized.
+
+
+	Syntax
+	vtss_rc vtss_fifo_setup( vtss_fifo_setup_t *ps_ingress, 
+	vtss_fifo_setup_t *ps_egress)
+
+	Arguments:
+	ps_ingress   pointer to a structure for the ingress fifo
+	ps_egress   pointer to a structure for the egress fifo
+
+	Return code:
+	VTSS_OK   if operation completed successfully
+	VTSS_MAJOR_MODE_NOT_SET
+
+ *******************************************************************************/
+
+vtss_rc vtss_fifo_setup( vtss_fifo_setup_t *ps_ingress, 
+		vtss_fifo_setup_t *ps_egress)
+{
+	int i, ppn;
+	ulong reg, mask;
+
+	/* Only one global device per API is currently supported */
+	vtss_device_setup_t *pvds = pdevice;
+	if ( pvds->mmode == VTSS_MAC_MAJOR_MODE_UNDEFINED) { return VTSS_MAJOR_MODE_NOT_SET; }
+
+	for ( i=1; i<=VTSS_PORTS_1G; i++) {
+
+		ppn = vtss_logical_ports[i].chip_port;
+		if( ppn < 0 ) { continue; }
+
+		/* Clear pointer mode when changing top/bottom */
+		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
+				M2_TEST + ppn, M2_TEST_FIFO_CLR, 0xF);
+		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+				M2_TEST + ppn, M2_TEST_FIFO_CLR, 0xF);
+
+		/* TOP and BOTTOM values */
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_TOP_BOTTOM + ppn, 
+				(ulong)((ps_ingress->fifo_port_area[i].top<<16) | 
+					ps_ingress->fifo_port_area[i].bottom));
+
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_TOP_BOTTOM + ppn, 
+				(ulong)((ps_egress->fifo_port_area[i].top<<16) | 
+					ps_egress->fifo_port_area[i].bottom));
+
+		/* Watermarks */
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_HIGH_LOW_WM + ppn, 
+			(ulong)((ps_ingress->fifo_port_wm[i].low_watermark<<16) | 
+					ps_ingress->fifo_port_wm[i].high_watermark));
+
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_HIGH_LOW_WM + ppn, 
+			(ulong)((ps_egress->fifo_port_wm[i].low_watermark<<16) | 
+				ps_egress->fifo_port_wm[i].high_watermark));
+
+		/* Threshold, if cut-through mode enabled */
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_CT_THRHLD + ppn, 
+				(ulong)((ps_ingress->thrhld[i].cut_through_enable)?
+					ps_ingress->thrhld[i].threshold_value:0));
+
+		vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_CT_THRHLD + ppn, 
+				(ulong)((ps_egress->thrhld[i].cut_through_enable)?
+					ps_egress->thrhld[i].threshold_value:0));
+
+		/* Enable FIFO again */
+		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
+				M2_TEST + ppn, M2_TEST_FIFO_NORMAL, 0xF);
+		vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+				M2_TEST + ppn, M2_TEST_FIFO_NORMAL, 0xF);
+	}
+
+	/* Ageing */
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_AGE_INC,
+		 (ps_ingress->ageing.enable)? ps_ingress->ageing.interval:0);
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_AGE_INC, 
+			(ps_egress->ageing.enable)? ps_egress->ageing.interval:0);
+
+	/* --- Ingress FIFO control register setup (major mode dependent) --- */
+	reg = 0;
+	if( ps_ingress->prm_hdr_used != FALSE) { SET_BIT( reg, 9); }
+
+	if( ps_ingress->norm_hdr_used != FALSE) {
+		SET_BIT( reg, 8);
+		/* Ingress FIFO gets data only from MACs thus bit 
+		   LE must always be set when the normalized header is used */
+		SET_BIT( reg, 13);
+	}
+
+	/* OUT_PORT_OFFSET */
+	reg  |= (ps_ingress->output_port_offset<<28) & 0xF0000000;
+
+	/* IN_PORT_OFFSET */
+	reg  |= (ps_ingress->input_port_offset<<24) & 0x0F000000;
+
+	/* Single Channel, M10G mode */
+	if (pvds->mmode == VTSS_MAC_MAJOR_MODE_SPI4_10G){ SET_BIT( reg, 5); }
+
+	/* Ingress FIFO by default is always set to run in burst-interleaved mode */
+	SET_BIT( reg, 4);
+
+	/* MUX bits, SS bit and burst size */
+	if ( (pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR) ||
+			(pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK)) {
+		/* if Single Chip aggr or single chip trunking */
+		SET_BIT( reg, 16);
+		SET_BIT( reg, 7);
+		/* burst size towards 1G ports */
+		SET_BITS_MASKED( reg, 
+			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT, 0xF);
+	} else {
+		/* burst size towards SPI4.2 */
+		SET_BITS_MASKED( reg, 
+			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_SPI4_2, 0xF); 
+	}
+
+	/* Enable the FIFO */
+	CLR_BIT( reg, 6);
+
+	mask = 0xFF0323FF;
+	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
+		M2_ING_CONTROL, reg, mask);
+
+
+	/* --- Egress FIFO control register setup (major mode dependent) --- */
+	reg = 0;
+	if( ps_egress->prm_hdr_used != FALSE) { SET_BIT( reg, 9); }
+
+	if( ps_egress->norm_hdr_used != FALSE) {
+		SET_BIT( reg, 8);
+		/* Single Chip aggr o trunking */
+		if( ( pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_AGGR) || 
+			( pvds->mmode == VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK)) {
+			/* Receiving data from 1G MACs in SMES mode */
+			SET_BIT( reg, 13);
+		} else {
+			/* Receiving data from SPI4.2 always SME mode */
+			CLR_BIT( reg, 13);
+		}
+	}
+
+	/* OUT_PORT_OFFSET */
+	reg  |= (ps_egress->output_port_offset<<28) & 0xF0000000;
+
+	/* IN_PORT_OFFSET */
+	reg  |= (ps_egress->input_port_offset<<24) & 0x0F000000;
+
+	switch (pvds->mmode) {
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:       /* SPI4 <-> 1x10G */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK: /* */
+			CLR_BIT( reg, 17);
+			CLR_BIT( reg, 16); /* MUX bits */
+			CLR_BIT( reg, 7); /* SS bit */
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:        /* SPI4 <-> 10x1G */
+			CLR_BIT( reg, 17);
+			SET_BIT( reg, 16); /* MUX bits */
+			SET_BIT( reg, 7); /* SS bit */
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:    /* single chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:   /* single chip trunking */
+			SET_BIT( reg, 17);
+			CLR_BIT( reg, 16); /* MUX bits */
+			CLR_BIT( reg, 7); /* SS bit */
+			break;
+
+		default:
+			break;
+	}
+
+	/* Activate the FIFO */
+	CLR_BIT( reg, 6);
+
+	/* Frame-, burst- interleaving and burst size */
+	switch (pvds->mmode) {
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:  /* Single Channel, M10G mode */
+			/* Egress FIFO sends data to 10G MAC from onei
+			 channel burst-interleaved is fine */
+			SET_BIT( reg, 4);
+			SET_BIT( reg, 5);
+			SET_BITS_MASKED( reg, 
+			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT, 0xF);
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:   /* */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:     /* Single Chip aggr */
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:    /* Single Chip trunking */
+			/* Egress FIFO sends data to 10G MAC 
+			from upto 10 channels always frame-interleaved */
+			CLR_BIT( reg, 4);
+			/* It's recommended to write a value into the 
+			   burst size bitfield even  when running in frame-interleaved
+			     mode */
+			SET_BITS_MASKED( reg, 
+			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT, 0xF);
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G: /* SPI4 <-> 10x1G */
+			/* Egress FIFO sends data to 1G MACs from upto
+			 10 channels always burst-interleaved */
+			SET_BIT( reg, 4);
+			SET_BITS_MASKED( reg,
+			VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT, 0xF);
+			break;
+
+		default:
+			break;
+	}
+
+	mask = 0xFF0323FF;
+	vtss_io_writemasked( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+				M2_EGR_CONTROL, reg, mask);
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ * Description:
+ *     This is a supplementary function. It configures a structure referenced 
+ *     by the pointer to the default values for the chosen major mode.
+ *     After that the user may modify the fields of the structure for 
+ *     fine-tuning of the system and then call the vtss_fifo_setup() function.
+ *
+ * Arguments:
+ *     ps_ingress   pointer to a structure for the ingress fifo
+ *     ps_egress    pointer to a structure for the egress fifo
+ *     major_mode   select the major mode  for the session
+ *
+ * Return code:
+ *     VTSS_OK      if operation completed successfully
+ *     VTSS_WRONG_MAJOR_MODE
+ *     VTSS_PORT_NOT_MAPPED
+ *
+ **************************************************************************kbp*/
+vtss_rc vtss_fifo_setup_get_default_values( vtss_fifo_setup_t *ps_ingress,
+		vtss_fifo_setup_t *ps_egress,
+		vtss_mac_major_mode_t major_mode)
+{
+	uint  i;
+	uint  ports = 0;
+	uint  ingress_tb = 0;
+	uint  egress_tb  = 0;
+	ulong fifo_ingress_block_size = 0x0; 
+	ulong fifo_egress_block_size  = 0x0; 
+
+	switch (major_mode) {
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:   /* SPI4 <-> 1x10G */
+			ps_ingress->prm_hdr_used = FALSE;
+			ps_ingress->norm_hdr_used = FALSE;
+			ps_egress->prm_hdr_used = FALSE;
+			ps_egress->norm_hdr_used = FALSE;
+
+			ps_ingress->output_port_offset = 0;
+			ps_ingress->input_port_offset = 0;
+			ps_egress->output_port_offset = 0;
+			ps_egress->input_port_offset = 0;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+			ps_ingress->prm_hdr_used = FALSE;
+			ps_ingress->norm_hdr_used = FALSE;
+			ps_egress->prm_hdr_used = FALSE;
+			ps_egress->norm_hdr_used = FALSE;
+
+			ps_ingress->output_port_offset = 0;
+			ps_ingress->input_port_offset = 0xA;
+			ps_egress->output_port_offset = 0xA;
+			ps_egress->input_port_offset = 0;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+			ps_ingress->prm_hdr_used = FALSE;
+			ps_ingress->norm_hdr_used = FALSE;
+			ps_egress->prm_hdr_used = FALSE;
+			ps_egress->norm_hdr_used = TRUE;
+
+			ps_ingress->output_port_offset = 0xA;
+			ps_ingress->input_port_offset = 0;
+			ps_egress->output_port_offset = 0;
+			ps_egress->input_port_offset = 0xA;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+			ps_ingress->prm_hdr_used = TRUE;
+			ps_ingress->norm_hdr_used = FALSE;
+			ps_egress->prm_hdr_used = TRUE;
+			ps_egress->norm_hdr_used = TRUE;
+
+			ps_ingress->output_port_offset = 0xA;
+			ps_ingress->input_port_offset = 0;
+			ps_egress->output_port_offset = 0;
+			ps_egress->input_port_offset = 0xA;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+			ps_ingress->prm_hdr_used = FALSE;
+			ps_ingress->norm_hdr_used = TRUE;
+			ps_egress->prm_hdr_used = FALSE;
+			ps_egress->norm_hdr_used = TRUE;
+
+			ps_ingress->output_port_offset = 0;
+			ps_ingress->input_port_offset = 0;
+			ps_egress->output_port_offset = 0;
+			ps_egress->input_port_offset = 0;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			ps_ingress->prm_hdr_used = TRUE;
+			ps_ingress->norm_hdr_used = TRUE;
+			ps_egress->prm_hdr_used = TRUE;
+			ps_egress->norm_hdr_used = TRUE;
+
+			ps_ingress->output_port_offset = 0;
+			ps_ingress->input_port_offset = 0;
+			ps_egress->output_port_offset = 0;
+			ps_egress->input_port_offset = 0;
+			break;
+
+		default:
+			/* VTSS_MAC_MAJOR_MODE_UNDEFINED */
+			return VTSS_WRONG_MAJOR_MODE;
+	}
+
+	fifo_ingress_block_size = VTSS_MAX_INGRESS_FIFO_SIZE >> 11;
+	fifo_egress_block_size  = VTSS_MAX_EGRESS_FIFO_SIZE  >> 11;
+
+	/* Single Channel mode, 10G is logical port number 1 */
+	if (major_mode == VTSS_MAC_MAJOR_MODE_SPI4_10G) {   /* SPI4 <-> 1x10G */
+
+		/* vtss_fifo_block_t  */
+		ps_ingress->fifo_port_area[1].bottom = 0;
+		ps_ingress->fifo_port_area[1].top = fifo_ingress_block_size;
+		ps_egress->fifo_port_area[1].bottom = 0;
+		ps_egress->fifo_port_area[1].top = fifo_egress_block_size;
+
+		/* vtss_fifo_fc_watermarks_t */
+		ps_ingress->fifo_port_wm[1].low_watermark = 0xFFFFFFFF;
+		ps_ingress->fifo_port_wm[1].high_watermark = 0xFFFFFFFF;
+		ps_egress->fifo_port_wm[1].low_watermark = 0xFFFFFFFF;
+		ps_egress->fifo_port_wm[1].high_watermark = 0xFFFFFFFF;
+
+		/* cut-through mode/threshold. If not enabled then store-forward */
+		/* vtss_fifo_cut_through_mode_t */
+		ps_ingress->thrhld[1].cut_through_enable = FALSE;
+		ps_ingress->thrhld[1].threshold_value = 0;
+		ps_egress->thrhld[1].cut_through_enable = FALSE;
+		ps_egress->thrhld[1].threshold_value = 0;
+
+	} else {
+
+		/* Multi Channel mode */
+		for( i=1; i<=VTSS_PORTS_1G; i++ ) {
+			if( vtss_logical_ports[i].chip_port >= 0 ) { ports++; }
+		}
+
+		if ( ports == 0 ) { return VTSS_PORT_NOT_MAPPED; } 
+		fifo_ingress_block_size = fifo_ingress_block_size / ports;
+		fifo_egress_block_size  = fifo_egress_block_size  / ports;
+
+
+		for(i=1; i<=VTSS_PORTS_1G; i++) {
+			if( vtss_logical_ports[i].chip_port < 0 ) { continue; }
+
+			/* TOP and BOTTOM values */
+			ps_ingress->fifo_port_area[i].bottom = ingress_tb;
+			ingress_tb = ingress_tb + fifo_ingress_block_size;
+			ps_ingress->fifo_port_area[i].top = ingress_tb;
+			ps_egress->fifo_port_area[i].bottom = egress_tb;
+			egress_tb = egress_tb + fifo_egress_block_size;
+			ps_egress->fifo_port_area[i].top = egress_tb;
+			/*VTSS_D(("tb: 0x%08lX 0x%08lX", ingress_tb, egress_tb));*/
+
+			/* Watermarks */
+			ps_ingress->fifo_port_wm[i].low_watermark = 0xFFFFFFFF;
+			ps_ingress->fifo_port_wm[i].high_watermark = 0xFFFFFFFF;
+			ps_egress->fifo_port_wm[i].low_watermark = 0x40; 
+			ps_egress->fifo_port_wm[i].high_watermark = 256; 
+
+			/* cut-through mode/threshold. If not enabled then store-forward */
+			ps_ingress->thrhld[i].cut_through_enable = FALSE;
+			ps_ingress->thrhld[i].threshold_value = 0;
+			ps_egress->thrhld[i].cut_through_enable = FALSE;
+			ps_egress->thrhld[i].threshold_value = 0;
+		}
+
+	}
+
+	/* vtss_fifo_ageing_t */
+	ps_ingress->ageing.enable = FALSE;
+	ps_ingress->ageing.interval = 0;
+	ps_egress->ageing.enable = FALSE;
+	ps_egress->ageing.interval = 0;
+
+	return VTSS_OK;
+}
+
+/*-----------------  Run-time funcitons   ------------------------------------*/
+
+
+
+/*******************************************************************************
+  Function 
+  Syntax 
+  Parameters 
+
+  Returns 
+  VTSS_OK        No errors detected
+
+  Description
+
+ ********************************************************************************/
+vtss_rc vtss_fifo_thrhld_set( vtss_port_no_t portnum, 
+		vtss_fifo_cut_through_mode_t *pctt_ingress,
+		vtss_fifo_cut_through_mode_t *pctt_egress)
+{
+	/* Find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+
+	/* Check the physical port number */
+	if (ppn == -1) { return VTSS_PORT_NOT_MAPPED; }
+
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
+			M2_CT_THRHLD + ppn, 
+			(pctt_ingress->cut_through_enable)?
+			(pctt_ingress->threshold_value):0);
+
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+			M2_CT_THRHLD + ppn, 
+			(pctt_egress->cut_through_enable)?
+				(pctt_egress->threshold_value):0);
+
+	return VTSS_OK;
+}
+
+
+/*******************************************************************************
+  Function 
+  vtss_fifo_watermarks_set()
+
+  Syntax 
+  vtss_fifo_watermarks_set( vtss_port_no_t portnum,
+  vtss_fifo_fc_watermarks_t *pwm_ingress,
+  vtss_fifo_fc_watermarks_t *pwm_egress)
+  Parameters 
+  portnum        Logical port number
+  pwm_ingress    Pointer to the 'watermarks' structure in ingress direction. 
+  If set to NULL no initialization is performed.
+  pwm_egress     Pointer to the 'watermarks' structure in egress directon.
+  If set to NULL no initalization is performed
+
+  Returns 
+  VTSS_OK        No errors detected
+
+  Description
+  This function sets watermarks for a given logical port
+
+ ********************************************************************************/
+vtss_rc vtss_fifo_watermarks_set( vtss_port_no_t portnum,
+		vtss_fifo_fc_watermarks_t *pwm_ingress,
+		vtss_fifo_fc_watermarks_t *pwm_egress)
+{
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+	/* check the physical port number */
+	if (ppn == -1) {
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, M2_HIGH_LOW_WM + ppn, 
+			(ulong)((pwm_ingress->low_watermark<<16) |
+			 pwm_ingress->high_watermark));
+
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, M2_HIGH_LOW_WM + ppn, 
+			(ulong)((pwm_egress->low_watermark<<16) |  
+			pwm_egress->high_watermark));
+
+	return VTSS_OK;
+}
+
+
+/*
+
+   Set a fifo to expect incoming data with/without the header (normalised or 
+   preamble)
+
+   The function does not check how the fifo is configured. (Note: running in 
+   cut-through mode with the header makes no sense)
+
+
+   Parameters
+   fifo      which fifo to use: engress or ingress
+   enable    enable or disable the feature
+   if TRUE,  incoming frame have normalized and/or preamble header
+   if FALSE, incoming frame co not have normalized and/or preamble 
+   header
+   hdr       Describes what header to expect
+
+	Note: this function will set or clear only that bit in the register which 
+	corresponding element in the 'hdr' structure is set, i.e. it will not 
+	affect preamble header settings, if the use_prm_hdr element is not set.
+
+ */
+static void vtss_fifo_use_hdr( int fifo, BOOL enable, m2_header_t hdr)
+{
+	ulong value = 0;
+	ulong mask = 0;
+	ulong reg_offset = 0;
+
+	switch( fifo) {
+		case M2_SUBBLK_EGRESS:
+			reg_offset = M2_EGR_CONTROL;
+			break;
+		case M2_SUBBLK_INGRESS:
+			reg_offset = M2_ING_CONTROL;
+			break;
+		default:
+			return;
+	}
+
+	if ( hdr.use_norm_hdr != FALSE) {
+		if ( enable != FALSE)
+			SET_BIT( value, 8);
+		SET_BIT( mask, 8);
+	}
+
+	if ( hdr.use_prm_hdr != FALSE){
+		if (enable != FALSE)
+			SET_BIT( value, 9);
+		SET_BIT( mask, 9);
+	}
+
+
+
+	vtss_io_writemasked( M2_BLK_FIFO, fifo, reg_offset, value, mask);
+
+	return;
+}
+
+
+#define VTSS_MIIM_READ_OPR      0x2
+#define VTSS_MIIM_WRITE_OPR     0x1
+
+#define VTSS_MIIM_OPR_MODE      0x1
+#define VTSS_MDIO_OPR_MODE      0x0
+
+
+/* Direct miim read/write operation using miim_controller address as a 
+   parameter */
+long vtss_miim_subblock_read( const uint miim_chnl, const uint phy_addr, 
+		const uint phy_reg)
+{
+	uint opcode = VTSS_MIIM_READ_OPR; /* read operation */
+	uint mode = VTSS_MIIM_OPR_MODE; /* MIIM operation, not MDIO */
+	ulong i = 0;
+	ulong data;
+
+
+	/* read status of the channel */
+	while ( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, 
+				miim_chnl, M2_MIIM_STATUS))) {
+		i++;
+		if(i > VTSS_MIIM_READ_ATTEMPT) {
+			return VTSS_MIIM_CHANNEL_BUSY;
+		}
+	}
+
+
+	vtss_io_write( M2_BLK_MIIM, miim_chnl, M2_MIIM_CMD, 
+			(phy_addr<<9)|(phy_reg<<4)|(opcode <<2)|mode);
+
+
+	/* read status of the channel */
+	while ( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, 
+			miim_chnl, M2_MIIM_STATUS))) {
+		VTSS_NSLEEP( 2000000); /* sleep 2 uS */
+		i++;
+		if(i > VTSS_MIIM_READ_ATTEMPT) {
+			printk("API: channel busy2\n");
+			return VTSS_MIIM_CHANNEL_BUSY;
+		}
+	}
+
+	data = vtss_io_read( M2_BLK_MIIM, miim_chnl, M2_MIIM_DATA);
+
+	return (data & ((ulong)1 << 16))?(-1):(data&0xFFFF);
+
+}
+
+
+void vtss_miim_subblock_write( const uint miim_chnl, const uint phy_addr, 
+		const uint phy_reg, const ushort value)
+{
+	uint opcode = VTSS_MIIM_WRITE_OPR; /* write operation */
+	uint mode = VTSS_MIIM_OPR_MODE; /* MIIM operation, not MDIO */
+
+
+	/* read status of the channel */
+	while( 0 != (0x1C & vtss_io_read( M2_BLK_MIIM, miim_chnl, M2_MIIM_STATUS))) 
+		; /* wait until the channel is ready */
+
+
+	vtss_io_write( M2_BLK_MIIM, miim_chnl, M2_MIIM_CMD, 
+	(ulong)((value<<16)|(phy_addr<<9)|(phy_reg<<4)|(opcode <<2)|mode));
+
+	return;
+}
+
+
+/* Indirect miim read/write operation. Accesses the PHY corresponding to the 
+   logical port number (PHY address is found via the mapping table)
+ */
+long vtss_miim_port_reg_read( const vtss_port_no_t portnum, 
+		const uint phy_reg){
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+	int miimchnl =  vtss_logical_ports[portnum].miim_controller;
+	int phy_addr =  vtss_logical_ports[portnum].phy_addr;
+	long data;
+
+	/* check the physical port number */
+	if (ppn == -1) {
+		printk("API: port not mapped\n");
+		return VTSS_PORT_NOT_MAPPED;
+	}
+
+	/* long */ 
+	data = vtss_miim_subblock_read( miimchnl, phy_addr,  phy_reg);
+	return data;
+}
+
+void  vtss_miim_port_reg_write( const vtss_port_no_t portnum, 
+		const uint phy_reg, const ushort value)
+{
+	/* find the physical port number in the global map table */
+	/* int ppn = vtss_logical_ports[portnum].chip_port; */
+	int miimchnl =  vtss_logical_ports[portnum].miim_controller;
+	int phy_addr =  vtss_logical_ports[portnum].phy_addr;
+
+	/* long */ 
+	vtss_miim_subblock_write( miimchnl, phy_addr,  phy_reg, value);
+}
+
+
+BOOL vtss_phy_mapped( const vtss_port_no_t port_no )
+{
+	return (vtss_logical_ports[port_no].phy_addr != -1);
+
+}
+
+/*******************************************************************************
+  Policing and shaping traffic.
+
+	Terminology:
+	Policer limits traffic in ingress direction
+	Shaper does the same in engress direction
+
+	In functions below only the term 'shaper' is used.
+ ********************************************************************************/
+static int get_shaper_register( int port_on_chip)
+{
+	if ( port_on_chip >= 0 && port_on_chip <= 7)
+		return 0xA | (port_on_chip << 4);
+	else if ( port_on_chip >= 8 && port_on_chip <= 9)
+		return 0xB | ((port_on_chip & 0x7) << 4);
+	else 
+		return -1;
+
+}
+
+/*******************************************************************************
+  Aggregation/trunking 
+ ********************************************************************************/
+
+/*
+   Initialises port map table of the aggregator.
+   The function must be called after virtual ports have been mapped to 
+   physical ports.
+   The function also tests whether the port is enabled or disabled.
+   Disabled ports are removed from the aggregation table.
+ */
+vtss_rc vtss_aggr_pmap_table_initialise( void)
+{
+	int i;
+	for ( i=0; i < M2_AGGR_PMAP_TABLE_SIZE; i++) {
+		vtss_aggr_pmap_table_set( i, i % VTSS_PORTS_1G);
+	}
+	return VTSS_OK;
+}
+
+/*
+   Writes one entry into the port map table of the aggregator
+ */
+vtss_rc vtss_aggr_pmap_table_set( int index, int portnum)
+{
+	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR,
+		 M2_PMAP_TABLE, (portnum<<8)|(index & 0xFF));
+
+	return VTSS_OK;
+}
+
+vtss_rc vtss_aggr_setup( vtss_aggr_mode_t *pamode)
+{
+	ulong reg_value = 0;
+	ulong reg_mask = 0x1BE; /* will not alter NLE,HDR,P_PAR and reserved bits */
+
+	if (pamode->preamble_trunking) {
+
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT0POS,
+				pamode->u.bit.pos0);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT1POS,
+				pamode->u.bit.pos1);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT2POS,
+				pamode->u.bit.pos2);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_PRE_BIT3POS,
+				pamode->u.bit.pos3);
+		reg_value = 1 << 5;
+
+	} else if (pamode->mpls_trunking) {
+
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT0,
+				pamode->u.bit.pos0);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT1,
+				pamode->u.bit.pos1);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT2,
+				pamode->u.bit.pos2);
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BIT3,
+				pamode->u.bit.pos3);
+		reg_value = (1<<8) |( 1<<7);
+
+	} else if (pamode->mpls_aggregation) {
+
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_MPLS_BITMASK,
+				pamode->u.mpls_bitmask);
+		reg_value = 1<<7;
+
+	} else if (pamode->l2_aggr || pamode->l3_aggr || pamode->l4_aggr) {
+
+		if ( pamode->l2_aggr)
+			SET_BIT( reg_value, 2);
+		if ( pamode->l3_aggr)
+			SET_BIT( reg_value, 3);
+		if ( pamode->l4_aggr)
+			SET_BIT( reg_value, 4);
+
+		SET_BIT(reg_value, 1);
+
+	}
+
+	if( pamode->norm_hdr_used == TRUE) {
+		SET_BIT( reg_value, 0);/* Norm header is present */
+		CLR_BIT( reg_value, 9);
+		/* NLE bit must be cleared when the norm header is present */
+	} else {
+		CLR_BIT( reg_value, 0);
+		SET_BIT( reg_value, 9);
+	}
+
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_AGGR, M2_AGGR_SETUP,
+			reg_value, reg_mask);
+
+	return VTSS_OK;
+}
+
+vtss_rc vtss_aggr_setup_get_default_values( vtss_aggr_mode_t* pam, 
+		vtss_mac_major_mode_t mmode)
+{
+
+	pam->preamble_trunking = FALSE;
+	pam->mpls_trunking = FALSE;
+	pam->mpls_aggregation = FALSE;
+	pam->l2_aggr = FALSE;
+	pam->l3_aggr = FALSE;
+	pam->l4_aggr = FALSE;
+
+	pam->u.bit.pos0 = 0;
+	pam->u.bit.pos1 = 0;
+	pam->u.bit.pos2 = 0;
+	pam->u.bit.pos3 = 0;
+
+	pam->u.mpls_bitmask = 0;
+
+	pam->norm_hdr_used = FALSE;
+
+
+	switch (mmode) {
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:   /* SPI4 <-> 1x10G */
+
+			return VTSS_WRONG_MAJOR_MODE;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:    /* SPI4 <-> 10x1G */
+
+			return VTSS_WRONG_MAJOR_MODE;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:
+			/* Default: layer 2 aggregation */
+			pam->l2_aggr = TRUE;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:
+
+			/* Default: preamble trunking */
+			pam->preamble_trunking = TRUE;
+
+			pam->u.bit.pos0 = M2_PREAMBLE_BIT0_POS;
+			pam->u.bit.pos1 = M2_PREAMBLE_BIT1_POS;
+			pam->u.bit.pos2 = M2_PREAMBLE_BIT2_POS;
+			pam->u.bit.pos3 = M2_PREAMBLE_BIT3_POS;
+
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:
+			/* Default: layer 2 aggregation */
+			pam->l2_aggr = TRUE;
+			break;
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:
+			/* Default: preamble trunking */
+			pam->preamble_trunking = TRUE;
+
+			pam->u.bit.pos0 = M2_PREAMBLE_BIT0_POS;
+			pam->u.bit.pos1 = M2_PREAMBLE_BIT1_POS;
+			pam->u.bit.pos2 = M2_PREAMBLE_BIT2_POS;
+			pam->u.bit.pos3 = M2_PREAMBLE_BIT3_POS;
+
+			break;
+
+		default:
+			/* VTSS_MAC_MAJOR_MODE_UNDEFINED */
+			return VTSS_WRONG_MAJOR_MODE;
+
+	}
+
+	return VTSS_OK;
+}
+
+
+/*
+   Inform the aggregator that frames are with/without a normalized and/or 
+   preamble header
+ */
+static void vtss_aggr_use_header( BOOL enable, m2_header_t hdr)
+{
+	ulong cfg_reg = 0;
+	BOOL prm_hdr_enabled = FALSE;
+	BOOL norm_hdr_enabled = FALSE;
+
+	if( hdr.use_norm_hdr == FALSE && hdr.use_prm_hdr == FALSE)
+		return;
+
+	cfg_reg = vtss_io_read( M2_BLK_FIFO, M2_BLK_SYSTEM, M2_CRC_CFG);
+
+	if ( cfg_reg & (1<<4)) {
+		switch (cfg_reg & 0xf) {
+			case 0:
+				prm_hdr_enabled = TRUE;
+				norm_hdr_enabled = TRUE;
+				break;
+			case 7:
+				prm_hdr_enabled = TRUE;
+				break;
+			case 9:
+				norm_hdr_enabled = TRUE;
+				break;
+			default:
+				break;
+		}
+	}
+
+	if( hdr.use_norm_hdr == TRUE) {
+
+		if( enable == TRUE) {
+			SET_BIT( cfg_reg, 4);
+			if( prm_hdr_enabled == TRUE)
+				cfg_reg &= ~(ulong)0xF;
+			else
+				cfg_reg = (cfg_reg & ~(ulong)0xF) + 9;
+
+		} else {
+			/* disable norm hdr */
+			if (prm_hdr_enabled == TRUE) {
+				SET_BIT( cfg_reg, 4);
+				cfg_reg = (cfg_reg & ~(ulong)0xF) + 7;
+			}
+
+		}
+
+	}
+
+	if (hdr.use_prm_hdr == TRUE) {
+
+		if ( enable == TRUE) {
+			SET_BIT( cfg_reg, 4);
+			if( norm_hdr_enabled == TRUE)
+				cfg_reg &= ~(ulong)0xF;
+			else
+				cfg_reg = (cfg_reg & ~(ulong)0xF) + 7;
+
+		} else {
+			/* disable preamble header */
+			if ( norm_hdr_enabled == TRUE) {
+				SET_BIT( cfg_reg, 4);
+				cfg_reg = (cfg_reg & ~(ulong)0xF) + 9;
+			}
+
+		}
+
+	}
+
+	vtss_io_writemasked( M2_BLK_FIFO, M2_BLK_SYSTEM, 
+				M2_CRC_CFG, cfg_reg, 0x1F);
+
+}
+
+
+/*
+   Works only in INGRESS direction. To use normalized header in egress direction
+   use the vtss_norm_hdr_expect_enable() function.
+
+   Configures the whole device to use normalized header in ingress direction.
+   In 1G<->SPI4 mode normalization (insertion of the normalized header)
+   is done by 1G MAC devices.
+   In other modes normalized header is inserted by 10G MAC.
+
+   Normalized header is needed when the ingress FIFO runs in frame-interleaved
+   mode. 
+
+   To enable normalized header (that also requires setting the LE/NLE bit):
+   - write to the 10M/100M/1G/10G MAC block
+   - write to the ingress FIFO
+   - 
+ */
+static vtss_rc vtss_hdr_insert( BOOL able, m2_header_t hdr)
+{
+
+	/* Global pointer to a structure that can tell in which mode we are */
+	vtss_device_setup_t *pdv = pdevice;
+	int i;
+
+	switch( pdv->mmode) {
+		case VTSS_MAC_MAJOR_MODE_SPI4_1G:        /* SPI4 <-> 10x1G */
+			/* configure all 1G devices to normalize frames */
+			for (i = M2_PHYS_PORT_1G_MIN; i <= M2_PHYS_PORT_1G_MAX; i++) {
+
+				vtss_port1G_header_insert( i, able, hdr);
+			}
+
+			/* Aggregator is not involved in this major mode */
+
+			/* Configure the ingress FIFO */
+			vtss_fifo_use_hdr( M2_SUBBLK_INGRESS, able, hdr);
+			break;
+
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR:  /* */
+			/* Aggregator must be configured */
+			vtss_aggr_use_header( able, hdr);
+
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK:  /* */
+
+			/* normalizer in 10G device, only one 10G port in M2 */
+			vtss_port10G_header_insert( able, hdr);
+
+			/* Aggregator must be configured */
+
+			/* Ingress FIFO must be configured to run with the norm header */
+			vtss_fifo_use_hdr( M2_SUBBLK_INGRESS, able, hdr);
+
+			break;
+
+
+			/* Undefined major mode */
+		case VTSS_MAC_MAJOR_MODE_UNDEFINED:
+			/* undefined major mode */
+			return VTSS_MAJOR_MODE_NOT_SET;
+
+
+			/* In the following two modes the ingress channel 
+			(1x10G->10x1G) always runs in burst-interleaved mode,
+			 i.e. without the normalised  header. Currently, 
+			there does not seem to be a reason to use 
+		   	normalisation of frames in ingress direction.
+
+			In the egress direction (10x1G->1x10G) the normalized header
+			is always enabled, because the egress fifo runs in 
+			frame-interleaved mode. Currently there is no reason to
+			disable it   */
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_AGGR:    /* single chip aggr */
+
+		case VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK:   /* single chip trunking */
+
+		/* In the next major mode ingress fifo always runs in the 
+		burst-interleaved  mode */
+		case VTSS_MAC_MAJOR_MODE_SPI4_10G:       /* SPI4 <-> 1x10G */
+
+		default:
+			return VTSS_WRONG_MAJOR_MODE;
+
+	}
+	return VTSS_OK;
+}
+
+/******************************************************************************
+ * Description: Set GPIO direction to input or output.
+ *
+ * \param gpio_no (input): GPIO pin number.
+ * \param output (input) : TRUE if output, FALSE if input.
+ *
+ * \return : Return code OK.
+ ******************************************************************************/
+vtss_rc vtss_gpio_direction_set(const vtss_gpio_no_t gpio_no, const BOOL output)
+{
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_GPIO_CTRL, 
+			output ? (ulong)1<<(gpio_no & 0xF) : 0, 
+			(ulong)1<<(gpio_no & 0xF));
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ * Description: Read from GPIO input pin.
+ *
+ * \param gpio_no (input): GPIO pin number.
+ *
+ * \return : TRUE if pin is high, FALSE if it is low.
+ ******************************************************************************/
+BOOL vtss_gpio_input_read(const vtss_gpio_no_t gpio_no)
+{
+	uint value;
+
+	value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, M2_GPIO_IN);
+
+	return ( value & ((ulong)1<<(gpio_no & 0xF))) ? 1 : 0;
+}
+
+
+/******************************************************************************
+ * Description: Write to GPIO output pin.
+ *
+ * \param gpio_no (input): GPIO pin number.
+ * \param value (input)  : TRUE to set pin high, FALSE to set pin low.
+ *
+ * \return : TRUE if pin is high, FALSE if it is low.
+ ******************************************************************************/
+vtss_rc vtss_gpio_output_write(const vtss_gpio_no_t gpio_no, const BOOL value)
+{
+	vtss_io_writemasked( M2_BLK_SYSTEM, M2_SUBBLK_CTRL, 
+		M2_GPIO_OUT, value ?
+		(ulong)1<<(gpio_no & 0xF) : 0, (ulong)1<<(gpio_no & 0xF));
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************/
+/***        BIST test                                **************************/
+/******************************************************************************/
+
+/******************************************************************************
+ * Description: Start a specific bist test
+ *
+ * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
+ *
+ * \return : VTSS_OK if write was started,
+ *           VTSS_BIST_CMD_FAILED if last write was still in progress.
+ **************************************************************************kbp*/
+vtss_rc vtss_chip_bist_start(const uint bist_no)
+{
+	ulong value = 0;
+
+	/*Last write completed?*/
+	value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD);
+	if ( (value & (1<<27)) != 0 ) { return  VTSS_BIST_CMD_FAILED; }
+
+	/*Enable bist_no test by writing 0x1 to the indirect BIST_COMMAND register*/
+	vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD,  
+			(1<<24)|(M2_BIST_COMMAND<<16)|(0x1<<8)|bist_no);
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ * Description: Get result for a specific bist test
+ *
+ * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
+ *                         >= VTSS_BIST_NAME_SIZE returns the write status.
+ *
+ * \return : VTSS_OK               when bist test went OK
+ *           VTSS_BIST_CMD_FAILED  when write accesses failed.
+ *           VTSS_BIST_TEST_FAILED when bist test failed.
+ **************************************************************************kbp*/
+vtss_rc vtss_chip_bist_result(const uint bist_no)
+{
+	ulong value = 0;
+	uint i = 0;
+
+	/* Test for any previous write errors */
+	if ( bist_no >= VTSS_BIST_NAME_SIZE ) {
+		value = vtss_io_read( M2_BLK_SYSTEM, M2_SUBBLK_BIST, M2_RAM_BIST_CMD);
+		if ( (value & (1<<25)) != 0 ) { return  VTSS_BIST_CMD_FAILED; }
+		return VTSS_OK;
+	}
+
+	/*Wait for the BIST test to be done RD_DATA and when valid.*/
+	while ( (value & 0x3FD) == 0 && i++ < 0xF ) {
+
+		/*Transfer bist_no BIST_STATUS register to the 
+		RAM_BIST_RESULT register*/
+		vtss_io_write( M2_BLK_SYSTEM, M2_SUBBLK_BIST, 
+			M2_RAM_BIST_CMD,  
+			(0<<24)|(M2_BIST_STATUS<<16)|(bist_no & 0x3f));
+
+		/*Wait for read to complete*/
+		do {
+			value = vtss_io_read( M2_BLK_SYSTEM, 
+			M2_SUBBLK_BIST, M2_RAM_BIST_RESULT);
+		} while ( (value & (1<<9) ) != 0 ) ;
+	}
+	return ( value & (ulong)1<<1 ? VTSS_OK : VTSS_BIST_TEST_FAILED );
+}
+
+
+/******************************************************************************
+ * Description: Setup for GFP-T handling in Campbell-I
+ *
+ * \param portnum
+ *          vtss_gfpt_setup_t* gs
+ *       
+ *
+ * \return : VTSS_OK               
+ *           VTSS_PORT_NOT_MAPPED
+ *           VTSS_WRONG_PARAMETER
+ **************************************************************************kbp*/
+vtss_rc vtss_gfpt_setup( vtss_port_no_t portnum, vtss_gfpt_setup_t* gs)
+{
+	ulong gfpt_rx_pcs_reg = 0;
+
+	/* find the physical port number in the global map table */
+	int ppn = vtss_logical_ports[portnum].chip_port;
+	/* Check the physical port number */
+	if (ppn < 0) { return VTSS_PORT_NOT_MAPPED; }
+
+	/* Check selected interface */
+	switch ( gs->interface_mode.interface_type) {
+		/* right interface */
+		case VTSS_PORT_INTERFACE_SERDES:
+			if (gs->interface_mode.speed != VTSS_SPEED_ETH_GFPT) {
+				return VTSS_WRONG_PARAMETER; 
+			}
+			break;
+		case VTSS_PORT_INTERFACE_TBI:
+			/* Select Rx path as TBI interface */
+			SET_BIT(gfpt_rx_pcs_reg, 8); 
+			break;
+			/* Error - wrong interface */
+		default:
+			return VTSS_WRONG_PARAMETER;
+	}
+
+	/* Setup client clock when in clock source mode. */
+	/* Note: Per default the GPIos are set as input. */
+	/* GBE: use Internal SerDes, FC/2,FC/4,FC: Use GPIO1,
+	 (2FC or GBE: Use GPIO4), ESC: Use GPIO7, DVB: Use GPIO10 */  
+	if (gs->source_mode_en) {
+		vtss_io_writemasked( M2_BLK_MACS, ppn, 
+		M2_DEV_SETUP, (ulong)((1<<20)|
+			(gs->interface_mode.speed<<16)), (ulong)17<<16);
+	}
+
+	/* Setup client signal for the Egress and Ingress direction */
+	switch (gs->interface_mode.speed) {
+	case VTSS_SPEED_ETH_GFPT:
+		/* Setup client signal */
+		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT1, 
+			(C1_GFPT_CLIENT_GBE<<16)|(C1_GFPT_CLIENT_GBE));
+		/* Setup PCS TX */
+		vtss_io_write( M2_BLK_MACS, ppn, 
+		C1_GFPT_PCS_TX, (ulong)(
+			(1<<20)|(0xF1<<4)|((gs->gfpt_en)? 1:0)));
+		break;
+	case VTSS_SPEED_FC2_GFPT: /* 6    bit/s Fibre Channel */
+	case VTSS_SPEED_FC4_GFPT: /* 7    bit/s Fibre Channel */
+	case VTSS_SPEED_1FC_GFPT: /* 8    1Gbit/s Fibre Channel or FICON*/
+	case VTSS_SPEED_2FC_GFPT: /* 9    2Gbit/s Fibre Channel */
+		/* Setup client signal */
+		vtss_io_write( M2_BLK_MACS, ppn,
+		C1_GFPT_CLIENT1, 
+		(C1_GFPT_CLIENT_FC<<16)|(C1_GFPT_CLIENT_FC));
+		/* Setup PCS TX */
+		vtss_io_write( M2_BLK_MACS, ppn, 
+		C1_GFPT_PCS_TX, (ulong)(
+			(3<<20)|(0xF1<<4)|((gs->gfpt_en)? 1:0)));
+		/* Rx Synchronization mode, FC/FICON */    
+		SET_BIT(gfpt_rx_pcs_reg, 1); 
+		break;
+	case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
+		/* Setup client signal */
+		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT1, 
+			(C1_GFPT_CLIENT_ESC<<16)|(C1_GFPT_CLIENT_ESC));
+		/* Setup PCS TX */
+		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_TX, 
+			(ulong)((0xF1<<4)|((gs->gfpt_en)? 1:0)));
+		/* Rx Synchronization mode, ESCON/SBCON */    
+		SET_BIT(gfpt_rx_pcs_reg, 2); 
+		break;
+	case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
+		/* Setup client signal */
+		vtss_io_write( M2_BLK_MACS, ppn, 
+		C1_GFPT_CLIENT1, (C1_GFPT_CLIENT_DVB<<16)|(C1_GFPT_CLIENT_DVB));
+		/*Setup PCS TX */
+		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_TX, 
+		(ulong)((0xF1<<4)|((gs->gfpt_en)? 1:0)));
+		/* Rx Synchronization mode, DVB ASI */    
+		SET_BIT(gfpt_rx_pcs_reg, 2); 
+		SET_BIT(gfpt_rx_pcs_reg, 1); 
+		break;
+
+		/* Error - wrong client */
+		default:
+			return VTSS_WRONG_PARAMETER;
+	}
+
+	/* Enable Rx symbol alignment, explicit bit 6=0 */
+	SET_BIT(gfpt_rx_pcs_reg, 7); 
+	/* Enable GFP-T processing */
+	if (gs->gfpt_en != FALSE) { SET_BIT(gfpt_rx_pcs_reg, 0); }
+	/* Setup PCS RX */
+	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_PCS_RX, gfpt_rx_pcs_reg);
+
+	/* Change FIFO Threshold levels for GFP-T */
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_INGRESS, 
+		M2_CT_THRHLD + ppn, (ulong)1); 
+	vtss_io_write( M2_BLK_FIFO, M2_SUBBLK_EGRESS, 
+		M2_CT_THRHLD + ppn, (ulong)((gs->threshold_level<<16)|1)); 
+
+	/* Setup rate adaptation rules */
+	if ( gs->rate_period >= 16 ) {
+		return VTSS_WRONG_PARAMETER;
+	} else if ( gs->rate_max_delta >= 8 ) {
+		return VTSS_WRONG_PARAMETER;
+	} else if ( gs->rate_min_idles >= 8 ) {
+		return VTSS_WRONG_PARAMETER;
+	} else {
+		vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CLIENT2, 
+		/* (ulong)1<<26 */
+		(gs->rate_period<<16) | (gs->rate_max_delta<<8) | 
+						gs->rate_min_idles);
+	}
+
+	/* Setup Ingress Pading rate */
+	if ( gs->rate_padding >= 1024) {
+		return VTSS_WRONG_PARAMETER;
+	} else {
+		vtss_io_write( M2_BLK_MACS, ppn, 
+		C1_GFPT_BLOCK_CODE, gs->rate_padding);
+	}
+
+	/* GFPT frame length */
+	if ( gs->frame_length <= 0 || gs->frame_length >= 256) {
+		return VTSS_WRONG_PARAMETER;
+	} else {
+		vtss_io_write( M2_BLK_MACS, ppn, 
+		C1_GFPT_FRM_LEN, gs->frame_length);
+	}
+
+	/* GFPT header */
+	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_HEAD_ENA,
+			(ulong)(((gs->egress_header_expect)? 1<<1:0) |
+			((gs->ingress_header_insert)? 1:0)));
+
+	/* Error correction */
+	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_BIT_ERR_CORR,
+		(ulong)((gs->egress_err_corr == VTSS_GFPT_DISABLE_ERR)? 0 : 
+		(1 | (gs->egress_err_corr<<1)) & 0x7));
+
+	/* GFP enable */
+	vtss_io_write( M2_BLK_MACS, ppn, C1_GFPT_CONFIG, 
+		(ulong)((gs->gfpt_en)? 1:0));
+
+	return VTSS_OK;
+}
+
+
+/******************************************************************************
+ * Description: Get default setting for GFP-T handling in Campbell-I
+ *
+ * \param     : vtss_gfpt_setup_t* gs
+ *              vtss_port_interface_mode_t  mode
+ *
+ * \return    : VTSS_OK               
+ *              VTSS_WRONG_PARAMETER
+ **************************************************************************kbp*/
+vtss_rc vtss_gfpt_setup_get_default_values( vtss_gfpt_setup_t* gs,
+		vtss_port_interface_mode_t mode)
+{
+
+	gs->gfpt_en = TRUE;
+	gs->interface_mode = mode;
+	gs->rate_padding = 0;
+	gs->egress_err_corr = VTSS_GFPT_FORWARD_ERR; /* Let 
+			uncorretable error come through */
+	gs->source_mode_en = FALSE; /* Let Campbell-I 
+		deliver the clock source for TBI */
+
+	/* Setup parameters specific for the client signal  */
+	switch (gs->interface_mode.speed) {
+		case VTSS_SPEED_ETH_GFPT:
+			gs->threshold_level = 14;
+			gs->rate_period = 12;
+			gs->rate_max_delta = 1;
+			gs->rate_min_idles = 3;
+			gs->frame_length = 95;
+			gs->ingress_header_insert = TRUE;
+			gs->egress_header_expect = TRUE;
+			break;
+		case VTSS_SPEED_2FC_GFPT: /* 6    2Gbit/s Fibre Channel */
+		case VTSS_SPEED_1FC_GFPT: /* 7    1Gbit/s Fibre 
+					Channel or FICON*/
+		case VTSS_SPEED_FC2_GFPT: /* 8    Gbit/s Fibre Channel */
+		case VTSS_SPEED_FC4_GFPT: /* 9    Gbit/s Fibre Channel */
+			gs->threshold_level = 12;
+			gs->rate_period = 12;
+			gs->rate_max_delta = 1;
+			gs->rate_min_idles = 2;
+			gs->frame_length = 13;
+			gs->ingress_header_insert = FALSE;
+			gs->egress_header_expect = FALSE;
+			break;
+		case VTSS_SPEED_ESC_GFPT: /* 10 200Mbit/s ESCON or SBCON */
+			gs->threshold_level = 8;
+			gs->rate_period = 10;
+			gs->rate_max_delta = 2;
+			gs->rate_min_idles = 2;
+			gs->frame_length = 1;
+			gs->ingress_header_insert = TRUE;
+			gs->egress_header_expect = TRUE;
+			break;
+		case VTSS_SPEED_DVB_GFPT: /* 11 270Mbit/s DVB ASI */
+			gs->threshold_level = 10;
+			gs->rate_period = 10;
+			gs->rate_max_delta = 2;
+			gs->rate_min_idles = 2;
+			gs->frame_length = 2;
+			gs->ingress_header_insert = TRUE;
+			gs->egress_header_expect = TRUE;
+			break;
+			/* Error - wrong client */
+		default:
+			return VTSS_WRONG_PARAMETER;
+	}
+
+	return VTSS_OK;
+}
diff --git a/drivers/net/rmi_spi4/vitesse_highlevel.h b/drivers/net/rmi_spi4/vitesse_highlevel.h
new file mode 100644
index 0000000..f3cca6c
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_highlevel.h
@@ -0,0 +1,1396 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/************************************************************-*- mode: C -*-*/
+/*                                                                          */
+/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
+/*                           All Rights Reserved.                           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                            Copyright Notice:                             */
+/*                                                                          */
+/*  Unpublished rights reserved under the copyright laws of the             */
+/*  United States of America, other countries and international treaties.   */
+/*  The software is provided without fee.                                   */
+/*  Permission to use,  copy, store, modify, disclose, transmit or          */
+/*  distribute the software is granted, provided that this copyright        */
+/*  notice must appear in any copy, modification, disclosure,               */
+/*  transmission or distribution of the software.                           */
+/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
+/*  trade secret and proprietary rights in the software.                    */
+/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
+/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
+/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                                                                          */
+/*  vitesse_highlevel.h  -- API functions and data structures for MAC       */
+/*                          devices.                                        */
+/*                                                                          */
+/*                                                                          */
+/****************************************************************************/
+#ifndef _VITESSE_HIGHLEVEL_H
+#define _VITESSE_HIGHLEVEL_H
+
+
+
+/******************************************************************************/
+/***        Common Type Definitions                  **************************/
+/******************************************************************************/
+
+#include <linux/types.h>
+#include "vitesse_common.h"
+
+/******     Return codes   ****************************************************/
+typedef int vtss_rc;
+
+#define VTSS_OK                        0	/* rc>=0 means OK */
+/* General warnings */
+#define VTSS_WARNING                (-0x01)	/* Error, but fixed by API. */
+/* General errors */
+#define VTSS_UNSPECIFIED_ERROR      (-0x02)
+#define VTSS_NOT_IMPLEMENTED        (-0x03)
+#define VTSS_INVALID_PARAMETER      (-0x04)
+#define VTSS_DATA_NOT_READY         (-0x05)
+#define VTSS_PORT_NOT_MAPPED        (-0x06)
+#define VTSS_FEATURE_NOT_SUPPORTED  (-0x07)
+#define VTSS_WRONG_PARAMETER        (-0x08)
+#define VTSS_MAJOR_MODE_NOT_SET     (-0x09)
+#define VTSS_WRONG_MAJOR_MODE       (-0x0A)
+#define VTSS_MIIM_CHANNEL_BUSY      (-0x0C)
+#define VTSS_PHY_READ_ERROR         (-0x0D)
+#define VTSS_PHY_NOT_MAPPED         (-0x0E)
+#define VTSS_PHY_ABILITY            (-0x0F)
+#define VTSS_BIST_CMD_FAILED        (-0x10)
+#define VTSS_BIST_TEST_FAILED       (-0x11)
+
+
+/******************************************************************************/
+/***        Type definitions common for 1G and 10G MAC ports   ****************/
+/******************************************************************************/
+typedef struct _vtss_mac_t
+{
+	uchar addr[6];				/* Network byte order */
+} vtss_mac_t;
+
+
+typedef enum _vtss_speed_t
+{
+	VTSS_SPEED_UNDEFINED,
+	VTSS_SPEED_10M,				/* 1   10Mbit/s Ethernet */
+	VTSS_SPEED_100M,			/* 2  100Mbit/s Ethernet */
+	VTSS_SPEED_1G,				/* 3    1Gbit/s Ethernet */
+	VTSS_SPEED_10G,				/* 4   10Gbit/s Ethernet */
+	VTSS_SPEED_ETH_GFPT,		/* 5    1Gbit/s Ethernet */
+	VTSS_SPEED_FC2_GFPT,		/* 6    Gbit/s Fibre Channel */
+	VTSS_SPEED_FC4_GFPT,		/* 7    Gbit/s Fibre Channel */
+	VTSS_SPEED_1FC_GFPT,		/* 8    1Gbit/s Fibre Channel or FICON */
+	VTSS_SPEED_2FC_GFPT,		/* 9    2Gbit/s Fibre Channel */
+	VTSS_SPEED_ESC_GFPT,		/* 10 200Mbit/s ESCON or SBCON */
+	VTSS_SPEED_DVB_GFPT			/* 11 270Mbit/s DVB ASI */
+} vtss_speed_t;
+
+
+/* In egress direction it is possible to alter FCS in those frames that 
+   were inserted in the stream without FCS, for ex. by the host 
+   
+   For this feature to work FCS check done in the SPI4 block must be 
+   disabled.
+*/
+typedef enum _vtss_fcs_modify_t
+{
+	VTSS_FCS_DO_NOTHING,
+	VTSS_FCS_UPDATE,
+	VTSS_FCS_ADD
+} vtss_fcs_modify_t;
+
+
+/******************************************************************************/
+/***        Major mode type definitions              **************************/
+/******************************************************************************/
+typedef enum _vtss_mac_major_mode_t
+{
+	VTSS_MAC_MAJOR_MODE_UNDEFINED,	/* After the reset */
+	VTSS_MAC_MAJOR_MODE_SPI4_1G,	/* SPI4 <-> 10x1G */
+	VTSS_MAC_MAJOR_MODE_SPI4_10G,	/* SPI4 <-> 1x10G */
+	VTSS_MAC_MAJOR_MODE_10G_1G_AGGR,	/* single chip aggr */
+	VTSS_MAC_MAJOR_MODE_10G_1G_TRUNK,	/* single chip trunking */
+	VTSS_MAC_MAJOR_MODE_SPI4_10G_AGGR,	/* */
+	VTSS_MAC_MAJOR_MODE_SPI4_10G_TRUNK	/* */
+} vtss_mac_major_mode_t;
+
+
+/******************************************************************************/
+/***        Device Specific Configuration                 *********************/
+/***        may be moved to a device specific .h file     *********************/
+/******************************************************************************/
+
+/* Time to wait after a reset in nanoseconds */
+#define VTSS_T_RESET                     2000000L
+
+#if defined MEIGS2 || defined VSC7321
+#define VTSS_MAX_INGRESS_FIFO_SIZE       (128*1024)
+#define VTSS_MAX_EGRESS_FIFO_SIZE        (128*1024)
+#elif defined CAMPBELL || defined VSC7331 || defined MEIGS2E || defined VSC7323
+/* Meigs2e and Campbell have 3Mbit ingress fifo, egress fifo is the same */
+#define VTSS_MAX_INGRESS_FIFO_SIZE       (3*128*1024)
+#define VTSS_MAX_EGRESS_FIFO_SIZE        (128*1024)
+#endif
+
+
+#define M2_TEST_FIFO_NORMAL              0x0
+#define M2_TEST_FIFO_RX_STOP             0x1
+#define M2_TEST_FIFO_CLR                 0x2
+#define M2_TEST_FIFO_TX_STOP             0x3
+#define M2_TEST_FIFO_REPLAY_TO_TOP       0x4
+#define M2_TEST_FIFO_REPLAY_TO_TAIL      0xC
+
+
+#define VTSS_MAX_FRAME_LENGTH            1518	/* 16-bit value */
+#define VTSS_MAX_FRAME_LENGTH_MASK       0xFFFF
+#define VTSS_MAX_IFG_VALUE               0xF	/*  4-bit value */
+#define VTSS_IFG_MASK                    0xF
+
+/* Recommended values for interframe gaps */
+#define VTSS_IFG1_1G                     5
+#define VTSS_IFG1_100M_HDX               6
+#define VTSS_IFG1_100M_FDX               7
+#define VTSS_IFG1_10M_HDX                6
+#define VTSS_IFG1_10M_FDX                7
+
+
+#define VTSS_IFG2_1G                     1
+#define VTSS_IFG2_100M_HDX               8
+#define VTSS_IFG2_100M_FDX               11
+#define VTSS_IFG2_10M_HDX                8
+#define VTSS_IFG2_10M_FDX                11
+
+
+#define M2_1G_PORT_CLOCK_MODE_10M        0x1
+#define M2_1G_PORT_CLOCK_MODE_100M       0x2
+#define M2_1G_PORT_CLOCK_MODE_1G_GMII    0x3
+#define M2_1G_PORT_CLOCK_MODE_1G_SERDES  0x4
+#ifndef VSC7321
+#define M2E_1G_PORT_CLOCK_MODE_TBI       0x5
+#endif
+
+#define M2_1G_PORT_CLOCK_MODE_MASK       0x7
+
+
+/* Order of bytes in a word and bits in a byte */
+#define M2_BIG_END_BYTE_BIG_END_BIT      0x99999999
+#define M2_LTL_END_BYTE_BIG_END_BIT      0x81818181
+
+#define M2_BIG_END_BYTE_LTL_END_BIT      0x18181818
+#define M2_LTL_END_BYTE_LTL_END_BIT      0x00000000
+
+
+ /**/
+#define M2_SW_GLOBAL_RESET               0x80000001
+/* Some default values */
+#define VTSS_PORT_1G_TX_PAUSE_VALUE      ((ushort)0xFF)
+#define VTSS_PORT_1G_TX_PAUSE_MASK       0xFFFF	/* 16bit field */
+/* #define VTSS_PORT_1G_TX_PAUSE_XON_XOFF   FALSE */
+#define VTSS_PORT_10G_TX_PAUSE_VALUE      ((ushort)0xFF)
+#define VTSS_PORT_10G_TX_PAUSE_MASK       0xFFFF	/* 16bit field */
+/* #define VTSS_PORT_10G_TX_PAUSE_XON_XOFF   FALSE */
+#define VTSS_SPI4_BURST_SIZE     4
+#define VTSS_SPI4_MAX_BURST_1    8
+#define VTSS_SPI4_MAX_BURST_2    8
+#define VTSS_SPI4_OUTPUT_FREQ_390MHZ   390
+#define VTSS_SPI4_OUTPUT_FREQ_312MHZ   312
+#define VTSS_SPI4_OUTPUT_FREQ_195MHZ   195
+#define VTSS_SPI4_OUTPUT_FREQ_156MHZ   156
+/* Meigs2 physical port numbering */
+#define M2_PHYS_PORT_1G_MIN   0
+#define M2_PHYS_PORT_1G_MAX   9
+#define M2_PHYS_PORT_10G     10
+/* Default values for preamble bit position */
+/*     same values as in the datasheet      */
+#define M2_PREAMBLE_BIT0_POS   0x37
+#define M2_PREAMBLE_BIT1_POS   0x36
+#define M2_PREAMBLE_BIT2_POS   0x35
+#define M2_PREAMBLE_BIT3_POS   0x34
+/* Default values for burst size from FIFO to the ouput module */
+#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_1G_PORT   1
+#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_10G_PORT  1
+#define VTSS_FIFO_DEFAULT_BURST_SIZE_TOWARDS_SPI4_2    4
+#define VTSS_SHAPER_BITRATE_UNIT_PER_PORT   152588
+#define VTSS_SHAPER_BITRATE_UNIT_PER_LINK   305176
+#define VTSS_SHAPER_LEAKY_BUCKET_UNIT          128
+/* GPIO number: VTSS_GPIO_NO_START..(VTSS_GPIO_NO_END-1) */
+typedef uint vtss_gpio_no_t;
+
+#define VTSS_GPIOS (16)
+#define VTSS_GPIO_NO_START ((vtss_gpio_no_t)0)
+#define VTSS_GPIO_NO_END   (VTSS_GPIO_NO_START+VTSS_GPIOS)
+
+
+
+/******************************************************************************/
+/***        Default Device Configuration             **************************/
+/******************************************************************************/
+
+/*-------        Mapping of logical into physical ports           ------------*/
+/* Port Number: 1..VTSS_PORTS */
+typedef uint vtss_port_no_t;	/* VTSS_PORT_NO_START..(VTSS_PORT_NO_END-1) */
+
+#define VTSS_PORTS              (10+1)
+#define VTSS_PORTS_1G           10
+#define VTSS_PORTS_10G          1	/* How many of the VTSS_PORTS are 10G ports */
+#define VTSS_CHIP_PORTS         11	/* Number of ports inside chip */
+#define VTSS_CHIP_PORT_IS_10G(chip_port) (chip_port == 10)
+
+#define VTSS_PORT_NO_START      ((vtss_port_no_t)1)	/* The first logical port 
+													   number is 1 */
+#define VTSS_PORT_NO_END        (VTSS_PORT_NO_START+VTSS_PORTS)
+#define VTSS_PORT_ARRAY_SIZE    VTSS_PORT_NO_END
+
+#define VTSS_PORT_IS_PORT(x)    (x>=VTSS_PORT_NO_START && x<VTSS_PORT_NO_END)
+
+/* MeigsII/MeigsIIe/Campbell port mapping: 0..9 -- 10/100/1000M, 10 -- 10G */
+
+
+
+
+/******************************************************************************/
+/***        General Device Configuration             **************************/
+/******************************************************************************/
+
+/* 1G ports of a MAC device are known to the user under the numbers on the 
+   front panel of the final system. This numeration is not necessarily the same 
+   as the internal numeration from 0..MAX_PORT_NUMBER. Thus the need for 
+   mapping. Terminology: logical port number -- the number on the front panel,
+   physical "chip_port" port number -- internal number from 0 to 
+   MAX_1G_PORT_NUMBER. Some additional information such as the address of the 
+   corresponding PHY device and the number of a MIIM controller to use to 
+   communicate with the PHY device is also in the mapping table */
+
+typedef struct _vtss_mapped_port_t
+{
+	int chip_port;				/* Physical port. Set to -1 if not in use. */
+	int miim_controller;		/* Set to 0 or 1. Set to -1 if not in use. */
+	int phy_addr;				/* Ignored if miim_controller==-1. */
+} vtss_mapped_port_t;
+
+
+/* 
+   Set physical addresses of logical ports. Index is logical port_no. 
+   The mapping table must be initialized early in the initialization phase,
+   as most funcitons use logical port number as an argument and get the
+   matching physical port from the table.
+*/
+vtss_rc vtss_port_map_set(const vtss_mapped_port_t
+						  mapped_ports[VTSS_PORT_ARRAY_SIZE]);
+
+BOOL vtss_port_mapped(const vtss_port_no_t port_no);
+
+
+/*******************************************************************************
+
+  Function vtss_major_mode_set( ).
+
+  Prepares the system to run in one of the major modes.
+  This function must be called only once after reset. If the function is 
+  called when the system is up and running it will return an error.
+  It is not allowed to call this function with VTSS_MAC_MAJOR_MODE_UNDEFINED
+  as an argument.
+
+*******************************************************************************/
+vtss_rc vtss_major_mode_set(vtss_mac_major_mode_t mm);
+
+
+
+/******************************************************************************/
+/***        System Configuration                     **************************/
+/******************************************************************************/
+typedef struct vtss_system_setup_t
+{
+
+	BOOL big_endian;			/* TRUE -- CPU interface runs as big-endian */
+	uint si_dummy_bytes;		/* number of dummy bytes that will be inserted in the 
+								   reply before valid data when serial interface is used
+								   at high frequency. Set to 0 if not used */
+
+	/* serdes_ref_clk_external must be TRUE when using VSC7323 or VSC7331 */
+	BOOL serdes_ref_clk_external;	/* TRUE serdes ref clk is external, 
+									   FALSE -- internal */
+
+	BOOL system_ref_clk_extern;	/* TRUE  -- one of the GPIO pins is used as 
+								   system clock input 
+								   FALSE -- internal source is used for the 
+								   system clock (default)
+								 */
+
+	BOOL single_chip_mode;		/* TRUE -- 1x10G<->10x1G mode is used 
+								   FALSE -- all other modes */
+
+	BOOL rx_chain_mode_10G;		/* TRUE -- when in 10G<->SPI4.2 mode 
+								   FALSE -- all other modes */
+
+} vtss_system_setup_t;
+
+
+/*
+  Function vtss_system_setup()
+
+  Performs most basic initialization of the chip.
+  The function must be called after start-up or chip reset.
+
+
+  Arguments:
+       psystem   pointer to a structure with configuration data
+
+  Return code:
+       VTSS_OK   if operation completed successfully
+       
+ */
+vtss_rc vtss_system_setup(vtss_system_setup_t * psystem);
+
+/* 
+   This is a supplementary function. It configures a structure referenced 
+   by the pointer to the default values for the chosen major mode.
+   After that the user may modify the fields of the structure for 
+   fine-tuning of the system and than call the vtss_system_setup() function.
+*/
+vtss_rc vtss_system_setup_get_default_values(vtss_system_setup_t * psystem,
+											 vtss_mac_major_mode_t
+											 major_mode);
+
+
+/* vtss_chip_reset() performs a software reset of the chip */
+void vtss_chip_reset(void);
+
+
+/* vtss_get_chip_id() returns the content of the chip identification register */
+ulong vtss_chip_id_get(void);
+
+
+
+/******************************************************************************/
+/***        FIFO Configuration                       **************************/
+/******************************************************************************/
+typedef struct _vtss_fifo_block_t
+{
+	uint top;					/* 2Kbytes granularity */
+	uint bottom;
+} vtss_fifo_block_t;
+
+
+/* Flow control watermarks */
+typedef struct _vtss_fifo_fc_watermarks_t
+{
+	uint low_watermark;			/* 32 bytes granularity */
+	uint high_watermark;
+} vtss_fifo_fc_watermarks_t;
+
+
+/* Cut-through threshold */
+typedef struct _vtss_fifo_cut_through_mode_t
+{
+	BOOL cut_through_enable;	/* If FALSE -- FIFO runs in store-forward mode */
+	uint threshold_value;
+} vtss_fifo_cut_through_mode_t;
+
+
+/* Ageing mode */
+typedef struct _vtss_fifo_ageing_t
+{
+	BOOL enable;				/* enables ageing timer */
+	uint interval;				/* ageing interval */
+} vtss_fifo_ageing_t;
+
+
+/* 
+   Used for one-time complete setup of the fifo. Usually used after reset,
+   Using this structure the user can alter the default setup of the block.
+*/
+/* May be used to initialize both ingress and egress fifo */
+typedef struct vtss_fifo_setup_t
+{
+
+	vtss_fifo_block_t fifo_port_area[VTSS_PORT_NO_START + VTSS_PORTS_1G];
+	vtss_fifo_fc_watermarks_t fifo_port_wm[VTSS_PORT_NO_START +
+										   VTSS_PORTS_1G];
+
+	/* cut-through mode/threshold. If not enabled then store-forward */
+	vtss_fifo_cut_through_mode_t thrhld[VTSS_PORT_NO_START + VTSS_PORTS_1G];
+
+	vtss_fifo_ageing_t ageing;
+
+	/* */
+	BOOL norm_hdr_used;
+	BOOL prm_hdr_used;
+
+	  /**/ ulong output_port_offset;
+	ulong input_port_offset;
+
+} vtss_fifo_setup_t;
+
+
+/*-----------------  FIFO setup funcitons   ----------------------------------*/
+
+/*
+  Function vtss_fifo_setup()
+
+  Initializes the FIFO block based on the information in the provided 
+  structures. If the pointer to the structure is set to NULL, the corresponding
+  FIFO will not be initialized (it will be left in its current state).
+
+  The function must be called after start-up and may be called at run-
+  time to reconfigure the FIFO. 
+
+  Note: port mapping table must be initialized.
+
+  Arguments:
+       ps_ingress   pointer to a structure for the ingress fifo
+       ps_egress   pointer to a structure for the egress fifo
+
+  Return code:
+       VTSS_OK   if operation completed successfully
+       
+ */
+vtss_rc vtss_fifo_setup(vtss_fifo_setup_t * ps_ingress,
+						vtss_fifo_setup_t * ps_egress);
+
+/* 
+   This is a supplementary function. It configures a structure referenced 
+   by the pointer to the default values for the chosen major mode.
+   After that the user may modify the fields of the structure for 
+   fine-tuning of the system and then call the vtss_fifo_setup() function.
+*/
+vtss_rc vtss_fifo_setup_get_default_values(vtss_fifo_setup_t * ps_ingress,
+										   vtss_fifo_setup_t * ps_engress,
+										   vtss_mac_major_mode_t major_mode);
+
+/*-----------------  Run-time funcitons   ------------------------------------*/
+/* 
+   Select store-forward or cut-through mode of fifo for a specified logical 
+   port 
+*/
+vtss_rc vtss_fifo_thrhld_set(vtss_port_no_t portnum,
+							 vtss_fifo_cut_through_mode_t * pctt_ingress,
+							 vtss_fifo_cut_through_mode_t * pctt_egress);
+
+/*
+  Configure watermarks for a given logical port
+*/
+vtss_rc vtss_fifo_watermarks_set(vtss_port_no_t portnum,
+								 vtss_fifo_fc_watermarks_t * pwm_ingress,
+								 vtss_fifo_fc_watermarks_t * pwm_egress);
+
+
+
+/******************************************************************************/
+/***      10M/100M/1G  Ethernet Port Configuration   **************************/
+/******************************************************************************/
+/* ================================================================= *
+ *  Port
+ * ================================================================= */
+
+/* - Port Setup (Operational) -------------------------------------- */
+
+/* The different interfaces for connecting MAC and PHY. */
+typedef enum _vtss_port_interface_t
+{
+	VTSS_PORT_INTERFACE_NO_CONNECTION,	/* No connection */
+	VTSS_PORT_INTERFACE_MII,	/* MII */
+	VTSS_PORT_INTERFACE_GMII,	/* GMII */
+	VTSS_PORT_INTERFACE_RGMII,	/* RGMII */
+	VTSS_PORT_INTERFACE_TBI,	/* TBI */
+	VTSS_PORT_INTERFACE_SERDES,	/* SERDES */
+	VTSS_PORT_INTERFACE_XAUI	/* XAUI */
+} vtss_port_interface_t;
+
+
+typedef struct _vtss_port_interface_mode_t
+{
+	vtss_port_interface_t interface_type;	/* not just "interface" because it 
+											   is a reserved word in C++ */
+	vtss_speed_t speed;
+} vtss_port_interface_mode_t;
+
+
+typedef struct _vtss_flowcontrol_setup_t
+{
+	BOOL obey;					/* Should PAUSE frames be obeyed. */
+	BOOL generate;				/* Show flow control:
+								   fdx: PAUSE frames, 
+								   hdx: backpressure  be generated. */
+	vtss_mac_t smac;
+} vtss_flowcontrol_setup_t;
+
+
+/* Interframe gaps */
+typedef struct _vtss_frame_gaps_t
+{
+
+	uint ifg1;
+	uint ifg2;
+
+} vtss_frame_gaps_t;
+
+
+
+/* Advertisement Word (Refer to IEEE 802.3 Clause 37):
+ *  MSB                                                                         LSB
+ *  D15  D14  D13  D12  D11  D10   D9   D8   D7   D6   D5   D4   D3   D2   D1   D0 
+ * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+ * | NP | Ack| RF2| RF1|rsvd|rsvd|rsvd| PS2| PS1| HD | FD |rsvd|rsvd|rsvd|rsvd|rsvd|
+ * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+ */
+
+/* enum used in vtss_autoneg_1000base_x_config_t */
+typedef enum _vtss_autoneg_1000base_x_remote_fault_t
+{
+	/* RF2 *//* RF1 */
+	VTSS_1000BASEX_LINK_OK = ((0 << 1) | (0 << 0)),
+	VTSS_1000BASEX_OFFLINE = ((1 << 1) | (0 << 0)),
+	VTSS_1000BASEX_LINK_FAILURE = ((0 << 1) | (1 << 0)),
+	VTSS_1000BASEX_AUTONEG_ERROR = ((1 << 1) | (1 << 0))
+} vtss_autoneg_1000base_x_remote_fault_t;
+
+typedef struct _vtss_autoneg_1000base_x_advertisement_t
+{
+	BOOL fdx;
+	BOOL hdx;
+	BOOL symmetric_pause;		/* a.k.a. PAUSE (PS1) */
+	BOOL asymmetric_pause;		/* a.k.a. ASM_DIR (PS2) */
+	vtss_autoneg_1000base_x_remote_fault_t remote_fault;
+	BOOL acknowledge;
+	BOOL next_page;
+} vtss_autoneg_1000base_x_advertisement_t;
+
+
+typedef struct _vtss_pcs_autoneg_control_t
+{
+	BOOL enable;
+	vtss_autoneg_1000base_x_advertisement_t advertisement;
+} vtss_pcs_autoneg_control_t;
+
+
+
+/* Used for the initial setup of the PCS module */
+typedef struct _vtss_pcs_control_t
+{
+
+	BOOL disable_lss_on_gpio14;
+
+	BOOL disable_link_timer;
+	BOOL debug_link_timer_select;
+
+	BOOL signal_detect_polarity_low;
+	BOOL signal_detect_enable;
+
+	BOOL show_complete_link_down_counter;
+
+	BOOL pcs_aneg_sw_resolve;
+
+	BOOL pcs_autoneg_enable;
+	BOOL pcs_autoneg_restart;
+
+	vtss_autoneg_1000base_x_advertisement_t advertisement;
+
+} vtss_pcs_control_t;
+
+
+/* Used for the setup of the Serdes module */
+#define VTSS_SERDES_CONFIG_WORD        0x0000003E
+/* the following two values to be written to the SERDES_TEST register */
+#define VTSS_SERDES_RESET_AND_ENABLE   0x00000003
+#define VTSS_SERDES_ENABLE             0x00000023
+
+
+/* Port setup, which may change dynamically, e.g. after auto-negotiation */
+typedef struct _vtss_port_setup_t
+{
+	vtss_port_interface_mode_t interface_mode;
+	BOOL fdx;					/* Full duplex: TRUE, 
+								   Half duplex: FALSE */
+	vtss_flowcontrol_setup_t flowcontrol;
+	vtss_frame_gaps_t frame_gaps;
+	BOOL enable_tx_pause_xon_xoff;
+	uint tx_pause_value;
+	uint maxframelength;		/* Max frame length. */
+	BOOL vlan_aware;
+	BOOL drop_on_length_error;
+	BOOL crc_update;
+	vtss_fcs_modify_t fcs_modify;
+	BOOL invert_gtx_tx_clock;	/* HW related */
+	BOOL invert_rx_clock;		/* HW related */
+	BOOL norm_hdr_insert;
+	BOOL prm_hdr_insert;
+	uint prm_hdr_value;
+	BOOL norm_hdr_expect;
+	BOOL prm_hdr_expect;
+} vtss_port_setup_t;
+
+
+/* Setup 10M/100M/1G port */
+vtss_rc vtss_port_setup(vtss_port_no_t portnum, vtss_port_setup_t * psetup);
+
+/* 
+   Supplementary function: fills the structure referenced by the pointer 
+   with the default values for a given major_mode.
+
+   Requires global port mapping table to be initialized
+*/
+vtss_rc vtss_port_setup_get_default_values(vtss_port_setup_t * psetup,
+										   vtss_mac_major_mode_t major_mode);
+
+/*----------------  Run-time funcitons  ---------------------------------------*/
+/* Configure speed and duplex mode of a 10M/100M/1G port */
+/*
+  Arguments:
+      portnum   logical port number
+      speed     10M, 100M, 1G
+      fdx       TRUE - full duplex, FALSE -- half duplex
+ */
+vtss_rc vtss_port_set_mode(vtss_port_no_t portnum, vtss_speed_t speed,
+						   BOOL fdx);
+
+/* Enable/disable rx, tx or both in a 10M/100M/1G port */
+vtss_rc vtss_port_set_enable(vtss_port_no_t portnum, BOOL rx_en, BOOL tx_en);
+
+
+/* Set CRC adding/updating mode */
+/* Only 10/100/1000 ports have this feature -- done in the denormalizer */
+vtss_rc vtss_port_fcs_modify(vtss_port_no_t portnum, vtss_fcs_modify_t mc);
+
+/* 
+   Discard/do_not_discard  Ethernet frames with wrong FCS in ingress direciton
+
+   Arguments:
+        portnum   logical port number
+	check     TRUE   -- frames with wrong FCS are discarded (default)
+	          FALSE  -- frames with wrong FCS are forwarded upstream
+*/
+vtss_rc vtss_port_check_fcs(vtss_port_no_t portnum, BOOL check);
+
+
+/* Allow pause frames pass through the device. By default 10M/100M/1G block
+   prevents propagation of pause frames through the device.
+ */
+vtss_rc vtss_port_forward_pause_frames(vtss_port_no_t portnum, BOOL allow);
+
+
+
+/*
+  obey -- obeys pause frames from external Eth client 
+  generate -- generate pause frames/backpressure upon request from the 
+              destination (FIFO or the host interface)
+
+  If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
+
+
+ */
+vtss_rc vtss_port_flow_control_mode(vtss_port_no_t port_num,
+									BOOL fc_obey, BOOL fc_generate);
+
+
+
+/******************************************************************************/
+/***      10G  Ethernet Port Configuration           **************************/
+/******************************************************************************/
+
+/* 10G Port setup */
+typedef struct _vtss_10Gport_setup_t
+{
+	vtss_port_interface_mode_t interface_mode;
+
+	vtss_flowcontrol_setup_t flowcontrol;
+
+	uint maxframelength;		/* Max frame length. */
+
+	BOOL enable_tx_pause_xon_xoff;
+	uint tx_pause_value;
+
+	BOOL vlan_aware;
+	BOOL pace_mode;
+	BOOL drop_on_length_error;
+	BOOL drop_in_range_error;
+
+	/* Extended End-of-packet and Start-of-packet checks */
+	BOOL ext_eop_check_enable;
+	BOOL ext_sop_check_enable;
+
+	vtss_fcs_modify_t fcs_modify;
+
+
+	/* Start-of-frame delimiter check */
+	/* Must be disabled, ie set to FALSE, when using preamble trunking */
+	BOOL sfd_check;
+
+	/* Use of the headers */
+	BOOL norm_hdr_insert;
+	BOOL prm_hdr_insert;
+
+	BOOL norm_hdr_expect;
+	BOOL prm_hdr_expect;
+
+
+} vtss_10Gport_setup_t;
+
+
+/* Setup 10G port */
+vtss_rc vtss_10Gport_setup(vtss_port_no_t port_num,
+						   vtss_10Gport_setup_t * psetup);
+
+/* 
+   Supplementary function: fills the structure referenced by the pointer 
+   with the default values for a given major_mode.
+
+*/
+vtss_rc vtss_10Gport_setup_get_default_values(vtss_10Gport_setup_t * psetup,
+											  vtss_mac_major_mode_t
+											  major_mode);
+
+/*----------------  Run-time funcitons  ---------------------------------------*/
+/* Enable/disable rx, tx or both in a 10G port */
+vtss_rc vtss_10Gport_set_enable(vtss_port_no_t port_num,
+								BOOL rx_en, BOOL tx_en);
+
+
+/* Set CRC adding/updating mode */
+vtss_rc vtss_10Gport_fcs_modify(vtss_port_no_t port_num,
+								vtss_fcs_modify_t mc);
+
+
+
+/* Allow pause frames pass through the device. By default 10G block
+   prevents propagation of pause frames through the device.
+ */
+vtss_rc vtss_10Gport_forward_pause_frames(vtss_port_no_t port_num,
+										  BOOL allow);
+
+
+
+/*
+  obey -- obeys pause frames from external Eth client 
+  generate -- generate pause frames/backpressure upon request from the 
+              destination (FIFO or the host interface)
+
+  If fc_obey AND fc_generate are set to FALSE, then flow control is disabled
+
+
+ */
+vtss_rc vtss_10Gport_flow_control_mode(vtss_port_no_t port_num,
+									   BOOL fc_obey, BOOL fc_generate);
+
+/*
+  Once a 10G Base-X optical module is connected to the XAUI port,
+  this function can use to drive an GPIO connected LED to visualize 
+  signal detection/link status. The CPU must poll this function.
+ */
+BOOL vtss_10Gport_signal_detect(void);
+
+
+/******************************************************************************/
+/***        Host Interface (SPI-4.2) Configuration     ************************/
+/******************************************************************************/
+
+/*--        type definitions                           -----------------------*/
+
+typedef enum _vtss_spi4_sch_mode_t
+{
+	/* Controled by Ingress(Egress)_Fifo_Ctrl register */
+	VTSS_SPI4_BURST_MODE_WITH_HEADER,	/* when user wants header on SPI4 */
+	VTSS_SPI4_BURST_MODE,		/* Burst interleaved output */
+	VTSS_SPI4_FRAME_MODE		/* Frame interleaved output */
+} vtss_spi4_sch_mode_t;
+
+
+typedef enum _vtss_spi4_training_mode_t
+{
+	/* VTSS_SPI4_TRAINING_AUTO not used in Meigs-II */
+	VTSS_SPI4_TRAINING_AUTO,	/* issue training sequences in response to all '11's
+								   in the status channel */
+	VTSS_SPI4_TRAINING_OFF,		/* don't issue training sequences */
+	VTSS_SPI4_TRAINING_FORCE	/* send training sequences continiously */
+} vtss_spi4_training_mode_t;
+
+
+typedef struct _vtss_spi4_setup_t
+{
+
+	/* 
+	   This stucture gives a possibility to alter the default configuration of
+	   the spi4 block after reset according to end-user needs.
+	 */
+
+	vtss_spi4_sch_mode_t sch_mode;
+	uint burst_size;
+	uint maxburst1;
+	uint maxburst2;
+
+	/* Parameters of the training mode (only in ingress direction) */
+	vtss_spi4_training_mode_t tm;
+	uint alpha;
+	uint tsperiod;
+
+	/* spi4 output frequency */
+	uint spi4_output_freq;		/* 390, 312, 195, 156 MHz */
+
+	/* For the description of the following four elements refer to the desription 
+	   of the SPI4 misc register in the datasheet */
+	BOOL spi4_swap_ingress_data;	/* Board dependent *//* Bit WI, SPI4 MISC reg */
+	BOOL spi4_swap_egress_data;	/* Board dependent *//* Bit WE, SPI4 MISC reg */
+	BOOL spi4_data_clock_skew;	/* Board dependent */
+	BOOL spi4_status_clock_skew;	/* Board dependent */
+
+	/* calendar length is defined by number of ports */
+	BOOL spi4_calendar_order_ascending;	/* Ascending or descending order */
+	uint spi4_calendar_m;
+
+	/* In ingress direction */
+	BOOL norm_hdr_strip;
+
+	/* In egress direction */
+	BOOL prm_hdr_expect;
+	BOOL norm_hdr_expect;
+
+
+} vtss_spi4_setup_t;
+
+
+/*--        Setup  Funtions                            -----------------------*/
+vtss_rc vtss_spi4_setup(vtss_spi4_setup_t * ps);
+
+/* Configures a user provided structure with values default for the selected 
+   major mode.
+*/
+vtss_rc vtss_spi4_setup_get_default_values(vtss_spi4_setup_t * ps,
+										   vtss_mac_major_mode_t mode);
+
+/*--        Run-time Functions                         -----------------------*/
+
+
+/*
+  Function vtss_spi4_fcs_check_enable()
+
+  The function turns on/off FCS check of Ehternet frames arriving from the 
+  host interface. This is done for all channels.
+
+
+  NOTE. FCS check in the SPI4 block must be OFF if the FCS modify feature is
+        used in the egress direction
+
+*/
+vtss_rc vtss_spi4_fcs_check_enable(BOOL check);
+
+
+/*
+  Function vtss_spi4_keep_norm_header()
+
+  The funciton controls whether to strip the normalised header or to keep it.
+  Usually the normalised header is stripped before the frame is sent over 
+  SPI4. However, if the remove receiver can use information in the header, 
+  keeping it may be an advantage.
+
+
+  NOTE. Works in ingress direction
+
+*/
+vtss_rc vtss_spi4_keep_norm_header(BOOL keep);
+
+
+
+/******************************************************************************/
+/***        Flow Control Configuration        *********************************/
+/******************************************************************************/
+
+/* 
+   Function device_flow_control() selects FIFO flow control mode 
+      transparent off -- filling of the FIFO causes generation of pause frames
+      transparent on  -- destination (host i/f), not FIFO, requests pause frames
+
+   Note:
+   This mode is enabled for all 10/100/1000 Eth ports simultaneously 
+*/
+vtss_rc vtss_device_transparent_flow_control_mode(BOOL ingress_enable,
+												  BOOL egress_enable);
+
+
+
+
+
+/******************************************************************************/
+/***        Statistics                                         ****************/
+/******************************************************************************/
+typedef struct _vtss_port_counters_t
+{
+
+	/* if a counter is not implemented in 10G or 1G module the software will 
+	   return 0 */
+	ulong rx_in_bytes;
+	ulong rx_symbol_carrier;
+	ulong rx_pause;
+	ulong rx_unsup_opcode;
+
+	ulong rx_ok_bytes;
+	ulong rx_bad_bytes;
+
+	ulong rx_unicast;
+	ulong rx_multicast;
+	ulong rx_broadcast;
+	ulong rx_crc;
+	ulong rx_alignment;			/* 10/100/1G mac only */
+	ulong rx_undersize;
+
+	ulong rx_fragments;
+	ulong rx_in_range_error;
+	ulong rx_out_of_range_error;
+	ulong rx_oversize;
+	ulong rx_jabbers;
+	ulong rx_size_64;
+
+	ulong rx_size_65_to_127;
+	ulong rx_size_128_to_255;
+	ulong rx_size_256_to_511;
+	ulong rx_size_512_to_1023;
+	ulong rx_size_1024_to_1518;
+	ulong rx_size_1519_to_max;
+
+	ulong rx_xgmii_prot_err;	/* Only on 10G MAC port */
+
+	ulong rx_ipg_shrink;
+
+
+	ulong tx_out_bytes;
+	ulong tx_pause;
+	ulong tx_ok_bytes;
+
+	ulong tx_unicast;
+	ulong tx_multicast;
+	ulong tx_broadcast;
+
+	ulong tx_multiple_coll;		/* 10/100/1G MAC only */
+	ulong tx_late_coll;			/* 10/100/1G MAC only */
+	ulong tx_xcoll;				/* 10/100/1G MAC only */
+	ulong tx_defer;				/* 10/100/1G MAC only */
+	ulong tx_xdefer;			/* 10/100/1G MAC only */
+	ulong tx_carrier_sense;		/* 10/100/1G MAC only */
+
+
+	ulong tx_size_64;
+	ulong tx_size_65_to_127;
+	ulong tx_size_128_to_255;
+	ulong tx_size_256_to_511;
+	ulong tx_size_512_to_1023;
+	ulong tx_size_1024_to_1518;
+	ulong tx_size_1519_to_max;
+
+
+	ulong tx_single_coll;		/* 10/100/1G MAC only */
+	ulong tx_backoff2;			/* 10/100/1G MAC only */
+	ulong tx_backoff3;			/* 10/100/1G MAC only */
+	ulong tx_backoff4;			/* 10/100/1G MAC only */
+	ulong tx_backoff5;			/* 10/100/1G MAC only */
+	ulong tx_backoff6;			/* 10/100/1G MAC only */
+	ulong tx_backoff7;			/* 10/100/1G MAC only */
+	ulong tx_backoff8;			/* 10/100/1G MAC only */
+	ulong tx_backoff9;			/* 10/100/1G MAC only */
+	ulong tx_backoff10;			/* 10/100/1G MAC only */
+	ulong tx_backoff11;			/* 10/100/1G MAC only */
+	ulong tx_backoff12;			/* 10/100/1G MAC only */
+	ulong tx_backoff13;			/* 10/100/1G MAC only */
+	ulong tx_backoff14;			/* 10/100/1G MAC only */
+	ulong tx_backoff15;			/* 10/100/1G MAC only */
+
+	ulong tx_underrun;
+
+	ulong ingress_overflow_drop;
+	ulong egress_overflow_drop;
+
+
+} vtss_port_counters_t;
+
+
+/*------------   TBD:  Error monitoring    ---------------------------------*/
+/* DIP4, sync errors, fifo ageing drop, etc.. */
+
+
+
+
+/* Clears counter for the logical port */
+vtss_rc vtss_port_counters_clear(const vtss_port_no_t port_no);
+
+/* */
+vtss_rc vtss_port_counters_get(const vtss_port_no_t port_no,
+							   vtss_port_counters_t * pcounters);
+
+
+/******************************************************************************/
+/***        MIIM(MDIO) Interface Functions           **************************/
+/******************************************************************************/
+
+#define VTSS_MIIM_READ_ATTEMPT    0xF000
+
+/* Direct miim read/write operation using miim_controller address as a 
+parameter */
+long vtss_miim_subblock_read(const uint miim_chnl, const uint phy_addr,
+							 const uint phy_reg);
+void vtss_miim_subblock_write(const uint miim_chnl, const uint phy_addr,
+							  const uint phy_reg, const ushort value);
+
+
+/* Indirect miim read/write operation. Accesses the PHY corresponding to the 
+   logical port number (PHY address is found via the mapping table)
+*/
+long vtss_miim_port_reg_read(const vtss_port_no_t port_no,
+							 const uint phy_reg);
+void vtss_miim_port_reg_write(const vtss_port_no_t port_no,
+							  const uint phy_reg, const ushort value);
+
+
+/******************************************************************************/
+/***        Policer/shaper                           **************************/
+/******************************************************************************/
+typedef ulong vtss_kbitrate_t;
+
+#define VTSS_DISABLE_SHAPER  ((vtss_kbitrate_t)-1)
+
+vtss_rc vtss_egress_shaper_set(vtss_port_no_t port_no, vtss_kbitrate_t br,
+							   ulong lb_lvl);
+vtss_rc vtss_ingress_shaper_set(vtss_port_no_t port_no, vtss_kbitrate_t br,
+								ulong lb_lvl);
+vtss_rc vtss_egress_common_shaper_set(vtss_kbitrate_t br, ulong lb_lvl);
+vtss_rc vtss_ingress_common_shaper_set(vtss_kbitrate_t br, ulong lb_lvl);
+
+vtss_rc vtss_egress_shaper_get(vtss_port_no_t port_no, vtss_kbitrate_t * pbr,
+							   ulong * lb_lvl);
+vtss_rc vtss_ingress_shaper_get(vtss_port_no_t port_no, vtss_kbitrate_t * pbr,
+								ulong * lb_lvl);
+vtss_rc vtss_egress_common_shaper_get(vtss_kbitrate_t * pbr, ulong * lb_lvl);
+vtss_rc vtss_ingress_common_shaper_get(vtss_kbitrate_t * pbr, ulong * lb_lvl);
+
+
+
+/******************************************************************************/
+/***        Aggregator Configuration                 **************************/
+/******************************************************************************/
+
+#define M2_AGGR_PMAP_TABLE_SIZE    256
+
+typedef struct _vtss_aggr_mode_t
+{
+	BOOL preamble_trunking;
+	BOOL mpls_trunking;
+	BOOL mpls_aggregation;
+	BOOL l2_aggr;
+	BOOL l3_aggr;
+	BOOL l4_aggr;
+	union
+	{
+		struct
+		{
+			ulong pos0;
+			ulong pos1;
+			ulong pos2;
+			ulong pos3;
+		} bit;
+		ulong mpls_bitmask;
+	} u;
+
+	BOOL norm_hdr_used;
+
+} vtss_aggr_mode_t;
+
+
+vtss_rc vtss_aggr_pmap_table_set(int index, int portnum);
+
+/* Reinitialises aggregation map table, if the port is mot mapped or disabled */
+/* it will be removed from the table, if the port has been enabled it will be */
+/* added to the table */
+vtss_rc vtss_aggr_pmap_table_initialise(void);
+
+
+/*--        Setup  Funtions                            -----------------------*/
+vtss_rc vtss_aggr_setup(vtss_aggr_mode_t * pam);
+
+/* Configures a user provided structure with values default for the selected 
+   major mode.
+*/
+vtss_rc vtss_aggr_setup_get_default_values(vtss_aggr_mode_t * pam,
+										   vtss_mac_major_mode_t mmode);
+
+
+/******************************************************************************/
+/***        PCS Autonegotiation (Serdes and TBI)     **************************/
+/******************************************************************************/
+
+vtss_rc vtss_pcs_autoneg_control_get(const vtss_port_no_t port_no,
+									 vtss_pcs_autoneg_control_t *
+									 const control);
+
+vtss_rc vtss_pcs_autoneg_control_set(const vtss_port_no_t port_no,
+									 const vtss_pcs_autoneg_control_t *
+									 const control);
+
+vtss_rc vtss_pcs_autoneg_restart(const vtss_port_no_t port_no);
+
+
+/* Current state of the PCS autonegotiation state machine */
+typedef enum _vtss_pcs_aneg_state_t
+{
+	VTSS_PCS_ANEG_STATE_IDLE,	/* Idle */
+	VTSS_PCS_ANEG_STATE_CONFIG,	/* Config (i.e. ANEG in progress) */
+	VTSS_PCS_ANEG_STATE_NOTVALID,	/*  */
+	VTSS_PCS_ANEG_STATE_DATA	/* Data */
+} vtss_pcs_aneg_state_t;
+
+typedef struct _vtss_pcs_autoneg_status_t
+{
+	vtss_pcs_aneg_state_t aneg_state;
+	BOOL aneg_complete;
+	vtss_autoneg_1000base_x_advertisement_t partner_advertisement;
+} vtss_pcs_autoneg_status_t;
+
+
+
+vtss_rc vtss_pcs_autoneg_status_get(const vtss_port_no_t port_no,
+									vtss_pcs_autoneg_status_t * paneg);
+
+
+typedef struct _vtss_pcs_status_t
+{
+
+	BOOL losync;				/* loss of sync: sticky self-cleared bit. PCS sync state 
+								   machine has lost sync at least once since last read 
+								   of the register */
+	BOOL pcs_in_sync;
+	BOOL signal_detected;		/* signal_detected indicates that there is light 
+								   in fiber; require SD_EN in the PCS_CTRL register 
+								   to be set */
+	BOOL jtp_lock;
+	BOOL jtp_error;
+
+	BOOL link_status_ok;		/* link_status:  FALSE if link has been down since 
+								   last status read */
+
+	uint link_down_counter;		/* link down counter: 8bit counter (only 6 bits 
+								   visible), saturates when reaching 256 */
+
+	BOOL show_ldc_top;			/* if TRUE indicates that the link down counter 
+								   is 8 bit long, not 6 bit as usually */
+
+	vtss_pcs_autoneg_status_t autoneg;
+
+} vtss_pcs_status_t;
+
+#define VTSS_PCS_LINK_DOWN_COUNTER_SATURATED 255
+
+/* Returns more detailed status than vtss_pcs_autoneg_status_get */
+vtss_rc vtss_pcs_status_get(const vtss_port_no_t port_no,
+							vtss_pcs_status_t * const status);
+
+
+
+/******************************************************************************/
+/***        Serdes Signal Detect Control             **************************/
+/******************************************************************************/
+vtss_rc vtss_serdes_signal_detect_setup(const vtss_port_no_t port_num,
+										BOOL enable,
+										BOOL sd_polarity_high,
+										BOOL sd_source_extern);
+
+
+/*
+  Reads serdes signal detect status.
+
+  Return values 
+    VTSS_OK                    successful completion
+
+    or an error:
+    VTSS_WRONG_MAJOR_MODE
+    VTSS_MAJOR_MODE_NOT_SET
+    VTSS_PORT_NOT_MAPPED
+
+  If VTSS_OK, then if the content of psignal_detected is 
+    TRUE    signal is detected
+    FALSE   no signal detected
+
+
+*/
+vtss_rc vtss_serdes_extern_signal_detect_status_get(const vtss_port_no_t
+													port_num,
+													BOOL * psignal_detected);
+
+
+
+
+/******************************************************************************
+ * Description: Set GPIO direction to input or output.
+ *
+ * \param chip_no (input): Chip number (for multi chip targets only).
+ * \param gpio_no (input): GPIO pin number.
+ * \param output (input) : TRUE if output, FALSE if input.
+ *
+ * \return : Return code.
+ ******************************************************************************/
+#if defined(VTSS_CHIPS)
+vtss_rc vtss_gpio_direction_set(const vtss_chip_no_t chip_no,
+								const vtss_gpio_no_t gpio_no,
+								const BOOL output);
+#else
+vtss_rc vtss_gpio_direction_set(const vtss_gpio_no_t gpio_no,
+								const BOOL output);
+#endif /* VTSS_CHIPS */
+
+
+/******************************************************************************
+ * Description: Read from GPIO input pin.
+ *
+ * \param chip_no (input): Chip number (for multi chip targets only).
+ * \param gpio_no (input): GPIO pin number.
+ *
+ * \return : TRUE if pin is high, FALSE if it is low.
+ ******************************************************************************/
+#if defined(VTSS_CHIPS)
+BOOL vtss_gpio_input_read(const vtss_chip_no_t chip_no,
+						  const vtss_gpio_no_t gpio_no);
+#else
+BOOL vtss_gpio_input_read(const vtss_gpio_no_t gpio_no);
+#endif /* VTSS_CHIPS */
+
+
+/******************************************************************************
+ * Description: Write to GPIO output pin.
+ *
+ * \param chip_no (input): Chip number (for multi chip targets only).
+ * \param gpio_no (input): GPIO pin number.
+ * \param value (input)  : TRUE to set pin high, FALSE to set pin low.
+ *
+ * \return : TRUE if pin is high, FALSE if it is low.
+ ******************************************************************************/
+#if defined(VTSS_CHIPS)
+/* Write to GPIO output pin */
+vtss_rc vtss_gpio_output_write(const vtss_chip_no_t chip_no,
+							   const vtss_gpio_no_t gpio_no,
+							   const BOOL value);
+#else
+vtss_rc vtss_gpio_output_write(const vtss_gpio_no_t gpio_no,
+							   const BOOL value);
+#endif /* VTSS_CHIPS */
+
+
+
+/******************************************************************************/
+/***        BIST test                                **************************/
+/******************************************************************************/
+
+#if defined MEIGS2 || defined VSC7321
+#define VTSS_BIST_NAME_SIZE 29
+#else
+#define VTSS_BIST_NAME_SIZE 33
+#endif
+
+
+/******************************************************************************
+ * Description: Start a specific bist test
+ *
+ * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
+ *
+ * \return : VTSS_OK if write was started,
+ *           VTSS_BIST_CMD_FAILED if last write was still in progress.
+ **************************************************************************kbp*/
+vtss_rc vtss_chip_bist_start(const uint bist_no);
+
+
+/******************************************************************************
+ * Description: Get result for a specific bist test
+ *
+ * \param bist_no (input): bist test number range <0..VTSS_BIST_NAME_SIZE-1>.
+ *                         >= VTSS_BIST_NAME_SIZE returns the write status.
+ *
+ * \return : VTSS_OK               when bist test went OK
+ *           VTSS_BIST_CMD_FAILED  when write accesses failed.
+ *           VTSS_BIST_TEST_FAILED when bist test failed.
+ **************************************************************************kbp*/
+vtss_rc vtss_chip_bist_result(const uint bist_no);
+
+
+/******************************************************************************/
+/***        GFP-T Configuration                      **************************/
+/******************************************************************************/
+
+/* Used to define the client signal type for GFP-T */
+#define C1_GFPT_CLIENT_GBE    0x0
+#define C1_GFPT_CLIENT_FC     0x1
+#define C1_GFPT_CLIENT_ESC    0x2
+#define C1_GFPT_CLIENT_DVB    0x3
+
+/* GFP-T Egress Frame Disassembler, Single bit Error Correction mode */
+typedef enum _vtss_gfpt_error_corr_t
+{
+	VTSS_GFPT_REPLACE_10B_ERR,
+	VTSS_GFPT_FORWARD_ERR,
+	VTSS_GFPT_DISCARD_ERR,
+	VTSS_GFPT_DISABLE_ERR
+} vtss_gfpt_error_corr_t;
+
+/* GFP-T port setup, which may change dynamically */
+typedef struct _vtss_gfpt_setup_t
+{
+	BOOL gfpt_en;
+	BOOL source_mode_en;
+	vtss_port_interface_mode_t interface_mode;
+	uint threshold_level;
+	uint rate_period;
+	uint rate_max_delta;
+	uint rate_min_idles;
+	uint rate_padding;
+	uint frame_length;
+	BOOL ingress_header_insert;
+	BOOL egress_header_expect;
+	vtss_gfpt_error_corr_t egress_err_corr;
+} vtss_gfpt_setup_t;
+
+
+/******************************************************************************
+ * Description: Setup for GFP-T handling in Campbell-I
+ *
+ * \param     : portnum
+ *              vtss_gfpt_setup_t* gs
+ *       
+ *
+ * \return    : VTSS_OK               
+ *              VTSS_PORT_NOT_MAPPED
+ *              VTSS_WRONG_PARAMETER
+ **************************************************************************kbp*/
+vtss_rc vtss_gfpt_setup(vtss_port_no_t portnum, vtss_gfpt_setup_t * gs);
+
+
+/******************************************************************************
+ * Description: Get default setting for GFP-T handling in Campbell-I
+ *
+ * \param     : vtss_gfpt_setup_t* gs
+ *              vtss_port_interface_mode_t  mode
+ *
+ * \return    : VTSS_OK               
+ *              VTSS_WRONG_PARAMETER
+ **************************************************************************kbp*/
+vtss_rc vtss_gfpt_setup_get_default_values(vtss_gfpt_setup_t * gs,
+										   vtss_port_interface_mode_t mode);
+
+
+/******************************************************************************/
+/***        Debug Section                            **************************/
+/******************************************************************************/
+
+
+BOOL vtss_port_mapped(const vtss_port_no_t port_no);
+BOOL vtss_phy_mapped(const vtss_port_no_t port_no);
+
+#endif /* _VITESSE_HIGHLEVEL_H */
diff --git a/drivers/net/rmi_spi4/vitesse_io.c b/drivers/net/rmi_spi4/vitesse_io.c
new file mode 100644
index 0000000..dccebf3
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_io.c
@@ -0,0 +1,200 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/*
+
+   vitesse_io.c  -- Vitesse hardware access layer.
+
+   This file provides the hardware access to target chip registers.
+   Modify it to fit your configuration.
+
+   Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
+   Unpublished rights reserved under the copyright laws of the United States of 
+   America, other countries and international treaties. The software is provided
+   without fee. Permission to use, copy, store, modify, disclose, transmit or 
+   distribute the software is granted, provided that this copyright notice must 
+   appear in any copy, modification, disclosure, transmission or distribution of 
+   the software. Vitesse Semiconductor Corporation retains all ownership, 
+   copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
+   HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
+   WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
+   PARTICULAR USE AND NON-INFRINGEMENT.
+
+   $Id: vitesse_io.c,v 1.1.2.4 2007/05/17 01:15:36 rpmbuilder Exp $
+
+ */
+
+#include "rmi_vits_wrapper.h"
+#include <asm/rmi/debug.h>
+
+#define __VTSS_LIBRARY__
+
+#define VTSS_TRACE_LAYER 1
+
+#include "vitesse_io.h"
+#include "meigsii_reg.h"
+
+
+#define VTSS_CHIP_ADDR_MMAP_SIZE (0x8000*sizeof(ulong))
+
+#ifdef VITGENIO
+#include <linux/vitgenio.h>
+#include <fcntl.h> /* open() */
+#include <sys/ioctl.h> /* ioctl() */
+#include <sys/mman.h> /* mmap() */
+#endif
+
+#ifdef CUSTOMERIO
+#endif
+
+#define VTSS_BLK_SYSTEM             M2_BLK_SYSTEM
+#define VTSS_SUBBLK_CTRL            M2_SUBBLK_CTRL
+#define VTSS_REG_SW_RESET           M2_SW_RESET
+#define VTSS_REG_CPU_TRANSFER_SEL   M2_SI_TRANSFER_SEL
+#define VTSS_REG_LOCAL_DATA         M2_LOCAL_DATA
+#define VTSS_REG_LOCAL_STATUS       M2_LOCAL_STATUS
+
+#define VTSS_T_RESET 2000000L
+
+/* ================================================================= *
+ *  I/O Layer Helper functions
+ * ================================================================= */
+
+
+/* Note: This must be called before any access to the target chip.
+ *       vtss_reset_io_layer() calls this directly.
+ */
+void vtss_io_reset( void )
+{
+
+#ifdef VITGENIO
+	/* Setup the hardware access (open device driver and setup MMU). */
+	if (vtss_io_state->chip_addr == NULL) {
+		vtss_io_state->fd_driver = open( "/dev/vitgenio", 0 );
+
+#ifdef NO_MMAP
+		printk ("VTSS:io_reset no_mmap\n");
+
+		vtss_io_state->chip_addr = (void*)4; /* Any non-NULL value to indicate that the driver is ready. */
+#else
+		vtss_io_state->chip_addr = mmap( 0, VTSS_CHIP_ADDR_MMAP_SIZE, 
+						PROT_READ | PROT_WRITE, 
+						MAP_SHARED, 
+						vtss_io_state->fd_driver, 
+						0 );
+#endif
+	}
+
+	/* Call the I/O Layer driver callback, if present. */
+	if (vtss_io_state->io_driver_callback) vtss_io_state->io_driver_callback();
+#endif
+
+
+#ifdef CUSTOMERIO
+	/* Setup the hardware access (open device driver and setup MMU). */
+	/* Call the I/O Layer driver callback, if present. */
+	vtss_io_state->chip_addr = (void*)4;
+	if (vtss_io_state->io_driver_callback) vtss_io_state->io_driver_callback();
+#endif
+	/* Reset and configure the chip. */
+	/* vtss_io_reset_chip(); */
+}
+
+
+
+
+/* ================================================================= *
+ *  Chip register access methods
+ * ================================================================= */
+
+static ulong vtss_io_pi_read(const uint block, const uint subblock, const uint reg)
+{
+	/* Use 32 bit access, letting the CPU split it up to two 16 bit bus accesses */
+	VTSS_NSLEEP( 240 ); /* Refer to the data sheet for timing diagrams. */
+	if ((block==VTSS_BLK_SYSTEM)
+		&&
+	(subblock==VTSS_SUBBLK_CTRL)
+		&&
+	((reg==VTSS_REG_LOCAL_DATA)||(reg==VTSS_REG_LOCAL_STATUS))) {
+		return (ulong)megis_read(block, subblock, reg);
+	} else {
+		/* Perform a dummy read to activate read request. */
+		megis_read(block, subblock, reg) ;
+		/* Wait for data ready. */
+		VTSS_NSLEEP( 1000 ); /* Refer to the data sheet for timing diagrams. */
+		return (ulong)megis_read(VTSS_BLK_SYSTEM, 
+					VTSS_SUBBLK_CTRL, 
+					VTSS_REG_LOCAL_DATA);
+	}
+}
+
+static void vtss_io_pi_write(const uint block, const uint subblock, const uint reg, const ulong value)
+{
+	/* Use 32 bit access, letting the CPU 
+	split it up to two 16 bit bus accesses */
+	VTSS_NSLEEP( 120 ); /* Refer to the data sheet for timing diagrams. */
+	megis_write(block, subblock, reg, value);
+}
+
+
+ulong vtss_io_read(uint block, uint subblock, const uint reg)
+{
+	ulong value;
+
+	value = vtss_io_pi_read(block, subblock, reg);
+
+	VTSS_N(("R 0x%01X 0x%01X 0x%02X 0x%08lX",block,subblock,reg,value));
+
+	return value;
+}
+
+void vtss_io_write(uint block, uint subblock, const uint reg, const ulong value)
+{
+	VTSS_N(("W 0x%01X 0x%01X 0x%02X 0x%08lX",block,subblock,reg,value));
+
+	vtss_io_pi_write(block, subblock, reg, value);
+}
+
+void vtss_io_writemasked(uint block, uint subblock, 
+			const uint reg, const ulong value, 
+			const ulong mask)
+{
+	VTSS_N(("M 0x%01X 0x%01X 0x%02X 0x%08lX 0x%08lX",
+		block,subblock,reg,value,mask));
+
+	vtss_io_write(block,subblock,reg, 
+			(vtss_io_read(block,subblock,reg) & ~mask) | 
+			(value & mask) );
+}
+
+
+/* ================================================================= *
+ *  I/O Layer state information
+ * ================================================================= */
+
+static vtss_io_state_t default_io_state =
+{
+
+	/* The following members must be present: */
+	/* This optional callback function will be called after 
+		the vtss_io_init function has completed. */
+	NULL,       /*void                (*io_driver_callback) (void);*/
+
+	/* The following members are implementation specific: */
+	0,          /*int                 fd_driver;*/
+	NULL        /*ulong *             chip_addr;*/
+
+};
+
+/* Pointer to current state. */
+vtss_io_state_t * vtss_io_state = &default_io_state;
+
diff --git a/drivers/net/rmi_spi4/vitesse_io.h b/drivers/net/rmi_spi4/vitesse_io.h
new file mode 100644
index 0000000..924d0a2
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_io.h
@@ -0,0 +1,78 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/*
+
+ vitesse_io.h  -- Vitesse hardware access layer.
+ This file provides the hardware access to target chip registers.
+ Modify it to fit your configuration.
+
+ Copyright (c) 2003 Vitesse Semiconductor Corporation. All Rights Reserved.
+ Unpublished rights reserved under the copyright laws of the United States of 
+ America, other countries and international treaties. The software is provided
+ without fee. Permission to use, copy, store, modify, disclose, transmit or 
+ distribute the software is granted, provided that this copyright notice must 
+ appear in any copy, modification, disclosure, transmission or distribution of 
+ the software. Vitesse Semiconductor Corporation retains all ownership, 
+ copyright, trade secret and proprietary rights in the software. THIS SOFTWARE
+ HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED WARRANTY INCLUDING, 
+ WITHOUT LIMITATION, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
+ PARTICULAR USE AND NON-INFRINGEMENT.
+ 
+*/
+
+#ifndef _VITESSE_IO_H
+#define _VITESSE_IO_H
+
+#include "vitesse_common.h"
+
+/* ================================================================= *
+ *  I/O Layer initialisation and
+ *  Chip hardware access configuration (pin polarity etc.)
+ * ================================================================= */
+
+/* 
+ * Note: This must be called before any access to the target chip.
+ *       vtss_reset_io_layer() calls this directly.
+*/
+void vtss_io_reset( void );
+
+/* ================================================================= *
+ *  Chip register access
+ * ================================================================= */
+
+ulong vtss_io_read(uint block, uint subblock, const uint reg);
+void vtss_io_write(uint block, uint subblock, const uint reg, const ulong value);
+void vtss_io_writemasked(uint block, uint subblock, const uint reg, const ulong value, const ulong mask);
+
+
+/* ================================================================= *
+ *  I/O Layer state information
+ * ================================================================= */
+
+typedef struct _vtss_io_state_t {
+/* 
+ * This optional callback function will be called after the chip hardware access driver has been opened,
+ * but before the chip has been reset and configured for hardware access (pin polarity etc.).
+ * It can be used for passing extra parameters to the chip hardware access driver.
+ */
+	void (*io_driver_callback) (void);
+
+/* The following members are implementation specific: */
+	int                 fd_driver; /* File descriptor to VitGenIO Linux driver */
+	ulong *             chip_addr; /* mmap'ed address of chip */
+} vtss_io_state_t;
+
+/* Pointer to I/O layer current state information. */
+extern vtss_io_state_t * vtss_io_state;
+
+#endif /* _VITESSE_IO_H */
diff --git a/drivers/net/rmi_spi4/vitesse_phy_ctrl.c b/drivers/net/rmi_spi4/vitesse_phy_ctrl.c
new file mode 100644
index 0000000..15d9b88
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_phy_ctrl.c
@@ -0,0 +1,435 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/************************************************************-*- mode: C -*-*/
+/*                                                                          */
+/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
+/*                           All Rights Reserved.                           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                            Copyright Notice:                             */
+/*                                                                          */
+/*  Unpublished rights reserved under the copyright laws of the United      */
+/*  States of America, other countries and international treaties.          */
+/*                                                                          */
+/*      The software is provided without fee.                               */
+/*                                                                          */
+/*  Permission to use,  copy, store, modify, disclose, transmit or          */
+/*  distribute the software is granted, provided that this copyright notice */
+/*  must appear in any copy, modification, disclosure, transmission or      */
+/*  distribution of the software.                                           */
+/*                                                                          */
+/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
+/*  trade secret and proprietary rights in the software.                    */
+/*                                                                          */
+/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
+/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
+/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
+/*                                                                          */
+/*    $Id: vitesse_phy_ctrl.c,v 1.1.2.3 2006/09/28 01:24:16 nphilips Exp $           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*  File content:                                                           */
+/*                                                                          */
+/*  vitesse_phy_ctrl.c -- C-library for controlling PHY devices             */
+/*                        Copied/compiled from Heathrow PHY ctrl functions  */
+/*                                                                          */
+/****************************************************************************/
+#include "vitesse_highlevel.h"
+#include "meigsii_reg.h"
+#include "vitesse_io.h"
+#include "vitesse_phy_ctrl.h"
+#include <asm/rmi/debug.h>
+
+
+/* ================================================================= *
+ *  PHY
+ * ================================================================= */
+
+/* - Read/Write PHY registers via MII-Management ------------------- */
+/* returns >=0: (ushort)result or <0: (long)error */
+long vtss_phy_read(             const vtss_port_no_t    port_no,
+		const uint              phy_reg )
+{
+	long rc;
+
+	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
+	rc = vtss_miim_port_reg_read( port_no, phy_reg );
+	if (rc<0) return VTSS_PHY_READ_ERROR;
+	return rc;
+}
+
+vtss_rc vtss_phy_write(         const vtss_port_no_t    port_no,
+		const uint              phy_reg,
+		const ushort            value )
+{
+	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
+	vtss_miim_port_reg_write( port_no, phy_reg, value );
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_writemasked(   const vtss_port_no_t    port_no,
+		const uint              phy_reg,
+		const ushort            value,
+		const ushort            mask )
+{
+	long rc;
+
+	if (!vtss_phy_mapped(port_no)) return VTSS_PHY_NOT_MAPPED;
+	rc = vtss_miim_port_reg_read( port_no, phy_reg );
+	if (rc<0) return VTSS_PHY_READ_ERROR;
+	rc = (rc & (0xFFFF^mask)) | (value & mask);
+	vtss_miim_port_reg_write( port_no, phy_reg, rc );
+	return VTSS_OK;
+}
+
+/* - PHY Registers, see IEEE 802.3 clause 22.2.4 ------------------- */
+
+vtss_rc vtss_phy_reset( const vtss_port_no_t port_no )
+{
+	vtss_rc rc;
+	vtss_phy_control_t  control;
+
+	control.reset = 1;
+	if ((rc=vtss_phy_control_set( port_no, &control ))<0) return rc;
+	do {
+		uint read_attempt=0;
+		do {
+			rc = vtss_phy_control_get( port_no, &control );
+		} while ((rc==VTSS_PHY_READ_ERROR) 
+				&& 
+			(read_attempt++<VTSS_PHY_RESET_READ_MAXRETRIES));
+		if (rc<0) return rc;
+	} while (control.reset);
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_control_get(   const vtss_port_no_t                port_no,
+		vtss_phy_control_t * const          control )
+{
+	long reg0;
+
+	if ((reg0 = vtss_phy_read( port_no, 0 ))<0) return (vtss_rc)reg0;
+	control->reset          = MAKEBOOL01(reg0 & (1<<15));
+	control->loopback       = MAKEBOOL01(reg0 & (1<<14));
+	switch ( reg0 & ((1<<6)|(1<<13)) ) {
+	case (1<<6)|(1<<13): control->speed = VTSS_SPEED_UNDEFINED; 
+		break;
+	case (1<<6)|(0<<13): control->speed = VTSS_SPEED_1G; 
+		break;
+	case (0<<6)|(1<<13): control->speed = VTSS_SPEED_100M; 
+		break;
+	case (0<<6)|(0<<13): control->speed = VTSS_SPEED_10M; 
+		break;
+	}
+	control->autoneg_enable = MAKEBOOL01(reg0 & (1<<12));
+	control->powerdown      = MAKEBOOL01(reg0 & (1<<11));
+	control->isolate        = MAKEBOOL01(reg0 & (1<<10));
+	control->autoneg_restart = MAKEBOOL01(reg0 & (1<< 9));
+	control->fdx            = MAKEBOOL01(reg0 & (1<< 8));
+	control->collision_test = MAKEBOOL01(reg0 & (1<< 7));
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_control_set(   const vtss_port_no_t                port_no,
+				const vtss_phy_control_t * const    control )
+{
+	vtss_rc rc;
+	ushort reg0 = 0;
+
+	reg0 |= control->reset          ? (1<<15) : 0;
+	reg0 |= control->loopback       ? (1<<14) : 0;
+	switch (control->speed) {
+	case VTSS_SPEED_UNDEFINED:  
+		reg0 |= (1<<6)|(1<<13); 
+		break;
+	case VTSS_SPEED_1G:         
+		reg0 |= (1<<6)|(0<<13); 
+		break;
+	case VTSS_SPEED_100M:       
+		reg0 |= (0<<6)|(1<<13); 
+		break;
+	case VTSS_SPEED_10M:        
+		reg0 |= (0<<6)|(0<<13); 
+		break;
+	default:  
+		reg0 |= (1<<6)|(1<<13); 
+		break;
+	}
+	reg0 |= control->autoneg_enable ? (1<<12) : 0;
+	reg0 |= control->powerdown      ? (1<<11) : 0;
+	reg0 |= control->isolate        ? (1<<10) : 0;
+	reg0 |= (control->autoneg_enable && control->autoneg_restart) ? (1<< 9) : 0;
+	reg0 |= control->fdx            ? (1<< 8) : 0;
+	reg0 |= control->collision_test ? (1<< 7) : 0;
+
+	rc=vtss_phy_write( port_no, 0, reg0 );
+#if VTSS_PHY_RESET_PAUSE
+	if (control->reset) {
+		/* Wait after issuing a soft reset to the PHY. */
+		VTSS_NSLEEP(VTSS_PHY_RESET_PAUSE);
+	}
+#endif
+	return rc;
+}
+
+vtss_rc vtss_phy_status_get(    const vtss_port_no_t        port_no,
+		vtss_phy_status_t * const   status )
+{
+	const long reg1 = vtss_phy_read( port_no, 1 );
+	if (reg1<0) return (vtss_rc)reg1;
+	status->ability_100base_t4              = MAKEBOOL01(reg1 & (1<<15));
+	status->ability_100base_x_fdx           = MAKEBOOL01(reg1 & (1<<14));
+	status->ability_100base_x_hdx           = MAKEBOOL01(reg1 & (1<<13));
+	status->ability_10mbps_fdx              = MAKEBOOL01(reg1 & (1<<12));
+	status->ability_10mbps_hdx              = MAKEBOOL01(reg1 & (1<<11));
+	status->ability_100base_t2_fdx          = MAKEBOOL01(reg1 & (1<<10));
+	status->ability_100base_t2_hdx          = MAKEBOOL01(reg1 & (1<< 9));
+	status->accepts_mf_preamble_suppression = MAKEBOOL01(reg1 & (1<< 6));
+	status->autoneg_complete                = MAKEBOOL01(reg1 & (1<< 5));
+	status->remote_fault                    = MAKEBOOL01(reg1 & (1<< 4));
+	status->ability_autoneg                 = MAKEBOOL01(reg1 & (1<< 3));
+	status->link_status                     = MAKEBOOL01(reg1 & (1<< 2));
+	status->jabber_detected                 = MAKEBOOL01(reg1 & (1<< 1));
+	status->extended_capability             = MAKEBOOL01(reg1 & (1<< 0));
+	status->extended_status                 = MAKEBOOL01(reg1 & (1<< 8));
+	if (status->extended_status) {
+		const long reg15 = vtss_phy_read( port_no, 15 );
+		if (reg15<0) return (vtss_rc)reg15;
+		status->extended.ability_1000base_x_fdx = 
+					MAKEBOOL01(reg15 & (1<<15));
+		status->extended.ability_1000base_x_hdx = 
+					MAKEBOOL01(reg15 & (1<<14));
+		status->extended.ability_1000base_t_fdx = 
+					MAKEBOOL01(reg15 & (1<<13));
+		status->extended.ability_1000base_t_hdx = 
+					MAKEBOOL01(reg15 & (1<<12));
+	} else {
+		status->extended.ability_1000base_x_fdx = 0;
+		status->extended.ability_1000base_x_hdx = 0;
+		status->extended.ability_1000base_t_fdx = 0;
+		status->extended.ability_1000base_t_hdx = 0;
+	}
+	return VTSS_OK;
+}
+
+/* Note: This function can be used to see if a PHY is present by calling it with id=NULL. */
+vtss_rc vtss_phy_id_get(const vtss_port_no_t    port_no,
+			vtss_phy_id_t * const   id )
+{
+	long reg2, reg3;
+
+	if ((reg2 = vtss_phy_read( port_no, 2 ))<0) 
+		return (vtss_rc)reg2;
+	if ((reg3 = vtss_phy_read( port_no, 3 ))<0) 
+		return (vtss_rc)reg3;
+	if (id) {
+		/* 16 bits from reg2 and 6 bits from reg3 */
+		id->manufacturer = (reg2 <<6) | ((reg3 >> 10) & 0x3F); 
+		id->model        = (reg3 >> 4) & 0x3F; /* 6 bits */
+		id->revision     = reg3 & 0xF;         /* 4 bits */
+	}
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_autoneg_advertisement_get( const 	uint   	port_no,
+		vtss_phy_autoneg_advertisement_t * const        advertisement )
+{
+	long reg4;
+
+	if ((reg4 = vtss_phy_read( port_no, 4 ))<0) return (vtss_rc)reg4;
+	advertisement->ability_100base_t4   = MAKEBOOL01(reg4 & (1<< 9));
+	advertisement->ability_100base_x_fdx= MAKEBOOL01(reg4 & (1<< 8));
+	advertisement->ability_100base_x_hdx= MAKEBOOL01(reg4 & (1<< 7));
+	advertisement->ability_10base_t_fdx = MAKEBOOL01(reg4 & (1<< 6));
+	advertisement->ability_10base_t_hdx = MAKEBOOL01(reg4 & (1<< 5));
+	advertisement->symmetric_pause      = MAKEBOOL01(reg4 & (1<<10));
+	advertisement->asymmetric_pause     = MAKEBOOL01(reg4 & (1<<11));
+	advertisement->remote_fault         = MAKEBOOL01(reg4 & (1<<13));
+	advertisement->acknowledge          = 0;    /* Unused in Register 4 */
+	advertisement->next_page_present    = MAKEBOOL01(reg4 & (1<<15));
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_autoneg_advertisement_set( const uint   port_no,
+		const vtss_phy_autoneg_advertisement_t * const  advertisement )
+{
+	ushort reg4 = 0;
+
+	reg4 |= advertisement->ability_100base_t4   ? (1<< 9) : 0;
+	reg4 |= advertisement->ability_100base_x_fdx? (1<< 8) : 0;
+	reg4 |= advertisement->ability_100base_x_hdx? (1<< 7) : 0;
+	reg4 |= advertisement->ability_10base_t_fdx ? (1<< 6) : 0;
+	reg4 |= advertisement->ability_10base_t_hdx ? (1<< 5) : 0;
+	reg4 |= advertisement->symmetric_pause      ? (1<<10) : 0;
+	reg4 |= advertisement->asymmetric_pause     ? (1<<11) : 0;
+	reg4 |= advertisement->remote_fault         ? (1<<13) : 0;
+	/* advertisement->acknowledge is unused in Register 4 */
+	reg4 |= advertisement->next_page_present    ? (1<<15) : 0;
+
+	/* Selector field must be set to 1 for IEEE802.3 twisted pair. 
+	(Refer to IEEE 802.3 Clause 28.2.1.2.1 and Annex 28A) */
+	reg4 |= ((1 & 0x1F)<<0);
+
+	return vtss_phy_write( port_no, 4, reg4 );
+}
+
+vtss_rc vtss_phy_autoneg_linkpartner_ability_get(   const uint    port_no,
+		vtss_phy_autoneg_advertisement_t * const    linkpartner_advertisement )
+{
+	long reg5;
+
+	if ((reg5 = vtss_phy_read( port_no, 5 ))<0) return (vtss_rc)reg5;
+	linkpartner_advertisement->ability_100base_t4   = 
+					MAKEBOOL01(reg5 & (1<< 9));
+	linkpartner_advertisement->ability_100base_x_fdx= 
+					MAKEBOOL01(reg5 & (1<< 8));
+	linkpartner_advertisement->ability_100base_x_hdx= 
+					MAKEBOOL01(reg5 & (1<< 7));
+	linkpartner_advertisement->ability_10base_t_fdx = 
+					MAKEBOOL01(reg5 & (1<< 6));
+	linkpartner_advertisement->ability_10base_t_hdx = 
+					MAKEBOOL01(reg5 & (1<< 5));
+	linkpartner_advertisement->symmetric_pause      = 
+					MAKEBOOL01(reg5 & (1<<10));
+	linkpartner_advertisement->asymmetric_pause     = 
+					MAKEBOOL01(reg5 & (1<<11));
+	linkpartner_advertisement->remote_fault         = 
+					MAKEBOOL01(reg5 & (1<<13));
+	linkpartner_advertisement->acknowledge          = 
+					MAKEBOOL01(reg5 & (1<<14));
+	linkpartner_advertisement->next_page_present    = 
+					MAKEBOOL01(reg5 & (1<<15));
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_masterslave_control_get(   const vtss_port_no_t    port_no,
+		vtss_phy_masterslave_control_t * const  masterslave_control )
+{
+	long reg9;
+
+	if ((reg9 = vtss_phy_read( port_no, 9 ))<0) 
+		return (vtss_rc)reg9;
+	masterslave_control->test_mode              = 
+					(reg9 & (7<<13)) >> 13;
+	masterslave_control->masterslave_force      = 
+					MAKEBOOL01(reg9 & (1<<12));
+	masterslave_control->masterslave_master     = 
+					MAKEBOOL01(reg9 & (1<<11));
+	masterslave_control->port_type              = 
+					MAKEBOOL01(reg9 & (1<<10));
+	masterslave_control->ability_1000base_t_fdx = 
+					MAKEBOOL01(reg9 & (1<< 9));
+	masterslave_control->ability_1000base_t_fdx = 
+					MAKEBOOL01(reg9 & (1<< 8));
+	return VTSS_OK;
+}
+
+vtss_rc vtss_phy_masterslave_control_set(   const vtss_port_no_t  port_no,
+	const vtss_phy_masterslave_control_t * const  masterslave_control )
+{
+	ushort reg9 = 0;
+
+	reg9 |= (masterslave_control->test_mode & 7)            <<13;
+	reg9 |= masterslave_control->masterslave_force      ? (1<<12) : 0;
+	reg9 |= masterslave_control->masterslave_master     ? (1<<11) : 0;
+	reg9 |= masterslave_control->port_type              ? (1<<10) : 0;
+	reg9 |= masterslave_control->ability_1000base_t_fdx ? (1<< 9) : 0;
+	reg9 |= masterslave_control->ability_1000base_t_fdx ? (1<< 8) : 0;
+
+	return vtss_phy_write( port_no, 9, reg9 );
+}
+
+vtss_rc vtss_phy_masterslave_status_get(    const vtss_port_no_t     port_no,
+	vtss_phy_masterslave_status_t * const   masterslave_status )
+{
+	long reg10;
+
+	if ((reg10 = vtss_phy_read( port_no, 10 ))<0) return (vtss_rc)reg10;
+	masterslave_status->fault                               = 
+					MAKEBOOL01(reg10 & (1<<15));
+	masterslave_status->master                              = 
+					MAKEBOOL01(reg10 & (1<<14));
+	masterslave_status->local_receiver_status_ok            = 
+					MAKEBOOL01(reg10 & (1<<13));
+	masterslave_status->remote_receiver_status_ok           = 
+					MAKEBOOL01(reg10 & (1<<12));
+	masterslave_status->linkpartner_ability_1000base_t_fdx  = 
+					MAKEBOOL01(reg10 & (1<<11));
+	masterslave_status->linkpartner_ability_1000base_t_hdx  = 
+					MAKEBOOL01(reg10 & (1<<10));
+	masterslave_status->idle_error_count                    = 
+							reg10 & 0xFF;
+	return VTSS_OK;
+}
+
+/* - PHY Auto-Negotiation and Forced Speed ------------------------- */
+
+/* Note: Some PHYs (DP83865) requires a reset to run with forced speed. This function does not reset the PHY. */
+vtss_rc vtss_phy_force_speed(   const vtss_port_no_t    port_no,
+		const vtss_speed_t      speed,
+		const BOOL              fdx /* Full duplex: TRUE, Half duplex: FALSE */ )
+{
+	vtss_rc rc;
+	vtss_phy_status_t   status;
+	vtss_phy_control_t  control;
+
+	/* Verify PHY ability. */
+	if ((rc=vtss_phy_status_get( port_no, &status ))<0) 
+		return rc;
+	switch (speed) {
+	case VTSS_SPEED_10M:
+		if (fdx) {
+			if (status.ability_10mbps_fdx) break;
+		} else {
+			if (status.ability_10mbps_hdx) break;
+		}
+		return VTSS_PHY_ABILITY;
+	case VTSS_SPEED_100M:
+		if (fdx) {
+			if (status.ability_100base_x_fdx) break;
+			if (status.ability_100base_t2_fdx) break;
+		} else {
+			/* Note: 100Base-T4 is always half duplex. */
+			if (status.ability_100base_t4) break;
+			if (status.ability_100base_x_hdx) break;
+			if (status.ability_100base_t2_hdx) break;
+		}
+		return VTSS_PHY_ABILITY;
+	case VTSS_SPEED_1G:
+		if (!status.extended_status) return VTSS_PHY_ABILITY;
+		if (fdx) {
+			if (status.extended.ability_1000base_x_fdx) break;
+			if (status.extended.ability_1000base_t_fdx) break;
+		} else {
+			if (status.extended.ability_1000base_x_hdx) break;
+			if (status.extended.ability_1000base_t_hdx) break;
+		}
+		return VTSS_PHY_ABILITY;
+	default:
+		return VTSS_PHY_ABILITY;
+	}
+
+	/* Set PHY mode. */
+	control.reset           = 0;
+	control.loopback        = 0;
+	control.speed           = speed;
+	control.autoneg_enable  = 0;
+	control.powerdown       = 0;
+	control.isolate         = 0;
+	control.autoneg_restart = 0;
+	control.fdx             = fdx;
+	control.collision_test  = 0;
+	return vtss_phy_control_set( port_no, &control );
+}
diff --git a/drivers/net/rmi_spi4/vitesse_phy_ctrl.h b/drivers/net/rmi_spi4/vitesse_phy_ctrl.h
new file mode 100644
index 0000000..6ed9971
--- /dev/null
+++ b/drivers/net/rmi_spi4/vitesse_phy_ctrl.h
@@ -0,0 +1,299 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
+/************************************************************-*- mode: C -*-*/
+/*                                                                          */
+/*           Copyright (C) 2003 Vitesse Semiconductor Corporation           */
+/*                           All Rights Reserved.                           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*                            Copyright Notice:                             */
+/*                                                                          */
+/*  Unpublished rights reserved under the copyright laws of the United      */
+/*  States of America, other countries and international treaties.          */
+/*                                                                          */
+/*      The software is provided without fee.                               */
+/*                                                                          */
+/*  Permission to use,  copy, store, modify, disclose, transmit or          */
+/*  distribute the software is granted, provided that this copyright notice */
+/*  must appear in any copy, modification, disclosure, transmission or      */
+/*  distribution of the software.                                           */
+/*                                                                          */
+/*  Vitesse Semiconductor Corporation retains all ownership, copyright,     */
+/*  trade secret and proprietary rights in the software.                    */
+/*                                                                          */
+/*  THIS SOFTWARE HAS BEEN PROVIDED "AS IS," WITHOUT EXPRESS OR IMPLIED     */
+/*  WARRANTY INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF           */
+/*  MERCHANTABILITY, FITNESS FOR A PARTICULAR USE AND NON-INFRINGEMENT.     */
+/*                                                                          */
+/*    $Id: vitesse_phy_ctrl.h,v 1.1.2.3 2006/09/28 01:24:16 nphilips Exp $           */
+/*                                                                          */
+/****************************************************************************/
+/*                                                                          */
+/*  File content:                                                           */
+/*                                                                          */
+/*  vitesse_phy_ctrl.h -- C-library for controlling PHY devices             */
+/*                                                                          */
+/*                                                                          */
+/****************************************************************************/
+
+#ifndef _VITESSE_PHY_CRTL_H
+#define _VITESSE_PHY_CTRL_H
+
+/* ================================================================= *
+ *  PHY
+ * ================================================================= */
+
+/* - Read/Write PHY registers via MII-Management ------------------- */
+
+/* returns >=0: (ushort)result or <0: (long)error */
+long vtss_phy_read(const vtss_port_no_t port_no,
+                   const uint phy_reg );
+
+vtss_rc vtss_phy_write(const vtss_port_no_t port_no,
+                       const uint phy_reg,
+                       const ushort value );
+
+vtss_rc vtss_phy_writemasked(const vtss_port_no_t port_no,
+                             const uint phy_reg,
+                             const ushort value,
+                             const ushort mask );
+
+/* - PHY Registers, see IEEE 802.3 clause 22.2.4 ------------------- */
+
+/*
+ * Some PHYs do not respond to MII-M READ during Reset, although they
+ * must (according to IEEE 802.3 clause 22.2.4.1.1), so we try reading
+ * a number of times before we give up when there is no read response
+ * from the PHY during reset. Set to 0 to disable retrying.
+*/
+#define VTSS_PHY_RESET_READ_MAXRETRIES 15625
+
+/*
+ * Some PHYs require silence on the MII-M bus a short period after
+ * soft reset, so we pause this many nanoseconds.
+ * Set to 0 to disable. 
+*/
+#define VTSS_PHY_RESET_PAUSE 1000
+
+vtss_rc vtss_phy_reset(const vtss_port_no_t port_no);
+
+/* PHY Basic Capability registers */
+
+/* PHY Control Register (Register 0) */
+typedef struct _vtss_phy_control_t {
+    BOOL reset;              /* Self Clearing */
+    BOOL loopback;
+    vtss_speed_t speed;
+    BOOL autoneg_enable;
+    BOOL powerdown;
+    BOOL isolate;
+    BOOL autoneg_restart;    /* Self Clearing */
+    BOOL fdx;                /* Full duplex: TRUE, Half duplex: FALSE */
+    BOOL collision_test;
+} vtss_phy_control_t;
+
+vtss_rc vtss_phy_control_get(const vtss_port_no_t port_no,
+                             vtss_phy_control_t * const control);
+
+vtss_rc vtss_phy_control_set(const vtss_port_no_t port_no,
+                             const vtss_phy_control_t * const control);
+
+/* PHY Status Registers (Registers 1 and 15) */
+/* 
+ * Note: The link_status entry is "shared" between vtss_port_status and 
+ * hvtss_phy_status_get functions. 
+*/
+typedef struct _vtss_phy_status_t {
+    BOOL ability_100base_t4; /* Note: 100Base-T4 is always hdx. */
+    BOOL ability_100base_x_fdx; /* Covers 100Base-TX or 100Base-FX */
+    BOOL ability_100base_x_hdx; /* Covers 100Base-TX or 100Base-FX */
+    BOOL ability_10mbps_fdx;
+    BOOL ability_10mbps_hdx;
+    BOOL ability_100base_t2_fdx;
+    BOOL ability_100base_t2_hdx;
+    BOOL accepts_mf_preamble_suppression;
+    BOOL autoneg_complete;
+    BOOL remote_fault;
+    BOOL ability_autoneg;
+    BOOL link_status;
+    BOOL jabber_detected;
+    BOOL extended_capability;    /* PHY supports Registers 2-14 and 16-31 */
+    BOOL extended_status;
+    struct {
+		BOOL ability_1000base_x_fdx;
+		BOOL ability_1000base_x_hdx;
+		BOOL ability_1000base_t_fdx;
+		BOOL ability_1000base_t_hdx;
+    } extended;    /* Only available when extended_status==TRUE. */
+} vtss_phy_status_t;
+
+vtss_rc vtss_phy_status_get(const vtss_port_no_t port_no,
+                             vtss_phy_status_t * const status);
+
+/* PHY Extended Capability registers */
+
+/* PHY Identifier (Registers 2 and 3) */
+typedef struct _vtss_phy_id_t {
+    uint manufacturer;   /* 22 bits (bits 3-24 of the manufacturer's OUI) */
+    uint model;          /* 6 bits */
+    uint revision;       /* 4 bits */
+} vtss_phy_id_t;
+
+/* Note: This function can be used to see if a PHY is present by calling it with id=NULL. */
+vtss_rc vtss_phy_id_get(const vtss_port_no_t port_no,
+                         vtss_phy_id_t * const id);
+
+/* PHY Auto-Negotiation Advertisement (Register 4) and Link Partner Ability (Register 5) */
+typedef struct _vtss_phy_autoneg_advertisement_t {
+    BOOL ability_100base_t4; /* Note: 100Base-T4 is always half duplex. */
+    BOOL ability_100base_x_fdx; /* Covers 100Base-TX or 100Base-FX */
+    BOOL ability_100base_x_hdx; /* Covers 100Base-TX or 100Base-FX */
+    BOOL ability_10base_t_fdx;
+    BOOL ability_10base_t_hdx;
+    BOOL symmetric_pause;    /* a.k.a. PAUSE (PS1) */
+    BOOL asymmetric_pause;   /* a.k.a. ASM_DIR (PS2) */
+    BOOL remote_fault;
+    BOOL acknowledge;    /* Unused in Register 4 */
+    BOOL next_page_present;
+} vtss_phy_autoneg_advertisement_t;
+
+/* PHY Auto-Negotiation Advertisement (Register 4) */
+vtss_rc vtss_phy_autoneg_advertisement_get(const uint port_no,
+		vtss_phy_autoneg_advertisement_t * const advertisement);
+
+/* PHY Auto-Negotiation Advertisement (Register 4) */
+vtss_rc vtss_phy_autoneg_advertisement_set(const uint port_no,
+		const vtss_phy_autoneg_advertisement_t * const advertisement);
+
+/* PHY Auto-Negotiation Link Partner Ability (Register 5) */
+vtss_rc vtss_phy_autoneg_linkpartner_ability_get(const uint port_no,
+		vtss_phy_autoneg_advertisement_t * const linkpartner_advertisement);
+
+/* PHY Master-Slave Control Register (Register 9), 1000Base-T only. 
+Set this before PHY Control Register */
+typedef struct _vtss_phy_masterslave_control_t {
+    uint test_mode;          /* (3 bits wide), 0: Normal operation */
+    BOOL masterslave_force;  /* Manually set Master/Slave mode */
+    BOOL masterslave_master; /* Only used when masterslave_force==TRUE */
+    BOOL port_type;          /* TRUE: multi-port device, FALSE: single-port device */
+    BOOL ability_1000base_t_fdx; /* Used for Auto-Negotiation */
+    BOOL ability_1000base_t_hdx; /* Used for Auto-Negotiation */
+} vtss_phy_masterslave_control_t;
+
+vtss_rc vtss_phy_masterslave_control_get(const vtss_port_no_t port_no,
+		vtss_phy_masterslave_control_t * const masterslave_control);
+
+vtss_rc vtss_phy_masterslave_control_set(const vtss_port_no_t port_no,
+		const vtss_phy_masterslave_control_t * const masterslave_control);
+
+/* PHY Master-Slave Status Register (Register 10), 1000Base-T only */
+typedef struct _vtss_phy_masterslave_status_t {
+    BOOL fault;
+    BOOL master;
+    BOOL local_receiver_status_ok;
+    BOOL remote_receiver_status_ok;
+    BOOL linkpartner_ability_1000base_t_fdx; /* Used for Auto-Negotiation */
+    BOOL linkpartner_ability_1000base_t_hdx; /* Used for Auto-Negotiation */
+    uchar idle_error_count;   /* Saturates when reaching 0xFF */
+} vtss_phy_masterslave_status_t;
+
+vtss_rc vtss_phy_masterslave_status_get(const vtss_port_no_t port_no,
+         vtss_phy_masterslave_status_t * const masterslave_status);
+
+/* - PHY Auto-Negotiation and Forced Speed ------------------------- */
+
+vtss_rc vtss_phy_force_speed(const vtss_port_no_t port_no,
+                             const vtss_speed_t speed,
+                             const BOOL fdx 
+							 /* Full duplex: TRUE, Half duplex: FALSE */ );
+
+
+#if defined(HEATHROW2) || defined(STAPLEFORD)
+/* ================================================================= *
+ *  TBI Auto-Negotiation and Status
+ * ================================================================= */
+
+BOOL vtss_tbi_enabled(const vtss_port_no_t port_no);
+
+/* Advertisement Word (Refer to IEEE 802.3 Clause 37):
+ *  MSB                                                                         LSB
+ *  D15  D14  D13  D12  D11  D10   D9   D8   D7   D6   D5   D4   D3   D2   D1   D0 
+ * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+ * | NP | Ack| RF2| RF1|rsvd|rsvd|rsvd| PS2| PS1| HD | FD |rsvd|rsvd|rsvd|rsvd|rsvd|
+ * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+ */
+
+/* enum used in vtss_autoneg_1000base_x_config_t */
+typedef enum _vtss_autoneg_1000base_x_remote_fault_t {
+                                     /* RF2 */  /* RF1 */
+    VTSS_1000BASEX_LINK_OK          = (( 0 <<1) | ( 0 <<0)),
+    VTSS_1000BASEX_OFFLINE          = (( 1 <<1) | ( 0 <<0)),
+    VTSS_1000BASEX_LINK_FAILURE     = (( 0 <<1) | ( 1 <<0)),
+    VTSS_1000BASEX_AUTONEG_ERROR    = (( 1 <<1) | ( 1 <<0))
+} vtss_autoneg_1000base_x_remote_fault_t;
+
+typedef struct _vtss_autoneg_1000base_x_advertisement_t {
+    BOOL fdx;
+    BOOL hdx;
+    BOOL symmetric_pause;    /* a.k.a. PAUSE (PS1) */
+    BOOL asymmetric_pause;   /* a.k.a. ASM_DIR (PS2) */
+    vtss_autoneg_1000base_x_remote_fault_t remote_fault;
+    BOOL acknowledge;
+    BOOL next_page;
+} vtss_autoneg_1000base_x_advertisement_t;
+
+typedef struct _vtss_tbi_autoneg_control_t {
+    BOOL enable;
+    vtss_autoneg_1000base_x_advertisement_t advertisement;
+} vtss_tbi_autoneg_control_t;
+
+vtss_rc vtss_tbi_autoneg_control_get(const vtss_port_no_t port_no,
+                   vtss_tbi_autoneg_control_t * const control);
+
+vtss_rc vtss_tbi_autoneg_control_set(const vtss_port_no_t port_no,
+	        const vtss_tbi_autoneg_control_t * const control);
+
+vtss_rc vtss_tbi_autoneg_restart(const vtss_port_no_t port_no);
+
+/* TBI Status, Current state of the PCS */
+typedef enum _vtss_tbi_pcs_state_t {
+	VTSS_TBI_PCS_STATE_IDLE,      /* Idle */
+	VTSS_TBI_PCS_STATE_CONFIG,    /* Config (i.e. ANEG in progress) */
+	VTSS_TBI_PCS_STATE_DATA       /* Data */
+} vtss_tbi_pcs_state_t;
+
+/*
+ * Note: The link_status entry is "shared" between vtss_port_status 
+ * and vtss_tbi_status_get functions. 
+*/
+typedef struct _vtss_tbi_status_t {
+	/* FALSE if link has been down since last status read */
+	BOOL link_status;        
+	/* Note: Saturates when reaching VTSS_TBI_LINK_DOWN_COUNTER_SATURATED. */
+	uint link_down_counter;  
+	struct {
+		vtss_tbi_pcs_state_t pcs_state;
+		BOOL priority_resolution;
+		BOOL complete;
+		vtss_autoneg_1000base_x_advertisement_t partner_advertisement;
+	} autoneg;
+} vtss_tbi_status_t;
+
+#define VTSS_TBI_LINK_DOWN_COUNTER_SATURATED 255
+
+vtss_rc vtss_tbi_status_get(const vtss_port_no_t port_no,
+                             vtss_tbi_status_t * const status);
+#endif /* HEATHROW2/STAPLEFORD */
+
+#endif /* _VITESSE_PHY_CTRL_H */
-- 
1.6.0.2.GIT

