From c80a3155c12f6044ab2a825ffefaabedfa57106a Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf.baechle@windriver.com>
Date: Tue, 14 Jul 2009 21:40:57 +0100
Subject: [PATCH] MIPS: RMI: Add EDAC support.

Drivers for EDAC on RMI XLR.  Supported subsystems are:

 o CPU primary and secondary caches.  These are ECC protected and provide
   SECDED protection.  The hardware silently fixes single bit errors so
   only double bit errors are reported - this unfortunately is a kernel
   panic situation and handled outside EDAC, so mentioned here only for
   completeness.
 o Memory: ECC / SECDEC if used with suitable DRAM modules.
 o PCI / PCI-X: Parity errors and various other errors that may indicate a
   hardware issue are reported.
 o HyperTransport: Parity errors and various other errors that may indicate
   a hardware issue are reported.

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
---
 arch/mips/Kconfig                |    4 +
 arch/mips/pci/pci-phoenix.c      |    8 ++
 arch/mips/rmi/phoenix/Makefile   |    2 +-
 arch/mips/rmi/phoenix/on_chip.c  |    3 +
 arch/mips/rmi/phoenix/platform.c |   35 +++++++
 drivers/edac/Kconfig             |   21 ++++-
 drivers/edac/Makefile            |    3 +
 drivers/edac/edac_core.h         |    1 +
 drivers/edac/rmi-edac-dram.c     |  184 ++++++++++++++++++++++++++++++++++++++
 drivers/edac/rmi-edac-ht.c       |  166 ++++++++++++++++++++++++++++++++++
 drivers/edac/rmi-edac-pcix.c     |  177 ++++++++++++++++++++++++++++++++++++
 11 files changed, 602 insertions(+), 2 deletions(-)
 create mode 100644 arch/mips/rmi/phoenix/platform.c
 create mode 100644 drivers/edac/rmi-edac-dram.c
 create mode 100644 drivers/edac/rmi-edac-ht.c
 create mode 100644 drivers/edac/rmi-edac-pcix.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 331d739..e1a7914 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -614,6 +614,7 @@ config RMI_PTR
 	select SWAP_IO_SPACE
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_EDAC
 	select SYS_SUPPORTS_HIGHMEM
 	select ZONE_DMA if 64BIT
 	select DMA_COHERENT
@@ -852,6 +853,9 @@ config SYS_SUPPORTS_APM_EMULATION
 config SYS_SUPPORTS_BIG_ENDIAN
 	bool
 
+config SYS_SUPPORTS_EDAC
+	bool
+
 config SYS_SUPPORTS_LITTLE_ENDIAN
 	bool
 
diff --git a/arch/mips/pci/pci-phoenix.c b/arch/mips/pci/pci-phoenix.c
index be19639..eec2039 100644
--- a/arch/mips/pci/pci-phoenix.c
+++ b/arch/mips/pci/pci-phoenix.c
@@ -35,6 +35,7 @@
 #include <linux/mm.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/platform_device.h>
 
 #include <asm/io.h>
 
@@ -632,12 +633,19 @@ static int __init pcibios_init(void)
 #endif
     register_pci_controller(&phoenix_controller);
 
+	if (IS_ERR(platform_device_register_simple("rmi_edac_pcix", -1,
+						   NULL, 0)))
+		pr_err("Registation of rmi_edac_pcix failed!\n");
+
     /* XLS : No native HT */
     if (!is_xls()) {
         /* XLR : ATX1, ATX2B Boards */
         if ((xlr_board_atx_i() || xlr_board_atx_ii_b()) && ht_controller_init_done()) {
             printk("Registering XLR HT Controller. \n");
             register_pci_controller(&phoenix_ht_controller);
+		if (IS_ERR(platform_device_register_simple("rmi_edac_ht", -1,
+							   NULL, 0)))
+			pr_err("Registation of rmi_edac_ht failed!\n");
         }
     }
 	return 0;
diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
index dfa2ac1..1d23471 100644
--- a/arch/mips/rmi/phoenix/Makefile
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -1,4 +1,4 @@
-obj-y := irq.o time.o on_chip.o on_chip_devtree.o
+obj-y := irq.o time.o on_chip.o on_chip_devtree.o platform.o
 
 obj-y += msgring.o msgring_xls.o msgring_shared.o 
 
diff --git a/arch/mips/rmi/phoenix/on_chip.c b/arch/mips/rmi/phoenix/on_chip.c
index 236ba59..bcf0088 100644
--- a/arch/mips/rmi/phoenix/on_chip.c
+++ b/arch/mips/rmi/phoenix/on_chip.c
@@ -29,6 +29,7 @@
   *****************************#RMI_2#**********************************/
 
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/smp.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
@@ -41,6 +42,8 @@
 #include <asm/rmi/sim.h>
 
 unsigned long phoenix_io_base = (unsigned long)(DEFAULT_PHOENIX_IO_BASE);
+EXPORT_SYMBOL_GPL(phoenix_io_base);
+
 extern int xlr_loader_support;
 extern int xlr_loader_sharedcore;
 extern int xlr_loader_own_gmac;
diff --git a/arch/mips/rmi/phoenix/platform.c b/arch/mips/rmi/phoenix/platform.c
new file mode 100644
index 0000000..b5621f5
--- /dev/null
+++ b/arch/mips/rmi/phoenix/platform.c
@@ -0,0 +1,35 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems
+ *   written by Ralf Baechle
+ */
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+static char *edac_device_names[] = {
+	"rmi_edac_cache",
+	"rmi_edac_dram",
+};
+
+static int __init edac_devinit(void)
+{
+	struct platform_device *dev;
+	int i, err = 0;
+	char *name;
+
+	for (i = 0; i < ARRAY_SIZE(edac_device_names); i++) {
+		name = edac_device_names[i];
+		dev = platform_device_register_simple(name, -1, NULL, 0);
+		if (IS_ERR(dev)) {
+			pr_err("Registation of %s failed!\n", name);
+			err = PTR_ERR(dev);
+		}
+	}
+
+	return err;
+}
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 5a11e3c..afb9294 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -8,7 +8,7 @@ menuconfig EDAC
 	bool "EDAC - error detection and reporting (EXPERIMENTAL)"
 	depends on HAS_IOMEM
 	depends on EXPERIMENTAL
-	depends on X86 || PPC
+	depends on X86 || PPC || SYS_SUPPORTS_EDAC
 	help
 	  EDAC is designed to report errors in the core system.
 	  These are low-level errors that are reported in the CPU or
@@ -160,4 +160,23 @@ config EDAC_CELL
 	  Cell Broadband Engine internal memory controller
 	  on platform without a hypervisor
 
+config EDAC_RMI_DRAM
+	tristate "RMI XLR DRAM Memory Controller"
+	depends on EDAC_MM_EDAC && RMI_PHOENIX
+	help
+	  Support for error detection and correction on the DRAM memory
+	  controller (SECDED) of RMI XLR family SOCs.
+
+config EDAC_RMI_PCIX
+	tristate "RMI XLR PCI-X Controller"
+	depends on EDAC_MM_EDAC && PCI && RMI_PHOENIX
+	help
+	  Support for error detection on the PCI-X bus of RMI XLR family SOCs.
+
+config EDAC_RMI_HT
+	tristate "RMI XLR HT Controller"
+	depends on EDAC_MM_EDAC && PCI && RMI_PHOENIX
+	help
+	  Support for error detection on the PCI-X bus of RMI XLR family SOCs.
+
 endif # EDAC
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index e5e9104..854d89e 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -32,4 +32,7 @@ obj-$(CONFIG_EDAC_PASEMI)		+= pasemi_edac.o
 obj-$(CONFIG_EDAC_MPC85XX)		+= mpc85xx_edac.o
 obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
+obj-$(CONFIG_EDAC_RMI_DRAM)		+= rmi-edac-dram.o
+obj-$(CONFIG_EDAC_RMI_PCIX)		+= rmi-edac-pcix.o
+obj-$(CONFIG_EDAC_RMI_HT)		+= rmi-edac-ht.o
 
diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 4b55ec6..88eacff 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -819,6 +819,7 @@ extern void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 				int inst_nr, int block_nr, const char *msg);
 extern void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 				int inst_nr, int block_nr, const char *msg);
+extern int edac_device_alloc_index(void);
 
 /*
  * edac_pci APIs
diff --git a/drivers/edac/rmi-edac-dram.c b/drivers/edac/rmi-edac-dram.c
new file mode 100644
index 0000000..5a1a189
--- /dev/null
+++ b/drivers/edac/rmi-edac-dram.c
@@ -0,0 +1,184 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <asm/rmi/iomap.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "rmi"
+
+struct rmi_lmc_priv {
+	struct timer_list poll_timer;
+};
+
+/*
+ * There should be a header file for these
+ */
+#define DDR_GLB_PARAMS			0x01c
+#define   ECC_REPORT_EN			(1 << 11)
+#define   ECC_EN			(1 <<  5)	/* B stepping only */
+#define   ECC_DETECT_EN			(1 <<  5)
+
+#define DDR_CFG_REG_RMW_ECC_LOG_HI	0x08c
+#define   ECC_LOG_C			(1 <<  1)
+#define   ECC_LOG_U			(1 <<  0)
+
+
+static void rmi_lmc_poll_channel(struct mem_ctl_info *mci, unsigned long offset,
+	char channel)
+{
+	phoenix_reg_t *mmio;
+	phoenix_reg_t reg;
+	char msg[64];
+
+	mmio = phoenix_io_mmio(offset);
+
+	reg = phoenix_read_reg(mmio, DDR_GLB_PARAMS);
+	if (!(reg & ECC_DETECT_EN))
+		return;
+
+	reg = phoenix_read_reg(mmio, DDR_CFG_REG_RMW_ECC_LOG_HI);
+	if (reg & ECC_LOG_C) {
+		snprintf(msg, sizeof(msg), "DDR channel %c", channel);
+		edac_mc_handle_ce_no_info(mci, msg);
+	}
+	if (reg & ECC_LOG_U) {
+		snprintf(msg, sizeof(msg), "DDR channel %c", channel);
+		edac_mc_handle_ue_no_info(mci, msg);
+	}
+	phoenix_write_reg(mmio, DDR_CFG_REG_RMW_ECC_LOG_HI, 0);	/* clear log */
+}
+
+static void rmi_lmc_poll(unsigned long data)
+{
+	struct mem_ctl_info *mci = (struct mem_ctl_info *) data;
+	struct rmi_lmc_priv *mp = mci->pvt_info;
+
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN0_OFFSET, 'A');
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN1_OFFSET, 'B');
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN2_OFFSET, 'C');
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN3_OFFSET, 'D');
+
+	mod_timer(&mp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit rmi_lmc_probe(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci;
+	struct rmi_lmc_priv *mp;
+	int res = 0;
+
+	mci = edac_mc_alloc(sizeof(*mp), 0, 0, 0);
+	if (!mci)
+		return -ENOMEM;
+
+	mci->dev = &pdev->dev;
+	platform_set_drvdata(pdev, mci);
+	mci->dev_name = dev_name(&pdev->dev);
+
+	mci->mod_name = "octeon-lmc";
+	mci->ctl_name = "rmi_lmc_err";
+
+	if (edac_mc_add_mc(mci) > 0) {
+		pr_err("%s: edac_mc_add_mc() failed\n", __func__);
+		goto err;
+	}
+
+	mp = mci->pvt_info;
+
+	init_timer(&mp->poll_timer);
+	mp->poll_timer.data       = (unsigned long) mci;
+	mp->poll_timer.function   = rmi_lmc_poll;
+	mp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&mp->poll_timer);
+
+	return 0;
+
+err:
+	edac_mc_free(mci);
+
+	return res;
+}
+
+static int rmi_lmc_remove(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
+	struct rmi_lmc_priv *mp = mci->pvt_info;
+
+	del_timer_sync(&mp->poll_timer);
+	edac_mc_del_mc(&pdev->dev);
+	edac_mc_free(mci);
+
+	return 0;
+}
+
+static struct platform_driver rmi_lmc_driver = {
+	.probe = rmi_lmc_probe,
+	.remove = rmi_lmc_remove,
+	.driver = {
+		   .name = "rmi_edac_dram",
+	}
+};
+
+static int rmi_lmc_bank_enabled(unsigned long offset, char bank)
+{
+	phoenix_reg_t reg;
+	phoenix_reg_t *mmio;
+
+	mmio = phoenix_io_mmio(offset);
+	reg = phoenix_read_reg(mmio, DDR_GLB_PARAMS);
+	if (reg & ECC_DETECT_EN) {
+		reg &= ~ECC_REPORT_EN;		/* disable reporting */
+		phoenix_write_reg(mmio, DDR_GLB_PARAMS, reg);
+		pr_err("%s: ECC on bank %c is enabled.\n", __func__, bank);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int __init rmi_edac_init(void)
+{
+	int activate, ret;
+
+	activate  = rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN0_OFFSET, 'A');
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN1_OFFSET, 'B');
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN2_OFFSET, 'C');
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN3_OFFSET, 'D');
+
+	if (!activate) {
+		pr_info("%s: ECC on all memory banks disabled, no EDAC\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	ret = platform_driver_register(&rmi_lmc_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " LMC EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit rmi_edac_exit(void)
+{
+	platform_driver_unregister(&rmi_lmc_driver);
+}
+
+module_init(rmi_edac_init);
+module_exit(rmi_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
diff --git a/drivers/edac/rmi-edac-ht.c b/drivers/edac/rmi-edac-ht.c
new file mode 100644
index 0000000..217a2e0
--- /dev/null
+++ b/drivers/edac/rmi-edac-ht.c
@@ -0,0 +1,166 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <asm/rmi/iomap.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "rmi"
+
+struct rmi_pci_priv {
+	struct timer_list poll_timer;
+};
+
+#define PHNX_HT_COMMAND				(0x004 >>  2)
+#define   SERRE					(1     <<  3)
+#define   BME					(1     <<  2)
+#define   MEMSE					(1     <<  1)
+#define   IOSE					(1     <<  0)
+
+#define SPECIAL_INTERRUPT			(0x740 >>  2)
+#define   HT_LINK_ERROR				(1     <<  6)
+#define   DIO_WRITE_ERROR			(1     <<  5)
+#define   CFG_WRITE_ERRT			(1     <<  4)
+#define   EXT_INT				(1     <<  3)
+#define   INIT					(1     <<  2)
+#define   NMI					(1     <<  1)
+#define   SMI					(1     <<  0)
+
+#define LINK_ERROR				(0x0a8 >>  2)
+#define   CTL_TIMEOUT				(1     << 15)
+#define   END_OF_CHAIN_ERROR			(1     << 14)
+#define   OVERFLOW_ERROR			(1     << 13)
+#define   PROTOCOL_ERROR			(1     << 12)
+
+static void rmi_pci_poll(unsigned long data)
+{
+	struct edac_pci_ctl_info *pci = (struct edac_pci_ctl_info *) data;
+	struct rmi_pci_priv *pp = pci->pvt_info;
+	phoenix_reg_t *mmio;
+	phoenix_reg_t reg;
+
+	mmio = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+	/*
+	 * Note that SPECIAL_INTERRUPT is clear on read
+	 */
+	reg = phoenix_read_reg(mmio, SPECIAL_INTERRUPT);
+
+	if (reg & HT_LINK_ERROR) {
+		phoenix_reg_t le;
+
+		/* Again this register ist a r/c register  */
+		le = phoenix_read_reg(mmio, LINK_ERROR);
+		if (le & END_OF_CHAIN_ERROR)
+			edac_pci_handle_npe(pci, "End of chain error");
+		if (le & OVERFLOW_ERROR)
+			edac_pci_handle_npe(pci, "Overflow Error");
+		if (le & PROTOCOL_ERROR)
+			edac_pci_handle_npe(pci, "HT protocol/ECC Error");
+	}
+	if (reg & DIO_WRITE_ERROR)
+		edac_pci_handle_npe(pci, "Error I/O Distributed Interface");
+	if (reg & CFG_WRITE_ERRT)
+		edac_pci_handle_npe(pci, "Configuration Write Timeout");
+
+	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit rmi_pci_probe(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci;
+	struct rmi_pci_priv *pp;
+	phoenix_reg_t *mmio;
+	phoenix_reg_t reg;
+	int res = 0;
+
+	pci = edac_pci_alloc_ctl_info(sizeof(*pp), "rmi-pci-err");
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	platform_set_drvdata(pdev, pci);
+	pci->dev_name = dev_name(&pdev->dev);
+
+	pci->mod_name = "rmi-pci";
+	pci->ctl_name = "rmi-pci-err";
+
+	if (edac_pci_add_device(pci, 0) > 0) {
+		pr_err("%s: edac_pci_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	pp = pci->pvt_info;
+
+	mmio = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+	reg = phoenix_read_reg(mmio, PHNX_HT_COMMAND);
+	reg &= SERRE;
+	phoenix_write_reg(mmio, PHNX_HT_COMMAND, reg);
+
+	init_timer(&pp->poll_timer);
+	pp->poll_timer.data       = (unsigned long) pci;
+	pp->poll_timer.function   = rmi_pci_poll;
+	pp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&pp->poll_timer);
+
+	return 0;
+
+err:
+	edac_pci_free_ctl_info(pci);
+
+	return res;
+}
+
+static int rmi_pci_remove(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci = platform_get_drvdata(pdev);
+	struct rmi_pci_priv *pp = pci->pvt_info;
+
+	del_timer_sync(&pp->poll_timer);
+	edac_pci_del_device(&pdev->dev);
+	edac_pci_free_ctl_info(pci);
+
+	return 0;
+}
+
+static struct platform_driver rmi_pci_driver = {
+	.probe = rmi_pci_probe,
+	.remove = rmi_pci_remove,
+	.driver = {
+		   .name = "rmi_edac_pcix",
+	}
+};
+
+static int __init rmi_edac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&rmi_pci_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " PCI EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit rmi_edac_exit(void)
+{
+	platform_driver_unregister(&rmi_pci_driver);
+}
+
+module_init(rmi_edac_init);
+module_exit(rmi_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
diff --git a/drivers/edac/rmi-edac-pcix.c b/drivers/edac/rmi-edac-pcix.c
new file mode 100644
index 0000000..cd231f8
--- /dev/null
+++ b/drivers/edac/rmi-edac-pcix.c
@@ -0,0 +1,177 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <asm/rmi/iomap.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "rmi"
+
+struct rmi_pci_priv {
+	struct timer_list poll_timer;
+};
+
+#define PHNX_PCI_STATUS				(0x004 >>  2)
+#define   DET_PAR_ERROR				(1     << 31)
+#define   SIGD_SERR				(1     << 30)
+#define   RCVD_MASTER_ABORT			(1     << 29)
+#define   RCVD_TARGET_ABORT			(1     << 28)
+#define   SIGD_TARGET_ABORT			(1     << 27)
+#define   DEV_SEL_TIMING			(1     << 25)
+#define   MASTER_DATA_PAR_DETECTED		(1     << 24)
+#define   FAST_B2B_CAP				(1     << 23)
+#define   PCI_66MHZ_CAP				(1     << 21)
+#define   CAP_LIST				(1     << 20)
+
+#define PHNX_PCI_COMMAND			(0x004 >>  2)
+#define   FAST_B2BEN				(1     <<  9)
+#define   SERREN				(1     <<  8)
+#define   STEP_CTRL				(1     <<  7)
+#define   PAR_ERR_EN				(1     <<  6)
+#define   VGA_PAL_SNOOP_EN			(1     <<  5)
+#define   MEM_WRITE_INV_EN			(1     <<  4)
+#define   SPEC_SYS_EN				(1     <<  3)
+#define   BUS_MASTER_EN				(1     <<  2)
+#define   MEM_SPACE_EN				(1     <<  1)
+#define   IO_SPACE_EN				(1     <<  0)
+
+#define INTERRUPT_ERROR_STATUS_REGISTER		(0x144 >>  2)
+#define   SERR					(1     <<  4)
+#define   TARGET_ERROR				(1     <<  2)
+#define   INITIATOR_ERROR			(1     <<  1)
+#define   RETRY_COUNT_EXPIRED			(1     <<  0)
+
+static void rmi_pci_poll(unsigned long data)
+{
+	struct edac_pci_ctl_info *pci = (struct edac_pci_ctl_info *) data;
+	struct rmi_pci_priv *pp = pci->pvt_info;
+	phoenix_reg_t *mmio;
+	phoenix_reg_t reg;
+
+	mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+
+	/*
+	 * Careful - the RMI documentation doesn't make sense here!
+	 */
+	reg = phoenix_read_reg(mmio, PHNX_PCI_STATUS);
+	if (reg & DET_PAR_ERROR) {
+		edac_pci_handle_pe(pci, pci->ctl_name);
+		phoenix_write_reg(mmio, PHNX_PCI_STATUS, reg);
+	}
+
+	/*
+	 * Note that INTERRUPT_ERROR_STATUS_REGISTER is clear on read and it
+	 * resides in the same 32-bit word as PHNX_PCI_STATUS, so we don't
+	 * read it again!
+	 */
+	if (reg & SERR)
+		edac_pci_handle_npe(pci, "Signaled System Error");
+	if (reg & TARGET_ERROR)
+		edac_pci_handle_npe(pci, "Target Error");
+	if (reg & INITIATOR_ERROR)
+		edac_pci_handle_npe(pci, "Received Initiator Error");
+	if (reg & RETRY_COUNT_EXPIRED)
+		edac_pci_handle_npe(pci, "Retry Count Expired");
+
+	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit rmi_pci_probe(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci;
+	struct rmi_pci_priv *pp;
+	phoenix_reg_t *mmio;
+	phoenix_reg_t reg;
+	int res = 0;
+
+	pci = edac_pci_alloc_ctl_info(sizeof(*pp), "rmi-pci-err");
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	platform_set_drvdata(pdev, pci);
+	pci->dev_name = dev_name(&pdev->dev);
+
+	pci->mod_name = "rmi-pci";
+	pci->ctl_name = "rmi-pci-err";
+
+	if (edac_pci_add_device(pci, 0) > 0) {
+		pr_err("%s: edac_pci_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	pp = pci->pvt_info;
+
+	mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+	reg = phoenix_read_reg(mmio, PHNX_PCI_COMMAND);
+	reg &= (SERREN | PAR_ERR_EN);
+	phoenix_write_reg(mmio, PHNX_PCI_COMMAND, reg);
+
+	init_timer(&pp->poll_timer);
+	pp->poll_timer.data       = (unsigned long) pci;
+	pp->poll_timer.function   = rmi_pci_poll;
+	pp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&pp->poll_timer);
+
+	return 0;
+
+err:
+	edac_pci_free_ctl_info(pci);
+
+	return res;
+}
+
+static int rmi_pci_remove(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci = platform_get_drvdata(pdev);
+	struct rmi_pci_priv *pp = pci->pvt_info;
+
+	del_timer_sync(&pp->poll_timer);
+	edac_pci_del_device(&pdev->dev);
+	edac_pci_free_ctl_info(pci);
+
+	return 0;
+}
+
+static struct platform_driver rmi_pci_driver = {
+	.probe = rmi_pci_probe,
+	.remove = rmi_pci_remove,
+	.driver = {
+		   .name = "rmi_edac_pcix",
+	}
+};
+
+static int __init rmi_edac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&rmi_pci_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " PCI EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit rmi_edac_exit(void)
+{
+	platform_driver_unregister(&rmi_pci_driver);
+}
+
+module_init(rmi_edac_init);
+module_exit(rmi_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
-- 
1.6.3.1

