From bb45bb9eac6b3106b34a4692087a26ec570ae9b5 Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf.baechle@windriver.com>
Date: Thu, 20 Aug 2009 18:46:23 +0100
Subject: [PATCH] EDAC: Fix potencial crash on RMI DRAM module insertion

Hardware / software may use a register to disable access to most of the
devices on a RMI board.  If for some reason access to a DRAM controller
is disabled the EDAC DRAM driver module load will result in cache errors
crashing the system.

Fixed by changing the probe to a two stage probe.  We now only probe the
DRAM controller for enabled ECC capability after first checking for
the device mask register for this to be permissible.

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
---
 drivers/edac/rmi-edac-dram.c |   67 ++++++++++++++++++++++++++++++++----------
 1 files changed, 51 insertions(+), 16 deletions(-)

diff --git a/drivers/edac/rmi-edac-dram.c b/drivers/edac/rmi-edac-dram.c
index f8c6865..d2b73a4 100644
--- a/drivers/edac/rmi-edac-dram.c
+++ b/drivers/edac/rmi-edac-dram.c
@@ -18,7 +18,7 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
-#define EDAC_MOD_STR "rmi"
+#define EDAC_MOD_STR "rmi-edac-dram"
 
 struct rmi_lmc_priv {
 	struct timer_list poll_timer;
@@ -26,6 +26,17 @@ struct rmi_lmc_priv {
 
 /*
  * There should be a header file for these
+ *
+ * Register in the system bridge
+ */
+#define DEVICE_MASK			(0x094 >> 2)
+#define   DDR_CHND			(1    <<  4)
+#define   DDR_CHNC			(1    <<  3)
+#define   DDR_CHNB			(1    <<  2)
+#define   DDR_CHNA			(1    <<  1)
+
+/*
+ * Registers in the DRAM controllers
  */
 #define DDR_GLB_PARAMS			(0x01c >> 2)
 #define   ECC_REPORT_EN			(1    << 11)
@@ -38,12 +49,17 @@ struct rmi_lmc_priv {
 
 
 static void rmi_lmc_poll_channel(struct mem_ctl_info *mci, unsigned long offset,
-	char channel)
+	char channel, unsigned int dev_mask)
 {
 	phoenix_reg_t *mmio;
 	phoenix_reg_t reg;
 	char msg[64];
 
+	mmio = phoenix_io_mmio(PHOENIX_IO_BRIDGE_OFFSET);
+	reg = phoenix_read_reg(mmio, DEVICE_MASK);
+	if (!(reg & dev_mask))
+		return;
+
 	mmio = phoenix_io_mmio(offset);
 
 	reg = phoenix_read_reg(mmio, DDR_GLB_PARAMS);
@@ -67,10 +83,10 @@ static void rmi_lmc_poll(unsigned long data)
 	struct mem_ctl_info *mci = (struct mem_ctl_info *) data;
 	struct rmi_lmc_priv *mp = mci->pvt_info;
 
-	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN0_OFFSET, 'A');
-	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN1_OFFSET, 'B');
-	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN2_OFFSET, 'C');
-	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN3_OFFSET, 'D');
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN0_OFFSET, 'A', DDR_CHNA);
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN1_OFFSET, 'B', DDR_CHNB);
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN2_OFFSET, 'C', DDR_CHNC);
+	rmi_lmc_poll_channel(mci, PHOENIX_IO_DDR2_CHN3_OFFSET, 'D', DDR_CHND);
 
 	mod_timer(&mp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
 }
@@ -93,7 +109,7 @@ static int __devinit rmi_lmc_probe(struct platform_device *pdev)
 	mci->ctl_name = "rmi_lmc_err";
 
 	if (edac_mc_add_mc(mci) > 0) {
-		pr_err("%s: edac_mc_add_mc() failed\n", __func__);
+		pr_err(EDAC_MOD_STR": edac_mc_add_mc() failed\n");
 		goto err;
 	}
 
@@ -133,20 +149,34 @@ static struct platform_driver rmi_lmc_driver = {
 	}
 };
 
-static int rmi_lmc_bank_enabled(unsigned long offset, char bank)
+static int rmi_lmc_bank_enabled(unsigned long offset, char bank,
+	unsigned int dev_mask)
 {
 	phoenix_reg_t reg;
 	phoenix_reg_t *mmio;
 
+	mmio = phoenix_io_mmio(PHOENIX_IO_BRIDGE_OFFSET);
+	reg = phoenix_read_reg(mmio, DEVICE_MASK);
+	if (!(reg & dev_mask)) {
+		pr_info(EDAC_MOD_STR": Memory controller bank %c is disabled\n",
+			bank);
+		return 0;
+	}
+
+	pr_info(EDAC_MOD_STR": Memory controller bank %c is enabled\n", bank);
+
 	mmio = phoenix_io_mmio(offset);
 	reg = phoenix_read_reg(mmio, DDR_GLB_PARAMS);
 	if (reg & ECC_DETECT_EN) {
 		reg &= ~ECC_REPORT_EN;		/* disable reporting */
 		phoenix_write_reg(mmio, DDR_GLB_PARAMS, reg);
-		pr_err("%s: ECC on bank %c is enabled.\n", __func__, bank);
+		pr_info(EDAC_MOD_STR": ECC on bank %c is enabled.\n", bank);
+
 		return 1;
 	}
 
+	pr_info(EDAC_MOD_STR": ECC on bank %c is disabled.\n", bank);
+
 	return 0;
 }
 
@@ -154,20 +184,25 @@ static int __init rmi_edac_init(void)
 {
 	int activate, ret;
 
-	activate  = rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN0_OFFSET, 'A');
-	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN1_OFFSET, 'B');
-	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN2_OFFSET, 'C');
-	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN3_OFFSET, 'D');
+	activate  = rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN0_OFFSET,
+					 'A', DDR_CHNA);
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN1_OFFSET,
+					 'B', DDR_CHNB);
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN2_OFFSET,
+					 'C', DDR_CHNC);
+	activate |= rmi_lmc_bank_enabled(PHOENIX_IO_DDR2_CHN3_OFFSET,
+					 'D', DDR_CHND);
 
 	if (!activate) {
-		pr_info("%s: ECC on all memory banks disabled, no EDAC\n",
-			__func__);
+		pr_info(EDAC_MOD_STR
+			": ECC on all memory banks disabled, no EDAC\n");
+
 		return -ENODEV;
 	}
 
 	ret = platform_driver_register(&rmi_lmc_driver);
 	if (ret)
-		pr_warning(EDAC_MOD_STR " LMC EDAC failed to register\n");
+		pr_warning(EDAC_MOD_STR ": LMC EDAC failed to register\n");
 
 	return ret;
 }
-- 
1.6.3.3

