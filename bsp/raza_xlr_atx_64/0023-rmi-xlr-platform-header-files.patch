From 865aed6a54919fbde803effe5efff99fdedd173f Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 16 Dec 2008 19:07:16 +0800
Subject: [PATCH] rmi xlr platform header files

RMI XLR platform specific header files.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 include/asm-mips/rmi/64bit.h                  |   85 ++
 include/asm-mips/rmi/atx_cpld.h               |   64 ++
 include/asm-mips/rmi/debug.h                  |  109 +++
 include/asm-mips/rmi/devices.h                |   44 +
 include/asm-mips/rmi/global_shmem.h           |   45 +
 include/asm-mips/rmi/gpio.h                   |   77 ++
 include/asm-mips/rmi/interrupt.h              |   59 ++
 include/asm-mips/rmi/io.h                     |   53 ++
 include/asm-mips/rmi/iomap.h                  |  222 +++++
 include/asm-mips/rmi/memory-exclusion.h       |   38 +
 include/asm-mips/rmi/mips-exts.h              |  321 +++++++
 include/asm-mips/rmi/msgring.h                |  676 +++++++++++++++
 include/asm-mips/rmi/msidef.h                 |   73 ++
 include/asm-mips/rmi/pci.h                    |   38 +
 include/asm-mips/rmi/perf_ctr.h               |   72 ++
 include/asm-mips/rmi/phnx_cde.h               |  165 ++++
 include/asm-mips/rmi/phnx_loader.h            |  175 ++++
 include/asm-mips/rmi/phnx_tb.h                |   96 ++
 include/asm-mips/rmi/phnx_user_mac.h          |   62 ++
 include/asm-mips/rmi/phoenix_flash_pcmcia.h   |  116 +++
 include/asm-mips/rmi/phoenix_ide.h            |   62 ++
 include/asm-mips/rmi/phoenix_mac.h            | 1149 +++++++++++++++++++++++++
 include/asm-mips/rmi/phoenix_rmios_debugger.h |   53 ++
 include/asm-mips/rmi/phoenix_sec.h            |  766 ++++++++++++++++
 include/asm-mips/rmi/phoenix_shim_drv.h       |  510 +++++++++++
 include/asm-mips/rmi/phoenix_uart.h           |   52 ++
 include/asm-mips/rmi/pic.h                    |  241 ++++++
 include/asm-mips/rmi/proc.h                   |   51 ++
 include/asm-mips/rmi/rmi_pcix_gen_dev.h       |  115 +++
 include/asm-mips/rmi/rmi_pcix_gen_host.h      |  117 +++
 include/asm-mips/rmi/rmi_rw_lock.h            |  117 +++
 include/asm-mips/rmi/rmios_user_mac.h         |   64 ++
 include/asm-mips/rmi/sim.h                    |  341 ++++++++
 include/asm-mips/rmi/user/phnx_loader.h       |  148 ++++
 include/asm-mips/rmi/user/phnx_mmap.h         |   44 +
 include/asm-mips/rmi/user/phnx_msgring.h      |   56 ++
 include/asm-mips/rmi/user/phnx_user_mac.h     |  223 +++++
 include/asm-mips/rmi/xgmac_mdio.h             |  115 +++
 include/asm-mips/rmi/xlr_pcix_boot.h          |   42 +
 include/asm-mips/rmi/xlr_virt_uart.h          |   68 ++
 40 files changed, 6924 insertions(+), 0 deletions(-)
 create mode 100644 include/asm-mips/rmi/64bit.h
 create mode 100644 include/asm-mips/rmi/atx_cpld.h
 create mode 100644 include/asm-mips/rmi/debug.h
 create mode 100644 include/asm-mips/rmi/devices.h
 create mode 100644 include/asm-mips/rmi/global_shmem.h
 create mode 100644 include/asm-mips/rmi/gpio.h
 create mode 100644 include/asm-mips/rmi/interrupt.h
 create mode 100644 include/asm-mips/rmi/io.h
 create mode 100644 include/asm-mips/rmi/iomap.h
 create mode 100644 include/asm-mips/rmi/memory-exclusion.h
 create mode 100644 include/asm-mips/rmi/mips-exts.h
 create mode 100644 include/asm-mips/rmi/msgring.h
 create mode 100644 include/asm-mips/rmi/msidef.h
 create mode 100644 include/asm-mips/rmi/pci.h
 create mode 100644 include/asm-mips/rmi/perf_ctr.h
 create mode 100644 include/asm-mips/rmi/phnx_cde.h
 create mode 100644 include/asm-mips/rmi/phnx_loader.h
 create mode 100644 include/asm-mips/rmi/phnx_tb.h
 create mode 100644 include/asm-mips/rmi/phnx_user_mac.h
 create mode 100644 include/asm-mips/rmi/phoenix_flash_pcmcia.h
 create mode 100644 include/asm-mips/rmi/phoenix_ide.h
 create mode 100644 include/asm-mips/rmi/phoenix_mac.h
 create mode 100644 include/asm-mips/rmi/phoenix_rmios_debugger.h
 create mode 100644 include/asm-mips/rmi/phoenix_sec.h
 create mode 100644 include/asm-mips/rmi/phoenix_shim_drv.h
 create mode 100644 include/asm-mips/rmi/phoenix_uart.h
 create mode 100644 include/asm-mips/rmi/pic.h
 create mode 100644 include/asm-mips/rmi/proc.h
 create mode 100644 include/asm-mips/rmi/rmi_pcix_gen_dev.h
 create mode 100644 include/asm-mips/rmi/rmi_pcix_gen_host.h
 create mode 100644 include/asm-mips/rmi/rmi_rw_lock.h
 create mode 100644 include/asm-mips/rmi/rmios_user_mac.h
 create mode 100644 include/asm-mips/rmi/sim.h
 create mode 100644 include/asm-mips/rmi/user/phnx_loader.h
 create mode 100644 include/asm-mips/rmi/user/phnx_mmap.h
 create mode 100644 include/asm-mips/rmi/user/phnx_msgring.h
 create mode 100644 include/asm-mips/rmi/user/phnx_user_mac.h
 create mode 100644 include/asm-mips/rmi/xgmac_mdio.h
 create mode 100644 include/asm-mips/rmi/xlr_pcix_boot.h
 create mode 100644 include/asm-mips/rmi/xlr_virt_uart.h

diff --git a/include/asm-mips/rmi/64bit.h b/include/asm-mips/rmi/64bit.h
new file mode 100644
index 0000000..b8d825f
--- /dev/null
+++ b/include/asm-mips/rmi/64bit.h
@@ -0,0 +1,85 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_64BIT_H
+#define _ASM_RMI_64BIT_H
+
+#include <linux/types.h>
+#include <asm/system.h>
+
+/* Implement 64bit read and write operations */
+
+static inline void out64(u64 val, unsigned long addr)
+{
+  u32 low, high, tmp;
+  unsigned long flags=0;
+
+  high = val >> 32;
+  low = val & 0xffffffff;
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# out64n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			"   dsll32 %0, %2, 0   \n"
+			"   dsll32 $1, %1, 0   \n"
+			"   dsrl32 %0, %0, 0   \n"
+			"   or     $1, $1, %0  \n"
+			"   sd $1, (%3)\n"
+			".set pop\n"
+			: "=&r" (tmp)
+			: "r" (high), "r" (low), "r" (addr));
+  local_irq_restore(flags);
+}
+
+static inline u64 in64(unsigned long addr)
+{
+  unsigned long flags;
+  u32 low, high;
+
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# in64\n"
+			".set noreorder\n"
+			".set noat     \n"
+			".set mips4    \n"
+			"  ld     %1, (%2)\n"
+			"  dsra32 %0, %1, 0\n"
+			"  sll    %1, %1, 0\n"
+			".set pop\n"
+			: "=r" (high), "=r" (low)
+			: "r" (addr));
+  local_irq_restore(flags);
+
+  return (((u64)high) << 32) | low;
+}
+
+#endif 
diff --git a/include/asm-mips/rmi/atx_cpld.h b/include/asm-mips/rmi/atx_cpld.h
new file mode 100644
index 0000000..aa3f8d5
--- /dev/null
+++ b/include/asm-mips/rmi/atx_cpld.h
@@ -0,0 +1,64 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_ATX_CPLD_H
+#define _ASM_RMI_ATX_CPLD_H
+
+/*
+	 * bit_0 : xgs0 phy reset
+	 * bit_1 : xgs1 phy reset
+	 * bit_2 : HT reset
+	 * bit_3 : RTC reset
+	 * bit_4 : gmac phy soft reset
+	 * bit_5 : gmac phy hard reset
+	 * bit_6 : board reset
+	 * bit_7 : reserved
+*/
+#define ATX_CPLD_RESET_1   2
+
+/*
+ *  bit_0_2 : reserved
+ *  bit_3 : turn off xpak_0 tx
+ *  bit_4 : turn off xpak_1 tx
+ *  bit_5 : HT stop (active low)
+ *  bit_6 : flash program enable
+ *  bit_7 : compact flash io mode
+ */
+#define ATX_CPLD_MISC_CTRL 8
+
+/*
+ * bit_0 : reset tcam 
+ * bit_1 : reset xpak_0 module
+ * bit_2 : reset xpak_1 module
+ * bit_3_7 : reserved
+ */
+#define ATX_CPLD_RESET_2   9
+
+#endif /* _ASM_RMI_ATX_CPLD_H */
diff --git a/include/asm-mips/rmi/debug.h b/include/asm-mips/rmi/debug.h
new file mode 100644
index 0000000..c11839f
--- /dev/null
+++ b/include/asm-mips/rmi/debug.h
@@ -0,0 +1,109 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEBUG_H
+#define _ASM_RMI_DEBUG_H
+
+#include <linux/threads.h>
+#include <linux/smp.h>
+#include <asm/atomic.h>
+
+enum {
+  /* cacheline 0 */
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  /* cacheline 1 */
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  /* cacheline 2 */
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  /* cacheline 3 */
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  /* cacheline 4 */
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_BIGTLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  PHNX_MAX_COUNTERS = 40
+};
+
+extern atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#define phnx_inc_counter(x)             \
+	    atomic_inc(&phnx_counters[cpu_logical_map(smp_processor_id())][(x)])
+#define phnx_dec_counter(x)             \
+	    atomic_dec(&phnx_counters[cpu_logical_map(smp_processor_id())][(x)])
+#define phnx_set_counter(x, value)      \
+	    atomic_set(&phnx_counters[cpu_logical_map(smp_processor_id())][(x)], (value))
+#define phnx_get_counter(x)             \
+	    atomic_read(&phnx_counters[cpu_logical_map(smp_processor_id())][(x)])
+
+#ifdef CONFIG_DEBUG 
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __func__, smp_processor_id(), ##args)
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __func__, smp_processor_id(), ##args)
+#define prom_dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __func__, smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/devices.h b/include/asm-mips/rmi/devices.h
new file mode 100644
index 0000000..9cb258a
--- /dev/null
+++ b/include/asm-mips/rmi/devices.h
@@ -0,0 +1,44 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEVICES_H
+#define _ASM_RMI_DEVICES_H
+
+#define XLR_VIRT_UART_MAJOR       239
+#define XLR_TB_MAJOR              240
+#define XLR_USER_MAC_MAJOR        241
+#define XLR_CRYPTO_MAJOR          242
+
+#define XLR_MSGRING_SHM_MAJOR     244
+#define XLR_APP_LOADER_MAJOR      245
+#define XLR_CONSOLE_OVER_PCI_MAJOR	  246
+#define XLR_DEBUGGER_MAJOR              247
+
+#endif
diff --git a/include/asm-mips/rmi/global_shmem.h b/include/asm-mips/rmi/global_shmem.h
new file mode 100644
index 0000000..0fe20d3
--- /dev/null
+++ b/include/asm-mips/rmi/global_shmem.h
@@ -0,0 +1,45 @@
+/***********************************************************************
+ Copyright 2003-2006 Raza Microelectronics, Inc.(RMI). All rights
+ reserved.
+ Use of this software shall be governed in all respects by the terms and
+ conditions of the RMI software license agreement ("SLA") that was
+ accepted by the user as a condition to opening the attached files.
+ Without limiting the foregoing, use of this software in source and
+ binary code forms, with or without modification, and subject to all
+ other SLA terms and conditions, is permitted.
+ Any transfer or redistribution of the source code, with or without
+ modification, IS PROHIBITED,unless specifically allowed by the SLA.
+ Any transfer or redistribution of the binary code, with or without
+ modification, is permitted, provided that the following condition is
+ met:
+ Redistributions in binary form must reproduce the above copyright
+ notice, the SLA, this list of conditions and the following disclaimer
+ in the documentation and/or other materials provided with the
+ distribution:
+ THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. `AS IS'' AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+ FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_3#***********************************/
+#ifndef __GLOBAL_SHMEM_H_
+#define __GLOBAL_SHMEM_H_
+
+
+/* Apps should check this size and then use boot1_info->global_shmem_addr */
+#define GLOBAL_SHMEM_SIZE       0x1000
+
+
+/* Apps should use the boot1_info->global_shmem_addr + the offsets defined
+   here.
+ */
+#define BRIDGE_WKAROUND_AREA_OFFSET	0
+#define BRIDGE_WKAROUND_AREA_SIZE	32
+
+#endif
diff --git a/include/asm-mips/rmi/gpio.h b/include/asm-mips/rmi/gpio.h
new file mode 100644
index 0000000..d3b72de
--- /dev/null
+++ b/include/asm-mips/rmi/gpio.h
@@ -0,0 +1,77 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_GPIO_H
+#define _ASM_RMI_GPIO_H
+
+#include <asm/rmi/iomap.h>
+
+#define PHOENIX_GPIO_INT_EN_REG 0
+#define PHOENIX_GPIO_INPUT_INVERSION_REG 1
+#define PHOENIX_GPIO_IO_DIR_REG 2
+#define PHOENIX_GPIO_IO_DATA_WR_REG 3
+#define PHOENIX_GPIO_IO_DATA_RD_REG 4
+
+#define PHOENIX_GPIO_SWRESET_REG 8
+
+#define PHOENIX_GPIO_DRAM1_CNTRL_REG 9
+#define PHOENIX_GPIO_DRAM1_RATIO_REG 10
+#define PHOENIX_GPIO_DRAM1_RESET_REG 11
+#define PHOENIX_GPIO_DRAM1_STATUS_REG 12
+
+#define PHOENIX_GPIO_DRAM2_CNTRL_REG 13
+#define PHOENIX_GPIO_DRAM2_RATIO_REG 14
+#define PHOENIX_GPIO_DRAM2_RESET_REG 15
+#define PHOENIX_GPIO_DRAM2_STATUS_REG 16
+
+#define PHOENIX_GPIO_PWRON_RESET_CFG_REG 21
+
+#define PHOENIX_GPIO_BIST_ALL_GO_STATUS_REG 24
+#define PHOENIX_GPIO_BIST_CPU_GO_STATUS_REG 25
+#define PHOENIX_GPIO_BIST_DEV_GO_STATUS_REG 26
+
+#define PHOENIX_GPIO_FUSE_BANK_REG 35
+
+#define PHOENIX_GPIO_CPU_RESET_REG 40
+
+#define PHOENIX_GPIO_RNG_REG 43
+
+#define PHOENIX_PWRON_RESET_PCMCIA_BOOT 17
+
+#define PHOENIX_GPIO_LED_BITMAP 0x1700000
+#define PHOENIX_GPIO_LED_0_SHIFT 20
+#define PHOENIX_GPIO_LED_1_SHIFT 24
+
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_RESET 0x01
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_MAIN 0x04
+
+#endif
diff --git a/include/asm-mips/rmi/interrupt.h b/include/asm-mips/rmi/interrupt.h
new file mode 100644
index 0000000..fd57fe9
--- /dev/null
+++ b/include/asm-mips/rmi/interrupt.h
@@ -0,0 +1,59 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_INTERRUPT_H
+#define _ASM_RMI_INTERRUPT_H
+
+#include <asm/rmi/pic.h>
+
+/* Defines for the IRQ numbers */
+
+#define IRQ_DUMMY_UART           2
+#define IRQ_IPI_SMP_FUNCTION     3
+#define IRQ_IPI_SMP_RESCHEDULE   4
+#define IRQ_REMOTE_DEBUG         5
+#define IRQ_MSGRING              6
+#define IRQ_TIMER                7
+#define IRQ_IPI_SMP_KGDB   	50
+#define IRQ_IPI_OPROFILE        51
+
+
+#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
+
+#define IRQ_IPI_NETRX           49
+#define SMP_NETRX_IPI           0x20
+
+#endif /* CONFIG_PHOENIX_IP_FLOW_AFFINITY */
+
+
+#define SMP_CALL_KGDB_HOOK 	8
+#define SMP_OPROFILE_IPI        0x10
+
+#endif
diff --git a/include/asm-mips/rmi/io.h b/include/asm-mips/rmi/io.h
new file mode 100644
index 0000000..d0ab8cb
--- /dev/null
+++ b/include/asm-mips/rmi/io.h
@@ -0,0 +1,53 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_IO_H
+#define _ASM_RMI_IO_H
+
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
+#define __raw_writeb(v,a)       (*(volatile unsigned char  *)(a) = (v))
+#define __raw_writew(v,a)       (*(volatile unsigned short *)(a) = (v))
+#define __raw_writel(v,a)       (*(volatile unsigned int   *)(a) = (v))
+
+#define __raw_readb(a)          (*(volatile unsigned char  *)(a))
+#define __raw_readw(a)          (*(volatile unsigned short *)(a))
+#define __raw_readl(a)          (*(volatile unsigned int   *)(a))
+
+#define ioread8(p)  ({ unsigned int __v = __raw_readb(p); __v; })
+#define ioread16(p) ({ unsigned int __v = le16_to_cpu(__raw_readw(p)); __v; })
+#define ioread32(p) ({ unsigned int __v = le32_to_cpu(__raw_readl(p)); __v; })
+
+#define iowrite8(v,p)   __raw_writeb(v, p)
+#define iowrite16(v,p)  __raw_writew(cpu_to_le16(v), p)
+#define iowrite32(v,p)  __raw_writel(cpu_to_le32(v), p)
+
+#endif
diff --git a/include/asm-mips/rmi/iomap.h b/include/asm-mips/rmi/iomap.h
new file mode 100644
index 0000000..3c4533d
--- /dev/null
+++ b/include/asm-mips/rmi/iomap.h
@@ -0,0 +1,222 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RFI_IO_H
+#define _ASM_RFI_IO_H
+
+#define DEFAULT_PHOENIX_IO_BASE 0xffffffffbef00000ULL
+#define PHOENIX_IO_SIZE                   0x1000
+
+#define PHOENIX_IO_BRIDGE_OFFSET          0x00000
+
+#define PHOENIX_IO_DDR2_CHN0_OFFSET       0x01000
+#define PHOENIX_IO_DDR2_CHN1_OFFSET       0x02000
+#define PHOENIX_IO_DDR2_CHN2_OFFSET       0x03000
+#define PHOENIX_IO_DDR2_CHN3_OFFSET       0x04000
+
+#define PHOENIX_IO_RLD2_CHN0_OFFSET       0x05000
+#define PHOENIX_IO_RLD2_CHN1_OFFSET       0x06000
+
+#define PHOENIX_IO_SRAM_OFFSET            0x07000
+
+#define PHOENIX_IO_PIC_OFFSET             0x08000
+#define PHOENIX_IO_PCIX_OFFSET            0x09000
+#define PHOENIX_IO_HT_OFFSET              0x0A000
+
+#define PHOENIX_IO_SECURITY_OFFSET        0x0B000
+
+#define PHOENIX_IO_GMAC_0_OFFSET          0x0C000
+#define PHOENIX_IO_GMAC_1_OFFSET          0x0D000
+#define PHOENIX_IO_GMAC_2_OFFSET          0x0E000
+#define PHOENIX_IO_GMAC_3_OFFSET          0x0F000
+
+#ifdef XLS
+#define PHOENIX_IO_GMAC_4_OFFSET          0x20000
+#define PHOENIX_IO_GMAC_5_OFFSET          0x21000
+#define PHOENIX_IO_GMAC_6_OFFSET          0x22000
+#define PHOENIX_IO_GMAC_7_OFFSET          0x23000
+
+#define PHOENIX_IO_PCIE_0_OFFSET          0x1E000
+#define PHOENIX_IO_PCIE_1_OFFSET          0x1F000
+
+#define PHOENIX_IO_USB_0_OFFSET           0x24000
+#define PHOENIX_IO_USB_1_OFFSET           0x25000
+
+#define PHOENIX_IO_COMP_OFFSET            0x1D000
+
+#endif /* XLS */
+
+#define PHOENIX_IO_SPI4_0_OFFSET          0x10000
+#define PHOENIX_IO_XGMAC_0_OFFSET         0x11000
+#define PHOENIX_IO_SPI4_1_OFFSET          0x12000
+#define PHOENIX_IO_XGMAC_1_OFFSET         0x13000
+
+#define PHOENIX_IO_UART_0_OFFSET          0x14000
+#define PHOENIX_IO_UART_1_OFFSET          0x15000
+
+#define PHOENIX_IO_I2C_0_OFFSET           0x16000
+#define PHOENIX_IO_I2C_1_OFFSET           0x17000
+
+#define PHOENIX_IO_GPIO_OFFSET            0x18000
+
+#define PHOENIX_IO_FLASH_OFFSET           0x19000
+
+#define PHOENIX_IO_TB_OFFSET           	  0x1C000
+
+#define PHOENIX_CPLD_OFFSET               0xffffffffbd840000ULL
+
+/* Base Address (Virtual) of the PCI Config address space
+ * For now, choose 256M phys in kseg1 = 0xA0000000 + (1<<28)
+ * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
+ * ie 1<<24 = 16M
+ */ 
+#define DEFAULT_PCI_CONFIG_BASE         0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef volatile __u32 phoenix_reg_t;
+extern unsigned long phoenix_io_base;
+
+#define phoenix_io_mmio(offset) ((phoenix_reg_t *)(phoenix_io_base+(offset)))
+
+#ifdef RMI_BRIDGE_WKAROUND
+#include <asm/rmi/rmi_rw_lock.h>
+
+extern rmi_rwlock_t *rmi_bridge_lock;
+extern int rmi_enable_br_wrkaround;
+
+static inline uint32_t rmi_br_read_lock(void)
+{
+	if(rmi_enable_br_wrkaround)
+		return rmi_read_lock_irq_save(rmi_bridge_lock);
+	return 0;
+}
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround)
+		rmi_read_unlock_irq_restore(rmi_bridge_lock, flags);
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+	if(rmi_enable_br_wrkaround)
+		return rmi_write_lock_irq_save(rmi_bridge_lock);
+	return 0;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround)
+		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
+}
+
+static inline uint32_t rmi_read_reg_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+
+	flags = rmi_br_read_lock();
+	val = (be32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline uint32_t rmi_read_reg_le_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+	flags = rmi_br_read_lock();
+	val = (le32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline void rmi_write_reg_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_be32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+static inline void rmi_write_reg_le_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_le32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+#define phoenix_read_reg(base, offset) rmi_read_reg_locked(base, offset)
+#define phoenix_write_reg(base, offset, value) \
+	rmi_write_reg_locked(base, offset, value)
+
+#define phoenix_read_reg_le32(base, offset) \
+	rmi_read_reg_le_locked(base, offset)
+#define phoenix_write_reg_le32(base, offset, value) \
+	rmi_write_reg_le_locked(base, offset, value)
+#else
+static inline uint32_t rmi_br_read_lock(void) 
+{
+	return 0;
+}
+
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+	return 0;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+}
+#define phoenix_read_reg(base, offset) (be32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg(base, offset, value) ((base)[(offset)] = cpu_to_be32((value)))
+
+#define phoenix_read_reg_le32(base, offset) (le32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg_le32(base, offset, value) \
+	((base)[(offset)] = cpu_to_le32((value)))
+
+#endif
+extern void on_chip_init(void);
+
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/memory-exclusion.h b/include/asm-mips/rmi/memory-exclusion.h
new file mode 100644
index 0000000..3a6730e
--- /dev/null
+++ b/include/asm-mips/rmi/memory-exclusion.h
@@ -0,0 +1,38 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef PHNX_MEMORY_EXCLUSION
+#define PHNX_MEMORY_EXCLUSION
+
+#define PHNX_RMIOS_TCPIP_START  (8<<20)
+#define PHNX_RMIOS_TCPIP_END    (96<<20)
+
+#define PHNX_RMIOS_IPSEC_START  (1<<20)
+#define PHNX_RMIOS_IPSEC_END    (51<<20)
+
+#define PHNX_RMIOS_LIB_START    (16<<20)
+#define PHNX_RMIOS_LIB_END	(51<<20)
+
+#endif
diff --git a/include/asm-mips/rmi/mips-exts.h b/include/asm-mips/rmi/mips-exts.h
new file mode 100644
index 0000000..4d437c1
--- /dev/null
+++ b/include/asm-mips/rmi/mips-exts.h
@@ -0,0 +1,321 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MIPS_EXTS_H
+#define _ASM_RMI_MIPS_EXTS_H
+
+#define PHOENIX_OSS_SEL_TLB_STATS 0
+#define PHOENIX_OSS_SEL_BIGTLB_STATS 1
+#define PHOENIX_OSS_SEL_PAGEMASK 2
+#define PHOENIX_OSS_SEL_VADDR 3
+#define PHOENIX_OSS_SEL_PFN0 4
+#define PHOENIX_OSS_SEL_PFN1 5
+#define PHOENIX_OSS_SEL_K0 6
+#define PHOENIX_OSS_SEL_K1 7
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/rmi/interrupt.h>
+
+#define DMFC0_AT_EIRR 0x40214806
+#define DMFC0_AT_EIMR 0x40214807
+#define DMTC0_AT_EIRR 0x40a14806
+#define DMTC0_AT_EIMR 0x40a14807
+
+/*
+ * Functions to write to and read from the extended
+ * cp0 registers.
+ * EIRR : Extended Interrupt Request Register
+ *        cp0 register 9 sel 6
+ *        bits 0...7 are same as cause register 8...15
+ * EIMR : Extended Interrupt Mask Register
+ *        cp0 register 9 sel 7
+ *        bits 0...7 are same as status register 8...15
+*/
+static inline __u64 read_64bit_cp0_eirr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214806  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline __u64 read_64bit_cp0_eimr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214807  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline void write_64bit_cp0_eirr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14806 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static inline void write_64bit_cp0_eimr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14807 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+#define phoenix_id()                                            \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 10\n"                      \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_cpu_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 4\n"                       \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_thr_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "andi %0, $8, 0x0f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+static __inline__ int hard_smp_processor_id(void)
+{
+	return (phoenix_cpu_id() << 2) + phoenix_thr_id();
+}
+
+#define CPU_BLOCKID_IFU      0
+#define CPU_BLOCKID_ICU      1
+#define CPU_BLOCKID_IEU      2
+#define CPU_BLOCKID_LSU      3
+#define CPU_BLOCKID_MMU      4
+#define CPU_BLOCKID_PRF      5
+
+#define LSU_CERRLOG_REGID    9
+
+static __inline__ unsigned int read_32bit_phnx_ctrl_reg(int block, int reg)
+{
+	unsigned int __res;
+
+	__asm__ __volatile__(
+			".set\tpush\n\t"
+			".set\tnoreorder\n\t"
+			"move $9, %1\n"
+			/* "mfcr\t$8, $9\n\t" */
+			".word 0x71280018\n"
+			"move %0, $8\n"
+			".set\tpop"
+			: "=r" (__res) : "r"((block<<8)|reg)
+			: "$8", "$9"
+		);
+
+	return __res;
+}
+
+static __inline__ void write_32bit_phnx_ctrl_reg(int block, int reg, unsigned int value)
+{
+	__asm__ __volatile__(
+			".set\tpush\n\t"
+			".set\tnoreorder\n\t"
+			"move $8, %0\n"
+			"move $9, %1\n"
+			/* "mtcr\t$8, $9\n\t" */
+			".word 0x71280019\n"
+			".set\tpop"
+			:
+			: "r" (value), "r"((block<<8)|reg)
+			: "$8", "$9"
+		);
+}
+
+static __inline__ unsigned long long read_64bit_phnx_ctrl_reg(int block, int reg)
+{
+	unsigned int high, low;
+
+	__asm__ __volatile__(
+			".set\tmips64\n\t"
+			"move    $9, %2\n"
+			/* "mfcr    $8, $9\n" */
+			".word   0x71280018\n"
+			"dsrl32  %0, $8, 0\n\t"
+			"dsll32  $8, $8, 0\n\t"
+			"dsrl32  %1, $8, 0\n\t"
+			".set mips0"
+			: "=r" (high), "=r"(low)
+			: "r"((block<<8)|reg)
+			: "$8", "$9"
+		);
+
+	return ((((unsigned long long)high)<<32) | low);
+}
+
+static __inline__ void write_64bit_phnx_ctrl_reg(int block, int reg,unsigned long long value)
+{
+	__u32 low, high;
+	high = value >> 32;
+	low = value & 0xffffffff;
+
+	__asm__ __volatile__(
+			".set push\n"
+			".set noreorder\n"
+			".set mips4\n\t"
+			/* Set up "rs" */
+			"move $9, %0\n"
+
+			/* Store 64 bit value in "rt" */
+			"dsll32 $10, %1, 0  \n\t"
+			"dsll32 $8, %2, 0  \n\t"
+			"dsrl32 $8, $8, 0  \n\t"
+			"or     $10, $8, $8 \n\t"
+			/* mtcr $8, $9 */
+			".word 0x71280019\n" 
+
+			".set pop\n"
+
+			:  /* No outputs */
+			: "r"((block<<8)|reg), "r" (high), "r" (low)
+			: "$8", "$9", "$10"
+		);
+}
+
+typedef struct { volatile int value; } phnx_atomic_t;
+
+static __inline__ int phnx_test_and_set(phnx_atomic_t *lock)
+{
+	int oldval = 0;
+
+	__asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			"move $9, %2\n"
+			"li $8, 1\n"
+			/* "swapw $8, $9\n" */
+			".word 0x71280014\n"
+			"move %1, $8\n"
+			".set pop\n"
+			: "+m" (lock->value), "=r" (oldval)
+			: "r" ((unsigned long)&lock->value)
+			: "$8", "$9"
+		);
+	return (oldval == 0 ? 1 : 0);
+}
+
+#endif
+
+#endif /* _ASM_RMI_MIPS_EXTS_H */
diff --git a/include/asm-mips/rmi/msgring.h b/include/asm-mips/rmi/msgring.h
new file mode 100644
index 0000000..cc026a6
--- /dev/null
+++ b/include/asm-mips/rmi/msgring.h
@@ -0,0 +1,676 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MSG_RING_H
+#define _ASM_RMI_MSG_RING_H
+
+#include <linux/types.h>
+
+#include <asm/asm.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/mips-exts.h>
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define read_32bit_cp2_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_32bit_cp2_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define read_32bit_cp2_register_sel(source, sel)                \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define write_32bit_cp2_register_sel(reg, value, sel)           \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#define MSGRNG_TX_BUF_REG $0
+#define MSGRNG_RX_BUF_REG $1
+
+#define MSGRNG_MSG_STATUS_REG $2
+#define MSGRNG_MSG_CONFIG_REG $3
+
+#define MSGRNG_MSG_BUCKSIZE_REG $4
+
+#define MSGRNG_CC_0_REG  $16
+#define MSGRNG_CC_1_REG  $17
+#define MSGRNG_CC_2_REG  $18
+#define MSGRNG_CC_3_REG  $19
+#define MSGRNG_CC_4_REG  $20
+#define MSGRNG_CC_5_REG  $21
+#define MSGRNG_CC_6_REG  $22
+#define MSGRNG_CC_7_REG  $23
+#define MSGRNG_CC_8_REG  $24
+#define MSGRNG_CC_9_REG  $25
+#define MSGRNG_CC_10_REG $26
+#define MSGRNG_CC_11_REG $27
+#define MSGRNG_CC_12_REG $28
+#define MSGRNG_CC_13_REG $29
+#define MSGRNG_CC_14_REG $30
+#define MSGRNG_CC_15_REG $31
+
+#define msgrng_read_status() read_32bit_cp2_register(MSGRNG_MSG_STATUS_REG)
+
+#define msgrng_read_config() read_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG)
+#define msgrng_write_config(value) write_32bit_cp2_register(MSGRNG_MSG_CONFIG_REG, value)
+
+#define msgrng_read_bucksize(bucket) read_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, bucket)
+#define msgrng_write_bucksize(bucket, value) write_32bit_cp2_register_sel(MSGRNG_MSG_BUCKSIZE_REG, value, bucket)
+
+#define msgrng_read_cc(reg, pri) read_32bit_cp2_register_sel(reg, pri)
+#define msgrng_write_cc(reg, value, pri) write_32bit_cp2_register_sel(reg, value, pri)
+
+#if 1
+#define read_64bit_cp2_register_sel(source, sel)			\
+({									\
+	unsigned int high, low;						\
+									\
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+			"dmfc2\t$8, "STR(source)","STR(sel)"\n\t"		\
+			"dsrl32\t%0, $8, 0\n\t"			        \
+                        "dsll32\t$8, $8, 0\n\t"                         \
+                        "dsrl32\t%1, $8, 0\n\t"                         \
+			".set\tmips0"					\
+			: "=r" (high), "=r"(low): "i"(sel) : "$8");	\
+	( (((unsigned long long)high)<<32) | low);					\
+})
+
+#define write_64bit_cp2_register_sel(source, val, sel)			\
+do {									\
+     unsigned int high = val>>32;                                       \
+     unsigned int low  = val & 0xffffffff;                              \
+		__asm__ __volatile__(					\
+			".set\tmips64\n\t"				\
+                        "dsll32 $8, %1, 0\n"                            \
+                        "dsll32 $9, %0, 0\n"                            \
+                        "dsrl32 $8, $8, 0\n"                            \
+                        "or     $8, $8, $9\n"				\
+			"dmtc2\t$8, "STR(source)", %2\n\t"		\
+			".set\tmips0"					\
+			: : "r" (high), "r" (low), "i"(sel): "$8", "$9");		\
+} while (0)
+
+#else
+#define read_64bit_cp2_register(source)                         \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        ".set\tmips64\n\t"                                      \
+        "dmfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_64bit_cp2_register(register,value)                \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "dmtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+	".set\tpop"						\
+        : : "r" (value));
+
+#define read_64bit_cp2_register_sel(source, sel)                \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define write_64bit_cp2_register_sel(reg, value, sel)           \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+#endif
+
+#define msgrng_load_rx_msg0() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 0)
+#define msgrng_load_rx_msg1() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 1)
+#define msgrng_load_rx_msg2() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 2)
+#define msgrng_load_rx_msg3() read_64bit_cp2_register_sel(MSGRNG_RX_BUF_REG, 3)
+
+#define msgrng_load_tx_msg0(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 0)
+#define msgrng_load_tx_msg1(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 1)
+#define msgrng_load_tx_msg2(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 2)
+#define msgrng_load_tx_msg3(value) write_64bit_cp2_register_sel(MSGRNG_TX_BUF_REG, value, 3)
+
+/* Station IDs */
+#define MSGRNG_STNID_CPU0  0x00
+#define MSGRNG_STNID_CPU1  0x08
+#define MSGRNG_STNID_CPU2  0x10
+#define MSGRNG_STNID_CPU3  0x18
+#define MSGRNG_STNID_CPU4  0x20
+#define MSGRNG_STNID_CPU5  0x28
+#define MSGRNG_STNID_CPU6  0x30
+#define MSGRNG_STNID_CPU7  0x38
+
+#define MSGRING_STNID_DEVICES 64
+#define MSGRNG_STNID_XGS0_TX 64
+#define MSGRNG_STNID_XMAC0_00_TX 64
+#define MSGRNG_STNID_XMAC0_01_TX 65
+#define MSGRNG_STNID_XMAC0_02_TX 66
+#define MSGRNG_STNID_XMAC0_03_TX 67
+#define MSGRNG_STNID_XMAC0_04_TX 68
+#define MSGRNG_STNID_XMAC0_05_TX 69
+#define MSGRNG_STNID_XMAC0_06_TX 70
+#define MSGRNG_STNID_XMAC0_07_TX 71
+#define MSGRNG_STNID_XMAC0_08_TX 72
+#define MSGRNG_STNID_XMAC0_09_TX 73
+#define MSGRNG_STNID_XMAC0_10_TX 74
+#define MSGRNG_STNID_XMAC0_11_TX 75
+#define MSGRNG_STNID_XMAC0_12_TX 76
+#define MSGRNG_STNID_XMAC0_13_TX 77
+#define MSGRNG_STNID_XMAC0_14_TX 78
+#define MSGRNG_STNID_XMAC0_15_TX 79
+
+#define MSGRNG_STNID_XGS1_TX 80
+#define MSGRNG_STNID_XMAC1_00_TX 80
+#define MSGRNG_STNID_XMAC1_01_TX 81
+#define MSGRNG_STNID_XMAC1_02_TX 82
+#define MSGRNG_STNID_XMAC1_03_TX 83
+#define MSGRNG_STNID_XMAC1_04_TX 84
+#define MSGRNG_STNID_XMAC1_05_TX 85
+#define MSGRNG_STNID_XMAC1_06_TX 86
+#define MSGRNG_STNID_XMAC1_07_TX 87
+#define MSGRNG_STNID_XMAC1_08_TX 88
+#define MSGRNG_STNID_XMAC1_09_TX 89
+#define MSGRNG_STNID_XMAC1_10_TX 90
+#define MSGRNG_STNID_XMAC1_11_TX 91
+#define MSGRNG_STNID_XMAC1_12_TX 92
+#define MSGRNG_STNID_XMAC1_13_TX 93
+#define MSGRNG_STNID_XMAC1_14_TX 94
+#define MSGRNG_STNID_XMAC1_15_TX 95
+
+#define MSGRNG_STNID_GMAC 96
+#define MSGRNG_STNID_GMACJFR_0  96
+#define MSGRNG_STNID_GMACRFR_0  97
+#define MSGRNG_STNID_GMACTX0  98
+#define MSGRNG_STNID_GMACTX1  99
+#define MSGRNG_STNID_GMACTX2  100
+#define MSGRNG_STNID_GMACTX3  101
+#define MSGRNG_STNID_GMACJFR_1  102
+#define MSGRNG_STNID_GMACRFR_1  103
+
+#define MSGRNG_STNID_DMA      104
+#define MSGRNG_STNID_DMA_0    104
+#define MSGRNG_STNID_DMA_1    105
+#define MSGRNG_STNID_DMA_2    106
+#define MSGRNG_STNID_DMA_3    107
+
+#define MSGRNG_STNID_XGS0FR 112
+#define MSGRNG_STNID_XMAC0JFR 112
+#define MSGRNG_STNID_XMAC0RFR 113
+
+#define MSGRNG_STNID_XGS1FR 114
+#define MSGRNG_STNID_XMAC1JFR 114
+#define MSGRNG_STNID_XMAC1RFR 115
+
+#define MSGRNG_STNID_SEC 120
+#define MSGRNG_STNID_SEC0 120
+#define MSGRNG_STNID_SEC1 121
+#define MSGRNG_STNID_SEC2 122
+#define MSGRNG_STNID_SEC3 123
+#define MSGRNG_STNID_PK0  124
+
+#define MSGRNG_STNID_GMAC1      80
+#define MSGRNG_STNID_GMAC1_FR   81
+#define MSGRNG_STNID_GMAC1_TX0  82
+#define MSGRNG_STNID_GMAC1_TX1  83
+#define MSGRNG_STNID_GMAC1_TX2  84
+#define MSGRNG_STNID_GMAC1_TX3  85
+#define MSGRNG_STNID_GMAC0      96
+#define MSGRNG_STNID_GMAC0_FR   97
+#define MSGRNG_STNID_GMAC0_TX0  98
+#define MSGRNG_STNID_GMAC0_TX1  99
+#define MSGRNG_STNID_GMAC0_TX2  100
+#define MSGRNG_STNID_GMAC0_TX3  101
+#define MSGRNG_STNID_CMP_0      108
+#define MSGRNG_STNID_CMP_1      109
+#define MSGRNG_STNID_CMP_2      110
+#define MSGRNG_STNID_CMP_3      111
+#define MSGRNG_STNID_PCIE_0     116
+#define MSGRNG_STNID_PCIE_1     117
+#define MSGRNG_STNID_PCIE_2     118
+#define MSGRNG_STNID_PCIE_3     119
+#define MSGRNG_STNID_XLS_PK0    121
+
+#define MSGRNG_CODE_DEVICE         0
+#define MSGRNG_CODE_MAC            MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_XGMAC          MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_SPI4           MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_SEC            MSGRNG_CODE_DEVICE
+#define MSGRNG_CODE_BOOT_WAKEUP    200
+
+static inline int msgrng_xgmac_stid_rfr(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0RFR : MSGRNG_STNID_XMAC1RFR;
+}
+
+static inline int msgrng_xgmac_stid_jfr(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0JFR : MSGRNG_STNID_XMAC1JFR;
+}
+
+static inline int msgrng_xgmac_stid_tx(int id)
+{
+  return !id ? MSGRNG_STNID_XMAC0_00_TX : MSGRNG_STNID_XMAC1_00_TX;
+}
+
+static inline int msgrng_gmac_stid_rfr(int id)
+{
+  if (id & 0x4)
+      return (MSGRNG_STNID_GMAC1_FR);
+  return (MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_rfr_split_mode(int id)
+{
+  return ((id>>1)?MSGRNG_STNID_GMACRFR_1:MSGRNG_STNID_GMACRFR_0);
+}
+
+static inline int msgrng_gmac_stid_jfr(int id)
+{
+  return MSGRNG_STNID_GMACJFR_0;
+}
+
+static inline int msgrng_gmac_stid_jfr_split_mode(int id)
+{
+  return ((id>>1)?MSGRNG_STNID_GMACJFR_1:MSGRNG_STNID_GMACJFR_0);
+}
+
+static inline int msgrng_gmac_stid_tx(int id)
+{
+  if (id & 0x4)
+      return (MSGRNG_STNID_GMAC1_TX0 + (id & 0x3));
+  return (MSGRNG_STNID_GMACTX0 + id);
+}
+
+static inline int msgrng_gmac0_stid_rfr(int id)
+{
+  return (MSGRNG_STNID_GMAC0_FR);
+}
+static inline int msgrng_gmac0_stid_tx(int id)
+{
+  return (MSGRNG_STNID_GMAC0_TX0 + id);
+}
+static inline int msgrng_gmac1_stid_rfr(int id)
+{
+  return (MSGRNG_STNID_GMAC1_FR);
+}
+static inline int msgrng_gmac1_stid_tx(int id)
+{
+  return (MSGRNG_STNID_GMAC1_TX0 + (id & 0x3));
+}
+
+static inline void msgrng_send(unsigned int stid)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    "sync\n"
+		    /* "msgsnd %0\n" */
+		    "move  $8, %0\n"
+		    "c2    0x80001\n"
+		    ".set pop\n"
+		    : : "r" (stid) : "$8"
+		    );
+}
+
+static inline void msgrng_receive(unsigned int pri)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    /* "msgld %0\n" */
+		    "move $8, %0\n"
+		    "c2   0x80002\n"
+		    ".set pop\n"
+		    : : "r" (pri) : "$8"
+		    );
+}
+
+static inline void msgrng_wait(unsigned int mask)
+{
+  __asm__ volatile (
+		    ".set push\n"
+		    ".set noreorder\n"
+		    /* "msgwait %0\n" */
+		    "move $8, %0\n"
+		    /*to ensure msgwait picks up the right bucket */
+		    ""STR(PTR_ADDU)" $8, $8, $0\n"
+		    "c2   0x80003\n"
+		    ".set pop\n"
+		    : :"r" (mask) : "$8"
+		    );
+}
+
+#define msgrng_enable(flags)                \
+do {                                        \
+  preempt_disable(); \
+  __asm__ volatile (                        \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+  preempt_enable(); \
+} while (0)
+
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#define msgrng_flags_save(flags) msgrng_enable(flags)
+#define msgrng_flags_restore(flags) msgrng_disable(flags)
+
+struct msgrng_msg {
+  __u64 msg0;
+  __u64 msg1;
+  __u64 msg2;
+  __u64 msg3;
+};
+
+static inline void message_send_block_fast(int size, unsigned int code, unsigned int stid,
+                                         unsigned long long msg0, unsigned long long msg1,
+					 unsigned long long msg2, unsigned long long msg3)
+{
+  __asm__ __volatile__ (".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        "dmtc2 %1, "STR(MSGRNG_TX_BUF_REG)", 0\n"
+                        "dmtc2 %2, "STR(MSGRNG_TX_BUF_REG)", 1\n"
+                        "dmtc2 %3, "STR(MSGRNG_TX_BUF_REG)", 2\n"
+                        "dmtc2 %4, "STR(MSGRNG_TX_BUF_REG)", 3\n"
+		        "sync\n"
+                        "move $8, %0\n"
+                        "1: c2 0x80001\n"
+                        "mfc2 $8, "STR(MSGRNG_MSG_STATUS_REG)"\n"
+                        "andi $8, $8, 0x6\n"
+                        "bnez $8, 1b\n"
+                        "move $8, %0\n"
+                        ".set pop\n"
+                        :
+                        : "r"(((size-1)<<16)|(code<<8)|stid), "r" (msg0), "r" (msg1), "r"(msg2), "r"(msg3)
+                        : "$8"
+                        );
+}
+
+#define message_receive_fast(bucket, size, code, stid, msg0, msg1, msg2, msg3)      \
+        ( { unsigned int _status=0, _tmp=0;                     \
+           msgrng_receive(bucket);                              \
+           while ( (_status=msgrng_read_status()) & 0x08) ;     \
+           _tmp = _status & 0x30;                               \
+           if (likely(!_tmp)) {                                 \
+                 (size)=((_status & 0xc0)>>6)+1;                \
+                 (code)=(_status & 0xff00)>>8;                  \
+                 (stid)=(_status & 0x7f0000)>>16;               \
+                 (msg0)=msgrng_load_rx_msg0();                  \
+                 (msg1)=msgrng_load_rx_msg1();                  \
+                 (msg2)=msgrng_load_rx_msg2();                  \
+                 (msg3)=msgrng_load_rx_msg3();                  \
+                 _tmp=0;                                        \
+                }                                               \
+           _tmp;                                                \
+        } )
+
+static __inline__ int message_send(unsigned int size, unsigned int code,
+				   unsigned int stid, struct msgrng_msg *msg)
+{
+  unsigned int dest = 0;
+  unsigned long long status=0;
+  int i=0;
+
+  msgrng_load_tx_msg0(msg->msg0);
+  msgrng_load_tx_msg1(msg->msg1);
+  msgrng_load_tx_msg2(msg->msg2);
+  msgrng_load_tx_msg3(msg->msg3);
+
+  dest = ((size-1)<<16)|(code<<8)|(stid);
+
+  dbg_msg("Sending msg<%Lx,%Lx,%Lx,%Lx> to dest = %x\n",
+  			msg->msg0, msg->msg1, msg->msg2, msg->msg3, dest);
+
+
+  for(i=0;i<16;i++) {
+  	msgrng_send(dest);
+	status = msgrng_read_status();
+	dbg_msg("status = %Lx\n", status);
+
+	if (status & 0x6) {
+	  continue;
+	}
+	else break;
+	}
+    if (i==16) {
+	  if (dest == 0x61)
+		  dbg_msg("Processor %x: Unable to send msg to %llx\n", processor_id(), dest);
+	  return status & 0x6;
+	}
+  return msgrng_read_status() & 0x06;
+}
+
+static __inline__ int message_send_retry(unsigned int size, unsigned int code,
+					 unsigned int stid, struct msgrng_msg *msg)
+{
+  int res = 0;
+  int retry = 0;
+
+  for(;;) {
+    res = message_send(size, code, stid, msg);
+    /* retry a pending fail */
+    if (res & 0x02) continue;
+    /* credit fail */
+    if (res & 0x04) retry++;
+    else break;
+    if (retry == 4) return res & 0x06;
+  }
+
+  return 0;
+}
+
+static __inline__ int message_receive(int pri, int *size, int *code, int *src_id,
+				      struct msgrng_msg *msg)
+{
+  int res = message_receive_fast(pri, *size, *code, *src_id, msg->msg0, msg->msg1, msg->msg2, msg->msg3);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  if (!res) {
+    dbg_msg("Received msg <%llx, %llx, %llx, %llx> <%d,%d,%d>\n",
+	    msg->msg0, msg->msg1, msg->msg2, msg->msg3,
+	    *size, *code, *src_id);
+  }
+#endif
+
+  return res;
+}
+
+#define MSGRNG_STN_RX_QSIZE 256
+
+struct stn_cc {
+  unsigned short counters[16][8];
+};
+
+struct bucket_size {
+  unsigned short bucket[128];
+};
+
+extern struct bucket_size bucket_sizes;
+
+extern struct stn_cc cc_table_cpu_0;
+extern struct stn_cc cc_table_cpu_1;
+extern struct stn_cc cc_table_cpu_2;
+extern struct stn_cc cc_table_cpu_3;
+extern struct stn_cc cc_table_cpu_4;
+extern struct stn_cc cc_table_cpu_5;
+extern struct stn_cc cc_table_cpu_6;
+extern struct stn_cc cc_table_cpu_7;
+extern struct stn_cc cc_table_xgs_0;
+extern struct stn_cc cc_table_xgs_1;
+extern struct stn_cc cc_table_gmac;
+extern struct stn_cc cc_table_dma;
+extern struct stn_cc cc_table_sec;
+
+extern struct bucket_size xls_bucket_sizes;
+extern struct stn_cc xls_cc_table_cpu_0;
+extern struct stn_cc xls_cc_table_cpu_1;
+extern struct stn_cc xls_cc_table_gmac0;
+extern struct stn_cc xls_cc_table_gmac1;
+extern struct stn_cc xls_cc_table_cmp;
+extern struct stn_cc xls_cc_table_pcie;
+extern struct stn_cc xls_cc_table_dma;
+extern struct stn_cc xls_cc_table_sec;
+
+extern struct bucket_size shared_bucket_sizes;
+
+extern struct stn_cc shared_cc_table_cpu_0;
+extern struct stn_cc shared_cc_table_cpu_1;
+extern struct stn_cc shared_cc_table_cpu_2;
+extern struct stn_cc shared_cc_table_cpu_3;
+extern struct stn_cc shared_cc_table_cpu_4;
+extern struct stn_cc shared_cc_table_cpu_5;
+extern struct stn_cc shared_cc_table_cpu_6;
+extern struct stn_cc shared_cc_table_cpu_7;
+extern struct stn_cc shared_cc_table_gmac;
+extern struct stn_cc shared_cc_table_dma;
+
+
+#define msgrng_access_save(lock, iflags, mflags) do {        \
+  spin_lock_irqsave(lock, iflags);                           \
+  msgrng_flags_save(mflags);                                 \
+ }while(0)
+
+#define msgrng_access_restore(lock, iflags, mflags) do {     \
+  msgrng_flags_restore(mflags);                              \
+  spin_unlock_irqrestore(lock, iflags);                      \
+ }while(0)
+
+#define msgrng_access_enable(mflags) do {   \
+  preempt_disable();                        \
+  msgrng_flags_save(mflags);                \
+} while(0)
+
+#define msgrng_access_disable(mflags) do {   \
+  msgrng_flags_restore(mflags);              \
+  preempt_enable();                          \
+} while(0)
+
+enum {
+  TX_STN_CPU_0,
+  TX_STN_CPU_1,
+  TX_STN_CPU_2,
+  TX_STN_CPU_3,
+  TX_STN_CPU_4,
+  TX_STN_CPU_5,
+  TX_STN_CPU_6,
+  TX_STN_CPU_7,
+  TX_STN_GMAC,
+  TX_STN_DMA,
+  TX_STN_XGS_0,
+  TX_STN_XGS_1,
+  TX_STN_SEC,
+  TX_STN_GMAC0,
+  TX_STN_GMAC1,
+  TX_STN_CMP,
+  TX_STN_PCIE,
+  TX_STN_INVALID,
+  MAX_TX_STNS
+};
+
+extern int register_msgring_handler(int major,
+				    void (*action)(int, int,int,int,struct msgrng_msg *, void *),
+				    void *dev_id);
+extern void phoenix_msgring_cpu_init(void);
+
+extern void phnx_msgring_config(void);
+
+#define cpu_to_msgring_bucket(cpu) ((((cpu) >> 2)<<3)|((cpu) & 0x03))
+
+
+/* PR: We need to make the following entrities visible across the kernel */
+
+struct msgrng_msg;
+
+struct tx_stn_handler {
+	void (*action)(int, int, int, int, struct msgrng_msg *, void *);
+	void *dev_id;
+};
+
+struct tx_stn {
+	struct tx_stn_handler handler;
+};
+
+extern struct tx_stn tx_stns[];
+extern int rxstn_to_txstn_map[];
+extern int xls_rxstn_to_txstn_map[];
+
+
+#endif
diff --git a/include/asm-mips/rmi/msidef.h b/include/asm-mips/rmi/msidef.h
new file mode 100644
index 0000000..b34353f
--- /dev/null
+++ b/include/asm-mips/rmi/msidef.h
@@ -0,0 +1,73 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef ASM_RMI_MSIDEF_H
+#define ASM_RMI_MSIDEF_H
+
+/*
+ * Constants for Intel APIC based MSI messages.
+ * Adapted for the RMI XLR using identical defines
+ */
+
+/*
+ * Shifts for MSI data
+ */
+
+#define MSI_DATA_VECTOR_SHIFT		0
+#define  MSI_DATA_VECTOR_MASK		0x000000ff
+#define	 MSI_DATA_VECTOR(v)		(((v) << MSI_DATA_VECTOR_SHIFT) & MSI_DATA_VECTOR_MASK)
+
+#define MSI_DATA_DELIVERY_MODE_SHIFT	8
+#define  MSI_DATA_DELIVERY_FIXED	(0 << MSI_DATA_DELIVERY_MODE_SHIFT)
+#define  MSI_DATA_DELIVERY_LOWPRI	(1 << MSI_DATA_DELIVERY_MODE_SHIFT)
+
+#define MSI_DATA_LEVEL_SHIFT		14
+#define	 MSI_DATA_LEVEL_DEASSERT	(0 << MSI_DATA_LEVEL_SHIFT)
+#define	 MSI_DATA_LEVEL_ASSERT		(1 << MSI_DATA_LEVEL_SHIFT)
+
+#define MSI_DATA_TRIGGER_SHIFT		15
+#define  MSI_DATA_TRIGGER_EDGE		(0 << MSI_DATA_TRIGGER_SHIFT)
+#define  MSI_DATA_TRIGGER_LEVEL		(1 << MSI_DATA_TRIGGER_SHIFT)
+
+/*
+ * Shift/mask fields for msi address
+ */
+
+#define MSI_ADDR_BASE_HI		0
+#define MSI_ADDR_BASE_LO		0xfee00000
+
+#define MSI_ADDR_DEST_MODE_SHIFT	2
+#define  MSI_ADDR_DEST_MODE_PHYSICAL	(0 << MSI_ADDR_DEST_MODE_SHIFT)
+#define	 MSI_ADDR_DEST_MODE_LOGICAL	(1 << MSI_ADDR_DEST_MODE_SHIFT)
+
+#define MSI_ADDR_REDIRECTION_SHIFT	3
+#define  MSI_ADDR_REDIRECTION_CPU	(0 << MSI_ADDR_REDIRECTION_SHIFT) /* dedicated cpu */
+#define  MSI_ADDR_REDIRECTION_LOWPRI	(1 << MSI_ADDR_REDIRECTION_SHIFT) /* lowest priority */
+
+#define MSI_ADDR_DEST_ID_SHIFT		12
+#define	 MSI_ADDR_DEST_ID_MASK		0x00ffff0
+#define  MSI_ADDR_DEST_ID(dest)		(((dest) << MSI_ADDR_DEST_ID_SHIFT) & MSI_ADDR_DEST_ID_MASK)
+
+#endif /* ASM_RMI_MSIDEF_H */
diff --git a/include/asm-mips/rmi/pci.h b/include/asm-mips/rmi/pci.h
new file mode 100644
index 0000000..c97ce1c
--- /dev/null
+++ b/include/asm-mips/rmi/pci.h
@@ -0,0 +1,38 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PCI_H
+#define _ASM_RMI_PCI_H
+
+#define RMI_PCI_VENDOR_ID            0xfecc
+#define RMI_PCI_UART_DEV_ID          2
+#define RMI_PCI_DUMMY_MAC_DEV_ID     16
+
+#endif
diff --git a/include/asm-mips/rmi/perf_ctr.h b/include/asm-mips/rmi/perf_ctr.h
new file mode 100644
index 0000000..8371148
--- /dev/null
+++ b/include/asm-mips/rmi/perf_ctr.h
@@ -0,0 +1,72 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_RMI_PERF_CTR_H
+#define __ASM_RMI_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_RMI_PERF_CTR_H */
diff --git a/include/asm-mips/rmi/phnx_cde.h b/include/asm-mips/rmi/phnx_cde.h
new file mode 100644
index 0000000..f74221d
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_cde.h
@@ -0,0 +1,165 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef _PHNX_CDE_H
+#define _PHNX_CDE_H
+
+#include <asm-mips/rmi/msgring.h>
+#include <asm-mips/io.h> 
+
+#define CMP_REG_CNFG_MSG_CREDIT_SEL 14
+#define CMP_REG_CTRL_REG         0
+#define CMP_REG_DMA_CREDITS_REG  1
+#define CMP_REG_SPILL_ADDR0_REG  2
+#define CMP_REG_SPILL_ADDR1_REG  3
+#define CMP_REG_SPILL_SIZE_REG   4
+#define CMP_REG_SPILL_BYTES_REG  5
+#define CMP_REG_CRC_ADLER_SPILL  6
+#define CMP_REG_SCRATCH_PAGE     7
+#define CMP_REG_INTERRUPT_VEC    8
+#define CMP_REG_INTERRUPT_MASK   9
+#define CMP_REG_FREE_DESC_THRES  10
+#define CMP_REG_DESC_FIFO_COUNT  11
+#define CMP_REG_RESET_REG        12
+#define CMP_REG_ERROR_RESET_MASK 13
+#define CMP_REG_READ_ERROR_LIST0 14
+#define CMP_REG_READ_ERROR_LIST1 15
+
+/* defines needed to be declared */
+#define CMP_MSG_BUCKET0_SIZE 0x320
+#define CMP_MSG_BUCKET1_SIZE 0x321
+
+
+static inline uint32_t cmp_read_reg(int reg)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_COMP_OFFSET);
+
+  return phoenix_read_reg(mmio, reg);
+}
+
+static inline void cmp_write_reg(int reg, uint32_t value)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_COMP_OFFSET);
+
+  phoenix_write_reg(mmio, reg, value);
+}
+
+static __inline__ int make_fd_msg(struct msgrng_msg *msg, void *free_addr)
+{
+  int stid = MSGRNG_STNID_CMP_0;
+
+  msg->msg0 = ( ((uint64_t)virt_to_phys(free_addr) & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+static __inline__ int make_cmp_msg(struct msgrng_msg *msg, int rtn_bkt,
+				   int op, int length, void *src_addr)
+{
+  int stid = MSGRNG_STNID_CMP_1;
+  
+  msg->msg0 = ( ((uint64_t) op << 60)  | 
+                ((uint64_t) rtn_bkt << 54) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) virt_to_phys(src_addr) & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+
+static __inline__ uint64_t make_src_desc(int eof, int type, int sod, int sob, int save,
+					 int restore, int eob, int length, void *src_addr)
+{
+  uint64_t src_desc = 0;
+  src_desc = (  ((uint64_t) eof << 63) | 
+                ((uint64_t) type << 61) |
+                ((uint64_t) sod << 60) |
+                ((uint64_t) sob << 59) |
+                ((uint64_t) save << 58) |
+                ((uint64_t) restore << 57) |
+                ((uint64_t) eob << 56) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) virt_to_phys(src_addr) & 0xffffffffffULL)
+                );
+  return src_desc;
+}
+
+static __inline__ uint64_t get_dest_desc(uint64_t dest_addr)
+{
+  uint64_t *desc;
+  desc = phys_to_virt(dest_addr);
+  return *desc;
+}
+
+static __inline__ int read_cmp_msg(char *buffer, uint64_t payload) 
+{
+  uint64_t i,j,num_bytes;
+  int offset = 0;
+  uint64_t *desc, dest_addr;
+  int num_desc = (payload >> 40) & 0x3fff;
+  char * tmp_ptr;
+
+  for (i = 0; i < num_desc; i++) {
+    desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; 
+
+    num_bytes = (*desc >> 40) & 0xffff;
+
+    dest_addr = *desc & 0xffffffffffUll;
+
+    tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
+
+    for (j = 0; j < num_bytes; j++) {
+      buffer[offset+j] = tmp_ptr[j];
+    }
+
+    offset = offset + num_bytes;
+  }
+
+  return offset;
+}
+
+
+#ifndef CDE_MAJOR
+#define CDE_MAJOR 0   /* dynamic major by default */
+#endif
+
+
+/*
+ * Split minors in two parts
+ */
+#define TYPE(minor)	(((minor) >> 4) & 0xf)	/* high nibble */
+#define NUM(minor)	((minor) & 0xf)		/* low  nibble */
+
+
+#define CDE_IOC_MAGIC  'k'
+#define CDE_IOCINFLATE _IO(CDE_IOC_MAGIC, 0)
+#define CDE_IOCDEFLATE _IO(CDE_IOC_MAGIC, 1)
+#define CDE_IOC_MAXNR  1
+
+#define CDE_INFLATE 0
+#define CDE_DEFLATE 1
+
+
+#endif /* _PHNX_CDE_H_ */
diff --git a/include/asm-mips/rmi/phnx_loader.h b/include/asm-mips/rmi/phnx_loader.h
new file mode 100644
index 0000000..7fc9b6b
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_loader.h
@@ -0,0 +1,175 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PHNX_LOADER_H
+#define _ASM_RMI_PHNX_LOADER_H
+#include <linux/list.h>
+#include <asm/rmi/memory-exclusion.h>
+
+#define PHNX_LOADER_KSEG0_VIRT_START         0x60000000
+#define PHNX_LOADER_KSEG0_START         0x0c000000
+#define PHNX_LOADER_KSEG0_SIZE         0x04000000
+
+#define PHNX_LOADER_KUSEG_VIRT_START         0x20000000
+#define PHNX_LOADER_KUSEG_PHYS_START         0x20000000ULL
+#define PHNX_LOADER_KUSEG_PHYS_SIZE          0xf000000ULL /* for 512 MB boards*/
+
+/* the below macros go together */
+#define PHNX_LOADER_PHYS_SIZE          (512<<20)
+#define PHNX_LOADER_PMASK_SIZE         (PHNX_LOADER_PHYS_SIZE >> 1)
+#define PHNX_LOADER_PMASK_SIZE_256MB   0xffff
+
+#define PHNX_LOADER_IPI_VECTOR 51
+
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI64)
+#define PTR2U64(x) (unsigned long)(x)
+#define U642PTR(x) (void *)((unsigned long)(x))
+#else
+/* preserve sign-extension */
+#define PTR2U64(x) (int)(x)
+#define U642PTR(x) (void *)((int)(x))
+#endif
+
+#define NUM_WORDS 2048
+
+#define XLR_THREAD_SIZE (NUM_WORDS * sizeof(long))
+
+#define PHNX_APP_SHMEM_MAX_SZ (512*1024*1024)
+#ifndef __ASSEMBLY__
+
+struct xlr_thread_info {
+	unsigned long stack[NUM_WORDS];
+};
+extern struct xlr_thread_info xlrthreads_info[];
+
+#endif
+
+#define PSB_MEM_MAP_MAX 32
+#define PSB_IO_MAP_MAX 32
+
+struct psb_mem_map {
+	int nr_map;
+	struct psb_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;      /* type of memory segment */
+	} map[PSB_MEM_MAP_MAX];
+};
+
+struct psb_io_map {
+	int nr_map;
+	struct psb_io_map_entry {
+		uint64_t addr;  /* start of IO segment */
+		uint64_t size;  /* size of IO segment */
+		long type;      /* type of IO segment */
+	} map[PSB_IO_MAP_MAX];
+};
+
+struct r_exception_region {
+	    unsigned int data[1024];
+};
+
+#define PKT_DATA_LEN 1592
+#define PKT_SEC_AUTH_LEN 32
+#define PKT_SEC_CTRL_DESC_LEN 128
+#define PKT_SEC_PKT_DESC_LEN 32
+
+
+struct packet {
+	/* New cacheline */
+	uint8_t data[PKT_DATA_LEN];
+	uint32_t len;
+	uint32_t seq_num;
+	/* New cacheline */
+	uint8_t sec_ctrl_desc[PKT_SEC_CTRL_DESC_LEN];
+	/* New cacheline */
+	uint8_t sec_pkt_desc[PKT_SEC_PKT_DESC_LEN];
+	/* New cacheline */
+	uint8_t sec_auth[PKT_SEC_AUTH_LEN];
+	/* New cacheline */
+	uint16_t sec_cksum;
+	uint8_t sec_cksum_padding[30];
+	/* New cacheline */
+	uint32_t sec_error;
+	uint32_t sec_op_timestamp;
+	struct list_head sec_tx_list;
+	uint16_t sec_ctrl_desc_size;
+	uint8_t padding[14];
+	/* New cacheline */
+} __attribute__ ((aligned(32)));
+
+#define dprintk(fmt, args...) 
+#define eprintk(fmt, args...) printk(fmt, ##args)
+
+#define MAX_LOADER_MEMORY_ENTRY 128
+
+#define XLR_MAX_THRDS 32
+
+#define MEM_ALLOC_REQUEST 1
+#define MEM_ALLOC_FAILED 2
+#define MEM_ALLOC_DONE 3
+#define MAX_NUM_KUSEG_BLOCKS 4
+
+struct phnx_loader_alloc_memory
+{
+	void *ptr;
+	size_t size;
+	int status;
+};
+
+struct phnx_loader_free_memory
+{
+	void *ptr;
+};
+
+struct xlr_rmios_pt_regs {
+	unsigned long long pad0[6];
+
+	unsigned long long regs[32];
+
+	unsigned long long cp0_status;
+	unsigned long long hi;
+	unsigned long long lo;
+
+	/*
+	 * saved cp0 registers
+	 */
+	unsigned long long cp0_badvaddr;
+	unsigned long long cp0_cause;
+	unsigned long long cp0_epc;
+};
+
+struct kuseg_mem_info {
+	uint64_t size;
+	uint64_t start_addr;
+};
+
+#endif
diff --git a/include/asm-mips/rmi/phnx_tb.h b/include/asm-mips/rmi/phnx_tb.h
new file mode 100644
index 0000000..10fd9d9
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_tb.h
@@ -0,0 +1,96 @@
+/*********************************************************************
+
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+
+*****************************#RMI_2#**********************************/
+#ifndef _RMI_PHOENIX_TB_H
+#define _RMI_PHOENIX_TB_H
+
+#include <linux/types.h>
+#include <asm-mips/rmi/iomap.h>
+#include <linux/phnx_tb.h>
+
+#define TB_REG_SIZE				4
+#define TB_NO_RDDATA_REGS		4
+#define TB_MAX_ENTRIES			256
+#define TB_ENTRY_SIZE		(TB_NO_RDDATA_REGS * TB_REG_SIZE)
+#define TB_SIZE				(TB_MAX_ENTRIES * TB_ENTRY_SIZE)
+
+/* ---------------------------------------------------------------------------- */
+/*                             RD/WR macros                                     */
+/* ---------------------------------------------------------------------------- */
+
+static inline unsigned int tb_read_reg_be32(unsigned int reg)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    return phoenix_read_reg(mmio, reg);
+}
+
+static inline void tb_write_reg_be32 (unsigned int reg, unsigned int value)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    phoenix_write_reg(mmio, reg, value);
+}
+
+static inline unsigned int tb_read_reg_le32 (unsigned int reg)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    return phoenix_read_reg_le32(mmio, reg);
+}
+
+static inline void tb_write_reg_le32 (unsigned int reg, unsigned int value)
+{
+    phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_TB_OFFSET);
+    phoenix_write_reg_le32(mmio, reg, value);
+}
+
+#define tb_read_status_reg() tb_read_reg_be32(TB_STATUS_REG)
+#define tb_read_ctrl_reg() tb_read_reg_be32(TB_CTRL_REG)
+
+#define tb_read_reqmatch_reg(i) tb_read_reg_be32 (TB_REQMATCH_REGS + i)
+#define tb_read_raddr_reg(i) tb_read_reg_be32 (TB_RADDR_REGS + i)
+#define tb_read_rddata_reg(i) tb_read_reg_be32 (TB_RDDATA_REGS + i)
+
+#define tb_write_ctrl_reg(val) tb_write_reg_be32 (TB_CTRL_REG, val)
+#define tb_write_reqmatch_reg(i, val) tb_write_reg_be32 ((TB_REQMATCH_REGS+i), val)
+#define tb_write_raddr_reg(i, val) tb_write_reg_be32 ((TB_RADDR_REGS+i), val)
+
+#define tb_reinit(void) {tb_write_reg_be32(TB_INIT_REG, 0x0);tb_write_reg_be32(TB_INIT_REG, 0x1);}
+#define tb_pop_entry(void) tb_write_reg_be32(TB_ACCESS_REG, 0)
+#define disable_tb()    tb_write_reg_be32(TB_CTRL_REG, 0x01000000)
+
+typedef struct _tb_dev_t {
+	unsigned int	size;
+	unsigned char   *data;
+} tb_dev_t;
+
+ssize_t	tb_read (struct file *, char *, size_t, loff_t *);
+int		tb_open (struct inode *, struct file *);
+int		tb_ioctl (struct inode *, struct file *, unsigned int, unsigned long);
+int		tb_release (struct inode *, struct file *);
+
+#endif
diff --git a/include/asm-mips/rmi/phnx_user_mac.h b/include/asm-mips/rmi/phnx_user_mac.h
new file mode 100644
index 0000000..4f9b84c
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_user_mac.h
@@ -0,0 +1,62 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PHNX_USER_MAC_H
+#define _ASM_RMI_PHNX_USER_MAC_H
+
+#define PHNX_USER_MAC_MMAP_VIRT_START 0x60000000
+#define PHNX_USER_MAC_MMAP_PHYS_START 0x0b800000
+#define PHNX_USER_MAC_MMAP_PHYS_END   0x0c000000
+
+#ifndef __ASSEMBLY__
+#include <asm/rmi/sim.h>
+
+extern void phoenix_user_mac_update_time(void);
+
+struct xlr_user_mac_config {
+	int l4_extract;
+	int fast_syscall;
+};
+
+extern struct xlr_user_mac_config xlr_user_mac;
+
+static __inline__ int xlr_user_mac_l4_extract(void)
+{
+	return xlr_hybrid_user_mac() ? xlr_user_mac.l4_extract  : 0;
+}
+
+static __inline__ int xlr_user_mac_fast_syscall(void)
+{
+	return xlr_hybrid_user_mac() && (xlr_user_mac.fast_syscall == 1);
+}
+
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/phoenix_flash_pcmcia.h b/include/asm-mips/rmi/phoenix_flash_pcmcia.h
new file mode 100644
index 0000000..4398655
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_flash_pcmcia.h
@@ -0,0 +1,116 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _FLASH_PCMCIA_H_
+#define _FLASH_PCMCIA_H_
+
+#define R_FLASH_PCMCIA_BASE_ADDR                    0x0
+#define   O_BASE_ADDR__base_addr                    0
+#define   W_BASE_ADDR__base_addr                    16
+#define R_FLASH_PCMCIA_BASE_ADDR_MASK               0x1
+#define   O_BASE_ADDR_MASK__base_amask              0
+#define   W_BASE_ADDR_MASK__base_amask              16
+#define R_FLASH_PCMCIA_DEV_PARM                     0x2
+#define   O_DEV_PARM__burst_mode_en                 0
+#define   O_DEV_PARM__burst_mode                    1
+#define   W_DEV_PARM__burst_mode                    3
+#define   O_DEV_PARM__wait_en                       4
+#define   O_DEV_PARM__wait_pol                      5
+#define   O_DEV_PARM__mx_addr                       6
+#define   O_DEV_PARM__dwidth                        7
+#define   W_DEV_PARM__dwidth                        2
+#define   O_DEV_PARM__pcmcia_en                     9
+#define   O_DEV_PARM__genif_en                      10
+#define   O_DEV_PARM__genparity_en                  11
+#define   O_DEV_PARM__genparity_type                12
+#define   O_DEV_PARM__adv_type                      13
+#define R_FLASH_TIMING_PARM_0                       0x3
+#define   O_FLASH_TIMING_PARM_0__ale_width          0
+#define   W_FLASH_TIMING_PARM_0__ale_width          3
+#define   O_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   W_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   O_FLASH_TIMING_PARM_0__cs_width           6
+#define   W_FLASH_TIMING_PARM_0__cs_width           5
+#define   O_FLASH_TIMING_PARM_0__wait_to_data       11
+#define   W_FLASH_TIMING_PARM_0__wait_to_data       5
+#define   O_FLASH_TIMING_PARM_0__cs_to_oe           16
+#define   W_FLASH_TIMING_PARM_0__cs_to_oe           3
+#define   O_FLASH_TIMING_PARM_0__cs_to_we           19
+#define   W_FLASH_TIMING_PARM_0__cs_to_we           3
+#define   O_FLASH_TIMING_PARM_0__oe_to_cs           22
+#define   W_FLASH_TIMING_PARM_0__oe_to_cs           2
+#define   O_FLASH_TIMING_PARM_0__we_to_cs           24
+#define   W_FLASH_TIMING_PARM_0__we_to_cs           4
+#define   O_FLASH_TIMING_PARM_0__cs_to_cs           28
+#define   W_FLASH_TIMING_PARM_0__cs_to_cs           4
+#define R_FLASH_TIMING_PARM_1                       0x4
+#define   O_FLASH_TIMING_PARM_1__oe_width           0
+#define   W_FLASH_TIMING_PARM_1__oe_width           6
+#define   O_FLASH_TIMING_PARM_1__we_width           6
+#define   W_FLASH_TIMING_PARM_1__we_width           6
+#define   O_FLASH_TIMING_PARM_1__wait_timeout       12
+#define   W_FLASH_TIMING_PARM_1__wait_timeout       15
+#define R_PCMCIA_CONFIG                             0x5
+#define   O_PCMCIA_CONFIG__pcmcia_en                0
+#define   O_PCMCIA_CONFIG__reg_access               1
+#define   O_PCMCIA_CONFIG__reset                    2
+#define   O_PCMCIA_CONFIG__cdmask                   4
+#define   O_PCMCIA_CONFIG__wpmask                   5
+#define   O_PCMCIA_CONFIG__rdymask                  6
+#define   O_PCMCIA_CONFIG__rybymask                 7
+#define R_PCMCIA_STATUS                             0x6
+#define   O_PCMCIA_STATUS__bvd1_sts                 0
+#define   O_PCMCIA_STATUS__bvd2_sts                 1
+#define   O_PCMCIA_STATUS__cd1_sts                  2
+#define   O_PCMCIA_STATUS__cd2_sts                  3
+#define   O_PCMCIA_STATUS__vs1_sts                  4
+#define   O_PCMCIA_STATUS__vs2_sts                  5
+#define   O_PCMCIA_STATUS__wp_sts                   6
+#define   O_PCMCIA_STATUS__rdy_sts                  7
+#define   O_PCMCIA_STATUS__ryby_sts                 8
+#define   O_PCMCIA_STATUS__cd_intr                  9
+#define   O_PCMCIA_STATUS__wp_intr                  10
+#define   O_PCMCIA_STATUS__rdy_intr                 11
+#define   O_PCMCIA_STATUS__illegal_addr_intrpt      12
+#define   O_PCMCIA_STATUS__mutl_cs_intrpt           13
+#define   O_PCMCIA_STATUS__wait_timeout_intrpt      14
+#define   O_PCMCIA_STATUS__ryby_intrpt              16
+#define   O_PCMCIA_STATUS__werr_intrpt              17
+#define   O_PCMCIA_STATUS__illegal_pcmcia_intrpt    18
+#define R_GENERIC_REGION_STATUS                     0x7
+#define   O_GENERIC_REGION_STATUS__cs_err_intrpt    0
+#define   W_GENERIC_REGION_STATUS__cs_err_intrpt    8
+#define R_GENERIC_ERROR_ADDR                        0x8
+#define   O_GENERIC_ERROR_ADDR__err_addr            0
+#define   W_GENERIC_ERROR_ADDR__err_addr            32
+
+
+#endif /* _FLASH_PCMCIA_H_ */
+
diff --git a/include/asm-mips/rmi/phoenix_ide.h b/include/asm-mips/rmi/phoenix_ide.h
new file mode 100644
index 0000000..1100bf0
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_ide.h
@@ -0,0 +1,62 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_PHOENIX_H
+#define __ASM_PHOENIX_H
+
+
+#define  CONFIG_PHOENIX 1
+
+#ifdef CONFIG_PHOENIX
+#define PHOENIX_BOARD_NAME "PHOENIX -ATX1"
+#define PHOENIX_HAVE_PCMCIA 0
+#define PHOENIX_HAVE_IDE    1
+#endif
+
+
+#ifdef PHOENIX_HAVE_IDE
+#define IDE_CS          6
+#define IDE_PHYS        0x1D000000
+#define K_GPIO_GB_IDE   4
+#define K_GPIO_PC_READY 11 
+#define K_INT_GPIO_0    32 
+#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
+#endif
+
+#ifdef PHOENIX_HAVE_PCMCIA
+#define PCMCIA_CS       4
+#define PCMCIA_PHYS     0x11000000
+#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
+#endif
+
+
+#define IOADDR(a) (UNCAC_BASE + (a))
+
+#endif /* __ASM_PHOENIX_H */
diff --git a/include/asm-mips/rmi/phoenix_mac.h b/include/asm-mips/rmi/phoenix_mac.h
new file mode 100644
index 0000000..b54809b
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_mac.h
@@ -0,0 +1,1149 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MAC_H
+#define _ASM_RMI_MAC_H
+
+#include <linux/types.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <linux/skbuff.h>
+#include <asm/rmi/phoenix_sec.h>
+#define IPSEC_PACKET_PAYLOAD_SIZE 1696
+#define PHXSEC_HMAC_LENGTH 64
+#define SKBUF_HEAD (32 * 2)    /* 2 cachelines reserved before payload */
+
+#define MAC_SPACING                 0x400
+#define XGMAC_SPACING               0x400
+
+/* PE-MCXMAC register and bit field definitions */
+#define R_MAC_CONFIG_1                                              0x00
+#define   O_MAC_CONFIG_1__srst                                      31
+#define   O_MAC_CONFIG_1__simr                                      30
+#define   O_MAC_CONFIG_1__hrrmc                                     18
+#define   W_MAC_CONFIG_1__hrtmc                                      2
+#define   O_MAC_CONFIG_1__hrrfn                                     16
+#define   W_MAC_CONFIG_1__hrtfn                                      2
+#define   O_MAC_CONFIG_1__intlb                                      8
+#define   O_MAC_CONFIG_1__rxfc                                       5
+#define   O_MAC_CONFIG_1__txfc                                       4
+#define   O_MAC_CONFIG_1__srxen                                      3
+#define   O_MAC_CONFIG_1__rxen                                       2
+#define   O_MAC_CONFIG_1__stxen                                      1
+#define   O_MAC_CONFIG_1__txen                                       0
+#define R_MAC_CONFIG_2                                              0x01
+#define   O_MAC_CONFIG_2__prlen                                     12
+#define   W_MAC_CONFIG_2__prlen                                      4
+#define   O_MAC_CONFIG_2__speed                                      8
+#define   W_MAC_CONFIG_2__speed                                      2
+#define   O_MAC_CONFIG_2__hugen                                      5
+#define   O_MAC_CONFIG_2__flchk                                      4
+#define   O_MAC_CONFIG_2__crce                                       1
+#define   O_MAC_CONFIG_2__fulld                                      0
+#define R_IPG_IFG                                                   0x02
+#define   O_IPG_IFG__ipgr1                                          24
+#define   W_IPG_IFG__ipgr1                                           7
+#define   O_IPG_IFG__ipgr2                                          16
+#define   W_IPG_IFG__ipgr2                                           7
+#define   O_IPG_IFG__mifg                                            8
+#define   W_IPG_IFG__mifg                                            8
+#define   O_IPG_IFG__ipgt                                            0
+#define   W_IPG_IFG__ipgt                                            7
+#define R_HALF_DUPLEX                                               0x03
+#define   O_HALF_DUPLEX__abebt                                      24
+#define   W_HALF_DUPLEX__abebt                                       4
+#define   O_HALF_DUPLEX__abebe                                      19
+#define   O_HALF_DUPLEX__bpnb                                       18
+#define   O_HALF_DUPLEX__nobo                                       17
+#define   O_HALF_DUPLEX__edxsdfr                                    16
+#define   O_HALF_DUPLEX__retry                                      12
+#define   W_HALF_DUPLEX__retry                                       4
+#define   O_HALF_DUPLEX__lcol                                        0
+#define   W_HALF_DUPLEX__lcol                                       10
+#define R_MAXIMUM_FRAME_LENGTH                                      0x04
+#define   O_MAXIMUM_FRAME_LENGTH__maxf                               0
+#define   W_MAXIMUM_FRAME_LENGTH__maxf                              16
+#define R_TEST                                                      0x07
+#define   O_TEST__mbof                                               3
+#define   O_TEST__rthdf                                              2
+#define   O_TEST__tpause                                             1
+#define   O_TEST__sstct                                              0
+#define R_MII_MGMT_CONFIG                                           0x08
+#define   O_MII_MGMT_CONFIG__scinc                                   5
+#define   O_MII_MGMT_CONFIG__spre                                    4
+#define   O_MII_MGMT_CONFIG__clks                                    3
+#define   W_MII_MGMT_CONFIG__clks                                    3
+#define R_MII_MGMT_COMMAND                                          0x09
+#define   O_MII_MGMT_COMMAND__scan                                   1
+#define   O_MII_MGMT_COMMAND__rstat                                  0
+#define R_MII_MGMT_ADDRESS                                          0x0A
+#define   O_MII_MGMT_ADDRESS__fiad                                   8
+#define   W_MII_MGMT_ADDRESS__fiad                                   5
+#define   O_MII_MGMT_ADDRESS__fgad                                   5
+#define   W_MII_MGMT_ADDRESS__fgad                                   0
+#define R_MII_MGMT_WRITE_DATA                                       0x0B
+#define   O_MII_MGMT_WRITE_DATA__ctld                                0
+#define   W_MII_MGMT_WRITE_DATA__ctld                               16
+#define R_MII_MGMT_STATUS                                           0x0C
+#define R_MII_MGMT_INDICATORS                                       0x0D
+#define   O_MII_MGMT_INDICATORS__nvalid                              2
+#define   O_MII_MGMT_INDICATORS__scan                                1
+#define   O_MII_MGMT_INDICATORS__busy                                0
+#define R_INTERFACE_CONTROL                                         0x0E
+#define   O_INTERFACE_CONTROL__hrstint                              31
+#define   O_INTERFACE_CONTROL__tbimode                              27
+#define   O_INTERFACE_CONTROL__ghdmode                              26
+#define   O_INTERFACE_CONTROL__lhdmode                              25
+#define   O_INTERFACE_CONTROL__phymod                               24
+#define   O_INTERFACE_CONTROL__hrrmi                                23
+#define   O_INTERFACE_CONTROL__rspd                                 16
+#define   O_INTERFACE_CONTROL__hr100                                15
+#define   O_INTERFACE_CONTROL__frcq                                 10
+#define   O_INTERFACE_CONTROL__nocfr                                 9
+#define   O_INTERFACE_CONTROL__dlfct                                 8
+#define   O_INTERFACE_CONTROL__enjab                                 0
+#define R_INTERFACE_STATUS                                         0x0F
+#define   O_INTERFACE_STATUS__xsdfr                                  9
+#define   O_INTERFACE_STATUS__ssrr                                   8
+#define   W_INTERFACE_STATUS__ssrr                                   5
+#define   O_INTERFACE_STATUS__miilf                                  3
+#define   O_INTERFACE_STATUS__locar                                  2
+#define   O_INTERFACE_STATUS__sqerr                                  1
+#define   O_INTERFACE_STATUS__jabber                                 0
+#define R_STATION_ADDRESS_LS                                       0x10
+#define R_STATION_ADDRESS_MS                                       0x11
+
+/* A-XGMAC register and bit field definitions */
+#define R_XGMAC_CONFIG_0    0x00
+#define   O_XGMAC_CONFIG_0__hstmacrst               31
+#define   O_XGMAC_CONFIG_0__hstrstrctl              23
+#define   O_XGMAC_CONFIG_0__hstrstrfn               22
+#define   O_XGMAC_CONFIG_0__hstrsttctl              18
+#define   O_XGMAC_CONFIG_0__hstrsttfn               17
+#define   O_XGMAC_CONFIG_0__hstrstmiim              16
+#define   O_XGMAC_CONFIG_0__hstloopback             8
+#define R_XGMAC_CONFIG_1    0x01
+#define   O_XGMAC_CONFIG_1__hsttctlen               31
+#define   O_XGMAC_CONFIG_1__hsttfen                 30
+#define   O_XGMAC_CONFIG_1__hstrctlen               29
+#define   O_XGMAC_CONFIG_1__hstrfen                 28
+#define   O_XGMAC_CONFIG_1__tfen                    26
+#define   O_XGMAC_CONFIG_1__rfen                    24
+#define   O_XGMAC_CONFIG_1__hstrctlshrtp            12
+#define   O_XGMAC_CONFIG_1__hstdlyfcstx             10
+#define   W_XGMAC_CONFIG_1__hstdlyfcstx              2
+#define   O_XGMAC_CONFIG_1__hstdlyfcsrx              8
+#define   W_XGMAC_CONFIG_1__hstdlyfcsrx              2
+#define   O_XGMAC_CONFIG_1__hstppen                  7
+#define   O_XGMAC_CONFIG_1__hstbytswp                6
+#define   O_XGMAC_CONFIG_1__hstdrplt64               5
+#define   O_XGMAC_CONFIG_1__hstprmscrx               4
+#define   O_XGMAC_CONFIG_1__hstlenchk                3
+#define   O_XGMAC_CONFIG_1__hstgenfcs                2
+#define   O_XGMAC_CONFIG_1__hstpadmode               0
+#define   W_XGMAC_CONFIG_1__hstpadmode               2
+#define R_XGMAC_CONFIG_2    0x02
+#define   O_XGMAC_CONFIG_2__hsttctlfrcp             31
+#define   O_XGMAC_CONFIG_2__hstmlnkflth             27
+#define   O_XGMAC_CONFIG_2__hstalnkflth             26
+#define   O_XGMAC_CONFIG_2__rflnkflt                24
+#define   W_XGMAC_CONFIG_2__rflnkflt                 2                          
+#define   O_XGMAC_CONFIG_2__hstipgextmod            16
+#define   W_XGMAC_CONFIG_2__hstipgextmod             5
+#define   O_XGMAC_CONFIG_2__hstrctlfrcp             15
+#define   O_XGMAC_CONFIG_2__hstipgexten              5
+#define   O_XGMAC_CONFIG_2__hstmipgext               0
+#define   W_XGMAC_CONFIG_2__hstmipgext               5
+#define R_XGMAC_CONFIG_3    0x03
+#define   O_XGMAC_CONFIG_3__hstfltrfrm              31
+#define   W_XGMAC_CONFIG_3__hstfltrfrm              16
+#define   O_XGMAC_CONFIG_3__hstfltrfrmdc            15
+#define   W_XGMAC_CONFIG_3__hstfltrfrmdc            16
+#define R_XGMAC_STATION_ADDRESS_LS      0x04
+#define   O_XGMAC_STATION_ADDRESS_LS__hstmacadr0    0
+#define   W_XGMAC_STATION_ADDRESS_LS__hstmacadr0    32
+#define R_XGMAC_STATION_ADDRESS_MS      0x05
+#define R_XGMAC_MAX_FRAME_LEN           0x08
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       16
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       14
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx        0
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx       16
+#define R_XGMAC_REV_LEVEL               0x0B
+#define   O_XGMAC_REV_LEVEL__revlvl                  0
+#define   W_XGMAC_REV_LEVEL__revlvl                 15
+#define R_XGMAC_MIIM_COMMAND            0x10
+#define   O_XGMAC_MIIM_COMMAND__hstldcmd             3
+#define   O_XGMAC_MIIM_COMMAND__hstmiimcmd           0
+#define   W_XGMAC_MIIM_COMMAND__hstmiimcmd           3
+#define R_XGMAC_MIIM_FILED              0x11
+#define   O_XGMAC_MIIM_FILED__hststfield            30
+#define   W_XGMAC_MIIM_FILED__hststfield             2
+#define   O_XGMAC_MIIM_FILED__hstopfield            28
+#define   W_XGMAC_MIIM_FILED__hstopfield             2
+#define   O_XGMAC_MIIM_FILED__hstphyadx             23
+#define   W_XGMAC_MIIM_FILED__hstphyadx              5
+#define   O_XGMAC_MIIM_FILED__hstregadx             18
+#define   W_XGMAC_MIIM_FILED__hstregadx              5
+#define   O_XGMAC_MIIM_FILED__hsttafield            16
+#define   W_XGMAC_MIIM_FILED__hsttafield             2
+#define   O_XGMAC_MIIM_FILED__miimrddat              0
+#define   W_XGMAC_MIIM_FILED__miimrddat             16
+#define R_XGMAC_MIIM_CONFIG             0x12
+#define   O_XGMAC_MIIM_CONFIG__hstnopram             7
+#define   O_XGMAC_MIIM_CONFIG__hstclkdiv             0
+#define   W_XGMAC_MIIM_CONFIG__hstclkdiv             7
+#define R_XGMAC_MIIM_LINK_FAIL_VECTOR   0x13
+#define   O_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec   0
+#define   W_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec  32
+#define R_XGMAC_MIIM_INDICATOR          0x14
+#define   O_XGMAC_MIIM_INDICATOR__miimphylf          4
+#define   O_XGMAC_MIIM_INDICATOR__miimmoncplt        3
+#define   O_XGMAC_MIIM_INDICATOR__miimmonvld         2
+#define   O_XGMAC_MIIM_INDICATOR__miimmon            1
+#define   O_XGMAC_MIIM_INDICATOR__miimbusy           0
+
+/* Glue logic register and bit field definitions */
+#define R_MAC_ADDR0                                                 0x50
+#define R_MAC_ADDR1                                                 0x52
+#define R_MAC_ADDR2                                                 0x54
+#define R_MAC_ADDR3                                                 0x56
+#define R_MAC_ADDR_MASK2                                            0x58
+#define R_MAC_ADDR_MASK3                                            0x5A
+#define R_MAC_FILTER_CONFIG                                         0x5C
+#define   O_MAC_FILTER_CONFIG__BROADCAST_EN                         10
+#define   O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN                       9
+#define   O_MAC_FILTER_CONFIG__ALL_MCAST_EN                         8
+#define   O_MAC_FILTER_CONFIG__ALL_UCAST_EN                         7
+#define   O_MAC_FILTER_CONFIG__HASH_MCAST_EN                        6
+#define   O_MAC_FILTER_CONFIG__HASH_UCAST_EN                        5
+#define   O_MAC_FILTER_CONFIG__ADDR_MATCH_DISC                      4
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR3_VALID                      3
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR2_VALID                      2
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR1_VALID                      1
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID                      0
+#define R_HASH_TABLE_VECTOR                                         0x30
+#define R_TX_CONTROL                                                 0x0A0
+#define   O_TX_CONTROL__Tx15Halt                                     31
+#define   O_TX_CONTROL__Tx14Halt                                     30
+#define   O_TX_CONTROL__Tx13Halt                                     29
+#define   O_TX_CONTROL__Tx12Halt                                     28
+#define   O_TX_CONTROL__Tx11Halt                                     27
+#define   O_TX_CONTROL__Tx10Halt                                     26
+#define   O_TX_CONTROL__Tx9Halt                                      25
+#define   O_TX_CONTROL__Tx8Halt                                      24
+#define   O_TX_CONTROL__Tx7Halt                                      23
+#define   O_TX_CONTROL__Tx6Halt                                      22
+#define   O_TX_CONTROL__Tx5Halt                                      21
+#define   O_TX_CONTROL__Tx4Halt                                      20
+#define   O_TX_CONTROL__Tx3Halt                                      19
+#define   O_TX_CONTROL__Tx2Halt                                      18
+#define   O_TX_CONTROL__Tx1Halt                                      17
+#define   O_TX_CONTROL__Tx0Halt                                      16
+#define   O_TX_CONTROL__TxIdle                                       15
+#define   O_TX_CONTROL__TxEnable                                     14
+#define   O_TX_CONTROL__TxThreshold                                  0
+#define   W_TX_CONTROL__TxThreshold                                  14
+#define R_RX_CONTROL                                                 0x0A1
+#define   O_RX_CONTROL__RGMII                                        10
+#define   O_RX_CONTROL__RxHalt                                       1
+#define   O_RX_CONTROL__RxEnable                                     0
+#define R_DESC_PACK_CTRL                                            0x0A2
+#define   O_DESC_PACK_CTRL__ByteOffset                              17
+#define   W_DESC_PACK_CTRL__ByteOffset                              3
+#define   O_DESC_PACK_CTRL__PrePadEnable                            16
+#define   O_DESC_PACK_CTRL__MaxEntry                                14
+#define   W_DESC_PACK_CTRL__MaxEntry                                2
+#define   O_DESC_PACK_CTRL__RegularSize                             0
+#define   W_DESC_PACK_CTRL__RegularSize                             14
+#define R_STATCTRL                                                  0x0A3
+#define   O_STATCTRL__OverFlowEn                                    4
+#define   O_STATCTRL__GIG                                           3
+#define   O_STATCTRL__Sten                                          2
+#define   O_STATCTRL__ClrCnt                                        1
+#define   O_STATCTRL__AutoZ                                         0
+#define R_L2ALLOCCTRL                                               0x0A4
+#define   O_L2ALLOCCTRL__TxL2Allocate                               9
+#define   W_L2ALLOCCTRL__TxL2Allocate                               9
+#define   O_L2ALLOCCTRL__RxL2Allocate                               0
+#define   W_L2ALLOCCTRL__RxL2Allocate                               9
+#define R_INTMASK                                                   0x0A5
+#define   O_INTMASK__Spi4TxError                                     28
+#define   O_INTMASK__Spi4RxError                                     27
+#define   O_INTMASK__RGMIIHalfDupCollision                           27
+#define   O_INTMASK__Abort                                           26
+#define   O_INTMASK__Underrun                                        25
+#define   O_INTMASK__DiscardPacket                                   24
+#define   O_INTMASK__AsyncFifoFull                                   23
+#define   O_INTMASK__TagFull                                         22
+#define   O_INTMASK__Class3Full                                      21
+#define   O_INTMASK__C3EarlyFull                                     20
+#define   O_INTMASK__Class2Full                                      19
+#define   O_INTMASK__C2EarlyFull                                     18
+#define   O_INTMASK__Class1Full                                      17
+#define   O_INTMASK__C1EarlyFull                                     16
+#define   O_INTMASK__Class0Full                                      15
+#define   O_INTMASK__C0EarlyFull                                     14
+#define   O_INTMASK__RxDataFull                                      13
+#define   O_INTMASK__RxEarlyFull                                     12
+#define   O_INTMASK__RFreeEmpty                                      9
+#define   O_INTMASK__RFEarlyEmpty                                    8
+#define   O_INTMASK__P2PSpillEcc                                     7
+#define   O_INTMASK__FreeDescFull                                    5
+#define   O_INTMASK__FreeEarlyFull                                   4
+#define   O_INTMASK__TxFetchError                                    3
+#define   O_INTMASK__StatCarry                                       2
+#define   O_INTMASK__MDInt                                           1
+#define   O_INTMASK__TxIllegal                                       0
+#define R_INTREG                                                    0x0A6
+#define   O_INTREG__Spi4TxError                                     28
+#define   O_INTREG__Spi4RxError                                     27
+#define   O_INTREG__RGMIIHalfDupCollision                           27
+#define   O_INTREG__Abort                                           26
+#define   O_INTREG__Underrun                                        25
+#define   O_INTREG__DiscardPacket                                   24
+#define   O_INTREG__AsyncFifoFull                                   23
+#define   O_INTREG__TagFull                                         22
+#define   O_INTREG__Class3Full                                      21
+#define   O_INTREG__C3EarlyFull                                     20
+#define   O_INTREG__Class2Full                                      19
+#define   O_INTREG__C2EarlyFull                                     18
+#define   O_INTREG__Class1Full                                      17
+#define   O_INTREG__C1EarlyFull                                     16
+#define   O_INTREG__Class0Full                                      15
+#define   O_INTREG__C0EarlyFull                                     14
+#define   O_INTREG__RxDataFull                                      13
+#define   O_INTREG__RxEarlyFull                                     12
+#define   O_INTREG__RFreeEmpty                                      9
+#define   O_INTREG__RFEarlyEmpty                                    8
+#define   O_INTREG__P2PSpillEcc                                     7
+#define   O_INTREG__FreeDescFull                                    5
+#define   O_INTREG__FreeEarlyFull                                   4
+#define   O_INTREG__TxFetchError                                    3
+#define   O_INTREG__StatCarry                                       2
+#define   O_INTREG__MDInt                                           1
+#define   O_INTREG__TxIllegal                                       0
+#define R_TXRETRY                                                   0x0A7
+#define   O_TXRETRY__CollisionRetry                                 6
+#define   O_TXRETRY__BusErrorRetry                                  5
+#define   O_TXRETRY__UnderRunRetry                                  4
+#define   O_TXRETRY__Retries                                        0
+#define   W_TXRETRY__Retries                                        4
+#define R_CORECONTROL                                               0x0A8
+#define   O_CORECONTROL__ErrorThread                                4
+#define   W_CORECONTROL__ErrorThread                                7
+#define   O_CORECONTROL__Shutdown                                   2
+#define   O_CORECONTROL__Speed                                      0
+#define   W_CORECONTROL__Speed                                      2
+#define R_BYTEOFFSET0                                               0x0A9
+#define R_BYTEOFFSET1                                               0x0AA
+#define R_L2TYPE_0                                                  0x0F0
+#define   O_L2TYPE__ExtraHdrProtoSize                               26
+#define   W_L2TYPE__ExtraHdrProtoSize                               5
+#define   O_L2TYPE__ExtraHdrProtoOffset                             20
+#define   W_L2TYPE__ExtraHdrProtoOffset                             6
+#define   O_L2TYPE__ExtraHeaderSize                                 14
+#define   W_L2TYPE__ExtraHeaderSize                                 6
+#define   O_L2TYPE__ProtoOffset                                     8
+#define   W_L2TYPE__ProtoOffset                                     6
+#define   O_L2TYPE__L2HdrOffset                                     2
+#define   W_L2TYPE__L2HdrOffset                                     6
+#define   O_L2TYPE__L2Proto                                         0
+#define   W_L2TYPE__L2Proto                                         2
+#define R_L2TYPE_1                                                  0xF0
+#define R_L2TYPE_2                                                  0xF0
+#define R_L2TYPE_3                                                  0xF0
+#define R_PARSERCONFIGREG                                           0x100
+#define   O_PARSERCONFIGREG__CRCHashPoly                            8
+#define   W_PARSERCONFIGREG__CRCHashPoly                            7
+#define   O_PARSERCONFIGREG__PrePadOffset                           4
+#define   W_PARSERCONFIGREG__PrePadOffset                           4
+#define   O_PARSERCONFIGREG__UseCAM                                 2
+#define   O_PARSERCONFIGREG__UseHASH                                1
+#define   O_PARSERCONFIGREG__UseProto                               0
+#define R_L3CTABLE                                                  0x140
+#define   O_L3CTABLE__Offset0                                       25
+#define   W_L3CTABLE__Offset0                                       7
+#define   O_L3CTABLE__Len0                                          21
+#define   W_L3CTABLE__Len0                                          4
+#define   O_L3CTABLE__Offset1                                       14
+#define   W_L3CTABLE__Offset1                                       7
+#define   O_L3CTABLE__Len1                                          10
+#define   W_L3CTABLE__Len1                                          4
+#define   O_L3CTABLE__Offset2                                       4
+#define   W_L3CTABLE__Offset2                                       6
+#define   O_L3CTABLE__Len2                                          0
+#define   W_L3CTABLE__Len2                                          4
+#define   O_L3CTABLE__L3HdrOffset                                   26
+#define   W_L3CTABLE__L3HdrOffset                                   6
+#define   O_L3CTABLE__L4ProtoOffset                                 20
+#define   W_L3CTABLE__L4ProtoOffset                                 6
+#define   O_L3CTABLE__IPChksumCompute                               19
+#define   O_L3CTABLE__L4Classify                                    18
+#define   O_L3CTABLE__L2Proto                                       16
+#define   W_L3CTABLE__L2Proto                                       2
+#define   O_L3CTABLE__L3ProtoKey                                    0
+#define   W_L3CTABLE__L3ProtoKey                                    16
+#define R_L4CTABLE                                                  0x160
+#define   O_L4CTABLE__Offset0                                       21
+#define   W_L4CTABLE__Offset0                                       6
+#define   O_L4CTABLE__Len0                                          17
+#define   W_L4CTABLE__Len0                                          4
+#define   O_L4CTABLE__Offset1                                       11
+#define   W_L4CTABLE__Offset1                                       6
+#define   O_L4CTABLE__Len1                                          7
+#define   W_L4CTABLE__Len1                                          4
+#define   O_L4CTABLE__TCPChksumEnable                               0
+#define R_CAM4X128TABLE                                             0x172
+#define   O_CAM4X128TABLE__ClassId                                  7
+#define   W_CAM4X128TABLE__ClassId                                  2
+#define   O_CAM4X128TABLE__BucketId                                 1
+#define   W_CAM4X128TABLE__BucketId                                 6
+#define   O_CAM4X128TABLE__UseBucket                                0
+#define R_CAM4X128KEY                                               0x180
+#define R_TRANSLATETABLE                                            0x1A0
+#define R_DMACR0                                                    0x200
+#define   O_DMACR0__Data0WrMaxCr                                    27
+#define   W_DMACR0__Data0WrMaxCr                                    3
+#define   O_DMACR0__Data0RdMaxCr                                    24
+#define   W_DMACR0__Data0RdMaxCr                                    3
+#define   O_DMACR0__Data1WrMaxCr                                    21
+#define   W_DMACR0__Data1WrMaxCr                                    3
+#define   O_DMACR0__Data1RdMaxCr                                    18
+#define   W_DMACR0__Data1RdMaxCr                                    3
+#define   O_DMACR0__Data2WrMaxCr                                    15
+#define   W_DMACR0__Data2WrMaxCr                                    3
+#define   O_DMACR0__Data2RdMaxCr                                    12
+#define   W_DMACR0__Data2RdMaxCr                                    3
+#define   O_DMACR0__Data3WrMaxCr                                    9
+#define   W_DMACR0__Data3WrMaxCr                                    3
+#define   O_DMACR0__Data3RdMaxCr                                    6
+#define   W_DMACR0__Data3RdMaxCr                                    3
+#define   O_DMACR0__Data4WrMaxCr                                    3
+#define   W_DMACR0__Data4WrMaxCr                                    3
+#define   O_DMACR0__Data4RdMaxCr                                    0
+#define   W_DMACR0__Data4RdMaxCr                                    3
+#define R_DMACR1                                                    0x201
+#define   O_DMACR1__Data5WrMaxCr                                    27
+#define   W_DMACR1__Data5WrMaxCr                                    3
+#define   O_DMACR1__Data5RdMaxCr                                    24
+#define   W_DMACR1__Data5RdMaxCr                                    3
+#define   O_DMACR1__Data6WrMaxCr                                    21
+#define   W_DMACR1__Data6WrMaxCr                                    3
+#define   O_DMACR1__Data6RdMaxCr                                    18
+#define   W_DMACR1__Data6RdMaxCr                                    3
+#define   O_DMACR1__Data7WrMaxCr                                    15
+#define   W_DMACR1__Data7WrMaxCr                                    3
+#define   O_DMACR1__Data7RdMaxCr                                    12
+#define   W_DMACR1__Data7RdMaxCr                                    3
+#define   O_DMACR1__Data8WrMaxCr                                    9
+#define   W_DMACR1__Data8WrMaxCr                                    3
+#define   O_DMACR1__Data8RdMaxCr                                    6
+#define   W_DMACR1__Data8RdMaxCr                                    3
+#define   O_DMACR1__Data9WrMaxCr                                    3
+#define   W_DMACR1__Data9WrMaxCr                                    3
+#define   O_DMACR1__Data9RdMaxCr                                    0
+#define   W_DMACR1__Data9RdMaxCr                                    3
+#define R_DMACR2                                                    0x202
+#define   O_DMACR2__Data10WrMaxCr                                   27
+#define   W_DMACR2__Data10WrMaxCr                                   3
+#define   O_DMACR2__Data10RdMaxCr                                   24
+#define   W_DMACR2__Data10RdMaxCr                                   3
+#define   O_DMACR2__Data11WrMaxCr                                   21
+#define   W_DMACR2__Data11WrMaxCr                                   3
+#define   O_DMACR2__Data11RdMaxCr                                   18
+#define   W_DMACR2__Data11RdMaxCr                                   3
+#define   O_DMACR2__Data12WrMaxCr                                   15
+#define   W_DMACR2__Data12WrMaxCr                                   3
+#define   O_DMACR2__Data12RdMaxCr                                   12
+#define   W_DMACR2__Data12RdMaxCr                                   3
+#define   O_DMACR2__Data13WrMaxCr                                   9
+#define   W_DMACR2__Data13WrMaxCr                                   3
+#define   O_DMACR2__Data13RdMaxCr                                   6
+#define   W_DMACR2__Data13RdMaxCr                                   3
+#define   O_DMACR2__Data14WrMaxCr                                   3
+#define   W_DMACR2__Data14WrMaxCr                                   3
+#define   O_DMACR2__Data14RdMaxCr                                   0
+#define   W_DMACR2__Data14RdMaxCr                                   3
+#define R_DMACR3                                                    0x203
+#define   O_DMACR3__Data15WrMaxCr                                   27
+#define   W_DMACR3__Data15WrMaxCr                                   3
+#define   O_DMACR3__Data15RdMaxCr                                   24
+#define   W_DMACR3__Data15RdMaxCr                                   3
+#define   O_DMACR3__SpClassWrMaxCr                                  21
+#define   W_DMACR3__SpClassWrMaxCr                                  3
+#define   O_DMACR3__SpClassRdMaxCr                                  18
+#define   W_DMACR3__SpClassRdMaxCr                                  3
+#define   O_DMACR3__JumFrInWrMaxCr                                  15
+#define   W_DMACR3__JumFrInWrMaxCr                                  3
+#define   O_DMACR3__JumFrInRdMaxCr                                  12
+#define   W_DMACR3__JumFrInRdMaxCr                                  3
+#define   O_DMACR3__RegFrInWrMaxCr                                  9
+#define   W_DMACR3__RegFrInWrMaxCr                                  3
+#define   O_DMACR3__RegFrInRdMaxCr                                  6
+#define   W_DMACR3__RegFrInRdMaxCr                                  3
+#define   O_DMACR3__FrOutWrMaxCr                                    3
+#define   W_DMACR3__FrOutWrMaxCr                                    3
+#define   O_DMACR3__FrOutRdMaxCr                                    0
+#define   W_DMACR3__FrOutRdMaxCr                                    3
+#define R_REG_FRIN_SPILL_MEM_START_0                                0x204
+#define   O_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0        0
+#define   W_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0       32
+#define R_REG_FRIN_SPILL_MEM_START_1                                0x205
+#define   O_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        0
+#define   W_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        3
+#define R_REG_FRIN_SPILL_MEM_SIZE                                   0x206
+#define   O_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize             0
+#define   W_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize            32
+#define R_FROUT_SPILL_MEM_START_0                                   0x207
+#define   O_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0             0
+#define   W_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0            32
+#define R_FROUT_SPILL_MEM_START_1                                   0x208
+#define   O_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             0
+#define   W_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             3
+#define R_FROUT_SPILL_MEM_SIZE                                      0x209
+#define   O_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                  0
+#define   W_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                 32
+#define R_CLASS0_SPILL_MEM_START_0                                  0x20A
+#define   O_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0           0
+#define   W_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0          32
+#define R_CLASS0_SPILL_MEM_START_1                                  0x20B
+#define   O_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           0
+#define   W_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           3
+#define R_CLASS0_SPILL_MEM_SIZE                                     0x20C
+#define   O_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize                0
+#define   W_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize               32
+#define R_JUMFRIN_SPILL_MEM_START_0                                 0x20D
+#define   O_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0          0
+#define   W_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0         32
+#define R_JUMFRIN_SPILL_MEM_START_1                                 0x20E
+#define   O_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         0
+#define   W_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         3
+#define R_JUMFRIN_SPILL_MEM_SIZE                                    0x20F
+#define   O_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize              0
+#define   W_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize             32
+#define R_CLASS1_SPILL_MEM_START_0                                  0x210
+#define   O_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0           0
+#define   W_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0          32
+#define R_CLASS1_SPILL_MEM_START_1                                  0x211
+#define   O_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           0
+#define   W_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           3
+#define R_CLASS1_SPILL_MEM_SIZE                                     0x212
+#define   O_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize                0
+#define   W_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize               32
+#define R_CLASS2_SPILL_MEM_START_0                                  0x213
+#define   O_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0           0
+#define   W_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0          32
+#define R_CLASS2_SPILL_MEM_START_1                                  0x214
+#define   O_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           0
+#define   W_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           3
+#define R_CLASS2_SPILL_MEM_SIZE                                     0x215
+#define   O_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize                0
+#define   W_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize               32
+#define R_CLASS3_SPILL_MEM_START_0                                  0x216
+#define   O_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0           0
+#define   W_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0          32
+#define R_CLASS3_SPILL_MEM_START_1                                  0x217
+#define   O_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           0
+#define   W_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           3
+#define R_CLASS3_SPILL_MEM_SIZE                                     0x218
+#define   O_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize                0
+#define   W_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize               32
+#define R_REG_FRIN1_SPILL_MEM_START_0                               0x219
+#define R_REG_FRIN1_SPILL_MEM_START_1                               0x21a
+#define R_REG_FRIN1_SPILL_MEM_SIZE                                  0x21b
+#define R_SPIHNGY0                                                  0x219
+#define   O_SPIHNGY0__EG_HNGY_THRESH_0                              24
+#define   W_SPIHNGY0__EG_HNGY_THRESH_0                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_1                              16
+#define   W_SPIHNGY0__EG_HNGY_THRESH_1                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_2                              8
+#define   W_SPIHNGY0__EG_HNGY_THRESH_2                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_3                              0
+#define   W_SPIHNGY0__EG_HNGY_THRESH_3                              7
+#define R_SPIHNGY1                                                  0x21A
+#define   O_SPIHNGY1__EG_HNGY_THRESH_4                              24
+#define   W_SPIHNGY1__EG_HNGY_THRESH_4                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_5                              16
+#define   W_SPIHNGY1__EG_HNGY_THRESH_5                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_6                              8
+#define   W_SPIHNGY1__EG_HNGY_THRESH_6                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_7                              0
+#define   W_SPIHNGY1__EG_HNGY_THRESH_7                              7
+#define R_SPIHNGY2                                                  0x21B
+#define   O_SPIHNGY2__EG_HNGY_THRESH_8                              24
+#define   W_SPIHNGY2__EG_HNGY_THRESH_8                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_9                              16
+#define   W_SPIHNGY2__EG_HNGY_THRESH_9                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_10                             8
+#define   W_SPIHNGY2__EG_HNGY_THRESH_10                             7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_11                             0
+#define   W_SPIHNGY2__EG_HNGY_THRESH_11                             7
+#define R_SPIHNGY3                                                  0x21C
+#define   O_SPIHNGY3__EG_HNGY_THRESH_12                             24
+#define   W_SPIHNGY3__EG_HNGY_THRESH_12                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_13                             16
+#define   W_SPIHNGY3__EG_HNGY_THRESH_13                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_14                             8
+#define   W_SPIHNGY3__EG_HNGY_THRESH_14                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_15                             0
+#define   W_SPIHNGY3__EG_HNGY_THRESH_15                             7
+#define R_SPISTRV0                                                  0x21D
+#define   O_SPISTRV0__EG_STRV_THRESH_0                              24
+#define   W_SPISTRV0__EG_STRV_THRESH_0                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_1                              16
+#define   W_SPISTRV0__EG_STRV_THRESH_1                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_2                              8
+#define   W_SPISTRV0__EG_STRV_THRESH_2                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_3                              0
+#define   W_SPISTRV0__EG_STRV_THRESH_3                              7
+#define R_SPISTRV1                                                  0x21E
+#define   O_SPISTRV1__EG_STRV_THRESH_4                              24
+#define   W_SPISTRV1__EG_STRV_THRESH_4                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_5                              16
+#define   W_SPISTRV1__EG_STRV_THRESH_5                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_6                              8
+#define   W_SPISTRV1__EG_STRV_THRESH_6                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_7                              0
+#define   W_SPISTRV1__EG_STRV_THRESH_7                              7
+#define R_SPISTRV2                                                  0x21F
+#define   O_SPISTRV2__EG_STRV_THRESH_8                              24
+#define   W_SPISTRV2__EG_STRV_THRESH_8                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_9                              16
+#define   W_SPISTRV2__EG_STRV_THRESH_9                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_10                             8
+#define   W_SPISTRV2__EG_STRV_THRESH_10                             7
+#define   O_SPISTRV2__EG_STRV_THRESH_11                             0
+#define   W_SPISTRV2__EG_STRV_THRESH_11                             7
+#define R_SPISTRV3                                                  0x220
+#define   O_SPISTRV3__EG_STRV_THRESH_12                             24
+#define   W_SPISTRV3__EG_STRV_THRESH_12                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_13                             16
+#define   W_SPISTRV3__EG_STRV_THRESH_13                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_14                             8
+#define   W_SPISTRV3__EG_STRV_THRESH_14                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_15                             0
+#define   W_SPISTRV3__EG_STRV_THRESH_15                             7
+#define R_TXDATAFIFO0                                               0x221
+#define   O_TXDATAFIFO0__Tx0DataFifoStart                           24
+#define   W_TXDATAFIFO0__Tx0DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx0DataFifoSize                            16
+#define   W_TXDATAFIFO0__Tx0DataFifoSize                            7
+#define   O_TXDATAFIFO0__Tx1DataFifoStart                           8
+#define   W_TXDATAFIFO0__Tx1DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx1DataFifoSize                            0
+#define   W_TXDATAFIFO0__Tx1DataFifoSize                            7
+#define R_TXDATAFIFO1                                               0x222
+#define   O_TXDATAFIFO1__Tx2DataFifoStart                           24
+#define   W_TXDATAFIFO1__Tx2DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx2DataFifoSize                            16
+#define   W_TXDATAFIFO1__Tx2DataFifoSize                            7
+#define   O_TXDATAFIFO1__Tx3DataFifoStart                           8
+#define   W_TXDATAFIFO1__Tx3DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx3DataFifoSize                            0
+#define   W_TXDATAFIFO1__Tx3DataFifoSize                            7
+#define R_TXDATAFIFO2                                               0x223
+#define   O_TXDATAFIFO2__Tx4DataFifoStart                           24
+#define   W_TXDATAFIFO2__Tx4DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx4DataFifoSize                            16
+#define   W_TXDATAFIFO2__Tx4DataFifoSize                            7
+#define   O_TXDATAFIFO2__Tx5DataFifoStart                           8
+#define   W_TXDATAFIFO2__Tx5DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx5DataFifoSize                            0
+#define   W_TXDATAFIFO2__Tx5DataFifoSize                            7
+#define R_TXDATAFIFO3                                               0x224
+#define   O_TXDATAFIFO3__Tx6DataFifoStart                           24
+#define   W_TXDATAFIFO3__Tx6DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx6DataFifoSize                            16
+#define   W_TXDATAFIFO3__Tx6DataFifoSize                            7
+#define   O_TXDATAFIFO3__Tx7DataFifoStart                           8
+#define   W_TXDATAFIFO3__Tx7DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx7DataFifoSize                            0
+#define   W_TXDATAFIFO3__Tx7DataFifoSize                            7
+#define R_TXDATAFIFO4                                               0x225
+#define   O_TXDATAFIFO4__Tx8DataFifoStart                           24
+#define   W_TXDATAFIFO4__Tx8DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx8DataFifoSize                            16
+#define   W_TXDATAFIFO4__Tx8DataFifoSize                            7
+#define   O_TXDATAFIFO4__Tx9DataFifoStart                           8
+#define   W_TXDATAFIFO4__Tx9DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx9DataFifoSize                            0
+#define   W_TXDATAFIFO4__Tx9DataFifoSize                            7
+#define R_TXDATAFIFO5                                               0x226
+#define   O_TXDATAFIFO5__Tx10DataFifoStart                          24
+#define   W_TXDATAFIFO5__Tx10DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx10DataFifoSize                           16
+#define   W_TXDATAFIFO5__Tx10DataFifoSize                           7
+#define   O_TXDATAFIFO5__Tx11DataFifoStart                          8
+#define   W_TXDATAFIFO5__Tx11DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx11DataFifoSize                           0
+#define   W_TXDATAFIFO5__Tx11DataFifoSize                           7
+#define R_TXDATAFIFO6                                               0x227
+#define   O_TXDATAFIFO6__Tx12DataFifoStart                          24
+#define   W_TXDATAFIFO6__Tx12DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx12DataFifoSize                           16
+#define   W_TXDATAFIFO6__Tx12DataFifoSize                           7
+#define   O_TXDATAFIFO6__Tx13DataFifoStart                          8
+#define   W_TXDATAFIFO6__Tx13DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx13DataFifoSize                           0
+#define   W_TXDATAFIFO6__Tx13DataFifoSize                           7
+#define R_TXDATAFIFO7                                               0x228
+#define   O_TXDATAFIFO7__Tx14DataFifoStart                          24
+#define   W_TXDATAFIFO7__Tx14DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx14DataFifoSize                           16
+#define   W_TXDATAFIFO7__Tx14DataFifoSize                           7
+#define   O_TXDATAFIFO7__Tx15DataFifoStart                          8
+#define   W_TXDATAFIFO7__Tx15DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx15DataFifoSize                           0
+#define   W_TXDATAFIFO7__Tx15DataFifoSize                           7
+#define R_RXDATAFIFO0                                               0x229
+#define   O_RXDATAFIFO0__Rx0DataFifoStart                           24
+#define   W_RXDATAFIFO0__Rx0DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx0DataFifoSize                            16
+#define   W_RXDATAFIFO0__Rx0DataFifoSize                            7
+#define   O_RXDATAFIFO0__Rx1DataFifoStart                           8
+#define   W_RXDATAFIFO0__Rx1DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx1DataFifoSize                            0
+#define   W_RXDATAFIFO0__Rx1DataFifoSize                            7
+#define R_RXDATAFIFO1                                               0x22A
+#define   O_RXDATAFIFO1__Rx2DataFifoStart                           24
+#define   W_RXDATAFIFO1__Rx2DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx2DataFifoSize                            16
+#define   W_RXDATAFIFO1__Rx2DataFifoSize                            7
+#define   O_RXDATAFIFO1__Rx3DataFifoStart                           8
+#define   W_RXDATAFIFO1__Rx3DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx3DataFifoSize                            0
+#define   W_RXDATAFIFO1__Rx3DataFifoSize                            7
+#define R_RXDATAFIFO2                                               0x22B
+#define   O_RXDATAFIFO2__Rx4DataFifoStart                           24
+#define   W_RXDATAFIFO2__Rx4DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx4DataFifoSize                            16
+#define   W_RXDATAFIFO2__Rx4DataFifoSize                            7
+#define   O_RXDATAFIFO2__Rx5DataFifoStart                           8
+#define   W_RXDATAFIFO2__Rx5DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx5DataFifoSize                            0
+#define   W_RXDATAFIFO2__Rx5DataFifoSize                            7
+#define R_RXDATAFIFO3                                               0x22C
+#define   O_RXDATAFIFO3__Rx6DataFifoStart                           24
+#define   W_RXDATAFIFO3__Rx6DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx6DataFifoSize                            16
+#define   W_RXDATAFIFO3__Rx6DataFifoSize                            7
+#define   O_RXDATAFIFO3__Rx7DataFifoStart                           8
+#define   W_RXDATAFIFO3__Rx7DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx7DataFifoSize                            0
+#define   W_RXDATAFIFO3__Rx7DataFifoSize                            7
+#define R_RXDATAFIFO4                                               0x22D
+#define   O_RXDATAFIFO4__Rx8DataFifoStart                           24
+#define   W_RXDATAFIFO4__Rx8DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx8DataFifoSize                            16
+#define   W_RXDATAFIFO4__Rx8DataFifoSize                            7
+#define   O_RXDATAFIFO4__Rx9DataFifoStart                           8
+#define   W_RXDATAFIFO4__Rx9DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx9DataFifoSize                            0
+#define   W_RXDATAFIFO4__Rx9DataFifoSize                            7
+#define R_RXDATAFIFO5                                               0x22E
+#define   O_RXDATAFIFO5__Rx10DataFifoStart                          24
+#define   W_RXDATAFIFO5__Rx10DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx10DataFifoSize                           16
+#define   W_RXDATAFIFO5__Rx10DataFifoSize                           7
+#define   O_RXDATAFIFO5__Rx11DataFifoStart                          8
+#define   W_RXDATAFIFO5__Rx11DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx11DataFifoSize                           0
+#define   W_RXDATAFIFO5__Rx11DataFifoSize                           7
+#define R_RXDATAFIFO6                                               0x22F
+#define   O_RXDATAFIFO6__Rx12DataFifoStart                          24
+#define   W_RXDATAFIFO6__Rx12DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx12DataFifoSize                           16
+#define   W_RXDATAFIFO6__Rx12DataFifoSize                           7
+#define   O_RXDATAFIFO6__Rx13DataFifoStart                          8
+#define   W_RXDATAFIFO6__Rx13DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx13DataFifoSize                           0
+#define   W_RXDATAFIFO6__Rx13DataFifoSize                           7
+#define R_RXDATAFIFO7                                               0x230
+#define   O_RXDATAFIFO7__Rx14DataFifoStart                          24
+#define   W_RXDATAFIFO7__Rx14DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx14DataFifoSize                           16
+#define   W_RXDATAFIFO7__Rx14DataFifoSize                           7
+#define   O_RXDATAFIFO7__Rx15DataFifoStart                          8
+#define   W_RXDATAFIFO7__Rx15DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx15DataFifoSize                           0
+#define   W_RXDATAFIFO7__Rx15DataFifoSize                           7
+#define R_XGMACPADCALIBRATION                                       0x231
+#define R_FREEQCARVE                                                0x233
+#define R_SPI4STATICDELAY0                                          0x240
+#define   O_SPI4STATICDELAY0__DataLine7                             28
+#define   W_SPI4STATICDELAY0__DataLine7                             4
+#define   O_SPI4STATICDELAY0__DataLine6                             24
+#define   W_SPI4STATICDELAY0__DataLine6                             4
+#define   O_SPI4STATICDELAY0__DataLine5                             20
+#define   W_SPI4STATICDELAY0__DataLine5                             4
+#define   O_SPI4STATICDELAY0__DataLine4                             16
+#define   W_SPI4STATICDELAY0__DataLine4                             4
+#define   O_SPI4STATICDELAY0__DataLine3                             12
+#define   W_SPI4STATICDELAY0__DataLine3                             4
+#define   O_SPI4STATICDELAY0__DataLine2                             8
+#define   W_SPI4STATICDELAY0__DataLine2                             4
+#define   O_SPI4STATICDELAY0__DataLine1                             4
+#define   W_SPI4STATICDELAY0__DataLine1                             4
+#define   O_SPI4STATICDELAY0__DataLine0                             0
+#define   W_SPI4STATICDELAY0__DataLine0                             4
+#define R_SPI4STATICDELAY1                                          0x241
+#define   O_SPI4STATICDELAY1__DataLine15                            28
+#define   W_SPI4STATICDELAY1__DataLine15                            4
+#define   O_SPI4STATICDELAY1__DataLine14                            24
+#define   W_SPI4STATICDELAY1__DataLine14                            4
+#define   O_SPI4STATICDELAY1__DataLine13                            20
+#define   W_SPI4STATICDELAY1__DataLine13                            4
+#define   O_SPI4STATICDELAY1__DataLine12                            16
+#define   W_SPI4STATICDELAY1__DataLine12                            4
+#define   O_SPI4STATICDELAY1__DataLine11                            12
+#define   W_SPI4STATICDELAY1__DataLine11                            4
+#define   O_SPI4STATICDELAY1__DataLine10                            8
+#define   W_SPI4STATICDELAY1__DataLine10                            4
+#define   O_SPI4STATICDELAY1__DataLine9                             4
+#define   W_SPI4STATICDELAY1__DataLine9                             4
+#define   O_SPI4STATICDELAY1__DataLine8                             0
+#define   W_SPI4STATICDELAY1__DataLine8                             4
+#define R_SPI4STATICDELAY2                                          0x242
+#define   O_SPI4STATICDELAY0__TxStat1                               8
+#define   W_SPI4STATICDELAY0__TxStat1                               4
+#define   O_SPI4STATICDELAY0__TxStat0                               4
+#define   W_SPI4STATICDELAY0__TxStat0                               4
+#define   O_SPI4STATICDELAY0__RxControl                             0
+#define   W_SPI4STATICDELAY0__RxControl                             4
+#define R_SPI4CONTROL                                               0x243
+#define   O_SPI4CONTROL__StaticDelay                                2
+#define   O_SPI4CONTROL__LVDS_LVTTL                                 1
+#define   O_SPI4CONTROL__SPI4Enable                                 0
+#define R_CLASSWATERMARKS                                           0x244
+#define   O_CLASSWATERMARKS__Class0Watermark                        24
+#define   W_CLASSWATERMARKS__Class0Watermark                        5
+#define   O_CLASSWATERMARKS__Class1Watermark                        16
+#define   W_CLASSWATERMARKS__Class1Watermark                        5
+#define   O_CLASSWATERMARKS__Class3Watermark                        0
+#define   W_CLASSWATERMARKS__Class3Watermark                        5
+#define R_RXWATERMARKS1                                              0x245
+#define   O_RXWATERMARKS__Rx0DataWatermark                          24
+#define   W_RXWATERMARKS__Rx0DataWatermark                          7
+#define   O_RXWATERMARKS__Rx1DataWatermark                          16
+#define   W_RXWATERMARKS__Rx1DataWatermark                          7
+#define   O_RXWATERMARKS__Rx3DataWatermark                          0
+#define   W_RXWATERMARKS__Rx3DataWatermark                          7
+#define R_RXWATERMARKS2                                              0x246
+#define   O_RXWATERMARKS__Rx4DataWatermark                          24
+#define   W_RXWATERMARKS__Rx4DataWatermark                          7
+#define   O_RXWATERMARKS__Rx5DataWatermark                          16
+#define   W_RXWATERMARKS__Rx5DataWatermark                          7
+#define   O_RXWATERMARKS__Rx6DataWatermark                          8
+#define   W_RXWATERMARKS__Rx6DataWatermark                          7
+#define   O_RXWATERMARKS__Rx7DataWatermark                          0
+#define   W_RXWATERMARKS__Rx7DataWatermark                          7
+#define R_RXWATERMARKS3                                              0x247
+#define   O_RXWATERMARKS__Rx8DataWatermark                          24
+#define   W_RXWATERMARKS__Rx8DataWatermark                          7
+#define   O_RXWATERMARKS__Rx9DataWatermark                          16
+#define   W_RXWATERMARKS__Rx9DataWatermark                          7
+#define   O_RXWATERMARKS__Rx10DataWatermark                         8
+#define   W_RXWATERMARKS__Rx10DataWatermark                         7
+#define   O_RXWATERMARKS__Rx11DataWatermark                         0
+#define   W_RXWATERMARKS__Rx11DataWatermark                         7
+#define R_RXWATERMARKS4                                              0x248
+#define   O_RXWATERMARKS__Rx12DataWatermark                         24
+#define   W_RXWATERMARKS__Rx12DataWatermark                         7
+#define   O_RXWATERMARKS__Rx13DataWatermark                         16
+#define   W_RXWATERMARKS__Rx13DataWatermark                         7
+#define   O_RXWATERMARKS__Rx14DataWatermark                         8
+#define   W_RXWATERMARKS__Rx14DataWatermark                         7
+#define   O_RXWATERMARKS__Rx15DataWatermark                         0
+#define   W_RXWATERMARKS__Rx15DataWatermark                         7
+#define R_FREEWATERMARKS                                            0x249
+#define   O_FREEWATERMARKS__FreeOutWatermark                        16
+#define   W_FREEWATERMARKS__FreeOutWatermark                        16
+#define   O_FREEWATERMARKS__JumFrWatermark                          8
+#define   W_FREEWATERMARKS__JumFrWatermark                          7
+#define   O_FREEWATERMARKS__RegFrWatermark                          0
+#define   W_FREEWATERMARKS__RegFrWatermark                          7
+#define R_EGRESSFIFOCARVINGSLOTS                                    0x24a
+
+#define TYPE_GMAC       0
+#define TYPE_XGMAC      1
+#define TYPE_SPI4       2
+
+#define CTRL_RES0           0
+#define CTRL_RES1           1
+#define CTRL_REG_FREE       2
+#define CTRL_JUMBO_FREE     3
+#define CTRL_CONT           4
+#define CTRL_EOP            5
+#define CTRL_START          6
+#define CTRL_SNGL           7
+
+#define CTRL_B0_NOT_EOP     0
+#define CTRL_B0_EOP         1
+
+#define R_ROUND_ROBIN_TABLE                 0
+#define R_PDE_CLASS_0                       0x300
+#define R_PDE_CLASS_1                       0x302
+#define R_PDE_CLASS_2                       0x304
+#define R_PDE_CLASS_3                       0x306
+
+#define R_MSG_TX_THRESHOLD                  0x308
+
+#define R_GMAC_JFR0_BUCKET_SIZE              0x320
+#define R_GMAC_RFR0_BUCKET_SIZE              0x321
+#define R_GMAC_TX0_BUCKET_SIZE              0x322
+#define R_GMAC_TX1_BUCKET_SIZE              0x323
+#define R_GMAC_TX2_BUCKET_SIZE              0x324
+#define R_GMAC_TX3_BUCKET_SIZE              0x325
+#define R_GMAC_JFR1_BUCKET_SIZE              0x326
+#define R_GMAC_RFR1_BUCKET_SIZE              0x327
+
+#define R_XGS_TX0_BUCKET_SIZE               0x320
+#define R_XGS_TX1_BUCKET_SIZE               0x321
+#define R_XGS_TX2_BUCKET_SIZE               0x322
+#define R_XGS_TX3_BUCKET_SIZE               0x323
+#define R_XGS_TX4_BUCKET_SIZE               0x324
+#define R_XGS_TX5_BUCKET_SIZE               0x325
+#define R_XGS_TX6_BUCKET_SIZE               0x326
+#define R_XGS_TX7_BUCKET_SIZE               0x327
+#define R_XGS_TX8_BUCKET_SIZE               0x328
+#define R_XGS_TX9_BUCKET_SIZE               0x329
+#define R_XGS_TX10_BUCKET_SIZE              0x32A
+#define R_XGS_TX11_BUCKET_SIZE              0x32B
+#define R_XGS_TX12_BUCKET_SIZE              0x32C
+#define R_XGS_TX13_BUCKET_SIZE              0x32D
+#define R_XGS_TX14_BUCKET_SIZE              0x32E
+#define R_XGS_TX15_BUCKET_SIZE              0x32F
+#define R_XGS_JFR_BUCKET_SIZE               0x330
+#define R_XGS_RFR_BUCKET_SIZE               0x331
+
+#define R_CC_CPU0_0                         0x380
+#define R_CC_CPU1_0                         0x388
+#define R_CC_CPU2_0                         0x390
+#define R_CC_CPU3_0                         0x398
+#define R_CC_CPU4_0                         0x3a0
+#define R_CC_CPU5_0                         0x3a8
+#define R_CC_CPU6_0                         0x3b0
+#define R_CC_CPU7_0                         0x3b8
+
+enum {
+        SGMII_SPEED_10   = 0x00000000,
+        SGMII_SPEED_100  = 0x02000000,
+        SGMII_SPEED_1000 = 0x04000000,
+};
+
+enum tsv_rsv_reg{
+  TX_RX_64_BYTE_FRAME = 0x20,
+  TX_RX_64_127_BYTE_FRAME,
+  TX_RX_128_255_BYTE_FRAME,
+  TX_RX_256_511_BYTE_FRAME,
+  TX_RX_512_1023_BYTE_FRAME,
+  TX_RX_1024_1518_BYTE_FRAME,
+  TX_RX_1519_1522_VLAN_BYTE_FRAME,
+
+  RX_BYTE_COUNTER = 0x27,
+  RX_PACKET_COUNTER,
+  RX_FCS_ERROR_COUNTER,
+  RX_MULTICAST_PACKET_COUNTER,
+  RX_BROADCAST_PACKET_COUNTER,
+  RX_CONTROL_FRAME_PACKET_COUNTER,
+  RX_PAUSE_FRAME_PACKET_COUNTER,
+  RX_UNKNOWN_OP_CODE_COUNTER,
+  RX_ALIGNMENT_ERROR_COUNTER,
+  RX_FRAME_LENGTH_ERROR_COUNTER,
+  RX_CODE_ERROR_COUNTER,
+  RX_CARRIER_SENSE_ERROR_COUNTER,
+  RX_UNDERSIZE_PACKET_COUNTER,
+  RX_OVERSIZE_PACKET_COUNTER,
+  RX_FRAGMENTS_COUNTER,
+  RX_JABBER_COUNTER,
+  RX_DROP_PACKET_COUNTER,
+
+  TX_BYTE_COUNTER   = 0x38,
+  TX_PACKET_COUNTER,
+  TX_MULTICAST_PACKET_COUNTER,
+  TX_BROADCAST_PACKET_COUNTER,
+  TX_PAUSE_CONTROL_FRAME_COUNTER,
+  TX_DEFERRAL_PACKET_COUNTER,
+  TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
+  TX_SINGLE_COLLISION_PACKET_COUNTER,
+  TX_MULTI_COLLISION_PACKET_COUNTER,
+  TX_LATE_COLLISION_PACKET_COUNTER,
+  TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
+  TX_TOTAL_COLLISION_COUNTER,
+  TX_PAUSE_FRAME_HONERED_COUNTER,
+  TX_DROP_FRAME_COUNTER,
+  TX_JABBER_FRAME_COUNTER,
+  TX_FCS_ERROR_COUNTER,
+  TX_CONTROL_FRAME_COUNTER,
+  TX_OVERSIZE_FRAME_COUNTER,
+  TX_UNDERSIZE_FRAME_COUNTER,
+  TX_FRAGMENT_FRAME_COUNTER,
+
+  CARRY_REG_1 = 0x4c,
+  CARRY_REG_2 = 0x4d,
+};
+
+struct size_1_desc {
+  uint64_t entry0;
+};
+
+struct size_2_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+};
+
+struct size_3_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+  uint64_t entry2;
+};
+
+struct size_4_desc {
+  uint64_t entry0;
+  uint64_t entry1;
+  uint64_t entry2;
+  uint64_t entry3;
+};
+
+struct fr_desc {
+  struct size_1_desc d1;
+};
+
+union rx_tx_desc {
+  struct size_1_desc d1;
+};
+
+static inline int mac_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
+				    unsigned long addr)
+{
+  int stid = 0;
+  
+  if (type == TYPE_XGMAC) stid = msgrng_xgmac_stid_rfr(id);
+  else  {
+#ifdef MAC_SPLIT_MODE
+    stid =  msgrng_gmac_stid_rfr_split_mode(id);
+#else
+    stid = msgrng_gmac_stid_rfr(id);
+#endif 
+  }
+  msg->msg0 = (((uint64_t)CTRL_REG_FREE << 61) | 
+	       ((uint64_t)stid<<52) | 
+	       (uint64_t)addr);
+  msg->msg1 = msg->msg2 = msg->msg3 = 0;
+  return stid;
+}
+
+
+
+static inline int
+msgrng_stid_rfr(int id, int type)
+{
+    int stid = 0;
+
+  if (type == TYPE_XGMAC) 
+    stid = msgrng_xgmac_stid_rfr(id);
+    else  {
+        if (id < 4) {
+#ifdef MAC_SPLIT_MODE
+            stid =  msgrng_gmac_stid_rfr_split_mode(id);
+#else
+            stid = msgrng_gmac_stid_rfr(id);
+#endif 
+        }
+        else
+            stid = msgrng_gmac1_stid_rfr(id);
+    }
+  return stid;
+}
+
+
+
+static inline int mac_make_desc_b0_rfr(struct msgrng_msg *msg, int id, int type,
+        unsigned long addr)
+{
+    int stid = msgrng_stid_rfr(id, type);
+
+    msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
+    msg->msg1 = msg->msg2 = msg->msg3 = 0;
+
+    return stid;
+}
+
+#define MAC_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
+static inline int mac_make_desc_tx(struct msgrng_msg *msg, int id, int type,
+        unsigned long addr, int len)
+{
+    int tx_stid = 0;
+    int fr_stid = 0;
+    int desc_offset = addr & MAC_TX_DESC_ALIGNMENT;
+
+    if (type == TYPE_XGMAC) {
+        tx_stid = msgrng_xgmac_stid_tx(id);
+        fr_stid = 0;
+    }
+    else {
+        int cpu = phoenix_cpu_id();
+        if (id < 4)
+            tx_stid = msgrng_gmac_stid_tx(id);
+        else
+            tx_stid = msgrng_gmac1_stid_tx(id);
+        fr_stid = (cpu << 3) + phoenix_thr_id();
+    }
+
+    msg->msg0 = ( ((uint64_t)CTRL_SNGL << 61) | 
+            ((uint64_t)desc_offset << 40) | 
+            ((uint64_t)tx_stid << 52) |
+            ((uint64_t)addr & ~MAC_TX_DESC_ALIGNMENT)
+            );
+    msg->msg1 = ( ( (uint64_t)CTRL_EOP << 61) |  
+            ( ((uint64_t)fr_stid) << 54) | 
+            ( (uint64_t)len << 40)
+            );
+
+    msg->msg2 = msg->msg3 = 0;
+
+    return tx_stid;
+}
+
+extern __u8 phoenix_base_mac_addr[];
+/*
+ * Structure of an rmios ipsec packet
+ */
+typedef struct tagIPSEC_PACKET {
+    /* cacheline-aligned portion */
+    PacketDescriptor_t packet_desc;	/* multiple of 32 (32) */
+    PacketDescriptor_t particle_desc;	/* second particle (GCM) */
+    unsigned char auth_dest[PHXSEC_HMAC_LENGTH];	/* multiple of 32 (32) */
+    unsigned char packet_data[IPSEC_PACKET_PAYLOAD_SIZE];
+    /* end of cacheline-aligned portion */
+    int src_id;
+} IPSEC_PACKET ____cacheline_aligned;
+
+#endif
diff --git a/include/asm-mips/rmi/phoenix_rmios_debugger.h b/include/asm-mips/rmi/phoenix_rmios_debugger.h
new file mode 100644
index 0000000..b5d38e3
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_rmios_debugger.h
@@ -0,0 +1,53 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#define PHNX_DEB_DEV_NAME  "phnxdeb"
+
+#define PHNX_RMIOS_DEBUGGER_WRITE                   0xaa10
+#define PHNX_RMIOS_DEBUGGER_READ                    0xaa11
+#define PHNX_RMIOS_DEBUGGER_TX_MEM_WRITE            0xaa12
+#define PHNX_RMIOS_DEBUGGER_TX_MEM_READ             0xaa13
+#define PHNX_RMIOS_DEBUGGER_RX_MEM_WRITE            0xaa14
+#define PHNX_RMIOS_DEBUGGER_RX_MEM_READ             0xaa15
+#define PHNX_RMIOS_DEBUGGER_MEM_READ                0xaa16
+#define PHNX_RMIOS_DEBUGGER_MEM_WRITE               0xaa17
+#define PHNX_RMIOS_DEBUGGER_PIC_IPI                 0xaa18
+#define LINUX_RMIOS_SHARED_BASE                     0x00040000UL
+#define LINUX_RMIOS_VCPU                            32
+#define LINUX_RMIOS_TX_BUF_SIZE                     1600
+#define LINUX_RMIOS_RX_BUF_SIZE                     256
+#define LINUX_RMIOS_RX_BUF_BASE            LINUX_RMIOS_SHARED_BASE
+#define LINUX_RMIOS_TX_BUF_BASE            (LINUX_RMIOS_RX_BUF_BASE + (LINUX_RMIOS_RX_BUF_SIZE * LINUX_RMIOS_VCPU))
+#define LINUX_RMIOS_CPU_ONLINE_MAP_LOCK    (LINUX_RMIOS_TX_BUF_BASE + (LINUX_RMIOS_TX_BUF_SIZE * LINUX_RMIOS_VCPU))
+#define LINUX_RMIOS_CPU_ONLINE_MAP_LOCK_INIT_DONE  (LINUX_RMIOS_CPU_ONLINE_MAP_LOCK + CACHE_LINE_SIZE)
+#define LINUX_RMIOS_CPU_ONLINE_MAP         (LINUX_RMIOS_CPU_ONLINE_MAP_LOCK_INIT_DONE + CACHE_LINE_SIZE)
+
+#define LOCK_INIT_DONE                              0x900ddeed
+
diff --git a/include/asm-mips/rmi/phoenix_sec.h b/include/asm-mips/rmi/phoenix_sec.h
new file mode 100644
index 0000000..8e64a41
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_sec.h
@@ -0,0 +1,766 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _PHONIEX_SEC_H
+#define _PHOENIX_SEC_H
+
+#include <linux/types.h>
+#include <asm/rmi/msgring.h>
+
+enum sec_pipe_config {
+
+  SEC_PIPE_CIPHER_KEY0_L0            = 0x00,
+  SEC_PIPE_CIPHER_KEY0_HI,
+  SEC_PIPE_CIPHER_KEY1_LO,
+  SEC_PIPE_CIPHER_KEY1_HI,
+  SEC_PIPE_CIPHER_KEY2_LO,
+  SEC_PIPE_CIPHER_KEY2_HI,
+  SEC_PIPE_CIPHER_KEY3_LO,
+  SEC_PIPE_CIPHER_KEY3_HI,
+  SEC_PIPE_HMAC_KEY0_LO,
+  SEC_PIPE_HMAC_KEY0_HI,
+  SEC_PIPE_HMAC_KEY1_LO,
+  SEC_PIPE_HMAC_KEY1_HI,
+  SEC_PIPE_HMAC_KEY2_LO,
+  SEC_PIPE_HMAC_KEY2_HI,
+  SEC_PIPE_HMAC_KEY3_LO,
+  SEC_PIPE_HMAC_KEY3_HI,
+  SEC_PIPE_HMAC_KEY4_LO,
+  SEC_PIPE_HMAC_KEY4_HI,
+  SEC_PIPE_HMAC_KEY5_LO,
+  SEC_PIPE_HMAC_KEY5_HI,
+  SEC_PIPE_HMAC_KEY6_LO,
+  SEC_PIPE_HMAC_KEY6_HI,
+  SEC_PIPE_HMAC_KEY7_LO,
+  SEC_PIPE_HMAC_KEY7_HI,
+  SEC_PIPE_NCFBM_LO,
+  SEC_PIPE_NCFBM_HI,
+  SEC_PIPE_INSTR_LO,
+  SEC_PIPE_INSTR_HI,
+  SEC_PIPE_RSVD0,
+  SEC_PIPE_RSVD1,
+  SEC_PIPE_RSVD2,
+  SEC_PIPE_RSVD3,
+
+  SEC_PIPE_DF_PTRS0,
+  SEC_PIPE_DF_PTRS1,
+  SEC_PIPE_DF_PTRS2,
+  SEC_PIPE_DF_PTRS3,
+  SEC_PIPE_DF_PTRS4,
+  SEC_PIPE_DF_PTRS5,
+  SEC_PIPE_DF_PTRS6,
+  SEC_PIPE_DF_PTRS7,
+
+  SEC_PIPE_DU_DATA_IN_LO,
+  SEC_PIPE_DU_DATA_IN_HI,
+  SEC_PIPE_DU_DATA_IN_CTRL,
+  SEC_PIPE_DU_DATA_OUT_LO,
+  SEC_PIPE_DU_DATA_OUT_HI,
+  SEC_PIPE_DU_DATA_OUT_CTRL,
+
+  SEC_PIPE_STATE0,
+  SEC_PIPE_STATE1,
+  SEC_PIPE_STATE2,
+  SEC_PIPE_STATE3,
+  SEC_PIPE_STATE4,
+  SEC_PIPE_INCLUDE_MASK0,
+  SEC_PIPE_INCLUDE_MASK1,
+  SEC_PIPE_INCLUDE_MASK2,
+  SEC_PIPE_INCLUDE_MASK3,
+  SEC_PIPE_INCLUDE_MASK4,
+  SEC_PIPE_EXCLUDE_MASK0,
+  SEC_PIPE_EXCLUDE_MASK1,
+  SEC_PIPE_EXCLUDE_MASK2,
+  SEC_PIPE_EXCLUDE_MASK3,
+  SEC_PIPE_EXCLUDE_MASK4,
+};
+
+enum sec_pipe_base_config {
+  
+  SEC_PIPE0_BASE = 0x00,
+  SEC_PIPE1_BASE = 0x40,
+  SEC_PIPE2_BASE = 0x80,
+  SEC_PIPE3_BASE = 0xc0
+
+};
+
+enum sec_rsa_config {
+  
+  SEC_RSA_PIPE0_DU_DATA_IN_LO = 0x100,
+  SEC_RSA_PIPE0_DU_DATA_IN_HI,
+  SEC_RSA_PIPE0_DU_DATA_IN_CTRL,
+  SEC_RSA_PIPE0_DU_DATA_OUT_LO,
+  SEC_RSA_PIPE0_DU_DATA_OUT_HI,
+  SEC_RSA_PIPE0_DU_DATA_OUT_CTRL,
+  SEC_RSA_RSVD0,
+  SEC_RSA_RSVD1,
+
+  SEC_RSA_PIPE0_STATE0,
+  SEC_RSA_PIPE0_STATE1,
+  SEC_RSA_PIPE0_STATE2,
+  SEC_RSA_PIPE0_INCLUDE_MASK0,
+  SEC_RSA_PIPE0_INCLUDE_MASK1,
+  SEC_RSA_PIPE0_INCLUDE_MASK2,
+  SEC_RSA_PIPE0_EXCLUDE_MASK0,
+  SEC_RSA_PIPE0_EXCLUDE_MASK1,
+  SEC_RSA_PIPE0_EXCLUDE_MASK2,
+  SEC_RSA_PIPE0_EVENT_CTR
+
+};
+
+enum sec_config {
+  
+  SEC_DMA_CREDIT = 0x140,
+  SEC_CONFIG1,
+  SEC_CONFIG2,
+  SEC_CONFIG3,  
+
+};
+
+enum sec_debug_config {
+  
+  SEC_DW0_DESCRIPTOR0_LO  = 0x180,
+  SEC_DW0_DESCRIPTOR0_HI,
+  SEC_DW0_DESCRIPTOR1_LO,
+  SEC_DW0_DESCRIPTOR1_HI,
+  SEC_DW1_DESCRIPTOR0_LO,
+  SEC_DW1_DESCRIPTOR0_HI,
+  SEC_DW1_DESCRIPTOR1_LO,
+  SEC_DW1_DESCRIPTOR1_HI,
+  SEC_DW2_DESCRIPTOR0_LO,
+  SEC_DW2_DESCRIPTOR0_HI,
+  SEC_DW2_DESCRIPTOR1_LO,
+  SEC_DW2_DESCRIPTOR1_HI,
+  SEC_DW3_DESCRIPTOR0_LO,
+  SEC_DW3_DESCRIPTOR0_HI,
+  SEC_DW3_DESCRIPTOR1_LO,
+  SEC_DW3_DESCRIPTOR1_HI,
+
+  SEC_STATE0,
+  SEC_STATE1,  
+  SEC_STATE2,
+  SEC_INCLUDE_MASK0,
+  SEC_INCLUDE_MASK1,
+  SEC_INCLUDE_MASK2,
+  SEC_EXCLUDE_MASK0,
+  SEC_EXCLUDE_MASK1,
+  SEC_EXCLUDE_MASK2,
+  SEC_EVENT_CTR
+
+};
+
+enum sec_msgring_bucket_config {
+
+  SEC_BIU_CREDITS = 0x308,
+  
+  SEC_MSG_BUCKET0_SIZE = 0x320,
+  SEC_MSG_BUCKET1_SIZE,
+  SEC_MSG_BUCKET2_SIZE,
+  SEC_MSG_BUCKET3_SIZE,
+  SEC_MSG_BUCKET4_SIZE,
+  SEC_MSG_BUCKET5_SIZE,
+  SEC_MSG_BUCKET6_SIZE,
+  SEC_MSG_BUCKET7_SIZE,
+};
+
+enum sec_msgring_credit_config {
+
+  SEC_CC_CPU0_0                        = 0x380,
+  SEC_CC_CPU1_0                        = 0x388,
+  SEC_CC_CPU2_0                        = 0x390,
+  SEC_CC_CPU3_0                        = 0x398,
+  SEC_CC_CPU4_0                        = 0x3a0,
+  SEC_CC_CPU5_0                        = 0x3a8,
+  SEC_CC_CPU6_0                        = 0x3b0,
+  SEC_CC_CPU7_0                        = 0x3b8
+
+};
+
+enum sec_engine_id {
+  SEC_PIPE0,
+  SEC_PIPE1,
+  SEC_PIPE2,
+  SEC_PIPE3,
+  SEC_RSA
+};
+
+enum sec_cipher {
+  SEC_AES256_MODE_HMAC,
+  SEC_AES256_MODE,
+  SEC_AES256_HMAC,
+  SEC_AES256,
+  SEC_AES192_MODE_HMAC,
+  SEC_AES192_MODE,
+  SEC_AES192_HMAC,
+  SEC_AES192,
+  SEC_AES128_MODE_HMAC,
+  SEC_AES128_MODE,
+  SEC_AES128_HMAC,
+  SEC_AES128,
+  SEC_DES_HMAC,
+  SEC_DES,
+  SEC_3DES,
+  SEC_3DES_HMAC,
+  SEC_HMAC
+};
+
+enum sec_msgrng_msg_ctrl_config {
+  SEC_EOP=5,
+  SEC_SOP=6,
+};
+
+/*
+ * Security block data and control exchange
+ *
+ * A 2-word message ring descriptor is used to pass a pointer to the control descriptor data structure
+ * and a pointer to the packet descriptor data structure:
+ *
+ *  63  61 60    54      53      52    48 47            45 44    40 39                                                     5 4      0
+ *  ---------------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | FREEBACKID | IF_L2ALLOC | UNUSED | Control Length | UNUSED | 35 MSB of address of control descriptor data structure | UNUSED |
+ *  ---------------------------------------------------------------------------------------------------------------------------------
+ *    3       7          1          5             3           5                              35                                 5
+ *
+ *  63  61 60    54     53          52             51        50    46      45       44    40 39                                                    5 4      0
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | FREEBACKID | WRB_COH | WRB_L2ALLOC | DF_PTR_L2ALLOC | UNUSED | Data Length | UNUSED | 35 MSB of address of packet descriptor data structure | UNUSED |
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ *    3       7         1          1               1            5           1          5                                35                              5
+ *
+ * Addresses assumed to be cache-line aligned, i.e., Address[4:0] ignored (using 5'h00 instead)
+ *
+ * Control length is the number of control cachelines to be read so user needs to round up
+ * the control length to closest integer multiple of 32 bytes. Note that at present (03/18/04)
+ * the longest (sensical) ctrl structure is <= 128 bytes.
+ *
+ * The packet descriptor data structure size is fixed at 1 cacheline (32 bytes).
+ * This effectively makes "Data Length" a Load/NoLoad bit. NoLoad causes an abort.
+ *
+ *
+ * Upon completion of operation, the security block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49   48   47               40 39                                                  0
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 | Instruction Error |    Address of control descriptor data structure     |
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 |     Data Error    |    Address of packet descriptor data structure      |
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ *
+ * The Instruction and Data Error codes are enumerated in the 
+ * ControlDescriptor and PacketDescriptor sections below
+ *
+ *
+ *                                              /----------------------------------------\
+ *                                              |                                        |
+ *                                              |   ControlDescriptor_s datastructure    |
+ *                                              |                                        |
+ *                                              \----------------------------------------/
+ *
+ *
+ *       ControlDescriptor_t.Instruction
+ *       -------------------------------
+ *
+ *   63        37   36   35   34    32 31  29 28         27 26           24
+ *  ------------------------------------------------------------------------
+ * ||   UNUSED   || V || E/D | Cipher | Mode | Init_Cipher | Cipher_Offset ||   ... CONT ...
+ *  ------------------------------------------------------------------------
+ *        28        1     1      3       3          2              3        
+ *               <CTRL><--------------------CIPHER----------------------->
+ *
+ *
+ *     23   22  21      20     19         18     17        16    15   14 13           2 1         0
+ *  -----------------------------------------------------------------------------------------------
+ * || HMAC | Hash | Init_Hash | Hash_Offset | Hash_Src || CkSum |  N/U  | CkSum_Offset | CkSum_Src ||
+ *  -----------------------------------------------------------------------------------------------
+ *     1      2         1            2            1         1       2         12            2
+ *   <-----------------------HASH--------------------->  <-----------CHECKSUM-------------------->
+ *
+ *
+ *
+ *      CTRL.V                 =        1'b0       Instruction invalid
+ *                                      1'b1       Instruction valid
+ *      CIPHER.E/D             =        1'b0       Decrypt
+ *                                      1'b1       Encrypt
+ *             Cipher          =        3'b000     Bypass
+ *                                      3'b001     DES
+ *                                      3'b010     3DES
+ *                                      3'b011     AES 128-bit key
+ *                                      3'b100     AES 192-bit key
+ *                                      3'b101     AES 256-bit key
+ *                                      Remainder  UNDEFINED
+ *             Mode            =        3'b000     ECB
+ *                                      3'b001     CBC
+ *                                      3'b010     CFB (AES only, otherwise undefined)
+ *                                      3'b011     OFB (AES only, otherwise undefined)
+ *                                      3'b100     CTR (AES only, otherwise undefined)
+ *                                      Remainder  UNDEFINED
+ *             Init_Cipher     =        2'b00      Preserve old IV/(Keys,NonceCFBMask)
+ *                                      2'b01      Load new IV use old Keys,NonceCFBMask
+ *                                      2'b10      Load new Keys,NonceCFBMask use old IV (?)
+ *                                      2'b11      Load new IV/(Keys,NonceCFBMask)
+ *             Cipher_Offset   =                   Nb of words between the first data segment 
+ *                                                 and word on which to start cipher operation
+ *                                                 (64 BIT WORDS !!!)
+ *        HASH.HMAC            =        1'b0       Hash without HMAC
+ *                                      1'b1       Hash with HMAC 
+ *             Hash            =        2'b00      Hash NOP
+ *                                      2'b01      MD5
+ *                                      2'b10      SHA-1
+ *                                      2'b11      SHA-256
+ *             Init_Hash       =        1'b0       Preserve old key HMAC key stored in ID registers (moot if HASH.HMAC == 0)
+ *                                      1'b1       Load new HMAC key from memory ctrl section to ID registers
+ *             Hash_Offset     =                   Nb of words between the first data segment
+ *                                                 and word on which to start hashing 
+ *                                                 (64 bit words)
+ *             Hash_Src        =        1'b0       DMA channel
+ *                                      1'b1       Cipher if word count exceeded Cipher_Offset; 
+ *                                                 DMA channel otherwise
+ *    CHECKSUM.CkSum           =        1'b0       CkSum NOP
+ *                                      1'b1       INTERNET_CHECKSUM
+ *             N/U             =        2'bx       Field not used
+ *             CkSum_Offset    =                   Nb of words between the first data segment 
+ *                                                 and word on which to start 
+ *                                                 checksum calculation (32 BIT WORDS !!!)
+ *             CkSum_Src       =        2'b00      DMA channel if word count exceeded CkSum_Offset
+ *                                      2'b01      Cipher if word count exceeded CkSum_Offset,
+ *                                      2'b10      UNDEFINED
+ *                                      2'b11      UNDEFINED
+ *
+ *
+ *             OLD !!!
+ *             CkSum_Src       =        2'b00      0
+ *                                      2'b01      Cipher if word count exceeded CkSum_Offset,
+ *                                                 0 otherwise
+ *                                      2'b10      DMA channel if word count exceeded 
+ *                                                 CkSum_Offset, 0 otherwise
+ *                                      2'b11      UNDEFINED
+ *
+ *
+ *       ControlDescriptor_t.cipherHashInfo.infoAES256ModeHMAC
+ *       -----------------------------------------------------
+ *  
+ *  -----------------------------------------------------------------
+ * ||63              AES Key0                                      0||
+ *  -----------------------------------------------------------------
+ *                   .
+ *                   .
+ *                   .
+ *  -----------------------------------------------------------------
+ * ||63              AES Key3                                      0||
+ *  -----------------------------------------------------------------
+ *                   .
+ *                   .
+ *                   .
+ *  -----------------------------------------------------------------
+ * ||63              HMAC Key0                                      0||
+ *  -----------------------------------------------------------------
+ *                   .
+ *                   .
+ *                   .
+ *  -----------------------------------------------------------------
+ * ||63              HMAC Key7                                      0||
+ *  -----------------------------------------------------------------
+ *
+ *   63        40  39                   8  7                       0
+ *  -----------------------------------------------------------------
+ * ||   UNUSED   || Nonce (AES/CTR only) || CFB_Mask (AES/CFB only) ||
+ *  -----------------------------------------------------------------
+ *        24                 32                       8
+ *
+ */
+
+
+/*                                              /--------------------------------------------\
+ *                                              |                                            |
+ *                                              |    New PacketDescriptor_s datastructure    |
+ *                                              |                                            |
+ *                                              \--------------------------------------------/
+ *
+ *
+ *       PacketDescriptor_t.srcLengthIVOffUseIVNext
+ *       ------------------------------------------
+ *
+ *           63           62      61             59    58        57    56       54  53           43  42    40  39                  5  4      3  2                      0
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ * || Load HMAC key || Pad Hash || Hash Byte Count || Next || Use IV || IV Offset || Packet length || UNUSED || Segment src address || UNUSED || Global src data offset || 
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
+ *           1            1           3                1        1          3              11            3             35                 2                 3
+ *
+ *
+ *             Load HMAC key           =        1'b0       Preserve old HMAC key stored in Auth engine (moot if HASH.HMAC == 0)
+ *                                              1'b1       Load HMAC key from ID registers at beginning of op
+ *             Pad Hash                =        1'b0       HASH will assume the data was padded to be a multiple
+ *                                                         of 512 bits in length and that the last 64 bit word
+ *                                                         expresses the total datalength in bits seen by HASH engine
+ *                                              1'b1       The data was not padded to be a multiple of 512 bits in length;
+ *                                                         The Hash engine will do its own padding to generate the correct digest.
+ *             Hash Byte Count                             Number of BYTES on last 64-bit data word to use in digest calculation RELEVANT ONLY IF Pad Hash IS SET
+ *                                              3'b000     Use all 8
+ *                                              3'b001     Use first (MS) byte only (0-out rest), i.e., 0xddXXXXXXXXXXXXXX
+ *                                              3'b010     Use first 2 bytes only (0-out rest), i.e., 0xddddXXXXXXXXXXXX     ... etc
+ *             Next                    =        1'b0       Finish (return msg descriptor) at end of operation
+ *                                              1'b1       Grab the next PacketDescriptor (i.e. next cache-line) - NOT YET IMPLEMENTED !!!
+ *             Use IV                  =        1'b0       Use old IV
+ *                                              1'b1       Use data @ Segment_address + IV_Offset as IV
+ *             IV Offset               =                   Offset IN NB OF 8 BYTE WORDS from beginning of packet
+ *                                                         (i.e. (Potentially shifted) Segment address) to cipher IV
+ *             Packet length           =                   Nb double words to stream in (Including Segment address->CP/IV/Auth/CkSum offsets)
+ *                                                         This is the total amount of data (x8 in bytes) read    (+1 dword if "Global src data offset" != 0)
+ *                                                         This is the total amount of data (x8 in bytes) written (+1 dword if "Global dst data offset" != 0)
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *                                                         If Packet length == 11'h7ff and (Global src data offset != 0 or Global dst data offset != 0)
+ *                                                         the operation is aborted (no mem writes occur)
+ *             Segment src address     =                   35 MSB of pointer to src data (i.e., cache-line aligned)
+ *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *
+ *       PacketDescriptor_t.dstLLWMask
+ *       -----------------------------
+ *
+ *   63    60  59                 58  57    40  39                 5  4      3  2                      0
+ *  -----------------------------------------------------------------------------------------------------
+ * || UNUSED || Last long word mask || UNUSED || Cipher dst address || UNUSED || Global dst data offset ||
+ *  -----------------------------------------------------------------------------------------------------
+ *      4                2               18              35              2                 3
+ *
+ *
+ *             Last long word mask     =   2'b00      Give last 128 bit word to AES/HAMC/CKSUM engines as is
+ *                                         2'b11      Mask (zero-out) 32 least significant bits
+ *                                         2'b10      Mask 64 LSBs
+ *                                         2'b01      Mask 96 LSBs
+ *             Cipher dst address      =              35 MSB of pointer to dst location (i.e., cache-line aligned)
+ *             Global dst data offset  =              Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+ *
+ * Upon completion of operation, the Sec block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49  48          40 39             0
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address |
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   |
+ *  ----------------------------------------------------------------------------
+ *
+ * The Control and Data Error codes are enumerated below
+ *
+
+*
+ * Component strcts and unions defining CipherHashInfo_u
+ */
+
+/* All AES256 possibilities */
+ /* AES256, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-256)      - 104 bytes */
+typedef struct AES256ModeHMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             cipherKey3;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+  uint64_t             nonceCFBMask;
+} AES256ModeHMAC_t, *AES256ModeHMAC_pt;
+
+/* AES256, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-256)  - 40  bytes */
+typedef struct AES256Mode_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             cipherKey3;
+  uint64_t             nonceCFBMask;
+} AES256Mode_t, *AES256Mode_pt;
+
+/* AES256, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-256)      - 96  bytes */
+typedef struct AES256HMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             cipherKey3;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} AES256HMAC_t, *AES256HMAC_pt;
+
+/* AES256, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct AES256_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             cipherKey3;
+} AES256_t, *AES256_pt;
+
+
+/* All AES192 possibilities */
+
+/* AES192, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-192)      - 96  bytes */
+typedef struct AES192ModeHMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+  uint64_t             nonceCFBMask;
+} AES192ModeHMAC_t, *AES192ModeHMAC_pt;
+
+/* AES192, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-192)  - 32  bytes */
+typedef struct AES192Mode_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             nonceCFBMask;
+} AES192Mode_t, *AES192Mode_pt;
+
+/* AES192, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-192)      - 88  bytes */
+typedef struct AES192HMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} AES192HMAC_t, *AES192HMAC_pt;
+
+/* AES192, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-192)  - 24  bytes */
+typedef struct AES192_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+} AES192_t, *AES192_pt;
+
+
+/* All AES128 possibilities */
+
+/* AES128, (CTR or CFB),    HMAC (MD5, SHA-1, SHA-128)      - 88  bytes */
+typedef struct AES128ModeHMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+  uint64_t             nonceCFBMask;
+} AES128ModeHMAC_t, *AES128ModeHMAC_pt;
+
+/* AES128, (CTR or CFB),    Non-HMAC (MD5, SHA-1, SHA-128)  - 24  bytes */
+typedef struct AES128Mode_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             nonceCFBMask;
+} AES128Mode_t, *AES128Mode_pt;
+
+/* AES128, (ECB, CBC, OFB), HMAC (MD5, SHA-1, SHA-128)      - 80  bytes */
+typedef struct AES128HMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} AES128HMAC_t, *AES128HMAC_pt;
+
+/* AES128, (ECB, CBC, OFB), Non-HMAC (MD5, SHA-1, SHA-128)  - 16  bytes */
+typedef struct AES128_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+} AES128_t, *AES128_pt;
+
+
+/* All DES possibilities */
+
+/* DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)              - 72  bytes */
+typedef struct DESHMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} DESHMAC_t, *DESHMAC_pt;
+
+/* DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)          - 9   bytes */
+typedef struct DES_s {
+  uint64_t             cipherKey0;
+} DES_t, *DES_pt;
+
+
+/* All 3DES possibilities */
+
+/* 3DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)             - 88  bytes */
+typedef struct TriDESHMAC_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} TriDESHMAC_t, *TriDESHMAC_pt;
+
+/* 3DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)         - 24  bytes */
+typedef struct TriDES_s {
+  uint64_t             cipherKey0;
+  uint64_t             cipherKey1;
+  uint64_t             cipherKey2;
+} TriDES_t, *TriDES_pt;
+
+
+/* HMAC only - no cipher */
+
+/* HMAC (MD5, SHA-1, SHA-128)                               - 64  bytes */
+typedef struct HMAC_s {
+  uint64_t             hmacKey0;
+  uint64_t             hmacKey1;
+  uint64_t             hmacKey2;
+  uint64_t             hmacKey3;
+  uint64_t             hmacKey4;
+  uint64_t             hmacKey5;
+  uint64_t             hmacKey6;
+  uint64_t             hmacKey7;
+} HMAC_t, *HMAC_pt;
+
+typedef union CipherHashInfo_u {
+  AES256ModeHMAC_t     infoAES256ModeHMAC;
+  AES256Mode_t         infoAES256Mode;
+  AES256HMAC_t         infoAES256HMAC;
+  AES256_t             infoAES256;
+  AES192ModeHMAC_t     infoAES192ModeHMAC;
+  AES192Mode_t         infoAES192Mode;
+  AES192HMAC_t         infoAES192HMAC;
+  AES192_t             infoAES192;
+  AES128ModeHMAC_t     infoAES128ModeHMAC;
+  AES128Mode_t         infoAES128Mode;
+  AES128HMAC_t         infoAES128HMAC;
+  AES128_t             infoAES128;
+  DESHMAC_t            infoDESHMAC;
+  DES_t                infoDES;
+  TriDESHMAC_t         info3DESHMAC;
+  TriDES_t             info3DES;
+  HMAC_t               infoHMAC;
+  uint64_t             infoDwords[12];
+} CipherHashInfo_t, *CipherHashInfo_pt;
+
+/*
+ * This defines the security control descriptor format
+ */
+typedef struct ControlDescriptor_s {
+  uint64_t            instruction;
+  CipherHashInfo_t    cipherHashInfo;
+} ControlDescriptor_t, *ControlDescriptor_pt;
+
+/*
+ * This defines the security data descriptor format
+ */
+typedef struct PacketDescriptor_s {
+  uint64_t             srcLengthIVOffUseIVNext;
+  uint64_t             dstLLWMask;
+  uint64_t             authDst;
+  uint64_t             ckSumDst;
+} PacketDescriptor_t, *PacketDescriptor_pt;
+
+#define SEC_CTRL_ERR_NONE                    0x000
+#define SEC_CTRL_ERR_UNKNOWN_CIPHER_OP       0x001
+#define SEC_CTRL_ERR_ILLEGAL_MODE            0x002
+#define SEC_CTRL_ERR_UNSUPP_CKSUM_SRC        0x004
+#define SEC_CTRL_ERR_FORBIDDEN_CFB_MASK      0x008
+#define SEC_CTRL_ERR_UNKNOWN_CTRL_OP         0x010
+#define SEC_CTRL_ERR_DATA_READ               0x080
+#define SEC_CTRL_ERR_DESC_CTRL_FIELD         0x100
+
+#define SEC_PKT_ERR_NONE                     0x000
+#define SEC_PKT_ERR_INSUFF_DATA_TO_CIPHER    0x001
+#define SEC_PKT_ERR_ILLEGAL_IV_LOCATION      0x002
+#define SEC_PKT_ERR_ILLEGAL_WORDCOUNT_AES    0x004
+#define SEC_PKT_ERR_ILLEGAL_PAD_BYTECOUNT_SPEC 00x8
+#define SEC_PKT_ERR_INSUFF_DATA_TO_CKSUM       0x010
+#define SEC_PKT_ERR_UNKNOWN_DATA_OP            0x020
+#define SEC_PKT_ERR_INSUFF_DATA_TO_AUTH        0x040
+#define SEC_PKT_ERR_DATA_READ                  0x080
+
+#define HASH_NOP    0
+#define HASH_MD5    1
+#define HASH_SHA1   2
+#define HASH_SHA256 3
+
+static __inline__ int make_sec_desc(struct msgrng_msg *msg, void *ctrl_addr, int ctrl_len, void *data_addr)
+{
+  int stid = MSGRNG_STNID_SEC0;
+  msg->msg0 = ( ((uint64_t)SEC_SOP<<61)  | 
+		((uint64_t)4<<54) |
+		((uint64_t)ctrl_len<<45) |
+		((uint64_t)virt_to_phys(ctrl_addr) & 0xffffffffe0ULL)
+		);
+  msg->msg1 = ( ((uint64_t)SEC_EOP<<61)  | 
+		((uint64_t)4<<54) |
+		((uint64_t)1<<45) |
+		((uint64_t)virt_to_phys(data_addr) & 0xffffffffe0ULL)
+		);
+  msg->msg2 = msg->msg3 = 0;
+
+  return stid;
+}
+
+#endif
diff --git a/include/asm-mips/rmi/phoenix_shim_drv.h b/include/asm-mips/rmi/phoenix_shim_drv.h
new file mode 100644
index 0000000..28f8545
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_shim_drv.h
@@ -0,0 +1,510 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _SHIM_H_
+#define _SHIM_H_
+
+#define DEBUG   1
+
+extern int debug_var;
+
+#ifdef DEBUG
+#define debug(level, fmt, args...) \
+	if (debug_var&level) printk(KERN_INFO fmt, ## args)
+#else
+#define debug(fmt, args...)
+#endif
+#define DEBUG_TRACE     0x8000
+#define DEBUG_INFO      0x4000
+#define DEBUG_TX_FSM    0x2000
+#define DEBUG_RX_FSM    0x1000
+#define DEBUG_REG_WRITE 0x0800
+#define DEBUG_ENTRY     0x0400
+#define DEBUG_EXIT      0x0200
+#define DEBUG_DSCR      0x0100
+#define DEBUG_ERROR     0x0080
+
+#define ENTRY_LO(v) ((uint32_t)(v&0xffffffff))
+#define ENTRY_HI(v) ((uint32_t)((v>>32)&0xffffffff))
+
+#define SHIM_OK     0
+#define SHIM_ERROR  -1
+
+/**********************************************************************
+ *  DMA Descriptor structure
+ ********************************************************************* */
+
+typedef struct shimdscr_s {
+	uint64_t  dscr_a;
+	uint64_t  dscr_b;
+} shimdscr_t;
+
+typedef unsigned long paddr_t;
+typedef unsigned long vaddr_t;
+typedef unsigned long shim_port_t;
+
+/**********************************************************************
+ *  DMA Controller structure
+ ********************************************************************* */
+
+typedef struct shim_cb_s {
+    int             shim_macnum;
+	int             shim_channel;	/* channel number */
+	int		        shim_txdir;     /* direction (1=transmit) */
+	int		        shim_maxdescr;	/* total # of descriptors in ring */
+	shim_port_t     shim_config0;	/* DMA config register 0 */
+	shim_port_t     shim_config1;	/* DMA config register 1 */
+	shim_port_t     shim_dscrbase;	/* Descriptor base address */
+	shim_port_t     shim_dscrcnt;   /* Descriptor count register */
+	shim_port_t     shim_curdscr;	/* current descriptor address */
+	shim_port_t     shim_dscraddcnt;/* Descriptor add count register */
+
+    /* This stuff is for maintenance of the ring */
+	
+	shimdscr_t     *shim_dscrtable;	/* base of descriptor table */
+	shimdscr_t     *shim_dscrtable_end; /* end of descriptor table */
+
+    struct packet **shim_ctxtable;
+
+    paddr_t         shim_dscrtable_phys; /* and also the phys addr */
+    shimdscr_t     *shim_addptr;  /* next dscr for sw to add */
+    shimdscr_t     *shim_remptr;  /* next dscr for sw to remove */
+    int             fsm_state;
+    int             shim_ready;    /* Activated by driver */
+    int             rcv_buf_full;   /* When set do not issue msgld */
+} shim_cb_t;
+
+#define SHIM_READCSR(t)    (*(uint64_t*)(t))
+#define SHIM_WRITECSR(t,v) (*(uint64_t*)(t) = v)
+#define SHIM_NEXTBUF(d,f) ((((d)->f+1) == (d)->shim_dscrtable_end) ? \
+              (d)->shim_dscrtable : (d)->f+1)
+#define SHIM_MAC_TYPE(macnum) ((macnum < MAC_MAX_GMAC) ? GMAC : XGMAC)
+#define SHIM_MAC_ID(macnum)   ((macnum < MAC_MAX_GMAC) ? macnum :\
+                             (macnum - MAC_MAX_GMAC))
+#define SHIM_GET_CB(macnum, txrx, chan) &shim_cb[macnum][txrx][chan]
+#define SHIM_CURDSCR(p) ((shimdscr_t *)(uint32_t)\
+                SHIM_READCSR(p->shim_curdscr))
+
+
+
+#define SHIM_ST_INVALID     -1
+#define SHIM_TR_INVALID     -1
+#define SHIM_EV_INVALID     -1
+
+/*
+ *  Finite State machine States
+ *
+ *  Count of non-terminal states.  The generated states INVALID and DONE
+ *  are terminal, but INIT is not  :-).
+ */
+#define SHIM_TX_STATE_CT 3 
+#define SHIM_TX_EVENT_CT 5
+typedef enum {
+    SHIM_ST_TX_INIT,
+    SHIM_ST_TX_ACTIVE,
+    SHIM_ST_TX_PAUSE,  
+} te_shim_tx_state;
+
+typedef enum {
+    SHIM_EV_TX_RESET,     
+    SHIM_EV_TX_CPU_PAUSE_EN,    
+    SHIM_EV_TX_CPU_RESUME,
+    SHIM_EV_TX_DSCR_CNT,
+    SHIM_EV_TX_ADD_DSCR_CNT,
+} te_shim_tx_event;
+
+#define SHIM_RX_STATE_CT 2
+#define SHIM_RX_EVENT_CT 4
+
+typedef enum {
+    SHIM_ST_RX_INIT,
+    SHIM_ST_RX_ACTIVE,
+} te_shim_rx_state;
+
+typedef enum {
+    SHIM_EV_RX_RESET,     
+    SHIM_EV_RX_DSCR_CNT,
+    SHIM_EV_RX_DSCR_ADD_CNT,
+    SHIM_EV_RX_PKT_FROM_MSGRNG
+} te_shim_rx_event;
+
+
+/*
+ *  Run the FSM.  Will return SHIM_ST_DONE or SHIM_ST_INVALID
+ */
+int shim_run_rx_fsm(shim_cb_t *shim_cb_p, int trans_evt);
+int shim_run_tx_fsm(shim_cb_t *shim_cb_p, int trans_evt);
+
+        
+/*
+ * Cast to 64-bit number.  Presumably the syntax is different in 
+ * assembly language.
+ *
+ * Note: you'll need to define uint32_t and uint64_t in your headers.
+ */
+
+#if !defined(__ASSEMBLER__)
+#define _SHIM_MAKE64(x) ((uint64_t)(x))
+#define _SHIM_MAKE32(x) ((uint32_t)(x))
+#else
+#define _SHIM_MAKE64(x) (x)
+#define _SHIM_MAKE32(x) (x)
+#endif
+
+
+/*
+ * Make a mask for 1 bit at position 'n'
+ */
+
+#define _SHIM_MAKEMASK1(n) (_SHIM_MAKE64(1) << _SHIM_MAKE64(n))
+#define _SHIM_MAKEMASK1_32(n) (_SHIM_MAKE32(1) << _SHIM_MAKE32(n))
+
+/*
+ * Make a mask for 'v' bits at position 'n'
+ */
+
+#define _SHIM_MAKEMASK(v,n) (_SHIM_MAKE64((_SHIM_MAKE64(1)<<(v))-1) << _SHIM_MAKE64(n))
+#define _SHIM_MAKEMASK_32(v,n) (_SHIM_MAKE32((_SHIM_MAKE32(1)<<(v))-1) << _SHIM_MAKE32(n))
+
+/*
+ * Make a value at 'v' at bit position 'n'
+ */
+
+#define _SHIM_MAKEVALUE(v,n) (_SHIM_MAKE64(v) << _SHIM_MAKE64(n))
+#define _SHIM_MAKEVALUE_32(v,n) (_SHIM_MAKE32(v) << _SHIM_MAKE32(n))
+
+#define _SHIM_GETVALUE(v,n,m) ((_SHIM_MAKE64(v) & _SHIM_MAKE64(m)) >> _SHIM_MAKE64(n))
+#define _SHIM_GETVALUE_32(v,n,m) ((_SHIM_MAKE32(v) & _SHIM_MAKE32(m)) >> _SHIM_MAKE32(n))
+
+/*
+ * Macros to read/write on-chip registers
+ * XXX should we do the PHYS_TO_K1 here?
+ */
+
+
+#if !defined(__ASSEMBLER__)
+#define SHIMWRITECSR(csr,val) *((volatile uint64_t *) PHYS_TO_K1(csr)) = (val)
+#define SHIMREADCSR(csr) (*((volatile uint64_t *) PHYS_TO_K1(csr)))
+#endif /* __ASSEMBLER__ */
+
+
+/*  *********************************************************************
+    *  SHIM Registers
+    ********************************************************************* */
+
+/* 
+ * Ethernet Configuration Register 0  
+ * Registers: DMA_CONFIG0_MAC_x_RX_CH_0 
+ * Registers: DMA_CONFIG0_MAC_x_TX_CH_0
+ */
+
+
+#define M_SHIM_DROP                  _SHIM_MAKEMASK1(0)
+#define M_SHIM_CHAIN_SEL             _SHIM_MAKEMASK1(1)
+#define M_SHIM_RESERVED1             _SHIM_MAKEMASK1(2)
+#define M_SHIM_EOP_INT_EN            _SHIM_MAKEMASK1(3)
+#define M_SHIM_HWM_INT_EN            _SHIM_MAKEMASK1(4)
+#define M_SHIM_LWM_INT_EN            _SHIM_MAKEMASK1(5)
+#define M_SHIM_TBX_EN                _SHIM_MAKEMASK1(6)
+#define M_SHIM_TDX_EN                _SHIM_MAKEMASK1(7)
+
+#define S_SHIM_INT_PKTCNT            _SHIM_MAKE64(8)
+#define M_SHIM_INT_PKTCNT            _SHIM_MAKEMASK(8,S_SHIM_INT_PKTCNT)
+#define V_SHIM_INT_PKTCNT(x)         _SHIM_MAKEVALUE(x,S_SHIM_INT_PKTCNT)
+#define G_SHIM_INT_PKTCNT(x)         _SHIM_GETVALUE(x,S_SHIM_INT_PKTCNT,M_SHIM_INT_PKTCNT)
+
+#define S_SHIM_RINGSZ                _SHIM_MAKE64(16)
+#define M_SHIM_RINGSZ                _SHIM_MAKEMASK(16,S_SHIM_RINGSZ)
+#define V_SHIM_RINGSZ(x)             _SHIM_MAKEVALUE(x,S_SHIM_RINGSZ)
+#define G_SHIM_RINGSZ(x)             _SHIM_GETVALUE(x,S_SHIM_RINGSZ,M_SHIM_RINGSZ)
+
+#define S_SHIM_HIGH_WATERMARK        _SHIM_MAKE64(32)
+#define M_SHIM_HIGH_WATERMARK        _SHIM_MAKEMASK(16,S_SHIM_HIGH_WATERMARK)
+#define V_SHIM_HIGH_WATERMARK(x)     _SHIM_MAKEVALUE(x,S_SHIM_HIGH_WATERMARK)
+#define G_SHIM_HIGH_WATERMARK(x)     _SHIM_GETVALUE(x,S_SHIM_HIGH_WATERMARK,M_SHIM_HIGH_WATERMARK)
+
+#define S_SHIM_LOW_WATERMARK         _SHIM_MAKE64(48)
+#define M_SHIM_LOW_WATERMARK         _SHIM_MAKEMASK(16,S_SHIM_LOW_WATERMARK)
+#define V_SHIM_LOW_WATERMARK(x)      _SHIM_MAKEVALUE(x,S_SHIM_LOW_WATERMARK)
+#define G_SHIM_LOW_WATERMARK(x)      _SHIM_GETVALUE(x,S_SHIM_LOW_WATERMARK,M_SHIM_LOW_WATERMARK)
+
+/*
+ * Ethernet Configuration Register 1 
+ * Registers: DMA_CONFIG1_MAC_x_RX_CH_0 
+ * Registers: DMA_CONFIG1_SHIM_x_TX_CH_0
+ */
+
+#define M_SHIM_HDR_CF_EN             _SHIM_MAKEMASK1(0)
+#define M_SHIM_ASIC_XFR_EN           _SHIM_MAKEMASK1(1)
+#define M_SHIM_PRE_ADDR_EN           _SHIM_MAKEMASK1(2)
+#define M_SHIM_FLOW_CTL_EN           _SHIM_MAKEMASK1(3)
+#define M_SHIM_NO_DSCR_UPDT          _SHIM_MAKEMASK1(4)
+#define M_SHIM_L2CA		    _SHIM_MAKEMASK1(5)
+#define M_SHIM_CPU_PAUSE_EN		    _SHIM_MAKEMASK1(6)
+
+#define M_SHIM_MBZ1                  _SHIM_MAKEMASK(6,15)
+
+#define S_SHIM_HDR_SIZE              _SHIM_MAKE64(21)
+#define M_SHIM_HDR_SIZE              _SHIM_MAKEMASK(9,S_SHIM_HDR_SIZE)
+#define V_SHIM_HDR_SIZE(x)           _SHIM_MAKEVALUE(x,S_SHIM_HDR_SIZE)
+#define G_SHIM_HDR_SIZE(x)           _SHIM_GETVALUE(x,S_SHIM_HDR_SIZE,M_SHIM_HDR_SIZE)
+
+#define M_SHIM_MBZ2                  _SHIM_MAKEMASK(5,32)
+
+#define S_SHIM_ASICXFR_SIZE          _SHIM_MAKE64(37)
+#define M_SHIM_ASICXFR_SIZE          _SHIM_MAKEMASK(9,S_SHIM_ASICXFR_SIZE)
+#define V_SHIM_ASICXFR_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_ASICXFR_SIZE)
+#define G_SHIM_ASICXFR_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_ASICXFR_SIZE,M_SHIM_ASICXFR_SIZE)
+
+#define S_SHIM_INT_TIMEOUT           _SHIM_MAKE64(48)
+#define M_SHIM_INT_TIMEOUT           _SHIM_MAKEMASK(16,S_SHIM_INT_TIMEOUT)
+#define V_SHIM_INT_TIMEOUT(x)        _SHIM_MAKEVALUE(x,S_SHIM_INT_TIMEOUT)
+#define G_SHIM_INT_TIMEOUT(x)        _SHIM_GETVALUE(x,S_SHIM_INT_TIMEOUT,M_SHIM_INT_TIMEOUT)
+
+/*
+ * Ethernet Descriptor base address 
+ */
+
+#define M_SHIM_DSCRBASE_MBZ          _SHIM_MAKEMASK(4,0)
+#define M_SHIM_DSCRBASE              _SHIM_MAKEMASK(36,4)
+
+
+/* 
+ * Current Descriptor Address Register 
+ */
+
+#define S_SHIM_CURDSCR_ADDR          _SHIM_MAKE64(0)
+#define M_SHIM_CURDSCR_ADDR          _SHIM_MAKEMASK(40,S_SHIM_CURDSCR_ADDR)
+#define S_SHIM_CURDSCR_COUNT         _SHIM_MAKE64(0)
+#define M_SHIM_CURDSCR_COUNT         _SHIM_MAKEMASK(16,S_SHIM_CURDSCR_COUNT)
+
+#define M_SHIM_CURDSCR_ADD_COUNT     M_SHIM_CURDSCR_COUNT
+
+/*  ********************************************************************* 
+    * Ethernet, MAC is not used
+    ********************************************************************* */
+
+#define A_MAC_BASE_0               0 
+
+#define MAC_SPACING                 0x1000
+#define SHIM_TXRX_SPACING        0x0400
+#define SHIM_CHANNEL_SPACING     0x0100
+#define SHIM_RX                      0
+#define SHIM_TX                      1
+#define MAX_SHIM_TXRX                2
+#define MAC_NUM_SHIMCHAN         2           /* channels per direction */
+
+#define MAC_NUM_PORTS               6
+#define MAC_MAX_GMAC                4
+
+#define A_MAC_CHANNEL_BASE(macnum)                  \
+            (A_MAC_BASE_0 +                         \
+             MAC_SPACING*(macnum))
+
+#define R_SHIM_CHANNELS      0x800 /* Relative to A_MAC_CHANNEL_BASE */
+
+#define A_SHIM_CHANNEL_BASE(macnum,txrx,chan)    \
+             ((A_MAC_CHANNEL_BASE(macnum)) +        \
+             R_SHIM_CHANNELS +                   \
+             (SHIM_TXRX_SPACING*(txrx)) +        \
+             (SHIM_CHANNEL_SPACING*(chan)))
+
+#define R_SHIM_CHANNEL_BASE(txrx,chan)    \
+             (R_SHIM_CHANNELS +                   \
+             (SHIM_TXRX_SPACING*(txrx)) +        \
+             (SHIM_CHANNEL_SPACING*(chan)))
+
+#define A_SHIM_REGISTER(macnum,txrx,chan,reg)           \
+            (A_SHIM_CHANNEL_BASE(macnum,txrx,chan) +    \
+            (reg))
+
+#define R_SHIM_REGISTER(txrx,chan,reg)           \
+            (R_SHIM_CHANNEL_BASE(txrx,chan) +    \
+            (reg))
+
+#define I_SHIM_REGISTER(macnum,txrx,chan,reg)\
+            ((A_SHIM_CHANNEL_BASE(macnum,txrx,chan) +    \
+            (reg))/sizeof(unsigned long long int))
+/* 
+ * SHIM channel registers, relative to A_SHIM_CHANNEL_BASE
+ */
+
+#define R_SHIM_CONFIG0               0x00000000
+#define R_SHIM_CONFIG1               0x00000008
+#define R_SHIM_DSCR_BASE             0x00000010
+#define R_SHIM_DSCR_CNT              0x00000018
+#define R_SHIM_CUR_DSCRA             0x00000020
+#define R_SHIM_CUR_DSCRB             0x00000028
+#define R_SHIM_CUR_DSCRADDR          0x00000030
+#define R_SHIM_DSCR_ADD_CNT          0x00000038
+
+
+/*  *********************************************************************
+    *  DMA Descriptors
+    ********************************************************************* */
+
+/*
+ * Descriptor doubleword "A"  (Table 7-12)
+ */
+
+#define S_SHIM_DSCRA_OFFSET          _SHIM_MAKE64(0)
+#define M_SHIM_DSCRA_OFFSET          _SHIM_MAKEMASK(5,S_SHIM_DSCRA_OFFSET)
+
+/* Note: Don't shift the address over, just mask it with the mask below */
+#define S_SHIM_DSCRA_A_ADDR          _SHIM_MAKE64(5)
+#define M_SHIM_DSCRA_A_ADDR          _SHIM_MAKEMASK(35,S_SHIM_DSCRA_A_ADDR)
+
+#define M_SHIM_DSCRA_A_ADDR_OFFSET   (M_SHIM_DSCRA_OFFSET | M_SHIM_DSCRA_A_ADDR)
+
+#define S_SHIM_DSCRA_A_ADDR_UA        _SHIM_MAKE64(0)
+#define M_SHIM_DSCRA_A_ADDR_UA        _SHIM_MAKEMASK(40,S_SHIM_DSCRA_A_ADDR_UA)
+
+#define S_SHIM_DSCRA_A_SIZE          _SHIM_MAKE64(40)
+#define M_SHIM_DSCRA_A_SIZE          _SHIM_MAKEMASK(9,S_SHIM_DSCRA_A_SIZE)
+#define V_SHIM_DSCRA_A_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRA_A_SIZE)
+#define G_SHIM_DSCRA_A_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRA_A_SIZE,M_SHIM_DSCRA_A_SIZE)
+
+#define M_SHIM_DSCRA_INTERRUPT       _SHIM_MAKEMASK1(49)
+#define M_SHIM_DSCRA_OFFSETB	    _SHIM_MAKEMASK1(50)
+
+#define S_SHIM_DSCRA_STATUS          _SHIM_MAKE64(51)
+#define M_SHIM_DSCRA_STATUS          _SHIM_MAKEMASK(13,S_SHIM_DSCRA_STATUS)
+#define V_SHIM_DSCRA_STATUS(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRA_STATUS)
+#define G_SHIM_DSCRA_STATUS(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRA_STATUS,M_SHIM_DSCRA_STATUS)
+
+/*
+ * Descriptor doubleword "B"  (Table 7-13)
+ */
+
+
+#define S_SHIM_DSCRB_OPTIONS         _SHIM_MAKE64(0)
+#define M_SHIM_DSCRB_OPTIONS         _SHIM_MAKEMASK(4,S_SHIM_DSCRB_OPTIONS)
+#define V_SHIM_DSCRB_OPTIONS(x)      _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_OPTIONS)
+#define G_SHIM_DSCRB_OPTIONS(x)      _SHIM_GETVALUE(x,S_SHIM_DSCRB_OPTIONS,M_SHIM_DSCRB_OPTIONS)
+
+#define R_SHIM_DSCRB_ADDR            _SHIM_MAKE64(0x10)
+
+/* Note: Don't shift the address over, just mask it with the mask below */
+#define S_SHIM_DSCRB_B_ADDR          _SHIM_MAKE64(5)
+#define M_SHIM_DSCRB_B_ADDR          _SHIM_MAKEMASK(35,S_SHIM_DSCRB_B_ADDR)
+
+#define S_SHIM_DSCRB_B_SIZE          _SHIM_MAKE64(40)
+#define M_SHIM_DSCRB_B_SIZE          _SHIM_MAKEMASK(9,S_SHIM_DSCRB_B_SIZE)
+#define V_SHIM_DSCRB_B_SIZE(x)       _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_B_SIZE)
+#define G_SHIM_DSCRB_B_SIZE(x)       _SHIM_GETVALUE(x,S_SHIM_DSCRB_B_SIZE,M_SHIM_DSCRB_B_SIZE)
+
+#define M_SHIM_DSCRB_B_VALID         _SHIM_MAKEMASK1(49)
+
+#define S_SHIM_DSCRB_PKT_SIZE        _SHIM_MAKE64(50)
+#define M_SHIM_DSCRB_PKT_SIZE        _SHIM_MAKEMASK(14,S_SHIM_DSCRB_PKT_SIZE)
+#define V_SHIM_DSCRB_PKT_SIZE(x)     _SHIM_MAKEVALUE(x,S_SHIM_DSCRB_PKT_SIZE)
+#define G_SHIM_DSCRB_PKT_SIZE(x)     _SHIM_GETVALUE(x,S_SHIM_DSCRB_PKT_SIZE,M_SHIM_DSCRB_PKT_SIZE)
+
+/* 
+ * Ethernet Descriptor Status Bits (Table 7-15)
+ */
+
+#define M_SHIM_ETHRX_BADIP4CS        _SHIM_MAKEMASK1(51)
+#define M_SHIM_ETHRX_DSCRERR	    _SHIM_MAKEMASK1(52)
+
+#define S_SHIM_ETHRX_RXCH            53
+#define M_SHIM_ETHRX_RXCH            _SHIM_MAKEMASK(2,S_SHIM_ETHRX_RXCH)
+#define V_SHIM_ETHRX_RXCH(x)         _SHIM_MAKEVALUE(x,S_SHIM_ETHRX_RXCH)
+#define G_SHIM_ETHRX_RXCH(x)         _SHIM_GETVALUE(x,S_SHIM_ETHRX_RXCH,M_SHIM_ETHRX_RXCH)
+
+#define S_SHIM_ETHRX_PKTTYPE         55
+#define M_SHIM_ETHRX_PKTTYPE         _SHIM_MAKEMASK(3,S_SHIM_ETHRX_PKTTYPE)
+#define V_SHIM_ETHRX_PKTTYPE(x)      _SHIM_MAKEVALUE(x,S_SHIM_ETHRX_PKTTYPE)
+#define G_SHIM_ETHRX_PKTTYPE(x)      _SHIM_GETVALUE(x,S_SHIM_ETHRX_PKTTYPE,M_SHIM_ETHRX_PKTTYPE)
+
+#define K_SHIM_ETHRX_PKTTYPE_IPV4    0
+#define K_SHIM_ETHRX_PKTTYPE_ARPV4   1
+#define K_SHIM_ETHRX_PKTTYPE_802     2
+#define K_SHIM_ETHRX_PKTTYPE_OTHER   3
+#define K_SHIM_ETHRX_PKTTYPE_USER0   4
+#define K_SHIM_ETHRX_PKTTYPE_USER1   5
+#define K_SHIM_ETHRX_PKTTYPE_USER2   6
+#define K_SHIM_ETHRX_PKTTYPE_USER3   7
+
+#define M_SHIM_ETHRX_MATCH_EXACT     _SHIM_MAKEMASK1(58)
+#define M_SHIM_ETHRX_MATCH_HASH      _SHIM_MAKEMASK1(59)
+#define M_SHIM_ETHRX_BCAST           _SHIM_MAKEMASK1(60)
+#define M_SHIM_ETHRX_MCAST           _SHIM_MAKEMASK1(61)
+#define M_SHIM_ETHRX_BAD	            _SHIM_MAKEMASK1(62)
+#define M_SHIM_ETHRX_SOP             _SHIM_MAKEMASK1(63)
+
+/*
+ * Ethernet Transmit Status Bits (Table 7-16)
+ */
+
+#define M_SHIM_ETHTX_SOP	    	    _SHIM_MAKEMASK1(63)
+
+/* 
+ * Ethernet Transmit Options (Table 7-17)
+ */
+
+#define K_SHIM_ETHTX_NOTSOP          _SHIM_MAKE64(0x00)
+#define K_SHIM_ETHTX_APPENDCRC       _SHIM_MAKE64(0x01)
+#define K_SHIM_ETHTX_REPLACECRC      _SHIM_MAKE64(0x02)
+#define K_SHIM_ETHTX_APPENDCRC_APPENDPAD _SHIM_MAKE64(0x03)
+#define K_SHIM_ETHTX_APPENDVLAN_REPLACECRC _SHIM_MAKE64(0x04)
+#define K_SHIM_ETHTX_REMOVEVLAN_REPLACECRC _SHIM_MAKE64(0x05)
+#define K_SHIM_ETHTX_REPLACEVLAN_REPLACECRC _SHIM_MAKE64(0x6)
+#define K_SHIM_ETHTX_NOMODS          _SHIM_MAKE64(0x07)
+#define K_SHIM_ETHTX_RESERVED1       _SHIM_MAKE64(0x08)
+#define K_SHIM_ETHTX_REPLACESADDR_APPENDCRC _SHIM_MAKE64(0x09)
+#define K_SHIM_ETHTX_REPLACESADDR_REPLACECRC _SHIM_MAKE64(0x0A)
+#define K_SHIM_ETHTX_REPLACESADDR_APPENDCRC_APPENDPAD _SHIM_MAKE64(0x0B)
+#define K_SHIM_ETHTX_REPLACESADDR_APPENDVLAN_REPLACECRC _SHIM_MAKE64(0x0C)
+#define K_SHIM_ETHTX_REPLACESADDR_REMOVEVLAN_REPLACECRC _SHIM_MAKE64(0x0D)
+#define K_SHIM_ETHTX_REPLACESADDR_REPLACEVLAN_REPLACECRC _SHIM_MAKE64(0x0E)
+#define K_SHIM_ETHTX_RESERVED2       _SHIM_MAKE64(0x0F)
+
+#define S_MAC_RX_CH0                _SHIM_MAKE64(0)
+#define S_MAC_RX_CH1                _SHIM_MAKE64(8)
+#define S_MAC_TX_CH0                _SHIM_MAKE64(16)
+#define S_MAC_TX_CH1                _SHIM_MAKE64(24)
+
+#define M_MAC_INT_CHANNEL           _SHIM_MAKEMASK(8,0)
+#define R_MAC_ENABLE                    0x00000400
+#define R_MAC_STATUS                    0x00000408
+#define R_MAC_ETHERNET_ADDR             0x00000208
+        
+extern shim_cb_t shim_cb[MAC_NUM_PORTS][MAX_SHIM_TXRX][MAC_NUM_SHIMCHAN];
+/* Register file holding all register values, in a fixed location */
+extern uint64_t reg_file[MAC_SPACING * MAC_NUM_PORTS];
+int shim_handle_rx_pkt_from_msgrng(shim_cb_t *shim_cb_p);
+int shim_handle_reset(shim_cb_t *shim_cb_p);
+int shim_handle_tx_dscr_cnt(shim_cb_t *shim_cb_p);
+int shim_handle_tx_cpu_pause_en(shim_cb_t *shim_cb_p);
+int shim_handle_tx_resume(shim_cb_t *shim_cb_p);
+
+
+#endif /* _SHIM_H_ */
diff --git a/include/asm-mips/rmi/phoenix_uart.h b/include/asm-mips/rmi/phoenix_uart.h
new file mode 100644
index 0000000..308822e
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_uart.h
@@ -0,0 +1,52 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _UART_H
+#define _UART_H
+
+#include <asm/rmi/iomap.h>
+
+#define UART_RHR 0
+#define UART_THR 0
+#define UART_IER 1
+#define UART_IIR 2
+#define UART_FCR 2
+#define UART_LCR 3
+#define UART_MCR 4
+#define UART_LSR 5
+#define UART_MSR 6
+
+#define UART_DLB_1 0
+#define UART_DLB_2 1
+
+#define UART_DEBUG_1 8
+#define UART_DEBUG_2 9
+
+#endif
diff --git a/include/asm-mips/rmi/pic.h b/include/asm-mips/rmi/pic.h
new file mode 100644
index 0000000..5d22b42
--- /dev/null
+++ b/include/asm-mips/rmi/pic.h
@@ -0,0 +1,241 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PIC_H
+#define _ASM_RMI_PIC_H
+
+#include <asm/rmi/iomap.h>
+
+#define PIC_CLKS_PER_SEC 66666666ULL
+
+#define PIC_IRT_WD_INDEX     0
+#define PIC_IRT_TIMER_0_INDEX      1
+#define PIC_IRT_TIMER_1_INDEX      2
+#define PIC_IRT_TIMER_2_INDEX      3
+#define PIC_IRT_TIMER_3_INDEX      4
+#define PIC_IRT_TIMER_4_INDEX      5
+#define PIC_IRT_TIMER_5_INDEX      6
+#define PIC_IRT_TIMER_6_INDEX      7
+#define PIC_IRT_TIMER_7_INDEX      8
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_UART_0_INDEX       9
+#define PIC_IRT_UART_1_INDEX       10
+#define PIC_IRT_I2C_0_INDEX       11
+#define PIC_IRT_I2C_1_INDEX       12
+#define PIC_IRT_PCMCIA_INDEX           13
+#define PIC_IRT_GPIO_INDEX             14
+#define PIC_IRT_HYPER_INDEX            15
+#define PIC_IRT_PCIX_INDEX             16
+
+#define PIC_IRT_CDE_INDEX              15
+#define PIC_IRT_BRIDGE_TB_XLS_INDEX    16
+
+#define PIC_IRT_GMAC0_INDEX            17
+#define PIC_IRT_GMAC1_INDEX            18
+#define PIC_IRT_GMAC2_INDEX            19
+#define PIC_IRT_GMAC3_INDEX            20
+#define PIC_IRT_XGS0_INDEX             21
+#define PIC_IRT_XGS1_INDEX             22
+#define PIC_IRT_HYPER_FATAL_INDEX      23
+#define PIC_IRT_PCIX_FATAL_INDEX       24
+#define PIC_IRT_BRIDGE_AERR_INDEX      25
+#define PIC_IRT_BRIDGE_BERR_INDEX     26
+#define PIC_IRT_BRIDGE_TB_XLR_INDEX    27
+#define PIC_IRT_BRIDGE_AERR_NMI_INDEX  28
+
+#define PIC_IRT_GMAC4_INDEX            21
+#define PIC_IRT_GMAC5_INDEX            22
+#define PIC_IRT_GMAC6_INDEX            23
+#define PIC_IRT_GMAC7_INDEX            24
+#define PIC_IRT_BRIDGE_ERR_INDEX       25
+#define PIC_IRT_PCIE_LINK0_INDEX       26
+#define PIC_IRT_PCIE_LINK1_INDEX       27
+#define PIC_IRT_PCIE_LINK2_INDEX       23
+#define PIC_IRT_PCIE_LINK3_INDEX       24
+#define PIC_IRT_PCIE_INT_INDEX         28
+#define PIC_IRT_PCIE_FATAL_INDEX       29
+#define PIC_IRT_GPIO_B_INDEX           30
+#define PIC_IRT_USB_INDEX              31
+
+#define PIC_NUM_IRTS                   32
+
+#define PIC_SYS_TIMER_MAXVAL_0_BASE 0x100
+#define PIC_SYS_TIMER_MAXVAL_1_BASE 0x110
+#define PIC_SYS_TIMER_0_BASE 0x120
+#define PIC_SYS_TIMER_1_BASE 0x130
+#define PIC_CLOCK_TIMER 7
+
+#define PIC_CTRL    0x00
+#define PIC_IPI     0x04
+#define PIC_INT_ACK 0x06
+
+#define WD_MAX_VAL_0 0x08
+#define WD_MAX_VAL_1 0x09
+#define WD_MASK_0    0x0a
+#define WD_MASK_1    0x0b
+#define WD_HEARBEAT_0 0x0c
+#define WD_HEARBEAT_1 0x0d
+
+#define PIC_IRT_0_BASE 0x40
+#define PIC_IRT_1_BASE 0x80
+
+#define PIC_IRT_0_WD     (PIC_IRT_0_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_1_WD     (PIC_IRT_1_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_0_TIMER_0     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_1_TIMER_0     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_0_TIMER_1     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_1_TIMER_1     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_0_TIMER_2     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_1_TIMER_2     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_0_TIMER_3     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_1_TIMER_3     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_0_TIMER_4     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_1_TIMER_4     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_0_TIMER_5     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_1_TIMER_5     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_0_TIMER_6     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_1_TIMER_6     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_0_TIMER_7     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_1_TIMER_7     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_0_CLOCK       (PIC_IRT_0_TIMER_7)
+#define PIC_IRT_1_CLOCK       (PIC_IRT_1_TIMER_7)
+#define PIC_IRT_0_UART_0 (PIC_IRT_0_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_1_UART_0 (PIC_IRT_1_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_0_UART_1 (PIC_IRT_0_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_1_UART_1 (PIC_IRT_1_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_0_I2C_0 (PIC_IRT_0_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_1_I2C_0 (PIC_IRT_1_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_0_I2C_1 (PIC_IRT_0_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_IRT_1_I2C_1 (PIC_IRT_1_BASE + PIC_IRT_I2C_1_INDEX)
+
+#define PIC_TIMER_0_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 0)
+#define PIC_TIMER_0_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 0)
+#define PIC_TIMER_0_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 0)
+#define PIC_TIMER_0_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 0)
+#define PIC_TIMER_7_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 7)
+#define PIC_TIMER_7_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 7)
+#define PIC_TIMER_7_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 7)
+#define PIC_TIMER_7_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 7)
+#define PIC_TIMER_6_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 6)
+#define PIC_TIMER_6_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 6)
+#define PIC_TIMER_6_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 6)
+#define PIC_TIMER_6_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 6)
+
+#define PIC_IRQ_BASE      8
+#define PIC_IRT_FIRST_IRQ PIC_IRQ_BASE
+#define PIC_WD_IRQ      (PIC_IRQ_BASE + PIC_IRT_WD_INDEX)
+#define PIC_TIMER_0_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ   (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_UART_1_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_I2C_0_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_PCMCIA_IRQ           (PIC_IRQ_BASE + PIC_IRT_PCMCIA_INDEX)
+#define PIC_GPIO_IRQ             (PIC_IRQ_BASE + PIC_IRT_GPIO_INDEX)
+#define PIC_HYPER_IRQ            (PIC_IRQ_BASE + PIC_IRT_HYPER_INDEX)
+#define PIC_PCIX_IRQ             (PIC_IRQ_BASE + PIC_IRT_PCIX_INDEX)
+
+#define PIC_CDE_IRQ              (PIC_IRQ_BASE + PIC_IRT_CDE_INDEX)
+#define PIC_BRIDGE_TB_XLS_IRQ    (PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_XLS_INDEX)
+
+#define PIC_GMAC_0_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC0_INDEX)
+#define PIC_GMAC_1_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC1_INDEX)
+#define PIC_GMAC_2_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC2_INDEX)
+#define PIC_GMAC_3_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC3_INDEX)
+#define PIC_XGS_0_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS0_INDEX)
+#define PIC_XGS_1_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS1_INDEX)
+#define PIC_HYPER_FATAL_IRQ      (PIC_IRQ_BASE + PIC_IRT_HYPER_FATAL_INDEX)
+#define PIC_PCIX_FATAL_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIX_FATAL_INDEX)
+#define PIC_BRIDGE_AERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_INDEX)
+#define PIC_BRIDGE_BERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_BERR_INDEX)
+#define PIC_BRIDGE_TB_XLR_IRQ    (PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_XLR_INDEX)
+#define PIC_BRIDGE_AERR_NMI_IRQ  (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_NMI_INDEX)
+#define PIC_IRT_LAST_XLR_IRQ     PIC_BRIDGE_AERR_NMI_IRQ
+
+#define PIC_GMAC_4_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC4_INDEX)
+#define PIC_GMAC_5_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC5_INDEX)
+#define PIC_GMAC_6_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC6_INDEX)
+#define PIC_GMAC_7_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC7_INDEX)
+#define PIC_BRIDGE_ERR_IRQ       (PIC_IRQ_BASE + PIC_IRT_BRIDGE_ERR_INDEX)
+#define PIC_PCIE_LINK0_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK0_INDEX)
+#define PIC_PCIE_LINK1_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK1_INDEX)
+#define PIC_PCIE_LINK2_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK2_INDEX)
+#define PIC_PCIE_LINK3_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK3_INDEX)
+#define PIC_PCIE_INT_IRQ         (PIC_IRQ_BASE + PIC_IRT_PCIE_INT__INDEX)
+#define PIC_PCIE_FATAL_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_FATAL_INDEX)
+#define PIC_GPIO_B_IRQ           (PIC_IRQ_BASE + PIC_IRT_GPIO_B_INDEX)
+#define PIC_USB_IRQ              (PIC_IRQ_BASE + PIC_IRT_USB_INDEX)
+#define PIC_IRT_LAST_XLS_IRQ  PIC_USB_IRQ
+
+#ifndef __ASSEMBLY__
+static __inline__ void pic_send_ipi(__u32 ipi)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_IPI, ipi);
+}
+
+static __inline__ __u32 pic_read_control(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	return phoenix_read_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void pic_write_control(__u32 control)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_CTRL, control);
+}
+
+static __inline__ void pic_update_control(__u32 control)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_write_reg(mmio, PIC_CTRL, (control | phoenix_read_reg(mmio, PIC_CTRL)));
+}
+
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) ( ((irq)>=PIC_TIMER_0_IRQ) && ((irq)<=PIC_TIMER_7_IRQ) )
+
+#define PIC_IRQ_IS_IRT(irq) ( ((irq)>=PIC_IRT_FIRST_IRQ) && ((irq)<=(is_xls()?PIC_IRT_LAST_XLS_IRQ:PIC_IRT_LAST_XLR_IRQ)) )
+#define PIC_IRT_LAST_IRQ() (is_xls()?PIC_IRT_LAST_XLS_IRQ:PIC_IRT_LAST_XLR_IRQ)
+#define PIC_BRIDGE_TB_IRQ() (is_xls()?PIC_BRIDGE_TB_XLS_IRQ:PIC_BRIDGE_TB_XLR_IRQ)
+
+struct pt_regs;
+extern void phoenix_ipi_handler(int irq, struct pt_regs *regs);
+extern void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
+
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/proc.h b/include/asm-mips/rmi/proc.h
new file mode 100644
index 0000000..8e988ee
--- /dev/null
+++ b/include/asm-mips/rmi/proc.h
@@ -0,0 +1,51 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PROC_H
+#define _ASM_RMI_PROC_H
+
+#include <linux/types.h>
+
+static __inline__ int proc_pos_check(off_t * begin, int *len, off_t off,
+				     int count)
+{
+	off_t pos = *begin + *len;
+
+	if (pos < off) {
+		*len = 0;
+		*begin = pos;
+	}
+	if (pos > off + count)
+		return 0;
+
+	return 1;
+}
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_pcix_gen_dev.h b/include/asm-mips/rmi/rmi_pcix_gen_dev.h
new file mode 100644
index 0000000..b3644d7
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_pcix_gen_dev.h
@@ -0,0 +1,115 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PHNX_PCIX_DEVICE_H__
+#define __PHNX_PCIX_DEVICE_H__
+
+#include <asm/types.h>
+#include <linux/cache.h>
+
+#ifdef PHOENIX_LITTLE_ENDIAN
+#define PCIX_REG_BASE 64
+#else
+#define PCIX_REG_BASE (512 + 64)
+#endif
+
+#define XLR_PCI_HOST_MODE 0x1
+#define XLR_PCI_DEV_MODE 0x2
+#define PCIX_INTRPT_CONTROL_REG ( PCIX_REG_BASE + 15)
+#define PCIX_PHOENIX_CONTROL_REG ( PCIX_REG_BASE + 14)
+#define PCIX_INTRPT_STATUS_REG ( PCIX_REG_BASE + 16)
+#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
+#define PCIX_DEVICE_MODE_ADDR_MAPPER ( PCIX_REG_BASE + 36)
+#define PCIX_DEVMODE_TBL_BAR0_REG                   (PCIX_REG_BASE + 44)
+#define PCIX_DEVMODE_TBL_BAR1_REG                   (PCIX_REG_BASE + 45)
+#define PCIX_DEVMODE_TBL_BAR2_REG                   (PCIX_REG_BASE + 46)
+#define PCIX_DEVMODE_TBL_BAR3_REG                   (PCIX_REG_BASE + 47)
+
+#define PHNX_MAX_IRQS_SUPPORTED 16
+
+#define phnx_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
+
+#define CACHELINE_ALIGNED_ADDR(addr) \
+			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+
+int xlr_get_pci_mode(void);
+void phnx_interrupt_host(void);
+/* DEVICE SIDE */
+#ifdef XLR_MAILBOX_IS_SUPPORTED
+typedef int (*mailbox_handler)(void *, struct pt_regs *);
+int phnx_request_mailbox_handler(mailbox_handler, void *, int *);
+int phnx_disable_mailbox_intr(int *);
+int phnx_enable_mailbox_intr(int *);
+int phnx_free_mailbox_handler(int *);
+#endif
+
+
+/***************************************************************/
+/**********************************SHARED    MEMORY*************/
+/***************************************************************/
+/* DURING BOOT ONLY */
+
+#define PHNX_BOOT_SHARED_MEM_BASE 0x1000
+#define PHNX_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
+
+
+/* AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER */
+#define PHNX_GENERIC_SHARED_MEM_BASE (20*1024*1024)
+#define PHNX_GENERIC_SHARED_MEM_SIZE (10*1024*1024)
+
+#define PHNX_PCIX_SHARED_MEM_START (0x8000000+PHNX_GENERIC_SHARED_MEM_BASE)
+#define PHNX_PCIX_SHARED_MEM_END (PHNX_PCIX_SHARED_MEM_START+PHNX_GENERIC_SHARED_MEM_SIZE)
+/* All The Shared Address must be unique for each driver. Confliction of 
+ * Address Space can cause unpredictable result. Shared Space Must be in 
+ * sync with that of host driver.
+ */
+
+/* SHARED SPACE BETWEEN MAC DRIVERS */
+#define PHNX_MAC_SHARED_MEM_BASE PHNX_GENERIC_SHARED_MEM_BASE
+#define PHNX_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
+
+/* SHARED SPACE BETWEEN CONSOLE DRIVERS */
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
+	         (PHNX_MAC_SHARED_MEM_BASE + PHNX_MAC_SHARED_MEM_SIZE)
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
+
+/* SHARED space for DMA */
+#define PHNX_DMA_MEM_BASE \
+			(PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
+	 		PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
+#define PHNX_DMA_MEM_SIZE 1024
+
+/* SHARED SPACE BETWEEN IP OVER PCI DRIVER... */
+#define PHNX_IP_OVER_PCI_MEM_BASE \
+			(PHNX_DMA_MEM_BASE + PHNX_DMA_MEM_SIZE)
+#define PHNX_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_pcix_gen_host.h b/include/asm-mips/rmi/rmi_pcix_gen_host.h
new file mode 100644
index 0000000..7ca649e
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_pcix_gen_host.h
@@ -0,0 +1,117 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PHNX_PCIX_DEVICE_H__
+#define __PHNX_PCIX_DEVICE_H__
+
+#include <asm/types.h>
+#include <linux/cache.h>
+
+#ifdef CONFIG_RMI_PHOENIX
+#ifdef PHOENIX_LITTLE_ENDIAN
+#define PCIX_REG_BASE 64
+#else
+#define PCIX_REG_BASE (512 + 64)
+#endif
+#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
+#endif
+
+#define XLR_PCI_HOST_MODE 0x1
+#define XLR_PCI_DEV_MODE 0x2
+
+#define phnx_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
+
+#define CACHELINE_ALIGNED_ADDR(addr) \
+			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+#ifndef CONFIG_RMI_PHOENIX
+#ifdef XLR_MSI_IS_SUPPORTED
+typedef int (*msi_handler)(void *, struct pt_regs *);
+#endif
+#endif
+
+/* HOST SIDE */
+#ifndef CONFIG_RMI_PHOENIX
+#ifdef XLR_MSI_IS_SUPPORTED
+int phnx_request_msi_handler(msi_handler,void *,int *);
+void phnx_free_msi_handler(int *);
+int phnx_enable_msi(int *);
+int phnx_disable_msi(int *);
+void phnx_interrupt_host(void);
+#endif
+#endif
+
+#ifdef CONFIG_RMI_PHOENIX
+int rmi_get_pci_mode(void);
+#endif
+
+unsigned volatile long phnx_get_shared_mem_base(void);
+unsigned int phnx_pci_readl(unsigned int *);
+u8 phnx_pci_readb(u8 *);
+void rmi_phnx_interrupt_device(void);
+
+
+/***************************************************************************/
+/**********************SHARED    MEMORY*************************************/
+/***************************************************************************/
+/* DURING BOOT ONLY */
+#define PHNX_BOOT_SHARED_MEM_BASE 0x1000
+#define PHNX_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
+
+/* AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER */
+#define PHNX_GENERIC_SHARED_MEM_BASE (20*1024*1024)
+#define PHNX_GENERIC_SHARED_MEM_SIZE (10* 1024 * 1024)
+
+/* 
+ * All The Shared Address must be unique for each driver. Confliction of
+ * Address Space can cause unpredictable result.
+ */
+
+/* SHARED SPACE BETWEEN MAC DRIVERS */
+#define PHNX_MAC_SHARED_MEM_BASE PHNX_GENERIC_SHARED_MEM_BASE
+#define PHNX_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
+
+/* SHARED SPACE BETWEEN CONSOLE DRIVERS */
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
+	         (PHNX_MAC_SHARED_MEM_BASE + PHNX_MAC_SHARED_MEM_SIZE)
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
+
+/* SHARED space for DMA */
+#define PHNX_DMA_MEM_BASE \
+			(PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
+	 		PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
+#define PHNX_DMA_MEM_SIZE 1024
+
+/* SHARED SPACE BETWEEN IP OVER PCI DRIVER... */
+#define PHNX_IP_OVER_PCI_MEM_BASE \
+			(PHNX_DMA_MEM_BASE + PHNX_DMA_MEM_SIZE)
+#define PHNX_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_rw_lock.h b/include/asm-mips/rmi/rmi_rw_lock.h
new file mode 100644
index 0000000..9316f31
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_rw_lock.h
@@ -0,0 +1,117 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __RMI_RW_LOCK_H_
+#define __RMI_RW_LOCK_H_
+
+#define RMI_MAX_CPUS 32
+
+typedef struct {
+	volatile unsigned int lock;
+	unsigned int read_cpus[RMI_MAX_CPUS]; /* cpus that hold rd lock */
+	int write_cpu; /* CPU that is currently holding wr lock */
+} rmi_rwlock_t;
+
+#define rmi_sync() __asm__ __volatile__("sync": : :"memory")
+
+__asm__ (
+			".macro	rmi_local_irq_save result\n\t"
+			".set	push\n\t"
+			".set	reorder\n\t"
+			".set	noat\n\t"
+			"mfc0	\\result, $12\n\t"
+			"ori	$1, \\result, 1\n\t"
+			"xori	$1, 1\n\t"
+			".set	noreorder\n\t"
+			"mtc0	$1, $12\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			".set	pop\n\t"
+			".endm"
+		);
+
+__asm__(
+			".macro	rmi_local_irq_restore flags\n\t"
+			".set	noreorder\n\t"
+			".set	noat\n\t"
+			"mfc0	$1, $12\n\t"
+			"andi	\\flags, 1\n\t"
+			"ori	$1, 1\n\t"
+			"xori	$1, 1\n\t"
+			"or		\\flags, $1\n\t"
+			"mtc0	\\flags, $12\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			"sll	$0, $0, 1\t\t\t# nop\n\t"
+			".set	at\n\t"
+			".set	reorder\n\t"
+			".endm"
+		);
+
+
+#define rmi_local_irq_save(x)		\
+	__asm__ __volatile__(			\
+		"rmi_local_irq_save\t%0"	\
+		: "=r" (x)					\
+		: 							\
+		: "memory")
+
+
+#define rmi_local_irq_restore(flags)	\
+	do {                           		\
+		unsigned long __tmp1;  			\
+		__asm__ __volatile__(  			\
+		"rmi_local_irq_restore\t%0"		\
+		: "=r" (__tmp1)                 \
+		: "0" (flags)                   \
+		: "memory");                    \
+	} while(0)
+
+
+#define rmi_processor_id() 				\
+	({ int __res;						\
+	 __asm__ __volatile__(				\
+		 ".set\tmips32\n\t"				\
+		 "mfc0\t%0, $15, 1\n\t"			\
+		 "andi\t%0, 0x1f\n\t"			\
+		 ".set\tmips0\n\t"				\
+		 : "=r" (__res));				\
+	 __res;								\
+	 })
+
+
+static inline unsigned int rmi_read_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
diff --git a/include/asm-mips/rmi/rmios_user_mac.h b/include/asm-mips/rmi/rmios_user_mac.h
new file mode 100644
index 0000000..d14aa06
--- /dev/null
+++ b/include/asm-mips/rmi/rmios_user_mac.h
@@ -0,0 +1,64 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_RMIOS_USER_MAC_H
+#define _ASM_RMI_RMIOS_USER_MAC_H
+
+#define RMIOS_USER_MAC_BUCKET 4
+
+#define RMIOS_USER_MAC_PERF_EVT_0            0
+#define RMIOS_USER_MAC_PERF_EVT_1            1
+#define RMIOS_USER_MAC_PERF_TOTAL_PKTS       2
+#define RMIOS_USER_MAC_PERF_DROPPED_PKTS     3
+#define RMIOS_USER_MAC_PERF_RX_TIMEOUT       4
+#define RMIOS_USER_MAC_PERF_NUM_CTRS         5
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+
+extern __u64 rmios_user_mac_perf_ctrs[32][RMIOS_USER_MAC_PERF_NUM_CTRS];
+
+extern int rmios_user_mac_balance_num_flows;
+
+#define RMIOS_USER_MAC_RX_TIMEOUT 672
+
+extern __u32 rmios_user_mac_rx_timeout[32];
+
+extern int rmios_user_mac_perf;
+extern int rmios_user_mac_perf_q_thr;
+extern int rmios_user_mac_perf_global;
+extern int rmios_user_mac_perf_evt_0;
+extern int rmios_user_mac_perf_evt_1;
+
+extern void rmios_user_mac_init(void);
+#endif
+
+#endif /* _ASM_RMI_RMIOS_USER_MAC_H */
diff --git a/include/asm-mips/rmi/sim.h b/include/asm-mips/rmi/sim.h
new file mode 100644
index 0000000..1bcb60b
--- /dev/null
+++ b/include/asm-mips/rmi/sim.h
@@ -0,0 +1,341 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_SIM_H
+#define _ASM_SIM_H
+
+#include <linux/types.h>
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#define PSB_INFO_VERSION 0x0001
+
+struct psb_info {
+	uint64_t boot_level;
+	uint64_t io_base;
+	uint64_t output_device;
+	uint64_t uart_print;
+	uint64_t led_output;
+	uint64_t init;
+	uint64_t exit;
+	uint64_t warm_reset;
+	uint64_t wakeup;
+	uint64_t cpu_online_map;
+	uint64_t master_reentry_sp;
+	uint64_t master_reentry_gp;
+	uint64_t master_reentry_fn;
+	uint64_t slave_reentry_fn;
+	uint64_t magic_dword;
+	uint64_t uart_putchar;
+	uint64_t size;
+	uint64_t uart_getchar;
+	uint64_t nmi_handler;
+	uint64_t psb_version;
+	uint64_t mac_addr;
+	uint64_t cpu_frequency;
+	uint64_t board_version;
+	uint64_t malloc;
+	uint64_t free;
+	uint64_t global_shmem_addr;
+	uint64_t global_shmem_size;
+	uint64_t psb_os_cpu_map;
+	uint64_t userapp_cpu_map;
+	uint64_t wakeup_os;
+	uint64_t psb_mem_map;
+	uint64_t board_major_version;
+	uint64_t board_minor_version;
+	uint64_t board_manf_revision;
+	uint64_t board_serial_number;
+	uint64_t psb_physaddr_map;
+	uint64_t xlr_loaderip_config;
+	uint64_t bldr_envp;
+	uint64_t avail_mem_map;
+};
+
+
+enum {
+        PHOENIX_IO_SPACE = 0x10,
+        PCIX_IO_SPACE,
+        PCIX_CFG_SPACE,
+        PCIX_MEMORY_SPACE,
+        HT_IO_SPACE,
+        HT_CFG_SPACE,
+        HT_MEMORY_SPACE,
+        SRAM_SPACE,
+        FLASH_CONTROLLER_SPACE
+};
+
+extern struct psb_info *prom_info;
+
+#define MAX_ENV_BUF 0x00020000 /* 128 KB = One sector of Intel flash. */
+struct environment
+{
+        unsigned long crc;
+        unsigned char envbuf[MAX_ENV_BUF - 20]; /* 4 bytes for CRC and 16 bytes reserved */
+        unsigned char reserved[16];
+};
+
+#define RMI_PHOENIX_BOARD_ARIZONA_I   1
+#define RMI_PHOENIX_BOARD_ARIZONA_II  2
+#define RMI_PHOENIX_BOARD_ARIZONA_III 3
+#define RMI_PHOENIX_BOARD_ARIZONA_IV  4
+#define RMI_PHOENIX_BOARD_ARIZONA_V   5
+#define RMI_PHOENIX_BOARD_ARIZONA_VI   6  /* XLS boards */
+#define RMI_PHOENIX_BOARD_ARIZONA_VII 7 /*XLS 2xx boards*/
+#define RMI_PHOENIX_BOARD_ARIZONA_VIII 8 /*XLS LTE boards*/
+
+struct smp_boot_info_percpu {
+  volatile unsigned long ready;
+  volatile unsigned long sp;
+  volatile unsigned long gp;
+  volatile unsigned long fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_percpu boot_info[32];
+  __u32 online_map;
+};
+
+extern struct smp_boot_info smp_boot;
+extern void prom_boot_cpus_secondary(void *);
+
+extern __u32 xlr_board_major_version;
+extern __u32 xlr_board_minor_version;
+
+#define XLR_REVISION_A0 0xc0000
+#define XLR_REVISION_A1 0xc0001
+#define XLR_REVISION_B0 0xc0002
+#define XLR_REVISION_B1 0xc0003
+#define XLR_REVISION_B2 0xc0004
+#define XLR_REVISION_C0 0xc0005
+#define XLR_REVISION_C1 0xc0006
+#define XLR_REVISION_C2 0xc0007
+#define XLR_REVISION_C3 0xc0008
+#define XLR_REVISION_C4 0xc0009
+
+static __inline__ unsigned int xlr_revision(void)
+{
+	return read_c0_prid() & 0xff00ff;
+}
+
+static __inline__ int xlr_revision_a0(void)
+{
+	return xlr_revision() == XLR_REVISION_A0;
+}
+
+static __inline__ int xlr_revision_b0(void)
+{
+	return xlr_revision() == XLR_REVISION_B0;
+}
+
+static __inline__ int xlr_revision_b1(void)
+{
+        return xlr_revision() == XLR_REVISION_B1;
+}
+
+static __inline__ int xlr_revision_c(void)
+{
+    uint32_t prid = read_c0_prid();
+    if(prid>=XLR_REVISION_C0 && prid<=XLR_REVISION_C4)
+        return 1;        
+    return 0; 
+}
+
+static __inline__ int xlr_board_atx_i(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_I;
+}
+
+static __inline__ int xlr_board_atx_ii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II;
+}
+
+static __inline__ int xlr_board_atx_ii_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_iii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III;
+}
+
+static __inline__ int xlr_board_atx_iv(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iv_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V;
+}
+
+static __inline__ int xlr_board_atx_iii_256(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iii_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_vi(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VI)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_vii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VII)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_viii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VIII);
+}
+
+#define XLR_HYBRID_NONE              0
+#define XLR_HYBRID_USER_MAC          1
+#define XLR_HYBRID_RMIOS_IPSEC       2
+#define XLR_HYBRID_RMIOS_TCPIP_STACK 3
+#define XLR_HYBRID_USER_MAC_GMAC     4
+#define XLR_HYBRID_USER_MAC_XGMAC    5
+#define XLR_HYBRID_USER_MAC_SPI4     6
+
+extern int xlr_hybrid;
+
+static __inline__ int xlr_hybrid_user_mac(void)
+{
+	return xlr_hybrid == XLR_HYBRID_USER_MAC;
+}
+
+static __inline__ int xlr_hybrid_user_mac_xgmac(void)
+{
+	return xlr_hybrid == XLR_HYBRID_USER_MAC_XGMAC;
+}
+
+static __inline__ int xlr_hybrid_rmios_tcpip_stack(void)
+{
+        return xlr_hybrid == XLR_HYBRID_RMIOS_TCPIP_STACK;
+}
+
+static __inline__ int xlr_hybrid_rmios_ipsec(void)
+{
+	return xlr_hybrid == XLR_HYBRID_RMIOS_IPSEC;
+}
+
+static __inline__ int xlr_hybrid_none(void)
+{
+	return xlr_hybrid == XLR_HYBRID_NONE;
+}
+
+struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type);
+
+/* Returns '1' if the processor id belongs
+ * to any one of the family of XLS Processors;
+ * viz. 608/408/404/208/204, else '0'.
+ */
+
+#define CHIP_PROCESSOR_ID_XLS_608   0x80
+#define CHIP_PROCESSOR_ID_XLS_408   0x88
+#define CHIP_PROCESSOR_ID_XLS_404   0x8c
+#define CHIP_PROCESSOR_ID_XLS_208   0x8e
+#define CHIP_PROCESSOR_ID_XLS_204   0x8f
+static __inline__ int is_xls(void)
+{
+	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+	switch (processor_id) {
+        case CHIP_PROCESSOR_ID_XLS_608:
+        case CHIP_PROCESSOR_ID_XLS_408:
+        case CHIP_PROCESSOR_ID_XLS_404:
+        case CHIP_PROCESSOR_ID_XLS_208:
+        case CHIP_PROCESSOR_ID_XLS_204:
+		return 1;
+        default:
+		return 0;
+	}
+}
+
+static __inline__ int is_xls2xx(void)
+{
+	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+	switch (processor_id) {
+        case CHIP_PROCESSOR_ID_XLS_208:
+        case CHIP_PROCESSOR_ID_XLS_204:
+		return 1;
+        default:
+		return 0;
+	}
+}
+
+static __inline__ int is_xls4xx(void)
+{
+	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+	switch (processor_id) {
+        case CHIP_PROCESSOR_ID_XLS_408:
+        case CHIP_PROCESSOR_ID_XLS_404:
+		return 1;
+        default:
+		return 0;
+	}
+}
+
+static __inline__ int is_xls6xx(void)
+{
+	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+	switch (processor_id) {
+        case CHIP_PROCESSOR_ID_XLS_608:
+		return 1;
+        default:
+		return 0;
+	}
+}
+
+#endif /* _ASM_SIM_H */
diff --git a/include/asm-mips/rmi/user/phnx_loader.h b/include/asm-mips/rmi/user/phnx_loader.h
new file mode 100644
index 0000000..827bb44
--- /dev/null
+++ b/include/asm-mips/rmi/user/phnx_loader.h
@@ -0,0 +1,148 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __USER_RMI_PHNX_LOADER_H
+#define __USER_RMI_PHNX_LOADER_H
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define XLR_MAP_SLAVE_DEVICE 0x1
+
+#define XLR_MAP_UNCACHED 0x1
+#define XLR_MAP_CACHED 0x2
+
+#define PHNX_APP_LOADER_CHRDEV_NAME "xlr_app_loader"
+
+#define PHNX_LOADER_IOC_MAGIC 'X'
+
+#define PHNX_LOADER_IOC_SHMEM_SIZE _IOR(PHNX_LOADER_IOC_MAGIC, 0, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_SHMEM _IOR(PHNX_LOADER_IOC_MAGIC, 1, unsigned int)
+
+#define PHNX_LOADER_IOC_LIB_BKP _IOR(PHNX_LOADER_IOC_MAGIC, 2, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_LOAD_ADDR  _IOR(PHNX_LOADER_IOC_MAGIC, 3, unsigned int)
+
+#define PHNX_LOADER_IOC_START_IPI _IOR(PHNX_LOADER_IOC_MAGIC, 4, unsigned int)
+
+#define PHNX_LOADER_IOC_STOP_IPI  _IOR(PHNX_LOADER_IOC_MAGIC, 5, unsigned int)
+
+#define PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 6, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 7, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_APP_SHMEM _IOR(PHNX_LOADER_IOC_MAGIC, 45, unsigned int)
+
+#define PHNX_LOADER_IOC_FREE_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 8, unsigned int)
+
+#define PHNX_LOADER_IOC_LAUNCH_KSEG _IOR(PHNX_LOADER_IOC_MAGIC, 15, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_SIZE _IOR(PHNX_LOADER_IOC_MAGIC, 25, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_RESERVE _IOR(PHNX_LOADER_IOC_MAGIC, 35, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_PHYS _IOR(PHNX_LOADER_IOC_MAGIC, 55, unsigned int)
+
+#define PHNX_LOADER_STORE_ENV _IOR(PHNX_LOADER_IOC_MAGIC, 65, unsigned int)
+
+#define PHNX_MAX_VCPUS 32
+
+enum { KUSEG_MODE, KSEG0_MODE };
+
+typedef enum {
+	STOP_THREAD=0xbeef,
+	START_THREAD,
+	RUN_FUNCTION, /* Used by wakeup and wakeup_os call */
+} loader_cmd;
+
+typedef enum {
+	THREAD_STOPPED=0x600d,
+	THREAD_RUNNING,
+	THREAD_SCHEDULED,
+} thread_status;
+
+struct cpu_tlb_mapping {
+	int page_size;
+	int asid;
+	int coherency;
+	int attr;
+	unsigned long virt;
+	uint64_t phys;
+};
+
+#define MAX_TLB_MAPPINGS 16
+#define MAX_ARGS 16
+#define MAX_ARGV_LEN 16
+
+struct cpu_wakeup_info {
+	int            master_cpu;
+	int            map_count;
+	int            valid;
+	unsigned long  func;
+	unsigned long  args;
+	int            argc;
+	uint32_t       buddy_mask;
+	uint32_t       cpu_mask;
+	char          *argv[32]; /* RMIOS LIB NEEDS this to be 32 */
+	char           buf[256];/* must be > MAX_ARGS * MAX_ARGV_LEN + some buffer */
+	struct cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
+};
+
+/* SHARED memory structure b/w loader app, linux and RMIOS apps */
+typedef struct phnx_loader_shared_struct {
+	unsigned long park_entry;
+	loader_cmd    cmd;
+	thread_status thr_status;
+	unsigned long entry; /* Entry point address */
+	int 	      run_mode;
+	struct cpu_wakeup_info run_info;
+	uint32_t 	app_sh_mem_sz; /* Size of the shared memory */
+	unsigned long	sp;/* Used for reentry */
+	unsigned long	gp;
+} phnx_loader_shared_struct_t;
+
+
+/* 
+ * This structure is passed to all applications launched from the linux
+ * loader through OS 7 scratch register
+*/
+#define PHNX_LOADER_INFO_MAGIC 0x600ddeed
+
+typedef struct phnx_loader_info {
+	uint32_t magic;
+	/* phnx_loader_shared_struct_t for CPU 0 will start here */
+	unsigned long sh_mem_start;
+	/* Size of the shared memory b/w linux apps and rmios apps  */
+	uint32_t app_sh_mem_size;
+	uint8_t printk_lock[16]; /* used for printk */
+} phnx_loader_info_t;
+
+#endif
diff --git a/include/asm-mips/rmi/user/phnx_mmap.h b/include/asm-mips/rmi/user/phnx_mmap.h
new file mode 100644
index 0000000..c0933e0
--- /dev/null
+++ b/include/asm-mips/rmi/user/phnx_mmap.h
@@ -0,0 +1,44 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __USER_RMI_PHNX_MMAP_H
+#define __USER_RMI_PHNX_MMAP_H
+
+#include <asm/ioctl.h>
+
+#define PHNX_MMAP_CHRDEV_NAME "xlr_bigtlb_heap"
+
+#define PHNX_MMAP_IOC_MAGIC 'N'
+
+#define    PHNX_MMAP_IOC_GPHYS_START         _IOR(PHNX_MMAP_IOC_MAGIC, 0, unsigned long)
+#define    PHNX_MMAP_IOC_GPHYS_SIZE          _IOR(PHNX_MMAP_IOC_MAGIC, 1, unsigned long)
+#define    PHNX_MMAP_IOC_GVIRT_START         _IOR(PHNX_MMAP_IOC_MAGIC, 2, unsigned long)
+
+#endif
diff --git a/include/asm-mips/rmi/user/phnx_msgring.h b/include/asm-mips/rmi/user/phnx_msgring.h
new file mode 100644
index 0000000..684c944
--- /dev/null
+++ b/include/asm-mips/rmi/user/phnx_msgring.h
@@ -0,0 +1,56 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __USER_RMI_PHNX_MSG_RNG_H
+#define __USER_RMI_PHNX_MSG_RNG_H
+
+#include <asm/ioctl.h>
+
+struct msgring_msg_data {
+  int		size;
+  int           code;
+  int           stid;
+  int           rx_bucket;
+  unsigned int  msgs[8];
+};
+
+#define MSG_RNG_IOC_MAGIC 'M'
+
+#define    MSGRING_IOC_SSTNNO       _IOW(MSG_RNG_IOC_MAGIC, 0, unsigned int)
+#define    MSGRING_IOC_GSHMPHYS     _IOR(MSG_RNG_IOC_MAGIC, 1, unsigned int)
+#define    MSGRING_IOC_GSHMVIRT     _IOR(MSG_RNG_IOC_MAGIC, 2, unsigned int)
+#define    MSGRING_IOC_GMMAP_START  _IOR(MSG_RNG_IOC_MAGIC, 3, unsigned int)
+#define    MSGRING_IOC_SYSINIT      _IOR(MSG_RNG_IOC_MAGIC, 4, unsigned int)
+#define    MSGRING_IOC_SYSPHYS      _IOR(MSG_RNG_IOC_MAGIC, 5, unsigned int)
+#define    MSGRING_IOC_SYSCALL      _IOW(MSG_RNG_IOC_MAGIC, 6, unsigned int)
+
+#define PHNX_MSGRING_CHRDEV_NAME "xlr_msgring_shm"
+
+#endif
diff --git a/include/asm-mips/rmi/user/phnx_user_mac.h b/include/asm-mips/rmi/user/phnx_user_mac.h
new file mode 100644
index 0000000..b3901bf
--- /dev/null
+++ b/include/asm-mips/rmi/user/phnx_user_mac.h
@@ -0,0 +1,223 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __USER_RMI_PHNX_USER_MAC_H
+#define __USER_RMI_PHNX_USER_MAC_H
+
+#include <asm/ioctl.h>
+
+#define USER_MAC_IOC_MAGIC 'M'
+
+#define    USER_MAC_IOC_SRXQ                _IOW(USER_MAC_IOC_MAGIC, 0, unsigned int)
+#define    USER_MAC_IOC_GSHMPHYS            _IOR(USER_MAC_IOC_MAGIC, 1, unsigned int)
+#define    USER_MAC_IOC_GSHMVIRT            _IOR(USER_MAC_IOC_MAGIC, 2, unsigned int)
+#define    USER_MAC_IOC_GSHMSIZE            _IOR(USER_MAC_IOC_MAGIC, 3, unsigned int)
+#define    USER_MAC_IOC_GMMAP_START         _IOR(USER_MAC_IOC_MAGIC, 4, unsigned int)
+#define    USER_MAC_IOC_SPERF_Q_THR         _IOW(USER_MAC_IOC_MAGIC, 5, unsigned int)
+#define    USER_MAC_IOC_SPERF_GLOBAL_THR    _IOW(USER_MAC_IOC_MAGIC, 6, unsigned int)
+#define    USER_MAC_IOC_SPERF_EVENT_0       _IOW(USER_MAC_IOC_MAGIC, 7, unsigned int)
+#define    USER_MAC_IOC_SPERF_EVENT_1       _IOW(USER_MAC_IOC_MAGIC, 8, unsigned int)
+#define    USER_MAC_IOC_SBALANCE_NUM_FLOWS  _IOW(USER_MAC_IOC_MAGIC, 9, unsigned int)
+#define    USER_MAC_IOC_SWRITE_REG          _IOW(USER_MAC_IOC_MAGIC, 10, unsigned int)
+#define    USER_MAC_IOC_GREAD_REG           _IOR(USER_MAC_IOC_MAGIC, 11, unsigned int)
+#define    USER_MAC_IOC_SPERF               _IOW(USER_MAC_IOC_MAGIC, 12, unsigned int)
+#define    USER_MAC_IOC_GPHYS_CPU_PRESENT_MAP _IOR(USER_MAC_IOC_MAGIC, 13, unsigned int)
+#define    USER_MAC_IOC_GCPU_ONLINE_MAP     _IOR(USER_MAC_IOC_MAGIC, 14, unsigned int)
+#define    USER_MAC_IOC_HYBRID_MODE_SETUP   _IOR(USER_MAC_IOC_MAGIC, 15, unsigned int)
+
+#define PHNX_USER_MAC_CHRDEV_NAME "xlr_user_mac"
+
+#define MAX_USER_MAC_PKTS 3072
+#define MAX_USER_MAC_FRIN_PKTS (MAX_USER_MAC_PKTS - 256)
+#define USER_MAC_FIFO_SIZE 128
+#define USER_MAC_PKT_BUF_SIZE 1600
+
+struct ufifo {
+  unsigned int data[USER_MAC_FIFO_SIZE];
+  int       size;
+  volatile int       head;
+  volatile int       tail;
+};
+static __inline__ void ufifo_init (struct ufifo *ufifo)
+{
+  ufifo->head = ufifo->tail = 0;
+  ufifo->size = USER_MAC_FIFO_SIZE;
+}
+
+/* TODO: Change all modulos to boolean arithmetic */
+static __inline__ int ufifo_next_index(struct ufifo *ufifo, int index)
+{
+  return (index+1) & (USER_MAC_FIFO_SIZE - 1);
+}
+
+static __inline__ int  ufifo_next_head(struct ufifo *ufifo) 
+{ 
+  return (ufifo->head+1) & (USER_MAC_FIFO_SIZE - 1); 
+}
+
+static __inline__ int  ufifo_next_tail(struct ufifo *ufifo) 
+{ 
+  return (ufifo->tail+1) & (USER_MAC_FIFO_SIZE - 1);
+}
+
+static __inline__ int  ufifo_empty(struct ufifo *ufifo) 
+{ return (ufifo->head == ufifo->tail); }
+
+static __inline__ int  ufifo_full(struct ufifo *ufifo) 
+{ return (ufifo_next_tail(ufifo) == ufifo->head); }
+
+static __inline__ int  ufifo_count(struct ufifo *ufifo) 
+{ 
+  if (ufifo->head <= ufifo->tail)
+    return ufifo->tail - ufifo->head;
+  else
+    return (ufifo->size - ufifo->head) + (ufifo->tail - 1);
+}
+static __inline__ int ufifo_dequeue(struct ufifo *ufifo, unsigned int *data)
+{
+  if (ufifo_empty(ufifo))
+    return 0;
+
+   *data = ufifo->data[ufifo->head];
+  ufifo->head = ufifo_next_head(ufifo);
+
+  return 1;
+}
+static __inline__ int ufifo_enqueue(struct ufifo *ufifo, unsigned int data) 
+{
+  if (ufifo_full(ufifo))
+    return 0;
+
+  ufifo->data[ufifo->tail] = data;
+  ufifo->tail = ufifo_next_tail(ufifo);
+
+  return 1;
+}
+static __inline__ int ufifo_head(struct ufifo *ufifo, unsigned int *data) 
+{
+  if (ufifo_empty(ufifo)) return 0;
+  
+  *data = ufifo->data[ufifo->head];
+  return 1;
+}
+
+struct packet_data {
+  unsigned char data[USER_MAC_PKT_BUF_SIZE];
+};
+
+struct packet_desc {
+  unsigned int offset;
+  int len;
+  int port;
+  int type;
+  int xgmac;	/* ignore in gmac. 1 xgmac loopback, 2, xgmac crossover */
+  int device;	/* 0 xgmac0, 1 xgmac1 */
+  int free;
+  unsigned char priv[48];
+  uint64_t priv_ptr;
+};
+
+#define USER_MAC_TXQ_FREE 0
+#define USER_MAC_TXQ_TX 1
+#define USER_MAC_TXQ_HOST 2
+
+struct user_mac_time {
+  unsigned int hi;
+  unsigned int lo;
+};
+
+#define MAX_USER_KERNEL_APPL 6
+#define MAX_USER_KERNEL_SYSCALL 32000
+struct user_kernel_appl {
+  char syscall_data[MAX_USER_KERNEL_SYSCALL];
+};
+#define MAX_USER_KERNEL_SECURITY 8000
+struct user_kernel_sec_ctrl {
+  char security_data[32];
+};
+struct user_kernel_sec_data {
+  char security_data[MAX_USER_KERNEL_SECURITY];
+};
+
+struct user_mac_data {
+  struct packet_data pkt_data[MAX_USER_MAC_PKTS];
+  struct packet_desc pkt_desc[MAX_USER_MAC_PKTS];
+  struct ufifo rxqs[32];
+  struct ufifo txqs[32];
+  struct user_mac_time time;
+  struct user_kernel_appl appl[MAX_USER_KERNEL_APPL];
+  struct user_kernel_sec_ctrl sec_ctrl;
+  struct user_kernel_sec_data sec_data[MAX_USER_KERNEL_APPL];
+  int host_pkt_next_free[32];
+};
+
+static __inline__ unsigned char *user_mac_host_pkt_alloc(struct user_mac_data *user_mac, int cpu)
+{
+	int num_pkts = (MAX_USER_MAC_PKTS - MAX_USER_MAC_FRIN_PKTS) / 32;
+	int start_index = MAX_USER_MAC_FRIN_PKTS + (cpu * num_pkts);
+	int next_free = user_mac->host_pkt_next_free[cpu];
+	int i=0;
+
+	if (next_free < start_index || next_free >= (start_index + num_pkts)) 
+		return NULL;
+	
+	for (i=next_free; i<(start_index+num_pkts) ;i++) {
+		if (user_mac->pkt_desc[i].free) {
+			user_mac->pkt_desc[i].free = 0;
+			user_mac->host_pkt_next_free[cpu] = i;
+			return user_mac->pkt_data[i].data;
+		}
+	}
+	
+	for (i=start_index; i<next_free; i++) {
+		if (user_mac->pkt_desc[i].free) {
+			user_mac->pkt_desc[i].free = 0;
+			user_mac->host_pkt_next_free[cpu] = i;
+			return user_mac->pkt_data[i].data;
+		}		
+	}
+
+	return NULL;
+}
+
+static __inline__ int user_mac_host_pkt_free(struct user_mac_data *user_mac, int index, int cpu)
+{
+	/* This function can be called from any cpu */
+	if (index < MAX_USER_MAC_FRIN_PKTS || index >= MAX_USER_MAC_PKTS)
+		return -1;
+	
+	if (user_mac->pkt_desc[index].free) return -1;
+
+	user_mac->pkt_desc[index].free = 1;
+
+	return 0;
+}
+
+#endif
diff --git a/include/asm-mips/rmi/xgmac_mdio.h b/include/asm-mips/rmi/xgmac_mdio.h
new file mode 100644
index 0000000..204b307
--- /dev/null
+++ b/include/asm-mips/rmi/xgmac_mdio.h
@@ -0,0 +1,115 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _XGMAC_MDIO
+#define _XGMAC_MDIO
+
+static inline int xmdio_read  (volatile unsigned int *_mmio,
+		uint32_t phy_addr, uint32_t address) ;
+static inline void xmdio_write (volatile unsigned int *_mmio, 
+		uint32_t phy_addr, uint32_t address, uint32_t data) ;
+static inline void xmdio_address (volatile unsigned int *_mmio, 
+		uint32_t phy_addr, uint32_t dev_ad, uint32_t address) ;
+
+static inline int xmdio_read  (volatile unsigned int *_mmio, 
+		uint32_t phy_addr, uint32_t address) {
+	uint32_t st_field = 0x0 ;
+	uint32_t op_type  = 0x3 ; /* read operation */
+	uint32_t ta_field = 0x2 ; /* ta field */
+	uint32_t data = 0 ;
+
+        xmdio_address (_mmio, phy_addr, 5, address) ;
+	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
+		( ( op_type  & 0x3    ) << 28 ) | 
+		( ( phy_addr & 0x1F   ) << 23 ) | 
+		( ( 5  & 0x1F   ) << 18 ) | 
+		( ( ta_field & 0x3    ) << 16 ) | 
+		( ( data     & 0xffff ) <<  0 ) ;
+
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+
+	/* wait for write cycle to complete */
+	while (_mmio [0x14] & 0x1) {
+	} ; 
+
+	data = _mmio [0x11] & 0xffff ;
+	return (data);
+}
+ 
+static inline void xmdio_write (volatile unsigned int *_mmio, 
+		uint32_t phy_addr, uint32_t address, uint32_t data) {
+	uint32_t st_field = 0x0 ;
+	uint32_t op_type  = 0x1 ; /* write operation */
+	uint32_t ta_field = 0x2 ; /* ta field */
+
+   xmdio_address ( _mmio, phy_addr, 5, address) ;
+	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
+		( ( op_type  & 0x3    ) << 28 ) | 
+		( ( phy_addr & 0x1F   ) << 23 ) | 
+		( ( 5  & 0x1F   ) << 18 ) | 
+		( ( ta_field & 0x3    ) << 16 ) | 
+		( ( data     & 0xffff ) <<  0 ) ;
+
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+
+	/* wait for write cycle to complete */
+	while (_mmio [0x14] & 0x1) {
+	} ; 
+
+}
+
+static inline void xmdio_address (volatile unsigned int *_mmio, 
+		uint32_t phy_addr, uint32_t dev_ad, uint32_t address) {
+	uint32_t st_field = 0x0 ;
+	uint32_t op_type  = 0x0 ; /* address operation */
+	uint32_t ta_field = 0x2 ; /* ta field */
+
+	_mmio [0x11] =  ( ( st_field & 0x3    ) << 30 ) |
+		( ( op_type  & 0x3    ) << 28 ) | 
+		( ( phy_addr & 0x1F   ) << 23 ) | 
+		( ( dev_ad  & 0x1F   ) << 18 ) | 
+		( ( ta_field & 0x3    ) << 16 ) | 
+		( ( address  & 0xffff ) <<  0 ) ;
+
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x1 << 3 ) | 0x5 ;
+	_mmio [0x10] =  ( 0x0 << 3 ) | 0x5 ;
+
+	/* wait for dev_ad cycle to complete */
+	while (_mmio [0x14] & 0x1) {
+	} ; 
+
+}
+ 
+#endif
diff --git a/include/asm-mips/rmi/xlr_pcix_boot.h b/include/asm-mips/rmi/xlr_pcix_boot.h
new file mode 100644
index 0000000..8dc3056
--- /dev/null
+++ b/include/asm-mips/rmi/xlr_pcix_boot.h
@@ -0,0 +1,42 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PCIX_BOOT_H__
+#define __PCIX_BOOT_H__
+
+#define PCIX_BOOT_FILE_START    (2<<20)
+#define PCIX_BOOT_ARG_CNT_OFF   0x100 /* Number of args */
+#define PCIX_BOOT_ARGS_LEN_OFF  0x104 /* Total length of the args */
+#define PCIX_BOOT_ARGS_OFF      0x108 /*  args string */
+#define PCIX_BOOT_MAGIC         0xa5a5a5a5
+
+
+#endif
+
diff --git a/include/asm-mips/rmi/xlr_virt_uart.h b/include/asm-mips/rmi/xlr_virt_uart.h
new file mode 100644
index 0000000..8bbc4e0
--- /dev/null
+++ b/include/asm-mips/rmi/xlr_virt_uart.h
@@ -0,0 +1,68 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_XLR_VIRT_UART_H
+#define _ASM_XLR_VIRT_UART_H
+
+typedef struct test{
+        volatile unsigned char *tx_fifo;
+        volatile unsigned int *tx_pro;
+        volatile unsigned int  *tx_con;
+        volatile unsigned char *rx_fifo;
+        volatile unsigned int *rx_pro;
+        volatile unsigned int *rx_con;
+        volatile int *status;
+}virt_uart_struct;
+
+typedef struct outbyte_struct{
+      volatile unsigned char *rx_fifo;
+      volatile unsigned int *rx_pro;
+      volatile unsigned int  *rx_con;
+      volatile unsigned char *tx_fifo;
+      volatile unsigned int *tx_pro;
+      volatile unsigned int *tx_con;
+      volatile int *status;
+}virt_uart;
+
+#define USER_CMD_SIZE 			  (1*1024)
+#define USER_RESULT_SIZE 		  (7*1024)
+#define DELAY_TIME                         2
+#define VIRTUAL_UART_CONSOLE      	  "virt_uart"
+#define VIRTUAL_UART_CONSOLE_MAJOR        XLR_VIRT_UART_MAJOR
+#define VIRTUAL_UART_CONSOLE_MINOR        200
+#define VIRTUAL_UART_NR                   32
+#define VIRT_UART_OPENED 		  0xeadbeef
+#ifdef CONFIG_64BIT
+#define VIRT_UART_BUF_START               ((48<<20) | 0xffffffff80000000ULL)
+#else
+#define VIRT_UART_BUF_START               ((48<<20) | 0x80000000)
+#endif
+#endif
+
-- 
1.6.0.2.GIT

