From 3154b74d155eb81c92f8d5aa5152817672f0547e Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 17 Dec 2008 10:28:17 +0800
Subject: [PATCH] rmi xlr pcix support

RMI XLR on-chip PCI-X support.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/pci/Makefile      |    1 +
 arch/mips/pci/pci-phoenix.c |  651 +++++++++++++++++++++++++++++++++++++++++++
 drivers/pci/pci.c           |   21 ++-
 drivers/pci/probe.c         |  100 +++++++-
 4 files changed, 769 insertions(+), 4 deletions(-)
 create mode 100644 arch/mips/pci/pci-phoenix.c

diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index c8c32f4..76520c1 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -49,5 +49,6 @@ obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-rbtx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
+obj-$(CONFIG_RMI_PHOENIX)  	+= pci-phoenix.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
diff --git a/arch/mips/pci/pci-phoenix.c b/arch/mips/pci/pci-phoenix.c
new file mode 100644
index 0000000..be19639
--- /dev/null
+++ b/arch/mips/pci/pci-phoenix.c
@@ -0,0 +1,651 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+
+#include <asm/io.h>
+
+#include <asm/rmi/interrupt.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/pci.h>
+#include <asm/rmi/io.h>         
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+#define  PCI_HT_LCTR_INIT   0x0020  /* Initialization Complete  */
+#define  PCIE_LINK_STATE    0x4000  /* Bit 14, Datalink Status  */
+
+#define LSU_CFG0_REGID       0
+#define LSU_CERRLOG_REGID    9
+#define LSU_CERROVF_REGID    10
+#define LSU_CERRINT_REGID    11
+
+
+#define pci_cfg_offset(bus,devfn,where) (((bus)<<16)+((devfn)<<8)+(where))
+#define pci_cfg_addr(bus,devfn,where) pci_cfg_offset((bus)->number,(devfn),where)
+
+int  pci_start_busno;
+static int  pci_bus_status;
+static int  pci_start_bus_fixed;
+int  ht_start_busno = 0;
+static int  ht_start_bus_fixed;
+static void *pci_config_base;
+void *pci_io_base;
+static void *ht_io_base;
+
+volatile void *ht_config_base;
+/* Global Link Status */
+int link0 = 0, link1 = 0, link2 = 0, link3 = 0;
+
+#define CFGTYPE(x) ((x)<(1)?(0):(1))
+#define MB16 0x01000000
+
+#define SWAP32(x)				\
+        (((x) & 0xff000000) >> 24) |		\
+        (((x) & 0x000000ff) << 24) |		\
+        (((x) & 0x0000ff00) << 8)  |		\
+        (((x) & 0x00ff0000) >> 8)
+
+static __inline__ void disable_and_clear_cache_error(void)
+{
+	uint64_t lsu_cfg0 = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+	lsu_cfg0 = lsu_cfg0 & ~0x2e;
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID, lsu_cfg0);
+	/* Clear cache error log */
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+}
+
+static __inline__ void clear_and_enable_cache_error(void)
+{
+	uint64_t lsu_cfg0 = 0;
+
+	/* first clear the cache error logging register */
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID, 0);
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERROVF_REGID, 0);
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRINT_REGID, 0);
+
+	lsu_cfg0 = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID);
+	lsu_cfg0 = lsu_cfg0 | 0x2e;
+	write_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CFG0_REGID, lsu_cfg0);
+}
+
+static inline int ht_controller_init_done(void)
+{
+	int init_done=0;
+	phoenix_reg_t *ht_mmio = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+	phoenix_reg_t reg = cpu_to_le32(phoenix_read_reg(ht_mmio, (0xA4 >> 2)));
+	if ((uint16_t)reg & PCI_HT_LCTR_INIT)
+		init_done = 1;
+	else
+		printk("Skipping XLR HT-Controller Registration...\n");
+	return init_done;
+}
+
+#ifdef XLS
+void pcie_controller_init_done(void) {
+
+    phoenix_reg_t *pcie_mmio_le = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
+	phoenix_reg_t reg_link0     = phoenix_read_reg(pcie_mmio_le, (0x80 >> 2));
+	phoenix_reg_t reg_link1     = phoenix_read_reg(pcie_mmio_le, (0x84 >> 2));
+	phoenix_reg_t reg_link2  = 0;
+	phoenix_reg_t reg_link3  = 0;
+
+	if ((uint16_t)reg_link0 & PCIE_LINK_STATE)
+		link0 = 1;
+    else
+        link0 = 0;
+
+	if ((uint16_t)reg_link1 & PCIE_LINK_STATE)
+		link1 = 1;
+    else
+        link1 = 0;
+
+    if(is_xls2xx()){
+
+        reg_link2 = phoenix_read_reg(pcie_mmio_le, (0x180 >> 2));
+
+        if((uint16_t)reg_link2 & PCIE_LINK_STATE)
+            link2 = 1;
+        else 
+            link2 = 0;
+
+	    reg_link3 = phoenix_read_reg(pcie_mmio_le, (0x184 >> 2));
+
+        if((uint16_t)reg_link3 & PCIE_LINK_STATE)
+            link3 = 1;
+        else
+            link3 = 0;
+    }
+}
+#endif
+
+static inline __u32 pci_cfg_read_32bit(__u32 addr)
+{
+    __u32 temp = 0;
+    __u32 *p = (__u32 *) (pci_config_base + (addr & ~3));
+    __u64 cerr_cpu_log = 0;
+
+    disable_and_clear_cache_error();
+
+    temp = SWAP32(*p);
+
+    /* Read cache err log */
+    cerr_cpu_log = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+    if(cerr_cpu_log) {
+        /* Device doesn't exist. */
+        temp = ~0x0;
+    }
+    clear_and_enable_cache_error();
+    return temp;
+}
+
+static inline void pci_cfg_write_32bit(__u32 addr, __u32 data) {
+    
+        unsigned int *p = (unsigned int *)(pci_config_base + (addr & ~3));
+        *p = SWAP32(data);
+}
+
+/*
+ * Low-level HT Configuration READ and Write Routines
+ */
+static inline __u32 ht_cfg_read_32bit(unsigned long addr) {
+
+    __u8 *p;
+    __u32 temp = 0;
+    __u64 cerr_cpu_log = 0;
+
+    disable_and_clear_cache_error();
+    p = (__u8 *)((addr & ~3));
+    temp =  ( (*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | *p);
+
+    cerr_cpu_log = read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, 
+			LSU_CERRLOG_REGID);
+
+    if(cerr_cpu_log) {
+        /* Device doesn't exist. */
+        temp = ~0x0;
+    }
+    clear_and_enable_cache_error();
+    return temp;
+}
+
+static inline void ht_cfg_write_32bit(unsigned long addr, __u32 data) {
+
+    __u8 *p;
+    int i=0;
+    p = (__u8 *)((addr & ~3));
+
+    for(i=0;i<4;i++)
+        p[i] = (data >> (i<<3)) & 0xff;
+}
+
+/*
+ * HT Wrapper Routine: READ
+ */
+static int phoenix_htbios_read(struct pci_bus *bus, unsigned int devfn,
+                               int where, int size, u32 * val)
+{
+	__u32 data = 0;
+	unsigned long long int cfgaddr;
+
+	/* Keep track of where the PCIX
+	 * bus numbering starts from..
+	 */
+	if (!ht_start_bus_fixed) {
+		ht_start_busno     = (int)(bus->number);
+		ht_start_bus_fixed = 1;
+	}
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	cfgaddr = (long) ht_config_base +
+		CFGTYPE(bus->number - ht_start_busno) * MB16 +
+		pci_cfg_offset((int)(bus->number-ht_start_busno),devfn,where);
+
+	if (pci_bus_status)
+		data = ht_cfg_read_32bit(cfgaddr);
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * HT Wrapper Routine: WRITE
+ */
+static int phoenix_htbios_write(struct pci_bus *bus, unsigned int devfn,
+                                int where, int size, u32 val)
+{
+	unsigned long long int cfgaddr;
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!pci_bus_status)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	cfgaddr = (long) ht_config_base +
+		CFGTYPE(bus->number - ht_start_busno) * MB16 +
+		pci_cfg_offset((bus->number-ht_start_busno),devfn,where);
+
+
+	data = ht_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else
+		data = val;
+
+	ht_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int phoenix_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 * val)
+{
+	__u32 data = 0;
+
+	/* 
+	 * Keep track of where the PCIX
+	 * bus numbering starts from..
+	*/
+	if (!pci_start_bus_fixed) {
+		pci_start_busno     = (int)(bus->number);
+		pci_start_bus_fixed = 1;
+	}
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (pci_bus_status)
+		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number-pci_start_busno), 
+					devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int phoenix_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 val)
+{
+	__u32 cfgaddr = pci_cfg_offset((bus->number-pci_start_busno), devfn, 
+			where);
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!pci_bus_status)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else
+		data = val;
+
+	pci_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops phoenix_pci_ops = {
+	.read  = phoenix_pcibios_read,
+	.write = phoenix_pcibios_write
+};
+
+struct pci_ops phoenix_ht_ops = {
+	.read  = phoenix_htbios_read,
+	.write = phoenix_htbios_write
+};
+
+/*
+ * XLR PCIX Controller
+ */
+static struct resource phoenix_mem_resource = {
+	.name           = "PHOENIX PCI MEM",
+	.start          = 0xd0000000UL,          /* 256MB PCI mem @ 0xd000_0000 */
+	.end            = 0xdfffffffUL,
+	.flags          = IORESOURCE_MEM,
+};
+static struct resource phoenix_io_resource = {
+	.name           = "PHOENIX IO MEM",
+	.start          = 0x10000000UL,         /* 16MB PCI IO @ 0x1000_0000 */
+	.end            = 0x100fffffUL,
+	.flags          = IORESOURCE_IO,
+};
+struct pci_controller phoenix_controller = {
+	.index          = 0,
+	.pci_ops        = &phoenix_pci_ops,
+	.mem_resource   = &phoenix_mem_resource,
+	.io_resource    = &phoenix_io_resource,
+	.io_offset      = 0x00000000UL,
+	.mem_offset     = 0x00000000UL
+};
+
+/*
+ * XLR HT Controller
+ */
+static struct resource phoenix_htmem_resource = {
+	.name           = "PHOENIX HT MEM",
+	.start          = 0xc0000000UL,     /* 256MB HT mem @ 0xC0000000 */
+	.end            = 0xcfffffffUL,
+	.flags          = IORESOURCE_MEM,
+};
+static struct resource phoenix_htio_resource = {
+	.name           = "PHOENIX HT IO",
+	.start          = 0x14000000UL,     /* 16MB HT IO @ 0x1400_0000 */
+	.end            = 0x140fffffUL,
+	.flags          = IORESOURCE_IO,
+};
+struct pci_controller phoenix_ht_controller = {
+	.index          = 1,
+	.pci_ops        = &phoenix_ht_ops,
+	.mem_resource   = &phoenix_htmem_resource,
+	.io_resource    = &phoenix_htio_resource,
+	.io_offset      = 0x00000000UL,
+	.mem_offset     = 0x00000000UL
+};
+
+/* I/O routines for IDE on PCI */
+#define pci_ide_phys_to_virt(x) 		\
+	(((x) - (phoenix_io_resource.start)) + (unsigned long)pci_io_base)
+
+inline void 
+rmi_ide_mm_insw(unsigned long port, void *addr, u32 count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u16 *)addr = (__raw_readw(v_port));
+		addr += 2;
+	}
+}
+
+inline void 
+rmi_ide_mm_insl(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u32 *)addr = (__raw_readl(v_port));
+		addr += 4;
+	}
+}
+
+inline void 
+rmi_ide_mm_outsw(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		__raw_writew(*(u16 *)addr, v_port);
+		addr += 2;
+	}
+}
+
+inline void 
+rmi_ide_mm_outsl(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		__raw_writel(*(u32 *)addr, v_port);
+		addr += 4;
+	}
+}
+
+u8 rmi_ide_mm_inb (unsigned long port)
+{
+	return((u8)__raw_readb(pci_ide_phys_to_virt(port)));
+}
+
+static u16 rmi_ide_mm_inw (unsigned long port)
+{
+	return ((u16) swab16(__raw_readw(pci_ide_phys_to_virt(port))));
+}
+
+/* Not part of hwif anymore; remove static declaration */
+u32 rmi_ide_mm_inl (unsigned long port)
+{
+	return ((u32)swab32(__raw_readl(pci_ide_phys_to_virt(port))));
+}
+
+void rmi_ide_mm_outb (u8 value, unsigned long port)
+{
+	__raw_writeb(value, pci_ide_phys_to_virt(port));
+}
+
+static void 
+rmi_ide_mm_outbsync (ide_drive_t *drive, u8 value, unsigned long port)
+{
+	__raw_writeb(value, pci_ide_phys_to_virt(port));
+}
+
+static void rmi_ide_mm_outw (u16 value, unsigned long port)
+{
+	__raw_writew(swab16(value), pci_ide_phys_to_virt(port));
+}
+
+/* Not part of hwif anymore; remove static declaration */
+void rmi_ide_mm_outl (u32 value, unsigned long port)
+{
+	__raw_writel(swab32(value), pci_ide_phys_to_virt(port));
+}
+
+int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+    /* Sane default values for XLR */
+    int index = 0;
+    int retVal= PIC_PCIX_IRQ;    
+
+    if (is_xls() && !is_xls2xx()) {
+        if (link0) {
+            if (dev->bus->number == 1)
+                return 0x22;
+            else
+                return 0x23;
+        }
+        else if (link1) {
+            if (dev->bus->number == 1)
+                return 0x23;
+        }
+	} else if (is_xls2xx()) {
+        if (dev->bus->number>0)
+            switch(dev->bus->self->devfn){
+            case 0x0:
+                return 0x22;
+            case 0x8:
+                return 0x23;
+            case 0x10:
+                return 0x1f;
+            case 0x18:
+                return 0x20;
+            default:
+                break;
+            }
+        else 
+            return 0x23;
+		/*
+		 * Need to FIX!!!, XLS logic does same.. Or probably
+         * we would never come here with bus number ZERO
+		*/
+	} else {
+        /* XLR */
+        index = ((struct pci_controller *)(dev->sysdata))->index;
+        if(index == 0)
+            /* IRQ Vector 24 for PCI/X Devices */
+            retVal = PIC_PCIX_IRQ;   
+        else if (index == 1)
+            /* IRQ Vector 23 for HT Devices */
+            retVal = PIC_HYPER_IRQ;  
+    }
+    return retVal;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+        return 0;
+}
+
+extern int pci_probe_only;
+
+/* Enabled by default */
+static int __initdata xlr_nopci = 0; 
+
+static int __init xlr_nopci_setup(char *str)
+{
+    /* Disable PCI/X/E; disables HT also */
+	xlr_nopci = 1;  
+	return 1;
+}
+__setup("xlr_nopci", xlr_nopci_setup);
+
+extern uint32_t dev_tree_en;
+extern int fdt_get_pci_ht_map(int *pci_map, int *ht_map);
+
+static int __init pcibios_init(void)
+{
+	int pci_map = 0x0, ht_map = 0x0;
+
+	if (xlr_nopci || xlr_board_atx_iii() || xlr_board_atx_v() ) 
+        return 0;
+
+	if(dev_tree_en)
+		fdt_get_pci_ht_map(&pci_map, &ht_map);
+
+	/* PSB assigns PCI resources */
+	pci_probe_only = 1;
+
+	/* Map the PCIX CFG space */
+	pci_config_base = ioremap(DEFAULT_PCI_CONFIG_BASE, (32<<20));
+	if (!pci_config_base) {
+		printk("Unable to map PCI config space!\n");
+		return 1;
+	}
+
+	/* Map the HT CFG spaces... */
+	ht_config_base = ioremap(DEFAULT_HT_TYPE0_CFG_BASE, (32<<20));
+	if (!ht_config_base) {
+		printk("Unable to map HT config space!\n");
+		return 1;
+	}
+
+	unsigned long phys = phoenix_io_resource.start;
+	unsigned long size = phoenix_io_resource.end - phoenix_io_resource.start + 1;
+
+	pci_io_base = ioremap(phys, size);
+	if (!pci_io_base)
+		printk("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+			   __func__, phys, size);
+	else
+		printk("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+			   __func__, phys, size, pci_io_base);
+
+	phys = phoenix_htio_resource.start;
+	size = phoenix_htio_resource.end - phoenix_htio_resource.start + 1;
+
+	ht_io_base = ioremap(phys, size);
+	if (!ht_io_base)
+		printk("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+			   __func__, phys, size);
+	else
+		printk("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+			   __func__, phys, size, ht_io_base);
+
+	pci_bus_status = 1;
+	pci_start_bus_fixed = 0;
+	ht_start_bus_fixed = 0;
+
+	/* IO Range for 16MB from where the MEM Range Ends */
+	ioport_resource.start =  0;
+	ioport_resource.end   = ~0;
+    printk("Registering XLR/XLS PCIX/PCIE Controller. \n");
+#ifdef XLS
+    if (is_xls())
+        pcie_controller_init_done();
+#endif
+    register_pci_controller(&phoenix_controller);
+
+    /* XLS : No native HT */
+    if (!is_xls()) {
+        /* XLR : ATX1, ATX2B Boards */
+        if ((xlr_board_atx_i() || xlr_board_atx_ii_b()) && ht_controller_init_done()) {
+            printk("Registering XLR HT Controller. \n");
+            register_pci_controller(&phoenix_ht_controller);
+        }
+    }
+	return 0;
+}
+
+arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
+
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9884bb..b261c65 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pm_wakeup.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
+#include <asm/rmi/sim.h>
 
 unsigned int pci_pm_d3_delay = 10;
 
@@ -1656,9 +1657,16 @@ pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 {
 	if (!pci_dma_supported(dev, mask))
 		return -EIO;
-
+#ifdef CONFIG_RMI_PHOENIX
+	if(mask > DMA_32BIT_MASK)
+		return -EIO;
+	if(xlr_revision_c())
+		dev->dma_mask = mask & 0x7fffffffULL;
+    else
+		dev->dma_mask = mask;
+#else
 	dev->dma_mask = mask;
-
+#endif
 	return 0;
 }
     
@@ -1668,7 +1676,16 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 	if (!pci_dma_supported(dev, mask))
 		return -EIO;
 
+#ifdef CONFIG_RMI_PHOENIX
+	if(mask > DMA_32BIT_MASK)
+		return -EIO;
+	if(xlr_revision_c())
+		dev->dev.coherent_dma_mask = mask & 0x7fffffffULL;
+	else
+		dev->dev.coherent_dma_mask = mask;
+#else
 	dev->dev.coherent_dma_mask = mask;
+#endif
 
 	return 0;
 }
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index bcafbd6..bd3e808 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -17,6 +17,24 @@
 #define PCI_CFG_SPACE_SIZE	256
 #define PCI_CFG_SPACE_EXP_SIZE	4096
 
+#ifdef CONFIG_RMI_PHOENIX
+/* Hack! This file includes references to XLR
+ * specific routines/defines. To be removed...
+ * -------------------------------------------
+ * The Global ht_start_busno variable (set in
+ * pci-phoenix.c) is used here, as a reference 
+ * to programming the Seconday/Subordinate bus 
+ * nrs. during bridge scans...
+ */
+extern int ht_start_busno;
+/*
+ * for the is_xls routine.
+ */
+#include <asm/rmi/sim.h>    
+extern void pcie_controller_init_done(void);
+extern int link0, link1, link2, link3;
+#endif
+
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
@@ -554,6 +572,10 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 
+#ifdef CONFIG_RMI_PHOENIX
+	buses = buses + ((ht_start_busno<<8) | (ht_start_busno<<16));
+#endif
+
 	dev_dbg(&dev->dev, "scanning behind bridge, config %06x, pass %d\n",
 		buses & 0xffffff, pass);
 
@@ -563,7 +585,11 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
+#ifdef CONFIG_RMI_PHOENIX
+	if ((buses & 0xffff00) && !is_cardbus) {
+#else
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
+#endif
 		unsigned int cmax, busnr;
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -1001,7 +1027,14 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */
+#ifdef CONFIG_RMI_PHOENIX
+	if(xlr_revision_c())
+		dev->dma_mask = DMA_31BIT_MASK;
+	else
+		dev->dma_mask = DMA_32BIT_MASK;
+#else
 	dev->dma_mask = 0xffffffff;
+#endif
 	if (pci_setup_device(dev) < 0) {
 		kfree(dev);
 		return NULL;
@@ -1020,7 +1053,14 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
+#ifdef CONFIG_RMI_PHOENIX
+	if(xlr_revision_c())
+		dev->dev.coherent_dma_mask = DMA_31BIT_MASK;
+	else
+		dev->dev.coherent_dma_mask = DMA_32BIT_MASK;
+#else
 	dev->dev.coherent_dma_mask = 0xffffffffull;
+#endif
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);
@@ -1106,18 +1146,74 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
 
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int devfn_start = 0x00;
+	unsigned int devfn_max   = 0x100;
+	int all_absent = 0;
+    
+	if(is_xls2xx()){
+		if(!link0 && !link1 && !link2 && !link3)
+			all_absent = 1;
+	}
+#endif
 	pr_debug("PCI: Scanning bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
 
+#ifdef CONFIG_RMI_PHOENIX
+	if (is_xls() && !is_xls2xx()) {
+		if (link0 && (!link1)) {
+			if (bus->number == 0)
+				devfn_max = 0x08;
+		}
+		if ((!link0) && link1) {
+			if (bus->number == 0)
+				devfn_start = 0x08;
+		}
+	}
+#endif
+
 	/* Go find them, Rover! */
-	for (devfn = 0; devfn < 0x100; devfn += 8)
+#ifdef CONFIG_RMI_PHOENIX
+	for (devfn = devfn_start; devfn < devfn_max; devfn += 8) {
+        if (bus->number==0 && is_xls2xx() && !all_absent) {
+			switch(devfn){
+				case 0x0:
+					if(!link0)
+					continue;
+					break;
+				case 0x8:
+					if(!link1)
+						continue;
+					break;
+				case 0x10:
+					if(!link2)
+						continue;
+					break;
+				case 0x18:
+					if(!link3)
+						continue;
+					break;
+				default:
+					break;
+			}
+		}
+#else
+	for (devfn = 0; devfn < 0x100; devfn += 8){
+#endif
 		pci_scan_slot(bus, devfn);
-
+    }
 	/*
 	 * After performing arch-dependent fixup of the bus, look behind
 	 * all PCI-to-PCI bridges on this bus.
 	 */
 	pr_debug("PCI: Fixups for bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
 	pcibios_fixup_bus(bus);
+
+#ifdef CONFIG_RMI_PHOENIX
+	/*link2 and link3 are always set to zero incase of xls-4xx/6xx*/
+	if ((is_xls()) && (!link0) && (!link1) && (!link2) && (!link3))
+		return max;
+#endif
+
 	for (pass=0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
 			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
-- 
1.6.0.2.GIT

