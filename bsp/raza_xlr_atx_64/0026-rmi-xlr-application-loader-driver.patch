From d5cd6620a16ebfecad0a36900a973f79b34fe1fe Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 16 Dec 2008 19:07:19 +0800
Subject: [PATCH] rmi xlr application loader driver

RMI XLR application loader driver. It's for supplying an interface to load
applications in Linux.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/char/Kconfig       |    8 +
 drivers/char/Makefile      |    1 +
 drivers/char/phnx_loader.c |  462 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 471 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/phnx_loader.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index da8a40f..dff088e 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -50,6 +50,14 @@ config VT
 	  If unsure, say Y, or else you won't be able to do much with your new
 	  shiny Linux system :-)
 
+config PHOENIX_LOADER
+	bool "RMI Application Loader support"
+	depends on RMI_PHOENIX
+	default y
+	---help---
+	  RMI Application Loader support
+	  It's for supplying an interface to load applications in Linux.
+
 config CONSOLE_TRANSLATIONS
 	depends on VT
 	default y
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 542c194..1362d37 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_MVME147_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_MVME162_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_BVME6000_SCC)	+= generic_serial.o vme_scc.o
 obj-$(CONFIG_ROCKETPORT)	+= rocket.o
+obj-$(CONFIG_PHOENIX_LOADER) += phnx_loader.o
 obj-$(CONFIG_SERIAL167)		+= serial167.o
 obj-$(CONFIG_CYCLADES)		+= cyclades.o
 obj-$(CONFIG_STALLION)		+= stallion.o
diff --git a/drivers/char/phnx_loader.c b/drivers/char/phnx_loader.c
new file mode 100644
index 0000000..4ed3ff8
--- /dev/null
+++ b/drivers/char/phnx_loader.c
@@ -0,0 +1,462 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <asm/rmi/devices.h>
+#include <asm/rmi/phnx_loader.h>
+#include <asm/rmi/user/phnx_loader.h>
+#include <asm/rmi/pic.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/rwsem.h>
+#define dbg_msg(fmt, args...) printk(fmt,##args)
+
+#define Message(fmt, args...) printk("\n[%s]-[%d] "fmt"\n",__func__,__LINE__,##args)
+
+extern int xlr_lib_launch_userapp(int cpu);
+extern void wakeup_cpu(unsigned int cpu, unsigned long fn, unsigned long args);
+extern void xlr_send_stop_ipi(unsigned long mask);
+extern volatile unsigned int xlr_lib_shmem_size;
+static int phnx_loader_major;
+static spinlock_t phnx_loader_lock;
+static int phnx_loader_user = 0;
+static int phnx_map_sh_mem=0;
+static int phnx_map_persistent_mem = 0;
+static int phnx_map_load_addr = 0;
+static int phnx_map_app_shmem=0;
+unsigned char *xlr_persistent_data_start=NULL;
+unsigned char *xlr_persistent_data_start_orig=NULL;
+static uint64_t xlr_app_shmem_start = 0x0;
+
+unsigned int xlr_persistent_data_size=0;
+/* Size of the shared memory b/w Linux userapp and rmios apps */
+extern uint32_t phnx_app_sh_mem_sz;
+extern unsigned long  phnx_app_shmem_start;
+
+extern uint64_t phnx_loader_kuseg_size, phnx_loader_kuseg_start;
+extern uint32_t phnx_loader_kseg_size, phnx_loader_kseg_start;
+extern int xlr_loader_support;
+extern uint32_t phnx_loader_mask;
+extern void phnx_start_loader_threads(void);
+extern void prom_check_image(void);
+unsigned char load_env[32][6];
+
+struct wakeup_info
+{
+	int vcpu;
+    unsigned long long func;
+    unsigned long long data;
+};
+
+struct xlr_load_addr
+{
+	uint64_t phys;
+	uint64_t size;
+	uint32_t flag;
+}xlr_image_load_addr;
+
+
+static int phnx_loader_open (struct inode *inode, struct file *filp)
+{
+	uint32_t minor=0;
+	if(xlr_loader_support == 0) 
+		return -EPERM;
+
+	minor = MINOR(inode->i_rdev);	
+	if(minor == XLR_MAP_SLAVE_DEVICE){
+		filp->private_data = (void *)inode;
+		return 0;
+	}
+
+	/* ALLOW ONLY ONE OPEN at a time */
+	spin_lock(&phnx_loader_lock);
+	if(phnx_loader_user == 1){
+		spin_unlock(&phnx_loader_lock);
+		return -EAGAIN;
+	}
+	filp->private_data = (void *)inode;
+	phnx_loader_user = 1;
+	phnx_map_load_addr = 0;
+	phnx_map_persistent_mem = 0;
+	phnx_map_sh_mem = 0;
+	phnx_map_app_shmem = 0;
+
+	spin_unlock(&phnx_loader_lock);
+
+
+	return 0;
+}
+
+
+int phnx_loader_ioctl (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned int *addr = (unsigned int*)arg;
+
+	switch (cmd) {
+		case PHNX_LOADER_IOC_LIB_BKP:
+		{
+			if(xlr_persistent_data_start_orig){
+				if(put_user(1, addr)){
+					panic("\nput_user failed for lib_bkp\n");
+				}
+			}
+			else{
+				if(put_user(0, addr))
+					panic("\nput_user failed for lib_bkp\n");
+			}
+		}
+		break;
+		case PHNX_LOADER_IOC_APP_SHMEM_RESERVE:
+		{
+			if(xlr_app_shmem_start){
+				if(put_user(1, addr)){
+					panic("\nput_user failed for lib_bkp\n");
+				}
+			}
+			else{
+				if(put_user(0, addr)){
+					panic("\nput_user failed for lib_bkp\n");
+				}
+			}	
+		}
+		break;
+		case PHNX_LOADER_IOC_APP_SHMEM_PHYS:
+		{
+				if(get_user(xlr_app_shmem_start, (uint64_t *)addr)){
+					panic("\nput_user failed for lib_bkp\n");
+				}
+		}
+		break;
+		case PHNX_LOADER_IOC_SHMEM_SIZE: 
+		{
+			Message(" available shared mem [%#x]",xlr_lib_shmem_size);
+			if(put_user(xlr_lib_shmem_size, addr)){
+				panic("\nput user failed for ioc shmem size\n");
+			}
+		}
+		break;
+		case PHNX_LOADER_IOC_APP_SHMEM_SIZE:
+		{
+			if(put_user(phnx_app_sh_mem_sz, addr)){
+				panic("\nput user failed for ioc shmem size\n");
+			}
+		}
+		break;
+		case PHNX_LOADER_IOC_MMAP_SHMEM:
+		{
+			phnx_map_sh_mem = 1;
+			phnx_map_persistent_mem = 0;
+			phnx_map_load_addr = 0;
+			phnx_map_app_shmem = 0;
+		}
+		break;
+	
+		case PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM:
+		{
+			unsigned long tmp_addr=0;
+			if(get_user(xlr_persistent_data_size,(unsigned int *)addr)){
+				panic("\nGetUser Failed for alloc persistent mem\n");	
+			}
+			if(!xlr_persistent_data_size){
+				printk("\nInvalid Len %#x\n", xlr_persistent_data_size);
+				return -EINVAL;
+			}
+			xlr_persistent_data_start_orig = 
+				kmalloc(xlr_persistent_data_size+PAGE_SIZE, GFP_KERNEL|GFP_DMA);
+			if(!xlr_persistent_data_start_orig)
+				return -ENOMEM;
+			xlr_persistent_data_start = (unsigned char *)
+						(((unsigned long)(xlr_persistent_data_start_orig + 
+											PAGE_SIZE)) & ~(PAGE_SIZE-1));
+			tmp_addr = (unsigned long)xlr_persistent_data_start;
+			while(tmp_addr < (unsigned long)
+						(xlr_persistent_data_start+xlr_persistent_data_size)){
+                SetPageReserved(virt_to_page((void *)tmp_addr));
+                tmp_addr += PAGE_SIZE;	
+			}
+		}
+		break;
+
+		case PHNX_LOADER_IOC_FREE_PERSISTENT_MEM:
+		{
+			unsigned long addr=0;
+			if(!xlr_persistent_data_start_orig){
+				printk("\nData Is Not Allocated.\n");
+				return -EINVAL;
+			}
+			addr = (unsigned long)xlr_persistent_data_start;
+			while(addr < (unsigned long)
+						(xlr_persistent_data_start+xlr_persistent_data_size)){
+                ClearPageReserved(virt_to_page((void *)addr));
+                addr += PAGE_SIZE;	
+			}
+			kfree(xlr_persistent_data_start_orig);
+			xlr_persistent_data_start_orig = xlr_persistent_data_start = NULL;
+		}
+		break;
+
+		case PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM:
+		{
+			phnx_map_persistent_mem = 1;
+			phnx_map_sh_mem = 0;
+			phnx_map_load_addr = 0;
+			phnx_map_app_shmem = 0;
+		}
+		break;
+
+		case PHNX_LOADER_IOC_MMAP_LOAD_ADDR:
+		{
+			if(copy_from_user((void *)&xlr_image_load_addr,
+								(const void __user *)addr,
+								sizeof(struct xlr_load_addr)))
+					panic("\nmmap load addr - copy frm user - failed\n");
+			phnx_map_load_addr = 1;
+			phnx_map_persistent_mem = 0;
+			phnx_map_sh_mem = 0;
+			phnx_map_app_shmem = 0;
+		}
+		break;
+		case PHNX_LOADER_IOC_MMAP_APP_SHMEM:
+		{
+			phnx_map_app_shmem = 1;
+			phnx_map_persistent_mem = 0;
+			phnx_map_sh_mem = 0;
+			phnx_map_load_addr = 0;
+		}
+		break;
+		case PHNX_LOADER_IOC_START_IPI: 
+		{
+			struct wakeup_info tmp;
+			if(copy_from_user((void *)&tmp, (const void __user *)addr,
+								sizeof(struct wakeup_info)))
+				panic("\nCopyFrm User Failed For START IPI\n");
+			wakeup_cpu(tmp.vcpu, (unsigned long)tmp.func, 
+									(unsigned long)tmp.data);
+		}
+		break;
+
+		case PHNX_LOADER_IOC_STOP_IPI:
+		{
+			uint32_t vcpu=0;
+			if(get_user(vcpu, (uint32_t *)addr))
+				panic("\nGetUser Failed for stop ipi\n");	
+			/*Below Func Is Library Call.*/
+			xlr_send_stop_ipi(vcpu);
+		}
+		break;
+		case PHNX_LOADER_IOC_LAUNCH_KSEG:
+		{
+				uint32_t vcpu=0;
+				if(get_user(vcpu, (uint32_t *)addr))
+						panic("\nGetUser Failed for launch kseg\n");
+				/*Below Func Is Library Call.*/
+				xlr_lib_launch_userapp(vcpu);
+		}
+		break;
+		case PHNX_LOADER_STORE_ENV:
+		{
+				int i;
+				unsigned char temp[32][6];
+				copy_from_user ((void *)&temp , (const void __user *)addr, sizeof(temp));
+
+				for (i=0; i<32; i++)    {
+						if (strcmp(temp[i],"") != 0)
+								strcpy(load_env[i],temp[i]);
+				}
+		}
+                break;
+		default:
+		{
+			printk("ioctl(): invalid command=0x%x\n", cmd);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static long phnx_loader_compat_ioctl(struct file *filp, unsigned int cmd, 
+		unsigned long arg)
+{
+	unsigned long ret = -1;
+	Message("");
+	lock_kernel();	
+	Message("Got the user space address [%#lx]",arg);
+	ret = phnx_loader_ioctl(NULL,filp,cmd,(uint32_t)arg);
+	unlock_kernel();
+	if(ret){
+		printk("tb_ioctl returned with an error.");
+		return -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+static int phnx_loader_map_helper(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	uint64_t shm_addr;
+	unsigned long shm_size;
+	unsigned long size = 0;
+	int result = 0;
+	unsigned long shm_pfn_addr = 0;
+	struct inode *i;
+	uint32_t minor;
+	i = (struct inode *)file->private_data;
+	minor = MINOR(i->i_rdev);	
+	if(minor == XLR_MAP_SLAVE_DEVICE){
+		shm_addr = xlr_app_shmem_start+offset;
+		shm_size = phnx_app_sh_mem_sz-offset;
+		shm_pfn_addr = (unsigned long)((uint64_t)shm_addr >> PAGE_SHIFT);
+	}else if(phnx_map_sh_mem){
+		shm_addr = (uint64_t)(49<<20);
+		shm_size = xlr_lib_shmem_size; 
+		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
+	}else if(phnx_map_persistent_mem){
+		shm_addr = (uint64_t)virt_to_phys(xlr_persistent_data_start);
+		shm_size = xlr_persistent_data_size;
+		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
+	}else if(phnx_map_load_addr){
+		shm_addr = xlr_image_load_addr.phys;
+		shm_size = (unsigned long)xlr_image_load_addr.size;
+		shm_pfn_addr = ((uint64_t)shm_addr >> PAGE_SHIFT);
+	}else if(phnx_map_app_shmem){
+		shm_addr = xlr_app_shmem_start;
+		shm_size = phnx_app_sh_mem_sz;
+		shm_pfn_addr = (unsigned long)((uint64_t)shm_addr >> PAGE_SHIFT);
+	}else{
+		printk("\nInvalid mmap command.\n");
+		return -EINVAL;
+	}
+	dbg_msg("[%s]: shm_addr=%lx, shm_size=%lx, offset = %lx, vm_start=%lx, vm_flags=%lx, vm_page_prot=%lx\n",
+			__func__, shm_addr, shm_size, offset, vma->vm_start, vma->vm_flags, pgprot_val(vma->vm_page_prot));
+	if (!shm_addr) return -ENXIO;
+
+	if(shm_addr & (PAGE_SIZE-1)){
+		printk("\nMmaping to invalid address ... %#llx\n",
+						(unsigned long long)shm_addr);
+		return -EINVAL;
+	}
+	if (offset >= shm_size) return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED) return -EPERM;
+
+	size = vma->vm_end - vma->vm_start;
+	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
+	if(phnx_map_load_addr && (xlr_image_load_addr.flag == XLR_MAP_UNCACHED)){
+		pgprot_val (vma->vm_page_prot) |= _CACHE_UNCACHED;
+	}else{
+		pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
+	}
+	result = remap_pfn_range(vma, vma->vm_start, shm_pfn_addr, size, 
+								vma->vm_page_prot);
+	if (result) return -EAGAIN;
+
+	return 0;
+}
+static int phnx_loader_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int res;
+	
+	res = phnx_loader_map_helper(file, vma);
+	phnx_map_app_shmem = 0;
+	phnx_map_sh_mem = 0;
+	phnx_map_persistent_mem = 0;
+	phnx_map_load_addr = 0;
+	return res;
+}
+
+static int phnx_loader_release (struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int phnx_loader_flush(struct file *fp, fl_owner_t id)
+{
+	uint32_t minor=0;
+	struct inode *inode = (struct inode *)(fp->private_data);
+	minor = MINOR(inode->i_rdev);
+	if(minor == XLR_MAP_SLAVE_DEVICE){
+		return 0;
+	}
+	spin_lock(&phnx_loader_lock);
+	phnx_loader_user = 0;
+	spin_unlock(&phnx_loader_lock);
+	return 0;
+
+}
+
+struct file_operations phnx_loader_fops = {
+	.mmap     = phnx_loader_mmap,
+	.open	  = phnx_loader_open,
+	.ioctl    = phnx_loader_ioctl,
+	.release  = phnx_loader_release,
+	.flush = phnx_loader_flush,
+	.compat_ioctl = phnx_loader_compat_ioctl,
+};
+
+static int __init phnx_loader_init(void)	
+{
+	if(xlr_loader_support == 0)
+		return -EINVAL;
+
+	spin_lock_init(&phnx_loader_lock);
+
+	phnx_loader_major = register_chrdev (XLR_APP_LOADER_MAJOR, 
+								PHNX_APP_LOADER_CHRDEV_NAME, &phnx_loader_fops);
+
+	if (phnx_loader_major < 0) {
+		printk("[%s]: register_chrdev failed\n", __func__);
+		return phnx_loader_major;
+	}
+
+	/* Launch the threads now */
+	phnx_start_loader_threads();
+
+	printk("Registered phoenix app loader driver: phnx_loader_major=%d\n", XLR_APP_LOADER_MAJOR);
+
+	return 0;
+}
+
+static void __exit phnx_loader_exit(void)
+{
+	/*TODO: Clean up*/
+	unregister_chrdev (phnx_loader_major, PHNX_APP_LOADER_CHRDEV_NAME);
+}
+
+module_init (phnx_loader_init);
+module_exit (phnx_loader_exit);
+
-- 
1.6.0.2.GIT

