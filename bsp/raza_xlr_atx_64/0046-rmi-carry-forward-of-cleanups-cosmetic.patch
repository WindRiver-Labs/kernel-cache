From 8a46aef1417e0a55df2b9d1b73184704f74aeb6d Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sun, 21 Jun 2009 18:59:21 -0400
Subject: [PATCH 46/49] rmi: carry forward of cleanups - cosmetic

This is a carry forward of the cleanups done on the 2.6.21
codebase. While the changes here are 100% cosmetic, they are
important in allowing easy comparisons between the two trees.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/mips/kernel/csrc-phoenix.c |   65 ++++++++++++++++++++-------------------
 arch/mips/rmi/phoenix/irq.c     |    5 ++-
 2 files changed, 37 insertions(+), 33 deletions(-)

diff --git a/arch/mips/kernel/csrc-phoenix.c b/arch/mips/kernel/csrc-phoenix.c
index 4c8865e..c133b66 100644
--- a/arch/mips/kernel/csrc-phoenix.c
+++ b/arch/mips/kernel/csrc-phoenix.c
@@ -1,28 +1,18 @@
 /*
- *  Copyright 2008 Wind River Systems, Inc. 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
- *  Author: Jack Tan <jack.tan@windriver.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * Copyright (C) 2008 Wind River Systems, Inc.
+ *   written by Ralf Baechle
  */
-
 #include <linux/clocksource.h>
+#include <linux/init.h>
 
 #include <asm/irq.h>
 #include <asm/ptrace.h>
 #include <asm/addrspace.h>
+#include <asm/mipsregs.h>
 #include <asm/time.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
@@ -31,47 +21,58 @@
 
 extern spinlock_t phnx_pic_lock;
 
-#define	PIC_TIMER6_MAX_VAL	0xffffffff
+/*
+ * PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit
+ * counter is sufficient
+ */
+#define PIC_TIMER6_MAX_VAL 0xffffffff
 
-static cycle_t xlr_hpt_read(void)
+static cycle_t phoenix_read(void)
 {
 	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
 	uint32_t counter = 0;
 
 	counter = phoenix_read_reg(mmio, PIC_TIMER_6_COUNTER_0);
 
-	return (cycle_t) (PIC_TIMER6_MAX_VAL - counter);
+	return (cycle_t)(PIC_TIMER6_MAX_VAL - counter);
 }
 
-struct clocksource phoenix_clocksource = {
-	.name	= "phoenix-timer6",
-	.rating	= 200 + PIC_CLKS_PER_SEC / 10000000,
-	.read	= xlr_hpt_read,
-	.mask	= CLOCKSOURCE_MASK(32),
-	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+static struct clocksource phoenix_clocksource = {
+	.name		= "phoenix",
+	.read		= phoenix_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
 int __init phoenix_clocksource_init(void)
 {
-	struct clocksource *cs = &phoenix_clocksource;
 	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
 	unsigned long flags;
 
 	spin_lock_irqsave(&phnx_pic_lock, flags);
 
-	/* Use PIC Timer 6 as a free running counter */
+	/*
+	 * Use PIC Timer 6 as a free running counter
+	 */
 	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_0, 0xffffffff);
 	phoenix_write_reg(mmio, PIC_TIMER_6_MAXVAL_1, 0x0);
-	/* we Don't need interrupts */
+
+	/*
+	 * We don't need interrupts
+	 */
 	phoenix_write_reg(mmio, PIC_IRT_0_TIMER_6, 0);
 	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_6,
-					  (1 << 31) | (0 << 30) | (1 << 6) | (PIC_TIMER_6_IRQ));
+			  (1 << 31) | (0 << 30) | (1 << 6) | PIC_TIMER_6_IRQ);
 	pic_update_control(1 << (8 + 6));
 
 	spin_unlock_irqrestore(&phnx_pic_lock, flags);
 
-	clocksource_set_clock(cs, PIC_CLKS_PER_SEC);
-	clocksource_register(cs);
+	/* Calculate a somewhat reasonable rating value */
+	phoenix_clocksource.rating = 200 + PIC_CLKS_PER_SEC / 10000000;
+
+	clocksource_set_clock(&phoenix_clocksource, PIC_CLKS_PER_SEC);
+
+	clocksource_register(&phoenix_clocksource);
 
 	return 0;
 }
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index 0671f2e..f353f16 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -43,6 +43,8 @@
 #include <asm/ptrace.h>
 #include <asm/kgdb.h>
 #include <asm/mipsregs.h>
+#include <asm/time.h>
+#include <asm/mmu_context.h>
 
 #include <asm/rmi/sim.h>
 #include <asm/rmi/msidef.h>
@@ -105,7 +107,7 @@ static void pic_ack(unsigned int irq)
 	unsigned long i, flags;
 	phoenix_reg_t reg;
 
-#ifdef	XLS
+#ifdef XLS
 	if (is_xls()) {
 		pcie_mmio_le = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
 	}
@@ -348,6 +350,7 @@ void __init init_phoenix_irqs(void)
 	irq_desc[PIC_TIMER_0_IRQ].action = &phnx_rsvd_action;
 	phnx_irq_mask |= (1ULL << PIC_TIMER_0_IRQ);
 
+	/* The driver installs a handler so, don't reserve it */
 	phnx_irq_mask |= (1ULL << IRQ_DUMMY_UART);
 
 	/*
-- 
1.6.3.2

