From 98b740af2f097ac5588b76a9276333e83194f875 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 17 Dec 2008 19:04:13 +0800
Subject: [PATCH] rmi xlr pci ide driver

RMI XLR PCI IDE driver.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/ide/ide-dma.c          |   36 +++++-
 drivers/ide/pci/pdc202xx_new.c |  324 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 359 insertions(+), 1 deletions(-)

diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3fa07c0..b0e6263 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -44,6 +44,11 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_RMI_PHOENIX
+extern void rmi_ide_mm_outl (u32 value, unsigned long port);
+extern void rmi_ide_mm_outb (u8 value, unsigned long port);
+#endif
+
 static const struct drive_list_entry drive_whitelist [] = {
 
 	{ "Micropolis 2112A"	,       NULL		},
@@ -378,8 +383,12 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 		dma_stat &= ~(1 << (5 + unit));
 
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
+#else
 		writeb(dma_stat,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
+#endif
 	else
 		outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
 }
@@ -470,14 +479,23 @@ int ide_dma_setup(ide_drive_t *drive)
 
 	/* PRD table */
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outl(hwif->dmatable_dma, 
+				(void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
+#else
 		writel(hwif->dmatable_dma,
-		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
+				(void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
+#endif
 	else
 		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
 
 	/* specify r/w */
 	if (mmio)
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(reading, hwif->dma_base + ATA_DMA_CMD);
+#else
 		writeb(reading, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
+#endif
 	else
 		outb(reading, hwif->dma_base + ATA_DMA_CMD);
 
@@ -486,8 +504,12 @@ int ide_dma_setup(ide_drive_t *drive)
 
 	/* clear INTR & ERROR flags */
 	if (mmio)
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+#else
 		writeb(dma_stat | 6,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
+#endif
 	else
 		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
 
@@ -517,8 +539,12 @@ void ide_dma_start(ide_drive_t *drive)
 	if (hwif->host_flags & IDE_HFLAG_MMIO) {
 		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 		/* start DMA */
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
+#else
 		writeb(dma_cmd | 1,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
+#endif
 	} else {
 		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
 		outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
@@ -543,8 +569,12 @@ int __ide_dma_end (ide_drive_t *drive)
 		/* get DMA command mode */
 		dma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 		/* stop DMA */
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
+#else
 		writeb(dma_cmd & ~1,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
+#endif
 	} else {
 		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
 		outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
@@ -555,8 +585,12 @@ int __ide_dma_end (ide_drive_t *drive)
 
 	if (mmio)
 		/* clear the INTR & ERROR bits */
+#ifdef CONFIG_RMI_PHOENIX
+		rmi_ide_mm_outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+#else
 		writeb(dma_stat | 6,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
+#endif
 	else
 		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
 
diff --git a/drivers/ide/pci/pdc202xx_new.c b/drivers/ide/pci/pdc202xx_new.c
index d477da6..efffded 100644
--- a/drivers/ide/pci/pdc202xx_new.c
+++ b/drivers/ide/pci/pdc202xx_new.c
@@ -41,6 +41,310 @@
 #define DBG(fmt, args...)
 #endif
 
+#ifdef CONFIG_RMI_PHOENIX
+extern void rmi_ide_mm_outb (u8 value, unsigned long port);
+extern u8 rmi_ide_mm_inb (unsigned long port);
+extern void rmi_ide_mm_insw(unsigned long port, void *addr, u32 count);
+extern void rmi_ide_mm_insl(unsigned long port, void *addr, unsigned int count);
+extern void rmi_ide_mm_outsw(unsigned long port, void *addr, unsigned int count);
+extern void rmi_ide_mm_outsl(unsigned long port, void *addr, unsigned int count);
+#undef inb
+#define inb rmi_ide_mm_inb
+#undef outb
+#define outb rmi_ide_mm_outb
+
+void rmi_ata_vlb_sync(unsigned long port)
+{
+	(void)inb(port);
+	(void)inb(port);
+	(void)inb(port);
+}   
+
+void phnx_exec_command(ide_hwif_t *hwif, u8 cmd)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		rmi_ide_mm_outb(cmd, hwif->io_ports.command_addr);
+	else
+		outb(cmd, hwif->io_ports.command_addr);
+}
+
+u8 phnx_read_status(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return rmi_ide_mm_inb(hwif->io_ports.status_addr);
+	else
+		return inb(hwif->io_ports.status_addr);
+}
+
+u8 phnx_read_altstatus(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return rmi_ide_mm_inb(hwif->io_ports.ctl_addr);
+	else
+		return inb(hwif->io_ports.ctl_addr);
+}
+
+u8 phnx_read_sff_dma_status(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return rmi_ide_mm_inb(hwif->dma_base + ATA_DMA_STATUS);
+	else
+		return inb(hwif->dma_base + ATA_DMA_STATUS);
+}
+
+void phnx_set_irq(ide_hwif_t *hwif, int on)
+{
+	u8 ctl = ATA_DEVCTL_OBS;
+
+	if (on == 4) { /* hack for SRST */
+		ctl |= 4;
+		on &= ~4;
+	}
+
+	ctl |= on ? 0 : 2;
+
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		rmi_ide_mm_outb(ctl, hwif->io_ports.ctl_addr);
+	else
+		outb(ctl, hwif->io_ports.ctl_addr);
+}
+
+void phnx_tf_load(ide_drive_t *drive, ide_task_t *task)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	struct ide_taskfile *tf = &task->tf;
+	void (*tf_outb)(u8 addr, unsigned long port);
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+	u8 HIHI = (task->tf_flags & IDE_TFLAG_LBA48) ? 0xE0 : 0xEF;
+
+	if (mmio)
+		tf_outb = rmi_ide_mm_outb;
+
+	if (task->tf_flags & IDE_TFLAG_FLAGGED)
+		HIHI = 0xFF;
+
+	if (task->tf_flags & IDE_TFLAG_OUT_DATA) {
+		u16 data = (tf->hob_data << 8) | tf->data;
+
+		if (mmio)
+			writew(data, (void __iomem *)io_ports->data_addr);
+	}
+
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_FEATURE)
+		tf_outb(tf->hob_feature, io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_NSECT)
+		tf_outb(tf->hob_nsect, io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAL)
+		tf_outb(tf->hob_lbal, io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAM)
+		tf_outb(tf->hob_lbam, io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAH)
+		tf_outb(tf->hob_lbah, io_ports->lbah_addr);
+
+	if (task->tf_flags & IDE_TFLAG_OUT_FEATURE)
+		tf_outb(tf->feature, io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_NSECT)
+		tf_outb(tf->nsect, io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAL)
+		tf_outb(tf->lbal, io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAM)
+		tf_outb(tf->lbam, io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAH)
+		tf_outb(tf->lbah, io_ports->lbah_addr);
+
+	if (task->tf_flags & IDE_TFLAG_OUT_DEVICE)
+		tf_outb((tf->device & HIHI) | drive->select.all,
+			 io_ports->device_addr);
+}
+
+void phnx_tf_read(ide_drive_t *drive, ide_task_t *task)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	struct ide_taskfile *tf = &task->tf;
+	void (*tf_outb)(u8 addr, unsigned long port);
+	u8 (*tf_inb)(unsigned long port);
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	if (mmio)
+		tf_outb = rmi_ide_mm_outb;
+		tf_inb  = rmi_ide_mm_inb;
+
+	if (task->tf_flags & IDE_TFLAG_IN_DATA) {
+		u16 data;
+
+		if (mmio)
+			data = readw((void __iomem *)io_ports->data_addr);
+
+		tf->data = data & 0xff;
+		tf->hob_data = (data >> 8) & 0xff;
+	}
+
+	/* be sure we're looking at the low order bits */
+	tf_outb(ATA_DEVCTL_OBS & ~0x80, io_ports->ctl_addr);
+
+	if (task->tf_flags & IDE_TFLAG_IN_FEATURE)
+		tf->feature = tf_inb(io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_NSECT)
+		tf->nsect  = tf_inb(io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAL)
+		tf->lbal   = tf_inb(io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAM)
+		tf->lbam   = tf_inb(io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAH)
+		tf->lbah   = tf_inb(io_ports->lbah_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_DEVICE)
+		tf->device = tf_inb(io_ports->device_addr);
+
+	if (task->tf_flags & IDE_TFLAG_LBA48) {
+		tf_outb(ATA_DEVCTL_OBS | 0x80, io_ports->ctl_addr);
+
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_FEATURE)
+			tf->hob_feature = tf_inb(io_ports->feature_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_NSECT)
+			tf->hob_nsect   = tf_inb(io_ports->nsect_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAL)
+			tf->hob_lbal    = tf_inb(io_ports->lbal_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAM)
+			tf->hob_lbam    = tf_inb(io_ports->lbam_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAH)
+			tf->hob_lbah    = tf_inb(io_ports->lbah_addr);
+	}
+}
+
+static inline void __phnx_mm_insw(void __iomem *port, void *addr, u32 count)
+{
+	__ide_flush_prologue();
+	rmi_ide_mm_insw((unsigned long)port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+	__ide_flush_epilogue();
+}
+
+static inline void __phnx_mm_insl(void __iomem *port, void *addr, u32 count)
+{
+	__ide_flush_prologue();
+	rmi_ide_mm_insl((unsigned long)port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+	__ide_flush_epilogue();
+}
+
+static inline void __phnx_mm_outsw(void __iomem *port, void *addr, u32 count)
+{
+	__ide_flush_prologue();
+	rmi_ide_mm_outsw((unsigned long)port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+	__ide_flush_epilogue();
+}
+
+static inline void __phnx_mm_outsl(void __iomem * port, void *addr, u32 count)
+{
+	__ide_flush_prologue();
+	rmi_ide_mm_outsl((unsigned long)port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+	__ide_flush_epilogue();
+}
+
+void phnx_input_data(ide_drive_t *drive, struct request *rq, void *buf,
+		    unsigned int len)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	unsigned long data_addr = io_ports->data_addr;
+	u8 io_32bit = drive->io_32bit;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	len++;
+
+	if (io_32bit) {
+		unsigned long uninitialized_var(flags);
+
+		if ((io_32bit & 2) && !mmio) {
+			local_irq_save(flags);
+			rmi_ata_vlb_sync(io_ports->nsect_addr);
+		}
+
+		if (mmio)
+			__phnx_mm_insl((void __iomem *)data_addr, buf, len / 4);
+		else
+			insl(data_addr, buf, len / 4);
+
+		if ((io_32bit & 2) && !mmio)
+			local_irq_restore(flags);
+
+		if ((len & 3) >= 2) {
+			if (mmio)
+				__phnx_mm_insw((void __iomem *)data_addr,
+						(u8 *)buf + (len & ~3), 1);
+			else
+				insw(data_addr, (u8 *)buf + (len & ~3), 1);
+		}
+	} else {
+		if (mmio)
+			__phnx_mm_insw((void __iomem *)data_addr, buf, len / 2);
+		else
+			insw(data_addr, buf, len / 2);
+	}
+}
+
+void phnx_output_data(ide_drive_t *drive, struct request *rq, void *buf,
+		     unsigned int len)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	unsigned long data_addr = io_ports->data_addr;
+	u8 io_32bit = drive->io_32bit;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	if (io_32bit) {
+		unsigned long uninitialized_var(flags);
+
+		if ((io_32bit & 2) && !mmio) {
+			local_irq_save(flags);
+			rmi_ata_vlb_sync(io_ports->nsect_addr);
+		}
+
+		if (mmio)
+			__phnx_mm_outsl((void __iomem *)data_addr, buf, len / 4);
+		else
+			outsl(data_addr, buf, len / 4);
+
+		if ((io_32bit & 2) && !mmio)
+			local_irq_restore(flags);
+
+		if ((len & 3) >= 2) {
+			if (mmio)
+				__phnx_mm_outsw((void __iomem *)data_addr,
+						 (u8 *)buf + (len & ~3), 1);
+			else
+				outsw(data_addr, (u8 *)buf + (len & ~3), 1);
+		}
+	} else {
+		if (mmio)
+			__phnx_mm_outsw((void __iomem *)data_addr, buf, len / 2);
+		else
+			outsw(data_addr, buf, len / 2);
+	}
+}
+
+static const struct ide_tp_ops phnx_tp_ops = {
+	.exec_command		= phnx_exec_command,
+	.read_status		= phnx_read_status,
+	.read_altstatus		= phnx_read_altstatus,
+	.read_sff_dma_status	= phnx_read_sff_dma_status,
+
+	.set_irq		= phnx_set_irq,
+
+	.tf_load		= phnx_tf_load,
+	.tf_read		= phnx_tf_read,
+
+	.input_data		= phnx_input_data,
+	.output_data		= phnx_output_data,
+};
+#endif
+
+
+
 static const char *pdc_quirk_drives[] = {
 	"QUANTUM FIREBALLlct08 08",
 	"QUANTUM FIREBALLP KA6.4",
@@ -479,6 +783,24 @@ static const struct ide_port_ops pdcnew_port_ops = {
 	.cable_detect		= pdcnew_cable_detect,
 };
 
+#ifdef CONFIG_RMI_PHOENIX
+
+#define DECLARE_PDCNEW_DEV(udma) \
+	{ \
+		.name		= DRV_NAME, \
+		.init_chipset	= init_chipset_pdcnew, \
+		.port_ops	= &pdcnew_port_ops, \
+		.tp_ops     = &phnx_tp_ops, \
+		.host_flags	= IDE_HFLAG_POST_SET_MODE | \
+				  IDE_HFLAG_ERROR_STOPS_FIFO | \
+				  IDE_HFLAG_OFF_BOARD | IDE_HFLAG_MMIO, \
+		.pio_mask	= ATA_PIO4, \
+		.mwdma_mask	= ATA_MWDMA2, \
+		.udma_mask	= udma, \
+	}
+
+#else
+
 #define DECLARE_PDCNEW_DEV(udma) \
 	{ \
 		.name		= DRV_NAME, \
@@ -492,6 +814,8 @@ static const struct ide_port_ops pdcnew_port_ops = {
 		.udma_mask	= udma, \
 	}
 
+#endif
+
 static const struct ide_port_info pdcnew_chipsets[] __devinitdata = {
 	/* 0: PDC202{68,70} */		DECLARE_PDCNEW_DEV(ATA_UDMA5),
 	/* 1: PDC202{69,71,75,76,77} */	DECLARE_PDCNEW_DEV(ATA_UDMA6),
-- 
1.6.0.2.GIT

