From 36653fb72e2238df42a6483f6a244055d6640114 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sun, 21 Jun 2009 19:14:04 -0400
Subject: [PATCH] rmi: clean up irq dispatch code

The irq dispatch code made use of some inline assembly that just
made the code harder to read and maintain, and also had its own
do_phnx_IRQ that has been integrated into plat_irq_dispatch for
clarity.  This brings the codebase in sync with that which was
enhanced for the 2.0 release.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/mips/rmi/phoenix/irq.c |  102 ++++++++++++++++++++-----------------------
 1 files changed, 47 insertions(+), 55 deletions(-)

diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index 032cb2b..f108241 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -387,26 +387,6 @@ void __init init_phoenix_irqs(void)
 
 }
 
-void do_phnx_IRQ(unsigned int irq)
-{
-#ifdef CONFIG_SMP
-#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
-	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE
-		|| irq == IRQ_IPI_NETRX) {
-#else
-	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
-#endif
-		phoenix_ipi_handler(irq, regs);
-		return;
-	}
-#endif
-	if (irq == IRQ_MSGRING || irq == PIC_TIMER_0_IRQ)
-		phnx_msgring_int_handler(irq, regs);
-	else
-		do_IRQ(irq);
-}
-
-
 void __init phoenix_smp_init(void)
 {
 	/* Set up kseg0 to be cachable coherent */
@@ -452,49 +432,61 @@ void __init arch_init_irq(void)
 	write_64bit_cp0_eimr(phnx_irq_mask | (1 << IRQ_TIMER));
 }
 
-static int __flb(uint64_t dw)
-{   
-	int ret;
-#ifdef CONFIG_64BIT
-    asm (
-			".set mips64\n\t"
-			"dclz %0, %1"
-			: "=r" (ret) : "r" (dw)
-		);
-#else
-	asm (
-			".set mips64\n\t"
-			"dsll %L1, %L1, 32\n\t"
-			"dsrl %L1, %L1, 32\n\t"
-			"dsll %M1, %M1, 32\n\t"
-			"or %L1, %L1, %M1\n\t"
-			"dclz %0, %L1\n\t"
-			".set mips0"
-			: "=r" (ret)
-			: "r" (dw)
-		);
-#endif        
-
-    return 63 - ret;
-}   
-
 asmlinkage void plat_irq_dispatch(void)
 {
-	uint64_t eirr;
-	int i = 0;
+	uint64_t eirr, eimr, pending;
+	int irq = 0;
 
-	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
+	/*
+	 * WARNING: you can mask irq through PIC, using eimr is not recommended.
+	 * If irmr is used, more work in this function needs to be done.
+	 */
+	eirr = read_64bit_cp0_eirr();
+	eimr = read_64bit_cp0_eimr();
+
+	pending = eirr & eimr;
+	if (unlikely(!pending)) {
+		/* According to the datasheet eirr must be cleared manually */
+		if (eirr & ~eimr)
+			write_64bit_cp0_eirr(eirr & ~eimr);
+		return;
+	}
 
-	i = __flb(eirr);
+	if (eirr & (1 << IRQ_TIMER)) {
+		do_IRQ(IRQ_TIMER);
+		return;
+	}
 
-	if (i == -1) {
+	for (irq = 63; irq != -1; irq--) {
+		if (eirr & (1ULL << irq))
+			break;
+		else if (eirr & (1ULL << irq)) {/* eirr also must be cleared */
+			write_64bit_cp0_eirr(1ULL << irq);
+			continue;
+		}
+	}
+
+	if (irq == -1) {
 		printk("no interrupt !!\n");
 		return;
 	}
 
-	/*ack eirr */
-	write_64bit_cp0_eirr(1ULL << i);
+	write_64bit_cp0_eirr(1ULL << irq);	/*ack eirr*/
 
-	do_phnx_IRQ(i);
-	return;
+#ifdef CONFIG_SMP
+
+#ifdef CONFIG_PHOENIX_IP_FLOW_AFFINITY
+	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE || irq == IRQ_IPI_NETRX)
+#else
+	if (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE)
+#endif /* CONFIG_PHOENIX_IP_FLOW_AFFINITY */
+	{
+		phoenix_ipi_handler(irq);
+		return;
+	}
+#endif
+	if (irq == IRQ_MSGRING || irq == PIC_TIMER_0_IRQ)
+		phnx_msgring_int_handler(irq);
+	else
+		do_IRQ(irq);
 }
-- 
1.6.3.2

