From eb767ff78244a7bce8dfb4946adb1fc6a4386077 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 19 Dec 2008 17:19:05 +0800
Subject: [PATCH] rmi xlr clock api support

Support Wind River generic hardware timer API.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Steve Yang <steve.yang@windriver.com>
---
 arch/mips/kernel/cevt-phoenix.c |   51 +++++++++++++++++++++++++++++++++++++++
 arch/mips/kernel/cevt-r4k.c     |   18 +++++++++++++
 2 files changed, 69 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/cevt-phoenix.c b/arch/mips/kernel/cevt-phoenix.c
index 3b8651f..56a2a58 100644
--- a/arch/mips/kernel/cevt-phoenix.c
+++ b/arch/mips/kernel/cevt-phoenix.c
@@ -32,6 +32,38 @@
 
 #define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
 
+#ifdef CONFIG_HWTIMER_HOOKS 
+#include <linux/hwtimer.h>
+
+int phoenix_timer_get_freq(void)
+{
+	return HZ;
+}
+
+static struct hwtimer_data phoenix_timer_data = {
+	.name = "Phoenix timer",
+	.desc = "Phoenix HW timer",
+	.def_freq = HZ,
+	.min_freq = HZ,
+	.max_freq = HZ
+};
+
+static spinlock_t phoenix_timer_lock = SPIN_LOCK_UNLOCKED;
+
+struct hwtimer phoenix_timer = {
+	.data = &phoenix_timer_data,
+	.set_freq = NULL,
+	.get_freq = phoenix_timer_get_freq,
+	.start = NULL,
+	.stop = NULL,
+	.lock = &phoenix_timer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+
+atomic_t hwtimer_cpu_trigger[NR_CPUS];
+#endif  /* CONFIG_HWTIMER_HOOKS */
+
 static void phoenix_set_mode(enum clock_event_mode mode,
                            struct clock_event_device *evt)
 {
@@ -105,6 +137,13 @@ static irqreturn_t phoenix_timer7_interrupt(int irq, void *dev_id)
 					  (1 << (PIC_TIMER_7_IRQ - PIC_IRQ_BASE)));
 	cd->event_handler(cd);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	spin_lock(phoenix_timer.lock);
+	if (phoenix_timer.hook != NULL)
+	   (phoenix_timer.hook)(phoenix_timer.hook_data);
+	spin_unlock(phoenix_timer.lock);
+#endif /* CONFIG_HWTIMER_HOOKS */
+
 	return IRQ_HANDLED;
 }
 
@@ -151,3 +190,15 @@ void __cpuinit phoenix_clockevent_init(void)
 
 	setup_irq(PIC_TIMER_7_IRQ, action);
 }
+
+#ifdef CONFIG_HWTIMER_HOOKS
+void __init phoenix_hwtimer_init()
+{
+	unsigned int i;
+	for_each_possible_cpu(i)
+		atomic_set(&hwtimer_cpu_trigger[i], i + 1);
+
+	register_hwtimer(&phoenix_timer);
+}
+arch_initcall(phoenix_hwtimer_init);
+#endif /* CONFIG_HWTIMER_HOOKS */
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index afe06db..e87cdac 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -48,6 +48,13 @@ static struct hwtimer mips_hwtimer = {
 	.hook = NULL,
 	.hook_data = NULL
 };
+
+#endif
+
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_HWTIMER_HOOKS)
+#include <linux/hwtimer.h>
+extern atomic_t hwtimer_cpu_trigger[NR_CPUS];
+extern struct hwtimer phoenix_timer;
 #endif
 
 static int mips_next_event(unsigned long delta,
@@ -109,6 +116,17 @@ irqreturn_t c0_compare_interrupt(int irq, void *dev_id)
 		(mips_hwtimer.hook)(mips_hwtimer.hook_data);
 	spin_unlock(mips_hwtimer.lock);
 #endif
+#if defined (CONFIG_RMI_PHOENIX) && defined (CONFIG_HWTIMER_HOOKS)
+	if (atomic_dec_and_test(&hwtimer_cpu_trigger[smp_processor_id()])) {
+		atomic_set(&hwtimer_cpu_trigger[smp_processor_id()],
+			num_online_cpus());
+
+		spin_lock(phoenix_timer.lock);
+		if (phoenix_timer.hook != NULL)
+		   (phoenix_timer.hook)(phoenix_timer.hook_data);
+		spin_unlock(phoenix_timer.lock);
+	}
+#endif
 out:
 	return IRQ_HANDLED;
 }
-- 
1.6.0.3

