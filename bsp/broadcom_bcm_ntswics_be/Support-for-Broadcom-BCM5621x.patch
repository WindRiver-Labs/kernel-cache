From 0e324b558c28d5593fe4cfbe75334bb10a0dc398 Mon Sep 17 00:00:00 2001
From: Shuo Liu <shuo.liu@windriver.com>
Date: Tue, 13 Oct 2009 13:03:17 +0800
Subject: [PATCH 1/4] Support for Broadcom BCM5621x

The patch is the core platform support for Broadcom BCM5621x. They has been provide
by Broadcom and they have been distributed as part of Broadcom's SDK.
Currently, it supports the following device:
 * Dual 16550 compatible UART
 * Common gpio
 * Timer
 * Some other misc functionality related to processor.
Now two serial ports on the board are supported by the patch.And the first serial port only
works under poll mode. Its interrupt mode have some bugs and due to the hardware issue.

Signed-off-by: Shuo Liu <shuo.liu@windriver.com>
---
 arch/mips/Kconfig                          |   23 +
 arch/mips/Makefile                         |    6 +
 arch/mips/bcm5621x/Makefile                |   22 +
 arch/mips/bcm5621x/gpio.c                  |  134 +++++
 arch/mips/bcm5621x/irq.c                   |   55 ++
 arch/mips/bcm5621x/prom.c                  |  353 +++++++++++++
 arch/mips/bcm5621x/sb56218mips.c           |  359 +++++++++++++
 arch/mips/bcm5621x/sb56218utils.c          |  786 ++++++++++++++++++++++++++++
 arch/mips/bcm5621x/serial.c                |   51 ++
 arch/mips/bcm5621x/setup.c                 |   91 ++++
 arch/mips/bcm5621x/time.c                  |   69 +++
 include/asm-mips/mach-bcm5621x/bcmdevs.h   |  245 +++++++++
 include/asm-mips/mach-bcm5621x/bcmutils.h  |  144 +++++
 include/asm-mips/mach-bcm5621x/linux_osl.h |  340 ++++++++++++
 include/asm-mips/mach-bcm5621x/linuxver.h  |  335 ++++++++++++
 include/asm-mips/mach-bcm5621x/osl.h       |   29 +
 include/asm-mips/mach-bcm5621x/sbchipc.h   |  360 +++++++++++++
 include/asm-mips/mach-bcm5621x/sbconfig.h  |  342 ++++++++++++
 include/asm-mips/mach-bcm5621x/sbmemc.h    |  152 ++++++
 include/asm-mips/mach-bcm5621x/sbmips.h    |   68 +++
 include/asm-mips/mach-bcm5621x/sbutils.h   |   97 ++++
 include/asm-mips/mach-bcm5621x/typedefs.h  |  170 ++++++
 include/asm-mips/mach-bcm5621x/war.h       |   25 +
 23 files changed, 4256 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/bcm5621x/Makefile
 create mode 100644 arch/mips/bcm5621x/gpio.c
 create mode 100644 arch/mips/bcm5621x/irq.c
 create mode 100644 arch/mips/bcm5621x/prom.c
 create mode 100644 arch/mips/bcm5621x/sb56218mips.c
 create mode 100644 arch/mips/bcm5621x/sb56218utils.c
 create mode 100644 arch/mips/bcm5621x/serial.c
 create mode 100644 arch/mips/bcm5621x/setup.c
 create mode 100644 arch/mips/bcm5621x/time.c
 create mode 100644 include/asm-mips/mach-bcm5621x/bcmdevs.h
 create mode 100644 include/asm-mips/mach-bcm5621x/bcmutils.h
 create mode 100644 include/asm-mips/mach-bcm5621x/linux_osl.h
 create mode 100644 include/asm-mips/mach-bcm5621x/linuxver.h
 create mode 100644 include/asm-mips/mach-bcm5621x/osl.h
 create mode 100644 include/asm-mips/mach-bcm5621x/sbchipc.h
 create mode 100644 include/asm-mips/mach-bcm5621x/sbconfig.h
 create mode 100644 include/asm-mips/mach-bcm5621x/sbmemc.h
 create mode 100644 include/asm-mips/mach-bcm5621x/sbmips.h
 create mode 100644 include/asm-mips/mach-bcm5621x/sbutils.h
 create mode 100644 include/asm-mips/mach-bcm5621x/typedefs.h
 create mode 100644 include/asm-mips/mach-bcm5621x/war.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 37ef41e..07407d3 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -61,6 +61,29 @@ config BCM47XX
 	help
 	 Support for BCM47XX based boards
 
+config BCM5621X
+	bool "Support for Broadcom BCM5621x"
+	select CEVT_R4K
+	select CSRC_R4K
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_R4K_CVET_HWTIMER
+	select SYS_HAS_EARLY_PRINTK
+	select CFE
+	help
+	  Support Broadcom BCM5621x board
+
+config BCM5621X_NVRAM_BASE
+	hex "Base physical address for windowed flash NVRAM access"
+	default "0x1dc88000"
+	depends on BCM5621X
+	help
+	  Base physical address for windowed flash NVRAM access
+
 config MIPS_COBALT
 	bool "Cobalt Server"
 	select CEVT_R4K
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 84b5241..08cbafa 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -534,6 +534,12 @@ core-$(CONFIG_BCM47XX)		+= arch/mips/bcm47xx/
 cflags-$(CONFIG_BCM47XX)	+= -Iinclude/asm-mips/mach-bcm47xx
 load-$(CONFIG_BCM47XX)		:= 0xffffffff80001000
 
+# Broadcom BCM5621x board
+#
+core-$(CONFIG_BCM5621X) 	+= arch/mips/bcm5621x/
+cflags-$(CONFIG_BCM5621X)	+= -Iinclude/asm-mips/mach-bcm5621x
+load-$(CONFIG_BCM5621X)		+= 0xffffffff80001000
+
 #
 # SNI RM
 #
diff --git a/arch/mips/bcm5621x/Makefile b/arch/mips/bcm5621x/Makefile
new file mode 100644
index 0000000..b6a0948
--- /dev/null
+++ b/arch/mips/bcm5621x/Makefile
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2004 Broadcom Corporation
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+
+
+obj-y	:= prom.o setup.o time.o gpio.o irq.o serial.o
+obj-y	+= sb56218mips.o sb56218utils.o
+EXTRA_CFLAGS += -DCONFIG_BCM5621X
diff --git a/arch/mips/bcm5621x/gpio.c b/arch/mips/bcm5621x/gpio.c
new file mode 100644
index 0000000..cdfb341
--- /dev/null
+++ b/arch/mips/bcm5621x/gpio.c
@@ -0,0 +1,134 @@
+/*
+ * GPIO char driver
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ * Copyright (C) 2005 MontaVista Inc. ( 2.6 kernel modifications )
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/major.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+
+#include <asm/mach-bcm5621x/typedefs.h>
+#include <asm/mach-bcm5621x/bcmutils.h>
+#include <asm/mach-bcm5621x/sbutils.h>
+#include <asm/mach-bcm5621x/bcmdevs.h>
+
+static void *gpio_sbh;
+static int gpio_major;
+static int gpio_open(struct inode *inode, struct file *file)
+{
+	if (MINOR(inode->i_rdev) > 3)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int gpio_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t
+gpio_read(struct file *file, char *buf, size_t count, loff_t * ppos)
+{
+	u32 val;
+
+	switch (MINOR(file->f_dentry->d_inode->i_rdev)) {
+	case 0:
+		val = sb_gpioin(gpio_sbh);
+		break;
+	case 1:
+		val = sb_gpioout(gpio_sbh, 0, 0);
+		break;
+	case 2:
+		val = sb_gpioouten(gpio_sbh, 0, 0);
+		break;
+	case 3:
+		val = sb_gpiocontrol(gpio_sbh, 0, 0);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	if (put_user(val, (u32 *) buf))
+		return -EFAULT;
+
+	return sizeof(val);
+}
+
+static ssize_t
+gpio_write(struct file *file, const char *buf, size_t count, loff_t * ppos)
+{
+	u32 val;
+
+	if (get_user(val, (u32 *) buf))
+		return -EFAULT;
+
+	switch (MINOR(file->f_dentry->d_inode->i_rdev)) {
+	case 0:
+		return -EACCES;
+	case 1:
+		sb_gpioout(gpio_sbh, ~0, val);
+		break;
+	case 2:
+		sb_gpioouten(gpio_sbh, ~0, val);
+		break;
+	case 3:
+		sb_gpiocontrol(gpio_sbh, ~0, val);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	return sizeof(val);
+}
+
+static struct file_operations gpio_fops = {
+	owner:THIS_MODULE,
+	open:gpio_open,
+	release:gpio_release,
+	read:gpio_read,
+	write:gpio_write,
+};
+
+static int __init gpio_init(void)
+{
+	if (!(gpio_sbh = sb_kattach()))
+		return -ENODEV;
+
+	sb_gpiosetcore(gpio_sbh);
+
+	if ((gpio_major = register_chrdev(0, "gpio", &gpio_fops)) < 0)
+		return gpio_major;
+
+	return 0;
+}
+
+static void __exit gpio_exit(void)
+{
+	unregister_chrdev(gpio_major, "gpio");
+	sb_detach(gpio_sbh);
+}
+
+module_init(gpio_init);
+module_exit(gpio_exit);
diff --git a/arch/mips/bcm5621x/irq.c b/arch/mips/bcm5621x/irq.c
new file mode 100644
index 0000000..325757a
--- /dev/null
+++ b/arch/mips/bcm5621x/irq.c
@@ -0,0 +1,55 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer <jolt@tuxbox.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/irq_cpu.h>
+
+void plat_irq_dispatch(void)
+{
+	u32 cause;
+
+	cause = read_c0_cause() & read_c0_status() & CAUSEF_IP;
+
+	clear_c0_status(cause);
+
+	if (cause & CAUSEF_IP7)
+		do_IRQ(7);
+	if (cause & CAUSEF_IP2)
+		do_IRQ(2);
+	if (cause & CAUSEF_IP3)
+		do_IRQ(3);
+	if (cause & CAUSEF_IP4)
+		do_IRQ(4);
+	if (cause & CAUSEF_IP5)
+		do_IRQ(5);
+	if (cause & CAUSEF_IP6)
+		do_IRQ(6);
+}
+
+void __init arch_init_irq(void)
+{
+	mips_cpu_irq_init();
+}
diff --git a/arch/mips/bcm5621x/prom.c b/arch/mips/bcm5621x/prom.c
new file mode 100644
index 0000000..6a716ff
--- /dev/null
+++ b/arch/mips/bcm5621x/prom.c
@@ -0,0 +1,353 @@
+/*
+ * Early initialization code for BCM94710 boards
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ * Copyright (C) 2005 MontaVista Inc. ( 2.6 kernel modifications )
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <linux/smp.h>
+#include <linux/serial_reg.h>
+#include <asm/reboot.h>
+#include <asm/fw/cfe/cfe_api.h>
+#include <asm/fw/cfe/cfe_error.h>
+
+
+#ifdef CONFIG_HIGHMEM
+#define MAX_RAM_SIZE (0xffffffffULL)
+#else
+#define MAX_RAM_SIZE (0x1fffffffULL)
+#endif
+
+#define BCM56218_MAX_MEM_REGIONS 8
+phys_t board_mem_region_addrs[BCM56218_MAX_MEM_REGIONS];
+phys_t board_mem_region_sizes[BCM56218_MAX_MEM_REGIONS];
+unsigned int board_mem_region_count;
+
+int cfe_cons_handle;
+
+#ifdef CONFIG_BLK_DEV_INITRD
+extern unsigned long initrd_start, initrd_end;
+#endif
+extern void bcm956218_machine_restart(char *command);
+
+const char *get_system_type(void)
+{
+	return "Broadcom BCM95621x";
+}
+
+static void ATTRIB_NORET cfe_linux_exit(void *arg)
+{
+	int warm = *(int *)arg;
+
+	if ((*((volatile unsigned int*)0xb8000000) & 0x00f0) != 0x10) {
+		if (!warm)
+			bcm956218_machine_restart(NULL);
+	}
+
+	if (smp_processor_id()) {
+		static int reboot_smp;
+
+		/* Don't repeat the process from another CPU */
+		if (!reboot_smp) {
+			/* Get CPU 0 to do the cfe_exit */
+			reboot_smp = 1;
+			smp_call_function(cfe_linux_exit, arg, 0);
+		}
+	} else {
+		printk("Passing control back to CFE...\n");
+		cfe_exit(warm, 0);
+		printk("cfe_exit returned??\n");
+	}
+	while (1);
+}
+
+static void ATTRIB_NORET cfe_linux_restart(char *command)
+{
+	static const int zero;
+
+	cfe_linux_exit((void *)&zero);
+}
+
+static void ATTRIB_NORET cfe_linux_halt(void)
+{
+	static const int one = 1;
+
+	cfe_linux_exit((void *)&one);
+}
+
+static __init void prom_meminit(void)
+{
+	u64 addr, size, type; /* regardless of 64BIT_PHYS_ADDR */
+	int mem_flags = 0;
+	unsigned int idx;
+	int rd_flag;
+#ifdef CONFIG_BLK_DEV_INITRD
+	unsigned long initrd_pstart;
+	unsigned long initrd_pend;
+
+	initrd_pstart = CPHYSADDR(initrd_start);
+	initrd_pend = CPHYSADDR(initrd_end);
+	if (initrd_start &&
+	    ((initrd_pstart > MAX_RAM_SIZE)
+	     || (initrd_pend > MAX_RAM_SIZE))) {
+		panic("initrd out of addressable memory");
+	}
+
+#endif /* INITRD */
+
+	for (idx = 0; cfe_enummem(idx, mem_flags, &addr, &size, &type) != CFE_ERR_NOMORE;
+	     idx++) {
+		rd_flag = 0;
+		if (type == CFE_MI_AVAILABLE) {
+			/*
+			 * See if this block contains (any portion of) the
+			 * ramdisk
+			 */
+#ifdef CONFIG_BLK_DEV_INITRD
+			if (initrd_start) {
+				if ((initrd_pstart > addr) &&
+				    (initrd_pstart < (addr + size))) {
+					add_memory_region(addr,
+							   initrd_pstart - addr,
+							   BOOT_MEM_RAM);
+					rd_flag = 1;
+				}
+				if ((initrd_pend > addr) &&
+				    (initrd_pend < (addr + size))) {
+					add_memory_region(initrd_pend,
+						(addr + size) - initrd_pend,
+						 BOOT_MEM_RAM);
+					rd_flag = 1;
+				}
+			}
+#endif
+			if (!rd_flag) {
+				if (addr > MAX_RAM_SIZE)
+					continue;
+				if (addr+size > MAX_RAM_SIZE)
+					size = MAX_RAM_SIZE - (addr+size) + 1;
+				/*
+				 * memcpy/__copy_user prefetch, which
+				 * will cause a bus error for
+				 * KSEG/KUSEG addrs not backed by RAM.
+				 * Hence, reserve some padding for the
+				 * prefetch distance.
+				 */
+				if (size > 512)
+					size -= 512;
+				add_memory_region(addr, size, BOOT_MEM_RAM);
+			}
+			board_mem_region_addrs[board_mem_region_count] = addr;
+			board_mem_region_sizes[board_mem_region_count] = size;
+			board_mem_region_count++;
+			if (board_mem_region_count ==
+			    BCM56218_MAX_MEM_REGIONS) {
+				/*
+				 * Too many regions.  Need to configure more
+				 */
+				while(1);
+			}
+		}
+	}
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start) {
+		add_memory_region(initrd_pstart, initrd_pend - initrd_pstart,
+				  BOOT_MEM_RESERVED);
+	}
+#endif
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+static int __init initrd_setup(char *str)
+{
+	char rdarg[64];
+	int idx;
+	char *tmp, *endptr;
+	unsigned long initrd_size;
+
+	/* Make a copy of the initrd argument so we can smash it up here */
+	for (idx = 0; idx < sizeof(rdarg)-1; idx++) {
+		if (!str[idx] || (str[idx] == ' ')) break;
+		rdarg[idx] = str[idx];
+	}
+
+	rdarg[idx] = 0;
+	str = rdarg;
+
+	/*
+	 *Initrd location comes in the form "<hex size of ramdisk in bytes>@<location in memory>"
+	 *  e.g. initrd=3abfd@80010000.  This is set up by the loader.
+	 */
+	for (tmp = str; *tmp != '@'; tmp++) {
+		if (!*tmp) {
+			goto fail;
+		}
+	}
+	*tmp = 0;
+	tmp++;
+	if (!*tmp) {
+		goto fail;
+	}
+	initrd_size = simple_strtoul(str, &endptr, 16);
+	if (*endptr) {
+		*(tmp-1) = '@';
+		goto fail;
+	}
+	*(tmp-1) = '@';
+	initrd_start = simple_strtoul(tmp, &endptr, 16);
+	if (*endptr) {
+		goto fail;
+	}
+	initrd_end = initrd_start + initrd_size;
+	printk("Found initrd of %lx@%lx\n", initrd_size, initrd_start);
+	return 1;
+ fail:
+	printk("Bad initrd argument.  Disabling initrd\n");
+	initrd_start = 0;
+	initrd_end = 0;
+	return 1;
+}
+
+#endif
+
+void __init prom_init_cfe(void)
+{
+	uint32_t cfe_ept, cfe_handle;
+	unsigned int cfe_eptseal;
+	int argc = fw_arg0;
+	char **envp = (char **) fw_arg2;
+	int *prom_vec = (int *) fw_arg3;
+
+	_machine_restart = cfe_linux_restart;
+	_machine_halt = cfe_linux_halt;
+
+	/*
+	 * Check if a loader was used; if NOT, the 4 arguments are
+	 * what CFE gives us (handle, 0, EPT and EPTSEAL)
+	 */
+	if (argc < 0) {
+		cfe_handle = (uint32_t)(long)argc;
+		cfe_ept = (long)envp;
+		cfe_eptseal = (uint32_t)(unsigned long)prom_vec;
+	} else {
+		if ((int32_t)(long)prom_vec < 0) {
+			/*
+			 * Old loader; all it gives us is the handle,
+			 * so use the "known" entrypoint and assume
+			 * the seal.
+			 */
+			cfe_handle = (uint32_t)(long)prom_vec;
+			cfe_ept = (uint32_t)((int32_t)0x9fc00500);
+			cfe_eptseal = CFE_EPTSEAL;
+		} else {
+			/*
+			 * Newer loaders bundle the handle/ept/eptseal
+			 * Note: prom_vec is in the loader's useg
+			 * which is still alive in the TLB.
+			 */
+			cfe_handle = (uint32_t)((int32_t *)prom_vec)[0];
+			cfe_ept = (uint32_t)((int32_t *)prom_vec)[2];
+			cfe_eptseal = (unsigned int)((uint32_t *)prom_vec)[3];
+		}
+	}
+	if (cfe_eptseal != CFE_EPTSEAL) {
+		/* too early for panic to do any good */
+		printk("CFE's entrypoint seal doesn't match. Spinning.");
+		while (1) ;
+	}
+	cfe_init(cfe_handle, cfe_ept);
+}
+
+static __init void prom_init_console(void)
+{
+
+	/* Initialize CFE console */
+	cfe_cons_handle = cfe_getstdhandle(CFE_STDHANDLE_CONSOLE);
+}
+
+static __init void prom_init_cmdline(void)
+{
+	int argc = fw_arg0;
+
+	if (cfe_getenv("LINUX_CMDLINE", arcs_cmdline, CL_SIZE) < 0) {
+		if (argc < 0) {
+			/*
+			 * It's OK for direct boot to not provide a
+			 *  command line*/
+			strcpy(arcs_cmdline, "root=/dev/ram0 ");
+			strcat(arcs_cmdline, "console=ttyS0,9600 ");
+		} else {
+			/* The loader should have set the command line */
+			/* too early for panic to do any good */
+			printk("LINUX_CMDLINE not defined in cfe.");
+			while (1) ;
+		}
+	}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	{
+		char *ptr;
+		/* Need to find out early whether we've got an initrd.
+		 * So scan the list looking now */
+		for (ptr = arcs_cmdline; *ptr; ptr++) {
+			while (*ptr == ' ') {
+				ptr++;
+			}
+			if (!strncmp(ptr, "initrd=", 7)) {
+				initrd_setup(ptr+7);
+				break;
+			} else {
+				while (*ptr && (*ptr != ' ')) {
+					ptr++;
+				}
+			}
+		}
+	}
+#endif /* CONFIG_BLK_DEV_INITRD */
+
+	/* Not sure this is needed, but it's the safe way. */
+	arcs_cmdline[CL_SIZE-1] = 0;
+
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+
+	prom_init_cfe();
+	prom_init_console();
+	prom_init_cmdline();
+	prom_meminit();
+}
+
+/* simple debug assistance*/
+#define CCORE_BASE 0xb8000300
+void prom_putchar(char c)
+{
+	while (!(readb((void *) (CCORE_BASE + UART_LSR)) & UART_LSR_THRE));
+	writeb(c, (void *) (CCORE_BASE + UART_TX));
+}
+
diff --git a/arch/mips/bcm5621x/sb56218mips.c b/arch/mips/bcm5621x/sb56218mips.c
new file mode 100644
index 0000000..f30a43a
--- /dev/null
+++ b/arch/mips/bcm5621x/sb56218mips.c
@@ -0,0 +1,359 @@
+/*
+ * BCM47XX Sonics SiliconBackplane MIPS core routines
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <asm/mach-bcm5621x/typedefs.h>
+#include <asm//mach-bcm5621x/osl.h>
+#include <asm/mach-bcm5621x/sbutils.h>
+#include <asm/mach-bcm5621x/bcmdevs.h>
+#include <asm/mach-bcm5621x/bcmutils.h>
+#include <asm/mach-bcm5621x/sbconfig.h>
+#include <asm/mach-bcm5621x/sbchipc.h>
+#include <asm/mach-bcm5621x/sbmemc.h>
+
+/* flash_waitcount */
+#define	FW_W0_MASK	0x1f			/* waitcount0 */
+#define	FW_W1_MASK	0x1f00			/* waitcount1 */
+#define	FW_W1_SHIFT	8
+#define	FW_W2_MASK	0x1f0000		/* waitcount2 */
+#define	FW_W2_SHIFT	16
+#define	FW_W3_MASK	0x1f000000		/* waitcount3 */
+#define	FW_W3_SHIFT	24
+
+#define INTERNAL_UART0_ONLY 0
+
+/**********************************************************************
+ * CP0 Registers
+***********************************************************************/
+
+#define C0_INX		0	/* CP0: TLB Index */
+#define C0_RAND		1	/* CP0: TLB Random */
+#define C0_TLBLO0	2	/* CP0: TLB EntryLo0 */
+#define C0_TLBLO	C0_TLBLO0	/* CP0: TLB EntryLo0 */
+#define C0_TLBLO1	3	/* CP0: TLB EntryLo1 */
+#define C0_CTEXT	4	/* CP0: Context */
+#define C0_PGMASK	5	/* CP0: TLB PageMask */
+#define C0_WIRED	6	/* CP0: TLB Wired */
+#define C0_BADVADDR	8	/* CP0: Bad Virtual Address */
+#define C0_COUNT 	9	/* CP0: Count */
+#define C0_TLBHI	10	/* CP0: TLB EntryHi */
+#define C0_COMPARE	11	/* CP0: Compare */
+#define C0_SR		12	/* CP0: Processor Status */
+#define C0_STATUS	C0_SR	/* CP0: Processor Status */
+#define C0_CAUSE	13	/* CP0: Exception Cause */
+#define C0_EPC		14	/* CP0: Exception PC */
+#define C0_PRID		15	/* CP0: Processor Revision Indentifier */
+#define C0_CONFIG	16	/* CP0: Config */
+#define C0_LLADDR	17	/* CP0: LLAddr */
+#define C0_WATCHLO	18	/* CP0: WatchpointLo */
+#define C0_WATCHHI	19	/* CP0: WatchpointHi */
+#define C0_XCTEXT	20	/* CP0: XContext */
+#define C0_DIAGNOSTIC	22	/* CP0: Diagnostic */
+#define C0_BROADCOM	C0_DIAGNOSTIC	/* CP0: Broadcom Register */
+#define C0_ECC		26	/* CP0: ECC */
+#define C0_CACHEERR	27	/* CP0: CacheErr */
+#define C0_TAGLO	28	/* CP0: TagLo */
+#define C0_TAGHI	29	/* CP0: TagHi */
+#define C0_ERREPC	30	/* CP0: ErrorEPC */
+
+/*
+ * Macros to access the system control coprocessor
+ */
+
+#define MFC0(source, sel)					\
+({								\
+	int __res;						\
+	__asm__ __volatile__(					\
+	".set\tnoreorder\n\t"					\
+	".set\tnoat\n\t"					\
+	".word\t"STR(0x40010000 | ((source)<<11) | (sel))"\n\t"	\
+	"move\t%0,$1\n\t"					\
+	".set\tat\n\t"						\
+	".set\treorder"						\
+	:"=r" (__res)						\
+	:							\
+	:"$1");							\
+	__res;							\
+})
+
+#define MTC0(source, sel, value)				\
+do {								\
+	__asm__ __volatile__(					\
+	".set\tnoreorder\n\t"					\
+	".set\tnoat\n\t"					\
+	"move\t$1,%z0\n\t"					\
+	".word\t"STR(0x40810000 | ((source)<<11) | (sel))"\n\t"	\
+	".set\tat\n\t"						\
+	".set\treorder"						\
+	:							\
+	:"Jr" (value)						\
+	:"$1");							\
+} while (0)
+
+
+/*
+ * Cache Operations
+ */
+
+#ifndef Fill_I
+#define Fill_I			0x14
+#endif
+
+#define cache_unroll(base,op)			\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, (%0);			\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+
+static const uint32 sbips_bcm56218_irq_id[] = {
+	SBIPS_INT_UART0,
+	SBIPS_INT_UART1,
+	SBIPS_INT_CMIC,
+	SBIPS_INT_GPIO,
+};
+
+uint sb_irq(void *sbh, uint irq_src_id);
+
+static const uint32 sbips_int_mask[] = {
+	0,
+	SBIPS_INT1_MASK,
+	SBIPS_INT2_MASK,
+	SBIPS_INT3_MASK,
+	SBIPS_INT4_MASK
+};
+
+static const uint32 sbips_int_shift[] = {
+	0,
+	0,
+	SBIPS_INT2_SHIFT,
+	SBIPS_INT3_SHIFT,
+	SBIPS_INT4_SHIFT
+};
+
+/*
+ * Returns the MIPS IRQ assignment of the current core. If unassigned,
+ * 0 is returned.
+ */
+uint
+sb_irq(void *sbh, uint irq_src_id)
+{
+	uint idx;
+	uint32 flag, sbipsflag = 0;
+	uint irq = 0;
+	chipcregs_t *cc;
+
+	idx = sb_coreidx(sbh);
+
+	flag = irq_src_id;
+	if ((cc = sb_setcore(sbh, SB_CC, 0))) {
+		sbipsflag = R_REG(&cc->sbipsflag);
+	}
+
+	for (irq = 1; irq <= 4; irq++) {
+		if (((sbipsflag & sbips_int_mask[irq]) >> sbips_int_shift[irq])
+			== flag)
+			break;
+	}
+	/* No match, return Zer. */
+	if (irq == 5)
+		irq = 0;
+
+	sb_setcoreidx(sbh, idx);
+
+	return irq;
+}
+
+/* Clears the specified MIPS IRQ. */
+static void
+sb_clearirq(void *sbh, uint irq)
+{
+	chipcregs_t *cc;
+	uint idx;
+
+	idx = sb_coreidx(sbh);
+	if ((cc = sb_setcore(sbh, SB_CC, 0))) {
+		if (irq == 0)
+			W_REG(&cc->sbintvec, 0);
+		else
+			OR_REG(&cc->sbipsflag, sbips_int_mask[irq]);
+	}
+	sb_setcoreidx(sbh, idx);
+}
+
+/*
+ * Assigns the specified MIPS IRQ to the specified core. Shared MIPS
+ * IRQ 0 may be assigned more than once.
+ */
+static void
+sb_setirq(void *sbh, uint irq, uint sb_irq_id)
+{
+	chipcregs_t *cc;
+	uint32 flag, idx;
+
+	flag = sb_irq_id;
+
+	idx = sb_coreidx(sbh);
+	if ((cc = sb_setcore(sbh, SB_CC, 0))) {
+		if (irq == 0)
+			OR_REG(&cc->sbintvec, 1 << flag);
+		else {
+			flag <<= sbips_int_shift[irq];
+			ASSERT(!(flag & ~sbips_int_mask[irq]));
+			flag |= R_REG(&cc->sbipsflag) & ~sbips_int_mask[irq];
+			W_REG(&cc->sbipsflag, flag);
+
+			/* Setup GPIO interrupts */
+			if (sb_irq_id == SBIPS_INT_GPIO) {
+				W_REG(&cc->gpiocontrol, 0xffffffff);
+				W_REG(&cc->gpiointmask, 3);
+				W_REG(&cc->gpiointpolarity, 3);
+				W_REG(&cc->gpioouten, 3);
+			}
+		}
+	}
+	sb_setcoreidx(sbh, idx);
+}
+
+/*
+ * Initializes clocks and interrupts. SB and NVRAM access must be
+ * initialized prior to calling.
+ */
+void
+sb_mips_init(void *sbh)
+{
+	uint irq, idx;
+	chipcregs_t *cc;
+
+	/* Chip specific initialization */
+	switch (sb_chip(sbh)) {
+	case BCM56218_DEVICE_ID:
+		/* reset uart */
+		idx = sb_coreidx(sbh);
+		if ((cc = sb_setcore(sbh, SB_CC, 0))) {
+		//	W_REG(&cc->peripheralreset, 1);
+		//	W_REG(&cc->peripheralreset, 3);
+		}
+
+		/* Clear interrupt map */
+		for (irq = 0; irq <= 4; irq++)
+			sb_clearirq(sbh, irq);
+
+		sb_setirq(sbh, 1, SBIPS_INT_UART0);
+		sb_setirq(sbh, 2, SBIPS_INT_UART1);
+		sb_setirq(sbh, 3, SBIPS_INT_CMIC);
+		sb_setirq(sbh, 4, SBIPS_INT_GPIO);
+
+		sb_setcoreidx(sbh, idx);
+		break;
+	}
+}
+
+uint32
+sb_mips_clock(void *sbh)
+{
+	uint idx;
+	uint32 rate, ratio;
+	chipcregs_t *cc;
+
+	rate = 133000000;
+	idx = sb_coreidx(sbh);
+
+	if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
+		ratio = (R_REG(&cc->capabilities) >> 4) & 3;
+
+		switch (ratio) {
+		case 0:
+			rate = rate*2;
+			break;
+		case 1:
+			rate = (rate*9)/4;
+			break;
+		case 2:
+			if ((R_REG(&cc->chipid) & 0x00f0) == 0x10) {
+				rate = (rate*6)/4;
+			} else {
+				rate = (rate*10)/4;
+			}
+			break;
+		case 3:
+			break;
+		}
+	}
+
+	sb_setcoreidx(sbh, idx);
+
+	return rate;
+}
+
+bool
+sb_mips_setclock(void *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock)
+{
+	return FALSE;
+}
+
+
+/* returns the ncdl value to be programmed into sdram_ncdl for calibration */
+uint32
+sb_memc_get_ncdl(void *sbh)
+{
+	sbmemcregs_t *memc;
+	uint32 ret = 0;
+	uint32 config, rd, wr, misc, dqsg, cd, sm, sd;
+	uint idx;
+
+	idx = sb_coreidx(sbh);
+
+	memc = (sbmemcregs_t *)sb_setcore(sbh, SB_MEMC, 0);
+	if (memc == 0)
+		goto out;
+
+	config = R_REG(&memc->config);
+	wr = R_REG(&memc->wrncdlcor);
+	rd = R_REG(&memc->rdncdlcor);
+	misc = R_REG(&memc->miscdlyctl);
+	dqsg = R_REG(&memc->dqsgatencdl);
+
+	rd &= MEMC_RDNCDLCOR_RD_MASK;
+	wr &= MEMC_WRNCDLCOR_WR_MASK;
+	dqsg &= MEMC_DQSGATENCDL_G_MASK;
+
+	if (config & MEMC_CONFIG_DDR) {
+		ret = (wr << 16) | (rd << 8) | dqsg;
+	} else {
+		cd = (rd == MEMC_CD_THRESHOLD) ? rd : (wr + MEMC_CD_THRESHOLD);
+		sm = (misc & MEMC_MISC_SM_MASK) >> MEMC_MISC_SM_SHIFT;
+		sd = (misc & MEMC_MISC_SD_MASK) >> MEMC_MISC_SD_SHIFT;
+		ret = (sm << 16) | (sd << 8) | cd;
+	}
+
+out:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
+
diff --git a/arch/mips/bcm5621x/sb56218utils.c b/arch/mips/bcm5621x/sb56218utils.c
new file mode 100644
index 0000000..227b235
--- /dev/null
+++ b/arch/mips/bcm5621x/sb56218utils.c
@@ -0,0 +1,786 @@
+/*
+ * Misc utility routines for accessing chip-specific features
+ * of the SiliconBackplane-based Broadcom chips.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <asm/mach-bcm5621x/typedefs.h>
+#include <asm/mach-bcm5621x/osl.h>
+#include <asm/mach-bcm5621x/bcmutils.h>
+#include <asm/mach-bcm5621x/bcmdevs.h>
+#include <asm/mach-bcm5621x/sbconfig.h>
+#include <asm/mach-bcm5621x/sbchipc.h>
+#include <asm/mach-bcm5621x/sbutils.h>
+
+/* debug/trace */
+#define	SB_ERROR(args) printk args
+
+typedef uint32 (*sb_intrsoff_t)(void *intr_arg);
+typedef void (*sb_intrsrestore_t)(void *intr_arg, uint32 arg);
+
+/* misc sb info needed by some of the routines */
+typedef struct sb_info {
+	uint	chip;			/* chip number */
+	uint	chiprev;		/* chip revision */
+	uint	chippkg;		/* chip package option */
+	uint	boardtype;		/* board type */
+	uint	boardvendor;		/* board vendor id */
+	uint	bus;			/* what bus type we are going through */
+
+	void	*osh;			/* osl os handle */
+	void	*sdh;			/* bcmsdh handle */
+
+	void	*curmap;		/* current regs va */
+	void	*regs[SB_MAXCORES];	/* other regs va */
+
+	uint	curidx;			/* current core index */
+	uint	dev_coreid;		/* the core provides driver functions */
+
+	uint	ccrev;			/* chipc core rev */
+
+	uint	gpioidx;		/* gpio control core index */
+	uint	gpioid;			/* gpio control coretype */
+
+	uint	numcores;		/* # discovered cores */
+	uint	coreid[SB_MAXCORES];	/* id of each core */
+
+	void	*intr_arg;		/* interrupt callback function arg */
+	sb_intrsoff_t		intrsoff_fn;		/* function turns chip interrupts off */
+	sb_intrsrestore_t	intrsrestore_fn;	/* function restore chip interrupts */
+} sb_info_t;
+
+/* local prototypes */
+static void* sb_doattach(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
+static uint sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val);
+static uint _sb_coreidx(void *sbh);
+static uint sb_findcoreidx(void *sbh, uint coreid, uint coreunit);
+static uint sb_pcidev2chip(uint pcidev);
+static uint sb_chip2numcores(uint chip);
+static int sb_map_cores(sb_info_t *si);
+
+#define	SB_INFO(sbh)	(sb_info_t*)sbh
+#define	SET_SBREG(sbh, r, mask, val)	W_SBREG((sbh), (r), ((R_SBREG((sbh), (r)) & ~(mask)) | (val)))
+#define	GOODCOREADDR(x)	(((x) >= SB_ENUM_BASE) && ((x) <= SB_ENUM_LIM) \
+				&& ISALIGNED((x), SB_CORE_SIZE))
+#define	GOODREGS(regs)	(regs && ISALIGNED(regs, SB_CORE_SIZE))
+#define	GOODIDX(idx)	(((uint)idx) < SB_MAXCORES)
+#define	BADIDX		(SB_MAXCORES+1)
+
+/*
+ * Macros to disable/restore function core(D11, ENET, ILINE20, etc) interrupts before/
+ * after core switching to avoid invalid register accesss inside ISR.
+ */
+#define INTR_OFF(si, intr_val) \
+	if ((si)->intrsoff_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		intr_val = (*(si)->intrsoff_fn)((si)->intr_arg); }
+#define INTR_RESTORE(si, intr_val) \
+	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
+
+#define M_ASSERT(x)
+
+typedef struct sb_cores_map {
+	char	*core_name;
+	uint	core_base;
+	uint	core_id;
+} sb_cored_map_t;
+
+static sb_cored_map_t bcm56218_cores_map[] =	{
+	{ "Chipcommon", 0x18000000, SB_CC	},
+	{ "mips",	0x18005000, SB_MIPS	},
+	{ "memc",	0x18008000, SB_MEMC	},
+	{ NULL,		0,	0		},
+};
+
+void bcm_mdelay(uint ms)
+{
+	uint i;
+
+	for (i = 0; i < ms; i++) {
+		OSL_DELAY(1000);
+	}
+}
+
+/*
+ * Allocate a sb handle.
+ * devid - pci device id (used to determine chip#)
+ * osh - opaque OS handle
+ * regs - virtual address of initial core registers
+ * bustype - pci/pcmcia/sb/sdio/etc
+ * vars - pointer to a pointer area for "environment" variables
+ * varsz - pointer to int to return the size of the vars
+ */
+void*
+sb_attach(uint devid, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz)
+{
+	sb_info_t *si;
+
+	/* alloc sb_info_t */
+	if ((si = MALLOC(sizeof (sb_info_t))) == NULL) {
+		SB_ERROR(("sb_attach: malloc failed!\n"));
+		return (NULL);
+	}
+
+	return (sb_doattach(si, devid, osh, regs, bustype, sdh, vars, varsz));
+}
+
+/* global kernel resource */
+static sb_info_t ksi;
+
+/* generic kernel variant of sb_attach() */
+void*
+sb_kattach()
+{
+	uint32 *regs;
+	char *unused;
+	int varsz;
+
+	if (ksi.curmap == NULL) {
+		regs = (uint32 *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
+		sb_doattach(&ksi, BCM56218_DEVICE_ID, NULL, (void*)regs,
+			    SB_BUS, NULL, &unused, &varsz);
+	}
+	return &ksi;
+}
+
+static void*
+sb_doattach(sb_info_t *si, uint devid, void *osh, void *regs, uint bustype,
+	     void *sdh, char **vars, int *varsz)
+{
+	uint origidx;
+	chipcregs_t *cc;
+
+	ASSERT(GOODREGS(regs));
+
+	bzero((uchar*)si, sizeof (sb_info_t));
+
+	si->gpioidx = BADIDX;
+
+	si->osh = osh;
+	si->curmap = regs;
+	si->sdh = sdh;
+
+	si->bus = bustype;
+
+	/* initialize current core index value */
+	si->curidx = _sb_coreidx((void*)si);
+
+	/* keep and reuse the initial register mapping */
+	origidx = si->curidx;
+	if (si->bus == SB_BUS)
+		si->regs[origidx] = regs;
+
+	/* is core-0 a chipcommon core? */
+	si->numcores = 1;
+	cc = (chipcregs_t*) sb_setcoreidx((void*)si, 0);
+
+	si->chip = BCM56218_DEVICE_ID;
+	si->chiprev = (R_REG(&cc->chipid) & CID_REV_MASK) >> CID_REV_SHIFT;
+
+	si->numcores = sb_chip2numcores(si->chip);
+
+	/* return to original core */
+	sb_setcoreidx((void*)si, origidx);
+
+	/* sanity checks */
+	ASSERT(si->chip);
+
+	/*
+	 * Check if cores can be mapped statically. If not, do a scan.
+	 */
+	if (sb_map_cores(si)) {
+		SB_ERROR(("sb_attach: unable to map cores !!\n"));
+		goto bad;
+	}
+
+	/* gpio control core is required */
+	if (!GOODIDX(si->gpioidx)) {
+		SB_ERROR(("sb_attach: gpio control core not found\n"));
+		goto bad;
+	}
+
+	/* get boardtype and boardrev */
+	si->boardvendor = VENDOR_BROADCOM;
+	si->boardtype = 0;
+
+	return ((void*)si);
+
+bad:
+	MFREE(si, sizeof (sb_info_t));
+	return (NULL);
+}
+
+uint
+sb_coreidx(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->curidx);
+}
+
+/* return current index of core */
+static uint
+_sb_coreidx(void *sbh)
+{
+	sb_info_t *si;
+	int idx;
+
+	si = SB_INFO(sbh);
+	ASSERT(si);
+
+	for (idx = 0; idx < SB_MAXCORES; idx++)
+		if (si->regs[idx] == si->curmap)
+			return idx;
+
+	return 0;
+}
+
+/*
+ * Switch to 'coreidx', issue a single arbitrary 32bit register mask&set operation,
+ * switch back to the original core, and return the new value.
+ */
+static uint
+sb_corereg(void *sbh, uint coreidx, uint regoff, uint mask, uint val)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint32 *r;
+	uint w = 0;
+	uint intr_val = 0;
+
+	ASSERT(GOODIDX(coreidx));
+	ASSERT(regoff < SB_CORE_SIZE);
+	ASSERT((val & ~mask) == 0);
+
+	si = SB_INFO(sbh);
+
+	/* save current core index */
+	origidx = sb_coreidx(sbh);
+
+	/* switch core */
+	INTR_OFF(si, intr_val);
+	r = (uint32*) ((uint) sb_setcoreidx(sbh, coreidx) + regoff);
+
+	/* mask and set */
+	if (mask || val) {
+		w = (R_REG(r) & ~mask) | val;
+		W_REG(r, w);
+	}
+
+	/* restore core index */
+	if (origidx != coreidx)
+		sb_setcoreidx(sbh, origidx);
+
+	INTR_RESTORE(si, intr_val);
+	return (w);
+}
+
+static char hex(int n)
+{
+	n &= 0xf;
+	if (n < 10) return '0' + n;
+	return 'A' + (n-10);
+}
+
+static int hexbytes(int b)
+{
+	b &= 0xff;
+	return (hex(b >> 4) << 8) | hex(b);
+}
+
+void showme(char c, u32 v)
+{
+	volatile u_long *p = (volatile u_long *)0xba00c000;
+	u_long num;
+
+	*p = (c << 24) | (' ' << 16) | (' ' << 8) | ' ';
+	bcm_mdelay(1000);
+
+	num = (hexbytes(v >> 24) << 16) | hexbytes(v >> 16);
+	*p = num;
+	bcm_mdelay(1000);
+
+	num = (hexbytes(v >> 8) << 16) | hexbytes(v);
+	*p = num;
+	bcm_mdelay(1000);
+}
+
+static int
+sb_map_cores(sb_info_t *si)
+{
+	sb_cored_map_t	*core_map = NULL;
+	int		core_idx, origidx;
+	void		*sbh;
+
+	sbh = (void*) si;
+
+	/* save current core index */
+	origidx = sb_coreidx(sbh);
+
+	if (si->chip == BCM56218_DEVICE_ID)
+		core_map = bcm56218_cores_map;
+
+	if (core_map == NULL)
+		return -1;
+
+	/*
+	 * Map the cores.
+	 */
+	while (core_map->core_name) {
+		core_idx = (core_map->core_base - SB_ENUM_BASE)/ SB_CORE_SIZE;
+		sb_setcoreidx(sbh, core_idx);
+		si->coreid[core_idx] = core_map->core_id;
+		core_map++;
+	}
+
+	if (GOODIDX(sb_findcoreidx(sbh, SB_CC, 0))) {
+		si->gpioidx = sb_findcoreidx(sbh, SB_CC, 0);
+		si->gpioid = SB_CC;
+	}
+
+	/* return to original core index */
+	sb_setcoreidx(sbh, origidx);
+
+	return 0;
+}
+
+/* may be called with core in reset */
+void
+sb_detach(void *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL)
+		return;
+
+	if (si->bus == SB_BUS)
+		for (idx = 0; idx < SB_MAXCORES; idx++)
+			if (si->regs[idx]) {
+				REG_UNMAP(si->regs[idx]);
+				si->regs[idx] = NULL;
+			}
+
+	MFREE(si, sizeof (sb_info_t));
+}
+
+/* use pci dev id to determine chip id for chips not having a chipcommon core */
+static uint
+sb_pcidev2chip(uint devid)
+{
+	if (devid == BCM56218_DEVICE_ID)
+		return (BCM56218_DEVICE_ID);
+
+	return (0);
+}
+
+/* convert chip number to number of i/o cores */
+static uint
+sb_chip2numcores(uint chip)
+{
+	if (chip == BCM56218_DEVICE_ID)
+		return (9);
+
+	SB_ERROR(("sb_chip2numcores: unsupported chip 0x%x\n", chip));
+	ASSERT(0);
+	return (1);
+}
+
+/* return index of coreid or BADIDX if not found */
+static uint
+sb_findcoreidx(void *sbh, uint coreid, uint coreunit)
+{
+	sb_info_t *si;
+	uint found;
+	uint i;
+
+	si = SB_INFO(sbh);
+	found = 0;
+
+	for (i = 0; i < si->numcores; i++)
+		if (si->coreid[i] == coreid) {
+			if (found == coreunit)
+				return (i);
+			found++;
+		}
+
+	return (BADIDX);
+}
+
+/* change logical "focus" to the indiciated core */
+void*
+sb_setcoreidx(void *sbh, uint coreidx)
+{
+	sb_info_t *si;
+	uint32 sbaddr;
+
+	si = SB_INFO(sbh);
+
+	if (coreidx >= si->numcores)
+		return (NULL);
+
+	sbaddr = SB_ENUM_BASE + (coreidx * SB_CORE_SIZE);
+
+	/* map new one */
+	if (!si->regs[coreidx]) {
+		si->regs[coreidx] = (void*)REG_MAP(sbaddr, SB_CORE_SIZE);
+		ASSERT(GOODREGS(si->regs[coreidx]));
+	}
+	si->curmap = si->regs[coreidx];
+
+	si->curidx = coreidx;
+
+	return (si->curmap);
+}
+
+/* change logical "focus" to the indicated core */
+void*
+sb_setcore(void *sbh, uint coreid, uint coreunit)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	idx = sb_findcoreidx(sbh, coreid, coreunit);
+	if (!GOODIDX(idx))
+		return (NULL);
+
+	return (sb_setcoreidx(sbh, idx));
+}
+
+/* return chip number */
+uint
+sb_chip(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->chip);
+}
+
+/* return chip revision number */
+uint
+sb_chiprev(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->chiprev);
+}
+
+/* return chip package option */
+uint
+sb_chippkg(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->chippkg);
+}
+
+/* return board vendor id */
+uint
+sb_boardvendor(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->boardvendor);
+}
+
+/* return boardtype */
+uint
+sb_boardtype(void *sbh)
+{
+	return (0);
+}
+
+/* return board bus style */
+uint
+sb_boardstyle(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	if (si->bus == SB_BUS)
+		return (BOARDSTYLE_SOC);
+
+	return (BOARDSTYLE_SOC);
+}
+
+/* return boolean if sbh device is in pci hostmode or client mode */
+uint
+sb_bus(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->bus);
+}
+
+/* return list of found cores */
+uint
+sb_corelist(void *sbh, uint coreid[])
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof (uint)));
+	return (si->numcores);
+}
+
+/* return current register mapping */
+void *
+sb_coreregs(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	ASSERT(GOODREGS(si->curmap));
+
+	return (si->curmap);
+}
+
+
+/* reset and re-enable a core */
+void
+sb_core_reset(void *sbh, uint32 bits)
+{
+	/* FIXME : add code here */
+	return;
+}
+
+void
+sb_core_disable(void *sbh, uint32 bits)
+{
+	return;
+}
+
+void
+sb_watchdog(void *sbh, uint ticks)
+{
+	sb_info_t *si = SB_INFO(sbh);
+
+	switch (si->gpioid) {
+	case SB_CC:
+		sb_corereg(sbh, si->gpioidx, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
+		break;
+	deafult:
+		break;
+	}
+}
+
+/* return the core-type instantiation # of the current core */
+uint
+sb_coreunit(void *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+	uint coreid;
+	uint coreunit;
+	uint i;
+
+	si = SB_INFO(sbh);
+	coreunit = 0;
+
+	idx = si->curidx;
+
+	ASSERT(GOODREGS(si->curmap));
+	coreid = si->coreid[idx];
+
+	/* count the cores of our type */
+	for (i = 0; i < idx; i++)
+		if (si->coreid[i] == coreid)
+			coreunit++;
+
+	return (coreunit);
+}
+
+/* returns the current speed the SB is running at */
+uint32
+sb_clock(void *sbh)
+{
+	return 133000000;
+}
+
+/* change logical "focus" to the gpio core for optimized access */
+void*
+sb_gpiosetcore(void *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	return (sb_setcoreidx(sbh, si->gpioidx));
+}
+
+/* mask&set gpiocontrol bits */
+uint32
+sb_gpiocontrol(void *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio output enable bits */
+uint32
+sb_gpioouten(void *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioouten);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio output bits */
+uint32
+sb_gpioout(void *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioout);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+}
+
+/* return the current gpioin register value */
+uint32
+sb_gpioin(void *sbh)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioin);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, 0, 0));
+}
+
+/* mask&set gpio interrupt polarity bits */
+uint32
+sb_gpiointpolarity(void *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio interrupt mask bits */
+uint32
+sb_gpiointmask(void *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiointmask);
+		break;
+
+	default:
+		return (0);
+	}
+
+	return (sb_corereg(sbh, si->gpioidx, regoff, mask, val));
+}
+
+
+/* register driver interrupt disabling and restoring callback functions */
+void
+sb_register_intr_callback(void *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intr_arg)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	si->intr_arg = intr_arg;
+	si->intrsoff_fn = (sb_intrsoff_t)intrsoff_fn;
+	si->intrsrestore_fn = (sb_intrsrestore_t)intrsrestore_fn;
+	/* save current core id.  when this function called, the current core
+	 * must be the core which provides driver functions(il, et, wl, etc.)
+	 */
+	si->dev_coreid = si->coreid[si->curidx];
+}
diff --git a/arch/mips/bcm5621x/serial.c b/arch/mips/bcm5621x/serial.c
new file mode 100644
index 0000000..fe983e1
--- /dev/null
+++ b/arch/mips/bcm5621x/serial.c
@@ -0,0 +1,51 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Wind River Systems, Inc.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+
+#define BCM_UART_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP)
+
+static struct plat_serial8250_port uart8250_data[] = {
+	{
+		.membase	= (void __iomem *)0xb8000300,
+		.mapbase	= 0x18000300,
+		.irq		= MIPS_CPU_IRQ_BASE + 0,
+		.uartclk	= 133000000,
+		.iotype		= UPIO_MEM,
+		.flags		= BCM_UART_FLAGS,
+		.regshift	= 0,
+	},
+	{
+		.membase	= (void __iomem *)0xb8000400,
+		.mapbase	= 0x18000400,
+		.irq		= MIPS_CPU_IRQ_BASE + 4,
+		.uartclk	= 133000000,
+		.iotype		= UPIO_MEM,
+		.flags		= BCM_UART_FLAGS,
+		.regshift	= 0,
+	},
+	{ },
+};
+
+static struct platform_device uart8250_device = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= uart8250_data,
+	},
+};
+
+static int __init uart8250_init(void)
+{
+	return platform_device_register(&uart8250_device);
+}
+
+module_init(uart8250_init);
+
diff --git a/arch/mips/bcm5621x/setup.c b/arch/mips/bcm5621x/setup.c
new file mode 100644
index 0000000..d97175c
--- /dev/null
+++ b/arch/mips/bcm5621x/setup.c
@@ -0,0 +1,91 @@
+/*
+ * Generic setup routines for Broadcom MIPS boards
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ * Copyright (C) 2005 MontaVista Inc. ( 2.6 kernel modification )
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <linux/initrd.h>
+#include <linux/major.h>
+#include <linux/kdev_t.h>
+#include <linux/root_dev.h>
+#include <asm/bootinfo.h>
+
+#include <asm/mach-bcm5621x/typedefs.h>
+#include <asm/mach-bcm5621x/bcmdevs.h>
+#include <asm/mach-bcm5621x/bcmutils.h>
+#include <asm/mach-bcm5621x/sbmips.h>
+#include <asm/mach-bcm5621x/sbutils.h>
+
+/* Global SB handle */
+void *bcm956218_sbh = NULL;
+spinlock_t bcm956218_sbh_lock = SPIN_LOCK_UNLOCKED;
+EXPORT_SYMBOL(bcm956218_sbh);
+EXPORT_SYMBOL(bcm956218_sbh_lock);
+
+#ifdef CONFIG_EMBEDDED_RAMDISK
+extern void * __rd_start, * __rd_end;
+#endif
+
+/* Convenience */
+#define sbh bcm956218_sbh
+#define sbh_lock bcm956218_sbh_lock
+
+void bcm956218_machine_restart(char *command)
+{
+	printk("Please stand by while rebooting the system...\n");
+
+	/* Set the watchdog timer to reset immediately */
+	local_irq_disable();
+	sb_watchdog(sbh, 1);
+	while (1);
+}
+
+void bcm956218_machine_halt(void)
+{
+	printk("System halted\n");
+
+	/* Disable interrupts and watchdog and spin forever */
+	local_irq_disable();
+	sb_watchdog(sbh, 0);
+	while (1);
+}
+
+void __init plat_mem_setup(void)
+{
+	/* Get global SB handle */
+	sbh = sb_kattach();
+
+	/* Initialize clocks and interrupts */
+	_machine_restart = bcm956218_machine_restart;
+	_machine_halt = bcm956218_machine_halt;
+	pm_power_off = bcm956218_machine_halt;
+}
+
+void __init bus_error_init(void)
+{
+}
+
diff --git a/arch/mips/bcm5621x/time.c b/arch/mips/bcm5621x/time.c
new file mode 100644
index 0000000..301932e
--- /dev/null
+++ b/arch/mips/bcm5621x/time.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2004 Broadcom Corporation
+ * Copyright (C) 2008 Wind River Systems, Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/serial_reg.h>
+#include <linux/interrupt.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+#include <asm/mach-bcm5621x/typedefs.h>
+#include <asm/mach-bcm5621x/sbutils.h>
+#include <asm/mach-bcm5621x/sbmips.h>
+
+extern void *bcm956218_sbh;
+extern spinlock_t bcm956218_sbh_lock;
+
+/* Convenience */
+#define sbh bcm956218_sbh
+#define sbh_lock bcm956218_sbh_lock
+
+extern int panic_timeout;
+static int watchdog = 0;
+
+void __init plat_time_init(void)
+{
+	unsigned int hz;
+
+	/*
+	 * Use deterministic values for initial counter interrupt
+	 * so that calibrate delay avoids encountering a counter wrap.
+	 */
+	write_c0_count(0);
+	write_c0_compare(0xffff);
+
+	if (!(hz = sb_mips_clock(sbh)))
+		hz = 100000000;
+
+	printk("CPU: BCM%05d rev %d at %d MHz\n", sb_chip(sbh),
+	       sb_chiprev(sbh), (hz + 500000) / 1000000);
+
+	/* Set MIPS counter frequency for fixed_rate_gettimeoffset() */
+	mips_hpt_frequency = hz / 2;
+
+	/* Set watchdog interval in ms */
+	watchdog = 0xffffffff;
+
+	/* Set panic timeout in seconds */
+	panic_timeout = watchdog / 1000;
+}
diff --git a/include/asm-mips/mach-bcm5621x/bcmdevs.h b/include/asm-mips/mach-bcm5621x/bcmdevs.h
new file mode 100644
index 0000000..3d3b7a4
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/bcmdevs.h
@@ -0,0 +1,245 @@
+/*
+ * Broadcom device-specific manifest constants.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_BCMDEVS_H
+#define	_BCMDEVS_H
+
+/* Known PCI vendor Id's */
+#define	VENDOR_EPIGRAM		0xfeda
+#define	VENDOR_BROADCOM		0x14e4
+#define	VENDOR_3COM		0x10b7
+#define	VENDOR_NETGEAR		0x1385
+#define	VENDOR_DIAMOND		0x1092
+#define	VENDOR_DELL		0x1028
+#define	VENDOR_HP		0x0e11
+#define	VENDOR_APPLE		0x106b
+
+/* PCI Device Id's */
+#define	BCM4210_DEVICE_ID	0x1072	/* never used */
+#define	BCM4211_DEVICE_ID	0x4211
+#define	BCM4230_DEVICE_ID	0x1086	/* never used */
+#define	BCM4231_DEVICE_ID	0x4231
+
+#define	BCM4410_DEVICE_ID	0x4410	/* bcm44xx family pci iline */
+#define	BCM4430_DEVICE_ID	0x4430	/* bcm44xx family cardbus iline */
+#define	BCM4412_DEVICE_ID	0x4412	/* bcm44xx family pci enet */
+#define	BCM4432_DEVICE_ID	0x4432	/* bcm44xx family cardbus enet */
+
+#define	BCM3352_DEVICE_ID	0x3352	/* bcm3352 device id */
+#define	BCM3360_DEVICE_ID	0x3360	/* bcm3360 device id */
+
+#define	EPI41210_DEVICE_ID	0xa0fa	/* bcm4210 */
+#define	EPI41230_DEVICE_ID	0xa10e	/* bcm4230 */
+
+#define	BCM47XX_ILINE_ID	0x4711	/* 47xx iline20 */
+#define	BCM47XX_V90_ID		0x4712	/* 47xx v90 codec */
+#define	BCM47XX_ENET_ID		0x4713	/* 47xx enet */
+#define	BCM47XX_EXT_ID		0x4714	/* 47xx external i/f */
+#define	BCM47XX_USB_ID		0x4715	/* 47xx usb */
+#define	BCM47XX_USBH_ID		0x4716	/* 47xx usb host */
+#define	BCM47XX_USBD_ID		0x4717	/* 47xx usb device */
+#define	BCM47XX_IPSEC_ID	0x4718	/* 47xx ipsec */
+
+#define	BCM4710_DEVICE_ID	0x4710	/* 4710 primary function 0 */
+
+#define	BCM4610_DEVICE_ID	0x4610	/* 4610 primary function 0 */
+#define	BCM4610_ILINE_ID	0x4611	/* 4610 iline100 */
+#define	BCM4610_V90_ID		0x4612	/* 4610 v90 codec */
+#define	BCM4610_ENET_ID		0x4613	/* 4610 enet */
+#define	BCM4610_EXT_ID		0x4614	/* 4610 external i/f */
+#define	BCM4610_USB_ID		0x4615	/* 4610 usb */
+
+#define	BCM4402_DEVICE_ID	0x4402	/* 4402 primary function 0 */
+#define	BCM4402_ENET_ID		0x4402	/* 4402 enet */
+#define	BCM4402_V90_ID		0x4403	/* 4402 v90 codec */
+
+#define	BCM4301_DEVICE_ID	0x4301	/* 4301 primary function 0 */
+#define	BCM4301_D11B_ID		0x4301	/* 4301 802.11b */
+
+#define	BCM4307_DEVICE_ID	0x4307	/* 4307 primary function 0 */
+#define	BCM4307_V90_ID		0x4305	/* 4307 v90 codec */
+#define	BCM4307_ENET_ID		0x4306	/* 4307 enet */
+#define	BCM4307_D11B_ID		0x4307	/* 4307 802.11b */
+
+#define	BCM4306_DEVICE_ID	0x4306	/* 4306 chipcommon chipid */
+#define	BCM4306_D11G_ID		0x4320	/* 4306 802.11g */
+#define	BCM4306_D11G_ID2	0x4325
+#define	BCM4306_D11A_ID		0x4321	/* 4306 802.11a */
+#define	BCM4306_UART_ID		0x4322	/* 4306 uart */
+#define	BCM4306_V90_ID		0x4323	/* 4306 v90 codec */
+#define	BCM4306_D11DUAL_ID	0x4324	/* 4306 dual A+B */
+
+#define	BCM4309_PKG_ID		1	/* 4309 package id */
+
+#define	BCM4303_D11B_ID		0x4303	/* 4303 802.11b */
+#define	BCM4303_PKG_ID		2	/* 4303 package id */
+
+#define	BCM4310_DEVICE_ID	0x4310	/* 4310 chipcommon chipid */
+#define	BCM4310_D11B_ID		0x4311	/* 4310 802.11b */
+#define	BCM4310_UART_ID		0x4312	/* 4310 uart */
+#define	BCM4310_ENET_ID		0x4313	/* 4310 enet */
+#define	BCM4310_USB_ID		0x4315	/* 4310 usb */
+
+#define	BCM4704_DEVICE_ID	0x4704	/* 4704 chipcommon chipid */
+#define	BCM4704_V90_ID		0x4705	/* 4704 802.11b */
+#define	BCM4704_ENET_ID		0x4706	/* 4704 enet (Use 47XX_ENET_ID instead!) */
+#define	BCM4704_USB_ID		0x4707	/* 4704 usb */
+#define	BCM4704_IPSEC_ID	0x4708	/* 4704 ipsec */
+
+#define	BCM4712_DEVICE_ID	0x4712	/* 4712 chipcommon chipid */
+#define	BCM4712_MIPS_ID		0x4720	/* 4712 base devid */
+#define	BCM4712SMALL_PKG_ID	1	/* 200pin 4712 package id */
+
+#define	BCM4317_DEVICE_ID	0x4317	/* 4317 chip common chipid */
+#define	BCM4317_D11B_ID		0x4317	/* 4317 802.11b */
+
+#define	SDIOH_FPGA_ID		0x4380	/* sdio host fpga */
+
+#define BCM5365_DEVICE_ID       0x5365	/* 5365 chipcommon chipid */
+#define BCM5365_ENET_ID         0x0806	/* 5365 enet */
+
+#define BCM56218_DEVICE_ID      56210  /* 5621x chipid */
+
+
+/* PCMCIA vendor Id's */
+
+#define	VENDOR_BROADCOM_PCMCIA	0x02d0
+
+/* SDIO vendor Id's */
+#define	VENDOR_BROADCOM_SDIO	0x00BF
+
+
+/* boardflags */
+#define	BFL_BTCOEXIST		0x0001	/* This board implements Bluetooth coexistance */
+#define	BFL_PACTRL		0x0002	/* This board has GPIO 9 controlling the PA */
+#define	BFL_AIRLINEMODE		0x0004	/* This board implements GPIO 13 radio disable indication */
+#define	BFL_ENETSPI		0x0010	/* This board has ephy roboswitch spi */
+#define	BFL_CCKHIPWR		0x0040	/* Can do high-power CCK transmission */
+#define	BFL_ENETADM		0x0080	/* This board has ADMtek switch */
+#define	BFL_ENETVLAN		0x0100	/* This board can do vlan */
+
+/* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
+#define BOARD_GPIO_HWRAD_B	0x010	/* bit 4 is HWRAD input on 4301 */
+#define	BOARD_GPIO_BTC_IN	0x080	/* bit 7 is BT Coexistance Input */
+#define	BOARD_GPIO_BTC_OUT	0x100	/* bit 8 is BT Coexistance Out */
+#define	BOARD_GPIO_PACTRL	0x200	/* bit 9 controls the PA on new 4306 boards */
+#define	PCI_CFG_GPIO_SCS	0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define PCI_CFG_GPIO_HWRAD	0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+/* Bus types */
+#define	SB_BUS			0	/* Silicon Backplane */
+#define	PCI_BUS			1	/* PCI target */
+#define	PCMCIA_BUS		2	/* PCMCIA target */
+#define SDIO_BUS		3	/* SDIO target */
+
+/* Reference Board Types */
+
+#define	BU4710_BOARD		0x0400
+#define	VSIM4710_BOARD		0x0401
+#define	QT4710_BOARD		0x0402
+
+#define	BU4610_BOARD		0x0403
+#define	VSIM4610_BOARD		0x0404
+
+#define	BU4307_BOARD		0x0405
+#define	BCM94301CB_BOARD	0x0406
+#define	BCM94301PC_BOARD	0x0406	/* PCMCIA 5V card */
+#define	BCM94301MP_BOARD	0x0407
+#define	BCM94307MP_BOARD	0x0408
+#define	BCMAP4307_BOARD		0x0409
+
+#define	BU4309_BOARD		0x040a
+#define	BCM94309CB_BOARD	0x040b
+#define	BCM94309MP_BOARD	0x040c
+#define	BCM4309AP_BOARD		0x040d
+
+#define	BCM94302MP_BOARD	0x040e
+
+#define	VSIM4310_BOARD		0x040f
+#define	BU4711_BOARD		0x0410
+#define	BCM94310U_BOARD		0x0411
+#define	BCM94310AP_BOARD	0x0412
+#define	BCM94310MP_BOARD	0x0414
+
+#define	BU4306_BOARD		0x0416
+#define	BCM94306CB_BOARD	0x0417
+#define	BCM94306MP_BOARD	0x0418
+
+#define	BCM94710D_BOARD		0x041a
+#define	BCM94710R1_BOARD	0x041b
+#define	BCM94710R4_BOARD	0x041c
+#define	BCM94710AP_BOARD	0x041d
+
+
+#define	BU2050_BOARD		0x041f
+
+
+#define	BCM94309G_BOARD		0x0421
+
+#define	BCM94301PC3_BOARD	0x0422	/* PCMCIA 3.3V card */
+
+#define	BU4704_BOARD		0x0423
+#define	BU4702_BOARD		0x0424
+
+#define	BCM94306PC_BOARD	0x0425	/* PCMCIA 3.3V 4306 card */
+
+
+
+#define	BCM94702MN_BOARD	0x0428
+
+/* BCM4702 1U CompactPCI Board */
+#define	BCM94702CPCI_BOARD	0x0429
+
+/* BCM4702 with BCM95380 VLAN Router */
+#define	BCM95380RR_BOARD	0x042a
+
+/* cb4306 with SiGe PA */
+#define	BCM94306CBSG_BOARD	0x042b
+
+/* mp4301 with 2050 radio */
+#define	BCM94301MPL_BOARD	0x042c
+
+/* cb4306 with SiGe PA */
+#define	PCSG94306_BOARD		0x042d
+
+/* bu4704 with sdram */
+#define	BU4704SD_BOARD		0x042e
+
+/* Dual 11a/11g Router */
+#define	BCM94704AGR_BOARD	0x042f
+
+/* 11a-only minipci */
+#define	BCM94308MP_BOARD	0x0430
+
+
+
+/* BCM5365K Sentry-5 Evaluation Platform */
+#define BCM95365K_BOARD         0x0444
+
+/* BCM5365P Sentry-5 PCI NIC Evaluation Platform */
+#define BCM95365P_BOARD         0x0445
+
+/* BCM5365R Sentry-5 Router/AP Reference Platform */
+#define BCM95365R_BOARD         0x0446
+
+#endif				/* _BCMDEVS_H */
diff --git a/include/asm-mips/mach-bcm5621x/bcmutils.h b/include/asm-mips/mach-bcm5621x/bcmutils.h
new file mode 100644
index 0000000..4571a54
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/bcmutils.h
@@ -0,0 +1,144 @@
+/*
+ * Misc useful os-independent macros and functions.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+#ifndef MIN
+#define	MIN(a, b)		(((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define	MAX(a, b)		(((a)>(b))?(a):(b))
+#endif
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((ulong)(x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((uint)(a) & ((x)-1)) == 0)
+#define	ISPOWEROF2(x)		((((x)-1)&(x))==0)
+#define	OFFSETOF(type, member)	((uint) &((type *)0)->member)
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+
+/* bit map related macros */
+#ifndef setbit
+#define	NBBY	8		/* 8 bits per byte */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif
+
+#define	NBITS(type)	(sizeof (type) * 8)
+
+#define _BCM_U	0x01		/* upper */
+#define _BCM_L	0x02		/* lower */
+#define _BCM_D	0x04		/* digit */
+#define _BCM_C	0x08		/* cntrl */
+#define _BCM_P	0x10		/* punct */
+#define _BCM_S	0x20		/* white space (space/lf/tab) */
+#define _BCM_X	0x40		/* hex digit */
+#define _BCM_SP	0x80		/* hard space (0x20) */
+
+extern unsigned char bcm_ctype[];
+#define bcm_ismask(x) (bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* generic osl packet queue */
+struct pktq {
+	void *head;
+	void *tail;
+	uint len;
+	uint maxlen;
+};
+#define DEFAULT_QLEN	128
+
+#define	pktq_len(q)		((q)->len)
+#define	pktq_avail(q)	((q)->maxlen - (q)->len)
+#define	pktq_head(q)	((q)->head)
+#define	pktq_full(q)	((q)->len >= (q)->maxlen)
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff	/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f	/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff	/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8	/* Good final CRC16 checksum value */
+#define CRC32_INIT_VALUE 0xffffffff	/* Initial CRC32 checksum value */
+#define CRC32_GOOD_VALUE 0xdebb20e3	/* Good final CRC32 checksum value */
+
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+	uint8 id;
+	uint8 len;
+	uint8 data[1];
+} bcm_tlv_t;
+
+/* externs */
+extern uint bcm_atoi(char *s);
+extern uchar bcm_toupper(uchar c);
+extern ulong bcm_strtoul(char *cp, char **endp, uint base);
+extern void deadbeef(char *p, uint len);
+extern void prhex(char *msg, uchar * buf, uint len);
+extern void prpkt(char *msg, void *drv, void *p0);
+extern uint pktcopy(void *drv, void *p, uint offset, int len, uchar * buf);
+extern uint pkttotlen(void *drv, void *);
+extern uchar *bcm_ether_ntoa(char *ea, char *buf);
+extern int bcm_ether_atoe(char *p, char *ea);
+extern void bcm_mdelay(uint ms);
+extern char *getvar(char *vars, char *name);
+extern int getintvar(char *vars, char *name);
+
+extern uint8 crc8(uint8 * p, uint nbytes, uint8 crc);
+extern uint16 crc16(uint8 * p, uint nbytes, uint16 crc);
+extern uint32 crc32(uint8 * p, uint nbytes, uint32 crc);
+extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
+extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
+extern void pktqinit(struct pktq *q, int maxlen);
+extern void pktenq(struct pktq *q, void *p, bool lifo);
+extern void *pktdeq(struct pktq *q);
+
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+
+#endif				/* _bcmutils_h_ */
diff --git a/include/asm-mips/mach-bcm5621x/linux_osl.h b/include/asm-mips/mach-bcm5621x/linux_osl.h
new file mode 100644
index 0000000..43d4afc
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/linux_osl.h
@@ -0,0 +1,340 @@
+/*
+ * Linux OS Independent Layer
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ * Copyright (C) 2005 MontaVista Inc. ( 2.6 kernel modifications )
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Linux OS Independent Layer
+ *
+ */
+
+#ifndef _linux_osl_h_
+#define _linux_osl_h_
+
+#include <asm/mach-bcm5621x/typedefs.h>
+
+/* use current 2.4.x calling conventions */
+#include <asm/mach-bcm5621x/linuxver.h>
+
+/* assert and panic */
+#ifdef BCMDBG
+#define ASSERT(exp) \
+	do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(char *exp, char *file, int line);
+#else
+#define	ASSERT(exp)		do {} while (0)
+#endif
+
+/* PCMCIA attribute space access macros */
+#define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
+#define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
+extern void osl_pcmcia_read_attr(void *osh, uint offset, void *buf,
+				 int size);
+extern void osl_pcmcia_write_attr(void *osh, uint offset, void *buf,
+				  int size);
+
+/* PCI configuration space access macros */
+#define	OSL_PCI_READ_CONFIG(loc, offset, size) \
+	osl_pci_read_config((loc), (offset), (size))
+#define	OSL_PCI_WRITE_CONFIG(loc, offset, size, val) \
+	osl_pci_write_config((loc), (offset), (size), (val))
+extern uint32 osl_pci_read_config(void *loc, uint size, uint offset);
+extern void osl_pci_write_config(void *loc, uint offset, uint size,
+				 uint val);
+
+/* OSL initialization */
+#define osl_init()		do {} while (0)
+
+/* host/bus architecture-specific byte swap */
+#define BUS_SWAP32(v)		(v)
+
+/*
+ * BINOSL selects the slightly slower function-call-based binary compatible osl.
+ * Macros expand to calls to functions defined in linux_osl.c .
+ */
+#ifndef BINOSL
+
+/* string library */
+#define	printf(fmt, args...)	printk(fmt, ## args)
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* register access macros */
+
+#define R_REG(r) ({ \
+	__typeof(*(r)) __osl_v; \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	__osl_v = readb((void*)(r)); break; \
+	case sizeof(uint16):	__osl_v = readw((void*)(r)); break; \
+	case sizeof(uint32):	__osl_v = readl((void*)(r)); break; \
+	} \
+	__osl_v; \
+})
+
+#define W_REG(r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	writeb((uint8)(v),(void*)(r)); break; \
+	case sizeof(uint16):	writew((uint16)(v),(void*)(r)); break; \
+	case sizeof(uint32):	writel((uint32)(v),(void*)(r)); break; \
+	} \
+} while (0)
+
+#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
+#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+
+/* bcopy, bcmp, and bzero */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+
+/* general purpose memory allocation */
+#define	MALLOC(size)		kmalloc((size), GFP_ATOMIC)
+#define	MFREE(addr, size)	kfree((addr))
+
+/* uncached virtual address */
+#ifdef mips
+#define OSL_UNCACHED(va)	KSEG1ADDR((va))
+#include <asm/addrspace.h>
+#else
+#define OSL_UNCACHED(va)	(va)
+#endif
+
+/* get processor cycle count */
+#if defined(mips)
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count() * 2)
+#elif defined(__i386__)
+#define	OSL_GETCYCLES(x)	rdtscl((x))
+#else
+#define OSL_GETCYCLES(x)	((x) = 0)
+#endif
+
+/* map/unmap physical to virtual I/O */
+#define	REG_MAP(pa, size)	ioremap_nocache((unsigned long)(pa), (unsigned long)(size))
+#define	REG_UNMAP(va)		iounmap((void *)(va))
+
+/* dereference an address that may cause a bus exception */
+#ifdef mips
+#if defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17))
+#define BUSPROBE(val, addr)	panic("get_dbe() will not fixup a bus exception when compiled into a module")
+#else
+#define	BUSPROBE(val, addr)	get_dbe((val), (addr))
+#include <asm/paccess.h>
+#endif
+#else
+#define	BUSPROBE(val, addr)	({ (val) = R_REG((addr)); 0; })
+#endif
+
+/* allocate/free shared (dma-able) consistent (uncached) memory */
+#define	DMA_ALLOC_CONSISTENT(dev, size, pap) \
+	pci_alloc_consistent((dev), (size), (dma_addr_t*)(pap))
+#define	DMA_FREE_CONSISTENT(dev, va, size, pa) \
+	pci_free_consistent((dev), (size), (va), (dma_addr_t)(pa))
+
+/* map/unmap direction */
+#define	DMA_TX			PCI_DMA_TODEVICE
+#define	DMA_RX			PCI_DMA_FROMDEVICE
+
+/* map/unmap shared (dma-able) memory */
+#define	DMA_MAP(dev, va, size, direction, p) \
+	pci_map_single((dev), (va), (size), (direction))
+#define	DMA_UNMAP(dev, pa, size, direction, p) \
+	pci_unmap_single((dev), (dma_addr_t)(pa), (size), (direction))
+
+/* microsecond delay */
+#define	OSL_DELAY(usec)		udelay(usec)
+#include <linux/delay.h>
+#define OSL_SLEEP(usec) set_current_state(TASK_INTERRUPTIBLE); \
+                        schedule_timeout((usec*HZ)/1000000);
+#define OSL_IN_INTERRUPT() in_interrupt()
+
+
+
+/* shared (dma-able) memory access macros */
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	memset((r), '\0', (len))
+
+/* packet primitives */
+#define	PKTGET(drv, len, send)		osl_pktget((drv), (len), (send))
+#define	PKTFREE(drv, skb, send)		osl_pktfree((skb))
+#define	PKTDATA(drv, skb)		(((struct sk_buff*)(skb))->data)
+#define	PKTLEN(drv, skb)		(((struct sk_buff*)(skb))->len)
+#define	PKTNEXT(drv, skb)		(((struct sk_buff*)(skb))->next)
+#define	PKTSETNEXT(skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
+#define	PKTSETLEN(drv, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
+#define	PKTPUSH(drv, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
+#define	PKTPULL(drv, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
+#define	PKTDUP(drv, skb)		skb_clone((struct sk_buff*)(skb), GFP_ATOMIC)
+#define	PKTCOOKIE(skb)			((void*)((struct sk_buff*)(skb))->csum)
+#define	PKTSETCOOKIE(skb, x)		(((struct sk_buff*)(skb))->csum = (uint)(x))
+#define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
+#define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
+extern void *osl_pktget(void *drv, uint len, bool send);
+extern void osl_pktfree(void *skb);
+
+#else				/* BINOSL */
+
+/* string library */
+#ifndef LINUX_OSL
+#undef printf
+#define	printf(fmt, args...)		osl_printf((fmt), ## args)
+#undef sprintf
+#define sprintf(buf, fmt, args...)	osl_sprintf((buf), (fmt), ## args)
+#undef strcmp
+#define	strcmp(s1, s2)			osl_strcmp((s1), (s2))
+#undef strncmp
+#define	strncmp(s1, s2, n)		osl_strncmp((s1), (s2), (n))
+#undef strlen
+#define strlen(s)			osl_strlen((s))
+#undef strcpy
+#define	strcpy(d, s)			osl_strcpy((d), (s))
+#undef strncpy
+#define	strncpy(d, s, n)		osl_strncpy((d), (s), (n))
+#undef strcat
+#define	strcat(d, s)			osl_strcat((d), (s))
+#undef strncat
+#define	strncat(d, s, n)		osl_strncat((d), (s), (n))
+#endif
+extern int osl_printf(const char *format, ...);
+extern int osl_sprintf(char *buf, const char *format, ...);
+extern int osl_strcmp(const char *s1, const char *s2);
+extern int osl_strncmp(const char *s1, const char *s2, uint n);
+extern int osl_strlen(char *s);
+extern char *osl_strcpy(char *d, const char *s);
+extern char *osl_strncpy(char *d, const char *s, uint n);
+extern char *osl_strcat(char *d, const char *s);
+extern char *osl_strncat(char *d, const char *s, uint n);
+
+/* register access macros */
+#define R_REG(r) ({ \
+	__typeof(*(r)) __osl_v; \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	__osl_v = osl_readb((volatile uint8*)(r)); break; \
+	case sizeof(uint16):	__osl_v = osl_readw((volatile uint16*)(r)); break; \
+	case sizeof(uint32):	__osl_v = osl_readl((volatile uint32*)(r)); break; \
+	} \
+	__osl_v; \
+})
+#define W_REG(r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	osl_writeb((uint8)(v), (volatile uint8*)(r)); break; \
+	case sizeof(uint16):	osl_writew((uint16)(v), (volatile uint16*)(r)); break; \
+	case sizeof(uint32):	osl_writel((uint32)(v), (volatile uint32*)(r)); break; \
+	} \
+} while (0)
+#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
+#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+extern uint8 osl_readb(volatile uint8 * r);
+extern uint16 osl_readw(volatile uint16 * r);
+extern uint32 osl_readl(volatile uint32 * r);
+extern void osl_writeb(uint8 v, volatile uint8 * r);
+extern void osl_writew(uint16 v, volatile uint16 * r);
+extern void osl_writel(uint32 v, volatile uint32 * r);
+
+/* bcopy, bcmp, and bzero */
+extern void bcopy(const void *src, void *dst, int len);
+extern int bcmp(const void *b1, const void *b2, int len);
+extern void bzero(void *b, int len);
+
+/* general purpose memory allocation */
+#define	MALLOC(size)		osl_malloc((size))
+#define	MFREE(addr, size)	osl_mfree((char*)(addr), (size))
+extern void *osl_malloc(uint size);
+extern void osl_mfree(void *addr, uint size);
+
+/* uncached virtual address */
+#define OSL_UNCACHED(va)	osl_uncached((va))
+extern void *osl_uncached(void *va);
+
+/* get processor cycle count */
+#define OSL_GETCYCLES(x)	((x) = osl_getcycles())
+extern uint osl_getcycles(void);
+
+/* map/unmap physical to virtual */
+#define	REG_MAP(pa, size)	osl_reg_map((pa), (size))
+#define	REG_UNMAP(va)		osl_reg_unmap((va))
+extern void *osl_reg_map(uint32 pa, uint size);
+extern void osl_reg_unmap(void *va);
+
+/* dereference an address that may target abort */
+#define	BUSPROBE(val, addr)	osl_busprobe(&(val), (addr))
+extern int osl_busprobe(uint32 * val, uint32 addr);
+
+/* allocate/free shared (dma-able) consistent (uncached) memory */
+#define	DMA_ALLOC_CONSISTENT(dev, size, pap) \
+	osl_dma_alloc_consistent((dev), (size), (pap))
+#define	DMA_FREE_CONSISTENT(dev, va, size, pa) \
+	osl_dma_free_consistent((dev), (void*)(va), (size), (pa))
+extern void *osl_dma_alloc_consistent(void *dev, uint size, void *pap);
+extern void osl_dma_free_consistent(void *dev, void *va, uint size,
+				    void *pa);
+
+/* map/unmap direction */
+#define	DMA_TX	1
+#define	DMA_RX	2
+
+/* map/unmap shared (dma-able) memory */
+#define	DMA_MAP(dev, va, size, direction, p) \
+	osl_dma_map((dev), (va), (size), (direction))
+#define	DMA_UNMAP(dev, pa, size, direction, p) \
+	osl_dma_unmap((dev), (pa), (size), (direction))
+extern uint osl_dma_map(void *dev, void *va, uint size, int direction);
+extern void osl_dma_unmap(void *dev, uint pa, uint size, int direction);
+
+/* microsecond delay */
+#define	OSL_DELAY(usec)		osl_delay((usec))
+extern void osl_delay(uint usec);
+
+/* shared (dma-able) memory access macros */
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	bzero((r), (len))
+
+/* packet primitives */
+#define	PKTGET(drv, len, send)		osl_pktget((drv), (len), (send))
+#define	PKTFREE(drv, skb, send)		osl_pktfree((skb))
+#define	PKTDATA(drv, skb)		osl_pktdata((drv), (skb))
+#define	PKTLEN(drv, skb)		osl_pktlen((drv), (skb))
+#define	PKTNEXT(drv, skb)		osl_pktnext((drv), (skb))
+#define	PKTSETNEXT(skb, x)		osl_pktsetnext((skb), (x))
+#define	PKTSETLEN(drv, skb, len)	osl_pktsetlen((drv), (skb), (len))
+#define	PKTPUSH(drv, skb, bytes)	osl_pktpush((drv), (skb), (bytes))
+#define	PKTPULL(drv, skb, bytes)	osl_pktpull((drv), (skb), (bytes))
+#define	PKTDUP(drv, skb)		osl_pktdup((drv), (skb))
+#define	PKTCOOKIE(skb)			osl_pktcookie((skb))
+#define	PKTSETCOOKIE(skb, x)		osl_pktsetcookie((skb), (x))
+#define	PKTLINK(skb)			osl_pktlink((skb))
+#define	PKTSETLINK(skb, x)		osl_pktsetlink((skb), (x))
+extern void *osl_pktget(void *drv, uint len, bool send);
+extern void osl_pktfree(void *skb);
+extern uchar *osl_pktdata(void *drv, void *skb);
+extern uchar *osl_pktdata(void *drv, void *skb);
+extern void *osl_pktnext(void *drv, void *skb);
+extern void osl_pktsetnext(void *skb, void *x);
+extern void osl_pktsetlen(void *drv, void *skb, uint len);
+extern uchar *osl_pktpush(void *drv, void *skb, int bytes);
+extern uchar *osl_pktpull(void *drv, void *skb, int bytes);
+extern void *osl_pktdup(void *drv, void *skb);
+extern void *osl_pktcookie(void *skb);
+extern void osl_pktsetcookie(void *skb, void *x);
+extern void *osl_pktlink(void *skb);
+extern void osl_pktsetlink(void *skb, void *x);
+
+#endif				/* BINOSL */
+
+#endif				/* _linux_osl_h_ */
diff --git a/include/asm-mips/mach-bcm5621x/linuxver.h b/include/asm-mips/mach-bcm5621x/linuxver.h
new file mode 100644
index 0000000..2327538
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/linuxver.h
@@ -0,0 +1,335 @@
+/*
+ * Linux-specific abstractions to gain some independence from linux
+ * kernel versions.  Pave over some 2.2 versus 2.4 kernel differences.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _linuxver_h_
+#define _linuxver_h_
+
+/* #include <linux/config.h> */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+/* __NO_VERSION__ must be defined for all linkables except one in 2.2 */
+#ifdef __UNDEF_NO_VERSION__
+#undef __NO_VERSION__
+#else
+#define __NO_VERSION__
+#endif
+#endif
+
+#if defined(MODULE) && defined(MODVERSIONS)
+#include <linux/modversions.h>
+#endif
+
+/* linux/malloc.h is deprecated, use linux/slab.h instead. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9))
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+
+#ifndef __exit
+#define __exit
+#endif
+#ifndef __devexit
+#define __devexit
+#endif
+#ifndef __devinit
+#define __devinit	__init
+#endif
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+
+#define pci_get_drvdata(dev)		(dev)->sysdata
+#define pci_set_drvdata(dev, value)	(dev)->sysdata=(value)
+
+/*
+ * New-style (2.4.x) PCI/hot-pluggable PCI/CardBus registration
+ */
+
+struct pci_device_id {
+	unsigned int vendor, device;	/* Vendor and device ID or PCI_ANY_ID */
+	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	unsigned int class, class_mask;	/* (class,subclass,prog-if) triplet */
+	unsigned long driver_data;	/* Data private to the driver */
+};
+
+struct pci_driver {
+	struct list_head node;
+	char *name;
+	const struct pci_device_id *id_table;	/* NULL if wants all devices */
+	int (*probe) (struct pci_dev * dev, const struct pci_device_id * id);	/* New device inserted */
+	void (*remove) (struct pci_dev * dev);	/* Device removed (NULL if not a hot-plug capable driver) */
+	void (*suspend) (struct pci_dev * dev);	/* Device suspended */
+	void (*resume) (struct pci_dev * dev);	/* Device woken up */
+};
+
+#define MODULE_DEVICE_TABLE(type, name)
+#define PCI_ANY_ID (~0)
+
+/* compatpci.c */
+#define pci_module_init pci_register_driver
+extern int pci_register_driver(struct pci_driver *drv);
+extern void pci_unregister_driver(struct pci_driver *drv);
+
+#endif				/* PCI registration */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18))
+#ifdef MODULE
+#define module_init(x) int init_module(void) { return x(); }
+#define module_exit(x) void cleanup_module(void) { x(); }
+#else
+#define module_init(x)	__initcall(x);
+#define module_exit(x)	__exitcall(x);
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,48))
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,13))
+#define pci_resource_start(dev, bar)	((dev)->base_address[(bar)])
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,44))
+#define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,23))
+#define pci_enable_device(dev) do { } while (0)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,14))
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,42))
+
+/*
+ * DMA mapping
+ *
+ * See linux/Documentation/DMA-mapping.txt
+ */
+
+#ifndef PCI_DMA_TODEVICE
+#define	PCI_DMA_TODEVICE	1
+#define	PCI_DMA_FROMDEVICE	2
+#endif
+
+typedef u32 dma_addr_t;
+
+/* Pure 2^n version of get_order */
+static inline int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size - 1) >> (PAGE_SHIFT - 1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+static inline void *pci_alloc_consistent(struct pci_dev *hwdev,
+					 size_t size,
+					 dma_addr_t * dma_handle)
+{
+	void *ret;
+	int gfp = GFP_ATOMIC | GFP_DMA;
+
+	ret = (void *) __get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		memset(ret, 0, size);
+		*dma_handle = virt_to_bus(ret);
+	}
+	return ret;
+}
+static inline void pci_free_consistent(struct pci_dev *hwdev, size_t size,
+				       void *vaddr, dma_addr_t dma_handle)
+{
+	free_pages((unsigned long) vaddr, get_order(size));
+}
+
+
+#ifdef ILSIM
+extern uint pci_map_single(void *dev, void *va, uint size, int direction);
+extern void pci_unmap_single(void *dev, uint pa, uint size, int direction);
+#else
+#define pci_map_single(cookie, address, size, dir)	virt_to_bus(address)
+#define pci_unmap_single(cookie, address, size, dir)
+#endif
+
+#endif				/* DMA mapping */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43))
+
+#define dev_kfree_skb_any(a)		dev_kfree_skb(a)
+#define netif_down(dev)			do { (dev)->start = 0; } while(0)
+
+/* pcmcia-cs provides its own netdevice compatibility layer */
+#ifndef _COMPAT_NETDEVICE_H
+
+/*
+ * SoftNet
+ *
+ * For pre-softnet kernels we need to tell the upper layer not to
+ * re-enter start_xmit() while we are in there. However softnet
+ * guarantees not to enter while we are in there so there is no need
+ * to do the netif_stop_queue() dance unless the transmit queue really
+ * gets stuck. This should also improve performance according to tests
+ * done by Aman Singla.
+ */
+
+#define dev_kfree_skb_irq(a)		dev_kfree_skb(a)
+#define netif_wake_queue(dev)		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while(0)
+#define netif_stop_queue(dev)		set_bit(0, &(dev)->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy = 0;
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	(dev)->tbusy
+#define netif_running(dev)		(dev)->start
+
+#endif				/* _COMPAT_NETDEVICE_H */
+
+#define netif_device_attach(dev)	netif_start_queue(dev)
+#define netif_device_detach(dev)	netif_stop_queue(dev)
+
+/* 2.4.x renamed bottom halves to tasklets */
+#define tasklet_struct				tq_struct
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func) (unsigned long),
+				unsigned long data)
+{
+	tasklet->next = NULL;
+	tasklet->sync = 0;
+	tasklet->routine = (void (*)(void *)) func;
+	tasklet->data = (void *) data;
+}
+
+#define tasklet_kill(tasklet)			{do{} while(0);}
+
+/* 2.4.x introduced del_timer_sync() */
+#define del_timer_sync(timer) del_timer(timer)
+
+#else
+
+#define netif_down(dev)
+
+#endif				/* SoftNet */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3))
+
+/*
+ * Emit code to initialise a tq_struct's routine and data pointers
+ */
+#define PREPARE_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		(_tq)->routine = _routine;			\
+		(_tq)->data = _data;				\
+	} while (0)
+
+/*
+ * Emit code to initialise all of a tq_struct
+ */
+#define INIT_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		INIT_LIST_HEAD(&(_tq)->list);			\
+		(_tq)->sync = 0;				\
+		PREPARE_TQUEUE((_tq), (_routine), (_data));	\
+	} while (0)
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6))
+
+/* Power management related routines */
+
+static inline int pci_save_state(struct pci_dev *dev, u32 * buffer)
+{
+	int i;
+	if (buffer) {
+		/* XXX: 100% dword access ok here? */
+		for (i = 0; i < 16; i++)
+			pci_read_config_dword(dev, i * 4, &buffer[i]);
+	}
+	return 0;
+}
+
+static inline int pci_restore_state(struct pci_dev *dev, u32 * buffer)
+{
+	int i;
+
+	if (buffer) {
+		for (i = 0; i < 16; i++)
+			pci_write_config_dword(dev, i * 4, buffer[i]);
+	}
+	/*
+	 * otherwise, write the context information we know from bootup.
+	 * This works around a problem where warm-booting from Windows
+	 * combined with a D3(hot)->D0 transition causes PCI config
+	 * header data to be forgotten.
+	 */
+	else {
+		for (i = 0; i < 6; i++)
+			pci_write_config_dword(dev,
+					       PCI_BASE_ADDRESS_0 +
+					       (i * 4),
+					       pci_resource_start(dev, i));
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+	}
+	return 0;
+}
+
+#endif				/* PCI power management */
+
+/* Old cp0 access macros deprecated in 2.4.19 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19))
+#define read_c0_count() read_32bit_cp0_register(CP0_COUNT)
+#endif
+
+#endif				/* _linuxver_h_ */
diff --git a/include/asm-mips/mach-bcm5621x/osl.h b/include/asm-mips/mach-bcm5621x/osl.h
new file mode 100644
index 0000000..847f37f
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/osl.h
@@ -0,0 +1,29 @@
+/*
+ * OS Independent Layer
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _osl_h_
+#define _osl_h_
+#include <asm/mach-bcm5621x/linux_osl.h>
+
+/* handy */
+#define SET_REG(r, mask, val)   W_REG((r), ((R_REG(r) & ~(mask)) | (val)))
+
+#endif				/* _osl_h_ */
diff --git a/include/asm-mips/mach-bcm5621x/sbchipc.h b/include/asm-mips/mach-bcm5621x/sbchipc.h
new file mode 100644
index 0000000..98d8fac
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/sbchipc.h
@@ -0,0 +1,360 @@
+/*
+ * SiliconBackplane Chipcommon core hardware definitions.
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_SBCHIPC_H
+#define	_SBCHIPC_H
+
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
+#if defined(CONFIG_BCM5621X)
+
+#define	CID_ID_MASK		0x0000ffff		/* Chip Id mask */
+#define	CID_REV_MASK		0x00ff0000		/* Chip Revision mask */
+#define	CID_REV_SHIFT		16			/* Chip Revision shift */
+
+typedef volatile struct {
+	uint32	chipid;			/* FIXME (not sure if its there*/
+	uint32	capabilities;
+	uint32	PAD[6];
+
+	/* Interrupt control */
+	uint32	intstatus;		/* 0x20 */
+	uint32	PAD[15];
+
+	/* gpio - cleared only by power-on-reset */
+	uint32	gpioin;			/* 0x60 */
+	uint32	gpioout;
+	uint32	gpioouten;
+	uint32	gpiocontrol;
+	uint32	gpiointpolarity;
+	uint32	gpiointmask;
+	uint32	PAD[2];
+
+	/* Watchdog timer */
+	uint32	watchdog;		/* 0x80 */
+	uint32	PAD[3];
+
+	/* PLL control */
+	uint32	pllcontrol1;		/* 0x90 */
+	uint32	pllcontrol2;
+	uint32	pllstatus;
+	uint32	PAD[25];
+
+	/* 0x100 */
+	uint32	sbipsflag;
+	uint32	sbintvec;
+	uint32	serrconfig;
+	uint32	memcclkcontrol;
+	uint32	icsreset;
+	uint32	peripheralreset;
+	uint32	PAD[2];
+
+	/* 0x120 */
+	uint32	membist;
+	uint32	membiststatus;
+	uint32	memcbist;
+	uint32	parallelflashwaitcnt;
+	uint32	PAD[116];
+
+	/* uarts */
+	uint8	uart0data;		/* 0x300 */
+	uint8	uart0imr;
+	uint8	uart0fcr;
+	uint8	uart0lcr;
+	uint8	uart0mcr;
+	uint8	uart0lsr;
+	uint8	uart0msr;
+	uint8	uart0scratch;
+	uint8	PAD[248];		/* corerev >= 1 */
+
+	uint8	uart1data;		/* 0x400 */
+	uint8	uart1imr;
+	uint8	uart1fcr;
+	uint8	uart1lcr;
+	uint8	uart1mcr;
+	uint8	uart1lsr;
+	uint8	uart1msr;
+	uint8	uart1scratch;
+} chipcregs_t;
+#else
+typedef volatile struct {
+	uint32	chipid;			/* 0x0 */
+	uint32	capabilities;
+	uint32	corecontrol;		/* corerev >= 1 */
+	uint32	PAD[5];
+
+	/* Interrupt control */
+	uint32	intstatus;		/* 0x20 */
+	uint32	intmask;
+	uint32	PAD[6];
+
+	/* serial flash interface registers */
+	uint32	flashcontrol;		/* 0x40 */
+	uint32	flashaddress;
+	uint32	flashdata;
+	uint32	PAD[1];
+
+	/* Silicon backplane configuration broadcast control */
+	uint32	broadcastaddress;
+	uint32	broadcastdata;
+	uint32	PAD[2];
+
+	/* gpio - cleared only by power-on-reset */
+	uint32	gpioin;			/* 0x60 */
+	uint32	gpioout;
+	uint32	gpioouten;
+	uint32	gpiocontrol;
+	uint32	gpiointpolarity;
+	uint32	gpiointmask;
+	uint32	PAD[2];
+
+	/* Watchdog timer */
+	uint32	watchdog;		/* 0x80 */
+	uint32	PAD[3];
+
+	/* clock control */
+	uint32	clockcontrol_n;		/* 0x90 */
+	uint32	clockcontrol_sb;	/* aka m0 */
+	uint32	clockcontrol_pci;	/* aka m1 */
+	uint32	clockcontrol_m2;	/* mii/uart/mipsref */
+	uint32	clockcontrol_mips;	/* aka m3 */
+	uint32	uart_clkdiv;		/* corerev >= 3 */
+	uint32	PAD[2];
+
+	/* pll delay registers (corerev >= 4) */
+	uint32	pll_on_delay;		/* 0xb0 */
+	uint32	fref_sel_delay;
+	uint32	slow_clk_ctl;
+	uint32	PAD[17];
+
+	/* ExtBus control registers (corerev >= 3) */
+	uint32	cs01config;		/* 0x100 */
+	uint32	cs01memwaitcnt;
+	uint32	cs01attrwaitcnt;
+	uint32	cs01iowaitcnt;
+	uint32	cs23config;
+	uint32	cs23memwaitcnt;
+	uint32	cs23attrwaitcnt;
+	uint32	cs23iowaitcnt;
+	uint32	cs4config;
+	uint32	cs4waitcnt;
+	uint32	parallelflashconfig;
+	uint32	parallelflashwaitcnt;
+	uint32	PAD[116];
+
+	/* uarts */
+	uint8	uart0data;		/* 0x300 */
+	uint8	uart0imr;
+	uint8	uart0fcr;
+	uint8	uart0lcr;
+	uint8	uart0mcr;
+	uint8	uart0lsr;
+	uint8	uart0msr;
+	uint8	uart0scratch;
+	uint8	PAD[248];		/* corerev >= 1 */
+
+	uint8	uart1data;		/* 0x400 */
+	uint8	uart1imr;
+	uint8	uart1fcr;
+	uint8	uart1lcr;
+	uint8	uart1mcr;
+	uint8	uart1lsr;
+	uint8	uart1msr;
+	uint8	uart1scratch;
+} chipcregs_t;
+
+/* chipid */
+#define	CID_ID_MASK		0x0000ffff		/* Chip Id mask */
+#define	CID_REV_MASK		0x000f0000		/* Chip Revision mask */
+#define	CID_REV_SHIFT		16			/* Chip Revision shift */
+#define	CID_PKG_MASK		0x00f00000		/* Package Option mask */
+#define	CID_PKG_SHIFT		20			/* Package Option shift */
+#define	CID_CC_MASK		0x0f000000		/* CoreCount (corerev >= 4) */
+#define CID_CC_SHIFT		24
+
+/* capabilities */
+#define	CAP_UARTS_MASK		0x00000003		/* Number of uarts */
+#define CAP_MIPSEB		0x00000004		/* MIPS is in big-endian mode */
+#define CAP_UCLKSEL		0x00000018		/* UARTs clock select */
+#define CAP_UINTCLK		0x00000008		/* UARTs are driven by internal divided clock */
+#define CAP_UARTGPIO		0x00000020		/* UARTs own Gpio's 15:12 */
+#define CAP_EXTBUS		0x00000040		/* External bus present */
+#define	CAP_FLASH_MASK		0x00000700		/* Type of flash */
+#define	CAP_PLL_MASK		0x00038000		/* Type of PLL */
+#define CAP_PWR_CTL		0x00040000		/* Power control */
+
+/* PLL type */
+#define PLL_NONE		0x00000000
+#define PLL_TYPE1		0x00010000		/* 48Mhz base, 3 dividers */
+#define PLL_TYPE2		0x00020000		/* 48Mhz, 4 dividers */
+#define PLL_TYPE3		0x00030000		/* 25Mhz, 2 dividers */
+#define PLL_TYPE4		0x00008000		/* 48Mhz, 4 dividers */
+
+/* corecontrol */
+#define CC_UARTCLKO		0x00000001		/* Drive UART with internal clock */
+#define	CC_SE			0x00000002		/* sync clk out enable (corerev >= 3) */
+
+/* intstatus/intmask */
+#define	CI_EI			0x00000002		/* ro: ext intr pin (corerev >= 3) */
+
+/* slow_clk_ctl */
+#define SCC_SS_MASK		0x00000007		/* slow clock source mask */
+#define	SCC_SS_LPO		0x00000000		/* source of slow clock is LPO */
+#define	SCC_SS_XTAL		0x00000001		/* source of slow clock is crystal */
+#define	SCC_SS_PCI		0x00000002		/* source of slow clock is PCI */
+#define SCC_LF			0x00000200		/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define SCC_LP			0x00000400		/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
+#define SCC_FS			0x00000800		/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
+#define SCC_IP			0x00001000		/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
+#define SCC_XC			0x00002000		/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define SCC_XP			0x00004000		/* XtalPU (RO), 1/0: crystal running/disabled */
+#define SCC_CD_MASK		0xffff0000		/* ClockDivider mask, SlowClk = 1/(4+divisor) * crystal/PCI clock */
+#define SCC_CD_SHF		16			/* CLockDivider shift */
+
+/* clockcontrol_n */
+#define	CN_N1_MASK		0x3f			/* n1 control */
+#define	CN_N2_MASK		0x3f00			/* n2 control */
+#define	CN_N2_SHIFT		8
+
+/* clockcontrol_sb/pci/uart */
+#define	CC_M1_MASK		0x3f			/* m1 control */
+#define	CC_M2_MASK		0x3f00			/* m2 control */
+#define	CC_M2_SHIFT		8
+#define	CC_M3_MASK		0x3f0000		/* m3 control */
+#define	CC_M3_SHIFT		16
+#define	CC_MC_MASK		0x1f000000		/* mux control */
+#define	CC_MC_SHIFT		24
+
+/* N3M Clock control values for 125Mhz */
+#define	CC_125_N		0x0802			/* Default values for bcm4310 */
+#define	CC_125_M		0x04020009
+#define	CC_125_M25		0x11090009
+#define	CC_125_M33		0x11090005
+
+/* N3M Clock control magic field values */
+#define	CC_F6_2			0x02			/* A factor of 2 in */
+#define	CC_F6_3			0x03			/* 6-bit fields like */
+#define	CC_F6_4			0x05			/* N1, M1 or M3 */
+#define	CC_F6_5			0x09
+#define	CC_F6_6			0x11
+#define	CC_F6_7			0x21
+
+#define	CC_F5_BIAS		5			/* 5-bit fields get this added */
+
+#define	CC_MC_BYPASS		0x08
+#define	CC_MC_M1		0x04
+#define	CC_MC_M1M2		0x02
+#define	CC_MC_M1M2M3		0x01
+#define	CC_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	CC_T2_BIAS		2			/* n1, n2, m1 & m3 bias */
+#define	CC_T2M2_BIAS		3			/* m2 bias */
+
+#define	CC_T2MC_M1BYP		1
+#define	CC_T2MC_M2BYP		2
+#define	CC_T2MC_M3BYP		4
+
+/* Common clock base */
+#define	CC_CLOCK_BASE		24000000		/* Half the clock freq */
+
+/* Flash types in the chipcommon capabilities register */
+#define FLASH_NONE		0x000		/* No flash */
+#define SFLASH_ST		0x100		/* ST serial flash */
+#define SFLASH_AT		0x200		/* Atmel serial flash */
+#define	PFLASH			0x700		/* Parallel flash */
+
+/* Bits in the config registers */
+#define	CC_CFG_EN		0x0001		/* Enable */
+#define	CC_CFG_EM_MASK		0x000e		/* Extif Mode */
+#define	CC_CFG_EM_ASYNC		0x0002		/* Async/Parallel flash */
+#define	CC_CFG_EM_SYNC		0x0004		/* Synchronous */
+#define	CC_CFG_EM_PCMCIA	0x0008		/* PCMCIA */
+#define	CC_CFG_EM_IDE		0x000a		/* IDE */
+#define	CC_CFG_DS		0x0010		/* Data size, 0=8bit, 1=16bit */
+#define	CC_CFG_CD_MASK		0x0060		/* Sync: Clock divisor */
+#define	CC_CFG_CE		0x0080		/* Sync: Clock enable */
+#define	CC_CFG_SB		0x0100		/* Sync: Size/Bytestrobe */
+
+/* Start/busy bit in flashcontrol */
+#define SFLASH_START		0x80000000
+#define SFLASH_BUSY		SFLASH_START
+
+/* flashcontrol opcodes for ST flashes */
+#define SFLASH_ST_WREN		0x0006		/* Write Enable */
+#define SFLASH_ST_WRDIS		0x0004		/* Write Disable */
+#define SFLASH_ST_RDSR		0x0105		/* Read Status Register */
+#define SFLASH_ST_WRSR		0x0101		/* Write Status Register */
+#define SFLASH_ST_READ		0x0303		/* Read Data Bytes */
+#define SFLASH_ST_PP		0x0302		/* Page Program */
+#define SFLASH_ST_SE		0x02d8		/* Sector Erase */
+#define SFLASH_ST_BE		0x00c7		/* Bulk Erase */
+#define SFLASH_ST_DP		0x00b9		/* Deep Power-down */
+#define SFLASH_ST_RES		0x03ab		/* Read Electronic Signature */
+
+/* Status register bits for ST flashes */
+#define SFLASH_ST_WIP		0x01		/* Write In Progress */
+#define SFLASH_ST_WEL		0x02		/* Write Enable Latch */
+#define SFLASH_ST_BP_MASK	0x1c		/* Block Protect */
+#define SFLASH_ST_BP_SHIFT	2
+#define SFLASH_ST_SRWD		0x80		/* Status Register Write Disable */
+
+/* flashcontrol opcodes for Atmel flashes */
+#define SFLASH_AT_READ				0x07e8
+#define SFLASH_AT_PAGE_READ			0x07d2
+#define SFLASH_AT_BUF1_READ
+#define SFLASH_AT_BUF2_READ
+#define SFLASH_AT_STATUS			0x01d7
+#define SFLASH_AT_BUF1_WRITE			0x0384
+#define SFLASH_AT_BUF2_WRITE			0x0387
+#define SFLASH_AT_BUF1_ERASE_PROGRAM		0x0283
+#define SFLASH_AT_BUF2_ERASE_PROGRAM		0x0286
+#define SFLASH_AT_BUF1_PROGRAM			0x0288
+#define SFLASH_AT_BUF2_PROGRAM			0x0289
+#define SFLASH_AT_PAGE_ERASE			0x0281
+#define SFLASH_AT_BLOCK_ERASE			0x0250
+#define SFLASH_AT_BUF1_WRITE_ERASE_PROGRAM	0x0382
+#define SFLASH_AT_BUF2_WRITE_ERASE_PROGRAM	0x0385
+#define SFLASH_AT_BUF1_LOAD			0x0253
+#define SFLASH_AT_BUF2_LOAD			0x0255
+#define SFLASH_AT_BUF1_COMPARE			0x0260
+#define SFLASH_AT_BUF2_COMPARE			0x0261
+#define SFLASH_AT_BUF1_REPROGRAM		0x0258
+#define SFLASH_AT_BUF2_REPROGRAM		0x0259
+
+/* Status register bits for Atmel flashes */
+#define SFLASH_AT_READY				0x80
+#define SFLASH_AT_MISMATCH			0x40
+#define SFLASH_AT_ID_MASK			0x38
+#define SFLASH_AT_ID_SHIFT			3
+
+#endif /* CONFIG_BCM5621X */
+#endif	/* _SBCHIPC_H */
diff --git a/include/asm-mips/mach-bcm5621x/sbconfig.h b/include/asm-mips/mach-bcm5621x/sbconfig.h
new file mode 100644
index 0000000..b0a69b7
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/sbconfig.h
@@ -0,0 +1,342 @@
+/*
+ * Broadcom SiliconBackplane hardware register definitions.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_SBCONFIG_H
+#define	_SBCONFIG_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+#ifdef CONFIG_BCM5621X
+
+#define SB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define	SB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SB_ENUM_BASE		0x18000000	/* Enumeration space base */
+#define	SB_ENUM_LIM		0x18010000	/* Enumeration space limit */
+
+#define SB_CORE_SIZE		0x1000		/* each core gets 4Kbytes for registers */
+#define	SB_MAXCORES		((SB_ENUM_LIM - SB_ENUM_BASE)/SB_CORE_SIZE)
+
+/* IRQ defines */
+#define SBIPS_INT_UART0		0
+#define SBIPS_INT_UART1		1
+#define SBIPS_INT_CMIC		2
+#define SBIPS_INT_GPIO		3
+
+#define	SBIPS_INT1_MASK		0x3f		/* which sbflags get routed to mips interrupt 1 */
+#define	SBIPS_INT1_SHIFT	0
+#define	SBIPS_INT2_MASK		0x3f00		/* which sbflags get routed to mips interrupt 2 */
+#define	SBIPS_INT2_SHIFT	8
+#define	SBIPS_INT3_MASK		0x3f0000	/* which sbflags get routed to mips interrupt 3 */
+#define	SBIPS_INT3_SHIFT	16
+#define	SBIPS_INT4_MASK		0x3f000000	/* which sbflags get routed to mips interrupt 4 */
+#define	SBIPS_INT4_SHIFT	24
+
+/* sbtpsflag */
+#define	SBTPS_NUM0_MASK		0x3f		/* interrupt sbFlag # generated by this core */
+#define	SBTPS_F0EN0		0x40		/* interrupt is always sent on the backplane */
+
+/* mips address */
+#define	SB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+#define	SB_CC			0x800		/* chipcommon core */
+#define	SB_MIPS			0x805		/* mips core */
+#define	SB_MEMC			0x80f		/* memc sdram core */
+
+#else
+
+/*
+ * SiliconBackplane Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SB_PCI_MEM		0x08000000	/* Host Mode PCI memory access space (64 MB) */
+#define SB_PCI_CFG		0x0c000000	/* Host Mode PCI configuration space (64 MB) */
+#define	SB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SB_ENUM_BASE		0x18000000	/* Enumeration space base */
+#define	SB_ENUM_LIM		0x18010000	/* Enumeration space limit */
+#define	SB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
+#define SB_PCI_DMA		0x40000000	/* Client Mode PCI memory access space (1 GB) */
+#define	SB_EUART		(SB_EXTIF_BASE + 0x00800000)
+#define	SB_LED			(SB_EXTIF_BASE + 0x00900000)
+
+/* enumeration space related defs */
+#define SB_CORE_SIZE		0x1000		/* each core gets 4Kbytes for registers */
+#define	SB_MAXCORES		((SB_ENUM_LIM - SB_ENUM_BASE)/SB_CORE_SIZE)
+#define	SBCONFIGOFF		0xf00		/* core sbconfig regs are top 256bytes of regs */
+#define	SBCONFIGSIZE		256		/* sizeof (sbconfig_t) */
+
+/* mips address */
+#define	SB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+/*
+ * Sonics Configuration Space Registers.
+ */
+#ifdef _LANGUAGE_ASSEMBLY
+
+#define SBIPSFLAG		0x08
+#define SBTPSFLAG		0x18
+#define	SBTMERRLOGA		0x48		/* sonics >= 2.3 */
+#define	SBTMERRLOG		0x50		/* sonics >= 2.3 */
+#define SBADMATCH3		0x60
+#define SBADMATCH2		0x68
+#define SBADMATCH1		0x70
+#define SBIMSTATE		0x90
+#define SBINTVEC		0x94
+#define SBTMSTATELOW		0x98
+#define SBTMSTATEHIGH		0x9c
+#define SBBWA0			0xa0
+#define SBIMCONFIGLOW		0xa8
+#define SBIMCONFIGHIGH		0xac
+#define SBADMATCH0		0xb0
+#define SBTMCONFIGLOW		0xb8
+#define SBTMCONFIGHIGH		0xbc
+#define SBBCONFIG		0xc0
+#define SBBSTATE		0xc8
+#define SBACTCNFG		0xd8
+#define	SBFLAGST		0xe8
+#define SBIDLOW			0xf8
+#define SBIDHIGH		0xfc
+
+
+#else
+
+typedef volatile struct _sbconfig {
+	uint32	PAD[2];
+	uint32	sbipsflag;		/* initiator port ocp slave flag */
+	uint32	PAD[3];
+	uint32	sbtpsflag;		/* target port ocp slave flag */
+	uint32	PAD[11];
+	uint32	sbtmerrloga;		/* (sonics >= 2.3) */
+	uint32	PAD;
+	uint32	sbtmerrlog;		/* (sonics >= 2.3) */
+	uint32	PAD[3];
+	uint32	sbadmatch3;		/* address match3 */
+	uint32	PAD;
+	uint32	sbadmatch2;		/* address match2 */
+	uint32	PAD;
+	uint32	sbadmatch1;		/* address match1 */
+	uint32	PAD[7];
+	uint32	sbimstate;		/* initiator agent state */
+	uint32	sbintvec;		/* interrupt mask */
+	uint32	sbtmstatelow;		/* target state */
+	uint32	sbtmstatehigh;		/* target state */
+	uint32	sbbwa0;			/* bandwidth allocation table0 */
+	uint32	PAD;
+	uint32	sbimconfiglow;		/* initiator configuration */
+	uint32	sbimconfighigh;		/* initiator configuration */
+	uint32	sbadmatch0;		/* address match0 */
+	uint32	PAD;
+	uint32	sbtmconfiglow;		/* target configuration */
+	uint32	sbtmconfighigh;		/* target configuration */
+	uint32	sbbconfig;		/* broadcast configuration */
+	uint32	PAD;
+	uint32	sbbstate;		/* broadcast state */
+	uint32	PAD[3];
+	uint32	sbactcnfg;		/* activate configuration */
+	uint32	PAD[3];
+	uint32	sbflagst;		/* current sbflags */
+	uint32	PAD[3];
+	uint32	sbidlow;		/* identification */
+	uint32	sbidhigh;		/* identification */
+} sbconfig_t;
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/* sbipsflag */
+#define	SBIPS_INT1_MASK		0x3f		/* which sbflags get routed to mips interrupt 1 */
+#define	SBIPS_INT1_SHIFT	0
+#define	SBIPS_INT2_MASK		0x3f00		/* which sbflags get routed to mips interrupt 2 */
+#define	SBIPS_INT2_SHIFT	8
+#define	SBIPS_INT3_MASK		0x3f0000	/* which sbflags get routed to mips interrupt 3 */
+#define	SBIPS_INT3_SHIFT	16
+#define	SBIPS_INT4_MASK		0x3f000000	/* which sbflags get routed to mips interrupt 4 */
+#define	SBIPS_INT4_SHIFT	24
+
+/* sbtpsflag */
+#define	SBTPS_NUM0_MASK		0x3f		/* interrupt sbFlag # generated by this core */
+#define	SBTPS_F0EN0		0x40		/* interrupt is always sent on the backplane */
+
+/* sbtmerrlog */
+#define	SBTMEL_CM		0x00000007	/* command */
+#define	SBTMEL_CI		0x0000ff00	/* connection id */
+#define	SBTMEL_EC		0x0f000000	/* error code */
+#define	SBTMEL_ME		0x80000000	/* multiple error */
+
+/* sbimstate */
+#define	SBIM_PC			0xf		/* pipecount */
+#define	SBIM_AP_MASK		0x30		/* arbitration policy */
+#define	SBIM_AP_BOTH		0x00		/* use both timeslaces and token */
+#define	SBIM_AP_TS		0x10		/* use timesliaces only */
+#define	SBIM_AP_TK		0x20		/* use token only */
+#define	SBIM_AP_RSV		0x30		/* reserved */
+#define	SBIM_IBE		0x20000		/* inbanderror */
+#define	SBIM_TO			0x40000		/* timeout */
+#define	SBIM_BY			0x01800000	/* busy (sonics >= 2.3) */
+#define	SBIM_RJ			0x02000000	/* reject (sonics >= 2.3) */
+
+/* sbtmstatelow */
+#define	SBTML_RESET		0x1		/* reset */
+#define	SBTML_REJ		0x2		/* reject */
+#define	SBTML_CLK		0x10000		/* clock enable */
+#define	SBTML_FGC		0x20000		/* force gated clocks on */
+#define	SBTML_FL_MASK		0x3ffc0000	/* core-specific flags */
+#define	SBTML_PE		0x40000000	/* pme enable */
+#define	SBTML_BE		0x80000000	/* bist enable */
+
+/* sbtmstatehigh */
+#define	SBTMH_SERR		0x1		/* serror */
+#define	SBTMH_INT		0x2		/* interrupt */
+#define	SBTMH_BUSY		0x4		/* busy */
+#define	SBTMH_TO		0x00000020	/* timeout (sonics >= 2.3) */
+#define	SBTMH_FL_MASK		0x1fff0000	/* core-specific flags */
+#define	SBTMH_GCR		0x20000000	/* gated clock request */
+#define	SBTMH_BISTF		0x40000000	/* bist failed */
+#define	SBTMH_BISTD		0x80000000	/* bist done */
+
+/* sbbwa0 */
+#define	SBBWA_TAB0_MASK		0xffff		/* lookup table 0 */
+#define	SBBWA_TAB1_MASK		0xffff		/* lookup table 1 */
+#define	SBBWA_TAB1_SHIFT	16
+
+/* sbimconfiglow */
+#define	SBIMCL_STO_MASK		0x7		/* service timeout */
+#define	SBIMCL_RTO_MASK		0x70		/* request timeout */
+#define	SBIMCL_RTO_SHIFT	4
+#define	SBIMCL_CID_MASK		0xff0000	/* connection id */
+#define	SBIMCL_CID_SHIFT	16
+
+/* sbimconfighigh */
+#define	SBIMCH_IEM_MASK		0xc		/* inband error mode */
+#define	SBIMCH_TEM_MASK		0x30		/* timeout error mode */
+#define	SBIMCH_TEM_SHIFT	4
+#define	SBIMCH_BEM_MASK		0xc0		/* bus error mode */
+#define	SBIMCH_BEM_SHIFT	6
+
+/* sbadmatch0 */
+#define	SBAM_TYPE_MASK		0x3		/* address type */
+#define	SBAM_AD64		0x4		/* reserved */
+#define	SBAM_ADINT0_MASK	0xf8		/* type0 size */
+#define	SBAM_ADINT0_SHIFT	3
+#define	SBAM_ADINT1_MASK	0x1f8		/* type1 size */
+#define	SBAM_ADINT1_SHIFT	3
+#define	SBAM_ADINT2_MASK	0x1f8		/* type2 size */
+#define	SBAM_ADINT2_SHIFT	3
+#define	SBAM_ADEN		0x400		/* enable */
+#define	SBAM_ADNEG		0x800		/* negative decode */
+#define	SBAM_BASE0_MASK		0xffffff00	/* type0 base address */
+#define	SBAM_BASE0_SHIFT	8
+#define	SBAM_BASE1_MASK		0xfffff000	/* type1 base address for the core */
+#define	SBAM_BASE1_SHIFT	12
+#define	SBAM_BASE2_MASK		0xffff0000	/* type2 base address for the core */
+#define	SBAM_BASE2_SHIFT	16
+
+/* sbtmconfiglow */
+#define	SBTMCL_CD_MASK		0xff		/* clock divide */
+#define	SBTMCL_CO_MASK		0xf800		/* clock offset */
+#define	SBTMCL_CO_SHIFT		11
+#define	SBTMCL_IF_MASK		0xfc0000	/* interrupt flags */
+#define	SBTMCL_IF_SHIFT		18
+#define	SBTMCL_IM_MASK		0x3000000	/* interrupt mode */
+#define	SBTMCL_IM_SHIFT		24
+
+/* sbtmconfighigh */
+#define	SBTMCH_BM_MASK		0x3		/* busy mode */
+#define	SBTMCH_RM_MASK		0x3		/* retry mode */
+#define	SBTMCH_RM_SHIFT		2
+#define	SBTMCH_SM_MASK		0x30		/* stop mode */
+#define	SBTMCH_SM_SHIFT		4
+#define	SBTMCH_EM_MASK		0x300		/* sb error mode */
+#define	SBTMCH_EM_SHIFT		8
+#define	SBTMCH_IM_MASK		0xc00		/* int mode */
+#define	SBTMCH_IM_SHIFT		10
+
+/* sbbconfig */
+#define	SBBC_LAT_MASK		0x3		/* sb latency */
+#define	SBBC_MAX0_MASK		0xf0000		/* maxccntr0 */
+#define	SBBC_MAX0_SHIFT		16
+#define	SBBC_MAX1_MASK		0xf00000	/* maxccntr1 */
+#define	SBBC_MAX1_SHIFT		20
+
+/* sbbstate */
+#define	SBBS_SRD		0x1		/* st reg disable */
+#define	SBBS_HRD		0x2		/* hold reg disable */
+
+/* sbidlow */
+#define	SBIDL_CS_MASK		0x3		/* config space */
+#define	SBIDL_AR_MASK		0x38		/* # address ranges supported */
+#define	SBIDL_AR_SHIFT		3
+#define	SBIDL_SYNCH		0x40		/* sync */
+#define	SBIDL_INIT		0x80		/* initiator */
+#define	SBIDL_MINLAT_MASK	0xf00		/* minimum backplane latency */
+#define	SBIDL_MINLAT_SHIFT	8
+#define	SBIDL_MAXLAT		0xf000		/* maximum backplane latency */
+#define	SBIDL_MAXLAT_SHIFT	12
+#define	SBIDL_FIRST		0x10000		/* this initiator is first */
+#define	SBIDL_CW_MASK		0xc0000		/* cycle counter width */
+#define	SBIDL_CW_SHIFT		18
+#define	SBIDL_TP_MASK		0xf00000	/* target ports */
+#define	SBIDL_TP_SHIFT		20
+#define	SBIDL_IP_MASK		0xf000000	/* initiator ports */
+#define	SBIDL_IP_SHIFT		24
+#define	SBIDL_RV_MASK		0xf0000000	/* sonics backplane revision code */
+#define	SBIDL_RV_SHIFT		28
+
+/* sbidhigh */
+#define	SBIDH_RC_MASK		0xf		/* revision code*/
+#define	SBIDH_CC_MASK		0xfff0		/* core code */
+#define	SBIDH_CC_SHIFT		4
+#define	SBIDH_VC_MASK		0xffff0000	/* vendor code */
+#define	SBIDH_VC_SHIFT		16
+
+#define	SB_COMMIT		0xfd8		/* update buffered registers value */
+
+/* vendor codes */
+#define	SB_VEND_BCM		0x4243		/* Broadcom's SB vendor code */
+
+/* core codes */
+#define	SB_CC			0x800		/* chipcommon core */
+#define	SB_ILINE20		0x801		/* iline20 core */
+#define	SB_SDRAM		0x803		/* sdram core */
+#define	SB_PCI			0x804		/* pci core */
+#define	SB_MIPS			0x805		/* mips core */
+#define	SB_ENET			0x806		/* enet mac core */
+#define	SB_CODEC		0x807		/* v90 codec core */
+#define	SB_USB			0x808		/* usb 1.1 host/device core */
+#define	SB_ILINE100		0x80a		/* iline100 core */
+#define	SB_IPSEC		0x80b		/* ipsec core */
+#define	SB_PCMCIA		0x80d		/* pcmcia core */
+#define	SB_MEMC			0x80f		/* memc sdram core */
+#define	SB_EXTIF		0x811		/* external interface core */
+#define	SB_D11			0x812		/* 802.11 MAC core */
+#define	SB_MIPS33		0x816		/* mips3302 core */
+#define	SB_USB11H		0x817		/* usb 1.1 host core */
+#define	SB_USB11D		0x818		/* usb 1.1 device core */
+#define	SB_USB20H		0x819		/* usb 2.0 host core */
+#define	SB_USB20D		0x81A		/* usb 2.0 device core */
+#define	SB_SDIOH		0x81B		/* sdio host core */
+
+#endif /* CONFIG_BCM5621X */
+#endif	/* _SBCONFIG_H */
diff --git a/include/asm-mips/mach-bcm5621x/sbmemc.h b/include/asm-mips/mach-bcm5621x/sbmemc.h
new file mode 100644
index 0000000..c6d61a5
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/sbmemc.h
@@ -0,0 +1,152 @@
+/*
+ * BCM47XX Sonics SiliconBackplane DDR/SDRAM controller core hardware definitions.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_SBMEMC_H
+#define	_SBMEMC_H
+
+#ifdef _LANGUAGE_ASSEMBLY
+
+#define	MEMC_CONTROL		0x00
+#define	MEMC_CONFIG		0x04
+#define	MEMC_REFRESH		0x08
+#define	MEMC_BISTSTAT		0x0c
+#define	MEMC_MODEBUF		0x10
+#define	MEMC_BKCLS		0x14
+#define	MEMC_PRIORINV		0x18
+#define	MEMC_DRAMTIM		0x1c
+#define	MEMC_INTSTAT		0x20
+#define	MEMC_INTMASK		0x24
+#define	MEMC_INTINFO		0x28
+#define	MEMC_NCDLCTL		0x30
+#define	MEMC_RDNCDLCOR		0x34
+#define	MEMC_WRNCDLCOR		0x38
+#define	MEMC_MISCDLYCTL		0x3c
+#define	MEMC_DQSGATENCDL	0x40
+#define	MEMC_SPARE		0x44
+#define	MEMC_TPADDR		0x48
+#define	MEMC_TPDATA		0x4c
+#define	MEMC_BARRIER		0x50
+#define	MEMC_CORE		0x54
+
+
+#else
+
+/* Sonics side: MEMC core registers */
+typedef volatile struct sbmemcregs {
+	uint32	control;
+	uint32	config;
+	uint32	refresh;
+	uint32	biststat;
+	uint32	modebuf;
+	uint32	bkcls;
+	uint32	priorinv;
+	uint32	dramtim;
+	uint32	intstat;
+	uint32	intmask;
+	uint32	intinfo;
+	uint32	reserved1;
+	uint32	ncdlctl;
+	uint32	rdncdlcor;
+	uint32	wrncdlcor;
+	uint32	miscdlyctl;
+	uint32	dqsgatencdl;
+	uint32	spare;
+	uint32	tpaddr;
+	uint32	tpdata;
+	uint32	barrier;
+	uint32	core;
+} sbmemcregs_t;
+
+#endif
+
+/* MEMC Core Init values (OCP ID 0x80f) */
+
+/* For SDR: */
+#define MEMC_SD_CONFIG_INIT	0x00048000
+#define MEMC_SD_DRAMTIM_INIT	0x000754da
+#define MEMC_SD_RDNCDLCOR_INIT	0x00000000
+#define MEMC_SD_WRNCDLCOR_INIT	0x49351200
+#define MEMC_SD1_WRNCDLCOR_INIT	0x14500200	/* For corerev 1 (4712) */
+#define MEMC_SD_MISCDLYCTL_INIT	0x00061c1b
+#define MEMC_SD1_MISCDLYCTL_INIT 0x00021416	/* For corerev 1 (4712) */
+#define MEMC_SD_CONTROL_INIT0	0x00000002
+#define MEMC_SD_CONTROL_INIT1	0x00000008
+#define MEMC_SD_CONTROL_INIT2	0x00000004
+#define MEMC_SD_CONTROL_INIT3	0x00000010
+#define MEMC_SD_CONTROL_INIT4	0x00000001
+#define MEMC_SD_MODEBUF_INIT	0x00000000
+#define MEMC_SD_REFRESH_INIT	0x0000840f
+
+
+/* This is for SDRM8X8X4 */
+#define	MEMC_SDR_INIT		0x0008
+#define	MEMC_SDR_MODE		0x32
+#define	MEMC_SDR_NCDL		0x00020032
+#define	MEMC_SDR1_NCDL		0x0002020f	/* For corerev 1 (4712) */
+
+/* For DDR: */
+#define MEMC_CONFIG_INIT	0x00048000
+#define MEMC_DRAMTIM_INIT	0x000754d9
+#define MEMC_RDNCDLCOR_INIT	0x00000000
+#define MEMC_WRNCDLCOR_INIT	0x49351200
+#define MEMC_1_WRNCDLCOR_INIT	0x14500200
+#define MEMC_DQSGATENCDL_INIT	0x00030000
+#define MEMC_MISCDLYCTL_INIT	0x21061c1b
+#define MEMC_1_MISCDLYCTL_INIT	0x21021400
+#define MEMC_NCDLCTL_INIT	0x00002001
+#define MEMC_CONTROL_INIT0	0x00000002
+#define MEMC_CONTROL_INIT1	0x00000008
+#define MEMC_MODEBUF_INIT0	0x00004000
+#define MEMC_CONTROL_INIT2	0x00000010
+#define MEMC_MODEBUF_INIT1	0x00000100
+#define MEMC_CONTROL_INIT3	0x00000010
+#define MEMC_CONTROL_INIT4	0x00000008
+#define MEMC_REFRESH_INIT	0x0000840f
+#define MEMC_CONTROL_INIT5	0x00000004
+#define MEMC_MODEBUF_INIT2	0x00000000
+#define MEMC_CONTROL_INIT6	0x00000010
+#define MEMC_CONTROL_INIT7	0x00000001
+
+
+/* This is for DDRM16X16X2 */
+#define	MEMC_DDR_INIT		0x0009
+#define	MEMC_DDR_MODE		0x62
+#define	MEMC_DDR_NCDL		0x0005050a
+#define	MEMC_DDR1_NCDL		0x00000a0a	/* For corerev 1 (4712) */
+
+/* mask for SDR/DDR calibration registers */
+#define MEMC_RDNCDLCOR_RD_MASK	0x000000ff
+#define MEMC_WRNCDLCOR_WR_MASK	0x000000ff
+#define MEMC_DQSGATENCDL_G_MASK	0x000000ff
+
+/* masks for MiscDlyCtl registers */
+#define MEMC_MISC_SM_MASK	0x30000000
+#define MEMC_MISC_SM_SHIFT	28
+#define MEMC_MISC_SD_MASK	0x0f000000
+#define MEMC_MISC_SD_SHIFT	24
+
+/* hw threshhold for calculating wr/rd for SDR MEMC */
+#define MEMC_CD_THRESHOLD	128
+
+/* Low bit of init register says if MEMC is DDR or SDR */
+#define MEMC_CONFIG_DDR		0x00000001
+
+#endif	/* _SBMEMC_H */
diff --git a/include/asm-mips/mach-bcm5621x/sbmips.h b/include/asm-mips/mach-bcm5621x/sbmips.h
new file mode 100644
index 0000000..d387759
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/sbmips.h
@@ -0,0 +1,68 @@
+/*
+ * Broadcom SiliconBackplane MIPS definitions
+ *
+ * SB MIPS cores are custom MIPS32 processors with SiliconBackplane
+ * OCP interfaces. The CP0 processor ID is 0x00024000, where bits
+ * 23:16 mean Broadcom and bits 15:8 mean a MIPS core with an OCP
+ * interface. The core revision is stored in the SB ID register in SB
+ * configuration space.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * $Id: bcm95836_inc.diff,v 1.1 2007/08/23 15:04:22 rlarocqu Exp $
+ */
+
+#ifndef	_SBMIPS_H
+#define	_SBMIPS_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
+typedef volatile struct {
+	uint32	corecontrol;
+	uint32	PAD[2];
+	uint32	biststatus;
+	uint32	PAD[4];
+	uint32	intstatus;
+	uint32	intmask;
+	uint32	timer;
+} mipsregs_t;
+
+extern uint32 sb_flag(void *sbh);
+#ifdef CONFIG_BCM5621X
+extern uint sb_irq(void *sbh, uint irq_src_id);
+#else
+extern uint sb_irq(void *sbh);
+#endif
+
+extern void sb_serial_init(void *sbh, void (*add)(void *regs, uint irq, uint baud_base, uint reg_shift));
+
+extern void sb_mips_init(void *sbh);
+extern uint32 sb_mips_clock(void *sbh);
+extern bool sb_mips_setclock(void *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock);
+
+extern uint32 sb_memc_get_ncdl(void *sbh);
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif	/* _SBMIPS_H */
diff --git a/include/asm-mips/mach-bcm5621x/sbutils.h b/include/asm-mips/mach-bcm5621x/sbutils.h
new file mode 100644
index 0000000..94b928b
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/sbutils.h
@@ -0,0 +1,97 @@
+/*
+ * Misc utility routines for accessing chip-specific features
+ * of Broadcom HNBU SiliconBackplane-based chips.
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef	_sbutils_h_
+#define	_sbutils_h_
+
+/* Board styles (bustype) */
+#define	BOARDSTYLE_SOC		0		/* Silicon Backplane */
+#define	BOARDSTYLE_PCI		1		/* PCI/MiniPCI board */
+#define	BOARDSTYLE_PCMCIA	2		/* PCMCIA board */
+#define	BOARDSTYLE_CARDBUS	3		/* Cardbus board */
+
+/*
+ * Many of the routines below take an 'sbh' handle as their first arg.
+ * Allocate this by calling sb_attach().  Free it by calling sb_detach().
+ * At any one time, the sbh is logically focused on one particular sb core
+ * (the "current core").
+ * Use sb_setcore() or sb_setcoreidx() to change the association to another core.
+ */
+
+/* exported externs */
+extern void *sb_attach(uint pcidev, void *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
+extern void *sb_kattach(void);
+extern void sb_detach(void *sbh);
+extern uint sb_chip(void *sbh);
+extern uint sb_chiprev(void *sbh);
+extern uint sb_chippkg(void *sbh);
+extern uint sb_boardvendor(void *sbh);
+extern uint sb_boardtype(void *sbh);
+extern uint sb_boardstyle(void *sbh);
+extern uint sb_bus(void *sbh);
+extern uint sb_corelist(void *sbh, uint coreid[]);
+extern uint sb_coreid(void *sbh);
+extern uint sb_coreidx(void *sbh);
+extern uint sb_coreunit(void *sbh);
+extern uint sb_corevendor(void *sbh);
+extern uint sb_corerev(void *sbh);
+extern void *sb_coreregs(void *sbh);
+extern uint32 sb_coreflags(void *sbh, uint32 mask, uint32 val);
+extern uint32 sb_coreflagshi(void *sbh, uint32 mask, uint32 val);
+extern bool sb_iscoreup(void *sbh);
+extern void *sb_setcoreidx(void *sbh, uint coreidx);
+extern void *sb_setcore(void *sbh, uint coreid, uint coreunit);
+extern void sb_commit(void *sbh);
+extern uint32 sb_base(uint32 admatch);
+extern uint32 sb_size(uint32 admatch);
+extern void sb_core_reset(void *sbh, uint32 bits);
+extern void sb_core_tofixup(void *sbh);
+extern void sb_core_disable(void *sbh, uint32 bits);
+extern uint32 sb_clock_rate(uint32 pll_type, uint32 n, uint32 m);
+extern uint32 sb_clock(void *sbh);
+extern void sb_pci_setup(void *sbh, uint32 *dmaoffset, uint coremask);
+extern void sb_pcmcia_init(void *sbh);
+extern void sb_watchdog(void *sbh, uint ticks);
+extern void *sb_gpiosetcore(void *sbh);
+extern uint32 sb_gpiocontrol(void *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpioouten(void *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpioout(void *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpioin(void *sbh);
+extern uint32 sb_gpiointpolarity(void *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpiointmask(void *sbh, uint32 mask, uint32 val);
+extern bool sb_taclear(void *sbh);
+extern void sb_pwrctl_init(void *sbh);
+extern uint16 sb_pwrctl_fast_pwrup_delay(void *sbh);
+extern bool sb_pwrctl_clk(void *sbh, uint mode);
+extern int sb_pwrctl_xtal(void *sbh, uint what, bool on);
+extern void sb_register_intr_callback(void *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intr_arg);
+
+/* pwrctl xtal what flags */
+#define	XTAL		0x1			/* primary crystal oscillator (2050) */
+#define	PLL		0x2			/* main chip pll */
+
+/* pwrctl clk mode */
+#define	CLK_FAST	0			/* force fast (pll) clock */
+#define	CLK_SLOW	1			/* force slow clock */
+#define	CLK_DYNAMIC	2			/* enable dynamic power control */
+
+#endif	/* _sbutils_h_ */
diff --git a/include/asm-mips/mach-bcm5621x/typedefs.h b/include/asm-mips/mach-bcm5621x/typedefs.h
new file mode 100644
index 0000000..30ecf38
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/typedefs.h
@@ -0,0 +1,170 @@
+/*
+ *
+ * Copyright (C) 2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+/*----------------------- define TRUE, FALSE, NULL, bool ----------------*/
+#ifdef __cplusplus
+
+#ifndef FALSE
+#define FALSE	false
+#endif
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#else /* !__cplusplus */
+
+#if defined(_WIN32)
+
+/* typedef	unsigned char	bool; */
+
+#else
+
+#if defined(MACOSX) && defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#else
+/* typedef	int	bool; */
+#endif
+
+#endif
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+#ifndef TRUE
+#define TRUE	1
+
+#ifndef NULL
+#define	NULL 0
+#endif
+
+#endif
+
+#endif /* __cplusplus */
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+
+/*----------------------- define uchar, ushort, uint, ulong ----------------*/
+
+typedef unsigned char uchar;
+
+#if defined(_WIN32) || defined(PMON) || defined(__MRC__) || defined(V2_HAL) || defined(_CFE_)
+
+#ifndef V2_HAL
+typedef unsigned short	ushort;
+#endif
+
+typedef unsigned int	uint;
+typedef unsigned long	ulong;
+
+#else
+
+/* pick up ushort & uint from standard types.h */
+#if defined(linux) && defined(__KERNEL__)
+#include <linux/types.h>	/* sys/types.h and linux/types.h are oil and water */
+#else
+#include <sys/types.h>
+#if !defined(TARGETENV_sun4) && !defined(linux)
+typedef unsigned long	ulong;
+#endif /* TARGETENV_sun4 */
+#endif
+#if defined(PMON)
+typedef unsigned int	uint;
+typedef unsigned long long       uint64;
+#endif
+
+#endif /* WIN32 || PMON || .. */
+
+/*----------------------- define [u]int8/16/32/64 --------------------------*/
+
+
+#ifdef V2_HAL
+#include <bcmos.h>
+#else
+typedef signed char	int8;
+typedef signed short	int16;
+typedef signed int	int32;
+
+typedef unsigned char	uint8;
+typedef unsigned short	uint16;
+typedef unsigned int	uint32;
+#endif	/* V2_HAL */
+
+typedef float		float32;
+typedef double		float64;
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else /* default to double precision floating point */
+typedef float64 float_t;
+#endif /* FLOAT32 */
+
+#ifdef _MSC_VER	    /* Microsoft C */
+typedef signed __int64	int64;
+typedef unsigned __int64 uint64;
+
+#elif defined(__GNUC__) && !defined(__STRICT_ANSI__)
+/* gcc understands signed/unsigned 64 bit types, but complains in ANSI mode */
+typedef signed long long int64;
+typedef unsigned long long uint64;
+
+#elif defined(__ICL) && !defined(__STDC__)
+/* ICL accepts unsigned 64 bit type only, and complains in ANSI mode */
+typedef unsigned long long uint64;
+
+#endif /* _MSC_VER */
+
+
+/*----------------------- define PTRSZ, INLINE --------------------------*/
+
+#define	PTRSZ	sizeof (char*)
+
+#ifndef INLINE
+
+#ifdef _MSC_VER
+
+#define INLINE __inline
+
+#elif __GNUC__
+
+#define INLINE __inline__
+
+#else
+
+#define INLINE
+
+#endif /* _MSC_VER */
+
+#endif /* INLINE */
+
+#endif /* _TYPEDEFS_H_ */
diff --git a/include/asm-mips/mach-bcm5621x/war.h b/include/asm-mips/mach-bcm5621x/war.h
new file mode 100644
index 0000000..4a2b798
--- /dev/null
+++ b/include/asm-mips/mach-bcm5621x/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_BCM947XX_WAR_H
+#define __ASM_MIPS_MACH_BCM947XX_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_BCM947XX_WAR_H */
-- 
1.6.5.2

