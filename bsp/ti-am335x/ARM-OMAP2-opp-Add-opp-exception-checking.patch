From 5546c69e01516fd89512eeb24b86d93c4b502c58 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Tue, 10 Nov 2015 14:26:22 -0600
Subject: [PATCH 664/800] ARM: OMAP2+: opp: Add opp exception checking

Add a device properties, ti,opp-enable-exception and
ti,opp-disable-exception that allow selective enabling and disabling of
OPPs on a per board basis. This patch adds the support code to parse the
properties and either enable or disable registered OPPs based on the
frequencies provided.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Reviewed-by: Nishanth Menon <nm@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/opp.c |   68 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 68 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/opp.c b/arch/arm/mach-omap2/opp.c
index 79da30f..0a2f3ea 100644
--- a/arch/arm/mach-omap2/opp.c
+++ b/arch/arm/mach-omap2/opp.c
@@ -88,6 +88,70 @@ int __init opp_def_list_update_opp_voltage(struct omap_opp_def *list,
 	return -EINVAL;
 }
 
+static int __init of_omap_set_opp_exceptions(struct omap_opp_def *list,
+					     unsigned int size,
+					     const char *hwmod_name,
+					     struct device_node *np,
+					     const char *of_prop_name,
+					     unsigned long freq,
+					     bool state)
+{
+	const __be32 *val;
+	const struct property *prop;
+	int nr;
+
+	prop = of_find_property(np, of_prop_name, NULL);
+	if (!prop)
+		return -ENODEV;
+	if (!prop->value)
+		return -ENODATA;
+
+	/*
+	 * Each OPP is a a single frequency value in kHz.
+	 */
+	nr = prop->length / sizeof(u32);
+
+	val = prop->value;
+	while (nr) {
+		unsigned long exception_freq = be32_to_cpup(val++) * 1000;
+
+		if (exception_freq == freq) {
+			if (opp_def_list_enable_opp(list, size, hwmod_name,
+						    freq, state))
+				return -EINVAL;
+			else
+				return 0;
+		}
+		nr--;
+	}
+
+	return 0;
+}
+
+static int __init of_omap_check_opp_exceptions(struct device *dev,
+					       struct omap_opp_def *list,
+					       unsigned int size,
+					       const char *hwmod_name,
+					       unsigned long freq)
+
+{
+	struct device_node *np;
+
+	np = of_node_get(dev->of_node);
+	if (!np)
+		return  -ENOENT;
+
+	of_omap_set_opp_exceptions(list, size, hwmod_name, np,
+				   "ti,opp-enable-exception",
+				   freq, true);
+
+	of_omap_set_opp_exceptions(list, size, hwmod_name, np,
+				   "ti,opp-disable-exception",
+				   freq, false);
+
+	of_node_put(np);
+	return 0;
+}
 /**
  * omap_init_opp_table() - Initialize opp table as per the CPU type
  * @opp_def:		opp default list for this silicon
@@ -142,6 +206,10 @@ int __init omap_init_opp_table(struct omap_opp_def *opp_def,
 			dev = &oh->od->pdev->dev;
 		}
 
+		of_omap_check_opp_exceptions(dev, opp_def, opp_def_size,
+					     opp_def->hwmod_name,
+					     opp_def->freq);
+
 		r = dev_pm_opp_add(dev, opp_def->freq, opp_def->u_volt);
 		if (r) {
 			dev_err(dev, "%s: add OPP %ld failed for %s [%d] result=%d\n",
-- 
1.7.5.4

