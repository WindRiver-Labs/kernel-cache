From 749a4d3753ec774fb9dc62c517ce8aa5401899d0 Mon Sep 17 00:00:00 2001
From: Kishon Vijay Abraham I <kishon@ti.com>
Date: Thu, 27 Aug 2015 14:43:57 +0530
Subject: [PATCH 339/800] mmc: host: omap_hsmmc: use mmc_host's vmmc and vqmmc

commit aa9a68014bb6c6e1052d79561815885b797d15ea upstream

No functional change. Instead of using omap_hsmmc_host's vcc and vcc_aux
members, use vmmc and vqmmc present in mmc_host which is present
for the same purpose.

Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
Reviewed-by: Roger Quadros <rogerq@ti.com>
Tested-by: Tony Lindgren <tony@atomide.com>
Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
---
 drivers/mmc/host/omap_hsmmc.c |   65 ++++++++++++++++++----------------------
 1 files changed, 29 insertions(+), 36 deletions(-)

diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 07b0df5..6289349 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -181,15 +181,6 @@ struct omap_hsmmc_host {
 	struct	mmc_data	*data;
 	struct	clk		*fclk;
 	struct	clk		*dbclk;
-	/*
-	 * vcc == configured supply
-	 * vcc_aux == optional
-	 *   -	MMC1, supply for DAT4..DAT7
-	 *   -	MMC2/MMC2, external level shifter voltage supply, for
-	 *	chip (SDIO, eMMC, etc) or transceiver (MMC2 only)
-	 */
-	struct	regulator	*vcc;
-	struct	regulator	*vcc_aux;
 	struct	regulator	*pbias;
 	bool			pbias_enabled;
 	void	__iomem		*base;
@@ -266,13 +257,14 @@ static int omap_hsmmc_set_power(struct device *dev, int power_on, int vdd)
 {
 	struct omap_hsmmc_host *host =
 		platform_get_drvdata(to_platform_device(dev));
+	struct mmc_host *mmc = host->mmc;
 	int ret = 0;
 
 	/*
 	 * If we don't see a Vcc regulator, assume it's a fixed
 	 * voltage always-on regulator.
 	 */
-	if (!host->vcc)
+	if (!mmc->supply.vmmc)
 		return 0;
 
 	if (mmc_pdata(host)->before_set_reg)
@@ -301,23 +293,23 @@ static int omap_hsmmc_set_power(struct device *dev, int power_on, int vdd)
 	 * chips/cards need an interface voltage rail too.
 	 */
 	if (power_on) {
-		if (host->vcc)
-			ret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);
+		if (mmc->supply.vmmc)
+			ret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
 		/* Enable interface voltage rail, if needed */
-		if (ret == 0 && host->vcc_aux) {
-			ret = regulator_enable(host->vcc_aux);
-			if (ret < 0 && host->vcc)
-				ret = mmc_regulator_set_ocr(host->mmc,
-							host->vcc, 0);
+		if (ret == 0 && mmc->supply.vqmmc) {
+			ret = regulator_enable(mmc->supply.vqmmc);
+			if (ret < 0 && mmc->supply.vmmc)
+				ret = mmc_regulator_set_ocr(mmc,
+							    mmc->supply.vmmc,
+							    0);
 		}
 	} else {
 		/* Shut down the rail */
-		if (host->vcc_aux)
-			ret = regulator_disable(host->vcc_aux);
-		if (host->vcc) {
+		if (mmc->supply.vqmmc)
+			ret = regulator_disable(mmc->supply.vqmmc);
+		if (mmc->supply.vmmc) {
 			/* Then proceed to shut down the local regulator */
-			ret = mmc_regulator_set_ocr(host->mmc,
-						host->vcc, 0);
+			ret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
 		}
 	}
 
@@ -349,32 +341,32 @@ static int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)
 {
 	int ocr_value = 0;
 	int ret;
+	struct mmc_host *mmc = host->mmc;
 
-	host->vcc = devm_regulator_get_optional(host->dev, "vmmc");
-	if (IS_ERR(host->vcc)) {
-		ret = PTR_ERR(host->vcc);
+	mmc->supply.vmmc = devm_regulator_get_optional(host->dev, "vmmc");
+	if (IS_ERR(mmc->supply.vmmc)) {
+		ret = PTR_ERR(mmc->supply.vmmc);
 		if (ret != -ENODEV)
 			return ret;
 		dev_dbg(host->dev, "unable to get vmmc regulator %ld\n",
-			PTR_ERR(host->vcc));
-		host->vcc = NULL;
+			PTR_ERR(mmc->supply.vmmc));
+		mmc->supply.vmmc = NULL;
 	} else {
-		ocr_value = mmc_regulator_get_ocrmask(host->vcc);
+		ocr_value = mmc_regulator_get_ocrmask(mmc->supply.vmmc);
 		if (ocr_value > 0)
 			mmc_pdata(host)->ocr_mask = ocr_value;
 	}
 	mmc_pdata(host)->set_power = omap_hsmmc_set_power;
 
 	/* Allow an aux regulator */
-	host->vcc_aux = devm_regulator_get_optional(host->dev, "vmmc_aux");
-	if (IS_ERR(host->vcc_aux)) {
-		ret = PTR_ERR(host->vcc_aux);
+	mmc->supply.vqmmc = devm_regulator_get_optional(host->dev, "vmmc_aux");
+	if (IS_ERR(mmc->supply.vqmmc)) {
+		ret = PTR_ERR(mmc->supply.vqmmc);
 		if (ret != -ENODEV)
 			return ret;
 		dev_dbg(host->dev, "unable to get vmmc_aux regulator %ld\n",
-		host->vcc_aux = reg;
-			PTR_ERR(host->vcc_aux));
-		host->vcc_aux = NULL;
+			PTR_ERR(mmc->supply.vqmmc));
+		mmc->supply.vqmmc = NULL;
 	}
 
 	host->pbias = devm_regulator_get_optional(host->dev, "pbias");
@@ -394,8 +386,9 @@ static int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)
 	 * To disable boot_on regulator, enable regulator
 	 * to increase usecount and then disable it.
 	 */
-	if ((host->vcc && regulator_is_enabled(host->vcc) > 0) ||
-	    (host->vcc_aux && regulator_is_enabled(host->vcc_aux))) {
+	if ((mmc->supply.vmmc && regulator_is_enabled(mmc->supply.vmmc) > 0) ||
+	    (mmc->supply.vqmmc && regulator_is_enabled(mmc->supply.vqmmc))) {
+
 		int vdd = ffs(mmc_pdata(host)->ocr_mask) - 1;
 
 		mmc_pdata(host)->set_power(host->dev, 1, vdd);
-- 
1.7.5.4

