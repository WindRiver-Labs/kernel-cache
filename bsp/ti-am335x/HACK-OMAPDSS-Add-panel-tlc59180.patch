From 4d76f8c232de4c47cecd269cb988743be5459b03 Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Fri, 12 Jun 2015 14:56:17 +0300
Subject: [PATCH 125/800] HACK: OMAPDSS: Add panel-tlc59180

DRA7 EVM and DRA72 EVM have a panel for which we don't have proper
drivers. We'd need a driver for the TLC59108 LED chip, which, on those
boards, is used as both GPIO expander and a backlight source. We don't
have such a driver, and so we have this custom DRA7/72 specific panel
driver that does the job.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 .../devicetree/bindings/video/ti,tlc59108.txt      |   26 ++
 drivers/video/fbdev/omap2/displays-new/Kconfig     |    8 +
 drivers/video/fbdev/omap2/displays-new/Makefile    |    1 +
 .../fbdev/omap2/displays-new/panel-tlc59108.c      |  374 ++++++++++++++++++++
 4 files changed, 409 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/video/ti,tlc59108.txt
 create mode 100644 drivers/video/fbdev/omap2/displays-new/panel-tlc59108.c

diff --git a/Documentation/devicetree/bindings/video/ti,tlc59108.txt b/Documentation/devicetree/bindings/video/ti,tlc59108.txt
new file mode 100644
index 0000000..0a49669
--- /dev/null
+++ b/Documentation/devicetree/bindings/video/ti,tlc59108.txt
@@ -0,0 +1,26 @@
+TLC59108 based DPI panel
+========================
+
+Required properties
+- compatible: "ti,tlc59108-lp101"; /* For 1280x800 Panel on DRA7/DRA72 EVM */
+
+- reg: i2c slave address of the chip on the board
+- enable-gpio: Enable GPIO for the DPI panel
+
+Required nodes:
+- Video port for DPI input
+
+Example:
+-------
+
+tlc59108: tlc59108@40 {
+	ompatible = "ti,tlc59108-lp101";
+	reg = <0x40>;
+	enable_gpio = <gpio7 11 0>;
+
+	port {
+		lcd_in: endpoint {
+			remote-endpoint = <&dpi_out>;
+		};
+	};
+};
diff --git a/drivers/video/fbdev/omap2/displays-new/Kconfig b/drivers/video/fbdev/omap2/displays-new/Kconfig
index 2637785..ee0bb82 100644
--- a/drivers/video/fbdev/omap2/displays-new/Kconfig
+++ b/drivers/video/fbdev/omap2/displays-new/Kconfig
@@ -106,4 +106,12 @@ config DISPLAY_PANEL_NEC_NL8048HL11
 		This NEC NL8048HL11 panel is TFT LCD used in the
 		Zoom2/3/3630 sdp boards.
 
+config DISPLAY_PANEL_TLC59108
+	tristate "TLC59108 based DPI driver"
+	depends on I2C
+	help
+		Driver for DPI panels powered by TLC59108 pwm/gpio expander
+		chips. These are found on the LCD daughter boards of DRA7 and
+		DRA72 EVMs.
+
 endmenu
diff --git a/drivers/video/fbdev/omap2/displays-new/Makefile b/drivers/video/fbdev/omap2/displays-new/Makefile
index c8cb71b..983e269 100644
--- a/drivers/video/fbdev/omap2/displays-new/Makefile
+++ b/drivers/video/fbdev/omap2/displays-new/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_DISPLAY_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
 obj-$(CONFIG_DISPLAY_PANEL_TPO_TD028TTEC1) += panel-tpo-td028ttec1.o
 obj-$(CONFIG_DISPLAY_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
 obj-$(CONFIG_DISPLAY_PANEL_NEC_NL8048HL11) += panel-nec-nl8048hl11.o
+obj-$(CONFIG_DISPLAY_PANEL_TLC59108) += panel-tlc59108.o
diff --git a/drivers/video/fbdev/omap2/displays-new/panel-tlc59108.c b/drivers/video/fbdev/omap2/displays-new/panel-tlc59108.c
new file mode 100644
index 0000000..aa57662
--- /dev/null
+++ b/drivers/video/fbdev/omap2/displays-new/panel-tlc59108.c
@@ -0,0 +1,374 @@
+/*
+ * TLC59108 DPI Panel Driver
+ *
+ * Copyright (C) 2013 Texas Instruments
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/of_device.h>
+
+#include <video/omapdss.h>
+#include <video/omap-panel-data.h>
+#include <video/of_display_timing.h>
+
+#define TLC_NAME		"tlc59108"
+#define TLC_I2C_ADDR		0x40
+
+#define TLC59108_MODE1		0x00
+#define TLC59108_PWM2		0x04
+#define TLC59108_LEDOUT0	0x0c
+#define TLC59108_LEDOUT1	0x0d
+
+struct panel_drv_data {
+	struct omap_dss_device dssdev;
+	struct omap_dss_device *in;
+
+	struct omap_video_timings videomode;
+
+	struct gpio_desc *enable_gpio;
+	struct regmap *regmap;
+
+	const struct tlc_board_data *board_data;
+};
+
+struct tlc_board_data {
+	struct omap_video_timings timings;
+	const unsigned int *init_seq;
+	unsigned init_seq_len;
+};
+
+static const unsigned int tlc_10_inch_init_seq[] = {
+	/* Init the TLC chip */
+	TLC59108_MODE1, 0x01,
+	/* LDR0: ON, LDR1: OFF, LDR2: PWM, LDR3: OFF */
+	TLC59108_LEDOUT0, 0x21,
+	/* Set LED2 PWM to full */
+	TLC59108_PWM2, 0xff,
+	/* LDR4: OFF, LDR5: OFF, LDR6: OFF, LDR7: ON */
+	TLC59108_LEDOUT1, 0x40,
+};
+
+static const struct tlc_board_data tlc_10_inch_data = {
+	.timings = {
+		.x_res          = 1280,
+		.y_res          = 800,
+
+		.pixelclock     = 69300404,
+
+		.hfp            = 48,
+		.hsw            = 32,
+		.hbp            = 44,
+
+		.vfp            = 4,
+		.vsw            = 7,
+		.vbp            = 12,
+
+		.vsync_level    = OMAPDSS_SIG_ACTIVE_LOW,
+		.hsync_level    = OMAPDSS_SIG_ACTIVE_LOW,
+		.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
+		.de_level       = OMAPDSS_SIG_ACTIVE_HIGH,
+		.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE,
+	},
+	.init_seq = tlc_10_inch_init_seq,
+	.init_seq_len = ARRAY_SIZE(tlc_10_inch_init_seq),
+};
+
+static int tlc_init(struct panel_drv_data *ddata)
+{
+	struct regmap *map = ddata->regmap;
+	unsigned i, len;
+	const unsigned int *seq;
+
+	len = ddata->board_data->init_seq_len;
+	seq = ddata->board_data->init_seq;
+
+	for (i = 0; i < len; i += 2)
+		regmap_write(map, seq[i], seq[i + 1]);
+
+	return 0;
+}
+
+static int tlc_uninit(struct panel_drv_data *ddata)
+{
+	struct regmap *map = ddata->regmap;
+
+	/* clear TLC chip regs */
+	regmap_write(map, TLC59108_PWM2, 0x0);
+	regmap_write(map, TLC59108_LEDOUT0, 0x0);
+	regmap_write(map, TLC59108_LEDOUT1, 0x0);
+
+	regmap_write(map, TLC59108_MODE1, 0x0);
+
+	return 0;
+}
+
+#define to_panel_data(p) container_of(p, struct panel_drv_data, dssdev)
+
+static int panel_dpi_connect(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+	int r;
+
+	if (omapdss_device_is_connected(dssdev))
+		return 0;
+
+	r = in->ops.dpi->connect(in, dssdev);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+static void panel_dpi_disconnect(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	if (!omapdss_device_is_connected(dssdev))
+		return;
+
+	in->ops.dpi->disconnect(in, dssdev);
+}
+
+static int panel_dpi_enable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+	int r;
+
+	if (!omapdss_device_is_connected(dssdev))
+		return -ENODEV;
+
+	if (omapdss_device_is_enabled(dssdev))
+		return 0;
+
+	in->ops.dpi->set_timings(in, &ddata->videomode);
+
+	r = in->ops.dpi->enable(in);
+	if (r)
+		return r;
+
+	tlc_init(ddata);
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+
+	return 0;
+}
+
+static void panel_dpi_disable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	if (!omapdss_device_is_enabled(dssdev))
+		return;
+
+	tlc_uninit(ddata);
+
+	in->ops.dpi->disable(in);
+
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+}
+
+static void panel_dpi_set_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	ddata->videomode = *timings;
+	dssdev->panel.timings = *timings;
+
+	in->ops.dpi->set_timings(in, timings);
+}
+
+static void panel_dpi_get_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+
+	*timings = ddata->videomode;
+}
+
+static int panel_dpi_check_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	return in->ops.dpi->check_timings(in, timings);
+}
+
+static struct omap_dss_driver panel_dpi_ops = {
+	.connect	= panel_dpi_connect,
+	.disconnect	= panel_dpi_disconnect,
+
+	.enable		= panel_dpi_enable,
+	.disable	= panel_dpi_disable,
+
+	.set_timings	= panel_dpi_set_timings,
+	.get_timings	= panel_dpi_get_timings,
+	.check_timings	= panel_dpi_check_timings,
+
+	.get_resolution	= omapdss_default_get_resolution,
+};
+
+static const struct of_device_id tlc59108_of_match[] = {
+	{
+		.compatible = "omapdss,ti,tlc59108-lp101",
+		.data = &tlc_10_inch_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, tlc59108_of_match);
+
+static int tlc_probe_of(struct device *dev)
+{
+	struct panel_drv_data *ddata = dev_get_drvdata(dev);
+	struct device_node *np = dev->of_node;
+	const struct of_device_id *of_dev_id;
+	struct gpio_desc *gpio;
+
+	gpio = devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+	ddata->enable_gpio = gpio;
+
+	ddata->in = omapdss_of_find_source_for_first_ep(np);
+	if (IS_ERR(ddata->in)) {
+		dev_err(dev, "failed to find video source\n");
+		return PTR_ERR(ddata->in);
+	}
+
+	of_dev_id = of_match_device(tlc59108_of_match, dev);
+	if (!of_dev_id) {
+		dev_err(dev, "Unable to match device\n");
+		return -ENODEV;
+	}
+
+	ddata->board_data = of_dev_id->data;
+	ddata->videomode = ddata->board_data->timings;
+
+	return 0;
+}
+
+struct regmap_config tlc59108_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static int tlc59108_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int r;
+	struct regmap *regmap;
+	struct panel_drv_data *ddata;
+	struct device *dev = &client->dev;
+	struct omap_dss_device *dssdev;
+	unsigned int val;
+
+	ddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);
+	if (ddata == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, ddata);
+
+	r = tlc_probe_of(dev);
+	if (r)
+		return r;
+
+	regmap = devm_regmap_init_i2c(client, &tlc59108_regmap_config);
+	if (IS_ERR(regmap)) {
+		r = PTR_ERR(regmap);
+		dev_err(dev, "Failed to init regmap: %d\n", r);
+		goto err_gpio;
+	}
+
+	ddata->regmap = regmap;
+
+	usleep_range(10000, 15000);
+
+	/* Try to read a TLC register to verify if i2c works */
+	r = regmap_read(ddata->regmap, TLC59108_MODE1, &val);
+	if (r < 0) {
+		dev_err(dev, "Failed to set MODE1: %d\n", r);
+		goto err_read;
+	}
+
+	dssdev = &ddata->dssdev;
+	dssdev->dev = dev;
+	dssdev->driver = &panel_dpi_ops;
+	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
+	dssdev->owner = THIS_MODULE;
+	dssdev->panel.timings = ddata->videomode;
+
+	r = omapdss_register_display(dssdev);
+	if (r) {
+		dev_err(dev, "Failed to register panel\n");
+		goto err_reg;
+	}
+
+	dev_info(dev, "Successfully initialized %s\n", TLC_NAME);
+
+	return 0;
+err_reg:
+err_read:
+err_gpio:
+	omap_dss_put_device(ddata->in);
+	return r;
+}
+
+static int tlc59108_i2c_remove(struct i2c_client *client)
+{
+	struct panel_drv_data *ddata = dev_get_drvdata(&client->dev);
+	struct omap_dss_device *dssdev = &ddata->dssdev;
+	struct omap_dss_device *in = ddata->in;
+
+	if (ddata->enable_gpio)
+		gpiod_set_value_cansleep(ddata->enable_gpio, 0);
+
+	omapdss_unregister_display(dssdev);
+
+	panel_dpi_disable(dssdev);
+	panel_dpi_disconnect(dssdev);
+
+	omap_dss_put_device(in);
+
+	return 0;
+}
+
+static const struct i2c_device_id tlc59108_id[] = {
+	{ TLC_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tlc59108_id);
+
+static struct i2c_driver tlc59108_i2c_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= TLC_NAME,
+		.of_match_table = tlc59108_of_match,
+	},
+	.id_table	= tlc59108_id,
+	.probe		= tlc59108_i2c_probe,
+	.remove		= tlc59108_i2c_remove,
+};
+
+module_i2c_driver(tlc59108_i2c_driver);
+
+MODULE_AUTHOR("Archit Taneja  <archit@ti.com>");
+MODULE_DESCRIPTION("TLC-59108 DPI Panel Driver");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

