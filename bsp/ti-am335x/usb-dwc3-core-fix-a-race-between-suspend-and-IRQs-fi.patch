From ab4db42ac7560e067c5e6cdb821906e2b444b0fa Mon Sep 17 00:00:00 2001
From: Felipe Balbi <balbi@ti.com>
Date: Fri, 28 Aug 2015 02:27:49 +0000
Subject: [PATCH 526/800] usb: dwc3: core: fix a race between ->suspend() and
 IRQs firing

If an IRQ fires before we have a chance to mask
them during suspend, we will end up setting oevten
to 0 and completely break functionality because
->resume() won't be able to reenable OTG IRQ.

Instead of caching OEVTEN at all, let's just
introduce dwc3_otg_{mask,unmask}_irq() helpers,
and get rid of oevten from dwc3 private structure.

This simplifies the driver a little bit while also
preventing these silly races.

Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/dwc3/core.c |   30 ++++++++++++++++++------------
 drivers/usb/dwc3/core.h |    2 --
 2 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index ffeecae..7922f88 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -850,6 +850,18 @@ static void dwc3_otg_fsm_sync(struct dwc3 *dwc)
 	}
 }
 
+static void dwc3_otg_mask_irq(struct dwc3 *dwc)
+{
+	dwc3_writel(dwc->regs, DWC3_OEVTEN, 0);
+}
+
+static void dwc3_otg_unmask_irq(struct dwc3 *dwc)
+{
+	dwc3_writel(dwc->regs, DWC3_OEVTEN, DWC3_OEVTEN_CONIDSTSCHNGEN |
+			DWC3_OEVTEN_BDEVVBUSCHNGE |
+			DWC3_OEVTEN_BDEVSESSVLDDETEN);
+}
+
 static irqreturn_t dwc3_otg_thread_irq(int irq, void *_dwc)
 {
 	struct dwc3 *dwc = _dwc;
@@ -857,8 +869,7 @@ static irqreturn_t dwc3_otg_thread_irq(int irq, void *_dwc)
 
 	spin_lock_irqsave(&dwc->lock, flags);
 	dwc3_otg_fsm_sync(dwc);
-	/* unmask interrupts */
-	dwc3_writel(dwc->regs, DWC3_OEVTEN, dwc->oevten);
+	dwc3_otg_unmask_irq(dwc);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	return IRQ_HANDLED;
@@ -875,9 +886,7 @@ static irqreturn_t dwc3_otg_irq(int irq, void *_dwc)
 	reg = dwc3_readl(dwc->regs, DWC3_OEVT);
 	if (reg) {
 		dwc3_writel(dwc->regs, DWC3_OEVT, reg);
-		/* mask interrupts till processed */
-		dwc->oevten = dwc3_readl(dwc->regs, DWC3_OEVTEN);
-		dwc3_writel(dwc->regs, DWC3_OEVTEN, 0);
+		dwc3_otg_mask_irq(dwc);
 		ret = IRQ_WAKE_THREAD;
 	}
 
@@ -1082,7 +1091,7 @@ try_otg_core:
 		return ret;
 
 	/* disable all irqs */
-	dwc3_writel(dwc->regs, DWC3_OEVTEN, 0);
+	dwc3_otg_mask_irq(dwc);
 	/* clear all events */
 	dwc3_writel(dwc->regs, DWC3_OEVT, ~0);
 
@@ -1117,9 +1126,7 @@ try_otg_core:
 	reg = DWC3_OCFG_SFTRSTMASK;
 	dwc3_writel(dwc->regs, DWC3_OCFG, reg);
 	/* Enable ID event interrupt */
-	dwc3_writel(dwc->regs, DWC3_OEVTEN, DWC3_OEVTEN_CONIDSTSCHNGEN |
-			DWC3_OEVTEN_BDEVVBUSCHNGE |
-			DWC3_OEVTEN_BDEVSESSVLDDETEN);
+	dwc3_otg_unmask_irq(dwc);
 	/* OCTL.PeriMode = 1 */
 	dwc3_writel(dwc->regs, DWC3_OCTL, DWC3_OCTL_PERIMODE);
 
@@ -1569,8 +1576,7 @@ static int dwc3_suspend(struct device *dev)
 		dwc->ocfg = dwc3_readl(dwc->regs, DWC3_OCFG);
 		dwc->octl = dwc3_readl(dwc->regs, DWC3_OCTL);
 		dwc->oevt = dwc3_readl(dwc->regs, DWC3_OEVT);
-		dwc->oevten = dwc3_readl(dwc->regs, DWC3_OEVTEN);
-		dwc3_writel(dwc->regs, DWC3_OEVTEN, 0);
+		dwc3_otg_mask_irq(dwc);
 	}
 
 	if (dwc->dr_mode == USB_DR_MODE_PERIPHERAL ||
@@ -1620,7 +1626,7 @@ static int dwc3_resume(struct device *dev)
 		dwc3_writel(dwc->regs, DWC3_OCFG, dwc->ocfg);
 		dwc3_writel(dwc->regs, DWC3_OCTL, dwc->octl);
 		dwc3_writel(dwc->regs, DWC3_OEVT, dwc->oevt);
-		dwc3_writel(dwc->regs, DWC3_OEVTEN, dwc->oevten);
+		dwc3_otg_unmask_irq(dwc);
 	}
 
 	if (dwc->dr_mode == USB_DR_MODE_PERIPHERAL ||
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 9294272..0b2be84 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -745,7 +745,6 @@ struct dwc3_scratchpad_array {
  * @gadget_driver: pointer to the gadget driver
  * @regs: base address for our registers
  * @regs_size: address space size
- * @oevten: otg interrupt enable mask copy
  * @current_mode: current mode of operation written to PRTCAPDIR
  * @nr_scratch: number of scratch buffers
  * @num_event_buffers: calculated number of event buffers
@@ -878,7 +877,6 @@ struct dwc3 {
 	u32			ocfg;
 	u32			octl;
 	u32			oevt;
-	u32			oevten;
 
 	u32			current_mode;
 	u32			nr_scratch;
-- 
1.7.5.4

