From d38aca358f9c1de1bc5e8a532a9173346019ac92 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Thu, 25 Jun 2015 12:40:34 -0500
Subject: [PATCH 205/800] soc: ti: wkup_m3_ipc: Add wkup_m3_request_wake_src

Add wkup_m3_request_wake_src to allow users to get the name of
the wakeup source after a DeepSleep or Standby transition.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/soc/ti/wkup_m3_ipc.c |   41 +++++++++++++++++++++++++++++++++++++++++
 include/linux/wkup_m3_ipc.h  |    7 +++++++
 2 files changed, 48 insertions(+), 0 deletions(-)

diff --git a/drivers/soc/ti/wkup_m3_ipc.c b/drivers/soc/ti/wkup_m3_ipc.c
index a8e9bde..07149a2 100644
--- a/drivers/soc/ti/wkup_m3_ipc.c
+++ b/drivers/soc/ti/wkup_m3_ipc.c
@@ -46,6 +46,7 @@
 #define M3_BASELINE_VERSION		0x191
 #define M3_STATUS_RESP_MASK		(0xffff << 16)
 #define M3_FW_VERSION_MASK		0xffff
+#define M3_WAKE_SRC_MASK		0xff
 
 #define M3_STATE_UNKNOWN		0
 #define M3_STATE_RESET			1
@@ -70,6 +71,23 @@ struct wkup_m3_ipc {
 
 static struct wkup_m3_ipc m3_ipc_state;
 
+static const struct wkup_m3_wakeup_src wakeups[] = {
+	{.irq_nr = 35,	.src = "USB0_PHY"},
+	{.irq_nr = 36,	.src = "USB1_PHY"},
+	{.irq_nr = 40,	.src = "I2C0"},
+	{.irq_nr = 41,	.src = "RTC Timer"},
+	{.irq_nr = 42,	.src = "RTC Alarm"},
+	{.irq_nr = 43,	.src = "Timer0"},
+	{.irq_nr = 44,	.src = "Timer1"},
+	{.irq_nr = 45,	.src = "UART"},
+	{.irq_nr = 46,	.src = "GPIO0"},
+	{.irq_nr = 48,	.src = "MPU_WAKE"},
+	{.irq_nr = 49,	.src = "WDT0"},
+	{.irq_nr = 50,	.src = "WDT1"},
+	{.irq_nr = 51,	.src = "ADC_TSC"},
+	{.irq_nr = 0,	.src = "Unknown"},
+};
+
 static void am33xx_txev_eoi(struct wkup_m3_ipc *m3_ipc)
 {
 	writel(AM33XX_M3_TXEV_ACK,
@@ -321,6 +339,29 @@ int wkup_m3_finish_low_power(void)
 }
 EXPORT_SYMBOL_GPL(wkup_m3_finish_low_power);
 
+/**
+ * wkup_m3_wake_src - Get the wakeup source info passed from wkup_m3
+ * @wkup_m3_wakeup: struct wkup_m3_wakeup_src * gets assigned the
+ *		    wakeup src value
+ */
+const char *wkup_m3_request_wake_src(void)
+{
+	struct wkup_m3_ipc *m3_ipc = &m3_ipc_state;
+	unsigned int wakeup_src_idx;
+	int j, val;
+
+	val = wkup_m3_ctrl_ipc_read(m3_ipc, 6);
+
+	wakeup_src_idx = val & M3_WAKE_SRC_MASK;
+
+	for (j = 0; j < ARRAY_SIZE(wakeups) - 1; j++) {
+		if (wakeups[j].irq_nr == wakeup_src_idx)
+			return wakeups[j].src;
+	}
+	return wakeups[j].src;
+}
+EXPORT_SYMBOL(wkup_m3_request_wake_src);
+
 static void wkup_m3_rproc_boot_thread(struct rproc *rproc)
 {
 	struct device *dev = &rproc->dev;
diff --git a/include/linux/wkup_m3_ipc.h b/include/linux/wkup_m3_ipc.h
index 85f9074..56bcaec6 100644
--- a/include/linux/wkup_m3_ipc.h
+++ b/include/linux/wkup_m3_ipc.h
@@ -17,10 +17,17 @@
 #ifndef _LINUX_WKUP_M3_IPC_H
 #define _LINUX_WKUP_M3_IPC_H
 
+struct wkup_m3_wakeup_src {
+	int irq_nr;
+	char src[10];
+};
+
 void wkup_m3_set_mem_type(int mem_type);
 void wkup_m3_set_resume_address(void *addr);
 int wkup_m3_prepare_low_power(int state);
 int wkup_m3_finish_low_power(void);
 int wkup_m3_request_pm_status(void);
+int wkup_m3_request_pm_status(void);
+const char *wkup_m3_request_wake_src(void);
 
 #endif /* _LINUX_WKUP_M3_IPC_H */
-- 
1.7.5.4

