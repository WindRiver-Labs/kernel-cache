From 391f9098a0471e86c2d3844544451af9ff807390 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Thu, 30 Jan 2014 11:55:23 +0200
Subject: [PATCH 039/188] usb: musb: dsps: Fix babble workaround for AM335x
 PG2.0 devices

This commit comes from branch ti-linux-3.12.y:

git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

The babble workaround handling must be done outside the interrupt
context, so do it using a workqueue. This fixes USB detection after
babble condition for AM335x PG2.0 devices (e.g. Beaglebone black).

Also reduce delay from 100ms to 100uS around PHY power down/up
during the workaround. This delay seems to be sufficient.

Fixes D-01491 - AM335x: CONNECTIVITY: USB device detection fails after
		babble condition on PG2.0 devices

Signed-off-by: Roger Quadros <rogerq@ti.com>
Tested-by: George Cherian <george.cherian@ti.com>
(cherry picked from commit 2b4a2e2c49d5f248babf0c337567b287df35b4ce)
---
 drivers/usb/musb/musb_core.h |    2 ++
 drivers/usb/musb/musb_dsps.c |   17 +++++++++++++----
 2 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 55e25f6..3a58999 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -296,6 +296,8 @@ struct musb {
 
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
+	struct work_struct	babble_work;
+
 	struct delayed_work	deassert_reset_work;
 	struct delayed_work	finish_resume_work;
 	u16			hwvers;
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index f6de92c..1e440db 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -325,6 +325,7 @@ static void sw_babble_control(struct musb *musb)
 	if (session_restart) {
 		u32 devctl;
 
+		dev_dbg(musb->controller, "Restarting session\n");
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		devctl &= ~MUSB_DEVCTL_SESSION;
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
@@ -333,16 +334,23 @@ static void sw_babble_control(struct musb *musb)
 		dsps_writel(base, wrp->control, (1 << wrp->reset));
 
 		usb_phy_shutdown(musb->xceiv);
-		mdelay(100);
+		usleep_range(100, 200);
 		musb_platform_set_mode(musb, MUSB_HOST);
-		mdelay(100);
+		usleep_range(100, 200);
 		usb_phy_init(musb->xceiv);
-		mdelay(100);
+		msleep(100);
 
 		musb_babble_reinit(musb);
 	}
 }
 
+static void dsps_babble_work(struct work_struct *work)
+{
+	struct musb *musb = container_of(work, struct musb, babble_work);
+
+	sw_babble_control(musb);
+}
+
 static irqreturn_t dsps_interrupt(int irq, void *hci)
 {
 	struct musb  *musb = hci;
@@ -445,7 +453,7 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 		mod_timer(&glue->timer, jiffies + wrp->poll_seconds * HZ);
 
 	if (babble_detected)
-		sw_babble_control(musb);
+		schedule_work(&musb->babble_work);
 out:
 	spin_unlock_irqrestore(&musb->lock, flags);
 
@@ -481,6 +489,7 @@ static int dsps_musb_init(struct musb *musb)
 	if (!rev)
 		return -ENODEV;
 
+	INIT_WORK(&musb->babble_work, dsps_babble_work);
 	usb_phy_init(musb->xceiv);
 	setup_timer(&glue->timer, otg_timer, (unsigned long) musb);
 
-- 
1.7.5.4

