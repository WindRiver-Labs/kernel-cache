From 8bd168c4dae78677a5217f620359fd32b24b3b96 Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Fri, 2 Oct 2015 11:10:42 +0300
Subject: [PATCH 581/800] drm/omap: fix suspend/resume handling

For legacy reasons omapdss handles system suspend/resume via PM notifier
callback, where the driver disables/resumes all the outputs.

This doesn't work well with omapdrm. What happens on suspend is that the
omapdss disables the displays while omapdrm is still happily continuing
its work, possibly waiting for an vsync irq, which will never come if
the display output is disabled, leading to timeouts and errors sent to
userspace.

To fix this while keeping the omapfb behavior unchanged, this patch
makes the omapdss register the PM notifier only when in legacy mode, and
lets omapdrm do its own suspend handling.

Similar suspend/resume code than in omapdss is added to omapdrm's
suspend and resume functions, which is now done safely inside modeset
lock.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Jyri Sarha <jsarha@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/gpu/drm/omapdrm/omap_drv.c    |   44 +++++++++++++++++++++++++++++++++
 drivers/video/fbdev/omap2/dss/apply.c |    4 +++
 drivers/video/fbdev/omap2/dss/core.c  |   14 +++++++---
 drivers/video/fbdev/omap2/dss/dss.h   |    2 +
 4 files changed, 60 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/omap_drv.c b/drivers/gpu/drm/omapdrm/omap_drv.c
index d12dadb..56ff8bf 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.c
+++ b/drivers/gpu/drm/omapdrm/omap_drv.c
@@ -1081,12 +1081,52 @@ static int pdev_remove(struct platform_device *device)
 }
 
 #ifdef CONFIG_PM_SLEEP
+static int omap_drm_suspend_all_displays(void)
+{
+	struct omap_dss_device *dssdev = NULL;
+
+	for_each_dss_dev(dssdev) {
+		if (!dssdev->driver)
+			continue;
+
+		if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {
+			dssdev->driver->disable(dssdev);
+			dssdev->activate_after_resume = true;
+		} else {
+			dssdev->activate_after_resume = false;
+		}
+	}
+
+	return 0;
+}
+
+static int omap_drm_resume_all_displays(void)
+{
+	struct omap_dss_device *dssdev = NULL;
+
+	for_each_dss_dev(dssdev) {
+		if (!dssdev->driver)
+			continue;
+
+		if (dssdev->activate_after_resume) {
+			dssdev->driver->enable(dssdev);
+			dssdev->activate_after_resume = false;
+		}
+	}
+
+	return 0;
+}
+
 static int omap_drm_suspend(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
 
 	drm_kms_helper_poll_disable(drm_dev);
 
+	drm_modeset_lock_all(drm_dev);
+	omap_drm_suspend_all_displays();
+	drm_modeset_unlock_all(drm_dev);
+
 	return 0;
 }
 
@@ -1094,6 +1134,10 @@ static int omap_drm_resume(struct device *dev)
 {
 	struct drm_device *drm_dev = dev_get_drvdata(dev);
 
+	drm_modeset_lock_all(drm_dev);
+	omap_drm_resume_all_displays();
+	drm_modeset_unlock_all(drm_dev);
+
 	drm_kms_helper_poll_enable(drm_dev);
 
 	return omap_gem_resume(dev);
diff --git a/drivers/video/fbdev/omap2/dss/apply.c b/drivers/video/fbdev/omap2/dss/apply.c
index 663ccc3..dce710d 100644
--- a/drivers/video/fbdev/omap2/dss/apply.c
+++ b/drivers/video/fbdev/omap2/dss/apply.c
@@ -1655,6 +1655,8 @@ int omapdss_compat_init(void)
 
 	dispc_runtime_put();
 
+	dss_install_pm_handler();
+
 out:
 	mutex_unlock(&compat_init_lock);
 
@@ -1688,6 +1690,8 @@ void omapdss_compat_uninit(void)
 	if (--compat_refcnt > 0)
 		goto out;
 
+	dss_uninstall_pm_handler();
+
 	dss_dispc_uninitialize_irq();
 
 	display_uninit_sysfs(pdev);
diff --git a/drivers/video/fbdev/omap2/dss/core.c b/drivers/video/fbdev/omap2/dss/core.c
index 54eeb50..d7606b3 100644
--- a/drivers/video/fbdev/omap2/dss/core.c
+++ b/drivers/video/fbdev/omap2/dss/core.c
@@ -191,6 +191,16 @@ static struct notifier_block omap_dss_pm_notif_block = {
 	.notifier_call = omap_dss_pm_notif,
 };
 
+void dss_install_pm_handler(void)
+{
+	register_pm_notifier(&omap_dss_pm_notif_block);
+}
+
+void dss_uninstall_pm_handler(void)
+{
+	unregister_pm_notifier(&omap_dss_pm_notif_block);
+}
+
 static int __init omap_dss_probe(struct platform_device *pdev)
 {
 	struct omap_dss_board_info *pdata = pdev->dev.platform_data;
@@ -211,8 +221,6 @@ static int __init omap_dss_probe(struct platform_device *pdev)
 	else if (pdata->default_device)
 		core.default_display_name = pdata->default_device->name;
 
-	register_pm_notifier(&omap_dss_pm_notif_block);
-
 	return 0;
 
 err_debugfs:
@@ -222,8 +230,6 @@ err_debugfs:
 
 static int omap_dss_remove(struct platform_device *pdev)
 {
-	unregister_pm_notifier(&omap_dss_pm_notif_block);
-
 	dss_uninitialize_debugfs();
 
 	return 0;
diff --git a/drivers/video/fbdev/omap2/dss/dss.h b/drivers/video/fbdev/omap2/dss/dss.h
index 2406bcd..788e0a7 100644
--- a/drivers/video/fbdev/omap2/dss/dss.h
+++ b/drivers/video/fbdev/omap2/dss/dss.h
@@ -204,6 +204,8 @@ int dss_dsi_enable_pads(int dsi_id, unsigned lane_mask);
 void dss_dsi_disable_pads(int dsi_id, unsigned lane_mask);
 int dss_set_min_bus_tput(struct device *dev, unsigned long tput);
 int dss_debugfs_create_file(const char *name, void (*write)(struct seq_file *));
+void dss_install_pm_handler(void);
+void dss_uninstall_pm_handler(void);
 
 /* display */
 int dss_suspend_all_devices(void);
-- 
1.7.5.4

