From 2f655aa2e34903a7f45dbef4b99c14848b89be06 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Wed, 1 Jul 2015 14:46:10 -0500
Subject: [PATCH 212/800] ARM: OMAP2+: sleep33xx: Make sleep33xx actions
 configurable

Add an argument to the sleep33xx code to allow us to set flags to
determine which portions of the code get called in order to use the same
code for cpuidle sequence as well. This patch allows us to decide
whether or not we save EMIF context, put the DDR into self refresh,
disable the EMIF, and invoke the wkup_m3 when entering into WFI.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/pm.h          |    9 +++++++-
 arch/arm/mach-omap2/pm33xx-core.c |   10 +++++---
 arch/arm/mach-omap2/pm33xx.c      |   10 ++++++++-
 arch/arm/mach-omap2/sleep33xx.S   |   39 ++++++++++++++++++++++++++++++++++++-
 4 files changed, 61 insertions(+), 7 deletions(-)

diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index ba407e1..f622b00 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -84,7 +84,8 @@ extern void (*omap3_do_wfi_sram)(void);
 /* for sharing core pm ops with amx3 pm modules */
 struct am33xx_pm_ops {
 	int	(*init)(void);
-	int	(*soc_suspend)(unsigned int state, int (*fn)(unsigned long));
+	int	(*soc_suspend)(unsigned int state, int (*fn)(unsigned long),
+			       unsigned long args);
 };
 
 /* for sharing asm function addrs with amx3 pm modules */
@@ -98,6 +99,12 @@ struct am33xx_pm_sram_addr {
 struct am33xx_pm_ops *amx3_get_pm_ops(void);
 struct am33xx_pm_sram_addr *amx3_get_sram_addrs(void);
 
+#define WFI_FLAG_SELF_REFRESH		(1 << 2)
+#define WFI_FLAG_SAVE_EMIF		(1 << 3)
+#define WFI_FLAG_WAKE_M3		(1 << 4)
+#define WFI_FLAG_DISABLE_EMIF		(1 << 7)
+#define WFI_FLAG_RTC_ONLY		(1 << 8)
+
 extern struct am33xx_pm_sram_addr am33xx_pm_sram;
 extern struct am33xx_pm_sram_addr am43xx_pm_sram;
 
diff --git a/arch/arm/mach-omap2/pm33xx-core.c b/arch/arm/mach-omap2/pm33xx-core.c
index ef6d481..cbbc935 100644
--- a/arch/arm/mach-omap2/pm33xx-core.c
+++ b/arch/arm/mach-omap2/pm33xx-core.c
@@ -113,12 +113,13 @@ static void amx3_post_suspend_common(void)
 		pr_err("PM: GFX domain did not transition: %x\n", status);
 }
 
-static int am33xx_suspend(unsigned int state, int (*fn)(unsigned long))
+static int am33xx_suspend(unsigned int state, int (*fn)(unsigned long),
+			  unsigned long args)
 {
 	int ret = 0;
 
 	amx3_pre_suspend_common();
-	ret = cpu_suspend(0, fn);
+	ret = cpu_suspend(args, fn);
 	amx3_post_suspend_common();
 
 	/*
@@ -135,13 +136,14 @@ static int am33xx_suspend(unsigned int state, int (*fn)(unsigned long))
 	return ret;
 }
 
-static int am43xx_suspend(unsigned int state, int (*fn)(unsigned long))
+static int am43xx_suspend(unsigned int state, int (*fn)(unsigned long),
+			  unsigned long args)
 {
 	int ret = 0;
 
 	amx3_pre_suspend_common();
 	scu_power_mode(scu_base, SCU_PM_POWEROFF);
-	ret = cpu_suspend(0, fn);
+	ret = cpu_suspend(args, fn);
 	scu_power_mode(scu_base, SCU_PM_NORMAL);
 	amx3_post_suspend_common();
 
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index d589a8d..619dce9 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -42,13 +42,15 @@ static phys_addr_t ocmcram_location;
 
 static struct am33xx_pm_ops *pm_ops;
 static struct am33xx_pm_sram_addr *pm_sram;
+static unsigned long suspend_wfi_flags;
 
 #ifdef CONFIG_SUSPEND
 static int am33xx_pm_suspend(suspend_state_t suspend_state)
 {
 	int i, ret = 0;
 
-	ret = pm_ops->soc_suspend(suspend_state, am33xx_do_wfi_sram);
+	ret = pm_ops->soc_suspend(suspend_state, am33xx_do_wfi_sram,
+				  suspend_wfi_flags);
 
 	if (ret) {
 		pr_err("PM: Kernel suspend failure\n");
@@ -227,6 +229,12 @@ int am33xx_pm_init(void)
 		return -ENODEV;
 	}
 
+	suspend_wfi_flags = 0;
+	suspend_wfi_flags |= WFI_FLAG_SELF_REFRESH;
+	suspend_wfi_flags |= WFI_FLAG_SAVE_EMIF;
+	suspend_wfi_flags |= WFI_FLAG_DISABLE_EMIF;
+	suspend_wfi_flags |= WFI_FLAG_WAKE_M3;
+
 	ret = pm_ops->init();
 	if (ret) {
 		pr_err("Unable to call core pm init!\n");
diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
index cd9e72f2..a476200 100644
--- a/arch/arm/mach-omap2/sleep33xx.S
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -21,6 +21,12 @@
 #include "iomap.h"
 #include "cm33xx.h"
 
+#define WFI_FLAG_SELF_REFRESH		(1 << 2)
+#define WFI_FLAG_SAVE_EMIF		(1 << 3)
+#define WFI_FLAG_WAKE_M3		(1 << 4)
+#define WFI_FLAG_DISABLE_EMIF		(1 << 7)
+#define WFI_FLAG_RTC_ONLY		(1 << 8)
+
 #define AM33XX_CM_CLKCTRL_MODULEMODE_DISABLE			0x0003
 #define AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE			0x0002
 
@@ -30,6 +36,13 @@
 ENTRY(am33xx_do_wfi)
 	stmfd	sp!, {r4 - r11, lr}	@ save registers on stack
 
+	str	r0, wfi_flags
+
+	/* Only necessary if PER is losing context */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_FLAG_SAVE_EMIF
+	beq	emif_skip_save
+
 	/*
 	 * Flush all data from the L1 and L2 data cache before disabling
 	 * SCTLR.C bit.
@@ -56,22 +69,37 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, ti_emif_save_context
 	blx	r1
 
+emif_skip_save:
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_FLAG_SELF_REFRESH
+	beq	emif_skip_enter_sr
+
 	ldr	r1, ti_emif_enter_sr
 	blx	r1
 
+emif_skip_enter_sr:
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_FLAG_DISABLE_EMIF
+	beq	emif_skip_disable
+
 	/* Disable EMIF */
 	ldr     r1, virt_emif_clkctrl
 	ldr     r2, [r1]
 	bic     r2, r2, #AM33XX_CM_CLKCTRL_MODULEMODE_DISABLE
 	str     r2, [r1]
 
-	ldr	r1, virt_emif_clkctrl
 wait_emif_disable:
 	ldr	r2, [r1]
 	ldr	r3, module_disabled_val
 	cmp	r2, r3
 	bne	wait_emif_disable
 
+emif_skip_disable:
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_FLAG_WAKE_M3
+	beq	wkup_m3_skip
+
+	ldr	r1, virt_emif_clkctrl
 	/*
 	 * For the MPU WFI to be registered as an interrupt
 	 * to WKUP_M3, MPU_CLKCTRL.MODULEMODE needs to be set
@@ -82,6 +110,7 @@ wait_emif_disable:
 	bic	r2, r2, #AM33XX_CM_CLKCTRL_MODULEMODE_DISABLE
 	str	r2, [r1]
 
+wkup_m3_skip:
 	/*
 	 * Execute an ISB instruction to ensure that all of the
 	 * CP15 register changes have been committed.
@@ -126,6 +155,11 @@ wait_emif_disable:
 	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
 	str	r2, [r1]
 
+	/* Only necessary if PER is losing context */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_FLAG_SELF_REFRESH
+	beq	emif_skip_exit_sr_abt
+
 	/* Re-enable EMIF */
 	ldr	r1, virt_emif_clkctrl
 	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
@@ -138,6 +172,7 @@ wait_emif_enable:
 	ldr	r1, ti_emif_abort_sr
 	blx	r1
 
+emif_skip_exit_sr_abt:
 	/*
 	 * Set SCTLR.C bit to allow data cache allocation
 	 */
@@ -196,6 +231,8 @@ phys_emif_clkctrl:
 		AM33XX_CM_PER_EMIF_CLKCTRL_OFFSET)
 module_disabled_val:
 	.word	0x30000
+wfi_flags:
+	.word	0x00000000
 
 /* DDR related defines */
 am33xx_emif_sram_table:
-- 
1.7.5.4

