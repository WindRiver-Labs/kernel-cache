From 7fe9fd8c12c598b74ab27c5d12a733c6f6f21f98 Mon Sep 17 00:00:00 2001
From: Felipe Balbi <balbi@ti.com>
Date: Fri, 28 Aug 2015 02:27:50 +0000
Subject: [PATCH 527/800] usb: common: otg: track wheter host/gadget are
 started or not

With this we can issue multiple calls to otg_start_{host,gadget}()
and it won't fail with NULL pointer dereferences.

Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/common/usb-otg.c |   21 +++++++++++++++++++++
 1 files changed, 21 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/common/usb-otg.c b/drivers/usb/common/usb-otg.c
index 9b89f4b..f1c10e4 100644
--- a/drivers/usb/common/usb-otg.c
+++ b/drivers/usb/common/usb-otg.c
@@ -64,6 +64,10 @@ struct otg_data {
 
 	struct list_head list;
 
+	u32 flags;
+#define OTG_FLAG_GADGET_RUNNING (1 << 0)
+#define OTG_FLAG_HOST_RUNNING (1 << 1)
+
 	struct work_struct work;	/* OTG FSM work */
 	struct workqueue_struct *wq;
 
@@ -211,6 +215,10 @@ static int usb_otg_start_host(struct otg_fsm *fsm, int on)
 	}
 
 	if (on) {
+		if (otgd->flags & OTG_FLAG_HOST_RUNNING)
+			return 0;
+		otgd->flags |= OTG_FLAG_HOST_RUNNING;
+
 		/* OTG device operations */
 		if (otgd->start_host)
 			otgd->start_host(fsm, on);
@@ -226,11 +234,16 @@ static int usb_otg_start_host(struct otg_fsm *fsm, int on)
 				     otgd->shared_hcd.irqflags);
 		}
 	} else {
+		if (!(otgd->flags & OTG_FLAG_HOST_RUNNING))
+			return 0;
+		otgd->flags &= ~OTG_FLAG_HOST_RUNNING;
+
 		/* stop host */
 		if (otgd->shared_hcd.hcd) {
 			hcd_ops = otgd->shared_hcd.ops;
 			hcd_ops->remove(otgd->shared_hcd.hcd);
 		}
+
 		hcd_ops = otgd->primary_hcd.ops;
 		hcd_ops->remove(otgd->primary_hcd.hcd);
 
@@ -257,17 +270,25 @@ static int usb_otg_start_gadget(struct otg_fsm *fsm, int on)
 	}
 
 	if (on) {
+		if (otgd->flags & OTG_FLAG_GADGET_RUNNING)
+			return 0;
+
 		/* OTG device operations */
 		if (otgd->start_gadget)
 			otgd->start_gadget(fsm, on);
 
 		otgd->gadget_ops->start(fsm->otg->gadget);
+		otgd->flags |= OTG_FLAG_GADGET_RUNNING;
 	} else {
+		if (!(otgd->flags & OTG_FLAG_GADGET_RUNNING))
+			return 0;
+
 		otgd->gadget_ops->stop(fsm->otg->gadget);
 
 		/* OTG device operations */
 		if (otgd->start_gadget)
 			otgd->start_gadget(fsm, on);
+		otgd->flags &= ~OTG_FLAG_GADGET_RUNNING;
 	}
 
 	return 0;
-- 
1.7.5.4

