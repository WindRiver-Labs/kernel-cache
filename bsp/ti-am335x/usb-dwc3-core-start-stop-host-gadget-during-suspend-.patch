From 90944afeedd308ce5d06c5cd83015a453fc50e62 Mon Sep 17 00:00:00 2001
From: Felipe Balbi <balbi@ti.com>
Date: Fri, 28 Aug 2015 04:27:19 +0000
Subject: [PATCH 531/800] usb: dwc3: core: start/stop host/gadget during
 suspend/resume

We should automatically start/stop host/gadget
during suspend/resume so that a suspend/resume
cycle with USB cable attached causes the device
to come back up to the bus.

Without this, we will need a cable reinsertion
to the the device to reenumerate after resume.

Signed-off-by: Felipe Balbi <balbi@ti.com>
[nsekhar@ti.com: checkpatch fixes for space before '(']
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/dwc3/core.c |   63 +++++++++++++++++++++++++++++++++++++++-------
 drivers/usb/dwc3/core.h |    1 +
 2 files changed, 54 insertions(+), 10 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 6318541..2751a94 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -1578,15 +1578,38 @@ static int dwc3_suspend(struct device *dev)
 		dwc3_otg_mask_irq(dwc);
 	}
 
-	if (dwc->dr_mode == USB_DR_MODE_PERIPHERAL ||
-	    ((dwc->dr_mode == USB_DR_MODE_OTG) && dwc->fsm->protocol == PROTO_GADGET))
-		dwc3_gadget_suspend(dwc);
-
 	dwc3_event_buffers_cleanup(dwc);
 
 	dwc->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
+	switch (dwc->dr_mode) {
+	case USB_DR_MODE_PERIPHERAL:
+		dwc3_gadget_suspend(dwc);
+		break;
+	case USB_DR_MODE_OTG:
+		dwc->otg_protocol = dwc->fsm->protocol;
+
+		switch (dwc->fsm->protocol) {
+		case PROTO_GADGET:
+			dwc3_gadget_suspend(dwc);
+			otg_start_gadget(dwc->fsm, false);
+			break;
+		case PROTO_HOST:
+			otg_start_host(dwc->fsm, false);
+			break;
+		case PROTO_UNDEF:
+		default:
+			/* nothing */
+			break;
+		}
+	case USB_DR_MODE_HOST:
+	case USB_DR_MODE_UNKNOWN:
+	default:
+		/* nothing */
+		break;
+	}
+
 	usb_phy_shutdown(dwc->usb3_phy);
 	usb_phy_shutdown(dwc->usb2_phy);
 	phy_exit(dwc->usb2_generic_phy);
@@ -1616,21 +1639,41 @@ static int dwc3_resume(struct device *dev)
 		goto err_usb2phy_init;
 
 	spin_lock_irqsave(&dwc->lock, flags);
-
 	dwc3_event_buffers_setup(dwc);
 	dwc3_writel(dwc->regs, DWC3_GCTL, dwc->gctl);
+	spin_unlock_irqrestore(&dwc->lock, flags);
 
+	switch (dwc->dr_mode) {
+	case USB_DR_MODE_PERIPHERAL:
+		dwc3_gadget_resume(dwc);
+		break;
+	case USB_DR_MODE_OTG:
+		switch (dwc->otg_protocol) {
+		case PROTO_GADGET:
+			dwc3_gadget_resume(dwc);
+			otg_start_gadget(dwc->fsm, true);
+			break;
+		case PROTO_HOST:
+			otg_start_host(dwc->fsm, true);
+			break;
+		case PROTO_UNDEF:
+			/* nothing */
+			break;
+		}
+	case USB_DR_MODE_HOST:
+	case USB_DR_MODE_UNKNOWN:
+	default:
+		/* nothing */
+		break;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
 	/* Restore OTG state only if we're really using it */
 	if (dwc->current_mode == DWC3_GCTL_PRTCAP_OTG) {
 		dwc3_writel(dwc->regs, DWC3_OCFG, dwc->ocfg);
 		dwc3_writel(dwc->regs, DWC3_OCTL, dwc->octl);
 		dwc3_otg_unmask_irq(dwc);
 	}
-
-	if (dwc->dr_mode == USB_DR_MODE_PERIPHERAL ||
-	    ((dwc->dr_mode == USB_DR_MODE_OTG) && dwc->fsm->protocol == PROTO_GADGET))
-		dwc3_gadget_resume(dwc);
-
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	pm_runtime_disable(dev);
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 86e0fbd..39e5bb6 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -867,6 +867,7 @@ struct dwc3 {
 
 	enum usb_dr_mode	dr_mode;
 
+	int			otg_protocol;
 	int			gadget_irq;
 	int			xhci_irq;
 	int			otg_irq;
-- 
1.7.5.4

