From 916cfcad8e6e1774646f4c2be95e6105d4ac4005 Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Wed, 30 Mar 2016 14:08:20 +0800
Subject: [PATCH 1/2] mailbox: using raw lock for rt kernel

when cpu prepares into the idle state, irq will be disabled,
but for mailbox driver, it will call the spin_lock_irqsave,
it will cause the crash:

CPU: 0 PID: 0 Comm: swapper/0 Not tainted
[<c0017788>] (unwind_backtrace) from [<c0012d3c>] (show_stack+0x20/0x24)
[<c0012d3c>] (show_stack) from [<c07e9888>] (dump_stack+0x74/0xcc)
[<c07e9888>] (dump_stack) from [<c006fe40>] (__might_sleep+0xe4/0x154)
[<c006fe40>] (__might_sleep) from [<c07ef414>] (rt_spin_lock+0x30/0x3c)
[<c07ef414>] (rt_spin_lock) from [<c05c23d4>]
(mbox_send_message+0x3c/0x14c)
[<c05c23d4>] (mbox_send_message) from [<c05c7160>]
(wkup_m3_ping+0x30/0x90)
[<c05c7160>] (wkup_m3_ping) from [<c002eab0>]
(am33xx_do_sram_cpuidle+0x84/0xa8)
[<c002eab0>] (am33xx_do_sram_cpuidle) from [<c002eff0>]
(am33xx_enter_idle+0x80/0x88)
[<c002eff0>] (am33xx_enter_idle) from [<c058f038>]
(cpuidle_enter_state+0x4c/0xf8)
[<c058f038>] (cpuidle_enter_state) from [<c058f1b8>]
(cpuidle_idle_call+0xd4/0x298)
[<c058f1b8>] (cpuidle_idle_call) from [<c00101b4>]
(arch_cpu_idle+0x18/0x48)
[<c00101b4>] (arch_cpu_idle) from [<c0091768>]
(cpu_startup_entry+0x68/0x288)
[<c0091768>] (cpu_startup_entry) from [<c07e2f10>] (rest_init+0x80/0x98)
[<c07e2f10>] (rest_init) from [<c0b21b6c>] (start_kernel+0x338/0x39c)

Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/mailbox/mailbox.c          |   24 ++++++++++++------------
 include/linux/mailbox_controller.h |    2 +-
 2 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/drivers/mailbox/mailbox.c b/drivers/mailbox/mailbox.c
index c7fdb57..11c3d5c 100644
--- a/drivers/mailbox/mailbox.c
+++ b/drivers/mailbox/mailbox.c
@@ -33,11 +33,11 @@ static int add_to_rbuf(struct mbox_chan *chan, void *mssg)
 	int idx;
 	unsigned long flags;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 
 	/* See if there is any space left */
 	if (chan->msg_count == MBOX_TX_QUEUE_LEN) {
-		spin_unlock_irqrestore(&chan->lock, flags);
+		raw_spin_unlock_irqrestore(&chan->lock, flags);
 		return -ENOBUFS;
 	}
 
@@ -50,7 +50,7 @@ static int add_to_rbuf(struct mbox_chan *chan, void *mssg)
 	else
 		chan->msg_free++;
 
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 
 	return idx;
 }
@@ -62,7 +62,7 @@ static void msg_submit(struct mbox_chan *chan)
 	void *data;
 	int err = -EBUSY;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 
 	if (!chan->msg_count || chan->active_req)
 		goto exit;
@@ -85,7 +85,7 @@ static void msg_submit(struct mbox_chan *chan)
 		chan->msg_count--;
 	}
 exit:
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 
 	if (!err && (chan->txdone_method & TXDONE_BY_POLL))
 		poll_txdone((unsigned long)chan->mbox);
@@ -96,10 +96,10 @@ static void tx_tick(struct mbox_chan *chan, int r)
 	unsigned long flags;
 	void *mssg;
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 	mssg = chan->active_req;
 	chan->active_req = NULL;
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 
 	/* Submit next message */
 	msg_submit(chan);
@@ -338,7 +338,7 @@ struct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)
 		return ERR_PTR(-EBUSY);
 	}
 
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 	chan->msg_free = 0;
 	chan->msg_count = 0;
 	chan->active_req = NULL;
@@ -348,7 +348,7 @@ struct mbox_chan *mbox_request_channel(struct mbox_client *cl, int index)
 	if (chan->txdone_method	== TXDONE_BY_POLL && cl->knows_txdone)
 		chan->txdone_method |= TXDONE_BY_ACK;
 
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 
 	ret = chan->mbox->ops->startup(chan);
 	if (ret) {
@@ -406,14 +406,14 @@ void mbox_free_channel(struct mbox_chan *chan)
 	chan->mbox->ops->shutdown(chan);
 
 	/* The queued TX requests are simply aborted, no callbacks are made */
-	spin_lock_irqsave(&chan->lock, flags);
+	raw_spin_lock_irqsave(&chan->lock, flags);
 	chan->cl = NULL;
 	chan->active_req = NULL;
 	if (chan->txdone_method == (TXDONE_BY_POLL | TXDONE_BY_ACK))
 		chan->txdone_method = TXDONE_BY_POLL;
 
 	module_put(chan->mbox->dev->driver->owner);
-	spin_unlock_irqrestore(&chan->lock, flags);
+	raw_spin_unlock_irqrestore(&chan->lock, flags);
 }
 EXPORT_SYMBOL_GPL(mbox_free_channel);
 
@@ -462,7 +462,7 @@ int mbox_controller_register(struct mbox_controller *mbox)
 		chan->cl = NULL;
 		chan->mbox = mbox;
 		chan->txdone_method = txdone;
-		spin_lock_init(&chan->lock);
+		raw_spin_lock_init(&chan->lock);
 	}
 
 	if (!mbox->of_xlate)
diff --git a/include/linux/mailbox_controller.h b/include/linux/mailbox_controller.h
index 68c4245..45a753e 100644
--- a/include/linux/mailbox_controller.h
+++ b/include/linux/mailbox_controller.h
@@ -121,7 +121,7 @@ struct mbox_chan {
 	void *active_req;
 	unsigned msg_count, msg_free;
 	void *msg_data[MBOX_TX_QUEUE_LEN];
-	spinlock_t lock; /* Serialise access to the channel */
+	raw_spinlock_t lock; /* Serialise access to the channel */
 	void *con_priv;
 };
 
-- 
1.7.5.4

