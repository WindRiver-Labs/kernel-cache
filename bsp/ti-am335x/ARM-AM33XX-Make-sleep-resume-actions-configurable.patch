From f4b13e38e8d67c3c5888db0c56f4f4d0de942ab2 Mon Sep 17 00:00:00 2001
From: Russ Dill <russ.dill@ti.com>
Date: Thu, 23 Jan 2014 01:56:53 -0800
Subject: [PATCH 147/188] ARM: AM33XX: Make sleep/resume actions configurable

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

The sleep33xx assembly code currently executes a sequence of sleep
and resume actions for suspend and standby. In order to extend that
same code to support CPU idle, make the actions performed
configurable based on a set of passed in flags.

Signed-off-by: Russ Dill <russ.dill@ti.com>
(cherry picked from commit e987c001a0317314999b8cb236f7bca358a190d2)
---
 arch/arm/mach-omap2/pm33xx.c    |   25 ++++++++++++---
 arch/arm/mach-omap2/pm33xx.h    |   10 +++++-
 arch/arm/mach-omap2/sleep33xx.S |   62 ++++++++++++++++++++++++++++++++++-----
 3 files changed, 83 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 9939769..a2365b2 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -68,9 +68,9 @@ static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
 
 static struct am33xx_suspend_params susp_params;
 
-static int am33xx_do_sram_idle(long unsigned int unused)
+static int am33xx_do_sram_idle(long unsigned int arg)
 {
-	am33xx_do_wfi_sram(&susp_params);
+	am33xx_do_wfi_sram((struct am33xx_suspend_params *)arg);
 	return 0;
 }
 
@@ -83,7 +83,8 @@ static int am33xx_pm_suspend(unsigned int state)
 
 	am33xx_pm->ops->pre_suspend(state);
 
-	ret = cpu_suspend(0, am33xx_do_sram_idle);
+	ret = cpu_suspend((long unsigned int) &susp_params,
+							am33xx_do_sram_idle);
 
 	am33xx_pm->ops->post_suspend(state);
 
@@ -548,10 +549,24 @@ int __init am33xx_pm_init(void)
 	/* Determine Memory Type */
 	temp = readl(am33xx_emif_base + EMIF_SDRAM_CONFIG);
 	temp = (temp & SDRAM_TYPE_MASK) >> SDRAM_TYPE_SHIFT;
-	/* Parameters to pass to aseembly code */
+	/* Parameters to pass to assembly code */
+	susp_params.wfi_flags = 0;
 	susp_params.emif_addr_virt = am33xx_emif_base;
 	susp_params.dram_sync = am33xx_dram_sync;
-	susp_params.mem_type = temp;
+
+	switch (temp) {
+	case MEM_TYPE_DDR2:
+		susp_params.wfi_flags |= WFI_MEM_TYPE_DDR2;
+		break;
+	case MEM_TYPE_DDR3:
+		susp_params.wfi_flags |= WFI_MEM_TYPE_DDR3;
+		break;
+	}
+	susp_params.wfi_flags |= WFI_SELF_REFRESH;
+	susp_params.wfi_flags |= WFI_SAVE_EMIF;
+	susp_params.wfi_flags |= WFI_DISABLE_EMIF;
+	susp_params.wfi_flags |= WFI_WAKE_M3;
+
 	am33xx_pm->ipc.reg4 = temp & MEM_TYPE_MASK;
 
 	np = of_find_compatible_node(NULL, NULL, "ti,am3353-wkup-m3");
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index 73f42a0..c686703 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -44,7 +44,7 @@ struct am33xx_pm_context {
  */
 struct am33xx_suspend_params {
 	void __iomem *emif_addr_virt;
-	u32 mem_type;
+	u32 wfi_flags;
 	void __iomem *dram_sync;
 	void __iomem *l2_base_virt;
 };
@@ -84,6 +84,14 @@ int wkup_m3_copy_data(const u8 *data, size_t size);
 #define AM43XX_PRM_EMIF_CTRL_OFFSET	0x30
 
 #define MEM_TYPE_DDR2		2
+#define MEM_TYPE_DDR3		3
+
+#define WFI_MEM_TYPE_DDR2	(1 << 0)
+#define WFI_MEM_TYPE_DDR3	(1 << 1)
+#define WFI_SELF_REFRESH	(1 << 2)
+#define WFI_SAVE_EMIF		(1 << 3)
+#define WFI_WAKE_M3		(1 << 4)
+#define WFI_DISABLE_EMIF	(1 << 7)
 
 /*
  * 9-4 = VTT GPIO PIN (6 Bits)
diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
index 36e0745..e44708c 100644
--- a/arch/arm/mach-omap2/sleep33xx.S
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -41,12 +41,12 @@
  * This routine is executed from internal RAM and expects some
  * parameters to be passed in r0 _strictly_ in following order:
  * 1) emif_addr_virt - ioremapped EMIF address
- * 2) mem_type - 2 -> DDR2, 3-> DDR3
+ * 2) wfi_flags - actions to perform
  * 3) dram_sync_word - uncached word in SDRAM
  *
  * The code loads these values taking r0 value as reference to
  * the array in registers starting from r0, i.e emif_addr_virt
- * goes to r1, mem_type goes to r2 and and so on. These are
+ * goes to r1, wfi_flags goes to r2 and and so on. These are
  * then saved into memory locations before proceeding with the
  * sleep sequence and hence registers r0, r1 etc can still be
  * used in the rest of the sleep code.
@@ -59,9 +59,13 @@ ENTRY(am33xx_do_wfi)
 
 	/* Save the values passed */
 	str	r1, emif_addr_virt
-	str	r2, mem_type
+	str	r2, wfi_flags
 	str	r3, dram_sync_word
 
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_sr
+
 	/*
 	 * Flush all data from the L1 and L2 data cache before disabling
 	 * SCTLR.C bit.
@@ -92,6 +96,11 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, [r0, #EMIF_POWER_MANAGEMENT_CTRL_SHDW]
 	str	r1, emif_pmcr_shdw_val
 
+	/* Only necessary if PER is losing context */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SAVE_EMIF
+	beq	skip_save_emif
+
 	/* Save EMIF configuration */
 	ldr	r1, [r0, #EMIF_SDRAM_REFRESH_CONTROL]
 	str	r1, emif_ref_ctrl_val
@@ -106,6 +115,7 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, [r0, #EMIF_DDR_PHY_CTRL_1]
 	str	r1, emif_rd_lat_val
 
+skip_save_emif:
 	/* Put SDRAM in self-refresh */
 	ldr	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
 	bic	r1, r1, #EMIF_POWER_MGMT_SR_TIMER_MASK
@@ -121,6 +131,9 @@ ENTRY(am33xx_do_wfi)
 	ldr	r1, dram_sync_word	@ a dummy access to DDR as per spec
 	ldr	r2, [r1, #0]
 
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_sr
 
 	/* Disable EMIF */
 	ldr	r1, virt_emif_clkctrl
@@ -135,6 +148,11 @@ wait_emif_disable:
 	cmp	r2, r3
 	bne	wait_emif_disable
 
+skip_sr:
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_WAKE_M3
+	beq	skip_m3
+
 	/*
 	 * For the MPU WFI to be registered as an interrupt
 	 * to WKUP_M3, MPU_CLKCTRL.MODULEMODE needs to be set
@@ -145,6 +163,7 @@ wait_emif_disable:
 	bic	r2, r2, #AM33XX_CM_CLKCTRL_MODULEMODE_DISABLE
 	str	r2, [r1]
 
+skip_m3:
 	/*
 	 * Execute an ISB instruction to ensure that all of the
 	 * CP15 register changes have been committed.
@@ -183,11 +202,20 @@ wait_emif_disable:
 	nop
 
 	/* We come here in case of an abort due to a late interrupt */
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_WAKE_M3
 
 	/* Set MPU_CLKCTRL.MODULEMODE back to ENABLE */
-	ldr	r1, virt_mpu_clkctrl
-	mov	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
-	str	r2, [r1]
+	ldrne	r1, virt_mpu_clkctrl
+	movne	r2, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
+	strne	r2, [r1]
+
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_reenable_emif
+
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_emif_enable
 
 	/* Re-enable EMIF */
 	ldr	r1, virt_emif_clkctrl
@@ -198,6 +226,7 @@ wait_emif_enable:
 	cmp	r2, r3
 	bne	wait_emif_enable
 
+skip_emif_enable:
 	/* Disable EMIF self-refresh */
 	ldr	r0, emif_addr_virt
 	ldr	r1, emif_pmcr_val
@@ -218,6 +247,7 @@ wait_emif_enable:
 	mcr	p15, 0, r0, c1, c0, 0
 	isb
 
+skip_reenable_emif:
 	/* Let the suspend code know about the abort */
 	mov	r0, #1
 	ldmfd	sp!, {r4 - r11, pc}	@ restore regs and return
@@ -228,6 +258,13 @@ ENTRY(am33xx_resume_offset)
 	.word . - am33xx_do_wfi
 
 ENTRY(am33xx_resume_from_deep_sleep)
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SELF_REFRESH
+	beq	skip_reenable_emif1
+
+	tst	r2, #WFI_DISABLE_EMIF
+	beq	skip_emif_enable1
+
 	/* Re-enable EMIF */
 	ldr	r0, phys_emif_clkctrl
 	mov	r1, #AM33XX_CM_CLKCTRL_MODULEMODE_ENABLE
@@ -237,8 +274,14 @@ wait_emif_enable1:
 	cmp	r1, r2
 	bne	wait_emif_enable1
 
-	/* Config EMIF Timings */
+skip_emif_enable1:
 	ldr	r0, emif_phys_addr
+
+	ldr	r2, wfi_flags
+	tst	r2, #WFI_SAVE_EMIF
+	beq	skip_restore_emif
+
+	/* Config EMIF Timings */
 	ldr	r1, emif_rd_lat_val
 	str	r1, [r0, #EMIF_DDR_PHY_CTRL_1]
 	str	r1, [r0, #EMIF_DDR_PHY_CTRL_1_SHDW]
@@ -257,6 +300,8 @@ wait_emif_enable1:
 
 	ldr	r1, emif_pmcr_shdw_val
 	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CTRL_SHDW]
+
+skip_restore_emif:
 	/*
 	 * Toggle EMIF to exit refresh mode:
 	 * if EMIF lost context, PWR_MGT_CTRL is currently 0, writing disable
@@ -290,6 +335,7 @@ wait_emif_enable1:
 	tst	r1, #EMIF_STATUS_READY
 	beq	1b
 
+skip_reenable_emif1:
 	/* We are back. Branch to the common CPU resume routine */
 	mov	r0, #0
 	ldr	pc, resume_addr
@@ -321,7 +367,7 @@ module_disabled_val:
 /* DDR related defines */
 dram_sync_word:
 	.word	0xDEADBEEF
-mem_type:
+wfi_flags:
 	.word	0xDEADBEEF
 emif_addr_virt:
 	.word	0xDEADBEEF
-- 
1.7.5.4

