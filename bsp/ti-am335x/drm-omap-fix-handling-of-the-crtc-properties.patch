From d1c533983449e29b787a59bd0e5fb20ac6d5fa95 Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Thu, 27 Aug 2015 13:09:21 +0300
Subject: [PATCH 529/800] drm/omap: fix handling of the crtc properties

We have some properties which are crtc specific, and then we have
properties for planes. The properties for planes are also used for
crtcs.

In omap_crtc.c's omap_crtc_atomic_set_property and
omap_crtc_atomic_set_property we check if the given property is a plane
property, and if so, call the relevant function in the plane object
instead. This check is done by comparing the property to the plane
properties which have been added by omapdrm.

This doesn't work correctly, as there are common properties for planes,
which are added by the DRM framework. Thus common plane properties such
as src_x, rotation, etc. fail our check, and they are handled as crtc
properties, leading to set/get_property returning an error. Which then
breaks the userspace.

This patch fixes the issue by changing the code to check if the given
property is a crtc property. This works much better, as when
omap_crtc_atomic_set/get_property is called, the caller (DRM framework)
has already handled common crtc properties. Thus
omap_crtc_atomic_set/get_property can only check against omapdrm's
private crtc properties.

If that check shows it is not a crtc property,
omap_crtc_atomic_set/get_property routes the call back to DRM framework,
for the plane object. Which then will first handle common plane
properties, and call omap_plane_atomic_set/get_property if necessary.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Reported-by: Robert Nelson <robertcnelson@gmail.com>
Tested-by: Robert Nelson <robertcnelson@gmail.com>
Signed-off-by: Jyri Sarha <jsarha@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/gpu/drm/omapdrm/omap_crtc.c |   65 ++++++++++++++++++-----------------
 1 files changed, 33 insertions(+), 32 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index c3340790..9c26546 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -513,12 +513,13 @@ static void omap_crtc_atomic_destroy_state(struct drm_crtc *crtc,
 	kfree(to_omap_crtc_state(state));
 }
 
-static bool omap_crtc_is_plane_prop(struct omap_drm_private *priv,
+static bool omap_crtc_is_crtc_prop(struct omap_drm_private *priv,
 	struct drm_property *property)
 {
-	return	property == priv->zorder_prop ||
-		property == priv->global_alpha_prop ||
-		property == priv->pre_mult_alpha_prop;
+	return	property == priv->trans_key_mode_prop ||
+		property == priv->trans_key_prop ||
+		property == priv->background_color_prop ||
+		property == priv->alpha_blender_prop;
 }
 
 static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
@@ -529,7 +530,20 @@ static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 	struct omap_drm_private *priv = crtc->dev->dev_private;
 	struct omap_crtc_state *omap_state = to_omap_crtc_state(state);
 
-	if (omap_crtc_is_plane_prop(priv, property)) {
+	if (omap_crtc_is_crtc_prop(priv, property)) {
+		if (property == priv->trans_key_mode_prop)
+			omap_state->trans_key_mode = val;
+		else if (property == priv->trans_key_prop)
+			omap_state->trans_key = val;
+		else if (property == priv->background_color_prop)
+			omap_state->default_color = val;
+		else if (property == priv->alpha_blender_prop)
+			omap_state->partial_alpha_enabled = !!val;
+		else
+			return -EINVAL;
+
+		return 0;
+	} else {
 		struct drm_plane_state *plane_state;
 		struct drm_plane *plane = crtc->primary;
 
@@ -545,19 +559,6 @@ static int omap_crtc_atomic_set_property(struct drm_crtc *crtc,
 		return drm_atomic_plane_set_property(plane, plane_state,
 			property, val);
 	}
-
-	if (property == priv->trans_key_mode_prop)
-		omap_state->trans_key_mode = val;
-	else if (property == priv->trans_key_prop)
-		omap_state->trans_key = val;
-	else if (property == priv->background_color_prop)
-		omap_state->default_color = val;
-	else if (property == priv->alpha_blender_prop)
-		omap_state->partial_alpha_enabled = !!val;
-	else
-		return -EINVAL;
-
-	return 0;
 }
 
 static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
@@ -569,7 +570,20 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 	const struct omap_crtc_state *omap_state =
 		container_of(state, const struct omap_crtc_state, base);
 
-	if (omap_crtc_is_plane_prop(priv, property)) {
+	if (omap_crtc_is_crtc_prop(priv, property)) {
+		if (property == priv->trans_key_mode_prop)
+			*val = omap_state->trans_key_mode;
+		else if (property == priv->trans_key_prop)
+			*val = omap_state->trans_key;
+		else if (property == priv->background_color_prop)
+			*val = omap_state->default_color;
+		else if (property == priv->alpha_blender_prop)
+			*val = omap_state->partial_alpha_enabled;
+		else
+			return -EINVAL;
+
+		return 0;
+	} else {
 		/*
 		 * Delegate property get to the primary plane. The
 		 * drm_atomic_plane_get_property() function isn't exported, but
@@ -579,19 +593,6 @@ static int omap_crtc_atomic_get_property(struct drm_crtc *crtc,
 		return drm_object_property_get_value(&crtc->primary->base,
 			property, val);
 	}
-
-	if (property == priv->trans_key_mode_prop)
-		*val = omap_state->trans_key_mode;
-	else if (property == priv->trans_key_prop)
-		*val = omap_state->trans_key;
-	else if (property == priv->background_color_prop)
-		*val = omap_state->default_color;
-	else if (property == priv->alpha_blender_prop)
-		*val = omap_state->partial_alpha_enabled;
-	else
-		return -EINVAL;
-
-	return 0;
 }
 
 static const struct drm_crtc_funcs omap_crtc_funcs = {
-- 
1.7.5.4

