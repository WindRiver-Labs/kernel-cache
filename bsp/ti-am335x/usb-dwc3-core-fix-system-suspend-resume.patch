From afd8acd3fc49d51b01ecf680a3e9d8be53cbf2da Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Tue, 15 Sep 2015 18:18:52 +0300
Subject: [PATCH 561/800] usb: dwc3: core: fix system suspend/resume

Switching roles before suspend/resume of host
driver is complete was the main culprit breaking
system suspend/resume.

XHCI goes for a toss if the HCD disappears
between xhci_suspend/xhci_resume.

An easy way to get around this is to
prevent any role switch between pm.prepare
and pm.complete.

We need an additional dwc3_drd_start_host(dwc->fsm, true);
after suspend/resume if OTG controller lost its state
otherwise host controller malfunctions.

We can now even detect if usb adapter changed role
during system suspend.

Cc: Felipe Balbi <balbi@ti.com>
Reviewed-by: Felipe Balbi <balbi@ti.com>
Tested-by: Aparna Balasubramanian <aparnab@ti.com>
Signed-off-by: Roger Quadros <rogerq@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/dwc3/core.c |   94 +++++++++++++++++++++++++++++++++++++++++------
 drivers/usb/dwc3/core.h |    2 +
 2 files changed, 84 insertions(+), 12 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 13db777..eea057e 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -836,6 +836,14 @@ static void dwc3_otg_fsm_sync(struct dwc3 *dwc)
 	u32 reg;
 	int id, vbus;
 
+	/*
+	 * calling usb_otg_sync_inputs() during resume breaks host
+	 * if adapter was removed during suspend as xhci driver
+	 * is not prepared to see hcd removal before xhci_resume.
+	 */
+	if (dwc->otg_prevent_sync)
+		return;
+
 	reg = dwc3_readl(dwc->regs, DWC3_OSTS);
 	dev_dbg(dwc->dev, "otgstatus 0x%x\n", reg);
 
@@ -853,21 +861,41 @@ static void dwc3_otg_mask_irq(struct dwc3 *dwc)
 	dwc3_writel(dwc->regs, DWC3_OEVTEN, 0);
 }
 
+#define DWC3_OTG_ALL_EVENTS	(DWC3_OEVTEN_XHCIRUNSTPSETEN | \
+		DWC3_OEVTEN_DEVRUNSTPSETEN | DWC3_OEVTEN_HIBENTRYEN | \
+		DWC3_OEVTEN_CONIDSTSCHNGEN | DWC3_OEVTEN_HRRCONFNOTIFEN | \
+		DWC3_OEVTEN_HRRINITNOTIFEN | DWC3_OEVTEN_ADEVIDLEEN | \
+		DWC3_OEVTEN_ADEVBHOSTENDEN | DWC3_OEVTEN_ADEVHOSTEN | \
+		DWC3_OEVTEN_ADEVHNPCHNGEN | DWC3_OEVTEN_ADEVSRPDETEN | \
+		DWC3_OEVTEN_ADEVSESSENDDETEN | DWC3_OEVTEN_BDEVHOSTENDEN | \
+		DWC3_OEVTEN_BDEVHNPCHNGEN | DWC3_OEVTEN_BDEVSESSVLDDETEN | \
+		DWC3_OEVTEN_BDEVVBUSCHNGE)
+
 static void dwc3_otg_unmask_irq(struct dwc3 *dwc)
 {
-	dwc3_writel(dwc->regs, DWC3_OEVTEN, DWC3_OEVTEN_CONIDSTSCHNGEN |
-			DWC3_OEVTEN_BDEVVBUSCHNGE |
-			DWC3_OEVTEN_BDEVSESSVLDDETEN);
+	dwc3_writel(dwc->regs, DWC3_OEVTEN, DWC3_OTG_ALL_EVENTS);
 }
 
+static int dwc3_drd_start_host(struct otg_fsm *fsm, int on);
+static int dwc3_drd_start_gadget(struct otg_fsm *fsm, int on);
 static irqreturn_t dwc3_otg_thread_irq(int irq, void *_dwc)
 {
 	struct dwc3 *dwc = _dwc;
 	unsigned long flags;
 
+	u32 oevt = dwc->oevt;
 	spin_lock_irqsave(&dwc->lock, flags);
+
+	/*
+	 * this bit is needed for otg-host to work after system suspend/resume
+	 */
+	if (!(oevt & DWC3_OEVT_DEVICEMODE))
+		dwc3_drd_start_host(dwc->fsm, true);
+
 	dwc3_otg_fsm_sync(dwc);
 	dwc3_otg_unmask_irq(dwc);
+
+	dwc->oevt = 0;
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	return IRQ_HANDLED;
@@ -883,6 +911,7 @@ static irqreturn_t dwc3_otg_irq(int irq, void *_dwc)
 
 	reg = dwc3_readl(dwc->regs, DWC3_OEVT);
 	if (reg) {
+		dwc->oevt = reg;
 		dwc3_writel(dwc->regs, DWC3_OEVT, reg);
 		dwc3_otg_mask_irq(dwc);
 		ret = IRQ_WAKE_THREAD;
@@ -899,6 +928,14 @@ static void dwc3_drd_fsm_sync(struct dwc3 *dwc)
 {
 	int id, vbus;
 
+	/*
+	 * calling usb_otg_sync_inputs() during resume breaks host
+	 * if adapter was removed during suspend as xhci driver
+	 * is not prepared to see hcd removal before xhci_resume.
+	 */
+	if (dwc->otg_prevent_sync)
+		return;
+
 	/* get ID */
 	id = extcon_get_cable_state(dwc->edev, "USB-HOST");
 	/* Host means ID == 0 */
@@ -929,6 +966,11 @@ static int dwc3_drd_start_host(struct otg_fsm *fsm, int on)
 
 	/* switch OTG core */
 	if (on) {
+		/* Make sure core won't switch off VBUS automatically */
+		reg = dwc3_readl(dwc->regs, DWC3_OCFG);
+		reg |= DWC3_OCFG_DISPWRCUTTOFF;
+		dwc3_writel(dwc->regs, DWC3_OCFG, reg);
+
 		/* OCTL.PeriMode = 0 */
 		reg = dwc3_readl(dwc->regs, DWC3_OCTL);
 		reg &= ~DWC3_OCTL_PERIMODE;
@@ -945,6 +987,11 @@ static int dwc3_drd_start_host(struct otg_fsm *fsm, int on)
 		reg = dwc3_readl(dwc->regs, DWC3_OCTL);
 		reg |= DWC3_OCTL_PERIMODE;
 		dwc3_writel(dwc->regs, DWC3_OCTL, reg);
+
+		/* allow core to switch off VBUS automatically */
+		reg = dwc3_readl(dwc->regs, DWC3_OCFG);
+		reg &= ~DWC3_OCFG_DISPWRCUTTOFF;
+		dwc3_writel(dwc->regs, DWC3_OCFG, reg);
 	}
 
 	return 0;
@@ -1562,6 +1609,34 @@ static int dwc3_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
+static int dwc3_prepare(struct device *dev)
+{
+	struct dwc3	*dwc = dev_get_drvdata(dev);
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dwc->otg_prevent_sync = true;
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+static void dwc3_complete(struct device *dev)
+{
+	struct dwc3	*dwc = dev_get_drvdata(dev);
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dwc->otg_prevent_sync = false;
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	if (dwc->dr_mode == USB_DR_MODE_OTG) {
+		if (dwc->current_mode == DWC3_GCTL_PRTCAP_OTG)
+			dwc3_otg_fsm_sync(dwc);
+		else
+			dwc3_drd_fsm_sync(dwc);
+	}
+}
+
 static int dwc3_suspend(struct device *dev)
 {
 	struct dwc3	*dwc = dev_get_drvdata(dev);
@@ -1579,7 +1654,6 @@ static int dwc3_suspend(struct device *dev)
 	dwc3_event_buffers_cleanup(dwc);
 
 	dwc->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
-	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	switch (dwc->dr_mode) {
 	case USB_DR_MODE_PERIPHERAL:
@@ -1591,11 +1665,8 @@ static int dwc3_suspend(struct device *dev)
 		switch (dwc->fsm->protocol) {
 		case PROTO_GADGET:
 			dwc3_gadget_suspend(dwc);
-			otg_start_gadget(dwc->fsm, false);
 			break;
 		case PROTO_HOST:
-			otg_start_host(dwc->fsm, false);
-			break;
 		case PROTO_UNDEF:
 		default:
 			/* nothing */
@@ -1607,6 +1678,7 @@ static int dwc3_suspend(struct device *dev)
 		/* nothing */
 		break;
 	}
+	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	usb_phy_shutdown(dwc->usb3_phy);
 	usb_phy_shutdown(dwc->usb2_phy);
@@ -1639,7 +1711,6 @@ static int dwc3_resume(struct device *dev)
 	spin_lock_irqsave(&dwc->lock, flags);
 	dwc3_event_buffers_setup(dwc);
 	dwc3_writel(dwc->regs, DWC3_GCTL, dwc->gctl);
-	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	switch (dwc->dr_mode) {
 	case USB_DR_MODE_PERIPHERAL:
@@ -1649,12 +1720,11 @@ static int dwc3_resume(struct device *dev)
 		switch (dwc->otg_protocol) {
 		case PROTO_GADGET:
 			dwc3_gadget_resume(dwc);
-			otg_start_gadget(dwc->fsm, true);
 			break;
 		case PROTO_HOST:
-			otg_start_host(dwc->fsm, true);
 			break;
 		case PROTO_UNDEF:
+		default:
 			/* nothing */
 			break;
 		}
@@ -1665,13 +1735,11 @@ static int dwc3_resume(struct device *dev)
 		break;
 	}
 
-	spin_lock_irqsave(&dwc->lock, flags);
 	/* Restore OTG state only if we're really using it */
 	if (dwc->current_mode == DWC3_GCTL_PRTCAP_OTG) {
 		dwc3_writel(dwc->regs, DWC3_OCFG, dwc->ocfg);
 		dwc3_writel(dwc->regs, DWC3_OCTL, dwc->octl);
 		dwc3_otg_unmask_irq(dwc);
-		dwc3_otg_fsm_sync(dwc);
 	}
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
@@ -1689,6 +1757,8 @@ err_usb2phy_init:
 
 static const struct dev_pm_ops dwc3_dev_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(dwc3_suspend, dwc3_resume)
+	.prepare = dwc3_prepare,
+	.complete = dwc3_complete,
 };
 
 #define DWC3_PM_OPS	&(dwc3_dev_pm_ops)
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 39e5bb6..3014ed3 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -859,6 +859,7 @@ struct dwc3 {
 	struct extcon_dev	*edev;	/* USB cable events ID & VBUS */
 	struct notifier_block	otg_nb;	/* notifier for USB cable events */
 	struct otg_fsm		*fsm;
+	bool			otg_prevent_sync;
 
 	struct ulpi		*ulpi;
 
@@ -877,6 +878,7 @@ struct dwc3 {
 	u32			gctl;
 	u32			ocfg;
 	u32			octl;
+	u32			oevt;
 
 	u32			current_mode;
 	u32			nr_scratch;
-- 
1.7.5.4

