From e8b77ec7ccb7a261a6ce0b9226ed7b7c6fb47152 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Wed, 22 Jul 2015 20:49:52 +0530
Subject: [PATCH 296/800] ARM: OMAP2+: clockdomain: Add mechanism for
 disabling HW_AUTO

For some hwmods (e.g. DCAN on DRA7) we need the possibility to
disable HW_AUTO for the clockdomain while the module is active.

To achieve this there needs to be a refcounting mechanism to
indicate whether any module in the clockdomain has requested
to disable HW_AUTO. We keep track of this in 'noidlecount'.

Hwmod code must use clkdm_hwmod_prevent_hwauto() to prevent
HW_AUTO of the clockdomain in the future clkdm_hwmod_hwauto() calls.

It must use clkdm_hwmod_allow_hwauto() to allow HW_AUTO in
the future clkdm_hwmod_hwauto() calls.

Hwmod code must use clkdm_hwmod_allow_hwauto() whenever it needs
to request HW_AUTO of any clockdomain. (Typically after it has
enabled the module).

Signed-off-by: Roger Quadros <rogerq@ti.com>
[nsekhar@ti.com: checkpatch cleanup, add kerneldoc style comments]
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/clockdomain.c |   80 +++++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/clockdomain.h |    5 ++
 2 files changed, 85 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/clockdomain.c b/arch/arm/mach-omap2/clockdomain.c
index 2da3b5e..b58808bc 100644
--- a/arch/arm/mach-omap2/clockdomain.c
+++ b/arch/arm/mach-omap2/clockdomain.c
@@ -1213,6 +1213,86 @@ ccd_exit:
 }
 
 /**
+ * clkdm_hwmod_prevent_hwauto - prevent a future hwauto on a clock domain.
+ * @clkdm: struct clockdomain *
+ * @oh: struct omap_hwmod * of the enabled downstream hwmod
+ *
+ * Prevent future hwauto for this clkdm. This will only prevent future hwauto
+ * but not bring it out of hwauto.
+ */
+int clkdm_hwmod_prevent_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh)
+{
+	/* The clkdm attribute does not exist yet prior OMAP4 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return 0;
+
+	if (!clkdm || !oh || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)
+		return -EINVAL;
+
+	pwrdm_lock(clkdm->pwrdm.ptr);
+	clkdm->noidlecount++;
+	pwrdm_unlock(clkdm->pwrdm.ptr);
+
+	return 0;
+}
+
+/**
+ * clkdm_hwmod_allow_hwauto - allow future hwauto for this clkdm
+ * @clkdm: struct clockdomain *
+ * @oh: struct omap_hwmod * of the enabled downstream hwmod
+ *
+ * Allow future hwauto for this clkdm. It won't put clkdm into hwauto.
+ * use clkdm_hwmod_hwauto() for that.
+ */
+int clkdm_hwmod_allow_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh)
+{
+	/* The clkdm attribute does not exist yet prior OMAP4 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return 0;
+
+	if (!clkdm || !oh || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)
+		return -EINVAL;
+
+	pwrdm_lock(clkdm->pwrdm.ptr);
+
+	if (clkdm->noidlecount == 0) {
+		pwrdm_unlock(clkdm->pwrdm.ptr);
+		WARN_ON(1); /* underflow */
+		return -ERANGE;
+	}
+
+	clkdm->noidlecount--;
+	pwrdm_unlock(clkdm->pwrdm.ptr);
+
+	return 0;
+}
+
+/**
+ * clkdm_hwmod_hwauto - put clkdm in hwauto
+ * @clkdm: struct clockdomain *
+ * @oh: struct omap_hwmod * of the enabled downstream hwmod
+ *
+ * Put clkdm in hwauto if we can. Checks noidlecount to see if we can.
+ */
+int clkdm_hwmod_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh)
+{
+	/* The clkdm attribute does not exist yet prior OMAP4 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return 0;
+
+	if (!clkdm || !oh || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)
+		return -EINVAL;
+
+	pwrdm_lock(clkdm->pwrdm.ptr);
+	if (clkdm->noidlecount == 0)
+		clkdm_allow_idle_nolock(clkdm);
+
+	pwrdm_unlock(clkdm->pwrdm.ptr);
+
+	return 0;
+}
+
+/**
  * clkdm_hwmod_enable - add an enabled downstream hwmod to this clkdm
  * @clkdm: struct clockdomain *
  * @oh: struct omap_hwmod * of the enabled downstream hwmod
diff --git a/arch/arm/mach-omap2/clockdomain.h b/arch/arm/mach-omap2/clockdomain.h
index 77bab5f..8c491be 100644
--- a/arch/arm/mach-omap2/clockdomain.h
+++ b/arch/arm/mach-omap2/clockdomain.h
@@ -114,6 +114,7 @@ struct omap_hwmod;
  * @wkdep_srcs: Clockdomains that can be told to wake this powerdomain up
  * @sleepdep_srcs: Clockdomains that can be told to keep this clkdm from inact
  * @usecount: Usecount tracking
+ * @noidlecount: Noidle count tracking. Domain won't be auto idled this is > 0.
  * @node: list_head to link all clockdomains together
  *
  * @prcm_partition should be a macro from mach-omap2/prcm44xx.h (OMAP4 only)
@@ -138,6 +139,7 @@ struct clockdomain {
 	struct clkdm_dep *wkdep_srcs;
 	struct clkdm_dep *sleepdep_srcs;
 	int usecount;
+	int noidlecount;
 	struct list_head node;
 };
 
@@ -211,6 +213,9 @@ int clkdm_clk_enable(struct clockdomain *clkdm, struct clk *clk);
 int clkdm_clk_disable(struct clockdomain *clkdm, struct clk *clk);
 int clkdm_hwmod_enable(struct clockdomain *clkdm, struct omap_hwmod *oh);
 int clkdm_hwmod_disable(struct clockdomain *clkdm, struct omap_hwmod *oh);
+int clkdm_hwmod_prevent_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh);
+int clkdm_hwmod_allow_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh);
+int clkdm_hwmod_hwauto(struct clockdomain *clkdm, struct omap_hwmod *oh);
 
 extern void __init omap242x_clockdomains_init(void);
 extern void __init omap243x_clockdomains_init(void);
-- 
1.7.5.4

