From f78ff403c90e90f1f2492887562c5c000158cc65 Mon Sep 17 00:00:00 2001
From: Misael Lopez Cruz <misael.lopez@ti.com>
Date: Tue, 11 Aug 2015 11:53:59 +0300
Subject: [PATCH 477/800] ARM: edma: HACK: Mark xbar related channels as used

eDMA channels not being used in the platform are assumed to
be without event association.  The ones detected as 'used'
are those from DT nodes whose "dmas" property have a direct
reference to the eDMA controller node.

However, when a DMA crossbar is present the "dmas" property
actually points to the crossbar node, not to the DMA controller.
The DMA crossbar related channels can be identified in the
controller's translation function and marked as 'used' in
the platform.

Due to the current direct mapping between DMA requests and eDMA
channels, it's possible that the DMA channel corresponding to
the crossbar-translated DMA request might have been already
taken by another client.  The conflict might occur if such
client uses memcpy transfer type.

Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/common/edma.c |   20 ++++++++++++++++++--
 1 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 3ddb7d1..5cc8f33 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -1587,6 +1587,18 @@ static struct of_dma_filter_info edma_filter_info = {
 	.filter_fn = edma_filter_fn,
 };
 
+struct dma_chan *edma_of_xlate(struct of_phandle_args *dma_spec,
+			       struct of_dma *ofdma)
+{
+	struct dma_chan *chan = of_dma_simple_xlate(dma_spec, ofdma);
+
+	if (chan)
+		clear_bit(EDMA_CHAN_SLOT(dma_spec->args[0]),
+			  edma_cc[0]->edma_unused);
+
+	return chan;
+}
+
 static struct edma_soc_info *edma_setup_info_from_dt(struct device *dev,
 						      struct device_node *node)
 {
@@ -1603,8 +1615,12 @@ static struct edma_soc_info *edma_setup_info_from_dt(struct device *dev,
 
 	dma_cap_set(DMA_SLAVE, edma_filter_info.dma_cap);
 	dma_cap_set(DMA_CYCLIC, edma_filter_info.dma_cap);
-	of_dma_controller_register(dev->of_node, of_dma_simple_xlate,
-				   &edma_filter_info);
+	if (of_machine_is_compatible("ti,dra7"))
+		of_dma_controller_register(dev->of_node, edma_of_xlate,
+					   &edma_filter_info);
+	else
+		of_dma_controller_register(dev->of_node, of_dma_simple_xlate,
+					   &edma_filter_info);
 
 	return info;
 }
-- 
1.7.5.4

