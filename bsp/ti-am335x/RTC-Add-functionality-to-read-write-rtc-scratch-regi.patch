From f1c9dd721298a2cda6ee55cb306a26ae1c32da6d Mon Sep 17 00:00:00 2001
From: Russ Dill <Russ.Dill@ti.com>
Date: Thu, 6 Aug 2015 12:19:50 +0530
Subject: [PATCH 381/800] RTC: Add functionality to read/write rtc scratch
 registers

Many RTCs provide scratch registers that are maintained so long as the RTC
has power. Provide a generic method to access these registers.

Signed-off-by: Russ Dill <Russ.Dill@ti.com>
[j-keerthy@ti.com] ported to 4.1 with locking/unlocking
Signed-off-by: Keerthy <j-keerthy@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/rtc/interface.c |   48 +++++++++++++++++++++++++++++++++++++++++++++++
 drivers/rtc/rtc-omap.c  |   33 ++++++++++++++++++++++++++++++++
 include/linux/rtc.h     |    7 ++++++
 3 files changed, 88 insertions(+), 0 deletions(-)

diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index 166fc60..69a4674 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -986,4 +986,52 @@ int rtc_timer_cancel(struct rtc_device *rtc, struct rtc_timer *timer)
 	return ret;
 }
 
+/* rtc_read_scratch - Read from RTC scratch register
+ * @ rtc: rtc device to be used
+ * @ index: index of scratch register
+ * @ value: returned value read
+ *
+ * Kernel interface read from an RTC scratch register
+ */
+int rtc_read_scratch(struct rtc_device *rtc, unsigned index, u32 *value)
+{
+	int err;
+
+	mutex_lock(&rtc->ops_lock);
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (index >= rtc->ops->scratch_size || !rtc->ops->read_scratch)
+		err = -EINVAL;
+	else
+		err = rtc->ops->read_scratch(rtc->dev.parent, index, value);
+	mutex_unlock(&rtc->ops_lock);
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_read_scratch);
 
+/* rtc_write_scratch - Write to RTC scratch register
+ * @ rtc: rtc device to be used
+ * @ index: index of scratch register
+ * @ value: value to write
+ *
+ * Kernel interface write to an RTC scratch register
+ */
+int rtc_write_scratch(struct rtc_device *rtc, unsigned index, u32 value)
+{
+	int err;
+
+	mutex_lock(&rtc->ops_lock);
+
+	if (!rtc->ops)
+		err = -ENODEV;
+	else if (index >= rtc->ops->scratch_size ||
+		 !rtc->ops->write_scratch)
+		err = -EINVAL;
+	else
+		err = rtc->ops->write_scratch(rtc->dev.parent, index, value);
+
+	mutex_unlock(&rtc->ops_lock);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(rtc_write_scratch);
diff --git a/drivers/rtc/rtc-omap.c b/drivers/rtc/rtc-omap.c
index cb8936a..4ebc358 100644
--- a/drivers/rtc/rtc-omap.c
+++ b/drivers/rtc/rtc-omap.c
@@ -65,6 +65,10 @@
 #define OMAP_RTC_COMP_MSB_REG		0x50
 #define OMAP_RTC_OSC_REG		0x54
 
+#define OMAP_RTC_SCRATCH0_REG		0x60
+#define OMAP_RTC_SCRATCH1_REG		0x64
+#define OMAP_RTC_SCRATCH2_REG		0x68
+
 #define OMAP_RTC_KICK0_REG		0x6c
 #define OMAP_RTC_KICK1_REG		0x70
 
@@ -403,6 +407,32 @@ static int omap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 
 static struct omap_rtc *omap_rtc_power_off_rtc;
 
+static const u32 omap_rtc_scratch_regs[] = {
+	OMAP_RTC_SCRATCH0_REG,
+	OMAP_RTC_SCRATCH1_REG,
+	OMAP_RTC_SCRATCH2_REG,
+};
+
+static int omap_rtc_read_scratch(struct device *dev, unsigned index, u32 *value)
+{
+	*value = readl(omap_rtc_power_off_rtc->base +
+		       omap_rtc_scratch_regs[index]);
+
+	return 0;
+}
+
+static int omap_rtc_write_scratch(struct device *dev, unsigned index, u32 value)
+{
+	struct omap_rtc *rtc = dev_get_drvdata(dev);
+
+	rtc->type->unlock(rtc);
+	writel(value, omap_rtc_power_off_rtc->base +
+	       omap_rtc_scratch_regs[index]);
+	rtc->type->lock(rtc);
+
+	return 0;
+}
+
 /*
  * omap_rtc_poweroff: RTC-controlled power off
  *
@@ -473,6 +503,9 @@ static struct rtc_class_ops omap_rtc_ops = {
 	.read_alarm	= omap_rtc_read_alarm,
 	.set_alarm	= omap_rtc_set_alarm,
 	.alarm_irq_enable = omap_rtc_alarm_irq_enable,
+	.read_scratch	= omap_rtc_read_scratch,
+	.write_scratch	= omap_rtc_write_scratch,
+	.scratch_size	= ARRAY_SIZE(omap_rtc_scratch_regs),
 };
 
 static const struct omap_rtc_device_type omap_rtc_default_type = {
diff --git a/include/linux/rtc.h b/include/linux/rtc.h
index 8dcf682..2409bd5 100644
--- a/include/linux/rtc.h
+++ b/include/linux/rtc.h
@@ -81,6 +81,10 @@ struct rtc_class_ops {
 	int (*set_mmss)(struct device *, unsigned long secs);
 	int (*read_callback)(struct device *, int data);
 	int (*alarm_irq_enable)(struct device *, unsigned int enabled);
+	int (*read_scratch)(struct device *, unsigned int, u32*);
+	int (*write_scratch)(struct device *, unsigned int, u32);
+
+	unsigned int scratch_size;
 };
 
 #define RTC_DEVICE_NAME_SIZE 20
@@ -204,6 +208,9 @@ int rtc_timer_start(struct rtc_device *rtc, struct rtc_timer* timer,
 int rtc_timer_cancel(struct rtc_device *rtc, struct rtc_timer* timer);
 void rtc_timer_do_work(struct work_struct *work);
 
+int rtc_read_scratch(struct rtc_device *rtc, unsigned index, u32 *value);
+int rtc_write_scratch(struct rtc_device *rtc, unsigned index, u32 value);
+
 static inline bool is_leap_year(unsigned int year)
 {
 	return (!(year % 4) && (year % 100)) || !(year % 400);
-- 
1.7.5.4

