From 093fbb53cfd7919f3935c529be9252fe9656dbc7 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Mon, 9 Nov 2015 17:25:54 -0600
Subject: [PATCH 658/800] remoteproc: add infrastructure to support user-space
 loading/booting

The remoteproc infrastructure is enhanced to allow remoteproc drivers
to support userspace driven loading and booting mechanism. This is
done in preparation for a new remoteproc driver on TI Keystone2 SoCs.

A new field 'use_userspace_loader' is added to the rproc structure,
and this field is expected to be set by remoteproc drivers wishing
to bypass the in-kernel loading and boot mechanism. The remoteproc
core skips processing of any virtio devices or looking for firmware
or loading firmware segments using this state flag.

Two new API, rproc_add_vdevs_direct() and rproc_remove_vdevs_direct()
are added to allow the remoteproc drivers to trigger the processing
of the resource table. These API are expected to be invoked by the
remoteproc drivers after the loading is completed and the resource
table information is published to the remoteproc driver. The interface
and implementation details to userspace is left to the individual
remoteproc driver.

Signed-off-by: Sam Nelson <sam.nelson@ti.com>
Signed-off-by: Suman Anna <s-anna@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/remoteproc/remoteproc_core.c |   98 +++++++++++++++++++++++++++------
 include/linux/remoteproc.h           |    4 ++
 2 files changed, 84 insertions(+), 18 deletions(-)

diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index 8656094..1f4a6d6 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -1138,7 +1138,11 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 	if (ret)
 		return ret;
 
-	dev_info(dev, "Booting fw image %s, size %zd\n", name, fw->size);
+	if (!rproc->use_userspace_loader)
+		dev_info(dev, "Booting fw image %s, size %zd\n",
+			 name, fw->size);
+	else
+		dev_info(dev, "Booting unspecified pre-loaded fw image\n");
 
 	/*
 	 * if enabling an IOMMU isn't relevant for this rproc, this is
@@ -1181,12 +1185,14 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 			goto clean_up;
 		}
 	}
-
-	/* load the ELF segments to memory */
-	ret = rproc_load_segments(rproc, fw);
-	if (ret) {
-		dev_err(dev, "Failed to load program segments: %d\n", ret);
-		goto clean_up;
+	if (!rproc->use_userspace_loader) {
+		/* load the ELF segments to memory */
+		ret = rproc_load_segments(rproc, fw);
+		if (ret) {
+			dev_err(dev, "Failed to load program segments: %d\n",
+				ret);
+			goto clean_up;
+		}
 	}
 
 	/*
@@ -1287,14 +1293,65 @@ static void rproc_fw_config_virtio(const struct firmware *fw, void *context)
 
 out:
 	release_firmware(fw);
-	/* allow rproc_del() contexts, if any, to proceed */
-	complete_all(&rproc->firmware_loading_complete);
+	if (!rproc->use_userspace_loader) {
+		/* allow rproc_del() contexts, if any, to proceed */
+		complete_all(&rproc->firmware_loading_complete);
+	}
+}
+
+/**
+ * rproc_add_vdevs_direct() - add virtio devices directly from a resource table
+ * @rproc: handle of a remote processor
+ *
+ * This function is added to support remoteproc drivers using userspace loaders
+ * to process a published resource table directly and add the virtio devices for
+ * supporting the virtio rpmsg infrastructure. The firmwares are not looked up
+ * and processed by the remoteproc core for such drivers.
+ *
+ * The remoteproc drivers are expected to undo the addition using the
+ * @rproc_remove_vdevs_direct() function.
+ */
+void rproc_add_vdevs_direct(struct rproc *rproc)
+{
+	if (!rproc->use_userspace_loader) {
+		dev_err(&rproc->dev, "cannot be called on rprocs supporting in-kernel loader!\n");
+		return;
+	}
+
+	rproc_fw_config_virtio(NULL, (void *)rproc);
 }
+EXPORT_SYMBOL(rproc_add_vdevs_direct);
+
+/**
+ * rproc_remove_vdevs_direct() - remove virtio devices directly
+ * @rproc: handle of a remote processor
+ *
+ * This function is added to support remoteproc drivers using userspace
+ * loaders to remove any directly added virtio devices through the
+ * @rproc_add_vdevs_direct() function.
+ */
+void rproc_remove_vdevs_direct(struct rproc *rproc)
+{
+	struct rproc_vdev *rvdev, *tmp;
+
+	if (!rproc->use_userspace_loader) {
+		dev_err(&rproc->dev, "cannot be called on rprocs supporting in-kernel loader!\n");
+		return;
+	}
+
+	list_for_each_entry_safe(rvdev, tmp, &rproc->rvdevs, node)
+		rproc_remove_virtio_dev(rvdev);
+}
+EXPORT_SYMBOL(rproc_remove_vdevs_direct);
 
 static int rproc_add_virtio_devices(struct rproc *rproc)
 {
 	int ret;
 
+	/* nothing to do if relying on external userspace loader */
+	if (rproc->use_userspace_loader)
+		return 0;
+
 	/* rproc_del() calls must wait until async loader completes */
 	init_completion(&rproc->firmware_loading_complete);
 
@@ -1413,7 +1470,7 @@ EXPORT_SYMBOL(rproc_get_alias_id);
  */
 int rproc_boot(struct rproc *rproc)
 {
-	const struct firmware *firmware_p;
+	const struct firmware *firmware_p = NULL;
 	struct device *dev;
 	int ret;
 
@@ -1452,16 +1509,19 @@ int rproc_boot(struct rproc *rproc)
 
 	dev_info(dev, "powering up %s\n", rproc->name);
 
-	/* load firmware */
-	ret = request_firmware(&firmware_p, rproc->firmware, dev);
-	if (ret < 0) {
-		dev_err(dev, "request_firmware failed: %d\n", ret);
-		goto downref_rproc;
+	if (!rproc->use_userspace_loader) {
+		/* load firmware */
+		ret = request_firmware(&firmware_p, rproc->firmware, dev);
+		if (ret < 0) {
+			dev_err(dev, "request_firmware failed: %d\n", ret);
+			goto downref_rproc;
+		}
 	}
 
 	ret = rproc_fw_boot(rproc, firmware_p);
 
-	release_firmware(firmware_p);
+	if (!rproc->use_userspace_loader)
+		release_firmware(firmware_p);
 
 downref_rproc:
 	if (ret) {
@@ -1802,8 +1862,10 @@ int rproc_del(struct rproc *rproc)
 	if (!rproc)
 		return -EINVAL;
 
-	/* if rproc is just being registered, wait */
-	wait_for_completion(&rproc->firmware_loading_complete);
+	if (!rproc->use_userspace_loader) {
+		/* if rproc is just being registered, wait */
+		wait_for_completion(&rproc->firmware_loading_complete);
+	}
 
 	/* clean up remote vdev entries */
 	list_for_each_entry_safe(rvdev, tmp, &rproc->rvdevs, node)
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index bb80c2d..febc06d 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -488,6 +488,7 @@ enum rproc_crash_type {
  * @table_csum: checksum of the resource table
  * @fw_version: human readable version information extracted from f/w
  * @has_iommu: flag to indicate if remote processor is behind an MMU
+ * @use_userspace_loader: flag to denote if remoteproc is loaded by userspace
  */
 struct rproc {
 	struct list_head node;
@@ -523,6 +524,7 @@ struct rproc {
 	u32 table_csum;
 	char *fw_version;
 	bool has_iommu;
+	bool use_userspace_loader;
 };
 
 /* we currently support only two vrings per rvdev */
@@ -581,6 +583,8 @@ void rproc_report_crash(struct rproc *rproc, enum rproc_crash_type type);
 struct rproc *rproc_vdev_to_rproc_safe(struct virtio_device *vdev);
 int rproc_get_alias_id(struct rproc *rproc);
 int rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da);
+void rproc_add_vdevs_direct(struct rproc *rproc);
+void rproc_remove_vdevs_direct(struct rproc *rproc);
 
 static inline struct rproc_vdev *vdev_to_rvdev(struct virtio_device *vdev)
 {
-- 
1.7.5.4

