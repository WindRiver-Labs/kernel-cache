From 643ceb5dcc652403f1746fe55562531553e5d71e Mon Sep 17 00:00:00 2001
From: Russ Dill <russ.dill@ti.com>
Date: Thu, 23 Jan 2014 01:56:56 -0800
Subject: [PATCH 154/188] ARM: AM33XX: Add CPU idle support

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

This patch adds support for CPU idle on am335x. It has been tested with
Beaglebone Black, Beaglebone White, a PG1.x DDR2 am335x-evm and a PG2.x
DDR3 am335x-evm. The patchset supports putting the MPU PLL into bypass,
putting the MPU into retension mode, and putting the DDR into self
refresh.

The EMIF can bring the DDR out of self refresh when it needs to service
a DMA request. However, for maximum power savings on DDR3 systems, extra
steps need to be performed that the EMIF cannot reverse on its own.
Because of this, two separate sets of CPU idle states are provided, one
for DDR2 systems, and one for DDR3 systems. The DDR3 states do not
include self refresh alone as this actually increases power consumption.

It would be possible to increase DDR3 power savings if the am33xx CPU
idle code were able to detect if there were any potential EMIF users
before allowing deeper DDR3 states.

Signed-off-by: Russ Dill <russ.dill@ti.com>
(cherry picked from commit eadd1cc9a9b84eb6c9b9646578eb3b1054021836)
---
 arch/arm/mach-omap2/Makefile      |    1 +
 arch/arm/mach-omap2/cpuidle33xx.c |  141 +++++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/pm.h          |    6 ++
 arch/arm/mach-omap2/pm33xx.c      |   89 ++++++++++++++++++------
 arch/arm/mach-omap2/pm33xx.h      |   14 ++++
 5 files changed, 230 insertions(+), 21 deletions(-)
 create mode 100644 arch/arm/mach-omap2/cpuidle33xx.c

diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 8a01e91..4222f2d 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -108,6 +108,7 @@ AFLAGS_sleep43xx.o			:=-Wa,-march=armv7-a$(plus_sec)
 endif
 
 ifeq ($(CONFIG_CPU_IDLE),y)
+obj-$(CONFIG_SOC_AM33XX)                += cpuidle33xx.o
 obj-$(CONFIG_ARCH_OMAP3)                += cpuidle34xx.o
 obj-$(CONFIG_ARCH_OMAP4)                += cpuidle44xx.o
 endif
diff --git a/arch/arm/mach-omap2/cpuidle33xx.c b/arch/arm/mach-omap2/cpuidle33xx.c
new file mode 100644
index 0000000..8492c60
--- /dev/null
+++ b/arch/arm/mach-omap2/cpuidle33xx.c
@@ -0,0 +1,141 @@
+/*
+ * AM33XX CPU idle Routines
+ *
+ * Copyright (C) 2011-2013 Texas Instruments, Inc.
+ * Santosh Shilimkar <santosh.shilimkar@ti.com>
+ * Rajendra Nayak <rnayak@ti.com>
+ * Russ Dill <russ.dill@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/cpuidle.h>
+#include <linux/cpu_pm.h>
+
+#include "common.h"
+#include "pm33xx.h"
+#include "powerdomain.h"
+
+#define AM33XX_FLAG_MPU_PLL		BIT(16)
+#define AM33XX_FLAG_SELF_REFRESH	BIT(17)
+#define AM33XX_FLAG_DISABLE_EMIF	BIT(18)
+
+static int am33xx_enter_idle(struct cpuidle_device *dev,
+					struct cpuidle_driver *drv, int index)
+{
+	struct cpuidle_state *state;
+	u32 wfi_flags = 0;
+	u32 m3_flags = 0;
+
+	if (omap_irq_pending() || need_resched())
+		return index;
+
+	state = &drv->states[index];
+
+	if (state->flags & AM33XX_FLAG_SELF_REFRESH)
+		wfi_flags |= WFI_SELF_REFRESH;
+
+	if (state->flags & AM33XX_FLAG_DISABLE_EMIF)
+		wfi_flags |= WFI_DISABLE_EMIF;
+
+	if (state->flags & AM33XX_FLAG_MPU_PLL) {
+		wfi_flags |= WFI_WAKE_M3;
+		m3_flags = PWRDM_POWER_ON << M3_PARAM2_MPU_STATE_SHIFT |
+			MEM_BANK_RET_ST_OFF << M3_PARAM2_MPU_RAM_RET_SHIFT |
+			MEM_BANK_RET_ST_RET << M3_PARAM2_MPU_L1_RET_SHIFT |
+			MEM_BANK_RET_ST_RET << M3_PARAM2_MPU_L2_RET_SHIFT |
+			PWRDM_POWER_ON << M3_PARAM2_PER_STATE_SHIFT |
+			MPU_WAKE << M3_PARAM2_WAKE_SOURCES_SHIFT;
+	}
+
+	am33xx_do_sram_cpuidle(wfi_flags, m3_flags);
+
+	return index;
+}
+
+/* Power usage measured as a combination of CPU and DDR power rails */
+struct cpuidle_state am33xx_ddr2_states[] = {
+	{
+		.exit_latency = 72,
+		.target_residency = 150,
+		.power_usage = 625,
+		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.enter = am33xx_enter_idle,
+		.name = "C0",
+		.desc = "WFI",
+	},
+	{
+		.exit_latency = 176,
+		.target_residency = 300,
+		.power_usage = 562,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL,
+		.enter = am33xx_enter_idle,
+		.name = "C1",
+		.desc = "Bypass MPU PLL",
+	},
+	{
+		.exit_latency = 390,
+		.target_residency = 500,
+		.power_usage = 529,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL |
+				AM33XX_FLAG_SELF_REFRESH,
+		.enter = am33xx_enter_idle,
+		.name = "C1+SR",
+		.desc = "Bypass MPU PLL + DDR SR",
+	},
+};
+
+struct cpuidle_state am33xx_ddr3_states[] = {
+	{
+		.exit_latency = 68,
+		.target_residency = 150,
+		.power_usage = 557,
+		.flags = CPUIDLE_FLAG_TIME_VALID,
+		.enter = am33xx_enter_idle,
+		.name = "C0",
+		.desc = "WFI",
+	},
+	{
+		.exit_latency = 130,
+		.target_residency = 200,
+		.power_usage = 497,
+		.flags = CPUIDLE_FLAG_TIME_VALID | AM33XX_FLAG_MPU_PLL,
+		.enter = am33xx_enter_idle,
+		.name = "C1",
+		.desc = "Bypass MPU PLL",
+	},
+};
+
+static struct cpuidle_driver am33xx_idle_driver = {
+	.name		= "am33xx_idle",
+	.owner		= THIS_MODULE,
+};
+
+/**
+ * am33xx_idle_init - Init routine for am33xx idle
+ *
+ * Registers the am33xx specific cpuidle driver to the cpuidle
+ * framework with the valid set of states.
+ */
+int am33xx_idle_init(bool ddr3)
+{
+	if (ddr3) {
+		BUILD_BUG_ON(ARRAY_SIZE(am33xx_ddr3_states) >
+					ARRAY_SIZE(am33xx_idle_driver.states));
+		memcpy(am33xx_idle_driver.states, am33xx_ddr3_states,
+		       sizeof(am33xx_ddr3_states));
+		am33xx_idle_driver.state_count =
+						ARRAY_SIZE(am33xx_ddr3_states);
+	} else {
+		BUILD_BUG_ON(ARRAY_SIZE(am33xx_ddr2_states) >
+					ARRAY_SIZE(am33xx_idle_driver.states));
+		memcpy(am33xx_idle_driver.states, am33xx_ddr2_states,
+		       sizeof(am33xx_ddr2_states));
+		am33xx_idle_driver.state_count =
+						ARRAY_SIZE(am33xx_ddr2_states);
+	}
+	return cpuidle_register(&am33xx_idle_driver, NULL);
+}
diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 0a8c4f0..f91ddda 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -16,9 +16,15 @@
 #include "powerdomain.h"
 
 #ifdef CONFIG_CPU_IDLE
+int __init am33xx_idle_init(bool ddr3);
 extern int __init omap3_idle_init(void);
 extern int __init omap4_idle_init(void);
 #else
+static inline int am33xx_idle_init(bool ddr3)
+{
+	return 0;
+}
+
 static inline int omap3_idle_init(void)
 {
 	return 0;
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index a2365b2..1996e32 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -50,7 +50,6 @@
 
 #ifdef CONFIG_SUSPEND
 static void __iomem *scu_base;
-static void __iomem *am33xx_emif_base;
 static struct powerdomain *mpu_pwrdm, *per_pwrdm, *gfx_pwrdm;
 static struct clockdomain *gfx_l4ls_clkdm;
 static struct clockdomain *l3s_clkdm, *l4fw_clkdm, *clk_24mhz_clkdm;
@@ -59,7 +58,10 @@ static char *am33xx_i2c_sleep_sequence;
 static char *am33xx_i2c_wake_sequence;
 static size_t i2c_sleep_sequence_sz;
 static size_t i2c_wake_sequence_sz;
+#endif /* CONFIG_SUSPEND */
 
+#ifdef CONFIG_CPU_PM
+static void __iomem *am33xx_emif_base;
 static struct am33xx_pm_context *am33xx_pm;
 
 static DECLARE_COMPLETION(am33xx_pm_sync);
@@ -68,6 +70,41 @@ static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
 
 static struct am33xx_suspend_params susp_params;
 
+int am33xx_do_sram_cpuidle(u32 wfi_flags, u32 m3_flags)
+{
+	struct am33xx_suspend_params params;
+	int ret;
+
+	/* Start with the default flags */
+	memcpy(&params, &susp_params, sizeof(params));
+
+	/* Clear bits configurable through this call */
+	params.wfi_flags &= ~(WFI_SELF_REFRESH | WFI_WAKE_M3 | WFI_SAVE_EMIF |
+							WFI_DISABLE_EMIF);
+
+	/* Don't enter these states if the M3 isn't available */
+	if (am33xx_pm->state != M3_STATE_INITED)
+		wfi_flags &= ~WFI_WAKE_M3;
+
+	/* Set bits that have been passed */
+	params.wfi_flags |= wfi_flags;
+
+	if (wfi_flags & WFI_WAKE_M3) {
+		am33xx_pm->ipc.reg1 = IPC_CMD_IDLE;
+		am33xx_pm->ipc.reg2 = DS_IPC_DEFAULT;
+		am33xx_pm->ipc.reg3 = m3_flags;
+		am33xx_pm->ipc.reg5 = DS_IPC_DEFAULT;
+		wkup_m3_pm_set_cmd(&am33xx_pm->ipc);
+		ret = wkup_m3_ping_noirq();
+		if (ret < 0)
+			return ret;
+	}
+
+	am33xx_do_wfi_sram(&params);
+	return 0;
+}
+
+#ifdef CONFIG_SUSPEND
 static int am33xx_do_sram_idle(long unsigned int arg)
 {
 	am33xx_do_wfi_sram((struct am33xx_suspend_params *)arg);
@@ -246,6 +283,7 @@ static const struct platform_suspend_ops am33xx_pm_ops = {
 	.enter		= am33xx_pm_enter,
 	.valid		= am33xx_pm_valid,
 };
+#endif /* CONFIG_SUSPEND */
 
 static void am33xx_txev_handler(void)
 {
@@ -296,7 +334,11 @@ static void am33xx_m3_fw_ready_cb(void)
 					am33xx_pm->ver);
 	}
 
+	am33xx_idle_init(susp_params.wfi_flags & WFI_MEM_TYPE_DDR3);
+
+#ifdef CONFIG_SUSPEND
 	suspend_set_ops(&am33xx_pm_ops);
+#endif /* CONFIG_SUSPEND */
 }
 
 static struct wkup_m3_ops am33xx_wkup_m3_ops = {
@@ -329,6 +371,7 @@ static int __init am33xx_map_emif(void)
 	return 0;
 }
 
+#ifdef CONFIG_SUSPEND
 static int __init am43xx_map_scu(void)
 {
 	scu_base = ioremap(scu_a9_get_base(), SZ_256);
@@ -494,19 +537,34 @@ static struct am33xx_pm_ops am43xx_ops = {
 	.post_suspend = am43xx_post_suspend,
 };
 #endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 
 int __init am33xx_pm_init(void)
 {
 	struct powerdomain *cefuse_pwrdm;
-#ifdef CONFIG_SUSPEND
+#ifdef CONFIG_CPU_PM
 	int ret;
 	u32 temp;
 	struct device_node *np;
-#endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 
 	if (!soc_is_am33xx() && !soc_is_am43xx())
 		return -ENODEV;
 
+#ifdef CONFIG_CPU_PM
+	am33xx_pm = kzalloc(sizeof(*am33xx_pm), GFP_KERNEL);
+	if (!am33xx_pm) {
+		pr_err("Memory allocation failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = am33xx_map_emif();
+	if (ret) {
+		pr_err("PM: Could not ioremap EMIF\n");
+		goto err;
+	}
+
 #ifdef CONFIG_SUSPEND
 	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
 	per_pwrdm = pwrdm_lookup("per_pwrdm");
@@ -517,14 +575,6 @@ int __init am33xx_pm_init(void)
 		goto err;
 	}
 
-
-	am33xx_pm = kzalloc(sizeof(*am33xx_pm), GFP_KERNEL);
-	if (!am33xx_pm) {
-		pr_err("Memory allocation failed\n");
-		ret = -ENOMEM;
-		return ret;
-	}
-
 	/*
 	 * Code paths for each SoC are nearly the same but set ops
 	 * handle differences during init, pre-suspend, and post-suspend
@@ -539,12 +589,7 @@ int __init am33xx_pm_init(void)
 
 	if (ret)
 		goto err;
-
-	ret = am33xx_map_emif();
-	if (ret) {
-		pr_err("PM: Could not ioremap EMIF\n");
-		goto err;
-	}
+#endif /* CONFIG_SUSPEND */
 
 	/* Determine Memory Type */
 	temp = readl(am33xx_emif_base + EMIF_SDRAM_CONFIG);
@@ -583,12 +628,14 @@ int __init am33xx_pm_init(void)
 		}
 	}
 
+#ifdef CONFIG_SUSPEND
 	ret = am33xx_setup_sleep_sequence();
 	if (ret) {
 		pr_err("Error fetching I2C sleep/wake sequence\n");
 		goto err;
 	}
 #endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 
 	(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);
 
@@ -599,7 +646,7 @@ int __init am33xx_pm_init(void)
 	else
 		pr_err("PM: Failed to get cefuse_pwrdm\n");
 
-#ifdef CONFIG_SUSPEND
+#ifdef CONFIG_CPU_PM
 	am33xx_pm->state = M3_STATE_RESET;
 
 	wkup_m3_set_ops(&am33xx_wkup_m3_ops);
@@ -609,13 +656,13 @@ int __init am33xx_pm_init(void)
 
 	if (wkup_m3_is_valid())
 		am33xx_m3_fw_ready_cb();
-#endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 
 	return 0;
 
-#ifdef CONFIG_SUSPEND
+#ifdef CONFIG_CPU_PM
 err:
 	kfree(am33xx_pm);
 	return ret;
-#endif /* CONFIG_SUSPEND */
+#endif /* CONFIG_CPU_PM */
 }
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index da2b7c2..6a71b0e 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -51,11 +51,13 @@ struct am33xx_suspend_params {
 
 void wkup_m3_reset_data_pos(void);
 int wkup_m3_copy_data(const u8 *data, size_t size);
+int am33xx_do_sram_cpuidle(u32, u32);
 
 #endif
 
 #define	IPC_CMD_DS0			0x4
 #define	IPC_CMD_STANDBY			0xc
+#define	IPC_CMD_IDLE			0xd
 #define IPC_CMD_RESET			0xe
 #define DS_IPC_DEFAULT			0xffffffff
 #define M3_VERSION_UNKNOWN		0x0000ffff
@@ -105,4 +107,16 @@ int wkup_m3_copy_data(const u8 *data, size_t size);
 #define VTT_GPIO_PIN_SHIFT	(0x4)
 #define VTT_GPIO_PIN_MASK	(0x3f << 4)
 
+#define MPU_WAKE		0x800
+
+#define MEM_BANK_RET_ST_OFF		0x0
+#define MEM_BANK_RET_ST_RET		0x1
+
+#define M3_PARAM2_MPU_STATE_SHIFT	0
+#define M3_PARAM2_MPU_RAM_RET_SHIFT	2
+#define M3_PARAM2_MPU_L1_RET_SHIFT	3
+#define M3_PARAM2_MPU_L2_RET_SHIFT	4
+#define M3_PARAM2_PER_STATE_SHIFT	7
+#define M3_PARAM2_WAKE_SOURCES_SHIFT	18
+
 #endif
-- 
1.7.5.4

