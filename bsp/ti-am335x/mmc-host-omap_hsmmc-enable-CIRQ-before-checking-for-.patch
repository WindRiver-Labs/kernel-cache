From f24229117e3232c0dfe894fbd7c1b003f0e7cb6e Mon Sep 17 00:00:00 2001
From: Kishon Vijay Abraham I <kishon@ti.com>
Date: Tue, 3 Nov 2015 18:16:44 +0530
Subject: [PATCH 633/800] mmc: host: omap_hsmmc: enable CIRQ before checking
 for CLEV/DLEV

MMC module can sense when the clock lines and data lines are
driven high by the card, if MMC is active and CIRQ can be used to keep
the MMC module active. This is required for voltage switching to
succeed and the card to enumerate in UHS mode.

Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/mmc/host/omap_hsmmc.c |   27 +++++++++++++++++++++------
 1 files changed, 21 insertions(+), 6 deletions(-)

diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index d865e6b..3acf60c 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -244,6 +244,7 @@ struct omap_hsmmc_host {
 	unsigned int		flags;
 #define AUTO_CMD23		(1 << 0)        /* Auto CMD23 support */
 #define HSMMC_SDIO_IRQ_ENABLED	(1 << 1)        /* SDIO irq enabled */
+#define CLKEXTFREE_ENABLED	(1 << 2)        /* CLKEXTFREE enabled */
 	struct omap_hsmmc_next	next_data;
 	struct	omap_hsmmc_platform_data	*pdata;
 	/*
@@ -645,8 +646,8 @@ static void omap_hsmmc_enable_irq(struct omap_hsmmc_host *host,
 	unsigned long flags;
 	bool is_tuning;
 
-	is_tuning = (cmd->opcode == MMC_SEND_TUNING_BLOCK) ||
-		    (cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200);
+	is_tuning = cmd && ((cmd->opcode == MMC_SEND_TUNING_BLOCK) ||
+		    (cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200));
 
 	if (is_tuning)
 		/*
@@ -661,9 +662,12 @@ static void omap_hsmmc_enable_irq(struct omap_hsmmc_host *host,
 		irq_mask &= ~(BRR_EN | BWR_EN);
 
 	/* Disable timeout for erases or when using software timeout */
-	if (cmd->opcode == MMC_ERASE || host->need_i834_errata)
+	if (cmd && (cmd->opcode == MMC_ERASE || host->need_i834_errata))
 		irq_mask &= ~DTO_EN;
 
+	if (host->flags & CLKEXTFREE_ENABLED)
+		irq_mask |= CIRQ_EN;
+
 	spin_lock_irqsave(&host->irq_lock, flags);
 	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
 	OMAP_HSMMC_WRITE(host->base, ISE, irq_mask);
@@ -2114,11 +2118,16 @@ static int omap_hsmmc_card_busy_high(struct omap_hsmmc_host *host)
 {
 	int i;
 	u32 val;
+	int ret = true;
 
 	val = OMAP_HSMMC_READ(host->base, CON);
 	val |= CLKEXTFREE;
 	OMAP_HSMMC_WRITE(host->base, CON, val);
 
+	host->flags |= CLKEXTFREE_ENABLED;
+	disable_irq(host->irq);
+	omap_hsmmc_enable_irq(host, NULL);
+
 	/* By observation, card busy status reflects in 100 - 200us */
 	for (i = 0; i < 5; i++) {
 		val = OMAP_HSMMC_READ(host->base, PSTATE);
@@ -2126,15 +2135,21 @@ static int omap_hsmmc_card_busy_high(struct omap_hsmmc_host *host)
 			val = OMAP_HSMMC_READ(host->base, CON);
 			val &= ~(CON_CLKEXTFREE | CON_PADEN);
 			OMAP_HSMMC_WRITE(host->base, CON, val);
-			return false;
+			ret = false;
+			goto disable_irq;
 		}
 
 		usleep_range(100, 200);
 	}
 
-	dev_dbg(mmc_dev(host->mmc), "card busy\n");
+	dev_err(mmc_dev(host->mmc), "card busy\n");
 
-	return true;
+disable_irq:
+	omap_hsmmc_disable_irq(host);
+	enable_irq(host->irq);
+	host->flags &= ~CLKEXTFREE_ENABLED;
+
+	return ret;
 }
 
 static int omap_hsmmc_card_busy(struct mmc_host *mmc)
-- 
1.7.5.4

