From 96a223e8a68932006c403b77ffd33599327d94ab Mon Sep 17 00:00:00 2001
From: John Ogness <john.ogness@linutronix.de>
Date: Sat, 7 Nov 2015 18:55:15 +0530
Subject: [PATCH 659/800] serial: 8250: add optional spinlock arg to
 serial8250_rx_chars

serial8250_rx_chars() must be called from interrupt context and with
the port lock held. The port lock is released temporarily at the end
in order to call tty_flip_buffer_push(). However there may be other
drivers that need to synchronize tty_flip_buffer_push() with other
contexts. Since the port lock cannot be used for this synchronization,
an optional spinlock argument is added. If non-NULL, this will be
locked during the tty_flip_buffer_push() call.

Signed-off-by: John Ogness <john.ogness@linutronix.de>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/tty/serial/8250/8250_core.c |    9 +++++++--
 drivers/tty/serial/8250/8250_fsl.c  |    2 +-
 include/linux/serial_8250.h         |    3 ++-
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 9f1d31d..16333e1 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -1472,7 +1472,8 @@ static void serial8250_enable_ms(struct uart_port *port)
  * by this Rx routine.
  */
 unsigned char
-serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr)
+serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr,
+		    spinlock_t *flip_lock)
 {
 	struct uart_port *port = &up->port;
 	unsigned char ch;
@@ -1543,7 +1544,11 @@ ignore_char:
 		lsr = serial_in(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (--max_count > 0));
 	spin_unlock(&port->lock);
+	if (flip_lock)
+		spin_lock(flip_lock);
 	tty_flip_buffer_push(&port->state->port);
+	if (flip_lock)
+		spin_unlock(flip_lock);
 	spin_lock(&port->lock);
 	return lsr;
 }
@@ -1649,7 +1654,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 			dma_err = up->dma->rx_dma(up, iir);
 
 		if (!up->dma || dma_err)
-			status = serial8250_rx_chars(up, status);
+			status = serial8250_rx_chars(up, status, NULL);
 	}
 	serial8250_modem_status(up);
 	if ((!up->dma || (up->dma && up->dma->tx_err)) &&
diff --git a/drivers/tty/serial/8250/8250_fsl.c b/drivers/tty/serial/8250/8250_fsl.c
index c0533a5..628d70b 100644
--- a/drivers/tty/serial/8250/8250_fsl.c
+++ b/drivers/tty/serial/8250/8250_fsl.c
@@ -49,7 +49,7 @@ int fsl8250_handle_irq(struct uart_port *port)
 	lsr = orig_lsr = up->port.serial_in(&up->port, UART_LSR);
 
 	if (lsr & (UART_LSR_DR | UART_LSR_BI))
-		lsr = serial8250_rx_chars(up, lsr);
+		lsr = serial8250_rx_chars(up, lsr, NULL);
 
 	serial8250_modem_status(up);
 
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 78097e7..5f6c683 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -146,7 +146,8 @@ extern void serial8250_do_pm(struct uart_port *port, unsigned int state,
 extern void serial8250_do_set_mctrl(struct uart_port *port, unsigned int mctrl);
 extern int fsl8250_handle_irq(struct uart_port *port);
 int serial8250_handle_irq(struct uart_port *port, unsigned int iir);
-unsigned char serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr);
+unsigned char serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr,
+				  spinlock_t *flip_lock);
 void serial8250_tx_chars(struct uart_8250_port *up);
 unsigned int serial8250_modem_status(struct uart_8250_port *up);
 
-- 
1.7.5.4

