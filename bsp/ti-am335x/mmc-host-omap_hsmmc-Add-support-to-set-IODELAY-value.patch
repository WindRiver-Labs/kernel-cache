From a5301718b0de062a365d359ae53872685d6140c9 Mon Sep 17 00:00:00 2001
From: Kishon Vijay Abraham I <kishon@ti.com>
Date: Wed, 5 Aug 2015 18:54:50 +0530
Subject: [PATCH 416/800] mmc: host: omap_hsmmc: Add support to set IODELAY
 values

The data manual of J6/J6 Eco recommends to set different IODELAY values
depending on the mode in which the MMC/SD is enumerated in order to
ensure IO timings are met.

Added support to set the IODELAY values depending on the various MMC
modes using the pinctrl APIs.

Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 .../devicetree/bindings/mmc/ti-omap-hsmmc.txt      |    5 +
 drivers/mmc/host/omap_hsmmc.c                      |  121 +++++++++++++++++++-
 2 files changed, 125 insertions(+), 1 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt b/Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt
index 0c63216..06b87ac 100644
--- a/Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt
+++ b/Documentation/devicetree/bindings/mmc/ti-omap-hsmmc.txt
@@ -20,6 +20,11 @@ Optional properties:
 ti,dual-volt: boolean, supports dual voltage cards
 <supply-name>-supply: phandle to the regulator device tree node
 "supply-name" examples are "vmmc", "vmmc_aux" etc
+pinctrl-names: Should be a list of pinctrl state names and can be "sdr104",
+"hs200_1_8v", "ddr50", "sdr50", "sdr25", "sdr12", "hs", "ddr_1_8v" or
+"default".
+pinctrl-<num>: Phandle referencing pin configuration of the sd/emmc controller.
+See: Documentation/devicetree/bindings/pinctrl/pinctrl-binding.txt
 ti,non-removable: non-removable slot (like eMMC)
 ti,needs-special-reset: Requires a special softreset sequence
 ti,needs-special-hs-handling: HSMMC IP needs special setting for handling High Speed
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 9da63d3..71ea18c 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -261,6 +261,18 @@ struct omap_hsmmc_host {
 	u32			*tuning_data;
 	int			tuning_size;
 
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pinctrl_state;
+	struct pinctrl_state	*default_pinctrl_state;
+	struct pinctrl_state	*sdr104_pinctrl_state;
+	struct pinctrl_state	*hs200_1_8v_pinctrl_state;
+	struct pinctrl_state	*ddr50_pinctrl_state;
+	struct pinctrl_state	*sdr50_pinctrl_state;
+	struct pinctrl_state	*sdr25_pinctrl_state;
+	struct pinctrl_state	*sdr12_pinctrl_state;
+	struct pinctrl_state	*hs_pinctrl_state;
+	struct pinctrl_state	*ddr_1_8v_pinctrl_state;
+
 	/* return MMC cover switch state, can be NULL if not supported.
 	 *
 	 * possible return values:
@@ -1813,6 +1825,8 @@ static void omap_hsmmc_request(struct mmc_host *mmc, struct mmc_request *req)
 static void omap_hsmmc_set_timing(struct omap_hsmmc_host *host)
 {
 	u32 val;
+	int ret;
+	struct pinctrl_state *pinctrl_state;
 	struct mmc_ios *ios = &host->mmc->ios;
 
 	omap_hsmmc_stop_clock(host);
@@ -1822,35 +1836,54 @@ static void omap_hsmmc_set_timing(struct omap_hsmmc_host *host)
 	switch (ios->timing) {
 	case MMC_TIMING_UHS_SDR104:
 		val |= AC12_UHSMC_SDR104;
+		pinctrl_state = host->sdr104_pinctrl_state;
 		break;
 	case MMC_TIMING_MMC_HS200:
 		val |= AC12_UHSMC_SDR104;
+		pinctrl_state = host->hs200_1_8v_pinctrl_state;
 		break;
 	case MMC_TIMING_UHS_DDR50:
 		val |= AC12_UHSMC_DDR50;
+		pinctrl_state = host->ddr50_pinctrl_state;
 		break;
 	case MMC_TIMING_UHS_SDR50:
 		val |= AC12_UHSMC_SDR50;
+		pinctrl_state = host->sdr50_pinctrl_state;
 		break;
 	case MMC_TIMING_UHS_SDR25:
 		val |= AC12_UHSMC_SDR25;
+		pinctrl_state = host->sdr25_pinctrl_state;
 		break;
 	case MMC_TIMING_UHS_SDR12:
 		val |= AC12_UHSMC_SDR12;
+		pinctrl_state = host->sdr12_pinctrl_state;
 		break;
 	case MMC_TIMING_SD_HS:
 	case MMC_TIMING_MMC_HS:
 		val |= AC12_UHSMC_RES;
+		pinctrl_state = host->hs_pinctrl_state;
 		break;
 	case MMC_TIMING_MMC_DDR52:
 		val |= AC12_UHSMC_RES;
+		pinctrl_state = host->ddr_1_8v_pinctrl_state;
 		break;
 	default:
 		val |= AC12_UHSMC_RES;
+		pinctrl_state = host->default_pinctrl_state;
 		break;
 	}
 	OMAP_HSMMC_WRITE(host->base, AC12, val);
 
+	if (host->pdata->controller_flags & OMAP_HSMMC_REQUIRE_IODELAY) {
+		ret = pinctrl_select_state(host->pinctrl, pinctrl_state);
+		if (ret) {
+			dev_err(mmc_dev(host->mmc),
+				"failed to select pinctrl state\n");
+			return;
+		}
+		host->pinctrl_state = pinctrl_state;
+	}
+
 	omap_hsmmc_start_clock(host);
 }
 
@@ -2493,6 +2526,80 @@ static inline struct omap_hsmmc_platform_data
 }
 #endif
 
+static struct pinctrl_state *
+omap_hsmmc_pinctrl_lookup_state(struct omap_hsmmc_host *host, char *mode)
+{
+	struct pinctrl_state *state;
+
+	state = pinctrl_lookup_state(host->pinctrl, mode);
+	if (IS_ERR(state))
+		dev_err(mmc_dev(host->mmc),
+			"no pinctrl state for %s mode\n", mode);
+	return state;
+}
+
+static int omap_hsmmc_get_iodelay_pinctrl_state(struct omap_hsmmc_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	if (!(host->pdata->controller_flags & OMAP_HSMMC_REQUIRE_IODELAY))
+		return 0;
+
+	host->pinctrl = devm_pinctrl_get(host->dev);
+	if (IS_ERR(host->pinctrl)) {
+		dev_err(host->dev, "Cannot get pinctrl\n");
+		return PTR_ERR(host->pinctrl);
+	}
+
+	host->default_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								     "default");
+	if (IS_ERR(host->default_pinctrl_state))
+		return PTR_ERR(host->default_pinctrl_state);
+
+	host->sdr104_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								     "sdr104");
+	if (IS_ERR(host->sdr104_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_UHS_SDR104;
+
+	host->hs200_1_8v_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								    "hs200_1_8v");
+	if (IS_ERR(host->hs200_1_8v_pinctrl_state))
+		mmc->caps2 &= ~MMC_CAP2_HS200_1_8V_SDR;
+
+	host->ddr50_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								    "ddr50");
+	if (IS_ERR(host->ddr50_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_UHS_DDR50;
+
+	host->sdr50_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								    "sdr50");
+	if (IS_ERR(host->sdr50_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_UHS_SDR50;
+
+	host->sdr25_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								    "sdr25");
+	if (IS_ERR(host->sdr25_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_UHS_SDR25;
+
+	host->sdr12_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								    "sdr12");
+	if (IS_ERR(host->sdr12_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_UHS_SDR12;
+
+	host->hs_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host, "hs");
+	if (IS_ERR(host->hs_pinctrl_state))
+		mmc->caps &= ~(MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED);
+
+	host->ddr_1_8v_pinctrl_state = omap_hsmmc_pinctrl_lookup_state(host,
+								   "ddr_1_8v");
+	if (IS_ERR(host->ddr_1_8v_pinctrl_state))
+		mmc->caps &= ~MMC_CAP_1_8V_DDR;
+
+	host->pinctrl_state = host->default_pinctrl_state;
+
+	return 0;
+}
+
 static int omap_hsmmc_probe(struct platform_device *pdev)
 {
 	struct omap_hsmmc_platform_data *pdata = pdev->dev.platform_data;
@@ -2644,6 +2751,10 @@ static int omap_hsmmc_probe(struct platform_device *pdev)
 
 	omap_hsmmc_set_capabilities(host);
 
+	ret = omap_hsmmc_get_iodelay_pinctrl_state(host);
+	if (ret)
+		goto err_pinctrl;
+
 	if (!pdev->dev.of_node) {
 		res = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");
 		if (!res) {
@@ -2751,6 +2862,7 @@ err_irq:
 		dma_release_channel(host->tx_chan);
 	if (host->rx_chan)
 		dma_release_channel(host->rx_chan);
+err_pinctrl:
 	if (host->dbclk)
 		clk_disable_unprepare(host->dbclk);
 	pm_runtime_put_sync(host->dev);
@@ -2888,6 +3000,7 @@ static int omap_hsmmc_runtime_resume(struct device *dev)
 {
 	struct omap_hsmmc_host *host;
 	unsigned long flags;
+	int ret;
 
 	host = platform_get_drvdata(to_platform_device(dev));
 	omap_hsmmc_context_restore(host);
@@ -2904,7 +3017,13 @@ static int omap_hsmmc_runtime_resume(struct device *dev)
 		OMAP_HSMMC_WRITE(host->base, ISE, CIRQ_EN);
 		OMAP_HSMMC_WRITE(host->base, IE, CIRQ_EN);
 	} else {
-		pinctrl_pm_select_default_state(host->dev);
+		if (host->pinctrl) {
+			ret = pinctrl_select_state(host->pinctrl,
+						   host->pinctrl_state);
+			if (ret)
+				dev_err(mmc_dev(host->mmc),
+					"failed to activate pinctrl state\n");
+		}
 	}
 	spin_unlock_irqrestore(&host->irq_lock, flags);
 	return 0;
-- 
1.7.5.4

