From 1e68b79d99451b1db57995395784f2235a357324 Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Wed, 26 Aug 2015 09:04:52 +0530
Subject: [PATCH 545/800] HACK: drm/omap: Add omapdrm plugin API

This patch enables SGX driver to be added as a plugin to omapdrm. This
is a HACK, and must be reverted/rewritten when proper DRM-SGX interop is
implemented.

As this is a HACK, the code is wrapped with CONFIG_DRM_OMAP_SGX_PLUGIN,
and grouped together and separated from the main omapdrm code when
possible. This means checkpatch will complain a bit, but this should
make it easier to revert this later and to avoid conflicts with
mainline.

Main changes involved:

1. SGX specific GEM VM operations
	SGX requires contiguous memory for both texture memory as well
	as framebuffers.

	Memory allocation of FB is done through omapdrm and is guaranteed
	to be contiguous.

	Texture memory can come from:
	a. user space allocated memory
	b. memory is allocated by other cores
	c. memory comes from CMA

	Texture memory can be non-contiguous, but is wrapped as GEM
	objects which enables the use of TILER to map them as contiguous
	memory to the SGX HW.

2. Support for ioctls from plugin driver
	SGX driver registers as a plugin to the omapdrm driver. During
	registration, SGX specific ioctls are added to omapdrm. This allows
	user space to control specific SGX feature sets using the DRM FD.

3. Export GEM functions
	SGX driver needs to work directly on GEM objects for DSS
	synchronization, getting TILER address, etc.

Signed-off-by: Rob Clark <rob@ti.com>
Signed-off-by: Subhajit Paul <subhajit_paul@ti.com>
Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Anand Balagopalakrishnan <anandb@ti.com>
Signed-off-by: Jyri Sarha <jsarha@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/gpu/drm/omapdrm/Kconfig    |    5 +
 drivers/gpu/drm/omapdrm/omap_drv.c |  143 +++++++++++++++++++++++++++++++++++-
 drivers/gpu/drm/omapdrm/omap_drv.h |   53 +++++++++++++
 drivers/gpu/drm/omapdrm/omap_gem.c |   95 ++++++++++++++++++++++++
 include/uapi/drm/omap_drm.h        |   14 ++++
 5 files changed, 309 insertions(+), 1 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/Kconfig b/drivers/gpu/drm/omapdrm/Kconfig
index 6c220cd..b351bd8 100644
--- a/drivers/gpu/drm/omapdrm/Kconfig
+++ b/drivers/gpu/drm/omapdrm/Kconfig
@@ -24,3 +24,8 @@ config DRM_OMAP_NUM_CRTCS
 	  Select the number of video overlays which can be used as framebuffers.
 	  The remaining overlays are reserved for video.
 
+config DRM_OMAP_SGX_PLUGIN
+	bool "Enable support for SGX plugin"
+	depends on DRM_OMAP
+	help
+	  Enable omapdrm's plugin support for Imagination's SGX GPU driver.
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.c b/drivers/gpu/drm/omapdrm/omap_drv.c
index b82a75d..3072f8f 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.c
+++ b/drivers/gpu/drm/omapdrm/omap_drv.c
@@ -39,6 +39,17 @@ static int num_crtc = CONFIG_DRM_OMAP_NUM_CRTCS;
 MODULE_PARM_DESC(num_crtc, "Number of overlays to use as CRTCs");
 module_param(num_crtc, int, 0600);
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+static struct drm_device *drm_device;
+
+static struct omap_drm_plugin *sgx_plugin;
+
+/* keep track of whether we are already loaded.. we may need to call
+ * plugin's load() if they register after we are already loaded
+ */
+static bool drm_loaded;
+#endif /* CONFIG_DRM_OMAP_SGX_PLUGIN */
+
 /*
  * mode config funcs
  */
@@ -588,6 +599,21 @@ static int ioctl_set_param(struct drm_device *dev, void *data,
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+static int ioctl_get_base(struct drm_device *dev, void *data,
+		struct drm_file *file_priv)
+{
+	struct drm_omap_get_base *args = data;
+
+	if (!sgx_plugin)
+		return -ENODEV;
+
+	args->ioctl_base = sgx_plugin->ioctl_base;
+
+	return 0;
+}
+#endif /* CONFIG_DRM_OMAP_SGX_PLUGIN */
+
 static int ioctl_gem_new(struct drm_device *dev, void *data,
 		struct drm_file *file_priv)
 {
@@ -666,9 +692,12 @@ static int ioctl_gem_info(struct drm_device *dev, void *data,
 	return ret;
 }
 
-static const struct drm_ioctl_desc ioctls[DRM_COMMAND_END - DRM_COMMAND_BASE] = {
+static struct drm_ioctl_desc ioctls[DRM_COMMAND_END - DRM_COMMAND_BASE] = {
 	DRM_IOCTL_DEF_DRV(OMAP_GET_PARAM, ioctl_get_param, DRM_UNLOCKED|DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(OMAP_SET_PARAM, ioctl_set_param, DRM_UNLOCKED|DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	DRM_IOCTL_DEF_DRV(OMAP_GET_BASE, ioctl_get_base, DRM_UNLOCKED|DRM_AUTH),
+#endif
 	DRM_IOCTL_DEF_DRV(OMAP_GEM_NEW, ioctl_gem_new, DRM_UNLOCKED|DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(OMAP_GEM_CPU_PREP, ioctl_gem_cpu_prep, DRM_UNLOCKED|DRM_AUTH),
 	DRM_IOCTL_DEF_DRV(OMAP_GEM_CPU_FINI, ioctl_gem_cpu_fini, DRM_UNLOCKED|DRM_AUTH),
@@ -743,6 +772,15 @@ static int dev_load(struct drm_device *dev, unsigned long flags)
 
 	drm_kms_helper_poll_init(dev);
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	drm_device = dev;
+
+	drm_loaded = true;
+
+	if (sgx_plugin)
+		sgx_plugin->load(dev, flags);
+#endif
+
 	return 0;
 }
 
@@ -752,6 +790,13 @@ static int dev_unload(struct drm_device *dev)
 
 	DBG("unload: dev=%p", dev);
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	if (sgx_plugin)
+		sgx_plugin->unload(dev);
+
+	drm_loaded = false;
+#endif
+
 	drm_kms_helper_poll_fini(dev);
 
 	if (priv->fbdev)
@@ -779,6 +824,11 @@ static int dev_open(struct drm_device *dev, struct drm_file *file)
 
 	DBG("open: dev=%p, file=%p", dev, file);
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	if (sgx_plugin)
+		sgx_plugin->open(dev, file);
+#endif
+
 	return 0;
 }
 
@@ -835,6 +885,11 @@ static void dev_preclose(struct drm_device *dev, struct drm_file *file)
 
 	DBG("preclose: dev=%p", dev);
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	if (sgx_plugin)
+		sgx_plugin->release(dev, file);
+#endif
+
 	/*
 	 * Unlink all pending CRTC events to make sure they won't be queued up
 	 * by a pending asynchronous commit.
@@ -847,6 +902,10 @@ static void dev_preclose(struct drm_device *dev, struct drm_file *file)
 		}
 	}
 	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	kfree(file->driver_priv);
+#endif
 }
 
 static void dev_postclose(struct drm_device *dev, struct drm_file *file)
@@ -856,8 +915,13 @@ static void dev_postclose(struct drm_device *dev, struct drm_file *file)
 
 static const struct vm_operations_struct omap_gem_vm_ops = {
 	.fault = omap_gem_fault,
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	.open = omap_gem_vm_open,
+	.close = omap_gem_vm_close,
+#else
 	.open = drm_gem_vm_open,
 	.close = drm_gem_vm_close,
+#endif
 };
 
 static const struct file_operations omapdriver_fops = {
@@ -907,6 +971,83 @@ static struct drm_driver omap_drm_driver = {
 	.patchlevel = DRIVER_PATCHLEVEL,
 };
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+
+int omap_drm_register_plugin(struct omap_drm_plugin *plugin)
+{
+	struct drm_device *dev = drm_device;
+	int i;
+
+	DBG("register plugin: %p (%s)", plugin, plugin->name);
+
+	if (sgx_plugin)
+		return -EBUSY;
+
+	for (i = 0; i < plugin->num_ioctls; i++) {
+		int nr = i + DRM_OMAP_NUM_IOCTLS;
+
+		/* check for out of bounds ioctl or already registered ioctl */
+		if (nr > ARRAY_SIZE(ioctls) || ioctls[nr].func) {
+			dev_err(dev->dev, "invalid ioctl: %d (nr=%d)\n", i, nr);
+			return -EINVAL;
+		}
+	}
+
+	plugin->ioctl_base = DRM_OMAP_NUM_IOCTLS;
+
+	/* register the plugin's ioctl's */
+	for (i = 0; i < plugin->num_ioctls; i++) {
+		int nr = i + DRM_OMAP_NUM_IOCTLS;
+
+		DBG("register ioctl: %d %08x", nr, plugin->ioctls[i].cmd);
+
+		ioctls[nr] = plugin->ioctls[i];
+	}
+
+	omap_drm_driver.num_ioctls = DRM_OMAP_NUM_IOCTLS + plugin->num_ioctls;
+
+	sgx_plugin = plugin;
+
+	if (drm_loaded)
+		plugin->load(dev, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_drm_register_plugin);
+
+int omap_drm_unregister_plugin(struct omap_drm_plugin *plugin)
+{
+	int i;
+
+	for (i = 0; i < plugin->num_ioctls; i++) {
+		const struct drm_ioctl_desc empty = { 0 };
+		int nr = i + DRM_OMAP_NUM_IOCTLS;
+
+		ioctls[nr] = empty;
+	}
+
+	omap_drm_driver.num_ioctls = DRM_OMAP_NUM_IOCTLS;
+
+	sgx_plugin = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_drm_unregister_plugin);
+
+void *omap_drm_file_priv(struct drm_file *file)
+{
+	return file->driver_priv;
+}
+EXPORT_SYMBOL(omap_drm_file_priv);
+
+void omap_drm_file_set_priv(struct drm_file *file, void *priv)
+{
+	file->driver_priv = priv;
+}
+EXPORT_SYMBOL(omap_drm_file_set_priv);
+
+#endif /* CONFIG_DRM_OMAP_SGX_PLUGIN */
+
 static int pdev_probe(struct platform_device *device)
 {
 	int r;
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.h b/drivers/gpu/drm/omapdrm/omap_drv.h
index 23d29b3..41db4fe 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.h
+++ b/drivers/gpu/drm/omapdrm/omap_drv.h
@@ -277,4 +277,57 @@ fail:
 	return -ENOENT;
 }
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+
+/* interface that plug-in drivers (for now just PVR) can implement */
+struct omap_drm_plugin {
+	const char *name;
+
+	/* drm functions */
+	int (*load)(struct drm_device *dev, unsigned long flags);
+	int (*unload)(struct drm_device *dev);
+	int (*open)(struct drm_device *dev, struct drm_file *file);
+	int (*release)(struct drm_device *dev, struct drm_file *file);
+
+	struct drm_ioctl_desc *ioctls;
+	int num_ioctls;
+	int ioctl_base;
+};
+
+int omap_drm_register_plugin(struct omap_drm_plugin *plugin);
+int omap_drm_unregister_plugin(struct omap_drm_plugin *plugin);
+
+void *omap_drm_file_priv(struct drm_file *file);
+void omap_drm_file_set_priv(struct drm_file *file, void *priv);
+
+void *omap_gem_priv(struct drm_gem_object *obj);
+void omap_gem_set_priv(struct drm_gem_object *obj, void *priv);
+void omap_gem_vm_open(struct vm_area_struct *vma);
+void omap_gem_vm_close(struct vm_area_struct *vma);
+
+/* for external plugin buffers wrapped as GEM object (via. omap_gem_new_ext())
+ * a vm_ops struct can be provided to get callback notification of various
+ * events..
+ */
+struct omap_gem_vm_ops {
+	void (*open)(struct vm_area_struct *area);
+	void (*close)(struct vm_area_struct *area);
+	/*maybe: int (*fault)(struct vm_area_struct *vma,
+	  struct vm_fault *vmf)*/
+
+	/* note: mmap isn't expected to do anything. it is just to allow buffer
+	 * allocate to update it's own internal state
+	 */
+	void (*mmap)(struct file *, struct vm_area_struct *);
+};
+
+struct drm_gem_object *omap_gem_new_ext(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags,
+		dma_addr_t paddr, struct page **pages,
+		struct omap_gem_vm_ops *ops);
+
+void omap_gem_op_update(void);
+int omap_gem_set_sync_object(struct drm_gem_object *obj, void *syncobj);
+#endif /* CONFIG_DRM_OMAP_SGX_PLUGIN */
+
 #endif /* __OMAP_DRV_H__ */
diff --git a/drivers/gpu/drm/omapdrm/omap_gem.c b/drivers/gpu/drm/omapdrm/omap_gem.c
index f9ddbf5..2692dfa 100644
--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@ -117,6 +117,13 @@ struct omap_gem_object {
 		uint32_t read_pending;
 		uint32_t read_complete;
 	} *sync;
+
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	struct omap_gem_vm_ops *ops;
+
+	/* per-mapper private data. */
+	void *priv;
+#endif
 };
 
 static int get_pages(struct drm_gem_object *obj, struct page ***pages);
@@ -593,6 +600,11 @@ int omap_gem_mmap_obj(struct drm_gem_object *obj,
 		vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 	}
 
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+	if (omap_obj->ops && omap_obj->ops->mmap)
+		omap_obj->ops->mmap(obj->filp, vma);
+#endif
+
 	return 0;
 }
 
@@ -1485,3 +1497,86 @@ void omap_gem_deinit(struct drm_device *dev)
 	 */
 	kfree(usergart);
 }
+
+#if IS_ENABLED(CONFIG_DRM_OMAP_SGX_PLUGIN)
+
+EXPORT_SYMBOL(omap_gem_flags);
+EXPORT_SYMBOL(omap_gem_mmap_offset);
+EXPORT_SYMBOL(omap_gem_tiled_size);
+EXPORT_SYMBOL(omap_gem_get_paddr);
+EXPORT_SYMBOL(omap_gem_put_paddr);
+EXPORT_SYMBOL(omap_gem_tiled_stride);
+EXPORT_SYMBOL(omap_gem_get_pages);
+EXPORT_SYMBOL(omap_gem_put_pages);
+EXPORT_SYMBOL(omap_gem_op_update);
+EXPORT_SYMBOL(omap_gem_op_start);
+EXPORT_SYMBOL(omap_gem_op_finish);
+EXPORT_SYMBOL(omap_gem_op_sync);
+EXPORT_SYMBOL(omap_gem_op_async);
+EXPORT_SYMBOL(omap_gem_set_sync_object);
+
+/*
+ * This constructor is mainly to give plugins a way to wrap their
+ * own allocations
+ */
+struct drm_gem_object *omap_gem_new_ext(struct drm_device *dev,
+		union omap_gem_size gsize, uint32_t flags,
+		dma_addr_t paddr, struct page **pages,
+		struct omap_gem_vm_ops *ops)
+{
+	struct drm_gem_object *obj;
+
+	BUG_ON((flags & OMAP_BO_TILED) && !pages);
+
+	if (paddr)
+		flags |= OMAP_BO_DMA;
+
+	obj = omap_gem_new(dev, gsize, flags | OMAP_BO_EXT_MEM);
+	if (obj) {
+		struct omap_gem_object *omap_obj = to_omap_bo(obj);
+
+		omap_obj->paddr = paddr;
+		omap_obj->pages = pages;
+		omap_obj->ops = ops;
+	}
+	return obj;
+}
+EXPORT_SYMBOL(omap_gem_new_ext);
+
+void omap_gem_vm_open(struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct omap_gem_object *omap_obj = to_omap_bo(obj);
+
+	if (omap_obj->ops && omap_obj->ops->open)
+		omap_obj->ops->open(vma);
+	else
+		drm_gem_vm_open(vma);
+
+}
+
+void omap_gem_vm_close(struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct omap_gem_object *omap_obj = to_omap_bo(obj);
+
+	if (omap_obj->ops && omap_obj->ops->close)
+		omap_obj->ops->close(vma);
+	else
+		drm_gem_vm_close(vma);
+
+}
+
+void *omap_gem_priv(struct drm_gem_object *obj)
+{
+	return to_omap_bo(obj)->priv;
+}
+EXPORT_SYMBOL(omap_gem_priv);
+
+void omap_gem_set_priv(struct drm_gem_object *obj, void *priv)
+{
+	to_omap_bo(obj)->priv = priv;
+}
+EXPORT_SYMBOL(omap_gem_set_priv);
+
+#endif /* CONFIG_DRM_OMAP_SGX_PLUGIN */
diff --git a/include/uapi/drm/omap_drm.h b/include/uapi/drm/omap_drm.h
index 1d0b117..91edd9c 100644
--- a/include/uapi/drm/omap_drm.h
+++ b/include/uapi/drm/omap_drm.h
@@ -120,4 +120,18 @@ struct drm_omap_gem_info {
 #define DRM_IOCTL_OMAP_GEM_CPU_FINI	DRM_IOW (DRM_COMMAND_BASE + DRM_OMAP_GEM_CPU_FINI, struct drm_omap_gem_cpu_fini)
 #define DRM_IOCTL_OMAP_GEM_INFO		DRM_IOWR(DRM_COMMAND_BASE + DRM_OMAP_GEM_INFO, struct drm_omap_gem_info)
 
+/* HACK: SGX hack start */
+/* HACK: SGX plugin specific, will be removed */
+
+struct drm_omap_get_base {
+	char plugin_name[64];	/* in */
+	uint32_t ioctl_base;	/* out */
+	uint32_t __pad;
+};
+
+#define DRM_IOCTL_OMAP_GET_BASE		DRM_IOWR(DRM_COMMAND_BASE + DRM_OMAP_GET_BASE, struct drm_omap_get_base)
+#define DRM_OMAP_GET_BASE		0x02
+
+/* HACK: SGX hack end */
+
 #endif /* __OMAP_DRM_H__ */
-- 
1.7.5.4

