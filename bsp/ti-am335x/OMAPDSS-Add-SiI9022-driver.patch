From 9d371b4f63c1e3ba1fed139d5d4215af8686fff4 Mon Sep 17 00:00:00 2001
From: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date: Fri, 12 Jun 2015 14:46:54 +0300
Subject: [PATCH 123/800] OMAPDSS: Add SiI9022 driver

Add OMAPDSS driver for SiI9022 parallel RGB to HDMI encoder. The driver
contains support for both video and audio.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Jyri Sarha <jsarha@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 .../devicetree/bindings/video/sil,sii9022.txt      |   67 ++
 drivers/video/fbdev/omap2/displays-new/Kconfig     |   16 +
 drivers/video/fbdev/omap2/displays-new/Makefile    |    3 +
 .../omap2/displays-new/encoder-sii9022-audio.c     |  444 +++++++++
 .../omap2/displays-new/encoder-sii9022-video.c     |  969 ++++++++++++++++++++
 .../fbdev/omap2/displays-new/encoder-sii9022.h     |  174 ++++
 include/dt-bindings/sound/sii9022-audio.h          |   12 +
 7 files changed, 1685 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/video/sil,sii9022.txt
 create mode 100644 drivers/video/fbdev/omap2/displays-new/encoder-sii9022-audio.c
 create mode 100644 drivers/video/fbdev/omap2/displays-new/encoder-sii9022-video.c
 create mode 100644 drivers/video/fbdev/omap2/displays-new/encoder-sii9022.h
 create mode 100644 include/dt-bindings/sound/sii9022-audio.h

diff --git a/Documentation/devicetree/bindings/video/sil,sii9022.txt b/Documentation/devicetree/bindings/video/sil,sii9022.txt
new file mode 100644
index 0000000..c6047c9
--- /dev/null
+++ b/Documentation/devicetree/bindings/video/sil,sii9022.txt
@@ -0,0 +1,67 @@
+Silicon Image SiI9022 HDMI Encoder
+==================================
+
+Silicon Image SiI9022 is an HDMI encoder that encodes parallel RGB
+signal to HDMI signal. The SiI9022 is controlled with i2c command, and
+it has a single reset pin and single interrupt pin.
+
+Required properties:
+- compatible: "sil,sii9022"
+
+Optional properties:
+- reset-gpio: reset gpio
+- interrupts: interrupt line
+
+Required for HDMI audio:
+- i2s-fifo-routing:
+  - Array of exactly 4 integers indicating i2s pins to audio fifo routing
+  - First integer defines routing to fifo 0 and second to fifo 1, etc.
+  - Integers can be filled with definitions from:
+    include/dt-bindings/sound/sii9022-audio.h
+
+Required nodes:
+- Video port 0 for parallel video input
+- Video port 1 for HDMI output
+
+Example
+-------
+
+&i2c2 {
+	sii9022: sii9022@3b {
+		compatible = "sil,sii9022";
+		reg = <0x3b>;
+
+		i2s-fifo-routing = <
+			(ENABLE_BIT|CONNECT_SD0)
+			0
+			0
+			0
+		>;
+
+		reset-gpio = <&gpio2 1 GPIO_ACTIVE_LOW>;
+
+		interrupt-parent = <&gpio1>;
+		interrupts = <18 IRQ_TYPE_LEVEL_LOW>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				sii9022_in: endpoint {
+					remote-endpoint = <&dpi_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				sii9022_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
diff --git a/drivers/video/fbdev/omap2/displays-new/Kconfig b/drivers/video/fbdev/omap2/displays-new/Kconfig
index 5747101..c6e0089 100644
--- a/drivers/video/fbdev/omap2/displays-new/Kconfig
+++ b/drivers/video/fbdev/omap2/displays-new/Kconfig
@@ -18,6 +18,22 @@ config DISPLAY_ENCODER_TPD12S015
 	  Driver for TPD12S015, which offers HDMI ESD protection and level
 	  shifting.
 
+config DISPLAY_ENCODER_SII9022
+	tristate "SiI9022 HDMI Encoder"
+	depends on I2C
+	help
+	  Driver for Silicon Image SiI9022 HDMI encoder.
+	  A brief about SiI9022 can be found here:
+	  http://www.semiconductorstore.com/pdf/newsite/siliconimage/SiI9022a_pb.pdf
+
+config DISPLAY_ENCODER_SII9022_AUDIO_CODEC
+	bool "ASoC codec driver for SiI9022 HDMI Encoder"
+	depends on DISPLAY_ENCODER_SII9022
+	depends on SND_SOC = y || DISPLAY_ENCODER_SII9022 = SND_SOC
+	default y
+	help
+	  ASoC DAI driver for Silicon Image Sil9022 DPI to HDMI encoder.
+
 config DISPLAY_CONNECTOR_DVI
         tristate "DVI Connector"
 	depends on I2C
diff --git a/drivers/video/fbdev/omap2/displays-new/Makefile b/drivers/video/fbdev/omap2/displays-new/Makefile
index 9aa176b..8fb04e9 100644
--- a/drivers/video/fbdev/omap2/displays-new/Makefile
+++ b/drivers/video/fbdev/omap2/displays-new/Makefile
@@ -1,6 +1,9 @@
 obj-$(CONFIG_DISPLAY_ENCODER_OPA362) += encoder-opa362.o
 obj-$(CONFIG_DISPLAY_ENCODER_TFP410) += encoder-tfp410.o
 obj-$(CONFIG_DISPLAY_ENCODER_TPD12S015) += encoder-tpd12s015.o
+obj-$(CONFIG_DISPLAY_ENCODER_SII9022) += encoder-sii9022.o
+encoder-sii9022-y += encoder-sii9022-video.o
+encoder-sii9022-$(CONFIG_DISPLAY_ENCODER_SII9022_AUDIO_CODEC) += encoder-sii9022-audio.o
 obj-$(CONFIG_DISPLAY_CONNECTOR_DVI) += connector-dvi.o
 obj-$(CONFIG_DISPLAY_CONNECTOR_HDMI) += connector-hdmi.o
 obj-$(CONFIG_DISPLAY_CONNECTOR_ANALOG_TV) += connector-analog-tv.o
diff --git a/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-audio.c b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-audio.c
new file mode 100644
index 0000000..43b31b2
--- /dev/null
+++ b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-audio.c
@@ -0,0 +1,444 @@
+/*
+ * Silicon Image SiI9022 Encoder Driver
+ *
+ * Copyright (C) 2014 Texas Instruments
+ * Author: Jyri Sarha <jsarha@ti.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/regmap.h>
+
+#include <video/omapdss.h>
+
+#include <drm/drm_edid.h>
+
+#include <linux/hdmi.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <uapi/sound/asound.h>
+#include <sound/asoundef.h>
+
+#include <dt-bindings/sound/sii9022-audio.h>
+
+#include "encoder-sii9022.h"
+
+struct sii9022_audio {
+	unsigned int mclk;
+	unsigned int fmt;
+	unsigned int channels;
+	u32 i2s_fifo_routing[4];
+};
+
+static int sii9022_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+	u8 channel_layout = dd->audio->channels > 2 ?
+		TPI_AUDIO_LAYOUT_8_CHANNELS :
+		TPI_AUDIO_LAYOUT_2_CHANNELS;
+	int ret;
+
+	if (mute) {
+		dev_dbg(dai->dev, "Muted (%d)\n", mute);
+		ret = regmap_write(dd->regmap,
+				   HDMI_TPI_AUDIO_CONFIG_BYTE2_REG,
+				   TPI_AUDIO_INTERFACE_I2S |
+				   channel_layout |
+				   TPI_AUDIO_MUTE_ENABLE |
+				   TPI_AUDIO_CODING_PCM);
+	} else {
+		dev_dbg(dai->dev, "Unmuted (%d)\n", mute);
+		ret = regmap_write(dd->regmap,
+				   HDMI_TPI_AUDIO_CONFIG_BYTE2_REG,
+				   TPI_AUDIO_INTERFACE_I2S |
+				   channel_layout |
+				   TPI_AUDIO_MUTE_DISABLE |
+				   TPI_AUDIO_CODING_PCM);
+	}
+	return ret;
+}
+
+static const unsigned int mclk_div_table[] = {
+	128, 256, 384, 512, 768, 1024, 1152, 192 };
+
+static int sii9022_select_mclk_div(u8 *i2s_config_reg,
+				   unsigned int rate,
+				   unsigned int mclk)
+{
+	int distance = 100000;
+	u8 i, nearest = 0;
+
+	for (i = 0; i < ARRAY_SIZE(mclk_div_table); i++) {
+		unsigned int div = mclk/rate;
+
+		if (abs(div - mclk_div_table[i]) < distance) {
+			nearest = i;
+			distance = abs(div - mclk_div_table[i]);
+		}
+		if (div == mclk_div_table[i])
+			break;
+	}
+
+	*i2s_config_reg |= nearest << 4;
+
+	if (i == ARRAY_SIZE(mclk_div_table))
+		return mclk_div_table[nearest];
+
+	return 0;
+}
+
+static int sii9022_audio_start(struct snd_soc_dai *dai,
+			       struct snd_pcm_hw_params *params)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+	u8 i2s_config_reg = TPI_I2S_SD_DIRECTION_MSB_FIRST;
+	u8 config_byte3_reg = TPI_AUDIO_CHANNEL_STREAM;
+	u8 i2s_strm_hdr_reg[5] = {
+		IEC958_AES0_CON_NOT_COPYRIGHT,
+		IEC958_AES1_CON_GENERAL,
+		IEC958_AES2_CON_SOURCE_UNSPEC,
+		IEC958_AES3_CON_CLOCK_VARIABLE,
+		0
+	};
+	u8 infoframe_buf[HDMI_INFOFRAME_SIZE(AUDIO)];
+	struct hdmi_audio_infoframe infoframe;
+	int ret, i;
+
+	hdmi_audio_infoframe_init(&infoframe);
+
+	dd->audio->channels = params_channels(params);
+
+	switch (dd->audio->fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	default:
+		dev_err(dai->dev, "Unsupported daifmt (0x%x) master\n",
+			dd->audio->fmt);
+		return -EINVAL;
+	}
+
+	switch (dd->audio->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		i2s_config_reg |=
+			TPI_I2S_FIRST_BIT_SHIFT_YES | TPI_I2S_SD_JUSTIFY_LEFT;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		i2s_config_reg |= TPI_I2S_SD_JUSTIFY_LEFT;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		i2s_config_reg |= TPI_I2S_SD_JUSTIFY_RIGHT;
+		break;
+	default:
+		dev_err(dai->dev, "Unsupported daifmt (0x%x) format\n",
+			dd->audio->fmt);
+		return -EINVAL;
+	}
+
+	switch (dd->audio->fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		i2s_config_reg |=
+			TPI_I2S_WS_POLARITY_HIGH | TPI_I2S_SCK_EDGE_RISING;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		i2s_config_reg |=
+			TPI_I2S_WS_POLARITY_HIGH | TPI_I2S_SCK_EDGE_FALLING;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		i2s_config_reg |=
+			TPI_I2S_WS_POLARITY_LOW | TPI_I2S_SCK_EDGE_RISING;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		i2s_config_reg |=
+			TPI_I2S_WS_POLARITY_LOW | TPI_I2S_SCK_EDGE_FALLING;
+		break;
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		config_byte3_reg |= TPI_AUDIO_SAMPLE_SIZE_16;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_WORDLEN_20_16;
+		infoframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		config_byte3_reg |= TPI_AUDIO_SAMPLE_SIZE_20;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_WORDLEN_24_20;
+		infoframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config_byte3_reg |= TPI_AUDIO_SAMPLE_SIZE_24;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_MAX_WORDLEN_24 |
+			IEC958_AES4_CON_WORDLEN_24_20;
+		infoframe.sample_size = HDMI_AUDIO_SAMPLE_SIZE_24;
+		break;
+	default:
+		dev_err(dai->dev, "Unsupported sample format %d\n",
+			params_format(params));
+		return -EINVAL;
+	}
+
+	ret = sii9022_select_mclk_div(&i2s_config_reg, params_rate(params),
+				      dd->audio->mclk);
+	if (ret)
+		dev_warn(dai->dev, "Inaccurate reference clock (%u/%d != %u)\n",
+			 dd->audio->mclk, ret, params_rate(params));
+
+	switch (params_rate(params)) {
+	case 32000:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_32000;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_32000;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_32000;
+		break;
+	case 44100:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_44100;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_44100;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_44100;
+		break;
+	case 48000:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_48000;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_48000;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_48000;
+		break;
+	case 88200:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_88200;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_88200;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_88200;
+		break;
+	case 96000:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_96000;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_96000;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_96000;
+		break;
+	case 176400:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_176400;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_176400;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_176400;
+		break;
+	case 192000:
+		i2s_strm_hdr_reg[3] |= IEC958_AES3_CON_FS_192000;
+		i2s_strm_hdr_reg[4] |= IEC958_AES4_CON_ORIGFS_192000;
+		infoframe.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_192000;
+		break;
+	default:
+		dev_err(dai->dev, "Unsupported sample rate %d\n",
+			params_rate(params));
+		return -EINVAL;
+	}
+
+	ret = sii9022_mute(dai, true);
+	if (ret < 0)
+		return ret;
+
+	regmap_write(dd->regmap, HDMI_TPI_I2S_INPUT_CONFIG_REG,
+		     i2s_config_reg);
+
+	for (i = 0; i < ARRAY_SIZE(dd->audio->i2s_fifo_routing); i++)
+		regmap_write(dd->regmap, HDMI_TPI_I2S_ENABLE_MAPPING_REG,
+			     dd->audio->i2s_fifo_routing[i]);
+
+	regmap_write(dd->regmap, HDMI_TPI_AUDIO_CONFIG_BYTE3_REG,
+		     config_byte3_reg);
+
+	regmap_bulk_write(dd->regmap, HDMI_TPI_I2S_STRM_HDR_BASE,
+			  i2s_strm_hdr_reg, ARRAY_SIZE(i2s_strm_hdr_reg));
+
+	infoframe.channels = params_channels(params);
+	infoframe.coding_type = HDMI_AUDIO_CODING_TYPE_PCM;
+	ret = hdmi_audio_infoframe_pack(&infoframe, infoframe_buf,
+					sizeof(infoframe_buf));
+	if (ret < 0) {
+		dev_err(dai->dev, "Failed to pack audio infoframe: %d\n",
+			ret);
+		return ret;
+	}
+	regmap_bulk_write(dd->regmap, HDMI_CPI_MISC_IF_SELECT_REG,
+			  infoframe_buf, ret);
+
+	/* Decode Level 0 Packets */
+	regmap_write(dd->regmap, HDMI_IND_SET_PAGE, 0x02);
+	regmap_write(dd->regmap, HDMI_IND_OFFSET, 0x24);
+	regmap_write(dd->regmap, HDMI_IND_VALUE, 0x02);
+
+	dev_dbg(dai->dev, "hdmi audio enabled\n");
+
+	return 0;
+}
+
+static int sii9022_audio_stop(struct snd_soc_dai *dai)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+	int ret;
+
+	ret = regmap_write(dd->regmap, HDMI_TPI_AUDIO_CONFIG_BYTE2_REG,
+			   TPI_AUDIO_INTERFACE_DISABLE);
+
+	dev_dbg(dai->dev, "hdmi audio disabled (%d)\n", ret);
+	return ret;
+}
+
+static int sii9022_dai_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+	int r;
+
+	dev_dbg(dai->dev, "%s: format %d rate %d channels %d\n", __func__,
+		params_format(params),
+		params_rate(params),
+		params_channels(params));
+
+	mutex_lock(&dd->lock);
+
+	r = sii9022_audio_start(dai, params);
+
+	mutex_unlock(&dd->lock);
+
+	return r;
+}
+
+static int sii9022_dai_set_sysclk(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+
+	dev_dbg(dai->dev, "%s: id %d freq %u\n", __func__, clk_id, freq);
+	dd->audio->mclk = freq;
+
+	return 0;
+}
+
+static int sii9022_dai_set_fmt(struct snd_soc_dai *dai,
+			       unsigned int fmt)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+
+	dev_dbg(dai->dev, "%s: 0x%08x\n", __func__, fmt);
+	dd->audio->fmt = fmt;
+
+	return 0;
+}
+
+static int sii9022_dai_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+	int r;
+
+	mutex_lock(&dd->lock);
+	r = sii9022_mute(dai, mute);
+	mutex_unlock(&dd->lock);
+
+	return r;
+}
+
+static void sii9022_dai_shutdown(struct snd_pcm_substream *s,
+				 struct snd_soc_dai *dai)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dai->dev);
+
+	dev_dbg(dai->dev, "%s called\n", __func__);
+
+	mutex_lock(&dd->lock);
+	sii9022_audio_stop(dai);
+	mutex_unlock(&dd->lock);
+}
+
+static struct snd_soc_dai_ops sii9022_dai_ops = {
+	.hw_params	= sii9022_dai_hw_params,
+	.set_sysclk	= sii9022_dai_set_sysclk,
+	.set_fmt	= sii9022_dai_set_fmt,
+	.digital_mute	= sii9022_dai_digital_mute,
+	.shutdown	= sii9022_dai_shutdown,
+};
+
+static struct snd_soc_dai_driver sii9022_codec_dai = {
+	.name = "hdmi-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |
+			SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |
+			SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
+			SNDRV_PCM_FMTBIT_S32_LE,
+		.sig_bits = 24,
+	},
+	.ops = &sii9022_dai_ops,
+};
+
+static const struct snd_soc_dapm_widget sii9022_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("TX"),
+};
+
+static const struct snd_soc_dapm_route sii9022_routes[] = {
+	{ "TX", NULL, "Playback" },
+};
+
+static struct snd_soc_codec_driver sii9022_codec = {
+	.dapm_widgets = sii9022_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(sii9022_widgets),
+	.dapm_routes = sii9022_routes,
+	.num_dapm_routes = ARRAY_SIZE(sii9022_routes),
+};
+
+static const u8 i2s_fifo_defaults[] = {
+	TPI_I2S_CONFIG_FIFO0,
+	TPI_I2S_CONFIG_FIFO1,
+	TPI_I2S_CONFIG_FIFO2,
+	TPI_I2S_CONFIG_FIFO3,
+};
+
+int sii9022_hdmi_codec_register(struct device *dev)
+{
+	struct panel_drv_data *dd = dev_get_drvdata(dev);
+	struct device_node *node = dev->of_node;
+	int ret, i;
+	int fifos_enabled = 0;
+
+	dd->audio = devm_kzalloc(dev, sizeof(dd->audio), GFP_KERNEL);
+	if (IS_ERR(dd->audio))
+		return PTR_ERR(dd->audio);
+
+	ret = of_property_read_u32_array(
+		node, "i2s-fifo-routing", dd->audio->i2s_fifo_routing,
+		ARRAY_SIZE(dd->audio->i2s_fifo_routing));
+	if (ret != 0) {
+		dev_err(dev,
+			"Error %d getting \"i2s-fifo-routing\" DT property.\n",
+			ret);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dd->audio->i2s_fifo_routing); i++) {
+		dd->audio->i2s_fifo_routing[i] |= i2s_fifo_defaults[i];
+		if (dd->audio->i2s_fifo_routing[i] & TPI_I2S_FIFO_ENABLE)
+			fifos_enabled++;
+	}
+
+	dev_dbg(dev, "%d fifos enabled, setting max_channels to %d\n",
+		fifos_enabled, 2 * fifos_enabled);
+
+	sii9022_codec_dai.playback.channels_max = 2 * fifos_enabled;
+
+	return snd_soc_register_codec(dev, &sii9022_codec,
+				      &sii9022_codec_dai, 1);
+}
+
+void sii9022_hdmi_codec_unregister(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+}
diff --git a/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-video.c b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-video.c
new file mode 100644
index 0000000..1647190
--- /dev/null
+++ b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022-video.c
@@ -0,0 +1,969 @@
+/*
+ * Silicon Image SiI9022 Encoder Driver
+ *
+ * Copyright (C) 2014 Texas Instruments
+ * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <linux/of_irq.h>
+#include <linux/hdmi.h>
+
+#include <video/omapdss.h>
+#include <video/omap-panel-data.h>
+
+#include <drm/drm_edid.h>
+
+#include "encoder-sii9022.h"
+
+static const struct regmap_config sii9022_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static int sii9022_set_power_state(struct panel_drv_data *ddata,
+	enum sii9022_power_state state)
+{
+	unsigned pwr;
+	unsigned cold;
+	int r;
+
+	switch (state) {
+	case SII9022_POWER_STATE_D0:
+		pwr = 0;
+		cold = 0;
+		break;
+	case SII9022_POWER_STATE_D2:
+		pwr = 2;
+		cold = 0;
+		break;
+	case SII9022_POWER_STATE_D3_HOT:
+		pwr = 3;
+		cold = 0;
+		break;
+	case SII9022_POWER_STATE_D3_COLD:
+		pwr = 3;
+		cold = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	r = regmap_update_bits(ddata->regmap, SII9022_POWER_STATE_CTRL_REG,
+		1 << 2, cold << 2);
+	if (r) {
+		dev_err(&ddata->i2c_client->dev, "failed to set hot/cold bit\n");
+		return r;
+	}
+
+	r = regmap_update_bits(ddata->regmap, SII9022_POWER_STATE_CTRL_REG,
+		0x3, pwr);
+	if (r) {
+		dev_err(&ddata->i2c_client->dev,
+			"failed to set power state to %d\n", pwr);
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_ddc_read(struct i2c_adapter *adapter,
+		unsigned char *buf, u16 count, u8 offset)
+{
+	int r, retries;
+
+	for (retries = 3; retries > 0; retries--) {
+		struct i2c_msg msgs[] = {
+			{
+				.addr   = HDMI_I2C_MONITOR_ADDRESS,
+				.flags  = 0,
+				.len    = 1,
+				.buf    = &offset,
+			}, {
+				.addr   = HDMI_I2C_MONITOR_ADDRESS,
+				.flags  = I2C_M_RD,
+				.len    = count,
+				.buf    = buf,
+			}
+		};
+
+		r = i2c_transfer(adapter, msgs, 2);
+		if (r == 2)
+			return 0;
+
+		if (r != -EAGAIN)
+			break;
+	}
+
+	return r < 0 ? r : -EIO;
+}
+
+static int sii9022_request_ddc_access(struct panel_drv_data *ddata,
+	unsigned *ctrl_reg)
+{
+	struct device *dev = &ddata->i2c_client->dev;
+	unsigned int val;
+	int r;
+	unsigned retries;
+
+	*ctrl_reg = 0;
+
+	/* Read TPI system control register*/
+	r = regmap_read(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, &val);
+	if (r) {
+		dev_err(dev, "error reading DDC BUS REQUEST\n");
+		return r;
+	}
+
+	/* set SII9022_SYS_CTRL_DDC_BUS_REQUEST to request the DDC bus */
+	val |= SII9022_SYS_CTRL_DDC_BUS_REQUEST;
+
+	r = regmap_write(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, val);
+	if (r) {
+		dev_err(dev, "error writing DDC BUS REQUEST\n");
+		return r;
+	}
+
+	/*  Poll for bus DDC Bus control to be granted */
+	retries = 0;
+	do {
+		r = regmap_read(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, &val);
+		if (retries++ > 100)
+			return r;
+
+	} while ((val & SII9022_SYS_CTRL_DDC_BUS_GRANTED) == 0);
+
+	/*  Close the switch to the DDC */
+	val |= SII9022_SYS_CTRL_DDC_BUS_REQUEST |
+		SII9022_SYS_CTRL_DDC_BUS_GRANTED;
+	r = regmap_write(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, val);
+	if (r) {
+		dev_err(dev, "error closing switch to DDC BUS REQUEST\n");
+		return r;
+	}
+
+	*ctrl_reg = val;
+
+	return 0;
+}
+
+static int sii9022_release_ddc_access(struct panel_drv_data *ddata,
+	unsigned ctrl_reg)
+{
+	struct device *dev = &ddata->i2c_client->dev;
+	unsigned int val;
+	int r;
+	unsigned retries;
+
+	val = ctrl_reg;
+	val &= ~(SII9022_SYS_CTRL_DDC_BUS_REQUEST |
+		SII9022_SYS_CTRL_DDC_BUS_GRANTED);
+
+	/* retry write until we can read the register, and the bits are 0 */
+	for (retries = 5; retries > 0; --retries) {
+		unsigned v;
+
+		/* ignore error, as the chip won't ACK this. */
+		regmap_write(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, val);
+
+		r = regmap_read(ddata->regmap, SII9022_SYS_CTRL_DATA_REG, &v);
+		if (r)
+			continue;
+
+		if (v == val)
+			break;
+	}
+
+	if (retries == 0) {
+		dev_err(dev, "error releasing DDC Bus Access\n");
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_write_avi_infoframe(struct panel_drv_data *ddata)
+{
+	struct regmap *regmap = ddata->regmap;
+	u8 data[HDMI_INFOFRAME_SIZE(AVI)];
+	int r;
+
+	r = hdmi_avi_infoframe_pack(&ddata->frame, data, sizeof(data));
+	if (r < 0)
+		return r;
+
+	print_hex_dump_debug("AVI: ", DUMP_PREFIX_NONE, 16, 1, data,
+		HDMI_INFOFRAME_SIZE(AVI), false);
+
+	/* SiI9022 wants the checksum + the avi infoframe */
+	r = regmap_bulk_write(regmap, SII9022_AVI_INFOFRAME_BASE_REG,
+		&data[3], 1 + HDMI_AVI_INFOFRAME_SIZE);
+
+	return r;
+}
+
+static int sii9022_clear_avi_infoframe(struct panel_drv_data *ddata)
+{
+	struct regmap *regmap = ddata->regmap;
+	u8 data[1 + HDMI_AVI_INFOFRAME_SIZE] = { 0 };
+	int r;
+
+	r = regmap_bulk_write(regmap, SII9022_AVI_INFOFRAME_BASE_REG,
+		data, 1 + HDMI_AVI_INFOFRAME_SIZE);
+
+	return r;
+}
+
+static int sii9022_probe_chip_version(struct panel_drv_data *ddata)
+{
+	struct device *dev = &ddata->i2c_client->dev;
+	int r = 0;
+	unsigned id, rev, tpi_id;
+
+	r = regmap_read(ddata->regmap, SII9022_DEVICE_ID_REG, &id);
+	if (r) {
+		dev_err(dev, "failed to read device ID\n");
+		return r;
+	}
+
+	if (id != SII9022_ID_902xA) {
+		dev_err(dev, "unsupported device ID: 0x%x\n", id);
+		return -ENODEV;
+	}
+
+	r = regmap_read(ddata->regmap, SII9022_DEVICE_REV_ID_REG, &rev);
+	if (r) {
+		dev_err(dev, "failed to read device revision\n");
+		return r;
+	}
+
+	r = regmap_read(ddata->regmap, SII9022_DEVICE_TPI_ID_REG, &tpi_id);
+	if (r) {
+		dev_err(dev, "failed to read TPI ID\n");
+		return r;
+	}
+
+	dev_info(dev, "SiI902xA HDMI device %x, rev %x, tpi %x\n",
+		id, rev, tpi_id);
+
+	return r;
+}
+
+static int sii9022_enable_tpi(struct panel_drv_data *ddata)
+{
+	struct device *dev = &ddata->i2c_client->dev;
+	int r;
+
+	r = regmap_write(ddata->regmap, SII9022_TPI_RQB_REG, 0);
+	if (r) {
+		dev_err(dev, "failed to enable TPI commands\n");
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_enable_tmds(struct panel_drv_data *ddata, bool enable)
+{
+	struct regmap *regmap = ddata->regmap;
+	struct device *dev = &ddata->i2c_client->dev;
+	int r;
+
+	r = regmap_update_bits(regmap, SII9022_SYS_CTRL_DATA_REG,
+		1 << 4, (enable ? 0 : 1) << 4);
+	if (r) {
+		dev_err(dev, "failed to %s TMDS output\n",
+			enable ? "enable" : "disable");
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_setup_video(struct panel_drv_data *ddata,
+	struct omap_video_timings *timings)
+{
+	struct regmap *regmap = ddata->regmap;
+	struct device *dev = &ddata->i2c_client->dev;
+	int r;
+	unsigned pck = timings->pixelclock / 10000;
+	unsigned xres = timings->x_res;
+	unsigned yres = timings->y_res;
+	unsigned vfreq = 60;
+
+	u8 vals[] = {
+		pck & 0xff,
+		(pck & 0xff00) >> 8,
+		vfreq & 0xff,
+		(vfreq & 0xff00) >> 8,
+		(xres & 0xff),
+		(xres & 0xff00) >> 8,
+		(yres & 0xff),
+		(yres & 0xff00) >> 8,
+	};
+
+	r = regmap_bulk_write(regmap, SII9022_VIDEO_DATA_BASE_REG,
+		&vals, ARRAY_SIZE(vals));
+	if (r) {
+		dev_err(dev, "failed to write video mode config\n");
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_hw_enable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct regmap *regmap = ddata->regmap;
+	struct device *dev = &ddata->i2c_client->dev;
+	int r;
+
+	/* make sure we're in D2 */
+	r = sii9022_set_power_state(ddata, SII9022_POWER_STATE_D2);
+	if (r)
+		return r;
+
+	r = sii9022_setup_video(ddata, &ddata->timings);
+	if (r)
+		return r;
+
+	/* configure input video format */
+	r = regmap_write(regmap, SII9022_AVI_IN_FORMAT_REG, 0);
+	if (r) {
+		dev_err(dev, "failed to set input format\n");
+		return r;
+	}
+
+	/* configure output video format */
+	r = regmap_write(regmap, SII9022_AVI_OUT_FORMAT_REG,
+		(1 << 4)); /* CONV_BT709 */
+	if (r) {
+		dev_err(dev, "failed to set output format\n");
+		return r;
+	}
+
+	if (ddata->hdmi_mode)
+		r = sii9022_write_avi_infoframe(ddata);
+	else
+		r = sii9022_clear_avi_infoframe(ddata);
+
+	if (r) {
+		dev_err(dev, "failed to write AVI infoframe\n");
+		return r;
+	}
+
+	/* select DVI / HDMI */
+	/* note: must be done before D0 */
+	r = regmap_update_bits(regmap, SII9022_SYS_CTRL_DATA_REG,
+		1 << 0, ddata->hdmi_mode ? 1 : 0); /* 0 = DVI, 1 = HDMI */
+	if (r) {
+		dev_err(dev, "failed to set DVI/HDMI mode\n");
+		return r;
+	}
+
+	/* power up transmitter */
+	r = sii9022_set_power_state(ddata, SII9022_POWER_STATE_D0);
+	if (r)
+		return r;
+
+	/* enable TMDS */
+	r = sii9022_enable_tmds(ddata, true);
+	if (r)
+		return r;
+
+	/* configure input bus and pixel repetition */
+	/* Note: must be done after enabling TMDS */
+	r = regmap_write(regmap, SII9022_PIXEL_REPETITION_REG,
+		(0 << 4) |	/* Edge select = latch on falling edge */
+		(1 << 5) |	/* 24BIT */
+		(1 << 6)	/* CLK_RATIO_1X */
+		);
+	if (r) {
+		dev_err(dev, "failed to write pixel repetition reg\n");
+		return r;
+	}
+
+	return 0;
+}
+
+static int sii9022_hw_disable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	int r;
+
+	sii9022_enable_tmds(ddata, false);
+
+	r = sii9022_set_power_state(ddata, SII9022_POWER_STATE_D2);
+	if (r)
+		return r;
+
+	return 0;
+}
+
+static void sii9022_handle_hpd(struct panel_drv_data *ddata)
+{
+	struct device *dev = &ddata->i2c_client->dev;
+	unsigned int stat;
+	int r;
+	bool htplg, rxsense;
+	bool htplg_ev, rxsense_ev;
+
+	htplg_ev = rxsense_ev = false;
+
+	r = regmap_read(ddata->regmap, SII9022_IRQ_STATUS_REG, &stat);
+
+	if (stat & 0x3) {
+		if (stat & 1)
+			htplg_ev = true;
+		if (stat & 2)
+			rxsense_ev = true;
+
+		regmap_write(ddata->regmap, SII9022_IRQ_STATUS_REG, 0x3);
+	}
+
+	htplg = stat & (1 << 2);
+	rxsense = stat & (1 << 3);
+
+	if (ddata->htplg_state != htplg || htplg_ev) {
+		dev_dbg(dev, "hotplug %sconnect\n", htplg ? "" : "dis");
+		ddata->htplg_state = htplg;
+	}
+
+	if (ddata->rxsense_state != rxsense || rxsense_ev) {
+		dev_dbg(dev, "rxsense %sconnect\n", rxsense ? "" : "dis");
+		ddata->rxsense_state = rxsense;
+	}
+}
+
+static irqreturn_t sii9022_irq_handler(int irq, void *arg)
+{
+	struct panel_drv_data *ddata = arg;
+
+	mutex_lock(&ddata->lock);
+
+	sii9022_handle_hpd(ddata);
+
+	mutex_unlock(&ddata->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void sii9022_poll(struct work_struct *work)
+{
+	struct panel_drv_data *ddata;
+
+	ddata = container_of(work, struct panel_drv_data, work.work);
+
+	mutex_lock(&ddata->lock);
+
+	sii9022_handle_hpd(ddata);
+
+	mutex_unlock(&ddata->lock);
+
+	schedule_delayed_work(&ddata->work, msecs_to_jiffies(250));
+}
+
+static int sii9022_connect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct device *dev = &ddata->i2c_client->dev;
+	struct omap_dss_device *in = ddata->in;
+	int r;
+
+	if (omapdss_device_is_connected(dssdev))
+		return -EBUSY;
+
+	r = in->ops.dpi->connect(in, dssdev);
+	if (r)
+		return r;
+
+	mutex_lock(&ddata->lock);
+
+	r = sii9022_set_power_state(ddata, SII9022_POWER_STATE_D2);
+	if (r)
+		goto err_pwr;
+
+	ddata->htplg_state = ddata->rxsense_state = false;
+
+	sii9022_handle_hpd(ddata);
+
+	regmap_write(ddata->regmap, SII9022_IRQ_ENABLE_REG, 0x3);
+
+	if (ddata->use_polling) {
+		INIT_DELAYED_WORK(&ddata->work, sii9022_poll);
+		schedule_delayed_work(&ddata->work, msecs_to_jiffies(250));
+	} else {
+		r = devm_request_threaded_irq(dev, ddata->irq,
+			NULL, sii9022_irq_handler,
+			IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+			"sii9022 int", ddata);
+		if (r) {
+			dev_err(dev, "failed to request irq\n");
+			goto err_irq;
+		}
+	}
+
+	dst->src = dssdev;
+	dssdev->dst = dst;
+
+	mutex_unlock(&ddata->lock);
+
+	return 0;
+
+err_irq:
+err_pwr:
+	mutex_unlock(&ddata->lock);
+	in->ops.dpi->disconnect(in, dssdev);
+	return r;
+}
+
+static void sii9022_disconnect(struct omap_dss_device *dssdev,
+		struct omap_dss_device *dst)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct device *dev = &ddata->i2c_client->dev;
+	struct omap_dss_device *in = ddata->in;
+
+	WARN_ON(!omapdss_device_is_connected(dssdev));
+	if (!omapdss_device_is_connected(dssdev))
+		return;
+
+	WARN_ON(dst != dssdev->dst);
+	if (dst != dssdev->dst)
+		return;
+
+	if (ddata->use_polling)
+		cancel_delayed_work_sync(&ddata->work);
+	else
+		devm_free_irq(dev, ddata->irq, ddata);
+
+	dst->src = NULL;
+	dssdev->dst = NULL;
+
+	in->ops.dpi->disconnect(in, dssdev);
+}
+
+static int sii9022_enable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+	int r;
+
+	if (!omapdss_device_is_connected(dssdev))
+		return -ENODEV;
+
+	if (omapdss_device_is_enabled(dssdev))
+		return 0;
+
+	in->ops.dpi->set_timings(in, &ddata->timings);
+
+	r = in->ops.dpi->enable(in);
+	if (r)
+		return r;
+
+	if (ddata->reset_gpio)
+		gpiod_set_value_cansleep(ddata->reset_gpio, 0);
+
+	mutex_lock(&ddata->lock);
+
+	r = sii9022_hw_enable(dssdev);
+	if (r)
+		goto err_hw_enable;
+
+	mutex_unlock(&ddata->lock);
+
+	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+
+	return 0;
+
+err_hw_enable:
+	mutex_unlock(&ddata->lock);
+
+	if (ddata->reset_gpio)
+		gpiod_set_value_cansleep(ddata->reset_gpio, 1);
+
+	in->ops.dpi->disable(in);
+
+	return r;
+}
+
+static void sii9022_disable(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	if (!omapdss_device_is_enabled(dssdev))
+		return;
+
+	mutex_lock(&ddata->lock);
+
+	sii9022_hw_disable(dssdev);
+
+	mutex_unlock(&ddata->lock);
+
+	if (ddata->reset_gpio)
+		gpiod_set_value_cansleep(ddata->reset_gpio, 1);
+
+	in->ops.dpi->disable(in);
+
+	dssdev->state = OMAP_DSS_DISPLAY_DISABLED;
+}
+
+static void sii9022_set_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+	struct omap_video_timings t = *timings;
+
+	/* update DPI specific timing info */
+	t.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;
+	t.de_level = OMAPDSS_SIG_ACTIVE_HIGH;
+	t.sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;
+
+	ddata->timings = t;
+	dssdev->panel.timings = t;
+
+	in->ops.dpi->set_timings(in, &t);
+}
+
+static void sii9022_get_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	*timings = ddata->timings;
+}
+
+static int sii9022_check_timings(struct omap_dss_device *dssdev,
+		struct omap_video_timings *timings)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	struct omap_dss_device *in = ddata->in;
+
+	/* update DPI specific timing info */
+	timings->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;
+	timings->de_level = OMAPDSS_SIG_ACTIVE_HIGH;
+	timings->sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;
+
+	return in->ops.dpi->check_timings(in, timings);
+}
+
+static int _sii9022_read_edid(struct panel_drv_data *ddata,
+		u8 *edid, int len)
+{
+	struct i2c_client *client = ddata->i2c_client;
+	unsigned ctrl_reg;
+	int r, l, bytes_read;
+
+	r = sii9022_request_ddc_access(ddata, &ctrl_reg);
+	if (r)
+		return r;
+
+	l = min(len, EDID_LENGTH);
+
+	r = sii9022_ddc_read(client->adapter, edid, l, 0);
+	if (r)
+		goto err_ddc_read;
+
+	bytes_read = l;
+
+	/* if there are extensions, read second block */
+	if (len > EDID_LENGTH && edid[0x7e] > 0) {
+		l = min(EDID_LENGTH, len - EDID_LENGTH);
+
+		r = sii9022_ddc_read(client->adapter, edid + EDID_LENGTH,
+				l, EDID_LENGTH);
+		if (r)
+			goto err_ddc_read;
+
+		bytes_read += l;
+	}
+
+	r = sii9022_release_ddc_access(ddata, ctrl_reg);
+	if (r)
+		goto err_ddc_read;
+
+	return bytes_read;
+
+err_ddc_read:
+	sii9022_release_ddc_access(ddata, ctrl_reg);
+
+	return r;
+}
+
+static int sii9022_read_edid(struct omap_dss_device *dssdev,
+		u8 *edid, int len)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	int r;
+
+	mutex_lock(&ddata->lock);
+
+	if (ddata->use_polling)
+		sii9022_handle_hpd(ddata);
+
+	if (ddata->htplg_state == false) {
+		r = -ENODEV;
+		goto err_hpd;
+	}
+
+	/*
+	 * Sometimes we get -EREMOTEIO. The reason is unclear, but doing an i2c
+	 * read to SiI9022 after requesting the DDC access seems to cause
+	 * -EREMOTEIO both from the first i2c read and from the subsequent EDID
+	 * read. We don't do that, but it could mean that SiI9022 has some
+	 * issues around the DDC access.
+	 *
+	 * Retrying the EDID read solves the problem.
+	 */
+
+	r = _sii9022_read_edid(ddata, edid, len);
+	if (r == -EREMOTEIO)
+		r = _sii9022_read_edid(ddata, edid, len);
+	if (r < 0)
+		goto err_ddc_read;
+
+	print_hex_dump_debug("EDID: ", DUMP_PREFIX_NONE, 16, 1, edid,
+		r, false);
+
+	mutex_unlock(&ddata->lock);
+
+	return r;
+
+err_ddc_read:
+err_hpd:
+	mutex_unlock(&ddata->lock);
+
+	return r;
+}
+
+static bool sii9022_detect(struct omap_dss_device *dssdev)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	bool hpd;
+
+	mutex_lock(&ddata->lock);
+
+	if (ddata->use_polling)
+		sii9022_handle_hpd(ddata);
+
+	hpd = ddata->htplg_state;
+
+	mutex_unlock(&ddata->lock);
+
+	return hpd;
+}
+
+static int sii9022_set_infoframe(struct omap_dss_device *dssdev,
+	const struct hdmi_avi_infoframe *infoframe)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+
+	ddata->frame = *infoframe;
+
+	return 0;
+}
+
+
+static int sii9022_set_hdmi_mode(struct omap_dss_device *dssdev, bool hdmi_mode)
+{
+	struct panel_drv_data *ddata = to_panel_data(dssdev);
+
+	ddata->hdmi_mode = hdmi_mode;
+
+	return 0;
+}
+
+static const struct omapdss_hdmi_ops sii9022_hdmi_ops = {
+	.connect		= sii9022_connect,
+	.disconnect		= sii9022_disconnect,
+
+	.enable			= sii9022_enable,
+	.disable		= sii9022_disable,
+
+	.check_timings		= sii9022_check_timings,
+	.set_timings		= sii9022_set_timings,
+	.get_timings		= sii9022_get_timings,
+
+	.read_edid		= sii9022_read_edid,
+	.detect			= sii9022_detect,
+	.set_hdmi_mode		= sii9022_set_hdmi_mode,
+	.set_infoframe		= sii9022_set_infoframe,
+};
+
+static int sii9022_probe_of(struct i2c_client *client)
+{
+	struct panel_drv_data *ddata = dev_get_drvdata(&client->dev);
+	struct device_node *node = client->dev.of_node;
+	struct omap_dss_device *in;
+	struct gpio_desc *gpio;
+
+	gpio = devm_gpiod_get_optional(&client->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+
+	ddata->reset_gpio = gpio;
+
+	ddata->irq = irq_of_parse_and_map(node, 0);
+	if (ddata->irq > 0)
+		ddata->use_polling = false;
+	else
+		ddata->use_polling = true;
+
+	in = omapdss_of_find_source_for_first_ep(node);
+	if (IS_ERR(in)) {
+		dev_err(&client->dev, "failed to find video source\n");
+		return PTR_ERR(in);
+	}
+
+	ddata->in = in;
+
+	return 0;
+}
+
+static int sii9022_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct panel_drv_data *ddata;
+	struct omap_dss_device *dssdev;
+	struct regmap *regmap;
+	int r = 0;
+
+	regmap = devm_regmap_init_i2c(client, &sii9022_regmap_config);
+	if (IS_ERR(regmap)) {
+		r = PTR_ERR(regmap);
+		dev_err(&client->dev, "Failed to init regmap: %d\n", r);
+		return r;
+	}
+
+	ddata = devm_kzalloc(&client->dev, sizeof(*ddata), GFP_KERNEL);
+	if (ddata == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&client->dev, ddata);
+
+	mutex_init(&ddata->lock);
+
+	if (client->dev.of_node) {
+		r = sii9022_probe_of(client);
+		if (r)
+			return r;
+	} else {
+		return -ENODEV;
+	}
+
+	ddata->regmap = regmap;
+	ddata->i2c_client = client;
+
+	dssdev = &ddata->dssdev;
+	dssdev->dev = &client->dev;
+	dssdev->ops.hdmi = &sii9022_hdmi_ops;
+	dssdev->type = OMAP_DISPLAY_TYPE_DPI;
+	dssdev->output_type = OMAP_DISPLAY_TYPE_HDMI;
+	dssdev->owner = THIS_MODULE;
+	dssdev->port_num = 1;
+
+	r = sii9022_enable_tpi(ddata);
+	if (r)
+		goto err_tpi;
+
+	r = sii9022_probe_chip_version(ddata);
+	if (r)
+		goto err_i2c;
+
+	r = omapdss_register_output(dssdev);
+	if (r) {
+		dev_err(&client->dev, "Failed to register output\n");
+		goto err_reg;
+	}
+
+#ifdef CONFIG_DISPLAY_ENCODER_SII9022_AUDIO_CODEC
+	r = sii9022_hdmi_codec_register(&client->dev);
+	if (r)
+		dev_err(&client->dev,
+			"Failed to register audio codec, no audio support!\n");
+#endif
+
+	return 0;
+err_reg:
+err_i2c:
+err_tpi:
+	omap_dss_put_device(ddata->in);
+	return r;
+}
+
+static int sii9022_remove(struct i2c_client *client)
+{
+	struct panel_drv_data *ddata = dev_get_drvdata(&client->dev);
+	struct omap_dss_device *dssdev = &ddata->dssdev;
+
+#ifdef CONFIG_DISPLAY_ENCODER_SII9022_AUDIO_CODEC
+	sii9022_hdmi_codec_unregister(&client->dev);
+#endif
+
+	omapdss_unregister_output(dssdev);
+
+	WARN_ON(omapdss_device_is_enabled(dssdev));
+	if (omapdss_device_is_enabled(dssdev))
+		sii9022_disable(dssdev);
+
+	WARN_ON(omapdss_device_is_connected(dssdev));
+	if (omapdss_device_is_connected(dssdev))
+		sii9022_disconnect(dssdev, dssdev->dst);
+
+	omap_dss_put_device(ddata->in);
+
+	return 0;
+}
+
+static const struct i2c_device_id sii9022_id[] = {
+	{ "sii9022", 0 },
+	{ },
+};
+
+static const struct of_device_id sii9022_of_match[] = {
+	{ .compatible = "omapdss,sil,sii9022", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, sii9022_id);
+
+static struct i2c_driver sii9022_driver = {
+	.driver = {
+		.name  = "sii9022",
+		.owner = THIS_MODULE,
+		.of_match_table = sii9022_of_match,
+		},
+	.probe		= sii9022_probe,
+	.remove		= sii9022_remove,
+	.id_table	= sii9022_id,
+};
+
+module_i2c_driver(sii9022_driver);
+
+MODULE_AUTHOR("Tomi Valkeinen <tomi.valkeinen@ti.com>");
+MODULE_DESCRIPTION("SiI9022 HDMI Encoder Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/omap2/displays-new/encoder-sii9022.h b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022.h
new file mode 100644
index 0000000..c67844a
--- /dev/null
+++ b/drivers/video/fbdev/omap2/displays-new/encoder-sii9022.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2014 Texas Instruments
+ * Author : Tomi Valkeinen <tomi.valkeinen@ti.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#ifndef __ENCODER_SII9022_H_
+#define __ENCODER_SII9022_H_
+
+#define SII9022_ID_902xA		0xb0
+
+#define HDMI_I2C_MONITOR_ADDRESS	0x50
+
+#define SII9022_VIDEO_DATA_BASE_REG	0x00
+#define SII9022_PIXEL_CLK_LSB_REG	(SII9022_VIDEO_DATA_BASE_REG + 0x00)
+#define SII9022_PIXEL_CLK_MSB_REG	(SII9022_VIDEO_DATA_BASE_REG + 0x01)
+#define SII9022_VFREQ_LSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x02)
+#define SII9022_VFREQ_MSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x03)
+#define SII9022_PIXELS_LSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x04)
+#define SII9022_PIXELS_MSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x05)
+#define SII9022_LINES_LSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x06)
+#define SII9022_LINES_MSB_REG		(SII9022_VIDEO_DATA_BASE_REG + 0x07)
+
+#define SII9022_PIXEL_REPETITION_REG	0x08
+
+#define SII9022_AVI_IN_FORMAT_REG	0x09
+#define SII9022_AVI_OUT_FORMAT_REG	0x0a
+#define SII9022_AVI_INFOFRAME_BASE_REG	0x0c
+
+#define SII9022_SYS_CTRL_DATA_REG	0x1a
+#define SII9022_DEVICE_ID_REG		0x1b
+#define SII9022_DEVICE_REV_ID_REG	0x1c
+#define SII9022_DEVICE_TPI_ID_REG	0x1d
+
+#define SII9022_POWER_STATE_CTRL_REG	0x1e
+
+#define SII9022_IRQ_ENABLE_REG		0x3c
+#define SII9022_IRQ_STATUS_REG		0x3d
+
+#define SII9022_TPI_RQB_REG		0xc7
+
+/* Indirect internal register access */
+#define HDMI_IND_SET_PAGE		0xbc
+#define HDMI_IND_OFFSET			0xbd
+#define HDMI_IND_VALUE			0xbe
+
+/* AVI InfoFrame */
+#define HDMI_CPI_MISC_IF_SELECT_REG     0xbf
+#define HDMI_CPI_MISC_IF_OFFSET         0xC0
+
+/* Audio  */
+#define HDMI_TPI_I2S_ENABLE_MAPPING_REG 0x1f
+#define HDMI_TPI_I2S_INPUT_CONFIG_REG   0x20
+#define HDMI_TPI_I2S_STRM_HDR_BASE      0x21
+#define HDMI_TPI_I2S_STRM_HDR_0_REG     (HDMI_TPI_I2S_STRM_HDR_BASE + 0)
+#define HDMI_TPI_I2S_STRM_HDR_1_REG     (HDMI_TPI_I2S_STRM_HDR_BASE + 1)
+#define HDMI_TPI_I2S_STRM_HDR_2_REG     (HDMI_TPI_I2S_STRM_HDR_BASE + 2)
+#define HDMI_TPI_I2S_STRM_HDR_3_REG     (HDMI_TPI_I2S_STRM_HDR_BASE + 3)
+#define HDMI_TPI_I2S_STRM_HDR_4_REG     (HDMI_TPI_I2S_STRM_HDR_BASE + 4)
+#define HDMI_TPI_AUDIO_CONFIG_BYTE2_REG	0x26
+#define HDMI_TPI_AUDIO_CONFIG_BYTE3_REG	0x27
+#define HDMI_TPI_AUDIO_CONFIG_BYTE4_REG	0x28
+
+/* SII9022_SYS_CTRL_DATA_REG */
+#define SII9022_SYS_CTRL_DDC_BUS_GRANTED	BIT(1)
+#define SII9022_SYS_CTRL_DDC_BUS_REQUEST	BIT(2)
+
+/* HDMI_TPI_AUDIO_CONFIG_BYTE2_REG  */
+#define TPI_AUDIO_CODING_STREAM_HEADER		(0 << 0)
+#define TPI_AUDIO_CODING_PCM			(1 << 0)
+#define TPI_AUDIO_CODING_AC3			(2 << 0)
+#define TPI_AUDIO_CODING_MPEG1			(3 << 0)
+#define TPI_AUDIO_CODING_MP3			(4 << 0)
+#define TPI_AUDIO_CODING_MPEG2			(5 << 0)
+#define TPI_AUDIO_CODING_AAC			(6 << 0)
+#define TPI_AUDIO_CODING_DTS			(7 << 0)
+#define TPI_AUDIO_CODING_ATRAC			(8 << 0)
+#define TPI_AUDIO_MUTE_DISABLE			(0 << 4)
+#define TPI_AUDIO_MUTE_ENABLE			(1 << 4)
+#define TPI_AUDIO_LAYOUT_2_CHANNELS		(0 << 5)
+#define TPI_AUDIO_LAYOUT_8_CHANNELS		(1 << 5)
+#define TPI_AUDIO_INTERFACE_DISABLE		(0 << 6)
+#define TPI_AUDIO_INTERFACE_SPDIF		(1 << 6)
+#define TPI_AUDIO_INTERFACE_I2S			(2 << 6)
+
+/* HDMI_TPI_AUDIO_CONFIG_BYTE3_REG  */
+#define TPI_AUDIO_CHANNEL_STREAM		(0 << 0)
+#define TPI_AUDIO_2_CHANNEL			(1 << 0)
+#define TPI_AUDIO_8_CHANNEL			(7 << 0)
+#define TPI_AUDIO_FREQ_STREAM			(0 << 3)
+#define TPI_AUDIO_FREQ_32KHZ			(1 << 3)
+#define TPI_AUDIO_FREQ_44KHZ			(2 << 3)
+#define TPI_AUDIO_FREQ_48KHZ			(3 << 3)
+#define TPI_AUDIO_FREQ_88KHZ			(4 << 3)
+#define TPI_AUDIO_FREQ_96KHZ			(5 << 3)
+#define TPI_AUDIO_FREQ_176KHZ			(6 << 3)
+#define TPI_AUDIO_FREQ_192KHZ			(7 << 3)
+#define TPI_AUDIO_SAMPLE_SIZE_STREAM		(0 << 6)
+#define TPI_AUDIO_SAMPLE_SIZE_16		(1 << 6)
+#define TPI_AUDIO_SAMPLE_SIZE_20		(2 << 6)
+#define TPI_AUDIO_SAMPLE_SIZE_24		(3 << 6)
+
+/* HDMI_TPI_I2S_ENABLE_MAPPING_REG  */
+#define TPI_I2S_CONFIG_FIFO0			(0 << 0)
+#define TPI_I2S_CONFIG_FIFO1			(1 << 0)
+#define TPI_I2S_CONFIG_FIFO2			(2 << 0)
+#define TPI_I2S_CONFIG_FIFO3			(3 << 0)
+#define TPI_I2S_LEFT_RIGHT_SWAP			(1 << 2)
+#define TPI_I2S_AUTO_DOWNSAMPLE			(1 << 3)
+#define TPI_I2S_SELECT_SD0			(0 << 4)
+#define TPI_I2S_SELECT_SD1			(1 << 4)
+#define TPI_I2S_SELECT_SD2			(2 << 4)
+#define TPI_I2S_SELECT_SD3			(3 << 4)
+#define TPI_I2S_FIFO_ENABLE			(1 << 7)
+
+/* HDMI_TPI_I2S_INPUT_CONFIG_REG  */
+#define TPI_I2S_FIRST_BIT_SHIFT_YES		(0 << 0)
+#define TPI_I2S_FIRST_BIT_SHIFT_NO		(1 << 0)
+#define TPI_I2S_SD_DIRECTION_MSB_FIRST		(0 << 1)
+#define TPI_I2S_SD_DIRECTION_LSB_FIRST		(1 << 1)
+#define TPI_I2S_SD_JUSTIFY_LEFT			(0 << 2)
+#define TPI_I2S_SD_JUSTIFY_RIGHT		(1 << 2)
+#define TPI_I2S_WS_POLARITY_LOW			(0 << 3)
+#define TPI_I2S_WS_POLARITY_HIGH		(1 << 3)
+#define TPI_I2S_MCLK_MULTIPLIER_128		(0 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_256		(1 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_384		(2 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_512		(3 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_768		(4 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_1024		(5 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_1152		(6 << 4)
+#define TPI_I2S_MCLK_MULTIPLIER_192		(7 << 4)
+#define TPI_I2S_SCK_EDGE_FALLING		(0 << 7)
+#define TPI_I2S_SCK_EDGE_RISING			(1 << 7)
+
+enum sii9022_power_state {
+	SII9022_POWER_STATE_D0,
+	SII9022_POWER_STATE_D2,
+	SII9022_POWER_STATE_D3_HOT,
+	SII9022_POWER_STATE_D3_COLD,
+};
+
+struct sii9022_audio;
+struct panel_drv_data {
+	struct omap_dss_device dssdev;
+	struct omap_dss_device *in;
+	struct i2c_client *i2c_client;
+	struct gpio_desc *reset_gpio;
+	struct regmap *regmap;
+	struct omap_video_timings timings;
+	struct delayed_work work;
+	struct sii9022_audio *audio;
+	struct mutex lock;
+
+	int irq;
+	bool use_polling;
+
+	bool htplg_state;
+	bool rxsense_state;
+
+	bool hdmi_mode;
+	struct hdmi_avi_infoframe frame;
+};
+
+#define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)
+
+int sii9022_hdmi_codec_register(struct device *dev);
+void sii9022_hdmi_codec_unregister(struct device *dev);
+
+#endif
diff --git a/include/dt-bindings/sound/sii9022-audio.h b/include/dt-bindings/sound/sii9022-audio.h
new file mode 100644
index 0000000..d8f0847
--- /dev/null
+++ b/include/dt-bindings/sound/sii9022-audio.h
@@ -0,0 +1,12 @@
+#ifndef __DT_SII9022_AUDIO_H
+#define __DT_SII9022_AUDIO_H
+
+#define ENABLE_BIT			0x80
+#define CONNECT_SD0			0x00
+#define CONNECT_SD1			0x10
+#define CONNECT_SD2			0x20
+#define CONNECT_SD3			0x30
+#define AUTOMATIC_DOWNSAMPLE_BIT	0x08
+#define LEFT_RIGHT_SWAP_BIT		0x04
+
+#endif /* __DT_SII9022_AUDIO_H */
-- 
1.7.5.4

