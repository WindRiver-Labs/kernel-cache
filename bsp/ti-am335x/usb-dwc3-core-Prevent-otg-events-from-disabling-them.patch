From 95d6ee7a67d34f8768f60c4279d3f1d65117a055 Mon Sep 17 00:00:00 2001
From: Roger Quadros <rogerq@ti.com>
Date: Tue, 28 Jul 2015 15:18:56 +0300
Subject: [PATCH 331/800] usb: dwc3: core: Prevent otg events from disabling
 themselves

There is a race happening during dwc3_drd_init() that causes
otg events to get disabled. This is what happens.

dwc3_otg_irq() happens immediately when PRTCAP is set to OTG,
even though OEVTEN is 0. This is because BIT 31 IRQ of
OEVT can't be disabled by OEVTEN.
We configure OEVTEN in dwc3_otg_init() but dwc3_otg_irq() has
already saved OEVTEN as 0 into dwc->oevten. So finally when
dwc3_irq_thread_irq() is called we save 0 into OEVTEN
thus disabling OTG irqs forever.

We fix this by disabling IRQs when configuring OEVTEN in
dwc3_otg_init().

Signed-off-by: Roger Quadros <rogerq@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/dwc3/core.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 79863ad..2178a65 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -940,6 +940,7 @@ static int dwc3_drd_init(struct dwc3 *dwc)
 	int ret, id, vbus;
 	u32 reg;
 	struct dwc3_hwparams *parms = &dwc->hwparams;
+	unsigned long flags;
 
 	/* If extcon device is not present we rely on OTG core for ID event */
 	if (!dwc->edev) {
@@ -1008,6 +1009,8 @@ try_otg_core:
 		goto error;
 	}
 
+	spin_lock_irqsave(&dwc->lock, flags);
+
 	/* we need to set OTG to get events from OTG core */
 	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_OTG);
 	/* GUSB2PHYCFG0.SusPHY=0 */
@@ -1033,6 +1036,8 @@ try_otg_core:
 	/* OCTL.PeriMode = 1 */
 	dwc3_writel(dwc->regs, DWC3_OCTL, DWC3_OCTL_PERIMODE);
 
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
 	dwc3_otg_fsm_sync(dwc);
 	usb_otg_sync_inputs(dwc->fsm);
 
-- 
1.7.5.4

