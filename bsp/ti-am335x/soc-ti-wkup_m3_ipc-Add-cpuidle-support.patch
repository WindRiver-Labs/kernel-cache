From 880e4ae1f2f87f29d6979220b1651e68a5537e33 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Wed, 1 Jul 2015 14:37:27 -0500
Subject: [PATCH 211/800] soc: ti: wkup_m3_ipc: Add cpuidle support

Add support for sending a message to the wkup_m3 to enter cpuidle state.
Currently wkup_m3 just places MPU clockdomain in sleep and handles waking
back up.

Also, add a wkup_m3_ping_noirq function internally so that we can send a
message without waiting in a completion as when we send a cpuidle
message we are in noirq context.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/soc/ti/wkup_m3_ipc.c |   33 ++++++++++++++++++++++++++++++++-
 include/linux/wkup_m3_ipc.h  |    4 ++++
 2 files changed, 36 insertions(+), 1 deletions(-)

diff --git a/drivers/soc/ti/wkup_m3_ipc.c b/drivers/soc/ti/wkup_m3_ipc.c
index 10ad725..cfb910c 100644
--- a/drivers/soc/ti/wkup_m3_ipc.c
+++ b/drivers/soc/ti/wkup_m3_ipc.c
@@ -40,6 +40,7 @@
 
 #define IPC_CMD_DS0			0x4
 #define IPC_CMD_STANDBY			0xc
+#define IPC_CMD_IDLE			0x10
 #define IPC_CMD_RESET			0xe
 #define DS_IPC_DEFAULT			0xffffffff
 #define M3_VERSION_UNKNOWN		0x0000ffff
@@ -219,6 +220,29 @@ static int wkup_m3_ping(struct wkup_m3_ipc *m3_ipc)
 	return 0;
 }
 
+static int wkup_m3_ping_noirq(struct wkup_m3_ipc *m3_ipc)
+{
+	struct device *dev = m3_ipc->dev;
+	mbox_msg_t dummy_msg = 0;
+	int ret;
+
+	if (!m3_ipc->mbox) {
+		dev_err(dev,
+			"No IPC channel to communicate with wkup_m3!\n");
+		return -EIO;
+	}
+
+	ret = mbox_send_message(m3_ipc->mbox, &dummy_msg);
+	if (ret < 0) {
+		dev_err(dev, "%s: mbox_send_message() failed: %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	mbox_client_txdone(m3_ipc->mbox, 0);
+	return 0;
+}
+
 static int wkup_m3_is_available(struct wkup_m3_ipc *m3_ipc)
 {
 	return (m3_ipc->state != M3_STATE_RESET) && (m3_ipc->state != M3_STATE_UNKNOWN);
@@ -305,6 +329,9 @@ int wkup_m3_prepare_low_power(int state)
 	case PM_SUSPEND_STANDBY:
 		m3_power_state = IPC_CMD_STANDBY;
 		break;
+	case WKUP_M3_IDLE:
+		m3_power_state = IPC_CMD_IDLE;
+		break;
 	default:
 		return 1;
 	}
@@ -324,7 +351,11 @@ int wkup_m3_prepare_low_power(int state)
 
 	m3_ipc->state = M3_STATE_MSG_FOR_LP;
 
-	ret = wkup_m3_ping(m3_ipc);
+	if (state == WKUP_M3_IDLE)
+		ret = wkup_m3_ping_noirq(m3_ipc);
+	else
+		ret = wkup_m3_ping(m3_ipc);
+
 	if (ret) {
 		dev_err(dev, "Unable to ping CM3\n");
 		return ret;
diff --git a/include/linux/wkup_m3_ipc.h b/include/linux/wkup_m3_ipc.h
index 56bcaec6..2589840 100644
--- a/include/linux/wkup_m3_ipc.h
+++ b/include/linux/wkup_m3_ipc.h
@@ -17,6 +17,10 @@
 #ifndef _LINUX_WKUP_M3_IPC_H
 #define _LINUX_WKUP_M3_IPC_H
 
+#include <linux/suspend.h>
+
+#define WKUP_M3_IDLE (PM_SUSPEND_MAX + 1)
+
 struct wkup_m3_wakeup_src {
 	int irq_nr;
 	char src[10];
-- 
1.7.5.4

