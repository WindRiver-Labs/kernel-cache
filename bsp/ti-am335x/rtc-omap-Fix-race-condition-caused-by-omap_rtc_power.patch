From f9681f6cf51d7a4072b2fc8156dd257a04e8c9a4 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Mon, 14 Sep 2015 13:01:40 -0500
Subject: [PATCH 565/800] rtc: omap: Fix race condition caused by
 omap_rtc_power_off_rtc

omap_rtc_power_off_rtc is a static instance of the omap_rtc struct
that gets instantiated by the driver during probe to be used in
functions needed for power off and rtc-only functionality.

Currently devm_rtc_device_register is called before
omap_rtc_power_off_rtc is set so there is a short time where the
rtc-omap driver is available but omap_rtc_power_off_rtc is null.
Certain functions, like omap_rtc_read_scratch, make use of
omap_rtc_power_off_rtc so there is small chance of a NULL pointer
dereference during probe if this function gets called.

Move the setting of omap_rtc_power_off_rtc to before rtc-omap registers
itself to make sure that this never happens, and refactor the cleanup
code from omap_rtc_remove to avoid duplicating in probe error path.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Acked-by: Keerthy <j-keerthy@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/rtc/rtc-omap.c |   30 ++++++++++++++++++------------
 1 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/drivers/rtc/rtc-omap.c b/drivers/rtc/rtc-omap.c
index 862e509bd..e275e5d 100644
--- a/drivers/rtc/rtc-omap.c
+++ b/drivers/rtc/rtc-omap.c
@@ -547,6 +547,15 @@ static void omap_rtc_power_off(void)
 	pr_err("rtc_power_off failed, bailing out.\n");
 }
 
+static void omap_rtc_cleanup_pm_power_off(struct omap_rtc *rtc)
+{
+	if (pm_power_off == omap_rtc_power_off &&
+	    omap_rtc_power_off_rtc == rtc) {
+		pm_power_off = NULL;
+		omap_rtc_power_off_rtc = NULL;
+	}
+}
+
 static struct rtc_class_ops omap_rtc_ops = {
 	.read_time	= omap_rtc_read_time,
 	.set_time	= omap_rtc_set_time,
@@ -718,6 +727,13 @@ static int omap_rtc_probe(struct platform_device *pdev)
 
 	device_init_wakeup(&pdev->dev, true);
 
+	if (rtc->is_pmic_controller) {
+		if (!pm_power_off) {
+			omap_rtc_power_off_rtc = rtc;
+			pm_power_off = omap_rtc_power_off;
+		}
+	}
+
 	rtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
 			&omap_rtc_ops, THIS_MODULE);
 	if (IS_ERR(rtc->rtc)) {
@@ -738,16 +754,10 @@ static int omap_rtc_probe(struct platform_device *pdev)
 			goto err;
 	}
 
-	if (rtc->is_pmic_controller) {
-		if (!pm_power_off) {
-			omap_rtc_power_off_rtc = rtc;
-			pm_power_off = omap_rtc_power_off;
-		}
-	}
-
 	return 0;
 
 err:
+	omap_rtc_cleanup_pm_power_off(rtc);
 	device_init_wakeup(&pdev->dev, false);
 	rtc->type->lock(rtc);
 	pm_runtime_put_sync(&pdev->dev);
@@ -760,11 +770,7 @@ static int __exit omap_rtc_remove(struct platform_device *pdev)
 {
 	struct omap_rtc *rtc = platform_get_drvdata(pdev);
 
-	if (pm_power_off == omap_rtc_power_off &&
-			omap_rtc_power_off_rtc == rtc) {
-		pm_power_off = NULL;
-		omap_rtc_power_off_rtc = NULL;
-	}
+	omap_rtc_cleanup_pm_power_off(rtc);
 
 	device_init_wakeup(&pdev->dev, 0);
 
-- 
1.7.5.4

