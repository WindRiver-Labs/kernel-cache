From 101c2d4ebef2c28e12e231b73dc79873fecfc5dd Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 26 Mar 2014 14:25:38 +0800
Subject: [PATCH 63/71] fbdev/da8xx-fb: fix race issues with palette loading

This commit comes from branch ti-linux-3.12.y:
  git://git.ti.com/ti-linux-kernel/ti-linux-kernel.git

When the da8xx-fb sets up a new config, it first uses the DMA to load a
palette to the hardware and then sets up the DMA to send frame data.
This happens asynchronously, without locking, and causes race issues.
Furthermore, the whole DMA setup is not done if fbconsole is not
enabled.

This patch changes the palette loading to be synchronous, as it removes
any race issues and loading the palette should be a small operation. The
new function, lcd_load_palette, sets the DMA for palette loading, waits
for it to complete, and then sets up the DMA for frame data.

Also, the lcd_init function is changed to explicitly call
lcd_load_palette, so that everything is set up correctly without needing
fbconsole (or some other component) to activate the config.

Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
Signed-off-by: Darren Etheridge <detheridge@ti.com>
(cherry picked from commit e173d0ec33ba1db24ffef9c0b7d0552786e48d8f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/video/da8xx-fb.c |   69 ++++++++++++++++++++++++++++++---------------
 1 files changed, 46 insertions(+), 23 deletions(-)

diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 56fbd76..add76fe 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -194,7 +194,6 @@ struct da8xx_fb_par {
 	unsigned int		dma_start;
 	unsigned int		dma_end;
 	struct clk *lcdc_clk;
-	struct clk *disp_clk;
 	int irq;
 	unsigned int palette_sz;
 	int blank;
@@ -203,6 +202,9 @@ struct da8xx_fb_par {
 	int			vsync_timeout;
 	spinlock_t		lock_for_chan_update;
 
+	wait_queue_head_t	palette_wait;
+	int			palette_loaded_flag;
+
 	/*
 	 * LCDC has 2 ping pong DMA channels, channel 0
 	 * and channel 1.
@@ -396,6 +398,24 @@ static void lcd_blit(int load_mode, struct da8xx_fb_par *par)
 	lcd_enable_raster();
 }
 
+static void lcd_load_palette(struct da8xx_fb_par *par)
+{
+	int r;
+
+	par->palette_loaded_flag = 0;
+
+	lcd_blit(LOAD_PALETTE, par);
+
+	r = wait_event_interruptible_timeout(par->palette_wait,
+					       par->palette_loaded_flag != 0,
+					       msecs_to_jiffies(50));
+
+	if (r == 0)
+		pr_err("LCDC timeout when loading palette\n");
+
+	lcd_blit(LOAD_DATA, par);
+}
+
 /* Configure the Burst Size and fifo threhold of DMA */
 static int lcd_cfg_dma(int burst_size, int fifo_th)
 {
@@ -719,7 +739,7 @@ static int fb_setcolreg(unsigned regno, unsigned red, unsigned green,
 
 	/* Update the palette in the h/w as needed. */
 	if (update_hw)
-		lcd_blit(LOAD_PALETTE, par);
+		lcd_load_palette(par);
 
 	return 0;
 }
@@ -893,6 +913,8 @@ static int lcd_init(struct da8xx_fb_par *par, const struct lcd_ctrl_config *cfg,
 	if (ret < 0)
 		return ret;
 
+	lcd_load_palette(par);
+
 	/* Configure FDD */
 	lcdc_write((lcdc_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |
 		       (cfg->fdd << 12), LCD_RASTER_CTRL_REG);
@@ -950,8 +972,8 @@ static irqreturn_t lcdc_irq_handler_rev02(int irq, void *arg)
 		/* Disable PL completion interrupt */
 		lcdc_write(LCD_V2_PL_INT_ENA, LCD_INT_ENABLE_CLR_REG);
 
-		/* Setup and start data loading mode */
-		lcd_blit(LOAD_DATA, par);
+		par->palette_loaded_flag = 1;
+		wake_up_interruptible(&par->palette_wait);
 	} else {
 		lcdc_write(stat, LCD_MASKED_STAT_REG);
 
@@ -1019,8 +1041,8 @@ static irqreturn_t lcdc_irq_handler_rev01(int irq, void *arg)
 		reg_ras &= ~LCD_V1_PL_INT_ENA;
 		lcdc_write(reg_ras, LCD_RASTER_CTRL_REG);
 
-		/* Setup and start data loading mode */
-		lcd_blit(LOAD_DATA, par);
+		par->palette_loaded_flag = 1;
+		wake_up_interruptible(&par->palette_wait);
 	} else {
 		lcdc_write(stat, LCD_STAT_REG);
 
@@ -1646,6 +1668,18 @@ static int fb_probe(struct platform_device *device)
 		goto err_release_pl_mem;
 	}
 
+	if (lcd_revision == LCD_VERSION_1)
+		lcdc_irq_handler = lcdc_irq_handler_rev01;
+	else {
+		init_waitqueue_head(&frame_done_wq);
+		lcdc_irq_handler = lcdc_irq_handler_rev02;
+	}
+
+	ret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,
+			       DRIVER_NAME, par);
+	if (ret)
+		goto err_release_pl_mem;
+
 	da8xx_fb_var.grayscale =
 	    lcd_cfg->panel_shade == MONOCHROME ? 1 : 0;
 	da8xx_fb_var.bits_per_pixel = lcd_cfg->bpp;
@@ -1664,10 +1698,6 @@ static int fb_probe(struct platform_device *device)
 		goto err_release_pl_mem;
 	da8xx_fb_info->cmap.len = par->palette_sz;
 
-	/* initialize var_screeninfo */
-	da8xx_fb_var.activate = FB_ACTIVATE_FORCE;
-	fb_set_var(da8xx_fb_info, &da8xx_fb_var);
-
 	dev_set_drvdata(&device->dev, da8xx_fb_info);
 
 	/* initialize the vsync wait queue */
@@ -1676,6 +1706,12 @@ static int fb_probe(struct platform_device *device)
 	par->which_dma_channel_done = -1;
 	spin_lock_init(&par->lock_for_chan_update);
 
+	init_waitqueue_head(&par->palette_wait);
+
+	/* set var and par */
+	da8xx_fb_var.activate = FB_ACTIVATE_FORCE;
+	fb_set_var(da8xx_fb_info, &da8xx_fb_var);
+
 	/* Register the Frame Buffer  */
 	if (register_framebuffer(da8xx_fb_info) < 0) {
 		dev_err(&device->dev,
@@ -1692,22 +1728,9 @@ static int fb_probe(struct platform_device *device)
 	}
 #endif
 
-	if (lcd_revision == LCD_VERSION_1)
-		lcdc_irq_handler = lcdc_irq_handler_rev01;
-	else {
-		init_waitqueue_head(&frame_done_wq);
-		lcdc_irq_handler = lcdc_irq_handler_rev02;
-	}
-
-	ret = devm_request_irq(&device->dev, par->irq, lcdc_irq_handler, 0,
-			       DRIVER_NAME, par);
-	if (ret)
-		goto irq_freq;
 	return 0;
 
-irq_freq:
 #ifdef CONFIG_CPU_FREQ
-	lcd_da8xx_cpufreq_deregister(par);
 err_cpu_freq:
 #endif
 	unregister_framebuffer(da8xx_fb_info);
-- 
1.7.5.4

