From 45a2272122f48b53212fb4e45698401958155b34 Mon Sep 17 00:00:00 2001
From: John Ogness <john.ogness@linutronix.de>
Date: Sat, 7 Nov 2015 18:55:16 +0530
Subject: [PATCH 660/800] tty: serial: 8250: omap: convert to using cyclic
 transfers

By using cyclic transfers it is possible to sustain long running
DMA transfers at 3Mbit.

Note that an ugly device-tree lookup hack is implemented in order
to detect if the sDMA engine is being used. This is necessary
because the sDMA driver does not implement pause/resume correctly
and therefore requires slightly different logic for the UART
driver.

Signed-off-by: John Ogness <john.ogness@linutronix.de>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
[zou: Original patch taken from PROCESSOR-SDK-LINUX-AM335X 02_00_01_07]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/tty/serial/8250/8250.h      |    2 +
 drivers/tty/serial/8250/8250_omap.c |  237 +++++++++++++++++++---------------
 2 files changed, 134 insertions(+), 105 deletions(-)

diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index a407757..0114bc6 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -42,6 +42,8 @@ struct uart_8250_dma {
 	size_t			rx_size;
 	size_t			tx_size;
 
+	unsigned int		rx_pos;
+
 	unsigned char		tx_running;
 	unsigned char		tx_err;
 	unsigned char		rx_running;
diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index fc3f538..5284832 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -39,6 +39,7 @@
  * The same errata is applicable to AM335x and DRA7x processors too.
  */
 #define UART_ERRATA_CLOCK_DISABLE	(1 << 3)
+#define OMAP_DMA_RX_RESUME_STARTOVER	(1 << 4)
 
 #define OMAP_UART_FCR_RX_TRIG		6
 #define OMAP_UART_FCR_TX_TRIG		4
@@ -81,7 +82,10 @@
 #define OMAP_UART_TX_WAKEUP_EN	(1 << 7)
 
 #define TX_TRIGGER	1
+
 #define RX_TRIGGER	48
+/* RX buffer size chosen to fit within 1 page */
+#define RX_DMA_BUFSZ	(PAGE_SIZE - (PAGE_SIZE % RX_TRIGGER))
 
 #define OMAP_UART_TCR_RESTORE(x)	((x / 4) << 4)
 #define OMAP_UART_TCR_HALT(x)		((x / 4) << 0)
@@ -599,6 +603,8 @@ static irqreturn_t omap8250_irq(int irq, void *dev_id)
 	return IRQ_RETVAL(ret);
 }
 
+static int omap_8250_rx_dma_setup(struct uart_8250_port *p);
+
 static int omap_8250_startup(struct uart_port *port)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
@@ -649,7 +655,7 @@ static int omap_8250_startup(struct uart_port *port)
 	serial_out(up, UART_OMAP_WER, priv->wer);
 
 	if (up->dma)
-		up->dma->rx_dma(up, 0);
+		omap_8250_rx_dma_setup(up);
 
 	pm_runtime_mark_last_busy(port->dev);
 	pm_runtime_put_autosuspend(port->dev);
@@ -661,14 +667,20 @@ err:
 	return ret;
 }
 
+static void dma_rx_copy_buffer(struct uart_8250_port *p);
+
 static void omap_8250_shutdown(struct uart_port *port)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
 	struct omap8250_priv *priv = port->private_data;
+	struct uart_8250_dma *dma = up->dma;
 
 	flush_work(&priv->qos_work);
-	if (up->dma)
-		up->dma->rx_dma(up, UART_IIR_RX_TIMEOUT);
+	if (dma) {
+		dmaengine_pause(dma->rxchan);
+		dma_rx_copy_buffer(up);
+		dmaengine_terminate_all(dma->rxchan);
+	}
 
 	pm_runtime_get_sync(port->dev);
 
@@ -677,7 +689,7 @@ static void omap_8250_shutdown(struct uart_port *port)
 	up->ier = 0;
 	serial_out(up, UART_IER, 0);
 
-	if (up->dma)
+	if (dma)
 		serial8250_release_dma(up);
 
 	/*
@@ -728,132 +740,92 @@ static void omap_8250_unthrottle(struct uart_port *port)
 }
 
 #ifdef CONFIG_SERIAL_8250_DMA
-static int omap_8250_rx_dma(struct uart_8250_port *p, unsigned int iir);
-
-static void __dma_rx_do_complete(struct uart_8250_port *p, bool error)
+static void dma_rx_copy_buffer(struct uart_8250_port *p)
 {
 	struct omap8250_priv	*priv = p->port.private_data;
 	struct uart_8250_dma    *dma = p->dma;
 	struct tty_port         *tty_port = &p->port.state->port;
+	int			in_progress;
 	struct dma_tx_state     state;
-	int                     count;
 	unsigned long		flags;
 	int			ret;
+	int			pos;
 
+	spin_lock_irqsave(&priv->rx_dma_lock, flags);
+
+	/*
+	 * Since we are syncing the entire DMA area, we can do this before
+	 * getting the residue value. This allows getting the maximum data
+	 * available, since the DMA engine may not be paused.
+	 */
 	dma_sync_single_for_cpu(dma->rxchan->device->dev, dma->rx_addr,
 				dma->rx_size, DMA_FROM_DEVICE);
 
-	spin_lock_irqsave(&priv->rx_dma_lock, flags);
+	dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
 
-	if (!dma->rx_running)
-		goto unlock;
+	if (state.residue == 0)
+		pos = 0;
+	else
+		pos = RX_DMA_BUFSZ - state.residue;
 
-	dma->rx_running = 0;
-	dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
-	dmaengine_terminate_all(dma->rxchan);
+	/*
+	 * Ignore DMA data in progress. A new interrupt
+	 * will be genereted when it is completed.
+	 */
+	in_progress = pos % RX_TRIGGER;
+	if (in_progress)
+		pos -= in_progress;
 
-	count = dma->rx_size - state.residue;
+	while (dma->rx_pos != pos) {
+		ret = tty_insert_flip_string(tty_port,
+					     dma->rx_buf + dma->rx_pos,
+					     RX_TRIGGER);
 
-	ret = tty_insert_flip_string(tty_port, dma->rx_buf, count);
+		p->port.icount.rx += ret;
+		p->port.icount.buf_overrun += RX_TRIGGER - ret;
 
-	p->port.icount.rx += ret;
-	p->port.icount.buf_overrun += count - ret;
-unlock:
-	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
+		dma->rx_pos += RX_TRIGGER;
+		if (dma->rx_pos == RX_DMA_BUFSZ)
+			dma->rx_pos = 0;
+	}
 
-	if (!error)
-		omap_8250_rx_dma(p, 0);
+	dma_sync_single_for_device(dma->rxchan->device->dev, dma->rx_addr,
+				   dma->rx_size, DMA_FROM_DEVICE);
 
 	tty_flip_buffer_push(tty_port);
-}
 
-static void __dma_rx_complete(void *param)
-{
-	__dma_rx_do_complete(param, false);
+	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
 }
 
-static void omap_8250_rx_dma_flush(struct uart_8250_port *p)
+static void __dma_rx_complete(void *param)
 {
-	struct omap8250_priv	*priv = p->port.private_data;
-	struct uart_8250_dma	*dma = p->dma;
-	unsigned long		flags;
-
-	spin_lock_irqsave(&priv->rx_dma_lock, flags);
-
-	if (!dma->rx_running) {
-		spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
-		return;
-	}
-
-	dmaengine_pause(dma->rxchan);
-
-	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
-
-	__dma_rx_do_complete(p, true);
+	dma_rx_copy_buffer(param);
 }
 
-static int omap_8250_rx_dma(struct uart_8250_port *p, unsigned int iir)
+static int omap_8250_rx_dma_setup(struct uart_8250_port *p)
 {
-	struct omap8250_priv		*priv = p->port.private_data;
-	struct uart_8250_dma            *dma = p->dma;
+	struct uart_8250_dma	    *dma = p->dma;
 	int				err = 0;
 	struct dma_async_tx_descriptor  *desc;
-	unsigned long			flags;
-
-	switch (iir & 0x3f) {
-	case UART_IIR_RLSI:
-		/* 8250_core handles errors and break interrupts */
-		omap_8250_rx_dma_flush(p);
-		return -EIO;
-	case UART_IIR_RX_TIMEOUT:
-		/*
-		 * If RCVR FIFO trigger level was not reached, complete the
-		 * transfer and let 8250_core copy the remaining data.
-		 */
-		omap_8250_rx_dma_flush(p);
-		return -ETIMEDOUT;
-	case UART_IIR_RDI:
-		/*
-		 * The OMAP UART is a special BEAST. If we receive RDI we _have_
-		 * a DMA transfer programmed but it didn't work. One reason is
-		 * that we were too slow and there were too many bytes in the
-		 * FIFO, the UART counted wrong and never kicked the DMA engine
-		 * to do anything. That means once we receive RDI on OMAP then
-		 * the DMA won't do anything soon so we have to cancel the DMA
-		 * transfer and purge the FIFO manually.
-		 */
-		omap_8250_rx_dma_flush(p);
-		return -ETIMEDOUT;
 
-	default:
-		break;
-	}
-
-	spin_lock_irqsave(&priv->rx_dma_lock, flags);
-
-	if (dma->rx_running)
-		goto out;
-
-	desc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,
-					   dma->rx_size, DMA_DEV_TO_MEM,
-					   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
-	if (!desc) {
+	desc = dmaengine_prep_dma_cyclic(dma->rxchan, dma->rx_addr,
+					 RX_DMA_BUFSZ, RX_TRIGGER,
+					 DMA_DEV_TO_MEM,
+					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc)
 		err = -EBUSY;
-		goto out;
-	}
 
-	dma->rx_running = 1;
 	desc->callback = __dma_rx_complete;
 	desc->callback_param = p;
 
+	dma->rx_pos = 0;
 	dma->rx_cookie = dmaengine_submit(desc);
 
 	dma_sync_single_for_device(dma->rxchan->device->dev, dma->rx_addr,
 				   dma->rx_size, DMA_FROM_DEVICE);
 
 	dma_async_issue_pending(dma->rxchan);
-out:
-	spin_unlock_irqrestore(&priv->rx_dma_lock, flags);
+
 	return err;
 }
 
@@ -1010,8 +982,9 @@ err:
 static int omap_8250_dma_handle_irq(struct uart_port *port)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
+	struct omap8250_priv *priv = up->port.private_data;
+	struct uart_8250_dma *dma = up->dma;
 	unsigned char status;
-	unsigned long flags;
 	u8 iir;
 	int dma_err = 0;
 
@@ -1023,23 +996,41 @@ static int omap_8250_dma_handle_irq(struct uart_port *port)
 		return 0;
 	}
 
-	spin_lock_irqsave(&port->lock, flags);
+	spin_lock(&port->lock);
 
 	status = serial_port_in(port, UART_LSR);
 
 	if (status & (UART_LSR_DR | UART_LSR_BI)) {
 
-		dma_err = omap_8250_rx_dma(up, iir);
-		if (dma_err) {
-			status = serial8250_rx_chars(up, status);
-			omap_8250_rx_dma(up, 0);
+		switch (iir & 0x3f) {
+		case UART_IIR_RLSI:
+		case UART_IIR_RX_TIMEOUT:
+			/* pause the DMA */
+			dmaengine_pause(dma->rxchan);
+
+			/* get any data in the DMA buffer */
+			dma_rx_copy_buffer(up);
+
+			/*
+			 * Empty the FIFO using PIO. We pass a lock in
+			 * order to synchronize tty_flip_buffer_push()
+			 * against the rx dma callback.
+			 */
+			status = serial8250_rx_chars(up, status,
+						     &priv->rx_dma_lock);
+
+			/* resume the DMA */
+			if (priv->habit & OMAP_DMA_RX_RESUME_STARTOVER)
+				dma->rx_pos = 0;
+			dmaengine_resume(dma->rxchan);
+			break;
 		}
 	}
 	serial8250_modem_status(up);
-	if (status & UART_LSR_THRE && up->dma->tx_err) {
+	if (status & UART_LSR_THRE && dma->tx_err) {
 		if (uart_tx_stopped(&up->port) ||
 		    uart_circ_empty(&up->port.state->xmit)) {
-			up->dma->tx_err = 0;
+			dma->tx_err = 0;
 			serial8250_tx_chars(up);
 		} else  {
 			/*
@@ -1052,7 +1043,7 @@ static int omap_8250_dma_handle_irq(struct uart_port *port)
 		}
 	}
 
-	spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock(&port->lock);
 	serial8250_rpm_put(up);
 	return 1;
 }
@@ -1064,7 +1055,11 @@ static bool the_no_dma_filter_fn(struct dma_chan *chan, void *param)
 
 #else
 
-static inline int omap_8250_rx_dma(struct uart_8250_port *p, unsigned int iir)
+static void dma_rx_copy_buffer(struct uart_8250_port *p)
+{
+}
+
+static inline int omap_8250_rx_dma_setup(struct uart_8250_port *p)
 {
 	return -EINVAL;
 }
@@ -1220,16 +1215,45 @@ static int omap8250_probe(struct platform_device *pdev)
 		 */
 		ret = of_property_count_strings(pdev->dev.of_node, "dma-names");
 		if (ret == 2) {
+			struct platform_device *dma_pdev;
+			struct device_node *dma_np;
+			struct device_node *np;
+
 			up.dma = &priv->omap8250_dma;
 			priv->omap8250_dma.fn = the_no_dma_filter_fn;
 			priv->omap8250_dma.tx_dma = omap_8250_tx_dma;
-			priv->omap8250_dma.rx_dma = omap_8250_rx_dma;
-			priv->omap8250_dma.rx_size = RX_TRIGGER;
+			priv->omap8250_dma.rx_size = PAGE_ALIGN(RX_DMA_BUFSZ);
 			priv->omap8250_dma.rxconf.src_maxburst = RX_TRIGGER;
 			priv->omap8250_dma.txconf.dst_maxburst = TX_TRIGGER;
 
 			if (of_machine_is_compatible("ti,am33xx"))
 				priv->habit |= OMAP_DMA_TX_KICK;
+
+			/*
+			 * The sDMA driver will not resume from the same
+			 * buffer position that it had after pause. It will
+			 * start from the beginning of the buffer each time.
+			 */
+			dma_np = of_parse_phandle(pdev->dev.of_node, "dmas", 0);
+			if (dma_np) {
+				/* resolve possible dma router */
+				np = of_parse_phandle(dma_np, "dma-masters", 0);
+				if (np) {
+					of_node_put(dma_np);
+					dma_np = np;
+				}
+
+				/* set habit if we are using sDMA driver */
+				dma_pdev = of_find_device_by_node(dma_np);
+				if (dma_pdev && dma_pdev->dev.driver &&
+				    strcmp(dma_pdev->dev.driver->name,
+					   "omap-dma-engine") == 0) {
+					priv->habit |=
+						OMAP_DMA_RX_RESUME_STARTOVER;
+				}
+
+				of_node_put(dma_np);
+			}
 		}
 	}
 #endif
@@ -1375,8 +1399,11 @@ static int omap8250_runtime_suspend(struct device *dev)
 		omap8250_update_mdr1(up, priv);
 	}
 
-	if (up->dma && up->dma->rxchan)
-		omap_8250_rx_dma(up, UART_IIR_RX_TIMEOUT);
+	if (up->dma && up->dma->rxchan) {
+		dmaengine_pause(up->dma->rxchan);
+		dma_rx_copy_buffer(up);
+		dmaengine_terminate_all(up->dma->rxchan);
+	}
 
 	priv->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;
 	schedule_work(&priv->qos_work);
@@ -1405,7 +1432,7 @@ static int omap8250_runtime_resume(struct device *dev)
 		omap8250_restore_regs(up);
 
 	if (up->dma && up->dma->rxchan)
-		omap_8250_rx_dma(up, 0);
+		omap_8250_rx_dma_setup(up);
 
 	priv->latency = priv->calc_latency;
 	schedule_work(&priv->qos_work);
-- 
1.7.5.4

