From a0b72fbec59ab970e00b79b6b1ddde7f130f6a85 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 25 Feb 2011 12:34:29 +0800
Subject: [PATCH 07/30] WRHV: Cavium: Paravirtualize cpu_probe

Paravirtualize cpu_probe via paravirt ops. In cpu_probe, the most
COMP ID and IMPL ID is ignored, just handle CAVIUM and CN63XX/CN58XX
to setup cpuinfo_mips (current_cpu_data) struct.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/paravirt.h |    3 +
 arch/mips/kernel/cpu-probe.c     |   10 ++++-
 arch/mips/kernel/paravirt.c      |    8 ++++
 arch/mips/kernel/vbi/wrhv.c      |   79 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 99 insertions(+), 1 deletions(-)

diff --git a/arch/mips/include/asm/paravirt.h b/arch/mips/include/asm/paravirt.h
index d8f14af..ce07296 100644
--- a/arch/mips/include/asm/paravirt.h
+++ b/arch/mips/include/asm/paravirt.h
@@ -11,6 +11,7 @@ struct pv_info {
 /*
  * native functions
  */
+extern __cpuinit void native_cpu_probe(void);
 extern void __init native_per_cpu_trap_init(void);
 extern void __init native_tlb_init(void);
 extern void __init native_arch_init_irq(void);
@@ -22,6 +23,7 @@ extern long native_kernel_thread(int (*fn)(void *), void *arg, unsigned long fla
  * paravirtual operations structure
  */
 struct pv_cpu_ops {
+ 	void (*cpu_probe)(void);
 	void (*per_cpu_trap_init)(void);
 };
 
@@ -42,6 +44,7 @@ struct pv_misc_ops {
  	long (*kernel_thread)(int (*fn)(void *), void *arg, unsigned long flags);
 };
  
+extern struct pv_info pv_info;
 extern struct pv_cpu_ops pv_cpu_ops;
 extern struct pv_mem_ops pv_mem_ops;
 extern struct pv_irq_ops pv_irq_ops;
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index c6eeb30..c69b17e 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -955,7 +955,10 @@ platform:
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
 
-__cpuinit void cpu_probe(void)
+__cpuinit void paravirt_cpu_probe(void)
+	__attribute__((weak, alias("native_cpu_probe")));
+
+__cpuinit void native_cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int cpu = smp_processor_id();
@@ -1034,6 +1037,11 @@ __cpuinit void cpu_probe(void)
 	cpu_probe_vmbits(c);
 }
 
+__cpuinit void cpu_probe(void)
+{
+	paravirt_cpu_probe();
+}
+
 __cpuinit void cpu_report(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
diff --git a/arch/mips/kernel/paravirt.c b/arch/mips/kernel/paravirt.c
index e4643c7..72e6619 100644
--- a/arch/mips/kernel/paravirt.c
+++ b/arch/mips/kernel/paravirt.c
@@ -20,6 +20,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/module.h>
 #include <asm/paravirt.h>
 
 #ifdef CONFIG_WRHV
@@ -40,6 +41,7 @@ struct pv_info pv_info = {
 };
 
 struct pv_cpu_ops pv_cpu_ops = {
+ 	.cpu_probe = native_cpu_probe,
 	.per_cpu_trap_init = native_per_cpu_trap_init,
 };
 
@@ -60,6 +62,11 @@ struct pv_misc_ops pv_misc_ops = {
  	.kernel_thread = native_kernel_thread,
 };
  
+__cpuinit void paravirt_cpu_probe(void)
+{
+ 	pv_cpu_ops.cpu_probe();
+}
+ 
 void __init paravirt_per_cpu_trap_init(void)
 {
 	pv_cpu_ops.per_cpu_trap_init();
@@ -90,6 +97,7 @@ long paravirt_kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
  	return pv_misc_ops.kernel_thread(fn, arg, flags);
 }
  
+EXPORT_SYMBOL(pv_info);
 EXPORT_SYMBOL(pv_cpu_ops);
 EXPORT_SYMBOL(pv_mem_ops);
 EXPORT_SYMBOL(pv_irq_ops);
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index 9433ec9..d01d549 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -27,6 +27,9 @@
 #include <trace/sched.h>
 
 #include <asm/bootinfo.h>
+#include <asm/bugs.h>
+#include <asm/cpu.h>
+#include <asm/paravirt.h>
 #include <asm/mipsmtregs.h>
 #include <asm/mmu_context.h>
 #include <asm/sections.h>
@@ -488,6 +491,78 @@ void wrhv_wait(void)
  	vbi_idle(1);
 }
  
+static inline void cpu_probe_vmbits(struct cpuinfo_mips *c)
+{
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	c->vmbits = 49;
+#endif
+}
+
+static inline void cpu_probe_cavium(struct cpuinfo_mips *c, unsigned int cpu)
+{
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_CAVIUM_CN38XX:
+	case PRID_IMP_CAVIUM_CN31XX:
+	case PRID_IMP_CAVIUM_CN30XX:
+		c->cputype = CPU_CAVIUM_OCTEON;
+		__cpu_name[cpu] = "Cavium Octeon";
+		goto platform;
+	case PRID_IMP_CAVIUM_CN58XX:
+	case PRID_IMP_CAVIUM_CN56XX:
+	case PRID_IMP_CAVIUM_CN50XX:
+	case PRID_IMP_CAVIUM_CN52XX:
+		c->cputype = CPU_CAVIUM_OCTEON_PLUS;
+		__cpu_name[cpu] = "Cavium Octeon+";
+platform:
+		if (cpu == 0)
+			__elf_platform = "octeon";
+		break;
+	case PRID_IMP_CAVIUM_CN63XX:
+		c->cputype = CPU_CAVIUM_OCTEON2;
+		__cpu_name[cpu] = "Cavium Octeon II";
+		if (cpu == 0)
+			__elf_platform = "octeon2";
+		break;
+	default:
+		printk(KERN_INFO "Unknown Octeon chip!\n");
+		c->cputype = CPU_UNKNOWN;
+		break;
+	}
+	c->core = VBI_VCORE_ID_GET();
+}
+
+__cpuinit void wrhv_cpu_probe(void)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	unsigned int cpu = smp_processor_id();
+
+#ifdef CONFIG_CAVIUM_OCTEON2
+	c->processor_id = PRID_COMP_CAVIUM | PRID_IMP_CAVIUM_CN63XX;
+#else
+	c->processor_id = PRID_COMP_CAVIUM | PRID_IMP_CAVIUM_CN58XX;
+#endif
+	c->fpu_id	= FPIR_IMP_NONE;
+	c->cputype	= CPU_UNKNOWN;
+
+	switch (c->processor_id & 0xff0000) {
+	case PRID_COMP_CAVIUM:
+		cpu_probe_cavium(c, cpu);
+		break;
+	}
+
+	BUG_ON(!__cpu_name[cpu]);
+	BUG_ON(c->cputype == CPU_UNKNOWN);
+
+	/*
+	 * Platform code can force the cpu type to optimize code
+	 * generation. In that case be sure the cpu type is correctly
+	 * manually setup otherwise it could trigger some nasty bugs.
+	 */
+	BUG_ON(current_cpu_type() != c->cputype);
+
+	cpu_probe_vmbits(c);
+}
+
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -498,6 +573,10 @@ void __init wrhv_init(void)
 
 	vbi_init(wr_config);
 
+ 	pv_info.name = "wrhv";
+ 	pv_info.paravirt_enabled = 1;
+ 
+ 	pv_cpu_ops.cpu_probe = wrhv_cpu_probe;
 	pv_cpu_ops.per_cpu_trap_init = wrhv_per_cpu_trap_init;
 
 	pv_mem_ops.tlb_init = wrhv_tlb_init;
-- 
1.7.3

