From c2c00c6b16ff5a8f0c658eedb07e67c464b15529 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Wed, 6 Apr 2011 11:24:17 -0700
Subject: [PATCH 4/5] WRHV: Cavium: Insert Hypervisor IRQ hooks

Add calls to init, mask and unmask VIOAPIC interrupt hooks in the
Management Port ethernet driver.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 drivers/net/octeon/octeon_mgmt.c |   30 ++++++++++++++++++++++++++++++
 1 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/drivers/net/octeon/octeon_mgmt.c b/drivers/net/octeon/octeon_mgmt.c
index e1eb105..d021b83 100644
--- a/drivers/net/octeon/octeon_mgmt.c
+++ b/drivers/net/octeon/octeon_mgmt.c
@@ -24,6 +24,11 @@
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-board.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/compat.h>
+#include <vbi/interface.h>
+#endif
+
 #define DRV_NAME "octeon_mgmt"
 #define DRV_VERSION "2.0"
 #define DRV_DESCRIPTION \
@@ -99,6 +104,12 @@ static void octeon_mgmt_set_rx_irq(struct octeon_mgmt *p, int enable)
 	mix_intena.u64 = cvmx_read_csr(CVMX_MIXX_INTENA(port));
 	mix_intena.s.ithena = enable ? 1 : 0;
 	cvmx_write_csr(CVMX_MIXX_INTENA(port), mix_intena.u64);
+#ifdef CONFIG_WRHV
+	if (enable)
+		vbi_unmask_vioapic_irq(p->irq);
+	else
+		vbi_mask_vioapic_irq(p->irq);
+#endif
 	spin_unlock_irqrestore(&p->lock, flags);
 }
 
@@ -112,6 +123,12 @@ static void octeon_mgmt_set_tx_irq(struct octeon_mgmt *p, int enable)
 	mix_intena.u64 = cvmx_read_csr(CVMX_MIXX_INTENA(port));
 	mix_intena.s.othena = enable ? 1 : 0;
 	cvmx_write_csr(CVMX_MIXX_INTENA(port), mix_intena.u64);
+#ifdef CONFIG_WRHV
+	if (enable)
+		vbi_unmask_vioapic_irq(p->irq);
+	else
+		vbi_mask_vioapic_irq(p->irq);
+#endif
 	spin_unlock_irqrestore(&p->lock, flags);
 }
 
@@ -1190,6 +1207,10 @@ static int octeon_mgmt_open(struct net_device *netdev)
 	mix_intena.s.othena = 1;
 	cvmx_write_csr(CVMX_MIXX_INTENA(port), mix_intena.u64);
 
+#ifdef CONFIG_WRHV
+	vbi_unmask_vioapic_irq(p->irq);
+#endif
+
 	/* Enable packet I/O. */
 
 	rxx_frm_ctl.u64 = 0;
@@ -1440,11 +1461,20 @@ static int __init octeon_mgmt_probe(struct platform_device *pdev)
 	p->port = pdev->id;
 	snprintf(netdev->name, IFNAMSIZ, "mgmt%d", p->port);
 
+#ifdef CONFIG_WRHV
+	p->irq = vbi_find_irq(netdev->name, VB_INPUT_INT);
+	if (p->irq == VBI_INVALID_IRQ) {
+		printk("WRHV resolve irq for mgmt%d failed\n",
+		       p->port);
+		goto err;
+	}
+#else
 	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res_irq)
 		goto err;
 
 	p->irq = res_irq->start;
+#endif
 	spin_lock_init(&p->lock);
 
 	skb_queue_head_init(&p->tx_list);
-- 
1.7.0.2

