From b7bcc1750e9439d75b634c4b87a3b5e6b63f2394 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 23 Mar 2011 13:54:30 +0800
Subject: [PATCH 4/5] WRHV: Cavium: Make thread pointer access SMP safe

Cavium Octeon saves the thread pointers to per core L1 cache to
accelerate the access. But, on GOS, thread pointers are saved to
a memory location starting at 0xffffffffc0000080 instead of per
core L1 cache. But, on SMP, the memory location need to be expanded
to array indexed by core id so that it looks like per core L1 cache
and save/restore thread pointers to/from the correct location to
avoid the over-written.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/wrhv_stackframe.h |    5 ++++-
 arch/mips/kernel/syscall.c              |   10 +++++++++-
 arch/mips/kernel/wrhv_genex.S           |    7 ++++++-
 arch/mips/kernel/wrhv_octeon_switch.S   |    7 ++++++-
 4 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/arch/mips/include/asm/wrhv_stackframe.h b/arch/mips/include/asm/wrhv_stackframe.h
index c6fc22c..a9cbd6d 100644
--- a/arch/mips/include/asm/wrhv_stackframe.h
+++ b/arch/mips/include/asm/wrhv_stackframe.h
@@ -469,7 +469,10 @@
 		.set	mips3
 #ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
 		/* K0 = thread pointer */
-		LONG_L	k0, FAST_ACCESS_THREAD_OFFSET($0)
+		PTR_L   k1, wr_vb_config
+		lw      k1, WRHV_COREID_OFFSET(k1)
+		sll     k1, 3
+		LONG_L  k0, FAST_ACCESS_THREAD_OFFSET(k1)
 		PTR_L	k1, wr_vb_control
 		LONG_S	k0, VB_CONTROL_K0(k1)
 #endif
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index fc9b4a5..7335a97 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -279,14 +279,22 @@ out:
 SYSCALL_DEFINE1(set_thread_area, unsigned long, addr)
 {
 	struct thread_info *ti = task_thread_info(current);
-
+#ifdef CONFIG_WRHV
+	int cpu = raw_smp_processor_id();
+	unsigned long *thread_reg;
+#endif
 	ti->tp_value = addr;
 	if (cpu_has_userlocal)
 		write_c0_userlocal(addr);
 
 #ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
+#ifdef CONFIG_WRHV
+	thread_reg = (unsigned long *)(FAST_ACCESS_THREAD_OFFSET + (cpu << 3));
+	*thread_reg = addr;
+#else
 	FAST_ACCESS_THREAD_REGISTER = addr;
 #endif
+#endif
 	return 0;
 }
 
diff --git a/arch/mips/kernel/wrhv_genex.S b/arch/mips/kernel/wrhv_genex.S
index 508d0ae..eea8e03 100644
--- a/arch/mips/kernel/wrhv_genex.S
+++ b/arch/mips/kernel/wrhv_genex.S
@@ -24,6 +24,8 @@
 
 #include <vbi/vbi.h>
 
+#define WRHV_COREID_OFFSET      0x98
+
 #define PANIC_PIC(msg)					\
 		.set push;				\
 		.set	reorder;			\
@@ -200,7 +202,10 @@ NESTED(handle_int, PT_SIZE, sp)
 	bnez	k0, 1f
 
 #ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
-	LONG_L	k0, FAST_ACCESS_THREAD_OFFSET($0)
+	PTR_L	k0, wr_vb_config
+	lw	k0, WRHV_COREID_OFFSET(k0)
+	sll	k0, 3
+	LONG_L	k0, FAST_ACCESS_THREAD_OFFSET(k0)
 #endif
 	eret
 #endif
diff --git a/arch/mips/kernel/wrhv_octeon_switch.S b/arch/mips/kernel/wrhv_octeon_switch.S
index 8ab15f4..b15251a 100644
--- a/arch/mips/kernel/wrhv_octeon_switch.S
+++ b/arch/mips/kernel/wrhv_octeon_switch.S
@@ -31,6 +31,8 @@
  */
 #define ST_OFF (_THREAD_SIZE - 32 - PT_SIZE + PT_STATUS)
 
+#define WRHV_COREID_OFFSET      0x98
+ 
 /*
  * task_struct *resume(task_struct *prev, task_struct *next,
  *                     struct thread_info *next_ti)
@@ -121,8 +123,11 @@
 	/* We need to put the thread pointer in CVMMEM immediately. The
 		kernel will use this value during TLB exceptions even
 		though userspace hasn't accessed CVMMEM */
+	PTR_L	t0, wr_vb_config
+	lw	t0, WRHV_COREID_OFFSET(t0)
+	sll	t0, 3
 	LONG_L	t1, TI_TP_VALUE($28)
-	LONG_S	t1, FAST_ACCESS_THREAD_OFFSET($0)
+	LONG_S	t1, FAST_ACCESS_THREAD_OFFSET(t0)
 #endif
 
 	PTR_L	t1, wr_vb_status
-- 
1.7.0.4

