From 35b8b28a8e4a2cec748a50a372b6714d10150154 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 28 Feb 2011 12:59:53 +0800
Subject: [PATCH 08/30] WRHV: Cavium: Paravirtualize prom_init

Paravirtualize Cavium specific prom_init which do some board level
initialization and extract boot commandline.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/setup.c  |   16 ++-
 arch/mips/include/asm/paravirt.h |    2 +
 arch/mips/kernel/paravirt.c      |    6 +
 arch/mips/kernel/vbi/wrhv.c      |  249 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 269 insertions(+), 4 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index b31fc87..34d5f3f 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -55,7 +55,7 @@ extern struct plat_smp_ops octeon_smp_ops;
 
 extern void pci_console_init(const char *arg);
 
-static unsigned long long MAX_MEMORY = 512ull << 20;
+unsigned long long MAX_MEMORY = 512ull << 20;
 
 struct octeon_boot_descriptor *octeon_boot_desc_ptr;
 
@@ -104,7 +104,7 @@ static void octeon_crash_dump_setup(void)
 }
 #endif
 
-static int octeon_uart;
+int octeon_uart;
 
 extern asmlinkage void handle_int(void);
 extern asmlinkage void plat_irq_dispatch(void);
@@ -121,7 +121,7 @@ u64 octeon_bootloader_entry_addr;
 EXPORT_SYMBOL(octeon_bootloader_entry_addr);
 
 /* If an initrd named block is specified, its name goes here. */
-static char __initdata rd_name[64];
+char __initdata rd_name[64];
 
 #define SDK_VERSION "2.0"
 
@@ -615,10 +615,13 @@ int xkphys_usermem_write(long pid, int value)
 	return 0;
 }
 
+void paravirt_prom_init(void)
+	__attribute__((weak, alias("native_prom_init")));
+
 /**
  * Early entry point for arch setup
  */
-void __init prom_init(void)
+void __init native_prom_init(void)
 {
 	struct cvmx_sysinfo *sysinfo;
 	struct linux_app_boot_info *labi;
@@ -846,6 +849,11 @@ void __init prom_init(void)
 
 	pr_info("Cavium Networks SDK-" SDK_VERSION "\n");
 }
+ 
+void __init prom_init(void)
+{
+ 	paravirt_prom_init();
+}
 
 /* constants for memory initialization */
 #define OCTEON_DDR0_BASE    (0x0ULL)
diff --git a/arch/mips/include/asm/paravirt.h b/arch/mips/include/asm/paravirt.h
index ce07296..ca9776b 100644
--- a/arch/mips/include/asm/paravirt.h
+++ b/arch/mips/include/asm/paravirt.h
@@ -12,6 +12,7 @@ struct pv_info {
  * native functions
  */
 extern __cpuinit void native_cpu_probe(void);
+extern void __init native_prom_init(void);
 extern void __init native_per_cpu_trap_init(void);
 extern void __init native_tlb_init(void);
 extern void __init native_arch_init_irq(void);
@@ -24,6 +25,7 @@ extern long native_kernel_thread(int (*fn)(void *), void *arg, unsigned long fla
  */
 struct pv_cpu_ops {
  	void (*cpu_probe)(void);
+ 	void (*prom_init)(void);
 	void (*per_cpu_trap_init)(void);
 };
 
diff --git a/arch/mips/kernel/paravirt.c b/arch/mips/kernel/paravirt.c
index 72e6619..fd72d55 100644
--- a/arch/mips/kernel/paravirt.c
+++ b/arch/mips/kernel/paravirt.c
@@ -42,6 +42,7 @@ struct pv_info pv_info = {
 
 struct pv_cpu_ops pv_cpu_ops = {
  	.cpu_probe = native_cpu_probe,
+ 	.prom_init = native_prom_init,
 	.per_cpu_trap_init = native_per_cpu_trap_init,
 };
 
@@ -67,6 +68,11 @@ __cpuinit void paravirt_cpu_probe(void)
  	pv_cpu_ops.cpu_probe();
 }
  
+void __init paravirt_prom_init(void)
+{
+ 	pv_cpu_ops.prom_init();
+}
+ 
 void __init paravirt_per_cpu_trap_init(void)
 {
 	pv_cpu_ops.per_cpu_trap_init();
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index a825acb..edbc1e7 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -29,6 +29,7 @@
 #include <asm/bootinfo.h>
 #include <asm/bugs.h>
 #include <asm/cpu.h>
+#include <asm/reboot.h>
 #include <asm/paravirt.h>
 #include <asm/mipsmtregs.h>
 #include <asm/mmu_context.h>
@@ -52,10 +53,56 @@ void wrhv_unmask_IPIs_for_vcore(void);
 
 #define VECTORSPACING 0x100
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/octeon/cvmx-error.h>
+extern struct octeon_boot_descriptor *octeon_boot_desc_ptr;
+extern struct plat_smp_ops octeon_smp_ops;
+extern int octeon_uart;
+
+extern void pci_console_init(const char *arg);
+
+#define SDK_VERSION "2.0"
+#endif
+
 #ifndef NUM_MACS
 #define NUM_MACS 2
 #endif
 
+extern unsigned long long MAX_MEMORY;
+extern char __initdata rd_name[64];
+
+static void wrhv_restart(char *command)
+{
+	int ret = 0;
+	unsigned int cpu = smp_processor_id();
+
+	if (!cpu) {
+		printk(KERN_INFO "WRHV: rebooting \n");
+
+		ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
+				VBI_VBMGMT_RESET_AND_START_CORE0 |
+				VBI_VBMGMT_RESET_DOWNLOAD
+				);
+
+		if (ret)
+			printk(KERN_ERR "WRHV: reboot failed. ret = %d\n", ret);
+	}
+}
+
+static void wrhv_halt(void)
+{
+	unsigned int cpu;
+	int ret = 0;
+
+	cpu = smp_processor_id();
+
+	if (!cpu)
+        	ret = vbi_vb_suspend(VBI_BOARD_ID_GET(), cpu);
+
+        if (ret)
+                printk(KERN_ERR "%s: suspend result: %d\n", __func__, ret);
+}
+
 static void get_hv_bsp_server_handle(void)
 {
  	int32_t rc;
@@ -571,6 +618,207 @@ __cpuinit void wrhv_cpu_probe(void)
 	cpu_probe_vmbits(c);
 }
 
+void __init wrhv_prom_init(void)
+{
+	struct cvmx_sysinfo *sysinfo;
+	struct linux_app_boot_info *labi;
+	int i;
+	int argc;
+#if CONFIG_CAVIUM_RESERVE32
+	int64_t addr = -1;
+#endif
+	/*
+	 * The bootloader passes a pointer to the boot descriptor in
+	 * $a3, this is available as fw_arg3.
+	 */
+	octeon_boot_desc_ptr = (struct octeon_boot_descriptor *)fw_arg3;
+	octeon_bootinfo =
+		(struct cvmx_bootinfo *)(octeon_boot_desc_ptr->cvmx_desc_vaddr);
+	MAX_MEMORY = (uint64_t)octeon_bootinfo->dram_size;
+	cvmx_bootmem_init((uint64_t)(octeon_bootinfo->phy_mem_desc_addr));
+
+#if defined(CONFIG_CAVIUM_DECODE_RSL) && !defined(CONFIG_WRHV)
+	cvmx_error_initialize(CVMX_ERROR_FLAGS_ECC_SINGLE_BIT | CVMX_ERROR_FLAGS_CORRECTABLE);
+#endif
+
+#if CONFIG_CAVIUM_RESERVE32
+	/*
+	 * We need to temporarily allocate all memory in the reserve32
+	 * region. This makes sure the kernel doesn't allocate this
+	 * memory when it is getting memory from the
+	 * bootloader. Later, after the memory allocations are
+	 * complete, the reserve32 will be freed.
+	 *
+	 * Allocate memory for RESERVED32 aligned on 2MB boundary. This
+	 * is in case we later use hugetlb entries with it.
+	 */
+	addr = cvmx_bootmem_phy_named_block_alloc(CONFIG_CAVIUM_RESERVE32 << 20,
+						0, 0, 2 << 20,
+						"CAVIUM_RESERVE32", 0);
+	if (addr < 0)
+		pr_err("Failed to allocate CAVIUM_RESERVE32 memory area\n");
+	else
+		octeon_reserve32_memory = addr;
+#endif
+
+	sysinfo = cvmx_sysinfo_get();
+	memset(sysinfo, 0, sizeof(*sysinfo));
+	sysinfo->system_dram_size = octeon_bootinfo->dram_size << 20;
+	sysinfo->phy_mem_desc_addr = (uint64_t)(octeon_bootinfo->phy_mem_desc_addr);
+	sysinfo->core_mask = octeon_bootinfo->core_mask;
+	sysinfo->exception_base_addr = (uint64_t)octeon_bootinfo->exception_base_addr;
+	sysinfo->cpu_clock_hz = octeon_bootinfo->eclock_hz;
+	sysinfo->dram_data_rate_hz = octeon_bootinfo->dclock_hz * 2;
+	sysinfo->board_type = octeon_bootinfo->board_type;
+	sysinfo->board_rev_major = octeon_bootinfo->board_rev_major;
+	sysinfo->board_rev_minor = octeon_bootinfo->board_rev_minor;
+	memcpy(sysinfo->mac_addr_base, octeon_bootinfo->mac_addr_base,
+	       sizeof(sysinfo->mac_addr_base));
+	sysinfo->mac_addr_count = octeon_bootinfo->mac_addr_count;
+	memcpy(sysinfo->board_serial_number,
+	       octeon_bootinfo->board_serial_number,
+	       sizeof(sysinfo->board_serial_number));
+	sysinfo->compact_flash_common_base_addr =
+		octeon_bootinfo->compact_flash_common_base_addr;
+	sysinfo->compact_flash_attribute_base_addr =
+		octeon_bootinfo->compact_flash_attribute_base_addr;
+	sysinfo->led_display_base_addr = octeon_bootinfo->led_display_base_addr;
+	sysinfo->dfa_ref_clock_hz = octeon_bootinfo->dfa_ref_clock_hz;
+	sysinfo->bootloader_config_flags = octeon_bootinfo->config_flags;
+
+	octeon_uart = octeon_get_boot_uart();
+
+#ifdef CONFIG_SMP
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("CrashSMP");
+#else
+#endif
+#else
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("Crash");
+#else
+	octeon_write_lcd("Linux");
+#endif
+#endif
+
+
+#ifdef CONFIG_CAVIUM_GDB
+	cvmx_debug_init();
+#endif
+
+#ifndef CONFIG_WRHV
+	/* 
+	 * WRHV platform uses generic delay functions instead of
+         * Cavium specific ones
+         */
+	octeon_setup_delays();
+#endif
+
+	/* Default to 64MB in the simulator to speed things up */
+	if (octeon_is_simulation())
+		MAX_MEMORY = 64ull << 20;
+
+	arcs_cmdline[0] = 0;
+	argc = octeon_boot_desc_ptr->argc;
+	for (i = 0; i < argc; i++) {
+		const char *arg = (char *)(octeon_boot_desc_ptr->argv[i]);
+#ifndef CONFIG_CRASH_DUMP
+		if ((strncmp(arg, "MEM=", 4) == 0) ||
+		    (strncmp(arg, "mem=", 4) == 0)) {
+			char mult = '?';
+			sscanf(arg + 4, "%llu%c", &MAX_MEMORY, &mult);
+			switch (mult) {
+			case 'M':
+			case '?': /* assume M when no multiplier */
+				MAX_MEMORY <<= 10;
+			case 'K':
+				MAX_MEMORY <<= 10;
+			default:
+				break;
+			}
+			if (MAX_MEMORY == 0)
+				MAX_MEMORY = 32ull << 30;
+		} else
+#endif /* CONFIG_CRASH_DUMP */
+		if (strcmp(arg, "ecc_verbose") == 0) {
+#ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC
+		else if (strcmp(arg, "ecc_verbose") == 0) {
+			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
+			pr_notice("Reporting of single bit ECC errors is "
+				  "turned on\n");
+		}
+#endif
+			strncpy(rd_name, arg + 8, sizeof(rd_name));
+			rd_name[sizeof(rd_name) - 1] = 0;
+		}
+		else if (strlen(arcs_cmdline) + strlen(arg) + 1 <
+			   sizeof(arcs_cmdline) - 1) {
+			strcat(arcs_cmdline, " ");
+			strcat(arcs_cmdline, arg);
+		}
+	}
+
+	if (strstr(arcs_cmdline, "console=pci"))
+		pci_console_init(strstr(arcs_cmdline, "console=pci") + 8);
+
+	if (strstr(arcs_cmdline, "console=") == NULL) {
+#ifdef CONFIG_GDB_CONSOLE
+		strcat(arcs_cmdline, " console=gdb");
+#else
+#ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL
+		strcat(arcs_cmdline, " console=ttyS0,115200");
+#else
+		if (octeon_uart == 1)
+			strcat(arcs_cmdline, " console=ttyS1,115200");
+		else
+			strcat(arcs_cmdline, " console=ttyS0,115200");
+#endif
+#endif
+	}
+
+	if (octeon_is_simulation()) {
+		/*
+		 * The simulator uses a mtdram device pre filled with
+		 * the filesystem. Also specify the calibration delay
+		 * to avoid calculating it every time.
+		 */
+		strcat(arcs_cmdline, " rw root=1f00 slram=root,0x40000000,+1073741824");
+	}
+
+	mips_hpt_frequency = octeon_get_clock_rate();
+
+#ifndef CONFIG_WRHV
+	octeon_init_cvmcount();
+#endif
+
+	_machine_restart = wrhv_restart;
+	_machine_halt = wrhv_halt;
+
+#ifndef CONFIG_WRHV
+	octeon_user_io_init();
+#endif
+
+#ifdef CONFIG_SMP
+	register_smp_ops(&octeon_smp_ops);
+#endif
+
+#ifndef CONFIG_WRHV
+	labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
+	if (labi->labi_signature == LABI_SIGNATURE)
+		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
+#endif
+
+#ifdef CONFIG_KEXEC
+	octeon_kexec_setup();
+#endif
+#ifdef CONFIG_CRASH_DUMP
+	octeon_crash_dump_setup();
+#endif
+
+	pr_info("Cavium Networks SDK-" SDK_VERSION "\n");
+
+}
+
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -585,6 +833,7 @@ void __init wrhv_init(void)
  	pv_info.paravirt_enabled = 1;
  
  	pv_cpu_ops.cpu_probe = wrhv_cpu_probe;
+ 	pv_cpu_ops.prom_init = wrhv_prom_init;
 	pv_cpu_ops.per_cpu_trap_init = wrhv_per_cpu_trap_init;
 
 	pv_mem_ops.tlb_init = wrhv_tlb_init;
-- 
1.7.0.4

