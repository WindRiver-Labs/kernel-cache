From a2780a6d4e4cf3321fbfde5deb0f23849f0d9f46 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 23 Mar 2011 13:52:18 +0800
Subject: [PATCH 3/5] WRHV: Cavium: Bootup secondary cores on SMP

Wake up secondary cores with VBI calls and enable IPIs per core.
Only register IPIs handler on boot core.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/smp.c |   58 ++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 57 insertions(+), 1 deletions(-)

diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 2235253..4029520 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -25,6 +25,14 @@
 
 #include <asm/octeon/cvmx-debug.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+VBI_HREG_SET_CMPLX_QUALIFIED bootREG;
+extern void kernel_entry(void);
+extern void wrhv_request_ipis(void);
+extern void wrhv_unmask_IPIs_for_vcore(void);
+#endif
+
 volatile unsigned long octeon_processor_boot = 0xff;
 volatile unsigned long octeon_processor_sp;
 volatile unsigned long octeon_processor_gp;
@@ -35,6 +43,7 @@ extern void octeon_hotplug_entry(void);
 #endif
 struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
 
+#ifndef CONFIG_WRHV
 static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 {
 	const int coreid = cvmx_get_core_num();
@@ -54,6 +63,7 @@ static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 		asm volatile ("synci 0($0)\n");
 	return IRQ_HANDLED;
 }
+#endif
 
 /**
  * Cause the function described by call_data to be executed on the passed
@@ -62,12 +72,20 @@ static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
  */
 void octeon_send_ipi_single(int cpu, unsigned int action)
 {
+#ifndef CONFIG_WRHV
 	int coreid = cpu_logical_map(cpu);
+#endif
 	/*
 	pr_info("SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n", cpu,
 	       coreid, action);
 	*/
+#ifdef CONFIG_WRHV
+	uint32_t coreset;
+	coreset = (1 << cpu);
+	vbi_send_vcore_vioapic_irq(action, coreset, 0);
+#else
 	cvmx_write_csr(CVMX_CIU_MBOX_SETX(coreid), action);
+#endif
 }
 
 static inline void octeon_send_ipi_mask(const struct cpumask *mask,
@@ -81,14 +99,20 @@ static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 
 static void octeon_smp_setup(void)
 {
+#ifdef CONFIG_WRHV
+	const int coreid = wr_vb_config->coreId;  
+#else
 	const int coreid = cvmx_get_core_num();
+#endif
 	int cpus;
 	int id;
 	int core_mask = octeon_get_boot_coremask();
 #ifdef CONFIG_HOTPLUG_CPU
 	unsigned int num_cores = cvmx_octeon_num_cores();
 #endif
+#ifndef CONFIG_WRHV
 	struct linux_app_boot_info *labi;
+#endif
 
 	/* The present CPUs are initially just the boot cpu (CPU 0). */
 	for (id = 0; id < NR_CPUS; id++) {
@@ -139,6 +163,7 @@ static void octeon_smp_setup(void)
 		}
 	}
 #endif
+#ifndef CONFIG_WRHV
 	octeon_hotplug_global_ptr =
 		(struct cvmx_app_hotplug_global *) cvmx_bootmem_alloc_named_range(
 			CVMX_APP_HOTPLUG_INFO_REGION_SIZE, 0x0, 0x0, 0,
@@ -154,6 +179,7 @@ static void octeon_smp_setup(void)
 
 	pr_info("Cavium Hotplug: Available coremask 0x%x\n",
 		octeon_hotplug_global_ptr->avail_coremask);
+#endif
 }
 
 /**
@@ -172,6 +198,23 @@ static void octeon_boot_secondary(int cpu, struct task_struct *idle)
 	octeon_processor_boot = cpu_logical_map(cpu);
 	mb();
 
+#ifdef CONFIG_WRHV
+	bootREG.vbiRegType = VBI_REG_SET_32BIT;
+	count = vbi_vb_read_reg(&bootREG, VBI_BOARD_ID_GET(), cpu);
+	if (count)
+		printk("WRHV read REG failed:%d\n", count);
+
+	bootREG.vbiRegSet.hreg64.pc = (uint64_t *) kernel_entry;
+
+	count = vbi_vb_write_reg(&bootREG, VBI_BOARD_ID_GET(), cpu);
+	if (count)
+		printk("WRHV write REG failed:%d\n", count);
+
+	count = vbi_vb_resume(VBI_BOARD_ID_GET(), cpu);
+	if (count)
+		printk("WRHV resume CPU failed:%d\n", count);
+#endif
+
 	count = 100000;
 	while (octeon_processor_sp && count) {
 		/* Waiting for processor to get the SP and GP */
@@ -188,6 +231,10 @@ static void octeon_boot_secondary(int cpu, struct task_struct *idle)
  */
 static void octeon_init_secondary(void)
 {
+#ifdef CONFIG_WRHV
+	/* Enable IPIs to this core. */
+	wrhv_unmask_IPIs_for_vcore();
+#else
 	const int coreid = cvmx_get_core_num();
 	union cvmx_ciu_intx_sum0 interrupt_enable;
 
@@ -209,6 +256,7 @@ static void octeon_init_secondary(void)
 	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2 + 1)), 0);
 	/* Enable core interrupt processing for 2,3 and 7 */
 	set_c0_status(0x8c01);
+#endif
 }
 
 /**
@@ -234,6 +282,9 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 	octeon_hotplug_entry_addr = (uint32_t)CKSEG0ADDR(t);
 #endif
 
+#ifdef CONFIG_WRHV
+	wrhv_request_ipis();
+#else
 	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(cvmx_get_core_num()), 0xffffffff);
 	if (request_irq(OCTEON_IRQ_MBOX0, mailbox_interrupt, IRQF_DISABLED,
 			"mailbox0", mailbox_interrupt)) {
@@ -243,6 +294,7 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 			"mailbox1", mailbox_interrupt)) {
 		panic("Cannot request_irq(OCTEON_IRQ_MBOX1)\n");
 	}
+#endif
 }
 
 /**
@@ -259,11 +311,15 @@ static void octeon_smp_finish(void)
 	asm volatile ("dmfc0 %0, $22\n"
 		      "ori   %0, %0, 0x9100\n" "dmtc0 %0, $22\n" : "=r" (tmp));
 #endif
-
+#ifdef CONFIG_WRHV
+	/* Enable timer interrupt */
+	local_irq_enable();
+#else
 	octeon_user_io_init();
 
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
+#endif
 }
 
 /**
-- 
1.7.0.4

