From 7d534ee3d1d33b40b9961388fe56191b8f164f96 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 23 Mar 2011 17:28:07 +0800
Subject: [PATCH 7/7] WRHV: MIPS: Change vmmu64_config to static allocation

Since vmmu64_config is always existed in the whole life cycle of
a process. So, it's not necessary to allocate memory space
dynamically via kmalloc/kfree for it, which introduced extra cost
and unstability. And, the whole task_struct will be destroyed
once the process exits, so there is also no any memory space waste.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/mmu.h         |    2 +-
 arch/mips/include/asm/mmu_context.h |    8 ++++----
 arch/mips/kernel/vbi/wrhv.c         |   35 +++++++++++------------------------
 3 files changed, 16 insertions(+), 29 deletions(-)

diff --git a/arch/mips/include/asm/mmu.h b/arch/mips/include/asm/mmu.h
index 105cc3b..e7eb387 100644
--- a/arch/mips/include/asm/mmu.h
+++ b/arch/mips/include/asm/mmu.h
@@ -9,7 +9,7 @@ typedef struct {
 	unsigned long asid[NR_CPUS];
 	void *vdso;
 #ifdef CONFIG_WRHV
-	struct vmmu64_config *config;
+	struct vmmu64_config config;
 #endif
 } mm_context_t;
 
diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index 8fe13dc..19340a6 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -224,7 +224,7 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	vb_context_vmmu_off(next);
 	vb_context_vmmu_on(next, next->pgd, cpu_asid(cpu, next));
 	wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, next);
-	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config->vmmu_handle;
+	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config.vmmu_handle;
 	vbi_ctx_load();
 #else
 	write_c0_entryhi(cpu_asid(cpu, next));
@@ -298,7 +298,7 @@ activate_mm(struct mm_struct *prev, struct mm_struct *next)
 #ifdef CONFIG_WRHV
 	vb_context_vmmu_on(next, next->pgd, cpu_asid(cpu, next));
 	wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, next);
-	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config->vmmu_handle;
+	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config.vmmu_handle;
 	/* Force to call sys_ctx_load to make VMMU setup take effect */
 	vbi_ctx_load();
 #else
@@ -354,7 +354,7 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 #ifdef CONFIG_WRHV
 		vb_context_vmmu_on(mm, mm->pgd, cpu_asid(cpu, mm));
 		wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, mm);
-		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config->vmmu_handle;
+		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config.vmmu_handle;
 		vbi_ctx_load();
 #else
 		write_c0_entryhi(cpu_asid(cpu, mm));
@@ -370,7 +370,7 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 #ifdef CONFIG_WRHV
 		vb_context_vmmu_on(mm, mm->pgd, cpu_asid(cpu, mm));
 		wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, mm);
-		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config->vmmu_handle;
+		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config.vmmu_handle;
 		vbi_ctx_load();
 #endif
 #else /* SMTC */
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index dfce673..766a98e 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -115,14 +115,11 @@ void __cpuinit wrhv_per_cpu_trap_init(void)
 	/* Paravirt tlb_init is empty */
 	tlb_init();
 
-	init_cfg.addr = (uint64_t) init_mm.pgd;
-	init_cfg.asid = 0;
-	init_cfg.flush_type = VMMU64_TLB_FLUSH_ALL;
-	init_cfg.vmmu_handle = 0;
-
-	init_mm.context.config = &init_cfg;
-
-	vbi_create_vmmu(&init_cfg);
+	init_mm.context.config.addr = (uint64_t) init_mm.pgd;
+	init_mm.context.config.asid = 0;
+	init_mm.context.config.flush_type = VMMU64_TLB_FLUSH_ALL;
+	init_mm.context.config.vmmu_handle = 0;
+	vbi_create_vmmu(&(init_mm.context.config));
  
 	wr_vb_control->vb_control_regs.asid = init_cfg.asid;
 	wr_vb_control->vb_control_regs.vmmu_handle = init_cfg.vmmu_handle;
@@ -325,21 +322,14 @@ int vb_context_vmmu_on(struct mm_struct *mm, void *pgd, unsigned int asid)
 	if (wr_config == (struct vb_config *)(-1) || !pgd)
 		return -1;
 
-	if (!mm->context.config)
-		mm->context.config = kmalloc(sizeof(struct vmmu64_config), GFP_KERNEL);
-	if (!mm->context.config)
-		panic("Can't allocate memory sapce for VMMU config\n");
+	mm->context.config.addr = (uint64_t) pgd;
 
-	if (mm->context.config->addr != (uint64_t) pgd) {
-		mm->context.config->addr = (uint64_t) pgd;
+	mm->context.config.asid = asid;
+	mm->context.config.flush_type = VMMU64_TLB_FLUSH_ASID;
+	mm->context.config.vmmu_handle = 0;
 
-		mm->context.config->asid = asid;
-		mm->context.config->flush_type = VMMU64_TLB_FLUSH_ASID;
-		mm->context.config->vmmu_handle = 0;
+	vbi_create_vmmu(&(mm->context.config));
 
-		vbi_create_vmmu(mm->context.config);
-	}
-	
 	return 0;
 }
 
@@ -349,10 +339,7 @@ int vb_context_vmmu_off(struct mm_struct *mm)
 	if ((wr_config == (struct vb_config *)(-1)) || !mm)
 		return -1;
 
-	ret = vbi_delete_vmmu(mm->context.config);
-	kfree(mm->context.config);
-	mm->context.config = NULL;
-
+	ret = vbi_delete_vmmu(&(mm->context.config));
 	return ret;
 }
 
-- 
1.7.0.4

