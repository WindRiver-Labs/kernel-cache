From 777f8aaec548fbe972159fe71905db996087b9cb Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Thu, 24 Mar 2011 11:19:18 +0800
Subject: [PATCH 5/7] WRHV: MIPS: Add common IPIs infrastructure

Add GOS specfic IPI handler and register IPIs. Since Hyp can't
recognize sub action in one interrupt. So, register 3 IPIs,
reschedule, call function and icache flush for GOS. And, they
share the same IPI handler by considering VIOAPIC vectors number
as the sub action.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/kernel/vbi/wrhv.c |   65 +++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 65 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index 0c514b7..46dd13c 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -39,6 +39,11 @@ extern void cpu_cache_init(void);
 extern void tlb_init(void);
 extern unsigned long setup_zero_pages(void);
 
+#ifdef CONFIG_SMP
+#define IPI_IRQ_BASE_NAME "ipi1"
+void wrhv_unmask_IPIs_for_vcore(void);
+#endif
+
 #define VECTORSPACING 0x100
 
 unsigned long max_asid;
@@ -351,6 +356,66 @@ int vb_context_vmmu_off(struct mm_struct *mm)
 	return ret;
 }
 
+#ifdef CONFIG_SMP
+static irqreturn_t wrhv_ipi_interrupt(int irq, void *dev_id)
+{
+ 	uint64_t action;
+ 
+ 	action = (uint64_t) irq;
+ 	if (action & SMP_CALL_FUNCTION)
+ 		smp_call_function_interrupt();
+ 
+#ifdef CONFIG_CAVIUM_OCTEON
+ 	/* Check if we've been told to flush the icache */
+ 	if (action & SMP_ICACHE_FLUSH)
+ 		asm volatile ("synci 0($0)\n");
+#endif
+ 
+ 	return IRQ_HANDLED;
+}
+ 
+void wrhv_request_ipis(void)
+{
+ 	static char *ipi_names[] = {
+ 		"IPI1 (reschedule)",
+ 		"IPI2 (call function)",
+#ifdef CONFIG_CAVIUM_OCTEON
+ 		"IPI3 (icache flush)",
+#endif
+ 	};
+ 
+ 	int i, err;
+ 	unsigned irq;
+ 
+ 	irq = vbi_find_irq(IPI_IRQ_BASE_NAME, VB_INPUT_INT);
+ 	if (irq == VBI_INVALID_IRQ)
+ 		panic("WRHV resolve irq for IPI failed\n");
+ 
+ 	for (i = 0; i < 3; i++) {
+ 		set_irq_chip_and_handler_name(irq + i, &wrhv_ipi_irq_chip,
+ 					      handle_percpu_irq, "per_cpu");
+ 		err = request_irq(irq + i, wrhv_ipi_interrupt,
+ 				  IRQF_DISABLED | IRQF_NOBALANCING,
+ 				  ipi_names[i], wrhv_ipi_interrupt);
+ 		if (err) {
+ 			printk("WRHV request of irq %d for IPI(%s) failed\n",
+ 			       irq + i, ipi_names[i]);
+ 			break;
+ 		}
+ 	}
+}
+ 
+void wrhv_unmask_IPIs_for_vcore(void)
+{
+ 	int i, irq;
+ 
+ 	irq = vbi_find_irq(IPI_IRQ_BASE_NAME, VB_INPUT_INT);
+ 	for (i = 0; i < 3; i++) {
+ 		vbi_unmask_vioapic_irq(irq + i);
+ 	}
+}
+#endif
+ 
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
-- 
1.7.0.4

