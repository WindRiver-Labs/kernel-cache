From 9d8c5ef3596849ee229e8322ee5ab21c8686cfcb Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 28 Feb 2011 12:49:35 +0800
Subject: [PATCH 02/38] WRHV: VBI: Update VMMU64 page table format and VBIs

Update vmmu64.h to follow the new page table format and vmmu64Config
struct. And, update syscall.h to add VMMU64 specific VBI definitions.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 include/vbi/syscall.h |   11 ++
 include/vbi/vmmu64.h  |  300 +++++++++++++++++++++++++++++++------------------
 2 files changed, 201 insertions(+), 110 deletions(-)

diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index 799941e..9d849f0 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -28,6 +28,7 @@
 
 /* Forward declaration */
 struct vmmuConfig;
+struct vmmu64_config;
 
 /* information about incoming message */
 
@@ -118,8 +119,13 @@ extern asmlinkage int32_t vbi_panic(const char *msg);
 extern int32_t vbi_flush_dcache(void *saddr, size_t size);
 extern int32_t vbi_flush_icache(void *saddr, size_t size);
 extern int32_t vbi_config_vmmu(struct vmmuConfig * config);
+#ifdef CONFIG_MIPS
+extern int32_t vbi_create_vmmu(struct vmmu64_config * config);
+extern int32_t vbi_delete_vmmu(struct vmmu64_config * config);
+#else
 extern int32_t vbi_create_vmmu(struct vmmuConfig * config);
 extern int32_t vbi_delete_vmmu(struct vmmuConfig * config);
+#endif
 extern int32_t vbi_enable_vmmu(uint32_t  vmmu_num);
 extern int32_t vbi_disable_vmmu(uint32_t vmmu_num);
 
@@ -129,7 +135,12 @@ extern int32_t vbi_ns_lookup_old(char *name, uint32_t  rev,
 				VBI_NS_HANDLE *pHandle);
 extern int32_t vbi_ns_lookup(char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle,
 				uint32_t timeout, uint32_t options);
+#ifdef CONFIG_MIPS
+extern int32_t vbi_tlb_flush_vmmu(struct vmmu64_config * config, void *addr, size_t len);
+#else
 extern int32_t vbi_tlb_flush_vmmu(struct vmmuConfig * config, void *addr, size_t len);
+#endif
+extern int32_t vbi_get_max_asid_vmmu(void);
 
 /* Prior to vbi 2.0 these api were vbi_set_mmu_attr/Get */
 
diff --git a/include/vbi/vmmu64.h b/include/vbi/vmmu64.h
index c7aabe3..35228b7 100644
--- a/include/vbi/vmmu64.h
+++ b/include/vbi/vmmu64.h
@@ -17,77 +17,128 @@
 #define __VBI_VMMU64_H
 
 /*
-
-The vmmu64 virtual address space is restricted to 40 bits and is decoded using
-a level-1/level-2/level-3 page table.  The virtual address is decoded as follows:
-
-
-                                          40-bit Virtual Address
-     +--------------------------------------------------------------------+
-     |      L1 offset       | L2 offset |  L3 offset |  Page offset       |
-     +--------------------------------------------------------------------+
-		10 bits       9 bits        9 bits        12 bits
-               |               |              |        
-               |               |              |
- +-------------+               |              +---------+
- |                             |                        |
- |                             |                        |
- |           L1 Table          |            L2 Table    |      L3 Table
- |    1023 +----------+        |     511 +----------+   |  511 +----------+
- |         |          |        |         |          |   |      |          |
- |         |          |        |         |          |   |      |          |
- |         |          |        |         |----------|   |      |----------|
- |         |          |        |   +---->|   L3 ptr |---+----->|   PTE    | 8 
- |         |          |        |   |     |----------| 28       |----------|byte
- |         |          | 19     |   |     |          | bits     |          |PTE
- |         |----------| bits   |   |     |          |          |          |
- +-------->|  L2 ptr  |--------+---+     |          |          |          |
-           |----------|                  |          |          |          |
-           |          |                  |          |          |          |
-           |          |                  |          |          |          |
-         0 +----------+                0 +----------+        0 +----------+
-           2 page (8KB)                   1 page (4KB)          1 page (4KB) 
-          1024 L2 pointers               512 L3 pointers        512 PTE entries
-
-
-
-(VMMU64_PTE is arch specific, following describes the VMMU64_PTE for mips64)  
-
-Each page table entry is 8 bytes and uses the following format:
-
-
-word 0 (64-bits):
-
-  63                 43 42                                  6 5     3 2 1 0
- +---------------------+-------------------------------------+-------+-----+
- |FILL                 |PFN                                  | Cache |D|V|G|
- +---------------------+-------------------------------------+-------+-+-+-+
-
-		PFN        - page frame number
-		C          - Cache Coherency bit
-		D	   - Dirty bit
-		V	   - Valid bit
-		G	   - Global bit
-
-*/
-
+ *
+ * VMMU64 format - 64-bit Virtual MMU format for Guest OS
+ * 
+ * 64-bit Virtual MMU format for Guest OS 
+ * 
+ * For a 64-bit virtual address, there would need to be a 6 level page table,
+ * with levels labelled as:
+ * 
+ * LX 	level x 	12 bits
+ * LY 	level y 	12 bits
+ * L1 	level 1 	10 bits
+ * L2 	level 2 	 9 bits
+ * L3 	level 3 	 9 bits
+ * PO 	pageoffset 	12 bits
+ *                        --------
+ *                         64 bits
+ *                        --------
+ * 
+ * In typical usage scenario 40-bits is sufficient (Linux for example). So
+ * we leave it as a configurable parameter:
+ * 
+ * 	WRHV_INCLUDE_VMMU64_USE_40BITS
+ * 
+ * If the above feature is enabled in archConfig.h, then it'll only use 40-bits
+ * as described below:
+ * 
+ * The vmmu64 virtual address space is restricted to 40 bits and is decoded using 
+ * a level-1/level-2/level-3 page table.  The virtual address is decoded as follows:
+ * 
+ * 
+ *                                           40-bit Virtual Address
+ *      +--------------------------------------------------------------------+
+ *      |      L1 offset       | L2 offset |  L3 offset |  Page offset       |
+ *      +--------------------------------------------------------------------+
+ * 		10 bits       9 bits        9 bits        12 bits
+ *                |               |              |        
+ *                |               |              |
+ *  +-------------+               |              +---------+
+ *  |                             |                        |
+ *  |                             |                        |
+ *  |           L1 Table          |            L2 Table    |      L3 Table
+ *  |    1023 +----------+        |     511 +----------+   |  511 +----------+
+ *  |         |          |        |         |          |   |      |          |
+ *  |         |          |        |         |          |   |      |          |
+ *  |         |          |        |         |----------|   |      |----------|
+ *  |         |          |        |   +---->|   L3 ptr |---+----->|   PTE    | 8 
+ *  |         |          |        |   |     |----------| 28       |----------|byte
+ *  |         |          | 19     |   |     |          | bits     |          |PTE
+ *  |         |----------| bits   |   |     |          |          |          |
+ *  +-------->|  L2 ptr  |--------+---+     |          |          |          |
+ *            |----------|                  |          |          |          |
+ *            |          |                  |          |          |          |
+ *            |          |                  |          |          |          |
+ *          0 +----------+                0 +----------+        0 +----------+
+ *            2 page (8KB)                   1 page (4KB)          1 page (4KB) 
+ *           1024 L2 pointers               512 L3 pointers        512 PTE entries
+ * 
+ * 
+ * 
+ * (VMMU64_PTE is arch specific, following describes the VMMU64_PTE for mips64)  
+ * 
+ * Each page table entry is 8 bytes and uses the following format:
+ * 
+ * 
+ * word 0 (64-bits):
+ * 
+ *   6     6                   5                   4               3
+ *   3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |Fill                                   |PFN                    |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * 
+ * 
+ *     3                   2                   1
+ *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *  |PFN                                    |C C C D V G| user-bits |
+ *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * 
+ * 
+ * 		PFN        - page frame number
+ * 		C          - Cache Coherency bit
+ * 		D	   - Dirty bit
+ * 		V	   - Valid bit
+ * 		G	   - Global bit
+ * 		u	   - user-bits
+ * 
+ * NOTE:
+ * 
+ * Hypervisor would not know the guest is using 64-bit VMMU unless
+ * the configuration file, specifically mentions the GuestOS type 
+ * of "Application Unprivileged 64" or "Application Privileged 64" 
+ * or any of the WRLinux versions.
+ *
+ * Unless the Virtual Board configuration file indicates the Guest OS
+ * type, hypervisor would not know that the guest is using 64-bit
+ * vmmu, in which case, it would default to using 32-bit VMMU and
+ * would cause unpredictable behaviour (most likely crash).
+ *
+ */
+ 
 #ifndef	_ASMLANGUAGE
 
 #if (CPU == MIPSI64R2) 
-/* Page Table Entry Definition */
-
 typedef union vmmu64_pte		/* vmmu64 pte format */
-    {
+{
 	struct {
-	uint32_t fill:21;		/* could be used for pagemask */
-	uint64_t pfn:37;
-	uint32_t coherent:3;
-	uint32_t dirty:1;
-	uint32_t valid:1;
-	uint32_t global:1;
+		uint64_t fill:20;		
+		uint64_t pfn:32;
+		uint64_t coherent:3;
+		uint64_t dirty:1;
+		uint64_t valid:1;
+		uint64_t global:1;
+		uint64_t usr5:1;
+		uint64_t usr4:1;
+		uint64_t usr3:1;
+		uint64_t usr2:1;
+		uint64_t usr1:1;
+		uint64_t usr0:1;
 	} field;
 	uint64_t data64;
-    } VMMU64_PTE;
+} VMMU64_PTE;
 #else
 /* for all other arches, for now placeholder */
 typedef uint64_t VMMU64_PTE;
@@ -96,74 +147,98 @@ typedef uint64_t VMMU64_PTE;
 /* Effective Address Definition */
 
 typedef union vmmu64EffectiveAddr 	/* effective Address structure */
-    {
-    struct
-        {
-        uint64_t fill:24;			/* reserved */
-        uint64_t l1index:10;		/* Level 1 Index (1K) */
-        uint64_t l2index:9;		/* Level 2 Index (512) */
-        uint64_t l3index:9;		/* Level 3 Index (512) */
-        uint64_t po:12;			/* Page Offset (4K) */
-        } field;
-    uint64_t addr;
-    } VMMU64_EFFECTIVE_ADDR;
+{
+	struct {
+		uint64_t fill:24;			/* reserved */
+		uint64_t l1index:10;		/* Level 1 Index (1K) */
+		uint64_t l2index:9;		/* Level 2 Index (512) */
+		uint64_t l3index:9;		/* Level 3 Index (512) */
+		uint64_t po:12;			/* Page Offset (4K) */
+	} field;
+	uint64_t addr;
+} VMMU64_EFFECTIVE_ADDR;
 
 typedef union vmmu64RealAddress		/* Real Address Structure */
-    {
-    struct                      	/* Bit field description */
-        {
-        uint64_t rpn:52;           	/* Real Page Number */
-        uint64_t po:12;            	/* Page Offset */
-        }field;
-    uint64_t realAddr;            	/* Real Address */
-    } VMMU64_REAL_ADDRESS;
-
+{
+	struct {                      	/* Bit field description */
+		uint64_t rpn:52;           	/* Real Page Number */
+		uint64_t po:12;            	/* Page Offset */
+	}field;
+	uint64_t realAddr;            	/* Real Address */
+} VMMU64_REAL_ADDRESS;
+
+
+#ifndef WRHV_INCLUDE_VMMU64_USE_40BITS
+/* Level-0 descriptor definition */
+
+typedef union vmmu64_level_0_desc	/* Level 0 descriptor format */
+{
+	struct {                      	/* Bit field desciption */
+		uint64_t l1ba:52;          	/* Level 1 table Base Address */
+		uint64_t reserved:12;      	/* Reserved */
+	} field;
+	uint64_t l0desc;               	/* Level 0 descriptor */
+} VMMU64_LEVEL_0_DESC;
+#endif
 
 /* Level-1 descriptor definition */
 
 typedef union vmmu64_level_1_desc	/* Level 1 descriptor format */
-    {
-    struct                      	/* Bit field desciption */
-        {
-        uint64_t l2ba:52;          	/* Level 2 table Base Address */
-        uint64_t reserved:12;      	/* Reserved */
-        } field;
-    uint64_t l1desc;               	/* Level 1 descriptor */
-    } VMMU64_LEVEL_1_DESC;
+{
+	struct {                      	/* Bit field desciption */
+		uint64_t l2ba:52;          	/* Level 2 table Base Address */
+		uint64_t reserved:12;      	/* Reserved */
+	} field;
+	uint64_t l1desc;               	/* Level 1 descriptor */
+} VMMU64_LEVEL_1_DESC;
 
 
 /* Level-2 descriptor definition */
 
 typedef union vmmu64_level_2_desc	/* Level 2 descriptor format */
-    {
-    struct                      	/* Bit field desciption */
-        {
-        uint64_t l3ba:52;          	/* Level 3 table Base Address */
-        uint64_t reserved:12;      	/* Reserved */
-        } field;
-    uint64_t l1desc;               	/* Level 3 descriptor */
-    } VMMU64_LEVEL_2_DESC;
+{
+	struct {                      	/* Bit field desciption */
+		uint64_t l3ba:52;          	/* Level 3 table Base Address */
+		uint64_t reserved:12;      	/* Reserved */
+	} field;
+	uint64_t l2desc;               	/* Level 3 descriptor */
+} VMMU64_LEVEL_2_DESC;
 
 
 /* Level-3 descriptor definition */
 
 typedef union vmmu64_level_3_desc	/* Level 2 descriptor format */
-    {
-    VMMU64_PTE pte;			/* a full PTE entry */
-    } VMMU64_LEVEL_3_DESC;
+{
+	VMMU64_PTE pte;			/* a full PTE entry */
+} VMMU64_LEVEL_3_DESC;
 
+/* VMMU configuration system call paramter */
+
+typedef struct vmmu64_config
+{
+	uint64_t	addr; 
+	uint32_t	flush_type;
+	uint32_t	asid;
+	uint32_t	vmmu_handle; 
+} VMMU64_CONFIG;
 
 #endif /* _ASMLANGUAGE */
 
 
 /* VMMU page table structure */
 
-#define	VMMU64_L1_ENTRIES	1024	/* top 10 bits of address	*/
-#define	VMMU64_L1_SIZE	2	/* table size in pages (8KB)	*/
-#define	VMMU64_L2_ENTRIES	512	/* middle 9 bits of address	*/
-#define	VMMU64_L2_SIZE	1	/* table size in pages (4KB)	*/
-#define	VMMU64_L3_ENTRIES	512	/* middle 9 bits of address	*/
-#define	VMMU64_L3_SIZE	1	/* table size in pages (4KB)	*/
+#ifdef WRHV_INCLUDE_VMMU64_4LEVEL_PAGE_TABLE
+#define	VMMU64_LX_ENTRIES	4096 	/* top 12 bits of address	*/
+#define	VMMU64_LX_SIZE		8	/* table size in pages (32KB)	*/
+#define	VMMU64_LY_ENTRIES	4096 	/* next 12 bits of address	*/
+#define	VMMU64_LY_SIZE		8	/* table size in pages (32KB)	*/
+#endif
+#define	VMMU64_L1_ENTRIES	1024	/* next 10 bits of address	*/
+#define	VMMU64_L1_SIZE		2	/* table size in pages (8KB)	*/
+#define	VMMU64_L2_ENTRIES	512	/* next 9 bits of address	*/
+#define	VMMU64_L2_SIZE		1	/* table size in pages (4KB)	*/
+#define	VMMU64_L3_ENTRIES	512	/* next 9 bits of address	*/
+#define	VMMU64_L3_SIZE		1	/* table size in pages (4KB)	*/
 
 #define VMMU64_TLB_FLUSH_ALL    0
 #define VMMU64_TLB_FLUSH_NONE   1
@@ -174,7 +249,7 @@ typedef union vmmu64_level_3_desc	/* Level 2 descriptor format */
 #define	VMMU64_PAGE_SIZE	4096	/* always use a 4KB page size */
 #define	VMMU64_RPN_SHIFT	12
 #endif
-#define	NVPAGES(x)		((x)/VMMU64_PAGE_SIZE)
+#define	NV64PAGES(x)		((x)/VMMU64_PAGE_SIZE)
 
 /* address to level-1 table offset */
 
@@ -197,4 +272,9 @@ typedef union vmmu64_level_3_desc	/* Level 2 descriptor format */
 #define	VMMU64_ADDR_TO_LBA(v)	(((uint64_t)(v)) >> VMMU64_RPN_SHIFT)
 #define	VMMU64_LBA_TO_ADDR(v)	(((uint64_t)(v)) << VMMU64_RPN_SHIFT)
 
+/* arch PTE commands */
+#define VMMU64_PTE_INVALID	0
+#define VMMU64_PTE_VALID	1
+#define VMMU64_PTE_ATTR_SET	2
+
 #endif  /* __VBI_VMMU64_H */
-- 
1.6.5.2

