From 69289c4de060d83342db99d04a103acc45f875ca Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 25 Feb 2011 11:56:06 +0800
Subject: [PATCH 38/38] WRHV: MIPS: Add multiple ASID VMMU support

vmmu64_config is used to identify a per-process based VMMU config
by Hypervisor, so add the vmmu64Config pointer into mmu_context_t
structure.

Define vb_context_vmmu_on/off helper functions and enable/disable
VMMU config for a process when process creation/deletion and
switch.

Enable VMMU config for INIT process to setup kernel page table.

Get maximum ASID via vbi_get_max_asid_vmmu. The range of ASID
used by GOS is limited by Hypervisor.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/mmu.h         |    7 ++++
 arch/mips/include/asm/mmu_context.h |   56 +++++++++++++++++++++++++++++++++
 arch/mips/kernel/vbi/wrhv.c         |   59 +++++++++++++++++++++++++++++++++++
 3 files changed, 122 insertions(+), 0 deletions(-)

diff --git a/arch/mips/include/asm/mmu.h b/arch/mips/include/asm/mmu.h
index c436138..105cc3b 100644
--- a/arch/mips/include/asm/mmu.h
+++ b/arch/mips/include/asm/mmu.h
@@ -1,9 +1,16 @@
 #ifndef __ASM_MMU_H
 #define __ASM_MMU_H
 
+#ifdef CONFIG_WRHV
+#include <vbi/vmmu64.h>
+#endif
+
 typedef struct {
 	unsigned long asid[NR_CPUS];
 	void *vdso;
+#ifdef CONFIG_WRHV
+	struct vmmu64_config *config;
+#endif
 } mm_context_t;
 
 #endif /* __ASM_MMU_H */
diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index 25e32d6..8fe13dc 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -24,6 +24,14 @@
 #endif /* SMTC */
 #include <asm-generic/mm_hooks.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+extern int vb_context_vmmu_on(struct mm_struct *mm, void * pgd, unsigned int asid);
+extern int vb_context_vmmu_off(struct mm_struct *mm);
+extern void vbi_ctx_load(void);
+extern unsigned long max_asid;
+#endif
+
 #ifdef CONFIG_MIPS_PGD_C0_CONTEXT
 
 #define TLBMISS_HANDLER_SETUP_PGD(pgd)				\
@@ -103,6 +111,12 @@ extern unsigned long smtc_asid_mask;
 #define ASID_MASK	(smtc_asid_mask)
 #define	HW_ASID_MASK	0xff
 /* End SMTC/34K debug hack */
+
+#elif defined(CONFIG_WRHV)
+
+#define ASID_INC	0x1
+#define ASID_MASK	max_asid	
+
 #else /* FIXME: not correct for R6000 */
 
 #define ASID_INC	0x1
@@ -206,7 +220,15 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	ehb(); /* Make sure it propagates to TCStatus */
 	evpe(mtflags);
 #else
+#ifdef CONFIG_WRHV
+	vb_context_vmmu_off(next);
+	vb_context_vmmu_on(next, next->pgd, cpu_asid(cpu, next));
+	wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, next);
+	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config->vmmu_handle;
+	vbi_ctx_load();
+#else
 	write_c0_entryhi(cpu_asid(cpu, next));
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
 
@@ -228,7 +250,14 @@ static inline void destroy_context(struct mm_struct *mm)
 {
 }
 
+#ifdef CONFIG_WRHV
+#define deactivate_mm(tsk, mm)			\
+	do {					\
+		vb_context_vmmu_off(mm);	\
+	} while (0)
+#else
 #define deactivate_mm(tsk, mm)	do { } while (0)
+#endif
 
 /*
  * After we have set current->mm to a new value, this activates
@@ -266,7 +295,15 @@ activate_mm(struct mm_struct *prev, struct mm_struct *next)
 	ehb(); /* Make sure it propagates to TCStatus */
 	evpe(mtflags);
 #else
+#ifdef CONFIG_WRHV
+	vb_context_vmmu_on(next, next->pgd, cpu_asid(cpu, next));
+	wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, next);
+	wr_vb_control->vb_control_regs.vmmu_handle = next->context.config->vmmu_handle;
+	/* Force to call sys_ctx_load to make VMMU setup take effect */
+	vbi_ctx_load();
+#else
 	write_c0_entryhi(cpu_asid(cpu, next));
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
 
@@ -295,6 +332,9 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 	local_irq_save(flags);
 
 	if (cpumask_test_cpu(cpu, mm_cpumask(mm)))  {
+#ifdef CONFIG_WRHV
+		vb_context_vmmu_off(mm);
+#endif
 		get_new_mmu_context(mm, cpu);
 #ifdef CONFIG_MIPS_MT_SMTC
 		/* See comments for similar code above */
@@ -311,12 +351,28 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 		ehb(); /* Make sure it propagates to TCStatus */
 		evpe(prevvpe);
 #else /* not CONFIG_MIPS_MT_SMTC */
+#ifdef CONFIG_WRHV
+		vb_context_vmmu_on(mm, mm->pgd, cpu_asid(cpu, mm));
+		wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, mm);
+		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config->vmmu_handle;
+		vbi_ctx_load();
+#else
 		write_c0_entryhi(cpu_asid(cpu, mm));
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 	} else {
 		/* will get a new context next time */
 #ifndef CONFIG_MIPS_MT_SMTC
+#ifdef CONFIG_WRHV
+		vb_context_vmmu_off(mm);
+#endif
 		cpu_context(cpu, mm) = 0;
+#ifdef CONFIG_WRHV
+		vb_context_vmmu_on(mm, mm->pgd, cpu_asid(cpu, mm));
+		wr_vb_control->vb_control_regs.asid = cpu_asid(cpu, mm);
+		wr_vb_control->vb_control_regs.vmmu_handle = mm->context.config->vmmu_handle;
+		vbi_ctx_load();
+#endif
 #else /* SMTC */
 		int i;
 
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index 98e00e6..eb7d68c 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -40,6 +40,15 @@ extern unsigned long setup_zero_pages(void);
 
 #define VECTORSPACING 0x100
 
+unsigned long max_asid;
+
+static void get_max_asid(void)
+{
+	max_asid = vbi_get_max_asid_vmmu();
+}
+
+static struct vmmu64_config init_cfg;
+
 void __cpuinit wrhv_per_cpu_trap_init(void)
 {
 	extern char except_vec3_generic;
@@ -100,6 +109,20 @@ void __cpuinit wrhv_per_cpu_trap_init(void)
 	/* Paravirt tlb_init is empty */
 	tlb_init();
 
+	init_cfg.addr = (uint64_t) init_mm.pgd;
+	init_cfg.asid = 0;
+	init_cfg.flush_type = VMMU64_TLB_FLUSH_ALL;
+	init_cfg.vmmu_handle = 0;
+
+	init_mm.context.config = &init_cfg;
+
+	vbi_create_vmmu(&init_cfg);
+ 
+	wr_vb_control->vb_control_regs.asid = init_cfg.asid;
+	wr_vb_control->vb_control_regs.vmmu_handle = init_cfg.vmmu_handle;
+
+	get_max_asid();
+
 	TLBMISS_HANDLER_SETUP();
 }
 
@@ -274,7 +297,43 @@ long wrhv_kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	trace_sched_kthread_create(fn, pid);
 	return pid;
 }
+
+int vb_context_vmmu_on(struct mm_struct *mm, void *pgd, unsigned int asid)
+{
+	if (wr_config == (struct vb_config *)(-1) || !pgd)
+		return -1;
+
+	if (!mm->context.config)
+		mm->context.config = kmalloc(sizeof(struct vmmu64_config), GFP_KERNEL);
+	if (!mm->context.config)
+		panic("Can't allocate memory sapce for VMMU config\n");
+
+	if (mm->context.config->addr != (uint64_t) pgd) {
+		mm->context.config->addr = (uint64_t) pgd;
+
+		mm->context.config->asid = asid;
+		mm->context.config->flush_type = VMMU64_TLB_FLUSH_ASID;
+		mm->context.config->vmmu_handle = 0;
+
+		vbi_create_vmmu(mm->context.config);
+	}
 	
+	return 0;
+}
+
+int vb_context_vmmu_off(struct mm_struct *mm)
+{
+	int ret;
+	if ((wr_config == (struct vb_config *)(-1)) || !mm)
+		return -1;
+
+	ret = vbi_delete_vmmu(mm->context.config);
+	kfree(mm->context.config);
+	mm->context.config = NULL;
+
+	return ret;
+}
+
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
-- 
1.6.5.2

