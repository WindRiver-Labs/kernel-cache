From 42aefa4d02f769c07783d6d2127826b06e39aad2 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 25 Feb 2011 11:49:00 +0800
Subject: [PATCH 36/38] WRHV: MIPS: Move kcore address to CKSSEG

Since GOS kernel image link address is in CKSSEG, so move kcore
address to CKSEEG accordingly.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/paravirt.h |    2 +
 arch/mips/kernel/paravirt.c      |    6 +++
 arch/mips/kernel/vbi/wrhv.c      |   78 ++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/init.c              |   11 +++++-
 4 files changed, 96 insertions(+), 1 deletions(-)

diff --git a/arch/mips/include/asm/paravirt.h b/arch/mips/include/asm/paravirt.h
index 51da23c..4065705 100644
--- a/arch/mips/include/asm/paravirt.h
+++ b/arch/mips/include/asm/paravirt.h
@@ -15,6 +15,7 @@ extern void __init native_per_cpu_trap_init(void);
 extern void __init native_tlb_init(void);
 extern void __init native_arch_init_irq(void);
 extern void __init native_plat_time_init(void);
+extern void __init native_mem_init(void);
 
 /*
  * paravirtual operations structure
@@ -25,6 +26,7 @@ struct pv_cpu_ops {
 
 struct pv_mem_ops {
 	void (*tlb_init)(void);
+	void (*mem_init)(void);
 };
  
 struct pv_irq_ops {
diff --git a/arch/mips/kernel/paravirt.c b/arch/mips/kernel/paravirt.c
index 6d109c9..106a907 100644
--- a/arch/mips/kernel/paravirt.c
+++ b/arch/mips/kernel/paravirt.c
@@ -45,6 +45,7 @@ struct pv_cpu_ops pv_cpu_ops = {
 
 struct pv_mem_ops pv_mem_ops = {
 	.tlb_init = native_tlb_init,
+	.mem_init = native_mem_init,
 };
 
 struct pv_irq_ops pv_irq_ops = {
@@ -75,6 +76,11 @@ void __init paravirt_plat_time_init(void)
  	pv_time_ops.plat_time_init();
 }
  
+void __init paravirt_mem_init(void)
+{
+ 	pv_mem_ops.mem_init();
+}
+ 
 EXPORT_SYMBOL(pv_cpu_ops);
 EXPORT_SYMBOL(pv_mem_ops);
 EXPORT_SYMBOL(pv_irq_ops);
diff --git a/arch/mips/kernel/vbi/wrhv.c b/arch/mips/kernel/vbi/wrhv.c
index 54162d9..b0aadcf 100644
--- a/arch/mips/kernel/vbi/wrhv.c
+++ b/arch/mips/kernel/vbi/wrhv.c
@@ -19,9 +19,14 @@
 #include <linux/interrupt.h>
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
+#include <linux/bootmem.h>
+#include <linux/proc_fs.h>
+#include <linux/swap.h>
+#include <linux/highmem.h>
 
 #include <asm/mipsmtregs.h>
 #include <asm/mmu_context.h>
+#include <asm/sections.h>
 
 #include <vbi/vbi.h>
 #include <linux/wrhv.h>
@@ -30,6 +35,7 @@ struct vb_config *wr_config;
 
 extern void cpu_cache_init(void);
 extern void tlb_init(void);
+extern unsigned long setup_zero_pages(void);
 
 #define VECTORSPACING 0x100
 
@@ -167,6 +173,77 @@ void __init wrhv_plat_time_init(void)
 		printk("Setup Timer interrupt failed\n");
 }
 
+#ifdef CONFIG_64BIT
+static struct kcore_list kcore_ksseg;
+#endif
+
+void __init wrhv_mem_init(void)
+{
+	unsigned long codesize, reservedpages, datasize, initsize;
+	unsigned long tmp, ram;
+
+#ifdef CONFIG_HIGHMEM
+#ifdef CONFIG_DISCONTIGMEM
+#error "CONFIG_HIGHMEM and CONFIG_DISCONTIGMEM dont work together yet"
+#endif
+	max_mapnr = highend_pfn;
+#else
+	max_mapnr = max_low_pfn;
+#endif
+	high_memory = (void *) __va(max_low_pfn << PAGE_SHIFT);
+
+	totalram_pages += free_all_bootmem();
+	totalram_pages -= setup_zero_pages();	/* Setup zeroed pages.  */
+
+	reservedpages = ram = 0;
+	for (tmp = 0; tmp < max_low_pfn; tmp++)
+		if (page_is_ram(tmp)) {
+			ram++;
+			if (PageReserved(pfn_to_page(tmp)))
+				reservedpages++;
+		}
+	num_physpages = ram;
+
+#ifdef CONFIG_HIGHMEM
+	for (tmp = highstart_pfn; tmp < highend_pfn; tmp++) {
+		struct page *page = pfn_to_page(tmp);
+
+		if (!page_is_ram(tmp)) {
+			SetPageReserved(page);
+			continue;
+		}
+		ClearPageReserved(page);
+		init_page_count(page);
+		__free_page(page);
+		totalhigh_pages++;
+	}
+	totalram_pages += totalhigh_pages;
+	num_physpages += totalhigh_pages;
+#endif
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+#ifdef CONFIG_64BIT
+	if ((unsigned long) &_text > (unsigned long) CKSSEG)
+		/* The -4 is a hack so that user tools don't have to handle
+		   the overflow.  */
+		kclist_add(&kcore_ksseg, (void *) CKSSEG,
+				0xc0000000 - 4, KCORE_TEXT);
+#endif
+
+	printk(KERN_INFO "Memory: %luk/%luk available (%ldk kernel code, "
+	       "%ldk reserved, %ldk data, %ldk init, %ldk highmem)\n",
+	       nr_free_pages() << (PAGE_SHIFT-10),
+	       ram << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       reservedpages << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10,
+	       totalhigh_pages << (PAGE_SHIFT-10));
+}
+
 void __init wrhv_init(void)
 {
 	/* initialize wr_config so that we can access
@@ -180,6 +257,7 @@ void __init wrhv_init(void)
 	pv_cpu_ops.per_cpu_trap_init = wrhv_per_cpu_trap_init;
 
 	pv_mem_ops.tlb_init = wrhv_tlb_init;
+	pv_mem_ops.mem_init = wrhv_mem_init;
 
 	pv_irq_ops.arch_init_irq = wrhv_arch_init_irq;
 
diff --git a/arch/mips/mm/init.c b/arch/mips/mm/init.c
index 2efcbd2..a533ff9 100644
--- a/arch/mips/mm/init.c
+++ b/arch/mips/mm/init.c
@@ -361,7 +361,10 @@ void __init paging_init(void)
 static struct kcore_list kcore_kseg0;
 #endif
 
-void __init mem_init(void)
+void paravirt_mem_init(void)
+	__attribute__ ((weak, alias("native_mem_init")));
+
+void __init native_mem_init(void)
 {
 	unsigned long codesize, reservedpages, datasize, initsize;
 	unsigned long tmp, ram;
@@ -427,6 +430,12 @@ void __init mem_init(void)
 	       initsize >> 10,
 	       totalhigh_pages << (PAGE_SHIFT-10));
 }
+
+void __init mem_init(void)
+{
+	paravirt_mem_init();
+}
+
 #endif /* !CONFIG_NEED_MULTIPLE_NODES */
 
 void free_init_pages(const char *what, unsigned long begin, unsigned long end)
-- 
1.6.5.2

