From ffe28f104998a17cf90b8f45603aaf9d3fca4b25 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 29 Nov 2010 13:37:09 +0800
Subject: [PATCH 08/38] WRHV: MIPS: Paravirtualize IRQ enable/disable interfaces

Since interrupt controller is virtualized by VIOAPIC, so IRQ
enable/disable interfaces need to be paravirtualized to set/get
external interrupt enabled/disabled flag.

Define VBI_VCORE_INT_UNLOCK/LOCK/STATE macros to paravirtualize
local_irq_enable/disable, etc.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/irqflags.h      |    4 +
 arch/mips/include/asm/wrhv_irqflags.h |  179 +++++++++++++++++++++++++++++++++
 2 files changed, 183 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/include/asm/wrhv_irqflags.h

diff --git a/arch/mips/include/asm/irqflags.h b/arch/mips/include/asm/irqflags.h
index 701ec0b..ef0bf6f 100644
--- a/arch/mips/include/asm/irqflags.h
+++ b/arch/mips/include/asm/irqflags.h
@@ -11,6 +11,9 @@
 #ifndef _ASM_IRQFLAGS_H
 #define _ASM_IRQFLAGS_H
 
+#ifdef CONFIG_WRHV
+#include <asm/wrhv_irqflags.h>
+#else
 #ifndef __ASSEMBLY__
 
 #include <linux/compiler.h>
@@ -241,6 +244,7 @@ static inline int raw_irqs_disabled_flags(unsigned long flags)
 }
 
 #endif
+#endif /* CONFIG_WRHV */
 
 /*
  * Do the CPU's IRQ-state tracing from assembly code.
diff --git a/arch/mips/include/asm/wrhv_irqflags.h b/arch/mips/include/asm/wrhv_irqflags.h
new file mode 100644
index 0000000..fe050a2
--- /dev/null
+++ b/arch/mips/include/asm/wrhv_irqflags.h
@@ -0,0 +1,179 @@
+/*
+ * wrhv_irqflags.h - MIPS64 architecture specific irq enable/disable definitions
+ *
+ * Copyright 2010 Wind River Systems, Inc.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ASM_WRHV_IRQFLAGS_H
+#define _ASM_WRHV_IRQFLAGS_H
+
+#include <linux/types.h>
+#include <vbi/vbi.h>
+
+#ifndef __ASSEMBLY__
+#include <linux/compiler.h>
+
+#define IRQS_ENABLED		0
+#define IRQS_DISABLED		-1
+
+/* 
+ * VB_CONTROL_INT_DISABLE offset is 0x78
+ * VB_STATUS_INT_PENDING offset is 0x58
+ */
+__asm__(
+	"	.macro	VBI_VCORE_INT_UNLOCK				\n"
+	"	ld	$t0, wr_vb_control				\n"
+	"	li	$t1, 0						\n"
+	/* sw	$t1, VB_CONTROL_INT_DISABLE($t0) */
+	"	sw	$t1, 0x78($t0)					\n"
+	"3:								\n"
+	"	ld	$t0, wr_vb_status				\n"
+	/* lw	$t1, VB_STATUS_INT_PENDING($t0) */
+	"	lw	$t1, 0x58($t0)					\n"
+	"	andi	$t1, 0						\n"
+	"	beqz	$t1, 0f						\n"
+	"	nop							\n"
+	/* VBI_SYS_int_enable == 0x85000000 */
+	"	li	$v0, 0x85000000					\n"
+	"	syscall							\n"
+	"	nop							\n"
+	"	b	3b						\n"
+	"	nop							\n"
+	"0:								\n"
+	"	.endm							\n");
+
+__asm__(
+	"	.macro	VBI_VCORE_INT_LOCK				\n"
+	"	li	$t1, -1						\n"
+	"	ld	$t2, wr_vb_control				\n"
+	/* sw	$t1, VB_CONTROL_INT_DISABLE($t2) */
+	"	sw	$t1, 0x78($t2)					\n"
+	"	.endm							\n");
+
+__asm__(
+	"	.macro	VBI_VCORE_INT_STATE				\n"
+	"	ld	$t2, wr_vb_control				\n"
+	/* lw	$t1, VB_CONTROL_INT_DISABLE($t2) */
+	"	lw	$t1, 0x78($t2)					\n"
+	"	.endm							\n");
+
+__asm__(
+	"	.macro	raw_local_irq_enable				\n"
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	VBI_VCORE_INT_UNLOCK					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
+
+static inline void raw_local_irq_enable(void) {
+	__asm__ __volatile__(
+		"raw_local_irq_enable"
+		: /* no outputs */
+		: /* no inputs */
+		: "memory");
+}
+
+__asm__(
+	"	.macro	raw_local_irq_disable				\n"
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	VBI_VCORE_INT_LOCK					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
+
+static inline void raw_local_irq_disable(void)
+{
+	__asm__ __volatile__(
+		"raw_local_irq_disable"
+		: /* no outputs */
+		: /* no inputs */
+		: "memory");
+}
+
+__asm__(
+	"	.macro	raw_local_save_flags flags			\n"
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	VBI_VCORE_INT_STATE					\n"
+	"	move	\\flags, $t1					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
+
+#define raw_local_save_flags(x)						\
+__asm__ __volatile__(							\
+	"raw_local_save_flags %0"					\
+	: "=r" (x))
+
+__asm__(
+	"	.macro	raw_local_irq_save result			\n"
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	VBI_VCORE_INT_STATE					\n"
+	"	move	\\result, $t1					\n"
+	"	VBI_VCORE_INT_LOCK					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
+
+#define raw_local_irq_save(x)						\
+__asm__ __volatile__(							\
+	"raw_local_irq_save\t%0"					\
+	: "=r" (x)							\
+	: /* no inputs */						\
+	: "memory")
+
+__asm__(
+	"	.macro	raw_local_irq_restore flags			\n"
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	beqz	\\flags, 1f					\n"
+	"	nop							\n"
+	"	VBI_VCORE_INT_LOCK					\n"
+	"	b	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	VBI_VCORE_INT_UNLOCK					\n"
+	"2:								\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
+
+static inline void raw_local_irq_restore(unsigned long flags)
+{
+	unsigned long __tmp1;
+
+	__asm__ __volatile__(
+		"raw_local_irq_restore\t%0"
+		: "=r" (__tmp1)
+		: "0" (flags)
+		: "memory");
+}
+
+static inline void __raw_local_irq_restore(unsigned long flags)
+{
+	unsigned long __tmp1;
+
+	__asm__ __volatile__(
+		"raw_local_irq_restore\t%0"
+		: "=r" (__tmp1)
+		: "0" (flags)
+		: "memory");
+}
+
+static inline int raw_irqs_disabled_flags(unsigned long flags)
+{
+	return (flags == IRQS_DISABLED);
+}
+
+#define raw_irqs_disabled	(vbi_vcore_irq_state() == IRQS_DISABLED)
+
+#endif
+
+#endif /* _ASM_WRHV_IRQFLAGS_H */ 
-- 
1.6.5.2

