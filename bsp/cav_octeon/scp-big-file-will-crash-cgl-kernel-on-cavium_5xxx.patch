From 7f76b079838802773323343a0f325ee042045c0b Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 3 Feb 2010 18:42:29 -0800
Subject: [PATCH] scp big file will crash cgl kernel on cavium_5xxx

Scp a big file to the target will crash the cgl kernel without
any calltrace, no response from the board.

This patch intended to fix the deadlock of MIPS assemble spin
lock in the context with PREEMPT_SOFTIRQS enabled, which only
intruduced by CONFIG_CPU_CAVIUM_OCTEON.

Root cause: It seems the assemble spin lock perfectly ensure
the concurrence in the context with PREEMPT_SOFTIRQS enabled,
but it looks like not enough for preemption. So we replace
CVMX_PKO_LOCK_CMD_QUEUE with CVMX_PKO_LOCK_NONE to use C spin
lock here from the original codes comments, and initialize it.

Scenario:
Core0:
=====
-------->preemtp other thead,
	cvm_oct_xmit() - ethernet-tx.c:153
	dev_queue_xmit() - dev.c:1920
	ip_queue_xmit() - ip_output.c:389
	tcp_transmit_skb() - tcp_output.c:690
	tcp_rcv_established() - tcp_input.c:4886
	tcp_v4_do_rcv() - tcp_ipv4.c:1481
	tcp_v4_rcv() - tcp_ipv4.c:1606
-------->held the _spin_lock,which will stuck core1.
	ip_local_deliver_finish() - ip_input.c:222
	ip_rcv_finish() - ip_input.c:357
	netif_receive_skb() - dev.c:2416
	cvm_oct_tasklet_rx() - ethernet-rx.c:390
	tasklet_action() - softirq.c:528
	ksoftirqd() - softirq.c:692
	kthread() - kthread.c:80
	kernel_thread_helper() - process.c:228

Core1:
=====
	_spin_lock() - spinlock.c:301
	tcp_v4_rcv() - tcp_ipv4.c:1593
	ip_local_deliver_finish() - ip_input.c:222
	ip_rcv_finish() - ip_input.c:357
	netif_receive_skb() - dev.c:2416
	cvm_oct_tasklet_rx() - ethernet-rx.c:390
	tasklet_action() - softirq.c:528
	ksoftirqd() - softirq.c:692
	kthread() - kthread.c:80
	kernel_thread_helper() - process.c:228

Signed-off-by: Zumeng.Chen <zumeng.chen@windrive.com>
---
 drivers/net/cavium-ethernet/cavium-ethernet.h |    1 +
 drivers/net/cavium-ethernet/ethernet-common.c |    1 +
 drivers/net/cavium-ethernet/ethernet-tx.c     |   15 +++++++++------
 3 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/drivers/net/cavium-ethernet/cavium-ethernet.h b/drivers/net/cavium-ethernet/cavium-ethernet.h
index 750de22..3b3d2ec 100644
--- a/drivers/net/cavium-ethernet/cavium-ethernet.h
+++ b/drivers/net/cavium-ethernet/cavium-ethernet.h
@@ -94,6 +94,7 @@ typedef struct {
 	int                     queue;          /* PKO hardware queue for the port */
 	int                     fau;            /* Hardware fetch and add to count outstanding tx buffers */
 	int                     imode;          /* Type of port. This is one of the enums in cvmx_helper_interface_mode_t */
+	spinlock_t		oct_tx_lock;
 	struct sk_buff_head     tx_free_list[16];/* List of outstanding tx buffers per queue */
 	/* Keeping intercept_cb close the the part of stats that is most often
 	 * modified helps throughput. */
diff --git a/drivers/net/cavium-ethernet/ethernet-common.c b/drivers/net/cavium-ethernet/ethernet-common.c
index 02aed05..d6e242e 100644
--- a/drivers/net/cavium-ethernet/ethernet-common.c
+++ b/drivers/net/cavium-ethernet/ethernet-common.c
@@ -244,6 +244,7 @@ int cvm_oct_common_init(struct net_device *dev)
 	cvm_oct_private_t *priv = (cvm_oct_private_t *)netdev_priv(dev);
 
 
+	spin_lock_init(&(priv->oct_tx_lock));
 	/* Force the interface to use the POW send if always_use_pow was
 	   specified or it is in the pow send list */
 	if ((pow_send_group != -1) && (always_use_pow || strstr(pow_send_list, dev->name)))
diff --git a/drivers/net/cavium-ethernet/ethernet-tx.c b/drivers/net/cavium-ethernet/ethernet-tx.c
index ca358cc..e8d56d9 100644
--- a/drivers/net/cavium-ethernet/ethernet-tx.c
+++ b/drivers/net/cavium-ethernet/ethernet-tx.c
@@ -87,6 +87,7 @@ int cvm_oct_xmit(struct sk_buff *skb, struct net_device *dev)
 #if REUSE_SKBUFFS_WITHOUT_FREE
 	unsigned char *fpa_head;
 #endif
+	int flags;
 
 	/* Prefetch the private data structure.
 	   It is larger that one cache line */
@@ -285,7 +286,7 @@ dont_put_skbuff_in_hw:
 		pko_command.s.reg0 = priv->fau+qos*4;
 	}
 
-	cvmx_pko_send_packet_prepare(priv->port, priv->queue + qos, CVMX_PKO_LOCK_CMD_QUEUE);
+	cvmx_pko_send_packet_prepare(priv->port, priv->queue + qos, CVMX_PKO_LOCK_NONE);
 
 	/* Drop this packet if we have too many already queued to the HW */
 	if (unlikely(skb_queue_len(&priv->tx_free_list[qos]) >=
@@ -297,11 +298,13 @@ dont_put_skbuff_in_hw:
 	}
 	/* Send the packet to the output queue */
 	else
-	if (unlikely(cvmx_pko_send_packet_finish(priv->port, priv->queue + qos, pko_command, hw_buffer, CVMX_PKO_LOCK_CMD_QUEUE))) {
+	spin_lock_irqsave(&(priv->oct_tx_lock), flags);
+	if (unlikely(cvmx_pko_send_packet_finish(priv->port, priv->queue + qos, pko_command, hw_buffer, CVMX_PKO_LOCK_NONE))) {
 		DEBUGPRINT("%s: Failed to send the packet\n", dev->name);
 		dropped = 1;
 	}
 
+	spin_unlock_irqrestore(&(priv->oct_tx_lock), flags);
 	if (USE_ASYNC_IOBDMA) {
 		/* Restore the scratch area */
 		cvmx_scratch_write64(CVMX_SCR_SCRATCH, old_scratch);
@@ -519,8 +522,8 @@ int cvm_oct_transmit_qos(struct net_device *dev, void *work_queue_entry, int do_
 	/* Start off assuming no drop */
 	dropped = 0;
 
-	local_irq_save(flags);
-	cvmx_pko_send_packet_prepare(priv->port, priv->queue + qos, CVMX_PKO_LOCK_CMD_QUEUE);
+	spin_lock_irqsave(&(priv->oct_tx_lock), flags);
+	cvmx_pko_send_packet_prepare(priv->port, priv->queue + qos, CVMX_PKO_LOCK_NONE);
 
 	/* Build the PKO buffer pointer */
 	hw_buffer.u64 = 0;
@@ -543,11 +546,11 @@ int cvm_oct_transmit_qos(struct net_device *dev, void *work_queue_entry, int do_
 		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1;
 
 	/* Send the packet to the output queue */
-	if (unlikely(cvmx_pko_send_packet_finish(priv->port, priv->queue + qos, pko_command, hw_buffer, CVMX_PKO_LOCK_CMD_QUEUE))) {
+	if (unlikely(cvmx_pko_send_packet_finish(priv->port, priv->queue + qos, pko_command, hw_buffer, CVMX_PKO_LOCK_NONE))) {
 		DEBUGPRINT("%s: Failed to send the packet\n", dev->name);
 		dropped = -1;
 	}
-	local_irq_restore(flags);
+	spin_unlock_irqrestore(&(priv->oct_tx_lock), flags);
 
 	if (unlikely(dropped)) {
 		if (do_free)
-- 
1.6.5.2

