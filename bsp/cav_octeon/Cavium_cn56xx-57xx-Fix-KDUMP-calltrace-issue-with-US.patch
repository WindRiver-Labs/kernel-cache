From 9da392e96e688675844e159a8dbdf665c9923519 Mon Sep 17 00:00:00 2001
From: Tian Le <le.tian@windriver.com>
Date: Fri, 25 Feb 2011 10:28:03 +0800
Subject: [PATCH 12/13] Cavium_cn56xx/57xx: Fix KDUMP calltrace issue with USB device connected by closing on-board USB hardware directly.

The calltrace is caused by bash thread scheduling in atomic context.
The 56xx has specific code to shut down the USB ports when kexec is
called so that they can be re-initialized on the way up when the
second kernel is called. The problem here comes from the fact that
when the crash is triggered, panic() is called, and that disables
preemption: at some point later in panic(), crash_kexec() is called to
reboot the board, and that calls the 56xx USB shutdown code, which
ultimately calls schedule through the USB device disconnect methods.

Now don't "unregister/del_device" usb subsystem from system(because
they will cause schedule), and directly shutdown cavium's on-board usb
hardware(even though it's in busy status) to resolve it.

Signed-off-by: Tian Le <le.tian@windriver.com>
---
 drivers/usb/host/octeon-hcd.c |   39 ++++++++++++++++++++++++++++++++++++++-
 simple_exec/cvmx-usb.c        |   21 +++++++++++++++++++++
 2 files changed, 59 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
index ae44811..8f359e9 100644
--- a/drivers/usb/host/octeon-hcd.c
+++ b/drivers/usb/host/octeon-hcd.c
@@ -684,6 +684,29 @@ static int octeon_usb_driver_remove(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_KEXEC
+extern cvmx_usb_status_t cvmx_usb_shutdown_directly(cvmx_usb_state_t *state);
+static int octeon_usb_driver_remove_phy(struct device *dev)
+{
+	int status;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	status = cvmx_usb_shutdown_directly(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (status)
+		DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+
+	kfree(hcd);
+
+	return 0;
+}
+#endif
+
 static struct device_driver octeon_usb_driver = {
 	.name       = "OcteonUSB",
 	.bus        = &platform_bus_type,
@@ -709,11 +732,25 @@ static void __shutdown_usb_ports(void)
 }
 
 #ifdef CONFIG_KEXEC
+static void __shutdown_usb_ports_phy(void)
+{
+	/* shutdown all USB phy ports */
+	int i = 0;
+	for (i = 0; i < MAX_USB_PORTS; i++) {
+		if (pdev_glob[i]) {
+			octeon_usb_driver_remove_phy(&pdev_glob[i]->dev);
+			pdev_glob[i] = NULL;
+		}
+	}
+}
+#endif
+
+#ifdef CONFIG_KEXEC
 void kexec_octeon_register_shutdown_usb_ports(void(*fn)(void));
 void kexec_octeon_unregister_shutdown_usb_ports(void);
 static void __register_for_kexec_shutdown(void)
 {
-	kexec_octeon_register_shutdown_usb_ports(__shutdown_usb_ports);
+	kexec_octeon_register_shutdown_usb_ports(__shutdown_usb_ports_phy);
 }
 static void __unregister_for_kexec_shutdown(void)
 {
diff --git a/simple_exec/cvmx-usb.c b/simple_exec/cvmx-usb.c
index c00fb2b..d2b8149 100644
--- a/simple_exec/cvmx-usb.c
+++ b/simple_exec/cvmx-usb.c
@@ -946,6 +946,27 @@ cvmx_usb_status_t cvmx_usb_shutdown(cvmx_usb_state_t *state)
 EXPORT_SYMBOL(cvmx_usb_shutdown);
 #endif
 
+#ifdef CONFIG_KEXEC
+cvmx_usb_status_t cvmx_usb_shutdown_directly(cvmx_usb_state_t *state)
+{
+    cvmx_usbnx_clk_ctl_t usbn_clk_ctl;
+    cvmx_usb_internal_state_t *usb = (cvmx_usb_internal_state_t*)state;
+
+    /* Disable the clocks and put them in power on reset */
+    usbn_clk_ctl.u64 = __cvmx_usb_read_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index));
+    usbn_clk_ctl.s.enable = 1;
+    usbn_clk_ctl.s.por = 1;
+    usbn_clk_ctl.s.hclk_rst = 1;
+    usbn_clk_ctl.s.prst = 0;
+    usbn_clk_ctl.s.hrst = 0;
+    __cvmx_usb_write_csr64(usb, CVMX_USBNX_CLK_CTL(usb->index),
+                           usbn_clk_ctl.u64);
+    CVMX_USB_RETURN(CVMX_USB_SUCCESS);
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(cvmx_usb_shutdown_directly);
+#endif
+#endif
 
 /**
  * Enable a USB port. After this call succeeds, the USB port is
-- 
1.7.0.4

