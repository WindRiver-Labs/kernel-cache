From 301a7659135ec5d902ece35dd02568a421acee14 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 24 Sep 2009 17:18:19 -0700
Subject: [PATCH] Cavium: I2C support files for Cavium Octeon family BSP

These files support the I2C interface in Cavium's SDK 1.9 BSP. The
current state of these files reflects an ongoing development process,
and as such implies an extensive modification history that is not
cited in detail here. It is worth noting, however, that this
collection represents the work of the following people who were
involved in that history:

David Daney <ddaney@caviumnetworks.com>
Vlad Malov <vlad.malov@caviumnetworks.com>
Phil Staub <Phil.Staub@windriver.com>
Weiwei Wang <weiwei.wang@windriver.com>

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/i2c-octeon_twsi.c     |  182 ++++++++++++++
 arch/mips/cavium-octeon/i2c-octeon_twsi_raw.c |  312 ++++++++++++++++++++++++
 arch/mips/cavium-octeon/i2c-octeon_twsi_raw.h |  148 ++++++++++++
 drivers/i2c/busses/i2c-octeon.c               |  318 +++++++++++++++++++++++++
 4 files changed, 960 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/i2c-octeon_twsi.c
 create mode 100644 arch/mips/cavium-octeon/i2c-octeon_twsi_raw.c
 create mode 100644 arch/mips/cavium-octeon/i2c-octeon_twsi_raw.h
 create mode 100644 drivers/i2c/busses/i2c-octeon.c

diff --git a/arch/mips/cavium-octeon/i2c-octeon_twsi.c b/arch/mips/cavium-octeon/i2c-octeon_twsi.c
new file mode 100644
index 0000000..6ba3a82
--- /dev/null
+++ b/arch/mips/cavium-octeon/i2c-octeon_twsi.c
@@ -0,0 +1,182 @@
+/*
+ * Portions Copyright (C) 2004-2009 Cavium Networks, Inc.
+ * Portions Copyright (c) 2006-2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*
+ *  This file was modified by Cavium Networks Inc to:
+ *   1) Move all HW specific code here
+ *   2) Support multiple on-chip i2c controllers
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <octeon-hal-read-write.h>
+
+#include "cvmx.h"
+#include "i2c-octeon.h"
+
+#ifdef CONFIG_I2C_OCTEON_TWSI_RAW
+#include "i2c-octeon_twsi_raw.h"
+#endif
+
+struct twsi_regs_s {
+	uint64_t twsx_sw_twsi_addr;
+	uint64_t twsx_sw_twsi_ext_addr;
+};
+
+static struct twsi_regs_s twsi_regs[OCT_MAX_IFACES];
+
+int octeon_i2c_num_ifaces(void)
+{
+	/* list chips with 2 twsi interfaces here */
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))
+		return 2;
+
+	/* all others have 1 iface as of today */
+	return 1;
+}
+EXPORT_SYMBOL(octeon_i2c_num_ifaces);
+
+void *octeon_i2c_get_algo_data(int iface)
+{
+	if (iface >= OCT_MAX_IFACES)
+		return NULL;
+
+	twsi_regs[iface].twsx_sw_twsi_addr = CVMX_MIO_TWSX_SW_TWSI(iface);
+	twsi_regs[iface].twsx_sw_twsi_ext_addr =
+	    CVMX_MIO_TWSX_SW_TWSI_EXT(iface);
+
+	return &twsi_regs[iface];
+}
+EXPORT_SYMBOL(octeon_i2c_get_algo_data);
+
+int octeon_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,
+			int combined)
+{
+	uint64_t data = 0;
+	int i;
+	int timeout = 0;
+	cvmx_mio_twsx_sw_twsi_t temp, mio_tws_sw_twsi;
+	cvmx_mio_twsx_sw_twsi_ext_t mio_tws_sw_twsi_ext;
+
+#define OCTEON_MIO_TWS_SW_TWSI_EXT \
+	(((struct twsi_regs_s *)(adap->algo_data))->twsx_sw_twsi_ext_addr)
+#define OCTEON_MIO_TWS_SW_TWSI \
+	(((struct twsi_regs_s *)(adap->algo_data))->twsx_sw_twsi_addr)
+
+#ifdef I2C_OCTEON_DEBUG
+	printk(KERN_DEBUG "addr: 0x%04x, len: %d, flags: 0x%x, buf[0] = %x\n",
+		msg->addr, msg->len, msg->flags, msg->buf[0]);
+#endif
+
+#ifdef CONFIG_I2C_OCTEON_TWSI_RAW
+	if ((msg->len > 8) && (!(msg->flags & I2C_M_TEN)))
+		return octeon_i2c_xfer_msg_raw(adap, msg);
+#endif
+
+	mio_tws_sw_twsi.u64 = 0x0;
+
+	mio_tws_sw_twsi.s.v = 1;
+
+	/* ten bit address op<1> = 1 */
+	if (msg->flags & I2C_M_TEN)
+		mio_tws_sw_twsi.s.op |= 0x2;
+	mio_tws_sw_twsi.s.a = msg->addr & 0x3ff;
+
+	/* check the msg->len  0<=len <8 */
+	if (msg->len > 8) {
+		printk(KERN_ERR "%s %d Error len msg->len %d\n",
+			__FILE__, __LINE__, msg->len);
+		return -1;
+	}
+	/*  size override */
+	mio_tws_sw_twsi.s.sovr = 1;
+	if (msg->len == 0)
+		mio_tws_sw_twsi.s.size = 0;
+	else
+		/* Size: 0 = 1 byte, 1 = 2 bytes, ..., 7 = 8 bytes */
+		mio_tws_sw_twsi.s.size = msg->len - 1;
+
+	if (msg->flags & I2C_M_RD)
+		/* Enable Read bit */
+		mio_tws_sw_twsi.s.r = 1;
+	else {
+		for (i = 0; i <= mio_tws_sw_twsi.s.size; i++) {
+			data = data << 8;
+			data |= msg->buf[i];
+		}
+
+		mio_tws_sw_twsi.s.d = data;
+		mio_tws_sw_twsi_ext.s.d = data >> 32;
+	}
+
+#ifdef I2C_OCTEON_DEBUG
+	if (mio_tws_sw_twsi.s.r == 1)
+		printk(KERN_DEBUG "twsi-read  op: data=%llx %llx len=%d\n",
+		       mio_tws_sw_twsi.u64, mio_tws_sw_twsi_ext.u64, msg->len);
+	else
+		printk(KERN_DEBUG "twsi-write op: data=%llx %llx len=%d\n",
+		       mio_tws_sw_twsi.u64, mio_tws_sw_twsi_ext.u64, msg->len);
+#endif
+
+	cvmx_write_csr(OCTEON_MIO_TWS_SW_TWSI_EXT, mio_tws_sw_twsi_ext.u64);
+	cvmx_write_csr(OCTEON_MIO_TWS_SW_TWSI, mio_tws_sw_twsi.u64);
+
+	/* Poll! wait the transfer complete and timeout (10ms). */
+	do {
+		temp.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+		udelay(1);
+	} while (temp.s.v && (timeout++ < I2C_MAX_TIMEOUT));
+
+	mio_tws_sw_twsi.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+
+	if (timeout >= I2C_MAX_TIMEOUT) {
+		printk(KERN_WARNING "Octeon twsi I2C Timeout!\n");
+		return -EIO;
+	}
+
+	/* transfer ERROR */
+	if (!mio_tws_sw_twsi.s.r)
+		return -EIO;
+
+	if (msg->flags & I2C_M_RD) {
+
+		mio_tws_sw_twsi_ext.u64 =
+		    cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI_EXT);
+		data =
+		    ((uint64_t) mio_tws_sw_twsi_ext.s.
+		     d << 32) | mio_tws_sw_twsi.s.d;
+
+#ifdef I2C_OCTEON_DEBUG
+		printk(KERN_DEBUG "twsi-read result: data=%llx %llx len=%d\n",
+		       mio_tws_sw_twsi.u64, mio_tws_sw_twsi_ext.u64, msg->len);
+#endif
+
+		for (i = mio_tws_sw_twsi.s.size; i >= 0; i--) {
+			msg->buf[i] = data;
+			data = data >> 8;
+		}
+	}
+
+	return msg->len;
+}
+EXPORT_SYMBOL(octeon_i2c_xfer_msg);
+MODULE_LICENSE("GPL");
+
diff --git a/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.c b/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.c
new file mode 100644
index 0000000..62d3a66
--- /dev/null
+++ b/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.c
@@ -0,0 +1,312 @@
+/***********************license start***************
+ * Author: Cavium Networks
+ *
+ * Contact: support@caviumnetworks.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT. See the GNU General Public License for more details.
+ * it under the terms of the GNU General Public License, Version 2, as published
+ * by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Networks for more information
+ ***********************license end**************************************/
+
+/*
+ * octeon TWSI low lewel controller interface. 7-bit addressing implementation
+ */
+
+#include <linux/i2c.h>
+#include <octeon-hal-read-write.h>
+#include "cvmx.h"
+#include "i2c-octeon_twsi_raw.h"
+
+/*
+ * uint8_t cvmx_twsix_read_ctr(int twsi_id, uint8_t reg)
+ * twsi core register read
+ * twsi_id - twsi core index
+ * reg 0 - 8-bit register
+ * returns 8-bit register contetn
+ */
+struct twsi_regs_s {
+	uint64_t twsx_sw_twsi_addr;
+	uint64_t twsx_sw_twsi_ext_addr;
+};
+
+#define OCTEON_MIO_TWS_SW_TWSI \
+	(((struct twsi_regs_s *)(adap->algo_data))->twsx_sw_twsi_addr)
+uint8_t cvmx_twsix_read_ctr(struct i2c_adapter *adap, uint8_t reg)
+{
+	cvmx_mio_twsx_sw_twsi_t sw_twsi_val;
+
+	sw_twsi_val.u64 = 0;
+	sw_twsi_val.s.v = 1;
+	sw_twsi_val.s.op = 6;
+	sw_twsi_val.s.eop_ia = reg;
+	sw_twsi_val.s.r = 1;
+	cvmx_write_csr(OCTEON_MIO_TWS_SW_TWSI, sw_twsi_val.u64);
+	sw_twsi_val.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+	while (sw_twsi_val.s.v)
+		sw_twsi_val.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+
+	return sw_twsi_val.s.d;
+}
+
+/*
+ * uint8_t cvmx_twsix_write_ctr(int twsi_id, uint8_t reg, uint8_t data)
+ *
+ * twsi core register write
+ * twsi_id - twsi core index
+ * reg 0 - 8-bit register
+ * data - data to write
+ * returns 0;
+ */
+
+int cvmx_twsix_write_ctr(struct i2c_adapter *adap, uint8_t reg, uint8_t data)
+{
+	cvmx_mio_twsx_sw_twsi_t sw_twsi_val;
+
+	sw_twsi_val.u64 = 0;
+	sw_twsi_val.s.v = 1;
+	sw_twsi_val.s.op = 6;
+	sw_twsi_val.s.eop_ia = reg;
+	sw_twsi_val.s.d = data;
+	cvmx_write_csr(OCTEON_MIO_TWS_SW_TWSI, sw_twsi_val.u64);
+	sw_twsi_val.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+	while (sw_twsi_val.s.v)
+		sw_twsi_val.u64 = cvmx_read_csr(OCTEON_MIO_TWS_SW_TWSI);
+
+	return 0;
+}
+
+/*
+ * cvmx_twsi_wait_iflg(int twsi_id)
+ * cvmx_twsi_wait_stop(int twsi_id)
+ *
+ * Helper functions - wait for event flag.
+ *
+ * TWSI_WAIT loop count must be defined large enough to allow on-wire
+ * transaction to finish - that is about 20 twsi clocks
+ */
+#define TWSI_WAIT 10000000
+static inline int cvmx_twsi_wait_iflg(struct i2c_adapter *adap)
+{
+	union octeon_twsi_ctl_t ctl_reg;
+	int wait = TWSI_WAIT;
+	do {
+		ctl_reg.u8 = cvmx_twsix_read_ctr(adap, TWSI_CTL_REG);
+	} while ((ctl_reg.s.iflg == 0) && (wait-- > 0));
+	if (wait == 0)
+		return -1;
+	return 0;
+}
+
+static inline int cvmx_twsi_wait_stop(struct i2c_adapter *adap)
+{
+	union octeon_twsi_ctl_t ctl_reg;
+	int wait = TWSI_WAIT;
+	do {
+		ctl_reg.u8 = cvmx_twsix_read_ctr(adap, TWSI_CTL_REG);
+	} while ((ctl_reg.s.stp == 1) && (wait-- > 0));
+	if (wait == 0)
+		return -1;
+	return 0;
+}
+
+/*
+ * uint8_t octeon_twsi_read_byte(int twsi_id, uint8_t* byte, int ack)
+ * uint8_t octeon_twsi_write_byte(int twsi_id, uint8_t byte)
+ *
+ * helper functions - read or write byte to data reg and reads the TWSI
+ * core status
+ */
+static uint8_t octeon_twsi_read_byte(struct i2c_adapter *adap, uint8_t *byte,
+				     int ack)
+{
+	union octeon_twsi_ctl_t ctl_reg;
+	union octeon_twsi_data_t data;
+	union octeon_twsi_stat_t stat;
+
+	/* clear interrupt flag, set aak for requested ACK signal level */
+	ctl_reg.u8 = 0;
+	ctl_reg.s.aak = (ack == 0) ? 0 : 1;
+	ctl_reg.s.enab = 1;
+	cvmx_twsix_write_ctr(adap, TWSI_CTL_REG, ctl_reg.u8);
+
+	/* wait for  twsi_ctl[iflg] to be set */
+	if (cvmx_twsi_wait_iflg(adap))
+		goto error;
+
+	/* read the byte */
+	data.u8 = cvmx_twsix_read_ctr(adap, TWSI_DATA_REG);
+	*byte = data.s.data;
+error:
+	/* read the status */
+	stat.u8 = cvmx_twsix_read_ctr(adap, TWSI_STAT_REG);
+	return stat.s.stat;
+}
+
+static uint8_t octeon_twsi_write_byte(struct i2c_adapter *adap, uint8_t byte)
+{
+	union octeon_twsi_ctl_t ctl_reg;
+	union octeon_twsi_data_t data;
+	union octeon_twsi_stat_t stat;
+
+	/* tx data byte - write to twsi_data reg, then clear twsi_ctl[iflg] */
+	data.s.data = byte;
+	cvmx_twsix_write_ctr(adap, TWSI_DATA_REG, data.u8);
+
+	ctl_reg.u8 = cvmx_twsix_read_ctr(adap, TWSI_CTL_REG);
+	ctl_reg.s.iflg = 0;
+	cvmx_twsix_write_ctr(adap, TWSI_CTL_REG, ctl_reg.u8);
+
+	/* wait for  twsi_ctl[iflg] to be set */
+	if (cvmx_twsi_wait_iflg(adap))
+		goto error;
+error:
+	/* read the status */
+	stat.u8 = cvmx_twsix_read_ctr(adap, TWSI_STAT_REG);
+	return stat.s.stat;
+}
+
+MODULE_LICENSE("GPL");
+
+/*
+ * int octeon_i2c_xfer_msg_raw(struct i2c_msg *msg)
+ *
+ * Send (read or write) a message with 7-bit address device over direct
+ * control of TWSI core, bypassind HLC. Will try to finish the transaction
+ * on failure, so core state expected to be idle with HLC enabled on exit.
+ * 10-bit addressing not implemented at that time.
+ *
+ * adap - i2c adapter
+ * msg - message to transfer
+ * returns 0 on success, TWSI core state on error. Will try to finish the
+ * transaction on failure, so core state expected to be idle
+ */
+int octeon_i2c_xfer_msg_raw(struct i2c_adapter *adap, struct i2c_msg *msg)
+{
+	int i = 0;
+	union octeon_twsi_ctl_t ctl_reg;
+	union octeon_twsi_addr_t addr;
+	union octeon_twsi_stat_t stat;
+	int is_read = msg->flags & I2C_M_RD;
+	int ret = 0;
+
+	/* fail if 10-bit address transaction requested */
+	if (msg->flags & I2C_M_TEN)
+		return -EINVAL;
+
+	/* check the core state, quit if not idle */
+	stat.u8 = cvmx_twsix_read_ctr(adap, TWSI_STAT_REG);
+	if (stat.s.stat != TWSI_IDLE) {
+		msg->len = 0;
+		return stat.s.stat;
+	}
+
+	/* first send start - set twsi_ctl[sta] to 1 */
+	ctl_reg.u8 = 0;
+	ctl_reg.s.enab = 1;
+	ctl_reg.s.sta = 1;
+	ctl_reg.s.iflg = 0;
+	cvmx_twsix_write_ctr(adap, TWSI_CTL_REG, ctl_reg.u8);
+	/* wait for  twsi_ctl[iflg] to be set */
+	if (cvmx_twsi_wait_iflg(adap))
+		goto stop;
+
+	/* Write 7-bit addr to twsi_data; set read bit */
+	addr.s.slave_addr7 = msg->addr;
+	if (is_read)
+		addr.s.r = 1;
+	else
+		addr.s.r = 0;
+	stat.s.stat = octeon_twsi_write_byte(adap, addr.u8);
+
+	/* Data read loop */
+	if (is_read) {
+		/* any status but ACK_RXED means failure
+		   we try to send stop and go idle */
+		if (!(stat.s.stat == TWSI_ADDR_R_TX_ACK_RXED)) {
+			ret = stat.s.stat;
+			msg->len = 0;
+			goto stop;
+		}
+		/* We read data from the buffer and send ACK back.
+		   The last byte we read with negative ACK */
+		for (i = 0; i < msg->len - 1; i++) {
+			stat.s.stat =
+			    octeon_twsi_read_byte(adap, &(msg->buf[i]), 1);
+			if (stat.s.stat != TWSI_DATA_RX_ACK_TXED)
+				goto stop;
+		}
+		/* last read we send negACK */
+		stat.s.stat = octeon_twsi_read_byte(adap, &(msg->buf[i]), 0);
+		if (stat.s.stat != TWSI_DATA_RX_NACK_TXED)
+			return stat.s.stat;
+	}
+
+	/* read loop */
+	/* Data write loop */
+	else {
+		/* any status but ACK_RXED means failure
+		   we try to send stop and go idle */
+		if (stat.s.stat != TWSI_ADDR_W_TX_ACK_RXED) {
+			ret = stat.s.stat;
+			msg->len = 0;
+			goto stop;
+		}
+		/* We write data to the buffer and check for ACK. */
+		for (i = 0; i < msg->len; i++) {
+			stat.s.stat = octeon_twsi_write_byte(adap, msg->buf[i]);
+			if (stat.s.stat == TWSI_DATA_TX_NACK_RXED) {
+				/* Negative ACK means slave can not RX more */
+				msg->len = i - 1;
+				goto stop;
+			} else if (stat.s.stat != TWSI_DATA_TX_ACK_RXED) {
+				/* lost arbitration? try to send stop and go
+				   idle. This byte likely was not written */
+				msg->len = (i - 2) > 0 ? (i - 2) : 0;
+				goto stop;
+			}
+		}
+	}			/* write loop */
+
+stop:
+	ctl_reg.u8 = cvmx_twsix_read_ctr(adap, TWSI_CTL_REG);
+	ctl_reg.s.stp = 1;
+	ctl_reg.s.iflg = 0;
+	cvmx_twsix_write_ctr(adap, TWSI_CTL_REG, ctl_reg.u8);
+	/* wait for  twsi_ctl[stp] to clear */
+	cvmx_twsi_wait_stop(adap);
+
+	/* Leave TWSI core with HLC eabled */
+	{
+		ctl_reg.u8 = 0;
+		ctl_reg.s.ce = 1;
+		ctl_reg.s.enab = 1;
+		ctl_reg.s.aak = 1;
+		cvmx_twsix_write_ctr(adap, TWSI_CTL_REG, ctl_reg.u8);
+	}
+#ifdef TWSI_DEBUG
+	if (ret)
+		printk(KERN_DEBUG "failed low level TWSI xfer, controller \
+		       state %02x\n", ret);
+#endif
+	if (ret)
+		ret = -EIO;
+	return ret;
+}
diff --git a/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.h b/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.h
new file mode 100644
index 0000000..42b1530
--- /dev/null
+++ b/arch/mips/cavium-octeon/i2c-octeon_twsi_raw.h
@@ -0,0 +1,148 @@
+/***********************license start***************
+ * Author: Cavium Networks
+ *
+ * Contact: support@caviumnetworks.com
+ * This file is part of the OCTEON SDK
+ *
+ * Copyright (c) 2008 Cavium Networks
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, Version 2, as published
+ * by the Free Software Foundation.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
+ * NONINFRINGEMENT. See the GNU General Public License for more details.
+ * it under the terms of the GNU General Public License, Version 2, as published
+ * by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this file; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ * or visit http://www.gnu.org/licenses/.
+ *
+ * This file may also be available under a different license from Cavium.
+ * Contact Cavium Networks for more information
+ ***********************license end**************************************/
+
+#ifndef __CVMX_TWSI_RAW_H__
+#define __CVMX_TWSI_RAW_H__
+
+/* Addresses for twsi 8-bit registers. Gets written to EOP_IA field of
+   MIO_TWS_SW_TWSI reg when OP = 6 and SLONLY =0 */
+#define TWSI_SLAVE_ADD_REG      0
+#define TWSI_DATA_REG           1
+#define TWSI_CTL_REG            2
+#define TWSI_STAT_REG	        3	/* read only */
+#define TWSI_CLKCTL_REG 	3	/* write only */
+#define TWSI_SLAVE_EXTADD_REG   4
+#define TWSI_RST_REG            7
+
+/* twsi core slave address reg */
+union octeon_twsi_slave_add_t {
+	uint8_t u8;
+	struct {
+		uint8_t slave_addr7:7;
+		uint8_t gce:1;
+
+	} s;
+};
+
+/* twsi core 10-bit slave address reg */
+union octeon_twsi_slave_extadd_t {
+	uint8_t u8;
+	struct {
+		uint8_t slave_addr8:8;
+	} s;
+};
+
+/* twsi core control register */
+union octeon_twsi_ctl_t {
+	uint8_t u8;
+	struct {
+		uint8_t ce:1;	/* enable HLC */
+		uint8_t enab:1;	/* bus enable */
+		uint8_t sta:1;	/* start request */
+		uint8_t stp:1;	/* stop request */
+		uint8_t iflg:1;	/* interrupt flag
+				   request completed (1) start new (0) */
+		uint8_t aak:1;	/* assert ack (1)
+				   neg ack at end of Rx sequence */
+		uint8_t rsv:2;	/* not used */
+	} s;
+};
+
+/* clock dividers register */
+union octeon_twsi_clkctl_t {
+	uint8_t u8;
+	struct {
+		uint8_t m_divider:4;
+		uint8_t n_divider:3;
+	} s;
+};
+
+/* address of the remote slave + r/w bit */
+union octeon_twsi_addr_t {
+	uint8_t u8;
+	struct {
+		uint8_t slave_addr7:7;
+		uint8_t r:1;	/* read (1) write (0) bit */
+	} s;
+};
+
+/* core state reg */
+union octeon_twsi_stat_t {
+	uint8_t u8;
+	struct {
+		uint8_t stat:8;
+	} s;
+};
+
+ /* data byte reg */
+union octeon_twsi_data_t {
+	uint8_t u8;
+	struct {
+		uint8_t data:8;
+	} s;
+};
+
+/* twsi core states as reported in twsi core stat register */
+#define TWSI_BUS_ERROR 			0x00
+#define TWSI_START_TXED 		0x08
+#define TWSI_ADDR_W_TX_ACK_RXED 	0x18
+#define TWSI_ADDR_W_TX_NACK_RXED 	0x20
+
+#define TWSI_DATA_TX_ACK_RXED 		0x28
+#define TWSI_DATA_TX_NACK_RXED 	0x30
+#define TWSI_ARB_LOST			0x38
+#define TWSI_ADDR_R_TX_ACK_RXED		0x40
+
+#define TWSI_ADDR_R_TX_NACK_RXED	0x48
+#define TWSI_DATA_RX_ACK_TXED		0x50
+#define TWSI_DATA_RX_NACK_TXED		0x58
+#define TWSI_SLAVE_ADDR_RX_ACK_TXED	0x60
+
+#define TWSI_ARB_LOST_SLAVE_ADDR_RX	0x68
+#define TWSI_GEN_ADDR_RXED_ACK_TXED	0x70
+#define TWSI_ARB_LOST_GEN_ADDR_RXED	0x78
+#define TWSI_SLAVE_DATA_RX_ACK_TXED	0x80
+
+#define TWSI_SLAVE_DATA_RX_NACK_TXED	0x88
+#define TWSI_GEN_DATA_RX_ACK_TXED	0x90
+#define TWSI_GEN_DATA_RX_NACK_TXED	0x98
+#define TWSI_SLAVE_STOP_OR_START_RXED	0xa0
+
+#define TWSI_SLAVE_ADDR_R_RX_ACK_TXED	0xa8
+#define TWSI_ARB_LOST_SLAVE_ADDR_R_RX_ACK_TXED 0xb0
+#define TWSI_SLAVE_DATA_TX_ACK_RXED	0xb8
+#define TWSI_SLAVE_DATA_TX_NACK_RXED	0xc0
+
+#define TWSI_SLAVE_LAST_DATA_TX_ACK_RXED 0xc8
+#define TWSI_SECOND_ADDR_W_TX_ACK_RXED	0xd0
+#define TWSI_SECOND_ADDR_W_TX_NACK_RXED	0xd8
+#define TWSI_IDLE			0xf8
+
+int octeon_i2c_xfer_msg_raw(struct i2c_adapter *adap, struct i2c_msg *msg);
+
+#endif
diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
new file mode 100644
index 0000000..c46f431
--- /dev/null
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -0,0 +1,318 @@
+/*
+ * Portions Copyright (C) 2004-2009 Cavium Networks, Inc.
+ * Portions Copyright (c) 2006-2007 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*
+ *  This file was modified by Cavium Networks Inc to:
+ *   1) Move direct HW calls to arch directory
+ *   2) Support multiple on-chip i2c controllers
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/version.h>
+#include <linux/i2c.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+
+#include <linux/uaccess.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+#include "i2c-octeon.h"		/* HW specific calls */
+
+/* #define       I2C_OCTEON_DEBUG */
+
+#ifdef I2C_OCTEON_DEBUG
+static int i2c_debug;
+#define DEB0(format, arg...)	\
+	printk(KERN_DEBUG MODULE_NAME "DEBUG: " format "\n", ## arg)
+#define DEB1(format, arg...)	\
+	if (i2c_debug >= 1) {	\
+		printk(KERN_DEBUG MODULE_NAME "DEBUG: " format "\n", ## arg);\
+	}
+#define DEB2(format, arg...)	\
+	if (i2c_debug >= 2) {	\
+		printk(KERN_DEBUG MODULE_NAME "DEBUG: " format "\n", ## arg);\
+	}
+#define DEB3(format, arg...)	\
+	if (i2c_debug >= 3) {	\
+		printk(KERN_DEBUG MODULE_NAME "DEBUG: " format "\n", ## arg);\
+	}
+#define DEB9(format, arg...)	\
+/* debug the protocol by showing transferred bits */	\
+	if (i2c_debug >= 9) {	\
+		printk(KERN_DEBUG MODULE_NAME "DEBUG: " format "\n", ## arg);\
+	}
+#else
+#define DEB0(fmt, args...)
+#define DEB1(fmt, args...)
+#define DEB2(fmt, args...)
+#define DEB3(fmt, args...)
+#define DEB9(fmt, args...)
+#endif
+
+#define MODULE_NAME "OCTEON I2C"
+
+static int i2c_scan;
+
+static struct i2c_board_info ds1307_i2c_devices = {
+	I2C_BOARD_INFO("ds1307", 0x68),
+};
+static struct i2c_client *ds1307_i2c_client;
+
+/* invalid address will return 1; TEN bit addr is valid */
+static inline int i2c_invalid_address(const struct i2c_msg *p)
+{
+	return (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN)
+				     && (p->addr > 0x7f));
+}
+
+static int octeon_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+			   int num)
+{
+	int i;
+	int r = 0;
+
+	DEB1("msgs: %d\n", num);
+
+	if (unlikely(!num)) {
+		printk(KERN_INFO "num is zero!!\n");
+		return 0;
+	}
+
+	if (unlikely(i2c_invalid_address(&msgs[0]))) {
+		printk(KERN_INFO "invalid address 0x%03x (%d-bit)\n",
+		       msgs[0].addr, msgs[0].flags & I2C_M_TEN ? 10 : 7);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num; ++i) {
+		DEB2("msg: %d, addr: 0x%04x, len: %d, flags: 0x%x\n", i,
+		     msgs[i].addr, msgs[i].len, msgs[i].flags);
+
+		r = octeon_i2c_xfer_msg(adap, &msgs[i], 0);
+
+		DEB2("r: %d\n", r);
+
+		if (r != msgs[i].len)
+			break;
+
+	}
+
+	DEB1("r: %d msgs: %d", r, num);
+
+	return (r < 0) ? r : num;
+}
+
+static int octeon_i2c_remove(struct device *dev)
+{
+	/* Nothing */
+	return 0;
+}
+
+static void octeon_i2c_device_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+/* should contain I2C_FUNC_SMBUS_BYTE_DATA */
+static u32 octeon_i2c_func(struct i2c_adapter *adap)
+{
+	/* should be check */
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm octeon_i2c_algo = {
+	.master_xfer = octeon_i2c_xfer,
+	.smbus_xfer = NULL,	/* emulate by master_xfer */
+	.functionality = octeon_i2c_func,
+};
+
+#if (OCT_MAX_IFACES > 2)
+#error "OCT_MAX_IFACES increased, need to fix a driver interface"
+#endif
+static struct i2c_adapter octeon_i2c_adap0 = {
+	.owner = THIS_MODULE,
+	.class = I2C_CLASS_HWMON,//I2C_CLASS_ALL
+	.name = "octeon twsi",
+	.algo = &octeon_i2c_algo,
+	.nr   = 0,
+	.algo_data = NULL,
+	.client_register = NULL,
+	.client_unregister = NULL,
+};
+
+static struct i2c_adapter octeon_i2c_adap1 = {
+	.owner = THIS_MODULE,
+	.class = I2C_CLASS_HWMON,//I2C_CLASS_ALL
+	.name = "octeon twsi",
+	.algo = &octeon_i2c_algo,
+	.nr   = 1,
+	.algo_data = NULL,
+	.client_register = NULL,
+	.client_unregister = NULL,
+};
+
+static struct i2c_adapter *octeon_i2c_adap[OCT_MAX_IFACES] = {
+	&octeon_i2c_adap0,
+	&octeon_i2c_adap1,
+};
+
+static struct device_driver octeon_i2c_driver = {
+	.name = "octeon_i2c",
+	.bus = &platform_bus_type,
+	.remove = octeon_i2c_remove,
+};
+
+static struct platform_device octeon_i2c_device = {
+	.name = "i2c",
+	.id = -1,
+	.dev = {
+		.driver = &octeon_i2c_driver,
+		.release = octeon_i2c_device_release,
+		},
+};
+
+static void __init octeon_i2c_chip_init(void)
+{
+	/* Nothing */
+}
+
+static int octeon_i2c_scan_bus(struct i2c_adapter *adap)
+{
+	int found = 0;
+	int i;
+	struct i2c_msg msg;
+	char data[1];
+
+	printk(KERN_INFO " ** scanning for active I2C devices on the bus...");
+
+	for (i = 1; i < 0x7f; i++) {
+
+		msg.addr = i;
+		msg.buf = data;
+		msg.len = 0;
+		msg.flags = I2C_M_RD;
+
+		if (octeon_i2c_xfer(adap, &msg, 1) > 0) {
+			printk(KERN_INFO "I2C device 0x%02x found\n", i);
+			found++;
+		}
+	}
+
+	if (!found)
+		printk(KERN_INFO "found nothing\n");
+
+	return found;
+}
+
+static int octeon_check_ds1307_on_bus(struct i2c_adapter *adap)
+{
+	struct i2c_msg msg;
+	char data[1];
+	msg.addr = 0x68;
+	msg.buf = data;
+	msg.len = 0;
+	msg.flags = I2C_M_RD;
+	if (octeon_i2c_xfer(adap, &msg, 1) > 0)
+		return 1;
+	else
+		return 0;
+}
+
+static int __init octeon_i2c_init(void)
+{
+	int r, i;
+
+	for (i = 0; i < octeon_i2c_num_ifaces(); i++) {
+		/* init algo data first  then add adapter */
+		octeon_i2c_adap[i]->algo_data = octeon_i2c_get_algo_data(i);
+		r = i2c_add_numbered_adapter(octeon_i2c_adap[i]);
+
+		if (r) {
+			printk(KERN_ERR "failed to add adapter %d", i);
+			if (i == 0)
+				goto do_release_region;	/*do_free_irq;*/
+			else
+				break;
+		}
+	}
+
+	octeon_i2c_chip_init();
+
+	if (i2c_scan)
+		for (i = 0; i < octeon_i2c_num_ifaces(); i++) {
+			printk(KERN_INFO "scanning bus %d\n", i);
+			octeon_i2c_scan_bus(octeon_i2c_adap[i]);
+		}
+
+	/* ds1307 device register */
+	if (octeon_check_ds1307_on_bus(octeon_i2c_adap[0])) {
+		ds1307_i2c_client = i2c_new_device(octeon_i2c_adap[0],
+						   &ds1307_i2c_devices);
+		if (ds1307_i2c_client == NULL)
+			printk(KERN_ERR "ds1307 register failed \n");
+	}
+
+	if (driver_register(&octeon_i2c_driver) != 0)
+		printk(KERN_ERR "Driver register failed for octeon_i2c\n");
+
+	if (platform_device_register(&octeon_i2c_device) != 0) {
+		printk(KERN_ERR "Device register failed for i2c\n");
+		driver_unregister(&octeon_i2c_driver);
+	}
+
+	return 0;
+
+do_release_region:
+/*	release_region(OCTEON_I2C_BASE, OCTEON_I2C_IOSIZE); */
+	return 0;
+
+}
+
+static void __exit octeon_i2c_exit(void)
+{
+	int i;
+
+	/* unregister i2c device ds1307 */
+	if(ds1307_i2c_client != NULL)
+		i2c_unregister_device(ds1307_i2c_client);
+
+	for (i = 0; i < octeon_i2c_num_ifaces(); i++)
+		i2c_del_adapter(octeon_i2c_adap[i]);
+/*	release_region(OCTEON_I2C_BASE, OCTEON_I2C_IOSIZE); */
+	driver_unregister(&octeon_i2c_driver);
+	platform_device_unregister(&octeon_i2c_device);
+}
+
+MODULE_AUTHOR("RichardXY_huang@asus.com.cn");
+MODULE_DESCRIPTION("Cavium Octeon I2C bus adapter");
+MODULE_DESCRIPTION("Octeon i2c driver");
+MODULE_LICENSE("GPL");
+
+module_init(octeon_i2c_init);
+module_exit(octeon_i2c_exit);
-- 
1.5.5.1

