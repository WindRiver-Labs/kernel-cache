From 11c58632847ebdfe5aa295cd9cc78954ddd3858c Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Tue, 16 Mar 2010 15:23:53 +0800
Subject: [PATCH] MIPS: Octeon: Enable USER IO/MEM support

Allows user applications to directly access the Octeon hardware
IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
performance networking applications to run in user space with minimal
performance penalties. This also means a user application can bring
down the entire system. Only use this option on embedded devices
where all user applications are strictly controlled.

Allows user applications to use XKPHYS addresses directly to memory.
This allows user space direct access to shared memory not in use by
Linux. This memory is suitable for use with the Octeon hardware.
Cavium simple executive applications also share this memory. Since
this bypass all of the Linux memory protection, only use this option
on embedded devices where all user applications are strictly
controlled.

This option dynamically enable/disable with sysmips syscall,
by a process with root privilege. Without root privilege you can only
remove access.

Original patch taken from Cavium SDK 1.9.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig     |   56 ++++++++++++++++
 arch/mips/cavium-octeon/Makefile    |    2 +-
 arch/mips/cavium-octeon/setup.c     |    8 ++
 arch/mips/cavium-octeon/userio.c    |  121 +++++++++++++++++++++++++++++++++++
 arch/mips/include/asm/processor.h   |    8 ++
 arch/mips/include/asm/thread_info.h |    4 +
 arch/mips/kernel/ptrace.c           |   52 +++++++++++++++
 arch/mips/kernel/syscall.c          |   13 ++++
 8 files changed, 263 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/userio.c

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 55ac7b6..bc81840 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -121,6 +121,62 @@ config CAVIUM_OCTEON_LOCK_L2_MEMCPY
 	help
 	  Lock the kernel's implementation of memcpy() into L2.
 
+choice
+	prompt "Allow User space to access hardware IO directly"
+	default CAVIUM_OCTEON_USER_IO
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+
+config CAVIUM_OCTEON_USER_IO
+	bool "Allowed"
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	help
+	  Allows user applications to directly access the Octeon hardware
+	  IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
+	  performance networking applications to run in user space with minimal
+	  performance penalties. This also means a user application can bring
+	  down the entire system. Only use this option on embedded devices
+	  where all user applications are strictly controlled.
+
+config CAVIUM_OCTEON_USER_IO_PER_PROCESS
+	bool "Per process"
+	help
+	  Allows user applications to use XKPHYS addresses directly to IO.
+	  This option dynamically enable/disable with sysmips syscall,
+	  by a process with root privilege. Without root privilege you can only remove access.
+
+config CAVIUM_OCTEON_USER_IO_DISABLED
+	bool "Disabled"
+
+endchoice
+
+choice
+	prompt "Allow User space to access memory directly"
+	default OCTEON_USER_MEM
+	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+
+config CAVIUM_OCTEON_USER_MEM
+	bool "Allowed"
+	help
+	  Allows user applications to use XKPHYS addresses directly to memory.
+	  This allows user space direct access to shared memory not in use by
+	  Linux. This memory is suitable for use with the Octeon hardware.
+	  Cavium simple executive applications also share this memory. Since
+	  this bypass all of the Linux memory protection, only use this option
+	  on embedded devices where all user applications are strictly
+	  controlled.
+
+config CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+	bool "Per process"
+	help
+	  Allows user applications to use XKPHYS addresses directly to memory.
+	  This option dynamically enable/disable with sysmips syscall,
+	  by a process with root privilege. Without root privilege you can only remove access.
+
+config CAVIUM_OCTEON_USER_MEM_DISABLED
+	bool "Disabled"
+
+endchoice
+
 config ARCH_SPARSEMEM_ENABLE
 	def_bool y
 	select SPARSEMEM_STATIC
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index 3e98763..823a68f 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -11,7 +11,7 @@
 
 obj-y := cpu.o setup.o serial.o octeon-platform.o octeon-irq.o csrc-octeon.o
 obj-y += dma-octeon.o flash_setup.o
-obj-y += octeon-memcpy.o
+obj-y += octeon-memcpy.o userio.o
 
 obj-$(CONFIG_SMP)                     += smp.o
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 9a06fa9..c2ad541 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -310,7 +310,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==0 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
+	cvmmemctl.s.xkmemenau = 1;
+#else
 	cvmmemctl.s.xkmemenau = 0;
+#endif
 
 	/* R/W If set (and SX set), supervisor-level loads/stores can
 	 * use XKPHYS addresses with VA<48>==1 */
@@ -318,7 +322,11 @@ void octeon_user_io_init(void)
 
 	/* R/W If set (and UX set), user-level loads/stores can use
 	 * XKPHYS addresses with VA<48>==1 */
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO
+	cvmmemctl.s.xkioenau = 1;
+#else
 	cvmmemctl.s.xkioenau = 0;
+#endif
 
 	/* R/W If set, all stores act as SYNCW (NOMERGE must be set
 	 * when this is set) RW, reset to 0. */
diff --git a/arch/mips/cavium-octeon/userio.c b/arch/mips/cavium-octeon/userio.c
new file mode 100644
index 0000000..4922911
--- /dev/null
+++ b/arch/mips/cavium-octeon/userio.c
@@ -0,0 +1,121 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004-2007 Cavium Networks
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>	/* for memset */
+#include <linux/console.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/time.h>
+#include <linux/serial_core.h>
+#include <linux/reboot.h>
+#include <linux/io.h>
+
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/bootinfo.h>
+#include <asm/octeon/octeon.h>
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+
+void cavium_prepare_arch_switch(struct task_struct *next)
+{
+	struct task_struct *group_leader = next->group_leader;
+	union octeon_cvmemctl cvmmemctl;
+	cvmmemctl.u64 = read_c0_cvmmemctl();
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	cvmmemctl.s.xkmemenau = test_tsk_thread_flag(group_leader,
+						     TIF_XKPHYS_MEM_EN) ? 1 : 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	cvmmemctl.s.xkioenau = test_tsk_thread_flag(group_leader,
+						    TIF_XKPHYS_IO_EN) ? 1 : 0;
+#endif
+	write_c0_cvmmemctl(cvmmemctl.u64);
+}
+
+static struct task_struct *xkphys_get_task(pid_t pid)
+{
+	struct task_struct *task, *group_leader;
+
+	read_lock(&tasklist_lock);
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		read_unlock(&tasklist_lock);
+		return NULL;
+	}
+	group_leader = task->group_leader;
+	get_task_struct(group_leader);
+
+	read_unlock(&tasklist_lock);
+	return group_leader;
+}
+
+int xkphys_usermem_read(long pid)
+{
+	struct task_struct *task;
+	int io, mem;
+
+	task = xkphys_get_task(pid);
+	if (!task)
+		return -ESRCH;
+	io = test_tsk_thread_flag(task, TIF_XKPHYS_IO_EN);
+	mem = test_tsk_thread_flag(task, TIF_XKPHYS_MEM_EN);
+	put_task_struct(task);
+	return (io ? 2 : 0) | (mem ? 1 : 0);
+}
+
+int xkphys_usermem_write(long pid, int value)
+{
+	struct task_struct *task, *group_leader;
+
+	task = xkphys_get_task(pid);
+	group_leader = task->group_leader;
+
+	if (!task)
+		return -ESRCH;
+
+	if (task->uid != current->euid &&
+			task->euid != current->euid &&
+			!(capable(CAP_SYS_RAWIO) || value == 0)) {
+		put_task_struct(task);
+		return -EPERM;
+	}
+
+	if (value & 1)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+
+	if (value & 2)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+
+	preempt_disable();
+
+	/* If we are adjusting ourselves, make the change effective
+	   immediatly.  */
+	if (group_leader == current->group_leader)
+		cavium_prepare_arch_switch(current);
+
+	preempt_enable();
+
+	put_task_struct(task);
+	return 0;
+}
+#endif
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index ab38791..f17bf72 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -357,4 +357,12 @@ static inline void prefetch(const void *addr)
 
 #endif
 
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+#define prepare_arch_switch(next)  cavium_prepare_arch_switch(next)
+extern void cavium_prepare_arch_switch(struct task_struct *next);
+extern int xkphys_usermem_read(long pid);
+extern int xkphys_usermem_write(long pid, int value);
+#endif
+
 #endif /* _ASM_PROCESSOR_H */
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index aac9833..4e8792e 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -120,6 +120,8 @@ register struct thread_info *__current_thread_info __asm__("$28");
 #define TIF_32BIT_ADDR		23	/* 32-bit address space (o32/n32) */
 #define TIF_FPUBOUND		24	/* thread bound to FPU-full CPU set */
 #define TIF_LOAD_WATCH		25	/* If set, load watch registers */
+#define TIF_XKPHYS_MEM_EN       26
+#define TIF_XKPHYS_IO_EN        27
 #define TIF_KERNEL_TRACE	30	/* kernel trace active */
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
@@ -139,6 +141,8 @@ register struct thread_info *__current_thread_info __asm__("$28");
 #define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
 #define _TIF_USEDFPU		(1<<TIF_USEDFPU)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+#define _TIF_XKPHYS_MEM_EN      (1<<TIF_XKPHYS_MEM_EN)
+#define _TIF_XKPHYS_IO_EN       (1<<TIF_XKPHYS_IO_EN)
 #define _TIF_FREEZE		(1<<TIF_FREEZE)
 #define _TIF_FIXADE		(1<<TIF_FIXADE)
 #define _TIF_LOGADE		(1<<TIF_LOGADE)
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 6c190b6..c9dbe2b 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -43,6 +43,11 @@
 DEFINE_TRACE(syscall_entry);
 DEFINE_TRACE(syscall_exit);
 
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(CONFIG_64BIT)
+#include <asm/octeon/octeon.h>
+extern struct cvmx_bootinfo *octeon_bootinfo;
+#endif
+
 /*
  * Called by kernel/ptrace.c when detaching..
  *
@@ -267,6 +272,53 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
 	case PTRACE_PEEKDATA:
+#if !defined(CAVIUM_OCTEON_USER_IO_DISABLED) && defined(CONFIG_64BIT)
+		/* check whether its a XKPHYS IO addr (we only allow the 0x80xx.. alias) */
+		if (((unsigned long)addr >> 48) == 0x8001) {
+#ifdef CAVIUM_OCTEON_USER_IO_PER_PROCESS
+			struct task_struct *group_leader;
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader,
+							TIF_XKPHYS_IO_EN))
+				break;
+#endif
+			ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
+			break;
+		}
+#endif /* !defined(CAVIUM_OCTEON_USER_IO_DISABLED) */
+#if !defined(CAVIUM_OCTEON_USER_MEM_DISABLED)
+		/* check whether its a XKPHYS MEM addr */
+		if (((unsigned long)addr >> 48) == 0x8000) {
+			unsigned long tmp;
+#ifdef CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+			struct task_struct *group_leader;
+			group_leader = child->group_leader;
+			if (!test_tsk_thread_flag(group_leader,
+							TIF_XKPHYS_MEM_EN))
+				break;
+#endif
+			ret = -EIO;
+			/* ensure that task is 64 bit */
+			if (test_tsk_thread_flag(child, TIF_32BIT_ADDR))
+				break;
+
+			/* extract phy addr from XKPHYS alias */
+			tmp = (unsigned long)addr - 0x8000000000000000ull;
+
+			/* check for boot-bus addr range */
+			if ((tmp >= 0x10000000) && (tmp < 0x20000000))
+				break;
+			/* this is for the dram_size comparison below */
+			if ((tmp >= 0x410000000ull) && (tmp < 0x420000000ull))
+				tmp -= 0x400000000ull;
+
+			/* verify that "addr" is within installed dram */
+			if (tmp <= ((octeon_bootinfo->dram_size<<20) - sizeof(tmp)))  {
+				ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
+			}
+			break;
+		}
+#endif /*  defined(CONFIG_CAVIUM_OCTEON_USER_MEM) */
 		ret = generic_ptrace_peekdata(child, addr, data);
 		break;
 
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index c49beda..cf3c9d0 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -45,6 +45,11 @@
 
 DEFINE_TRACE(ipc_call);
 
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+#include <asm/processor.h>
+#endif
+
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.  It returns results in registers $v0 / $v1 which means there
@@ -376,6 +381,14 @@ _sys_sysmips(nabi_no_regargs struct pt_regs regs)
 		__flush_cache_all();
 		return 0;
 	}
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	case MIPS_CAVIUM_XKPHYS_READ:
+		return xkphys_usermem_read(arg1);
+
+	case MIPS_CAVIUM_XKPHYS_WRITE:
+		return xkphys_usermem_write(arg1, arg2);
+#endif
 
 	return -EINVAL;
 }
-- 
1.6.0.3

