From 77bd38829f2ac92b21a7b8b97c0b1f23c4ffb404 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Mon, 15 Nov 2010 10:16:01 +0800
Subject: [PATCH 057/132] RapidIO: Add interface to memory map rapidio device memory.

The rapidio system needs a standard interface to allow drivers access
to memory mapped addresses on devices. Add a map/unamp calls to
create kernel pointers for accessing this remote memory.

Signed-off-by: Chad Reese <kreese@caviumnetworks.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 drivers/rapidio/rio-sysfs.c |   76 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/rio.h         |    7 ++++
 include/linux/rio_drv.h     |   35 ++++++++++++++++++++
 3 files changed, 118 insertions(+), 0 deletions(-)

diff --git a/drivers/rapidio/rio-sysfs.c b/drivers/rapidio/rio-sysfs.c
index cb8f7c7..c5b0d89 100644
--- a/drivers/rapidio/rio-sysfs.c
+++ b/drivers/rapidio/rio-sysfs.c
@@ -207,6 +207,52 @@ static struct bin_attribute rio_config_attr = {
 	.write = rio_write_config,
 };
 
+static ssize_t
+rio_read_memory(struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct rio_dev *dev =
+		to_rio_dev(container_of(kobj, struct device, kobj));
+	void *map;
+
+	if (off >= bin_attr->size)
+		return 0;
+	if (off + count > bin_attr->size)
+		count = bin_attr->size - off;
+
+	map = rio_map_memory(dev, off, count);
+	if (!map) {
+		dev_err(&dev->dev, "Unable to map RapidIO device resource\n");
+		return 0;
+	}
+	memcpy(buf, map, count);
+	rio_unmap_memory(dev, off, count, map);
+	return count;
+}
+
+static ssize_t
+rio_write_memory(struct kobject *kobj, struct bin_attribute *bin_attr,
+		 char *buf, loff_t off, size_t count)
+{
+	struct rio_dev *dev =
+		to_rio_dev(container_of(kobj, struct device, kobj));
+	void *map;
+
+	if (off >= bin_attr->size)
+		return 0;
+	if (off + count > bin_attr->size)
+		count = bin_attr->size - off;
+
+	map = rio_map_memory(dev, off, count);
+	if (!map) {
+		dev_err(&dev->dev, "Unable to map RapidIO device resource\n");
+		return 0;
+	}
+	memcpy(map, buf, count);
+	rio_unmap_memory(dev, off, count, map);
+	return count;
+}
+
 /**
  * rio_create_sysfs_dev_files - create RIO specific sysfs files
  * @rdev: device whose entries should be created
@@ -218,7 +264,32 @@ int rio_create_sysfs_dev_files(struct rio_dev *rdev)
 	int err = 0;
 
 	err = sysfs_create_bin_file(&rdev->dev.kobj, &rio_config_attr);
+	if (err)
+		return err;
+
+	rdev->memory.attr.name = "memory";
+	rdev->memory.attr.mode = S_IRUGO | S_IWUSR;
+	rdev->memory.read = rio_read_memory;
+	rdev->memory.write = rio_write_memory;
+	rdev->memory.private = NULL;
+
+	/* Prefer 50 bit addressing as it fits in kernel variables on a 64 bit
+		machine. Support for addressing 66 bits will need to be
+		revisited if anyone actually uses it */
+	if (rdev->pef & RIO_PEF_ADDR_50)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 50;
+	else if (rdev->pef & RIO_PEF_ADDR_66)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 63;
+	else if (rdev->pef & RIO_PEF_ADDR_34)
+		rdev->memory.size = (sizeof(rdev->memory.size) == 4) ? 1<<31 : 1ul << 34;
+	else
+		rdev->memory.size = 0;
 
+	if (rdev->memory.size) {
+		err = sysfs_create_bin_file(&rdev->dev.kobj, &rdev->memory);
+		if (err)
+			rdev->memory.size = 0;
+	}
 	return err;
 }
 
@@ -231,4 +302,9 @@ int rio_create_sysfs_dev_files(struct rio_dev *rdev)
 void rio_remove_sysfs_dev_files(struct rio_dev *rdev)
 {
 	sysfs_remove_bin_file(&rdev->dev.kobj, &rio_config_attr);
+
+	if (rdev->memory.size) {
+		sysfs_remove_bin_file(&rdev->dev.kobj, &rdev->memory);
+		rdev->memory.size = 0;
+	}
 }
diff --git a/include/linux/rio.h b/include/linux/rio.h
index b7bc3d9..dea68a2 100644
--- a/include/linux/rio.h
+++ b/include/linux/rio.h
@@ -112,6 +112,7 @@ struct rio_dev {
 	struct rio_driver *driver;	/* RIO driver claiming this device */
 	struct device dev;	/* LDM device structure */
 	struct resource riores[RIO_MAX_DEV_RESOURCES];
+	struct bin_attribute memory;	/* Sysfs file for memory access */
 	u16 destid;
 };
 
@@ -235,6 +236,8 @@ struct rio_switch {
  * @cread: Callback to perform network read of config space.
  * @cwrite: Callback to perform network write of config space.
  * @dsend: Callback to send a doorbell message.
+ * @map: Callback to map a remote device's memory range to the local system.
+ * @unmap: Callback to unmap a previously mapped range.
  */
 struct rio_ops {
 	int (*lcread) (struct rio_mport *mport, int index, u32 offset, int len,
@@ -246,6 +249,10 @@ struct rio_ops {
 	int (*cwrite) (struct rio_mport *mport, int index, u16 destid,
 			u8 hopcount, u32 offset, int len, u32 data);
 	int (*dsend) (struct rio_mport *mport, int index, u16 destid, u16 data);
+	phys_t (*map) (struct rio_mport *mport, struct rio_dev *rdev,
+			u64 offset, u64 length);
+	void (*unmap) (struct rio_mport *mport, struct rio_dev *rdev,
+			u64 offset, u64 length, phys_t map);
 };
 
 #define RIO_RESOURCE_MEM	0x00000100
diff --git a/include/linux/rio_drv.h b/include/linux/rio_drv.h
index c93a58a..6e61bce 100644
--- a/include/linux/rio_drv.h
+++ b/include/linux/rio_drv.h
@@ -413,6 +413,41 @@ void rio_release_regions(struct rio_dev *);
 int rio_request_region(struct rio_dev *, int, char *);
 void rio_release_region(struct rio_dev *, int);
 
+/**
+ * rio_map_memory - Map a RIO memory address to a kernel pointer.
+ * @rdev: RapidIO device the map is for
+ * @offset: RapidIO memory address offset into the device
+ * @length: Length of the mapped range
+ *
+ * Returns a kernel pointer to a memory mapped interface for a remote RapidIO
+ * device.
+ */
+static inline void *rio_map_memory(struct rio_dev *rdev,
+			u64 offset, u64 length)
+{
+	struct rio_mport *mport = rdev->net->hport;
+	phys_t physical = mport->ops->map(mport, rdev, offset, length);
+	if (physical)
+		return phys_to_virt(physical);
+	else
+		return NULL;
+}
+
+/**
+ * rio_unmap_memory - Unmap a RIO device mapped using rio_map_memory().
+ * @rdev: RapidIO device the resource is for
+ * @offset: RapidIO memory address offset of the map
+ * @length: Length of the mapped range
+ * @map: Kernel virtual address the resource was mapped at
+ */
+static inline void rio_unmap_memory(struct rio_dev *rdev,
+			u64 offset, u64 length, void *map)
+{
+	struct rio_mport *mport = rdev->net->hport;
+	phys_t physical = virt_to_phys(map);
+	mport->ops->unmap(mport, rdev, offset, length, physical);
+}
+
 /* LDM support */
 int rio_register_driver(struct rio_driver *);
 void rio_unregister_driver(struct rio_driver *);
-- 
1.7.0.4

