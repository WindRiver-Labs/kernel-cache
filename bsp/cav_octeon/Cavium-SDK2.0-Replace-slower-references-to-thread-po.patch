From 49fead546cb22b90099566242e30af5c3d94467e Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Wed, 10 Nov 2010 11:28:25 +0800
Subject: [PATCH 002/132] Cavium: SDK2.0 Replace slower references to thread pointer

Source: SDK 2.0.0-366

With this optimization, the kernel can dynamically replace slower
references to the thread pointer with fast accesses. This involves
replacing userspace instructions at runtime, so it may not work with
all programs. If you use an older compiler that does not provide the
ability to support FAST_ACCESS_TO_THREAD_POINTER, this option may
allow you to receive most of the benefit of direct access to the
thread pointer. It may also cause programs to fail.

Instruction replacement is disabled on boot. It can be controlled by
writing a mode to /sys/module/traps/parameters/thread_pointer_mode.
The supported modes are:

        0 - Use the normal kernel emulation without any changes.
        1 - Replace emulated instructions with direct accesses to the
            thread register.
        2 - Replace emulated instructions and log the replacement PC.
        3 - Replace emulated instructions with break instructions.
            This will cause programs to fail, but makes it easy to
            stop gdb on the instruction.

Integrated-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig |   24 ++++----
 arch/mips/kernel/traps.c        |  111 ++++++++++++++++++++++++---------------
 2 files changed, 80 insertions(+), 55 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 45495c6..1e04686 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -67,19 +67,19 @@ config REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
 	depends on FAST_ACCESS_TO_THREAD_POINTER
 	default "y"
 	help
-	  When this option is set, the kernel can dynamically replace slower
-	  references to the thread pointer with fast accesses. This involves
-	  replacing userspace instructions at runtime, so it may not work with
-	  all programs. It is advised to use a toolchain that creates code for
-	  FAST_ACCESS_TO_THREAD_POINTER instead of this option. If you have
-	  code compiled with a Cavium compiler prior to release 1.5, or are
-	  using a non Cavium compiler, this option may allow you to receive
-	  most of the benefit of direct access to the thread pointer. It may
-	  also cause programs to fail.
-
-	  Instruction replacement is disabled on boot. It can be controlled by
-	  writing a mode to /sys/module/traps/parameters/thread_pointer_mode.
-	  The supported modes are:
+	  When this option is set, the kernel can dynamically replace
+	  slower references to the thread pointer with fast
+	  accesses. This involves replacing userspace instructions at
+	  runtime, so it may not work with all programs. If you use an
+	  older compiler that does not provide the ability to support
+	  FAST_ACCESS_TO_THREAD_POINTER, this option may allow you to
+	  receive most of the benefit of direct access to the thread
+	  pointer. It may also cause programs to fail.
+
+	  Instruction replacement is disabled on boot. It can be
+	  controlled by writing a mode to
+	  /sys/module/traps/parameters/thread_pointer_mode.  The
+	  supported modes are:
 
 	  0 - Use the normal kernel emulation without any changes.
 	  1 - Replace emulated instructions with direct accesses to the thread
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index a0d64d3..9cde65a 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -89,24 +89,24 @@ extern asmlinkage void handle_reserved(void);
 extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 	struct mips_fpu_struct *ctx, int has_fpu);
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+/*	0 - Use the normal kernel emulation without any changes.
+	1 - Replace emulated instructions with direct accesses to the thread
+		register.
+	2 - Replace emulated instructions and log the replacement PC.
+	3 - Replace emulated instructions with break instructions. This will
+		cause programs to fail, but makes it easy to stop gdb on the
+		instruction. */
+static int thread_pointer_mode;
+module_param(thread_pointer_mode, int, 0644);
+#endif
+
 void (*board_be_init)(void);
 int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
 void (*board_nmi_handler_setup)(void);
 void (*board_ejtag_handler_setup)(void);
 void (*board_bind_eic_interrupt)(int irq, int regset);
 
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-/* 0 - Use the normal kernel emulation without any changes.
- * 1 - Replace emulated instructions with direct accesses to the thread
- *	register.
- * 2 - Replace emulated instructions and log the replacement PC.
- * 3 - Replace emulated instructions with break instructions. This will
- *	cause programs to fail, but makes it easy to stop gdb on the
- *	instruction.
- */
-static int thread_pointer_mode = 0;
-module_param(thread_pointer_mode, int, 0644);
-#endif
 
 static void show_raw_backtrace(unsigned long reg29)
 {
@@ -604,10 +604,6 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 {
 	struct thread_info *ti = task_thread_info(current);
 
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-	unsigned int __user *epc = (unsigned int __user *)regs->cp0_epc + ((regs->cp0_cause & CAUSEF_BD) != 0);
-#endif
-
 	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
 		int rd = (opcode & RD) >> 11;
 		int rt = (opcode & RT) >> 16;
@@ -634,36 +630,12 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-			if (thread_pointer_mode) {
-				unsigned int new_instruction = 0x00000025 | (26 << 21) | (rt << 11); /* move [rt], k0 */
-				if (thread_pointer_mode == 3)
-					new_instruction = 0x0000000d; /* break */
-				if (access_process_vm(current, (unsigned long)epc, &new_instruction, sizeof(new_instruction), 1) != sizeof(new_instruction))
-					printk(KERN_ERR "Failed to replaced emulated RDHWR at PC=%p\n", epc);
-				if (thread_pointer_mode == 2)
-					printk(KERN_INFO "Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n", epc, rt);
-				else if (thread_pointer_mode == 3)
-					printk(KERN_INFO "Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
-                        }
-#endif
 			return 0;
 		default:
 			return -1;
 		}
 	}
-#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
-	else if (opcode == (0x00000025 | (26 << 21) | (3 << 11)) /* move v1, k0 */)
-	{
-		/* We need to flush the icache, not emulate an instruction. The EPC is wrong,
-		 * so we need to put it back to the old instruction
-		 */
-		pr_debug(KERN_INFO "Already replaced emulated RDHWR at PC=%p\n", epc);
-		regs->cp0_epc = (unsigned long)epc;
-		flush_cache_sigtramp((unsigned long)epc);
-		return 0;
-        }
-#endif
+
 	/* Not ours.  */
 	return -1;
 }
@@ -838,6 +810,53 @@ out_sigsegv:
 	force_sig(SIGSEGV, current);
 }
 
+static void __handle_thread_pointer_mode(struct pt_regs *regs, unsigned int opcode, unsigned int __user *epc)
+{
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
+		int rd = (opcode & RD) >> 11;
+		int rt = (opcode & RT) >> 16;
+		switch (rd) {
+		case 29:
+			if (thread_pointer_mode) {
+				/* move [rt], k0 */
+				unsigned int new_instruction
+					= 0x00000025 | (26 << 21) | (rt << 11);
+				if (thread_pointer_mode == 3)
+					/* break */
+					new_instruction = 0x0000000d;
+				if (access_process_vm(current,
+					    (unsigned long)epc,
+					    &new_instruction,
+					    sizeof(new_instruction), 1)
+				    != sizeof(new_instruction))
+					printk(KERN_ERR \
+			"Failed to replaced emulated RDHWR at PC=%p\n", epc);
+				if (thread_pointer_mode == 2)
+					printk(KERN_INFO \
+			"Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n"
+					, epc, rt);
+				else if (thread_pointer_mode == 3)
+					printk(KERN_INFO \
+			"Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
+			}
+			break;
+		}
+
+	} else if (opcode == (0x00000025 | (26 << 21) | (3 << 11))) {
+		/*
+		 * Its a 'move v1, k0' instruction.
+		 * We need to flush the icache, not emulate an
+		 * instruction. The EPC is wrong, so we need to put it
+		 * back to the old instruction.
+		 */
+		/*printk(KERN_INFO "Already replaced emulated RDHWR at PC=%p\n", epc); */
+		regs->cp0_epc = (unsigned long)epc;
+		flush_cache_sigtramp((unsigned long)epc);
+	}
+#endif
+}
+
 asmlinkage void do_tr(struct pt_regs *regs)
 {
 	unsigned int opcode, tcode = 0;
@@ -878,8 +897,10 @@ asmlinkage void do_ri(struct pt_regs *regs)
 	if (!cpu_has_llsc && status < 0)
 		status = simulate_llsc(regs, opcode);
 
-	if (status < 0)
+	if (status < 0) {
+		__handle_thread_pointer_mode(regs, opcode, epc);
 		status = simulate_rdhwr(regs, opcode);
+	}
 
 	if (status < 0)
 		status = simulate_sync(regs, opcode);
@@ -993,8 +1014,10 @@ asmlinkage void do_cpu(struct pt_regs *regs)
 		if (!cpu_has_llsc && status < 0)
 			status = simulate_llsc(regs, opcode);
 
-		if (status < 0)
+		if (status < 0) {
+			__handle_thread_pointer_mode(regs, opcode, epc);
 			status = simulate_rdhwr(regs, opcode);
+		}
 
 		if (status < 0)
 			status = SIGILL;
@@ -1561,6 +1584,8 @@ void __cpuinit per_cpu_trap_init(void)
 			evpe(vpflags);
 		} else
 			set_c0_cause(CAUSEF_IV);
+	} else {
+		clear_c0_cause(CAUSEF_IV);
 	}
 
 	/*
-- 
1.6.5.2

