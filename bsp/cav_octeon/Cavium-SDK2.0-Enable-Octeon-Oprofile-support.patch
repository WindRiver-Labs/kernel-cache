From c4a6ec8c67fa23b593e476e5bfc8fbcb5c36cd32 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Fri, 19 Nov 2010 14:49:13 +0800
Subject: [PATCH 010/132] Cavium: SDK2.0 Enable Octeon Oprofile support

Source: SDK 2.0.0-366

Octeon has two PMR pairs and the counter registers are 64 bits.  Add
Octeon specifc read/write counter registers macros since MIPSR2
performance counters registers are 32 bits.  Add Octeon specific op
model file for arch-dependent Oprofile interfaces.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/oprofile/backtrace.h              |   17 ++++++++
 arch/mips/oprofile/common.c                 |    6 ++-
 arch/mips/oprofile/mips_context.h           |    2 +-
 arch/mips/oprofile/op_model_cavium_octeon.c |   60 ++++++++++++++------------
 4 files changed, 54 insertions(+), 31 deletions(-)

diff --git a/arch/mips/oprofile/backtrace.h b/arch/mips/oprofile/backtrace.h
index 0b49062..b105a58 100644
--- a/arch/mips/oprofile/backtrace.h
+++ b/arch/mips/oprofile/backtrace.h
@@ -22,4 +22,21 @@
  */
 extern void mips_backtrace(struct pt_regs *const regs, unsigned int depth);
 
+#if defined(CONFIG_64BIT)
+/*
+ * Callback from do_page_fault and do_ade to detect if
+ * page fault occured during an oprofile_backtrace.
+ * returns 1 if caller should not handle the fault
+ *   (caused by oprofile backtracing)
+ * returns 0 if the caller should handle the fault
+ */
+extern unsigned int (*is_oprofile_fault)(struct pt_regs *regs);
+
+/*
+ * Callback from do_page_fault and do_ade to set return
+ * of oprofile user space address valididator to false
+ */
+extern unsigned int op_page_fault_filter(struct pt_regs *regs);
+#endif
+
 #endif /* BACKTRACE_H */
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index 59a3b1c..337e0a0 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -20,7 +20,7 @@ extern struct op_mips_model op_model_mipsxx_ops __weak;
 extern struct op_mips_model op_model_rm9000_ops __weak;
 extern struct op_mips_model op_model_vr5500_ops __weak;
 extern struct op_mips_model op_model_loongson2_ops __weak;
-extern struct op_mips_model op_model_octeon_ops __weak;
+extern struct op_mips_model op_model_octeon __weak;
 
 static struct op_mips_model *model;
 
@@ -105,9 +105,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_R5500:
 		lmodel = &op_model_vr5500_ops;
 		break;
+
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
-		lmodel = &op_model_octeon_ops;
+	case CPU_CAVIUM_OCTEON2:
+		lmodel = &op_model_octeon;
 		break;
 	};
 
diff --git a/arch/mips/oprofile/mips_context.h b/arch/mips/oprofile/mips_context.h
index 20ef131..6114285 100644
--- a/arch/mips/oprofile/mips_context.h
+++ b/arch/mips/oprofile/mips_context.h
@@ -203,7 +203,7 @@ typedef unsigned long tAddr;	/* Address type */
 #define RTITOOLS_CONTEXT_CHECK_TOP_LAST         (0)
 
 #define RTITOOLS_CONTEXT_USES_SP  (1)	/* Does context package use sp? */
-#define RTITOOLS_CONTEXT_USES_FP  (0)	/* Does context package use fp? */
+#define RTITOOLS_CONTEXT_USES_FP  (1)	/* Does context package use fp? */
 
 /* Register numbers for op_context */
 enum register_name {
diff --git a/arch/mips/oprofile/op_model_cavium_octeon.c b/arch/mips/oprofile/op_model_cavium_octeon.c
index 88fef67..c58abb4 100644
--- a/arch/mips/oprofile/op_model_cavium_octeon.c
+++ b/arch/mips/oprofile/op_model_cavium_octeon.c
@@ -8,10 +8,11 @@
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
-#include <asm/mipsregs.h>
 
 #include "op_impl.h"
 
+#define OCTEON_PERFCNT_IRQ   (cp0_perfcount_irq + MIPS_CPU_IRQ_BASE)
+
 /**
  * Bit description of the core counters control register
  */
@@ -59,8 +60,8 @@ static void octeon_reg_setup(struct op_counter_config *ctr)
 
 static void octeon_cpu_setup(void *args)
 {
-	write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
-	write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+	__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
+	__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
 }
 
 static void octeon_cpu_start(void *args)
@@ -69,13 +70,22 @@ static void octeon_cpu_start(void *args)
 
 	/* Disable the issue and exec conditional clock support so we get
 		better results */
-	cvmctl = read_c0_cvmctl();
+	cvmctl = __read_64bit_c0_register($9, 7);
 	cvmctl |= 3 << 16;
-	write_c0_cvmctl(cvmctl);
+	__write_64bit_c0_register($9, 7, cvmctl);
+
+	/* Check CvmCtl[IPPCI] bit to make sure it is set with
+	 * irq cached by cp0_perfcount_irq
+	 */
+	cvmctl = __read_64bit_c0_register($9, 7);
+	if (cp0_perfcount_irq != ((cvmctl >> 7) & 7)) {
+		printk(KERN_INFO "oprofile perf irq is not mapped to %d, on core %d \n",
+			cp0_perfcount_irq,  smp_processor_id());
+	}
 
 	/* Start all counters on current CPU */
-	write_c0_perfctrl0(octeon_config.control[0].u32);
-	write_c0_perfctrl1(octeon_config.control[1].u32);
+	__write_32bit_c0_register($25, 0, octeon_config.control[0].u32);
+	__write_32bit_c0_register($25, 2, octeon_config.control[1].u32);
 }
 
 static void octeon_cpu_stop(void *args)
@@ -83,30 +93,30 @@ static void octeon_cpu_stop(void *args)
 	uint64_t cvmctl;
 
 	/* Stop all counters on current CPU */
-	write_c0_perfctrl0(0);
-	write_c0_perfctrl1(0);
+	__write_32bit_c0_register($25, 0, 0);
+	__write_32bit_c0_register($25, 2, 0);
 
 	/* Enable the issue and exec conditional clock support so we use
 		less power */
-	cvmctl = read_c0_cvmctl();
+	cvmctl = __read_64bit_c0_register($9, 7);
 	cvmctl &= ~(3 << 16);
-	write_c0_cvmctl(cvmctl);
+	__write_64bit_c0_register($9, 7, cvmctl);
 }
 
 static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
 {
 	uint64_t counter;
 
-	counter = read_octeon_c0_perfcntr0();
+	counter = __read_64bit_c0_register($25, 1);
 	if (counter & (1ull << 63)) {
 		oprofile_add_sample(get_irq_regs(), 0);
-		write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
+		__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
 	}
 
-	counter = read_octeon_c0_perfcntr1();
+	counter = __read_64bit_c0_register($25, 3);
 	if (counter & (1ull << 63)) {
 		oprofile_add_sample(get_irq_regs(), 1);
-		write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+		__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
 	}
 
 	return IRQ_HANDLED;
@@ -114,21 +124,15 @@ static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
 
 static int octeon_init(void)
 {
-	unsigned long irq_flags;
-	int result;
-#ifdef CONFIG_PREEMPT_HARDIRQS
-	irq_flags = IRQF_NODELAY;
-#else
-	irq_flags = IRQF_SHARED;
-#endif 
-	result =
-		request_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler, irq_flags,
+	int result =
+		request_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler,
+			    IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING,
 			    "Perfcounter", octeon_perfcount_handler);
 #ifdef CONFIG_SMP
 	if (result == 0) {
-		struct irq_desc *desc = irq_desc + OCTEON_IRQ_PERF;
+		struct irq_desc *desc = irq_desc + OCTEON_PERFCNT_IRQ;
 		smp_call_function((void (*)(void *)) desc->chip->enable,
-				  (void *) (long) OCTEON_IRQ_PERF, 1);
+				  (void *) (long) OCTEON_PERFCNT_IRQ, 1);
 	}
 #endif
 	return result;
@@ -136,10 +140,10 @@ static int octeon_init(void)
 
 static void octeon_exit(void)
 {
-	free_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler);
+	free_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler);
 }
 
-struct op_mips_model op_model_octeon_ops = {
+struct op_mips_model op_model_octeon = {
 	.reg_setup = octeon_reg_setup,
 	.cpu_setup = octeon_cpu_setup,
 	.init = octeon_init,
-- 
1.6.5.2

