From 94d6c551e1f37c157cb0a8fa109a385d9ab94add Mon Sep 17 00:00:00 2001
From: Tian Le <le.tian@windriver.com>
Date: Fri, 26 Nov 2010 15:17:02 +0800
Subject: [PATCH 124/132] Cavium Add CGL support by adding IRQ_NODELAY to IRQ flags

Ethernet and Oprofile IRQ handling are broken by threaded IRQ in CGL,
so disable both these 2 IRQs to be threaded by adding IRQ_NODELAY
to fix the issue.

Signed-off-by: Tian Le <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/setup.c             |   10 +++++++++-
 arch/mips/oprofile/op_model_cavium_octeon.c |   12 +++++++++---
 drivers/net/octeon/ethernet-rgmii.c         |    8 +++++++-
 drivers/net/octeon/ethernet-rx.c            |    7 ++++++-
 drivers/net/octeon/ethernet-spi.c           |    8 +++++++-
 5 files changed, 38 insertions(+), 7 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index de15c1f..2e69fdb 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -1101,6 +1101,9 @@ EXPORT_SYMBOL(prom_putchar);
 
 void prom_free_prom_memory(void)
 {
+#ifdef CONFIG_CAVIUM_DECODE_RSL
+	unsigned long irq_flags;
+#endif
         if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
                 /* Check for presence of Core-14445 fix.  */
                 u32 insn;
@@ -1128,7 +1131,12 @@ void prom_free_prom_memory(void)
         }
 #ifdef CONFIG_CAVIUM_DECODE_RSL
  	/* Add an interrupt handler for general failures. */
-	if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, IRQF_SHARED,
+#ifdef  CONFIG_PREEMPT_HARDIRQS
+	irq_flags = IRQF_SHARED | IRQF_NODELAY;
+#else
+	irq_flags = IRQF_SHARED;
+#endif
+	if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, irq_flags,
                         "RML_RSL", octeon_rml_interrupt)) {	
  		panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
 	}
diff --git a/arch/mips/oprofile/op_model_cavium_octeon.c b/arch/mips/oprofile/op_model_cavium_octeon.c
index c58abb4..8c03c41 100644
--- a/arch/mips/oprofile/op_model_cavium_octeon.c
+++ b/arch/mips/oprofile/op_model_cavium_octeon.c
@@ -124,9 +124,15 @@ static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
 
 static int octeon_init(void)
 {
-	int result =
-		request_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler,
-			    IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING,
+	unsigned long irq_flags;
+	int result;
+#ifdef	CONFIG_PREEMPT_HARDIRQS
+	irq_flags = IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING | IRQF_NODELAY;
+#else
+	irq_flags = IRQF_DISABLED | IRQF_PERCPU | IRQF_NOBALANCING;
+#endif 
+	result =
+		request_irq(OCTEON_PERFCNT_IRQ, octeon_perfcount_handler, irq_flags,
 			    "Perfcounter", octeon_perfcount_handler);
 #ifdef CONFIG_SMP
 	if (result == 0) {
diff --git a/drivers/net/octeon/ethernet-rgmii.c b/drivers/net/octeon/ethernet-rgmii.c
index 6eccaf0..f604123 100644
--- a/drivers/net/octeon/ethernet-rgmii.c
+++ b/drivers/net/octeon/ethernet-rgmii.c
@@ -246,6 +246,7 @@ int cvm_oct_rgmii_init(struct net_device *dev)
 {
 	struct octeon_ethernet *priv = netdev_priv(dev);
 	int r;
+	unsigned long irq_flags;
 
 	cvm_oct_common_init(dev);
 	dev->netdev_ops->ndo_stop(dev);
@@ -258,9 +259,14 @@ int cvm_oct_rgmii_init(struct net_device *dev)
 	 * problems if the PHY doesn't implement inband status
 	 * properly.
 	 */
+#ifdef  CONFIG_PREEMPT_HARDIRQS
+	irq_flags = IRQF_SHARED | IRQF_NODELAY;
+#else
+	irq_flags = IRQF_SHARED;
+#endif 
 	if (number_rgmii_ports == 0) {
 		r = request_irq(OCTEON_IRQ_RML, cvm_oct_rgmii_rml_interrupt,
-				IRQF_SHARED, "RGMII", &number_rgmii_ports);
+				irq_flags, "RGMII", &number_rgmii_ports);
 		if (r != 0)
 			return r;
 	}
diff --git a/drivers/net/octeon/ethernet-rx.c b/drivers/net/octeon/ethernet-rx.c
index ff03f30..375a0b7 100644
--- a/drivers/net/octeon/ethernet-rx.c
+++ b/drivers/net/octeon/ethernet-rx.c
@@ -624,6 +624,7 @@ void cvm_oct_rx_initialize(void)
 	struct net_device *dev_for_napi = NULL;
 	union cvmx_pow_wq_int_thrx int_thr;
 	union cvmx_pow_wq_int_pc int_pc;
+	unsigned long irq_flags = 0;
 
 	if (list_empty(&cvm_oct_list))
 		panic("No net_devices were allocated.");
@@ -643,9 +644,13 @@ void cvm_oct_rx_initialize(void)
 			       cvm_oct_napi_poll, rx_napi_weight);
 		napi_enable(&cvm_oct_napi[i].napi);
 	}
+	
 	/* Register an IRQ hander for to receive POW interrupts */
+#ifdef  CONFIG_PREEMPT_HARDIRQS
+	irq_flags = IRQF_NODELAY;
+#endif
 	i = request_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group,
-			cvm_oct_do_interrupt, 0, dev_for_napi->name, &cvm_oct_list);
+			cvm_oct_do_interrupt, irq_flags, dev_for_napi->name, &cvm_oct_list);
 
 	if (i)
 		panic("Could not acquire Ethernet IRQ %d\n",
diff --git a/drivers/net/octeon/ethernet-spi.c b/drivers/net/octeon/ethernet-spi.c
index 66d43f8..858f48c 100644
--- a/drivers/net/octeon/ethernet-spi.c
+++ b/drivers/net/octeon/ethernet-spi.c
@@ -254,11 +254,17 @@ static void cvm_oct_spi_poll(struct net_device *dev)
 int cvm_oct_spi_init(struct net_device *dev)
 {
 	int r;
+	unsigned long irq_flags;
 	struct octeon_ethernet *priv = netdev_priv(dev);
 
+#ifdef CONFIG_PREEMPT_HARDIRQS
+	irq_flags = IRQF_SHARED | IRQF_NODELAY;
+#else
+	irq_flags = IRQF_SHARED;
+#endif 
 	if (number_spi_ports == 0) {
 		r = request_irq(OCTEON_IRQ_RML, cvm_oct_spi_rml_interrupt,
-				IRQF_SHARED, "SPI", &number_spi_ports);
+				irq_flags, "SPI", &number_spi_ports);
 		if (r != 0) {
 			pr_err("%s: request_irq(%d) failed\n", dev->name, OCTEON_IRQ_RML);
 			return r;
-- 
1.6.5.2

