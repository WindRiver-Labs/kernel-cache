From 8dd9d29b3a46377c69caa1ea66e6747caf735d13 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 10 Mar 2011 11:39:27 -0800
Subject: [PATCH 10/13] Cavium: Add hardware timestamp support

Source: Cavium sdk_2.0.0_updates_p4.tgz

The CN63XX hardware supports very accurate time-stamping in the GMX,
PIP/IPD, and PKO blocks. This time-stamping is suitable for use in
IEEE 1588 Precision Time Protocol (PTP) or other purposes.

CN63XX includes a tunable PTP clock that can be used for precision
time-stamping.  This clock is used for time-stamping at the physical
packet-transfer interfaces.

Add HW timestamp support by adding new function
octeon_mgmt_ioctl_hwstamp(), making octeon_mgmt_ioctl() decide whether
to call it or phy_mii_ioctl(), and adding support function
ptp_to_ktime.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 drivers/net/octeon/ethernet-mdio.c |    4 +-
 drivers/net/octeon/ethernet-rx.c   |   34 +++++---
 drivers/net/octeon/octeon_mgmt.c   |  172 ++++++++++++++++++++++++++++++++++--
 3 files changed, 190 insertions(+), 20 deletions(-)

diff --git a/drivers/net/octeon/ethernet-mdio.c b/drivers/net/octeon/ethernet-mdio.c
index 80608b5..1229efd 100644
--- a/drivers/net/octeon/ethernet-mdio.c
+++ b/drivers/net/octeon/ethernet-mdio.c
@@ -136,7 +136,9 @@ static int cvm_oct_ioctl_hwtstamp(struct net_device *dev,
 			 */
 			unsigned long long clock_comp = (NSEC_PER_SEC << 32) /
 				octeon_get_io_clock_rate();
-			cvmx_write_csr(CVMX_MIO_PTP_CLOCK_COMP, clock_comp);
+			if (!ptp.s.ptp_en)
+				cvmx_write_csr(CVMX_MIO_PTP_CLOCK_COMP,
+					       clock_comp);
 			pr_info("PTP Clock: Using sclk reference at %lld Hz\n",
 				(NSEC_PER_SEC << 32) / clock_comp);
 		} else {
diff --git a/drivers/net/octeon/ethernet-rx.c b/drivers/net/octeon/ethernet-rx.c
index 31435ef..c684037 100644
--- a/drivers/net/octeon/ethernet-rx.c
+++ b/drivers/net/octeon/ethernet-rx.c
@@ -372,24 +372,32 @@ static int cvm_oct_napi_poll(struct napi_struct *napi, int budget)
 		 */
 		if (work->word2.s.software) {
 			struct octeon_ethernet *priv;
+			union skb_shared_tx *shtx;
 			int packet_qos = work->unused;
 			skb = (struct sk_buff *)work->packet_ptr.u64;
 			priv = netdev_priv(skb->dev);
 			if (!netif_running(skb->dev))
 				netif_wake_queue(skb->dev);
-			if (priv->flags & OCTEON_ETHERNET_FLAG_TX_TIMESTAMP_HW) {
-				uint64_t ns = *(uint64_t *)work->packet_data;
-				struct skb_shared_hwtstamps ts;
-				ts.syststamp = cvm_oct_ptp_to_ktime(ns);
-				ts.hwtstamp = ns_to_ktime(ns);
-				skb_tstamp_tx(skb, &ts);
-			}
-			if (priv->flags & OCTEON_ETHERNET_FLAG_TX_TIMESTAMP_SW) {
-				uint64_t ns = *(uint64_t *)work->packet_data;
-				struct skb_shared_hwtstamps ts;
-				ts.syststamp = ns_to_ktime(ns);
-				ts.hwtstamp = ns_to_ktime(0);
-				skb_tstamp_tx(skb, &ts);
+			shtx = skb_tx(skb);
+			if (unlikely(shtx->hardware)) {
+				if (priv->flags &
+				    OCTEON_ETHERNET_FLAG_TX_TIMESTAMP_HW) {
+					uint64_t ns =
+						*(uint64_t *)work->packet_data;
+					struct skb_shared_hwtstamps ts;
+					ts.syststamp = cvm_oct_ptp_to_ktime(ns);
+					ts.hwtstamp = ns_to_ktime(ns);
+					skb_tstamp_tx(skb, &ts);
+				}
+				if (priv->flags &
+				    OCTEON_ETHERNET_FLAG_TX_TIMESTAMP_SW) {
+					uint64_t ns =
+						*(uint64_t *)work->packet_data;
+					struct skb_shared_hwtstamps ts;
+					ts.syststamp = ns_to_ktime(ns);
+					ts.hwtstamp = ns_to_ktime(0);
+					skb_tstamp_tx(skb, &ts);
+				}
 			}
 
 			dev_kfree_skb_any(skb);
diff --git a/drivers/net/octeon/octeon_mgmt.c b/drivers/net/octeon/octeon_mgmt.c
index 57e9283..2c7041b 100644
--- a/drivers/net/octeon/octeon_mgmt.c
+++ b/drivers/net/octeon/octeon_mgmt.c
@@ -15,6 +15,7 @@
 #include <linux/if_vlan.h>
 #include <linux/phy.h>
 #include <linux/spinlock.h>
+#include <linux/net_tstamp.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-clock.h>
@@ -61,6 +62,7 @@ struct octeon_mgmt {
 	struct net_device *netdev;
 	int port;
 	int irq;
+	int has_rx_tstamp;
 	u64 *tx_ring;
 	dma_addr_t tx_ring_handle;
 	unsigned int tx_next;
@@ -181,6 +183,29 @@ static void octeon_mgmt_rx_fill_ring(struct net_device *netdev)
 	}
 }
 
+static ktime_t ptp_to_ktime(uint64_t ptptime)
+{
+	ktime_t ktimebase;
+	uint64_t ptpbase;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	/* Fill the icache with the code */
+	ktime_get_real();
+	/* Flush all pending operations */
+	CVMX_SYNC;
+	/* Read the time and PTP clock as close together as possible. It is
+	    important that this sequence take the same amount of time to
+	    reduce jitter */
+	ktimebase = ktime_get_real();
+	/* FIXME: Needed for CN63XX errata */
+	cvmx_read_csr(CVMX_MIO_PTP_CLOCK_HI);
+	ptpbase = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_HI);
+	local_irq_restore(flags);
+
+	return ktime_sub_ns(ktimebase, ptpbase - ptptime);
+}
+
 static void octeon_mgmt_clean_tx_buffers(struct octeon_mgmt *p)
 {
 	int port = p->port;
@@ -221,6 +246,20 @@ static void octeon_mgmt_clean_tx_buffers(struct octeon_mgmt *p)
 
 		dma_unmap_single(p->dev, re.s.addr, re.s.len,
 				 DMA_TO_DEVICE);
+
+		/* Read the hardware TX timestamp if one was recorded */
+		if (unlikely(re.s.tstamp)) {
+			struct skb_shared_hwtstamps ts;
+			/* Read the timestamp */
+			uint64_t ns = cvmx_read_csr(CVMX_MIXX_TSTAMP(p->port));
+			/* Remove the timestamp from the FIFO */
+			cvmx_write_csr(CVMX_MIXX_TSCTL(p->port), 0);
+			/* Tell the kernel about the timestamp */
+			ts.syststamp = ptp_to_ktime(ns);
+			ts.hwtstamp = ns_to_ktime(ns);
+			skb_tstamp_tx(skb, &ts);
+		}
+
 		dev_kfree_skb_any(skb);
 		cleaned++;
 
@@ -323,6 +362,16 @@ static int octeon_mgmt_receive_one(struct octeon_mgmt *p)
 		/* A good packet, send it up. */
 		skb_put(skb, re.s.len);
 good:
+		/* Process the RX timestamp if it was recorded */
+		if (p->has_rx_tstamp) {
+			/* The first 8 bytes are the timestamp */
+			uint64_t ns = *(uint64_t *)skb->data;
+			struct skb_shared_hwtstamps *ts;
+			ts = skb_hwtstamps(skb);
+			ts->hwtstamp = ns_to_ktime(ns);
+			ts->syststamp = ptp_to_ktime(ns);
+			__skb_pull(skb, 8);
+		}
 		skb->protocol = eth_type_trans(skb, netdev);
 		netdev->stats.rx_packets++;
 		netdev->stats.rx_bytes += skb->len;
@@ -624,18 +673,125 @@ static irqreturn_t octeon_mgmt_interrupt(int cpl, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int octeon_mgmt_ioctl(struct net_device *netdev,
-			     struct ifreq *rq, int cmd)
+static int octeon_mgmt_ioctl_hwtstamp(struct net_device *netdev,
+	struct ifreq *rq, int cmd)
 {
 	struct octeon_mgmt *p = netdev_priv(netdev);
+	struct hwtstamp_config config;
+	union cvmx_mio_ptp_clock_cfg ptp;
+	int have_hw_timestamps = 0;
 
-	if (!netif_running(netdev))
+	if (copy_from_user(&config, rq->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	if (config.flags) /* reserved for future extensions */
 		return -EINVAL;
 
-	if (!p->phydev)
+	/* Check the status of hardware for tiemstamps */
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		/* Get the current state of the PTP clock */
+		ptp.u64 = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_CFG);
+		if (!ptp.s.ext_clk_en) {
+			/*
+			 * The clock has not been configured to use an
+			 * external source.  Program it to use the main clock
+			 * reference.
+			 */
+			unsigned long long clock_comp = (NSEC_PER_SEC << 32) /
+				octeon_get_io_clock_rate();
+			if (!ptp.s.ptp_en)
+				cvmx_write_csr(CVMX_MIO_PTP_CLOCK_COMP,
+					       clock_comp);
+			pr_info("PTP Clock: Using sclk reference at %lld Hz\n",
+				(NSEC_PER_SEC << 32) / clock_comp);
+		} else {
+			/* The clock is already programmed to use a GPIO */
+			unsigned long long clock_comp = octeon_read_ptp_csr(
+				CVMX_MIO_PTP_CLOCK_COMP);
+			pr_info("PTP Clock: Using GPIO %d at %lld Hz\n",
+				ptp.s.ext_clk_in,
+				(NSEC_PER_SEC << 32) / clock_comp);
+		}
+
+		/* Enable the clock if it wasn't done already */
+		if (!ptp.s.ptp_en) {
+			ptp.s.ptp_en = 1;
+			cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp.u64);
+		}
+		have_hw_timestamps = 1;
+	}
+
+	if (!have_hw_timestamps)
 		return -EINVAL;
 
-	return phy_mii_ioctl(p->phydev, if_mii(rq), cmd);
+	switch (config.tx_type) {
+	case HWTSTAMP_TX_OFF:
+	case HWTSTAMP_TX_ON:
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		p->has_rx_tstamp = 0;
+		if (have_hw_timestamps) {
+			union cvmx_agl_gmx_rxx_frm_ctl rxx_frm_ctl;
+			rxx_frm_ctl.u64 =
+				cvmx_read_csr(CVMX_AGL_GMX_RXX_FRM_CTL(p->port));
+			rxx_frm_ctl.s.ptp_mode = 0;
+			cvmx_write_csr(CVMX_AGL_GMX_RXX_FRM_CTL(p->port),
+				       rxx_frm_ctl.u64);
+		}
+		break;
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_SOME:
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		p->has_rx_tstamp = have_hw_timestamps;
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+		if (p->has_rx_tstamp) {
+			union cvmx_agl_gmx_rxx_frm_ctl rxx_frm_ctl;
+			rxx_frm_ctl.u64 =
+				cvmx_read_csr(CVMX_AGL_GMX_RXX_FRM_CTL(p->port));
+			rxx_frm_ctl.s.ptp_mode = 1;
+			cvmx_write_csr(CVMX_AGL_GMX_RXX_FRM_CTL(p->port),
+				       rxx_frm_ctl.u64);
+		}
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	if (copy_to_user(rq->ifr_data, &config, sizeof(config)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int octeon_mgmt_ioctl(struct net_device *netdev,
+			     struct ifreq *rq, int cmd)
+{
+	struct octeon_mgmt *p = netdev_priv(netdev);
+
+	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		return octeon_mgmt_ioctl_hwtstamp(netdev, rq, cmd);
+	default:
+		if (p->phydev)
+			return phy_mii_ioctl(p->phydev, if_mii(rq), cmd);
+		return -EINVAL;
+	}
 }
 
 static void octeon_mgmt_disable_link(int port)
@@ -983,6 +1139,7 @@ static int octeon_mgmt_open(struct net_device *netdev)
 
 		/* Enable the componsation controller */
 		agl_prtx_ctl.s.comp = 1;
+		agl_prtx_ctl.s.drv_byp = 0;
 		cvmx_write_csr(CVMX_AGL_PRTX_CTL(port),	agl_prtx_ctl.u64);
 		/* Force write out before wait. */
 		cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));
@@ -1019,7 +1176,7 @@ static int octeon_mgmt_open(struct net_device *netdev)
 
 	/* Interrupt when we have 1 or more packets to clean.  */
 	mix_orhwm.u64 = 0;
-	mix_orhwm.s.orhwm = 1;
+	mix_orhwm.s.orhwm = 0;
 	cvmx_write_csr(CVMX_MIXX_ORHWM(port), mix_orhwm.u64);
 
 	/* Enable receive and transmit interrupts */
@@ -1031,6 +1188,7 @@ static int octeon_mgmt_open(struct net_device *netdev)
 	/* Enable packet I/O. */
 
 	rxx_frm_ctl.u64 = 0;
+	rxx_frm_ctl.s.ptp_mode = p->has_rx_tstamp;
 	rxx_frm_ctl.s.pre_align = 1;
 	/*
 	 * When set, disables the length check for non-min sized pkts
@@ -1136,6 +1294,7 @@ static int octeon_mgmt_xmit(struct sk_buff *skb, struct net_device *netdev)
 	int rv = NETDEV_TX_BUSY;
 
 	re.d64 = 0;
+	re.s.tstamp = skb_tx(skb)->hardware;
 	re.s.len = skb->len;
 	re.s.addr = dma_map_single(p->dev, skb->data,
 				   skb->len,
@@ -1272,6 +1431,7 @@ static int __init octeon_mgmt_probe(struct platform_device *pdev)
 	p->netdev = netdev;
 	p->dev = &pdev->dev;
 
+	p->has_rx_tstamp = 0;
 	p->port = pdev->id;
 	snprintf(netdev->name, IFNAMSIZ, "mgmt%d", p->port);
 
-- 
1.7.0.4

