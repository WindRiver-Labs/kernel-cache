From 1ed07fc5dd48fd39c3ea0655ebde6b57891700d2 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Fri, 12 Nov 2010 16:25:31 +0800
Subject: [PATCH 051/132] Cavium: fix kexec crash kernel boot failing on 58xx

Source: Internal Development

First, fix on-SoC POW-driven-device reset sequence by methods
from SDK 2.0.0-366, include:

 - Obtain device work from POW from pow_work_request_sync() API
   to drain the rx queues
 - Shutdown RX/TX on devices
 - Clear possible pending interrupts from first kernel in POW
 - Add handling of SGMII and XAUI interface modes

Second, handle bootmem allocation differently for crash kernel.
Previous implementation tried to free bootmem then reallocate it.
In fact, this is superfluous, since the memory has already been
allocated by the bootloader to the first kernel. The crash kernel
will run from inside some of that memory. Simply bypass the
reallocation if running a crash kernel.

Third, remove a forgotten debugging printk().

Signed-off-by: ltian <le.tian@windriver.com>
---
 drivers/net/octeon/ethernet.c         |    1 -
 drivers/net/octeon/octeon-kexec-net.c |   37 ++++++++++++++++++++++----------
 2 files changed, 25 insertions(+), 13 deletions(-)

diff --git a/drivers/net/octeon/ethernet.c b/drivers/net/octeon/ethernet.c
index 509f5e0..4a85591 100644
--- a/drivers/net/octeon/ethernet.c
+++ b/drivers/net/octeon/ethernet.c
@@ -753,7 +753,6 @@ static int __init cvm_oct_init_module(void)
 	int qos;
 
 #ifdef CONFIG_KEXEC
-printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
 	if (reset_devices)
 		octeon_shutdown_network_hw();
 #endif
diff --git a/drivers/net/octeon/octeon-kexec-net.c b/drivers/net/octeon/octeon-kexec-net.c
index b47d01c..97d2915 100644
--- a/drivers/net/octeon/octeon-kexec-net.c
+++ b/drivers/net/octeon/octeon-kexec-net.c
@@ -12,6 +12,7 @@
 #include "cvmx-pko-defs.h"
 #include "cvmx-smix-defs.h"
 #include "cvmx-pow.h"
+#include "cvmx-asxx-defs.h"
 
 void octeon_shutdown_network_hw(void)
 {
@@ -27,14 +28,7 @@ void octeon_shutdown_network_hw(void)
 	union cvmx_smix_en smix_en;
 	union cvmx_ipd_ctl_status ipd_ctl_status;
 	union cvmx_pip_sft_rst pip_sft_rst;
-
-	/* free up the work queue associated with this core */
-	work = cvmx_pow_get_current_wqp();
-	if (NULL != work) {
-		/* drain the work queue and free it */
-		cvmx_helper_free_packet_data(work);
-		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
-	}
+	union cvmx_pow_wq_int wq_int;
 
 	/* halt the interfaces */
 	num_ints = cvmx_helper_get_number_of_interfaces();
@@ -43,10 +37,18 @@ void octeon_shutdown_network_hw(void)
 
 	/* Check to see what interface and ports we should use */
 	for (interface = 0; interface < num_ints; interface++) {
-		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
-			cvmx_helper_interface_get_mode(interface)) ||
-			(CVMX_HELPER_INTERFACE_MODE_GMII ==
-				cvmx_helper_interface_get_mode(interface))) {
+		cvmx_helper_interface_mode_t mode =
+			cvmx_helper_interface_get_mode(interface);
+		int xGMII_mode = (CVMX_HELPER_INTERFACE_MODE_RGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_SGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_GMII  == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_XAUI  == mode);
+
+		if (xGMII_mode) {
+			/* disable RX and TX */
+			cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), 0x0);
+			cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), 0x0);
+
 			/* get the ports for this interface */
 			cvmx_helper_interface_probe(interface);
 			num_ports = cvmx_helper_ports_on_interface(interface);
@@ -61,6 +63,17 @@ void octeon_shutdown_network_hw(void)
 		}
 	}
 
+	/* drain the work queue and free it */
+	while ((work = cvmx_pow_work_request_sync(CVMX_POW_WAIT))) {
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* clear possible pending interrupt */
+	wq_int.u64 = 0;
+	wq_int.s.wq_int = 1 << 15;
+	cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
+
 	/* disable the SMI */
 	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
 	if (smix_en.s.en) {
-- 
1.6.5.2

