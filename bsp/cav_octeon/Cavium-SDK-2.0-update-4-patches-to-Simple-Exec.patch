From ddfdd8b7608385575071921446f81b1e83ed3909 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 10 Mar 2011 11:35:53 -0800
Subject: [PATCH 01/13] Cavium: SDK 2.0 update 4 patches to Simple Exec

Source: Cavium sdk_2.0.0_updates_p4.tgz

Updates to Cavium's Simple Exec library, taken verbatim from their
update patch.

Includes:

1. Add Octeon II pass2 support.
2. Fix the bug that TWSI transactions don't handle multi-master busses.
3. Add NIC10e board support.
4. Add code to ensure the workaround of errata G-720 is only applied once.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 simple_exec/cvmx-app-init.c       |   16 +-
 simple_exec/cvmx-csr-db-support.c |    6 +-
 simple_exec/cvmx-dma-engine.c     |   16 +-
 simple_exec/cvmx-error-custom.c   |  102 +++++++
 simple_exec/cvmx-error.c          |    5 +-
 simple_exec/cvmx-helper-board.c   |    3 +-
 simple_exec/cvmx-helper-errata.c  |    8 +-
 simple_exec/cvmx-helper.c         |   12 +-
 simple_exec/cvmx-interrupt.c      |   45 +++-
 simple_exec/cvmx-l2c.c            |   51 ++++-
 simple_exec/cvmx-l2c.h            |   17 +-
 simple_exec/cvmx-mgmt-port.c      |    3 +-
 simple_exec/cvmx-pcie.c           |    5 +-
 simple_exec/cvmx-srio.c           |  532 +++++++++++++++++++++----------------
 simple_exec/cvmx-tra.c            |   37 +++-
 simple_exec/cvmx-tra.h            |   25 +-
 simple_exec/cvmx-twsi.c           |   61 ++++-
 simple_exec/cvmx-version.h        |    4 +-
 simple_exec/octeon-model.c        |    5 +-
 simple_exec/octeon-model.h        |    4 +-
 20 files changed, 676 insertions(+), 281 deletions(-)

diff --git a/simple_exec/cvmx-app-init.c b/simple_exec/cvmx-app-init.c
index 885e36e..b20085c 100644
--- a/simple_exec/cvmx-app-init.c
+++ b/simple_exec/cvmx-app-init.c
@@ -60,6 +60,7 @@
 #include "cvmx-ebt3000.h"
 #include "cvmx-sim-magic.h"
 #include "cvmx-debug.h"
+#include "cvmx-scratch.h"
 #include "../../bootloader/u-boot/include/octeon_mem_map.h"
 
 int cvmx_debug_uart = -1;
@@ -396,11 +397,11 @@ int cvmx_user_app_init(void)
 
     /* Put message on LED display */
     if (cvmx_sysinfo_get()->board_type != CVMX_BOARD_TYPE_SIM)
-      ebt3000_str_write("CVMX    ");
+        ebt3000_str_write("CVMX    ");
 
     /* Check BIST results for COP0 registers, some values only meaningful in pass 2 */
     CVMX_MF_CACHE_ERR(bist_val);
-    mask = (1ULL<<32) | (1ULL<<33) | (1ULL<<34) | (1ULL<<35) | (1ULL<<36);
+    mask = (0x3fULL<<32); // Icache;BHT;AES;HSH/GFM;LRU;register file
     bist_val &= mask;
     if (bist_val)
     {
@@ -429,6 +430,17 @@ int cvmx_user_app_init(void)
     }
     CVMX_MT_CVM_MEM_CTL(tmp);
 
+    if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X))
+    {
+        /* Clear the lines of scratch memory configured, for
+        ** 63XX pass 2 errata Core-15169. */
+        uint64_t addr;
+        unsigned  num_lines;
+        CVMX_MF_CVM_MEM_CTL(tmp);
+        num_lines = tmp & 0x3f;
+        for (addr = 0; addr < CVMX_CACHE_LINE_SIZE * num_lines; addr += 8)
+            cvmx_scratch_write64(addr, 0);
+    }
 
 #if CVMX_USE_1_TO_1_TLB_MAPPINGS
 
diff --git a/simple_exec/cvmx-csr-db-support.c b/simple_exec/cvmx-csr-db-support.c
index 6850c31..1ee5f59 100644
--- a/simple_exec/cvmx-csr-db-support.c
+++ b/simple_exec/cvmx-csr-db-support.c
@@ -48,7 +48,7 @@
  *
  * Utility functions for working with the CSR database
  *
- * <hr>$Revision: 49507 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #define PRINTF printk
@@ -88,7 +88,7 @@ int cvmx_db_get_chipindex(int identifier)
         case 0x000d0700: /* CN52XX */
             return 10;
         case 0x000d9000: /* CN63XX */
-            return 11;
+            return 12;
     }
 
     /* Next try PCI device IDs */
@@ -115,7 +115,7 @@ int cvmx_db_get_chipindex(int identifier)
         case 0x0080177d: /* CN52XX Pass 2 */
             return 10;
         case 0x0090177d: /* CN63XX Pass 1 */
-            return 11;
+            return 12;
     }
 
     /* Default to Pass 3 if we don't know */
diff --git a/simple_exec/cvmx-dma-engine.c b/simple_exec/cvmx-dma-engine.c
index a3718bd..1deb51c 100644
--- a/simple_exec/cvmx-dma-engine.c
+++ b/simple_exec/cvmx-dma-engine.c
@@ -49,13 +49,27 @@
  * Interface to the PCI / PCIe DMA engines. These are only avialable
  * on chips with PCI / PCIe.
  *
- * <hr>$Revision: 50126 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <linux/module.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon-model.h>
+#include <asm/octeon/cvmx-config.h>
+#include <asm/octeon/cvmx-cmd-queue.h>
+#include <asm/octeon/cvmx-dma-engine.h>
+#include <asm/octeon/octeon-feature.h>
+#include <asm/octeon/cvmx-npi-defs.h>
+#include <asm/octeon/cvmx-npei-defs.h>
+#include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#else
 #include "executive-config.h"
 #include "cvmx-config.h"
 #include "cvmx.h"
 #include "cvmx-cmd-queue.h"
 #include "cvmx-dma-engine.h"
+#endif
 
 #ifdef CVMX_ENABLE_PKO_FUNCTIONS
 
diff --git a/simple_exec/cvmx-error-custom.c b/simple_exec/cvmx-error-custom.c
index 3aeaa0d..eb9b25f 100644
--- a/simple_exec/cvmx-error-custom.c
+++ b/simple_exec/cvmx-error-custom.c
@@ -140,6 +140,99 @@ static int __cvmx_error_handle_npei_int_sum_c1_ldwn(const struct cvmx_error_info
     return 1;
 }
 
+//#define DECODE_FAILING_ADDRESS
+
+/**
+ * @INTERNAL
+ * This error bit handler clears the status and prints failure infomation.
+ *
+ * @param info   Error register to check
+ *
+ * @return
+ */
+static int __cvmx_cn6xxx_lmc_ecc_error_display(const cvmx_error_info_t *info)
+{
+#ifdef DECODE_FAILING_ADDRESS
+    cvmx_lmcx_config_t lmc_config;
+    uint64_t fadr_physical, fadr_data;
+#endif
+
+    int ddr_controller = info->group_index;
+    cvmx_lmcx_int_t lmc_int;
+    cvmx_lmcx_fadr_t fadr;
+    cvmx_lmcx_ecc_synd_t ecc_synd;
+    int sec_err;
+    int ded_err;
+    int syndrome = -1;
+    int phase;
+
+    lmc_int.u64 = cvmx_read_csr(CVMX_LMCX_INT(ddr_controller));
+    fadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(ddr_controller));
+    ecc_synd.u64 = cvmx_read_csr(CVMX_LMCX_ECC_SYND(ddr_controller));
+    /* This assumes that all bits in the status register are RO or R/W1C */
+    cvmx_write_csr(info->status_addr, info->status_mask);
+
+#ifdef DECODE_FAILING_ADDRESS
+    lmc_config.u64 = cvmx_read_csr(CVMX_LMCX_CONFIG(ddr_controller));
+#endif
+
+    sec_err = lmc_int.s.sec_err;
+    ded_err = lmc_int.s.ded_err;
+
+    phase = ded_err ? ded_err : sec_err; /* Double bit errors take precedence. */
+
+    switch (phase) {
+    case 1:
+        syndrome = ecc_synd.cn63xx.mrdsyn0;
+        break;
+    case 2:
+        syndrome = ecc_synd.cn63xx.mrdsyn1;
+        break;
+    case 4:
+        syndrome = ecc_synd.cn63xx.mrdsyn2;
+        break;
+    case 8:
+        syndrome = ecc_synd.cn63xx.mrdsyn3;
+        break;
+    }
+
+#ifdef DECODE_FAILING_ADDRESS
+    fadr_physical  = (uint64_t)fadr.cn63xx.fdimm      << (lmc_config.s.pbank_lsb + 28);
+    fadr_physical |= (uint64_t)fadr.cn63xx.frow       << (lmc_config.s.row_lsb + 14);
+    fadr_physical |= (uint64_t)fadr.cn63xx.fbank      << 7;
+    fadr_physical |= (uint64_t)(fadr.cn63xx.fcol&0xf) << 3;
+    fadr_physical |= (uint64_t)(fadr.cn63xx.fcol>>4)  << 10;
+
+    fadr_data = *(uint64_t*)cvmx_phys_to_ptr(fadr_physical);
+#endif
+
+    PRINT_ERROR("LMC%d ECC: sec_err:%d ded_err:%d\n"
+                "LMC%d ECC:\tFailing dimm:   %u\n"
+                "LMC%d ECC:\tFailing rank:   %u\n"
+                "LMC%d ECC:\tFailing bank:   %u\n"
+                "LMC%d ECC:\tFailing row:    0x%x\n"
+                "LMC%d ECC:\tFailing column: 0x%x\n"
+                "LMC%d ECC:\tsyndrome: 0x%x\n"
+#ifdef DECODE_FAILING_ADDRESS
+                "Failing Address: 0x%016llx, Data: 0x%016llx\n"
+#endif
+                ,               /* Comma */
+                ddr_controller, sec_err, ded_err,
+                ddr_controller, fadr.cn63xx.fdimm,
+                ddr_controller, fadr.cn63xx.fbunk,
+                ddr_controller, fadr.cn63xx.fbank,
+                ddr_controller, fadr.cn63xx.frow,
+                ddr_controller, fadr.cn63xx.fcol,
+                ddr_controller, syndrome
+#ifdef DECODE_FAILING_ADDRESS
+                ,               /* Comma */
+                (unsigned long long) fadr_physical, (unsigned long long) fadr_data
+#endif
+                );
+
+    return 1;
+}
+
 /**
  * @INTERNAL
  * Some errors require more complicated error handing functions than the
@@ -150,6 +243,15 @@ static int __cvmx_error_handle_npei_int_sum_c1_ldwn(const struct cvmx_error_info
  */
 int __cvmx_error_custom_initialize(void)
 {
+    if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+    {
+        cvmx_error_change_handler(CVMX_ERROR_REGISTER_IO64,
+                            CVMX_LMCX_INT(0), 0xfull<<1 /* sec_err */,
+                            __cvmx_cn6xxx_lmc_ecc_error_display, 0, NULL, NULL);
+        cvmx_error_change_handler(CVMX_ERROR_REGISTER_IO64,
+                            CVMX_LMCX_INT(0), 0xfull<<5 /* ded_err */,
+                            __cvmx_cn6xxx_lmc_ecc_error_display, 0, NULL, NULL);
+    }
     if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN63XX))
     {
         cvmx_error_change_handler(CVMX_ERROR_REGISTER_IO64,
diff --git a/simple_exec/cvmx-error.c b/simple_exec/cvmx-error.c
index 2b77d4c..f2ff537 100644
--- a/simple_exec/cvmx-error.c
+++ b/simple_exec/cvmx-error.c
@@ -223,7 +223,7 @@ int __cvmx_error_display(const cvmx_error_info_t *info)
 int cvmx_error_initialize(cvmx_error_flags_t flags)
 {
     __cvmx_error_flags = flags;
-    if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_X))
+    if (OCTEON_IS_MODEL(OCTEON_CN63XX))
     {
         extern int cvmx_error_initialize_cn63xx(void);
         if (cvmx_error_initialize_cn63xx())
@@ -337,6 +337,9 @@ int cvmx_error_initialize(cvmx_error_flags_t flags)
     if (OCTEON_IS_MODEL(OCTEON_CN63XX))
         cvmx_write_csr(CVMX_PEXP_SLI_INT_SUM, 1);
 
+    /* Call poll once to clear out any pending interrupts */
+    cvmx_error_poll();
+
     return 0;
 }
 
diff --git a/simple_exec/cvmx-helper-board.c b/simple_exec/cvmx-helper-board.c
index c3179c1..14c684f 100644
--- a/simple_exec/cvmx-helper-board.c
+++ b/simple_exec/cvmx-helper-board.c
@@ -49,7 +49,7 @@
  * Helper functions to abstract board specific data about
  * network ports from the rest of the cvmx-helper files.
  *
- * <hr>$Revision: 49627 $<hr>
+ * <hr>$Revision: 54361 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/module.h>
@@ -233,6 +233,7 @@ int cvmx_helper_board_get_mii_address(int ipd_port)
             else
                 return -1;
         case CVMX_BOARD_TYPE_NIC_XLE_10G:
+        case CVMX_BOARD_TYPE_NIC10E:
             return -1;  /* We don't use clause 45 MDIO for anything */
         case CVMX_BOARD_TYPE_BBGW_REF:
             return -1;  /* No PHYs are connected to Octeon, everything is through switch */
diff --git a/simple_exec/cvmx-helper-errata.c b/simple_exec/cvmx-helper-errata.c
index 46655ca..a9a13e8 100644
--- a/simple_exec/cvmx-helper-errata.c
+++ b/simple_exec/cvmx-helper-errata.c
@@ -51,7 +51,7 @@
  * chip errata. For the most part, code doesn't need to call
  * these functions directly.
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 54712 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -302,6 +302,12 @@ int cvmx_helper_fix_ipd_packet_chain(cvmx_wqe_t *work)
 void __cvmx_helper_errata_qlm_disable_2nd_order_cdr(int qlm)
 {
     int lane;
+    /* Apply the workaround only once. */
+    cvmx_ciu_qlm_jtgd_t qlm_jtgd;
+    qlm_jtgd.u64 = cvmx_read_csr(CVMX_CIU_QLM_JTGD);
+    if (qlm_jtgd.s.select != 0)
+        return;
+
     cvmx_helper_qlm_jtag_init();
     /* We need to load all four lanes of the QLM, a total of 1072 bits */
     for (lane=0; lane<4; lane++)
diff --git a/simple_exec/cvmx-helper.c b/simple_exec/cvmx-helper.c
index 3d63704..19d1278 100644
--- a/simple_exec/cvmx-helper.c
+++ b/simple_exec/cvmx-helper.c
@@ -48,7 +48,7 @@
  *
  * Helper functions for common, but complicated tasks.
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <linux/module.h>
@@ -1172,6 +1172,16 @@ step2:
             pip_sft_rst.s.rst = 1;
             cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
         }
+
+        /* Make sure IPD has finished reset. */
+        if (OCTEON_IS_MODEL(OCTEON_CN6XXX))
+        {
+            if (CVMX_WAIT_FOR_FIELD64(CVMX_IPD_CTL_STATUS, cvmx_ipd_ctl_status_t, rst_done, ==, 0, 1000))
+            {
+                cvmx_dprintf("IPD reset timeout waiting for idle\n");
+                result = -1;
+            }
+        }
     }
 
     /* Step 11: Restore the FPA buffers into pool 0 */
diff --git a/simple_exec/cvmx-interrupt.c b/simple_exec/cvmx-interrupt.c
index 9280e8d..8858691 100644
--- a/simple_exec/cvmx-interrupt.c
+++ b/simple_exec/cvmx-interrupt.c
@@ -48,7 +48,7 @@
  *
  * Interface to the Mips interrupts.
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
 #ifndef __U_BOOT__
 #if __GNUC__ >= 4
@@ -396,20 +396,43 @@ void cvmx_interrupt_do_irq(uint64_t registers[35])
         CVMX_MF_CACHE_ERR(cache_err);
 
         /* Use copy of DCACHE_ERR register that early exception stub read */
-        if (registers[34] & 0x1)
+        if (OCTEON_IS_MODEL(OCTEON_CN3XXX) || OCTEON_IS_MODEL(OCTEON_CN5XXX))
         {
-            cvmx_safe_printf("Dcache error detected: core: %d, set: %d, va 6:3: 0x%x\n", i, (int)(cache_err >> 3) & 0x3, (int)(cache_err >> 3) & 0xf);
-            uint64_t dcache_err = 0;
-            CVMX_MT_DCACHE_ERR(dcache_err);
+            if (registers[34] & 0x1)
+                cvmx_safe_printf("Dcache error detected: core: %d, way: %d, va 7:3: 0x%x\n", i, (int)(registers[34] >> 8) & 0x3f, (int)(registers[34] >> 3) & 0x1f);
+            else if (cache_err & 0x1)
+                cvmx_safe_printf("Icache error detected: core: %d, set: %d, way : %d, va 6:3 = 0x%x\n", i, (int)(cache_err >> 5) & 0x3f, (int)(cache_err >> 3) & 0x3, (int)(cache_err >> 11) & 0xf);
+            else
+                cvmx_safe_printf("Cache error exception: core %d\n", i);
         }
-        else if (cache_err & 0x1)
+        else
         {
-            cvmx_safe_printf("Icache error detected: core: %d, set: %d, way : %d\n", i, (int)(cache_err >> 5) & 0x3f, (int)(cache_err >> 7) & 0x3);
-            cache_err = 0;
-            CVMX_MT_CACHE_ERR(cache_err);
+            if (registers[34] & 0x1)
+                cvmx_safe_printf("Dcache error detected: core: %d, way: %d, va 9:7: 0x%x\n", i, (int)(registers[34] >> 10) & 0x1f, (int)(registers[34] >> 7) & 0x3);
+            else if (cache_err & 0x1)
+                cvmx_safe_printf("Icache error detected: core: %d, way : %d, va 9:3 = 0x%x\n", i, (int)(cache_err >> 10) & 0x3f, (int)(cache_err >> 3) & 0x7f);
+            else
+                cvmx_safe_printf("Cache error exception: core %d\n", i);
+        }
+        CVMX_MT_DCACHE_ERR(1);
+        CVMX_MT_CACHE_ERR(0);
+    }
+
+    /* The bus error exceptions can occur due to DID timeout or write buffer,
+       check by reading COP0_CACHEERRD */
+    if (OCTEON_IS_MODEL(OCTEON_CN6XXX))
+    {
+        i = cvmx_get_core_num();
+        if (registers[34] & 0x4)
+        {
+            cvmx_safe_printf("Bus error detected due to DID timeout: core: %d\n", i);
+            CVMX_MT_DCACHE_ERR(4);
+        }
+        else if (registers[34] & 0x2)
+        {
+            cvmx_safe_printf("Bus error detected due to write buffer parity: core: %d\n", i);
+            CVMX_MT_DCACHE_ERR(2);
         }
-        else
-            cvmx_safe_printf("Cache error exception: core %d\n", i);
     }
 
     if ((cause & 0x7c) != 0)
diff --git a/simple_exec/cvmx-l2c.c b/simple_exec/cvmx-l2c.c
index e104509..d1089aa 100644
--- a/simple_exec/cvmx-l2c.c
+++ b/simple_exec/cvmx-l2c.c
@@ -49,7 +49,7 @@
  * Implementation of the Level 2 Cache (L2C) control,
  * measurement, and debugging facilities.
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  *
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -976,8 +976,51 @@ void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)
 }
 #endif
 
-#ifndef CVMX_BUILD_FOR_LINUX_HOST
+/**
+ * Initialize the BIG address in L2C+DRAM to generate proper error
+ * on reading/writing to an non-existant memory location.
+ *
+ * @param mem_size  Amount of DRAM configured in MB.
+ * @param mode      Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR].
+ */
+void cvmx_l2c_set_big_size(uint64_t mem_size, int mode)
+{
+    if (OCTEON_IS_MODEL(OCTEON_CN6XXX) && !OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+    {
+        cvmx_l2c_big_ctl_t big_ctl;
+        int bits = 0, zero_bits = 0;
+        uint64_t mem;
+
+        if (mem_size > (CVMX_L2C_MAX_MEMSZ_ALLOWED * 1024))
+        {
+            cvmx_dprintf("WARNING: Invalid memory size(%lld) requested, should be <= %lld\n",
+                (unsigned long long)mem_size, (unsigned long long)CVMX_L2C_MAX_MEMSZ_ALLOWED);
+            mem_size = CVMX_L2C_MAX_MEMSZ_ALLOWED * 1024;
+        }
+
+        mem = mem_size;
+        while (mem)
+        {
+            if ((mem & 1) == 0)
+                zero_bits++;
+            bits++;
+            mem >>= 1;
+        }
+
+        if ((bits - zero_bits) != 1 || (bits - 9) <= 0)
+        {
+            cvmx_dprintf("ERROR: Invalid DRAM size (%lld) requested, refer to L2C_BIG_CTL[maxdram] for valid options.\n", (unsigned long long)mem_size);
+            return;
+        }
+
+        big_ctl.u64 = 0;
+        big_ctl.s.maxdram = bits - 9;
+        big_ctl.s.disable = mode;
+        cvmx_write_csr(CVMX_L2C_BIG_CTL, big_ctl.u64);
+    }
+}
 
+#if !defined(CVMX_BUILD_FOR_LINUX_HOST) && !defined(CVMX_BUILD_FOR_LINUX_KERNEL)
 /* L2C Virtualization APIs. These APIs are based on Octeon II documentation. */
 
 /**
@@ -1087,9 +1130,9 @@ static inline int __cvmx_l2c_vrt_decode_memsize(int memsz)
 
     if (OCTEON_IS_MODEL(OCTEON_CN6XXX))
     {
-        if (memsz == 0 || memsz > CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED)
+        if (memsz == 0 || memsz > CVMX_L2C_MAX_MEMSZ_ALLOWED)
         {
-            cvmx_dprintf("WARNING: Invalid virtual memory size(%d) requested, should be <= %d\n", memsz, CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED);
+            cvmx_dprintf("WARNING: Invalid virtual memory size(%d) requested, should be <= %d\n", memsz, CVMX_L2C_MAX_MEMSZ_ALLOWED);
             return -1;
         }
 
diff --git a/simple_exec/cvmx-l2c.h b/simple_exec/cvmx-l2c.h
index 775f26f..51940dc 100644
--- a/simple_exec/cvmx-l2c.h
+++ b/simple_exec/cvmx-l2c.h
@@ -49,7 +49,7 @@
  * Interface to the Level 2 Cache (L2C) control, measurement, and debugging
  * facilities.
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 55343 $<hr>
  *
  */
 
@@ -71,7 +71,7 @@
 
 /* Defines for Virtualizations, valid only from Octeon II onwards. */
 #define CVMX_L2C_VRT_MAX_VIRTID_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 64 : 0)
-#define CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 32 : 0)
+#define CVMX_L2C_MAX_MEMSZ_ALLOWED ((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 32 : 0)
 
   /*------------*/
   /*  TYPEDEFS  */
@@ -389,6 +389,17 @@ int cvmx_l2c_get_num_assoc(void);
  */
 void cvmx_l2c_flush_line(uint32_t assoc, uint32_t index);
 
+/**
+ * Initialize the BIG address in L2C+DRAM to generate proper error
+ * on reading/writing to an non-existant memory location.
+ *
+ * @param mem_size  Amount of DRAM configured in MB.
+ * @param mode      Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR].
+ */
+void cvmx_l2c_set_big_size(uint64_t mem_size, int mode);
+
+#if !defined(CVMX_BUILD_FOR_LINUX_HOST) && !defined(CVMX_BUILD_FOR_LINUX_KERNEL)
+
 /*
  * Set maxium number of Virtual IDS allowed in a machine.
  *
@@ -451,4 +462,6 @@ void cvmx_l2c_vrt_enable(int mode);
  */
 void cvmx_l2c_vrt_disable(void);
 
+#endif /* CVMX_BUILD_FOR_LINUX_HOST */
+
 #endif /* __CVMX_L2C_H__ */
diff --git a/simple_exec/cvmx-mgmt-port.c b/simple_exec/cvmx-mgmt-port.c
index 108ef00..2e3f362 100644
--- a/simple_exec/cvmx-mgmt-port.c
+++ b/simple_exec/cvmx-mgmt-port.c
@@ -48,7 +48,7 @@
  *
  * Support functions for managing the MII management port
  *
- * <hr>$Revision: 49628 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
 #include "cvmx.h"
 #include "cvmx-bootmem.h"
@@ -363,6 +363,7 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 
             /* Enable the componsation controller */
             agl_prtx_ctl.s.comp = 1;
+            agl_prtx_ctl.s.drv_byp = 0;
             cvmx_write_csr(CVMX_AGL_PRTX_CTL(port), agl_prtx_ctl.u64);
             cvmx_read_csr(CVMX_AGL_PRTX_CTL(port));  /* Force write out before wait */
             cvmx_wait(1024 * clock_scale); // for componsation state to lock.
diff --git a/simple_exec/cvmx-pcie.c b/simple_exec/cvmx-pcie.c
index 8053737..42c0049 100644
--- a/simple_exec/cvmx-pcie.c
+++ b/simple_exec/cvmx-pcie.c
@@ -48,7 +48,7 @@
  *
  * Interface to PCIe as a host(RC) or target(EP)
  *
- * <hr>$Revision: 52004 $<hr>
+ * <hr>$Revision: 55482 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/cvmx.h>
@@ -982,6 +982,9 @@ static int __cvmx_pcie_rc_initialize_gen2(int pcie_port)
     if (pemx_bist_status.u64)
         cvmx_dprintf("PCIe: BIST FAILED for port %d (0x%016llx)\n", pcie_port, CAST64(pemx_bist_status.u64));
     pemx_bist_status2.u64 = cvmx_read_csr(CVMX_PEMX_BIST_STATUS2(pcie_port));
+    /* Errata PCIE-14766 may cause the lower 6 bits to be randomly set on CN63XXp1 */
+    if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+        pemx_bist_status2.u64 &= ~0x3full;
     if (pemx_bist_status2.u64)
         cvmx_dprintf("PCIe: BIST2 FAILED for port %d (0x%016llx)\n", pcie_port, CAST64(pemx_bist_status2.u64));
 
diff --git a/simple_exec/cvmx-srio.c b/simple_exec/cvmx-srio.c
index f8511c6..dc107ee 100644
--- a/simple_exec/cvmx-srio.c
+++ b/simple_exec/cvmx-srio.c
@@ -72,7 +72,6 @@
 #endif
 #endif
 
-#define CVMX_SRIO_USE_FIFO_FOR_MAINT    1
 #define CVMX_SRIO_CONFIG_TIMEOUT        10000 /* 10ms */
 #define CVMX_SRIO_DOORBELL_TIMEOUT      10000 /* 10ms */
 #define CVMX_SRIO_CONFIG_PRIORITY       0
@@ -376,6 +375,7 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
     cvmx_sriox_imsg_vport_thr_t sriox_imsg_vport_thr;
     cvmx_dpi_sli_prtx_cfg_t prt_cfg;
     cvmx_sli_s2m_portx_ctl_t sli_s2m_portx_ctl;
+    cvmx_sli_mem_access_ctl_t sli_mem_access_ctl;
 
     sriox_status_reg.u64 = cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
     if (!sriox_status_reg.s.srio)
@@ -410,6 +410,13 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
         }
     }
 
+    /* Don't receive or drive reset signals for the SRIO QLM */
+    mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
+    mio_rst_ctl.s.rst_drv = 0;
+    mio_rst_ctl.s.rst_rcv = 0;
+    mio_rst_ctl.s.rst_chip = 0;
+    cvmx_write_csr(CVMX_MIO_RST_CTLX(srio_port), mio_rst_ctl.u64);
+
     mio_rst_ctl.u64 = cvmx_read_csr(CVMX_MIO_RST_CTLX(srio_port));
     cvmx_dprintf("SRIO%d: Port in %s mode\n", srio_port,
         (mio_rst_ctl.s.prtmode) ? "host" : "endpoint");
@@ -481,19 +488,19 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
             return -1;
     }
 
-    /* Set the link layer timeout to 10us. The default is too high and causes
+    /* Set the link layer timeout to 1ms. The default is too high and causes
         core bus errors */
     if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), &port_lt_ctl.u32))
         return -1;
-    port_lt_ctl.s.timeout = 10000 / 200; /* 10us = 10000ns / 200ns */
+    port_lt_ctl.s.timeout = 1000000 / 200; /* 1ms = 1000000ns / 200ns */
     if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_LT_CTL(srio_port), port_lt_ctl.u32))
         return -1;
 
-    /* Set the logical layer timeout to 10ms. The default is too high and causes
+    /* Set the logical layer timeout to 100ms. The default is too high and causes
         core bus errors */
     if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), &port_rt_ctl.u32))
         return -1;
-    port_rt_ctl.s.timeout = 10000000 / 200; /* 10ms = 10000000ns / 200ns */
+    port_rt_ctl.s.timeout = 100000000 / 200; /* 100ms = 100000000ns / 200ns */
     if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_RT_CTL(srio_port), port_rt_ctl.u32))
         return -1;
 
@@ -562,6 +569,69 @@ int cvmx_srio_initialize(int srio_port, cvmx_srio_initialize_flags_t flags)
     if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_CTL(srio_port), port_0_ctl.u32))
         return -1;
 
+    /* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
+    sli_mem_access_ctl.u64 = cvmx_read_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL);
+    sli_mem_access_ctl.s.max_word = 0;     /* Allow 16 words to combine */
+    sli_mem_access_ctl.s.timer = 127;      /* Wait up to 127 cycles for more data */
+    cvmx_write_csr(CVMX_PEXP_SLI_MEM_ACCESS_CTL, sli_mem_access_ctl.u64);
+
+    /* Ask for a link and align our ACK state. CN63XXp1 didn't support this */
+    if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+    {
+        uint64_t stop_cycle;
+        cvmx_sriomaintx_port_0_err_stat_t sriomaintx_port_0_err_stat;
+
+        /* Wait a little to see if the link comes up */
+        stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/4 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+        do
+        {
+            /* Read the port link status */
+            if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+                CVMX_SRIOMAINTX_PORT_0_ERR_STAT(srio_port),
+                &sriomaintx_port_0_err_stat.u32))
+                return -1;
+        } while (!sriomaintx_port_0_err_stat.s.pt_ok && (cvmx_clock_get_count(CVMX_CLOCK_CORE) < stop_cycle));
+
+        /* Send link request if link is up */
+        if (sriomaintx_port_0_err_stat.s.pt_ok)
+        {
+            cvmx_sriomaintx_port_0_link_req_t link_req;
+            cvmx_sriomaintx_port_0_link_resp_t link_resp;
+            link_req.u32 = 0;
+            link_req.s.cmd = 4;
+
+            /* Send the request */
+            if (cvmx_srio_config_write32(srio_port, 0, -1, 0, 0,
+                CVMX_SRIOMAINTX_PORT_0_LINK_REQ(srio_port),
+                link_req.u32))
+                return -1;
+
+            /* Wait for the response */
+            stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/8 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+            do
+            {
+                if (cvmx_srio_config_read32(srio_port, 0, -1, 0, 0,
+                    CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port),
+                    &link_resp.u32))
+                    return -1;
+            } while (!link_resp.s.valid && (cvmx_clock_get_count(CVMX_CLOCK_CORE) < stop_cycle));
+
+            /* Set our ACK state if we got a response */
+            if (link_resp.s.valid)
+            {
+                cvmx_sriomaintx_port_0_local_ackid_t local_ackid;
+                local_ackid.u32 = 0;
+                local_ackid.s.i_ackid = 0;
+                local_ackid.s.e_ackid = link_resp.s.ackid;
+                local_ackid.s.o_ackid = link_resp.s.ackid;
+                if (cvmx_srio_config_write32(srio_port, 0, -1, 0, 0,
+                    CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port),
+                    local_ackid.u32))
+                    return -1;
+            }
+        }
+    }
+
     return 0;
 }
 
@@ -596,136 +666,141 @@ int cvmx_srio_config_read32(int srio_port, int srcid_index, int destid,
     }
     else
     {
-#if CVMX_SRIO_USE_FIFO_FOR_MAINT
-        int return_code;
-        uint32_t pkt = 0;
-        uint32_t sourceid;
-        uint64_t stop_cycle;
-        char rx_buffer[64];
+        if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+        {
+            int return_code;
+            uint32_t pkt = 0;
+            uint32_t sourceid;
+            uint64_t stop_cycle;
+            char rx_buffer[64];
 
-        /* Tell the user */
-        if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-            cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, (unsigned int)offset);
+            /* Tell the user */
+            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, (unsigned int)offset);
 
-        /* Read the proper source ID */
-        if (srcid_index)
-            __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
-        else
-            __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
+            /* Read the proper source ID */
+            if (srcid_index)
+                __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
+            else
+                __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
 
-        if (is16bit)
-        {
-            /* Use the 16bit source ID */
-            sourceid &= 0xffff;
-
-            /* MAINT Reads are 11 bytes */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 11<<16);
-
-            pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
-            pkt |= 1 << 28;                         /* tt       [29:28] */
-            pkt |= 0x8 << 24;                       /* ftype    [27:24] */
-            pkt |= destid << 8;                     /* destID   [23:8] */
-            pkt |= sourceid >> 8;                   /* sourceID [7:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= sourceid << 24;                  /* sourceID [31:24] */
-            pkt |= 0 << 20;                         /* transaction [23:20] */
-            pkt |= 8 << 16;                         /* rdsize [19:16] */
-            pkt |= 0xc0 << 8;                       /* srcTID [15:8] */
-            pkt |= hopcount;                        /* hopcount [7:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= offset << 8;                     /* offset [31:11, wdptr[10], reserved[9:8] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-        }
-        else
-        {
-            /* Use the 8bit source ID */
-            sourceid = (sourceid >> 16) & 0xff;
-
-            /* MAINT Reads are 9 bytes */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 9<<16);
-
-            pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
-            pkt |= 0 << 28;                         /* tt       [29:28] */
-            pkt |= 0x8 << 24;                       /* ftype    [27:24] */
-            pkt |= destid << 16;                    /* destID   [23:16] */
-            pkt |= sourceid << 8;                   /* sourceID [15:8] */
-            pkt |= 0 << 4;                          /* transaction [7:4] */
-            pkt |= 8 << 0;                          /* rdsize [3:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= 0xc0 << 24;                      /* srcTID [31:24] */
-            pkt |= hopcount << 16;                  /* hopcount [23:16] */
-            pkt |= offset >> 8;                     /* offset [15:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= offset << 24;                    /* offset [31:27, wdptr[26], reserved[25:24] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-        }
+            if (is16bit)
+            {
+                /* Use the 16bit source ID */
+                sourceid &= 0xffff;
 
-        stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/10 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
-        do
-        {
-            return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
-            if ((return_code == 0) && (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle))
+                /* MAINT Reads are 11 bytes */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 11<<16);
+
+                pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
+                pkt |= 1 << 28;                         /* tt       [29:28] */
+                pkt |= 0x8 << 24;                       /* ftype    [27:24] */
+                pkt |= destid << 8;                     /* destID   [23:8] */
+                pkt |= sourceid >> 8;                   /* sourceID [7:0] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                pkt = 0;
+                pkt |= sourceid << 24;                  /* sourceID [31:24] */
+                pkt |= 0 << 20;                         /* transaction [23:20] */
+                pkt |= 8 << 16;                         /* rdsize [19:16] */
+                pkt |= 0xc0 << 8;                       /* srcTID [15:8] */
+                pkt |= hopcount;                        /* hopcount [7:0] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                pkt = 0;
+                pkt |= offset << 8;                     /* offset [31:11, wdptr[10], reserved[9:8] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+            }
+            else
             {
-                if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-                    cvmx_dprintf("timeout\n");
-                return_code = -1;
+                /* Use the 8bit source ID */
+                sourceid = (sourceid >> 16) & 0xff;
+
+                /* MAINT Reads are 9 bytes */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 9<<16);
+
+                pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
+                pkt |= 0 << 28;                         /* tt       [29:28] */
+                pkt |= 0x8 << 24;                       /* ftype    [27:24] */
+                pkt |= destid << 16;                    /* destID   [23:16] */
+                pkt |= sourceid << 8;                   /* sourceID [15:8] */
+                pkt |= 0 << 4;                          /* transaction [7:4] */
+                pkt |= 8 << 0;                          /* rdsize [3:0] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                pkt = 0;
+                pkt |= 0xc0 << 24;                      /* srcTID [31:24] */
+                pkt |= hopcount << 16;                  /* hopcount [23:16] */
+                pkt |= offset >> 8;                     /* offset [15:0] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                pkt = 0;
+                pkt |= offset << 24;                    /* offset [31:27, wdptr[26], reserved[25:24] */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
             }
-        } while (return_code == 0);
 
-        if (return_code == ((is16bit) ? 23 : 19))
-        {
-            if (is16bit)
+            stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/10 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+            do
             {
-                if (offset & 4)
-                    *result = *(uint32_t*)(rx_buffer + 15);
+                return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
+                if ((return_code == 0) && (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle))
+                {
+                    if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                        cvmx_dprintf("timeout\n");
+                    return_code = -1;
+                }
+            } while (return_code == 0);
+
+            if (return_code == ((is16bit) ? 23 : 19))
+            {
+                if (is16bit)
+                {
+                    if (offset & 4)
+                        *result = *(uint32_t*)(rx_buffer + 15);
+                    else
+                        *result = *(uint32_t*)(rx_buffer + 11);
+                }
                 else
-                    *result = *(uint32_t*)(rx_buffer + 11);
+                {
+                    if (offset & 4)
+                        *result = *(uint32_t*)(rx_buffer + 13);
+                    else
+                        *result = *(uint32_t*)(rx_buffer + 9);
+                }
+                if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                    cvmx_dprintf("0x%08x\n", (unsigned int)*result);
+                return_code = 0;
             }
             else
             {
-                if (offset & 4)
-                    *result = *(uint32_t*)(rx_buffer + 13);
-                else
-                    *result = *(uint32_t*)(rx_buffer + 9);
+                *result = 0xffffffff;
+                return_code = -1;
             }
-            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-                cvmx_dprintf("0x%08x\n", (unsigned int)*result);
-            return_code = 0;
+
+            return return_code;
         }
         else
         {
-            *result = 0xffffffff;
-            return_code = -1;
-        }
-
-        return return_code;
-#elif !defined(CVMX_BUILD_FOR_LINUX_HOST)
-        uint64_t physical;
-        physical = cvmx_srio_physical_map(srio_port,
-            CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
-            CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
-            srcid_index, destid, is16bit, offset + (hopcount<<24), 4);
-        if (!physical)
-            return -1;
+#if !defined(CVMX_BUILD_FOR_LINUX_HOST)
+            uint64_t physical;
+            physical = cvmx_srio_physical_map(srio_port,
+                CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+                CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+                srcid_index, destid, is16bit, offset + (hopcount<<24), 4);
+            if (!physical)
+                return -1;
 
-        if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-            cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, offset);
+            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                cvmx_dprintf("SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x] <= ", srio_port, destid, hopcount, offset);
 
-        /* Finally do the maintenance read to complete the config request */
-        *result = cvmx_read64_uint32(CVMX_ADD_IO_SEG(physical));
-        cvmx_srio_physical_unmap(physical, 4);
+            /* Finally do the maintenance read to complete the config request */
+            *result = cvmx_read64_uint32(CVMX_ADD_IO_SEG(physical));
+            cvmx_srio_physical_unmap(physical, 4);
 
-        if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-            cvmx_dprintf("0x%08x\n", *result);
+            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                cvmx_dprintf("0x%08x\n", *result);
 
-        return 0;
+            return 0;
 #else
-        return -1;
+            return -1;
 #endif
+        }
     }
 }
 
@@ -758,142 +833,147 @@ int cvmx_srio_config_write32(int srio_port, int srcid_index, int destid,
     }
     else
     {
-#if CVMX_SRIO_USE_FIFO_FOR_MAINT
-        int return_code;
-        uint32_t pkt = 0;
-        uint32_t sourceid;
-        uint64_t stop_cycle;
-        char rx_buffer[64];
-
-        /* Tell the user */
-        if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-            cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, (unsigned int)offset, (unsigned int)data);
+        if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+        {
+            int return_code;
+            uint32_t pkt = 0;
+            uint32_t sourceid;
+            uint64_t stop_cycle;
+            char rx_buffer[64];
 
-        /* Read the proper source ID */
-        if (srcid_index)
-            __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
-        else
-            __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
+            /* Tell the user */
+            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, (unsigned int)offset, (unsigned int)data);
 
-        if (is16bit)
-        {
-            /* Use the 16bit source ID */
-            sourceid &= 0xffff;
-
-            /* MAINT Writes are 19 bytes */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 19<<16);
-
-            pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
-            pkt |= 1 << 28;                         /* tt       [29:28] */
-            pkt |= 0x8 << 24;                       /* ftype    [27:24] */
-            pkt |= destid << 8;                     /* destID   [23:8] */
-            pkt |= sourceid >> 8;                   /* sourceID [7:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= sourceid << 24;                  /* sourceID [31:24] */
-            pkt |= 1 << 20;                         /* transaction [23:20] */
-            pkt |= 8 << 16;                         /* wrsize [19:16] */
-            pkt |= 0xc0 << 8;                       /* srcTID [15:8] */
-            pkt |= hopcount;                        /* hopcount [7:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= offset << 8;                     /* offset [31:11, wdptr[10], reserved[9:8] */
-            if ((offset & 4) == 0)
-                pkt |= 0xff & (data >> 24);       /* data [7:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            if (offset & 4)
-            {
-                pkt = 0xff & (data >> 24);
-                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                pkt = data << 8;
-                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            }
+            /* Read the proper source ID */
+            if (srcid_index)
+                __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_SEC_DEV_ID(srio_port), &sourceid);
             else
+                __cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PRI_DEV_ID(srio_port), &sourceid);
+
+            if (is16bit)
             {
-                pkt = data << 8;
-                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
-            }
-        }
-        else
-        {
-            /* Use the 8bit source ID */
-            sourceid = (sourceid >> 16) & 0xff;
-
-            /* MAINT Writes are 17 bytes */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 17<<16);
-
-            pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
-            pkt |= 0 << 28;                         /* tt       [29:28] */
-            pkt |= 0x8 << 24;                       /* ftype    [27:24] */
-            pkt |= destid << 16;                    /* destID   [23:16] */
-            pkt |= sourceid << 8;                   /* sourceID [15:8] */
-            pkt |= 1 << 4;                          /* transaction [7:4] */
-            pkt |= 8 << 0;                          /* wrsize [3:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= 0xc0 << 24;                      /* srcTID [31:24] */
-            pkt |= hopcount << 16;                  /* hopcount [23:16] */
-            pkt |= offset >> 8;                     /* offset [15:0] */
-            __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-            pkt = 0;
-            pkt |= offset << 24;                    /* offset [31:27, wdptr[26], reserved[25:24] */
-            if (offset & 4)
-            {
+                /* Use the 16bit source ID */
+                sourceid &= 0xffff;
+
+                /* MAINT Writes are 19 bytes */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 19<<16);
+
+                pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
+                pkt |= 1 << 28;                         /* tt       [29:28] */
+                pkt |= 0x8 << 24;                       /* ftype    [27:24] */
+                pkt |= destid << 8;                     /* destID   [23:8] */
+                pkt |= sourceid >> 8;                   /* sourceID [7:0] */
                 __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                pkt = data >> 8;
+                pkt = 0;
+                pkt |= sourceid << 24;                  /* sourceID [31:24] */
+                pkt |= 1 << 20;                         /* transaction [23:20] */
+                pkt |= 8 << 16;                         /* wrsize [19:16] */
+                pkt |= 0xc0 << 8;                       /* srcTID [15:8] */
+                pkt |= hopcount;                        /* hopcount [7:0] */
                 __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                pkt = data << 24;
+                pkt = 0;
+                pkt |= offset << 8;                     /* offset [31:11, wdptr[10], reserved[9:8] */
+                if ((offset & 4) == 0)
+                    pkt |= 0xff & (data >> 24);       /* data [7:0] */
                 __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                if (offset & 4)
+                {
+                    pkt = 0xff & (data >> 24);
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    pkt = data << 8;
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                }
+                else
+                {
+                    pkt = data << 8;
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
+                }
             }
             else
             {
-                pkt |= data >> 8;                    /* data [23:0] */
+                /* Use the 8bit source ID */
+                sourceid = (sourceid >> 16) & 0xff;
+
+                /* MAINT Writes are 17 bytes */
+                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_CTRL(srio_port), 17<<16);
+
+                pkt |= CVMX_SRIO_CONFIG_PRIORITY << 30; /* priority [31:30] */
+                pkt |= 0 << 28;                         /* tt       [29:28] */
+                pkt |= 0x8 << 24;                       /* ftype    [27:24] */
+                pkt |= destid << 16;                    /* destID   [23:16] */
+                pkt |= sourceid << 8;                   /* sourceID [15:8] */
+                pkt |= 1 << 4;                          /* transaction [7:4] */
+                pkt |= 8 << 0;                          /* wrsize [3:0] */
                 __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                pkt = data << 24;                    /* data [31:24] */
+                pkt = 0;
+                pkt |= 0xc0 << 24;                      /* srcTID [31:24] */
+                pkt |= hopcount << 16;                  /* hopcount [23:16] */
+                pkt |= offset >> 8;                     /* offset [15:0] */
                 __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
-                __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
+                pkt = 0;
+                pkt |= offset << 24;                    /* offset [31:27, wdptr[26], reserved[25:24] */
+                if (offset & 4)
+                {
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    pkt = data >> 8;
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    pkt = data << 24;
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                }
+                else
+                {
+                    pkt |= data >> 8;                    /* data [23:0] */
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    pkt = data << 24;                    /* data [31:24] */
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), pkt);
+                    __cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_IR_SP_TX_DATA(srio_port), 0);
+                }
             }
-        }
 
-        stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/10 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
-        do
-        {
-            return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
-            if ((return_code == 0) && (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle))
+            stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/10 + cvmx_clock_get_count(CVMX_CLOCK_CORE);
+            do
             {
-                if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-                    cvmx_dprintf("timeout\n");
+                return_code = cvmx_srio_receive_spf(srio_port, rx_buffer, sizeof(rx_buffer));
+                if ((return_code == 0) && (cvmx_clock_get_count(CVMX_CLOCK_CORE) > stop_cycle))
+                {
+                    if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                        cvmx_dprintf("timeout\n");
+                    return_code = -1;
+                }
+            } while (return_code == 0);
+
+            if (return_code == ((is16bit) ? 15 : 11))
+                return_code = 0;
+            else
+            {
+                cvmx_dprintf("SRIO%d: Remote write failed\n", srio_port);
                 return_code = -1;
             }
-        } while (return_code == 0);
 
-        if (return_code == ((is16bit) ? 15 : 11))
-            return_code = 0;
+            return return_code;
+        }
         else
         {
-            cvmx_dprintf("SRIO%d: Remote write failed\n", srio_port);
-            return_code = -1;
-        }
+#if !defined(CVMX_BUILD_FOR_LINUX_HOST)
+            uint64_t physical = cvmx_srio_physical_map(srio_port,
+                    CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+                    CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
+                    srcid_index, destid, is16bit, offset + (hopcount<<24), 4);
+            if (!physical)
+                return -1;
 
-        return return_code;
-#elif !defined(CVMX_BUILD_FOR_LINUX_HOST)
-        uint64_t physical = cvmx_srio_physical_map(srio_port,
-                CVMX_SRIO_WRITE_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
-                CVMX_SRIO_READ_MODE_MAINTENANCE, CVMX_SRIO_CONFIG_PRIORITY,
-                srcid_index, destid, is16bit, offset + (hopcount<<24), 4);
-        if (!physical)
-            return -1;
-
-        if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
-            cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, offset, data);
+            if (__cvmx_srio_state[srio_port].flags & CVMX_SRIO_INITIALIZE_DEBUG)
+                cvmx_dprintf("SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n", srio_port, destid, hopcount, offset, data);
 
-        /* Finally do the maintenance write to complete the config request */
-        cvmx_write64_uint32(CVMX_ADD_IO_SEG(physical), data);
-        return cvmx_srio_physical_unmap(physical, 4);
+            /* Finally do the maintenance write to complete the config request */
+            cvmx_write64_uint32(CVMX_ADD_IO_SEG(physical), data);
+            return cvmx_srio_physical_unmap(physical, 4);
 #else
-        return -1;
+            return -1;
 #endif
+        }
     }
 }
 
@@ -1141,7 +1221,7 @@ uint64_t cvmx_srio_physical_map(int srio_port, cvmx_srio_write_mode_t write_op,
     /* Build the needed SubID config */
     needed_subid.u64 = 0;
     needed_subid.s.port = srio_port;
-    needed_subid.s.nmerge = 1;
+    needed_subid.s.nmerge = 0;
 
     /* FIXME: We might want to use the device ID swapping modes so the device
         ID is part of the lower address bits. This would allow many more
diff --git a/simple_exec/cvmx-tra.c b/simple_exec/cvmx-tra.c
index e1585ec..9c7b268 100644
--- a/simple_exec/cvmx-tra.c
+++ b/simple_exec/cvmx-tra.c
@@ -302,6 +302,7 @@ static uint64_t __cvmx_tra_set_filter_cmd_mask(cvmx_tra_filt_t filter)
 
         filter_command.cn63xx.reserved_60_61 = 0;
         filter_command.cn63xx.reserved_56_57 = 0;
+        filter_command.cn63xx.reserved_27_27 = 0;
         filter_command.cn63xx.reserved_10_14 = 0;
         filter_command.cn63xx.reserved_6_7 = 0;
     }
@@ -334,6 +335,21 @@ void cvmx_tra_setup(cvmx_tra_ctl_t control, cvmx_tra_filt_t filter,
     filt_sid.u64 = source_filter & CVMX_TRA_SOURCE_MASK;
     filt_did.u64 = dest_filter & CVMX_TRA_DESTINATION_MASK;
 
+    /* Address filtering does not work when IOBDMA filter command is enabled
+       because of some caveats.  Disable the IOBDMA filter command. */
+    if (OCTEON_IS_MODEL(OCTEON_CN6XXX)
+        && ((filt_cmd.u64 & CVMX_TRA_FILT_IOBDMA) == CVMX_TRA_FILT_IOBDMA)
+        && address_mask != 0)
+    {
+        cvmx_dprintf("The address-based filtering does not work with IOBDMAs, disabling the filter command.\n");
+        filt_cmd.u64 &= ~(CVMX_TRA_FILT_IOBDMA);
+    }
+
+    /* In OcteonII pass2, the mode bit is added to enable reading the trace
+       buffer data from different registers for lower and upper 64-bit value.
+       This bit is reserved in other Octeon models. */
+    control.s.rdat_md = 1;
+
     cvmx_write_csr(CVMX_TRA_CTL,            control.u64);
     cvmx_write_csr(CVMX_TRA_FILT_CMD,       filt_cmd.u64);
     cvmx_write_csr(CVMX_TRA_FILT_SID,       filt_sid.u64);
@@ -372,6 +388,16 @@ void cvmx_tra_trig_setup(uint64_t trigger, cvmx_tra_filt_t filter,
     tra_filt_sid.u64 = source_filter & CVMX_TRA_SOURCE_MASK;
     tra_filt_did.u64 = dest_filter & CVMX_TRA_DESTINATION_MASK;
 
+    /* Address filtering does not work when IOBDMA filter command is enabled
+       because of some caveats.  Disable the IOBDMA filter command. */
+    if (OCTEON_IS_MODEL(OCTEON_CN6XXX)
+        && ((tra_filt_cmd.u64 & CVMX_TRA_FILT_IOBDMA) == CVMX_TRA_FILT_IOBDMA)
+        && address_mask != 0)
+    {
+        cvmx_dprintf("The address-based filtering does not work with IOBDMAs, disabling the filter command.\n");
+        tra_filt_cmd.u64 &= ~(CVMX_TRA_FILT_IOBDMA);
+    }
+
     cvmx_write_csr(CVMX_TRA_TRIG0_CMD + trigger * 64,       tra_filt_cmd.u64);
     cvmx_write_csr(CVMX_TRA_TRIG0_SID + trigger * 64,       tra_filt_sid.u64);
     cvmx_write_csr(CVMX_TRA_TRIG0_DID + trigger * 64,       tra_filt_did.u64);
@@ -393,14 +419,21 @@ cvmx_tra_data_t cvmx_tra_read(void)
     uint64_t address = CVMX_TRA_READ_DAT;
     cvmx_tra_data_t result;
 
-    /* The trace buffer format is wider than 64-bits in Octeon2 model,
+    /* The trace buffer format is wider than 64-bits in OcteonII model,
        read the register again to get the second part of the data. */
-    if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) && !OCTEON_IS_MODEL(OCTEON_CN5XXX))
+    if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
     {
         /* These reads need to be as close as possible to each other */
         result.u128.data = cvmx_read_csr(address);
         result.u128.datahi = cvmx_read_csr(address);
     }
+    else if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) && !OCTEON_IS_MODEL(OCTEON_CN5XXX))
+    {
+        /* OcteonII pass2 uses different trace buffer data register for reading
+           lower and upper 64-bit values */
+        result.u128.data = cvmx_read_csr(address);
+        result.u128.datahi = cvmx_read_csr(CVMX_TRA_READ_DAT_HI);
+    }
     else
     {
         result.u128.data = cvmx_read_csr(address);
diff --git a/simple_exec/cvmx-tra.h b/simple_exec/cvmx-tra.h
index 74f6192..8a91782 100644
--- a/simple_exec/cvmx-tra.h
+++ b/simple_exec/cvmx-tra.h
@@ -152,9 +152,10 @@
  * - Fields marked as '*' are first filled with '0' at XMC time and may be filled with real data later at XMD time.  Note that the
  * XMD write may be dropped if the shallow FIFO overflows which leaves the '*' fields as '0'.
  * - 2 bits (sta) are used not to trace, but to return global state information with each read, encoded as follows:
- * 0x0-0x1=not valid
- * 0x2=valid, no discontinuity
- * 0x3=valid,    discontinuity
+ * 0x0=not valid
+ * 0x1=valid, no discontinuity
+ * 0x2=not valid, discontinuity
+ * 0x3=valid, discontinuity
  * - commands are encoded as follows:
  * 0x0=DWB
  * 0x1=PL2
@@ -218,7 +219,7 @@
  * 13-31 = illegal
  * @endverbatim
  *
- * <hr>$Revision: 49484 $<hr>
+ * <hr>$Revision: 54721 $<hr>
  */
 
 #ifndef __CVMX_TRA_H__
@@ -478,8 +479,8 @@ typedef union
     {
 #if __BYTE_ORDER == __BIG_ENDIAN
         uint64_t    reserved1   : 59;
-        uint64_t    valid       : 1;
         uint64_t    discontinuity:1;
+        uint64_t    valid       : 1;
         uint64_t    addresshi   : 3;   /* Split the address to fit in upper 64 bits  */
         uint64_t    addresslo   : 35;  /* and lower 64-bits. */
         uint64_t    reserved    : 10;
@@ -493,8 +494,8 @@ typedef union
         uint64_t    reserved    : 10;
         uint64_t    addresslo   : 35;
         uint64_t    addresshi   : 3;
-        uint64_t    discontinuity:1;
         uint64_t    valid       : 1;
+        uint64_t    discontinuity:1;
         uint64_t    reserved1   : 59;
 #endif
     } cmn2; /**< for LDT, LDI, PL2, RPL2, DWB, WBL2, SET*, CLR*, INCR*, DECR* */
@@ -502,8 +503,8 @@ typedef union
     {
 #if __BYTE_ORDER == __BIG_ENDIAN
         uint64_t    reserved1   : 59;
-        uint64_t    valid       : 1;
         uint64_t    discontinuity:1;
+        uint64_t    valid       : 1;
         uint64_t    addresshi   : 3;   /* Split the address to fit in upper 64 bits  */
         uint64_t    addresslo   : 35;  /* and lower 64-bits */
         uint64_t    reserved    : 2;
@@ -519,8 +520,8 @@ typedef union
         uint64_t    reserved    : 2;
         uint64_t    addresslo   : 35;
         uint64_t    addresshi   : 3;
-        uint64_t    discontinuity:1;
         uint64_t    valid       : 1;
+        uint64_t    discontinuity:1;
         uint64_t    reserved1   : 59;
 #endif
     } store2; /**< for STC, STF, STP, STT, LDD, PSL1, SAA32, SAA64, FAA32, FAA64, FAS32, FAS64 */
@@ -528,8 +529,8 @@ typedef union
     {
 #if __BYTE_ORDER == __BIG_ENDIAN
         uint64_t    reserved1   : 59;
-        uint64_t    valid       : 1;
         uint64_t    discontinuity:1;
+        uint64_t    valid       : 1;
         uint64_t    addresshi   : 3;   /* Split the address to fit in upper 64 bits  */
         uint64_t    addresslo   : 35;  /* and lower 64-bits */
         uint64_t    reserved    : 2;
@@ -547,8 +548,8 @@ typedef union
         uint64_t    reserved    : 2;
         uint64_t    addresslo   : 35;
         uint64_t    addresshi   : 3;
-        uint64_t    discontinuity:1;
         uint64_t    valid       : 1;
+        uint64_t    discontinuity:1;
         uint64_t    reserved1   : 59;
 #endif
     } iobld2; /**< for IOBLD8, IOBLD16, IOBLD32, IOBLD64, IOBST64, IOBST32, IOBST16, IOBST8 */
@@ -556,8 +557,8 @@ typedef union
     {
 #if __BYTE_ORDER == __BIG_ENDIAN
         uint64_t    reserved1   : 59;
-        uint64_t    valid       : 1;
         uint64_t    discontinuity:1;
+        uint64_t    valid       : 1;
         uint64_t    addresshi   : 3;   /* Split the address to fit in upper 64 bits  */
         uint64_t    addresslo   : 32;  /* and lower 64-bits */
         uint64_t    mask        : 8;
@@ -573,8 +574,8 @@ typedef union
         uint64_t    mask        : 8;
         uint64_t    addresslo   : 32;
 	uint64_t    addresshi   : 3;
-        uint64_t    discontinuity:1;
         uint64_t    valid       : 1;
+        uint64_t    discontinuity:1;
         uint64_t    reserved1   : 59;
 #endif
     } iob2; /**< for IOBDMA */
diff --git a/simple_exec/cvmx-twsi.c b/simple_exec/cvmx-twsi.c
index 30e8081..4dc36ab 100644
--- a/simple_exec/cvmx-twsi.c
+++ b/simple_exec/cvmx-twsi.c
@@ -48,7 +48,7 @@
  *
  * Interface to the TWSI / I2C bus
  *
- * <hr>$Revision: 49448 $<hr>
+ * <hr>$Revision: 53154 $<hr>
  *
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
@@ -171,10 +171,11 @@ int cvmx_twsix_read_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, in
 #else
 	cvmx_mio_twsx_sw_twsi_t sw_twsi_val;
 	cvmx_mio_twsx_sw_twsi_ext_t twsi_ext;
+        int retry_limit = 5;
 
 	if (num_bytes < 1 || num_bytes > 8 || !data || ia_width_bytes < 0 || ia_width_bytes > 2)
 		return -1;
-
+retry:
 	twsi_ext.u64 = 0;
 	sw_twsi_val.u64 = 0;
 	sw_twsi_val.s.v = 1;
@@ -197,11 +198,33 @@ int cvmx_twsix_read_ia(int twsi_id, uint8_t dev_addr, uint16_t internal_addr, in
 	cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	cvmx_write_csr(CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	while (((cvmx_mio_twsx_sw_twsi_t)(sw_twsi_val.u64 = cvmx_read_csr(CVMX_MIO_TWSX_SW_TWSI(twsi_id)))).s.v)
-		;
+		cvmx_wait(1000);
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	if (!sw_twsi_val.s.r)
-		return -1;
+        {
+            /* Check the reason for the failure.  We may need to retry to handle multi-master
+            ** configurations.
+            ** Lost arbitration : 0x38, 0x68, 0xB0, 0x78
+            ** Core busy as slave: 0x80, 0x88, 0xA0, 0xA8, 0xB8, 0xC0, 0xC8
+            */
+            if (sw_twsi_val.s.d == 0x38
+                || sw_twsi_val.s.d == 0x68
+                || sw_twsi_val.s.d == 0xB0
+                || sw_twsi_val.s.d == 0x78
+                || sw_twsi_val.s.d == 0x80
+                || sw_twsi_val.s.d == 0x88
+                || sw_twsi_val.s.d == 0xA0
+                || sw_twsi_val.s.d == 0xA8
+                || sw_twsi_val.s.d == 0xB8
+                || sw_twsi_val.s.d == 0xC8)
+            {
+                if (retry_limit-- > 0)
+                    goto retry;
+            }
+            /* For all other errors, return an error code */
+            return -1;
+        }
 
 	*data = (sw_twsi_val.s.d & (0xFFFFFFFF >> (32 - num_bytes*8)));
 	if (num_bytes > 4) {
@@ -265,10 +288,11 @@ int cvmx_twsix_read(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t *data
 #else
 	cvmx_mio_twsx_sw_twsi_t sw_twsi_val;
 	cvmx_mio_twsx_sw_twsi_ext_t twsi_ext;
+        int retry_limit = 5;
 
 	if (num_bytes > 8 || num_bytes < 1)
 		return -1;
-
+retry:
 	sw_twsi_val.u64 = 0;
 	sw_twsi_val.s.v = 1;
 	sw_twsi_val.s.r = 1;
@@ -279,11 +303,34 @@ int cvmx_twsix_read(int twsi_id, uint8_t dev_addr, int num_bytes, uint64_t *data
 	cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	cvmx_write_csr(CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	while (((cvmx_mio_twsx_sw_twsi_t)(sw_twsi_val.u64 = cvmx_read_csr(CVMX_MIO_TWSX_SW_TWSI(twsi_id)))).s.v)
-		;
+            cvmx_wait(1000);
 	twsi_printf("Results:\n");
 	cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_MIO_TWSX_SW_TWSI(twsi_id), sw_twsi_val.u64);
 	if (!sw_twsi_val.s.r)
-		return -1;
+            if (!sw_twsi_val.s.r)
+            {
+                /* Check the reason for the failure.  We may need to retry to handle multi-master
+                ** configurations.
+                ** Lost arbitration : 0x38, 0x68, 0xB0, 0x78
+                ** Core busy as slave: 0x80, 0x88, 0xA0, 0xA8, 0xB8, 0xC0, 0xC8
+                */
+                if (sw_twsi_val.s.d == 0x38
+                    || sw_twsi_val.s.d == 0x68
+                    || sw_twsi_val.s.d == 0xB0
+                    || sw_twsi_val.s.d == 0x78
+                    || sw_twsi_val.s.d == 0x80
+                    || sw_twsi_val.s.d == 0x88
+                    || sw_twsi_val.s.d == 0xA0
+                    || sw_twsi_val.s.d == 0xA8
+                    || sw_twsi_val.s.d == 0xB8
+                    || sw_twsi_val.s.d == 0xC8)
+                {
+                    if (retry_limit-- > 0)
+                        goto retry;
+                }
+                /* For all other errors, return an error code */
+                return -1;
+            }
 
 	*data = (sw_twsi_val.s.d & (0xFFFFFFFF >> (32 - num_bytes*8)));
 	if (num_bytes > 4) {
diff --git a/simple_exec/cvmx-version.h b/simple_exec/cvmx-version.h
index c4901b2..9dd2c75 100644
--- a/simple_exec/cvmx-version.h
+++ b/simple_exec/cvmx-version.h
@@ -44,5 +44,5 @@
 **     10.9.0 == 10.09.00 > 09.10.00 == 9.10.0 
 ** 
 */ 
-#define OCTEON_SDK_VERSION_NUM  200000366ull
-#define OCTEON_SDK_VERSION_STRING   "Cavium Networks Octeon SDK version 2.0.0, build 366"
+#define OCTEON_SDK_VERSION_NUM  200000373ull
+#define OCTEON_SDK_VERSION_STRING   "Cavium Networks Octeon SDK version 2.0.0-p4, build 373"
diff --git a/simple_exec/octeon-model.c b/simple_exec/octeon-model.c
index 337d9d7..cc323e7 100644
--- a/simple_exec/octeon-model.c
+++ b/simple_exec/octeon-model.c
@@ -49,7 +49,7 @@
  * File defining functions for working with different Octeon
  * models.
  *
- * <hr>$Revision: 49922 $<hr>
+ * <hr>$Revision: 54797 $<hr>
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 #include <asm/octeon/octeon.h>
@@ -329,6 +329,9 @@ const char *octeon_model_get_string_buffer(uint32_t chip_id, char * buffer)
                     suffix = "NSP";
                     if (fus_dat3.s.nozip)
                         suffix = "SCP";
+
+                    if (fus_dat3.s.bar2_en)
+                        suffix = "NSPB2";
                 }
                 if (fus3.cn56xx.crip_1024k)
                     family = "54";
diff --git a/simple_exec/octeon-model.h b/simple_exec/octeon-model.h
index 9ad98a1..4380ee7 100644
--- a/simple_exec/octeon-model.h
+++ b/simple_exec/octeon-model.h
@@ -48,7 +48,7 @@
  * File defining different Octeon model IDs and macros to
  * compare them.
  *
- * <hr>$Revision: 52119 $<hr>
+ * <hr>$Revision: 55342 $<hr>
  */
 
 #ifndef __OCTEON_MODEL_H__
@@ -101,7 +101,7 @@ extern "C" {
 #define OCTEON_CN63XX_PASS1_2   0x000d9002
 #define OCTEON_CN63XX_PASS2_0   0x000d9008
 
-#define OCTEON_CN63XX           (OCTEON_CN63XX_PASS1_0 | OM_IGNORE_REVISION)
+#define OCTEON_CN63XX           (OCTEON_CN63XX_PASS2_0 | OM_IGNORE_REVISION)
 #define OCTEON_CN63XX_PASS1_X   (OCTEON_CN63XX_PASS1_0 | OM_IGNORE_MINOR_REVISION)
 #define OCTEON_CN63XX_PASS2_X   (OCTEON_CN63XX_PASS2_0 | OM_IGNORE_MINOR_REVISION)
 
-- 
1.7.0.4

