From 74206fd40d4ea3a767b6a4a56c5019b816f3e237 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Mon, 15 Nov 2010 14:19:54 +0800
Subject: [PATCH 085/132] RapidIO: Octeon: Add locking necessary to protect MAINT register access.

Signed-off-by: Chad Reese <kreese@caviumnetworks.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/octeon-rapidio.c |  154 ++++++++++++++++++++++--------
 1 files changed, 114 insertions(+), 40 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-rapidio.c b/arch/mips/cavium-octeon/octeon-rapidio.c
index e5488d1..52d5985 100644
--- a/arch/mips/cavium-octeon/octeon-rapidio.c
+++ b/arch/mips/cavium-octeon/octeon-rapidio.c
@@ -36,9 +36,44 @@
 struct octeon_rio_port {
 	struct rio_mport mport;
 	struct work_struct work;
+	spinlock_t lock;
 };
 
 /**
+ * Private function for locking. SRIO MAINT registers require
+ * multiple transactions to read/write. This means that a lock
+ * is needed as each transaction is not atomic.
+ *
+ * @param mport  Port to lock
+ *
+ * @return IRQ flags. Must be passed to unlock.
+ */
+static unsigned long octeon_rio_lock(struct rio_mport *mport)
+{
+	struct octeon_rio_port *my_port = container_of(mport,
+		struct octeon_rio_port, mport);
+	unsigned long flags;
+
+	spin_lock_irqsave(&my_port->lock, flags);
+	return flags;
+}
+
+/**
+ * Private function for unlocking. SRIO MAINT registers require
+ * multiple transactions to read/write. This means that a lock
+ * is needed as each transaction is not atomic.
+ *
+ * @param mport  Port to lock
+ * @param flags  IRQ Flags from the lock call
+ */
+static void octeon_rio_unlock(struct rio_mport *mport, unsigned long flags)
+{
+	struct octeon_rio_port *my_port = container_of(mport,
+		struct octeon_rio_port, mport);
+	spin_unlock_irqrestore(&my_port->lock, flags);
+}
+
+/**
  * Local config read
  *
  * @param mport    RapidIO Master port info
@@ -52,6 +87,9 @@ struct octeon_rio_port {
 static int octeon_rio_lcread(struct rio_mport *mport, int mport_id, u32 offset,
 			     int len, u32 *data)
 {
+	int return_code;
+	unsigned long flags;
+
 	if (len != 4) {
 		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
 			but the RapidIO spec says these are illegal */
@@ -60,10 +98,14 @@ static int octeon_rio_lcread(struct rio_mport *mport, int mport_id, u32 offset,
 		return -EINVAL;
 	}
 
+	flags = octeon_rio_lock(mport);
 	if (cvmx_srio_config_read32(mport_id, OCTEON_RIO_ID, -1, 0, 0,
 		offset, data))
-		return -EIO;
-	return 0;
+		return_code = -EIO;
+	else
+		return_code = 0;
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -80,6 +122,9 @@ static int octeon_rio_lcread(struct rio_mport *mport, int mport_id, u32 offset,
 static int octeon_rio_lcwrite(struct rio_mport *mport, int mport_id, u32 offset,
 			      int len, u32 data)
 {
+	int return_code;
+	unsigned long flags;
+
 	if (len != 4) {
 		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
 			but the RapidIO spec says these are illegal */
@@ -87,10 +132,15 @@ static int octeon_rio_lcwrite(struct rio_mport *mport, int mport_id, u32 offset,
 			     " length (offset=0x%x, len=%d)\n", offset, len);
 		return -EINVAL;
 	}
+
+	flags = octeon_rio_lock(mport);
 	if (cvmx_srio_config_write32(mport_id, OCTEON_RIO_ID, -1, 0, 0, offset,
 		data))
-		return -EIO;
-	return 0;
+		return_code = -EIO;
+	else
+		return_code = 0;
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -109,6 +159,9 @@ static int octeon_rio_lcwrite(struct rio_mport *mport, int mport_id, u32 offset,
 static int octeon_rio_cread(struct rio_mport *mport, int mport_id, u16 destid,
 			    u8 hopcount, u32 offset, int len, u32 *data)
 {
+	int return_code;
+	unsigned long flags;
+
 	if (len != 4) {
 		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
 			but the RapidIO spec says these are illegal */
@@ -119,10 +172,15 @@ static int octeon_rio_cread(struct rio_mport *mport, int mport_id, u16 destid,
 			     0xffff & destid, 0xff & hopcount, offset, len);
 		return -EINVAL;
 	}
+
+	flags = octeon_rio_lock(mport);
 	if (cvmx_srio_config_read32(mport_id, OCTEON_RIO_ID, destid,
-				    mport->sys_size, hopcount, offset, data))
-		return -EIO;
-	return 0;
+		mport->sys_size, hopcount, offset, data))
+		return_code = -EIO;
+	else
+		return_code = 0;
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -141,6 +199,9 @@ static int octeon_rio_cread(struct rio_mport *mport, int mport_id, u16 destid,
 static int octeon_rio_cwrite(struct rio_mport *mport, int mport_id, u16 destid,
 			     u8 hopcount, u32 offset, int len, u32 data)
 {
+	int return_code;
+	unsigned long flags;
+
 	if (len != 4) {
 		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
 			but the RapidIO spec says these are illegal */
@@ -149,10 +210,15 @@ static int octeon_rio_cwrite(struct rio_mport *mport, int mport_id, u16 destid,
 			     0xffff & destid, 0xff & hopcount, offset, len);
 		return -EINVAL;
 	}
+
+	flags = octeon_rio_lock(mport);
 	if (cvmx_srio_config_write32(mport_id, OCTEON_RIO_ID, destid,
 		mport->sys_size, hopcount, offset, data))
-		return -EIO;
-	return 0;
+		return_code = -EIO;
+	else
+		return_code = 0;
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -168,8 +234,14 @@ static int octeon_rio_cwrite(struct rio_mport *mport, int mport_id, u16 destid,
 static int octeon_rio_dsend(struct rio_mport *mport, int mport_id, u16 destid,
 			    u16 data)
 {
-	return cvmx_srio_send_doorbell(mport_id, OCTEON_RIO_ID, destid,
+	int return_code;
+	unsigned long flags;
+
+	flags = octeon_rio_lock(mport);
+	return_code = cvmx_srio_send_doorbell(mport_id, OCTEON_RIO_ID, destid,
 		mport->sys_size, OCTEON_RIO_DOORBELL_PRIORITY, data);
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -188,13 +260,18 @@ static phys_t octeon_rio_mem_map(struct rio_mport *mport, struct rio_dev *rdev,
 	u64 offset, u64 length)
 {
 	int priority = 0;
+	phys_t return_code;
+	unsigned long flags;
 
 	DEBUG_MAP(mport, "map(destid=0x%x, res=0x%llx-0x%llx)\n",
 		0xffff & rdev->destid, offset, offset + length - 1);
 
-	return cvmx_srio_physical_map(mport->id, CVMX_SRIO_WRITE_MODE_AUTO,
+	flags = octeon_rio_lock(mport);
+	return_code = cvmx_srio_physical_map(mport->id, CVMX_SRIO_WRITE_MODE_AUTO,
 		priority, CVMX_SRIO_READ_MODE_NORMAL, priority,
 		OCTEON_RIO_ID, rdev->destid, mport->sys_size, offset, length);
+	octeon_rio_unlock(mport, flags);
+	return return_code;
 }
 
 /**
@@ -210,9 +287,13 @@ static phys_t octeon_rio_mem_map(struct rio_mport *mport, struct rio_dev *rdev,
 static void octeon_rio_mem_unmap(struct rio_mport *mport, struct rio_dev *rdev,
 	u64 offset, u64 length, phys_t physical_map)
 {
+	unsigned long flags;
+
 	DEBUG_MAP(mport, "unmap(destid=0x%x, res=0x%llx-0x%llx)\n",
 		0xffff & rdev->destid, offset, offset + length - 1);
+	flags = octeon_rio_lock(mport);
 	cvmx_srio_physical_unmap(physical_map, length);
+	octeon_rio_unlock(mport, flags);
 }
 
 /**
@@ -350,10 +431,13 @@ static void octeon_rio_rx_doorbell(struct rio_mport *mport)
 	int is16bit;
 	uint16_t data;
 	struct rio_dbell *dbell;
+	unsigned long flags;
 
 	while (1) {
+		flags = octeon_rio_lock(mport);
 		status = cvmx_srio_receive_doorbell(mport->id, &destid_index,
 			&sequence_num, &srcid, &priority, &is16bit, &data);
+		octeon_rio_unlock(mport, flags);
 		if (status != CVMX_SRIO_DOORBELL_DONE)
 			break;
 		list_for_each_entry(dbell, &mport->dbells, node) {
@@ -372,41 +456,26 @@ static void octeon_rio_rx_doorbell(struct rio_mport *mport)
  */
 static void octeon_rio_rx_soft_fifo(struct rio_mport *mport)
 {
-	union cvmx_sriomaintx_ir_sp_rx_stat sp_rx_stat;
-	int status;
-	int length;
+	int length = 8 + 256; /* SRIO header plus max of 256 byte */
 	struct sk_buff *skb;
+	unsigned long flags;
 
-	while (1) {
-		status = cvmx_srio_config_read32(mport->id, 0, -1, 0, 0,
-			CVMX_SRIOMAINTX_IR_SP_RX_STAT(mport->id),
-			&sp_rx_stat.u32);
-		if (status) {
-			RIO_PRINTK(mport,
-				"Failed read of SRIOMAINTX_IR_SP_RX_STAT\n");
-			return;
-		}
-		if (!sp_rx_stat.s.buffers)
-			break;
-		length = sp_rx_stat.s.octets;
-		skb = dev_alloc_skb((length+3) & -4);
-		while (length > 0) {
-			status = cvmx_srio_config_read32(mport->id, 0, -1, 0, 0,
-				CVMX_SRIOMAINTX_IR_SP_RX_DATA(mport->id),
-				(uint32_t *)skb_put(skb, (length < 4) ?
-				length : 4));
-			if (status) {
-				RIO_PRINTK(mport, "Failed soft packet read\n");
-				dev_kfree_skb_any(skb);
-				return;
-			}
-			length -= 4;
-		}
+	skb = dev_alloc_skb(length);
+	if (!skb) {
+		RIO_PRINTK(mport, "Failed to allocate skb\n");
+		return;
+	}
+
+	flags = octeon_rio_lock(mport);
+	length = cvmx_srio_receive_spf(mport->id, skb->data, length);
+	octeon_rio_unlock(mport, flags);
 
+	if (length > 0) {
+		__skb_put(skb, length);
 		DEBUG_PACKET(mport, "RX", "%d byte packet\n", skb->len);
 		/* FIXME: Do something with the packet */
-		dev_kfree_skb_any(skb);
 	}
+	dev_kfree_skb_any(skb);
 }
 
 /**
@@ -416,8 +485,13 @@ static void octeon_rio_rx_soft_fifo(struct rio_mport *mport)
  */
 static void octeon_rio_tx_doorbell(struct rio_mport *mport)
 {
+	unsigned long flags;
 	cvmx_srio_doorbell_status_t status;
+
+	flags = octeon_rio_lock(mport);
 	status = cvmx_srio_send_doorbell_status(mport->id);
+	octeon_rio_unlock(mport, flags);
+
 	switch (status) {
 	case CVMX_SRIO_DOORBELL_DONE:
 		DEBUG_IRQ(mport, "TX doorbell complete\n");
-- 
1.6.5.2

