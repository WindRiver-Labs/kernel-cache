From fa6837fe10739c8ba4210d526d970910bdb49c01 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 27 May 2010 17:38:11 -0400
Subject: [PATCH] Kexec support for Cavium.

Most of it coming from work done by Greg Moffatt for WR Linux 3.0.2:
- Network interface reset
- SMP CPU takedown
- Cavium Physical memory cleanup upon reboot
- Newer mgmt port driver resets interface on restart, kexec-specific
  support has been dropped.
- USB shutdown

Added:
- add cvmx_bootmem_phy_available_mem() from 3.0.x since it was removed
  in 4.0.
- mem= did not take multipliers into account, always assuming M: add
  support for K since kexec adds a mem=<crashkernel size>K to the
  boot line

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c |   18 ++
 arch/mips/cavium-octeon/octeon-usb-host.c        |   38 +++-
 arch/mips/cavium-octeon/setup.c                  |  325 +++++++++++++++++++++-
 arch/mips/include/asm/octeon/cvmx-bootmem.h      |    5 +
 drivers/staging/octeon/Makefile                  |    1 +
 drivers/staging/octeon/ethernet.c                |    9 +
 drivers/staging/octeon/octeon-kexec-net.c        |  115 ++++++++
 7 files changed, 501 insertions(+), 10 deletions(-)
 create mode 100644 drivers/staging/octeon/octeon-kexec-net.c

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index ed1659c..0f2a1b3 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -689,3 +689,21 @@ int64_t cvmx_bootmem_phy_named_block_alloc(uint64_t size, uint64_t min_addr,
 		cvmx_spinlock_unlock((cvmx_spinlock_t *)&(cvmx_bootmem_desc->lock));
 	return addr_allocated;
 }
+
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size)
+{
+	uint64_t addr;
+
+	uint64_t available_mem = 0;
+
+	cvmx_bootmem_lock();
+	addr = cvmx_bootmem_desc->head_addr;
+	while (addr)
+	{
+		if (cvmx_bootmem_phy_get_size(addr) >= min_block_size)
+			available_mem += cvmx_bootmem_phy_get_size(addr);
+		addr = cvmx_bootmem_phy_get_next(addr);
+	}
+	cvmx_bootmem_unlock();
+	return(available_mem);
+}
diff --git a/arch/mips/cavium-octeon/octeon-usb-host.c b/arch/mips/cavium-octeon/octeon-usb-host.c
index 1cd81da..f3c559f 100644
--- a/arch/mips/cavium-octeon/octeon-usb-host.c
+++ b/arch/mips/cavium-octeon/octeon-usb-host.c
@@ -717,6 +717,34 @@ static struct device_driver octeon_usb_driver = {
 
 #define MAX_USB_PORTS	10
 struct platform_device *pdev_glob[MAX_USB_PORTS];
+static void __shutdown_usb_ports(void)
+{
+	/* shutdown all USB ports */
+	int i=0;
+	for(i=0; i < MAX_USB_PORTS; i++) {
+		if(pdev_glob[i]) {
+			platform_device_unregister(pdev_glob[i]);
+			pdev_glob[i] = NULL;
+		}
+	}
+}
+
+#ifdef CONFIG_KEXEC
+void kexec_octeon_register_shutdown_usb_ports(void(*fn)(void));
+void kexec_octeon_unregister_shutdown_usb_ports(void);
+static void __register_for_kexec_shutdown(void)
+{
+	kexec_octeon_register_shutdown_usb_ports(__shutdown_usb_ports);
+}
+static void __unregister_for_kexec_shutdown(void)
+{
+	kexec_octeon_unregister_shutdown_usb_ports();
+}
+#else
+static void __register_for_kexec_shutdown(void) { /* do nothing */ }
+static void __unregister_for_kexec_shutdown(void) { /* do nothing */ }
+#endif
+
 static int __init octeon_usb_module_init(void)
 {
 	int num_devices = cvmx_usb_get_num_ports();
@@ -727,6 +755,8 @@ static int __init octeon_usb_module_init(void)
 		return -ENOMEM;
 	}
 
+	__register_for_kexec_shutdown();
+
 	printk(KERN_INFO "OcteonUSB: Detected %d ports\n", num_devices);
 	for (device = 0; device < num_devices; device++) {
 		struct resource irq_resource;
@@ -756,13 +786,9 @@ static int __init octeon_usb_module_init(void)
 
 static void __exit octeon_usb_module_cleanup(void)
 {
-	int i;
 	DEBUG_CALL("OcteonUSB: %s called\n", __func__);
-	for (i = 0; i < MAX_USB_PORTS; i++)
-		if (pdev_glob[i]) {
-			platform_device_unregister(pdev_glob[i]);
-			pdev_glob[i] = NULL;
-		}
+	__unregister_for_kexec_shutdown();
+	__shutdown_usb_ports();
 	driver_unregister(&octeon_usb_driver);
 }
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index bf1fef1..e1b96a6 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -33,6 +33,11 @@
 
 #include <asm/octeon/octeon.h>
 
+#ifdef CONFIG_KEXEC
+#include <linux/kexec.h>
+#include <linux/slab.h>
+#endif
+
 #ifdef CONFIG_CAVIUM_DECODE_RSL
 extern void cvmx_interrupt_rsl_decode(void);
 extern int __cvmx_interrupt_ecc_report_single_bit_errors;
@@ -57,6 +62,43 @@ uint64_t octeon_reserve32_memory;
 EXPORT_SYMBOL(octeon_reserve32_memory);
 #endif
 
+#ifdef CONFIG_KEXEC
+/* machine-specific function pointers for kexec */
+extern int (*_machine_kexec_prepare)(struct kimage *);
+extern void (*_machine_kexec_shutdown)(void);
+extern void (*_machine_crash_shutdown)(struct pt_regs *);
+/* utility functions */
+extern void octeon_shutdown_network_hw(void);
+/*
+ * Perform any setup actions necessary to setup this unit for kexec
+ * Currently this primarily means registering the cavium-specific targets
+ * for the kexec functions
+ */
+
+static void octeon_kexec_shutdown(void);
+static int octeon_kexec_prepare(struct kimage *kimage);
+static void octeon_crash_shutdown(struct pt_regs *regs);
+
+static void octeon_kexec_setup(void)
+{
+	_machine_kexec_shutdown = &octeon_kexec_shutdown;
+	_machine_kexec_prepare = &octeon_kexec_prepare;
+	_machine_crash_shutdown = &octeon_crash_shutdown;
+}
+#endif
+
+#ifdef CONFIG_CRASH_DUMP
+extern int (*_machine_check_pfn_validity)(unsigned long pfn);
+static int octeon_check_pfn_validity(unsigned long pfn)
+{
+	return (pfn_present(pfn) && pfn_valid(pfn));
+}
+static void octeon_crash_dump_setup(void)
+{
+	_machine_check_pfn_validity = octeon_check_pfn_validity;
+}
+#endif
+
 static int octeon_uart;
 
 extern asmlinkage void handle_int(void);
@@ -548,7 +590,7 @@ void __init prom_init(void)
 
 	sysinfo = cvmx_sysinfo_get();
 	memset(sysinfo, 0, sizeof(*sysinfo));
-	sysinfo->system_dram_size = octeon_bootinfo->dram_size << 20;
+	sysinfo->system_dram_size = (uint64_t)octeon_bootinfo->dram_size << 20;
 	sysinfo->phy_mem_desc_ptr =
 		cvmx_phys_to_ptr(octeon_bootinfo->phy_mem_desc_addr);
 	sysinfo->core_mask = octeon_bootinfo->core_mask;
@@ -589,10 +631,19 @@ void __init prom_init(void)
 	cvmx_read_csr(CVMX_CIU_INTX_SUM0((coreid * 2)));
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("CrashSMP");
+#else
 	octeon_write_lcd("LinuxSMP");
+#endif
+#else
+#ifdef CONFIG_CRASH_DUMP
+	octeon_write_lcd("Crash");
 #else
 	octeon_write_lcd("Linux");
 #endif
+#endif
+
 
 #ifdef CONFIG_CAVIUM_GDB
 	/*
@@ -628,8 +679,17 @@ void __init prom_init(void)
 			cvmx_phys_to_ptr(octeon_boot_desc_ptr->argv[i]);
 		if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
-			sscanf(arg + 4, "%llu", &MAX_MEMORY);
-			MAX_MEMORY <<= 20;
+			char mult = '?';
+			sscanf(arg + 4, "%llu%c", &MAX_MEMORY, &mult);
+			switch (mult) {
+			case 'M':
+			case '?': /* assume M when no multiplier */
+				MAX_MEMORY <<= 10;
+			case 'K':
+				MAX_MEMORY <<= 10;
+			default:
+				break;
+			}
 			if (MAX_MEMORY == 0)
 				MAX_MEMORY = 32ull << 30;
 		} else if (strcmp(arg, "ecc_verbose") == 0) {
@@ -703,6 +763,83 @@ void __init prom_init(void)
 
 	octeon_user_io_init();
 	register_smp_ops(&octeon_smp_ops);
+#ifdef CONFIG_KEXEC
+	octeon_kexec_setup();
+#endif
+#ifdef CONFIG_CRASH_DUMP
+	octeon_crash_dump_setup();
+#endif
+}
+
+/* constants for memory initialization */
+#define OCTEON_DDR0_BASE    (0x0ULL)
+#define OCTEON_DDR0_SIZE    (0x010000000ULL)
+#define OCTEON_DDR1_BASE    (0x410000000ULL)
+#define OCTEON_DDR1_SIZE    (0x010000000ULL)
+#define OCTEON_DDR2_BASE    (0x020000000ULL)
+#define OCTEON_DDR2_SIZE    (0x3e0000000ULL)
+#define OCTEON_MAX_PHY_MEM_SIZE (16*1024*1024*1024ULL)
+#define OCTEON_LINUX_RESERVED_MEM_NAME    "__tmp_reserved_linux"
+
+void cleanup_phy_mem(void)
+{
+	/* Ensure all memory is cleaned up.
+	 * Assume nothing has been put before the kernel
+	 * and assume that the kernel lands in the DDR0 region
+	 */
+	uint64_t freemem;
+	struct cvmx_sysinfo *sysinfo;
+	uint64_t memory;
+	uint64_t kernel_size;
+	uint64_t delta;
+	uint64_t curr_addr;
+
+	/* get the amount of DRAM on the board */
+	sysinfo = cvmx_sysinfo_get();
+	memory = sysinfo->system_dram_size;
+
+	/* do a few calculations */
+	kernel_size = (uint64_t)__bss_stop - (uint64_t)_text;
+	freemem = cvmx_bootmem_phy_available_mem(0x100000);
+	delta = (memory > freemem ? (memory - freemem) : (freemem - memory));
+
+	if (delta < MAX_MEMORY) {
+		/* we haven't allocated any memory yet = no need to
+		 * continue free'ing
+		 */
+		printk(KERN_NOTICE "...no need to free any memory\n");
+		return;
+	}
+
+	/* calculate the current address which is the next address after
+	 * the end of the kernel, on a boundary of 0x100000 (1MB)
+	 * the shift needs to match the value used in plat_mem_setup()
+	 */
+	curr_addr = (uint64_t)__bss_stop;
+	curr_addr &= 0x7fffffffULL;
+	curr_addr = curr_addr >> 20;
+	curr_addr += 1;
+	curr_addr = curr_addr << 20;
+
+	memory -= kernel_size;
+
+	if (memory <= (OCTEON_DDR0_SIZE - curr_addr)) {
+		__cvmx_bootmem_phy_free(curr_addr, memory, 0);
+	} else {
+		__cvmx_bootmem_phy_free(curr_addr,
+			OCTEON_DDR0_SIZE - curr_addr, 0);
+
+		memory -= (OCTEON_DDR0_SIZE);
+
+		if (memory > OCTEON_DDR1_SIZE) {
+			__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE,
+				OCTEON_DDR1_SIZE, 0);
+			__cvmx_bootmem_phy_free(OCTEON_DDR2_BASE,
+				memory - OCTEON_DDR1_SIZE, 0);
+		} else {
+			__cvmx_bootmem_phy_free(OCTEON_DDR1_BASE, memory, 0);
+		}
+	}
 }
 
 void __init plat_mem_setup(void)
@@ -713,6 +850,8 @@ void __init plat_mem_setup(void)
 
 	total = 0;
 
+	cleanup_phy_mem();
+
 	/* First add the init memory we will be returning.  */
 	memory = __pa_symbol(&__init_begin) & PAGE_MASK;
 	mem_alloc_size = (__pa_symbol(&__init_end) & PAGE_MASK) - memory;
@@ -739,7 +878,7 @@ void __init plat_mem_setup(void)
 	 */
 	cvmx_bootmem_lock();
 	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX)
-		&& (total < MAX_MEMORY)) {
+		&& (total <= OCTEON_MAX_PHY_MEM_SIZE)) {
 #if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
 						__pa_symbol(&__init_end), -1,
@@ -810,3 +949,181 @@ void prom_free_prom_memory(void)
 	}
 #endif
 }
+
+#ifdef CONFIG_KEXEC
+#ifdef CONFIG_SMP
+static cpumask_t kexec_cpus = CPU_MASK_NONE;
+
+static void octeon_kexec_shutdown_other_cpus(void *ignore)
+{
+	/* for each CPU except CPU0 go into a loop until we've relocated
+	 * the kernel and then jump to that page
+	 */
+	int cpu = smp_processor_id();
+	if (!cpu_online(cpu))
+		return;
+
+	local_irq_disable();
+
+	cpu_set(cpu, kexec_cpus);
+
+	while (!atomic_read(&kexec_ready_to_reboot)) {
+		cpu_relax();
+	}
+	relocated_kexec_smp_wait(NULL);
+}
+#endif /* CONFIG_SMP */
+
+/* USB shutdown hooks, overriden in octeon_usb_module_init() if
+ * CAVIUM_OCTEON_USB is configured in or when module is loaded */
+static void __shutdown_usb_ports(void) { /* do nothing */ }
+static void (*kexec_octeon_shutdown_usb_ports)(void) = __shutdown_usb_ports;
+void kexec_octeon_register_shutdown_usb_ports(void(*fn)(void))
+{
+	kexec_octeon_shutdown_usb_ports = fn;
+}
+void kexec_octeon_unregister_shutdown_usb_ports(void)
+{
+	kexec_octeon_shutdown_usb_ports = __shutdown_usb_ports;
+}
+
+static void octeon_kexec_shutdown(void)
+{
+#ifdef CONFIG_SMP
+	unsigned int msecs;
+	unsigned int ncpus;
+
+	/* proceed to shutdown the other CPUs */
+	ncpus = num_online_cpus() - 1; /* exclude this CPU */
+	cpus_clear(kexec_cpus);
+
+	printk(KERN_EMERG "Sending IPI to other cpus...\n");
+	if (smp_call_function(&octeon_kexec_shutdown_other_cpus, NULL, 0))
+		printk(KERN_EMERG "failed to send IPI\n");
+	smp_wmb();
+
+	msecs = 10000;
+	while ((cpus_weight(kexec_cpus) < ncpus) && (--msecs > 0)) {
+		cpu_relax();
+		mdelay(1);
+	}
+#endif /* CONFIG_SMP */
+
+	kexec_octeon_shutdown_usb_ports();
+}
+
+static void octeon_crash_shutdown(struct pt_regs *regs)
+{
+#ifdef CONFIG_SMP
+	/* just use the normal shutdown() mechanism */
+	octeon_kexec_shutdown();
+#endif /* CONFIG_SMP */
+}
+
+/*
+ * the arguments passed into the new kernel
+ * kexec_args[0] = register a0 = argc
+ * kexec_args[1] = register a1 = argv at a kseg0 compatible address
+ * kexec_args[2] = register a2 = 1 if init core, zero otherwise
+ * kexec_args[3] = register a3 = address of boot descriptor block
+ */
+extern unsigned long kexec_args[4];
+#ifdef CONFIG_SMP
+extern unsigned long secondary_kexec_args[4];
+#endif /* CONFIG_SMP */
+
+static int octeon_kexec_prepare(struct kimage *kimage)
+{
+	unsigned long argv = 0;
+	int i = 0;
+	char *kbuf = NULL;
+	const unsigned long KBUF_SIZE = 1024;
+	int buflen = 0;
+	void *userbuf = NULL;
+	char *kexec = "kexec";
+
+	/* setup the boot descriptor pointer */
+	for (i=0; i < OCTEON_ARGV_MAX_ARGS; i++) {
+		/* invalidate all entries in the boot ptr */
+		octeon_boot_desc_ptr->argv[i] = 0;
+	}
+	octeon_boot_desc_ptr->argc = 0;
+
+	/* get the argc and argv */
+	/* search through the source pages looking for a page that starts
+	 * with the string "kexec"
+	 */
+	kbuf = kmalloc(KBUF_SIZE, GFP_KERNEL);
+
+	/* find the cmdline buffer in the kimage */
+	for (i=0; (!argv) && (i < kimage->nr_segments); i++) {
+		memset(kbuf, 0, KBUF_SIZE);
+		copy_from_user(kbuf, kimage->segment[i].buf,
+			(kimage->segment[i].bufsz > KBUF_SIZE ?
+			KBUF_SIZE :  kimage->segment[i].bufsz));
+
+		/* see if this buffer starts with "kexec" */
+		if (memcmp(kbuf, kexec, 5) == 0) {
+			/* this is the buffer */
+			userbuf = kimage->segment[i].buf;
+			argv = (unsigned long)kimage->segment[i].mem;
+		}
+	}
+
+	if (argv) {
+		char *p = kbuf;
+		int looking_for_space = 0;
+		/* argv is the location of argv at a kseg0 address */
+		kexec_args[1] = argv;
+
+		/* parse the buffer and copy into the boot descriptor */
+		while (*p) {
+			if (1 == looking_for_space) {
+				if (*p == ' ') {
+					looking_for_space = 0;
+					*p='\0';
+				}
+			} else {
+				if (*p != ' ') {
+					/* found another token */
+					octeon_boot_desc_ptr->argv[(octeon_boot_desc_ptr->argc)++] = argv;
+					looking_for_space = 1;
+				} else {
+					*p = '\0';
+				}
+			}
+			p++;
+			argv++;
+		}
+
+		buflen = (int)(p - kbuf);
+		kexec_args[0] = octeon_boot_desc_ptr->argc;
+	}
+
+	/* now copy the modified cmdline buffer back to userspace */
+	copy_to_user(userbuf, kbuf, buflen);
+
+	if (kbuf)
+		kfree(kbuf);
+
+	/* setup the rest of the args */
+	kexec_args[2] = 1;
+	kexec_args[3] = (unsigned long)octeon_boot_desc_ptr;
+
+#ifdef CONFIG_SMP
+	/* copy the kexec_args to the secondary_args for the secondary
+	 * CPUs
+	 */
+	secondary_kexec_args[0] = kexec_args[0];
+	secondary_kexec_args[1] = kexec_args[1];
+	secondary_kexec_args[2] = 0; /* this is NOT the init core */
+	secondary_kexec_args[3] = kexec_args[3];
+#endif /* CONFIG_SMP */
+
+	return 0;
+}
+
+EXPORT_SYMBOL(kexec_octeon_register_shutdown_usb_ports);
+EXPORT_SYMBOL(kexec_octeon_unregister_shutdown_usb_ports);
+
+#endif /* CONFIG_KEXEC */
diff --git a/arch/mips/include/asm/octeon/cvmx-bootmem.h b/arch/mips/include/asm/octeon/cvmx-bootmem.h
index 8e708bd..6ed1657 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootmem.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootmem.h
@@ -370,4 +370,9 @@ void cvmx_bootmem_lock(void);
  */
 void cvmx_bootmem_unlock(void);
 
+/**
+ * Queries the available physical memory from the bootmem allocator
+ */
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size);
+
 #endif /*   __CVMX_BOOTMEM_H__ */
diff --git a/drivers/staging/octeon/Makefile b/drivers/staging/octeon/Makefile
index 87447c1..7a902e7 100644
--- a/drivers/staging/octeon/Makefile
+++ b/drivers/staging/octeon/Makefile
@@ -26,3 +26,4 @@ octeon-ethernet-objs += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o \
 	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
 
+obj-${CONFIG_KEXEC} +=  octeon-kexec-net.o
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index e50a17d..fa5d3b2 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -596,6 +596,9 @@ static const struct net_device_ops cvm_oct_pow_netdev_ops = {
 };
 
 extern void octeon_mdiobus_force_mod_depencency(void);
+#ifdef CONFIG_KEXEC
+extern void octeon_shutdown_network_hw(void);
+#endif
 
 static int __init cvm_oct_init_module(void)
 {
@@ -604,6 +607,12 @@ static int __init cvm_oct_init_module(void)
 	int fau = FAU_NUM_PACKET_BUFFERS_TO_FREE;
 	int qos;
 
+#ifdef CONFIG_KEXEC
+printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
+	if (reset_devices)
+		octeon_shutdown_network_hw();
+#endif
+
 	octeon_mdiobus_force_mod_depencency();
 	pr_notice("cavium-ethernet %s\n", OCTEON_ETHERNET_VERSION);
 
diff --git a/drivers/staging/octeon/octeon-kexec-net.c b/drivers/staging/octeon/octeon-kexec-net.c
new file mode 100644
index 0000000..b47d01c
--- /dev/null
+++ b/drivers/staging/octeon/octeon-kexec-net.c
@@ -0,0 +1,115 @@
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon-model.h>
+#include <asm/octeon/cvmx-agl-defs.h>
+#include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-mixx-defs.h>
+#include <linux/netdevice.h>
+#include "cvmx-helper.h"
+#include "cvmx-helper-util.h"
+#include "cvmx-config.h"
+#include "cvmx-fpa-defs.h"
+#include "cvmx-pip-defs.h"
+#include "cvmx-pko-defs.h"
+#include "cvmx-smix-defs.h"
+#include "cvmx-pow.h"
+
+void octeon_shutdown_network_hw(void)
+{
+	cvmx_helper_link_info_t link_info;
+	cvmx_wqe_t *work = NULL;
+	int ipd_port = 0;
+	int num_ints = 0;
+	int interface = 0;
+	int num_ports = 0;
+	int port = 0;
+	union cvmx_pko_reg_flags pko_reg_flags;
+	union cvmx_fpa_ctl_status fpa_status;
+	union cvmx_smix_en smix_en;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+	union cvmx_pip_sft_rst pip_sft_rst;
+
+	/* free up the work queue associated with this core */
+	work = cvmx_pow_get_current_wqp();
+	if (NULL != work) {
+		/* drain the work queue and free it */
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* halt the interfaces */
+	num_ints = cvmx_helper_get_number_of_interfaces();
+	if (num_ints > 2)
+		num_ints = 2;
+
+	/* Check to see what interface and ports we should use */
+	for (interface = 0; interface < num_ints; interface++) {
+		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
+			cvmx_helper_interface_get_mode(interface)) ||
+			(CVMX_HELPER_INTERFACE_MODE_GMII ==
+				cvmx_helper_interface_get_mode(interface))) {
+			/* get the ports for this interface */
+			cvmx_helper_interface_probe(interface);
+			num_ports = cvmx_helper_ports_on_interface(interface);
+
+			for (port = 0; port < num_ports; port++) {
+				ipd_port = cvmx_helper_get_ipd_port(interface, port);
+
+				link_info = cvmx_helper_link_get(ipd_port);
+				link_info.s.link_up = 0;
+				cvmx_helper_link_set(ipd_port, link_info);
+			}
+		}
+	}
+
+	/* disable the SMI */
+	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
+	if (smix_en.s.en) {
+		smix_en.s.en = 0;
+		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
+	}
+
+	/* Newer chips actually have two SMI/MDIO interfaces */
+	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN58XX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
+		if (smix_en.s.en) {
+			smix_en.s.en = 0;
+			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
+		}
+	}
+
+	/* Reset the IPD to get all buffers out of it */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.reset = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	/* Reset the PIP */
+	pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
+	pip_sft_rst.s.rst = 1;
+	cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
+
+	/* disable the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.ena_pko = 0;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* reset the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.reset = 1;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* disable the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.enb = 0;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* reset the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.reset = 1;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* free the cvmx_cmd_queues from bootmemory */
+	cvmx_bootmem_free_named("cvmx_cmd_queues");
+}
+
-- 
1.6.5.2

