From 73ee259c01306365d41e7c2e842a7e853c34f970 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Wed, 10 Nov 2010 14:31:57 +0800
Subject: [PATCH 003/132] Cavium: SDK2.0 Enable USER IO/MEM support

Source: SDK 2.0.0-366

Allows user applications to directly access the Octeon hardware IO
addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
performance networking applications to run in user space with minimal
performance penalties. This also means a user application can bring
down the entire system.

Allows user applications to use XKPHYS addresses directly to memory.
This allows user space direct access to shared memory not in use by
Linux. This memory is suitable for use with the Octeon hardware.
Cavium simple executive applications also share this memory. Since
this bypass all of the Linux memory protection, only use this option
on embedded devices where all user applications are strictly
controlled.

This option dynamically enable/disable with sysmips syscall, by a
process with root privilege. Without root privilege you can only
remove access.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig   |   74 ++++++++++---------
 arch/mips/cavium-octeon/Makefile  |    2 +-
 arch/mips/cavium-octeon/setup.c   |  144 ++++++++++++++++++++++++++++++++++++-
 arch/mips/include/asm/processor.h |   17 +----
 arch/mips/kernel/ptrace.c         |   49 ++++++++-----
 arch/mips/kernel/syscall.c        |    6 ++-
 6 files changed, 219 insertions(+), 73 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 1e04686..ca897ed 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -132,58 +132,60 @@ config CAVIUM_OCTEON_LOCK_L2_MEMCPY
 	  Lock the kernel's implementation of memcpy() into L2.
 
 choice
-	prompt "Allow User space to access hardware IO directly"
-	default CAVIUM_OCTEON_USER_IO
-	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+       prompt "Allow User space to access hardware IO directly"
+       default CAVIUM_OCTEON_USER_IO
+       depends on CPU_CAVIUM_OCTEON
 
 config CAVIUM_OCTEON_USER_IO
-	bool "Allowed"
-	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
-	help
-	  Allows user applications to directly access the Octeon hardware
-	  IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
-	  performance networking applications to run in user space with minimal
-	  performance penalties. This also means a user application can bring
-	  down the entire system. Only use this option on embedded devices
-	  where all user applications are strictly controlled.
+       bool "Allowed"
+       depends on CPU_CAVIUM_OCTEON
+       help
+         Allows user applications to directly access the Octeon hardware
+         IO addresses (0x1000000000000 - 0x1ffffffffffff). This allows high
+         performance networking applications to run in user space with minimal
+         performance penalties. This also means a user application can bring
+         down the entire system. Only use this option on embedded devices
+         where all user applications are strictly controlled.
 
 config CAVIUM_OCTEON_USER_IO_PER_PROCESS
-	bool "Per process"
-	help
-	  Allows user applications to use XKPHYS addresses directly to IO.
-	  This option dynamically enable/disable with sysmips syscall,
-	  by a process with root privilege. Without root privilege you can only remove access.
+       bool "Per process"
+       help
+         Allows user applications to use XKPHYS addresses directly to IO.
+         This option dynamically enable/disable with sysmips syscall,
+         by a process with root privilege. Without root privilege you can
+         only remove access.
 
 config CAVIUM_OCTEON_USER_IO_DISABLED
-	bool "Disabled"
+       bool "Disabled"
 
 endchoice
 
 choice
-	prompt "Allow User space to access memory directly"
-	default OCTEON_USER_MEM
-	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+       prompt "Allow User space to access memory directly"
+       default OCTEON_USER_MEM
+       depends on CPU_CAVIUM_OCTEON
 
 config CAVIUM_OCTEON_USER_MEM
-	bool "Allowed"
-	help
-	  Allows user applications to use XKPHYS addresses directly to memory.
-	  This allows user space direct access to shared memory not in use by
-	  Linux. This memory is suitable for use with the Octeon hardware.
-	  Cavium simple executive applications also share this memory. Since
-	  this bypass all of the Linux memory protection, only use this option
-	  on embedded devices where all user applications are strictly
-	  controlled.
+       bool "Allowed"
+       help
+         Allows user applications to use XKPHYS addresses directly to memory.
+         This allows user space direct access to shared memory not in use by
+         Linux. This memory is suitable for use with the Octeon hardware.
+         Cavium simple executive applications also share this memory. Since
+         this bypass all of the Linux memory protection, only use this option
+         on embedded devices where all user applications are strictly
+         controlled.
 
 config CAVIUM_OCTEON_USER_MEM_PER_PROCESS
-	bool "Per process"
-	help
-	  Allows user applications to use XKPHYS addresses directly to memory.
-	  This option dynamically enable/disable with sysmips syscall,
-	  by a process with root privilege. Without root privilege you can only remove access.
+       bool "Per process"
+       help
+         Allows user applications to use XKPHYS addresses directly to memory.
+         This option dynamically enable/disable with sysmips syscall,
+         by a process with root privilege. Without root privilege you can only
+         remove access.
 
 config CAVIUM_OCTEON_USER_MEM_DISABLED
-	bool "Disabled"
+       bool "Disabled"
 
 endchoice
 
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index e5740c4..0cfcb65 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -11,7 +11,7 @@
 
 obj-y := cpu.o setup.o serial.o octeon-platform.o octeon-irq.o csrc-octeon.o octeon_info.o
 obj-y += dma-octeon.o flash_setup.o
-obj-y += octeon-memcpy.o userio.o
+obj-y += octeon-memcpy.o
 
 obj-$(CONFIG_SMP)                     += smp.o
 obj-$(CONFIG_CAVIUM_OCTEON_WATCHDOG)  += watchdog.o watchdog_nmi.o
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index f81dbd0..36a118e 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -378,7 +378,6 @@ void octeon_user_io_init(void)
 	union octeon_cvmemctl cvmmemctl;
 	union cvmx_iob_fau_timeout fau_timeout;
 	union cvmx_pow_nw_tim nm_tim;
-	uint64_t cvmctl;
 
 	/* Get the current settings for CP0_CVMMEMCTL_REG */
 	cvmmemctl.u64 = read_c0_cvmmemctl();
@@ -454,8 +453,16 @@ void octeon_user_io_init(void)
 	cvmmemctl.s.wbfltime = 0;
 	/* R/W If set, do not put Istream in the L2 cache. */
 	cvmmemctl.s.istrnol2 = 0;
-	/* R/W The write buffer threshold. */
-	cvmmemctl.s.wbthresh = 10;
+	/*
+	 * R/W The write buffer threshold. As per erratum Core-14752
+	 * for CN63XX, a sc/scd might fail if the write buffer is
+	 * full.  Lowering WBTHRESH greatly lowers the chances of the
+	 * write buffer ever being full and triggering the erratum.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+		cvmmemctl.s.wbthresh = 4;
+	else
+		cvmmemctl.s.wbthresh = 10;
 	/* R/W If set, CVMSEG is available for loads/stores in
 	 * kernel/debug mode. */
 #if CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE > 0
@@ -503,6 +510,137 @@ void octeon_user_io_init(void)
 	write_c0_derraddr1(0);
 }
 
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
+	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+
+void cavium_prepare_arch_switch(struct task_struct *next)
+{
+	struct task_struct *group_leader = next->group_leader;
+	union octeon_cvmemctl cvmmemctl;
+	cvmmemctl.u64 = read_c0_cvmmemctl();
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	cvmmemctl.s.xkmemenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN) ? 1 : 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	cvmmemctl.s.xkioenau = test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN) ? 1 : 0;
+#endif
+	write_c0_cvmmemctl(cvmmemctl.u64);
+}
+#else
+static void cavium_prepare_arch_switch(struct task_struct *next)
+{
+}
+#endif
+
+static struct task_struct *xkphys_get_task(pid_t pid)
+{
+	struct task_struct *task, *group_leader;
+
+	rcu_read_lock();
+	task = find_task_by_vpid(pid);
+	if (!task) {
+		read_unlock(&tasklist_lock);
+		return NULL;
+	}
+	group_leader = task->group_leader;
+	get_task_struct(group_leader);
+
+	rcu_read_unlock();
+	return group_leader;
+}
+
+int xkphys_usermem_read(long pid)
+{
+	struct task_struct *task;
+	int io, mem;
+
+	task = xkphys_get_task(pid);
+	if (!task)
+		return -ESRCH;
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	io = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	io = test_tsk_thread_flag(task, TIF_XKPHYS_IO_EN);
+#else
+	io = 0;
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	mem = 1;
+#elif defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	mem = test_tsk_thread_flag(task, TIF_XKPHYS_MEM_EN);
+#else
+	mem = 0;
+#endif
+	put_task_struct(task);
+	return (io ? 2 : 0) | (mem ? 1 : 0);
+}
+
+int xkphys_usermem_write(long pid, int value)
+{
+	struct task_struct *task, *group_leader;
+	const struct cred *tcred;
+
+	uid_t euid = current_euid();
+
+#if defined(CONFIG_CAVIUM_OCTEON_USER_IO)
+	if ((value & 2) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+	if (value & 2)
+		return -EINVAL;
+#endif
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM)
+	if ((value & 1) == 0)
+		return -EINVAL;
+#elif !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
+	if (value & 1)
+		return -EINVAL;
+#endif
+
+	task = xkphys_get_task(pid);
+	group_leader = task->group_leader;
+
+	if (!task)
+		return -ESRCH;
+
+	rcu_read_lock();
+	tcred = __task_cred(task);
+
+	if (tcred->uid != euid &&
+	    tcred->euid != euid &&
+	    !(capable(CAP_SYS_RAWIO) || value == 0)) {
+		put_task_struct(task);
+		rcu_read_unlock();
+		return -EPERM;
+	}
+	rcu_read_unlock();
+
+	if (value & 1)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
+
+	if (value & 2)
+		set_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+	else
+		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
+
+	preempt_disable();
+
+	/* If we are adjusting ourselves, make the change effective
+	   immediatly.  */
+	if (group_leader == current->group_leader)
+		cavium_prepare_arch_switch(current);
+
+	preempt_enable();
+
+	put_task_struct(task);
+	return 0;
+}
+
 /**
  * Early entry point for arch setup
  */
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index f17bf72..9542440 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -344,25 +344,16 @@ unsigned long get_wchan(struct task_struct *p);
 #ifdef CONFIG_CPU_HAS_PREFETCH
 
 #define ARCH_HAS_PREFETCH
+#define prefetch(x) __builtin_prefetch((x), 0, 1)
 
-static inline void prefetch(const void *addr)
-{
-	__asm__ __volatile__(
-	"	.set	mips4		\n"
-	"	pref	%0, (%1)	\n"
-	"	.set	mips0		\n"
-	:
-	: "i" (Pref_Load), "r" (addr));
-}
+#define ARCH_HAS_PREFETCHW
+#define prefetchw(x) __builtin_prefetch((x), 1, 1)
 
 #endif
 
-#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
-	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
 #define prepare_arch_switch(next)  cavium_prepare_arch_switch(next)
 extern void cavium_prepare_arch_switch(struct task_struct *next);
-extern int xkphys_usermem_read(long pid);
-extern int xkphys_usermem_write(long pid, int value);
 #endif
 
 #endif /* _ASM_PROCESSOR_H */
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index c9dbe2b..0edb606 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -43,9 +43,8 @@
 DEFINE_TRACE(syscall_entry);
 DEFINE_TRACE(syscall_exit);
 
-#if defined(CONFIG_CPU_CAVIUM_OCTEON) && defined(CONFIG_64BIT)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
 #include <asm/octeon/octeon.h>
-extern struct cvmx_bootinfo *octeon_bootinfo;
 #endif
 
 /*
@@ -271,30 +270,33 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
-	case PTRACE_PEEKDATA:
-#if !defined(CAVIUM_OCTEON_USER_IO_DISABLED) && defined(CONFIG_64BIT)
-		/* check whether its a XKPHYS IO addr (we only allow the 0x80xx.. alias) */
+	case PTRACE_PEEKDATA: {
+		ret = -EIO;
+#if !defined(CONFIG_CAVIUM_OCTEON_USER_IO_DISABLED) && defined(CONFIG_64BIT)
+		/* check whether its a XKPHYS IO addr (we only allow the
+		   0x80xx.. alias) */
 		if (((unsigned long)addr >> 48) == 0x8001) {
-#ifdef CAVIUM_OCTEON_USER_IO_PER_PROCESS
+#ifdef CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS
 			struct task_struct *group_leader;
+
 			group_leader = child->group_leader;
-			if (!test_tsk_thread_flag(group_leader,
-							TIF_XKPHYS_IO_EN))
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN))
 				break;
 #endif
-			ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
+			ret = put_user(*(unsigned long *)addr,
+					(unsigned long __user *) data);
 			break;
 		}
-#endif /* !defined(CAVIUM_OCTEON_USER_IO_DISABLED) */
-#if !defined(CAVIUM_OCTEON_USER_MEM_DISABLED)
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_IO_DISABLED) */
+#if !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_DISABLED)
 		/* check whether its a XKPHYS MEM addr */
 		if (((unsigned long)addr >> 48) == 0x8000) {
 			unsigned long tmp;
-#ifdef CAVIUM_OCTEON_USER_MEM_PER_PROCESS
+#ifdef CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS
 			struct task_struct *group_leader;
+
 			group_leader = child->group_leader;
-			if (!test_tsk_thread_flag(group_leader,
-							TIF_XKPHYS_MEM_EN))
+			if (!test_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN))
 				break;
 #endif
 			ret = -EIO;
@@ -308,19 +310,28 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 			/* check for boot-bus addr range */
 			if ((tmp >= 0x10000000) && (tmp < 0x20000000))
 				break;
+
 			/* this is for the dram_size comparison below */
-			if ((tmp >= 0x410000000ull) && (tmp < 0x420000000ull))
-				tmp -= 0x400000000ull;
+			if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
+				/* subtract 256MB hole for dram_size comparison */
+				if (tmp >= 0x20000000ull)
+					tmp -= 0x10000000ull;
+			} else {
+				if ((tmp >= 0x410000000ull) && (tmp < 0x420000000ull))
+					tmp -= 0x400000000ull;
+			}
 
 			/* verify that "addr" is within installed dram */
-			if (tmp <= ((octeon_bootinfo->dram_size<<20) - sizeof(tmp)))  {
+			if (tmp <= ((octeon_bootinfo->dram_size << 20) - sizeof(tmp)))
 				ret = put_user(*(unsigned long *)addr, (unsigned long __user *) data);
-			}
+
 			break;
 		}
-#endif /*  defined(CONFIG_CAVIUM_OCTEON_USER_MEM) */
+#endif /* !defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) */
+
 		ret = generic_ptrace_peekdata(child, addr, data);
 		break;
+	}
 
 	/* Read the word at location addr in the USER area. */
 	case PTRACE_PEEKUSR: {
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index fd2373a..e21fd69 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -45,10 +45,13 @@
 #include <linux/elf.h>
 
 #if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
-	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
+       defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
 #include <asm/processor.h>
 #endif
 
+extern int xkphys_usermem_read(long);
+extern int xkphys_usermem_write(long, int);
+
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.  It returns results in registers $v0 / $v1 which means there
@@ -401,6 +404,7 @@ _sys_sysmips(nabi_no_regargs struct pt_regs regs)
 	case FLUSH_CACHE:
 		__flush_cache_all();
 		return 0;
+
 #if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
 	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
 	case MIPS_CAVIUM_XKPHYS_READ:
-- 
1.6.5.2

