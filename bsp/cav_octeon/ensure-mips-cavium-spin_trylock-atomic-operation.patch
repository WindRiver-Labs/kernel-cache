From 7b59ccafdbc39a1714853f4b09c7ddb3f70830ee Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 2 Feb 2010 17:38:07 +0800
Subject: [PATCH] ensure mips-cavium spin_trylock atomic operation

The inverted lock in fs/jbd triggered the concurrence operation of
non-atomic part in the spin_trylock of mips cavium implementation,
which is shown as follows:

-       if (__raw_spin_is_locked(lock))
-               return 0;
---> 	Here, it said,the lock is available for current thread; But
--->	at the same time, another core has been trying to get here;
--->	So it becomes critical area here, which will trigger inverted
--->	locks(call order of spin locks are inverted)
-       __raw_spin_lock(lock);

So, a full raw assemble atomic trylock replace it, which will let
"runltp -f fs_readonly" passed on cavium boards.

The following is calltrace scenaro:

Core0:
=====
	_spin_lock() - spinlock.c:301
--->Try to hold spin_lock(&journal->j_list_lock) in fs/jbd/transaction.c 993

--->And stuck in the followling line of kernel/spinlock.c
245                 while (!op##_can_lock(lock) && (lock)->break_lock)      \
246                         _raw_##op##_relax(&lock->raw_lock);
--->

	journal_dirty_data() - transaction.c:993

 992         jbd_lock_bh_state(bh); //Got the lock,which will stuck
 993         spin_lock(&journal->j_list_lock);

	ext3_journal_dirty_data() - inode.c:1191
	walk_page_buffers() - inode.c:1098
	ext3_ordered_writepage() - inode.c:1522
	__writepage() - page-writeback.c:1045
	write_cache_pages() - page-writeback.c:968
	do_writepages() - page-writeback.c:1080
	__writeback_single_inode() - fs-writeback.c:387
	generic_sync_sb_inodes() - fs-writeback.c:506
	writeback_inodes() - fs-writeback.c:619
	background_writeout() - page-writeback.c:644
	pdflush() - pdflush.c:191
	kthread() - kthread.c:80
	kernel_thread_helper() - process.c:228

Core1:
=====
	_spin_trylock() - spinlock.c:26
----> Concurrence break the try_lock. it is unlocked, so spin_trylock to spinlock
      the lock, but stucked in raw_spin_lock.

	inverted_lock() - commit.c:99

	journal_commit_transaction() - commit.c:461
----> Here journal_commit_transaction held the spinlock journal->j_list_lock
      successfully, and going.(in which will incur another thread stuck above)

	kjournald() - journal.c:149
	kthread() - kthread.c:80
	kernel_thread_helper() - process.c:228

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 include/asm-mips/spinlock.h |   29 +++++++++++++++++++++++++----
 1 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/include/asm-mips/spinlock.h b/include/asm-mips/spinlock.h
index 19720c1..2fefc26 100644
--- a/include/asm-mips/spinlock.h
+++ b/include/asm-mips/spinlock.h
@@ -140,10 +140,31 @@ static inline void __raw_spin_unlock(raw_spinlock_t *lock)
 static inline unsigned int __raw_spin_trylock(raw_spinlock_t *lock)
 {
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
-	if (__raw_spin_is_locked(lock))
-		return 0;
-	__raw_spin_lock(lock);
-	return 1;
+	int tmp,retval;
+	int my_ticket;
+	__asm__ __volatile__ (
+	"	.set noreorder					\n"
+	"1:							\n"
+	"	ll	%[my_ticket], %[ticket_ptr]		\n"
+	"	lw	%[ticket], %[now_serving]		\n"
+	"	bne	%[ticket], %[my_ticket], 2f		\n"
+	"	li	%[retval], 0				\n"
+	"	li	%[ticket], 1				\n"
+	"	addu	%[ticket], %[my_ticket]			\n"
+	"	sc	%[ticket], %[ticket_ptr]		\n"
+	"	beqz	%[ticket], 1b				\n"
+	"	syncw						\n"
+	"	syncw						\n"
+	"	li	%[retval], 1				\n"
+	"2:							\n"
+	"	.set reorder					\n"
+	: [ticket_ptr] "=m" (lock->ticket),
+	[now_serving] "=m" (lock->now_serving),
+	[ticket] "=r" (tmp),
+	[retval] "=r" (retval),
+	[my_ticket] "=r" (my_ticket));
+
+	return retval;
 #else
 	unsigned int temp, res;
 
-- 
1.6.0.4

