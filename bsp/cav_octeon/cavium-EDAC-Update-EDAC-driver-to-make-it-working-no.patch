From bcfe15a51ae5521c82b130320bf94cdf3ea5944d Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 17 Nov 2011 11:03:00 +0800
Subject: [PATCH] cavium/EDAC: Update EDAC driver to make it working normally

EDAC driver can't work normally on cavium-octeon boards,
this is because this driver is incomplete and missed some
necessary codes, moreover, this driver is written base on
Octeon Plus platforms.

Update the EDAC driver to fix this problem.

The main changes include:
1). Register EDAC devices on octeon-platform.c file.
2). Add octeon_edac-l2c.h header file to extend support
    for Octeon II platforms.
3). Update octeon_edac-lmc.h header file to extend support
    for Octeon II platforms.
4). Update LMC, L2C, L1C, PCI source code to use the standard
    EDAC poll mechanism and remove the unneeded poll timer.
5). Add enable and disabled LMC ECC parts code.
6). Update the LMC code to replace readq and writeq interfaces
    by the cvmx_read_csr and cvmx_write_csr interfaces.
7). Add the PCIe support for PCI EDAC.

Signed-off-by: Phil Staub <phil.staub@windriver.com>
Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-platform.c |   54 ++++++++
 drivers/edac/octeon_edac-l2c.c            |  119 +++++++++++------
 drivers/edac/octeon_edac-l2c.h            |   93 +++++++++++++
 drivers/edac/octeon_edac-lmc.c            |  209 ++++++++++++++++++++---------
 drivers/edac/octeon_edac-lmc.h            |  156 +++++++++++++---------
 drivers/edac/octeon_edac-pc.c             |   61 +++------
 drivers/edac/octeon_edac-pci.c            |  100 +++++++++-----
 7 files changed, 549 insertions(+), 243 deletions(-)
 create mode 100644 drivers/edac/octeon_edac-l2c.h

diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index 79881e0..4cd20fe 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -466,6 +466,60 @@ device_initcall(octeon_ohci_device_init);
 
 #endif /* CONFIG_USB */
 
+#ifdef CONFIG_EDAC
+
+static int __init octeon_edac_device_init(void)
+{
+	struct platform_device *pd;
+	int ret = 0;
+
+	pd = platform_device_alloc("co_l2c_edac", 0);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+
+	pd = platform_device_alloc("co_lmc_edac", 1);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+	
+	pd = platform_device_alloc("co_pc_edac", 2);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+
+	pd = platform_device_alloc("co_pci_edac", 3);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+
+	return ret;
+fail:
+	platform_device_put(pd);
+out:
+	return ret;
+}
+device_initcall(octeon_edac_device_init);
+
+#endif /* CONFIG_EDAC */
+
+
 MODULE_AUTHOR("David Daney <ddaney@caviumnetworks.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Platform driver for Octeon SOC");
diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index 43e3573..e76ceab 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -3,8 +3,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2009 Wind River Systems,
+ * Copyright (C) 2009-2011 Wind River Systems,
  *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ *   extended for Octeon II and multiple L2Cs by
+ *     Phil Staub <phil.staub@windriver.com>
  */
 #include <linux/module.h>
 #include <linux/init.h>
@@ -18,43 +20,60 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
+#include "octeon_edac-l2c.h"
+
 #define EDAC_MOD_STR "octeon-l2c"
 
-struct co_l2c_priv {
-	struct timer_list poll_timer;
-};
+static int	num_l2tad = 1;		/* number of l2 tag and data units */
 
-static void co_l2c_poll(unsigned long data)
+static void co_l2c_check(struct edac_device_ctl_info *l2c)
 {
-	struct edac_device_ctl_info *l2c = (struct edac_device_ctl_info *) data;
-	struct co_l2c_priv *pp = l2c->pvt_info;
-	union cvmx_l2t_err l2t_err;
-
-	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
-	if (l2t_err.s.sec_err) {
-		edac_device_handle_ce(l2c, 0, 0,
-				      "Single bit error (corrected)");
-		l2t_err.s.sec_err = 1;		/* Reset */
-		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
-	}
-	if (l2t_err.s.ded_err) {
-		edac_device_handle_ue(l2c, 0, 0,
-				      "Double bit error (corrected)");
-		l2t_err.s.ded_err = 1;		/* Reset */
-		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+	l2t_err_t	l2t_err;
+	l2d_err_t	l2d_err;
+	int		tad;
+
+	for (tad = 0; tad < num_l2tad; tad++) {
+		l2t_err.u64 = cvmx_read_csr(L2T_ERR(tad));
+		if (l2t_err.s.t_sec_err) {
+			edac_device_handle_ce(l2c, 0, 0,
+					"Single bit tag error (corrected)");
+			l2t_err.s.t_sec_err = 1;		/* Reset */
+			cvmx_write_csr(L2T_ERR(tad), l2t_err.u64);
+		}
+		if (l2t_err.s.t_ded_err) {
+			edac_device_handle_ue(l2c, 0, 0,
+					"Double bit tag error (uncorrected)");
+			l2t_err.s.t_ded_err = 1;		/* Reset */
+			cvmx_write_csr(L2T_ERR(tad),l2t_err.u64);
+		}
+
+		l2d_err.u64 = cvmx_read_csr(L2D_ERR(tad));
+		if (l2d_err.s.d_sec_err) {
+			edac_device_handle_ce(l2c, 0, 0,
+					"Single bit data error (corrected)");
+			l2d_err.s.d_sec_err = 1;		/* Reset */
+			cvmx_write_csr(L2D_ERR(tad), l2d_err.u64);
+		}
+		if (l2d_err.s.d_ded_err) {
+			edac_device_handle_ue(l2c, 0, 0,
+					"Double bit data error (uncorrected)");
+			l2d_err.s.d_ded_err = 1;		/* Reset */
+			cvmx_write_csr(L2D_ERR(tad), l2d_err.u64);
+		}
 	}
-
-	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
 }
 
 static int __devinit co_l2c_probe(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c;
-	struct co_l2c_priv *pp;
-	union cvmx_l2t_err l2t_err;
+	l2t_err_en_t	l2t_err_en;
+	l2t_err_t	l2t_err;
+	l2d_err_en_t	l2d_err_en;
+	l2d_err_t	l2d_err;
 	int res = 0;
+	int tad;
 
-	l2c = edac_device_alloc_ctl_info(sizeof(*pp), "l2c", 1, NULL, 0, 0,
+	l2c = edac_device_alloc_ctl_info(0, "l2c", 1, NULL, 0, 0,
 					 NULL, 0, edac_device_alloc_index());
 	if (!l2c)
 		return -ENOMEM;
@@ -66,28 +85,38 @@ static int __devinit co_l2c_probe(struct platform_device *pdev)
 	l2c->mod_name = "octeon-l2c";
 	l2c->ctl_name = "octeon_l2c_err";
 
+	l2c->edac_check = co_l2c_check;
+
 	if (edac_device_add_device(l2c) > 0) {
 		pr_err("%s: edac_device_add_device() failed\n", __func__);
 		goto err;
 	}
 
-	pp = l2c->pvt_info;
-
-	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
-	l2t_err.s.sec_intena = 0;	/* We poll */
-	l2t_err.s.ded_intena = 0;
-	l2t_err.s.sec_err = 1;		/* Clear, just in case */
-	l2t_err.s.ded_err = 1;
-	cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
-
-	init_timer(&pp->poll_timer);
-	pp->poll_timer.data       = (unsigned long) l2c;
-	pp->poll_timer.function   = co_l2c_poll;
-	pp->poll_timer.expires    = jiffies + HZ;
-	add_timer(&pp->poll_timer);
+	for (tad = 0; tad < num_l2tad; tad++) {
+		/* cache tag errors */
+		l2t_err_en.u64 = cvmx_read_csr(L2T_ERR_EN(tad));
+		l2t_err_en.s.t_sec_intena = 0;	/* We poll */
+		l2t_err_en.s.t_ded_intena = 0;
+		cvmx_write_csr(L2T_ERR_EN(tad), l2t_err_en.u64);
+
+		l2t_err.u64 = cvmx_read_csr(L2T_ERR(tad));
+		l2t_err.s.t_sec_err = 1;	/* Clear, just in case */
+		l2t_err.s.t_ded_err = 1;
+		cvmx_write_csr(L2T_ERR(tad), l2t_err.u64);
+
+		/* cache data errors */
+		l2d_err_en.u64 = cvmx_read_csr(L2D_ERR_EN(tad));
+		l2d_err_en.s.d_sec_intena = 0;	/* We poll */
+		l2d_err_en.s.d_ded_intena = 0;
+		cvmx_write_csr(L2D_ERR_EN(tad), l2d_err_en.u64);
+
+		l2d_err.u64 = cvmx_read_csr(L2D_ERR(tad));
+		l2d_err.s.d_sec_err = 1;	/* Clear, just in case */
+		l2d_err.s.d_ded_err = 1;
+		cvmx_write_csr(L2D_ERR(tad), l2d_err.u64);
+	}
 
 	return 0;
-
 err:
 	edac_device_free_ctl_info(l2c);
 
@@ -97,9 +126,7 @@ err:
 static int co_l2c_remove(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c = platform_get_drvdata(pdev);
-	struct co_l2c_priv *pp = l2c->pvt_info;
 
-	del_timer_sync(&pp->poll_timer);
 	edac_device_del_device(&pdev->dev);
 	edac_device_free_ctl_info(l2c);
 
@@ -118,6 +145,12 @@ static int __init co_edac_init(void)
 {
 	int ret;
 
+#if 0
+#ifdef CONFIG_CAVIUM_OCTEON2
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		num_l2tad = 4;
+#endif
+#endif
 	ret = platform_driver_register(&co_l2c_driver);
 	if (ret)
 		pr_warning(EDAC_MOD_STR " EDAC failed to register\n");
diff --git a/drivers/edac/octeon_edac-l2c.h b/drivers/edac/octeon_edac-l2c.h
new file mode 100644
index 0000000..ad9a7fa
--- /dev/null
+++ b/drivers/edac/octeon_edac-l2c.h
@@ -0,0 +1,93 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2011 Wind River Systems,
+ *   written by Phil Staub <Phil.Staub@windriver.com>
+ */
+
+/*
+ * octeon_edac-l2c.h - Level 2 cache EDAC definitions.
+ *
+ * These are RSL Type registers and are accessed indirectly across the
+ * I/O bus, so accesses are slowish.  Not that it matters.  Any size load is
+ * ok but stores must be 64-bit.
+ */
+#ifndef _OCTEON_EDAC_L2C_H_
+#define _OCTEON_EDAC_L2C_H_
+
+#include <asm/octeon/cvmx-l2c-defs.h>
+
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define L2T_ERR(x)	CVMX_L2C_ERR_TTGX(x)
+#define L2D_ERR(x)	CVMX_L2C_ERR_TDTX(x)
+#define L2T_ERR_EN(x)	CVMX_L2C_TADX_IEN(x)
+#define L2D_ERR_EN(x)	CVMX_L2C_TADX_IEN(x)
+
+/*
+ * For Octeon II, cache tag and cache data errors show up in the same
+ * register. 
+ */
+
+/* L2 Cache tag error register */
+union cvmx_l2c_int {
+	uint64_t			u64;
+	struct cvmx_l2c_tadx_int_s	s;
+};
+typedef union cvmx_l2c_int		l2t_err_t;
+typedef union cvmx_l2c_int		l2d_err_t;
+
+/* L2 Cache tag error enable register */
+union cvmx_l2c_en {
+	uint64_t			u64;
+	struct cvmx_l2c_tadx_ien_s	s;
+};
+typedef union cvmx_l2c_en		l2t_err_en_t;
+typedef union cvmx_l2c_en		l2d_err_en_t;
+
+
+
+/* bit names are slightly different than for Octeon/Octeon Plus */
+#define t_sec_err	tagsbe
+#define t_ded_err	tagdbe
+#define d_sec_err	l2dsbe
+#define d_ded_err	l2ddbe
+#define t_sec_intena	tagsbe
+#define t_ded_intena	tagdbe
+#define d_sec_intena	l2dsbe
+#define d_ded_intena	l2ddbe
+
+#else /* Octeon/Octeon Plus */
+#define L2T_ERR(x)	CVMX_L2T_ERR
+#define L2D_ERR(x)	CVMX_L2D_ERR
+#define L2T_ERR_EN(x)	CVMX_L2T_ERR
+#define L2D_ERR_EN(x)	CVMX_L2D_ERR
+
+/* L2 Cache tag error register */
+union l2t_err {
+	uint64_t		u64;
+	struct cvmx_l2t_err_s	s;
+};
+typedef union l2t_err		l2t_err_t;
+typedef union l2t_err		l2t_err_en_t;
+
+/* L2 Cache data error register */
+union l2d_err {
+	uint64_t		u64;
+	struct cvmx_l2d_err_s	s;
+};
+typedef union l2d_err		l2d_err_t;
+typedef union l2d_err		l2d_err_en_t;
+
+#define t_sec_err	sec_err
+#define t_ded_err	ded_err
+#define d_sec_err	sec_err
+#define d_ded_err	ded_err
+#define t_sec_intena	sec_intena
+#define t_ded_intena	ded_intena
+#define d_sec_intena	sec_intena
+#define d_ded_intena	ded_intena
+
+#endif
+#endif /*  _OCTEON_EDAC_L2C_H_ */
diff --git a/drivers/edac/octeon_edac-lmc.c b/drivers/edac/octeon_edac-lmc.c
index ebd50cc..199b0be 100644
--- a/drivers/edac/octeon_edac-lmc.c
+++ b/drivers/edac/octeon_edac-lmc.c
@@ -3,8 +3,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2009 Wind River Systems,
+ * Copyright (C) 2009-2011 Wind River Systems,
  *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ *   extended for OCTEON II and multiple LMCs by
+ *     Phil Staub <phil.staub@windriver.com>
  */
 #include <linux/module.h>
 #include <linux/init.h>
@@ -21,49 +23,47 @@
 
 #define EDAC_MOD_STR "octeon"
 
-struct co_lmc_priv {
-	struct timer_list poll_timer;
-};
-
-static struct mem_ctl_info *mc_cavium;
-static void *lmc_base;
+static int max_lmc;
 
-static void co_lmc_poll(unsigned long data)
+static void co_lmc_check(struct mem_ctl_info *mci)
 {
-	union lmc_mem_cfg0 cfg0;
-	struct mem_ctl_info *mci = (struct mem_ctl_info *) data;
-	struct co_lmc_priv *mp = mci->pvt_info;
-	union lmc_fadr fadr;
-	char msg[64];
-
-	fadr.u64 = readq(lmc_base + LMC_FADR);
-	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);
-	snprintf(msg, sizeof(msg), "DIMM %d rank %d bank %d row %d col %d",
-		fadr.fdimm, fadr.fbunk, fadr.fbank, fadr.frow, fadr.fcol);
-
-	if (cfg0.sec_err) {
-		edac_mc_handle_ce_no_info(mci, msg);
-		cfg0.intr_sec_ena = -1;		/* Done, re-arm */
-	}
+	lmc_int			lint;
+	lmc_fadr		fadr;
+	char			msg[64];
+	int			lmc;
 
-	if (cfg0.ded_err) {
-		edac_mc_handle_ue_no_info(mci, msg);
-		cfg0.intr_ded_ena = -1;		/* Done, re-arm */
-	}
+	for (lmc = 0; lmc < max_lmc; lmc++) {
+		fadr.u64 = cvmx_read_csr(LMC_FADR(0) + lmc * LMC_STRIDE);
+
+		snprintf(msg, sizeof(msg),
+			 "LMC %d DIMM %d rank %d bank %d row %d col %d",
+			 lmc, fadr.s.fdimm, fadr.s.fbunk,
+			 fadr.s.fbank, fadr.s.frow, fadr.s.fcol);
 
-	writeq(cfg0.u64, lmc_base + LMC_MEM_CFG0);
+		lint.u64 = cvmx_read_csr(LMC_INT(0) + lmc * LMC_STRIDE);
 
-	mod_timer(&mp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+		if (lint.s.sec_err) {
+			edac_mc_handle_ce_no_info(mci, msg);
+			lint.s.sec_err = -1;			/* Reset */
+		}
+
+		if (lint.s.ded_err) {
+			edac_mc_handle_ue_no_info(mci, msg);
+			lint.s.ded_err = -1;			/* Reset */
+		}
+
+		cvmx_write_csr(LMC_INT(0) + lmc * LMC_STRIDE, lint.u64);
+	}
 }
 
 static int __devinit co_lmc_probe(struct platform_device *pdev)
 {
 	struct mem_ctl_info *mci;
-	union lmc_mem_cfg0 cfg0;
-	struct co_lmc_priv *mp;
+	lmc_int_en	lint_en;
 	int res = 0;
+	int lmc;
 
-	mci = edac_mc_alloc(sizeof(*mp), 0, 0, 0);
+	mci = edac_mc_alloc(0, 0, 0, 0);
 	if (!mci)
 		return -ENOMEM;
 
@@ -74,25 +74,19 @@ static int __devinit co_lmc_probe(struct platform_device *pdev)
 	mci->mod_name = "octeon-lmc";
 	mci->ctl_name = "co_lmc_err";
 
+	mci->edac_check = co_lmc_check; 
+
 	if (edac_mc_add_mc(mci) > 0) {
 		pr_err("%s: edac_mc_add_mc() failed\n", __func__);
 		goto err;
 	}
 
-	mp = mci->pvt_info;
-
-	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);	/* We poll */
-	cfg0.intr_ded_ena = 0;
-	cfg0.intr_sec_ena = 0;
-	writeq(cfg0.u64, lmc_base + LMC_MEM_CFG0);
-
-	init_timer(&mp->poll_timer);
-	mp->poll_timer.data       = (unsigned long) mci;
-	mp->poll_timer.function   = co_lmc_poll;
-	mp->poll_timer.expires    = jiffies + HZ;
-	add_timer(&mp->poll_timer);
-
-	mc_cavium = mci;
+	for (lmc = 0; lmc < max_lmc; lmc++) {
+		lint_en.u64 = cvmx_read_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE);
+		lint_en.s.intr_ded_ena = 0;
+		lint_en.s.intr_sec_ena = 0;
+		cvmx_write_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE, lint_en.u64);
+	}
 
 	return 0;
 
@@ -105,10 +99,7 @@ err:
 static int co_lmc_remove(struct platform_device *pdev)
 {
 	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
-	struct co_lmc_priv *mp = mci->pvt_info;
 
-	del_timer_sync(&mp->poll_timer);
-	mc_cavium = NULL;
 	edac_mc_del_mc(&pdev->dev);
 	edac_mc_free(mci);
 
@@ -123,20 +114,112 @@ static struct platform_driver co_lmc_driver = {
 	}
 };
 
+static void __init co_edac_enable(void)
+{
+	lmc_mem_cfg	cfg;
+	lmc_int_en	lint_en;
+	int		lmc;
+
+	for (lmc = 0; lmc < max_lmc; lmc++) {
+		lint_en.u64 = cvmx_read_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE);
+		lint_en.s.intr_sec_ena = -1;
+		lint_en.s.intr_ded_ena = -1;
+		cvmx_write_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE, lint_en.u64);
+
+		cfg.u64 = cvmx_read_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE);
+		if (cfg.s.ecc_ena)
+			continue;
+		cfg.s.ecc_ena = -1;
+		cvmx_write_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE, cfg.u64);
+	}
+}
+
+static void __init co_edac_disable(void)
+{
+	lmc_mem_cfg	cfg;
+	lmc_int_en	lint_en;
+	int		lmc;
+
+	for (lmc = 0; lmc < max_lmc; lmc++) {
+		cfg.u64 = cvmx_read_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE);
+		if (!cfg.s.ecc_ena)
+			continue;
+
+		cfg.s.ecc_ena = 0;
+		cvmx_write_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE, cfg.u64);
+
+		lint_en.u64 = cvmx_read_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE);
+		lint_en.s.intr_sec_ena = 0;
+		lint_en.s.intr_ded_ena = 0;
+		cvmx_write_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE, lint_en.u64);
+	}
+}
+
+#ifdef CONFIG_CAVIUM_OCTEON2
+/*
+ * probe_2_4() - return up to 4 active lmcs
+ *
+ * Determine the number of active lmcs on CN68XX chips, which have 4
+ * controllers. This is determined by reading the LMC2_DLL_CTL2[INTF_ENA]
+ * bit. If the bit is set, assume the chip is in 4 LMC mode. If clear,
+ * it is in 2 LMC mode.
+ */
+#if 0
+static int __init probe_2_4(void)
+{
+	int num_lmc = 2;
+	cvmx_lmcx_dll_ctl2_t	lmc_dll_ctl2;
+
+	lmc_dll_ctl2.u64 = cvmx_read_csr(LMC_DLL_CTL2(0) + 2 * LMC_STRIDE);
+	if (lmc_dll_ctl2.s.intf_en)
+		num_lmc = 4;
+	return num_lmc;
+} 
+#endif
+#endif
+
+/*
+ * return the number of active Local Memory Controllers (LMCs).
+ *
+ * For CN68XX (CN67XX, this can be 2 or 4, depending on how
+ * many of the controllers have connected DIMMs.
+ *
+ * For CN56xx (CN57xx) this is 2, indicating the presence of 
+ * 2 connected DIMMS.
+ * 
+ * For all other chip types, this is 1.
+ */
+static int __init probe_num_lmc(void)
+{
+#if 0
+#ifdef CONFIG_CAVIUM_OCTEON2
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		return probe_2_4();
+#endif 
+#endif
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX))
+		return 2;
+	else 
+		return 1;
+}
+
 static int __init co_edac_init(void)
 {
-	union lmc_mem_cfg0 cfg0;
+	lmc_mem_cfg cfg;
 	int ret;
+	int lmc;
 
-	lmc_base = ioremap_nocache(LMC_BASE, LMC_SIZE);
-	if (!lmc_base)
-		return -ENOMEM;
+	max_lmc = probe_num_lmc();
 
-	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);
-	if (!cfg0.ecc_ena) {
-		pr_info(EDAC_MOD_STR " LMC EDAC: ECC disabled, good bye\n");
-		ret = -ENODEV;
-		goto out;
+	co_edac_enable();
+
+	for (lmc = 0; lmc < max_lmc; lmc++) {
+		cfg.u64 = cvmx_read_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE);
+		if (!cfg.s.ecc_ena) {
+			pr_info(EDAC_MOD_STR " LMC %d EDAC: ECC disabled, good bye\n", lmc);
+			ret = -ENODEV;
+			goto out;
+		}
 	}
 
 	ret = platform_driver_register(&co_lmc_driver);
@@ -144,19 +227,23 @@ static int __init co_edac_init(void)
 		pr_warning(EDAC_MOD_STR " LMC EDAC failed to register\n");
 		goto out;
 	}
-
 	return ret;
 
 out:
-	iounmap(lmc_base);
+	for (lmc = 0; lmc < max_lmc; lmc++)
+		co_edac_disable();
 
 	return ret;
 }
 
 static void __exit co_edac_exit(void)
 {
+	int lmc;
+
 	platform_driver_unregister(&co_lmc_driver);
-	iounmap(lmc_base);
+
+	for (lmc = 0; lmc < max_lmc; lmc++)
+		co_edac_disable();
 }
 
 module_init(co_edac_init);
diff --git a/drivers/edac/octeon_edac-lmc.h b/drivers/edac/octeon_edac-lmc.h
index 246dc52..7f5abe4 100644
--- a/drivers/edac/octeon_edac-lmc.h
+++ b/drivers/edac/octeon_edac-lmc.h
@@ -1,78 +1,106 @@
 /*
- * LMC Registers, see chapter 2.5
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2011 Wind River Systems,
+ *   written by Phil Staub <Phil.Staub@windriver.com>
+ */
+
+/*
+ * LMC Registers
  *
  * These are RSL Type registers and are accessed indirectly across the
  * I/O bus, so accesses are slowish.  Not that it matters.  Any size load is
  * ok but stores must be 64-bit.
  */
-#define LMC_BASE		0x0001180088000000
-#define LMC_SIZE		0xb8
+#ifndef _OCTEON_EDAC_LMC_H_
+#define _OCTEON_EDAC_LMC_H_
+
+#include <asm/octeon/cvmx-lmcx-defs.h>
+
+#ifdef CONFIG_CAVIUM_OCTEON2
+#define LMC_MEM_CFG0(x)			CVMX_LMCX_CONFIG(x)
+#define LMC_FADR(x)			CVMX_LMCX_FADR(x)
+#define LMC_DLL_CTL2(x)			CVMX_LMCX_DLL_CTL2(x)
+#define LMC_INT_EN(x)			CVMX_LMCX_INT_EN(x)
+#define LMC_INT(x)			CVMX_LMCX_INT(x)
+#define LMC_STRIDE			0x0000000001000000ull
+
+/* Failing address */
+union cvmx_lmc_fadr {
+	uint64_t			u64;
+	struct cvmx_lmcx_fadr_cn63xx	s;
+};
+typedef union cvmx_lmc_fadr		lmc_fadr;
+
+
+/* Configuration register */
+union lmc_config {
+	uint64_t			u64;
+	struct cvmx_lmcx_config_s	s;
+};
+typedef union lmc_config		lmc_mem_cfg;
 
-#define LMC_MEM_CFG0		0x0000000000000000
-#define LMC_MEM_CFG1		0x0000000000000008
-#define LMC_CTL			0x0000000000000010
-#define LMC_DDR2_CTL		0x0000000000000018
-#define LMC_FADR		0x0000000000000020
-#define   LMC_FADR_FDIMM
-#define   LMC_FADR_FBUNK
-#define   LMC_FADR_FBANK
-#define   LMC_FADR_FROW
-#define   LMC_FADR_FCOL
-#define LMC_COMP_CTL		0x0000000000000028
-#define LMC_WODT_CTL		0x0000000000000030
-#define LMC_ECC_SYND		0x0000000000000038
-#define LMC_IFB_CNT_LO		0x0000000000000048
-#define LMC_IFB_CNT_HI		0x0000000000000050
-#define LMC_OPS_CNT_LO		0x0000000000000058
-#define LMC_OPS_CNT_HI		0x0000000000000060
-#define LMC_DCLK_CNT_LO		0x0000000000000068
-#define LMC_DCLK_CNT_HI		0x0000000000000070
-#define LMC_DELAY_CFG		0x0000000000000088
-#define LMC_CTL1		0x0000000000000090
-#define LMC_DUAL_MEM_CONFIG	0x0000000000000098
-#define LMC_RODT_COMP_CTL	0x00000000000000A0
-#define LMC_PLL_CTL		0x00000000000000A8
-#define LMC_PLL_STATUS		0x00000000000000B0
+/* Interrupt status register */
+union cvmx_lmc_int {
+	uint64_t			u64;
+	struct cvmx_lmcx_int_s		s;
+};
+typedef union cvmx_lmc_int		lmc_int;
 
-union lmc_mem_cfg0 {
-	uint64_t u64;
-	struct {
-		uint64_t reserved_32_63:32;
-		uint64_t reset:1;
-		uint64_t silo_qc:1;
-		uint64_t bunk_ena:1;
-		uint64_t ded_err:4;
-		uint64_t sec_err:4;
-		uint64_t intr_ded_ena:1;
-		uint64_t intr_sec_ena:1;
-		uint64_t reserved_15_18:4;
-		uint64_t ref_int:5;
-		uint64_t pbank_lsb:4;
-		uint64_t row_lsb:3;
-		uint64_t ecc_ena:1;
-		uint64_t init_start:1;
-	};
+/* Interrupt enable register */
+union cvmx_lmc_int_en {
+	uint64_t			u64;
+	struct cvmx_lmcx_int_en_s	s;
 };
+typedef union cvmx_lmc_int_en		lmc_int_en;
+
+#else /* Octeon/Octeon Plus */
+#define LMC_MEM_CFG0(x)			CVMX_LMCX_MEM_CFG0(x)
+#define LMC_INT_EN(x)			LMC_MEM_CFG0(x)
+#define LMC_INT(x)			LMC_MEM_CFG0(x)
+#define LMC_FADR(x)			CVMX_LMCX_FADR(x)
+#define LMC_STRIDE			0x0000000060000000ull
 
+/* Failing address register */
 union lmc_fadr {
-	uint64_t u64;
-	struct {
-		uint64_t reserved_32_63:32;
-		uint64_t fdimm:2;
-		uint64_t fbunk:1;
-		uint64_t fbank:3;
-		uint64_t frow:14;
-		uint64_t fcol:12;
-	};
+	uint64_t			u64;
+	struct cvmx_lmcx_fadr_cn30xx	s;
 };
+typedef union lmc_fadr			lmc_fadr;
+
 
-union lmc_ecc_synd {
-	uint64_t u64;
-	struct {
-		uint64_t reserved_32_63:32;
-		uint64_t mrdsyn3:8;
-		uint64_t mrdsyn2:8;
-		uint64_t mrdsyn1:8;
-		uint64_t mrdsyn0:8;
-	};
+/* Configuration register */
+union lmc_config {
+	uint64_t			u64;
+	struct cvmx_lmcx_mem_cfg0_s	s;
 };
+typedef union lmc_config		lmc_mem_cfg;
+
+/*
+ *
+ * for Octeon/Octeon Plus, the bits determining interrupt status and
+ * interrupt enable are all incorporated in the cfg0 register. For Octeon II,
+ * they are split into two other registers separate from the cfg0 register.
+ * 
+ * However, since the bit names we're interested in are consistent with
+ * Octeon II names, we just duplicate the configure register and refer to
+ * it as the interrupt and interrupt enable register.
+ *
+ * Relevant bits and their positions in the indicated registers:
+ *
+ * Octeon/Octeon Plus			Octeon II
+ * ECC_ENA	lmcx_mem_cfg0:1		lmcx_config:1
+ * INTR_SEC_ENA	lmcx_mem_cfg0:19	lmcx_int_en:1
+ * INTR_DED_ENA	lmcx_mem_cfg0:20	lmcx_int_en:2
+ * SEC_ERR	lmcx_mem_cfg0:24-21	lmcx_int:4-1
+ * DED_ERR	lmcx_mem_cfg0:28-25	lmcx_int:8-5
+ * 
+ */
+
+typedef union lmc_config		lmc_int;
+typedef union lmc_config		lmc_int_en;
+
+#endif
+#endif /*  _OCTEON_EDAC_LMC_H_ */
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
index bfb8828..23ddcb7 100644
--- a/drivers/edac/octeon_edac-pc.c
+++ b/drivers/edac/octeon_edac-pc.c
@@ -22,26 +22,27 @@
 
 extern unsigned long long cache_err_dcache[NR_CPUS];
 
-static struct edac_device_ctl_info *ed_cavium;
-
 /*
- * EDAC CPU cache error callback
+ * EDAC CPU cache error poll function
  *
  */
 
-static int  co_cache_error_event(struct notifier_block *this,
-	unsigned long event, void *ptr)
+static void co_cache_error_check(struct edac_device_ctl_info *ed)
 {
 	unsigned int core = cvmx_get_core_num();
+	preempt_disable();
 	unsigned int cpu = smp_processor_id();
+	preempt_enable();
 	uint64_t icache_err = read_c0_cacheerr();
-	struct edac_device_ctl_info *ed = ed_cavium;
 
-	edac_device_printk(ed, KERN_ERR,
-			   "Cache error exception on core %d / processor %d:\n",
-			   core, cpu);
-	edac_device_printk(ed, KERN_ERR,
-			   "cp0_errorepc == %lx\n", read_c0_errorepc());
+	if ((icache_err & 1) || (cache_err_dcache[core] & 1)) {
+		edac_device_printk(ed, KERN_ERR,
+			   	"Cache error exception on core %d / processor %d:\n",
+			   	core, cpu);
+		edac_device_printk(ed, KERN_ERR,
+			   	"cp0_errorepc == %lx\n", read_c0_errorepc());
+	}
+
 	if (icache_err & 1) {
 		edac_device_printk(ed, KERN_ERR, "CacheErr (Icache) == %llx\n",
 				   (unsigned long long)icache_err);
@@ -54,29 +55,6 @@ static int  co_cache_error_event(struct notifier_block *this,
 		cache_err_dcache[core] = 0;
 		edac_device_handle_ue(ed, 0, 0, ed->ctl_name);
 	}
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block co_cache_error_notifier = {
-	.notifier_call = co_cache_error_event,
-};
-
-static RAW_NOTIFIER_HEAD(co_cache_error_chain);
-
-static int register_co_cache_error_notifier(struct notifier_block *nb)
-{
-	return raw_notifier_chain_register(&co_cache_error_chain, nb);
-}
-
-static int unregister_co_cache_error_notifier(struct notifier_block *nb)
-{
-	return raw_notifier_chain_unregister(&co_cache_error_chain, nb);
-}
-
-static inline int co_cache_error_call_notifiers(unsigned long val)
-{
-	return raw_notifier_call_chain(&co_cache_error_chain, val, NULL);
 }
 
 static int __devinit co_cache_error_probe(struct platform_device *pdev)
@@ -93,17 +71,16 @@ static int __devinit co_cache_error_probe(struct platform_device *pdev)
 
 	ed->mod_name = "octeon-cpu";
 	ed->ctl_name = "co_cpu_err";
+	
+	if (edac_op_state == EDAC_OPSTATE_POLL)
+		ed->edac_check = co_cache_error_check;
 
 	if (edac_device_add_device(ed) > 0) {
 		pr_err("%s: edac_device_add_device() failed\n", __func__);
 		goto err;
 	}
 
-	register_co_cache_error_notifier(&co_cache_error_notifier);
-	ed_cavium = ed;
-
 	return 0;
-
 err:
 	edac_device_free_ctl_info(ed);
 
@@ -114,8 +91,6 @@ static int co_cache_error_remove(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *ed = platform_get_drvdata(pdev);
 
-	unregister_co_cache_error_notifier(&co_cache_error_notifier);
-	ed_cavium = NULL;
 	edac_device_del_device(&pdev->dev);
 	edac_device_free_ctl_info(ed);
 
@@ -137,9 +112,11 @@ static int __init co_edac_init(void)
 	/* make sure error reporting method is sane */
 	switch (edac_op_state) {
 	case EDAC_OPSTATE_INT:
+	case EDAC_OPSTATE_POLL:
+		edac_op_state = EDAC_OPSTATE_POLL; 
 		break;
 	default:
-		edac_op_state = EDAC_OPSTATE_INT;
+		edac_op_state = EDAC_OPSTATE_POLL;
 		break;
 	}
 	ret = platform_driver_register(&co_cache_error_driver);
@@ -161,4 +138,4 @@ MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
 module_param(edac_op_state, int, 0444);
 MODULE_PARM_DESC(edac_op_state,
-		 "EDAC Error Reporting state: 2=Interrupt");
+		 "EDAC Error Reporting state: 0=Poll");
diff --git a/drivers/edac/octeon_edac-pci.c b/drivers/edac/octeon_edac-pci.c
index c6e69c3..e398d81 100644
--- a/drivers/edac/octeon_edac-pci.c
+++ b/drivers/edac/octeon_edac-pci.c
@@ -3,8 +3,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2009 Wind River Systems,
+ * Copyright (C) 2009-2011 Wind River Systems,
  *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ *   Extended to support other Octeon* devices by 
+ *     Phil Staub <phil.staub@windriver.com>
  */
 #include <linux/module.h>
 #include <linux/init.h>
@@ -14,69 +16,109 @@
 #include <linux/edac.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-pci-defs.h>
+#include <asm/octeon/cvmx-npi-defs.h>
+#include <asm/octeon/cvmx-pcie.h>
+#include <asm/octeon/cvmx-pciercx-defs.h>
 
 #include "edac_core.h"
 #include "edac_module.h"
 
 #define EDAC_MOD_STR "octeon"
 
-struct co_pci_priv {
-	struct timer_list poll_timer;
-};
+/*
+ * Octeon and CN50XX/CN58XX are the only processors
+ * that can access the PCI config space using NPI registers.
+ * All the rest access the pci config read/write routines.
+ *
+ * We're going to cheat a little when we access the
+ * Configuration space/NPI registers:
+ * 
+ * Octeon and CN50xx/CN58XX processors technically use
+ * a 'union cvmx_pci_cfg01' to read status and clear
+ * errors. All others use either a 'union cvmx_pcieepx_cfg001'
+ * or 'union cvmx_pciercx_cfg001'. For the bits we use, these
+ * unions are all identical. So we're going to use the
+ * same union (i.e., union cvmx_pci_cfg01) to identify
+ * the bits no matter what processor is in use.
+ * 
+ * This means the ONLY difference between
+ * Octeon/CN50xx/CN58xx and all other processors is the
+ * functions we use to read and write the configuration
+ * space, and what address we use to access.
+ */
 
-static void co_pci_poll(unsigned long data)
+static u32 co_pci_cfg_read(int pcie_port)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
+	      OCTEON_IS_MODEL(OCTEON_CN50XX) ||
+	      OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		return octeon_npi_read32(CVMX_NPI_PCI_CFG01);
+	else {
+		return cvmx_pcie_cfgx_read(pcie_port,
+					   CVMX_PCIERCX_CFG001(pcie_port));
+	}
+
+}
+
+static void co_pci_cfg_write(int pcie_port, uint32_t val)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN3XXX) ||
+	      OCTEON_IS_MODEL(OCTEON_CN50XX) ||
+	      OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		return octeon_npi_write32(CVMX_NPI_PCI_CFG01, val);
+	else {
+		return cvmx_pcie_cfgx_write(pcie_port,
+					   CVMX_PCIERCX_CFG001(pcie_port),
+					   val);
+	}
+
+}
+
+static void co_pci_check(struct edac_pci_ctl_info *pci)
 {
-	struct edac_pci_ctl_info *pci = (struct edac_pci_ctl_info *) data;
-	struct co_pci_priv *pp = pci->pvt_info;
 	union cvmx_pci_cfg01 cfg01;
+	int pcie_port = pci->pci_idx;
 
-	cfg01.u32 = octeon_npi_read32(CVMX_NPI_PCI_CFG01);
+	cfg01.u32 = co_pci_cfg_read(pcie_port);
 	if (cfg01.s.dpe) {		/* Detected parity error */
 		edac_pci_handle_pe(pci, pci->ctl_name);
 		cfg01.s.dpe = 1;		/* Reset  */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
 	if (cfg01.s.sse) {
 		edac_pci_handle_npe(pci, "Signaled System Error");
 		cfg01.s.sse = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
 	if (cfg01.s.rma) {
 		edac_pci_handle_npe(pci, "Received Master Abort");
 		cfg01.s.rma = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
 	if (cfg01.s.rta) {
 		edac_pci_handle_npe(pci, "Received Target Abort");
 		cfg01.s.rta = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
 	if (cfg01.s.sta) {
 		edac_pci_handle_npe(pci, "Signaled Target Abort");
 		cfg01.s.sta = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
-	}
-	if (cfg01.s.mdpe) {
-		edac_pci_handle_npe(pci, "Master Data Parity Error");
-		cfg01.s.mdpe = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
 	if (cfg01.s.mdpe) {
 		edac_pci_handle_npe(pci, "Master Data Parity Error");
 		cfg01.s.mdpe = 1;		/* Reset */
-		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+		co_pci_cfg_write(pcie_port, cfg01.u32);
 	}
-
-	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
 }
 
 static int __devinit co_pci_probe(struct platform_device *pdev)
 {
 	struct edac_pci_ctl_info *pci;
-	struct co_pci_priv *pp;
 	int res = 0;
 
-	pci = edac_pci_alloc_ctl_info(sizeof(*pp), "octeon_pci_err");
+	pci = edac_pci_alloc_ctl_info(0, "octeon_pci_err");
 	if (!pci)
 		return -ENOMEM;
 
@@ -86,20 +128,14 @@ static int __devinit co_pci_probe(struct platform_device *pdev)
 
 	pci->mod_name = "octeon-pci";
 	pci->ctl_name = "octeon_pci_err";
+	
+	pci->edac_check = co_pci_check;
 
 	if (edac_pci_add_device(pci, 0) > 0) {
 		pr_err("%s: edac_pci_add_device() failed\n", __func__);
 		goto err;
 	}
 
-	pp = pci->pvt_info;
-
-	init_timer(&pp->poll_timer);
-	pp->poll_timer.data       = (unsigned long) pci;
-	pp->poll_timer.function   = co_pci_poll;
-	pp->poll_timer.expires    = jiffies + HZ;
-	add_timer(&pp->poll_timer);
-
 	return 0;
 
 err:
@@ -111,9 +147,7 @@ err:
 static int co_pci_remove(struct platform_device *pdev)
 {
 	struct edac_pci_ctl_info *pci = platform_get_drvdata(pdev);
-	struct co_pci_priv *pp = pci->pvt_info;
 
-	del_timer_sync(&pp->poll_timer);
 	edac_pci_del_device(&pdev->dev);
 	edac_pci_free_ctl_info(pci);
 
-- 
1.7.0.4

