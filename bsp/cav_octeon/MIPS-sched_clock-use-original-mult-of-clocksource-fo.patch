From 824dd4a7511b8ded197853cd04ffb4b5e5bd7746 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Wed, 10 Oct 2012 10:51:26 +0800
Subject: [PATCH] MIPS: sched_clock: use original mult of clocksource for calculating clock value

The sched_clock should use mult_orig of clocksource to calculate the clock
value instead of using NTP adjusted mult of clocksource, otherwise the
sched_clock would provide backwarding clock value instead of monotonically
increasing one on certain workloads after the time is adjusted by NTP.

All the architectures should have distinct concept of time, one is for kernel
internal monotonically increasing time from system boot like the sched_clock()
provides, another one is maintained by timekeeping code, which is counted from
UNIX EPOC but it might not be monotonic because it might be adjusted by ntp if
there is drift between local time and time of ntp server.

Architectures beside ARM/OMAP and MIPS/CAVIUM_OCTEON do not depend on
clocksource->mult/shift to provide sched_clock but by other means, at least
not depend on ntp adjusted mult value, so they are immune to this sort of
problem. In the latest upstream kernel the mult/shift value is separated in
two parts, clocksource and timekeeper respectively.

The system time go backwards under certain workload and in some occasions the
softlockup warning is triggered because the interval between time value sampled
by the softlockup is greater than 1sec, the sched_clock() in ARM/MIPS use ntp
adjusted mult, the cycles -> nanoseconds is also influenced and occurs crazy
time value leap on these architectures.

The timekeeper patch is huge for back porting so just pick the part of it here.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 arch/mips/cavium-octeon/sync-octeon.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/mips/cavium-octeon/sync-octeon.c b/arch/mips/cavium-octeon/sync-octeon.c
index 6c856ce..efe5f9a 100644
--- a/arch/mips/cavium-octeon/sync-octeon.c
+++ b/arch/mips/cavium-octeon/sync-octeon.c
@@ -29,7 +29,7 @@ unsigned long long notrace sched_clock(void)
 #if (__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ <= 3))
 	u64 t1, t2, t3;
 	unsigned long long rv;
-	u64 mult = clocksource_mips.mult;
+	u64 mult = clocksource_mips.mult_orig;
 	u64 shift = clocksource_mips.shift;
 	u64 cnt = read_c0_cvmcount();
 
@@ -50,7 +50,7 @@ unsigned long long notrace sched_clock(void)
 	/* GCC > 4.3 do it the easy way.  */
 	unsigned int __attribute__((mode(TI))) t;
 	t = read_c0_cvmcount();
-	t = t * clocksource_mips.mult;
+	t = t * clocksource_mips.mult_orig;
 	return (unsigned long long)(t >> clocksource_mips.shift);
 #endif
 }
-- 
1.7.3.5

