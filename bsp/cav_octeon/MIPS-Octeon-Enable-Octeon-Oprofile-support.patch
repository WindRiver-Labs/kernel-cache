From 87a6dbab1123c67e89ca1f0c8fc67a75844b42f3 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 29 Mar 2010 15:35:00 +0800
Subject: [PATCH 1/3] MIPS: Octeon: Enable Octeon Oprofile support

Original patch taken from Cavium SDK 1.9.

Octeon has two PMR pairs and the counter registers are 64 bits.
Add Octeon specifc read/write counter registers macros since
MIPSR2 performance counters registers are 32 bits.
Add Octeon specific op model file for arch-dependent Oprofile
interfaces.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/include/asm/mipsregs.h            |    6 +
 arch/mips/oprofile/Makefile                 |    1 +
 arch/mips/oprofile/common.c                 |    5 +
 arch/mips/oprofile/op_model_cavium_octeon.c |  144 +++++++++++++++++++++++++++
 4 files changed, 156 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/oprofile/op_model_cavium_octeon.c

diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 9c9a7c0..2e2697e 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -1087,6 +1087,12 @@ do {									\
 #define read_octeon_c0_dcacheerr()	__read_64bit_c0_register($27, 1)
 #define write_octeon_c0_dcacheerr(val)	__write_64bit_c0_register($27, 1, val)
 
+/* Octeon's perf counter registers are 64bits */
+#define read_octeon_c0_perfcntr0()	__read_64bit_c0_register($25, 1)
+#define write_octeon_c0_perfcntr0(val)	__write_64bit_c0_register($25, 1, val)
+#define read_octeon_c0_perfcntr1()	__read_64bit_c0_register($25, 3)
+#define write_octeon_c0_perfcntr1(val)	__write_64bit_c0_register($25, 3, val)
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index 02cc65e..6b45035 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -16,3 +16,4 @@ oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
+oprofile-$(CONFIG_CPU_CAVIUM_OCTEON)	+= op_model_cavium_octeon.o
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index f9eb1ab..3a4fac6 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -18,6 +18,7 @@
 extern struct op_mips_model op_model_mipsxx_ops __weak;
 extern struct op_mips_model op_model_rm9000_ops __weak;
 extern struct op_mips_model op_model_loongson2_ops __weak;
+extern struct op_mips_model op_model_octeon_ops __weak;
 
 static struct op_mips_model *model;
 
@@ -98,6 +99,10 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_LOONGSON2:
 		lmodel = &op_model_loongson2_ops;
 		break;
+	case CPU_CAVIUM_OCTEON:
+	case CPU_CAVIUM_OCTEON_PLUS:
+		lmodel = &op_model_octeon_ops;
+		break;
 	};
 
 	if (!lmodel)
diff --git a/arch/mips/oprofile/op_model_cavium_octeon.c b/arch/mips/oprofile/op_model_cavium_octeon.c
new file mode 100644
index 0000000..a910443
--- /dev/null
+++ b/arch/mips/oprofile/op_model_cavium_octeon.c
@@ -0,0 +1,144 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ */
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+#include <asm/mipsregs.h>
+
+#include "op_impl.h"
+
+/**
+ * Bit description of the core counters control register
+ */
+typedef union {
+	uint32_t u32;
+	struct {
+		uint32_t M:1;
+		uint32_t W:1;
+		uint32_t reserved:19;
+		uint32_t event:6;
+		uint32_t IE:1;
+		uint32_t U:1;
+		uint32_t S:1;
+		uint32_t K:1;
+		uint32_t EX:1;
+	} s;
+} core_control_t;
+
+static struct {
+	core_control_t control[2];
+	uint64_t reset_value[2];
+} octeon_config;
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void octeon_reg_setup(struct op_counter_config *ctr)
+{
+	int i;
+	for (i = 0; i < 2; i++) {
+		octeon_config.control[i].u32 = 0;
+		if (ctr[i].enabled) {
+			octeon_config.control[i].s.event = ctr[i].event;
+			octeon_config.control[i].s.IE = 1;
+			octeon_config.control[i].s.U = ctr[i].user;
+			octeon_config.control[i].s.S = 1;
+			octeon_config.control[i].s.K = ctr[i].kernel;
+			octeon_config.control[i].s.EX = ctr[i].exl;
+			octeon_config.reset_value[i] =
+				(1ull << 63) - ctr[i].count;
+		}
+	}
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void octeon_cpu_setup(void *args)
+{
+	write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
+	write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+}
+
+static void octeon_cpu_start(void *args)
+{
+	uint64_t cvmctl;
+
+	/* Disable the issue and exec conditional clock support so we get
+		better results */
+	cvmctl = read_c0_cvmctl();
+	cvmctl |= 3 << 16;
+	write_c0_cvmctl(cvmctl);
+
+	/* Start all counters on current CPU */
+	write_c0_perfctrl0(octeon_config.control[0].u32);
+	write_c0_perfctrl1(octeon_config.control[1].u32);
+}
+
+static void octeon_cpu_stop(void *args)
+{
+	uint64_t cvmctl;
+
+	/* Stop all counters on current CPU */
+	write_c0_perfctrl0(0);
+	write_c0_perfctrl1(0);
+
+	/* Enable the issue and exec conditional clock support so we use
+		less power */
+	cvmctl = read_c0_cvmctl();
+	cvmctl &= ~(3 << 16);
+	write_c0_cvmctl(cvmctl);
+}
+
+static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
+{
+	uint64_t counter;
+
+	counter = read_octeon_c0_perfcntr0();
+	if (counter & (1ull << 63)) {
+		oprofile_add_sample(get_irq_regs(), 0);
+		write_octeon_c0_perfcntr0(octeon_config.reset_value[0]);
+	}
+
+	counter = read_octeon_c0_perfcntr1();
+	if (counter & (1ull << 63)) {
+		oprofile_add_sample(get_irq_regs(), 1);
+		write_octeon_c0_perfcntr1(octeon_config.reset_value[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int octeon_init(void)
+{
+	int result =
+		request_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler, IRQF_SHARED,
+			    "Perfcounter", octeon_perfcount_handler);
+#ifdef CONFIG_SMP
+	if (result == 0) {
+		struct irq_desc *desc = irq_desc + OCTEON_IRQ_PERF;
+		smp_call_function((void (*)(void *)) desc->chip->enable,
+				  (void *) (long) OCTEON_IRQ_PERF, 1);
+	}
+#endif
+	return result;
+}
+
+static void octeon_exit(void)
+{
+	free_irq(OCTEON_IRQ_PERF, octeon_perfcount_handler);
+}
+
+struct op_mips_model op_model_octeon_ops = {
+	.reg_setup = octeon_reg_setup,
+	.cpu_setup = octeon_cpu_setup,
+	.init = octeon_init,
+	.exit = octeon_exit,
+	.cpu_start = octeon_cpu_start,
+	.cpu_stop = octeon_cpu_stop,
+	.cpu_type = "mips/octeon",
+	.num_counters = 2
+};
-- 
1.6.5.2

