From 867e4dad141f4cb195e73781281725a14c70988c Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Thu, 11 Nov 2010 18:30:30 +0800
Subject: [PATCH 029/132] Cavium: Enable RSL Decode

Source: SDK 2.0.0-366

Hooks cvmx-error files into the kernel and associated header files so
that we get error and fault reporting.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig |    8 ++++++++
 arch/mips/cavium-octeon/setup.c |   22 ++++++++++++----------
 2 files changed, 20 insertions(+), 10 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 5b7b835..b210023 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -261,6 +261,14 @@ config CAVIUM_OCTEON_TRA
        tristate "Octeon trace buffer (TRA) driver"
        depends on CPU_CAVIUM_OCTEON && !CAVIUM_OCTEON2
        default n
+
+config CAVIUM_DECODE_RSL
+       bool "Decode RSL interrupt conditions."
+       depends on CPU_CAVIUM_OCTEON
+       default y
+       help
+         Detect, decode and display on-chip error conditions.
+
        help
          This option enables a driver for the Octeon trace buffer. By default
          it enables interrupts on some illegal memory accesses. See
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index c54370e..102437b 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -42,9 +42,7 @@
 #endif
 
 #ifdef CONFIG_CAVIUM_DECODE_RSL
-extern void cvmx_interrupt_rsl_decode(void);
 extern int __cvmx_interrupt_ecc_report_single_bit_errors;
-extern void cvmx_interrupt_rsl_enable(void);
 #endif
 
 extern struct plat_smp_ops octeon_smp_ops;
@@ -313,10 +311,12 @@ static void octeon_halt(void)
  *
  */
 #ifdef CONFIG_CAVIUM_DECODE_RSL
-static irqreturn_t octeon_rlm_interrupt(int cpl, void *dev_id)
+static irqreturn_t octeon_rml_interrupt(int cpl, void *dev_id)
 {
-	cvmx_interrupt_rsl_decode();
-	return IRQ_HANDLED;
+	if (cvmx_error_poll())
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
 }
 #endif
 
@@ -681,6 +681,10 @@ void __init prom_init(void)
 	MAX_MEMORY = (uint64_t)octeon_bootinfo->dram_size << 20;
 	cvmx_bootmem_init(cvmx_phys_to_ptr(octeon_bootinfo->phy_mem_desc_addr));
 
+#ifdef CONFIG_CAVIUM_DECODE_RSL
+	cvmx_error_initialize(CVMX_ERROR_FLAGS_ECC_SINGLE_BIT | CVMX_ERROR_FLAGS_CORRECTABLE);
+#endif
+
 	/*
 	 * Only enable the LED controller if we're running on a CN38XX, CN58XX,
 	 * or CN56XX. The CN30XX and CN31XX don't have an LED controller.
@@ -1107,12 +1111,10 @@ int prom_putchar(char c)
 void prom_free_prom_memory(void)
 {
 #ifdef CONFIG_CAVIUM_DECODE_RSL
-	cvmx_interrupt_rsl_enable();
-
 	/* Add an interrupt handler for general failures. */
-	if (request_irq(OCTEON_IRQ_RML, octeon_rlm_interrupt, IRQF_SHARED,
-			"RML/RSL", octeon_rlm_interrupt)) {
-		panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
+	if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, IRQF_SHARED,
+                        "RML_RSL", octeon_rml_interrupt)) {	
+ 		panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
 	}
 #endif
 }
-- 
1.6.5.2

