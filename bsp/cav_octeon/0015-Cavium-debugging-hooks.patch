From fe1030ebcbbed145a77bcad0580e14074515d399 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 24 Sep 2009 17:35:04 -0700
Subject: [PATCH] Cavium: debugging hooks

Hooks in the serial driver for debugging with GDB/KGDB. Includes early
initialization of driver, IRQ sharing, etc. Also includes 8250
specific tweaks that are required to be able to use the generic 8250
code.

The current state of these files reflects an ongoing development
process, and as such implies an extensive modification history that is
not cited in detail here. It is worth noting, however, that this
collection represents the work of the following people who were
involved in that history:

Tomaso Paoletti <tpaoletti@caviumnetworks.com>
Jason Wessel <jason.wessel@windriver.com>
Chunbo Luo <chunbo.luo@windriver.com>
Jack Tan <jack.tan@windriver.com>
Mark Asselstine <mark.asselstine@windriver.com>
Paul Gortmaker <Paul.Gortmaker@windriver.com>
Phil Staub <Phil.Staub@windriver.com>
Yang Shi <yang.shi@windriver.com>

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 drivers/serial/8250.c       |   44 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/serial/8250_early.c |    8 +++++++
 drivers/serial/8250_kgdb.c  |   21 ++++++++++++++++++++
 3 files changed, 72 insertions(+), 1 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 537a245..d7ed81e 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -41,7 +41,9 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/delay.h>
+#endif
 #include "8250.h"
 
 /*
@@ -360,7 +362,11 @@ static unsigned int serial_in(struct uart_8250_port *up, int offset)
 
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return __raw_readq(up->port.membase + offset);
+#else
 		return readb(up->port.membase + offset);
+#endif
 
 	case UPIO_RM9000:
 	case UPIO_MEM32:
@@ -397,7 +403,13 @@ serial_out(struct uart_8250_port *up, int offset, int value)
 		break;
 
 	case UPIO_MEM:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		if (offset == (UART_LCR<<up->port.regshift))
+			value &= 0x9f;
+		 __raw_writeq((unsigned char)value, up->port.membase + offset);
+#else
 		writeb(value, up->port.membase + offset);
+#endif
 		break;
 
 	case UPIO_RM9000:
@@ -838,7 +850,9 @@ static int broken_efr(struct uart_8250_port *up)
 static void autoconfig_16550a(struct uart_8250_port *up)
 {
 	unsigned char status1, status2;
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 	unsigned int iersave;
+#endif
 
 	up->port.type = PORT_16550A;
 	up->capabilities |= UART_CAP_FIFO;
@@ -886,7 +900,9 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 
 	if (!((status2 ^ status1) & UART_MCR_LOOP)) {
 		serial_outp(up, UART_LCR, 0);
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		serial_outp(up, UART_MCR, status1 ^ UART_MCR_LOOP);
+#endif
 		serial_outp(up, UART_LCR, 0xE0);
 		status2 = serial_in(up, 0x02); /* EXCR1 */
 		serial_outp(up, UART_LCR, 0);
@@ -940,6 +956,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		return;
 	}
 
+#if !defined(CONFIG_TAIGA) && !defined (CONFIG_CPU_CAVIUM_OCTEON)
 	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
@@ -974,6 +991,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_outp(up, UART_IER, iersave);
+#endif /* CAVIUM */
 }
 
 /*
@@ -1135,6 +1153,10 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	up->port.fifosize = uart_config[up->port.type].fifo_size;
 	up->capabilities = uart_config[up->port.type].flags;
 	up->tx_loadsz = uart_config[up->port.type].tx_loadsz;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	up->port.fifosize = 64;
+	up->tx_loadsz = 64;
+#endif
 
 	if (up->port.type == PORT_UNKNOWN)
 		goto out;
@@ -1486,6 +1508,14 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 		up = list_entry(l, struct uart_8250_port, list);
 
 		iir = serial_in(up, UART_IIR);
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#define UART_USR        0x27    /* UART Status Register */
+		if ((iir & 0xf) == 7) /* Busy interrupt */
+		{
+			serial_in(up, UART_USR);
+			iir = serial_in(up, UART_IIR);
+		}
+#endif
 		if (!(iir & UART_IIR_NO_INT)) {
 			serial8250_handle_port(up);
 
@@ -1607,7 +1637,11 @@ static void serial8250_timeout(unsigned long data)
 	struct uart_8250_port *up = (struct uart_8250_port *)data;
 	unsigned int iir;
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	iir = 0;
+#else
 	iir = serial_in(up, UART_IIR);
+#endif
 	if (!(iir & UART_IIR_NO_INT))
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
@@ -1945,7 +1979,11 @@ static int serial8250_startup(struct uart_port *port)
 	 */
 	if (!is_real_interrupt(up->port.irq)) {
 		up->timer.data = (unsigned long)up;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		add_timer_on(&up->timer, 0);
+#else
 		mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
+#endif
 	} else {
 		retval = serial_link_irq_chain(up);
 		if (retval)
@@ -2208,6 +2246,10 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 			up->port.ignore_status_mask |= UART_LSR_OE;
 	}
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	udelay(500);
+#endif
+
 	/*
 	 * ignore all characters if CREAD is not set
 	 */
diff --git a/drivers/serial/8250_early.c b/drivers/serial/8250_early.c
index f279745..df6bd00 100644
--- a/drivers/serial/8250_early.c
+++ b/drivers/serial/8250_early.c
@@ -49,7 +49,11 @@ static struct early_serial8250_device early_device;
 static unsigned int __init serial_in(struct uart_port *port, int offset)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return __raw_readq(port->membase + offset);
+#else
 		return readb(port->membase + offset);
+#endif
 	else
 		return inb(port->iobase + offset);
 }
@@ -57,7 +61,11 @@ static unsigned int __init serial_in(struct uart_port *port, int offset)
 static void __init serial_out(struct uart_port *port, int offset, int value)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		__raw_writeq((unsigned char)value, port->membase + offset);
+#else
 		writeb(value, port->membase + offset);
+#endif
 	else
 		outb(value, port->iobase + offset);
 }
diff --git a/drivers/serial/8250_kgdb.c b/drivers/serial/8250_kgdb.c
index f5430b0..95b9e18 100644
--- a/drivers/serial/8250_kgdb.c
+++ b/drivers/serial/8250_kgdb.c
@@ -71,9 +71,29 @@ int __weak kgdb8250_early_debug_ready(void)
 }
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+static inline void octeon_write_csr(uint64_t csr_addr, uint64_t val)
+{
+	*(volatile uint64_t *)csr_addr = val;
+}
+
+static inline uint64_t octeon_read_csr(uint64_t csr_addr)
+{
+	return *(volatile uint64_t *)csr_addr;
+}
 
 static inline unsigned int kgdb8250_ioread(u8 mask)
 {
+	return octeon_read_csr(kgdb8250_addr + (mask << kgdb8250_port.regshift));
+}
+
+static inline void kgdb8250_iowrite(u8 val, u8 mask)
+{
+	octeon_write_csr(kgdb8250_addr + (mask << kgdb8250_port.regshift) , val);
+}
+#else
+static inline unsigned int kgdb8250_ioread(u8 mask)
+{
 	return ioread8(kgdb8250_addr + (mask << kgdb8250_port.regshift));
 }
 
@@ -81,6 +101,7 @@ static inline void kgdb8250_iowrite(u8 val, u8 mask)
 {
 	iowrite8(val, kgdb8250_addr + (mask << kgdb8250_port.regshift));
 }
+#endif
 
 /*
  * Wait until the interface can accept a char, then write it.
-- 
1.5.5.1

