From 37d1c38448e274b5a44328257b94984bd74fd6c0 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 5 May 2010 18:12:00 +0800
Subject: [PATCH 2/6] MIPS: Octeon: Add Cavium GDB stub support

Enable Cavium Octeon sepcific GDB stub.
CONFIG_CAVIUM_GDB need to be selected to enable this feature.

Original patch taken from Cavium SDK 1.9.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/Kconfig.debug          |   10 ++++++
 arch/mips/cavium-octeon/serial.c |   64 ++++++++++++++++++++++++++++++++++++++
 arch/mips/cavium-octeon/setup.c  |    5 +++
 3 files changed, 79 insertions(+), 0 deletions(-)

diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug
index 43dc279..249d1b0 100644
--- a/arch/mips/Kconfig.debug
+++ b/arch/mips/Kconfig.debug
@@ -128,4 +128,14 @@ config SPINLOCK_TEST
 	help
 	  Add several files to the debugfs to test spinlock speed.
 
+config CAVIUM_GDB
+	bool "Remote GDB debugging using the Cavium Networks Multicore GDB"
+	depends on DEBUG_KERNEL
+	depends on CPU_CAVIUM_OCTEON
+	select DEBUG_INFO
+	help
+	  If you say Y here, it will be possible to remotely debug the MIPS
+	  kernel using the Cavium Networks GDB with extended SMP support.
+	  This is only useful for kernel hackers. If unsure, say N.
+
 endmenu
diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index 8240728..c0a433d 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -18,12 +18,67 @@
 
 #include <asm/octeon/octeon.h>
 
+#if defined(CONFIG_CAVIUM_GDB)
+static int cavium_gdb_active;
+
+static int __init opt_cavium_gdb(char *p)
+{
+	cavium_gdb_active = 1;
+
+	return 0;
+}
+early_param("cavium_gdb", opt_cavium_gdb);
+
 #ifdef CONFIG_GDB_CONSOLE
 #define DEBUG_UART 0
 #else
 #define DEBUG_UART 1
 #endif
 
+static irqreturn_t interruptDebugChar(int cpl, void *dev_id)
+{
+	unsigned long lsrval;
+	lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(1));
+	if (lsrval & 1) {
+		unsigned long tmp;
+		/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also set
+		   the MCD0 to be not masked by this core so we know the signal
+		   is received by someone */
+		octeon_write_lcd("brk");
+		asm volatile ("dmfc0 %0, $22\n"
+			      "ori   %0, %0, 0x10\n"
+			      "dmtc0 %0, $22\n" : "=r" (tmp));
+		octeon_write_lcd("");
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/* Enable uart1 interrupts for debugger Control-C processing */
+
+static int octeon_setup_debug_uart(void)
+{
+	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
+	   kernel command line */
+	if (cavium_gdb_active) {
+		if (request_irq(OCTEON_IRQ_UART0 + DEBUG_UART,
+				interruptDebugChar, IRQF_SHARED, "Cavium GDB",
+				interruptDebugChar)) {
+			panic("request_irq(%d) failed.", OCTEON_IRQ_UART0 + DEBUG_UART);
+		}
+
+		/* Enable uart1 interrupts for debugger Control-C processing */
+		cvmx_write_csr(CVMX_MIO_UARTX_IER(DEBUG_UART),
+			cvmx_read_csr(CVMX_MIO_UARTX_IER(DEBUG_UART)) | 1);
+	}
+	return 0;
+}
+
+/* Install this as early as possible to be able to debug the boot
+   sequence.  */
+core_initcall(octeon_setup_debug_uart);
+#endif  /* CONFIG_CAVIUM_GDB */
+
 unsigned int octeon_serial_in(struct uart_port *up, int offset)
 {
 	int rv = cvmx_read_csr((uint64_t)(up->membase + (offset << 3)));
@@ -98,6 +153,15 @@ static int __init octeon_serial_init(void)
 #endif
 #endif
 
+#if defined(CONFIG_CAVIUM_GDB)
+	/* As a special case forcibly disable uart1 if cavium gdb is in use */
+
+	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
+	   kernel command line */
+	if (cavium_gdb_active)
+		enable_uart1 = 0;
+#endif
+
 	/* Right now CN52XX is the only chip with a third uart */
 	enable_uart2 = OCTEON_IS_MODEL(OCTEON_CN52XX);
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 84f9c95..bf1fef1 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -142,6 +142,11 @@ int octeon_get_boot_uart(void)
 	return uart;
 }
 
+int octeon_get_boot_debug_flag(void)
+{
+	return !!(octeon_boot_desc_ptr->flags & OCTEON_BL_FLAG_DEBUG);
+}
+
 /**
  * Get the coremask Linux was booted on.
  *
-- 
1.6.5.2

