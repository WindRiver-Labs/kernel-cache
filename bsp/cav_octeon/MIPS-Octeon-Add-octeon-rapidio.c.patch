From d69ca3d287a9f0486a98c34eccbba38661be0bfc Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Mon, 15 Nov 2010 10:22:35 +0800
Subject: [PATCH 059/132] MIPS: Octeon: Add octeon-rapidio.c

Driver to connect Octeon's SRIO to the RapidIO subsystem.

Signed-off-by: Chad Reese <kreese@caviumnetworks.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/Makefile         |    1 +
 arch/mips/cavium-octeon/octeon-rapidio.c |  608 ++++++++++++++++++++++++++++++
 2 files changed, 609 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/octeon-rapidio.c

diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index f3e3ac7..3b7aed8 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -20,5 +20,6 @@ obj-$(CONFIG_CAVIUM_OCTEON_WATCHDOG)  += octeon-wdt.o
 octeon-wdt-objs := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_CAVIUM_OCTEON_TRA)       += octeon-tra.o
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)      += octeon-nand.o
+obj-$(CONFIG_CAVIUM_OCTEON_RAPIDIO)   += octeon-rapidio.o
 
 EXTRA_CFLAGS += -Werror
diff --git a/arch/mips/cavium-octeon/octeon-rapidio.c b/arch/mips/cavium-octeon/octeon-rapidio.c
new file mode 100644
index 0000000..cad5e10
--- /dev/null
+++ b/arch/mips/cavium-octeon/octeon-rapidio.c
@@ -0,0 +1,608 @@
+/**
+ * Driver for the Octeon Serial Rapid IO interfaces introduced in CN63XX.
+ *
+ * LICENSE:
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Cavium Networks
+ */
+
+#include <linux/rio.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-srio.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
+#include <asm/octeon/cvmx-sriomaintx-defs.h>
+
+#define RIO_PRINTK(mport, fmt, ...) \
+	printk(KERN_INFO "SRIO%d: " fmt, (mport)->id, ##__VA_ARGS__)
+#define DEBUG_CONFIG(mport, fmt, ...) \
+	RIO_PRINTK(mport, fmt, ##__VA_ARGS__)
+#define DEBUG_DOORBELL(mport, fmt, ...) \
+	RIO_PRINTK(mport, fmt, ##__VA_ARGS__)
+#define DEBUG_MAP(mport, fmt, ...) \
+	RIO_PRINTK(mport, fmt, ##__VA_ARGS__)
+#define DEBUG_MBOX(mport, dir, mbox, fmt, ...) \
+	RIO_PRINTK(mport, "%s MBOX %d " fmt, dir, mbox, ##__VA_ARGS__)
+#define DEBUG_PACKET(mport, dir, fmt, ...) \
+	RIO_PRINTK(mport, "%s PACKET " fmt, dir, ##__VA_ARGS__)
+#define DEBUG_IRQ(mport, fmt, ...) \
+	RIO_PRINTK(mport, fmt, ##__VA_ARGS__)
+
+#define OCTEON_RIO_ID 0 /* Which source ID to use. 0=Primary, 1=Secondary */
+#define OCTEON_RIO_DOORBELL_PRIORITY 0 /* Priority for sent doorbells (0-3) */
+
+struct octeon_rio_port {
+	struct rio_mport mport;
+	struct work_struct work;
+};
+
+/**
+ * Local config read
+ *
+ * @param mport    RapidIO Master port info
+ * @param mport_id Always the same as mport->id
+ * @param offset   Config space register
+ * @param len      Length of the read (1,2, or 4 bytes)
+ * @param data     Resulting data
+ *
+ * @return Zero on success, negative on failure
+ */
+static int octeon_rio_lcread(struct rio_mport *mport, int mport_id, u32 offset,
+			     int len, u32 *data)
+{
+	if (len != 4) {
+		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
+			but the RapidIO spec says these are illegal */
+		DEBUG_CONFIG(mport, "ERROR: local config read with illegal"
+			     " length (offset=0x%x, len=%d)\n", offset, len);
+		return -EINVAL;
+	}
+
+	if (cvmx_srio_config_read32(mport_id, OCTEON_RIO_ID, -1, 0, 0,
+		offset, data))
+		return -EIO;
+	DEBUG_CONFIG(mport, "local config read"
+		     "(offset=0x%x, len=%d, data=0x%x)\n", offset, len, *data);
+	return 0;
+}
+
+/**
+ * Local config write
+ *
+ * @param mport    RapidIO Master port info
+ * @param mport_id Always the same as mport->id
+ * @param offset   Config space register
+ * @param len      Length of the write (1,2, or 4 bytes)
+ * @param data     Data to write
+ *
+ * @return Zero on success, negative on failure
+ */
+static int octeon_rio_lcwrite(struct rio_mport *mport, int mport_id, u32 offset,
+			      int len, u32 data)
+{
+	if (len != 4) {
+		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
+			but the RapidIO spec says these are illegal */
+		DEBUG_CONFIG(mport, "ERROR: local config write with illegal"
+			     " length (offset=0x%x, len=%d)\n", offset, len);
+		return -EINVAL;
+	}
+	DEBUG_CONFIG(mport, "local config write"
+		     "(offset=0x%x, len=%d, data=0x%x)\n", offset, len, data);
+	if (cvmx_srio_config_write32(mport_id, OCTEON_RIO_ID, -1, 0, 0, offset,
+		data))
+		return -EIO;
+	return 0;
+}
+
+/**
+ * Remote config read
+ *
+ * @param mport    RapidIO Master port info
+ * @param mport_id Always the same as mport->id
+ * @param destid   Remote destination ID
+ * @param hopcount Number of hops to the device
+ * @param offset   Config space register
+ * @param len      Length of the read (1,2, or 4 bytes)
+ * @param data     Resulting data
+ *
+ * @return Zero on success, negative on failure
+ */
+static int octeon_rio_cread(struct rio_mport *mport, int mport_id, u16 destid,
+			    u8 hopcount, u32 offset, int len, u32 *data)
+{
+	if (len != 4) {
+		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
+			but the RapidIO spec says these are illegal */
+		DEBUG_CONFIG(mport,
+			     "ERROR: config read with illegal length"
+			     " (destid=0x%x, hopcount=%d, "
+			     "offset=0x%x, len=%d)\n",
+			     0xffff & destid, 0xff & hopcount, offset, len);
+		return -EINVAL;
+	}
+	/* FIXME: rdev->pef & RIO_PEF_CTLS for 16bit flag */
+	if (cvmx_srio_config_read32(mport_id, OCTEON_RIO_ID, destid, 1,
+		hopcount, offset, data))
+		return -EIO;
+	DEBUG_CONFIG(mport, "config read(destid=0x%x, hopcount=%d, "
+		     "offset=0x%x, len=%d, data=0x%x)\n",
+		     0xffff & destid, 0xff & hopcount, offset, len, *data);
+	return 0;
+}
+
+/**
+ * Remote config write
+ *
+ * @param mport    RapidIO Master port info
+ * @param mport_id Always the same as mport->id
+ * @param destid   Remote destination ID
+ * @param hopcount Number of hops to the device
+ * @param offset   Config space register
+ * @param len      Length of the write (1,2, or 4 bytes)
+ * @param data     Write data
+ *
+ * @return Zero on success, negative on failure
+ */
+static int octeon_rio_cwrite(struct rio_mport *mport, int mport_id, u16 destid,
+			     u8 hopcount, u32 offset, int len, u32 data)
+{
+	if (len != 4) {
+		/* The kernel's RapidIO system defines 8 and 16 bit accesses,
+			but the RapidIO spec says these are illegal */
+		DEBUG_CONFIG(mport, "ERROR: config write with illegal length("
+			     "destid=0x%x, hopcount=%d, offset=0x%x, len=%d)\n",
+			     0xffff & destid, 0xff & hopcount, offset, len);
+		return -EINVAL;
+	}
+	DEBUG_CONFIG(mport, "config write(destid=0x%x, hopcount=%d,"
+		     " offset=0x%x, len=%d, data=0x%x)\n",
+		     0xffff & destid, 0xff & hopcount, offset, len, data);
+	if (cvmx_srio_config_write32(mport_id, OCTEON_RIO_ID, destid,
+		1 /* FIXME: rdev->pef & RIO_PEF_CTLS */, hopcount, offset,
+		data))
+		return -EIO;
+	return 0;
+}
+
+/**
+ * Remote doorbell send
+ *
+ * @param mport    RapidIO Master port info
+ * @param mport_id Always the same as mport->id
+ * @param destid   Remote destination ID
+ * @param data     Data for doorbell
+ *
+ * @return Zero on success, negative on failure
+ */
+static int octeon_rio_dsend(struct rio_mport *mport, int mport_id, u16 destid,
+			    u16 data)
+{
+	DEBUG_DOORBELL(mport, "doorbell(destid=0x%x, data=0x%x)\n",
+		       0xffff & destid, 0xffff & data);
+	return cvmx_srio_send_doorbell(mport_id, OCTEON_RIO_ID, destid,
+		1 /* FIXME: rdev->pef & RIO_PEF_CTLS */,
+		OCTEON_RIO_DOORBELL_PRIORITY, data);
+}
+
+/**
+ * Map a remote SRIO device's memory resource into the local
+ * physical space.
+ *
+ * @param mport  RapidIO Master port info
+ * @param rdev   Remote RapidIO device
+ * @param offset Offset into the remote device's memory space
+ * @param length Length of window to map
+ *
+ * @return Local physical address to use for resource access, or 0 on
+ *         failure.
+ */
+static phys_t octeon_rio_mem_map(struct rio_mport *mport, struct rio_dev *rdev,
+	u64 offset, u64 length)
+{
+	int priority = 0;
+	cvmx_srio_addressing_mode_t address_mode;
+
+	DEBUG_MAP(mport, "map(destid=0x%x, res=0x%llx-0x%llx)\n",
+		0xffff & rdev->destid, offset, offset + length - 1);
+
+	if (rdev->pef & RIO_PEF_ADDR_50)
+		address_mode = CVMX_SRIO_ADDRESSING_MODE_50;
+	else if (rdev->pef & RIO_PEF_ADDR_66)
+		address_mode = CVMX_SRIO_ADDRESSING_MODE_66;
+	else
+		address_mode = CVMX_SRIO_ADDRESSING_MODE_34;
+
+	return cvmx_srio_physical_map(mport->id, CVMX_SRIO_WRITE_MODE_AUTO,
+		priority, CVMX_SRIO_READ_MODE_NORMAL, priority,
+		OCTEON_RIO_ID, address_mode, rdev->destid,
+		rdev->pef & RIO_PEF_CTLS, offset, length);
+}
+
+/**
+ * Unmap a remote resource mapped using octeon_rio_mem_map()
+ *
+ * @param mport  RapidIO Master port info
+ * @param rdev   Remote RapidIO device
+ * @param offset Offset into the remote device's memory space
+ * @param length Length of window to map
+ * @param physical_map
+ *               Physical address the resource was mapped at
+ */
+static void octeon_rio_mem_unmap(struct rio_mport *mport, struct rio_dev *rdev,
+	u64 offset, u64 length, phys_t physical_map)
+{
+	DEBUG_MAP(mport, "unmap(destid=0x%x, res=0x%llx-0x%llx)\n",
+		0xffff & rdev->destid, offset, offset + length - 1);
+	cvmx_srio_physical_unmap(physical_map, length);
+}
+
+/**
+ * Add message to outbound mailbox
+ *
+ * @param mport  RapidIO Master port info
+ * @param rdev   RIO device the message is be sent to
+ * @param mbox   The outbound mailbox queue
+ * @param buffer Pointer to the message buffer
+ * @param length Length of the message buffer
+ *
+ * @return Zero on success, negative on failure
+ */
+int rio_hw_add_outb_message(struct rio_mport *mport, struct rio_dev *rdev,
+			    int mbox, void *buffer, size_t length)
+{
+	DEBUG_MBOX(mport, "OUT", mbox,
+		   "send message(rdev=%p, buffer=%p, length=%lu)\n", rdev,
+		   buffer, length);
+	/* The current implementation of the rionet network driver assumes
+		that outbound buffers must be freed in the callback routine
+		for message complete. This means we can't use the PKO free
+		to FPA pool function. We also need to add an Octeon specific
+		SRIO header, so we might need a gather list */
+	return -EINVAL;
+}
+
+/**
+ * Add empty buffer to inbound mailbox
+ *
+ * @param mport  RapidIO Master port info
+ * @param mbox   The inbound mailbox number
+ * @param buffer Pointer to the message buffer
+ *
+ * @return Zero on success, negative on failure
+ */
+int rio_hw_add_inb_buffer(struct rio_mport *mport, int mbox, void *buffer)
+{
+	DEBUG_MBOX(mport, "IN", mbox, "add buffer %p\n", buffer);
+	/* The current implementation of the rionet network driver assumes
+		that the buffers are used in FIFO order and will always be
+		returned in that same order. This doesn't play well with
+		Octeon's FPA pools */
+	return -EINVAL;
+}
+
+/**
+ * Get the next pending inbound message from a mailbox
+ *
+ * @param mport  RapidIO Master port info
+ * @param mbox   The inbound mailbox number
+ *
+ * @return Mailbox message pointer, or NULL.
+ */
+void *rio_hw_get_inb_message(struct rio_mport *mport, int mbox)
+{
+	DEBUG_MBOX(mport, "IN", mbox, "receive message\n");
+	/* The current implementation of the rionet network driver assumes
+		that the buffers are used in FIFO order and will always be
+		returned in that same order. This doesn't play well with
+		Octeon's FPA pools */
+	return NULL;
+}
+
+/**
+ * Open an inbound mailbox
+ *
+ * @param mport   RapidIO Master port info
+ * @param dev_id  Device specific pointer to pass on event
+ * @param mbox    The inbound mailbox number
+ * @param entries Number of entries allowed in the incomming queue
+ *
+ * @return Zero on success, negative on failure
+ */
+int rio_open_inb_mbox(struct rio_mport *mport, void *dev_id, int mbox,
+		      int entries)
+{
+	DEBUG_MBOX(mport, "IN", mbox, "open(dev_id=%p, entries=%d)\n", dev_id,
+		   entries);
+	return -EINVAL;
+}
+
+/**
+ * Close an inbound mailbox
+ *
+ * @param mport  RapidIO Master port info
+ * @param mbox   The inbound mailbox number
+ */
+void rio_close_inb_mbox(struct rio_mport *mport, int mbox)
+{
+	DEBUG_MBOX(mport, "IN", mbox, "close\n");
+}
+
+/**
+ * Open an outbound mailbox
+ *
+ * @param mport   RapidIO Master port info
+ * @param dev_id  Device specific pointer to pass on event
+ * @param mbox    The outbound mailbox number
+ * @param entries Number of entries allowed in the outgoing queue
+ *
+ * @return Zero on success, negative on failure
+ */
+int rio_open_outb_mbox(struct rio_mport *mport, void *dev_id, int mbox,
+		       int entries)
+{
+	DEBUG_MBOX(mport, "OUT", mbox, "open(dev_id=%p, entries=%d)\n", dev_id,
+		   entries);
+	return -EINVAL;
+}
+
+/**
+ * Close an outbound mailbox
+ *
+ * @param mport  RapidIO Master port info
+ * @param mbox   The outbound mailbox number
+ */
+void rio_close_outb_mbox(struct rio_mport *mport, int mbox)
+{
+	DEBUG_MBOX(mport, "OUT", mbox, "close\n");
+}
+
+/**
+ * Function to process incomming doorbells
+ *
+ * @param mport  SRIO port to check
+ */
+static void octeon_rio_rx_doorbell(struct rio_mport *mport)
+{
+	cvmx_srio_doorbell_status_t status;
+	int destid_index;
+	uint32_t sequence_num;
+	int srcid;
+	int priority;
+	int is16bit;
+	uint16_t data;
+	struct rio_dbell *dbell;
+
+	DEBUG_IRQ(mport, "RX doorbell\n");
+
+	while (1) {
+		status = cvmx_srio_receive_doorbell(mport->id, &destid_index,
+			&sequence_num, &srcid, &priority, &is16bit, &data);
+		if (status != CVMX_SRIO_DOORBELL_DONE)
+			break;
+		list_for_each_entry(dbell, &mport->dbells, node) {
+			if ((dbell->res->start >= data) &&
+			    (dbell->res->end <= data))
+				dbell->dinb(mport, dbell->dev_id, srcid, data,
+					data);
+		}
+	}
+}
+
+/**
+ * Function to handle receiving a packet through the soft fifo
+ *
+ * @param mport  SRIO port to check
+ */
+static void octeon_rio_rx_soft_fifo(struct rio_mport *mport)
+{
+	union cvmx_sriomaintx_ir_sp_rx_stat sp_rx_stat;
+	int status;
+	int length;
+	struct sk_buff *skb;
+
+	while (1) {
+		status = cvmx_srio_config_read32(mport->id, 0, -1, 0, 0,
+			CVMX_SRIOMAINTX_IR_SP_RX_STAT(mport->id),
+			&sp_rx_stat.u32);
+		if (status) {
+			RIO_PRINTK(mport,
+				"Failed read of SRIOMAINTX_IR_SP_RX_STAT\n");
+			return;
+		}
+		if (!sp_rx_stat.s.buffers)
+			break;
+		length = sp_rx_stat.s.octets;
+		skb = dev_alloc_skb((length+3) & -4);
+		while (length > 0) {
+			status = cvmx_srio_config_read32(mport->id, 0, -1, 0, 0,
+				CVMX_SRIOMAINTX_IR_SP_RX_DATA(mport->id),
+				(uint32_t *)skb_put(skb, (length < 4) ?
+				length : 4));
+			if (status) {
+				RIO_PRINTK(mport, "Failed soft packet read\n");
+				dev_kfree_skb_any(skb);
+				return;
+			}
+			length -= 4;
+		}
+
+		DEBUG_PACKET(mport, "RX", "%d byte packet\n", skb->len);
+		/* FIXME: Do something with the packet */
+		dev_kfree_skb_any(skb);
+	}
+}
+
+/**
+ * Function to handle completion status of TX doorbells
+ *
+ * @param mport  SRIO port to check
+ */
+static void octeon_rio_tx_doorbell(struct rio_mport *mport)
+{
+	cvmx_srio_doorbell_status_t status;
+	status = cvmx_srio_send_doorbell_status(mport->id);
+	switch (status) {
+	case CVMX_SRIO_DOORBELL_DONE:
+		DEBUG_IRQ(mport, "TX doorbell complete\n");
+		break;
+	case CVMX_SRIO_DOORBELL_NONE:
+		break;
+	case CVMX_SRIO_DOORBELL_BUSY:
+		DEBUG_IRQ(mport, "TX doorbell busy\n");
+		break;
+	case CVMX_SRIO_DOORBELL_RETRY:
+		DEBUG_IRQ(mport, "TX doorbell needs retry\n");
+		break;
+	case CVMX_SRIO_DOORBELL_ERROR:
+		DEBUG_IRQ(mport, "TX doorbell error\n");
+		break;
+	}
+}
+
+/**
+ * Delayed work handler for SRIO.
+ *
+ * @param work   Work to process
+ */
+static void octeon_rio_work(struct work_struct *work)
+{
+	struct octeon_rio_port *my_port = container_of(work, struct octeon_rio_port, work);
+	struct rio_mport *mport = &my_port->mport;
+	cvmx_sriox_int_reg_t srio_int_reg;
+
+	DEBUG_IRQ(mport, "Work\n");
+
+	/* Get which interrupt fired. Ignore disabled interrupts */
+	srio_int_reg.u64 = cvmx_read_csr(CVMX_SRIOX_INT_REG(mport->id));
+	srio_int_reg.u64 &= cvmx_read_csr(CVMX_SRIOX_INT_ENABLE(mport->id));
+
+	/* Clear the interrupts before we start processing them */
+	cvmx_write_csr(CVMX_SRIOX_INT_REG(mport->id), srio_int_reg.u64);
+
+	/* SRIO Link transitioned up */
+	if (srio_int_reg.s.link_up)
+		DEBUG_IRQ(mport, "Link up\n");
+
+	/* SRIO Link transitioned down */
+	if (srio_int_reg.s.link_dwn)
+		DEBUG_IRQ(mport, "Link down\n");
+
+	/* Received a doorbell */
+	if (srio_int_reg.s.rxbell)
+		octeon_rio_rx_doorbell(mport);
+
+	/* Received a packet to the soft fifo */
+	if (srio_int_reg.s.soft_rx)
+		octeon_rio_rx_soft_fifo(mport);
+
+	/* TX doorbell */
+	if (srio_int_reg.s.bell_err || srio_int_reg.s.txbell)
+		octeon_rio_tx_doorbell(mport);
+
+	enable_irq(OCTEON_IRQ_SRIO0 + mport->id);
+}
+
+/**
+ * Interrupt handler for SRIO.
+ *
+ * @param irq     IRQ number
+ * @param irq_arg Rapid IO port structure
+ *
+ * @return IRQ_HANDLED
+ */
+static irqreturn_t octeon_rio_irq(int irq, void *irq_arg)
+{
+	struct rio_mport *mport = (struct rio_mport *)irq_arg;
+	struct octeon_rio_port *my_port = container_of(mport, struct octeon_rio_port, mport);
+
+	DEBUG_IRQ(mport, "Interrupt\n");
+	disable_irq(irq);
+	schedule_work(&my_port->work);
+	return IRQ_HANDLED;
+}
+
+/**
+ * Initialize the RapidIO system
+ *
+ * @return Zero on success, negative on failure.
+ */
+static int __init octeon_rio_init(void)
+{
+	static struct octeon_rio_port srio_ports[2];
+	static struct rio_ops srio_ops;
+
+	int srio_port;
+	if (!octeon_has_feature(OCTEON_FEATURE_SRIO))
+		return 0;
+	memset(&srio_ops, 0, sizeof(srio_ops));
+	srio_ops.lcread = octeon_rio_lcread;
+	srio_ops.lcwrite = octeon_rio_lcwrite;
+	srio_ops.cread = octeon_rio_cread;
+	srio_ops.cwrite = octeon_rio_cwrite;
+	srio_ops.dsend = octeon_rio_dsend;
+	srio_ops.map = octeon_rio_mem_map;
+	srio_ops.unmap = octeon_rio_mem_unmap;
+
+	memset(srio_ports, 0, sizeof(srio_ports));
+	for (srio_port = 0; srio_port < 2; srio_port++) {
+		cvmx_sriox_int_enable_t int_enable;
+		cvmx_sriox_status_reg_t sriox_status_reg;
+		cvmx_mio_rst_ctlx_t mio_rst_ctl;
+		sriox_status_reg.u64 =
+			cvmx_read_csr(CVMX_SRIOX_STATUS_REG(srio_port));
+		if (!sriox_status_reg.s.srio)
+			continue;
+		INIT_WORK(&srio_ports[srio_port].work, octeon_rio_work);
+		srio_ports[srio_port].mport.host_deviceid = 0;
+		srio_ports[srio_port].mport.ops = &srio_ops;
+		srio_ports[srio_port].mport.id = srio_port;
+		srio_ports[srio_port].mport.index = 0;
+		srio_ports[srio_port].mport.sys_size = 1;
+		srio_ports[srio_port].mport.iores.start =
+			CVMX_SRIOX_STATUS_REG(srio_port) & ((1ull << 49) - 1);
+		srio_ports[srio_port].mport.iores.end =
+			srio_ports[srio_port].mport.iores.start + 256;
+		srio_ports[srio_port].mport.iores.flags = IORESOURCE_MEM;
+		srio_ports[srio_port].mport.iores.name = "SRIO CSRs";
+		srio_ports[srio_port].mport.phy_type = RIO_PHY_SERIAL;
+		sprintf(srio_ports[srio_port].mport.name, "SRIO%d", srio_port);
+		RIO_PRINTK(&srio_ports[srio_port].mport, "Registering port\n");
+		if (cvmx_srio_initialize(srio_port,
+			CVMX_SRIO_INITIALIZE_DEBUG) == 0) {
+			rio_register_mport(&srio_ports[srio_port].mport);
+			/* Clear all SRIO interrupts and enables */
+			cvmx_write_csr(CVMX_SRIOX_INT_ENABLE(srio_port), 0);
+			cvmx_write_csr(CVMX_SRIOX_INT_REG(srio_port),
+				cvmx_read_csr(CVMX_SRIOX_INT_REG(srio_port)));
+			if (request_irq(OCTEON_IRQ_SRIO0 + srio_port,
+				octeon_rio_irq, IRQF_SHARED, "SRIO",
+				&srio_ports[srio_port].mport)) {
+				RIO_PRINTK(&srio_ports[srio_port].mport,
+					"Failed to register IRQ handler\n");
+			} else {
+				/* Enable the interrupts we care about */
+				int_enable.u64 = 0;
+				int_enable.s.link_dwn = 1;
+				int_enable.s.link_up = 1;
+				int_enable.s.rxbell = 1;
+				int_enable.s.bell_err = 1;
+				int_enable.s.txbell = 1;
+				int_enable.s.soft_rx = 1;
+				cvmx_write_csr(CVMX_SRIOX_INT_ENABLE(srio_port),
+					int_enable.u64);
+			}
+		}
+	}
+	return rio_init_mports();
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks Rapid IO driver.");
+late_initcall(octeon_rio_init);
-- 
1.6.5.2

