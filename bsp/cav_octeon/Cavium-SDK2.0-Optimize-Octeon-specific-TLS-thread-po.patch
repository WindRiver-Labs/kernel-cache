From 39952a49be7e5d81d5651808fb8038031b387c9c Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Thu, 18 Nov 2010 10:10:14 +0800
Subject: [PATCH 001/132] Cavium: SDK2.0 Optimize Octeon-specific TLS thread pointer

Source: SDK 2.0.0-366

For MIPS, normally the TLS thread pointer is accessed by the userspace
program executing a "rdhwr" from register $29. This register doesn't
exist, so the kernel emulates the instruction assigning the thread
pointer to the value register. This option supplies an alternate,
faster access to the thread pointer. A side effect of this option is
that the highest 8 bytes of CVMSEG is used by the kernel to save and
restore the thread pointer during the TLB fault handlers. This CVMSEG
address isn't available to user applications.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig  |   12 ++++++-
 arch/mips/include/asm/mipsregs.h |   25 +++++++++----
 arch/mips/kernel/syscall.c       |   28 +++++++++++++++
 arch/mips/kernel/unaligned.c     |   70 +++++++++++++++++++++-----------------
 4 files changed, 95 insertions(+), 40 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 8e3f9ba..45495c6 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -37,9 +37,19 @@ config CAVIUM_OCTEON_CVMSEG_SIZE
 	  legally range is from zero to 54 cache blocks (i.e. CVMSEG LM is
 	  between zero and 6192 bytes).
 
+	  For Mips, performance-critical kernel routines (like the TLB
+	  miss handlers) can normally only use registers K0 and K1
+	  ($26 and $27) from the main register file. If this option is
+	  set to a value greater than zero, the kernel allocates space
+	  in CVMSEG LM for use as a scratch register. This can make
+	  the kernel routines run faster. A side effect of this is
+	  that the kernel will clobber the top 16 bytes in CVMSEG LM
+	  space.  Consequently those locations are not available to
+	  user applications.
+
 config FAST_ACCESS_TO_THREAD_POINTER
 	bool "Enable fast access to the thread pointer"
-	depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
+	depends on CPU_CAVIUM_OCTEON
 	default "y"
 	help
 	  For MIPS, normally the TLS thread pointer is accessed by the
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 208048f..745944c 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -408,6 +408,7 @@
 #define  STATUSB_IP15		7
 #define  STATUSF_IP15		(_ULCAST_(1) <<  7)
 #define ST0_CH			0x00040000
+#define ST0_NMI			0x00080000
 #define ST0_SR			0x00100000
 #define ST0_TS			0x00200000
 #define ST0_BEV			0x00400000
@@ -613,16 +614,24 @@
 #define MIPS_FPIR_F64		(_ULCAST_(1) << 22)
 
 /*
- * These defines are used on Octeon to implement fast access to the thread pointer
- * from userspace. Octeon uses a 64bit location in CVMSEG to store the thread pointer
- * for quick access.
+ * These defines are used on Octeon to implement fast access to the
+ * thread pointer from userspace. Octeon uses a 64bit location in
+ * CVMSEG to store the thread pointer for quick access.
  */
-#define TOP_OF_CVMSEG_STORE        (CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE*128-32768)
 #ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
-#define FAST_ACCESS_THREAD_OFFSET       (TOP_OF_CVMSEG_STORE-8)
-#define FAST_ACCESS_THREAD_REGISTER     *(unsigned long *)(FAST_ACCESS_THREAD_OFFSET)
-#else
-#define FAST_ACCESS_THREAD_OFFSET       TOP_OF_CVMSEG_STORE
+#define FAST_ACCESS_THREAD_OFFSET       (CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE * 128 - 8 - 32768)
+#define FAST_ACCESS_THREAD_REGISTER     (*(unsigned long *)(FAST_ACCESS_THREAD_OFFSET))
+#endif
+
+#if defined(CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE)
+# if CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE > 0
+/*
+ * CVMSEG starts at address -32768 and extends for
+ * CAVIUM_OCTEON_CVMSEG_SIZE 128 byte cache lines.
+ */
+#define TEMPORARY_SCRATCHPAD_FOR_KERNEL_OFFSET(i) \
+	(CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE * 128 - (8 * ((i) + 2)) - 32768)
+# endif
 #endif
 
 #ifndef __ASSEMBLY__
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index 803f48e..c8f4e65 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -42,6 +42,7 @@
 #include <asm/shmparam.h>
 #include <asm/sysmips.h>
 #include <asm/uaccess.h>
+#include <linux/elf.h>
 
 #if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
 	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
@@ -146,6 +147,33 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,
 	}
 }
 
+static inline unsigned long brk_rnd(void)
+{
+	unsigned long rnd = get_random_int();
+
+	rnd = rnd << PAGE_SHIFT;
+       /* 8MB for 32bit, 256MB for 64bit */
+	if (TASK_IS_32BIT_ADDR)
+		rnd = rnd & 0x7ffffful;
+	else
+		rnd = rnd & 0xffffffful;
+
+	return rnd;
+}
+
+unsigned long arch_randomize_brk(struct mm_struct *mm)
+{
+	unsigned long base = mm->brk;
+	unsigned long ret;
+
+	ret = PAGE_ALIGN(base + brk_rnd());
+
+	if (ret < mm->brk)
+		return mm->brk;
+
+	return ret;
+}
+
 SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,
 	unsigned long, prot, unsigned long, flags, unsigned long,
 	fd, off_t, offset)
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index 467f97b..60bc1de 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -518,38 +518,46 @@ asmlinkage void do_ade(struct pt_regs *regs)
 	mm_segment_t seg;
 
 #if defined(CONFIG_CPU_CAVIUM_OCTEON) && (CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE > 0)
-	/* This section of code allows tasks to access CVMSEG addresses. These are
-	 * special addresses into the Octeon L1 Cache that can be used as fast
-	 * scratch memory. By default access to this memory is disabled so we
-	 * don't have to save it on context switch. When a userspace task
-	 * references one of these addresses, we enable the region and size it
-	 * to match the app
-	 */
-	const unsigned long CVMSEG_BASE  = (short)0x8000;
-	const unsigned long CVMSEG_IO    = (short)0xa200;
-	uint64_t cvmmemctl               = __read_64bit_c0_register($11, 7);
-	unsigned long cvmseg_size        = (cvmmemctl&0x3f) * 128;
-
-	if ((regs->cp0_badvaddr==CVMSEG_IO) ||
-	    ((regs->cp0_badvaddr>=CVMSEG_BASE) && (regs->cp0_badvaddr<CVMSEG_BASE + cvmseg_size)))
-	{
-		/* Make sure all async operations are done */
-		asm volatile ("synciobdma" ::: "memory");
-		/* Enable userspace access to CVMSEG */
-		cvmmemctl |= 1<<6;
-		__write_64bit_c0_register($11, 7, cvmmemctl);
-
-		pr_debug("Enabling CVMSEG access for task %p (%lu lines)\n", current, (unsigned long)cvmmemctl&0x3f);
-#ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
-		/* Restore the processes CVMSEG data. Leave off the last 8 bytes since
-		 * the kernel stores the thread pointer there
+       {
+		/*
+		 * This section of code allows tasks to access CVMSEG
+		 * addresses. These are special addresses into the
+		 * Octeon L1 Cache that can be used as fast scratch
+		 * memory. By default access to this memory is
+		 * disabled so we don't have to save it on context
+		 * switch. When a userspace task references one of
+		 * these addresses, we enable the region and size it
+		 * to match the app.
 		 */
-		memcpy((void*)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size-8);
-#else
-		/* Restore the processes CVMSEG data */
-		memcpy((void*)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size);
-#endif
-		return;
+		const unsigned long CVMSEG_BASE = 0xffffffffffff8000ul;
+		const unsigned long CVMSEG_IO   = 0xffffffffffffa200ul;
+		uint64_t cvmmemctl              = __read_64bit_c0_register($11, 7);
+		unsigned long cvmseg_size       = (cvmmemctl & 0x3f) * 128;
+
+		if ((regs->cp0_badvaddr == CVMSEG_IO) ||
+			((regs->cp0_badvaddr >= CVMSEG_BASE) && (regs->cp0_badvaddr < CVMSEG_BASE + cvmseg_size))) {
+			preempt_disable();
+			cvmmemctl = __read_64bit_c0_register($11, 7);
+			/* Make sure all async operations are done */
+			asm volatile ("synciobdma" ::: "memory");
+			/* Enable userspace access to CVMSEG */
+			cvmmemctl |= 1<<6;
+			__write_64bit_c0_register($11, 7, cvmmemctl);
+
+# ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
+			/*
+			 * Restore the processes CVMSEG data. Leave
+			 * off the last 8 bytes since the kernel
+			 * stores the thread pointer there.
+			 */
+			memcpy((void *)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size - 8);
+# else
+			/* Restore the processes CVMSEG data */
+			memcpy((void *)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size);
+# endif
+			preempt_enable();
+			return;
+		}
 	}
 #endif
 
-- 
1.7.0.4

