From 0d60cf0c9dfcfe51fbb9f9d0be9b8c19e652f5e5 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Sat, 21 Aug 2010 12:35:08 -0700
Subject: [PATCH] kexec/cavium: fix crash kernel boot failing on 58xx

First, fix on-SoC POW-driven-device reset. Updated to use latest-SDK's
reset sequence, namely:

 - Obtain device work from POW from pow_work_request_sync() API
   to drain the rx queues
 - Shutdown RX/TX on devices
 - Clear possible pending interrupts from first kernel in POW
 - Add handling of SGMII and XAUI interface modes

Second, handle bootmem allocation differently for crash kernel.
Previous implementation tried to free bootmem then reallocate it.
In fact, this is superflous, since the memory has alread been
allocated by the bootloader to the first kernel. The crash kernel
will run from inside some of that memory. Simply bypass allocation
if running a crash kernel.

Thirdly, remove a forgotten debugging printk().

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/mips/cavium-octeon/setup.c           |   16 +++++++++++-
 drivers/staging/octeon/ethernet.c         |    1 -
 drivers/staging/octeon/octeon-kexec-net.c |   37 +++++++++++++++++++---------
 3 files changed, 40 insertions(+), 14 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index fa5d2ab..9a31bff 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -677,6 +677,7 @@ void __init prom_init(void)
 	for (i = 0; i < argc; i++) {
 		const char *arg =
 			cvmx_phys_to_ptr(octeon_boot_desc_ptr->argv[i]);
+#ifndef CONFIG_CRASH_DUMP
 		if ((strncmp(arg, "MEM=", 4) == 0) ||
 		    (strncmp(arg, "mem=", 4) == 0)) {
 			char mult = '?';
@@ -692,7 +693,9 @@ void __init prom_init(void)
 			}
 			if (MAX_MEMORY == 0)
 				MAX_MEMORY = 32ull << 30;
-		} else if (strcmp(arg, "ecc_verbose") == 0) {
+		} else
+#endif /* CONFIG_CRASH_DUMP */
+		if (strcmp(arg, "ecc_verbose") == 0) {
 #ifdef CONFIG_CAVIUM_REPORT_SINGLE_BIT_ECC
 			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
 			pr_notice("Reporting of single bit ECC errors is "
@@ -781,6 +784,7 @@ void __init prom_init(void)
 #define OCTEON_MAX_PHY_MEM_SIZE (16*1024*1024*1024ULL)
 #define OCTEON_LINUX_RESERVED_MEM_NAME    "__tmp_reserved_linux"
 
+#ifndef CONFIG_CRASH_DUMP
 void cleanup_phy_mem(void)
 {
 	/* Ensure all memory is cleaned up.
@@ -841,6 +845,12 @@ void cleanup_phy_mem(void)
 		}
 	}
 }
+#else
+void cleanup_phy_mem(void)
+{
+	/* do nothing */
+}
+#endif /* CONFIG_CRASH_DUMP */
 
 void __init plat_mem_setup(void)
 {
@@ -871,6 +881,9 @@ void __init plat_mem_setup(void)
 	if (mem_alloc_size > MAX_MEMORY)
 		mem_alloc_size = MAX_MEMORY;
 
+/* only allocate from bootmem when not a crash dump kernel (memory layout is
+   defined by mem= by kexec in that case) */
+#ifndef CONFIG_CRASH_DUMP
 	/*
 	 * When allocating memory, we want incrementing addresses from
 	 * bootmem_alloc so the code in add_memory_region can merge
@@ -906,6 +919,7 @@ void __init plat_mem_setup(void)
 		}
 	}
 	cvmx_bootmem_unlock();
+#endif
 
 #ifdef CONFIG_CAVIUM_RESERVE32
 	/*
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index fa5d3b2..efb4b5d 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -608,7 +608,6 @@ static int __init cvm_oct_init_module(void)
 	int qos;
 
 #ifdef CONFIG_KEXEC
-printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
 	if (reset_devices)
 		octeon_shutdown_network_hw();
 #endif
diff --git a/drivers/staging/octeon/octeon-kexec-net.c b/drivers/staging/octeon/octeon-kexec-net.c
index b47d01c..97d2915 100644
--- a/drivers/staging/octeon/octeon-kexec-net.c
+++ b/drivers/staging/octeon/octeon-kexec-net.c
@@ -12,6 +12,7 @@
 #include "cvmx-pko-defs.h"
 #include "cvmx-smix-defs.h"
 #include "cvmx-pow.h"
+#include "cvmx-asxx-defs.h"
 
 void octeon_shutdown_network_hw(void)
 {
@@ -27,14 +28,7 @@ void octeon_shutdown_network_hw(void)
 	union cvmx_smix_en smix_en;
 	union cvmx_ipd_ctl_status ipd_ctl_status;
 	union cvmx_pip_sft_rst pip_sft_rst;
-
-	/* free up the work queue associated with this core */
-	work = cvmx_pow_get_current_wqp();
-	if (NULL != work) {
-		/* drain the work queue and free it */
-		cvmx_helper_free_packet_data(work);
-		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
-	}
+	union cvmx_pow_wq_int wq_int;
 
 	/* halt the interfaces */
 	num_ints = cvmx_helper_get_number_of_interfaces();
@@ -43,10 +37,18 @@ void octeon_shutdown_network_hw(void)
 
 	/* Check to see what interface and ports we should use */
 	for (interface = 0; interface < num_ints; interface++) {
-		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
-			cvmx_helper_interface_get_mode(interface)) ||
-			(CVMX_HELPER_INTERFACE_MODE_GMII ==
-				cvmx_helper_interface_get_mode(interface))) {
+		cvmx_helper_interface_mode_t mode =
+			cvmx_helper_interface_get_mode(interface);
+		int xGMII_mode = (CVMX_HELPER_INTERFACE_MODE_RGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_SGMII == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_GMII  == mode) ||
+				 (CVMX_HELPER_INTERFACE_MODE_XAUI  == mode);
+
+		if (xGMII_mode) {
+			/* disable RX and TX */
+			cvmx_write_csr(CVMX_ASXX_RX_PRT_EN(interface), 0x0);
+			cvmx_write_csr(CVMX_ASXX_TX_PRT_EN(interface), 0x0);
+
 			/* get the ports for this interface */
 			cvmx_helper_interface_probe(interface);
 			num_ports = cvmx_helper_ports_on_interface(interface);
@@ -61,6 +63,17 @@ void octeon_shutdown_network_hw(void)
 		}
 	}
 
+	/* drain the work queue and free it */
+	while ((work = cvmx_pow_work_request_sync(CVMX_POW_WAIT))) {
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* clear possible pending interrupt */
+	wq_int.u64 = 0;
+	wq_int.s.wq_int = 1 << 15;
+	cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
+
 	/* disable the SMI */
 	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
 	if (smix_en.s.en) {
-- 
1.6.5.2

