From 3335dafbaece40e57f83182250012385602d680a Mon Sep 17 00:00:00 2001
From: jack.tan@windriver.com <jack.tan@windriver.com>
Date: Fri, 2 Jul 2010 14:43:39 +0800
Subject: [PATCH] CF: rework driver to use workqueue instead of tasklet

Make driver use a workqueue struct instead of a tasklet.
The way the tasklet was written was causing a kernel hung
when mkfs or extract a standard rootfs.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/cavium-octeon/ebt3000_cf.c |   45 ++++++++++++++++++++++++++++------
 1 files changed, 37 insertions(+), 8 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index 623ee51..a870be8 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -82,6 +82,8 @@ struct cf_device {
 	void *current_buffer;	/* Memory buffer for the current request */
 
 	struct tasklet_struct poll_tasklet;
+	struct workqueue_struct *workqueue;
+	struct work_struct cf_work;
 	struct timer_list timeout_timer;
 };
 
@@ -90,6 +92,8 @@ struct cf_device {
    device assumptions were made */
 static struct cf_device STATIC_DEVICE;
 static void octeon_ide_polled_io(unsigned long data);
+static void octeon_cf_work(struct work_struct *work);
+static void octeon_cf_work_xfer(struct work_struct *work);
 
 
 /**
@@ -173,8 +177,8 @@ static void octeon_ide_start_transfer(unsigned long data)
 	/* Try again later if the device is busy. We have to poll since we
 	   don't have the INTRQ interrupt */
 	if (octeon_ide_read_reg(cf, ATA_REG_STATUS) & ATA_BUSY) {
-		cf->poll_tasklet.func = octeon_ide_start_transfer;
-		tasklet_schedule(&cf->poll_tasklet);
+		cf->cf_work.func = octeon_cf_work_xfer;
+		queue_work(cf->workqueue, &cf->cf_work);
 		return;
 	}
 
@@ -198,8 +202,8 @@ static void octeon_ide_start_transfer(unsigned long data)
 		ide_command = (is_write) ? WIN_WRITEDMA : WIN_READDMA;
 	} else {
 		/* We need a polling tasklet since we don't have DMA */
-		cf->poll_tasklet.func = octeon_ide_polled_io;
-		tasklet_schedule(&cf->poll_tasklet);
+		cf->cf_work.func = octeon_cf_work;
+		queue_work(cf->workqueue, &cf->cf_work);
 		ide_command = (is_write) ? WIN_WRITE : WIN_READ;
 	}
 	mb();
@@ -209,6 +213,15 @@ static void octeon_ide_start_transfer(unsigned long data)
 }
 
 
+static void octeon_cf_work_xfer(struct work_struct *work)
+{
+	struct cf_device *cf = container_of(work, struct cf_device, cf_work);
+	if (cf == NULL) {
+		printk(KERN_ERR "Get cf_device error! \n");
+		return;
+	}
+	octeon_ide_start_transfer((unsigned long)cf);
+}
 /**
  * Submit the next pending request to the IDE. If there is a
  * request currently processing, then nothing is done.
@@ -237,6 +250,16 @@ static void octeon_ide_handle_next_request(struct cf_device *cf)
 	}
 }
 
+static void octeon_cf_work(struct work_struct *work)
+{
+	struct cf_device *cf = container_of(work, struct cf_device, cf_work);
+	if (cf == NULL) {
+		printk(KERN_ERR "Get cf_device error! \n");
+		return;
+	}
+	octeon_ide_polled_io((unsigned long)cf);
+}
+
 
 /**
  * Called as a tasklet when we don't have DMA. This function polls
@@ -263,7 +286,7 @@ static void octeon_ide_polled_io(unsigned long data)
 
 		/* Reschedule ourselves if the device is still busy */
 		if (status & ATA_BUSY) {
-			tasklet_schedule(&cf->poll_tasklet);
+			queue_work(cf->workqueue, &cf->cf_work);
 			return;
 		}
 
@@ -327,7 +350,7 @@ static void octeon_ide_polled_io(unsigned long data)
 
 	/* We don't complete the transaction until the IDE is idle again */
 	if (octeon_ide_read_reg(cf, ATA_REG_STATUS) & ATA_BUSY) {
-		tasklet_schedule(&cf->poll_tasklet);
+		queue_work(cf->workqueue, &cf->cf_work);
 		return;
 	}
 
@@ -658,8 +681,14 @@ static int __init octeon_ide_module_init(void)
 	cf->base_ptr =
 		cvmx_phys_to_ptr(octeon_bootinfo->
 				 compact_flash_common_base_addr);
-	tasklet_init(&cf->poll_tasklet, octeon_ide_polled_io,
-		     (unsigned long) cf);
+
+	cf->workqueue = create_singlethread_workqueue(DEVICE_NAME "-worker");
+	if (cf->workqueue == NULL) {
+		printk(KERN_ERR "Unable to create workqueue\n");
+		return -ENOMEM;
+	}
+	INIT_WORK(&cf->cf_work, octeon_cf_work);
+
 	setup_timer(&cf->timeout_timer, octeon_ide_timeout, (unsigned long)cf);
 
 	/* Determine from base address is in true IDE mode or not */
-- 
1.7.0.4

