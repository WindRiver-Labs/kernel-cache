From 203f5e370d3782f26ddc6729d0e4b08cdaa88395 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Thu, 11 Nov 2010 17:59:50 +0800
Subject: [PATCH 027/132] Cavium: Add Cavium GDB stub support

Source: SDK 2.0.0-366 and Internal development

Enable Cavium Octeon sepcific GDB stub.
CONFIG_CAVIUM_GDB needs to be selected to enable this feature.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/Kconfig                     |    2 +
 arch/mips/Kconfig.debug               |   20 ++++++++--------
 arch/mips/cavium-octeon/serial.c      |   42 +++++++++++++++++++-------------
 arch/mips/cavium-octeon/setup.c       |   13 ++++------
 arch/mips/include/asm/octeon/octeon.h |    3 +-
 5 files changed, 44 insertions(+), 36 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 4b2760f..7779a96 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -649,6 +649,7 @@ config CAVIUM_OCTEON_SIMULATOR
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_HOTPLUG_CPU
+        select SYS_SUPPORTS_KGDB
 	select SYS_HAS_EARLY_PRINTK
 	select SYS_HAS_CPU_CAVIUM_OCTEON
 	help
@@ -666,6 +667,7 @@ config CAVIUM_OCTEON_REFERENCE_BOARD
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_HOTPLUG_CPU
 	select SYS_SUPPORTS_EDAC
+	select SYS_SUPPORTS_KGDB
 	select SYS_HAS_EARLY_PRINTK
 	select SYS_HAS_CPU_CAVIUM_OCTEON
 	select SWAP_IO_SPACE
diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug
index 249d1b0..0a4d30d 100644
--- a/arch/mips/Kconfig.debug
+++ b/arch/mips/Kconfig.debug
@@ -93,6 +93,16 @@ config SB1XXX_CORELIS
 	  Select compile flags that produce code that can be processed by the
 	  Corelis mksym utility and UDB Emulator.
 
+config CAVIUM_GDB
+       bool "Remote GDB debugging using the Cavium Networks Multicore GDB"
+       depends on DEBUG_KERNEL
+       depends on CPU_CAVIUM_OCTEON && !KGDB
+       select DEBUG_INFO
+       help
+         If you say Y here, it will be possible to remotely debug the MIPS
+         kernel using the Cavium Networks GDB with extended SMP support.
+         This is only useful for kernel hackers. If unsure, say N.
+
 config RUNTIME_DEBUG
 	bool "Enable run-time debugging"
 	depends on DEBUG_KERNEL
@@ -128,14 +138,4 @@ config SPINLOCK_TEST
 	help
 	  Add several files to the debugfs to test spinlock speed.
 
-config CAVIUM_GDB
-	bool "Remote GDB debugging using the Cavium Networks Multicore GDB"
-	depends on DEBUG_KERNEL
-	depends on CPU_CAVIUM_OCTEON
-	select DEBUG_INFO
-	help
-	  If you say Y here, it will be possible to remotely debug the MIPS
-	  kernel using the Cavium Networks GDB with extended SMP support.
-	  This is only useful for kernel hackers. If unsure, say N.
-
 endmenu
diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index c0a433d..ce084e5 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -18,7 +18,7 @@
 
 #include <asm/octeon/octeon.h>
 
-#if defined(CONFIG_CAVIUM_GDB)
+#if defined(CONFIG_CAVIUM_GDB) || defined(CONFIG_KGDB)
 static int cavium_gdb_active;
 
 static int __init opt_cavium_gdb(char *p)
@@ -29,25 +29,30 @@ static int __init opt_cavium_gdb(char *p)
 }
 early_param("cavium_gdb", opt_cavium_gdb);
 
+
 #ifdef CONFIG_GDB_CONSOLE
 #define DEBUG_UART 0
 #else
 #define DEBUG_UART 1
 #endif
 
-static irqreturn_t interruptDebugChar(int cpl, void *dev_id)
+static irqreturn_t interrupt_debug_char(int cpl, void *dev_id)
 {
 	unsigned long lsrval;
-	lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(1));
+	unsigned long tmp;
+
+	lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(DEBUG_UART));
 	if (lsrval & 1) {
-		unsigned long tmp;
-		/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also set
-		   the MCD0 to be not masked by this core so we know the signal
-		   is received by someone */
+		/*
+		 * Pulse MCD0 signal on Ctrl-C to stop all the
+		 * cores. Also set the MCD0 to be not masked by this
+		 * core so we know the signal is received by
+		 * someone.
+		 */
 		octeon_write_lcd("brk");
-		asm volatile ("dmfc0 %0, $22\n"
-			      "ori   %0, %0, 0x10\n"
-			      "dmtc0 %0, $22\n" : "=r" (tmp));
+		asm volatile ("dmfc0 %0, $22\n\t"
+			      "ori   %0, %0, 0x10\n\t"
+			      "dmtc0 %0, $22" : "=r" (tmp));
 		octeon_write_lcd("");
 		return IRQ_HANDLED;
 	}
@@ -62,12 +67,12 @@ static int octeon_setup_debug_uart(void)
 	   kernel command line */
 	if (cavium_gdb_active) {
 		if (request_irq(OCTEON_IRQ_UART0 + DEBUG_UART,
-				interruptDebugChar, IRQF_SHARED, "Cavium GDB",
-				interruptDebugChar)) {
-			panic("request_irq(%d) failed.", OCTEON_IRQ_UART0 + DEBUG_UART);
+				interrupt_debug_char, IRQF_SHARED, "Cavium GDB",
+				interrupt_debug_char)) {
+			panic("request_irq(%d) failed.",
+			      OCTEON_IRQ_UART0 + DEBUG_UART);
 		}
 
-		/* Enable uart1 interrupts for debugger Control-C processing */
 		cvmx_write_csr(CVMX_MIO_UARTX_IER(DEBUG_UART),
 			cvmx_read_csr(CVMX_MIO_UARTX_IER(DEBUG_UART)) | 1);
 	}
@@ -77,7 +82,7 @@ static int octeon_setup_debug_uart(void)
 /* Install this as early as possible to be able to debug the boot
    sequence.  */
 core_initcall(octeon_setup_debug_uart);
-#endif  /* CONFIG_CAVIUM_GDB */
+#endif	/* CONFIG_CAVIUM_GDB */
 
 unsigned int octeon_serial_in(struct uart_port *up, int offset)
 {
@@ -120,7 +125,11 @@ static void __init octeon_uart_set_common(struct plat_serial8250_port *p)
 	p->type = PORT_OCTEON;
 	p->iotype = UPIO_MEM;
 	p->regshift = 3;	/* I/O addresses are every 8 bytes */
-	p->uartclk = mips_hpt_frequency;
+	if (octeon_is_simulation())
+		/* Make simulator output fast*/
+		p->uartclk = 115200 * 16;
+	else
+		p->uartclk = octeon_get_io_clock_rate();
 	p->serial_in = octeon_serial_in;
 	p->serial_out = octeon_serial_out;
 }
@@ -152,7 +161,6 @@ static int __init octeon_serial_init(void)
 	enable_uart1 = 1;
 #endif
 #endif
-
 #if defined(CONFIG_CAVIUM_GDB)
 	/* As a special case forcibly disable uart1 if cavium gdb is in use */
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 44dfa0b..6290e06 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -33,6 +33,8 @@
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-error.h>
+#include <asm/octeon/cvmx-debug.h>
 
 #ifdef CONFIG_KEXEC
 #include <linux/kexec.h>
@@ -796,16 +798,11 @@ void __init prom_init(void)
 
 
 #ifdef CONFIG_CAVIUM_GDB
-	/*
-	 * When debugging the linux kernel, force the cores to enter
-	 * the debug exception handler to break in.
-	 */
-	if (octeon_get_boot_debug_flag()) {
-		cvmx_write_csr(CVMX_CIU_DINT, 1 << cvmx_get_core_num());
-		cvmx_read_csr(CVMX_CIU_DINT);
-	}
+	cvmx_debug_init();
 #endif
 
+	octeon_setup_delays();
+
 	/*
 	 * BIST should always be enabled when doing a soft reset. L2
 	 * Cache locking for instance is not cleared unless BIST is
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 188c2b3..8f4e059 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -223,7 +223,6 @@ struct octeon_i2c_data {
 
 extern void octeon_write_lcd(const char *s);
 extern void octeon_check_cpu_bist(void);
-extern int octeon_get_boot_debug_flag(void);
 extern int octeon_get_boot_uart(void);
 
 struct uart_port;
@@ -256,4 +255,6 @@ static inline uint32_t octeon_npi_read32(uint64_t address)
 
 extern struct cvmx_bootinfo *octeon_bootinfo;
 
+extern u64 octeon_bootloader_entry_addr;
+
 #endif /* __ASM_OCTEON_OCTEON_H */
-- 
1.6.5.2

