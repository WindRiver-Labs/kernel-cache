From 760cdcb0ca0623098af32e5f636bcf7e4f3b8913 Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 24 Sep 2009 14:12:23 -0700
Subject: [PATCH] Cavium: Add SPI support

Support files and enablement for the SPI driver.

The current state of these files reflects an ongoing development
process, and as such implies an extensive modification history that is
not cited in detail here.

Supplied by David Daney <ddaney@caviumnetworks.com>

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/spi-octeon.c             |  293 +++++++++++++++++++
 drivers/spi/Kconfig                              |    7 +-
 drivers/spi/Makefile                             |    3 +
 drivers/spi/spi_octeon.c                         |  324 ++++++++++++++++++++++
 include/asm-mips/mach-cavium-octeon/spi-octeon.h |   25 ++
 5 files changed, 651 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/spi-octeon.c
 create mode 100644 drivers/spi/spi_octeon.c
 create mode 100644 include/asm-mips/mach-cavium-octeon/spi-octeon.h

diff --git a/arch/mips/cavium-octeon/spi-octeon.c b/arch/mips/cavium-octeon/spi-octeon.c
new file mode 100644
index 0000000..68b35b1
--- /dev/null
+++ b/arch/mips/cavium-octeon/spi-octeon.c
@@ -0,0 +1,293 @@
+/*
+ * Author: Vlad Malov <vlad.malov@caviumnetworks.com>
+ * Copyright (C) 2009 Cavium Networks, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <octeon-hal-read-write.h>
+
+#include "cvmx.h"
+#include "hal.h"
+#include "spi-octeon.h"
+
+#define OCT_SPI_MAX_CLOCK 16000000	/* 16Hz */
+#define OCT_SPI_MAX_DIVIDER 0x1fff	/* 13 bits */
+#define CVMX_DATX 9		/* 9 data regs */
+#define MAX_UDELAY 100000	/* by all means we must be done with a single
+				 * xfer within 100ms */
+/*  oct_spi_get_divider(uint32_t spi_clock)
+ * returns the round up divider value to generate the closest possible
+ * SPI clock not higher the requested value
+ * The requested value must be within min/max range, no checks done
+ */
+static uint32_t oct_spi_get_divider(uint32_t spi_clock)
+{
+	uint64_t clock = octeon_get_clock_rate();
+	uint32_t clkdiv;
+
+	/* get round-up divider value */
+	clkdiv = (clock + spi_clock - 1) / spi_clock;
+	/* and again round-up divide by 2 to get the value that can be actually
+	 * written to the reg */
+	clkdiv = (clkdiv + 1) / 2;
+
+	return clkdiv;
+}
+
+/*  oct_spi_get_max_speed(void)
+ *  oct_spi_get_min_speed(void)
+ * Report the speed range of the interface
+ * Speed is limited by the controller max speed 16Hz and value that can be
+ * actually written into the divider field of the contol reg.
+ * We report the actual speed we can configure based on the core clock.
+ */
+
+uint32_t oct_spi_get_max_speed(void)
+{
+	return octeon_get_clock_rate() / (2 *
+					  oct_spi_get_divider
+					  (OCT_SPI_MAX_CLOCK));
+}
+
+uint32_t oct_spi_get_min_speed(void)
+{
+	return octeon_get_clock_rate() / (2 * OCT_SPI_MAX_DIVIDER);
+}
+
+/* oct_spi_setup_interface() - enable GPIO pins. Not required usualy,
+ * pins are tri-stated if not enabled */
+
+void oct_spi_enable_interface(void)
+{
+	cvmx_mpi_cfg_t spi_cfg;
+
+	spi_cfg.u64 = 0;
+	spi_cfg.s.enable = 1;
+	cvmx_write_csr(CVMX_MPI_CFG, spi_cfg.u64);
+}
+
+/* oct_spi_disable_interface() - disable/tri-state GPIO pins */
+void oct_spi_disable_interface(void)
+{
+	cvmx_mpi_cfg_t spi_cfg;
+
+	spi_cfg.u64 = 0;
+	cvmx_write_csr(CVMX_MPI_CFG, spi_cfg.u64);
+}
+
+/*
+ * oct_spi_write_read()
+ * untangle bytes from Linux spi xfer, feed them to the controller,
+ * get what we have recieved back
+ */
+int oct_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)
+{
+	cvmx_mpi_cfg_t spi_cfg;
+	cvmx_mpi_datx_t spi_datx[CVMX_DATX];
+	cvmx_mpi_tx_t spi_tx;
+	cvmx_mpi_sts_t spi_sts;
+	int byte, bytes_per_word, word_size, words_per_step, bytes_per_xfer;
+	int word_count, word, word_in_buf;
+	const char *tx_buf = xfer->tx_buf;
+	char *rx_buf = xfer->rx_buf;
+	int delay_count;
+
+	/* set configuration reg */
+	spi_cfg.u64 = 0;
+	spi_cfg.s.clkdiv = oct_spi_get_divider(xfer->speed_hz);
+
+	if (((1 << spi->chip_select) & OCT_SPI_CS_MASK) != 0) {
+		/* CS active only for chip selects that match the mask, others
+		 * are tymed externally to the controller and must be
+		 * set/clear by the function caller */
+		spi_cfg.s.csena = 1;
+		spi_cfg.s.cshi = spi->mode & SPI_CS_HIGH ? 1 : 0;
+	}
+
+	spi_cfg.s.lsbfirst = spi->mode & SPI_LSB_FIRST ? 1 : 0;
+	spi_cfg.s.wireor = spi->mode & SPI_3WIRE ? 1 : 0;
+	spi_cfg.s.idlelo = spi->mode & SPI_CPOL ? 0 : 1;
+	spi_cfg.s.enable = 1;
+	cvmx_write_csr(CVMX_MPI_CFG, spi_cfg.u64);
+
+	/* prepare parametrs for main loop */
+	bytes_per_word = xfer->bits_per_word >> 3;	/* bits/8 */
+	if (bytes_per_word == 0) {
+		printk(KERN_INFO
+		       "ERROR: oct_spi_write_read call with bits_per_word "
+		       "%d <8\n", bytes_per_word);
+		return 0;
+	}
+
+	/* no split words ower buffer */
+	bytes_per_xfer = CVMX_DATX - (CVMX_DATX % bytes_per_word);
+
+	/* find the word size */
+	word_size = 1;
+	if (bytes_per_word == 1)
+		word_size = 1;
+	else if (bytes_per_word == 2)
+		word_size = 2;
+	else if (bytes_per_word <= 4)
+		word_size = 4;
+	else if (bytes_per_word <= 8)
+		word_size = 8;	/* we can support the larger tx_buffer word
+				 * size, but should we? */
+	/* xfer->len is not on-wire size, it is in-memory size! */
+	word_count = xfer->len / word_size;
+
+	words_per_step = CVMX_DATX / word_size;
+	/* The undefined bits are always MSB. That is: if bits_per_word = 24:
+	   data[0], data[1], data[2] will contain the valide bits in BE octeon.
+	   When SPI_LSB_FIRST is set we have to send them in data[2], data[1],
+	   data[0] order  */
+	/* main loop - fill/read the controller buffer each loop */
+	/* first copy bytes from tx_buff to spi_datx[] buffer */
+	/* then dump them to controller, do xfer, read all back to spi_datx[] */
+	/* last copy bytes from spi_datx[] to the rx_buff in expected way */
+	for (word = 0; word < word_count; word += words_per_step) {
+		/* Copy words to controller regs loop */
+		for (word_in_buf = 0; word_in_buf < words_per_step;
+		     word_in_buf++) {
+			if (word + word_in_buf >= word_count)
+				break;	/* check for odd ends */
+			if (tx_buf != NULL)
+				/* copy data to tmp buffer */
+				/* copy bytes in word loop */
+				for (byte = 0; byte < bytes_per_word; byte++)
+					if (!(spi->mode & SPI_LSB_FIRST))
+						spi_datx[(word_in_buf *
+							  bytes_per_word) +
+							 bytes_per_word -
+							 byte - 1].s.data =
+							(&(((char *)
+							    tx_buf)[(word +
+								word_in_buf) *
+								word_size]))
+							[byte];
+					else
+						spi_datx[(word_in_buf *
+							  bytes_per_word) +
+							 byte].s.data =
+							(&(((char *)
+							    tx_buf)[(word +
+								word_in_buf) *
+								word_size]))
+							[byte];
+			else
+				for (byte = 0; byte < bytes_per_word; byte++)
+					spi_datx[(word_in_buf *
+						  bytes_per_word) +
+						 byte].s.data = 0;
+		}
+
+		/* copy the data to controller */
+		for (byte = 0; byte < bytes_per_word * word_in_buf; byte++)
+			cvmx_write_csr(CVMX_MPI_DATX(byte), spi_datx[byte].u64);
+
+		/* set mpi_tx reg for the xfer */
+		spi_tx.u64 = 0;
+		if ((spi->mode & SPI_3WIRE) == 0) {
+			/* spi mode: totnum =  txnum = bytes to process */
+			spi_tx.s.txnum = bytes_per_word * word_in_buf;
+			spi_tx.s.totnum = bytes_per_word * word_in_buf;
+		} else {
+			/* 3-wire mode: totnum = bytes to process,
+			 * txnum = 0 : = totnum */
+			spi_tx.s.totnum = bytes_per_word * word_in_buf;
+			if (tx_buf == NULL)
+				spi_tx.s.txnum = 0;
+			else
+				spi_tx.s.txnum = bytes_per_word * word_in_buf;
+
+		}
+
+		/* if not the last byte - keep CS active */
+		/* Keepin' CS active after the last byte in xfer can be
+		 * requested - and is not up to as to guarantee the integrity,
+		 * e.i. next xfer goes to same device. Has no efect if not
+		 * xfer->csnum==0 */
+		if ((word + word_in_buf < word_count) || (xfer->cs_change == 0))
+			spi_tx.s.leavecs = 1;
+
+		/* start the xfer */
+		cvmx_write_csr(CVMX_MPI_TX, spi_tx.u64);
+
+		/* wait for completion */
+		/* for really slow bus and long transfers we may want a
+		 * context switching sleep here */
+		delay_count = MAX_UDELAY;	/* sanity loop count check */
+		do {
+			udelay(1);
+			spi_sts.u64 = cvmx_read_csr(CVMX_MPI_STS);
+		} while (spi_sts.s.busy && delay_count-- > 0);
+		/* get whatever we read to the user buff */
+		if (xfer->rx_buf != NULL) {
+			for (byte = 0; byte < bytes_per_word * word_in_buf;
+			     byte++)
+				spi_datx[byte].u64 =
+					cvmx_read_csr(CVMX_MPI_DATX(byte));
+
+			for (word_in_buf = 0; word_in_buf < words_per_step;
+			     word_in_buf++) {
+				if (word + word_in_buf >= word_count)
+					break;
+				for (byte = 0; byte < bytes_per_word; byte++)
+					if (!(spi->mode & SPI_LSB_FIRST))
+						(&(((char *)
+						   rx_buf)[(word +
+							    word_in_buf) *
+							   word_size]))[byte] =
+							spi_datx[(word_in_buf *
+							    bytes_per_word) +
+							    bytes_per_word -
+							    byte - 1].s.data;
+					else
+						(&(((char *)
+						   rx_buf)[(word +
+							    word_in_buf) *
+							   word_size]))[byte] =
+							spi_datx[(word_in_buf *
+							    bytes_per_word) +
+							    byte].s.data;
+			}
+		}
+		/* we likely never loop here, but we support long xfers loner
+		 * that 9 bytes if requested */
+	}
+	return bytes_per_word * word_count;
+}
+
+int oct_spy_get_num_interfaces(void)
+{
+	if (OCTEON_IS_MODEL(OCTEON_CN50XX))
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(oct_spi_get_max_speed);
+EXPORT_SYMBOL(oct_spi_get_min_speed);
+EXPORT_SYMBOL(oct_spi_enable_interface);
+EXPORT_SYMBOL(oct_spi_disable_interface);
+EXPORT_SYMBOL(oct_spi_write_read);
+EXPORT_SYMBOL(oct_spy_get_num_interfaces);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c04029a..bcba590 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -135,6 +135,12 @@ config SPI_MPC83xx
 	  technology. This driver uses a simple set of shift registers for data
 	  (opposed to the CPM based descriptor model).
 
+config SPI_OCTEON
+	tristate "Octeon CN5020 SPI controller"
+	depends on CPU_CAVIUM_OCTEON
+	help
+	  This is SPI controller for Octeon CN5020.
+
 config SPI_OMAP_UWIRE
 	tristate "OMAP1 MicroWire"
 	depends on ARCH_OMAP1
@@ -203,7 +209,6 @@ config SPI_XILINX
 
 	  See the "OPB Serial Peripheral Interface (SPI) (v1.00e)"
 	  Product Specification document (DS464) for hardware details.
-
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 1c2e7fc..237cd78 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -29,6 +29,9 @@ obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_OCTEON)		+= spi-oct.o 
+spi-oct-objs := spi_octeon.o ../../arch/mips/cavium-octeon/spi-octeon.o
+
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff --git a/drivers/spi/spi_octeon.c b/drivers/spi/spi_octeon.c
new file mode 100644
index 0000000..485becb
--- /dev/null
+++ b/drivers/spi/spi_octeon.c
@@ -0,0 +1,324 @@
+/*
+ * spi_octeon.c -- Cavium Networks SPI controller driver
+ *
+ * Author: Vlad Malov <vlad.malov@caviumnetworks.com>
+ * Copyright (C) 2009 Cavium Networks
+ * Copyright (C) 2007-2008 Marvell Ltd.
+
+ * This driver uses the framework of orion_spi.c driver.
+ * Author: Shadi Ammouri <shadi@marvell.com>
+ *
+ * Octeon HW code  moved to arch/mips/cavium-octeon directory
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <asm/unaligned.h>
+#include "spi-octeon.h"
+
+#define DRIVER_NAME	"octeon_spi"
+
+/* Octeon SPI controller has only 1 chip select. You may have implemented
+ * extra chip selects */
+#define OCT_NUM_ONCHIP_CHIPSELECTS	1
+
+/* change this definition if you have implemented extra SPI chip selects */
+#define OCT_NUM_CHIPSELECTS		OCT_NUM_ONCHIP_CHIPSELECTS
+
+/* Define these macros if you have implemented your own extra SPI chip
+ * selects. Chipselect 0 is handled by the Octeon SPI controller
+ */
+#define OCT_CHIPSELECT_SET(_xfer)
+#define OCT_CHIPSELECT_CLEAR(_xfer)
+
+/* private driver data */
+struct oct_spi {
+	struct work_struct work;
+
+	/* Lock access to transfer list.        */
+	spinlock_t lock;
+
+	struct list_head msg_queue;
+	struct spi_master *master;
+	unsigned int max_speed;
+	unsigned int min_speed;
+};
+
+static struct workqueue_struct *spi_wq;
+
+static void oct_spi_work(struct work_struct *work)
+{
+	struct oct_spi *oct_spi = container_of(work, struct oct_spi, work);
+
+	spin_lock_irq(&oct_spi->lock);
+	while (!list_empty(&oct_spi->msg_queue)) {
+		struct spi_message *msg;
+		struct spi_device *spi;
+		struct spi_transfer *xfer = NULL;
+		int status = 0;
+		int cs_active = 0;
+
+		msg =
+		    container_of(oct_spi->msg_queue.next, struct spi_message,
+				 queue);
+
+		list_del_init(&msg->queue);
+		spin_unlock_irq(&oct_spi->lock);
+
+		spi = msg->spi;
+
+		/* messages in the queue already verified. Simply send them
+		 * out */
+		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+			if (!cs_active) {
+				OCT_CHIPSELECT_SET(spi);
+				cs_active = 1;
+			}
+			if (xfer->len)
+				/* doing something usefull, finally */
+				msg->actual_length +=
+				    oct_spi_write_read(spi, xfer);
+
+			if (xfer->delay_usecs)
+				udelay(xfer->delay_usecs);
+
+			if (xfer->cs_change) {
+				OCT_CHIPSELECT_CLEAR(spi);
+				cs_active = 0;
+			}
+		}
+		if (cs_active)
+			OCT_CHIPSELECT_CLEAR(spi);
+
+		msg->status = status;
+		msg->complete(msg->context);
+		spin_lock_irq(&oct_spi->lock);
+	}
+	spin_unlock_irq(&oct_spi->lock);
+}
+
+/*
+ * only checks here
+ */
+static int oct_spi_setup(struct spi_device *spi)
+{
+	struct oct_spi *oct_spi;
+
+	oct_spi = spi_master_get_devdata(spi->master);
+
+	if ((spi->mode & (SPI_CPHA)) == 0) {
+		dev_err(&spi->dev, "setup: unsupported clock mode %x\n",
+			spi->mode & (SPI_CPHA | SPI_CPOL));
+		return -EINVAL;
+	}
+
+	if (spi->bits_per_word == 0)
+		spi->bits_per_word = 8;
+
+	if ((spi->bits_per_word & 0x7) != 0) {
+		dev_err(&spi->dev, "setup: unsupported bits per word %d\n",
+			spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	if ((spi->max_speed_hz == 0)
+	    || (spi->max_speed_hz > oct_spi->max_speed))
+		spi->max_speed_hz = oct_spi->max_speed;
+
+	if (spi->max_speed_hz < oct_spi->min_speed) {
+		dev_err(&spi->dev, "setup: requested speed too low %d Hz\n",
+			spi->max_speed_hz);
+		return -EINVAL;
+	}
+
+	/*
+	 * baudrate & width will be set oct_spi_setup_transfer
+	 */
+	return 0;
+}
+
+/* oct_spi_transfer()
+ * run checks, put message in the work queue.
+ */
+static int oct_spi_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct oct_spi *oct_spi;
+	struct spi_transfer *xfer = NULL;
+	unsigned long flags;
+
+	msg->actual_length = 0;
+	msg->status = 0;
+
+	/* reject invalid messages and transfers */
+	if (list_empty(&msg->transfers) || !msg->complete)
+		return -EINVAL;
+
+	oct_spi = spi_master_get_devdata(spi->master);
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (xfer->tx_buf == NULL && xfer->rx_buf == NULL && xfer->len) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"invalid transfer data buffers\n");
+			goto msg_rejected;
+		}
+
+		if (xfer->bits_per_word == 0)
+			xfer->bits_per_word = 8;
+
+		if ((xfer->bits_per_word & 0x7) != 0) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"invalid transfer bits_per_word (%d bits)\n",
+				xfer->bits_per_word);
+			goto msg_rejected;
+		}
+
+		if (xfer->len < xfer->bits_per_word >> 3) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"invalid transfer len %d bytes for word size: "
+				"bits_per_word (%d bits)\n",
+				xfer->len, xfer->bits_per_word);
+			goto msg_rejected;
+		}
+
+		if ((xfer->speed_hz == 0)
+		    || (spi->max_speed_hz > oct_spi->max_speed))
+			xfer->speed_hz = oct_spi->max_speed;
+
+		else if (xfer->speed_hz < oct_spi->min_speed) {
+			dev_err(&spi->dev,
+				"message rejected : "
+				"device min speed (%d Hz) exceeds "
+				"required transfer speed (%d Hz)\n",
+				oct_spi->min_speed, xfer->speed_hz);
+			goto msg_rejected;
+		}
+
+	}
+
+	spin_lock_irqsave(&oct_spi->lock, flags);
+	list_add_tail(&msg->queue, &oct_spi->msg_queue);
+	queue_work(spi_wq, &oct_spi->work);
+	spin_unlock_irqrestore(&oct_spi->lock, flags);
+	return 0;
+msg_rejected:
+	/* Message rejected and not queued */
+	msg->status = -EINVAL;
+	if (msg->complete)
+		msg->complete(msg->context);
+	return -EINVAL;
+}
+
+static int __init oct_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct oct_spi *spi;
+	int status = 0;
+
+	if (oct_spy_get_num_interfaces() == 0) {
+		dev_dbg(&pdev->dev,
+			"This chip does not have SPI controller, "
+			"needs bitbanging driver\n");
+		return -ENODEV;
+	}
+	master = spi_alloc_master(&pdev->dev, sizeof *spi);
+	if (master == NULL) {
+		dev_dbg(&pdev->dev, "master allocation failed\n");
+		return -ENOMEM;
+	}
+
+	if (pdev->id != -1)
+		master->bus_num = pdev->id;
+
+	master->setup = oct_spi_setup;
+	master->transfer = oct_spi_transfer;
+	master->num_chipselect = OCT_NUM_CHIPSELECTS;
+
+	dev_set_drvdata(&pdev->dev, master);
+
+	spi = spi_master_get_devdata(master);
+	spi->master = master;
+
+	spi->max_speed = oct_spi_get_max_speed();
+	spi->min_speed = oct_spi_get_min_speed();
+	INIT_WORK(&spi->work, oct_spi_work);
+
+	spin_lock_init(&spi->lock);
+	INIT_LIST_HEAD(&spi->msg_queue);
+
+	status = spi_register_master(master);
+	if (status < 0)
+		goto out;
+
+	return status;
+out:
+	spi_master_put(master);
+	return status;
+}
+
+static int __exit oct_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct oct_spi *spi;
+	master = dev_get_drvdata(&pdev->dev);
+	spi = spi_master_get_devdata(master);
+
+	cancel_work_sync(&spi->work);
+
+	spi_unregister_master(master);
+
+	return 0;
+}
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+static struct platform_driver oct_spi_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.remove = __exit_p(oct_spi_remove),
+};
+
+static int __init oct_spi_init(void)
+{
+	struct platform_device *pd;
+
+	spi_wq = create_singlethread_workqueue(oct_spi_driver.driver.name);
+	if (spi_wq == NULL)
+		return -ENOMEM;
+
+	pd = platform_device_alloc(DRIVER_NAME, -1);
+	if (!pd)
+		return -ENOMEM;
+
+	platform_device_add(pd);
+
+	return platform_driver_probe(&oct_spi_driver, oct_spi_probe);
+}
+
+module_init(oct_spi_init);
+
+static void __exit oct_spi_exit(void)
+{
+	flush_workqueue(spi_wq);
+	platform_driver_unregister(&oct_spi_driver);
+
+	destroy_workqueue(spi_wq);
+}
+
+module_exit(oct_spi_exit);
+
+MODULE_DESCRIPTION("Cavium Octeon SPI driver");
+MODULE_AUTHOR("Vlad Malov <vlad.malov@caviumnetworks.com>");
+MODULE_LICENSE("GPL");
diff --git a/include/asm-mips/mach-cavium-octeon/spi-octeon.h b/include/asm-mips/mach-cavium-octeon/spi-octeon.h
new file mode 100644
index 0000000..b12ba99
--- /dev/null
+++ b/include/asm-mips/mach-cavium-octeon/spi-octeon.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Cavium Networks <support@caviumnetworks.com>
+ */
+
+#ifndef _SPI_OCTEON_H_
+#define _SPI_OCTEON_H_
+
+/* As default we drive chip select pin when spi->chip_select is 0.
+ * if HW on your bord uses Octeon chip select signal to time other
+ * chip select signals, add these bits to OCT_SPI_CS_MASK */
+#define OCT_SPI_CS_MASK 0x1 	/* Chip select 0 is default to drive octeon
+				   MPI_CS pin */
+
+uint32_t oct_spi_get_max_speed(void);
+uint32_t oct_spi_get_min_speed(void);
+void oct_spi_enable_interface(void);
+void oct_spi_disable_interface(void);
+int oct_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer);
+int oct_spy_get_num_interfaces(void);
+
+#endif /* _SPI_OCTEON_H_ */
-- 
1.5.5.1

