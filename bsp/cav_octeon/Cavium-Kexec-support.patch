From 05a21d4fe5fd2c20293141f850bee541da49e94d Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Fri, 12 Nov 2010 16:11:16 +0800
Subject: [PATCH 050/132] Cavium: Kexec support

Source: Internal Development

 Most of it coming from work done for WR Linux 3.0.2:
 - Network interface reset
 - SMP CPU takedown
 - Cavium Physical memory cleanup upon reboot
 - USB shutdown

 Added:
 - add cvmx_bootmem_phy_available_mem() from 3.0.x since it was removed
   in 4.0.
 - mem= did not take multipliers into account, always assuming M: add
   support for K since kexec adds a mem=<crashkernel size>K to the
   boot line

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/setup.c       |    4 +-
 drivers/net/octeon/Makefile           |    1 +
 drivers/net/octeon/ethernet.c         |    9 +++
 drivers/net/octeon/octeon-kexec-net.c |  115 +++++++++++++++++++++++++++++++++
 drivers/staging/octeon/Makefile       |    1 -
 drivers/usb/host/octeon-hcd.c         |   40 ++++++++++--
 simple_exec/cvmx-bootmem.h            |    5 ++
 7 files changed, 166 insertions(+), 9 deletions(-)
 create mode 100644 drivers/net/octeon/octeon-kexec-net.c

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 487cc2a..7395a17 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -767,7 +767,6 @@ void __init prom_init(void)
 #ifdef CONFIG_CRASH_DUMP
 	octeon_write_lcd("CrashSMP");
 #else
-	octeon_write_lcd("LinuxSMP");
 #endif
 #else
 #ifdef CONFIG_CRASH_DUMP
@@ -1077,7 +1076,8 @@ void __init plat_mem_setup(void)
 	 * regions next to each other.
 	 */
 	cvmx_bootmem_lock();
-	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX) && (total < MAX_MEMORY)) {
+	while ((boot_mem_map.nr_map < BOOT_MEM_MAP_MAX) &&
+		(total < MAX_MEMORY)) {
 #if defined(CONFIG_64BIT) || defined(CONFIG_64BIT_PHYS_ADDR)
 		memory = cvmx_bootmem_phy_alloc(mem_alloc_size,
 						__pa_symbol(&__init_end), -1,
diff --git a/drivers/net/octeon/Makefile b/drivers/net/octeon/Makefile
index d3566db..8baa84d 100644
--- a/drivers/net/octeon/Makefile
+++ b/drivers/net/octeon/Makefile
@@ -14,6 +14,7 @@
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET)	+= octeon_mgmt.o
 
 obj-${CONFIG_OCTEON_ETHERNET} +=  octeon-ethernet.o
+obj-${CONFIG_KEXEC} +=  octeon-kexec-net.o
 
 octeon-ethernet-objs := ethernet.o
 octeon-ethernet-objs += ethernet-mdio.o
diff --git a/drivers/net/octeon/ethernet.c b/drivers/net/octeon/ethernet.c
index 95eec18..509f5e0 100644
--- a/drivers/net/octeon/ethernet.c
+++ b/drivers/net/octeon/ethernet.c
@@ -741,6 +741,9 @@ static void cvm_oct_override_pko_queue_priority(int pko_port, uint64_t prioritie
 	}
 }
 
+#ifdef CONFIG_KEXEC
+extern void octeon_shutdown_network_hw(void);
+#endif
 
 static int __init cvm_oct_init_module(void)
 {
@@ -749,6 +752,12 @@ static int __init cvm_oct_init_module(void)
 	int fau = FAU_NUM_PACKET_BUFFERS_TO_FREE;
 	int qos;
 
+#ifdef CONFIG_KEXEC
+printk(KERN_EMERG "reset_devices: %d\n", reset_devices);
+	if (reset_devices)
+		octeon_shutdown_network_hw();
+#endif
+
 	octeon_mdiobus_force_mod_depencency();
 	pr_notice("octeon-ethernet %s\n", OCTEON_ETHERNET_VERSION);
 
diff --git a/drivers/net/octeon/octeon-kexec-net.c b/drivers/net/octeon/octeon-kexec-net.c
new file mode 100644
index 0000000..b47d01c
--- /dev/null
+++ b/drivers/net/octeon/octeon-kexec-net.c
@@ -0,0 +1,115 @@
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/octeon-model.h>
+#include <asm/octeon/cvmx-agl-defs.h>
+#include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-mixx-defs.h>
+#include <linux/netdevice.h>
+#include "cvmx-helper.h"
+#include "cvmx-helper-util.h"
+#include "cvmx-config.h"
+#include "cvmx-fpa-defs.h"
+#include "cvmx-pip-defs.h"
+#include "cvmx-pko-defs.h"
+#include "cvmx-smix-defs.h"
+#include "cvmx-pow.h"
+
+void octeon_shutdown_network_hw(void)
+{
+	cvmx_helper_link_info_t link_info;
+	cvmx_wqe_t *work = NULL;
+	int ipd_port = 0;
+	int num_ints = 0;
+	int interface = 0;
+	int num_ports = 0;
+	int port = 0;
+	union cvmx_pko_reg_flags pko_reg_flags;
+	union cvmx_fpa_ctl_status fpa_status;
+	union cvmx_smix_en smix_en;
+	union cvmx_ipd_ctl_status ipd_ctl_status;
+	union cvmx_pip_sft_rst pip_sft_rst;
+
+	/* free up the work queue associated with this core */
+	work = cvmx_pow_get_current_wqp();
+	if (NULL != work) {
+		/* drain the work queue and free it */
+		cvmx_helper_free_packet_data(work);
+		cvmx_fpa_free(work, CVMX_FPA_WQE_POOL, 0);
+	}
+
+	/* halt the interfaces */
+	num_ints = cvmx_helper_get_number_of_interfaces();
+	if (num_ints > 2)
+		num_ints = 2;
+
+	/* Check to see what interface and ports we should use */
+	for (interface = 0; interface < num_ints; interface++) {
+		if ((CVMX_HELPER_INTERFACE_MODE_RGMII ==
+			cvmx_helper_interface_get_mode(interface)) ||
+			(CVMX_HELPER_INTERFACE_MODE_GMII ==
+				cvmx_helper_interface_get_mode(interface))) {
+			/* get the ports for this interface */
+			cvmx_helper_interface_probe(interface);
+			num_ports = cvmx_helper_ports_on_interface(interface);
+
+			for (port = 0; port < num_ports; port++) {
+				ipd_port = cvmx_helper_get_ipd_port(interface, port);
+
+				link_info = cvmx_helper_link_get(ipd_port);
+				link_info.s.link_up = 0;
+				cvmx_helper_link_set(ipd_port, link_info);
+			}
+		}
+	}
+
+	/* disable the SMI */
+	smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(0));
+	if (smix_en.s.en) {
+		smix_en.s.en = 0;
+		cvmx_write_csr(CVMX_SMIX_EN(0), smix_en.u64);
+	}
+
+	/* Newer chips actually have two SMI/MDIO interfaces */
+	if (!OCTEON_IS_MODEL(OCTEON_CN3XXX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN58XX) &&
+		!OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		smix_en.u64 = cvmx_read_csr(CVMX_SMIX_EN(1));
+		if (smix_en.s.en) {
+			smix_en.s.en = 0;
+			cvmx_write_csr(CVMX_SMIX_EN(1), smix_en.u64);
+		}
+	}
+
+	/* Reset the IPD to get all buffers out of it */
+	ipd_ctl_status.u64 = cvmx_read_csr(CVMX_IPD_CTL_STATUS);
+	ipd_ctl_status.s.reset = 1;
+	cvmx_write_csr(CVMX_IPD_CTL_STATUS, ipd_ctl_status.u64);
+
+	/* Reset the PIP */
+	pip_sft_rst.u64 = cvmx_read_csr(CVMX_PIP_SFT_RST);
+	pip_sft_rst.s.rst = 1;
+	cvmx_write_csr(CVMX_PIP_SFT_RST, pip_sft_rst.u64);
+
+	/* disable the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.ena_pko = 0;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* reset the PKO */
+	pko_reg_flags.u64 = cvmx_read_csr(CVMX_PKO_REG_FLAGS);
+	pko_reg_flags.s.reset = 1;
+	cvmx_write_csr(CVMX_PKO_REG_FLAGS, pko_reg_flags.u64);
+
+	/* disable the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.enb = 0;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* reset the FPA */
+	fpa_status.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);
+	fpa_status.s.reset = 1;
+	cvmx_write_csr(CVMX_FPA_CTL_STATUS, fpa_status.u64);
+
+	/* free the cvmx_cmd_queues from bootmemory */
+	cvmx_bootmem_free_named("cvmx_cmd_queues");
+}
+
diff --git a/drivers/staging/octeon/Makefile b/drivers/staging/octeon/Makefile
index 7a902e7..87447c1 100644
--- a/drivers/staging/octeon/Makefile
+++ b/drivers/staging/octeon/Makefile
@@ -26,4 +26,3 @@ octeon-ethernet-objs += cvmx-pko.o cvmx-spi.o cvmx-cmd-queue.o \
 	cvmx-helper-loop.o cvmx-helper-spi.o cvmx-helper-util.o \
 	cvmx-interrupt-decodes.o cvmx-interrupt-rsl.o
 
-obj-${CONFIG_KEXEC} +=  octeon-kexec-net.o
diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
index 27ed515..c493549 100644
--- a/drivers/usb/host/octeon-hcd.c
+++ b/drivers/usb/host/octeon-hcd.c
@@ -672,6 +672,35 @@ static struct device_driver octeon_usb_driver = {
 #define MAX_USB_PORTS   10
 struct platform_device *pdev_glob[MAX_USB_PORTS];
 static int octeon_usb_registered;
+
+static void __shutdown_usb_ports(void)
+{
+	/* shutdown all USB ports */
+	int i = 0;
+	for (i = 0; i < MAX_USB_PORTS; i++) {
+		if (pdev_glob[i]) {
+			platform_device_unregister(pdev_glob[i]);
+			pdev_glob[i] = NULL;
+		}
+	}
+}
+
+#ifdef CONFIG_KEXEC
+void kexec_octeon_register_shutdown_usb_ports(void(*fn)(void));
+void kexec_octeon_unregister_shutdown_usb_ports(void);
+static void __register_for_kexec_shutdown(void)
+{
+	kexec_octeon_register_shutdown_usb_ports(__shutdown_usb_ports);
+}
+static void __unregister_for_kexec_shutdown(void)
+{
+	kexec_octeon_unregister_shutdown_usb_ports();
+}
+#else
+static void __register_for_kexec_shutdown(void) { /* do nothing */ }
+static void __unregister_for_kexec_shutdown(void) { /* do nothing */ }
+#endif
+
 static int __init octeon_usb_module_init(void)
 {
 	int num_devices = cvmx_usb_get_num_ports();
@@ -684,6 +713,9 @@ static int __init octeon_usb_module_init(void)
 		DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
 		return -ENOMEM;
 	}
+
+	__register_for_kexec_shutdown();
+
 	octeon_usb_registered = 1;
 	printk(KERN_INFO "OcteonUSB: Detected %d ports\n", num_devices);
 	for (device = 0; device < num_devices; device++) {
@@ -707,13 +739,9 @@ static int __init octeon_usb_module_init(void)
 
 static void __exit octeon_usb_module_cleanup(void)
 {
-	int i;
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
-	for (i = 0; i < MAX_USB_PORTS; i++)
-		if (pdev_glob[i]) {
-			platform_device_unregister(pdev_glob[i]);
-			pdev_glob[i] = NULL;
-		}
+	__unregister_for_kexec_shutdown();
+	__shutdown_usb_ports();
 	if (octeon_usb_registered)
 		driver_unregister(&octeon_usb_driver);
 }
diff --git a/simple_exec/cvmx-bootmem.h b/simple_exec/cvmx-bootmem.h
index 2f07990..0e9a02f 100644
--- a/simple_exec/cvmx-bootmem.h
+++ b/simple_exec/cvmx-bootmem.h
@@ -421,6 +421,11 @@ void cvmx_bootmem_lock(void);
 void cvmx_bootmem_unlock(void);
 
 /**
+ * Queries the available physical memory from the bootmem allocator
+ */
+uint64_t cvmx_bootmem_phy_available_mem(uint64_t min_block_size);
+
+/**
  * Internal use function to get the current descriptor pointer */
 void *__cvmx_bootmem_internal_get_desc_ptr(void);
 
-- 
1.6.5.2

