From 0fd3154c2fa165d9ae92bcd67d5e7bf98b5576fd Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Mon, 15 Nov 2010 17:02:16 +0800
Subject: [PATCH 123/132] Delete arch/mips/cavium-octeon/userio.c

The original implementation is integrated into
arch/mips/cavium-octeon/setup.c, so remove the duplidated file.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/userio.c |  129 --------------------------------------
 1 files changed, 0 insertions(+), 129 deletions(-)
 delete mode 100644 arch/mips/cavium-octeon/userio.c

diff --git a/arch/mips/cavium-octeon/userio.c b/arch/mips/cavium-octeon/userio.c
deleted file mode 100644
index aa7f6ee..0000000
--- a/arch/mips/cavium-octeon/userio.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2004-2007 Cavium Networks
- */
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/serial.h>
-#include <linux/types.h>
-#include <linux/string.h>	/* for memset */
-#include <linux/console.h>
-#include <linux/serial.h>
-#include <linux/tty.h>
-#include <linux/time.h>
-#include <linux/serial_core.h>
-#include <linux/reboot.h>
-#include <linux/io.h>
-
-#include <asm/processor.h>
-#include <asm/system.h>
-#include <asm/irq_cpu.h>
-#include <asm/mipsregs.h>
-#include <asm/bootinfo.h>
-#include <asm/octeon/octeon.h>
-
-#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS) || \
-	defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
-
-void cavium_prepare_arch_switch(struct task_struct *next)
-{
-	struct task_struct *group_leader = next->group_leader;
-	union octeon_cvmemctl cvmmemctl;
-	cvmmemctl.u64 = read_c0_cvmmemctl();
-
-#if defined(CONFIG_CAVIUM_OCTEON_USER_MEM_PER_PROCESS)
-	cvmmemctl.s.xkmemenau = test_tsk_thread_flag(group_leader,
-						     TIF_XKPHYS_MEM_EN) ? 1 : 0;
-#endif
-
-#if defined(CONFIG_CAVIUM_OCTEON_USER_IO_PER_PROCESS)
-	cvmmemctl.s.xkioenau = test_tsk_thread_flag(group_leader,
-						    TIF_XKPHYS_IO_EN) ? 1 : 0;
-#endif
-	write_c0_cvmmemctl(cvmmemctl.u64);
-}
-
-static struct task_struct *xkphys_get_task(pid_t pid)
-{
-	struct task_struct *task, *group_leader;
-
-	read_lock(&tasklist_lock);
-	task = find_task_by_vpid(pid);
-	if (!task) {
-		read_unlock(&tasklist_lock);
-		return NULL;
-	}
-	group_leader = task->group_leader;
-	get_task_struct(group_leader);
-
-	read_unlock(&tasklist_lock);
-	return group_leader;
-}
-
-int xkphys_usermem_read(long pid)
-{
-	struct task_struct *task;
-	int io, mem;
-
-	task = xkphys_get_task(pid);
-	if (!task)
-		return -ESRCH;
-	io = test_tsk_thread_flag(task, TIF_XKPHYS_IO_EN);
-	mem = test_tsk_thread_flag(task, TIF_XKPHYS_MEM_EN);
-	put_task_struct(task);
-	return (io ? 2 : 0) | (mem ? 1 : 0);
-}
-
-int xkphys_usermem_write(long pid, int value)
-{
-	struct task_struct *task, *group_leader;
-	const struct cred *tcred;
-
-	uid_t euid = current_euid();
-
-	task = xkphys_get_task(pid);
-	group_leader = task->group_leader;
-
-	if (!task)
-		return -ESRCH;
-
-	rcu_read_lock();
-	tcred = __task_cred(task);
-
-	if (tcred->uid != euid &&
-	    tcred->euid != euid &&
-	    !(capable(CAP_SYS_RAWIO) || value == 0)) {
-		put_task_struct(task);
-		rcu_read_unlock();
-		return -EPERM;
-	}
-	rcu_read_unlock();
-
-	if (value & 1)
-		set_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
-	else
-		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_MEM_EN);
-
-	if (value & 2)
-		set_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
-	else
-		clear_tsk_thread_flag(group_leader, TIF_XKPHYS_IO_EN);
-
-	preempt_disable();
-
-	/* If we are adjusting ourselves, make the change effective
-	   immediatly.  */
-	if (group_leader == current->group_leader)
-		cavium_prepare_arch_switch(current);
-
-	preempt_enable();
-
-	put_task_struct(task);
-	return 0;
-}
-#endif
-- 
1.6.5.2

