From 2a18d9c47802596fdbbecbd229e59d5dd587d51d Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Thu, 11 Nov 2010 17:16:34 +0800
Subject: [PATCH 024/132] Cavium: Update clock code to support Octeon II

Source: SDK 2.0.0-366

Add PTP clock source.

Octeon II power throttling makes deterministic delay loops
impossible. Re-implement delays using the cycle counter. This also
allows us to get rid of the code that calculates loops per jiffy.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/csrc-octeon-ptp.c |   76 ++++++++++++++++++
 arch/mips/cavium-octeon/csrc-octeon.c     |  122 ++++++++++++++++++++++++++++-
 arch/mips/cavium-octeon/setup.c           |   18 ++++-
 arch/mips/include/asm/octeon/octeon.h     |    3 +
 4 files changed, 213 insertions(+), 6 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/csrc-octeon-ptp.c

diff --git a/arch/mips/cavium-octeon/csrc-octeon-ptp.c b/arch/mips/cavium-octeon/csrc-octeon-ptp.c
new file mode 100644
index 0000000..c033b31
--- /dev/null
+++ b/arch/mips/cavium-octeon/csrc-octeon-ptp.c
@@ -0,0 +1,76 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009, 2010 Cavium Networks
+ */
+#include <linux/clocksource.h>
+#include <linux/init.h>
+#include <asm/time.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-mio-defs.h>
+
+static cycle_t octeon_ptp_clock_read(struct clocksource *cs)
+{
+	/* CN63XX pass 1.x has an errata where you must read this register
+		twice to get the correct result */
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))
+		cvmx_read_csr(CVMX_MIO_PTP_CLOCK_HI);
+	return cvmx_read_csr(CVMX_MIO_PTP_CLOCK_HI);
+}
+
+static struct clocksource clocksource_ptp_clock = {
+	.name		= "OCTEON_PTP_CLOCK",
+	.read		= octeon_ptp_clock_read,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+int __init ptp_clock_init(void)
+{
+	union cvmx_mio_ptp_clock_cfg ptp_clock_cfg;
+
+	/* Chips prior to CN6XXX don't support the PTP clock source */
+	if (!OCTEON_IS_MODEL(OCTEON_CN6XXX))
+		return 0;
+
+	/* FIXME: Remove this when PTP is implemented in the simulator */
+	if (octeon_is_simulation())
+		return 0;
+
+	/* Get the current state of the PTP clock */
+	ptp_clock_cfg.u64 = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_CFG);
+	if (!ptp_clock_cfg.s.ext_clk_en) {
+		/*
+		 * The clock has not been configured to use an
+		 * external source.  Program it to use the main clock
+		 * reference.
+		 */
+		unsigned long long clock_comp = (NSEC_PER_SEC << 32) / octeon_get_io_clock_rate();
+		cvmx_write_csr(CVMX_MIO_PTP_CLOCK_COMP, clock_comp);
+		pr_info("PTP Clock: Using sclk reference at %lld Hz\n",
+			(NSEC_PER_SEC << 32) / clock_comp);
+	} else {
+		/* The clock is already programmed to use an external GPIO */
+		unsigned long long clock_comp = cvmx_read_csr(CVMX_MIO_PTP_CLOCK_COMP);
+		pr_info("PTP Clock: Using GPIO %d at %lld Hz\n",
+			ptp_clock_cfg.s.ext_clk_in,
+			(NSEC_PER_SEC << 32) / clock_comp);
+	}
+
+	/* Enable the clock if it wasn't done already */
+	if (!ptp_clock_cfg.s.ptp_en) {
+		ptp_clock_cfg.s.ptp_en = 1;
+		cvmx_write_csr(CVMX_MIO_PTP_CLOCK_CFG, ptp_clock_cfg.u64);
+	}
+
+	/* Add PTP as a high quality clocksource with nano second granularity */
+	clocksource_ptp_clock.rating = 400;
+	clocksource_set_clock(&clocksource_ptp_clock, NSEC_PER_SEC);
+	clocksource_register(&clocksource_ptp_clock);
+	return 0;
+}
+
+arch_initcall(ptp_clock_init);
diff --git a/arch/mips/cavium-octeon/csrc-octeon.c b/arch/mips/cavium-octeon/csrc-octeon.c
index 0bf4bbe..6d9973e 100644
--- a/arch/mips/cavium-octeon/csrc-octeon.c
+++ b/arch/mips/cavium-octeon/csrc-octeon.c
@@ -4,14 +4,45 @@
  * for more details.
  *
  * Copyright (C) 2007 by Ralf Baechle
+ * Copyright (C) 2009, 2010 Cavium Networks, Inc.
  */
 #include <linux/clocksource.h>
 #include <linux/init.h>
+#include <linux/smp.h>
 
+#include <asm/cpu-info.h>
 #include <asm/time.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-ipd-defs.h>
+#include <asm/octeon/cvmx-mio-defs.h>
+
+
+static u64 f;
+static u64 rdiv;
+static u64 sdiv;
+static u64 octeon_udelay_factor;
+static u64 octeon_ndelay_factor;
+
+void __init octeon_setup_delays(void)
+{
+	octeon_udelay_factor = octeon_get_clock_rate() / 1000000;
+	/*
+	 * For __ndelay we divide by 2^16, so the factor is multiplied
+	 * by the same amount.
+	 */
+	octeon_ndelay_factor = (octeon_udelay_factor * 0x10000ull) / 1000ull;
+
+	preset_lpj = octeon_get_clock_rate() / HZ;
+
+	if (current_cpu_type() == CPU_CAVIUM_OCTEON2) {
+		union cvmx_mio_rst_boot rst_boot;
+		rst_boot.u64 = cvmx_read_csr(CVMX_MIO_RST_BOOT);
+		rdiv = rst_boot.s.c_mul;	/* CPU clock */
+		sdiv = rst_boot.s.pnr_mul;	/* I/O clock */
+		f = (0x8000000000000000ull / sdiv) * 2;
+	}
+}
 
 /*
  * Set the current core's cvmcount counter to the value of the
@@ -19,6 +50,7 @@
  * on-line.  This allows for a read from a local cpu register to
  * access a synchronized counter.
  *
+ * On CPU_CAVIUM_OCTEON2 the IPD_CLK_COUNT is scaled by rdiv/sdiv.
  */
 void octeon_init_cvmcount(void)
 {
@@ -33,8 +65,20 @@ void octeon_init_cvmcount(void)
 	 * Loop several times so we are executing from the cache,
 	 * which should give more deterministic timing.
 	 */
-	while (loops--)
-		write_c0_cvmcount(cvmx_read_csr(CVMX_IPD_CLK_COUNT));
+	while (loops--) {
+		u64 ipd_clk_count = cvmx_read_csr(CVMX_IPD_CLK_COUNT);
+		if (rdiv != 0) {
+			ipd_clk_count = ipd_clk_count * rdiv;
+			if (f != 0) {
+				asm("dmultu\t%[cnt],%[f]\n\t"
+				    "mfhi\t%[cnt]"
+				    : [cnt] "+r" (ipd_clk_count)
+				    :  [f] "r" (f)
+				    :  "hi", "lo");
+			}
+		}
+		write_c0_cvmcount(ipd_clk_count);
+	}
 	local_irq_restore(flags);
 }
 
@@ -85,6 +129,78 @@ unsigned long long notrace sched_clock(void)
 void __init plat_time_init(void)
 {
 	clocksource_mips.rating = 300;
-	clocksource_set_clock(&clocksource_mips, mips_hpt_frequency);
+	clocksource_set_clock(&clocksource_mips, octeon_get_clock_rate());
 	clocksource_register(&clocksource_mips);
 }
+
+void __udelay(unsigned int us)
+{
+	u64 cur, end, inc;
+
+	cur = read_c0_cvmcount();
+
+	inc = us * octeon_udelay_factor;
+	end = cur + inc;
+
+	while (end > cur)
+		cur = read_c0_cvmcount();
+}
+EXPORT_SYMBOL(__udelay);
+
+void __ndelay(unsigned int ns)
+{
+	u64 cur, end, inc;
+
+	cur = read_c0_cvmcount();
+
+	inc = ((ns * octeon_ndelay_factor) >> 16);
+	end = cur + inc;
+
+	while (end > cur)
+		cur = read_c0_cvmcount();
+}
+EXPORT_SYMBOL(__ndelay);
+
+void __delay(unsigned int loops)
+{
+	u64 cur, end;
+
+	cur = read_c0_cvmcount();
+	end = cur + loops;
+
+	while (end > cur)
+		cur = read_c0_cvmcount();
+}
+EXPORT_SYMBOL(__delay);
+
+
+/**
+ * octeon_io_clk_delay - wait for a given number of io clock cycles to pass.
+ *
+ * We scale the wait by the clock ratio, and then wait for the
+ * corresponding number of core clocks.
+ *
+ * @count: The number of clocks to wait.
+ */
+void octeon_io_clk_delay(unsigned long count)
+{
+	u64 cur, end;
+
+	cur = read_c0_cvmcount();
+	if (rdiv != 0) {
+		end = count * rdiv;
+		if (f != 0) {
+			asm("dmultu\t%[cnt],%[f]\n\t"
+				"mfhi\t%[cnt]"
+				: [cnt] "+r" (end)
+				: [f] "r" (f)
+				: "hi", "lo");
+		}
+		end = cur + end;
+	} else {
+		end = cur + count;
+	}
+	while (end > cur)
+		cur = read_c0_cvmcount();
+}
+EXPORT_SYMBOL(octeon_io_clk_delay);
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 8fce39b..44dfa0b 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -32,6 +32,7 @@
 #include <asm/time.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-clock.h>
 
 #ifdef CONFIG_KEXEC
 #include <linux/kexec.h>
@@ -137,12 +138,23 @@ int octeon_is_pci_host(void)
  */
 uint64_t octeon_get_clock_rate(void)
 {
-	if (octeon_is_simulation())
-		octeon_bootinfo->eclock_hz = 6000000;
-	return octeon_bootinfo->eclock_hz;
+	struct cvmx_sysinfo *sysinfo = cvmx_sysinfo_get();
+
+	return sysinfo->cpu_clock_hz;
 }
 EXPORT_SYMBOL(octeon_get_clock_rate);
 
+/*
+ * Get the IO clock rate of Octeon2
+ *
+ * Returns IO Clock rate in HZ
+ */
+uint64_t octeon_get_io_clock_rate(void)
+{
+       return cvmx_clock_get_rate(CVMX_CLOCK_SCLK);
+}
+EXPORT_SYMBOL(octeon_get_io_clock_rate);
+
 /**
  * Write to the LCD display connected to the bootbus. This display
  * exists on most Cavium evaluation boards. If it doesn't exist, then
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index ca6214b..188c2b3 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -35,6 +35,7 @@ extern int octeon_is_simulation(void);
 extern int octeon_is_pci_host(void);
 extern int octeon_usb_is_ref_clk(void);
 extern uint64_t octeon_get_clock_rate(void);
+extern uint64_t octeon_get_io_clock_rate(void);
 extern const char *octeon_board_type_string(void);
 extern const char *octeon_get_pci_interrupts(void);
 extern int octeon_get_southbridge_interrupt(void);
@@ -50,6 +51,8 @@ extern void octeon_crypto_disable(struct octeon_cop2_state *state,
 extern asmlinkage void octeon_cop2_restore(struct octeon_cop2_state *task);
 
 extern void octeon_init_cvmcount(void);
+extern void octeon_setup_delays(void);
+extern void octeon_io_clk_delay(unsigned long);
 
 #define OCTEON_ARGV_MAX_ARGS	64
 #define OCTOEN_SERIAL_LEN	20
-- 
1.6.5.2

