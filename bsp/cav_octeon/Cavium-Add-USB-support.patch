From 7e9fb795815002cb2747da9f9369cc107f635bec Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Fri, 12 Nov 2010 11:13:23 +0800
Subject: [PATCH 032/132] Cavium: Add USB support

Source: SDK 2.0.0-366

Add USB support, including hcd glue for ohci and ehci drivers, common
code, config fragment and Makefile updates.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/cavium-octeon/octeon-platform.c |  102 ++++
 drivers/usb/host/Kconfig                  |   37 ++-
 drivers/usb/host/Makefile                 |    2 +
 drivers/usb/host/ehci-hcd.c               |    5 +
 drivers/usb/host/ehci-octeon.c            |  193 ++++++++
 drivers/usb/host/octeon-hcd.c             |  725 +++++++++++++++++++++++++++++
 drivers/usb/host/octeon2-common.c         |  166 +++++++
 drivers/usb/host/ohci-hcd.c               |    5 +
 drivers/usb/host/ohci-octeon.c            |  204 ++++++++
 9 files changed, 1438 insertions(+), 1 deletions(-)
 create mode 100644 drivers/usb/host/ehci-octeon.c
 create mode 100644 drivers/usb/host/octeon-hcd.c
 create mode 100644 drivers/usb/host/octeon2-common.c
 create mode 100644 drivers/usb/host/ohci-octeon.c

diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index b35ded3..79881e0 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -364,6 +364,108 @@ out:
 }
 device_initcall(octeon_mgmt_device_init);
 
+#ifdef CONFIG_USB
+
+static int __init octeon_ehci_device_init(void)
+{
+	struct platform_device *pd;
+	int ret = 0;
+
+	struct resource usb_resources[] = {
+		{
+			.flags	= IORESOURCE_MEM,
+		}, {
+			.flags	= IORESOURCE_IRQ,
+		}
+	};
+
+	/* Only Octeon2 has ehci/ohci */
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 0;
+
+	if (octeon_is_simulation() || usb_disabled())
+		return 0; /* No USB in the simulator. */
+
+	pd = platform_device_alloc("octeon-ehci", 0);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usb_resources[0].start = XKPHYS_TO_PHYS(CVMX_UAHCX_EHCI_HCCAPBASE(0));
+	usb_resources[0].end = usb_resources[0].start + 0x100;
+
+	usb_resources[1].start = OCTEON_IRQ_USB0;
+	usb_resources[1].end = OCTEON_IRQ_USB0;
+
+	ret = platform_device_add_resources(pd, usb_resources,
+					    ARRAY_SIZE(usb_resources));
+	if (ret)
+		goto fail;
+
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+
+	return ret;
+fail:
+	platform_device_put(pd);
+out:
+	return ret;
+}
+device_initcall(octeon_ehci_device_init);
+
+static int __init octeon_ohci_device_init(void)
+{
+	struct platform_device *pd;
+	int ret = 0;
+
+	struct resource usb_resources[] = {
+		{
+			.flags	= IORESOURCE_MEM,
+		}, {
+			.flags	= IORESOURCE_IRQ,
+		}
+	};
+
+	/* Only Octeon2 has ehci/ohci */
+	if (!OCTEON_IS_MODEL(OCTEON_CN63XX))
+		return 0;
+
+	if (octeon_is_simulation() || usb_disabled())
+		return 0; /* No USB in the simulator. */
+
+	pd = platform_device_alloc("octeon-ohci", 0);
+	if (!pd) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usb_resources[0].start = XKPHYS_TO_PHYS(CVMX_UAHCX_OHCI0_HCREVISION(0));
+	usb_resources[0].end = usb_resources[0].start + 0x100;
+
+	usb_resources[1].start = OCTEON_IRQ_USB0;
+	usb_resources[1].end = OCTEON_IRQ_USB0;
+
+	ret = platform_device_add_resources(pd, usb_resources,
+					    ARRAY_SIZE(usb_resources));
+	if (ret)
+		goto fail;
+
+	ret = platform_device_add(pd);
+	if (ret)
+		goto fail;
+
+	return ret;
+fail:
+	platform_device_put(pd);
+out:
+	return ret;
+}
+device_initcall(octeon_ohci_device_init);
+
+#endif /* CONFIG_USB */
+
 MODULE_AUTHOR("David Daney <ddaney@caviumnetworks.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Platform driver for Octeon SOC");
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 6af8bee..ea6dfb1 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -90,7 +90,7 @@ config USB_EHCI_TT_NEWSCHED
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || NLM_XLP)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX || XPS_USB_HCD_XILINX || NLM_XLP || CPU_CAVIUM_OCTEON)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
@@ -408,6 +408,41 @@ config USB_HWA_HCD
 	  To compile this driver a module, choose M here: the module
 	  will be called "hwa-hc".
 
+
+config USB_OCTEON_HCD
+	tristate "Octeon usb host driver"
+	depends on USB && CPU_CAVIUM_OCTEON && !CAVIUM_OCTEON_2ND_KERNEL
+	default n
+	help
+          The Octeon DWC_OTG USB host controller.  All CN3XXX and
+          CN5XXX based chips with USB are supported.
+
+config USB_OCTEON_EHCI
+	bool "Octeon on-chip EHCI support"
+	depends on USB && USB_EHCI_HCD && CPU_CAVIUM_OCTEON && !CAVIUM_OCTEON_2ND_KERNEL
+	default n
+	select USB_EHCI_BIG_ENDIAN_MMIO
+	help
+	  Enable support for the Octeon II SOC's on-chip EHCI
+	  controller.  It is needed for high-speed (480Mbit/sec)
+	  USB 2.0 device support.  All CN6XXX based chips with USB are
+	  supported.
+
+config USB_OCTEON_OHCI
+	bool "Octeon on-chip OHCI support"
+	depends on USB && USB_OHCI_HCD && CPU_CAVIUM_OCTEON && !CAVIUM_OCTEON_2ND_KERNEL
+	default USB_OCTEON_EHCI
+	select USB_OHCI_BIG_ENDIAN_MMIO
+	select USB_OHCI_LITTLE_ENDIAN
+	help
+	  Enable support for the Octeon II SOC's on-chip OHCI
+	  controller.  It is needed for low-speed USB 1.0 device
+	  support.  All CN6XXX based chips with USB are supported.
+
+config USB_OCTEON2_COMMON
+	bool
+	default y if USB_OCTEON_EHCI || USB_OCTEON_OHCI
+
 config USB_IMX21_HCD
        tristate "iMX21 HCD support"
        depends on USB && ARM && MACH_MX21
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index db64276..71f2153 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -35,5 +35,7 @@ obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
 obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
+obj-$(CONFIG_USB_OCTEON_HCD)	+= octeon-hcd.o
+obj-$(CONFIG_USB_OCTEON2_COMMON)	+= octeon2-common.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 97af916..093a0fa 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1177,6 +1177,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		cns3xxx_ehci_driver
 #endif
 
+#ifdef CONFIG_USB_OCTEON_EHCI
+#include "ehci-octeon.c"
+#define PLATFORM_DRIVER		ehci_octeon_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
diff --git a/drivers/usb/host/ehci-octeon.c b/drivers/usb/host/ehci-octeon.c
new file mode 100644
index 0000000..c48f8e3
--- /dev/null
+++ b/drivers/usb/host/ehci-octeon.c
@@ -0,0 +1,193 @@
+/*
+ * EHCI HCD glue for Cavium Octeon II SOCs.
+ *
+ * Loosely based on ehci-au1xxx.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Cavium Networks
+ *
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-uctlx-defs.h>
+
+#define OCTEON_EHCI_HCD_NAME "octeon-ehci"
+
+/* Common clock init code.  */
+void octeon2_usb_clocks_start(void);
+void octeon2_usb_clocks_stop(void);
+
+static void ehci_octeon_start(void)
+{
+	union cvmx_uctlx_ehci_ctl ehci_ctl;
+
+	octeon2_usb_clocks_start();
+
+	ehci_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_EHCI_CTL(0));
+	/* Use 64-bit addressing. */
+	ehci_ctl.s.ehci_64b_addr_en = 1;
+	ehci_ctl.s.l2c_addr_msb = 0;
+	ehci_ctl.s.l2c_buff_emod = 1; /* Byte swapped. */
+	ehci_ctl.s.l2c_desc_emod = 1; /* Byte swapped. */
+	cvmx_write_csr(CVMX_UCTLX_EHCI_CTL(0), ehci_ctl.u64);
+}
+
+static void ehci_octeon_stop(void)
+{
+	octeon2_usb_clocks_stop();
+}
+
+static const struct hc_driver ehci_octeon_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Octeon EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+
+	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
+};
+
+static int ehci_octeon_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	struct resource *res_mem;
+	int irq;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No irq assigned\n");
+		return -ENODEV;
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(&pdev->dev, "No register space assigned\n");
+		return -ENODEV;
+	}
+
+	/* We can DMA from anywhere. */
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(64);
+	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+
+	hcd = usb_create_hcd(&ehci_octeon_hc_driver, &pdev->dev, "octeon");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res_mem->start;
+	hcd->rsrc_len = res_mem->end - res_mem->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, OCTEON_EHCI_HCD_NAME)) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	ehci_octeon_start();
+
+	ehci = hcd_to_ehci(hcd);
+
+	/* Octeon EHCI matches CPU endianness. */
+#ifdef __BIG_ENDIAN
+	ehci->big_endian_mmio = 1;
+#endif
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
+
+	ehci_octeon_stop();
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static int ehci_octeon_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+
+	ehci_octeon_stop();
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver ehci_octeon_driver = {
+	.probe		= ehci_octeon_drv_probe,
+	.remove		= ehci_octeon_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name	= OCTEON_EHCI_HCD_NAME,
+		.owner	= THIS_MODULE,
+	}
+};
+
+MODULE_ALIAS("platform:" OCTEON_EHCI_HCD_NAME);
diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
new file mode 100644
index 0000000..27ed515
--- /dev/null
+++ b/drivers/usb/host/octeon-hcd.c
@@ -0,0 +1,725 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include "../../../drivers/usb/core/hcd.h"
+#include <asm/octeon/cvmx-usb.h>
+
+/*#define DEBUG_CALL(format, ...)         printk(format, ##__VA_ARGS__) */
+#define DEBUG_CALL(format, ...)         do {} while (0)
+/*#define DEBUG_SUBMIT(format, ...)       printk(format, ##__VA_ARGS__) */
+#define DEBUG_SUBMIT(format, ...)       do {} while (0)
+/*#define DEBUG_ROOT_HUB(format, ...)     printk(format, ##__VA_ARGS__) */
+#define DEBUG_ROOT_HUB(format, ...)     do {} while (0)
+/*#define DEBUG_ERROR(format, ...)        printk(format, ##__VA_ARGS__) */
+#define DEBUG_ERROR(format, ...)        do {} while (0)
+#define DEBUG_FATAL(format, ...)        printk(format, ##__VA_ARGS__)
+
+typedef struct {
+	spinlock_t lock;
+	cvmx_usb_state_t usb;
+} octeon_usb_priv_t;
+
+static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
+				     cvmx_usb_callback_t reason,
+				     cvmx_usb_complete_t status,
+				     int pipe_handle,
+				     int submit_handle,
+				     int bytes_transferred,
+				     void *user_data)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)((void*)usb - offsetof(octeon_usb_priv_t, usb));
+	struct usb_hcd *hcd = ((void *)priv - offsetof(struct usb_hcd, hcd_priv));
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_unlock(&priv->lock);
+	usb_hcd_poll_rh_status(hcd);
+	spin_lock(&priv->lock);
+}
+
+static int octeon_usb_start(struct usb_hcd *hcd)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	hcd->state = HC_STATE_RUNNING;
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   octeon_usb_port_callback, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static void octeon_usb_stop(struct usb_hcd *hcd)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	unsigned long flags;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_register_callback(&priv->usb, CVMX_USB_CALLBACK_PORT_CHANGED,
+				   NULL, NULL);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	hcd->state = HC_STATE_HALT;
+}
+
+static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	return cvmx_usb_get_frame_number(&priv->usb);
+}
+
+static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
+					     cvmx_usb_callback_t reason,
+					     cvmx_usb_complete_t status,
+					     int pipe_handle,
+					     int submit_handle,
+					     int bytes_transferred,
+					     void *user_data)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)((void*)usb - offsetof(octeon_usb_priv_t, usb));
+	struct usb_hcd *hcd = ((void *)priv - offsetof(struct usb_hcd, hcd_priv));
+	struct urb *urb = user_data;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	urb->actual_length = bytes_transferred;
+	urb->hcpriv = NULL;
+
+	/* For Isochronous transactions we need to update the URB packet status
+	   list from data in our private copy */
+	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
+		int i;
+		/* The pointer to the private list is stored in the setup_packet field */
+		cvmx_usb_iso_packet_t *iso_packet = (cvmx_usb_iso_packet_t *)urb->setup_packet;
+		/* Recalculate the transfer size by adding up each packet */
+		urb->actual_length = 0;
+		for (i = 0; i < urb->number_of_packets; i++) {
+			if (iso_packet[i].status == CVMX_USB_COMPLETE_SUCCESS) {
+				urb->iso_frame_desc[i].status = 0;
+				urb->iso_frame_desc[i].actual_length = iso_packet[i].length;
+				urb->actual_length += urb->iso_frame_desc[i].actual_length;
+			} else {
+				DEBUG_ERROR("%s: ISOCHRONOUS packet=%d of %d status=%d pipe=%d submit=%d size=%d\n",
+					    __FUNCTION__, i, urb->number_of_packets,
+					    iso_packet[i].status, pipe_handle,
+					    submit_handle, iso_packet[i].length);
+				urb->iso_frame_desc[i].status = -EREMOTEIO;
+			}
+		}
+		/* Free the private list now that we don't need it anymore */
+		kfree(iso_packet);
+		urb->setup_packet = NULL;
+	}
+
+	switch (status) {
+	case CVMX_USB_COMPLETE_SUCCESS:
+		urb->status = 0;
+		break;
+	case CVMX_USB_COMPLETE_CANCEL:
+		urb->status = -ENOENT;
+		break;
+	case CVMX_USB_COMPLETE_STALL:
+		DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_BABBLEERR:
+		DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+	case CVMX_USB_COMPLETE_SHORT:
+		DEBUG_ERROR("%s: status=short pipe=%d submit=%d size=%d\n", __FUNCTION__, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EREMOTEIO;
+		break;
+	case CVMX_USB_COMPLETE_ERROR:
+	case CVMX_USB_COMPLETE_XACTERR:
+	case CVMX_USB_COMPLETE_DATATGLERR:
+	case CVMX_USB_COMPLETE_FRAMEERR:
+		DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n", __FUNCTION__, status, pipe_handle, submit_handle, bytes_transferred);
+		urb->status = -EPROTO;
+		break;
+	}
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(hcd, urb, urb->status);
+	spin_lock(&priv->lock);
+}
+
+static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
+				  struct urb *urb,
+				  gfp_t mem_flags)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	int submit_handle = -1;
+	int pipe_handle;
+	unsigned long flags;
+	cvmx_usb_iso_packet_t *iso_packet;
+	struct usb_host_endpoint *ep = urb->ep;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (!ep->hcpriv) {
+		cvmx_usb_transfer_t transfer_type;
+		cvmx_usb_speed_t speed;
+		int split_device = 0;
+		int split_port = 0;
+		switch (usb_pipetype(urb->pipe)) {
+		case PIPE_ISOCHRONOUS:
+			transfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;
+			break;
+		case PIPE_INTERRUPT:
+			transfer_type = CVMX_USB_TRANSFER_INTERRUPT;
+			break;
+		case PIPE_CONTROL:
+			transfer_type = CVMX_USB_TRANSFER_CONTROL;
+			break;
+		default:
+			transfer_type = CVMX_USB_TRANSFER_BULK;
+			break;
+		}
+		switch (urb->dev->speed) {
+		case USB_SPEED_LOW:
+			speed = CVMX_USB_SPEED_LOW;
+			break;
+		case USB_SPEED_FULL:
+			speed = CVMX_USB_SPEED_FULL;
+			break;
+		default:
+			speed = CVMX_USB_SPEED_HIGH;
+			break;
+		}
+		/* For slow devices on high speed ports we need to find the hub that
+		   does the speed translation so we know where to send the split
+		   transactions */
+		if (speed != CVMX_USB_SPEED_HIGH) {
+			/* Start at this device and work our way up the usb tree */
+			struct usb_device *dev = urb->dev;
+			while (dev->parent) {
+				/* If our parent is high speed then he'll receive the splits */
+				if (dev->parent->speed == USB_SPEED_HIGH) {
+					split_device = dev->parent->devnum;
+					split_port = dev->portnum;
+					break;
+				}
+				/* Move up the tree one level. If we make it all the way up the
+				   tree, then the port must not be in high speed mode and we
+				   don't need a split */
+				dev = dev->parent;
+			}
+		}
+		pipe_handle = cvmx_usb_open_pipe(&priv->usb,
+						 0,
+						 usb_pipedevice(urb->pipe),
+						 usb_pipeendpoint(urb->pipe),
+						 speed,
+						 le16_to_cpu(ep->desc.wMaxPacketSize) & 0x7ff,
+						 transfer_type,
+						 usb_pipein(urb->pipe) ? CVMX_USB_DIRECTION_IN : CVMX_USB_DIRECTION_OUT,
+						 urb->interval,
+						 (le16_to_cpu(ep->desc.wMaxPacketSize)>>11) & 0x3,
+						 split_device,
+						 split_port);
+		if (pipe_handle < 0) {
+			spin_unlock_irqrestore(&priv->lock, flags);
+			DEBUG_ERROR("OcteonUSB: %s failed to create pipe\n", __FUNCTION__);
+			return -ENOMEM;
+		}
+		ep->hcpriv = (void *)(0x10000L + pipe_handle);
+	} else
+		pipe_handle = 0xffff & (long)ep->hcpriv;
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_ISOCHRONOUS:
+		DEBUG_SUBMIT("OcteonUSB: %s submit isochronous to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		/* Allocate a structure to use for our private list of isochronous
+		   packets */
+		iso_packet = kmalloc(urb->number_of_packets * sizeof(cvmx_usb_iso_packet_t), GFP_ATOMIC);
+		if (iso_packet) {
+			int i;
+			/* Fill the list with the data from the URB */
+			for (i = 0; i < urb->number_of_packets; i++) {
+				iso_packet[i].offset = urb->iso_frame_desc[i].offset;
+				iso_packet[i].length = urb->iso_frame_desc[i].length;
+				iso_packet[i].status = CVMX_USB_COMPLETE_ERROR;
+			}
+			/* Store a pointer to the list in uthe URB setup_pakcet field.
+			   We know this currently isn't being used and this saves us
+			   a bunch of logic */
+			urb->setup_packet = (char *)iso_packet;
+			submit_handle = cvmx_usb_submit_isochronous(&priv->usb, pipe_handle,
+								    urb->start_frame,
+								    0 /* flags */,
+								    urb->number_of_packets,
+								    iso_packet,
+								    urb->transfer_dma,
+								    urb->transfer_buffer_length,
+								    octeon_usb_urb_complete_callback,
+								    urb);
+			/* If submit failed we need to free our private packet list */
+			if (submit_handle < 0) {
+				urb->setup_packet = NULL;
+				kfree(iso_packet);
+			}
+		}
+		break;
+	case PIPE_INTERRUPT:
+		DEBUG_SUBMIT("OcteonUSB: %s submit interrupt to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_interrupt(&priv->usb, pipe_handle,
+							  urb->transfer_dma,
+							  urb->transfer_buffer_length,
+							  octeon_usb_urb_complete_callback,
+							  urb);
+		break;
+	case PIPE_CONTROL:
+		DEBUG_SUBMIT("OcteonUSB: %s submit control to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_control(&priv->usb, pipe_handle,
+							urb->setup_dma,
+							urb->transfer_dma,
+							urb->transfer_buffer_length,
+							octeon_usb_urb_complete_callback,
+							urb);
+		break;
+	case PIPE_BULK:
+		DEBUG_SUBMIT("OcteonUSB: %s submit bulk to %d.%d\n", __FUNCTION__, usb_pipedevice(urb->pipe), usb_pipeendpoint(urb->pipe));
+		submit_handle = cvmx_usb_submit_bulk(&priv->usb, pipe_handle,
+						     urb->transfer_dma,
+						     urb->transfer_buffer_length,
+						     octeon_usb_urb_complete_callback,
+						     urb);
+		break;
+	}
+	if (submit_handle < 0) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		DEBUG_ERROR("OcteonUSB: %s failed to submit\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+	urb->hcpriv = (void *)(long)(((submit_handle & 0xffff) << 16) | pipe_handle);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	int pipe_handle;
+	int submit_handle;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	if (!urb->dev)
+		return -EINVAL;
+
+	pipe_handle = 0xffff & (long)urb->hcpriv;
+	submit_handle = ((long)urb->hcpriv) >> 16;
+	spin_lock_irqsave(&priv->lock, flags);
+	if (cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle)) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		DEBUG_ERROR("OcteonUSB: Canceling URB failed\n");
+		return -1;
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	if (ep->hcpriv) {
+		octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+		int pipe_handle = 0xffff & (long)ep->hcpriv;
+		unsigned long flags;
+		spin_lock_irqsave(&priv->lock, flags);
+		cvmx_usb_cancel_all(&priv->usb, pipe_handle);
+		if (cvmx_usb_close_pipe(&priv->usb, pipe_handle))
+			DEBUG_ERROR("OcteonUSB: Closing pipe %d failed\n", pipe_handle);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		ep->hcpriv = NULL;
+	}
+}
+
+static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	cvmx_usb_port_status_t port_status;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	port_status = cvmx_usb_get_status(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	buf[0] = 0;
+	buf[0] = port_status.connect_change << 1;
+
+	return (buf[0] != 0);
+}
+
+static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	cvmx_usb_port_status_t usb_port_status;
+	int port_status;
+	struct usb_hub_descriptor *desc;
+	unsigned long flags;
+
+	switch (typeReq) {
+	case ClearHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearHubFeature\n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* Nothing required here */
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case ClearPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: ClearPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			DEBUG_ROOT_HUB(" ENABLE");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER");
+			/* Not supported on Octeon */
+			break;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR");
+			/* Port inidicator not supported */
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+			/* Clears drivers internal connect status change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			DEBUG_ROOT_HUB(" C_RESET");
+			/* Clears the driver's internal Port Reset Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			DEBUG_ROOT_HUB(" C_ENABLE");
+			/* Clears the driver's internal Port Enable/Disable Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			DEBUG_ROOT_HUB(" C_SUSPEND");
+			/* Clears the driver's internal Port Suspend Change flag,
+			   which is set when resume signaling on the host port is
+			   complete */
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			DEBUG_ROOT_HUB(" C_OVER_CURRENT");
+			/* Clears the driver's overcurrent Change flag */
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_set_status(&priv->usb, cvmx_usb_get_status(&priv->usb));
+			spin_unlock_irqrestore(&priv->lock, flags);
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case GetHubDescriptor:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubDescriptor\n");
+		desc = (struct usb_hub_descriptor *)buf;
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = 0x08;
+		desc->bPwrOn2PwrGood = 1;
+		desc->bHubContrCurrent = 0;
+		desc->bitmap[0] = 0;
+		desc->bitmap[1] = 0xff;
+		break;
+	case GetHubStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetHubStatus\n");
+		*(__le32 *)buf = 0;
+		break;
+	case GetPortStatus:
+		DEBUG_ROOT_HUB("OcteonUSB: GetPortStatus");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&priv->lock, flags);
+		usb_port_status = cvmx_usb_get_status(&priv->usb);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		port_status = 0;
+
+		if (usb_port_status.connect_change) {
+			port_status |= (1 << USB_PORT_FEAT_C_CONNECTION);
+			DEBUG_ROOT_HUB(" C_CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_C_ENABLE);
+			DEBUG_ROOT_HUB(" C_ENABLE");
+		}
+
+		if (usb_port_status.connected) {
+			port_status |= (1 << USB_PORT_FEAT_CONNECTION);
+			DEBUG_ROOT_HUB(" CONNECTION");
+		}
+
+		if (usb_port_status.port_enabled) {
+			port_status |= (1 << USB_PORT_FEAT_ENABLE);
+			DEBUG_ROOT_HUB(" ENABLE");
+		}
+
+		if (usb_port_status.port_over_current) {
+			port_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);
+			DEBUG_ROOT_HUB(" OVER_CURRENT");
+		}
+
+		if (usb_port_status.port_powered) {
+			port_status |= (1 << USB_PORT_FEAT_POWER);
+			DEBUG_ROOT_HUB(" POWER");
+		}
+
+		if (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {
+			port_status |= (1 << USB_PORT_FEAT_HIGHSPEED);
+			DEBUG_ROOT_HUB(" HIGHSPEED");
+		} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {
+			port_status |= (1 << USB_PORT_FEAT_LOWSPEED);
+			DEBUG_ROOT_HUB(" LOWSPEED");
+		}
+
+		*((__le32 *)buf) = cpu_to_le32(port_status);
+		DEBUG_ROOT_HUB("\n");
+		break;
+	case SetHubFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetHubFeature\n");
+		/* No HUB features supported */
+		break;
+	case SetPortFeature:
+		DEBUG_ROOT_HUB("OcteonUSB: SetPortFeature");
+		if (wIndex != 1) {
+			DEBUG_ROOT_HUB(" INVALID\n");
+			return -EINVAL;
+		}
+
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			DEBUG_ROOT_HUB(" SUSPEND\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_POWER:
+			DEBUG_ROOT_HUB(" POWER\n");
+			return -EINVAL;
+		case USB_PORT_FEAT_RESET:
+			DEBUG_ROOT_HUB(" RESET\n");
+			spin_lock_irqsave(&priv->lock, flags);
+			cvmx_usb_disable(&priv->usb);
+			if (cvmx_usb_enable(&priv->usb))
+				DEBUG_ERROR("Failed to enable the port\n");
+			spin_unlock_irqrestore(&priv->lock, flags);
+			return 0;
+		case USB_PORT_FEAT_INDICATOR:
+			DEBUG_ROOT_HUB(" INDICATOR\n");
+			/* Not supported */
+			break;
+		default:
+			DEBUG_ROOT_HUB(" UNKNOWN\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		DEBUG_ROOT_HUB("OcteonUSB: Unknown root hub request\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static const struct hc_driver octeon_hc_driver = {
+	.description =      "Octeon USB",
+	.product_desc =     "Octeon Host Controller",
+	.hcd_priv_size =    sizeof(octeon_usb_priv_t),
+	.irq =              octeon_usb_irq,
+	.flags =            HCD_MEMORY | HCD_USB2,
+	.start =            octeon_usb_start,
+	.stop =             octeon_usb_stop,
+	.urb_enqueue =      octeon_usb_urb_enqueue,
+	.urb_dequeue =      octeon_usb_urb_dequeue,
+	.endpoint_disable = octeon_usb_endpoint_disable,
+	.get_frame_number = octeon_usb_get_frame_number,
+	.hub_status_data =  octeon_usb_hub_status_data,
+	.hub_control =      octeon_usb_hub_control,
+};
+
+
+static int octeon_usb_driver_probe(struct device *dev)
+{
+	int status;
+	int usb_num = to_platform_device(dev)->id;
+	int irq = platform_get_irq(to_platform_device(dev), 0);
+	octeon_usb_priv_t *priv;
+	struct usb_hcd *hcd;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	/* Set the DMA mask to 64bits so we get buffers already translated for
+	   DMA */
+	dev->coherent_dma_mask = ~0;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+	hcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));
+	if (!hcd) {
+		DEBUG_FATAL("OcteonUSB: Failed to allocate memory for HCD\n");
+		return -1;
+	}
+	hcd->uses_new_polling = 1;
+	priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	/*status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS); */
+	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB initialization failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	/* This delay is needed for CN3010, but I don't know why... */
+	mdelay(10);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	cvmx_usb_poll(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	status = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (status) {
+		DEBUG_FATAL("OcteonUSB: USB add HCD failed with %d\n", status);
+		kfree(hcd);
+		return -1;
+	}
+
+	printk("OcteonUSB: Registered HCD for port %d on irq %d\n", usb_num, irq);
+
+	return 0;
+}
+
+static int octeon_usb_driver_remove(struct device *dev)
+{
+	int status;
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	unsigned long flags;
+
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+
+	usb_remove_hcd(hcd);
+	spin_lock_irqsave(&priv->lock, flags);
+	status = cvmx_usb_shutdown(&priv->usb);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (status)
+		DEBUG_FATAL("OcteonUSB: USB shutdown failed with %d\n", status);
+
+	kfree(hcd);
+
+	return 0;
+}
+
+static struct device_driver octeon_usb_driver = {
+	.name       = "OcteonUSB",
+	.bus        = &platform_bus_type,
+	.probe      = octeon_usb_driver_probe,
+	.remove     = octeon_usb_driver_remove,
+};
+
+
+#define MAX_USB_PORTS   10
+struct platform_device *pdev_glob[MAX_USB_PORTS];
+static int octeon_usb_registered;
+static int __init octeon_usb_module_init(void)
+{
+	int num_devices = cvmx_usb_get_num_ports();
+	int device;
+
+	if (usb_disabled() || num_devices == 0)
+		return -ENODEV;
+
+	if (driver_register(&octeon_usb_driver)) {
+		DEBUG_FATAL("OcteonUSB: Failed to register driver\n");
+		return -ENOMEM;
+	}
+	octeon_usb_registered = 1;
+	printk(KERN_INFO "OcteonUSB: Detected %d ports\n", num_devices);
+	for (device = 0; device < num_devices; device++) {
+		struct resource irq_resource;
+		struct platform_device *pdev;
+		memset(&irq_resource, 0, sizeof(irq_resource));
+		irq_resource.start = (device == 0) ? OCTEON_IRQ_USB0 : OCTEON_IRQ_USB1;
+		irq_resource.end = irq_resource.start;
+		irq_resource.flags = IORESOURCE_IRQ;
+		pdev = platform_device_register_simple((char *)octeon_usb_driver.name, device, &irq_resource, 1);
+		if (!pdev) {
+			DEBUG_FATAL("OcteonUSB: Failed to allocate platform device for USB%d\n", device);
+			return -ENOMEM;
+		}
+		if (device < MAX_USB_PORTS)
+			pdev_glob[device] = pdev;
+
+	}
+	return 0;
+}
+
+static void __exit octeon_usb_module_cleanup(void)
+{
+	int i;
+	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
+	for (i = 0; i < MAX_USB_PORTS; i++)
+		if (pdev_glob[i]) {
+			platform_device_unregister(pdev_glob[i]);
+			pdev_glob[i] = NULL;
+		}
+	if (octeon_usb_registered)
+		driver_unregister(&octeon_usb_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cavium Networks <support@caviumnetworks.com>");
+MODULE_DESCRIPTION("Cavium Networks Octeon USB Host driver.");
+module_init(octeon_usb_module_init);
+module_exit(octeon_usb_module_cleanup);
diff --git a/drivers/usb/host/octeon2-common.c b/drivers/usb/host/octeon2-common.c
new file mode 100644
index 0000000..73a5ed9
--- /dev/null
+++ b/drivers/usb/host/octeon2-common.c
@@ -0,0 +1,166 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Cavium Networks
+ */
+
+#include <linux/module.h>
+#include <linux/time.h>
+
+#include <asm/atomic.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-uctlx-defs.h>
+
+static atomic_t  octeon2_usb_clock_start_cnt = ATOMIC_INIT(0);
+
+void octeon2_usb_clocks_start(void)
+{
+	u64 div;
+	union cvmx_uctlx_if_ena if_ena;
+	union cvmx_uctlx_clk_rst_ctl clk_rst_ctl;
+	union cvmx_uctlx_uphy_ctl_status uphy_ctl_status;
+
+	if (atomic_inc_return(&octeon2_usb_clock_start_cnt) != 1)
+		return;
+
+	/*
+	 * Step 1: Wait for voltages stable.  That surely happened
+	 * before starting the kernel.
+	 *
+	 * Step 2: Enable  SCLK of UCTL by writing UCTL0_IF_ENA[EN] = 1
+	 */
+	if_ena.u64 = 0;
+	if_ena.s.en = 1;
+	cvmx_write_csr(CVMX_UCTLX_IF_ENA(0), if_ena.u64);
+
+	/* Step 3: Configure the reference clock, PHY, and HCLK */
+	clk_rst_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_CLK_RST_CTL(0));
+	/* 3a */
+	clk_rst_ctl.s.p_por = 1;
+	clk_rst_ctl.s.hrst = 0;
+	clk_rst_ctl.s.p_prst = 0;
+	clk_rst_ctl.s.h_clkdiv_rst = 0;
+	clk_rst_ctl.s.o_clkdiv_rst = 0;
+	clk_rst_ctl.s.h_clkdiv_en = 0;
+	clk_rst_ctl.s.o_clkdiv_en = 0;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* 3b */
+	/* 12MHz crystal. */
+	clk_rst_ctl.s.p_refclk_sel = 0;
+	clk_rst_ctl.s.p_refclk_div = 0;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* 3c */
+	div = octeon_get_io_clock_rate() / 130000000ull;
+
+	switch (div) {
+	case 0:
+		div = 1;
+		break;
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+		break;
+	case 5:
+		div = 4;
+		break;
+	case 6:
+	case 7:
+		div = 6;
+		break;
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+		div = 8;
+		break;
+	default:
+		div = 12;
+		break;
+	}
+	clk_rst_ctl.s.h_div = div;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+	/* Read it back, */
+	clk_rst_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_CLK_RST_CTL(0));
+	clk_rst_ctl.s.h_clkdiv_en = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+	/* 3d */
+	clk_rst_ctl.s.h_clkdiv_rst = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* 3e */
+	octeon_io_clk_delay(64);
+
+	/*
+	 * Step 4: Program the power-on reset field in the UCTL
+	 * clock-reset-control register.
+	 */
+	clk_rst_ctl.s.p_por = 0;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* Step 5:    Wait 1 ms for the PHY clock to start. */
+	mdelay(1);
+
+	/*
+	 * Step 6: Program the reset input from automatic test
+	 * equipment field in the UPHY CSR
+	 */
+	uphy_ctl_status.u64 = cvmx_read_csr(CVMX_UCTLX_UPHY_CTL_STATUS(0));
+	uphy_ctl_status.s.ate_reset = 1;
+	cvmx_write_csr(CVMX_UCTLX_UPHY_CTL_STATUS(0), uphy_ctl_status.u64);
+
+	/* Step 7: Wait for at least 10ns. */
+	ndelay(10);
+
+	/* Step 8: Clear the ATE_RESET field in the UPHY CSR. */
+	uphy_ctl_status.s.ate_reset = 0;
+	cvmx_write_csr(CVMX_UCTLX_UPHY_CTL_STATUS(0), uphy_ctl_status.u64);
+
+	/*
+	 * Step 9: Wait for at least 20ns for UPHY to output PHY clock
+	 * signals and OHCI_CLK48
+	 */
+	ndelay(20);
+
+	/* Step 10: Configure the OHCI_CLK48 and OHCI_CLK12 clocks. */
+	/* 10a */
+	clk_rst_ctl.s.o_clkdiv_rst = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* 10b */
+	clk_rst_ctl.s.o_clkdiv_en = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* 10c */
+	octeon_io_clk_delay(64);
+
+	/* Step 11: Program the PHY reset field: UCTL0_CLK_RST_CTL[P_PRST] = 1 */
+	clk_rst_ctl.s.p_prst = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+	/* Step 12: Wait 1 uS. */
+	udelay(1);
+
+	/* Step 13: Program the HRESET_N field: UCTL0_CLK_RST_CTL[HRST] = 1 */
+	clk_rst_ctl.s.hrst = 1;
+	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+}
+EXPORT_SYMBOL(octeon2_usb_clocks_start);
+
+void octeon2_usb_clocks_stop(void)
+{
+	union cvmx_uctlx_if_ena if_ena;
+
+	if (atomic_dec_return(&octeon2_usb_clock_start_cnt) != 0)
+		return;
+
+	if_ena.u64 = 0;
+	if_ena.s.en = 0;
+	cvmx_write_csr(CVMX_UCTLX_IF_ENA(0), if_ena.u64);
+}
+EXPORT_SYMBOL(octeon2_usb_clocks_stop);
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index c8b5064..14ccaaf 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1080,6 +1080,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ohci_hcd_da8xx_driver
 #endif
 
+#ifdef CONFIG_USB_OCTEON_OHCI
+#include "ohci-octeon.c"
+#define PLATFORM_DRIVER		ohci_octeon_driver
+#endif
+
 #if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
     defined(CONFIG_CPU_SUBTYPE_SH7721) || \
     defined(CONFIG_CPU_SUBTYPE_SH7763) || \
diff --git a/drivers/usb/host/ohci-octeon.c b/drivers/usb/host/ohci-octeon.c
new file mode 100644
index 0000000..5c94917
--- /dev/null
+++ b/drivers/usb/host/ohci-octeon.c
@@ -0,0 +1,204 @@
+/*
+ * EHCI HCD glue for Cavium Octeon II SOCs.
+ *
+ * Loosely based on ehci-au1xxx.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2010 Cavium Networks
+ *
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-uctlx-defs.h>
+
+#define OCTEON_OHCI_HCD_NAME "octeon-ohci"
+
+/* Common clock init code.  */
+void octeon2_usb_clocks_start(void);
+void octeon2_usb_clocks_stop(void);
+
+static void ohci_octeon_hw_start(void)
+{
+	union cvmx_uctlx_ohci_ctl ohci_ctl;
+
+	octeon2_usb_clocks_start();
+
+	ohci_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_OHCI_CTL(0));
+	ohci_ctl.s.l2c_addr_msb = 0;
+	ohci_ctl.s.l2c_buff_emod = 1; /* Byte swapped. */
+	ohci_ctl.s.l2c_desc_emod = 1; /* Byte swapped. */
+	cvmx_write_csr(CVMX_UCTLX_OHCI_CTL(0), ohci_ctl.u64);
+
+}
+
+static void ohci_octeon_hw_stop(void)
+{
+	/* Undo ohci_octeon_start() */
+	octeon2_usb_clocks_stop();
+}
+
+static int __devinit ohci_octeon_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		ohci_err(ohci, "can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver ohci_octeon_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "Octeon OHCI",
+	.hcd_priv_size		= sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_octeon_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+static int ohci_octeon_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct ohci_hcd *ohci;
+	void *reg_base;
+	struct resource *res_mem;
+	int irq;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No irq assigned\n");
+		return -ENODEV;
+	}
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(&pdev->dev, "No register space assigned\n");
+		return -ENODEV;
+	}
+
+	/* Ohci is a 32-bit device. */
+	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+
+	hcd = usb_create_hcd(&ohci_octeon_hc_driver, &pdev->dev, "octeon");
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res_mem->start;
+	hcd->rsrc_len = res_mem->end - res_mem->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, OCTEON_OHCI_HCD_NAME)) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	reg_base = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!reg_base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	ohci_octeon_hw_start();
+
+	hcd->regs = reg_base;
+
+	ohci = hcd_to_ohci(hcd);
+
+	/* Octeon OHCI matches CPU endianness. */
+#ifdef __BIG_ENDIAN
+	ohci->flags |= OHCI_QUIRK_BE_MMIO;
+#endif
+
+	ohci_hcd_init(ohci);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, hcd);
+		return ret;
+	}
+
+	ohci_octeon_hw_stop();
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static int ohci_octeon_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+
+	ohci_octeon_hw_stop();
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver ohci_octeon_driver = {
+	.probe		= ohci_octeon_drv_probe,
+	.remove		= ohci_octeon_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name	= OCTEON_OHCI_HCD_NAME,
+		.owner	= THIS_MODULE,
+	}
+};
+
+MODULE_ALIAS("platform:" OCTEON_OHCI_HCD_NAME);
-- 
1.7.0.4

