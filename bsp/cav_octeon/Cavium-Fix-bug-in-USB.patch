From 7f04c2654b07e963ae163bf2ccaf4f20e747b05b Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Thu, 10 Mar 2011 11:35:59 -0800
Subject: [PATCH 03/13] Cavium: Fix bug in USB

Source: Cavium sdk_2.0.0_updates_p4.tgz

octeon-hcd.c:
1. Change the struct name from "octeon_usb_priv_t" to "struct octeon_hcd",
   and abstract the common codes into functions.

2. Only cn52XX and cn56XX have DWC_OTG USB hardware and the IOB priority
   registers. Under heavy network load USB hardware can be starved by
   the IOB causing a crash. Add codes to select a threshold used to
   determine when it is necessary to increase the priority to avoid
   starving the USB hardware. Give it a priority boost if it has been
   waiting more than 400 cycles to avoid this situation.

   Testing indicates that a cnt_val of 8192 is not sufficient, because
   if the hardware has been waiting 8192 cycles, crashes occur. If the
   hardware has been waiting 4096 cycles, no crashes occur, but since
   it is difficult to prove a negative (i.e., since we aren't comfortable
   stating that the crash will NEVER occur at this level) we want to
   choose a threshold that is smaller than 4096 by a significant margin,
   in this case a factor of 10: 4096/10 = 409.6 which is pretty close
   to 400 as a nice round number.

octeon2-common.c:
1. Substitute atomic operation for mutex to protect global static
   variable octeon2_usb_clock_start_cnt.

2. Add the check of whether UCTL has already been started to avoid
   bus errors in octeon2_usb_clock_start().

3. Add the usb clock support for NIC10e board by configuring
   USB_X0 to 12/24/48 MHz and USB_X1 to ground.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 drivers/usb/host/octeon-hcd.c     |   88 +++++++++++++++++++++++++++---------
 drivers/usb/host/octeon2-common.c |   55 +++++++++++++++++-----
 2 files changed, 108 insertions(+), 35 deletions(-)

diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
index c493549..ae44811 100644
--- a/drivers/usb/host/octeon-hcd.c
+++ b/drivers/usb/host/octeon-hcd.c
@@ -12,10 +12,15 @@
 #include <linux/platform_device.h>
 #include <linux/platform_device.h>
 #include <linux/usb.h>
+
 #include <asm/time.h>
 #include <asm/delay.h>
-#include "../../../drivers/usb/core/hcd.h"
+
+#include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-usb.h>
+#include <asm/octeon/cvmx-iob-defs.h>
+
+#include "../core/hcd.h"
 
 /*#define DEBUG_CALL(format, ...)         printk(format, ##__VA_ARGS__) */
 #define DEBUG_CALL(format, ...)         do {} while (0)
@@ -27,14 +32,31 @@
 #define DEBUG_ERROR(format, ...)        do {} while (0)
 #define DEBUG_FATAL(format, ...)        printk(format, ##__VA_ARGS__)
 
-typedef struct {
+struct octeon_hcd {
 	spinlock_t lock;
 	cvmx_usb_state_t usb;
-} octeon_usb_priv_t;
+};
+
+/* convert between an HCD pointer and the corresponding struct octeon_hcd */
+static inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)
+{
+	return (struct octeon_hcd *)(hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)
+{
+	return container_of((void *)p, struct usb_hcd, hcd_priv);
+}
+
+static inline struct octeon_hcd *cvmx_usb_to_octeon(cvmx_usb_state_t *p)
+{
+	return container_of(p, struct octeon_hcd, usb);
+}
 
 static irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	spin_lock_irqsave(&priv->lock, flags);
@@ -51,17 +73,16 @@ static void octeon_usb_port_callback(cvmx_usb_state_t *usb,
 				     int bytes_transferred,
 				     void *user_data)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)((void*)usb - offsetof(octeon_usb_priv_t, usb));
-	struct usb_hcd *hcd = ((void *)priv - offsetof(struct usb_hcd, hcd_priv));
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	spin_unlock(&priv->lock);
-	usb_hcd_poll_rh_status(hcd);
+	usb_hcd_poll_rh_status(octeon_to_hcd(priv));
 	spin_lock(&priv->lock);
 }
 
 static int octeon_usb_start(struct usb_hcd *hcd)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	hcd->state = HC_STATE_RUNNING;
@@ -74,7 +95,7 @@ static int octeon_usb_start(struct usb_hcd *hcd)
 
 static void octeon_usb_stop(struct usb_hcd *hcd)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	spin_lock_irqsave(&priv->lock, flags);
@@ -86,7 +107,7 @@ static void octeon_usb_stop(struct usb_hcd *hcd)
 
 static int octeon_usb_get_frame_number(struct usb_hcd *hcd)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	return cvmx_usb_get_frame_number(&priv->usb);
 }
@@ -99,8 +120,7 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 					     int bytes_transferred,
 					     void *user_data)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)((void*)usb - offsetof(octeon_usb_priv_t, usb));
-	struct usb_hcd *hcd = ((void *)priv - offsetof(struct usb_hcd, hcd_priv));
+	struct octeon_hcd *priv = cvmx_usb_to_octeon(usb);
 	struct urb *urb = user_data;
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	urb->actual_length = bytes_transferred;
@@ -160,7 +180,7 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 		break;
 	}
 	spin_unlock(&priv->lock);
-	usb_hcd_giveback_urb(hcd, urb, urb->status);
+	usb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);
 	spin_lock(&priv->lock);
 }
 
@@ -168,7 +188,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 				  struct urb *urb,
 				  gfp_t mem_flags)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	int submit_handle = -1;
 	int pipe_handle;
 	unsigned long flags;
@@ -320,7 +340,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 
 static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	int pipe_handle;
 	int submit_handle;
 	unsigned long flags;
@@ -346,7 +366,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 {
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
 	if (ep->hcpriv) {
-		octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+		struct octeon_hcd *priv = hcd_to_octeon(hcd);
 		int pipe_handle = 0xffff & (long)ep->hcpriv;
 		unsigned long flags;
 		spin_lock_irqsave(&priv->lock, flags);
@@ -360,7 +380,7 @@ static void octeon_usb_endpoint_disable(struct usb_hcd *hcd, struct usb_host_end
 
 static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	cvmx_usb_port_status_t port_status;
 	unsigned long flags;
 
@@ -377,7 +397,7 @@ static int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)
 
 static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)
 {
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	cvmx_usb_port_status_t usb_port_status;
 	int port_status;
 	struct usb_hub_descriptor *desc;
@@ -576,7 +596,7 @@ static int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 static const struct hc_driver octeon_hc_driver = {
 	.description =      "Octeon USB",
 	.product_desc =     "Octeon Host Controller",
-	.hcd_priv_size =    sizeof(octeon_usb_priv_t),
+	.hcd_priv_size =    sizeof(struct octeon_hcd),
 	.irq =              octeon_usb_irq,
 	.flags =            HCD_MEMORY | HCD_USB2,
 	.start =            octeon_usb_start,
@@ -595,7 +615,7 @@ static int octeon_usb_driver_probe(struct device *dev)
 	int status;
 	int usb_num = to_platform_device(dev)->id;
 	int irq = platform_get_irq(to_platform_device(dev), 0);
-	octeon_usb_priv_t *priv;
+	struct octeon_hcd *priv;
 	struct usb_hcd *hcd;
 	unsigned long flags;
 
@@ -612,7 +632,10 @@ static int octeon_usb_driver_probe(struct device *dev)
 		return -1;
 	}
 	hcd->uses_new_polling = 1;
-	priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	priv = (struct octeon_hcd *)hcd->hcd_priv;
+
+	spin_lock_init(&priv->lock);
+
 	/*status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO | CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS | CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS); */
 	status = cvmx_usb_initialize(&priv->usb, usb_num, CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO);
 	if (status) {
@@ -644,7 +667,7 @@ static int octeon_usb_driver_remove(struct device *dev)
 {
 	int status;
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	octeon_usb_priv_t *priv = (octeon_usb_priv_t *)hcd->hcd_priv;
+	struct octeon_hcd *priv = hcd_to_octeon(hcd);
 	unsigned long flags;
 
 	DEBUG_CALL("OcteonUSB: %s called\n", __FUNCTION__);
@@ -718,6 +741,27 @@ static int __init octeon_usb_module_init(void)
 
 	octeon_usb_registered = 1;
 	printk(KERN_INFO "OcteonUSB: Detected %d ports\n", num_devices);
+
+	/*
+	 * Only cn52XX and cn56XX have DWC_OTG USB hardware and the
+	 * IOB priority registers.  Under heavy network load USB
+	 * hardware can be starved by the IOB causing a crash.  Give
+	 * it a priority boost if it has been waiting more than 400
+	 * cycles to avoid this situation.
+	 *
+	 * Testing indicates that a cnt_val of 8192 is not sufficient,
+	 * but no failures are seen with 4096.  We choose a value of
+	 * 400 to give a safety factor of 10.
+	 */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {
+		union cvmx_iob_n2c_l2c_pri_cnt pri_cnt;
+
+		pri_cnt.u64 = 0;
+		pri_cnt.s.cnt_enb = 1;
+		pri_cnt.s.cnt_val = 400;
+		cvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);
+	}
+
 	for (device = 0; device < num_devices; device++) {
 		struct resource irq_resource;
 		struct platform_device *pdev;
diff --git a/drivers/usb/host/octeon2-common.c b/drivers/usb/host/octeon2-common.c
index 73a5ed9..cc01cfe 100644
--- a/drivers/usb/host/octeon2-common.c
+++ b/drivers/usb/host/octeon2-common.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/time.h>
 
 #include <asm/atomic.h>
@@ -14,7 +15,9 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-uctlx-defs.h>
 
-static atomic_t  octeon2_usb_clock_start_cnt = ATOMIC_INIT(0);
+static DEFINE_MUTEX(octeon2_usb_clocks_mutex);
+
+static int octeon2_usb_clock_start_cnt;
 
 void octeon2_usb_clocks_start(void)
 {
@@ -22,9 +25,15 @@ void octeon2_usb_clocks_start(void)
 	union cvmx_uctlx_if_ena if_ena;
 	union cvmx_uctlx_clk_rst_ctl clk_rst_ctl;
 	union cvmx_uctlx_uphy_ctl_status uphy_ctl_status;
+	union cvmx_uctlx_uphy_portx_ctl_status port_ctl_status;
+	int i;
+
 
-	if (atomic_inc_return(&octeon2_usb_clock_start_cnt) != 1)
-		return;
+	mutex_lock(&octeon2_usb_clocks_mutex);
+
+	octeon2_usb_clock_start_cnt++;
+	if (octeon2_usb_clock_start_cnt != 1)
+		goto exit;
 
 	/*
 	 * Step 1: Wait for voltages stable.  That surely happened
@@ -38,6 +47,13 @@ void octeon2_usb_clocks_start(void)
 
 	/* Step 3: Configure the reference clock, PHY, and HCLK */
 	clk_rst_ctl.u64 = cvmx_read_csr(CVMX_UCTLX_CLK_RST_CTL(0));
+
+	/*
+	 * If the UCTL looks like it has already been started, skip
+	 * the initialization, otherwise bus errors are obtained.
+	 */
+	if (clk_rst_ctl.s.hrst)
+		goto end_clock;
 	/* 3a */
 	clk_rst_ctl.s.p_por = 1;
 	clk_rst_ctl.s.hrst = 0;
@@ -49,8 +65,12 @@ void octeon2_usb_clocks_start(void)
 	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
 
 	/* 3b */
-	/* 12MHz crystal. */
-	clk_rst_ctl.s.p_refclk_sel = 0;
+	if (octeon_bootinfo->board_type == CVMX_BOARD_TYPE_NIC10E)
+		/* USB_X0 uses 12/24/48 MHz and USB_X1 is grounded */
+		clk_rst_ctl.s.p_refclk_sel = 1;
+	else
+		/* USB_X0 and USB_X1 uses 12 MHz */
+		clk_rst_ctl.s.p_refclk_sel = 0;
 	clk_rst_ctl.s.p_refclk_div = 0;
 	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
 
@@ -149,18 +169,27 @@ void octeon2_usb_clocks_start(void)
 	/* Step 13: Program the HRESET_N field: UCTL0_CLK_RST_CTL[HRST] = 1 */
 	clk_rst_ctl.s.hrst = 1;
 	cvmx_write_csr(CVMX_UCTLX_CLK_RST_CTL(0), clk_rst_ctl.u64);
+
+end_clock:
+	/* Now we can set some other registers.  */
+
+	for (i = 0; i <= 1; i++) {
+		port_ctl_status.u64 =
+			cvmx_read_csr(CVMX_UCTLX_UPHY_PORTX_CTL_STATUS(i, 0));
+		/* Set txvreftune to 15 to obtain complient 'eye' diagram. */
+		port_ctl_status.s.txvreftune = 15;
+		cvmx_write_csr(CVMX_UCTLX_UPHY_PORTX_CTL_STATUS(i, 0),
+			       port_ctl_status.u64);
+	}
+exit:
+	mutex_unlock(&octeon2_usb_clocks_mutex);
 }
 EXPORT_SYMBOL(octeon2_usb_clocks_start);
 
 void octeon2_usb_clocks_stop(void)
 {
-	union cvmx_uctlx_if_ena if_ena;
-
-	if (atomic_dec_return(&octeon2_usb_clock_start_cnt) != 0)
-		return;
-
-	if_ena.u64 = 0;
-	if_ena.s.en = 0;
-	cvmx_write_csr(CVMX_UCTLX_IF_ENA(0), if_ena.u64);
+	mutex_lock(&octeon2_usb_clocks_mutex);
+	octeon2_usb_clock_start_cnt--;
+	mutex_unlock(&octeon2_usb_clocks_mutex);
 }
 EXPORT_SYMBOL(octeon2_usb_clocks_stop);
-- 
1.7.0.4

