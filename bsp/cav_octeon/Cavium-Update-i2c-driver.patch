From 005f77a1e4d54d861246357db0a6d6a65aa47c75 Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Fri, 12 Nov 2010 11:22:39 +0800
Subject: [PATCH 034/132] Cavium: Update i2c driver

Source: SDK 2.0.0-366

CN3860 does not interrupt the CPU when the i2c status changes.  If we
get a timeout, and see the status has in fact changed, we know we have
this problem, and drop back to polling.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: ltian <le.tian@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c |   48 ++++++++++++++++++++++++++++++--------
 1 files changed, 38 insertions(+), 10 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index 0e9f85d..f449568 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -71,6 +71,7 @@ struct octeon_i2c {
 	void __iomem *twsi_base;
 	resource_size_t regsize;
 	struct device *dev;
+	int broken_irq_mode;
 };
 
 /**
@@ -205,6 +206,20 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 {
 	int result;
 
+	if (i2c->broken_irq_mode) {
+		/*
+		 * Some chip revisions seem to not assert the irq in
+		 * the interrupt controller.  So we must poll for the
+		 * IFLG change.
+		 */
+		u64 end = get_jiffies_64() + i2c->adap.timeout;
+
+		while (!octeon_i2c_test_iflg(i2c) && get_jiffies_64() <= end)
+			udelay(50);
+
+		return octeon_i2c_test_iflg(i2c) ? 0 : -ETIMEDOUT;
+	}
+
 	octeon_i2c_int_enable(i2c);
 
 	result = wait_event_interruptible_timeout(i2c->queue,
@@ -213,12 +228,19 @@ static int octeon_i2c_wait(struct octeon_i2c *i2c)
 
 	octeon_i2c_int_disable(i2c);
 
+
+	if (result <= 0 && octeon_i2c_test_iflg(i2c)) {
+		dev_err(i2c->dev, "broken irq connection detected, switching to polling mode.\n");
+		i2c->broken_irq_mode = 1;
+		return 0;
+	}
+
 	if (result < 0) {
 		dev_dbg(i2c->dev, "%s: wait interrupted\n", __func__);
 		return result;
 	} else if (result == 0) {
 		dev_dbg(i2c->dev, "%s: timeout\n", __func__);
-		result = -ETIMEDOUT;
+		return -ETIMEDOUT;
 	}
 
 	return 0;
@@ -304,6 +326,7 @@ static int octeon_i2c_write(struct octeon_i2c *i2c, int target,
 	int i, result;
 	u8 tmp;
 
+	udelay(100);
 	result = octeon_i2c_start(i2c);
 	if (result)
 		return result;
@@ -441,7 +464,6 @@ static struct i2c_adapter octeon_i2c_ops = {
 	.owner = THIS_MODULE,
 	.name = "OCTEON adapter",
 	.algo = &octeon_i2c_algo,
-	.timeout = 2,
 };
 
 /**
@@ -495,20 +517,26 @@ static int __devinit octeon_i2c_initlowlevel(struct octeon_i2c *i2c)
 	u8 status;
 	int tries;
 
-	/* disable high level controller, enable bus access */
-	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);
-
 	/* reset controller */
 	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_RST, 0);
 
-	for (tries = 10; tries; tries--) {
+	status = 0;
+	for (tries = 10; tries && status != STAT_IDLE; tries--) {
 		udelay(1);
 		status = octeon_i2c_read_sw(i2c, SW_TWSI_EOP_TWSI_STAT);
-		if (status == STAT_IDLE)
-			return 0;
 	}
-	dev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n", __func__, status);
-	return -EIO;
+
+	if (status != STAT_IDLE) {
+		dev_err(i2c->dev, "%s: TWSI_RST failed! (0x%x)\n",
+			__func__, status);
+		return -EIO;
+	}
+
+
+	/* disable high level controller, enable bus access */
+	octeon_i2c_write_sw(i2c, SW_TWSI_EOP_TWSI_CTL, TWSI_CTL_ENAB);
+
+	return 0;
 }
 
 static int __devinit octeon_i2c_probe(struct platform_device *pdev)
-- 
1.6.5.2

