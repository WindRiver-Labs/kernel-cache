From 01828a1d2ffd7f622a6e5bbbdf97a472836df613 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 25 Aug 2010 16:14:39 +0800
Subject: [PATCH] Staging: Octeon: Introduce USE_32BIT_SHARED macro to allocate
  FPA buffers in shared RESERVE32 area

When CAVIUM_RESERVE32 is enabled, kernel will reserve a shared
memory region for user space to use for hardware memory buffers.
This requried for 32bit applications to be able to send and
receive packets directly.

In Octeon ethernet driver, FPA should allocate memory buffers
in the shared RESERVE32 area instead of kernel memory space allocated
by kmalloc once CAVIUM_RESERVE32 is enabled.

So, introduce USE_32BIT_SHARED macro, which depends on CAVIUM_RESERVE32,
to force Octeon ethernet driver allocate FPA memory buffers in the
shared RESERVE32 area. If FPA doesn't allocate buffers in the RESERVE32
area, SE demos will access the wrong virtual address to cause
segmentation fault.

And, export cvmx_bootmem_alloc_range which is used to allocate
FPA buffer in RESERVE32 area.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-bootmem.c |    1 +
 drivers/staging/octeon/ethernet-defines.h        |   18 +++-
 drivers/staging/octeon/ethernet-mem.c            |   95 +++++++++++++---------
 3 files changed, 73 insertions(+), 41 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
index 0f2a1b3..a8aa9fa 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-bootmem.c
@@ -85,6 +85,7 @@ void *cvmx_bootmem_alloc_range(uint64_t size, uint64_t alignment,
 	else
 		return NULL;
 }
+EXPORT_SYMBOL(cvmx_bootmem_alloc_range);
 
 void *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,
 				 uint64_t alignment)
diff --git a/drivers/staging/octeon/ethernet-defines.h b/drivers/staging/octeon/ethernet-defines.h
index 6a2cd50..bdfd9c4 100644
--- a/drivers/staging/octeon/ethernet-defines.h
+++ b/drivers/staging/octeon/ethernet-defines.h
@@ -41,6 +41,9 @@
  *      Tells the driver to populate the packet buffers with kernel skbuffs.
  *      This allows the driver to receive packets without copying them. It also
  *      means that 32bit userspace can't access the packet buffers.
+ *  USE_32BIT_SHARED
+ *      This define tells the driver to allocate memory for buffers from the
+ *      32bit shared region instead of the kernel memory space.
  *  USE_HW_TCPUDP_CHECKSUM
  *      Controls if the Octeon TCP/UDP checksum engine is used for packet
  *      output. If this is zero, the kernel will perform the checksum in
@@ -68,11 +71,18 @@
 #define CONFIG_CAVIUM_RESERVE32 0
 #endif
 
-#define USE_SKBUFFS_IN_HW           1
-#ifdef CONFIG_NETFILTER
-#define REUSE_SKBUFFS_WITHOUT_FREE  0
+#ifdef CONFIG_CAVIUM_RESERVE32
+#	define USE_32BIT_SHARED            1
+#	define USE_SKBUFFS_IN_HW           0
+#	define REUSE_SKBUFFS_WITHOUT_FREE  0
 #else
-#define REUSE_SKBUFFS_WITHOUT_FREE  1
+#	define USE_32BIT_SHARED            0
+#	define USE_SKBUFFS_IN_HW           1
+#	ifdef CONFIG_NETFILTER
+#		define REUSE_SKBUFFS_WITHOUT_FREE  0
+#	else
+#		define REUSE_SKBUFFS_WITHOUT_FREE  1
+#	endif
 #endif
 
 #define USE_HW_TCPUDP_CHECKSUM      1
diff --git a/drivers/staging/octeon/ethernet-mem.c b/drivers/staging/octeon/ethernet-mem.c
index 635bb86..9096150 100644
--- a/drivers/staging/octeon/ethernet-mem.c
+++ b/drivers/staging/octeon/ethernet-mem.c
@@ -105,27 +105,44 @@ static int cvm_oct_fill_hw_memory(int pool, int size, int elements)
 	char *fpa;
 	int freed = elements;
 
-	while (freed) {
-		/*
-		 * FPA memory must be 128 byte aligned.  Since we are
-		 * aligning we need to save the original pointer so we
-		 * can feed it to kfree when the memory is returned to
-		 * the kernel.
-		 *
-		 * We allocate an extra 256 bytes to allow for
-		 * alignment and space for the original pointer saved
-		 * just before the block.
-		 */
-		memory = kmalloc(size + 256, GFP_ATOMIC);
-		if (unlikely(memory == NULL)) {
-			pr_warning("Unable to allocate %u bytes for FPA pool %d\n",
-				   elements * size, pool);
-			break;
+        if (USE_32BIT_SHARED) {
+		extern uint64_t octeon_reserve32_memory;
+
+		memory = cvmx_bootmem_alloc_range(elements*size, 128, octeon_reserve32_memory,
+                                                octeon_reserve32_memory + (CONFIG_CAVIUM_RESERVE32<<20) - 1);
+		if (memory == NULL)
+			panic("Unable to allocate %u bytes for FPA pool %d\n", elements*size, pool);
+
+		printk("Memory range %p - %p reserved for hardware\n", memory, memory + elements*size - 1);
+
+		while (freed) {
+			cvmx_fpa_free(memory, pool, 0);
+			memory += size;
+			freed--;
+		}
+	} else {
+		while (freed) {
+			/*
+		 	 * FPA memory must be 128 byte aligned.  Since we are
+		 	 * aligning we need to save the original pointer so we
+		 	 * can feed it to kfree when the memory is returned to
+		 	 * the kernel.
+		 	 *
+		 	 * We allocate an extra 256 bytes to allow for
+		 	 * alignment and space for the original pointer saved
+		 	 * just before the block.
+		 	 */
+			memory = kmalloc(size + 256, GFP_ATOMIC);
+			if (unlikely(memory == NULL)) {
+				pr_warning("Unable to allocate %u bytes for FPA pool %d\n",
+				   	elements * size, pool);
+				break;
+			}
+			fpa = (char *)(((unsigned long)memory + 256) & ~0x7fUL);
+			*((char **)fpa - 1) = memory;
+			cvmx_fpa_free(fpa, pool, 0);
+			freed--;
 		}
-		fpa = (char *)(((unsigned long)memory + 256) & ~0x7fUL);
-		*((char **)fpa - 1) = memory;
-		cvmx_fpa_free(fpa, pool, 0);
-		freed--;
 	}
 	return elements - freed;
 }
@@ -138,24 +155,28 @@ static int cvm_oct_fill_hw_memory(int pool, int size, int elements)
  */
 static void cvm_oct_free_hw_memory(int pool, int size, int elements)
 {
-	char *memory;
-	char *fpa;
-	do {
-		fpa = cvmx_fpa_alloc(pool);
-		if (fpa) {
-			elements--;
-			fpa = (char *)phys_to_virt(cvmx_ptr_to_phys(fpa));
-			memory = *((char **)fpa - 1);
-			kfree(memory);
-		}
-	} while (fpa);
+        if (USE_32BIT_SHARED) {
+		printk("Warning: 32 shared memory is not freeable\n");
+        } else {
+		char *memory;
+		char *fpa;
+		do {
+			fpa = cvmx_fpa_alloc(pool);
+			if (fpa) {
+				elements--;
+				fpa = (char *)phys_to_virt(cvmx_ptr_to_phys(fpa));
+				memory = *((char **)fpa - 1);
+				kfree(memory);
+			}
+		} while (fpa);
 
-	if (elements < 0)
-		pr_warning("Freeing of pool %u had too many buffers (%d)\n",
-			pool, elements);
-	else if (elements > 0)
-		pr_warning("Warning: Freeing of pool %u is missing %d buffers\n",
-			pool, elements);
+		if (elements < 0)
+			pr_warning("Freeing of pool %u had too many buffers (%d)\n",
+				pool, elements);
+		else if (elements > 0)
+			pr_warning("Warning: Freeing of pool %u is missing %d buffers\n",
+				pool, elements);
+	}
 }
 
 int cvm_oct_mem_fill_fpa(int pool, int size, int elements)
-- 
1.6.5.2

