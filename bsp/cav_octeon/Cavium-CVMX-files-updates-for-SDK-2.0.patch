From e51d9e03eddc8be605b1c39e99e74a5ce5e63b3e Mon Sep 17 00:00:00 2001
From: ltian <le.tian@windriver.com>
Date: Thu, 11 Nov 2010 15:30:52 +0800
Subject: [PATCH 014/132] Cavium: CVMX files updates for SDK 2.0

Source: SDK 2.0.0-366

Some CVMX files in the kernel tree that do not use the common Simple
Exec files were updated.

All code in cvmx-bootinfo.h was removed in favor of a simple inclusion
of cvmx-app-init.h.

There are two copies of cvmx.h: one in the simple exec directory, the
other in the kernel tree. MOST cvmx-* files use the simple exec
copies, but Cavium deemed it necessary to maintain them separately in
this case, so the update of this file can be considered to be part of
the general up-rev to SDK 2.0.

Signed-off-by: ltian <le.tian@windriver.com>
---
 arch/mips/include/asm/octeon/cvmx-bootinfo.h |  245 +-------------------------
 arch/mips/include/asm/octeon/cvmx.h          |  151 +++++++++-------
 2 files changed, 87 insertions(+), 309 deletions(-)

diff --git a/arch/mips/include/asm/octeon/cvmx-bootinfo.h b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
index f3c23a4..9a3e232 100644
--- a/arch/mips/include/asm/octeon/cvmx-bootinfo.h
+++ b/arch/mips/include/asm/octeon/cvmx-bootinfo.h
@@ -29,247 +29,4 @@
  * Header file containing the ABI with the bootloader.
  */
 
-#ifndef __CVMX_BOOTINFO_H__
-#define __CVMX_BOOTINFO_H__
-
-/*
- * Current major and minor versions of the CVMX bootinfo block that is
- * passed from the bootloader to the application.  This is versioned
- * so that applications can properly handle multiple bootloader
- * versions.
- */
-#define CVMX_BOOTINFO_MAJ_VER 1
-#define CVMX_BOOTINFO_MIN_VER 2
-
-#if (CVMX_BOOTINFO_MAJ_VER == 1)
-#define CVMX_BOOTINFO_OCTEON_SERIAL_LEN 20
-/*
- * This structure is populated by the bootloader.  For binary
- * compatibility the only changes that should be made are
- * adding members to the end of the structure, and the minor
- * version should be incremented at that time.
- * If an incompatible change is made, the major version
- * must be incremented, and the minor version should be reset
- * to 0.
- */
-struct cvmx_bootinfo {
-	uint32_t major_version;
-	uint32_t minor_version;
-
-	uint64_t stack_top;
-	uint64_t heap_base;
-	uint64_t heap_end;
-	uint64_t desc_vaddr;
-
-	uint32_t exception_base_addr;
-	uint32_t stack_size;
-	uint32_t flags;
-	uint32_t core_mask;
-	/* DRAM size in megabytes */
-	uint32_t dram_size;
-	/* physical address of free memory descriptor block*/
-	uint32_t phy_mem_desc_addr;
-	/* used to pass flags from app to debugger */
-	uint32_t debugger_flags_base_addr;
-
-	/* CPU clock speed, in hz */
-	uint32_t eclock_hz;
-
-	/* DRAM clock speed, in hz */
-	uint32_t dclock_hz;
-
-	uint32_t reserved0;
-	uint16_t board_type;
-	uint8_t board_rev_major;
-	uint8_t board_rev_minor;
-	uint16_t reserved1;
-	uint8_t reserved2;
-	uint8_t reserved3;
-	char board_serial_number[CVMX_BOOTINFO_OCTEON_SERIAL_LEN];
-	uint8_t mac_addr_base[6];
-	uint8_t mac_addr_count;
-#if (CVMX_BOOTINFO_MIN_VER >= 1)
-	/*
-	 * Several boards support compact flash on the Octeon boot
-	 * bus.  The CF memory spaces may be mapped to different
-	 * addresses on different boards.  These are the physical
-	 * addresses, so care must be taken to use the correct
-	 * XKPHYS/KSEG0 addressing depending on the application's
-	 * ABI.  These values will be 0 if CF is not present.
-	 */
-	uint64_t compact_flash_common_base_addr;
-	uint64_t compact_flash_attribute_base_addr;
-	/*
-	 * Base address of the LED display (as on EBT3000 board)
-	 * This will be 0 if LED display not present.
-	 */
-	uint64_t led_display_base_addr;
-#endif
-#if (CVMX_BOOTINFO_MIN_VER >= 2)
-	/* DFA reference clock in hz (if applicable)*/
-	uint32_t dfa_ref_clock_hz;
-
-	/*
-	 * flags indicating various configuration options.  These
-	 * flags supercede the 'flags' variable and should be used
-	 * instead if available.
-	 */
-	uint32_t config_flags;
-#endif
-
-};
-
-#define CVMX_BOOTINFO_CFG_FLAG_PCI_HOST			(1ull << 0)
-#define CVMX_BOOTINFO_CFG_FLAG_PCI_TARGET		(1ull << 1)
-#define CVMX_BOOTINFO_CFG_FLAG_DEBUG			(1ull << 2)
-#define CVMX_BOOTINFO_CFG_FLAG_NO_MAGIC			(1ull << 3)
-/* This flag is set if the TLB mappings are not contained in the
- * 0x10000000 - 0x20000000 boot bus region. */
-#define CVMX_BOOTINFO_CFG_FLAG_OVERSIZE_TLB_MAPPING     (1ull << 4)
-#define CVMX_BOOTINFO_CFG_FLAG_BREAK			(1ull << 5)
-
-#endif /*   (CVMX_BOOTINFO_MAJ_VER == 1) */
-
-/* Type defines for board and chip types */
-enum cvmx_board_types_enum {
-	CVMX_BOARD_TYPE_NULL = 0,
-	CVMX_BOARD_TYPE_SIM = 1,
-	CVMX_BOARD_TYPE_EBT3000 = 2,
-	CVMX_BOARD_TYPE_KODAMA = 3,
-	CVMX_BOARD_TYPE_NIAGARA = 4,
-	CVMX_BOARD_TYPE_NAC38 = 5,	/* formerly NAO38 */
-	CVMX_BOARD_TYPE_THUNDER = 6,
-	CVMX_BOARD_TYPE_TRANTOR = 7,
-	CVMX_BOARD_TYPE_EBH3000 = 8,
-	CVMX_BOARD_TYPE_EBH3100 = 9,
-	CVMX_BOARD_TYPE_HIKARI = 10,
-	CVMX_BOARD_TYPE_CN3010_EVB_HS5 = 11,
-	CVMX_BOARD_TYPE_CN3005_EVB_HS5 = 12,
-	CVMX_BOARD_TYPE_KBP = 13,
-	/* Deprecated, CVMX_BOARD_TYPE_CN3010_EVB_HS5 supports the CN3020 */
-	CVMX_BOARD_TYPE_CN3020_EVB_HS5 = 14,
-	CVMX_BOARD_TYPE_EBT5800 = 15,
-	CVMX_BOARD_TYPE_NICPRO2 = 16,
-	CVMX_BOARD_TYPE_EBH5600 = 17,
-	CVMX_BOARD_TYPE_EBH5601 = 18,
-	CVMX_BOARD_TYPE_EBH5200 = 19,
-	CVMX_BOARD_TYPE_BBGW_REF = 20,
-	CVMX_BOARD_TYPE_NIC_XLE_4G = 21,
-	CVMX_BOARD_TYPE_EBT5600 = 22,
-	CVMX_BOARD_TYPE_EBH5201 = 23,
-	CVMX_BOARD_TYPE_EBT5200 = 24,
-	CVMX_BOARD_TYPE_CB5600  = 25,
-	CVMX_BOARD_TYPE_CB5601  = 26,
-	CVMX_BOARD_TYPE_CB5200  = 27,
-	/* Special 'generic' board type, supports many boards */
-	CVMX_BOARD_TYPE_GENERIC = 28,
-	CVMX_BOARD_TYPE_EBH5610 = 29,
-	CVMX_BOARD_TYPE_MAX,
-
-	/*
-	 * The range from CVMX_BOARD_TYPE_MAX to
-	 * CVMX_BOARD_TYPE_CUST_DEFINED_MIN is reserved for future
-	 * SDK use.
-	 */
-
-	/*
-	 * Set aside a range for customer boards.  These numbers are managed
-	 * by Cavium.
-	 */
-	CVMX_BOARD_TYPE_CUST_DEFINED_MIN = 10000,
-	CVMX_BOARD_TYPE_CUST_WSX16 = 10001,
-	CVMX_BOARD_TYPE_CUST_NS0216 = 10002,
-	CVMX_BOARD_TYPE_CUST_NB5 = 10003,
-	CVMX_BOARD_TYPE_CUST_WMR500 = 10004,
-	CVMX_BOARD_TYPE_CUST_DEFINED_MAX = 20000,
-
-	/*
-	 * Set aside a range for customer private use.  The SDK won't
-	 * use any numbers in this range.
-	 */
-	CVMX_BOARD_TYPE_CUST_PRIVATE_MIN = 20001,
-	CVMX_BOARD_TYPE_CUST_PRIVATE_MAX = 30000,
-
-	/* The remaining range is reserved for future use. */
-};
-
-enum cvmx_chip_types_enum {
-	CVMX_CHIP_TYPE_NULL = 0,
-	CVMX_CHIP_SIM_TYPE_DEPRECATED = 1,
-	CVMX_CHIP_TYPE_OCTEON_SAMPLE = 2,
-	CVMX_CHIP_TYPE_MAX,
-};
-
-/* Compatability alias for NAC38 name change, planned to be removed
- * from SDK 1.7 */
-#define CVMX_BOARD_TYPE_NAO38	CVMX_BOARD_TYPE_NAC38
-
-/* Functions to return string based on type */
-#define ENUM_BRD_TYPE_CASE(x) \
-	case x: return(#x + 16);	/* Skip CVMX_BOARD_TYPE_ */
-static inline const char *cvmx_board_type_to_string(enum
-						    cvmx_board_types_enum type)
-{
-	switch (type) {
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NULL)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_SIM)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT3000)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_KODAMA)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIAGARA)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NAC38)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_THUNDER)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_TRANTOR)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH3000)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH3100)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_HIKARI)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3010_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3005_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_KBP)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CN3020_EVB_HS5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5800)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NICPRO2)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5601)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_BBGW_REF)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_NIC_XLE_4G)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5201)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBT5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5600)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5601)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CB5200)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_GENERIC)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_EBH5610)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_MAX)
-
-			/* Customer boards listed here */
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_DEFINED_MIN)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_WSX16)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_NS0216)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_NB5)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_WMR500)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_DEFINED_MAX)
-
-		    /* Customer private range */
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MIN)
-		ENUM_BRD_TYPE_CASE(CVMX_BOARD_TYPE_CUST_PRIVATE_MAX)
-	}
-	return "Unsupported Board";
-}
-
-#define ENUM_CHIP_TYPE_CASE(x) \
-	case x: return(#x + 15);	/* Skip CVMX_CHIP_TYPE */
-static inline const char *cvmx_chip_type_to_string(enum
-						   cvmx_chip_types_enum type)
-{
-	switch (type) {
-		ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_NULL)
-		    ENUM_CHIP_TYPE_CASE(CVMX_CHIP_SIM_TYPE_DEPRECATED)
-		    ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_OCTEON_SAMPLE)
-		    ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_MAX)
-	}
-	return "Unsupported Chip";
-}
-
-#endif /* __CVMX_BOOTINFO_H__ */
+#include "cvmx-app-init.h"
diff --git a/arch/mips/include/asm/octeon/cvmx.h b/arch/mips/include/asm/octeon/cvmx.h
index 678eb0a..aac806d 100644
--- a/arch/mips/include/asm/octeon/cvmx.h
+++ b/arch/mips/include/asm/octeon/cvmx.h
@@ -30,29 +30,52 @@
 
 #include <linux/kernel.h>
 #include <linux/string.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
 
-#include "cvmx-asm.h"
-#include "cvmx-packet.h"
-#include "cvmx-sysinfo.h"
+#ifndef CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_ENABLE_CSR_ADDRESS_CHECKING 0
+#endif
 
-#include "cvmx-ciu-defs.h"
-#include "cvmx-gpio-defs.h"
-#include "cvmx-iob-defs.h"
-#include "cvmx-ipd-defs.h"
-#include "cvmx-l2c-defs.h"
-#include "cvmx-l2d-defs.h"
-#include "cvmx-l2t-defs.h"
-#include "cvmx-led-defs.h"
-#include "cvmx-mio-defs.h"
-#include "cvmx-pow-defs.h"
-#include "cvmx-pci-defs.h"
-#include "cvmx-npi-defs.h"
-#include "cvmx-usb-defs.h"
+#ifndef CVMX_ENABLE_PARAMETER_CHECKING
+#define CVMX_ENABLE_PARAMETER_CHECKING 0
+#endif
 
-#include "cvmx-bootinfo.h"
-#include "cvmx-bootmem.h"
-#include "cvmx-l2c.h"
-#include "cvmx-usb.h"
+#ifndef CVMX_ENABLE_POW_CHECKS
+#define CVMX_ENABLE_POW_CHECKS 0
+#endif
+
+#define CVMX_SHARED
+#ifndef __BYTE_ORDER
+# ifdef __BIG_ENDIAN
+#  define __BYTE_ORDER __BIG_ENDIAN
+# else
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
+
+#define cvmx_local_irq_save local_irq_save
+#define cvmx_local_irq_restore local_irq_restore
+
+#define cvmx_safe_printf pr_err
+#define cvmx_warn pr_warning
+#define cvmx_warn_if(p, fmt, ...) ({if (p) pr_warning(pr_fmt(fmt), ##__VA_ARGS__);})
+
+#define cvmx_unlikely unlikely
+#define cvmx_likely likely
+#define CVMX_ENABLE_HELPER_FUNCTIONS 1
+#define CVMX_ENABLE_PKO_FUNCTIONS 1
+/*
+ * Returns processor ID, different Linux and simple exec versions
+ * provided in the cvmx-app-init*.c files.
+ */
+static inline uint32_t cvmx_get_proc_id(void) __attribute__ ((pure));
+static inline uint32_t cvmx_get_proc_id(void)
+{
+       uint32_t id;
+       asm("mfc0 %0, $15,0" : "=r"(id));
+       return id;
+}
 
 #ifndef CVMX_ENABLE_DEBUG_PRINTS
 #define CVMX_ENABLE_DEBUG_PRINTS 1
@@ -60,8 +83,10 @@
 
 #if CVMX_ENABLE_DEBUG_PRINTS
 #define cvmx_dprintf        printk
+#define cvmx_dvprintf       vprintk
 #else
 #define cvmx_dprintf(...)   {}
+#define cvmx_dvprintf(a, b)   {(void)(a);(void)(b);}
 #endif
 
 #define CVMX_MAX_CORES          (16)
@@ -71,18 +96,6 @@
 #define CAST64(v) ((long long)(long)(v))
 #define CASTPTR(type, v) ((type *)(long)(v))
 
-/*
- * Returns processor ID, different Linux and simple exec versions
- * provided in the cvmx-app-init*.c files.
- */
-static inline uint32_t cvmx_get_proc_id(void) __attribute__ ((pure));
-static inline uint32_t cvmx_get_proc_id(void)
-{
-	uint32_t id;
-	asm("mfc0 %0, $15,0" : "=r"(id));
-	return id;
-}
-
 /* turn the variable name into a string */
 #define CVMX_TMP_STR(x) CVMX_TMP_STR2(x)
 #define CVMX_TMP_STR2(x) #x
@@ -132,27 +145,7 @@ static inline uint64_t cvmx_build_bits(uint64_t high_bit,
 {
 	return (value & cvmx_build_mask(high_bit - low_bit + 1)) << low_bit;
 }
-
-enum cvmx_mips_space {
-	CVMX_MIPS_SPACE_XKSEG = 3LL,
-	CVMX_MIPS_SPACE_XKPHYS = 2LL,
-	CVMX_MIPS_SPACE_XSSEG = 1LL,
-	CVMX_MIPS_SPACE_XUSEG = 0LL
-};
-
-/* These macros for use when using 32 bit pointers. */
-#define CVMX_MIPS32_SPACE_KSEG0 1l
-#define CVMX_ADD_SEG32(segment, add) \
-	(((int32_t)segment << 31) | (int32_t)(add))
-
-#define CVMX_IO_SEG CVMX_MIPS_SPACE_XKPHYS
-
-/* These macros simplify the process of creating common IO addresses */
-#define CVMX_ADD_SEG(segment, add) \
-	((((uint64_t)segment) << 62) | (add))
-#ifndef CVMX_ADD_IO_SEG
-#define CVMX_ADD_IO_SEG(add) CVMX_ADD_SEG(CVMX_IO_SEG, (add))
-#endif
+#include "cvmx-address.h"
 
 /**
  * Convert a memory pointer (void*) into a hardware compatable
@@ -264,6 +257,29 @@ CVMX_BUILD_READ64(uint16, "lhu");
 CVMX_BUILD_READ64(uint8, "lbu");
 #define cvmx_read64 cvmx_read64_uint64
 
+static inline uint64_t cvmx_read_csr(uint64_t csr_addr)
+{
+       uint64_t val = cvmx_read64(csr_addr);
+       return val;
+}
+
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#include <asm/octeon/octeon-model.h>
+#endif
+
+#include "cvmx-csr-enums.h"
+
+#include "cvmx-ciu-defs.h"
+#include "cvmx-gpio-defs.h"
+#include "cvmx-iob-defs.h"
+#include "cvmx-ipd-defs.h"
+#include "cvmx-l2c-defs.h"
+#include "cvmx-l2d-defs.h"
+#include "cvmx-l2t-defs.h"
+#include "cvmx-led-defs.h"
+#include "cvmx-mio-defs.h"
+#include "cvmx-pow-defs.h"
+#include "cvmx-rnm-defs.h"
 
 static inline void cvmx_write_csr(uint64_t csr_addr, uint64_t val)
 {
@@ -285,12 +301,13 @@ static inline void cvmx_write_io(uint64_t io_addr, uint64_t val)
 
 }
 
-static inline uint64_t cvmx_read_csr(uint64_t csr_addr)
-{
-	uint64_t val = cvmx_read64(csr_addr);
-	return val;
-}
+#include "cvmx-asm.h"
+#include "cvmx-packet.h"
+#include "cvmx-sysinfo.h"
 
+#include "cvmx-bootinfo.h"
+#include "cvmx-bootmem.h"
+#include "cvmx-l2c.h"
 
 static inline void cvmx_send_single(uint64_t data)
 {
@@ -383,13 +400,14 @@ static inline uint64_t cvmx_get_cycle(void)
  * Wait for the specified number of cycle
  *
  */
-static inline void cvmx_wait(uint64_t cycles)
-{
-	uint64_t done = cvmx_get_cycle() + cycles;
+#define cvmx_wait(c) __delay(c)
 
-	while (cvmx_get_cycle() < done)
-		; /* Spin */
-}
+/**
+ * Wait for the specified number of micro seconds
+ *
+ * @param usec   micro seconds to wait
+ */
+#define cvmx_wait_usec(usec) udelay(usec)
 
 /**
  * Reads a chip global cycle counter.  This counts CPU cycles since
@@ -405,6 +423,7 @@ static inline uint64_t cvmx_get_cycle_global(void)
 	else
 		return cvmx_read64(CVMX_IPD_CLK_COUNT);
 }
+extern uint64_t octeon_get_clock_rate(void);
 
 /**
  * This macro spins on a field waiting for it to reach a value. It
@@ -421,7 +440,7 @@ static inline uint64_t cvmx_get_cycle_global(void)
 	int result;							\
 	do {								\
 		uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec * \
-			cvmx_sysinfo_get()->cpu_clock_hz / 1000000;	\
+			octeon_get_clock_rate() / 1000000;      \
 		type c;							\
 		while (1) {						\
 			c.u64 = cvmx_read_csr(address);			\
@@ -494,6 +513,8 @@ static inline int cvmx_octeon_model_CN36XX(void)
 		&& cvmx_fuse_read(264);
 }
 
+#include "octeon-feature.h"
+
 static inline int cvmx_octeon_zip_present(void)
 {
 	return octeon_has_feature(OCTEON_FEATURE_ZIP);
-- 
1.6.5.2

