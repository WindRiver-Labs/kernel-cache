From b866b7787e1b12ee1817690f4fa96b0f9e2b910a Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 2 Jun 2010 12:43:10 -0700
Subject: [PATCH] WRHV/mpc8572ds: Support SMP

1> Add power.save
2> Support HOT_PLUG
3> Extend swapper_pg_dir space for VMMU
4> Separate WRHV_SPRNS per core to keep thread infor
5> Create VMMU for secondary core

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/include/asm/pv_pgtable-ppc32.h |    3 +-
 arch/powerpc/include/asm/reg_wrhv.h         |   19 ++++++++
 arch/powerpc/include/asm/time.h             |   22 +++++++++
 arch/powerpc/kernel/head_wrhv.S             |   65 +++++++++++++++------------
 arch/powerpc/kernel/smp-tbsync.c            |    7 +++
 arch/powerpc/kernel/smp.c                   |    6 +++
 arch/powerpc/kernel/vbi/wrhv.c              |   27 ++++++++++-
 arch/powerpc/kernel/wrhv_entry_32.S         |   25 ++++------
 arch/powerpc/platforms/85xx/wrhv_8572ds.c   |    1 +
 9 files changed, 128 insertions(+), 47 deletions(-)

diff --git a/arch/powerpc/include/asm/pv_pgtable-ppc32.h b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
index 81c44a1..b8153ea 100644
--- a/arch/powerpc/include/asm/pv_pgtable-ppc32.h
+++ b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
@@ -12,7 +12,8 @@
  */
 /*
  * need extra care for _PAGE_SPECIAL -- Liang Li
- */ #define _PAGE_SPECIAL    0x0
+ */ 
+#define _PAGE_SPECIAL		0x0
 #define _PAGE_PRESENT		VMMU_PROT_SUPV_READ
 #define _PAGE_USER		(VMMU_PROT_USER_READ|VMMU_PROT_USER_EXECUTE)
 #define _PAGE_FILE      	_PAGE_USER
diff --git a/arch/powerpc/include/asm/reg_wrhv.h b/arch/powerpc/include/asm/reg_wrhv.h
index 4d88f9e..805a5c6 100644
--- a/arch/powerpc/include/asm/reg_wrhv.h
+++ b/arch/powerpc/include/asm/reg_wrhv.h
@@ -44,6 +44,24 @@
 .extern	var(wrhv_user)
 .extern var(wrhv_pir)
 
+#ifdef CONFIG_SMP
+/*temporary solution for MFSPRG3,PIR ,wrhv-reserverd:0xf0002068 */
+#define WRHY_SPRG3 (0xF0002000 + VB_CONTROL_RESERVED8)
+/*
+       lis     r24, 0xF0000000@h
+       ori     r24, r24, 0xF0000000@l
+       lwz     r24, WRHV_COREID_OFFSET(r24)
+*/
+#define WRHV_MFSPRG3(rd)	\
+	lis	rd,WRHY_SPRG3@ha;	\
+	lwz	rd,WRHY_SPRG3@l(rd)
+
+#define WRHV_MTSPRG3(rs,tmpr)	\
+	lis	tmpr,WRHY_SPRG3@ha;             \
+	stw	rs,WRHY_SPRG3@l(tmpr)
+
+#else 
+
 #define WRHV_MFSPRG3(rd)                        \
 	lis	rd,wrhv_sprg3@ha;               \
 	lwz	rd,wrhv_sprg3@l(rd)
@@ -51,6 +69,7 @@
 #define WRHV_MTSPRG3(rs,tmpr)                   \
 	lis	tmpr,wrhv_sprg3@ha;             \
 	stw	rs,wrhv_sprg3@l(tmpr)
+#endif
 
 #ifdef CONFIG_SMP
 #define WRHV_MFPIR(rd)				\
diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 27ccb76..e54a65e 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -110,6 +110,9 @@ static inline u64 get_rtc(void)
 	return (u64)hi * 1000000000 + lo;
 }
 
+long long wrhv_gettb_diff(void);
+void wrhv_settb_diff(long long diff);
+
 #ifdef CONFIG_PPC64
 static inline u64 get_tb(void)
 {
@@ -126,7 +129,17 @@ static inline u64 get_tb(void)
 		tbhi2 = get_tbu();
 	} while (tbhi != tbhi2);
 
+#ifndef CONFIG_WRHV
 	return ((u64)tbhi << 32) | tblo;
+#else
+	{
+	int cpuid = smp_processor_id();
+	if(cpuid)
+		return (((u64)tbhi << 32) | tblo) + wrhv_gettb_diff();
+	else
+		return ((u64)tbhi << 32) | tblo;
+	}   
+#endif
 }
 #endif /* !CONFIG_PPC64 */
 
@@ -137,9 +150,16 @@ static inline u64 get_tb_or_rtc(void)
 
 static inline void set_tb(unsigned int upper, unsigned int lower)
 {
+#ifndef CONFIG_WRHV
 	mtspr(SPRN_TBWL, 0);
 	mtspr(SPRN_TBWU, upper);
 	mtspr(SPRN_TBWL, lower);
+#else
+	unsigned long long tb = ((u64)upper<<32) | lower;
+	int cpuid = smp_processor_id();
+	if(cpuid)
+		wrhv_settb_diff((long long)get_tb() - (long long)tb);
+#endif
 }
 
 /* Accessor functions for the decrementer register.
@@ -181,7 +201,9 @@ static inline void set_dec(int val)
 		return;
 	}
 #endif
+#ifndef CONFIG_WRHV
 	mtspr(SPRN_DEC, val);
+#endif
 #endif /* not 40x or 8xx_CPU6 */
 }
 
diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index e3928a1..621ce6a 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -100,18 +100,6 @@ _ENTRY(_start);
  */
 
 _ENTRY(__early_start)
-	/*
-	 * This is where the main kernel code starts.
-	 */
-
-	/* ptr to current */
-	lis	r2,init_task@h
-	ori	r2,r2,init_task@l
-
-	/* ptr to current thread */
-	addi	r4,r2,THREAD	/* init task's THREAD */
-	WRHV_MTSPRG3(r4,r1)
-
 	/* Establish the interrupt vector base */
 	lis	r0,VBI_SYS_hyIoctl@h
 	ori     r0,r0,VBI_SYS_hyIoctl@l
@@ -132,6 +120,14 @@ _ENTRY(__early_start)
 	bne	__secondary_start
 #endif
 
+	/* ptr to current */
+	lis	r2,init_task@h
+	ori	r2,r2,init_task@l
+
+	/* ptr to current thread */
+	addi	r4,r2,THREAD	/* init task's THREAD */
+	WRHV_MTSPRG3(r4,r1)
+
 	/* stack */
 	lis	r1,init_thread_union@h
 	ori	r1,r1,init_thread_union@l
@@ -187,10 +183,22 @@ _ENTRY(__early_start)
 #define LOAD_PTE \
 	lwz	r11, 4(r12);
 
+#ifdef CONFIG_SMP
+#define LWARX_PTE \
+	li	r11, 4;
+	lwarx	r11, r11, r12;		/* lwarx pte */
+
 #define STWCX_PTE \
 	addi	r12, r12, 4;	\
 	stwcx.	r11, 0, r12;	\
 	addi	r12, r12, -4;
+#else
+#define LWARX_PTE \
+	lwz	r11, 4(r12)
+
+#define STWCX_PTE \
+	stw	r11, 4(r12)
+#endif
 
 #else
 #define FIND_PTE	\
@@ -289,7 +297,7 @@ interrupt_base:
         /* find the TLB index that caused the fault. */
         tlbsx   0, r10
 
-	#if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
+#if defined(CONFIG_SMP)
         /*
          * It's possible another processor kicked out the entry
          * before we did our tlbsx, so check if we hit
@@ -313,7 +321,7 @@ interrupt_base:
         mtspr   SPRN_MAS3,r10
         tlbwe
 
-#if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
+#if defined(CONFIG_SMP)
         mr      r13, r11
         LWARX_PTE
         cmpw    r13, r11
@@ -324,7 +332,7 @@ interrupt_base:
         ori     r11, r11, _PAGE_DIRTY|_PAGE_ACCESSED|_PAGE_HWWRITE
         STWCX_PTE       /* r11 and r12 must be PTE and &PTE */
 
-#if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
+#if defined(CONFIG_SMP)
         /*
          * If the stwcx. failed, we invalidate the entry we just wrote,
          * and start over
@@ -355,7 +363,7 @@ interrupt_base:
         rfi                     /* Force context change */
 
 2:
-#if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
+#if defined(CONFIG_SMP)
         /* Clear the reservation */
         lis     r11, dummy_stwcx@h
         ori     r11,r11, dummy_stwcx@l
@@ -486,14 +494,14 @@ finish_tlb_load:
 	 */
 
 	mfspr	r12, SPRN_MAS2
-#ifdef CONFIG_PTE_64BIT
+#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_WRHV)
 	rlwimi	r12, r11, 32-19, 27, 31	/* extract WIMGE from pte */
 #else
 	rlwimi	r12, r11, 26, 27, 31	/* extract WIMGE from pte */
 #endif
 	mtspr	SPRN_MAS2, r12
 
-#ifdef CONFIG_PTE_64BIT
+#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_WRHV)
 	rlwinm	r12, r11, 32-2, 26, 31	/* Move in perm bits */
 	andi.	r10, r11, _PAGE_DIRTY
 	bne	1f
@@ -852,18 +860,10 @@ __secondary_start:
 
 	/* ptr to current thread */
 	addi	r4,r2,THREAD	/* address of our thread_struct */
-	mtspr	SPRN_SPRG_THREAD,r4
+	WRHV_MTSPRG3(r4,r3)
 
 	/* Jump to start_secondary */
-	lis	r4,MSR_KERNEL@h
-	ori	r4,r4,MSR_KERNEL@l
-	lis	r3,wrhv_start_secondary@h
-	ori	r3,r3,wrhv_start_secondary@l
-	mtspr	SPRN_SRR0,r3
-	mtspr	SPRN_SRR1,r4
-	sync
-	rfi
-	sync
+	b	wrhv_start_secondary
 
 	.globl __secondary_hold_acknowledge
 __secondary_hold_acknowledge:
@@ -883,7 +883,14 @@ empty_zero_page:
 	.space	4096
 	.globl	swapper_pg_dir
 swapper_pg_dir:
-	.space	PGD_TABLE_SIZE
+	.space	8192
+/*
+ * We need a place to stwcx. to when we want to clear a reservation
+ * without knowing where the original was.
+ */
+	.globl	dummy_stwcx
+dummy_stwcx:
+	.space	4
 
 /*
  * Room for two PTE pointers, usually the kernel and current user pointers
diff --git a/arch/powerpc/kernel/smp-tbsync.c b/arch/powerpc/kernel/smp-tbsync.c
index 03e45c4..292d94a 100644
--- a/arch/powerpc/kernel/smp-tbsync.c
+++ b/arch/powerpc/kernel/smp-tbsync.c
@@ -126,6 +126,10 @@ void __devinit smp_generic_give_timebase(void)
 
 	pr_debug("Got ack\n");
 
+#ifdef CONFIG_WRHV
+	goto bypass;
+#endif 
+
 	/* binary search */
 	for (old = -1; old != offset ; offset = (min+max) / 2) {
 		score = start_contest(kSetAndTest, offset, NUM_ITER);
@@ -158,6 +162,9 @@ void __devinit smp_generic_give_timebase(void)
 	}
 	pr_debug("Final offset: %d (%d/%d)\n", offset, score2, NUM_ITER );
 
+#ifdef CONFIG_WRHV
+bypass:
+#endif 
 	/* exiting */
 	tbsync->cmd = kExit;
 	wmb();
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index cf7d658..4e3c578 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -50,6 +50,8 @@
 #include <asm/paca.h>
 #endif
 
+#include <asm/wrhv.h>
+
 #ifdef DEBUG
 #include <asm/udbg.h>
 #define DBG(fmt...) udbg_printf(fmt)
@@ -281,6 +283,10 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
  
 	smp_space_timers(max_cpus);
 
+#ifdef CONFIG_WRHV
+	wrhv_umask_IPIs_for_vcore();
+#endif 
+
 	for_each_possible_cpu(cpu)
 		if (cpu != boot_cpuid)
 			smp_create_idle(cpu);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 6686483..29dede1 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1376,6 +1376,18 @@ VBI_HREG_SET_CMPLX_QUALIFIED bootREG;
 #define IPI_IRQ_BASE_NAME "ipi0"
 int irq_base = 0xFFFF; /*init as invalid IRQ number*/
 
+DEFINE_PER_CPU(long long, tb_diff);
+
+long long wrhv_gettb_diff()
+{
+	return __get_cpu_var(tb_diff);
+}
+
+void wrhv_settb_diff(long long diff)
+{
+	 __get_cpu_var(tb_diff) = diff;
+}
+
 static irqreturn_t wrhv_ipi_action(int irq, void *data)
 {
 	long ipi = (long)data;
@@ -1562,6 +1574,14 @@ struct smp_ops_t smp_wrhv_ops = {
 	.setup_cpu = smp_wrhv_setup_cpu,
 };
 
+#if defined(CONFIG_HOTPLUG_CPU)
+void cpu_die(void)
+{
+	if (smp_ops->cpu_die)
+	smp_ops->cpu_die(smp_processor_id());
+}
+#endif
+
 void __init wrhv_smp_init(void)
 {
 	smp_ops = &smp_wrhv_ops;
@@ -1604,12 +1624,15 @@ int __devinit wrhv_start_secondary(void *unused)
 	struct device_node *l2_cache;
 	int i, base;
 
+	local_irq_disable();
+#ifndef CONFIG_PPC85xx_VT_MODE
+	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+#endif
+
 	vbi_set_exc_base((char*)0xC0000000);
 	wrhv_umask_IPIs_for_vcore();
 	vbi_set_exc_offset(&exec_table);
 
-	wrhv_umask_IPIs_for_vcore();
-
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
 
diff --git a/arch/powerpc/kernel/wrhv_entry_32.S b/arch/powerpc/kernel/wrhv_entry_32.S
index 71785ee..cf895a1 100644
--- a/arch/powerpc/kernel/wrhv_entry_32.S
+++ b/arch/powerpc/kernel/wrhv_entry_32.S
@@ -87,30 +87,19 @@ paravirt_transfer_to_handler:
 	beq	2f			/* if from user, fix up THREAD.regs */
 	addi	r11,r1,STACK_FRAME_OVERHEAD
 	stw	r11,PT_REGS(r12)
-#if defined(CONFIG_40x) || defined(CONFIG_BOOKE) && !defined(CONFIG_WRHV)
-	/* Check to see if the dbcr0 register is set up to debug.  Use the
-	   internal debug mode bit to do this. */
-	lwz	r12,THREAD_DBCR0(r12)
-	andis.	r12,r12,DBCR0_IDM@h
-	beq+	3f
-	/* From user and task is ptraced - load up global dbcr0 */
-	li	r12,-1			/* clear all pending debug events */
-	mtspr	SPRN_DBSR,r12
-	lis	r11,global_dbcr0@ha
-	tophys(r11,r11)
-	addi	r11,r11,global_dbcr0@l
+#if 0
+#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
 #ifdef CONFIG_SMP
 	rlwinm	r9,r1,0,0,(31-THREAD_SHIFT)
 	lwz	r9,TI_CPU(r9)
 	slwi	r9,r9,3
 	add	r11,r11,r9
 #endif
-	lwz	r12,0(r11)
-	mtspr	SPRN_DBCR0,r12
 	lwz	r12,4(r11)
 	addi	r12,r12,-1
 	stw	r12,4(r11)
 #endif
+#endif
 	b	3f
 
 2:	/* if from kernel, check interrupted DOZE/NAP mode and
@@ -223,11 +212,15 @@ paravirt_stack_ovf:
 	lis	r9,StackOverflow@ha
 	addi	r9,r9,StackOverflow@l
 	LOAD_MSR_KERNEL(r10,MSR_KERNEL)
+	WRHV_FIX_MSR(r10,r11)
+	b	StackOverflow
+#if 0
 	FIX_SRR1(r10,r12)
 	mtspr	SPRN_SRR0,r9
 	mtspr	SPRN_SRR1,r10
 	SYNC
 	RFI
+#endif
 
 
 	.globl	paravirt_ret_from_syscall
@@ -289,10 +282,11 @@ END_FTR_SECTION_IFSET(CPU_FTR_NEED_PAIRED_STWCX)
 	lwz	r2,GPR2(r1)
 	lwz	r1,GPR1(r1)
 	lis	r0,VBI_SYS_ctx_load@h
+	ori	r0,r0,VBI_SYS_ctx_load@l
 	sc
 
 66:	li	r3,-ENOSYS
-	b	ret_from_syscall
+	b	paravirt_ret_from_syscall
 
 	.globl	paravirt_syscall_exit_work
 paravirt_syscall_exit_work:
@@ -509,6 +503,7 @@ paravirt_restore:
 	lwz	r4,GPR4(r1)
 	lwz	r1,GPR1(r1)
 	lis	r0,VBI_SYS_ctx_load@h
+	ori	r0,r0,VBI_SYS_ctx_load@l
 #endif  /* VMMU */
 	sc
 
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index b9d69c0..2b589d2 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -253,6 +253,7 @@ define_machine(mpc8572_ds) {
 	.set_law_base		= wrhv_set_law_base,
 	.set_law_attr		= wrhv_set_law_attr,
 	.get_law_attr		= wrhv_get_law_attr,
+	.power_save		= wrhv_power_save,
 };
 
 define_machine(p2020_ds) {
-- 
1.6.5.2

