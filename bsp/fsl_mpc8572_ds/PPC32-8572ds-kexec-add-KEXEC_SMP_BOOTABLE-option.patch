From 170978c7e49a4cd71ceb3a8ec38c4a69bfa23b67 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Fri, 21 May 2010 15:26:06 -0400
Subject: [PATCH] PPC32/8572ds/kexec: add KEXEC_SMP_BOOTABLE option

The 8572ds code currently supports two ways of waking up a secondary
CPU. The older uboot is not aware of multiple CPUs and thus leaves
the CPU off and then the kernel starts it; the newer uboot knows
about them and wakes them up and spins them on a tight loop, leaving
the kernel to make them enter the kernel by writing a start address
in the spin loop variable. The kexec-bootable kernel takes an
approach that is similar to the latter, with one more step.

When the secondary CPU goes down in the original kernel, it first
spins in a tight loop in the control code page, which is randomly
allocated, until the copy of the new kernel is done. At that point,
the primary CPU jumps to the new kernel. It then has to bring the
secondary CPU into the second kernel as well since the control code
page has a high chance of being reused by the new kernel before the
primary CPU hits the secondary wakeup code. To achieve this, the
primary CPU writes the address of a new loop in the second kernel
at which the secondary jumps to. When the wakeup code is hit by the
primary, it finally instructs the secondary to run __early_start.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/platforms/85xx/smp.c |   35 +++++++++++++++++++++++++++++++++++
 1 files changed, 35 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index a15f582..7e97722 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -38,6 +38,7 @@ extern void __early_start(void);
 #define NUM_BOOT_ENTRY		8
 #define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u32))
 
+#ifndef CONFIG_KEXEC_POWERPC_SMP_BOOTABLE
 static void __init
 smp_85xx_kick_cpu(int nr)
 {
@@ -94,6 +95,36 @@ smp_85xx_kick_cpu(int nr)
 
 	pr_debug("waited %d msecs for CPU #%d.\n", n, nr);
 }
+#else
+extern u32 kexec_secondary_hold_addr;
+static void __init smp_85xx_kick_cpu(int nr)
+{
+	unsigned long flags;
+	int n = 0;
+
+	WARN_ON (nr < 0 || nr >= NR_CPUS);
+
+	pr_debug("smp_85xx_kick_cpu: kick CPU #%d\n", nr);
+
+	local_irq_save(flags);
+
+	/* a kexec-bootable kernel has its secondary CPU spinning on
+	 * kexec_secondary_hold_addr in the new kernel text/data at this
+	 * point: release it and make it start its true kernel execution,
+	 * at __early_start() */
+
+	kexec_secondary_hold_addr = (u32)__pa(__early_start);
+	mb();
+
+	/* Wait a bit for the CPU to ack. */
+	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
+		mdelay(1);
+
+	local_irq_restore(flags);
+
+	pr_debug("waited %d msecs for CPU #%d.\n", n, nr);
+}
+#endif	/* CONFIG_KEXEC_POWERPC_SMP_BOOTABLE */
 
 static void __init
 smp_85xx_setup_cpu(int cpu_nr)
@@ -101,8 +132,12 @@ smp_85xx_setup_cpu(int cpu_nr)
 	mpic_setup_this_cpu();
 }
 
+extern void default_kexec_stop_cpus(void *arg);
 struct smp_ops_t smp_85xx_ops = {
 	.kick_cpu = smp_85xx_kick_cpu,
+#ifdef CONFIG_KEXEC
+	.kexec_stop_cpus = default_kexec_stop_cpus,
+#endif
 };
 
 void __init mpc85xx_smp_init(void)
-- 
1.6.5.2

