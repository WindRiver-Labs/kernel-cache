From c6192f6944c5fd47dfffe21ecf0147e923b65cd8 Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Wed, 12 Jan 2011 19:54:02 +0800
Subject: [PATCH 1/2] wrhv/8572ds: add i8259 cascaded irq chip

We need the i8259 irq chip in uli1575 southbridge chip
to handle interrupts for SATA/PATA/USB/legacy devices.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/powerpc/platforms/85xx/Kconfig       |    1 +
 arch/powerpc/platforms/85xx/wrhv_8572ds.c |   49 +++++++++++++++++++++++++++++
 2 files changed, 50 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 687f1ef..4ab84be 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -211,6 +211,7 @@ config WRHV_8572
 	select DEFAULT_UIMAGE
 	select WRHV_E500
 	select PARAVIRT_PTE
+	select PPC_I8259
 	help
 	  This option enables support for the Freescale 8572 DS board
 	  on the Wind River Hypervisor.
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index 52bf014..2add723 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -36,6 +36,7 @@
 #include <sysdev/fsl_soc.h>
 #include <sysdev/fsl_pci.h>
 
+#include <linux/wrhv.h>
 #include <asm/wrhv.h>
 #include <vbi/vbi.h>
 
@@ -55,9 +56,57 @@ extern int wrhv_get_law_attr(int index);
 #define DBG(fmt, args...)
 #endif
 
+#ifdef CONFIG_PPC_I8259
+static void mpc85xx_8259_cascade(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int cascade_irq = i8259_irq();
+
+	if (cascade_irq != NO_IRQ) {
+		generic_handle_irq(cascade_irq);
+	}
+
+	desc->chip->eoi(irq);
+}
+
+static void wrhv_init_ppc_8259(void)
+{
+	struct device_node *np = NULL;
+	struct device_node *cascade_node = NULL;
+	int cascade_irq;
+
+	/* Initialize the i8259 controller */
+	for_each_node_by_type(np, "interrupt-controller")
+		if (of_device_is_compatible(np, "chrp,iic")) {
+			cascade_node = np;
+			break;
+		}
+
+	if (cascade_node == NULL) {
+		printk(KERN_DEBUG "Could not find i8259 PIC\n");
+		return;
+	}
+
+	cascade_irq = irq_of_parse_and_map(cascade_node, 0);
+	if (cascade_irq == NO_IRQ) {
+		printk(KERN_ERR "Failed to map cascade interrupt\n");
+		return;
+	}
+
+	DBG("mpc85xxds: cascade mapped to irq %d\n", cascade_irq);
+
+	i8259_init(cascade_node, 0);
+	of_node_put(cascade_node);
+
+	set_irq_chained_handler(cascade_irq, mpc85xx_8259_cascade);
+}
+#endif	/* CONFIG_PPC_I8259 */
+
 static void __init wrhv_mpc85xx_pic_init(void)
 {
 	wrhv_init_irq();
+#ifdef CONFIG_PPC_I8259
+	wrhv_init_ppc_8259();
+#endif
 }
 
 #ifdef CONFIG_PCI
-- 
1.6.5.2

