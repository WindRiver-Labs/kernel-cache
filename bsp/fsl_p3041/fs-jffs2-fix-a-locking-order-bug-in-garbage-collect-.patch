From 34e9d8a01dc40ae6448c777ec239acae96848dae Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Tue, 26 Nov 2013 13:41:00 +0800
Subject: [PATCH] fs/jffs2: fix a locking order bug in garbage collect path

Under certain workload the following crash can be observed on jffs2,
the reason is that the commit "jffs2: Fix lock acquisition order bug
in jffs2_write_begin" introduces a incorrect locking order bug in
jffs2_read and jffs2_garbage_collect path, this patch fixes this bug
by reverting the above commit and changing lock_page to trylock_page
to avoid the dead lock in garbage collect pass.

The idea is from "http://patchwork.ozlabs.org/patch/269823".

INFO: task jffs2_gcd_mtd12:493 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c4abfc90] [c0007bf0] __switch_to+0x64/0xd0
[c4abfca0] [c058f518] schedule+0x258/0x638
[c4abfd20] [c058f954] io_schedule+0x5c/0x90
[c4abfd30] [c00bde60] sync_page+0x54/0x74
[c4abfd40] [c058fec8] __wait_on_bit_lock+0x9c/0x108
[c4abfd70] [c00bddd8] __lock_page+0x88/0x98
[c4abfda0] [c00be810] do_read_cache_page+0x188/0x1a4
[c4abfde0] [e16d8514] jffs2_gc_fetch_page+0x30/0xac [jffs2]
[c4abfdf0] [e16d5ab0] jffs2_garbage_collect_live+0x4c0/0xec4 [jffs2]
[c4abfea0] [e16d6aa8] jffs2_garbage_collect_pass+0x5f4/0x738 [jffs2]
[c4abff00] [e16d8374] jffs2_garbage_collect_thread+0x188/0x1a0 [jffs2]
[c4abffb0] [c00665c4] kthread+0x78/0x7c
[c4abfff0] [c000fae4] original_kernel_thread+0x4c/0x68
INFO: task mytest:1237 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
Call Trace:
[c43e7ba0] [c0007bf0] __switch_to+0x64/0xd0
[c43e7bb0] [c058f518] schedule+0x258/0x638
[c43e7c30] [c059039c] __mutex_lock_slowpath+0x174/0x230
[c43e7c80] [c05904a8] mutex_lock+0x50/0x54
[c43e7c90] [e16cdeac] jffs2_write_begin+0xf0/0x2d4 [jffs2]
[c43e7d10] [c00bd260] generic_file_buffered_write+0x1b4/0x290
[c43e7da0] [c00bf70c] __generic_file_aio_write+0x33c/0x508
[c43e7e10] [c00bf948] generic_file_aio_write+0x70/0xf0
[c43e7e40] [c00fefec] do_sync_write+0xac/0x120
[c43e7ee0] [c00ffcbc] vfs_write+0xb4/0x158
[c43e7f00] [c00ffed4] sys_write+0x50/0x10c
[c43e7f40] [c000fdcc] ret_from_syscall+0x0/0x4

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 fs/jffs2/fs.c           |    5 +++--
 fs/jffs2/gc.c           |    8 +++++++-
 include/linux/pagemap.h |    3 +++
 mm/filemap.c            |   41 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 54 insertions(+), 3 deletions(-)

diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 7adcc72..207a076 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -646,8 +646,9 @@ unsigned char *jffs2_gc_fetch_page(struct jffs2_sb_info *c,
 	struct inode *inode = OFNI_EDONI_2SFFJ(f);
 	struct page *pg;
 
-	pg = read_cache_page_async(inode->i_mapping, offset >> PAGE_CACHE_SHIFT,
-			     (void *)jffs2_do_readpage_unlock, inode);
+	pg = read_cache_page_async_nowait(inode->i_mapping,
+				 offset >> PAGE_CACHE_SHIFT,
+			     	(void *)jffs2_do_readpage_unlock, inode);
 	if (IS_ERR(pg))
 		return (void *)pg;
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 1875e57..b25171f 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -428,6 +428,9 @@ int jffs2_garbage_collect_pass(struct jffs2_sb_info *c)
 	ret = jffs2_garbage_collect_live(c, jeb, raw, f);
 
 	jffs2_gc_release_inode(c, f);
+	
+	if (!ret)
+		goto release_sem;
 
  test_gcnode:
 	if (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {
@@ -1256,7 +1259,10 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 
 	if (IS_ERR(pg_ptr)) {
 		printk(KERN_WARNING "read_cache_page() returned error: %ld\n", PTR_ERR(pg_ptr));
-		return PTR_ERR(pg_ptr);
+		if (PTR_ERR(pg_ptr) == -EBUSY)
+			 return 0;
+		else
+			return PTR_ERR(pg_ptr);
 	}
 
 	offset = start;
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index a547d96..85cb3c5 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -251,6 +251,9 @@ extern struct page * grab_cache_page_nowait(struct address_space *mapping,
 extern struct page * read_cache_page_async(struct address_space *mapping,
 				pgoff_t index, filler_t *filler,
 				void *data);
+extern struct page * read_cache_page_async_nowait(struct address_space *mapping,
+				pgoff_t index, filler_t *filler,
+				void *data);
 extern struct page * read_cache_page(struct address_space *mapping,
 				pgoff_t index, filler_t *filler,
 				void *data);
diff --git a/mm/filemap.c b/mm/filemap.c
index 7f6087f..5dfbd2e 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1744,6 +1744,47 @@ struct page *read_cache_page_async(struct address_space *mapping,
 }
 EXPORT_SYMBOL(read_cache_page_async);
 
+struct page *read_cache_page_async_nowait(struct address_space *mapping,
+                                pgoff_t index,
+                                int (*filler)(void *,struct page*),
+                                void *data)
+
+{
+        struct page *page;
+        int err;
+
+retry:
+        page = __read_cache_page(mapping, index, filler, data, mapping_gfp_mask(mapping));
+        if (IS_ERR(page))
+                return page;
+        if (PageUptodate(page))
+                goto out;
+
+        if (!trylock_page(page)) {
+                page_cache_release(page);
+		return ERR_PTR(-EBUSY);
+	}
+
+        if (!page->mapping) {
+                unlock_page(page);
+                page_cache_release(page);
+                goto retry;
+        }
+        if (PageUptodate(page)) {
+                unlock_page(page);
+                goto out;
+        }
+        err = filler(data, page);
+        if (err < 0) {
+                page_cache_release(page);
+                return ERR_PTR(err);
+        }
+out:
+        mark_page_accessed(page);
+        return page;
+}
+EXPORT_SYMBOL(read_cache_page_async_nowait);
+
 static struct page *wait_on_page_read(struct page *page)
 {
 	if (!IS_ERR(page)) {
-- 
1.7.0

