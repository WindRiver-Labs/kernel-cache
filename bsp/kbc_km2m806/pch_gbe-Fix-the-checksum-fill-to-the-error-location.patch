From a70506e79aa59d9d3f3b63192e48969734615077 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 9 Apr 2012 10:51:28 +0800
Subject: [PATCH 16/16] pch_gbe: Fix the checksum fill to the error location

Due to some unknown hardware limitations the pch_gbe hardware cannot
calculate checksums when the length of network package is less
than 64 bytes, where we will surprisingly encounter a problem of
the destination IP incorrectly changed.

When forwarding network packages at the network layer the IP packages
won't be relayed to the upper transport layer and analyzed there,
consequently, skb->transport_header pointer will be mistakenly remained
the same as that of skb->network_header, resulting in TCP checksum wrongly
filled into the field of destination IP in IP header.

We can fix this issue by manually calculate the offset of the TCP checksum
 and update it accordingly.

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/pch_gbe/pch_gbe_main.c |   14 ++++++++------
 1 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/drivers/net/pch_gbe/pch_gbe_main.c b/drivers/net/pch_gbe/pch_gbe_main.c
index 170c923..48ff4d7 100644
--- a/drivers/net/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/pch_gbe/pch_gbe_main.c
@@ -2360,32 +2360,34 @@ pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,
   * when the received data size is less than 64 bytes.
   */
  if ((skb->len < PCH_GBE_SHORT_PKT) && (adapter->tx_csum == TRUE)) {
+   struct iphdr *iph = ip_hdr(skb);
   frame_ctrl |=
    PCH_GBE_TXD_CTRL_APAD | PCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;
   if (skb->protocol == htons(ETH_P_IP) && !(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET))) {
-   struct iphdr *iph = ip_hdr(skb);
    unsigned int offset;
+   offset = (unsigned char *)((u8 *)iph + iph->ihl * 4) - skb->data;
    iph->check = 0;
    iph->check = ip_fast_csum((u8 *) iph, iph->ihl);
-   offset = skb_transport_offset(skb);
    if (iph->protocol == IPPROTO_TCP) {
+    struct tcphdr *tcphdr_point = (struct tcphdr *)((u8 *)iph + iph->ihl * 4);
     skb->csum = 0;
-    tcp_hdr(skb)->check = 0;
+    tcphdr_point->check = 0;
     skb->csum =
      skb_checksum(skb, offset,
       skb->len - offset, 0);
-    tcp_hdr(skb)->check =
+    tcphdr_point->check =
      csum_tcpudp_magic(iph->saddr,
        iph->daddr,
        skb->len - offset,
        IPPROTO_TCP, skb->csum);
    } else if (iph->protocol == IPPROTO_UDP && !(ip_hdr(skb)->frag_off & htons(IP_MF | IP_OFFSET))) {
+    struct udphdr *udphdr_point = (struct udphdr *)((u8 *)iph + iph->ihl * 4);
     skb->csum = 0;
-    udp_hdr(skb)->check = 0;
+    udphdr_point->check = 0;
     skb->csum =
      skb_checksum(skb, offset,
       skb->len - offset, 0);
-    udp_hdr(skb)->check =
+    udphdr_point->check =
      csum_tcpudp_magic(iph->saddr,
        iph->daddr,
        skb->len - offset,
-- 
1.7.0

