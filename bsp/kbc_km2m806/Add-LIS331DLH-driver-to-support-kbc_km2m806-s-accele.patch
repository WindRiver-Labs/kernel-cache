From 414a09bf868330a06d4f950c907db19fbe770a94 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 13 Feb 2012 17:09:15 +0800
Subject: [PATCH 08/16] Add LIS331DLH driver to support kbc_km2m806's accelerometer feature

Source: SDK 1.6 for Kontron M2M Smart Services Developer Kit

The LIS331DLH is an ultra low-power high performance three axes linear
accelerometer, with digital I2C/SPI serial interface standard output.

Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
Signed-off-by: Mikhail Vanyulin <mvanyulin@dev.rtsoft.ru>
Integrated-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/staging/iio/Kconfig                |    8 +
 drivers/staging/iio/accel/Kconfig          |   10 +-
 drivers/staging/iio/accel/Makefile         |    5 +-
 drivers/staging/iio/accel/lis331dlh.h      |  178 ++++++
 drivers/staging/iio/accel/lis331dlh_core.c |  867 ++++++++++++++++++++++++++++
 drivers/staging/iio/accel/lis331dlh_ring.c |  319 ++++++++++
 drivers/staging/iio/iio.h                  |    7 +
 drivers/staging/iio/industrialio-core.c    |   57 ++-
 8 files changed, 1448 insertions(+), 3 deletions(-)
 create mode 100644 drivers/staging/iio/accel/lis331dlh.h
 create mode 100644 drivers/staging/iio/accel/lis331dlh_core.c
 create mode 100644 drivers/staging/iio/accel/lis331dlh_ring.c

diff --git a/drivers/staging/iio/Kconfig b/drivers/staging/iio/Kconfig
index ace99f6..901e8d5 100644
--- a/drivers/staging/iio/Kconfig
+++ b/drivers/staging/iio/Kconfig
@@ -38,6 +38,14 @@ config IIO_TRIGGER
 	  ring buffers.  The triggers are effectively a 'capture
 	  data now' interrupt.
 
+config IIO_SIMULATE_INTERRUPTS
+	boolean "Simulate the IIO device interrupt with a periodic timer"
+	default n
+	help
+	  A hack for broken or being under development hardware.
+	  This can help to make a progress in writing the driver while
+	  the hardware is not quite capable of generating the interrupts
+	  properly.
 
 source "drivers/staging/iio/accel/Kconfig"
 source "drivers/staging/iio/adc/Kconfig"
diff --git a/drivers/staging/iio/accel/Kconfig b/drivers/staging/iio/accel/Kconfig
index 3d3c333..63c09bd 100644
--- a/drivers/staging/iio/accel/Kconfig
+++ b/drivers/staging/iio/accel/Kconfig
@@ -20,10 +20,18 @@ config LIS3L02DQ
 	  accelerometer. The driver supplies direct access via sysfs files
 	  and an event interface via a character device.
 
+config LIS331DLH
+	tristate "ST Microelectronics LIS331DLH Accelerometer Driver"
+	depends on I2C
+	help
+	  Say yes here to build I2C support for the ST microelectronics
+	  LIS331DLH accelerometer. The driver supplies direct access via sysfs
+	  files and an event interface via a character device.
+
 config SCA3000
        depends on IIO_RING_BUFFER
        depends on SPI
        tristate "VTI SCA3000 series accelerometers"
        help
          Say yes here to build support for the VTI SCA3000 series of SPI
-	 accelerometers. These devices use a hardware ring buffer.
\ No newline at end of file
+	 accelerometers. These devices use a hardware ring buffer.
diff --git a/drivers/staging/iio/accel/Makefile b/drivers/staging/iio/accel/Makefile
index d5335f9..853276e 100644
--- a/drivers/staging/iio/accel/Makefile
+++ b/drivers/staging/iio/accel/Makefile
@@ -7,5 +7,8 @@ lis3l02dq-y		:= lis3l02dq_core.o
 lis3l02dq-$(CONFIG_IIO_RING_BUFFER) += lis3l02dq_ring.o
 obj-$(CONFIG_LIS3L02DQ)	+= lis3l02dq.o
 
+lis331dlh-y		:= lis331dlh_core.o lis331dlh_ring.o
+obj-$(CONFIG_LIS331DLH)	+= lis331dlh.o
+
 sca3000-y		:= sca3000_core.o sca3000_ring.o
-obj-$(CONFIG_SCA3000)	+= sca3000.o
\ No newline at end of file
+obj-$(CONFIG_SCA3000)	+= sca3000.o
diff --git a/drivers/staging/iio/accel/lis331dlh.h b/drivers/staging/iio/accel/lis331dlh.h
new file mode 100644
index 0000000..d083a1a
--- /dev/null
+++ b/drivers/staging/iio/accel/lis331dlh.h
@@ -0,0 +1,178 @@
+/*
+ * lis331dlh.h support STMicroelectronics LIS331DLH
+ * 3d 2g/4g/8g Linear Accelerometers via I2C
+ *
+ * Based upon lisl02dq.h
+ * Copyright (c) 2007 Jonathan Cameron <jic23@cam.ac.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SPI_LIS331DLH_H_
+#define SPI_LIS331DLH_H_
+
+/* Register definitions */
+
+#define LIS331LDH_ADDR_AUTOINCREMENT	0x80
+
+/* Device identification register */
+#define LIS331LDH_WHO_AM_I_ADDR		0x0F	/* r */
+#define LIS331LDH_WHO_AM_I		0x32
+
+#define LIS331LDH_CTRL1_ADDR		0x20	/* rw */
+/* power mode bits: */
+#define LIS331LDH_CTRL1_PMODE_MASK	0xE0
+#define LIS331LDH_CTRL1_PMODE_DOWN	0x00
+#define LIS331LDH_CTRL1_PMODE_NORMAL	0x20
+#define LIS331LDH_CTRL1_PMODE_LOW_05	0x40	/* ODR.LP = 0.5 Hz*/
+#define LIS331LDH_CTRL1_PMODE_LOW_1	0x60	/* ODR.LP = 1 Hz*/
+#define LIS331LDH_CTRL1_PMODE_LOW_2	0x80	/* ODR.LP = 2 Hz*/
+#define LIS331LDH_CTRL1_PMODE_LOW_5	0xB0	/* ODR.LP = 5 Hz*/
+#define LIS331LDH_CTRL1_PMODE_LOW_10	0xC0	/* ODR.LP = 10 Hz*/
+/* output data rate bits: */
+#define LIS331LDH_CTRL1_DR_MASK		0x18
+#define LIS331LDH_CTRL1_DR_50HZ		0x00
+#define LIS331LDH_CTRL1_DR_100HZ	0x08
+#define LIS331LDH_CTRL1_DR_400HZ	0x10
+#define LIS331LDH_CTRL1_DR_1000HZ	0x18
+/* axis enable bits: */
+#define LIS331LDH_CTRL1_AXES_X_ENABLE	0x01
+#define LIS331LDH_CTRL1_AXES_Y_ENABLE	0x02
+#define LIS331LDH_CTRL1_AXES_Z_ENABLE	0x04
+#define LIS331LDH_CTRL1_AXES_XYZ_ENABLE	0x07
+
+#define LIS331LDH_CTRL2_ADDR		0x21	/* rw */
+#define LIS331LDH_CTRL3_ADDR		0x22	/* rw */
+/* interrupt output configuration bits: */
+#define LIS331LDH_CTRL3_INT_HIGH	0x00	/* active high output */
+#define LIS331LDH_CTRL3_INT_LOW		0x80	/* active low output */
+#define LIS331LDH_CTRL3_PUSHPULL	0x00	/* push-pull output */
+#define LIS331LDH_CTRL3_OPENDRAIN	0x40	/* open drain output */
+#define LIS331LDH_CTRL3_INT2_LATCH	0x20	/* INT2_SRC is cleared by reading it */
+#define LIS331LDH_CTRL3_INT2_CFG	0x18	/* mask for I2_CFG bits */
+#define LIS331LDH_CTRL3_2_SINGLE_SRC	0x00	/* INT2 follows INT2_SRC */
+#define LIS331LDH_CTRL3_2_BOTH_SRCS	0x08	/* INT2 follows INT1_SRC and INT2_SRC */
+#define LIS331LDH_CTRL3_2_DATA_READY	0x10	/* INT2 follows Data Ready */
+#define LIS331LDH_CTRL3_2_BOOT_RUNNING	0x18	/* INT2 is active on boot */
+#define LIS331LDH_CTRL3_INT1_LATCH	0x04	/* INT1_SRC is cleared by reading it */
+#define LIS331LDH_CTRL3_INT1_CFG	0x03	/* mask for I1_CFG bits */
+#define LIS331LDH_CTRL3_1_SINGLE_SRC	0x00	/* INT1 follows INT1_SRC */
+#define LIS331LDH_CTRL3_1_BOTH_SRCS	0x01	/* INT1 follows INT1_SRC and INT2_SRC */
+#define LIS331LDH_CTRL3_1_DATA_READY	0x02	/* INT1 follows Data Ready */
+#define LIS331LDH_CTRL3_1_BOOT_RUNNING	0x03	/* INT1 is active on boot */
+
+
+#define LIS331LDH_CTRL4_ADDR		0x23	/* rw */
+/* full scale selection bits: */
+#define LIS331LDH_CTRL4_FS_MASK		0x30
+#define LIS331LDH_CTRL4_FS_2G		0x00
+#define LIS331LDH_CTRL4_FS_4G		0x10
+#define LIS331LDH_CTRL4_FS_8G		0x30
+
+#define LIS331LDH_CTRL5_ADDR		0x24	/* rw */
+
+#define LIS331LDH_HP_FILTER_RST_ADDR	0x25	/* r */
+
+#define LIS331LDH_REFERENCE_REG		0x26	/* rw */
+
+#define LIS331LDH_STATUS_REG		0x27	/* r */
+#define LIS331LDH_STATUS_ZYXDA		0x08
+
+#define LIS331LDH_OUT_X_L_REG		0x28	/* r */
+#define LIS331LDH_OUT_X_H_REG		0x29	/* r */
+#define LIS331LDH_OUT_Y_L_REG		0x2A	/* r */
+#define LIS331LDH_OUT_Y_H_REG		0x2B	/* r */
+#define LIS331LDH_OUT_Z_L_REG		0x2C	/* r */
+#define LIS331LDH_OUT_Z_H_REG		0x2D	/* r */
+
+#define LIS331LDH_INT1_CFG_REG		0x30	/* rw */
+#define LIS331LDH_INT1_SOURCE_REG	0x31	/* r */
+#define LIS331LDH_INT1_THS_REG		0x32	/* rw */
+#define LIS331LDH_INT1_DURATION_REG	0x33	/* rw */
+
+#define LIS331LDH_INT2_CFG_REG		0x34	/* rw */
+#define LIS331LDH_INT2_SOURCE_REG	0x35	/* r */
+#define LIS331LDH_INT2_THS_REG		0x36	/* rw */
+#define LIS331LDH_INT2_DURATION_REG	0x37	/* rw */
+
+#define LIS331LDH_INT_SRC_ZH		0x20
+#define LIS331LDH_INT_SRC_ZL		0x10
+#define LIS331LDH_INT_SRC_YH		0x08
+#define LIS331LDH_INT_SRC_YL		0x04
+#define LIS331LDH_INT_SRC_XH		0x02
+#define LIS331LDH_INT_SRC_XL		0x01
+#define LIS331LDH_INT_SRC_FREE_FALL	(LIS331LDH_INT_SRC_ZL \
+					| LIS331LDH_INT_SRC_YL \
+					| LIS331LDH_INT_SRC_XL)
+
+#define LIS331LDH_INT_CFG_AND		0x80 /* do AND on the enabled sources */
+#define LIS331LDH_INT_CFG_ZH		0x20
+#define LIS331LDH_INT_CFG_ZL		0x10
+#define LIS331LDH_INT_CFG_YH		0x08
+#define LIS331LDH_INT_CFG_YL		0x04
+#define LIS331LDH_INT_CFG_XH		0x02
+#define LIS331LDH_INT_CFG_XL		0x01
+#define LIS331LDH_INT_CFG_FREE_FALL	(LIS331LDH_INT_CFG_AND \
+					| LIS331LDH_INT_CFG_ZL \
+					| LIS331LDH_INT_CFG_YL \
+					| LIS331LDH_INT_CFG_XL)
+
+/*
+ * INT2 pad is used for the Data Ready and the motion interrupts.
+ * Active low.
+ * When no acceleration data are being read, INT2 follows the sources
+ * enabled in the INT2_CFG (LIS331LDH_CTRL3_2_SINGLE_SRC is used).
+ * When the acceleration data are being read, INT2 is configured as
+ * Data Ready output. This way we won't miss any INT2_SRC events, as their
+ * update rate is not higher than the data sampling rate.
+ */
+#define LIS331LDH_CTRL3_INT_CFG		LIS331LDH_CTRL3_INT2_CFG
+#define LIS331LDH_CTRL3_DATA_READY	LIS331LDH_CTRL3_2_DATA_READY
+#define LIS331LDH_CTRL3_SINGLE_SRC	LIS331LDH_CTRL3_2_SINGLE_SRC
+#define LIS331LDH_INT_CFG_REG		LIS331LDH_INT2_CFG_REG
+#define LIS331LDH_INT_SOURCE_REG	LIS331LDH_INT2_SOURCE_REG
+#define LIS331LDH_INT_THS_REG		LIS331LDH_INT2_THS_REG
+#define LIS331LDH_INT_DURATION_REG	LIS331LDH_INT2_DURATION_REG
+/*
+ * INT1 pad is disabled: it is set up as open drain output,
+ * follows the INT1_SRC, and all interrupt sources in INT1_CFG register
+ * are kept disabled.
+ */
+
+struct lis331dlh_data {
+	__s64	timestamp;
+	u8	data[7];	/* status, x.l, x.h, y.l, y.h, z.l, z.h */
+};
+
+struct lis331dlh_state {
+	struct iio_dev			*indio_dev;
+	struct i2c_client		*client;
+	struct iio_work_cont		work_cont_thresh;
+	bool				inter;
+	s64				last_timestamp;
+	struct work_struct		work_trigger_to_ring;
+	struct iio_trigger		*trig;
+};
+
+#define IIO_DEV_ATTR_ACCEL_FULL_SCALE(_mode, _show, _store)	\
+	IIO_DEVICE_ATTR(accel_full_scale, _mode, _show, _store, 0)
+
+#define IIO_CONST_ATTR_AVAIL_FULL_SCALE(_string)	\
+	IIO_CONST_ATTR(available_full_scale, _string)
+
+
+int lis331dlh_i2c_read_reg8(struct i2c_client *client, u8 reg);
+int lis331dlh_i2c_write_reg8(struct i2c_client *client, u8 reg, u8 value);
+
+int lis331dlh_configure_ring(struct iio_dev *indio_dev);
+void lis331dlh_unconfigure_ring(struct iio_dev *indio_dev);
+
+int lis331dlh_initialize_ring(struct iio_ring_buffer *ring);
+void lis331dlh_uninitialize_ring(struct iio_ring_buffer *ring);
+
+int lis331dlh_probe_trigger(struct iio_dev *indio_dev);
+void lis331dlh_remove_trigger(struct iio_dev *indio_dev);
+
+#endif /* #ifndef SPI_LIS331DLH_H_ */
diff --git a/drivers/staging/iio/accel/lis331dlh_core.c b/drivers/staging/iio/accel/lis331dlh_core.c
new file mode 100644
index 0000000..6fd107c
--- /dev/null
+++ b/drivers/staging/iio/accel/lis331dlh_core.c
@@ -0,0 +1,867 @@
+/*
+ * lis331dlh_core.c  support STMicroelectronics LIS331DLH
+ *              3d 2g/4g/8g Linear Accelerometers via I2C
+ *
+ * Copyright (c) 2011 Kontron???
+ *
+ * based on linux/drivers/industrialio/adc/max1363.c
+ * Copyright (C) 2008 Jonathan Cameron
+ *
+ * based on linux/drivers/industrialio/accel/lis3l02dq_core.c
+ * Copyright (c) 2007 Jonathan Cameron <jic23@cam.ac.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include "../iio.h"
+#include "../sysfs.h"
+#include "accel.h"
+
+#include "lis331dlh.h"
+
+#define LIS331DLH_IRQ	(32+10)	/* TBD */
+
+/* Addresses to scan */
+static const unsigned short lis331dlh_normal_i2c[] = { 0x18, I2C_CLIENT_END };
+
+int lis331dlh_i2c_read_reg8(struct i2c_client *client, u8 reg)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0)
+		dev_warn(&client->dev, "lis331dlh: read byte data failed, "
+			 "address 0x%02x.\n", reg);
+	return ret;
+}
+
+int lis331dlh_i2c_write_reg8(struct i2c_client *client, u8 reg, u8 value)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, value);
+
+	if (ret < 0)
+		dev_warn(&client->dev, "lis331dlh: write byte data failed, "
+			 "0x%02x at address 0x%02x.\n", value, reg);
+
+	return ret;
+}
+
+static ssize_t lis331dlh_read_frequency(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	int ret;
+
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_CTRL1_ADDR);
+	printk(KERN_ERR "LIS331LDH_CTRL1 = 0x%02X\n", ret);
+	if (ret < 0)
+		return ret;
+
+	switch (ret & LIS331LDH_CTRL1_DR_MASK) {
+	case LIS331LDH_CTRL1_DR_50HZ:
+		ret = sprintf(buf, "50\n");
+		break;
+	case LIS331LDH_CTRL1_DR_100HZ:
+		ret = sprintf(buf, "100\n");
+		break;
+	case LIS331LDH_CTRL1_DR_400HZ:
+		ret = sprintf(buf, "400\n");
+		break;
+	case LIS331LDH_CTRL1_DR_1000HZ:
+		ret = sprintf(buf, "1000\n");
+		break;
+	default:
+		ret = 0;
+	}
+	return ret;
+}
+
+static ssize_t lis331dlh_write_frequency(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	long val;
+	int ret;
+
+	ret = strict_strtol(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	mutex_lock(&indio_dev->mlock);
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_CTRL1_ADDR);
+	if (ret < 0)
+		goto error;
+	/* Wipe the bits clean */
+	ret &= ~LIS331LDH_CTRL1_DR_MASK;
+	switch (val) {
+	case 50:
+		ret |= LIS331LDH_CTRL1_DR_50HZ;
+		break;
+	case 100:
+		ret |= LIS331LDH_CTRL1_DR_100HZ;
+		break;
+	case 400:
+		ret |= LIS331LDH_CTRL1_DR_400HZ;
+		break;
+	case 1000:
+		ret |= LIS331LDH_CTRL1_DR_1000HZ;
+		break;
+	default:
+		ret = -EINVAL;
+		goto error;
+	};
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL1_ADDR, ret);
+
+error:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret ? ret : len;
+}
+
+static ssize_t lis331dlh_read_fscale(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	int ret;
+
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_CTRL4_ADDR);
+	printk(KERN_ERR "LIS331LDH_CTRL4 = 0x%02X\n", ret);
+	if (ret < 0)
+		return ret;
+
+	switch (ret & LIS331LDH_CTRL4_FS_MASK) {
+	case LIS331LDH_CTRL4_FS_2G:
+		ret = sprintf(buf, "2\n");
+		break;
+	case LIS331LDH_CTRL4_FS_4G:
+		ret = sprintf(buf, "4\n");
+		break;
+	case LIS331LDH_CTRL4_FS_8G:
+		ret = sprintf(buf, "8\n");
+		break;
+	default:
+		ret = 0;
+	}
+	return ret;
+}
+
+static ssize_t lis331dlh_write_fscale(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t len)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	long val;
+	int ret;
+
+	ret = strict_strtol(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	mutex_lock(&indio_dev->mlock);
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_CTRL4_ADDR);
+	if (ret < 0)
+		goto error;
+	/* Wipe the bits clean */
+	ret &= ~LIS331LDH_CTRL4_FS_MASK;
+	switch (val) {
+	case 2:
+		ret |= LIS331LDH_CTRL4_FS_2G;
+		break;
+	case 4:
+		ret |= LIS331LDH_CTRL4_FS_4G;
+		break;
+	case 8:
+		ret |= LIS331LDH_CTRL4_FS_8G;
+		break;
+	default:
+		ret = -EINVAL;
+		goto error;
+	};
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL4_ADDR, ret);
+
+error:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret ? ret : len;
+}
+
+
+/* read status reg and all the OUT regs */
+static ssize_t lis331dlh_read_accel_xyz(struct lis331dlh_state *st,
+					char *buf)
+{
+	ssize_t ret;
+	unsigned char data[7];
+
+	ret = i2c_smbus_read_i2c_block_data(st->client,
+			LIS331LDH_STATUS_REG | LIS331LDH_ADDR_AUTOINCREMENT,
+			7, data);
+	if (ret < 0) {
+		dev_warn(&st->client->dev,
+			 "lis331dlh: read_accel_xyz failed with %d\n", ret);
+		return ret;
+	}
+
+	ret = i2c_smbus_read_byte_data(st->client, LIS331LDH_STATUS_REG);
+	if (ret < 0) {
+		dev_warn(&st->client->dev,
+			 "lis331dlh: read_accel_xyz2 failed with %d\n", ret);
+		return ret;
+	}
+	return sprintf(buf, "0x%02x %d %d %d 0x%02x\n", /* "STATUS OUT_X OUT_Y OUT_Z NEW_STATUS" */
+		       data[0],
+		       (s16)(data[1]) | (s16)(data[2] << 8),
+		       (s16)(data[3]) | (s16)(data[4] << 8),
+		       (s16)(data[5]) | (s16)(data[6] << 8),
+		       (unsigned char)ret);
+}
+
+/* read one of the OUT regs */
+static ssize_t lis331dlh_read_accel_one(struct lis331dlh_state *st,
+					int addr,
+					char *buf)
+{
+	ssize_t ret;
+
+	ret = i2c_smbus_read_word_data(st->client,
+				       addr | LIS331LDH_ADDR_AUTOINCREMENT);
+	if (ret < 0) {
+		dev_warn(&st->client->dev,
+			 "lis331dlh: read_accel_one failed with %d\n", ret);
+		return ret;
+	}
+
+	return sprintf(buf, "%d\n", (s16)ret);
+}
+
+/* This (cat /sys/class/iio/device0/accel_*) doesn't work in
+ * INDIO_RING_TRIGGERED mode. There is little sense to use the ring buffer
+ * this way. Please use the character device to read for ring buffered reads
+ */
+static ssize_t lis331dlh_read_accel(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	ssize_t ret;
+
+	/* Take the iio_dev status lock */
+	mutex_lock(&indio_dev->mlock);
+	if (indio_dev->currentmode == INDIO_RING_TRIGGERED) {
+		ret = -EINVAL;
+	} else {
+		if (this_attr->address == LIS331LDH_STATUS_REG)
+			ret = lis331dlh_read_accel_xyz(st, buf);
+		else
+			ret = lis331dlh_read_accel_one(st, this_attr->address,
+						       buf);
+	}
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+/* some data to print via lis331dlh_debug_read */
+long lis331dlh_interrupt_count = 0;
+static long lis331dlh_bh_count;
+static int lis331dlh_zh_cnt;
+static int lis331dlh_zl_cnt;
+static int lis331dlh_yh_cnt;
+static int lis331dlh_yl_cnt;
+static int lis331dlh_xh_cnt;
+static int lis331dlh_xl_cnt;
+static int lis331dlh_free_fall_cnt;
+unsigned int lis331dlh_int_cfg_copy = 0x100;
+
+
+static ssize_t lis331dlh_debug_read(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	ssize_t ret;
+
+	ret = sprintf(buf, "interrupts / bhs: %ld / %ld\n"
+			   "ZH ZL YH YL XH XL FF counts: %d %d %d %d %d %d %d\n"
+			   "INT_CFG = 0x%03X\n",
+			   lis331dlh_interrupt_count, lis331dlh_bh_count,
+			   lis331dlh_zh_cnt, lis331dlh_zl_cnt,
+			   lis331dlh_yh_cnt, lis331dlh_yl_cnt,
+			   lis331dlh_xh_cnt, lis331dlh_xl_cnt,
+			   lis331dlh_free_fall_cnt,
+			   lis331dlh_int_cfg_copy);
+
+	return ret;
+}
+
+static ssize_t lis331dlh_debug_write(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf,
+				     size_t len)
+{
+	return len;
+}
+
+static IIO_DEVICE_ATTR(debug, S_IRUGO | S_IWUSR,
+		       lis331dlh_debug_read, lis331dlh_debug_write, 0);
+
+static ssize_t lis331dlh_read_threshold(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	ssize_t ret;
+
+	ret = lis331dlh_i2c_read_reg8(st->client, this_attr->address);
+	return ret < 0 ? 0 : sprintf(buf, "%d\n", ret);
+}
+
+static ssize_t lis331dlh_write_threshold(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	long val;
+	int ret;
+
+	ret = strict_strtol(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	mutex_lock(&indio_dev->mlock);
+	ret = lis331dlh_i2c_write_reg8(st->client, this_attr->address, (u8)val);
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret ? ret : len;
+}
+
+static IIO_DEV_ATTR_ACCEL_THRESH(S_IWUSR | S_IRUGO,
+				 lis331dlh_read_threshold,
+				 lis331dlh_write_threshold,
+				 LIS331LDH_INT_THS_REG);
+
+#define IIO_DEV_ATTR_ACCEL_XYZ(_show, _addr)			\
+	IIO_DEVICE_ATTR(accel_xyz, S_IRUGO, _show, NULL, _addr)
+static IIO_DEV_ATTR_ACCEL_XYZ(lis331dlh_read_accel,
+			    LIS331LDH_STATUS_REG);
+
+static IIO_DEV_ATTR_ACCEL_X(lis331dlh_read_accel,
+			    LIS331LDH_OUT_X_L_REG);
+
+static IIO_DEV_ATTR_ACCEL_Y(lis331dlh_read_accel,
+			    LIS331LDH_OUT_Y_L_REG);
+
+static IIO_DEV_ATTR_ACCEL_Z(lis331dlh_read_accel,
+			    LIS331LDH_OUT_Z_L_REG);
+
+static IIO_DEV_ATTR_SAMP_FREQ(S_IWUSR | S_IRUGO,
+			      lis331dlh_read_frequency,
+			      lis331dlh_write_frequency);
+
+static IIO_CONST_ATTR_AVAIL_SAMP_FREQ("50 100 400 1000");
+
+static IIO_DEV_ATTR_ACCEL_FULL_SCALE(S_IWUSR | S_IRUGO,
+				     lis331dlh_read_fscale,
+				     lis331dlh_write_fscale);
+
+static IIO_CONST_ATTR_AVAIL_FULL_SCALE("2 4 8");
+
+static ssize_t lis331dlh_read_interrupt_config(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_event_attr *this_attr = to_iio_event_attr(attr);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	int ret;
+
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_INT_CFG_REG);
+	if (ret < 0)
+		return ret;
+	lis331dlh_int_cfg_copy = (unsigned char)ret;
+
+	if (this_attr->mask == LIS331LDH_INT_CFG_FREE_FALL) {
+		return sprintf (buf, "%d\n",
+				(ret == LIS331LDH_INT_CFG_FREE_FALL) ? 1 : 0);
+	} else {
+		return sprintf (buf, "%d\n",
+				(ret & this_attr->mask)
+				&& !(ret & LIS331LDH_INT_CFG_AND) ? 1 : 0);
+	}
+}
+
+static ssize_t lis331dlh_write_interrupt_config(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf,
+						size_t len)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_event_attr *this_attr = to_iio_event_attr(attr);
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+	int oldcfg;
+	int do_set = (buf[0] != '0');
+
+	mutex_lock(&indio_dev->mlock);
+
+	/* read current value */
+	oldcfg = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_INT_CFG_REG);
+	if (oldcfg < 0)
+		goto out;
+
+	if (oldcfg == LIS331LDH_INT_CFG_FREE_FALL) {
+		/* In FREE_FALL mode enabling the other acceleration
+		 * events is not allowed (the -EAGAIN error is returned:
+		 * "disable FREE_FALL before enabling the other events"),
+		 * and disabling the other acceleration events is no-op
+		 * (success code is returned, but no action is done) */
+		if (this_attr->mask != LIS331LDH_INT_CFG_FREE_FALL) {
+			if (do_set)
+				oldcfg = -EAGAIN;
+			goto out;
+		}
+	} else if (oldcfg != 0 && this_attr->mask == LIS331LDH_INT_CFG_FREE_FALL) {
+		/* FREE_FALL mode can't be enabled if any other acceleration
+		 * event enabled (the -EAGAIN error is returned: "disable all
+		 * the other acceleration events before enabling FREE_FALL"),
+		 * and disabling FREE_FALL is no-op (success code is returned,
+		 * but no action is done) */
+		if (do_set)
+			oldcfg = -EAGAIN;
+		goto out;
+	}
+
+	if (do_set && !(oldcfg & this_attr->mask)) {
+		oldcfg |= this_attr->mask;
+		iio_add_event_to_list(this_attr->listel,
+				      &indio_dev->interrupts[0]->ev_list);
+	} else if (!do_set && (oldcfg & this_attr->mask)) {
+		oldcfg &= ~this_attr->mask;
+		iio_remove_event_from_list(this_attr->listel,
+					   &indio_dev->interrupts[0]->ev_list);
+	} else {
+		mutex_unlock(&indio_dev->mlock);
+		return len;
+	}
+	oldcfg = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_INT_CFG_REG,
+					  oldcfg);
+
+out:
+	mutex_unlock(&indio_dev->mlock);
+	return oldcfg < 0 ? oldcfg : len;
+}
+
+static int lis331dlh_thresh_handler_th(struct iio_dev *dev_info,
+				       int index,
+				       s64 timestamp,
+				       int no_test)
+{
+	struct lis331dlh_state *st = dev_info->dev_data;
+
+	lis331dlh_interrupt_count++;
+
+	/* Stash the timestamp somewhere convenient for the bh */
+	st->last_timestamp = timestamp;
+	schedule_work(&st->work_cont_thresh.ws);
+
+	return 0;
+}
+
+static void lis331dlh_thresh_handler_bh_no_check(struct work_struct *work_s)
+{
+	struct iio_work_cont *wc
+		= container_of(work_s, struct iio_work_cont, ws);
+	struct lis331dlh_state *st = wc->st;
+	int ret, ret1;
+
+	lis331dlh_bh_count++;
+
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_INT_SOURCE_REG);
+	ret1 = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_INT_CFG_REG);
+	if (ret < 0 || ret1 < 0)
+		return;
+	/* mask out the sources which are not enabled */
+	ret &= (ret1 & 0x3f);
+
+	if (ret1 & LIS331LDH_INT_CFG_AND) {
+		if (ret == LIS331LDH_INT_SRC_FREE_FALL) {
+			lis331dlh_free_fall_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_FREE_FALL,
+				       st->last_timestamp);
+		}
+	} else {
+		if (ret & LIS331LDH_INT_SRC_ZH) {
+			lis331dlh_zh_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_Z_HIGH,
+				       st->last_timestamp);
+		}
+
+		if (ret & LIS331LDH_INT_SRC_ZL) {
+			lis331dlh_zl_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_Z_LOW,
+				       st->last_timestamp);
+		}
+
+		if (ret & LIS331LDH_INT_SRC_YH)	{
+			lis331dlh_yh_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_Y_HIGH,
+				       st->last_timestamp);
+		}
+
+		if (ret & LIS331LDH_INT_SRC_YL)	{
+			lis331dlh_yl_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_Y_LOW,
+				       st->last_timestamp);
+		}
+
+		if (ret & LIS331LDH_INT_SRC_XH)	{
+			lis331dlh_xh_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_X_HIGH,
+				       st->last_timestamp);
+		}
+
+		if (ret & LIS331LDH_INT_SRC_XL)	{
+			lis331dlh_xl_cnt++;
+			iio_push_event(st->indio_dev, 0,
+				       IIO_EVENT_CODE_ACCEL_X_LOW,
+				       st->last_timestamp);
+		}
+	}
+
+#ifndef CONFIG_IIO_SIMULATE_INTERRUPTS
+	/* reenable the irq */
+	enable_irq(st->client->irq);
+#endif
+}
+
+/* A shared handler for a number of threshold types */
+IIO_EVENT_SH(threshold, &lis331dlh_thresh_handler_th);
+
+IIO_EVENT_ATTR_ACCEL_X_HIGH_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_XH);
+
+IIO_EVENT_ATTR_ACCEL_Y_HIGH_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_YH);
+
+IIO_EVENT_ATTR_ACCEL_Z_HIGH_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_ZH);
+
+IIO_EVENT_ATTR_ACCEL_X_LOW_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_XL);
+
+IIO_EVENT_ATTR_ACCEL_Y_LOW_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_YL);
+
+IIO_EVENT_ATTR_ACCEL_Z_LOW_SH(iio_event_threshold,
+			       lis331dlh_read_interrupt_config,
+			       lis331dlh_write_interrupt_config,
+			       LIS331LDH_INT_CFG_ZL);
+
+IIO_EVENT_ATTR_FREE_FALL_DETECT_SH(iio_event_threshold,
+				   lis331dlh_read_interrupt_config,
+				   lis331dlh_write_interrupt_config,
+				   LIS331LDH_INT_CFG_FREE_FALL);
+
+static struct attribute *lis331dlh_event_attributes[] = {
+	&iio_event_attr_accel_x_high.dev_attr.attr,
+	&iio_event_attr_accel_y_high.dev_attr.attr,
+	&iio_event_attr_accel_z_high.dev_attr.attr,
+	&iio_event_attr_accel_x_low.dev_attr.attr,
+	&iio_event_attr_accel_y_low.dev_attr.attr,
+	&iio_event_attr_accel_z_low.dev_attr.attr,
+	&iio_event_attr_free_fall.dev_attr.attr,
+	NULL
+};
+
+static struct attribute_group lis331dlh_event_attribute_group = {
+	.attrs = lis331dlh_event_attributes,
+};
+
+static IIO_CONST_ATTR(name, "lis331dlh");
+
+static struct attribute *lis331dlh_attributes[] = {
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_const_attr_available_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_accel_full_scale.dev_attr.attr,
+	&iio_const_attr_available_full_scale.dev_attr.attr,
+	&iio_dev_attr_thresh.dev_attr.attr,
+	&iio_dev_attr_accel_xyz.dev_attr.attr,
+	&iio_dev_attr_accel_x.dev_attr.attr,
+	&iio_dev_attr_accel_y.dev_attr.attr,
+	&iio_dev_attr_accel_z.dev_attr.attr,
+	&iio_const_attr_name.dev_attr.attr,
+	&iio_dev_attr_debug.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group lis331dlh_attribute_group = {
+	.attrs = lis331dlh_attributes,
+};
+
+static int lis331dlh_initial_setup(struct lis331dlh_state *st)
+{
+	int ret;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_INT_CFG_REG, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL1_ADDR,
+					LIS331LDH_CTRL1_PMODE_NORMAL |
+					LIS331LDH_CTRL1_DR_50HZ |
+					LIS331LDH_CTRL1_AXES_XYZ_ENABLE);
+	if (ret < 0)
+		return ret;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL3_ADDR,
+					LIS331LDH_CTRL3_INT_LOW |
+					LIS331LDH_CTRL3_OPENDRAIN);
+	if (ret < 0)
+		return ret;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL4_ADDR,
+					LIS331LDH_CTRL4_FS_8G);
+
+	return ret;
+}
+
+static const struct i2c_device_id lis331dlh_id[] = {
+	{ "lis331dlh", 0 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, lis331dlh_id);
+
+static int lis331dlh_detect(struct i2c_client *client,
+			    struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_READ_BYTE)
+	   && !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA)
+	   && !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_WORD_DATA))
+		return -ENODEV;
+
+	ret = i2c_smbus_read_byte_data(client, LIS331LDH_WHO_AM_I_ADDR);
+	if (ret < 0 || ret != LIS331LDH_WHO_AM_I)
+		return -ENODEV;
+
+	strlcpy(info->type, "lis331dlh", I2C_NAME_SIZE);
+	return 0;
+}
+
+static int __devinit lis331dlh_probe(struct i2c_client *client,
+				     const struct i2c_device_id *device_id)
+{
+	int ret;
+	struct lis331dlh_state *st = kzalloc(sizeof(*st), GFP_KERNEL);
+
+	printk(KERN_ERR "lis331dlh: device_id->name = %s\n", device_id->name);
+
+	if (st == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, st);
+
+	st->client = client;
+	st->client->irq = LIS331DLH_IRQ;
+
+	/* setup the industrialio driver allocated elements */
+	st->indio_dev = iio_allocate_device();
+	if (st->indio_dev == NULL) {
+		ret = -ENOMEM;
+		goto error_free_st;
+	}
+
+	st->indio_dev->dev.parent = &client->dev;
+	st->indio_dev->num_interrupt_lines = 1;
+	st->indio_dev->event_attrs = &lis331dlh_event_attribute_group;
+	st->indio_dev->attrs = &lis331dlh_attribute_group;
+	st->indio_dev->dev_data = (void *)(st);
+	st->indio_dev->driver_module = THIS_MODULE;
+	st->indio_dev->modes = INDIO_DIRECT_MODE;
+
+	ret = lis331dlh_configure_ring(st->indio_dev);
+	if (ret) {
+		iio_free_device(st->indio_dev);
+		goto error_free_st;
+	}
+
+	ret = iio_device_register(st->indio_dev);
+	if (ret)
+		goto error_unconfigure_ring;
+
+	ret = lis331dlh_initialize_ring(st->indio_dev->ring);
+	if (ret) {
+		printk(KERN_ERR "failed to initialize the ring\n");
+		goto error_unreg_iidev;
+	}
+
+	iio_init_work_cont(&st->work_cont_thresh,
+			   lis331dlh_thresh_handler_bh_no_check,
+			   lis331dlh_thresh_handler_bh_no_check, /* is the 2nd
+							one needed too? */
+			   LIS331LDH_INT_SOURCE_REG,
+			   0,
+			   st);
+	st->inter = 0;
+	ret = iio_register_interrupt_line(LIS331DLH_IRQ,
+					  st->indio_dev,
+					  0,
+					  IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					  "lis33ldlh");
+	if (ret) {
+		printk(KERN_ERR "failed to register the interrupt line %d\n",
+			LIS331DLH_IRQ);
+		goto error_uninitialize_ring;
+	}
+
+	ret = lis331dlh_probe_trigger(st->indio_dev);
+	if (ret)
+		goto error_unregister_line;
+
+	/* Get the device into a sane initial state */
+	ret = lis331dlh_initial_setup(st);
+	if (ret == 0)
+		return 0;
+
+	if (st->indio_dev->modes & INDIO_RING_TRIGGERED)
+		lis331dlh_remove_trigger(st->indio_dev);
+error_unregister_line:
+	if (st->indio_dev->modes & INDIO_RING_TRIGGERED)
+		iio_unregister_interrupt_line(st->indio_dev, 0);
+error_uninitialize_ring:
+	lis331dlh_uninitialize_ring(st->indio_dev->ring);
+error_unreg_iidev:
+	iio_device_unregister(st->indio_dev);
+error_unconfigure_ring:
+	lis331dlh_unconfigure_ring(st->indio_dev);
+error_free_st:
+	i2c_set_clientdata(client, NULL);
+	kfree(st);
+
+	return ret;
+}
+
+/* Power down the device */
+static int lis331dlh_stop_device(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_INT_CFG_REG, 0);
+	if (ret < 0)
+		goto err;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL3_ADDR,
+					LIS331LDH_CTRL3_INT_LOW |
+					LIS331LDH_CTRL3_OPENDRAIN);
+	if (ret < 0)
+		goto err;
+
+	ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL1_ADDR,
+					LIS331LDH_CTRL1_PMODE_DOWN);
+
+err:
+	mutex_unlock(&indio_dev->mlock);
+	return ret;
+}
+
+static int lis331dlh_remove(struct i2c_client *client)
+{
+	struct lis331dlh_state *st = i2c_get_clientdata(client);
+	int ret;
+
+	ret = lis331dlh_stop_device(st->indio_dev);
+	if (ret)
+		return ret;
+
+	flush_scheduled_work();
+	lis331dlh_remove_trigger(st->indio_dev);
+	iio_unregister_interrupt_line(st->indio_dev, 0);
+	lis331dlh_uninitialize_ring(st->indio_dev->ring);
+	lis331dlh_unconfigure_ring(st->indio_dev);
+	iio_device_unregister(st->indio_dev);
+	i2c_set_clientdata(client, NULL);
+	kfree(st);
+
+	return 0;
+}
+
+static struct i2c_driver lis331dlh_driver = {
+	.driver = {
+		.name = "lis331dlh",
+	},
+	.probe = lis331dlh_probe,
+	.remove = lis331dlh_remove,
+	.id_table = lis331dlh_id,
+
+	.class = I2C_CLASS_HWMON,
+	.detect = lis331dlh_detect,
+	.address_list = lis331dlh_normal_i2c,
+};
+
+static __init int lis331dlh_init(void)
+{
+	printk(KERN_ERR "lis331dlh: inside lis331dlh_init\n");
+	return i2c_add_driver(&lis331dlh_driver);
+}
+
+static __exit void lis331dlh_exit(void)
+{
+	i2c_del_driver(&lis331dlh_driver);
+}
+
+MODULE_AUTHOR("Andrey Konovalov <ank@dev.rtsoft.ru>");
+MODULE_DESCRIPTION("ST LIS331DLH Accelerometer I2C driver");
+MODULE_LICENSE("GPL v2");
+
+module_init(lis331dlh_init);
+module_exit(lis331dlh_exit);
diff --git a/drivers/staging/iio/accel/lis331dlh_ring.c b/drivers/staging/iio/accel/lis331dlh_ring.c
new file mode 100644
index 0000000..a7ebd89
--- /dev/null
+++ b/drivers/staging/iio/accel/lis331dlh_ring.c
@@ -0,0 +1,319 @@
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include "../iio.h"
+#include "../ring_sw.h"
+#include "../sysfs.h"
+#include "../trigger.h"
+#include "accel.h"
+
+#include "lis331dlh.h"
+
+extern long lis331dlh_interrupt_count;
+
+/*
+ * lis331dlh_poll_func_th(): "poll_func_main" interrupt handler called by
+ * iio_trigger_poll().
+ * @private_data:	iio_dev
+ */
+static void lis331dlh_poll_func_th(struct iio_dev *indio_dev)
+{
+	struct lis331dlh_state *st = iio_dev_get_devdata(indio_dev);
+
+	lis331dlh_interrupt_count++;
+
+	st->last_timestamp = indio_dev->trig->timestamp;
+	schedule_work(&st->work_trigger_to_ring);
+
+	/* Indicate that this interrupt is being handled */
+
+	/* Technically this is trigger related, but without this
+	 * handler running there is currently now way for the interrupt
+	 * to clear.
+	 */
+	st->inter = 1;
+}
+
+/*
+ * lis331dlh_data_rdy_trig_poll(): the event handler for the data rdy trig
+ */
+static int lis331dlh_data_rdy_trig_poll(struct iio_dev *dev_info,
+					int index,
+					s64 timestamp,
+					int no_test)
+{
+	struct lis331dlh_state *st = iio_dev_get_devdata(dev_info);
+	struct iio_trigger *trig = st->trig;
+
+	trig->timestamp = timestamp;
+	iio_trigger_poll(trig);
+
+	return IRQ_HANDLED;
+}
+
+/* This is an event as it is a response to a physical interrupt */
+IIO_EVENT_SH(data_rdy_trig, &lis331dlh_data_rdy_trig_poll);
+
+static void lis331dlh_trigger_bh_to_ring(struct work_struct *work_s)
+{
+	struct lis331dlh_state *st;
+	static struct lis331dlh_data d;
+	ssize_t ret;
+
+	st = container_of(work_s, struct lis331dlh_state, work_trigger_to_ring);
+
+	st->inter = 0;
+
+	d.timestamp = st->last_timestamp;
+	ret = i2c_smbus_read_i2c_block_data(st->client,
+			LIS331LDH_STATUS_REG | LIS331LDH_ADDR_AUTOINCREMENT,
+			7, d.data);
+	if (ret < 0) {
+		dev_err(&st->client->dev,
+			"lis331dlh_trigger_bh_to_ring: read failed with %d\n",
+			ret);
+		return;
+	}
+	st->indio_dev->ring->access.store_to(st->indio_dev->ring,
+					     (u8 *)(&d),
+					     st->last_timestamp);
+
+	iio_trigger_notify_done(st->indio_dev->trig);
+}
+
+static int lis331dlh_data_rdy_ring_preenable(struct iio_dev *indio_dev)
+{
+	if (indio_dev->ring->access.set_bpd)
+		indio_dev->ring->access.set_bpd(indio_dev->ring,
+						sizeof(struct lis331dlh_data));
+
+	return 0;
+}
+
+static int lis331dlh_data_rdy_ring_postenable(struct iio_dev *indio_dev)
+{
+	return indio_dev->trig
+		? iio_trigger_attach_poll_func(indio_dev->trig,
+					       indio_dev->pollfunc)
+		: 0;
+}
+
+static int lis331dlh_data_rdy_ring_predisable(struct iio_dev *indio_dev)
+{
+	return indio_dev->trig
+		? iio_trigger_dettach_poll_func(indio_dev->trig,
+						indio_dev->pollfunc)
+		: 0;
+}
+
+/*
+ * lis331dlh_data_rdy_trigger_set_state(): set datardy interrupt state
+ * Is called with indio_dev->mlock held.
+ */
+static int lis331dlh_data_rdy_trigger_set_state(struct iio_trigger *trig,
+						bool state)
+{
+	struct lis331dlh_state *st = trig->private_data;
+	struct iio_dev *indio_dev;
+	int was_en;
+	unsigned char reg3;
+	int ret;
+
+	indio_dev = st->indio_dev;
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_CTRL3_ADDR);
+printk(KERN_INFO "lis331dlh_data_rdy_trigger_set_state: read from CTRL3: 0x%04x\n", ret);
+	if (ret < 0)
+		return ret;
+
+	was_en = ((ret & LIS331LDH_CTRL3_INT_CFG) == LIS331LDH_CTRL3_DATA_READY);
+	if (was_en == state) {
+		printk(KERN_INFO
+			"lis331dlh_data_rdy_trigger_set_state: same state %d requested\n",
+			state);
+		return 0;	/* current state is the same as the requested */
+	}
+
+	reg3 = (unsigned char)ret & ~LIS331LDH_CTRL3_INT_CFG;
+	if (state) {
+		/* enable request */
+		iio_add_event_to_list(&iio_event_data_rdy_trig,
+				      &indio_dev->interrupts[0]->ev_list);
+printk(KERN_INFO "lis331dlh_data_rdy_trigger_set_state: iio_event_data_rdy_trig added\n");
+		ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL3_ADDR,
+				       reg3 | LIS331LDH_CTRL3_DATA_READY);
+	} else {
+		/* disable request */
+		ret = lis331dlh_i2c_write_reg8(st->client, LIS331LDH_CTRL3_ADDR,
+				       reg3 | LIS331LDH_CTRL3_SINGLE_SRC);
+		iio_remove_event_from_list(&iio_event_data_rdy_trig,
+					   &indio_dev->interrupts[0]->ev_list);
+printk(KERN_INFO "lis331dlh_data_rdy_trigger_set_state: iio_event_data_rdy_trig removed\n");
+		/* possible quirk with handler currently worked around
+		   by ensuring the work queue is empty */
+		flush_scheduled_work();
+	}
+
+	return ret;
+}
+
+static DEVICE_ATTR(name, S_IRUGO, iio_trigger_read_name, NULL);
+
+static struct attribute *lis331dlh_trigger_attrs[] = {
+	&dev_attr_name.attr,
+	NULL,
+};
+
+static const struct attribute_group lis331dlh_trigger_attr_group = {
+	.attrs = lis331dlh_trigger_attrs,
+};
+
+/*
+ * lis331dlh_trig_try_reen() try renabling irq for data rdy trigger
+ * @trig:	the datardy trigger
+ *
+ * Is called from iio_trigger_notify_done().
+ * Is needed to reenable the irq disabled inside iio_interrupt_handler.
+ *
+ * If this function returns a non-zero value, iio_trigger_notify_done()
+ * calls iio_trigger_poll() once more.
+ */
+static int lis331dlh_trig_try_reen(struct iio_trigger *trig)
+{
+	struct lis331dlh_state *st = trig->private_data;
+#ifndef CONFIG_IIO_SIMULATE_INTERRUPTS
+	int ret;
+
+	enable_irq(st->client->irq);
+
+	ret = lis331dlh_i2c_read_reg8(st->client, LIS331LDH_STATUS_REG);
+	if (ret > 0 && (ret & LIS331LDH_STATUS_ZYXDA)) {
+		printk(KERN_WARNING
+		       "lis331dlh_trig_try_reen: DATA_AVAILABLE is set again\n");
+		/* If the interrupt pin is still active (or active again) */
+		if (st->inter == 0) {
+			/* already interrupt handler dealing with it */
+			disable_irq_nosync(st->client->irq);
+			if (st->inter == 1) {
+				/* interrupt handler snuck in between test
+				 * and disable */
+				enable_irq(st->client->irq);
+				return 0;
+			}
+			return -EAGAIN;
+		}
+	}
+#endif
+
+	/* irq reenabled successfully, no need to call iio_trigger_poll()
+	 * by force */
+	return 0;
+}
+
+int lis331dlh_probe_trigger(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct lis331dlh_state *state = indio_dev->dev_data;
+
+	state->trig = iio_allocate_trigger();
+	if (!state->trig)
+		return -ENOMEM;
+
+	state->trig->name = kmalloc(IIO_TRIGGER_NAME_LENGTH, GFP_KERNEL);
+	if (!state->trig->name) {
+		ret = -ENOMEM;
+		goto error_free_trig;
+	}
+	snprintf((char *)state->trig->name,
+		 IIO_TRIGGER_NAME_LENGTH,
+		 "lis331dlh-dev%d", indio_dev->id);
+	state->trig->dev.parent = &state->client->dev;
+	state->trig->owner = THIS_MODULE;
+	state->trig->private_data = state;
+	state->trig->set_trigger_state = &lis331dlh_data_rdy_trigger_set_state;
+	state->trig->try_reenable = &lis331dlh_trig_try_reen;
+	state->trig->control_attrs = &lis331dlh_trigger_attr_group;
+	ret = iio_trigger_register(state->trig);
+	if (ret)
+		goto error_free_trig_name;
+
+	return 0;
+
+error_free_trig_name:
+	kfree(state->trig->name);
+error_free_trig:
+	iio_free_trigger(state->trig);
+
+	return ret;
+}
+
+void lis331dlh_remove_trigger(struct iio_dev *indio_dev)
+{
+	struct lis331dlh_state *state = indio_dev->dev_data;
+
+	iio_trigger_unregister(state->trig);
+	kfree(state->trig->name);
+	iio_free_trigger(state->trig);
+}
+
+
+void lis331dlh_unconfigure_ring(struct iio_dev *indio_dev)
+{
+	kfree(indio_dev->pollfunc);
+	iio_sw_rb_free(indio_dev->ring);
+}
+
+int lis331dlh_configure_ring(struct iio_dev *indio_dev)
+{
+	struct lis331dlh_state *st = indio_dev->dev_data;
+	struct iio_ring_buffer *ring;
+
+	INIT_WORK(&st->work_trigger_to_ring, lis331dlh_trigger_bh_to_ring);
+
+	ring = iio_sw_rb_allocate(indio_dev);
+	if (!ring)
+		return -ENOMEM;
+
+	indio_dev->ring = ring;
+	/* Effectively select the ring buffer implementation */
+	iio_ring_sw_register_funcs(&ring->access);
+	ring->preenable = &lis331dlh_data_rdy_ring_preenable;
+	ring->postenable = &lis331dlh_data_rdy_ring_postenable;
+	ring->predisable = &lis331dlh_data_rdy_ring_predisable;
+	ring->owner = THIS_MODULE;
+
+	indio_dev->pollfunc = kzalloc(sizeof(*indio_dev->pollfunc), GFP_KERNEL);
+	if (indio_dev->pollfunc == NULL) {
+		iio_sw_rb_free(indio_dev->ring);
+		return -ENOMEM;
+	}
+
+	indio_dev->pollfunc->poll_func_main = &lis331dlh_poll_func_th;
+	indio_dev->pollfunc->private_data = indio_dev;
+	indio_dev->modes |= INDIO_RING_TRIGGERED;
+	return 0;
+}
+
+int lis331dlh_initialize_ring(struct iio_ring_buffer *ring)
+{
+	return iio_ring_buffer_register(ring);
+}
+
+void lis331dlh_uninitialize_ring(struct iio_ring_buffer *ring)
+{
+	iio_ring_buffer_unregister(ring);
+}
+
+#if 0
+int lis331dlh_set_ring_length(struct iio_dev *indio_dev, int length)
+{
+	/* Set a reasonable default for the ring buffer */
+	if (indio_dev->ring->access.set_length)
+		return indio_dev->ring->access.set_length(indio_dev->ring, 500);
+	return 0;
+}
+#endif
diff --git a/drivers/staging/iio/iio.h b/drivers/staging/iio/iio.h
index 71dbfe1..63ff38c 100644
--- a/drivers/staging/iio/iio.h
+++ b/drivers/staging/iio/iio.h
@@ -12,6 +12,9 @@
 
 #include <linux/device.h>
 #include <linux/cdev.h>
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+#include <linux/timer.h>
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
 #include "sysfs.h"
 #include "chrdev.h"
 
@@ -210,6 +213,10 @@ struct iio_interrupt {
 	int				irq;
 	struct list_head		ev_list;
 	spinlock_t			ev_list_lock;
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+	struct timer_list		timer;
+	unsigned long			period;	/* in jiffies */
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
 };
 
 #define to_iio_interrupt(i) container_of(i, struct iio_interrupt, ev_list)
diff --git a/drivers/staging/iio/industrialio-core.c b/drivers/staging/iio/industrialio-core.c
index 1d77082..497f431 100644
--- a/drivers/staging/iio/industrialio-core.c
+++ b/drivers/staging/iio/industrialio-core.c
@@ -158,10 +158,49 @@ static struct iio_interrupt *iio_allocate_interrupt(void)
 	if (i) {
 		spin_lock_init(&i->ev_list_lock);
 		INIT_LIST_HEAD(&i->ev_list);
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+		init_timer(&i->timer);
+		i->period = 20 * HZ / 1000; /* 20mS by default */
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
 	}
 	return i;
 }
 
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+static void iio_timer_handler(unsigned long data)
+{
+	struct iio_interrupt *int_info = (struct iio_interrupt *)data;
+	struct iio_dev *dev_info = int_info->dev_info;
+	struct iio_event_handler_list *p;
+	s64 time_ns;
+	unsigned long flags;
+
+	spin_lock_irqsave(&int_info->ev_list_lock, flags);
+	if (list_empty(&int_info->ev_list))
+		goto out;
+
+	time_ns = iio_get_time_ns();
+	/* detect single element list */
+	if (list_is_singular(&int_info->ev_list)) {
+		p = list_first_entry(&int_info->ev_list,
+				     struct iio_event_handler_list,
+				     list);
+		/* single event handler - maybe shared */
+		p->handler(dev_info, 1, time_ns, !(p->refcount > 1));
+	} else
+		list_for_each_entry(p, &int_info->ev_list, list) {
+			p->handler(dev_info, 1, time_ns, 0);
+		}
+out:
+	spin_unlock_irqrestore(&int_info->ev_list_lock, flags);
+
+	if (int_info->period) {
+		int_info->timer.expires = jiffies + int_info->period;
+		add_timer(&int_info->timer);
+	}
+}
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
+
 /* Confirming the validity of supplied irq is left to drivers.*/
 int iio_register_interrupt_line(unsigned int irq,
 				struct iio_dev *dev_info,
@@ -184,11 +223,23 @@ int iio_register_interrupt_line(unsigned int irq,
 	 * Can see this may complicate the handling of interrupts.
 	 * However, with this approach we might end up handling lots of
 	 * events no-one cares about.*/
-	ret = request_irq(irq,
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+	printk(KERN_ERR "IIO_SIMULATE_INTERRUPTS: period = %ld\n",
+	       dev_info->interrupts[line_number]->period);
+	dev_info->interrupts[line_number]->timer.data =
+			(unsigned long)(dev_info->interrupts[line_number]);
+	dev_info->interrupts[line_number]->timer.function = iio_timer_handler;
+	dev_info->interrupts[line_number]->timer.expires =
+			jiffies + dev_info->interrupts[line_number]->period;
+	add_timer(&dev_info->interrupts[line_number]->timer);
+	ret = 0;
+#else /* CONFIG_IIO_SIMULATE_INTERRUPTS */
+	ret = request_threaded_irq(irq, NULL,
 			  &iio_interrupt_handler,
 			  type,
 			  name,
 			  dev_info->interrupts[line_number]);
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
 
 error_ret:
 	return ret;
@@ -211,6 +262,10 @@ void iio_unregister_interrupt_line(struct iio_dev *dev_info, int line_number)
 	flush_scheduled_work();
 	free_irq(dev_info->interrupts[line_number]->irq,
 		 dev_info->interrupts[line_number]);
+#ifdef CONFIG_IIO_SIMULATE_INTERRUPTS
+	dev_info->interrupts[line_number]->period = 0;
+	del_timer_sync(&dev_info->interrupts[line_number]->timer);
+#endif /* CONFIG_IIO_SIMULATE_INTERRUPTS */
 	kfree(dev_info->interrupts[line_number]);
 }
 EXPORT_SYMBOL(iio_unregister_interrupt_line);
-- 
1.7.0

