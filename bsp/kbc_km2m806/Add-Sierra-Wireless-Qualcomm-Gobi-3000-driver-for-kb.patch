From e975f85eceeb84680e41159304d7609f11d7cf41 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 16 Jan 2012 19:51:53 +0800
Subject: [PATCH 02/16] Add Sierra Wireless Qualcomm Gobi 3000 driver for kbc_km2m806 platform

Source: GobiSerial_2011-07-29-1026.tar.gz(https://www.codeaurora.org/
patches/quic/gobi/Gobi3000/GobiSerial_2011-07-29-1026.tar.gz)

Signed-off-by: Alfred Tan <atan@codeaurora.org>
Integrated-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/serial/Kconfig       |    9 +
 drivers/usb/serial/Makefile      |    1 +
 drivers/usb/serial/gobi_serial.c |  564 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 574 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/serial/gobi_serial.c

diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index 00c6e23..02c90fc 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -628,6 +628,15 @@ config FUSIONSTAGING
           To compile this driver as a module, choose M here: the module will be
           called fusion wireless module.
 
+config GOBISERIAL
+        tristate "Sierra Wireless GobiSerial modem"
+        ---help---
+	help
+         Say Y here if you want to use a GobiSerial device.
+
+         To compile this driver as a module, choose M here: the
+         module will be called gobi serial.
+
 config USB_SERIAL_DEBUG
 	tristate "USB Debugging Device"
 	help
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 5363c0b..523d4b1 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -58,3 +58,4 @@ obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
 obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
 obj-$(CONFIG_USB_SERIAL_VIVOPAY_SERIAL)	+= vivopay-serial.o
 obj-$(CONFIG_FUSIONSTAGING)             	+= fusion.o
+obj-$(CONFIG_GOBISERIAL)			+= gobi_serial.o
diff --git a/drivers/usb/serial/gobi_serial.c b/drivers/usb/serial/gobi_serial.c
new file mode 100644
index 0000000..e232b88
--- /dev/null
+++ b/drivers/usb/serial/gobi_serial.c
@@ -0,0 +1,564 @@
+/*
+ * FILE:
+ *    GobiSerial.c
+ *
+ * DESCRIPTION:
+ *    Linux Qualcomm Serial USB driver Implementation
+ *
+ * PUBLIC DRIVER FUNCTIONS:
+ *    GobiProbe
+ *    GobiOpen
+ *    GobiClose
+ *    GobiSuspend
+ *
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Code Aurora Forum nor
+ *       the names of its contributors may be used to endorse or promote
+ *       products derived from this software without specific prior written
+ *       permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this software
+ * may be relicensed by the recipient under the terms of the GNU General Public
+ * License version 2 ("GPL") and only version 2, in which case the provisions of
+ * the GPL apply INSTEAD OF those given above.  If the recipient relicenses the
+ * software under the GPL, then the identification text in the MODULE_LICENSE
+ * macro must be changed to reflect "GPLv2" instead of "Dual BSD/GPL".  Once a
+ * recipient changes the license terms to the GPL, subsequent recipients shall
+ * not relicense under alternate licensing terms, including the BSD or dual
+ * BSD/GPL terms.  In addition, the following license statement immediately
+ * below and between the words START and END shall also then apply when this
+ * software is relicensed under the GPL:
+ *
+ * START
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 and only version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * END
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/usb.h>
+#include <linux/usb/serial.h>
+#include <linux/version.h>
+
+#define DRIVER_VERSION "1.0.30/SWI_2.3"
+#define DRIVER_AUTHOR "Qualcomm Innovation Center"
+#define DRIVER_DESC "GobiSerial"
+
+#define NUM_BULK_EPS         1
+#define MAX_BULK_EPS         6
+
+static int debug;
+
+/*
+ * Global pointer to usb_serial_generic_close function
+ * This function is not exported, which is why we have to use a pointer
+ * instead of just calling it.
+ */
+void (*gpClose)(struct usb_serial_port *);
+
+#define DBG(format, arg...) \
+if (debug == 1) { \
+	printk(KERN_INFO "GobiSerial::%s " format, __func__, ## arg); \
+} \
+
+/*
+ * Function Prototypes
+ */
+int GobiOpen(struct tty_struct *pTTY, struct usb_serial_port *pPort);
+
+/* Stop GPS if GPS port, run usb_serial_generic_close */
+void GobiClose(struct usb_serial_port *);
+
+/* Set reset_resume flag */
+int GobiSuspend(struct usb_interface *pIntf, pm_message_t powerEvent);
+
+/* Attach to correct interfaces */
+static int GobiProbe(struct usb_serial *pSerial,
+			const struct usb_device_id *pID);
+/*
+ * Blacklisted Interface Lists - used to filter out non serial device interfaces
+ */
+#define BLACKLISTED_INTERFACE_LIST_TERMINATOR  (signed char)(-1)
+static const signed char qmi_non_serial_interfaces[]  = {
+		8, BLACKLISTED_INTERFACE_LIST_TERMINATOR
+	};
+static const signed char gobi_non_serial_interfaces[] = {
+		0, BLACKLISTED_INTERFACE_LIST_TERMINATOR
+	};
+
+/* Qualcomm Gobi 3000 VID/PIDs */
+static struct usb_device_id GobiVIDPIDTable[] = {
+   { USB_DEVICE(0x05c6, 0x920c) },
+   { USB_DEVICE(0x05c6, 0x920d) },
+   /* Sierra Wireless QMI VID/PID */
+   { USB_DEVICE(0x1199, 0x68A2),
+      .driver_info = (kernel_ulong_t)&qmi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9010) },
+   /* Sierra Wireless G3K Device Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9011),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9012) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9013),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9014) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9015),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* Sierra Wireless G3K Boot VID/PID */
+   { USB_DEVICE(0x1199, 0x9018) },
+   /* Sierra Wireless G3K Application VID/PID */
+   { USB_DEVICE(0x1199, 0x9019),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   /* G3K Boot VID/PID */
+   { USB_DEVICE(0x03F0, 0x361D) },
+   /* G3K Application VID/PID */
+   { USB_DEVICE(0x03F0, 0x371D),
+      .driver_info = (kernel_ulong_t)&gobi_non_serial_interfaces
+   },
+   {}  /* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, GobiVIDPIDTable);
+
+/*
+ * Struct usb_serial_driver
+ * Driver structure we register with the USB core
+ */
+static struct usb_driver GobiDriver = {
+   .name       = "GobiSerial",
+   .probe      = usb_serial_probe,
+   .disconnect = usb_serial_disconnect,
+   .id_table   = GobiVIDPIDTable,
+#ifdef CONFIG_PM
+   .suspend    = GobiSuspend,
+   .resume     = usb_serial_resume,
+   .supports_autosuspend = true,
+#else
+   .suspend    = NULL,
+   .resume     = NULL,
+   .supports_autosuspend = false,
+#endif
+};
+
+/* Struct usb_serial_driver */
+static struct usb_serial_driver gGobiDevice = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "GobiSerial driver",
+	},
+	.description   = "GobiSerial",
+	.id_table      = GobiVIDPIDTable,
+	.usb_driver    = &GobiDriver,
+	.num_ports     = 1,
+	.probe         = GobiProbe,
+	.open          = GobiOpen,
+};
+
+/* USB serial core overridding Methods */
+
+/*
+ * METHOD:
+ *    InterfaceIsBlacklisted (Free Method)
+ *
+ * DESCRIPTION:
+ *    Check whether an interface is blacklisted
+ *
+ * PARAMETERS:
+ *    ifnum           [ I ] - interface number
+ *    pblklist        [ I ] - black listed interface list
+ *
+ * RETURN VALUE:
+ *   bool - true if the interface is blacklisted
+ *          false otherwise
+ */
+static bool InterfaceIsBlacklisted(
+   const signed char ifnum,
+   const signed char *pblklist)
+{
+	if (pblklist != NULL) {
+		while (*pblklist != BLACKLISTED_INTERFACE_LIST_TERMINATOR) {
+			if (*pblklist == ifnum)
+				return true;
+			pblklist++;
+		}
+	}
+	return false;
+}
+
+
+/*
+ * METHOD:
+ *    GobiProbe (Free Method)
+ *
+ * DESCRIPTION:
+ *    Attach to correct interfaces
+ *
+ * PARAMETERS:
+ *    pSerial    [ I ] - Serial structure
+ *    pID        [ I ] - VID PID table
+ *
+ * RETURN VALUE:
+ *    int - negative error code on failure
+ *         zero on success
+ */
+static int GobiProbe(
+   struct usb_serial *pSerial,
+   const struct usb_device_id *pID)
+{
+	int nRetval = -ENODEV;
+
+	int nNumInterfaces;
+	int nInterfaceNum;
+
+	/* Test parameters */
+	if ((pSerial == NULL)
+		||   (pSerial->dev == NULL)
+		||   (pSerial->dev->actconfig == NULL)
+		||   (pSerial->interface == NULL)
+		||   (pSerial->interface->cur_altsetting == NULL)
+		||   (pSerial->type == NULL)) {
+		DBG("invalid parameter\n");
+		return -EINVAL;
+	}
+
+	nNumInterfaces = pSerial->dev->actconfig->desc.bNumInterfaces;
+	DBG("Num Interfaces = %d\n", nNumInterfaces);
+	nInterfaceNum =
+		pSerial->interface->cur_altsetting->desc.bInterfaceNumber;
+	DBG("This Interface = %d\n", nInterfaceNum);
+
+	if (nNumInterfaces == 1) {
+		/* QDL mode? */
+		if ((nInterfaceNum == 0) || (nInterfaceNum == 1)) {
+			DBG("QDL port found\n");
+			nRetval = usb_set_interface(pSerial->dev,
+							nInterfaceNum, 0);
+			if (nRetval < 0)
+				DBG("Could not set interface, error %d\n",
+								nRetval);
+		} else {
+			DBG("Incorrect QDL interface number\n");
+		}
+	} else if (nNumInterfaces > 1) {
+		/* Composite mode */
+		if (InterfaceIsBlacklisted((signed char)nInterfaceNum,
+				(const signed char *)pID->driver_info)) {
+			DBG("Ignoring blacklisted interface #%d\n",
+							nInterfaceNum);
+			return -ENODEV;
+		} else {
+			nRetval = usb_set_interface(pSerial->dev,
+							nInterfaceNum, 0);
+			if (nRetval < 0)
+				DBG("Could not set interface, error %d\n",
+								nRetval);
+
+			/* Check for recursion */
+			if (pSerial->type->close != GobiClose) {
+				/* Store usb_serial_generic_close in gpClose */
+				gpClose = pSerial->type->close;
+				pSerial->type->close = GobiClose;
+			}
+		}
+	}
+
+   return nRetval;
+}
+
+/*
+ * METHOD:
+ *    IsGPSPort (Free Method)
+ *
+ * DESCRIPTION:
+ *    Determines whether the interface is GPS port
+ *
+ * PARAMETERS:
+ *    pPort   [ I ] - USB serial port structure
+ *
+ * RETURN VALUE:
+ *    bool- true if this is a GPS port
+ *        - false otherwise
+ */
+bool IsGPSPort(struct usb_serial_port *pPort)
+{
+	int number = 0;
+
+	number =
+		pPort->serial->interface->cur_altsetting->desc.bInterfaceNumber;
+	DBG("Product=0x%x, Interface=0x%x\n",
+		cpu_to_le16(pPort->serial->dev->descriptor.idProduct),
+		number);
+
+	switch (cpu_to_le16(pPort->serial->dev->descriptor.idProduct)) {
+	case 0x68A2:  /* Sierra Wireless QMI */
+		if (number == 2)
+			return true;
+		break;
+	case 0x9011:  /* Sierra Wireless G3K */
+	case 0x9013:  /* Sierra Wireless G3K */
+	case 0x9015:  /* Sierra Wireless G3K */
+	case 0x9019:  /* Sierra Wireless G3K */
+	case 0x371D:  /* G3K */
+		if (number == 3)
+			return true;
+		break;
+	default:
+		return false;
+		break;
+	}
+	return false;
+}
+
+/*
+ * METHOD:
+ *    GobiOpen (Free Method)
+ *
+ * DESCRIPTION:
+ *    Start GPS if GPS port, run usb_serial_generic_open
+ *
+ * PARAMETERS:
+ *    pPort   [ I ] - USB serial port structure
+ *
+ * RETURN VALUE:
+ *    int - zero for success
+ *        - negative errno on error
+ */
+int GobiOpen(
+   struct tty_struct *pTTY,
+   struct usb_serial_port *pPort)
+{
+	const char startMessage[] = "$GPS_START";
+	int nResult;
+	int bytesWrote;
+
+	/* Test parameters */
+	if ((pPort == NULL)
+		||   (pPort->serial == NULL)
+		||   (pPort->serial->dev == NULL)
+		||   (pPort->serial->interface == NULL)
+		||   (pPort->serial->interface->cur_altsetting == NULL)) {
+		DBG("invalid parameter\n");
+		return -EINVAL;
+	}
+
+	/* Is this the GPS port? */
+	if (IsGPSPort(pPort) == true) {
+		/* Send startMessage, 1s timeout */
+		nResult = usb_bulk_msg(pPort->serial->dev,
+			usb_sndbulkpipe(pPort->serial->dev,
+				pPort->bulk_out_endpointAddress),
+			(void *)&startMessage[0],
+			sizeof(startMessage),
+			&bytesWrote,
+			1000);
+		if (nResult != 0) {
+			DBG("error %d sending startMessage\n", nResult);
+			return nResult;
+		}
+
+		if (bytesWrote != sizeof(startMessage)) {
+			DBG("invalid write size %d, %d\n",
+			bytesWrote,
+			sizeof(startMessage));
+			return -EIO;
+		}
+	}
+
+	/* Clear endpoint halt condition */
+	nResult = usb_clear_halt(pPort->serial->dev,
+			usb_sndbulkpipe(pPort->serial->dev,
+				pPort->bulk_in_endpointAddress) | USB_DIR_IN);
+	if (nResult != 0)
+		DBG("usb_clear_halt return value = %d\n", nResult);
+
+	/* Pass to usb_serial_generic_open */
+	return usb_serial_generic_open(pTTY, pPort);
+}
+
+/*
+ * METHOD:
+ *    GobiClose (Free Method)
+ *
+ * DESCRIPTION:
+ *   Stop GPS if GPS port, run usb_serial_generic_close
+ *
+ * PARAMETERS:
+ *    pPort   [ I ] - USB serial port structure
+ */
+void GobiClose(struct usb_serial_port *pPort)
+{
+	const char stopMessage[] = "$GPS_STOP";
+	int nResult;
+	int bytesWrote;
+
+	if ((pPort == NULL)
+		||   (pPort->serial == NULL)
+		||   (pPort->serial->dev == NULL)
+		||   (pPort->serial->interface == NULL)
+		||   (pPort->serial->interface->cur_altsetting == NULL)) {
+		DBG("invalid parameter\n");
+		return;
+	}
+
+	if ((IsGPSPort(pPort)) == true) {
+		nResult = usb_bulk_msg(pPort->serial->dev,
+				usb_sndbulkpipe(pPort->serial->dev,
+					pPort->bulk_out_endpointAddress),
+				(void *)&stopMessage[0],
+				sizeof(stopMessage),
+				&bytesWrote,
+				1000);
+		if (nResult != 0)
+			DBG("error %d sending stopMessage\n", nResult);
+
+		if (bytesWrote != sizeof(stopMessage))
+			DBG("invalid write size %d, %d\n", bytesWrote,
+							sizeof(stopMessage));
+	}
+
+	if (gpClose == NULL) {
+		DBG("NULL gpClose\n");
+		return;
+	}
+
+	gpClose(pPort);
+}
+
+#ifdef CONFIG_PM
+/*
+ * METHOD:
+ *    GobiSuspend (Public Method)
+ *
+ * DESCRIPTION:
+ *    Set reset_resume flag
+ *
+ * PARAMETERS
+ *    pIntf          [ I ] - Pointer to interface
+ *    powerEvent     [ I ] - Power management event
+ *
+ * RETURN VALUE:
+ *    int - 0 for success
+ *         negative errno for failure
+ */
+int GobiSuspend(
+   struct usb_interface *pIntf,
+   pm_message_t          powerEvent) {
+	struct usb_serial *pDev;
+
+	if (pIntf == 0)
+		return -ENOMEM;
+
+	pDev = usb_get_intfdata(pIntf);
+	if (pDev == NULL)
+		return -ENXIO;
+
+	if ((powerEvent.event & PM_EVENT_SUSPEND) == 0)
+		pDev->dev->reset_resume = 1;
+
+	return usb_serial_suspend(pIntf, powerEvent);
+}
+#endif /* CONFIG_PM*/
+
+/*
+ * METHOD:
+ *    GobiInit (Free Method)
+ *
+ * DESCRIPTION:
+ *    Register the driver and device
+ *
+ * PARAMETERS:
+ *
+ * RETURN VALUE:
+ *    int - negative error code on failure
+ *          zero on success
+ */
+static int __init GobiInit(void)
+{
+	int nRetval = 0;
+	gpClose = NULL;
+
+	gGobiDevice.num_ports = NUM_BULK_EPS;
+
+	nRetval = usb_serial_register(&gGobiDevice);
+	if (nRetval != 0)
+		return nRetval;
+
+	nRetval = usb_register(&GobiDriver);
+	if (nRetval != 0) {
+		usb_serial_deregister(&gGobiDevice);
+		return nRetval;
+	}
+
+	printk(KERN_INFO "%s: %s\n", DRIVER_DESC, DRIVER_VERSION);
+
+	return nRetval;
+}
+
+/*
+ * METHOD:
+ *    GobiExit (Free Method)
+ *
+ * DESCRIPTION:
+ *    Deregister the driver and device
+ *
+ * PARAMETERS:
+ *
+ * RETURN VALUE:
+ */
+static void __exit GobiExit(void)
+{
+	gpClose = NULL;
+	usb_deregister(&GobiDriver);
+	usb_serial_deregister(&gGobiDevice);
+}
+
+module_init(GobiInit);
+module_exit(GobiExit);
+
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
-- 
1.7.0

