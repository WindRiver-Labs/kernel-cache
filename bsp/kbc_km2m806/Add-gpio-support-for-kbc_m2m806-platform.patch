From 9d381ed6a8f50fad41ff9785246a82b8833c05ec Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 16 Jan 2012 10:38:48 +0800
Subject: [PATCH 03/16] Add gpio support for kbc_m2m806 platform

Source: SDK 1.6 for Kontron M2M Smart Services Developer Kit

Add GPIO initlization. The GPIO depend on kempld-core and i2c-kempld

Signed-off-by: Michael Brunner <michael.brunner@kontron.com>
Integrated-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/gpio/Kconfig   |    6 ++
 drivers/gpio/pca953x.c |  188 +++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 193 insertions(+), 1 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index b4990e2..ce73773 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -164,6 +164,12 @@ config GPIO_PCA953X_IRQ
 	  Say yes here to enable the pca953x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
 
+config GPIO_PCA9555_FRI2
+	bool "PCA9555 I/O support on Intel FRI 2 carrier board"
+	depends on GPIO_PCA953X
+	help
+	  Say yes here to enable the FRI2 specific initialization of pca9555.
+
 config GPIO_PCF857X
 	tristate "PCF857x, PCA{85,96}7x, and MAX732[89] I2C GPIO expanders"
 	depends on I2C
diff --git a/drivers/gpio/pca953x.c b/drivers/gpio/pca953x.c
index b827c97..5c6c151 100644
--- a/drivers/gpio/pca953x.c
+++ b/drivers/gpio/pca953x.c
@@ -3,6 +3,7 @@
  *
  *  Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
  *  Copyright (C) 2007 Marvell International Ltd.
+ *  Copyright (c) 2011 Kontron Global Software Center
  *
  *  Derived from drivers/i2c/chips/pca9539.c
  *
@@ -23,6 +24,8 @@
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
 #endif
+#include <linux/io.h>
+#include <linux/acpi.h>
 
 #define PCA953X_INPUT          0
 #define PCA953X_OUTPUT         1
@@ -76,6 +79,101 @@ struct pca953x_chip {
 	char **names;
 };
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+
+#define GPIO_GPE	0x0B	/* SMB_ALERT GPE number on FRI2 */
+#define GPEC		0x18	/* GPE Control register (used to reset GPE) */
+#define	FRI2_GPIO_IRQ_BASE	32
+
+/*
+  Board revision:
+  0x11 - MP1 or older
+  0x10 - MP2 or newer (default)
+*/
+static int fri2_revision = 0x10;
+
+int fri2_get_revision(void)
+{
+	return fri2_revision;
+}
+EXPORT_SYMBOL_GPL(fri2_get_revision);
+
+/* We can install only _one_ handler for SMB_ALERT GPE, but there are
+ * _two_ pca9555 chips on FRI2.
+ * so we need a way to test all GPIOs in one handler. fri2_chips should
+ * contain info about both pca9555.
+ */
+static struct pca953x_chip *fri2_chips[] = {NULL, NULL};
+static int fri2_chip_count;
+
+/* only pins 0 1 3 4 6 and 15 are allowed to write on FRI2 */
+
+#define EXP_A_1_0 1
+#define EXP_A_1_1 (1<<1)
+#define EXP_A_1_3 (1<<3)
+#define EXP_A_1_4 (1<<4)
+#define EXP_A_1_6 (1<<6)
+#define EXP_A_1_15 (1<<15)
+
+#define FRI2_OUT_MASK (EXP_A_1_0 |\
+EXP_A_1_1 | EXP_A_1_3 | EXP_A_1_4 | EXP_A_1_6 | EXP_A_1_15)
+
+/* use i2c device 0x18 to access accelerometer (workaround -
+ * accelerometer holds SMB_ALERT low) 0x20 and 0x21 are pca9555
+ * chips
+ */
+static const unsigned short normal_i2c[] = {0x18, 0x20, 0x21, I2C_CLIENT_END };
+
+static struct pca953x_platform_data fri2_gpio_expander_a_info = {
+	.gpio_base      = 0,
+	.irq_base	= FRI2_GPIO_IRQ_BASE,
+	.invert		= 0,
+};
+
+static struct pca953x_platform_data fri2_gpio_expander_b_info = {
+	.gpio_base	= 16,
+	.irq_base	= FRI2_GPIO_IRQ_BASE + 16,
+	.invert		= 0,
+};
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int pca953x_i2c_detect(struct i2c_client *client,
+			      struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
+		return -ENODEV;
+
+	if (client->addr == 0x20) {
+		/* IO Expander A */
+		info->platform_data = &fri2_gpio_expander_a_info;
+	} else if (client->addr == 0x21) {
+		/* IO expander B */
+		int val;
+		info->platform_data = &fri2_gpio_expander_b_info;
+		val = i2c_smbus_read_word_data(client, PCA953X_INPUT<<1);
+		if (val >= 0)
+			fri2_revision = (val>>14) & 0x3;
+	} else if (client->addr == 0x18) {
+		/* Hack !! set accelerometer to not pull smb_alert */
+		int val;
+		val = i2c_smbus_read_byte_data(client, 0x22);
+		printk(KERN_INFO "PCA95xx: Set accelerometer to not pull \
+			SMB_ALERT. pca953x_i2c_detect should return -ENODEV.");
+		i2c_smbus_write_byte_data(client, 0x22, 0x40);
+		/* always return error - we're not using accelerometer here. */
+		return -ENODEV;
+	}
+	strlcpy(info->type, "pca9555", I2C_NAME_SIZE);
+	return 0;
+}
+
+#endif
+
 static int pca953x_write_reg(struct pca953x_chip *chip, int reg, uint16_t val)
 {
 	int ret;
@@ -137,6 +235,11 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 
 	chip = container_of(gc, struct pca953x_chip, gpio_chip);
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	if (!(FRI2_OUT_MASK & (1 << (chip->gpio_start + off))))
+		return -EINVAL;
+#endif
+
 	/* set output level */
 	if (val)
 		reg_val = chip->reg_output | (1u << off);
@@ -332,6 +435,8 @@ static uint16_t pca953x_irq_pending(struct pca953x_chip *chip)
 	return pending;
 }
 
+#ifndef CONFIG_GPIO_PCA9555_FRI2
+
 static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 {
 	struct pca953x_chip *chip = devid;
@@ -353,6 +458,46 @@ static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
+#else
+
+static u32 pca95xx_gpe_test_chip(struct pca953x_chip *chip)
+{
+	uint16_t pending;
+	uint16_t level;
+
+	pending = pca953x_irq_pending(chip);
+	if (!pending)
+		return ACPI_INTERRUPT_NOT_HANDLED;
+
+	do {
+		level = __ffs(pending);
+		handle_nested_irq(level + chip->irq_base);
+		pending &= ~(1 << level);
+	} while (pending);
+
+	return ACPI_INTERRUPT_HANDLED;
+}
+
+/*
+ * one GPE handler for BOTH pca9555 chips. call pca95xx_gpe_test_chip
+ * for each chip.
+ */
+static u32 pca95xx_gpe_handler(void *context)
+{
+	int i;
+	int ret = ACPI_INTERRUPT_NOT_HANDLED;
+
+	inb(acpi_gbl_FADT.gpe0_block + GPEC);
+	outb(0, acpi_gbl_FADT.gpe0_block + GPEC);
+
+	for (i = 0; i < fri2_chip_count; i++)
+		if (fri2_chips[i] != NULL)
+			ret |= pca95xx_gpe_test_chip(fri2_chips[i]);
+	return ret;
+}
+
+#endif
+
 static int pca953x_irq_setup(struct pca953x_chip *chip,
 			     const struct i2c_device_id *id)
 {
@@ -390,7 +535,7 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 			set_irq_noprobe(irq);
 #endif
 		}
-
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 		ret = request_threaded_irq(client->irq,
 					   NULL,
 					   pca953x_irq_handler,
@@ -401,6 +546,25 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 				client->irq);
 			goto out_failed;
 		}
+#else
+		/* install handler only once - for te first pca9555 chip. */
+		if (fri2_chip_count == 1) {
+			ret = acpi_install_gpe_handler(NULL,
+					   GPIO_GPE,
+					   ACPI_GPE_EDGE_TRIGGERED,
+					   &pca95xx_gpe_handler,
+					   &fri2_chips);
+			if (ret != AE_OK) {
+				printk(KERN_WARNING
+					"pca95xx: unable to claim ACPI GPE %d\n",
+					GPIO_GPE);
+				goto out_failed;
+			} else {
+				printk("  Using ACPI GPE %d\n", GPIO_GPE);
+			}
+		}
+
+#endif
 
 		chip->gpio_chip.to_irq = pca953x_gpio_to_irq;
 	}
@@ -414,8 +578,13 @@ out_failed:
 
 static void pca953x_irq_teardown(struct pca953x_chip *chip)
 {
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 	if (chip->irq_base)
 		free_irq(chip->client->irq, chip);
+#else
+	if (fri2_chip_count-- == 0)
+		acpi_remove_gpe_handler(NULL, GPIO_GPE, &pca95xx_gpe_handler);
+#endif
 }
 #else /* CONFIG_GPIO_PCA953X_IRQ */
 static int pca953x_irq_setup(struct pca953x_chip *chip,
@@ -494,6 +663,9 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 	if (chip == NULL)
 		return -ENOMEM;
 
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	fri2_chips[fri2_chip_count++] = chip;
+#endif
 	pdata = client->dev.platform_data;
 	if (pdata == NULL) {
 		pdata = pca953x_get_alt_pdata(client);
@@ -502,6 +674,7 @@ static int __devinit pca953x_probe(struct i2c_client *client,
 		 * dynamically and must be freed in the driver
 		 */
 		chip->dyn_pdata = pdata;
+		client->dev.platform_data = pdata;
 	}
 
 	if (pdata == NULL) {
@@ -595,16 +768,29 @@ static struct i2c_driver pca953x_driver = {
 	.probe		= pca953x_probe,
 	.remove		= pca953x_remove,
 	.id_table	= pca953x_id,
+
+#ifdef CONFIG_GPIO_PCA9555_FRI2
+	.class = I2C_CLASS_HWMON,
+	.detect = pca953x_i2c_detect,
+	.address_list = normal_i2c,
+#endif
 };
 
 static int __init pca953x_init(void)
 {
 	return i2c_add_driver(&pca953x_driver);
 }
+#ifndef CONFIG_GPIO_PCA9555_FRI2
 /* register after i2c postcore initcall and before
  * subsys initcalls that may rely on these GPIOs
  */
 subsys_initcall(pca953x_init);
+#else
+/* on FRI2 we can init gpio _after_ kontron CPLD
+ * drivers kempld-core and i2c-kempld
+ */
+module_init(pca953x_init);
+#endif
 
 static void __exit pca953x_exit(void)
 {
-- 
1.7.0

