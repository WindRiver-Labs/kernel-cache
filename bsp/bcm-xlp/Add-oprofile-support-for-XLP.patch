From 840a471f0b493a3f4436a950576a999e94c2a788 Mon Sep 17 00:00:00 2001
From: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Date: Mon, 21 Feb 2011 00:56:02 -0800
Subject: [PATCH 239/761] Add oprofile support for XLP

Based on Broadcom SDK 2.3.

Signed-off-by: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/time.c          |   17 +--
 arch/mips/netlogic/xlr/time.c          |    4 +-
 arch/mips/oprofile/Makefile            |    3 +-
 arch/mips/oprofile/common.c            |    5 +-
 arch/mips/oprofile/op_model_mips_xlp.c |  255 ++++++++++++++++++++++++++++++++
 arch/mips/oprofile/op_model_mips_xlr.c |    5 +-
 6 files changed, 268 insertions(+), 21 deletions(-)
 create mode 100644 arch/mips/oprofile/op_model_mips_xlp.c

diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index f22dce8..0bf749b 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -82,8 +82,6 @@ void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
 #endif
 
 #if defined (CONFIG_OPROFILE) || defined (CONFIG_PERFCTR_INTERRUPT_SUPPORT)
-    int cntr0, cntr1;
-    uint32_t ctrl0, ctrl1;
 	int    perfctr_overflow = 0;
 #endif
 
@@ -98,17 +96,8 @@ void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
 	}
 
 #if defined (CONFIG_PERFCTR_INTERRUPT_SUPPORT) || defined (CONFIG_OPROFILE)
-    ctrl0 = __read_32bit_c0_register($25, 0);
-    ctrl1 = __read_32bit_c0_register($25, 2);
-    cntr0 = __read_32bit_c0_register($25, 1);
-    cntr1 = __read_32bit_c0_register($25, 3);
-
-    /* if interrupts are enabled for perf events, check if any counter has
-       overflowed. Then we know for sure that this is a perf event
-       */
-    if((ctrl0 & 0x10) || (ctrl1 & 0x10))
-            if((cntr0 < 0) || (cntr1 < 0))
-                perfctr_overflow = 1;
+    perfctr_overflow = ((read_c0_cause() >> 26) & 0x1);
+
     if(perfctr_overflow == 0)
 #endif
     {
@@ -128,10 +117,8 @@ void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
     }
 #ifdef CONFIG_OPROFILE
 	if (perfctr_overflow) {
-		if(netlogic_thr_id() == 0) {
 			nlm_common_oprofile_int_handler (irq, NULL, regs);
 		}
-    }
 #endif
 #endif
 
diff --git a/arch/mips/netlogic/xlr/time.c b/arch/mips/netlogic/xlr/time.c
index 975a8d9..8660b6c 100644
--- a/arch/mips/netlogic/xlr/time.c
+++ b/arch/mips/netlogic/xlr/time.c
@@ -123,8 +123,8 @@ void xlr_timer_interrupt(struct pt_regs *regs, int irq)
     }
 #ifdef CONFIG_OPROFILE
 	if (perfctr_overflow) {
-		if(xlr_thr_id() == 0) {
-			xlr_oprofile_int_handler (irq, NULL, regs);
+		if(netlogic_thr_id() == 0) {
+			nlm_common_oprofile_int_handler (irq, NULL, regs);
 		}
     }
 #endif
diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index 04cd670..d1b5b78 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -15,5 +15,6 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
-oprofile-$(CONFIG_NLM_COMMON)		+= op_model_mips_xlr.o
+oprofile-$(CONFIG_NLM_XLR)		+= op_model_mips_xlr.o
+oprofile-$(CONFIG_NLM_XLP)		+= op_model_mips_xlp.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index 4f131a4..720d36d 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -27,6 +27,7 @@ extern struct op_mips_model op_model_mipsxx_ops __weak;
 extern struct op_mips_model op_model_rm9000_ops __weak;
 extern struct op_mips_model op_model_loongson2_ops __weak;
 extern struct op_mips_model op_model_xlr __attribute__((weak));
+extern struct op_mips_model op_model_xlp __attribute__((weak));
 static struct op_mips_model *model;
 
 static struct op_counter_config ctr[20];
@@ -86,9 +87,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	switch (current_cpu_type()) {
 	case CPU_XLR:
-	case CPU_XLP:
 		lmodel = &op_model_xlr;
 		break;
+	case CPU_XLP:
+		lmodel = &op_model_xlp;
+		break;
 	case CPU_5KC:
 	case CPU_20KC:
 	case CPU_24K:
diff --git a/arch/mips/oprofile/op_model_mips_xlp.c b/arch/mips/oprofile/op_model_mips_xlp.c
new file mode 100644
index 0000000..88dbe96
--- /dev/null
+++ b/arch/mips/oprofile/op_model_mips_xlp.c
@@ -0,0 +1,255 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+#include <asm/mipsregs.h>
+
+#include "op_impl.h"
+
+#define NETLOGIC_PMC_EVENT_MASK			0x3f
+#define NETLOGIC_PMC_EVENT(event) 		\
+				((event & NETLOGIC_PMC_EVENT_MASK) << 5)
+#define NETLOGIC_PMC_DOM_EXL       		(1U << 0)
+#define NETLOGIC_PMC_DOM_KERNEL			(1U << 1)
+#define NETLOGIC_PMC_DOM_USR			(1U << 3)
+#define NETLOGIC_PMC_ENABLE_INT          (1U << 4)
+
+#define NETLOGIC_PMC_COUNT_ALL_THREADS	(1U << 25)
+
+#define XLP_MAX_PERF_COUNTERS 4
+#define XLP_MAX_CPU_CORES 8
+#define XLP_MAX_CPUS 32
+
+extern struct op_mips_model op_model_xlp;
+
+static struct nlm_common_register_config {
+	unsigned int control[XLP_MAX_PERF_COUNTERS];
+	uint64_t reset_counter[XLP_MAX_PERF_COUNTERS];
+}reg;
+
+volatile int g_stop_pmc[XLP_MAX_CPUS];
+
+
+static void nlm_common_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int counters = op_model_xlp.num_counters;
+	int i;
+	unsigned long flags;
+
+	/* Compute the performance counter control word.  */
+	local_irq_save(flags);
+	for(i=0; i < counters; i++) {
+		reg.control[i] = 0;
+		reg.reset_counter[i] = 0;
+
+		if (!ctr[i].enabled)
+			continue;
+
+		reg.control[i] = NETLOGIC_PMC_EVENT(ctr[i].event) |
+			NETLOGIC_PMC_ENABLE_INT;
+		if (ctr[i].kernel)
+			reg.control[i] |= NETLOGIC_PMC_DOM_KERNEL;
+		if (ctr[i].user)
+			reg.control[i] |= NETLOGIC_PMC_DOM_USR;
+		if (ctr[i].exl)
+			reg.control[i] |= NETLOGIC_PMC_DOM_EXL;
+
+		reg.reset_counter[i] = 0x8000000000000000ULL - ctr[i].count;
+	}
+	wmb();
+	local_irq_restore(flags);
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void netlogic_cpu_setup (void *args)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__write_64bit_c0_register($25, 1, reg.reset_counter[0]);
+	__write_64bit_c0_register($25, 3, reg.reset_counter[1]);
+	__write_64bit_c0_register($25, 5, reg.reset_counter[2]);
+	__write_64bit_c0_register($25, 7, reg.reset_counter[3]);
+	local_irq_restore(flags);
+}
+
+static void netlogic_cpu_start(void *args)
+{
+	unsigned long flags;
+
+	/* Start all counters on current CPU */
+	local_irq_save(flags);
+	__write_32bit_c0_register($25, 0, reg.control[0]);
+	__write_32bit_c0_register($25, 2, reg.control[1]);
+	__write_32bit_c0_register($25, 4, reg.control[2]);
+	__write_32bit_c0_register($25, 6, reg.control[3]);
+	local_irq_restore(flags);
+
+	local_irq_save(flags);
+	g_stop_pmc[hard_smp_processor_id()] = 0;
+	local_irq_restore(flags);
+
+	wmb();
+
+}
+
+static void netlogic_cpu_stop(void *args)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	g_stop_pmc[hard_smp_processor_id()] = 1;
+	local_irq_restore(flags);
+
+	/* Stop all counters on current CPU */
+	local_irq_save(flags);
+	__write_32bit_c0_register($25, 0, 0);
+	__write_32bit_c0_register($25, 2, 0);
+	__write_32bit_c0_register($25, 4, 0);
+	__write_32bit_c0_register($25, 6, 0);
+	local_irq_restore(flags);
+}
+
+/*
+ * This handler is called from count compare timer
+ * interrupt as the perf counter overflow interrupt
+ * shares the same count compare IRQ.
+ */
+
+void nlm_common_oprofile_int_handler(int irq, void * dev_id,
+	struct pt_regs *regs)
+{
+	uint64_t counter1, counter2;
+	uint64_t counter3, counter4;
+	uint32_t control1, control2;
+	uint32_t control3, control4;
+	int h_id = hard_smp_processor_id();/* 0, 1, 2, 3, 4, .....31 */
+
+	if(g_stop_pmc[h_id])
+		return;
+
+	control1 = __read_32bit_c0_register ($25, 0);
+	control2 = __read_32bit_c0_register ($25, 2);
+	control3 = __read_32bit_c0_register ($25, 4);
+	control4 = __read_32bit_c0_register ($25, 6);
+
+
+	counter1 = __read_64bit_c0_register ($25, 1);
+	counter2 = __read_64bit_c0_register ($25, 3);
+	counter3 = __read_64bit_c0_register ($25, 5);
+	counter4 = __read_64bit_c0_register ($25, 7);
+
+	if (((long)counter1) < 0) {
+		__write_32bit_c0_register($25, 0, 0);
+		oprofile_add_sample(regs, 0);
+		counter1 = reg.reset_counter[0];
+		__write_64bit_c0_register($25, 1, counter1);
+		__write_32bit_c0_register($25, 0, reg.control[0]);
+
+		wmb();
+	}
+	if (((long)counter2) < 0) {
+		__write_32bit_c0_register($25, 2, 0);
+		oprofile_add_sample(regs, 1);
+		counter2 = reg.reset_counter[1];
+		__write_64bit_c0_register($25, 3, counter2);
+		__write_32bit_c0_register($25, 2, reg.control[1]);
+
+		wmb();
+	}
+
+	if (((long)counter3) < 0) {
+		__write_32bit_c0_register($25, 4, 0);
+		oprofile_add_sample(regs, 2);
+		counter3 = reg.reset_counter[2];
+		__write_64bit_c0_register($25, 5, counter3);
+		__write_32bit_c0_register($25, 4, reg.control[2]);
+
+		wmb();
+	}
+	if (((long)counter4) < 0) {
+		__write_32bit_c0_register($25, 6, 0);
+		oprofile_add_sample(regs, 3);
+		counter4 = reg.reset_counter[3];
+		__write_64bit_c0_register($25, 7, counter4);
+		__write_32bit_c0_register($25, 6, reg.control[3]);
+
+		wmb();
+	}
+	return ;
+}
+
+static void nlm_common_reset_perf_counters(void)
+{
+	__write_32bit_c0_register($25, 0, 0);
+	__write_64bit_c0_register($25, 1, 0);
+
+	__write_32bit_c0_register($25, 2, 0);
+	__write_64bit_c0_register($25, 3, 0);
+
+	__write_32bit_c0_register($25, 4, 0);
+	__write_64bit_c0_register($25, 5, 0);
+
+	__write_32bit_c0_register($25, 6, 0);
+	__write_64bit_c0_register($25, 7, 0);
+
+}
+
+static int __init nlm_common_init(void)
+{
+	int i;
+
+	for(i=0; i < XLP_MAX_CPUS; i++)
+		g_stop_pmc[i] = 1;
+	nlm_common_reset_perf_counters();
+
+	return 0;
+}
+
+static void nlm_common_exit(void)
+{
+	nlm_common_reset_perf_counters();
+	return;
+}
+
+
+/*
+ * The following is assigned to the variable
+ * 'lmodel' in oprofile_arch_init()
+ */
+struct op_mips_model op_model_xlp = {
+	.reg_setup	= nlm_common_reg_setup,
+	.cpu_setup	= netlogic_cpu_setup,
+	.init		= nlm_common_init,
+	.exit		= nlm_common_exit,
+	.cpu_start	= netlogic_cpu_start,
+	.cpu_stop	= netlogic_cpu_stop,
+	.cpu_type	= "mips/xlp",
+	.num_counters	= XLP_MAX_PERF_COUNTERS,
+};
diff --git a/arch/mips/oprofile/op_model_mips_xlr.c b/arch/mips/oprofile/op_model_mips_xlr.c
index cb6ac64..294d835 100644
--- a/arch/mips/oprofile/op_model_mips_xlr.c
+++ b/arch/mips/oprofile/op_model_mips_xlr.c
@@ -243,6 +243,7 @@ void nlm_common_oprofile_int_handler(int irq, void * dev_id,
 	int ret, lcpu;
 	int sample1_taken=0;
 	int sample2_taken=0;
+	extern struct plat_smp_ops *mp_ops;
 
 	if(g_stop_pmc[h_id])
 		return;
@@ -277,7 +278,7 @@ void nlm_common_oprofile_int_handler(int irq, void * dev_id,
 		for(i=1; i < 4; i++) {
 			lcpu = cpu_number_map(cpu_id+i);
 			if(lcpu && cpu_isset(lcpu, cpu_online_map)) {
-				core_send_ipi(lcpu, SMP_OPROFILE_IPI);
+				mp_ops->send_ipi_single(lcpu, SMP_OPROFILE_IPI);
 			}
 		}
 	}
@@ -293,7 +294,7 @@ void nlm_common_oprofile_int_handler(int irq, void * dev_id,
 		for(i=1; i < 4; i++) {
 			lcpu = cpu_number_map(cpu_id+i);
 			if(lcpu && cpu_isset(lcpu, cpu_online_map)) {
-				core_send_ipi(lcpu, SMP_OPROFILE_IPI);
+				mp_ops->send_ipi_single(lcpu, SMP_OPROFILE_IPI);
 			}
 		}
 	}
-- 
1.7.10.4

