From 9dd6c686194d3bfb086844e93da79b22d09e4b59 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Thu, 31 May 2012 14:17:24 -0700
Subject: [PATCH 751/760] numa: add support for more than 16GB memory

  o In case of NUMA, for each node, the first few physical memory
    page is used for numa bookkeeping. These memories must
    be wired as in early booting, no TLB refill handling exists.

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/mmu.h    |    1 +
 arch/mips/include/asm/mach-netlogic/mmzone.h |    4 +-
 arch/mips/mm/init.c                          |    1 +
 arch/mips/netlogic/common/memory.c           |   56 +++++++++++++++++++-------
 arch/mips/netlogic/xlp/numa.c                |   10 +++++
 5 files changed, 56 insertions(+), 16 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/mmu.h b/arch/mips/include/asm/mach-netlogic/mmu.h
index 2377955..fe0ed25 100644
--- a/arch/mips/include/asm/mach-netlogic/mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/mmu.h
@@ -78,6 +78,7 @@ extern void __init nlm_numa_bootmem_init(unsigned long);
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
 extern int map_kernel_addrspace(unsigned long vaddr, unsigned long paddr,
 				unsigned long max_pfn);
+extern void setup_mapped_kernel_pgtable(void);
 
 #define KERNEL_PAGE_ATTR \
 	(_CACHE_CACHABLE_COW |_PAGE_DIRTY |  _PAGE_VALID | _PAGE_GLOBAL)
diff --git a/arch/mips/include/asm/mach-netlogic/mmzone.h b/arch/mips/include/asm/mach-netlogic/mmzone.h
index 42b7c42..28f9a37 100644
--- a/arch/mips/include/asm/mach-netlogic/mmzone.h
+++ b/arch/mips/include/asm/mach-netlogic/mmzone.h
@@ -23,8 +23,10 @@ struct nlm_node_mem_frag {
 #define NLM_MAX_MEM_FRAGS_PER_NODE 16
 struct nlm_node_mem_info {
 	struct nlm_node_mem_frag mem[NLM_MAX_MEM_FRAGS_PER_NODE];
-	unsigned long free_addr; /* for node_data */
 	int frags;
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	int min_start_pfn;
+#endif
 };
 
 struct nlm_cpu_info {
diff --git a/arch/mips/mm/init.c b/arch/mips/mm/init.c
index f3143b6..a211b06 100644
--- a/arch/mips/mm/init.c
+++ b/arch/mips/mm/init.c
@@ -337,6 +337,7 @@ void __init paging_init(void)
 
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
+	setup_mapped_kernel_pgtable();
 #endif
 
 #ifdef CONFIG_HIGHMEM
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index 2aa5f2c..d606d2e 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -210,7 +210,10 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 		setup_tlb(&tlb, pagesize);
 	}
 	else {
-		int retval;
+#ifdef CONFIG_NUMA
+		int node;
+		extern struct nlm_node_mem_info node_mem_info[];
+#endif
 		/*
 		 * the primary cpu reads the memory map and records
 		 * the highest page frame number. Secondary cpus
@@ -243,23 +246,46 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 			setup_tlb(&tlb, pagesize);
 		}
 
-		if (primary_cpu) {
-			if (max_low_pfn > MAX_WIRED_PFN) {
-				__get_free_pages = alloc_bootmem_low;
-				retval = map_kernel_addrspace(vaddr, MAX_WIRED_PFN, max_low_pfn);
-				if (retval != 0)
-					panic("unable to map kernel addrspace\n");
-				NONWIRED_START = vaddr;
-				NONWIRED_END = vaddr + (PFN_PHYS(max_low_pfn - MAX_WIRED_PFN));
-				__get_free_pages = ____get_free_pages;
-			}
+#ifdef CONFIG_NUMA
+		/* For NUMA, for each node, we have to wire the minimum physical page for that node.
+		 * NUMA uses that piece of memory immediately to keep its internal data structure.
+		 */
+		for (node = 1; node < NLM_MAX_CPU_NODE; node ++) {
+			paddr = PFN_PHYS(node_mem_info[node].min_start_pfn);
+			if (paddr == 0)
+				continue;
+
+			vaddr = KERNEL_SEG_START + paddr;
+			tlb.entryHi = vaddr;
+			tlb.entrylo0 = page_entrylo(paddr, attr);
+			tlb.entrylo1 = page_entrylo(paddr + pagesize, attr);
+			tlb.wired = TRUE;
+			setup_tlb(&tlb, pagesize);
+		}
+#endif
+	}
+}
+
+void setup_mapped_kernel_pgtable(void)
+{
+	unsigned long vaddr = KERNEL_SEG_START + PFN_PHYS(MIN(max_low_pfn, MAX_WIRED_PFN));
+	int retval;
+
+	if (max_low_pfn > MAX_WIRED_PFN) {
+		__get_free_pages = alloc_bootmem_low;
+		retval = map_kernel_addrspace(vaddr, MAX_WIRED_PFN, max_low_pfn);
+		if (retval != 0)
+			panic("unable to map kernel addrspace\n");
+		NONWIRED_START = vaddr;
+		NONWIRED_END = vaddr + (PFN_PHYS(max_low_pfn - MAX_WIRED_PFN));
+		__get_free_pages = ____get_free_pages;
+	}
 #ifdef CONFIG_64BIT
-			__vmalloc_start = KERNEL_SEG_START + (1UL << PGDIR_SHIFT);
+	__vmalloc_start = KERNEL_SEG_START + (1UL << PGDIR_SHIFT);
 #else
-			__vmalloc_start = vaddr;
+	__vmalloc_start = vaddr;
 #endif
-		}
-	}
+	return;
 }
 
 #define FLOOR(addr, alignment) ((addr) & ~((alignment) - 1)) /* alignment must be power of 2 */
diff --git a/arch/mips/netlogic/xlp/numa.c b/arch/mips/netlogic/xlp/numa.c
index c8492b8..16cd814 100644
--- a/arch/mips/netlogic/xlp/numa.c
+++ b/arch/mips/netlogic/xlp/numa.c
@@ -198,6 +198,13 @@ void __init nlm_numa_bootmem_init(unsigned long reserved_end)
 		node_mem_info[node].mem[seg].end_pfn = end;
 		node_mem_info[node].frags++;
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+		if (seg == 0)
+			node_mem_info[node].min_start_pfn = start;
+		else if (start < node_mem_info[node].min_start_pfn)
+			node_mem_info[node].min_start_pfn = start;
+#endif
+
 		if (end > max_low_pfn)
 			max_low_pfn = end;
 		if (start < min_low_pfn)
@@ -321,6 +328,9 @@ void __init paging_init(void)
 	unsigned node;
 
 	pagetable_init();
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	setup_mapped_kernel_pgtable();
+#endif
 
 #ifdef CONFIG_ZONE_DMA
 	zones_size[ZONE_DMA] = MAX_DMA_PFN;
-- 
1.7.0.4

