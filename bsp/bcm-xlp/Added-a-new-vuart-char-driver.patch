From d586be025c61e5c6a2f5f7c5c0ae6e75bfbbc436 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Wed, 4 Aug 2010 17:12:02 -0700
Subject: [PATCH 125/761] Added a new vuart char driver

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/char/Makefile    |    1 +
 drivers/char/nlm_vuart.c |  207 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 208 insertions(+)
 create mode 100644 drivers/char/nlm_vuart.c

diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 30aa989..7e19e27 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -57,6 +57,7 @@ obj-$(CONFIG_AGP)		+= agp/
 obj-$(CONFIG_PCMCIA)		+= pcmcia/
 obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_NLM_XLR) 	+= nlm_common_tb.o
+obj-$(CONFIG_NLM_COMMON)	+= nlm_vuart.o
 obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER) += nlm_pcix_gen_dev.o
 obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER) += nlm_pcix_gen_host.o
 obj-$(CONFIG_NLMCOMMON_CONSOLE_OVER_PCI) += xlr_pcix_console_dev.o
diff --git a/drivers/char/nlm_vuart.c b/drivers/char/nlm_vuart.c
new file mode 100644
index 0000000..15cdf90
--- /dev/null
+++ b/drivers/char/nlm_vuart.c
@@ -0,0 +1,207 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ( Netlogic ). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/slab.h>
+
+#define VUART_MAJOR 251
+#define VUART_NAME "nlm_vuart"
+#define CASE1 1
+#define CASE2 2
+
+static unsigned int counter = 0;
+static char string [128];
+static int data;
+
+static unsigned long uart_sharedcfg_base = (496 << 20);
+static unsigned long uart_sharedcfg_size = (4 << 20);
+
+DECLARE_WAIT_QUEUE_HEAD(vuart_wait);
+static int data_not_ready = 0;
+
+static int vuart_open (struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static int vuart_release (struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static ssize_t vuart_read (struct file *file, char *buf,
+			   size_t count, loff_t *ppos)
+{
+	int len, err;
+
+	printk("[%s]\n", __FUNCTION__);
+	// check if we have data - if not, sleep
+	// wake up in interrupt_handler
+	while (data_not_ready) {
+		interruptible_sleep_on(&vuart_wait);
+	}
+	//data_not_ready = 1;
+
+	if( counter <= 0 )
+		return 0;
+	err = copy_to_user(buf,string,counter);
+	if (err != 0)
+		return -EFAULT;
+	len  = counter;
+	counter = 0;
+	return len;
+}
+
+// write function called when to /dev/vuart is written
+static ssize_t vuart_write (struct file *file, const char *buf,
+			    size_t count, loff_t *ppos)
+{
+	int err;
+
+	printk("[%s]\n", __FUNCTION__);
+	err = copy_from_user(string,buf,count);
+	if (err != 0)
+		return -EFAULT;
+
+	counter += count;
+
+	return count;
+}
+
+// ioctl - I/O control
+static int vuart_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg) {
+	int retval = 0;
+	switch ( cmd ) {
+	case CASE1:/* for writing data to arg */
+		if (copy_from_user(&data, (int *)arg, sizeof(int)))
+			return -EFAULT;
+		break;
+	case CASE2:/* for reading data from arg */
+		if (copy_to_user((int *)arg, &data, sizeof(int)))
+			return -EFAULT;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+static long vuart_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned long ret = -1;
+
+	lock_kernel();
+	ret = vuart_ioctl(NULL, filp, cmd, arg);
+	unlock_kernel();
+
+	if(ret){
+		printk("vuart_ioctl returned with an error %lx", ret);
+		return -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+static int vuart_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long vm_size = vma->vm_end - vma->vm_start;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long size = 0;
+
+	if (offset >= uart_sharedcfg_size) return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED) return -EPERM;
+
+	size = uart_sharedcfg_size - offset;
+	if (vm_size > size) return -ENOSPC;
+
+	vma->vm_flags |= (VM_RESERVED | VM_IO);
+
+        if (remap_pfn_range(vma, vma->vm_start, (uart_sharedcfg_base >> PAGE_SHIFT),
+			    size, vma->vm_page_prot))
+		return -EAGAIN;
+
+	printk("[%s]: pbase=%lx\n", __FUNCTION__, uart_sharedcfg_base);
+
+	return 0;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(vuart_read_wait);
+static DECLARE_WAIT_QUEUE_HEAD(vuart_write_wait);
+
+static unsigned int vuart_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	unsigned int mask;
+
+	if (!filp->private_data) return -EINVAL;
+
+	mask = 0;
+
+	return mask;
+}
+
+struct file_operations vuart_fops = {
+	.owner	  =	THIS_MODULE,
+	.read	  =	vuart_read,
+	.write	  =	vuart_write,
+	.mmap	  =	vuart_mmap,
+	.poll	  =	vuart_poll,
+	.ioctl	  =	vuart_ioctl,
+	.compat_ioctl =	vuart_compat_ioctl,
+	.open	  =	vuart_open,
+	.release  =	vuart_release,
+};
+
+static int vuart_init (void)
+{
+	int ret;
+
+	ret = register_chrdev (VUART_MAJOR, VUART_NAME, &vuart_fops);
+	if (ret != 0)
+		return - EIO;
+
+	printk("[%s] Registered char device major=%d\n", __FUNCTION__, VUART_MAJOR);
+	return 0;
+}
+
+static void vuart_cleanup (void)
+{
+	printk("cleaning up module\n");
+	unregister_chrdev (VUART_MAJOR, VUART_NAME);
+}
+
+module_init(vuart_init);
+module_exit(vuart_cleanup);
+MODULE_AUTHOR("Netlogic");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Virtual UART driver");
-- 
1.7.10.4

