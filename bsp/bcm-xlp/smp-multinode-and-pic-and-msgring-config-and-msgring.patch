From a13a0880487034ce38cea8ba0aaf16a240d28771 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 8 Jun 2010 11:55:49 -0700
Subject: [PATCH 055/761] smp multinode and pic and msgring config and msgring
 int_handler change

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/Makefile             |    3 +-
 arch/mips/netlogic/xlp/cpu_control.c        |  252 +++++++++++---
 arch/mips/netlogic/xlp/cpu_control_macros.h |    4 +
 arch/mips/netlogic/xlp/irq.c                |    3 +-
 arch/mips/netlogic/xlp/on_chip.c            |  487 +++++++--------------------
 arch/mips/netlogic/xlp/smp.c                |   80 ++++-
 arch/mips/netlogic/xlp/time.c               |    1 -
 drivers/net/xlp_nae/Makefile                |    4 +-
 8 files changed, 404 insertions(+), 430 deletions(-)

diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 8973c90..8a739fe 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -2,9 +2,10 @@ EXTRA_CFLAGS := -Werror
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 
 obj-y                    = setup.o config_net.o
-obj-y 				   	+= irq.o time.o on_chip.o mmu.o
+obj-y 			+= irq.o time.o on_chip.o mmu.o
 obj-$(CONFIG_NLM_XLP) 	+= platform-xlp.o
 obj-$(CONFIG_SMP)       += smp.o smpboot.o
+
 obj-$(CONFIG_KGDB)      += nmi.o
 obj-$(CONFIG_NLM_XLP) += cpu_control.o cpu_control_asm.o
 obj-y += bootinfo.o
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 7a0b81c..2adcad6 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -53,9 +53,11 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Globals Section 
  */ 
+#define XLP_ECFG_BASE		0x18000000
+#define XLP_SYS_DEV_BASE	0x35000
 uint32_t cores_bitmap = 0x1;	/* Bitmap of cores to enable  */
 int threads_to_enable; 			/* Threads to enable per core */
-DEFINE_SPINLOCK(smp_lock);
+spinlock_t smp_lock;
 
 /* temporary storage space for
  * stack pointers
@@ -66,6 +68,155 @@ unsigned long linuxsp[NR_CPUS];
  */
 extern unsigned char __stack[];
 extern char boot_siblings_start[], boot_siblings_end[];
+#ifndef __CPUCONTROL_MACROS_H__
+#define __CPUCONTROL_MACROS_H__
+
+#define CHIP_PID_XLP    0x00
+#define NMI_BASE    	0xffffffffbfc00000UL
+#define NMI_BASE_ASM   	0xbfc00000
+
+/* CPU Internal Blocks specific to XLP .
+ * These are accessed using the mfcr/mtcr
+ * instructions. Blocks [0-5] are same for
+ * XLR and XLP
+ */
+#define CPU_BLOCKID_MAP                         0x0a
+/* Offsets of interest from the 'MAP' Block */
+#define BLKID_MAP_THREADMODE                    0x00 
+#define BLKID_MAP_EXT_EBASE_ENABLE              0x04 
+#define BLKID_MAP_CCDI_CONFIG                   0x08
+#define BLKID_MAP_THRD0_CCDI_STATUS             0x0c    
+#define BLKID_MAP_THRD1_CCDI_STATUS             0x10
+#define BLKID_MAP_THRD2_CCDI_STATUS             0x14    
+#define BLKID_MAP_THRD3_CCDI_STATUS             0x18
+#define BLKID_MAP_THRD0_DEBUG_MODE              0x1c
+#define BLKID_MAP_THRD1_DEBUG_MODE              0x20
+#define BLKID_MAP_THRD2_DEBUG_MODE              0x24
+#define BLKID_MAP_THRD3_DEBUG_MODE              0x28
+#define BLKID_MAP_MISC_STATE                    0x60
+#define BLKID_MAP_DEBUG_READ_CTL                0x64
+#define BLKID_MAP_DEBUG_READ_REG0               0x68
+#define BLKID_MAP_DEBUG_READ_REG1               0x6c
+
+#define CPU_BLOCKID_SCH                         7
+#define CPU_BLOCKID_SCU                         8
+#define CPU_BLOCKID_FPU                         9
+
+/* ----------------------------------
+ *   XLP RESET Physical Address Map
+ * ----------------------------------
+ * PCI ECFG : 0x18000000 - 0x1bffffff 
+ * PCI CFG  : 0x1c000000 - 0x1cffffff 
+ * FLASH    : 0x1fc00000 - 0x1fffffff 
+ * ----------------------------------
+ */
+
+/* 
+ * The DEFAULT_XLP_IO_BASE value is what is
+ * programmed in the NBU's (NorthBridge Unit) 
+ * ECFG_BAR register. The NBU itself is 
+ * accessible as [BDF:0,0,0].
+ */
+#define DEFAULT_XLP_IO_BASE       0xffffffffb8000000ULL
+#define DEFAULT_XLP_IO_BASE_VIRT  0xffffffffb8000000      /* IO_BASE for Assembly macros */
+#define DEFAULT_CPU_IO_BASE       DEFAULT_XLP_IO_BASE
+#define DEFAULT_CPU_IO_BASE_VIRT  DEFAULT_XLP_IO_BASE_VIRT
+#define CPU_IO_SIZE               (64<<20)        /* Size of the ECFG Space      */
+#define HDR_OFFSET                0x100           /* Skip 256 bytes of cfg. hdrs */
+
+/* The On-Chip functional blocks for XLP */
+
+/* --------------------------------------------------------------*/
+/* Accesses Based on Enhanced Configuration Mechanism            */
+/* --------------------------------------------------------------*/
+/* Interface | Bus          | Dev       |  Func                  */
+/* --------------------------------------------------------------*/
+#define        BRIDGE        (0x00<<20) | (0x00<<15) | (0x00<<12)
+#define        PIC           (0x00<<20) | (0x00<<15) | (0x04<<12)
+#define        CMS           (0x00<<20) | (0x04<<15) | (0x00<<12)
+#define        UART0         (0x00<<20) | (0x06<<15) | (0x00<<12)
+#define        UART1         (0x00<<20) | (0x06<<15) | (0x01<<12)
+#define        I2C0          (0x00<<20) | (0x06<<15) | (0x02<<12)
+#define        I2C1          (0x00<<20) | (0x06<<15) | (0x03<<12)
+#define        GPIO          (0x00<<20) | (0x06<<15) | (0x04<<12)
+#define        SYS           (0x00<<20) | (0x06<<15) | (0x05<<12)
+#define        JTAG          (0x00<<20) | (0x06<<15) | (0x06<<12)
+#define        NOR           (0x00<<20) | (0x07<<15) | (0x00<<12)
+#define        NAND          (0x00<<20) | (0x07<<15) | (0x01<<12)
+#define        SPI           (0x00<<20) | (0x07<<15) | (0x02<<12)
+#define        MMC           (0x00<<20) | (0x07<<15) | (0x03<<12)
+
+#define CPU_MMIO_OFFSET(x) (DEFAULT_CPU_IO_BASE_VIRT + (x) + HDR_OFFSET)
+
+
+#define SYS_CHIPRST_REG                 0
+#define SYS_PWRONRSTCFG0_REG            1
+#define SYS_EFUSEDEV_CFG0_REG           2
+#define SYS_EFUSEDEV_CFG1_REG           3
+#define SYS_EFUSEDEV_CFG2_REG           4
+#define SYS_EFUSEDEV_CFG3_REG           5
+#define SYS_EFUSEDEV_CFG4_REG           6
+#define SYS_EFUSEDEV_CFG5_REG           7
+#define SYS_EFUSEDEV_CFG6_REG           8
+#define SYS_EFUSEDEV_CFG7_REG           9 
+#define SYS_PLLCTRL_REG                 10
+#define SYS_CPURST_REG                  11
+#define SYS_CPUTHREADEN_REG             12
+#define SYS_CPUNONCOHERENTMODE_REG      13
+#define SYS_COREDFSDISCTRL_REG          14
+#define SYS_COREDFSRSTCTRL_REG          15
+#define SYS_COREDFSBYPCTRL_REG          16
+#define SYS_COREDFSPHACTRL_REG          17
+#define SYS_COREDFSDIVCTRL_REG          18
+#define SYS_SYSRST_REG                  19
+#define SYS_SYSDFSDISCTRL_REG           20
+#define SYS_SYSDFSRSTCTRL_REG           21
+#define SYS_SYSDFSBYPCTRL_REG           22
+#define SYS_SYSDFSDIVCTRL_REG           23
+#define SYS_DMCDFSCTRL_REG              24
+
+
+#ifndef __ASSEMBLY__
+static inline int num_ones(unsigned long mask)
+{
+	int  nones;
+	for (nones = 0; mask; mask >>= 1) {
+		if (mask & 0x1)
+			++nones;
+	}
+	return nones;
+}
+
+enum processor_sys
+{
+	SYS_CHIPRST                     = 0,
+	SYS_PWRONRSTCFG0                = 1,
+	SYS_EFUSEDEV_CFG0               = 2,
+	SYS_EFUSEDEV_CFG1               = 3,
+	SYS_EFUSEDEV_CFG2               = 4,
+	SYS_EFUSEDEV_CFG3               = 5,
+	SYS_EFUSEDEV_CFG4               = 6,
+	SYS_EFUSEDEV_CFG5               = 7,
+	SYS_EFUSEDEV_CFG6               = 8,
+	SYS_EFUSEDEV_CFG7               = 9, 
+	SYS_PLLCTRL                     = 10,
+	SYS_CPURST                      = 11,
+	SYS_CPUTHREADEN                 = 12,
+	SYS_CPUNONCOHERENTMODE          = 13,
+	SYS_COREDFSDISCTRL              = 14,
+	SYS_COREDFSRSTCTRL              = 15,
+	SYS_COREDFSBYPCTRL              = 16,
+	SYS_COREDFSPHACTRL              = 17,
+	SYS_COREDFSDIVCTRL              = 18,
+	SYS_SYSRST                      = 19,
+	SYS_SYSDFSDISCTRL               = 20,
+	SYS_SYSDFSRSTCTRL               = 21,
+	SYS_SYSDFSBYPCTRL               = 22,
+	SYS_SYSDFSDIVCTRL               = 23,
+	SYS_DMCDFSCTRL                  = 24
+};
+#endif
+#endif /* __CPUCONTROL_MACROS_H__ */
 extern char reset_entry[], reset_entry_end[];
 //extern void xlr_loader_init(void);
 
@@ -82,16 +233,15 @@ static inline void jump_address(unsigned long entry)
 
 void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num) {
 	uint32_t core, value, start_core, i = 0;
-        uint64_t sys_mmio;
 
        if(node == 0)
                 start_core = 0x2;
         else
                 start_core = 0x1;
 
-        sys_mmio = XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node;
+        nlm_reg_t *sys_mmio =(nlm_reg_t *) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
 
-	printk("sys_mmio = %llu\n", sys_mmio);
+	printk("sys_mmio = %p\n", sys_mmio);
 
 	for (core=start_core; core!=(0x1<<8); core<<=1) {
 
@@ -103,6 +253,11 @@ void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_n
 
 		if (cbitmap & core) {
 
+			if(thread_num != 4)
+			{
+	                        value = (thread_num-1) << (i*2);
+	                        nlm_hal_write_32bit_reg(sys_mmio, 0x4C, 0x1/*value*/);
+			}
 			/* Enable CPU clock 
 			 */
                         value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
@@ -115,11 +270,9 @@ void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_n
 			/* Poll for CPU to mark itself coherent */
 			do {
                                 value = nlm_hal_read_32bit_reg(sys_mmio, 0x4D) & core;
+				if( node > 0)
+				   break;	
 			} while (value);
-#if 0
-			/* hangs..? */
-			udelay(50);
-#endif
 		}
 		i++;
 	}
@@ -127,40 +280,46 @@ void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_n
 
 /* Main routine 
  */
-void enable_cpus(unsigned long thread_bitmask)
+void enable_cpus( unsigned int node, unsigned int onlinemask)
 {
+printk("[%s] node:%p \n", __FUNCTION__, node );
 	uint32_t cbitmap;
 	uint32_t t0_bitmap = 0x0;
-	uint32_t t0_positions = 0, index=3;
-	unsigned long flags;
-
+	uint32_t t0_positions = 0, index=3, flags;
+	uint32_t thread_bitmask, flags, i = 0;
 	/* Extract the bitmap of 'cores'
 	 * from the complete input bitmask
 	 */
-	t0_bitmap = thread_bitmask & 0x11111111;
+//	for(i = 0; i < 4 ; i++)
+	{
+		thread_bitmask = onlinemask;
+//		if(thread_bitmask == 0)
+//			continue;
 
-	cores_bitmap = 0x1;
+		t0_bitmap = thread_bitmask & 0x11111111;
 
-	for (t0_positions = 4; t0_positions <=28; t0_positions+=4) {
-		cores_bitmap |= ((t0_bitmap & (1 << t0_positions)) >> index);
-		index+=3;
-	}
+		cores_bitmap = 0x1;
 
-	printk("Cores Bitmap=0x%x\n", cores_bitmap);
+		for (t0_positions = 4; t0_positions <=28; t0_positions+=4) {
+			cores_bitmap |= ((t0_bitmap & (1 << t0_positions)) >> index);
+			index+=3;
+		}
 
-	/* As for the threads to be enabled
-	 * per core, use Core0 as a reference
-	 */
-	thread_bitmask = thread_bitmask & 0xf;
+		printk("Node %d Cores Bitmap=0x%x\n", node, cores_bitmap);
 
-	switch (thread_bitmask) {
-		case 0x1:
+		/* As for the threads to be enabled
+	 	* per core, use Core0 as a reference
+	 	*/
+		thread_bitmask = thread_bitmask & 0xf;
+
+		switch (thread_bitmask) {
+			case 0x1:
 			if (num_ones(cores_bitmap) == 1) {
 				printk("Core0/Thread0 is enabled.\n");
 				return;
 			}
-		case 0x3:
-		case 0xf:
+			case 0x3:
+			case 0xf:
 			threads_to_enable = num_ones(thread_bitmask);
 			printk("Enabling (%d) cores, (%d) threads/core\n",
 					num_ones(cores_bitmap), threads_to_enable);
@@ -171,34 +330,35 @@ void enable_cpus(unsigned long thread_bitmask)
 			cbitmap = cores_bitmap;
 			cores_bitmap = ~(cores_bitmap) & 0xfe;
 			break;
-		default:
+			default:
 			printk("[Core 0] : Invalid Threads number!\n");
 			return;
-	}
-
-        spin_lock_irqsave(&smp_lock, flags);
-	
-	/* Linux runs out of KSEG2. Setup TLBs
-	 * for other threads, by running from
-	 * KSEG0. Then, jump back into KSEG2.
-	 */
-	memcpy((void *)(NMI_BASE + (2<<10)), 
+		}
+        	
+		spin_lock_irqsave(&smp_lock, flags);
+
+		/* Linux runs out of KSEG2. Setup TLBs
+	 	* for other threads, by running from
+	 	* KSEG0. Then, jump back into KSEG2.
+	 	*/
+		memcpy((void *)(NMI_BASE + (2<<10)), 
 		   (void *)&boot_siblings_start, 
 		   (boot_siblings_end - boot_siblings_start));
 
-	jump_address(NMI_BASE + (2<<10));
+		jump_address(NMI_BASE + (2<<10));
 
-	/* Bring the other cores online here
-	 * Copy reset code into KSEG0 space
-	 */
-	if (cores_bitmap != 0xfe) {
-		memcpy((void *)(NMI_BASE), 
+		/* Bring the other cores online here
+	 	* Copy reset code into KSEG0 space
+	 	*/
+		if (cores_bitmap != 0xfe) {
+			memcpy((void *)(NMI_BASE), 
 			   (void *)&reset_entry, 
 			   (reset_entry_end - reset_entry));
-	}
+		}
 
-	enable_cores(0, cbitmap, threads_to_enable);
-        spin_unlock_irqrestore(&smp_lock, flags);
+		enable_cores( node, cbitmap, threads_to_enable);
 
+        	spin_unlock_irqrestore(&smp_lock, flags);
+	}
 	return;
 }
diff --git a/arch/mips/netlogic/xlp/cpu_control_macros.h b/arch/mips/netlogic/xlp/cpu_control_macros.h
index cece0b6..b5a2942 100644
--- a/arch/mips/netlogic/xlp/cpu_control_macros.h
+++ b/arch/mips/netlogic/xlp/cpu_control_macros.h
@@ -145,5 +145,9 @@ enum processor_sys
 	SYS_SYSDFSDIVCTRL               = 23,
 	SYS_DMCDFSCTRL                  = 24
 };
+
+struct node_mask {
+	uint32_t onlinemask[4];
+};
 #endif
 #endif /* __CPUCONTROL_MACROS_H__ */
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 940fee9..b2b251f 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -56,6 +56,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Externs */
 extern void nlm_common_timer_interrupt(struct pt_regs *regs, int irq);
+extern void nlm_xlp_msgring_int_handler(int irq, struct pt_regs *regs);
 
 extern void *ht_config_base;
 extern int link0, link1;
@@ -147,7 +148,7 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 	}
 #endif
 
-	if (irq == IRQ_MSGRING) nlm_common_msgring_int_handler(irq, regs);
+	if (irq == IRQ_MSGRING) nlm_xlp_msgring_int_handler(irq, regs);
 
 #ifdef CONFIG_KGDB
 	else if (irq == IRQ_IPI_SMP_KGDB) {
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index a29990b..031b275 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -34,7 +34,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
-#include <asm/netlogic/xlr_user_mac.h>
 #include <asm/netlogic/sim.h>
 
 #include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
@@ -43,64 +42,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-extern int xlr_loader_own_gmac;
-extern int xlr_loader_own_dma;
 int msgring_timer_irq;
 extern uint32_t xlp_linux_cpu_mask;
 
-#define MSGRNG_CC_INIT_CPU_DEST(conf, dest,cpu) \
-do { \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][0], 0 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][1], 1 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][2], 2 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][3], 3 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][4], 4 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][5], 5 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][6], 6 ); \
-     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][7], 7 ); \
-} while(0)
-
-/* Initialized CC for cpu 0 to send to all buckets at 0-7 cpus */
-#define MSGRNG_CC_INIT_CPU(conf, cpu) \
-do { \
-  MSGRNG_CC_INIT_CPU_DEST(conf,0,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,1,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,2,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,3,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,4,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,5,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,6,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,7,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,8,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,9,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,10,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,11,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,12,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,13,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,14,cpu); \
-  MSGRNG_CC_INIT_CPU_DEST(conf,15,cpu); \
-} while (0)
-
-#define MSGRNG_BUCKETSIZE_INIT_CPU(conf, base) \
-do { \
-  msgrng_write_bucksize(0, conf##bucket_sizes.bucket[base+0]);         \
-  msgrng_write_bucksize(1, conf##bucket_sizes.bucket[base+1]);         \
-  msgrng_write_bucksize(2, conf##bucket_sizes.bucket[base+2]);  \
-  msgrng_write_bucksize(3, conf##bucket_sizes.bucket[base+3]);  \
-  msgrng_write_bucksize(4, conf##bucket_sizes.bucket[base+4]);  \
-  msgrng_write_bucksize(5, conf##bucket_sizes.bucket[base+5]);  \
-  msgrng_write_bucksize(6, conf##bucket_sizes.bucket[base+6]);  \
-  msgrng_write_bucksize(7, conf##bucket_sizes.bucket[base+7]);  \
-} while(0)
-
-#define XLR_MSG_TBL
-#define XLS_MSG_TBL  xls_
-#define SHARED_XLR_MSG_TBL shared_
-
-#define X_MSGRNG_BUCKETSIZE_INIT_CPU(x,y) MSGRNG_BUCKETSIZE_INIT_CPU(x,y)
-
 __u32  pop_bucket_mask[NR_CORES];
 __u32  pop_bucket_start[NR_CORES];
 __u32  pop_bucket_end[NR_CORES];
@@ -123,40 +67,7 @@ extern int nlm_dev_own_bucket_list_get(int *start, int *end, int *mask);
 extern struct irq_chip nlm_common_rsvd_pic;
 extern struct irqaction nlm_common_rsvd_action;
 
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-extern int nlm_msgring_napi;
-extern int xlr_napi_ready;
-extern void xlr_napi_rx_schedule(void);
-#endif				/* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-struct tx_stn tx_stns[XLP_MAX_TX_STNS];
-
-/*
-int stnid_to_index[XLP_MAX_TX_STNS] = {
-	XLP_MSG_HANDLE_CPU0,          
-	XLP_MSG_HANDLE_CPU1,         
-	XLP_MSG_HANDLE_CPU2,          
-	XLP_MSG_HANDLE_CPU3,         
-	XLP_MSG_HANDLE_CPU4,          
-	XLP_MSG_HANDLE_CPU5,          
-	XLP_MSG_HANDLE_CPU6,          
-	XLP_MSG_HANDLE_CPU7,          
-	XLP_MSG_HANDLE_PCIE0,         
-	XLP_MSG_HANDLE_PCIE1,         
-	XLP_MSG_HANDLE_PCIE2,
-	XLP_MSG_HANDLE_PCIE3,
-	XLP_MSG_HANDLE_GDX,
-	XLP_MSG_HANDLE_RSA_ECC,
-	XLP_MSG_HANDLE_CRYPTO,
-	XLP_MSG_HANDLE_CMP,
-	XLP_MSG_HANDLE_POE,
-	XLP_MSG_HANDLE_NAE_TX,
-	XLP_MSG_HANDLE_NAE_RX,
-	XLP_MSG_HANDLE_INVALID,
-};
-*/
-
-int rxstn_to_txstn_map[1024] = {
+static uint16_t vc_to_handle_map[1024] = {
 	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
 	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
 	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
@@ -184,8 +95,44 @@ int rxstn_to_txstn_map[1024] = {
 	[305 ... 383] = XLP_MSG_HANDLE_INVALID,
 	[384 ... 391] = XLP_MSG_HANDLE_POE,
 	[392 ... 475] = XLP_MSG_HANDLE_INVALID,
-	[476 ... 999] = XLP_MSG_HANDLE_NAE_TX,
-	[1000 ... 1019] = XLP_MSG_HANDLE_NAE_RX,
+	[476] 	      = XLP_MSG_HANDLE_NAE_0,
+	[477] 	      = XLP_MSG_HANDLE_NAE_1,
+	[478] 	      = XLP_MSG_HANDLE_NAE_2,
+	[479] 	      = XLP_MSG_HANDLE_NAE_3,
+	[480] 	      = XLP_MSG_HANDLE_NAE_4,
+	[481] 	      = XLP_MSG_HANDLE_NAE_5,
+	[482] 	      = XLP_MSG_HANDLE_NAE_6,
+	[483] 	      = XLP_MSG_HANDLE_NAE_7,
+	[484] 	      = XLP_MSG_HANDLE_NAE_8,
+	[485] 	      = XLP_MSG_HANDLE_NAE_9,
+	[486] 	      = XLP_MSG_HANDLE_NAE_10,
+	[487] 	      = XLP_MSG_HANDLE_NAE_11,
+	[488] 	      = XLP_MSG_HANDLE_NAE_12,
+	[489] 	      = XLP_MSG_HANDLE_NAE_13,
+	[490] 	      = XLP_MSG_HANDLE_NAE_14,
+	[491] 	      = XLP_MSG_HANDLE_NAE_15,
+	[492] 	      = XLP_MSG_HANDLE_NAE_16,
+	[493] 	      = XLP_MSG_HANDLE_NAE_17,
+	[494 ... 999] = XLP_MSG_HANDLE_NAE_0,
+	[1000] 	      = XLP_MSG_HANDLE_NAE_0,
+	[1001] 	      = XLP_MSG_HANDLE_NAE_1,
+	[1002] 	      = XLP_MSG_HANDLE_NAE_2,
+	[1003] 	      = XLP_MSG_HANDLE_NAE_3,
+	[1004] 	      = XLP_MSG_HANDLE_NAE_4,
+	[1005] 	      = XLP_MSG_HANDLE_NAE_5,
+	[1006] 	      = XLP_MSG_HANDLE_NAE_6,
+	[1007] 	      = XLP_MSG_HANDLE_NAE_7,
+	[1008] 	      = XLP_MSG_HANDLE_NAE_8,
+	[1009] 	      = XLP_MSG_HANDLE_NAE_9,
+	[1010] 	      = XLP_MSG_HANDLE_NAE_10,
+	[1011] 	      = XLP_MSG_HANDLE_NAE_11,
+	[1012] 	      = XLP_MSG_HANDLE_NAE_12,
+	[1013] 	      = XLP_MSG_HANDLE_NAE_13,
+	[1014] 	      = XLP_MSG_HANDLE_NAE_14,
+	[1015] 	      = XLP_MSG_HANDLE_NAE_15,
+	[1016] 	      = XLP_MSG_HANDLE_NAE_16,
+	[1017] 	      = XLP_MSG_HANDLE_NAE_17,
+	[1018 ... 1019] = XLP_MSG_HANDLE_NAE_0,
 	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID
 };
 
@@ -198,58 +145,18 @@ void dummy_handler(int bucket, int size, int code, int tx_stid,
 	       (unsigned long long)msg->msg0);
 }
 
-struct tx_stn_handler tx_stn_handler_map[128] = {
-	[0 ... 127] = {dummy_handler, NULL},
+struct tx_stn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
+	[0 ... (XLP_MSG_HANDLE_MAX-1)] = {dummy_handler, NULL},
 };
 
-void nlm_common_msgring_cpu_init(void)
+void nlm_xlp_msgring_cpu_init(void)
 {
 	int id;
-	unsigned long flags;
-	int shared_msgring = 0;
 
 	id = cpu_logical_map(get_cpu());
 
 	msgring_int_en = 1;
 
-	if (xlr_loader_support && xlr_loader_sharedcore) {
-		/* if support for loading apps on same core as Linux is enabled */
-		if (xlr_loader_own_gmac || xlr_loader_own_dma) {
-			/* pop should only the buckets matching with the thread
-			   on which linux is loaded */
-			shared_msgring = 1;
-			msgring_int_en = 0;
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] |= (1 << (id % 4));
-			if (pop_bucket_end[id >> 2] < (id % 4) + 1)
-				pop_bucket_end[id >> 2] = (id % 4) + 1;
-		} else if (xlr_hybrid_rmios_ipsec()) {
-			/* rmios will always send to the bucket 0 */
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] = 1;
-			pop_bucket_end[id >> 2] = 1;
-			put_cpu();
-			return;
-		} else {
-			/* all the stations are owned by apps, 
-			   linux should not poll for any bucket */
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] = 0;
-			pop_bucket_end[id >> 2] = 0;
-		}
-	} else if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
-		/* msgring interrupt should be disabled */
-		msgring_int_type = 0x0;
-
-		pop_bucket_start[id >> 2] = 0;
-		pop_bucket_end[id >> 2] = 4;
-		pop_bucket_mask[id >> 2] = 0xf;
-	} else {
-		/* all the stations are owned by linux */
-		pop_bucket_start[id >> 2] = 0;
-		pop_bucket_end[id >> 2] = 8;
-		pop_bucket_mask[id >> 2] = 0xff;
-	}
 
 	/* if not thead 0 */
 	if ((id & 0x03) != 0) {
@@ -258,112 +165,8 @@ void nlm_common_msgring_cpu_init(void)
 	}
 
 	prom_dbg_msg("Initializing message ring for cpu_%d\n", id);
-
-	msgrng_flags_save(flags);
-
-	/* Message Stations are shared among all threads in a cpu core
-	 * Assume, thread 0 on all cores are always active when more than
-	 * 1 thread is active in a core
-	 */
-	if (is_xls()) {
-		if (id == 0) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 0);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 0);
-		} else if (id == 4) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 8);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 1);
-		} else if (id == 8) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 16);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 2);
-		} else if (id == 12) {
-			X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL, 24);
-			MSGRNG_CC_INIT_CPU(XLS_MSG_TBL, 3);
-		}
-	} else {
-		if (shared_msgring) {
-			if (id == 0) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     0);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 0);
-			} else if (id == 4) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     8);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 1);
-			} else if (id == 8) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     16);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 2);
-			} else if (id == 12) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     24);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 3);
-			} else if (id == 16) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     32);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 4);
-			} else if (id == 20) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     40);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 5);
-			} else if (id == 24) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     48);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 6);
-			} else if (id == 28) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,
-							     56);
-				MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL, 7);
-			}
-		} else {
-			if (id == 0) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 0);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 0);
-			} else if (id == 4) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 8);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 1);
-			} else if (id == 8) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 16);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 2);
-			} else if (id == 12) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 24);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 3);
-			} else if (id == 16) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 32);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 4);
-			} else if (id == 20) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 40);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 5);
-			} else if (id == 24) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 48);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 6);
-			} else if (id == 28) {
-				X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL, 56);
-				MSGRNG_CC_INIT_CPU(XLR_MSG_TBL, 7);
-			}
-		}
-	}
-	msgrng_flags_restore(flags);
-	put_cpu();
 }
 
-void nlm_common_msgring_config(void)
-{
-
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	/* If we use NAPI then we enable queue non-empty interrupt */
-	msgring_int_type = nlm_msgring_napi ? 0x01 : 0x02;
-#else
-	msgring_int_type = 0x02;
-#endif				/* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
-	msgring_watermark_count = 1;
-	msgring_thread_mask = 0x0f;
-
-/* 	printk("[%s]: int_type = 0x%x, pop_num_buckets=%d, pop_bucket_mask=%x" */
-/* 	       "watermark_count=%d, thread_mask=%x\n", __FUNCTION__, */
-/* 	       msgring_int_type, msgring_pop_num_buckets, msgring_pop_bucket_mask, */
-/* 	       msgring_watermark_count, msgring_thread_mask); */
-}
 
 void nlm_common_derive_cpu_to_bkt_map(void)
 {
@@ -449,74 +252,26 @@ void nlm_common_derive_cpu_to_bkt_map(void)
 			rv++;
         }
     }
-#if 0
-	for (i = 0; i < NR_CPUS; i++)
-		printk("%d: bktmask=0x%x frstid=%d\n",
-		       i, cpu_to_bktmask[i], cpu_to_frstid[i]);
-#endif
 
 	return;
 }
 
-static int __init xlr_msgring_watermark_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-
-	msgring_watermark_count = (int)simple_strtoul(str, NULL, 10);
-
-	return 1;
-}
-
-static int __init xlr_msgring_thread_mask_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-
-	msgring_thread_mask = simple_strtoul(str, NULL, 16);
-	msgring_thread_mask &= 0x0f;
-
-	return 1;
-}
-
-static int __init xlr_complete_msgring_thread_mask_setup(char *str)
-{
-	if (*str == '=')
-		str++;
-	msgring_global_thread_mask = simple_strtoul(str, NULL, 16);
-	msgring_global_thread_mask &= 0xffffffff;
-	return 1;
-}
-
-__setup("xlr_msgring_watermark=", xlr_msgring_watermark_setup);
-__setup("xlr_msgring_thread_mask=", xlr_msgring_thread_mask_setup);
-__setup("xlr_complete_msgring_thread_mask=",
-	xlr_complete_msgring_thread_mask_setup);
-
 extern void nlm_cpu_stat_update_msgring_int(void);
 extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
 extern void nlm_cpu_stat_update_msgring_pic_int(void);
-
+#if 0
 void msgring_process_rx_msgs(int start_bucket, int end_bucket,
 			     __u32 pop_bucket_mask)
 {
 	unsigned int bucket_empty_bm = 0;
 	int bucket = 0;
 	int size = 0, code = 0, rx_stid = 0;
-	struct msgrng_msg msg;
+	struct msgring_msg msg;
 	struct tx_stn_handler *handler = 0;
 	unsigned int status = 0;
 
 printk("[%s] \n", __FUNCTION__);
 
-#ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
-	if (xlr_napi_ready && in_irq()) {
-		xlr_napi_rx_schedule();
-printk("xlr_napi_rx_schedule\n");
-		return;
-	}
-#endif				/* CONFIG_NLMCOMMON_MSGRING_NAPI */
-
 	/* First Drain all the high priority messages */
 	for (;;) {
 
@@ -534,40 +289,33 @@ printk("bucket_empty_bm:%d pop_bucket_mask %d \n", bucket_empty_bm, pop_bucket_m
 			    !((1 << bucket) & pop_bucket_mask))	/* not in mask */
 				continue;
 
-			status =
-			    message_receive(bucket, &size, &code, &rx_stid,
-					    &msg);
-			if (status)
-				continue;
-
-			handler = &tx_stn_handler_map[rx_stid];
+			status = xlp_msg_recv(bucket, &rx_stid,  &size, &code, &msg);
 printk("rx_stid:%d  \n", rx_stid);
-			/* Handler is always present. If not actual, atleast 
-			 * dummy_handler
-			 */
-			(handler->action) (bucket, size, code, rx_stid, &msg,
-					   handler->dev_id);
+			handler = &msg_handler_map[vc_to_handle_map[rx_stid]];
+			(handler->action) (bucket, size, code, rx_stid, &msg, handler->dev_id);
 		}
 	}
 }
+#endif
 
 #if !defined(CONFIG_NLMCOMMON_MAC) && !defined(CONFIG_NLM_XLP)
-__u64 xlr_cp2_exceptions[32];
-struct user_mac_data *user_mac;
-struct user_mac_kernal_data user_mac_krnl_data;
-struct xlr_user_mac_config xlr_user_mac;
 void nlm_cpu_stat_update_msgring_int(void) { }
 void nlm_cpu_stat_update_msgring_cycles(__u32 cycles) { }
 void nlm_cpu_stat_update_msgring_pic_int(void) { }
 #endif /* CONFIG_NLMCOMMON_MAC */
 
 __u32 msgrng_msg_cycles = 0;
-void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
+void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
 	unsigned long mflags;
 	int core;
 	__u32 cycles = 0;
-printk("[%s] \n",__FUNCTION__);
+	int vc = 0;
+	int size = 0, code = 0, rx_stid = 0;
+	struct msgring_msg msg;
+	struct tx_stn_handler *handler = 0;
+	unsigned int status = 0;
+//printk("[%s] \n",__FUNCTION__);
 
 	if (irq == IRQ_MSGRING) {
 		/* normal message ring interrupt */
@@ -582,16 +330,26 @@ printk("[%s] \n",__FUNCTION__);
 	dbg_msg("[%s] IN irq=%d\n",__function__, irq);
 
 	/* TODO: not necessary to disable preemption */
-	msgrng_flags_save(mflags);
+//	msgrng_flags_save(mflags);
 
 	cycles = read_c0_count();
 
 	core = cpu_logical_map(smp_processor_id()) >> 2;
-	msgring_process_rx_msgs(pop_bucket_start[core], pop_bucket_end[core], pop_bucket_mask[core]);
-
-	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
-
-	msgrng_flags_restore(mflags);
+//	msgring_process_rx_msgs(pop_bucket_start[core], pop_bucket_end[core], pop_bucket_mask[core]);
+        msgrng_access_enable(mflags);
+	for( vc = 0; vc < 4; vc++){
+	status = xlp_msg_recv(vc, &rx_stid,  &size, &code, &msg);
+	if(status & 0x1)
+	{
+printk("rx_stid:%d handler_id %d\n", rx_stid, vc_to_handle_map[rx_stid]);
+		handler = &msg_handler_map[vc_to_handle_map[rx_stid]];
+		(handler->action) (vc, size, code, rx_stid, &msg, handler->dev_id);
+	
+		nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
+	}
+	}
+        msgrng_access_disable(mflags);
+//	msgrng_flags_restore(mflags);
 
 	//dbg_msg("OUT irq=%d\n", irq);
 
@@ -602,8 +360,10 @@ printk("[%s] \n",__FUNCTION__);
 static void enable_msgring_int(void *info)
 {
 	unsigned long flags = 0, mflags = 0;
-	unsigned int th_mask;
+	unsigned int th_mask, i;
 	unsigned int core;
+	uint64_t val;
+
 	msgrng_access_save(&msgrng_lock, flags, mflags);
 
 	core = hard_smp_processor_id() & ~(0x3);
@@ -619,11 +379,18 @@ static void enable_msgring_int(void *info)
 #endif
 
 	/* enable the message ring interrupts */
-/*
-	msgrng_write_config((msgring_watermark_count << 24) |
-			    (IRQ_MSGRING << 16)
-			    | (th_mask << 8) | msgring_int_type);
-*/
+
+	for(i = 0; i < 128; i++)
+	{
+		val = nlm_hal_read_outq_config(i);
+		/* clear and then set int level value and high watermark field*/
+		val &= ~(0xfULL << 53);
+		val |= ((uint64_t)HWM_NON_EMPTY << 55)|((uint64_t)LVL_INT_HIGH_WM << 53);	
+		/*enable interrupt*/	
+		val |= 1ULL << 59;
+		nlm_hal_write_outq_config(i, val);
+	}
+
 	msgrng_access_restore(&msgrng_lock, flags, mflags);
 }
 
@@ -632,7 +399,7 @@ static void msgring_bkp_timer(unsigned long data)
 	unsigned long flags;
 	struct timer_list *timer = (struct timer_list *)data;
 	local_irq_save(flags);
-	nlm_common_msgring_int_handler(-1,NULL);
+	nlm_xlp_msgring_int_handler(-1,NULL);
 	local_irq_restore(flags);
 	mod_timer(timer, timer->expires+2);
 }
@@ -652,13 +419,12 @@ int register_msgring_handler(int major,
 					     struct msgrng_msg *, void *),
 			     void *dev_id)
 {
-	struct tx_stn_handler *handler = 0;
 	int ret = 1;
-	int i,j,tx_stid, handle_index;
+	int i, j, tx_stid=0;
 	unsigned long flags = 0;
 	cpumask_t timer_cpu_mask;
 
-	if (major >= XLP_MAX_TX_STNS || action == NULL) {
+	if (major >= XLP_MSG_HANDLE_MAX || action == NULL) {
 		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
 		       "XLP_MAX_TX_STN=%d action=%p",
 		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
@@ -668,27 +434,16 @@ int register_msgring_handler(int major,
 	/* Check if the message station is valid, if not return error */
 	spin_lock_irqsave(&msgrng_lock, flags);
 
-	for (i = 0; i < 128; i++) {
-		tx_stid = rxstn_to_txstn_map[i];
-		if (tx_stid == major) {
-printk("[%s]tx_stid : %x\n",__FUNCTION__, tx_stid);
-			tx_stn_handler_map[i].action = action;
-			tx_stn_handler_map[i].dev_id = dev_id;
-		}
-	}
-
-	handler = &tx_stns[tx_stid].handler;
 
-	// dbg_msg("major=%d, action=%p, dev_id=%p\n", major, action, dev_id);
-	handler->action = action;
-	handler->dev_id = dev_id;
+printk("[%s] major=%d, tx_stid=%d action=%p, dev_id=%p\n", __FUNCTION__, major,tx_stid, action, dev_id);
+	msg_handler_map[major].action = action;
+	msg_handler_map[major].dev_id = dev_id;
 
 	ret = 0;
 	spin_unlock_irqrestore(&msgrng_lock, flags);
 
 	if (!ret && nlm_common_test_and_set(&msgring_registered)) {
-		int i=0;
-
+		i=0;
 		hard_cpu_online_map = 0;
 		for (i = 0; i < NR_CPUS; i++) {
 			if (cpu_isset(i, cpu_online_map))
@@ -697,7 +452,7 @@ printk("[%s]tx_stid : %x\n",__FUNCTION__, tx_stid);
 		}
 
 		/* derive the cpu to bucket map */
-		nlm_common_derive_cpu_to_bkt_map();
+		//nlm_common_derive_cpu_to_bkt_map();
 
 
 		/* Configure PIC to deliver msgring interrupt for timeouts */
@@ -740,6 +495,13 @@ printk("[%s]tx_stid : %x\n",__FUNCTION__, tx_stid);
 				cpu_set(logical_id, timer_cpu_mask);
 			}
 		}
+#if 1
+                preempt_disable();
+                smp_call_function_many(&timer_cpu_mask, enable_msgring_timer, NULL, 1);
+                preempt_enable();
+                if(cpu_isset(cpu_number_map(hard_smp_processor_id()),timer_cpu_mask))
+                        enable_msgring_timer(NULL);
+#endif
 	}
 
 	return ret;
@@ -771,39 +533,25 @@ atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
 
 static void nlm_usb_init (void)
 {
+	volatile unsigned int value;
 	nlm_reg_t * gpio_mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
 	nlm_reg_t * usb_mmio  = netlogic_io_mmio(NETLOGIC_IO_USB_1_OFFSET);
 
-   /* The NLM-Specific USB Block */
-   netlogic_write_reg(usb_mmio, 49, 0x10000000); //Clear Rogue Phy INTs
-   netlogic_write_reg(usb_mmio, 50, 0x1f000000);
+	/* The NLM-Specific USB Block */
+	netlogic_write_reg(usb_mmio, 49, 0x10000000); //Clear Rogue Phy INTs
+	netlogic_write_reg(usb_mmio, 50, 0x1f000000);
 
-	if (is_xls1xx()) {
-		/* Enabling only 1 USB Port */
-		if (xlr_board_atx_viii()) {
-			/* LTE board has usb port #1 */
-			netlogic_write_reg(usb_mmio,  1, 0x05000500);
-		}
-		else {
-			/* enable usb port #0 */
-			netlogic_write_reg(usb_mmio,  1, 0x03000500);
-		}
+	netlogic_write_reg(usb_mmio,  1, 0x07000500);
+
+	value = gpio_mmio[21];
+	if ((value >> 22) & 0x01) {
+		printk("Detected USB Host mode..\n");
+		netlogic_write_reg(usb_mmio,  0, 0x02000000);
 	}
 	else {
-   	netlogic_write_reg(usb_mmio,  1, 0x07000500);
+		printk("Detected USB Device mode..\n");
+		netlogic_write_reg(usb_mmio,  0, 0x01000000);
 	}
-
-   {
-      volatile unsigned int value = gpio_mmio[21];
-      if ((value >> 22) & 0x01) {
-         printk("Detected USB Host mode..\n");
-         netlogic_write_reg(usb_mmio,  0, 0x02000000);
-      }
-      else {
-         printk("Detected USB Device mode..\n");
-         netlogic_write_reg(usb_mmio,  0, 0x01000000);
-      }
-   }
 }
 
 void on_chip_init(void)
@@ -821,19 +569,16 @@ void on_chip_init(void)
 
 	nlm_hal_fmn_init( xlp_linux_cpu_mask );
 
-	nlm_common_msgring_config();
 	
 	pic_init(); 
 
-	/* XLP FMN code Not Yet ported! */
 #if !defined(CONFIG_NLM_XLP)
-//	nlm_common_msgring_cpu_init();
+//	nlm_xlp_msgring_cpu_init();
 #endif
 
 	for (i = 0; i < NR_CPUS; i++)
-		for (j = 0; j < NLM_MAX_COUNTERS; j++)
+	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
 
-	if (is_xls())
-		nlm_usb_init();
+	nlm_usb_init();
 }
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 437decc..83d6d69 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -44,6 +44,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <user/netlogic/nlm_common_loader.h>
 
 #include <asm/mach-netlogic/mmu.h>
+#include "cpu_control_macros.h"
 
 extern int xlr_loader_support;
 extern volatile cpumask_t cpu_callin_map;
@@ -53,8 +54,11 @@ extern int onlinemask;
 extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 struct smp_boot_info smp_boot;
+struct node_mask smp_node;
 extern void prom_reconfigure_thr_resources(void);
 extern unsigned long nlm_common_ebase;
+extern void enable_cpus(unsigned int node, unsigned online_mask);
+extern void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num);
 
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
 cpumask_t phys_cpu_present_map;
@@ -81,6 +85,7 @@ void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
  */
 static void __cpuinit nlm_init_secondary(void)
 {
+ printk("[%s]\n", __FUNCTION__); 
     extern void nlm_smp_irq_init(void);
 
     nlm_smp_irq_init();
@@ -102,12 +107,18 @@ void nlm_cpus_done(void)
    bring them into the boot fn */
 void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 {
+ printk("[%s] logical_cpu: %d\n", __FUNCTION__,logical_cpu); 
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
 	int cpu = cpu_logical_map(logical_cpu);
 
-/* 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", */
-/* 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); */
+	if(cpu == 32)
+	{
+		//enable_cores( 1,0x3,4); 
+		enable_cpus( 1, smp_node.onlinemask[1]);
+	}
+ 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", 
+ 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); 
   
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -116,13 +127,14 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 	__sync();
 	smp_boot.boot_info[cpu].ready = 1;
   
-/* 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); */
+ 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); 
 }
 
 unsigned int fast_syscall_cpumask_phy = 0x1;
 
 void __init nlm_smp_setup(void)
 {
+ printk("[%s]\n", __FUNCTION__); 
 	int num_cpus = 1;
 	__u32 boot_cpu_online_map = 0, boot_cpu = 0x0;
 
@@ -150,7 +162,8 @@ void __init nlm_smp_setup(void)
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	boot_cpu_online_map = smp_boot.online_map;
+	boot_cpu_online_map = smp_node.onlinemask[0];
+	smp_boot.online_map = smp_node.onlinemask[0];
 	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
 
 	/* 0th entry in the logical_map should be the bootcpu and all
@@ -162,7 +175,7 @@ void __init nlm_smp_setup(void)
 	__cpu_logical_map[0] = boot_cpu;
 //	cpu_set(0, cpu_possible_map);
 
-	for(i = 0;i<NR_CPUS;i++) {
+	for(i = 0; i < 32; i++) {
 		if (boot_cpu_online_map & (1<<i)) {
 			cpu_set(i, phys_cpu_present_map);
 			__cpu_number_map[i] = num_cpus;
@@ -172,6 +185,22 @@ void __init nlm_smp_setup(void)
 		}
 	}
 
+	for(j = 1; j < 4; j++)
+	{
+		boot_cpu_online_map = smp_node.onlinemask[j];
+		if(boot_cpu_online_map == 0)
+			continue;
+
+		for(i = 0; i < 32; i++) {
+			if (boot_cpu_online_map & (1<<i)) {
+				cpu_set(i + 32*j, phys_cpu_present_map);
+				__cpu_number_map[i+32*j] = num_cpus;
+				__cpu_logical_map[num_cpus] = i+32*j;
+				cpu_set(num_cpus, cpu_possible_map);
+				++num_cpus;
+			}
+		}
+	}
 
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
 
@@ -203,7 +232,7 @@ struct plat_smp_ops nlm_smp_ops = {
 void prom_boot_cpus_secondary(void *args)
 {
 	int cpu = hard_smp_processor_id();
-  
+ printk("[%s]\n", __FUNCTION__); 
 	write_c0_ebase((uint32_t)nlm_common_ebase);
 	atomic_add((1<<cpu), (atomic_t *)&smp_boot.online_map);
 	for(;;) {
@@ -232,11 +261,46 @@ extern uint32_t xlp_linux_cpu_mask;
 #else
 #define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
 #endif
-extern void enable_cpus(int online_mask);
 
 int wakeup_secondary_cpus(void)
 {
-	enable_cpus(onlinemask);
+#if 1 
+	smp_node.onlinemask[0] = 0x00000001;
+	smp_node.onlinemask[1] = 0x00000000;
+	smp_node.onlinemask[2] = 0x00000000;
+	smp_node.onlinemask[3] = 0x00000000;
+
+	enable_cpus( 0, smp_node.onlinemask[0]);
+//#if 0
+#else
+	__u32 wakeup_mask;
+#if defined(CONFIG_NLM_XLP_SIM)
+	unsigned int wait_count = 0;
+#endif
+
+	if (xlr_loader_support) {
+		wakeup_mask = xlp_linux_cpu_mask | nlm_common_loader_mask;
+		if (wakeup != NULL)
+			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
+	} 
+	else {
+		if (wakeup != NULL) {
+			wakeup((void *)secondary_cpus_bootup_func, 0, 
+				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
+#if defined(CONFIG_NLM_XLP_SIM)
+			while (smp_boot.online_map != prom_info->nlm_cpu_online_map) {
+				if ((wait_count++ % 1000000) == 0) {
+					printk("[%s%d]: Master cpu waiting for slave cpus to wakeup from bootloader (%x != %llx)\n",
+					       __FUNCTION__, __LINE__, smp_boot.online_map, 
+						   (unsigned long long) prom_info->nlm_cpu_online_map);
+				}
+			}
+			printk("[%s@%d]: woke up prom_info->nlm_cpu_online_map=%016llx\n", __FILE__, __LINE__, 
+				   (unsigned long long) prom_info->nlm_cpu_online_map);
+#endif
+		}
+	}
+#endif
 	return 0;
 }
 
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index a9bad30..d4eb942 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -171,7 +171,6 @@ void nlm_common_timer_setup(void)
         nlm_hal_pic_update_control(1 << (10 + 6));
 
         spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-        //do_gettimeoffset = xlr_gettimeoffset;
 
 }
 
diff --git a/drivers/net/xlp_nae/Makefile b/drivers/net/xlp_nae/Makefile
index f0efab3..4324a8a 100644
--- a/drivers/net/xlp_nae/Makefile
+++ b/drivers/net/xlp_nae/Makefile
@@ -6,8 +6,8 @@
 #EXTRA_CFLAGS := -Werror
 
 EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
-obj-m += nlm_xlp_nae.o
-#obj-$(CONFIG_XLP_NAE) += nlm_xlp_nae.o
+#obj-m += nlm_xlp_nae.o
+obj-$(CONFIG_XLP_NAE) += nlm_xlp_nae.o
 nlm_xlp_nae-objs := xlp_nae.o init_nae.o init_fmn.o ucore_loader.o xlp_hw.o 
 
 shared_sources:
-- 
1.7.10.4

