From f96453246730b23389090f32e74e178723288d96 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Wed, 6 Oct 2010 15:59:25 -0700
Subject: [PATCH 196/762] Renamed cerr-phoenix to cerr-nlm

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/Makefile       |    2 +-
 arch/mips/mm/cerr-nlm.c     |  193 +++++++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/cerr-phoenix.c |  192 ------------------------------------------
 3 files changed, 194 insertions(+), 193 deletions(-)
 create mode 100644 arch/mips/mm/cerr-nlm.c
 delete mode 100644 arch/mips/mm/cerr-phoenix.c

diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index a75c7dd..858750c 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -32,7 +32,7 @@ obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= c-octeon.o cex-oct.o tlb-r4k.o
 obj-$(CONFIG_CPU_XLR)		+= c-r4k.o tlb-r4k.o cex-gen.o
 obj-$(CONFIG_CPU_XLP)		+= c-r4k.o tlb-r4k.o cex-gen.o
-obj-$(CONFIG_CPU_XLP)		+= c-phoenix.o cerr-phoenix.o
+obj-$(CONFIG_CPU_XLP)		+= c-phoenix.o cerr-nlm.o
 
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
diff --git a/arch/mips/mm/cerr-nlm.c b/arch/mips/mm/cerr-nlm.c
new file mode 100644
index 0000000..744fda5
--- /dev/null
+++ b/arch/mips/mm/cerr-nlm.c
@@ -0,0 +1,193 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/smp.h>
+#include <asm/system.h>
+
+#include <asm/netlogic/iomap.h>
+
+unsigned char nlm_cerr_stack[8192];
+volatile int nlm_cerr_lock;
+
+static __inline__ void cerr_cpu_halt(void)
+{
+	for(;;) {
+		__asm__ __volatile__(".set mips64\n"
+				     "1: wait \n"
+				     "   b 1b\n"
+				     "   nop\n"
+			);
+	}
+}
+
+#define UART_RHR 0
+#define UART_THR 0
+#define UART_IER 1
+#define UART_IIR 2
+#define UART_FCR 2
+#define UART_LCR 3
+#define UART_MCR 4
+#define UART_LSR 5
+#define UART_MSR 6
+static void cerr_outbyte(char ch)
+{
+	volatile uint32_t *mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
+	int lsr;
+	for (;;) {
+
+		lsr = be32_to_cpu(mmio[UART_LSR]);
+
+		/* Tx Fifo empty */
+		if (lsr & 0x20) {
+			mmio[UART_THR] = cpu_to_be32((int)ch);
+			break;
+		}
+	}
+}
+
+static char cerr_printk_buf[2048];
+static void cerr_printk(const char *fmt, ...)
+{
+	va_list args;
+	int len;
+	int i = 0;
+
+	va_start(args, fmt);
+	len = vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
+	va_end(args);
+
+	for (i = 0; i <= len; i++) {
+
+		if (cerr_printk_buf[i] == 0)
+			continue;
+
+		if (cerr_printk_buf[i] == '\n')
+			cerr_outbyte('\r');
+
+		cerr_outbyte(cerr_printk_buf[i]);
+	}
+
+}
+
+#ifdef CONFIG_NLM_XLR
+
+static char *bridge_aerr_intr_devstat[] = {
+	[0] = "cpu 0",
+	[1] = "cpu 1",
+	[2] = "cpu 2",
+	[3] = "cpu 3",
+	[4] = "cpu 4",
+	[5] = "cpu 5",
+	[6] = "cpu 6",
+	[7] = "cpu 7",
+
+	[8] = "L2",
+	[9] = "XGS 0",
+	[10] = "XGS 1",
+	[11] = "GMAC",
+	[12] = "SEC",
+	[13] = "PCIX",
+	[14] = "HT",
+	[15] = "DMA",
+};
+
+static void print_cerr_info(void)
+{
+	__u64 cerr_cpu_log = 0;
+	int i = 0;
+	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+	__u32 tmp = 0;
+
+	cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
+			( ((__u64)netlogic_read_reg(mmio, 39)<<5) | ((__u64)netlogic_read_reg(mmio, 40)<<37) ),
+			netlogic_read_reg(mmio, 41));
+
+	cerr_printk("Bridge: The devices reporting AERR are:\n");
+	tmp = netlogic_read_reg(mmio, 41);
+	for(i = 0; i < 16; i++) {
+		if (tmp & (1<<i)) xlr_cerr_printk("\t%s\n", bridge_aerr_intr_devstat[i]);
+	}
+
+	cerr_cpu_log = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+	cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
+			cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
+}
+
+#else
+
+static void print_cerr_info(void)
+{
+	nlm_reg_t *nbu_mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+
+	uint64_t icu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
+	uint64_t icu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
+	uint64_t icu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
+	uint64_t lsu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
+	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
+	uint64_t scu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
+	uint64_t scu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
+	uint64_t scu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
+
+	cerr_printk("CPU: (XLP specific) ICU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n"
+		    "                    LSU log0 = 0x%016llx, log1 = 0x%016llx\n"
+		    "                    SCU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n",
+		    icu_log0, icu_log1, icu_log2,
+		    lsu_log0, lsu_log1,
+		    scu_log0, scu_log1, scu_log2);
+
+	cerr_printk("NBU: Bar Aerr reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
+		    netlogic_read_reg(nbu_mmio, 162), netlogic_read_reg(nbu_mmio, 163),
+		    netlogic_read_reg(nbu_mmio, 164) );
+}
+
+#endif
+
+/* On XLR/XLP, errors reported by bridge (like misconfigured BARS etc) are also
+ * reported as cache errors. Need to check if it is really a cache error or a "bus error"
+ * and take action appropriately.
+ * For now, treat it as a cache error
+ */
+asmlinkage void nlm_cache_error(void)
+{
+	local_irq_disable();
+
+	/* let the first cpu in */
+	while (nlm_cerr_lock) ;
+	nlm_cerr_lock = 1;
+
+	cerr_printk("*********************************************\n");
+	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
+	cerr_printk("*********************************************\n");
+
+	print_cerr_info();
+
+	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
+			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+
+	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+
+	cerr_cpu_halt();
+}
+
diff --git a/arch/mips/mm/cerr-phoenix.c b/arch/mips/mm/cerr-phoenix.c
deleted file mode 100644
index a73233a..0000000
--- a/arch/mips/mm/cerr-phoenix.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (¡°Netlogic¡±). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/smp.h>
-
-#include <asm/netlogic/iomap.h>
-
-unsigned char nlm_cerr_stack[8192];
-volatile int nlm_cerr_lock;
-
-static __inline__ void cerr_cpu_halt(void)
-{
-	for(;;) {
-		__asm__ __volatile__(".set mips64\n"
-				     "1: wait \n"
-				     "   b 1b\n"
-				     "   nop\n"
-			);
-	}
-}
-
-#define UART_RHR 0
-#define UART_THR 0
-#define UART_IER 1
-#define UART_IIR 2
-#define UART_FCR 2
-#define UART_LCR 3
-#define UART_MCR 4
-#define UART_LSR 5
-#define UART_MSR 6
-static void cerr_outbyte(char ch)
-{
-	volatile uint32_t *mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
-	int lsr;
-	for (;;) {
-
-		lsr = be32_to_cpu(mmio[UART_LSR]);
-
-		/* Tx Fifo empty */
-		if (lsr & 0x20) {
-			mmio[UART_THR] = cpu_to_be32((int)ch);
-			break;
-		}
-	}
-}
-
-static char cerr_printk_buf[2048];
-static void cerr_printk(const char *fmt, ...)
-{
-	va_list args;
-	int len;
-	int i = 0;
-
-	va_start(args, fmt);
-	len = vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
-	va_end(args);
-
-	for (i = 0; i <= len; i++) {
-
-		if (cerr_printk_buf[i] == 0)
-			continue;
-
-		if (cerr_printk_buf[i] == '\n')
-			cerr_outbyte('\r');
-
-		cerr_outbyte(cerr_printk_buf[i]);
-	}
-
-}
-
-#ifdef CONFIG_NLM_XLR
-
-static char *bridge_aerr_intr_devstat[] = {
-	[0] = "cpu 0",
-	[1] = "cpu 1",
-	[2] = "cpu 2",
-	[3] = "cpu 3",
-	[4] = "cpu 4",
-	[5] = "cpu 5",
-	[6] = "cpu 6",
-	[7] = "cpu 7",
-
-	[8] = "L2",
-	[9] = "XGS 0",
-	[10] = "XGS 1",
-	[11] = "GMAC",
-	[12] = "SEC",
-	[13] = "PCIX",
-	[14] = "HT",
-	[15] = "DMA",
-};
-
-static void print_cerr_info(void)
-{
-	__u64 cerr_cpu_log = 0;
-	int i = 0;
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
-	__u32 tmp = 0;
-
-	cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
-			( ((__u64)netlogic_read_reg(mmio, 39)<<5) | ((__u64)netlogic_read_reg(mmio, 40)<<37) ),
-			netlogic_read_reg(mmio, 41));
-
-	cerr_printk("Bridge: The devices reporting AERR are:\n");
-	tmp = netlogic_read_reg(mmio, 41);
-	for(i = 0; i < 16; i++) {
-		if (tmp & (1<<i)) xlr_cerr_printk("\t%s\n", bridge_aerr_intr_devstat[i]);
-	}
-
-	cerr_cpu_log = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
-	cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
-			cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
-}
-
-#else
-
-static void print_cerr_info(void)
-{
-	nlm_reg_t *nbu_mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
-
-	uint64_t icu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
-	uint64_t icu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
-	uint64_t icu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
-	uint64_t lsu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
-	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
-	uint64_t scu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
-	uint64_t scu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
-	uint64_t scu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
-
-	cerr_printk("CPU: (XLP specific) ICU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n"
-		    "                    LSU log0 = 0x%016llx, log1 = 0x%016llx\n"
-		    "                    SCU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n",
-		    icu_log0, icu_log1, icu_log2,
-		    lsu_log0, lsu_log1,
-		    scu_log0, scu_log1, scu_log2);
-
-	cerr_printk("NBU: Bar Aerr reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
-		    netlogic_read_reg(nbu_mmio, 162), netlogic_read_reg(nbu_mmio, 163),
-		    netlogic_read_reg(nbu_mmio, 164) );
-}
-
-#endif
-
-/* On XLR/XLP, errors reported by bridge (like misconfigured BARS etc) are also
- * reported as cache errors. Need to check if it is really a cache error or a "bus error"
- * and take action appropriately.
- * For now, treat it as a cache error
- */
-asmlinkage void nlm_cache_error(void)
-{
-	local_irq_disable();
-
-	/* let the first cpu in */
-	while (nlm_cerr_lock) ;
-	nlm_cerr_lock = 1;
-
-	cerr_printk("*********************************************\n");
-	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
-	cerr_printk("*********************************************\n");
-
-	print_cerr_info();
-
-	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
-			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
-
-	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
-
-	cerr_cpu_halt();
-}
-
-- 
1.7.0.4

