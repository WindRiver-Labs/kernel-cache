From 8e9695c1620a36191a43b9b013af541cfb02120a Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Thu, 28 Oct 2010 12:44:13 -0700
Subject: [PATCH 218/762] Use NLM atomic insn only for XLR

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/atomic.h             |    8 ++++----
 arch/mips/include/asm/netlogic/mips-exts.h |    4 ++++
 arch/mips/netlogic/xlp/on_chip.c           |    4 ++--
 3 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/arch/mips/include/asm/atomic.h b/arch/mips/include/asm/atomic.h
index 6943da9..240e4f3 100644
--- a/arch/mips/include/asm/atomic.h
+++ b/arch/mips/include/asm/atomic.h
@@ -49,7 +49,7 @@
  */
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 	ldadd_w_no_read(i, &v->counter);
 #else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
@@ -96,7 +96,7 @@ static __inline__ void atomic_add(int i, atomic_t * v)
  */
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 	ldadd_w_no_read(-i,&v->counter);
 #else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
@@ -143,7 +143,7 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 	result = ldadd_w(i, &v->counter);
 	result += i;
 #else
@@ -199,7 +199,7 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 	result = ldadd_w(-i, &v->counter);
 	result -= i;
 #else
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index e618ee1..75e5b34 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -174,6 +174,7 @@ static inline void write_64bit_cp0_eimr(__u64 value)
 	: "$1", "$2");
 }
 
+#ifdef CONFIG_NLM_XLR
 static __inline__ int ldadd_w(unsigned int value, volatile int *addr)
 {
 	unsigned long res;
@@ -248,6 +249,7 @@ static __inline__ void ldadd_wu_no_read(unsigned int value,
                        : "$8", "$9"
                        );
 }
+#endif /* CONFIG_NLM_XLR */
 
 static __inline__ int hard_smp_processor_id(void)
 {
@@ -387,6 +389,7 @@ static __inline__ void write_64bit_nlm_ctrl_reg(int block, int reg,unsigned long
 
 typedef struct { volatile int value; } nlm_common_atomic_t;
 
+#ifdef CONFIG_NLM_XLR
 static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
 {
   int oldval = 0;
@@ -405,6 +408,7 @@ static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
 			);
   return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
 }
+#endif /* CONFIG_NLM_XLR */
 
 #define nlm_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
 #define nlm_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 60c78a2..6457eec 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -267,9 +267,9 @@ int register_xlp_msgring_handler(int major,
 	msg_handler_map[major].dev_id = dev_id;
 
 	ret = 0;
-	spin_unlock_irqrestore(&msgrng_lock, flags);
+	msgring_registered.value = 1;
 
-	nlm_common_test_and_set(&msgring_registered);
+	spin_unlock_irqrestore(&msgrng_lock, flags);
 
 	return ret;
 }
-- 
1.7.0.4

