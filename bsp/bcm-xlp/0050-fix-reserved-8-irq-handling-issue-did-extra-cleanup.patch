From bad158f41dcb7c2898322594d9793ee4574d34bf Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Mon, 31 May 2010 03:19:07 -0700
Subject: [PATCH 050/762] fix reserved 8 irq handling issue, did extra cleanup

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c |   80 ++++++------------------------------------
 1 files changed, 11 insertions(+), 69 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index a70d61f..940fee9 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -56,7 +56,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Externs */
 extern void nlm_common_timer_interrupt(struct pt_regs *regs, int irq);
-extern void nlm_common_smp_time_init(void);
 
 extern void *ht_config_base;
 extern int link0, link1;
@@ -127,7 +126,7 @@ void __init init_nlm_common_irqs(void)
 }
 
 #ifdef CONFIG_KGDB
-extern irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs);
+extern irqreturn_t xlp_kgdb_ipi_handler(int irq, struct pt_regs *regs);
 #endif
 #ifdef CONFIG_OPROFILE
 extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
@@ -165,15 +164,8 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 
 void __cpuinit nlm_smp_irq_init(void)
 {
-#ifdef XLP_MERGE_TODO
-	/* Set up kseg0 to be cachable coherent */
-	change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
-#endif
 	/* set interrupt mask for non-zero cpus */
 	write_64bit_cp0_eimr(nlm_common_irq_mask | (1 << IRQ_TIMER));
-#ifdef XLP_MERGE_TODO
-	nlm_common_smp_time_init();
-#endif
 }
 
 /* 
@@ -193,58 +185,10 @@ void destroy_irq(unsigned int irq)
 
 #ifdef CONFIG_PCI_MSI_XLR
 
-#if defined(CONFIG_NLM_XLP)
 static int get_irq_vector(struct pci_dev *dev)
 {
 	return nlm_hal_irt_to_irq(PIC_IRT_PCIE_LINK_INDEX(0));
 }
-#else
-static int get_irq_vector(struct pci_dev *dev)
-{
-
-    int irq = 0;
-
-	if (is_xls() && !is_xls2xx() && !is_xls_b0()) {
-		/* Currently, PCIE bridges not supported */
-		if (link0) {
-			if (dev->bus->number == 1)
-				irq = PIC_PCIE_LINK0_IRQ;
-			else
-				irq = PIC_PCIE_LINK1_IRQ;
-		} else if (link1) {
-			if (dev->bus->number == 1)
-				irq = PIC_PCIE_LINK1_IRQ;
-		}
-	} else if (is_xls2xx() || is_xls_b0()) {
-		switch (dev->bus->self->devfn) {
-		case 0x0:
-			irq = PIC_PCIE_LINK0_IRQ;
-			break;
-		case 0x8:
-			irq = PIC_PCIE_LINK1_IRQ;
-			break;
-		case 0x10:
-			if (is_xls_b0())
-				irq = PIC_PCIE_XLSB0_LINK2_IRQ;
-			else
-				irq = PIC_PCIE_LINK2_IRQ;
-			break;
-		case 0x18:
-			if (is_xls_b0())
-				irq = PIC_PCIE_XLSB0_LINK3_IRQ;
-			else
-				irq = PIC_PCIE_LINK3_IRQ;
-			break;
-		default:
-			break;
-		}
-	} else {
-		irq = PIC_HYPER_IRQ;
-	}
-
-	return irq;
-}
-#endif
 
 static int msi_compose_msg(struct pci_dev *pdev, unsigned int irq,
 			   struct msi_msg *msg)
@@ -321,6 +265,7 @@ void __init arch_init_irq(void)
 
 	write_64bit_cp0_eimr(nlm_common_irq_mask);
 
+//	dumpall_irt_entry();
 }
 
 asmlinkage void plat_irq_dispatch(void)
@@ -347,21 +292,18 @@ asmlinkage void plat_irq_dispatch(void)
 		return;
 	}
 	/*ack eirr */
+	if(i == 58)
+	{
+		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
+	}
 	write_64bit_cp0_eirr(1ULL << i);
+	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
+	if(i == 58)
+	{
+		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
+	}
 	do_nlm_common_IRQ(i, pt_regs);
 	return;
 }
 
 
-void pic_setup_threadmask(unsigned int irt, uint32_t mask)
-{
-#ifdef XLP_MERGE_TODO
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
-	pic_tmask[irt].mask = mask;
-	pic_tmask[irt].set = 1;
-	pic_tmask[irt].valid = 1;
- 	netlogic_write_reg(mmio, PIC_IRT_0_BASE + irt, mask);
-	nlm_hal_write_pic_reg(mmio, PIC_IRT(nlm_hal_irq_to_irt(irq)),(uint32_t) (mask.bits[0]));
-#endif
-	return;
-}
-- 
1.7.0.4

