From 80f0cdbcb74fc25fbddacac2cdeca5b6c45ee53c Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 11 Aug 2010 20:30:55 -0700
Subject: [PATCH 129/761] 1.some extra cleanup. 2. add function to enable
 msgcfg int vector on cpu 1-7

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c |  121 ++++++++++----------------------------
 1 file changed, 30 insertions(+), 91 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index abdb4be..25abbe1 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -23,10 +23,12 @@ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.
 *****************************#NETL_2#********************************/
 
+#include <linux/types.h>
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/timer.h>
 
@@ -52,6 +54,7 @@ spinlock_t msgrng_lock;
 static nlm_common_atomic_t msgring_registered;
 
 static __u32 msgring_thread_mask;
+static void enable_msgconfig_int(void);
 
 static void msgring_enable_timer_int_handler(void);
 
@@ -172,7 +175,7 @@ struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
 	unsigned long mflags;
-	int core;
+	int vcpu;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0;
 	struct msgstn_handler *handler = 0;
@@ -183,12 +186,13 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	irq_enter();
 
-	core = cpu_logical_map(hard_smp_processor_id()) >> 2;
+	vcpu = hard_smp_processor_id() & 0x1f;
+	vcpu = vcpu << 2;
         msgrng_access_enable(mflags);
 
-	//for(int i = 0; i < 10; i++) 
+	/* for(int i = 0; i < 10; i++) */
 	{
-	for( vc = core; vc < (core+4); vc++)
+	for( vc = vcpu; vc < (vcpu + 4); vc++)
 	{
 		status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
 		if(status != 0)
@@ -254,95 +258,20 @@ int register_xlp_msgring_handler(int major,
 
 EXPORT_SYMBOL(register_xlp_msgring_handler);
 
-/*********************************************************************
- *  msgring_bkp_timer 
- *  
- *  @data     parameter that can be passed to timer handler 
- *  
- ********************************************************************/
-static void msgring_bkp_timer(unsigned long data)
-{
-	unsigned long flags;
-	struct timer_list *timer = (struct timer_list *)data;
-	local_irq_save(flags);
-	nlm_xlp_msgring_int_handler(-1,NULL);
-	local_irq_restore(flags);
-	mod_timer(timer, timer->expires+HZ/10000);
-}
 
 /*********************************************************************
- *  enable_msgring_timer 
- *  
- *  @data     timer hander paramete
+ * enable_msgconfig_int 
  *
  ********************************************************************/
-static void enable_msgring_timer(void *data)
-{
-	struct timer_list *timer;
-	timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-	setup_timer(timer, msgring_bkp_timer, (unsigned long)timer);
-	timer->expires = jiffies + HZ/10000;
-	add_timer(timer);
-}
-
-/*********************************************************************
- *  enable_msgring_timer 
- *  
- *  this is xlr inherited routine, here we keep it for test purpose to 
- *  user timer interrupt to call msgring interrupt handler routine 
- * 
- ********************************************************************/
-static void msgring_enable_timer_int_handler()
+static void enable_msgconfig_int()
 {
-	int i, j;
-	cpumask_t timer_cpu_mask;
-
-	if ( nlm_common_test_and_set(&msgring_registered)) {
-		i=0;
-		hard_cpu_online_map = 0;
-		for (i = 0; i < NR_CPUS; i++) {
-			if (cpu_isset(i, cpu_online_map))
-				hard_cpu_online_map |=
-				    (1 << cpu_logical_map(i));
-		}
+        uint32_t val;
+        /* Need write interrupt vector to cp2 msgconfig register */
 
-
-		/* Configure PIC to deliver msgring interrupt for timeouts */
-		if (msgring_global_thread_mask == 0) {
-			for (i = 0; i < NR_CORES; i++) {
-				msgring_global_thread_mask |=
-				    (msgring_thread_mask << (i << 2));
-			}
-		}
-
-		msgring_global_thread_mask &= hard_cpu_online_map;
-
-
-		/* Schedule a messagering backup timer at every 2 jiffies on one 
-		   therad per core 
-		 */
-
-		cpus_clear(timer_cpu_mask);
-		for(i = 0; i < NR_CORES; i++) {
-			int core_mask;			
-			int phys_id, logical_id;
-			if(hard_cpu_online_map & (0xf<<(i*NR_CPUS_PER_CORE))){
-				core_mask = (hard_cpu_online_map>>(i*NR_CPUS_PER_CORE)) & 0xf;
-				for(j=0; j<NR_CPUS_PER_CORE; j++){
-					if(core_mask & (1<<j))
-						break;
-				}
-				phys_id = (i*NR_CPUS_PER_CORE) + j;
-				logical_id = cpu_number_map(phys_id);
-				cpu_set(logical_id, timer_cpu_mask);
-			}
-		}
-                preempt_disable();
-                smp_call_function_many(&timer_cpu_mask, enable_msgring_timer, NULL, 1);
-                preempt_enable();
-                if(cpu_isset(cpu_number_map(hard_smp_processor_id()),timer_cpu_mask))
-                        enable_msgring_timer(NULL);
-	}
+        val =  _read_32bit_cp2_register(XLP_MSG_CONFIG_REG);
+        val &= ~(0x1f << 16);
+        val |= 6 << 16;
+        _write_32bit_cp2_register(XLP_MSG_CONFIG_REG, val);
 }
 
 
@@ -353,8 +282,10 @@ static void msgring_enable_timer_int_handler()
 static void pic_init(void)
 {
 	int i = 0;
-	int level;
-	uint32_t thread_mask = (1 << hard_smp_processor_id());
+	int level, vcpu;
+
+	vcpu = hard_smp_processor_id() & 0x1F;
+	uint32_t thread_mask = (1 << vcpu);
 
 	for (i = 0; i < PIC_NUM_IRTS; i++) {
 
@@ -365,6 +296,16 @@ static void pic_init(void)
 		 */
 		nlm_hal_pic_write_irt(i, 0, 0, 1, nlm_hal_irt_to_irq(i), 1, 0, thread_mask);
 	}
+
+	/* 
+	 each cpu core only has one set of cop2 register,
+	 only need enable msg int vector once 
+	*/
+
+	if( (vcpu % 4) == 0)
+	{
+		enable_msgconfig_int();
+	}
 }
 
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
@@ -416,8 +357,6 @@ void on_chip_init(void)
 	// nlm_hal_pcie_base();
 
 	nlm_hal_fmn_init( xlp_linux_cpu_mask );
-
-	
 	pic_init(); 
 
 	for (i = 0; i < NR_CPUS; i++)
-- 
1.7.10.4

