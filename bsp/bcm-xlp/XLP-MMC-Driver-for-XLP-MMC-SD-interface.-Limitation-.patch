From 0357317021dd7ff2f09b43a3a934f52083c1c39d Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikasg@netlogicmicro.com>
Date: Thu, 28 Apr 2011 11:45:05 +0530
Subject: [PATCH 252/761] XLP MMC: Driver for XLP MMC/SD interface.
 Limitation: Driver is supporting NON-DMA method.

Based on Broadcom SDK 2.3.

Signed-off-by: Vikas Gupta <vikasg@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/platform.c |    1 +
 drivers/mmc/host/Kconfig          |    7 +
 drivers/mmc/host/Makefile         |    1 +
 drivers/mmc/host/xlpmmc.c         |  822 +++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/xlpmmc.h         |  147 +++++++
 5 files changed, 978 insertions(+)
 create mode 100644 drivers/mmc/host/xlpmmc.c
 create mode 100644 drivers/mmc/host/xlpmmc.h

diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index f804a64..5239afe 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -134,6 +134,7 @@ static void xlp_usb_hw_start(int ctrl_no)
 struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
 	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
 	{XLP_DEVID_I2C,	 "i2c-xlp",	8,	0, 	PLAT_DRV},
+	{XLP_DEVID_MMC,	 "mmc-xlp",	8,	0, 	PLAT_DRV},
 	{0x0, 			 "",	0,	0,	PLAT_DRV},
 };
 
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9f99a58..f0387b0 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -270,6 +270,13 @@ config MMC_AU1X
 
 	  If unsure, say N.
 
+config MMC_XLP
+	tristate "XLP MMC/SD/SDIO support interface "
+	depends on CPU_XLP
+	help
+	  This selects the XLP sdio/mmc/sd card interface.
+	  If you have a XLP platform with a MMC slot, say Y or M here.
+
 choice
 	prompt "Atmel SD/MMC Driver"
 	depends on AVR32 || ARCH_AT91
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 3e7e26d..69d6efd 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
+obj-$(CONFIG_MMC_XLP)		+= xlpmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_OMAP_HS)	+= omap_hsmmc.o
 obj-$(CONFIG_MMC_AT91)		+= at91_mci.o
diff --git a/drivers/mmc/host/xlpmmc.c b/drivers/mmc/host/xlpmmc.c
new file mode 100644
index 0000000..5a6993c
--- /dev/null
+++ b/drivers/mmc/host/xlpmmc.c
@@ -0,0 +1,822 @@
+
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic" ). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+/*
+ * linux/drivers/mmc/host/xlpmmc.c - XLP MMC driver
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/leds.h>
+#include <linux/mmc/host.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#include "xlpmmc.h"
+
+#undef XLP_MMC_DEBUG
+struct xlpmmc_host {
+	struct mmc_host *mmc;
+	struct mmc_request *mrq;
+
+	u32 flags;
+	void    __iomem         *base;
+	void* ioarea;
+	u32 clock;
+	u32 bus_width;
+	u32 power_mode;
+	spinlock_t		irq_lock; /* Prevent races with irq handler */
+	int status;
+
+	struct {
+		int len;
+		int dir;
+	} dma;
+
+	struct {
+		int index;
+		int offset;
+		int len;
+	} pio;
+
+	int irq;
+
+	struct xlpmmc_platform_data *platdata;
+	struct platform_device *pdev;
+};
+
+/* Status flags used by the host structure */
+#define HOST_F_XMIT	0x0001
+#define HOST_F_RECV	0x0002
+#define HOST_F_DMA	0x0010
+#define HOST_F_ACTIVE	0x0100
+#define HOST_F_STOP	0x1000
+
+#define HOST_S_IDLE	0x0001
+#define HOST_S_CMD	0x0002
+#define HOST_S_DATA	0x0003
+
+#define PCIE_HDR_OFFSET                0x100
+
+/* Low-level write-routines*/
+static inline void hc_wr32(void *iobase, int offset, u32 data, int slot) {
+
+        int reg_offset = PCIE_HDR_OFFSET + (slot*0x100);
+        volatile u32 *mmc_base = (u32 *)( (u8*)iobase + reg_offset );
+        mmc_base[offset>>2] = data;
+        return;
+}
+
+static inline void hc_wr16(void *iobase, int offset, u16 data, int slot) {
+
+        int reg_offset = PCIE_HDR_OFFSET + (slot*0x100);
+        volatile u16 *mmc_base = (u16 *)( (u8*)iobase + reg_offset );
+
+        mmc_base[offset>>1] = data;
+        return;
+}
+
+/* Low-level read-routines
+ */
+static inline u32 hc_rd32(void *iobase,int offset, int slot) {
+
+        int reg_offset = PCIE_HDR_OFFSET + (slot*0x100);
+        volatile u32 *mmc_base = (u32 *)( (u8*)iobase + reg_offset );
+
+        u32 data = mmc_base[offset>>2];
+        return data;
+}
+
+static inline u32 hc_rd16(void *iobase, int offset, int slot) {
+
+        int reg_offset = PCIE_HDR_OFFSET + (slot*0x100);
+        volatile u16 *mmc_base = (u16 *)( (u8*)iobase + reg_offset );
+
+        u32 data = mmc_base[offset>>1];
+        return data;
+}
+
+static void dump_hc_regs(struct xlpmmc_host *host)
+{
+	printk ("MMC_PRESENT STATE = 0x%x\n", hc_rd32((host->base), HC_PRESENT_STATE_LO, 0));
+	printk ("MMC_POWER_CTL = 0x%x\n", hc_rd16((host->base), HC_PC_HC, 0));
+	printk ("MMC_CLOK_CTL = 0x%x\n", hc_rd16((host->base), HC_CLOCK_CTRL, 0));
+}
+
+static void xlpmmc_set_power(struct xlpmmc_host *host, int state)
+{	
+	if(state)
+		hc_wr16(host->base, HC_PC_HC, 0x1f00, 0);
+	else
+		hc_wr16(host->base, HC_PC_HC, 0x1e00, 0);
+}		
+
+static int xlpmmc_card_inserted(struct mmc_host *mmc)
+{
+	//struct xlpmmc_host *host = mmc_priv(mmc);
+	return 1;
+}
+
+static int xlpmmc_card_readonly(struct mmc_host *mmc)
+{
+	//struct xlpmmc_host *host = mmc_priv(mmc);
+	return -ENOSYS;
+}
+
+static void xlpmmc_finish_request(struct xlpmmc_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+#ifdef XLP_MMC_DEBUG	
+	printk("xlpmmc_finish_request mrq= %p\n", mrq);
+#endif
+	host->mrq = NULL;
+	host->flags &= HOST_F_ACTIVE | HOST_F_DMA;
+
+	host->dma.len = 0;
+	host->dma.dir = 0;
+
+	host->pio.index  = 0;
+	host->pio.offset = 0;
+	host->pio.len = 0;
+
+	host->status = HOST_S_IDLE;
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static int xlpmmc_send_command(struct xlpmmc_host *host, int wait,
+				struct mmc_command *cmd, struct mmc_data *data)
+{
+	int rsp_type;
+	u32 mmccmd = 0;
+	volatile u32 hcstate = 0;
+	
+	/* Parse the command and set the CMD and XFER reg accordingly */
+	mmccmd = (cmd->opcode << CMD_IDX_SHT);
+
+	/*Command type*/
+	rsp_type = mmc_resp_type(cmd);
+	switch (rsp_type) {
+	case MMC_RSP_NONE:
+		mmccmd |= RSP_TYPE_NONE;
+		break;
+	case MMC_RSP_R1:
+		mmccmd |= RSP_TYPE_R1;
+		break;
+	case MMC_RSP_R1B:
+		mmccmd |= RSP_TYPE_R1B;
+		break;
+	case MMC_RSP_R2:
+		mmccmd |= RSP_TYPE_R2;
+		break;
+	case MMC_RSP_R3:
+		mmccmd |= RSP_TYPE_R3;
+		break;
+	default:
+		printk(KERN_INFO "xlpmmc: unhandled response type %02x\n",
+			mmc_resp_type(cmd));
+		return -EINVAL;
+	}
+
+#ifdef XLP_MMC_DEBUG
+	printk("xlpmmc_send_command : cmd-opcode=%d mmc_data= %p rep= 0x%x cm-arg=0x%x\n", cmd->opcode, data, rsp_type,cmd->arg);
+#endif
+	
+	/*Data direction and count*/
+	if (data) {
+		//if((rsp_type != RSP_TYPE_R1B) && (rsp_type != RSP_TYPE_R5B) )/*do we ever come here?*/
+		if((rsp_type != RSP_TYPE_R1B) )/*do we ever come here?*/
+			mmccmd |= DP_DATA;
+
+		/*enable block count*/	
+		mmccmd |= (1<<1);
+		
+		if (data->blocks == 1){
+			mmccmd |= MBS_SINGLE;
+		}
+		else{
+			mmccmd |= MBS_MTPLE; 
+			mmccmd |= AUTO_CMD12_EN;  
+		}
+
+		if (data->flags & MMC_DATA_READ) {
+			mmccmd |= DDIR_READ;
+		
+		} else if (data->flags & MMC_DATA_WRITE) {
+			mmccmd |= DDIR_WRITE;
+		}
+	}else{
+		mmccmd |= DP_NO_DATA; 
+	}
+
+	/*Wait for CMD line to free. Safe to poll 
+	as HOST CMD line could have been resetted.*/
+	hcstate = hc_rd32(host->base, 0x24, 0);
+	do{
+		/*Should never stuck here*/
+		hcstate = hc_rd32(host->base, 0x24, 0);
+	}while(hcstate & 0x1);
+
+	hc_wr32(host->base, HC_ARG1_LO, cmd->arg, 0);
+	hc_wr32(host->base, HC_COMMAND, mmccmd, 0);	
+	return 0;
+}
+
+static void xlpmmc_data_complete(struct xlpmmc_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data;
+
+	WARN_ON((host->status != HOST_S_DATA));
+
+	if (host->mrq == NULL)
+		return;
+	
+	data = mrq->cmd->data;
+
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
+	
+	data->bytes_xfered = 0;
+
+	if (!data->error) {
+		data->bytes_xfered =
+		(data->blocks * data->blksz) - host->pio.len;
+	}
+		
+	xlpmmc_finish_request(host);
+}
+
+
+static void xlpmmc_send_pio(struct xlpmmc_host *host)
+{
+	struct mmc_data *data;
+	int sg_len, max, count;
+	unsigned char *sg_ptr;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_XMIT))
+		return;
+	
+	/* This is the pointer to the data buffer */
+	sg = &data->sg[host->pio.index];
+	sg_ptr = sg_virt(sg) + host->pio.offset;
+
+	/* This is the space left inside the buffer */
+	sg_len = data->sg[host->pio.index].length - host->pio.offset;
+
+	/* Check if we need less than the size of the sg_buffer */
+	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
+	if (max > MMCSD_SECTOR_SIZE)
+		max = MMCSD_SECTOR_SIZE;
+
+	for (count = 0; count < max/4; count++) {
+		u8 write_data[4];
+		
+		write_data[3] = *sg_ptr++ & 0xff; 
+		write_data[2] = *sg_ptr++ & 0xff; 
+		write_data[1] = *sg_ptr++ & 0xff; 
+		write_data[0] = *sg_ptr++ & 0xff;
+		hc_wr32(host->base, HC_BUFF_DATA_PORT0, *(u32*)write_data, 0);
+	}
+	count=count<<2;
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+}
+
+static void xlpmmc_receive_pio(struct xlpmmc_host *host)
+{
+	struct mmc_data *data;
+	int max, count, sg_len = 0;
+	unsigned char *sg_ptr = NULL;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_RECV))
+		return;
+
+	max = host->pio.len;
+
+	if (host->pio.index < host->dma.len) {
+		sg = &data->sg[host->pio.index];
+		sg_ptr = sg_virt(sg) + host->pio.offset;
+
+		/* This is the space left inside the buffer */
+		sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
+
+		/* Check if we need less than the size of the sg_buffer */
+		if (sg_len < max)
+			max = sg_len;
+	}
+	if (max > MMCSD_SECTOR_SIZE){
+		max = MMCSD_SECTOR_SIZE;
+	}
+
+	for (count = 0; count < max/4; count++) {
+		volatile uint32_t read_data;
+		read_data = hc_rd32(host->base, HC_BUFF_DATA_PORT0, 0);
+			*sg_ptr++ = (unsigned char)((read_data >>  0) & 0xFF);
+			*sg_ptr++ = (unsigned char)((read_data >>  8) & 0xFF);
+			*sg_ptr++ = (unsigned char)((read_data >>  16) & 0xFF);
+			*sg_ptr++ = (unsigned char)((read_data >>  24) & 0xFF);
+	}
+	count = count<<2;
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (sg_len && count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+}
+
+/*
+  1)This is called when a command has been completed - grab the response
+     and check for errors. Then start the data transfer if it is indicated.
+  2) Notify the core about command completion 
+*/
+static void xlpmmc_cmd_complete(struct xlpmmc_host *host, u32 status)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd;
+	u32 r[4];
+	int i, trans;
+
+	if (!host->mrq)
+		return;
+
+	cmd = mrq->cmd;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			r[0] = hc_rd32(host->base, HC_RESPONSE6, 0);
+			r[1] = hc_rd32(host->base, HC_RESPONSE4, 0);
+			r[2] = hc_rd32(host->base, HC_RESPONSE2, 0);
+			r[3] = hc_rd32(host->base, HC_RESPONSE0, 0);
+			for (i = 0; i < 4; i++) {
+				cmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;
+				if (i != 3)
+					cmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;
+			}
+#ifdef XLP_MMC_DEBUG
+			printk("RESP0 =0x%x RESP1 =0x%x RESP2 = 0x%x RESP3=0x%x\n ",  cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+#endif
+		}else{ 
+			cmd->resp[0] = hc_rd32(host->base, HC_RESPONSE0,0);
+		}
+	}
+
+	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
+
+	if (!trans || cmd->error) {
+		xlpmmc_finish_request(host); 
+		return;
+	}
+	host->status = HOST_S_DATA;
+}
+
+static void xlpmmc_set_clock(struct xlpmmc_host *host, int rate)
+{
+	u32 sd_bclk_fq;
+	u16 dsor = 0;
+	u16 sd_ck_fs = 0;
+	u16 hc_clk_ctl=0;
+	/* i) Read the base clock.
+	   ii) find the divisior.
+	   iii)TODO: Add boundry conditions for dsor if req */
+
+	sd_bclk_fq = (0x85)*1000; /* reset value 133 MHz */ 
+	rate= rate/1000;
+	dsor =  sd_bclk_fq / rate ;
+	sd_ck_fs = dsor>>1;
+	
+	hc_clk_ctl  = (sd_ck_fs<<SD_CLK_FRQ_SHT) |  HCC_INT_CLK_EN | HCC_SD_CLK_EN;
+	hc_wr16(host->base, HC_CLOCK_CTRL, hc_clk_ctl, 0);
+
+	/* Wait for stable clock */
+	while ((hc_rd16(host->base, HC_CLOCK_CTRL,0) & HCC_INT_CLK_STABLE) == 0) {};
+
+	return;	
+}
+
+static int xlpmmc_prepare_data(struct xlpmmc_host *host,
+				struct mmc_data *data)
+{
+	int datalen = data->blocks * data->blksz;
+	u32 mmc_blk_ctl = 0;
+#ifdef XLP_MMC_DEBUG
+	printk("xlpmmc_prepare_data datablks=%d\n", data->blocks);
+#endif
+	if (data->flags & MMC_DATA_READ)
+		host->flags |= HOST_F_RECV;
+	else
+		host->flags |= HOST_F_XMIT;
+
+	if (host->mrq->stop)
+		host->flags |= HOST_F_STOP;
+
+	host->dma.dir = DMA_BIDIRECTIONAL;
+
+	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				   data->sg_len, host->dma.dir);
+
+	if (host->dma.len == 0)
+		return -ETIMEDOUT;
+
+	if(data->blocks > 1)	/*Multiple block transfer?*/
+		mmc_blk_ctl |=  data->blocks<<BLK_CNT_SHT;
+	else
+		mmc_blk_ctl &= 0xffff;
+	/*block size bit Xsz[0:11]=[0:11] and Xsz[12]=[15]*/
+	//mmc_blk_ctl |= (data->blksz<< 0)&(0xfff);
+	mmc_blk_ctl |= (data->blksz<< 0);
+	if(data->blksz & BLK_SZ_LOW_BITS)
+		mmc_blk_ctl |= BLK_SZ_HGH_BIT;
+	else
+		mmc_blk_ctl &= ~BLK_SZ_HGH_BIT;
+	hc_wr32(host->base, HC_BLOCK_SIZE, mmc_blk_ctl, 0);
+	
+	host->pio.index = 0;
+	host->pio.offset = 0;
+	host->pio.len = datalen;
+	
+	return 0;
+}
+
+/* This actually starts a command or data transaction */
+static void xlpmmc_request(struct mmc_host* mmc, struct mmc_request* mrq)
+{
+	struct xlpmmc_host *host = mmc_priv(mmc);
+	int ret = 0;
+
+	WARN_ON(irqs_disabled());
+	WARN_ON(host->status != HOST_S_IDLE);
+
+	host->mrq = mrq;
+	host->status = HOST_S_CMD;
+
+	/* fail request immediately if no card is present */
+#if 0	
+	if (0 == xlpmmc_card_inserted(mmc)) {
+		mrq->cmd->error = -ENOMEDIUM;
+		xlpmmc_finish_request(host);
+		return;
+	}
+	/* No platform support to know card detection */
+#endif
+	if (mrq->data) {
+		ret = xlpmmc_prepare_data(host, mrq->data);
+	}
+
+	if (!ret)
+		ret = xlpmmc_send_command(host, 0, mrq->cmd, mrq->data);
+
+	if (ret) {
+		mrq->cmd->error = ret;
+		xlpmmc_finish_request(host);
+	}
+}
+
+static void xlpmmc_reset_controller(struct xlpmmc_host *host)
+{
+	hc_wr32(host->base, HC_SYSCTRL,0x14, 0);
+
+        /* S1: Clear any set INT Bits */
+        hc_wr32(host->base, HC_NORMAL_INT_STS, hc_rd32(host->base, HC_NORMAL_INT_STS,0), 0);
+
+        /* S2: Enable Interrupts */
+        hc_wr32(host->base, HC_NORMAL_INT_STS_EN, 0x37ff7fff, 0);
+
+        /* S3: Enable Interrupt Signals */
+        hc_wr32(host->base, HC_NORMAL_INT_SIGNAL_EN, 0x37ff7fff, 0);
+
+        /* S4: Send HW Reset to eMMC-4.4 Card */
+        hc_wr16(host->base, HC_PC_HC, 0x1e00, 0);
+        hc_wr16(host->base, HC_PC_HC, 0x1f00, 0);
+
+        /* S4: Remove HW Reset to eMMC-4.4 Card */
+        hc_wr16(host->base, HC_PC_HC, 0x0f00, 0);
+
+        hc_wr16(host->base, HC_SWRST_TIMEOUT_CTRL,0xe,0) ;
+        printk("Initialized eMMC Host Controller\n");
+
+        return;
+}
+
+static void xlpmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct xlpmmc_host *host = mmc_priv(mmc);
+	u16 hc_pc_hc;
+#ifdef XLP_MMC_DEBUG
+	printk("xlpmmc_set_ios  ios = %p power = 0x%x clock = 0x%x bus-width=0x%x\n", ios, ios->power_mode, ios->clock, ios->bus_width);	
+#endif
+
+	/*Power */
+	if (ios->power_mode == MMC_POWER_OFF)
+		xlpmmc_set_power(host, 0);
+	else if (ios->power_mode == MMC_POWER_ON) {
+		xlpmmc_set_power(host, 1);
+	}
+	msleep(5);
+	/* Clock */
+	if (ios->clock && ios->clock != host->clock) {
+		xlpmmc_set_clock(host, ios->clock);
+		host->clock = ios->clock;
+	}
+	
+	/*BUS width*/
+	hc_pc_hc = hc_rd16(host->base, HC_PC_HC, 0);
+	
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_4:
+		hc_pc_hc |= HC_HCR_4BIT_MODE;
+		break;
+	case MMC_BUS_WIDTH_1:
+		hc_pc_hc &= ~HC_HCR_4BIT_MODE;
+		break;
+	}
+	hc_wr16 (host->base, HC_PC_HC, hc_pc_hc, 0);
+	msleep(5);
+#ifdef XLP_MMC_DEBUG
+	dump_hc_regs(host);
+#endif
+}
+
+static irqreturn_t xlpmmc_irq(int irq, void *dev_id)
+{
+	struct xlpmmc_host *host = dev_id;
+	volatile short intstatus;
+	spin_lock(&host->irq_lock);
+
+	intstatus = hc_rd16(host->base, HC_NORMAL_INT_STS, 0);
+#ifdef XLP_MMC_DEBUG
+	printk("got xlpmmc_irq status = 0x%x\n", intstatus);	
+#endif
+	hc_wr16(host->base, HC_NORMAL_INT_STS, intstatus, 0);	
+
+/*	if (status & HNIS_CARD_INT )	
+		mmc_signal_sdio_irq(host->mmc); */
+	/*Error Interrupt*/
+	if(intstatus & HNIS_ERR){
+		volatile short interrsts;
+		u16 handle_err=0;
+		handle_err = 0x1; /*TODO : Add error codes here*/
+		interrsts = hc_rd16(host->base, HC_ERROR_INT_STS, 0);	  
+#ifdef XLP_MMC_DEBUG
+		printk("INT ERR: error status  = 0x%x\n", interrsts);
+#endif
+		hc_wr16(host->base, HC_ERROR_INT_STS, interrsts, 0);
+		if(interrsts & handle_err){	
+			/*Reset the CMD line*/
+			interrsts =  hc_rd16(host->base, HC_SWRST_TIMEOUT_CTRL, 0);
+			interrsts |= SW_RST_CMD; 
+			hc_wr16(host->base, HC_SWRST_TIMEOUT_CTRL, interrsts, 0);	
+			host->mrq->cmd->error = -ETIMEDOUT;
+			
+		} 
+		xlpmmc_cmd_complete(host, intstatus);
+		spin_unlock(&host->irq_lock);
+		return IRQ_HANDLED;
+	}
+
+	if(intstatus & HNIS_CMD_CMPL){	
+		if (host->status == HOST_S_CMD)
+			xlpmmc_cmd_complete(host, intstatus);
+
+	} 
+	 if (!(host->flags & HOST_F_DMA)) {
+		if ((host->flags & HOST_F_XMIT) && (intstatus & HNIS_BUFF_WR_RDY))
+			xlpmmc_send_pio(host);
+		else if ((host->flags & HOST_F_RECV) && (intstatus & HNIS_BUFF_RD_RDY))
+			xlpmmc_receive_pio(host);
+		else if( ((host->flags & HOST_F_RECV) || (host->flags & HOST_F_XMIT))&&(intstatus & HNIS_TC_CMPL))
+			xlpmmc_data_complete(host);
+			
+
+	} else if (intstatus |= 0x33) { /*TODO: change it as we enable other interrupts in signal register*/
+			printk("Unhandled status 0x%x\n",intstatus);
+	}
+	
+	spin_unlock(&host->irq_lock);
+	return IRQ_HANDLED;
+}
+
+
+static const struct mmc_host_ops xlpmmc_ops = {
+	.request	= xlpmmc_request,
+	.set_ios	= xlpmmc_set_ios,
+	.get_ro		= xlpmmc_card_readonly,
+	.get_cd		= xlpmmc_card_inserted,
+	//.enable_sdio_irq = xlpmmc_enable_sdio_irq,
+};
+
+static int __devinit xlpmmc_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct xlpmmc_host *host;
+	struct resource *r;
+	int ret;
+
+	mmc = mmc_alloc_host(sizeof(struct xlpmmc_host), &pdev->dev);
+	if (!mmc) {
+		dev_err(&pdev->dev, "no memory for mmc_host\n");
+		ret = -ENOMEM;
+		goto out0;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->platdata = pdev->dev.platform_data;
+	host->pdev = pdev;
+
+	ret = -ENODEV;
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no mmio defined\n");
+		goto out1;
+	}
+
+	host->ioarea = request_mem_region(r->start, r->end - r->start + 1,
+					   pdev->name);
+	if (!host->ioarea) {
+		dev_err(&pdev->dev, "mmio already in use\n");
+		goto out1;
+	}
+
+	host->base = (void *)ioremap_nocache(r->start, PAGE_SIZE);
+	if (!host->base) {
+		dev_err(&pdev->dev, "cannot remap mmio\n");
+		goto out2;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no IRQ defined\n");
+		goto out3;
+	}
+
+	host->irq = r->start;
+	ret = request_irq(host->irq, xlpmmc_irq, IRQF_SHARED,
+			  "xlp-mmc", host);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot grab IRQ\n");
+		goto out3;
+	}
+
+	mmc->ops = &xlpmmc_ops;
+
+	mmc->f_min =     260000; /* From bootloader */
+	mmc->f_max =   16667000;  
+	spin_lock_init(&host->irq_lock);
+
+	/*Set max_seg_size in case of DMA*/
+	/*-------------------------------*/
+
+	mmc->max_blk_size = 512;
+	mmc->max_blk_count = 2048;
+
+	mmc->ocr_avail = XLPMMC_OCR; /* volt 2.70 ~ 3.60 */
+	
+	//mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_NEEDS_POLL;
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+
+	host->status = HOST_S_IDLE;
+
+	xlpmmc_reset_controller(host);
+
+	ret = mmc_add_host(mmc);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot add mmc host\n");
+		goto out6;
+	}
+
+	platform_set_drvdata(pdev, host);
+
+	printk(KERN_INFO "xlp-mmc " ": MMC Controller %d set up at %p"
+		" (mode=%s)\n", pdev->id, host->base,
+		host->flags & HOST_F_DMA ? "dma" : "pio");
+
+	return 0;	/*Everything is OK */
+
+out6:
+	/*Disable the host if init fails*/
+	/*---------------*/
+
+	free_irq(host->irq, host);
+out3:
+	iounmap((void *)host->base);
+out2:
+	release_resource(host->ioarea);
+	kfree(host->ioarea);
+out1:
+	mmc_free_host(mmc);
+out0:
+	return ret;
+}
+
+static int __devexit xlpmmc_remove(struct platform_device *pdev)
+{
+	struct xlpmmc_host *host = platform_get_drvdata(pdev);
+	
+	if (host) {
+		mmc_remove_host(host->mmc);
+		
+		xlpmmc_set_power(host, 0);
+		
+		free_irq(host->irq, host);
+		iounmap((void *)host->base);
+		release_resource(host->ioarea);
+		kfree(host->ioarea);
+
+		mmc_free_host(host->mmc);
+		platform_set_drvdata(pdev, NULL);
+	
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int xlpmmc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	//TODO: Implement if required. 
+	return 0;
+}
+
+static int xlpmmc_resume(struct platform_device *pdev)
+{
+	//TODO: Implement if required. 
+	return 0;
+}
+#else
+#define xlpmmc_suspend NULL
+#define xlpmmc_resume NULL
+#endif
+
+static struct platform_driver xlpmmc_driver = {
+	.probe         = xlpmmc_probe,
+	.remove        = xlpmmc_remove,
+	.suspend       = xlpmmc_suspend,
+	.resume        = xlpmmc_resume,
+	.driver        = {
+		.name  = "mmc-xlp",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init xlpmmc_init(void)
+{
+	return platform_driver_register(&xlpmmc_driver);
+}
+
+static void __exit xlpmmc_exit(void)
+{
+	platform_driver_unregister(&xlpmmc_driver);
+}
+
+module_init(xlpmmc_init);
+module_exit(xlpmmc_exit);
+
+MODULE_AUTHOR("Netlogic Microsystems");
+MODULE_DESCRIPTION("MMC/SD driver for the XLP");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:xlp-mmc");
diff --git a/drivers/mmc/host/xlpmmc.h b/drivers/mmc/host/xlpmmc.h
new file mode 100644
index 0000000..2871048
--- /dev/null
+++ b/drivers/mmc/host/xlpmmc.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
+ * reserved. Redistribution and use in source and binary forms, with 
+ * or without modification, are permitted provided that the following 
+ * conditions are met:
+ *
+ *	1. 	Redistributions of source code must retain the above copyright
+ *		notice, this list of conditions and the following disclaimer.
+ *
+ *	2. 	Redistributions in binary form must reproduce the above copyright
+ *		notice, this list of conditions and the following disclaimer in
+ *		the documentation and/or other materials provided with the
+ *		distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * --------------------------------#NETL_2#--------------------------------
+ */
+#ifndef __XLP_MMC_HC__
+#define __XLP_MMC_HC__
+
+/*Host controller RESPONSE defines */
+
+#define RSP_TYPE_MASK                   (0x3 << 16)
+#define RSP_TYPE_NORSP                  (0x0 << 16)
+#define RSP_TYPE_LGHT136                (0x1 << 16)
+#define RSP_TYPE_LGHT48                 (0x2 << 16)
+#define RSP_TYPE_LGHT48B                (0x3 << 16)
+#define CCCE_NOCHECK                    (0x0 << 19)
+#define CCCE_CHECK                      (0x1 << 19)
+#define CICE_NOCHECK                    (0x0 << 20)
+#define CICE_CHECK                      (0x1 << 20)
+#define DP_NO_DATA                      (0x0 << 21)
+#define DP_DATA                         (0x1 << 21)
+#define DDIR_WRITE                      (0x0 << 4)
+#define DDIR_READ                       (0x1 << 4)
+#define MBS_SINGLE			(0x0 << 5)
+#define MBS_MTPLE			(0x1 << 5)
+
+/* Response types */
+#define RSP_TYPE_NONE   (RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R1     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R1B    (RSP_TYPE_LGHT48B | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R2     (RSP_TYPE_LGHT136 | CCCE_CHECK   | CICE_NOCHECK)
+#define RSP_TYPE_R3     (RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R4     (RSP_TYPE_LGHT48  | CCCE_NOCHECK | CICE_NOCHECK)
+#define RSP_TYPE_R5     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R6     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+#define RSP_TYPE_R7     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
+
+
+/*Command Support Registers*/	
+
+#define HC_SDMA_SA_OR_ARG2_LO 		0x0000 
+#define HC_SDMA_SA_OR_ARG2_HI 		0x0002 
+#define HC_BLOCK_SIZE 			0x0004
+#define HC_BLOCK_COUNT 			0x0006
+	#define BLK_CNT_SHT			16
+	#define BLK_SZ_LOW_BITS			(1<<12)
+	#define BLK_SZ_HGH_BIT			(1<<15)
+
+#define HC_ARG1_LO 			0x0008
+	#define AUTO_CMD12_EN			(1<<2)
+	
+#define HC_ARG1_HI  			0x000A
+#define HC_TRANSFER_MODE 		0x000C
+	#define CMD_IDX_SHT			24
+	#define HC_CMD_INDEX_CHK_EN		(1<<4)
+	#define HC_CMD_CRC_CHK_EN		(1<<3)
+
+#define HC_COMMAND 			0x000E
+#define HC_DATA_PRESENT_SEL		0x0020
+
+
+/*Data Port Registers */
+#define HC_BUFF_DATA_PORT0 		0x0020
+#define HC_BUFF_DATA_PORT1 		0x0022
+
+/*Controller status and control registers*/
+#define HC_PRESENT_STATE_LO 		0x0024
+#define HC_PRESENT_STATE_HI 		0x0026
+#define HC_PC_HC			0x0028
+#define HC_WC_BGC			0x002A
+#define HC_CLOCK_CTRL 		       	0x002C
+	#define SD_CLK_FRQ_SHT				8
+	#define HCC_INT_CLK_EN 				(1<<0)
+	#define HCC_INT_CLK_STABLE          		(1<<1)
+	#define HCC_SD_CLK_EN 				(1<<2)
+#define HC_SYSCTRL 	       	        0x0200 
+#define HC_SWRST_TIMEOUT_CTRL 		0x002E
+	#define  SW_RST_CMD				(1<<9)
+
+/*Response registers*/
+#define HC_RESPONSE0 			0x0010
+#define HC_RESPONSE1 			0x0012
+#define HC_RESPONSE2 			0x0014
+#define HC_RESPONSE3 			0x0016
+#define HC_RESPONSE4 			0x0018
+#define HC_RESPONSE5 			0x001A
+#define HC_RESPONSE6 			0x001C
+#define HC_RESPONSE7 			0x001E
+
+/*Interrupt Registers*/
+#define HC_NORMAL_INT_STS 		0x0030
+	#define HNIS_CMD_CMPL 				(1<<0) /* command completion intr. */
+	#define HNIS_TC_CMPL 				(1<<1) /* transaction completion intr. */
+	#define HNIS_BUFF_RD_RDY			(1<<5) /* ready to read buffer intr. */
+	#define HNIS_BUFF_WR_RDY			(1<<4) /* write buffer ready  intr. */
+	#define HNIS_ERR 				(1<<15) /* An error Interrupt */
+#define HC_ERROR_INT_STS 		0x0032
+	#define	CMD_TIMEOUT_ERR				(1<<0) 
+#define HC_NORMAL_INT_STS_EN 		0x0034
+#define HC_ERROR_INT_STS_EN 		0x0036
+#define HC_NORMAL_INT_SIGNAL_EN 	0x0038
+#define HC_ERROR_INT_SIGNAL_EN 		0x003A
+#define HC_AUTO_CMD_ERROR_STS 		0x003C
+
+
+/*Sector size*/
+#define MMCSD_SECTOR_SIZE           512
+#define HC_HCR_4BIT_MODE            0x2
+
+
+#define XLPMMC_OCR (MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 | \
+		     MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 | \
+		     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36)
+#endif/*_XLP_MMC_HC_*/
+
+
+
+
+
+
+
+
+
+
+
-- 
1.7.10.4

