From c917d26b7a194deb1baca1ae37c35a68a7a2b120 Mon Sep 17 00:00:00 2001
From: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Date: Tue, 28 Sep 2010 19:05:55 +0530
Subject: [PATCH 213/762] KGDB support.

Based on Broadcom SDK 2.3.

Signed-off-by: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/bootinfo.h |    3 ---
 arch/mips/kernel/kgdb.c                   |    7 +++++--
 arch/mips/netlogic/common/smp.c           |    2 ++
 arch/mips/netlogic/xlp/smp.c              |    5 ++++-
 arch/mips/netlogic/xlr/setup.c            |    4 ++--
 5 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 7ac65f4..3486087 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -34,9 +34,6 @@ extern int read_physaddr_map(void);
 
 #ifdef CONFIG_FDT
 extern int wakeup_secondary_cpus(void);
-#else
-extern int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), 
-				 struct psb_info *prom_info);
 #endif
 #endif
 
diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index df6f0a6..d9f7ee1 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -244,6 +244,7 @@ void nlm_kgdb_smp_hook(void)
 	int cpu = smp_processor_id();
 	int cpus = num_online_cpus() - 1;
 	unsigned long flags;
+	extern struct plat_smp_ops *mp_ops;
 
 	BUG_ON(!cpu_online(cpu));
 
@@ -252,8 +253,8 @@ void nlm_kgdb_smp_hook(void)
 
 	spin_lock_irqsave(&nlm_kgdb_lock, flags);
 	for (i = 0; i < NR_CPUS; i++)
-//		if (cpu_online(i) && i != cpu)
-			//core_send_ipi(i, SMP_CALL_KGDB_HOOK);
+		if (cpu_online(i) && i != cpu)
+			mp_ops->send_ipi_single(i, SMP_CALL_KGDB_HOOK);
 	spin_unlock_irqrestore(&nlm_kgdb_lock, flags);
 }
 
@@ -329,8 +330,10 @@ void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
 	regs->cp0_epc = pc;
 }
 
+#ifdef CONFIG_NLM_COMMON
 extern void nlm_common_flush_l1_icache_ipi(void *);
 extern void nlm_common_flush_l1_caches_ipi(void *);
+#endif
 
 #ifdef CONFIG_NLM_COMMON
 irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs)
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index 5f6e6ff..078cf13 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -63,6 +63,8 @@ void core_send_ipi(int logical_cpu, unsigned int action)
 		SET_IPI_VECTOR(ipi, IRQ_IPI_SMP_RESCHEDULE);
 	} else if (action & SMP_CALL_KGDB_HOOK) {
 		SET_IPI_VECTOR(ipi, IRQ_IPI_SMP_KGDB);
+		/* set NMI also for KGDB */
+		SET_IPI_VECTOR(ipi, (1 << 8));
 	} else if (action & SMP_OPROFILE_IPI) {
 		SET_IPI_VECTOR(ipi, IRQ_IPI_OPROFILE);
 	}
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index cd045cd..f137d64 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -63,6 +63,7 @@ void nlm_send_ipi_single(int cpu, unsigned int action)
 {
         __u32 node = cpu / 32;
         __u32 ipi = 0;
+	__u8 nmi = 0;
 	cpu = cpu % 32;
 
         if (action & SMP_CALL_FUNCTION) {
@@ -71,6 +72,8 @@ void nlm_send_ipi_single(int cpu, unsigned int action)
                 ipi |= IRQ_IPI_SMP_RESCHEDULE;
 	} else if (action & SMP_CALL_KGDB_HOOK) {
                 ipi |= IRQ_IPI_SMP_KGDB;
+		/* for KGDB enable NMI also */
+		nmi = 1;
 	} else if (action & SMP_OPROFILE_IPI) {
                 ipi |= IRQ_IPI_OPROFILE;
         } else
@@ -78,7 +81,7 @@ void nlm_send_ipi_single(int cpu, unsigned int action)
 
 	smp_mb();
 
-        nlm_hal_pic_send_ipi(0, (ipi & 0x3f), node, cpu);
+        nlm_hal_pic_send_ipi(nmi, (ipi & 0x3f), node, cpu);
 }
 
 void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index d3ac686..25f70c3 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -990,7 +990,7 @@ static void prepare_wakeup(unsigned long wakeup_fun)
 	
 }
 
-static int wakeup_secondary_cpus(struct psb_info *prom_info)
+static int wakeup_secondary_cpus(void)
 {
 	__u32 wakeup_mask;
 	int i;
@@ -1245,7 +1245,7 @@ void __init prom_init(void)
 
 	smp_boot.online_map = (1 << hard_smp_processor_id());
 
-	wakeup_secondary_cpus(NULL);
+	wakeup_secondary_cpus();
 
 	if (hybrid_str != NULL)
 		xlr_hybrid_setup(hybrid_str);
-- 
1.7.0.4

