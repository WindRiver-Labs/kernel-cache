From 99b677628c128cc70d53290125a2f82c3e7d2d7a Mon Sep 17 00:00:00 2001
From: Mehul <vmehul@netlogicmicro.com>
Date: Tue, 21 Sep 2010 18:45:27 +0530
Subject: [PATCH 225/761] Incorporated Below comments from Prasad, 1)Removed
 changes from process.c. 2)Added "jump
 cop2_save/restore" code in stackframe.h to reduce
 the changes in generic file. 3)Modified
 asm-offsets.c to have only one TX and one RX offset
 macro.

Also, changed traps.c to not to handle "cop2 unusable" exception for user space. Application should no longer get this exception.

Based on Broadcom SDK 2.3.

Signed-off-by: Mehul <vmehul@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/stackframe.h           |   78 ++++------------------
 arch/mips/kernel/asm-offsets.c               |   10 +--
 arch/mips/kernel/process.c                   |    5 --
 arch/mips/kernel/xlr_fast_sys_call_handler.S |   90 ++++++++++++++++++++++++++
 4 files changed, 104 insertions(+), 79 deletions(-)

diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 22a7ee9..e62f346 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -217,36 +217,14 @@
 		LONG_S	v1, PT_EPC(sp)
 		ori	$28, sp, _THREAD_MASK
 		xori	$28, _THREAD_MASK
+
 #ifdef CONFIG_NLM_ENABLE_COP2
-		.set push
-		.set	noat
-		.set noreorder
-		/*msgring tx buf reg*/
-		dmfc2 v1, $0, 0
-		LONG_S  v1, NLM_COP2_TX_BUF_0(sp)
-		dmfc2 v1, $0, 1
-		LONG_S  v1, NLM_COP2_TX_BUF_1(sp)
-		dmfc2 v1, $0, 2
-		LONG_S v1, NLM_COP2_TX_BUF_2(sp)
-		dmfc2 v1, $0, 3
-		LONG_S v1, NLM_COP2_TX_BUF_3(sp)
-	
-		/*msgring rx buf reg*/
-		dmfc2 v1, $1, 0
-		LONG_S  v1, NLM_COP2_RX_BUF_0(sp)
-		dmfc2 v1, $1, 1
-		LONG_S  v1, NLM_COP2_RX_BUF_1(sp)
-		dmfc2 v1, $1, 2
-		LONG_S  v1, NLM_COP2_RX_BUF_2(sp)
-		dmfc2 v1, $1, 3
-		LONG_S  v1, NLM_COP2_RX_BUF_3(sp)
-
-		mfc2 v1, $2, 0
-		sw  v1, NLM_COP2_TX_MSG_STATUS(sp)
-	
-		mfc2 v1, $3, 0
-		sw v1, NLM_COP2_RX_MSG_STATUS(sp)
-		.set pop
+		.set    mips64
+		dla k0, nlm_cop2_save
+		jalr k0
+		nop
+		LONG_L  ra, PT_R31(sp)
+		LONG_L	k0, PT_R29(sp)
 #endif
 
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
@@ -400,45 +378,13 @@
 		ori	a0, STATMASK
 		xori	a0, STATMASK
 		mtc0	a0, CP0_STATUS
+
 #ifdef CONFIG_NLM_ENABLE_COP2
-		.set push
-		.set	noat
-		.set noreorder
-		/*msgring tx buf reg*/
-		LONG_L  v1, NLM_COP2_TX_BUF_0(sp)
-		dmtc2 v1, $0, 0
-		LONG_L  v1, NLM_COP2_TX_BUF_1(sp)
-		dmtc2 v1, $0, 1
-		LONG_L  v1, NLM_COP2_TX_BUF_2(sp)
-		dmtc2 v1, $0, 2
-		LONG_L  v1, NLM_COP2_TX_BUF_3(sp)
-		dmtc2 v1, $0, 3
-
-		/*msgring rx buf reg*/
-		LONG_L  v1, NLM_COP2_RX_BUF_0(sp)
-		dmtc2 v1, $1, 0
-		LONG_L  v1, NLM_COP2_RX_BUF_1(sp)
-		dmtc2 v1, $1, 1
-		LONG_L  v1, NLM_COP2_RX_BUF_2(sp)
-		dmtc2 v1, $1, 2
-		LONG_L  v1, NLM_COP2_RX_BUF_3(sp)
-		dmtc2 v1, $1, 3
-
-		lw  v1, NLM_COP2_TX_MSG_STATUS(sp)
-		mtc2 v1, $2, 0
-	
-		/*leave bits 28-31 up to date*/
-		li k0, 0xf0000000
-		lw v1, NLM_COP2_RX_MSG_STATUS(sp)
-		or v1, k0, v1
-		xor v1, k0, v1
-		mfc2 k0, $3, 0
-		srl k0, k0, 28
-		sll k0, k0, 28
-		or v1, k0, v1
-		mtc2 v1, $3, 0
-		.set pop
+		dla v1, nlm_cop2_restore
+		jalr v1
+		nop
 #endif
+
 		li	v1, 0x4000ff00
 		and	a0, v1
 		LONG_L	v0, PT_STATUS(sp)
diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c
index cb9b0c1..99a8a4b 100644
--- a/arch/mips/kernel/asm-offsets.c
+++ b/arch/mips/kernel/asm-offsets.c
@@ -70,14 +70,8 @@ void output_ptreg_defines(void)
 	OFFSET(PT_MTP, pt_regs, mtp);
 #endif /* CONFIG_CPU_CAVIUM_OCTEON */
 #ifdef CONFIG_NLM_ENABLE_COP2
-	OFFSET(NLM_COP2_TX_BUF_0, pt_regs, tx_buf[0]);
-	OFFSET(NLM_COP2_TX_BUF_1, pt_regs, tx_buf[1]);
-	OFFSET(NLM_COP2_TX_BUF_2, pt_regs, tx_buf[2]);
-	OFFSET(NLM_COP2_TX_BUF_3, pt_regs, tx_buf[3]);
-	OFFSET(NLM_COP2_RX_BUF_0, pt_regs, rx_buf[0]);
-	OFFSET(NLM_COP2_RX_BUF_1, pt_regs, rx_buf[1]);
-	OFFSET(NLM_COP2_RX_BUF_2, pt_regs, rx_buf[2]);
-	OFFSET(NLM_COP2_RX_BUF_3, pt_regs, rx_buf[3]);
+	OFFSET(NLM_COP2_TX_BUF, pt_regs, tx_buf);
+	OFFSET(NLM_COP2_RX_BUF, pt_regs, rx_buf);
 	OFFSET(NLM_COP2_TX_MSG_STATUS, pt_regs, tx_msg_status);
 	OFFSET(NLM_COP2_RX_MSG_STATUS, pt_regs, rx_msg_status);
 	OFFSET(NLM_COP2_MISC_STATUS, pt_regs, misc_status);
diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 22d3bd1..029b4d3 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -170,13 +170,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	 * New tasks lose permission to use the fpu. This accelerates context
 	 * switching for most programs since they don't use the fpu.
 	 */
-#ifdef CONFIG_NLM_ENABLE_COP2
-	p->thread.cp0_status = read_c0_status() & ~(ST0_CU1);
-	childregs->cp0_status &= ~(ST0_CU1);
-#else
 	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
-#endif
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	/*
diff --git a/arch/mips/kernel/xlr_fast_sys_call_handler.S b/arch/mips/kernel/xlr_fast_sys_call_handler.S
index 6464cfd..1dad09c 100644
--- a/arch/mips/kernel/xlr_fast_sys_call_handler.S
+++ b/arch/mips/kernel/xlr_fast_sys_call_handler.S
@@ -224,6 +224,96 @@ NESTED(nlm_uaccess_fs_mem_write32, PT_SIZE, sp)
 	fs_eret
 END(nlm_uaccess_fs_mem_write32)
 
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+/*
+ * void nlm_cop2_save()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in SAVE_SOME in stackframe.h. It can only
+ *       safely modify k0 and k1.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_save)
+	/*msgring tx buf reg*/
+	dmfc2 k0, $0, 0
+	LONG_S  k0, NLM_COP2_TX_BUF(sp)
+	dmfc2 k0, $0, 1
+	LONG_S  k0, (NLM_COP2_TX_BUF+8)(sp)
+	dmfc2 k0, $0, 2
+	LONG_S k0, (NLM_COP2_TX_BUF+16)(sp)
+	dmfc2 k0, $0, 3
+	LONG_S k0, (NLM_COP2_TX_BUF+24)(sp)
+	
+	/*msgring rx buf reg*/
+	dmfc2 k0, $1, 0
+	LONG_S  k0, NLM_COP2_RX_BUF(sp)
+	dmfc2 k0, $1, 1
+	LONG_S  k0, (NLM_COP2_RX_BUF+8)(sp)
+	dmfc2 k0, $1, 2
+	LONG_S  k0, (NLM_COP2_RX_BUF+16)(sp)
+	dmfc2 k0, $1, 3
+	LONG_S  k0, (NLM_COP2_RX_BUF+24)(sp)
+
+	mfc2 k0, $2, 0
+	sw  k0, NLM_COP2_TX_MSG_STATUS(sp)
+	
+	mfc2 k0, $3, 0
+	jr	ra
+	sw k0, NLM_COP2_RX_MSG_STATUS(sp)
+
+	END(nlm_cop2_save)
+	.set pop
+
+/*
+ * void nlm_cop2_restore()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in RESTORE_SOME in stackframe.h.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_restore)
+	/*msgring tx buf reg*/
+	LONG_L  v1, NLM_COP2_TX_BUF(sp)
+	dmtc2 v1, $0, 0
+	LONG_L  v1, (NLM_COP2_TX_BUF+8)(sp)
+	dmtc2 v1, $0, 1
+	LONG_L  v1, (NLM_COP2_TX_BUF+16)(sp)
+	dmtc2 v1, $0, 2
+	LONG_L  v1, (NLM_COP2_TX_BUF+24)(sp)
+	dmtc2 v1, $0, 3
+
+	/*msgring rx buf reg*/
+	LONG_L  v1, NLM_COP2_RX_BUF(sp)
+	dmtc2 v1, $1, 0
+	LONG_L  v1, (NLM_COP2_RX_BUF+8)(sp)
+	dmtc2 v1, $1, 1
+	LONG_L  v1, (NLM_COP2_RX_BUF+16)(sp)
+	dmtc2 v1, $1, 2
+	LONG_L  v1, (NLM_COP2_RX_BUF+24)(sp)
+	dmtc2 v1, $1, 3
+	lw  v1, NLM_COP2_TX_MSG_STATUS(sp)
+	mtc2 v1, $2, 0
+
+	/*leave bits 28-31 up to date*/
+	li k0, 0xf0000000
+	lw v1, NLM_COP2_RX_MSG_STATUS(sp)
+	or v1, k0, v1
+	xor v1, k0, v1
+	mfc2 k0, $3, 0
+	srl k0, k0, 28
+	sll k0, k0, 28
+	or v1, k0, v1
+	jr	ra
+	mtc2 v1, $3, 0
+	END(nlm_cop2_restore)
+	.set pop
+#endif
+
 #endif /* CONFIG_NLM_XLP */
 
 	NESTED(xlr_fast_syscall_msgsnd, PT_SIZE, sp)
-- 
1.7.10.4

