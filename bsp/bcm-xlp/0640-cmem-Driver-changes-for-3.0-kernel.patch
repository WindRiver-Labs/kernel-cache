From f9983f28b0c289aa3dda848c39319ac3ad919efd Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Mon, 10 Dec 2012 09:45:03 +0530
Subject: [PATCH 640/762] cmem: Driver changes for 3.0 kernel

Based on Broadcom SDK 2.3.

Signed-off-by: Hareesh R <hareeshr@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/char/nlm_cmem.c |   42 +++++++++++++++++++++++++++++-------------
 1 files changed, 29 insertions(+), 13 deletions(-)

diff --git a/drivers/char/nlm_cmem.c b/drivers/char/nlm_cmem.c
index a9749b6..57a88d7 100644
--- a/drivers/char/nlm_cmem.c
+++ b/drivers/char/nlm_cmem.c
@@ -41,6 +41,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 static int nlm_cmem_driver_major;
 static unsigned long app_pagesize = 0;
 static unsigned int app_pageorder = 0;
+static DEFINE_SPINLOCK(driver_lock);
 
 #define NLM_CMEM_DEV_NAME "nlm_cmem"
 
@@ -144,7 +145,6 @@ static inline int list_add_vinfo(struct file_priv_data *fpriv,
 		mminfo = kmalloc(sizeof(struct mm_info), GFP_KERNEL);
 		if(!mminfo) {
 			printk("Error : no mem in %s\n", __FUNCTION__);
-			spin_unlock(&fpriv->hlock[hash]);
 			return -ENOMEM;
 		}
 		INIT_HLIST_NODE(&mminfo->mnode);
@@ -234,19 +234,21 @@ static struct vaddr_info *create_new_vinfo(struct file_priv_data *fpriv,
 	return vinfo;
 }
 
-/* called from down_write mmap_sem , no need to take spinlock */
+/* called from down_write mmap_sem */
 static void set_err_status(struct file_priv_data *fpriv, struct mm_struct *mm)
 {
 	int hash;
 	struct mm_info *mminfo;
 
 	hash = calc_hash((unsigned long)mm) %  MMINFO_HASH_SIZE;
+	spin_lock(&fpriv->hlock[hash]);
 	mminfo = list_find_mminfo(fpriv, mm, hash);
 	if(mminfo) {
 		/* mminfo refcount has been incremented */
 		mminfo->refcnt--;
 		mminfo->status = -ENOMEM;
 	}
+	spin_unlock(&fpriv->hlock[hash]);
 }
 
 static int remap_pte_fn(pte_t *pte, struct page *pmd_page,
@@ -446,6 +448,7 @@ static int nlm_cmem_child_post_atfork_handler(struct file_priv_data *fpriv)
 	int hash;
 	struct mm_info *mminfo;
 	struct mm_struct *mm = current->mm;
+	int err = -ENOMEM;
 
 	Message("%s %d\n", __FUNCTION__, __LINE__);
 
@@ -454,14 +457,16 @@ static int nlm_cmem_child_post_atfork_handler(struct file_priv_data *fpriv)
 	 any memory 
 	 */
 	hash = calc_hash((unsigned long)mm) %  MMINFO_HASH_SIZE;
+	spin_lock(&fpriv->hlock[hash]);
 	mminfo = list_find_mminfo(fpriv, mm, hash);
 	if(mminfo) {
 		/* mminfo refcount has been incremented */
 		mminfo->refcnt--;
 	       if(mminfo->status == 0)
-			return 0;
+			err = 0;
 	}
-	return -ENOMEM;
+	spin_unlock(&fpriv->hlock[hash]);
+	return err;
 }
 
 static int nlm_cmem_copy_va_pa_info(struct file_priv_data *fpriv, unsigned long start,
@@ -480,19 +485,22 @@ static int nlm_cmem_copy_va_pa_info(struct file_priv_data *fpriv, unsigned long
 
 	hash = calc_hash((unsigned long)mm) %  MMINFO_HASH_SIZE;
 	
+	/* This read_sem will protect the mminfo taken below, as all the 
+	 vinfo addition and deletion is called with write_sem held */
 	down_read(&mm->mmap_sem);
 
-	/* Now we dont need to take the hash lock, as all the vinfo addition and deletion 
-	   takes write mmap_sem(mmap, vma_open, vma_close) , 
-	 We already taken the read lock */
-
+	/* we have to take the hash lock here because of fpriv is shared 
+	 with multiple processes and the list can be changed at any time */
+	spin_lock(&fpriv->hlock[hash]);
 	mminfo = list_find_mminfo(fpriv, mm, hash);
 	if(!mminfo) {
+		spin_unlock(&fpriv->hlock[hash]);
 		goto end;
 	} else {
 		/* mminfo refcount has been incremented */
 		mminfo->refcnt--;
 	}
+	spin_unlock(&fpriv->hlock[hash]);
 	
 	hlist_for_each(node, &mminfo->vhead) {
 		vinfo = (struct vaddr_info *) ((unsigned long)node -
@@ -557,19 +565,27 @@ static long nlm_cmem_driver_ioctl(struct file *filp, unsigned int cmd,
 	switch (cmd) {
 		case NLM_CMEM_SET_APP_PAGE_SIZE: 
 		{
+			rv = copy_from_user(&tmp, ptr, sizeof(*ptr));
+
+			spin_lock(&driver_lock);
 			/* Different applications sharing this driver cannot have different app pagesize,
 			 * Ignore the request if it is already set */
-			if(app_pagesize)
-				break;
+			if(app_pagesize && (tmp != app_pagesize)) {
+				printk("%s, Error : App page size is already set to %lx\n", __FUNCTION__, app_pagesize); 
+				spin_unlock(&driver_lock);
+				return -EINVAL;
+			}
 
-			rv = copy_from_user(&tmp, ptr, sizeof(*ptr));
-			app_pagesize = tmp;
-			if(app_pagesize < PAGE_SIZE) {
+			if(tmp < PAGE_SIZE) {
 				printk("%s, Error : App page size is very low\n", __FUNCTION__); 
+				spin_unlock(&driver_lock);
 				return -EINVAL;
 			}
+			app_pagesize = tmp;
+			spin_unlock(&driver_lock);
 
 			app_pageorder = get_order(app_pagesize);
+
 			Message("App page size %lx order %d\n", app_pagesize, app_pageorder);
 			break;
 		}
-- 
1.7.0.4

