From f67d6707f30d687b16ed81c71f42a48bbfc3908a Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Thu, 15 Jul 2010 14:02:59 +0530
Subject: [PATCH 118/762] Remove unused files Remove unnecessary modifications.

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/pg-phoenix.c  |  132 -------------
 arch/mips/mm/tlb-phnx.c    |  135 -------------
 arch/mips/mm/tlb-phoenix.c |  461 --------------------------------------------
 drivers/block/sbull.c      |  357 ----------------------------------
 4 files changed, 0 insertions(+), 1085 deletions(-)
 delete mode 100644 arch/mips/mm/pg-phoenix.c
 delete mode 100644 arch/mips/mm/tlb-phnx.c
 delete mode 100644 arch/mips/mm/tlb-phoenix.c
 delete mode 100644 drivers/block/sbull.c

diff --git a/arch/mips/mm/pg-phoenix.c b/arch/mips/mm/pg-phoenix.c
deleted file mode 100644
index 32a305e..0000000
--- a/arch/mips/mm/pg-phoenix.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2002 
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */ 
-
-#include <linux/smp.h>
-
-#include <asm/asm.h>
-#include <asm/page.h>
-#include <asm/bug.h>
-#include <asm/system.h>
-
-/* These are the functions hooked by the memory management function pointers */
-void clear_page(void *page)
-{
-#ifdef CONFIG_NLMCOMMON_VM_DEBUG
-  printk("[%s]: page = %lx\n", __FUNCTION__, (unsigned long)page);
-#endif
-  __asm__ __volatile__(
-		       ".set push                  \n"
-		       ".set noreorder             \n"
-		       ".set noat                  \n"
-		       ".set mips4                 \n"
-
-		       STR(LONG_ADDIU) "\t$1, $0, 1		\n"
-		       STR(LONG_SLL)"\t$1, %1		\n"
-		       /* store the address of last cacheline in $1 */
-		       STR(LONG_ADDU) "\t$1, %0, $1  \n"  
-
-		       /* pref with prep_for_store and zero the cacheline */
-		       "1:   pref      30,  0(%0)  \n"
-
-		       "     sd        $0,  0(%0)  \n"  
-		       "     sd        $0,  8(%0)  \n"
-		       "     sd        $0, 16(%0)  \n"
-		       "     sd        $0, 24(%0)  \n"
-
-		       /* loop till the last cacheline */
-		       STR(LONG_ADDIU)"\t%0, %0, 32  \n"  
-		       "     bne       %0, $1, 1b  \n"
-		       "     nop                   \n"
-
-		       ".set pop                   \n"
-		       :
-		       :"r" (page), "I" (PAGE_SHIFT)
-		       :"$1","memory");
-}
-
-void copy_page(void *to, void *from)
-{
-  __asm__ __volatile__(
-		       ".set push                  \n"
-		       ".set noreorder             \n"
-		       ".set noat                  \n"
-		       ".set mips64                 \n"
-
-		       STR(LONG_ADDIU) "\t$1, $0, 1		\n"
-		       STR(PTR_SLL) "\t $1, %2		\n"
-		       /* store the address of last cacheline in $1 */
-		       STR(LONG_ADDU)"\t$1, %1, $1  \n"  
-
-		       /* pref with prep_for_store the current cacheline */
-		       /* the stores should merge into this pref cacheline */
-		       "1:   pref      30,   0(%0)  \n"
-
-		       /* pref the next cacheline "from" */
-		       "     pref      0,    32(%1)  \n"
-
-		       /* copy the cacheline */
-#ifdef CONFIG_32BIT
- 		       "2:   lw        $8,   0(%1)  \n"
-		       "     lw        $9,   4(%1)  \n"
-		       "     lw        $10,  8(%1)  \n"
-		       "     lw        $11,  12(%1)  \n"
-		       "     sw        $8,   0(%0)  \n"
-		       "     sw        $9,   4(%0)  \n"
-		       "     sw        $10,  8(%0)  \n"
-		       "     sw        $11,  12(%0)  \n"
- 		       "     lw        $8,   16(%1)  \n"
-		       "     lw        $9,   20(%1)  \n"
-		       "     lw        $10,  24(%1)  \n"
-		       "     lw        $11,  28(%1)  \n"
-		       "     sw        $8,   16(%0)  \n"
-		       "     sw        $9,   20(%0)  \n"
-		       "     sw        $10,  24(%0)  \n"
-		       "     sw        $11,  28(%0)  \n"
-#else
- 		       "2:   ld        $8,   0(%1)  \n"
-		       "     ld        $9,   8(%1)  \n"
-		       "     ld        $10,  16(%1)  \n"
-		       "     ld        $11,  24(%1)  \n"
-		       "     sd        $8,   0(%0)  \n"
-		       "     sd        $9,   8(%0)  \n"
-		       "     sd        $10,  16(%0)  \n"
-		       "     sd        $11,  24(%0)  \n"
-#endif
-
-		       /* loop till the last cacheline */		       
-		       STR(LONG_ADDIU)"\t%1, %1, 32  \n"
-		       STR(LONG_ADDIU)"\t%0, %0, 32  \n"  
-		       "     bne       %1, $1, 1b  \n"
-		       "     nop                   \n"
-
-		       ".set pop                   \n"
-
-		       :
-		       :"r" (to), "r"(from), "I" (PAGE_SHIFT)
-		       :"$1","$8", "$9", "$10", "$11", "memory");
-}
diff --git a/arch/mips/mm/tlb-phnx.c b/arch/mips/mm/tlb-phnx.c
deleted file mode 100644
index d41b79b..0000000
--- a/arch/mips/mm/tlb-phnx.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#include <linux/sched.h>
-
-#define UNIQUE_ENTRYHI(idx)  ((1ULL << 63) + (1ULL << 40) + ((idx) << (PAGE_SHIFT + 1)) + ( 1 << 8))
-#define ENTER_CRITICAL(flags) local_irq_save(flags)
-#define EXIT_CRITICAL(flags) local_irq_restore(flags)
-extern void local_flush_tlb_all(void);
-
-int nlm_vmips_wired_entry_add(unsigned long entrylo0, unsigned long entrylo1,
-	uint64_t entryhi, unsigned long pagemask)
-{
-	unsigned long flags;
-	unsigned long wired;
-	unsigned long old_pagemask;
-	unsigned long old_ctx;
-
-	ENTER_CRITICAL(flags);
-	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi();
-	old_pagemask = read_c0_pagemask();
-	wired = read_c0_wired();
-	write_c0_wired(wired + 1);
-	write_c0_index(wired);
-	tlbw_use_hazard();	/* What is the hazard here? */
-	write_c0_pagemask(pagemask);
-	__write_64bit_c0_register($10, 0, entryhi);
-	write_c0_entrylo0(entrylo0);
-	write_c0_entrylo1(entrylo1);
-	mtc0_tlbw_hazard();
-	tlb_write_indexed();
-	tlbw_use_hazard();
-
-	write_c0_entryhi(old_ctx);
-	tlbw_use_hazard();	/* What is the hazard here? */
-	write_c0_pagemask(old_pagemask);
-	local_flush_tlb_all();
-	EXIT_CRITICAL(flags);
-	return wired;
-}
-
-void nlm_vmips_wired_entry_remove(int index)
-{
-	unsigned long flags;
-	unsigned long wired;
-	unsigned long old_pagemask;
-	unsigned long old_ctx;
-
-	ENTER_CRITICAL(flags);
-	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi();
-	old_pagemask = read_c0_pagemask();
-	write_c0_pagemask(0);
-	__write_64bit_c0_register($10, 0, UNIQUE_ENTRYHI(index));
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	wired = read_c0_wired();
-	if(index == (wired - 1))
-        write_c0_wired(wired - 1);
-    write_c0_index(index);
-	mtc0_tlbw_hazard();
-	tlb_write_indexed();
-	tlbw_use_hazard();
-	write_c0_entryhi(old_ctx);
-	tlbw_use_hazard();	/* What is the hazard here? */
-	write_c0_pagemask(old_pagemask);
-	local_flush_tlb_all();
-	EXIT_CRITICAL(flags);
-}
-
-
-void nlm_vmips_wired_entry_read(int index, uint64_t *entryhi, 
-		unsigned long *entrylo0, unsigned long *entrylo1)
-{
-	unsigned long flags;
-	ENTER_CRITICAL(flags);
-
-    write_c0_index(index);
-	tlb_read();
-	tlb_probe_hazard();
-	if(entryhi)
-		*entryhi = __read_64bit_c0_register($10, 0);
-
-	if(entrylo0)
-		*entrylo0 = read_c0_entrylo0();
-
-	if(entrylo1)
-		*entrylo1 = read_c0_entrylo1();
-
-	EXIT_CRITICAL(flags);
-	return;
-}
-
-/* Cacheble + Dirty + Valid + Global */
-#define TLB_ENTRY_CACHEBLE ((3 << 3) | (1 << 2) | (1 << 1) | ( 1 << 0)) 
-#define   nlm_align(x, y)     ((x) & (~((y)-1)))
-void nlm_vmips_temp_xkphys_tlb_add(phys_t start, phys_t end, int *tlbs, int *tlbe)
-{
-	uint32_t pagesize = 256 * 1024 * 1024;
-	uint64_t entryhi = 0x9800000000000000ULL;
-	phys_t aligned_start;
-
-	*tlbs = *tlbe = read_c0_wired();
-	
-	aligned_start = nlm_align(start, pagesize);
-	entryhi += aligned_start;
-	for(; aligned_start < end; aligned_start += (2 * pagesize), entryhi += ((2 * pagesize))) {
-		uint64_t entrylo0 = ((( aligned_start & 0xffffffffffULL) >> 12) << 6) | TLB_ENTRY_CACHEBLE;
-		uint64_t entrylo1 = ((( (aligned_start + pagesize) & 0xffffffffffULL) >> 12) << 6) | TLB_ENTRY_CACHEBLE;
-		*tlbe = nlm_vmips_wired_entry_add(entrylo0, entrylo1, entryhi, 0x1fffe000);
-	}
-}
diff --git a/arch/mips/mm/tlb-phoenix.c b/arch/mips/mm/tlb-phoenix.c
deleted file mode 100644
index 57639f8..0000000
--- a/arch/mips/mm/tlb-phoenix.c
+++ /dev/null
@@ -1,461 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */ 
-
-#include <asm/mmu_context.h>
-#include <asm/bootinfo.h>
-#include <asm/cpu.h>
-#include <linux/highmem.h>
-
-#include <asm/io.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/nlm_common_mmap.h>
-#include <asm/netlogic/sim.h>
-
-#ifdef CONFIG_NLMCOMMON_VM_DEBUG
-#define DEBUG_TLB
-#endif
-
-extern char except_vec0_r4000[];
-extern char except_vec0_phoenix[];
-extern unsigned long nlm_common_ebase;
-
-/* Dump the current entry* and pagemask registers */
-static inline void dump_cur_tlb_regs(void)
-{
-  unsigned int entryhihi, entryhilo, entrylo0hi, entrylo0lo, entrylo1hi;
-  unsigned int entrylo1lo, pagemask;
-
-  __asm__ __volatile__ (
-			".set push             \n"
-			".set noreorder        \n"
-			".set mips64           \n"
-			".set noat             \n"
-			"     tlbr             \n"
-			"     dmfc0  $1, $10   \n"
-			"     dsrl32 %0, $1, 0 \n"
-			"     sra    %1, $1, 0 \n"
-			"     dmfc0  $1, $2    \n"
-			"     dsrl32 %2, $1, 0 \n"
-			"     sra    %3, $1, 0 \n"
-			"     dmfc0  $1, $3    \n"
-			"     dsrl32 %4, $1, 0 \n"
-			"     sra    %5, $1, 0 \n"
-			"     mfc0   %6, $5    \n"
-			".set pop              \n"
-			: "=r" (entryhihi),
-			"=r" (entryhilo),
-			"=r" (entrylo0hi),
-			"=r" (entrylo0lo),
-			"=r" (entrylo1hi),
-			"=r" (entrylo1lo),
-			"=r" (pagemask));
-  printk("%08X%08X %08X%08X %08X%08X %08X",
-	 entryhihi, entryhilo,
-	 entrylo0hi, entrylo0lo,
-	 entrylo1hi, entrylo1lo,
-	 pagemask);
-}
-
-void nlm_common_dump_tlb(void)
-{
-  int entry;
-  printk("Current TLB registers state:\n"
-	 "      EntryHi       EntryLo0          EntryLo1     PageMask  Index\n"
-	 "--------------------------------------------------------------------\n");
-  dump_cur_tlb_regs();
-  printk(" %08X\n", read_c0_index());
-  printk("\n\nFull TLB Dump:\n"
-	 "Idx      EntryHi       EntryLo0          EntryLo1     PageMask\n"
-	 "--------------------------------------------------------------\n");
-  for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
-    write_c0_index(entry);
-    printk("\n%02i ", entry);
-    __asm__ __volatile__ (
-			  ".set push             \n"
-			  ".set mips64           \n"
-			  "     tlbr             \n"
-			  ".set pop              \n");
-    dump_cur_tlb_regs();
-  }
-  printk("\n");
-}
-
-void local_flush_tlb_all(void)
-{
-  unsigned long flags;
-  unsigned long old_ctx;
-  int entry;
-
-  local_irq_save(flags);
-  /* Save old context and create impossible VPN2 value */
-  old_ctx = (read_c0_entryhi() & 0xff);
-  write_c0_entrylo0(0);
-  write_c0_entrylo1(0);
-
-  entry = read_c0_wired();
-  for (; entry < current_cpu_data.tlbsize; entry++) {
-    write_c0_entryhi(KSEG0 + (PAGE_SIZE << 1) * entry);
-    write_c0_index(entry);
-    tlb_write_indexed();
-  }
-  reload_context(old_ctx);
-  local_irq_restore(flags);	
-}
-
-/*
- * Use a bogus region of memory (starting at 0) to sanitize the TLB's.  
- * Use increments of the maximum page size (16MB), and check for duplicate
- * entries before doing a given write.  Then, when we're safe from collisions
- * with the firmware, go back and give all the entries invalid addresses with
- * the normal flush routine.
- */
-void nlm_common_sanitize_tlb(void)
-{
-  int entry;
-  long addr = 0;
-
-  long inc = 1<<24;  /* 16MB */
-
-  /* Initialize the Page Mask Register */
-  write_c0_pagemask(0);
-
-  /* Save old context and create impossible VPN2 value */
-  write_c0_entrylo0(0);
-  write_c0_entrylo1(0);
-  for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
-    do {
-      addr += inc;
-      write_c0_entryhi(addr);
-      tlb_probe();
-    } while ((int)(read_c0_index()) >= 0);
-    write_c0_index(entry);
-    tlb_write_indexed();
-  }
-  /* Now that we know we're safe from collisions, we can safely flush
-     the TLB with the "normal" routine. */
-  local_flush_tlb_all();
-}
-
-void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-			   unsigned long end)
-{
-  struct mm_struct *mm = vma->vm_mm;
-  unsigned long flags;
-  int cpu;
-
-  local_irq_save(flags);
-  cpu = smp_processor_id();
-  if(cpu_context(cpu, mm) != 0) {
-    int size;
-    size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-    size = (size + 1) >> 1;
-    if(size <= (current_cpu_data.tlbsize/2)) {
-      int oldpid = (read_c0_entryhi() & 0xff);
-      int newpid = (cpu_context(cpu, mm) & 0xff);
-
-      start &= (PAGE_MASK << 1);
-      end += ((PAGE_SIZE << 1) - 1);
-      end &= (PAGE_MASK << 1);
-      while(start < end) {
-	int idx;
-
-	write_c0_entryhi(start | newpid);
-	start += (PAGE_SIZE << 1);
-	tlb_probe();
-	idx = read_c0_index();
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	write_c0_entryhi(KSEG0 + (idx << (PAGE_SHIFT+1)));
-	if(idx < 0)
-	  continue;
-	tlb_write_indexed();
-      }
-      reload_context(oldpid);
-    } else {
-      get_new_mmu_context(mm, cpu);
-      if (mm == current->active_mm)
-	reload_context(cpu_context(cpu, mm));
-    }
-  }
-  local_irq_restore(flags);
-}
-
-void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-  unsigned long flags;
-  int size;
-
-  size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-  size = (size + 1) >> 1;
-
-  local_irq_save(flags);
-  if (size <= (current_cpu_data.tlbsize/2)) {
-    int pid = read_c0_entryhi();
-
-    start &= (PAGE_MASK << 1);
-    end += ((PAGE_SIZE << 1) - 1);
-    end &= (PAGE_MASK << 1);
-
-    while (start < end) {
-      int idx;
-
-      write_c0_entryhi(start);
-      start += (PAGE_SIZE << 1);
-      tlb_probe();
-      idx = read_c0_index();
-      write_c0_entrylo0(0);
-      write_c0_entrylo1(0);
-      write_c0_entryhi(KSEG0 + (idx << (PAGE_SHIFT+1)));
-      if (idx < 0)
-	continue;
-      tlb_write_indexed();
-    }
-    reload_context(pid);
-  } else {
-    local_flush_tlb_all();
-  }
-  local_irq_restore(flags);
-}
-
-void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-  unsigned long flags;
-  int cpu;
-
-  local_irq_save(flags);
-  cpu = smp_processor_id();
-  if (cpu_context(cpu, vma->vm_mm) != 0) {
-    int oldpid, newpid, idx;
-#ifdef DEBUG_TLB
-    printk("[tlbpage<%ld,%08lx>]\n", cpu_context(cpu, vma->vm_mm), page);
-#endif
-    newpid = (cpu_context(cpu, vma->vm_mm) & 0xff);
-    page &= (PAGE_MASK << 1);
-    oldpid = (read_c0_entryhi() & 0xff);
-    write_c0_entryhi(page | newpid);
-    tlb_probe();
-    idx = read_c0_index();
-    write_c0_entrylo0(0);
-    write_c0_entrylo1(0);
-    if(idx < 0)
-      goto finish;
-    /* Make sure all entries differ. */  
-    write_c0_entryhi(KSEG0+(idx<<(PAGE_SHIFT+1)));
-    tlb_write_indexed();
-  finish:
-    reload_context(oldpid);
-  }
-  local_irq_restore(flags);
-}
-
-/*
- * This one is only used for pages with the global bit set so we don't care
- * much about the ASID.
- */
-void local_flush_tlb_one(unsigned long page)
-{
-	unsigned long flags;
-	int oldpid, idx;
-
-	local_irq_save(flags);
-	page &= (PAGE_MASK << 1);
-	oldpid = read_c0_entryhi() & ASID_MASK;
-	write_c0_entryhi(page);
-	tlb_probe();
-	idx = read_c0_index();
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	if (idx >= 0) {
-		/* Make sure all entries differ. */
-		write_c0_entryhi(KSEG0+(idx<<(PAGE_SHIFT+1)));
-		tlb_write_indexed();
-	}
-	reload_context(oldpid);
-
-	local_irq_restore(flags);
-}
-
-/* All entries common to a mm share an asid.  To effectively flush
-   these entries, we just bump the asid. */
-void local_flush_tlb_mm(struct mm_struct *mm)
-{
-  unsigned long flags;
-  int cpu;
-  local_irq_save(flags);
-  cpu = smp_processor_id();
-  if (cpu_context(cpu, mm) != 0) {
-    get_new_mmu_context(mm, smp_processor_id());
-    if (mm == current->active_mm) {
-      reload_context(cpu_context(cpu, mm) & 0xff);
-    }
-  }
-  local_irq_restore(flags);
-}
-
-static int user_mac_bigtlb(struct vm_area_struct *vma, unsigned long pfn0, 
-			   unsigned long pfn1, int pid, int idx)
-{  
-  return 0;
-}
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address,
-		  pte_t pte)
-{
-  unsigned long flags;
-  pgd_t *pgdp;
-  pmd_t *pmdp;
-  pte_t *ptep;
-  int idx, pid;
-  unsigned long pfn0, pfn1;
-#ifdef DEBUG_TLB
-  int cpu = smp_processor_id();
-#endif
-
-  /*
-   * Handle debugger faulting in for debugee.
-   */
-  if (current->active_mm != vma->vm_mm)
-    return;
-
-  local_irq_save(flags);
-
-  xlr_inc_counter(USER_MAC_UPDATE_TLB);
-
-  pid = read_c0_entryhi() & 0xff;
-
-#ifdef DEBUG_TLB
-  if((pid != (cpu_context(cpu, vma->vm_mm) & 0xff)) 
-     || (cpu_context(cpu, vma->vm_mm) == 0)) {
-    printk("update_mmu_cache: Wheee, bogus tlbpid mmpid=%d tlbpid=%d\n",
-	   (int) (cpu_context(cpu, vma->vm_mm) & 0xff), pid);
-  }
-#endif
-
-  address &= (PAGE_MASK << 1);
-  write_c0_entryhi(address | (pid));
-  pgdp = pgd_offset(vma->vm_mm, address);
-  tlb_probe();
-  pmdp = pmd_offset(pgdp, address);
-  idx = read_c0_index();
-  ptep = pte_offset_map(pmdp, address);
-#ifdef DEBUG_TLB  
-  printk("[%s]: idx = %d, address = %lx, pte = %lx, pte+1=%lx, ptep=%lx\n", 
-	 __FUNCTION__, idx, address, pte_val(*ptep), pte_val(*(ptep+1)), 
-	 (unsigned long)ptep);
-#endif  
-  pfn0 = pte_pfn(*ptep);
-  pfn1 = pte_pfn(*(ptep+1));
-  xlr_set_counter(USER_MAC_UPDATE_TLB_PFN0, pte_val(*ptep));
-  xlr_set_counter(USER_MAC_UPDATE_TLB_PFN1, pte_val(*(ptep+1)));
-  if (!user_mac_bigtlb(vma, pfn0, pfn1, pid, idx)) {
-    write_c0_entrylo0(pte_val(*ptep++) >> 6);
-    write_c0_entrylo1(pte_val(*ptep) >> 6);
-    write_c0_entryhi(address | (pid));
-    if(idx < 0) {
-      tlb_write_random();
-    } else {
-      tlb_write_indexed();
-    }
-  }
-  local_irq_restore(flags);
-}
-
-unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
-
-/*
- * This is called from loadmmu.c.  We have to set up all the
- * memory management function pointers, as well as initialize
- * the caches and tlbs
- */
-void tlb_init(void)
-{
-  u32 config1;
-
-  config1 = read_c0_config1();
-  current_cpu_data.tlbsize = ((config1 >> 25) & 0x3f) + 1;
-
-  nlm_common_sanitize_tlb();
-
-  {
-    unsigned long virt_start = (unsigned long)NLM_MMAP_VIRT_START & 0xffffffff;
-    unsigned long phys_start = (unsigned long)NLM_MMAP_PHYS_START & 0xffffffff;
-    unsigned long phys_pmask_size = (unsigned long)NLM_MMAP_PMASK_SIZE & 0xffffffff;
-
-    /* update scratch regs to be used in tlb refill */
-    __asm__ __volatile__ (".set push\n"
-			  ".set mips64\n"
-			  ".set noreorder\n"
-			  "dmtc0 %0, $22, "STR(NETLOGIC_OSS_SEL_TLB_STATS)"\n"
-			  "dmtc0 %2, $22, "STR(NETLOGIC_OSS_SEL_PAGEMASK)"\n"
-			  "dmtc0 %3, $22, "STR(NETLOGIC_OSS_SEL_VADDR)"\n"
-			  "dmtc0 %4, $22, "STR(NETLOGIC_OSS_SEL_PFN0)"\n"
-			  "dmtc0 %5, $22, "STR(NETLOGIC_OSS_SEL_PFN1)"\n"
-			  ".set pop\n"
-			  : 
-			  : "r"(&nlm_common_tlb_stats[hard_smp_processor_id()]),
-			  "r"(NLM_MMAP_PMASK_SIZE_256MB << 13),
-			  "r"(virt_start),
-			  "r"( phys_start >> 12),
-			  "r"( (phys_start + phys_pmask_size) >> 12)
-			  );
-  }
-
-  if (smp_processor_id()) return;
-
-  /* Set up the TLB Refill handler */
-  memcpy((void *)nlm_common_ebase, except_vec0_r4000, 0x80);
-}
-
-static int __init user_mac_tlb_init(void)
-{
-  void *vaddr = 0;
-  unsigned long phys_start = NLM_MMAP_PHYS_START;
-  unsigned long phys_size = NLM_MMAP_PHYS_SIZE;
-
-  if (!xlr_hybrid_user_mac() && !xlr_hybrid_user_mac_xgmac()) return 0;
-
-  if (!request_mem_region(phys_start, phys_size, "user_mac_private")) {
-    printk("[%s]: request_mem_region failed for phys_start=%lx, phys_size=%lx\n",
-	   __FUNCTION__, phys_start, phys_size);
-  }
-
-  vaddr = ioremap(phys_start, phys_size);
-
-/*   printk("[%s]: vaddr = %p\n", __FUNCTION__, vaddr); */
-/*   printk("[%s]: nlm_common_counters[0][USER_MAC_UPDATE_TLB]=%p\n",  */
-/* 	 __FUNCTION__, &nlm_common_counters[0][USER_MAC_UPDATE_TLB]); */
-
-/*   printk("[%s]: nlm_common_tlb_stats = %p\n", __FUNCTION__, nlm_common_tlb_stats); */
-
-  return 0;
-}
-
-arch_initcall(user_mac_tlb_init);
-
diff --git a/drivers/block/sbull.c b/drivers/block/sbull.c
deleted file mode 100644
index da33c5b..0000000
--- a/drivers/block/sbull.c
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * Sample disk driver, from the beginning.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-
-#include <linux/sched.h>
-#include <linux/kernel.h>	/* printk() */
-#include <linux/slab.h>		/* kmalloc() */
-#include <linux/fs.h>		/* everything... */
-#include <linux/errno.h>	/* error codes */
-#include <linux/timer.h>
-#include <linux/types.h>	/* size_t */
-#include <linux/fcntl.h>	/* O_ACCMODE */
-#include <linux/hdreg.h>	/* HDIO_GETGEO */
-#include <linux/kdev_t.h>
-#include <linux/vmalloc.h>
-#include <linux/genhd.h>
-#include <linux/blkdev.h>
-#include <linux/buffer_head.h>	/* invalidate_bdev */
-#include <linux/bio.h>
-
-static int sbull_major = 0;
-module_param(sbull_major, int, 0);
-
-static int hardsect_size = 512;
-module_param(hardsect_size, int, 0);
-
-static int nsectors = 1024;	/* How big the drive is */
-module_param(nsectors, int, 0);
-
-static int ndevices = 1;
-module_param(ndevices, int, 0);
-
-/**
- * Minor number and partition management.
- **/
-
-#define SBULL_MINORS	16
-#define MINOR_SHIFT	4
-#define DEVNUM(kdevnum)	(MINOR(kdev_t_to_nr(kdevnum)) >> MINOR_SHIFT
-
-/**
- * We can tweak our hardware sector size, but the kernel talks to us
- * in terms of small sectors, always.
- **/
-
-#define KERNEL_SECTOR_SIZE	512
-
-/**
- * After this much idle time, the driver will simulate a media change.
- **/
-#define INVALIDATE_DELAY	30*HZ
-
-/*
- * The internal representation of our device.
- */
-struct sbull_dev {
-        int size;                       /* Device size in sectors */
-        u8 *data;                       /* The data array */
-        short users;                    /* How many users */
-        short media_change;             /* Flag a media change? */
-        spinlock_t lock;                /* For mutual exclusion */
-        struct request_queue *queue;    /* The device request queue */
-        struct gendisk *gd;             /* The gendisk structure */
-        struct timer_list timer;        /* For simulated media changes */
-};
-
-static struct sbull_dev *Devices = NULL;
-
-/**
- * Handle an I/O request.
- **/
-
-static void sbull_transfer(struct sbull_dev *dev, unsigned long sector,
-		unsigned long nsect, char *buffer, int write)
-{
-	unsigned long offset = sector*KERNEL_SECTOR_SIZE;
-	unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;
-
-	if ((offset + nbytes) > dev->size) {
-		printk (KERN_NOTICE "Beyond-end write (%ld %ld)\n", offset, nbytes);
-		return;
-	}
-	if (write)
-		memcpy(dev->data + offset, buffer, nbytes);
-	else
-		memcpy(buffer, dev->data + offset, nbytes);
-}
-
-/**
- * Transfer a single BIO.
- **/
-
-static int sbull_xfer_bio(struct sbull_dev *dev, struct bio *bio)
-{
-	int i;
-	struct bio_vec *bvec;
-	sector_t sector = bio->bi_sector;
-
-	/* Do each segment independently. */
-	bio_for_each_segment(bvec, bio, i) {
-		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
-		sbull_transfer(dev, sector, bio_cur_sectors(bio),
-				buffer, bio_data_dir(bio) == WRITE);
-		sector += bio_cur_sectors(bio);
-		__bio_kunmap_atomic(bio, KM_USER0);
-	}
-	return 0; /* Always "succeed" */
-}
-
-/*
- * The direct make request version.
- */
-static int sbull_make_request(struct request_queue *q, struct bio *bio)
-{
-	struct sbull_dev *dev = q->queuedata;
-	int status;
-
-	status = sbull_xfer_bio(dev, bio);
-	bio_endio(bio, status);
-	return 0;
-}
-
-
-/**
- * Open and close.
- **/
-
-static int sbull_open(struct inode *inode, struct file *filp)
-{
-	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;
-
-	// del_timer_sync(&dev->timer);
-	filp->private_data = dev;
-	spin_lock(&dev->lock);
-	if (! dev->users) 
-		check_disk_change(inode->i_bdev);
-	dev->users++;
-	spin_unlock(&dev->lock);
-	return 0;
-}
-
-static int sbull_release(struct inode *inode, struct file *filp)
-{
-	struct sbull_dev *dev = inode->i_bdev->bd_disk->private_data;
-
-	spin_lock(&dev->lock);
-	dev->users--;
-
-	/* if (!dev->users) {
-		dev->timer.expires = jiffies + INVALIDATE_DELAY;
-		add_timer(&dev->timer);
-	} */
-	spin_unlock(&dev->lock);
-
-	return 0;
-}
-
-/*
- * Look for a (simulated) media change.
- */
-int sbull_media_changed(struct gendisk *gd)
-{
-	struct sbull_dev *dev = gd->private_data;
-	
-	return dev->media_change;
-}
-
-/*
- * Revalidate.  WE DO NOT TAKE THE LOCK HERE, for fear of deadlocking
- * with open.  That needs to be reevaluated.
- */
-int sbull_revalidate(struct gendisk *gd)
-{
-	struct sbull_dev *dev = gd->private_data;
-	
-	if (dev->media_change) {
-		dev->media_change = 0;
-		memset (dev->data, 0, dev->size);
-	}
-	return 0;
-}
-
-/*
- * The "invalidate" function runs out of the device timer; it sets
- * a flag to simulate the removal of the media.
- */
-void sbull_invalidate(unsigned long ldev)
-{
-	struct sbull_dev *dev = (struct sbull_dev *) ldev;
-
-	spin_lock(&dev->lock);
-	if (dev->users || !dev->data) 
-		printk (KERN_WARNING "sbull: timer sanity check failed\n");
-	else
-		dev->media_change = 1;
-	spin_unlock(&dev->lock);
-}
-
-/*
- * The ioctl() implementation
- */
-
-int sbull_ioctl (struct inode *inode, struct file *filp,
-                 unsigned int cmd, unsigned long arg)
-{
-	long size;
-	struct hd_geometry geo;
-	struct sbull_dev *dev = filp->private_data;
-
-	switch(cmd) {
-	    case HDIO_GETGEO:
-        	/*
-		 * Get geometry: since we are a virtual device, we have to make
-		 * up something plausible.  So we claim 16 sectors, four heads,
-		 * and calculate the corresponding number of cylinders.  We set the
-		 * start of data at sector four.
-		 */
-		size = dev->size*(hardsect_size/KERNEL_SECTOR_SIZE);
-		geo.cylinders = (size & ~0x3f) >> 6;
-		geo.heads = 4;
-		geo.sectors = 16;
-		geo.start = 4;
-		if (copy_to_user((void __user *) arg, &geo, sizeof(geo)))
-			return -EFAULT;
-		return 0;
-	}
-
-	return -ENOTTY; /* unknown command */
-}
-
-
-
-/*
- * The device operations structure.
- */
-static struct block_device_operations sbull_ops = {
-	.owner           = THIS_MODULE,
-	.open 	         = sbull_open,
-	.release 	 = sbull_release,
-	.media_changed   = sbull_media_changed,
-	.revalidate_disk = sbull_revalidate,
-	.ioctl	         = sbull_ioctl
-};
-
-
-/*
- * Set up our internal device.
- */
-static void setup_device(struct sbull_dev *dev, int which)
-{
-	/*
-	 * Get some memory.
-	 */
-	memset (dev, 0, sizeof (struct sbull_dev));
-	dev->size = nsectors*hardsect_size;
-
-	// dev->data = vmalloc(dev->size);
-	dev->data = (u8 *) (unsigned long)0xffffffff80400000ULL; // 4 MB
-
-	/* if (dev->data == NULL) {
-		printk (KERN_NOTICE "vmalloc failure.\n");
-		return;
-	} */
-	spin_lock_init(&dev->lock);
-	
-	/*
-	 * The timer which "invalidates" the device.
-	 */
-	/* init_timer(&dev->timer);
-	dev->timer.data = (unsigned long) dev;
-	dev->timer.function = sbull_invalidate; */
-	
-	dev->queue = blk_alloc_queue(GFP_KERNEL);
-	if (dev->queue == NULL)
-		goto out_vfree;
-	blk_queue_make_request(dev->queue, sbull_make_request);
-
-	blk_queue_hardsect_size(dev->queue, hardsect_size);
-	dev->queue->queuedata = dev;
-
-	/*
-	 * And the gendisk structure.
-	 */
-
-	dev->gd = alloc_disk(SBULL_MINORS);
-	if (! dev->gd) {
-		printk (KERN_NOTICE "alloc_disk failure\n");
-		goto out_vfree;
-	}
-	dev->gd->major = sbull_major;
-	dev->gd->first_minor = which*SBULL_MINORS;
-	dev->gd->fops = &sbull_ops;
-	dev->gd->queue = dev->queue;
-	dev->gd->private_data = dev;
-	snprintf (dev->gd->disk_name, 32, "sbull%c", which + 'a');
-	set_capacity(dev->gd, nsectors*(hardsect_size/KERNEL_SECTOR_SIZE));
-	add_disk(dev->gd);
-
-  out_vfree:
-	return;
-}
-
-static int __init sbull_init(void)
-{
-	int i;
-	/*
-	 * Get registered.
-	 */
-	sbull_major = register_blkdev(sbull_major, "sbull");
-	if (sbull_major <= 0) {
-		printk(KERN_WARNING "sbull: unable to get major number\n");
-		return -EBUSY;
-	}
-	/*
-	 * Allocate the device array, and initialize each one.
-	 */
-	Devices = kmalloc(ndevices*sizeof (struct sbull_dev), GFP_KERNEL);
-	if (Devices == NULL)
-		goto out_unregister;
-	for (i = 0; i < ndevices; i++) 
-		setup_device(Devices + i, i);
-
-	return 0;
-
-  out_unregister:
-	unregister_blkdev(sbull_major, "sbd");
-	return -ENOMEM;
-}
-
-static void sbull_exit(void)
-{
-	int i;
-
-	for (i = 0; i < ndevices; i++) {
-		struct sbull_dev *dev = Devices + i;
-
-		// del_timer_sync(&dev->timer);
-		if (dev->gd) {
-			del_gendisk(dev->gd);
-			put_disk(dev->gd);
-		}
-		if (dev->queue) {
-			blk_put_queue(dev->queue);
-		}
-		if (dev->data)
-			vfree(dev->data);
-	}
-	unregister_blkdev(sbull_major, "sbull");
-	kfree(Devices);
-}
-
-module_init(sbull_init);
-module_exit(sbull_exit);
-- 
1.7.0.4

