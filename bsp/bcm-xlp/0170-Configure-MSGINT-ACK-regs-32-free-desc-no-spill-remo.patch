From 35c3b976dfd37125b6b4cdba9a35848a42979807 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 4 Sep 2010 15:14:33 -0700
Subject: [PATCH 170/762] Configure MSGINT ACK regs, 32 free desc (no spill), removed XLR UART HACK

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c      |   20 ++++++--
 arch/mips/netlogic/xlp/platform-xlp.c |   12 -----
 drivers/net/xlp_nae/Makefile          |    2 +-
 drivers/net/xlp_nae/xlp_nae.c         |   82 ++++++++++++++++++++------------
 4 files changed, 66 insertions(+), 50 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 8100dc8..39ffa51 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -182,6 +182,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
+	unsigned int msg_status1 = 0, vc_empty_status = 0;
 
 	msg0 = msg1 = msg2 = msg3 = 0;
 
@@ -201,13 +202,17 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
         msgrng_access_enable(mflags);
 	cycles = read_c0_count();
 
-	for( vc = vcpu; vc < (vcpu + 4); vc++)
-	{
-		status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
-		if(status != 0)
-			continue;
-		
+	for (;;) {
+		/* Read latest VC empty mask */
+		msg_status1 = xlp_read_status1();
+		vc_empty_status = (msg_status1 >> 24) & 0xf;
+		if (!vc_empty_status) break;
+
+		for( vc = vcpu; vc < (vcpu + 4); vc++)
 		{
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			if(status != 0)
+				continue;
 			if(src_id >= 0 && src_id < MAX_VC)
 			{
 				handler = &msg_handler_map[vc_to_handle_map[src_id]];
@@ -217,6 +222,9 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	}
 	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
 
+	/* Clear VC interrupt status by writing 1s */
+	xlp_write_status1( (msg_status1 | (0xf << 16)) );
+
         msgrng_access_disable(mflags);
 
 	irq_exit();
diff --git a/arch/mips/netlogic/xlp/platform-xlp.c b/arch/mips/netlogic/xlp/platform-xlp.c
index 06de273..5a8942d 100644
--- a/arch/mips/netlogic/xlp/platform-xlp.c
+++ b/arch/mips/netlogic/xlp/platform-xlp.c
@@ -150,12 +150,6 @@ unsigned int xlp_uart_in(struct uart_port *p, int offset)
 	mmio = (nlm_reg_t *)(p->membase + offset);
 	value = netlogic_read_reg(mmio, 0);
 
-	/* IS this required for XLP too ? */
-	if (offset == UART_MSR)
-		value ^= 0xF0;
-	else if (offset == UART_MCR)
-		value ^= 0x3;
-
 	return value;
 
 }
@@ -164,12 +158,6 @@ void xlp_uart_out(struct uart_port *p, int offset, int value)
 {
 	nlm_reg_t *mmio;
 
-	/* IS this required for XLP too ? */
-	if (offset == UART_MSR)
-		value ^= 0xF0;
-	else if (offset == UART_MCR)
-		value ^= 0x3;
-
 	/* XLP uart does not need any mapping of regs */
 	offset = offset << p->regshift;
 	mmio = (nlm_reg_t *)(p->membase + offset);
diff --git a/drivers/net/xlp_nae/Makefile b/drivers/net/xlp_nae/Makefile
index e9f1af4..eba22eb 100644
--- a/drivers/net/xlp_nae/Makefile
+++ b/drivers/net/xlp_nae/Makefile
@@ -8,5 +8,5 @@
 EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 obj-m += nlm_xlp_nae.o
 obj-$(CONFIG_XLP_NAE) += nlm_xlp_nae.o
-nlm_xlp_nae-objs := xlp_nae.o init_nae.o ucore_loader.o xlp_hw.o 
+nlm_xlp_nae-objs := xlp_nae.o init_nae.o ucore_loader.o xlp_hw.o
 
diff --git a/drivers/net/xlp_nae/xlp_nae.c b/drivers/net/xlp_nae/xlp_nae.c
index c80d520..2994d5d 100644
--- a/drivers/net/xlp_nae/xlp_nae.c
+++ b/drivers/net/xlp_nae/xlp_nae.c
@@ -67,8 +67,8 @@
 #define NUM_FREE_DESC			18	
 #define FREE_DESC_POOL_WIDTH		20
 #define NUM_FREEIN_QUEUE		18
-#define MAX_NUM_DESC			32 
-#define MIN_FRIN_DESC_THRESHD		16
+#define MAX_NUM_DESC                    32
+#define MIN_FRIN_DESC_THRESHD		16	
 #define MAX_NET_INF             	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
@@ -400,6 +400,7 @@ retry_send:
                                 printk("TX message Q fulll\n");
 			}
 
+			printk("[%s]: retrying...\n", __func__);
 			goto retry_send;
                 }
 		msgrng_access_disable(mflags);
@@ -422,6 +423,15 @@ static void nlm_xlp_nae_init(void)
 	struct proc_dir_entry *entry;
 	uint32_t val;
 
+#define HW_EMULATOR                            1
+#ifdef HW_EMULATOR
+	unsigned long mflags = 0;
+	msgrng_access_enable(mflags);
+        nlm_hal_fmn_init(0xE0000000ULL, 0x1000000, 50);
+	// nlm_hal_dump_outq();
+	msgrng_access_disable(mflags);
+#endif
+
  	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
 		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",__FUNCTION__, xlp_sgmii_ports);
@@ -437,12 +447,13 @@ static void nlm_xlp_nae_init(void)
 	/* initial 18 gmac block */	
         for(i = 0; i < 1/*MAX_NET_INF*/; i++)
 	{
-		init_gmac(i);
+		/* init_gmac(i); */
+		nlm_hal_open_if(GMAC_IF, i);
 	}
-	        
+#if 0
 	/* init tx if credit */	
 	init_tx_if_credit( 0, 0x7FFFF );
-
+#endif
 
 	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
 	{
@@ -450,9 +461,12 @@ static void nlm_xlp_nae_init(void)
 	}
 
 	ucore_load_apps(0xffffUL);	
+
+#if 0
 	/*  init egress and igress interface */
 	init_ingress();
 	init_egress(); 
+#endif
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
 	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
@@ -674,7 +688,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 	}
 
-	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, (virt_to_bus(skb)|port));
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
 							 0,
 							 NULL_VFBID,
@@ -687,6 +701,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
   	DUMP_PKT(skb->data, skb->len) 
 #endif
 	__sync(); 
+
+       printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
+	      priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
+
 	msgrng_access_enable(mflags);
 retry_send:
         if ((ret = nlm_hal_send_msg2( priv->nae_tx_qid,
@@ -881,6 +899,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	cpu = vc >> 4;
 	vc = vc & 0x03;
 
+       printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
+	      src_id, vc, size, msg0, msg1);
+
 	if( vc == 1 && size == 1)
 	{
 		/* Transmit Complete */
@@ -894,22 +915,23 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			port = 0;
 		}
 
-                if(addr)
-                {
-        		pdev = (struct net_device*)dev_mac[port];
-			if(!pdev)
-				return;
-        		priv = netdev_priv(pdev);
+		pdev = (struct net_device*)dev_mac[port];
+		if(!pdev) {
+			printk("[%s]: [txc] wrong port=%d? pdev = NULL!\n", __func__, port);
+			return;
+		}
+		priv = netdev_priv(pdev);
 
-                        skb = (struct sk_buff *)bus_to_virt(addr);
-                        if(skb)
-                        {
-                                dev_kfree_skb_any(skb);
-                        }
-			else {
-				printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
-			}
-                }
+		skb = (struct sk_buff *)bus_to_virt(addr);
+		if(skb)
+		{
+			printk("[%s]: addr=%llx, skb=%p, context=%d, port=%d\n",
+			       __func__, addr, skb, context, port);
+			dev_kfree_skb_any(skb);
+		}
+		else {
+			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
+		}
 	}
 	else if(vc == 0 && size == 2)
 	{
@@ -917,7 +939,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
         	addr	= msg1 & 0xffffffffc0ULL;
         	len	= (msg1 >> 40) & 0x3fff;
 		context = msg1 >> 54;
-		
+
 		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
 		port = context / XLP_SGMII_RCV_CONTEXT_NUM;
 
@@ -932,16 +954,16 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			return;
 		}
         	priv = netdev_priv(pdev);
-			
+
         	vaddr = (uint64_t)bus_to_virt(addr);
         	buf = (unsigned char *)vaddr;
-		
-#if DUMP_RCV_PKT
-		printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",
-		       priv->port,src_id,context,(uint64_t)buf, len, vaddr);
 
-		/* DUMP_PKT(buf , len); */
-#endif       
+		printk("[%s]: addr=%llx, len=%d, context=%d, port=%d, vaddr=%llx, buf=%p\n",
+		       __func__, addr, len, context, port, vaddr, buf);
+
+#if DUMP_RCV_PKT
+		DUMP_PKT(buf , len);
+#endif
 
 		len = len  - MAC_CRC_LEN;
 
@@ -949,8 +971,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		{
 			priv->stats.rx_errors++;
 			priv->stats.rx_dropped++;
-			/* printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n",
-			   len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);*/
 			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
 			return ;
 		}
-- 
1.7.0.4

