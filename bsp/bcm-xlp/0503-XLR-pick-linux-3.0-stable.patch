From 16455a7eea6da33c1ac9e4e92a230751c93c1a37 Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Mon, 9 Jan 2012 18:16:44 -0800
Subject: [PATCH 503/762] XLR: pick linux-3.0-stable

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../include/asm/netlogic/nlm_common_flash_pcmcia.h |  111 -----
 arch/mips/include/asm/netlogic/nlm_common_ide.h    |   57 ---
 drivers/ide/phoenix_ide.c                          |  522 --------------------
 3 files changed, 0 insertions(+), 690 deletions(-)
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_flash_pcmcia.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_ide.h
 delete mode 100644 drivers/ide/phoenix_ide.c

diff --git a/arch/mips/include/asm/netlogic/nlm_common_flash_pcmcia.h b/arch/mips/include/asm/netlogic/nlm_common_flash_pcmcia.h
deleted file mode 100644
index 2d3803c..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_flash_pcmcia.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _FLASH_PCMCIA_H_
-#define _FLASH_PCMCIA_H_
-
-#define R_FLASH_PCMCIA_BASE_ADDR                    0x0
-#define   O_BASE_ADDR__base_addr                    0
-#define   W_BASE_ADDR__base_addr                    16
-#define R_FLASH_PCMCIA_BASE_ADDR_MASK               0x1
-#define   O_BASE_ADDR_MASK__base_amask              0
-#define   W_BASE_ADDR_MASK__base_amask              16
-#define R_FLASH_PCMCIA_DEV_PARM                     0x2
-#define   O_DEV_PARM__burst_mode_en                 0
-#define   O_DEV_PARM__burst_mode                    1
-#define   W_DEV_PARM__burst_mode                    3
-#define   O_DEV_PARM__wait_en                       4
-#define   O_DEV_PARM__wait_pol                      5
-#define   O_DEV_PARM__mx_addr                       6
-#define   O_DEV_PARM__dwidth                        7
-#define   W_DEV_PARM__dwidth                        2
-#define   O_DEV_PARM__pcmcia_en                     9
-#define   O_DEV_PARM__genif_en                      10
-#define   O_DEV_PARM__genparity_en                  11
-#define   O_DEV_PARM__genparity_type                12
-#define   O_DEV_PARM__adv_type                      13
-#define R_FLASH_TIMING_PARM_0                       0x3
-#define   O_FLASH_TIMING_PARM_0__ale_width          0
-#define   W_FLASH_TIMING_PARM_0__ale_width          3
-#define   O_FLASH_TIMING_PARM_0__ale_to_cs          3
-#define   W_FLASH_TIMING_PARM_0__ale_to_cs          3
-#define   O_FLASH_TIMING_PARM_0__cs_width           6
-#define   W_FLASH_TIMING_PARM_0__cs_width           5
-#define   O_FLASH_TIMING_PARM_0__wait_to_data       11
-#define   W_FLASH_TIMING_PARM_0__wait_to_data       5
-#define   O_FLASH_TIMING_PARM_0__cs_to_oe           16
-#define   W_FLASH_TIMING_PARM_0__cs_to_oe           3
-#define   O_FLASH_TIMING_PARM_0__cs_to_we           19
-#define   W_FLASH_TIMING_PARM_0__cs_to_we           3
-#define   O_FLASH_TIMING_PARM_0__oe_to_cs           22
-#define   W_FLASH_TIMING_PARM_0__oe_to_cs           2
-#define   O_FLASH_TIMING_PARM_0__we_to_cs           24
-#define   W_FLASH_TIMING_PARM_0__we_to_cs           4
-#define   O_FLASH_TIMING_PARM_0__cs_to_cs           28
-#define   W_FLASH_TIMING_PARM_0__cs_to_cs           4
-#define R_FLASH_TIMING_PARM_1                       0x4
-#define   O_FLASH_TIMING_PARM_1__oe_width           0
-#define   W_FLASH_TIMING_PARM_1__oe_width           6
-#define   O_FLASH_TIMING_PARM_1__we_width           6
-#define   W_FLASH_TIMING_PARM_1__we_width           6
-#define   O_FLASH_TIMING_PARM_1__wait_timeout       12
-#define   W_FLASH_TIMING_PARM_1__wait_timeout       15
-#define R_PCMCIA_CONFIG                             0x5
-#define   O_PCMCIA_CONFIG__pcmcia_en                0
-#define   O_PCMCIA_CONFIG__reg_access               1
-#define   O_PCMCIA_CONFIG__reset                    2
-#define   O_PCMCIA_CONFIG__cdmask                   4
-#define   O_PCMCIA_CONFIG__wpmask                   5
-#define   O_PCMCIA_CONFIG__rdymask                  6
-#define   O_PCMCIA_CONFIG__rybymask                 7
-#define R_PCMCIA_STATUS                             0x6
-#define   O_PCMCIA_STATUS__bvd1_sts                 0
-#define   O_PCMCIA_STATUS__bvd2_sts                 1
-#define   O_PCMCIA_STATUS__cd1_sts                  2
-#define   O_PCMCIA_STATUS__cd2_sts                  3
-#define   O_PCMCIA_STATUS__vs1_sts                  4
-#define   O_PCMCIA_STATUS__vs2_sts                  5
-#define   O_PCMCIA_STATUS__wp_sts                   6
-#define   O_PCMCIA_STATUS__rdy_sts                  7
-#define   O_PCMCIA_STATUS__ryby_sts                 8
-#define   O_PCMCIA_STATUS__cd_intr                  9
-#define   O_PCMCIA_STATUS__wp_intr                  10
-#define   O_PCMCIA_STATUS__rdy_intr                 11
-#define   O_PCMCIA_STATUS__illegal_addr_intrpt      12
-#define   O_PCMCIA_STATUS__mutl_cs_intrpt           13
-#define   O_PCMCIA_STATUS__wait_timeout_intrpt      14
-#define   O_PCMCIA_STATUS__ryby_intrpt              16
-#define   O_PCMCIA_STATUS__werr_intrpt              17
-#define   O_PCMCIA_STATUS__illegal_pcmcia_intrpt    18
-#define R_GENERIC_REGION_STATUS                     0x7
-#define   O_GENERIC_REGION_STATUS__cs_err_intrpt    0
-#define   W_GENERIC_REGION_STATUS__cs_err_intrpt    8
-#define R_GENERIC_ERROR_ADDR                        0x8
-#define   O_GENERIC_ERROR_ADDR__err_addr            0
-#define   W_GENERIC_ERROR_ADDR__err_addr            32
-
-
-#endif /* _FLASH_PCMCIA_H_ */
-
diff --git a/arch/mips/include/asm/netlogic/nlm_common_ide.h b/arch/mips/include/asm/netlogic/nlm_common_ide.h
deleted file mode 100644
index e2cf1fe..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_ide.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __ASM_NETLOGIC_H
-#define __ASM_NETLOGIC_H
-
-
-#define  CONFIG_XLR 1
-
-#ifdef CONFIG_XLR
-#define NETLOGIC_BOARD_NAME "XLR -ATX1"
-#define NETLOGIC_HAVE_PCMCIA 0
-#define NETLOGIC_HAVE_IDE    1
-#endif
-
-
-#ifdef NETLOGIC_HAVE_IDE
-#define IDE_CS          6
-#define IDE_PHYS        0x1D000000
-#define K_GPIO_GB_IDE   4
-#define K_GPIO_PC_READY 11 
-#define K_INT_GPIO_0    32 
-#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
-#endif
-
-#ifdef NETLOGIC_HAVE_PCMCIA
-#define PCMCIA_CS       4
-#define PCMCIA_PHYS     0x11000000
-#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
-#endif
-
-
-#define IOADDR(a) (UNCAC_BASE + (a))
-
-#endif /* __ASM_NETLOGIC_H */
diff --git a/drivers/ide/phoenix_ide.c b/drivers/ide/phoenix_ide.c
deleted file mode 100644
index a79f437..0000000
--- a/drivers/ide/phoenix_ide.c
+++ /dev/null
@@ -1,522 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
-This is a derived work from software originally provided by the external
-entity identified below. The licensing terms and warranties specified in
-the header of the original work apply to this derived work.
-
-*****************************#NETL_1#********************************/
-
-/*  Derived loosely from ide-pmac.c, so:
- *  
- *  Copyright (C) 1998 Paul Mackerras.
- *  Copyright (C) 1995-1998 Mark Lord
- */
-
-/*
- * Boards with xlr processors so far have supported IDE devices via
- * the Generic Bus, PCI bus, and built-in PCMCIA interface.  In all
- * cases, byte-swapping must be avoided for these devices (whereas
- * other PCI devices, for example, will require swapping).  Any
- * xlr-targetted kernel including IDE support will include this
- * file.  Probing of a Generic Bus for an IDE device is controlled by
- * the definitions of "NETLOGIC_HAVE_IDE" and "IDE_PHYS", which are
- * provided by <asm/netlogic/nlm_common_ide.h> for ATX1 boards.
- */
-
-#include <linux/kernel.h>
-#include <linux/ide.h>
-#include <linux/platform_device.h>
-#include <asm/netlogic/nlm_common_ide.h>
-#include <asm/netlogic/64bit.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/sim.h>
-
-#ifdef CONFIG_MIPS
-#include <asm/ide.h>
-#else
-#include <asm-generic/ide_iops.h>
-#endif
-
-/* #define DEBUG_PORT  */
-
-#define GPIO_INTR_CLR_REG    0x1EF19180
-#define PCMCIA_CONFIG_REG    0x1EF19140
-
-/*
- * Our non-swapping I/O operations.  
- */
-static inline void nlm_common_outb(u8 val, unsigned long port) 
-{
-	unsigned int flags=0;
-#ifdef DEBUG_PORT
-	printk(" %s port = %x %x \n", __FUNCTION__, (mips_io_port_base + port),val);
-#endif
-
-	flags = nlm_br_write_lock();
-	*(volatile u8 *)(mips_io_port_base + (port)) = val;
-	nlm_br_write_unlock(flags);
-}
-
-static inline void nlm_common_outw(u16 val, unsigned long port) 
-{
-	unsigned int flags=0;
-#ifdef DEBUG_PORT
-	printk("%s  port = %x  %x\n",__FUNCTION__,  (mips_io_port_base + port),val);
-#endif
-	flags = nlm_br_write_lock();
-	*(volatile u16 *)(mips_io_port_base + (port)) = val;
-	nlm_br_write_unlock(flags);
-}
-
-static inline void nlm_common_outl(u32 val, unsigned long port) 
-{
-	unsigned int flags=0;
-#ifdef DEBUG_PORT
-	printk("%s  port = %x %x\n",__FUNCTION__,  (mips_io_port_base + port),val);
-#endif
-	flags = nlm_br_write_lock();
-	*(volatile u32 *)(mips_io_port_base + (port)) = val;
-	nlm_br_write_unlock(flags);
-}
-
-static inline unsigned char nlm_common_inb(unsigned long port)
-{
-	unsigned int flags=0;
-	unsigned char val ;
-
-	flags = nlm_br_read_lock();
-	val =  (*(volatile u8 *)(mips_io_port_base + (port)));
-	nlm_br_read_unlock(flags);
-#ifdef DEBUG_PORT
-	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
-#endif
-	return val;
-}
-
-static inline unsigned short nlm_common_inw(unsigned long port)
-{
-	unsigned int flags=0;
-	unsigned short val ;
-	flags = nlm_br_read_lock();
-	val = (*(volatile u16 *)(mips_io_port_base + (port)));
-	nlm_br_read_unlock(flags);
-#ifdef DEBUG_PORT
-	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
-#endif
-	return val;
-}
-
-static inline unsigned int nlm_common_inl(unsigned long port)
-{
-	unsigned int flags=0;
-	unsigned int val ;
-	flags = nlm_br_read_lock();
-	val =  (*(volatile u32 *)(mips_io_port_base + (port)));
-	nlm_br_read_unlock(flags);
-#ifdef DEBUG_PORT
-	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
-#endif
-	return val;
-}
-
-static inline void nlm_common_outsb(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		nlm_common_outb(*(u8 *)addr, port);
-		addr++;
-	}
-}
-
-static inline void nlm_common_insb(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u8 *)addr = nlm_common_inb(port);
-		addr++;
-	}
-}
-
-static inline void nlm_common_outsw(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		nlm_common_outw(*(u16 *)addr, port);
-		addr += 2;
-	}
-}
-
-static inline void nlm_common_insw(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u16 *)addr = nlm_common_inw(port);
-		addr += 2;
-	}
-}
-
-static inline void nlm_common_outsl(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		nlm_common_outl(*(u32 *)addr, port);
-		addr += 4;
-	}
-}
-
-static inline void nlm_common_insl(unsigned long port, void *addr, unsigned int count)
-{
-	while (count--) {
-		*(u32 *)addr = nlm_common_inl(port);
-		addr += 4;
-	}
-}
-
-
-/* Note:
-   Following functions are taken from drivers/ide/ide-io-std.c
-   unmodified, as required for PCMCIA.
-   The original functions in drivers/ide/ide-io-std.c have been modified so 
-   that PCI devices work properly
-   */
-
-/*
- *	Conventional PIO operations for ATA devices
- */
-
-static u8 ide_inb(unsigned long port)
-{
-	return (u8) inb(port);
-}
-
-static void ide_outb(u8 val, unsigned long port)
-{
-	outb(val, port);
-}
-
-/*
- *	MMIO operations, typically used for SATA controllers
- */
-
-static u8 ide_mm_inb(unsigned long port)
-{
-	return (u8) readb((void __iomem *) port);
-}
-
-static void ide_mm_outb(u8 value, unsigned long port)
-{
-	writeb(value, (void __iomem *) port);
-}
-
-static void nlm_common_ide_exec_command(ide_hwif_t *hwif, u8 cmd)
-{
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writeb(cmd, (void __iomem *)hwif->io_ports.command_addr);
-	else
-		outb(cmd, hwif->io_ports.command_addr);
-}
-
-static u8 nlm_common_ide_read_status(ide_hwif_t *hwif)
-{
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		return readb((void __iomem *)hwif->io_ports.status_addr);
-	else
-		return inb(hwif->io_ports.status_addr);
-}
-
-static u8 nlm_common_ide_read_altstatus(ide_hwif_t *hwif)
-{
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		return readb((void __iomem *)hwif->io_ports.ctl_addr);
-	else
-		return inb(hwif->io_ports.ctl_addr);
-}
-
-static void nlm_common_ide_write_devctl(ide_hwif_t *hwif, u8 ctl)
-{
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writeb(ctl, (void __iomem *)hwif->io_ports.ctl_addr);
-	else
-		outb(ctl, hwif->io_ports.ctl_addr);
-}
-
-static void nlm_common_ide_dev_select(ide_drive_t *drive)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	u8 select = drive->select | ATA_DEVICE_OBS;
-
-	if (hwif->host_flags & IDE_HFLAG_MMIO)
-		writeb(select, (void __iomem *)hwif->io_ports.device_addr);
-	else
-		outb(select, hwif->io_ports.device_addr);
-}
-
-static void nlm_common_ide_tf_load(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct ide_io_ports *io_ports = &hwif->io_ports;
-	void (*tf_outb)(u8 addr, unsigned long port);
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-
-	if (mmio)
-		tf_outb = ide_mm_outb;
-	else
-		tf_outb = ide_outb;
-
-	if (valid & IDE_VALID_FEATURE)
-		tf_outb(tf->feature, io_ports->feature_addr);
-	if (valid & IDE_VALID_NSECT)
-		tf_outb(tf->nsect, io_ports->nsect_addr);
-	if (valid & IDE_VALID_LBAL)
-		tf_outb(tf->lbal, io_ports->lbal_addr);
-	if (valid & IDE_VALID_LBAM)
-		tf_outb(tf->lbam, io_ports->lbam_addr);
-	if (valid & IDE_VALID_LBAH)
-		tf_outb(tf->lbah, io_ports->lbah_addr);
-	if (valid & IDE_VALID_DEVICE)
-		tf_outb(tf->device, io_ports->device_addr);
-}
-
-static void nlm_common_ide_tf_read(ide_drive_t *drive, struct ide_taskfile *tf, u8 valid)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct ide_io_ports *io_ports = &hwif->io_ports;
-	u8 (*tf_inb)(unsigned long port);
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-
-	if (mmio)
-		tf_inb  = ide_mm_inb;
-	else
-		tf_inb  = ide_inb;
-
-	if (valid & IDE_VALID_ERROR)
-		tf->error  = tf_inb(io_ports->feature_addr);
-	if (valid & IDE_VALID_NSECT)
-		tf->nsect  = tf_inb(io_ports->nsect_addr);
-	if (valid & IDE_VALID_LBAL)
-		tf->lbal   = tf_inb(io_ports->lbal_addr);
-	if (valid & IDE_VALID_LBAM)
-		tf->lbam   = tf_inb(io_ports->lbam_addr);
-	if (valid & IDE_VALID_LBAH)
-		tf->lbah   = tf_inb(io_ports->lbah_addr);
-	if (valid & IDE_VALID_DEVICE)
-		tf->device = tf_inb(io_ports->device_addr);
-}
-
-/*
- * Some localbus EIDE interfaces require a special access sequence
- * when using 32-bit I/O instructions to transfer data.  We call this
- * the "vlb_sync" sequence, which consists of three successive reads
- * of the sector count register location, with interrupts disabled
- * to ensure that the reads all happen together.
- */
-static void ata_vlb_sync(unsigned long port)
-{
-	(void)inb(port);
-	(void)inb(port);
-	(void)inb(port);
-}
-
-/*
- * This is used for most PIO data transfers *from* the IDE interface
- *
- * These routines will round up any request for an odd number of bytes,
- * so if an odd len is specified, be sure that there's at least one
- * extra byte allocated for the buffer.
- */
-static void nlm_common_ide_input_data(ide_drive_t *drive, struct ide_cmd *cmd, void *buf,
-		    unsigned int len)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct ide_io_ports *io_ports = &hwif->io_ports;
-	unsigned long data_addr = io_ports->data_addr;
-	unsigned int words = (len + 1) >> 1;
-	u8 io_32bit = drive->io_32bit;
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-
-	if (io_32bit) {
-		unsigned long uninitialized_var(flags);
-
-		if ((io_32bit & 2) && !mmio) {
-			local_irq_save(flags);
-			ata_vlb_sync(io_ports->nsect_addr);
-		}
-
-		words >>= 1;
-		if (mmio)
-			__ide_mm_insl((void __iomem *)data_addr, buf, words);
-		else
-			insl(data_addr, buf, words);
-
-		if ((io_32bit & 2) && !mmio)
-			local_irq_restore(flags);
-
-		if (((len + 1) & 3) < 2)
-			return;
-
-		buf += len & ~3;
-		words = 1;
-	}
-
-	if (mmio)
-		__ide_mm_insw((void __iomem *)data_addr, buf, words);
-	else
-		insw(data_addr, buf, words);
-}
-
-/*
- * This is used for most PIO data transfers *to* the IDE interface
- */
-static void nlm_common_ide_output_data(ide_drive_t *drive, struct ide_cmd *cmd, void *buf,
-		     unsigned int len)
-{
-	ide_hwif_t *hwif = drive->hwif;
-	struct ide_io_ports *io_ports = &hwif->io_ports;
-	unsigned long data_addr = io_ports->data_addr;
-	unsigned int words = (len + 1) >> 1;
-	u8 io_32bit = drive->io_32bit;
-	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
-
-	if (io_32bit) {
-		unsigned long uninitialized_var(flags);
-
-		if ((io_32bit & 2) && !mmio) {
-			local_irq_save(flags);
-			ata_vlb_sync(io_ports->nsect_addr);
-		}
-
-		words >>= 1;
-		if (mmio)
-			__ide_mm_outsl((void __iomem *)data_addr, buf, words);
-		else
-			outsl(data_addr, buf, words);
-
-		if ((io_32bit & 2) && !mmio)
-			local_irq_restore(flags);
-
-		if (((len + 1) & 3) < 2)
-			return;
-
-		buf += len & ~3;
-		words = 1;
-	}
-
-	if (mmio)
-		__ide_mm_outsw((void __iomem *)data_addr, buf, words);
-	else
-		outsw(data_addr, buf, words);
-}
-
-const struct ide_tp_ops nlm_common_tp_ops = {
-	.exec_command		= nlm_common_ide_exec_command,
-	.read_status		= nlm_common_ide_read_status,
-	.read_altstatus		= nlm_common_ide_read_altstatus,
-	.write_devctl		= nlm_common_ide_write_devctl,
-
-	.dev_select		= nlm_common_ide_dev_select,
-	.tf_load		= nlm_common_ide_tf_load,
-	.tf_read		= nlm_common_ide_tf_read,
-
-	.input_data		= nlm_common_ide_input_data,
-	.output_data		= nlm_common_ide_output_data,
-};
-
-/* Note ends:
-   Above functions are taken from drivers/ide/ide-io-std.c
-   */
-
-static const struct ide_port_info nlm_common_port_info = {
-	.tp_ops			= &nlm_common_tp_ops,
-	.host_flags 		= IDE_HFLAG_NO_DMA,
-};
-
-#define NETLOGIC_IDE_REG(pcaddr) (IOADDR(IDE_PHYS) + ((pcaddr)) - mips_io_port_base)
-
-/*
- * nlm_common_ide_probe :
- *      - Probe the PCMCIA interface
- *        on selected  XLR Boards.
- */
-
-static int __devinit nlm_common_ide_probe (struct platform_device *dev)
-{
-#if defined(NETLOGIC_HAVE_IDE) && defined(IDE_PHYS)
-	unsigned int i = 0;
-	int ret = 0;
-	struct ide_host *host;
-	struct ide_hw hw, *hws[] = { &hw };
-	ide_hwif_t *nlm_common_ide_hwif;
-	extern int dev_tree_en;
-	extern int fdt_get_flash_enabled(void);
-
-	if(dev_tree_en && fdt_get_flash_enabled() == 0) {
-		printk("FLASH disabled by boot arg, skipping..\n");
-		return 0;
-	}
-
-
-	if (xlr_board_atx_iii() || xlr_board_atx_v())
-	{
-		printk("** Skipping PCMCIA Interface Probe.\n");
-		goto out;
-	}
-
-	printk ("Initializing xlr PCMCIA IDE...\n");
-
-	memset(&hw, 0, sizeof(hw));
-	
-	/* setup ports here */
-	hw.io_ports.data_addr   = NETLOGIC_IDE_REG(0x1f0);
-	hw.io_ports.error_addr  = NETLOGIC_IDE_REG(0x1f1);
-	hw.io_ports.nsect_addr  = NETLOGIC_IDE_REG(0x1f2);
-	hw.io_ports.lbal_addr   = NETLOGIC_IDE_REG(0x1f3);
-	hw.io_ports.lbam_addr   = NETLOGIC_IDE_REG(0x1f4);
-	hw.io_ports.lbah_addr   = NETLOGIC_IDE_REG(0x1f5);
-	hw.io_ports.device_addr = NETLOGIC_IDE_REG(0x1f6);
-	hw.io_ports.status_addr = NETLOGIC_IDE_REG(0x1f7);
-	hw.io_ports.ctl_addr    = NETLOGIC_IDE_REG(0x3f6);
-	hw.io_ports.irq_addr    = NETLOGIC_IDE_REG(0x3f7);
-
-	hw.irq = PIC_PCMCIA_IRQ;
-	hw.dev = &dev->dev;
-
-	ret = ide_host_add(&nlm_common_port_info, hws, 1, &host);
-	if (ret)
-		goto out;
-
-	platform_set_drvdata(dev, host);
-
-	nlm_common_ide_hwif = host->ports[0];
-
-        printk("Netlogic XLR PCMCIA configured as IDE interface = %d\n", i);
-out:
-	return ret;
-
-#endif
-}
-
-static int nlm_common_ide_remove (struct platform_device *dev)
-{
-
-	return 0;
-}
-
-static struct platform_driver nlm_common_ide_driver = {
-	.driver = {
-		.name = "xlr-pcmcia",
-		.owner = THIS_MODULE,
-	},
-	.probe          = nlm_common_ide_probe,
-	.remove         = nlm_common_ide_remove,
-};
-
-static int __init nlm_common_ide_init(void)
-{
-	return platform_driver_register(&nlm_common_ide_driver);
-}
-
-static void __exit nlm_common_ide_exit(void)
-{
-	platform_driver_unregister(&nlm_common_ide_driver);
-}
-
-module_init(nlm_common_ide_init);
-module_exit(nlm_common_ide_exit);
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Netlogic XLR-PCMCIA IDE driver");
-- 
1.7.0.4

