From 4965e9ee4846b67a8ea9f3bdaae9744bd38359ac Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 8 Jul 2013 15:02:43 +0800
Subject: [PATCH 1/2] bcm-xlp: add cpu hotplug support

It mainly implements or enhances the necessary interfaces proposed in
Documentation/cpu-hotplug.txt, such interfaces include:

cpu offline:

    o cpu_disable

	Called by _cpu_down() to clear cpu_online_map & cpu_callin_map,
	disable all interrupts, and flush cache & tlb.

    o cpu_die

	Called by _cpu_down() to Wait for cpu die(ready to be 0)

    o play_dead

	Called by cpu_idle() to make cpu die(set ready to 0): Enter into
	a loop till it is waked up by user-space /sys interface
	(till ready is set to 1).

cpu online:

    o boot_secondary

	Called by __cpu_up to re-activate the cpu and make it exit from the
	loop of play_dead() and re-init the cpu via calling the following
	functions orderly: ptr_smp_boot -> smp_bootstrap -> start_secondary
	-> init_secondary -> smp_finish. The interrupts will be re-enabled
	in init_secondary and smp_finish.

The top-level functions for offline and online is cpu_down() and
cpu_up() respectively, they are called in drivers/base/cpu.c when 0 or 1
is written to the /sys interface: /sys/devices/system/cpu/cpuX/online

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                |    3 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h |    6 +
 arch/mips/include/asm/netlogic/xlp_pic.h         |    4 +
 arch/mips/kernel/sync-r4k.c                      |   16 +++
 arch/mips/netlogic/common/Makefile               |    4 +-
 arch/mips/netlogic/common/nlm_hal.c              |   43 +++++++
 arch/mips/netlogic/xlp/irq.c                     |   33 ++++++
 arch/mips/netlogic/xlp/on_chip.c                 |   57 +++++++++-
 arch/mips/netlogic/xlp/pic/xlp_pic.c             |    7 +-
 arch/mips/netlogic/xlp/smp.c                     |  130 +++++++++++++++++++++-
 drivers/mmc/host/sdhci-xlp.c                     |    2 +-
 11 files changed, 291 insertions(+), 14 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 36c7ca4..7ac4432 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -854,6 +854,7 @@ config NLM_XLP_BOARD
 	select NLM_XLP
 	select SYS_HAS_CPU_XLP
 	select SYS_SUPPORTS_SMP
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select HW_HAS_PCI
 	select ARCH_SUPPORTS_MSI
 	select SWAP_IO_SPACE
@@ -2694,7 +2695,7 @@ config ARCH_HIBERNATION_POSSIBLE
 
 config ARCH_SUSPEND_POSSIBLE
 	def_bool y
-	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP
+	depends on (SYS_SUPPORTS_HOTPLUG_CPU || !SMP) && !NLM_XLP
 
 source "kernel/power/Kconfig"
 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
index c57c6a6..8dfb74b 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
@@ -1098,6 +1098,12 @@ extern void nlm_hal_set_fmn_interrupt(int irq);
 extern void nlm_hal_disable_vc_intr(int node, int vc);
 extern void nlm_hal_enable_vc_intr(int node, int vc);
 
+extern void enable_msgconfig_int(void);
+extern void nlm_enable_vc_intr(void);
+extern void nlm_disable_vc_intr(void);
+extern void on_chip_shutoff_msgring(void);
+extern void cpu_hotplug_fixup_poe(int cpu, int flag);
+extern void fixup_irqs(unsigned int cpu, int flag);
 #endif /* #ifndef _NLH_FMN_H */
 
 	
diff --git a/arch/mips/include/asm/netlogic/xlp_pic.h b/arch/mips/include/asm/netlogic/xlp_pic.h
index 8a6dc2a..7593701 100644
--- a/arch/mips/include/asm/netlogic/xlp_pic.h
+++ b/arch/mips/include/asm/netlogic/xlp_pic.h
@@ -37,4 +37,8 @@
 #define XLP_IRTENT_DT			(1ULL << 19)
 #define XLP_IRTENT_DB(x)		((x & 7) << 16)
 #define XLP_IRTENT_DTE(x)		((x) & 0xffff)
+
+#define XLP_ITE_ENTRIES		8
+
+extern void xlp_prog_all_node_ites(void);
 #endif
diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index 99f913c..a040360 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -24,6 +24,9 @@ static atomic_t __cpuinitdata count_start_flag = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_start = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_stop = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_reference = ATOMIC_INIT(0);
+#ifdef CONFIG_HOTPLUG_CPU
+static atomic_t __cpuinitdata count_finish_flag = ATOMIC_INIT(0);
+#endif
 
 #define COUNTON	100
 #define NR_LOOPS 5
@@ -106,6 +109,11 @@ void __cpuinit synchronise_count_master(void)
 	 * so no point in alarming people
 	 */
 	printk("done.\n");
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* Safely mark the finish flag here */
+	atomic_set(&count_finish_flag, 1);
+#endif
 }
 
 void __cpuinit synchronise_count_slave(void)
@@ -125,6 +133,14 @@ void __cpuinit synchronise_count_slave(void)
 
 	local_irq_save(flags);
 
+#ifdef CONFIG_HOTPLUG_CPU
+	/* No need to re-sync it when up the cpu via cpu hotplug */
+	if (atomic_read(&count_finish_flag)) {
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+
 	/*
 	 * Not every cpu is online at the time this gets called,
 	 * so we first wait for the master to say everyone is ready
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 92a40c5..a8e44a2 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -3,9 +3,9 @@ obj-$(CONFIG_NLM_XLP) :=   cpu_proc.o memory.o bootinfo.o pic_hal.o pci_hal.o
 
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_sys.o nlm_evp_cpld.o nlm_hal_cpu_info.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_eeprom.o fdt_helper.o
-obj-$(CONFIG_XLP_NAE_SUPPORT)		+= nlm_hal_mdio.o nlm_hal_vsemi_config.o nlm_hal_nae_interface.o
+obj-$(CONFIG_XLP_FMN_SUPPORT)		+= nlm_hal_fmn_config.o nlm_hal_mdio.o
+obj-$(CONFIG_XLP_NAE_SUPPORT)		+= nlm_hal_vsemi_config.o nlm_hal_nae_interface.o
 obj-$(CONFIG_XLP_NAE_SUPPORT)		+= nlm_hal_nae.o 
-obj-$(CONFIG_XLP_FMN_SUPPORT)		+= nlm_hal_fmn_config.o
 obj-$(CONFIG_KEXEC)                   	+= nlm_kexec.o
 
 ifeq ($(CONFIG_NLM_CORTINA_SUPPORT),y)
diff --git a/arch/mips/netlogic/common/nlm_hal.c b/arch/mips/netlogic/common/nlm_hal.c
index 74ece23..ab27cb9 100644
--- a/arch/mips/netlogic/common/nlm_hal.c
+++ b/arch/mips/netlogic/common/nlm_hal.c
@@ -95,6 +95,7 @@
 #include "nlm_hal_sys.h"
 #include "libfdt.h"
 #include "fdt_helper.h"
+#include "msgring.h"
 
 /* These addresses are computed by the nlm_hal_init() */
 unsigned long xlp_io_base;
@@ -2061,6 +2062,48 @@ void nlm_hal_sata_init(void)
 	nlm_hal_sata_firmware_init();
 }
 
+#define NUM_VCS_PER_CPU 4
+
+#define NUM_DISTVEC_CELLS	16
+#define MIN_DIST_VEC 0
+#define MAX_DIST_VEC 16
+
+#define NUM_DISTVEC_CPUMASKS 4
+
+#define POE_DIST_VEC0 0x100
+
+void cpu_hotplug_fixup_poe(int cpu, int flag)
+{
+	unsigned long mflags = 0;
+	int reg_index;
+	uint32_t value, vcmask;
+	int cell, offset, vc = 0;
+	uint32_t distvec[NUM_DISTVEC_CELLS];
+	int node = cpu/32;
+	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
+
+	vcmask =  (1 << nae_cfg->rx_vc);
+	vc = (cpu * NUM_VCS_PER_CPU) % (NUM_DISTVEC_CELLS * 32);
+	cell = vc / 32;
+
+	reg_index = POE_DIST_VEC0 + (NUM_DISTVEC_CELLS - 1 - cell);
+
+	/* do we need to ensure nobody is operating on msgrng? */
+	msgrng_access_enable(mflags);
+	if (flag) {
+		/* online */
+		offset = vc % 32;
+		value = vcmask << offset;
+
+		distvec[cell] |= value;
+		nlm_hal_write_poe_pcim_reg(node, reg_index, value);
+	} else {
+		/* offline */
+		nlm_hal_write_poe_pcim_reg(node, reg_index, 0);
+	}
+	msgrng_access_disable(mflags);
+}
+
 uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module)
 {
 	char dom_node_str[32];
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index a12d586..7c97535 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -55,6 +55,9 @@
 #if defined CONFIG_PCI_MSI
 #include <asm/netlogic/msi.h>
 #endif
+#ifdef CONFIG_XLP_FMN_SUPPORT
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#endif
 
 /* About this file: irq.c
  * This file contains routines that handle all the low level interrupt stuff.
@@ -619,3 +622,33 @@ void __init arch_init_irq(void)
 	write_64bit_cp0_eimr(xlp_irq_mask);
 
 }
+
+#if defined(CONFIG_HOTPLUG_CPU)
+void fixup_irqs(unsigned int cpu, int flag)
+{
+#ifdef CONFIG_XLP_NAE_SUPPORT
+	/* Fix the POE configuration */
+	cpu_hotplug_fixup_poe(cpu, flag);
+
+	if (!flag) {
+		/*offline*/
+		on_chip_shutoff_msgring();
+		nlm_disable_vc_intr();
+		/* clear all pending interrupts (don't touch timer and soft,
+		 * they're special) */
+		write_64bit_cp0_eirr(0xffffffffffffff7c);
+		/* Mask out all interrupts */
+		write_64bit_cp0_eimr(0);
+	} else {
+		/*online*/
+		/* clear all pending interrupts (don't touch timer and soft,
+		 * they're special) */
+		write_64bit_cp0_eirr(0xffffffffffffff7c);
+		/* set interrupt mask for non-zero cpus */
+		write_64bit_cp0_eimr(xlp_irq_mask | (1 << XLP_IRQ_TIMER_RVEC));
+		enable_msgconfig_int();
+		nlm_enable_vc_intr();
+	}
+#endif
+}
+#endif
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 1aa34b8..4040be0 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -47,6 +47,7 @@
 #endif
 
 #include <linux/netdevice.h>
+#include <asm/netlogic/cpumask.h>
 
 #define MAX_VC	4096
 
@@ -621,8 +622,46 @@ int nlm_xlp_register_napi_final_handler(int major, void (*napi_final)(void *arg)
 
 EXPORT_SYMBOL(nlm_xlp_register_napi_final_handler);
 
+/* need COP2 to be accessible */
+static void on_chip_msgring_drain_msgs(void)
+{
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0;
+	uint64_t msg0, msg1, msg2, msg3;
+	unsigned int msg_status1 = 0, vc_empty_status = 0;
+	int cpu = hard_smp_processor_id();
+	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
 
-#include <asm/netlogic/cpumask.h>
+	msg0 = msg1 = msg2 = msg3 = 0;
+
+	/* loop is just to be safe, but should only hit once in theory */
+	for ( ; ; ) {
+		/* Read latest VC empty mask */
+		msg_status1 = xlp_read_status1();
+
+		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+		if (vc_empty_status == pop_vc_mask)
+			break;
+
+		for (vc = 0; vc < 4; vc++) {
+			if (!(pop_vc_mask & (1<<vc)))
+				continue;
+			(void) xlp_message_receive(vc, &src_id, &size,
+				&code, &msg0, &msg1, &msg2, &msg3);
+		}
+	}
+}
+
+void on_chip_shutoff_msgring(void)
+{
+	uint32_t __maybe_unused flags;
+
+	/* Need write interrupt vector to cp2 msgconfig register */
+	msgrng_access_enable(flags);
+	xlp_write_config(0);
+	on_chip_msgring_drain_msgs();
+	msgrng_access_disable(flags);
+}
 
 /*********************************************************************
  * enable_msgconfig_int 
@@ -664,6 +703,22 @@ void nlm_enable_vc_intr(void)
 	}
 }
 
+/*********************************************************************
+ * nlm_disable_vc_intr
+ *********************************************************************/
+void nlm_disable_vc_intr(void)
+{
+	int cpu = hard_smp_processor_id();
+	int vc_index = 0;
+	int i = 0;
+
+	for (i = 0; i < NLM_MAX_VC_PER_THREAD; i++) {
+		if (nlm_cpu_vc_mask[cpu] & (1<<i)) {
+			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			nlm_hal_disable_vc_intr(0, vc_index);
+		}
+	}
+}
 
 int xlp_fmn_poll(struct napi_struct *napi, int budget)
 {
diff --git a/arch/mips/netlogic/xlp/pic/xlp_pic.c b/arch/mips/netlogic/xlp/pic/xlp_pic.c
index 06807c7..87eed4e 100644
--- a/arch/mips/netlogic/xlp/pic/xlp_pic.c
+++ b/arch/mips/netlogic/xlp/pic/xlp_pic.c
@@ -1,13 +1,12 @@
-#include "xlp_pic.h"
 #include <asm/netlogic/pic_hal.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_irq_map.h>
-#define XLP_ITE_ENTRIES		8
+#include "xlp_pic.h"
 
 /*
  * xlp_ites[node][0-3] = {0x1, 0xffffffff, 0x0000ffff, 0xffff0000};//local only
  */
-static struct cpumask xlp_ites[NLM_MAX_NODES][XLP_ITE_ENTRIES];
+struct cpumask xlp_ites[NLM_MAX_NODES][XLP_ITE_ENTRIES];
 
 void ite_to_cpumask(u8 node, u8 idx, cpumask_t *m)
 {
@@ -47,7 +46,7 @@ void dump_all_ites(void)
  * @ite		: ITE index
  * @bitval	: 0 to clear, 1 to set
  */
-static void xlp_ite_cpu_op(struct pic_dev *pic, u8 cpu, u8 ite, u8 bitval)
+void xlp_ite_cpu_op(struct pic_dev *pic, u8 cpu, u8 ite, u8 bitval)
 {
 	unsigned long flags;
 	u64 val, reg;
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index b36b24e..b9a9882 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -32,6 +32,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
+#include <linux/cpu.h>
 #include <linux/irqreturn.h>
 #include <linux/interrupt.h>
 
@@ -60,6 +61,7 @@
 
 #include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 #include <asm/netlogic/xlp_hal_pic.h>
+#include <asm/netlogic/xlp_pic.h>
 
 struct smp_boot_info smp_boot;
 EXPORT_SYMBOL(smp_boot);
@@ -74,13 +76,11 @@ extern unsigned long nlm_common_ebase;
 extern void enable_cpus(unsigned int node, unsigned online_mask);
 extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
-#ifdef CONFIG_XLP_FMN_SUPPORT
-extern void enable_msgconfig_int(void);
-void nlm_enable_vc_intr(void);
-#endif
 extern void xlp_pic_ite_init(const struct cpumask *);
+extern struct cpumask xlp_ites[NLM_MAX_NODES][XLP_ITE_ENTRIES];
 static int node_exist[NLM_MAX_NODES];
 
+
 /*
  * Input parameter is logical cpu number.
  * Should convert to physical cpu before using it
@@ -143,18 +143,75 @@ static void __cpuinit nlm_init_secondary(void)
 	}
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static atomic_t __cpuinitdata cpu_hotplug_flag = ATOMIC_INIT(0);
+static DEFINE_RAW_SPINLOCK(smp_reserve_lock);
+
+static int __cpuinit nlm_cpu_callback(struct notifier_block *nfb,
+	unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		pr_info("Cpu %d online\n", cpu);
+		break;
+	case CPU_DEAD:
+		pr_info("Cpu %d offline\n", cpu);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata nlm_cpu_notifier = {
+	.notifier_call = nlm_cpu_callback,
+};
+
+static int __cpuinit register_nlm_notifier(void)
+{
+	register_hotcpu_notifier(&nlm_cpu_notifier);
+
+	return 0;
+}
+
+late_initcall(register_nlm_notifier);
+
+#endif	/* CONFIG_HOTPLUG_CPU */
+
 void nlm_smp_finish(void)
 {
+#ifdef CONFIG_HOTPLUG_CPU
+	u8 ite, node;
+	int cpu = hard_smp_processor_id();
+	unsigned long flags;
+	struct pic_dev *pic;
+	node = cpu/32;
+
+	if (atomic_read(&cpu_hotplug_flag)) {
+		atomic_set(&cpu_hotplug_flag, 0);
+		raw_spin_lock_irqsave(&smp_reserve_lock, flags);
+		/* Enable IRQs on the cpu */
+		for (ite = 0; ite < XLP_ITE_ENTRIES; ite++) {
+			if (ite != 4)
+				cpumask_set_cpu(cpu, &(xlp_ites[0][ite]));
+		}
+		xlp_prog_all_node_ites();
+		fixup_irqs(cpu, 1);
+		raw_spin_unlock_irqrestore(&smp_reserve_lock, flags);
+	}
+#endif
 	local_irq_enable();
 }
 
 
 int irq_select_affinity_usr(unsigned int irq);
-void xlp_prog_all_node_ites(void );
 
 static long fmn_config(void *arg)
 {
         extern void *fdt;
+	int cpu = hard_smp_processor_id();
+
         printk("Doing fmn init from cpu %d for node %d\n", hard_smp_processor_id(), (int)(long)arg);
         nlm_hal_fmn_init(fdt, (int)(long)arg);
         return 0;
@@ -337,6 +394,65 @@ void nlm_prepare_cpus(unsigned int max_cpus)
 	}
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int nlm_cpu_disable(void)
+{
+	u8 ite, node;
+	int cpu = hard_smp_processor_id();
+	struct pic_dev *pic;
+	unsigned long flags;
+	node = cpu/32;
+
+	if (cpu == 0)
+		return -EBUSY;
+	atomic_set(&cpu_hotplug_flag, 1);
+	set_cpu_online(cpu, false);
+	cpu_clear(cpu, cpu_callin_map);
+
+	raw_spin_lock_irqsave(&smp_reserve_lock, flags);
+
+	for (ite = 0; ite < XLP_ITE_ENTRIES; ite++) {
+		if (ite != 4)
+			cpumask_clear_cpu(cpu, &(xlp_ites[0][ite]));
+	}
+	xlp_prog_all_node_ites();
+
+	local_irq_enable();
+	fixup_irqs(cpu, 0);
+
+	flush_cache_all();
+	local_flush_tlb_all();
+
+	raw_spin_unlock_irqrestore(&smp_reserve_lock, flags);
+
+	return 0;
+}
+
+static void nlm_cpu_die(unsigned int logical_cpu)
+{
+	int cpu = cpu_logical_map(logical_cpu);
+
+	while (smp_boot.boot_info[cpu].ready)
+		cpu_relax();
+}
+
+void play_dead(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct smp_boot_info_percpu *bic;
+
+	bic = smp_boot.boot_info + cpu;
+	idle_task_exit();
+	bic->ready = 0;
+
+	local_irq_disable();
+	while (!bic->ready)
+		cpu_relax();
+
+	ptr_smp_boot(bic->fn, bic->sp, bic->gp);
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
 struct plat_smp_ops nlm_smp_ops = {
     .send_ipi_single    = nlm_send_ipi_single,
     .send_ipi_mask      = nlm_send_ipi_mask,
@@ -346,6 +462,10 @@ struct plat_smp_ops nlm_smp_ops = {
     .boot_secondary     = nlm_boot_secondary,
     .smp_setup      	= nlm_smp_setup,
     .prepare_cpus       = nlm_prepare_cpus,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_disable	= nlm_cpu_disable,
+	.cpu_die	= nlm_cpu_die,
+#endif
 };
 
 void prom_boot_cpus_secondary(void *args)
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
index 8feb9a5..130f801 100644
--- a/drivers/mmc/host/sdhci-xlp.c
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -285,7 +285,7 @@ static int sdhci_pltfm_suspend(struct platform_device *dev, pm_message_t state)
 {
 	struct sdhci_host *host = platform_get_drvdata(dev);
 
-	return sdhci_suspend_host(host, state);
+	return sdhci_suspend_host(host);
 }
 
 static int sdhci_pltfm_resume(struct platform_device *dev)
-- 
1.7.0.4

