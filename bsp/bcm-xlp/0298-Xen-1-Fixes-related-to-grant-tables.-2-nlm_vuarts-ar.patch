From fbf030d6e2ad3154a811692dc828ad9f0606089f Mon Sep 17 00:00:00 2001
From: Rahul Jain <rajain@netlogicmicro.com>
Date: Tue, 1 Feb 2011 11:59:41 +0530
Subject: [PATCH 298/762] Xen 1) Fixes related to grant-tables. 2) nlm_vuarts are now using grant-tables. 3) "/dev/nlm_vuart" device gets created and when "vuartio" userspace application opens and mmaps the device. Currently, NUM_VUARTS/2 pages are shared, one page for each domain starting from 0. 4) Support for sharing of pages for a particular service for a domain_id has been added. 5) Added a new case for grant_table_op: GNTTABOP_update_service 6) Shared memory driver added 7) /dev/nlm_sharedmem[0-10] being created with major no 252 and minor no from 0 to 10 8) In domctl.h, added structure xen_max_mem 9) Grant_table.c: Added function for get_current_reservation, total_reservation and setting_max_mem 10) Shared Memory (/dev/sharedmem)stuff is working.

Based on Broadcom SDK 2.3.

Signed-off-by: Rahul Jain <rajain@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/xen/hypercall.h |    6 +
 drivers/char/Makefile                 |    1 +
 drivers/char/nlm_sharedmem.c          |  210 +++++++++++++++++++++++++++++++++
 drivers/char/nlm_vuart.c              |  132 +++++++++++----------
 include/xen/interface/domctl.h        |   11 ++
 include/xen/interface/grant_table.h   |   35 ++++++
 mm/memory.c                           |    2 +-
 7 files changed, 333 insertions(+), 64 deletions(-)
 create mode 100644 drivers/char/nlm_sharedmem.c

diff --git a/arch/mips/include/asm/xen/hypercall.h b/arch/mips/include/asm/xen/hypercall.h
index 634e323..e06a331 100644
--- a/arch/mips/include/asm/xen/hypercall.h
+++ b/arch/mips/include/asm/xen/hypercall.h
@@ -434,6 +434,12 @@ HYPERVISOR_grant_table_op(unsigned int cmd, void *uop, unsigned int count)
 }
 
 static inline int
+HYPERVISOR_grant_table_op2(unsigned int cmd, void *uop, unsigned int count)
+{
+	return _hypercall3(int, grant_table_op2, cmd, uop, count);
+}
+
+static inline int
 HYPERVISOR_update_va_mapping_otherdomain(unsigned long va, pte_t new_val,
 					 unsigned long flags, domid_t domid)
 {
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7e19e27..79c0509 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_PCMCIA)		+= pcmcia/
 obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_NLM_XLR) 	+= nlm_common_tb.o
 obj-$(CONFIG_NLM_COMMON)	+= nlm_vuart.o
+obj-$(CONFIG_NLM_COMMON)	+= nlm_sharedmem.o
 obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER) += nlm_pcix_gen_dev.o
 obj-$(CONFIG_NLMCOMMON_PCIX_GEN_DRIVER) += nlm_pcix_gen_host.o
 obj-$(CONFIG_NLMCOMMON_CONSOLE_OVER_PCI) += xlr_pcix_console_dev.o
diff --git a/drivers/char/nlm_sharedmem.c b/drivers/char/nlm_sharedmem.c
new file mode 100644
index 0000000..7d5eccf
--- /dev/null
+++ b/drivers/char/nlm_sharedmem.c
@@ -0,0 +1,210 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ( Netlogic ). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+
+#include <xen/interface/xen.h>
+#include <xen/grant_table.h>
+#include <asm/xen/hypercall.h>
+
+#define SHAREDMEM_MAJOR            (252)
+#define SHAREDMEM_NAME             "nlm_sharedmem"
+#define NUM_SHAREDMEMS             (1)
+#define NLM_SHAREDMEM_ID           (101)
+#define MAX_EXTENTS                (1)
+#define MAX_EXTENT_ORDER           (12)
+#define MAX_PAGE_REQUEST           (MAX_EXTENTS)
+#define DOMID                      (0)
+#define DOMAIN_ID_OPTION           (1)
+#define MAX_MINOR_NUMBERS          (256)
+
+static unsigned long shared_memory_mfn[MAX_MINOR_NUMBERS] = {0};
+static int num_order[MAX_MINOR_NUMBERS] = {0};
+static int domain_id = 1;
+
+extern int gnttab_grant_foreign_access(domid_t domid, unsigned long frame, int readonly);
+extern int gnttab_update_service (uint32_t service_for_dom_id, uint32_t start_ref_id, 
+								  uint32_t nr_pages, uint32_t pfn, uint32_t service_id);
+extern int xen_get_maximum_reservation (uint32_t dom_id);
+extern int xen_get_current_reservation (uint32_t dom_id);
+extern int xen_increase_max_mem (uint32_t dom_id, uint64_t max_mem);
+extern int xen_increase_reservation (uint32_t dom_id, int n_extents, int n_extent_order);
+extern xen_pfn_t p2m_host[MAX_EXTENTS];
+
+static int sharedmem_open (struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static int sharedmem_release (struct inode *inode, struct file *file) {
+	return 0;
+}
+
+static ssize_t sharedmem_read (struct file *file, char *buf,
+							   size_t count, loff_t *ppos) {
+	return 0;
+}
+
+static ssize_t sharedmem_write (struct file *file, const char *buf,
+								size_t count, loff_t *ppos) {
+	return 0;
+}
+
+static int sharedmem_ioctl(struct inode *inode, struct file *file,
+						   unsigned int cmd, unsigned long arg) {
+	return 0;
+}
+
+static long sharedmem_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
+       
+	/* Will be called during 32 bit user space applications */
+	int ret = 0;
+	switch ( cmd ) {
+	case DOMAIN_ID_OPTION:/* for writing data to arg */
+		if (copy_from_user(&domain_id, (int *)arg, sizeof(int)))
+			return -EFAULT;
+#ifdef DEBUG
+		printk ("%s: domain id is %d\n", __func__, domain_id);
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int sharedmem_mmap(struct file * filep, struct vm_area_struct * vma)
+{
+	int ref = 0, i, order;
+	int minor = iminor (filep->f_dentry->d_inode);
+       
+	order = get_order (vma->vm_end - vma->vm_start);
+       
+	if (num_order [minor] && order > num_order [minor]) {
+		printk ("Order %d > already allocated memory of order %d\n", 
+				order, num_order[minor]);
+		return -EAGAIN;
+	}
+              
+	if (!shared_memory_mfn[minor]) {
+		int req_pages, ret;
+		unsigned long mfn;
+		int tot_pages, max_pages;
+
+		tot_pages = xen_get_current_reservation (DOMID_SELF);
+		max_pages = xen_get_maximum_reservation (DOMID_SELF);
+
+		req_pages = (1 << order);
+		ret = xen_increase_max_mem (DOMID, ((req_pages + max_pages) * PAGE_SIZE) >> 10);
+		if (ret == 0) {
+			max_pages = xen_get_maximum_reservation (DOMID_SELF);
+			ret = xen_increase_reservation (DOMID_SELF, MAX_EXTENTS, order);
+			if (ret != MAX_EXTENTS) {
+				printk ("(%s): xen_increase_reservation failed with error = %d\n", __func__, ret);
+				goto err;
+			}
+
+			tot_pages = xen_get_current_reservation (DOMID_SELF);
+			max_pages = xen_get_maximum_reservation (DOMID_SELF);
+			mfn = p2m_host[MAX_EXTENTS - 1];
+			shared_memory_mfn[minor] = mfn;
+			num_order[minor] = order;
+			goto out;
+		}
+		else {
+			printk ("(%s): xen_increase_max_mem failed with error = %d\n", __func__, ret);
+			goto err;
+		}
+	err:
+		/* Reduce max_mem to old value */
+		xen_increase_max_mem (DOMID, (max_pages * PAGE_SIZE) >> 10);
+		return ret;
+	}
+out:
+	if (remap_pfn_range (vma, (unsigned long) vma->vm_start, shared_memory_mfn[minor],
+						 1 << (order + PAGE_SHIFT), vma->vm_page_prot))	{
+		printk ("%s mapping failed \n", __func__);
+		return -EAGAIN;
+	}
+	for (i = 0; i < (1 << num_order [minor]); i++) {
+		ref = gnttab_grant_foreign_access (domain_id, shared_memory_mfn [minor] + i, 0);
+		if (ref < 0)
+			printk ("%s Grant foreign access failed ref = %d for page index %d\n", __func__, ref, i);
+		if (!i)
+			gnttab_update_service (domain_id, ref, 1 << num_order [minor], 
+								   shared_memory_mfn [minor], NLM_SHAREDMEM_ID + minor);
+	}
+	return 0;
+}
+
+struct file_operations sharedmem_fops = {
+	.owner	      =	THIS_MODULE,
+	.read	      =	sharedmem_read,
+	.write	      =	sharedmem_write,
+	.mmap	      =	sharedmem_mmap,
+	.ioctl	      =	sharedmem_ioctl,
+	.compat_ioctl =	sharedmem_compat_ioctl,
+	.open	      =	sharedmem_open,
+	.release      =	sharedmem_release,
+};
+
+static int sharedmem_init (void)
+{
+	int ret;
+
+	ret = register_chrdev (SHAREDMEM_MAJOR, SHAREDMEM_NAME, &sharedmem_fops);
+	if (ret != 0) {
+		printk("[%s] Failed to register packet memory char device major=%d\n", 
+			   __FUNCTION__, SHAREDMEM_MAJOR);
+		return -EIO;
+	}
+
+	printk("[%s] Registered packet memory char device major=%d\n", 
+		   __FUNCTION__, SHAREDMEM_MAJOR);
+	return 0;
+}
+
+static void sharedmem_cleanup (void)
+{
+	printk("cleaning up module\n");
+	unregister_chrdev (SHAREDMEM_MAJOR, SHAREDMEM_NAME);
+}
+
+module_init(sharedmem_init);
+module_exit(sharedmem_cleanup);
+MODULE_AUTHOR("Netlogic");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Shared Memory driver");
diff --git a/drivers/char/nlm_vuart.c b/drivers/char/nlm_vuart.c
index 3bdc310..0b0e778 100644
--- a/drivers/char/nlm_vuart.c
+++ b/drivers/char/nlm_vuart.c
@@ -22,6 +22,7 @@ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.
 *****************************#NETL_2#********************************/
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/version.h>
@@ -36,6 +37,11 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/mman.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
+#include <linux/device.h>
+
+#include <xen/interface/xen.h>
+#include <xen/grant_table.h>
+#include <asm/xen/hypercall.h>
 
 #define VUART_MAJOR 251
 #define VUART_NAME "nlm_vuart"
@@ -46,11 +52,11 @@ static unsigned int counter = 0;
 static char string [128];
 static int data;
 
-static unsigned long uart_sharedcfg_base = (496 << 20);
-static unsigned long uart_sharedcfg_size = (4 << 20);
-
 DECLARE_WAIT_QUEUE_HEAD(vuart_wait);
 static int data_not_ready = 0;
+extern int gnttab_grant_foreign_access(domid_t domid, unsigned long frame, int readonly);
+extern void gnttab_update_service (uint32_t service_for_dom_id, uint32_t start_ref_id, 
+								   uint32_t nr_pages, uint64_t pfn, uint32_t service_id);
 
 static int vuart_open (struct inode *inode, struct file *file) {
 	return 0;
@@ -65,31 +71,34 @@ static ssize_t vuart_read (struct file *file, char *buf,
 {
 	int len, err;
 
-	printk("[%s]\n", __FUNCTION__);
-	// check if we have data - if not, sleep
-	// wake up in interrupt_handler
-	while (data_not_ready) {
+	/*
+	 * check if we have data - if not, sleep wake up in 
+	 * interrupt_handler
+	 */
+	while (data_not_ready)
 		interruptible_sleep_on(&vuart_wait);
-	}
-	//data_not_ready = 1;
 
-	if( counter <= 0 )
+	if (counter <= 0)
 		return 0;
+
 	err = copy_to_user(buf,string,counter);
 	if (err != 0)
 		return -EFAULT;
-	len  = counter;
+
+	len = counter;
 	counter = 0;
+
 	return len;
 }
 
-// write function called when to /dev/vuart is written
+/*
+ * write function called when to /dev/vuart is written
+ */
 static ssize_t vuart_write (struct file *file, const char *buf,
 			    size_t count, loff_t *ppos)
 {
 	int err;
 
-	printk("[%s]\n", __FUNCTION__);
 	err = copy_from_user(string,buf,count);
 	if (err != 0)
 		return -EFAULT;
@@ -99,22 +108,26 @@ static ssize_t vuart_write (struct file *file, const char *buf,
 	return count;
 }
 
-// ioctl - I/O control
 static int vuart_ioctl(struct inode *inode, struct file *file,
 		       unsigned int cmd, unsigned long arg) {
 	int retval = 0;
-	switch ( cmd ) {
-	case CASE1:/* for writing data to arg */
+
+	switch (cmd) {
+
+	case CASE1: /* for writing data to arg */
 		if (copy_from_user(&data, (int *)arg, sizeof(int)))
 			return -EFAULT;
 		break;
-	case CASE2:/* for reading data from arg */
+
+	case CASE2: /* for reading data from arg */
 		if (copy_to_user((int *)arg, &data, sizeof(int)))
 			return -EFAULT;
 		break;
+
 	default:
 		retval = -EINVAL;
 	}
+
 	return retval;
 }
 
@@ -126,78 +139,71 @@ static long vuart_compat_ioctl(struct file *filp, unsigned int cmd, unsigned lon
 	ret = vuart_ioctl(NULL, filp, cmd, arg);
 	unlock_kernel();
 
-	if(ret){
-		printk("vuart_ioctl returned with an error %lx", ret);
+	if (ret)
 		return -ENOIOCTLCMD;
-	}
+
 	return ret;
 }
 
+#define NUM_VUARTS 32
+#define NLM_VUART_ID 100
+static unsigned long shared_page_paddr = 0;
+
 static int vuart_mmap(struct file * filp, struct vm_area_struct * vma)
 {
-	unsigned long vm_size = vma->vm_end - vma->vm_start;
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-	unsigned long size = 0;
-
-	if (offset >= uart_sharedcfg_size) return -ESPIPE;
-
-	if (vma->vm_flags & VM_LOCKED) return -EPERM;
-
-	size = uart_sharedcfg_size - offset;
-	if (vm_size > size) return -ENOSPC;
-
-	vma->vm_flags |= (VM_RESERVED | VM_IO);
+	if (!shared_page_paddr) {
+		/* Sharing of page */
+		int i, ref;
+		char* free_page;
+		unsigned long mfn;
+
+		/* Each Page is shared by read and write vuarts */
+		free_page = (char *) __get_free_pages (GFP_KERNEL, get_order(NUM_VUARTS/2 * PAGE_SIZE));
+		mfn = __pa (free_page) >> PAGE_SHIFT;
+
+		for (i = 0; i < NUM_VUARTS/2; i++) {
+			ref = gnttab_grant_foreign_access (i, mfn + i, 0);
+			gnttab_update_service (i, ref, 1, mfn + i, NLM_VUART_ID);
+		}
+
+		shared_page_paddr = (unsigned long) __pa(free_page);
+	}
 
-        if (remap_pfn_range(vma, vma->vm_start, (uart_sharedcfg_base >> PAGE_SHIFT),
-			    size, vma->vm_page_prot))
+	if (remap_pfn_range (vma, (unsigned long) vma->vm_start, 
+						 shared_page_paddr >> PAGE_SHIFT, 
+						 1 << (PAGE_SHIFT + get_order (NUM_VUARTS/2 * PAGE_SIZE)), 
+						 vma->vm_page_prot))
 		return -EAGAIN;
 
-	printk("[%s]: pbase=%lx\n", __FUNCTION__, uart_sharedcfg_base);
-
 	return 0;
 }
 
-static DECLARE_WAIT_QUEUE_HEAD(vuart_read_wait);
-static DECLARE_WAIT_QUEUE_HEAD(vuart_write_wait);
-
-static unsigned int vuart_poll(struct file *filp, struct poll_table_struct *wait)
-{
-	unsigned int mask;
-
-	if (!filp->private_data) return -EINVAL;
-
-	mask = 0;
-
-	return mask;
-}
-
 struct file_operations vuart_fops = {
-	.owner	  =	THIS_MODULE,
-	.read	  =	vuart_read,
-	.write	  =	vuart_write,
-	.mmap	  =	vuart_mmap,
-	.poll	  =	vuart_poll,
-	.ioctl	  =	vuart_ioctl,
+	.owner	      =	THIS_MODULE,
+	.read	      =	vuart_read,
+	.write	      =	vuart_write,
+	.mmap	      =	vuart_mmap,
+	.ioctl	      =	vuart_ioctl,
 	.compat_ioctl =	vuart_compat_ioctl,
-	.open	  =	vuart_open,
-	.release  =	vuart_release,
+	.open	      =	vuart_open,
+	.release      =	vuart_release,
 };
 
 static int vuart_init (void)
 {
 	int ret;
 
-	ret = register_chrdev (VUART_MAJOR, VUART_NAME, &vuart_fops);
-	if (ret != 0)
-		return - EIO;
+	ret = register_chrdev(VUART_MAJOR, VUART_NAME, &vuart_fops);
+	if (ret != 0) {
+		printk("[%s] Failed to register char device major=%d\n", __FUNCTION__, VUART_MAJOR);
+		return -EIO;
+	}
 
-	printk("[%s] Registered char device major=%d\n", __FUNCTION__, VUART_MAJOR);
 	return 0;
 }
 
 static void vuart_cleanup (void)
 {
-	printk("cleaning up module\n");
 	unregister_chrdev (VUART_MAJOR, VUART_NAME);
 }
 
diff --git a/include/xen/interface/domctl.h b/include/xen/interface/domctl.h
index 5f68f43..9ffe897 100644
--- a/include/xen/interface/domctl.h
+++ b/include/xen/interface/domctl.h
@@ -5,6 +5,7 @@
 #include <xen/interface/grant_table.h>
 
 #define XEN_DOMCTL_INTERFACE_VERSION 0x00000006
+#define uint64_aligned_t uint64_t
 
 struct xen_domctl_vcpucontext {
     uint32_t vcpu;                  /* IN */
@@ -13,13 +14,23 @@ struct xen_domctl_vcpucontext {
 typedef struct xen_domctl_vcpucontext xen_domctl_vcpucontext_t;
 DEFINE_GUEST_HANDLE(xen_domctl_vcpucontext_t);
 
+/* XEN_DOMCTL_max_mem */
+struct xen_domctl_max_mem {
+   /* IN variables. */
+   uint64_aligned_t max_memkb;
+};
+typedef struct xen_domctl_max_mem xen_domctl_max_mem_t;
+DEFINE_GUEST_HANDLE(xen_domctl_max_mem_t);
+
 struct xen_domctl {
     uint32_t cmd;
 #define XEN_DOMCTL_destroydomain        1
 #define XEN_DOMCTL_bootvcpu             2
+#define XEN_DOMCTL_max_mem              11
     uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
     domid_t domain;
     union {
+        struct xen_domctl_max_mem     max_mem;
         struct xen_domctl_vcpucontext vcpucontext;
         uint8_t pad[128];
     } u;
diff --git a/include/xen/interface/grant_table.h b/include/xen/interface/grant_table.h
index a17d844..445f1b6 100644
--- a/include/xen/interface/grant_table.h
+++ b/include/xen/interface/grant_table.h
@@ -479,6 +479,41 @@ struct gnttab_get_version {
 DEFINE_GUEST_HANDLE_STRUCT(gnttab_get_version);
 
 /*
+ * GNTTABOP_update_services: Update the database of services. It will add an entry
+ * into local database for service_id.
+ */
+#define GNTTABOP_update_service           8
+struct gnttab_update_service {
+       /* IN parameters. */
+       uint32_t dom_id;
+       uint32_t shared_page_for_dom_id;
+       uint32_t start_ref_id;
+       uint32_t nr_pages;
+       uint32_t service_id;
+       uint64_t pfn;
+       /* OUT parameters. */
+       int16_t  status;
+};
+DEFINE_GUEST_HANDLE_STRUCT(gnttab_update_service_t);
+
+/*
+ * GNTTABOP_query_service: Query the database of services for a particular service id.
+ */
+#define GNTTABOP_query_service            9
+struct gnttab_query_service {
+       /* IN parametes. */
+       uint32_t dom_id;
+       uint32_t service_id;
+       uint32_t shared_page_by_dom_id;
+       /* OUT parameters. */
+       uint32_t start_ref_id;
+       uint32_t nr_pages;
+       uint64_t pfn;
+       int16_t  status;
+};
+DEFINE_GUEST_HANDLE_STRUCT(gnttab_query_service_t);
+
+/*
  * Bitfield values for update_pin_status.flags.
  */
  /* Map the grant entry for access by I/O devices. */
diff --git a/mm/memory.c b/mm/memory.c
index 0ddf3d8..3b15794 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3659,7 +3659,7 @@ static void print_pte_range(pte_t *pte, int pgd_index, int pmd_index)
 	{
 		if (pte_none(*pte))
 			continue;
-		printk("\t\tpte[%d] = %lx, vpage = %lx\n", i, pte_val(*pte), 
+		printk("\t\tpte[%d] = %llx, vpage = %lx\n", i, pte_val(*pte), 
 			  	((unsigned long)pgd_index << PGDIR_SHIFT)
 				| ((unsigned long)pmd_index << PAGE_SHIFT));
 	}
-- 
1.7.0.4

