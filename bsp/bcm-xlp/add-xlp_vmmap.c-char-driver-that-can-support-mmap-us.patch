From 84b6c989a4aa0f44ad36427018432c486622f118 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 11 Aug 2010 20:54:20 -0700
Subject: [PATCH 131/761] add xlp_vmmap.c char driver that can support mmap
 user space function

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/char/xlp_vmmap.c |  288 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 288 insertions(+)
 create mode 100644 drivers/char/xlp_vmmap.c

diff --git a/drivers/char/xlp_vmmap.c b/drivers/char/xlp_vmmap.c
new file mode 100644
index 0000000..38ba17e
--- /dev/null
+++ b/drivers/char/xlp_vmmap.c
@@ -0,0 +1,288 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ( Netlogic ). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/slab.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/wrapper.h>
+#endif
+
+#define VMMAP_MAJOR 251
+#define VMMAP_NAME "vmmap"
+#define CASE1 1
+#define CASE2 2
+
+static unsigned int counter = 0;
+static char string [128];
+static int data;
+
+//#define USEASCII
+
+#ifdef USEASCII
+static char *kmalloc_area = NULL;
+static char *kmalloc_ptr = NULL;
+#else
+static unsigned int *kmalloc_area = NULL;
+static unsigned int *kmalloc_ptr = NULL;
+#endif
+
+#define LEN (512*1024)
+unsigned long virt_addr;
+
+DECLARE_WAIT_QUEUE_HEAD(vmmap_wait);
+static int data_not_ready = 0;
+
+// open function - called when the "file" /dev/vmmap is opened in userspace
+static int vmmap_open (struct inode *inode, struct file *file) {
+	// we could do some checking on the flags supplied by "open"
+	// i.e. O_NONBLOCK
+	// -> set some flag to disable interruptible_sleep_on in vmmap_read
+	return 0;
+}
+
+// close function - called when the "file" /dev/vmmap is closed in userspace  
+static int vmmap_release (struct inode *inode, struct file *file) {
+	return 0;
+}
+
+// read function called when from /dev/vmmap is read
+static ssize_t vmmap_read (struct file *file, char *buf,
+		size_t count, loff_t *ppos) {
+	int len, err;
+	
+	// check if we have data - if not, sleep
+	// wake up in interrupt_handler
+	while (data_not_ready) {
+		interruptible_sleep_on(&vmmap_wait);
+	}
+	//data_not_ready = 1;
+	
+	if( counter <= 0 ) 
+		return 0;
+	err = copy_to_user(buf,string,counter);
+	if (err != 0)
+		return -EFAULT;
+	len  = counter;
+	counter = 0;
+	return len;
+}
+
+// write function called when to /dev/vmmap is written
+static ssize_t vmmap_write (struct file *file, const char *buf,
+		size_t count, loff_t *ppos) {
+	int err;
+	err = copy_from_user(string,buf,count);
+	if (err != 0)
+		return -EFAULT;
+	counter += count;
+	return count;
+}
+
+// ioctl - I/O control
+static int vmmap_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg) {
+	int retval = 0;
+	switch ( cmd ) {
+		case CASE1:/* for writing data to arg */
+			if (copy_from_user(&data, (int *)arg, sizeof(int)))
+			return -EFAULT;
+			break;
+		case CASE2:/* for reading data from arg */
+			if (copy_to_user((int *)arg, &data, sizeof(int)))
+			return -EFAULT;
+			break;
+		default:
+			retval = -EINVAL;
+	}
+	return retval;
+}
+
+#ifndef VMALLOC_VMADDR
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+#endif
+
+volatile void *virt_to_kseg(volatile void *address) {
+	pgd_t *pgd; pmd_t *pmd; pte_t *ptep, pte;
+	unsigned long va, ret = 0UL;
+	va=VMALLOC_VMADDR((unsigned long)address);
+	/* get the page directory. Use the kernel memory map. */
+	pgd = pgd_offset_k(va);
+	/* check whether we found an entry */
+	if (!pgd_none(*pgd)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		/* get the page middle directory */
+		pmd = pmd_offset(pgd, va);
+#else
+		// I'm not sure if we need this, or the line for 2.4
+		//    above will work reliably too
+		// If you know, please email me :-)
+		pud_t *pud = pud_offset(pgd, va);		
+		pmd = pmd_offset(pud, va);
+#endif
+		/* check whether we found an entry */
+		if (!pmd_none(*pmd)) {
+			/* get a pointer to the page table entry */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			ptep = pte_offset(pmd, va);
+#else
+			ptep = pte_offset_map(pmd, va);
+#endif
+			pte = *ptep;
+			/* check for a valid page */
+			if (pte_present(pte)) {
+				/* get the address the page is refering to */
+				ret = (unsigned long)page_address(pte_page(pte));
+				/* add the offset within the page to the page address */
+				ret |= (va & (PAGE_SIZE -1));
+			}
+		}
+	}
+	return((volatile void *)ret);
+}
+
+static int vmmap_mmap(struct file * filp, struct vm_area_struct * vma) {
+	int ret;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ret = remap_page_range(vma->vm_start,
+			virt_to_phys((void*)((unsigned long)kmalloc_area)),
+			vma->vm_end-vma->vm_start,
+			PAGE_SHARED);
+//			       vma->vm_page_prot);
+#else
+        ret = remap_pfn_range(vma,
+               vma->vm_start,
+               virt_to_phys((void*)((unsigned long)kmalloc_area)) >> PAGE_SHIFT,
+               vma->vm_end-vma->vm_start,
+               PAGE_SHARED);
+//               vma->vm_page_prot); 
+#endif
+	if(ret != 0) {
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+// define which file operations are supported
+struct file_operations vmmap_fops = {
+	.owner	=	THIS_MODULE,
+	.llseek	=	NULL,
+	.read		=	vmmap_read,
+	.write	=	vmmap_write,
+	.readdir	=	NULL,
+	.poll		=	NULL,
+	.ioctl	=	vmmap_ioctl,
+	.mmap		=	vmmap_mmap,
+	.open		=	vmmap_open,
+	.flush	=	NULL,
+	.release	=	vmmap_release,
+	.fsync	=	NULL,
+	.fasync	=	NULL,
+	.lock		=	NULL,
+};
+
+// initialize module
+static int __init vmmap_init_module (void) {
+	int i, ret;
+#ifndef USEASCII
+	int tmp, tmp2;
+#endif
+	ret = register_chrdev (VMMAP_MAJOR, VMMAP_NAME, &vmmap_fops);
+	if (ret != 0) 
+		return - EIO;
+	
+	// reserve memory with kmalloc - Allocating Memory in the Kernel
+	kmalloc_ptr = kmalloc(LEN + 2 * PAGE_SIZE, GFP_KERNEL);
+	if (!kmalloc_ptr) {
+		printk("kmalloc failed\n");
+		return 0;
+	}
+#ifdef USEASCII
+	kmalloc_area = (char *)(((unsigned long)kmalloc_ptr + PAGE_SIZE -1) & PAGE_MASK);
+#else
+	kmalloc_area = (unsigned int *)(((unsigned long)kmalloc_ptr + PAGE_SIZE -1) & PAGE_MASK);
+#endif
+	for (virt_addr=(unsigned long)kmalloc_area; virt_addr < (unsigned long)kmalloc_area + LEN;
+		virt_addr+=PAGE_SIZE) {
+			// reserve all pages to make them remapable
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			mem_map_reserve(virt_to_page(virt_addr));
+#else
+			SetPageReserved(virt_to_page(virt_addr));
+#endif
+	}
+	printk("kmalloc_area at 0x%p (phys 0x%lx)\n", kmalloc_area,
+		virt_to_phys((void *)virt_to_kseg(kmalloc_area)));
+
+#ifdef USEASCII
+	// fill allocated memory with 0123456789 ascii
+	for( i = 48; i < 58; i++) {
+		kmalloc_ptr[i-48] = (char)i;
+	}
+	i = 0;
+	kmalloc_ptr[58-48] = (char)i;
+#else
+	// fill allocated memory with integers
+	tmp = sizeof(int);
+	for( i = 0; i < (10 * tmp); i = i + tmp) {
+		kmalloc_ptr[i] = (unsigned int)i;
+      
+		tmp2 = (unsigned int)kmalloc_ptr[i];
+		printk("kmalloc_ptr[%d]=%d\n", i, tmp2);
+	}
+#endif
+
+	return 0;
+}
+
+// close and cleanup module
+static void __exit vmmap_cleanup_module (void) {
+	printk("cleaning up module\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+	for (virt_addr=(unsigned long)kmalloc_area; virt_addr < (unsigned long)kmalloc_area + LEN;
+		virt_addr+=PAGE_SIZE) {
+			// clear all pages
+			ClearPageReserved(virt_to_page(virt_addr));
+	}
+#endif
+	kfree(kmalloc_ptr);
+	unregister_chrdev (VMMAP_MAJOR, VMMAP_NAME);
+}
+
+module_init(vmmap_init_module);
+module_exit(vmmap_cleanup_module);
+MODULE_AUTHOR("netlogic");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Virtual TTY driver with MMAP");
-- 
1.7.10.4

