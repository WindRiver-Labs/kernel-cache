From f20576ba2af199ec1287302305db4af097fd28dd Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Wed, 8 Apr 2015 12:51:23 -0400
Subject: kvm: add clocksource based on TSC for guest kernel

 o KVM will sync TSC counters across all cores
 o OS will check whether it is running on guest mode. If it is, it will
   use TSC clock sou otherwise, it will use default PIC clock source.
 o With this change, the guest OS becomes a para-virtualized kernel.

[Moved it to a different file, cleaned up code - jchandra@broadcom.com]
Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/netlogic/mips-extns.h b/arch/mips/include/asm/netlogic/mips-extns.h
index a216637..ab0c082 100644
--- a/arch/mips/include/asm/netlogic/mips-extns.h
+++ b/arch/mips/include/asm/netlogic/mips-extns.h
@@ -139,6 +139,38 @@ static inline uint64_t read_c0_eirr_and_eimr(void)
 	return val;
 }
 
+static inline uint64_t nlm_read_tsc(void)
+{
+	uint64_t __res;
+
+	__asm__ __volatile__(
+		".set\tpush\n\t"
+		".set\tnoreorder\n\t"
+		"dmfur $12, $18\n\t"
+		"move %0, $12\n\t"
+		".set\tpop"
+		: "=r" (__res)
+		:
+		: "$12");
+
+		return __res;
+}
+
+static inline void nlm_write_tsc(uint64_t val)
+{
+	__asm__ __volatile__(
+		".set\tpush\n\t"
+		".set\tnoreorder\n\t"
+		"move $12, %0\n\t"
+		"dmtur $12, $18\n\t"
+		".set\tpop"
+		:
+		: "r" (val)
+		: "$12");
+
+	return;
+}
+
 static inline int hard_smp_processor_id(void)
 {
 	return __read_32bit_c0_register($15, 1) & 0x3ff;
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 60f7a2f..fedcc3a 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -114,6 +114,10 @@ void *xlp_dt_init(void *fdtp);
 int xlp_dt_get_cpumask(cpumask_t *mask);
 unsigned int nlm_get_core_frequency(int node, int core);
 
+/* tsc for XLP9xx */
+void nlm_init_tsc_timer(void);
+void nlm_sync_tsc_ipi(void *args);
+
 /* XLP CPU types */
 static inline int cpu_is_xlpii(void)
 {
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index e890fc2..a625f5f 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -223,6 +223,9 @@ void nlm_smp_finish(void)
 
 void nlm_cpus_done(void)
 {
+#ifdef CONFIG_KVM_NETL
+	on_each_cpu(nlm_sync_tsc_ipi, (void *)NULL, 0);
+#endif
 }
 
 /*
diff --git a/arch/mips/netlogic/common/time.c b/arch/mips/netlogic/common/time.c
index cf6c25c..172040b 100644
--- a/arch/mips/netlogic/common/time.c
+++ b/arch/mips/netlogic/common/time.c
@@ -98,9 +98,17 @@ static void nlm_init_pic_timer(void)
 	pr_info("PIC clock source added, frequency %d\n", picfreq);
 }
 
+#ifndef CONFIG_CPU_XLP
+const int is_nlm_guest_os = 0;
+static inline void nlm_init_tsc_timer(void) {}
+#endif
+
 void __init plat_time_init(void)
 {
-	nlm_init_pic_timer();
+	if (is_nlm_guest_os)
+		nlm_init_tsc_timer();
+	else
+		nlm_init_pic_timer();
 	mips_hpt_frequency = nlm_get_cpu_frequency();
 	if (current_cpu_type() == CPU_XLR)
 		preset_lpj = mips_hpt_frequency / (3 * HZ);
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index d8f8656..0aa06c5 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -16,4 +16,5 @@ obj-$(CONFIG_NLM_ENABLE_COP2)	+= cop2.o
 obj-$(CONFIG_KGDB)		+= nmi.o
 
 obj-y				+= pci-hot-reset.o
+obj-y				+= csrc-tsc.o
 obj-$(CONFIG_SMSC911X)		+= smsc-init.o
diff --git a/arch/mips/netlogic/xlp/csrc-tsc.c b/arch/mips/netlogic/xlp/csrc-tsc.c
new file mode 100644
index 0000000..27a928b
--- /dev/null
+++ b/arch/mips/netlogic/xlp/csrc-tsc.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+ * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+
+#include <asm/time.h>
+#include <asm/cpu-features.h>
+
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/mips-extns.h>
+
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+
+static uint32_t tsc_timer_freq(void)
+{
+	return 133333333;
+}
+
+static cycle_t nlm_get_tsc_timer(struct clocksource *cs)
+{
+	return nlm_read_tsc();
+}
+
+static struct clocksource csrc_tsc = {
+	.name	= "TSC",
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+	.mask	= CLOCKSOURCE_MASK(64),
+	.read	= nlm_get_tsc_timer,
+	.rating = 1000,
+};
+
+void nlm_init_tsc_timer(void)
+{
+	clocksource_register_hz(&csrc_tsc, tsc_timer_freq());
+}
+
+#ifdef CONFIG_KVM
+
+static atomic_t count_count_start = ATOMIC_INIT(0);
+static atomic_t count_count_stop = ATOMIC_INIT(0);
+static atomic_t tsc_count_start_flag = ATOMIC_INIT(0);
+static atomic64_t tsc_count_reference = ATOMIC_INIT(0);
+
+#define NR_LOOPS 5
+
+/* sync TSC at all cores */
+void nlm_sync_tsc_ipi(void *args)
+{
+	int i;
+	unsigned long flags;
+	uint64_t tsc_initcount;
+
+	(void)args;
+
+	if (smp_processor_id() == 0) {
+		int nslaves;
+
+		printk(KERN_INFO "Synchronize TSC counters across %u CPUs: ",
+			num_online_cpus());
+
+		/* we are the master. */
+		local_irq_save(flags);
+
+		/*
+		 * Notify the other cpus to start.
+		 */
+		atomic_set(&tsc_count_reference, nlm_read_tsc());
+		atomic_set(&tsc_count_start_flag, 1);
+		smp_wmb();
+
+		tsc_initcount = nlm_read_tsc();
+		nslaves = num_online_cpus()-1;
+		for (i = 0; i < NR_LOOPS; i++) {
+			/* slaves loop on '!= ncpus' */
+			while (atomic_read(&count_count_start) != nslaves)
+				mb();
+			atomic_set(&count_count_stop, 0);
+			smp_wmb();
+
+			/* this lets the slaves write their count register */
+			atomic_inc(&count_count_start);
+
+			/*
+			 * Everyone initialises count in the last loop:
+			 */
+			if (i == NR_LOOPS-1) {
+				nlm_write_tsc(tsc_initcount);
+			}
+
+			/*
+			 * Wait for all slaves to leave the synchronization point:
+			 */
+			while (atomic_read(&count_count_stop) != nslaves)
+				mb();
+			atomic_set(&count_count_start, 0);
+			smp_wmb();
+			atomic_inc(&count_count_stop);
+		}
+		local_irq_restore(flags);
+
+		printk("done.\n");
+	} else {
+		int ncpus;
+
+		local_irq_save(flags);
+		while (!atomic_read(&tsc_count_start_flag))
+			mb();
+
+		tsc_initcount = atomic64_read(&tsc_count_reference);
+		ncpus = num_online_cpus();
+		for (i = 0; i < NR_LOOPS; i++) {
+			atomic_inc(&count_count_start);
+			while (atomic_read(&count_count_start) != ncpus)
+				mb();
+
+			/*
+			 * Everyone initialises count in the last loop:
+			 */
+			if (i == NR_LOOPS-1) {
+				if ((hard_smp_processor_id() & 0x3) == 0)
+					nlm_write_tsc(tsc_initcount);
+			}
+
+			atomic_inc(&count_count_stop);
+			while (atomic_read(&count_count_stop) != ncpus)
+				mb();
+		}
+
+		local_irq_restore(flags);
+	}
+}
+#endif
-- 
1.7.1

