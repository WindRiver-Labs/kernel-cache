From 9301a181becdcb5594d6c39c87884095db88796f Mon Sep 17 00:00:00 2001
From: Ashok Kumar <ashoks@broadcom.com>
Date: Wed, 8 Apr 2015 13:00:10 -0400
Subject: kvm: fuse block emulation added

Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host_netl.h b/arch/mips/include/asm/kvm_host_netl.h
index cd019ea..3fe5d0a 100644
--- a/arch/mips/include/asm/kvm_host_netl.h
+++ b/arch/mips/include/asm/kvm_host_netl.h
@@ -92,6 +92,9 @@ struct kvm_arch {
 		unsigned int reg_cpupllctrl[20*4];
 		unsigned int reg_cpupllchgctrl;
 	} clkmgt;
+ 	struct {
+		uint32_t cfg[15];
+	} fuse;
 	struct {
 		int32_t config[16]; /* 16 standard configuration register */
 		int32_t pcie_busnum[4];
diff --git a/arch/mips/kvm-netl/xlp.c b/arch/mips/kvm-netl/xlp.c
index fe3fe6c..0037adf 100644
--- a/arch/mips/kvm-netl/xlp.c
+++ b/arch/mips/kvm-netl/xlp.c
@@ -360,6 +360,16 @@ static void xlp_kvm_init_clkmgt(struct kvm_arch *arch)
 	arch->clkmgt.reg_cpupllchgctrl = nlm_read_sys_reg(clkbase, 0x188);
 }
 
+static void xlp_kvm_init_fuse(struct kvm_arch *arch)
+{
+	uint64_t fusebase;
+	int ii = 0;
+	fusebase = nlm_get_node(0)->sysbase + (0x1 << 12);
+
+	for (ii = 0;ii < sizeof(arch->fuse.cfg)/4;ii++)
+		arch->fuse.cfg[ii] = nlm_read_sys_reg(fusebase, 0xc0+ii);
+}
+
 
 static void xlp_kvm_init_bridge(struct kvm_arch *arch)
 {
@@ -397,6 +407,7 @@ void xlp_kvm_init_vm(struct kvm *kvm)
 	xlp_kvm_init_pic(arch);
 	xlp_kvm_init_sysmgt(arch);
 	xlp_kvm_init_clkmgt(arch);
+	xlp_kvm_init_fuse(arch);
 	xlp_kvm_init_bridge(arch);
 }
 
diff --git a/arch/mips/netlogic/kvm-netl/kvm_fuse.c b/arch/mips/netlogic/kvm-netl/kvm_fuse.c
index 30a150b..f123f64 100644
--- a/arch/mips/netlogic/kvm-netl/kvm_fuse.c
+++ b/arch/mips/netlogic/kvm-netl/kvm_fuse.c
@@ -66,6 +66,7 @@ static inline void unhandled_exception(const char *func, unsigned long addr,
 void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
 		unsigned long address, unsigned long reg_num)
 {
+	struct kvm_arch *arch = kvm_get_arch(regs);
 	unsigned int rindex = address >> 2;
 
 	if (rindex == 0x106) {
@@ -75,6 +76,13 @@ void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
 			return;
 		}
 	}
+	else if (rindex >= 0x100 &&
+			 rindex <= 0x10e) {
+		if (!write) {
+			regs->regs[reg_num] = arch->fuse.cfg[rindex - 0x100];
+			return;
+		}
+	}
 
 	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
 }
-- 
1.7.1

