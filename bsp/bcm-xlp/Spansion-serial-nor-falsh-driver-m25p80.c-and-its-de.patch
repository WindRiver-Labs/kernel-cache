From 816cd67ea8fed43e83bd263cb9cf37703115c50c Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 18 May 2011 10:22:25 -0700
Subject: [PATCH 288/761] Spansion serial nor falsh driver m25p80.c and its
 dependent spi_xlp driver and related files.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/board.c  |   12 +-
 drivers/mtd/devices/Kconfig     |    7 +
 drivers/mtd/devices/Makefile    |    3 +-
 drivers/mtd/devices/m25p80.c    |   69 ++--
 drivers/mtd/devices/mt29f_spi.c |  779 +++++++++++++++++++++++++++++++++++++++
 drivers/spi/spi_xlp.c           |  179 ++++-----
 6 files changed, 901 insertions(+), 148 deletions(-)
 create mode 100644 drivers/mtd/devices/mt29f_spi.c

diff --git a/arch/mips/netlogic/xlp/board.c b/arch/mips/netlogic/xlp/board.c
index 7498075..8fc1610 100644
--- a/arch/mips/netlogic/xlp/board.c
+++ b/arch/mips/netlogic/xlp/board.c
@@ -29,13 +29,9 @@
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
 
-
 static struct i2c_board_info xlp_i2c_device_info[] __initdata = {
         {"ds1374",          0, 0x68, 0, 0, 0},
-        {"max6657",             0, 0x4c, 0, 0, 0},
-       /* {"at24c02",           0, 0x57, 0, 0, 0},
-        {"trx10gdp0310",      0, 0x70, 0, 0, 0},
-	*/
+        {"max6657",         0, 0x4c, 0, 0, 0},
 };
 
 static int __init xlp_i2c_device_init(void)
@@ -52,6 +48,12 @@ static struct spi_board_info spsn_spi_board_info[] __initdata = {
 		.bus_num = 0,
 		.chip_select = 1
 	},
+	{
+		.modalias = "mt29f",
+		.max_speed_hz = 50000000,
+		.bus_num = 0,
+		.chip_select = 2
+	},
 };
 
 static int __init xlp_spi_device_init(void)
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 4cdb2af..ec68073 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -120,6 +120,13 @@ config MTD_SST25L
 	  Set up your spi devices with the right board-specific platform data,
 	  if you want to specify device partitioning.
 
+config MTD_MT29F
+	tristate "Support Micron MT29F SPI Nand chips"
+	depends on SPI_MASTER
+	help
+	  This enables access to Micron MT29F family SPI flash chips, used
+	  for program and data storage.
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	help
diff --git a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
index a4dd1d8..bcf1950 100644
--- a/drivers/mtd/devices/Makefile
+++ b/drivers/mtd/devices/Makefile
@@ -17,7 +17,8 @@ obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_MT29F)		+= mt29f_spi.o
 obj-$(CONFIG_MTD_SPEAR_SMI)	+= spear_smi.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
 
-CFLAGS_docg3.o			+= -I$(src)
\ No newline at end of file
+CFLAGS_docg3.o			+= -I$(src)
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index b44b464..827c447 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -473,15 +473,9 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 			write_enable(flash);
 
-#ifdef CONFIG_NLM_XLP
-			spi_write(flash->spi, flash->command, CMD_SIZE);
-#endif
 			spi_sync(flash->spi, &m);
 
 			*retlen += m.actual_length - m25p_cmdsz(flash);
-#ifdef CONFIG_NLM_XLP
-			write_disable(flash);
-#endif
 		}
 	}
 
@@ -803,49 +797,58 @@ static struct mtd_partition xlp_spi_parti[] = {
 };
 static void m25p_test(struct m25p * flash)
 {
-	int i, xfer_len;
+	int i, j, xfer_len;
 	unsigned char buf[4096];
 	size_t retlen;
 	memset(buf, 0, 4096);
 	retlen 		= 0;
-	xfer_len 	= 2048;
+	xfer_len 	= 370;
 
-	printk("\n######################### erase_sector\n");
-	erase_sector(flash, 0);
+	j = flash->mtd.size / flash->mtd.erasesize;
+        for( i = 0; i < 5; i++)
+        {
 
+		printk("\n######################### erase_sector\n");
+		erase_sector(flash, 0);
+	}
 	printk("\n######################### read\n");
 	printk("\nFlash read back %d\n",xfer_len);
-	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
-	for( i = 0; i < xfer_len; i++)
-        {
-                printk("%02x",buf[i]);
-                if((i % 16) == 0xf)
-                        printk("\n");
-        }
 
-	/* fill buf with number */
-	for(i = 0; i < xfer_len; i++){
-		buf[i] = i % 0x100;
+        for(j = 0; j < 1; j++)
+        {
+		m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+		for( i = 0; i < xfer_len; i++) {
+			printk("%02x",buf[i]);
+			if((i % 16) == 0xf)
+				printk("\n");
+		}
 	}
-	retlen = xfer_len;
 
-	printk("\n######################### write\n");
-	printk("\nFlash write %d test\n",xfer_len);
+	/* fill buf with number */
+        for(j = 0; j < 5; j++)
+        {
+		for(i = 0; i < xfer_len; i++){
+			buf[i] = i % 0x100;
+		}
+		retlen = xfer_len;
 
-	m25p80_write(&flash->mtd, 0, xfer_len, &retlen, buf);
+		printk("\n######################### write\n");
+		printk("\nFlash write %d test\n",xfer_len);
 
+		m25p80_write(&flash->mtd, 0, xfer_len, &retlen, buf);
+	}
 	printk("\n######################### read\n");
 
-	xfer_len +=32;
-
-	printk("\n\nFlash read back %d\n",xfer_len);
-	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
-	for( i = 0; i < xfer_len; i++)
+       for(j = 0; j < 5; j++)
         {
-                printk("%02x",buf[i]);
-               if((i % 16) == 0xf)
-                        printk("\n");
-        }
+		printk("\n\nFlash read back %d\n",xfer_len);
+		m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+		for( i = 0; i < xfer_len; i++) {
+			printk("%02x",buf[i]);
+			if((i % 16) == 0xf)
+			printk("\n");
+		}
+	}
 }
 #endif
 
diff --git a/drivers/mtd/devices/mt29f_spi.c b/drivers/mtd/devices/mt29f_spi.c
new file mode 100644
index 0000000..aa5a9ff
--- /dev/null
+++ b/drivers/mtd/devices/mt29f_spi.c
@@ -0,0 +1,779 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (â€œNetlogicâ€?. All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+
+#define SPI_NAND_MT29F_BLOCK_ERASE	0xD8    /* Block Erase */
+#define SPI_NAND_MT29F_GET_FEATURE	0x0F    /* Get Feature */
+#define SPI_NAND_MT29F_PAGE_READ	0x13    /* Array Read */
+#define SPI_NAND_MT29F_PROG_EXE		0x10    /* Page Execute */
+#define SPI_NAND_MT29F_PROG_LOAD	0x02    /* Program Load*/
+#define SPI_NAND_MT29F_PROG_RAND_LOAD	0x84    /* Program load random data */
+#define SPI_NAND_MT29F_RD_ARRAY		0x0B    /* Read from cache Data Bytes */
+#define SPI_NAND_MT29F_RD_CACHE		0x03	/* Read From Cache*/
+#define SPI_NAND_MT29F_READID		0x9F	/* Read ID */
+#define SPI_NAND_MT29F_RESET       	0xFF    /* Reset */
+#define SPI_NAND_MT29F_SET_FEATURE	0x1F    /* Get Feature */
+
+#define SPI_NAND_MT29F_WREN        	0x06    /* Write Enable */
+#define SPI_NAND_MT29F_WRDI        	0x04    /* Write Disable */
+#define SPI_NAND_MT29F_BLOCK_LOCK	0xA0
+
+#define SPI_NAND_MT29F_OTP      	0xB0
+#define SPI_NAND_MT29F_OTP_EN      	0x40
+#define SPI_NAND_MT29F_OTP_PROT      	0x80
+#define SPI_NAND_MT29F_OTP_ECC      	0x10
+
+#define SPI_NAND_MT29F_STATUS      	0xC0
+#define SPI_NAND_MT29F_OIP      	0x01
+#define SPI_NAND_MT29F_WEL      	0x02
+#define SPI_NAND_MT29F_ST_EFAIL      	0x04
+#define SPI_NAND_MT29F_ST_PFAIL      	0x08
+#define SPI_NAND_MT29F_ST_ECC_S0      	0x10
+#define SPI_NAND_MT29F_ST_ECC_S1      	0x20
+
+#define MT29F_REG_BLOCK_LOCK		0xA0
+#define MT29F_REG_OTP			0xB0
+#define MT29F_REG_STATUS		0xC0
+
+#define MICRON_ID_MT29F1G01ZAC		0x12
+#define MICRON_SR_WIP         		(1 << 0)  /* Write-in-Progress */
+#define SPINAND_TIMEOUT			0x7fffffff
+
+#define ROW_SHIFT			12
+#define COL_MASK			0x0F
+/* Define max times to check status register before we give up. */
+#define	MAX_WAIT_TIME			40000
+
+struct mt29f_snand_params {
+        uint8_t      idcode1;
+        uint16_t page_size;
+        uint16_t pages_per_block;
+        uint16_t nr_blocks;
+        const char *name;
+};
+
+static const struct mt29f_snand_params mt29f_snand_table[] = {
+        {
+                .idcode1                 = MICRON_ID_MT29F1G01ZAC,
+                .page_size               = 2048,
+                .pages_per_block	 = 64,
+                .nr_blocks               = 1024,
+                .name                    = "MT29F1G01ZAC",
+        },
+};
+/****************************************************************************/
+
+struct mt29f {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct mtd_info		mtd;
+	unsigned		partitioned:1;
+	uint8_t			erase_opcode;
+	uint8_t			command[4];
+	struct mt29f_snand_params  params;
+};
+
+static struct mtd_partition xlp_mt29f_part[] = {
+        {
+                .name = "SPI NAND FLASH",
+                .offset = 0x00000000,
+                .size = MTDPART_SIZ_FULL,
+        }
+};
+
+static inline struct mt29f *mtd_to_mt29f(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct mt29f, mtd);
+}
+
+static int8_t get_feature(struct mt29f *snand, uint8_t reg)
+{
+	uint8_t cmd[4];
+	int8_t val, retval;
+
+	if(!snand)
+		return -1;
+
+	cmd[0] = SPI_NAND_MT29F_GET_FEATURE;
+	cmd[1] = reg;
+
+	retval = spi_write_then_read(snand->spi, cmd, 2, &val, 1);
+	if (retval < 0) {
+		printk("[%s] error %d reading status\n", __func__, (int)retval);
+		return retval;
+	}
+	return val;
+}
+
+static int set_feature(struct mt29f *snand, uint8_t reg, uint8_t val)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0] = SPI_NAND_MT29F_SET_FEATURE;
+	cmd[1] = reg;
+	cmd[2] = val;
+
+	return spi_write(snand->spi, cmd, 3);
+}
+
+static inline int write_enable(struct mt29f *snand)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0]= SPI_NAND_MT29F_WREN;
+	return spi_write(snand->spi, cmd, 1);
+}
+
+static inline int write_disable(struct mt29f *snand)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0]= SPI_NAND_MT29F_WRDI;
+	return spi_write(snand->spi, cmd, 1);
+}
+
+static void mt29f_blk_unlock(struct mt29f *snand, uint8_t lockbits)
+{
+	uint8_t val;
+
+	mutex_lock(&snand->lock);
+	val = get_feature(snand, MT29F_REG_BLOCK_LOCK);
+	val &= ~( 0x7 << 3);
+	val = val | lockbits;
+	set_feature(snand, MT29F_REG_BLOCK_LOCK, val);
+	mutex_unlock(&snand->lock);
+}
+
+static int wait_oip_clear(struct mt29f *snand, unsigned long t)
+{
+	int i, ret;
+
+        i = 0;
+        do {
+                ret = get_feature(snand, MT29F_REG_STATUS);
+                if( i++ == t) {
+                        printk("mt29f_page_read timeout\n");
+                        return ret;
+                }
+        } while((ret & SPI_NAND_MT29F_OIP) != 0x0);
+
+	return 0;
+
+}
+
+static int wait_write_latch(struct mt29f *snand, unsigned long t)
+{
+	int i, ret;
+
+	i = 0;
+	do {
+		ret = get_feature(snand, MT29F_REG_STATUS);
+		if( i++ == t) {
+			printk("mt29f_page_read timeout\n");
+			return ret;
+		}
+	} while((ret & SPI_NAND_MT29F_WEL) != 0x2);
+
+        return 0;
+
+}
+
+void mt29f_reset(struct mt29f *snand)
+{
+	int ret;
+	uint8_t cmd = SPI_NAND_MT29F_RESET;
+
+	mutex_lock(&snand->lock);
+	ret = spi_write_then_read(snand->spi, &cmd, 1, NULL, 0);
+	if (ret < 0) {
+		mutex_unlock(&snand->lock);
+		printk("SF: Reset failed\n");
+	}
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+            printk("MT29F: Timeout\n");
+		mutex_unlock(&snand->lock);
+            return;
+	}
+
+	mutex_unlock(&snand->lock);
+	return;
+}
+
+static uint16_t mt29f_read_id(struct mt29f *snand) 
+{
+	uint8_t cmd;
+	uint16_t read_id;
+	uint8_t id[5];
+	int ret;
+
+	mutex_lock(&snand->lock);
+	cmd = SPI_NAND_MT29F_READID;
+	ret = spi_write_then_read(snand->spi, &cmd, 1, id, 5);
+	if (ret < 0) {
+            printk("[%s]: read_id failed\n", __func__);
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+	read_id = id[1] << 8 |id[2];
+	mutex_unlock(&snand->lock);
+
+	return read_id;
+}
+
+
+static int mt29f_page_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, uint8_t* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint16_t col_addr = (uint16_t)(from & 0x7FF);
+	uint8_t cmd[4];
+	int ret;
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] READ from: row: 0x%x col: 0x%x len: %d \n", 
+		__func__,(unsigned int)(((from >> (ROW_SHIFT + 8)) << 8)|(from >> ROW_SHIFT)), 
+		(unsigned int)col_addr, (int)len);
+
+	if(!snand)
+		return -1;
+
+	if (!len)
+		return -1;
+
+	if (from + len > snand->mtd.size)
+		return -EINVAL;
+
+	mutex_lock(&snand->lock);
+
+	cmd[0] = SPI_NAND_MT29F_PAGE_READ;
+	cmd[1] = 0x0;
+	cmd[2] = (from >> (ROW_SHIFT + 8)) & 0xFF;
+	cmd[3] = (from >> ROW_SHIFT) & 0xFF;
+
+
+	ret = spi_write(snand->spi, cmd, 4);
+	if(ret < 0) {
+		printk("mt29f_page_read failed\n");
+		mutex_unlock(&snand->lock);
+		return ret;
+	}
+	
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] from 0x%x timeout. ret: 0x%x\n",  __func__, (unsigned int)from, ret);
+		*retlen = 0;
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+
+	cmd[0] = SPI_NAND_MT29F_RD_CACHE;
+	cmd[1] = (col_addr >> 8) & 0x0F;
+	cmd[2] = (col_addr & 0xFF);
+	cmd[3] = 0x0;   
+
+    	spi_write(snand->spi, cmd, 4);
+	ret = spi_read(snand->spi, buf, len);
+		
+	*retlen = len;
+	mutex_unlock(&snand->lock);
+
+	return ret;
+}
+
+static int mt29f_page_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t ret;
+	uint8_t cmd[4];
+	uint8_t prog_cmd[4];
+	uint16_t col_addr = (uint16_t) (to & 0x7FF);
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
+
+	if (!len) {
+		*retlen = 0;
+		return 0;
+	}
+
+        write_enable(snand);
+
+	prog_cmd[0] = SPI_NAND_MT29F_PROG_LOAD;
+	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
+	prog_cmd[2] = (col_addr & 0xFF);
+
+	ret = wait_write_latch(snand, MAX_WAIT_TIME);
+	if(ret) {
+		printk("[%s] write enable failed\n", __func__);
+		*retlen = 0;
+		return -1;	
+	}
+
+	spi_write(snand->spi, prog_cmd, 3);
+	spi_write(snand->spi, buf, len);
+
+	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
+	cmd[1] = 0x0;
+	cmd[2] = to >> (ROW_SHIFT + 8);
+	cmd[3] = to >> ROW_SHIFT;
+	
+	spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
+		*retlen = 0;
+		return -1;
+	}
+
+	*retlen = len;
+	return 0;
+}
+
+static int mt29f_random_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t ret;
+	uint8_t cmd[4];
+	uint8_t prog_cmd[4];
+	uint16_t col_addr = (uint16_t) (to & 0x7FF);
+
+	DEBUG(MTD_DEBUG_LEVEL2, "[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
+
+	if (!len) {
+		*retlen = 0;
+		return 0;
+	}
+
+        write_enable(snand);
+
+	prog_cmd[0] = SPI_NAND_MT29F_PROG_RAND_LOAD;
+	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
+	prog_cmd[2] = (col_addr & 0xFF);
+
+	ret = wait_write_latch(snand, MAX_WAIT_TIME);
+	if(ret) {
+		printk("[%s] write enable failed\n", __func__);
+		*retlen = 0;
+		return -1;	
+	}
+
+	spi_write(snand->spi, prog_cmd, 3);
+	spi_write(snand->spi, buf, len);
+
+	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
+	cmd[1] = 0x0;
+	cmd[2] = to >> (ROW_SHIFT + 8);
+	cmd[3] = to >> ROW_SHIFT;
+	
+	spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
+		*retlen = 0;
+		return -1;
+	}
+	*retlen = len;
+	return 0;
+}
+
+static int mt29f_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	int i;
+	uint16_t col_addr, page_size;
+	size_t ret;
+
+	if(!snand)
+		return -1;
+	*retlen = 0;
+	ret = 0;
+
+	page_size= snand->params.page_size;
+	col_addr = to % page_size;
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to:0x%x len:%d row:0x%x col_addr:0x%x\n", 
+			__func__, (unsigned int)to, (int)len, (unsigned int)(to >> ROW_SHIFT)&0xFFFF, col_addr);
+
+	mutex_lock(&snand->lock);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] snand is not ready!%x\n", __func__, (unsigned int)ret);
+		*retlen = 0;
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+
+	if(col_addr + len <= page_size) {
+		mt29f_page_program(mtd, to, len, retlen, buf);
+		/*mt29f_random_program(mtd, to, len, retlen, buf);*/
+	} else {
+	
+        	page_size = snand->params.page_size - col_addr;
+		mt29f_page_program(mtd, to, page_size, &ret, buf);
+		/*mt29f_random_program(mtd, to, page_size, &ret, buf);*/
+		*retlen = *retlen + ret;
+		for( i = page_size; i < len; i += page_size) {
+			page_size = len - i;
+			if(page_size > snand->params.page_size)
+				page_size = snand->params.page_size;
+			mt29f_page_program(mtd, to + i, page_size, &ret, buf + i);
+			/*mt29f_random_program(mtd, to + i, page_size, &ret, buf + i);*/
+			*retlen = *retlen + ret;
+		}
+	}	
+	mutex_unlock(&snand->lock);
+
+	return 0;
+}
+
+static int mt29f_erase_block(struct mtd_info *mtd, uint32_t addr)
+{
+        struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t cmd[4];
+	int ret;
+
+        DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+                        dev_name(&snand->spi->dev), __func__,
+                        snand->mtd.erasesize / 1024, addr);
+	if(!snand)
+		return 1;
+
+        /* Send write enable, then erase commands. */
+        write_enable(snand);
+
+        /* Wait until finished previous write command. */
+        if (wait_oip_clear(snand, MAX_WAIT_TIME))
+                return 1;
+
+        /* Set up command buffer. */
+        cmd[0] = SPI_NAND_MT29F_BLOCK_ERASE;
+        cmd[1] = 0;
+        cmd[2] = addr >> (ROW_SHIFT + 8);
+        cmd[3] = addr >> ROW_SHIFT;
+
+        spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] erase block 0x%x failed: ret: %x\n", __func__, addr, ret);
+		return -1;
+	}
+
+        return 0;
+}
+
+static int mt29f_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint32_t addr,len;
+	uint32_t rem;
+
+	if(!snand || !instr)
+		return -EINVAL;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
+	      dev_name(&snand->spi->dev), __func__, "at",
+	      (long long)instr->addr, (long long)instr->len);
+
+	if (instr->addr + instr->len > snand->mtd.size)
+		return -EINVAL;
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&snand->lock);
+
+	while (len) {
+		if (mt29f_erase_block(&snand->mtd, addr)) {
+			instr->state = MTD_ERASE_FAILED;
+			mutex_unlock(&snand->lock);
+			return -EIO;
+		}
+		addr += mtd->erasesize;
+		len -= mtd->erasesize;
+	}
+	
+	mutex_unlock(&snand->lock);
+
+        instr->state = MTD_ERASE_DONE;
+        mtd_erase_callback(instr);
+
+	return 0;
+}
+
+
+#if CONFIG_NLM_XLP
+unsigned char buf[4096];
+unsigned char wrbuf[4096];
+static void mt29f_test(struct mt29f * snand)
+{
+	int i, j, rw_err, offset, seg, xfer_len;
+	size_t retlen;
+	memset(buf, 0, 4096);
+	retlen 		= 0;
+	xfer_len 	= 370;
+
+	j = snand->mtd.size / snand->mtd.erasesize;
+	for( i = 0; i < j; i++)
+	{
+		mt29f_erase_block(&snand->mtd, i);
+		printk("\n######################### erase_block: %d\n", i);
+	}
+	printk("\n######################### read\n");
+	printk("\nFlash read back %d\n",xfer_len);
+
+	for(j = 0; j < 1; j++)
+	{
+		mt29f_page_read(&snand->mtd, j * 2048, xfer_len, &retlen, buf);
+		printk("\n **********************read :%d\n", (int)retlen);
+		for( i = 0; i < xfer_len; i++)
+        	{
+                	printk("%02x",buf[i]);
+                	if((i % 16) == 0xf)
+                        	printk("\n");
+        	}
+	}
+
+	rw_err = 0;
+	for(i = 0; i < 2048; i++){
+		wrbuf[i] = i % 0x100;
+	}
+	offset = 0;
+	seg = 2048;
+	/* write buf with number */
+	for(j = 0; j < 1; j++)
+	{
+		retlen = xfer_len;
+
+		printk("\n######################### write\n");
+		printk("\nFlash write %d to 0x%x\n",xfer_len, (j + offset)*seg);
+
+		mt29f_write(&snand->mtd, (j + offset)*seg, xfer_len, &retlen, wrbuf);
+
+		printk("\n######################### read\n");
+		printk("\n\nFlash read back %d\n",xfer_len);
+
+		mt29f_page_read(&snand->mtd, (j+offset) * seg, xfer_len, &retlen, buf);
+
+		printk("\nread from: 0x%x xfer_len:%d retlen: %d\n",
+			(j + offset) * seg,  xfer_len, (unsigned int)retlen);
+		for( i = 0; i < xfer_len; i++)
+        	{
+                	printk("%02x",buf[i]);
+               		if((i % 16) == 0xf)
+                        	printk("\n");
+        	}
+		if(memcmp(wrbuf, buf, xfer_len) != 0) {
+			rw_err++;
+		}
+	}
+	printk("\nread write: %d times for xfer_len: %d, rw_err: %d\n", j, xfer_len, rw_err);
+}
+#endif
+
+
+static int __devinit mt29f_probe(struct spi_device *spi)
+{
+	struct flash_platform_data *pdata;
+	struct mt29f_snand_params *params;
+	struct mt29f	*snand;
+	uint16_t snand_id;
+	int	i;
+
+	pdata = spi->dev.platform_data;
+	snand = kzalloc(sizeof(struct mt29f), GFP_KERNEL);
+	if (!snand)
+		return -ENOMEM;
+
+	
+	snand->spi = spi;
+	mutex_init(&snand->lock);
+	dev_set_drvdata(&spi->dev, snand);
+
+	snand_id = mt29f_read_id(snand);
+	printk("[%s] Micro vendorID:%x Chip ID:%x\n",
+		__func__, (0xff00 & snand_id) >> 8, (0xff & snand_id));
+
+        for (i = 0; i < ARRAY_SIZE(mt29f_snand_table); i++) {
+                params = (struct mt29f_snand_params *)&mt29f_snand_table[i];
+                if (params && params->idcode1 == (0xff & snand_id) ) {
+                                break;
+                }
+		params++;
+        }
+	
+	if (!params)
+		return -ENODEV;
+	
+	memcpy(&snand->params, params, sizeof(struct mt29f_snand_params));
+
+	snand->mtd.name = dev_name(&spi->dev);
+	printk("%s (%lld Kbytes) pagesize %u \n", params->name,
+			(long long)snand->mtd.size >> 10, params->page_size);
+
+	snand->mtd.type = MTD_NORFLASH;
+	snand->mtd.writesize = 1;
+	snand->mtd.flags = MTD_CAP_NORFLASH;
+	snand->mtd.size = (params->page_size * params->pages_per_block * params->nr_blocks); 
+	snand->mtd.erase = mt29f_erase;
+	snand->mtd.read  = mt29f_page_read;
+	snand->mtd.write = mt29f_write;
+
+	snand->erase_opcode = SPI_NAND_MT29F_BLOCK_ERASE;
+	snand->mtd.erasesize = params->page_size * params->pages_per_block;
+
+	snand->mtd.dev.parent = &spi->dev;
+
+	dev_info(&spi->dev, "%s (%lld Kbytes) pagesize %u \n", params->name,
+			(long long)snand->mtd.size >> 10, params->page_size);
+
+	DEBUG(MTD_DEBUG_LEVEL2,
+		"mtd .name = %s, .size = 0x%llx (%lldMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		snand->mtd.name,
+		(long long)snand->mtd.size, (long long)(snand->mtd.size >> 20),
+		snand->mtd.erasesize, snand->mtd.erasesize / 1024,
+		snand->mtd.numeraseregions);
+
+	if (snand->mtd.numeraseregions)
+		for (i = 0; i < snand->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL2,
+				"mtd.eraseregions[%d] = { .offset = 0x%llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (long long)snand->mtd.eraseregions[i].offset,
+				snand->mtd.eraseregions[i].erasesize,
+				snand->mtd.eraseregions[i].erasesize / 1024,
+				snand->mtd.eraseregions[i].numblocks);
+
+
+	if (mtd_has_partitions()) {
+		struct mtd_partition	*parts = NULL;
+		int			nr_parts = 0;
+
+		if (mtd_has_cmdlinepart()) {
+			static const char *part_probes[]
+					= { "cmdlinepart", NULL, };
+
+			nr_parts = parse_mtd_partitions(&snand->mtd,
+					part_probes, &parts, 0);
+		}
+
+                if((nr_parts == 0) && (pdata == 0)) {
+                        parts    = xlp_mt29f_part;
+                        nr_parts = ARRAY_SIZE(xlp_mt29f_part);
+                }
+
+		if (nr_parts > 0) {
+			for (i = 0; i < nr_parts; i++) {
+				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
+					"{.name = %s, .offset = 0x%llx, "
+						".size = 0x%llx (%lldKiB) }\n",
+					i, parts[i].name,
+					(long long)parts[i].offset,
+					(long long)parts[i].size,
+					(long long)(parts[i].size >> 10));
+			}
+			snand->partitioned = 1;
+			return add_mtd_partitions(&snand->mtd, parts, nr_parts);
+		}
+	} else if (pdata && pdata->nr_parts) {
+		dev_warn(&spi->dev, "ignoring %d default partitions on %s\n",
+				pdata->nr_parts, pdata->name);
+	}
+	return add_mtd_device(&snand->mtd) == 1 ? -ENODEV : 0;
+}
+
+
+static int __devexit mt29f_remove(struct spi_device *spi)
+{
+	struct mt29f	*snand = dev_get_drvdata(&spi->dev);
+	int		status;
+
+	if (mtd_has_partitions() && snand->partitioned)
+		status = del_mtd_partitions(&snand->mtd);
+	else
+		status = del_mtd_device(&snand->mtd);
+	if (status == 0)
+		kfree(snand);
+	return 0;
+}
+
+
+static struct spi_driver mt29f_driver = {
+	.driver = {
+		.name	= "mt29f",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= mt29f_probe,
+	.remove	= __devexit_p(mt29f_remove),
+
+};
+
+
+static int __init mt29f_init(void)
+{
+	return spi_register_driver(&mt29f_driver);
+}
+
+
+static void __exit mt29f_exit(void)
+{
+	spi_unregister_driver(&mt29f_driver);
+}
+
+
+module_init(mt29f_init);
+module_exit(mt29f_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netlogicmicro System Inc.");
+MODULE_DESCRIPTION("MTD SPI driver for Micron MT29f nand chips");
+MODULE_ALIAS("platform:mt29f-spi");
diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
index 39e80a3..e9db811 100644
--- a/drivers/spi/spi_xlp.c
+++ b/drivers/spi/spi_xlp.c
@@ -39,6 +39,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlp.h>
 
 #undef XLP_SPI_DEBUG
+
 #define CONFIG_SPI_REFCLK		133333334
 #define SPI_CHAN_OFFSET			0x10
 #define CMD_RDID			0x9f
@@ -47,8 +48,15 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define CMD_WRDI			0x04
 #define CMD_BE_4K			0x20
 #define CMD_BE_32K			0x52
-#define CMD_CHIP_ERASE		0xc7
-#define CMD_SE			0xd8
+#define CMD_CHIP_ERASE			0xc7
+#define CMD_SE				0xd8
+#define CMD_GET_FEATURE			0x0f
+#define CMD_SET_FEATURE			0x1f
+#define CMD_RESET			0xff
+#define CMD_PR				0x13
+#define CMD_PL				0x02
+#define CMD_PROGEXE			0x10
+
 #define DEFAULT_CS_FDIV			0x10
 #define XLP_SPI_MAX_XFER_SIZE		0x2000
 #define XLP_SPI_FIFO_SIZE		8
@@ -178,7 +186,6 @@ out:
 
 }
 
-
 static void spi_xlp_fill_txfifo(struct spi_xlp *pspi, uint32_t* len, unsigned char** data)
 {
         uint32_t txfifo_cnt;
@@ -222,8 +229,11 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 	if(opcode[0] == CMD_WREN 	||
 	   opcode[0] == CMD_BE_4K	||
 	   opcode[0] == CMD_BE_32K	||
-	   opcode[0] == CMD_CHIP_ERASE||
-	   opcode[0] == CMD_SE	||
+	   opcode[0] == CMD_CHIP_ERASE	||
+	   opcode[0] == CMD_SE		||
+	   opcode[0] == CMD_RESET	||
+	   opcode[0] == CMD_PROGEXE	||
+	   opcode[0] == CMD_SET_FEATURE	||
 	   opcode[0] == CMD_WRDI )
 		return 1;
 	else
@@ -233,39 +243,40 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, uint32_t xfer_len)
 {
 	uint32_t val;
-        uint32_t rx_data, tx_len, rx_len, rxfifo_cnt;
+	uint32_t rx_data, tx_len, rx_len, rxfifo_cnt, sent_bytes;
 	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+	unsigned char* rx_buf = NULL;
+	unsigned char* tx_buf = NULL;
 
-	pspi->tx_buf = (unsigned char*)t->tx_buf;
-	pspi->rx_buf = (unsigned char*)t->rx_buf;
-	pspi->rcounter = xfer_len;
+	tx_buf = (unsigned char*)t->tx_buf;
+	rx_buf = (unsigned char*)t->rx_buf;
 
-        if (xfer_len == 0)
+	if (!tx_buf && !rx_buf)
                 return -1;
 
-        tx_len = (pspi->tx_buf == NULL) ? 0 : xfer_len;
-        rx_len = (pspi->rx_buf == NULL) ? 0 : xfer_len;
+	tx_len = (tx_buf == NULL) ? 0 : xfer_len;
+	rx_len = (rx_buf == NULL) ? 0 : xfer_len;
+	sent_bytes = 0;
 
 	val = XLP_SPI_CMD_IDLE;
-        if (tx_len) {
-                spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
-		t->len = tx_len;
+	if (tx_len) {
+		spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+		sent_bytes = xfer_len - tx_len;
 		if(xfer_len <= NOR_SPI_CMD_SIZE){
 			val |= XLP_SPI_CMD_CONT;
 		}
-
 		if(spi_disable_cont_cmd((unsigned char*)t->tx_buf))
 		{
 			val &= ~XLP_SPI_CMD_CONT;
 		}
         }
 
-	if(pspi->tx_buf != 0)
+	if(t->tx_buf)
 		val |= XLP_SPI_CMD_TX;
-	if(pspi->rx_buf != 0)
+	if(t->rx_buf)
 		val |= XLP_SPI_CMD_RX;
         if(xfer_len)
-		val |= ((xfer_len * 8 -1) << XLP_SPI_XFR_BITCNT_POS);
+		val |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_POS);
 
 	spi_reg_write(0, pspi->cs, XLP_SPI_CMD, val);
 
@@ -282,131 +293,92 @@ static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, ui
 				rxfifo_cnt--;
 
                                 if (rx_len <= 1) {
-                                        pspi->rx_buf[0] = (uint8_t) (rx_data & 0xff);
+                                        rx_buf[0] = (uint8_t) (rx_data & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 2) {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 3) {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len -= 4;
                                 }
-
-                                pspi->rx_buf += 4;
+                                rx_buf += 4;
                         }
-			t->len = rx_len;
+			sent_bytes = xfer_len - rx_len;
                 }
                 if (tx_len) {
-                        spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
-			t->len = tx_len;
+			spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+			sent_bytes = xfer_len - tx_len;	
                 }
         }
 
 	do {
 		val = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
-        } while( (val & XLP_SPI_XFR_DONE) == 0);
+		if(val & XLP_SPI_TX_OV_TH)
+		{
+			printk("[%s] tx over threshold, stop sendinging\n",__func__);
+		}
+        } while((val & XLP_SPI_XFR_DONE) == 0);
 
-        return 0;
+        return sent_bytes;
 }
 
 static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
         int ret;
-	uint32_t len = t->len;
-        while (len) {
-
-                if (len > XLP_SPI_MAX_XFER_SIZE) {
-                        ret = spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
-
-                        len = len - XLP_SPI_MAX_XFER_SIZE;
-
-                        if (t->tx_buf)
-                                t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
-                        if (t->rx_buf)
-                                t->rx_buf = t->rx_buf  + XLP_SPI_MAX_XFER_SIZE;
-                        if (ret)
-                                return ret;
-
-                } else {
-                        ret = spi_xlp_xfer_block(spi, t, len);
-                        return ret;
-                }
-        }
-        return 0;
-}
-
-static irqreturn_t spi_xlp_irq(int irq, void *dev_id)
-{
-	struct spi_xlp *pspi = dev_id;
-	uint32_t int_stat;
-
-	int_stat = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
-
-	if (int_stat & XLP_SPI_INT_XFR_DONE) {
-		uint32_t sr;
-
-		sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
-		while ((sr & XLP_SPI_INT_RX_THRESH) == 0) {
-			uint32_t data;
-
-			data = spi_reg_read(0, pspi->cs,XLP_SPI_RXDATA_FIFO);
-			if (pspi->rx_buf) {
-				memcpy(pspi->rx_buf, &data, 4);
-			}
-			sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
-		}
-
-		if (pspi->rcounter > 0) {
-			spi_xlp_fill_txfifo(pspi, &pspi->rcounter, &pspi->tx_buf);
-		} else {
-			complete(&pspi->done);
-		}
+	uint32_t len;
+
+	ret = 0;
+	len = t->len;
+	while (len > XLP_SPI_MAX_XFER_SIZE) {
+		ret += spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
+		len = len - XLP_SPI_MAX_XFER_SIZE;
+		if (t->tx_buf)
+			t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+		if (t->rx_buf)
+			t->rx_buf = t->rx_buf + XLP_SPI_MAX_XFER_SIZE;
 	}
+        ret += spi_xlp_xfer_block(spi, t, len);
 
-	return IRQ_HANDLED;
+        return ret;
 }
 
 static int __init spi_xlp_probe(struct platform_device *dev)
 {
-	int ret = 0 , irt;
+	int ret = 0;
 	struct spi_master *master;
 	struct spi_xlp *pspi;
 	struct resource *r;
 
-
 	master = spi_alloc_master(&dev->dev, sizeof(struct spi_xlp));
-	if(!master) {
-		printk("[%s] failed to allocate spi master\n",__func__);
+
+	if (master == NULL) {
 		return -ENOMEM;
 	}
 
 	dev_set_drvdata(&dev->dev, master);
 
 	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (!r) {
+	if (r == NULL) {
 		ret = -ENODEV;
 		goto put_master;
 	}
 
 	pspi = spi_master_get_devdata(master);
-	platform_set_drvdata(dev, pspi);
-
-	/* setup spi bitbang adaptor */
 	pspi->bitbang.master 		= spi_master_get(master);
 	pspi->bitbang.chipselect	= spi_xlp_chipselect;
 	pspi->bitbang.setup_transfer	= spi_xlp_setup_transfer;
 	pspi->bitbang.txrx_bufs		= spi_xlp_txrx_bufs;
 	pspi->bitbang.master->setup	= spi_xlp_setup;
-	pspi->bitbang.master->num_chipselect = XLP_SPI_MAX_CS;
 	init_completion(&pspi->done);
 
 	if (!request_mem_region(r->start,
@@ -420,29 +392,19 @@ static int __init spi_xlp_probe(struct platform_device *dev)
 		ret = -ENOMEM;
 		goto put_master;
 	}
-        irt = spi_reg_read(0, 0, 0x3D) & 0xFFFF;
-        pspi->irq = nlm_hal_irt_to_irq(irt);
-	if (pspi->irq < 0) {
-		ret = -ENXIO;
-		goto unmap_io;
-	}
 
 	master->bus_num = 0;
 	master->num_chipselect = XLP_SPI_MAX_CS;
 
 	xlp_spi_init(pspi);
-	ret = request_irq(pspi->irq, spi_xlp_irq, 0, "spi-xlp", pspi);
-	if (ret != 0)
-		goto unmap_io;
 	ret = spi_bitbang_start(&pspi->bitbang);
 	if (ret != 0) {
-		printk("[%s] spi_bitbang_start FAILED\n", __func__);
-		goto free_irq;
+		dev_err(&dev->dev, "spi_bitbang_start FAILED\n");
+		goto unmap_io;
 	}
+
 	return ret;
 
-free_irq:
-	free_irq(pspi->irq, pspi);
 unmap_io:
 	iounmap(pspi->regs);
 put_master:
@@ -459,7 +421,6 @@ static int __devexit spi_xlp_remove(struct platform_device *dev)
 	pspi = spi_master_get_devdata(master);
 
 	spi_bitbang_stop(&pspi->bitbang);
-	free_irq(pspi->irq, pspi);
 	iounmap(pspi->regs);
 	platform_set_drvdata(dev, 0);
 	spi_master_put(pspi->bitbang.master);
-- 
1.7.10.4

