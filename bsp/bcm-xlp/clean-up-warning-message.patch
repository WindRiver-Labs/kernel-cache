From 84934fd5b9f7ea2e22da9d776bd264734608d625 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 30 Jun 2010 17:00:34 -0700
Subject: [PATCH 077/761] clean up warning message

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c |  302 +++++++++++++++++++++++++++++++++++++++---
 1 file changed, 287 insertions(+), 15 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index b2b251f..0a637b77 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -34,6 +34,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/msi.h>
 #include <asm/errno.h>
 #include <asm/signal.h>
+#include <asm/system.h>
 #include <asm/ptrace.h>
 #include <asm/kgdb.h>
 #include <asm/mipsregs.h>
@@ -63,10 +64,279 @@ extern int link0, link1;
 struct pic_tmask pic_tmask[PIC_NUM_IRTS];
 
 __u64 nlm_common_irq_mask;
-DEFINE_SPINLOCK(nlm_common_pic_lock);
+spinlock_t nlm_common_pic_lock = SPIN_LOCK_UNLOCKED;
+
+void dump_irt_entry(short no)
+{
+	nlm_reg_t reg;
+	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(no));
+	printk("%d:\t%d\t%d\t%d\t%d\n",no, reg>>31,(reg>>20)&0x3f, (reg>>16)&0x3, reg&0xffff);
+
+}
+
+void dumpall_irt_entry(void)
+{
+	short i;
+
+	printk("IRT:\tEn\tRVec\tDB\tDTE\n");
+
+	for (i = 0; i < PIC_NUM_IRTS; i++)
+		dump_irt_entry(i);
+}
+
+static unsigned int pic_startup(unsigned int irq)
+{
+	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	unsigned long flags;
+	nlm_reg_t reg;
+	unsigned long irt;
+
+	if(irq < 8) {
+		return 0;
+	}
+	irt = find_irt_from_irq(irq);
+	if (irt == -1)	{
+		printk("can't find irt for irq: %d\n",irq);
+		return -1;
+	}
+ 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq, irt); 
+
+	spin_lock_irqsave(&nlm_common_pic_lock, flags);
+
+	/* What happens if this irq was previously not ack'ed? 
+	 * Assume, that doesn't happen?
+	 */
+	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
+	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
+	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg|(1 << 28)|(1 << 31));
+	printk("[%s] Writing IRT reg %ld with IRQ %d\n", __FUNCTION__,irt, irq);
+
+	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+
+	return 0;
+}
+
+static void pic_unmask(unsigned int irq)
+{
+	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	unsigned long flags;
+	nlm_reg_t reg;
+	unsigned long irt;
+
+	if(irq < 8) {
+		return 0;
+	}
+	irt = find_irt_from_irq(irq);
+	if(irt == -1)
+	{
+		printk("can't find irt for irq: %d\n",irq);
+		return;
+	}
+
+ 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+	spin_lock_irqsave(&nlm_common_pic_lock, flags);
+
+	/* What happens if this irq was previously not ack'ed? 
+	 * Assume, that doesn't happen?
+	 */
+	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
+	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
+	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg | (1 << 28) | (1 << 31));
+
+	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+
+	return;
+}
+
+static void pic_ack(unsigned int irq)
+{
+	unsigned long flags, i;
+	unsigned long irt;
+	uint64_t val,eirr;
+
+
+	if(irq < 8) {
+		return 0;
+	}
+	irt = find_irt_from_irq(irq);
+	if(irt == -1)
+	{
+		printk("can't find irt for irq: %d\n",irq);
+		return;
+	}
+	if(irq!=7 && irq != 17 && irq != 18)
+ 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+	/* If edge triggered IRQ, ack it immediately, else when the device
+	 * interrupt condition is cleared, we may lose interrupts 
+	 */
+	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&nlm_common_pic_lock, flags);
+		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
+	if(irq!=7 && irq != 17 && irq != 18)
+		printk("[%s] pending1 :%lx\n", __func__,val);
+		nlm_hal_ack_pic(irt);
+		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
+	if(irq!=7 && irq != 17 && irq != 18)
+		printk("[%s] pending1 :%lx\n", __func__,val);
+		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+	}
+}
+
+static void pic_end(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned long irt;
+	uint64_t val;
+
+	if(irq < 8) {
+		return 0;
+	}
+	irt = find_irt_from_irq(irq);
+	if(irt == -1)
+	{
+		printk("can't find irt for irq: %d\n",irq);
+		return;
+	}
+	if(irq!=7 && irq != 17 && irq != 18)
+ 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+
+	/* If level triggered, ack it after the device condition is cleared */
+	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&nlm_common_pic_lock, flags);
+		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
+	if(irq!=7 && irq != 17 && irq != 18)
+		printk("[%s] pending1 :%lx\n", __func__,val);
+		nlm_hal_ack_pic(irt);
+		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
+	if(irq!=7 && irq != 17 && irq != 18)
+		printk("[%s] pending1 :%lx\n", __func__,val);
+		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+	}
+}
+
+static void pic_shutdown(unsigned int irq)
+{
+	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	unsigned long flags;
+	nlm_reg_t reg;
+	unsigned long irt;
+
+	if(irq < 8) {
+		return 0;
+	}
+	irt = find_irt_from_irq(irq);
+	if(irt == -1)
+	{
+		printk("can't find irt for irq: %d\n",irq);
+		return;
+	}
+
+	//dbg_msg("IN irq=%d\n", irq);
+ 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
+
+	spin_lock_irqsave(&nlm_common_pic_lock, flags);
+
+	/* What happens if this irq is currently pending an ack? 
+	 * Assume, that doesn't happen?
+	 */
+	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), (reg & ~(1 << 31)));
+	printk("[%s] disable IRT %ld with IRQ %d\n", __FUNCTION__,PIC_IRT(irt), irq);
+
+	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+}
+
+/*
+ * Set affinity for the irq for chips
+ * 
+ */
+
+static int pic_set_affinity(unsigned int irq, const struct cpumask *mask)
+{
+	unsigned long flags;
+	int cpu;
+
+	spin_lock_irqsave(&nlm_common_pic_lock, flags);
+	for_each_online_cpu(cpu){
+		if(cpumask_test_cpu(cpu, mask))
+		{
+			nlm_hal_set_irq_to_cpu(irq, cpu);
+		}
+	}
+//	nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu);
+	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
+
+	return 0;
+}
 
 static struct irq_chip nlm_common_pic = {
 	.name = "XLP-PIC",
+	.unmask = pic_unmask,
+	.mask = pic_shutdown,
+	.ack = pic_ack,
+	.end = pic_end,
+	.set_affinity = pic_set_affinity
+};
+
+static void rsvd_pic_handler_1_1(unsigned int irq)
+{
+	if(irq < PIC_IRQ_BASE)
+		return;
+  dbg_msg("Requesting a reserved irq (%d)??", irq);
+  return;
+}
+
+static void rsvd_pic_handler_1(unsigned int irq)
+{
+	if(irq < PIC_IRQ_BASE)
+		return;
+  dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static int rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
+{
+	if(irq < PIC_IRQ_BASE)
+		return -1;
+  dbg_msg("handler called for a reserved irq (%d)\n", irq);
+  return 0;
+}
+
+struct irq_chip nlm_common_rsvd_pic_irq_timer = {
+  .name     =          "Count-Compare",
+  .unmask	=          rsvd_pic_handler_1_1,
+  .mask		=          rsvd_pic_handler_1,
+  .ack          =          rsvd_pic_handler_1,
+  .end          =          rsvd_pic_handler_1,
+  .set_affinity =          rsvd_pic_handler_2
+};
+
+struct irq_chip nlm_common_rsvd_pic = {
+	.name = "Netlogic-RSVD-PIC",
+	.unmask = rsvd_pic_handler_1_1,
+	.mask = rsvd_pic_handler_1,
+	.ack = rsvd_pic_handler_1,
+	.end = rsvd_pic_handler_1,
+	.set_affinity = rsvd_pic_handler_2
+};
+
+static irqreturn_t nlm_common_rsvd_irq_handler(int irq, void *dev_id)
+{
+	if(irq == IRQ_TIMER) 
+		return IRQ_HANDLED;
+  dbg_msg("handler for reserved irq %d\n", irq);
+  return IRQ_NONE;
+}
+
+struct irqaction nlm_common_rsvd_action = {
+	.handler = nlm_common_rsvd_irq_handler,
+	.flags = 0,
+	//.mask = 0,
+	.name = "nlm_common_rsvd_action",
+	.dev_id = 0,
+	.next = 0
 };
 
 void __init init_nlm_common_irqs(void)
@@ -74,30 +344,27 @@ void __init init_nlm_common_irqs(void)
 	int i;
 
 	for (i = 0; i < NR_IRQS; i++) {
-		//set_irq_chip(i, &nlm_common_pic);
-		irq_set_chip_and_handler(i,
-			&nlm_common_pic, handle_level_irq);
-
+		set_irq_chip(i, &nlm_common_pic);
 	}
 
 #ifdef CONFIG_REMOTE_DEBUG
-	//irq_desc[IRQ_REMOTE_DEBUG].chip = &nlm_common_rsvd_pic;
-	//irq_desc[IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
+	irq_desc[IRQ_REMOTE_DEBUG].chip = &nlm_common_rsvd_pic;
+	irq_desc[IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
 	nlm_common_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
 #endif
 
 #ifdef CONFIG_SMP
-	//irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &nlm_common_rsvd_pic;
-	//irq_desc[IRQ_IPI_SMP_FUNCTION].action = &nlm_common_rsvd_action;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &nlm_common_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &nlm_common_rsvd_action;
 
-	//irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &nlm_common_rsvd_pic;
-	//irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &nlm_common_rsvd_action;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &nlm_common_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &nlm_common_rsvd_action;
 
 #ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
 	/* PR: New IPI added here for netrx balancing */
-	//irq_desc[IRQ_IPI_NETRX].chip = &nlm_common_rsvd_pic;
+	irq_desc[IRQ_IPI_NETRX].chip = &nlm_common_rsvd_pic;
 	irq_desc[IRQ_IPI_NETRX].action = &nlm_common_rsvd_action;
-	//nlm_common_irq_mask |= (1ULL << IRQ_IPI_NETRX);
+	nlm_common_irq_mask |= (1ULL << IRQ_IPI_NETRX);
 #endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 
 	nlm_common_irq_mask |=
@@ -105,8 +372,8 @@ void __init init_nlm_common_irqs(void)
 #endif
 
 	/* msgring interrupt */
-	//irq_desc[IRQ_MSGRING].chip = &nlm_common_rsvd_pic;
-	//irq_desc[IRQ_MSGRING].action = &nlm_common_rsvd_action;
+	irq_desc[IRQ_MSGRING].chip = &nlm_common_rsvd_pic;
+	irq_desc[IRQ_MSGRING].action = &nlm_common_rsvd_action;
 	nlm_common_irq_mask |= (1ULL << IRQ_MSGRING);
 
 	/* unmask all PIC related interrupts. If no handler is installed by the 
@@ -177,6 +444,11 @@ void __cpuinit nlm_smp_irq_init(void)
 
 struct irq_chip nlm_common_pic_msi = {
 	.name = "Netlogic-PIC-MSI",
+	.startup = pic_startup,
+	.shutdown = pic_shutdown,
+	.ack = pic_ack,
+	.end = pic_end,
+	.set_affinity = pic_set_affinity
 };
 
 void destroy_irq(unsigned int irq)
-- 
1.7.10.4

