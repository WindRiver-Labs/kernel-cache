From f9c3d8ecb5d86908222c586f476af378b1c78b68 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 23 Mar 2011 17:08:25 -0700
Subject: [PATCH 266/762] add xlp_plat_nand flash driver files

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/nand/xlp_plat_nand.c |  795 ++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/xlp_plat_nand.h |   95 +++++
 2 files changed, 890 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/nand/xlp_plat_nand.c
 create mode 100644 drivers/mtd/nand/xlp_plat_nand.h

diff --git a/drivers/mtd/nand/xlp_plat_nand.c b/drivers/mtd/nand/xlp_plat_nand.c
new file mode 100644
index 0000000..7f58095
--- /dev/null
+++ b/drivers/mtd/nand/xlp_plat_nand.c
@@ -0,0 +1,795 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (â€œNetlogicâ€?. All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#endif
+#include "xlp_plat_nand.h"
+
+int debug = 0;
+
+#define NAND_DEBUG		1
+#define BUF_SIZE 		(16*1024)
+#define dbp_print		if(debug) printk
+#define NAND_DEV_CS		1
+#define DEFAULT_NUM_PARTITIONS	2
+
+static struct mtd_partition xlp_nand_partition_info[] = {
+        {
+        .name = "NAND FS 0",
+        .offset = 0,
+        .size = 8 * 64 * 2048,
+        },
+        {
+        .name = "NAND FS 1",
+        .offset = MTDPART_OFS_APPEND , /* Rest@62M */
+        .size = MTDPART_SIZ_FULL ,
+        },
+};
+	
+struct xlp_nand_data {
+        struct nand_chip        chip;
+        struct mtd_info         mtd;
+        void __iomem            *io_base;
+#ifdef CONFIG_MTD_PARTITIONS
+        int                     nr_parts;
+        struct mtd_partition    *parts;
+#endif
+};
+
+struct nand_state {
+        int cs ;
+        uint32_t col_cyc;
+        uint32_t row_cyc;
+        uint32_t page_size;
+        uint32_t block_size ;
+        uint32_t pages_per_block;
+        uint32_t spare_size ;
+        uint32_t last_cmd ;
+        int buf_ptr ;
+        u8* buf ;
+} ;
+
+static int column_prog = 0;
+static int page_prog = 0;
+static int waitfunc (struct mtd_info *mtd, struct nand_chip *chip) ;
+
+static __inline__ int32_t nand_reg_read(int node,  int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NAND);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ int32_t nor_reg_read(int node,  int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void nand_reg_write(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NAND);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+
+static int dma_wait(int cs)
+{
+        int timeout = 0xfffff ;
+        while ( ( (nand_reg_read(0, NAND_STATUS) & (1 << cs) ) == 0) ||
+                ( (nand_reg_read(0, NAND_DMA_CTRL) & 0x01) == 0) )  {
+
+                timeout--;
+                if (timeout == 0) {
+                        dbp_print("DMA timed out NAND_STATUS:%x\n",nand_reg_read(0,NAND_STATUS)) ;
+                        return -1 ;
+                }
+        }
+        return 0;
+}
+
+static void print_onfi_params(struct nand_onfi_params * p)
+{
+	printk("OFNI parameter \n"); 
+	printk("rev info and features block\n");
+	printk("revision:%d\n", p->revision);
+	printk("features:%x\n", p->features);
+	printk("opt_cmd::%x\n", p->opt_cmd);
+
+	printk("\n memory organization block \n");
+
+
+	printk("byte_per_page:%d\n",p->byte_per_page);
+	printk("spare_bytes_per_page: %d\n", p->spare_bytes_per_page);
+	printk("data_bytes_per_ppage: %d\n", p->data_bytes_per_ppage);
+	printk("sparre_bytes_per_ppage: %d\n", p->sparre_bytes_per_ppage);
+	printk("pages_per_block: %d\n", p->pages_per_block);
+	printk("blocks_per_lun: %d\n", p->blocks_per_lun);
+	printk("lun_count: %d\n", p->lun_count);
+	printk("addr_cycles: %d\n", p->addr_cycles);
+	printk("bits_per_cell: %d\n", p->bits_per_cell);
+	printk("bb_per_lun: %d\n", p->bb_per_lun);
+	printk("block_endurance: %d\n", p->block_endurance);
+	printk("guaranteed_good_blocks: %d\n", p->guaranteed_good_blocks);
+	printk("guaranteed_block_endurance: %d\n", p->guaranteed_block_endurance);
+	printk("programs_per_page: %d\n", p->programs_per_page);
+	printk("ppage_attr: %d\n", p->ppage_attr);
+	printk("ecc_bits: %d\n", p->ecc_bits);
+	printk("interleaved_bits: %d\n", p->interleaved_bits);
+	printk("interleaved_ops: %d\n", p->interleaved_ops);
+
+	printk("\nelectrical parameter block\n");
+	printk("io_pin_capacitance_max: %d\n", p->io_pin_capacitance_max);
+	printk("async_timing_mode: %d\n", p->async_timing_mode);
+	printk("program_cache_timing_mode: %d\n", p->program_cache_timing_mode);
+	printk("t_prog: %d\n", p->t_prog);
+	printk("t_bers: %d\n", p->t_bers);
+	printk("t_r: %d\n", p->t_r);
+	printk("t_ccs: %d\n", p->t_ccs);
+	printk("src_sync_timing_mode: %d\n", p->src_sync_timing_mode);
+	printk("src_ssync_features: %d\n", p->src_ssync_features);
+	printk("clk_pin_capacitance_typ: %d\n", p->clk_pin_capacitance_typ);
+	printk("io_pin_capacitance_typ: %d\n", p->io_pin_capacitance_typ);
+	printk("input_pin_capacitance_typ: %d\n", p->input_pin_capacitance_typ);
+	printk("input_pin_capacitance_max: %d\n", p->input_pin_capacitance_max);
+	printk("driver_strenght_support: %d\n", p->driver_strenght_support);
+	printk("t_int_r: %d\n", p->t_int_r);
+	printk("t_ald: %d\n", p->t_ald);        
+	printk("crc: %x\n", p->crc);
+
+	printk("\nmanufacturer information block\n");
+	printk("manufacturer: %s\n", p->manufacturer);
+	printk("model: %s\n",  p->model);
+	printk("jedec_id: %x\n",         p->jedec_id);
+	printk("date_code: %x\n", p->date_code);
+
+	return;
+}
+
+void onfi_init(struct nand_chip *chip)
+{
+        struct nand_state *state = chip->priv;
+        u8* param_ptr = state->buf ;
+        uint32_t page_val ;
+        uint32_t block_val;
+        uint32_t addr_cyc,addr_val ;
+        uint32_t spare_bytes_per_512 ;
+        uint32_t ecc_bytes ;
+        uint32_t ecc_bits ;
+        uint32_t ecc_val ;
+        uint32_t val ;
+        uint32_t ecc_offset;
+        int i ;
+
+        state->page_size = ( (unsigned int) (param_ptr[80] << 0)  |
+                             (unsigned int) (param_ptr[81] << 8)  |
+                             (unsigned int) (param_ptr[82] << 16) |
+                             (unsigned int) (param_ptr[83] << 24) ) ;
+
+        switch (state->page_size) {
+        case 256:  page_val = 0; break;
+        case 512:  page_val = 1; break;
+        case 1024: page_val = 2; break;
+        case 2048: page_val = 3; break;
+        case 4096: page_val = 4; break;
+        case 8192: page_val = 5; break;
+        case 16384: page_val = 6; break;
+        default: page_val = 7; break;
+        }
+
+        state->pages_per_block  = ( (unsigned int) (param_ptr[92] << 0)  |
+                                    (unsigned int) (param_ptr[93] << 8)  |
+                                    (unsigned int) (param_ptr[94] << 16) |
+                                    (unsigned int) (param_ptr[95] << 24) ) ;
+
+        state->block_size = state->pages_per_block * state->page_size ;
+
+
+        switch (state->pages_per_block) {
+        case 32:  block_val = 0; break;
+        case 64:  block_val = 1; break;
+        case 128: block_val = 2; break;
+        case 256: block_val = 3; break;
+        default: block_val = -1 ; break;
+        }
+
+        addr_cyc = param_ptr[101] ;
+        state->row_cyc = (addr_cyc & 0xf) ;
+        state->col_cyc = ( (addr_cyc >> 4) & 0xf) ;
+        addr_val = state->row_cyc + state->col_cyc ;
+
+        state->spare_size = ( (unsigned int) (param_ptr[84] << 0)  |
+                              (unsigned int) (param_ptr[85] << 8) ) ;
+
+        spare_bytes_per_512 = state->spare_size/(state->page_size/512) ;
+
+        if (spare_bytes_per_512 <= 4) {
+                ecc_bytes = 0 ;
+                ecc_bits  = 0 ;
+                ecc_val   = 0 ;
+        } else if (spare_bytes_per_512 <= 8) {
+                ecc_bytes = 4 ;
+                ecc_bits  = 2 ;
+                ecc_val   = 0 ;
+        } else if (spare_bytes_per_512 <= 16) {
+                ecc_bytes = 8 ;
+                ecc_bits  = 13 ;
+                ecc_val   = 3 ;
+        } else if (spare_bytes_per_512 <= 24) {
+                ecc_bytes = 20 ;
+                ecc_bits  = 12 ;
+                ecc_val   = 5 ;
+        } else {
+                ecc_bytes = 23 ;
+                ecc_bits  = 14 ;
+                ecc_val   = 6 ;
+        }
+        ecc_offset = state->spare_size - ( (state->page_size/512) * ecc_bytes);
+
+
+        nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
+        nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
+	
+	val = nand_reg_read(0, NAND_CTRL);
+        val |= (NAND_CTRL_ECC_EN(1)		  |
+		NAND_CTRL_PAGE_SIZE(page_val)  |
+		NAND_CTRL_BLOCK_SIZE(block_val)|
+		NAND_CTRL_ADDR_CYCLE(addr_val));
+	nand_reg_write(0, NAND_CTRL, val);
+
+        chip->ecc.size   = 512;
+        chip->ecc.bytes  = ecc_bytes;
+        chip->ecc.layout = kmalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
+        chip->ecc.layout->eccbytes = (ecc_bytes * (state->page_size / 512));
+        for (i=0; i < ecc_bytes; i++) {
+                chip->ecc.layout->eccpos[i] = ecc_offset + i;
+        }
+        chip->ecc.layout->oobfree[0].offset = 2 ;
+        chip->ecc.layout->oobfree[0].length = state->spare_size - chip->ecc.layout->eccbytes - 2;
+}
+
+
+
+#ifdef NAND_DEBUG
+static void nand_dump_reg(void)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x30; i < 0x4A; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x50; i < 0x5C; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+	for(i = 0x60; i < 0x70; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x80; i < 0x82; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+}
+
+static void nand_dump_ioreg( uint32_t * ioaddr)
+{
+	int i;
+	if(!ioaddr)
+		return;
+	for(i = 0; i < 12; i++)
+		printk("nand 0x%0x = 0x%8x\n", i, ioaddr[i]);
+	for(i = 25; i < 39; i++)
+		printk("nand 0x%0x = 0x%8x\n", i, ioaddr[i]);
+
+}
+#endif
+
+static void send_cmd(struct mtd_info *mtd,
+                     unsigned int command,
+                     int column,
+                     int page_addr,
+                     int len)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+	uint32_t val;
+
+        nand_reg_write(0, NAND_DATA_SIZE, len);
+        nand_reg_write(0, NAND_DMA_CNT, len);
+
+	val = (page_addr >> (32 - (state->col_cyc * 8)));
+        nand_reg_write(0, NAND_ADDR1_L, val);
+	val = ( (page_addr << (state->col_cyc * 8) ) | column);
+        nand_reg_write(0, NAND_ADDR0_L, val) ;
+	val = virt_to_phys((void *) state->buf) + state->buf_ptr;
+        nand_reg_write(0, NAND_DMA_ADDR, val);
+
+        if ( (command == NAND_READ_PAGE_CMD) ||
+             (command == NAND_READ_ID_CMD)   ||
+             (command == NAND_READ_PARAMETER_CMD) ) {
+                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (1 << 6) | (5 << 2));
+        } else {
+                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
+        }
+
+        if ((column + len) > mtd->writesize) {
+		val = nand_reg_read(0, NAND_CTRL);
+                nand_reg_write(0, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
+        }
+
+        nand_reg_write(0, NAND_CMD, command | NAND_CMD_DMA_FLAG);
+        dma_wait(state->cs);
+	val = nand_reg_read(0, NAND_CTRL);
+        nand_reg_write(0, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1)));
+
+        state->last_cmd    = command;
+}
+
+static void cmdfunc(struct mtd_info *mtd,
+                    unsigned int command,
+                    int column,
+                    int page_addr)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        int len = 0 ;
+        uint32_t val;
+
+        if (state->cs < 0)
+                return;
+
+        switch (command) {
+	/*
+	 * READ0 - read in first  256 bytes
+	 * READ1 - read in second 256 bytes
+	 */
+        case NAND_CMD_READ1:
+                column += 256;
+        case NAND_CMD_READ0:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         column,
+                         page_addr,
+                         mtd->writesize);
+                state->buf_ptr += mtd->writesize;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         (mtd->writesize + column),
+                         page_addr,
+                         (mtd->oobsize - column));
+                state->buf_ptr = 0;
+		break;
+        /* READOOB reads only the OOB because no ECC is performed. */
+        case NAND_CMD_READOOB:
+               dbp_print("NAND_CMD_READOOB, "
+                    "page_addr: 0x%x, column: 0x%x oobsize: 0x%x.\n",
+                    page_addr, column, mtd->oobsize);
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         (mtd->writesize + column),
+                         page_addr,
+                         (mtd->oobsize - column));
+                state->buf_ptr = 0;
+		break;
+        /* READID must read all 5 possible bytes while CEB is active */
+        case NAND_CMD_READID:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_ID_CMD,
+                         column,
+                         0,
+                         8);
+                state->buf_ptr = 0;
+		break;
+        case NAND_CMD_PARAM:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PARAMETER_CMD,
+                         0,
+                         0,
+                         1024);
+                onfi_init(chip);
+		break;
+        /* ERASE1 stores the block and page address */
+        case NAND_CMD_ERASE1:
+                dbp_print("NAND_CMD_ERASE1, "
+                    "page_addr: 0x%x, column: 0x%x.\n",
+                    page_addr, column);
+                val = (page_addr >> (32 - (state->col_cyc*8)));
+		nand_reg_write(0, NAND_ADDR1_L, val);
+                val = ((page_addr << (state->col_cyc * 8)));
+		nand_reg_write(0, NAND_ADDR0_L, val);
+		break;
+        /* ERASE2 uses the block and page address from ERASE1 */
+        case NAND_CMD_ERASE2:
+                dbp_print("NAND_CMD_ERASE2, "
+                    "addr 0x%x\n",
+		nand_reg_read(0, NAND_ADDR0_L));
+		nand_reg_write(0, NAND_CMD, NAND_ERASE_BLOCK_CMD);
+		state->last_cmd         = NAND_ERASE_BLOCK_CMD ;
+		waitfunc(mtd,chip) ;
+		break;
+        /* SEQIN sets up the addr buffer and all registers except the length */
+        case NAND_CMD_SEQIN:
+                dbp_print("NAND_CMD_SEQIN/PAGE_PROG, "
+                       "page_addr: 0x%x, column: 0x%x.\n",
+                       page_addr, column);
+                column_prog    = column;
+                page_prog      = page_addr;
+                state->buf_ptr = 0;
+		break;
+        /* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+        case NAND_CMD_PAGEPROG:
+                len = state->buf_ptr;
+                state->buf_ptr = 0;
+                dbp_print("PAGE_PROG: page 0x%x col 0x%x size %d \n",page_prog,column_prog,len);
+                send_cmd(mtd,
+                         NAND_PAGE_PROGRAM_CMD,
+                         column_prog,
+                         page_prog,
+                         len);
+                waitfunc(mtd,chip);
+		break;
+
+        case NAND_CMD_STATUS:
+                nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
+                state->last_cmd = NAND_READ_STATUS_CMD;
+                dbp_print("Status read\n");
+		break;
+        /* RESET command */
+        case NAND_CMD_RESET:
+                nand_reg_write(0, NAND_CMD, NAND_RESET_CMD);
+                state->last_cmd = NAND_RESET_CMD;
+                waitfunc(mtd,chip);
+		break;
+
+        default:
+                dbp_print("netl8xx_nand: unsupported command 0x%x\n",command);
+        }
+}
+
+static void select_chip(struct mtd_info *mtd, int dev)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        if ( (dev >= 0) && (dev < 8) ) {
+                nand_reg_write(0, NAND_MEMCTRL, dev + NAND_DEV_CS);
+		state->cs = dev + NAND_DEV_CS;
+        } else {
+                state->cs = -1;
+        }
+}
+
+static uint8_t read_byte(struct mtd_info *mtd)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        uint32_t data ;
+
+        if (state->cs < 0)
+                return 0;
+
+        if (state->last_cmd == NAND_READ_STATUS_CMD) {
+                data = nand_reg_read(0, NAND_READ_STATUS);
+                dbp_print("Status: %x\n",data);
+                return nand_reg_read(0, NAND_READ_STATUS);
+        } else {
+                data = state->buf[state->buf_ptr];
+                state->buf_ptr = (state->buf_ptr+1)%BUF_SIZE;
+                return data;
+        }
+}
+
+static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        int i;
+
+        if (state->cs < 0)
+                return;
+
+        dbp_print("read_buf %p %d %d\n", buf, state->buf_ptr, len);
+        for (i = 0; i < len; i++) {
+                buf[i] = state->buf[state->buf_ptr];
+                state->buf_ptr = (state->buf_ptr + 1) % BUF_SIZE;
+        }
+        return;
+}
+
+static void write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+        int i=0;
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return;
+
+        dbp_print("write_buf %p %d %d\n",buf,state->buf_ptr,len);
+        while (len > 0) {
+                state->buf[state->buf_ptr] = buf[i++];
+                len--;
+                state->buf_ptr = (state->buf_ptr + 1) % BUF_SIZE;
+        }
+}
+
+static int read_page(struct mtd_info *mtd,
+                     struct nand_chip *chip,
+                     uint8_t *buf, int page)
+{
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return -1;
+
+        dbp_print ("Read page %s\n",buf);
+        read_buf(mtd, buf, mtd->writesize);
+
+        return 0;
+}
+
+static void write_page(struct mtd_info *mtd,
+                       struct nand_chip *chip,
+                       const uint8_t *buf)
+{
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return;
+        dbp_print ("Write page %p\n",buf);
+        write_buf(mtd, buf, mtd->writesize);
+}
+
+static int waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+        struct nand_state *state = chip->priv;
+        int timeout = 0xfffff;
+        uint32_t val;
+
+        if (state->cs < 0)
+                return -1;
+		val = nand_reg_read(0, NAND_STATUS);
+        while ((val & (1 << state->cs)) == 0) {
+                timeout--;
+                if (timeout == 0) {
+                        dbp_print("wait func out\n");
+                        return -1 ;
+                }
+			val = nand_reg_read(0, NAND_STATUS);
+	}
+
+        nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
+        return nand_reg_read(0, NAND_READ_STATUS);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+        struct nand_state *state ;
+        uint32_t val;
+
+        nand_reg_write(0, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
+
+	val = 	NAND_TIME_SEQ0_TWHR(7) |
+		NAND_TIME_SEQ0_TRHW(7) |
+		NAND_TIME_SEQ0_TADL(7) |
+		NAND_TIME_SEQ0_TCCS(7);
+
+	val =  NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
+
+	nand_reg_write(0, NAND_TIMINGS_ASYN, val);
+
+
+        nand->ecc.read_page  = read_page;
+        nand->ecc.write_page = write_page;
+
+
+        nand->ecc.mode    = NAND_ECC_HW;
+
+        nand->read_byte   = read_byte;
+        nand->write_buf   = write_buf;
+        nand->read_buf    = read_buf;
+        nand->verify_buf  = NULL;
+        nand->select_chip = select_chip;
+        nand->cmdfunc     = cmdfunc;
+        nand->waitfunc    = waitfunc;
+
+        nand->options     = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT;
+
+
+        state            = kmalloc(sizeof(struct nand_state), GFP_KERNEL);
+        state->last_cmd  = 0;
+        state->cs        = 0;
+        state->buf_ptr   = 0;
+        state->buf       = kmalloc(BUF_SIZE, GFP_KERNEL);
+        nand->priv       = state;
+
+        dbp_print("Nand buffer virt: %p  phys: %p\n",state->buf,(u8 *) virt_to_phys((void *) state->buf) );
+        return 0;
+}
+
+
+/*
+ * Probe for the NAND device.
+ */
+static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
+{
+        struct platform_nand_data *pdata = pdev->dev.platform_data;
+        struct xlp_nand_data *data;
+        struct nand_state *state ;
+        int res = 0;
+        uint32_t val;
+
+	/* nand_dump_reg();*/
+		
+        /* Allocate memory for the device structure (and zero it) */
+        data = kzalloc(sizeof(struct xlp_nand_data), GFP_KERNEL);
+        if (!data) {
+                dev_err(&pdev->dev, "failed to allocate device structure.\n");
+                return -ENOMEM;
+        }
+
+	pdev->resource[0].end	= pdev->resource[0].start + 0x1000 -1;
+        data->io_base = ioremap(pdev->resource[0].start + 0x100,
+                                pdev->resource[0].end - pdev->resource[0].start + 1);
+        if (data->io_base == NULL) {
+                dev_err(&pdev->dev, "ioremap failed\n");
+                kfree(data);
+                return -EIO;
+        }
+	/* nand_dump_ioreg((uint32_t*)  data->io_base);*/
+
+        nand_reg_write(0, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
+
+        val = ( NAND_TIME_SEQ0_TWHR(7) |
+		NAND_TIME_SEQ0_TRHW(7) |
+		NAND_TIME_SEQ0_TADL(7) |
+		NAND_TIME_SEQ0_TCCS(7) );
+
+	nand_reg_write(0, NAND_TIME_SEQ0, val);
+
+        val = NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
+	nand_reg_write(0, NAND_TIMINGS_ASYN, val);
+
+        state            = kmalloc(sizeof(struct nand_state), GFP_KERNEL);
+        state->last_cmd  = 0;
+        state->cs        = 0;
+        state->buf_ptr   = 0 ;
+        state->buf       = kmalloc(BUF_SIZE, GFP_KERNEL);
+
+        data->chip.priv = state;
+        data->mtd.priv = &data->chip;
+        data->mtd.owner = THIS_MODULE;
+        data->mtd.name = dev_name(&pdev->dev);
+
+        data->chip.IO_ADDR_R = data->io_base;
+        data->chip.IO_ADDR_W = data->io_base;
+
+        data->chip.read_byte   	= read_byte ;
+        data->chip.write_buf 	= write_buf;
+        data->chip.read_buf 	= read_buf;
+        data->chip.verify_buf  	= NULL ;
+        data->chip.select_chip 	= select_chip;
+        data->chip.cmdfunc	= cmdfunc ;
+        data->chip.waitfunc	= waitfunc ;
+        data->chip.chip_delay	= 15;
+
+        data->chip.options     = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT ;
+        data->chip.ecc.mode = NAND_ECC_HW;
+
+        data->chip.ecc.read_page  = read_page;
+        data->chip.ecc.write_page = write_page;
+
+        platform_set_drvdata(pdev, data);
+
+        if (nand_scan(&data->mtd, 1)) {
+                res = -ENXIO;
+                goto out;
+        }
+
+	print_onfi_params(&data->chip.onfi_params);
+
+
+	/* Register the partitions */
+	add_mtd_partitions(&data->mtd, xlp_nand_partition_info, ARRAY_SIZE(xlp_nand_partition_info));
+        res = add_mtd_device(&data->mtd);
+
+        if (!res)
+                return res;
+
+        nand_release(&data->mtd);
+out:
+        platform_set_drvdata(pdev, NULL);
+        iounmap(data->io_base);
+        kfree(data);
+        return res;
+}
+
+/*
+ * Remove a NAND device.
+ */
+static int __devexit xlp_plat_nand_remove(struct platform_device *pdev)
+{
+        struct xlp_nand_data *data = platform_get_drvdata(pdev);
+        struct platform_nand_data *pdata = pdev->dev.platform_data;
+
+        nand_release(&data->mtd);
+#ifdef CONFIG_MTD_PARTITIONS
+        if (data->parts && data->parts != pdata->chip.partitions)
+                kfree(data->parts);
+#endif
+        if (pdata->ctrl.remove)
+                pdata->ctrl.remove(pdev);
+        iounmap(data->io_base);
+        kfree(data);
+
+        return 0;
+}
+
+static struct platform_driver xlp_plat_nand_driver = {
+        .probe          = xlp_plat_nand_probe,
+        .remove         = __devexit_p(xlp_plat_nand_remove),
+        .driver         = {
+                .name   = "nand-xlp",
+                .owner  = THIS_MODULE,
+        },
+};
+
+static int __init xlp_plat_nand_init(void)
+{
+        return platform_driver_register(&xlp_plat_nand_driver);
+}
+static void __exit xlp_plat_nand_exit(void)
+{
+        platform_driver_unregister(&xlp_plat_nand_driver);
+}
+
+module_init(xlp_plat_nand_init);
+module_exit(xlp_plat_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netlogicmicro System");
+MODULE_DESCRIPTION("XLP NAND platform driver");
+MODULE_ALIAS("platform:nand-xlp");
+
diff --git a/drivers/mtd/nand/xlp_plat_nand.h b/drivers/mtd/nand/xlp_plat_nand.h
new file mode 100644
index 0000000..0f392bd
--- /dev/null
+++ b/drivers/mtd/nand/xlp_plat_nand.h
@@ -0,0 +1,95 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (â~@~\Netlogicâ~@?. All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+#ifndef _XLP_NAND_H
+#define _XLP_NAND_H
+
+#define NAND_CMD		0x40
+#define NAND_CTRL		0x41
+#define NAND_STATUS		0x42
+#define NAND_INTMASK		0x43
+#define NAND_INT_STATUS		0x44
+#define	NAND_ECC_CTRL		0x45
+#define NAND_ECC_OFFSET		0x46
+#define NAND_ADDR0_L		0x47
+#define NAND_ADDR0_H		0x49
+#define NAND_ADDR1_L		0x48
+#define NAND_ADDR1_H		0x4A
+#define NAND_SPARE_SIZE		0x4B
+#define NAND_DMA_ADDR		0x59
+#define NAND_DMA_CNT		0x5A
+#define NAND_DMA_CTRL		0x5B
+#define NAND_MEMCTRL		0x60
+#define NAND_DATA_SIZE		0x61
+#define NAND_READ_STATUS	0x62
+#define NAND_TIME_SEQ0		0x63
+#define NAND_TIMINGS_ASYN	0x64
+#define NAND_TIMINGS_SYN	0x65
+#define NAND_FIFO_DATA		0x66
+#define NAND_FIFO_INIT		0x6C
+#define NAND_GENERIC_SEQ	0x6D
+#define NAND_FIFO_STATE		0x6E
+#define NAND_TIME_SEQ1		0x6F
+
+#define NAND_SYSCTRL		0x80
+#define NAND_RYBYSEL		0x81
+
+/*                                     CMD 3         CMD 2          CMD 1         SEQ */
+#define NAND_RESET_CMD              ( (0x0  << 24) | (0x0  << 16) | (0xFF << 8) | 0x0)
+#define NAND_READ_PARAMETER_CMD     ( (0x0  << 24) | (0x0  << 16) | (0xEC << 8) | 0x22)
+#define NAND_READ_ID_CMD            ( (0x0  << 24) | (0x0  << 16) | (0x90 << 8) | 0x21)
+#define NAND_READ_PAGE_CMD          ( (0x0  << 24) | (0x30 << 16) | (0x00 << 8) | 0x2a)
+#define NAND_ERASE_BLOCK_CMD        ( (0x0  << 24) | (0xD0 << 16) | (0x60 << 8) | 0xe)
+#define NAND_PAGE_PROGRAM_CMD       ( (0x0  << 24) | (0x10 << 16) | (0x80 << 8) | 0xc)
+#define NAND_READ_STATUS_CMD        ( (0x0  << 24) | (0x00 << 16) | (0x70 << 8) | 0x24)
+
+#define NAND_CMD_DMA_FLAG   (1<<6)
+#define NAND_CMD_ADDR1_FLAG (1<<7)
+
+#define NAND_CTRL_X16_FLAG (1<<12)
+#define NAND_CTRL_CUSTOM_XFER_FLAG (1<<11)
+#define NAND_CTRL_PAGE_SIZE(size) (size<<8)
+#define NAND_CTRL_BLOCK_SIZE(size) (size<<6)
+#define NAND_CTRL_ADDR_CYCLE(cyc) (cyc<<0)
+#define NAND_CTRL_ECC_EN(en) (en<<5)
+#define NAND_CTRL_SPARE_EN(en) (en<<3)
+
+/*Sync mode WE High->RE Low*/
+#define NAND_TIME_SEQ0_TWHR(x) (x<<24)
+/*ASync mode RE High->WE Low*/
+#define NAND_TIME_SEQ0_TRHW(x) (x<<16)
+/*Async ALE->Data start*/
+#define NAND_TIME_SEQ0_TADL(x) (x<<8)
+/*Chance column setup*/
+#define NAND_TIME_SEQ0_TCCS(x) (x<<0)
+/*TRR time peroid*/
+#define NAND_TIME_SEQ1_TRR(x) (x<<9)
+/*Busy time peroid for async->sync*/
+#define NAND_TIME_SEQ1_TWB(x) (x<<0)
+/*RE/WE high hold time*/
+#define NAND_TIME_ASYN_TRWH(x) (x<<4)
+/*RE/WE pulse width*/
+#define NAND_TIME_ASYN_TRWP(x) (x<<0)
+
+#endif
-- 
1.7.0.4

