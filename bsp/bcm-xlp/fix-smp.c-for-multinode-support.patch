From a76ba5bb21211b3d7e0e28e4945acc3692df293e Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 27 Aug 2010 16:56:30 -0700
Subject: [PATCH 156/761] fix smp.c for multinode support

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/smp.c |   86 +++++++++++++++++++++++-------------------
 1 file changed, 48 insertions(+), 38 deletions(-)

diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index f64e30d..d003263 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -35,6 +35,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msgring.h>
 #include <asm/netlogic/mips-exts.h>
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
 
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
@@ -44,7 +46,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "cpu_control_macros.h"
 
 
-extern int onlinemask;
 unsigned int fast_syscall_cpumask_phy = 0x1;
 extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
@@ -58,20 +59,37 @@ extern void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int t
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
 cpumask_t phys_cpu_present_map;
 extern void asmlinkage smp_bootstrap(void);
-extern void core_send_ipi(int cpu, unsigned int action);
+/*extern void core_send_ipi(int cpu, unsigned int action);*/
 
 extern void enable_cpus( unsigned int node, unsigned int onlinemask );
 
 void nlm_send_ipi_single(int cpu, unsigned int action)
 {
-    core_send_ipi(cpu, action);
+printk("[%s] cpu: %d\n",__func__,  cpu);
+        __u32 node = cpu / 32;
+        __u32 tid = cpu & 0x3;
+        __u32 pid = (cpu >> 2) & 0x07;
+        __u32 ipi = (tid << 16) | (pid << 20);
+
+        if (action & SMP_CALL_FUNCTION) {
+                ipi |= IRQ_IPI_SMP_FUNCTION;
+	} else if (action & SMP_RESCHEDULE_YOURSELF) {
+                ipi |= IRQ_IPI_SMP_RESCHEDULE;
+	} else if (action & SMP_CALL_KGDB_HOOK) {
+                ipi |= IRQ_IPI_SMP_KGDB;
+	} else if (action & SMP_OPROFILE_IPI) {
+                ipi |= IRQ_IPI_OPROFILE;
+        } else
+                BUG();
+        nlm_hal_pic_send_ipi(0, (ipi & 0x3f), node , cpu);
 }
 
 void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
 {
     int cpu;
     for_each_cpu(cpu, mask){
-        core_send_ipi(cpu, action);
+	 nlm_send_ipi_single(cpu, action);
+/*        core_send_ipi(cpu, action);*/
     }
 }
 
@@ -98,21 +116,17 @@ void nlm_cpus_done(void)
 
 /* Boot all other cpus in the system, initialize them, and
    bring them into the boot fn */
-void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
+void nlm_boot_secondary(int cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
-	int cpu = cpu_logical_map(logical_cpu);
-
-	if(cpu == 32)
-	{
-		//enable_cores( 1,0x3,4); 
-		enable_cpus( 1, smp_node.onlinemask[1]);
-	}
+//	int cpu = cpu_logical_map(logical_cpu);
+//printk("[%s] logical_cpu: %x  cpu: %x\n",__func__, logical_cpu, cpu);
 
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
-	smp_boot.boot_info[cpu].fn = (unsigned long)&smp_bootstrap;  
+	smp_boot.boot_info[cpu].fn = (unsigned long)&smp_bootstrap;
+
 	/* barrier */
 	__sync();
 	smp_boot.boot_info[cpu].ready = 1;
@@ -123,12 +137,8 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 
 void __init nlm_smp_setup(void)
 {
-	int num_cpus = 1;
+	int num_cpus;
 	__u32 boot_cpu_online_map = 0, boot_cpu = 0x0;
-
-
-	extern __u32 ipi_3_counter_tx[NR_CPUS][NR_CPUS];
-	extern __u32 ipi_3_counter_rx[NR_CPUS];
 	int i=0, j=0;
 
 	boot_cpu = hard_smp_processor_id();
@@ -139,16 +149,9 @@ void __init nlm_smp_setup(void)
 	__cpu_logical_map[0] = 0;  
 	dev_tree_en fix , and also not required for the existing case also */
 
-//	cpus_clear(cpu_possible_map);
 	/* cpu_set(0, cpu_possible_map); */
 
 	/* Initialize the ipi debug stat variables */
-	for(i=0;i<NR_CPUS;i++) {
-		for(j=0;j<NR_CPUS;j++)
-			ipi_3_counter_tx[i][j] = 0;
-  
-		ipi_3_counter_rx[i] = 0;
-	}
 
 	boot_cpu_online_map = smp_node.onlinemask[0];
 	smp_boot.online_map = smp_node.onlinemask[0];
@@ -158,16 +161,17 @@ void __init nlm_smp_setup(void)
 	/* Fill the entries for boot cpu */
 	boot_cpu_online_map &= (~(1 << boot_cpu));
 	cpu_set(boot_cpu, phys_cpu_present_map);
+
+	cpus_clear(cpu_possible_map);
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
-//	cpu_set(0, cpu_possible_map);
-
+	cpu_set(0, cpu_possible_map);
+	num_cpus = 1;
 	for(i = 0; i < 32; i++) {
 		if (boot_cpu_online_map & (1<<i)) {
-			cpu_set(i, phys_cpu_present_map);
+			cpu_set(i, cpu_possible_map);
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
-//			cpu_set(num_cpus, cpu_possible_map);
 			++num_cpus;
 		}
 	}
@@ -180,20 +184,21 @@ void __init nlm_smp_setup(void)
 
 		for(i = 0; i < 32; i++) {
 			if (boot_cpu_online_map & (1<<i)) {
-				cpu_set(i + 32*j, phys_cpu_present_map);
+				cpu_set(i + 32*j, cpu_possible_map);
 				__cpu_number_map[i+32*j] = num_cpus;
 				__cpu_logical_map[num_cpus] = i+32*j;
-				cpu_set(num_cpus, cpu_possible_map);
 				++num_cpus;
 			}
 		}
 	}
+	phys_cpu_present_map	= cpu_possible_map;
+	cpu_present_map		= cpu_possible_map;
 
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
-
+printk("phys_cpu_present_map: %x  cpu_possible_map: %x cpu_present_map: %x\n", phys_cpu_present_map,  cpu_possible_map, cpu_present_map); 
 	printk("Phys CPU present map: %lx, possible map %lx\n", 
 	       (unsigned long)phys_cpu_present_map.bits[0], 
-	       (unsigned long)phys_cpu_present_map.bits[0]);
+	       (unsigned long)cpu_possible_map.bits[0]);
 
 	printk("Detected %i Slave CPU(s)\n", num_cpus);
 }
@@ -238,7 +243,6 @@ void prom_boot_cpus_secondary(void *args)
 #ifdef CONFIG_NLM_XLP
 
 extern void prom_pre_boot_secondary_cpus(void *);
-extern uint32_t xlp_linux_cpu_mask;
  
 #ifdef CONFIG_MAPPED_KERNEL
 #define secondary_cpus_bootup_func \
@@ -250,12 +254,18 @@ extern uint32_t xlp_linux_cpu_mask;
 
 int wakeup_secondary_cpus(void)
 {
-	smp_node.onlinemask[0] = xlp_linux_cpu_mask;
-	smp_node.onlinemask[1] = 0x00000000;
+	int i;
+	smp_node.onlinemask[0] = 0x000000ff;
+	smp_node.onlinemask[1] = 0x000000ff;
 	smp_node.onlinemask[2] = 0x00000000;
 	smp_node.onlinemask[3] = 0x00000000;
-
-	enable_cpus( 0, smp_node.onlinemask[0]);
+	for(i = 0; i < 4; i++)
+	{
+		if(smp_node.onlinemask[i] == 0)
+			continue;
+		enable_cpus( i, smp_node.onlinemask[i]);
+		printk("enable node %d  smp_node.onlinemask[%d]): %x\n", i,i, smp_node.onlinemask[i]);
+	}
 	return 0;
 }
 
-- 
1.7.10.4

