From 6739becb4acae8688bf7b3e657ea010a82da1605 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Sat, 5 Jun 2010 08:49:55 -0700
Subject: [PATCH 039/762] many changs to this file:1.add Netlogic copyright 2. change to PCIE based nlm_hal register access 3. add smp_lock spinlock to protect register access 4. add support multinode register access

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c |   72 +++++++++++++++++++++++++++------
 1 files changed, 59 insertions(+), 13 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index d5deb21..9b7c8ee 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -1,3 +1,28 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (�~@~\Netlogic�~@~]). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
 #include <linux/spinlock.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>
@@ -16,14 +41,19 @@
 #include <asm/cacheflush.h>
 
 #include <asm/netlogic/sim.h>
-#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal.h>
 
 #include "cpu_control_macros.h"
 
+#define XLP_ECFG_BASE           0x18000000
+#define XLP_SYS_DEV_BASE        0x35000
+
+
 /* Globals Section 
  */ 
 uint32_t cores_bitmap = 0x1;	/* Bitmap of cores to enable  */
 int threads_to_enable; 			/* Threads to enable per core */
+DEFINE_SPINLOCK(smp_lock);
 
 /* temporary storage space for
  * stack pointers
@@ -48,36 +78,47 @@ static inline void jump_address(unsigned long entry)
 			:: "r"(entry));
 }
 
-void enable_cores(unsigned int cbitmap) {
+void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num) {
+	uint32_t core, value, start_core, i = 0;
+        uint64_t sys_mmio;
+
+       if(node == 0)
+                start_core = 0x2;
+        else
+                start_core = 0x1;
 
-	uint32_t core, value;
+        sys_mmio = XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node;
 
-	nlm_reg_t *sys_mmio = 
-	        netlogic_io_mmio(NETLOGIC_IO_SYS_OFFSET);
-	printk("sys_mmio = %p\n", sys_mmio);
+	printk("sys_mmio = %llu\n", sys_mmio);
 
-	for (core=0x2; core!=(0x1<<8); core<<=1) {
+	for (core=start_core; core!=(0x1<<8); core<<=1) {
 
+		if(thread_num != 4)
+		{
+			value = (thread_num-1) << (i*2);
+			nlm_hal_write_32bit_reg(sys_mmio, 0x4C, value);
+		}
 		if (cbitmap & core) {
 
 			/* Enable CPU clock 
 			 */
-			value = netlogic_read_reg(sys_mmio, SYS_COREDFSDISCTRL) & ~core;
-			netlogic_write_reg(sys_mmio, SYS_COREDFSDISCTRL, value);
+                        value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
+                        nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
 
 			/* Remove CPU Reset */
-			value = netlogic_read_reg(sys_mmio, SYS_CPURST) & ~core;
-			netlogic_write_reg(sys_mmio, SYS_CPURST, value);
+                        value = nlm_hal_read_32bit_reg(sys_mmio, 0x4B) & ~core;
+                        nlm_hal_write_32bit_reg(sys_mmio, 0x4B, value);
 
 			/* Poll for CPU to mark itself coherent */
 			do {
-				value = netlogic_read_reg(sys_mmio, SYS_CPUNONCOHERENTMODE) & core;
+                                value = nlm_hal_read_32bit_reg(sys_mmio, 0x4D) & core;
 			} while (value);
 #if 0
 			/* hangs..? */
 			udelay(50);
 #endif
 		}
+		i++;
 	}
 }
 
@@ -88,6 +129,7 @@ void enable_cpus(unsigned long thread_bitmask)
 	uint32_t cbitmap;
 	uint32_t t0_bitmap = 0x0;
 	uint32_t t0_positions = 0, index=3;
+	unsigned long flags;
 
 	/* Extract the bitmap of 'cores'
 	 * from the complete input bitmask
@@ -130,6 +172,8 @@ void enable_cpus(unsigned long thread_bitmask)
 			printk("[Core 0] : Invalid Threads number!\n");
 			return;
 	}
+
+        spin_lock_irqsave(&smp_lock, flags);
 	
 	/* Linux runs out of KSEG2. Setup TLBs
 	 * for other threads, by running from
@@ -150,6 +194,8 @@ void enable_cpus(unsigned long thread_bitmask)
 			   (reset_entry_end - reset_entry));
 	}
 
-	enable_cores(cbitmap);
+	enable_cores(0, cbitmap, threads_to_enable);
+        spin_unlock_irqrestore(&smp_lock, flags);
+
 	return;
 }
-- 
1.7.0.4

