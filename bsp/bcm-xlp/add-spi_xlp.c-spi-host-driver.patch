From fe5607fb52a4de2ec4aa37e0114fcbeedc5869c7 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 28 Dec 2010 01:53:32 -0800
Subject: [PATCH 254/761] add spi_xlp.c spi host driver

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/spi/spi_xlp.c |  524 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 524 insertions(+)
 create mode 100644 drivers/spi/spi_xlp.c

diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
new file mode 100644
index 0000000..35a4230
--- /dev/null
+++ b/drivers/spi/spi_xlp.c
@@ -0,0 +1,524 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/io.h>
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+
+#define CONFIG_SPI_REFCLK		133333334
+#define SPI_CHAN_OFFSET			0x10
+#define OPCODE_RDID			0x9f
+#define OPCODE_RDSR			0x05
+#define OPCODE_WREN			0x06
+#define OPCODE_WRDI			0x04
+#define OPCODE_BE_4K			0x20
+#define OPCODE_BE_32K			0x52
+#define OPCODE_CHIP_ERASE		0xc7
+#define OPCODE_SE			0xd8
+#define DEFAULT_CS_FDIV			0x10
+#define XLP_SPI_MAX_XFER_SIZE		0x2000
+
+struct spi_xlp {
+	/* bitbang has to be first */
+	struct spi_bitbang bitbang;
+	struct completion done;
+	uint8_t 	cs;
+	uint8_t 	cs_active;
+	void __iomem	*regs;		/* virt. address of the control registers */
+	uint32_t	irq;
+	uint32_t	speed_hz; 	/* SCK has a fixed frequency of speed_hz Hz */
+	unsigned char *prxbuf;		/* pointer in the Tx buffer */
+	unsigned char *ptxbuf;		/* pointer in the Rx buffer */
+	int remaining_bytes;		/* the number of bytes left to transfer */
+};
+
+static __inline__ int32_t spi_reg_read(int node, int cs, int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_CTRL);
+	regidx +=  cs * SPI_CHAN_OFFSET;
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void spi_reg_write(int node, int cs, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_CTRL);
+	regidx +=  cs * SPI_CHAN_OFFSET;
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#ifdef XLP_SPI_DEBUG
+static void spi_dump_reg()
+{
+        int i, j = 0;
+	for(i = 0; i < 8; i++) {
+		printk("0x%0x = 0x%8x\n", i, spi_reg_read( 0, j, i));
+	}
+        for(j = 0; j < 4; j++)
+        {
+                printk("dump spi_%d register\n", j);
+                for(i = 0x40; i < 0x47; i++) {
+                        printk("0x%0x = 0x%8x\n", i, spi_reg_read( 0, j, i));
+                }
+        }
+        printk("0x%0x = 0x%8x\n", 0x80, spi_reg_read( 0, 0, 0x80));
+}
+#endif
+
+static void xlp_spi_init(struct spi_xlp *pspi)
+{
+	uint32_t i, val;
+	/* Reset the SPI device */
+
+	val = spi_reg_read(0, 0, XLP_SPI_SYSCTRL);
+	val |= XLP_SPI_SYS_PMEN;
+        spi_reg_write(0, 0, XLP_SPI_SYSCTRL, (XLP_SPI_SYS_RESET << pspi->cs));
+
+	pspi->cs_active = 0;
+	/* set cfg register */
+	for(i = 0; i < 4; i++)
+	{
+		val = spi_reg_read(0, i, XLP_SPI_CONFIG);
+		val |= XLP_SPI_TXMOSI_EN |XLP_SPI_RXMISO_EN;
+		spi_reg_write(0, i, XLP_SPI_CONFIG, val);
+	}
+}
+
+static void spi_xlp_chipselect(struct spi_device *spi, int is_on)
+{
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+
+        if(pspi)
+                pspi->cs =  spi->chip_select;
+
+	if (is_on == BITBANG_CS_INACTIVE) {
+		/* Deselect the slave on the SPI bus */
+		pspi->cs_active = 0;
+	} else if (is_on == BITBANG_CS_ACTIVE) {
+		/* Activate the chip select */
+		pspi->cs_active = 1;
+	}
+}
+
+/* spi_bitbang requires custom setup_transfer() to be defined if there is a
+ * custom txrx_bufs(). We have nothing to setup here as the SPI IP block
+ * supports just 8 bits per word, and SPI clock can't be changed in software.
+ * Check for 8 bits per word. Chip select delay calculations could be
+ * added here as soon as bitbang_work() can be made aware of the delay value.
+ */
+static int spi_xlp_setup_transfer(struct spi_device *spi,
+		struct spi_transfer *t)
+{
+	uint8_t bits_per_word;
+	uint32_t hz;
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+
+	bits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;
+	hz = (t) ? t->speed_hz : spi->max_speed_hz;
+
+	if (hz && pspi->speed_hz > hz) {
+		dev_err(&spi->dev, "%s, unsupported clock rate %uHz\n",
+			__FUNCTION__, hz);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int spi_xlp_setup(struct spi_device *spi)
+{
+	struct spi_bitbang *bitbang;
+	struct spi_xlp *pspi;
+	int32_t val;
+	pspi = spi_master_get_devdata(spi->master);
+	bitbang = &pspi->bitbang;
+
+	/* enable spi pin muxing */
+	spi_reg_write(0, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
+
+	/* set XLP_SPI_FDIV */
+       if ((1000000 < CONFIG_SPI_REFCLK/4) &&
+                (1000000 > CONFIG_SPI_REFCLK/(64*1024))) {
+                spi_reg_write(0, pspi->cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
+        } else {
+                printk("Unsupported SPI frequency %d\n",1000000);
+                goto out;
+        }
+	val = spi_xlp_setup_transfer(spi, NULL);
+	if (val < 0)
+		return val;
+
+	return 0;
+out:
+	return -1;
+
+}
+
+
+static void spi_xlp_fill_txfifo(struct spi_xlp *pspi, uint32_t* len, unsigned char** data)
+{
+
+        uint32_t txfifo_cnt;
+        uint32_t tx_data;
+        txfifo_cnt = spi_reg_read(0, pspi->cs, XLP_SPI_FIFO_WCNT);
+	txfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_POS;
+
+        while ((*len) && (txfifo_cnt < 8))
+        {
+                if (*len <= 1) {
+                        tx_data = (*data)[0];
+                        *len = 0;
+                } else if (*len <= 2) {
+                        tx_data = (((*data)[0] << 8) |
+                                   ((*data)[1] << 0));
+                        *len = 0;
+                } else if (*len <= 3) {
+                        tx_data = (((*data)[0] << 16) |
+                                    ((*data)[1] << 8) |
+                                    ((*data)[2] << 0));
+                        *len = 0;
+                } else {
+                        tx_data = (((*data)[0] << 24) |
+                                   ((*data)[1] << 16) |
+                                   ((*data)[2] << 8)  |
+                                   ((*data)[3] << 0));
+                        *len = *len - 4;
+                }
+
+		spi_reg_write(0, pspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
+                (*data) += 4;
+                txfifo_cnt++;
+        }
+}
+
+static int spi_disable_cont_cmd(unsigned char* opcode)
+{
+	if(opcode == NULL)
+		return 0;
+
+	if(opcode[0] == OPCODE_WREN 	||
+	   opcode[0] == OPCODE_BE_4K	||
+	   opcode[0] == OPCODE_BE_32K	||
+	   opcode[0] == OPCODE_CHIP_ERASE||
+	   opcode[0] == OPCODE_SE	||
+	   opcode[0] == OPCODE_WRDI )
+		return 1;
+	else
+		return 0;
+}
+
+static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, uint32_t xfer_len)
+{
+	uint32_t val;
+        uint32_t rx_data, tx_len, rx_len, rxfifo_cnt /*, txfifo_cnt*/;
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+
+	pspi->ptxbuf = (unsigned char*)t->tx_buf;
+	pspi->prxbuf = (unsigned char*)t->rx_buf;
+	pspi->remaining_bytes = xfer_len;
+
+        if (xfer_len == 0)
+                return -1;
+
+        tx_len = (pspi->ptxbuf == NULL) ? 0 : xfer_len;
+        rx_len = (pspi->prxbuf == NULL) ? 0 : xfer_len;
+
+	val = XLP_SPI_CMD_IDLE;
+        if (tx_len) {
+                spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->ptxbuf);
+		t->len = tx_len;
+		if(xfer_len <= 5){
+			val |= XLP_SPI_CMD_CONT;
+		}
+
+		if(spi_disable_cont_cmd((unsigned char*)t->tx_buf))
+		{
+			val &= ~XLP_SPI_CMD_CONT;
+		}
+        }
+
+	if(pspi->ptxbuf != 0)
+		val |= XLP_SPI_CMD_TX;
+	if(pspi->prxbuf != 0)
+		val |= XLP_SPI_CMD_RX;
+        if(xfer_len)
+		val |= ((xfer_len* 8 -1) << XLP_SPI_XFR_BITCNT_POS);
+
+	spi_reg_write(0, pspi->cs, XLP_SPI_CMD, val);
+
+        while ((tx_len) || (rx_len)) {
+
+                if (rx_len) {
+
+			rxfifo_cnt = spi_reg_read(0, pspi->cs, XLP_SPI_FIFO_WCNT);
+			rxfifo_cnt = (0xF & rxfifo_cnt);
+
+                        while (rxfifo_cnt) {
+
+				rx_data = spi_reg_read(0, pspi->cs, XLP_SPI_RXDATA_FIFO);
+				rxfifo_cnt--;
+
+                                if (rx_len <= 1) {
+                                        pspi->prxbuf[0] = (uint8_t) (rx_data & 0xff);
+                                        rx_len = 0;
+                                } else if (rx_len <= 2) {
+                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len = 0;
+                                } else if (rx_len <= 3) {
+                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->prxbuf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len = 0;
+                                } else {
+                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
+                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        pspi->prxbuf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->prxbuf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len -= 4;
+                                }
+
+                                pspi->prxbuf += 4;
+                        }
+			t->len = rx_len;
+                }
+                if (tx_len) {
+                        spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->ptxbuf);
+			t->len = tx_len;
+                }
+        }
+
+	do {
+		val = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
+        } while( (val & XLP_SPI_XFR_DONE) == 0);
+
+        return 0;
+}
+
+static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+        int ret;
+	uint32_t len = t->len;
+        while (len) {
+
+                if (len > XLP_SPI_MAX_XFER_SIZE) {
+                        ret = spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
+
+                        len = len - XLP_SPI_MAX_XFER_SIZE;
+
+                        if (t->tx_buf)
+                                t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+                        if (t->rx_buf)
+                                t->rx_buf = t->rx_buf  + XLP_SPI_MAX_XFER_SIZE;
+                        if (ret)
+                                return ret;
+
+                } else {
+                        ret = spi_xlp_xfer_block(spi, t, len);
+                        return ret;
+                }
+        }
+        return 0;
+}
+
+
+/* This driver supports single master mode only. Hence Tx FIFO Empty
+ * is the only interrupt we care about.
+ * Receive FIFO Overrun, Transmit FIFO Underrun, Mode Fault, and Slave Mode
+ * Fault are not to happen.
+ */
+static irqreturn_t spi_xlp_irq(int irq, void *dev_id)
+{
+	struct spi_xlp *pspi = dev_id;
+	uint32_t int_stat;
+
+	/* Get the IPIF interrupts, and clear them immediately */
+	int_stat = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
+
+	if (int_stat & XLP_SPI_INT_XFR_DONE) {	/* Transmission completed */
+		uint32_t sr;
+
+		/* A transmit has just completed. Process received data and
+		 * check for more data to transmit. Always inhibit the
+		 * transmitter while the Isr refills the transmit register/FIFO,
+		 * or make sure it is stopped if we're done.
+		 */
+		/* Read out all the data from the Rx FIFO */
+		sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
+		while ((sr & XLP_SPI_INT_RX_THRESH) == 0) {
+			uint32_t data;
+
+			data = spi_reg_read(0, pspi->cs,XLP_SPI_RXDATA_FIFO);
+			if (pspi->prxbuf) {
+				memcpy(pspi->prxbuf, &data, 4);
+			}
+			sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
+		}
+
+		/* See if there is more data to send */
+		if (pspi->remaining_bytes > 0) {
+			spi_xlp_fill_txfifo(pspi, &pspi->remaining_bytes, &pspi->ptxbuf);
+		} else {
+			/* No more data to send.
+			 * Indicate the transfer is completed.
+			 */
+			complete(&pspi->done);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init spi_xlp_probe(struct platform_device *dev)
+{
+	int ret = 0, irt;
+	struct spi_master *master;
+	struct spi_xlp *pspi;
+	struct resource *r;
+
+
+	master = spi_alloc_master(&dev->dev, sizeof(struct spi_xlp));
+
+	if (master == NULL) {
+		return -ENOMEM;
+	}
+
+	dev_set_drvdata(&dev->dev, master);
+
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENODEV;
+		goto put_master;
+	}
+
+	pspi = spi_master_get_devdata(master);
+	pspi->bitbang.master = spi_master_get(master);
+	pspi->bitbang.chipselect = spi_xlp_chipselect;
+	pspi->bitbang.setup_transfer = spi_xlp_setup_transfer;
+	pspi->bitbang.txrx_bufs = spi_xlp_txrx_bufs;
+	pspi->bitbang.master->setup = spi_xlp_setup;
+	init_completion(&pspi->done);
+
+	if (!request_mem_region(r->start,
+			r->end - r->start + 1, "spi-xlp")) {
+		ret = -ENXIO;
+		goto put_master;
+	}
+
+	pspi->regs = ioremap(r->start, r->end - r->start + 1);
+	if (pspi->regs == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+        irt = spi_reg_read(0, 0, 0x3D) & 0xFFFF;
+        pspi->irq = nlm_hal_irt_to_irq(irt);
+	if (pspi->irq < 0) {
+		ret = -ENXIO;
+		goto unmap_io;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = 4;
+
+	/* SPI controller initializations */
+	xlp_spi_init(pspi);
+
+	/* Register for SPI Interrupt */
+	ret = request_irq(pspi->irq, spi_xlp_irq, 0, "spi-xlp", pspi);
+	if (ret != 0)
+		goto unmap_io;
+
+	ret = spi_bitbang_start(&pspi->bitbang);
+	if (ret != 0) {
+		dev_err(&dev->dev, "spi_bitbang_start FAILED\n");
+		goto free_irq;
+	}
+
+
+	return ret;
+
+free_irq:
+	free_irq(pspi->irq, pspi);
+unmap_io:
+	iounmap(pspi->regs);
+put_master:
+	spi_master_put(master);
+	return ret;
+}
+
+static int __devexit spi_xlp_remove(struct platform_device *dev)
+{
+	struct spi_xlp *pspi;
+	struct spi_master *master;
+
+	master = platform_get_drvdata(dev);
+	pspi = spi_master_get_devdata(master);
+
+	spi_bitbang_stop(&pspi->bitbang);
+	free_irq(pspi->irq, pspi);
+	iounmap(pspi->regs);
+	platform_set_drvdata(dev, 0);
+	spi_master_put(pspi->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver spi_xlp_driver = {
+	.probe	= spi_xlp_probe,
+	.remove	= __devexit_p(spi_xlp_remove),
+	.driver = {
+		.name = "spi-xlp",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init spi_xlp_init(void)
+{
+	return platform_driver_register(&spi_xlp_driver);
+}
+module_init(spi_xlp_init);
+
+static void __exit spi_xlp_exit(void)
+{
+	platform_driver_unregister(&spi_xlp_driver);
+}
+module_exit(spi_xlp_exit);
+
+MODULE_AUTHOR("Netlogic Microsystem Inc.");
+MODULE_DESCRIPTION("Netlogic XLP SPI master controller driver");
+MODULE_LICENSE("GPL");
-- 
1.7.10.4

