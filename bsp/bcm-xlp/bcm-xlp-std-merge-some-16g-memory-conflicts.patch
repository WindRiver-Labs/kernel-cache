From 943b72bf7d6cf3e3474f92b03677e2695881b1f8 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Tue, 4 Jun 2013 15:46:39 +0800
Subject: [PATCH 3/7] bcm-xlp-std: merge some 16g memory conflicts

Merge some 16g memory conflicts.

Based on Broadcom SDK 2.3.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/fault.c |   44 ++++++++++++++++++++++++++++++++++++++++++++
 kernel/fork.c        |    4 ++++
 mm/memory.c          |   33 +++++++++++++++++++++++++++++++++
 mm/mmap.c            |    8 ++++++++
 4 files changed, 89 insertions(+)

diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index b11f39e..d68bbb9 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -31,6 +31,50 @@
 DEFINE_TRACE(page_fault_entry);
 DEFINE_TRACE(page_fault_exit);
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+#define ENTER_CRITICAL(flags) local_irq_save(flags)
+#define EXIT_CRITICAL(flags) local_irq_restore(flags)
+
+extern void dump_pgtable(pgd_t *pgd);
+extern void print_pgtable(unsigned long, unsigned long);
+
+extern unsigned long NONWIRED_START, NONWIRED_END;
+
+static void update_kernel_tlb(unsigned long address)
+{
+	unsigned long flags;
+	pgd_t *pgdp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int pid;
+	unsigned long config6_flags;
+
+	ENTER_CRITICAL(flags);
+	disable_pgwalker(config6_flags);
+
+	pid = read_c0_entryhi() & ASID_MASK;
+	address &= (PAGE_MASK << 1);
+	write_c0_entryhi(address | pid);
+	pgdp = pgd_offset_k(address);
+	mtc0_tlbw_hazard();
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
+	{
+		ptep = pte_offset_map(pmdp, address);
+
+		write_c0_entrylo0(pte_to_entrylo(pte_val(*ptep++)));
+		write_c0_entrylo1(pte_to_entrylo(pte_val(*ptep)));
+		mtc0_tlbw_hazard();
+		tlb_write_random();
+	}
+	tlbw_use_hazard();
+//      FLUSH_ITLB_VM(vma);
+	enable_pgwalker(config6_flags);
+	EXIT_CRITICAL(flags);
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff --git a/kernel/fork.c b/kernel/fork.c
index eb91a80..a379643 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -378,7 +378,11 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 				goto fail_nomem;
 			charge = len;
 		}
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+		tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 		tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+#endif
 		if (!tmp)
 			goto fail_nomem;
 		*tmp = *mpnt;
diff --git a/mm/memory.c b/mm/memory.c
index fc4bd89..ef6b0a3 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4180,3 +4180,36 @@ void copy_user_huge_page(struct page *dst, struct page *src,
 	}
 }
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */
+
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+#include <asm/mach-netlogic/mmu.h>
+
+int __init map_kernel_addrspace(unsigned long addr, unsigned long pfn,
+				unsigned long max_pfn)
+{
+	pgd_t *pgd;
+	unsigned long end;
+	unsigned long next;
+	pgprot_t prot;
+	int err;
+
+	printk("(%s): addr = 0x%lx, pfn = 0x%lx, max_pfn = 0x%lx\n", __func__,
+		addr, pfn, max_pfn);
+
+	end = addr + ((max_pfn - pfn) << PAGE_SHIFT);
+
+	prot = __pgprot(KERNEL_PAGE_ATTR);
+	pfn -= addr >> PAGE_SHIFT;
+	pgd = pgd_offset(&init_mm, addr);
+	do {
+		next = pgd_addr_end(addr, end);
+		err = remap_pud_range(&init_mm, pgd, addr, next,
+		pfn + (addr >> PAGE_SHIFT), prot);
+		if (err)
+			break;
+	} while (pgd++, addr = next, addr != end);
+
+	return err;
+}
+#endif /* CONFIG_NLM_16G_MEM_SUPPORT */
+
diff --git a/mm/mmap.c b/mm/mmap.c
index 2a527bd..deb27b3 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1997,7 +1997,11 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 					~(huge_page_mask(hstate_vma(vma)))))
 		return -EINVAL;
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+#endif
 	if (!new)
 		goto out_err;
 
@@ -2265,7 +2269,11 @@ static unsigned long do_brk(unsigned long addr, unsigned long len)
 	/*
 	 * create a vma struct for an anonymous mapping
 	 */
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+#endif
 	if (!vma) {
 		vm_unacct_memory(len >> PAGE_SHIFT);
 		return -ENOMEM;
-- 
1.7.10.4

