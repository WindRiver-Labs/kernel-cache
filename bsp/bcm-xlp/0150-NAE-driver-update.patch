From 76d5e224f66fc8a2e39cbcbca5a89b50c380aeea Mon Sep 17 00:00:00 2001
From: Siva Pochiraju <sivap@netlogicmicro.com>
Date: Tue, 31 Aug 2010 22:50:31 -0700
Subject: [PATCH 150/762] NAE driver update

1. Removed hack for simulator
2. Fixed descriptor bugs
3. Updated buffer management logic

Based on Broadcom SDK 2.3.

Signed-off-by: Siva Pochiraju <sivap@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/xlp_nae/xlp_nae.c |  614 ++++++++---------------------------------
 net/ipv4/ip_input.c           |    1 +
 2 files changed, 115 insertions(+), 500 deletions(-)

diff --git a/drivers/net/xlp_nae/xlp_nae.c b/drivers/net/xlp_nae/xlp_nae.c
index 237ab0b..dfc0a7e 100644
--- a/drivers/net/xlp_nae/xlp_nae.c
+++ b/drivers/net/xlp_nae/xlp_nae.c
@@ -66,8 +66,9 @@
 #define FREE_DEFAULT_SIZE		256
 #define NUM_FREE_DESC			18	
 #define FREE_DESC_POOL_WIDTH		20	
-#define NUM_FREEIN_QUEUE		18	
-#define MIN_FRIN_DESC_THRESHD		10	
+#define NUM_FREEIN_QUEUE		18
+#define MAX_NUM_DESC                    128
+#define MIN_FRIN_DESC_THRESHD		16	
 #define MAX_NET_INF             	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
@@ -91,8 +92,8 @@
         }					\
 	printk("\n");				
 
-#define RUN_ON_SIM_ONLY				1
-#define IP_HEADER_4BYTE_ALIGN_WKAROUND 		1 
+#define RUN_ON_SIM_ONLY				0
+#define IP_HEADER_4BYTE_ALIGN_WKAROUND 		0
 
 unsigned char eth_hw_addr[18][6] = {
 					{0x00,0x01,0x02,0x03,0x04,0x05},
@@ -148,8 +149,6 @@ static void nlm_xlp_mac_timer(unsigned long data);
 static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 
-static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget);
-
 static struct net_device *dev_mac[MAX_GMAC_PORT];
 struct net_device *dev_mac_type[MAX_XLP_NET_TYPES][MAX_GMAC_PORT];
 
@@ -279,11 +278,13 @@ static void mac_refill_frin_desc(unsigned long dev)
 	priv = netdev_priv(ndev);
 	ret = 0;
 	
-	limit = priv->inited ? MIN_FRIN_DESC_THRESHD: MIN_FRIN_DESC_THRESHD*4; 
+	/* TODO ALERT: priv->num_desc access needs to atomic */
+	limit = MAX_NUM_DESC - priv->num_desc;
+	printk("[%s]: sending %d desc\n", __func__, limit);
 
 	for(i=1; i <= limit; i++)
 	{
-		 skb = nlm_xlp_alloc_skb();
+		skb = nlm_xlp_alloc_skb();
 		if(!skb)
 		{
 			printk("[%s] alloc skb failed\n",__FUNCTION__);
@@ -323,104 +324,27 @@ retry_send:
                                 	printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
                         	}
                                 printk("TX message destination flow control credit fail\n");
-                        	msgrng_access_disable(mflags);
-				break;
 			}
-                        else if(ret & MSG_INFLIGHT_MSG_EX)
-                                goto retry_send;
-                        else if(ret & MSG_TXQ_FULL)
+                        else if(ret & MSG_INFLIGHT_MSG_EX) {
+				printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
+			}
+                        else if(ret & MSG_TXQ_FULL) {
                                 printk("TX message Q fulll\n");
-                        dev_kfree_skb(skb);
-                        msgrng_access_disable(mflags);
-                        break;
+			}
+
+			printk("[%s]: retrying...\n", __func__);
+			goto retry_send;
                 }
 
 		msgrng_access_disable(mflags);
 		priv->num_desc += 1;
 	}
+	printk("[%s]: priv->num_desc = %d\n", __func__, priv->num_desc);
 
         return;
 }
 
 /**********************************************************************
- * nlm_xlp_nae_fill_rxfr -  create rx freein buffer for one interface
- * @dev  -  this is per device based function
- * @intf -  interface number
- **********************************************************************/
-static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf)
-{
-        struct dev_data *priv = netdev_priv(dev);
-        struct sk_buff *skb = 0;
-        unsigned long mflags;
-        int i,code;
-        int ret = 1;
-        struct xlp_msg msg = { {0, 0, 0, 0} };
-	uint64_t* idx_ptr;
-
-	for (i = 1; i <= NUM_FREEIN_QUEUE ; i++) {
-		skb = nlm_xlp_alloc_skb();
-		if (!skb) {
-			printk("[%s] alloc skb failed\n",__FUNCTION__);
-			return -ENOMEM;
-		}
-
-		skb->dev = dev_mac[intf];
-
-		/* Send the free Rx desc*/
-		msgrng_access_enable(mflags);
-		mac_put_skb_back_ptr(skb);
-
-		code = 0;
-		idx_ptr = (uint64_t*)((uint64_t)skb->data-20);
-		*idx_ptr = i;
-
-		msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
-		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
-retry_send:
-                if ((ret = nlm_hal_send_msg1( priv->nae_rx_qid,
-                                        code,
-                                        msg.entry[0]))){
-                        if(ret & MSG_DST_FC_FAIL)
-                        {
-                                ret = xlp_read_status1();
-                                if( ret & (1 << 31))
-                                {
-                                        printk("CPU receive queue written when Full\n");
-
-                                }
-                                else if(ret & (1 << 30))
-                                {
-                                        printk("Fmn input credit overflow hardware error\n");
-                                }
-                                else if( ret & (1 << 29))
-                                {
-                                        printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-                                }
-                                printk("TX message destination flow control credit fail\n");
-                                msgrng_access_disable(mflags);
-                                break;
-                        }
-   
-			else if(ret & MSG_INFLIGHT_MSG_EX)
-                                goto retry_send;
-                        else if(ret & MSG_TXQ_FULL)
-                                printk("TX message Q fulll\n");
-                        dev_kfree_skb(skb);
-                        msgrng_access_disable(mflags);
-                        break;
-                }
-
-	
-		
-		msgrng_access_disable(mflags);
-		priv->num_desc += 1;
-        }
-
-        return ret;
-}
-
-
-/**********************************************************************
  * nlm_xlp_nae_init -  xlp_nae device driver init function
  * @dev  -  this is per device based function
  * 
@@ -429,10 +353,9 @@ retry_send:
 static void nlm_xlp_nae_init(void)
 {
 	struct net_device *dev = NULL;
-	struct dev_data *tp;
+	struct dev_data *priv;
 	int i;
 	struct proc_dir_entry *entry;
-        uint64_t* spill_addr;
 	uint32_t val;
 
  	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
@@ -479,27 +402,28 @@ static void nlm_xlp_nae_init(void)
 
 		ether_setup(dev);
 
-        	tp = netdev_priv(dev);
-		tp->dev 	= dev;
+        	priv = netdev_priv(dev);
+		priv->dev 	= dev;
 		dev->netdev_ops = &nlm_xlp_nae_ops;
 		/* set ethtool_ops which is inside xlp_ethtool.c file*/
 		xlp_set_ethtool_ops(dev);
 
-		/*netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);*/
+		/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16);*/
 
 		dev->dev_addr = eth_hw_addr[i];  
-		tp->port	= i;
-		tp->inited	= 0;
-		tp->block 	=(i & 0xff) >> 2;
-		tp->index 	= i & 0x3;
-		tp->nae_tx_qid 	= XLP_NET_TX_VC_BASE+i;
-		tp->nae_rx_qid 	= XLP_NET_RX_VC_BASE+i;
+		priv->port	= i;
+		priv->num_desc  = 0;
+		priv->inited	= 0;
+		priv->block 	=(i & 0xff) >> 2;
+		priv->index 	= i & 0x3;
+		priv->nae_tx_qid 	= XLP_NET_TX_VC_BASE+i;
+		priv->nae_rx_qid 	= XLP_NET_RX_VC_BASE+i;
 		register_netdev(dev);
 
-		dev_mac_type[tp->type][tp->port] = dev;
+		dev_mac_type[priv->type][priv->port] = dev;
 		dev_mac[i] = dev;
 
-		tasklet_init(&mac_refill_task[tp->port],mac_refill_frin_desc,(unsigned long)dev);
+		tasklet_init(&mac_refill_task[priv->port],mac_refill_frin_desc,(unsigned long)dev);
 	}
  
 	entry = create_proc_read_entry("nlm_mac_stats", 0 /* def mode */ ,
@@ -585,17 +509,17 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int port = priv->port;
-	int ret  = 0, i, irq;
+	int ret  = 0, i;
 
-	if(priv->inited)
-		return ret;
+	if (priv->inited) return 0;
 
 	if(register_xlp_msgring_handler( XLP_MSG_HANDLE_NAE_0 , nlm_xlp_nae_msgring_handler, dev))
 	{
 		panic("can't register msgring handler for TX_STN_GMAC0");
 	}
-	nlm_xlp_nae_fill_rxfr(dev,  port );
-	mac_refill_frin_desc(dev);
+
+	mac_refill_frin_desc((unsigned long)dev);
+
 /*
 	irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
 	if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
@@ -639,7 +563,8 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 
 	}
 
-	priv->inited = 1;	
+	priv->inited = 1;
+
 	return 0;
 }
 
@@ -676,7 +601,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	unsigned long mflags = 0;
 	int cpu = 0, ret = 0;
 	struct xlp_msg msg =  { {0, 0, 0, 0} };
-	
+
 	if(!skb)
 	{
 		printk("[%s] skb is NULL\n",__FUNCTION__);
@@ -725,15 +650,15 @@ retry_send:
 				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
 			}
 		}
-                else if(ret & MSG_INFLIGHT_MSG_EX)
-                        goto retry_send;
+                else if(ret & MSG_INFLIGHT_MSG_EX) {
+			printk("[%s]: MSG_INFLIGHT_MSG_EX\n", __func__);
+		}
                 else if(ret & MSG_TXQ_FULL)
 		{
                         printk("TX message Q fulll\n");
-                	priv->stats.tx_errors++;
-        	        msgrng_access_disable(mflags);
-	                return NETDEV_TX_BUSY;
 		}
+		printk("[%s]: retrying...\n", __func__);
+		goto retry_send;
         }
 
 	msgrng_access_disable(mflags);
@@ -743,10 +668,6 @@ retry_send:
     	priv->stats.tx_packets++;
     	priv->cpu_stats[cpu].tx_packets++;
 
-	if(priv->num_desc <= MIN_FRIN_DESC_THRESHD)
-	{ 
-		netif_stop_queue(dev);
-	}
     	return NETDEV_TX_OK;
 }
 
@@ -853,158 +774,6 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 }
 
 /**********************************************************************
- * nlm_xlp_nae_rx -  main receive function
- * @skb  -  skb buffer address
- * @dev  -  this device 
- * 
- **********************************************************************/
-static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
-{
-	unsigned long mflags;
-	struct dev_data * priv = netdev_priv(dev);
-	unsigned int len, size,src_id, code, src;
-	unsigned char* buf;
-	uint64_t addr , vaddr;
-	uint32_t rx_status = 0;
-	struct xlp_msg fr_msg =  {{0, 0, 0, 0}} ;
-	struct xlp_msg rx_msg =  {{0, 0, 0, 0}} ;
-	unsigned short port = 0;
-
-	int cpu_qid = CPU_Q_ID( 0, 0, 0); /* core0 thread0 vc0 */
-	int cpu = 0;
-	
-	priv->cpu_stats[cpu].interrupts++;
-
-    	msgrng_access_enable(mflags);
-
-
-	/* process packet message at cpu vc 1 */
-	if (nlm_hal_recv_msg1(1,
-			  &src_id,
-			  &size,
-			  &code,
-			  &fr_msg.entry[0])){
-		rx_print(fr_msg.entry[0]);
-		printk("port: %d got src_id: %d fr_msg %llx \n\n",priv->port, src_id, fr_msg.entry[0]);
-  		addr = (fr_msg.entry[0]) & 0xffffffffffULL;
-		len = (fr_msg.entry[0] >> 40) & 0x3fff;
-		if(addr && (len==0))
-		{
-			skb = (struct sk_buff *)bus_to_virt(addr);
-			if(skb)
-			{
-				priv->stats.rx_packets++;
-				if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15)
-				{
-					netif_tx_wake_all_queues(dev);
-				}
-				dev_kfree_skb_any(skb);
-			}
-    		}
-		else if(addr == 0) 
-		{
-			/* case tx queue is stopped */
-			netif_tx_wake_all_queues(dev);
-		}
-	}
-	/* process packet message at cpu vc 0 */
-	if ((rx_status = nlm_hal_recv_msg2(cpu_qid,
-                                &src_id,
-                               	&size,
-                               	&code,
-                               	&rx_msg.entry[0],
-                               	&rx_msg.entry[1]))) 
-	{
-               if(rx_status & 0x01)
-                {
-                        priv->stats.rx_errors++;
-                        printk("[%s] RX Load msg failed\n",__FUNCTION__);
-                	msgrng_access_disable(mflags);
-                	return;
-                }
-                else if(rx_status & 0x02)
-                {
-                        priv->stats.rx_errors++;
-                        printk("[%s] RX pop msg request failed\n",__FUNCTION__);
-                	msgrng_access_disable(mflags);
-                	return;
-                }
-                else if(rx_status>>28)
-                {
-                        printk("[%s] RX queue %x empty, no msg\n",__FUNCTION__,(rx_status>>28));
-                        netif_tx_wake_all_queues(dev);
-                	msgrng_access_disable(mflags);
-                        goto fill_desc;
-                }
-	}
-	msgrng_access_disable(mflags);
-
-	addr = (rx_msg.entry[1]) & 0xfffffffff0ULL;
-    	len = (rx_msg.entry[1] >> 40) & 0x3fff;
-    
-	/* update dev and port to be accurate*/
-	dev = dev_mac[port];
-	priv = netdev_priv(dev);
-	if(!len || addr == 0) 
-	{
-		if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
-			tasklet_schedule(&mac_refill_task[priv->port]);
-		return;
-	}
-	vaddr = (uint64_t)bus_to_virt(addr);
-    	buf = (unsigned char *)vaddr;
-
-	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
-	{
-		priv->stats.rx_errors++;
-		priv->stats.rx_dropped++;
-		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
-		return ;
-	}
-	else
-	{
-		len = len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD;
-	
-		if(len >= ETH_MTU_SIZE)
-		{
-			priv->stats.rx_errors++;
-			priv->stats.rx_dropped++;
-			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
-			return ;
-		}	
-       }
-	skb = mac_get_skb_back_ptr(vaddr);
-        if (skb) {
-			src = *((unsigned long *)(skb->data-20));
-			skb_put(skb, len);
-			skb->dev = dev_mac[port];
-			skb->protocol = eth_type_trans(skb, dev_mac[port]);
-			skb->dev->last_rx = jiffies;
-		netif_rx (skb);
-           	priv->stats.rx_bytes += len;
-            	priv->stats.rx_packets++;
-		priv->cpu_stats[cpu].rx_packets++;
-		priv->num_desc -= 1;
-        } 
-	else if(!skb)
-	{
-		priv->stats.rx_errors++;
-		priv->stats.rx_dropped++;
-		printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
-		return;
-	}
-
-fill_desc:
-	if(priv->num_desc < MIN_FRIN_DESC_THRESHD)
-	{
-		tasklet_schedule(&mac_refill_task[priv->port]);
-	}
-
-	return;
-
-}
-
-/**********************************************************************
  * nlm_xlp_nae_int_handler -  interrupt handler
  * @irq     -  irq number
  * @dev_id  -  this device 
@@ -1043,55 +812,50 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 {
         struct net_device *pdev;
         struct dev_data *priv;
-	unsigned int len, port = 0, freedesc, src, cpu, context;
+	unsigned int len, port = 0, cpu, context;
         unsigned char* buf;
         uint64_t addr , vaddr;
 	struct sk_buff* skb;
 
 	cpu = vc >> 4;
-	vc = vc % 4;
+	vc = vc & 0x03;
 
-	if( vc == 1)
+	/* printk("[%s] vc = %d, size = %d\n", __func__, vc, size); */
+	if( vc == 1 && size == 1)
 	{
-		port = msg0 & 0x0f;
-                addr = msg0 & 0xfffffffff0ULL;
-                len = (msg0 >> 40) & 0x3fff;
-#ifdef RUN_ON_SIM_ONLY
-		freedesc = len;
-		len = 0;
-#endif
-                if(addr && (len==0))
-                {
-        		pdev = (struct net_device*)dev_mac[port];
-			if(!pdev)
-				return;
-        		priv = netdev_priv(pdev);
-			if(priv->num_desc > freedesc)
-				priv->num_desc = freedesc;
-
-                        skb = (struct sk_buff *)bus_to_virt(addr);
-                        if(skb)
-                        {
-                                priv->stats.rx_packets++;
-                                if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15){
-                                       netif_tx_wake_all_queues(pdev);
-                                }
-                                dev_kfree_skb_any(skb);
-                        }
-                	if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
-			{
-                        	tasklet_schedule(&mac_refill_task[port]);
-			}
-                }
-                else if(addr == 0)
-                {
-                        /* case tx queue is stopped */
-                        netif_tx_wake_all_queues(pdev);
-                }			
+		/* Transmit Complete */
+                addr = msg0 & 0xffffffffffULL;
+
+		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
+		context = (msg0 >> 40) & 0x3ff;
+		port = context / XLP_SGMII_RCV_CONTEXT_NUM;
+
+        	/* update dev and port to be accurate */
+		if(port < 0 || port >= MAX_GMAC_PORT)
+		{
+			port = 0;
+		}
+
+		pdev = (struct net_device*)dev_mac[port];
+		if(!pdev) {
+			printk("[%s]: [txc] wrong port=%d? pdev = NULL!\n", __func__, port);
+			return;
+		}
+		priv = netdev_priv(pdev);
+
+		skb = (struct sk_buff *)bus_to_virt(addr);
+		if(skb)
+		{
+			dev_kfree_skb_any(skb);
+		}
+		else {
+			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
+		}
 	}
-	else if(vc == 0)
+	else if(vc == 0 && size == 2)
 	{
-        	addr	= msg1 & 0xfffffffff0ULL;
+		/* Rx packet */
+        	addr	= msg1 & 0xffffffffc0ULL;
         	len	= (msg1 >> 40) & 0x3fff;
 		context = msg1 >> 54;
 		
@@ -1104,73 +868,59 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			port = 0;
 		}
         	pdev = (struct net_device*)dev_mac[port];
-		if(!pdev)
+		if(!pdev) {
+			printk("[%s]: [rx] wrong port=%d? pdev = NULL!\n", __func__, port);
 			return;
+		}
         	priv = netdev_priv(pdev);
-	
-		
-        	if(!len || addr == 0)
-        	{
-                	if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
-                        	tasklet_schedule(&mac_refill_task[priv->port]);
-                
-                	return;
-        	}
+			
         	vaddr = (uint64_t)bus_to_virt(addr);
         	buf = (unsigned char *)vaddr;
 		
 #if DUMP_RCV_PKT
 		printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",
-					priv->port,src_id,context,(uint64_t)buf, len, vaddr);
+		       priv->port,src_id,context,(uint64_t)buf, len, vaddr);
 
-		DUMP_PKT(buf , len)
+		//DUMP_PKT(buf , len);
 #endif       
-        	if(len - MAC_CRC_LEN  < 0)
-        	{
-                	priv->stats.rx_errors++;
-                	priv->stats.rx_dropped++;
-                	printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
-                	return ;
-        	}
-        	else
-        	{
-                	len = len  - MAC_CRC_LEN;
-			/* printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n", len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);*/
-                	if(len >= ETH_MTU_SIZE)
-                	{
-                        	priv->stats.rx_errors++;
-                        	priv->stats.rx_dropped++;
-                        	printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
-                        	return ;
-                	}
-       		}
+
+		len = len  - MAC_CRC_LEN;
+
+		if(len > ETH_MTU_SIZE)
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_dropped++;
+			/* printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n",
+			   len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);*/
+			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
+			return ;
+		}
+
         	skb = mac_get_skb_back_ptr(vaddr);
         	if (skb) {
-#if  IP_HEADER_4BYTE_ALIGN_WKAROUND  /* fix for ip header not alligned to 4 bytes boundry problem */ 
-			{
-			struct sk_buff *myskb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
-			unsigned long offset;
-			/*align myskb to 64bytes*/
-			offset = 64 -((unsigned long)myskb->data & 0x3f);
-			skb_reserve(myskb, offset+2);
-			memcpy(myskb->data, skb->data, len);
-			kfree_skb(skb);
-			skb = myskb;
-			}
-#endif
-                        src = *((unsigned long *)(skb->data)-20);
-
                         skb_put(skb, len);
                         skb->dev = dev_mac[port];
                         skb->protocol = eth_type_trans(skb, dev_mac[port]);
                         skb->dev->last_rx = jiffies;
+
+			/* printk("[%s]: sending rx packet up the stack\n", __func__); */
+			/* Pass the packet to Network stack */
                 	netif_rx (skb);
+
+			/* Update Stats */
                 	priv->stats.rx_bytes += len;
                 	priv->stats.rx_packets++;
                 	priv->cpu_stats[cpu].rx_packets++;
+
                 	priv->num_desc -= 1;
+			/* printk("[%s] priv->num_desc = %d\n", __func__, priv->num_desc); */
+			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+			{
+				tasklet_schedule(&mac_refill_task[port]);
+			}
+
 #if DUMP_RCV_PKT
-			DUMP_PKT(skb->data, skb->len)
+			DUMP_PKT(skb->data, skb->len);
 #endif
         	}
         	else if(!skb)
@@ -1181,6 +931,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
                 	return;
         	}
 	}
+	else {
+		printk("[%s]: wrong vc=%d or size=%d?\n", __func__, vc, size);
+	}
 
 	return;
 
@@ -1250,151 +1003,12 @@ static void nlm_xlp_mac_timer(unsigned long data)
         int next_tick = HZ;
 
         spin_lock_irq(&priv->lock);
-#ifdef RUN_ON_SIM_ONLY
-	if( priv->num_desc <= MIN_FRIN_DESC_THRESHD)
-	{
-		mac_refill_frin_desc(dev);
-	}
-#endif
 
         spin_unlock_irq(&priv->lock);
         priv->link_timer.expires = jiffies + next_tick/10;
         add_timer(&priv->link_timer);
 }
 
-/**********************************************************************
- * nlm_xlp_napi_poll - net device napi callback handler
- * @napi - structure for parameter
- * @budget - max number buffer can be processed per call.
- **********************************************************************/
-static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
-{
-	unsigned long mflags;
-	struct net_device * dev = napi->dev;
-	struct dev_data * priv = netdev_priv(dev);
-	unsigned int len, size,src_id, code, src;
-	unsigned char* buf;
-	uint64_t addr , vaddr;
-	uint32_t rx_status = 0;
-	struct xlp_msg fr_msg =  {{0, 0, 0, 0}} ;
-	struct xlp_msg rx_msg =  {{0, 0, 0, 0}} ;
-	struct sk_buff* skb;
-
-	int cpu_qid = CPU_Q_ID( 0, 0, 0); /* core0 thread0 vc0 */
-	int cpu = 0;
-	printk("[%s] \n", __FUNCTION__);
-	
-	priv->cpu_stats[cpu].interrupts++;
-
-    	msgrng_access_enable(mflags);
-
-
-	/* process packet message at cpu vc 1 */
-	if (nlm_hal_recv_msg1(1,
-			  &src_id,
-			  &size,
-			  &code,
-			  &fr_msg.entry[0])){
-		rx_print(fr_msg.entry[0]);
-  		addr = (fr_msg.entry[0]) & 0xffffffffffULL;
-		len = (fr_msg.entry[0] >> 40) & 0x3fff;
-		if(addr && (len==0))
-		{
-			skb = (struct sk_buff *)bus_to_virt(addr);
-			if(skb)
-			{
-				priv->stats.rx_packets++;
-				if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15)
-				{
-					netif_tx_wake_all_queues(dev);
-				}
-				dev_kfree_skb_any(skb);
-			}
-  	  	}
-		else if(addr == 0) 
-		{
-			/* case tx queue is stopped */
-			netif_tx_wake_all_queues(dev);
-		}
-     	}
-	/* process packet message at cpu vc 0 */
-	if (!nlm_hal_recv_msg2(cpu_qid,
-                                  &src_id,
-                               	&size,
-                               	&code,
-                               	&rx_msg.entry[0],
-                               	&rx_msg.entry[1])) 
-	{
-	        rx_status = xlp_read_rx_status();
-		if(rx_status == 0)
-		{
-			netif_tx_wake_all_queues(dev);
-			return;
-		}
-        	if (!((rx_status >> 28) & (1 << cpu_qid))) {
-             		priv->stats.rx_errors++;
-                	return;
-		}
-	}
-	msgrng_access_disable(mflags);
-
-	addr = (rx_msg.entry[1]) & 0xffffffffffULL;
-    	len = (rx_msg.entry[1] >> 40) & 0x3fff;
-	if(!len || addr == 0) 
-	{
-		if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
-			tasklet_schedule(&mac_refill_task[0]);
-		return;
-	}
-	vaddr = (uint64_t)bus_to_virt(addr);
-    	buf = (unsigned char *)vaddr;
-
-	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
-	{
-		priv->stats.rx_errors++;
-		priv->stats.rx_dropped++;
-		printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
-		return ;
-	}
-	else
-	{
-		len = len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD;
-	
-		if(len >=2048)
-		{
-		priv->stats.rx_errors++;
-			priv->stats.rx_dropped++;
-			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
-			return ;
-		}	
-       }
-	skb = mac_get_skb_back_ptr(vaddr);
-        if (skb) {
-			src = *((unsigned long *)(skb->data-20));
-			skb_put(skb, len);
-			skb->dev = dev;
-			skb->protocol = eth_type_trans(skb, dev);
-			skb->dev->last_rx = jiffies;
-			netif_receive_skb(skb);
-			priv->stats.rx_bytes += len;
-			priv->stats.rx_packets++;
-			priv->cpu_stats[cpu].rx_packets++;
-        } 
-	else if(!skb)
-	{
-		priv->stats.rx_errors++;
-		priv->stats.rx_dropped++;
-		printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
-		return;
-	}
-	if( -- priv->num_desc < MIN_FRIN_DESC_THRESHD)
-	{
-		tasklet_schedule(&mac_refill_task[0]);
-	}
-
-	return;
-}
-
 static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
         int result = 0;
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 26eccc5..e9e6713 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -447,6 +447,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 inhdr_error:
 	IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);
 drop:
+	printk("[%s]: dropping packet...\n", __func__);
 	kfree_skb(skb);
 out:
 	return NET_RX_DROP;
-- 
1.7.0.4

