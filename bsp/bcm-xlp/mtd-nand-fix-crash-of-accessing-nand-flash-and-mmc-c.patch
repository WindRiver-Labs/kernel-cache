From 64f7fcd39766e8b4f6366a66c30aa5c46ace2a71 Mon Sep 17 00:00:00 2001
From: "yanjun.zhu" <yanjun.zhu@windriver.com>
Date: Sun, 28 Sep 2014 13:23:04 +0800
Subject: [PATCH] mtd:nand: fix crash of accessing nand flash and mmc card at
 the same time

When xlp nand device is accessed too many times at the same time, the device
sometimes will slowly respond. For example, running erase and status command,
the device sometimes needs a long time to respond. This long time is beyond
the timeout. This will result in kernel crash. Now the timeout is enlarged
to avoid kernel crash.
And spinlock is used to prevent simultaneous access to the same device register.

Signed-off-by: yanjun.zhu <yanjun.zhu@windriver.com>
---
 drivers/mtd/nand/xlp_nand.c |   91 +++++++++++++++++++++++++++++++++++--------
 1 files changed, 75 insertions(+), 16 deletions(-)

diff --git a/drivers/mtd/nand/xlp_nand.c b/drivers/mtd/nand/xlp_nand.c
index 511b57b..7ecfefe 100644
--- a/drivers/mtd/nand/xlp_nand.c
+++ b/drivers/mtd/nand/xlp_nand.c
@@ -112,6 +112,10 @@
 #define BUF_SIZE	(16 * 1024)
 #define NAND_DEV_CS	1
 
+#ifdef CONFIG_FLASH_MMC_LOCK
+extern spinlock_t g_flashmmc_lock;
+#endif
+
 static u64 xlp_dev_dma_mask = DMA_BIT_MASK(64);
 
 /* The oobsize is the area visible to software, and software will read/write
@@ -158,18 +162,35 @@ struct nand_info {
 static inline int xlp_nand_read_reg(struct xlp_nand_data *data,
 		int regidx)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	int ret;
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	ret = readl(data->io_base + (regidx << 2));
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	return ret;
+#else
 	return readl(data->io_base + (regidx << 2));
+#endif
 }
 
 static inline void xlp_nand_write_reg(struct xlp_nand_data *data,
 		int regidx, u32 val)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	writel(val, data->io_base + (regidx << 2));
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#else
+	writel(val, data->io_base + (regidx << 2));
+#endif
 }
 
 static int xlp_dma_wait(struct xlp_nand_data *data, int cs)
 {
-	int timeout = 0xffffff;
+	int timeout = 0x2fffffff;/*modified:old 0xffffff new 0x2fffffff*/
+
 	while ((!(xlp_nand_read_reg(data, NAND_STATUS) & (1 << cs))) ||
 		(!(xlp_nand_read_reg(data, NAND_DMA_CTRL) & 0x01))) {
 
@@ -422,14 +443,11 @@ static void xlp_send_cmd(struct mtd_info *mtd,
 		}
 	}
 
-	if (cmd == NAND_CMD_PAGEPROG || cmd == NAND_CMD_READ0 ||
-			cmd == NAND_CMD_READOOB) {
-		timeout = wait_for_completion_timeout(&data->cmd_complete,
-				msecs_to_jiffies(1000));
-		if (timeout)
-			pr_err("xfer timedout!!!\n");
-	}
-
+	timeout = wait_for_completion_timeout(&data->cmd_complete,
+			msecs_to_jiffies(1000));
+	if (!timeout)
+		pr_debug("xfer timedout!!!,cmd=0x%x last cmd=0x%x\n\n",
+				cmd,state->last_cmd);
 	state->last_cmd = cmd;
 }
 
@@ -444,16 +462,28 @@ static void xlp_nand_cmdfunc(struct mtd_info *mtd,
 	static int column_prog;
 	static int page_prog;
 	int len = 0, status;
+	
+	int timeout;
 	uint32_t val;
 
 	struct xlp_nand_data *data = container_of(mtd,
 					struct xlp_nand_data, mtd);
 
-	init_completion(&data->cmd_complete);
-
 	if (state->cs < 0)
 		return;
 
+	if (command != NAND_RESET_CMD) {
+		/* Check NAND should be in ready state */
+		timeout = 0x0fffffff;
+		do {
+			if((1<<state->cs)& xlp_nand_read_reg(data, NAND_STATUS))
+				break;
+		} while(timeout--);
+	}
+	if (!timeout)
+		pr_debug("NAND CS%d not ready before send command 0x%x,last command is 0x%x\n",
+				command, state->last_cmd);
+
 	switch (command) {
 	/*
 	 * READ0 - read in first  256 bytes
@@ -507,6 +537,24 @@ static void xlp_nand_cmdfunc(struct mtd_info *mtd,
 		/* ERASE2 uses the block and page address from ERASE1 */
 	case NAND_CMD_ERASE2:
 		xlp_nand_write_reg(data, NAND_CMD, NAND_ERASE_BLOCK_CMD);
+		/* Wait for cmmand finish*/
+		timeout = 0xff;
+		do {
+			status= xlp_nand_read_reg(data, NAND_INT_STATUS);
+		} while (!(status&2) && timeout--);
+
+		if (!timeout)
+			pr_debug("NAND_WAIT: failed in waiting command finish.\n");
+
+		/* Wait for operation finish */
+		timeout = 0xffffff;
+		do {
+			status= xlp_nand_read_reg(data, NAND_STATUS);
+		} while (!(status&(1<<state->cs)) && timeout--);
+
+		if (!timeout)
+			pr_debug("NAND_WAIT: failed in waiting device finish.\n");
+
 		state->last_cmd = NAND_ERASE_BLOCK_CMD;
 		status = chip->waitfunc(mtd, chip);
 		if (status & 0x01)
@@ -538,6 +586,13 @@ static void xlp_nand_cmdfunc(struct mtd_info *mtd,
 
 	case NAND_CMD_STATUS:
 		xlp_nand_write_reg(data, NAND_CMD, NAND_READ_STATUS_CMD);
+		timeout = 0xff;
+		do {
+			status= xlp_nand_read_reg(data, NAND_INT_STATUS);
+		} while(!(status&2) && timeout--);
+
+		if (!timeout)
+			pr_err("NAND_WAIT: failed in waiting command finish.\n");
 		state->last_cmd = NAND_READ_STATUS_CMD;
 		break;
 		/* RESET command */
@@ -563,10 +618,10 @@ static void xlp_select_chip(struct mtd_info *mtd, int dev)
 
 	struct xlp_nand_data *data = container_of(mtd,
 			struct xlp_nand_data, mtd);
-
 	if ((dev >= 0) && (dev < 8)) {
 		xlp_nand_write_reg(data, NAND_MEMCTRL, state->cs);
 	}
+
 }
 
 static uint8_t xlp_nand_read_byte(struct mtd_info *mtd)
@@ -664,11 +719,15 @@ static irqreturn_t xlp_nand_interrupt(int irq, void *dev_id)
 	struct xlp_nand_data *data = dev_id;
 	int stat;
 
+	xlp_nand_write_reg(data, NAND_INTMASK, 0x0);
 	stat = xlp_nand_read_reg(data, NAND_INT_STATUS);
+
+	if (stat & 2 == 0) {
+		return IRQ_NONE;
+	}
+
 	/* Clear all interrupts and Disable the interrupt */
 	xlp_nand_write_reg(data, NAND_INT_STATUS, 0x0);
-	xlp_nand_write_reg(data, NAND_INTMASK, 0x0);
-
 	complete(&data->cmd_complete);
 
 	return IRQ_HANDLED;
@@ -729,6 +788,7 @@ static int of_xlp_nand_devices(void __iomem *io_base,
 		return -ENXIO;
 	}
 
+	init_completion(&data->cmd_complete);
 	data->chip.priv	= (void *)info;
 
 	data->mtd.priv	= &data->chip;
@@ -743,8 +803,7 @@ static int of_xlp_nand_devices(void __iomem *io_base,
 	data->chip.write_buf	= xlp_nand_write_buf;
 	data->chip.cmdfunc	= xlp_nand_cmdfunc;
 	data->chip.select_chip	= xlp_select_chip;
-	data->chip.options	= NAND_SKIP_BBTSCAN;
-
+	
 	xlp_nand_write_reg(data, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG |
 			NAND_CTRL_GINTR_EN);
 	val = (NAND_TIME_SEQ0_TWHR(7) |
-- 
1.7.5.4

