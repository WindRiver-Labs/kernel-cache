From 8cd964bec9c5f6b4d2f41a926a767167081c6819 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Fri, 24 Sep 2010 14:38:51 -0700
Subject: [PATCH 186/762] Use physical address map for determining uncached acccesses on /dev/mem

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/setup.c |   76 +++++++++++++++++++++++++++++-----------
 drivers/char/mem.c             |    3 --
 2 files changed, 55 insertions(+), 24 deletions(-)

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index e19e852..692c475 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -77,10 +77,6 @@
 
 #define BOOT_LOADER_REGION_SZ 			0x04000000
 #define LOADER_KSEG_END 			0x10000000
-/* used by the default memory map
- */
-#define DEF_PHYMEM_START_ADDR 			0x100000
-#define DEF_PHYMEM_SIZE 			0x0ff00000
 
 static unsigned int xlp_uart_portid = 0;
 unsigned long nlm_common_ebase = 0x0;
@@ -134,16 +130,65 @@ unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
 
 extern struct node_mask smp_node;
 
+struct boot_mem_map boot_physaddr_info = {
+	.nr_map = 5,
+	.map = {
+		[0] = {
+			.addr = 0ULL,
+			.size = 0x14000000ULL,
+			.type = BOOT_MEM_RAM
+		},
+		[1] = {
+			.addr = 0x14000000ULL,
+			.size = 0x09000000ULL,
+			.type = BOOT_MEM_RESERVED
+		},
+		[2] = {
+			.addr = 0x1D000000ULL,
+			.size = 0xA3000000ULL,
+			.type = BOOT_MEM_RAM
+		},
+		[3] = {
+			.addr = 0xC0000000ULL,
+			.size = 0x20000000ULL,
+			.type = BOOT_MEM_RESERVED
+		},
+		[4] = {
+			.addr = 0xE0000000ULL,
+			.size = 0x20000000ULL,
+			.type = BOOT_MEM_RAM
+		},
+	}
+};
 int nlm_common_get_pgprot(unsigned long address)
 {
+	int i = 0;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		__u64 start = 0, end = 0;
+		long type = 0;
+
+		start = boot_physaddr_info.map[i].addr;
+		end = start + boot_physaddr_info.map[i].size;
+		type = boot_physaddr_info.map[i].type;
+
+		if (address >= start && address < end) {
+			/* Uncached */
+			if (type == BOOT_MEM_RESERVED) return 1;
+			/* cached */
+			if (type == BOOT_MEM_RAM) return 0;
+		}
+	}
 
+	/* uncached */
 	return 1;
 }
-struct boot_mem_map boot_physaddr_info;
+
 int valid_mmap_nlm_common_addr_range(unsigned long pfn)
 {
 	int i;
 	__u64 end=0;
+
 	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
 		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
 		end = end >> PAGE_SHIFT;
@@ -417,27 +462,16 @@ static int fdt_process(void)
 
 		for (i=0; i<entries; i+=2) {
 			unsigned long long addr, size;
-			addr = fdt32_to_cpu(regs[i]) >> 20;
-			size = fdt32_to_cpu(regs[i + 1]) >> 20;
-			sprintf(domstr, " mem=%lldm@%lldm ", size, addr);
+
+			addr = fdt32_to_cpu(regs[i]);
+			size = fdt32_to_cpu(regs[i + 1]);
+
+			sprintf(domstr, " mem=%lldm@%lldm ", (size >> 20), (addr >> 20));
 			strcat(arcs_cmdline, domstr);
 			memset((void *)&domstr, '\0', sizeof(domstr));
-
-			/* Register these memory regions
-			 */
-			if (!use_default_phymem)
-				prom_add_memory(addr, size);
 		}
 	}
 
-	if (use_default_phymem) {
-		printk("Using Default Physical Mem Map\n");
-		add_memory_region (
-				DEF_PHYMEM_START_ADDR,
-				DEF_PHYMEM_SIZE-512, 	/* CHECK! */
-				BOOT_MEM_RAM);
-	}
-
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
 	/* extract CPU online mask for
diff --git a/drivers/char/mem.c b/drivers/char/mem.c
index 665275d..c4bbcaa 100644
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -87,9 +87,6 @@ void __weak unxlate_dev_mem_ptr(unsigned long phys, void *addr)
 {
 }
 
-extern int nlm_common_get_pgprot(unsigned long address);
-extern int valid_mmap_nlm_common_addr_range(unsigned long pfn);
-
 /*
  * This funcion reads the *physical* memory. The f_pos points directly to the
  * memory location.
-- 
1.7.0.4

