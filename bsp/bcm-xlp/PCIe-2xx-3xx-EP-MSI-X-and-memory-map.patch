From 6b0fdecc0862749538ca362e7d835ff8d31127b6 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Wed, 16 Jan 2013 11:05:13 -0800
Subject: [PATCH 663/761] PCIe : 2xx/3xx EP MSI-X and memory map

2xx/3xx has a different memory mapping and MSI-X scheme as implemented by
this commmit.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/nlm_dma.h |    1 +
 arch/mips/include/asm/netlogic/xlp_irq.h |    2 ++
 arch/mips/netlogic/common/pci_hal.c      |    3 +-
 drivers/char/nlm_xlp_dma.c               |   56 +++++++++++++++++++++++++++++-
 4 files changed, 60 insertions(+), 2 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/nlm_dma.h b/arch/mips/include/asm/netlogic/nlm_dma.h
index 133592f..b9e66c6 100644
--- a/arch/mips/include/asm/netlogic/nlm_dma.h
+++ b/arch/mips/include/asm/netlogic/nlm_dma.h
@@ -41,6 +41,7 @@ extern struct proc_dir_entry *dma_procfs_dir;
 int xlp_init_dma(void);
 
 #define NLM_XLP_PCIE_SHARED_MEMSIZE		(32 * 1024 * 1024)
+#define NLM_XLP2XX_PCIE_SHARED_MEMSIZE		(2 * 32 * 1024 * 1024)
 #define DEFAULT_NLMXLP_IO_BASE DEFAULT_NETLOGIC_IO_BASE
 
 #define DPRINTK(level,fmt,args...)\
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 3bef942..aa5f782 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -57,6 +57,8 @@ int xlp_intx_disable(u8 node, int fn);
 #if !defined CONFIG_XLP_REPLACE_R4K_TIMER
 void nlm_hal_pic_update_control(u64);
 #endif
+void __nlh_pci_w32o(u8 nid, u8 fn, u64 offset, u32 val);
+u64 __nlh_pci_r32o(u8 nid, u8 fn, u64 offset);
 
 #define nlh_pic_r64r(nid, reg)	__nlh_pic_r64o(nid, (reg << 2))
 #define nlh_pic_w64r(nid, reg, val) __nlh_pic_w64o(nid, (reg << 2), val)
diff --git a/arch/mips/netlogic/common/pci_hal.c b/arch/mips/netlogic/common/pci_hal.c
index dc7859e..cae8bd6 100644
--- a/arch/mips/netlogic/common/pci_hal.c
+++ b/arch/mips/netlogic/common/pci_hal.c
@@ -22,12 +22,13 @@ u64 __nlh_pci_r32o(u8 nid, u8 fn, u64 offset)
 {
 	return (nlh_read_cfg_reg32(xlp_pci_base[nid][fn] + offset));
 }
+EXPORT_SYMBOL(__nlh_pci_r32o);
 
 void __nlh_pci_w32o(u8 nid, u8 fn, u64 offset, u32 val)
 {
 	nlh_write_cfg_reg32(xlp_pci_base[nid][fn] + offset, val);
 }
-
+EXPORT_SYMBOL(__nlh_pci_w32o);
 
 /* The following is the table describing current interrupt modes of
  * XLP controllers. When an external switch is present, different devices
diff --git a/drivers/char/nlm_xlp_dma.c b/drivers/char/nlm_xlp_dma.c
index 51b5a7a..d0a6a10 100644
--- a/drivers/char/nlm_xlp_dma.c
+++ b/drivers/char/nlm_xlp_dma.c
@@ -545,6 +545,45 @@ static int is_xlp_rc(int node, int fn)
 	return (mode & (1 << fn));
 }
 
+u64 setup_pcie_shared_memxlp2xx(u64 *len)
+{
+	u64 phys, bar, barH, hostphys;
+	u32 r, is64 = 0;
+
+	if (pcie_shared_membase == 0) {
+		pcie_shared_membase = (u64) __get_free_pages(GFP_KERNEL, get_order(NLM_XLP2XX_PCIE_SHARED_MEMSIZE));/* Reserve 64 MB */
+		if (pcie_shared_membase == 0) {
+			printk(KERN_WARNING "Alloc failed\n");
+			return -ENOMEM;
+		}
+		phys = virt_to_phys((const volatile void *)pcie_shared_membase);
+		if (phys == 0) {
+			free_pages(pcie_shared_membase, get_order(NLM_XLP_PCIE_SHARED_MEMSIZE));
+			printk(KERN_WARNING "virt_to_phys failed\n");
+			return -ENOMEM;
+		}
+		bar = nlh_pci_r32r(0, 0, 0x4);
+		is64 = ((bar & 0x6) == 0x4) ? 1 : 0;
+		hostphys = (bar >> 8);
+		if (is64) {
+			barH = nlh_pci_r32r(0, 0, 0x5);
+			hostphys |= ((barH & 0xff) << 24);
+		}
+		nlh_pci_w32r(0, 0, 0x251, (phys >> 8));
+		nlh_pci_w32r(0, 0, 0x26F, is64 ? (0xffc00000) : 0xfc0000);
+		nlh_pci_w32r(0, 0, 0x271, 0);
+		nlh_pci_w32r(0, 0, 0x272, 0);
+		nlh_pci_w32r(0, 0, 0x272, hostphys);
+		*len = NLM_XLP2XX_PCIE_SHARED_MEMSIZE;
+		r = nlh_pci_r32r(0, 0, 0x240);
+		r |= 0x02000000;
+		nlh_pci_w32r(0, 0, 0x240, r);
+	}
+	return pcie_shared_membase;
+}
+
+
+
 static int nlm_init_dma(void)
 {
 	int i;
@@ -589,6 +628,9 @@ u64 setup_pcie_shared_memspace(u64 * len)
 	u64 xlp_pci_base = XLP_BDF_BASE(0,1,0); /* fn = 0 for EP */
 	u32 r;
 
+	if (is_nlm_xlp2xx()) {
+		return setup_pcie_shared_memxlp2xx(len);
+	}
 	if (pcie_shared_membase == 0) {
 		pcie_shared_membase = (u64) __get_free_pages(GFP_KERNEL, get_order(NLM_XLP_PCIE_SHARED_MEMSIZE));/* Reserve 32 MB */
 		if (pcie_shared_membase == 0) {
@@ -620,6 +662,7 @@ u64 setup_pcie_shared_memspace(u64 * len)
 
 EXPORT_SYMBOL(setup_pcie_shared_memspace);
 
+
 #ifdef TEST_DMA
 void xlp_dma_test(void)
 {
@@ -677,6 +720,16 @@ static inline void raise_intx(int ignore)
 	nlm_hal_write_32bit_reg(xlp_pci_base, 0x240, r);
 }
 
+static inline void raise_msix_xlp2xx(int vec)
+{
+	u64 xlp_pci_base = XLP_BDF_BASE(0,1,0); /* fn = 0 for EP */
+	u32 r;
+
+	r = ((1 << 8) | vec);
+	nlm_hal_write_32bit_reg(xlp_pci_base, 0x25c, r);
+}
+
+
 static inline void raise_msix(int vec)
 {
 	u64 xlp_pci_base = XLP_BDF_BASE(0,1,0); /* fn = 0 for EP */
@@ -710,7 +763,8 @@ void raise_host_interrupt(int vec)
 	msix = (msix >> 31) & 1;
 	/* We don't care if fmask == 1 or not */
 	if (msix != 0) {
-		raise_msix(vec);
+		if (is_nlm_xlp2xx()) raise_msix_xlp2xx(vec);
+		else raise_msix(vec);
 		return;
 	}
 
-- 
1.7.10.4

