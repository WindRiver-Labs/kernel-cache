From 779f6ac1a722c2be738ca31c88679fca91ccf321 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Wed, 6 Oct 2010 15:57:27 -0700
Subject: [PATCH 195/762] Added a minimal XLP cache error handler

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/iomap.h     |    2 +-
 arch/mips/include/asm/netlogic/mips-exts.h |   16 ++++
 arch/mips/mm/cerr-phoenix.c                |  118 +++++++++++++++++----------
 arch/mips/mm/cex-gen.S                     |   20 ++----
 4 files changed, 97 insertions(+), 59 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
index 6fcde45..8cb2610 100644
--- a/arch/mips/include/asm/netlogic/iomap.h
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -26,7 +26,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _ASM_RFI_IO_H
 #define _ASM_RFI_IO_H
 
-#if !defined(CONFIG_NLM_XLP)
+#if defined(CONFIG_NLM_XLR)
 #define DEFAULT_NETLOGIC_IO_BASE 0xffffffffbef00000ULL
 #define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x01000
 #define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x02000
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index e214350..ca30429 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -301,7 +301,23 @@ static __inline__ int hard_smp_processor_id(void)
 #define CPU_BLOCKID_MMU      4
 #define CPU_BLOCKID_PRF      5
 
+#ifdef CONFIG_NLM_XLR
 #define LSU_CERRLOG_REGID    9
+#else
+#define CPU_BLOCKID_SCU      8
+
+#define ICU_CERRLOG0_REGID   0x10
+#define ICU_CERRLOG1_REGID   0x11
+#define ICU_CERRLOG2_REGID   0x12
+
+#define LSU_CERRLOG0_REGID   0x08
+#define LSU_CERRLOG1_REGID   0x09
+
+#define SCU_CERRLOG0_REGID   0x10
+#define SCU_CERRLOG1_REGID   0x11
+#define SCU_CERRLOG2_REGID   0x12
+
+#endif
 
 static __inline__ unsigned int read_32bit_nlm_ctrl_reg(int block, int reg)
 {
diff --git a/arch/mips/mm/cerr-phoenix.c b/arch/mips/mm/cerr-phoenix.c
index 3ca7ecb..a73233a 100644
--- a/arch/mips/mm/cerr-phoenix.c
+++ b/arch/mips/mm/cerr-phoenix.c
@@ -27,10 +27,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <asm/netlogic/iomap.h>
 
-unsigned char xlr_cerr_stack[8192];
-
-/* generic MIPS cache error handler */
-extern void cache_parity_error(void);
+unsigned char nlm_cerr_stack[8192];
+volatile int nlm_cerr_lock;
 
 static __inline__ void cerr_cpu_halt(void)
 {
@@ -52,7 +50,7 @@ static __inline__ void cerr_cpu_halt(void)
 #define UART_MCR 4
 #define UART_LSR 5
 #define UART_MSR 6
-static void xlr_cerr_outbyte(char ch)
+static void cerr_outbyte(char ch)
 {
 	volatile uint32_t *mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
 	int lsr;
@@ -68,9 +66,8 @@ static void xlr_cerr_outbyte(char ch)
 	}
 }
 
-volatile int xlr_cerr_lock;
-static char cerr_printk_buf[1024];
-static void xlr_cerr_printk(const char *fmt, ...)
+static char cerr_printk_buf[2048];
+static void cerr_printk(const char *fmt, ...)
 {
 	va_list args;
 	int len;
@@ -79,17 +76,21 @@ static void xlr_cerr_printk(const char *fmt, ...)
 	va_start(args, fmt);
 	len = vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
 	va_end(args);
-	  
-	for (i=0; i<=len; i++) {
+
+	for (i = 0; i <= len; i++) {
+
 		if (cerr_printk_buf[i] == 0)
 			continue;
+
 		if (cerr_printk_buf[i] == '\n')
-			xlr_cerr_outbyte('\r');
-		xlr_cerr_outbyte(cerr_printk_buf[i]);
+			cerr_outbyte('\r');
+
+		cerr_outbyte(cerr_printk_buf[i]);
 	}
 
 }
 
+#ifdef CONFIG_NLM_XLR
 
 static char *bridge_aerr_intr_devstat[] = {
 	[0] = "cpu 0",
@@ -100,7 +101,7 @@ static char *bridge_aerr_intr_devstat[] = {
 	[5] = "cpu 5",
 	[6] = "cpu 6",
 	[7] = "cpu 7",
-	
+
 	[8] = "L2",
 	[9] = "XGS 0",
 	[10] = "XGS 1",
@@ -110,52 +111,81 @@ static char *bridge_aerr_intr_devstat[] = {
 	[14] = "HT",
 	[15] = "DMA",
 };
-/* On Phoenix, errors reported by bridge (like misconfigured BARS etc) are also
- * reported as cache errors. Need to check if it is really a cache error or a "bus error"
- * and take action appropriately.
- * For now, treat it as a cache error 
- */
-asmlinkage void nlm_cache_error(struct pt_regs *regs)
+
+static void print_cerr_info(void)
 {
-	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
 	__u64 cerr_cpu_log = 0;
+	int i = 0;
+	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
 	__u32 tmp = 0;
-	int i=0;
-
-	/* TODO: cache error on xlr could also be because of access to a physical address region that is
-	 * not mapped to any device in the bridge
-	 * We should detect that condition by reading the bridge registers and if a process is doing
-	 * the access, the process should be SEGFAULTED. If kernel is doing it, all bets are off, so
-	 * we should dump the stack and die
-	 * For Now, just halt the cpu
-	 */
-	local_irq_disable();
-
-	/* let the first cpu in */
-	while (xlr_cerr_lock) ;
-	xlr_cerr_lock = 1;
-
-	xlr_cerr_printk("*********************************************\n");
-	xlr_cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
-	xlr_cerr_printk("*********************************************\n");
 
-	xlr_cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
+	cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
 			( ((__u64)netlogic_read_reg(mmio, 39)<<5) | ((__u64)netlogic_read_reg(mmio, 40)<<37) ),
 			netlogic_read_reg(mmio, 41));
-	xlr_cerr_printk("Bridge: The devices reporting AERR are:\n");
+
+	cerr_printk("Bridge: The devices reporting AERR are:\n");
 	tmp = netlogic_read_reg(mmio, 41);
-	for(i=0;i<16;i++) {
+	for(i = 0; i < 16; i++) {
 		if (tmp & (1<<i)) xlr_cerr_printk("\t%s\n", bridge_aerr_intr_devstat[i]);
 	}
 
 	cerr_cpu_log = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
-	xlr_cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
+	cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
 			cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
+}
+
+#else
+
+static void print_cerr_info(void)
+{
+	nlm_reg_t *nbu_mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+
+	uint64_t icu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
+	uint64_t icu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
+	uint64_t icu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
+	uint64_t lsu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
+	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
+	uint64_t scu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
+	uint64_t scu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
+	uint64_t scu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
+
+	cerr_printk("CPU: (XLP specific) ICU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n"
+		    "                    LSU log0 = 0x%016llx, log1 = 0x%016llx\n"
+		    "                    SCU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n",
+		    icu_log0, icu_log1, icu_log2,
+		    lsu_log0, lsu_log1,
+		    scu_log0, scu_log1, scu_log2);
+
+	cerr_printk("NBU: Bar Aerr reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
+		    netlogic_read_reg(nbu_mmio, 162), netlogic_read_reg(nbu_mmio, 163),
+		    netlogic_read_reg(nbu_mmio, 164) );
+}
+
+#endif
+
+/* On XLR/XLP, errors reported by bridge (like misconfigured BARS etc) are also
+ * reported as cache errors. Need to check if it is really a cache error or a "bus error"
+ * and take action appropriately.
+ * For now, treat it as a cache error
+ */
+asmlinkage void nlm_cache_error(void)
+{
+	local_irq_disable();
+
+	/* let the first cpu in */
+	while (nlm_cerr_lock) ;
+	nlm_cerr_lock = 1;
+
+	cerr_printk("*********************************************\n");
+	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
+	cerr_printk("*********************************************\n");
+
+	print_cerr_info();
 
-	xlr_cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
+	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
 			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
 
-	xlr_cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
 
 	cerr_cpu_halt();
 }
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index ef88f02..2e4274b 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -48,25 +48,17 @@ the header of the original work apply to this derived work.
 
 	/* If some other cpu is already in the handler
 	 * just wait... */
-	PTR_LA	k0, xlr_cerr_lock
+	PTR_LA	k0, nlm_cerr_lock
 1:	lw	k1, 0(k0)
 	bnez	k1, 1b
 	nop
-	
+
 	/* switch stack to a new one */
-	PTR_LA	sp, xlr_cerr_stack
-	li	k1, 8192 - 64
+	PTR_LA		sp, nlm_cerr_stack
+	li		k1, 8192 - 64
 	PTR_ADDU	sp, sp, k1
-	
-	/* set up first argument - pt_regs */
-	move	a0, sp
-	/* read the cache error log reg in the cpu */
-	li	k1, 0x309
-	/*mfcr	k0, k1*/
-	PTR	0x737a0018
-	move	a1, k0
-	
-    j nlm_cache_error
+
+	jal	nlm_cache_error
 	nop
 	/* should never get here */
 
-- 
1.7.0.4

