From 123a79b28469cd094002501d72c53ec5f4c3f0b1 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 25 Apr 2013 17:10:48 +0800
Subject: [PATCH 705/762] SPINAND: Added nand controller layer support

Added framework in the chip driver for using linux nand
controller layer functions

Based on Broadcom SDK 2.3.

Signed-off-by: Divya Sakthidharan <divyas@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/devices/Kconfig       |   28 +-
 drivers/mtd/devices/Makefile      |    2 +-
 drivers/mtd/devices/mt29f_spi.c   |  785 -------------------------------------
 drivers/mtd/devices/spinand_lld.c |  415 ++++++++++++++++----
 drivers/mtd/nand/nand_ids.c       |    3 +
 include/linux/mtd/spinand.h       |   51 +--
 6 files changed, 384 insertions(+), 900 deletions(-)
 delete mode 100644 drivers/mtd/devices/mt29f_spi.c

diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index ec68073..83fbd3a 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -120,12 +120,28 @@ config MTD_SST25L
 	  Set up your spi devices with the right board-specific platform data,
 	  if you want to specify device partitioning.
 
-config MTD_MT29F
-	tristate "Support Micron MT29F SPI Nand chips"
-	depends on SPI_MASTER
-	help
-	  This enables access to Micron MT29F family SPI flash chips, used
-	  for program and data storage.
+config MTD_SPINAND
+        tristate "SPINAND Device Support"
+        depends on MTD
+        help
+          This enables support for accessing Micron SPI NAND flash
+          devices.
+
+if MTD_SPINAND
+
+config MTD_SPINAND_ONDIEECC
+        bool "Use SPINAND internal ECC"
+        help
+         Internel ECC
+
+config MTD_SPINAND_SWECC
+        bool "Use software ECC"
+        depends on MTD_NAND
+        help
+         software ECC
+
+endif
+
 
 config MTD_SLRAM
 	tristate "Uncached system RAM"
diff --git a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
index bcf1950..2b68e8a 100644
--- a/drivers/mtd/devices/Makefile
+++ b/drivers/mtd/devices/Makefile
@@ -17,8 +17,8 @@ obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
-obj-$(CONFIG_MTD_MT29F)		+= mt29f_spi.o
 obj-$(CONFIG_MTD_SPEAR_SMI)	+= spear_smi.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
+obj-$(CONFIG_MTD_SPINAND)       += spinand_lld.o
 
 CFLAGS_docg3.o			+= -I$(src)
diff --git a/drivers/mtd/devices/mt29f_spi.c b/drivers/mtd/devices/mt29f_spi.c
deleted file mode 100644
index 12dfcb1..0000000
--- a/drivers/mtd/devices/mt29f_spi.c
+++ /dev/null
@@ -1,785 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/mutex.h>
-#include <linux/sched.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
-
-
-#define SPI_NAND_MT29F_BLOCK_ERASE	0xD8    /* Block Erase */
-#define SPI_NAND_MT29F_GET_FEATURE	0x0F    /* Get Feature */
-#define SPI_NAND_MT29F_PAGE_READ	0x13    /* Array Read */
-#define SPI_NAND_MT29F_PROG_EXE		0x10    /* Page Execute */
-#define SPI_NAND_MT29F_PROG_LOAD	0x02    /* Program Load*/
-#define SPI_NAND_MT29F_PROG_RAND_LOAD	0x84    /* Program load random data */
-#define SPI_NAND_MT29F_RD_ARRAY		0x0B    /* Read from cache Data Bytes */
-#define SPI_NAND_MT29F_RD_CACHE		0x03	/* Read From Cache*/
-#define SPI_NAND_MT29F_READID		0x9F	/* Read ID */
-#define SPI_NAND_MT29F_RESET       	0xFF    /* Reset */
-#define SPI_NAND_MT29F_SET_FEATURE	0x1F    /* Get Feature */
-
-#define SPI_NAND_MT29F_WREN        	0x06    /* Write Enable */
-#define SPI_NAND_MT29F_WRDI        	0x04    /* Write Disable */
-#define SPI_NAND_MT29F_BLOCK_LOCK	0xA0
-
-#define SPI_NAND_MT29F_OTP      	0xB0
-#define SPI_NAND_MT29F_OTP_EN      	0x40
-#define SPI_NAND_MT29F_OTP_PROT      	0x80
-#define SPI_NAND_MT29F_OTP_ECC      	0x10
-
-#define SPI_NAND_MT29F_STATUS      	0xC0
-#define SPI_NAND_MT29F_OIP      	0x01
-#define SPI_NAND_MT29F_WEL      	0x02
-#define SPI_NAND_MT29F_ST_EFAIL      	0x04
-#define SPI_NAND_MT29F_ST_PFAIL      	0x08
-#define SPI_NAND_MT29F_ST_ECC_S0      	0x10
-#define SPI_NAND_MT29F_ST_ECC_S1      	0x20
-
-#define MT29F_REG_BLOCK_LOCK		0xA0
-#define MT29F_REG_OTP			0xB0
-#define MT29F_REG_STATUS		0xC0
-
-#define MICRON_ID_MT29F1G01ZAC		0x12
-#define MICRON_ID_MT29F1G01ZAC1		0x11
-#define MICRON_SR_WIP         		(1 << 0)  /* Write-in-Progress */
-#define SPINAND_TIMEOUT			0x7fffffff
-
-#define ROW_SHIFT			12
-#define COL_MASK			0x0F
-/* Define max times to check status register before we give up. */
-#define	MAX_WAIT_TIME			40000
-
-struct mt29f_snand_params {
-        uint8_t      idcode1;
-        uint16_t page_size;
-        uint16_t pages_per_block;
-        uint16_t nr_blocks;
-        const char *name;
-};
-
-static const struct mt29f_snand_params mt29f_snand_table[] = {
-        {
-                .idcode1                 = MICRON_ID_MT29F1G01ZAC,
-                .page_size               = 2048,
-                .pages_per_block	 = 64,
-                .nr_blocks               = 1024,
-                .name                    = "MT29F1G01ZAC",
-        },
-        {
-                .idcode1                 = MICRON_ID_MT29F1G01ZAC1,
-                .page_size               = 2048,
-                .pages_per_block	 = 64,
-                .nr_blocks               = 1024,
-                .name                    = "MT29F1G01ZAC",
-        },
-};
-/****************************************************************************/
-
-struct mt29f {
-	struct spi_device	*spi;
-	struct mutex		lock;
-	struct mtd_info		mtd;
-	unsigned		partitioned:1;
-	uint8_t			erase_opcode;
-	uint8_t			command[4];
-	struct mt29f_snand_params  params;
-};
-
-static struct mtd_partition xlp_mt29f_part[] = {
-        {
-                .name = "SPI NAND FLASH",
-                .offset = 0x00000000,
-                .size = MTDPART_SIZ_FULL,
-        }
-};
-
-static inline struct mt29f *mtd_to_mt29f(struct mtd_info *mtd)
-{
-	return container_of(mtd, struct mt29f, mtd);
-}
-
-static int8_t get_feature(struct mt29f *snand, uint8_t reg)
-{
-	uint8_t cmd[4];
-	int8_t val, retval;
-
-	if(!snand)
-		return -1;
-
-	cmd[0] = SPI_NAND_MT29F_GET_FEATURE;
-	cmd[1] = reg;
-
-	retval = spi_write_then_read(snand->spi, cmd, 2, &val, 1);
-	if (retval < 0) {
-		printk("[%s] error %d reading status\n", __func__, (int)retval);
-		return retval;
-	}
-	return val;
-}
-
-static int set_feature(struct mt29f *snand, uint8_t reg, uint8_t val) __attribute__((unused));
-static int set_feature(struct mt29f *snand, uint8_t reg, uint8_t val)
-{
-	uint8_t cmd[4];
-	if(!snand)
-		return -1;
-
-	cmd[0] = SPI_NAND_MT29F_SET_FEATURE;
-	cmd[1] = reg;
-	cmd[2] = val;
-
-	return spi_write(snand->spi, cmd, 3);
-}
-
-static inline int write_enable(struct mt29f *snand)
-{
-	uint8_t cmd[4];
-	if(!snand)
-		return -1;
-
-	cmd[0]= SPI_NAND_MT29F_WREN;
-	return spi_write(snand->spi, cmd, 1);
-}
-
-static inline int write_disable(struct mt29f *snand)
-{
-	uint8_t cmd[4];
-	if(!snand)
-		return -1;
-
-	cmd[0]= SPI_NAND_MT29F_WRDI;
-	return spi_write(snand->spi, cmd, 1);
-}
-
-static void mt29f_blk_unlock(struct mt29f *snand, uint8_t lockbits) __attribute__((unused));
-static void mt29f_blk_unlock(struct mt29f *snand, uint8_t lockbits)
-{
-	uint8_t val;
-
-	mutex_lock(&snand->lock);
-	val = get_feature(snand, MT29F_REG_BLOCK_LOCK);
-	val &= ~( 0x7 << 3);
-	val = val | lockbits;
-	set_feature(snand, MT29F_REG_BLOCK_LOCK, val);
-	mutex_unlock(&snand->lock);
-}
-
-static int wait_oip_clear(struct mt29f *snand, unsigned long t)
-{
-	int i, ret;
-
-        i = 0;
-        do {
-                ret = get_feature(snand, MT29F_REG_STATUS);
-                if( i++ == t) {
-                        printk("mt29f_page_read timeout\n");
-                        return ret;
-                }
-        } while((ret & SPI_NAND_MT29F_OIP) != 0x0);
-
-	return 0;
-
-}
-
-static int wait_write_latch(struct mt29f *snand, unsigned long t)
-{
-	int i, ret;
-
-	i = 0;
-	do {
-		ret = get_feature(snand, MT29F_REG_STATUS);
-		if( i++ == t) {
-			printk("mt29f_page_read timeout\n");
-			return ret;
-		}
-	} while((ret & SPI_NAND_MT29F_WEL) != 0x2);
-
-        return 0;
-
-}
-
-void mt29f_reset(struct mt29f *snand)
-{
-	int ret;
-	uint8_t cmd = SPI_NAND_MT29F_RESET;
-
-	mutex_lock(&snand->lock);
-	ret = spi_write_then_read(snand->spi, &cmd, 1, NULL, 0);
-	if (ret < 0) {
-		mutex_unlock(&snand->lock);
-		printk("SF: Reset failed\n");
-	}
-
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-            printk("MT29F: Timeout\n");
-		mutex_unlock(&snand->lock);
-            return;
-	}
-
-	mutex_unlock(&snand->lock);
-	return;
-}
-
-static uint16_t mt29f_read_id(struct mt29f *snand) 
-{
-	uint8_t cmd;
-	uint16_t read_id;
-	uint8_t id[5];
-	int ret;
-
-	mutex_lock(&snand->lock);
-	cmd = SPI_NAND_MT29F_READID;
-	ret = spi_write_then_read(snand->spi, &cmd, 1, id, 5);
-	if (ret < 0) {
-            printk("[%s]: read_id failed\n", __func__);
-		mutex_unlock(&snand->lock);
-		return -1;
-	}
-	read_id = id[1] << 8 |id[2];
-	mutex_unlock(&snand->lock);
-
-	return read_id;
-}
-
-
-static int mt29f_page_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, uint8_t* buf) 
-{
-	struct mt29f *snand = mtd_to_mt29f(mtd);
-	uint16_t col_addr = (uint16_t)(from & 0x7FF);
-	uint8_t cmd[4];
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL2,"[%s] READ from: row: 0x%x col: 0x%x len: %d \n", 
-		__func__,(unsigned int)(((from >> (ROW_SHIFT + 8)) << 8)|(from >> ROW_SHIFT)), 
-		(unsigned int)col_addr, (int)len);
-
-	if(!snand)
-		return -1;
-
-	if (!len)
-		return -1;
-
-	if (from + len > snand->mtd.size)
-		return -EINVAL;
-
-	mutex_lock(&snand->lock);
-
-	cmd[0] = SPI_NAND_MT29F_PAGE_READ;
-	cmd[1] = 0x0;
-	cmd[2] = (from >> (ROW_SHIFT + 8)) & 0xFF;
-	cmd[3] = (from >> ROW_SHIFT) & 0xFF;
-
-
-	ret = spi_write(snand->spi, cmd, 4);
-	if(ret < 0) {
-		printk("mt29f_page_read failed\n");
-		mutex_unlock(&snand->lock);
-		return ret;
-	}
-	
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-		printk("[%s] from 0x%x timeout. ret: 0x%x\n",  __func__, (unsigned int)from, ret);
-		*retlen = 0;
-		mutex_unlock(&snand->lock);
-		return -1;
-	}
-
-	cmd[0] = SPI_NAND_MT29F_RD_CACHE;
-	cmd[1] = (col_addr >> 8) & 0x0F;
-	cmd[2] = (col_addr & 0xFF);
-	cmd[3] = 0x0;   
-
-    	spi_write(snand->spi, cmd, 4);
-	ret = spi_read(snand->spi, buf, len);
-		
-	*retlen = len;
-	mutex_unlock(&snand->lock);
-
-	return ret;
-}
-
-static int mt29f_page_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
-{
-	struct mt29f *snand = mtd_to_mt29f(mtd);
-	uint8_t ret;
-	uint8_t cmd[4];
-	uint8_t prog_cmd[4];
-	uint16_t col_addr = (uint16_t) (to & 0x7FF);
-
-	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
-
-	if (!len) {
-		*retlen = 0;
-		return 0;
-	}
-
-        write_enable(snand);
-
-	prog_cmd[0] = SPI_NAND_MT29F_PROG_LOAD;
-	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
-	prog_cmd[2] = (col_addr & 0xFF);
-
-	ret = wait_write_latch(snand, MAX_WAIT_TIME);
-	if(ret) {
-		printk("[%s] write enable failed\n", __func__);
-		*retlen = 0;
-		return -1;	
-	}
-
-	spi_write(snand->spi, prog_cmd, 3);
-	spi_write(snand->spi, buf, len);
-
-	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
-	cmd[1] = 0x0;
-	cmd[2] = to >> (ROW_SHIFT + 8);
-	cmd[3] = to >> ROW_SHIFT;
-	
-	spi_write(snand->spi, cmd, 4);
-
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
-		*retlen = 0;
-		return -1;
-	}
-
-	*retlen = len;
-	return 0;
-}
-
-static int mt29f_random_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) __attribute__((unused));
-static int mt29f_random_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
-{
-	struct mt29f *snand = mtd_to_mt29f(mtd);
-	uint8_t ret;
-	uint8_t cmd[4];
-	uint8_t prog_cmd[4];
-	uint16_t col_addr = (uint16_t) (to & 0x7FF);
-
-	DEBUG(MTD_DEBUG_LEVEL2, "[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
-
-	if (!len) {
-		*retlen = 0;
-		return 0;
-	}
-
-        write_enable(snand);
-
-	prog_cmd[0] = SPI_NAND_MT29F_PROG_RAND_LOAD;
-	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
-	prog_cmd[2] = (col_addr & 0xFF);
-
-	ret = wait_write_latch(snand, MAX_WAIT_TIME);
-	if(ret) {
-		printk("[%s] write enable failed\n", __func__);
-		*retlen = 0;
-		return -1;	
-	}
-
-	spi_write(snand->spi, prog_cmd, 3);
-	spi_write(snand->spi, buf, len);
-
-	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
-	cmd[1] = 0x0;
-	cmd[2] = to >> (ROW_SHIFT + 8);
-	cmd[3] = to >> ROW_SHIFT;
-	
-	spi_write(snand->spi, cmd, 4);
-
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
-		*retlen = 0;
-		return -1;
-	}
-	*retlen = len;
-	return 0;
-}
-
-static int mt29f_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
-{
-	struct mt29f *snand = mtd_to_mt29f(mtd);
-	int i;
-	uint16_t col_addr, page_size;
-	size_t ret;
-
-	if(!snand)
-		return -1;
-	*retlen = 0;
-	ret = 0;
-
-	page_size= snand->params.page_size;
-	col_addr = do_div(to,(uint64_t)page_size);
-
-	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to:0x%x len:%d row:0x%x col_addr:0x%x\n", 
-			__func__, (unsigned int)to, (int)len, (unsigned int)(to >> ROW_SHIFT)&0xFFFF, col_addr);
-
-	mutex_lock(&snand->lock);
-
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-		printk("[%s] snand is not ready!%x\n", __func__, (unsigned int)ret);
-		*retlen = 0;
-		mutex_unlock(&snand->lock);
-		return -1;
-	}
-
-	if(col_addr + len <= page_size) {
-		mt29f_page_program(mtd, to, len, retlen, buf);
-		/*mt29f_random_program(mtd, to, len, retlen, buf);*/
-	} else {
-	
-        	page_size = snand->params.page_size - col_addr;
-		mt29f_page_program(mtd, to, page_size, &ret, buf);
-		/*mt29f_random_program(mtd, to, page_size, &ret, buf);*/
-		*retlen = *retlen + ret;
-		for( i = page_size; i < len; i += page_size) {
-			page_size = len - i;
-			if(page_size > snand->params.page_size)
-				page_size = snand->params.page_size;
-			mt29f_page_program(mtd, to + i, page_size, &ret, buf + i);
-			/*mt29f_random_program(mtd, to + i, page_size, &ret, buf + i);*/
-			*retlen = *retlen + ret;
-		}
-	}	
-	mutex_unlock(&snand->lock);
-
-	return 0;
-}
-
-static int mt29f_erase_block(struct mtd_info *mtd, uint32_t addr)
-{
-        struct mt29f *snand = mtd_to_mt29f(mtd);
-	uint8_t cmd[4];
-	int ret;
-
-        DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
-                        dev_name(&snand->spi->dev), __func__,
-                        snand->mtd.erasesize / 1024, addr);
-	if(!snand)
-		return 1;
-
-        /* Send write enable, then erase commands. */
-        write_enable(snand);
-
-        /* Wait until finished previous write command. */
-        if (wait_oip_clear(snand, MAX_WAIT_TIME))
-                return 1;
-
-        /* Set up command buffer. */
-        cmd[0] = SPI_NAND_MT29F_BLOCK_ERASE;
-        cmd[1] = 0;
-        cmd[2] = addr >> (ROW_SHIFT + 8);
-        cmd[3] = addr >> ROW_SHIFT;
-
-        spi_write(snand->spi, cmd, 4);
-
-	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
-	if (ret) {
-		printk("[%s] erase block 0x%x failed: ret: %x\n", __func__, addr, ret);
-		return -1;
-	}
-
-        return 0;
-}
-
-static int mt29f_erase(struct mtd_info *mtd, struct erase_info *instr)
-{
-	struct mt29f *snand = mtd_to_mt29f(mtd);
-	uint32_t addr,len;
-	uint32_t rem;
-
-	if(!snand || !instr)
-		return -EINVAL;
-
-	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
-	      dev_name(&snand->spi->dev), __func__, "at",
-	      (long long)instr->addr, (long long)instr->len);
-
-	if (instr->addr + instr->len > snand->mtd.size)
-		return -EINVAL;
-	div_u64_rem(instr->len, mtd->erasesize, &rem);
-	if (rem)
-		return -EINVAL;
-
-	addr = instr->addr;
-	len = instr->len;
-
-	mutex_lock(&snand->lock);
-
-	while (len) {
-		if (mt29f_erase_block(&snand->mtd, addr)) {
-			instr->state = MTD_ERASE_FAILED;
-			mutex_unlock(&snand->lock);
-			return -EIO;
-		}
-		addr += mtd->erasesize;
-		len -= mtd->erasesize;
-	}
-	
-	mutex_unlock(&snand->lock);
-
-        instr->state = MTD_ERASE_DONE;
-        mtd_erase_callback(instr);
-
-	return 0;
-}
-
-
-unsigned char buf[4096];
-unsigned char wrbuf[4096];
-static void mt29f_test(struct mt29f * snand) __attribute__((unused));
-static void mt29f_test(struct mt29f * snand)
-{
-	int i, j, rw_err, offset, seg, xfer_len;
-	size_t retlen;
-	memset(buf, 0, 4096);
-	retlen 		= 0;
-	xfer_len 	= 370;
-
-	j = snand->mtd.size / snand->mtd.erasesize;
-	for( i = 0; i < j; i++)
-	{
-		mt29f_erase_block(&snand->mtd, i);
-		printk("\n######################### erase_block: %d\n", i);
-	}
-	printk("\n######################### read\n");
-	printk("\nFlash read back %d\n",xfer_len);
-
-	for(j = 0; j < 1; j++)
-	{
-		mt29f_page_read(&snand->mtd, j * 2048, xfer_len, &retlen, buf);
-		printk("\n **********************read :%d\n", (int)retlen);
-		for( i = 0; i < xfer_len; i++)
-        	{
-                	printk("%02x",buf[i]);
-                	if((i % 16) == 0xf)
-                        	printk("\n");
-        	}
-	}
-
-	rw_err = 0;
-	for(i = 0; i < 2048; i++){
-		wrbuf[i] = i % 0x100;
-	}
-	offset = 0;
-	seg = 2048;
-	/* write buf with number */
-	for(j = 0; j < 1; j++)
-	{
-		retlen = xfer_len;
-
-		printk("\n######################### write\n");
-		printk("\nFlash write %d to 0x%x\n",xfer_len, (j + offset)*seg);
-
-		mt29f_write(&snand->mtd, (j + offset)*seg, xfer_len, &retlen, wrbuf);
-
-		printk("\n######################### read\n");
-		printk("\n\nFlash read back %d\n",xfer_len);
-
-		mt29f_page_read(&snand->mtd, (j+offset) * seg, xfer_len, &retlen, buf);
-
-		printk("\nread from: 0x%x xfer_len:%d retlen: %d\n",
-			(j + offset) * seg,  xfer_len, (unsigned int)retlen);
-		for( i = 0; i < xfer_len; i++)
-        	{
-                	printk("%02x",buf[i]);
-               		if((i % 16) == 0xf)
-                        	printk("\n");
-        	}
-		if(memcmp(wrbuf, buf, xfer_len) != 0) {
-			rw_err++;
-		}
-	}
-	printk("\nread write: %d times for xfer_len: %d, rw_err: %d\n", j, xfer_len, rw_err);
-}
-
-
-static int __devinit mt29f_probe(struct spi_device *spi)
-{
-	struct flash_platform_data *pdata;
-	struct mt29f_snand_params *params;
-	struct mt29f	*snand;
-	uint16_t snand_id;
-	int	i;
-	struct mtd_partition *parts = NULL;
-	int nr_parts = 0;
-
-	pdata = spi->dev.platform_data;
-	snand = kzalloc(sizeof(struct mt29f), GFP_KERNEL);
-	if (!snand)
-		return -ENOMEM;
-
-	
-	snand->spi = spi;
-	mutex_init(&snand->lock);
-	dev_set_drvdata(&spi->dev, snand);
-
-	snand_id = mt29f_read_id(snand);
-	printk("[%s] Micro vendorID:%x Chip ID:%x\n",
-		__func__, (0xff00 & snand_id) >> 8, (0xff & snand_id));
-
-        for (i = 0; i < ARRAY_SIZE(mt29f_snand_table); i++) {
-                params = (struct mt29f_snand_params *)&mt29f_snand_table[i];
-                if (params && params->idcode1 == (0xff & snand_id) ) {
-                                break;
-                }
-		params++;
-        }
-	
-	if (!params || i == ARRAY_SIZE(mt29f_snand_table)) {
-		printk("The Chip ID does not match device in driver device table\n");
-		return -ENODEV;
-	}
-	memcpy(&snand->params, params, sizeof(struct mt29f_snand_params));
-
-	snand->mtd.name = dev_name(&spi->dev);
-	printk("%s (%lld Kbytes) pagesize %u \n", params->name,
-			(long long)snand->mtd.size >> 10, params->page_size);
-
-	snand->mtd.type = MTD_NORFLASH;
-	snand->mtd.writesize = 1;
-	snand->mtd.flags = MTD_CAP_NORFLASH;
-	snand->mtd.size = (params->page_size * params->pages_per_block * params->nr_blocks); 
-	snand->mtd.erase = mt29f_erase;
-	snand->mtd.read  = mt29f_page_read;
-	snand->mtd.write = mt29f_write;
-
-	snand->erase_opcode = SPI_NAND_MT29F_BLOCK_ERASE;
-	snand->mtd.erasesize = params->page_size * params->pages_per_block;
-
-	snand->mtd.dev.parent = &spi->dev;
-
-	dev_info(&spi->dev, "%s (%lld Kbytes) pagesize %u \n", params->name,
-			(long long)snand->mtd.size >> 10, params->page_size);
-
-	DEBUG(MTD_DEBUG_LEVEL2,
-		"mtd .name = %s, .size = 0x%llx (%lldMiB) "
-			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
-		snand->mtd.name,
-		(long long)snand->mtd.size, (long long)(snand->mtd.size >> 20),
-		snand->mtd.erasesize, snand->mtd.erasesize / 1024,
-		snand->mtd.numeraseregions);
-
-	if (snand->mtd.numeraseregions)
-		for (i = 0; i < snand->mtd.numeraseregions; i++)
-			DEBUG(MTD_DEBUG_LEVEL2,
-				"mtd.eraseregions[%d] = { .offset = 0x%llx, "
-				".erasesize = 0x%.8x (%uKiB), "
-				".numblocks = %d }\n",
-				i, (long long)snand->mtd.eraseregions[i].offset,
-				snand->mtd.eraseregions[i].erasesize,
-				snand->mtd.eraseregions[i].erasesize / 1024,
-				snand->mtd.eraseregions[i].numblocks);
-
-	if (mtd_has_cmdlinepart()) {
-		static const char *part_probes[]
-				= { "cmdlinepart", NULL, };
-
-		nr_parts = parse_mtd_partitions(&snand->mtd,
-				part_probes, &parts, 0);
-	}
-
-	if ((nr_parts == 0) && (pdata == 0)) {
-		parts    = xlp_mt29f_part;
-		nr_parts = ARRAY_SIZE(xlp_mt29f_part);
-	}
-
-	if (nr_parts > 0) {
-		for (i = 0; i < nr_parts; i++) {
-			DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
-				"{.name = %s, .offset = 0x%llx, "
-				".size = 0x%llx (%lldKiB) }\n",
-				i, parts[i].name,
-				(long long)parts[i].offset,
-				(long long)parts[i].size,
-				(long long)(parts[i].size >> 10));
-		}
-		snand->partitioned = 1;
-		return mtd_device_register(&snand->mtd, parts, nr_parts);
-	}
-
-	return mtd_device_register(&snand->mtd, NULL, 0) ? -ENODEV : 0;
-}
-
-
-static int __devexit mt29f_remove(struct spi_device *spi)
-{
-	struct mt29f	*snand = dev_get_drvdata(&spi->dev);
-	int		status;
-
-	status = mtd_device_unregister(&snand->mtd);
-	if (status == 0)
-		kfree(snand);
-	return 0;
-}
-
-
-static struct spi_driver mt29f_driver = {
-	.driver = {
-		.name	= "mt29f",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe	= mt29f_probe,
-	.remove	= __devexit_p(mt29f_remove),
-
-};
-
-
-static int __init mt29f_init(void)
-{
-	return spi_register_driver(&mt29f_driver);
-}
-
-
-static void __exit mt29f_exit(void)
-{
-	spi_unregister_driver(&mt29f_driver);
-}
-
-
-module_init(mt29f_init);
-module_exit(mt29f_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Netlogicmicro System Inc.");
-MODULE_DESCRIPTION("MTD SPI driver for Micron MT29f nand chips");
-MODULE_ALIAS("platform:mt29f-spi");
diff --git a/drivers/mtd/devices/spinand_lld.c b/drivers/mtd/devices/spinand_lld.c
index 008bafc..347b402 100644
--- a/drivers/mtd/devices/spinand_lld.c
+++ b/drivers/mtd/devices/spinand_lld.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2013 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
 spinand_lld.c
 
@@ -21,9 +29,11 @@ GNU General Public License for more details.
 #include <linux/interrupt.h>
 #include <linux/mutex.h>
 #include <linux/math64.h>
+#include <linux/delay.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
 #include <linux/mtd/spinand.h>
 
 #include <linux/spi/spi.h>
@@ -36,6 +46,11 @@ GNU General Public License for more details.
 /**
    OOB area specification layout:  Total 32 available free bytes.
 */
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+int enable_hw_ecc = 0;
+int enable_read_hw_ecc = 0;
+#endif
 static struct nand_ecclayout spinand_oob_64 = {
 	.eccbytes = 24,
 	.eccpos = {
@@ -54,6 +69,7 @@ static struct nand_ecclayout spinand_oob_64 = {
 		{.offset = 56,
 		 .length = 8}, }
 };
+
 /**
  * spinand_cmd - to process a command to send to the SPI Nand
  * 
@@ -61,12 +77,14 @@ static struct nand_ecclayout spinand_oob_64 = {
  *    Set up the command buffer to send to the SPI controller.
  *    The command buffer has to initized to 0
  */
+
 int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 {
-	int					ret;
+	int	ret;
 	struct spi_message	message;
-	struct spi_transfer		x[4];
+	struct spi_transfer	x[4];
 	u8 dummy = 0xff;
+	char cmd_buff[16];
 
 
 	spi_message_init(&message);
@@ -74,19 +92,28 @@ int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 	
 	x[0].len = 1;
 	x[0].tx_buf = &cmd->cmd;
-	spi_message_add_tail(&x[0], &message);
+	
+	memcpy(cmd_buff,  &cmd->cmd, 1);
 	
 	if (cmd->n_addr)
 	{
 		x[1].len = cmd->n_addr;
 		x[1].tx_buf = cmd->addr;
-		spi_message_add_tail(&x[1], &message);
+		x[0].len = 1 +  x[1].len;
+		memcpy(&cmd_buff[1],  cmd->addr, x[1].len);
 	}
 
+	x[0].tx_buf = &cmd_buff[0];
+	if(cmd->n_tx || cmd->n_rx)
+		x[0].spi_cont_cmd = 1;
+	spi_message_add_tail(&x[0], &message);
+	
+
 	if (cmd->n_dummy)
 	{
 		x[2].len = cmd->n_dummy;
 		x[2].tx_buf = &dummy;
+		x[2].spi_cont_cmd = 1;
 		spi_message_add_tail(&x[2], &message);		
 	}
 
@@ -110,20 +137,6 @@ int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 }
 
 /**
- * spinand_reset- send reset command "0xff" to the Nand device
- * 
- * Description:
- *    Reset the SPI Nand with the reset command 0xff
- */
-static int spinand_reset(struct spi_device *spi_nand)
-{
-	struct spinand_cmd cmd = {0};
-
-	cmd.cmd = CMD_RESET;
-
-	return spinand_cmd(spi_nand, &cmd);
-}
-/**
  * spinand_read_id- Read SPI Nand ID
  * 
  * Description:
@@ -133,12 +146,12 @@ static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 {
 	struct spinand_cmd cmd = {0};
 	ssize_t retval;
+	u8 nand_id[3];
 
 	
 	cmd.cmd = CMD_READ_ID;
-	cmd.n_dummy = 1;
-	cmd.n_rx = 2;
-	cmd.rx_buf = id;
+	cmd.n_rx = 3;
+	cmd.rx_buf = &nand_id[0];
 	
 	retval = spinand_cmd(spi_nand, &cmd);
 
@@ -147,7 +160,9 @@ static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 				(int) retval);
 		return retval;
 	}
-	
+	id[0] = nand_id[1];
+        id[1] = nand_id[2];	
+
 	return 0;	
 }
 
@@ -188,7 +203,7 @@ static int spinand_lock_block(struct spi_device *spi_nand, struct spinand_info *
  *    This function is to allow reading the status of the command: read, write, and erase.
  *    Once the status turns to be ready, the other status bits also are valid status bits.
  */
-static int spinand_read_status(struct spi_device *spi_nand, struct spinand_info *info, u8 *status)
+static int spinand_read_status(struct spi_device *spi_nand, struct spinand_info *info, uint8_t *status)
 {
 	struct spinand_cmd cmd = {0};
 	ssize_t retval;
@@ -271,8 +286,9 @@ static int spinand_set_otp(struct spi_device *spi_nand, struct spinand_info *inf
 	return 0;
 }
 
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
 /**
- * sspinand_enable_ecc- send command 0x1f to write the SPI Nand OTP register
+ * spinand_enable_ecc- send command 0x1f to write the SPI Nand OTP register
  * 
  * Description:
  *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
@@ -298,6 +314,7 @@ static int spinand_enable_ecc(struct spi_device *spi_nand, struct spinand_info *
 		return retval;
 	}
 }
+#endif
 
 static int spinand_disable_ecc(struct spi_device *spi_nand, struct spinand_info *info)
 {
@@ -321,7 +338,7 @@ static int spinand_disable_ecc(struct spi_device *spi_nand, struct spinand_info
 }
 
 /**
- * sspinand_write_enable- send command 0x06 to enable write or erase the Nand cells
+ * spinand_write_enable- send command 0x06 to enable write or erase the Nand cells
  * 
  * Description:
  *   Before write and erase the Nand cells, the write enable has to be set.
@@ -367,10 +384,11 @@ static int spinand_read_from_cache(struct spi_device *spi_nand, struct spinand_i
 	column = byte_id;
 
 	cmd.cmd = CMD_READ_RDM;
-	cmd.n_addr = 2;
+	cmd.n_addr = 3;
 	cmd.addr[0] = (u8)((column&0xff00)>>8);
 	cmd.addr[1] = (u8)(column&0x00ff);
-	cmd.n_dummy = 1;
+	cmd.addr[2] = (u8)(0xff);
+	cmd.n_dummy = 0;
 	cmd.n_rx = len;
 	cmd.rx_buf = rbuf;
 	
@@ -393,6 +411,10 @@ static int spinand_read_page(struct spi_device *spi_nand, struct spinand_info *i
 	ssize_t retval;
 	u8 status = 0;
 	
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_read_hw_ecc)	
+		retval = spinand_enable_ecc(spi_nand, info);
+#endif	
 	retval = spinand_read_page_to_cache(spi_nand, info, page_id);
 
 	while (1)
@@ -409,16 +431,20 @@ static int spinand_read_page(struct spi_device *spi_nand, struct spinand_info *i
 			if ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR)
 			{
 				dev_err(&spi_nand->dev, "ecc error, page=%d\n", page_id);
-				if (spi_nand == SPI_NAND_MICRON_DRIVER_KEY)
-					printk(KERN_INFO "Error: reformat or erase your device. \n"); 
-				else
-				return -1;
+				return 0;
 			}
 			break;
 		}
 	}
 
 	retval = spinand_read_from_cache(spi_nand, info, offset, len, rbuf);
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_read_hw_ecc)	{	
+		retval = spinand_disable_ecc(spi_nand, info);
+		enable_read_hw_ecc = 0;
+	}
+#endif	
 	return 0;
 		
 }
@@ -485,10 +511,27 @@ static int spinand_program_execute(struct spi_device *spi_nand, struct spinand_i
  *   sent, the write cache command, and the write execute command
  *   Poll to wait for the tPROG time to finish the transaction.
  */
-static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* wbuf)
+static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* buf)
 {
 	ssize_t retval;
 	u8 status = 0;
+	uint8_t *wbuf;
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	unsigned int i, j;
+
+	enable_read_hw_ecc = 0;
+	wbuf = kzalloc(2112,GFP_KERNEL);
+	spinand_read_page(spi_nand, info, page_id, 0, 2112, wbuf);
+	for(i=offset, j=0; i<len; i++,j++)
+	{
+		wbuf[i] &= buf[j];
+	}
+	if(enable_hw_ecc)
+		retval = spinand_enable_ecc(spi_nand, info);
+
+#else
+	wbuf = buf;
+#endif
 
 	retval = spinand_write_enable(spi_nand, info);
 	
@@ -517,6 +560,13 @@ static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info
 				break;
 		}
 	}
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_hw_ecc)	{
+		retval = spinand_disable_ecc(spi_nand, info);
+		enable_hw_ecc = 0;
+	}
+	kfree(wbuf);
+#endif
 
 	return 0;
 }
@@ -534,7 +584,8 @@ static int spinand_erase_block_erase(struct spi_device *spi_nand, struct spinand
 	struct spinand_cmd cmd = {0};
 	u16 row;
 
-	row = block_id << 6;
+	//row = block_id << 6;
+	row = block_id;
 	cmd.cmd = CMD_ERASE_BLK;
 	cmd.n_addr = 3;
 	cmd.addr[1] = (u8)((row&0xff00)>>8);
@@ -556,7 +607,7 @@ static int spinand_erase_block(struct spi_device *spi_nand, struct spinand_info
 {
 	ssize_t retval;
 	u8 status= 0;
-
+	
 	retval = spinand_write_enable(spi_nand, info);
 	
 	retval = spinand_erase_block_erase(spi_nand, info, block_id);
@@ -613,15 +664,197 @@ static int spinand_get_info(struct spi_device *spi_nand, struct spinand_info *in
 
 		info->page_shift = 11;
 		info->page_mask = 0x7ff;
-		
-		info->ecclayout = &spinand_oob_64;
 	}	
 	
 	return 0;
 }
 
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+static void spinand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
+{
+	const uint8_t *p = buf;
+	int eccsize = chip->ecc.size;
+	int eccsteps = chip->ecc.steps;
+
+	enable_hw_ecc = 1;
+	chip->write_buf(mtd, p, eccsize * eccsteps);
+	return;
+}
+
+static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int page)
+{
+	u8 retval, status;
+	uint8_t *p = buf;
+	int eccsize = chip->ecc.size;
+	int eccsteps = chip->ecc.steps;
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+
+	enable_read_hw_ecc = 1;	
+
+	chip->read_buf(mtd, p, eccsize*eccsteps);
+	while(1)
+	{	
+		retval = spinand_read_status(info->spi, info, &status);
+		if ((status & STATUS_OIP_MASK) == STATUS_READY)
+		{
+			if ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR)
+			{
+				printk("spinand: ECC error \n");
+				mtd->ecc_stats.failed++;
+			}
+			else if((status & STATUS_ECC_MASK) == STATUS_ECC_1BIT_CORRECTED )	{
+				mtd->ecc_stats.corrected ++;
+			}
+			break;
+		}
+
+	
+	}
+	return 0;
+
+}
+#endif
+
+static void spinand_select_chip(struct mtd_info *mtd, int dev)
+{
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->priv;
+
+                state->cs = 1;
+}
+
+
+static uint8_t spinand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+	u8 data;
+
+	data = state->buf[state->buf_ptr];
+	state->buf_ptr++;
+	return data;
+}
+
+static int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+
+	unsigned long timeo = jiffies;
+	int retval, state = chip->state;
+	u8 status;
+
+	if (state == FL_ERASING)
+		timeo += (HZ * 400) / 1000;
+	else
+		timeo += (HZ * 20) / 1000;
+	
+
+	while (time_before(jiffies, timeo)) {
+		retval = spinand_read_status(info->spi, info, &status);
+		if ((status & STATUS_OIP_MASK) == STATUS_READY)
+		{
+			return 0;
+		}
+		cond_resched();
+	}
+	return 0;
+}
+
+static void spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+
+	memcpy(state->buf+state->buf_ptr, buf, len);
+	state->buf_ptr += len;
+	return;
+}
+
+static void spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+
+	memcpy(buf, state->buf+state->buf_ptr, len);
+	state->buf_ptr += len;
+	return;
+}
+
+static void cmdfunc(struct mtd_info *mtd,
+                    unsigned int command,
+                    int column,
+                    int page)
+{
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+        switch (command) {
+	/*
+	 * READ0 - read in first  0x800 bytes
+	 */
+        case NAND_CMD_READ1:
+        case NAND_CMD_READ0:
+                state->buf_ptr = 0;
+		spinand_read_page(info->spi, info, page, 0x0, 0x840, state->buf);
+		break;
+        /* READOOB reads only the OOB because no ECC is performed. */
+        case NAND_CMD_READOOB:
+		state->buf_ptr = 0;
+		spinand_read_page(info->spi, info, page, 0x800, 0x40, state->buf);
+		break;
+	case NAND_CMD_RNDOUT:
+		state->buf_ptr = column;
+		break;
+        case NAND_CMD_READID:
+                state->buf_ptr = 0;
+		spinand_read_id(info->spi, (u8*)state->buf);
+		break;
+        case NAND_CMD_PARAM:
+                state->buf_ptr = 0;
+		break;
+        /* ERASE1 stores the block and page address */
+        case NAND_CMD_ERASE1:
+		spinand_erase_block(info->spi, info, page);
+		break;
+        /* ERASE2 uses the block and page address from ERASE1 */
+        case NAND_CMD_ERASE2:
+		break;
+        /* SEQIN sets up the addr buffer and all registers except the length */
+        case NAND_CMD_SEQIN:
+		state->col	= column;
+		state->row	= page;
+		state->buf_ptr = 0;
+		break;
+        /* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+        case NAND_CMD_PAGEPROG:
+		spinand_program_page(info->spi, info, state->row, state->col, state->buf_ptr, state->buf);
+		break;
+
+        case NAND_CMD_STATUS:
+		spinand_get_otp(info->spi, info, state->buf);
+		
+		if(!(state->buf[0] & 0x80))
+		state->buf[0] = 0x80;
+		state->buf_ptr = 0;
+
+		break;
+        /* RESET command */
+        case NAND_CMD_RESET:
+		break;
+	default:
+		printk("command: 0x%x \n", command);
+		break;
+        }
+}
+
+
+
 /**
- * spinand_probe - [spinand Interface] 
+* spinand_probe - [spinand Interface] 
 * @spi_nand: registered device driver.
  *
  * Description:
@@ -631,12 +864,12 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 {
 	ssize_t retval;
 	struct mtd_info *mtd;
-	struct spinand_chip *chip; 
+	struct nand_chip *chip; 
 	struct spinand_info *info;
-	u8 id[2]= {0};
+	struct nand_state *state;
+	u8 id[2]= {2};
+	
 	
-	retval = spinand_reset(spi_nand);
-	retval = spinand_reset(spi_nand);
 	retval = spinand_read_id(spi_nand, (u8*)&id);
 	if (id[0]==0 && id[1]==0)
 	{
@@ -647,37 +880,61 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 	info  = kzalloc(sizeof(struct spinand_info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
+
+	info->spi = spi_nand;
 	
 	retval = spinand_get_info(spi_nand, info, (u8*)&id);
 	printk(KERN_INFO "SPINAND: 0x%02x, 0x%02x, %s\n", id[0], id[1], info->name); 
 	printk(KERN_INFO "%s\n", mu_spi_nand_driver_version);
 	retval = spinand_lock_block(spi_nand, info, BL_ALL_UNLOCKED);
 
+	state = kzalloc(sizeof(struct nand_state), GFP_KERNEL);
+	if(!state)
+		return -ENOMEM; 
+	
+	info->priv = state;
+	state->last_cmd  = 0;
+	state->cs        = 0;
+	state->buf_ptr   = 0 ;
+	state->buf =  kzalloc(10 * 64 * 2048, GFP_KERNEL);
+	if(!state->buf)
+		return -ENOMEM;
+	
+	chip  = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	
+	chip->ecc.mode      = NAND_ECC_NONE;
+
+#ifdef CONFIG_MTD_SPINAND_SWECC
+	chip->ecc.mode      = NAND_ECC_SOFT;
+	chip->ecc.size	    = 0x200;
+	chip->ecc.steps     = 0x4;
+	chip->ecc.total     = chip->ecc.steps * chip->ecc.bytes;
+	chip->ecc.layout    = &spinand_oob_64;
+#endif
+
 #ifdef CONFIG_MTD_SPINAND_ONDIEECC
-	retval = spinand_enable_ecc(spi_nand, info);
+	chip->ecc.mode      = NAND_ECC_HW;
+	chip->ecc.size	    = 0x200;
+	chip->ecc.bytes     = 0x6;
+	chip->ecc.steps     = 0x4;
+	chip->ecc.total     = chip->ecc.steps * chip->ecc.bytes;
+	chip->ecc.layout    = &spinand_oob_64;
+        chip->ecc.write_page= spinand_write_page_hwecc;
+	chip->ecc.read_page = spinand_read_page_hwecc;	
 #else
 	retval = spinand_disable_ecc(spi_nand, info);
 #endif
 
-	chip  = kzalloc(sizeof(struct spinand_chip), GFP_KERNEL);
-	if (!chip)
-		return -ENOMEM;
-
-	chip->spi_nand = spi_nand;
-	chip->info = info;
-	chip->reset = spinand_reset;
-	chip->read_id = spinand_read_id;
-	chip->read_page = spinand_read_page;
-	chip->program_page = spinand_program_page;
-	chip->erase_block = spinand_erase_block;
-
-	chip->buf = kzalloc(info->page_size, GFP_KERNEL);
-	if (!chip->buf)
-		return -ENOMEM;
-
-	chip->oobbuf = kzalloc(info->ecclayout->oobavail, GFP_KERNEL);
-	if (!chip->oobbuf)
-		return -ENOMEM;
+	chip->priv = info;
+	chip->options |= NAND_CACHEPRG | NAND_SKIP_BBTSCAN;
+	chip->read_buf   = spinand_read_buf;
+	chip->write_buf  = spinand_write_buf;
+	chip->read_byte  = spinand_read_byte;
+	chip->select_chip = spinand_select_chip;
+	chip->cmdfunc      = cmdfunc;
+	chip->waitfunc      = spinand_wait;
 
 	mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
 	if (!mtd)
@@ -686,9 +943,12 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 	dev_set_drvdata(&spi_nand->dev, mtd);
 	
 	mtd->priv = chip;
+	mtd->oobsize = 64;
 
-	retval = spinand_mtd(mtd);
-	
+	if(nand_scan(mtd, 1))	{
+		return -1;
+	}
+	 mtd_device_register(mtd, NULL, 0);
 	return retval;
 }
 
@@ -702,19 +962,21 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 static int __devexit spinand_remove(struct spi_device *spi)
 {
 	struct mtd_info *mtd;
-	struct spinand_chip *chip; 
-
-	DEBUG(MTD_DEBUG_LEVEL1, "%s: remove\n", dev_name(&spi->dev));
+	struct nand_chip *chip; 
+	struct spinand_info *info;
+	struct nand_state *state;
 
 	mtd = dev_get_drvdata(&spi->dev);
 	
-	spinand_mtd_release(mtd);
 
-	chip = mtd->priv;
+	chip = (struct nand_chip *)mtd->priv;
+	info = (struct spinand_info *)chip->priv;
+	state = (struct nand_state *)info->priv;
+
+	mtd_device_unregister(mtd);
 	
-	kfree(chip->info);
-	kfree(chip->buf);
-	kfree(chip->oobbuf);
+	kfree(state);
+	kfree(info);
 	kfree(chip);
 	kfree(mtd);
 	
@@ -726,7 +988,7 @@ static int __devexit spinand_remove(struct spi_device *spi)
 */
 static struct spi_driver spinand_driver = {
 	.driver = {
-		.name		= "spi_nand",
+		.name		= "mt29f",
 		.bus		= &spi_bus_type,
 		.owner		= THIS_MODULE,
 	},
@@ -740,7 +1002,9 @@ static struct spi_driver spinand_driver = {
 */
 static int __init spinand_init(void)
 {
-	return spi_register_driver(&spinand_driver);
+	int val;
+	val = spi_register_driver(&spinand_driver);
+	return val;
 }
 
 /**
@@ -756,5 +1020,6 @@ module_exit(spinand_exit);
 
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Henry Pan <hspan@micron.com>");
-MODULE_DESCRIPTION("SPI NAND driver code");
+MODULE_AUTHOR("Netlogicmicro System Inc.");
+MODULE_DESCRIPTION("MTD SPI driver for Micron MT29f nand chips");
+MODULE_ALIAS("platform:spinand");
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index af4fe8c..1dade81 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -91,6 +91,9 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 1,8V 16-bit",     0xAD, 0, 128, 0, LP_OPTIONS16},
+	{"SPINAND 128MiB 3,3V 8-bit",	0x11, 2048, 128, 0x20000, LP_OPTIONS},
+	{"SPINAND 128MiB 3,3V 8-bit",	0x12, 2048, 128, 0x20000, LP_OPTIONS},
+
 
 	/* 2 Gigabit */
 	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
diff --git a/include/linux/mtd/spinand.h b/include/linux/mtd/spinand.h
index afc1d3d..508b080 100644
--- a/include/linux/mtd/spinand.h
+++ b/include/linux/mtd/spinand.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2013 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  *  linux/include/linux/mtd/spinand.h
  *
@@ -104,47 +112,24 @@ struct spinand_info {
 	u16		page_mask;
 
 	struct nand_ecclayout *ecclayout;
+	struct spi_device *spi; 
+	void *priv;
 };
 
-typedef enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_LOCKING,
-	FL_RESETING,
-	FL_OTPING,
-	FL_PM_SUSPENDED,
-} spinand_state_t;
-	
-struct spinand_chip { /* used for multi chip */
-	spinlock_t		chip_lock;
-	wait_queue_head_t wq;	
-	spinand_state_t	state;
-	struct spi_device	*spi_nand;
-	struct spinand_info *info;
-	/*struct mtd_info	*mtd; */
-
-	int (*reset) (struct spi_device *spi_nand);
-	int (*read_id) (struct spi_device *spi_nand, u8* id);
-	int (*read_page) (struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* rbuf);
-	int (*program_page) (struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* wbuf);
-	int (*erase_block) (struct spi_device *spi_nand, struct spinand_info *info, u16 block_id);
-
+struct nand_state {
+	int cs ;
+	uint32_t col;
+	uint32_t row;
+	uint32_t last_cmd;
+	int buf_ptr;
 	u8 *buf;
-	u8 *oobbuf; /* temp buffer */
-
-
-#ifdef CONFIG_MTD_SPINAND_SWECC
-	u8 ecc_calc[12];
-	u8 ecc_code[12];
-#endif
 };
 
 struct spinand_cmd {
 	u8 cmd;
+	u8 cmd_cnt;
 	unsigned n_addr;	
+	u8 addr_cmd_cnt;
 	u8 addr[3];
 	unsigned n_dummy;
 	unsigned n_tx;	
-- 
1.7.0.4

