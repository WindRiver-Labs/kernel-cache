From d67e5a915b9cc8c4f8eb56e88346f75da52507bb Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 21 May 2010 16:23:53 -0700
Subject: [PATCH 029/761] reslove unsolve symbol issue when compiled use
 nlm_xlr_defconfig

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/traps.c             |    8 ++++----
 arch/mips/netlogic/common/cpu_proc.c |   10 +++++-----
 arch/mips/netlogic/xlp/on_chip.c     |   18 +++++++++---------
 drivers/char/nlm_xlr_msgring.c       |    8 ++++----
 drivers/net/nlm_spi4/nlm_vits_eth.c  |    7 ++++---
 drivers/net/xlr_mac.c                |   17 ++++++++++-------
 6 files changed, 36 insertions(+), 32 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 9f7e447..2a07ecf 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -619,8 +619,8 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 	return -1;			/* Must be something else ... */
 }
 
-extern void netlogic_cpu_stat_update_rdhwr(void);
-extern void netlogic_cpu_stat_update_fp(void);
+extern void nlm_cpu_stat_update_rdhwr(void);
+extern void nlm_cpu_stat_update_fp(void);
 
 /*
  * Simulate trapping 'rdhwr' instructions to provide user accessible
@@ -660,7 +660,7 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 		case 29:
 			regs->regs[rt] = ti->tp_value;
 #if defined(CONFIG_NLM_COMMON)
-			netlogic_cpu_stat_update_rdhwr();
+			nlm_cpu_stat_update_rdhwr();
 #endif
 			return 0;
 		default:
@@ -738,7 +738,7 @@ asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 		void __user *fault_addr = NULL;
 
 #if defined(CONFIG_NLM_COMMON)
-				netlogic_cpu_stat_update_fp();
+				nlm_cpu_stat_update_fp();
 #endif
 		/*
 		 * Unimplemented operation exception.  If we've got the full
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 6ef43ea..2e83e7d 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -57,7 +57,7 @@ __u64 xlr_cp2_exceptions[32];
 extern unsigned long long nlm_common_tlb_stats[];
 
 
-void netlogic_cpu_stat_update_rdhwr(void)
+void nlm_cpu_stat_update_rdhwr(void)
 {
 	int cpu = 0;
 
@@ -69,7 +69,7 @@ void netlogic_cpu_stat_update_rdhwr(void)
 	preempt_enable();
 }
 
-void netlogic_cpu_stat_update_fp(void)
+void nlm_cpu_stat_update_fp(void)
 {
 	int cpu = 0;
 
@@ -81,7 +81,7 @@ void netlogic_cpu_stat_update_fp(void)
 	preempt_enable();
 }
 
-void netlogic_cpu_stat_update_msgring_int(void)
+void nlm_cpu_stat_update_msgring_int(void)
 {
 	int cpu = 0;
 
@@ -93,7 +93,7 @@ void netlogic_cpu_stat_update_msgring_int(void)
 	preempt_enable();
 }
 
-void netlogic_cpu_stat_update_msgring_cycles(__u32 cycles)
+void nlm_cpu_stat_update_msgring_cycles(__u32 cycles)
 {
 	int cpu = 0;
 
@@ -105,7 +105,7 @@ void netlogic_cpu_stat_update_msgring_cycles(__u32 cycles)
 	preempt_enable();
 }
 
-void netlogic_cpu_stat_update_msgring_pic_int(void)
+void nlm_cpu_stat_update_msgring_pic_int(void)
 {
 	int cpu = 0;
 
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index f1823ed..ab6af26 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -470,9 +470,9 @@ __setup("xlr_msgring_thread_mask=", xlr_msgring_thread_mask_setup);
 __setup("xlr_complete_msgring_thread_mask=",
 	xlr_complete_msgring_thread_mask_setup);
 
-extern void netlogic_cpu_stat_update_msgring_int(void);
-extern void netlogic_cpu_stat_update_msgring_cycles(__u32 cycles);
-extern void netlogic_cpu_stat_update_msgring_pic_int(void);
+extern void nlm_cpu_stat_update_msgring_int(void);
+extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
+extern void nlm_cpu_stat_update_msgring_pic_int(void);
 
 void msgring_process_rx_msgs(int start_bucket, int end_bucket,
 			     __u32 pop_bucket_mask)
@@ -528,9 +528,9 @@ __u64 xlr_cp2_exceptions[32];
 struct user_mac_data *user_mac;
 struct user_mac_kernal_data user_mac_krnl_data;
 struct xlr_user_mac_config xlr_user_mac;
-void netlogic_cpu_stat_update_msgring_int(void) { }
-void netlogic_cpu_stat_update_msgring_cycles(__u32 cycles) { }
-void netlogic_cpu_stat_update_msgring_pic_int(void) { }
+void nlm_cpu_stat_update_msgring_int(void) { }
+void nlm_cpu_stat_update_msgring_cycles(__u32 cycles) { }
+void nlm_cpu_stat_update_msgring_pic_int(void) { }
 #endif /* CONFIG_NLMCOMMON_MAC */
 
 __u32 msgrng_msg_cycles = 0;
@@ -543,9 +543,9 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	if (irq == IRQ_MSGRING) {
 		/* normal message ring interrupt */
 		xlr_inc_counter(MSGRNG_INT);
-		netlogic_cpu_stat_update_msgring_int();
+		nlm_cpu_stat_update_msgring_int();
 	} else {
-		netlogic_cpu_stat_update_msgring_pic_int();
+		nlm_cpu_stat_update_msgring_pic_int();
 	}
 
 	irq_enter();
@@ -561,7 +561,7 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	core = 0;
 	msgring_process_rx_msgs(pop_bucket_start[core], pop_bucket_end[core], pop_bucket_mask[core]);
 
-	netlogic_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
+	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
 
 	msgrng_flags_restore(mflags);
 
diff --git a/drivers/char/nlm_xlr_msgring.c b/drivers/char/nlm_xlr_msgring.c
index b9f67ff..2b81580 100644
--- a/drivers/char/nlm_xlr_msgring.c
+++ b/drivers/char/nlm_xlr_msgring.c
@@ -199,10 +199,10 @@ do { \
 static struct fifo msg_fifos[MAX_MSG_FIFOS];
 
 #ifdef CONFIG_NLMCOMMON_MAC
-extern void nlm_nlm_common_rmios_msgring_handler(int bucket, int size, int code, int stid,
+extern void nlm_xlr_rmios_msgring_handler(int bucket, int size, int code, int stid,
 					   struct msgrng_msg *msg, void *data/* ignored */);
 #else /* CONFIG_NLMCOMMON_MAC */
-void nlm_nlm_common_rmios_msgring_handler(int bucket, int size, int code,
+void nlm_xlr_rmios_msgring_handler(int bucket, int size, int code,
                                     int stid, struct msgrng_msg *msg,
                                     void *data /* ignored */ ) { }
 #endif /* CONFIG_NLMCOMMON_MAC */
@@ -227,7 +227,7 @@ void nlm_common_msgring_drv_int_handler(int bucket, int size, int code, int stid
 
 		if (((code&0xf) == 0xf) && hybrid) {
 			// forward to linux driver
-			nlm_nlm_common_rmios_msgring_handler(bucket, size, code, stid, msg, data);
+			nlm_xlr_rmios_msgring_handler(bucket, size, code, stid, msg, data);
 			return;
 		}
 		if (((code&0xf) == 0xe) && hybrid) {
@@ -718,7 +718,7 @@ static int msgring_init(void)
 		return msgring_major;
 	}
 	msgring_major = XLR_MSGRING_SHM_MAJOR;
-	printk("Registered xlr msgring driver: major=%d\n", msgring_major);
+	printk("Registered phoenix msgring driver: major=%d\n", msgring_major);
 
 	return 0;
 }
diff --git a/drivers/net/nlm_spi4/nlm_vits_eth.c b/drivers/net/nlm_spi4/nlm_vits_eth.c
index 13c445b..ca1f5d4 100644
--- a/drivers/net/nlm_spi4/nlm_vits_eth.c
+++ b/drivers/net/nlm_spi4/nlm_vits_eth.c
@@ -749,10 +749,10 @@ void nlm_vits_station_unowned_rx_tx_done(	uint32  cmd, 	uint32 	slot,
 		skb_put(skb, len);
 		skb->protocol = eth_type_trans(skb, skb->dev);
 		memcpy(skb->data, (char *)addr + 2, len);
-
+/*
 		if(rmik_queue_pkt_mem(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL) < 0)
 		nlm_nlm_common_drop_message_unowned(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL, 1);
-
+*/
 	
 #if NLM_SPI4_DEBUG
 		{
@@ -768,8 +768,9 @@ void nlm_vits_station_unowned_rx_tx_done(	uint32  cmd, 	uint32 	slot,
 		netif_rx(skb);
 		return;
 		err_exit:
-
+/*
 		nlm_nlm_common_drop_message_unowned(fbstid, virt_to_phys(addr) & 0xffffffffe0ULL, 1);
+*/
 		if(skb)
 			kfree_skb(skb);
 
diff --git a/drivers/net/xlr_mac.c b/drivers/net/xlr_mac.c
index 8b85569..62db521 100644
--- a/drivers/net/xlr_mac.c
+++ b/drivers/net/xlr_mac.c
@@ -70,8 +70,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/gpio.h>
 #include <user/netlogic/xlr_user_mac.h>
 #include <asm/netlogic/debug.h>
+/*
 #include <asm/netlogic/xlr_rmik.h>
-
+*/
 #define DRV_NAME	"nlm_xlr_mac"
 #define DRV_VERSION	"0.1"
 /* #define DEBUG */
@@ -2643,10 +2644,10 @@ void nlm_xlr_station_unowned_msgring_handler(int bucket, int size, int code,
 	length = length - (BYTE_OFFSET + MAC_CRC_LEN);
 	skb_put(skb, length);
 	memcpy(skb->data, (char *)addr + 2, length);
-	
+/*	
 	if(rmik_queue_pkt_mem(fbstid, msg->msg0 & 0xffffffffe0ULL) < 0)
 		nlm_xlr_drop_message_unowned(fbstid, msg->msg0 & 0xffffffffe0ULL, 1);
-
+*/
 #if 0
 		{
 			int i = 0;
@@ -2675,7 +2676,9 @@ void nlm_xlr_station_unowned_msgring_handler(int bucket, int size, int code,
 	return;
 
 	err_exit:
+/*
 		nlm_xlr_drop_message_unowned(fbstid, msg->msg0 & 0xffffffffe0ULL, 1);
+*/
 		if(skb)
 			kfree_skb(skb);
 		return;
@@ -3219,7 +3222,7 @@ static void nlm_xlr_config_spill_area(struct driver_data *priv)
 }
 
 /*****************************************************************
- * Write the MAC address to the XLR registers
+ * Write the MAC address to the PHNX registers
  * All 4 addresses are the same for now
  *****************************************************************/
 static void xlr_mac_setup_hwaddr(struct driver_data *priv)
@@ -3252,7 +3255,7 @@ static void xlr_mac_setup_hwaddr(struct driver_data *priv)
 }
 
 /*****************************************************************
- * Read the MAC address from the XLR registers
+ * Read the MAC address from the PHNX registers
  * All 4 addresses are the same for now
  *****************************************************************/
 static void xlr_mac_get_hwaddr(struct net_device *dev)
@@ -4365,10 +4368,10 @@ int nlm_xlr_mac_init_module(void)
 		dev_mac_type[priv->type][priv->instance] = dev;
 		dev_mac[i] = dev;
 	}
-	
+/*	
 	rmik_init_replenish_work(num_desc);
 	rmik_register_net_events();
-
+*/
 	dbg_msg("port_counters = %p\n", port_counters);
 	dbg_msg("pending_tx_lock = %p, pending_tx = %p\n", port_counters,
 		pending_tx);
-- 
1.7.10.4

