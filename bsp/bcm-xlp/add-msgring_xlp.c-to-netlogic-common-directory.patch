From a77f8b12b0fb35fcb916ad1fdd597e108356f20f Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 8 Jun 2010 15:37:55 -0700
Subject: [PATCH 057/761] add msgring_xlp.c to netlogic/common directory

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/common/msgring_xlp.c |  475 +++++++++++++++++++++++++++++++
 1 file changed, 475 insertions(+)
 create mode 100644 arch/mips/netlogic/common/msgring_xlp.c

diff --git a/arch/mips/netlogic/common/msgring_xlp.c b/arch/mips/netlogic/common/msgring_xlp.c
new file mode 100644
index 0000000..01a2e0f
--- /dev/null
+++ b/arch/mips/netlogic/common/msgring_xlp.c
@@ -0,0 +1,475 @@
+/*********************************************************************
+
+  Copyright 2003-2010 Netlogic Microsystem, Inc. ( Netlogic ). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#NLM_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+
+#define OUTQ_EN		0x8000000000000000ULL
+#define SPILL_EN 	0x4000000000000000ULL
+#define INT_EN 		0x0800000000000000ULL
+
+#define OQ_BASE_START(x) ( ( x>> 5) & 0x1fULL)
+#define OQ_BASE_END(x)   ( ( (x >>5)  & 0x1fULL) << 5)
+#define OQ_BASE_1K(x)    ( ( (x >> 10) & 0x1fULL) << 10)
+
+enum cpu_io_credit {
+	CPU_CREDIT		=4,
+	CPU_GMAC_TX_CREDIT	=4, 
+	CPU_GMAC_RX_CREDIT	= 4,
+	CPU_POE_CREDIT		= 4,
+	CPU_CMP_CREDIT		= 4,
+	CPU_CRYPTO_CREDIT 	= 4,
+	CPU_RSA_ECC_CREDIT	= 4,
+	CPU_GDX_CREDIT 		= 4,
+	CPU_PCIE0_CREDIT 	= 2 
+};
+
+/*********************************************************************
+ ********************************************************************/
+static void config_cpu_io_pushq_credit(uint8_t cpu)
+{	
+	uint8_t i;
+	uint8_t s_qid = cpu;
+
+
+//	nlm_hal_write_outq_config(qid, val);
+	
+	//cpu to nae tx interface q
+	for( i = 0; i < 18; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_NET_TX_VC_BASE+i,  CPU_GMAC_TX_CREDIT);
+	}
+
+	// nae tx to cpu free out
+
+	//cpu to nae rx freein interface q
+	for( i = 0; i < 18; i ++)
+	{
+                nlm_hal_write_credit( s_qid, XLP_NET_RX_VC_BASE + i,  CPU_GMAC_RX_CREDIT);
+	}
+
+	//setup cpu to 8 poe vc
+	for(i = 0; i < 8; i++)
+	{
+		nlm_hal_write_credit( s_qid, XLP_POE_VC_BASE + i,  CPU_POE_CREDIT);
+	}
+
+	//setup cpu to 8 compression engine vc
+	for(i = 0; i < 8; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_CMP_VC_BASE + i,  CPU_CMP_CREDIT);
+	}
+
+	//setup cpu to 16 crypto engine vc
+	for(i = 0; i < 8; i++)
+	{
+		nlm_hal_write_credit( s_qid, XLP_CRYPTO_VC_BASE + i,  CPU_CRYPTO_CREDIT);
+	}
+
+	//setup cpu to RSA/ECC engine
+	
+	for(i = 0; i < 8; i++)
+	{
+		nlm_hal_write_credit( s_qid, XLP_RSA_ECC_VC_BASE + i,  CPU_RSA_ECC_CREDIT);
+	}
+
+	//setup cpu to Data transfer engine
+	for(i = 0; i < 8; i++)
+	{
+		nlm_hal_write_credit( s_qid, XLP_GDX_VC_BASE + i,  CPU_GDX_CREDIT);
+	}
+
+	//setup cpu to 2 PCIe0 vc
+	for(i = 0; i < 2; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_PCIE0_VC_BASE + i,  CPU_PCIE0_CREDIT);
+	}
+
+        //setup cpu to 2 PCIe1 vc
+	for(i = 0; i < 2; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_PCIE1_VC_BASE + i,  CPU_PCIE0_CREDIT);
+	}
+
+	//setup cpu to 2 PCIe2 vc
+	for(i = 0; i < 2; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_PCIE2_VC_BASE + i,  CPU_PCIE0_CREDIT);
+	}
+
+       //setup cpu to 2 PCIe3 vc
+
+	for(i = 0; i < 2; i++)
+	{
+        	nlm_hal_write_credit( s_qid, XLP_PCIE3_VC_BASE + i,  CPU_PCIE0_CREDIT);
+	}
+
+}
+
+/*********************************************************************
+ ********************************************************************/
+static void config_io_io_outq_credit()
+{
+	//security block to poe
+	nlm_hal_write_credit( XLP_RSA_ECC_VC_BASE, XLP_POE_VC_BASE,  CPU_PCIE0_CREDIT);
+
+        //security block to nae
+        nlm_hal_write_credit( XLP_RSA_ECC_VC_BASE, XLP_NET_TX_VC_BASE,  CPU_PCIE0_CREDIT);
+
+	//poe to nae
+        nlm_hal_write_credit( XLP_POE_VC_BASE, XLP_NET_TX_VC_BASE, 18*CPU_GMAC_TX_CREDIT);
+
+	//nae to poe
+        nlm_hal_write_credit( XLP_NET_TX_VC_BASE, XLP_POE_VC_BASE, 18*CPU_GMAC_RX_CREDIT);
+
+	
+}
+
+/*********************************************************************
+ ********************************************************************/
+static void config_io_cpu_pushq_credit(uint8_t cpu, uint8_t thread, uint8_t vc)
+{
+	uint8_t d_qid = cpu << 4 | thread << 2 | vc;
+	uint8_t i;
+
+	if(d_qid >=256)
+	{
+		printk("Err d_qid: cpu %d thread %d vc %d",cpu, thread, vc);
+		return;
+	}
+/*
+	//PCIE0 station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_PCIE0, d_qid, CPU_PCIE0_CREDIT);
+	//PCIE1 station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_PCIE1, d_qid, CPU_PCIE0_CREDIT);
+	//PCIE2 station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_PCIE2, d_qid, CPU_PCIE0_CREDIT);
+	//PCIE3 station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_PCIE3, d_qid, CPU_PCIE0_CREDIT);
+*/
+	//Data Transfer and RAID station to vCPU	
+	nlm_hal_write_credit( XLP_STNID_GDX, d_qid, CPU_GDX_CREDIT);
+	//RSA_ECC station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_RSA_ECC, d_qid, CPU_RSA_ECC_CREDIT);
+	//SAE CRYPTO station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_CRYPTO, d_qid, CPU_CRYPTO_CREDIT);
+	//CMP station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_CMP, d_qid, CPU_CMP_CREDIT);
+	//POE station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_POE, d_qid, 18 * CPU_POE_CREDIT);
+	//NAE station to vCPU		
+	nlm_hal_write_credit( XLP_STNID_NAE_TX, d_qid, 18 * CPU_GMAC_TX_CREDIT);
+}
+
+/*********************************************************************
+ * dump_outq
+ *
+ * dump the outq config register value for debug purpose
+ ********************************************************************/
+void dump_outq()
+{
+	int i;
+        uint64_t val = 0;
+
+	printk("n\FMN output_q config: index	value\n");
+        // 0 - 127 cpu push outputq , 8 cpu, each cpu has 4 threads, each thread has 4 vcs
+        for( i = 0; i < 128; i++ ) { 
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+        // 128-255 cpu pop queue
+        for( i = 128; i < 256; i++ ) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+        // 256-257 PCIe0
+        for( i = XLP_PCIE0_VC_BASE; i <= XLP_PCIE0_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+        // 258-259 PCIe1
+        for( i = XLP_PCIE1_VC_BASE; i <= XLP_PCIE1_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 260-261 PCIe2
+        for( i = XLP_PCIE2_VC_BASE; i <= XLP_PCIE2_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 262-263 PCIe3
+        for( i = XLP_PCIE3_VC_BASE; i <= XLP_PCIE3_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+ 	}
+
+        // 264-271 Data Transfer and RAID engine
+        for( i = XLP_GDX_VC_BASE; i <= XLP_GDX_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 272-280 RSA/ECC security engine
+        for( i = XLP_RSA_ECC_VC_BASE; i <= XLP_RSA_ECC_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 281-296 SAE crypto engine
+        for( i = XLP_CRYPTO_VC_BASE; i <= XLP_CRYPTO_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 297-304 Data compression enigne
+        for( i = XLP_CMP_VC_BASE; i <= XLP_CMP_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 384-391 packet order enigne
+        for( i = XLP_CMP_VC_BASE; i <= XLP_CMP_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 476-999 NAE TX interface
+        for( i = XLP_NET_TX_VC_BASE; i <= (XLP_NET_TX_VC_BASE + 18); i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+
+        // 1000-1019 NAE RX interface
+        for( i = XLP_NET_RX_VC_BASE; i <= XLP_NET_RX_VC_LIMIT; i++) {
+                val = nlm_hal_read_outq_config( i );
+		printk("\t%d\t%llx\n", i, val);
+	}
+}
+
+/*********************************************************************
+ * setup_outq
+ *
+ * In xlp, there is 1024 receive message queues for fmn network. The 
+ * queue, allocated to cpu and high speed IO device, identified by 
+ * their vc number. When A send B a FMN message, receive VC is dest 
+ * number A need addressing. This function is to config each queue with 
+ * initial defaule value
+ ********************************************************************/
+static void setup_outq()
+{
+	uint16_t i, q_base;
+	uint64_t val;
+
+	// 0 - 127 cpu push outputq , 8 cpu, each cpu has 4 threads, each thread has 4 vcs
+	q_base = 0;
+	val = OUTQ_EN|INT_EN|((uint64_t)HWM_NON_EMPTY<<55)|(((uint64_t)LVL_INT_HIGH_WM)<<53);
+	for( i = 0; i < 128; i++ )
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+		nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+//		printk("\t%d\t%d\t%llx\n", i, q_base, val);
+	}
+	// 128-255 cpu pop queue 
+	val = OUTQ_EN|INT_EN|((uint64_t)HWM_NON_EMPTY<<55)|(((uint64_t)LVL_INT_HIGH_WM)<<53);
+	for( i = 128; i < 256; i++ ) 
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+	// 256-257 PCIe0
+	val = OUTQ_EN;
+	for( i = XLP_PCIE0_VC_BASE; i <= XLP_PCIE0_VC_LIMIT; i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+        // 258-259 PCIe1
+	val = OUTQ_EN;
+        for( i = XLP_PCIE1_VC_BASE; i <= XLP_PCIE1_VC_LIMIT; i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+        // 260-261 PCIe2
+	val = OUTQ_EN;
+        for( i = XLP_PCIE2_VC_BASE; i <= XLP_PCIE2_VC_LIMIT; i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+        // 262-263 PCIe3
+	val = OUTQ_EN;
+        for( i = XLP_PCIE3_VC_BASE; i <= XLP_PCIE3_VC_LIMIT; i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+	// 264-271 Data Transfer and RAID engine
+	val = OUTQ_EN;
+	for( i = XLP_GDX_VC_BASE; i <= XLP_GDX_VC_LIMIT; i++)
+        {
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+	        nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+	// 272-280 RSA/ECC security engine
+	val = OUTQ_EN;
+	for( i = XLP_RSA_ECC_VC_BASE; i <= XLP_RSA_ECC_VC_LIMIT; i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+	// 281-296 SAE crypto engine
+	val = OUTQ_EN;
+	for( i = XLP_CRYPTO_VC_BASE; i <= XLP_CRYPTO_VC_LIMIT; i++)
+        {
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+	        nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+	// 297-304 Data compression enigne
+	val = OUTQ_EN;
+	for( i = XLP_CMP_VC_BASE; i <= XLP_CMP_VC_LIMIT; i++)
+        {
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+	        nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+	// 384-391 packet order enigne
+	val = OUTQ_EN;
+	for( i = XLP_CMP_VC_BASE; i <= XLP_CMP_VC_LIMIT; i++)
+        {
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+	        nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+	// 476-999 NAE TX interface
+	val = OUTQ_EN;
+	for( i = XLP_NET_TX_VC_BASE; i <= (XLP_NET_TX_VC_BASE + 18); i++)
+	{
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+                nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+	// 1000-1019 NAE RX interface
+	val = OUTQ_EN;
+	for( i = XLP_NET_RX_VC_BASE; i <= XLP_NET_RX_VC_LIMIT; i++)
+        {
+		val |= OQ_BASE_START(q_base) |  OQ_BASE_END((q_base)) |OQ_BASE_1K(q_base) ;
+	        nlm_hal_write_outq_config(i, val);
+		q_base += 32;
+	}
+
+}
+
+/*********************************************************************
+ * nlm_hal_fmn_init
+ *
+ * setup 1024 outq, set credit from cpu to io,  io to io, and io to 
+ * cpu
+ ********************************************************************/
+void nlm_hal_fmn_init( uint32_t cpu_mask)
+{
+	int thrid, i, j, k;
+	//setup outq
+	setup_outq();
+
+	//verify out_q config
+//	dump_outq();
+
+	//config cpu(0, 0, 0) to io credit
+	//config_cpu_io_pushq_credit(0, 0, 0);
+	//config_cpu_io_pushq_credit(0, 0, 1);
+	//config_io_io_pushq_credit();
+	//config_nae_cpu_pushq_credit(0, 0, 1);
+	// initial cpu to io q, 8 cpu, each has 4 thread, each thread has 4 vc
+	for( i = 0; i < 8; i++){
+		if( cpu_mask & (0xf <<(i*4)))
+		{
+			//if cpu online, we need init queue
+			config_cpu_io_pushq_credit( i );
+		}
+		
+	}
+
+	for( i = 0; i < 8; i++){
+		for( j = 0; j < 4; j++){
+			thrid =  i<<2 | j;
+			if( cpu_mask & (1 << thrid))
+			{
+				for (k = 0; k < 4; k++)
+				{
+					//if cpu online, we need init queue
+					config_io_cpu_pushq_credit(i, j, k);
+				}
+			}
+		}
+	}
+
+	config_io_io_outq_credit();
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
-- 
1.7.10.4

