From 7b373b8914c0d48380a81decb99955d4e58ab168 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 25 Apr 2013 12:39:26 +0800
Subject: [PATCH 332/762] Changes to compile without PCI enabled and other MSI tweaks

Some IRT specific changes were placed in pci files, which prevented compilation
without CONFIG_PCI. CONFIG_PCI_MSI_XLR is not used correctly.

Automatically select MSI for XLP as this is not an optional feature for XLP.
Making the old XLR MSI select only if cpu is XLR/XLS

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                        |    2 +
 arch/mips/include/asm/netlogic/xlp_irq.h |    7 +-
 arch/mips/netlogic/xlp/irq.c             |   22 ++++--
 arch/mips/netlogic/xlp/on_chip.c         |  129 ++++++++++++++++++++++++++++++
 arch/mips/pci/pci-xlp.c                  |  129 ------------------------------
 drivers/pci/pci.h                        |    2 +-
 drivers/pci/quirks.c                     |    2 +-
 include/linux/pci.h                      |    4 +-
 8 files changed, 152 insertions(+), 145 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 636c027..194ef69 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -794,6 +794,7 @@ config NLM_XLP_EVP_BOARD
         select SYS_HAS_CPU_XLP
         select SYS_SUPPORTS_SMP
         select HW_HAS_PCI
+	select ARCH_SUPPORTS_MSI
         select SWAP_IO_SPACE
         select SYS_SUPPORTS_32BIT_KERNEL
         select SYS_SUPPORTS_64BIT_KERNEL
@@ -879,6 +880,7 @@ config NLM_XLP_BOARD
 	select SYS_HAS_CPU_XLP
 	select SYS_SUPPORTS_SMP
 	select HW_HAS_PCI
+	select ARCH_SUPPORTS_MSI
 	select SWAP_IO_SPACE
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 39d6e1a..a4bb382 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -185,8 +185,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
  * This is a kludge to keep NR_IRQS == 256 and can be expanded later
  * We are using IRQ 192 - 255 for MSI/MSI-X
  * */
-#define CONFIG_PCI_MSI_XLP	1
-#define CONFIG_PCI_MSIX_XLP	1
 
 #define XLP_PIC_IRTREG_START 0xB4
 #define XLP_ITE_ENTRIES		8
@@ -199,7 +197,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_BDF_BASE(b,d,f)	(0x18000000 + ((b) << 20) + ((d) << 15) + ((f) << 12))
 #define XLP_MAX_SLOTS		4	/* Only 4 slots now */
 #define XLP_PCIE_CTRL_DEVFN(node, ctr)	PCI_DEVFN((node + 1), ctr)
-#ifdef CONFIG_PCI_MSI_XLP
+
+#ifdef CONFIG_PCI_MSI
 #define XLP_MSI_MM_CAP		3	/* Multiple message capability */
 #define XLP_MSI_PER_SLOT	(1 << XLP_MSI_MM_CAP)
 #define XLP_MSI_IRQ_OFFSET	192	/* Note IRQ not IRT */
@@ -207,9 +206,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_MSI_INDEX_START XLP_MSI_IRQ_START(0)
 #define XLP_MSI_INDEX_END (XLP_MSI_IRQ_START(XLP_MAX_SLOTS) - 1)// 31 vectors
 #define XLP_MSI_TO_CTRL_FN(msi) (((msi) >> 3) & 3)
-#endif
 
-#ifdef CONFIG_PCI_MSIX_XLP
 #define XLP_MSIX_PER_SLOT	8
 #define XLP_MSIX_IRQ_OFFSET	(XLP_MSI_IRQ_OFFSET + XLP_MAX_SLOTS * XLP_MSIX_PER_SLOT) /* 192 + (4 * 8) => 224 */
 #define XLP_MSIX_TO_CTRL_FN(msix) (((msix) >> 3) & 3)
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 4208f05..e7eb065 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -59,6 +59,12 @@ THE POSSIBILITY OF SUCH DAMAGE.
 /* Externs */
 extern void nlm_common_timer_interrupt(struct pt_regs *, int);
 extern void nlm_xlp_msgring_int_handler(int , struct pt_regs *);
+extern int xlp_ctrl_fn_from_dev(const struct pci_dev *);
+extern const struct cpumask *xlp_closest_match_cpumask(struct cpumask *);
+extern void xlp_intx_enable(int);
+extern void xlp_intx_disable(int);
+extern void xlp_set_cpumask(const struct cpumask *m, int irt);
+#if defined CONFIG_PCI_MSI
 extern int xlp_msi_status_clear(struct pci_dev *, int);
 extern int xlp_msi_enable(struct pci_dev *, u32);
 extern int xlp_msi_base_vector(struct pci_dev *);
@@ -68,17 +74,13 @@ extern void xlp_msi_disable(int, int);
 extern u32 xlp_msi_set_mask(int, int, int);
 volatile const void *xlp_msix_addr_start(int);
 volatile const void *xlp_msi_addr_start(int);
-extern int xlp_ctrl_fn_from_dev(const struct pci_dev *);
 extern u32 xlp_msix_status_clear(int);
 extern u32 xlp_msix_set_mask(int, int, int);
 extern int xlp_msix_enable(struct pci_dev *);
 extern void xlp_msix_disable(int);
-extern const struct cpumask *xlp_closest_match_cpumask(struct cpumask *);
-extern void xlp_set_cpumask(const struct cpumask *m, int irt);
 void mask_msi_irq(unsigned int);
 void unmask_msi_irq(unsigned int);
-extern void xlp_intx_enable(int);
-extern void xlp_intx_disable(int);
+#endif
 
 /* own variables */
 
@@ -93,6 +95,7 @@ static volatile uint64_t xlp_irq_mask;
  */
 spinlock_t xlp_pic_lock = SPIN_LOCK_UNLOCKED;
 EXPORT_SYMBOL(xlp_pic_lock);
+#if defined CONFIG_PCI_MSI
 /*
  * This bitmap keeps track of the MSI vectors allocated from
  * XLP_MSIX_IRQ_START(x)
@@ -102,6 +105,7 @@ struct msix_alloc_bitmap {
 	u32 count;	/* #of bits set at any point of time */
 };
 static struct msix_alloc_bitmap msix_vec[XLP_MAX_SLOTS];
+#endif
 
 /*
  * There are two data structures pivotal for interrupt delivery mechanism
@@ -855,7 +859,7 @@ void destroy_irq(unsigned int irq)
     /* no-op */
 }
 
-#ifdef CONFIG_PCI_MSI_XLP
+#ifdef CONFIG_PCI_MSI
 
 /*
  * The MSI and MSI-X functionality is supported only by the PCIe Controller.
@@ -1242,6 +1246,7 @@ asmlinkage void plat_irq_dispatch(void)
 		bitmap = rvec_map[rvec].bitmap;
 		spin_unlock_irqrestore(&xlp_pic_lock, flags);
 		switch(base_irq) {
+#if defined CONFIG_PCI_MSI
 		/* These are not MSIs, but IRT #s */
 		case XLP_PCIE_LINK_IRQ(0) ... XLP_PCIE_LINK_IRQ(3):
 			/* Here fn # of controller is easily calculated
@@ -1263,6 +1268,7 @@ asmlinkage void plat_irq_dispatch(void)
 			base_irq = XLP_MSIX_IRQ_START(fn);
 			/* now handle it as any other interrupt */
 			break;
+#endif
 		default:
 			break;
 		}
@@ -1291,6 +1297,7 @@ int nlm_xlp_request_irq(int irq)
 }
 EXPORT_SYMBOL(nlm_xlp_request_irq);
 
+#if defined CONFIG_PCI_MSI
 #ifdef arch_setup_msi_irqs
 /*
  * Arch specific setup functions and helpers
@@ -1471,6 +1478,7 @@ int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 }
 EXPORT_SYMBOL(arch_setup_msi_irqs);
 #endif
+#endif
 
 void __init init_nlm_common_irqs(void)
 {
@@ -1479,7 +1487,7 @@ void __init init_nlm_common_irqs(void)
 	for (i = 0; i < XLP_IRQ_MAX; i++) {	// IRQ : 0 - 167
 		set_irq_chip(i, &nlm_irq_pic);
 	}
-#ifdef CONFIG_PCI_MSI_XLP
+#ifdef CONFIG_PCI_MSI
 	for (i = XLP_MSI_INDEX_START; i <= XLP_MSI_INDEX_END; i++) {
 		set_irq_chip(i, &nlm_msi_pic);
 	}
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 015ae7a..ae7a01e 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -453,6 +453,134 @@ void enable_msgconfig_int(void)
 	msgrng_access_disable(flags);
 }
 
+/*
+ * Initializes PIC ITE entries PRM 9.5.6.26
+ * XLP restricts CPU affinity to 8 groups. They are,
+ * 0 =>	Only cpu0/thread0; mask = 1
+ * 1 => All CPUs/threads and nodes; mask = (~0 & online_cpu_mask) on all nodes
+ * 2 => cpu0-1 on all nodes. mask = 0x000000ff& online_cpu_mask  on all nodes
+ * 3 => cpu2-3 on all nodes; mask = 0x0000ff00 & online_cpu_mask on all nodes
+ * 4 => cpu4-5 on all nodes; mask = 0x00ff0000 & online_cpu_mask on all nodes
+ * 5 => cpu6-7 on all nodes; mask = 0xff000000 & online_cpu_mask on all nodes
+ * 6 => cpu0-15 on all nodes; mask = 0x0000ffff & online_cpu_mask on all nodes
+ * 7 => cpu15-31 on all nodes; mask = 0xffff0000 & online_cpu_mask on all nodes
+ *
+ * These are programmer defined groups and can be changed as warranted.
+ */
+static struct cpumask xlp_ite_cpumask[XLP_ITE_ENTRIES];
+void xlp_pic_ite_init(void)
+{
+	int i;
+	struct cpumask m;
+	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
+	char buf[140];
+	u64 bitmask = 0;
+
+	printk(KERN_WARNING "Setting ITE entries only for 0-31 (Node 0) CPUs!\n");
+	cpumask_clear(&m);
+	/* We manipulate only NODE0 ITE entries here */
+	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
+		cpumask_clear(&xlp_ite_cpumask[i]);
+	}
+	cpumask_set_cpu(cpumask_first(cpu_online_mask), &xlp_ite_cpumask[0]);
+
+	/* Set 0-31 cpus, if present in cpu_online mask */
+	for (i = cpumask_first(cpu_online_mask); i < 32; ) {
+		bitmask |= (1ULL << i);
+		i = cpumask_next(i, cpu_online_mask);
+	}
+	cpumask_scnprintf(buf, 140, cpu_online_mask); fdebug("cpu_online_mask -> %s\n", buf);
+	cpumask_copy(&xlp_ite_cpumask[1], cpu_online_mask);
+
+	/* Set 0-7 cpus */
+	for (i = 0; i < 8; i++) {
+		cpumask_set_cpu(i, &m);
+	}
+	/* logical and with cpuonline mask to get the actual mask */
+	cpumask_and(&xlp_ite_cpumask[2], &m, cpu_online_mask);
+	cpumask_shift_left(&xlp_ite_cpumask[3], &m, 8);
+	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], cpu_online_mask);
+	cpumask_shift_left(&xlp_ite_cpumask[4], &m, 16);
+	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], cpu_online_mask);
+	cpumask_shift_left(&xlp_ite_cpumask[5], &m, 24);
+	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], cpu_online_mask);
+
+	cpumask_shift_left(&xlp_ite_cpumask[6], &m, 8);
+	cpumask_or(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], &m);
+	cpumask_shift_left(&xlp_ite_cpumask[7], &xlp_ite_cpumask[6], 16);
+	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], cpu_online_mask);
+
+
+	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
+		cpumask_scnprintf(buf, 140, &xlp_ite_cpumask[i]);
+		printk(KERN_DEBUG "Supported CPUMASK (%d) -> %s\n", i, buf);
+	}
+
+	/* Right shift by 1 is required by HAL, _DO_NOT_REMOVE_ */
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0x94 >> 1, (0x00000001 & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0x98 >> 1, (0xffffffff & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0x9C >> 1, (0x000000ff & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA0 >> 1, (0x0000ff00 & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA4 >> 1, (0x00ff0000 & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA8 >> 1, (0xff000000 & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0xAC >> 1, (0x0000ffff & bitmask));
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0xB0 >> 1, (0xffff0000 & bitmask));
+	/* We don't populate redirection to other nodes now */
+}
+
+/*
+ * This function returns closest match cpumask among the supported bitmasks
+ * in XLP
+ * Logic is moot, need to improve it later.
+ * XXX
+ *
+ * @m	: user supplied cpumask
+ */
+const struct cpumask *xlp_closest_match_cpumask(struct cpumask *m)
+{
+	int i;
+
+	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
+		if (cpumask_equal(m, &xlp_ite_cpumask[i])) {
+			return &xlp_ite_cpumask[i];
+		}
+	}
+	return NULL;
+}
+
+/*
+ * This function sets the cpumask for an interrupt vector
+ * @m	: CPU mask resulting from xlp_closest_match_cpumask() call
+ */
+void xlp_set_cpumask(const struct cpumask *m, int irt)
+{
+	int i;
+	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
+	u64 val;
+	u32 offset = ((XLP_PIC_IRTREG_START + (irt << 1)) >> 1);	// Hal requires this nasty right shift
+
+	/* We set the following in IRT entry
+	 * 28 : clear to indicate global delivery
+	 * 19 : clear to indicate DB selects ITE
+	 * 16-18 : set to indicate ITE
+	 * 0-15 : Clear
+	 */
+	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
+		if (m != &xlp_ite_cpumask[i]) {
+			continue;
+		}
+		val = nlm_hal_read_64bit_reg(xlp_pic_base, offset);
+		val &= ~((1 << 28) | (1 << 19) | (0x7 << 16) | 0xffff);
+		val |= (i << 16);
+		//fdebug("Writing val = %#llx\n", val);
+		nlm_hal_write_64bit_reg(xlp_pic_base, offset, val);
+		return;
+	}
+	printk(KERN_WARNING "Failed to program IRT entry %d\n", irt);
+	return;
+}
+
 
 /*********************************************************************
  *  pic_init
@@ -477,6 +605,7 @@ static void pic_init(void)
 
 	/* On XLP, MSGRING config register is per hw-thread */
 	enable_msgconfig_int();
+	xlp_pic_ite_init();// Initialize even if xlp is passed nopci option
 }
 
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index b3f76bc..9b534f1 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -726,140 +726,11 @@ static int __init xlp_nopci_setup(char *str)
 }
 __setup("xlp_nopci", xlp_nopci_setup);
 
-/*
- * Initializes PIC ITE entries PRM 9.5.6.26
- * XLP restricts CPU affinity to 8 groups. They are,
- * 0 =>	Only cpu0/thread0; mask = 1
- * 1 => All CPUs/threads and nodes; mask = (~0 & online_cpu_mask) on all nodes
- * 2 => cpu0-1 on all nodes. mask = 0x000000ff& online_cpu_mask  on all nodes
- * 3 => cpu2-3 on all nodes; mask = 0x0000ff00 & online_cpu_mask on all nodes
- * 4 => cpu4-5 on all nodes; mask = 0x00ff0000 & online_cpu_mask on all nodes
- * 5 => cpu6-7 on all nodes; mask = 0xff000000 & online_cpu_mask on all nodes
- * 6 => cpu0-15 on all nodes; mask = 0x0000ffff & online_cpu_mask on all nodes
- * 7 => cpu15-31 on all nodes; mask = 0xffff0000 & online_cpu_mask on all nodes
- *
- * These are programmer defined groups and can be changed as warranted.
- */
-static struct cpumask xlp_ite_cpumask[XLP_ITE_ENTRIES];
-void xlp_pic_ite_init(void)
-{
-	int i;
-	struct cpumask m;
-	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
-	char buf[140];
-	u64 bitmask = 0;
-
-	printk(KERN_WARNING "Setting ITE entries only for 0-31 (Node 0) CPUs!\n");
-	cpumask_clear(&m);
-	/* We manipulate only NODE0 ITE entries here */
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_clear(&xlp_ite_cpumask[i]);
-	}
-	cpumask_set_cpu(cpumask_first(cpu_online_mask), &xlp_ite_cpumask[0]);
-
-	/* Set 0-31 cpus, if present in cpu_online mask */
-	for (i = cpumask_first(cpu_online_mask); i < 32; ) {
-		bitmask |= (1ULL << i);
-		i = cpumask_next(i, cpu_online_mask);
-	}
-	cpumask_scnprintf(buf, 140, cpu_online_mask); fdebug("cpu_online_mask -> %s\n", buf);
-	cpumask_copy(&xlp_ite_cpumask[1], cpu_online_mask);
-
-	/* Set 0-7 cpus */
-	for (i = 0; i < 8; i++) {
-		cpumask_set_cpu(i, &m);
-	}
-	/* logical and with cpuonline mask to get the actual mask */
-	cpumask_and(&xlp_ite_cpumask[2], &m, cpu_online_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[3], &m, 8);
-	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], cpu_online_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[4], &m, 16);
-	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], cpu_online_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[5], &m, 24);
-	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], cpu_online_mask);
-
-	cpumask_shift_left(&xlp_ite_cpumask[6], &m, 8);
-	cpumask_or(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], &m);
-	cpumask_shift_left(&xlp_ite_cpumask[7], &xlp_ite_cpumask[6], 16);
-	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], cpu_online_mask);
-	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], cpu_online_mask);
-
-
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_scnprintf(buf, 140, &xlp_ite_cpumask[i]);
-		printk(KERN_DEBUG "Supported CPUMASK (%d) -> %s\n", i, buf);
-	}
-
-	/* Right shift by 1 is required by HAL, _DO_NOT_REMOVE_ */
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x94 >> 1, (0x00000001 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x98 >> 1, (0xffffffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x9C >> 1, (0x000000ff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA0 >> 1, (0x0000ff00 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA4 >> 1, (0x00ff0000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA8 >> 1, (0xff000000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xAC >> 1, (0x0000ffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xB0 >> 1, (0xffff0000 & bitmask));
-	/* We don't populate redirection to other nodes now */
-}
-
-/*
- * This function returns closest match cpumask among the supported bitmasks
- * in XLP
- * Logic is moot, need to improve it later.
- * XXX
- *
- * @m	: user supplied cpumask
- */
-const struct cpumask *xlp_closest_match_cpumask(struct cpumask *m)
-{
-	int i;
-
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		if (cpumask_equal(m, &xlp_ite_cpumask[i])) {
-			return &xlp_ite_cpumask[i];
-		}
-	}
-	return NULL;
-}
-
-/*
- * This function sets the cpumask for an interrupt vector
- * @m	: CPU mask resulting from xlp_closest_match_cpumask() call
- */
-void xlp_set_cpumask(const struct cpumask *m, int irt)
-{
-	int i;
-	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
-	u64 val;
-	u32 offset = ((XLP_PIC_IRTREG_START + (irt << 1)) >> 1);	// Hal requires this nasty right shift
-
-	/* We set the following in IRT entry
-	 * 28 : clear to indicate global delivery
-	 * 19 : clear to indicate DB selects ITE
-	 * 16-18 : set to indicate ITE
-	 * 0-15 : Clear
-	 */
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		if (m != &xlp_ite_cpumask[i]) {
-			continue;
-		}
-		val = nlm_hal_read_64bit_reg(xlp_pic_base, offset);
-		val &= ~((1 << 28) | (1 << 19) | (0x7 << 16) | 0xffff);
-		val |= (i << 16);
-		//fdebug("Writing val = %#llx\n", val);
-		nlm_hal_write_64bit_reg(xlp_pic_base, offset, val);
-		return;
-	}
-	printk(KERN_WARNING "Failed to program IRT entry %d\n", irt);
-	return;
-}
-
 static int __init pcibios_init(void)
 {
 	unsigned long phys = 0;
 	unsigned long size = 0;
 
-	xlp_pic_ite_init();// Initialize even if xlp is passed nopci option
 	if (xlp_nopci) return 0;
 
 	/* Bootloader assigns PCI resources */
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index d254eb0..d6e7ea6 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -141,7 +141,7 @@ extern raw_spinlock_t pci_lock;
 
 extern unsigned int pci_pm_d3_delay;
 
-#if defined(CONFIG_PCI_MSI) || defined(CONFIG_PCI_MSI_XLR)
+#if defined(CONFIG_PCI_MSI)
 void pci_no_msi(void);
 extern void pci_msi_init_pci_dev(struct pci_dev *dev);
 #else
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index e473f92..ce042c4 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -2162,7 +2162,7 @@ static void __devinit quirk_tile_plx_gen1(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_PLX, 0x8624, quirk_tile_plx_gen1);
 #endif /* CONFIG_TILE */
 
-#if defined(CONFIG_PCI_MSI) || defined(CONFIG_PCI_MSI_XLR)
+#if defined(CONFIG_PCI_MSI)
 /* Some chipsets do not support MSI. We cannot easily rely on setting
  * PCI_BUS_FLAGS_NO_MSI in its bus flags because there are actually
  * some other busses controlled by the chipset even if Linux is not
diff --git a/include/linux/pci.h b/include/linux/pci.h
index a82e861..49b50cf 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -341,7 +341,7 @@ struct pci_dev {
 	int rom_attr_enabled;		/* has display of the rom attribute been enabled? */
 	struct bin_attribute *res_attr[DEVICE_COUNT_RESOURCE]; /* sysfs file for resources */
 	struct bin_attribute *res_attr_wc[DEVICE_COUNT_RESOURCE]; /* sysfs file for WC mapping of resources */
-#if defined(CONFIG_PCI_MSI) || defined(CONFIG_PCI_MSI_XLR)
+#if defined(CONFIG_PCI_MSI)
 	struct list_head msi_list;
 	struct kset *msi_kset;
 #endif
@@ -1019,7 +1019,7 @@ struct msix_entry {
 };
 
 
-#if (!defined(CONFIG_PCI_MSI) && !defined(CONFIG_PCI_MSI_XLR))
+#if !defined(CONFIG_PCI_MSI)
 static inline int pci_enable_msi_block(struct pci_dev *dev, unsigned int nvec)
 {
 	return -1;
-- 
1.7.0.4

