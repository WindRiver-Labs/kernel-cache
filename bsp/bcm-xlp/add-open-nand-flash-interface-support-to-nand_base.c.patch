From bcaeca8720637ba9eab05e3095900bc70934bef1 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 23 Mar 2011 17:10:46 -0700
Subject: [PATCH 267/761] add open nand flash interface support to nand_base.c
 and nand.h

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/nand/nand_base.c |   56 +++++++++++++++++++++++++++++++++++-
 include/linux/mtd/nand.h     |   64 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 119 insertions(+), 1 deletion(-)

diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 9e972dd..dac6368 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -46,6 +46,9 @@
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/leds.h>
+#ifdef CONFIG_NLM_XLP
+#include <linux/crc16.h>
+#endif
 #include <linux/io.h>
 #include <linux/mtd/partitions.h>
 
@@ -92,6 +95,41 @@ static struct nand_ecclayout nand_oob_128 = {
 		{.offset = 2,
 		 .length = 78} }
 };
+#ifdef CONFIG_NLM_XLP
+static u16 onfi_crc(u16 crc, unsigned char const *p, size_t len)
+{
+        int i;
+        while (len--) {
+                crc ^= *p++ << 8;
+                for (i = 0; i < 8; i++)
+                        crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+        }
+        return crc;
+}
+
+/*
+ * sanitize ONFI strings so we can safely print them
+ */
+static void sanitize_string(uint8_t *s, size_t len)
+{
+        ssize_t i;
+
+        /* null terminate */
+        s[len - 1] = 0;
+
+        /* remove non printable chars */
+        for (i = 0; i < len - 1; i++) {
+                if (s[i] < ' ' || s[i] > 127)
+                        s[i] = '?';
+        }
+	/* remove trailing spaces */
+	for (i = len - 1; i >= 0; i--) {
+		if (s[i] && s[i] != ' ')
+			break;
+		s[i] = 0;
+	}
+}
+#endif
 
 static int nand_manufacturer;
 
@@ -3109,12 +3147,28 @@ ident_done:
 	 */
 	chip->options |= NAND_NO_AUTOINCR;
 
+#ifdef CONFIG_NLM_XLP
+        /* Get chip options, preserve non chip based options */
+        chip->options &= ~NAND_CHIPOPTIONS_MSK;
+        chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
+        /* Check if chip is a not a samsung device. Do not clear the
+         * options for chips which are not having an extended id.
+         */
+        if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+                chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+ident_done:
+
+        /*
+         * Set chip as a default. Board drivers can override it, if necessary
+         */
+        chip->options |= NAND_NO_AUTOINCR;
+#endif
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
 			break;
 	}
-
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct!
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 432dd64..41a450a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -301,6 +301,70 @@ struct nand_onfi_params {
 
 #define ONFI_CRC_BASE	0x4F4E
 
+#ifdef CONFIG_NLM_XLP
+struct nand_onfi_params {
+	/* rev info and features block */
+	uint8_t		sig[4]; /* 'O' 'N' 'F' 'I'  */
+	uint16_t	revision;
+	uint16_t	features;
+	uint16_t	opt_cmd;
+	uint8_t		reserved[22];
+
+	/* manufacturer information block */
+	char		manufacturer[12];
+	char		model[20];
+	uint8_t		jedec_id;
+	uint16_t	date_code;
+	uint8_t		reserved2[13];
+
+	/* memory organization block */
+	uint32_t	byte_per_page;
+	uint16_t	spare_bytes_per_page;
+	uint32_t	data_bytes_per_ppage;
+	uint16_t	sparre_bytes_per_ppage;
+	uint32_t	pages_per_block;
+	uint32_t	blocks_per_lun;
+	uint8_t		lun_count;
+	uint8_t		addr_cycles;
+	uint8_t		bits_per_cell;
+	uint16_t	bb_per_lun;
+	uint16_t	block_endurance;
+	uint8_t		guaranteed_good_blocks;
+	uint16_t	guaranteed_block_endurance;
+	uint8_t		programs_per_page;
+	uint8_t		ppage_attr;
+	uint8_t		ecc_bits;
+	uint8_t		interleaved_bits;
+	uint8_t		interleaved_ops;
+        uint8_t		reserved3[13];
+	
+	/* electrical parameter block */
+	uint8_t		io_pin_capacitance_max;
+	uint16_t	async_timing_mode;
+	uint16_t	program_cache_timing_mode;
+	uint16_t	t_prog;
+	uint16_t	t_bers;
+	uint16_t	t_r;
+	uint16_t	t_ccs;
+	uint16_t	src_sync_timing_mode;
+	uint16_t	src_ssync_features;
+	uint16_t	clk_pin_capacitance_typ;
+	uint16_t	io_pin_capacitance_typ;
+	uint16_t	input_pin_capacitance_typ;
+	uint8_t		input_pin_capacitance_max;
+	uint8_t		driver_strenght_support;
+	uint16_t	t_int_r;
+	uint16_t	t_ald;
+	uint8_t		reserved4[7];
+
+	/* vendor */
+	uint8_t		reserved5[90];
+
+	uint16_t	crc;
+} __attribute__((packed));
+
+#define ONFI_CRC_BASE  0x4F4E
+#endif
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
-- 
1.7.10.4

