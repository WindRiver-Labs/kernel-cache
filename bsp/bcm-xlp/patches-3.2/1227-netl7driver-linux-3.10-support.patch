From 8a7d7b367f5672b2844288fc0ceaf21d5f72b994 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Mon, 16 Jun 2014 12:03:27 +0530
Subject: netl7driver: linux 3.10 support

Changes for 3.10 support. proc filesystem API has changed in 3.8 and struct
proc_dir_entry's internals are no longer accessible. Update netl7driver to
address this
   - Add proc_name field to struct nlm_device instead of accessing the name
     field of the proc entry
   - Use proc_create_data instead of create_proc_entry API
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/netl7driver/netl7driver.c b/drivers/misc/netlogic/netl7driver/netl7driver.c
index dc07ff3..04c4ef8 100755
--- a/drivers/misc/netlogic/netl7driver/netl7driver.c
+++ b/drivers/misc/netlogic/netl7driver/netl7driver.c
@@ -107,6 +107,7 @@ struct nlm_device
 #ifndef MP_SUPPORT
   pid_t owner_pid;
 #endif
+  char *proc_name;
   struct proc_dir_entry *proc_entry;
   unsigned long long sysmem_base;    /* chunk of system memory for this device */
   unsigned long long packetmem_base; /* chunk of packet memory for this device */
@@ -130,6 +131,14 @@ static void destroy_proc_entries (void);
 static int memory_manager_init (void);
 static void memory_manager_fini (void);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
+static inline void *
+PDE_DATA (struct inode *inode)
+{
+  return  PDE (inode)->data;
+}
+#endif
+
 #ifdef KERNEL_DEMO
 #include "./kerneldemo.c"
 #endif
@@ -196,6 +205,7 @@ nlm_pci_probe (struct pci_dev *nlm_dev, const struct pci_device_id *nlm_id)
   device_list[dev_id].type = type;
   device_list[dev_id].regmap_base = pci_resource_start (nlm_dev, 0);
   device_list[dev_id].regmap_size = pci_resource_len (nlm_dev, 0);
+  device_list[dev_id].proc_name = NULL;
   device_list[dev_id].proc_entry = NULL;
   spin_lock_init (&device_list[dev_id].lock);
 
@@ -218,6 +228,7 @@ nlm_pci_probe (struct pci_dev *nlm_dev, const struct pci_device_id *nlm_id)
           device_list[dev_id].type = type;
           device_list[dev_id].regmap_base = regmap_base;
           device_list[dev_id].regmap_size = regmap_size;
+          device_list[dev_id].proc_name = NULL;
           device_list[dev_id].proc_entry = NULL;
           spin_lock_init (&device_list[dev_id].lock);
         }
@@ -241,6 +252,7 @@ nlm_pci_probe (struct pci_dev *nlm_dev, const struct pci_device_id *nlm_id)
       device_list[dev_id].type = type;
       device_list[dev_id].regmap_base = regmap_base;
       device_list[dev_id].regmap_size = regmap_size;
+      device_list[dev_id].proc_name = NULL;
       device_list[dev_id].proc_entry = NULL;
       spin_lock_init (&device_list[dev_id].lock);
     }
@@ -251,7 +263,7 @@ nlm_pci_probe (struct pci_dev *nlm_dev, const struct pci_device_id *nlm_id)
   return 0;
 }
 
-static const struct __devinitdata pci_device_id netl7_pci_ids[] = 
+static const struct pci_device_id netl7_pci_ids[] = 
 {
   {PCI_DEVICE (NLM_PCI_VENDOR_ID, NLM_PCI_DEV_ID)},
   {PCI_DEVICE (NLM_PCI_VENDOR_ID, NLM_PCI_DEV_ID + 1)},
@@ -317,7 +329,7 @@ nlm_drv_module_init (void)
         NLM_VERB (": === Probed device no %d (%p) (%s) === \n",
                   i, &device_list[i], nlm_device_type_name[device_list[i].type]);
         NLM_VERB (":     proc_entry /proc/NetL7/%s\n",
-                  device_list[i].proc_entry->name);
+                  device_list[i].proc_name);
         NLM_VERB (":     register_map base = 0x%llx size = 0x%x\n",
                   device_list[i].regmap_base, device_list[i].regmap_size);
         NLM_VERB (":     system memory base = 0x%llx size = 0x%x\n",
@@ -414,7 +426,7 @@ nlm_device_info_show (struct seq_file *m, void *v)
 static int
 nlm_device_open (struct inode *inode, struct file *file)
 {
-  struct nlm_device *dev = PDE (inode)->data;
+  struct nlm_device *dev = PDE_DATA (inode);
   
   if (dev == NULL)
     return -EINVAL;
@@ -506,7 +518,7 @@ nlm_device_ioctl (struct file *file, unsigned int cmd, unsigned long arg)
       
     default:
       NLM_VERB (": ioctl code incorrect on %s by pid %d, ioctl=%d\n",
-                dev->proc_entry->name, current->pid, _IOC_TYPE(cmd));
+                dev->proc_name, current->pid, _IOC_TYPE(cmd));
       return -EFAULT;
     }
 
@@ -567,7 +579,7 @@ nlm_device_compat_ioctl (struct file *file, unsigned int cmd, unsigned long arg)
       
     default:
       NLM_VERB (": compat ioctl code incorrect on %s by pid %d, ioctl=%d\n",
-                dev->proc_entry->name, current->pid, _IOC_TYPE(cmd));
+                dev->proc_name, current->pid, _IOC_TYPE(cmd));
       return -EFAULT;
     }
 
@@ -630,7 +642,7 @@ nlm_device_mmap (struct file *file_p, struct vm_area_struct *vm_p)
 static int
 nlm_device_close (struct inode *inode, struct file *file)
 {
-  struct nlm_device *dev = PDE (inode)->data;
+  struct nlm_device *dev = PDE_DATA (inode);
   
   if (dev == NULL)
     return -EINVAL;
@@ -700,16 +712,15 @@ create_proc_entries ()
               break;
             }
           mars1_id++;
-          entry = create_proc_entry (buf, S_IFREG | S_IRUGO | S_IWUGO, 
-                                     nlm_proc_root);
+          entry = proc_create_data (buf, S_IFREG | S_IRUGO | S_IWUGO, 
+                       nlm_proc_root, &device_proc_fops, &device_list[i]);
           if (entry == NULL)
             {
               failure = 1;
               break;
             }
 
-          entry->proc_fops = &device_proc_fops;
-          entry->data = &device_list[i];
+          device_list[i].proc_name = kstrdup(buf, GFP_KERNEL);
           device_list[i].proc_entry = entry;
           break;
           
@@ -720,16 +731,15 @@ create_proc_entries ()
               break;
             }
           mars2_id++;
-          entry = create_proc_entry (buf, S_IFREG | S_IRUGO | S_IWUGO, 
-                                     nlm_proc_root);
+          entry = proc_create_data (buf, S_IFREG | S_IRUGO | S_IWUGO, 
+                       nlm_proc_root, &device_proc_fops, &device_list[i]);
           if (entry == NULL)
             {
               failure = 1;
               break;
             }
 
-          entry->proc_fops = &device_proc_fops;
-          entry->data = &device_list[i];
+          device_list[i].proc_name = kstrdup(buf, GFP_KERNEL);
           device_list[i].proc_entry = entry;
           break;
 
@@ -743,16 +753,15 @@ create_proc_entries ()
                   failure = 1;
                   break;
                 }
-              entry = create_proc_entry (buf, S_IFREG | S_IRUGO | S_IWUGO, 
-                                         nlm_proc_root);
+              entry = proc_create_data (buf, S_IFREG | S_IRUGO | S_IWUGO, 
+                       nlm_proc_root, &device_proc_fops, &device_list[i]);
               if (entry == NULL)
                 {
                   failure = 1;
                   break;
                 }
 
-              entry->proc_fops = &device_proc_fops;
-              entry->data = &device_list[i];
+              device_list[i].proc_name = kstrdup(buf, GFP_KERNEL);
               device_list[i].proc_entry = entry;
               i++;
             }
@@ -769,16 +778,15 @@ create_proc_entries ()
                   failure = 1;
                   break;
                 }
-              entry = create_proc_entry (buf, S_IFREG | S_IRUGO | S_IWUGO, 
-                                         nlm_proc_root);
+              entry = proc_create_data (buf, S_IFREG | S_IRUGO | S_IWUGO, 
+                       nlm_proc_root, &device_proc_fops, &device_list[i]);
               if (entry == NULL)
                 {
                   failure = 1;
                   break;
                 }
 
-              entry->proc_fops = &device_proc_fops;
-              entry->data = &device_list[i];
+              device_list[i].proc_name = kstrdup(buf, GFP_KERNEL);
               device_list[i].proc_entry = entry;
               i++;
             }
@@ -793,16 +801,15 @@ create_proc_entries ()
               break;
             }
           mars3_id++;
-          entry = create_proc_entry (buf, S_IFREG | S_IRUGO | S_IWUGO, 
-                                     nlm_proc_root);
+          entry = proc_create_data (buf, S_IFREG | S_IRUGO | S_IWUGO, 
+                       nlm_proc_root, &device_proc_fops, &device_list[i]);
           if (entry == NULL)
             {
               failure = 1;
               break;
             }
 
-          entry->proc_fops = &device_proc_fops;
-          entry->data = &device_list[i];
+          device_list[i].proc_name = kstrdup(buf, GFP_KERNEL);
           device_list[i].proc_entry = entry;
           break;
         default:
@@ -837,8 +844,9 @@ destroy_proc_entries ()
       entry = device_list[i].proc_entry;
       device_list[i].proc_entry = NULL;
       NLM_INFO (": Going to destroy /proc/NetL7/%s\n",
-                entry->name);
-      remove_proc_entry (entry->name, nlm_proc_root);
+                device_list[i].proc_name);
+      remove_proc_entry (device_list[i].proc_name, nlm_proc_root);
+      kfree(device_list[i].proc_name);
     }
   
   /* Remove root directory */
-- 
1.7.1

