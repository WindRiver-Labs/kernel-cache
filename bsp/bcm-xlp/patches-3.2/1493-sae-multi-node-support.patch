From 945d7922b01b397a34a65377cae60d36903f4b21 Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Thu, 22 Mar 2012 16:56:19 +0530
Subject: sae multi node support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index ffd6606..3a01f7f 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -750,6 +750,8 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	uint8_t *tmp_iv = iv;
 	unsigned long msgrng_flags;
 	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
 
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
@@ -817,7 +819,7 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, hash_source, iv_off, 
 		iv_size, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
 	
-	fb_vc = crypto_get_fb_vc();
+	fb_vc = crypto_get_fb_vc(&node);
 
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
@@ -845,7 +847,8 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 
 	//construct pkt, send to engine and receive reply
 	msgrng_access_enable(msgrng_flags);
-	err = nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
 	msgrng_access_disable(msgrng_flags);
 	if(err){
 		printk("err\n");
@@ -884,6 +887,9 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	uint8_t *tmp_iv = &iv[1];
 	unsigned long msgrng_flags;
 	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
+
 	param = (struct nlm_crypto_pkt_param *)NLM_CRYPTO_PKT_PARAM_OFFSET(aead_request_ctx(req));
 	hash_addr = (uint8_t *)NLM_HASH_OFFSET(aead_request_ctx(req));
 
@@ -1024,7 +1030,7 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, hash_source, iv_off,
 			iv_size, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
 
-	fb_vc = crypto_get_fb_vc();
+	fb_vc = crypto_get_fb_vc(&node);
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl))
 ;
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
@@ -1054,7 +1060,8 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 
 	//construct pkt, send to engine and receive reply
 	msgrng_access_enable(msgrng_flags);
-	err = nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
 	msgrng_access_disable(msgrng_flags);
 	if(err){
 		printk("err\n");
@@ -1090,6 +1097,8 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
 	unsigned long msgrng_flags;
 	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
 
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
@@ -1146,7 +1155,7 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
 			CTR_RFC3686_BLOCK_SIZE, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
 	
-	fb_vc = crypto_get_fb_vc();
+	fb_vc = crypto_get_fb_vc(&node);
 
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
@@ -1175,7 +1184,8 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 
 	//construct pkt, send to engine and receive reply
 	msgrng_access_enable(msgrng_flags);
-	err = nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
 	msgrng_access_disable(msgrng_flags);
 	if(err){
 		return -EIO;
@@ -1206,6 +1216,9 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 	struct nlm_crypto_pkt_ctrl *ctrl = NULL;
 	unsigned long msgrng_flags;
 	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
+
 	ctx = (struct  nlm_aead_ctx *)(( unsigned long )(( uint8_t *)ctx + CTRL_DESC_SIZE + 64) & ~(0x3fUL));
 	ctrl = &ctx->ctrl;
 	
@@ -1247,7 +1260,7 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
 			ivsize, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
 	
-	fb_vc = crypto_get_fb_vc();
+	fb_vc = crypto_get_fb_vc(&node);
 
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
@@ -1275,7 +1288,8 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 
 	//construct pkt, send to engine and receive reply
 	msgrng_access_enable(msgrng_flags);
-	err = nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
 	msgrng_access_disable(msgrng_flags);
 	if(err){
 		printk("err\n");
@@ -1307,6 +1321,8 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
 	unsigned long msgrng_flags;
 	unsigned int max_frags  = MAX_FRAGS;
+	int node_sae_base;
+	int node;
 
 	authsize = crypto_aead_authsize(tfm);
 	maxauthsize= aead->maxauthsize;
@@ -1347,7 +1363,7 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 	nlm_crypto_fill_cipher_auth_pkt_param(ctrl, param, op, op, iv_off, 
 			ivsize, auth_off, auth_len, 0, cipher_off, cipher_len, hash_addr);
 	
-	fb_vc = crypto_get_fb_vc();
+	fb_vc = crypto_get_fb_vc(&node);
 
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen, virt_to_phys(ctrl));
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (seg + 2)<<4, virt_to_phys(param));
@@ -1376,7 +1392,8 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 
 	//construct pkt, send to engine and receive reply
 	msgrng_access_enable(msgrng_flags);
-	err = nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
 	msgrng_access_disable(msgrng_flags);
 	if(err){
 		printk("err\n");
diff --git a/drivers/crypto/sae/nlm_async.h b/drivers/crypto/sae/nlm_async.h
index 3c022ff..2dbbed0 100644
--- a/drivers/crypto/sae/nlm_async.h
+++ b/drivers/crypto/sae/nlm_async.h
@@ -29,8 +29,11 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "nlmcrypto.h"
 
 struct nlm_async_crypto;
-#define MAX_CPU 32
-extern int crypto_get_fb_vc(void);
+#define MAX_CPU 128
+#define NODE_ID_SHIFT_BIT 5
+#define NODE_BASE_SHIFT_BIT 10
+
+extern int crypto_get_fb_vc(int * node);
 
 struct nlm_async_crypto
 {
diff --git a/drivers/crypto/sae/nlm_auth.c b/drivers/crypto/sae/nlm_auth.c
index bf21fea..c66fb91 100644
--- a/drivers/crypto/sae/nlm_auth.c
+++ b/drivers/crypto/sae/nlm_auth.c
@@ -242,13 +242,16 @@ xlp_auth_update(struct shash_desc *desc,
 	return 0;
 }
 static int
-crypto_get_sync_fb_vc(void)
+crypto_get_sync_fb_vc(int * node)
 {
     int cpu;
+    int node_id;
     extern int ipsec_sync_vc;
 
     cpu = hard_smp_processor_id();      //processor_id();
-    cpu = cpu * 4 + ipsec_sync_vc;
+    node_id = (cpu >> NODE_ID_SHIFT_BIT);
+    cpu = (node_id << NODE_BASE_SHIFT_BIT) | (((cpu & 0x1f) * 4) + ipsec_sync_vc);
+    *node = node_id;
 
     return cpu;
 }
@@ -269,6 +272,8 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 	int cpu = hard_smp_processor_id();
         extern int ipsec_sync_vc;
 	unsigned long msgrng_flags;
+	int node_sae_base;
+	int node;
 
 	if ( (auth_pkt_desc->total_len == 0 ) ||  ( auth_pkt_desc->total_len > MAX_AUTH_DATA)) { 
 
@@ -294,11 +299,12 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 	preempt_disable();
 	msgrng_access_enable(msgrng_flags);
 
-	fb_vc = crypto_get_sync_fb_vc();
+	fb_vc = crypto_get_sync_fb_vc(&node);
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
 	entry1 = nlm_crypto_form_pkt_fmn_entry1(0, ctrl->hashkeylen, (32 + index * 16 ), virt_to_phys(pkt_param));
-	
-	while (nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id) != 0 );
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+
+	while (nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id) != 0 );
 
 #ifdef NLM_CRYPTO_DEBUG
 	print_crypto_msg_desc(entry0, entry1, tx_id);
@@ -322,6 +328,7 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 		preempt_enable();
 		return -EIO;
 	}
+
 #ifdef NLM_CRYPTO_DEBUG
 	print_buf("AUTH:", out, 16);
 #endif
@@ -364,6 +371,8 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
 	uint64_t tx_id=0x12345678ULL;
 	uint64_t  timeout = 0;
 	unsigned long msgrng_flags;
+	int node_sae_base;
+	int node;
 	char * tmp = kmalloc(keylen + sizeof(struct nlm_crypto_pkt_ctrl) + sizeof( struct nlm_crypto_pkt_param ) 
 											+ 128, GFP_KERNEL);
 	struct nlm_crypto_pkt_ctrl * ctrl = (struct nlm_crypto_pkt_ctrl * ) ((((unsigned long)tmp + 63)) & ~(0x3fUL)); 
@@ -379,7 +388,7 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
 
 
 	msgrng_access_enable(msgrng_flags);
-        fb_vc = crypto_get_sync_fb_vc();
+        fb_vc = crypto_get_sync_fb_vc(&node);
         entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
         entry1 = nlm_crypto_form_pkt_fmn_entry1(0, 0, (32 + 16 ), virt_to_phys(pkt_param));
 
@@ -391,7 +400,9 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
 #endif
 
         //construct pkt, send to engine and receive reply
-	nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , entry0, entry1, tx_id);
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+
+	while (nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id) != 0 );
         timeout = 0;
         do {
                 timeout++;
diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index 144bfc8..03103aa 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -514,14 +514,17 @@ reset_crypto_stats(void)
 }
 
 int
-crypto_get_fb_vc(void)
+crypto_get_fb_vc(int * node)
 {
     int cpu;
+    int node_id = 0;
     extern int ipsec_async_vc;
 
 
     cpu = hard_smp_processor_id();	//processor_id();
-    cpu = cpu * 4 + ipsec_async_vc;
+    node_id = (cpu >> NODE_ID_SHIFT_BIT);
+    cpu = (node_id << NODE_BASE_SHIFT_BIT) | (((cpu & 0x1f) * 4) + ipsec_async_vc);
+    *node = node_id;
 
     return cpu;
 }
diff --git a/drivers/crypto/sae/nlm_enc.c b/drivers/crypto/sae/nlm_enc.c
index cef9945..2d8b40b 100755
--- a/drivers/crypto/sae/nlm_enc.c
+++ b/drivers/crypto/sae/nlm_enc.c
@@ -255,6 +255,8 @@ xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct
 	unsigned int cipher_len = req->nbytes;
 	struct nlm_crypto_pkt_param * pkt_param = (struct nlm_crypto_pkt_param *) NLM_CRYPTO_PKT_PARAM_OFFSET(ablkcipher_request_ctx(req));
 	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(ablkcipher_request_ctx(req));;
+	int node_sae_base;
+	int node ;
 	async->pkt_param = NULL;
 
 	nlm_crypto_fill_cipher_pkt_param(ctrl, pkt_param, enc,0,iv_size,iv_size ,req->nbytes); 
@@ -275,7 +277,7 @@ xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct
 	pktdescsize = 32 + seg * 16;
 
 	preempt_disable();
-	fb_vc = crypto_get_fb_vc(); 
+	fb_vc = crypto_get_fb_vc(&node); 
 
 	msg0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, ctrl->cipherkeylen,
 			virt_to_phys(ctrl));
@@ -292,7 +294,8 @@ xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct
 	async->bytes = req->nbytes; 
 	mb();
 	msgrng_access_enable(msgrng_flags);
-	while( nlm_hal_send_msg3(crypto_vc_base, 0 /*code */ , msg0, msg1, (unsigned long )async) != 0 );
+	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
+	while( nlm_hal_send_msg3(node_sae_base, 0 /*code */ , msg0, msg1, (unsigned long )async) != 0 );
 	msgrng_access_disable(msgrng_flags);
 	preempt_enable();
 	return -EINPROGRESS;
-- 
1.7.1

