From 0a59d495f5d1d3a42bf8e2c4eea191151433027a Mon Sep 17 00:00:00 2001
From: Kopal <kopal@broadcom.com>
Date: Tue, 6 Mar 2012 17:39:09 +0530
Subject: Read MAC Address from EEPROM.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 38280fa..55f3a33 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -61,6 +61,7 @@
 #include <asm/netlogic/xlp_irq.h>
 
 #include "net_common.h"
+#include <asm/netlogic/hal/nlm_eeprom.h>
 #include "xlp_nae.h"
 
 #if 1
@@ -92,7 +93,7 @@
 #define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
 
 /* On-Chip NAE PCI Header */
-#define PCI_NETL_VENDOR			0xfecc
+//#define PCI_NETL_VENDOR			0xfecc
 #define PCI_DEVID_BASE			0
 #define PCI_DEVID_OFF_NET		0
 
@@ -119,7 +120,7 @@
         }					\
 	printk("\n"); }
 
-/* This includes extra space and so with 64K PAGE_SIZE, we can have upto 
+/* This includes extra space and so with 64K PAGE_SIZE, we can have upto
    7 buffers. We need 32 bytes for prepad and another cacheline for storing
    s/w info
  */
@@ -129,10 +130,10 @@
 #define DEFAULT_JUMBO_MTU       3268  // for mtu 16384 : 5568
 #endif
 #define JUMBO_RX_OFFSET		64
-#define PREPAD_LEN		0	
+#define PREPAD_LEN		0
 /* THIS MUST be multiple of cache line size */
 #define DEFAULT_JUMBO_BUFFER_SIZE	\
-		(DEFAULT_JUMBO_MTU + PREPAD_LEN + JUMBO_RX_OFFSET) 
+		(DEFAULT_JUMBO_MTU + PREPAD_LEN + JUMBO_RX_OFFSET)
 
 #define NETL_JUMBO_SKB_HDR_LEN 64
 #define MAC_FRIN_WORK_NUM NR_CPUS
@@ -145,7 +146,7 @@ static int jumbo_buffer_size = DEFAULT_JUMBO_BUFFER_SIZE; /*or set in set_mtu */
 static int jumbo_mtu = DEFAULT_JUMBO_MTU; /* or set in set_mtu */
 typedef struct jumbo_rx_info {
 	struct page *page;
-	unsigned int page_offset; 
+	unsigned int page_offset;
 	unsigned int space;
 	atomic_t alloc_fails[NLM_MAX_NODES][PHOENIX_MAX_MACS];
 }jumbo_rx_info_t;
@@ -287,10 +288,10 @@ static inline struct jumbo_rx_cookie *get_rx_cookie(uint64_t phys)
 	return (struct jumbo_rx_cookie *)ptr;
 }
 
-/* Here 
+/* Here
    length -> is the exact length of the data (excluding BYTE_OFFSET, CRClen,
    prepad)
-   hlen -> is the length of the data to be copied to the skb 
+   hlen -> is the length of the data to be copied to the skb
    */
 
 /* Module Parameters */
@@ -301,7 +302,7 @@ static int drop_uboot_pkt = 1;
 module_param(drop_uboot_pkt, int, 0);
 static unsigned long stats_uboot_pkts;
 
-static int rely_on_firmware_config = 1;
+static int rely_on_firmware_config=1;
 module_param(rely_on_firmware_config, int, 0);
 
 /***************************************************************
@@ -315,29 +316,9 @@ extern uint32_t nae_rx_vc;
 extern uint32_t nae_fb_vc;
 /***************************************************************/
 
+extern struct eeprom_data * get_nlm_eeprom(void);
+
 unsigned char eth_hw_addr[NLM_MAX_NODES][18][6];
-/*
-unsigned char eth_hw_addr[18][6] = {
-	{0x00,0x01,0x02,0x03,0x04,0x05},
-	{0x00,0x01,0x02,0x03,0x04,0x06},
-	{0x00,0x01,0x02,0x03,0x04,0x07},
-	{0x00,0x01,0x02,0x03,0x04,0x08},
-	{0x00,0x01,0x02,0x03,0x04,0x09},
-	{0x00,0x01,0x02,0x03,0x04,0x0A},
-	{0x00,0x01,0x02,0x03,0x04,0x0B},
-	{0x00,0x01,0x02,0x03,0x04,0x0C},
-	{0x00,0x01,0x02,0x03,0x04,0x0D},
-	{0x00,0x01,0x02,0x03,0x04,0x0E},
-	{0x00,0x01,0x02,0x03,0x04,0x0F},
-	{0x00,0x01,0x02,0x03,0x04,0x10},
-	{0x00,0x01,0x02,0x03,0x04,0x11},
-	{0x00,0x01,0x02,0x03,0x04,0x12},
-	{0x00,0x01,0x02,0x03,0x04,0x13},
-	{0x00,0x01,0x02,0x03,0x04,0x14},
-	{0x00,0x01,0x02,0x03,0x04,0x15},
-	{0x00,0x01,0x02,0x03,0x04,0x16}
-};
-*/
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -471,22 +452,22 @@ static __inline__ int mac_send_fr(struct dev_data *priv, unsigned long addr, int
 	__sync();
         if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) ){
 		print_fmn_send_error(__func__, ret);
-		printk("Unable to send configured free desc, check freein carving (qid=%d) ret 0x%x\n", priv->nae_rx_qid, ret);			 
+		printk("Unable to send configured free desc, check freein carving (qid=%d) ret 0x%x\n", priv->nae_rx_qid, ret);
 		return ret;
 	}
-	return ret;		
-	
+	return ret;
+
 }
 
-void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_desc, 
+void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_desc,
 			uint32_t hlen, uint32_t length)
 {
 	int idx;
 	struct skb_shared_info *sp = skb_shinfo(skb);
-	struct jumbo_rx_cookie *rx_cookie = get_rx_cookie(rxp2d[0]);	
+	struct jumbo_rx_cookie *rx_cookie = get_rx_cookie(rxp2d[0]);
 	struct page *pg = rx_cookie->page;
 	int rx_offset =  JUMBO_RX_OFFSET;
-	uint8_t *va = page_address(pg) + rx_cookie->page_offset + rx_offset; 
+	uint8_t *va = page_address(pg) + rx_cookie->page_offset + rx_offset;
 	skb_frag_t *fp = &sp->frags[0];
 
 	/* actual data starts IP header align */
@@ -495,10 +476,10 @@ void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_d
 	skb->len = skb->data_len = length;
 	skb->truesize = length + sizeof(struct sk_buff);
 
-	fp->page= pg; 
+	fp->page= pg;
 	fp->page_offset = rx_cookie->page_offset + rx_offset + hlen;
 	fp->size = p2d_len[0]- hlen;
-	
+
 	skb_copy_to_linear_data(skb, va, hlen);
 	skb->data_len -= hlen;
 	skb->tail += hlen;
@@ -506,14 +487,14 @@ void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_d
 	/*fill other frags*/
 	for(idx=1; idx<num_desc; idx++){
 		fp = &sp->frags[idx];
-		rx_cookie = get_rx_cookie(rxp2d[idx]);	
+		rx_cookie = get_rx_cookie(rxp2d[idx]);
 		pg = rx_cookie->page;
 		rx_offset =  JUMBO_RX_OFFSET;
-		va = page_address(pg) + rx_cookie->page_offset + rx_offset; 
-		fp->page= pg; 
+		va = page_address(pg) + rx_cookie->page_offset + rx_offset;
+		fp->page= pg;
 		fp->page_offset = rx_cookie->page_offset + rx_offset;
 		fp->size = p2d_len[idx];
-	}	
+	}
 	skb_shinfo(skb)->nr_frags = num_desc;
 }
 
@@ -666,15 +647,15 @@ static int mac_fill_rxfr(struct net_device *dev)
 
 	//printk(" mac_fill_rxfr--------\n");
 	//if (!priv->init_frin_desc) return ret;
-	//priv->init_frin_desc = 0;	
+	//priv->init_frin_desc = 0;
 
 	//if(!(MSGRNG_OWN(priv->cfg_flag)))
-	//	return ret; 
+	//	return ret;
 	limit = atomic_read(&priv->frin_to_be_sent);
-	
+
 	for(i = 0; i < limit; i++){
 		/*  get a page */
-		pg = alloc_pages_exact_node(priv->node, GFP_KERNEL, 0); 
+		pg = alloc_pages_exact_node(priv->node, GFP_KERNEL, 0);
 		if(pg == NULL) {
 			ret = -ENOMEM;
 			break;
@@ -707,7 +688,7 @@ static int mac_fill_rxfr(struct net_device *dev)
 			va += jumbo_buffer_size;
 			pa += jumbo_buffer_size;
 			/* increment ref count from second particle */
-			if(j) 
+			if(j)
 				get_page(pg);
 			j++;
 			nr_buffs--;
@@ -735,6 +716,52 @@ static int nlm_initialize_vfbid(int node, int fbvc)
 		vfbid_tbl[cpu] = (dst_node << 10) | (((cpu % 32) * 4) + fbvc);
 	}
 	nlm_config_vfbid_table(node, 0, NR_CPUS, vfbid_tbl);	//FIXME change mappings for 127 and 126
+	return 0;
+}
+
+static int gen_mac_address(void)
+{
+	struct eeprom_data *nlm_eeprom=NULL;
+	unsigned char mac_base[6],temp,buf_write[2],buf0_read[2],buf1_read[2];
+	int if_mac_set=0,mac0_set=0, mac1_set=0;
+	int i,j;
+	buf_write[0]= MAC_MAGIC_BYTE0;
+	buf_write[1]= MAC_MAGIC_BYTE1;
+
+	memset(mac_base, '0', 6);
+	nlm_eeprom = get_nlm_eeprom();
+
+	eeprom_get_magic_bytes(nlm_eeprom,buf0_read,0);/* signature*/
+	eeprom_get_magic_bytes(nlm_eeprom,buf1_read,1);
+
+	if((buf0_read[0]==buf_write[0]) && (buf0_read[1]==buf_write[1]))/*match the signature*/
+        {
+                mac0_set=1;
+                eeprom_get_mac_addr(nlm_eeprom, mac_base,0);/* get the mac address*/
+        }
+	else if((buf1_read[0]==buf_write[0]) && (buf1_read[1]==buf_write[1]))
+	{
+		 mac1_set=1;
+		 eeprom_get_mac_addr(nlm_eeprom, mac_base,1);/* get the mac address*/
+	}
+
+	for(temp=0;temp<6;temp++)
+	{
+		if(mac_base[temp]!=0)
+		{
+			if_mac_set=1;
+		}
+	}
+
+	if( ((mac0_set | mac1_set) && if_mac_set) == 0){
+		 random_ether_addr(mac_base);
+	}
+	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
+		 for(j=0;j<18;j++){
+			  memcpy(eth_hw_addr[i][j], mac_base, 6);
+			  mac_base[5] += 1;
+		 }
+	}
 }
 
 /**********************************************************************
@@ -747,17 +774,16 @@ static void nlm_xlp_nae_init(void)
 {
 	struct net_device *dev = NULL;
 	struct dev_data *priv;
-	int i, node = 0, cpu;
+	int i, node = 0, cpu, j;
 	struct proc_dir_entry *entry;
 	nlm_nae_config_ptr nae_cfg;
 	uint32_t cpu_mask[NLM_MAX_NODES];
 	char buf[CPUMASK_BUF];
-	
+
 	for(i=0; i < NLM_MAX_NODES; i++)
 		cpu_mask[i] = 0;
-        
+
 	cpumask_scnprintf(buf, CPUMASK_BUF, &phys_cpu_present_map);
-        printk("phys_cpu_present_map %s\n",buf);
 
 	for (cpu = 0, node = 0; cpu < NR_CPUS ; cpu++) {
                 if(!cpu_isset(cpu, phys_cpu_present_map))
@@ -766,21 +792,24 @@ static void nlm_xlp_nae_init(void)
 		cpu_mask[node] |= (1 << (cpu % 32));
 	}
 
+
 	printk("======= Module Parameters =========\n");
 	printk("debug = %d, frin_desc_thres=%d drop_uboot_pkt=%d\n",
 	       debug, frin_desc_thres, drop_uboot_pkt);
 	printk("rely_on_firmware_config = %d\n", rely_on_firmware_config);
 
-	if (initialize_nae(cpu_mask[0], cpu_mask[1], cpu_mask[2], cpu_mask[3]))		//FIXME find a better way to do this
+	if (initialize_nae(cpu_mask[0], cpu_mask[1], cpu_mask[2], cpu_mask[3])) //FIXME find a better way to do this
 		return;
 	p2p_desc_mem_init();
-	
+
 	for (i = 0; i < ((node+1) * 32); i++) {
-		//tasklet_init(&mac_frin_replenish_task[i], mac_frin_replenish, 0UL);		  
+		//tasklet_init(&mac_frin_replenish_task[i], mac_frin_replenish, 0UL);
 		INIT_WORK(&mac_frin_replenish_work[i], mac_frin_replenish);
 	}
 
-	maxnae = nlm_node_cfg.num_nodes;	
+	gen_mac_address();
+
+	maxnae = nlm_node_cfg.num_nodes;
 	for(node = 0; node < maxnae; node++) {
 		nae_cfg = nlm_node_cfg.nae_cfg[node];
 		if (nae_cfg == NULL)
@@ -827,7 +856,7 @@ static void nlm_xlp_nae_init(void)
 					break;
 				case XAUI_IF:
 					priv->index = XGMAC;
-					break;	
+					break;
 				case INTERLAKEN_IF:
 					priv->index = INTERLAKEN;
 					priv->phy.addr = nae_cfg->ports[i].ext_phy_addr;
@@ -844,7 +873,7 @@ static void nlm_xlp_nae_init(void)
 					priv->index=0;
 					break;
 			}
-			printk("port%d hw %d block %d index %d type %d \n",i, nae_cfg->ports[i].hw_port_id, 
+			printk("port%d hw %d block %d index %d type %d \n",i, nae_cfg->ports[i].hw_port_id,
 									priv->block, priv->index, priv->type);
 			priv->nae_tx_qid 	= nae_cfg->ports[i].txq;
 			priv->nae_rx_qid 	= nae_cfg->ports[i].rxq;
@@ -852,7 +881,6 @@ static void nlm_xlp_nae_init(void)
 			register_netdev(dev);
 
 			dev_mac[node][i] = dev;
-			random_ether_addr(dev->dev_addr);
 			xlp_mac_setup_hwaddr(priv);
 
 		}
@@ -885,7 +913,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	tso_enable(dev, 1);
 	dev->features |= NETIF_F_FRAGLIST | NETIF_F_HIGHDMA | NETIF_F_SG;
 	//dev->features |= NETIF_F_IP_CSUM | NETIF_F_HW_CSUM;
-	
+
 	ret = mac_fill_rxfr(dev);
 	if (ret) goto out;
 
@@ -979,7 +1007,7 @@ static int p2p_desc_mem_init(void)
 
 
 	for(cpu = 0; cpu < NR_CPUS; cpu++) {
-		buf = cacheline_aligned_kmalloc(tsize, GFP_KERNEL);		      
+		buf = cacheline_aligned_kmalloc(tsize, GFP_KERNEL);
 		//spin_lock_init(&p2p_desc_mem[cpu].lock);
 		if (!buf)
 			return -ENOMEM;
@@ -1001,8 +1029,8 @@ static inline void *alloc_p2p_desc_mem(int cpu)
     	//unsigned long flags;
     	//spin_lock_irqsave(&p2p_desc_mem[cpu].lock, flags);
     	/*Disabling irq as the critical section shared between
- 	inteerupt context and xmit path. */	
-    	local_irq_disable();	
+ 	inteerupt context and xmit path. */
+    	local_irq_disable();
 	buf = p2p_desc_mem[cpu].mem;
 	if(buf) {
 		p2p_desc_mem[cpu].mem = (void *)*(unsigned long *)(buf);
@@ -1010,9 +1038,9 @@ static inline void *alloc_p2p_desc_mem(int cpu)
 	} else {
 		buf = cacheline_aligned_kmalloc(p2p_desc_mem[cpu].dsize, GFP_KERNEL);
 		p2p_dynamic_alloc_cnt[CPU_INDEX(cpu)]++;
-		//printk("alloc_p2p_desc_mem p2p_dynamic_alloc_cnt cpu=0x%x\n", cpu);	
+		//printk("alloc_p2p_desc_mem p2p_dynamic_alloc_cnt cpu=0x%x\n", cpu);
 	}
-    	local_irq_enable();	
+    	local_irq_enable();
 	//spin_unlock_irqrestore(&p2p_desc_mem[cpu].lock, flags);
 	return buf;
 }
@@ -1059,7 +1087,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	int cpu = hard_smp_processor_id();
 	int  ret, retry_cnt = 0;
 	unsigned long mflags = 0;
-	
+
 
 	p2pdesc = alloc_p2p_desc_mem(cpu);
 	if(p2pdesc == NULL) {
@@ -1085,7 +1113,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		l4hoff = iphdroff + ip_hdrlen(skb);
 
 		if(ip_hdr(skb)->protocol == IPPROTO_UDP){
-			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct udphdr);	
+			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct udphdr);
 			//printk("iphdroff %d udphdroff %d pyldoff %d\n", iphdroff, l4hoff, pyldoff);
 			udppcsum = udp_pseuodo_chksum((uint16_t *)((char *)iph + 12));
 			udp_hdr(skb)->check = 0;
@@ -1130,7 +1158,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	create_last_p2p_desc(p2pdesc, skb, idx);
 	msg = nae_tx_desc(P2P, 0, cpu, idx, virt_to_bus(p2pdesc));
-	
+
 retry_send:
 	msgrng_access_enable(mflags);
 	if(mss)
@@ -1185,12 +1213,12 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv)
 {
         struct net_device *dev = priv->dev;
 
-	dev->dev_addr[1] = priv->node;
- 
+	//dev->dev_addr[1] = priv->node;
+
         nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_LO, (dev->dev_addr[5] << 24) |
 				(dev->dev_addr[4] << 16) | (dev->dev_addr[3] << 8) | (dev->dev_addr[2]));
 
-	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) | 
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) |
 				(dev->dev_addr[0] << 16));
 
 	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_MASK_LO, 0xFFFFFFFF);
@@ -1317,14 +1345,14 @@ static int nlm_xlp_nae_set_hwaddr(struct net_device *dev, void *p)
 
 	if (priv->type == SGMII_IF)
 	{
-	  nlm_hal_write_mac_reg(priv->node,priv->block, priv->index, MAC_ADDR0_LO, 
-				(addr->sa_data[5] << 24) | 
-				(addr->sa_data[4] << 16) | 
-				(addr->sa_data[3] << 8) | 
+	  nlm_hal_write_mac_reg(priv->node,priv->block, priv->index, MAC_ADDR0_LO,
+				(addr->sa_data[5] << 24) |
+				(addr->sa_data[4] << 16) |
+				(addr->sa_data[3] << 8) |
 				(addr->sa_data[2]));
 
-	  nlm_hal_write_mac_reg(priv->node,priv->block, priv->index, MAC_ADDR0_HI, 
-				(addr->sa_data[1] << 24) | 
+	  nlm_hal_write_mac_reg(priv->node,priv->block, priv->index, MAC_ADDR0_HI,
+				(addr->sa_data[1] << 24) |
 				(addr->sa_data[0] << 16));
 	}
 
@@ -1398,7 +1426,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	{
 		/* Process Transmit Complete, addr is the skb pointer */
 		addr = msg0 & 0xffffffffffULL;
-		
+
 
 		if (!addr || drop_uboot_pkt) {
 			if ( (addr >= (192<<20)) && (addr < (256 << 20)) ) {
@@ -1406,12 +1434,12 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				stats_uboot_pkts++;
 				return;
 			}
-		}	
+		}
 		node = (src_id >> 10) & 0x3;
 		context = (msg0 >> 40) & 0x3fff;
 		port = *(cntx2port[node] + context);
 		//nlm_xlp_free_skb(addr, port);
-//#if 0		
+//#if 0
 		p2pfbdesc = bus_to_virt(addr);
 		skb = (struct sk_buff *)(p2pfbdesc[P2P_SKB_OFF]);
 		priv = netdev_priv(skb->dev);
@@ -1427,7 +1455,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		context = (msg0 >> 40) & 0x3fff;
 		port = cntx2port[context];
 #ifdef DEBUG_CONTEXT_PORT_MAPPING
-                if (port == 0) printk("FB context %d port %d \n",context, port);    
+                if (port == 0) printk("FB context %d port %d \n",context, port);
 #endif
 		skb = (struct sk_buff *)bus_to_virt(addr);
 		if(skb)
@@ -1459,14 +1487,14 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		uint32_t p2d_len[MAX_SKB_FRAGS];
 
 		/* Rx packet */
-		is_p2p  = msg1 & 0x1;	
+		is_p2p  = msg1 & 0x1;
 		addr	= msg1 & 0xffffffffe0ULL;
 		len	= (msg1 >> 40) & 0x3fff;
 		context = (msg1 >> 54) & 0x3ff;
 		if(is_p2p){
 			num_p2d = len;
 			//printk("P2p size=0x%x\n", len);
-		}	
+		}
 		//printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
                 //       src_id, vc, size, msg0, msg1);
 
@@ -1475,7 +1503,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			printk("Rcvd pkt address NULL !!!\n");
 			printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
                        src_id, vc, size, msg0, msg1);
-			return;	
+			return;
 		}
 #endif
 		if (err) bad_pkt = 1;
@@ -1493,7 +1521,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		port = *(cntx2port[node] + context);
 
 #ifdef DEBUG_CONTEXT_PORT_MAPPING
-		if (port == 0) printk("Rx context %d port %d \n",context, port);    
+		if (port == 0) printk("Rx context %d port %d \n",context, port);
 #endif
 		if(port >= MAX_GMAC_PORT)
 		{
@@ -1535,7 +1563,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		}else{ /*only one P2Dl_skb*/
 			vaddr = (uint64_t)bus_to_virt(addr);
 			p2d_addr[0] = addr;
-			p2d_len[0] = len - MAC_CRC_LEN; 
+			p2d_len[0] = len - MAC_CRC_LEN;
 			len = len - MAC_CRC_LEN;
 			num_p2d = 1;
 			tot_desc = 1;
@@ -1554,7 +1582,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			STATS_INC(priv->stats.rx_dropped);
 			/*increase free count for used pages*/
 			for(idx=0; idx<num_p2d; idx++){
-				rx_cookie = get_rx_cookie(p2d_addr[idx]);	
+				rx_cookie = get_rx_cookie(p2d_addr[idx]);
 				rx_offset =  JUMBO_RX_OFFSET;
 				pg = rx_cookie->page;
 				put_page(pg);
@@ -1569,12 +1597,12 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		if(skb == NULL) {
 			printk("FAILED TO ALLOCATE skb\n");
 			STATS_INC(priv->stats.rx_dropped);
-			
+
 			recycle_rx_desc(addr, pdev);
 			return;
 		}
 		skb->dev = dev_mac[node][port];
-		hlen = (len > NETL_JUMBO_SKB_HDR_LEN) ? 
+		hlen = (len > NETL_JUMBO_SKB_HDR_LEN) ?
 				NETL_JUMBO_SKB_HDR_LEN: len;
 		/* after this call, skb->data is pointing to start of MAChdr */
 		build_skb(skb, &p2d_addr[0], &p2d_len[0], num_p2d, hlen, len);
-- 
1.7.1

