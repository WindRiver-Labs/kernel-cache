From d516f2771020887797db8b73cec4671ef55fd1f2 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Mon, 21 Apr 2014 02:21:33 -0700
Subject: xlp9xx: support for RX channelization.

	1) RX channelization added for XLAUI/XFI.
	2) Changes for RX buffer threshold.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 41a1298..1d239fd 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -354,7 +354,7 @@ static inline uint32_t update_prsr_seq_fifo_size(nae_t *nae, uint32_t *size)
 
 static inline uint32_t update_rx_buf_size(nae_t *nae, uint32_t *size)
 {
-	*size = (((current_netsoc->ingress.max_rx_fifo) / nae->num_contexts) >> 2);
+	*size = (((current_netsoc->ingress.max_rx_fifo) / nae->num_ports) >> 2);
 	return 0;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 860307e..c4a4dd4 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -146,6 +146,7 @@ RX_PERF_CTR_VAL			    = 0xA1,
 NET_COMMON0_INTR_STS		    = 0x2A8,	
 NET_COMMON0_INTR_MASK		    = 0x2A9,	
 
+
  /*1588 PTP timer */
 IF_1588_TMSMP_HI		    = 0x300,
 IF_1588_TMSMP_LO		    = 0x301,   
@@ -153,6 +154,14 @@ IF_1588_TMSMP_LO		    = 0x301,
 TX_PERF_CNTR_0			    = 0x332,
 TX_PERF_CTRL_0			    = 0x333,
 
+CH_CLASS_PORT_EN		   = 0x422,
+CH_CLASS_USE_HIGIG_PRI		   = 0x423,
+CH_CLASS_USE_MAC_DA_OR_SA	   = 0x424,
+CH_CLASS_USE_MAC_DA		   = 0x425,
+CH_CLASS_USE_VLAN_ID		   = 0x426,
+CH_CLASS_USE_VLAN_PRI		   = 0x427,
+
+
 PTP_OFFSET_HI		    	    = 0x784,
 PTP_OFFSET_LO		            = 0x785,
 PTP_INC_DEN		            = 0x786,
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 5cd40fc..45b0495 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1128,6 +1128,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_pa
                         nae_port->ext_phy_addr = cmplx_cfg.ext_phy_addr[offset]; /*used for both 1G and 10G PHY*/
                         nae_port->ext_phy_bus = cmplx_cfg.ext_phy_bus[offset];
                         nae_port->ext_phy_sbl = cmplx_cfg.ext_phy_sbl[offset];
+                        nae_port->vlan_pri_en = cmplx_cfg.vlan_pri_en[offset];
                         nae_port->loopback = cmplx_cfg.loopback[offset];
                         nae_port->rxaui_mode = cmplx_cfg.rxaui_submode[offset];;
                         //nae_port->msec_enable = cmplx_cfg.msec_port_enable[offset];;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 24eec16..5eb1e29 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1187,47 +1187,59 @@ void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp
          send xoff when rx_data_buffer_used >= xoff threshold */
         int xoff, xon, val, reaction_len, inflight_len;
 
-	if ((netport->iftype == XLAUI_IF) || (netport->iftype == XAUI_IF)){
-		maxbuf /= 4;
-		val = maxbuf / 4;
-                xoff = ((val * 3) << 2);
-		xon = ((val * 2) << 2);
+	if(is_nlm_xlp9xx()){
+		if(netport->vlan_pri_en){
+			if(netport->iftype == XLAUI_IF){
+				val = maxbuf / 16 ;
+				xoff = ((val * 8) << 2);
+				xon = ((val * 4) << 2);
+			}else if(netport->iftype == XFI_IF){
+				val = maxbuf / 16 ;
+				xoff = ((val * 4) << 2);
+				xon = ((val * 2) << 2);	
+			}else if(netport->iftype == RXAUI_IF){
+				val = maxbuf / 16 ;
+				xoff = ((val * 8) << 2);
+				xon = ((val * 4) << 2);
+			}else if(netport->iftype == SGMII_IF){
+				val = maxbuf / 16 ;
+				xoff = ((val * 4) << 2);
+				xon = ((val * 2) << 2);	
+			}
+		}else{
+			val = maxbuf / 4;
+			xoff = ((val * 3) << 2);
+			xon = ((val * 2) << 2);
+		}
 		val = (xoff << 3) | (xon << 17) | thgrp;
 	}
-        else if (netport->iftype == XFI_IF){
-		maxbuf /= 4;
-		val = maxbuf / 16;
-		xoff = ((val * 5) << 2);
-		xon = ((val * 1) << 2);
-		val = (xoff << 3) | (xon << 17) | thgrp;
-        }
+	
 	else {
+		maxbuf=maxbuf<<2;
+		if (netport->iftype == SGMII_IF)
+		{
+			reaction_len = NAE_REACTION_LEN_SGMII;
+			inflight_len = NAE_INFLIGHT_LEN_SGMII;
+		}
+		else
+		{
+			reaction_len = NAE_REACTION_LEN_XAUI;
+			inflight_len = NAE_INFLIGHT_LEN_XAUI;
+		}
 
- 
-        if (netport->iftype == SGMII_IF)
-        {
-                reaction_len = NAE_REACTION_LEN_SGMII;
-                inflight_len = NAE_INFLIGHT_LEN_SGMII;
-        }
-        else
-        {
-                reaction_len = NAE_REACTION_LEN_XAUI;
-                inflight_len = NAE_INFLIGHT_LEN_XAUI;
-        }
-
-        /*
-           formula from PRM:
-           xoff = ((fifosize * 16) - 504 - MTU - R)/16;
-           xon = xoff - H;
+		/*
+		   formula from PRM:
+		   xoff = ((fifosize * 16) - 504 - MTU - R)/16;
+		   xon = xoff - H;
 
-           (maxbuf<<2) is reqd since same is done for RX_BUFFER_BASE_DEPTH_REG also.
-           16 is required 16k entries of 16 bytes each
-           */
+		   (maxbuf<<2) is reqd since same is done for RX_BUFFER_BASE_DEPTH_REG also.
+		   16 is required 16k entries of 16 bytes each
+		 */
 
-        xoff = ((maxbuf * NAE_RX_THR_BYTE_UNIT) - reaction_len - inflight_len - mtu_len) / NAE_RX_THR_BYTE_UNIT;
-        xon = xoff - NAE_THR_SEPARATION;
+		xoff = ((maxbuf * NAE_RX_THR_BYTE_UNIT) - reaction_len - inflight_len - mtu_len) / NAE_RX_THR_BYTE_UNIT;
+		xon = xoff - NAE_THR_SEPARATION;
 
-	val = (xoff << 3) | (xon << 17) | thgrp;
+		val = (xoff << 3) | (xon << 17) | thgrp;
 	}
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, thgrp);
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, val);
@@ -1348,7 +1360,7 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
         {
 		if (IS_NLM_XLP9XX_FAMILY) {
                         xoff = size - 30 ;
-                        xon = xoff/ 2;
+                        xon = xoff/2;
                         val = (xoff<<12) | (xon);
                 }
                 else {
@@ -1447,7 +1459,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
                 {
   			if(!(xonxoff_done[nae->node][nae->nae_id][thrgrp])){
 				xonxoff_done[nae->node][nae->nae_id][thrgrp] = 1;
-				__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  (rx_buf_size << 2) / nae->ports[port].num_channels, NAE_MTU_LEN);
+				__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  rx_buf_size/nae->ports[port].num_channels, NAE_MTU_LEN);
 			}
 		}
 
@@ -2012,6 +2024,9 @@ void __netsoc_set_xlgmac_enable(net_port_t *netport)
         __netsoc_write_xlgmac_reg(netport, XLAUI_RX_FIFO_SECTIONS, val);
 
 	val = 0x220d3; // PFC disable
+        if (netport->vlan_pri_en) {  
+		val |= (1<<19); /*PFC enable*/
+	}
         __netsoc_write_xlgmac_reg(netport, XLAUI_COMMNAD_CONFIG, val);
 
 
@@ -2342,6 +2357,13 @@ static void __netsoc_config_xlgmac(net_port_t *netport)
 	//__netsoc_xlgmac_fec_enable(netport);
 	__netsoc_set_xlgmac_enable(netport);
 	__netsoc_set_xlgmac_pause_config(netport);
+        if (netport->vlan_pri_en) {  
+		uint32_t val = 0;	
+		val = netsoc_read_nae_reg(nae->nae_base, CH_CLASS_PORT_EN);
+		netsoc_write_nae_reg(nae->nae_base, CH_CLASS_PORT_EN, val | (1<<netport->hw_port_id));
+		val = netsoc_read_nae_reg(nae->nae_base, CH_CLASS_USE_VLAN_PRI);
+		netsoc_write_nae_reg(nae->nae_base,  CH_CLASS_USE_VLAN_PRI, val | (1<<netport->hw_port_id));
+	}
 
 
 	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
@@ -2366,6 +2388,7 @@ static void __netsoc_config_xfi(net_port_t *netport)
         uint32_t val = 0, lane_cfg;
 	uint64_t mac_base = __netsoc_get_xgmac_base(netport);
 	uint64_t netior_base = netsoc_get_macreg_base_for_lanecfg(netport->nae->mac_base);
+	nae_t *nae = netport->nae;
 
 	// Apply a soft reset.
 	__netsoc_xfi_softreset(mac_base, 0x2);
@@ -2425,6 +2448,15 @@ static void __netsoc_config_xfi(net_port_t *netport)
         } else {
                 val = 0x0000F123;          // Link level FC: OffTimer = 0xF123
         }
+
+	if (netport->vlan_pri_en) {  
+		uint32_t val = 0;	
+		val = netsoc_read_nae_reg(nae->nae_base, CH_CLASS_PORT_EN);
+		netsoc_write_nae_reg(nae->nae_base, CH_CLASS_PORT_EN, val | (1<<netport->hw_port_id));
+		val = netsoc_read_nae_reg(nae->nae_base, CH_CLASS_USE_VLAN_PRI);
+		netsoc_write_nae_reg(nae->nae_base,  CH_CLASS_USE_VLAN_PRI, val | (1<<netport->hw_port_id));
+	}
+
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL2, val);
 }
 
-- 
1.7.1

