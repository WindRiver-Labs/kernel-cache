From dfbed06a541e088dbe783ea2c8c536ec9d2fdd9f Mon Sep 17 00:00:00 2001
From: Jayanthi Annadurai <jayanthia@netlogicmicro.com>
Date: Fri, 24 Feb 2012 16:39:02 -0800
Subject: Added support for changing interlaken MTU

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 07e2d7c..017dce0 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -830,6 +830,7 @@ static void nlm_xlp_nae_init(void)
 					break;	
 				case INTERLAKEN_IF:
 					priv->index = INTERLAKEN;
+					priv->phy.addr = nae_cfg->ports[i].ext_phy_addr;
 					if (nae_cfg->ports[i].hw_port_id == 0) {
                         	               if (dev_alloc_name(dev, "ilk0-%d") < 0)
                                 	                printk("alloc name failed \n");
@@ -1230,10 +1231,6 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 	if ((new_mtu > (DEFAULT_JUMBO_MTU * MAX_SKB_FRAGS)) || (new_mtu < MIN_ETH_FRAME_SIZE)) {
 		return -EINVAL;
 	}
-	if(priv->type==INTERLAKEN_IF){
-		return -EINVAL;
-	}
-
 	spin_lock_irqsave(&priv->lock, flags);
 
 	local_jumbo_mtu = new_mtu + ETH_HLEN + ETH_FCS_LEN;
@@ -1241,9 +1238,16 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 	if(priv->type==SGMII_IF){
 		nlm_hal_set_sgmii_framesize(priv->node, priv->block, priv->index, local_jumbo_mtu);
 	}
-	if(priv->type==XAUI_IF){
+	else if(priv->type==XAUI_IF){
 		nlm_hal_set_xaui_framesize(priv->node, priv->block, local_jumbo_mtu, local_jumbo_mtu);
 	}
+	else if(priv->type == INTERLAKEN_IF) {
+		nlm_hal_set_ilk_framesize(priv->node, priv->block, priv->phy.addr, local_jumbo_mtu);
+	}
+	else {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return -1;
+	}
 
 	dev->mtu = new_mtu;
 
@@ -1290,7 +1294,7 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 
 	spin_lock_irq(&priv->lock);
 
-	priv->stats.tx_errors++;
+	STATS_ADD(priv->stats.tx_errors, 1);
 
 	spin_unlock_irq(&priv->lock);
 
-- 
1.7.1

