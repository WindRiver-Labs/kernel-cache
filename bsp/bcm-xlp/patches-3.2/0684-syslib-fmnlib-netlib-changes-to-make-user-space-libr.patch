From dec26ec046b06abb7443dc7928c7cbcbf709db90 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 7 May 2013 10:22:34 -0700
Subject: syslib/fmnlib/netlib: changes to make user-space libraries link properly

  o fmnlib: add proper cop2 read/write register functions
  o syslib/fmnlib/netlib: Makefile changes
  o netlib: add Kbuild
  o netlib: certain implementation changes
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
index fac7029..e90fb36 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
@@ -38,6 +38,13 @@
 #ifndef _NLH_FMN_DP_H
 #define _NLH_FMN_DP_H
 
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
 #ifndef __ASSEMBLY__
 
 /*Cop2 Regs */
@@ -67,6 +74,25 @@
 	"nop"							\
         : : "r" (value));
 
+#define _read_32bit_cp2_register_sel(source, sel)               \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+        ".set\tpop"                                             \
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_32bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+        ".set\tpop"                                             \
+        : : "r" (value), "i" (sel) );
+
+
 #ifndef _ABI64
 
 #define _read_64bit_cp2_register_sel(source, sel)                        \
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
index e33f87f..099f517 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
@@ -15,6 +15,7 @@
 #else
 #include "nlm_evp_cpld.h"
 #endif
+#include <netsoc_dev.h>
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
index e8a134c..4119c02 100644
--- a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
+++ b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
@@ -140,7 +140,12 @@ static int bcm_get_phy_status(net_port_t *netport, uint32_t *speed, uint32_t *du
         if(*speed==SPEED_10M)
                 netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Configured with Speed 10M");
 
-        ((*duplex == 1) ? netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Full duplex\n"):nlm_print("Half duplex\n"));
+        if (*duplex == 1) {
+		netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Full duplex\n");
+	}
+	else {
+		netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Half duplex\n");
+	}
 //#endif
         status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
         if(status & (1<<2)){
@@ -306,7 +311,12 @@ static int xmc_get_phy_status(net_port_t *netport, uint32_t *speed, uint32_t *du
         if(*speed==SPEED_10M)
                 netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Configured with Speed 10M");
 
-        ((*duplex == 1) ? netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Full duplex\n"):nlm_print("Half duplex\n"));
+        if (*duplex == 1) {
+		netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Full duplex\n");
+	}
+	else {
+		netsoc_api_print(NETSOC_APIDBG_DEFAULT, "Half duplex\n");
+	}
 //#endif
         status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
         status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index d6359c7..780f268 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -60,4 +60,7 @@ EXPORT_SYMBOL(netsoc_disable_nae_hwparser);
 EXPORT_SYMBOL(netsoc_enable_nae_hwparser);
 EXPORT_SYMBOL(netsoc_config_nae_l4parser);
 EXPORT_SYMBOL(netsoc_config_nae_l3parser);
+EXPORT_SYMBOL(netsoc_lib_writel);
+EXPORT_SYMBOL(netsoc_lib_readl);
+
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index 445de22..b172fb1 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -69,6 +69,36 @@
 #define DEFAULT_ILK_CAL_SLOTS           26
 
 
+#define GMAC    1
+#define XGMAC   2
+
+
+typedef struct {
+        uint32_t iftype[5];
+        union { 
+                struct {
+                        uint32_t phymode[4];
+                        uint32_t phy_bus[4];
+                        uint32_t phy_addr[4];
+                        uint32_t num_channels[4];
+                }gmac;
+                struct {
+                        uint32_t phymode;
+                        uint32_t num_channels;
+                }xgmac;
+                struct {
+                        uint32_t phymode;
+                        uint32_t num_channels;
+                }xlgmac;
+                struct {
+                        uint32_t phymode;
+                        uint32_t num_channels;
+                        uint32_t num_lanes;
+                        uint32_t lane_rate;
+                }interlaken;
+        }ifparam[5];
+}xlp_netifconfig_t;
+
 struct netsoc_info{
 	uint32_t max_ports;
 	uint32_t max_freeinqs;
@@ -311,4 +341,32 @@ static inline uint32_t get_msec_port_enable(uint32_t intf_type)
 	return 0;
 }
 
+static inline void update_default_config(int intf_type, uint32_t *config, uint32_t val)
+{
+        uint32_t iface;
+        if (intf_type == SGMII_IF) {
+                for(iface = 0; iface < 4; iface++) {
+                        *config++ = val;
+                }
+        }
+        else {  
+                *config = val;
+        }
+}
+
+static inline int get_num_ports(int block, int intf_type)
+{
+        if (intf_type == SGMII_IF) {
+                if ((is_nlm_xlp9xx()) && block == 2)
+                        return 1;
+
+                if (block < 4)
+                        return 4;
+                else
+                        return 2;
+        }
+        else
+                return 1;
+}
+
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
new file mode 100644
index 0000000..41196b1
--- /dev/null
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -0,0 +1,1001 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef __NETSOC_DEV_H_
+#define __NETSOC_DEV_H_
+
+
+#ifndef __ASSEMBLY__
+/* Device Id: Bus[8:6], Dev[5:3], func[2:0] */
+
+#define XLP_NA_REG_BLOCK_SIZE 0x2000 /* 8KB */
+#define XLP_NA_REG_IFACE_SIZE 0x200 /* 512B */
+
+enum net_cfg_regs {
+ RX_CONFIG                          = 0x10,
+ TX_CONFIG                          = 0x11,
+ RX_IF_BASE_CONFIG_0                = 0x12,
+ RX_IF_BASE_CONFIG_1                = 0x13,
+ RX_IF_BASE_CONFIG_2                = 0x14,
+ RX_IF_BASE_CONFIG_3                = 0x15,
+ RX_IF_BASE_CONFIG_4                = 0x16,
+ RX_IF_BASE_CONFIG_5                = 0x17,
+ RX_IF_BASE_CONFIG_6                = 0x18,
+ RX_IF_BASE_CONFIG_7                = 0x19,
+ RX_IF_BASE_CONFIG_8                = 0x1a,
+ RX_IF_BASE_CONFIG_9                = 0x1b,
+ RX_IFACE_VEC_VALID                 = 0x1c,
+ RX_IFACE_SLOT_CAL                  = 0x1d,
+ XLP_PARSER_CONFIG                  = 0x1e,
+ PARSER_SEQ_FIFO_CFG                = 0x1f,
+ FREE_IN_FIFO_CFG                   = 0x20,
+ RX_BUFFER_BASE_DEPTH_ADDR_REG      = 0x21,
+ RX_BUFFER_BASE_DEPTH_REG           = 0x22,
+ RX_UCORE_CFG                       = 0x23,
+ RX_UCORE_CAM_MASK0_CFG             = 0x24,
+ RX_UCORE_CAM_MASK1_CFG             = 0x25,
+ RX_UCORE_CAM_MASK2_CFG             = 0x26,
+ RX_UCORE_CAM_MASK3_CFG             = 0x27,
+ FREE_IN_FIFO_UNIQ_SZ_CFG           = 0x28,
+ CRC_POLY0_CFG                      = 0x2a,
+ CRC_POLY1_CFG                      = 0x2b,
+ FREE_SPILL0_MEM_CFG                = 0x2c,
+ FREE_SPILL1_MEM_CFG                = 0x2d,
+ FREE_FIFO_THRESHOLD_CFG    	    = 0x2e,
+ FREE_FIFO_THRESHOLDS_CFG           = 0x87,
+ FLOW_CRC16_POLY_CFG                = 0x2f,
+ DMA_TX_CREDIT_TH                   = 0x29,
+ STG1_STG2CRDT_CMD                  = 0x30,
+ STG1_STG2CRDT_STATUS               = 0x31,
+ STG2_EHCRDT_CMD                    = 0x32,
+ STG2_EHCRDT_STATUS                 = 0x33,
+ STG2_FREECRDT_CMD                  = 0x34,
+ STG2_FREECRDT_STATUS               = 0x35,
+ STG2_STRCRDT_CMD                   = 0x36,
+ STG2_STRCRDT_STATUS                = 0x37,
+ TXFIFO_IFACE_MAP_CMD               = 0x38,
+ TXFIFO_IFACE_MAP_STATUS            = 0x39,
+ VFBID_TO_DEST_MAP_CMD              = 0x3a,
+ STG1_PMEM_PROG                     = 0x3c,
+ STG1_PMEM_STATUS                   = 0x3d,
+ STG2_PMEM_PROG                     = 0x3e,
+ STG2_PMEM_STATUS                   = 0x3f,
+ EH_PMEM_PROG                       = 0x40,
+ EH_PMEM_STATUS                     = 0x41,
+ FREE_PMEM_PROG                     = 0x42,
+ FREE_PMEM_STATUS                   = 0x43,
+ TX_DRR_ACTVLIST_CMD                = 0x44,
+ TX_DRR_ACTVLIST_STATUS             = 0x45,
+ TX_IFACE_BURSTMAX_CMD              = 0x46,
+ TX_IFACE_BURSTMAX_STATUS           = 0x385,
+ TX_IFACE_ENBL_CMD                  = 0x48,
+ TX_IFACE_ENBL_STATUS               = 0x49,
+ TX_PKTLEN_PMEM_CMD                 = 0x4a,
+ TX_PKTLEN_PMEM_STATUS              = 0x4b,
+ TX_SCHED_MAP_CMD0                  = 0x4c,
+ TX_SCHED_MAP_CMD1                  = 0x4d,
+ EGR_NIOR_CAL_LEN_REG       	    = 0x4e,
+ EGR_NIOR_CRDT_CAL_PROG     	    = 0x52,
+ TX_SCHED_MAP_STATUS0               = 0x387,
+ TX_SCHED_MAP_STATUS1               = 0x388,
+ TX_PKT_PMEM_CMD0                   = 0x50,
+ TX_PKT_PMEM_CMD1                   = 0x51,
+ TX_PKT_PMEM_STATUS                 = 0x389,
+ TX_SCHED_CTRL                      = 0x53,
+ STR_PMEM_CMD                       = 0x58,
+ TX_IORCRDT_INIT                    = 0x59,
+ RX_FREE_FIFO_POP                   = 0x62,
+ FLOW_BASE_MASK_CFG                 = 0x80,
+ POE_CLASS_SETUP_CFG                = 0x81,
+ UCORE_IFACE_MASK_CFG               = 0x82,
+ RX_BUFFER_XONOFF_THR    	    = 0x83,
+ FLOW_TABLE1_CFG                    = 0x84,
+ FLOW_CLASS_BASE_MASK		    = 0x85,	
+ FLOW_TABLE3_CFG                    = 0x86,
+ IFACE_FIFO_CFG             	    = 0x8a,
+ PARSER_SEQ_FIFOTH_CFG		    = 0x8b,
+ RX_ERRINJ_CTRL1		    = 0x8d,
+ L2_TYPE_0                          = 0x210,
+ L3_CTABLE_MASK_0                   = 0x22c,
+ L3_CTABLE_0_0                      = 0x230,
+ L3_CTABLE_0_1                      = 0x231,
+ L4_CTABLE_0_0                      = 0x250,
+ L4_CTABLE_0_1                      = 0x251,
+ VFBID_TO_DEST_MAP_STATUS           = 0x380,
+ EGR_NIOR_CAL_STATUS		    = 0x38B,
+NET_COMMON0_INTR_STS		    = 0x2A8,	
+NET_COMMON0_INTR_MASK		    = 0x2A9,	
+
+ /*1588 PTP timer */
+IF_1588_TMSMP_HI		    = 0x300,
+IF_1588_TMSMP_LO		    = 0x301,   
+
+PTP_OFFSET_HI		    	    = 0x784,
+PTP_OFFSET_LO		            = 0x785,
+PTP_INC_DEN		            = 0x786,
+PTP_INC_NUM		            = 0x787,
+PTP_INC_INTG		            = 0x788,
+PTP_CONTROL		            = 0x789,
+PTP_STATUS			    = 0x78A,
+PTP_USER_VALUE_HI		    = 0x78B,
+PTP_USER_VALUE_LO		    = 0x78C,							  
+PTP_TMR1_HI		            = 0x78D,
+PTP_TMR1_LO		            = 0x78E,
+PTP_TMR2_HI		            = 0x78F,
+PTP_TMR2_LO		            = 0x790,
+PTP_TMR3_HI		            = 0x791,
+PTP_TMR3_LO		            = 0x792,
+
+IOSYS_RTC_CMD      = 0x7C0,
+IOSYS_RTC_RDATA_HI = 0x7C1,
+IOSYS_RTC_RDATA_LO = 0x7C2,
+
+};
+
+//
+enum if_cfg_regs {
+  MAC_CONF1 = 0,
+  MAC_CONF2 = 1,
+  SGMII_MAX_FRAME_LEN = 4,
+  NETWK_INF_CTRL3_REG = 0x7c,
+  NETWK_INF_CTRL_REG = 0x7f
+};
+//
+enum xaui_cfg_regs {
+	XGMAC_CTL_REG1 = 0x7f,
+	XGMAC_CTL_REG2 = 0x7e,
+	XGMAC_CTL_REG3 = 0x7d,
+	XGMAC_STATUS_REG = 0x7c,
+};
+//
+enum netior_regs {
+	NETIOR_SOFTRESET = 3,
+	NETIOR_MISC_REG1_ADDR = 0x39,
+	NETIOR_MISC_REG2_ADDR = 0x3a,
+	NETIOR_MISC_REG3_ADDR = 0x3d,
+
+};
+enum NAE_TX_TYPE {
+	P2D_NEOP = 0,
+	P2P      = 1,
+	P2D_EOP  = 2,
+	MSC      = 3
+};
+
+/* NAE Interface Definitions
+ */
+enum NAE_INTF_TYPE {    
+	GMAC_0 = 0,
+	GMAC_1 = 1,
+	GMAC_2 = 2,
+	GMAC_3 = 3,
+	XGMAC  = 4,
+	INTERLAKEN = 5,
+	PHY	 = 0xE,
+	LANE_CFG = 0xF,
+};      
+
+enum NAE_BLOCK_NR {    
+	BLOCK_0 = 0,
+	BLOCK_1,
+	BLOCK_2,
+	BLOCK_3,
+	BLOCK_4,
+	BLOCK_5,
+	BLOCK_6,
+	BLOCK_7,
+};      
+
+typedef enum PHY_LANE_INTF_TYPE {
+	LANE_DISCONNECTED,      
+	LANE_GMAC,      
+	LANE_XGMAC,     
+	LANE_8ILAKEN,   
+} phy_lane_intf_t;      
+
+
+/* MACSEC
+ */
+enum nae_macsec_cfg_regs {
+TX_MSEC_ETHER_TYPE		= 0x33e,
+TX_MSEC_PORT_EN          	= 0x33f,
+TX_MSEC_BYPASS         		= 0x340,
+TX_MSEC_PROG_STATUS      	= 0x341,
+TX_MSEC_INIT_PN          	= 0x342,
+TX_MSEC_PN_THRESH        	= 0x343,
+TX_MSEC_PREAMBLE_LEN_CODE      	= 0x344,
+TX_MSEC_KEY_IN_USE0		= 0x345,
+TX_MSEC_KEY_IN_USE1		= 0x346,
+TX_MSEC_KEY_IN_USE2		= 0x347,
+TX_MSEC_KEY_IN_USE3		= 0x348,
+TX_MSEC_KEY_XED_THRESH0     	= 0x349,
+TX_MSEC_KEY_XED_THRESH1      	= 0x34a,
+TX_MSEC_KEY_XED_THRESH2      	= 0x34b,
+TX_MSEC_KEY_XED_THRESH3      	= 0x34c,
+TX_MSEC_KEY_STALE0		= 0x34d,
+TX_MSEC_KEY_STALE2		= 0x34f,
+TX_MSEC_KEY_STALE3		= 0x350,
+TX_MSEC_KEY_ERR0            	= 0x351,
+TX_MSEC_KEY_ERR1            	= 0x352,
+TX_MSEC_KEY_ERR2            	= 0x353,
+TX_MSEC_KEY_ERR3            	= 0x354,
+
+TX_MSEC_MEM_DATAREG_0           = 0x38c,
+TX_MSEC_MEM_DATAREG_1           = 0x38d,
+TX_MSEC_MEM_DATAREG_2           = 0x38e,
+TX_MSEC_MEM_DATAREG_3           = 0x38f,
+TX_MSEC_MEM_CTRL_REG            = 0x390,
+
+RX_MSEC_MEM_DATAREG_0        	= 0x400,
+RX_MSEC_MEM_DATAREG_1        	= 0x401,
+RX_MSEC_MEM_DATAREG_2        	= 0x402,
+RX_MSEC_MEM_DATAREG_3        	= 0x403,
+RX_MSEC_MEM_CTRL_REG         	= 0x404,
+
+RX_MSEC_PORT_EN         	= 0x405,
+RX_MSEC_BYPASS         		= 0x406,
+RX_MSEC_SEC_TAG0		= 0x407,
+RX_MSEC_SEC_TAG1      		= 0x408,
+RX_MSEC_INIT_PN             	= 0x409,
+RX_MSEC_REPLAY_WIN_SIZE     	= 0x40a,
+RX_MSEC_SCI_MASK0_LO        	= 0x40b,
+RX_MSEC_SCI_MASK0_HI         	= 0x40c,
+RX_MSEC_SCI_MASK1_LO         	= 0x40d,
+RX_MSEC_SCI_MASK1_HI         	= 0x40e,
+RX_MSEC_SCI_MASK2_LO         	= 0x40f,
+RX_MSEC_SCI_MASK2_HI         	= 0x410,
+RX_MSEC_SCI_MASK3_LO         	= 0x411,
+RX_MSEC_SCI_MASK3_HI         	= 0x412,
+RX_MSEC_SCI_MASK4_LO         	= 0x413,
+RX_MSEC_SCI_MASK4_HI         	= 0x414,
+RX_MSEC_SCI_MASK5_LO         	= 0x415,
+RX_MSEC_SCI_MASK5_HI         	= 0x416,
+RX_MSEC_SCI_MASK6_LO         	= 0x417,
+RX_MSEC_SCI_MASK6_HI         	= 0x418,
+RX_MSEC_SCI_MASK7_LO         	= 0x419,
+RX_MSEC_SCI_MASK7_HI		= 0x41a,
+
+};
+
+#define RX_MSEC_SCI_MASK_LO(i) (0x40b + i *2)
+#define RX_MSEC_SCI_MASK_HI(i) (0x40c + i *2)
+
+/*
+ *  POE
+ */
+
+enum poe_reg_type {
+	PCIE_CFG_POE_REG = 0,
+	PCIE_MEM_POE_REG = 1,
+};
+
+enum poe_cfg_reg {
+  MAX_FLOW_MSGS0 = 64, // TBI
+  MAX_MSGS_CLASS0 = 72, // TBI
+  CLASS0_SIZE = 88, // TBI
+  ERROR_MESG0 = 96, // TBI
+  LO_CNT_OOO_MSG = 104, // TBI
+  LO_CNT_INORDER_MSG = 105, // TBI 
+  LO_CNT_LOCBUF_ST = 106, // TBI
+  LO_CNT_EXTBUF_ST = 107, // TBI
+  LO_CNT_LOCBUF_ALLOC = 108, // TBI
+  LO_CNT_EXTBUF_ALLOC = 109, // TBI
+  HI_CNT_OOO_MSG = 110, // TBI
+  HI_CNT_INORDE_RMSG = 111, // TBI
+  HI_CNT_LOCBUF_ST = 112, // TBI
+  HI_CNT_EXTBUF_ST = 113, // TBI
+  HI_CNT_LOCBUF_ALLOC = 114, // TBI
+  HI_CNT_EXTBUF_ALLOC = 115, // TBI
+  DROP_CNT_DIST0 = 192, // TBI
+  DROP_CNT_CLASS0 = 208, // TBI
+  DROP_CNT_DIST_CLASS0 = 216, // TBI
+  DROP_CNT_CPU = 224, // TBI
+  DROP_CNT_MAX_FLOW =  225, // TBI
+  INT_VECTOR = 320, // TBI
+  POE_INT_MASK = 321, // TBI
+  FATAL_ERR_MASK = 322, // TBI
+  BIU_CONFIG = 323, // TBI
+  BIU_TIMEOUT = 324, // TBI
+  ENQUED_MSG_SENT = 336, 
+  ENQUED_MSG_CNT = 337, 
+  DIST_THRESHOLD0 = 448, // TBI
+  DIST_CLASS_DROP_ENABLE = 459, // TBI
+  DIST_VEC_DROP_ENABLE = 460, // TBI
+  DIST_DROP_TIMER = 461, // TBI
+  ERROR_LOG_WORD0 = 462, // TBI
+  ERROR_INJ_CTL = 465, // TBI
+  DIST_VEC_0_15 = 466, // TBI
+  LOCAL_FBP_BASE = 0x400,
+  MSG_STORAGE_BASE_ADR_L = 0x60,
+  FBP_BASE_ADR_L = 0x62,
+};
+
+enum poe_stats_reg {
+	OO_MSG_CNT_LO = 0xa8,
+	IN_ORDER_MSG_CNT_LO,
+	LOC_BUF_STOR_CNT_LO,
+	EXT_BUF_STOR_CNT_LO,
+	LOC_BUF_ALLOC_CNT_LO,
+	EXT_BUF_ALLOC_CNT_LO,
+        OO_MSG_CNT_HI ,
+        IN_ORDER_MSG_CNT_HI,
+        LOC_BUF_STOR_CNT_HI,
+        EXT_BUF_STOR_CNT_HI,
+        LOC_BUF_ALLOC_CNT_HI,
+        EXT_BUF_ALLOC_CNT_HI,
+	MODE_ERR_FLOW_ID,
+	POE_STATISTICS_EN,
+	POE_MAX_SIZE_FLOW,
+	POE_MAX_SIZE	
+};
+
+#define POE_CL0_ENQ_SPILL_BASE_L	0x40
+#define POE_CL0_ENQ_SPILL_BASE_H	0x41
+#define POE_CL1_ENQ_SPILL_BASE_L	0x42
+#define POE_CL1_ENQ_SPILL_BASE_H	0x43
+#define POE_CL2_ENQ_SPILL_BASE_L	0x44
+#define POE_CL2_ENQ_SPILL_BASE_H	0x45
+#define POE_CL3_ENQ_SPILL_BASE_L	0x46
+#define POE_CL3_ENQ_SPILL_BASE_H	0x47
+#define POE_CL4_ENQ_SPILL_BASE_L	0x48
+#define POE_CL4_ENQ_SPILL_BASE_H	0x49
+#define POE_CL5_ENQ_SPILL_BASE_L	0x4a
+#define POE_CL5_ENQ_SPILL_BASE_H	0x4b
+#define POE_CL6_ENQ_SPILL_BASE_L	0x4c
+#define POE_CL6_ENQ_SPILL_BASE_H	0x4d
+#define POE_CL7_ENQ_SPILL_BASE_L	0x4e
+#define POE_CL7_ENQ_SPILL_BASE_H	0x4f
+
+#define POE_CL0_DEQ_SPILL_BASE_L	0x50
+#define POE_CL0_DEQ_SPILL_BASE_H	0x51
+#define POE_CL1_DEQ_SPILL_BASE_L	0x52
+#define POE_CL1_DEQ_SPILL_BASE_H	0x53
+#define POE_CL2_DEQ_SPILL_BASE_L	0x54
+#define POE_CL2_DEQ_SPILL_BASE_H	0x55
+#define POE_CL3_DEQ_SPILL_BASE_L	0x56
+#define POE_CL3_DEQ_SPILL_BASE_H	0x57
+#define POE_CL4_DEQ_SPILL_BASE_L	0x58
+#define POE_CL4_DEQ_SPILL_BASE_H	0x59
+#define POE_CL5_DEQ_SPILL_BASE_L	0x5a
+#define POE_CL5_DEQ_SPILL_BASE_H	0x5b
+#define POE_CL6_DEQ_SPILL_BASE_L	0x5c
+#define POE_CL6_DEQ_SPILL_BASE_H	0x5d
+#define POE_CL7_DEQ_SPILL_BASE_L	0x5e
+#define POE_CL7_DEQ_SPILL_BASE_H	0x5f
+
+#define POE_CL0_ENQ_SPILL_MAXLINE	0x64
+#define POE_CL1_ENQ_SPILL_MAXLINE	0x65
+#define POE_CL2_ENQ_SPILL_MAXLINE	0x66
+#define POE_CL3_ENQ_SPILL_MAXLINE	0x67
+#define POE_CL4_ENQ_SPILL_MAXLINE	0x68
+#define POE_CL5_ENQ_SPILL_MAXLINE	0x69
+#define POE_CL6_ENQ_SPILL_MAXLINE	0x6a
+#define POE_CL7_ENQ_SPILL_MAXLINE	0x6b
+
+#define POE_CL0_DEQ_SPILL_MAXLINE	0x6c
+#define POE_CL1_DEQ_SPILL_MAXLINE	0x6d
+#define POE_CL2_DEQ_SPILL_MAXLINE	0x6e
+#define POE_CL3_DEQ_SPILL_MAXLINE	0x6f
+#define POE_CL4_DEQ_SPILL_MAXLINE	0x70
+#define POE_CL5_DEQ_SPILL_MAXLINE	0x71
+#define POE_CL6_DEQ_SPILL_MAXLINE	0x72
+#define POE_CL7_DEQ_SPILL_MAXLINE	0x73
+
+#define POE_DIST_THRESHOLD_0 	0x200
+#define POE_DEST_THRESHOLD	0x204
+#define POE_DIST_ENABLE 0x205
+#define POE_DIST_VEC0	0x100
+#define POE_DIST_THRESHOLD_VAL 0xa
+#define POE_MAX_LOCAL_MSGS (6 << 10) // 6K
+#define POE_TX_TIMER     0x214
+#define POE_FBP_SP       0xb8
+#define POE_FBP_SP_EN    0xb9
+#define POE_LOC_ALLOC_EN 0xba
+#define POE_EXT_ALLOC_EN 0xbb
+#define POE_LOCAL_FBP_BASE 0x400
+
+#define POE_ENQ_SPILL_THOLD	0x208
+#define POE_DEQ_SPILL_THOLD	0x209
+#define POE_DEQ_SPILL_TIMER	0x20A
+#define POE_DISTR_CLASS_DROP_EN	0x20B	
+#define POE_DISTR_VEC_DROP_EN	0x20C
+#define POE_DISTRVEC_DROP_TIMER	0x20D
+
+#define EXT_FBP_START_ADDR       0x1800
+#define MAX_POE_EXT_MSG_STORAGE  (58 << 10) /* 58K entries */
+#define POE_FBP_SP_INIT	 	 0x740
+
+#define XLP3XX_EXT_FBP_START_ADDR	0x1000
+#define XLP3XX_POE_MAX_LOCAL_MSGS	(4 << 10)
+#define XLP3XX_MAX_POE_EXT_MSG_STORAGE 	(28 << 10)
+#define XLP3XX_POE_FBP_SP_INIT	 	0x380
+
+enum POE_SW_CODE {
+	DROP_IN_NAE = 0,
+	FWD_DEST,
+	RENQ_DVEC,
+	RENQ_DEST,
+	FWD_DVEC,
+	DROP_IN_POE,
+	RENQ_DVEC_SERIAL,
+	RENQ_DEST_SERIAL
+};
+
+/*
+ *  UCORE
+ */
+#define MAX_NAE_UCORES 16
+#define NAE_UCORE_MASK 0xffff
+#define CODE_SIZE_PER_UCORE (4 << 10)
+#define UC_MAGIC_REG_OFFSET_TO_INDEX(offset) (((offset) - 0x8000)/4)
+#define UCORE_OUTBUF_DONE  0x8000
+#define UCORE_RX_PKT_RDY  0x8004
+#define UCORE_RX_PKT_INFO  0x8008
+#define UCORE_CAM0  0x800c
+#define UCORE_CAM1  0x8010
+#define UCORE_CAM2  0x8014
+#define UCORE_CAM3  0x8018
+#define UCORE_CAM_RES  0x801c
+#define UCORE_CSUM_INFO  0x8020
+#define UCORE_CRC_INFO  0x8024
+#define UCORE_CRC_POS  0x8028
+#define UCORE_FREE_FIFO_EMPTY  0x802c
+#define UCORE_PKT_DISTR  0x8030
+#define UCORE_MAGIC_REG_BASE UCORE_OUTBUF_DONE
+#define UCORE_MAGIC_REG_LIMIT UCORE_PKT_DISTR
+#define UCORE_MAX_MAGIC_REGS (1 + (UCORE_MAGIC_REG_LIMIT - UCORE_MAGIC_REG_BASE) / 4)
+
+#define UCORE_PKT_DISCARD 0x2
+
+/* Ucore Memory Map. To be used in Microcode based apps only */
+#define UCORE_SHARED_CAM_START 0x17000
+#define UCORE_SHARE_CAM_END    0x17bff
+#define UCORE_SHARED_MEM_START 0x18000
+#define UCORE_SHARE_MEM_END    0x1ffff
+
+/* Ucore Shared memory Map for cpu. To be used in cpu only, to access ucore shared mem */
+#define UCORE_CPU_SHARED_CAM_START 0x18000
+#define UCORE_CPU_SHARED_CAM_END   0x18bff
+#define UCORE_CPU_SHARED_MEM_START 0x10000
+#define UCORE_CPU_SHARED_MEM_END   0x17fff
+
+
+/*1588-PTP CLOCK selection*/
+#define NET_SYS_CLK 		0
+#define INT_SYNCE_CLK		1
+#define GPIO_1588_CLK		2
+#define SGMII_REF_CLK		3
+
+enum {
+	PHYMODE_NONE = 0,
+	PHYMODE_HS_SGMII = 1,
+	PHYMODE_XAUI = 1,
+	PHYMODE_SGMII = 2,
+	PHYMODE_IL = 3,
+        PHYMODE_RXAUI = 6,
+
+        /* NET Version 1 
+        PHYMODE_XLAUI = 4,
+        */
+        /* submodes */
+        PHYMODE_XFI,
+};
+
+enum {
+	LM_UNCONNECTED = 0,
+	LM_SGMII = 1,
+	LM_XAUI = 2,
+	LM_IL = 3,
+};	
+
+#define MAX_GMAC_PORT			18
+#define MAX_CPLX_BLOCK                  5
+#define MAX_LANE_PER_CPLX               4
+
+/*PRM: VSEMI  CONFIG REGISTERS*/
+#define VSEMI_CMD 			0x9
+#define VSEMI_CTL0			0xA
+	#define VSEMI_CTL_POR			(1<<9)
+	#define VSEMI_CTL_SYNTH_RST		(1<<10)
+	#define VSEMI_CTL_RTHR			(0xf<<12)	
+#define VSEMI_CTL1			0xB
+
+	#define VSEMI_CTL_MASK_DR	(0x7)
+	#define VSEMI_CTL_RXAUI_10G_DR	(0x3)
+	#define VSEMI_CTL_XAUI_16G_DR	(0x3)
+	#define VSEMI_CTL_XAUI_12G_DR	(0x3)
+	#define VSEMI_CTL_XAUI_DR	(0x2)
+	#define VSEMI_CTL_SGMII_DR	(0x1)
+
+	#define VSEMI_CTL_MASK_DW	(0x70)
+	#define VSEMI_CTL_RXAUI_10G_DW	(0x30)
+	#define VSEMI_CTL_XAUI_16G_DW	(0x10)
+	#define VSEMI_CTL_XAUI_12G_DW	(0x10)
+	#define VSEMI_CTL_XAUI_DW	(0x10)
+	#define VSEMI_CTL_SGMII_DW	(0x10)
+	
+#define VSEMI_STATUS			0xC
+#define VSEMI_PINCTRL			0xD
+#define VSEMI_PIN_STS			0XE
+		
+ 
+
+/*
+ * PRM: 11.10.2 PHY and PMA Controller Registers
+ */
+#define PHY_LANE_0_STATUS               0
+#define PHY_LANE_1_STATUS               1
+#define PHY_LANE_2_STATUS               2
+#define PHY_LANE_3_STATUS               3
+    #define PHY_LANE_STAT_SRCS          0x00000001 /* bit 1: Rx clock stable if 1 */
+    #define PHY_LANE_STAT_STD           0x00000010 /* bit 4: Transmit Detect if 1 */
+    #define PHY_LANE_STAT_SFEA          0x00000020 /* bit 5: Far end absent if 1 */
+    #define PHY_LANE_STAT_STCS          0x00000040 /* bit 6: Tx clock stable if 1 */
+    #define PHY_LANE_STAT_SPC           0x00000200 /* bit  9: SGMII PCS Sync bit; 1:synced 0:fault*/
+    #define PHY_LANE_STAT_XLF           0x00000400 /* bit 10: XAUI lane sync bit; 0:synced 1:fault*/
+    #define PHY_LANE_STAT_PCR           0x00000800 /* bit 11: PMA Controller Ready; 1:ready */
+    //#define XAUI_LANE_FAULT                 0x400
+    #define LANE_RX_CLK                     (1 << 0)
+    #define LANE_TX_CLK                     (1 << 6)
+#define PHY_LANE_0_CTRL                 4
+#define PHY_LANE_1_CTRL                 5
+#define PHY_LANE_2_CTRL                 6
+#define PHY_LANE_3_CTRL                 7
+    #define PHY_LANE_CTRL_DATA_POS      0
+    #define PHY_LANE_CTRL_ADDR_POS      8
+    #define PHY_LANE_CTRL_CMD_READ      0x00010000
+    #define PHY_LANE_CTRL_CMD_WRITE     0x00000000
+    #define PHY_LANE_CTRL_CMD_START     0x00020000
+    #define PHY_LANE_CTRL_CMD_PENDING   0x00040000
+    #define PHY_LANE_CTRL_RESET_PMA	0x00100000	
+    #define PHY_LANE_CTRL_ALL           0x00200000
+    #define PHY_LANE_CTRL_FAST_INIT     0x00400000
+    #define PHY_LANE_CTRL_REXSEL_POS    23
+    #define PHY_LANE_CTRL_PHYMODE_POS   25
+    #define PHY_LANE_CTRL_PWRDOWN       0x20000000
+    #define PHY_LANE_CTRL_RST           0x40000000
+    #define PHY_LANE_CTRL_RST_XAUI      0xc0000000
+    #define PHY_LANE_CTRL_BPC_XAUI      0x80000000
+#define LANE_CFG_CPLX_0_1               0x0
+#define LANE_CFG_CPLX_2_3               0x1
+#define LANE_CFG_CPLX_4                 0x2
+    #define LANE_CFG_LANE_0_POS         0
+    #define LANE_CFG_LANE_1_POS         4
+    #define LANE_CFG_LANE_2_POS         8
+    #define LANE_CFG_LANE_3_POS         12
+
+    #define LANE_CFG_DISCONNECT         0
+    #define LANE_CFG_GMAC               1
+    #define LANE_CFG_XGMAC              2
+    #define LANE_CFG_8ILAKEN            3
+#define NET_INTF_SOFT_RST               0x3
+
+#define INT_MDIO_CTRL                   0x19
+    #define INT_MDIO_CTRL_ST		0
+    #define INT_MDIO_CTRL_ST_POS        0
+    #define INT_MDIO_CTRL_OP_POS        2
+    #define INT_MDIO_CTRL_PHYADDR_POS   4
+    #define INT_MDIO_CTRL_DEVTYPE_POS   9
+    #define INT_MDIO_CTRL_TA_POS        14
+    #define INT_MDIO_CTRL_TA    	0x02
+    #define INT_MDIO_CTRL_MIIM_POS      16
+    #define INT_MDIO_CTRL_LOAD_POS      19
+    #define INT_MDIO_CTRL_XDIV_POS      21
+    #define INT_MDIO_CTRL_MCDIV_POS     28
+    #define INT_MDIO_CTRL_RST           0x40000000
+    #define INT_MDIO_CTRL_SMP           0x00100000
+    #define INT_MDIO_CTRL_CMD_LOAD      0x00080000
+
+    #define INT_MDIO_CTRL_XDIV		7
+    #define INT_MDIO_CTRL_MCDIV		1
+		
+#define INT_MDIO_CTRL_DATA              0x1A
+#define INT_MDIO_RD_STAT                0x1B
+    #define INT_MDIO_RD_STAT_MASK       0x0000FFFF
+    #define INT_MDIO_STAT_LFV           0x00010000
+    #define INT_MDIO_STAT_SC            0x00020000
+    #define INT_MDIO_STAT_SM            0x00040000
+    #define INT_MDIO_STAT_MIILFS        0x00080000
+    #define INT_MDIO_STAT_MBSY          0x00100000
+#define INT_MDIO_LINK_STAT              0x1C
+
+#define EXT_XG0_MDIO_CTRL               0x25
+#define EXT_XG1_MDIO_CTRL               0x29
+    #define EXT_XG_MDIO_CTRL_ST		0
+    #define EXT_XG_MDIO_CTRL_OP_POS     2
+#define MDIO_CTRL_OP_INDIRECT_ADDR      0x00
+#define MDIO_CTRL_OP_WRITE_10G_MMD      0x01
+#define MDIO_CTRL_OP_READ_10G_MMD       0x02
+#define MDIO_CTRL_OP_POST_RDINC_ADDR    0x03
+
+    #define EXT_XG_MDIO_CTRL_PHYADDR_POS	4
+    #define EXT_XG_MDIO_CTRL_REG_POS		9
+    #define EXT_XG_MDIO_CTRL_TA    	0x02
+    #define EXT_XG_MDIO_CTRL_TA_POS     14
+    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
+    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
+    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
+    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
+    #define EXT_XG_MDIO_CTRL_RST        0x40000000
+    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
+    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
+    #define MDIO_MIIM_CMD_IDLE		0x000
+    #define MDIO_MIIM_CMD_WRITE		0x001
+    #define MDIO_MIIM_CMD_READ		0x002
+    #define MDIO_MIIM_CMD_SM		0x003
+    #define MDIO_MIIM_CMD_MM		0x004
+    #define MDIO_MIIM_CMD_10G_MMD	0x005
+    #define MDIO_MIIM_CMD_CLEAR_LINK	0x006
+
+#define EXT_G0_MDIO_CTRL                0x1D
+#define EXT_G1_MDIO_CTRL                0x21
+    #define EXT_G_MDIO_CLOCK_DIV_4      0
+    #define EXT_G_MDIO_CLOCK_DIV_2      1
+    #define EXT_G_MDIO_CLOCK_DIV_1      2
+    #define EXT_G_MDIO_REGADDR_POS      5
+    #define EXT_G_MDIO_PHYADDR_POS      10
+    #define EXT_G_MDIO_CMD_SP           0x00008000
+    #define EXT_G_MDIO_CMD_PSIA 		0x00010000
+    #define EXT_G_MDIO_CMD_LCD          0x00020000
+    #define EXT_G_MDIO_CMD_RDS          0x00040000
+    #define EXT_G_MDIO_CMD_SC           0x00080000
+    #define EXT_G_MDIO_MMRST            0x00100000
+    #define EXT_G_MDIO_DIV              0x0000001E	
+    #define EXT_G_MDIO_DIV_WITH_HW_DIV64 0x00000010
+    #define EXT_G_MDIO_DIV_WITH_HW_DIV64_11 0x00000011
+
+#define EXT_G0_MDIO_CTRL_DATA           0x1E
+#define EXT_G1_MDIO_CTRL_DATA           0x22
+
+#define EXT_G0_MDIO_LINK_STAT           0x20
+#define EXT_G1_MDIO_LINK_STAT           0x24
+
+#define EXT_G0_MDIO_RD_STAT             0x1F
+#define EXT_G1_MDIO_RD_STAT             0x23
+    #define EXT_G_MDIO_RD_STAT_MASK     0x0000FFFF
+    #define EXT_G_MDIO_STAT_LFV         0x00010000
+    #define EXT_G_MDIO_STAT_SC          0x00020000
+    #define EXT_G_MDIO_STAT_SM          0x00040000
+    #define EXT_G_MDIO_STAT_MIILFS      0x00080000
+    #define EXT_G_MDIO_STAT_MBSY        0x80000000
+    #define MDIO_OP_CMD_READ            0x10
+    #define MDIO_OP_CMD_WRITE           0x01
+
+#define EXT_XG0_MDIO_CTRL               0x25
+#define EXT_XG1_MDIO_CTRL               0x29
+    #define EXT_XG_MDIO_CTRL_ST_POS     0
+    #define EXT_XG_MDIO_CTRL_OP_POS     2
+    #define EXT_XG_MDIO_CTRL_PHYADDR_POS        4
+    #define EXT_XG_MDIO_CTRL_DEVTYPE_POS        9
+    #define EXT_XG_MDIO_CTRL_TA_POS     14
+    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
+    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
+    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
+    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
+    #define EXT_XG_MDIO_CTRL_RST        0x40000000
+    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
+    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
+
+#define EXT_XG0_MDIO_CTRL_DATA          0x26
+#define EXT_XG1_MDIO_CTRL_DATA          0x2A
+
+#define EXT_XG0_MDIO_LINK_STAT          0x28
+#define EXT_XG1_MDIO_LINK_STAT          0x2C
+
+#define EXT_XG0_MDIO_RD_STAT            0x27
+#define EXT_XG1_MDIO_RD_STAT            0x2B
+    #define EXT_XG_MDIO_RD_STAT_MASK    0x0000FFFF
+    #define EXT_XG_MDIO_STAT_LFV        0x00010000
+    #define EXT_XG_MDIO_STAT_SC         0x00020000
+    #define EXT_XG_MDIO_STAT_SM         0x00040000
+    #define EXT_XG_MDIO_STAT_MIILFS     0x00080000
+    #define EXT_XG_MDIO_STAT_MBSY       0x00100000
+
+#define GMAC_FC_SLOT0                   0x2D
+#define GMAC_FC_SLOT1                   0x2E
+#define GMAC_FC_SLOT2                   0x2F
+#define GMAC_FC_SLOT3                   0x30
+
+#define XAUI_CONFIG_0                   0
+    #define XAUI_CONFIG_MACRST          0x80000000
+    #define XAUI_CONFIG_RSTRCTL         0x00400000
+    #define XAUI_CONFIG_RSTRFN          0x00200000
+    #define XAUI_CONFIG_RSTTCTL         0x00040000
+    #define XAUI_CONFIG_RSTTFN          0x00020000
+    #define XAUI_CONFIG_RSTMIIM         0x00010000
+
+#define XAUI_CONFIG_1                   1
+    #define XAUI_CONFIG_TCTLEN          0x80000000
+    #define XAUI_CONFIG_TFEN            0x40000000
+    #define XAUI_CONFIG_RCTLEN          0x20000000
+    #define XAUI_CONFIG_RFEN            0x10000000
+    #define XAUI_CONFIG_DRPLT64         0x00000020
+    #define XAUI_CONFIG_LENCHK          0x00000008
+    #define XAUI_CONFIG_GENFCS          0x00000004
+    #define XAUI_CONFIG_PAD_0           0x00000000
+    #define XAUI_CONFIG_PAD_64          0x00000001
+    #define XAUI_CONFIG_PAD_COND        0x00000002
+    #define XAUI_CONFIG_PAD_68          0x00000003
+
+#define XAUI_CONFIG_2                   2
+
+#define XAUI_CONFIG_3                   3
+
+#define XAUI_MAX_FRAME_LEN              8
+#define XAUI_PHY_CTRL_1                 0x00
+    #define XAUI_PHY_RST                0x8000
+    #define XAUI_PHY_LOOPBACK           0x4000
+    #define XAUI_PHY_SPSEL1             0x2000
+    #define XAUI_PHY_LOW_POWER          0x0800
+    #define XAUI_PHY_SPSEL0             0x0040
+    #define XAUI_PHY_10G                0x0000
+
+#define XAUI_PHY_STAT_1                 0x01
+    #define XAUI_PHY_FAULT_DP           0x0008
+    #define XAUI_PHY_LINK_UP            0x0004
+    #define XAUI_PHY_LOWPOWER           0x0002
+
+#define XAUI_PHY_SPEED_CAP              0x04
+    #define XAUI_PHY_10G_CAP            0x0001
+
+#define XAUI_PHY_DEV_PRESENT            0x05
+    #define XAUI_PHY_DTE_XS_DP          0x0020
+    #define XAUI_PHY_XS_DP              0x0010
+    #define XAUI_PHY_PCS_DP             0x0008
+    #define XAUI_PHY_WIS_DP             0x0004
+    #define XAUI_PHY_PMD_PMA_DP         0x0002
+    #define XAUI_PHY_CL22_DP            0x0001
+
+#define XAUI_PHY_STAT_2                 0x08
+    #define XAUI_PHY_STAT2_DP           0x2000
+    #define XAUI_PHY_TXF                0x0800
+    #define XAUI_PHY_RXF                0x0400
+#define XAUI_LANE_STAT                  0x18
+    #define XAUI_LANE_ALIGNED           0x1000
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_LOOPBACK_EN       0x0400
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_L3S               0x0008
+    #define XAUI_LANE_L2S               0x0004
+    #define XAUI_LANE_L1S               0x0002
+    #define XAUI_LANE_L0S               0x0001
+
+#define XAUI_PHY_TEST_CTRL              0x19
+    #define XAUI_PHY_TEST_PATTERN_EN    0x04
+    #define XAUI_PHY_TEST_HI_FREQ       0x00
+    #define XAUI_PHY_TEST_LOW_FREQ      0x01
+    #define XAUI_PHY_TEST_MIXED_FREQ    0x02
+
+
+#define NETIOR_HIGIG2_CTRL0		0x70
+#define NETIOR_HIGIG2_CTRL1		0x71
+#define NETIOR_HIGIG2_CTRL2		0x72
+#define NETIOR_HIGIG2_PAUSE_CTRL1	0x73
+#define NETIOR_HIGIG2_MACSA		0x74
+#define NETIOR_HIGIG2_STATUS		0x75
+#define NETIOR_HIGIG2_MISC		0x76
+
+
+#define NETIOR_GMAC_CTRL1		0x7F
+	#define NETIOR_GMAC_TX_PFC_EN_POS	13
+	#define NETIOR_GMAC_RX_PFC_EN_POS	12
+	#define NETIOR_GMAC_TX_PAUSE_POS	10
+
+	
+#define NETIOR_XGMAC_CTRL1              0x7F
+    #define NETIOR_XGMAC_RXAUI_DC_POS        30 /* Rxaui Disparity calculation */
+    #define NETIOR_XGMAC_RXAUI_EN_POS        29 /* Enable RXAUI Mode */
+
+    #define NETIOR_XGMAC_VLAN_DC_POS    28
+    #define NETIOR_XGMAC_PHYADDR_POS    23
+    #define NETIOR_XGMAC_DEVID_POS      18
+    #define NETIOR_XGMAC_STATS_EN_POS   17
+    #define NETIOR_XGMAC_STATS_CLR_POS	16	
+    #define NETIOR_XGMAC_TX_PFC_EN_POS  14
+    #define NETIOR_XGMAC_RX_PFC_EN_POS  13
+    #define NETIOR_XGMAC_SOFT_RST_POS   11
+    #define NETIOR_XGMAC_TX_PAUSE_POS   10
+
+    #define NETIOR_XGMAC_RXAUI_SCRAMBLER_POS 4
+
+#define NETIOR_XGMAC_CTRL2		0x7E
+#define NETIOR_XGMAC_CTRL3		0x7D
+
+#define MAC_ADDR0_LO			0x50
+#define MAC_ADDR0_HI			0x51
+#define MAC_FILTER_CONFIG		0x5c
+	#define MAC_FILTER_BCAST_EN_POS 	10
+	#define MAC_FILTER_MCAST_EN_POS		8
+	#define MAC_FILTER_ADDR0_VALID_POS 	0
+#define MAC_ADDR0_MASK_LO		0x58
+#define MAC_ADDR0_MASK_HI		0x59
+	
+// Interlaken Registers
+
+#define ILK_TX_CONTROL			0x00
+    #define ILK_TX_CTRL_RST_INF		0x80000000
+    #define ILK_TX_CTRL_RST_CORE	0x40000000
+    #define ILK_TX_CTRL_TXO		0x20000000
+    #define ILK_TX_CTRL_TXU		0x10000000
+    #define ILK_TX_CTRL_TXBE		0x08000000
+    #define ILK_TX_CTRL_DSW		0x00000200
+    #define ILK_TX_CTRL_BAD_LANE	0x00000100
+    #define ILK_TX_CTRL_RATELIM_EN	0x00000002
+    #define ILK_TX_CTRL_TX_EN		0x00000001
+    
+    #define ILK_TX_CTRL_FIFO_THR_POS	19
+    #define ILK_TX_CTRL_CAL_LEN_POS	15
+    #define ILK_TX_CTRL_BS_POS		12
+    #define ILK_TX_CTRL_BMAX_POS	10
+    #define ILK_TX_CTRL_BLS_POS		5
+    #define ILK_TX_CTRL_LLS_POS		2
+
+#define ILK_TX_RATE_LIMIT		0x01
+    #define ILK_TX_RATE_LIM_UI_POS	24
+    #define ILK_TX_RATE_LIM_DELTA_POS	12
+    #define ILK_TX_RATE_LIM_MTC_POS	0
+
+#define ILK_TX_META_CTRL		0x02
+    #define ILK_TX_META_CTRL_TXLEN_POS	16
+    #define ILK_TX_META_CTRL_RXLEN_POS	0
+
+#define ILK_RX_CONTROL			0x03
+    #define ILK_RX_CTRL_RST_CORE	0x00800000
+    #define ILK_RX_CTRL_BAD_LANE	0x00000004
+    #define ILK_RX_CTRL_FORCE_RESYNC	0x00000002
+    #define ILK_RX_CTRL_PKT_MODE	0x00000001
+
+    #define ILK_RX_CTRL_RST_LANE_POS	24
+    #define ILK_RX_CTRL_BMAX_POS	9
+    #define ILK_RX_CTRL_LLS_POS		6
+    #define ILK_RX_CTRL_BLS_POS		3
+
+#define ILK_RX_STATUS1			0x04
+    // All fields are RWC
+    #define ILK_RX_STAT1_MFS_POS	24
+    #define ILK_RX_STAT1_MFSE_POS	16
+    #define ILK_RX_STAT1_MFLE_POS	8
+    #define ILK_RX_STAT1_MFRE_POS	0
+
+#define ILK_RX_STATUS2			0x05
+    // All fields are RWC	
+    #define ILK_RX_STAT2_RDCV_POS	24
+    #define ILK_RX_STAT2_RDCE_POS	16
+    #define ILK_RX_STAT2_RDIS_POS	8
+    #define ILK_RX_STAT2_RDLS_POS	0	
+ 	
+#define ILK_GENERAL_CTRL1		0x06
+    #define ILK_GEN_CTRL1_RXBTE_POS	16
+    #define ILK_GEN_CTRL1_RXMBITS_POS	12	// PRM bug
+    #define ILK_GEN_CTRL1_RXFC_POS	8	// Bits 8..11 RXFC (This is not included in PRM)
+    #define ILK_GEN_CTRL1_TXMBITS_POS	0
+
+#define ILK_RX_STATUS3			0x07
+    #define ILK_RX_STAT3_CC_MAP		0x00080000
+    #define ILK_RX_STAT3_TIME_STAMP	0x00040000  //RWC
+    #define ILK_RX_STAT3_RXL_ALIGN	0x00020000
+    // Bits 16-0 RWC
+    #define ILK_RX_STAT3_WCRC_ERR	0x00010000
+    #define ILK_RX_STAT3_CWCRC_ERR	0x00008000
+    #define ILK_RX_STAT3_SS_ERR		0x00004000
+    #define ILK_RX_STAT3_MFLEN_ERR	0x00002000
+    #define ILK_RX_STAT3_MFRPT_ERR	0x00001000
+    #define ILK_RX_STAT3_WRDSYNC_ERR	0x00000800
+    #define ILK_RX_STAT3_MF_ERR		0x00000400
+    #define ILK_RX_STAT3_FRM_ERR	0x00000200
+    #define ILK_RX_STAT3_BADTYPE_ERR	0x00000100
+    #define ILK_RX_STAT3_SOP_ERR	0x00000080
+    #define ILK_RX_STAT3_EOP_ERR	0x00000040
+    #define ILK_RX_STAT3_LA_ERR		0x00000020
+    #define ILK_RX_STAT3_LM_ERR		0x00000010
+    #define ILK_RX_STAT3_BMAX_ERR	0x00000008
+    #define ILK_RX_STAT3_BURST_ERR	0x00000004
+    #define ILK_RX_STAT3_FIFO_OVF_ERR	0x00000002
+    #define ILK_RX_STAT3_OTHER_ERR	0x00000001
+
+#define ILK_RX_FC_TMAP0			0x08
+#define ILK_RX_FC_TMAP1			0x09
+#define ILK_RX_FC_TMAP2			0x0A
+#define ILK_RX_FC_TMAP3			0x0B
+#define ILK_RX_FC_TMAP4			0x0C
+
+#define ILK_RX_FC_TADDR			0x0D
+    #define ILK_RX_FC_RXMTUDROP_EN	0x40000000
+    #define ILK_RX_FC_REQ_VALID		0x00000020
+    #define ILK_RX_FC_WRITE_REQ		0x00000010
+
+    #define ILK_RX_FC_RXMTU_SIZE_POS	17  // size in 16byte words
+    #define ILK_RX_FC_TABLE_IDX_POS	0	
+
+#define ILK_GENERAL_CTRL2		0x0E
+    #define ILK_GEN_CTRL2_STATS_COR	0x40000000
+
+    #define ILK_GEN_CTRL2_SCS5_POS	25		    
+    #define ILK_GEN_CTRL2_SCS4_POS	20
+    #define ILK_GEN_CTRL2_SCS3_POS	15
+    #define ILK_GEN_CTRL2_SCS2_POS	10
+    #define ILK_GEN_CTRL2_SCS1_POS	5
+    #define ILK_GEN_CTRL2_SCS0_POS	0
+
+#define ILK_GENERAL_CTRL3		0x0F
+    #define ILK_GEN_CTRL3_LCS1_POS	17
+    #define ILK_GEN_CTRL3_LCS0_POS	14
+    #define ILK_GEN_CTRL3_MCS1_POS	12
+    #define ILK_GEN_CTRL3_MCS0_POS      10
+    #define ILK_GEN_CTRL3_SCS7_POS	5
+    #define ILK_GEN_CTRL3_SCS6_POS	0
+
+#define ILK_SMALL_COUNT0		0x10
+#define ILK_SMALL_COUNT1                0x11
+#define ILK_SMALL_COUNT2                0x12
+#define ILK_SMALL_COUNT3                0x13
+#define ILK_SMALL_COUNT4                0x14
+#define ILK_SMALL_COUNT5                0x15
+#define ILK_SMALL_COUNT6                0x16
+#define ILK_SMALL_COUNT7                0x17
+#define ILK_MID_COUNT0			0x18
+#define ILK_MID_COUNT1			0x19
+#define ILK_LARGE_COUNT_L0		0x1A
+#define ILK_LARGE_COUNT_L1              0x1B
+#define ILK_LARGE_COUNT_H0		0x1C
+#define ILK_LARGE_COUNT_H1              0x1D
+
+// Serdes Register
+#define SER_GEN1_PWR_DOWN		0x0E
+    #define SERDES_PMFF_ALL_SET		0x04
+
+#define SERDES_PRBS_CTRL		0x64
+    #define SERDES_LOOPBACK_EN		0x02
+
+#define ILK_BURST_MAX           	3 // 256 bytes   
+
+#define XLP_ILK_LANE_RATE_LOW           0       // 0, 19, 0
+#define XLP_ILK_LANE_RATE_HIDH          1       // 1, 19, 0
+
+#define XLP_ILK_PORT_0                  0
+#define XLP_ILK_PORT_1                  8
+
+#define XLP_ILK_PORT0_CS                3
+#define XLP_ILK_PORT1_CS                4
+
+#define XLP_ILK_MAX_LANES               8
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* #ifndef __NETSOC_DEV_H_ */
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index 3185703..6210559 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -32,6 +32,7 @@
 #define __BRCM_NETSOC_HALIFACE_H
 
 #include "nlm_hal.h"
+#include "netsoc_dev.h"
 #include "nlm_nae.h"
 #include "nlm_hal_nae.h"
 #include "xlp8xx_netsoc.h"
@@ -87,6 +88,7 @@ extern int __netsoc_ext_phy_an(net_port_t *netport);
 extern void __netsoc_init_ext_phy(net_port_t *netport);
 extern int __netsoc_enable_nae_hwparser(nae_t *nae);
 extern int __netsoc_disable_nae_hwparser(nae_t *nae);
+extern int __netsoc_config_nae_l2parser_perport(nae_t *nae, l2_parser_config_t *l2, uint32_t portnum);
 extern int __netsoc_config_nae_l2parser(nae_t *nae, l2_parser_config_t *l2);
 extern int __netsoc_config_nae_l3parser(nae_t *nae, l3_parser_config_t *l3_cfg, int entry);
 extern int __netsoc_config_nae_l4parser(nae_t *nae, l4_parser_config_t *l4_cfg, int entry);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index f9e9b09..45dd30a 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -43,8 +43,8 @@ extern void (*netsoc_lib_writel)(uint64_t base, uint32_t index, uint32_t val);
 
 extern void *(*netsoc_lib_contig_malloc)(uint32_t align, uint32_t size);
 extern void (*netsoc_lib_contig_free)(void *buf);
-extern unsigned long long (*netsoc_lib_virttophys)(void *);
-extern void *(*netsoc_lib_phystovirt)(unsigned long long);
+extern uint64_t (*netsoc_lib_virttophys)(void *);
+extern void *(*netsoc_lib_phystovirt)(uint64_t);
 
 
 enum netsoc_api_dbglevels{
@@ -74,7 +74,7 @@ struct netsoc_lib_param {
         void *(*malloc)(uint32_t size);
         void (*free)(void *buf);
 
-        uint16_t (*readw)(uint64_t base, uint16_t index);
+        uint16_t (*readw)(uint64_t base, uint32_t index);
         void (*writew)(uint64_t base, uint32_t index, uint16_t val);
         uint32_t (*readl)(uint64_t base, uint32_t index);	
         void (*writel)(uint64_t base, uint32_t index, uint32_t val);
@@ -83,8 +83,8 @@ struct netsoc_lib_param {
 
         void *(*contig_alloc)(uint32_t align, uint32_t size);
         void (*contig_free)(void *buf);
-        unsigned long long (*virt_to_phys)(void *);
-        void *(*phys_to_virt)(unsigned long long);
+        uint64_t (*virt_to_phys)(void *);
+        void *(*phys_to_virt)(uint64_t);
 };
 
 static inline void *netsoc_api_contig_malloc(uint32_t align, uint32_t size)
@@ -108,26 +108,32 @@ static inline void *netsoc_api_phystovirt(uint64_t addr)
         return netsoc_lib_phystovirt((unsigned long long)addr);
 }
 
-static inline void *netsoc_api_malloc(uint32_t size, uint32_t align)
+static inline void *netsoc_api_malloc(uint32_t size)
 {
+	if (netsoc_lib_malloc != NULL) {
+		return netsoc_lib_malloc(size);
+	}
+	else {
 #if defined(NLM_HAL_LINUX_USER)
-	return malloc(size);
+		return malloc(size);
 #elif defined(NLM_HAL_LINUX_KERNEL)
-	return kmalloc(size, GFP_KERNEL);
-#else
-	return netsoc_lib_malloc(size);
+		return kmalloc(size, GFP_KERNEL);
 #endif
+	}
 }
 
 static inline void netsoc_api_free(void *buf)
 {
+	if (netsoc_lib_free != NULL) {
+		netsoc_lib_free(buf);
+	}
+	else {
 #if defined(NLM_HAL_LINUX_USER)
-	free(buf);
+		free(buf);
 #elif defined(NLM_HAL_LINUX_KERNEL)
-	kfree(buf);
-#else
-	netsoc_lib_free(buf);
+		kfree(buf);
 #endif
+	}
 }
 
 
@@ -147,30 +153,46 @@ static inline void netsoc_api_delay(uint32_t x)
 
 static inline uint32_t netsoc_api_readl(uint64_t base, uint32_t index)
 {
+	if (netsoc_lib_readl != NULL) {
+		return netsoc_lib_readl(base, index);
+	}
+	else {
 #if defined(NLM_HAL_LINUX_USER)
-	return nlm_uaccess_mem_read32(NLH_XKPHYS_UNCACHED | (base + (index << 2)));
+		return nlm_uaccess_mem_read32(NLH_XKPHYS_UNCACHED | (base + (index << 2)));
 #elif defined(NLM_HAL_LINUX_KERNEL)
-	return lw_40bit_phys_uncached(base + (index << 2));
-#else
-        return netsoc_lib_readl(base, index);
+		return lw_40bit_phys_uncached(base + (index << 2));
 #endif
+	}
 }
 
 static inline void netsoc_api_writel(uint64_t base, uint32_t index, uint32_t val )
 {
+	if (netsoc_lib_writel != NULL) {
+		netsoc_lib_writel(base, index, val);
+	}
+	else {
 #if defined(NLM_HAL_LINUX_USER)
-	nlm_uaccess_mem_write32(NLH_XKPHYS_UNCACHED | (base + (index << 2)), val);
+		nlm_uaccess_mem_write32(NLH_XKPHYS_UNCACHED | (base + (index << 2)), val);
 #elif defined(NLM_HAL_LINUX_KERNEL)
-	sw_40bit_phys_uncached(base + (index << 2), val);
-#else
-        netsoc_lib_writel(base, index, val);
+		sw_40bit_phys_uncached(base + (index << 2), val);
 #endif
+	}
 }
 
 #if defined(NLM_HAL_LINUX_KERNEL) 
-#define netsoc_api_print(dbglvl, fmt, args...) printk(fmt, ##args)
+#define netsoc_api_print(dbglvl, fmt, args...) \
+{ \
+        if (dbglvl & netsoc_api_dbglvl) { \
+                printk(fmt, ##args); \
+        } \
+}
 #elif defined(NLM_HAL_LINUX_USER)
-#define netsoc_api_print(dbglvl, fmt, args...) printf(fmt, ##args)
+#define netsoc_api_print(dbglvl, fmt, args...)  \
+{ \
+        if (dbglvl & netsoc_api_dbglvl) { \
+                printf(fmt,##args);   \
+        }\
+}
 #endif
 
 #define netsoc_write_nae_iface_reg(base, reg, val)      netsoc_api_writel((uint64_t) base, (reg), (val))
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h b/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
index d32761d..2da2900 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_msg.h
@@ -77,8 +77,18 @@ EGOP_IPCSUM_UDPCSUM,         /* IP and UDP checksum */
 EGOP_IPCSUM_SCTPCRC,         /* IP checksum and SCTP crc */
 }nae_egop_t;
 
+typedef enum {
+	NET_TX_FREEBACK=0,
+	NET_RX = 1,
+}net_msg_t;
+
+typedef enum {
+	NET_RX_P2D = 0,
+	NET_RX_P2P,
+}net_rxmsg_type;
+
 typedef struct {
-	nae_desc_t type;     /* nae descriptor type */
+	net_rxmsg_type type;     /* nae descriptor type */
 	uint32_t error;      /* Rx error status */
 	uint32_t context;    /* context number of the received packet*/
 	uint32_t frin_qnum;  /* FRIN queue used to DMA the received packet, valid in soc net version - 1*/
@@ -104,7 +114,7 @@ typedef struct {
 }poe_enq_info_t;
 
 typedef struct {
-	uint32_t type;       /* type indicates txack or rx, 0 - tx freeback, 1 - rx packet*/
+	net_msg_t type;       /* type indicates txack or rx, 0 - tx freeback, 1 - rx packet*/
 	void *port;          /* pointer to net_port_t */
 	union {
 		nae_rx_info_t rx;   /* received packet information if type is 1 */	
@@ -636,7 +646,7 @@ static inline void nae_decode_rxpktinfo(uint64_t naerxdesc, nae_rx_info_t *rxpkt
 {
 	rxpkt_info->context = rx_context(naerxdesc);
 	rxpkt_info->error = is_rx_err(naerxdesc);
-	rxpkt_info->type = is_p2p(naerxdesc) ? DESC_TYPE_P2P: 0;
+	rxpkt_info->type = is_p2p(naerxdesc) ? NET_RX_P2P: NET_RX_P2D;
 	rxpkt_info->msg = naerxdesc;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
index 01ffde5..5dded0d 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
@@ -31,7 +31,7 @@
 #ifndef __BRCM_NETSOC_MSGIFACE_H
 
 #define __BRCM_NETSOC_MSGIFACE_H
-
+#include "nlm_hal_fmn_dp.h"
 #include "netsoc_msg.h"
 
 extern int netsoc_nae_send_freein_buf(nae_t *nae, uint32_t frinq_num, uint64_t paddr);
@@ -55,389 +55,6 @@ extern int (*poe_send_resp)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_i
 #define netsoc_poe_send_deq         poe_send_deq
 #define netsoc_poe_send_resp        poe_send_resp
 
-/*Cop2 Regs */
-#define XLP_TX_BUF_REG          $0
-#define XLP_RX_BUF_REG          $1
-#define XLP_MSG_TXSTATUS_REG    $2
-#define XLP_MSG_RXSTATUS_REG    $3
-#define XLP_MSG_STATUS1_REG     $4
-#define XLP_MSG_CONFIG_REG      $5
-#define XLP_MSG_CONFIG1_REG     $6
-#define XLP_MSG_INT_REG         $8
-
-#ifndef __STR
-#define __STR(x) #x
-#endif
-#ifndef STR
-#define STR(x) __STR(x)
-#endif
-
-
-/*
- *  COP2 Reg access macros
- */
-#define _read_32bit_cp2_register(source)                        \
-({ int __res;                                                   \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set\treorder\n\t"                                     \
-        "mfc2\t%0,"STR(source)"\n\t"                            \
-        ".set\tpop"                                             \
-        : "=r" (__res));                                        \
-        __res;})
-
-#define _write_32bit_cp2_register(register,value)               \
-        __asm__ __volatile__(                                   \
-        "mtc2\t%0,"STR(register)"\n\t"                          \
-        "nop"                                                   \
-        : : "r" (value));
-
-#define _read_32bit_cp2_register_sel(source, sel)               \
-({ int __res;                                                   \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set mips32\n\t"                                       \
-        "mfc2\t%0,"STR(source)", %1\n\t"                        \
-        ".set\tpop"                                             \
-        : "=r" (__res) : "i" (sel) );                           \
-        __res;})
-
-#define _write_32bit_cp2_register_sel(reg, value, sel)          \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set mips32\n\t"                                       \
-        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
-        ".set\tpop"                                             \
-        : : "r" (value), "i" (sel) );
-
-
-#ifndef _ABI64
-
-#define _read_64bit_cp2_register_sel(source, sel)                        \
-({                                                                      \
-        unsigned int high, low;                                         \
-                                                                        \
-                __asm__ __volatile__(                                   \
-                        ".set\tmips64\n\t"                              \
-                        "dmfc2\t$8, "STR(source)","STR(sel)"\n\t"       \
-                        "dsrl32\t%0, $8, 0\n\t"                         \
-                        "dsll32\t$8, $8, 0\n\t"                         \
-                        "dsrl32\t%1, $8, 0\n\t"                         \
-                        ".set\tmips0"                                   \
-                        : "=r" (high), "=r"(low): "i"(sel) : "$8");     \
-        ( (((unsigned long long)high)<<32) | low);                      \
-})
-
-#define _write_64bit_cp2_register_sel(source, val, sel)                 \
-do {                                                                    \
-     unsigned int high = val>>32;                                       \
-     unsigned int low  = val & 0xffffffff;                              \
-                __asm__ __volatile__(                                   \
-                        ".set\tmips64\n\t"                              \
-                        "dsll32 $8, %1, 0\n"                            \
-                        "dsll32 $9, %0, 0\n"                            \
-                        "dsrl32 $8, $8, 0\n"                            \
-                        "or     $8, $8, $9\n"                           \
-                        "dmtc2\t$8, "STR(source)", %2\n\t"              \
-                        ".set\tmips0"                                   \
-                        : : "r" (high), "r" (low), "i"(sel): "$8", "$9");               \
-} while (0)
-
-#define _read_64bit_cp2_register(source) \
-        _read_64bit_cp2_register_sel(source, 0)
-#define _write_64bit_cp2_register(source, val) \
-        _write_64bit_cp2_register_sel(source, val, 0)
-
-#else /* _ABI64 */
-#define _read_64bit_cp2_register(source)                        \
-({ unsigned long long __res;                                    \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set\treorder\n\t"                                     \
-        ".set\tmips64\n\t"                                      \
-        "dmfc2\t%0,"STR(source)"\n\t"                           \
-        ".set\tpop"                                             \
-        : "=r" (__res));                                        \
-        __res;})
-
-#define _write_64bit_cp2_register(register,value)               \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set\treorder\n\t"                                     \
-        "dmtc2\t%0,"STR(register)"\n\t"                         \
-        "nop"                                                   \
-        ".set\tpop"                                             \
-        : : "r" (value));
-
-#define _read_64bit_cp2_register_sel(source, sel)               \
-({ unsigned long long __res;                                    \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set mips64\n\t"                                       \
-        "dmfc2\t%0,"STR(source)", %1\n\t"                       \
-        ".set\tpop"                                             \
-        : "=r" (__res) : "i" (sel) );                           \
-        __res;})
-
-#define _write_64bit_cp2_register_sel(reg, value, sel)          \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set mips64\n\t"                                       \
-        "dmtc2\t%0,"STR(reg)", %1\n\t"                          \
-        ".set\tpop"                                             \
-        : : "r" (value), "i" (sel) );
-
-#endif /* _ABI64 */
-
-#define xlp_read_rx_status() _read_32bit_cp2_register(XLP_MSG_RXSTATUS_REG)
-
-#define xlp_read_status1()   _read_32bit_cp2_register(XLP_MSG_STATUS1_REG)
-
-#define xlp_load_rx_msg0() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 0)
-#define xlp_load_rx_msg1() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 1)
-#define xlp_load_rx_msg2() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 2)
-#define xlp_load_rx_msg3() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 3)
-
-#define xlp_load_tx_msg0(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 0)
-#define xlp_load_tx_msg1(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 1)
-#define xlp_load_tx_msg2(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 2)
-#define xlp_load_tx_msg3(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 3)
-
-/*
- *  Messaging Operations 
- */
-/**
-* @brief xlp_send function is used to send any configured message to a destination, used by the HAL send message API's for different number of messages. Performs a sync before sending.
-*
-* @param [in]  dest             :Destination Message Queue number
-*
-* @return
-*  - "1" on  send success, "0" on failure
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline int xlp_send(unsigned int dest)
-{
-        unsigned int success = 0;
-
-        __asm__ volatile (".set push\n"
-                          ".set noreorder\n"
-                          ".set arch=xlp\n"
-                          "sync\n"
-                          "msgsnds %0, %1\n"
-                          ".set pop\n"
-                          : "=&r" (success)
-                          : "r" (dest));
-
-        return success;
-}
-
-/**
-* @brief xlp_receive function is used to receive message from a mailbox vc, used by the HAL receive message API's for different number of messages
-*
-* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
-*
-* @return
-*  - "1" on load success, "0" on failure
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline int xlp_receive(unsigned int vc)
-{
-        unsigned int success = 0;
-
-        __asm__ volatile (".set push\n"
-                          ".set noreorder\n"
-                          ".set arch=xlp\n"
-                          "msglds %0, %1\n"
-                          ".set pop\n"
-                          : "=&r" (success)
-                          : "r" (vc));
-
-        return success;
-}
-
-/**
-* @brief xlp_message_receive_1 function is used to receive a single entry message from a VC of the CPU. 
-*
-* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
-* @param [out]  src_id          :Source Message Queue Number
-* @param [out]  size            :# of messages that were in this received message (1 to 4)
-* @param [out]  code            :8b SW code of the received message
-* @param [out]  msg0            :64b data value for the first received message
-*
-* @return
-*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline int xlp_message_receive_1(uint32_t vc, uint32_t *src_id,
-        uint32_t *size, uint32_t *code, uint64_t *msg0)
-{
-        unsigned int status;
-
-        if (!xlp_receive(vc))
-                return -1;
-
-        status = xlp_read_rx_status();
-        *size = ((status >> 26) & 0x3) + 1;
-        *code = (status >> 18) & 0xff;
-        *src_id = (status >> 4) & 0xfff;
-        *msg0 = xlp_load_rx_msg0();
-        return (status & 0x3);
-}
-
-/**
-* @brief xlp_message_receive_2 function is used to receive a two entry message from a VC of the CPU. Size should be used to determine how many of msg0-msg1 have valid data and if there were more messages available.
-*
-* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
-* @param [out]  src_id          :Source Message Queue Number
-* @param [out]  size            :# of messages that were in this received message (1 to 4)
-* @param [out]  code            :8b SW code of the received message
-* @param [out]  msg0            :64b data value for the first received message
-* @param [out]  msg1            :64b data value for the second received message
-*
-* @return
-*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline int xlp_message_receive_2(uint32_t vc, uint32_t *src_id,
-        uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1)
-{
-        unsigned int status;
-
-        if (!xlp_receive(vc))
-                return -1;
-
-        status = xlp_read_rx_status();
-        *size = ((status >> 26) & 0x3) + 1;
-        *code = (status >> 18) & 0xff;
-        *src_id = (status >> 4) & 0xfff;
-        *msg0 = xlp_load_rx_msg0();
-        *msg1 = xlp_load_rx_msg1();
-        return (status & 0x3);
-}
-
-/**
-* @brief xlp_message_receive_3 function is used to receive three entry message from a VC of the CPU. Size should be used to determine how many of msg0-msg2 have valid data and if there were more messages available.
-*
-* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
-* @param [out]  src_id          :Source Message Queue Number
-* @param [out]  size            :# of messages that were in this received message (1 to 4)
-* @param [out]  code            :8b SW code of the received message
-* @param [out]  msg0            :64b data value for the first received message
-* @param [out]  msg1            :64b data value for the second received message
-* @param [out]  msg2            :64b data value for the third received message
-*
-* @return
-*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline int xlp_message_receive_3(uint32_t vc, uint32_t *src_id,
-        uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1, uint64_t *msg2)
-{
-        unsigned int status;
-
-        if (!xlp_receive(vc))
-                return -1;
-
-        status = xlp_read_rx_status();
-        *size = ((status >> 26) & 0x3) + 1;
-        *code = (status >> 18) & 0xff;
-        *src_id = (status >> 4) & 0xfff;
-        *msg0 = xlp_load_rx_msg0();
-        *msg1 = xlp_load_rx_msg1();
-        *msg2 = xlp_load_rx_msg2();
-        return (status & 0x3);
-}
-
-#define fmn_msg_recv_3		xlp_message_receive_3
-#define fmn_msg_recv_2 		xlp_message_receive_2
-#define fmn_msg_recv_1          xlp_message_receive_1
-
-/* API to send a 1 entry message to "stid" with given "code" */
-/**
-* @brief xlp_message_send_block_fast_1 function is a blocking API for sending a one entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
-*
-* @param [in]  code             :8b SW code to send with the message
-* @param [in]  dest_vc          :Destination Message Queue number
-* @param [in]  msg0             :64b data value for the first message
-*
-* @return
-*  - none
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline void xlp_message_send_block_fast_1(unsigned int code,
-                                                 unsigned int dest_vc,
-                                                 unsigned long long msg0)
-{
-  __asm__ __volatile__ (".set push\n"
-                        ".set noreorder\n"
-                        ".set arch=xlp\n"
-                        "dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
-                        "sync\n"
-                        "1: \n"
-                        "msgsnds  $8, %0\n"    /* msgsnds rD, rt */
-                        "andi $8, $8, 0x1\n"
-                        "beqz $8, 1b\n"
-                        "move $8, %0\n"
-                        ".set mips64\n"
-                        ".set pop\n"
-                        :
-                        : "r"((code << 24) |  dest_vc), /* %0 */
-                          "r"(msg0)
-                        : "$8"
-                        );
-}
-
-/* API to send a 2 entry message to "stid" with given "code" */
-/**
-* @brief xlp_message_send_block_fast_2 function is a blocking API for sending a two entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
-*
-* @param [in]  code             :8b SW code to send with the message
-* @param [in]  dest_vc          :Destination Message Queue number
-* @param [in]  msg0             :64b data value for the first message
-* @param [in]  msg1             :64b data value for the second message
-*
-* @return
-*  - none
-* 
-* @ingroup hal_fmn
-*
-*/
-static inline void xlp_message_send_block_fast_2(unsigned int code,
-                                                 unsigned int dest_vc,
-                                                 unsigned long long msg0,
-                                                 unsigned long long msg1)
-{
-  __asm__ __volatile__ (".set push\n"
-                        ".set noreorder\n"
-                        ".set arch=xlp\n"
-                        "dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
-                        "dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
-                        "sync\n"
-                        "1: \n"
-                        "msgsnds  $8, %0\n"    /* msgsnds rD, rt */
-                        "andi $8, $8, 0x1\n"
-                        "beqz $8, 1b\n"
-                        "move $8, %0\n"
-                        ".set mips64\n"
-                        ".set pop\n"
-                        :
-                        : "r"((code << 24) | (1 << 16) | dest_vc), /* %0 */
-                          "r"(msg0), "r" (msg1)
-                        : "$8"
-                        );
-}
 
 static __inline__ int netsoc_fmn_recv_2(uint32_t rxvc, uint32_t *node, uint32_t *nae_id, uint64_t *msg0, uint64_t *msg1)
 {
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 2bee537..0471dd2 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -37,10 +37,15 @@
 extern struct netsoc_info *current_netsoc;
 
 enum netv1_nae_reg{
-	GUESTID_ADDR_SP_CFG = 0x58,
-	FREE_IN_GST_MAP = 0x5A,
-	WRED_CMD_REG = 0x5B,
-	WRED_THRESH_REG = 0x5C,
+	TX_STG1_DEEPFIFO_CFG = 0x6c,
+	TX_IGNXOFF_CTX0_31 = 0x6d,
+	TX_IGNXOFF_CTX32_63 = 0x6e,
+	GUESTID_ADDR_SP_CFG = 0x90,
+	FREE_IN_GST_MAP = 0x91,
+	WRED_CMD_REG = 0x92,
+	WRED_THRESH_REG = 0x93,
+	RX_ST_FWD_MODE = 0x71,
+	CRC32_HASH_POLY = 0x72,
         ALE_BYPASS = 0x73,
 	STRING_DEST_OFF = 0x74,
 };
@@ -50,6 +55,7 @@ enum net_path{
 	INGRESS_PATH,
 };
 
+#define DEFAULT_PARSER_THR		384
 #define VAL_UCORE_RESET(x) 		(((x) &0xffff) << 8)
 #define NLM_NAE_MAX_XONOFF_THR_GRPS 	8
 
@@ -292,7 +298,14 @@ static inline void __netsoc_write_ucore_sprayvec(nae_t *nae, int hw_port_id, uin
 
 static inline void __netsoc_write_fifo_size(nae_t *nae, int hw_port_id, uint32_t size)
 {
-        netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_UNIQ_SZ_CFG, ((size/XLP_CACHELINE_SIZE) << 8) | (hw_port_id & 0x1f) );
+	uint32_t moddescsz, desc_size = (size/XLP_CACHELINE_SIZE) & 0xff;
+	
+	if ((desc_size == 0) || (desc_size > (DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE)))
+		moddescsz = (DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE) & 0xff;
+	else
+		moddescsz = ((DEFAULT_PARSER_THR / XLP_CACHELINE_SIZE) % desc_size) & 0xff;
+	
+        netsoc_write_nae_reg(nae->nae_base, FREE_IN_FIFO_UNIQ_SZ_CFG, (moddescsz << 16) | (desc_size << 8) | (hw_port_id & 0x1f) );
 }
 
 static inline void __netsoc_write_interface_fifo(nae_t *nae, int hw_port_id, uint32_t start, uint32_t size, uint32_t xoff_thresh)
@@ -303,8 +316,12 @@ static inline void __netsoc_write_interface_fifo(nae_t *nae, int hw_port_id, uin
                                        ((start & 0xff) << 8) | hw_port_id);
         netsoc_write_nae_reg(nae->nae_base, IFACE_FIFO_CFG, val);
 
-        netsoc_api_print(NETSOC_APIDBG_TRACE, "iface fifo config port %d addr %d size %d\n",hw_port_id, start, size);
-        netsoc_api_print(NETSOC_APIDBG_TRACE, "reg %x 0x%x\n",IFACE_FIFO_CFG, val);
+	//READ interface fifo register
+	val = (1<<31) | hw_port_id;
+	netsoc_write_nae_reg(nae->nae_base, IFACE_FIFO_CFG, val);
+	val = netsoc_read_nae_reg(nae->nae_base, IFACE_FIFO_CFG);
+        netsoc_api_print(NETSOC_APIDBG_TRACE, "IFACE_FIFO_CFG port %d start %d size %d xoffth %d \n",hw_port_id, 
+					((val >> 8) & 0xff), ((val >> 16) & 0x1ff) , ((val >> 25) & 0x3f));
 }
 
 static inline void __netsoc_write_rxbase(nae_t *nae, int hw_port_id, uint32_t base)
@@ -669,13 +686,18 @@ static inline int __netsoc_config_ale_disable(nae_t *nae)
        return 0;
 } 
 
-static inline int __netsoc_config_string_dest_offset(nae_t *nae, uint32_t offset)
+static inline int __netsoc_config_string_dest_offset(nae_t *nae, uint32_t offset, ucore_string_t string_type)
 {
+       uint32_t val;
+
        if (!(current_netsoc->hw_features & NETSOC_ALE))
                 return -NETSOC_API_NOT_SUPPORTED;
 
        netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s %d:%d\n",__func__,nae->node,nae->nae_id);
-       netsoc_write_nae_reg(nae->nae_base, STRING_DEST_OFF, offset);
+       val = netsoc_read_nae_reg(nae->nae_base, STRING_DEST_OFF);
+       val &= ~(0xF << ((string_type - 2) * 4));
+       val |= (offset << ((string_type - 2) * 4));
+       netsoc_write_nae_reg(nae->nae_base, STRING_DEST_OFF, val);
        return 0;
 }
 
@@ -749,7 +771,6 @@ static inline int __netsoc_config_per_freein(nae_t *nae, uint32_t frin_lifo, fri
 static inline int __netsoc_config_ucore_memtype(nae_t *nae, uint32_t type)
 {  
     volatile uint32_t ucore_cfg = 0;
-    int i = 0;
 
     if ((type==0) || (type == 1)) {
         ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);
@@ -805,6 +826,21 @@ static inline int __netsoc_config_burstmax(net_port_t *netport, uint32_t max)
         return 0;
 }
 
+static inline int __netsoc_get_burstmax(net_port_t *netport)
+{
+	uint64_t nae_base = netport->nae->nae_base;
+	int max;
+	volatile uint32_t data;
+
+	netsoc_write_nae_reg(nae_base, TX_IFACE_BURSTMAX_CMD, (netport->hw_port_id << 4));
+	do {
+		data = netsoc_read_nae_reg(nae_base, TX_IFACE_BURSTMAX_STATUS);
+	}while(!(data&0x1));
+	max = (data >> 4) & 0xFFFF;
+	return max;
+}
+
+
 static inline int  __netsoc_config_macen(net_port_t *netport, uint32_t enable, uint32_t path)
 {
         unsigned int mac_cfg1 = 0, xaui_cfg = 0;
@@ -896,4 +932,214 @@ static inline int __netsoc_nae_config_txrx(nae_t *nae, uint32_t enable, uint32_t
         }
         return NETSOC_API_SUCCESS;
 }
+
+static inline int __netsoc_map_context_toclass(nae_t *nae, uint32_t context, uint32_t class)
+{
+    	uint32_t val, index, ctxindex;
+    
+        if (context >= current_netsoc->max_contexts)
+              return -NETSOC_API_PARAM_INVALID;
+
+	index = context / 8;
+	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index); 
+        val = netsoc_read_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG);
+        ctxindex = ((context % 8) * 3) + 8;
+        val &= ~((0x7 << ctxindex) | (0xFF)); 
+        val |= (class << ctxindex);
+	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val | index);
+
+        netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index);
+        val = netsoc_read_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG);
+        netsoc_api_print(NETSOC_APIDBG_CONFIG,"%s context %d class %d \n",__func__, context, ((val >> ctxindex) & 0x7));
+        return NETSOC_API_SUCCESS;
+}
+
+static inline int __netsoc_config_drr_context(nae_t *nae, uint32_t context, uint64_t drr_quantum)
+{
+	uint32_t val, channel, interface;
+        uint64_t nae_base = nae->nae_base;
+        int i=0;
+
+	if (context >= current_netsoc->max_contexts)
+              return -NETSOC_API_PARAM_INVALID;
+
+        netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
+        // Read context schedule status
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5)); 
+	while(i++ <= 1000) {
+	        val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+		if (val & 0x1)
+		    break;
+	}				
+	if (i>1000)
+		return -NETSOC_ERROR_INTERNAL;
+
+        channel = (val >> 10) & 0xFF;
+        interface = (val >> 5) & 0x1F;
+ 
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD1,(uint32_t) drr_quantum);
+	val = (((drr_quantum >> 32) & 0x3) << 30) | (channel << 20) | (interface << 15) | (context << 5);
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, val | 1);
+
+	do {
+        	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , (context<<5));
+                val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+        }while(!(val & 0x1));
+	netsoc_api_print(NETSOC_APIDBG_CONFIG,"%s drrlo 0x%x\n",__func__, netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS1));
+        netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched scheduling context %d on port %d \n",(context), ((val>>5) & 0x1f));
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 1);
+
+	return NETSOC_API_SUCCESS;
+}
+
+
+static inline int __netsoc_config_pri_context(nae_t *nae, uint32_t context, uint32_t priority)
+{
+        uint32_t val, channel, interface;
+        uint64_t nae_base = nae->nae_base;
+	int i = 0;
+
+        if (context >= current_netsoc->max_contexts)
+              return -NETSOC_API_PARAM_INVALID;
+
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
+	
+        // Read context schedule status
+        netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5));
+	while(i++ <= 1000) {
+        	val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+		if (val & 0x1)
+		    break;
+	}
+	if (i>1000)
+                return -NETSOC_ERROR_INTERNAL;
+
+        channel = (val >> 10) & 0xFF;
+        interface = (val >> 5) & 0x1F;
+
+        val = (channel << 20) | (interface << 15) | (context << 5) | (1<<4) | ((priority & 0x7) << 1);
+        netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, val | 1);
+
+        do {
+                netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , (context<<5));
+                val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+        }while(!(val & 0x1));
+        netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched scheduling context %d on port %d \n",(context), ((val>>5) & 0x1f));
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 1);
+
+        return NETSOC_API_SUCCESS;
+}
+
+static inline int __netsoc_schedule_context_onport(nae_t *nae, uint32_t context, uint32_t hwport)
+{
+	uint64_t nae_base = nae->nae_base;
+	uint32_t drr_hi, drr_lo, sp, spnum, channel, val;
+        int i = 0;
+
+	if ((context >= current_netsoc->max_contexts) || (hwport >= current_netsoc->max_ports))
+		return -NETSOC_API_PARAM_INVALID;
+	
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 0x1);
+
+        // Read context schedule status
+        netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (context << 5));
+        while(i++ <= 1000) {
+                val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+                if (val & 0x1)
+                    break;
+        }
+        if (i>1000)
+                return -NETSOC_ERROR_INTERNAL;
+	
+	drr_hi = (val >> 30) & 0x3;
+        sp = (val >> 4) & 0x1;
+	spnum = (val >> 1) & 0x7;
+	channel = (val >> 10) & 0xFF;
+	drr_lo = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS1);
+
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD1, drr_lo);
+	val = (drr_hi << 30) | (channel << 20) | (hwport << 15) | (context << 5) | (sp << 4) | (spnum << 1);
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, (val | 1));
+
+        do {
+                netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , (context<<5));
+                val = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+        }while(!(val & 0x1));
+        netsoc_api_print(NETSOC_APIDBG_CONFIG,"%s drrlo 0x%x\n",__func__, netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS1));
+        netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched scheduling context %d on port %d \n",(context), ((val>>5) & 0x1f));
+	netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 1);
+
+        return NETSOC_API_SUCCESS;
+}
+
+static inline void __netsoc_config_rx_stfwd_mode(nae_t *nae, uint32_t rxspace)
+{
+	uint32_t val;
+
+        val = netsoc_read_nae_reg(nae->nae_base, RX_ST_FWD_MODE);
+	val &= ~(0x3FF);
+        val |= (1<<10) | (rxspace & 0x3FF);
+	netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, val);
+}
+
+static inline void __netsoc_drop_runt_pkts(nae_t *nae, uint32_t enable)
+{
+ 	uint32_t val;
+
+        val = netsoc_read_nae_reg(nae->nae_base, RX_ST_FWD_MODE);
+	val &= ~(1<<11);
+	val |= (enable << 11);
+	netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, val);
+}
+ 
+static inline int __netsoc_get_frame_size(net_port_t *netport)
+{
+        nae_t *nae = netport->nae;
+        uint64_t mac_base;
+        int size = -NETSOC_API_PARAM_INVALID;
+
+        switch(netport->iftype) {
+                case SGMII_IF:
+                        mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
+                        size = netsoc_read_mac_reg(mac_base, SGMII_MAX_FRAME_LEN);
+                        break;
+                case XAUI_IF:
+                case RXAUI_IF:
+                        mac_base = netsoc_get_macreg_base_for_xgmac(nae->mac_base, netport->hw_port_id);
+                        size = (netsoc_read_mac_reg(mac_base, XAUI_MAX_FRAME_LEN) >> 16) * 4;
+                        break;
+                default:
+                        return -NETSOC_API_PARAM_INVALID;
+        }
+        return size;
+}
+
+static inline int __netsoc_enable_deepfifo(nae_t *nae, uint32_t context)
+{
+	uint32_t val;
+	// enabling deep fifo for context n will disable context n+1 and
+        // n is even - 0,2,4...
+	if (context % 2)
+		return -NETSOC_API_PARAM_INVALID;
+
+	val = netsoc_read_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG);
+	val |= (1 << (context/2));
+	netsoc_write_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG, val);	
+	return NETSOC_API_SUCCESS;
+}
+
+static inline int __netsoc_disable_deepfifo(nae_t *nae, uint32_t context)
+{
+        uint32_t val;
+        // enabling deep fifo for context n will disable context n+1 and
+        // n is even - 0,2,4...
+        if (context % 2)
+                return -NETSOC_API_PARAM_INVALID;
+
+        val = netsoc_read_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG);
+        val &= ~(1 << (context/2));
+        netsoc_write_nae_reg(nae->nae_base, TX_STG1_DEEPFIFO_CFG, val);
+        return NETSOC_API_SUCCESS;
+}
+
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index 3110675..6b8b8ae 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -34,7 +34,8 @@
 #include <linux/netdevice.h>
 #endif
 #include "nlm_hal.h"
-
+#include "nlm_nae.h"
+#include "netsoc_dev.h"
 #define NUM_DIST_VEC 		16
 #define NUM_WORDS_PER_DV 	16
 #define MAX_DV_TBL_ENTRIES (NUM_DIST_VEC * NUM_WORDS_PER_DV)
@@ -385,6 +386,12 @@ enum NAE_REG_CMD {
         CMD_WRITE
 };
 
+enum if_link {
+       LINK_DOWN=0,
+       LINK_UP
+};
+
+
 enum if_speed {
         SPEED_10M = 0,
         SPEED_100M,
@@ -498,7 +505,7 @@ extern void reset_nae_mgmt(int node);
 extern int nlm_hal_nae_drain_frin_fifo_descs(int node, int inf);
 extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
 
-extern int nlm_hal_get_phy_status(int node, int inf, uint32_t *speed, uint32_t *duplex);
+extern int nlm_hal_get_phy_status(int node, int inf, struct nlm_hal_mii_info* mii_info);
 
 extern void nlm_hal_mac_disable(int node, int block, int intf_type);
 
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
new file mode 100644
index 0000000..ec2f7f3
--- /dev/null
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -0,0 +1,393 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef __NLM_NAE_H__
+#define __NLM_NAE_H__
+
+#ifndef __ASSEMBLY__
+#define MAX_NAE_CONTEXTS_PERNODE	524
+#define MAX_NAE_PORTS_PERNODE		18
+#define MAX_NAE_FREEIN_DESCS_QUEUE	18
+#define XLP_MAX_INTERLAKEN_IF		2
+
+#define MAX_UCORE_SRCS		16
+#define NLM_MAX_NODES           4
+#define MAX_NAE_PERNODE		2
+#define MAX_NAE_BLOCKS		2
+#define MAX_POE_BLOCKS		2
+#define MAX_NAE_CPLX_PER_NODE   8
+
+#define FREEBACK_TO_NAE		0x01
+#define VFBID_FROM_FDT		0x02
+#define FREEIN_SPILL_DYNAMIC	0x04
+#define POE_ENQSPILL_DYNAMIC	0x08
+#define POE_DEQSPILL_DYNAMIC	0x10
+#define NAE_RESET_DONE		0x20
+#define NAE_INIT_VALID		0x40
+
+#define NLM_NCPUS_PER_NODE	32
+#define NCPUS_PER_NODE		96
+#define XLP9XX_NCPUS_PER_NODE	64
+#define XLP_NCPUS_PER_NODE	NLM_NCPUS_PER_NODE
+
+#define NAEV1_SH_LCPU_TO_MAP_SZ                 24 /* in integers to map 96 cpus*/
+#define NAEV1_SH_LCPU_TO_MAP_SNG_VAL_SZ         8 /* in bits, can cover 6 cpus in single entry */
+#define NAEV1_SH_LCPU_TO_MAP_NVALS_PER_ENTRY    4 /* with 5 bits, can occupy 6  */
+
+#define NLM_NAE_SH_LCPU_TO_MAP_SZ		6 /* in integers */
+#define NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ  	5 /* in bits, can cover 6 cpus in single entry */
+#define NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY 	6 /* with 5 bits, can occupy 6  */
+
+struct nlm_nae_shinfo {
+	int valid;
+	int rxvc;
+	int domid;
+	/* logical cpu to physical cpu map */
+	unsigned int lcpu_2_pcpu_map[NLM_NAE_SH_LCPU_TO_MAP_SZ]; 
+	/* cpu to freein fifo map */
+	unsigned int cpu_2_freeinfifo_map[NLM_NAE_SH_LCPU_TO_MAP_SZ];
+};
+
+enum higig_mode{
+	NO_HIGIG,
+	HIGIG,
+	HIGIG2
+};
+
+enum flow_control {
+	PFC_LEVEL,
+	LINK_LEVEL,
+};
+
+
+#ifndef NLM_NUM_THREADS_PER_CORE
+#define NLM_NUM_THREADS_PER_CORE	4
+#endif
+
+/* Only 3 domains can share one nae node including the owner */
+#define NLM_NAE_MAX_SHARED_DOMS		2
+
+#define NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE 20
+/* XAUI Card only support XAUI mode */
+#define NLM_NAE_XAUI_MODE_XAUI      0
+
+/* RXAUI Card support 3 different modes */
+#define NLM_NAE_RXAUI_MODE_XAUI     1
+#define NLM_NAE_RXAUI_MODE_BROADCOM 2
+#define NLM_NAE_RXAUI_MODE_MARVELL  3
+
+struct nlm_hal_nae_config;
+
+typedef struct nlm_hal_nae_config nae_t;
+
+typedef enum{
+	FXD_V4DA_V4SA = 2,
+	FXD_V6DA_V6SA,
+	FXD_V4DA_V4SA_PROT_PORT0_PORT1,
+	FXD_V6DA_V6SA_PROT_PORT0_PORT1,
+	FXD_V4DA_V4SA_PROT_PORT0,
+	FXD_V6DA_V6SA_PROT_PORT0,
+}ucore_string_t;
+
+typedef enum{
+UCORE_DEST_ONLY=1,
+UCORE_ENQ_DIST_VEC,
+UCORE_ENQ_DEST,
+UCORE_DIST_VEC,
+UCORE_CPU_BYPASS,       
+UCORE_ENQ_DIST_VEC_SER,
+UCORE_ENQ_DEST_SER,
+}ucore_mode_t;
+
+typedef struct {
+        struct {
+                uint32_t num_entries;
+		uint32_t status;
+        }l2;   
+        struct {
+                uint32_t num_entries;
+                uint32_t status;
+        }l3;
+        struct {
+                uint32_t num_entries;
+                uint32_t status;
+        }l4;
+}nae_hw_parser_t;
+
+typedef enum{
+        L2_PROTO_ETHER = 1,
+        L2_PROTO_FIXEDHDR = 2,
+}l2_proto_t;
+
+typedef struct {
+        uint32_t l2_extract_len;  /* Layer 2 Extract length */
+        uint32_t l2_extract_off;  /* Layer 2 Extract offset */
+        uint32_t extra_hdr_size;  /* Extra header size before L2 header */
+        uint32_t l3_proto_offset; /* If L2 proto is 2, this tells where to pick L3 protocol */
+        uint32_t fixed_hdr_offset; /* If L2 proto is 2, this gives the size of the fixed header */
+                                   /* If L2 proto is 1, size of the constant prefix between L2 and L3 */
+        uint32_t l2_proto;        /* L2 Protocol, 0-No L2 extraction, 1-Ethernet, 2 - Fixed header length */
+}l2_parser_config_t;
+
+typedef struct {
+        // match configuration fields
+        uint32_t l2_proto_eth_mask; /* mask to include l2_proto, eth_type in l3 cam: valid value 0 or 1*/
+        uint32_t port_mask;         /* mask to include port_num in l3 cam : valid value 0 or 1*/
+        uint32_t port_num;          /* hardware interface number */
+
+        uint32_t l3_hdr_off;        /* L3 header offset */
+        uint32_t l4_proto_off;      /* L4 protocol offset, offset where the IP_PROTO field is
+                                       within the IP header */
+        uint32_t l4_extract_en;     /* Enable L4 extraction, udp/tcp/ip checksum compute: valid value 0 or 1*/
+
+        uint32_t l2_proto;          /* L2 proto to match */
+        uint32_t eth_type;          /* Ethernet type value to match */
+        // header extraction
+        uint32_t l3_hdr_off0;       /* offset and length in bytes for upto 3 areas of the L3 header */
+        uint32_t l3_hdr_len0;
+        uint32_t l3_hdr_off1;
+        uint32_t l3_hdr_len1;
+        uint32_t l3_hdr_off2;
+        uint32_t l3_hdr_len2;
+}l3_parser_config_t;
+
+typedef struct {
+        // match configuration fields
+        uint32_t ifnum_mask;       /* include interface number mask in l4 cam : valid value 0 or 1*/
+        uint32_t l3cam_addr_mask;  /* include L3 cam address mask in l4 cam : valid value 0 or 1*/
+        uint32_t l4_proto_mask;   /* include L4 proto field in L4 cam: valid value 0 or 1*/	
+        uint32_t ifnum;           /* interface number to match */
+        uint32_t l3cam_addr;      /* L3 cam address to match */
+        uint32_t l4_proto;        /* L4 proto to match */	
+
+        // header extraction
+        uint32_t l4_hdr_off0;     /* offset and length in bytes for upto 2 areas of the L4 header */
+        uint32_t l4_hdr_len0;
+        uint32_t l4_hdr_off1;
+        uint32_t l4_hdr_len1;
+}l4_parser_config_t;
+
+typedef struct {
+	uint64_t spill_base;
+	uint64_t spill_size;
+	uint32_t spill_num_descs;
+	uint32_t onchip_start;
+	uint32_t onchip_num_descs;
+	uint32_t guest_id;	
+}frin_lifo_config_t;
+
+struct poe_config {
+	uint32_t node;
+	uint32_t poe_id;
+	uint64_t pcie_base;
+	uint64_t pcim_base;
+
+	uint32_t *dist_vec;
+	uint32_t dist_en;
+
+	uint64_t poe_address_map;
+	uint32_t poe_address_len;
+	uint32_t dist_threshold[4];
+	uint32_t dist_drop_enable;
+	uint32_t dest_threshold;
+	uint32_t class_drop_enable;
+	uint32_t drop_timer;
+	uint32_t stats_en;
+	uint32_t poe_queue_base;
+        
+        uint64_t din_spill_base;
+        uint32_t din_spill_size;
+        uint32_t default_thr_sel; 
+	nae_t *nae;		
+};
+
+typedef struct poe_config poe_t;
+
+typedef struct {
+	uint32_t mask;
+	uint32_t num_opcodes;
+	uint32_t *opcodes;
+	uint32_t valid;
+}ucore_config_t;
+
+
+struct nlm_hal_nae_port {
+        int  valid;
+        int  mgmt;
+        int  num_free_desc;
+        int  txq;
+        int  rxq;
+        int  hw_port_id;
+        int  vlan_pri_en;
+        int  iftype;
+        int  num_channels;
+        uint32_t context_base;
+        uint32_t lport_id;
+	uint32_t  rx_buf_size;
+	uint32_t  intf_fifo_size;
+	uint32_t  free_desc_size;
+	uint32_t  prsr_seq_fifo_size;
+	uint32_t  rx_slots_reqd;
+	uint32_t  tx_slots_reqd;
+	uint32_t  ucore_mask;
+	uint32_t flow_control_type;
+	uint32_t param_index;
+        int  ext_phy_addr;
+        int  ext_phy_bus;
+	void *phy_dev;
+	uint32_t  rxaui_scrambler; /* 0: disable scrambler ; 1: enable scrambler */
+	uint32_t  rxaui_mode;      /* 0: broadcom mode; 1: marvell */
+        uint32_t  loopback;
+	uint32_t poe_queue_base;
+	nae_t *nae;
+};
+
+typedef struct nlm_hal_nae_port net_port_t;
+
+struct nlm_hal_nae_config {
+	uint64_t nae_base;
+	uint64_t mac_base;
+	uint64_t pcie_base;
+	uint32_t node;
+	uint32_t nae_id;
+	uint32_t frequency;
+        int fb_vc;
+        int rx_vc;
+        int frin_queue_base;
+        int frin_total_queue;
+        int num_ports;
+	uint32_t flags;
+	int rx_cal_slots;
+	int tx_cal_slots;
+	/* onchip descs per queue: value is taken from array for all 
+	   queues upto 0-17 */
+	int freein_fifo_onchip_num_descs[MAX_NAE_FREEIN_DESCS_QUEUE];
+	/* spill descs per queue, it will be added with the onchip size  */
+	int freein_fifo_spill_num_descs; 
+	uint64_t freein_spill_base;
+	uint64_t freein_spill_size;
+	struct nlm_hal_nae_port ports[MAX_NAE_PORTS_PERNODE];
+	ucore_config_t ucore_config[MAX_UCORE_SRCS];
+	uint32_t cntx2port[MAX_NAE_CONTEXTS_PERNODE];
+	uint32_t num_lanes[XLP_MAX_INTERLAKEN_IF];
+	uint32_t lane_rate[XLP_MAX_INTERLAKEN_IF];
+	//egress fifo 
+	uint32_t stg2fifo_base;
+	uint32_t ehfifo_base;
+	uint32_t froutfifo_base;
+	uint32_t msfifo_base;
+	uint32_t pktfifo_base;
+	uint32_t pktlenfifo_base;
+	// NAE complex map
+	uint32_t sgmii_complex_map;
+	uint32_t xaui_complex_map;
+	uint32_t higig_mode[MAX_NAE_CPLX_PER_NODE];
+	uint32_t xgmii_speed[MAX_NAE_CPLX_PER_NODE];
+	uint32_t rxaui_complex_map;
+	uint32_t ilk_complex_map;
+	// total queues used = num_contexts
+	uint32_t num_contexts;
+
+	/* I am the owner or not, who initialize the node */
+	int owned;
+	/* Freein fifo mask. Out of the max rx fifos, domain ownership
+	of rx-fifos. */
+	uint32_t freein_fifo_dom_mask;
+
+	/* vfbtable id offset, software freeback and hardware freebaack */
+	uint32_t vfbtbl_sw_offset;
+	uint32_t vfbtbl_sw_nentries;
+	uint32_t vfbtbl_hw_offset;
+	uint32_t vfbtbl_hw_nentries;
+
+        /* port fifo mode enabled/disabled */
+        unsigned int port_fifo_en;
+
+	unsigned long long dummy_pktdata_addr;
+	
+	struct nlm_nae_shinfo shinfo[NLM_NAE_MAX_SHARED_DOMS  + 1]; /* 1 extra for the owner */
+	uint32_t msec_port_enable;
+	unsigned char sectag_offset[MAX_NAE_PORTS_PERNODE];
+	unsigned char sectag_len[MAX_NAE_PORTS_PERNODE];
+	unsigned char icv_len[MAX_NAE_PORTS_PERNODE];
+	nae_hw_parser_t hwparser;
+       
+        uint32_t cpu_bypass_mode;  /* ucore cpu bypass mode enable */
+	uint32_t default_class;
+        /* ALE */
+        uint32_t ale_enable;
+        /* POE */
+	poe_t *poe;
+};
+
+typedef struct nlm_hal_nae_config * nlm_nae_config_ptr;
+
+extern struct nlm_node_config nlm_node_cfg;
+
+enum if_type {
+        UNKNOWN_IF    = 0,
+        SGMII_IF      = 1,
+        XAUI_IF       = 2,
+        INTERLAKEN_IF = 3,
+        RXAUI_IF      = 6,
+        /* Net version 1 
+        XLAUI_IF      = 4 , */
+};
+
+extern nae_t *xlp_nae[NLM_MAX_NODES][MAX_NAE_PERNODE];
+extern net_port_t **cntx2netport[NLM_MAX_NODES][MAX_NAE_PERNODE];
+
+#define GET_NAE(node,id)        xlp_nae[node][id]
+#define GET_NET_PORT(nae, port) &nae->ports[port]
+
+extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
+extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
+extern uint32_t *cntx2port[NLM_MAX_NODES];
+extern int nlm_hal_restart_ucore(int node, void *fdt);
+extern void nlm_hal_derive_cpu_to_freein_fifo_map(int node,
+                unsigned int phys_cpu_map,
+                unsigned int freein_fifo_mask, unsigned int *cpu_2_freein_fifo_map);
+extern void nlm_hal_modify_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
+		int off, int words);
+extern void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
+		int off, int words);
+
+extern void nlm_hal_disable_xaui_flow_control(int node, int block);
+
+typedef struct { uint32_t mask[24]; } cpu_mask_t;
+#endif
+#endif
diff --git a/arch/mips/netlogic/lib/netlib/src/ext_phy.c b/arch/mips/netlogic/lib/netlib/src/ext_phy.c
index 0e88970..2280a44 100644
--- a/arch/mips/netlogic/lib/netlib/src/ext_phy.c
+++ b/arch/mips/netlogic/lib/netlib/src/ext_phy.c
@@ -57,6 +57,9 @@ void __netsoc_init_ext_phy(net_port_t *netport)
 	int i, phyid; 
         ext_phy_t *phy_dev;
 
+        if (netport->iftype != SGMII_IF) {
+                return;
+        }
 
         /*BUS1*/
         if(is_nlm_xlp3xx() || is_nlm_xlp2xx()){ /*Only one mdio controller*/
@@ -94,6 +97,11 @@ void __netsoc_init_ext_phy(net_port_t *netport)
 int __netsoc_ext_phy_an(net_port_t *netport)
 {
 	ext_phy_t *phy_dev = (ext_phy_t *)netport->phy_dev;
+
+        if (netport->iftype != SGMII_IF) {
+                return -NETSOC_API_PARAM_INVALID;
+        }
+
 	if (phy_dev == NULL)
 		return -NETSOC_API_ERROR;
 
@@ -104,6 +112,10 @@ int __netsoc_ext_phy_an(net_port_t *netport)
 int __netsoc_get_phy_status(net_port_t *netport, uint32_t *speed, uint32_t *duplex)
 {
 	ext_phy_t *phy_dev = (ext_phy_t *)netport->phy_dev;
+	if (netport->iftype != SGMII_IF) {
+		return -NETSOC_API_PARAM_INVALID;
+	}
+
         if (phy_dev == NULL)
                 return -NETSOC_API_ERROR;
         return phy_dev->get_status(netport, speed, duplex);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index d04d864..91124bb 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -44,9 +44,9 @@ uint32_t (*netsoc_lib_readl)(uint64_t base, uint32_t index);
 void (*netsoc_lib_writel)(uint64_t base, uint32_t index, uint32_t val);
 void *(*netsoc_lib_contig_malloc)(uint32_t align, uint32_t size);
 void (*netsoc_lib_contig_free)(void *buf);
-unsigned long long (*netsoc_lib_virttophys)(void *);
-void *(*netsoc_lib_phystovirt)(unsigned long long);
-unsigned int netsoc_api_dbglvl = 1;
+uint64_t (*netsoc_lib_virttophys)(void *);
+void *(*netsoc_lib_phystovirt)(uint64_t);
+unsigned int netsoc_api_dbglvl = NETSOC_APIDBG_DEFAULT | NETSOC_APIDBG_GLOBAL;
 
 int (*const_func_list[])(void) = {
 register_marvell_phy,
@@ -240,6 +240,24 @@ int netsoc_set_framesize(net_port_t *netport, uint32_t size)
 }
 
 /**
+* @brief netsoc_set_framesize function is used to get the MAC frame size
+* 
+* @param [in] netport - pointer to net_port_t
+*
+* @return
+*       - frame size on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*  
+*/
+
+int netsoc_get_frame_size(net_port_t *netport)
+{
+	return __netsoc_get_frame_size(netport);
+}
+
+/**
 * @brief netsoc_init_burst_max function is used to configure the maximum burst length
 * 
 * @param [in] netport - pointer to net_port_t
@@ -258,6 +276,24 @@ int netsoc_init_burst_max(net_port_t *netport, uint32_t maxsize)
         return __netsoc_config_burstmax(netport, maxsize);
 }
 
+/**
+* @brief netsoc_get_burst_max function is used to get the maximum burst length
+* 
+* @param [in] netport - pointer to net_port_t
+*
+* @return
+*       - burst max length on success
+*       - < 0 on error
+*   
+* @ingroup hal_nae
+*   
+*/  
+
+int netsoc_get_burst_max(net_port_t *netport)
+{
+	return __netsoc_get_burstmax(netport);
+}
+
 
 /**
 * @brief netsoc_open_port function is used to open a port and enable mac
@@ -612,6 +648,83 @@ int netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 	return NETSOC_API_SUCCESS;
 }
 
+/**
+* @brief netsoc_map_context_toclass function is used to map context to a class
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] context Context number
+* @param [in] class Class number to be used for the context  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_map_context_toclass(nae_t *nae, uint32_t context, uint32_t class)
+{
+       	return __netsoc_map_context_toclass(nae, context, class);
+}
+
+/**
+* @brief netsoc_schedule_context_onport function is used to map context to a hardware port
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] context Context number
+* @param [in] hwport hardware port number to be used for the context  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_schedule_context_onport(nae_t *nae, uint32_t context, uint32_t hwport)
+{
+	return __netsoc_schedule_context_onport(nae, context, hwport);
+}
+
+/**
+* @brief netsoc_config_drr_context function is used to configure the context as DRR context
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] context Context number
+* @param [in] drr_quantum DRR quantum to be used for the context  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_config_drr_context(nae_t *nae, uint32_t context, uint64_t drr_quantum)
+{
+	return __netsoc_config_drr_context(nae, context, drr_quantum);
+}
+
+
+/**
+* @brief netsoc_config_pri_context function is used to configure the context as strict priority context
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] context Context number
+* @param [in] priority Priority number to be assigned for the context  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_config_pri_context(nae_t *nae, uint32_t context, uint32_t priority)
+{
+        return __netsoc_config_pri_context(nae, context, priority);
+}
+
 
 /**
 * @brief netsoc_rx_control function is used to enable or disable NAE RX
@@ -691,6 +804,27 @@ int netsoc_disable_wred_perclass(nae_t *nae, uint32_t class_num)
         return __netsoc_config_wred_perclass(nae, class_num, 0, 0, 0);
 }
 
+/**
+* @brief netsoc_drop_runt_pkts function is used to enable/disable dropping packets
+*        of size 64 bytes or less with CRC error, before it gets written into the RxBuffer
+*
+* @param [in] nae Pointer to nae_t
+* @param [in] enable 1 - enable 0 - disable 
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+
+int netsoc_drop_runt_pkts(nae_t *nae, uint32_t enable)
+{
+	__netsoc_drop_runt_pkts(nae, enable);
+	return NETSOC_API_SUCCESS;
+}
+
 // VBID TABLE
 /**
 * @brief netsoc_config_vfbid_table function is used to initialize VFBID table
@@ -869,6 +1003,28 @@ int netsoc_configure_frinq_spill(nae_t *nae, uint32_t frin_qnum, frin_lifo_confi
 	return __netsoc_config_per_freein(nae, frin_qnum, frin_config);
 }
 
+/**
+* @brief netsoc_configure_frindesc_size function is used to configure FRIN descriptor size per frin lifo
+* 	The configuration is in effect only when bit 31(frin desc unique size) in rx_config register is one.
+*
+* @param [in] nae Pointer to nae_t
+* @param [in] frin_qnum FRIN queue number  
+* @param [in] size Free in descriptor size 
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+
+int netsoc_configure_frindesc_size(nae_t *nae, uint32_t frin_qnum, uint32_t size)
+{
+	__netsoc_write_fifo_size(nae, frin_qnum, size);
+	return NETSOC_API_SUCCESS;
+}
+
 //parser
 
 /**
@@ -929,6 +1085,26 @@ int netsoc_config_nae_l2parser(nae_t *nae, l2_parser_config_t *l2)
 }
 
 /**
+* @brief netsoc_config_nae_l2parser function is used to configure layer 2 parsing
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] l2 Pointer to l2_parser_config_t  
+* @param [in] portnum Hardware port number
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+
+int netsoc_config_nae_l2parser_perport(nae_t *nae, l2_parser_config_t *l2, uint32_t portnum)
+{
+        return __netsoc_config_nae_l2parser_perport(nae, l2, portnum);
+}
+
+/**
 * @brief netsoc_config_nae_l3parser function is used to configure layer 3 parsing
 * 
 * @param [in] nae Pointer to nae_t
@@ -1034,7 +1210,7 @@ uint32_t netsoc_crc16(nae_t *nae, uint8_t *buf, uint32_t *crc32_tbl)
 * @param [in] nae Pointer to nae_t
 * @param [in] index FRIN queue number to index flow base table  
 * @param [in] context Context number 
-* @param [in] crc16 16 bit crc returned from netsoc_crc16 
+* @param [in] crc 16 bit crc returned from netsoc_crc16 
 *
 * @return
 *       - flow id
@@ -1043,7 +1219,7 @@ uint32_t netsoc_crc16(nae_t *nae, uint8_t *buf, uint32_t *crc32_tbl)
 *
 */
 
-uint32_t netsoc_get_flowid(nae_t *nae, uint32_t index, uint32_t context, uint32_t crc16)
+uint32_t netsoc_get_flowid(nae_t *nae, uint32_t index, uint32_t context, uint32_t crc)
 {
 	uint32_t class_base, class_mask, flow_base, flow_mask;
 	uint32_t flowid, classid;
@@ -1052,7 +1228,7 @@ uint32_t netsoc_get_flowid(nae_t *nae, uint32_t index, uint32_t context, uint32_
 	__netsoc_get_class_base(nae, classid, &class_base, &class_mask);
 	__netsoc_get_flow_base(nae, index, &flow_base, &flow_mask);
 
-	flowid = flow_base + ((crc16 & 0xFFFF) & (0xFFFF >> flow_mask) & (0xFFFF >> class_mask)) + class_base;
+	flowid = flow_base + ((crc & 0xFFFF) & (0xFFFF >> flow_mask) & (0xFFFF >> class_mask)) + class_base;
 	return flowid;
 }
 //POE 
@@ -1234,6 +1410,25 @@ int netsoc_configure_poeclass_spill(poe_t *poe, uint32_t class_num, uint64_t spi
         return NETSOC_API_SUCCESS;  
 }
 
+/**
+* @brief netsoc_poe_map_cpuclass function is used to map class for cpu enqueue mode operation. Classes
+*        that are mapped to CPU can not be be used by NAE
+* 
+* @param [in] poe Pointer to poe
+* @param [in] mode class numbers of type class_map_t  
+*
+* @return
+*       - NETSOC_API_SUCCESS on success
+*       - < 0 on error
+* 
+* @ingroup hal_nae
+*
+*/
+int netsoc_poe_map_cpuclass(poe_t *poe, class_map_t mode)
+{
+	return __netsoc_poe_config_class_map(poe, mode);
+}
+
 /* ALE specific configuration in NAE */
 /**
 * @brief netsoc_config_string_offset function is used to configure the offset to destination
@@ -1241,6 +1436,7 @@ int netsoc_configure_poeclass_spill(poe_t *poe, uint32_t class_num, uint64_t spi
 * 
 * @param [in] nae Pointer to nae
 * @param [in] offset Offset to destination IP address
+* @param [in] string_type String type from ucore
 *
 * @return
 *       - NETSOC_API_SUCCESS on success
@@ -1249,9 +1445,9 @@ int netsoc_configure_poeclass_spill(poe_t *poe, uint32_t class_num, uint64_t spi
 * @ingroup hal_nae
 *
 */
-int netsoc_config_string_offset(nae_t *nae, uint32_t offset)
+int netsoc_config_string_offset(nae_t *nae, uint32_t offset, ucore_string_t string_type)
 {
-	return __netsoc_config_string_dest_offset(nae, offset);
+	return __netsoc_config_string_dest_offset(nae, offset, string_type);
 }
 
 /**
@@ -1446,18 +1642,19 @@ int init_netsoc(void *fdt, uint32_t dom_id)
 	if (!hallib_init_done) {
 		brcm_netsoc_lib_init(NULL);
 	}
-	if (fdt == NULL)
+	if (fdt == NULL) 
 		return -NETSOC_API_PARAM_INVALID;
 
         if (fdt_check_header(fdt)) {
                 netsoc_api_print(NETSOC_APIDBG_ERROR, "Sanity check on FDT blob failed! Aborting\n");
                 return -NETSOC_FDT_ERROR;
         }
-
+	
 	netsoc_api_print(NETSOC_APIDBG_TRACE, "calling __netsoc_parse_and_init\n");
 	return __netsoc_parse_and_init(fdt, dom_id);
 }
 
+
 /**
 * @brief brcm_netsoc_lib_init function is used to initialize netsoc library
 * 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index e7cf749..20efc3a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -256,10 +256,10 @@ void update_netsoc_info(void)
 
 	for(node=0; node < 4; node++){
 	     for(id = 0; id < get_num_nae_pernode(); id++) {
-		   cntx2netport[node][id] = netsoc_api_malloc(MAX_NAE_CONTEXTS_PERNODE * 8, 0);
+		   cntx2netport[node][id] = netsoc_api_malloc(MAX_NAE_CONTEXTS_PERNODE * 8);
                    if (cntx2netport[node][id] == NULL) {
                       	netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: Memory allocation failed\n",__func__);
-                        return -1;
+                        return ;
                    }
                    memset((char *)cntx2netport[node][id], 0, (MAX_NAE_CONTEXTS_PERNODE * 8));
 	     }
@@ -293,7 +293,7 @@ static void dump_nae_config(nae_t *nae)
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_xgmac 4 0x%llx \n",(unsigned long long)netsoc_get_macreg_base_for_xgmac(nae->mac_base, 4));
 	
 	for(i=0; i < 8;i++){
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_gmac %d 0x%llx \n", i, netsoc_get_macreg_base_for_gmac(nae->mac_base, i));
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "netsoc_get_macreg_base_for_gmac %d 0x%llx \n", i, (unsigned long long)netsoc_get_macreg_base_for_gmac(nae->mac_base, i));
 	}
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, " ******************** \n");
 }
@@ -306,6 +306,25 @@ static void dump_poe_config(poe_t *poe)
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, " ******************** \n");
 }
 
+static void dump_context_config(void)
+{
+	int node, id, context;
+	net_port_t **netport;
+
+	for(node=0; node<4; node++) {
+		for(id=0;id<2;id++) {
+			netport = cntx2netport[node][id];
+			if (netport == NULL) {
+				netsoc_api_print(NETSOC_APIDBG_CONFIG,"context list null for node %d nae %d\n",node, id);
+				continue;
+			}
+			for(context = 0;context < current_netsoc->max_contexts; context++) {
+				if (netport[context] != NULL)
+					netsoc_api_print(NETSOC_APIDBG_CONFIG,"context %d assigned to hwport %d	\n",context, netport[context]->hw_port_id);
+			}
+		}
+	}
+}
 
 static int get_max_nodes(void)
 {
@@ -350,6 +369,10 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 #ifdef NLM_HAL_LINUX_KERNEL
         uint32_t port_num, txq;
 #endif
+#ifndef CONTEXT_NUMBER_INSEQ
+	uint32_t txq_base;
+#endif
+
         if (is_nlm_xlp9xx()) {
                 if (nae->nae_id == 0)
                         poe_queue_base = (nae->node <<10) | XLP_9XX_POE0_VC_BASE;
@@ -364,6 +387,19 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 
         max_ports = nae->num_ports;
 
+#ifndef CONTEXT_NUMBER_INSEQ
+	txq_base = nae->ports[0].txq;
+        for(i = 0 ; i < max_ports; i++) {
+                nae->ports[i].txq = txq_base;
+                if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                        txq_base  += nae->ports[i].num_channels;
+                else
+                        txq_base += 8;
+		printf("port %d txq_base %d \n",i, nae->ports[i].txq);
+        }
+#endif  
+
+
         for (i = 0, context = 0; i < max_ports; i++) {
                 net_port_t *port = &nae->ports[i];
 		port->nae = nae;
@@ -419,7 +455,15 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
 #ifdef NLM_HAL_LINUX_KERNEL
                }
 #endif
+
+#ifdef CONTEXT_NUMBER_INSEQ
                context += ctxsize;
+#else
+                if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                        context += ctxsize;
+                else
+                        context += 8;
+#endif
 
         }
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, "updated context mapping %d:%d num ports %d\n",nae->node,nae->nae_id, nae->num_ports);
@@ -442,7 +486,7 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
                 /* MAX_NAE_PORTS_PERNODE = 18 is an invalid port */
                 nae->cntx2port[i] = MAX_NAE_PORTS_PERNODE;
         }
-
+	nae->default_class = 0;
 	__netsoc_set_frin_queue_base(nae);
 	__netsoc_set_frin_total_queue(nae);
 	
@@ -526,6 +570,10 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 #ifdef XLP_SIM
         static uint64_t base = 0xd0400000;
 #endif
+	
+	if (fdt == NULL) {
+		return -NETSOC_FDT_ERROR;
+	}
 
 	netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s\n",__func__);
         max_nae = __netsoc_get_max_nae();
@@ -537,7 +585,7 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 	for(node = 0; node < max_nodes; node++) {
 		// Parset nae configuration from fdt
 		for(id = 0;id < max_nae; id++) {
-			nae = netsoc_api_malloc(sizeof(nae_t), 0);
+			nae = netsoc_api_malloc(sizeof(nae_t));
 			if (nae == NULL) {
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: Memory allocation failed\n",__func__);
 				return -1;
@@ -554,7 +602,6 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: parse nae fdt failed\n",__func__);
 				return -1;		
 			}
-
 			// update context mapping based on the port configuration
 			__netsoc_update_context_mapping(nae, cntx2netport[node][id]);
 			
@@ -581,7 +628,7 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 	
 		// Parset poe configuration from fdt
 		for(id = 0; id < max_poe; id++) {
-			poe = netsoc_api_malloc(sizeof(poe_t), 0);
+			poe = netsoc_api_malloc(sizeof(poe_t));
 			if (poe == NULL) {
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: Memory allocation failed\n",__func__);
 				return -1; 
@@ -590,12 +637,14 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 			poe->node = node;
                         poe->poe_id = id;
 			__netsoc_update_poe_defaultconfig(poe);
+
 			// fdt_parse_netsoc_nae_config fills 'poe' structure with the configuration information to intialize POE
 			retval = fdt_parse_netsoc_poe_config(fdt, poe);
 			if (retval) {
 				netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: parse poe fdt failed\n",__func__);
 				return -1;
 			}
+	
 			if (id == 0)
 				poe->pcie_base = nlm_hal_get_dev_base(node, bus, XLP_POE_DEVICE, XLP_POE_FUNC);
 			else
@@ -617,8 +666,8 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 		}
 	}
 
+	dump_context_config();
 	// Initialize all networking soc blocks
 	return __netsoc_init();
 }
 
-
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index b7fd812..a38f668 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -56,20 +56,6 @@
 
 #define MAX_PROP_LEN 30
 
-static inline int get_num_ports(int block, int intf_type)
-{
-        if (intf_type == SGMII_IF) {
-		if ((is_nlm_xlp9xx()) && block == 2)
-			return 1;
-
-                if (block < 4)
-                        return 4;
-                else
-                        return 2;
-        }
-        else
-                return 1;
-}
 
 static void fdt_derive_cpu_to_freein_fifo_map(nae_t *nae,
                 unsigned int phys_cpu_map,
@@ -149,12 +135,17 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
         char port_type_str[MAX_PROP_LEN];
 
 	netsoc_api_print(NETSOC_APIDBG_FDT,"get_interface_type node %d block %d port %d\n",node, block, port);
+#ifndef XLP_SIM
         if (GET_PORT_STR_PROP("cpld", port_type_str, MAX_PROP_LEN) < 0) {
-                        netsoc_api_print(NETSOC_APIDBG_FDT,"FDT missing cpld param for complex. port detection could be supported %d\n", block);
+		intf_type = DC_NOT_PRSNT;
         } 
 	else {
-                intf_type = nlm_get_interface_type(node, block);
+		if (!strcmp(port_type_str,"yes"))
+               	 	intf_type = nlm_get_interface_type(node, block);
+		else
+			intf_type = DC_NOT_PRSNT;
 	}
+#endif
 
 #ifdef CONFIG_N511
         if (block == 4) {
@@ -269,7 +260,7 @@ static void get_dom_nae_property(void *fdt, int dom_id, int nae_id, char *ppty,
         }
 }
 
-void fdt_extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, nae_t *nae_cfg)		//FIXME J - different for griffin 
+void fdt_extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, nae_t *nae_cfg)		
 {
         char dom_node_str[128];
         int i;
@@ -518,7 +509,7 @@ err:
 }
 
 
-int prepare_nae_shared_info(void *fdt, int dom_id, nae_t *nae_cfg)	//FIXME J - different for griffin
+int prepare_nae_shared_info(void *fdt, int dom_id, nae_t *nae_cfg)
 {
         char dom_node_str[128];
         int nodeoffset;
@@ -759,7 +750,7 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
 			ucore->opcodes = NULL;
 			continue;
 		}
-                ucore->opcodes = netsoc_api_malloc(size, 0);
+                ucore->opcodes = netsoc_api_malloc(size);
                 if (!ucore->opcodes) {
                         netsoc_api_print(NETSOC_APIDBG_ERROR,"[%s] Unable to allocate temporary memory\n", __func__);
                         return NETSOC_API_MALLOC_FAILED;
@@ -854,19 +845,6 @@ int fdt_parse_vfbid_config(void *fdt, nae_t *nae_cfg)
         return 0;
 }
 
-static void update_default_config(int intf_type, uint32_t *config, uint32_t val)
-{
-	uint32_t iface;
-	if (intf_type == SGMII_IF) {
-		for(iface = 0; iface < 4; iface++) {
-			*config++ = val;
-		}
-	}
-	else {
-		*config = val;
-	}
-}
-
 static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str, struct nae_complex_config *cmplx)
 {
         int i = 0;
@@ -976,8 +954,9 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                 txq = (node <<10) | XLP_NET_TX_VC_BASE;
         }
 	
+
         for(block=0, port = 0; block < max_complex; block++) {
-#ifndef NLM_HAL_UBOOT
+#ifndef XLP_SIM
                 if (is_nlm_xlp8xx_ax() && is_xlp_evp1() && (block % 2))
                         continue;
 #else
@@ -1192,7 +1171,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
 
         size = sizeof(uint32_t) * MAX_DV_TBL_ENTRIES;
 
-        poe->dist_vec = netsoc_api_malloc(size, 0);
+        poe->dist_vec = netsoc_api_malloc(size);
         if (poe->dist_vec == NULL) {
                 netsoc_api_print(NETSOC_APIDBG_ERROR,"nlm_alloc failed");
                 return NETSOC_API_MALLOC_FAILED;
@@ -1370,13 +1349,20 @@ int fdt_get_nae_ale_config(void *fdt, nae_t *nae)
  
 int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 {
+
         if (is_nlm_xlp9xx()) {
              fdt_get_nae_frequency(fdt, nae);
         }
         else {
-	     nae->frequency = nlm_hal_get_fdt_freq(fdt, NLM_NAE);	
-        }
-          
+             nae->frequency = nlm_hal_get_fdt_freq(fdt, NLM_NAE);
+        } 
+
+	if (dom_id < 0) {
+		nae->owned = 0;
+		fdt_parse_port_config(fdt, nae);
+		return 0;
+	}
+
         if (current_netsoc->hw_features & NETSOC_ALE)
             fdt_get_nae_ale_config(fdt, nae);
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
index bbc7d5e..874371e 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
@@ -30,7 +30,7 @@
 #include "lib_hdrs.h"
 #include "netsoc_msg.h"
 #include "nlm_nae.h"
-#include "nlm_hal_fmn.h"
+#include "nlm_hal_fmn_dp.h"
 
 
 int (*enq_pkt_recv)(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info, poe_enq_info_t *rcvd_enq_info);
@@ -374,7 +374,7 @@ int netsoc_v0_noenq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_r
                          src_id, size, code, msg0, msg1);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -384,7 +384,7 @@ int netsoc_v0_noenq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_r
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = rx_addr(msg1);
 			*len = rx_len(msg1);
 			nae_decode_rxpktinfo(msg1, &pkt_info->nae.rx);
@@ -445,7 +445,7 @@ int netsoc_v0_enq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_rec
                          src_id, size, code, msg0, msg1);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -455,7 +455,7 @@ int netsoc_v0_enq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_rec
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = rx_addr(msg1);
 			*len = rx_len(msg1);
 			nae_decode_rxpktinfo(msg1, &pkt_info->nae.rx);
@@ -515,7 +515,7 @@ int netsoc_v0_nae_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_in
                          src_id, size, code, msg0, msg1);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -525,7 +525,7 @@ int netsoc_v0_nae_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_in
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = rx_addr(msg1);
 			*len = rx_len(msg1);
 			nae_decode_rxpktinfo(msg1, &pkt_info->nae.rx);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 27ac6f9..6127a5e 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -517,6 +517,9 @@ int __netsoc_reset_and_load_ucore(nae_t *nae, uint32_t ucore_mask, unsigned int
 		ucore_cfg = netsoc_read_nae_reg(nae->nae_base, RX_UCORE_CFG);
 		ucore_cfg &= (~VAL_UCORE_RESET(ucore_mask));
                 ucore_cfg |= (1<<7);
+		if (!is_nlm_xlp8xx_ax())
+			ucore_cfg |= (1<<28);
+
                 if (nae->cpu_bypass_mode) {
                        netsoc_write_nae_reg(nae->nae_base, RX_UCORE_CFG, ucore_cfg | (1 << 24) | (1<<28));
                 }
@@ -936,8 +939,13 @@ void __netsoc_config_egress(net_port_t *netport, int context_base)
 				data = (netport->hw_port_id << 15) |
 					 (offset << 20) | ((context_base + offset) << 5) ;
 				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, data | 1 );
-				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0, data);
-				netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched %x \n",netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_CMD0)); 
+				//Read the sched status
+				do {
+                                        netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , ((context_base + offset)<<5));
+                                        data = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+                                }while(!(data & 0x1));
+                                netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 1);
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched scheduling context %d on port %d \n",(context_base + offset), ((data>>5) & 0x1f));
 			}
 			break;
 		default:
@@ -946,8 +954,13 @@ void __netsoc_config_egress(net_port_t *netport, int context_base)
 				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD1, DRR_QUANTA);
 				data =  (netport->hw_port_id << 15) | ((context_base + offset) << 5) ;
 				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , data | 1 );
-				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , data);
-			       netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched %x \n",netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_CMD0));
+				//Read the sched status 
+				do {
+					netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_CMD0 , ((context_base + offset)<<5));
+					data = netsoc_read_nae_reg(nae_base, TX_SCHED_MAP_STATUS0);
+				}while(!(data & 0x1));
+				netsoc_write_nae_reg(nae_base, TX_SCHED_MAP_STATUS0, 1);
+				netsoc_api_print(NETSOC_APIDBG_CONFIG, "txsched scheduling context %d on port %d \n",(context_base + offset), ((data>>5) & 0x1f));
                         }
 			break;
 	}
@@ -996,7 +1009,7 @@ void __netsoc_config_rx_calendar(nae_t *nae)
 	max_ports = __netsoc_get_max_ports();
         cal_len = nae->rx_cal_slots - 1;
 
-        netsoc_api_print(NETSOC_APIDBG_CONFIG, "Rx calendar length %d \n", cal_len);
+        netsoc_api_print(NETSOC_APIDBG_CONFIG, "Rx calendar length %d \n", nae->rx_cal_slots);
         do {
                 if (cal >= MAX_CAL_SLOTS)
                         break;
@@ -1005,7 +1018,14 @@ void __netsoc_config_rx_calendar(nae_t *nae)
                         if (nae->ports[port].rx_slots_reqd) {
                                 val = (cal_len << 16) | (nae->ports[port].hw_port_id << 8) | cal;
                                 netsoc_write_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL, val);
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Rx cal: hwport %d cal %d rx val 0x%x\n",nae->ports[port].hw_port_id, cal,  val);
+
+				//Read RX calendar slots
+				val = (1<<31) | (cal_len << 16) | cal;
+				netsoc_write_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL, val);	
+				val = netsoc_read_nae_reg(nae->nae_base, RX_IFACE_SLOT_CAL);
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Rx total-cal %d slot %d assigned to hwport %d \n",
+						(((val>>16) & 0x3f) + 1), cal, ((val>>8) & 0x1f));
+
                                 cal++;
                                 nae->ports[port].rx_slots_reqd--;
                         }
@@ -1032,7 +1052,15 @@ void __netsoc_config_tx_calendar(nae_t *nae)
                         if (nae->ports[port].tx_slots_reqd) {
                                 val = (nae->ports[port].hw_port_id << 7) | (cal << 1) | 1;
                                 netsoc_write_nae_reg(nae->nae_base, EGR_NIOR_CRDT_CAL_PROG, val);     // map it to interface
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "TX cal: hwport %d cal %d tx val 0x%x\n",nae->ports[port].hw_port_id, cal,  val);
+
+				//Read TX calendar slots
+				netsoc_write_nae_reg(nae->nae_base, EGR_NIOR_CRDT_CAL_PROG, (cal << 1));
+				do {
+					val = netsoc_read_nae_reg(nae->nae_base, EGR_NIOR_CAL_STATUS);
+				}while(!(val&0x1));
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "TX cal: cal %d assigned to hwport %d\n",
+						cal, ((val >> 1) & 0x1f));
+
                                 cal++;
                                 nae->ports[port].tx_slots_reqd--;
                         }
@@ -1077,22 +1105,20 @@ void __netsoc_config_poe_class(nae_t *nae)
 {
         int i;
         uint32_t val;
+	int max_poe_tbl_sz;
         int poe_cl_tbl[MAX_POE_CLASSES] = {0x0, 0x249249, 0x492492,
                                            0x6db6db, 0x924924, 0xb6db6d,
                                            0xdb6db6, 0xffffff};
-        int max_poe_tbl_sz;
+	
+	max_poe_tbl_sz = current_netsoc->max_contexts / MAX_POE_CLASSES;
 
-	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
-        	max_poe_tbl_sz = XLP3XX_MAX_POE_CLASS_CTXT_TBL_SZ;
-        }
-        else {
-		max_poe_tbl_sz = MAX_POE_CLASS_CTXT_TBL_SZ;
-	}
+	if (current_netsoc->max_contexts % MAX_POE_CLASSES)
+		max_poe_tbl_sz++;
 
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "max_poe_tbl_sz %d\n",max_poe_tbl_sz);
         for (i = 0; i <max_poe_tbl_sz; ++i) {
                 val = (0x00 | i); /* clear the read bit 0x80 */
-                val |= (poe_cl_tbl[(i/MAX_POE_CLASSES) & 0x7] << 8);
+                val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
 
                 netsoc_api_print(NETSOC_APIDBG_CONFIG, "POE index %d val %x \n",i, val);
                 netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val);
@@ -1163,17 +1189,22 @@ void __netsoc_config_rxbuffer(nae_t *nae, int context_base, int num_channels, ui
 
 	for(offset = 0; offset < num_channels; offset++) {
 		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_ADDR_REG, (context_base + offset) | (thrgrp << 10));
-                netsoc_api_print(NETSOC_APIDBG_CONFIG, "context %d base %x size %d \n",context_base + offset, base, size);
-         	netsoc_api_print(NETSOC_APIDBG_CONFIG, "reg %x 0x%x\n",RX_BUFFER_BASE_DEPTH_ADDR_REG, context_base + offset);       
-
-                netsoc_api_print(NETSOC_APIDBG_CONFIG, "rxbuffer context %d base %d size %d thrgrp %d\n",
+                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Configuring rxbuffer context %d base %d size %d thrgrp %d\n",
 				context_base + offset, base, size, thrgrp);
 		val = 0x80000000 | ((base << 2) & 0x3fff); /* base */
                 val |= (((size << 2)  & 0x3fff) << 16); /* size */
                 netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, val);
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "reg %x 0x%x\n",RX_BUFFER_BASE_DEPTH_REG, val);
-                netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, 0x7fffffff & val);
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "reg %x 0x%x\n",RX_BUFFER_BASE_DEPTH_REG, 0x7fffffff & val);
+
+		// Read back 
+		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, 0);
+		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_ADDR_REG, (context_base + offset));
+		netsoc_write_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG, 0);
+		val = netsoc_read_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_ADDR_REG);
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "RX_BUFFER_BASE_DEPTH_ADDR_REG %x thrgrp %d\n",val , ((val >> 10) & 0x7));
+		val = netsoc_read_nae_reg(nae_base, RX_BUFFER_BASE_DEPTH_REG);
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "RX_BUFFER_BASE_DEPTH_REG %x base %d depth %d\n",
+				val, (val & 0x1fff), ((val >> 16) & 0x3fff));
+
 		base += size;
 	}
 }
@@ -1185,7 +1216,6 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 
 	val = ((size & 0x1fff) << 17) | ((start & 0xfff) << 5) | (hw_port_id & 0x1f);
         netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
-	netsoc_api_print(NETSOC_APIDBG_CONFIG, "reg %x 0x%x\n",PARSER_SEQ_FIFO_CFG, val);
 
 	/*
 	   FIFO xoff threshold: high. When #entries used rises to this specified number.
@@ -1197,9 +1227,17 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 		xon = size/4;
 		val = (xoff<<12) | (xon);
 		netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG, val);
-
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "reg %x 0x%x\n",PARSER_SEQ_FIFOTH_CFG, val);
 	}
+
+	// MD is zero, 1024 entries
+	val = (1<<31) | (hw_port_id & 0x1f);
+	netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
+	val = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG);
+	netsoc_api_print(NETSOC_APIDBG_CONFIG,"PARSER_SEQ_FIFO_CFG port %d fcsz %d fcstart %d\n", hw_port_id,
+			 ((val >> 17) & 0x1FFF), ((val >> 5) & 0xFFF));
+	val = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG);
+	netsoc_api_print(NETSOC_APIDBG_CONFIG,"PARSER_SEQ_FIFOTH_CFG xoff %d xon %d \n",
+			((val >> 12) & 0xfff), (val & 0xfff));
 }
 
 void __netsoc_config_ingress_fifo(nae_t *nae)
@@ -1207,7 +1245,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
         int fifo_xoff_thresh;
         int port, lane = 0, hw_port = 0, max_lanes, offset = 0;
 	int cur_iface_start = 0, max_ports;
-	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
+	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0, tempctx_base;
 	int thrgrp = 0, rx_buf_size;
 
 	max_ports = __netsoc_get_max_ports();
@@ -1262,7 +1300,6 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
                                         rx_buf_base, nae->ports[port].rx_buf_size, thrgrp);  
                 rx_buf_base += nae->ports[port].rx_buf_size;
 
-
 		for (lane = 0 ; lane < max_lanes; lane++) {
 			// carving interface fifo
 			netsoc_api_print(NETSOC_APIDBG_CONFIG, "carving intf fifo: lane:%d n:%d hw_port:%d\n", lane, nae->node, hw_port);
@@ -1274,8 +1311,16 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			// carving Rx base
 			netsoc_api_print(NETSOC_APIDBG_CONFIG, "carving rx buffer: lane:%d\n", lane);
 			__netsoc_write_rxbase(nae, nae->ports[port].hw_port_id + lane, context_base);
-			if (lane == 0)
-                        	context_base += nae->ports[port].num_channels;
+			if (lane == 0) {
+#ifdef CONTEXT_NUMBER_INSEQ
+                		context_base += nae->ports[port].num_channels;
+#else
+                		if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+                        		context_base += nae->ports[port].num_channels;
+                		else
+                        		context_base += 8;
+#endif
+			}
 			
 			size = ((lane == 0) ? nae->ports[port].prsr_seq_fifo_size : 0);
 			__netsoc_config_parserfifo(nae, nae->ports[port].hw_port_id + lane, cur_parser_base, size);
@@ -2121,10 +2166,12 @@ static int __netsoc_init_netior(nae_t *nae)
 */
 void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 {
-        unsigned int rx_cfg = 0;
-        unsigned int parser_threshold = 384;
+        unsigned int rx_cfg = 0, i, val;
+        unsigned int parser_threshold = DEFAULT_PARSER_THR;
 	uint64_t nae_base = nae->nae_base;
-
+	unsigned int frin_descsz = 0, divdescsz, moddescsz;
+	
+	
         if (!desc_size)
 #ifdef CONFIG_64BIT
                 desc_size = 5504; /* to support 16384(mtu)/(max 3 P2Ds) and cacheline aligned */
@@ -2134,7 +2181,9 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 
         rx_cfg = netsoc_read_nae_reg(nae_base, RX_CONFIG);
 
-        netsoc_api_print(NETSOC_APIDBG_GLOBAL, "%s desc_size %d\n",__func__, desc_size);
+	if ((rx_cfg & (1 << 31)) == 0) {
+
+	        netsoc_api_print(NETSOC_APIDBG_GLOBAL, "%s desc_size %d\n",__func__, desc_size);
 #define NAE_MAX_MESSAGE_SIZE(x)                 (((x) & 0x3)<<1)
 #define RESET_MAX_MESSAGE_SIZE                   ~(0x3<<1)
 #define NAE_FRINDESCCLSIZE(x)                   (((x)  & 0xff)<< 4 )
@@ -2142,7 +2191,7 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
 #define NAE_RX_STATUS_MASK(x)                   (((x) & 0x7f) << 24)
 #define RESET_RX_STATUS_MASK                   ~((0x3f) << 24)
 
-        netsoc_write_nae_reg(nae_base,  RX_CONFIG,(rx_cfg &
+        	netsoc_write_nae_reg(nae_base,  RX_CONFIG,(rx_cfg &
                                           RESET_MAX_MESSAGE_SIZE &
                                           RESET_FRINDESCCLSIZE &
                                           RESET_RX_STATUS_MASK
@@ -2151,16 +2200,45 @@ void __netsoc_init_ingress(nae_t *nae, uint32_t desc_size)
                                NAE_MAX_MESSAGE_SIZE(0x0)|
                                NAE_RX_STATUS_MASK(0x43)|
                                NAE_FRINDESCCLSIZE(desc_size/64)
-                );
+                	);
 
 #define PARSER_THRESHOLD(x) ((x)  & 0x3ff)
 #define PARSER_THRESHOLD_DIV_DESCSIZE(x) ( ((x) & 0xff) << 12)
 #define PARSER_THRESHOLD_MOD_DESCSIZE_CL(x) ( ((x) & 0xff) << 20)
 
-        netsoc_write_nae_reg(nae_base, XLP_PARSER_CONFIG,
+		frin_descsz = (desc_size/64) & 0xff;
+		if ((frin_descsz == 0) || (frin_descsz > (parser_threshold/64)))
+			moddescsz = (parser_threshold / XLP_CACHE_LINE_SIZE);
+		else
+			moddescsz = (parser_threshold / XLP_CACHE_LINE_SIZE) % frin_descsz;
+
+		divdescsz = (parser_threshold/desc_size) + 1;
+
+	        netsoc_write_nae_reg(nae_base, XLP_PARSER_CONFIG,
+                               PARSER_THRESHOLD(parser_threshold) |
+                               PARSER_THRESHOLD_DIV_DESCSIZE(divdescsz) |
+                               PARSER_THRESHOLD_MOD_DESCSIZE_CL(moddescsz));
+		rx_cfg = netsoc_read_nae_reg(nae_base, RX_CONFIG);
+		netsoc_api_print(NETSOC_APIDBG_GLOBAL,"Parser thr %d devdescSz %d moddescSz %d \n", 
+			(rx_cfg & 0x3ff), ((rx_cfg>>12) & 0xff), ((rx_cfg>>20) & 0xff));
+	}
+	else {
+		for(i=0; i<current_netsoc->max_freeinqs;i++) {
+			netsoc_write_nae_reg(nae_base, FREE_IN_FIFO_UNIQ_SZ_CFG, (1<<31) | (i & 0x1f));
+			val = netsoc_read_nae_reg(nae_base, FREE_IN_FIFO_UNIQ_SZ_CFG);
+			desc_size = (val & 0x1f) * XLP_CACHE_LINE_SIZE;
+			if (desc_size == 0)
+				desc_size = 16*1024; 
+			if (desc_size < frin_descsz)
+				frin_descsz = desc_size;
+		}
+		divdescsz = (parser_threshold / frin_descsz) + 1;
+		netsoc_write_nae_reg(nae_base, XLP_PARSER_CONFIG,
                                PARSER_THRESHOLD(parser_threshold) |
-                               PARSER_THRESHOLD_DIV_DESCSIZE((parser_threshold/desc_size) + 1) |
-                               PARSER_THRESHOLD_MOD_DESCSIZE_CL( (parser_threshold/64)%desc_size) );
+                               PARSER_THRESHOLD_DIV_DESCSIZE(divdescsz));
+		netsoc_api_print(NETSOC_APIDBG_GLOBAL,"Parser thr %d devdescSz %d moddescSz is configured in FREE_IN_FIFO_UNIQ_SZ_CFG\n",
+			(rx_cfg & 0x3ff), ((rx_cfg>>12) & 0xff)); 
+	}
 }
 
 /**
@@ -2414,6 +2492,7 @@ int __netsoc_config_frame_size(net_port_t *netport, uint32_t size)
 	return NETSOC_API_SUCCESS;	
 }
  
+
 int __netsoc_config_flow_control(net_port_t *netport, uint32_t enable)
 {
 	unsigned int val, mask;
@@ -3212,16 +3291,18 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                                  spill_addr >>= 6;
                              }
                         }
-                        if(i < MAX_NAE_FREEIN_DESCS_QUEUE && (spillsz)) {
+                        if(spillsz) {
 
                                 reg = spill_addr & 0xffffffff;
                                 netsoc_write_nae_reg(nae->nae_base, FREE_SPILL0_MEM_CFG, reg);
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_addr %lx reg0 %x\n", i, (long)spill_addr, reg);
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_addr %lx spill_claddrlo %x\n", i, (long)(spill_addr << 6) ,
+							(long)spill_addr);
 
                                 reg = (((spill_addr >> 32) & 0x3) << 30) | spillsz;
                                 netsoc_write_nae_reg(nae->nae_base, FREE_SPILL1_MEM_CFG, reg);
 
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_addr %lx reg1 %x\n", i, (long)spill_addr, reg);
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_claddrhi %lx spillsize %d cachelines\n",
+								 i, ((reg >> 30) & 0x3), (reg & 0x3fffffff));
                                 spill_addr += spillsz;
                                 /* align to 32k, already >> 6 is done above, so align to 1k */
                                 spill_addr = (spill_addr + 1023) & (~1023);
@@ -3251,7 +3332,8 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                 /* spill credits [27:24] has to be 2 */
                 reg = (2 << 24) | th_lo | (th_hi << 12);
                 netsoc_write_nae_reg(nae->nae_base, FREE_FIFO_THRESHOLD_CFG, reg);
-
+		
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo spill thrhi %d thrlo %d\n",th_hi, th_lo);
                 if(spill_mem_addr && ((spill_addr << 6) > (spill_mem_addr + spill_mem_size))) {
                         netsoc_api_print(NETSOC_APIDBG_ERROR, "ERROR : Spill address range overflow\n");
                         return -NETSOC_API_PARAM_INVALID;
@@ -3314,10 +3396,12 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
         if (netport->iftype == INTERLAKEN_IF) {
 	        if ((nlm_hal_init_cs34x7(hw_port, nae->num_lanes[hw_port / XLP_ILK_MAX_LANES],
         	        nae->lane_rate[hw_port / XLP_ILK_MAX_LANES]) == 0) &&
-                	        (is_ilk_lanealigned(nae, hw_port/4)))
+                	        (is_ilk_lanealigned(nae, hw_port/4))) {
                         netsoc_api_print(NETSOC_APIDBG_PORT, "Interlaken lanes on port %d are aligned\n", hw_port);
-                else
+		}	
+                else {
                         netsoc_api_print(NETSOC_APIDBG_ERROR, "Interlaken initialization on port %d failed\n", hw_port);
+		}
         }
 #endif
         __netsoc_write_ucore_sprayvec(nae, hw_port, netport->ucore_mask);
@@ -3330,7 +3414,14 @@ static int __netsoc_init_net_port(net_port_t *netport, uint32_t context)
         }
 
         netsoc_api_print(NETSOC_APIDBG_PORT, "Initialized port@%d\n", hw_port);
+#ifdef CONTEXT_NUMBER_INSEQ
 	return netport->num_channels;
+#else
+	if (is_nlm_xlp9xx() && (nae->num_contexts == current_netsoc->max_contexts) && (nae->num_ports == current_netsoc->max_ports))
+          	return netport->num_channels;
+        else
+                return 8;
+#endif
 }
 
 
@@ -3389,8 +3480,10 @@ int __netsoc_init_nae(nae_t *nae)
                 /* For U-Boot, reset_nae clears all IO BARs
                  * which messes up Flash/CPLD/GBU BARs etc
                  */
+#ifndef XLP_SIM
                 __netsoc_reset_nae(nae);
                 nae->flags |= NAE_RESET_DONE;
+#endif
 
                 nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
 
@@ -3398,9 +3491,10 @@ int __netsoc_init_nae(nae_t *nae)
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "Configuring ucore...\n");
                 __netsoc_init_ucore(nae);
 
+#ifndef XLP_SIM
 		//Set NAE frequency
 		__netsoc_set_frequency(nae, nae->frequency);
-	
+#endif	
 		__netsoc_mdio_init(nae);
 
 		__netsoc_pcs_init(nae);
@@ -3428,6 +3522,10 @@ int __netsoc_init_nae(nae_t *nae)
         	}
  
 		if (is_nlm_xlp9xx()) {
+		      /* Configured for default MTU. This may not work for ports with different MTU size. */	
+		      netsoc_write_nae_reg(nae->nae_base, RX_ST_FWD_MODE, (1<<10) | (1536/16));
+		      			
+		      __netsoc_drop_runt_pkts(nae, 1);
                       /* Disable WRED discard for now. No PRM/document available to know how to configure WRED thresholds */ 
                       __netsoc_config_wred_disable(nae);
                 }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c b/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
index f6ef12e..a96b8bf 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
@@ -28,6 +28,7 @@
  * #BRCM_2# */
 
 #include "nlm_hal.h"
+#include "netsoc_dev.h"
 #include "nlm_nae.h"
 #include "netsoc_parser.h"
 #include "netsoc_libiface.h"
@@ -107,3 +108,14 @@ int __netsoc_config_nae_l4parser(nae_t *nae, l4_parser_config_t *l4_cfg, int ent
 	netsoc_write_nae_reg(nae->nae_base, L4_CTABLE_0_1 + (entry * 2), val);
 	return NETSOC_API_SUCCESS;	
 }
+
+
+int __netsoc_config_nae_l2parser_perport(nae_t *nae, l2_parser_config_t *l2, uint32_t portnum)
+{
+        uint32_t val;
+
+        __netsoc_disable_nae_hwparser(nae);
+        val = l2_parser_cfg2reg(l2);
+        netsoc_write_nae_reg(nae->nae_base, L2_TYPE_0 + portnum, val);
+	return NETSOC_API_SUCCESS;
+}
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
index 82d076a..cceb10a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
@@ -83,9 +83,9 @@ int __netsoc_init_poe_ext_storage(poe_t *poe, uint64_t fbp_base_phys,
 
         /* POE External Message Storage (upto 58K) */
 
-        nlm_print("POE ext msg storage: \n");
-        nlm_print("msg base: 0x%x%x\n", mbase_hi, mbase_lo);
-        nlm_print("fbp base: 0x%x%x\n", fbp_hi, fbp_lo);
+        netsoc_api_print(NETSOC_APIDBG_GLOBAL,"POE ext msg storage: \n");
+        netsoc_api_print(NETSOC_APIDBG_GLOBAL,"msg base: 0x%x%x\n", mbase_hi, mbase_lo);
+        netsoc_api_print(NETSOC_APIDBG_GLOBAL,"fbp base: 0x%x%x\n", fbp_hi, fbp_lo);
 
         /* Free Buffer Pool config */
         nlm_print (" POE Free Buffer Pool config ...\n");
@@ -226,7 +226,7 @@ int __netsoc_init_poe_distvec(poe_t *poe,int vec, uint32_t cm0, uint32_t cm1,
                             + (NUM_DISTVEC_CELLS - 1 - i);
                 value = distvec[i];
 
-                nlm_print("Node %d POE DistVec[%d]: reg=%d value=%08x\n",
+                netsoc_api_print(NETSOC_APIDBG_GLOBAL,"Node %d POE DistVec[%d]: reg=%d value=%08x\n",
                           poe->node, vec, (NUM_DISTVEC_CELLS - 1 - i), value);
                 netsoc_write_poe_pcim_reg(poe->pcim_base, reg_index, value);
         }
@@ -369,8 +369,9 @@ int __netsoc_init_poe(poe_t *poe)
         uint32_t index =0,thrsel_mask = 0;
  
 	netsoc_api_print(NETSOC_APIDBG_DEFAULT, "%s\n",__func__);
+#ifndef XLP_SIM
 	__netsoc_reset_poe(poe);
-	
+#endif	
 	__netsoc_poe_loc_msg_storage(poe);
 
 	if (poe->poe_address_map > 0ULL && poe->poe_address_len > 0) 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
index 8cd0da3..ebe1b43 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_v1_msg.c
@@ -30,7 +30,7 @@
 #include "lib_hdrs.h"
 #include "netsoc_msg.h"
 #include "nlm_nae.h"
-#include "nlm_hal_fmn.h"
+#include "nlm_hal_fmn_dp.h"
 
 /**
 * @brief netsoc_nae_send_p2d_and_rtn2dest function is used to send a packet and configures NAE to return the 40 bit
@@ -142,7 +142,7 @@ int netsoc_v1_noenq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_r
                          src_id, size, code, msg0, msg1, msg2);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -152,7 +152,7 @@ int netsoc_v1_noenq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_r
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = netv1_rx_addr(msg2);
 			*len = netv1_rx_len(msg2);
 			netv1_nae_decode_rxpktinfo(msg2, &pkt_info->nae.rx);
@@ -226,7 +226,7 @@ int netsoc_v1_enq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_rec
                          src_id, size, code, msg0, msg1, msg2);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -236,7 +236,7 @@ int netsoc_v1_enq_pkt_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_rec
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = netv1_rx_addr(msg2);
 			*len = netv1_rx_len(msg2);
 			netv1_nae_decode_rxpktinfo(msg2, &pkt_info->nae.rx);
@@ -299,7 +299,7 @@ int netsoc_v1_nae_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_in
                          src_id, size, code, msg0, msg1, msg2);
 #endif
 		if (size == 1) {
-			pkt_info->type = 0;
+			pkt_info->type = NET_TX_FREEBACK;
 			*addr = txfbk_address(msg0);
 			*len = 0;
 			nae_decode_txfbkinfo(msg0, &pkt_info->nae.txack);
@@ -309,7 +309,7 @@ int netsoc_v1_nae_recv(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_in
 #endif
 		}
 		else {
-			pkt_info->type = 1;
+			pkt_info->type = NET_RX;
 			*addr = netv1_rx_addr(msg2);
 			*len = netv1_rx_len(msg2);
 			netv1_nae_decode_rxpktinfo(msg2, &pkt_info->nae.rx);
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index 76e1e86..cba53ae 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -31,7 +31,6 @@
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/netdevice.h>
 #endif
-#include "nlm_hal_fmn.h"
 #include "nlm_hal_nae.h"
 #include "nlm_hal_sys.h"
 #include "libfdt.h"
@@ -1305,6 +1304,9 @@ void nlm_hal_config_sgmii_if(int node, int inf)
 	unsigned int netwk_inf = 0;
 	unsigned int ifmode, speed, duplex;
 	struct nlm_hal_ext_phy *this_phy=NULL;
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+        struct nlm_hal_mii_info mii_info;
+#endif
 
 
 	// Disable TX , Rx for now
@@ -1324,7 +1326,10 @@ void nlm_hal_config_sgmii_if(int node, int inf)
 	nlm_hal_ext_phy_an(node, inf);
 
 	// Read PHY status from extended status
-	nlm_hal_get_phy_status(node, inf, &speed, &duplex);
+	nlm_hal_get_phy_status(node, inf, &mii_info);
+
+        speed= mii_info.speed;
+        duplex= mii_info.duplex;
 
 #else
 	speed = SPEED_1000M;
@@ -5607,13 +5612,13 @@ void nlm_hal_mac_enable(int node, int block, int intf_type)
 * @ingroup hal_nae
 *
 */
-int nlm_hal_get_phy_status(int node, int inf, uint32_t *speed, uint32_t *duplex)
+int nlm_hal_get_phy_status(int node, int inf, struct nlm_hal_mii_info* mii_info)
 {
 	struct nlm_hal_ext_phy *this_phy=NULL;
 	this_phy = get_phy_info(inf);
 	if(!this_phy)
 		return 0;
-	return this_phy->phy_get_status(this_phy, speed, duplex, node);
+	return this_phy->phy_get_status(this_phy, mii_info, node);
 }
 
 
@@ -6065,11 +6070,12 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 
 int nlm_hal_restart_ucore(int node, void *fdt)
 {
+	nae_t *nae_cfg = (nae_t *)nlm_node_cfg.nae_cfg[node];;
 	nlm_print("%s node %d\n", __func__, node);
 
-	if (nlm_node_cfg.nae_cfg[node] == NULL)
+	if (nae_cfg == NULL)
 		return -1;
-	if(nlm_node_cfg.nae_cfg[node]->owned)
+	if(nae_cfg->owned)
 		parse_ucore_config(fdt, node);
 	return 0;
 }
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_phy.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_phy.c
index 62c3597..b6e5cac 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_phy.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_phy.c
@@ -30,10 +30,9 @@
 
 
 #include "nlm_hal.h"
-#include "nlm_hal_fmn.h"
 #include "nlm_hal_nae.h"
 #include "nlm_hal_crypto.h"
-#include "nlm_hal_xlp_dev.h"
+#include "netsoc_dev.h"
 #include "nlm_hal_sys.h"
 #include "libfdt.h"
 #include "fdt_helper.h"
@@ -46,15 +45,15 @@ void sgmii_scan_phys(int node);
 void  nlm_hal_sata_firmware_init(void);
 void register_phy(int node, int inf, int* hw_portid);
 
-static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node);
+static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
 static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node);
 static void mvl_init_phy(struct nlm_hal_ext_phy *phy, int node);
 
-static int  bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node);
+static int  bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
 static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node);
 static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node);
 
-static int  xmc_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node);
+static int  xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
 static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node);
 static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node);
 
@@ -565,101 +564,84 @@ static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
 * @ingroup hal_nae
 *
 */
-static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node)
-{
-	int aux_status=0;
-	int status=0;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-	//int int_inf = phy->inf;
-
-
-	/*switch to Copper registers mode*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
-
-#if 0
-	/* start auto-negotiation on copper side */
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
-	status |= (1 << 9);
-	nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status );
-#endif
-
-#if 0
-	/* wait up to 5 seconds for AN to complete on copper side*/
-	i=0;
-	do {
-		nlm_mdelay(100);
-		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-		if (aux_status & 0x8000)
-			break;
-
-		i++;
-	}while(i<50);
-#endif
-	/* check the status */
-	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-	switch ((aux_status>>8) & 0x7){
-		case 0x7:
-			*speed = SPEED_1000M;
-			*duplex = 1;
-		break;
-
-		case 0x6:
-			*speed = SPEED_1000M;
-			*duplex = 0;
-		break;
 
-		case 0x5:
-			*speed = SPEED_100M;
-			*duplex = 1;
-		break;
-
-		case 0x3:
-			*speed = SPEED_100M;
-			*duplex = 0;
-		break;
-
-		case 0x2:
-			*speed = SPEED_10M;
-			*duplex = 1;
-		break;
-
-		case 0x1:
-			*speed = SPEED_10M;
-			*duplex = 0;
-		break;
+static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
+{
+        int aux_status=0;
+        int status=0;
+        int phyaddr = phy->phy_addr;
+        int bus = phy->ext_mdio_bus;
+        mii_info->phyaddr=phyaddr;
+        /*int int_inf = phy->inf; */
+
+
+        /*switch to Copper registers mode*/
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+        status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+        /* check the status */
+        aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+        switch ((aux_status>>8) & 0x7){
+                case 0x7:
+                        mii_info->speed = SPEED_1000M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x6:
+                        mii_info->speed = SPEED_1000M;
+                        mii_info->duplex = 0;
+                break;
+
+                case 0x5:
+                        mii_info->speed = SPEED_100M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x3:
+                        mii_info->speed = SPEED_100M;
+                        mii_info->duplex = 0;
+                break;
+
+                case 0x2:
+                        mii_info->speed = SPEED_10M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x1:
+                        mii_info->speed = SPEED_10M;
+                        mii_info->duplex = 0;
+                break;
 
-		default:
-			nlm_print("Unknown operating speed, auxstatus = 0x%04x\n", aux_status);
-		break;
-	}
+                default:
+                        nlm_print("Unknown operating speed, auxstatus = 0x%04x\n", aux_status);
+                break;
+        }
 
 //#ifdef PHY_DEBUG
-	if(*speed==SPEED_1000M)
-		nlm_print("Configured with Speed  1000M");
-	if(*speed==SPEED_100M)
-		nlm_print("Configured with Speed 100M");
-	if(*speed==SPEED_10M)
-		nlm_print("Configured with Speed 10M");
-
-	((*duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+        if(mii_info->speed==SPEED_1000M)
+                nlm_print("Configured with Speed  1000M");
+        if(mii_info->speed==SPEED_100M)
+                nlm_print("Configured with Speed 100M");
+        if(mii_info->speed==SPEED_10M)
+                nlm_print("Configured with Speed 10M");
+
+        ((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
 //#endif
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	if(status & (1<<2)){
-		nlm_print("Link is up : %x\n", status);
-		xmc_phy_status(phy, node);
-		//nlm_print("%s: exit\n", __func__);
-		return 1;
-	}else{
-		nlm_print("Link is down : %x\n", status);
-		xmc_phy_status(phy, node);
-		//nlm_print("%s: exit\n", __func__);
-		return 0;
-	}
+        status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+        status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+        if(status & (1<<2)){
+                mii_info->link_stat = LINK_UP;
+                nlm_print("Link is up : %x\n", status);
+                xmc_phy_status(phy, node);
+                /*nlm_print("%s: exit\n", __func__); */
+                return 1;
+        }else{
+                mii_info->link_stat = LINK_DOWN;
+                nlm_print("Link is down : %x\n", status);
+                xmc_phy_status(phy, node);
+                /*nlm_print("%s: exit\n", __func__); */
+                return 0;
+        }
 }
 
 /**
@@ -676,75 +658,79 @@ static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 * @ingroup hal_nae
 *
 */
-static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node)
-{
-	int aux_status=0;
-	int status=0;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-	//int int_inf = phy->inf;
-
-	bcm_start_an(phy, node);
-
-	/*switch to Copper registers mode*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
-	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-	switch ((aux_status>>8) & 0x7){
-		case 0x7:
-			*speed = SPEED_1000M;
-			*duplex = 1;
-		break;
-
-		case 0x6:
-			*speed = SPEED_1000M;
-			*duplex = 0;
-		break;
-
-		case 0x5:
-			*speed = SPEED_100M;
-			*duplex = 1;
-		break;
 
-		case 0x3:
-			*speed = SPEED_100M;
-			*duplex = 0;
-		break;
-
-		case 0x2:
-			*speed = SPEED_10M;
-			*duplex = 1;
-		break;
-
-		case 0x1:
-			*speed = SPEED_10M;
-			*duplex = 0;
-		break;
+static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
+{
+        int aux_status=0;
+        int status=0;
+        int phyaddr = phy->phy_addr;
+        int bus = phy->ext_mdio_bus;
+        mii_info->phyaddr=phyaddr;
+        /*int int_inf = phy->inf; */
+
+        bcm_start_an(phy, node);
+
+        /*switch to Copper registers mode*/
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+        status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+        aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+        switch ((aux_status>>8) & 0x7){
+                case 0x7:
+                        mii_info->speed = SPEED_1000M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x6:
+                        mii_info->speed = SPEED_1000M;
+                        mii_info->duplex = 0;
+                break;
+
+                case 0x5:
+                        mii_info->speed = SPEED_100M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x3:
+                        mii_info->speed = SPEED_100M;
+                        mii_info->duplex = 0;
+                break;
+
+                case 0x2:
+                        mii_info->speed = SPEED_10M;
+                        mii_info->duplex = 1;
+                break;
+
+                case 0x1:
+                        mii_info->speed = SPEED_10M;
+                        mii_info->duplex = 0;
+                break;
 
-		default:
-			nlm_print("Unknown operating speed\n");
-		break;
-	}
+                default:
+                        nlm_print("Unknown operating speed\n");
+                break;
+        }
 
 //#ifdef PHY_DEBUG
-	if(*speed==SPEED_1000M)
-		nlm_print("Configured with Speed  1000M");
-	if(*speed==SPEED_100M)
-		nlm_print("Configured with Speed 100M");
-	if(*speed==SPEED_10M)
-		nlm_print("Configured with Speed 10M");
-
-	((*duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+        if(mii_info->speed==SPEED_1000M)
+                nlm_print("Configured with Speed  1000M");
+        if(mii_info->speed==SPEED_100M)
+                nlm_print("Configured with Speed 100M");
+        if(mii_info->speed==SPEED_10M)
+                nlm_print("Configured with Speed 10M");
+
+        ((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
 //#endif
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	if(status & (1<<2)){
-		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, status);
-		return 1;
-	}else{
-		nlm_print("bus:%d phy:%d Link is down : %x\n", bus, phyaddr, status);
-		return 0;
-	}
+        status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+        if(status & (1<<2)){
+                mii_info->link_stat = LINK_UP;
+                nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, status);
+                return 1;
+        }else{
+                mii_info->link_stat = LINK_DOWN;
+                nlm_print("bus:%d phy:%d Link is down : %x\n", bus, phyaddr, status);
+                return 0;
+        }
 }
 
 /**
@@ -761,25 +747,28 @@ static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 * @ingroup hal_nae
 *
 */
-static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node)
+static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
 {
 	uint16_t extstatus;
 	int phyaddr = phy->phy_addr;
 	int bus = phy->ext_mdio_bus;
 
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
+        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
         extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
-        *speed = (extstatus >> 14) & 0x3;
-        *duplex =  (extstatus >> 13) & 0x1;
-	if (extstatus & 0x0400) {
-		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, extstatus);
-		return 1;
-	}
-	else {
-		nlm_print("bus:%d phy:%d Link is down : %x\n",bus, phyaddr, extstatus);
-		return 0;
-	}
-
+        mii_info->speed = (extstatus >> 14) & 0x3;
+        mii_info->duplex =  (extstatus >> 13) & 0x1;
+        mii_info->phyaddr=phyaddr;
+
+        if (extstatus & 0x0400) {
+                mii_info->link_stat = LINK_UP;
+                nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, extstatus);
+                return 1;
+        }
+        else {
+                mii_info->link_stat = LINK_DOWN;
+                nlm_print("bus:%d phy:%d Link is down : %x\n",bus, phyaddr, extstatus);
+                return 0;
+        }
 }
 
 /**
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index bbfbd19..e2a12c6 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -39,11 +39,29 @@
 
 #include "nlm_hal_macros.h"
 #include "nlm_hal_xlp_dev.h"
-#include "nlm_nae.h"
+//#include "nlm_nae.h"
 #ifndef __ASSEMBLY__
 
 #include "nlm_hal_sys.h"
 
+struct nlm_node_config
+{
+        int valid;
+        int num_nodes;  // Number of nodes
+        void *nae_cfg[NLM_MAX_NODES];      // NAE configuration
+        struct fmn_cfg *fmn_cfg[NLM_MAX_NODES];
+};
+
+
+enum freq_config {
+        NLM_DEFAULT     = 0,
+        NLM_NAE,
+        NLM_RSA,
+        NLM_SAE,
+        NLM_DTRE,
+        NLM_CDE,
+};
+
 struct nlm_netl_proc_info{
 	unsigned int proc_id;
 	unsigned int chipid;		/*example: xlp832=>0x8084, xlp316=>0x3044, xlp208=>0x2024 etc */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h
index 45cedc3..65c0edc 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_sys.h
@@ -41,7 +41,7 @@
 
 #define COUNT_OF(x) ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))
 
-/* TODO: Griffin support for different REFCLKs. */
+/* TODO: XLP9xx support for different REFCLKs. */
 /* 133.333 MHz Reference Clock */
 #define REF_CLK_NUM_400 400000000ULL
 #define REF_CLK_NUM_200 200000000ULL
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index bccbb52..a564a38 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -390,6 +390,28 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 
 #define XLP_9XX_INVALID_STATION		0x2FF
 
+#define XLP_9XX_NET0_TX_VC_BASE      520
+#define XLP_9XX_NET0_TX_VC_LIMIT     583
+#define XLP_9XX_NET0_RX_VC_BASE      584
+#define XLP_9XX_NET0_RX_VC_LIMIT     599
+
+#define XLP_9XX_NET1_TX_VC_BASE      648
+#define XLP_9XX_NET1_TX_VC_LIMIT     711
+#define XLP_9XX_NET1_RX_VC_BASE      712
+#define XLP_9XX_NET1_RX_VC_LIMIT     727
+
+#define XLP9XX_NAE_DEVICE               3
+#define XLP9XX_NAE_FUNC                 0
+
+#define XLP9XX_NAE1_DEVICE              3
+#define XLP9XX_NAE1_FUNC                3
+
+#define XLP9XX_POE_DEVICE               3
+#define XLP9XX_POE_FUNC                 1
+
+#define XLP9XX_POE1_DEVICE              3
+#define XLP9XX_POE1_FUNC                4 
+
 /*Sw Code */
 #define XLP_CODE_MAC		0
 #define XLP_CODE_SEC		1
@@ -558,463 +580,11 @@ enum XLP_MSG_HANDLES  {
         XLP_MSG_HANDLE_MAX,
 };
 
-/*
- *  NET Accelerator
- */
-#define XLP_NA_REG_BLOCK_SIZE 0x2000 /* 8KB */
-#define XLP_NA_REG_IFACE_SIZE 0x200 /* 512B */
-
-enum net_cfg_regs {
- RX_CONFIG                          = 0x10,
- TX_CONFIG                          = 0x11,
- RX_IF_BASE_CONFIG_0                = 0x12,
- RX_IF_BASE_CONFIG_1                = 0x13,
- RX_IF_BASE_CONFIG_2                = 0x14,
- RX_IF_BASE_CONFIG_3                = 0x15,
- RX_IF_BASE_CONFIG_4                = 0x16,
- RX_IF_BASE_CONFIG_5                = 0x17,
- RX_IF_BASE_CONFIG_6                = 0x18,
- RX_IF_BASE_CONFIG_7                = 0x19,
- RX_IF_BASE_CONFIG_8                = 0x1a,
- RX_IF_BASE_CONFIG_9                = 0x1b,
- RX_IFACE_VEC_VALID                 = 0x1c,
- RX_IFACE_SLOT_CAL                  = 0x1d,
- XLP_PARSER_CONFIG                  = 0x1e,
- PARSER_SEQ_FIFO_CFG                = 0x1f,
- FREE_IN_LIFO_CFG                   = 0x20,
- RX_BUFFER_BASE_DEPTH_ADDR_REG      = 0x21,
- RX_BUFFER_BASE_DEPTH_REG           = 0x22,
- RX_UCORE_CFG                       = 0x23,
- RX_UCORE_CAM_MASK0_CFG             = 0x24,
- RX_UCORE_CAM_MASK1_CFG             = 0x25,
- RX_UCORE_CAM_MASK2_CFG             = 0x26,
- RX_UCORE_CAM_MASK3_CFG             = 0x27,
- FREE_IN_LIFO_UNIQ_SZ_CFG           = 0x28,
- CRC_POLY0_CFG                      = 0x2a,
- CRC_POLY1_CFG                      = 0x2b,
- FREE_SPILL0_MEM_CFG                = 0x2c,
- FREE_SPILL1_MEM_CFG                = 0x2d,
- FREE_LIFO_THRESHOLD_CFG    	    = 0x2e,
- RX_FREE_LIFO_THRESH                = 0x87,
- FLOW_CRC16_POLY_CFG                = 0x2f,
- DMA_TX_CREDIT_TH                   = 0x29,
- STG1_STG2CRDT_CMD                  = 0x30,
- STG1_STG2CRDT_STATUS               = 0x31,
- STG2_EHCRDT_CMD                    = 0x32,
- STG2_EHCRDT_STATUS                 = 0x33,
- STG2_FREECRDT_CMD                  = 0x34,
- STG2_FREECRDT_STATUS               = 0x35,
- STG2_STRCRDT_CMD                   = 0x36,
- STG2_STRCRDT_STATUS                = 0x37,
- TXFIFO_IFACE_MAP_CMD               = 0x38,
- TXFIFO_IFACE_MAP_STATUS            = 0x39,
- VFBID_TO_DEST_MAP_CMD              = 0x3a,
- STG1_PMEM_PROG                     = 0x3c,
- STG1_PMEM_STATUS                   = 0x3d,
- STG2_PMEM_PROG                     = 0x3e,
- STG2_PMEM_STATUS                   = 0x3f,
- EH_PMEM_PROG                       = 0x40,
- EH_PMEM_STATUS                     = 0x41,
- FREE_PMEM_PROG                     = 0x42,
- FREE_PMEM_STATUS                   = 0x43,
- TX_DRR_ACTVLIST_CMD                = 0x44,
- TX_DRR_ACTVLIST_STATUS             = 0x45,
- TX_IFACE_BURSTMAX_CMD              = 0x46,
- TX_IFACE_BURSTMAX_STATUS           = 0x47,
- TX_IFACE_ENBL_CMD                  = 0x48,
- TX_IFACE_ENBL_STATUS               = 0x49,
- TX_PKTLEN_PMEM_CMD                 = 0x4a,
- TX_PKTLEN_PMEM_STATUS              = 0x4b,
- TX_SCHED_MAP_CMD0                  = 0x4c,
- TX_SCHED_MAP_CMD1                  = 0x4d,
- EGR_NIOR_CAL_LEN_REG       	    = 0x4e,
- EGR_NIOR_CRDT_CAL_PROG     	    = 0x52,
- TX_SCHED_MAP_STATUS0               = 0x387,
- TX_SCHED_MAP_STATUS1               = 0x388,
- TX_PKT_PMEM_CMD0                   = 0x50,
- TX_PKT_PMEM_CMD1                   = 0x51,
- TX_PKT_PMEM_STATUS                 = 0x389,
- TX_SCHED_CTRL                      = 0x53,
- STR_PMEM_CMD                       = 0x58,
- TX_IORCRDT_INIT                    = 0x59,
- RX_FREE_LIFO_POP                   = 0x62,
- FLOW_BASE_MASK_CFG                 = 0x80,
- POE_CLASS_SETUP_CFG                = 0x81,
- UCORE_IFACE_MASK_CFG               = 0x82,
- RX_BUFFER_XONOFF_THR    	    = 0x83,
- FLOW_TABLE1_CFG                    = 0x84,
- FLOW_TABLE3_CFG                    = 0x86,
- IFACE_FIFO_CFG             	    = 0x8a,
- PARSER_SEQ_FIFOTH_CFG		    = 0x8b,
- L2_TYPE_0                          = 0x210,
- L3_CTABLE_MASK_0                   = 0x22c,
- L3_CTABLE_0_0                      = 0x230,
- L3_CTABLE_0_1                      = 0x231,
- L4_CTABLE_0_0                      = 0x250,
- L4_CTABLE_0_1                      = 0x251,
- VFBID_TO_DEST_MAP_STATUS           = 0x380,
-
-NET_COMMON0_INTR_STS		    = 0x2A8,
-NET_COMMON0_INTR_MASK		    = 0x2A9,
-
- /*1588 PTP timer */
-IF_1588_TMSMP_HI		    = 0x300,
-IF_1588_TMSMP_LO		    = 0x301,
-
-PTP_OFFSET_HI		    	    = 0x784,
-PTP_OFFSET_LO		            = 0x785,
-PTP_INC_DEN		            = 0x786,
-PTP_INC_NUM		            = 0x787,
-PTP_INC_INTG		            = 0x788,
-PTP_CONTROL		            = 0x789,
-PTP_STATUS			    = 0x78A,
-PTP_USER_VALUE_HI		    = 0x78B,
-PTP_USER_VALUE_LO		    = 0x78C,
-PTP_TMR1_HI		            = 0x78D,
-PTP_TMR1_LO		            = 0x78E,
-PTP_TMR2_HI		            = 0x78F,
-PTP_TMR2_LO		            = 0x790,
-PTP_TMR3_HI		            = 0x791,
-PTP_TMR3_LO		            = 0x792,
-
-IOSYS_RTC_CMD      = 0x7C0,
-IOSYS_RTC_RDATA_HI = 0x7C1,
-IOSYS_RTC_RDATA_LO = 0x7C2,
-
-};
-
-enum if_cfg_regs {
-  MAC_CONF1 = 0,
-  MAC_CONF2 = 1,
-  SGMII_MAX_FRAME_LEN = 4,
-
-  NETWK_INF_CTRL3_REG = 0x7c,
-  NETWK_INF_CTRL_REG = 0x7f
-};
-
-enum xaui_cfg_regs {
-	XGMAC_CTL_REG1 = 0x7f,
-	XGMAC_CTL_REG2 = 0x7e,
-	XGMAC_CTL_REG3 = 0x7d,
-	XGMAC_STATUS_REG = 0x7c,
-};
-
-enum netior_regs {
-	NETIOR_SOFTRESET = 3,
-	NETIOR_MISC_REG1_ADDR = 0x39,
-	NETIOR_MISC_REG2_ADDR = 0x3a,
-	NETIOR_MISC_REG3_ADDR = 0x3d,
-
-};
-enum NAE_TX_TYPE {
-	P2D_NEOP = 0,
-	P2P      = 1,
-	P2D_EOP  = 2,
-	MSC      = 3
-};
-
-/* NAE Interface Definitions
- */
-enum NAE_INTF_TYPE {
-	GMAC_0 = 0,
-	GMAC_1 = 1,
-	GMAC_2 = 2,
-	GMAC_3 = 3,
-	XGMAC  = 4,
-	INTERLAKEN = 5,
-	PHY	 = 0xE,
-	LANE_CFG = 0xF,
-};
-
-enum NAE_BLOCK_NR {
-	BLOCK_0 = 0,
-	BLOCK_1,
-	BLOCK_2,
-	BLOCK_3,
-	BLOCK_4,
-	BLOCK_5,
-	BLOCK_6,
-	BLOCK_7,
-};
-
 typedef struct {
         unsigned int base_vc;
         unsigned int vc_limit;
 }nlm_fmn_config_t;
 
-typedef enum PHY_LANE_INTF_TYPE {
-	LANE_DISCONNECTED,
-	LANE_GMAC,
-	LANE_XGMAC,
-	LANE_8ILAKEN,
-} phy_lane_intf_t;
-
-
-/* MACSEC
- */
-enum nae_macsec_cfg_regs {
-TX_MSEC_ETHER_TYPE		= 0x33e,
-TX_MSEC_PORT_EN          	= 0x33f,
-TX_MSEC_BYPASS         		= 0x340,
-TX_MSEC_PROG_STATUS      	= 0x341,
-TX_MSEC_INIT_PN          	= 0x342,
-TX_MSEC_PN_THRESH        	= 0x343,
-TX_MSEC_PREAMBLE_LEN_CODE      	= 0x344,
-TX_MSEC_KEY_IN_USE0		= 0x345,
-TX_MSEC_KEY_IN_USE1		= 0x346,
-TX_MSEC_KEY_IN_USE2		= 0x347,
-TX_MSEC_KEY_IN_USE3		= 0x348,
-TX_MSEC_KEY_XED_THRESH0     	= 0x349,
-TX_MSEC_KEY_XED_THRESH1      	= 0x34a,
-TX_MSEC_KEY_XED_THRESH2      	= 0x34b,
-TX_MSEC_KEY_XED_THRESH3      	= 0x34c,
-TX_MSEC_KEY_STALE0		= 0x34d,
-TX_MSEC_KEY_STALE2		= 0x34f,
-TX_MSEC_KEY_STALE3		= 0x350,
-TX_MSEC_KEY_ERR0            	= 0x351,
-TX_MSEC_KEY_ERR1            	= 0x352,
-TX_MSEC_KEY_ERR2            	= 0x353,
-TX_MSEC_KEY_ERR3            	= 0x354,
-
-TX_MSEC_MEM_DATAREG_0           = 0x38c,
-TX_MSEC_MEM_DATAREG_1           = 0x38d,
-TX_MSEC_MEM_DATAREG_2           = 0x38e,
-TX_MSEC_MEM_DATAREG_3           = 0x38f,
-TX_MSEC_MEM_CTRL_REG            = 0x390,
-
-RX_MSEC_MEM_DATAREG_0        	= 0x400,
-RX_MSEC_MEM_DATAREG_1        	= 0x401,
-RX_MSEC_MEM_DATAREG_2        	= 0x402,
-RX_MSEC_MEM_DATAREG_3        	= 0x403,
-RX_MSEC_MEM_CTRL_REG         	= 0x404,
-
-RX_MSEC_PORT_EN         	= 0x405,
-RX_MSEC_BYPASS         		= 0x406,
-RX_MSEC_SEC_TAG0		= 0x407,
-RX_MSEC_SEC_TAG1      		= 0x408,
-RX_MSEC_INIT_PN             	= 0x409,
-RX_MSEC_REPLAY_WIN_SIZE     	= 0x40a,
-RX_MSEC_SCI_MASK0_LO        	= 0x40b,
-RX_MSEC_SCI_MASK0_HI         	= 0x40c,
-RX_MSEC_SCI_MASK1_LO         	= 0x40d,
-RX_MSEC_SCI_MASK1_HI         	= 0x40e,
-RX_MSEC_SCI_MASK2_LO         	= 0x40f,
-RX_MSEC_SCI_MASK2_HI         	= 0x410,
-RX_MSEC_SCI_MASK3_LO         	= 0x411,
-RX_MSEC_SCI_MASK3_HI         	= 0x412,
-RX_MSEC_SCI_MASK4_LO         	= 0x413,
-RX_MSEC_SCI_MASK4_HI         	= 0x414,
-RX_MSEC_SCI_MASK5_LO         	= 0x415,
-RX_MSEC_SCI_MASK5_HI         	= 0x416,
-RX_MSEC_SCI_MASK6_LO         	= 0x417,
-RX_MSEC_SCI_MASK6_HI         	= 0x418,
-RX_MSEC_SCI_MASK7_LO         	= 0x419,
-RX_MSEC_SCI_MASK7_HI		= 0x41a,
-
-};
-
-#define RX_MSEC_SCI_MASK_LO(i) (0x40b + i *2)
-#define RX_MSEC_SCI_MASK_HI(i) (0x40c + i *2)
-
-/*
- *  POE
- */
-
-enum poe_reg_type {
-	PCIE_CFG_POE_REG = 0,
-	PCIE_MEM_POE_REG = 1,
-};
-
-enum poe_cfg_reg {
-  MAX_FLOW_MSGS0 = 64,
-  MAX_MSGS_CLASS0 = 72,
-  CLASS0_SIZE = 88,
-  ERROR_MESG0 = 96,
-  LO_CNT_OOO_MSG = 104,
-  LO_CNT_INORDER_MSG = 105,
-  LO_CNT_LOCBUF_ST = 106,
-  LO_CNT_EXTBUF_ST = 107,
-  LO_CNT_LOCBUF_ALLOC = 108,
-  LO_CNT_EXTBUF_ALLOC = 109,
-  HI_CNT_OOO_MSG = 110,
-  HI_CNT_INORDE_RMSG = 111,
-  HI_CNT_LOCBUF_ST = 112,
-  HI_CNT_EXTBUF_ST = 113,
-  HI_CNT_LOCBUF_ALLOC = 114,
-  HI_CNT_EXTBUF_ALLOC = 115,
-  DROP_CNT_DIST0 = 192,
-  DROP_CNT_CLASS0 = 208,
-  DROP_CNT_DIST_CLASS0 = 216,
-  DROP_CNT_CPU = 224,
-  DROP_CNT_MAX_FLOW =  225,
-  INT_VECTOR = 320,
-  POE_INT_MASK = 321,
-  FATAL_ERR_MASK = 322,
-  BIU_CONFIG = 323,
-  BIU_TIMEOUT = 324,
-  ENQUED_MSG_SENT = 336,
-  ENQUED_MSG_CNT = 337,
-  DIST_THRESHOLD0 = 448,
-  DIST_CLASS_DROP_ENABLE = 459,
-  DIST_VEC_DROP_ENABLE = 460,
-  DIST_DROP_TIMER = 461,
-  ERROR_LOG_WORD0 = 462,
-  ERROR_INJ_CTL = 465,
-  DIST_VEC_0_15 = 466,
-  LOCAL_FBP_BASE = 0x400,
-  MSG_STORAGE_BASE_ADR_L = 0x60,
-  FBP_BASE_ADR_L = 0x62,
-};
-
-enum poe_stats_reg {
-	OO_MSG_CNT_LO = 0xa8,
-	IN_ORDER_MSG_CNT_LO,
-	LOC_BUF_STOR_CNT_LO,
-	EXT_BUF_STOR_CNT_LO,
-	LOC_BUF_ALLOC_CNT_LO,
-	EXT_BUF_ALLOC_CNT_LO,
-        OO_MSG_CNT_HI ,
-        IN_ORDER_MSG_CNT_HI,
-        LOC_BUF_STOR_CNT_HI,
-        EXT_BUF_STOR_CNT_HI,
-        LOC_BUF_ALLOC_CNT_HI,
-        EXT_BUF_ALLOC_CNT_HI,
-	MODE_ERR_FLOW_ID,
-	POE_STATISTICS_EN,
-	POE_MAX_SIZE_FLOW,
-	POE_MAX_SIZE
-};
-
-#define POE_CL0_ENQ_SPILL_BASE_L	0x40
-#define POE_CL0_ENQ_SPILL_BASE_H	0x41
-#define POE_CL1_ENQ_SPILL_BASE_L	0x42
-#define POE_CL1_ENQ_SPILL_BASE_H	0x43
-#define POE_CL2_ENQ_SPILL_BASE_L	0x44
-#define POE_CL2_ENQ_SPILL_BASE_H	0x45
-#define POE_CL3_ENQ_SPILL_BASE_L	0x46
-#define POE_CL3_ENQ_SPILL_BASE_H	0x47
-#define POE_CL4_ENQ_SPILL_BASE_L	0x48
-#define POE_CL4_ENQ_SPILL_BASE_H	0x49
-#define POE_CL5_ENQ_SPILL_BASE_L	0x4a
-#define POE_CL5_ENQ_SPILL_BASE_H	0x4b
-#define POE_CL6_ENQ_SPILL_BASE_L	0x4c
-#define POE_CL6_ENQ_SPILL_BASE_H	0x4d
-#define POE_CL7_ENQ_SPILL_BASE_L	0x4e
-#define POE_CL7_ENQ_SPILL_BASE_H	0x4f
-
-#define POE_CL0_DEQ_SPILL_BASE_L	0x50
-#define POE_CL0_DEQ_SPILL_BASE_H	0x51
-#define POE_CL1_DEQ_SPILL_BASE_L	0x52
-#define POE_CL1_DEQ_SPILL_BASE_H	0x53
-#define POE_CL2_DEQ_SPILL_BASE_L	0x54
-#define POE_CL2_DEQ_SPILL_BASE_H	0x55
-#define POE_CL3_DEQ_SPILL_BASE_L	0x56
-#define POE_CL3_DEQ_SPILL_BASE_H	0x57
-#define POE_CL4_DEQ_SPILL_BASE_L	0x58
-#define POE_CL4_DEQ_SPILL_BASE_H	0x59
-#define POE_CL5_DEQ_SPILL_BASE_L	0x5a
-#define POE_CL5_DEQ_SPILL_BASE_H	0x5b
-#define POE_CL6_DEQ_SPILL_BASE_L	0x5c
-#define POE_CL6_DEQ_SPILL_BASE_H	0x5d
-#define POE_CL7_DEQ_SPILL_BASE_L	0x5e
-#define POE_CL7_DEQ_SPILL_BASE_H	0x5f
-
-#define POE_CL0_ENQ_SPILL_MAXLINE	0x64
-#define POE_CL1_ENQ_SPILL_MAXLINE	0x65
-#define POE_CL2_ENQ_SPILL_MAXLINE	0x66
-#define POE_CL3_ENQ_SPILL_MAXLINE	0x67
-#define POE_CL4_ENQ_SPILL_MAXLINE	0x68
-#define POE_CL5_ENQ_SPILL_MAXLINE	0x69
-#define POE_CL6_ENQ_SPILL_MAXLINE	0x6a
-#define POE_CL7_ENQ_SPILL_MAXLINE	0x6b
-
-#define POE_CL0_DEQ_SPILL_MAXLINE	0x6c
-#define POE_CL1_DEQ_SPILL_MAXLINE	0x6d
-#define POE_CL2_DEQ_SPILL_MAXLINE	0x6e
-#define POE_CL3_DEQ_SPILL_MAXLINE	0x6f
-#define POE_CL4_DEQ_SPILL_MAXLINE	0x70
-#define POE_CL5_DEQ_SPILL_MAXLINE	0x71
-#define POE_CL6_DEQ_SPILL_MAXLINE	0x72
-#define POE_CL7_DEQ_SPILL_MAXLINE	0x73
-
-#define POE_DIST_THRESHOLD_0 	0x200
-#define POE_DEST_THRESHOLD	0x204
-#define POE_DIST_ENABLE 0x205
-#define POE_DIST_VEC0	0x100
-#define POE_DIST_THRESHOLD_VAL 0xa
-#define POE_MAX_LOCAL_MSGS (6 << 10) /* 6K */
-#define POE_TX_TIMER     0x214
-#define POE_FBP_SP       0xb8
-#define POE_FBP_SP_EN    0xb9
-#define POE_LOC_ALLOC_EN 0xba
-#define POE_EXT_ALLOC_EN 0xbb
-#define POE_LOCAL_FBP_BASE 0x400
-
-#define POE_ENQ_SPILL_THOLD	0x208
-#define POE_DEQ_SPILL_THOLD	0x209
-#define POE_DEQ_SPILL_TIMER	0x20A
-#define POE_DISTR_CLASS_DROP_EN	0x20B
-#define POE_DISTR_VEC_DROP_EN	0x20C
-#define POE_DISTRVEC_DROP_TIMER	0x20D
-
-#define EXT_FBP_START_ADDR       0x1800
-#define MAX_POE_EXT_MSG_STORAGE  (58 << 10) /* 58K entries */
-#define POE_FBP_SP_INIT	 	 0x740
-
-#define XLP3XX_EXT_FBP_START_ADDR	0x1000
-#define XLP3XX_POE_MAX_LOCAL_MSGS	(4 << 10)
-#define XLP3XX_MAX_POE_EXT_MSG_STORAGE 	(28 << 10)
-#define XLP3XX_POE_FBP_SP_INIT	 	0x380
-
-enum POE_SW_CODE {
-	DROP_IN_NAE = 0,
-	FWD_DEST,
-	RENQ_DVEC,
-	RENQ_DEST,
-	FWD_DVEC,
-	DROP_IN_POE,
-	RENQ_DVEC_SERIAL,
-	RENQ_DEST_SERIAL
-};
-
-/*
- *  UCORE
- */
-#define MAX_NAE_UCORES 16
-#define NAE_UCORE_MASK 0xffff
-#define CODE_SIZE_PER_UCORE (4 << 10)
-#define UC_MAGIC_REG_OFFSET_TO_INDEX(offset) (((offset) - 0x8000)/4)
-#define UCORE_OUTBUF_DONE  0x8000
-#define UCORE_RX_PKT_RDY  0x8004
-#define UCORE_RX_PKT_INFO  0x8008
-#define UCORE_CAM0  0x800c
-#define UCORE_CAM1  0x8010
-#define UCORE_CAM2  0x8014
-#define UCORE_CAM3  0x8018
-#define UCORE_CAM_RES  0x801c
-#define UCORE_CSUM_INFO  0x8020
-#define UCORE_CRC_INFO  0x8024
-#define UCORE_CRC_POS  0x8028
-#define UCORE_FREE_FIFO_EMPTY  0x802c
-#define UCORE_PKT_DISTR  0x8030
-#define UCORE_MAGIC_REG_BASE UCORE_OUTBUF_DONE
-#define UCORE_MAGIC_REG_LIMIT UCORE_PKT_DISTR
-#define UCORE_MAX_MAGIC_REGS (1 + (UCORE_MAGIC_REG_LIMIT - UCORE_MAGIC_REG_BASE) / 4)
-
-#define UCORE_PKT_DISCARD 0x2
-
-/* Ucore Memory Map. To be used in Microcode based apps only */
-#define UCORE_SHARED_CAM_START 0x17000
-#define UCORE_SHARE_CAM_END    0x17bff
-#define UCORE_SHARED_MEM_START 0x18000
-#define UCORE_SHARE_MEM_END    0x1ffff
-
-/* Ucore Shared memory Map for cpu. To be used in cpu only, to access ucore shared mem */
-#define UCORE_CPU_SHARED_CAM_START 0x18000
-#define UCORE_CPU_SHARED_CAM_END   0x18bff
-#define UCORE_CPU_SHARED_MEM_START 0x10000
-#define UCORE_CPU_SHARED_MEM_END   0x17fff
-
 #define SYS_REG_BASE	(( KSEG1 + 0x18000000 + XLP_PCIE_NODE0_SYSOFFSET) & 0x1fffffff )
 #define SYS_REG_INDEX(x)   ( 0x40 + (x))
 
@@ -1555,507 +1125,6 @@ enum xlp2xx_sys_cfg_regs {
         nlm_hal_write_32bit_reg ((xlp_rsa_base[node]), (reg), (val))
 
 #endif
-enum {
-	PHYMODE_NONE = 0,
-	PHYMODE_HS_SGMII = 1,
-	PHYMODE_XAUI = 1,
-	PHYMODE_SGMII = 2,
-	PHYMODE_IL = 3,
-	PHYMODE_RXAUI = 6,
-};
-
-enum {
-	LM_UNCONNECTED = 0,
-	LM_SGMII = 1,
-	LM_XAUI = 2,
-	LM_IL = 3,
-};
-
-#define MAX_GMAC_PORT			18
-#define MAX_CPLX_BLOCK                  5
-#define MAX_LANE_PER_CPLX               4
-
-/*PRM: VSEMI  CONFIG REGISTERS*/
-#define VSEMI_CMD 			0x9
-#define VSEMI_CTL0			0xA
-	#define VSEMI_CTL_POR			(1<<9)
-	#define VSEMI_CTL_SYNTH_RST		(1<<10)
-	#define VSEMI_CTL_RTHR			(0xf<<12)
-#define VSEMI_CTL1			0xB
-
-	#define VSEMI_CTL_MASK_DR	(0x7)
-	#define VSEMI_CTL_RXAUI_10G_DR	(0x3)
-	#define VSEMI_CTL_XAUI_16G_DR	(0x3)
-	#define VSEMI_CTL_XAUI_12G_DR	(0x3)
-	#define VSEMI_CTL_XAUI_DR	(0x2)
-	#define VSEMI_CTL_SGMII_DR	(0x1)
-
-	#define VSEMI_CTL_MASK_DW	(0x70)
-	#define VSEMI_CTL_RXAUI_10G_DW	(0x30)
-	#define VSEMI_CTL_XAUI_16G_DW	(0x10)
-	#define VSEMI_CTL_XAUI_12G_DW	(0x10)
-	#define VSEMI_CTL_XAUI_DW	(0x10)
-	#define VSEMI_CTL_SGMII_DW	(0x10)
-	
-#define VSEMI_STATUS			0xC
-#define VSEMI_PINCTRL			0xD
-#define VSEMI_PIN_STS			0XE
-
-
-
-/*
- * PRM: 11.10.2 PHY and PMA Controller Registers
- */
-#define PHY_LANE_0_STATUS               0
-#define PHY_LANE_1_STATUS               1
-#define PHY_LANE_2_STATUS               2
-#define PHY_LANE_3_STATUS               3
-    #define PHY_LANE_STAT_SRCS          0x00000001 /* bit 1: Rx clock stable if 1 */
-    #define PHY_LANE_STAT_STD           0x00000010 /* bit 4: Transmit Detect if 1 */
-    #define PHY_LANE_STAT_SFEA          0x00000020 /* bit 5: Far end absent if 1 */
-    #define PHY_LANE_STAT_STCS          0x00000040 /* bit 6: Tx clock stable if 1 */
-    #define PHY_LANE_STAT_SPC           0x00000200 /* bit  9: SGMII PCS Sync bit; 1:synced 0:fault*/
-    #define PHY_LANE_STAT_XLF           0x00000400 /* bit 10: XAUI lane sync bit; 0:synced 1:fault*/
-    #define PHY_LANE_STAT_PCR           0x00000800 /* bit 11: PMA Controller Ready; 1:ready */
-    #define LANE_RX_CLK                     (1 << 0)
-    #define LANE_TX_CLK                     (1 << 6)
-#define PHY_LANE_0_CTRL                 4
-#define PHY_LANE_1_CTRL                 5
-#define PHY_LANE_2_CTRL                 6
-#define PHY_LANE_3_CTRL                 7
-    #define PHY_LANE_CTRL_DATA_POS      0
-    #define PHY_LANE_CTRL_ADDR_POS      8
-    #define PHY_LANE_CTRL_CMD_READ      0x00010000
-    #define PHY_LANE_CTRL_CMD_WRITE     0x00000000
-    #define PHY_LANE_CTRL_CMD_START     0x00020000
-    #define PHY_LANE_CTRL_CMD_PENDING   0x00040000
-    #define PHY_LANE_CTRL_RESET_PMA	0x00100000
-    #define PHY_LANE_CTRL_ALL           0x00200000
-    #define PHY_LANE_CTRL_FAST_INIT     0x00400000
-    #define PHY_LANE_CTRL_REXSEL_POS    23
-    #define PHY_LANE_CTRL_PHYMODE_POS   25
-    #define PHY_LANE_CTRL_PWRDOWN       0x20000000
-    #define PHY_LANE_CTRL_RST           0x40000000
-    #define PHY_LANE_CTRL_RST_XAUI      0xc0000000
-    #define PHY_LANE_CTRL_BPC_XAUI      0x80000000
-#define LANE_CFG_CPLX_0_1               0x0
-#define LANE_CFG_CPLX_2_3               0x1
-#define LANE_CFG_CPLX_4                 0x2
-    #define LANE_CFG_LANE_0_POS         0
-    #define LANE_CFG_LANE_1_POS         4
-    #define LANE_CFG_LANE_2_POS         8
-    #define LANE_CFG_LANE_3_POS         12
-
-    #define LANE_CFG_DISCONNECT         0
-    #define LANE_CFG_GMAC               1
-    #define LANE_CFG_XGMAC              2
-    #define LANE_CFG_8ILAKEN            3
-#define NET_INTF_SOFT_RST               0x3
-
-#define INT_MDIO_CTRL                   0x19
-    #define INT_MDIO_CTRL_ST		0
-    #define INT_MDIO_CTRL_ST_POS        0
-    #define INT_MDIO_CTRL_OP_POS        2
-    #define INT_MDIO_CTRL_PHYADDR_POS   4
-    #define INT_MDIO_CTRL_DEVTYPE_POS   9
-    #define INT_MDIO_CTRL_TA_POS        14
-    #define INT_MDIO_CTRL_TA    	0x02
-    #define INT_MDIO_CTRL_MIIM_POS      16
-    #define INT_MDIO_CTRL_LOAD_POS      19
-    #define INT_MDIO_CTRL_XDIV_POS      21
-    #define INT_MDIO_CTRL_MCDIV_POS     28
-    #define INT_MDIO_CTRL_RST           0x40000000
-    #define INT_MDIO_CTRL_SMP           0x00100000
-    #define INT_MDIO_CTRL_CMD_LOAD      0x00080000
-
-    #define INT_MDIO_CTRL_XDIV		7
-    #define INT_MDIO_CTRL_MCDIV		1
-
-#define INT_MDIO_CTRL_DATA              0x1A
-#define INT_MDIO_RD_STAT                0x1B
-    #define INT_MDIO_RD_STAT_MASK       0x0000FFFF
-    #define INT_MDIO_STAT_LFV           0x00010000
-    #define INT_MDIO_STAT_SC            0x00020000
-    #define INT_MDIO_STAT_SM            0x00040000
-    #define INT_MDIO_STAT_MIILFS        0x00080000
-    #define INT_MDIO_STAT_MBSY          0x00100000
-#define INT_MDIO_LINK_STAT              0x1C
-
-#define EXT_XG0_MDIO_CTRL               0x25
-#define EXT_XG1_MDIO_CTRL               0x29
-    #define EXT_XG_MDIO_CTRL_ST		0
-    #define EXT_XG_MDIO_CTRL_OP_POS     2
-#define MDIO_CTRL_OP_INDIRECT_ADDR      0x00
-#define MDIO_CTRL_OP_WRITE_10G_MMD      0x01
-#define MDIO_CTRL_OP_READ_10G_MMD       0x02
-#define MDIO_CTRL_OP_POST_RDINC_ADDR    0x03
-
-    #define EXT_XG_MDIO_CTRL_PHYADDR_POS	4
-    #define EXT_XG_MDIO_CTRL_REG_POS		9
-    #define EXT_XG_MDIO_CTRL_TA    	0x02
-    #define EXT_XG_MDIO_CTRL_TA_POS     14
-    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
-    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
-    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
-    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
-    #define EXT_XG_MDIO_CTRL_RST        0x40000000
-    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
-    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
-    #define MDIO_MIIM_CMD_IDLE		0x000
-    #define MDIO_MIIM_CMD_WRITE		0x001
-    #define MDIO_MIIM_CMD_READ		0x002
-    #define MDIO_MIIM_CMD_SM		0x003
-    #define MDIO_MIIM_CMD_MM		0x004
-    #define MDIO_MIIM_CMD_10G_MMD	0x005
-    #define MDIO_MIIM_CMD_CLEAR_LINK	0x006
-
-#define EXT_G0_MDIO_CTRL                0x1D
-#define EXT_G1_MDIO_CTRL                0x21
-    #define EXT_G_MDIO_CLOCK_DIV_4      0
-    #define EXT_G_MDIO_CLOCK_DIV_2      1
-    #define EXT_G_MDIO_CLOCK_DIV_1      2
-    #define EXT_G_MDIO_REGADDR_POS      5
-    #define EXT_G_MDIO_PHYADDR_POS      10
-    #define EXT_G_MDIO_CMD_SP           0x00008000
-    #define EXT_G_MDIO_CMD_PSIA 		0x00010000
-    #define EXT_G_MDIO_CMD_LCD          0x00020000
-    #define EXT_G_MDIO_CMD_RDS          0x00040000
-    #define EXT_G_MDIO_CMD_SC           0x00080000
-    #define EXT_G_MDIO_MMRST            0x00100000
-    #define EXT_G_MDIO_DIV              0x0000001E
-    #define EXT_G_MDIO_DIV_WITH_HW_DIV64 0x00000010
-    #define EXT_G_MDIO_DIV_WITH_HW_DIV64_11 0x00000011
-
-#define EXT_G0_MDIO_CTRL_DATA           0x1E
-#define EXT_G1_MDIO_CTRL_DATA           0x22
-
-#define EXT_G0_MDIO_LINK_STAT           0x20
-#define EXT_G1_MDIO_LINK_STAT           0x24
-
-#define EXT_G0_MDIO_RD_STAT             0x1F
-#define EXT_G1_MDIO_RD_STAT             0x23
-    #define EXT_G_MDIO_RD_STAT_MASK     0x0000FFFF
-    #define EXT_G_MDIO_STAT_LFV         0x00010000
-    #define EXT_G_MDIO_STAT_SC          0x00020000
-    #define EXT_G_MDIO_STAT_SM          0x00040000
-    #define EXT_G_MDIO_STAT_MIILFS      0x00080000
-    #define EXT_G_MDIO_STAT_MBSY        0x80000000
-    #define MDIO_OP_CMD_READ            0x10
-    #define MDIO_OP_CMD_WRITE           0x01
-
-#define EXT_XG0_MDIO_CTRL               0x25
-#define EXT_XG1_MDIO_CTRL               0x29
-    #define EXT_XG_MDIO_CTRL_ST_POS     0
-    #define EXT_XG_MDIO_CTRL_OP_POS     2
-    #define EXT_XG_MDIO_CTRL_PHYADDR_POS        4
-    #define EXT_XG_MDIO_CTRL_DEVTYPE_POS        9
-    #define EXT_XG_MDIO_CTRL_TA_POS     14
-    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
-    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
-    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
-    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
-    #define EXT_XG_MDIO_CTRL_RST        0x40000000
-    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
-    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
-
-#define EXT_XG0_MDIO_CTRL_DATA          0x26
-#define EXT_XG1_MDIO_CTRL_DATA          0x2A
-
-#define EXT_XG0_MDIO_LINK_STAT          0x28
-#define EXT_XG1_MDIO_LINK_STAT          0x2C
-
-#define EXT_XG0_MDIO_RD_STAT            0x27
-#define EXT_XG1_MDIO_RD_STAT            0x2B
-    #define EXT_XG_MDIO_RD_STAT_MASK    0x0000FFFF
-    #define EXT_XG_MDIO_STAT_LFV        0x00010000
-    #define EXT_XG_MDIO_STAT_SC         0x00020000
-    #define EXT_XG_MDIO_STAT_SM         0x00040000
-    #define EXT_XG_MDIO_STAT_MIILFS     0x00080000
-    #define EXT_XG_MDIO_STAT_MBSY       0x00100000
-
-#define GMAC_FC_SLOT0                   0x2D
-#define GMAC_FC_SLOT1                   0x2E
-#define GMAC_FC_SLOT2                   0x2F
-#define GMAC_FC_SLOT3                   0x30
-
-#define XAUI_CONFIG_0                   0
-    #define XAUI_CONFIG_MACRST          0x80000000
-    #define XAUI_CONFIG_RSTRCTL         0x00400000
-    #define XAUI_CONFIG_RSTRFN          0x00200000
-    #define XAUI_CONFIG_RSTTCTL         0x00040000
-    #define XAUI_CONFIG_RSTTFN          0x00020000
-    #define XAUI_CONFIG_RSTMIIM         0x00010000
-
-#define XAUI_CONFIG_1                   1
-    #define XAUI_CONFIG_TCTLEN          0x80000000
-    #define XAUI_CONFIG_TFEN            0x40000000
-    #define XAUI_CONFIG_RCTLEN          0x20000000
-    #define XAUI_CONFIG_RFEN            0x10000000
-    #define XAUI_CONFIG_DRPLT64         0x00000020
-    #define XAUI_CONFIG_LENCHK          0x00000008
-    #define XAUI_CONFIG_GENFCS          0x00000004
-    #define XAUI_CONFIG_PAD_0           0x00000000
-    #define XAUI_CONFIG_PAD_64          0x00000001
-    #define XAUI_CONFIG_PAD_COND        0x00000002
-    #define XAUI_CONFIG_PAD_68          0x00000003
-
-#define XAUI_CONFIG_2                   2
-
-#define XAUI_CONFIG_3                   3
-
-#define XAUI_MAX_FRAME_LEN              8
-#define XAUI_PHY_CTRL_1                 0x00
-    #define XAUI_PHY_RST                0x8000
-    #define XAUI_PHY_LOOPBACK           0x4000
-    #define XAUI_PHY_SPSEL1             0x2000
-    #define XAUI_PHY_LOW_POWER          0x0800
-    #define XAUI_PHY_SPSEL0             0x0040
-    #define XAUI_PHY_10G                0x0000
-
-#define XAUI_PHY_STAT_1                 0x01
-    #define XAUI_PHY_FAULT_DP           0x0008
-    #define XAUI_PHY_LINK_UP            0x0004
-    #define XAUI_PHY_LOWPOWER           0x0002
-
-#define XAUI_PHY_SPEED_CAP              0x04
-    #define XAUI_PHY_10G_CAP            0x0001
-
-#define XAUI_PHY_DEV_PRESENT            0x05
-    #define XAUI_PHY_DTE_XS_DP          0x0020
-    #define XAUI_PHY_XS_DP              0x0010
-    #define XAUI_PHY_PCS_DP             0x0008
-    #define XAUI_PHY_WIS_DP             0x0004
-    #define XAUI_PHY_PMD_PMA_DP         0x0002
-    #define XAUI_PHY_CL22_DP            0x0001
-
-#define XAUI_PHY_STAT_2                 0x08
-    #define XAUI_PHY_STAT2_DP           0x2000
-    #define XAUI_PHY_TXF                0x0800
-    #define XAUI_PHY_RXF                0x0400
-#define XAUI_LANE_STAT                  0x18
-    #define XAUI_LANE_ALIGNED           0x1000
-    #define XAUI_LANE_PTE_EN            0x0800
-    #define XAUI_LANE_LOOPBACK_EN       0x0400
-    #define XAUI_LANE_PTE_EN            0x0800
-    #define XAUI_LANE_PTE_EN            0x0800
-    #define XAUI_LANE_PTE_EN            0x0800
-    #define XAUI_LANE_L3S               0x0008
-    #define XAUI_LANE_L2S               0x0004
-    #define XAUI_LANE_L1S               0x0002
-    #define XAUI_LANE_L0S               0x0001
-
-#define XAUI_PHY_TEST_CTRL              0x19
-    #define XAUI_PHY_TEST_PATTERN_EN    0x04
-    #define XAUI_PHY_TEST_HI_FREQ       0x00
-    #define XAUI_PHY_TEST_LOW_FREQ      0x01
-    #define XAUI_PHY_TEST_MIXED_FREQ    0x02
-
-#define NAE_THR_SEPARATION		   8
-#define NAE_MTU_LEN			1518
-#define NAE_REACTION_LEN_XAUI		1463
-#define NAE_REACTION_LEN_SGMII		1126
-#define NAE_REACTION_LEN_PARSER		  14
-#define NAE_INFLIGHT_LEN_XAUI		 504
-#define NAE_INFLIGHT_LEN_SGMII		 108
-#define NAE_SMALLEST_PKT_LEN		  64
-#define NAE_XAUI_THR_GROUP		   1
-#define NAE_SGMII_THR_GROUP		   2
-#define NAE_RXAUI_THR_GROUP		   3
-#define NAE_ILK_THR_GROUP		   4
-#define NAE_RX_THR_BYTE_UNIT	          16
-#define NAE_PAUSE_TIMER_DELTA		  32
-
-#define NETIOR_HIGIG2_CTRL0		0x70
-#define NETIOR_HIGIG2_CTRL1		0x71
-#define NETIOR_HIGIG2_CTRL2		0x72
-#define NETIOR_HIGIG2_PAUSE_CTRL1	0x73
-#define NETIOR_HIGIG2_MACSA		0x74
-#define NETIOR_HIGIG2_STATUS		0x75
-#define NETIOR_HIGIG2_MISC		0x76
-
-#define NETIOR_VLANTYPE_FILTER		0x76
-    #define VLAN_RxHMC			16
-    #define VLAN_RxPAC			17
-#define NETIOR_XGMAC_CTRL1              0x7F
-    #define NETIOR_XGMAC_RXAUI_DC_POS        30 /* Rxaui Disparity calculation */
-    #define NETIOR_XGMAC_RXAUI_EN_POS        29 /* Enable RXAUI Mode */
-
-    #define NETIOR_XGMAC_VLAN_DC_POS    28
-    #define NETIOR_XGMAC_PHYADDR_POS    23
-    #define NETIOR_XGMAC_DEVID_POS      18
-    #define NETIOR_XGMAC_STATS_EN_POS   17
-    #define NETIOR_XGMAC_STATS_CLR_POS	16
-    #define NETIOR_XGMAC_TX_PFC_EN_POS  14
-    #define NETIOR_XGMAC_RX_PFC_EN_POS  13
-    #define NETIOR_XGMAC_SOFT_RST_POS   11
-    #define NETIOR_XGMAC_TX_PAUSE_POS   10
-
-    #define NETIOR_XGMAC_RXAUI_SCRAMBLER_POS 4
-
-#define NETIOR_XGMAC_CTRL2		0x7E
-#define NETIOR_XGMAC_CTRL3		0x7D
-
-#define MAC_ADDR0_LO			0x50
-#define MAC_ADDR0_HI			0x51
-#define MAC_FILTER_CONFIG		0x5c
-	#define MAC_FILTER_BCAST_EN_POS 	10
-	#define MAC_FILTER_MCAST_EN_POS		8
-	#define MAC_FILTER_ALL_UCAST_EN         7
-	#define MAC_FILTER_UHASH_EN             5
-        #define MAC_FILTER_MHASH_EN             6
-	#define MAC_FILTER_ADDR0_VALID_POS 	0
-#define MAC_ADDR0_MASK_LO		0x58
-#define MAC_ADDR0_MASK_HI		0x59
-
-/* Interlaken Registers */
-
-#define ILK_TX_CONTROL			0x00
-    #define ILK_TX_CTRL_RST_INF		0x80000000
-    #define ILK_TX_CTRL_RST_CORE	0x40000000
-    #define ILK_TX_CTRL_TXO		0x20000000
-    #define ILK_TX_CTRL_TXU		0x10000000
-    #define ILK_TX_CTRL_TXBE		0x08000000
-    #define ILK_TX_CTRL_DSW		0x00000200
-    #define ILK_TX_CTRL_BAD_LANE	0x00000100
-    #define ILK_TX_CTRL_RATELIM_EN	0x00000002
-    #define ILK_TX_CTRL_TX_EN		0x00000001
-
-    #define ILK_TX_CTRL_FIFO_THR_POS	19
-    #define ILK_TX_CTRL_CAL_LEN_POS	15
-    #define ILK_TX_CTRL_BS_POS		12
-    #define ILK_TX_CTRL_BMAX_POS	10
-    #define ILK_TX_CTRL_BLS_POS		5
-    #define ILK_TX_CTRL_LLS_POS		2
-
-#define ILK_TX_RATE_LIMIT		0x01
-    #define ILK_TX_RATE_LIM_UI_POS	24
-    #define ILK_TX_RATE_LIM_DELTA_POS	12
-    #define ILK_TX_RATE_LIM_MTC_POS	0
-
-#define ILK_TX_META_CTRL		0x02
-    #define ILK_TX_META_CTRL_TXLEN_POS	16
-    #define ILK_TX_META_CTRL_RXLEN_POS	0
-
-#define ILK_RX_CONTROL			0x03
-    #define ILK_RX_CTRL_RST_CORE	0x00800000
-    #define ILK_RX_CTRL_BAD_LANE	0x00000004
-    #define ILK_RX_CTRL_FORCE_RESYNC	0x00000002
-    #define ILK_RX_CTRL_PKT_MODE	0x00000001
-
-    #define ILK_RX_CTRL_RST_LANE_POS	24
-    #define ILK_RX_CTRL_BMAX_POS	9
-    #define ILK_RX_CTRL_LLS_POS		6
-    #define ILK_RX_CTRL_BLS_POS		3
-
-#define ILK_RX_STATUS1			0x04
-    /* All fields are RWC */
-    #define ILK_RX_STAT1_MFS_POS	24
-    #define ILK_RX_STAT1_MFSE_POS	16
-    #define ILK_RX_STAT1_MFLE_POS	8
-    #define ILK_RX_STAT1_MFRE_POS	0
-
-#define ILK_RX_STATUS2			0x05
-    /* All fields are RWC */
-    #define ILK_RX_STAT2_RDCV_POS	24
-    #define ILK_RX_STAT2_RDCE_POS	16
-    #define ILK_RX_STAT2_RDIS_POS	8
-    #define ILK_RX_STAT2_RDLS_POS	0
-
-#define ILK_GENERAL_CTRL1		0x06
-    #define ILK_GEN_CTRL1_RXBTE_POS	16
-    #define ILK_GEN_CTRL1_RXMBITS_POS	12	/* PRM bug */
-    #define ILK_GEN_CTRL1_RXFC_POS	8	/* Bits 8..11 RXFC (This is not included in PRM) */
-    #define ILK_GEN_CTRL1_TXMBITS_POS	0
-
-#define ILK_RX_STATUS3			0x07
-    #define ILK_RX_STAT3_CC_MAP		0x00080000
-    #define ILK_RX_STAT3_TIME_STAMP	0x00040000  /*RWC */
-    #define ILK_RX_STAT3_RXL_ALIGN	0x00020000
-    /* Bits 16-0 RWC */
-    #define ILK_RX_STAT3_WCRC_ERR	0x00010000
-    #define ILK_RX_STAT3_CWCRC_ERR	0x00008000
-    #define ILK_RX_STAT3_SS_ERR		0x00004000
-    #define ILK_RX_STAT3_MFLEN_ERR	0x00002000
-    #define ILK_RX_STAT3_MFRPT_ERR	0x00001000
-    #define ILK_RX_STAT3_WRDSYNC_ERR	0x00000800
-    #define ILK_RX_STAT3_MF_ERR		0x00000400
-    #define ILK_RX_STAT3_FRM_ERR	0x00000200
-    #define ILK_RX_STAT3_BADTYPE_ERR	0x00000100
-    #define ILK_RX_STAT3_SOP_ERR	0x00000080
-    #define ILK_RX_STAT3_EOP_ERR	0x00000040
-    #define ILK_RX_STAT3_LA_ERR		0x00000020
-    #define ILK_RX_STAT3_LM_ERR		0x00000010
-    #define ILK_RX_STAT3_BMAX_ERR	0x00000008
-    #define ILK_RX_STAT3_BURST_ERR	0x00000004
-    #define ILK_RX_STAT3_FIFO_OVF_ERR	0x00000002
-    #define ILK_RX_STAT3_OTHER_ERR	0x00000001
-
-#define ILK_RX_FC_TMAP0			0x08
-#define ILK_RX_FC_TMAP1			0x09
-#define ILK_RX_FC_TMAP2			0x0A
-#define ILK_RX_FC_TMAP3			0x0B
-#define ILK_RX_FC_TMAP4			0x0C
-
-#define ILK_RX_FC_TADDR			0x0D
-    #define ILK_RX_FC_RXMTUDROP_EN	0x40000000
-    #define ILK_RX_FC_REQ_VALID		0x00000020
-    #define ILK_RX_FC_WRITE_REQ		0x00000010
-
-    #define ILK_RX_FC_RXMTU_SIZE_POS	17  /* size in 16byte words */
-    #define ILK_RX_FC_TABLE_IDX_POS	0
-
-#define ILK_GENERAL_CTRL2		0x0E
-    #define ILK_GEN_CTRL2_STATS_COR	0x40000000
-
-    #define ILK_GEN_CTRL2_SCS5_POS	25
-    #define ILK_GEN_CTRL2_SCS4_POS	20
-    #define ILK_GEN_CTRL2_SCS3_POS	15
-    #define ILK_GEN_CTRL2_SCS2_POS	10
-    #define ILK_GEN_CTRL2_SCS1_POS	5
-    #define ILK_GEN_CTRL2_SCS0_POS	0
-
-#define ILK_GENERAL_CTRL3		0x0F
-    #define ILK_GEN_CTRL3_LCS1_POS	17
-    #define ILK_GEN_CTRL3_LCS0_POS	14
-    #define ILK_GEN_CTRL3_MCS1_POS	12
-    #define ILK_GEN_CTRL3_MCS0_POS      10
-    #define ILK_GEN_CTRL3_SCS7_POS	5
-    #define ILK_GEN_CTRL3_SCS6_POS	0
-
-#define ILK_SMALL_COUNT0		0x10
-#define ILK_SMALL_COUNT1                0x11
-#define ILK_SMALL_COUNT2                0x12
-#define ILK_SMALL_COUNT3                0x13
-#define ILK_SMALL_COUNT4                0x14
-#define ILK_SMALL_COUNT5                0x15
-#define ILK_SMALL_COUNT6                0x16
-#define ILK_SMALL_COUNT7                0x17
-#define ILK_MID_COUNT0			0x18
-#define ILK_MID_COUNT1			0x19
-#define ILK_LARGE_COUNT_L0		0x1A
-#define ILK_LARGE_COUNT_L1              0x1B
-#define ILK_LARGE_COUNT_H0		0x1C
-#define ILK_LARGE_COUNT_H1              0x1D
-
-/* Serdes Register */
-#define SER_GEN1_PWR_DOWN		0x0E
-    #define SERDES_PMFF_ALL_SET		0x04
-
-#define SERDES_PRBS_CTRL		0x64
-    #define SERDES_LOOPBACK_EN		0x02
-
-#define ILK_BURST_MAX           	3 /* 256 bytes */
-
-#define XLP_ILK_LANE_RATE_LOW           0       /* 0, 19, 0 */
-#define XLP_ILK_LANE_RATE_HIDH          1       /* 1, 19, 0 */
-
-#define XLP_ILK_PORT_0                  0
-#define XLP_ILK_PORT_1                  8
-
-#define XLP_ILK_PORT0_CS                3
-#define XLP_ILK_PORT1_CS                4
-
-#define XLP_ILK_MAX_LANES               8
 
 /* SPI */
 #define XLP_SPI_CONFIG			0x40
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 69d964e..1551efe 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -6,7 +6,7 @@
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
  * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
  * or the Broadcom license below:
 
  * Redistribution and use in source and binary forms, with or without
@@ -37,19 +37,9 @@
 
 
 /**
-* @defgroup hal_overview Hardware Abstraction Layer APIs
-* @brief HAL is the lowest API layer provided in the XLP SDK.
-*
-* HAL APIs provide register level access, configuration, and initialization to HyperExec. HAL is primarily used to implement the HyperExec library, as well as to implement OS level features such as kernel drivers or BSPs. <br>
-*
-*/
-
-/**
-* @defgroup hal Generic Hardware Abstraction Layer APIs
+* @defgroup hal Hardware Abstraction Layer APIs
 * @brief This section describes the generic and miscellaneous HAL APIs. <br>
 *
-* The generic HAL APIs provide the rudimentary functions for XLP register access.
-*
 * <b>Source:</b> libraries/hal/nlm_hal.c <br>
 * @ingroup hal_overview
 */
@@ -58,26 +48,19 @@
 * @defgroup hal_nae NAE Hardware Abstraction Layer APIs
 * @brief This section describes the NAE(Network Acceleration Engine) HAL APIs.<br>
 *
-* The NAE HAL APIs provide accses to all aspects of networking with the NAE, including NAE programming, POE programming, MAC programming, and external PHY access.
-*
 * <b>Source:</b> libraries/hal/nlm_hal.c <br>
 * <b>Header:</b> hyperexec/srcs/drivers/hal/nlm_hal.h
-* @ingroup hal_overview
 */
 
 /**
 * @defgroup hal_sae SAE Hardware Abstraction Layer APIs
 * @brief This section describes the SAE(Security Acceleration Engine) HAL APIs <br>
 *
-* The SAE HAL APIs configure the SAE for application usage.
-*
 * <b>Source:</b> libraries/hal/nlm_hal.c <br>
 * <b>Header:</b> hyperexec/srcs/drivers/hal/nlm_hal_sae.h
-* @ingroup hal_overview
 */
 
 #include "nlm_hal.h"
-#include "nlm_hal_nae.h"
 #include "nlm_hal_crypto.h"
 #include "nlm_hal_xlp_dev.h"
 #include "nlm_hal_sys.h"
@@ -99,37 +82,6 @@ unsigned long xlp_regex_base_pcim;
 
 struct nlm_node_config  nlm_node_cfg;
 
-static int reg_num_phys;
-void sgmii_scan_phys(int node);
-void  nlm_hal_sata_firmware_init(void);
-void register_phy(int node, int inf, int* hw_portid);
-
-static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
-static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node);
-static void mvl_init_phy(struct nlm_hal_ext_phy *phy, int node);
-
-static int  bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
-static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node);
-static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node);
-
-static int  xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node);
-static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node);
-static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node);
-
-void nlm_hal_init_ext_phy(int node, int inf);
-void nlm_hal_config_sgmii_if(int node, int inf);
-
-struct nlm_hal_ext_phy * get_phy_info(int inf);
-#define MAX_PHYS 18
-/*PHYs */
-static struct nlm_hal_ext_phy  known_ext_phys[] = {
-		{"mvs103656", 0xc97, 0, 0, 0, mvl_get_phy_status, mvl_start_an, mvl_init_phy},
-		{"bcm5461s", 0x60c1, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
-		{"bcm5482", 0xbcb2, 0, 0, 0, xmc_get_phy_status, xmc_start_an, xmc_init_phy},
-		{"bcm5416", 0x5e74, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
-		{"", 0, 0, 0, 0, NULL, NULL, NULL}
-};
-static struct nlm_hal_ext_phy regs_ext_phys[MAX_PHYS];
 
 static __inline__ unsigned int power_on_reset_cfg(void)
 {
@@ -441,7 +393,7 @@ __inline__ void nlm_hal_init(void)
 
  	for(node = 0; node < NLM_MAX_NODES; node++)
 	{
-		/*nlm_node_cfg.nae_cfg[node] = NULL; */
+		//nlm_node_cfg.nae_cfg[node] = NULL;
 		nlm_node_cfg.nae_cfg[node] = NULL;
 		nlm_node_cfg.fmn_cfg[node] = NULL;
 
@@ -450,11 +402,11 @@ __inline__ void nlm_hal_init(void)
         	/* PCI enumeration of supported devices*/
 		xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
 
-		xlp_mac_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_NAE)), PCI_MEM_BAR_0); /*0x18018000 */
-		/*printf("Node:%d NAE_MAC_Base:%lX\n", node, xlp_mac_base[node]); */
+		xlp_mac_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_NAE)), PCI_MEM_BAR_0); //0x18018000
+		//printf("Node:%d NAE_MAC_Base:%lX\n", node, xlp_mac_base[node]);
 		xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
 
-		xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_POE)), PCI_MEM_BAR_0);	/*0x18019000 */
+		xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_POE)), PCI_MEM_BAR_0);	//0x18019000
 		xlp_poe_base_pcie[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_POE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
 
 		xlp_sys_base[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
@@ -846,854 +798,6 @@ unsigned long tlb_size_to_mask(unsigned long size)
 }
 #endif
 
-#ifdef PHY_DEBUG
-static void dump_phy_regs(int node, int inf)
-{
-	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
-	int j = 0;
-	for(;j<nae_cfg->num_ports;j++){
-		if(nae_cfg->ports[j].hw_port_id == inf)
-			break;
-	}
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x0);
-	nlm_print("Page0 Control Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 0));
-	nlm_print("Page0 Status Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 1));
-        nlm_print("Page0 ExtStatus Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 17));
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x2);
-	nlm_print("Page %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22));
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x2);
-
-        nlm_print("Page2 Control Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 0));
-        nlm_print("Page2 media Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 10));
-	nlm_print("Page2 Reg26 (Bypass) %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 26));
-	nlm_print("Page2 SGMII sync %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 17));
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x0);
-}
-#endif
-
-/**
-* @brief nlm_hal_init_ext_phy function initializes the external PHY of an interface.
-*
-* @param [in] node Node number
-* @param [in] inf Interface number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-void nlm_hal_init_ext_phy(int node, int inf)
-{
-	struct nlm_hal_ext_phy *this_phy=NULL;
-	this_phy = get_phy_info(inf);
-	if(!this_phy)
-		return;
-	this_phy->ext_phy_init(this_phy, node);
-	return;
-}
-
-#if 0
-/* print various phy status registers */
-static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node)
-{
-	int status;
-	int bus = phy->ext_mdio_bus;
-	int phyaddr = phy->phy_addr;
-	int int_inf = phy->inf;
-
-	/*operating mode status reg */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x17, 0xf42);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x15);
-	nlm_print("%s: operating mode status for phy %d = 0x%x \n", __func__, phyaddr, status);
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
-	nlm_print("%s: nae %d  register 1= 0x%x \n", __func__, int_inf, status);
-
-
-}
-#else
-static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node) {;}
-#endif
-
-/**
-* @brief xmc_init_phy function initializes an external BROADCOM 5482 PHY on the XMC board.
-*
-* @param[in] phy	:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node)
-{
-	int i, aux_status;
-	int bus = phy->ext_mdio_bus;
-	int phyaddr = phy->phy_addr;
-	int int_inf = phy->inf;
-	int status=0;
-
-	nlm_print("XMC_INIT_PHY \n ");
-
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); /* disable XLP AN */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
-
-	/* XMC board has INTFSEL[1:0] = 01 which selects fiber and power down modes*/
-
-	/* setup for SGMII-Copper mode */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	status = 0x7c00 | (2 << 1); /* SGMII mode, copper registers */
-	/*nlm_print("writing phyaddr %d reg 0x1c =0x%x \n", phyaddr, status); */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)));
-
-	/* Turn off Signal Detect Enable on 1000BASE-X side */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (0x5c00 | (1<<15)));
-
-	/* power up copper side*/
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
-	status &= ~(1<<11);
-	/*nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status); */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status); /* Normal Operation */
-	nlm_mdelay(100);
-
-	/* setup LED control */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x8801); /* spare control 1, enable link led mode */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB4E5); /* LED Selector 1, LED3 off, LED1 SLAVE (LINK) */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB83E); /* LED Selector 2, LED2 ACTIVITY, LED4 off */
-
-	/*switch to 1000Base-X registers mode*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN and power up SGMII side*/
-	nlm_mdelay(100);
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
-
-#if 1
-	/* wait up to 5 seconds for AN to complete on copper side */
-	i=0;
-	do {
-		nlm_mdelay(100);
-		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-		if (aux_status & 0x8000)
-			break;
-
-		i++;
-	}while(i<50);
-	xmc_phy_status(phy, node);
-#endif
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); /* Enable XLP AN */
-	return;
-}
-
-/**
-* @brief bcm_init_phy function initializes an external BROADCOM PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
-{
-	int bus = phy->ext_mdio_bus;
-	int phyaddr = phy->phy_addr;
-	int int_inf = phy->inf;
-	int status=0;
-	nlm_print("BCM_INIT_PHY \n ");
-
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); /* disable XLP AN */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
-
-#if 0
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, (status | (1<<15)| (0x1)));
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
-#endif
-
-	/*switch to 1000Base-X registers mode*/
-	/*refer mode control register in broadcom datasheet*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN*/
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); /* Enable XLP AN */
-	return;
-}
-
-/**
-* @brief mvl_init_phy function initializes an external MARVELL PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the MARVELL PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void mvl_init_phy(struct nlm_hal_ext_phy *phy, int node)
-{
-	int bus = phy->ext_mdio_bus;
-	int phyaddr = phy->phy_addr;
-	int int_inf = phy->inf;
-
-	/* device initialization */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x02);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 16, 0x0288);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x8000);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, 0x8000);
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x02); /* page 2 */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 26, 0x8000); /* AN bypass enable */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0); /* Disable MAC side AN */
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0x00); /* page 0 */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0xb000); /* Enable AN, Soft reset */
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, 0x9140); /* Enable AN, Soft reset */
-
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); /* selector field */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x4000); /* disable XLP AN */
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); /* soft reset */
-}
-
-/**
-* @brief nlm_hal_ext_phy_an function enables auto-negotiation on an interface.
-*
-* @param [in] node Node number
-* @param [in] inf Interface on which to enable auto-negotiation
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-void nlm_hal_ext_phy_an(int node, int inf)
-{
-	struct nlm_hal_ext_phy *this_phy=NULL;
-	this_phy = get_phy_info(inf);
-	if(!this_phy)
-		return;
-	this_phy->start_phy_an(this_phy, node);
-	return;
-}
-
-void nlm_hal_restart_an(int node, int inf)
-{
-	static int link_status[XLP_MAX_PORTS];
-	struct nlm_hal_ext_phy *phy=NULL;
-	int i = 0, int_inf, status, bus;
-
-	while(regs_ext_phys[i].inf != -1)
-	{
-		phy = get_phy_info(regs_ext_phys[i].inf);
-		if(!phy)
-	               	return;
-		if((phy->phy_idfer == 0x60c1 || phy->phy_idfer == 0xbcb2))/* only for broadcom phys*/
-		{
-			int_inf = phy->inf;
-			bus = phy->ext_mdio_bus;
-
-			status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
-			if(!(status & (1<<2)))
-			{
-				link_status[int_inf] = 1;
-
-				nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C, 0x7800);
-				status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
-
-				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
-				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-				nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
-
-			}
-			else if(link_status[int_inf])
-			{
-				link_status[int_inf] = 0;
-				nlm_hal_ext_phy_an(0, i);
-			}
-		}
-		i++;
-	}
-}
-/**
-* @brief xmc_start_an function enables auto-negotiation on XMC board external BROADCOM PHY.
-*
-* @param[in] phy	:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node)
-{
-	int status, count;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-	int int_inf = phy->inf;
-
-	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
-	/*Wait for XLP<->SGMII-PHY AN to be OK*/
-	count=0;
-        do {
-		nlm_mdelay(100);
-		count++;
-		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
-		if(status & (1<<5)){ /* check for autonegotiation to be completed */
-			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
-			xmc_phy_status(phy, node);
-			/*nlm_print("%s: exit\n", __func__); */
-			return;
-		}
-		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
-        }while(count<100);
-
-	nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf);
-	xmc_phy_status(phy, node);
-	return;
-}
-
-/**
-* @brief bcm_start_an function enables auto-negotiation on an external BROADCOM PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
-{
-	int status, count;
-	int int_inf = phy->inf;
-
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
-	/*Wait for XLP<->SGMII-PHY AN to be OK*/
-	count=0;
-        do {
-		nlm_mdelay(100);
-		count++;
-		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
-		if(status & (1<<5)){ /* check for autonegotiation to be completed */
-	/*		nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf); */
-			return;
-		}
-		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
-		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
-        }while(count<100);
-
-	/*nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf); */
-	return;
-}
-
-/**
-* @brief mvl_start_an function enables auto-negotiation on an external MARVELL PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the MARVELL PHY
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
-{
-        uint32_t i=0;
-        volatile uint16_t val, status, extstatus;
-#ifdef PHY_DEBUG
-        uint16_t speed, duplex = 0;
-#endif
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
-        val = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0);
-        val |= 0x1200;
-        nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0, val);
-
-#ifdef PHY_DEBUG
-	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
-#endif
-	i=0;
-        do {
-                status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 1);
-                extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
-		if (((status & 0x0024) == 0x0024) && (extstatus & 0x0400)) {
-			nlm_print("bus:%d phy:%d Autonegotiation ok:%X %X i:%d\n", bus, phyaddr, status, extstatus, i);
-			break;
-		}
-		nlm_mdelay(1);
-		i++;
-        }while(i<5000);
-        if(i==5000) nlm_print(" bus:%d phy:%d auto negotiation timeout!\n", bus, phyaddr);
-
-#ifdef PHY_DEBUG
-        switch(speed) {
-                case SPEED_10M:
-                        nlm_print("physpeed 10 Mbps\t");
-                        break;
-                case SPEED_100M:
-                        nlm_print("physpeed 100 Mbps\t");
-                        break;
-                case SPEED_1000M:
-                        nlm_print("physpeed 1000 Mbps\t");
-                        break;
-                default:
-                        nlm_print("unknown speed !!! \t");
-        }
-        ((duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
-	/*dump_phy_regs(inf); */
-#endif
-}
-
-int nlm_hal_status_ext_phy(int node, int inf, struct nlm_hal_mii_info* mii_info)
-{
-       struct nlm_hal_ext_phy *this_phy=NULL;
-       this_phy = get_phy_info(inf);
-       if(!this_phy)
-               return 0;
-       return this_phy->phy_get_status(this_phy, mii_info, node);
-}
-
-
-/**
-* @brief xmc_get_phy_status function returns the status of an interface from the XMC external BROADCOM PHY.
-*
-* @param[in] phy		:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param[out] speed		:Link speed
-* @param[out] duplex	:Link duplex status
-* @param [in] node Node number
-*
-* @return
-* 	- 1 - Link up, 0 - Link Down
-*
-* @ingroup hal_nae
-*
-*/
-static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
-{
-	int aux_status=0;
-	int status=0;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-	mii_info->phyaddr=phyaddr;
-	/*int int_inf = phy->inf; */
-
-
-	/*switch to Copper registers mode*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
-
-#if 0
-	/* start auto-negotiation on copper side */
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
-	status |= (1 << 9);
-	nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status );
-#endif
-
-#if 0
-	/* wait up to 5 seconds for AN to complete on copper side*/
-	i=0;
-	do {
-		nlm_mdelay(100);
-		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-		if (aux_status & 0x8000)
-			break;
-
-		i++;
-	}while(i<50);
-#endif
-	/* check the status */
-	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-	switch ((aux_status>>8) & 0x7){
-		case 0x7:
-			mii_info->speed = SPEED_1000M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x6:
-			mii_info->speed = SPEED_1000M;
-			mii_info->duplex = 0;
-		break;
-
-		case 0x5:
-			mii_info->speed = SPEED_100M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x3:
-			mii_info->speed = SPEED_100M;
-			mii_info->duplex = 0;
-		break;
-
-		case 0x2:
-			mii_info->speed = SPEED_10M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x1:
-			mii_info->speed = SPEED_10M;
-			mii_info->duplex = 0;
-		break;
-
-		default:
-			nlm_print("Unknown operating speed, auxstatus = 0x%04x\n", aux_status);
-		break;
-	}
-
-//#ifdef PHY_DEBUG
-	if(mii_info->speed==SPEED_1000M)
-		nlm_print("Configured with Speed  1000M");
-	if(mii_info->speed==SPEED_100M)
-		nlm_print("Configured with Speed 100M");
-	if(mii_info->speed==SPEED_10M)
-		nlm_print("Configured with Speed 10M");
-
-	((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
-//#endif
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	if(status & (1<<2)){
-		mii_info->link_stat = LINK_UP;
-		nlm_print("Link is up : %x\n", status);
-		xmc_phy_status(phy, node);
-		/*nlm_print("%s: exit\n", __func__); */
-		return 1;
-	}else{
-		mii_info->link_stat = LINK_DOWN;
-		nlm_print("Link is down : %x\n", status);
-		xmc_phy_status(phy, node);
-		/*nlm_print("%s: exit\n", __func__); */
-		return 0;
-	}
-}
-
-/**
-* @brief bcm_get_phy_status function returns the status of an interface from the external BROADCOM PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the BROADCOM PHY
-* @param [out] speed Link speed
-* @param [out] duplex Link duplex status
-* @param [in] node Node number
-*
-* @return
-* 	- 1 - Link up, 0 - Link Down
-*
-* @ingroup hal_nae
-*
-*/
-static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
-{
-	int aux_status=0;
-	int status=0;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-	mii_info->phyaddr=phyaddr;
-	/*int int_inf = phy->inf; */
-
-	bcm_start_an(phy, node);
-
-	/*switch to Copper registers mode*/
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
-	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
-	switch ((aux_status>>8) & 0x7){
-		case 0x7:
-			mii_info->speed = SPEED_1000M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x6:
-			mii_info->speed = SPEED_1000M;
-			mii_info->duplex = 0;
-		break;
-
-		case 0x5:
-			mii_info->speed = SPEED_100M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x3:
-			mii_info->speed = SPEED_100M;
-			mii_info->duplex = 0;
-		break;
-
-		case 0x2:
-			mii_info->speed = SPEED_10M;
-			mii_info->duplex = 1;
-		break;
-
-		case 0x1:
-			mii_info->speed = SPEED_10M;
-			mii_info->duplex = 0;
-		break;
-
-		default:
-			nlm_print("Unknown operating speed\n");
-		break;
-	}
-
-//#ifdef PHY_DEBUG
-	if(mii_info->speed==SPEED_1000M)
-		nlm_print("Configured with Speed  1000M");
-	if(mii_info->speed==SPEED_100M)
-		nlm_print("Configured with Speed 100M");
-	if(mii_info->speed==SPEED_10M)
-		nlm_print("Configured with Speed 10M");
-
-	((mii_info->duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
-//#endif
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-	if(status & (1<<2)){
-		mii_info->link_stat = LINK_UP;
-		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, status);
-		return 1;
-	}else{
-		mii_info->link_stat = LINK_DOWN;
-		nlm_print("bus:%d phy:%d Link is down : %x\n", bus, phyaddr, status);
-		return 0;
-	}
-}
-
-/**
-* @brief mvl_get_phy_status function returns the status of an interface from the external MARVELL PHY.
-*
-* @param [in] phy nlm_hal_ext_phy struct pointing to the MARVELL PHY
-* @param [out] speed Link speed
-* @param [out] duplex Link duplex status
-* @param [in] node Node number
-*
-* @return
-* 	- 1 - Link up, 0 - Link Down
-*
-* @ingroup hal_nae
-*
-*/
-static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, struct nlm_hal_mii_info* mii_info, int node)
-{
-	uint16_t extstatus;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
-
-	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
-        extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
-	mii_info->speed = (extstatus >> 14) & 0x3;
-        mii_info->duplex =  (extstatus >> 13) & 0x1;
-        mii_info->phyaddr=phyaddr;
-
-	if (extstatus & 0x0400) {
-		mii_info->link_stat = LINK_UP;
-		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, extstatus);
-		return 1;
-	}
-	else {
-		mii_info->link_stat = LINK_DOWN;
-		nlm_print("bus:%d phy:%d Link is down : %x\n",bus, phyaddr, extstatus);
-		return 0;
-	}
-
-}
-
-/**
-* @brief get_phy_info function returns PHY information from the external PHY of an interface.
-*
-* @param [in] inf Interface number
-*
-* @return
-* 	- Pointer to external phy information structure
-* 	- NULL if no registered external phy exists for inf
-*
-* @ingroup hal_nae
-*
-*/
-struct nlm_hal_ext_phy* get_phy_info(int inf)
-{
-	struct nlm_hal_ext_phy *phy_info = NULL;
-	/*search through scanned and registered phys*/
-	int reg_idx=0;
-	for(; reg_idx<MAX_PHYS; reg_idx++){
-		if(regs_ext_phys[reg_idx].inf==inf){
-			phy_info = regs_ext_phys + reg_idx;
-			return phy_info;
-		}
-	}
-	/*nlm_print("Interface could not be initialised for inf=0x%x\n", inf); */
-	return NULL;
-}
-
-/**
-* @brief register_phy function registers external PHY information for an interface.
-*
-* @param [in] node Node number
-* @param [in] inf Interface number
-* @param [out] hw_portid PHY address of the external PHY attached to inf
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-void register_phy(int node, int inf, int* hw_portid)
-{
-	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
-	int i = 0;
-	int phy_addr;
-#ifdef CONFIG_N511
-	int ext_mdio_bus;
-#endif
-	for(i=0; nae_cfg->num_ports; i++){
-		if(nae_cfg->ports[i].hw_port_id == inf)
-		break;
-	}
-#ifdef CONFIG_N511
-        /* Hardcode here for now, rather than generating a new dts/dtb */
-        if (inf == 0x10) {
-          /* override dtb */
-          nae_cfg->ports[i].ext_phy_addr = 0x10;
-          nae_cfg->ports[i].ext_phy_bus = 0;
-        }
-        if (inf == 0x11) {
-          /* override dtb */
-          nae_cfg->ports[i].ext_phy_addr = 0x10;
-          nae_cfg->ports[i].ext_phy_bus = 1;
-        }
-	ext_mdio_bus = nae_cfg->ports[i].ext_phy_bus;
-#endif
-	phy_addr = nae_cfg->ports[i].ext_phy_addr;
-	*hw_portid = phy_addr;
-	/* make a inf and hw_port id pair*/
-	for(i=0; i<reg_num_phys; i++){
-		if((*hw_portid) == regs_ext_phys[i].phy_addr){
-#ifdef CONFIG_N511
-                    if (ext_mdio_bus ==  regs_ext_phys[i].ext_mdio_bus) {
-                        regs_ext_phys[i].inf = inf;
-                        return;
-                    }
-#else
-			regs_ext_phys[i].inf = inf;
-			return;
-#endif
-		}
-	}
-	*hw_portid = -1;
-	nlm_print("Could not find the given interface\n");
-}
-
-/**
-* @brief sgmii_scan_phys function scans all possibel PHYs on the external MDIO busses and logs active ports.
-*
-* @param [in] node Node number
-*
-* @return
-* 	- none
-*
-* @ingroup hal_nae
-*
-*/
-void sgmii_scan_phys(int node)
-{
-	int phyid, inf;
-	int j;
-	int reg_idx=0;
-
-	/*init regs_ext_phys data*/
-	for (j=0; j<MAX_PHYS; j++){
-		regs_ext_phys[j].phy_get_status =  NULL;
-		regs_ext_phys[j].start_phy_an =  NULL;
-		regs_ext_phys[j].ext_phy_init =  NULL;
-		regs_ext_phys[j].phy_addr = 0xff;
-		regs_ext_phys[j].inf = -1;
-	}
-	/* scan all PHYs available on both ext MDIOs */
-	/* check with phys IDs against registered phys */
-
-	/*BUS1*/
-	if(!(is_nlm_xlp3xx() || is_nlm_xlp2xx())){ /*Only one mdio controller*/
-		nlm_print("Scanning MDIO external BUS1----\n");
-		for(inf=0; inf<31; inf++){
-			phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 1, BLOCK_7, LANE_CFG, inf, 3);
-			for(j=0; j < sizeof(known_ext_phys)/ sizeof(struct nlm_hal_ext_phy); j++){
-				if(phyid == known_ext_phys[j].phy_idfer){
-					regs_ext_phys[reg_idx].ext_mdio_bus = 1;
-					regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
-					regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
-					regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
-					regs_ext_phys[reg_idx].phy_addr = inf;
-					regs_ext_phys[reg_idx].inf = -1;
-					regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
-					/*nlm_print("Found port with 1st bus and phy_addr =0x%x phy-idfer =0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid); */
-					reg_idx++;
-				}
-			}
-
-		}
-	}
-	nlm_print("Scanning MDIO external BUS0----\n");
-	/*BUS0*/
-	for(inf=0; inf<31; inf++){
-		phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, inf, 3);
-		for(j=0; j < sizeof(known_ext_phys)/ sizeof(struct nlm_hal_ext_phy); j++){
-			if(phyid == known_ext_phys[j].phy_idfer){
-
-				regs_ext_phys[reg_idx].ext_mdio_bus = 0;
-				regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
-				regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
-				regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
-				regs_ext_phys[reg_idx].phy_addr = inf;
-				regs_ext_phys[reg_idx].inf = -1;
-				regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
-				/*nlm_print("Found port with 0th bus and phy_addr =0x%x phy-idfer=0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid); */
-				reg_idx++;
-			}
-		}
-
-	}
-
-	reg_num_phys =  reg_idx;
-	nlm_print("Total PHYs found = %d\n", reg_idx);
-}
 
 /* CDE SUPPORT
  */
@@ -1814,13 +918,13 @@ void nlm_hal_set_sae_freq(int node, int freq)
 }
 
 
-int nlm_hal_get_sae_chip_feature(void )
+int nlm_hal_get_chip_feature(void )
 {
 	int chip_features;
 	if( is_nlm_xlp2xx())
 		chip_features = (INIT_DONE | ZUC | DES3_KEY_SWAP);
 	else
-		chip_features = INIT_DONE;
+		chip_features = INIT_DONE;	
 	return chip_features;
 }
 
@@ -1940,131 +1044,41 @@ uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module)
 		pval = ((unsigned int *)fdt_getprop(fdt, nodeoffset, module, &plen));
 		if (pval != NULL) {
 			flag = fdt32_to_cpu(*(unsigned int *)pval);
-			/*nlm_print("owner flag for %s is %#x.\n", module, flag); */
+			//nlm_print("owner flag for %s is %#x.\n", module, flag);
 		}
 		else {
 			flag = 0;
-			/* nlm_print("ERROR: pval is NULL.\n"); */
+			// nlm_print("ERROR: pval is NULL.\n");
 		}
 	}
 	else
 	{
 		flag = 0;
-		/* nlm_print("ERROR: unable to find nodeoffset.\n"); */
+		// nlm_print("ERROR: unable to find nodeoffset.\n");
 	}
 
 	return flag;
 }
 
 
-void nlm_hal_set_rsa_cge(int node, int enable)
-{
-#define NLM_RSA_CFG_REG 0x40
-	uint32_t d32 = nlm_hal_read_rsa_reg(NLM_RSA_CFG_REG);
-	if(enable)
-		d32 |= 1<<9;
-	else
-		d32 &= ~(1<<9);
-	nlm_hal_write_rsa_reg(NLM_RSA_CFG_REG, d32);
-}
-
-#define NLM_SAE_ENGINE_SELECT_REG_0 0x41
-void nlm_hal_set_sae_engine_sel(int node)
-{
-	int i, n;
-	if(is_nlm_xlp2xx()) {
-		return;
-	}
-	if(is_nlm_xlp3xx())
-		n = 1;
-	else
-		n = 8;
-
-	for (i = 0; i < n; i++) {
-		nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, 0x00FFFFFF);
-	}
-}
-
-#define NLM_RSA_ENGINE_SELECT_REG_0 0x41
-void nlm_hal_set_rsa_engine_sel(void)
-{
-	int i, n;
-	unsigned int val;
-	if(is_nlm_xlp2xx()) {
-		return;
-	}
-	if(is_nlm_xlp3xx()) {
-		n = 1;
-		val = 0xffff;
-	} else {
-		n = 3;
-		val = 0x7ffffff;
-	}
-	for (i = 0; i < n; i++) {
-		nlm_hal_write_rsa_reg(NLM_RSA_ENGINE_SELECT_REG_0 + i, val);
-	}
-}
-
-void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
-{
-
-	if(is_nlm_xlp3xx()) {
-		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
-		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
-	} else if(is_nlm_xlp2xx()) {
-		*vcbase = XLP_2XX_CRYPTO_VC_BASE;
-		*vclimit = XLP_2XX_CRYPTO_VC_LIMIT;
-	} else {
-		*vcbase = XLP_CRYPTO_VC_BASE;
-		*vclimit = XLP_CRYPTO_VC_LIMIT;
-	}
-}
-
-void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
-{
-	if(is_nlm_xlp3xx()) {
-		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
-		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
-	} else if(is_nlm_xlp2xx()) {
-		*vcbase  = XLP_2XX_RSA_ECC_VC_BASE;
-		*vclimit = XLP_2XX_RSA_ECC_VC_LIMIT;
-	} else {
-		*vcbase = XLP_RSA_ECC_VC_BASE;
-		*vclimit = XLP_RSA_ECC_VC_LIMIT;
-
-	}
-}
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
 EXPORT_SYMBOL(nlm_hal_is_xlp_a0);
 EXPORT_SYMBOL(nlm_hal_is_xlp_le);
-EXPORT_SYMBOL(sgmii_scan_phys);
 EXPORT_SYMBOL(nlm_hal_get_dev_base);
 EXPORT_SYMBOL(nlm_hal_set_sae_freq);
-EXPORT_SYMBOL(nlm_hal_get_sae_chip_feature);
+EXPORT_SYMBOL(nlm_hal_get_chip_feature);
 EXPORT_SYMBOL(nlm_hal_set_rsa_freq);
 EXPORT_SYMBOL(nlm_hal_set_dtre_freq);
 EXPORT_SYMBOL(nlm_hal_set_cde_freq);
 
 EXPORT_SYMBOL(nlm_node_cfg);
 
-EXPORT_SYMBOL(nlm_hal_init_ext_phy);
-EXPORT_SYMBOL(nlm_hal_ext_phy_an);
-EXPORT_SYMBOL(nlm_hal_status_ext_phy);
-EXPORT_SYMBOL(nlm_hal_restart_an);
-EXPORT_SYMBOL(register_phy);
 EXPORT_SYMBOL(get_dom_owner_mask);
 EXPORT_SYMBOL(nlm_hal_sata_init);
 EXPORT_SYMBOL(nlm_hal_sata_intr_setup);
 EXPORT_SYMBOL(nlm_hal_sata_intr_ack);
 EXPORT_SYMBOL(nlm_hal_get_fdt_freq);
-EXPORT_SYMBOL(get_phy_info);
-
-EXPORT_SYMBOL(nlm_hal_set_rsa_cge);
-EXPORT_SYMBOL(nlm_hal_set_sae_engine_sel);
-EXPORT_SYMBOL(nlm_hal_set_rsa_engine_sel);
-EXPORT_SYMBOL(nlm_hal_get_crypto_vc_nums);
-EXPORT_SYMBOL(nlm_hal_get_rsa_vc_nums);
 #endif
-- 
1.7.1

