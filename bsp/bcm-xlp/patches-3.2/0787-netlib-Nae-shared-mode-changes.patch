From e665c450d679e028d4c3ec1359f319ee32b8b003 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Fri, 6 Sep 2013 09:52:51 +0530
Subject: netlib:Nae shared mode changes

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index e0ec9bc..db1eca9 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -64,25 +64,32 @@
 #define XLP9XX_NCPUS_PER_NODE	64
 #define XLP_NCPUS_PER_NODE	NLM_NCPUS_PER_NODE
 
-#define NAEV1_SH_LCPU_TO_MAP_SZ                 24 /* in integers to map 96 cpus*/
-#define NAEV1_SH_LCPU_TO_MAP_SNG_VAL_SZ         8 /* in bits, can cover 6 cpus in single entry */
-#define NAEV1_SH_LCPU_TO_MAP_NVALS_PER_ENTRY    4 /* with 5 bits, can occupy 6  */
-
-#define NLM_NAE_SH_LCPU_TO_MAP_SZ		6 /* in integers */
-#define NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ  	5 /* in bits, can cover 6 cpus in single entry */
-#define NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY 	6 /* with 5 bits, can occupy 6  */
-
 #define MAX_PORTS_PERBLOCK     4
 #define MAX_POE_DV             16
 
+#define NLM_NAE_LNX_SHINFO_FL_VALID     0x01
+#define NLM_NAE_LNX_SHINFO_FL_JUMBO_EN  0x02
+
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF 0
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_MASK 0xff
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_OFF 8 //Regular fifo offset
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_MASK 0xff
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_OFF 16 //Jumbo fifo offset
+#define NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_MASK 0xff
+
+
 struct nlm_nae_shinfo {
 	int valid;
 	int rxvc;
 	int domid;
-	/* logical cpu to physical cpu map */
-	unsigned int lcpu_2_pcpu_map[NLM_NAE_SH_LCPU_TO_MAP_SZ]; 
-	/* cpu to freein fifo map */
-	unsigned int cpu_2_freeinfifo_map[NLM_NAE_SH_LCPU_TO_MAP_SZ];
+	int num_cpus;
+	unsigned int freein_fifo_mask;
+	int owner_replenish;
+	char *paddr_info;
+	int paddr_info_len;
+	char *desc_info;
+	int desc_info_len;
+	unsigned int *fwd_info;
 };
 
 enum higig_mode{
@@ -380,6 +387,50 @@ enum if_type {
         RXAUI_IF      = 6,
 };
 
+static inline int derive_cpu_to_freein_fifo_map(
+		int frin_total_queue,
+		int num_cpus_per_node,
+		unsigned int *mem,
+		int memsize,
+		unsigned int *lcpu_2_pcpu,
+		unsigned int freein_fifo_mask, 
+		unsigned int *lcpu_2_freein_fifo_map)
+{
+        int i=0, j =0, filled = 0, index = 0, pcpu, fifo;
+		unsigned int *pcpu_2_fifo;
+
+		if(memsize < (num_cpus_per_node * sizeof(unsigned int)))
+			return -1;
+
+		pcpu_2_fifo = mem;
+
+        while(filled < num_cpus_per_node) {
+                for(j = 0; j < frin_total_queue && filled < num_cpus_per_node;) {
+                        if(!(freein_fifo_mask & (1 << j))) {
+                                j++;
+                                continue;
+                        }
+
+                        pcpu = lcpu_2_pcpu[i];
+                        if(pcpu_2_fifo[pcpu] & 0x80) {
+                                fifo = pcpu_2_fifo[pcpu] & 0x1f;
+                        } else {
+                                fifo = j;
+                                pcpu_2_fifo[pcpu] = 0x80 | fifo;
+                                j++;
+                        }
+                        lcpu_2_freein_fifo_map[i] = fifo;
+                        i += NLM_NUM_THREADS_PER_CORE;
+                        if(i >= num_cpus_per_node)
+                                i = ++index;
+                        filled++;
+                }
+        }
+		return 0;
+}
+
+
+
 extern nae_t *xlp_nae[NLM_MAX_NODES][MAX_NAE_PERNODE];
 extern net_port_t **cntx2netport[NLM_MAX_NODES][MAX_NAE_PERNODE];
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 000b471..217ba27 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -46,7 +46,7 @@ void *(*netsoc_lib_contig_malloc)(uint32_t align, uint32_t size);
 void (*netsoc_lib_contig_free)(void *buf);
 uint64_t (*netsoc_lib_virttophys)(void *);
 void *(*netsoc_lib_phystovirt)(uint64_t);
-unsigned int netsoc_api_dbglvl = 0xff; // NETSOC_APIDBG_DEFAULT | NETSOC_APIDBG_GLOBAL;
+unsigned int netsoc_api_dbglvl = 0xfb; // NETSOC_APIDBG_DEFAULT | NETSOC_APIDBG_GLOBAL;
 
 int (*const_func_list[])(void) = {
 register_marvell_phy,
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 409fd07..4df3fca 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -56,55 +56,6 @@
 
 #define MAX_PROP_LEN 30
 
-
-static void fdt_derive_cpu_to_freein_fifo_map(nae_t *nae,
-                unsigned int phys_cpu_map,
-                unsigned int freein_fifo_mask, unsigned int *cpu_2_freein_fifo_map)
-{
-        int i=0, j =0, filled = 0, index = 0, pcpu, fifo;
-        unsigned char lcpu_2_pcpu[XLP_NCPUS_PER_NODE], pcpu_2_fifo[NLM_NCPUS_PER_NODE];
-        int frin_total_queue = __netsoc_get_frin_total_queue(nae);
-
-        if((phys_cpu_map == 0) || (freein_fifo_mask == 0))
-                return;
-
-        memset(lcpu_2_pcpu, 0, sizeof(lcpu_2_pcpu));
-        memset(pcpu_2_fifo, 0, sizeof(pcpu_2_fifo));
-
-        while(i < XLP_NCPUS_PER_NODE){
-                for(j=0; j < XLP_NCPUS_PER_NODE && i < NLM_NCPUS_PER_NODE; j++){
-                        if(!(phys_cpu_map & (1 << j)))
-                                continue;
-                        lcpu_2_pcpu[i] = j;
-                        i++;
-                }
-        }
-        i = 0;
-        while(filled < XLP_NCPUS_PER_NODE) {
-                for(j = 0; j < frin_total_queue && filled < XLP_NCPUS_PER_NODE;) {
-                        if(!(freein_fifo_mask & (1 << j))) {
-                                j++;
-                                continue;
-                        }
-
-                        pcpu = lcpu_2_pcpu[i];
-                        if(pcpu_2_fifo[pcpu] & 0x80) {
-                                fifo = pcpu_2_fifo[pcpu] & 0x1f;
-                        } else {
-                                fifo = j;
-                                pcpu_2_fifo[pcpu] = 0x80 | fifo;
-                                j++;
-                        }
-                        cpu_2_freein_fifo_map[i] = fifo;
-                        i += NLM_NUM_THREADS_PER_CORE;
-                        if(i >= XLP_NCPUS_PER_NODE)
-                                i = ++index;
-                        filled++;
-                }
-        }
-}
-
-
 /* Returns 1 if the domain is the nae owner,
  Returns 0 otherwise */
 int fdt_get_dom_nae_node_ownership(void *fdt, int dom_id, nae_t *nae)
@@ -399,6 +350,7 @@ static void xlp9xx_fdt_derive_cpu_to_freein_fifo_map(nae_t *nae,
 
 int xlp9xx_prepare_nae_shared_info(void *fdt, int dom_id, nae_t *nae_cfg)
 {
+#if 0
         char dom_node_str[128];
         int nodeoffset;
         unsigned int *pval;
@@ -538,124 +490,246 @@ err:
                 cnt++;
                 goto start_for_dom;
         }
+#endif
         return 0;
 }
 
+static inline int get_num_cpus_per_node(void)
+{
+	
+	if (is_nlm_xlp9xx())
+		return  XLP9XX_NCPUS_PER_NODE;
+	else
+		return XLP_NCPUS_PER_NODE;
+}
+
+/* nbits : number of valid bits after shifting
+*  sbit : starting bit number  */
+static inline void right_shift_int_array(unsigned int *val, int sbit, int nbits)
+{
+	int l_off = sbit/32;
+	int b_off = sbit % 32;
+	int i;
+	int last = 0, hit = 0;
+	for(i = l_off; i < (l_off + nbits/32 + ((nbits % 32) != 0)); i++) {
+		if(last) {
+			val[last - 1] |= ((val[i] & ((1 << b_off) - 1)) << (32 - b_off));
+		}
+		val[last] = val[i] >> b_off;
+		hit = last;
+		last++;
+	}
+	if((nbits % 32) != 0) {
+		val[hit] = val[hit] & ((1 << (nbits % 32)) - 1);
+	}
+}
 
-int prepare_nae_shared_info(void *fdt, int dom_id, nae_t *nae_cfg)
+/* called only if the shared domain are exists
+ Extracts the paddr and desc information */
+static int retrieve_shared_freein_fifo_info(void *fdt,
+		int shared_dom_id,
+		struct nlm_nae_shinfo *shinfo)
+{
+	char nae_node_str[64];
+	char *pbuf;
+	const char *paddrname =  "freein-fifo-replenish-addr-info";
+	const char *pinfoname =  "freein-fifo-replenish-desc-info";
+	const char *ownerrepl = "freein-fifo-replenish-by-owner";
+	int plen, pnode;
+
+	shinfo->owner_replenish = 0;
+	sprintf(nae_node_str, "/doms/dom@%d/nae", shared_dom_id);
+
+	pnode = fdt_path_offset(fdt, nae_node_str);
+	if (pnode < 0) {
+		return -1;
+	}
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, ownerrepl, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	shinfo->owner_replenish = fdt32_to_cpu(*(unsigned int *)pbuf);
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, paddrname, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	shinfo->paddr_info = pbuf;
+	shinfo->paddr_info_len = plen;
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, pinfoname, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	shinfo->desc_info = pbuf;
+	shinfo->desc_info_len = plen;
+
+	return 0;
+}
+
+static int prepare_nae_shared_info(void *fdt, int domid, nae_t *nae_cfg)
 {
         char dom_node_str[128];
         int nodeoffset;
-        unsigned int *pval;
+        unsigned int *pval, mask = 0x0;
         int plen, i, j;
-        int pos, bitoff, max;
-        unsigned int map[NLM_MAX_NODES], fmask[NLM_MAX_NODES], node = nae_cfg->node;
         struct nlm_nae_shinfo shinfo;
         static int shdomains[NLM_NAE_MAX_SHARED_DOMS], shdom_extracted = 0;
-        int domid = dom_id, cnt = 0;
+        unsigned int *lcpu_2_pcpu, *lcpu_2_fifo;
+        unsigned int *cpu_mask = NULL, fifo_mask[NLM_MAX_NODES];
+		unsigned int *mem = NULL, *fmem, *fwd_info_mem;
+		int cnt = 0;
+		int node = nae_cfg->node;
+		int num_cpus_per_node = get_num_cpus_per_node();
         int frin_total_queue = __netsoc_get_frin_total_queue(nae_cfg);
-        unsigned int lcpu_2_pcpu[XLP_NCPUS_PER_NODE], cpu_2_fifo[XLP_NCPUS_PER_NODE];
+		int max_cpu_idx = (num_cpus_per_node/32) + ((num_cpus_per_node % 32) != 0);
+		
+
+		mem = (unsigned int *)netsoc_api_malloc(num_cpus_per_node * 
+				sizeof(unsigned int) * 3);
+		if(!mem) {
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : Memory limit exceeded\n");
+			return -1;
+		}
+
+		lcpu_2_pcpu = mem;
+		lcpu_2_fifo = lcpu_2_pcpu + num_cpus_per_node;
+		fmem = lcpu_2_fifo + num_cpus_per_node;
+
+		fwd_info_mem = (unsigned int *)netsoc_api_malloc(num_cpus_per_node * 
+				sizeof(unsigned int) * (NLM_NAE_MAX_SHARED_DOMS + 1));
+		if(!fwd_info_mem) {
+				netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : Memory limit exceeded..\n");
+				netsoc_api_free(mem);
+				return -1;
+		}
 
         if(!shdom_extracted) {
                 for(i = 0; i < NLM_NAE_MAX_SHARED_DOMS; i++)
                         shdomains[i] = -1;
-                get_dom_nae_property(fdt, dom_id, nae_cfg->nae_id, "sh-domains", (unsigned int *)shdomains, sizeof(shdomains));
+                get_dom_nae_property(fdt, domid, nae_cfg->nae_id, "sh-domains", 
+						(unsigned int *)shdomains, sizeof(shdomains));
                 shdom_extracted = 1;
         }
 
+#ifdef NAE_SH_INFO_DBG
+		netsoc_api_print(NETSOC_APIDBG_FDT, "mem %lx lcp %lx lf %lx fm %lx fwd %lx maxcpuidx %d ncpu %d node %d\n", (long)mem,
+				(long)lcpu_2_pcpu, (long)lcpu_2_fifo, (long)fmem, (long)fwd_info_mem, max_cpu_idx,
+				num_cpus_per_node, node);
+#endif
 
 start_for_dom:
-        map[node] = 0;
-        for(i = 0; i < NLM_MAX_NODES; i++)
-                fmask[i] = (1 << frin_total_queue) - 1;/* Ownes all fifos by default*/
+		memset((char *)&shinfo, 0, sizeof(shinfo));
+		shinfo.fwd_info = fwd_info_mem;
+		fwd_info_mem += num_cpus_per_node;
+		memset((char *)lcpu_2_pcpu, 0, num_cpus_per_node * sizeof(unsigned int));
+        memset((char *)shinfo.fwd_info, 0, num_cpus_per_node * sizeof(unsigned int));
 
-        memset((char *)&shinfo, 0, sizeof(shinfo));
-        memset(lcpu_2_pcpu, 0, sizeof(lcpu_2_pcpu));
+		/* Ownes all fifos by default, only 1 entry is considered now */
+        fifo_mask[node] = (1 << frin_total_queue) - 1;
 
         sprintf(dom_node_str, "/doms/dom@%d/cpu", domid);
         nodeoffset = fdt_path_offset(fdt, dom_node_str);
+
         if(nodeoffset >= 0) {
+				int max;
                 pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "onlinemask", &plen);
                 if(pval != NULL) {
-                        if(plen > sizeof(map))
-                                plen = sizeof(map);
-                        /* cpu mask is from msb to lsb, but we require in lsb to msb */
-                        max = (plen / sizeof(unsigned int)) - 1;
-                        for(i = 0; i < plen / sizeof(unsigned int); i++, max--)
-                                map[i] = fdt32_to_cpu(pval[max]);
-                }
+					if(plen < ((max_cpu_idx + 1) * NLM_MAX_NODES * sizeof(unsigned int)))
+						max = (max_cpu_idx + 1) * NLM_MAX_NODES * sizeof(unsigned int);
+					else
+						max = plen;
+					cpu_mask = (unsigned int *)netsoc_api_malloc(max);
+					if(!cpu_mask) {
+						netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : Onlinemask memalloc, size %d\n", max);
+						goto err;
+					}
+					memset(cpu_mask, 0, max);
+					/* cpu mask is from msb to lsb, but we require in lsb to msb */
+					max = (plen / sizeof(unsigned int)) - 1;
+					for(i = 0; i < plen / sizeof(unsigned int); i++, max--)
+						cpu_mask[i] = fdt32_to_cpu(pval[max]);
+					right_shift_int_array(cpu_mask, node * num_cpus_per_node, num_cpus_per_node);
+				}
                 pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-vc", &plen);
                 if(pval)
                         shinfo.rxvc = fdt32_to_cpu(pval[0]);
-                else
+                else {
+						netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : nae-rx-vc get failed, plen %d\n", plen);
                         goto err;
+				}
         }
 
         /* Extract free in fifo mask mask */
-        get_dom_nae_property(fdt, domid, nae_cfg->nae_id, "freein-fifo-mask", fmask, sizeof(fmask));
+        get_dom_nae_property(fdt, domid, nae_cfg->nae_id, "freein-fifo-mask", 
+				fifo_mask, sizeof(fifo_mask));
 
 #ifdef NAE_SH_INFO_DBG
-        netsoc_api_print(NETSOC_APIDBG_FDT,"%s domid %d node %d cpumask %x fmask %x\n", __FUNCTION__, domid, node,
-                        map[node], fmask[node]);
+        netsoc_api_print(NETSOC_APIDBG_FDT,
+				"%s domid %d node %d cpumask %x:%x:%x fmask %x:%x\n", 
+				__FUNCTION__, domid, node,
+				cpu_mask[0], cpu_mask[1], cpu_mask[2], fifo_mask[0], fifo_mask[1]);
 #endif
 
+		/* if no cpus or fifos */
+        if(!fifo_mask[node])
+			goto err;
+		for(i = 0; i < max_cpu_idx ; i++) 
+			mask |= cpu_mask[i];
+		if(!mask)
+			goto err;
+
+
+		i = 0;
+		while(i < num_cpus_per_node){
+			for(j=0; j < num_cpus_per_node && i < num_cpus_per_node; j++) {
+				if(!(cpu_mask[j/32] & (1 << (j % 32))))
+					continue;
+				shinfo.fwd_info[i] = (j << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF);
+				lcpu_2_pcpu[i] = j;
+				i++;
+			}
+		}
 
-        if(!(map[node] && fmask[node]))
-                goto err;
-
-        if(map[node]) {
-                i = 0;
-                while(i < XLP_NCPUS_PER_NODE){
-                        for(j=0; j < XLP_NCPUS_PER_NODE && i < XLP_NCPUS_PER_NODE; j++){
-                                if(!(map[node] & (1 << j)))
-                                        continue;
-                                pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
-                                bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) *
-                                        NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
-                                shinfo.lcpu_2_pcpu_map[pos] |= (j << bitoff);
-                                lcpu_2_pcpu[i] = j;
-                                i++;
-                        }
-                }
+		/* We need to avoid usage same fifo in different cores if possible. 
+		*  Also the filling should  be physical cpu id based, as the application 
+		*  knows only phys cpu id 
+		*/
+		memset(fmem, 0, num_cpus_per_node * sizeof(unsigned int));
+		if(derive_cpu_to_freein_fifo_map(frin_total_queue, num_cpus_per_node,
+			   fmem, num_cpus_per_node * sizeof(unsigned int),
+			   lcpu_2_pcpu, fifo_mask[node], lcpu_2_fifo) != 0) {
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Error : cpu to freein-fifo-mapping failed\n");
+			goto err;
+		}
 
-#ifdef NAE_SH_INFO_DBG
-                for(i = 0; i < XLP_NCPUS_PER_NODE; i++) {
-                        pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
-                        bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) *
-                                NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
-                        netsoc_api_print(NETSOC_APIDBG_FDT,"domid %d node %d lcpu %d pcpu %d (%d)\n", domid,
-                                        node, i, (shinfo.lcpu_2_pcpu_map[pos] >> bitoff) & 0x1f, lcpu_2_pcpu[i]);
-                }
-#endif
-        }
+		for(i = 0; i < num_cpus_per_node; i++) {
+			shinfo.fwd_info[i] |= (lcpu_2_fifo[i] << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_OFF);
+		}
 
-              /* We need to avoid usage same fifo in different cores if possible. Also the filling should
-        be physical cpu id based, as the application knows only phys cpu id
-         */
-        if(fmask[node]) {
-                fdt_derive_cpu_to_freein_fifo_map(nae_cfg, map[nae_cfg->node], fmask[nae_cfg->node], cpu_2_fifo);	//FIXME
-                for(i = 0; i < XLP_NCPUS_PER_NODE; i++) {
-                        pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
-                        bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) *
-                                NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
-                        shinfo.cpu_2_freeinfifo_map[pos] |= (cpu_2_fifo[i] << bitoff);
-                }
 #ifdef NAE_SH_INFO_DBG
-                for(i = 0; i < XLP_NCPUS_PER_NODE; i++) {
-                        pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
-                        bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) *
-                                NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
-                        netsoc_api_print(NETSOC_APIDBG_FDT,"domid %d node %d lcpu %d rxfifo %d\n", domid,
-                                        node, i, (shinfo.cpu_2_freeinfifo_map[pos] >> bitoff) & 0x1f);
-                }
+		for(i = 0; i < num_cpus_per_node; i++) {
+			netsoc_api_print(NETSOC_APIDBG_FDT,"domid %d node %d lcpu %d pcpu %d rxfifo %d\n", domid,
+					node, i, 
+					(shinfo.fwd_info[i] >> NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF) & 0xff ,
+					(shinfo.fwd_info[i] >> NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_OFF) & 0xff);
+		}
 #endif
-
-        }
+		
+		retrieve_shared_freein_fifo_info(fdt, domid, &shinfo);
 
         shinfo.domid = domid;
         shinfo.valid = 1;
-        memcpy((char *)&nae_cfg->shinfo[cnt], (char *)&shinfo, sizeof(shinfo));
+		shinfo.num_cpus = num_cpus_per_node;
+		shinfo.freein_fifo_mask = fifo_mask[node];
+
 err:
+        memcpy((char *)&nae_cfg->shinfo[cnt], (char *)&shinfo, sizeof(shinfo));
+		if(cpu_mask) {
+			netsoc_api_free(cpu_mask);
+			cpu_mask = NULL;
+		}
 
         while(cnt < NLM_NAE_MAX_SHARED_DOMS) {
                 if((domid = shdomains[cnt]) >= 0)
@@ -666,6 +740,9 @@ err:
                 cnt++;
                 goto start_for_dom;
         }
+		if(mem)
+			netsoc_api_free(mem);
+
         return 0;
 }
 
@@ -1501,9 +1578,6 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 	fdt_get_dom_nae_node_ownership(fdt, dom_id, nae);
 	fdt_extract_dom_nae_node_freein_fifo_info(fdt, dom_id, nae);
 
-        if (is_nlm_xlp9xx())
-           xlp9xx_prepare_nae_shared_info(fdt, dom_id, nae);
-        else
 	   prepare_nae_shared_info(fdt, dom_id, nae);
 
         fdt_parse_naecpuvc_config(fdt, dom_id, nae);
@@ -1518,4 +1592,3 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 	return 0;
 }
 
-
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index f31ba13..15afe85 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -37,7 +37,7 @@
 #include "ext_phy.h"
 #include "xlp9xx_sys.h"
 
-static unsigned int ucore_shared_scratch[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][128];
+static unsigned int ucore_shared_scratch[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][256];
 static unsigned int ucore_shared_scratch_words[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE];
 
 
@@ -475,7 +475,7 @@ int __netsoc_write_ucore_shared_mem(nae_t *nae, unsigned int *data, uint32_t wor
 	nae_id = nae->nae_id;
 
 	end =  ucore_shared_scratch_words[node][nae_id] + words;
-	if(end > 128)
+	if(end > 256)
 		return -1;
 
 	for (i=ucore_shared_scratch_words[node][nae_id]; i<end; ++i) {
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index 27cada9..0dea189 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -5833,6 +5833,7 @@ void nlm_hal_derive_cpu_to_freein_fifo_map(int node,
 static int prepare_nae_shared_info(void *fdt, int dom_id, int node, 
 		struct nlm_hal_nae_config *nae_cfg)
 {
+#if 0
 	char dom_node_str[128];
 	int nodeoffset;
 	unsigned int *pval;
@@ -5954,6 +5955,7 @@ err:
 		cnt++;
 		goto start_for_dom;
 	}
+#endif
 	return 0;
 }
 
-- 
1.7.1

