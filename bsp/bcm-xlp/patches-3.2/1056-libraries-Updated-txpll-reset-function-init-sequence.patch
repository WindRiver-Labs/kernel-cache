From 84ac76c290e9bb05712dd477769b1b02b0a0517a Mon Sep 17 00:00:00 2001
From: Anshu Kumari <anshuk@broadcom.com>
Date: Wed, 10 Dec 2014 14:07:53 +0530
Subject: libraries : Updated txpll reset function init sequence

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index 02e4ee7..745c6eb 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -622,7 +622,7 @@ static inline uint8_t __netsoc_read_pma_reg(nae_t *nae, int block, int lane_ctrl
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
         regval = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        regval |= PHY_LANE_CTRL_RST;
+       // regval |= PHY_LANE_CTRL_RST;
         regval |= PHY_LANE_CTRL_CMD_READ;
         regval = (regval & 0xffff0000);
         netsoc_write_mac_reg(mac_base, lane_ctrl, regval
@@ -645,7 +645,7 @@ static inline void __netsoc_write_pma_reg(nae_t *nae, int block, int lane_ctrl,
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
         regval = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        regval |= PHY_LANE_CTRL_RST;
+       // regval |= PHY_LANE_CTRL_RST;
         regval &= ~(PHY_LANE_CTRL_CMD_READ);
         regval = (regval & 0xffff0000) ;
         netsoc_write_mac_reg(mac_base, lane_ctrl, regval
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 8900915..c2eefa2 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -273,96 +273,114 @@ void xlp8xx_ax_lane_reset_txpll(nae_t *nae, int block, int lane_ctrl, int mode)
 static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t lane_ctrl, uint32_t mode)
 {
         uint32_t val = 0;
-        int rext_sel = 0;
+        int rext_sel = 0, i;
         int count=0;
         int count_max=1000;
-	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-
+		uint32_t val_temp = 0;
+		uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
         netsoc_api_print(NETSOC_APIDBG_PORT,"node %d block %d lane_ctrl %x \n",nae->node, block, lane_ctrl);
 
-        /* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
-         * skip lane 1 & 3 by setting lane_inc = 2
-         */
-        if(mode == PHYMODE_RXAUI && (lane_ctrl%2))
-        {
-                netsoc_api_print(NETSOC_APIDBG_PORT, "mode is %x so function is returning\n", mode);
-                return 0;
-        }
-
-        if(lane_ctrl != 4)
-                rext_sel = (1 << 23);
-
-        netsoc_api_print(NETSOC_APIDBG_PORT,"Before register reset de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, lane_ctrl));
-
-        val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-
-        if(mode != PHYMODE_SGMII){
-                val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUII*/
-        }
-
-        val |= 0x100000 | (mode << PHY_LANE_CTRL_PHYMODE_POS);  /* Bit20: serdes reg reset Storm & Eagle B0 */
-        val &= ~(0x20000);
-        netsoc_write_mac_reg(mac_base, lane_ctrl,val);
-        nlm_mdelay(1);
-
-        /* Clear the Power Down bit */
-        val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        val &= ~( (1 << 29) | (0x7ffff));
-        netsoc_write_mac_reg(mac_base, lane_ctrl, (rext_sel | val));
-        nlm_mdelay(1);
+    if(lane_ctrl == 4)
+    {
+		for(i=4;i<=7;i++)
+			{
+				netsoc_api_print(NETSOC_APIDBG_PORT,"Before register reset de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, i));
+				val = netsoc_read_mac_reg(mac_base,i);
+				val &= (~(1 << 30) & 0xFFFFFFFF);
+				val |= (1 << 20);
+				val |= (1 << 29);
+				val &= ~(1 << 17);
+				val &= ~(1 << 22);
+				val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
+
+				if(mode != PHYMODE_SGMII)
+				{
+					val |= PHY_LANE_CTRL_BPC_XAUI; //Set comma bypass for XAUI
+					netsoc_api_print(NETSOC_APIDBG_PORT, "Just set comma bypass for XAUI\n");
+					nlm_mdelay(1);
+				}
+				if(mode == PHYMODE_RXAUI && (i%2))
+				{
+					netsoc_api_print(NETSOC_APIDBG_PORT, "mode is %x so function is returning\n", mode);
+					return 0;
+				}
+				if(i != 4)
+				{
+					val = val | (1 << 23);
+				}
+				netsoc_api_print(NETSOC_APIDBG_PORT, "Just set rext_sel\n");
+				netsoc_write_mac_reg(mac_base,i,val);
+				nlm_mdelay(1);
+				val =  netsoc_read_mac_reg(mac_base,i);
+				netsoc_api_print(NETSOC_APIDBG_PORT,"Value written to SERDES lane %d is %x\n", i, val);
+				nlm_mdelay(1);
+			}
 
-	if (mode == PHYMODE_SGMII || mode == PHYMODE_XAUI) {
-		if (is_nlm_xlp3xx()) {
-			nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
-			reinit_tx_pll(nae, block, lane_ctrl);
-		}
+         for(i=4;i<=7;i++)
+             {
+		if (is_nlm_xlp3xx())
+		    {
+					nlm_hal_PMFF_ALL_workaround(nae, block, i);
+					nlm_mdelay(1);
+					reinit_tx_pll(nae, block, i);
+					nlm_mdelay(1);
+		    }
+
+		    netsoc_api_print(NETSOC_APIDBG_PORT,"Clearing the Power Down Bit(Bit 29)\n");
+		    val =netsoc_read_mac_reg(mac_base,i);
+		    val &= ~(1 << 29);
+		    netsoc_write_mac_reg(mac_base,i,val);
+		    nlm_mdelay(1);
+
+		    netsoc_api_print(NETSOC_APIDBG_PORT,"Setting the epcs Bit(Bit 30)\n");
+		    val = netsoc_read_mac_reg(mac_base,i);
+		    val |= (1 << 30);
+		    netsoc_write_mac_reg(mac_base,i,val);
+	            nlm_mdelay(1);
+				netsoc_api_print(NETSOC_APIDBG_PORT,"After serdes  de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, i));
+            }
+
+    }
+     while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (PHY_LANE_STAT_PCR)) != (PHY_LANE_STAT_PCR) && count!=count_max)
+	{
+		netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for PMA Ready ..........%d\n", count);
+		count++;
 	}
-
-        val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
-        netsoc_write_mac_reg(mac_base, lane_ctrl,val);
-        nlm_mdelay(1);
-        netsoc_api_print(NETSOC_APIDBG_PORT," After serdes  de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, lane_ctrl));
-
-        while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (PHY_LANE_STAT_PCR)) != (PHY_LANE_STAT_PCR) && count!=count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for PMA Ready ..........%d\n", count);
-                count++;
-        }
-        if(count==count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_ERROR,"PMA controller of node %d complex %d and lane %d did not come out of reset!!\n", nae->node, block, (lane_ctrl-4));
-                return -1;
-        }
-        count=0;
-        while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (LANE_TX_CLK)) != LANE_TX_CLK && count!=count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for TX clock to become stable ..........%d\n", count);
-                count++;
-        }
-        if(count==count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_ERROR," TX clock stable bit of node %d complex %d and lane %d not set!!\n", nae->node, block, (lane_ctrl-4));
-                return -2;
-        }
-        count=0;
-        while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (LANE_RX_CLK)) != LANE_RX_CLK && count!=count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for RX clock to become stable ..........%d\n", count);
-                count++;
-        }
-        if(count==count_max)
-        {
-                netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock stable bit of node %d complex %d and lane %d not set!!\n", nae->node, block, (lane_ctrl-4));
-                return -3;
+	if(count==count_max)
+	{
+		netsoc_api_print(NETSOC_APIDBG_ERROR,"PMA controller of node %d complex %d and lane %d did not come out of reset!!\n", nae->node, block, (lane_ctrl-4));
+		return -1;
+	}
+	count=0;
+	while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (LANE_TX_CLK)) != LANE_TX_CLK && count!=count_max)
+	{
+		netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for TX clock to become stable ..........%d\n", count);
+		count++;
+	}
+	if(count==count_max)
+	{
+	netsoc_api_print(NETSOC_APIDBG_ERROR," TX clock stable bit of node %d complex %d and lane %d not set!!\n", nae->node, block, (lane_ctrl-4));
+		return -2;
+	}
+	count=0;
+	while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (LANE_RX_CLK)) != LANE_RX_CLK && count!=count_max)
+	{
+		netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for RX clock to become stable ..........%d\n", count);
+		count++;
+	}
+	if(count==count_max)
+	{
+		netsoc_api_print(NETSOC_APIDBG_ERROR,"RX clock stable bit of node %d complex %d and lane %d not set!!\n", nae->node, block, (lane_ctrl-4));
+		return -3;
         }
-        netsoc_api_print(NETSOC_APIDBG_PORT,"Reset PMA for node %d complex %d and lane %d was successful!! \n", nae->node, block, (lane_ctrl-4));
+	netsoc_api_print(NETSOC_APIDBG_PORT,"Reset PMA for node %d complex %d and lane %d was successful!! \n", nae->node, block, (lane_ctrl-4));
+
+	netsoc_api_print(NETSOC_APIDBG_PORT,"Reset PLL done @node:%d block:%d lane:%d mode:%d\n", nae->node, block, lane_ctrl, mode);
 
-        netsoc_api_print(NETSOC_APIDBG_PORT,"Reset PLL done @node:%d block:%d lane:%d mode:%d\n", nae->node, block, lane_ctrl, mode);
-    return 0;
+	return 0;
 }
 
+
 static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 {
         uint32_t val = 0, count=0;
-- 
1.7.1

