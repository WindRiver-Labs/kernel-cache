From d0d789f5cf279a5c3640a0579c7267814afe9316 Mon Sep 17 00:00:00 2001
From: Sreenidhi B R <sreenira@broadcom.com>
Date: Fri, 5 Jul 2013 21:52:52 +0530
Subject: dtre: xlp9xx specific changes

- update FMN vc ID, used for sending messages
- change bus# to 1, during register read/write
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/dtre/nlm_adma.c b/drivers/misc/netlogic/dtre/nlm_adma.c
index 7281270..860532d 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.c
+++ b/drivers/misc/netlogic/dtre/nlm_adma.c
@@ -48,6 +48,7 @@
 #include "nlm_hal_fmn_dp.h"
 
 uint64_t nlm_dtre_debug = 0;
+static unsigned int nlm_dtre_min_vc = 0;
 
 #define shift_lower_bits(x, bitshift, numofbits) \
 	(((unsigned long long)(x) & ((1ULL << (numofbits)) - 1)) << (bitshift))
@@ -426,14 +427,17 @@ static dma_cookie_t nlm_tx_submit (struct dma_async_tx_descriptor *tx)
 	chan = (struct nlm_adma_chan *)(nlm_tx->chan);
 
 	/* update dest vc_id from channel number */
-	/* TODO: xlp9xx
-	   1. check if any change is required here, while calculating vc_id
-	   2. probably not required, under following assumptions
+	/* xlp9xx: calculating vc_id
 	      channel 0,1: belong to DTRE-0 and channel 0 is for RAID
 	      channel 2,3: belong to DTRE-1 and channel 2 is for RAID
+
+	   others:
+	      channel 0: RAID
+	      channel 1-3: DMA
 	      */
 
-	vc_id = DTRE_MIN_VC + chan->chan_num;
+	/* nlm_dtre_min_vc is updated in probe function */
+	vc_id = nlm_dtre_min_vc + chan->chan_num;
 
 	spin_lock_bh(&chan->lock);
 	cookie = nlm_desc_assign_cookie(chan, nlm_tx);
@@ -1460,14 +1464,11 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 	uint32_t value;
 	int is_raid = 0;
 
-
 	if (is_nlm_xlp9xx())
 	{
-		/* TODO: xlp9xx
-		   1. register station IDs of both engines
-		   2. confirm FMN station IDs
-		   3. check if any changes are required in onchip.c
-		*/
+		nlm_dtre_min_vc = DTRE_9XX_MIN_VC;
+
+		/* for xlp9xx, register station IDs of both engines */
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, nlm_dtre_msgring_handler, NULL))
 		{
 			printk("Error: NLM-ADMA unable to register for msgring handler\n");
@@ -1482,6 +1483,8 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 	}
 	else
 	{
+		nlm_dtre_min_vc = DTRE_MIN_VC;
+
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, nlm_dtre_msgring_handler, NULL)){
 			printk("Error: NLM-ADMA unable to register for msgring handler\n");
 			return -1;
@@ -1493,7 +1496,6 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 		/* assume current channel is DMA (not raid)
 		   change it later in the loop (if required) */
 
-		/* TODO: xlp9xx, check this logic */
 		is_raid = 0;
 		adev = kzalloc(sizeof(*adev), GFP_KERNEL);
 		if (!adev)
@@ -1539,8 +1541,7 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 
 		if (is_nlm_xlp9xx())
 		{
-			/* TODO: xlp9xx check this logic 
-			   assume channel 0 & 2 are for RAID 
+			/* xlp9xx: channel 0 & 2 are for RAID
 			   (ie., the first channel on each engine)
 			*/
 			if ((loop == 0) || (loop == 2)){
@@ -1608,24 +1609,32 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 	/* hal initialization */
 	nlm_hal_dtr_init(fdt);
 
-	/* for DTRE0 */
-	base = nlm_hal_get_dev_base (0 /*node*/, 0 /*B*/, 5 /*D*/, 0 /*F*/);
-	value = nlm_hal_read_32bit_reg (base, 0x40);
+	if (is_nlm_xlp9xx())
+	{
+		/* xlp9xx: if this is xlp9xx, we need to set for both engines DTRE0 and DTRE1.
+		   1. check BDF values
+		   2. check master control register numbers
+		   3. update both master control register
+		 */
 
-	/* set channel 0 is raid - bit 4 */
-	nlm_hal_write_32bit_reg (base, 0x40, value | (0x10));
+		/* for DTRE0, B/D/F = 1/5/0 */
+		base = nlm_hal_get_dev_base (0 /*node*/, 1 /*B*/, 5 /*D*/, 0 /*F*/);
+		value = nlm_hal_read_32bit_reg (base, 0x40);
 
-	/* TODO: xlp9xx
-	   if this is xlp9xx, we need to set for engine DTRE1 also.
-	   1. check BDF values
-	   2. check master control register numbers
-	   3. update both master control register
-	   here, we are assuming one master control register for each engine
-	   */
-	if (is_nlm_xlp9xx())
+		/* set channel 0 is raid - bit 4 */
+		nlm_hal_write_32bit_reg (base, 0x40, value | (0x10));
+
+		/* for DTRE1, B/D/F = 1/5/6 */
+		base = nlm_hal_get_dev_base (0 /*node*/, 1 /*B*/, 5 /*D*/, 6 /*F*/);
+		value = nlm_hal_read_32bit_reg (base, 0x40);
+
+		/* set channel 0 is raid - bit 4 */
+		nlm_hal_write_32bit_reg (base, 0x40, value | (0x10));
+	}
+	else
 	{
-		/* for DTRE1 */
-		base = nlm_hal_get_dev_base (0 /*node*/, 0 /*B*/, 5 /*D*/, 6 /*F*/);
+		/* for DTRE, B/D/F = 0/5/0 */
+		base = nlm_hal_get_dev_base (0 /*node*/, 0 /*B*/, 5 /*D*/, 0 /*F*/);
 		value = nlm_hal_read_32bit_reg (base, 0x40);
 
 		/* set channel 0 is raid - bit 4 */
diff --git a/drivers/misc/netlogic/dtre/nlm_adma.h b/drivers/misc/netlogic/dtre/nlm_adma.h
index 69898a3..e4e0b13 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.h
+++ b/drivers/misc/netlogic/dtre/nlm_adma.h
@@ -55,6 +55,8 @@
 #define DTRE_MIN_VC		264
 #define DTRE_MAX_VC		267
 #define DTRE_NUM_CHANNELS	4
+#define DTRE_9XX_MIN_VC		392
+#define DTRE_9XX_MAX_VC		395
 
 
 
-- 
1.7.1

