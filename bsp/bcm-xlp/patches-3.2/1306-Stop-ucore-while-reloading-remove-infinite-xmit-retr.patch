From daad4efa252ba1d7042c8d4c41f7afb986ec24bb Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sun, 3 Oct 2010 19:13:49 -0700
Subject: Stop ucore while reloading, remove infinite xmit retries (since no txc handling), use IPIs for XLP A0 msgring timer workaround

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 252aadc..0588880 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -8,10 +8,57 @@
 
 #include "net_common.h"
 
-#define VAL_UCORE_RESET(x)		((x&0xffff)<<8)
-
 #define RELY_ON_FIRMWARE_CONFIG
 
+#define VAL_UCORE_RESET(x)             ( ( (x) &0xffff) << 8)
+
+/*
+ *  Ucore support
+ */
+static int local_load_ucore(int ucore_mask, unsigned int *opcodes, int num_opcodes)
+{
+	int mask = ucore_mask & NAE_UCORE_MASK;
+	unsigned int id = 0;
+	int i;
+	volatile uint32_t ucore_cfg = 0;
+
+	printk("[%s]\n", __func__);
+	nlm_print("Stopping and Resetting all ucore...\n");
+
+	/* Stop all ucores */
+        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
+	nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg | (1 << 24));
+
+	/* poll for ucore to get in to a wait state */
+	for(;;) {
+		ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
+		if (ucore_cfg & (1 << 25)) break;
+	}
+
+	nlm_print("Loading ucores (mask = 0x%04x)\n", mask);
+
+	while (id < MAX_NAE_UCORES) {
+
+		if ((mask & (1 << id)) == 0) {
+			id++;
+			continue;
+		}
+
+		for (i=0; i < num_opcodes; ++i) {
+			nlm_hal_write_ucode(id, (i * 4), opcodes[i]);
+		}
+		id++;
+	}
+
+	/* Enable per-domain ucores */
+        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
+	ucore_cfg = ucore_cfg & (~VAL_UCORE_RESET(ucore_mask)) & ~(1 << 24);
+
+        nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg);
+
+	return 0;
+}
+
 static void parse_ucore_config(void)
 {
         uint32_t ucore_cfg;
@@ -42,13 +89,9 @@ static void parse_ucore_config(void)
 
 	getprop(node, "opcodes", uc_opcodes, size);
 
-	nlm_hal_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
+	local_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
 
 	kfree(uc_opcodes);
-
-	/* Enable per-domain ucores */
-        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
-        nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg & (~VAL_UCORE_RESET(uc_mask)));
 }
 
 static void parse_fdt_cpu_config(void)
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 21de461..c89991f 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -596,7 +596,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	msgrng_access_enable(mflags);
- retry_send:
+// retry_send:
         if ( (ret = nlm_hal_send_msg2(priv->nae_tx_qid,
 				      0,
 				      msg.entry[0],
@@ -604,8 +604,8 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
         {
 		print_fmn_send_error(__func__, ret);
 		//printk("[%s] HACK ALERT! dropping packet(skb=%p)!\n", __func__, skb);
-		//dev_kfree_skb_any(skb);
-		goto retry_send;
+		dev_kfree_skb_any(skb);
+		//goto retry_send;
         }
 
 	msgrng_access_disable(mflags);
@@ -932,6 +932,8 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 
 		priv = netdev_priv(dev);
 
+		len += sprintf(page + len, "=============== port@%d ==================\n", i);
+
 		len += sprintf(page + len, "per port@%d: frin_to_be_sent = %ld num_replenishes = %ld frin_sent = %ld\n",
 			       i, atomic64_read(&priv->frin_to_be_sent),
 			       atomic64_read(&priv->num_replenishes),
@@ -969,6 +971,7 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 }
 
 extern void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
+
 /**********************************************************************
  * nlm_xlp_mac_timer - interrupt handler routine
  * @data - parameter passed in when timer interrupt handler is called.
@@ -978,10 +981,25 @@ static void nlm_xlp_mac_timer(unsigned long data)
 	unsigned port = data;
         struct net_device *dev = (struct net_device *)dev_mac[port];
         struct dev_data *priv = netdev_priv(dev);
-        int next_tick = HZ / 100; /* 10ms */
+        int next_tick = HZ / 1000; /* 1ms */
 
 	/* printk("[%s] A0 Workaround, forcing FMN int handling \n",__func__); */
+#if 0
 	nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
+#else
+	{
+		uint32_t cpumask = 0xffffffff;
+		pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+		int cpu = hard_smp_processor_id();
+
+		cpumask = cpumask & ~(1 << cpu);
+
+		/* Send IRQ_MSGRING vector in an IPI to all cpus */
+		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (cpumask & 0xffff) );
+		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (1 << 16)
+				      | ( (cpumask >> 16) & 0xffff) );
+	}
+#endif
 
         priv->link_timer.expires = jiffies + next_tick;
         add_timer(&priv->link_timer);
-- 
1.7.1

