From b5bc5044f9346aa11d8f7499f332bf20551b14ab Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Tue, 18 Jun 2013 19:07:01 -0700
Subject: MACsec: Added support for xlp9XX

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_board.c b/drivers/net/ethernet/broadcom/nae/xlpge_board.c
index aa832ea..5f4c861 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_board.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_board.c
@@ -78,7 +78,12 @@ void gen_mac_address(void)
         if( ((mac0_set | mac1_set) && if_mac_set) == 0){
                 random_ether_addr(mac_base);
         }
-
+	mac_base[0] = 0x11;
+	mac_base[1] = 0x22;
+	mac_base[2] = 0x33;
+	mac_base[3] = 0x44;
+	mac_base[4] = 0x55;
+	mac_base[5] = 0x66;
 	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
                 for(j=0;j<18;j++){
                         memcpy(eth_hw_addr[i][j], mac_base, 6);
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index ced0fec..e15565b 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -61,6 +61,8 @@ struct dev_data *last_rcvd_priv[NR_CPUS * 8] ____cacheline_aligned;
 
 uint64_t receive_count[NR_CPUS * 8] __cacheline_aligned;
 
+#define MACSEC_DEBUG	1
+
 inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
 {
         struct sk_buff* skb;
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tso.c b/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
index 8885373..35c8cfa 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
@@ -40,6 +40,7 @@
 #include <nlm_hal_fmn.h>
 
 #include "xlpge.h"
+#define MACSEC_DEBUG	1
 
 static __inline__ uint64_t nae_tso_desc0(
 		unsigned int type,
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
index de93ba1..bbdd1a2 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
@@ -49,7 +49,7 @@ extern struct dev_data *last_rcvd_priv[NR_CPUS * 8] ____cacheline_aligned;
 uint64_t fast_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t slow_replenish_count[NR_CPUS * 8] __cacheline_aligned;
 uint64_t err_replenish_count[NR_CPUS * 8] __cacheline_aligned;
-
+#define MACSEC_DEBUG 1
 /**********************************************************************
  * nlm_xlp_nae_start_xmit -  transmit a packet from buffer
  * @dev  -  this is per device based function
@@ -64,9 +64,60 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	volatile int hw_repl = 0;
 	int  offset, qid;
 	unsigned long __attribute__ ((unused)) mflags;
+	uint32_t msec_port, send_msec = 0, msec_bypass = 0;
+	uint32_t pad_len = 0, icv_len = 0, param_index = 0 ;
+	unsigned char *buf, sec_tag_hdr[16], icv[16]; 
 
 	nae_t* nae_cfg = priv->nae;
 
+#ifdef MACSEC_DEBUG
+	printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+		nae_cfg->sectag_offset[priv->port],
+		nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
+#endif
+	if(priv->index == XGMAC0)
+		msec_port = (priv->port | 0xf) << (4 * priv->block);
+	else
+		msec_port = 1 << priv->port;
+
+#ifdef MACSEC_DEBUG
+	dump_buffer(skb->data, skb->len, "Org skb pkt:");
+	printk("msec_port = %x priv->port = %d priv->block = %d \
+		priv->index = %d skb->len = %d \
+		nae_cfg->msec_port_enable = %x\n",
+		msec_port, priv->port, priv->block, priv->index,
+		skb->len, nae_cfg->msec_port_enable);
+#endif
+	/* check if tx port is enabled for msec
+	 * else bypass MACSec
+	 */
+	if (nae_cfg->msec_port_enable & msec_port) {
+		short ether_type = *(short*)(((char*)skb->data) +
+					MAC_HEADER_LEN);
+
+#ifdef MACSEC_DEBUG
+	printk("skb->len = %d ether_type = %x\n",
+			skb->len, ether_type);
+#endif
+		/* Enable Macsec processing */
+//		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP) 
+		{
+			send_msec = 1;
+			/* param_index should be between 1 - 7 */
+			param_index = (priv->port)?priv->port:1;
+
+			pad_len =  nae_cfg->sectag_offset[priv->port] +
+					nae_cfg->sectag_len[priv->port];
+			icv_len = nae_cfg->icv_len[priv->port];
+
+#ifdef MACSEC_DEBUG
+	printk("pad_len = %d icv_len = %d ether_type = %x\n",
+			pad_len, icv_len, ether_type);
+#endif
+		}
+	/*	else
+			msec_bypass = 1;*/
+	}
 
 #ifdef ENABLE_SANITY_CHECKS
 	if (!skb) {
@@ -113,6 +164,17 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 	
 	{
+		if(send_msec)
+		{
+			buf = kmalloc(skb->len, GFP_KERNEL);
+			memcpy(buf, &skb->data[MAC_HEADER_LEN], (skb->len - MAC_HEADER_LEN));
+			memcpy(&skb->data[MAC_HEADER_LEN], sec_tag_hdr, pad_len); 		
+			memcpy(&skb->data[MAC_HEADER_LEN + pad_len], buf, (skb->len - MAC_HEADER_LEN)); 		
+			memcpy(&skb->data[skb->len+pad_len], icv, icv_len); 		
+			skb->len +=(pad_len + icv_len);
+			kfree(buf);
+				
+		}
 		msg1 = nae_tx_desc(DESC_TYPE_P2DEOP, NULL_VFBID, skb->len,
 			       virt_to_bus(skb->data));
 	}
-- 
1.7.1

