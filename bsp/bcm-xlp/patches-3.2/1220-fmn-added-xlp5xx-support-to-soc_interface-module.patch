From 781cad263c03cafaca76dfd67bc5c7eee508b2ea Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Tue, 11 Feb 2014 19:02:20 +0530
Subject: fmn: added xlp5xx support to soc_interface module

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index cf3e18d..3c3f51b 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -55,6 +55,7 @@
 
 #define MAX_VC	4096
 #define MAX_VC_9XX	8192
+#define MAX_VC_5XX	1024
 /* #define ONCHIP_DEBUG 1 */
 
 static int is_cpu_core_xlp_ii = 0;
@@ -678,6 +679,41 @@ static uint16_t xlp9xx_vc_to_handle_map[MAX_VC_9XX] = {
 	[7900 ... 8191]= XLP_MSG_HANDLE_INVALID,
 };
 
+static uint16_t xlp5xx_vc_to_handle_map[MAX_VC_5XX] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 95] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 385] = XLP_MSG_HANDLE_PCIE0,
+	[386 ... 387] = XLP_MSG_HANDLE_PCIE1,
+	[388 ... 389] = XLP_MSG_HANDLE_PCIE2,
+	[390 ... 391] = XLP_MSG_HANDLE_PCIE3,
+	[392 ... 393] = XLP_MSG_HANDLE_GDX_0,
+	[394 ... 399] = XLP_MSG_HANDLE_INVALID,
+	[400 ... 401] = XLP_MSG_HANDLE_CMP,
+	[402 ... 411] = XLP_MSG_HANDLE_INVALID,
+	[412 ... 415] = XLP_MSG_HANDLE_LZS,
+	[416 ... 423] = XLP_MSG_HANDLE_INVALID,
+	[424 ... 427] = XLP_MSG_HANDLE_CRYPTO,
+	[428 ... 447] = XLP_MSG_HANDLE_INVALID,
+	[448 ... 451] = XLP_MSG_HANDLE_RSA_ECC,
+	[452 ... 459] = XLP_MSG_HANDLE_INVALID,
+	[460 ... 463] = XLP_MSG_HANDLE_REGX,
+	[464 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 479] = XLP_MSG_HANDLE_KBP,
+	[480 ... 511] = XLP_MSG_HANDLE_INVALID,
+	[512 ... 519] = XLP_MSG_HANDLE_POE_0,
+	[520 ... 599] = XLP_MSG_HANDLE_NAE_0,
+	[600 ... 729] = XLP_MSG_HANDLE_INVALID,
+	[730 ... 731] = XLP_MSG_HANDLE_ALE,
+	[732 ... 1023]= XLP_MSG_HANDLE_INVALID,
+};
+
 static uint16_t *vc_to_handle = vc_to_handle_map;
 
 /******************************************************************************************
@@ -1111,6 +1147,34 @@ void nlm_enable_vc_intr_9xx(void)
         }
 }
 
+void nlm_enable_vc_intr_5xx(void)
+{
+	int cpu, node;
+	int vc_index = 0;
+	int i = 0;
+
+	for(cpu=0; cpu < NR_CPUS; cpu++){
+		if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
+			continue;
+		node = cpu / NLM_MAX_CPU_PER_NODE_5XX;
+		for(i = 0; i < NLM_MAX_VC_PER_THREAD_5XX; i++) {
+			vc_index = (i + cpu * NLM_MAX_VC_PER_THREAD_5XX) & NLM_MAX_VC_MASK_5XX;
+			if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+				/*enable interrupts*/
+				nlm_hal_enable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("%s ENABLED: node = %d, vc = %d\n", __func__, node, vc_index);
+#endif
+			} else{
+				nlm_hal_disable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("%s DISABLED: node = %d, vc = %d\n",__func__, node, vc_index);
+#endif
+			}
+		}
+	}
+}
+
 
 int xlp_fmn_poll(struct napi_struct *napi, int budget)
 {
@@ -1382,6 +1446,52 @@ static void parse_fmn_config_9xx(void)
 	}
 }
 
+static void parse_fmn_config_5xx(void)
+{
+	uint32_t node_vc_mask[NLM_MAX_COREPAIR_PER_NODE_5XX] = {0};
+	unsigned char buf[30];
+	int i, j, id=0, k, tmp;
+	void *node;
+	uint32_t onlinemask[NLM_MAX_CPU_NODE_5XX] = {~0u};
+
+	node = finddevice("/doms/dom@0/fmn");
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE_5XX; i++) {
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask[i]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE_5XX; j++, id++) {
+						if (onlinemask[i] & (1 << j)) {
+							nlm_cpu_vc_mask[id] = 0xf;
+						}
+					}
+				}
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = (NLM_MAX_COREPAIR_PER_NODE_5XX - 1); j >= 0; j--) {
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
+					}
+				}
+			}
+		}
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE_5XX; i++) {
+			if (onlinemask[i]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE_5XX; j++, id++) {
+					if (onlinemask[i] & (1 << j)) {
+						nlm_cpu_vc_mask[id] = 0xf;
+					}
+				}
+			}
+		}
+	}
+}
+
 int nae_rx_vc = -1, nae_fb_vc = -1;
 int sae_rx_vc = -1, sae_rx_sync_vc = -1;
 int ipsec_async_vc = -1, ipsec_sync_vc = -1;
@@ -1447,7 +1557,7 @@ static int __init nlm_fmn_init(void)
 	int max_nodes = NLM_MAX_NODES;
 	uint32_t fmn_owner_mask = 0;
 
-	if(is_nlm_xlp9xx())
+	if(IS_NLM_XLP9XX_FAMILY)
 		max_nodes = NLM_MAX_CPU_NODE_9XX;
 
         /* Better to do node level fmn initialization */
@@ -1465,8 +1575,9 @@ static int __init nlm_fmn_init(void)
         /* Enable vc interupts for the online cpus */
 	if(is_nlm_xlp9xx()) {
 		nlm_enable_vc_intr_9xx();
-	}
-	else {
+	} else if (is_nlm_xlp5xx()) {
+		nlm_enable_vc_intr_5xx();
+	} else {
 		nlm_enable_vc_intr();
 	}
 
@@ -1498,14 +1609,15 @@ static int __init on_chip_init(void)
 	for_each_possible_cpu(i)
 		cpumask_set_cpu(cpu_logical_map(i), &phys_cpu_present_map);
 
-	is_cpu_core_xlp_ii = is_nlm_xlp2xx() | is_nlm_xlp9xx() ;
+	is_cpu_core_xlp_ii = is_nlm_xlp2xx() | IS_NLM_XLP9XX_FAMILY;
 	node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
 	nlm_proc_setup();
 
 	if(is_nlm_xlp9xx()) {
 		parse_fmn_config_9xx();
-	}
-	else {
+	} else if (is_nlm_xlp5xx()) {
+		parse_fmn_config_5xx();
+	} else {
 		parse_fmn_config();
 	}
 
@@ -1533,6 +1645,8 @@ static int __init on_chip_init(void)
 		vc_to_handle = xlp3xx_vc_to_handle_map;
 	else if (is_nlm_xlp9xx())
 		vc_to_handle = xlp9xx_vc_to_handle_map;
+	else if (is_nlm_xlp5xx())
+		vc_to_handle = xlp5xx_vc_to_handle_map;
 	else
 		vc_to_handle = vc_to_handle_map;
 
-- 
1.7.1

