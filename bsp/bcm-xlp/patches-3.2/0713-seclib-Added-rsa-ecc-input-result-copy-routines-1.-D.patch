From 461c9142d1212045230a1da2165251716ccae94a Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Wed, 19 Jun 2013 15:22:01 +0530
Subject: seclib : Added rsa/ecc input/result copy routines 1. Disabled the debug prints

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
index f778e76..622a385 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
@@ -142,7 +142,6 @@
 * implemented as part of this library
 *
 */
-#include <linux/types.h>
 #include "cryptosoc_ctx.h"
 #include "saesoc_defs.h"
 #include "cryptosoc_lib_priv.h"
@@ -154,12 +153,6 @@ static int cryptosoc_lmt_vc[CRYPTOSOC_TYPE_MAX];
 cryptosoc__mem_alloc *cryptosoc_mem_alloc;
 cryptosoc__mem_free *cryptosoc_mem_free;
 
-static int cryptosoc_get_ptype_gen()
-{
-	/* TODO , Look at the processor type and return the value */
-	return CRYPTOSOC_PTYPE_IS_GEN1;
-}
-
 /**
 * cryptosoc_lib_init - Initialize the sae/rsa/ecc soc library parameters 
 *  based on the processor type.
@@ -191,7 +184,11 @@ int cryptosoc_lib_init(struct cryptosoc_lib_params *params,
 	cryptosoc_mem_alloc = mem_alloc;
 	cryptosoc_mem_free	= mem_free;
 
-	cryptosoc_ptype_gen = cryptosoc_get_ptype_gen();
+	/* gen type should be filled by the priv init 
+	implementation specific init routine */
+	if(cryptosoc_lib_priv_init() < 0)
+		return  -CRYPTOSOC_EINVAL;
+
 	if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
 		/* for griffin and associated versions */
 		params->saesoc_feature_set = SAESOC_FF_GEN2_PTYPE;
@@ -209,9 +206,7 @@ int cryptosoc_lib_init(struct cryptosoc_lib_params *params,
 		cryptosoc_get_basevc_limitvc(i,
 			&cryptosoc_base_vc[i], &cryptosoc_lmt_vc[i]);
 
-	/* implementation specific init routine */
-	return cryptosoc_lib_priv_init();
-
+	return CRYPTOSOC_OK;
 }
 
 /**
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
index eaf827b..eb20318 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
@@ -51,14 +51,24 @@ typedef  unsigned long long   _uint64_t;
 #define cryptosoc_is_cache_aligned(x) (((_uint64_t)x & (CRYPTOSOC_CACHELINE_SZ - 1)) == 0)
 #define cryptosoc_align(x, y)     ((x) & (~((y)-1)))
 #define cryptosoc_roundup(x, y)   (cryptosoc_align((x)+(y)-1, (y)))
+
 #ifndef NLM_HAL_LINUX_KERNEL
-#define cryptosoc_dbg_print(fmt, args...) printf(fmt, ##args)
-#define cryptosoc_err_print(fmt, args...) printf(fmt, ##args)
+	#ifdef CRYPTOSOC_DBG_EN
+	#define cryptosoc_dbg_print(fmt, args...) printf(fmt, ##args)
+	#endif
+	#define cryptosoc_err_print(fmt, args...) printf(fmt, ##args)
+	#define cryptosoc_print(fmt, args...) printf(fmt, ##args)
 #else
-#define cryptosoc_dbg_print(fmt, args...) printk(fmt, ##args)
-#define cryptosoc_err_print(fmt, args...) printk(fmt, ##args)
+	#ifdef CRYPTOSOC_DBG_EN
+	#define cryptosoc_dbg_print(fmt, args...) printk(fmt, ##args)
+	#endif
+	#define cryptosoc_err_print(fmt, args...) printk(fmt, ##args)
+	#define cryptosoc_print(fmt, args...) printk(fmt, ##args)
 #endif
 
+#ifndef CRYPTOSOC_DBG_EN
+#define cryptosoc_dbg_print(fmt, args...) { }
+#endif
 
 #define CRYPTOSOC_PTYPE_IS_GEN1 0x1
 #define CRYPTOSOC_PTYPE_IS_GEN2 0x2
diff --git a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
index cfe9046..540596e 100644
--- a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
+++ b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
@@ -37,11 +37,11 @@
 #define _RSAECC_SOC_COMMON_H
 
 /* engine request and result data format conversion routine */
-typedef int (*rsa_ecc_soc_data_copy)(int,  char *, int, char *, int);
+typedef int (*rsa_ecc_soc_data_copy)(int,  unsigned char *, int, unsigned char *, int);
 
 /* input copy : src format is dword and most significant dword first */
 static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian, 
-		char *dst, int d_nbits, char *src, int s_nbits)
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
 {
 
 	int i;
@@ -49,17 +49,17 @@ static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian,
 	int slen = (s_nbits + 7) / 8;
 	/* Engine format is ms-dword last and in bigendian format.*/
 	/* Return error if src is not  dword aligned, 
-	*  Engine dst and dlen should always be dword aligned */
+	*      *  Engine dst and dlen should always be dword aligned */
 
 	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
-		   		__FUNCTION__, (long)dst, (long)src, dlen, slen);
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
 
 	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
 	if(slen == 0 || dlen == 0)
 		return -CRYPTOSOC_EINVAL;
-		
+
 
 	/* return error if source length is greater than engine length */
 	if(slen > dlen)
@@ -80,17 +80,19 @@ static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian,
 }
 
 /* result copy : dst format is dword and most significant dword first */
-static int rsa_ecc_soc_result_copy_fmt_dword_msdwf(int dst_big_endian, 
-		char *dst, int d_nbits, char *src, int s_nbits)
+static int rsa_ecc_soc_result_copy_fmt_dword_msdwf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
 {
-	char *odst = dst;
 	int i, min;
 	int dlen = (d_nbits + 7) / 8;
 	int slen = s_nbits / 8;
 
 	/* Engine format is ms-dword last and in bigendian format.*/
 	/* Return error if dst is not dword aligned, 
-	   Engine src and slen should always be dword aligned */
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
 
 	if((unsigned long)dst & 0x7UL || (unsigned long)src & 0x7UL || (slen & 0x7))
 		return -CRYPTOSOC_EINVAL;
@@ -98,22 +100,513 @@ static int rsa_ecc_soc_result_copy_fmt_dword_msdwf(int dst_big_endian,
 	if(slen == 0 || dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
-	/* goto the end of the dest */
+	/* copy from ls to ms */
 	dlen = cryptosoc_roundup(dlen, 8);
-	dst += (dlen - 8);
 	/* copy only the mininum of slen & dlen */
 	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+	
+	dst += (dlen - 8);
+
 	for(i = 0; i < min; i+=8) {
-		*(_uint64_t *)dst =  *(_uint64_t *)(src + i);
+		*(_uint64_t *)(dst) =  *(_uint64_t *)(src);
+		src += 8;
 		dst -= 8;
 	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is dword and least significant dword first */
+static int rsa_ecc_soc_input_copy_fmt_dword_lsdwf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		*(_uint64_t *)(dst + i) = *(_uint64_t *)(src + i);
+	}
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is dword and least significant dword first */
+static int rsa_ecc_soc_result_copy_fmt_dword_lsdwf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	dlen = cryptosoc_roundup(dlen, 8);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+
+	for(i = 0; i < min; i+=8) {
+		*(_uint64_t *)(dst + i) =  *(_uint64_t *)(src + i);
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is word and most significant word first */
+static int rsa_ecc_soc_input_copy_fmt_word_mswf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0ULL;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the lsword */
+	slen = cryptosoc_roundup(slen, 4);
+	src += (slen - 4);
+	for(i = 0; i < slen; i+=8)  {
+		val =  *(unsigned int *)src;
+		src -= 4;
+		val |=  (((_uint64_t)(*(unsigned int *)src)) << 32);
+		src -= 4;
+		*(_uint64_t *)(dst + i) = val;
+	}
+	/* if slen is not dword, make last msb 0 */
+	if(slen & 7)
+		*(_uint64_t *)(dst + i - 8) = val & 0xffffffffULL;
+
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is word and most significant word first */
+static int rsa_ecc_soc_result_copy_fmt_word_mswf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+	_uint64_t val;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x3UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy from ls to ms */
+	/* goto the end of the dest */
+	dlen = cryptosoc_roundup(dlen, 4);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+
+	dst += (dlen - 4);
+	/* if min is not dword aligned */
+
+	for(i = 0; i < (min & ~0x7); i+=8) {
+		val = *(_uint64_t *)(src);
+		*(unsigned int *)dst = (unsigned int)val;
+		dst -= 4;
+		*(unsigned int *)dst = (unsigned int)(val >> 32);
+		dst -= 4;
+		src += 8;
+	}
+	if(min & 0x7)
+		*(unsigned int *)dst = (*(_uint64_t *)(src)) & 0xffffffffULL;
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is word and most significant word first */
+static int rsa_ecc_soc_input_copy_fmt_word_lswf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0x0ULL;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+
+	/* return error if source length is greater than engine length */
+	slen = cryptosoc_roundup(slen, 4);
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		val =  *(unsigned int *)src;
+		src += 4;
+		val |=  (((_uint64_t)(*(unsigned int *)src)) << 32);
+		src += 4;
+		*(_uint64_t *)(dst + i) = val;
+	}
+
+	/* if slen is not dword, make last msb 0 */
+	if(slen & 7)
+		*(_uint64_t *)(dst + i - 8) = val & 0xffffffffULL;
+
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is word and most significant word first */
+static int rsa_ecc_soc_result_copy_fmt_word_lswf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+	_uint64_t val;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x4UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	dlen = cryptosoc_roundup(dlen, 4);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+
+	for(i = 0; i < (min & ~0x7); i+=8) {
+		val = *(_uint64_t *)(src);
+		*(unsigned int *)(dst) = (unsigned int)val;
+		dst += 4;
+		*(unsigned int *)(dst) = (unsigned int)(val >> 32);
+		dst += 4;
+		src += 8;
+	}
+	if(min & 0x7)
+		*(unsigned int *)dst = (*(_uint64_t *)(src)) & 0xffffffffULL;
+
+	return CRYPTOSOC_OK;
+}
+
+
+/* input copy : src format is byte and most significant byte first */
+static int rsa_ecc_soc_input_copy_fmt_msbf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the last byte */
+	src += (slen - 1);
+	for(i = 0; i < slen; i+=8)  {
+		max = (slen - i) > 8 ? 8 : (slen - i);
+		val = 0ULL;
+		for(j=0; j<max; j++) {
+			/* end address contains lsb */
+			val |= (((_uint64_t)(*src)) << ((j % 8) * 8));
+			src -= 1;
+		}
+		*(_uint64_t *)(dst + i) = val;
+	}
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is byte and most significant byte first */
+static int rsa_ecc_soc_result_copy_fmt_msbf(int dst_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max, min;
+
+	cryptosoc_dbg_print("%s in dst %lx d_nbits %d src %lx s_nbits %d\n", __FUNCTION__,
+			(long)dst, d_nbits, (long)src, s_nbits);
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	if((unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
 	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+
+	/* got the end of destination */
+	dst += (dlen - 1);
+
+	for(i = 0; i < min; i+=8)  {
+		max = (min - i) > 8 ? 8 : (min - i);
+		val = *(_uint64_t *)(src + i);
+		for(j=0; j<max; j++) {
+			/* input is bigendian format, end address contains lsb */
+			*dst = (val >> ((j % 8) * 8)) & 0xffUL;
+			dst--;
+		}
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is byte and least significant byte first */
+static int rsa_ecc_soc_input_copy_fmt_lsbf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		max = (slen - i) > 8 ? 8 : (slen - i);
+		val = 0ULL;
+		for(j=0; j<max; j++) {
+			/* start address contains lsb */
+			val |= (((_uint64_t)(*src)) << ((j % 8) * 8));
+			src += 1;
+		}
+		*(_uint64_t *)(dst + i) = val;
+	}
+	/* clear the extra memory in the last */
 	if(i < dlen)
-		memset(odst, 0, dlen - i);
+		memset((dst + i), 0, (dlen - i));
 
 	return CRYPTOSOC_OK;
 }
 
+/* result copy : dst format is byte and least significant byte first */
+static int rsa_ecc_soc_result_copy_fmt_lsbf(int dst_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max, min;
+
+	cryptosoc_dbg_print("%s in dst %lx d_nbits %d src %lx s_nbits %d\n", __FUNCTION__,
+			(long)dst, d_nbits, (long)src, s_nbits);
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	if((unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+	
+	for(i = 0; i < min; i+=8)  {
+		max = (min - i) > 8 ? 8 : (min - i);
+		val = *(_uint64_t *)(src + i);
+		for(j=0; j<max; j++) {
+			/* input is bigendian format, end address contains lsb */
+			*dst = val >> ((j % 8) * 8) & 0xff;
+			dst++; 
+		}
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* RSA & ECC both have the same type of conversion routines */
+#ifdef ECCSOC_DATA_FORMAT_SET
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+	[ECCSOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_lsdwf,
+	[ECCSOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_mswf,
+	[ECCSOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_lswf,
+	[ECCSOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_msbf,
+	[ECCSOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_lsbf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+	[ECCSOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_lsdwf,
+	[ECCSOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_mswf,
+	[ECCSOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_lswf,
+	[ECCSOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_msbf,
+	[ECCSOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_lsbf,
+};
+#else
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+	[RSASOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_lsdwf,
+	[RSASOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_mswf,
+	[RSASOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_lswf,
+	[RSASOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_msbf,
+	[RSASOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_lsbf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+	[RSASOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_lsdwf,
+	[RSASOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_mswf,
+	[RSASOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_lswf,
+	[RSASOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_msbf,
+	[RSASOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_lsbf,
+};
+#endif
+
+
 static inline int rsa_ecc_soc_find_max2(int a, int b)
 {	
 	if(a < b)
@@ -155,30 +648,10 @@ static inline int rsa_ecc_soc_find_max6(int a, int b, int c, int d, int e, int f
 	return max;
 }
 
-/* RSA & ECC both have the same type of conversion routines */
-#ifdef ECCSOC_DATA_FORMAT_SET
-/* engine request and result data format conversion routine */
-static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
-	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
-};
-
-static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
-	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
-};
-#else
-/* engine request and result data format conversion routine */
-static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
-	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
-};
-
-static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
-	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
-};
-#endif
 
 static inline int rsa_ecc_soc_input_copy_2(int inp_data_fmt, 
-		int word_bigendian, char *mem, int blksz_in_bits,
-		char *a, int alen_in_bits, char *b, int blen_in_bits)
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits)
 {
 	int rv;
 	int blk = blksz_in_bits / 8;
@@ -196,9 +669,9 @@ static inline int rsa_ecc_soc_input_copy_2(int inp_data_fmt,
 }
 
 static inline int rsa_ecc_soc_input_copy_3(int inp_data_fmt, 
-		int word_bigendian, char *mem, int blksz_in_bits,
-		char *a, int alen_in_bits, char *b, int blen_in_bits,
-		char *c, int clen_in_bits)
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits)
 {
 	int rv;
 	int blk = blksz_in_bits / 8;
@@ -215,9 +688,9 @@ static inline int rsa_ecc_soc_input_copy_3(int inp_data_fmt,
 }
 
 static inline int rsa_ecc_soc_input_copy_4(int inp_data_fmt, 
-		int word_bigendian, char *mem, int blksz_in_bits,
-		char *a, int alen_in_bits, char *b, int blen_in_bits,
-		char *c, int clen_in_bits, char *d, int dlen_in_bits)
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits)
 {
 	int rv;
 	int blk = blksz_in_bits / 8;
@@ -235,10 +708,10 @@ static inline int rsa_ecc_soc_input_copy_4(int inp_data_fmt,
 }
 
 static inline int rsa_ecc_soc_input_copy_5(int inp_data_fmt, 
-		int word_bigendian, char *mem, int blksz_in_bits,
-		char *a, int alen_in_bits, char *b, int blen_in_bits,
-		char *c, int clen_in_bits, char *d, int dlen_in_bits,
-		char *e, int elen_in_bits)
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits,
+		unsigned char *e, int elen_in_bits)
 {
 	int rv;
 	int blk = blksz_in_bits / 8;
@@ -256,10 +729,10 @@ static inline int rsa_ecc_soc_input_copy_5(int inp_data_fmt,
 }
 
 static inline int rsa_ecc_soc_input_copy_6(int inp_data_fmt, 
-		int word_bigendian, char *mem, int blksz_in_bits,
-		char *a, int alen_in_bits, char *b, int blen_in_bits,
-		char *c, int clen_in_bits, char *d, int dlen_in_bits,
-		char *e, int elen_in_bits, char *f, int flen_in_bits)
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits,
+		unsigned char *e, int elen_in_bits, unsigned char *f, int flen_in_bits)
 {
 	int rv;
 	int blk = blksz_in_bits / 8;
@@ -277,8 +750,8 @@ static inline int rsa_ecc_soc_input_copy_6(int inp_data_fmt,
 }
 	
 static inline int rsa_ecc_soc_result_copy_1(int res_data_fmt, 
-		int word_bigendian, char *a, int alen_in_bits,
-		char *mem, int blksz_in_bits)
+		int word_bigendian, unsigned char *a, int alen_in_bits,
+		unsigned char *mem, int blksz_in_bits)
 {
 	int rv;
 
@@ -289,8 +762,8 @@ static inline int rsa_ecc_soc_result_copy_1(int res_data_fmt,
 
 static inline int rsa_ecc_soc_result_copy_2(int res_data_fmt, 
 		int word_bigendian, 
-		char *a, int alen_in_bits, char *b, int blen_in_bits, 
-		char *mem, int blksz_in_bits)
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits, 
+		unsigned char *mem, int blksz_in_bits)
 {
 
 	int rv;
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
index 5a58042..2372b0d 100644
--- a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
@@ -145,26 +145,26 @@ static inline char *rsasoc_get_op_func(int val, char *buf)
 static inline void rsasoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 {
 	char buf[32], buf1[32];
-	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n",
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n",
 			"SrcL3Alloc","Type", "Func", "SrcAddr");
 
-	cryptosoc_dbg_print("  %-16lld %-16s %-16s %-16llx\n",
+	cryptosoc_print("  %-16lld %-16s %-16s %-16llx\n",
 			RSASOC_GEN1_GET_BITS(entry0, SRC_L3_ALLOC),
 			rsasoc_get_op_type(RSASOC_GEN1_GET_BITS(entry0, TYPE), buf),
 			rsasoc_get_op_func(RSASOC_GEN1_GET_BITS(entry0, FUNC), buf1),
 			RSASOC_GEN1_GET_BITS(entry0, SRC_ADDR));
 
-	cryptosoc_dbg_print("\n  %-16s %-16s %-16s %-16s\n",
+	cryptosoc_print("\n  %-16s %-16s %-16s %-16s\n",
 			"DstClobber","DstL3Alloc", "FbVC", "DstAddr");
 
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx\n",
 			RSASOC_GEN1_GET_BITS(entry1, DST_CLOBBER),
 			RSASOC_GEN1_GET_BITS(entry1, DST_L3_ALLOC),
 			RSASOC_GEN1_GET_BITS(entry1, FBVC),
 			RSASOC_GEN1_GET_BITS(entry1, DST_ADDR));
 
-	cryptosoc_dbg_print("\n");
+	cryptosoc_print("\n");
 
 }
 
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h
deleted file mode 100644
index f22dd10..0000000
--- a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_ucode.h
+++ /dev/null
@@ -1,962 +0,0 @@
-
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-#ifndef _RSASOC_GEN1_UCODE_H
-#define _RSASOC_GEN1_UCODE_H
-static uint64_t  rsasoc_ucode_data [] = {
-0x0000000000000000ULL,
-0x00000000503840ecULL,
-0x00000001903800ecULL,
-0x00000002c03820ecULL,
-0x0000003760000044ULL,
-0x0000000000000014ULL,
-0x000000071000000cULL,
-0x00000007d000010cULL,
-0x0000001b80000c0cULL,
-0x00000000e03fc0ecULL,
-0x00000001103fc1ecULL,
-0x00000001403f42ecULL,
-0x00000001403fc4ecULL,
-0x0000003760000044ULL,
-0x000000001800003cULL,
-0x0000000d8000030cULL,
-0x0000000630000044ULL,
-0x000000002800003cULL,
-0x0000000ef000030cULL,
-0x0000000630000044ULL,
-0x00000000503fc23cULL,
-0x00000000a03fc33cULL,
-0x00000001403fc43cULL,
-0x00000010c000030cULL,
-0x0000000630000044ULL,
-0x0000000000000014ULL,
-0x000000071000000cULL,
-0x0000001c1000070cULL,
-0x0000002500000d0cULL,
-0x00000027c0000e0cULL,
-0x0000002d60000f0cULL,
-0x00000002603f00ecULL,
-0x00000002603f82ecULL,
-0x00000002803f83ecULL,
-0x00000002803f04ecULL,
-0x00000002a03f06ecULL,
-0x00000002a03f88ecULL,
-0x0000003760000044ULL,
-0x000000086000010cULL,
-0x00000003f0000044ULL,
-0x00000008d000010cULL,
-0x00000004b0000044ULL,
-0x00000008d000010cULL,
-0x0000000570000044ULL,
-0x000000000000001cULL,
-0x000000076000000cULL,
-0x0000001c1000070cULL,
-0x0000002690000d0cULL,
-0x0000002990000e0cULL,
-0x0000002e10000f0cULL,
-0x00000003903f20ecULL,
-0x00000003903fa2ecULL,
-0x00000003b03fa3ecULL,
-0x00000003b03f24ecULL,
-0x00000003d03f26ecULL,
-0x00000003d03fa8ecULL,
-0x0000003760000044ULL,
-0x000000096000010cULL,
-0x00000003f0000044ULL,
-0x0000000a0000010cULL,
-0x00000004b0000044ULL,
-0x0000000a0000010cULL,
-0x0000000570000044ULL,
-0x000000000800003cULL,
-0x0000000af000020cULL,
-0x0000000bc000030cULL,
-0x000000129000040cULL,
-0x000000178000050cULL,
-0x000000191000060cULL,
-0x0000001ff000080cULL,
-0x000000205000090cULL,
-0x00000022c0000a0cULL,
-0x00000020b0000b0cULL,
-0x0000001ac0000c0cULL,
-0x0000000680000044ULL,
-0x000000001000003cULL,
-0x0000000b5000020cULL,
-0x0000000c5000030cULL,
-0x000000137000040cULL,
-0x00000017e000050cULL,
-0x000000197000060cULL,
-0x000000200000080cULL,
-0x000000206000090cULL,
-0x0000002340000a0cULL,
-0x0000002110000b0cULL,
-0x0000001b10000c0cULL,
-0x0000000680000044ULL,
-0x000000001800003cULL,
-0x0000000b5000020cULL,
-0x0000000d8000030cULL,
-0x000000154000040cULL,
-0x000000187000050cULL,
-0x0000001a0000060cULL,
-0x000000202000080cULL,
-0x000000208000090cULL,
-0x0000002410000a0cULL,
-0x00000021c0000b0cULL,
-0x0000001b80000c0cULL,
-0x0000000680000044ULL,
-0x000000000000000aULL,
-0x0000000000000024ULL,
-0x0000002ed01f80e4ULL,
-0x00000030101f81e4ULL,
-0x0000003760000044ULL,
-0x000000000000000aULL,
-0x0000000000000024ULL,
-0x00000030d01f00e4ULL,
-0x00000030d01f82e4ULL,
-0x00000034801f83e4ULL,
-0x00000035401e04e4ULL,
-0x00000037101f88e4ULL,
-0x00000035401f89e4ULL,
-0x0000003760000044ULL,
-0x0000000000000074ULL,
-0x0000000f0000008cULL,
-0x00000008000000a4ULL,
-0x000000080400007bULL,
-0x00000000000000c4ULL,
-0x0000000000000074ULL,
-0x0000000c000000a4ULL,
-0x0000000004004071ULL,
-0x0000000b0000008cULL,
-0x00000008000000a4ULL,
-0x000000080400007bULL,
-0x00000000000000c4ULL,
-0x000000034c0b4091ULL,
-0x0000000b040b0093ULL,
-0x0000000000000000ULL,
-0x0000000004000802ULL,
-0x00000002c88b0021ULL,
-0x0000000a828b0423ULL,
-0x00000010000000a4ULL,
-0x000000081000006cULL,
-0x00000000000000c4ULL,
-0x000000004c0b4091ULL,
-0x00000008000000a4ULL,
-0x0000000002000402ULL,
-0x000000004a8b0021ULL,
-0x00000010000000a4ULL,
-0x000000089000006cULL,
-0x00000000000000c4ULL,
-0x000000034c0b4091ULL,
-0x0000000b040b0093ULL,
-0x00000008000000a4ULL,
-0x0000000002000402ULL,
-0x00000002c88b0021ULL,
-0x0000000a828b0423ULL,
-0x00000010000000a4ULL,
-0x000000091000006cULL,
-0x00000000000000c4ULL,
-0x000000004c0b4091ULL,
-0x00000008000000a4ULL,
-0x0000000002000402ULL,
-0x000000004a8b0021ULL,
-0x00000010000000a4ULL,
-0x0000000990000064ULL,
-0x000000004a8b0021ULL,
-0x0000000000898611ULL,
-0x0000000c000000a4ULL,
-0x00000000000000c4ULL,
-0x000000034c0b4091ULL,
-0x0000000b040b0093ULL,
-0x00000008000000a4ULL,
-0x0000000002000402ULL,
-0x00000002c88b0021ULL,
-0x0000000a828b0423ULL,
-0x00000010000000a4ULL,
-0x0000000a40000064ULL,
-0x0000000088800021ULL,
-0x0000000880800423ULL,
-0x00000000001004a1ULL,
-0x0000000c000000a4ULL,
-0x00000002c88b0061ULL,
-0x0000000a808b0463ULL,
-0x00000000000000c4ULL,
-0x00000000058f0011ULL,
-0x0000000001860002ULL,
-0x00000010000000a4ULL,
-0x00000000000000ccULL,
-0x000000004d8f0021ULL,
-0x0000000b10000044ULL,
-0x00000007058f0013ULL,
-0x0000000001860002ULL,
-0x00000010000000a4ULL,
-0x00000000000000ccULL,
-0x000000034c0f0021ULL,
-0x0000000b058f0423ULL,
-0x0000000b70000044ULL,
-0x0000000000180001ULL,
-0x000000000b600031ULL,
-0x00000008000000a4ULL,
-0x0000000004800041ULL,
-0x00000008000000a4ULL,
-0x0000000007c03f41ULL,
-0x00000000440ac491ULL,
-0x00000004000000a4ULL,
-0x00000000000000c4ULL,
-0x0000000010180001ULL,
-0x0000000088a00031ULL,
-0x00000002c3430431ULL,
-0x00000004000000a4ULL,
-0x0000000204938041ULL,
-0x00000008000000a4ULL,
-0x000000012c002b41ULL,
-0x0000000117982861ULL,
-0x0000000088a03631ULL,
-0x00000002c3430c31ULL,
-0x00000004000000a4ULL,
-0x0000000204938041ULL,
-0x00000008000000a4ULL,
-0x000000012c002b41ULL,
-0x0000000347cb2861ULL,
-0x000000034c09f691ULL,
-0x00000003040a8491ULL,
-0x0000000000000000ULL,
-0x00000000000000c4ULL,
-0x0000000010180001ULL,
-0x0000000088a00031ULL,
-0x00000002c0830431ULL,
-0x0000000283430431ULL,
-0x000000080000009cULL,
-0x0000000204938041ULL,
-0x00000008000000a4ULL,
-0x000000012c002b41ULL,
-0x0000000104202861ULL,
-0x0000000117d82861ULL,
-0x0000000088a02f31ULL,
-0x00000002c0833c31ULL,
-0x0000002283430c3bULL,
-0x0000000000000000ULL,
-0x0000000204938041ULL,
-0x00000008000000a4ULL,
-0x000000012c002b41ULL,
-0x00000003442b2861ULL,
-0x0000000307cb2861ULL,
-0x000000034c09ef91ULL,
-0x000000030409bc91ULL,
-0x00000003040a8491ULL,
-0x00000000000000c4ULL,
-0x0000000010180001ULL,
-0x0000000088a00031ULL,
-0x00000002c0830431ULL,
-0x0000000280830431ULL,
-0x0000000280c30431ULL,
-0x0000000004900041ULL,
-0x0000000283430531ULL,
-0x0000000a00038007ULL,
-0x0000000000000000ULL,
-0x000000012c002b41ULL,
-0x0000000344202861ULL,
-0x0000001304032863ULL,
-0x0000000317db2861ULL,
-0x00000000b8a02b31ULL,
-0x00000002c0832831ULL,
-0x0000000280832831ULL,
-0x0000000280c33c31ULL,
-0x0000000004900041ULL,
-0x0000002e83430d3bULL,
-0x0000000200038000ULL,
-0x0000000000000000ULL,
-0x000000012c002b41ULL,
-0x00000003442b2861ULL,
-0x00000013040b2863ULL,
-0x0000000307cb2861ULL,
-0x000000037c09eb91ULL,
-0x000000130409a893ULL,
-0x000000030409bc91ULL,
-0x00000003040a849dULL,
-0x0000000010180001ULL,
-0x0000000088a00031ULL,
-0x00000002c0830431ULL,
-0x0000000280830431ULL,
-0x0000000280c30431ULL,
-0x0000000004900041ULL,
-0x0000000280830531ULL,
-0x0000001e80830433ULL,
-0x0000000283430431ULL,
-0x0000000b2c03ab67ULL,
-0x0000000344202861ULL,
-0x0000001304032863ULL,
-0x0000000317db2861ULL,
-0x00000002b8a3ab31ULL,
-0x00000002c0832831ULL,
-0x0000000280832831ULL,
-0x0000000280c32831ULL,
-0x0000000004900041ULL,
-0x0000000280832931ULL,
-0x0000001e80832833ULL,
-0x0000002e83430c3bULL,
-0x000000032c03ab61ULL,
-0x00000003442b2861ULL,
-0x00000013040b2863ULL,
-0x0000000307cb2861ULL,
-0x000000037c09eb91ULL,
-0x000000130409a893ULL,
-0x000000030409bc91ULL,
-0x00000003040a849dULL,
-0x0000000000140001ULL,
-0x0000004000140001ULL,
-0x000000000b600061ULL,
-0x000000400b600061ULL,
-0x00000004000000a4ULL,
-0x0000000004800041ULL,
-0x0000004004800041ULL,
-0x00000004000000a4ULL,
-0x0000000007c03f41ULL,
-0x0000004007c03f41ULL,
-0x00000000440ac591ULL,
-0x00000040440ac591ULL,
-0x0000000000000000ULL,
-0x00000000000000c4ULL,
-0x0000000010140001ULL,
-0x0000004010140001ULL,
-0x0000000088e00061ULL,
-0x0000004088e00061ULL,
-0x00000002c3430561ULL,
-0x00000042c3430561ULL,
-0x0000000204938041ULL,
-0x0000004204938041ULL,
-0x00000004000000a4ULL,
-0x000000012c402b41ULL,
-0x000000412c402b41ULL,
-0x0000000117f42961ULL,
-0x0000004117f42961ULL,
-0x0000000088e03f61ULL,
-0x0000004088e03f61ULL,
-0x00000002c3430d61ULL,
-0x00000042c3430d61ULL,
-0x0000000204938041ULL,
-0x0000004204938041ULL,
-0x00000004000000a4ULL,
-0x000000012c402b41ULL,
-0x000000412c402b41ULL,
-0x0000000347eb2961ULL,
-0x0000004347eb2961ULL,
-0x000000034c7dff91ULL,
-0x000000434c7dff91ULL,
-0x00000003040a0591ULL,
-0x00000043040a0591ULL,
-0x00000000000000c4ULL,
-0x0000000010140001ULL,
-0x0000004010140001ULL,
-0x0000000088e00061ULL,
-0x0000004088e00061ULL,
-0x00000002c0c30561ULL,
-0x00000042c0c30561ULL,
-0x0000000004900041ULL,
-0x0000004004900041ULL,
-0x0000000283430561ULL,
-0x0000004283430561ULL,
-0x0000000b2c43ab47ULL,
-0x000000432c43ab41ULL,
-0x0000000344602961ULL,
-0x0000004344602961ULL,
-0x0000000317d72961ULL,
-0x0000004317d72961ULL,
-0x00000002b8e3ab61ULL,
-0x00000042b8e3ab61ULL,
-0x00000002c0c32961ULL,
-0x00000042c0c32961ULL,
-0x0000000004900041ULL,
-0x0000004004900041ULL,
-0x0000000283430d61ULL,
-0x0000007683430d6bULL,
-0x000000032c43ab41ULL,
-0x000000432c43ab41ULL,
-0x00000003446b2961ULL,
-0x00000043446b2961ULL,
-0x0000000307cb2961ULL,
-0x0000004307cb2961ULL,
-0x000000037c7de791ULL,
-0x000000437c7de791ULL,
-0x0000000304499d91ULL,
-0x0000004304499d91ULL,
-0x00000003040a0591ULL,
-0x00000043040a059dULL,
-0x0000000048840011ULL,
-0x00000000028b3691ULL,
-0x000000000e09c691ULL,
-0x000000000c09c691ULL,
-0x0000000000000000ULL,
-0x00000000000000c4ULL,
-0x00000000c8840011ULL,
-0x0000000212ab3691ULL,
-0x0000000080800411ULL,
-0x0000000002cb3691ULL,
-0x000000034c29ef91ULL,
-0x0000000006098491ULL,
-0x000000034c09ef91ULL,
-0x0000000004098491ULL,
-0x00000000000000c4ULL,
-0x00000000e8840011ULL,
-0x0000000210ab3a91ULL,
-0x0000000880800415ULL,
-0x00000006128b3699ULL,
-0x000000034c29eb91ULL,
-0x0000000f0409a893ULL,
-0x0000000026098891ULL,
-0x000000034c09eb91ULL,
-0x0000000f0409a893ULL,
-0x000000000409849dULL,
-0x0000000048841011ULL,
-0x00000000068b7691ULL,
-0x000000000e099611ULL,
-0x000000000c098611ULL,
-0x0000000000000000ULL,
-0x00000000000000c4ULL,
-0x00000000c8840011ULL,
-0x0000000216ab7691ULL,
-0x0000000080801411ULL,
-0x0000000006cb3691ULL,
-0x000000034c29af11ULL,
-0x0000000006099411ULL,
-0x000000034c09af11ULL,
-0x0000000004098411ULL,
-0x00000000000000c4ULL,
-0x00000000e8840011ULL,
-0x0000000214ab7a91ULL,
-0x0000000c80800415ULL,
-0x00000006168b3699ULL,
-0x0000000080801411ULL,
-0x00000002168b3691ULL,
-0x000000034c29ab11ULL,
-0x0000000f0409a813ULL,
-0x0000000026099811ULL,
-0x000000034c09ab11ULL,
-0x0000000f0409a813ULL,
-0x000000000409841dULL,
-0x0000000c000000d4ULL,
-0x0000000000000000ULL,
-0x000000004a801011ULL,
-0x000000000e004691ULL,
-0x000000000009800dULL,
-0x0000000c000000d4ULL,
-0x000000004a801011ULL,
-0x000000018c004691ULL,
-0x0000000000800411ULL,
-0x0000000006003691ULL,
-0x0000000200098001ULL,
-0x000000000009800dULL,
-0x0000000c000000d4ULL,
-0x000000004a801011ULL,
-0x000000018c004691ULL,
-0x0000000c00800415ULL,
-0x0000000584003699ULL,
-0x0000000000800411ULL,
-0x0000000006003691ULL,
-0x0000000a00098003ULL,
-0x000000000009800dULL,
-0x000000200000302aULL,
-0x00000000000e0012ULL,
-0x0000000000100211ULL,
-0x0000000002000002ULL,
-0x00000006000b0003ULL,
-0x0000000000000000ULL,
-0x00000000000000ccULL,
-0x0000000006000302ULL,
-0x00000002810b0011ULL,
-0x0000000a808b0013ULL,
-0x0000000002010002ULL,
-0x00000006108b0093ULL,
-0x0000000002800002ULL,
-0x00000007040b0013ULL,
-0x0000000006800002ULL,
-0x00000007040b0013ULL,
-0x0000000003000002ULL,
-0x0000000000090101ULL,
-0x0000000200098001ULL,
-0x0000000a000b0003ULL,
-0x0000000007000302ULL,
-0x0000000400890015ULL,
-0x0000000784098019ULL,
-0x0000000007800002ULL,
-0x0000000000090001ULL,
-0x0000000000098101ULL,
-0x0000001dd000006cULL,
-0x000000280300060aULL,
-0x0000000000000000ULL,
-0x0000000000000e02ULL,
-0x0000000001000011ULL,
-0x00000010000000a4ULL,
-0x0000001dc0000064ULL,
-0x0000000000000f02ULL,
-0x0000000001000011ULL,
-0x0000000002000602ULL,
-0x0000000680890013ULL,
-0x0000000002806002ULL,
-0x0000000004000011ULL,
-0x000000031489f691ULL,
-0x0000000804000415ULL,
-0x000000071489b699ULL,
-0x0000000006000e02ULL,
-0x0000000680890013ULL,
-0x0000000006800e02ULL,
-0x0000000680898013ULL,
-0x0000002c0300540aULL,
-0x0000000007800012ULL,
-0x00000000000b8000ULL,
-0x000000000700cd42ULL,
-0x0000000000800011ULL,
-0x000000029489f691ULL,
-0x0000000800800415ULL,
-0x000000069489b699ULL,
-0x000000200000e02aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000001dc0000064ULL,
-0x000000240000c02aULL,
-0x0000000002000012ULL,
-0x0000000600090003ULL,
-0x00000000000000c4ULL,
-0x000000001680409dULL,
-0x0000000014804091ULL,
-0x000000001680049dULL,
-0x0000000014804091ULL,
-0x0000000014800491ULL,
-0x000000001680049dULL,
-0x000000001680419dULL,
-0x0000000014804191ULL,
-0x000000001680049dULL,
-0x0000000014804191ULL,
-0x0000000014800491ULL,
-0x000000001680049dULL,
-0x0000000000800011ULL,
-0x00000000068b5691ULL,
-0x0000000004098611ULL,
-0x000000000700dc22ULL,
-0x0000000000800011ULL,
-0x0000000296cb569dULL,
-0x0000000000800011ULL,
-0x0000000294ab7691ULL,
-0x0000000000801411ULL,
-0x00000000068b3691ULL,
-0x000000034409af11ULL,
-0x0000000004098411ULL,
-0x000000000700dc22ULL,
-0x0000000000800011ULL,
-0x00000002948b7691ULL,
-0x0000000000801411ULL,
-0x0000000296cb369dULL,
-0x0000000000800011ULL,
-0x0000000294ab7691ULL,
-0x0000000000800411ULL,
-0x00000002948b3691ULL,
-0x0000000000801411ULL,
-0x00000000068b3a91ULL,
-0x000000034409ab11ULL,
-0x000000030409a411ULL,
-0x0000000004098411ULL,
-0x000000000700dc22ULL,
-0x0000000000800011ULL,
-0x00000002948b7691ULL,
-0x0000000000800411ULL,
-0x00000002948b3691ULL,
-0x0000000000801411ULL,
-0x0000000296cb369dULL,
-0x0000000001000011ULL,
-0x0000000006098611ULL,
-0x0000000000000000ULL,
-0x0000000007000e02ULL,
-0x0000000000888061ULL,
-0x0000000003000602ULL,
-0x0000000000888061ULL,
-0x00000000000984edULL,
-0x0000000001000011ULL,
-0x0000000b8409b615ULL,
-0x0000000400800419ULL,
-0x000000000609b611ULL,
-0x0000000007000e02ULL,
-0x0000000080800061ULL,
-0x0000000200cb0461ULL,
-0x00000000000b8000ULL,
-0x0000000003000602ULL,
-0x0000000080800061ULL,
-0x0000000200cb0461ULL,
-0x00000000000b8001ULL,
-0x00000000000985edULL,
-0x0000000001000011ULL,
-0x0000000b8409b615ULL,
-0x0000000400800419ULL,
-0x000000000609b611ULL,
-0x0000000007000e02ULL,
-0x0000000080800061ULL,
-0x00000002808b0461ULL,
-0x0000000200cb0461ULL,
-0x00000000000b8000ULL,
-0x0000000003000602ULL,
-0x0000000080800061ULL,
-0x00000002808b0461ULL,
-0x0000000200cb0461ULL,
-0x00000000000b8001ULL,
-0x00000000000985edULL,
-0x0000000002800002ULL,
-0x000000500220220aULL,
-0x000000140606550aULL,
-0x000000140606c50aULL,
-0x0000000002a01202ULL,
-0x000000500680100aULL,
-0x000000140286550aULL,
-0x000000000300d502ULL,
-0x000000500220340aULL,
-0x000000140306660aULL,
-0x000000140686c40aULL,
-0x000000140206660aULL,
-0x000000000600dd02ULL,
-0x000000500720550aULL,
-0x0000001806064c0aULL,
-0x000000180306c60aULL,
-0x0000000002001102ULL,
-0x000000500020c50aULL,
-0x000000000600e402ULL,
-0x000000500220440aULL,
-0x000000140606cc0aULL,
-0x000000000320d602ULL,
-0x000000500100e50aULL,
-0x000000180086c60aULL,
-0x00000000000000c4ULL,
-0x0000000002000002ULL,
-0x0000005002a0210aULL,
-0x000000140280540aULL,
-0x0000000003005502ULL,
-0x000000500620200aULL,
-0x000000140680c50aULL,
-0x0000000002004402ULL,
-0x0000005003a0cc0aULL,
-0x0000000002a03702ULL,
-0x000000500700c50aULL,
-0x000000140280650aULL,
-0x000000140280e50aULL,
-0x000000000000c502ULL,
-0x000000500120c70aULL,
-0x000000000200c402ULL,
-0x0000005000a0d50aULL,
-0x0000000000000000ULL,
-0x000000140080410aULL,
-0x00000000000000c4ULL,
-0x0000000006009202ULL,
-0x000000500220a10aULL,
-0x0000001806064c0aULL,
-0x0000000002808202ULL,
-0x0000005006a0a00aULL,
-0x000000180706d50aULL,
-0x000000000320cc02ULL,
-0x000000500280ee0aULL,
-0x0000000006a0d502ULL,
-0x000000500780a20aULL,
-0x000000140386dd0aULL,
-0x000000000300f602ULL,
-0x0000005002a0e50aULL,
-0x000000180306560aULL,
-0x0000000000000000ULL,
-0x000000180306760aULL,
-0x0000001806866d0aULL,
-0x000000000380f502ULL,
-0x0000005007a0450aULL,
-0x000000300281070aULL,
-0x000000200000502aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000002bc000006cULL,
-0x000000000600dc02ULL,
-0x000000500020e60aULL,
-0x000000180086fc0aULL,
-0x000000140107170aULL,
-0x00000000000000c4ULL,
-0x000000000200a102ULL,
-0x000000500620920aULL,
-0x000000140600c40aULL,
-0x000000000200a002ULL,
-0x0000005006a0820aULL,
-0x000000140680d40aULL,
-0x000000140200dc0aULL,
-0x000000000700a202ULL,
-0x0000005002a0dd0aULL,
-0x000000000300c402ULL,
-0x0000005003a0350aULL,
-0x0000000000000000ULL,
-0x000000140300670aULL,
-0x000000000380d502ULL,
-0x0000005007a0e60aULL,
-0x0000000000000000ULL,
-0x0000001407807f0aULL,
-0x000000000380d102ULL,
-0x000000500320c00aULL,
-0x0000000000000000ULL,
-0x000000140380760aULL,
-0x0000000003007502ULL,
-0x0000005002a0d50aULL,
-0x000000000200f402ULL,
-0x0000005003a0e50aULL,
-0x000000300281070aULL,
-0x000000200000502aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000002bc000006cULL,
-0x000000000000df02ULL,
-0x0000005000a0a60aULL,
-0x000000140101170aULL,
-0x000000140080410aULL,
-0x00000000000000c4ULL,
-0x000000300281020aULL,
-0x0000003006810a0aULL,
-0x0000003006010c0aULL,
-0x000000200000202aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000002d1000006cULL,
-0x000000200000a02aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000002d5000006cULL,
-0x000000200000c02aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000002cd0000064ULL,
-0x00000034000000d4ULL,
-0x00000000000000c4ULL,
-0x0000000001000002ULL,
-0x00000006000b0003ULL,
-0x0000000000000000ULL,
-0x00000000000000c4ULL,
-0x000000140001180aULL,
-0x000000140081190aULL,
-0x0000001401011a0aULL,
-0x00000000000000c4ULL,
-0x00000000000000c4ULL,
-0x0000000001810302ULL,
-0x0000005005a10b0aULL,
-0x0000000002000002ULL,
-0x000000500620110aULL,
-0x000000140206340aULL,
-0x000000180606cb0aULL,
-0x0000000002000402ULL,
-0x0000005006210c0aULL,
-0x000000140206c40aULL,
-0x000000300201040aULL,
-0x00000000000000c4ULL,
-0x0000000002801002ULL,
-0x0000005005a10b0aULL,
-0x000000140286b50aULL,
-0x000000140186300aULL,
-0x0000000002000002ULL,
-0x000000500620110aULL,
-0x000000140606c50aULL,
-0x0000000002003402ULL,
-0x0000005006210c0aULL,
-0x000000140206c40aULL,
-0x000000300201040aULL,
-0x00000000000000c4ULL,
-0x000000040400000aULL,
-0x000000000000002cULL,
-0x0000000c0000800eULL,
-0x0000000c0400880aULL,
-0x000000080000007cULL,
-0x0000000004000002ULL,
-0x00000006808b0013ULL,
-0x0000000000000034ULL,
-0x0000000000000002ULL,
-0x0000002ff000005cULL,
-0x0000002f4000004cULL,
-0x00000002000b0101ULL,
-0x0000000a000b0003ULL,
-0x0000003760000044ULL,
-0x0000000000000034ULL,
-0x0000000c0000000aULL,
-0x0000002ff0000054ULL,
-0x0000000c0000800aULL,
-0x0000002fb000004cULL,
-0x0000003640000044ULL,
-0x0000000c0000800aULL,
-0x000000040400000aULL,
-0x000000000000002cULL,
-0x0000000c0000800eULL,
-0x0000000c0400880aULL,
-0x000000080000007cULL,
-0x000000040400000aULL,
-0x000000000000002cULL,
-0x0000000c0000800eULL,
-0x0000000c0400880aULL,
-0x000000080000007cULL,
-0x0000003640000044ULL,
-0x000000080180000aULL,
-0x0000000001820002ULL,
-0x00000007040b0013ULL,
-0x000000040200000aULL,
-0x000000000000002cULL,
-0x0000000c0180430eULL,
-0x0000000c0200440aULL,
-0x000000080000007cULL,
-0x0000000001010002ULL,
-0x00000006108b0093ULL,
-0x0000000005010002ULL,
-0x00000006108b0093ULL,
-0x0000000000000000ULL,
-0x00000032e01f80e4ULL,
-0x00000034401f81e4ULL,
-0x00000034601f82e4ULL,
-0x0000000c0181020aULL,
-0x0000000c0181030aULL,
-0x0000001c000000d4ULL,
-0x0000000000004002ULL,
-0x0000005000a0410aULL,
-0x0000000001004202ULL,
-0x000000500021000aULL,
-0x0000000000810102ULL,
-0x000000500121020aULL,
-0x000000200000202aULL,
-0x00000000000000fcULL,
-0x0000000c000000a4ULL,
-0x0000000000000002ULL,
-0x0000000600098003ULL,
-0x0000000000810002ULL,
-0x0000000610898093ULL,
-0x0000003760000044ULL,
-0x0000000004000002ULL,
-0x00000006808b0013ULL,
-0x0000000004800102ULL,
-0x00000006808b0013ULL,
-0x0000000005000202ULL,
-0x00000006808b0013ULL,
-0x0000000000000034ULL,
-0x0000000000000002ULL,
-0x000000342000005cULL,
-0x000000334000004cULL,
-0x0000001000000084ULL,
-0x00000006000b0009ULL,
-0x00000002000b0101ULL,
-0x0000002000000084ULL,
-0x00000006000b0009ULL,
-0x0000003760000044ULL,
-0x0000000000000034ULL,
-0x00000034000000d4ULL,
-0x0000003420000054ULL,
-0x00000038000000d4ULL,
-0x00000033e000004cULL,
-0x00000031d0000044ULL,
-0x00000038000000d4ULL,
-0x00000031d0000044ULL,
-0x00000034000000d4ULL,
-0x00000031d0000044ULL,
-0x000000080180000aULL,
-0x0000000001820002ULL,
-0x00000007040b0013ULL,
-0x0000000005840002ULL,
-0x00000007040b0013ULL,
-0x0000003c000000d4ULL,
-0x00000004000000a4ULL,
-0x000000200000402aULL,
-0x0000000000000012ULL,
-0x00000000000b0001ULL,
-0x0000000000098101ULL,
-0x0000003760000044ULL,
-0x000000040200000aULL,
-0x000000000000002cULL,
-0x0000000c0000400eULL,
-0x0000000c0200440aULL,
-0x000000080000007cULL,
-0x00000036c01f87e4ULL,
-0x00000036401f89e4ULL,
-0x000000040200000aULL,
-0x000000000000002cULL,
-0x0000000c0400480eULL,
-0x0000000c0200440aULL,
-0x000000080000007cULL,
-0x00000036a01f86e4ULL,
-0x000000080180000aULL,
-0x00000036601f84e4ULL,
-0x00000036801f85e4ULL,
-0x000000300001000aULL,
-0x0000003760000044ULL,
-0x000000140006800aULL,
-0x0000003640000044ULL,
-0x000000180006800aULL,
-0x0000003640000044ULL,
-0x0000000c0000800aULL,
-0x0000003640000044ULL,
-0x0000000c0181080aULL,
-0x0000001c000000d4ULL,
-0x00000004000000a4ULL,
-0x0000000c0000400aULL,
-0x0000003640000044ULL,
-0x0000000c0181000aULL,
-0x0000001c000000d4ULL,
-0x00000004000000a4ULL,
-0x000000140001140aULL,
-0x0000003640000044ULL,
-0x0000000c000000a4ULL,
-0x0000000000000044ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-0x0000000000000000ULL,
-};
-
-#endif				/**/
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
index a9affc6..958b01b 100644
--- a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
@@ -613,7 +613,7 @@ static inline int rsasoc_copy_result(struct rsasoc_request_desc *req_desc, int r
 		return -CRYPTOSOC_EINVAL;
 
 	/* Nothing to do if application already passed the 
-	*  data in the required format */
+	*  result address in the required format */
 	if(!dpriv->req_info[req_num].usr_res)
 		return  CRYPTOSOC_OK;
 
@@ -719,7 +719,7 @@ static inline void rsasoc_dump_request_data(
 
 	blk = dpriv->req_info[req_num].blksz_in_bits / 8;
 
-	cryptosoc_dbg_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
+	cryptosoc_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
 			dpriv->req_info[req_num].blksz_in_bits,
 			dpriv->max_reqs, dpriv->num_reqs, 
 			dpriv->req_info[req_num].inp_size, 
@@ -728,14 +728,14 @@ static inline void rsasoc_dump_request_data(
 	mem = dpriv->req_info[req_num].eng_inp;
 
 	for(arg=0; arg < 3; arg++) {
-		cryptosoc_dbg_print("%s\n", p[arg]);
+		cryptosoc_print("%s\n", p[arg]);
 		for(i = 0; i < blk; ) {
-			cryptosoc_dbg_print(" <%016llx>", *(_uint64_t *)(mem + i));
+			cryptosoc_print(" <%016llx>", *(_uint64_t *)(mem + i));
 			i += 8;
 			if((i % 32) == 0)
-				cryptosoc_dbg_print("\n");
+				cryptosoc_print("\n");
 		}
-		cryptosoc_dbg_print("\n");
+		cryptosoc_print("\n");
 		mem = mem + blk;
 	}
 	return;
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
index 6117ce3..417cc34 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
@@ -290,11 +290,11 @@ enum saesoc_gen1_cipher_type {
 static inline void saesoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 {
 
-	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n",
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s \n",
 			"RegFb","DesFbEn", "DesFbLen", "KeyLenInDw", "CtrlDescAddr");
 
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN1_GET_BITS(entry0, REG_FB_DEST_ID),
 			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_EN),
 			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_LEN),
@@ -303,9 +303,9 @@ static inline void saesoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 			 		CRYPTOSOC_CACHELINE_SHIFT));
 
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s \n", 
 			"Arc4StateLdEn", "Hashkeylen", "PktDescLen", "PktDescAddr");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx \n",
 			SAESOC_GEN1_GET_BITS(entry1, ARC4_STATE_LD_EN), 
 			SAESOC_GEN1_GET_BITS(entry1, HASH_KEY_LEN),
 			SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_LEN), 
@@ -325,38 +325,38 @@ static void saesoc_gen1_dump_cdesc(_uint64_t *cdescs, int ndescs)
 	unsigned int type,mode;
 	_uint64_t cdesc = cdescs[0];
 
-	cryptosoc_dbg_print("\ncontrol description info:\n");
-       	cryptosoc_dbg_print(" %-16s \n", "Desc");
-	cryptosoc_dbg_print(" %-16llx\n", (unsigned long long)cdesc);
+	cryptosoc_print("\ncontrol description info:\n");
+       	cryptosoc_print(" %-16s \n", "Desc");
+	cryptosoc_print(" %-16llx\n", (unsigned long long)cdesc);
 
 	type = SAESOC_GEN1_GET_BITS(cdesc, HASH_TYPE); 
 	mode = SAESOC_GEN1_GET_BITS(cdesc, HASH_MODE);
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s \n","Hmac","HashType","HashMode");
-	cryptosoc_dbg_print(" %-16llx %-16s %-16s\n",
+	cryptosoc_print(" %-16s %-16s %-16s \n","Hmac","HashType","HashMode");
+	cryptosoc_print(" %-16llx %-16s %-16s\n",
 			SAESOC_GEN1_GET_BITS(cdesc, HMAC),
 			saesoc_gen1_hash_type[type],saesoc_gen1_hashmode[mode]);
 
 	type =  SAESOC_GEN1_GET_BITS(cdesc,CIPHER_TYPE );
 	mode = SAESOC_GEN1_GET_BITS(cdesc,CIPHER_MODE );
 
-	cryptosoc_dbg_print(" %-16s %-16s\n","CipherType","CipherMode");
-	cryptosoc_dbg_print(" %-16s %-16s\n",saesoc_gen1_cipher_type[type],
+	cryptosoc_print(" %-16s %-16s\n","CipherType","CipherMode");
+	cryptosoc_print(" %-16s %-16s\n",saesoc_gen1_cipher_type[type],
 			saesoc_gen1_cipher_mode[mode]);
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s\n",
+	cryptosoc_print(" %-16s %-16s %-16s\n",
 			"Arc4KeyLen","Arc4KeyInit","CfbMask");
-	cryptosoc_dbg_print(" %-16lld %-16lld %-16llx\n",
+	cryptosoc_print(" %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_LEN),
 			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_INIT),
 			SAESOC_GEN1_GET_BITS(cdesc, CFB_MASK));
 
 	if(ndescs > 1) {
 		int i;
-		cryptosoc_dbg_print("\nKey info:\n");
+		cryptosoc_print("\nKey info:\n");
 		for(i = 1; i < ndescs; i++)
-			cryptosoc_dbg_print("  <%-16llx>", cdescs[i]);
-		cryptosoc_dbg_print("\n");
+			cryptosoc_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_print("\n");
 	}
 }
 
@@ -377,53 +377,53 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 	desc2 = ddesc[nd++];
 	desc3 = ddesc[nd++];
 
-	cryptosoc_dbg_print("\nData Descriptor info:\n");
-	cryptosoc_dbg_print(" %-16s %-16s %-16s %-16s\n",
+	cryptosoc_print("\nData Descriptor info:\n");
+	cryptosoc_print(" %-16s %-16s %-16s %-16s\n",
 			"Desc0","Desc1","Desc2","Desc3");
 
-	cryptosoc_dbg_print(" %-16llx %-16llx %-16llx %-16llx\n",
+	cryptosoc_print(" %-16llx %-16llx %-16llx %-16llx\n",
 			desc0, desc1, desc2,desc3);	
 
-	cryptosoc_dbg_print(" %-16s %-16s\n","TLSProto","HashSource");
-	cryptosoc_dbg_print(" %-16lld %-16lld\n",
+	cryptosoc_print(" %-16s %-16s\n","TLSProto","HashSource");
+	cryptosoc_print(" %-16lld %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,TLS_ENABLE),
 			SAESOC_GEN1_GET_BITS(desc0, HASH_SRC_SEL));
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","HashL3","HashAddr","HashLen");
-	cryptosoc_dbg_print(" %-16lld %-16llx %-16lld\n",
+	cryptosoc_print(" %-16s %-16s %-16s\n","HashL3","HashAddr","HashLen");
+	cryptosoc_print(" %-16lld %-16llx %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,HASH_L3_ALLOCATE ),
 			SAESOC_GEN1_GET_BITS(desc0,HASH_DEST_ADDR ),
 			SAESOC_GEN1_GET_BITS(desc1,HASH_LEN));
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s \n","HashBitCnt","HashClobber",
+	cryptosoc_print(" %-16s %-16s %-16s \n","HashBitCnt","HashClobber",
 			"HashOffset");
-	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc2,HASH_BIT_CNT ),
 		SAESOC_GEN1_GET_BITS(desc2,HASH_CLOBBER ),
 		SAESOC_GEN1_GET_BITS(desc2,HASH_OFFSET ));
 
-	cryptosoc_dbg_print(" %-16s %-16s\n","TagLen","ExtPadKey");
-	cryptosoc_dbg_print(" %-16lld %-16lld\n",
+	cryptosoc_print(" %-16s %-16s\n","TagLen","ExtPadKey");
+	cryptosoc_print(" %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc3, TAGLEN),
 		SAESOC_GEN1_GET_BITS(desc3,HMAC_EXTPAD_KEY ));
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","Encrypt","IVLength",
+	cryptosoc_print(" %-16s %-16s %-16s\n","Encrypt","IVLength",
 			"IVOffset");
-	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN1_GET_BITS(desc0,CIPHER_ENCRYPT ),	
 			SAESOC_GEN1_GET_BITS(desc0,IVLEN ),
 			SAESOC_GEN1_GET_BITS(desc2,IV_OFFSET ));
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","CipherLen","CipherBitCnt",
+	cryptosoc_print(" %-16s %-16s %-16s\n","CipherLen","CipherBitCnt",
 			"CipherOffset");
-	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc1, CIPHER_LEN),
 		SAESOC_GEN1_GET_BITS(desc2, CIPHER_BIT_CNT),
 		SAESOC_GEN1_GET_BITS(desc2, CIPHER_OFFSET));
 
-	cryptosoc_dbg_print(" %-16s %-16s %-16s\n","DesignerFb","Arc4L3",
+	cryptosoc_print(" %-16s %-16s %-16s\n","DesignerFb","Arc4L3",
 			"Arc4SaveState");
-	cryptosoc_dbg_print(" %-16lld %-16lld %-16lld\n",
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
 		SAESOC_GEN1_GET_BITS(desc3, FB_DEST_ID),
 		SAESOC_GEN1_GET_BITS(desc3, ARC4_L3_ALLOC),
 		SAESOC_GEN1_GET_BITS(desc3, ARC4_SAVE_SATE_EN));
@@ -432,31 +432,31 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 		desc0 = ddesc[i++];
 		desc1 = ddesc[i++];
 
-		cryptosoc_dbg_print(
+		cryptosoc_print(
 				"\nPacket Fragment info: Srcfrag %-16llx DstFrag %-16llx\n",
 				desc0, desc1);
 
-		cryptosoc_dbg_print(" %-16s %-16s \n",
+		cryptosoc_print(" %-16s %-16s \n",
 				"SrcFragLen","SrcFragPaddr");
-		cryptosoc_dbg_print(" %-16lld %-16llx\n",
+		cryptosoc_print(" %-16lld %-16llx\n",
                 	SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_LEN),
                		SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_SRC_ADDR));
 
-		cryptosoc_dbg_print(" %-16s %-16s %-16s %-16s\n",
+		cryptosoc_print(" %-16s %-16s %-16s %-16s\n",
 				"DstFragLen","DstFragPaddr", "CipherL3", "CipherClobber");
-		cryptosoc_dbg_print(" %-16lld %-16llx %-16lld %-16lld \n",
+		cryptosoc_print(" %-16lld %-16llx %-16lld %-16lld \n",
                 	SAESOC_GEN1_GET_BITS(desc1, DEST_PAYLOAD_LEN),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_DEST_ADDR),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_L3_ALLOC),
                 	SAESOC_GEN1_GET_BITS(desc1, CIPHER_CLOBBER));
 	}
 	if(ndesfb_descs) {
-		cryptosoc_dbg_print("\nDesigner Fb descs:\n");
+		cryptosoc_print("\nDesigner Fb descs:\n");
 		for(; (i < ndescs); i++) 
-			cryptosoc_dbg_print("  %-16llx", ddesc[i]);
-		cryptosoc_dbg_print("\n");
+			cryptosoc_print("  %-16llx", ddesc[i]);
+		cryptosoc_print("\n");
 	}
-	cryptosoc_dbg_print("\n");
+	cryptosoc_print("\n");
 }
 
 /**
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
index 855a7b7..200c227 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
@@ -360,98 +360,98 @@ static void  saesoc_gen2_dump_cdesc(_uint64_t *cdescs, int ndescs)
 	_uint64_t cdesc1 = cdescs[1];
 
 
-	cryptosoc_dbg_print("\nCtrl Descriptor info:\n");
-	cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-	cryptosoc_dbg_print("  %-16llx %-16llx \n", cdesc0, cdesc1);
+	cryptosoc_print("\nCtrl Descriptor info:\n");
+	cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_print("  %-16llx %-16llx \n", cdesc0, cdesc1);
 
-	cryptosoc_dbg_print("\nHASH info:\n");
+	cryptosoc_print("\nHASH info:\n");
 
 	type = SAESOC_GEN2_GET_BITS(cdesc0, HASH_TYPE);
 	mode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_MODE);
 	ivmode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_MODE);
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s \n", 
+	cryptosoc_print("  %-16s %-16s %-16s \n", 
 			"HashType", "HashMode", "HashIvMode");
-	cryptosoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s \n",
+	cryptosoc_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s \n",
 			type, saesoc_gen2_hash_type_name[type], 
 			mode, saesoc_gen2_hash_mode_name[mode], 
 			ivmode, saesoc_gen2_ivmode_name[ivmode]);
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"HashIvOff", "AadOff",  "HashMuteEn", "HashMuteSel");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_OFFSET), 
 			SAESOC_GEN2_GET_BITS(cdesc0, AAD_OFFSET),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_ENABLE),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_SEL));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"AddlHashLen","HashSrcSel", "HmacKeyLen", "HmacKeyPad");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, ADDL_HASH_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_SRC_SEL), 
 			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_KEY_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_HW_KEY_PAD_ENABLE));
 
-	cryptosoc_dbg_print("  %-16s %-16s\n", "HashL3Alloc", "HashClobber");
-	cryptosoc_dbg_print("  %-16lld %-16lld\n",
+	cryptosoc_print("  %-16s %-16s\n", "HashL3Alloc", "HashClobber");
+	cryptosoc_print("  %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_L3_ALLOCATE), 
 			SAESOC_GEN2_GET_BITS(cdesc0, HASH_CLOBBER));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s\n", 
 			"Chktag", "TaginLoc", "TagoutLoc", "TagLen", "TagInoff");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, CHECK_TAG_ENABLE),  
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_IN_LOC_SEL),
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_OUT_LOC_SEL), 
 			SAESOC_GEN2_GET_BITS(cdesc1, TAG_LEN),
 			SAESOC_GEN2_GET_BITS(cdesc1, TAGIN_OFFSET));
 
-	cryptosoc_dbg_print("\nCIPHER info:\n");
+	cryptosoc_print("\nCIPHER info:\n");
 
 	type = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_TYPE);
 	mode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_MODE);
 	ivmode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_MODE);
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"CipherType", "CipherMode", "CipherIvMode", "CipherPadEn");
-	cryptosoc_dbg_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s    %-16lld\n",
+	cryptosoc_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s    %-16lld\n",
 			type, saesoc_gen2_cipher_type_name[type], 
 			mode, saesoc_gen2_cipher_mode_name[mode], 
 			ivmode, saesoc_gen2_ivmode_name[ivmode], 
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_PAD_ENABLE));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"CipherIvOff", "Encrypt", "Cfbmask", "Arc4Keylen");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_OFFSET),
 			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_ENCRYPT),
 			SAESOC_GEN2_GET_BITS(cdesc1, CFB_MASK),
 			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_KEY_LEN));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"Arc4L3Alloc", "Pktl3Alloc", "PktClobber", "WrModify");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_L3_ALLOCATE),	
 			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_L3_ALLOCATE),	
 			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_CLOBBER), 
 			SAESOC_GEN2_GET_BITS(cdesc0, WR_MODI_ONLY_EN));
 
-	cryptosoc_dbg_print("\nCOMMON info:\n");
+	cryptosoc_print("\nCOMMON info:\n");
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s\n", 
 			"PayloadOff", "Rabin", "TLS");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(cdesc1, PAYLOAD_OFFSET), 
 			SAESOC_GEN2_GET_BITS(cdesc0, RABIN_FINGERPRINT),
 			SAESOC_GEN2_GET_BITS(cdesc0, TLS_ENABLE));
 	
 	if(ndescs > 2) {
 		int i;
-		cryptosoc_dbg_print("\nKey info:\n");
+		cryptosoc_print("\nKey info:\n");
 		for(i = 2; i < ndescs; i++)
-			cryptosoc_dbg_print("  <%-16llx>", cdescs[i]);
-		cryptosoc_dbg_print("\n");
+			cryptosoc_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_print("\n");
 	}
 }
 
@@ -473,45 +473,45 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
 
 	desc0 = ddesc[nd++];
 	desc1 = ddesc[nd++];
-	cryptosoc_dbg_print("\nData Descriptor info:\n");
-	cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-	cryptosoc_dbg_print("  %-16llx %-16llx \n", desc0, desc1);
+	cryptosoc_print("\nData Descriptor info:\n");
+	cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_print("  %-16llx %-16llx \n", desc0, desc1);
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s\n", 
 			"PayloadLen", "CipherPadVal", "AadLen");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld\n",
 			SAESOC_GEN2_GET_BITS(desc0, PAYLOAD_LEN), 
 			SAESOC_GEN2_GET_BITS(desc0, CIPHER_PAD_VAL),
 			SAESOC_GEN2_GET_BITS(desc0, AADLEN));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
 			"Arc4SaveState", "PayloadBitCnt", "DesFbDst", "Tagaddr");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN2_GET_BITS(desc1, ARC4_SAVE_SATE_EN), 
 			SAESOC_GEN2_GET_BITS(desc1, PAY_LOAD_BIT_CNT),
 			SAESOC_GEN2_GET_BITS(desc1, DESC_FB_DEST_ID), 
 			SAESOC_GEN2_GET_BITS(desc1, TAG_DEST_ADDR));
 
 	if(hash_iv_mode == 1) {
-		cryptosoc_dbg_print("\nHash IV info:\n");
-		cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-		cryptosoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		cryptosoc_print("\nHash IV info:\n");
+		cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
 		nd += 2;
 	}
 
 	if(cipher_iv_mode == 1)  {
-		cryptosoc_dbg_print("\nCipher IV info:\n");
-		cryptosoc_dbg_print("  %-16s %-16s \n", "Desc0", "Desc1");
-		cryptosoc_dbg_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		cryptosoc_print("\nCipher IV info:\n");
+		cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
 		nd += 2;
 	}
 
 	for(i = nd; i<ndescs-ndesfb_descs; i++) {	
 		desc = ddesc[i];
-		cryptosoc_dbg_print("\nPacket Fragment info (ind %d Entry %llx):\n", i, desc);
-		cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+		cryptosoc_print("\nPacket Fragment info (ind %d Entry %llx):\n", i, desc);
+		cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s\n", 
 				"DstFrag", "WriteFragDis", "LastFrag", "FragLen", "FragAddr");
-		cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+		cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 				SAESOC_GEN2_GET_BITS(desc, FRAG_TYPE), 
 				SAESOC_GEN2_GET_BITS(desc, WR_FRAG_DIS),
 				SAESOC_GEN2_GET_BITS(desc, LAST_SRC_DESC), 
@@ -519,12 +519,12 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
 				SAESOC_GEN2_GET_BITS(desc, FRAG_ADDR));
 	}
 	if(ndesfb_descs) {
-		cryptosoc_dbg_print("\nDesigner Fb descs:\n");
+		cryptosoc_print("\nDesigner Fb descs:\n");
 		for(; (i < ndescs); i++) 
-			cryptosoc_dbg_print("  %-16llx", ddesc[i]);
-		cryptosoc_dbg_print("\n");
+			cryptosoc_print("  %-16llx", ddesc[i]);
+		cryptosoc_print("\n");
 	}
-	cryptosoc_dbg_print("\n");
+	cryptosoc_print("\n");
 }
 
 /**
@@ -535,10 +535,10 @@ static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
 
 static inline void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1) 
 {
-	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s \n", 
 			"RegFb","DesFbEn", "DesFbLen", "CtrlDescLen", "CtrlDescAddr");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
 			SAESOC_GEN2_GET_BITS(entry0, REG_FB_DEST_ID), 
 			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_EN),
 			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_LEN), 
@@ -546,9 +546,9 @@ static inline void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
 			(SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_ADDR) << 
 			 		CRYPTOSOC_CACHELINE_SHIFT));
 
-	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s \n", 
+	cryptosoc_print("  %-16s %-16s %-16s %-16s \n", 
 			"Arc4StateLdEn", "PktIvLenDW", "PktDescLen", "PktDescAddr");
-	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx \n",
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx \n",
 			SAESOC_GEN2_GET_BITS(entry1, ARC4_STATE_LD_EN), 
 			SAESOC_GEN2_GET_BITS(entry1, PKT_IV_LEN),
 			SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_LEN), 
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
index 8df4582..950857a 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -289,7 +289,7 @@ struct saesoc_cipher_init_params {
 * @iv_mode: iv mode
 * @mute_mask_sel: hash mute mask select. 
 * 			Valid only if HASH_MUTE in the feature flag is set.
-* @tag_len: length of the tag output.
+* @tag_len: length of the tag output in bytes.
 * 			Truncated tag length will be supported only if TRUNC_TAG 
 * 			in the feature flag is set
 * @tagin_offset: Offset from the start of the input where tag is present
@@ -687,7 +687,7 @@ static inline int saesoc_new_session(
 
 			/* Gen1 does not support truncated tag length. The auth-buffer
 			*  should have space for the tag length */
-			if(initp->hash.tag_len <  saesoc_gen1_tag_len[initp->hash.type]) {
+			if(initp->hash.tag_len <  (saesoc_gen1_tag_len[initp->hash.type] / 8)) {
 				cryptosoc_err_print("%s:%d, Error - Tag length is less than required\n", 
 				__FUNCTION__, __LINE__);
 				goto err_exit;
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 17cc7cc..467edea 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -37,6 +37,11 @@
 #ifndef _NLM_HAL_H_
 #define _NLM_HAL_H_
 
+#ifndef NLM_HAL_LINUX_KERNEL
+#include "types.h"
+#endif
+
+
 #include "nlm_hal_macros.h"
 #include "nlm_hal_xlp_dev.h"
 //#include "nlm_nae.h"
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 016f2e9..9341d26 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1157,7 +1157,10 @@ void nlm_hal_set_sae_engine_sel(int node)
 	if(is_nlm_xlp2xx()) {
 		return;
 	}
-	if(is_nlm_xlp3xx())
+	if (is_nlm_xlp9xx())  {
+		/* SEC-TODO */
+
+	} else if(is_nlm_xlp3xx())
 		n = 1;
 	else
 		n = 8;
@@ -1175,7 +1178,11 @@ void nlm_hal_set_rsa_engine_sel(void)
 	if(is_nlm_xlp2xx()) {
 		return;
 	}
-	if(is_nlm_xlp3xx()) {
+
+	if (is_nlm_xlp9xx())  {
+		/* SEC-TODO */
+
+	} else if(is_nlm_xlp3xx()) {
 		n = 1;
 		val = 0xffff;
 	} else {
@@ -1190,7 +1197,10 @@ void nlm_hal_set_rsa_engine_sel(void)
 void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
 {
 
-	if(is_nlm_xlp3xx()) {
+	if (is_nlm_xlp9xx())  {
+		/* SEC-TODO */
+
+	} else if(is_nlm_xlp3xx()) {
 		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
 		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
 	} else if(is_nlm_xlp2xx()) {
@@ -1204,7 +1214,10 @@ void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
 
 void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
 {
-	if(is_nlm_xlp3xx()) {
+	if (is_nlm_xlp9xx())  {
+		/* SEC-TODO */
+
+	} else if(is_nlm_xlp3xx()) {
 		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
 		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
 	} else if(is_nlm_xlp2xx()) {
-- 
1.7.1

