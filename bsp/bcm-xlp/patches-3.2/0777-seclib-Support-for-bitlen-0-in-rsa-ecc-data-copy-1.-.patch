From cb1aae39d4a4cb13d703a89734edcc43bbc7c2bb Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Thu, 22 Aug 2013 20:37:51 +0530
Subject: seclib: Support for bitlen=0 in rsa/ecc data copy 1. Added hal function to set the data swap bit in the rsa_config register

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
index 540596e..fe9ba34 100644
--- a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
+++ b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
@@ -36,6 +36,7 @@
 #ifndef _RSAECC_SOC_COMMON_H
 #define _RSAECC_SOC_COMMON_H
 
+//#define cryptosoc_dbg_print printf
 /* engine request and result data format conversion routine */
 typedef int (*rsa_ecc_soc_data_copy)(int,  unsigned char *, int, unsigned char *, int);
 
@@ -44,7 +45,7 @@ static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian,
 		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
 {
 
-	int i;
+	int i = 0;
 	int dlen = d_nbits / 8;
 	int slen = (s_nbits + 7) / 8;
 	/* Engine format is ms-dword last and in bigendian format.*/
@@ -57,9 +58,11 @@ static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian,
 	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
+	if(slen == 0)
+		goto end;
 
 	/* return error if source length is greater than engine length */
 	if(slen > dlen)
@@ -72,6 +75,7 @@ static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian,
 		*(_uint64_t *)(dst + i) = *(_uint64_t *)src;
 		src -= 8;
 	}
+end:
 	/* clear the extra memory in the last */
 	if(i < dlen)
 		memset((dst + i), 0, (dlen - i));
@@ -138,7 +142,7 @@ static int rsa_ecc_soc_input_copy_fmt_dword_lsdwf(int src_big_endian,
 	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
 
@@ -197,7 +201,7 @@ static int rsa_ecc_soc_input_copy_fmt_word_mswf(int src_big_endian,
 		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
 {
 
-	int i;
+	int i = 0;
 	int dlen = d_nbits / 8;
 	int slen = (s_nbits + 7) / 8;
 	_uint64_t val = 0ULL;
@@ -211,9 +215,11 @@ static int rsa_ecc_soc_input_copy_fmt_word_mswf(int src_big_endian,
 	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
+	if(slen == 0)
+		goto end;
 
 	/* return error if source length is greater than engine length */
 	if(slen > dlen)
@@ -233,6 +239,7 @@ static int rsa_ecc_soc_input_copy_fmt_word_mswf(int src_big_endian,
 	if(slen & 7)
 		*(_uint64_t *)(dst + i - 8) = val & 0xffffffffULL;
 
+end:
 	/* clear the extra memory in the last */
 	if(i < dlen)
 		memset((dst + i), 0, (dlen - i));
@@ -308,7 +315,7 @@ static int rsa_ecc_soc_input_copy_fmt_word_lswf(int src_big_endian,
 	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
 
@@ -387,7 +394,7 @@ static int rsa_ecc_soc_input_copy_fmt_msbf(int src_big_endian,
 		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
 {
 
-	int i, j;
+	int i = 0, j;
 	int dlen = d_nbits / 8;
 	int slen = (s_nbits + 7) / 8;
 	_uint64_t val = 0;
@@ -403,9 +410,12 @@ static int rsa_ecc_soc_input_copy_fmt_msbf(int src_big_endian,
 	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
+	if(slen == 0)
+		goto end;
+
 	/* return error if source length is greater than engine length */
 	if(slen > dlen)
 		return -CRYPTOSOC_EINVAL;
@@ -422,6 +432,7 @@ static int rsa_ecc_soc_input_copy_fmt_msbf(int src_big_endian,
 		}
 		*(_uint64_t *)(dst + i) = val;
 	}
+end:
 	/* clear the extra memory in the last */
 	if(i < dlen)
 		memset((dst + i), 0, (dlen - i));
@@ -497,7 +508,7 @@ static int rsa_ecc_soc_input_copy_fmt_lsbf(int src_big_endian,
 	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
 		return -CRYPTOSOC_EINVAL;
 
-	if(slen == 0 || dlen == 0)
+	if(dlen == 0)
 		return -CRYPTOSOC_EINVAL;
 
 	/* return error if source length is greater than engine length */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 290a202..adb6092 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -156,6 +156,7 @@ extern void nlm_hal_set_dtre_freq(int node, int freq);
 extern void nlm_hal_set_cde_freq(int node, int freq);
 extern void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit);
 extern void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit);
+extern void nlm_hal_set_rsa_data_mode(int node, int bigend_fmt);
 
 #define nlh_read_dev_reg(dev, index) nlm_hal_read_32bit_reg(nlm_hal_get_dev_base(dev), index)
 #define nlh_write_dev_reg(dev, index, val) nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(dev), index, val)
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 8355d62..85d1601 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1160,6 +1160,22 @@ void nlm_hal_set_rsa_cge(int node, int enable)
 	nlm_hal_write_rsa_reg(node, NLM_RSA_CFG_REG, d32);
 }
 
+
+
+void nlm_hal_set_rsa_data_mode(int node, int bigend_fmt)
+{
+	unsigned long rsa_base = xlp_rsa_base[node] | 1 << 20; //bus is 1
+	uint64_t d64 = nlm_hal_read_64bit_reg(rsa_base, 0x20);
+//	nlm_print("%s %d in, %llx\n", __FUNCTION__, __LINE__, d64);
+	if(!bigend_fmt)
+		d64 |= (1ULL<<20);
+	else
+		d64 &= ~(1ULL<<20);
+	nlm_hal_write_64bit_reg(rsa_base, 0x20, d64);
+	d64 = nlm_hal_read_64bit_reg(rsa_base, 0x20);
+//	nlm_print("%s %d out, %llx\n", __FUNCTION__, __LINE__, d64);
+}
+
 #define NLM_SAE_ENGINE_SELECT_REG_0 0x41
 void nlm_hal_set_sae_engine_sel(int node)
 {
@@ -1290,4 +1306,6 @@ EXPORT_SYMBOL(nlm_hal_sata_intr_setup);
 EXPORT_SYMBOL(nlm_hal_sata_intr_ack);
 EXPORT_SYMBOL(nlm_hal_get_fdt_freq);
 EXPORT_SYMBOL(nlm_hal_dtr_init);
+EXPORT_SYMBOL(nlm_hal_set_rsa_data_mode);
+
 #endif
-- 
1.7.1

