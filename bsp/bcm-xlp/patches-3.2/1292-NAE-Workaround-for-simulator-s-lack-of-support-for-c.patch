From f7b146f10f02ba27f53a196f7bc71ba874b57e28 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 4 Sep 2010 23:50:39 -0700
Subject: NAE: Workaround for simulator's lack of support for cop2 vc_empty_status1

	* Generic cleanup in NAE driver
		- Deleted trailing whitespace
		- Removed unused preprocessor macros
		- Fixes for warnings
		- Unhook nae_remove from pci driver remove
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 275ed60..744c6b2 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -59,26 +59,30 @@
 #include "xlp_nae.h"
 
 #define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
-#define MAX_NUM_MACS 			1
+
+/* On-Chip NAE PCI Header */
 #define PCI_NETL_VENDOR			0xfecc
 #define PCI_DEVID_BASE			0
 #define PCI_DEVID_OFF_NET		0
-#define MAX_NUM_UARTS			2
-#define FREE_DEFAULT_SIZE		256
-#define NUM_FREE_DESC			18
-#define FREE_DESC_POOL_WIDTH		20
-#define NUM_FREEIN_QUEUE		18
+
+/* Currently Spill areas are not configured, so number of
+ * desc sent to NAE should be less than default free frin
+ * fifo size (50)
+ */
 #define MAX_NUM_DESC                    32
 #define MIN_FRIN_DESC_THRESHD		16
-#define MAX_NET_INF             	18
+#define FREE_DESC_POOL_WIDTH		20
+
+#define MAX_NET_INF             	1
+#define MAX_GMAC_PORT               	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
+/* FMN send failure errors */
 #define MSG_DST_FC_FAIL                 0x01
 #define MSG_INFLIGHT_MSG_EX             0x02
 #define MSG_TXQ_FULL                    0x04
-#define ICMP_LEN                     	74
-#define MAX_GMAC_PORT               	18
-#define ETH_MTU_SIZE		 	2048
+
+#define ETH_MTU_SIZE		 	1536
 #define MIN_ETH_FRAME_SIZE		64
 
 #define  DUMP_PKT(x, y)	if (debug == 2)  {	\
@@ -95,29 +99,32 @@
 static int debug = 0;
 module_param(debug, int, 0);
 
-static int hwemul = 0;
+extern int hwemul;
 module_param(hwemul, int, 0);
 
+extern int  xlp_sgmii_ports;
+module_param(xlp_sgmii_ports, int, 0);
+
 unsigned char eth_hw_addr[18][6] = {
-					{0x00,0x01,0x02,0x03,0x04,0x05},
-					{0x00,0x01,0x02,0x03,0x04,0x06},
-					{0x00,0x01,0x02,0x03,0x04,0x07},
-					{0x00,0x01,0x02,0x03,0x04,0x08},
-					{0x00,0x01,0x02,0x03,0x04,0x09},
-					{0x00,0x01,0x02,0x03,0x04,0x0A},
-					{0x00,0x01,0x02,0x03,0x04,0x0B},
-					{0x00,0x01,0x02,0x03,0x04,0x0C},
-					{0x00,0x01,0x02,0x03,0x04,0x0D},
-					{0x00,0x01,0x02,0x03,0x04,0x0E},
-					{0x00,0x01,0x02,0x03,0x04,0x0F},
-					{0x00,0x01,0x02,0x03,0x04,0x10},
-					{0x00,0x01,0x02,0x03,0x04,0x11},
-					{0x00,0x01,0x02,0x03,0x04,0x12},
-					{0x00,0x01,0x02,0x03,0x04,0x13},
-					{0x00,0x01,0x02,0x03,0x04,0x14},
-					{0x00,0x01,0x02,0x03,0x04,0x15},
-					{0x00,0x01,0x02,0x03,0x04,0x16}
-				   };
+	{0x00,0x01,0x02,0x03,0x04,0x05},
+	{0x00,0x01,0x02,0x03,0x04,0x06},
+	{0x00,0x01,0x02,0x03,0x04,0x07},
+	{0x00,0x01,0x02,0x03,0x04,0x08},
+	{0x00,0x01,0x02,0x03,0x04,0x09},
+	{0x00,0x01,0x02,0x03,0x04,0x0A},
+	{0x00,0x01,0x02,0x03,0x04,0x0B},
+	{0x00,0x01,0x02,0x03,0x04,0x0C},
+	{0x00,0x01,0x02,0x03,0x04,0x0D},
+	{0x00,0x01,0x02,0x03,0x04,0x0E},
+	{0x00,0x01,0x02,0x03,0x04,0x0F},
+	{0x00,0x01,0x02,0x03,0x04,0x10},
+	{0x00,0x01,0x02,0x03,0x04,0x11},
+	{0x00,0x01,0x02,0x03,0x04,0x12},
+	{0x00,0x01,0x02,0x03,0x04,0x13},
+	{0x00,0x01,0x02,0x03,0x04,0x14},
+	{0x00,0x01,0x02,0x03,0x04,0x15},
+	{0x00,0x01,0x02,0x03,0x04,0x16}
+};
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -126,7 +133,6 @@ static struct pci_device_id soc_pci_table[] __devinitdata = {
         {}
 };
 
-extern int  xlp_sgmii_ports;
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 spinlock_t  nlm_xlp_nae_lock;
@@ -140,7 +146,10 @@ static void  nlm_xlp_set_multicast_list (struct net_device *dev);
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);
 static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
+
+#ifdef  ENABLE_NAE_PIC_INT
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
+#endif
 
 static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 					uint32_t size, uint32_t code,
@@ -171,6 +180,34 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 	.ndo_get_stats = nlm_xlp_mac_get_stats,
 };
 
+static __inline__ void print_fmn_send_error(uint32_t send_result, uint32_t status1)
+{
+	if(send_result & MSG_DST_FC_FAIL)
+	{
+		status1 = xlp_read_status1();
+		if( status1 & (1 << 31))
+		{
+			printk("CPU receive queue written when Full\n");
+
+		}
+		else if (status1 & (1 << 30))
+		{
+			printk("Fmn input credit overflow hardware error\n");
+		}
+		else if (status1 & (1 << 29))
+		{
+			printk("Fmn output credit overflow error, Outq ID: %d\n", status1 & 0xfff);
+		}
+		printk("TX message destination flow control credit fail\n");
+	}
+	else if (send_result & MSG_INFLIGHT_MSG_EX) {
+		printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
+	}
+	else if (send_result & MSG_TXQ_FULL) {
+		printk("TX message Q fulll\n");
+	}
+}
+
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
         uint64_t *back_ptr = (uint64_t *)(addr - CACHELINE_SIZE);
@@ -203,7 +240,7 @@ static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
         void *buf = kmalloc(size + CACHELINE_SIZE, gfp_mask);
         if (buf)
                 buf =(void*)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
-                                                   CACHELINE_SIZE));
+						    CACHELINE_SIZE));
         return buf;
 }
 
@@ -370,35 +407,11 @@ static void mac_refill_frin_desc(unsigned long dev)
 		msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
 		/* Send the packet to nae rx  */
 		__sync();
-retry_send:
-                if ((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])))
+	retry_send:
+                if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) )
 		{
-			if(ret & MSG_DST_FC_FAIL)
-			{
-				ret = xlp_read_status1();
-				if( ret & (1 << 31))
-				{
-					printk("CPU receive queue written when Full\n");
-
-				}
-				else if(ret & (1 << 30))
-				{
-					printk("Fmn input credit overflow hardware error\n");
-				}
-				else if( ret & (1 << 29))
-				{
-					printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-				}
-                                printk("TX message destination flow control credit fail\n");
-			}
-                        else if(ret & MSG_INFLIGHT_MSG_EX) {
-				printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
-			}
-                        else if(ret & MSG_TXQ_FULL) {
-                                printk("TX message Q fulll\n");
-			}
-
-			printk("[%s]: retrying...\n", __func__);
+			print_fmn_send_error(ret, xlp_read_status1());
+			if (debug) printk("[%s]: retrying...\n", __func__);
 			goto retry_send;
                 }
 		msgrng_access_disable(mflags);
@@ -422,7 +435,7 @@ static void nlm_xlp_nae_init(void)
 	uint32_t val;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, hwemul=%d\n", debug, hwemul);
+	printk("debug = %d, hwemul=%d, xlp_sgmii_ports=%d\n", debug, hwemul, xlp_sgmii_ports);
 
 	if (hwemul) {
 		unsigned long mflags = 0;
@@ -431,9 +444,10 @@ static void nlm_xlp_nae_init(void)
 		msgrng_access_disable(mflags);
 	}
 
-	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
+	if (xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
-		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",__FUNCTION__, xlp_sgmii_ports);
+		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",
+		       __FUNCTION__, xlp_sgmii_ports);
 		return;
 	}
 
@@ -443,23 +457,22 @@ static void nlm_xlp_nae_init(void)
 
 	spin_lock_irq(&nlm_xlp_nae_lock);
 
-	/* initial 18 gmac block */
-        for(i = 0; i < 1/*MAX_NET_INF*/; i++)
+	/* initial NAE interfaces */
+        for(i = 0; i < MAX_NET_INF; i++)
 	{
-		/* init_gmac(i); */
 		nlm_hal_open_if(GMAC_IF, i);
 	}
 
-	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
+	/* Currently HAL doesn't initialize ucores, so initialize them */
+	for (i = 0; i < MAX_NET_INF; i++ )
 	{
 		init_ucore(0xffffUL, i);
 	}
-
 	ucore_load_apps(0xffffUL);
 
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
-	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
+	for(i = 0; i < xlp_sgmii_ports; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
 		if(!dev)
@@ -496,16 +509,18 @@ static void nlm_xlp_nae_init(void)
 				       nlm_root_proc /* parent */ ,
 				       xlp_mac_proc_read /* proc read function */ ,
 				       0	/* no client data */
-					);
+		);
 	if (!entry) {
 		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",
 		       __FUNCTION__);
 	}
+
 	/*config free fifo context mapping*/
 	spin_lock_irq(&nlm_xlp_nae_lock);
+
 	for(i = 0; i < FREE_DESC_POOL_WIDTH; i++)
 	{
-		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
+		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG);
 
 		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
 		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
@@ -534,7 +549,7 @@ static void nlm_xlp_sgmii_setcontext(void)
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_1, val );
-	 i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
 	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_2, val );
@@ -574,7 +589,6 @@ static void nlm_xlp_sgmii_setcontext(void)
 static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
-	int port = priv->port;
 	int i;
 
 	if (priv->inited) return 0;
@@ -586,14 +600,17 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 
 	mac_refill_frin_desc((unsigned long)dev);
 
-/*
-	irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
-	if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
-		ret = -EBUSY;
-		printk("can't get mac interrupt line (%d)\n",dev->irq);
+#ifdef ENABLE_NAE_PIC_INT
+	{
+		int port = priv->port;
+		irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
+		if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
+			ret = -EBUSY;
+			printk("can't get mac interrupt line (%d)\n",dev->irq);
+		}
+		dump_irt_entry(PIC_IRT_NA_INDEX(port));
 	}
-*/
-	/*dump_irt_entry(PIC_IRT_NA_INDEX(port)); */
+#endif
 
 	/* set timer to test rx routine */
 	init_timer(&priv->link_timer);
@@ -660,7 +677,6 @@ static int  nlm_xlp_nae_stop (struct net_device *dev)
 static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
-	int port = priv->port;
 	unsigned long mflags = 0;
 	int cpu = 0, ret = 0;
 	struct xlp_msg msg =  { {0, 0, 0, 0} };
@@ -678,10 +694,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
-							 0,
-							 NULL_VFBID,
-							 skb->len,
-							 virt_to_bus(skb->data));
+				   0,
+				   NULL_VFBID,
+				   skb->len,
+				   virt_to_bus(skb->data));
 
 	msg.entry[2] = msg.entry[3] = 0;
 
@@ -689,43 +705,20 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	__sync();
 
-       if (debug) {
-	       printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
-		      priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
-       }
+	if (debug) {
+		printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
+		       priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
+	}
 
 	msgrng_access_enable(mflags);
-retry_send:
-        if ((ret = nlm_hal_send_msg2( priv->nae_tx_qid,
-                           0,
-                           msg.entry[0],
-                           msg.entry[1])))
+ retry_send:
+        if ( (ret = nlm_hal_send_msg2(priv->nae_tx_qid,
+				      0,
+				      msg.entry[0],
+				      msg.entry[1])) )
         {
-                if(ret & MSG_DST_FC_FAIL)
-		{
-			ret = xlp_read_status1();
-			if( ret & (1 << 31))
-			{
-				printk("CPU receive queue written when Full\n");
-
-			}
-			else if(ret & (1 << 30))
-			{
-				printk("Fmn input credit overflow hardware error\n");
-			}
-			else if( ret & (1 << 29))
-			{
-				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-			}
-		}
-                else if(ret & MSG_INFLIGHT_MSG_EX) {
-			printk("[%s]: MSG_INFLIGHT_MSG_EX\n", __func__);
-		}
-                else if(ret & MSG_TXQ_FULL)
-		{
-                        printk("TX message Q fulll\n");
-		}
-		printk("[%s]: retrying...\n", __func__);
+		print_fmn_send_error(ret, xlp_read_status1());
+		if (debug) printk("[%s]: retrying message send...\n", __func__);
 		goto retry_send;
         }
 
@@ -841,13 +834,14 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 	return;
 }
 
+#ifdef ENABLE_NAE_PIC_INT
 /**********************************************************************
  * nlm_xlp_nae_int_handler -  interrupt handler
  * @irq     -  irq number
  * @dev_id  -  this device
  *
  **********************************************************************/
-static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
+static irqreturn_t nlm_xlp_nae_int_handler(int irq, void *dev_id)
 {
         struct net_device *dev;
         struct dev_data *priv;
@@ -870,6 +864,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 /**********************************************************************
  * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
@@ -893,10 +888,10 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	cpu = hard_smp_processor_id();
 	vc = vc & 0x03;
 
-       if (debug) {
-	       printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-		      src_id, vc, size, msg0, msg1);
-       }
+	if (debug) {
+		printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
+		       src_id, vc, size, msg0, msg1);
+	}
 
 	if( vc == 1 && size == 1)
 	{
@@ -1044,13 +1039,13 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 			       priv->stats.tx_packets, priv->stats.tx_bytes);
 	}
 	for(cpu=0;cpu<8;cpu++) {
-			len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
-				        cpu,
-				       priv->cpu_stats[cpu].tx_packets,
-				       priv->cpu_stats[cpu].txc_packets,
-				       priv->cpu_stats[cpu].rx_packets,
-				       priv->cpu_stats[cpu].interrupts);
-		}
+		len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
+			       cpu,
+			       priv->cpu_stats[cpu].tx_packets,
+			       priv->cpu_stats[cpu].txc_packets,
+			       priv->cpu_stats[cpu].rx_packets,
+			       priv->cpu_stats[cpu].interrupts);
+	}
 
 	*eof = 1;
 
@@ -1086,6 +1081,7 @@ static void nlm_xlp_mac_timer(unsigned long data)
 static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
         int result = 0;
+
         result = pci_enable_device(pdev);
 	return result;
 }
@@ -1094,10 +1090,11 @@ static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pc
  * nlm_xlp_nae_remove - driver remove routine
  * @pdev - pci device.
  **********************************************************************/
-static void nlm_xlp_nae_remove(struct net_device * dev)
+static void nlm_xlp_nae_remove(void)
 {
 	int i;
-        struct dev_data *priv;
+	struct net_device *dev = 0;
+        struct dev_data *priv = 0;
 
 	for (i = 0; i < MAX_GMAC_PORT; i++)
 	{
@@ -1116,12 +1113,11 @@ static struct pci_driver soc_driver = {
 	.name             = XLP_SOC_MAC_DRIVER,
 	.id_table         = soc_pci_table,
 	.probe            = nlm_xlp_nae_pci_probe,
-	.remove		  = nlm_xlp_nae_remove,
+	.remove		  = NULL,
 };
 
 static int __init nlm_xlp_mac_init(void)
 {
-
 	nlm_xlp_nae_init();
 
 	return pci_register_driver(&soc_driver);
@@ -1129,6 +1125,9 @@ static int __init nlm_xlp_mac_init(void)
 
 static void __exit nlm_xlp_mac_exit(void)
 {
+	/* unregister mac driver */
+	nlm_xlp_nae_remove();
+
 	pci_unregister_driver(&soc_driver);
 }
 
-- 
1.7.1

