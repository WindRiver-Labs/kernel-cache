From 89239586a252fd7fe5077164c221c2451cdba7df Mon Sep 17 00:00:00 2001
From: Rahul Gupta <guptar@broadcom.com>
Date: Tue, 12 Aug 2014 03:44:35 -0700
Subject: brcm_nat_app: nlm_msgring on 9xx and 5xx boards, corrected read_register XLP_MSG_INT_REG to fix the msgrng_wait API on 9xx

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
index 5fa6c30..66137ec 100644
--- a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
+++ b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
@@ -63,6 +63,7 @@ static int msgring_timeout[NR_CPUS];
 static struct class *msgring_class;
 static struct device *msgring_device;
 static dev_t msgring_devt;
+static int xlp8xx_family, xlp9xx_family;
 
  
 #define NLM_MSGRING_WAIT_IOC 'm'
@@ -103,9 +104,21 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 
 	/* Enable intr on the vcs */
 	/* Need write vcmask into the register */
-	val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
-	val |= (intr_vc_mask[cpu] << 16);
-	_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+	if (xlp8xx_family) {
+	    val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+	    val |= (intr_vc_mask[cpu] << 16);
+	    _write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+	}
+	else if (xlp9xx_family) {
+	    /* works for xlp9xx_family- 9xx RC and 5xx RC*/
+	    /*TODO: Check for newer chips*/
+	    val =  _read_32bit_cp2_register(XLP_MSG_INT_REG);
+	    val |= (intr_vc_mask[cpu]);
+	    _write_32bit_cp2_register(XLP_MSG_INT_REG, val);
+	}
+	else {
+	    printk("xlp_nlm_msgring driver: Error Unknown chip");
+	}
 
 #ifdef CONFIG_32BIT
 	msgrng_access_disable(mflags);
@@ -228,7 +241,13 @@ static int msgring_init(void)
 	}
 
 	nlm_xlp_register_intr_vc_handler(msgring_event);
-    printk(" returning from mgsring_init\n");
+
+	if(IS_NLM_XLP9XX_FAMILY)
+	    xlp9xx_family = 1;
+	if (is_nlm_xlp8xx())
+	    xlp8xx_family = 1;
+	printk("returning from mgsring_init\n");
+
 	return 0;
 }
 
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index a4dc975..6a6751d 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -804,8 +804,19 @@ int nlm_xlp_register_intr_vc(int cpu, int vc)
 	if(!xlp_fmn_init_done)
 		xlp_fmn_init_done = 1;
 
-	node = cpu / 32;
-	nlm_hal_enable_vc_intr(node, (cpu*4 + vc) & 0x7f);
+	node = cpu_to_node(cpu_number_map(cpu));
+	if (is_nlm_xlp9xx()) {
+	    nlm_hal_enable_vc_intr(node, ((cpu%NLM_MAX_CPU_PER_NODE_9XX)*4 + vc)
+			    & 0xff);
+	}
+	if (is_nlm_xlp5xx()) {
+	    nlm_hal_enable_vc_intr(node, ((cpu%NLM_MAX_CPU_PER_NODE_5XX)*4 + vc)
+			    & 0xff);
+	}
+	if (is_nlm_xlp8xx()) {
+	    nlm_hal_enable_vc_intr(node, ((cpu%NLM_MAX_CPU_PER_NODE)*4 + vc)
+			    & 0x7f);
+	}
 
 	spin_lock_irqsave(&msgrng_lock, flags);
 	intr_vc_mask[cpu] |= (1 << vc);
-- 
1.7.1

