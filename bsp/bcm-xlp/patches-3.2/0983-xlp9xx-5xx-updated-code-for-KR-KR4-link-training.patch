From 17b82dc3661ea9ecc32f302395c1e34ea2529fe8 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Wed, 25 Jun 2014 12:43:27 +0530
Subject: xlp9xx/5xx: updated code for KR/KR4 link training.

[Based on SDK 3.2]
Delete "BIT(n)" defination because of the compile error as below:
arch/mips/netlogic/lib/netlib/src/netsoc_bkpl_ether.c:44:0: error: "BIT" redefined [-Werror]
 #define BIT(n)  (1<<n)
 ^

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index e1d9f3a..5e889e5 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -81,15 +81,15 @@ extern int __netsoc_init_ucore(nae_t *nae);
 extern int __netsoc_init_nae(nae_t *nae);
 extern int __netsoc_init_poe(poe_t *poe);
 
-extern void __netsoc_setup_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_enable_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_disable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_setup_link_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern void __netsoc_bkpl_set_cl73_enable(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern int __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern int __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern uint32_t __netsoc_bkpl_wait_for_an_complete(nae_t *nae, uint32_t block, uint32_t lane_no);
+extern int  __netsoc_bkpl_wait_for_ld_lt_done(nae_t *nae, uint32_t block, uint32_t lane_no);
+void __netsoc_init_kr_module(void);
 
 extern void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask);
 extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index c94588d..1c2e8d3 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -997,6 +997,61 @@ static inline void __netsoc_write_xlgmac_reg(net_port_t *netport, uint32_t addr,
 	return;
 }
 
+static inline void __netsoc_xlgmac_softreset(uint64_t mac_base,  uint32_t rst_val)
+{
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XLGMAC1_CTL);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base, XLGMAC1_CTL, val);
+}
+
+static inline void __netsoc_xlgmac_threshold(uint64_t mac_base,  uint32_t thres_val)
+{
+
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL);
+	val &= (~(XLGMAC3_CTL_SOFTH_MASK << XLGMAC3_CTL_SOFTH_SHIFT));
+	val |= ((thres_val & XLGMAC3_CTL_SOFTH_MASK) << XLGMAC3_CTL_SOFTH_SHIFT);
+        netsoc_write_mac_reg(mac_base, XLGMAC3_CTL, val);
+    	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
+
+}
+
+static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
+{
+	uint32_t val;
+	val =  netsoc_read_mac_reg(mac_base, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base, XGMAC_CTL_REG1, val);
+#if 0
+	// Lane 0
+	val =  netsoc_read_mac_reg(mac_base0, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base0, XGMAC_CTL_REG1, val);
+	// Lane 1
+	val =  netsoc_read_mac_reg(mac_base1, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base1, XGMAC_CTL_REG1, val);
+	// Lane 2
+	val =  netsoc_read_mac_reg(mac_base2, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base2, XGMAC_CTL_REG1, val);
+	// Lane 3
+	val =  netsoc_read_mac_reg(mac_base3, XGMAC_CTL_REG1);
+	val &= ~(0x3 << 11);
+	val |= ((rst_val & 0x3) << 11);
+        netsoc_write_mac_reg(mac_base3, XGMAC_CTL_REG1, val);
+#endif
+
+	netsoc_api_print(NETSOC_APIDBG_PORT, "%s All XFI ports in a Quad resetted\n", __func__);
+
+}
+
 static inline uint64_t __netsoc_get_xgmac_base(net_port_t *netport)
 {
 	uint64_t mac_base;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_bkpl_ether.c b/arch/mips/netlogic/lib/netlib/src/netsoc_bkpl_ether.c
new file mode 100644
index 0000000..0c9bb7d
--- /dev/null
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_bkpl_ether.c
@@ -0,0 +1,1964 @@
+/*-
+ * Copyright (c) 2003-2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include "nlm_hal.h"
+#include "nlm_nae.h"
+#include "nlm_hal_sys.h"
+#include "nlm_hal_pma2p0_data.h"
+#include "netsoc_nae.h"
+#include "netsoc_haliface.h"
+#include "netsoc_libiface.h"
+#include "ext_phy.h"
+
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
+
+
+/*KR/KR4 related functions.*/
+
+#define  bit_clear(data, n)  data &= ~(n)
+#define bit_set(data, n)     data |= (n)
+
+
+enum{
+	KR_LOOPBACK=0,
+	KR_TD2=1,
+};
+
+typedef struct kr_config{
+	int next_page_an;
+	int read_rem_ability_registers;
+	int message_page;
+	int partner_type;
+	int count_threshold;
+	int link_training_enable; 
+	int step_size;
+	int with_restart_link_training;
+#define NUM_KR_MAX_PORTS	8
+	int kr_enable[NUM_KR_MAX_PORTS];
+	int skip;
+	
+#define NUM_KR_ALGO_POSITIONS   16 /*max actual required is only 13*/
+	unsigned int eye_value[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dcgain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfepstapf3db[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfepstapgain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfetap1gain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfetap2gain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfetap3gain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_dfetap4gain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_lofreqagcgain[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	unsigned int rxcaleq_hifreqagccap[NUM_KR_MAX_PORTS][NUM_KR_ALGO_POSITIONS];
+	
+	unsigned int best_eye_value[NUM_KR_MAX_PORTS];
+	unsigned int best_position[NUM_KR_MAX_PORTS];
+	int verbose;
+	
+	
+}kr_config_t;
+
+kr_config_t kr_param;
+
+static void config_kr_params(void)
+{
+	int pos, port_no;
+	
+	kr_param.step_size = 1;
+	kr_param.link_training_enable = 1;
+	kr_param.next_page_an = 0;
+	kr_param.read_rem_ability_registers = 0;
+	kr_param.message_page =0;
+	kr_param.partner_type = KR_TD2;
+	kr_param.count_threshold = 10;	
+	for(port_no=0; port_no<NUM_KR_MAX_PORTS; port_no++){
+		kr_param.best_eye_value[port_no] = 0;
+		kr_param.best_position[port_no] = 0;
+		kr_param.kr_enable[port_no] = 1; /*enable KR on all lanes.*/
+	}
+	kr_param.with_restart_link_training = 1; 
+	for (port_no=0; port_no<NUM_KR_MAX_PORTS; port_no++){
+		for(pos=0; pos<NUM_KR_ALGO_POSITIONS;pos++){
+			kr_param.eye_value[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dcgain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfepstapf3db[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfepstapgain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfetap1gain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfetap2gain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfetap3gain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_dfetap4gain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_lofreqagcgain[port_no][pos]=0xFFFF;
+			kr_param.rxcaleq_hifreqagccap[port_no][pos]=0xFFFF;
+		}
+	}
+	kr_param.verbose =1;
+	kr_param.skip  =0;
+}
+
+uint32_t mod(uint32_t value){
+	volatile uint32_t mod_value;
+
+	if (value < 0) {
+		mod_value = -value;
+	} else {
+		mod_value = value;
+	}
+	return(mod_value);
+}
+void write_vsemi_txdriver_registers(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	//Read TX DRV registers
+	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
+	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
+	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
+	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
+	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
+	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
+	bit_clear(rd_data, BIT(5));
+	__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
+	__netsoc_write_pma2p0_reg(base, lane_no, 21, 0xdf);
+	//rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+	//nlm_print(" block:%d lane:%d 21:0x%x\n", block, lane_no, rd_data);
+	__netsoc_write_pma2p0_reg(base, lane_no, 22, 0x7);
+	//rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+	//nlm_print(" block:%d lane:%d 22:0x%x\n", block, lane_no, rd_data);
+	__netsoc_write_pma2p0_reg(base, lane_no, 23, 0);
+	//rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+	//nlm_print(" block:%d lane:%d 23:0x%x\n", block, lane_no, rd_data);
+
+}
+
+void read_vsemi_txequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no) {
+	volatile uint32_t rd_data;
+	volatile uint32_t txdrv_levn, txdrv_levnm1, txdrv_levnp1;
+	volatile int32_t  coeff27_minus1, coeff27, coeff27_plus1;
+	volatile uint32_t mod_coeff27_minus1, mod_coeff27, mod_coeff27_plus1;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	//Read TX DRV registers
+	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
+	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
+	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
+	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
+	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
+	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
+	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+	txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+	txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+	txdrv_levnp1 = (rd_data & 0x7);      //23[2:0]
+
+	//Get initial coefficients
+	coeff27_minus1 = ((txdrv_levnp1));
+	coeff27_plus1  = ((txdrv_levnm1));
+	mod_coeff27_minus1 = mod(coeff27_minus1);
+	mod_coeff27_plus1 = mod(coeff27_plus1);
+	coeff27 = ((txdrv_levn) - mod_coeff27_minus1 - mod_coeff27_plus1);
+	mod_coeff27= mod(coeff27);
+	nlm_print(" c:%d l:%d  C-1:%d C0:%d C+1:%d\n", block, lane_no,coeff27_minus1, coeff27, coeff27_plus1);
+}
+
+void read_vsemi_rxequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t pos) 
+{
+	volatile uint32_t rd_data;
+	volatile uint32_t rxcaleq_dcgain;
+	volatile uint32_t rxcaleq_dfepstapf3db;
+	volatile uint32_t rxcaleq_dfepstapgain;
+	volatile uint32_t rxcaleq_dfetap1gain;
+	volatile uint32_t rxcaleq_dfetap2gain;
+	volatile uint32_t rxcaleq_dfetap3gain;
+	volatile uint32_t rxcaleq_dfetap4gain;
+	volatile uint32_t rxcaleq_lofreqagcgain;
+	volatile uint32_t rxcaleq_hifreqagccap;
+	volatile uint32_t rxcaleq_locwren;
+	uint32_t port_no;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	port_no = (block*4 + lane_no);
+
+	// RXCALEQ_DCGAIN         24[2:0]    0 1 2 3 3'h0 // 3'h2
+	// RXCALEQ_DFEPSTAPF3DB   24[5:3]    0 1 2 3 3'h0
+	// RXCALEQ_DFEPSTAPGAIN   25[2:0]    0 1 2 3 3'h0
+	// RXCALEQ_DFETAP1GAIN    25[6:3]    0 1 2 3 4'h0
+	// RXCALEQ_DFETAP2GAIN    26[3:0]    0 1 2 3 4'h8
+	// RXCALEQ_DFETAP3GAIN    26[7:4]    0 1 2 3 4'h0
+	// RXCALEQ_DFETAP4GAIN    27[3:0]    0 1 2 3 4'h8
+	// RXCALEQ_LOFREQAGCGAIN  27[6:4]    0 1 2 3 3'h7
+	// RXCALEQ_HIFREQAGCCAP   28[7:3]    0 1 2 3 5'h0
+	// RXCALEQ_LOCWREN        86[3:3]    0 1 2 3 1'b0
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 24);
+	kr_param.rxcaleq_dcgain[port_no][pos] = (rd_data & 0x7);
+	kr_param.rxcaleq_dfepstapf3db[port_no][pos] = ((rd_data >> 3) & 0x7);
+	//nlm_print("RXCALEQ_DCGAIN=0x%x\n", kr_param.rxcaleq_dcgain);
+	//nlm_print("RXCALEQ_DFEPSTAPF3DB=0x%x\n", kr_param.rxcaleq_dfepstapf3db);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 25);
+	kr_param.rxcaleq_dfepstapgain[port_no][pos] = (rd_data & 0x7);
+	kr_param.rxcaleq_dfetap1gain[port_no][pos] = ((rd_data >> 3) & 0xF);
+	//nlm_print("RXCALEQ_DFEPSTAPGAIN=0x%x\n", kr_param.rxcaleq_dfepstapgain);
+	//nlm_print("RXCALEQ_DFETAP1GAIN=0x%x\n", kr_param.rxcaleq_dfetap1gain);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 26);
+	kr_param.rxcaleq_dfetap2gain[port_no][pos] = (rd_data & 0xF);
+	kr_param.rxcaleq_dfetap3gain[port_no][pos] = ((rd_data >> 4) & 0xF);
+	//nlm_print("RXCALEQ_DFETAP2GAIN=0x%x\n", kr_param.rxcaleq_dfetap2gain);
+	//nlm_print("RXCALEQ_DFETAP3GAIN=0x%x\n", kr_param.rxcaleq_dfetap3gain);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 27);
+	kr_param.rxcaleq_dfetap4gain[port_no][pos] = (rd_data & 0xF);
+	kr_param.rxcaleq_lofreqagcgain[port_no][pos] = ((rd_data >>4) & 0xF);
+	//nlm_print("RXCALEQ_DFETAP4GAIN=0x%x\n", kr_param.rxcaleq_dfetap4gain);
+	//nlm_print("RXCALEQ_LOFREQAGCGAIN=0x%x\n", kr_param.rxcaleq_lofreqagcgain);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 28);
+	kr_param.rxcaleq_hifreqagccap[port_no][pos] = ((rd_data >> 3) & 0x1F);
+	//nlm_print("RXCALEQ_HIFREQAGCCAP=0x%x\n", kr_param.rxcaleq_hifreqagccap);
+	//rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+	//rxcaleq_locwren = ((rd_data & BIT(3)) >> 3) ;
+	//nlm_print("RXCALEQ_LOCWREN=0x%x\n", rxcaleq_locwren);
+	//bit_clear(rd_data, BIT(3));
+	//__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+}
+
+
+
+int32_t update_coefficient(uint32_t update, int32_t present_coeff){
+	volatile int32_t updated_coeff;
+
+	switch (update) {
+		case 0 : updated_coeff = present_coeff;        break;
+		case 1 : updated_coeff = present_coeff + kr_param.step_size; break;
+		case 2 : updated_coeff = present_coeff - kr_param.step_size; break;
+	}
+	return(updated_coeff);
+}
+
+
+void program_tx_driver(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	volatile int32_t  coeff27_minus1, coeff27, coeff27_plus1;
+	volatile uint32_t mod_coeff27_minus1, mod_coeff27, mod_coeff27_plus1;
+	volatile int32_t  present_coeff_minus1, present_coeff_zero, present_coeff_plus1;
+	volatile uint32_t coeff_minus1_update, coeff_zero_update, coeff_plus1_update;
+	volatile int32_t  temp_coeff27_minus1, temp_coeff27_zero, temp_coeff27_plus1;
+	volatile uint32_t mod_temp_coeff27_zero, mod_temp_coeff27_minus1, mod_temp_coeff27_plus1;
+	volatile int32_t  updated_coeff_minus1, updated_coeff_zero,updated_coeff_plus1;
+	volatile uint32_t  updated_status_minus1, updated_status_zero,updated_status_plus1;
+	volatile uint32_t mod_updated_coeff_minus1, mod_updated_coeff_zero,mod_updated_coeff_plus1;
+	volatile uint32_t txdrv_levn, txdrv_levnm1, txdrv_levnp1;
+	volatile uint64_t cycles = 0;
+	uint64_t count= 0,count1=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//preset
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+	if ((rd_data & BIT(13)) == BIT(13)) {
+#ifndef PALLADIUM_TEST
+		//Write TX DRV registers
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
+		bit_clear(rd_data, BIT(5));
+		__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
+
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+		rd_data &= 0x07; //[7:3]
+		rd_data |= (0x1B << 3);
+		__netsoc_write_pma2p0_reg(base, lane_no, 21, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+		rd_data &= 0xF0;
+		rd_data |= 0;
+		__netsoc_write_pma2p0_reg(base, lane_no, 22, rd_data);
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+		rd_data &= 0xF8;
+		rd_data |= 0;
+		__netsoc_write_pma2p0_reg(base, lane_no, 23, rd_data);
+		//nlm_print("Preset received : TXDRV_LEVN:0x1B, TXDRV_LEVNM1:0 TXDRV_LEVNP1:0\n");
+#endif
+		// Write LD Status registers
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		rd_data &= 0xFFC0;
+		rd_data |= 0xC;   //[5:4]=0, [3:2]=3, [1:0]=0;
+		//rd_data |= 0x3F;   //[5:4]=3, [3:2]=3, [1:0]=3;//FIXME
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+
+		//Read LP coeff update till LP coeff is set to hold
+		do {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+		} while (rd_data != 0x0);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+		rd_data &= 0xFFC0;
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+
+	} else { //not preset
+
+#ifndef PALLADIUM_TEST
+		//Read TX DRV registers
+		// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
+		// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
+		// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
+		// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
+		// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
+		// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
+		// TXDRV_LOCWREN 87[6:6]    0 1 2 3
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+		txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+		txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+		txdrv_levnp1 = (rd_data & 0x7);      //23[2:0]
+
+		//Get initial coefficients
+		coeff27_minus1 = ((txdrv_levnp1));
+		coeff27_plus1  = ((txdrv_levnm1));
+		mod_coeff27_minus1 = mod(coeff27_minus1);
+		mod_coeff27_plus1 = mod(coeff27_plus1);
+		coeff27 = ((txdrv_levn) - mod_coeff27_minus1 - mod_coeff27_plus1);
+		mod_coeff27= mod(coeff27);
+
+		if(((mod_coeff27_minus1 + mod_coeff27 + mod_coeff27_plus1) <= 27) && ((mod_coeff27 - mod_coeff27_minus1 - mod_coeff27_plus1) >= 6)) {
+			present_coeff_minus1 = coeff27_minus1;
+			present_coeff_zero   = coeff27;
+			present_coeff_plus1  = coeff27_plus1;
+		}
+		nlm_print(" c:%d l:%d  C-1:%d C0:%d C+1:%d\n", block, lane_no,present_coeff_minus1, present_coeff_zero,present_coeff_plus1);
+#endif
+		//Read LP coefficient update
+		do {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+
+			//Get coeff updates
+			coeff_minus1_update = (rd_data & 0x3);
+			coeff_zero_update   = ((rd_data >> 2) & 0x3);
+			coeff_plus1_update  = ((rd_data >> 4) & 0x3);
+
+			if(coeff_minus1_update == 0) updated_status_minus1 = 0;
+			if(coeff_zero_update == 0)  updated_status_zero   = 0;
+			if(coeff_plus1_update == 0)  updated_status_plus1  = 0;
+
+#ifndef PALLADIUM_TEST
+			//calculate updated coeffs
+			temp_coeff27_minus1 = update_coefficient(coeff_minus1_update, present_coeff_minus1);
+			temp_coeff27_zero   = update_coefficient(coeff_zero_update, present_coeff_zero);
+			temp_coeff27_plus1  = update_coefficient(coeff_plus1_update, present_coeff_plus1);
+
+			mod_temp_coeff27_minus1 =  mod(temp_coeff27_minus1);
+			mod_temp_coeff27_zero   =  mod(temp_coeff27_zero);
+			mod_temp_coeff27_plus1  =  mod(temp_coeff27_plus1);
+
+			if(((mod_temp_coeff27_minus1 + mod_temp_coeff27_zero + mod_temp_coeff27_plus1) <= 27) && ( mod_temp_coeff27_zero - mod_temp_coeff27_minus1 - mod_updated_coeff_plus1 >= 6)) {
+				if(coeff_minus1_update != 0) {
+					if(mod_temp_coeff27_minus1 > 0x6) {
+						updated_status_minus1 = 3;//maximum
+						updated_coeff_minus1 = present_coeff_minus1;
+					} else if(mod_temp_coeff27_minus1 < 0) {
+						updated_status_minus1 = 2;//minimum
+						updated_coeff_minus1 = present_coeff_minus1;
+					} else {
+						updated_coeff_minus1 = temp_coeff27_minus1;
+						updated_status_minus1 = 1;
+					}
+				} else {
+					updated_coeff_minus1 = present_coeff_minus1;
+					updated_status_minus1 = 0;
+				}
+				if(coeff_zero_update != 0) {
+					if(mod_temp_coeff27_zero > 0x1B) {
+						updated_status_zero = 3;//maximum
+						updated_coeff_zero = present_coeff_zero;
+						//} else if(mod_temp_coeff27_zero < 0) { //FIXME
+						//  updated_coeff_zero = present_coeff_zero;
+						//  updated_status_zero = 2;//minimum
+				} else {
+					updated_coeff_zero   = temp_coeff27_zero;
+					updated_status_zero = 1;
+				}
+				} else {
+					updated_coeff_zero = present_coeff_zero;
+					updated_status_zero = 0;
+				}
+				if(coeff_plus1_update != 0) {
+					if(mod_temp_coeff27_plus1 > 0x9) {
+						updated_coeff_plus1  = present_coeff_plus1;
+						updated_status_plus1 = 3;//maximum
+					} else if(mod_temp_coeff27_plus1 < 0) {
+						updated_coeff_plus1  = present_coeff_plus1;
+						updated_status_plus1 = 2;//minimum
+					} else {
+						updated_coeff_plus1  = temp_coeff27_plus1;
+						updated_status_plus1 = 1;
+					}
+				} else {
+					updated_coeff_plus1 = present_coeff_plus1;
+					updated_status_plus1 = 0;
+				}
+			} else {
+				updated_coeff_minus1 = present_coeff_minus1;
+				updated_coeff_zero = present_coeff_zero;
+				updated_coeff_plus1 = present_coeff_plus1;
+				if(kr_param.partner_type == 1) {
+					updated_status_minus1 = 3;
+					updated_status_zero = 3;
+					updated_status_plus1 = 3;
+				} else {
+					updated_status_minus1 = 1;
+					updated_status_zero = 1;
+					updated_status_plus1 = 1;
+				}
+			}
+			//if(kr_param.verbose == 1) nlm_print(" c:%d l:%d C-1:%d C0:%d C+1:%d\n", block, lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
+			//nlm_print(" c:%d l:%d C-1:%d C0:%d C+1:%d\n", block, lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
+			//nlm_print(" c:%d l:%d S-1:%d S0:%d S+1:%d\n", block, lane_no,updated_status_minus1,updated_status_zero,updated_status_plus1 );
+
+			mod_updated_coeff_minus1 =  mod(updated_coeff_minus1);
+			mod_updated_coeff_zero   =  mod(updated_coeff_zero);
+			mod_updated_coeff_plus1  =  mod(updated_coeff_plus1);
+
+			//Write TX DRV registers
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
+			bit_clear(rd_data, BIT(5));
+			__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
+
+			//calculate register fields (txdrv_levn, txdrv_nm1, txdev_np1)
+			txdrv_levnm1 =   (updated_coeff_plus1);
+			txdrv_levnp1 =   (updated_coeff_minus1);
+			txdrv_levn = ((updated_coeff_zero + mod_updated_coeff_minus1 + mod_updated_coeff_plus1));
+
+			kr_param.verbose = 0;
+			if (kr_param.verbose) {
+				nlm_print("TXDRV_LEVN   = 0x%x\n", txdrv_levn);
+				nlm_print("TXDRV_LEVNM1 = 0x%x\n", txdrv_levnm1);
+				nlm_print("TXDRV_LEVNP1 = 0x%x\n", txdrv_levnp1);
+			}
+
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
+			rd_data &= 0x07; //[7:3]
+			rd_data |= (txdrv_levn << 3);
+			__netsoc_write_pma2p0_reg(base, lane_no, 21, rd_data);
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
+			rd_data &= 0xF0;
+			rd_data |= txdrv_levnm1;
+			__netsoc_write_pma2p0_reg(base, lane_no, 22, rd_data);
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
+			rd_data &= 0xF8;
+			rd_data |= txdrv_levnp1;
+			__netsoc_write_pma2p0_reg(base, lane_no, 23, rd_data);
+#else
+			if(coeff_minus1_update != 0) updated_status_minus1 = 1;
+			if(coeff_zero_update != 0)  updated_status_zero   = 1;
+			if(coeff_plus1_update != 0)  updated_status_plus1  = 1;
+#endif
+
+			// Write LD Status registers
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+			rd_data &= 0xFFFC;
+			rd_data |= updated_status_minus1;
+			rd_data &= 0xFFF3;
+			rd_data |= (updated_status_zero << 2);
+			rd_data &= 0xFFCF;
+			rd_data |= (updated_status_plus1 << 4);
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+
+			present_coeff_minus1 = updated_coeff_minus1;
+			present_coeff_zero   = updated_coeff_zero;
+			present_coeff_plus1  = updated_coeff_plus1;
+
+			//Read LP coeff update till LP coeff is set to hold
+			do {
+				rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+				count++;
+				rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+				if((rd_data & BIT(1)) != BIT(1)) {
+					break;
+				}
+				rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+			} while (rd_data != 0x0);
+			//nlm_print("count:%d\n",count);
+
+			//Set LD Status to not updated
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+			rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated)
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+			count1++;
+			//if((count1%2) == 1) break;
+		} while (rd_data != 0x0);
+		//nlm_print("count1:%d\n",count1);
+
+	}
+}
+
+void adapt_rxeq_settings(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+
+	volatile uint32_t rd_data, count;
+	volatile uint32_t eye_value0, eye_value1, figure_of_merit_value;
+
+	volatile uint32_t RXCALEQ_DCGAIN;
+	volatile uint32_t RXCALEQ_DFEPSTAPF3DB;
+	volatile uint32_t RXCALEQ_DFEPSTAPGAIN;
+	volatile uint32_t RXCALEQ_DFEPTAP1GAIN;
+	volatile uint32_t RXCALEQ_DFEPTAP2GAIN;
+	volatile uint32_t RXCALEQ_DFEPTAP3GAIN;
+	volatile uint32_t RXCALEQ_DFEPTAP4GAIN;
+	volatile uint32_t RXCALEQ_HIFREQAGCCAP;
+	volatile uint32_t RXCALEQ_LOFREQAGCGAIN;
+	volatile uint32_t calculation_done;
+	volatile uint32_t rd_data1, rd_data2;
+	volatile uint32_t count_threshold;
+	uint64_t  cycles = 0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//peter added : basing on Vsemi 11/20/2013 E-mail
+
+	count_threshold = kr_param.count_threshold;
+
+	count = 0;
+	calculation_done = 0;
+	RXCALEQ_DCGAIN = 0;
+	RXCALEQ_DFEPSTAPF3DB =0;
+	RXCALEQ_DFEPSTAPGAIN =0;
+	RXCALEQ_DFEPTAP1GAIN =0;
+	RXCALEQ_DFEPTAP2GAIN =0;
+	RXCALEQ_DFEPTAP3GAIN =0;
+	RXCALEQ_DFEPTAP4GAIN =0;
+	RXCALEQ_HIFREQAGCCAP =0;
+	RXCALEQ_LOFREQAGCGAIN =0;
+
+	do {
+		//0. Initialize the locwrens
+		//PCSRXEQ_LOCWREN
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+		bit_clear(rd_data, BIT(6));
+		__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+
+		//2. Start RX EQ
+		//PCSRXEQ_START	31[0:0] 1'b1
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+		bit_set(rd_data, BIT(0));
+		__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+		//3, Wait for done and read figure of merit:
+		//RXEQ_DONE	32[3:3] (should be 1'b1)
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+		while ((rd_data & BIT(3)) != BIT(3)) {
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+		}
+
+		//4. reset the EQ start signal
+		//PCSRXEQ_START	31[0:0] 1'b0
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+		bit_clear(rd_data, BIT(0));
+		__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+		//5. Record the following register values from memory
+		// RXCALEQ_DCGAIN         24[2:0]    0 1 2 3 3'h0 // 3'h2
+		// RXCALEQ_DFEPSTAPF3DB   24[5:3]    0 1 2 3 3'h0
+		// RXCALEQ_DFEPSTAPGAIN   25[2:0]    0 1 2 3 3'h0
+		// RXCALEQ_DFETAP1GAIN    25[6:3]    0 1 2 3 4'h0
+		// RXCALEQ_DFETAP2GAIN    26[3:0]    0 1 2 3 4'h8
+		// RXCALEQ_DFETAP3GAIN    26[7:4]    0 1 2 3 4'h0
+		// RXCALEQ_DFETAP4GAIN    27[3:0]    0 1 2 3 4'h8
+		// RXCALEQ_LOFREQAGCGAIN  27[6:4]    0 1 2 3 3'h7
+		// RXCALEQ_HIFREQAGCCAP   28[7:3]    0 1 2 3 5'h0
+		// RXCALEQ_LOCWREN        86[3:3]    0 1 2 3 1'b0
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 24);
+		rd_data1 = (rd_data & 0x7);
+		rd_data2 = ((rd_data >> 3) & 0x7);
+		RXCALEQ_DCGAIN       = RXCALEQ_DCGAIN + rd_data1;
+		RXCALEQ_DFEPSTAPF3DB = RXCALEQ_DFEPSTAPF3DB +rd_data2;
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 25);
+		rd_data1 = (rd_data & 0x7);
+		rd_data2 = ((rd_data >> 3) & 0xF);
+		RXCALEQ_DFEPSTAPGAIN = RXCALEQ_DFEPSTAPGAIN + rd_data1;
+		RXCALEQ_DFEPTAP1GAIN = RXCALEQ_DFEPTAP1GAIN + rd_data2;
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 26);
+		rd_data1 = (rd_data & 0xF);
+		rd_data2 = ((rd_data >> 4) & 0xF);
+		RXCALEQ_DFEPTAP2GAIN = RXCALEQ_DFEPTAP2GAIN + rd_data1;
+		RXCALEQ_DFEPTAP3GAIN = RXCALEQ_DFEPTAP3GAIN + rd_data2;
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 27);
+		rd_data1 = (rd_data & 0xF);
+		rd_data2 = ((rd_data >>4) & 0xF);
+		RXCALEQ_DFEPTAP4GAIN = RXCALEQ_DFEPTAP4GAIN + rd_data1;
+		RXCALEQ_LOFREQAGCGAIN = RXCALEQ_LOFREQAGCGAIN + rd_data2;
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 28);
+		rd_data1 = ((rd_data >> 3) & 0x1F);
+		RXCALEQ_HIFREQAGCCAP = RXCALEQ_HIFREQAGCCAP + rd_data2;
+
+		count++;
+		if(count == count_threshold) {
+			calculation_done = 1;
+		} else {
+		}
+	} while(calculation_done != 1);
+
+	RXCALEQ_DCGAIN       = RXCALEQ_DCGAIN/count;
+	RXCALEQ_DFEPSTAPF3DB = RXCALEQ_DFEPSTAPF3DB/count;
+	RXCALEQ_DFEPSTAPGAIN = RXCALEQ_DFEPSTAPGAIN/count;
+	RXCALEQ_DFEPTAP1GAIN = RXCALEQ_DFEPTAP1GAIN/count;
+	RXCALEQ_DFEPTAP2GAIN = RXCALEQ_DFEPTAP2GAIN/count;
+	RXCALEQ_DFEPTAP3GAIN = RXCALEQ_DFEPTAP3GAIN/count;
+	RXCALEQ_DFEPTAP4GAIN = RXCALEQ_DFEPTAP4GAIN/count;
+	RXCALEQ_HIFREQAGCCAP = RXCALEQ_HIFREQAGCCAP/count;
+	RXCALEQ_LOFREQAGCGAIN =RXCALEQ_LOFREQAGCGAIN/count;
+
+
+	//nlm_print("KR4_STEP(9_LP_00_C) Calculate average regs values done\n");
+	kr_param.verbose = 0;
+	if (kr_param.verbose) {
+		nlm_print("RXCALEQ_DCGAIN = 0x%x\n", RXCALEQ_DCGAIN);
+		nlm_print("RXCALEQ_DFEPSTAPF3DB = 0x%x\n", RXCALEQ_DFEPSTAPF3DB);
+		nlm_print("RXCALEQ_DFEPSTAPGAIN = 0x%x\n", RXCALEQ_DFEPSTAPGAIN);
+		nlm_print("RXCALEQ_DFEPTAP1GAIN = 0x%x\n", RXCALEQ_DFEPTAP1GAIN);
+		nlm_print("RXCALEQ_DFEPTAP2GAIN = 0x%x\n", RXCALEQ_DFEPTAP2GAIN);
+		nlm_print("RXCALEQ_DFEPTAP3GAIN = 0x%x\n", RXCALEQ_DFEPTAP3GAIN);
+		nlm_print("RXCALEQ_DFEPTAP4GAIN = 0x%x\n", RXCALEQ_DFEPTAP4GAIN);
+		nlm_print("RXCALEQ_HIFREQAGCCAP = 0x%x\n", RXCALEQ_HIFREQAGCCAP);
+		nlm_print("RXCALEQ_LOFREQAGCGAIN =0x%x\n", RXCALEQ_LOFREQAGCGAIN);
+	}
+
+	//7. Set RXCALEQ_LOCWREN(0 1 2 3 'd86[3:3]) to 1'b0 to enable RXCALEQ_* regs memory overwite, Vsemi document page 187
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+	bit_clear(rd_data, BIT(3));
+	__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+
+	//8. Write the corresponding average values back to the following registers
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 24);
+	rd_data = rd_data & 0xFFC0;             //'d24, clear [5:3], [2:0]
+	rd_data = rd_data | (RXCALEQ_DFEPSTAPF3DB << 3) | RXCALEQ_DCGAIN;
+	__netsoc_write_pma2p0_reg(base, lane_no, 24, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 24);
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 25);
+	rd_data = rd_data & 0xFF80;              //'d25, clear [6:3], [2:0]
+	rd_data = rd_data | (RXCALEQ_DFEPTAP1GAIN << 3) | RXCALEQ_DFEPSTAPGAIN;
+	__netsoc_write_pma2p0_reg(base, lane_no, 25, rd_data);
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 26);
+	rd_data = rd_data & 0xFF00;              //'d26, clear [7:4], [3:0]
+	rd_data = (RXCALEQ_DFEPTAP3GAIN << 4) |  RXCALEQ_DFEPTAP2GAIN;
+	__netsoc_write_pma2p0_reg(base, lane_no, 26, rd_data);
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 27);
+	rd_data = rd_data & 0xFF80;              //'d27, clear [6:4], [3:0]
+	rd_data = rd_data | (RXCALEQ_LOFREQAGCGAIN << 4) | RXCALEQ_DFEPTAP4GAIN;
+	__netsoc_write_pma2p0_reg(base, lane_no, 27, rd_data);
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 28);
+	rd_data = rd_data & 0xFF07;              //'d27, clear [7:3]
+	rd_data = (RXCALEQ_HIFREQAGCCAP << 3) | rd_data ;
+	__netsoc_write_pma2p0_reg(base, lane_no, 28, rd_data);
+
+	//nlm_print("KR4_STEP(9_LP_00_D) Writing Calculated average regs values back to memory done\n");
+}
+
+uint32_t get_eyediag_eyesum(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data, count;
+	volatile uint32_t eye_value0, eye_value1, figure_of_merit_value;
+	volatile uint32_t calculation_done;
+	volatile uint32_t rd_data1, rd_data2;
+	volatile uint32_t count_threshold;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//*peter comments: Generate Figure of Merit (FOM)
+	//9. Set RXCALEYEDIAGFSMIN_LOCWREN(0 1 2 3 'd86[4:4]) to 1'b0
+
+	count=0;
+	calculation_done = 0;
+	count_threshold = kr_param.count_threshold;
+
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+	bit_clear(rd_data, BIT(4));              //'d86, clear [4:4]
+	__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+
+	figure_of_merit_value = 0;
+
+	do {
+		//*peter comments: 10) Set RXCALEYEDIAGFSMIN_START(0 1 2 3 'd31[1:1]) to 1'b1
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+		//bit_clear(rd_data, BIT(1));              //'d31, clear   [1:1]  = 1
+		bit_set(rd_data, BIT(1));              //'d31, set   [1:1]  = 1
+		__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+		//*peter comments: 11) Wait for assertion of RXCALEYEDIAGFSM_DONE (0 1 2 3 `d32[0:0])
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+		while ((rd_data & 0x1) != 0x1) {
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+		}
+
+		//*peter comments: 12) Record the 4-point eye value from RXCALEYEDIAGFSM_EYESUM, Vsemi document page 204
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 35);
+		eye_value1 = rd_data & 0xFF;
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 36);
+		eye_value0 = rd_data & 0x3F;
+
+		figure_of_merit_value = figure_of_merit_value + ((eye_value1 << 6) | (eye_value0));
+
+		//13) Set RXCALEYEDIAGFSMIN_START(0 1 2 3 'd31[1:1]) to 1'b0
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+		bit_clear(rd_data, BIT(1));
+		__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+		count++;
+		if(count >= count_threshold) {
+			if (figure_of_merit_value !=0) {
+				calculation_done = 1;
+			} else {
+				calculation_done = 0;
+			}
+			//nlm_print("KR4 LINK_PARTNER_TRAINING: count_value: count:%d, calculation_done = %d \n",count, calculation_done);
+		} else {
+			//nlm_print("KR4 LINK_PARTNER_TRAINING: count_value: count:%d, calculation_done = %d \n",count, calculation_done);
+		}
+	} while(calculation_done != 1);
+
+	//nlm_print("KR4 LINK_PARTNER_TRAINING: calculation done \n");
+
+	//*peter comments: 13) Repeat Setp 10 and Step 12 50 times and take the average valuse of the results collected
+	figure_of_merit_value = figure_of_merit_value/count;
+	count=0;
+	calculation_done = 0;
+
+	//nlm_print("KR4_STEP(9_LP_00_G) AVERAGE figure_of_merit_value = 0x%x, count = %d\n", figure_of_merit_value, count);
+	//*peter comments: 14) Set RXCALEYEDIAGFSMIN_LOCWREN(0 1 2 3 'd86[4:4]) to 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+	bit_set(rd_data, BIT(4));
+	__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+
+	//*peter comments: 15) Set RXCALEQ_LOCWREN (0 1 2 3 'd86[3:3]) to 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+	bit_set(rd_data, BIT(3));
+	__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+
+
+	return (figure_of_merit_value);
+
+}
+
+uint32_t get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	volatile uint32_t eye_value0, eye_value1, figure_of_merit_value;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//0. Initialize the locwrens
+	//PCSRXEQ_LOCWREN
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+	bit_clear(rd_data, BIT(6));
+	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+
+	//2. Start RX EQ
+	//PCSRXEQ_START	31[0:0] 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+	bit_set(rd_data, BIT(0));
+	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+	//3, Wait for done and read figure of merit:
+	//RXEQ_DONE	32[3:3] (should be 1'b1)
+	//RXEQ_BEST_EYE_VAL	29[7:0],30[5:0]
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+	while ((rd_data & BIT(3)) != BIT(3)) {
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
+	}
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 29);
+	eye_value1 = rd_data & 0xFF;
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 30);
+	eye_value0 = rd_data & 0x3F;
+	figure_of_merit_value = ((eye_value1 << 6) | (eye_value0));
+
+	//4. reset the EQ start signal
+	//PCSRXEQ_START	31[0:0] 1'b0
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
+	bit_clear(rd_data, BIT(0));
+	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
+
+	return (figure_of_merit_value);
+}
+
+void __netsoc_bkpl_setup_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+	rd_data  |= (0x0 << 12); // initialize
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	rd_data  |= (0x0 << 0); // to push state machine into ( mr_trained ) remote training state
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
+}
+
+void __netsoc_bkpl_set_cl73_enable(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t data;
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	uint32_t port_no = (block*4) + lane_no;
+	uint32_t phymode = get_phy_mode(nae, block);
+
+	//Step1:
+	//configure KR ability 0-1-2 registers
+	//ability 0
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
+	if(kr_param.next_page_an == 1) {
+		rd_data |= (0x1 << 15); // Next Page
+	}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_0, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
+	nlm_print("AN_ABILITY0:  block:%d lane:%d value is 0x%x\n", block, lane_no, rd_data);
+
+	//ability 1
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
+	if(block == 0) {
+		rd_data &= 0xFFE0; //Transmitted nonce [4:0]
+		rd_data |= 0x1F;
+	}
+	if(block == 1) {
+		rd_data &= 0xFFE0; //Transmitted nonce
+		rd_data |= 0x07;
+	}
+	if(phymode==PHYMODE_XFI){
+		rd_data |= (0x1 << 7); // technology ability is 10g-KR
+	}else if(phymode==PHYMODE_XLAUI){
+		rd_data |= (0x1 << 8) | (0x1 << 7) | (0x1 << 6) | (0x1 << 5);
+	}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_1, rd_data);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
+	//nlm_print("AN_ABILITY1:  block:%d lane:%d value is %x\n", block, lane_no, rd_data);
+
+	//ability 2
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_2);
+	//nlm_print("AN_ABILITY2:  block:%d lane:%d value is %x\n", block, lane_no, rd_data);
+	//read status registers to reset all latches
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	//nlm_print("AN_STATUS:  block:%d lane:%d read value is %x\n", block, lane_no, rd_data);
+
+	//ms count reg
+	__netsoc_write_kr_reg(base, lane_no, KXAN_MS_COUNT, 0xFFFF);
+
+
+#ifdef DME_EN
+	//  1. PCSRX_DATAWIDTH	0 1 2 3	'd5[2:0]   3'b011 (The register values set must match the interface control for ICTL_MULTI_RXRATE_L*_.)
+	//     PCSRX_DIVRATE	0 1 2 3	'd6[2:0]   3'b011 (The register values set must match the interface control for ICTL_MULTI_RXDATAWIDTH_L*_. )
+	//      PCSRX_DME_EN		0 1 2 3	'd40[2:2]   1'b1
+	//  2. RXSIGDET_CDRLOCK2DATA	0 1 2 3	'd11[5:5] 1'b0
+	//  3. RXSIGDET_LOCWREN	0 1 2 3	'd230[2:2] 1'b0
+	//  4. PCSRX_LOCWREN	0 1 2 3	'd85[4:4] 1'b0
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 5);
+	rd_data &= 0xFFF8;
+	rd_data |= 0x5;
+	__netsoc_write_pma2p0_reg(base, lane_no, 5, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 6);
+	rd_data &= 0xFFFC;
+	rd_data |= 0x3;
+	__netsoc_write_pma2p0_reg(base, lane_no, 6, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 11);
+	bit_clear(rd_data, BIT(5));
+	__netsoc_write_pma2p0_reg(base, lane_no, 11, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 230);
+	bit_clear(rd_data, BIT(2));
+	__netsoc_write_pma2p0_reg(base, lane_no, 230, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+	bit_clear(rd_data, BIT(4));
+	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+	//nlm_print("DME is enabled:  block:%d lane:%d \n", block, lane_no);
+#endif
+
+	//Step2:
+	//Enable auto-negotiation
+	//enable the AN first
+	data = netsoc_read_mac_reg(base, KR_CTRL);
+	if(kr_param.kr_enable[port_no] == 1) {
+		data |= (0x1 << lane_no);
+		nlm_print("KR enabled for block:%d lane:%d\n", block, lane_no);
+	}
+	data &= (~0xF0);
+	data |= KR_PHY_STATUS;
+	netsoc_write_mac_reg(base, KR_CTRL, data);
+	data = netsoc_read_mac_reg(base, KR_CTRL);
+	//control
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	if(kr_param.partner_type == 1) rd_data |= (0x1 << 9); // an-restart
+	if(block == 1) rd_data |= (0x1 << 9); // an-restart /*useful for loopback mode*/
+	rd_data |= (0x1 << 12); // an-enable
+	if(kr_param.next_page_an == 1) {
+		if(block == 0) rd_data |= (0x1 << 13); // extended NP
+		//rd_data |= (0x1 << 13); // extended NP
+	}
+	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
+	//rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+	//nlm_print(" AN_CONTROL:  block:%d lane:%d value is 0x%x\n", block, lane_no, rd_data);
+
+}
+
+int perform_cl73_base_page(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint32_t count;
+	uint32_t restart_cnt=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block);
+
+	count=1;
+
+	//Step3:
+	//check for base page exchange completion
+	//status register
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	//nlm_print("  block:%d lane:%d KXAN_STATUS:0x%x\n", block, lane_no, rd_data);
+	while((rd_data & BIT(6)) != BIT(6)) {
+		//rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
+		//nlm_print("KXAN_ABILITY_0: value is 0x%x\n",rd_data);
+		//rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
+		//nlm_print("KXAN_ABILITY_1: value is 0x%x\n",rd_data);
+		//rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_2);
+		//nlm_print("KXAN_ABILITY_2: value is 0x%x\n",rd_data);
+		count++;
+		if(count%200000 == 0) {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+			if(block == 1) rd_data |= (0x1 << 9); // an-restart
+			rd_data |= (0x1 << 12); // an-enable
+			__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
+			nlm_print("restart\n");
+			restart_cnt++;
+			//nlm_print("  block:%d lane:%d restart AN\n", block, lane_no);
+		}
+		if(restart_cnt == 5) {
+			nlm_print("restart failed\n");
+			return(1);
+		}
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	}
+	nlm_print("count:%d\n",count);
+
+	if(kr_param.read_rem_ability_registers == 1) {
+		//Read rem_ability registers:
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_0);
+		nlm_print("AN_REM_ABILITY0: value is 0x%x\n",rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_1);
+		nlm_print("AN_REM_ABILITY1: value is 0x%x\n",rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_2);
+		nlm_print("AN_REM_ABILITY2: value is 0x%x\n",rd_data);
+	}
+
+	//If remote device does not have AN capability, AN process will be stuck at this stage,timeout to be implemented in this state to exit - MTIP spec
+
+
+#ifdef DME_EN
+	if((phymode == PHYMODE_XLAUI) && lane_no != 0) {
+	} else {
+		//Enable link training after AN_GOOD_CHECK state is reached
+		rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+		if(phymode == PHYMODE_XLAUI) {
+			while((rd_data & BIT(5)) == 0) { //40GKR4
+				rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+			}
+		} else if (phymode == PHYMODE_XFI) {
+			while((rd_data & BIT(3)) == 0) { //10GKR
+				rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+			}
+		}
+		//nlm_print(" block:%d lane:%d :AN_GOOD_CHECK state reached on DUT\n", block,lane_no);
+	}
+
+	//To disable DME:
+	//  1. PCSRX_LOCWREN	0 1 2 3	'd85[4:4] 1'b1
+	//  2. RXSIGDET_LOCWREN	0 1 2 3	'd230[2:2] 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+	bit_set(rd_data, BIT(4));
+	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 230);
+	bit_set(rd_data, BIT(2));
+	__netsoc_write_pma2p0_reg(base, lane_no, 230, rd_data);
+#endif
+
+
+	return(0);
+}
+
+void set_cl73_next_page(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(kr_param.next_page_an == 1) {
+		//Step 4 (optional)
+		//configure NP ability registers
+		//ability 0
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
+		if(kr_param.message_page == 1) {
+			rd_data |= (0x1 << 13); // set MP
+			rd_data &= 0xFFFFF800; //10:0 //Refer to NextPage Message code field definitions (IEEE Std 802.3-2005 Annex28C)
+			rd_data |= (0x1 << 0);
+		} else {
+			rd_data |= (0x0 << 13); // set MP
+			rd_data &= 0xFFFFF800; //10:0
+			rd_data |= (0xAB + block);
+		}
+		rd_data |= (0x0 << 15); // Next page (XNP)
+		__netsoc_write_kr_reg(base, lane_no, AN_XNP_0, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
+		nlm_print("XNP_ABILITY0:  block:%d lane:%d value is %x\n", block, lane_no, rd_data);
+
+		//ability 1
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
+		rd_data &= 0xFFFF0000;
+		rd_data |= ( 0xABCD + block) ;//15:0
+		__netsoc_write_kr_reg(base, lane_no, AN_XNP_1, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
+		nlm_print("XNP_ABILITY1:  block:%d lane:%d value is %x\n", block, lane_no, rd_data);
+
+		//ability 2
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
+		rd_data &= 0xFFFF0000;
+		rd_data |= (0xBBBB + block);//15:0
+		__netsoc_write_kr_reg(base, lane_no, AN_XNP_2, rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
+		nlm_print("XNP_ABILITY2:  block:%d lane:%d value is %x\n", block, lane_no, rd_data);
+	}
+}
+
+void perform_cl73_next_page(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(kr_param.next_page_an == 1) {
+		//check for next page exchange completion
+		//status register
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+		// looping on status until an complete or page received
+		while((rd_data & BIT(6)) == 0 ) {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+		}
+		nlm_print(" AN_STATUS:  block:%d lane:%d Next page exchange completed value:0x%x\n", block, lane_no, rd_data);
+
+		//Read remote next page ability registers:
+		rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_0);
+		nlm_print("AN_NP_REM_ABILITY0: value is %x\n",rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_1);
+		nlm_print("AN_NP_REM_ABILITY1: value is %x\n",rd_data);
+		rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_2);
+		nlm_print("AN_NP_REM_ABILITY2: value is %x\n",rd_data);
+
+		//disable XNP in control register
+		//control register
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
+		rd_data |= (0x0 << 13); // extended NP
+		__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
+	}
+}
+
+void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block);
+
+	if((phymode == PHYMODE_XLAUI) && lane_no != 0) {
+	} else {
+		//Enable link training after AN_GOOD_CHECK state is reached
+		rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+		if(phymode == PHYMODE_XLAUI) {
+			while((rd_data & BIT(5)) == 0) { //40GKR4
+				rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+			}
+		} else if (phymode == PHYMODE_XFI) {
+			while((rd_data & BIT(3)) == 0) { //10GKR
+				rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
+			}
+		}
+		if(kr_param.verbose == 1) nlm_print("enable_link_training:  block:%d lane:%d :AN_GOOD_CHECK state reached on DUT\n", block,lane_no);
+	}
+
+#ifdef DME_EN
+	//To disable DME:
+	//  1. PCSRX_LOCWREN	0 1 2 3	'd85[4:4] 1'b1
+	//  2. RXSIGDET_LOCWREN	0 1 2 3	'd230[2:2] 1'b1
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
+	bit_set(rd_data, BIT(4));
+	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
+	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 230);
+	bit_set(rd_data, BIT(2));
+	__netsoc_write_pma2p0_reg(base, lane_no, 230, rd_data);
+#endif
+
+	//rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+	//rd_data |= (0x1 << 0); // restart training
+	//rd_data |= (0x1 << 1); // training enable
+	//__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, 0x3);
+	//rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+	//nlm_print(" c:%d l:%d Enable LT 0x%x\n", block,lane_no, rd_data);
+}
+
+#if 0
+void wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t cnt=0,cnt1=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(block == 1) {
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1_MASK);
+		rd_data |= (0x1 << 22);
+		write_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1_MASK, rd_data);
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+		while((rd_data & BIT(22)) == 0) {
+			rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+		}
+		nlm_print("wait_for_lt_int:  block:%d lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n", block, lane_no, rd_data);
+		rd_data |= (0x1 << 22); //write 1 to clear
+		write_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1, rd_data);
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+	}
+	if(block == 0) {
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1_MASK);
+		rd_data |= (0x1 << 23);
+		write_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1_MASK, rd_data);
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+		while((rd_data & BIT(23)) == 0) {
+			rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+		}
+		nlm_print("wait_for_lt_int:  block:%d lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n", block, lane_no, rd_data);
+		rd_data |= (0x1 << 23); //write 1 to clear
+		write_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1, rd_data);
+		rd_data = read_netior_reg(inst_no, BLK_TYPE_NAE, INTF_TYPE_NETIOR, NETIOR_INT1);
+	}
+}
+#endif
+
+
+void restart_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+	rd_data |= (0x1 << 0); // restart training
+	rd_data |= (0x1 << 1); // training enable
+	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
+	nlm_print("restart_link_training:  block:%d lane:%d restart training \n", block,lane_no);
+}
+
+int wait_for_frame_lock(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint32_t count=0;
+	uint32_t restart_cnt=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	while((rd_data & BIT(1)) != BIT(1)) {
+		nlm_print(".");
+		count++;
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		if((count%50) == 0) {
+			restart_cnt++;
+			restart_link_training(nae, block, lane_no);
+			if(restart_cnt== 10) {
+				nlm_print("frame lock not achieved\n");
+				return(1);
+			}
+		}
+	}
+	//nlm_print("\n");
+	//nlm_print("count:%d\n", count);
+	return (0);
+}
+
+void send_preset(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	uint64_t cycles = 0;
+	uint64_t count= 0;
+	uint64_t count1= 0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(kr_param.partner_type == 1) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+		rd_data |= (0x1 << 13); //preset
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+		//Read LP status register
+		do {
+			count++;
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+			//} while((rd_data & 0x3F) != 0x0); //FIXME : Check with Switch team
+	} while((rd_data & 0x3F) != 0x3F); //FIXME : Check with Switch team
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0x0);
+		//do {
+		//  count1++;
+		//  rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		//} while((rd_data & 0x3F) != 0x0);
+
+} else {
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+	rd_data |= (0x1 << 13); //preset
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	//Read LP status register
+	do {
+		count++;
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		if(count%20 ==0) break;
+	} while((rd_data & 0x3F) != 0xC); 
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0x0);
+	do {
+		count1++;
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+	} while((rd_data & 0x3F) != 0x0);
+}
+
+
+}
+
+void send_initialize(nae_t *nae, uint32_t block, uint32_t lane_no)
+{
+	volatile uint32_t rd_data;
+	volatile uint32_t pre_tap_status, main_tap_status, post_tap_status;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+	rd_data |= (0x1 << 12); //initialize
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	nlm_print("send_initialize:   block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		pre_tap_status = (rd_data & 0x3);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+	} while((pre_tap_status == 0x0) && (main_tap_status == 0x0) && (post_tap_status == 0x0));
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0x0); //HOLD
+	nlm_print("send_initialize: Set all coeffs to HOLD  block:%d lane:%d Value of LD coefficient update register\n", block, lane_no);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		pre_tap_status = (rd_data & 0x3);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+	} while((pre_tap_status != 0x0) && (main_tap_status != 0x0) && (post_tap_status != 0x0));
+	nlm_print("send_initialize:  block:%d lane:%d Value of LP status register is 0x%x -2\n", block, lane_no, rd_data);
+}
+
+int send_coeff_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update) 
+{
+	volatile uint32_t coeff_status;
+	volatile uint32_t rd_data;
+	uint64_t  count= 0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(kr_param.partner_type == 1) {
+		//Update LD Coeff Update reg
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, update);
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0);
+		//Read LP status register
+		do {
+			count++;
+			coeff_status= __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+			if((count%50) == 0) break; 
+		} while ((coeff_status & 0x3F) == 0x0);
+		count= 0;
+		// Send HOLD
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0x0);//hold
+		//Read LP status register
+		do {
+			count++;
+			coeff_status = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		} while((coeff_status & 0x3F) != 0x0);
+
+	} else {
+		//Update LD Coeff Update reg
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, update);
+
+		//Read LP status register
+		do {
+			coeff_status= __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		} while ((coeff_status & 0x3F) == 0x0);
+		// Send HOLD
+		__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, 0x0);//hold
+		//Read LP status register
+		do {
+			coeff_status = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		} while((coeff_status & 0x3F) != 0x0);
+	}
+	return (0);
+}
+#if 0
+void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update) 
+{
+	volatile uint32_t main_tap_coeff, main_tap_status;
+	volatile uint32_t rd_data;
+	uint64_t  cycles = 0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	main_tap_coeff = update;
+	rd_data = (main_tap_coeff << 2);
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	//nlm_print("send_maintap_update: SEND C(0) update  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+		if((main_tap_status == 0x3) || (main_tap_status == 0x2) || (main_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			main_tap_coeff = 0x0; // hold
+			rd_data = (main_tap_coeff << 2);
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+			//nlm_print("send_maintap_update: Set C(0) to HOLD  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+		}
+	} while (main_tap_status == 0x0);
+
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		main_tap_status = ((rd_data & 0xC) >> 2);
+	} while(main_tap_status != 0x0);
+}
+
+void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
+{
+	volatile uint32_t pre_tap_coeff, pre_tap_status;
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	pre_tap_coeff = update;
+	rd_data = pre_tap_coeff;
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	//nlm_print("send_pretap_update: SEND C(-1) update  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		//nlm_print("send_pretap_update:  block:%d lane:%d Value of LP status register is 0x%x\n", block, lane_no, rd_data);
+		pre_tap_status = (rd_data & 0x3);
+		if((pre_tap_status == 0x3) || (pre_tap_status == 0x2) || (pre_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			pre_tap_coeff = 0x0; // hold
+			rd_data = pre_tap_coeff;
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			//nlm_print("send_pretap_update: Set C(-1) to HOLD  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+		}
+	} while (pre_tap_status == 0x0);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		pre_tap_status = (rd_data & 0x3);
+	} while(pre_tap_status != 0x0);
+}
+
+void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
+{
+	volatile uint32_t post_tap_coeff, post_tap_status;
+	volatile uint32_t rd_data;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	post_tap_coeff = update;
+	rd_data = (post_tap_coeff << 4);
+	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	//nlm_print("send_posttap_update: SEND C(+1) update  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+
+	//Read LP status register
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		//nlm_print("send_posttap_update:  block:%d lane:%d Value of LP status register is 0x%x \n", block, lane_no, rd_data);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+		if((post_tap_status == 0x3) || (post_tap_status == 0x2) || (post_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
+			post_tap_coeff = 0x0; // hold
+			rd_data = (post_tap_coeff << 4);
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+			//nlm_print("send_posttap_update: Set C(+1) to HOLD  block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+		}
+	} while (post_tap_status == 0x0);
+	do {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		post_tap_status = ((rd_data & 0x30) >> 4);
+	} while(post_tap_status != 0x0);
+}
+#endif
+
+int __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	volatile uint32_t eye_value=0, updated_eye_value=0;
+	uint64_t count=0;
+	volatile uint64_t cycles = 0;
+	uint32_t N=3, M= 1;
+	volatile uint32_t pos;
+	uint32_t port_no;
+	uint32_t i,k=2;
+	int coeff_update_failed =0;
+	int no_frame_lock =0;
+	int debug=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint32_t phymode = get_phy_mode(nae, block);
+
+	pos=0;
+
+	if(kr_param.skip == 0) {
+		port_no = block*4 + lane_no;
+
+		if (kr_param.partner_type == 0) {
+
+			if(phymode == PHYMODE_XLAUI)  N=2;
+			//To position0
+			send_preset(nae, block, lane_no);
+			//Set RXCALEQ_LOCWREN (0 1 2 3 'd86[3:3]) to 1'b1
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+			bit_set(rd_data, BIT(3));
+			__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+			//
+			adapt_rxeq_settings(nae, block, lane_no);
+			kr_param.best_eye_value[port_no] = get_eyediag_eyesum(nae, block, lane_no);
+			kr_param.eye_value[port_no][pos] = kr_param.best_eye_value[port_no];
+			read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+
+
+			//To position1
+			kr_param.step_size=N;
+			for(i=0; i<k; i++) {
+				pos++;
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x18); //c0decrement, c+1increment
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+				if(updated_eye_value > kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			//To position2
+			if(phymode == PHYMODE_XFI) kr_param.step_size=N/3;
+			else kr_param.step_size=N/2;
+
+			for(i=0; i<(k*2); i++) {
+				pos++;
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x18); //c0decrement, c+1increment
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+				if(updated_eye_value > kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			//To position3
+			kr_param.step_size=M;
+			for(i=0; i<k; i++) {
+				pos++;
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x9); //c0decrement, c-1increment
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+				if(updated_eye_value > kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+			}
+
+			//To position4
+			for(i=0; i<k; i++) {
+				pos++;
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x9); //c0decrement, c-1increment
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+				if(updated_eye_value > kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			//To position5
+			kr_param.step_size=N;
+			for(i=0; i<k; i++) {
+				pos++;
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x24); //c0increment, c+1decrement
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				read_vsemi_rxequalization_registers(nae, block, lane_no, pos);
+				if(updated_eye_value > kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+			}
+
+			//Iteration2 TXEQ space search
+			//To the best FOM recorded position
+			pos=0;
+			send_preset(nae, block, lane_no);
+
+			for(i=0; i<k; i++) {
+				if(pos <= kr_param.best_position[port_no]){
+					//To position1
+					kr_param.step_size=N;
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x18); //c0decrement, c+1increment
+					pos++;
+				}
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			for(i=0; i<(k*2); i++) {
+				if(pos <= kr_param.best_position[port_no]){
+					//To position2
+					if(phymode == PHYMODE_XFI) kr_param.step_size=N/3;
+					else kr_param.step_size=N/2;
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x18); //c0decrement, c+1increment
+					pos++;
+				}
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			for(i=0; i<k; i++) {
+				if(pos <= kr_param.best_position[port_no]){
+					//To position3
+					kr_param.step_size=M;
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x9); //c0decrement, c-1increment
+					pos++;
+				}
+			}
+
+			for(i=0; i<k; i++) {
+				if(pos < kr_param.best_position[port_no]){
+					//To position4
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x9); //c0decrement, c-1increment
+					pos++;
+				}
+			}
+
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+
+			for(i=0; i<k; i++) {
+				if(pos < kr_param.best_position[port_no]){
+					//To position5
+					kr_param.step_size=N;
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x24); //c0increment, c+1decrement
+					pos++;
+				}
+			}
+
+			adapt_rxeq_settings(nae, block, lane_no);
+
+		} else { //TD2 switch algorithm
+
+			if(kr_param.partner_type == 1)  k=10;
+			//To position0
+			send_preset(nae, block, lane_no);
+			//Set RXCALEQ_LOCWREN (0 1 2 3 'd86[3:3]) to 1'b1
+			rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 86);
+			bit_set(rd_data, BIT(3));
+			__netsoc_write_pma2p0_reg(base, lane_no, 86, rd_data);
+			//
+			adapt_rxeq_settings(nae, block, lane_no);
+			if(kr_param.with_restart_link_training == 1) {
+				restart_link_training(nae, block, lane_no);
+				no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+				if (no_frame_lock == 1) {
+					return(1);
+				}
+			}
+			kr_param.best_eye_value[port_no] = get_eyediag_eyesum(nae, block, lane_no);
+			kr_param.eye_value[port_no][pos] = kr_param.best_eye_value[port_no];
+			//read_vsemi_rxequalization_registers(block, lane_no, pos);
+
+			for(i=0; i<k; i++) {
+				pos++;
+				//coeff_update_failed = send_coeff_update(block, lane_no, 0x18); //c0decrement, c+1increment
+				coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x28); //c0decrement, c+1increment
+#ifndef PALLADIUM_TEST
+				adapt_rxeq_settings(nae, block, lane_no);
+				updated_eye_value = get_eyediag_eyesum(nae, block, lane_no);
+				kr_param.eye_value[port_no][pos] = updated_eye_value;
+				//read_vsemi_rxequalization_registers(block, lane_no, pos);
+				if(updated_eye_value >= kr_param.best_eye_value[port_no]) {
+					kr_param.best_eye_value[port_no] = updated_eye_value;
+					kr_param.best_position[port_no] = pos;
+				}
+#endif
+				if (k%3 ==0) {
+					if(kr_param.with_restart_link_training == 1) {
+						restart_link_training(nae, block, lane_no);
+						no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+						if (no_frame_lock == 1) {
+							return(1);
+						}
+					}
+				}
+			}
+
+			//Iteration2 TXEQ space search
+			//To the best FOM recorded position
+			pos=0;
+			send_preset(nae, block, lane_no);
+			for(i=0; i<k; i++) {
+				if(pos <= kr_param.best_position[port_no]){
+					//coeff_update_failed = send_coeff_update(block, lane_no, 0x18); //c0decrement, c+1increment
+					coeff_update_failed = send_coeff_update(nae, block, lane_no, 0x28); //c0decrement, c+1increment
+					pos++;
+				}
+				if (k%3 ==0) {
+					if(kr_param.with_restart_link_training == 1) {
+						restart_link_training(nae, block, lane_no);
+						no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+						if (no_frame_lock == 1) {
+							return(1);
+						}
+					}
+				}
+			}
+
+			adapt_rxeq_settings(nae, block, lane_no);
+		}
+	}//skip
+	/***
+	////////// OLD VSEMI TXEQ ALGORITHM CODE //////
+	//reset_perfctr();
+	//start_perfctr();
+	//1
+	//rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
+	//rd_data |= (0x1 << 12); //initialize
+	//__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
+	//nlm_print(" link_partner_training:   block:%d lane:%d Value of LD coefficient update register is 0x%x\n", block, lane_no, rd_data);
+
+	//2
+	//rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	//nlm_print("link_partner_training : block:%d: PMD STATUS value:0x%x\n", block,rd_data);
+
+	//3 Record the figure of merit
+	//Assert Start and wait for done and then record figure of merit
+	//eye_value = get_eyediag_figure_of_merit(block, lane_no);
+	//nlm_print("link_partner_training:  block:%d lane:%d  Initial eye_value: 0x%x\n", block, lane_no, eye_value);
+	eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:  block:%d lane:%d  Initial eyesum_value: 0x%x\n", block, lane_no, eye_value);
+
+	//send_initialize(block, lane_no);
+	//eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:  block:%d lane:%d  After initialize eyesum_value: 0x%x\n", block, lane_no, eye_value);
+
+	//4 while figure of merit is improved
+	do {
+	if(count > 0) eye_value = updated_eye_value;
+	//i   Send DEC C(0)
+	send_maintap_update(block, lane_no, 0x2); //decrement
+	//updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:  block:%d lane:%d  After step 4i updated_eye_value:0x%x\n", block, lane_no, updated_eye_value);
+	//ii   Send INC C(-1)
+	send_pretap_update(block, lane_no, 0x1); //increment
+	//iii
+	//iv
+	//updated_eye_value = get_eyediag_figure_of_merit(block, lane_no);
+	updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 4ii updated_eyesum_value: 0x%x\n", block, lane_no, updated_eye_value);
+	count++;
+	} while (updated_eye_value > eye_value);
+
+	//v   Send DEC C(-1)
+	send_pretap_update(block, lane_no, 0x2); //decrement
+	//updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 4v updated_eye_value: 0x%x\n", block, lane_no, updated_eye_value);
+
+	count = 0;
+	//5 while figure of merit is improved
+	do {
+	//i   Send DEC C(0)
+	eye_value = updated_eye_value;
+	send_maintap_update(block, lane_no, 0x2); //decrement
+	//updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 5i updated_eye_value: 0x%x\n", block, lane_no, updated_eye_value);
+	//ii  Send INC C(+1)
+	send_posttap_update(block, lane_no, 0x1); //increment
+	//iii
+	//iv
+	//updated_eye_value = get_eyediag_figure_of_merit(block, lane_no);
+	updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 5ii updated_eye_value: 0x%x\n", block, lane_no, updated_eye_value);
+	count++;
+	} while (updated_eye_value > eye_value);
+
+	//6  Send DEC C(+1)
+	send_posttap_update(block, lane_no, 0x2); //decrement
+	//updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 6: updated_eye_value: 0x%x\n", block, lane_no, updated_eye_value);
+
+	//7   Send INC C(0)
+	send_maintap_update(block, lane_no, 0x1); //increment
+	//updated_eye_value = get_eyediag_eyesum(block, lane_no);
+	//nlm_print("LP:   block:%d lane:%d  After step 7 updated_eye_value: 0x%x\n", block, lane_no, updated_eye_value);
+
+#endif
+
+	***/
+
+		if(coeff_update_failed == 1) {
+			nlm_print("lp failed\n");
+		} else {
+			//LD status
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+			rd_data &= 0xFFC0 ; //[5:0] = 6'h0
+			rd_data |= (0x1 << 15); // receiver ready
+			__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
+			//rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
+			//nlm_print("LP:   block:%d lane:%d Set receiver ready\n", block,lane_no);
+
+			if(kr_param.partner_type == 0) {
+				if(block == 0) {
+					//PMD status
+					rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+					rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
+					__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
+				}
+			}
+		}
+	return (coeff_update_failed);
+}
+
+int wait_for_lp_lt_done(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	//void wait_for_lp_lt_done(nae_t *nae, uint32_t block, uint32_t lane_no) {
+	volatile uint32_t rd_data;
+	uint32_t count=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(block == 0) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
+			count++;
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+			if(count%300 == 0)
+				return(1);
+		}
+		nlm_print("LP:   block:%d lane:%d Reached lt_done\n", block, lane_no);
+		count = 0;
+		//Read LP status
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		while ((rd_data & BIT(15)) == 0) {
+			count++;
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+			if(count%50 == 0)
+				return(1);
+		}
+		nlm_print("LP: block:%d lane:%d Value of LP status register is 0x%x\n", block,lane_no, rd_data);
+	}
+	return(0);
+}
+
+int  __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint64_t  cycles = 0;
+	uint64_t  count = 0;
+	int no_frame_lock =0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//MTIP step1: Keep polling PMD Status until it indicates frame lock
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	while((rd_data & BIT(1)) != BIT(1)) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+	}
+	nlm_print("  block:%d lane:%d Frame lock achieved\n", block,lane_no);
+
+	//Read LP status
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+	while ((rd_data & BIT(15)) == 0) {
+		count++;
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
+		if(((rd_data & 0x3F)!= 0x0) || ((rd_data & BIT(13)) == BIT(13))) {
+			if(kr_param.partner_type == 1) {
+				rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+				if((rd_data & BIT(1)) != BIT(1)) {
+					if(kr_param.with_restart_link_training == 1) {
+						restart_link_training(nae, block, lane_no);
+						no_frame_lock = wait_for_frame_lock(nae, block, lane_no);
+						if (no_frame_lock == 1) {
+							return(1);
+						}
+					}
+				}
+			}
+			program_tx_driver(nae, block, lane_no);
+		}
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
+		//if((count%300000) == 0) {
+		//  //nlm_print("ld_failed1\n");
+		//  return(1);
+		//}
+	}
+
+	if(kr_param.partner_type == 1) {
+		// PMD status
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
+		__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
+	} else {
+		if(block == 1) {
+			// PMD status
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+			rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
+			__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
+		}
+	}
+	return(0);
+}
+
+int __netsoc_bkpl_wait_for_ld_lt_done(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint32_t count=0;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//wait for lt_done
+	if(kr_param.partner_type == 1) {
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+		}
+	} else {
+		if(block == 1) {
+			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+			while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
+				count++;
+				rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
+				if(count%700 == 0) {
+					nlm_print("ld failed\n");
+					return(1);
+				}
+			}
+			nlm_print(" block:%d lane:%d Reached lt_done\n", block, lane_no);
+		}
+	}
+	return(0);
+}
+
+void __netsoc_bkpl_disable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no) 
+{
+	volatile uint32_t rd_data;
+	uint32_t count;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	if(kr_param.link_training_enable == 1) {
+		//Disable LT
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
+		bit_set(rd_data, BIT(0)); // restart training
+		bit_clear(rd_data, BIT(1)); // training enable
+		__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
+		nlm_print("disable_link_training:  block:%d lane:%d Disabled link training\n", block, lane_no);
+	}
+}
+
+uint32_t __netsoc_bkpl_wait_for_an_complete(nae_t *nae, uint32_t block, uint32_t lane_no) {
+	volatile uint32_t rd_data;
+	uint32_t count=0;
+	volatile uint32_t an_done=1;
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+	//Step 6:
+	//wait for AN complete
+	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+	while((rd_data & BIT(5)) != BIT(5)) {
+		count++;
+		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
+		if((count%500) == 0) {
+			an_done = 0;
+			break;
+		}
+	}
+	nlm_print("block:%d lane:%d count:%d value:0x%x\n", block, lane_no, count, rd_data);
+	return (an_done & (rd_data & BIT(0)));
+}
+
+void __netsoc_init_kr_module(void)
+{
+	config_kr_params();
+}
+
+
+#endif
+
+
+
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 199308c..0608294 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -2048,60 +2048,6 @@ void __netsoc_set_xlgmac_enable(net_port_t *netport)
 
 }
 
-static void __netsoc_xlgmac_softreset(uint64_t mac_base,  uint32_t rst_val)
-{
-	uint32_t val;
-	val =  netsoc_read_mac_reg(mac_base, XLGMAC1_CTL);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base, XLGMAC1_CTL, val);
-}
-
-static void __netsoc_xlgmac_threshold(uint64_t mac_base,  uint32_t thres_val)
-{
-
-	uint32_t val;
-	val =  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL);
-	val &= (~(XLGMAC3_CTL_SOFTH_MASK << XLGMAC3_CTL_SOFTH_SHIFT));
-	val |= ((thres_val & XLGMAC3_CTL_SOFTH_MASK) << XLGMAC3_CTL_SOFTH_SHIFT);
-        netsoc_write_mac_reg(mac_base, XLGMAC3_CTL, val);
-    	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
-
-}
-
-static void __netsoc_xfi_softreset(uint64_t mac_base,  uint32_t rst_val)
-{
-	uint32_t val;
-	val =  netsoc_read_mac_reg(mac_base, XGMAC_CTL_REG1);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base, XGMAC_CTL_REG1, val);
-#if 0
-	// Lane 0
-	val =  netsoc_read_mac_reg(mac_base0, XGMAC_CTL_REG1);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base0, XGMAC_CTL_REG1, val);
-	// Lane 1
-	val =  netsoc_read_mac_reg(mac_base1, XGMAC_CTL_REG1);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base1, XGMAC_CTL_REG1, val);
-	// Lane 2
-	val =  netsoc_read_mac_reg(mac_base2, XGMAC_CTL_REG1);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base2, XGMAC_CTL_REG1, val);
-	// Lane 3
-	val =  netsoc_read_mac_reg(mac_base3, XGMAC_CTL_REG1);
-	val &= ~(0x3 << 11);
-	val |= ((rst_val & 0x3) << 11);
-        netsoc_write_mac_reg(mac_base3, XGMAC_CTL_REG1, val);
-#endif
-
-	netsoc_api_print(NETSOC_APIDBG_PORT, "%s All XFI ports in a Quad resetted\n", __func__);
-
-}
 
 static void __netsoc_config_sgmii(net_port_t *netport)
 {
@@ -4289,9 +4235,6 @@ static int __netsoc_init_all_ports(nae_t *nae)
 }
 
 
-extern void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no);
-extern void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no);
-//extern void enable_autoneg(nae_t* nae);
 int __netsoc_init_nae(nae_t *nae)
 {
 	uint32_t tx_config, rx_config;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 604885c..ae57520 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -1484,6 +1484,40 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
         }
 }
 
+void __netsoc_wait_for_pcs_sync(nae_t *nae)
+{
+	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
+	uint64_t mac_base;
+	uint32_t cplx_mask = nae->xfi_complex_map | nae->xlgmac_complex_map;
+	if(!cplx_mask)
+		return -1; 
+
+	for( block = 0; block < 4; block++)
+	{
+		if ((cplx_mask & (1 << block)) == 0) {
+			continue;
+		}
+		mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+
+		for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
+			count = 0;
+			while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SPC)) != (PHY_LANE_STAT_SPC)) {
+				/* Wait for XAUI Lane fault to be cleared */
+				count++;
+				if (count == timeout) {
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"XFI/XLAUI lane fault not cleared \n");
+					nlm_print("XFI/XLAUI lane fault not cleared on block=%d lane=%d\n", block, PHY_LANE_3_STATUS-lane_status );
+					break;
+				}
+			}
+
+			nlm_print("Lane sync wait over \n");
+
+		}
+	}
+
+}
+
 static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t phymode)
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
@@ -1556,16 +1590,7 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                         }
 
                         netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait lane fault cleared\n", block, lane_status);
-#if 0
-			count = 0;
-			while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SPC)) != (1<<9)) {
-                                /* Wait for XAUI Lane fault to be cleared */
-                                count++;
-                                if (count == timeout) {
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"XFI/XLAUI lane fault not cleared \n");
-                                }
-                        }
-#endif
+//#if 0
                 }
         }
 
@@ -1656,955 +1681,6 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
 
 #endif
 
-void __netsoc_setup_bkpl_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-	rd_data  |= (0x0 << 0); // to push state machine into ( mr_trained ) remote training state
-	__netsoc_write_kr_reg(base, lane_no, KR_PMD_STATUS, rd_data);
-}
-
-void __netsoc_clause_173_enable(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t data;
-	volatile uint32_t rd_data;
-	uint32_t port_no;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block);
-
-
-	//DEBUG: Read DME VSEMI register bit
-	//rd_data = read_vsemi_reg( lane_no, 0x28);
-	//nlm_print("DEBUG:PCSRX_DME_EN register value is 0x%x\n", rd_data);
-
-	//Step1:
-	//configure KR ability 0-1-2 registers
-	//ability 0
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
-	//TODO; NEXT PAGE ENABLED
-	//if(nae->bkpl_cfg[block].next_page == 1) {
-		//rd_data |= (0x1 << 15); // Next Page
-	//}
-	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_0, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_0);
-	//nlm_print("AN_ABILITY0:  lane:%d value is 0x%x\n",  lane_no, rd_data);
-
-	//ability 1
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
-	//if(block==0 && nae->nae_id==0) {
-	if(block==0) {
-		rd_data &= 0xFFE0; //Transmitted nonce [4:0]
-		rd_data |= 0x1F;
-	}
-	if(block==1) {
-		rd_data &= 0xFFE0; //Transmitted nonce
-		rd_data |= 0x07;
-	}
-
-	if(phymode==PHYMODE_XFI){
-		rd_data |= (0x1 << 7); // technology ability is 10g-KR
-	}else if(phymode==PHYMODE_XLAUI){
-		rd_data |= (0x1 << 8) | (0x1 << 7) | (0x1 << 6) | (0x1 << 5);
-	}
-	__netsoc_write_kr_reg(base, lane_no, KXAN_ABILITY_1, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_1);
-	//nlm_print("AN_ABILITY1:  lane:%d value is %x\n",  lane_no, rd_data);
-
-	//ability 2
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_ABILITY_2);
-	//nlm_print("Data read from ability 2 is 0x%x\n", rd_data);
-	//nlm_print("AN_ABILITY2: complex: %d: lane: %d value is %x\n",block, lane_no, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-	//nlm_print("AN_STATUS: complex: %d lane :%d read value is %x\n",block, lane_no, rd_data);
-	__netsoc_write_kr_reg(base, lane_no, KXAN_MS_COUNT, 0xffff);
-
-	//Step2:
-	//Enable auto-negotiation
-	//enable the AN first
-	data = netsoc_read_mac_reg(base, KR_CTRL);
-	if((phymode==PHYMODE_XLAUI && lane_no==0) || (phymode==PHYMODE_XFI)){
-		data |= (0x1 << lane_no);
-		nlm_print("KR enabled for complex: %d lane 0\n", block, lane_no);
-	}
-
-	data &= (~0xF0);
-	data |= (KR_PHY_STATUS | KR_UNBYPASS);
-	netsoc_write_mac_reg(base, KR_CTRL, data);
-	data = netsoc_read_mac_reg(base, KR_CTRL);
-
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	if(nae->bkpl_cfg[block].kr_lpbk){
-		/*restart the AN on one of the block*/
-		if((block==1))
-			rd_data |= (0x1 << 9); // an-restart
-	}
-	rd_data |= (0x1 << 12); // an-enable
-	//TODO:next page
-	//if(netior_config.next_page_an == 1) {
-		//if(block==0) rd_data |= (0x1 << 13); // extended NP
-		//rd_data |= (0x1 << 13); // extended NP
-	//}
-	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	//nlm_print(" AN_CONTROL:  lane:%d value is 0x%x\n",  lane_no, rd_data);
-
-	//DEBUG: Read DME VSEMI register bit
-	//rd_data = read_vsemi_reg( lane_no, 0x28);
-	//nlm_print("DEBUG:PCSRX_DME_EN register value is 0x%x\n", rd_data);
-
-}
-
-void __netsoc_perform_clause_173_base_page(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-
-	volatile uint32_t rd_data;
-	uint32_t count=0;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	//Step3:
-	//check for base page exchange completion
-	//status register
-#if 0
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	if((block==1))
-		rd_data |= (0x1 << 9); // an-restart
-	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL, rd_data);
-	return;
-#endif
-
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-
-	while((rd_data & (1<<6)) == 0 ) {
-		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for base page exchange completion value:0x%x\n",block, lane_no, rd_data);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-		nlm_mdelay(10);
-		//if(count++ == 50) break;
-	}
-	//nlm_print(" AN_STATUS: complex: %d lane: %d Base page exchange completed value:0x%x\n",block, lane_no, rd_data);
-	//TODO:
-	//if(netior_config.read_rem_ability_registers == 1) {
-	//Read rem_ability registers:
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_0);
-	//nlm_print("AN_REM_ABILITY0: value is 0x%x\n",rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_1);
-	//nlm_print("AN_REM_ABILITY1: value is 0x%x\n",rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_REM_ABILITY_2);
-	//nlm_print("AN_REM_ABILITY2: value is 0x%x\n",rd_data);
-	//}
-
-	//If remote device does not have AN capability, AN process will be stuck at this stage,timeout to be implemented in this state to exit - MTIP spec
-}
-
-void __netsoc_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-
-	volatile uint32_t rd_data;
-	uint32_t count;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-	//Step 4 (optional)
-	//configure NP ability registers
-	//ability 0
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
-	if(nae->bkpl_cfg[block].message_page == 1) {
-		rd_data |= (0x1 << 13); // set MP
-		rd_data &= 0xFFFFF800; //10:0 //Refer to NextPage Message code field definitions (IEEE Std 802.3-2005 Annex28C)
-		rd_data |= (0x1 << 0);
-	} else {
-		rd_data |= (0x0 << 13); // set MP
-		rd_data &= 0xFFFFF800; //10:0
-		rd_data |= (0xAB + block);
-	}
-	rd_data |= (0x0 << 15); // Next page (XNP)
-	__netsoc_write_kr_reg(base, lane_no, AN_XNP_0, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_0);
-	nlm_print("XNP_ABILITY0: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
-
-	//ability 1
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
-	rd_data &= 0xFFFF0000;
-	rd_data |= ( 0xABCD + block) ;//15:0
-	__netsoc_write_kr_reg(base, lane_no, AN_XNP_1, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_1);
-	nlm_print("XNP_ABILITY1: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
-
-	//ability 2
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
-	rd_data &= 0xFFFF0000;
-	rd_data |= (0xBBBB + block);//15:0
-	__netsoc_write_kr_reg(base, lane_no, AN_XNP_2, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, AN_XNP_2);
-	nlm_print("XNP_ABILITY2: complex: %d: lane: %d value is %x\n", block, lane_no, rd_data);
-}
-
-void __netsoc_perform_clause_173_next_page(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	uint32_t count;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	//check for next page exchange completion
-	//status register
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-	// looping on status until an complete or page received
-	while((rd_data & (1<<6)) == 0 ) {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);;
-	}
-	nlm_print(" AN_STATUS: complex: %d: Next page exchange completed value:0x%x\n", block, rd_data);
-
-	//Read remote next page ability registers:
-	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_0);
-	nlm_print("AN_NP_REM_ABILITY0: value is %x\n", rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_1);
-	nlm_print("AN_NP_REM_ABILITY1: value is %x\n",rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, LP_AN_XNP_2);
-	nlm_print("AN_NP_REM_ABILITY2: value is %x\n",rd_data);
-
-	//disable XNP in control register
-	//control register
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_CONTROL);
-	rd_data |= (0x0 << 13); // extended NP
-	__netsoc_write_kr_reg(base, lane_no, KXAN_CONTROL,  rd_data);
-
-}
-
-#define BIT(n)  (1<<n)
-#define  bit_clear(data, n)  data &= ~(n)
-#define bit_set(data, n)     data |= (n)
-# if 0
-void __netsoc_bkpl_write_pma2p0_txdriver_registers(nae_t *nae, uint32_t block, uint32_t lane_no) {
-	volatile uint32_t rd_data;
-	//Read TX DRV registers
-	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
-	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
-	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
-	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
-	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
-	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
-	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 87);
-	bit_clear(rd_data, BIT(5));
-	__netsoc_write_pma2p0_reg(mac_base, lane_no, 87, rd_data);
-	__netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0xdf);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 21);
-	nlm_print("write_vsemi_txdriver_registers:  lane:%d 21:0x%x\n",  lane_no, rd_data);
-	__netsoc_write_pma2p0_reg(mac_base, lane_no, 22, 0x7);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 22);
-	nlm_print("write_vsemi_txdriver_registers:  lane:%d 22:0x%x\n",  lane_no, rd_data);
-	__netsoc_write_pma2p0_reg(mac_base, lane_no, 23, 0);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 23);
-	nlm_print("write_vsemi_txdriver_registers:  lane:%d 23:0x%x\n",  lane_no, rd_data);
-
-}
-void __netsoc_bkpl_read_vsemi_rxequalization_registers(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	volatile uint32_t rxcaleq_dcgain, rxcaleq_dfepstapf3db, rxcaleq_dfepstapgain, rxcaleq_dfetap1gain, rxcaleq_dfetap2gain, rxcaleq_dfetap3gain, rxcaleq_dfetap4gain, rxcaleq_lofreqagcgain, rxcaleq_hifreqagccap, rxcaleq_locwren;
-
-	// RXCALEQ_DCGAIN         24[2:0]    0 1 2 3 3'h0 // 3'h2
-	// RXCALEQ_DFEPSTAPF3DB   24[5:3]    0 1 2 3 3'h0
-	// RXCALEQ_DFEPSTAPGAIN   25[2:0]    0 1 2 3 3'h0
-	// RXCALEQ_DFETAP1GAIN    25[6:3]    0 1 2 3 4'h0
-	// RXCALEQ_DFETAP2GAIN    26[3:0]    0 1 2 3 4'h8
-	// RXCALEQ_DFETAP3GAIN    26[7:4]    0 1 2 3 4'h0
-	// RXCALEQ_DFETAP4GAIN    27[3:0]    0 1 2 3 4'h8
-	// RXCALEQ_LOFREQAGCGAIN  27[6:4]    0 1 2 3 3'h7
-	// RXCALEQ_HIFREQAGCCAP   28[7:3]    0 1 2 3 5'h0
-	// RXCALEQ_LOCWREN        86[3:3]    0 1 2 3 1'b0
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 24);
-	rxcaleq_dcgain = (rd_data & 0x7);
-	rxcaleq_dfepstapf3db = ((rd_data >> 3) & 0x7);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DCGAIN=0x%x\n", rxcaleq_dcgain);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFEPSTAPF3DB=0x%x\n", rxcaleq_dfepstapf3db);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 25);
-	rxcaleq_dfepstapgain = (rd_data & 0x7);
-	rxcaleq_dfetap1gain = ((rd_data >> 3) & 0xF);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFEPSTAPGAIN=0x%x\n", rxcaleq_dfepstapgain);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP1GAIN=0x%x\n", rxcaleq_dfetap1gain);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 26);
-	rxcaleq_dfetap2gain = (rd_data & 0xF);
-	rxcaleq_dfetap3gain = ((rd_data >> 4) & 0xF);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP2GAIN=0x%x\n", rxcaleq_dfetap2gain);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP3GAIN=0x%x\n", rxcaleq_dfetap3gain);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 27);
-	rxcaleq_dfetap4gain = (rd_data & 0xF);
-	rxcaleq_lofreqagcgain = ((rd_data >>4) & 0xF);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_DFETAP4GAIN=0x%x\n", rxcaleq_dfetap4gain);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_LOFREQAGCGAIN=0x%x\n", rxcaleq_lofreqagcgain);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 28);
-	rxcaleq_hifreqagccap = ((rd_data >> 3) & 0x1F);
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_HIFREQAGCCAP=0x%x\n", rxcaleq_hifreqagccap);
-	rd_data = __netsoc_read_pma2p0_reg(mac_base, lane_no, 86);
-	rxcaleq_locwren = ((rd_data & BIT(3)) >> 3) ;
-	nlm_print("read_vsemi_rxequalization_registers: RXCALEQ_LOCWREN=0x%x\n", rxcaleq_locwren);
-	bit_clear(rd_data, BIT(3));
-	__netsoc_write_pma2p0_reg(mac_base, lane_no, 86, rd_data);
-}
-
-#endif
-static inline uint32_t mod(int32_t value){
-	volatile uint32_t mod_value;
-
-	if (value < 0) {
-		mod_value = -value;
-	} else {
-		mod_value = value;
-	}
-	return(mod_value);
-}
-
-static inline uint32_t update_coefficient(uint32_t update, int32_t present_coeff)
-{
-	volatile int32_t updated_coeff;
-	uint32_t step = 1;
-
-	switch (update) {
-		case 0 : updated_coeff = present_coeff;        break;
-		case 1 : updated_coeff = present_coeff + step; break;
-		case 2 : updated_coeff = present_coeff - step; break;
-	}
-	return(updated_coeff);
-}
-#if 0
-static inline void __netsoc_bkpl_wait_for_lt_done(uint64_t base, uint32_t lane_no)
-{
-	//wait for lt_done
-	nlm_print(" LINK_TRAINING: %d: Waiting for signal_detection signal to go high - lt_done\n",block);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-	while((rd_data & (1<<15)) == 0) { //signal detection - indicates training process is complete
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-	}
-	nlm_print("Wait for Link Training done\n");
-}
-
-void __netsoc_bkpl_wait_for_lt_int(nae_t *nae, uint32_t block, uint32_t lane_no uint32_t update) {
-	volatile uint32_t rd_data;
-	uint64_t cnt=0,cnt1=0;
-
-	uint64_t nae_base = netsoc_get_iface_base(nae->nae_base, 0xf);
-
-	if(block==1) {
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
-		rd_data |= (0x1 << 22);
-		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		while((rd_data & BIT(22)) == 0) {
-			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		}
-		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
-		rd_data |= (0x1 << 22); //write 1 to clear
-		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-	}
-	if(block==0) {
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1_MASK);
-		rd_data |= (0x1 << 23);
-		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1_MASK, rd_data);
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		while((rd_data & BIT(23)) == 0) {
-			rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-		}
-		nlm_print("wait_for_lt_int:  lane:%d NetiorINT1 interrupt status after polling value: 0x%x\n",  lane_no, rd_data);
-		rd_data |= (0x1 << 23); //write 1 to clear
-		netsoc_write_nae_iface_reg(nae_base, NETIOR_INT1, rd_data);
-		rd_data = netsoc_read_nae_iface_reg(nae_base, NETIOR_INT1);
-	}
-}
-
-#endif
-
-void __netsoc_bkpl_enable_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block);
-
-	rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
-	if(phymode == PHYMODE_XLAUI) {
-		while((rd_data & (1<<5)) == 0) { //40GKR4
-			rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
-		}
-	} else if (phymode == PHYMODE_XFI) {
-		while((rd_data & (1<<3)) == 0) { //10GKR
-			rd_data = __netsoc_read_kr_reg(base, lane_no, BP_ETH_STATUS);
-		}
-	}
-	nlm_print(" complex: %d: lane: %d :AN_GOOD_CHECK state reached on DUT\n", block,lane_no);
-
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
-	rd_data |= (0x1 << 0); // restart training
-	rd_data |= (0x1 << 1); // training enable
-	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL,  rd_data);
-	nlm_print(" complex: %d: lane: %d :restart training and training enable set on DUT\n", block,lane_no);
-
-
-}
-
-static void __netsoc_bkpl_restart_link_training(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	volatile uint32_t rd_data;
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
-	rd_data |= (0x1 << 0); // restart training
-	rd_data |= (0x1 << 1); // training enable
-	__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
-	nlm_print("restart_link_training: lane:%d restart training \n",lane_no);
-}
-
-void send_maintap_update (nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
-{
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	volatile uint32_t main_tap_coeff, main_tap_status;
-	volatile uint32_t rd_data;
-
-	main_tap_coeff = update;
-	rd_data = (main_tap_coeff << 2);
-	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	//nlm_print("send_maintap_update: SEND C(0) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-
-	//Read LP status register
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		main_tap_status = ((rd_data & 0xC) >> 2);
-		if((main_tap_status == 0x3) || (main_tap_status == 0x2) || (main_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			main_tap_coeff = 0x0; // hold
-			rd_data = (main_tap_coeff << 2);
-			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
-			//nlm_print("send_maintap_update: Set C(0) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-		}
-	} while (main_tap_status == 0x0);
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		main_tap_status = ((rd_data & 0xC) >> 2);
-	} while(main_tap_status != 0x0);
-	//nlm_print("send_maintap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
-}
-
-void send_pretap_update(nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update)
-{
-	volatile uint32_t pre_tap_coeff, pre_tap_status;
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-	pre_tap_coeff = update;
-	rd_data = pre_tap_coeff;
-	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	//nlm_print("send_pretap_update: SEND C(-1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-
-	//Read LP status register
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		//nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
-		pre_tap_status = (rd_data & 0x3);
-		if((pre_tap_status == 0x3) || (pre_tap_status == 0x2) || (pre_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			pre_tap_coeff = 0x0; // hold
-			rd_data = pre_tap_coeff;
-			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-		//	nlm_print("send_pretap_update: Set C(-1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-		}
-	} while (pre_tap_status == 0x0);
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		pre_tap_status = (rd_data & 0x3);
-	} while(pre_tap_status != 0x0);
-	//nlm_print("send_pretap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
-}
-
-void send_posttap_update( nae_t *nae, uint32_t block, uint32_t lane_no, uint32_t update){
-	volatile uint32_t post_tap_coeff, post_tap_status;
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-	post_tap_coeff = update;
-	rd_data = (post_tap_coeff << 4);
-	__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-	//nlm_print("send_posttap_update: SEND C(+1) update  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-
-	//Read LP status register
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		//nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x \n",  lane_no, rd_data);
-		post_tap_status = ((rd_data & 0x30) >> 4);
-		if((post_tap_status == 0x3) || (post_tap_status == 0x2) || (post_tap_status == 0x1)) { //if maximum or minimum or updated, set LD coeff to hold
-			post_tap_coeff = 0x0; // hold
-			rd_data = (post_tap_coeff << 4);
-			__netsoc_write_kr_reg(base, lane_no, KR_LD_COEFF, rd_data);
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_COEFF);
-		//	nlm_print("send_posttap_update: Set C(+1) to HOLD  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-		}
-	} while (post_tap_status == 0x0);
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		post_tap_status = ((rd_data & 0x30) >> 4);
-	} while(post_tap_status != 0x0);
-	//nlm_print("send_posttap_update:  lane:%d Value of LP status register is 0x%x -2\n",  lane_no, rd_data);
-}
-
-
-static void  __netsoc_bkpl_program_tx_driver(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data,rd_data1;
-	volatile int32_t  coeff27_minus1, coeff27, coeff27_plus1;
-	volatile uint32_t mod_coeff27_minus1, mod_coeff27, mod_coeff27_plus1;
-	volatile int32_t  present_coeff_minus1, present_coeff_zero, present_coeff_plus1;
-	volatile uint32_t coeff_minus1_update, coeff_zero_update, coeff_plus1_update;
-	volatile int32_t  temp_coeff27_minus1, temp_coeff27_zero, temp_coeff27_plus1;
-	volatile uint32_t mod_temp_coeff27_zero, mod_temp_coeff27_minus1, mod_temp_coeff27_plus1;
-	volatile int32_t  updated_coeff_minus1, updated_coeff_zero,updated_coeff_plus1;
-	volatile uint32_t  updated_status_minus1, updated_status_zero,updated_status_plus1;
-	volatile uint32_t mod_updated_coeff_minus1, mod_updated_coeff_zero,mod_updated_coeff_plus1;
-	volatile uint32_t txdrv_hlev, txdrv_levn, txdrv_levnm1, txdrv_levnm2, txdrv_levnp1, txdrv_slew;
-	uint32_t cnt=0;
-	uint64_t  instr = 0, cycles = 0;
-
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-	//reset_perfctr();
-	//start_perfctr();
-	//Read TX DRV registers
-	// TXDRV_HLEV    21[2:0]    0 1 2 3  3'h7
-	// TXDRV_LEVN    21[7:3]    0 1 2 3  5'h1B
-	// TXDRV_LEVNM1  22[3:0]    0 1 2 3  4'h7
-	// TXDRV_LEVNM2  22[5:4]    0 1 2 3  2'h0
-	// TXDRV_LEVNP1  23[2:0]    0 1 2 3  3'h0
-	// TXDRV_SLEW    23[4:3]    0 1 2 3  2'h0
-	// TXDRV_LOCWREN 87[6:6]    0 1 2 3
-
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
-	//txdrv_hlev = (rd_data & 0x7);        //21[2:0]
-	txdrv_levn = ((rd_data >> 3) & 0x1F);//21[7:3]
-	////nlm_print("program_tx_driver:  lane:%d 21:0x%x\n",  lane_no, rd_data);
-	rd_data =  __netsoc_read_pma2p0_reg(base, lane_no, 22);
-	txdrv_levnm1 = (rd_data & 0xF);       //22[3:0]
-	//txdrv_levnm2 = ((rd_data >> 4) & 0xF);//22[7:4]
-	//nlm_print("program_tx_driver:  lane:%d 22:0x%x\n",  lane_no, rd_data);
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
-	txdrv_levnp1 = (rd_data & 0x7);      //23[2:0]
-	//txdrv_slew = ((rd_data >> 3) & 0x3); //23[4:3]
-	//nlm_print("program_tx_driver: inst:%d complex
-
-	//Get initial coefficients
-	coeff27_minus1 = ((txdrv_levnp1));
-	coeff27_plus1  = ((txdrv_levnm1));
-	mod_coeff27_minus1 = mod(coeff27_minus1);
-	mod_coeff27_plus1 = mod(coeff27_plus1);
-	coeff27 = ((txdrv_levn) - mod_coeff27_minus1 - mod_coeff27_plus1);
-	mod_coeff27= mod(coeff27);
-
-	if(((mod_coeff27_minus1 + mod_coeff27 + mod_coeff27_plus1) <= 27) && ((mod_coeff27 - mod_coeff27_minus1 - mod_coeff27_plus1) >= 6)) {
-		present_coeff_minus1 = coeff27_minus1;
-		present_coeff_zero   = coeff27;
-		present_coeff_plus1  = coeff27_plus1;
-	}
-	//nlm_print("program_tx_driver: lane:%d  present_coeff_minus1:%d present_coeff_zero:%d present_coeff_plus1:%d\n", lane_no,present_coeff_minus1, present_coeff_zero,present_coeff_plus1);
-
-
-	//Read LP coefficient update
-	do {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
-		//nlm_print("program_tx_driver:  lane:%d Value of LP coefficient update register is 0x%x --1\n", lane_no, rd_data);
-		//Get coeff updates
-		coeff_minus1_update = (rd_data & 0x3);
-		coeff_zero_update   = ((rd_data >> 2) & 0x3);
-		coeff_plus1_update  = ((rd_data >> 4) & 0x3);
-
-		if(coeff_minus1_update == 0) updated_status_minus1 = 0;
-		if(coeff_zero_update == 0)  updated_status_zero   = 0;
-		if(coeff_plus1_update == 0)  updated_status_plus1  = 0;
-
-		//calculate updated coeffs
-		temp_coeff27_minus1 = update_coefficient(coeff_minus1_update, present_coeff_minus1);
-		temp_coeff27_zero   = update_coefficient(coeff_zero_update, present_coeff_zero);
-		temp_coeff27_plus1  = update_coefficient(coeff_plus1_update, present_coeff_plus1);
-
-		mod_temp_coeff27_minus1 =  mod(temp_coeff27_minus1);
-		mod_temp_coeff27_zero   =  mod(temp_coeff27_zero);
-		mod_temp_coeff27_plus1  =  mod(temp_coeff27_plus1);
-
-		if(((mod_temp_coeff27_minus1 + mod_temp_coeff27_zero + mod_temp_coeff27_plus1) <= 27) && ( mod_temp_coeff27_zero - mod_temp_coeff27_minus1 - mod_updated_coeff_plus1 >= 6)) {
-			//max values
-			if(coeff_minus1_update != 0) {
-				if(mod_temp_coeff27_minus1 > 0x6) {
-					updated_status_minus1 = 3;//maximum
-					updated_coeff_minus1 = present_coeff_minus1;
-				} else if(mod_temp_coeff27_minus1 < 0) {
-					updated_status_minus1 = 2;//minimum
-					updated_coeff_minus1 = present_coeff_minus1;
-				} else {
-					updated_coeff_minus1 = temp_coeff27_minus1;
-					updated_status_minus1 = 1;
-				}
-			} else {
-				updated_coeff_minus1 = present_coeff_minus1;
-				updated_status_minus1 = 0;
-			}
-			if(coeff_zero_update != 0) {
-				if(mod_temp_coeff27_zero > 0x1B) {
-					updated_status_zero = 3;//maximum
-					updated_coeff_zero = present_coeff_zero;
-					//} else if(mod_temp_coeff27_zero < 0) { //FIXME
-					//  updated_coeff_zero = present_coeff_zero;
-					//  updated_status_zero = 2;//minimum
-			} else {
-				updated_coeff_zero   = temp_coeff27_zero;
-				updated_status_zero = 1;
-			}
-			} else {
-				updated_coeff_zero = present_coeff_zero;
-				updated_status_zero = 0;
-			}
-			if(coeff_plus1_update != 0) {
-				if(mod_temp_coeff27_plus1 > 0x9) {
-					updated_coeff_plus1  = present_coeff_plus1;
-					updated_status_plus1 = 3;//maximum
-				} else if(mod_temp_coeff27_plus1 < 0) {
-					updated_coeff_plus1  = present_coeff_plus1;
-					updated_status_plus1 = 2;//minimum
-				} else {
-					updated_coeff_plus1  = temp_coeff27_plus1;
-					updated_status_plus1 = 1;
-				}
-			} else {
-				updated_coeff_plus1 = present_coeff_plus1;
-				updated_status_plus1 = 0;
-			}
-		} else {
-			updated_coeff_minus1 = present_coeff_minus1;
-			updated_coeff_zero = present_coeff_zero;
-			updated_coeff_plus1 = present_coeff_plus1;
-			updated_status_minus1 = 0;
-			updated_status_zero = 0;
-			updated_status_plus1 = 0;
-		}
-		//nlm_print("program_tx_driver:  lane:%d updated_coeff_minus1:%d updated_coeff_zero:%d updated_coeff_plus1:%d\n",  lane_no,updated_coeff_minus1,updated_coeff_zero,updated_coeff_plus1 );
-
-		mod_updated_coeff_minus1 =  mod(updated_coeff_minus1);
-		mod_updated_coeff_zero   =  mod(updated_coeff_zero);
-		mod_updated_coeff_plus1  =  mod(updated_coeff_plus1);
-
-		//Write TX DRV registers
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 87);
-		rd_data &= ~(1<<5);
-		__netsoc_write_pma2p0_reg(base, lane_no, 87, rd_data);
-
-		//calculate register fields (txdrv_levn, txdrv_nm1, txdev_np1)
-		txdrv_levnm1 =   (updated_coeff_plus1);
-		txdrv_levnp1 =   (updated_coeff_minus1);
-		txdrv_levn = ((updated_coeff_zero + mod_updated_coeff_minus1 + mod_updated_coeff_plus1));
-
-
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
-		rd_data &= 0x07; //[7:3]
-		rd_data |= (txdrv_levn << 3);
-		__netsoc_write_pma2p0_reg(base, lane_no, 21, rd_data);
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 21);
-		//nlm_print("program_tx_driver:  lane:%d reg:21 rd_data:0x%x\n",  lane_no, rd_data);
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
-		rd_data &= 0xF0;
-		rd_data |= txdrv_levnm1;
-		__netsoc_write_pma2p0_reg(base, lane_no, 22, rd_data);
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 22);
-		//nlm_print("program_tx_driver:  lane:%d reg:22 rd_data:0x%x\n",  lane_no, rd_data);
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
-		rd_data &= 0xF8;
-		rd_data |= txdrv_levnp1;
-		__netsoc_write_pma2p0_reg(base, lane_no, 23, rd_data);
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 23);
-		//nlm_print("program_tx_driver:  lane:%d reg:23 rd_data:0x%x\n",  lane_no, rd_data);
-
-		// Write LD Status registers
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		rd_data &= 0xFFFC;
-		rd_data |= updated_status_minus1;
-		rd_data &= 0xFFF3;
-		rd_data |= (updated_status_zero << 2);
-		rd_data &= 0xFFCF;
-		rd_data |= (updated_status_plus1 << 4);
-		__netsoc_write_kr_reg(base, lane_no, KR_LD_STAT, rd_data);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-	//	nlm_print("program_tx_driver :  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
-
-		present_coeff_minus1 = updated_coeff_minus1;
-		present_coeff_zero   = updated_coeff_zero;
-		present_coeff_plus1  = updated_coeff_plus1;
-
-		//stop_perfctr();
-		/*TODO: call perf code*/
-		//instr  = read_64bit_cp0_register($25,  1);
-		//cycles = read_64bit_cp0_register($25,  3);
-		//nlm_print("total instr = %llu cycles = %llu \n", (unsigned long long)instr, (unsigned long long)cycles);
-
-		//Read LP coeff update till LP coeff is set to hold
-		do {
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
-		} while (rd_data != 0x0);
-		//nlm_print("program_tx_driver: lane:%d Value of LP coefficient update register is 0x%x -2\n", lane_no, rd_data);
-		//Set LD Status to not updated
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		rd_data &= 0xFFC0 ; // set 5:0 to 0 (not updated)
-		__netsoc_write_kr_reg(base , lane_no, KR_LD_STAT, rd_data);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-		//nlm_print("program_tx_driver:  lane:%d Value of LD status register is 0x%x\n", lane_no, rd_data);
-
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
-
-	}while (rd_data != 0x0);
-
-}
-
-uint32_t __netsoc_bkpl_get_eyediag_figure_of_merit(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-
-	volatile uint32_t rd_data;
-	volatile uint32_t eye_value0, eye_value1, figure_of_merit_value;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-
-	//0. Initialize the locwrens
-	//PCSRXEQ_LOCWREN
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 85);
-	bit_clear(rd_data, BIT(6));
-	__netsoc_write_pma2p0_reg(base, lane_no, 85, rd_data);
-
-	//2. Start RX EQ
-	//PCSRXEQ_START	31[0:0] 1'b1
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
-	bit_set(rd_data, BIT(0));
-	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
-
-	//3, Wait for done and read figure of merit:
-	//RXEQ_DONE	32[3:3] (should be 1'b1)
-	//RXEQ_BEST_EYE_VAL	29[7:0],30[5:0]
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
-	while ((rd_data & BIT(3)) != BIT(3)) {
-		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 32);
-	}
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 29);
-	eye_value1 = rd_data & 0xFF;
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 30);
-	eye_value0 = rd_data & 0x3F;
-	figure_of_merit_value = ((eye_value1 << 6) | (eye_value0));
-	//nlm_print(" get_eyediag_figure_of_merit:  lane:%d updated figure of merit for eye opening:0x%x\n",  lane_no, figure_of_merit_value);
-
-	//4. reset the EQ start signal
-	//PCSRXEQ_START	31[0:0] 1'b0
-	rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 31);
-	bit_clear(rd_data, BIT(0));
-	__netsoc_write_pma2p0_reg(base, lane_no, 31, rd_data);
-
-	return (figure_of_merit_value);
-
-}
-
-void __netsoc_bkpl_link_device_training(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block);
-	uint32_t count=0;
-
-	//MTIP step1: Keep polling PMD Status until it indicates frame lock
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-	while((rd_data & BIT(1)) != BIT(1)) {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-	}
-	//nlm_print("link_device_training:  lane:%d PMD STATUS value:0x%x\n",  lane_no, rd_data);
-
-	//program_tx_driver( lane_no);
-
-	//Read LP status
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-	//nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
-	while ((rd_data & BIT(15)) == 0) {
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_COEFF);
-		if((rd_data & 0x3F)!= 0x0) __netsoc_bkpl_program_tx_driver(nae, block, lane_no);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-	}
-	//nlm_print("link_device_training:  lane:%d Value of LP status register is 0x%x\n",  lane_no, rd_data);
-
-
-	if(block==1) {
-		// PMD status
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
-		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
-		//nlm_print("link_device_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
-	}
-
-	//wait for lt_done
-	if(block==1) {
-		//nlm_print("link_device_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n",  lane_no);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		}
-		nlm_print("link_device_training:  lane:%d Reached lt_done value 0x%x\n",  lane_no, rd_data);
-	}
-
-}
-
-void __netsoc_bkpl_link_partner_training(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	volatile uint32_t rd_data;
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block);
-
-	volatile uint32_t eye_value, updated_eye_value=0;
-	volatile uint32_t pre_tap_coeff, post_tap_coeff, main_tap_coeff;
-	volatile uint32_t pre_tap_status, post_tap_status, main_tap_status;
-	uint64_t count=0, cnt=0;
-	uint32_t reg_addr, mask, exp_value;
-
-	//reset_perfctr();
-	//start_perfctr();
-	//1
-	//rd_data = read_kr_reg( lane_no, KR_LD_COEFF);
-	//rd_data |= (0x1 << 12); //initialize
-	//write_kr_reg( lane_no, KR_LD_COEFF, rd_data);
-	//nlm_print(" link_partner_training:  lane:%d Value of LD coefficient update register is 0x%x\n",  lane_no, rd_data);
-
-	//2
-	//rd_data = read_kr_reg( lane_no, KR_PMD_STATUS);
-	//nlm_print("link_partner_training : complex_no:%d: PMD STATUS value:0x%x\n", rd_data);
-
-	//3 Record the figure of merit
-	//Assert Start and wait for done and then record figure of merit
-	eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	//nlm_print("link_partner_training:  lane:%d  Initial eye_value: 0x%x\n",  lane_no, eye_value);
-	//nlm_print("link_partner_training:  lane:%d  Read initial rx equalization register values\n",  lane_no);
-	//read_vsemi_rxequalization_registers( lane_no);
-	//clear_netior_interrupts(inst_no);
-
-	//4 while figure of merit is improved
-	do {
-		if(count > 0) eye_value = updated_eye_value;
-		//i   Send DEC C(0)
-		send_maintap_update(nae, block, lane_no, 0x2); //decrement
-
-		updated_eye_value =__netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-		//nlm_print("link_partner_training:  lane:%d  After step 4i updated_eye_value:0x%x\n",  lane_no, updated_eye_value);
-		//ii   Send INC(-1)
-		send_pretap_update(nae, block, lane_no, 0x1); //increment
-
-		//iii
-		//iv
-		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);;
-		//nlm_print("link_partner_training:  lane:%d  After step 4ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-		//nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
-		//nlm_print("link_partner_training:  lane:%d  After step 4ii Read rx equalization register values\n", lane_no);
-		//read_vsemi_rxequalization_registers( lane_no);
-		count++;
-	} while (updated_eye_value > eye_value);
-
-	//v   Send DEC(-1)
-	send_pretap_update(nae, block, lane_no, 0x2); //decrement
-
-	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	//nlm_print("link_partner_training:  lane:%d  After step 4v updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-	//nlm_print("link_partner_training:  lane:%d  After step 4v Read rx equalization register values\n", lane_no);
-	//read_vsemi_rxequalization_registers( lane_no);
-
-	count = 0;
-
-	//5 while figure of merit is improved
-	do {
-		//i   Send DEC C(0)
-		eye_value = updated_eye_value;
-		send_maintap_update(nae, block, lane_no, 0x2); //decrement
-		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-		//nlm_print("link_partner_training:  lane:%d  After step 5i updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-		//nlm_print("link_partner_training:  lane:%d  After step 5i Read rx equalization register values\n",  lane_no);
-		//read_vsemi_rxequalization_registers( lane_no);
-
-		//ii  Send INC C(+1)
-		send_posttap_update(nae, block, lane_no, 0x1); //increment
-
-		//iii
-		//iv
-		updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-		//nlm_print("link_partner_training:  lane:%d  After step 5ii updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-		//nlm_print("link_partner_training:  lane:%d  After step 5ii Read rx equalization register values\n",  lane_no);
-		//read_vsemi_rxequalization_registers( lane_no);
-	//	nlm_print("link_partner_training:  lane:%d  updated_eye_value: 0x%x eye_value:0x%x\n",  lane_no, updated_eye_value, eye_value);
-		count++;
-	} while (updated_eye_value > eye_value);
-
-	//6  Send DEC C(+1)
-	send_posttap_update(nae, block, lane_no, 0x2); //decrement
-	updated_eye_value =  __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	//nlm_print("link_partner_training:  lane:%d  After step 6: updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-	//nlm_print("link_partner_training:  lane:%d  After step 6 Read rx equalization register values\n",  lane_no);
-	//read_vsemi_rxequalization_registers( lane_no);
-
-	//7   Send INC C(0)
-	send_maintap_update(nae, block, lane_no, 0x1); //increment
-
-	updated_eye_value = __netsoc_bkpl_get_eyediag_figure_of_merit(nae, block, lane_no);
-	//nlm_print("link_partner_training:  lane:%d  After step 7 updated_eye_value: 0x%x\n",  lane_no, updated_eye_value);
-	//nlm_print("link_partner_training:  lane:%d  After step 7 Read rx equalization register values\n",  lane_no);
-	//read_vsemi_rxequalization_registers( lane_no);
-
-	//LD status
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-	rd_data &= 0xFFC0 ; //[5:0] = 6'h0
-	rd_data |= (0x1 << 15); // receiver ready
-	__netsoc_write_kr_reg(base,  lane_no, KR_LD_STAT, rd_data);
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LD_STAT);
-	//nlm_print("link_partner_training:  lane:%d Set receiver ready Value of LD status register is 0x%x\n", lane_no, rd_data);
-
-	if(block==0) {
-		//PMD status
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		rd_data |= (0x1 << 0); // to push state machine into ( mr_trained ) remote training state
-		__netsoc_write_kr_reg(base,  lane_no, KR_PMD_STATUS, rd_data);
-	//	nlm_print("link_partner_training:  lane:%d Pushed state machine into remote training state\n",  lane_no);
-	//	nlm_print("link_partner_training:  lane:%d Waiting for signal_detection signal to go high - lt_done\n", lane_no);
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		while((rd_data & BIT(15)) == 0) { //signal detection - indicates training process is complete
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_STATUS);
-		}
-		nlm_print("link_partner_training:  lane:%d Reached lt_done value:0x%x\n",  lane_no, rd_data);
-	}
-
-	if(block==0) {
-		//Read LP status
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		while ((rd_data & BIT(15)) == 0) {
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KR_LP_STAT);
-		}
-		//nlm_print("link_partner_training:  lane:%d Value of LP status register is 0x%x\n", lane_no, rd_data);
-	}
-
-}
-
-void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t lane_no)
-{
-	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	uint32_t phymode = get_phy_mode(nae, block);
-	volatile uint32_t rd_data;
-	uint32_t count;
-	if(nae->bkpl_cfg[block].link_training_enable)
-	{
-		//Disable LT
-		rd_data = __netsoc_read_kr_reg(base, lane_no, KR_PMD_CONTROL);
-		rd_data |= (0x1 << 0); // restart training
-		rd_data |= (0x0 << 1); // training enable
-		__netsoc_write_kr_reg(base, lane_no, KR_PMD_CONTROL, rd_data);
-		nlm_print("wait_for_an_complete:  lane:%d Disabled link training\n",  lane_no);
-
-	}
-
-	count=0;
-	rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-	while((rd_data & (1<<5)) == 0) {
-		nlm_print(" AN_STATUS: complex: %d lane: %d Waiting for an_done. value:0x%x\n", block, lane_no, rd_data);
-		nlm_mdelay(50);
-			rd_data = __netsoc_read_kr_reg(base, lane_no, KXAN_STATUS);
-
-		//if(count++ == 100) break;
-	}
-	nlm_print(" complex: %d lane: %d AN process completed value:0x%x\n", block, lane_no,rd_data);
-}
-
 void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
@@ -2656,109 +1732,60 @@ void __netsoc_kr_init_an(nae_t *nae, int block)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 
-	uint32_t lane_ctrl, max_kr_lanes=4, lane_no;
+	uint32_t  max_kr_lanes=4, lane_no;
 	uint32_t cplx_mask = nae->xlgmac_complex_map | nae->xfi_complex_map;
-#define NUM_LANES_PER_COMPLEX 4
-	static volatile int lt_done_nae0_c0[NUM_LANES_PER_COMPLEX];
-	static volatile int lt_done_nae0_c1[NUM_LANES_PER_COMPLEX];
-	static volatile int lt_done_nae1_c0[NUM_LANES_PER_COMPLEX];
-	static volatile int lt_done_nae1_c1[NUM_LANES_PER_COMPLEX];
-
-	//for( block = 0; block < 2; block++)
-        //{
-		uint32_t phymode = get_phy_mode(nae, block);
-
-		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-		 	return;
-//		 	continue;
-
-		//if(!(nae->bkpl_cfg[block].kr_en))
-		//	continue;
-
-                for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
-			__netsoc_setup_bkpl_link_training(nae, block, lane_ctrl);
-		}
-
-	//}
-
-	//for( block = 0; block < 2; block++)
-        //{
-	//	uint32_t phymode = get_phy_mode(nae, block);
-
-	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-	//	 	continue;
-	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0;
-
-	//	if(!(nae->bkpl_cfg[block].kr_en))
-	//		continue;
-
-                for( lane_ctrl = 0; lane_ctrl <=0; lane_ctrl++){
-			__netsoc_clause_173_enable(nae, block, lane_ctrl);
-		}
-
-	//}
-	//for( block = 0; block < 2; block++)
-        //{
-	//	uint32_t phymode = get_phy_mode(nae, block);
-
-	//	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-	//	 	continue;
-	//	max_kr_lanes = (phymode==XFI_IF) ? 4:0;
-
-	//	if(!(nae->bkpl_cfg[block].kr_en))
-	//		continue;
-
-                for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){
-			__netsoc_perform_clause_173_base_page(nae, block, lane_ctrl);
-		}
-
-		for( lane_ctrl = 0; lane_ctrl < max_kr_lanes; lane_ctrl++){
-			__netsoc_bkpl_enable_link_training(nae, block, lane_ctrl);
-		}
-		nlm_print("Done with enable link with block = 0x%x\n", block);
-
-	//}
-		if (block==1){
-			for(lane_no=0; lane_no<4; lane_no++){
-        			if(lane_no != 0) while(lt_done_nae0_c0[lane_no -1] == 0) {}
-	        	         nlm_print(" Start Link Partner training on  complex:1 lane:%d\n",  lane_no);
-        	        	__netsoc_bkpl_link_partner_training(nae, 1, lane_no);
-	                	__netsoc_bkpl_link_device_training(nae, 1, lane_no);
-        	        	nlm_print(" Finished Link Device training on  complex:1 lane:%d\n",  lane_no);
-                		lt_done_nae0_c1[lane_no] = 1;
-			}
+	uint32_t phymode = get_phy_mode(nae, block);
+	uint64_t base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	uint64_t xlgmac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, block);
+
+	if(!(phymode==XLAUI_IF || phymode==XFI_IF))
+	 	return;
+	
+	__netsoc_init_kr_module();
+	
+	if(phymode==XLAUI_IF)
+		__netsoc_xlgmac_softreset(base, 0x2); 
+
+	__netsoc_bkpl_set_cl73_enable(nae, block, 0);
+
+	for(lane_no = 0; lane_no < max_kr_lanes; lane_no++){
+		__netsoc_bkpl_setup_link_training(nae, block, lane_no);
+		__netsoc_bkpl_enable_link_training(nae, block, lane_no);
+ 	       	if(__netsoc_bkpl_link_partner_training(nae, block, lane_no)==1){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Link partner training failed for block %d lane%d\n", block,lane_no);
+			return;
 		}
-		if (block==0){
-			for(lane_no=0; lane_no<4; lane_no++){
-        			if(lane_no != 0) while(lt_done_nae0_c1[lane_no -1] == 0) {}
-	        	         nlm_print(" Start Link Partner training on  complex:0 lane:%d\n",  lane_no);
-	                	__netsoc_bkpl_link_device_training(nae, 0, lane_no);
-        	        	__netsoc_bkpl_link_partner_training(nae, 0, lane_no);
-        	        	nlm_print(" Finished Link Device training on  complex:0 lane:%d\n",  lane_no);
-                		lt_done_nae0_c0[lane_no] = 1;
-			}
+           	if(__netsoc_bkpl_link_device_training(nae, block, lane_no)==1){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Link device training failed for block %d lane%d\n", block,lane_no);
+			return;
 		}
-
-
-#if 0
-	for( block = 0; block < 2; block++)
-        {
-		uint32_t phymode = get_phy_mode(nae, block);
-		if(!(phymode==XLAUI_IF || phymode==XFI_IF))
-		 	continue;
-		if(!(nae->bkpl_cfg[block].kr_en))
-			continue;
-
-                for( lane_ctrl = 0; lane_ctrl <= 0; lane_ctrl++){ /*AN on only one lane*/
-			//if((phymode==PHYMODE_XLAUI && lane_ctrl==0) || (phymode==PHYMODE_XFI)){
-				__netsoc_bkpl_auneg_complete(nae, block, lane_ctrl);
-			//}
+		if(__netsoc_bkpl_wait_for_ld_lt_done(nae, block, lane_no)==1){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Link device training wait failed for block %d lane%d\n", block,lane_no);
+			return;
 		}
-	}
-endif
+		/*disable link traing*/
+		__netsoc_bkpl_disable_link_training(nae, block, lane_no);
+	}
+	for(lane_no = 0; lane_no < max_kr_lanes; lane_no++){
+		volatile uint32_t rd_data;
+		//reset tx pll
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 0x2);
+		rd_data &= ~(1<<3); 
+		__netsoc_write_pma2p0_reg(base, lane_no, 0x2, rd_data);
+		//remove reset tx pll
+		rd_data = __netsoc_read_pma2p0_reg(base, lane_no, 0x2);
+		rd_data |= (1<<3); 
+		__netsoc_write_pma2p0_reg(base, lane_no, 0x2, rd_data);
+	}
+	/*remove PCS reset*/
+	if(phymode==XLAUI_IF)
+		__netsoc_xlgmac_softreset(base, 0x0);
+	if(__netsoc_bkpl_wait_for_an_complete(nae, block, 0)==1){
+		nlm_print("Autoneg and LT is over\n");
+	}
+	
 
 #endif
-#endif
 
 }
 
-- 
1.7.1

