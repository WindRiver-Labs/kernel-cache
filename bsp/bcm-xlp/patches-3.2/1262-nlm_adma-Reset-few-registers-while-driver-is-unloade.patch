From 35667d50a8bda1f96b6a14a60b3cdbca860a54fd Mon Sep 17 00:00:00 2001
From: Lakshman Garlapati <kumarga@broadcom.com>
Date: Thu, 11 Dec 2014 15:49:50 +0530
Subject: nlm_adma: Reset few registers while driver is unloaded

  CC bit reset to 0 in Debug Control register
  Clear the Master Enable and Channel type
  Fixed issues in xlp2xx, xlp3xx and xlp8xx boards
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/dtre/nlm_adma.c b/drivers/misc/netlogic/dtre/nlm_adma.c
index 4d57f59..22e7095 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.c
+++ b/drivers/misc/netlogic/dtre/nlm_adma.c
@@ -77,6 +77,8 @@ static int dtre_init_only = 0;
 
 #define DTRE_DEBUG_CONTROL0_OFFSET	0x4C
 #define DTRE_DEBUG_CONTROL1_OFFSET	0x4D
+#define DTRE_DEBUG_CONTROL2_OFFSET	0x4E
+#define DTRE_DEBUG_CONTROL3_OFFSET	0x4F
 #define CC_BIT_SHIFT			0x0
 #define CCD_BIT_SHIFT			0x1
 #define DTRE_CLEAR_CHANNEL(base, dbgCtrl) {\
@@ -86,7 +88,13 @@ static int dtre_init_only = 0;
 	value = nlm_hal_read_32bit_reg((base), (dbgCtrl)); \
 	while (!(value & (0x1 << CCD_BIT_SHIFT))) \
 		value = nlm_hal_read_32bit_reg((base), (dbgCtrl)); \
-	nlm_hal_write_32bit_reg((base), (dbgCtrl), (0x1 << CC_BIT_SHIFT)); \
+	nlm_hal_write_32bit_reg((base), (dbgCtrl), ~(0x1 << CC_BIT_SHIFT)); \
+}
+
+#define DTRE_DISABLE_CHANNEL(base, channelCtrl) {\
+	uint32_t val; \
+	val = nlm_hal_read_32bit_reg(base, channelCtrl); \
+	nlm_hal_write_32bit_reg(base, channelCtrl, val & 0XFFFFFFFD); \
 }
 
 static __inline__ void *cacheline_aligned_kzalloc(int size, int gfp_mask)
@@ -1749,7 +1757,7 @@ static int nlm_adma_probe(struct platform_device *pdev)
 static int nlm_adma_remove(struct platform_device *dev)
 {
 	int num_channels, loop;
-	uint64_t base;
+	uint64_t base, val;
 
 	if (is_nlm_xlp2xx())
 		num_channels = DTRE_2XX_NUM_CHANNELS;
@@ -1801,26 +1809,43 @@ static int nlm_adma_remove(struct platform_device *dev)
 		unregister_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, NULL);
 
 	/* Clear and reset the channels */
-	if (is_nlm_xlp9xx()) {
+	if (is_nlm_9xx_family) {
 		/* For DTRE0, B/D/F = 1/5/0 */
 		base = nlm_hal_get_dev_base(0, 1, 5, 0);
 		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
 		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
-
-		/* For DTRE1, B/D/F = 1/5/6 */
-		base = nlm_hal_get_dev_base(0, 1, 5, 6);
-		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
-		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
-	} else if (is_nlm_xlp5xx()) {
-		/* For DTRE, B/D/F = 1/5/0 */
-		base = nlm_hal_get_dev_base(0, 1, 5, 0);
-		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
-		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
-	} else if (!is_nlm_xlp2xx()) {
+		DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_0);
+		DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_1);
+		/* Clear the Master Enable and Channel type*/
+		val = nlm_hal_read_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG);
+		nlm_hal_write_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG, val & 0xFFFFFFEE);
+
+		if (is_nlm_xlp9xx()) {/* For DTRE1, B/D/F = 1/5/6 */
+		  base = nlm_hal_get_dev_base(0, 1, 5, 6);
+		  DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
+		  DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+		  DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_0);
+		  DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_1);
+		  /* Clear the Master Enable and Channel type*/
+		  val = nlm_hal_read_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG);
+		  nlm_hal_write_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG, val & 0xFFFFFFEE);
+		}
+	} else {
 		/* For DTRE, B/D/F = 0/5/0 */
 		base = nlm_hal_get_dev_base(0, 0, 5, 0);
 		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL0_OFFSET);
 		DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL1_OFFSET);
+		DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_0);
+		DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_1);
+		if (!is_nlm_xlp2xx()) {
+		  DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL2_OFFSET);
+		  DTRE_CLEAR_CHANNEL(base, DTRE_DEBUG_CONTROL3_OFFSET);
+		  DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_2);
+		  DTRE_DISABLE_CHANNEL(base, XLP_DTR_CHANNEL_CONTROL_REG_3);
+		}
+		/* Clear the Master Enable and Channel type*/
+		val = nlm_hal_read_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG);
+		nlm_hal_write_32bit_reg(base, XLP_DTR_MASTER_CONTROL_REG, val & 0xFFFFFFEE);
 	}
 
 	pr_info("NLM ASYNC Device Unregistered\n");
-- 
1.7.1

