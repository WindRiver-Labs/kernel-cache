From 83fa6c0f33d627125594f4f2700986002330c707 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Thu, 3 Oct 2013 03:35:28 -0700
Subject: ethtool: added support for ethtool for macsec.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_ethtool.c b/drivers/net/ethernet/broadcom/nae/xlpge_ethtool.c
index e089049..1194e3d 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_ethtool.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_ethtool.c
@@ -114,7 +114,7 @@ static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	//cmd->phy_address = mii_info.phyaddr;
 	cmd->phy_address = priv->phy.addr;
 	cmd->transceiver = XCVR_INTERNAL;
-	cmd->autoneg  = 1; /*Autoneg is always enabled by default*/ 
+	cmd->autoneg  = 1; /*Autoneg is always enabled by default*/
 	cmd->maxtxpkt = 0;
 	cmd->maxrxpkt = 0;
 
@@ -205,7 +205,7 @@ static void xlp_get_pauseparam(struct net_device *dev,
                                   struct ethtool_pauseparam *pause)
 {
         struct dev_data *priv = netdev_priv(dev);
-	
+
 	pause->autoneg = 1;
 	if(priv->flow_ctrl==1)
 	{
@@ -223,7 +223,7 @@ static int xlp_set_pauseparam(struct net_device *dev,
 {
         struct dev_data *priv = netdev_priv(dev);
         net_port_t *netport=&priv->nae->ports[priv->port];
-        
+
 	if(pause->rx_pause && pause->tx_pause) {
                 netsoc_enable_flow_control(netport);
                 priv->flow_ctrl=1;
@@ -231,7 +231,7 @@ static int xlp_set_pauseparam(struct net_device *dev,
         else {
                 netsoc_disable_flow_control(netport);
                 priv->flow_ctrl=0;
-        }       
+        }
         return 0;
 }
 
@@ -491,13 +491,10 @@ static struct ethtool_ops xlp_ethtool_ops = {
 	.set_eeprom		= xlp_set_eeprom,
 	.get_pauseparam         = xlp_get_pauseparam,
         .set_pauseparam         = xlp_set_pauseparam,
-
-#ifdef NOTYET
 	.msec_tx_config		= xlp_config_msec_tx,
 	.msec_tx_mem_config	= xlp_config_msec_tx_mem,
 	.msec_rx_config		= xlp_config_msec_rx,
 	.msec_rx_mem_config	= xlp_config_msec_rx_mem,
-#endif
 };
 
 void xlp_set_ethtool_ops(struct net_device *netdev)
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_msec.c b/drivers/net/ethernet/broadcom/nae/xlpge_msec.c
index 0417279..5d3c1af 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_msec.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_msec.c
@@ -36,33 +36,46 @@
 
 #include "xlpge.h"
 
-#ifdef NOTYET
 int xlp_config_msec_tx(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	if(is_nlm_xlp2xx())
-		nlm_hal_msec_tx_config(cmd->node, cmd->port_enable,
+	nae_t *nae;
+
+	if(is_nlm_xlp2xx() || is_nlm_xlp9xx())
+	{
+		nae = get_nae(cmd->node, cmd->num_nae);
+		__netsoc_msec_tx_config(nae, cmd->port_enable,
 			cmd->preamble_len, cmd->packet_num,
 			cmd->win_size_thrshld);
-
+	}
 	return 0;
 }
 
 int xlp_config_msec_tx_mem(struct net_device *dev,
 				  struct ethtool_cmd *cmd)
 {
-	if(is_nlm_xlp2xx())
-		nlm_hal_msec_tx_mem_config(cmd->node, cmd->port, cmd->tci,
+	nae_t *nae;
+
+	if(is_nlm_xlp2xx() || is_nlm_xlp9xx())
+	{
+		nae = get_nae(cmd->node, cmd->num_nae);
+		__netsoc_msec_tx_mem_config(nae, cmd->port, cmd->tci,
 			cmd->sci, cmd->key);
+	}
 
 	return 0;
 }
 
 int xlp_config_msec_rx(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	if(is_nlm_xlp2xx())
-		nlm_hal_msec_rx_config(cmd->node, cmd->port_enable,
+	nae_t *nae;
+
+	if(is_nlm_xlp2xx() || is_nlm_xlp9xx())
+	{
+		nae = get_nae(cmd->node, cmd->num_nae);
+		__netsoc_msec_rx_config(nae, cmd->port_enable,
 			cmd->preamble_len, cmd->packet_num,
 			cmd->win_size_thrshld);
+	}
 
 	return 0;
 }
@@ -70,10 +83,15 @@ int xlp_config_msec_rx(struct net_device *dev, struct ethtool_cmd *cmd)
 int xlp_config_msec_rx_mem(struct net_device *dev,
 				  struct ethtool_cmd *cmd)
 {
-	if(is_nlm_xlp2xx())
-		nlm_hal_msec_rx_mem_config(cmd->node, cmd->port, cmd->index,
+	nae_t *nae;
+
+	if(is_nlm_xlp2xx() || is_nlm_xlp9xx())
+	{
+		nae = get_nae(cmd->node, cmd->num_nae);
+		__netsoc_msec_rx_mem_config(nae, cmd->port, cmd->index,
 			cmd->sci, cmd->key, cmd->sci_mask);
+	}
 
 	return 0;
 }
-#endif
+
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index 9563152..dd403cf 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -736,14 +736,14 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 		nae_cfg->sectag_len[port], nae_cfg->icv_len[port]);
 	dump_buffer(skb->data, len, "RX skb pkt:");
 	printk("msec_port = %x port = %d len = %d \
-		nae_cfg->msec_port_enable = %x\n",msec_port, port,
-		len, nae_cfg->msec_port_enable);
+		nae_cfg->msec_rx_port_enable = %x\n",msec_port, port,
+		len, nae_cfg->msec_rx_port_enable);
 #endif
 
 	/* check if port is tx port is enabled for msec
 	 * else bypass MACSec
 	 */
-	if(nae_cfg->msec_port_enable & msec_port) {
+	if(nae_cfg->msec_rx_port_enable & msec_port) {
 		short ether_type = *(short*)(((char*)skb->data) +
 					MAC_HEADER_LEN);
 
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tso.c b/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
index 9e8c741..256d751 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tso.c
@@ -113,14 +113,14 @@ inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	dump_buffer(skb->data, skb->len, "Org skb pkt:");
 	printk("msec_port = %x priv->port = %d priv->block = %d \
 		priv->index = %d skb->len = %d \
-		nae_cfg->msec_port_enable = %x\n",
+		nae_cfg->msec_tx_port_enable = %x\n",
 		msec_port, priv->port, priv->block, priv->index,
-		skb->len, nae_cfg->msec_port_enable);
+		skb->len, nae_cfg->msec_tx_port_enable);
 #endif
 	/* check if tx port is enabled for msec
 	 * else bypass MACSec
 	 */
-	if (nae_cfg->msec_port_enable & msec_port) {
+	if (nae_cfg->msec_tx_port_enable & msec_port) {
 		short ether_type = *(short*)(((char*)skb->data) +
 					MAC_HEADER_LEN);
 
@@ -249,7 +249,7 @@ inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 		create_last_p2p_desc(p2pdesc, skb, idx);
 		msg = nae_tx_desc(DESC_TYPE_P2P, qid, idx, virt_to_bus(p2pdesc));
 	}
-	
+
 
 	__sync();
 
@@ -293,5 +293,6 @@ int tso_enable(struct net_device *dev, u32 data)
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
 	dev->features = dev->hw_features;
 	dev->features |= NETIF_F_HIGHDMA;
+
 	return rv;
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
index aad091a..6265f11 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
@@ -85,14 +85,14 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	dump_buffer(skb->data, skb->len, "Org skb pkt:");
 	printk("msec_port = %x priv->port = %d priv->block = %d \
 		priv->index = %d skb->len = %d \
-		nae_cfg->msec_port_enable = %x\n",
+		nae_cfg->msec_tx_port_enable = %x\n",
 		msec_port, priv->port, priv->block, priv->index,
-		skb->len, nae_cfg->msec_port_enable);
+		skb->len, nae_cfg->msec_tx_port_enable);
 #endif
 	/* check if tx port is enabled for msec
 	 * else bypass MACSec
 	 */
-	if (nae_cfg->msec_port_enable & msec_port) {
+	if (nae_cfg->msec_tx_port_enable & msec_port) {
 
 #ifdef MACSEC_DEBUG
 	short ether_type = *(short*)(((char*)skb->data) +
-- 
1.7.1

