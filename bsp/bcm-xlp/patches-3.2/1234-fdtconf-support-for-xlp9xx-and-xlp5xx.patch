From 75f26f4af309b4d166461fdde82d0e525e1725bd Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmayj@broadcom.com>
Date: Fri, 25 Jul 2014 16:49:40 +0530
Subject: fdtconf: support for xlp9xx and xlp5xx

xlp9xx-config.dtb is the new dtb file that gets loaded at runtime for
xlp9xx and xlp5xx. Default ucore code is added to the appropriate NAE
section.
Also added a feature that allows users to modify the legacy dtb passed
at boot time.
Compilation warnings have also been fixed.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/fdtconf/fdtconf.c b/drivers/misc/netlogic/fdtconf/fdtconf.c
index f338501..c76c3c5 100644
--- a/drivers/misc/netlogic/fdtconf/fdtconf.c
+++ b/drivers/misc/netlogic/fdtconf/fdtconf.c
@@ -40,8 +40,18 @@
 #include "libfdt.h"
 #include "nlm_hal.h"
 
-#define FDT_FIRMWARE	"xlp-config.dtb"
+/* FDT parameters */
 #define FDT_ADDSZ	(16 * 1024)
+#define FDT_FIRMWARE	((is_nlm_xlp9xx() || is_nlm_xlp5xx()) ?	\
+			"xlp9xx-config.dtb" : "xlp-config.dtb")
+
+/* Default ucore code for NAE kernel driver */
+#define	LINUX_UCORE	"linux-ucore.hex"
+
+/* Path to ucore code in device tree */
+#define	UCORE_0		"/soc/net@node-0/nae-0/ucore/src@1"
+#define	UCORE_1		"/soc/net@node-0/nae-1/ucore/src@1"
+#define	UCORE		"/soc/nae@node-0/nae/ucore/src@1"
 
 void *fdt;
 EXPORT_SYMBOL(fdt);
@@ -95,7 +105,56 @@ static void parse_and_fill_kern_params(void)
 	 * to use memory region allocated by linux for freein-fifos.
 	 */
 	/* TODO allocate freein-fifo memory for multiple domians */
-	node = fdt_path_offset(fdt, "/doms/dom@1/nae");
+	/*
+	 * For XLP9XX  we need to provide memory for free-in fifos in both
+	 * NAE-0 and NAE-1. Hence we equally divide the allocated memory for
+	 * free-in fifos.
+	 */
+	if (is_nlm_xlp9xx()) {
+		node = fdt_path_offset(fdt, "/doms/dom@1/nae-0");
+		if (node < 0)
+			return;
+
+		prop = fdt_getprop(fdt, node, "freein-fifo-replenish-addr-info",
+					&plen);
+		if (prop == NULL)
+			return;
+
+		/* Freein Fifo start address */
+		prop[1] = (frin_fifo_address >> 32) & 0xffffffff;
+		prop[2] = frin_fifo_address & 0xffffffff;
+
+		/* Freein Fifo size */
+		prop[3] = ((frin_fifo_size / 2) >> 32) & 0xffffffff;
+		prop[4] = (frin_fifo_size / 2) & 0xffffffff;
+
+		node = fdt_path_offset(fdt, "/doms/dom@1/nae-1");
+		if (node < 0)
+			return;
+
+		prop = fdt_getprop(fdt, node, "freein-fifo-replenish-addr-info",
+					&plen);
+		if (prop == NULL)
+			return;
+
+		frin_fifo_size -= (frin_fifo_size / 2);
+		frin_fifo_address += frin_fifo_size;
+		/* Freein Fifo start address */
+		prop[1] = (frin_fifo_address >> 32) & 0xffffffff;
+		prop[2] = frin_fifo_address & 0xffffffff;
+
+		/* Freein Fifo size */
+		prop[3] = (frin_fifo_size >> 32) & 0xffffffff;/* High 32-bits */
+		prop[4] = frin_fifo_size & 0xffffffff;	/* Low 32-bits */
+
+		return;
+	}
+
+	if (is_nlm_xlp5xx())
+		node = fdt_path_offset(fdt, "/doms/dom@1/nae-0");
+	else
+		node = fdt_path_offset(fdt, "/doms/dom@1/nae");
+
 	if (node < 0)
 		return;
 
@@ -115,9 +174,9 @@ static void parse_and_fill_kern_params(void)
 /*
  * Load ucore opcodes in the dtb.
  */
-static int handle_opcodes(char *node, char *file)
+static int handle_opcodes(int node, char *file)
 {
-	struct firmware	*fw;
+	const struct firmware	*fw;
 	char		*next, *ucode, *end_of_code;
 	uint32_t	ucode_buf[1024], ncodes, *umask;
 	int		err;
@@ -126,7 +185,7 @@ static int handle_opcodes(char *node, char *file)
 	 * 2. Read that file and replace the opcode section of the fdt
 	 *    blob with the read file data.
 	 * 3. Set num-opcodes based on number of opcodes present in the file.
-	 * 4. Also check the ucore mask. 
+	 * 4. Also check the ucore mask.
 	 */
 	if (request_firmware(&fw, file, &fdtdev->dev))
 		return -ENOENT;
@@ -158,7 +217,7 @@ static int handle_opcodes(char *node, char *file)
 		goto out;
 
 	/* Fix/check ucore mask based on board type */
-	umask = fdt_getprop(fdt, node, "mask", &ucode);
+	umask = fdt_getprop(fdt, node, "mask", &ncodes);
 	if (umask == NULL)
 		goto out;
 
@@ -292,7 +351,7 @@ static ssize_t read_fdt(struct file *filep, struct kobject *kobj,
 /*
  * Expand the FDT blob.
  */
-static void *fdt_expand_into(struct firmware *fw, int sizeincr)
+static void *fdt_expand_into(const struct firmware *fw, int sizeincr)
 {
 	int size;
 	void *buf;
@@ -314,43 +373,50 @@ static void *fdt_expand_into(struct firmware *fw, int sizeincr)
  */
 static int __init fdtconf_init(void)
 {
-	struct firmware *fw;
+	const struct firmware *fw;
 	int err, ret = 0, node;
 
+	/* Register a platform device */
+	fdtdev = platform_device_register_simple("fdtconf", -1, NULL, 0);
+
+	if (fdtdev == NULL) {
+		pr_err("fdtconf: Registering device failed\n");
+		return -ENODEV;
+	}
+
 	/*
 	 * If the dtb contains the doms section, then dtb passed to linux
-	 * at boot time contains all the sections and parameters needed to 
+	 * at boot time contains all the sections and parameters needed to
 	 * run all the applications and modules.
 	 */
 	fdt = initial_boot_params;
-	node = fdt_path_offset(fdt, "/doms/dom@0/cpu");
+	node = fdt_path_offset(fdt, "/doms/dom@0");
 	if (node >= 0) {
 		pr_info("Going into legacy mode and using the dtb passed at"
 			" boot time\n");
-		return 0;
+		goto create_sys_files;
 	}
 
-	/* Register a platform device */
-	fdtdev = platform_device_register_simple("fdtconf", -1, NULL, 0);
-
-	if (fdtdev == NULL) {
-		pr_err("fdtconf: Registering device failed\n");
-		return -ENODEV;
-	}
-
-	 /* Request system.dtb file through request_firmware interface */
+	/*
+	 * Obtain appropriate dtb file through request_firmware interface.
+	 */
 	err = request_firmware(&fw, FDT_FIRMWARE, &fdtdev->dev);
 	if (err) {
-		pr_err("request_firmware %s failed (%d_\n", FDT_FIRMWARE, ret);
+		pr_err("request_firmware %s failed (%d)\n", FDT_FIRMWARE, ret);
 		ret = -ENODEV;
 		goto err_plat;
 	}
 
+	/*
+	 * The dtb file is copied into a larger memory area so that there is
+	 * enough space to load the ucore code and also modify parameters.
+	 */
 	fdt = fdt_expand_into(fw, FDT_ADDSZ);
 	if (fdt == NULL) {
 		pr_err("fdt_expand_into failed\n");
 		err = -ENOMEM;
-		goto err_fw;
+		release_firmware(fw);
+		goto err_plat;
 	}
 	initial_boot_params = fdt;
 
@@ -361,15 +427,35 @@ static int __init fdtconf_init(void)
 	parse_and_fill_kern_params();
 
 	/*
+	 * Release the dtb file.
+	 */
+	release_firmware(fw);
+
+	/*
 	 * Insert the default ucore code into the dtb.
 	 */
-	node = fdt_path_offset(fdt, "/soc/nae@node-0/ucore/src@1");
+	if (is_nlm_xlp9xx() || is_nlm_xlp5xx())
+		node = fdt_path_offset(fdt, UCORE_0);
+	else
+		node = fdt_path_offset(fdt, UCORE);
+
 	if (node >= 0) {
-		err = handle_opcodes(node, "linux-ucore.hex");
+		err = handle_opcodes(node, LINUX_UCORE);
 		if (err)
-			goto err_fw;
+			goto err_free;
 	}
 
+	/* Load default ucore code for NAE-1 in XLP9XX */
+	if (is_nlm_xlp9xx()) {
+		node = fdt_path_offset(fdt, UCORE_1);
+		if (node >= 0) {
+			err = handle_opcodes(node, LINUX_UCORE);
+			if (err)
+				goto err_free;
+		}
+	}
+
+create_sys_files:
 	/* Create a sys file to read data from the fdt blob */
 	binfdt_attr.attr.name = "app.dtb";
 	binfdt_attr.attr.mode = (S_IRUSR);
@@ -380,7 +466,7 @@ static int __init fdtconf_init(void)
 	if (err) {
 		dev_err(&fdtdev->dev, "Could not create app.dtb %d\n", err);
 		ret = err;
-		goto err_sys1;
+		goto err_free;
 	}
 
 	/* Create a sys file to control the operations on the fdt blob */
@@ -393,19 +479,16 @@ static int __init fdtconf_init(void)
 	if (err) {
 		dev_err(&fdtdev->dev, "Couldn't create control file %d\n", err);
 		ret = err;
-		goto err_sys2;
+		goto err_sysfs;
 	}
 
-	release_firmware(fw);
 	return 0;
 
-err_sys2:
+err_sysfs:
 	sysfs_remove_bin_file(&fdtdev->dev.kobj, &binfdt_attr);
-err_sys1:
+err_free:
 	kfree(fdt);
 	fdt = NULL;
-err_fw:
-	release_firmware(fw);
 err_plat:
 	platform_device_unregister(fdtdev);
 	return ret;
-- 
1.7.1

