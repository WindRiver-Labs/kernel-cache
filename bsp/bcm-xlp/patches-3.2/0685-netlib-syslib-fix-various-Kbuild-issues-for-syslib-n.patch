From b658bb6803032d37a952de0e2fb8aa7a8578714e Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 7 May 2013 11:16:34 -0700
Subject: netlib/syslib: fix various Kbuild issues for syslib/netlib

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
index 099f517..0664182 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
@@ -11,10 +11,8 @@
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/netdevice.h>
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
-#include "nlm_evp_cpld.h"
 #endif
+#include "nlm_evp_cpld.h"
 #include <netsoc_dev.h>
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p1.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p1.c
index 474ed49..1694b96 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p1.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p1.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p10.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p10.c
index c59bc2c..4892715 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p10.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p10.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p11.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p11.c
index 961a52b..2076f62 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p11.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p11.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p12.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p12.c
index 14345c7..c44f48c 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p12.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p12.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p2.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p2.c
index 639733d..0ab873e 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p2.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p2.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p3.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p3.c
index 640ccde..031010c 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p3.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p3.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p4.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p4.c
index ea7a94e..192b5bc 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p4.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p4.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p5.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p5.c
index 5baa144..e3fd2a6 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p5.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p5.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p6.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p6.c
index 1d089a7..f7c9faa 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p6.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p6.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p7.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p7.c
index b4a2d96..b6aace0 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p7.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p7.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p8.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p8.c
index 73c7339..82bbc89 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p8.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p8.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p9.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p9.c
index 32028a6..b3b7259 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p9.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7_p9.c
@@ -9,11 +9,7 @@
 
 /* Based on the code from Cortina */
 
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <asm/netlogic/hal/nlm_evp_cpld.h>
-#else
 #include "nlm_evp_cpld.h"
-#endif
 
 #define XGE_MAC_STATS_ACCESS    0x0728c
 #define XGE_MAC_STATS_DATA0     0x0728f
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 20efc3a..6af9f5a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -395,7 +395,7 @@ static int __netsoc_update_context_mapping(nae_t *nae, net_port_t **cntx)
                         txq_base  += nae->ports[i].num_channels;
                 else
                         txq_base += 8;
-		printf("port %d txq_base %d \n",i, nae->ports[i].txq);
+		netsoc_api_print(NETSOC_APIDBG_TRACE, "port %d txq_base %d \n",i, nae->ports[i].txq);
         }
 #endif  
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
index 874371e..8fca5bb 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
@@ -794,19 +794,19 @@ int netsoc_v0_poe_send_resp(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_i
 #ifdef NETSOC_MSG_DEBUG
                       fmndbg("MSC0 0x%llx msg0 0x%llx\n",msc0, msg0);
 #endif
-                      xlp_message_send_block_fast_3(0, (port->txq + resp->channel), msg0, msc0, msg1);
+                      xlp_message_send_3((port->txq + resp->channel), 0, msg0, msc0, msg1);
              }
              else if (msc_size == 2) {
 #ifdef NETSOC_MSG_DEBUG
                       fmndbg("MSC0 0x%llx MSC1 0x%llx msg0 0x%llx\n",msc0, msc1, msg0);
 #endif
-                      xlp_message_send_block_fast_4(0, (port->txq + resp->channel), msg0, msc0, msc1, msg1);
+                      xlp_message_send_4((port->txq + resp->channel), 0, msg0, msc0, msc1, msg1);
              }
              else {
 #ifdef NETSOC_MSG_DEBUG
                       fmndbg("msg0 0x%llx\n msg1 0x%llx\n", msg0, msg1);
 #endif
-                      xlp_message_send_block_fast_2(0, (port->txq + resp->channel), msg0, msg1);
+                      xlp_message_send_2((port->txq + resp->channel), 0, msg0, msg1);
              }
 
         }
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 6127a5e..9d73cb9 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1245,7 +1245,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
         int fifo_xoff_thresh;
         int port, lane = 0, hw_port = 0, max_lanes, offset = 0;
 	int cur_iface_start = 0, max_ports;
-	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0, tempctx_base;
+	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
 	int thrgrp = 0, rx_buf_size;
 
 	max_ports = __netsoc_get_max_ports();
@@ -3295,13 +3295,13 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
 
                                 reg = spill_addr & 0xffffffff;
                                 netsoc_write_nae_reg(nae->nae_base, FREE_SPILL0_MEM_CFG, reg);
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_addr %lx spill_claddrlo %x\n", i, (long)(spill_addr << 6) ,
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_addr %lx spill_claddrlo %lx\n", i, (long)(spill_addr << 6) ,
 							(long)spill_addr);
 
                                 reg = (((spill_addr >> 32) & 0x3) << 30) | spillsz;
                                 netsoc_write_nae_reg(nae->nae_base, FREE_SPILL1_MEM_CFG, reg);
 
-                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_claddrhi %lx spillsize %d cachelines\n",
+                                netsoc_api_print(NETSOC_APIDBG_CONFIG, "Freein fifo cfg %d spl_claddrhi %x spillsize %d cachelines\n",
 								 i, ((reg >> 30) & 0x3), (reg & 0x3fffffff));
                                 spill_addr += spillsz;
                                 /* align to 32k, already >> 6 is done above, so align to 1k */
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index d32b5c0..7f57041 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -939,7 +939,11 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
 void __netsoc_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-        if (is_nlm_xlp2xx())
+	if (is_nlm_xlp9xx())
+	{
+		xlp9xx_sgmii_pcs_init(nae, sgmii_cplx_mask);
+        }
+        else if (is_nlm_xlp2xx())
         {
 		xlp2xx_sgmii_pcs_init(nae, sgmii_cplx_mask);
         }
@@ -954,6 +958,9 @@ void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymod
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 	if (is_nlm_xlp2xx()) {
+		xlp9xx_xaui_pcs_init(nae, xaui_cplx_mask, phymode);
+	}
+	else if (is_nlm_xlp2xx()) {
 		xlp2xx_xaui_pcs_init(nae, xaui_cplx_mask, phymode);
 	}
 	else {
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index cba53ae..56534eb 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -37,6 +37,7 @@
 #include "fdt_helper.h"
 #include "nlm_evp_cpld.h"
 #include "nlm_hal_vsemi_data.h"
+#include "nlm_hal_fmn_dp.h"
 
 #define VAL_UCORE_RESET(x) ( ( (x) &0xffff) << 8)
 
@@ -3831,7 +3832,7 @@ void drain_nae_stray_packets(int node)
 
 		/* Send Free descriptors */
 		for (i = 0; i < 100; ++i) {
-			if (nlm_hal_send_msg1( mgmt_vc + j,
+			if (xlp_message_send_1( mgmt_vc + j,
 					       0,
 					       laddr)) {
 
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_nae.h
deleted file mode 100644
index dae9f42..0000000
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_nae.h
+++ /dev/null
@@ -1,625 +0,0 @@
-
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-
-#ifndef _NLM_HAL_NAE_H_
-#define _NLM_HAL_NAE_H_
-#ifdef NLM_LINUX_KERNEL
-#include <linux/netdevice.h>
-#endif
-#include "nlm_hal.h"
-
-#define NUM_DIST_VEC 		16
-#define NUM_WORDS_PER_DV 	16
-#define MAX_DV_TBL_ENTRIES (NUM_DIST_VEC * NUM_WORDS_PER_DV)
-
-#define XLP_3XX_MAX_PORTS	8
-#define XLP_2XX_MAX_PORTS	8
-#define XLP_MAX_PORTS		18
-
-#define NAE_RECV_NONE          	0x00000000
-#define NAE_RECV_RX            	0x00000001
-#define NAE_RECV_TXC           	0x00000002
-#define NAE_RECV_UNKNOWN       	0x80000000
-#define NULL_VFBID             	127
-#define MAX_NAE_CONTEXTS       	524
-#define XLP8XX_MAX_NAE_COMPLEX 	5
-#define MAX_CAL_SLOTS	       	64
-#define MAX_VFBID_ENTRIES	128
-
-#define XLP_MAX_FLOWS       (64 << 10)
-
-#define SGMII_CAL_SLOTS         3
-#define XAUI_CAL_SLOTS          13
-#define ILK_CAL_SLOTS           26
-
-#define MAX_PORTS_PERBLOCK	4
-#define XLP_MAX_INTERLAKEN_IF	2
-
-#define XLP3XX_MAX_NAE_FREQUENCY	250 /* in MHZ */
-#define XLP3XX_MAX_NAE_COMPLEX	2
-#define XLP3XX_MAX_NAE_CONTEXTS	64
-#define MAX_POE_CLASSES     	8
-#define MAX_POE_CLASS_CTXT_TBL_SZ ((MAX_NAE_CONTEXTS / MAX_POE_CLASSES) + 1)
-#define XLP3XX_MAX_POE_CLASS_CTXT_TBL_SZ ((XLP3XX_MAX_NAE_CONTEXTS / MAX_POE_CLASSES) + 1)
-#define XLP3XX_SGMII_PARSERSEQ_FIFO_MAX	30
-/*################################*/
-#define XLP3XX_STG2_FIFO_SZ   512
-#define XLP3XX_EH_FIFO_SZ     512
-#define XLP3XX_FROUT_FIFO_SZ  512
-#define XLP3XX_MS_FIFO_SZ     512
-#define XLP3XX_PKT_FIFO_SZ    8192
-#define XLP3XX_PKTLEN_FIFO_SZ 512
-
-#define XLP3XX_MAX_STG2_OFFSET           0x7F
-#define XLP3XX_MAX_EH_OFFSET             0x1f
-#define XLP3XX_MAX_FREE_OUT_OFFSET       0x1f
-#define XLP3XX_MAX_MS_OFFSET             0xF
-#define XLP3XX_MAX_PMEM_OFFSET           0x7FE
-
-
-#define XLP3XX_STG1_2_CREDIT     XLP3XX_STG2_FIFO_SZ
-#define XLP3XX_STG2_EH_CREDIT    XLP3XX_EH_FIFO_SZ
-#define XLP3XX_STG2_FROUT_CREDIT XLP3XX_FROUT_FIFO_SZ
-#define XLP3XX_STG2_MS_CREDIT    XLP3XX_MS_FIFO_SZ
-
-/*################################*/
-
-/*################################*/
-#define XLP8XX_STG2_FIFO_SZ   2048
-#define XLP8XX_EH_FIFO_SZ     4096
-#define XLP8XX_FROUT_FIFO_SZ  4096
-#define XLP8XX_MS_FIFO_SZ     2048
-#define XLP8XX_PKT_FIFO_SZ    16384
-#define XLP8XX_PKTLEN_FIFO_SZ 2048
-
-#define XLP8XX_MAX_STG2_OFFSET           0x7F
-#define XLP8XX_MAX_EH_OFFSET           	 0x7F
-#define XLP8XX_MAX_FREE_OUT_OFFSET       0x7F
-#define XLP8XX_MAX_MS_OFFSET             0x14
-#define XLP8XX_MAX_PMEM_OFFSET           0x7FE
-
-#define XLP8XX_STG1_2_CREDIT     XLP8XX_STG2_FIFO_SZ
-#define XLP8XX_STG2_EH_CREDIT    XLP8XX_EH_FIFO_SZ
-#define XLP8XX_STG2_FROUT_CREDIT XLP8XX_FROUT_FIFO_SZ
-#define XLP8XX_STG2_MS_CREDIT    XLP8XX_MS_FIFO_SZ
-
-#define XLP_FREEIN_SPILL_DEFAULT_MEM_ADDR (252ULL << 20)
-#define XLP_FREEIN_SPILL_DEFAULT_MEM_SIZE (4ULL << 20)
-
-/*################################*/
-
-#define NETIOR_CMPLX_0_INIT_CREDIT	0
-#define NETIOR_CMPLX_1_INIT_CREDIT	8
-#define NETIOR_CMPLX_2_INIT_CREDIT	16
-#define NETIOR_CMPLX_3_INIT_CREDIT	24
-#define NETIOR_CMPLX_4_INIT_CREDIT	18
-
-struct nae_complex_config {
-	uint32_t num_free_desc[MAX_PORTS_PERBLOCK];
-	uint32_t free_desc_size[MAX_PORTS_PERBLOCK];
-	uint32_t intf_fifo_size[MAX_PORTS_PERBLOCK];
-	uint32_t prsr_seq_fifo_size[MAX_PORTS_PERBLOCK];
-	uint32_t rx_buf_size[MAX_PORTS_PERBLOCK];
-	uint32_t ucore_mask[MAX_PORTS_PERBLOCK];	
-	uint32_t ext_phy_addr[MAX_PORTS_PERBLOCK];
-	uint32_t ext_phy_bus[MAX_PORTS_PERBLOCK];
-	uint32_t mgmt[MAX_PORTS_PERBLOCK];
-	uint32_t loopback[MAX_PORTS_PERBLOCK];
-	uint32_t num_channels[MAX_PORTS_PERBLOCK];
-	uint32_t num_lanes;
-	uint32_t lane_rate;
-	uint32_t higig_mode;
-	uint32_t xgmii_speed;
-	uint32_t vlan_pri_en;
-	uint32_t msec_port_enable;
-};
-
-
-struct poe_statistics {
-	uint64_t ooo_msg_count;
-	uint64_t inorder_msg_count;
-	uint64_t loc_stor_access_count;
-	uint64_t ext_stor_access_count;
-	uint64_t loc_stor_alloc_count;
-	uint64_t ext_stor_alloc_count;
-};
-
-
-/* Temporarily specifying these sizes here. 
-   These will be moved to FDT soon 
-*/
-
-static inline uint32_t nlm_stg2_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_STG2_FIFO_SZ;
-	}else{
-		return XLP8XX_STG2_FIFO_SZ;
-	}
-}
-
-static inline uint32_t nlm_eh_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_EH_FIFO_SZ;
-	}else{
-		return XLP8XX_EH_FIFO_SZ;
-	}
-}
-
-static inline uint32_t nlm_frout_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_FROUT_FIFO_SZ;
-	}else{
-		return XLP8XX_FROUT_FIFO_SZ;
-	}
-}
-
-static inline uint32_t nlm_ms_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MS_FIFO_SZ;
-	}else{
-		return XLP8XX_MS_FIFO_SZ;
-	}
-}
-
-static inline uint32_t nlm_pkt_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_PKT_FIFO_SZ;
-	}else{
-		return XLP8XX_PKT_FIFO_SZ;
-	}
-}
-
-static inline uint32_t nlm_pktlen_fifo_sz(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_PKTLEN_FIFO_SZ;
-	}else{
-		return XLP8XX_PKTLEN_FIFO_SZ;
-	}
-}
-
-static inline uint32_t max_stg2_offset(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MAX_STG2_OFFSET;
-	}else{
-		return XLP8XX_MAX_STG2_OFFSET;
-	}
-}
-
-static inline uint32_t max_eh_offset(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MAX_EH_OFFSET;
-	}else{
-		return XLP8XX_MAX_EH_OFFSET;
-	}
-}
-
-static inline uint32_t max_free_out_offset(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MAX_FREE_OUT_OFFSET;
-	}else{
-		return XLP8XX_MAX_FREE_OUT_OFFSET;
-	}
-}
-
-static inline uint32_t max_ms_offset(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MAX_MS_OFFSET;
-	}else{
-		return XLP8XX_MAX_MS_OFFSET;
-	}
-}
-
-static inline uint32_t max_pmem_offset(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_MAX_PMEM_OFFSET;
-	}else{
-		return XLP8XX_MAX_PMEM_OFFSET;
-	}
-}
-
-static inline uint32_t stg1_2_credit(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_STG1_2_CREDIT;
-	}else{
-		return XLP8XX_STG1_2_CREDIT;
-	}
-}
-
-static inline uint32_t stg2_eh_credit(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_STG2_EH_CREDIT;
-	}else{
-		return XLP8XX_STG2_EH_CREDIT;
-	}
-}
-
-static inline uint32_t stg2_frout_credit(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_STG2_FROUT_CREDIT;
-	}else{
-		return XLP8XX_STG2_FROUT_CREDIT;
-	}
-}
-
-static inline uint32_t stg2_ms_credit(void)
-{
-	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
-		return XLP3XX_STG2_MS_CREDIT;
-	}else{
-		return XLP8XX_STG2_MS_CREDIT;
-	}
-}
-
-
-/*###################################################*/
-/* To access Interface specific regs in NAE block */
-#define XLP_NAE_OFFSET(node, iface) \
-	(xlp_nae_base[node] | (((iface) & 0xf) << 9))
-
-/* To access individual gmac regs */
-#define XLP_MAC_OFFSET(node, blk, iface) \
-	(xlp_mac_base[node] + (((blk) * XLP_NA_REG_BLOCK_SIZE)) + ((iface) * XLP_NA_REG_IFACE_SIZE))
-
-#ifndef __ASSEMBLY__
-/* To access POE regs based in PCI Memory */
-
-#define nlm_hal_write_poe_pcim_reg(node, reg, val) nlm_hal_write_32bit_reg(xlp_poe_base_pcim[node], (reg), (val))
-#define nlm_hal_read_poe_pcim_reg(node, reg)   nlm_hal_read_32bit_reg(xlp_poe_base_pcim[node], (reg))
-
-/* To access POE regs based in PCIE config space */
-
-#define nlm_hal_write_poe_pcie_reg(node, reg, val) nlm_hal_write_32bit_reg(xlp_poe_base_pcie[node], (reg), (val))
-#define nlm_hal_read_poe_pcie_reg(node, reg)   nlm_hal_read_32bit_reg(xlp_poe_base_pcie[node], (reg))
-
-/* NAE */
-#define nlm_hal_write_nae_reg(node, reg, val) nlm_hal_write_32bit_reg(xlp_nae_base[node], (reg), (val))
-#define nlm_hal_read_nae_reg(node, reg) nlm_hal_read_32bit_reg(xlp_nae_base[node], (reg))
-
-#define nlm_hal_write_nae_iface_reg(node, iface, reg, val) nlm_hal_write_32bit_reg(XLP_NAE_OFFSET(node, iface), (reg), (val))
-#define nlm_hal_read_nae_iface_reg(node, iface, reg) nlm_hal_read_32bit_reg(XLP_NAE_OFFSET(node, iface), (reg))
-
-#define nlm_hal_write_ucode(node, ucore, offset, val) \
-  nlh_write_cfg_reg32((xlp_mac_base[node] + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset), (val))
-
-#define nlm_hal_read_ucode(node, ucore, offset) \
-  nlh_read_cfg_reg32((xlp_mac_base[node] + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset))
-
-#define nlm_hal_write_mac_reg(node, blk, iface, reg, val) nlm_hal_write_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg), (val))
-
-#define nlm_hal_read_mac_reg(node, blk, iface, reg) nlm_hal_read_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg))
-
-#define read_gmac_reg(node, idx, reg) nlm_hal_read_mac_reg(node, (((idx) & 0xff)>>2), ((idx) & 0x3), reg)
-#define write_gmac_reg(node, idx, reg, val) nlm_hal_write_mac_reg(node, (((idx) & 0xff)>>2), ((idx) & 0x3), (reg), (val))
-
-static __inline__ uint32_t vfbid_to_dest_map(unsigned int vfbid, unsigned int dest, int cmd) {
-	return ((dest & 0x3fff) << 16) | ((vfbid & 0x7f) << 4) | (cmd & 0x1);
-}
-
-static __inline__ uint32_t ucore_spray_config(unsigned int interface, unsigned int ucore_mask, int cmd) {
-	return ((cmd & 0x1) << 31) | ((ucore_mask & 0xffff) << 8) | (interface & 0x1f);
-}
-
-static __inline__ uint32_t poe_class_config(unsigned int table_index, unsigned int poe_class, int cmd) {
-	return ((poe_class & 0xffffff) << 8) | ((cmd & 0x1) << 7) | (table_index & 0x7f);
-}
-
-static __inline__ uint32_t flow_base_mask_config(unsigned int interface, unsigned int base, unsigned int mask, int cmd) {
-	return ((base & 0xffff) << 16) | ((cmd & 0x1) << 15) | ((mask & 0x1f) << 8) | (interface & 0x1f);
-}
-
-uint32_t nlm_hal_get_frin_total_queue(int node);
-uint32_t nlm_hal_get_frin_queue_base(int node);
-extern int nlm_hal_init_poe_distvec(int node, int vec, uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3, uint32_t vcmask);
-extern void nlm_hal_init_poe_ext_storage(int node, 
-					 uint64_t fbp_base_phys,
-					 uint64_t fbp_base_virt,
-					 uint64_t msg_base_phys,
-					 uint64_t msg_base_virt);
-
-extern int nlm_hal_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int num_opcodes);
-
-extern int nlm_hal_init_if(int node, int intf_type, int  block, uint32_t *regs, int num_regs);
-extern int nlm_hal_open_if(int node, int intf_type, int  block);
-extern int nlm_hal_close_if(int node, int intf_type, int  block);
-extern void nlm_hal_init_ingress(int node, int desc_size);
-
-extern void nlm_hal_init_ext_phy(int node, int inf);
-extern void nlm_hal_ext_phy_an(int node, int inf);
-extern int  nlm_hal_status_ext_phy(int node, int inf,struct nlm_hal_mii_info *mii_info);
-extern void nlm_hal_restart_an(int node, int inf);
-
-extern int nlm_enable_poe_statistics(int node);
-extern int nlm_disable_poe_statistics(int node);
-extern int nlm_read_poe_statistics(int node, struct poe_statistics *stats);
-
-extern void nlm_hal_prepad_enable(int node, int size);
-extern void nlm_hal_reset_1588_accum(int node);
-extern void nlm_hal_1588_ld_freq_mul(int node, uint32_t ptp_inc_den, uint32_t ptp_inc_num, 
-					uint32_t ptp_inc_intg);
-extern void nlm_hal_1588_ld_offs(int node, uint32_t ptp_off_hi,  uint32_t ptp_off_lo);
-extern void nlm_hal_1588_ld_user_val(int node, uint32_t user_val_hi,  uint32_t user_val_lo);
-extern void nlm_hal_1588_ptp_clk_sel(int node, int clk_type);
-extern uint32_t nlm_hal_get_int_sts(int node);
-extern uint64_t  nlm_hal_1588_ptp_get_counter(int node, int counter);
-extern void nlm_hal_1588_ptp_set_counter(int node, int counter, uint64_t cnt_val);
-extern int nlm_hal_is_intr_1588(int node);
-extern void nlm_hal_enable_1588_intr(int node,int mask);
-extern void nlm_hal_clear_1588_intr(int node, int timer);
-
-extern void nlm_hal_set_context_xon_xoff_threshold(int node, int mtu_len);
-
-enum NAE_REG_CMD {
-        CMD_READ = 0,
-        CMD_WRITE
-};
-
-enum if_link {
-       LINK_DOWN=0,
-       LINK_UP
-};
-
-enum if_speed {
-        SPEED_10M = 0,
-        SPEED_100M,
-        SPEED_1000M
-};
-
-
-/* NETWORK INF CTRL REG */
-#define SOFTRESET(x)                        ((x) << 11)
-#define STATS_EN(x)                         ((x) << 16)
-#define TX_EN(x)                            ((x) << 2)
-#define SPEED(x)                            ((x) & 0x3)
-
-/* MAC_CONF1 */
-#define INF_SOFTRESET(x)                    ((x) << 31)
-#define INF_LOOP_BACK(x)                    ((x) << 8)
-#define INF_RX_ENABLE(x)                    ((x) << 2)
-#define INF_TX_ENABLE(x)                    (0x1)
-
-/* MAC_CONF2 */
-#define INF_PREMBL_LEN(x)                   (((x) & 0xf) << 12)
-#define INF_IFMODE(x)                       (((x) & 0x3) << 8)
-#define INF_LENCHK(x)                       ((((x) & 0x1)) << 4)
-#define INF_PADCRCEN(x)                     (((x) & 0x1) << 2)
-#define INF_PADCRC(x)                       (((x) & 0x1) << 1)
-#define INF_FULLDUP(x)                      ((x) & 0x1)
-#define TXINITIORCR(x)                      ((x) & 0x7ffff) << 8
-
-#define NAE_RX_ENABLE 0x1
-#define NAE_TX_ENABLE 0x1
-#define NAE_TX_ACE 0x2
-#define NAE_TX_COMPATIBLE 0x4
-
-#define INF_BYTE_MODE   0x2
-#define INF_NIBBLE_MODE 0x1
-
-/* PHY Access routines
- * Internal MDIO: 0x799
- *    -- support clause 22
- *    -- support clause 45 with devType=0x5 only
- * External MDIO: EXT_G0:0x79D EXT_G1:0x7A1
- *    -- support clause 22 only
- *    -- used for 1GE interface
- * External MDIO: EXT_XG0:0x7A5 EXT_XG1:0x7A9
- *    -- support clause 22
- *    -- support clause 45 with devType as argument
- *    -- used for 10GE interface
- */
-enum {
-	NLM_HAL_INT_MDIO      = 0, /* Internal MDIO Clause 22 */
-	NLM_HAL_EXT_MDIO      = 1, /* EXT_G<0,1>: MDIO Clause 22 */
-	NLM_HAL_INT_MDIO_C45  = 2, /* Internal MDIO: Clause 45 */
-	NLM_HAL_EXT_MDIO_C45  = 3  /* EXT_XG<0,1>: External MDIO: Clause 45 */
-};
-
-/* MDIO reset/read/write
- * Note: block, intf_type are going to be removed.
- * block     = BLOCK_7  (NAE Block)
- * intf_type = LINE_CFG (0xF)
- */
-extern int nlm_hal_mdio_reset(int node, int type, int bus);
-extern int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val);
-extern int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx);
-extern int nlm_hal_mdio_read(int node, int type, int bus, int block, int intf_type, int phyaddr, int regidx);
-extern int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type, int phyaddr, int regidx, uint16_t val);
-
-
-/* External MDIO: C45 read/write */
-extern int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr,
-        int dev_addr, int regidx);
-extern int nlm_hal_xgmac_mdio_write(int node, int bus, int phyaddr,
-        int dev_addr, int regidx, uint16_t val);
-
-extern int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
-			int phyaddr, int dev_addr, uint32_t reg_addr, uint32_t write_data);
-extern int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
-			int phyaddr, int dev_addr, uint32_t reg_addr);
-
-#define NLM_C45_WRITE(node, bus, phyaddr, dev_addr, reg_addr, wdata)	\
-   nlm_hal_c45_mdio_indirect_write_external(node, bus, phyaddr, dev_addr, reg_addr, wdata)
-
-#define NLM_C45_READ(node, bus, phyaddr, dev_addr, reg_addr)	\
-   nlm_hal_c45_mdio_indirect_read_external(node, bus, phyaddr, dev_addr, reg_addr)
-
-extern int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
-extern void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
-
-/*  PCS initialization
- */
-extern void nlm_hal_mdio_init(int node);
-extern void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask);
-
-
-extern void nlm_hal_sgmii_phy_init(int node);
-
-extern int nlm_hal_init_nae(void *fdt, int dom_id);
-extern void nlm_hal_reset_nae_ownership(void *fdt, int dom_id);
-extern void reset_nae_mgmt(int node);
-extern int nlm_hal_nae_drain_frin_fifo_descs(int node, int inf);
-extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
-
-extern void nlm_hal_mac_disable(int node, int block, int intf_type);
-
-extern void nlm_hal_mac_enable(int node, int block, int intf_type);
-
-extern uint16_t nlm_hal_get_hwport(int node, uint32_t context);
-
-
-extern int nlm_hal_set_sgmii_framesize(int node, int block, int index, uint32_t size);
-
-extern int nlm_hal_set_ilk_framesize(int node, int block, int port, uint32_t size);
-extern int nlm_hal_set_xaui_framesize(int node, int block, uint32_t tx_size, uint32_t rx_size);
-#ifdef NLM_HAL_LINUX_KERNEL 
-extern int nlm_hal_get_ilk_mac_stats(int node, int block, int port, void *data);
-#endif
-
-extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
-extern void nlm_hal_msec_tx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
-extern void nlm_hal_msec_rx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
-extern void nlm_hal_msec_rx_mem_config(int node, int port, int index, uint64_t sci, unsigned char *key, uint64_t sci_mask);
-extern void nlm_hal_msec_rx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
-extern void nlm_hal_msec_tx_mem_config(int node, int context, int tci, uint64_t sci, unsigned char *key);
-extern void nlm_hal_msec_tx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
-extern int nlm_hal_retrieve_shared_freein_fifo_info(void *fdt, 
-		int shared_dom_id, int *owner_replenish, char **paddr_info, int *paddr_info_len,
-		char **desc_info, int *desc_info_len);
-extern unsigned int nlm_hal_retrieve_freein_fifo_mask(void *fdt, int node, int dom_id);
-#endif /*__ASSEMBLY__ */
-
-
-/* POE APIS */
-
-static inline void nlm_write_enqspill_threshold(int node, uint32_t threshold)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_ENQ_SPILL_THOLD, (threshold & 0xFF));
-}
-
-static inline void nlm_write_deqspill_threshold(int node, uint32_t threshold)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DEQ_SPILL_THOLD, (threshold & 0xFF));
-}
-
-static inline void nlm_write_deqspill_timer(int node, uint32_t timer)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DEQ_SPILL_TIMER, (timer & 0x3FF));
-}
-
-static inline void nlm_enable_distribution_class_drop(int node, uint32_t class_mask)
-{
-        uint32_t val = nlm_hal_read_poe_pcie_reg(node, POE_DISTR_CLASS_DROP_EN);
-        val |= (class_mask & 0xFF);
-        nlm_hal_write_poe_pcie_reg(node, POE_DISTR_CLASS_DROP_EN, val);
-}
-
-static inline void nlm_enable_distribution_vector_drop(int node, uint32_t vector_mask)
-{
-        uint32_t val = nlm_hal_read_poe_pcie_reg(node, POE_DISTR_VEC_DROP_EN);
-        val |= (vector_mask & 0xFFFF);
-        nlm_hal_write_poe_pcie_reg(node, POE_DISTR_VEC_DROP_EN, val);
-}
-
-static inline void nlm_disable_distribution_class_drop(int node, uint32_t class_mask)
-{
-        uint32_t val = nlm_hal_read_poe_pcie_reg(node, POE_DISTR_CLASS_DROP_EN);
-        val &= ~(class_mask & 0xFF);
-        nlm_hal_write_poe_pcie_reg(node, POE_DISTR_CLASS_DROP_EN, val);
-}
-
-static inline void nlm_disable_distribution_vector_drop(int node, uint32_t vector_mask)
-{
-        uint32_t val = nlm_hal_read_poe_pcie_reg(node, POE_DISTR_VEC_DROP_EN);
-        val &= ~(vector_mask & 0xFFFF);
-        nlm_hal_write_poe_pcie_reg(node, POE_DISTR_VEC_DROP_EN, val);
-}
-
-static inline void nlm_write_distvec_drop_timer(int node, uint32_t timer)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DISTRVEC_DROP_TIMER, (timer & 0xFFFF));
-}
-
-static inline void nlm_enable_distribution(int node)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DIST_ENABLE, 1);
-}
-
-static inline void nlm_disable_distribution(int node)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DIST_ENABLE, 0);
-}
-
-static inline void nlm_write_poe_dest_threshold(int node, uint32_t threshold)
-{
-        nlm_hal_write_poe_pcie_reg(node, POE_DEST_THRESHOLD, (threshold & 0xFFFF));
-}
-
-static inline void nlm_write_poe_distr_threshold(int node, uint32_t threshold0, uint32_t threshold1, uint32_t threshold2, uint32_t threshold3)
-{
-	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0, threshold0);
-	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0+1, threshold1);
-	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0+2, threshold2);
-	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0+3, threshold3);
-}
-
-static inline uint32_t nlm_hal_ptp_timer_hi(int node, int inf_num)
-{
-       return nlm_hal_read_nae_reg(node, IF_1588_TMSMP_HI+(2*inf_num));
-}
-
-static inline uint32_t nlm_hal_ptp_timer_lo(int node, int inf_num)
-{
-       return nlm_hal_read_nae_reg(node, IF_1588_TMSMP_LO+(2*inf_num));
-}
-
-
-extern uint32_t nlm_hal_get_rtc(int node, uint32_t* p_val_hi,  uint32_t* p_val_lo);
-
-#endif /*#ifndef _NLM_HAL_NAE_H_ */
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_nae.h b/arch/mips/netlogic/lib/syslib/include/nlm_nae.h
deleted file mode 100644
index 2b72153..0000000
--- a/arch/mips/netlogic/lib/syslib/include/nlm_nae.h
+++ /dev/null
@@ -1,225 +0,0 @@
-
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-
-#ifndef __NLM_NAE_H__
-#define __NLM_NAE_H__
-
-#ifndef __ASSEMBLY__
-#define MAX_NAE_CONTEXTS_PERNODE	524
-#define MAX_NAE_PORTS_PERNODE		18
-#define MAX_NAE_FREEIN_DESCS_QUEUE	18
-#define XLP_MAX_INTERLAKEN_IF		2
-
-#define NLM_MAX_NODES           4
-#define MAX_NAE_CPLX_PER_NODE   8
-
-#define FREEBACK_TO_NAE		0x01
-#define VFBID_FROM_FDT		0x02
-#define FREEIN_SPILL_DYNAMIC	0x04
-#define POE_ENQSPILL_DYNAMIC	0x08
-#define POE_DEQSPILL_DYNAMIC	0x10
-#define NAE_RESET_DONE		0x20
-#define NAE_INIT_VALID		0x40
-
-#ifndef NLM_NCPUS_PER_NODE
-#define NLM_NCPUS_PER_NODE	32
-#endif
-
-#define NLM_NAE_SH_LCPU_TO_MAP_SZ		6 /* in integers */
-#define NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ  	5 /* in bits, can cover 6 cpus in single entry */
-#define NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY 	6 /* with 5 bits, can occupy 6  */
-
-struct nlm_nae_shinfo {
-	int valid;
-	int rxvc;
-	int domid;
-	/* logical cpu to physical cpu map */
-	unsigned int lcpu_2_pcpu_map[NLM_NAE_SH_LCPU_TO_MAP_SZ]; 
-	/* cpu to freein fifo map */
-	unsigned int cpu_2_freeinfifo_map[NLM_NAE_SH_LCPU_TO_MAP_SZ];
-};
-
-enum higig_mode{
-	NO_HIGIG,
-	HIGIG,
-	HIGIG2
-};
-
-#ifndef NLM_NUM_THREADS_PER_CORE
-#define NLM_NUM_THREADS_PER_CORE	4
-#endif
-
-/* Only 3 domains can share one nae node including the owner */
-#define NLM_NAE_MAX_SHARED_DOMS		2
-
-#define NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE 20
-/* XAUI Card only support XAUI mode */
-#define NLM_NAE_XAUI_MODE_XAUI      0
-
-/* RXAUI Card support 3 different modes */
-#define NLM_NAE_RXAUI_MODE_XAUI     1
-#define NLM_NAE_RXAUI_MODE_BROADCOM 2
-#define NLM_NAE_RXAUI_MODE_MARVELL  3
-
-struct nlm_hal_nae_port {
-        int  valid;
-        int  mgmt;
-        int  num_free_desc;
-        int  txq;
-        int  rxq;
-        int  hw_port_id;
-        int  vlan_pri_en;
-        int  iftype;
-        int  num_channels;
-	uint32_t  rx_buf_size;
-	uint32_t  intf_fifo_size;
-	uint32_t  free_desc_size;
-	uint32_t  prsr_seq_fifo_size;
-	uint32_t  rx_slots_reqd;
-	uint32_t  tx_slots_reqd;
-	uint32_t  ucore_mask;
-        int  ext_phy_addr;
-        int  ext_phy_bus;
-	uint32_t  rxaui_scrambler; /* 0: disable scrambler ; 1: enable scrambler */
-	uint32_t  rxaui_mode;      /* 0: broadcom mode; 1: marvell */
-        int  loopback;
-};
-
-struct nlm_hal_nae_config {
-        int fb_vc;
-        int rx_vc;
-        int frin_queue_base;
-        int frin_total_queue;
-        int num_ports;
-	uint32_t flags;
-	int rx_cal_slots;
-	int tx_cal_slots;
-	/* onchip descs per queue: value is taken from array for all 
-	   queues upto 0-17 */
-	int freein_fifo_onchip_num_descs[MAX_NAE_FREEIN_DESCS_QUEUE];
-	/* spill descs per queue, it will be added with the onchip size  */
-	int freein_fifo_spill_num_descs; 
-	uint64_t freein_spill_base;
-	uint64_t freein_spill_size;
-	struct nlm_hal_nae_port ports[MAX_NAE_PORTS_PERNODE];
-	uint32_t cntx2port[MAX_NAE_CONTEXTS_PERNODE];
-	uint32_t num_lanes[XLP_MAX_INTERLAKEN_IF];
-	uint32_t lane_rate[XLP_MAX_INTERLAKEN_IF];
-	/*egress fifo  */
-	uint32_t stg2fifo_base;
-	uint32_t ehfifo_base;
-	uint32_t froutfifo_base;
-	uint32_t msfifo_base;
-	uint32_t pktfifo_base;
-	uint32_t pktlenfifo_base;
-	/* NAE complex map */
-	uint32_t sgmii_complex_map;
-	uint32_t xaui_complex_map;
-	uint32_t higig_mode[MAX_NAE_CPLX_PER_NODE];
-	uint32_t xgmii_speed[MAX_NAE_CPLX_PER_NODE];
-	uint32_t rxaui_complex_map;
-	uint32_t ilk_complex_map;
-	/* total queues used = num_contexts */
-	uint32_t num_contexts;
-
-	/* I am the owner or not, who initialize the node */
-	int owned;
-	/* Freein fifo mask. Out of the max rx fifos, domain ownership
-	of rx-fifos. */
-	uint32_t freein_fifo_dom_mask;
-
-	/* vfbtable id offset, software freeback and hardware freebaack */
-	uint32_t vfbtbl_sw_offset;
-	uint32_t vfbtbl_sw_nentries;
-	uint32_t vfbtbl_hw_offset;
-	uint32_t vfbtbl_hw_nentries;
-
-	/* port fifo mode enabled/disabled */
-	unsigned int port_fifo_en;
-	
-	struct nlm_nae_shinfo shinfo[NLM_NAE_MAX_SHARED_DOMS  + 1]; /* 1 extra for the owner */
-	uint32_t msec_port_enable;
-	unsigned char sectag_offset[MAX_NAE_PORTS_PERNODE];
-	unsigned char sectag_len[MAX_NAE_PORTS_PERNODE];
-	unsigned char icv_len[MAX_NAE_PORTS_PERNODE];
-};
-
-typedef struct nlm_hal_nae_config * nlm_nae_config_ptr;
-
-struct nlm_node_config
-{
-        int valid;
-        int num_nodes;  /* Number of nodes */
-        struct nlm_hal_nae_config *nae_cfg[NLM_MAX_NODES];      /* NAE configuration */
-        struct fmn_cfg *fmn_cfg[NLM_MAX_NODES];
-};
-
-enum freq_config {
-	NLM_DEFAULT	= 0,
-	NLM_NAE,
-	NLM_RSA,
-	NLM_SAE,
-	NLM_DTRE,
-	NLM_CDE,
-};
-
-extern struct nlm_node_config nlm_node_cfg;
-
-enum if_type {
-        UNKNOWN_IF    = 0,
-        SGMII_IF      = 1,
-        XAUI_IF       = 2,
-        INTERLAKEN_IF = 3,
-        RXAUI_IF      = 6,
-};
-
-extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
-extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
-extern uint32_t *cntx2port[];
-extern int nlm_hal_restart_ucore(int node, void *fdt);
-extern void nlm_hal_derive_cpu_to_freein_fifo_map(int node,
-                unsigned int phys_cpu_map,
-                unsigned int freein_fifo_mask, unsigned int *cpu_2_freein_fifo_map);
-extern void nlm_hal_modify_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
-		int off, int words);
-extern void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
-		int off, int words);
-
-extern void nlm_hal_disable_xaui_flow_control(int node, int block);
-
-#endif
-#endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_mdio.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_mdio.c
deleted file mode 100644
index f19256e..0000000
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal_mdio.c
+++ /dev/null
@@ -1,1037 +0,0 @@
-
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <linux/netdevice.h>
-#endif
-#include "nlm_hal_nae.h"
-#include "nlm_hal_sys.h"
-#include "libfdt.h"
-#include "fdt_helper.h"
-#include "nlm_evp_cpld.h"
-
-
-void nae_ext_mdio_wait(int n)
-{
-	volatile int s=0, i,j;
-	unsigned long long freq = nlm_hal_cpu_freq();
-	freq >>= 17;
-	if ( is_nlm_xlp3xx_ax() || is_nlm_xlp8xx_ax() || is_nlm_xlp8xx_b0() )
-	   return;
-	for(j=0; j<n; j++)
-	for(i=0; i<freq; i++) s++;
-	return;
-}
-
-/*
- * MDIO CLK = NAE Freq/(26*8*2)/64
- * MDIO CLK = 250MHz/(26*4*2)/64  when addDiv=7 & div=2 ==> 18.75KHz
- *------------------------------
- * EXT_G0_MDIO_CTRL[4:2]
- *------------------------------
- *  0 1
- *  1 1
- *  2 2
- *  3 3
- *  4 4
- *  5 6
- *  6 9
- *  7 26
- *------------------------------
- * EXT_G0_MDIO_CTRL[1:0]
- * 0 1
- * 1 2
- * 2 4
- * 3 8
- *------------------------------
- */
-/*0x1E: 0001 11,10  addDiv=7, div=2 ==> 18.75KHz if nae.ref=250Mhz */
-/*0x10: 0001 00,00  addDiv=4, div=0 ==> 0.5Mhz if nae.ref=250MHz */
-/*0x11: 0001 00,01  addDiv=4, div=1 ==> 0.5Mhz if nae.ref=500MHz */
-static uint32_t nae_get_EXT_G_MDIO_DIV(void)
-{
-	/*
-	 * MDIO CLK = 250MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 0.5MHz
-	 * MDIO CLK = 500MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 1.0MHz
-	 * XLP8XX_B1_EXT_G_MDIO_DIV:= b100,00 = 0x10
-	 */
-	return (
-	       is_nlm_xlp3xx_ax() ||
-	       is_nlm_xlp8xx_ax() ||
-	       is_nlm_xlp8xx_b0() ) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64_11;
-}
-
-/* INT_MDIO_CTRL, block7, 0x799
- * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
- * 29:28: MCDiv Master Clock Divider
- * 0 1
- * 1 2
- * 2 4
- * 3 8
- * 27:21: XDiv Clock Divisor
- *   M(mdc) = F(mstclk)/(2*(XDiv+1))
- *    500MHz/4 = 125MHz
- *    125MHz/(2*(0x7F+1)) = 0.5MHz
- *
- *    250MHz/4 = 62.5MHz
- *    62.5MHz/(2*(0x7F+1)) = 0.24MHz
- */
-
-static uint32_t nae_get_EXT_XG_MDIO_DIV(void)
-{
-	return ((0x7F << EXT_XG_MDIO_CTRL_XDIV_POS) | (2 << EXT_XG_MDIO_CTRL_MCDIV_POS));
-}
-
-/* INT_MDIO_CTRL, block7, 0x799
- * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
- * 29:28: MCDiv Master Clock Divider
- * 0 1
- * 1 2
- * 2 4
- * 3 8
- * 27:21: XDiv Clock Divisor
- *   M(mdc) = F(mstclk)/(2*(XDiv+1))
- *    500MHz/4 = 125MHz
- *    125MHz/(2*(0x7F+1)) = 0.5MHz
- *
- *    250MHz/4 = 62.5MHz
- *    62.5MHz/(2*(0x7F+1)) = 0.24MHz
- */
-static uint32_t nae_get_INT_MDIO_DIV(void)
-{
-	return ((0x7F << INT_MDIO_CTRL_XDIV_POS) | (2 << INT_MDIO_CTRL_MCDIV_POS));
-}
-
-#define PHY_STATUS_RETRIES 20000
-
-#define NUM_EGRESS_PORTS 18
-#define TX_IF_BURST_MAX  2048
-#define DRR_QUANTA       2048
-#define SP_EN            0
-#define SP_NUM           0
-
-
-
-#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  \
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
-		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG,	\
-			EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
-                        break;							\
-        }
-
-#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   \
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
-		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, \
-			INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY) == 0)        \
-                        break;                                                  \
-        }
-
-
-/*
- *      MDIO Support
- */
-/* Internal MDIO READ/WRITE Routines
- */
-/**
-* @brief nae_int_gmac_mdio_read function is used to read an SGMII PCS register.
-* 
-* @param [in] node Node number
-* @param [in] bus Internal MDIO bus number
-* @param [in] phyaddr Internal PHY's address
-* @param [in] regidx MDIO register index
-*
-* @return
-* 	- value of MDIO register
-* 
-* @ingroup hal_nae
-*
-*/
-static int nae_int_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
-
-	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
-		nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-				       (mdio_ld_cmd & ~INT_MDIO_CTRL_CMD_LOAD));
-	}
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (2 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (2 << INT_MDIO_CTRL_MIIM_POS)
-			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	/* Toggle Load Cmd Bit */
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (2 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (2 << INT_MDIO_CTRL_MIIM_POS)
-			       | (1 << INT_MDIO_CTRL_LOAD_POS) /* */
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	/* poll master busy bit until it is not busy
-	 */
-	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (2 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (2 << INT_MDIO_CTRL_MIIM_POS)
-			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	/* Read the data back
-	 */
-	return (nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_RD_STAT + bus * 4) & 0xffff);
-}
-
-/* Internal MDIO WRITE Routines
- */
-/**
-* @brief nae_int_gmac_mdio_write function is used to write an SGMII PCS register.
-*
-* @param [in] node Node number
-* @param [in] bus Internal MDIO bus number
-* @param [in] phyaddr Internal PHY's address
-* @param [in] regidx MDIO register index
-* @param [in] val Value to write
-*
-* @return
-* 	- 0 on success
-* 
-* @ingroup hal_nae
-*
-*/
-static int nae_int_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
-
-	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
-		nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-				       (mdio_ld_cmd & ~INT_MDIO_CTRL_CMD_LOAD));
-	}
-
-	/* load data into ctrl data reg
-	 */
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL_DATA + bus * 4, val);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (1 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (1 << INT_MDIO_CTRL_MIIM_POS)
-			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (1 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (1 << INT_MDIO_CTRL_MIIM_POS)
-			       | (1 << INT_MDIO_CTRL_LOAD_POS)
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	/* poll master busy bit until it is not busy
-	 */
-	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_SMP
-			       | (phyaddr << INT_MDIO_CTRL_PHYADDR_POS)
-			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
-			       | (1 << INT_MDIO_CTRL_OP_POS)
-			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
-			       | (2 << INT_MDIO_CTRL_TA_POS)
-			       | (1 << INT_MDIO_CTRL_MIIM_POS)
-			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	return 0;
-}
-
-/**
-* @brief internal_nae_gmac_mdio_reset function is used to reset an internal MDIO controller.
-*
-* @param [in] node Node number
-* @param [in] bus Internal MDIO bus number
-*
-* @return
-* 	- 0 on success
-* 
-* @ingroup hal_nae
-*
-*/
-static int internal_nae_gmac_mdio_reset(int node, int bus)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_RST | INT_MDIO_CTRL_SMP |
-			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
-			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-
-	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-				INT_MDIO_CTRL_SMP | /* supress pre-amble */
-			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
-			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
-	return 0;
-}
-
-/**********************************************************************
- *  nae_gmac_mdio_read - Read sgmii phy register
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external gmac bus: 0 and 1
- *         phyaddr      - PHY's address
- *         regidx       - index of register to read
- *
- *  Return value:
- *         value read (16 bits), or 0xffffffff if an error occurred.
- ********************************************************************* */
-/**
-* @brief nae_gmac_mdio_read function is used to read an SGMII PHY register.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] phyaddr External PHY's address
-* @param [in] regidx PHY register index to read
-*
-* @return
-*	- value read (16 bits), or 0xffffffff if an error occurred.
-* 
-* @ingroup hal_nae
-*
-*/
-static int nae_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
-
-	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
-		nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
-				       (mdio_ld_cmd & ~EXT_G_MDIO_CMD_LCD));
-		while(nlm_hal_read_mac_reg(node, block, intf_type,
-					    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
-	}
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_CMD_SP
-			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
-			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_CMD_SP
-			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
-			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (1<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	nae_ext_mdio_wait(1);
-
-	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_CMD_SP
-			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
-			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	/* Read the data back */
-	return (nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_RD_STAT + bus * 4) & 0xffff);
-}
-
-/**********************************************************************
- *  nae_gmac_mdio_write -Write sgmac mii PHY register.
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external gmac bus: 0 and 1
- *         phyaddr      - PHY to use
- *         regidx       - register within the PHY
- *         val          - data to write to register
- *
- *  Return value:
- *         0 - success
- ********************************************************************* */
-/**
-* @brief nae_gmac_mdio_write function is used to write an SGMII PHY register.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] phyaddr External PHY's address
-* @param [in] regidx PHY register index to read
-* @param [in] val Value to write
-*
-* @return
-* 	- 0 on success
-* 
-* @ingroup hal_nae
-*
-*/
-static int nae_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
-
-	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
-		nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
-				       (mdio_ld_cmd & ~EXT_G_MDIO_CMD_LCD));
-		while(nlm_hal_read_mac_reg(node, block, intf_type,
-					    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
-	}
-
-	/* load data into ctrl data reg
-	 */
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL_DATA + bus * 4, val);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
-			       EXT_G_MDIO_CMD_SP 	|
-			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
-			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
-			       EXT_G_MDIO_CMD_LCD | EXT_G_MDIO_CMD_SP 	|
-			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
-			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	nae_ext_mdio_wait(1);
-
-	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
-
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
-			       EXT_G_MDIO_CMD_SP 	|
-			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
-			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
-
-	return 0;
-}
-
-/**********************************************************************
- *  external_nae_gmac_mdio_reset -Reset sgmii mdio module.
- *
- *  Input parameters:
- *         bus - bus number, nae has two external gmac bus: 0 and 1
- *
- *  Return value:
- *        0 - success
- ********************************************************************* */
-/**
-* @brief external_nae_gmac_mdio_reset function is used to reset an external MDIO controller.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-*
-* @return
-* 	- 0 on success
-* 
-* @ingroup hal_nae
-*
-*/
-static int external_nae_gmac_mdio_reset(int node, int bus)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-	/*printf("INTF:%d EXT Gx MDIO DIV:%d\n", intf_type, nae_get_EXT_G_MDIO_DIV()); */
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_MMRST | nae_get_EXT_G_MDIO_DIV());
-	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       nae_get_EXT_G_MDIO_DIV());
-	return 0;
-}
-
-/**********************************************************************
- *  external_nae_xgmac_mdio_reset -Reset sgmii mdio module.
- *
- *  Input parameters:
- *         bus - bus number, nae has two external gmac bus: 0 and 1
- *
- *  Return value:
- *        0 - success
- ********************************************************************* */
-/**
-* @brief external_nae_xgmac_mdio_reset function is used to reset an external MDIO controller.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-*
-* @return
-* 	- 0 on success
-*
-* @ingroup hal_nae
-*
-*/
-static int external_nae_xgmac_mdio_reset(int node, int bus)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-				 nae_get_EXT_XG_MDIO_DIV()
-                                | EXT_XG_MDIO_CTRL_RST );
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-				 nae_get_EXT_XG_MDIO_DIV()
-                                );
-	return 0;
-}
-
-static int nlm_hal_xgmac_imdio_addr(int node, int phyaddr, int regidx)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t i;
-        /* internal xgmac pcs is always 5 */
-        /* phyadd 0x13,0x14, 0x15, 0x16 */
-        int dev_addr = 5;
-
-        /* load  XGMC_MDIO_CTRL_DATA register with addr */
-        nlm_hal_write_mac_reg( node, block, intf_type,
-                                INT_MDIO_CTRL_DATA, regidx);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | INT_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
-                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
-                                | 0x0 << INT_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node)
-        return 0;
-}
-
-static int nlm_hal_xgmac_imdio_write(int node, int phyaddr, int regidx, uint16_t val)
-{
-
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t  i;
-        /* internal xgmac pcs is always 5 */
-        /* phyadd 0x13,0x14, 0x15, 0x16 */
-        int dev_addr = 5;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
-
-        nlm_hal_write_mac_reg( node, block , intf_type,
-                                INT_MDIO_CTRL_DATA, val);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | INT_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
-                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_WRITE_10G_MMD << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
-                                | 0x0 << INT_MDIO_CTRL_TA_POS
-                                | 0 << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
-        return 0;
-
-}
-static int nlm_hal_xgmac_imdio_read(int node, int phyaddr, int regidx)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t  i;
-        int rdval;
-        /* internal xgmac pcs is always 5 */
-        /* phyadd 0x13,0x14, 0x15, 0x16 */
-        int dev_addr = 5;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | INT_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
-                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_READ_10G_MMD << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
-
-        rdval =  nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_RD_STAT) & 0xFFFF;
-
-        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
-				| nae_get_INT_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
-                                | 0x0 << INT_MDIO_CTRL_TA_POS
-                                | 0 << INT_MDIO_CTRL_OP_POS
-                                | INT_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
-
-        return rdval;
-
-}
-
-/**
-* @brief nlm_hal_mdio_read function is used to read a register through MDIO.
-*
-* @param [in] node Node number
-* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
-* @param [in] bus MDIO bus number
-* @param [in] [To be deleted] block NAE Register Memory Map Block
-* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
-* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
-* @param [in] regidx PHY register index to read
-*
-* @return
-*	- value read (16 bits), or 0xffffffff if an error occurred.
-*	- -1: Invalid type
-* 
-* @ingroup hal_nae
-*
-*/
-int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val);
-int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx);
-
-int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx)
-{
-	if (type == NLM_HAL_INT_MDIO) {
-		/* INT_MDIO_CTRL: 0x799 */
-		return nae_int_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
-	} else if (type == NLM_HAL_INT_MDIO_C45) {
-		/* INT_MDIO_CTRL: 0x799 */
-		return nlm_hal_xgmac_imdio_read(node, phyaddr&0x1F, regidx);
-	} else if (type == NLM_HAL_EXT_MDIO) {
-	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
-		return nae_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
-	} else if (type == NLM_HAL_EXT_MDIO_C45) {
-	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
-		return nlm_hal_xgmac_mdio_read(node, bus,
-						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx);
-	} else {
-		nlm_print("NAE_ERROR: Invalid type for MDIO read !!\n");
-		return -1;
-	}
-}
-int nlm_hal_mdio_read(int node, int type, int bus, int block, int intf_type,
-		      int phyaddr, int regidx)
-{
-	return nlm_hal_mdio_rd(node, type, bus, phyaddr, regidx);
-}
-
-/**
-* @brief nlm_hal_mdio_write function is used to write a register through MDIO.
-*
-* @param [in] node Node number
-* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
-* @param [in] bus MDIO bus number
-* @param [in] [To be deleted] block NAE Register Memory Map Block
-* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
-* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
-* @param [in] regidx PHY register index to read
-* @param [in] val Value to write
-*
-* @return
-*	- 0 on success
-*	- -1: Invalid type
-* 
-* @ingroup hal_nae
-*
-*/
-int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val)
-{
-	if (type == NLM_HAL_INT_MDIO) {
-		/* INT_MDIO_CTRL: 0x799 */
-		return nae_int_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
-	} else if (type == NLM_HAL_INT_MDIO_C45) {
-		/* INT_MDIO_CTRL: 0x799 */
-		return nlm_hal_xgmac_imdio_write(node, phyaddr&0x1F, regidx, val);
-	} else if (type == NLM_HAL_EXT_MDIO) {
-	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
-		return nae_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
-	} else if (type == NLM_HAL_EXT_MDIO_C45) {
-	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
-		return nlm_hal_xgmac_mdio_write(node, bus,
-						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx, val);
-	} else {
-		nlm_print("NAE_ERROR: Invalid type for MDIO write !!\n");
-		return -1;
-	}
-}
-int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
-		       int phyaddr, int regidx, uint16_t val)
-{
-	return nlm_hal_mdio_wr(node, type, bus, phyaddr, regidx, val);
-}
-
-/**
-* @brief nlm_hal_mdio_reset function is used to reset an MDIO controller.
-*
-* @param [in] node Node number
-* @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
-* @param [in] bus MDIO bus number
-*
-* @return
-*	- 0 on success
-*	- -1: Invalid type
-* 
-* @ingroup hal_nae
-*
-*/
-int nlm_hal_mdio_reset(int node, int type, int bus)
-{
-	if ((type == NLM_HAL_INT_MDIO) || (type == NLM_HAL_INT_MDIO_C45)) {
-		return internal_nae_gmac_mdio_reset(node, bus);
-	} else if (type == NLM_HAL_EXT_MDIO) {
-		return external_nae_gmac_mdio_reset(node, bus);
-	} else if (type == NLM_HAL_EXT_MDIO_C45) {
-		return external_nae_xgmac_mdio_reset(node, bus);
-	} else {
-		nlm_print("NAE_ERROR: Invalid type for MDIO reset !!\n");
-		return -1;
-	}
-}
-
-
-
-
-/**
-* @brief nlm_hal_init_poe_ext_storage function is used to initialize the POE memory spaces for message and FreeBuffer storage.
-*
-* @param [in] node Node number
-* @param [in] fbp_base_phys Physical address of the start of FreeBuffer storage in DRAM
-* @param [in] fbp_base_virt Virtual address of the start of FreeBuffer storage in DRAM
-* @param [in] msg_base_phys Physical address of the start of message storage in DRAM
-* @param [in] msg_base_virt Virtual address of the start of message storage in DRAM
-*
-* @return
-* 	- none
-* 
-* @ingroup hal_nae
-*
-*/
-void nlm_hal_init_poe_ext_storage(int node,
-				  uint64_t fbp_base_phys,
-				  uint64_t fbp_base_virt,
-				  uint64_t msg_base_phys,
-	                          uint64_t msg_base_virt)
-{
-	uint32_t addr, num_messages;
-	uint64_t ldata, a, mdata;
-	uint64_t *vaddr_fbp, *vaddr_msg;
-	int i;
-	uint32_t mbase_hi, mbase_lo, fbp_hi, fbp_lo, fbp_sp_init;
-	mbase_hi = (msg_base_phys >> 32) & 0xffffffff;
-	mbase_lo = msg_base_phys & 0xffffffff;
-	fbp_hi = (fbp_base_phys >> 32) & 0xffffffff;
-	fbp_lo = fbp_base_phys & 0xffffffff;
-
-	/* POE External Message Storage (upto 58K) */
-
-	nlm_print("POE ext msg storage: \n");
-	nlm_print("msg base: 0x%x%x\n", mbase_hi, mbase_lo);
-	nlm_print("fbp base: 0x%x%x\n", fbp_hi, fbp_lo);
-
-	/* Free Buffer Pool config */
-	nlm_print (" POE Free Buffer Pool config ...\n");
-
-	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
-		a = (uint64_t)XLP3XX_EXT_FBP_START_ADDR;
-		num_messages = XLP3XX_MAX_POE_EXT_MSG_STORAGE;
-		fbp_sp_init = XLP3XX_POE_FBP_SP_INIT;
-	}
-	else {
-		a = (uint64_t)EXT_FBP_START_ADDR;
-		num_messages = MAX_POE_EXT_MSG_STORAGE;
-		fbp_sp_init = POE_FBP_SP_INIT;
-	}
-
-	vaddr_fbp = (uint64_t *)(uintptr_t) fbp_base_virt;
-	vaddr_msg = (uint64_t *)(uintptr_t) msg_base_virt;
-	mdata = 0ULL;
-
-	/* initialize free buffer pool with 16-bit storage indexes */
-	for (i = 0; i < (num_messages / 4); i++) {
-		ldata = ((a+3) << 48) | ((a+2) << 32) | ((a+1) << 16) | a;
-		*vaddr_fbp = ldata;
-		vaddr_fbp++;
-		a += 4;
-	}
-
-	/* initialize storage memory area with zero */
-	for (i = 0; i < (num_messages * 8); i++) {
-		*vaddr_msg = mdata;
-		vaddr_msg++;
-	}
-
-	/* Configuring Message base pointer */
-	addr = MSG_STORAGE_BASE_ADR_L;
-	nlm_print ("POE Configuring Message base pointer ...\n");
-	nlm_hal_write_poe_pcie_reg(node, addr, mbase_lo);
-	addr++;
-	nlm_hal_write_poe_pcie_reg(node, addr, mbase_hi);
-
-	/* Configuring FBP base pointer */
-	addr = FBP_BASE_ADR_L;
-	nlm_print ("POE Configuring FBP base pointer ...\n");
-	nlm_hal_write_poe_pcie_reg(node, addr, fbp_lo);
-	addr++;
-	nlm_hal_write_poe_pcie_reg(node, addr, fbp_hi);
-
-	/* Configuring FBP SP */
-	addr = POE_FBP_SP;
-	nlm_print ("POE Configuring FBP stack pointer ...\n");
-	nlm_hal_write_poe_pcie_reg(node, addr, fbp_sp_init);
-}
-
-
-/*
- *  Interface support
- */
-
-#define PHY_STATUS_RETRIES 20000
-
-#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  \
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
-		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG,	\
-			EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
-                        break;							\
-        }
-
-#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   \
-	for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
-		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, \
-			INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY) == 0)        \
-                        break;                                                  \
-        }
-
-/*
- *                   XAUI Support
- *
- */
-int nlm_hal_xgmac_mdio_write(int node, int bus,
-	int phyaddr, int dev_addr, int regidx, uint16_t val)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t  i;
-	uint32_t ctrl =   (phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS)
-			| (dev_addr << EXT_XG_MDIO_CTRL_REG_POS)
-			| (regidx << EXT_XG_MDIO_CTRL_OP_POS)
-			/* load = 0 */
-			| nae_get_EXT_XG_MDIO_DIV()
-			| (EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS)
-			| (MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS);
-
-	/*nlm_print("xw: bus:%d phy:%d d:%d %x.%x=%x\n", bus, phyaddr, dev_addr, ctrl, regidx, val); */
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL_DATA + (bus * 4), val);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl|EXT_XG_MDIO_CTRL_CMD_LOAD);
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        return 0;
-}
-
-int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr, int dev_addr, int regidx)
-{
-	int rdval;
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, regidx);
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_READ_10G_MMD, regidx);
-        rdval =  nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT + (bus * 4)) & 0xFFFF;
-        return rdval;
-}
-
-int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
-	int phyaddr, int dev_addr, uint32_t reg_addr, uint32_t write_data)
-{
-	write_data &= 0xFFFF;
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_WRITE_10G_MMD, write_data);
-	/*nlm_print("C45 MDIO w phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, write_data); */
-	return 0;
-}
-
-int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
-	int phyaddr, int dev_addr, uint32_t reg_addr)
-{
-	int rdval = nlm_hal_xgmac_mdio_read(node, bus, phyaddr, dev_addr, reg_addr);
-	/*nlm_print("C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval); */
-	return rdval;
-}
-
-
-#ifdef CONFIG_N511
-
-/* call for phy/ports 0 - 3 */
-void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val)
-{
-  int bus = 0;
-  if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
-    nlm_hal_xgmac_imdio_write(0, phyaddr, regidx, val);
-    return;
-  } else if (phyaddr > 1) {
-    bus = 1;
-  }
-  nlm_hal_c45_mdio_indirect_write_external(0, bus, phyaddr, devaddr, regidx, val);
-  return;
-}
-
-uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
-{
-  int bus = 0;
-  uint16_t val = 0;
-
-  if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
-    val = nlm_hal_xgmac_imdio_read(0, phyaddr, regidx);
-    nlm_print("nlm_xaui_phy_read PCS phy with internal mdio = 0x%x\n", val);
-    return val;
-  } else if (phyaddr > 1) {
-    bus = 1;
-  }
-  val = nlm_hal_c45_mdio_indirect_read_external (0, bus, phyaddr, devaddr, regidx);
-  return val;
-}
-
-#include "nlm_10ge_phy_nlp1042.h"
-
-/* MPS add, scan 10ge Phys */
-void nlm_xaui_phy_scan(void)
-{
-  int bus, phyaddr, devid;
-  nlm_print("nlm_xaui_phy_scan, xlp_mac_base = 0x%llux\n", (unsigned long long)xlp_mac_base);
-  bus=0;
-  for (phyaddr=0; phyaddr<2; phyaddr++) {
-    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
-    nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
-    nlm_nlp1042_init(phyaddr);
-  }
-  bus=1;
-  for (phyaddr=2; phyaddr<4; phyaddr++) {
-    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
-    nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
-    nlm_nlp1042_init(phyaddr);
-  }
-}
-
-#endif /* CONFIG_N511 */
-
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <linux/types.h>
-#include <linux/module.h>
-EXPORT_SYMBOL(nlm_hal_mdio_reset);
-EXPORT_SYMBOL(nlm_hal_mdio_read);
-EXPORT_SYMBOL(nlm_hal_mdio_write);
-EXPORT_SYMBOL(nlm_hal_mdio_rd);
-EXPORT_SYMBOL(nlm_hal_mdio_wr);
-EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_read_external);
-EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_write_external);
-#endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal_vsemi_config.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal_vsemi_config.c
deleted file mode 100644
index 892b3bc..0000000
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal_vsemi_config.c
+++ /dev/null
@@ -1,758 +0,0 @@
-/*-
- * Copyright (c) 2003-2012 Broadcom Corporation
- * All Rights Reserved
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt
- * or the Broadcom license below:
-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_4# */
-#include "nlm_hal_vsemi_data.h"
-
-unsigned char vsemi_mem_sgmii_4page [256];
-unsigned char vsemi_mem_sgmii [256];
-
-unsigned char vsemi_mem_xaui_4page [256];
-unsigned char vsemi_mem_xaui [256];
-
-unsigned char vsemi_mem_12G_4page [256];
-unsigned char vsemi_mem_12G [256];
-unsigned char vsemi_mem_16G_4page [256];
-unsigned char vsemi_mem_16G [256];
-
-void nlm_hal_config_vsemi_mem_16G_4page(void)
-{
-
-	vsemi_mem_16G_4page[101] = 0xB7;
-	vsemi_mem_16G_4page[102] = 0xB7;
-	vsemi_mem_16G_4page[103] = 0xC;
-	vsemi_mem_16G_4page[104] = 0xC;
-	vsemi_mem_16G_4page[105] = 0x1A;
-	vsemi_mem_16G_4page[106] = 0x1A;
-	vsemi_mem_16G_4page[107] = 0x2;
-	vsemi_mem_16G_4page[108] = 0x2;
-	vsemi_mem_16G_4page[109] = 0x11;
-	vsemi_mem_16G_4page[110] = 0x0;
-	
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_16G_4page_125(void)
-{
-	vsemi_mem_16G_4page[101] = 0xBF;
-	vsemi_mem_16G_4page[102] = 0xBF;
-	vsemi_mem_16G_4page[103] = 0xA;
-	vsemi_mem_16G_4page[104] = 0xA;
-	vsemi_mem_16G_4page[105] = 0xE;
-	vsemi_mem_16G_4page[106] = 0xE;
-	vsemi_mem_16G_4page[107] = 0x1;
-	vsemi_mem_16G_4page[108] = 0x1;
-	vsemi_mem_16G_4page[109] = 0x11;
-	vsemi_mem_16G_4page[110] = 0x0;
-
-	return;
-}
-
-
-void nlm_hal_config_vsemi_mem_16G(void)
-{
-	
-	vsemi_mem_16G[101] = 0x99;
-	vsemi_mem_16G[102] = 0x0;
-	vsemi_mem_16G[103] = 0x76;
-	vsemi_mem_16G[104] = 0xB7;
-	vsemi_mem_16G[105] = 0xB7;
-	vsemi_mem_16G[106] = 0xC;
-	vsemi_mem_16G[107] = 0xC;
-	vsemi_mem_16G[108] = 0x1A;
-	vsemi_mem_16G[109] = 0x1A;
-	vsemi_mem_16G[110] = 0x6;
-	vsemi_mem_16G[111] = 0x16;
-	vsemi_mem_16G[112] = 0x8;
-	vsemi_mem_16G[113] = 0x0;
-	vsemi_mem_16G[114] = 0x8;
-	vsemi_mem_16G[115] = 0x0;
-	vsemi_mem_16G[116] = 0xFF;
-	vsemi_mem_16G[117] = 0xB3;
-	vsemi_mem_16G[118] = 0xF6;
-	vsemi_mem_16G[119] = 0xD0;
-	vsemi_mem_16G[120] = 0xEF;
-	vsemi_mem_16G[121] = 0xFB;
-	vsemi_mem_16G[122] = 0xFF;
-	vsemi_mem_16G[123] = 0xFF;
-	vsemi_mem_16G[124] = 0xFF;
-	vsemi_mem_16G[125] = 0xFF;
-	vsemi_mem_16G[126] = 0xFF;
-	vsemi_mem_16G[127] = 0xD3;
-	vsemi_mem_16G[128] = 0xD3;
-	vsemi_mem_16G[129] = 0xE2;
-	vsemi_mem_16G[130] = 0xEF;
-	vsemi_mem_16G[131] = 0xFB;
-	vsemi_mem_16G[132] = 0xFB;
-	vsemi_mem_16G[133] = 0xFF;
-	vsemi_mem_16G[134] = 0xEF;
-	vsemi_mem_16G[135] = 0xFF;
-	vsemi_mem_16G[136] = 0xFF;
-	vsemi_mem_16G[137] = 0xD3;
-	vsemi_mem_16G[138] = 0xD3;
-	vsemi_mem_16G[139] = 0xE2;
-	vsemi_mem_16G[140] = 0xEF;
-	vsemi_mem_16G[141] = 0xFB;
-	vsemi_mem_16G[142] = 0xFB;
-	vsemi_mem_16G[143] = 0xFF;
-	vsemi_mem_16G[144] = 0xEF;
-	vsemi_mem_16G[145] = 0xFF;
-	vsemi_mem_16G[146] = 0xFF;
-	vsemi_mem_16G[147] = 0xFB;
-	vsemi_mem_16G[148] = 0xFF;
-	vsemi_mem_16G[149] = 0x3F;
-	vsemi_mem_16G[150] = 0x0;
-	vsemi_mem_16G[151] = 0x64;
-	vsemi_mem_16G[152] = 0x0;
-	vsemi_mem_16G[153] = 0x4;
-	vsemi_mem_16G[154] = 0x2;
-	vsemi_mem_16G[155] = 0x5;
-	vsemi_mem_16G[156] = 0x5;
-	vsemi_mem_16G[157] = 0x4;
-	vsemi_mem_16G[158] = 0x0;
-	vsemi_mem_16G[159] = 0x0;
-	vsemi_mem_16G[160] = 0x8;
-	vsemi_mem_16G[161] = 0x4;
-	vsemi_mem_16G[162] = 0x0;
-	vsemi_mem_16G[163] = 0x0;
-	vsemi_mem_16G[164] = 0x4;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_16G_125(void)
-{
-
-	vsemi_mem_16G[101] = 0xAA;
-	vsemi_mem_16G[102] = 0x0;
-	vsemi_mem_16G[103] = 0x57;
-	vsemi_mem_16G[104] = 0xBF;
-	vsemi_mem_16G[105] = 0xBF;
-	vsemi_mem_16G[106] = 0xA;
-	vsemi_mem_16G[107] = 0xA;
-	vsemi_mem_16G[108] = 0xE;
-	vsemi_mem_16G[109] = 0xE;
-	vsemi_mem_16G[110] = 0x4;
-	vsemi_mem_16G[111] = 0x17;
-	vsemi_mem_16G[112] = 0x10;
-	vsemi_mem_16G[113] = 0x0;
-	vsemi_mem_16G[114] = 0x10;
-	vsemi_mem_16G[115] = 0x0;
-	vsemi_mem_16G[116] = 0xFF;
-	vsemi_mem_16G[117] = 0xC3;
-	vsemi_mem_16G[118] = 0xF5;
-	vsemi_mem_16G[119] = 0xD9;
-	vsemi_mem_16G[120] = 0xF2;
-	vsemi_mem_16G[121] = 0xFC;
-	vsemi_mem_16G[122] = 0xFE;
-	vsemi_mem_16G[123] = 0xFF;
-	vsemi_mem_16G[124] = 0xFF;
-	vsemi_mem_16G[125] = 0xFF;
-	vsemi_mem_16G[126] = 0xFF;
-	vsemi_mem_16G[127] = 0xDB;
-	vsemi_mem_16G[128] = 0xE9;
-	vsemi_mem_16G[129] = 0xC2;
-	vsemi_mem_16G[130] = 0xF2;
-	vsemi_mem_16G[131] = 0xFC;
-	vsemi_mem_16G[132] = 0xFE;
-	vsemi_mem_16G[133] = 0xF2;
-	vsemi_mem_16G[134] = 0xF2;
-	vsemi_mem_16G[135] = 0xFF;
-	vsemi_mem_16G[136] = 0xFF;
-	vsemi_mem_16G[137] = 0xDB;
-	vsemi_mem_16G[138] = 0xE9;
-	vsemi_mem_16G[139] = 0xC2;
-	vsemi_mem_16G[140] = 0xF2;
-	vsemi_mem_16G[141] = 0xFC;
-	vsemi_mem_16G[142] = 0xFE;
-	vsemi_mem_16G[143] = 0xF2;
-	vsemi_mem_16G[144] = 0xF2;
-	vsemi_mem_16G[145] = 0xFF;
-	vsemi_mem_16G[146] = 0xFF;
-	vsemi_mem_16G[147] = 0xFF;
-	vsemi_mem_16G[148] = 0xF2;
-	vsemi_mem_16G[149] = 0x3F;
-	vsemi_mem_16G[150] = 0x0;
-	vsemi_mem_16G[151] = 0x64;
-	vsemi_mem_16G[152] = 0x0;
-	vsemi_mem_16G[153] = 0x2;
-	vsemi_mem_16G[154] = 0x1;
-	vsemi_mem_16G[155] = 0x5;
-	vsemi_mem_16G[156] = 0x5;
-	vsemi_mem_16G[157] = 0x4;
-	vsemi_mem_16G[158] = 0x0;
-	vsemi_mem_16G[159] = 0x0;
-	vsemi_mem_16G[160] = 0x8;
-	vsemi_mem_16G[161] = 0x4;
-	vsemi_mem_16G[162] = 0x0;
-	vsemi_mem_16G[163] = 0x0;
-	vsemi_mem_16G[164] = 0x4;
-
-}
-
-void nlm_hal_config_vsemi_mem_12G_4page(void)
-{
-	vsemi_mem_12G_4page[101] = 0xC3;
-	vsemi_mem_12G_4page[102] = 0xC3;
-	vsemi_mem_12G_4page[103] = 0x11;
-	vsemi_mem_12G_4page[104] = 0x11;
-	vsemi_mem_12G_4page[105] = 0x12;
-	vsemi_mem_12G_4page[106] = 0x12;
-	vsemi_mem_12G_4page[107] = 0x2;
-	vsemi_mem_12G_4page[108] = 0x2;
-	vsemi_mem_12G_4page[109] = 0x0;
-	vsemi_mem_12G_4page[110] = 0x0;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_12G_4page_125(void)
-{
-	vsemi_mem_12G_4page[101] = 0xBA;
-	vsemi_mem_12G_4page[102] = 0xBA;
-	vsemi_mem_12G_4page[103] = 0xD;
-	vsemi_mem_12G_4page[104] = 0xD;
-	vsemi_mem_12G_4page[105] = 0x18;
-	vsemi_mem_12G_4page[106] = 0x18;
-	vsemi_mem_12G_4page[107] = 0x2;
-	vsemi_mem_12G_4page[108] = 0x2;
-	vsemi_mem_12G_4page[109] = 0x0;
-	vsemi_mem_12G_4page[110] = 0x0;
-	
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_12G(void)
-{
-	vsemi_mem_12G[101] = 0x99;
-	vsemi_mem_12G[102] = 0x0;
-	vsemi_mem_12G[103] = 0x76;
-	vsemi_mem_12G[104] = 0xC3;
-	vsemi_mem_12G[105] = 0xC3;
-	vsemi_mem_12G[106] = 0x11;
-	vsemi_mem_12G[107] = 0x11;
-	vsemi_mem_12G[108] = 0x12;
-	vsemi_mem_12G[109] = 0x12;
-	vsemi_mem_12G[110] = 0x6;
-	vsemi_mem_12G[111] = 0x16;
-	vsemi_mem_12G[112] = 0x8;
-	vsemi_mem_12G[113] = 0x0;
-	vsemi_mem_12G[114] = 0x8;
-	vsemi_mem_12G[115] = 0x0;
-	vsemi_mem_12G[116] = 0xFF;
-	vsemi_mem_12G[117] = 0xB3;
-	vsemi_mem_12G[118] = 0xF6;
-	vsemi_mem_12G[119] = 0xD0;
-	vsemi_mem_12G[120] = 0xEF;
-	vsemi_mem_12G[121] = 0xFB;
-	vsemi_mem_12G[122] = 0xFF;
-	vsemi_mem_12G[123] = 0xFF;
-	vsemi_mem_12G[124] = 0xFF;
-	vsemi_mem_12G[125] = 0xFF;
-	vsemi_mem_12G[126] = 0xFF;
-	vsemi_mem_12G[127] = 0xD3;
-	vsemi_mem_12G[128] = 0xD3;
-	vsemi_mem_12G[129] = 0xE2;
-	vsemi_mem_12G[130] = 0xEF;
-	vsemi_mem_12G[131] = 0xFB;
-	vsemi_mem_12G[132] = 0xFB;
-	vsemi_mem_12G[133] = 0xFF;
-	vsemi_mem_12G[134] = 0xEF;
-	vsemi_mem_12G[135] = 0xFF;
-	vsemi_mem_12G[136] = 0xFF;
-	vsemi_mem_12G[137] = 0xD3;
-	vsemi_mem_12G[138] = 0xD3;
-	vsemi_mem_12G[139] = 0xE2;
-	vsemi_mem_12G[140] = 0xEF;
-	vsemi_mem_12G[141] = 0xFB;
-	vsemi_mem_12G[142] = 0xFB;
-	vsemi_mem_12G[143] = 0xFF;
-	vsemi_mem_12G[144] = 0xEF;
-	vsemi_mem_12G[145] = 0xFF;
-	vsemi_mem_12G[146] = 0xFF;
-	vsemi_mem_12G[147] = 0xFB;
-	vsemi_mem_12G[148] = 0xFF;
-	vsemi_mem_12G[149] = 0x3F;
-	vsemi_mem_12G[150] = 0x0;
-	vsemi_mem_12G[151] = 0x64;
-	vsemi_mem_12G[152] = 0x0;
-	vsemi_mem_12G[153] = 0x4;
-	vsemi_mem_12G[154] = 0x2;
-	vsemi_mem_12G[155] = 0xA;
-	vsemi_mem_12G[156] = 0x5;
-	vsemi_mem_12G[157] = 0x4;
-	vsemi_mem_12G[158] = 0x0;
-	vsemi_mem_12G[159] = 0x0;
-	vsemi_mem_12G[160] = 0x8;
-	vsemi_mem_12G[161] = 0x4;
-	vsemi_mem_12G[162] = 0x0;
-	vsemi_mem_12G[163] = 0x0;
-	vsemi_mem_12G[164] = 0x4;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_12G_125(void)
-{
-	vsemi_mem_12G[101] = 0x99;
-	vsemi_mem_12G[102] = 0x0;
-	vsemi_mem_12G[103] = 0x57;
-	vsemi_mem_12G[104] = 0xBA;
-	vsemi_mem_12G[105] = 0xBA;
-	vsemi_mem_12G[106] = 0xD;
-	vsemi_mem_12G[107] = 0xD;
-	vsemi_mem_12G[108] = 0x18;
-	vsemi_mem_12G[109] = 0x18;
-	vsemi_mem_12G[110] = 0x4;
-	vsemi_mem_12G[111] = 0x17;
-	vsemi_mem_12G[112] = 0x8;
-	vsemi_mem_12G[113] = 0x0;
-	vsemi_mem_12G[114] = 0x8;
-	vsemi_mem_12G[115] = 0x0;
-	vsemi_mem_12G[116] = 0xFF;
-	vsemi_mem_12G[117] = 0xC3;
-	vsemi_mem_12G[118] = 0xF5;
-	vsemi_mem_12G[119] = 0xD9;
-	vsemi_mem_12G[120] = 0xF2;
-	vsemi_mem_12G[121] = 0xFC;
-	vsemi_mem_12G[122] = 0xFE;
-	vsemi_mem_12G[123] = 0xFF;
-	vsemi_mem_12G[124] = 0xFF;
-	vsemi_mem_12G[125] = 0xFF;
-	vsemi_mem_12G[126] = 0xFF;
-	vsemi_mem_12G[127] = 0xDB;
-	vsemi_mem_12G[128] = 0xE9;
-	vsemi_mem_12G[129] = 0xC2;
-	vsemi_mem_12G[130] = 0xF2;
-	vsemi_mem_12G[131] = 0xFC;
-	vsemi_mem_12G[132] = 0xFE;
-	vsemi_mem_12G[133] = 0xF2;
-	vsemi_mem_12G[134] = 0xF2;
-	vsemi_mem_12G[135] = 0xFF;
-	vsemi_mem_12G[136] = 0xFF;
-	vsemi_mem_12G[137] = 0xDB;
-	vsemi_mem_12G[138] = 0xE9;
-	vsemi_mem_12G[139] = 0xC2;
-	vsemi_mem_12G[140] = 0xF2;
-	vsemi_mem_12G[141] = 0xFC;
-	vsemi_mem_12G[142] = 0xFE;
-	vsemi_mem_12G[143] = 0xF2;
-	vsemi_mem_12G[144] = 0xF2;
-	vsemi_mem_12G[145] = 0xFF;
-	vsemi_mem_12G[146] = 0xFF;
-	vsemi_mem_12G[147] = 0xFF;
-	vsemi_mem_12G[148] = 0xF2;
-	vsemi_mem_12G[149] = 0x3F;
-	vsemi_mem_12G[150] = 0x0;
-	vsemi_mem_12G[151] = 0x64;
-	vsemi_mem_12G[152] = 0x0;
-	vsemi_mem_12G[153] = 0x4;
-	vsemi_mem_12G[154] = 0x2;
-	vsemi_mem_12G[155] = 0xA;
-	vsemi_mem_12G[156] = 0x5;
-	vsemi_mem_12G[157] = 0x4;
-	vsemi_mem_12G[158] = 0x0;
-	vsemi_mem_12G[159] = 0x0;
-	vsemi_mem_12G[160] = 0x8;
-	vsemi_mem_12G[161] = 0x4;
-	vsemi_mem_12G[162] = 0x0;
-	vsemi_mem_12G[163] = 0x0;
-	vsemi_mem_12G[164] = 0x4;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_xaui(void)
-{
-	vsemi_mem_xaui[101] = 0xAA;
-	vsemi_mem_xaui[102] = 0x0;
-	vsemi_mem_xaui[103] = 0x76;
-	vsemi_mem_xaui[104] = 0xBF;
-	vsemi_mem_xaui[105] = 0xBF;
-	vsemi_mem_xaui[106] = 0xA;
-	vsemi_mem_xaui[107] = 0xA;
-	vsemi_mem_xaui[108] = 0xE;
-	vsemi_mem_xaui[109] = 0xE;
-	vsemi_mem_xaui[110] = 0x6;
-	vsemi_mem_xaui[111] = 0x16;
-	vsemi_mem_xaui[112] = 0x10;
-	vsemi_mem_xaui[113] = 0x0;
-	vsemi_mem_xaui[114] = 0x10;
-	vsemi_mem_xaui[115] = 0x0;
-	vsemi_mem_xaui[116] = 0xFF;
-	vsemi_mem_xaui[117] = 0xB3;
-	vsemi_mem_xaui[118] = 0xF6;
-	vsemi_mem_xaui[119] = 0xD0;
-	vsemi_mem_xaui[120] = 0xEF;
-	vsemi_mem_xaui[121] = 0xFB;
-	vsemi_mem_xaui[122] = 0xFF;
-	vsemi_mem_xaui[123] = 0xFF;
-	vsemi_mem_xaui[124] = 0xFF;
-	vsemi_mem_xaui[125] = 0xFF;
-	vsemi_mem_xaui[126] = 0xFF;
-	vsemi_mem_xaui[127] = 0xD3;
-	vsemi_mem_xaui[128] = 0xD3;
-	vsemi_mem_xaui[129] = 0xE2;
-	vsemi_mem_xaui[130] = 0xEF;
-	vsemi_mem_xaui[131] = 0xFB;
-	vsemi_mem_xaui[132] = 0xFB;
-	vsemi_mem_xaui[133] = 0xFF;
-	vsemi_mem_xaui[134] = 0xEF;
-	vsemi_mem_xaui[135] = 0xFF;
-	vsemi_mem_xaui[136] = 0xFF;
-	vsemi_mem_xaui[137] = 0xD3;
-	vsemi_mem_xaui[138] = 0xD3;
-	vsemi_mem_xaui[139] = 0xE2;
-	vsemi_mem_xaui[140] = 0xEF;
-	vsemi_mem_xaui[141] = 0xFB;
-	vsemi_mem_xaui[142] = 0xFB;
-	vsemi_mem_xaui[143] = 0xFF;
-	vsemi_mem_xaui[144] = 0xEF;
-	vsemi_mem_xaui[145] = 0xFF;
-	vsemi_mem_xaui[146] = 0xFF;
-	vsemi_mem_xaui[147] = 0xFB;
-	vsemi_mem_xaui[148] = 0xFF;
-	vsemi_mem_xaui[149] = 0x3F;
-	vsemi_mem_xaui[150] = 0x0;
-	vsemi_mem_xaui[151] = 0x64;
-	vsemi_mem_xaui[152] = 0x0;
-	vsemi_mem_xaui[153] = 0x2;
-	vsemi_mem_xaui[154] = 0x1;
-	vsemi_mem_xaui[155] = 0x5;
-	vsemi_mem_xaui[156] = 0x5;
-	vsemi_mem_xaui[157] = 0x4;
-	vsemi_mem_xaui[158] = 0x0;
-	vsemi_mem_xaui[159] = 0x0;
-	vsemi_mem_xaui[160] = 0x8;
-	vsemi_mem_xaui[161] = 0x4;
-	vsemi_mem_xaui[162] = 0x0;
-	vsemi_mem_xaui[163] = 0x0;
-	vsemi_mem_xaui[164] = 0x4;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_xaui_125(void)
-{
-	vsemi_mem_xaui[101] = 0xAA;
-	vsemi_mem_xaui[102] = 0x0;
-	vsemi_mem_xaui[103] = 0x57;
-	vsemi_mem_xaui[104] = 0xBF;
-	vsemi_mem_xaui[105] = 0xBF;
-	vsemi_mem_xaui[106] = 0x8;
-	vsemi_mem_xaui[107] = 0x8;
-	vsemi_mem_xaui[108] = 0x13;
-	vsemi_mem_xaui[109] = 0x13;
-	vsemi_mem_xaui[110] = 0x4;
-	vsemi_mem_xaui[111] = 0x17;
-	vsemi_mem_xaui[112] = 0x10;
-	vsemi_mem_xaui[113] = 0x0;
-	vsemi_mem_xaui[114] = 0x10;
-	vsemi_mem_xaui[115] = 0x0;
-	vsemi_mem_xaui[116] = 0xFF;
-	vsemi_mem_xaui[117] = 0xC3;
-	vsemi_mem_xaui[118] = 0xF5;
-	vsemi_mem_xaui[119] = 0xD9;
-	vsemi_mem_xaui[120] = 0xF2;
-	vsemi_mem_xaui[121] = 0xFC;
-	vsemi_mem_xaui[122] = 0xFE;
-	vsemi_mem_xaui[123] = 0xFF;
-	vsemi_mem_xaui[124] = 0xFF;
-	vsemi_mem_xaui[125] = 0xFF;
-	vsemi_mem_xaui[126] = 0xFF;
-	vsemi_mem_xaui[127] = 0xDB;
-	vsemi_mem_xaui[128] = 0xE9;
-	vsemi_mem_xaui[129] = 0xC2;
-	vsemi_mem_xaui[130] = 0xF2;
-	vsemi_mem_xaui[131] = 0xFC;
-	vsemi_mem_xaui[132] = 0xFE;
-	vsemi_mem_xaui[133] = 0xF2;
-	vsemi_mem_xaui[134] = 0xF2;
-	vsemi_mem_xaui[135] = 0xFF;
-	vsemi_mem_xaui[136] = 0xFF;
-	vsemi_mem_xaui[137] = 0xDB;
-	vsemi_mem_xaui[138] = 0xE9;
-	vsemi_mem_xaui[139] = 0xC2;
-	vsemi_mem_xaui[140] = 0xF2;
-	vsemi_mem_xaui[141] = 0xFC;
-	vsemi_mem_xaui[142] = 0xFE;
-	vsemi_mem_xaui[143] = 0xF2;
-	vsemi_mem_xaui[144] = 0xF2;
-	vsemi_mem_xaui[145] = 0xFF;
-	vsemi_mem_xaui[146] = 0xFF;
-	vsemi_mem_xaui[147] = 0xFF;
-	vsemi_mem_xaui[148] = 0xF2;
-	vsemi_mem_xaui[149] = 0x3F;
-	vsemi_mem_xaui[150] = 0x0;
-	vsemi_mem_xaui[151] = 0x64;
-	vsemi_mem_xaui[152] = 0x0;
-	vsemi_mem_xaui[153] = 0x2;
-	vsemi_mem_xaui[154] = 0x1;
-	vsemi_mem_xaui[155] = 0x5;
-	vsemi_mem_xaui[156] = 0x5;
-	vsemi_mem_xaui[157] = 0x4;
-	vsemi_mem_xaui[158] = 0x0;
-	vsemi_mem_xaui[159] = 0x0;
-	vsemi_mem_xaui[160] = 0x8;
-	vsemi_mem_xaui[161] = 0x4;
-	vsemi_mem_xaui[162] = 0x0;
-	vsemi_mem_xaui[163] = 0x0;
-	vsemi_mem_xaui[164] = 0x4;
-
-}
-
-
-void nlm_hal_config_vsemi_mem_xaui_4page(void)
-{
-	vsemi_mem_xaui_4page[101] = 0xBF;
-	vsemi_mem_xaui_4page[102] = 0xBF;
-	vsemi_mem_xaui_4page[103] = 0xA;
-	vsemi_mem_xaui_4page[104] = 0xA;
-	vsemi_mem_xaui_4page[105] = 0xE;
-	vsemi_mem_xaui_4page[106] = 0xE;
-	vsemi_mem_xaui_4page[107] = 0x1;
-	vsemi_mem_xaui_4page[108] = 0x1;
-	vsemi_mem_xaui_4page[109] = 0x22;
-	vsemi_mem_xaui_4page[110] = 0xF;
-
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_xaui_4page_125(void)
-{
-	vsemi_mem_xaui_4page[101] = 0xBF;
-	vsemi_mem_xaui_4page[102] = 0xBF;
-	vsemi_mem_xaui_4page[103] = 0x8;
-	vsemi_mem_xaui_4page[104] = 0x8;
-	vsemi_mem_xaui_4page[105] = 0x13;
-	vsemi_mem_xaui_4page[106] = 0x13;
-	vsemi_mem_xaui_4page[107] = 0x1;
-	vsemi_mem_xaui_4page[108] = 0x1;
-	vsemi_mem_xaui_4page[109] = 0x22;
-	vsemi_mem_xaui_4page[110] = 0xF;
-	
-	return;
-}
-
-void nlm_hal_config_vsemi_mem_sgmii(void)
-{
-	vsemi_mem_sgmii[101] = 0x99;
-	vsemi_mem_sgmii[102] = 0x0;
-	vsemi_mem_sgmii[103] = 0x76;
-	vsemi_mem_sgmii[104] = 0xB7;
-	vsemi_mem_sgmii[105] = 0xB7;
-	vsemi_mem_sgmii[106] = 0xC;
-	vsemi_mem_sgmii[107] = 0xC;
-	vsemi_mem_sgmii[108] = 0x1A;
-	vsemi_mem_sgmii[109] = 0x1A;
-	vsemi_mem_sgmii[110] = 0x6;
-	vsemi_mem_sgmii[111] = 0x16;
-	vsemi_mem_sgmii[112] = 0x8;
-	vsemi_mem_sgmii[113] = 0x0;
-	vsemi_mem_sgmii[114] = 0x8;
-	vsemi_mem_sgmii[115] = 0x0;
-	vsemi_mem_sgmii[116] = 0xFF;
-	vsemi_mem_sgmii[117] = 0xB3;
-	vsemi_mem_sgmii[118] = 0xF6;
-	vsemi_mem_sgmii[119] = 0xD0;
-	vsemi_mem_sgmii[120] = 0xEF;
-	vsemi_mem_sgmii[121] = 0xFB;
-	vsemi_mem_sgmii[122] = 0xFF;
-	vsemi_mem_sgmii[123] = 0xFF;
-	vsemi_mem_sgmii[124] = 0xFF;
-	vsemi_mem_sgmii[125] = 0xFF;
-	vsemi_mem_sgmii[126] = 0xFF;
-	vsemi_mem_sgmii[127] = 0xD3;
-	vsemi_mem_sgmii[128] = 0xD3;
-	vsemi_mem_sgmii[129] = 0xE2;
-	vsemi_mem_sgmii[130] = 0xEF;
-	vsemi_mem_sgmii[131] = 0xFB;
-	vsemi_mem_sgmii[132] = 0xFB;
-	vsemi_mem_sgmii[133] = 0xFF;
-	vsemi_mem_sgmii[134] = 0xEF;
-	vsemi_mem_sgmii[135] = 0xFF;
-	vsemi_mem_sgmii[136] = 0xFF;
-	vsemi_mem_sgmii[137] = 0xD3;
-	vsemi_mem_sgmii[138] = 0xD3;
-	vsemi_mem_sgmii[139] = 0xE2;
-	vsemi_mem_sgmii[140] = 0xEF;
-	vsemi_mem_sgmii[141] = 0xFB;
-	vsemi_mem_sgmii[142] = 0xFB;
-	vsemi_mem_sgmii[143] = 0xFF;
-	vsemi_mem_sgmii[144] = 0xEF;
-	vsemi_mem_sgmii[145] = 0xFF;
-	vsemi_mem_sgmii[146] = 0xFF;
-	vsemi_mem_sgmii[147] = 0xFB;
-	vsemi_mem_sgmii[148] = 0xFF;
-	vsemi_mem_sgmii[149] = 0x3F;
-	vsemi_mem_sgmii[150] = 0x0;
-	vsemi_mem_sgmii[151] = 0x64;
-	vsemi_mem_sgmii[152] = 0x0;
-	vsemi_mem_sgmii[153] = 0x4;
-	vsemi_mem_sgmii[154] = 0x2;
-	vsemi_mem_sgmii[155] = 0x5;
-	vsemi_mem_sgmii[156] = 0x5;
-	vsemi_mem_sgmii[157] = 0x4;
-	vsemi_mem_sgmii[158] = 0x0;
-	vsemi_mem_sgmii[159] = 0x0;
-	vsemi_mem_sgmii[160] = 0x8;
-	vsemi_mem_sgmii[161] = 0x4;
-	vsemi_mem_sgmii[162] = 0x0;
-	vsemi_mem_sgmii[163] = 0x0;
-	vsemi_mem_sgmii[164] = 0x4;
-}
-
-void vsemi_mem_init_sgmii_125Mhzrefclk(void)
-{
-	vsemi_mem_sgmii[101] = 0xAA;
-	vsemi_mem_sgmii[102] = 0x0;
-	vsemi_mem_sgmii[103] = 0x57;
-	vsemi_mem_sgmii[104] = 0xBF;
-	vsemi_mem_sgmii[105] = 0xBF;
-	vsemi_mem_sgmii[106] = 0xA;
-	vsemi_mem_sgmii[107] = 0xA;
-	vsemi_mem_sgmii[108] = 0xE;
-	vsemi_mem_sgmii[109] = 0xE;
-	vsemi_mem_sgmii[110] = 0x4;
-	vsemi_mem_sgmii[111] = 0x17;
-	vsemi_mem_sgmii[112] = 0x10;
-	vsemi_mem_sgmii[113] = 0x0;
-	vsemi_mem_sgmii[114] = 0x10;
-	vsemi_mem_sgmii[115] = 0x0;
-	vsemi_mem_sgmii[116] = 0xFF;
-	vsemi_mem_sgmii[117] = 0xC3;
-	vsemi_mem_sgmii[118] = 0xF5;
-	vsemi_mem_sgmii[119] = 0xD9;
-	vsemi_mem_sgmii[120] = 0xF2;
-	vsemi_mem_sgmii[121] = 0xFC;
-	vsemi_mem_sgmii[122] = 0xFE;
-	vsemi_mem_sgmii[123] = 0xFF;
-	vsemi_mem_sgmii[124] = 0xFF;
-	vsemi_mem_sgmii[125] = 0xFF;
-	vsemi_mem_sgmii[126] = 0xFF;
-	vsemi_mem_sgmii[127] = 0xDB;
-	vsemi_mem_sgmii[128] = 0xE9;
-	vsemi_mem_sgmii[129] = 0xC2;
-	vsemi_mem_sgmii[130] = 0xF2;
-	vsemi_mem_sgmii[131] = 0xFC;
-	vsemi_mem_sgmii[132] = 0xFE;
-	vsemi_mem_sgmii[133] = 0xF2;
-	vsemi_mem_sgmii[134] = 0xF2;
-	vsemi_mem_sgmii[135] = 0xFF;
-	vsemi_mem_sgmii[136] = 0xFF;
-	vsemi_mem_sgmii[137] = 0xDB;
-	vsemi_mem_sgmii[138] = 0xE9;
-	vsemi_mem_sgmii[139] = 0xC2;
-	vsemi_mem_sgmii[140] = 0xF2;
-	vsemi_mem_sgmii[141] = 0xFC;
-	vsemi_mem_sgmii[142] = 0xFE;
-	vsemi_mem_sgmii[143] = 0xF2;
-	vsemi_mem_sgmii[144] = 0xF2;
-	vsemi_mem_sgmii[145] = 0xFF;
-	vsemi_mem_sgmii[146] = 0xFF;
-	vsemi_mem_sgmii[147] = 0xFF;
-	vsemi_mem_sgmii[148] = 0xF2;
-	vsemi_mem_sgmii[149] = 0x3F;
-	vsemi_mem_sgmii[150] = 0x0;
-	vsemi_mem_sgmii[151] = 0x64;
-	vsemi_mem_sgmii[152] = 0x0;
-	vsemi_mem_sgmii[153] = 0x2;
-	vsemi_mem_sgmii[154] = 0x1;
-	vsemi_mem_sgmii[155] = 0x5;
-	vsemi_mem_sgmii[156] = 0x5;
-	vsemi_mem_sgmii[157] = 0x4;
-	vsemi_mem_sgmii[158] = 0x0;
-	vsemi_mem_sgmii[159] = 0x0;
-	vsemi_mem_sgmii[160] = 0x8;
-	vsemi_mem_sgmii[161] = 0x4;
-	vsemi_mem_sgmii[162] = 0x0;
-	vsemi_mem_sgmii[163] = 0x0;
-	vsemi_mem_sgmii[164] = 0x4;
-}
-
-void nlm_hal_config_vsemi_mem_sgmii_4page(void)
-{    
-	vsemi_mem_sgmii_4page[101] = 0xB7;
-	vsemi_mem_sgmii_4page[102] = 0xB7;
-	vsemi_mem_sgmii_4page[103] = 0xC;
-	vsemi_mem_sgmii_4page[104] = 0xC;
-	vsemi_mem_sgmii_4page[105] = 0x1A;
-	vsemi_mem_sgmii_4page[106] = 0x1A;
-	vsemi_mem_sgmii_4page[107] = 0x2;
-	vsemi_mem_sgmii_4page[108] = 0x2;
-	vsemi_mem_sgmii_4page[109] = 0x11;
-	vsemi_mem_sgmii_4page[110] = 0xF;
-}
-
-void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void)
-{
-	vsemi_mem_sgmii_4page[101] = 0xBF;
-	vsemi_mem_sgmii_4page[102] = 0xBF;
-	vsemi_mem_sgmii_4page[103] = 0xA;
-	vsemi_mem_sgmii_4page[104] = 0xA;
-	vsemi_mem_sgmii_4page[105] = 0xE;
-	vsemi_mem_sgmii_4page[106] = 0xE;
-	vsemi_mem_sgmii_4page[107] = 0x1;
-	vsemi_mem_sgmii_4page[108] = 0x1;
-	vsemi_mem_sgmii_4page[109] = 0x11;
-	vsemi_mem_sgmii_4page[110] = 0xF;
-}
-
-#ifdef NLM_HAL_LINUX_KERNEL
-#include <linux/types.h>
-#include <linux/module.h>
-EXPORT_SYMBOL(vsemi_mem_sgmii_4page);
-EXPORT_SYMBOL(vsemi_mem_sgmii);
-EXPORT_SYMBOL(vsemi_mem_xaui_4page);
-EXPORT_SYMBOL(vsemi_mem_xaui);
-EXPORT_SYMBOL(vsemi_mem_12G_4page);
-EXPORT_SYMBOL(vsemi_mem_12G);
-EXPORT_SYMBOL(vsemi_mem_16G_4page);
-EXPORT_SYMBOL(vsemi_mem_16G);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_16G_4page);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_16G_4page_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_16G);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_16G_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_12G_4page);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_12G_4page_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_12G);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_12G_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_xaui);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_xaui_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_xaui_4page);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_xaui_4page_125);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii);
-EXPORT_SYMBOL(vsemi_mem_init_sgmii_125Mhzrefclk);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii_4page);
-EXPORT_SYMBOL(nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz);
-#endif
-- 
1.7.1

