From 0d5f426445772c887d15b7d91023392d124747bb Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 27 Aug 2010 16:59:27 -0700
Subject: NAE: use nlm_hal_open_if instead orginal init_gmac function

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 0a1bae2..584cfd7 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -80,9 +80,9 @@
 #define ETH_MTU_SIZE		 	2048
 #define MIN_ETH_FRAME_SIZE		64
 
-#define  DUMP_RCV_PKT				0
-#define  DUMP_XMIT_PKT				0
-#define  DUMP_PKT(x, y)				\
+#define DUMP_RCV_PKT				0
+#define DUMP_XMIT_PKT				0
+#define DUMP_PKT(x, y)				\
 	int i;      				\
         for(i = 0; i < y; i++)			\
         {					\
@@ -92,7 +92,7 @@
         }					\
 	printk("\n");
 
-#define RUN_ON_SIM_ONLY				0
+#define RUN_ON_SIM_ONLY			 	0
 #define IP_HEADER_4BYTE_ALIGN_WKAROUND 		0
 
 unsigned char eth_hw_addr[18][6] = {
@@ -131,6 +131,7 @@ static void nlm_xlp_sgmii_setcontext(void);
 static void nlm_xlp_nae_init(void);
 static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
 static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf);
+static void mac_send_one_desc(unsigned long dev);
 static int  nlm_xlp_nae_open (struct net_device *dev);
 static int  nlm_xlp_nae_stop (struct net_device *dev);
 static int  nlm_xlp_nae_start_xmit (struct sk_buff *skb, struct net_device *dev);
@@ -260,6 +261,74 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
 
 	dev_kfree_skb_any(skb);
 }
+
+/**********************************************************************
+ * mac_send_one_desc -  refill one freein buffer for a device
+ * @dev -  this is per device based function
+ *
+ **********************************************************************/
+static void mac_send_one_desc(unsigned long dev)
+{
+        struct dev_data* priv;
+        struct net_device *ndev;
+        int ret, mflags, code;
+        struct xlp_msg msg;
+        struct sk_buff * skb;
+
+        ndev = (struct net_device *) dev;
+        priv = netdev_priv(ndev);
+        ret = 0;
+
+	skb = nlm_xlp_alloc_skb();
+        if(!skb)
+	{
+		printk("[%s] alloc skb failed\n",__FUNCTION__);
+                        return;
+	}
+
+	skb->dev = ndev;
+
+        /* Send the free Rx desc to the MAC */
+	mac_put_skb_back_ptr(skb);
+	code = 0;
+
+	msgrng_access_enable(mflags);
+        msg.entry[0] = (unsigned long long)virt_to_bus(skb->data) & 0xffffffffffULL;
+        /* Send the packet to nae rx  */
+	__sync();
+retry_send:
+        if((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])))
+        {
+		if(ret & MSG_DST_FC_FAIL)
+		{
+			ret = xlp_read_status1();
+			if( ret & (1 << 31))
+                        {
+				printk("CPU receive queue written when Full\n");
+                        }
+                        else if(ret & (1 << 30))
+                        {
+				printk("Fmn input credit overflow hardware error\n");
+                        }
+                        else if( ret & (1 << 29))
+                        {
+				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
+                        }
+			printk("TX message destination flow control credit fail\n");
+			msgrng_access_disable(mflags);
+		}
+		else if(ret & MSG_INFLIGHT_MSG_EX)
+			goto retry_send;
+		else if(ret & MSG_TXQ_FULL)
+			printk("TX message Q fulll\n");
+		dev_kfree_skb(skb);
+		msgrng_access_disable(mflags);
+	}
+	msgrng_access_disable(mflags);
+        priv->num_desc += 1;
+        return;
+}
+
 /**********************************************************************
  * mac_refill_frin_desc -  refill rx freein buffer for a device
  * @dev -  this is per device based function
@@ -333,11 +402,9 @@ retry_send:
 
 			goto retry_send;
                 }
-
 		msgrng_access_disable(mflags);
 		priv->num_desc += 1;
 	}
-
         return;
 }
 
@@ -370,11 +437,12 @@ static void nlm_xlp_nae_init(void)
 	/* initial 18 gmac block */
         for(i = 0; i < 1/*MAX_NET_INF*/; i++)
 	{
-		init_gmac(i);
+		/*init_gmac(i);*/
+		nlm_hal_open_if(GMAC_IF, i);
 	}
 
 
-
+#if 1
 	/* init tx if credit */
 	init_tx_if_credit( 0, 0x7FFFF );
 
@@ -383,12 +451,13 @@ static void nlm_xlp_nae_init(void)
 	{
 		init_ucore(0xffffUL, i);
 	}
-
+#endif
 	ucore_load_apps(0xffffUL);
-
+#if 1
 	/*  init egress and igress interface */
 	init_ingress();
 	init_egress();
+#endif
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
 	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
@@ -848,6 +917,43 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		else {
 			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
 		}
+		port = msg0 & 0x0f;
+                addr = msg0 & 0xfffffffff0ULL;
+                len = (msg0 >> 40) & 0x3fff;
+#ifdef RUN_ON_SIM_ONLY
+		freedesc = len;
+		len = 0;
+#endif
+                if(addr && (len==0))
+                {
+			pdev = (struct net_device*)dev_mac[port];
+			if(!pdev)
+				return;
+			priv = netdev_priv(pdev);
+#ifdef RUN_ON_SIM_ONLY
+			if(priv->num_desc > freedesc)
+				priv->num_desc = freedesc;
+#endif
+
+                        skb = (struct sk_buff *)bus_to_virt(addr);
+                        if(skb)
+                        {
+                                priv->stats.rx_packets++;
+                                if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15){
+                                       netif_tx_wake_all_queues(pdev);
+                                }
+                                dev_kfree_skb_any(skb);
+                        }
+			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+			{
+				tasklet_schedule(&mac_refill_task[port]);
+			}
+                }
+                else if(addr == 0)
+                {
+                        /* case tx queue is stopped */
+                        netif_tx_wake_all_queues(pdev);
+                }
 	}
 	else if(vc == 0 && size == 2)
 	{
@@ -916,6 +1022,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				tasklet_schedule(&mac_refill_task[port]);
 			}
 
+			/* refill one freein desc */
+			mac_send_one_desc(pdev);
 #if DUMP_RCV_PKT
 			DUMP_PKT(skb->data, skb->len);
 #endif
-- 
1.7.1

