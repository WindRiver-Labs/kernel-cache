From 97f523ded37a06af1f6d6f067282d198332b33d1 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Fri, 10 Sep 2010 00:11:47 -0700
Subject: Support for FDT based nae-cfg

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 12484dd..6737a13 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -1,26 +1,190 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/mm.h>
+
 #include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <ops.h>
+
 #include "net_common.h"
 
 #define VAL_UCORE_RESET(x)		((x&0xffff)<<8)
-/*
- * uCore code
- * configure Interface to ucore
- * Load ucode
- * Reset Ucore
- *
- */
-int init_ucore(uint32_t ucore_mask, int if_num)
+
+static void parse_ucore_config(void)
 {
-	uint32_t ucore_cfg;
+        uint32_t ucore_cfg;
+	void *node;
+	int size = 0;
+	unsigned int *uc_opcodes;
+	uint32_t uc_mask, num_opcodes;
+
+	uc_mask = num_opcodes = ucore_cfg = 0;
+
+	node = finddevice("/chosen/nae-cfg/ucore/src@1");
+	if(!node) {
+		printk("[%s] Unable to parse ucore configuration!\n", __func__);
+		return;
+	}
+
+	/* Domain specific ucore mask */
+	getprop(node, "mask", &uc_mask, sizeof(uint32_t));
+
+	getprop(node, "num-opcodes", &num_opcodes, sizeof(uint32_t));
 
-	ucore_cfg = 0;
-	nlm_hal_write_nae_reg(UCORE_IFACE_MASK_CFG,
-			      ucore_spray_config(if_num, ucore_mask, CMD_WRITE));
-	ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
-	nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg & (~VAL_UCORE_RESET(ucore_mask)));
+	size = sizeof(uint32_t) * num_opcodes;
+	uc_opcodes = kmalloc(size, GFP_KERNEL);
+	if (!uc_opcodes) {
+		printk("[%s] Unable to allocate temporary memory\n", __func__);
+		return;
+	}
 
-	return 0;
+	getprop(node, "opcodes", uc_opcodes, size);
+
+	nlm_hal_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
+
+	kfree(uc_opcodes);
+
+	/* Enable per-domain ucores */
+        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
+        nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg & (~VAL_UCORE_RESET(uc_mask)));
 }
 
+static void parse_fdt_cpu_config(void)
+{
+	void *node;
+
+	node = finddevice("/doms/dom@0/cpu");
+	if (!node) {
+		printk("[%s] Unable to parse cpu-nae configuration! Using defaults:\n",
+		       __func__);
+		goto use_defaults;
+	}
+
+	if (getprop(node, "nae-rx-vc", &nae_rx_vc, sizeof(uint32_t)) < 0) {
+		printk("Unable to parse nae_rx_vc, using defaults\n");
+		goto use_defaults;
+	}
+
+	if (getprop(node, "nae-fb-vc", &nae_fb_vc, sizeof(uint32_t)) < 0) {
+		printk("Unable to parse nae_rx_vc, using defaults\n");
+		goto use_defaults;
+	}
+
+	return;
+
+ use_defaults:
+	nae_rx_vc = 0;
+	nae_fb_vc = 1;
+
+	return;
+}
+
+static void parse_fdt_nae_config(void)
+{
+	void *node, *subnode;
+	int i = 0;
+	char domstr[32] = "";
+	int port_type = UNKNOWN_IF;
+	char port_type_str[MAX_PROP_LEN];
+	int size = 0;
+	uint32_t start_port, num_nae_regs, num_intf_regs;
+
+	/* Parse Nae Config */
+	start_port = num_nae_regs = num_intf_regs = 0;
+
+	node = finddevice("/chosen/nae-cfg");
+	if(!node) {
+		printk("[%s] Unable to parse nae configuration!\n", __func__);
+		return;
+	}
+
+	/*******************************************************************************/
+	/* Read range of ports allocated per domain
+	 * start-port-id -> start-port-id + num-ports
+	 */
+
+	if(getprop(node, "start-port-id", &start_port, sizeof(uint32_t)) < 0)
+		printk("fdt missing start-port-id\n");
+
+	if(getprop(node, "num-ports", &netif_ports, sizeof(uint32_t)) < 0)
+		printk("fdt missing num-ports\n");
+
+	/*******************************************************************************/
+
+	if(getprop(node, "num-nae-regs", &num_nae_regs, sizeof(uint32_t)) < 0)
+		printk("fdt missing num-nae-regs\n");
+
+	if(getprop(node, "num-intf-regs", &num_intf_regs, sizeof(uint32_t)) < 0)
+		printk("fdt missing num-if-regs\n");
+
+	printk("num-ports = %d, start-port-id = %d\n", netif_ports, start_port);
+
+	if (debug)
+		printk("num-nae-regs = %d, num-intf-regs = %d\n", num_nae_regs, num_intf_regs);
+
+	for(i = 0; i < netif_ports; i++)
+	{
+		uint32_t *nae_regs = 0, *intf_regs = 0;
+
+		sprintf(domstr, "/chosen/nae-cfg/port@%d", i);
+
+		subnode = finddevice(domstr);
+		if(!subnode) continue;
+
+		getprop(subnode, "type", port_type_str, MAX_PROP_LEN);
+		if (!strcmp(port_type_str, "SGMII_IF")) port_type = SGMII_IF;
+		else if (!strcmp(port_type_str, "XAUI_IF")) port_type = XAUI_IF;
+		else if (!strcmp(port_type_str, "INTERLAKEN_IF")) port_type = INTERLAKEN_IF;
+		else port_type = UNKNOWN_IF;
+
+		getprop(subnode, "num-free-desc", &max_num_desc,
+			sizeof(uint32_t));
+
+		size = sizeof(uint32_t) * num_nae_regs * 2;
+		nae_regs = kmalloc(size, GFP_KERNEL);
+		if (!nae_regs) {
+			printk("[%s] Unable to allocate memory for nae-regs, aborting\n", __func__);
+			return;
+		}
+		getprop(subnode, "nae-regs", nae_regs, size);
+
+		size = sizeof(uint32_t) * num_intf_regs * 2;
+		intf_regs = kmalloc(size, GFP_KERNEL);
+		if (!intf_regs) {
+			printk("[%s] Unable to allocate memory for if-regs, aborting\n", __func__);
+			return;
+		}
+		getprop(subnode, "intf-regs", intf_regs, size);
+
+		printk("Configuring per-port interface registers for port@%d\n", i);
+		/* Configure per port interface registers */
+		nlm_hal_init_if_regs(port_type, i, intf_regs, num_intf_regs);
+
+		printk("Configuring per-port NAE registers for port@%d\n", i);
+		/* Configure per port NAE registers */
+		nlm_hal_init_nae_regs(port_type, nae_regs, num_nae_regs);
+
+		kfree(nae_regs);
+		kfree(intf_regs);
+
+		if (nlm_hal_open_if(port_type, i) < 0) {
+			printk("[%s] Unable to open port %d\n", __func__, i);
+			continue;
+		}
+
+		printk("Initialized port@%d\n", i);
+	}
+}
+
+void initialize_nae(void)
+{
+	printk("Configuring ucore...\n");
+	parse_ucore_config();
+
+	printk("Configuring NAE...\n");
+	parse_fdt_nae_config();
+
+	printk("Configuring NAE...\n");
+	parse_fdt_cpu_config();
+
+	printk("NAE configuration done!\n");
+}
diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
index d502b3b..478a1bb 100644
--- a/drivers/net/ethernet/broadcom/nae/net_common.h
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -167,4 +167,12 @@ static __inline__ void tx_print(uint64_t msg0) {
 	       (msg0) & 0xffffffffffULL);
 }
 
+extern int netif_ports;
+extern uint32_t max_num_desc;
+extern int debug;
+extern uint32_t nae_rx_vc;
+extern uint32_t nae_fb_vc;
+
+extern void initialize_nae(void);
+
 #endif
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_apps.c b/drivers/net/ethernet/broadcom/nae/ucore_apps.c
deleted file mode 100644
index aad326d..0000000
--- a/drivers/net/ethernet/broadcom/nae/ucore_apps.c
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "ucore_loader.h"
-
-uint32_t sample_array[] = {
-	0x0,
-	0x32,
-	0x3c1c0010,
-	0x279cf808,
-	0x3c020010,
-	0x2442f808,
-	0x3c030010,
-	0x2463f808,
-	0xac400000,
-	0x43082b,
-	0x1420fffd,
-	0x24420004,
-	0x3c1d0010,
-	0x27bdf9c0,
-	0x27a50020,
-	0x27a60028,
-	0xaca00000,
-	0xacc00000,
-	0xc000029,
-	0x2021,
-	0x1000ffff,
-	0x0,
-	0x3c020000,
-	0x8c4200fc,
-	0x27bdffe0,
-	0x2403ffff,
-	0xafbf001c,
-	0xafb10018,
-	0x10430009,
-	0xafb00014,
-	0x3c100000,
-	0x261000fc,
-	0x2411ffff,
-	0x40f809,
-	0x2610fffc,
-	0x8e020000,
-	0x1451fffc,
-	0x0,
-	0x8fbf001c,
-	0x8fb10018,
-	0x8fb00014,
-	0x3e00008,
-	0x27bd0020,
-	0x24030001,
-	0x1021,
-	0x34088004,
-	0x8d040000,
-	0x34088030,
-	0xad030000,
-	0x34088000,
-	0x800002b,
-	0xad020000,
-	0x0,
-	0x0,
-};
-#define sample_array_size 54
-ucore_array_info_t ucore_array_info[] = {
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size },
-	{ sample_array, sample_array_size }
-};
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_loader.c b/drivers/net/ethernet/broadcom/nae/ucore_loader.c
deleted file mode 100644
index 3cc2e3e..0000000
--- a/drivers/net/ethernet/broadcom/nae/ucore_loader.c
+++ /dev/null
@@ -1,66 +0,0 @@
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <asm/netlogic/hal/nlm_hal_nae.h>
-
-#include "ucore_loader.h"
-#include "ucore_apps.c"
-
-ucore_array_info_t ucore_array_info[MAX_UCORE];
-
-static __inline__ void ucore_load_app(int ucore, uint32_t **array, uint32_t array_size) {
-	int k = 0, j;
-	uint32_t offset, size, code;
-	uint32_t *p = *array;
-	if ((ucore < 0) || (ucore >= MAX_UCORE) ||
-	    (p == NULL) || (array_size == 0)) {
-		return;
-	}
-
-	while (k < array_size) {
-		offset = p[k];
-		size   = p[k + 1];
-
-	if(size >= array_size||size==0){
-
-		return;
-	}
-		for (j = 0; j < size; ++j) {
-			code = p[k + 2 + j];
-			nlm_hal_write_ucode(ucore, offset, code);
-			offset += 4;
-		}
-		k += (2 + size);
-	}
-}
-
-int ucore_load_apps(uint32_t mask)
-{
-	int i=0,t, count = 0;
-	uint32_t *array, asize;
-	asize  = ucore_array_info[i].array_size;
-	array = kmalloc(sizeof(uint32_t)*asize, GFP_KERNEL);
-	if(!array)
-	{
-		printk("kmalloc failed\n");
-		return 0;
-	}
-	for (i = 0; i < MAX_UCORE; ++i) {
-		if (!(mask & (1 << i))) {
-			continue;
-		}
-		asize  = ucore_array_info[i].array_size;
-
-		for(t = 0; t < asize; t++)
-		{
-			array[t] = ucore_array_info[i].array[t];
-		}
-
-		if ((array == NULL) || (asize == 0)) {
-			continue;
-		}
-		ucore_load_app(i, &array, asize);
-		count++;
-	}
-	kfree(array);
-	return count;
-}
diff --git a/drivers/net/ethernet/broadcom/nae/ucore_loader.h b/drivers/net/ethernet/broadcom/nae/ucore_loader.h
deleted file mode 100644
index e9d9bc4..0000000
--- a/drivers/net/ethernet/broadcom/nae/ucore_loader.h
+++ /dev/null
@@ -1,14 +0,0 @@
-#ifndef __UCORE_LOADER_H__
-#define __UCORE_LOADER_H__
-
-#define MAX_UCORE 16
-
-typedef struct {
-	uint32_t *array;
-	uint32_t array_size;
-} ucore_array_info_t;
-
-/* This is the only function that should be called by the application. */
-extern int ucore_load_apps(uint32_t mask);
-
-#endif /* __UCORE_LOADER_H__ */
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 7078d5e..014fdae 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -54,8 +54,8 @@
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_nae.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
+
 #include "net_common.h"
-#include "ucore_loader.h"
 #include "xlp_nae.h"
 
 #define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
@@ -65,11 +65,6 @@
 #define PCI_DEVID_BASE			0
 #define PCI_DEVID_OFF_NET		0
 
-/* Currently Spill areas are not configured, so number of
- * desc sent to NAE should be less than default free frin
- * fifo size (50)
- */
-#define MAX_NUM_DESC                    32
 #define MIN_FRIN_DESC_THRESHD		16
 #define FREE_DESC_POOL_WIDTH		20
 
@@ -96,18 +91,25 @@
 	printk("\n"); }
 
 /* Module Parameters */
-static int debug = 0;
+int debug = 0;
 module_param(debug, int, 0);
 
 extern int hwemul;
 module_param(hwemul, int, 0);
 
-extern int xlp_sgmii_ports;
-module_param(xlp_sgmii_ports, int, 0);
-
 extern int naecfg_hack;
 module_param(naecfg_hack, int, 0);
 
+/***************************************************************
+ *
+ * Below parameters are set during FDT file parsing
+ */
+int netif_ports = 0;
+uint32_t max_num_desc = 32;
+uint32_t nae_rx_vc = 0;
+uint32_t nae_fb_vc = 0;
+/***************************************************************/
+
 unsigned char eth_hw_addr[18][6] = {
 	{0x00,0x01,0x02,0x03,0x04,0x05},
 	{0x00,0x01,0x02,0x03,0x04,0x06},
@@ -301,6 +303,7 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
 	dev_kfree_skb_any(skb);
 }
 
+#if 0
 /**********************************************************************
  * mac_send_one_desc -  refill one freein buffer for a device
  * @dev -  this is per device based function
@@ -367,6 +370,7 @@ retry_send:
         priv->num_desc += 1;
         return;
 }
+#endif
 
 /**********************************************************************
  * mac_refill_frin_desc -  refill rx freein buffer for a device
@@ -387,7 +391,7 @@ static void mac_refill_frin_desc(unsigned long dev)
 	ret = 0;
 
 	/* TODO ALERT: priv->num_desc access needs to atomic */
-	limit = MAX_NUM_DESC - priv->num_desc;
+	limit = max_num_desc - priv->num_desc;
 
 	for(i=1; i <= limit; i++)
 	{
@@ -439,8 +443,8 @@ static void nlm_xlp_nae_init(void)
 	uint32_t val;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, hwemul=%d, xlp_sgmii_ports=%d naecfg_hack=%d\n",
-	       debug, hwemul, xlp_sgmii_ports, naecfg_hack);
+	printk("debug = %d, hwemul=%d, naecfg_hack=%d\n",
+	       debug, hwemul, naecfg_hack);
 
 	if (hwemul) {
 		unsigned long mflags = 0;
@@ -449,35 +453,9 @@ static void nlm_xlp_nae_init(void)
 		msgrng_access_disable(mflags);
 	}
 
-	if (xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
-	{
-		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",
-		       __FUNCTION__, xlp_sgmii_ports);
-		return;
-	}
-
-	spin_lock_init(&nlm_xlp_nae_lock);
-
-	/* initial base address for nae, gmac, fmn ...*/
-
-	spin_lock_irq(&nlm_xlp_nae_lock);
-
-	/* initial NAE interfaces */
-        for(i = 0; i < MAX_NET_INF; i++)
-	{
-		nlm_hal_open_if(GMAC_IF, i);
-	}
-
-	/* Currently HAL doesn't initialize ucores, so initialize them */
-	for (i = 0; i < MAX_NET_INF; i++ )
-	{
-		init_ucore(0xffffUL, i);
-	}
-	ucore_load_apps(0xffffUL);
-
-	spin_unlock_irq(&nlm_xlp_nae_lock);
+	initialize_nae();
 
-	for(i = 0; i < xlp_sgmii_ports; i++)
+	for(i = 0; i < netif_ports; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
 		if(!dev)
@@ -697,7 +675,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 	}
 
-	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, nae_fb_vc), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
 				   0,
 				   NULL_VFBID,
@@ -898,7 +876,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		       src_id, vc, size, msg0, msg1);
 	}
 
-	if( vc == 1 && size == 1)
+	if( vc == nae_fb_vc && size == 1)
 	{
 		/* Process Transmit Complete */
 		addr = msg0 & 0xffffffffffULL;
@@ -938,7 +916,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
 		}
 	}
-	else if(vc == 0 && size == 2)
+	else if(vc == nae_rx_vc && size == 2)
 	{
 		/* Rx packet */
 		addr	= msg1 & 0xffffffffc0ULL;
-- 
1.7.1

