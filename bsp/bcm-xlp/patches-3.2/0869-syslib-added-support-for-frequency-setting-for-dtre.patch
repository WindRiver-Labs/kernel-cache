From 02f17556c26cacc130329783c76cfe74d9825384 Mon Sep 17 00:00:00 2001
From: Abhishek Joshi <abjoshi@broadcom.com>
Date: Wed, 4 Dec 2013 18:56:09 +0530
Subject: syslib: added support for frequency setting for dtre

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
index 2643f72..e996351 100644
--- a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -423,6 +423,115 @@ static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq
 }
 
 
+static inline uint64_t get_dtre_frequency(int node)
+{
+    uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_GDX * 2;
+    uint32_t clk_freq;
+    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+
+    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+    switch (sel) {
+        case 0: pll_out = 133; break;
+        case 1: pll_out = 500; break;
+        case 2: pll_out = 667; break;
+        case 3: pll_out = 767; break;
+    }
+
+    switch (div) {
+        case 0: clk_freq = pll_out; break;
+        case 1: clk_freq = pll_out/2; break;
+        case 2: clk_freq = pll_out/4; break;
+        case 3: clk_freq = pll_out/8; break;
+    }
+#ifdef FREQ_DEBUG
+    nlm_print("sel:%d div:%d DTRE_FREQUENCY :%d MHz\n", sel, div, clk_freq);
+#endif
+    return (uint64_t) (clk_freq * 1000000);
+}
+
+static inline int xlp9xx_set_dtre_frequency(int node, uint64_t freq)
+{
+    int sel, div, dev_shift, i;
+    const uint64_t mhz = 1000000;
+    int dev_freq;
+    uint64_t dtre_freq;
+    uint32_t val, dev_id = XLP9XX_CLKDEV_GDX;
+    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+
+    dtre_freq = get_dtre_frequency(node);
+
+    NLM_HAL_DO_DIV(dtre_freq, mhz);
+
+#ifdef FREQ_DEBUG
+    nlm_print("DTRE frequency before configuration is %llu MHz\n", dtre_freq);
+#endif
+    if (freq == get_dtre_frequency(node)) {
+	nlm_print("DTRE frequency set to %llu MHz\n", freq);
+        return 0;
+    }
+
+    NLM_HAL_DO_DIV(freq, mhz);
+    dev_freq = freq;
+    switch (dev_freq) {
+        case 133: sel = 0; div = 0; break;
+        case 66:  sel = 0; div = 1; break;
+        case 33:  sel = 0; div = 2; break;
+        case 17:  sel = 0; div = 3; break;
+        case 500: sel = 1; div = 0; break;
+        case 250: sel = 1; div = 1; break;
+        case 125: sel = 1; div = 2; break;
+        case 63:  sel = 1; div = 3; break;
+        case 667: sel = 2; div = 0; break;
+        case 333: sel = 2; div = 1; break;
+        case 167: sel = 2; div = 2; break;
+        case 83:  sel = 2; div = 3; break;
+        case 767: sel = 3; div = 0; break;
+        case 383: sel = 3; div = 1; break;
+        case 192: sel = 3; div = 2; break;
+        case 96:  sel = 3; div = 3; break;
+        default: /* Set it to 333 MHz */
+            nlm_print("Can't set freq to given MHz. Setting DTRE Freq to 667 MHz instead.\n");
+            sel = 2; div = 0;
+        break;
+    }
+
+    dev_shift = dev_id * 2;
+    /* Write the div and select register */
+    val = ((sel & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+
+    val = ((div & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+
+    /* This register determines which device's CLK_DEVSEL will be changed, device mapping  same as CLK_DEVDIS register,hardware deasserts this bit when done */
+    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+
+    i=0;
+    while (i++ < 10) {
+      /* Poll Change register to see if bit corresponding to our device has been deasserted */
+      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+          // Check the status
+          val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          if (val != sel) {
+              nlm_print("DTRE CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+          }
+          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          if (val != div) {
+              nlm_print("DTRE CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+          }
+          break;
+      }
+    }
+    
+    dtre_freq=get_dtre_frequency(node);
+    NLM_HAL_DO_DIV(dtre_freq, mhz);
+    nlm_print("DTRE frequency set to %llu MHz\n",dtre_freq);
+    return 0;
+}
+
 static inline int xlp9xx_set_soc_frequency(int node, int dev_id, uint64_t freq)
 {
 
@@ -437,6 +546,9 @@ static inline int xlp9xx_set_soc_frequency(int node, int dev_id, uint64_t freq)
 		case XLP9XX_CLKDEV_RSA:
                         set_crypto_block_frequency(node, dev_id, freq);
                         break;
+		case XLP9XX_CLKDEV_GDX:
+			xlp9xx_set_dtre_frequency(node, freq);
+			break;
 		default:
 			nlm_print("%s error\n",__func__);
 			break;
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 06891ec..000204c 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -336,13 +336,15 @@ int nlm_hal_get_fdt_freq(void *fdt, int type)
 #endif
 		break;
 	case NLM_DTRE:
+		if (is_nlm_xlp9xx())
+			ret=133;
 		if(copy_fdt_prop(fdt, path_str, "dtre", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
 			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
 					using the default value\n", type);
 		else
 			ret = freq;
 #ifdef FREQ_DEBUG
-		nlm_print("sae frequency is %d\n", ret);
+		nlm_print("dtre frequency is %d\n", ret);
 #endif
 		break;
 	case NLM_CDE:
@@ -902,6 +904,9 @@ void nlm_hal_set_dtre_freq(int node, int freq)
 static void nlm_hal_dtr_9xx_init(void *fdt)
 {
 
+	int node=0;
+	const uint64_t mhz = 1000000;
+	uint64_t frequency;
 	uint64_t base0 = nlm_hal_get_dev_base (XLP_DTR_NODE, 1, XLP_DTR_DEVICE, XLP_DTR_FUNC);
 	uint64_t base1 = nlm_hal_get_dev_base (XLP_DTR_NODE, 1, XLP_DTR_DEVICE, 6);
 
@@ -915,6 +920,11 @@ static void nlm_hal_dtr_9xx_init(void *fdt)
 	nlm_hal_write_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_0, 0x3fe);
 	nlm_hal_write_32bit_reg (base0, XLP_DTR_CHANNEL_CONTROL_REG_1, 0x3fe);
 
+	frequency = nlm_hal_get_fdt_freq(fdt, NLM_DTRE);
+	if (frequency) {
+	xlp9xx_set_soc_frequency(node, XLP9XX_CLKDEV_GDX, (frequency * mhz));
+	}
+
 #ifdef DEBUG
 	nlm_print ("Base Register 0x%llx\n", (unsigned long long)base0);
 	nlm_print ("Master control 0x%x\n", nlm_hal_read_32bit_reg (base0, XLP_DTR_MASTER_CONTROL_REG));
-- 
1.7.1

