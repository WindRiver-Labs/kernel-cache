From 6d4e109b85960b425c4d795229d674f4c59ea3d3 Mon Sep 17 00:00:00 2001
From: Ganesan Ramalingam <ganesanr@broadcom.com>
Date: Fri, 26 Apr 2013 10:44:59 +0530
Subject: Linux-userspace: kmod: Add NMI profiler

This profiler is a function profiler, which give details about
function being called, who are the callers and how many times.

With help of this we shall optimization the particular function
and caller, which would improve the performance.

Added README on how to use this profiler.

Signed-off-by: Ganesan Ramalingam <ganesanr@broadcom.com>
[Based on SDK 3.2]
Change the varable "nlm_io_base" to the type "external" because
it has been defined in "arch/mips/netlogic/xlp/setup.c"

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
new file mode 100644
index 0000000..dde80d5
--- /dev/null
+++ b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
@@ -0,0 +1,223 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/sysctl.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <asm-generic/getorder.h>
+
+#include "nmiprof.h"
+
+static char nmiprofsave[1024];
+
+struct nlm_nmiprof_dev {
+	struct platform_device *dev;
+	struct bin_attribute bindata_attr;
+	struct bin_attribute binnmiprof_attr;
+	u64 *base;
+	u32 nlm_cpu;
+};
+
+struct nlm_nmiprof_dev *jdev;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+static ssize_t nlm_nmiprof_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#else
+static ssize_t nlm_nmiprof_read(struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#endif
+{
+	size_t log_size = bin_attr->size;
+
+	if ((pos) >= log_size)
+		return 0;
+	if ((pos) + size > log_size)
+		size = log_size - (pos/8);
+	memcpy((void __force *) buf,
+			(void __force *) ((char *)jdev->base + pos), size);
+	return size;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+static ssize_t nlm_nmiprof_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#else
+static ssize_t nlm_nmiprof_write(struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#endif
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+static ssize_t nlm_nmiprofcontrol_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#else
+static ssize_t nlm_nmiprofcontrol_read(struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#endif
+{
+	int count = 0;
+	if (!pos)
+		count = scnprintf(buf, size, "%d\n", jdev->nlm_cpu);
+	return count;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#else
+static ssize_t nlm_nmiprofcontrol_write(struct kobject *kobj,
+		struct bin_attribute *bin_attr,
+		char *buf, loff_t pos, size_t size)
+#endif
+
+{
+	char *reset_data;
+	uint64_t xlp_pic_base;
+	int ret;
+	u32 use_cpu;
+
+	pr_debug("Jprof control jdev->nlm_cpu %d\n", jdev->nlm_cpu);
+
+	/* Get cpu */
+	use_cpu = simple_strtoul(buf, NULL, 0);
+
+	if (jdev->nlm_cpu != 32 && use_cpu != 32) {
+		pr_info("Jprof running on cpu %d\n", jdev->nlm_cpu);
+		return size + 1;
+	}
+
+	jdev->nlm_cpu = use_cpu;
+	xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
+	reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
+
+	if (jdev->nlm_cpu >= 0 && jdev->nlm_cpu < 32) {
+		/* Setting scratch reg of requested cpu
+		 * with the memory address */
+		ret = smp_call_function_single(jdev->nlm_cpu, nlm_config_cpu,
+				jdev->base, 1);
+		if (ret) {
+			pr_info("smp call function error\n");
+			return ret;
+		}
+
+		pr_info("Jprof: start tracing cpu %d, jdev->base %p\n",
+				jdev->nlm_cpu, jdev->base);
+		memcpy((void *)nmiprofsave, reset_data,
+				(nlm_nmiprof_end - nlm_nmiprof));
+		memcpy(reset_data, nlm_nmiprof, (nlm_nmiprof_end - nlm_nmiprof));
+		nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3,
+				jdev->nlm_cpu);
+	} else if (jdev->nlm_cpu == 32) {
+		nlm_pic_set_timer(xlp_pic_base, 6, ~0ULL, 0, 0);
+		memcpy(reset_data, (void *)nmiprofsave,
+				(nlm_nmiprof_end - nlm_nmiprof));
+		pr_info("Jprof: stopped tracing\n");
+	} else {
+		pr_info("Help : cpu mask 0-31\n");
+		pr_info("	To stop Jprof 32\n");
+	}
+
+	return size + 1;
+}
+
+static int __init nlm_init_sys(void)
+{
+	int err = 0;
+
+	jdev = kzalloc(sizeof(*jdev), GFP_KERNEL);
+	if (!jdev)
+		return ENOMEM;
+
+	jdev->nlm_cpu = 32;
+	/* Allocate memory for dumping the statistic collected */
+	jdev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
+			get_order(NMIPROF_LOG_SIZE));
+	if (!jdev->base) {
+		pr_info("Allocation of free pages failed\n");
+		return -ENOMEM;
+	}
+
+	memset(jdev->base, 0xa5, NMIPROF_LOG_SIZE);
+
+	/* Setup the nmiprofdata entry,
+	 * which will be used for read/write */
+	jdev->bindata_attr.attr.name = "nmiprofdata";
+	jdev->bindata_attr.attr.mode = S_IRUSR | S_IWUSR;
+	jdev->bindata_attr.read = nlm_nmiprof_read;
+	jdev->bindata_attr.write = nlm_nmiprof_write;
+	jdev->bindata_attr.size = NMIPROF_LOG_SIZE;
+	jdev->bindata_attr.private = jdev;
+
+	/* Setup nmiprofcontrol entry to control
+	 * profiling start or stop */
+	jdev->binnmiprof_attr.attr.name = "nmiprofcontrol";
+	jdev->binnmiprof_attr.attr.mode = S_IRUSR | S_IWUSR;
+	jdev->binnmiprof_attr.read = nlm_nmiprofcontrol_read;
+	jdev->binnmiprof_attr.write = nlm_nmiprofcontrol_write;
+	jdev->binnmiprof_attr.size = 4;
+	jdev->binnmiprof_attr.private = jdev;
+
+	jdev->dev = platform_device_register_simple("nmiprof", -1, NULL, 0);
+	if (IS_ERR(jdev->dev)) {
+		printk(KERN_ERR
+		"nl_pf_fs:%s:platform_device_register_simple "
+		"failed\n", __func__);
+		goto platform_err;
+	}
+
+	err = sysfs_create_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
+	if (err) {
+		pr_info("can't create attribute file\n");
+		goto sys_err1;
+	}
+
+	err = sysfs_create_bin_file(&jdev->dev->dev.kobj, &jdev->binnmiprof_attr);
+	if (err) {
+		pr_info("can't create attribute file\n");
+		goto sys_err;
+	}
+	return 0;
+
+sys_err:
+	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
+sys_err1:
+	platform_device_unregister(jdev->dev);
+platform_err:
+	if (jdev) {
+		if (jdev->base)
+			iounmap(jdev->base);
+		kfree(jdev);
+	}
+	return err;
+}
+
+static void __exit nlm_exit_sys(void)
+{
+	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->binnmiprof_attr);
+	sysfs_remove_bin_file(&jdev->dev->dev.kobj, &jdev->bindata_attr);
+	platform_device_unregister(jdev->dev);
+	iounmap(jdev->base);
+
+	return;
+}
+
+module_init(nlm_init_sys);
+module_exit(nlm_exit_sys);
+
+MODULE_AUTHOR("Ganesan Ramalingam <ganesanr@broadcom.com>");
+MODULE_DESCRIPTION("XLP SoC NMIprof");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof.h b/drivers/misc/netlogic/nmiprof/nmiprof.h
new file mode 100644
index 0000000..b7444cf
--- /dev/null
+++ b/drivers/misc/netlogic/nmiprof/nmiprof.h
@@ -0,0 +1,223 @@
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+ * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* PIC Specific registers */
+#define PIC_CTRL                0x00
+
+/* PIC control register defines */
+#define PIC_CTRL_ITV		32 /* interrupt timeout value */
+#define PIC_CTRL_ICI		19 /* ICI interrupt timeout enable */
+#define PIC_CTRL_ITE		18 /* interrupt timeout enable */
+#define PIC_CTRL_STE		10 /* system timer interrupt enable */
+#define PIC_CTRL_WWR1		8  /* watchdog 1 wraparound count for reset */
+#define PIC_CTRL_WWR0		6  /* watchdog 0 wraparound count for reset */
+#define PIC_CTRL_WWN1		4  /* watchdog 1 wraparound count for NMI */
+#define PIC_CTRL_WWN0		2  /* watchdog 0 wraparound count for NMI */
+#define PIC_CTRL_WTE		0  /* watchdog timer enable */
+
+#define PIC_TIMER0_MAXVAL    0x34
+#define PIC_TIMER1_MAXVAL    0x36
+#define PIC_TIMER2_MAXVAL    0x38
+#define PIC_TIMER3_MAXVAL    0x3a
+#define PIC_TIMER4_MAXVAL    0x3c
+#define PIC_TIMER5_MAXVAL    0x3e
+#define PIC_TIMER6_MAXVAL    0x40
+#define PIC_TIMER7_MAXVAL    0x42
+#define PIC_TIMER_MAXVAL(i)  (PIC_TIMER0_MAXVAL + ((i) * 2))
+
+#define PIC_IRT0                0x74
+#define PIC_IRT(i)              (PIC_IRT0 + ((i) * 2))
+
+#define TIMER_CYCLES_MAXVAL	0xffffffffffffffffULL
+
+/*
+ *    IRT Map
+ */
+#define PIC_NUM_IRTS		160
+
+#define PIC_IRT_WD_0_INDEX	0
+#define PIC_IRT_WD_1_INDEX	1
+#define PIC_IRT_WD_NMI_0_INDEX	2
+#define PIC_IRT_WD_NMI_1_INDEX	3
+#define PIC_IRT_TIMER_0_INDEX	4
+#define PIC_IRT_TIMER_1_INDEX	5
+#define PIC_IRT_TIMER_2_INDEX	6
+#define PIC_IRT_TIMER_3_INDEX	7
+#define PIC_IRT_TIMER_4_INDEX	8
+#define PIC_IRT_TIMER_5_INDEX	9
+#define PIC_IRT_TIMER_6_INDEX	10
+#define PIC_IRT_TIMER_7_INDEX	11
+#define PIC_IRT_CLOCK_INDEX	PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_TIMER_INDEX(num)	((num) + PIC_IRT_TIMER_0_INDEX)
+
+
+
+#define XLP_DEFAULT_IO_BASE             0x18000000
+#define RESET_VEC_PHYS			0x1fc00000
+#define XLP_IO_PCI_HDRSZ		0x100
+#define XLP_IO_DEV(node, dev)		((dev) + (node) * 8)
+#define XLP_HDR_OFFSET(node, bus, dev, fn)	(((bus) << 20) | \
+				((XLP_IO_DEV(node, dev)) << 15) | ((fn) << 12))
+
+/* coherent inter chip */
+#define XLP_IO_PIC_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 0, 4)
+
+#define nlm_read_pci_reg(b, r)		nlm_read_reg(b, r)
+#define nlm_write_pci_reg(b, r, v)	nlm_write_reg(b, r, v)
+
+#define nlm_read_pic_reg(b, r)  nlm_read_reg64(b, r)
+#define nlm_write_pic_reg(b, r, v) nlm_write_reg64(b, r, v)
+
+#define nlm_get_pic_pcibase(node) nlm_pcicfg_base(XLP_IO_PIC_OFFSET(node))
+#define nlm_get_pic_regbase(node) (nlm_get_pic_pcibase(node) + XLP_IO_PCI_HDRSZ)
+
+#define write_c0_scratch(sel, val)	__write_64bit_c0_register($22, sel, val)
+#define read_c0_scratch(sel)	__read_64bit_c0_register($22, sel)
+
+/* NMIprof log size 4MB*/
+#define NMIPROF_LOG_SIZE	0x400000
+
+extern char nlm_nmiprof[], nlm_nmiprof_end[];
+extern uint64_t nlm_io_base;
+
+static inline uint64_t nlm_pcicfg_base(uint32_t devoffset)
+{
+	return nlm_io_base + devoffset;
+}
+
+static inline uint64_t
+nlm_read_reg64(uint64_t base, uint32_t reg)
+{
+	uint64_t addr = base + (reg >> 1) * sizeof(uint64_t);
+	volatile uint64_t *ptr = (volatile uint64_t *)(long)addr;
+	uint64_t val;
+
+	if (sizeof(unsigned long) == 4) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		__asm__ __volatile__(
+			".set	push"			"\n\t"
+			".set	mips64"			"\n\t"
+			"ld	%L0, %1"		"\n\t"
+			"dsra32	%M0, %L0, 0"		"\n\t"
+			"sll	%L0, %L0, 0"		"\n\t"
+			".set	pop"			"\n"
+			: "=r" (val)
+			: "m" (*ptr));
+		local_irq_restore(flags);
+	} else
+		val = *ptr;
+
+	return val;
+}
+
+static inline void
+nlm_write_reg64(uint64_t base, uint32_t reg, uint64_t val)
+{
+	uint64_t addr = base + (reg >> 1) * sizeof(uint64_t);
+	volatile uint64_t *ptr = (volatile uint64_t *)(long)addr;
+
+	if (sizeof(unsigned long) == 4) {
+		unsigned long flags;
+		uint64_t tmp;
+
+		local_irq_save(flags);
+		__asm__ __volatile__(
+			".set	push"			"\n\t"
+			".set	mips64"			"\n\t"
+			"dsll32	%L0, %L0, 0"		"\n\t"
+			"dsrl32	%L0, %L0, 0"		"\n\t"
+			"dsll32	%M0, %M0, 0"		"\n\t"
+			"or	%L0, %L0, %M0"		"\n\t"
+			"sd	%L0, %2"		"\n\t"
+			".set	pop"			"\n"
+			: "=r" (tmp)
+			: "0" (val), "m" (*ptr));
+		local_irq_restore(flags);
+	} else
+		*ptr = val;
+}
+
+/* IRT and h/w interrupt routines */
+
+inline void nlm_pic_write_irt(uint64_t base, int irt_num, int en,
+		int nmi, int sch, int vec, int dt, int db, int dte)
+{
+	uint64_t val;
+
+	val = (((uint64_t)en & 0x1) << 31) | ((nmi & 0x1) << 29) |
+			((sch & 0x1) << 28) | ((vec & 0x3f) << 20) |
+			((dt & 0x1) << 19) | ((db & 0x7) << 16) |
+			(dte & 0xffff);
+
+	nlm_write_pic_reg(base, PIC_IRT(irt_num), val);
+}
+
+inline void
+nlm_pic_write_irt_direct(uint64_t base, int irt_num, int en, int nmi,
+	int sch, int vec, int cpu)
+{
+	nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
+		(cpu >> 4),		/* thread group */
+		1 << (cpu & 0xf));	/* thread mask */
+}
+
+inline void
+nlm_pic_set_timer(uint64_t base, int timer, uint64_t value, int irq, int cpu)
+{
+	uint64_t pic_ctrl;
+	int en, nmi;
+
+	en = nmi = 0;
+	if (irq > 0)
+		en = 1;
+	else if (irq < 0) {
+		en = nmi = 1;
+		irq = -irq;
+	}
+	nlm_write_pic_reg(base, PIC_TIMER_MAXVAL(timer), value);
+	nlm_pic_write_irt_direct(base, PIC_IRT_TIMER_INDEX(timer),
+		en, nmi, 0, irq, cpu);
+
+	/* enable the timer */
+	pic_ctrl = nlm_read_pic_reg(base, PIC_CTRL);
+	pic_ctrl |= (1 << (PIC_CTRL_STE + timer));
+	nlm_write_pic_reg(base, PIC_CTRL, pic_ctrl);
+}
+
+static void nlm_config_cpu(void *data)
+{
+	write_c0_scratch(2, (u64 *)data);
+}
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof_asm.S b/drivers/misc/netlogic/nmiprof/nmiprof_asm.S
new file mode 100644
index 0000000..44da885
--- /dev/null
+++ b/drivers/misc/netlogic/nmiprof/nmiprof_asm.S
@@ -0,0 +1,39 @@
+#include <linux/init.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/asmmacro.h>
+#include <asm/addrspace.h>
+
+	.set	noreorder
+	.set	mips64r2
+	.set	noat
+
+FEXPORT(nlm_nmiprof)
+	dmtc0	k0, CP0_DIAGNOSTIC, 6
+	dmtc0	k1, CP0_DIAGNOSTIC, 7
+	dmfc0	k0, CP0_DIAGNOSTIC, 2
+	dmfc0	k1, CP0_ERROREPC
+	sw	k1, 0(k0)
+	sw	ra, 4(k0)
+	dextm	k1, k0, 22, 42
+	daddi	k0, 8
+	dinsm	k0, k1, 22, 42
+	dmtc0	k0, CP0_DIAGNOSTIC, 2
+	li	k0, 0xb8004100
+	li	k1, 0x400	/* (1 << PIC_IRT_TIMER_6_INDEX) */
+	sd	k1, (0x10)(k0)	/* (PIC_STATUS * 4)(k0) */
+	li	k1, 0xa		/* PIC_IRT_TIMER_6_INDEX */
+	sd	k1, (0x40)(k0)	/* (PIC_INT_ACK * 4)(k0) */
+	li	k1, 0x00480000	/* set ack mask */
+	mfc0	k0, CP0_STATUS	/* Read status */
+	xor	k0, k1		/* Ack */
+	mtc0	k0, CP0_STATUS	/* Write status */
+	dmfc0	k0, CP0_DIAGNOSTIC, 6
+	dmfc0	k1, CP0_DIAGNOSTIC, 7
+	eret
+	nop
+EXPORT(nlm_nmiprof_end)
diff --git a/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S b/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S
new file mode 100644
index 0000000..cb9e553
--- /dev/null
+++ b/drivers/misc/netlogic/nmiprof/nmiprof_asm_xlr.S
@@ -0,0 +1,42 @@
+#include <linux/init.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/asmmacro.h>
+#include <asm/addrspace.h>
+
+	.set	noreorder
+	.set	mips64r2
+	.set	noat
+
+FEXPORT(nlm_nmiprof)
+	dmtc0	k0, CP0_DIAGNOSTIC, 6
+	dmtc0	k1, CP0_DIAGNOSTIC, 7
+	dmfc0	k0, CP0_DIAGNOSTIC, 2
+	dmfc0	k1, CP0_ERROREPC
+	sw	k1, 0(k0)
+	sw	ra, 4(k0)
+	dsrl	k1, k0, 22
+	dsll	k1, k1, 22
+	daddi	k0, 8
+	dsll32	k0, k0, 10
+	dsrl32	k0, k0, 10
+	or	k0, k0, k1
+	dmtc0	k0, CP0_DIAGNOSTIC, 2
+	li	k0, 0xb8004100
+	li	k1, 0x400	/* (1 << PIC_IRT_TIMER_6_INDEX) */
+	sd	k1, (0x10)(k0)	/* (PIC_STATUS * 4)(k0) */
+	li	k1, 0xa		/* PIC_IRT_TIMER_6_INDEX */
+	sd	k1, (0x40)(k0)	/* (PIC_INT_ACK * 4)(k0) */
+	li	k1, 0x00480000	/* set ack mask */
+	mfc0	k0, CP0_STATUS	/* Read status */
+	xor	k0, k1		/* Ack */
+	mtc0	k0, CP0_STATUS	/* Write status */
+	dmfc0	k0, CP0_DIAGNOSTIC, 6
+	dmfc0	k1, CP0_DIAGNOSTIC, 7
+	eret
+	nop
+EXPORT(nlm_nmiprof_end)
-- 
1.7.1

