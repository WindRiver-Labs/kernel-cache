From 6dbfc9390d3c25380ae6f5bd23dcc7b4d0f1b375 Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Date: Wed, 8 May 2013 13:16:17 +0530
Subject: FMN: Initail patch for xlp9xx

Signed-off-by: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index 815448d..7cc7c89 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -287,12 +287,12 @@ static uint16_t *vc_to_handle = vc_to_handle_map;
 void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code,
 		   uint64_t msg0, uint64_t msg1, uint64_t msg2, uint64_t msg3, void *dev_id)
 {
-#if 0
+//#if 0
 	printk("[%s]: No Handler for message from stn_id=%d, bucket=%d, "
 	       "size=%d, msg0=%llx, msg1=%llx dropping message\n",
 	       __FUNCTION__, src_id, vc, size,
 	       (unsigned long long)msg0, (unsigned long long)msg1);
-#endif
+//#endif
 }
 
 /******************************************************************************************
@@ -969,6 +969,9 @@ static int __init on_chip_init(void)
 {
 	int i = 0, j = 0;
 	u8 node;
+#if defined(CONFIG_NLM_XLP9XX_IO)
+        uint32_t fmn_bar;
+#endif
 
 	fdt = initial_boot_params;
 	if (fdt == NULL) {
@@ -999,7 +1002,34 @@ static int __init on_chip_init(void)
 	msgring_registered.value = 0;
 #endif
 
+#ifdef CONFIG_NLM_XLP9XX
+	xlp_io_base = KSEG1 + 0x18000000;
+	xlp_sys_base[0] = (xlp_io_base | (1 << 20) | XLP_CFG_BASE(0, XLP9XX_SYS)) & 0x1fffffff;
+
+#ifdef CONFIG_NLM_XLP9XX_IO
+	/* FIXME: for FMN, let us read the bootloader configured value and set it to the
+	 * correct bar register and initialize xlp_fmn_base properly.
+	 *
+	 * Note the set of bar register will not be needed once bootloader for griffin
+	 * is implemented properly.
+	 */
+
+	/* Need to program the current node, CMU (bus 0, device 0, node id as function number)
+	 * register 0x6. The same format as the BUS number to set the secondary bus number
+	 * and subordinate bus number correctly. The bus number must be in the range for
+	 * the bar register to go through.
+	 */
+	nlm_hal_write_32bit_reg((0x18000000 | (0 << 20) | XLP_CFG_BASE(0, XLP_IO)), 0x6, 0x00ff0100);
+
+	fmn_bar = 0xd0000000;
+	nlm_hal_write_32bit_reg((0x18000000 | (1 << 20) | XLP_CFG_BASE(0, XLP_FMN)), 0x4, fmn_bar);
+	nlm_hal_write_32bit_reg((0x18000000 | (1 << 20) | XLP_CFG_BASE(0, XLP_FMN)), 0x5, 0x0);
+	xlp_fmn_base[0] = 0x9000000000000000ULL | fmn_bar;
+#endif
+
+#else
 	nlm_hal_init();
+#endif
 
 	for (i = 0; i < NR_CPUS; i++)
 		for (j = 0; j < NLM_MAX_COUNTERS; j++)
-- 
1.7.1

