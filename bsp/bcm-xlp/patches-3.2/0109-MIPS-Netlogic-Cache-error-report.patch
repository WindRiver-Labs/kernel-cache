From bce6c71a9286984f8173477b500edf98c3846862 Mon Sep 17 00:00:00 2001
From: Kamlakant Patel <kamlakant.patel@broadcom.com>
Date: Fri, 10 May 2013 12:00:20 +0530
Subject: MIPS: Netlogic: Cache error report

Add cache error reporting for XLR and XLP.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/bridge.h b/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
index 3067f98..1d4bdc0 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
@@ -119,6 +119,7 @@
 #define BRIDGE_TRACEBUF_READ_DATA2	0x5f
 #define BRIDGE_TRACEBUF_READ_DATA3	0x60
 #define BRIDGE_TRACEBUF_STATUS		0x61
+
 #define BRIDGE_ADDRESS_ERROR0		0x62
 #define BRIDGE_ADDRESS_ERROR1		0x63
 #define BRIDGE_ADDRESS_ERROR2		0x64
@@ -173,6 +174,12 @@
 #define BRIDGE_9XX_PCIEIO_LIMIT2	0x67
 #define BRIDGE_9XX_PCIEIO_LIMIT3	0x68
 
+#define BRIDGE_DMC_ECCLOG1		0xdd
+#define BRIDGE_DMC_ECCLOG2		0xde
+
+#define BRIDGE_9XX_DMC_ECCLOG1		0x15d
+#define BRIDGE_9XX_DMC_ECCLOG2		0x15e
+
 #ifndef __ASSEMBLY__
 
 #define nlm_read_bridge_reg(b, r)	nlm_read_reg(b, r)
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
index a06b592..ac6e979 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
@@ -49,13 +49,25 @@
 #define IFU_BRUB_RESERVE	0x007
 
 #define ICU_DEFEATURE		0x100
+#define ICU_CERR_LOG0		0x110
+#define ICU_CERR_LOG1		0x111
+#define ICU_CERR_LOG2		0x112
 
 #define LSU_DEFEATURE		0x304
 #define LSU_DEBUG_ADDR		0x305
 #define LSU_DEBUG_DATA0		0x306
-#define LSU_CERRLOG_REGID	0x309
+#define LSU_CERR_LOG0		0x308
+#define LSU_CERR_LOG1		0x309
+#define LSU_CERR_INJ0		0x30a
+#define LSU_CERR_INJ1		0x30b
+#define LSU_CERR_INT		0x30c
 #define SCHED_DEFEATURE		0x700
 
+/* L2 Cache Error Registers */
+#define SCU_CERR_LOG0		0x810
+#define SCU_CERR_LOG1		0x811
+#define SCU_CERR_LOG2		0x812
+
 /* Offsets of interest from the 'MAP' Block */
 #define MAP_THREADMODE			0x00
 #define MAP_EXT_EBASE_ENABLE		0x04
diff --git a/arch/mips/include/asm/netlogic/xlr/bridge.h b/arch/mips/include/asm/netlogic/xlr/bridge.h
index 2d02428..2a7b840 100644
--- a/arch/mips/include/asm/netlogic/xlr/bridge.h
+++ b/arch/mips/include/asm/netlogic/xlr/bridge.h
@@ -72,13 +72,20 @@
 #define BRIDGE_PCIXMEM_BAR		35
 #define BRIDGE_PCIXIO_BAR		36
 #define BRIDGE_DEVICE_MASK		37
+
+#define BRIDGE_AERR_INTR_LOG1		38
+#define BRIDGE_AERR_VALID_MASK		0x1
+#define BRIDGE_AERR_STAT_MASK		0x70
+#define BRIDGE_AERR_DEVID_MASK		0x1f00
+#define BRIDGE_AERR_CMD_MASK		0x70000
+
 #define BRIDGE_AERR_INTR_LOG1		38
 #define BRIDGE_AERR_INTR_LOG2		39
 #define BRIDGE_AERR_INTR_LOG3		40
 #define BRIDGE_AERR_DEV_STAT		41
-#define BRIDGE_AERR1_LOG1		42
-#define BRIDGE_AERR1_LOG2		43
-#define BRIDGE_AERR1_LOG3		44
+#define BRIDGE_AERR1_INTR_LOG1		42
+#define BRIDGE_AERR1_INTR_LOG2		43
+#define BRIDGE_AERR1_INTR_LOG3		44
 #define BRIDGE_AERR1_DEV_STAT		45
 #define BRIDGE_AERR_INTR_EN		46
 #define BRIDGE_AERR_UPG			47
@@ -100,5 +107,4 @@
 #define BRIDGE_SCRATCH1			61
 #define BRIDGE_SCRATCH2			62
 #define BRIDGE_SCRATCH3			63
-
 #endif
diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index 63f8c54..ce913cc 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -17,8 +17,8 @@ obj-$(CONFIG_CPU_R8000)		+= c-r4k.o cex-gen.o tlb-r8k.o
 obj-$(CONFIG_CPU_SB1)		+= c-r4k.o cerr-sb1.o cex-sb1.o tlb-r4k.o
 obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o tlb-r3k.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON) += c-octeon.o cex-oct.o tlb-r4k.o
-obj-$(CONFIG_CPU_XLR)		+= c-netlogic.o tlb-r4k.o cex-gen.o
-obj-$(CONFIG_CPU_XLP)		+= c-netlogic.o tlb-r4k.o cex-gen.o
+obj-$(CONFIG_CPU_XLR)		+= c-netlogic.o tlb-r4k.o cex-netlogic.o
+obj-$(CONFIG_CPU_XLP)		+= c-netlogic.o tlb-r4k.o cex-netlogic.o
 
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)	+= sc-r5k.o
diff --git a/arch/mips/mm/c-netlogic.c b/arch/mips/mm/c-netlogic.c
index f0b6e74..c4ba549 100644
--- a/arch/mips/mm/c-netlogic.c
+++ b/arch/mips/mm/c-netlogic.c
@@ -233,6 +233,13 @@ static void coherency_setup(void)
 	change_c0_config(CONF_CM_CMASK, cca);
 }
 
+static void __cpuinit cache_error_setup(void)
+{
+	extern char except_vec2_nlm;
+
+	set_uncached_handler(0x100, &except_vec2_nlm, 0x80);
+}
+
 void __cpuinit nlm_cache_init(void)
 {
 	/* update cpu_data */
@@ -304,5 +311,5 @@ void __cpuinit nlm_cache_init(void)
 
 	nlm_local_flush_icache();
 	coherency_setup();
-	board_cache_error_setup = NULL;
+	board_cache_error_setup = cache_error_setup;
 }
diff --git a/arch/mips/mm/cex-netlogic.S b/arch/mips/mm/cex-netlogic.S
new file mode 100644
index 0000000..6fa8bbe
--- /dev/null
+++ b/arch/mips/mm/cex-netlogic.S
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013 Broadcom Corporation
+ *
+ * Based on cex-gen.S
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995 - 1999 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ *
+ * Cache error handler
+ */
+#include <asm/asm.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+
+LEAF(except_vec2_nlm)
+	.set	noreorder
+	.set	noat
+	/*
+	 * If this is not a hardware problems but an address error from
+	 * the Bridge, which comes in as cache error, we need to dump
+	 * information
+	 */
+	j	nlm_handle_cache_err	/* this would remain in KSEG1 */
+	nop
+END(except_vec2_nlm)
+
+LEAF(nlm_handle_cache_err)
+	.set    push
+	.set    noreorder
+	.set    noat
+
+	/* Try to leave a good crash dump before you die */
+	mfc0	k0, CP0_STATUS
+	li	k1, ST0_IE | ST0_ERL
+	or	k0, k1
+	xor	k0, k1
+	mtc0	k0, CP0_STATUS
+
+	SAVE_ALL
+	move	a0, sp
+	PTR_LA	a1, nlm_cache_error
+	jalr	a1
+	nop
+
+	.set pop
+END(nlm_handle_cache_err)
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 43ca744..bcf3a18 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -1,4 +1,4 @@
-obj-y				+= setup.o nlm_hal.o dt.o
+obj-y				+= setup.o nlm_hal.o dt.o c-xlp.o
 obj-$(CONFIG_SMP)		+= wakeup.o
 obj-$(subst m,y,$(CONFIG_USB))	+= usb-init.o
 obj-$(subst m,y,$(CONFIG_USB))	+= usb-init-xlp2.o
diff --git a/arch/mips/netlogic/xlp/c-xlp.c b/arch/mips/netlogic/xlp/c-xlp.c
new file mode 100644
index 0000000..5efabd3
--- /dev/null
+++ b/arch/mips/netlogic/xlp/c-xlp.c
@@ -0,0 +1,428 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlp-hal/cpucontrol.h>
+#include <asm/netlogic/xlp-hal/bridge.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+/* Bridge error masks and shifts */
+#define XLP9XX_REQ_SRC_SHIFT		7
+#define XLP9XX_REQ_SRC_MASK		0xfff
+
+#define REQ_SRC_NODE_MASK		0x7
+#define REQ_SRC_ID_SHIFT		3
+#define REQ_SRC_ID_MASK			0x3
+#define REQ_SRC_RX_SHIFT		5
+#define REQ_SRC_RX_MASK			0x1
+#define REQ_SRC_PCIE_FN_MASK		0x7
+#define REQ_SRC_PCIE_DEV_SHIFT		3
+#define REQ_SRC_PCIE_DEV_MASK		0x1f
+#define REQ_SRC_TYPE_SHIFT		8
+#define REQ_SRC_TYPE_MASK		0x1
+#define REQ_SRC_AGENT_SHIFT		9
+#define REQ_SRC_AGENT_MASK		0x7
+#define REQ_SRC_CPU_MASK		0x000
+#define SRC_CPU_ID_MASK			0x1ff
+#define REQ_SRC_NBU_MASK		0x001
+#define SRC_NBU_TYPE_SHIFT		7
+#define SRC_NBU_TYPE_MASK		0x3
+#define SRC_TXVC_SHIFT			6
+#define SRC_TXVC_MASK			0x1
+#define SRC_RXVC_SHIFT			5
+#define SRC_RXVC_MASK			0x1
+#define SRC_NBU_TILE_MASK		0x7
+#define REQ_SRC_DMC_MASK		0x010
+#define SRC_DMC_TILE_MASK		0x3
+#define REQ_SRC_IO_MASK			0x011
+#define REQ_SRC_GCU_MASK		0x100
+
+#define ERR_VALID_MASK			0x4
+#define ERR_OV_MASK			0x8
+#define REQ_TYPE_SHIFT			4
+#define REQ_TYPE_MASK			0x70
+#define REQ_SRC_SHIFT			7
+#define REQ_SRC_MASK			0x780
+
+
+#define XLP9XX_TARGET_ID		0xc3
+#define XLP9XX_TARGETID_MASK		0xffffffe7
+
+/* ICU error masks and shifts */
+#define ICU_CERR_VALID_MASK	0xf
+#define ICU_CERR_OPTYPE_SHIFT	6
+#define ICU_CERR_OPTYPE_MASK	0x7
+#define ICU_CERR_ERRTYPE_SHIFT	9
+#define ICU_CERR_ERRTYPE_MASK	0x7
+#define ICU_CERR_INFO_SHIFT	12
+#define ICU_CERR_INFO_MASK	0xf
+
+/* L2 error masks and shifts */
+#define SCU_OP_TYP_SHIFT	4
+#define SCU_OP_TYP_MASK		0x3
+#define SCU_ERR_TYP_SHIFT	8
+#define SCU_ERR_TYP_MASK	0x3
+
+/* L3 Cache Error Registers */
+#define TCU_ERR_LOG0		0x99
+#define TCU_OP_TYPE_SHIFT	4
+#define TCU_OP_TYPE_MASK	0x7
+
+#define TCU_ERR_LOG1		0x9a
+#define TCU_ERR_LOG2		0x9b
+
+#define XLP9XX_TCU_ERR_LOG0	0xfc
+#define XLP9XX_TCU_ERR_LOG1	0xfd
+#define XLP9XX_TCU_ERR_LOG2	0xfe
+
+static void xlp9xx_err_info(uint32_t aerr_reg)
+{
+	uint32_t err_val;
+	int val;
+	char *err_id[] = {"Request", "Snoop", "Self Snoop"};
+	char *nbu_err[] = {"Flush", "MUnit", "L3", "Snoop Queue"};
+
+	err_val = (aerr_reg >> XLP9XX_REQ_SRC_SHIFT) &
+		XLP9XX_REQ_SRC_MASK;
+	pr_err("Error Source Info:\n");
+	pr_err("\tNode ID\t\t: %d\n", err_val & REQ_SRC_NODE_MASK);
+	pr_err("\tPCIe Func\t: %d\n", err_val & REQ_SRC_PCIE_FN_MASK);
+
+	val = (err_val >> REQ_SRC_ID_SHIFT) & REQ_SRC_ID_MASK;
+	pr_err("\tID\t\t: %s", val < 3 ? err_id[val] : "Unknown");
+
+	val = (err_val >> REQ_SRC_RX_SHIFT) & REQ_SRC_RX_MASK;
+	pr_err("\tOperation\t: %s\n", val ? "RX" : "TX");
+
+	val = (err_val >> REQ_SRC_PCIE_DEV_SHIFT) &
+		REQ_SRC_PCIE_DEV_MASK;
+	pr_err("\tPCIe Device\t: %x", val);
+
+	val = (err_val >> REQ_SRC_TYPE_SHIFT) & REQ_SRC_TYPE_MASK;
+	pr_err("\tType\t\t: %s\n", val ? "Slave" : "Master");
+
+	val = (err_val >> REQ_SRC_AGENT_SHIFT) & REQ_SRC_AGENT_MASK;
+	pr_err("Error Agent:\n");
+	switch (val) {
+	case REQ_SRC_CPU_MASK:
+		pr_err("\tCPU ID\t\t: %x", err_val & SRC_CPU_ID_MASK);
+		break;
+	case REQ_SRC_NBU_MASK:
+		val = (err_val >> SRC_NBU_TYPE_SHIFT) & SRC_NBU_TYPE_MASK;
+		pr_err("\tNBU:\n");
+		pr_err("\t\tType\t\t: %s\n",
+				val < 4 ? nbu_err[val] : "Unknown");
+
+		val = (err_val >> SRC_TXVC_SHIFT) & SRC_TXVC_MASK;
+		if (val)
+			pr_err("\t\tTX_VC\n");
+
+		val = (err_val >> SRC_RXVC_SHIFT) & SRC_RXVC_MASK;
+		if (val)
+			pr_err("\t\tRX_VC\n");
+
+		val = err_val & SRC_NBU_TILE_MASK;
+		pr_err("\t\tNBU Tile ID\t: %x\n", val);
+
+		break;
+	case REQ_SRC_DMC_MASK:
+		val = err_val & SRC_DMC_TILE_MASK;
+		pr_err("\tDMC tile ID\t: %x\n", val);
+		break;
+	case REQ_SRC_IO_MASK:
+		pr_err("\tIO\n");
+		break;
+	case REQ_SRC_GCU_MASK:
+		pr_err("\tGCU\n");
+		break;
+	default:
+		pr_err("\tUnknown\n");
+	}
+}
+
+static void xlp_address_err(uint32_t aerr_reg)
+{
+	uint32_t val;
+	char *err[] = {"Invalidate", "Read", "Read Excl", "Read Upgrade",
+			"Writeback", "I/O Read", "I/O write", "I/O Read Excl",
+			"L3 cache", "DRAM", "I/O", "GCU", "IODI"};
+
+	if (aerr_reg & ERR_OV_MASK)
+		pr_err("\tErr Ov\t\t: BAR address overflow\n");
+
+	val = (aerr_reg & REQ_TYPE_MASK) >> REQ_TYPE_SHIFT;
+	pr_err("\tReq Type\t: %s\n", (val < 8) ? err[val] : "Unknown");
+
+	if (cpu_is_xlp9xx())
+		xlp9xx_err_info(aerr_reg);
+	else {
+		val = (aerr_reg & REQ_SRC_MASK) >> REQ_SRC_SHIFT;
+		if (val >= 0 && val < 8)
+			pr_err("\tSource\t\t: Core [%d]\n", val);
+		else
+			pr_err("\tSource\t\t: %s",
+					(val <= 12) ? err[val] : "Unknown");
+	}
+}
+
+static void check_icu_error(void)
+{
+	uint32_t icu_err_log0, icu_err_log1, icu_err_log2;
+	int val;
+
+	icu_err_log0 = nlm_mfcr(ICU_CERR_LOG0);
+	icu_err_log1 = nlm_mfcr(ICU_CERR_LOG1);
+	icu_err_log2 = nlm_mfcr(ICU_CERR_LOG2);
+
+	if (icu_err_log0 & 0xF) {
+		pr_err("Processor Control Registers:\n");
+		pr_err("\tICU LOG0\t: 0x%x\n", icu_err_log0);
+		val = (icu_err_log0 >> ICU_CERR_OPTYPE_SHIFT) &
+				ICU_CERR_OPTYPE_MASK;
+		if (!val)
+			pr_err("\tOp Type\t: Read Access\n");
+		val = (icu_err_log0 >> ICU_CERR_ERRTYPE_SHIFT) &
+				ICU_CERR_ERRTYPE_MASK;
+		if (!val)
+			pr_err("\tError Type\t: Single-Bit\n");
+		val = (icu_err_log0 >> ICU_CERR_INFO_SHIFT) &
+				ICU_CERR_INFO_MASK;
+		if (!val)
+			pr_err("\tError Info\t: L1 tag RAM\n");
+		if (val == 1)
+			pr_err("\tError Info\t: L1 data RAM\n");
+
+		pr_err("\tBad Physical Address : 0x%llx\n",
+			(((uint64_t)icu_err_log2 & 0xff) << 32) | icu_err_log1);
+	}
+}
+
+static void check_lsu_error(void)
+{
+	uint64_t lsu_cerr_log1;
+	uint32_t lsu_cerr_log0;
+
+	lsu_cerr_log0 = nlm_mfcr(LSU_CERR_LOG0);
+	lsu_cerr_log1 = nlm_mfcr(LSU_CERR_LOG1);
+
+	if (lsu_cerr_log0 & 0xf) {
+		pr_err("Processor Control Registers:\n");
+		pr_err("\nLSU_CERR_LOG0\t:0x%x (error valid)\n", lsu_cerr_log0);
+		pr_err("\tValid\t:0x%x", (lsu_cerr_log0 & 0xf));
+
+		if (lsu_cerr_log0 & BIT(4))
+			pr_err("\tOv\t: Overflow");
+		if (lsu_cerr_log0 & BIT(5))
+			pr_err("\tUc\t: Uncorrectable error");
+		if (!(lsu_cerr_log0 & BIT(6)))
+			pr_err("\tOpType\t: Read");
+		if (!(lsu_cerr_log0 & BIT(10)))
+			pr_err("\tError Type\t: Parity error");
+		if ((lsu_cerr_log0 & BIT(11)))
+			pr_err("\tError Info\t: L1 Data");
+		else
+			pr_err("\tError Info\t: L1 Tag");
+
+		pr_err("Error Physical Address\t: 0x%llx\n", lsu_cerr_log1);
+	}
+}
+
+static void check_scu_error(void)
+{
+	uint32_t scu_log0, scu_log1, scu_log2;
+
+	scu_log0 = nlm_mfcr(SCU_CERR_LOG0);
+	scu_log1 = nlm_mfcr(SCU_CERR_LOG1);
+	scu_log2 = nlm_mfcr(SCU_CERR_LOG2);
+
+	if (scu_log0 & 0x1) {
+		int val;
+		char *err1;
+		char *err[] = {"Load", "Probe", "Store", "Load fill",
+				"Store fill", "Evict Compl"};
+
+		pr_err("SCU[L2] Error Registers:\n");
+		pr_err("\tL2_ERROR_LOG0\t: 0x%x\n", scu_log0);
+
+		val = (scu_log0 >> SCU_OP_TYP_SHIFT) & SCU_OP_TYP_MASK;
+		pr_err("\tOp type\t\t: %s\n", err[val]);
+
+		val = (scu_log0 >> SCU_ERR_TYP_SHIFT) & SCU_ERR_TYP_MASK;
+		if (!val)
+			err1 = "Single-bit Tag RAM";
+		if (val == 1)
+			err1 = "Double-bit Tag RAM";
+		if (val == 2)
+			err1 = "valid Array parity";
+		if (val == 3)
+			err1 = "Single-bit Data RAM";
+		if (val == 4)
+			err1 = "Double-bit Data RAM";
+		if (val == 5)
+			err1 = "DRAM ECC";
+		if (val == 6)
+			err1 = "Evict Compl";
+		pr_info("\tError Type\t: %s\n", err1);
+
+		pr_err("\tSCU Error Address\t: 0x%llx\n",
+			(((uint64_t)scu_log2 & 0xff) << 32) | scu_log1);
+	}
+}
+
+static void check_tcu_error(void)
+{
+	uint64_t base;
+	uint32_t tcu_log0, tcu_log1, tcu_log2;
+
+	base = nlm_get_bridge_regbase(nlm_nodeid());
+	if (cpu_is_xlp9xx()) {
+		tcu_log0 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG0);
+		tcu_log1 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG1);
+		tcu_log2 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG2);
+	} else {
+		tcu_log0 = nlm_read_bridge_reg(base, TCU_ERR_LOG0);
+		tcu_log1 = nlm_read_bridge_reg(base, TCU_ERR_LOG1);
+		tcu_log2 = nlm_read_bridge_reg(base, TCU_ERR_LOG2);
+	}
+
+	if (tcu_log0 & 0x1) {
+		int val;
+		char *err[] = { "Read", "Write", "MSG"};
+		pr_err("TCU[L3] Error Registers:\n");
+		pr_err("\tL3_ERROR_LOG0\t: 0x%x\n", tcu_log0);
+		if (tcu_log0 & BIT(1))
+			pr_err("\tOv\t\t: Overflow\n");
+		if (tcu_log0 & BIT(2))
+			pr_err("\tErr Type\t: Uncorrectable\n");
+
+		val = (tcu_log0 >> TCU_OP_TYPE_SHIFT) & TCU_OP_TYPE_MASK;
+		pr_err("\tOperation Type\t: %s\n",
+				val < 3 ? err[val] : "Unknown");
+
+		if (cpu_is_xlp9xx())
+			pr_err("\tTCU LOG1: 0x%x, LOG2: 0x%x\n",
+					tcu_log1, tcu_log2);
+		else
+			pr_err("\tTCU Error Address\t: 0x%llx\n",
+				(((uint64_t)tcu_log2 & 0xff) << 32) | tcu_log1);
+	}
+}
+
+static void check_nbu_error(void)
+{
+	uint64_t base, add_reg2;
+	uint32_t add_reg0, add_reg1;
+
+	base = nlm_get_bridge_regbase(nlm_nodeid());
+	if (cpu_is_xlp9xx()) {
+		add_reg0 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR0);
+		add_reg1 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR1);
+		add_reg2 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR2);
+	} else {
+		add_reg0 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR0);
+		add_reg1 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR1);
+		add_reg2 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR2);
+	}
+
+	if (add_reg0 & ERR_VALID_MASK) {
+		pr_err("Adress Error Registers:");
+		pr_err("\tADDRESS_ERROR0\t: 0x%x (error valid)\n", add_reg0);
+
+		xlp_address_err(add_reg0);
+		pr_err("\tBad Physical Address : 0x%llx\n",
+			(((uint64_t)add_reg2 & 0xff) << 32) | add_reg1);
+	}
+}
+
+static void check_dram_error(void)
+{
+	uint64_t nlm_io_base;
+	uint32_t dram_err_reg0, dram_err_reg1;
+	int i, ctrls;
+
+	ctrls = (read_c0_prid() & 0xff00) == PRID_IMP_NETLOGIC_XLP3XX ? 2 : 4;
+
+	nlm_io_base = nlm_get_bridge_regbase(nlm_nodeid());
+	for (i = 0; i < ctrls; i++) {
+		if (cpu_is_xlp9xx()) {
+			/* write target ID */
+			uint32_t id = nlm_read_bridge_reg(nlm_io_base,
+					XLP9XX_TARGET_ID);
+			nlm_write_bridge_reg(nlm_io_base, XLP9XX_TARGET_ID,
+					(id & XLP9XX_TARGETID_MASK) | (i << 3));
+
+			dram_err_reg0 = nlm_read_bridge_reg(nlm_io_base,
+					BRIDGE_9XX_DMC_ECCLOG1);
+			dram_err_reg1 = nlm_read_bridge_reg(nlm_io_base,
+					BRIDGE_9XX_DMC_ECCLOG2);
+		} else {
+			dram_err_reg0 = nlm_read_bridge_reg(nlm_io_base,
+					i * 0x80 + BRIDGE_DMC_ECCLOG1);
+			dram_err_reg1 = nlm_read_bridge_reg(nlm_io_base,
+					i * 0x80 + BRIDGE_DMC_ECCLOG2);
+		}
+
+		if (dram_err_reg0 & 0x1) {
+			pr_err("DRAM Registers (channel %d):\n", i);
+			pr_err("\tDRAM ECC LOG0: 0x%x, LOG1: 0x%x\n",
+					dram_err_reg0, dram_err_reg1);
+		}
+	}
+}
+asmlinkage void nlm_cache_error(struct pt_regs *regs)
+{
+	unsigned long errepc;
+
+	errepc = read_c0_errorepc();
+	pr_err("Cache Error Exception:\n");
+
+	check_icu_error();	/* ICU	*/
+	check_lsu_error();	/* LSU	*/
+	check_scu_error();	/* L2	*/
+	check_tcu_error();	/* L3	*/
+	check_nbu_error();	/* NBU	*/
+	check_dram_error();	/* DRAM */
+
+	pr_err("CPU [%d]: ErrorEPC 0x%lx EPC 0x%lx\n",
+			read_c0_ebase() & 0x3ff, errepc, regs->cp0_epc);
+
+	/* move ErrorEPC to EPC for better log */
+	regs->cp0_epc = errepc;
+	die("Cache error exception", regs);
+}
diff --git a/arch/mips/netlogic/xlr/Makefile b/arch/mips/netlogic/xlr/Makefile
index 05902bc..345e687 100644
--- a/arch/mips/netlogic/xlr/Makefile
+++ b/arch/mips/netlogic/xlr/Makefile
@@ -1,2 +1,2 @@
-obj-y			+=  fmn.o fmn-config.o setup.o platform.o platform-flash.o
+obj-y			+=  fmn.o fmn-config.o setup.o platform.o platform-flash.o c-xlr.o
 obj-$(CONFIG_SMP)	+= wakeup.o
diff --git a/arch/mips/netlogic/xlr/c-xlr.c b/arch/mips/netlogic/xlr/c-xlr.c
new file mode 100644
index 0000000..35d8f3f
--- /dev/null
+++ b/arch/mips/netlogic/xlr/c-xlr.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <asm/uaccess.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlr/bridge.h>
+
+/* XLR Cache Error log registers */
+#define CACHE_ERROR_LOG         0x309
+#define CACHE_ERROR_OVF_LOG     0x30a
+
+static void xlr_system_bridge_err(uint32_t aerr_log)
+{
+	uint32_t err_val;
+	char *err_msg;
+
+	if (aerr_log & BRIDGE_AERR_STAT_MASK) {
+		err_val = aerr_log & BRIDGE_AERR_STAT_MASK;
+		switch (ffs(err_val)) {
+		case 5:
+			err_msg = "L2 Tag";
+			break;
+		case 6:
+			err_msg = "L1 Tag";
+			break;
+		case 7:
+			err_msg = "System Bridge Controller";
+			break;
+		default:
+			err_msg = "Unknown";
+		}
+		pr_err("\t\tDetected by\t: %s [AERR_STATE %#x]\n", err_msg,
+				(unsigned)err_val);
+	}
+
+	if (aerr_log & BRIDGE_AERR_DEVID_MASK) {
+		err_val = (aerr_log & BRIDGE_AERR_DEVID_MASK) >> 8;
+
+		if (err_val >= 0 && err_val < 8)
+			pr_err("\t\tDevice\t: CPU %d [AERR_DEVID 0x%x]\n",
+				err_val, (aerr_log & BRIDGE_AERR_DEVID_MASK));
+		else if (err_val >= 8 && err_val < 16)
+			pr_err("\t\tDevice\t: L2[%d] [AERR_DEVID 0x%x]\n",
+				err_val, (aerr_log & BRIDGE_AERR_DEVID_MASK));
+		else {
+			switch (err_val) {
+			case 17:
+				err_msg = "XGSA";
+				break;
+			case 18:
+				err_msg = "XGSB";
+				break;
+			case 19:
+				err_msg = "RGMII";
+				break;
+			case 20:
+				err_msg = "SAE";
+				break;
+			case 21:
+				err_msg = "GPIO";
+				break;
+			case 22:
+				err_msg = "PCIX";
+				break;
+			case 23:
+				err_msg = "HT";
+				break;
+			case 24:
+				err_msg = "DMA";
+				break;
+			case 25:
+				err_msg = "CDE";
+				break;
+			case 26:
+				err_msg = "PCIe";
+				break;
+			case 27:
+				err_msg = "USB";
+				break;
+			case 28:
+				err_msg = "GMAC Quad 1 or XAUI_1";
+				break;
+			default:
+				err_msg = "Unknown";
+			}
+			pr_err("\t\tDevice\t: %s\n", err_msg);
+		}
+	}
+	if (aerr_log & BRIDGE_AERR_CMD_MASK) {
+		err_val = (aerr_log & BRIDGE_AERR_CMD_MASK) >> 16;
+		switch (err_val) {
+		case 0x0:
+			err_msg = "Idle";
+			break;
+		case 0x1:
+			err_msg = "Write";
+			break;
+		case 0x2:
+			err_msg = "Read";
+			break;
+		case 0x3:
+			err_msg = "Read exclusive";
+			break;
+		case 0x4:
+			err_msg = "Upgrade";
+			break;
+		case 0x5:
+			err_msg = "Invalidate";
+			break;
+		case 0x6:
+			err_msg = "Undefined";
+			break;
+		case 0x7:
+			err_msg = "Write error";
+			break;
+		default:
+			err_msg = "Unknown";
+		}
+		pr_err("\t\tMemory operation: %s [AERR_CMD 0x%x]\n",
+			err_msg, err_val);
+	}
+}
+
+asmlinkage void nlm_cache_error(void)
+{
+	uint64_t cache_error_log, aerr0_log2, aerr0_log3, aerr1_log2,
+		 aerr1_log3;
+	uint32_t aerr0_log1, aerr1_log1;
+	char *err_val;
+
+	cache_error_log = nlm_mfcr(CACHE_ERROR_LOG);
+	aerr0_log1 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG1);
+	aerr0_log2 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG2);
+	aerr0_log3 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG3);
+	aerr1_log1 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG1);
+	aerr1_log2 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG2);
+	aerr1_log3 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG3);
+
+	pr_err("Cache Error Exception:\n");
+	pr_err("Processor Control Registers\n");
+
+	if (cache_error_log) {
+		pr_err("CACHE_ERR_LOG\t\t: 0x%x\n",
+				(unsigned)cache_error_log);
+		if (cache_error_log & (1u << 4))
+			err_val = "Load";
+		else if (cache_error_log & (1u << 5))
+			err_val = "Store";
+		else if (cache_error_log & (1u << 6))
+			err_val = "Double Bit Error";
+		else if (cache_error_log & (1u << 7))
+			err_val = "Tag Parity Error";
+		else if (cache_error_log & (1u << 8))
+			err_val = "Address Error";
+		else if (cache_error_log & (1u << 9))
+			err_val = "Data Error";
+		else if ((cache_error_log & (1ull << 55)))
+			err_val = "Dirty Line";
+		else
+			err_val = "Unknown";
+
+		pr_err("\t\tError type\t: %s\n", err_val);
+	}
+
+	pr_err("\t\tError Address\t: 0x%llx\n", ((cache_error_log >> 10) << 3));
+	pr_err("CACHE_ERROR_OVF_LOG\t: 0x%llx\n",
+			nlm_mfcr(CACHE_ERROR_OVF_LOG));
+
+	if (aerr0_log1 & 0x1) {
+		pr_err("System Bridge Controller AERR0 :\n");
+		pr_err("\t\tAERR0 LOG\t: 0x%x (valid)", aerr0_log1);
+		xlr_system_bridge_err(aerr0_log1);
+		pr_err("AERR0 Physical Address   : 0x%llx\n",
+				(aerr0_log2 << 5) | (aerr0_log3 << 37));
+	} else
+		pr_err("\t\tAERR0 LOG\t: 0 (invalid)");
+
+	if (aerr1_log1 & 0x1) {
+		pr_err("System Bridge Controller AERR1 :\n");
+		pr_err("\tAERR1 LOG\t: 0x%x (valid)\n", aerr1_log1);
+		xlr_system_bridge_err(aerr1_log1);
+		pr_err("AERR1 Physical Address   : 0x%llx\n",
+				(aerr1_log2 << 5) | (aerr1_log3 << 37));
+	} else
+		pr_err("\t\tAERR1 LOG\t: 0 (invalid)\n");
+
+	panic("Can't handle cache error exception\n");
+}
-- 
1.7.1

