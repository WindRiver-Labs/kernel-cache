From e66abe65469efb4ab15922781b423935ad807c15 Mon Sep 17 00:00:00 2001
From: ajesh <ajesh@broadcom.com>
Date: Thu, 24 Jul 2014 16:27:41 +0530
Subject: nae: PTP support added for xlp9xx

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge.h b/drivers/net/ethernet/broadcom/nae/xlpge.h
index 9ea61aa..6e14b03 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge.h
@@ -83,12 +83,14 @@
 
 
 /* TODO XXX: default enable prepad */
-#ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
+#ifdef IEEE_1588_PTP_ENABLED
+#define PREPAD_LEN              64
+#elif CONFIG_NLM_ENABLE_LOAD_BALANCING
 #define	PREPAD_LEN			16
-#define	NLM_LOAD_BALANCING_MAGIC	0xdeadbeefU
 #else
 #define	PREPAD_LEN			0
 #endif
+#define	NLM_LOAD_BALANCING_MAGIC	0xdeadbeefU
 #define	ETH_JUMBO_DATA_LEN		16000
 #define	CACHELINE_SIZE			(1ULL << 6)
 #define	SKB_BACK_PTR_SIZE		CACHELINE_SIZE
@@ -139,6 +141,33 @@
 #define	P2P_EXTRA_DESCS			\
 	((PAGE_SIZE / MAX_PACKET_SZ_PER_MSG) + 4)
 
+#ifdef IEEE_1588_PTP_ENABLED
+/* 
+ * Define calls dummy functions as of now,
+ * need to replace the dummy functions with
+ * Kernel APIs for testing.
+ */
+#define nlm_timecounter_init         nlm_nae_timecounter_init
+#define nlm_timecompare_update       nlm_nae_timecompare_update
+#define nlm_ktime_get_real           nlm_nae_ktime_get_real
+#define nlm_timecounter_cyc2time     nlm_nae_timecounter_cyc2time
+#define nlm_timecompare_transform    nlm_nae_timecompare_transform
+#define nlm_skb_tstamp_tx            nlm_nae_skb_tstamp_tx
+
+void nlm_nae_timecounter_init(struct timecounter *tc,
+                              const struct cyclecounter *cc,
+                              u64 start_tstamp);
+void nlm_nae_timecompare_update(struct timecompare *sync,
+                                u64 source_tstamp);
+uint64_t nlm_nae_timecounter_cyc2time(struct timecounter *tc,
+                                  cycle_t cycle_tstamp);
+ktime_t nlm_nae_timecompare_transform(struct timecompare *sync,
+                                   u64 source_tstamp);
+ktime_t nlm_nae_ktime_get_real(void);
+
+void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb);
+
+#endif
 #ifndef __ASSEMBLY__
 /*
  * This macro resets first 164 (offsetof(struct sk_buff, tail))bytes
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index dbf2aaf..7617816 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -51,7 +51,7 @@ int phys_cpu_to_log_map[NLM_MAX_NODES][MAX_NAE_PERNODE][NR_CPUS];
 int lcpu_2_pcpu[NR_CPUS];
 static unsigned int fmem[NR_CPUS];
 int num_cpus_per_node;
-  
+
 uint64_t nlm_mode[NR_CPUS*8] ____cacheline_aligned;
 static struct nlm_nae_linux_shinfo *lnx_shinfo[3];
 uint64_t p2p_dynamic_alloc_cnt[NR_CPUS * 8] __cacheline_aligned;
@@ -1505,7 +1505,43 @@ int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const mac
 	//xlp_dev_mac[node][port] = dev;
 	//xlp_mac_setup_hwaddr(priv);
 
+#ifdef IEEE_1588_PTP_ENABLED
+	switch(node)
+	{
+		case 0:
+			priv->cycles.read = nlm_1588_read_clock0;
+			break;
+		case 1:
+			priv->cycles.read = nlm_1588_read_clock1;
+			break;
+		case 2:
+			priv->cycles.read = nlm_1588_read_clock2;
+			break;
+		case 3:
+			priv->cycles.read = nlm_1588_read_clock3;
+			break;
+		default:
+			nae_print(NAE_DBG_ERROR," PTP init for Wrong node \n");
+			priv->cycles.read = nlm_1588_read_clock0;
+			break;
+	}
+
+    priv->cycles.mask = CLOCKSOURCE_MASK(64);
 
+    if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
+        priv->cycles.mult = 1000/XLP3XX_MAX_NAE_FREQUENCY;
+    else
+        priv->cycles.mult = 0x2;
+
+    priv->cycles.shift = 0;
+    nlm_timecounter_init(&priv->clock, &priv->cycles, ktime_to_ns(nlm_ktime_get_real()));
+
+    memset(&priv->compare, 0, sizeof(priv->compare));
+    priv->compare.source = &priv->clock;
+    priv->compare.target = nlm_ktime_get_real;
+    priv->compare.num_samples = 0;
+    nlm_timecompare_update(&priv->compare,0);
+#endif
 	for (cpu = 0; cpu < NR_CPUS; cpu++)
 		per_cpu_netdev[node][cpu][nae_cfg->nae_id][port] = dev;
 
@@ -1544,7 +1580,7 @@ void nlm_xlp_nae_init(void)
 	}
 
 	nae_print(NAE_DBG_DEFAULT, "======= Module Parameters =========\n");
-	nae_print(NAE_DBG_DEFAULT, "nae debug mask 0x%x\n", nae_debug_level); 
+	nae_print(NAE_DBG_DEFAULT, "nae debug mask 0x%x\n", nae_debug_level);
 	nae_print(NAE_DBG_DEFAULT, "num_descs_per_normalq=%d num_descs_per_jumboq=%d ",
 	       num_descs_per_normalq, num_descs_per_jumboq);
 	nae_print(NAE_DBG_DEFAULT, "perf_mode=%s enable_lro=%d enable_jumbo=%d \n",
@@ -1576,8 +1612,17 @@ void nlm_xlp_nae_init(void)
 			nae_cfg = get_nae(node, num_nae);
 			if (nae_cfg == NULL)
 				continue;
-			for(i = 0; i < nae_cfg->num_ports; i++){
-				nlm_per_port_nae_init(nae_cfg, i, maxnae);
+
+#ifdef IEEE_1588_PTP_ENABLED
+                __netsoc_1588_ptp_clk_sel(nae_cfg, NET_SYS_CLK);
+                __netsoc_reset_1588_accum(nae_cfg);
+                __netsoc_1588_ld_user_val(nae_cfg, 0, 0);
+                __netsoc_1588_ld_freq_mul(nae_cfg, 1000, 1000, 0);
+                __netsoc_prepad_enable(nae_cfg, 64);
+#endif
+
+			for(i = 0; i < nae_cfg->num_ports; i++) {
+				nlm_per_port_nae_init(nae_cfg, i, maxnae, hw_mac_addr);
 				hw_mac_addr[5]++;
 				if(!(nae_cfg->port_fifo_en))
 					netsoc_map_interface_to_lifo(nae_cfg, i, 0xffff);
@@ -1595,8 +1640,8 @@ void nlm_xlp_nae_init(void)
 		nae_print(NAE_DBG_ERROR, "[%s]: Unable to create proc entry for xlp_mac!\n",
 				__func__);
 	}
-	entry = proc_create_data("nae_stats", 
-						0, nlm_root_proc, 
+	entry = proc_create_data("nae_stats",
+						0, nlm_root_proc,
 						&nae_proc_info_ops, 0);
 	if (!entry) {
 		nae_print(NAE_DBG_ERROR, "[%s]: Unable to create proc entry for nae_stats!\n",
@@ -1614,7 +1659,11 @@ void nlm_xlp_nae_init(void)
 #ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
 	if ((perf_mode == NLM_TCP_MODE) && load_balance_en) {
 		nlm_prepad_len = PREPAD_LEN;
+#elif defined(IEEE_1588_PTP_ENABLED)
+		nlm_prepad_len = PREPAD_LEN;
+#endif
 
+#ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
 		entry = create_proc_entry(
 				"load_info",
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_ptp.c b/drivers/net/ethernet/broadcom/nae/xlpge_ptp.c
index e7789f1..5d91bcd 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_ptp.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_ptp.c
@@ -35,54 +35,252 @@
 
 #include "xlpge.h"
 
-static uint64_t acc_1588[NLM_MAX_NODES];
-
 cycle_t nlm_1588_read_clock0(const struct cyclecounter *tc)
 {
-	return acc_1588[0];
+	struct dev_data *priv;
+	nae_t* nae;
+	int32_t val;
+	volatile uint64_t ptplo;
+	volatile uint64_t ptphi;
+	volatile cycle_t ptpval;
+	static cycle_t ptpprev;
+
+	priv = container_of(tc, struct dev_data, cycles);
+	nae = priv->nae;
+	
+	netsoc_write_nae_reg(nae->nae_base, IOSYS_RTC_CMD, 0x1);
+
+	while(((netsoc_read_nae_reg(nae->nae_base, IOSYS_RTC_CMD) & 0x1) == 0x1)) {
+	}
+    
+	ptplo = netsoc_read_nae_reg(nae->nae_base, 0x7c1);
+	nlm_mdelay(1);
+	ptphi = netsoc_read_nae_reg(nae->nae_base, 0x7c2);
+
+	ptpval = (cycle_t)(((ptphi & 0xffffffff) << 32) | (ptplo & 0xffffffff));
+	if(ptpval < ptpprev)
+	{
+		nae_print(NAE_DBG_ERROR, "Read clock0 val %lld prev %lld\n", ptpval, ptpprev);
+	}
+	ptpprev = ptpval;
+	return ptpval;
 }
 
 cycle_t nlm_1588_read_clock1(const struct cyclecounter *tc)
 {
-	return acc_1588[1];
+	struct dev_data *priv;
+    nae_t* nae;
+    int32_t val;
+    volatile uint64_t ptplo;
+    volatile uint64_t ptphi;
+    volatile cycle_t ptpval;
+    static cycle_t ptpprev;
+
+    priv = container_of(tc, struct dev_data, cycles);
+    nae = priv->nae;
+
+    netsoc_write_nae_reg(nae->nae_base, IOSYS_RTC_CMD, 0x1);
+
+    while(((netsoc_read_nae_reg(nae->nae_base, IOSYS_RTC_CMD) & 0x1) == 0x1)) {
+    }
+
+    ptplo = netsoc_read_nae_reg(nae->nae_base, 0x7c1);
+    nlm_mdelay(1);
+    ptphi = netsoc_read_nae_reg(nae->nae_base, 0x7c2);
+
+    ptpval = (cycle_t)(((ptphi & 0xffffffff) << 32) | (ptplo & 0xffffffff));
+    if(ptpval < ptpprev)
+    {
+        nae_print(NAE_DBG_ERROR, "Read clock1 val %lld prev %lld\n", ptpval, ptpprev);
+    }
+    ptpprev = ptpval;
+    return ptpval;
 }
 
 cycle_t nlm_1588_read_clock2(const struct cyclecounter *tc)
 {
-	return acc_1588[2];
+	struct dev_data *priv;
+    nae_t* nae;
+    int32_t val;
+    volatile uint64_t ptplo;
+    volatile uint64_t ptphi;
+    volatile cycle_t ptpval;
+    static cycle_t ptpprev;
+
+    priv = container_of(tc, struct dev_data, cycles);
+    nae = priv->nae;
+
+    netsoc_write_nae_reg(nae->nae_base, IOSYS_RTC_CMD, 0x1);
+
+    while(((netsoc_read_nae_reg(nae->nae_base, IOSYS_RTC_CMD) & 0x1) == 0x1)) {
+    }
+
+    ptplo = netsoc_read_nae_reg(nae->nae_base, 0x7c1);
+    nlm_mdelay(1);
+    ptphi = netsoc_read_nae_reg(nae->nae_base, 0x7c2);
+
+    ptpval = (cycle_t)(((ptphi & 0xffffffff) << 32) | (ptplo & 0xffffffff));
+    if(ptpval < ptpprev)
+    {
+        nae_print(NAE_DBG_ERROR, "Read clock2 val %lld prev %lld\n", ptpval, ptpprev);
+    }
+    ptpprev = ptpval;
+    return ptpval;
 }
 
 cycle_t nlm_1588_read_clock3(const struct cyclecounter *tc)
 {
-	return acc_1588[3];
+	struct dev_data *priv;
+    nae_t* nae;
+    int32_t val;
+    volatile uint64_t ptplo;
+    volatile uint64_t ptphi;
+    volatile cycle_t ptpval;
+    static cycle_t ptpprev;
+
+    priv = container_of(tc, struct dev_data, cycles);
+    nae = priv->nae;
+
+    netsoc_write_nae_reg(nae->nae_base, IOSYS_RTC_CMD, 0x1);
+
+    while(((netsoc_read_nae_reg(nae->nae_base, IOSYS_RTC_CMD) & 0x1) == 0x1)) {
+    }
+
+    ptplo = netsoc_read_nae_reg(nae->nae_base, 0x7c1);
+    nlm_mdelay(1);
+    ptphi = netsoc_read_nae_reg(nae->nae_base, 0x7c2);
+
+    ptpval = (cycle_t)(((ptphi & 0xffffffff) << 32) | (ptplo & 0xffffffff));
+    if(ptpval < ptpprev)
+    {
+        nae_print(NAE_DBG_ERROR, "Read clock3 val %lld prev %lld\n", ptpval, ptpprev);
+    }
+    ptpprev = ptpval;
+    return ptpval;
+}
+
+#ifdef IEEE_1588_PTP_ENABLED
+
+void nlm_nae_timecounter_init(struct timecounter *tc,
+                              const struct cyclecounter *cc,
+	                          u64 start_tstamp)
+{
+	/* 
+	 * dummy function, called using the #define 
+	 * nlm_timecounter_init.
+	 * For testing, need to replace the #define with 
+	 * kernel function 
+	 */
+}
+
+void nlm_nae_timecompare_update(struct timecompare *sync,
+                                u64 source_tstamp)
+{
+	/* 
+     * dummy function, called using the #define
+	 * nlm_timecompare_update.
+     * For testing, need to replace the #define with 
+     * kernel function 
+     */
+
+}
+
+uint64_t nlm_nae_timecounter_cyc2time(struct timecounter *tc,
+		                          cycle_t cycle_tstamp)
+{
+	/* 
+     * dummy function, called using the #define
+	 * nlm_timecounter_cyc2time.
+     * For testing, need to replace the #define with 
+     * kernel function 
+     */
+	return 0;
+}
+
+ktime_t nlm_nae_timecompare_transform(struct timecompare *sync,
+					               u64 source_tstamp)
+{
+	ktime_t ret;
+	/* 
+     * dummy function, called using the #define
+	 * nlm_timecompare_transform.
+     * For testing, need to replace the #define with 
+     * kernel function 
+     */
+	return ret;
 }
 
-#ifdef IEEE_1588_PTP_ENABLED	
-static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb)
+void nlm_nae_skb_tstamp_tx(struct sk_buff *orig_skb,
+						   struct skb_shared_hwtstamps *hwtstamps)
+{
+	/* 
+     * dummy function, called using the #define
+	 * nlm_skb_tstamp_tx.
+     * For testing, need to replace the #define with 
+     * kernel function 
+     */
+
+}
+
+ktime_t nlm_nae_ktime_get_real(void)
+{
+	ktime_t ret;
+	/* 
+     * dummy function, called using the #define
+	 * nlm_ktime_get_real.
+     * For testing, need to replace the #define with 
+     * kernel function 
+     */
+
+	return ret;
+}
+
+void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb)
 {
 	struct skb_shared_hwtstamps shhwtstamps;
-	uint64_t regval;
+	uint64_t regval1, regval2;
+	volatile u64 regval;
 	uint64_t ns;
-	
+	nae_t *nae;
 	
 	struct dev_data *priv = netdev_priv(skb->dev);
 	int if_num = priv->hw_port_id;
 	int node = priv->node;
 
-	memset(&shhwtstamps, 0, sizeof(shhwtstamps));
-	regval = nlm_hal_ptp_timer_lo(node, if_num);
-	regval |= (uint64_t)nlm_hal_ptp_timer_hi(node, if_num)<<32;
-	acc_1588[node] = regval;
-	ns = timecounter_cyc2time(&priv->clock, regval);
+	nae = priv->nae; 
+
+    memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+	
+	switch(node)
+	{
+	case 0:
+		regval = nlm_1588_read_clock0(&priv->cycles);
+		break;
+	case 1:
+		regval = nlm_1588_read_clock1(&priv->cycles);
+		break;
+	case 2:
+		regval = nlm_1588_read_clock2(&priv->cycles);
+		break;
+	case 3:
+		regval = nlm_1588_read_clock3(&priv->cycles);
+		break;
+	default:
+		nae_print(NAE_DBG_ERROR,"nlm_1588_ptp_hwtstamp_tx Called for Invalid node \n");
+		regval = nlm_1588_read_clock0(&priv->cycles);
+		break;
+	}
+    
+	ns = nlm_timecounter_cyc2time(&priv->clock, regval);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
-	timecompare_update(&priv->compare, ns);
+    nlm_timecompare_update(&priv->compare, ns);
 #endif
-	shhwtstamps.hwtstamp = ns_to_ktime(ns);
+    shhwtstamps.hwtstamp = ns_to_ktime(ns);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
-	shhwtstamps.syststamp =	timecompare_transform(&priv->compare, ns);
-#endif
-	skb_tstamp_tx(skb, &shhwtstamps);
-	Message("nlm_1588_ptp_hwtstamp_tx regval=0x%llx ns=0x%llx node=0x%x\n",
-		regval, ns, node);	
+    shhwtstamps.syststamp = nlm_timecompare_transform(&priv->compare, ns);
+#endif	
+    nlm_skb_tstamp_tx(skb, &shhwtstamps);
+    nae_print(NAE_DBG_TRACE, "nlm_1588_ptp_hwtstamp_tx regval=0x%llx ns=0x%llx node=0x%x\n",
+        regval, ns, node);
 }
 #endif 
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
index 4900624..1952213 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_rx.c
@@ -66,7 +66,6 @@ struct dev_data *last_rcvd_priv[NR_CPUS * 8] ____cacheline_aligned;
 #endif
 
 uint64_t receive_count[NR_CPUS * 8] __cacheline_aligned;
-
 //#define MACSEC_DEBUG	1
 
 inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
@@ -104,7 +103,15 @@ inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
 
         if(skb)
         {
-                dev_kfree_skb_any(skb);
+#ifdef IEEE_1588_PTP_ENABLED    
+	        if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE))
+    	    {  
+				nae_print(NAE_DBG_TRACE, "timestamp from tx complete \n");
+        	    nlm_1588_ptp_hwtstamp_tx(skb);
+        	}
+#endif
+			
+            dev_kfree_skb_any(skb);
         }
         else {
                 nae_print(NAE_DBG_ERROR, "[%s]: [txc] Null skb? "
@@ -645,6 +652,12 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 	struct sk_buff* skb;
 	nae_t* nae_cfg;
 	uint32_t msec_port;
+#ifdef IEEE_1588_PTP_ENABLED
+    char *prepad = NULL;
+    uint64_t ns, i;
+	volatile u64 regval;
+    struct skb_shared_hwtstamps *shhwtstamps;
+#endif
 	struct napi_struct *napi = (struct napi_struct *)arg;
 
 	if(nae_family_9xx){
@@ -726,6 +739,36 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 	}
 #endif
 
+#ifdef IEEE_1588_PTP_ENABLED
+    prepad = (char *)skb->data + 56; 
+    //ns = be64_to_cpu (*(unsigned long*)prepad);
+	switch(node)
+	{
+		case 0:
+			regval = nlm_1588_read_clock0(&priv->cycles);
+			break;
+		case 1:
+			regval = nlm_1588_read_clock1(&priv->cycles);
+			break;
+		case 2:
+			regval = nlm_1588_read_clock2(&priv->cycles);
+			break;
+		case 3:
+			regval = nlm_1588_read_clock3(&priv->cycles);
+			break;
+		default:
+			regval = nlm_1588_read_clock0(&priv->cycles);
+			break;
+	}
+    shhwtstamps = skb_hwtstamps(skb);
+    ns = nlm_timecounter_cyc2time(&priv->clock, regval);
+    nlm_timecompare_update(&priv->compare, ns);
+    memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+    shhwtstamps->hwtstamp = ns_to_ktime(ns);
+    shhwtstamps->syststamp = nlm_timecompare_transform(&priv->compare, ns);
+    skb_reserve(skb, PREPAD_LEN);
+#endif
+
 	if (priv->index == XGMAC0)
 		msec_port = (priv->port | 0xf) << (4 * priv->block);
 	else
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tso.h b/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
index 369f30f..0f53755 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tso.h
@@ -35,7 +35,9 @@
 #include <linux/inet_lro.h>
 #include <linux/clocksource.h>
 #include <linux/ethtool.h>
-
+#ifdef IEEE_1588_PTP_ENABLED
+#include <linux/skbuff.h>
+#endif
 #include <nlm_msgring.h>
 #include <nlm_xlp.h>
 #include <nlm_hal_fmn.h>
@@ -161,6 +163,12 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	unsigned long __attribute__ ((unused)) mflags;
 	uint32_t msec_port, send_msec = 0, msec_bypass = 0;
 	uint32_t pad_len = 0, icv_len = 0, param_index = 0;
+#ifdef IEEE_1588_PTP_ENABLED
+    uint64_t msg1;
+    union skb_shared_tx *shtx;
+    int is_skbts = skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE);
+#endif
+
 
 #ifdef MACSEC_DEBUG
 	nae_print(NAE_DBG_TRACE, "nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
@@ -287,6 +295,9 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 				param_index);
 #endif
 		} else{
+#ifdef IEEE_1588_PTP_ENABLED    
+        if(!is_skbts)
+#endif
 			idx = create_p2p_desc(virt_to_bus((char *)skb->data), len,
 			p2pdesc, idx);
 		 }
@@ -308,6 +319,15 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 
 
 	qid = nae_cfg->vfbtbl_sw_offset + (cpu % num_cpus_per_node);
+#ifdef IEEE_1588_PTP_ENABLED
+    if(is_skbts) {
+                p2pdesc[P2P_SKB_OFF] = (uint64_t)skb;
+                msg = nae_tx_desc (P2D_NEOP, qid, 0, virt_to_bus(p2pdesc));
+                msg1 = nae_tx_desc (P2D_EOP, 126, len, virt_to_bus((char *)skb->data));
+        skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+    }else
+#endif
+
 	{
 		create_last_p2p_desc(p2pdesc, skb, idx);
 		msg = nae_tx_desc(DESC_TYPE_P2P, qid, idx, virt_to_bus(p2pdesc));
@@ -323,6 +343,11 @@ retry_send:
 				mscmsg1, msg);
 	else if(skb->ip_summed == CHECKSUM_PARTIAL)
 		ret = xlp_message_send_2(priv->nae_tx_qid, 0, mscmsg0, msg);
+#ifdef IEEE_1588_PTP_ENABLED    
+    else if(is_skbts){
+        ret = xlp_message_send_2(priv->nae_tx_qid, 0, msg, msg1);
+    }
+#endif
 	else if (send_msec || msec_bypass)
 		ret = xlp_message_send_2(priv->nae_tx_qid, 0, mscmsg0, msg);
 	else
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
index 4d99ea3..5cc3e44 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_tx.c
@@ -68,7 +68,10 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	uint32_t msec_port, send_msec = 0;
 	uint32_t pad_len = 0, icv_len = 0, param_index = 0 ;
 	unsigned char *buf, sec_tag_hdr[16], icv[16];
-
+#ifdef IEEE_1588_PTP_ENABLED    
+    union skb_shared_tx *shtx;
+#endif
+	
 	nae_t* nae_cfg = priv->nae;
 
 #ifdef MACSEC_DEBUG
@@ -180,6 +183,15 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			kfree(buf);
 
 		}
+#ifdef IEEE_1588_PTP_ENABLED
+    if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE))
+    {   
+        msg1 = nae_tx_desc (P2D_EOP, 126, skb->len, virt_to_bus((char *)skb->data));
+        skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+    }
+    else
+#endif  
 		msg1 = nae_tx_desc(DESC_TYPE_P2DEOP, NULL_VFBID, skb->len,
 			       virt_to_bus(skb->data));
 	}
-- 
1.7.1

