From 92ede9d2f627c14cdab2994152313bb9c691745c Mon Sep 17 00:00:00 2001
From: Kevin James <kevinj@broadcom.com>
Date: Tue, 11 Mar 2014 23:20:43 -0700
Subject: netlib: Correct PLL reset sequence.

1. Changed bit sequence in txpll reset funtion
2. Re-init Tx PLL after setting PMFIFO bit
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 0860c17..1cfa776 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -1113,6 +1113,8 @@ enum {
 #define SERDES_PRBS_CTRL		0x64
     #define SERDES_LOOPBACK_EN		0x02
 
+#define SER_PHY_RST_OVR			0x66
+
 #define ILK_BURST_MAX           	3 // 256 bytes   
 
 #define XLP_ILK_LANE_RATE_LOW           0       // 0, 19, 0
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index b2bb31e..604885c 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -117,6 +117,22 @@ static inline void nlm_hal_PMFF_ALL_workaround(nae_t *nae, int block, int lane_c
         }
 }
 
+static inline void reinit_tx_pll(nae_t *nae, int block, int lane_ctrl)
+{
+	volatile int val = 0;
+
+	// Do Tx PLL reset
+	val = __netsoc_read_pma_reg(nae, block, lane_ctrl, SER_PHY_RST_OVR);
+	val |= (1<<4);
+	__netsoc_write_pma_reg(nae, block, lane_ctrl, SER_PHY_RST_OVR, val);
+	//Re-init Tx PLL
+	val = (1<<2);
+	__netsoc_write_pma_reg(nae, block, lane_ctrl, SER_PHY_RST_OVR, val);
+	// Remove Tx PLL reset
+	val = 0;
+	__netsoc_write_pma_reg(nae, block, lane_ctrl, SER_PHY_RST_OVR, val);
+}
+
 
 /**
 * @brief xlp8xx_ax_nae_lane_reset_txpll function is used to reset the Tx PLL for XLP8XX-AX products.
@@ -291,18 +307,25 @@ static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t la
         netsoc_write_mac_reg(mac_base, lane_ctrl,val);
         nlm_mdelay(1);
 
-        val = netsoc_read_mac_reg(mac_base, lane_ctrl);
-        val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
-        netsoc_write_mac_reg(mac_base, lane_ctrl,val);
-        nlm_mdelay(1);
-        netsoc_api_print(NETSOC_APIDBG_PORT," After serdes  de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, lane_ctrl));
-
         /* Clear the Power Down bit */
         val = netsoc_read_mac_reg(mac_base, lane_ctrl);
         val &= ~( (1 << 29) | (0x7ffff));
         netsoc_write_mac_reg(mac_base, lane_ctrl, (rext_sel | val));
         nlm_mdelay(1);
 
+	if (mode == PHYMODE_SGMII || mode == PHYMODE_XAUI) {
+		if (is_nlm_xlp3xx()) {
+			nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
+			reinit_tx_pll(nae, block, lane_ctrl);
+		}
+	}
+
+        val = netsoc_read_mac_reg(mac_base, lane_ctrl);
+        val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
+        netsoc_write_mac_reg(mac_base, lane_ctrl,val);
+        nlm_mdelay(1);
+        netsoc_api_print(NETSOC_APIDBG_PORT," After serdes  de-assertion PMA value=0x%x\n", netsoc_read_mac_reg(mac_base, lane_ctrl));
+
         while ((netsoc_read_mac_reg(mac_base, (lane_ctrl - 4)) & (PHY_LANE_STAT_PCR)) != (PHY_LANE_STAT_PCR) && count!=count_max)
         {
                 netsoc_api_print(NETSOC_APIDBG_PORT,"Wait for PMA Ready ..........%d\n", count);
@@ -1056,7 +1079,6 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
                         if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
                                 xlp3xx_8xxb0_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
-                                nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
                         }else if(is_nlm_xlp2xx()){
                                 xlp2xx_lane_reset_txpll(nae, block, lane_ctrl, PHYMODE_SGMII);
 			}
@@ -1570,7 +1592,6 @@ static void xlp_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phym
 
                         if((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())){
                                 xlp3xx_8xxb0_lane_reset_txpll(nae, block, lane_ctrl, phymode);
-                                nlm_hal_PMFF_ALL_workaround(nae, block, lane_ctrl);
                         }else{
                                 xlp8xx_ax_lane_reset_txpll(nae, block, lane_ctrl, phymode);
                         }
-- 
1.7.1

