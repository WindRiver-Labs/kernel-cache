From 2ec0879577add96c48ac222bfed9561154541742 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Thu, 3 Oct 2013 00:01:32 -0700
Subject: xlp9xx-nae: Fix for RX path and XLAUI configuration.

             1) RX buffer and POE configuration fix.
             2) XLAUI pause cofiguration added.
             3) RX credit fix.
             4) Fixed netior XAUI interface credit.
             5) fixed serdes initialization.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
index ad951b7..fc99f91 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_common.h
@@ -72,7 +72,7 @@
 
 #define DEFAULT_XLP9XX_XAUI_IFACEFIFO_SZ	110
 #define DEFAULT_XLP9XX_XAUI_RXFIFO_SZ         	1888
-#define DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ	480
+#define DEFAULT_XLP9XX_XAUI_PARSERSEQFIFO_SZ	480 
 #define DEFAULT_XLP9XX_XAUI_NUM_FREEDESC	300
 
 #define DEFAULT_XLP2XX_XAUI_IFACEFIFO_SZ        110
@@ -80,6 +80,7 @@
 #define DEFAULT_XLP2XX_XAUI_PARSERSEQFIFO_SZ    480
 
 
+
 typedef struct {
         uint32_t iftype[5];
         union {
@@ -314,7 +315,7 @@ static inline uint32_t get_intf_fifo_size(uint32_t intf_type)
 static inline uint32_t get_iface_credit(uint32_t intf_type)
 {
 	uint32_t size = get_intf_fifo_size(intf_type);
-	return (size >> 2);
+	 return (size - 1);	
 }
 
 static inline uint32_t get_prsr_seq_fifo_size(uint32_t intf_type)
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
index fc0818e..7752d7c 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_msgiface.h
@@ -34,8 +34,6 @@
 #include "nlm_hal_fmn_dp.h"
 #include "netsoc_msg.h"
 
-extern int netsoc_nae_send_freein_buf(nae_t *nae, uint32_t frinq_num, uint64_t paddr);
-extern int netsoc_nae_send_p2d_and_rtn2vfbid(net_port_t *port, uint32_t channel, uint32_t vfbid, uint64_t paddr, uint32_t len);
 extern int netsoc_nae_send_p2d_and_rtn_usermsg2vfbid(net_port_t *port, uint32_t channel, uint32_t vfbid, uint64_t paddr, uint32_t len, uint64_t data);
 extern int netsoc_nae_send_p2d_rtn2dest(net_port_t *port, uint32_t channel, uint32_t dest, uint64_t paddr, uint32_t len);
 extern int netsoc_nae_send_p2d_and_rtn_usermsg2dest(net_port_t *port, uint32_t channel, uint32_t dest, uint64_t paddr, uint32_t len, uint64_t data);
@@ -55,6 +53,62 @@ extern int (*poe_send_resp)(net_port_t *port, poe_fwd_mode_t fwd_mode, poe_enq_i
 #define netsoc_poe_send_deq         poe_send_deq
 #define netsoc_poe_send_resp        poe_send_resp
 
+/**
+* @brief netsoc_nae_send_freein_buf function is used to send a freein buffer to NAE free in descriptor queue
+* 
+* @param [in] nae Pointer to nae_t
+* @param [in] frinq_num FRIN queue number (0..n-1, not the actual VC)
+* @param [in] paddr Cache line aligned 40 bit physical address of RX buffer
+*
+* @return
+*       - 0         
+* 
+* @ingroup hal_nae
+*
+*/
+static __inline__ int netsoc_nae_send_freein_buf(nae_t *nae, uint32_t frinq_num, uint64_t paddr)
+{
+        uint64_t msg0;
+        uint32_t frinq = nae->frin_queue_base + frinq_num;
+
+        msg0 = nae_frin_desc(paddr);
+#ifdef NETSOC_MSG_DEBUG
+//        fmndbg("%s msg0 0x%llx Q: %d \n",__func__, msg0,frinq);
+#endif  
+        xlp_message_send_block_fast_1(0, frinq, msg0);
+        return 0;
+}
+
+
+/**
+* @brief netsoc_nae_send_p2d_and_rtn2vfbid function is used to send a packet and configures NAE to return the 40 bit
+*          physical address to the destination mapped to vfbid_table[vfbid]
+* 
+* @param [in] port Pointer to net_port_t indicates the network port that will be used to transmit the packet
+* @param [in] channel Logical channel number. If the port is configured with multiple channels, this parameter
+*             gives the channel number. Else, this must be 0.
+* @param [in] vfbid Index to virtual freeback id table
+* @param [in] paddr Physical address of the packet. It can be byte aligned
+* @param [in] len Length of the packet to be transmitted
+*
+* @return
+*       - 0         
+* 
+* @ingroup hal_nae
+*
+*/
+
+static __inline__ int netsoc_nae_send_p2d_and_rtn2vfbid(net_port_t *port, uint32_t channel, uint32_t vfbid, uint64_t paddr, uint32_t len)
+{
+        uint64_t msg0;
+
+        msg0 = nae_tx_desc(DESC_TYPE_P2DEOP, vfbid, len, paddr);
+#ifdef NETSOC_MSG_DEBUG
+        fmndbg("%s msg0 0x%llx Q: %d \n",__func__, msg0, ((port->txq + channel)));
+#endif  
+        xlp_message_send_block_fast_1(0, (port->txq + channel), msg0);
+        return 0;
+}
 
 static __inline__ int netsoc_fmn_recv_2(uint32_t rxvc, uint32_t *node, uint32_t *nae_id, uint64_t *msg0, uint64_t *msg1)
 {
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 217ba27..000b471 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -46,7 +46,7 @@ void *(*netsoc_lib_contig_malloc)(uint32_t align, uint32_t size);
 void (*netsoc_lib_contig_free)(void *buf);
 uint64_t (*netsoc_lib_virttophys)(void *);
 void *(*netsoc_lib_phystovirt)(uint64_t);
-unsigned int netsoc_api_dbglvl = 0xfb; // NETSOC_APIDBG_DEFAULT | NETSOC_APIDBG_GLOBAL;
+unsigned int netsoc_api_dbglvl = 0xff; // NETSOC_APIDBG_DEFAULT | NETSOC_APIDBG_GLOBAL;
 
 int (*const_func_list[])(void) = {
 register_marvell_phy,
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
index 8fca5bb..93dbfa8 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_msg.c
@@ -31,7 +31,7 @@
 #include "netsoc_msg.h"
 #include "nlm_nae.h"
 #include "nlm_hal_fmn_dp.h"
-
+#include "netsoc_msgiface.h"
 
 int (*enq_pkt_recv)(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info, poe_enq_info_t *rcvd_enq_info);
 int (*noenq_pkt_recv)(uint32_t rxvc, uint64_t *addr, uint32_t *len, pkt_recv_info_t *pkt_info);
@@ -49,62 +49,6 @@ extern int netsoc_v1_poe_send_resp(net_port_t *port, poe_fwd_mode_t fwd_mode, po
 
 
 /**
-* @brief netsoc_nae_send_freein_buf function is used to send a freein buffer to NAE free in descriptor queue
-* 
-* @param [in] nae Pointer to nae_t
-* @param [in] frinq_num FRIN queue number (0..n-1, not the actual VC)
-* @param [in] paddr Cache line aligned 40 bit physical address of RX buffer
-*
-* @return
-*       - 0         
-* 
-* @ingroup hal_nae
-*
-*/
-int netsoc_nae_send_freein_buf(nae_t *nae, uint32_t frinq_num, uint64_t paddr)
-{
-	uint64_t msg0;
-	uint32_t frinq = nae->frin_queue_base + frinq_num;
-	
-	msg0 = nae_frin_desc(paddr);
-#ifdef NETSOC_MSG_DEBUG
-//        fmndbg("%s msg0 0x%llx Q: %d \n",__func__, msg0,frinq);
-#endif  
-	xlp_message_send_block_fast_1(0, frinq, msg0);
-	return 0;
-}
-
-/**
-* @brief netsoc_nae_send_p2d_and_rtn2vfbid function is used to send a packet and configures NAE to return the 40 bit
-*          physical address to the destination mapped to vfbid_table[vfbid]
-* 
-* @param [in] port Pointer to net_port_t indicates the network port that will be used to transmit the packet
-* @param [in] channel Logical channel number. If the port is configured with multiple channels, this parameter
-*             gives the channel number. Else, this must be 0.
-* @param [in] vfbid Index to virtual freeback id table
-* @param [in] paddr Physical address of the packet. It can be byte aligned
-* @param [in] len Length of the packet to be transmitted
-*
-* @return
-*       - 0         
-* 
-* @ingroup hal_nae
-*
-*/
-
-int netsoc_nae_send_p2d_and_rtn2vfbid(net_port_t *port, uint32_t channel, uint32_t vfbid, uint64_t paddr, uint32_t len)
-{
-	uint64_t msg0;
-
-	msg0 = nae_tx_desc(DESC_TYPE_P2DEOP, vfbid, len, paddr);
-#ifdef NETSOC_MSG_DEBUG
-        fmndbg("%s msg0 0x%llx Q: %d \n",__func__, msg0, ((port->txq + channel)));
-#endif  
-	xlp_message_send_block_fast_1(0, (port->txq + channel), msg0);  
-	return 0;
-}
-
-/**
 * @brief netsoc_nae_send_p2d_and_rtn_usermsg2vfbid function is used to send a packet and  configures NAE to return the
 *          40 bit data passed to this function in param 'data' to the destination mapped to vfbid_table[vfbid]
 * 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 15afe85..c47ebaa 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1133,21 +1133,37 @@ void __netsoc_config_poe_class(nae_t *nae)
         }
 }
 
-void __netsoc_config_context_xoff_thr(nae_t *nae, int thgrp, int maxbuf)
+void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp, int maxbuf, int mtu_len)
 {
-	/* xon & xoff threshold is based on the number of entries used 
-	 send xon when rx_data_buffer_used <= xon threshold
-	 send xoff when rx_data_buffer_used >= xoff threshold */
-	int xoff = ((maxbuf * 16) - 504 - 1500)  / 16;
-	int xon = xoff - 94 ;
-	int val = (xoff << 3) | (xon << 17) | thgrp;
+        /* xon & xoff threshold is based on the number of entries used
+         send xon when rx_data_buffer_used <= xon threshold
+         send xoff when rx_data_buffer_used >= xoff threshold */
+        int xoff, xon, val, reaction_len, inflight_len;
 
-	static int done[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][NLM_NAE_MAX_XONOFF_THR_GRPS];
-	if(thgrp >= NLM_NAE_MAX_XONOFF_THR_GRPS)
-		return;
-	if(done[nae->node][nae->nae_id][thgrp])
-		return;
-	done[nae->node][nae->nae_id][thgrp] = 1;
+        if (netport->iftype == SGMII_IF)
+        {
+                reaction_len = NAE_REACTION_LEN_SGMII;
+                inflight_len = NAE_INFLIGHT_LEN_SGMII;
+        }
+        else
+        {
+                reaction_len = NAE_REACTION_LEN_XAUI;
+                inflight_len = NAE_INFLIGHT_LEN_XAUI;
+        }
+
+        /*
+           formula from PRM:
+           xoff = ((fifosize * 16) - 504 - MTU - R)/16;
+           xon = xoff - H;
+
+           (maxbuf<<2) is reqd since same is done for RX_BUFFER_BASE_DEPTH_REG also.
+           16 is required 16k entries of 16 bytes each
+           */
+
+        xoff = ((maxbuf * NAE_RX_THR_BYTE_UNIT) - reaction_len - inflight_len - mtu_len) / NAE_RX_THR_BYTE_UNIT;
+        xon = xoff - NAE_THR_SEPARATION;
+
+	val = (xoff << 3) | (xon << 17) | thgrp;
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, thgrp);
 	netsoc_write_nae_reg(nae->nae_base, RX_BUFFER_XONOFF_THR, val);
 
@@ -1232,14 +1248,14 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
 	   */
 	if (size != 0)
 	{
-		xoff = size/2;
-		xon = size/4;
+		xoff = (size/4) - 2;
+		xon = (size/8) - 1;
 		val = (xoff<<12) | (xon);
 		netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFOTH_CFG, val);
 	}
 
 	// MD is zero, 1024 entries
-	val = (1<<31) | (hw_port_id & 0x1f);
+	val = (1<<31) | (hw_port_id & 0x1f); 
 	netsoc_write_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG, val);
 	val = netsoc_read_nae_reg(nae->nae_base, PARSER_SEQ_FIFO_CFG);
 	netsoc_api_print(NETSOC_APIDBG_CONFIG,"PARSER_SEQ_FIFO_CFG port %d fcsz %d fcstart %d\n", hw_port_id,
@@ -1256,6 +1272,7 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 	int cur_iface_start = 0, max_ports;
 	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
 	int thrgrp = 0, rx_buf_size;
+	static int xonxoff_done[NLM_MAX_NODES][XLP9XX_MAX_NAE_PERNODE][NLM_NAE_MAX_XONOFF_THR_GRPS];
 
 	max_ports = __netsoc_get_max_ports();
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "Interface FIFO carving max_ports:%d \n", max_ports);
@@ -1304,11 +1321,16 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
 			nae->node, hw_port, context_base, nae->ports[port].num_channels,
                                         rx_buf_base, nae->ports[port].rx_buf_size);
 
-	//	if(nae->ports[port].vlan_pri_en && rx_buf_size)
-			if(rx_buf_size)
-				__netsoc_config_context_xoff_thr(nae, thrgrp,  (rx_buf_size << 2) / nae->ports[port].num_channels);
-	//	else
-	//		thrgrp = 0;
+		if( (rx_buf_size)  &&
+                                (thrgrp < NLM_NAE_MAX_XONOFF_THR_GRPS) &&
+                                (!(xonxoff_done[nae->node][nae->nae_id][thrgrp])) )
+                {
+			xonxoff_done[nae->node][nae->nae_id][thrgrp] = 1;
+			__netsoc_config_context_xoff_thr(nae, &nae->ports[port], thrgrp,  (rx_buf_size << 2) / nae->ports[port].num_channels, NAE_MTU_LEN);
+		}
+		else
+			thrgrp = 0;
+
 
 		__netsoc_config_rxbuffer(nae, context_base,nae->ports[port].num_channels,
                                         rx_buf_base, nae->ports[port].rx_buf_size, thrgrp);  
@@ -2075,6 +2097,29 @@ static void __netsoc_config_xaui(net_port_t *netport)
         netsoc_write_mac_reg(mac_base, NETIOR_XGMAC_CTRL3, val); netsoc_api_print(NETSOC_APIDBG_PORT, "%s XAUI Config Complete block %d \n", __func__, netport->hw_port_id >> 2); return;
 }
 
+static void __netsoc_set_xlgmac_pause_config(net_port_t *netport)
+{
+        volatile uint32_t val;
+        int i;
+        nae_t *nae = netport->nae;
+        static uint32_t xlgmac_pause_qn[8] = {0xF123, 0xF123, 0xF123, 0xF123, 0xF123, 0xF123, 0xF123, 0xF123};
+        static uint32_t xlgmac_qn_thres[8] = {0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000, 0xE000};
+        uint64_t mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+        val = netsoc_read_mac_reg(mac_base, XLGMAC3_CTL);
+        val &= 0xFFFFFC00;
+        val |=  netport->context_base; //TODO: should be context base instead hw_port_id
+        netsoc_write_mac_reg(mac_base, XLGMAC3_CTL, val);
+
+        for (i=0; i<4; i++) {
+                val = (xlgmac_pause_qn[i*2] & 0xFFFF) | ((xlgmac_pause_qn[(i*2)+1] & 0xFFFF)<<16);
+                __netsoc_write_xlgmac_reg(netport, XLAUI_CL01_PAUSE_QUANTA+ (i*4), val);
+                val = (xlgmac_qn_thres[i*2] & 0xFFFF) | ((xlgmac_qn_thres[(i*2)+1] & 0xFFFF)<<16);
+                __netsoc_write_xlgmac_reg(netport, XLAUI_CL01_QUANTA_THRESH+ (i*4), val);
+        }
+}
+
+
+
 /*
 * @brief __netsoc_config_xlgmac initializes a XLGMAC port at the MAC level.
 *
@@ -2095,6 +2140,12 @@ static void __netsoc_config_xlgmac(net_port_t *netport)
 	__netsoc_xlgmac_softreset(mac_base, 0x0);
 	__netsoc_xlgmac_threshold(mac_base, 0x1f);
 	__netsoc_set_xlgmac_enable(netport);
+	__netsoc_set_xlgmac_pause_config(netport);
+
+	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC3_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC3_CTL));
+	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC_STATUS : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC_STATUS));
+	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMAC1_CTL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMAC1_CTL));
+	netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI Rd XLGMACPCS_CTRL : 0x%x\n",  netsoc_read_mac_reg(mac_base, XLGMACPCS_CTRL));
 	return;
 }
 /*
@@ -2291,11 +2342,11 @@ uint16_t __netsoc_get_hwport(nae_t *nae, uint32_t context)
 static int __netsoc_init_netior(nae_t *nae)
 {
 	uint64_t nae_base = netsoc_get_iface_base(nae->nae_base, 0xf);
-	uint32_t xaui_ifcredit, sgmii_ifcredit, ilk_ifcredit, ifcredit = 0, ifcredit_1 = 0;
+	uint32_t xaui_ifcredit, sgmii_ifcredit, ilk_ifcredit, ifcredit = 0, ifcredit_1 = 0, ifcredit_val = 0;
 	uint32_t complex_mask = 0, block;
 
-	sgmii_ifcredit = 7; //get_iface_credit(SGMII_IF);
-	xaui_ifcredit = 7; //get_iface_credit(XAUI_IF);
+	sgmii_ifcredit = get_iface_credit(SGMII_IF);
+	xaui_ifcredit =  get_iface_credit(XAUI_IF);
 	ilk_ifcredit = 7; //get_iface_credit(INTERLAKEN_IF);
 
         netsoc_write_nae_iface_reg(nae_base, NETIOR_SOFTRESET, 0);
@@ -2305,12 +2356,28 @@ static int __netsoc_init_netior(nae_t *nae)
 			break;
 		}
 		if (nae->sgmii_complex_map & (1 << block)) {
-			ifcredit |= (sgmii_ifcredit << (block * 8));
+			ifcredit_val = get_iface_credit(SGMII_IF);
+			ifcredit |= (ifcredit_val << (block * 8));
 			complex_mask |= (0xF << (block * 4));		//FIXME 
 		}
-		else if ((nae->xaui_complex_map & (1 << block)) || (nae->rxaui_complex_map & (1 << block)) 
-					|| (nae->xfi_complex_map & (1 << block)) || (nae->xlgmac_complex_map & (1 << block))) {
-			ifcredit |= (xaui_ifcredit << (block * 8));
+		else if (nae->xaui_complex_map & (1 << block)) {
+			ifcredit_val = get_iface_credit(XAUI_IF);
+			ifcredit |= (ifcredit_val << (block * 8));
+			complex_mask |= (0xf << (block * 4));
+		}
+		else if (nae->rxaui_complex_map & (1 << block)) {
+			ifcredit_val = get_iface_credit(RXAUI_IF);
+			ifcredit |= (ifcredit_val << (block * 8));
+			complex_mask |= (0xf << (block * 4)); 
+		}
+		else if (nae->xfi_complex_map & (1 << block)) {
+			ifcredit_val = get_iface_credit(XFI_IF);
+			ifcredit |= (ifcredit_val << (block * 8));
+			complex_mask |= (0xf << (block * 4));
+		}
+		else if (nae->xlgmac_complex_map & (1 << block)) {
+			ifcredit_val = get_iface_credit(XLAUI_IF);
+			ifcredit |= (ifcredit_val << (block * 8));
 			complex_mask |= (0xf << (block * 4));
 		}
 		else {
@@ -2340,8 +2407,6 @@ static int __netsoc_init_netior(nae_t *nae)
         return NETSOC_API_SUCCESS;
 }
 
-
-
 /* Ingress Config
  *      20 queue (1000 - 1019)
  *      RxConfig : set the Free in desc default
@@ -3642,7 +3707,7 @@ static int __netsoc_config_freein_fifo(nae_t *nae)
                 unsigned int blk_cmplx_map;
                 /* Xaui/rxaui/interlaken uses only one fifo per complex */
                 blk_cmplx_map = nae->xaui_complex_map |  nae->rxaui_complex_map |
-                         nae->ilk_complex_map;
+                         nae->xlgmac_complex_map | nae->ilk_complex_map;
                 for(i = 0; blk_cmplx_map; i++) {
                         if(!(blk_cmplx_map & 0x1))  {
                                 blk_cmplx_map = blk_cmplx_map >> 1;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 5a89313..467c0f9 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -740,13 +740,13 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
                
 		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
                 pma2p0_config &= 0xFFFF01FF;
-                pma2p0_config |= PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR;
+                pma2p0_config |= PMA2P0_CTL_POR | PMA2P0_CTL_SYNTH_RST | PMA2P0_CTL_RTHR | (1<<16);
                 netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
 
                 for(delay=0; delay<1000000; delay++);
 
                 pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
-                pma2p0_config &= ~PMA2P0_CTL_POR;
+                pma2p0_config &= ~(PMA2P0_CTL_POR | (1<<16));
                 pma2p0_config &= 0xFFFFFE00;
                 netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
 
@@ -967,6 +967,9 @@ static void config_lanes_for_xlgmac(nae_t *nae, uint32_t xgmac_cplx_mask, uint32
 	uint32_t lane_enable;
 	uint32_t cplx_lane_enable = LM_XLAUI | (LM_XLAUI << 4) | (LM_XLAUI << 8) | (LM_XLAUI << 12);
 
+	if(phymode==0)
+		cplx_lane_enable = 0;
+
         if (xgmac_cplx_mask & 0x3) { /* Complexes 0, 1 */
                 lane_enable = netsoc_read_mac_reg(mac_base, LANE_CFG_CPLX_0_1);
                 if (xgmac_cplx_mask & 0x1) { /* Complex 0 */
@@ -1210,7 +1213,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 		}
 	}
 
-//        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
+        netsoc_api_print(NETSOC_APIDBG_PORT, "%s all blocks & lanes out of TXPLL\n", __func__);
 
         netsoc_api_delay(10);
         /* Wait for Rx & TX clock stable */
@@ -1258,6 +1261,7 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
 					break;
                                 }
                         }
+			netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XAUI lane status 0x%x\n",__func__, netsoc_read_mac_reg(mac_base, lane_status));
                 }
         }
 }
@@ -1267,15 +1271,10 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
 
-	if((phymode==PHYMODE_XFI))	
-		config_lanes_for_xfi(nae, cplx_mask);
-	else{
-		config_lanes_for_xlgmac(nae, cplx_mask, PHYMODE_XLAUI);
-	}
 
+	config_lanes_for_xlgmac(nae, cplx_mask, 0);
 	for( block = 0; block < 4; block++)
         {
-
                 if ((cplx_mask & (1 << block)) == 0) {
                         continue;
                 }
@@ -1284,7 +1283,20 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
 		//TODO: If HIGIG pass XGMII speed.
 		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 10, phymode);
 		nae->serdes_init_cnt++;	
-                
+	}
+	
+	if((phymode==PHYMODE_XFI))	
+		config_lanes_for_xfi(nae, cplx_mask);
+	else{
+		config_lanes_for_xlgmac(nae, cplx_mask, PHYMODE_XLAUI);
+	}
+	
+	for( block = 0; block < 4; block++)
+        {
+                if ((cplx_mask & (1 << block)) == 0) {
+                        continue;
+                }
+
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			xlp9xx_lane_reset(nae, block, lane_ctrl, phymode);
 		}
@@ -1326,15 +1338,16 @@ static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t ph
                         }
 
                         netsoc_api_print(NETSOC_APIDBG_PORT,"Blk:%d lane%d wait lane fault cleared\n", block, lane_status);
+#if 0
 			count = 0;
-                        while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
+			while ((netsoc_read_mac_reg(mac_base, lane_status) & (PHY_LANE_STAT_SPC)) != (1<<9)) {
                                 /* Wait for XAUI Lane fault to be cleared */
-				count++;
-                                if (count == timeout) {   
-                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI lane fault not cleared \n", __func__);
-					break;
+                                count++;
+                                if (count == timeout) {
+                                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s XFI/XLAUI lane fault not cleared \n", __func__);
                                 }
                         }
+#endif
                 }
         }
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
index 5673bdc..773f51a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
@@ -421,7 +421,8 @@ int __netsoc_init_poe(poe_t *poe)
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_FBP_SP_EN, 0x1);
         netsoc_write_poe_pcie_reg(poe_pcie_base, POE_EXT_ALLOC_EN, 1);
 
-        netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x3);
+        netsoc_write_poe_pcie_reg(poe_pcie_base, POE_TX_TIMER, 0x2);
+
 	return NETSOC_API_SUCCESS;
 }
 
-- 
1.7.1

