From bd41902608d886a1b5b9d9d59bef67f504ff6cf4 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 4 Sep 2010 15:14:33 -0700
Subject: NAE: Configure MSGINT ACK regs, 32 free desc (no spill), removed XLR UART HACK

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 36bcbea..24154ef 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -67,7 +67,7 @@
 #define NUM_FREE_DESC			18
 #define FREE_DESC_POOL_WIDTH		20
 #define NUM_FREEIN_QUEUE		18
-#define MAX_NUM_DESC			32
+#define MAX_NUM_DESC                    32
 #define MIN_FRIN_DESC_THRESHD		16
 #define MAX_NET_INF             	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
@@ -400,6 +400,7 @@ retry_send:
                                 printk("TX message Q fulll\n");
 			}
 
+			printk("[%s]: retrying...\n", __func__);
 			goto retry_send;
                 }
 		msgrng_access_disable(mflags);
@@ -422,6 +423,15 @@ static void nlm_xlp_nae_init(void)
 	struct proc_dir_entry *entry;
 	uint32_t val;
 
+#define HW_EMULATOR                            1
+#ifdef HW_EMULATOR
+	unsigned long mflags = 0;
+	msgrng_access_enable(mflags);
+        nlm_hal_fmn_init(0xE0000000ULL, 0x1000000, 50);
+	// nlm_hal_dump_outq();
+	msgrng_access_disable(mflags);
+#endif
+
 	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
 		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",__FUNCTION__, xlp_sgmii_ports);
@@ -437,12 +447,13 @@ static void nlm_xlp_nae_init(void)
 	/* initial 18 gmac block */
         for(i = 0; i < 1/*MAX_NET_INF*/; i++)
 	{
-		init_gmac(i);
+		/* init_gmac(i); */
+		nlm_hal_open_if(GMAC_IF, i);
 	}
-
+#if 0
 	/* init tx if credit */
 	init_tx_if_credit( 0, 0x7FFFF );
-
+#endif
 
 	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
 	{
@@ -450,9 +461,12 @@ static void nlm_xlp_nae_init(void)
 	}
 
 	ucore_load_apps(0xffffUL);
+
+#if 0
 	/*  init egress and igress interface */
 	init_ingress();
 	init_egress();
+#endif
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
 	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
@@ -674,7 +688,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 	}
 
-	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, (virt_to_bus(skb)|port));
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
 							 0,
 							 NULL_VFBID,
@@ -687,6 +701,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	DUMP_PKT(skb->data, skb->len)
 #endif
 	__sync();
+
+       printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
+	      priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
+
 	msgrng_access_enable(mflags);
 retry_send:
         if ((ret = nlm_hal_send_msg2( priv->nae_tx_qid,
@@ -881,6 +899,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	cpu = vc >> 4;
 	vc = vc & 0x03;
 
+       printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
+	      src_id, vc, size, msg0, msg1);
+
 	if( vc == 1 && size == 1)
 	{
 		/* Transmit Complete */
@@ -894,22 +915,23 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			port = 0;
 		}
 
-                if(addr)
-                {
-			pdev = (struct net_device*)dev_mac[port];
-			if(!pdev)
-				return;
-			priv = netdev_priv(pdev);
+		pdev = (struct net_device*)dev_mac[port];
+		if(!pdev) {
+			printk("[%s]: [txc] wrong port=%d? pdev = NULL!\n", __func__, port);
+			return;
+		}
+		priv = netdev_priv(pdev);
 
-                        skb = (struct sk_buff *)bus_to_virt(addr);
-                        if(skb)
-                        {
-                                dev_kfree_skb_any(skb);
-                        }
-			else {
-				printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
-			}
-                }
+		skb = (struct sk_buff *)bus_to_virt(addr);
+		if(skb)
+		{
+			printk("[%s]: addr=%llx, skb=%p, context=%d, port=%d\n",
+			       __func__, addr, skb, context, port);
+			dev_kfree_skb_any(skb);
+		}
+		else {
+			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
+		}
 	}
 	else if(vc == 0 && size == 2)
 	{
@@ -936,11 +958,11 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		vaddr = (uint64_t)bus_to_virt(addr);
 		buf = (unsigned char *)vaddr;
 
-#if DUMP_RCV_PKT
-		printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",
-		       priv->port,src_id,context,(uint64_t)buf, len, vaddr);
+		printk("[%s]: addr=%llx, len=%d, context=%d, port=%d, vaddr=%llx, buf=%p\n",
+		       __func__, addr, len, context, port, vaddr, buf);
 
-		/* DUMP_PKT(buf , len); */
+#if DUMP_RCV_PKT
+		DUMP_PKT(buf , len);
 #endif
 
 		len = len  - MAC_CRC_LEN;
@@ -949,8 +971,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		{
 			priv->stats.rx_errors++;
 			priv->stats.rx_dropped++;
-			/* printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n",
-			   len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);*/
 			printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
 			return ;
 		}
-- 
1.7.1

