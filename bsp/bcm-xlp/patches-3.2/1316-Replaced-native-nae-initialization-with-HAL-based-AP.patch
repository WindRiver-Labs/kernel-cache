From 8cd535827926909fa81531bbd384e94bd0d7043f Mon Sep 17 00:00:00 2001
From: Siva Pochiraju <sivap@netlogicmicro.com>
Date: Tue, 26 Oct 2010 14:39:41 -0700
Subject: Replaced native nae initialization with HAL based API

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index dcd96fd..bdf30e0 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -15,301 +15,6 @@
 
 extern int rely_on_firmware_config;
 
-#define VAL_UCORE_RESET(x)             ( ( (x) &0xffff) << 8)
-
-struct nae_config nae_cfg;
-int cntx2port[1024];
-
-/*
- *  Temporary direct ucore configuration. HAL needs to support stop and restart
- * of ucores before reloading code
- */
-static int local_load_ucore(int ucore_mask, unsigned int *opcodes, int num_opcodes)
-{
-	int mask = ucore_mask & NAE_UCORE_MASK;
-	unsigned int id = 0;
-	int i;
-	volatile uint32_t ucore_cfg = 0;
-
-	printk("[%s]\n", __func__);
-	nlm_print("Stopping and Resetting all ucore...\n");
-
-	/* Stop all ucores */
-        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
-	nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg | (1 << 24));
-
-	nlm_hal_write_nae_reg(UCORE_IFACE_MASK_CFG, ucore_spray_config(16, 0, CMD_WRITE));
-
-	/* poll for ucore to get in to a wait state */
-	for(;;) {
-		ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
-		if (ucore_cfg & (1 << 25)) break;
-	}
-
-	nlm_print("Loading ucores (mask = 0x%04x)\n", mask);
-
-	while (id < MAX_NAE_UCORES) {
-
-		if ((mask & (1 << id)) == 0) {
-			id++;
-			continue;
-		}
-
-		for (i=0; i < num_opcodes; ++i) {
-			nlm_hal_write_ucode(id, (i * 4), opcodes[i]);
-		}
-		id++;
-	}
-
-	/* Enable per-domain ucores */
-        ucore_cfg = nlm_hal_read_nae_reg(RX_UCORE_CFG);
-	/* write one to reset bits to put the ucores in reset */
-	ucore_cfg = ucore_cfg | (VAL_UCORE_RESET(ucore_mask));
-        nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg);
-	/* write zero to reset bits to pull them out of reset */
-	ucore_cfg = ucore_cfg & (~VAL_UCORE_RESET(ucore_mask)) & ~(1 << 24);
-        nlm_hal_write_nae_reg(RX_UCORE_CFG, ucore_cfg);
-
-	nlm_hal_write_nae_reg(UCORE_IFACE_MASK_CFG, ucore_spray_config(16, 0xffff, CMD_WRITE));
-
-	return 0;
-}
-
-static void parse_ucore_config(void)
-{
-        uint32_t ucore_cfg;
-	void *node;
-	int size = 0;
-	unsigned int *uc_opcodes;
-	uint32_t uc_mask, num_opcodes;
-
-	uc_mask = num_opcodes = ucore_cfg = 0;
-
-	node = finddevice("/soc/nae-cfg/ucore/src@1");
-	if(!node) {
-		printk("[%s] Unable to parse ucore configuration!\n", __func__);
-		return;
-	}
-
-	/* Domain specific ucore mask */
-	getprop(node, "mask", &uc_mask, sizeof(uint32_t));
-
-	getprop(node, "num-opcodes", &num_opcodes, sizeof(uint32_t));
-
-	size = sizeof(uint32_t) * num_opcodes;
-	uc_opcodes = kmalloc(size, GFP_KERNEL);
-	if (!uc_opcodes) {
-		printk("[%s] Unable to allocate temporary memory\n", __func__);
-		return;
-	}
-
-	getprop(node, "opcodes", uc_opcodes, size);
-
-	local_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
-
-	kfree(uc_opcodes);
-}
-
-static void parse_poe_config(void)
-{
-	void *node;
-	int size = 0;
-	unsigned int *poe_regs;
-	uint32_t num_regs;
-
-	node = finddevice("/soc/nae-cfg/poe-pci-mem-regs");
-	if(!node) {
-		printk("[%s] Unable to parse poe configuration!\n", __func__);
-		return;
-	}
-
-	getprop(node, "num-regs", &num_regs, sizeof(uint32_t));
-
-	size = sizeof(uint32_t) * num_regs * 3;
-	poe_regs = kmalloc(size, GFP_KERNEL);
-	if (!poe_regs) {
-		printk("[%s] Unable to allocate temporary memory\n", __func__);
-		return;
-	}
-
-	getprop(node, "regs", poe_regs, size);
-
-	nlm_hal_init_poe_regs(poe_regs, num_regs);
-
-	kfree(poe_regs);
-}
-
-static void parse_fdt_cpu_config(void)
-{
-	void *node;
-
-	node = finddevice("/doms/dom@0/cpu");
-	if (!node) {
-		printk("[%s] Unable to parse cpu-nae configuration! Using defaults:\n",
-		       __func__);
-		goto out;
-	}
-
-	if (getprop(node, "nae-rx-vc", &nae_cfg.rx_vc, sizeof(uint32_t)) < 0) {
-		printk("Unable to parse nae_rx_vc, using defaults\n");
-		goto out;
-	}
-
-	if (getprop(node, "nae-fb-vc", &nae_cfg.fb_vc, sizeof(uint32_t)) < 0) {
-		printk("Unable to parse nae_rx_vc, using defaults\n");
-		goto out;
-	}
-
- out:
-
-	return;
-}
-
-static void parse_fdt_nae_config(void)
-{
-	void *node, *subnode;
-	int i = 0;
-	char domstr[32] = "";
-	int port_type = UNKNOWN_IF;
-	char port_type_str[MAX_PROP_LEN];
-	int size = 0;
-	int num_ports = 0;
-	uint32_t start_port, num_nae_regs, num_intf_regs;
-
-	/* Parse Nae Config */
-	start_port = num_nae_regs = num_intf_regs = 0;
-
-	node = finddevice("/soc/nae-cfg");
-	if(!node) {
-		printk("[%s] Unable to parse nae configuration!\n", __func__);
-		return;
-	}
-
-	/*******************************************************************************/
-	/* Read range of ports allocated per domain
-	 * start-port-id -> start-port-id + num-ports
-	 */
-
-	if(getprop(node, "start-port-id", &start_port, sizeof(uint32_t)) < 0)
-		printk("fdt missing start-port-id\n");
-
-	if(getprop(node, "num-ports", &num_ports, sizeof(uint32_t)) < 0)
-		printk("fdt missing num-ports\n");
-
-	/*******************************************************************************/
-
-	if(getprop(node, "num-nae-regs", &num_nae_regs, sizeof(uint32_t)) < 0)
-		printk("fdt missing num-nae-regs\n");
-
-	if(getprop(node, "num-intf-regs", &num_intf_regs, sizeof(uint32_t)) < 0)
-		printk("fdt missing num-if-regs\n");
-
-	printk("num-ports = %d, start-port-id = %d\n", num_ports, start_port);
-
-	if (debug)
-		printk("num-nae-regs = %d, num-intf-regs = %d\n", num_nae_regs, num_intf_regs);
-
-	if (!rely_on_firmware_config)
-		/* bitmask of complexes to initialize */
-		nlm_hal_sgmii_pcs_init(1<<4);
-
-	for(i = 0; i < num_ports; i++)
-	{
-		uint32_t *nae_regs = 0, *intf_regs = 0;
-		int mgmt_intf = 0;
-		int port = 0;
-
-		sprintf(domstr, "/soc/nae-cfg/port@%d", i);
-
-		subnode = finddevice(domstr);
-		if(!subnode) continue;
-
-		if (getprop(subnode, "mgmt", &mgmt_intf, sizeof(uint32_t)) < 0)
-			printk("fdt missing mgmt\n");
-
-		port = nae_cfg.num_ports;
-		nae_cfg.num_ports++;
-
-		nae_cfg.ports[port].valid = 1;
-		nae_cfg.ports[port].mgmt = mgmt_intf;
-
-		if (getprop(subnode, "tx-que-range", &nae_cfg.ports[port].txq_range[0], sizeof(uint32_t) * 2) < 0)
-			printk("fdt missing tx-que-range\n");
-		else {
-			printk("tx-que-range[%d %d]\n", nae_cfg.ports[port].txq_range[0],
-			       nae_cfg.ports[port].txq_range[1]);
-		}
-
-		if (getprop(subnode, "rx-que", &nae_cfg.ports[port].rxq, sizeof(uint32_t)) < 0)
-			printk("fdt missing rx-que\n");
-		else {
-			printk("rx-que[%d]\n", nae_cfg.ports[port].rxq);
-		}
-
-		if (getprop(subnode, "hw-port-id", &nae_cfg.ports[port].hw_port_id, sizeof(uint32_t)) < 0)
-			printk("fdt missing hw-port-id\n");
-		else {
-			printk("hw-port-id[%d]\n", nae_cfg.ports[port].hw_port_id);
-		}
-
-		getprop(subnode, "type", port_type_str, MAX_PROP_LEN);
-		if (!strcmp(port_type_str, "SGMII_IF")) port_type = SGMII_IF;
-		else if (!strcmp(port_type_str, "XAUI_IF")) port_type = XAUI_IF;
-		else if (!strcmp(port_type_str, "INTERLAKEN_IF")) port_type = INTERLAKEN_IF;
-		else port_type = UNKNOWN_IF;
-
-		getprop(subnode, "num-free-desc", &nae_cfg.ports[port].num_free_desc,
-			sizeof(uint32_t));
-
-		size = sizeof(uint32_t) * num_nae_regs * 2;
-		nae_regs = kmalloc(size, GFP_KERNEL);
-		if (!nae_regs) {
-			printk("[%s] Unable to allocate memory for nae-regs, aborting\n", __func__);
-			return;
-		}
-		getprop(subnode, "nae-regs", nae_regs, size);
-
-		size = sizeof(uint32_t) * num_intf_regs * 2;
-		intf_regs = kmalloc(size, GFP_KERNEL);
-		if (!intf_regs) {
-			printk("[%s] Unable to allocate memory for if-regs, aborting\n", __func__);
-			return;
-		}
-		getprop(subnode, "intf-regs", intf_regs, size);
-
-		if (!rely_on_firmware_config) {
-			printk("Configuring per-port interface registers for port@%d\n", i);
-			/* Configure per port interface registers */
-			nlm_hal_init_if_regs(port_type, nae_cfg.ports[port].hw_port_id, intf_regs, num_intf_regs);
-
-			printk("Configuring per-port NAE registers for port@%d\n", i);
-			/* Configure per port NAE registers */
-			nlm_hal_init_nae_regs(port_type, nae_regs, num_nae_regs);
-		}
-		else {
-			int reg = 0;
-
-			/* don't rely on firmware for free-in desc carving */
-			for (reg = 0; reg < num_nae_regs; reg++) {
-				if (nae_regs[reg * 2] != FREE_IN_FIFO_CFG) continue;
-				nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, nae_regs[reg * 2 + 1]);
-			}
-		}
-
-		kfree(nae_regs);
-		kfree(intf_regs);
-
-		if (!rely_on_firmware_config) {
-			if (nlm_hal_open_if(port_type, nae_cfg.ports[port].hw_port_id) < 0) {
-				printk("[%s] Unable to open port %d\n", __func__, i);
-				continue;
-			}
-		}
-
-		printk("Initialized port@%d\n", i);
-	}
-}
-
 static void config_fmn(void)
 {
 	unsigned long mflags = 0;
@@ -331,123 +36,11 @@ static void config_fmn(void)
 	sched_bindto_restore_affinity(&cpumask);
 }
 
-static void drain_nae_frin_fifo_descs(void)
-{
-	int i = 0;
-	uint32_t value = 0;
-
-	nlm_hal_write_nae_reg(RX_FREE_FIFO_POP, 0xfffff);
-	for (i = 0; i < 10; i++) {
-		mdelay(1);
-		value = nlm_hal_read_nae_reg(RX_FREE_FIFO_POP);
-		if (value == 0xfffff) break;
-	}
-	if (i == 10) {
-		printk("Unable to zap free in fifo!(value=0x%08x)\n", value);
-	}
-	else {
-		printk("Successfully zapped free in fifo!\n");
-	}
-	nlm_hal_write_nae_reg(RX_FREE_FIFO_POP, 0);
-}
-
-static void print_frin_desc_carving(void)
-{
-	int intf;
-
-	if (!debug) return;
-
-	for (intf = 0; intf < 20; intf++) {
-		uint32_t value = 0;
-		int start = 0, size = 0;
-
-		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, (0x80000000 | intf));
-
-		value = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG);
-		size = (value >> 20) & 0x3ff;
-		start = (value >> 8) & 0x1ff;
-
-		printk("intf@%02d=0x%08x, start=%d, size=%d\n", intf, value, start, size);
-	}
-}
-
-static void deflate_frin_fifo_carving(void)
-{
-	int intf = 0;
-	const int minimum_size = 8; /* this represents entries, each entry holds 2 descriptors */
-	int start = 0;
-	uint32_t value = 0;
-
-	for (intf = 0; intf < 20; intf++) {
-		start = minimum_size * intf;
-		value = (minimum_size << 20) | (start << 8) | (intf);
-		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, value);
-	}
-}
-
 int initialize_nae(uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3)
 {
-	int i = 0;
-
-	if (check_header()) {
-		printk("Sanity check on FDT blob failed! Aborting\n");
-		return -1;
-	}
-
-	/* Initialize default configuration */
-	for (i = 0; i < 18; i++) {
-		nae_cfg.fb_vc = 1;
-		nae_cfg.rx_vc = 0;
-		nae_cfg.ports[i].valid = 0;
-		nae_cfg.ports[i].mgmt = 0;
-	}
-
-	for (i = 0; i < 1024; i++) {
-		/* 18 is an invalid port */
-		cntx2port[i] = 18;
-	}
-
-	/* frin_fifo represents the 20 pools of free-in descriptor fifos */
-	drain_nae_frin_fifo_descs();
-	deflate_frin_fifo_carving();
-
 	config_fmn();
 
-	printk("Configuring ucore...\n");
-	parse_ucore_config();
-
-	printk("Configuring NAE...\n");
-	parse_fdt_nae_config();
-
-	printk("Configuring CPU-NAE...\n");
-	parse_fdt_cpu_config();
-
-	printk("Configuring PoE...\n");
-	parse_poe_config();
-
-	printk("NAE configuration done!\n");
-
-	printk("Digest of FDT based NAE config: \n");
-	printk("fb_vc = %d, rx_vc = %d\n", nae_cfg.fb_vc, nae_cfg.rx_vc);
-	for (i = 0; i < 18; i++) {
-		int context = 0;
-		struct nae_port *port = &nae_cfg.ports[i];
-
-		if (!port->valid) continue;
-
-		/* Default NAE configuration uses hw_port_id as the context */
-		context = port->hw_port_id;
-		cntx2port[context] = i; /* logical port */
-
-		printk("port@%d: valid = %d, mgmt = %d, num_free_desc = %d\n"
-		       "\t txq[0] = %d, txq[1] = %d, rxq = %d, hw_port_id = %d\n", i,
-		       port->valid, port->mgmt, port->num_free_desc,
-		       port->txq_range[0], port->txq_range[1], port->rxq, port->hw_port_id);
-
-	}
-
-	printk("FRIN desc carving after HAL initialization...\n");
-	print_frin_desc_carving();
+	nlm_hal_init_nae(fdt);
 
 	printk("Overriding HAL POE configuration based on current active cpumask\n");
 	nlm_hal_init_poe_distvec(0, cm0, cm1, cm2, cm3, (1 << nae_cfg.rx_vc));
diff --git a/drivers/net/ethernet/broadcom/nae/net_common.h b/drivers/net/ethernet/broadcom/nae/net_common.h
index ad3cfa0..29b1639 100644
--- a/drivers/net/ethernet/broadcom/nae/net_common.h
+++ b/drivers/net/ethernet/broadcom/nae/net_common.h
@@ -1,6 +1,8 @@
 #ifndef NET_COMMON_H
 #define NET_COMMON_H
 
+#include <nlm_hal_nae.h>
+
 #define MAX_FMN_CODE            -1
 #define FMN_CREDIT_DEFAULT      8
 #define FMN_POE_CREDIT_DEFAULT      9
@@ -159,6 +161,7 @@ static __inline__ void tx_print(uint64_t msg0) {
 }
 
 extern int debug;
+extern void *fdt;
 
 struct nae_port {
 	int  valid;
@@ -176,9 +179,6 @@ struct nae_config {
 	struct nae_port ports[18];
 };
 
-extern struct nae_config nae_cfg;
-extern int cntx2port[];
-
 extern int initialize_nae(uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3);
 extern void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
 
-- 
1.7.1

