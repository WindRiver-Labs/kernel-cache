From 54d28e33ebd00af2ceedac0be588753f89eadc80 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Sun, 27 Jun 2010 00:58:43 -0700
Subject: NAE: tested version of network driver that works over simulator

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index f73e56f..5ecb615 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -73,6 +73,7 @@
 #define NUM_FREEIN_QUEUE		18
 #define MIN_FRIN_DESC_THRESHD		8
 #define MAX_NET_INF             	18
+#define XLP_SGMII_RCV_CONTEXT_NUM	8
 unsigned char icmp_pck[200] = {0x00,0x22,0x19,0x05,0xf0,0xb8,0x00,
                       0xd0,0xd3,0x3a,0xbd,0x50,0x08,0x00,0x45,0x00,0x00,
                       0x3c,0x92,0x42,0x00,0x00,0x7f,0x01,0x06,0xb4,0x0a,
@@ -89,27 +90,49 @@ unsigned char icmp_pck[200] = {0x00,0x22,0x19,0x05,0xf0,0xb8,0x00,
 #define ICMP_LEN                     	74
 #define MAX_GMAC_PORT               	18
 
+#define MYIP_OFFSET	30
+#define  RUN_ON_SIM()					\
+uint8_t broadcast[6] = {0xff,0xff,0xff,0xff,0xff,0xff};	\
+uint8_t myeth[6]     = {0x00,0x01,0x02,0x03,0x04,0x05};	\
+uint8_t hosteth[6]   = {0x00,0x1a,0xa0,0x1e,0x5d,0xc9};	\
+uint8_t myip[4]	     = {0x0a,0x1a,0x70,0xd6};	i	\
+	if(memcmp(buf, hosteth, 6) == 0)		\
+		if(memcmp(&buf[MYIP_OFFSET],myip,4)==0)	\
+			memcpy(buf,myeth,6);
+
+
+#define  DUMP_PKT()					\
+	int i;      					\
+        for(i = 0; i < skb->len; i++)			\
+        {						\
+                printk("%02x ",skb->data[i]);		\
+                if( i % 16 == 15)			\
+                        printk("\n");			\
+        }						\
+	printk("\n");
+
 unsigned char eth_hw_addr[18][6] = {
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE1},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE2},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE3},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE4},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE5},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE6},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE7},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE8},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xE9},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xEA},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xEB},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xEC},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xED},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xEE},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xEF},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xF1},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xF2},
-					{0xB6,0x75,0x8E,0xDC,0x2F,0xF3}
+					{0x00,0x01,0x02,0x03,0x04,0x05},
+					{0x00,0x01,0x02,0x03,0x04,0x06},
+					{0x00,0x01,0x02,0x03,0x04,0x07},
+					{0x00,0x01,0x02,0x03,0x04,0x08},
+					{0x00,0x01,0x02,0x03,0x04,0x09},
+					{0x00,0x01,0x02,0x03,0x04,0x0A},
+					{0x00,0x01,0x02,0x03,0x04,0x0B},
+					{0x00,0x01,0x02,0x03,0x04,0x0C},
+					{0x00,0x01,0x02,0x03,0x04,0x0D},
+					{0x00,0x01,0x02,0x03,0x04,0x0E},
+					{0x00,0x01,0x02,0x03,0x04,0x0F},
+					{0x00,0x01,0x02,0x03,0x04,0x10},
+					{0x00,0x01,0x02,0x03,0x04,0x11},
+					{0x00,0x01,0x02,0x03,0x04,0x12},
+					{0x00,0x01,0x02,0x03,0x04,0x13},
+					{0x00,0x01,0x02,0x03,0x04,0x14},
+					{0x00,0x01,0x02,0x03,0x04,0x15},
+					{0x00,0x01,0x02,0x03,0x04,0x16}
 				   };
 
+#define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
         {PCI_NETL_VENDOR, PCI_DEVID_BASE + PCI_DEVID_OFF_NET,
          PCI_ANY_ID, PCI_ANY_ID, 0},
@@ -120,6 +143,7 @@ extern int  xlp_with_mac_driver;
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 
+static void nlm_xlp_sgmii_setcontext();
 static void nlm_xlp_nae_init(void);
 static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
 static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf);
@@ -131,7 +155,12 @@ static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd
 static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
-static void nlm_xlp_nae_msgring_handler(int vc, int size, int code, int stid, struct msgrng_msg *msg, void* data);
+
+static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
+					uint32_t size, uint32_t code,
+					uint64_t msg0, uint64_t msg1,
+					uint64_t msg2, uint64_t msg3, void* data);
+
 static void nlm_xlp_mac_timer(unsigned long data);
 static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
@@ -144,6 +173,7 @@ struct net_device *dev_mac_type[MAX_NET_TYPES][MAX_GMAC_PORT];
 
 extern struct proc_dir_entry *nlm_root_proc;
 static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
+static void mac_refill_frin_desc(struct net_device *dev);
 
 extern void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag);
 
@@ -163,7 +193,6 @@ static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
         uint64_t *back_ptr =
                 (uint64_t *)(addr - CACHELINE_SIZE);
-//        printk("%s: addr = %llx,  back_ptr = %llx, skb = %llx\n", __FUNCTION__, addr, (uint64_t)back_ptr, *back_ptr);
         /* this function should be used only for newly allocated packets. It assumes
          * the first cacheline is for the back pointer related book keeping info
          */
@@ -179,7 +208,6 @@ static __inline__ void mac_put_skb_back_ptr(struct sk_buff *skb)
          */
         skb_reserve(skb, CACHELINE_SIZE);
         *back_ptr = (uint64_t)skb;
-//        printk("%s: skb->data=%llx, backptr:%llx  skb=%llx\n",__FUNCTION__, skb->data,*back_ptr, skb);
 }
 
 #define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(CACHELINE_SIZE-1))
@@ -239,9 +267,7 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
 	if(!skb)
 		return;
 	/* Tx Complete */
-//	xlr_inc_counter(NETIF_TX_COMPLETE);
 
-	dbg_msg("skb = %p\n", skb);
 	/* release the skb and update statistics outside the spinlock */
 	priv = netdev_priv(skb->dev);
 	priv->stats.tx_packets++;
@@ -259,21 +285,23 @@ static inline void nlm_xlp_free_skb(struct xlp_msg *msg)
  * @dev -  this is per device based function
  *
  **********************************************************************/
-static  int mac_refill_frin_desc(struct net_device *dev)
+static void mac_refill_frin_desc(struct net_device *dev)
 {
 	struct dev_data* priv = netdev_priv(dev);
-        int ret = 0, mflags = 0, i, code;
+        int ret = 0, mflags = 0, i, code,limit;
         struct xlp_msg msg;
 	struct sk_buff * skb;
 	uint64_t *idx_ptr;
 
-	for(i=1; i <= MIN_FRIN_DESC_THRESHD*2; i++)
+	limit = priv->inited ? MIN_FRIN_DESC_THRESHD*4: MIN_FRIN_DESC_THRESHD*4*10;
+
+	for(i=1; i <= limit; i++)
 	{
 		 skb = nlm_xlp_alloc_skb();
 		if(!skb)
 		{
 			printk("[%s] alloc skb failed\n",__FUNCTION__);
-			return -ENOMEM;
+			return;
 		}
 
 		skb->dev = dev;
@@ -305,12 +333,9 @@ retry_send:
 
 		msgrng_access_disable(mflags);
 		priv->num_desc++;
-/*
- *		 printk("mac_%d: Sending freein %llx  to vc %d, num %d\n",priv->port, msg.entry[0], priv->nae_rx_qid, (int)priv->num_desc);
-*/
 	}
 
-        return ret;
+        return;
 }
 
 /**********************************************************************
@@ -366,9 +391,6 @@ retry_send:
 
 		msgrng_access_disable(mflags);
 		priv->num_desc++;
-/*
- * 	printk("[%s] intf %d  freein %d    %llx  num_desc: %d\n", __FUNCTION__,intf, i, msg.entry[0],(int)priv->num_desc);
-*/
         }
 
         return ret;
@@ -377,18 +399,6 @@ retry_send:
 static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
         int result = 0;
-printk("[%s] \n", __FUNCTION__);
-//	nlm_xlp_nae_init();
-#if 0
-        /*static atmoic_t int  num_macs = ATOMIC_INIT(0);*/
-        static int  num_macs = 1;
-        int instance = atomic_inc_return(&num_macs) - 1;
-
-        if (instance < 0 || instance >= (MAX_NUM_UARTS - 1)) {
-                printk("Found an Invalid mac pci device instance_%d!\n", instance);
-                return -1 ;
-        }
-#endif
         result = pci_enable_device(pdev);
 	return result;
 
@@ -407,7 +417,7 @@ static void nlm_xlp_nae_init(void)
 	int i;
 	unsigned long mflags;
 	struct proc_dir_entry *entry;
-
+	uint32_t val;
 /*
 	if(xlp_with_mac_driver == 0)
 	{
@@ -434,7 +444,7 @@ static void nlm_xlp_nae_init(void)
 
 	msgrng_access_disable(mflags);
 
-	for (i = 0; i < MAX_NET_INF; i++ )
+	for (i = 0; i < 1/* MAX_NET_INF*/; i++ )
 	{
 		init_ucore(0xffffUL, i);
 	}
@@ -445,10 +455,9 @@ static void nlm_xlp_nae_init(void)
 	init_ingress();
 	init_egress();
 
-	for(i = 0; i< MAX_GMAC_PORT; i++)
+	for(i = 0; i< 1 /*MAX_GMAC_PORT*/; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
-//		dev = alloc_etherdev_mq(sizeof(struct dev_data), 32);
 		if(!dev)
 			return;
 
@@ -460,7 +469,7 @@ static void nlm_xlp_nae_init(void)
 		//set ethtool_ops which is inside xlp_ethtool.c file
 		xlp_set_ethtool_ops(dev);
 
-		netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
+//		netif_napi_add(dev, &tp->napi, nlm_xlp_napi_poll, 16);
 
 //		random_ether_addr(dev->dev_addr);
 		dev->dev_addr = eth_hw_addr[i];
@@ -475,6 +484,7 @@ static void nlm_xlp_nae_init(void)
 		dev_mac_type[tp->type][tp->port] = dev;
 		dev_mac[i] = dev;
 
+		tasklet_init(&mac_refill_task[tp->port],mac_refill_frin_desc,(unsigned long)dev);
 	}
 
 	entry = create_proc_read_entry("nlm_mac_stats", 0 /* def mode */ ,
@@ -486,10 +496,85 @@ static void nlm_xlp_nae_init(void)
 		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",
 		       __FUNCTION__);
 	}
+	/*config free fifo context mapping*/
+	for(i = 0; i < 20; i++)
+	{
+		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
 
+		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
+		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
+
+	//	val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
+	//	printk("After FREE_IN_FIFO_CFG: %d, val: %x\n", i, val);
+	}
+	nlm_xlp_sgmii_setcontext();
 
 }
 
+static void nlm_xlp_sgmii_setcontext()
+{
+	int i = 0;
+	uint32_t val;
+
+	/* XLP_SGMII_RCV_CONTEXT_NUM = 8 */
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_0, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_0 );
+	//printk("RX_IF_BASE_CONFIG_0,: %d, val: %x\n", 0, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_1, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_1 );
+	//printk("RX_IF_BASE_CONFIG_1: %d, val: %x\n", 1, val);
+	 i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_2, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_2 );
+	//printk("RX_IF_BASE_CONFIG_2: %d, val: %x\n", 2, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_3, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_3 );
+	//printk("RX_IF_BASE_CONFIG_3: %d, val: %x\n", 3, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_4, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_4 );
+	//printk("RX_IF_BASE_CONFIG_4: %d, val: %x\n", 4, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_5, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_5 );
+	//printk("RX_IF_BASE_CONFIG_5: %d, val: %x\n", 5, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_6, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_6 );
+	//printk("RX_IF_BASE_CONFIG_6: %d, val: %x\n", 6, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_7, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_7 );
+	//printk("RX_IF_BASE_CONFIG_7: %d, val: %x\n", 7, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
+	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_8, val );
+	//val = nlm_hal_read_nae_reg(RX_IF_BASE_CONFIG_8 );
+	//printk("RX_IF_BASE_CONFIG_6: %d, val: %x\n", 8, val);
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+
+
+
+}
 /**********************************************************************
  * nlm_xlp_nae_open -  called when bring up a device interface
  * @dev  -  this is per device based function
@@ -506,6 +591,10 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	if(priv->inited)
 		return ret;
 
+	if(register_xlp_msgring_handler( XLP_MSG_HANDLE_NAE_0 , nlm_xlp_nae_msgring_handler, dev))
+	{
+		panic("can't register msgring handler for TX_STN_GMAC0");
+	}
 	nlm_xlp_nae_fill_rxfr(dev,  port );
 /*
 	irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
@@ -514,26 +603,16 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		printk("can't get mac interrupt line (%d)\n",dev->irq);
 	}
 	dump_irt_entry(PIC_IRT_NA_INDEX(port));
-	printk("PIC_CTRL: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_CTRL ));
-	printk("PIC_STATUS: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET,PIC_STATUS ));
-	printk("PIC_INT_PENDING0: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING0 ));
-	printk("PIC_INT_PENDING1: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1 ));
-	printk("PIC_INT_PENDING2: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET, PIC_INT_PENDING2 ));
-	printk("PIC_IPI_CTL: %x\n", nlm_hal_read_pic_reg((pic_reg_t*)XLP_IO_PIC_OFFSET,PIC_IPI_CTL ));
 */
-	if(register_msgring_handler( /*XLP_MSG_HANDLE_NAE_0*/ 17 + port, nlm_xlp_nae_msgring_handler, dev))
-	{
-		panic("can't register msgring handler for TX_STN_GMAC0");
-	}
 	/* set timer to test rx routine */
 	init_timer(&priv->link_timer);
 	priv->link_timer.expires = jiffies + HZ/100 ;
 	priv->link_timer.data    = (unsigned long) priv->port;
 	priv->link_timer.function = &nlm_xlp_mac_timer;
 	priv->phy_oldlinkstat = -1;
-/*
-	add_timer(&priv->link_timer);
-*/
+
+//	add_timer(&priv->link_timer);
+
 //	napi_enable(&priv->napi);
 
 
@@ -558,7 +637,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		priv->cpu_stats[i].interrupts	= 0;
 
 	}
-	tasklet_init(&mac_refill_task[port],mac_refill_frin_desc,(unsigned long) dev);
+
 	priv->inited = 1;
 
 	return 0;
@@ -606,20 +685,21 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	if(skb->len == 0)
 	{
 		printk("[%s] skb empty packet\n",__FUNCTION__);
-//		skb->len = 0x4e;
 		return -1;
 	}
-	mac_put_skb_back_ptr(skb);
-	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
+
+	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, (virt_to_bus(skb)|port));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
 							 0,
 							 NULL_VFBID,
 							 skb->len,
-							 virt_to_bus(skb->data+(port&0xf)));
+							 virt_to_bus(skb->data));
 
 	msg.entry[2] = msg.entry[3] = 0;
 
-//	log_info("port:%d send %d skb %llx skb->data %llx len %d to qid %d \n", priv->port,(int)priv->stats.tx_packets, (uint64_t)skb, (uint64_t)skb->data,skb->len, nae_tx_qid);
+//	printk("[nlm_xlp_nae_start_xmit] port:%d send %d skb %llx skb->data %llx len %d to qid %d \n", priv->port,(int)priv->stats.tx_packets, (uint64_t)skb, (uint64_t)skb->data,skb->len, priv->nae_tx_qid);
+
+	//DUMP_PKT()
 
 	__sync();
 	msgrng_access_enable(mflags);
@@ -630,7 +710,23 @@ retry_send:
                            msg.entry[1])))
         {
                 if(ret & MSG_DST_FC_FAIL)
-                        printk("TX message destination flow control credit fail\n");
+		{
+                        printk("TX message destination flow control credit fail: flow control count: %d\n", ret & (0x3fff8));
+			ret = xlp_read_status1();
+			if( ret & (1 << 31))
+			{
+				printk("CPU receive queue written when Full\n");
+
+			}
+			else if(ret & (1 << 30))
+			{
+				printk("Fmn input credit overflow hardware error\n");
+			}
+			else if( ret & (1 << 29))
+			{
+				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
+			}
+		}
                 else if(ret & MSG_INFLIGHT_MSG_EX)
                         goto retry_send;
                 else if(ret & MSG_TXQ_FULL)
@@ -649,7 +745,7 @@ retry_send:
 
 	if(priv->num_desc <= MIN_FRIN_DESC_THRESHD)
 	{
-		netif_stop_queue(dev);
+//		netif_stop_queue(dev);
 	}
 	return NETDEV_TX_OK;
 }
@@ -763,7 +859,7 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	uint32_t rx_status = 0;
 	struct xlp_msg fr_msg =  {{0, 0, 0, 0}} ;
 	struct xlp_msg rx_msg =  {{0, 0, 0, 0}} ;
-	unsigned short port;
+	unsigned short port = 0;
 
 	int cpu_qid = CPU_Q_ID( 0, 0, 0); /* core0 thread0 vc0 */
 	int cpu = 0;
@@ -786,7 +882,6 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 		if(addr && (len==0))
 		{
 			skb = (struct sk_buff *)bus_to_virt(addr);
-//			log_dbg("\nTX: port %d free addr:0x%llx \n",priv->port,(uint64_t)bus_to_virt(addr));
 			if(skb)
 			{
 				priv->stats.rx_packets++;
@@ -839,7 +934,6 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	len = (rx_msg.entry[1] >> 40) & 0x3fff;
 
 	//update dev and port to be accurate
-	port = rx_msg.entry[1]  & 0x0f;
 	dev = dev_mac[port];
 	priv = netdev_priv(dev);
 	if(!len || addr == 0)
@@ -851,7 +945,6 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
 	}
 	vaddr = (uint64_t)bus_to_virt(addr);
 	buf = (unsigned char *)vaddr;
-//	log_dbg("RX: port:%d src_id: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",priv->port,src_id,(uint64_t)buf, len, vaddr);
 
 	if(len  - BYTE_OFFSET -MAC_CRC_LEN - MAC_PREPAD< 0)
 	{
@@ -877,13 +970,10 @@ static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev)
         if (skb) {
 			src = *((unsigned long *)(skb->data-20));
 //			skb_reserve(skb, MAC_PREPAD+BYTE_OFFSET );
-//			printk("%s : addr :%llx  len:%d  skb: %llx src: %d  num_desc: %d\n", __FUNCTION__, addr, len, (uint64_t)skb,src,(int) priv->num_desc);
 			skb_put(skb, len);
 			skb->dev = dev_mac[port];
 			skb->protocol = eth_type_trans(skb, dev_mac[port]);
-//			printk("\n[%s] port: %d  dev %llx  protocol %d\n",__FUNCTION__, priv->port, (uint64_t)dev_mac[port], skb->protocol);
 			skb->dev->last_rx = jiffies;
-//		netif_receive_skb(skb);
 		netif_rx (skb);
 		priv->stats.rx_bytes += len;
 		priv->stats.rx_packets++;
@@ -934,26 +1024,160 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 
 	return IRQ_HANDLED;
 }
-
 /**********************************************************************
  * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
  * @irq     -  irq number
  * @dev_id  -  this device
  *
  **********************************************************************/
-static void nlm_xlp_nae_msgring_handler(int vc, int size, int code, int stid, struct msgrng_msg *msg, void* data)
+static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
+					uint32_t size, uint32_t code,
+					uint64_t msg0, uint64_t msg1,
+					uint64_t msg2, uint64_t msg3, void* data)
 {
         struct net_device *dev;
         struct dev_data *priv;
-printk("%s : stid:%d data: %llx\n", __FUNCTION__,stid, (uint64_t)data );
+	unsigned int len, port = 0, src, cpu, context;
+        unsigned char* buf;
+        uint64_t addr , vaddr;
+	struct sk_buff* skb;
 
-        dev = (struct net_device*)data;
-	if(!data)
-		return;
 
-        priv = netdev_priv(dev);
 
-        nlm_xlp_nae_rx(priv->skb, dev);
+	cpu = vc % 16;
+	vc = vc % 4;
+
+	if( vc == 1)
+	{
+		port = msg0 & 0x0f;
+		//printk("port: %d got src_id: %d msg %llx \n\n",port, src_id, msg0);
+                addr = msg0 & 0xfffffffff0ULL;
+                len = (msg0 >> 40) & 0x3fff;
+
+
+                if(addr && (len==0))
+                {
+			dev = (struct net_device*)dev_mac[port];
+			if(!dev)
+				return;
+			priv = netdev_priv(dev);
+
+                        skb = (struct sk_buff *)bus_to_virt(addr);
+                        if(skb)
+                        {
+                                priv->stats.rx_packets++;
+                                if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15){
+                                       netif_tx_wake_all_queues(dev);
+                                }
+                                dev_kfree_skb_any(skb);
+                        }
+			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+			{
+			//printk("num_desc:%d refill_task[%d]:%x \n", priv->num_desc, priv->port, mac_refill_task[port]);
+				tasklet_schedule(&mac_refill_task[0]);
+			}
+                }
+                else if(addr == 0)
+                {
+                        //case tx queue is stopped
+                        netif_tx_wake_all_queues(dev);
+                }
+	}
+	else if(vc == 0)
+	{
+		addr	= msg1 & 0xfffffffff0ULL;
+		len	= (msg1 >> 40) & 0x3fff;
+		context = msg1 >> 54;
+
+		/*context is XLP_SGMII_RCV_CONTEXT_NUM + three bit vlan type or vlan priority*/
+		port = context / XLP_SGMII_RCV_CONTEXT_NUM;
+
+		//update dev and port to be accurate
+		if(port < 0 || port >= MAX_GMAC_PORT)
+		{
+			port = 0;
+		}
+		dev = (struct net_device*)dev_mac[port];
+		if(!dev)
+			return;
+		priv = netdev_priv(dev);
+
+
+		if(!len || addr == 0)
+		{
+			if( priv->num_desc < MIN_FRIN_DESC_THRESHD)
+				tasklet_schedule(&mac_refill_task[priv->port]);
+
+			return;
+		}
+		vaddr = (uint64_t)bus_to_virt(addr);
+		buf = (unsigned char *)vaddr;
+		//RUN_ON_SIM()
+//printk("RX: port:%d src_id: %d context: %d recv buf: 0x%llx len:%d addr:0x%010llx  \n",priv->port,src_id,context,(uint64_t)buf, len, vaddr);
+
+		if(len - MAC_CRC_LEN  < 0)
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_dropped++;
+			printk("[%s] wrong packet len %d, drop it!",__FUNCTION__,len);
+			return ;
+		}
+		else
+		{
+			len = len  - MAC_CRC_LEN;
+			//printk("len: %d, BYTE_OFFSET: %d, MAC_CRC_LEN: %d, MAC_PREPAD: %d \n", len, BYTE_OFFSET, MAC_CRC_LEN, MAC_PREPAD);
+			if(len >= 2048)
+			{
+				priv->stats.rx_errors++;
+				priv->stats.rx_dropped++;
+				printk("[%s] packet too long %d, drop it!\n",__FUNCTION__,len);
+				return ;
+			}
+		}
+		skb = mac_get_skb_back_ptr(vaddr);
+		if (skb) {
+		//DUMP_PKT()
+#if 1
+			{
+			struct sk_buff *myskb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
+			unsigned long offset;
+			/*align myskb to 64bytes*/
+			offset = 64 -((unsigned long)myskb->data & 0x3f);
+			skb_reserve(myskb, offset+2);
+			memcpy(myskb->data, skb->data, len);
+			kfree_skb(skb);
+			skb = myskb;
+			}
+#endif
+                        src = *((unsigned long *)(skb->data)-20);
+
+                        skb_put(skb, len);
+                        skb->dev = dev_mac[port];
+                        skb->protocol = eth_type_trans(skb, dev_mac[port]);
+                        skb->dev->last_rx = jiffies;
+			netif_rx (skb);
+			priv->stats.rx_bytes += len;
+			priv->stats.rx_packets++;
+			priv->cpu_stats[cpu].rx_packets++;
+			priv->num_desc--;
+			//DUMP_PKT();
+		}
+		else if(!skb)
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_dropped++;
+			printk("[%s] wrong skb addr %llx, drop it!",__FUNCTION__,(uint64_t)skb);
+			return;
+		}
+	}
+
+	return;
+fill_desc:
+        if(priv->num_desc < MIN_FRIN_DESC_THRESHD)
+        {
+                tasklet_schedule(&mac_refill_task[priv->port]);
+        }
+        return;
 }
 
 /**********************************************************************
@@ -1171,10 +1395,9 @@ static void  nlm_xlp_napi_poll(struct napi_struct *napi, int* budget)
  * nlm_xlp_nae_remove - driver remove routine
  * @pdev - pci device.
  **********************************************************************/
-static void nlm_xlp_nae_remove()
+static void nlm_xlp_nae_remove(struct net_device * dev)
 {
 	int i;
-	struct net_device *dev;
         struct dev_data *priv;
 
 	for (i = 0; i < MAX_GMAC_PORT; i++)
@@ -1200,7 +1423,6 @@ static struct pci_driver soc_driver = {
 static int __init nlm_xlp_mac_init(void)
 {
 
-printk("[%s] \n", __FUNCTION__);
 	nlm_xlp_nae_init();
 
 	return pci_register_driver(&soc_driver);
@@ -1208,7 +1430,6 @@ printk("[%s] \n", __FUNCTION__);
 
 static void __exit nlm_xlp_mac_exit(void)
 {
-	nlm_xlp_nae_remove();
 	pci_unregister_driver(&soc_driver);
 }
 
-- 
1.7.1

