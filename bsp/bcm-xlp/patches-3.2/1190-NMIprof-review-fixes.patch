From f4164d5b54ed7c0d2da236cf955fb8e37c0ad106 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Mon, 7 Oct 2013 16:52:14 +0530
Subject: NMIprof: review fixes

- error return should be EINVAL in case of bad input
- cpu id should be translated to hw thread id before giving to
  PIC
- do not update dev->nlm_cpu unless smp call function succeeds
- error messages should be dev_err
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
index 07c64e0..66e4ffb 100644
--- a/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
+++ b/drivers/misc/netlogic/nmiprof/nmiprof-sys.c
@@ -67,7 +67,7 @@ static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
 		char *buf, loff_t pos, size_t size)
 {
 	u32 *write_asm;
-	int ret, use_cpu;
+	int ret, use_cpu, hwcpu;
 	char *reset_data = (char *)CKSEG1ADDR(RESET_VEC_PHYS);
 	uint64_t xlp_pic_base = nlm_get_pic_regbase(0); /* Node 0 */
 
@@ -75,50 +75,49 @@ static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
 
 	/* Get cpu */
 	use_cpu = simple_strtol(buf, NULL, 0);
-
 	if (use_cpu >= NLM_NR_CPUS || use_cpu  < -1) {
-		dev_info(&ndev->dev->dev, "Invalid CPU %d\n"
-			"Help - cpu mask on XLP8xx 0-31 and on XLP9xx 0-79\n", use_cpu);
-		return size;
-	}
-
-	if (!ndev->state || use_cpu == -1) {
-		dev_info(&ndev->dev->dev, "Not running on any cpu\n");
-		return size;
+		dev_info(&ndev->dev->dev,
+			"Invalid CPU %d, valid values are 0-%d\n",
+							use_cpu, NLM_NR_CPUS);
+		return -EINVAL;
 	}
 
 	/* Stop the profiler */
 	if (use_cpu == -1) {
+		if (!ndev->state) {
+			dev_info(&ndev->dev->dev, "Not running on any cpu\n");
+			return -EINVAL;
+		}
 		nlm_pic_set_timer(xlp_pic_base, 6, ~0ULL, 0, 0);
 		memcpy(reset_data, (void *)nmiprofsave,
 				(nlm_nmiprof_end - nlm_nmiprof));
 		ndev->state = 0;
-		dev_info(&ndev->dev->dev, "Stopped tracing on cpu %d\n", ndev->nlm_cpu);
+		dev_info(&ndev->dev->dev, "Stopped tracing on cpu %d\n",
+								ndev->nlm_cpu);
 		ndev->nlm_cpu = NLM_NR_CPUS;
 		module_put(THIS_MODULE);
 		return size;
 	}
 
 	if (ndev->state) {
-		dev_info(&ndev->dev->dev, "Running on cpu %d\n" 
-			"To stop nmiprof: echo -1 > nmiprofcontrol\n", ndev->nlm_cpu);
-		return size;
+		dev_info(&ndev->dev->dev, "Already running on cpu %d\n"
+			"To stop nmiprof: echo -1 > nmiprofcontrol\n",
+								ndev->nlm_cpu);
+		return -EINVAL;
 	}
 
-	/* Start the profiler on use_cpu */
-	ndev->nlm_cpu = use_cpu;
-
+	hwcpu = cpu_logical_map(ndev->nlm_cpu);
 	memset(ndev->base, 0xa5, NMIPROF_LOG_SIZE);
-	/* Setting scratch reg of requested cpu
-	 * with the memory address */
-	ret = smp_call_function_single(ndev->nlm_cpu, nlm_config_cpu,
+	ret = smp_call_function_single(use_cpu, nlm_config_cpu,
 			ndev->base, 1);
 	if (ret) {
 		dev_info(&ndev->dev->dev, "smp call function error\n");
 		return ret;
 	}
 
-	dev_info(&ndev->dev->dev, "nmiprof: start tracing on cpu %d\n", ndev->nlm_cpu);
+	ndev->nlm_cpu = use_cpu;
+	dev_info(&ndev->dev->dev, "nmiprof: start tracing on cpu %d (hw %d)\n",
+							ndev->nlm_cpu, hwcpu);
 	memcpy((void *)nmiprofsave, reset_data,
 			(nlm_nmiprof_end - nlm_nmiprof));
 	memcpy(reset_data, nlm_nmiprof, (nlm_nmiprof_end - nlm_nmiprof));
@@ -134,11 +133,10 @@ static ssize_t nlm_nmiprofcontrol_write(struct file *filp, struct kobject *kobj,
 	write_asm++;
 	*write_asm |= ((xlp_pic_base & 0xffff) + (PIC_INT_ACK << 2));
 
-	nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3,
-			ndev->nlm_cpu);
+	nlm_pic_set_timer(xlp_pic_base, 6, 509 * 1499ull, -3, hwcpu);
 	ndev->state = 1;
 	if (!try_module_get(THIS_MODULE))
-		printk(KERN_WARNING "%s:cannot get module\n", __func__);
+		pr_warn("%s:cannot get module\n", __func__);
 
 	return size;
 }
@@ -155,9 +153,8 @@ static int __init nlm_init_sys(void)
 
 	ndev->dev = platform_device_register_simple("nmiprof", -1, NULL, 0);
 	if (IS_ERR(ndev->dev)) {
-		printk(KERN_ERR
-		"nl_pf_fs:%s:platform_device_register_simple "
-		"failed\n", __func__);
+		pr_err("%s:platform_device_register_simple failed\n",
+								__func__);
 		err = EBUSY;
 		goto platform_err;
 	}
@@ -165,7 +162,7 @@ static int __init nlm_init_sys(void)
 	ndev->base = (u64 *) __get_free_pages(GFP_ATOMIC,
 			get_order(NMIPROF_LOG_SIZE));
 	if (!ndev->base) {
-		pr_info("Allocation of free pages failed\n");
+		dev_err(&ndev->dev->dev, "Allocation of free pages failed\n");
 		err = ENOMEM;
 		goto page_err;
 	}
@@ -190,13 +187,13 @@ static int __init nlm_init_sys(void)
 
 	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->bindata_attr);
 	if (err) {
-		dev_info(&ndev->dev->dev, "can't create attribute file\n");
+		dev_err(&ndev->dev->dev, "can't create attribute file\n");
 		goto sys_err1;
 	}
 
 	err = sysfs_create_bin_file(&ndev->dev->dev.kobj, &ndev->binnmiprof_attr);
 	if (err) {
-		dev_info(&ndev->dev->dev, "can't create attribute file\n");
+		dev_err(&ndev->dev->dev, "can't create attribute file\n");
 		goto sys_err;
 	}
 	return 0;
-- 
1.7.1

