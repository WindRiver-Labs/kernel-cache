From 602d0ec80c03b8723865847dc0dd35b95c2eeb27 Mon Sep 17 00:00:00 2001
From: Subhendu Sekhar Behera <sbehera@broadcom.com>
Date: Fri, 20 Jun 2014 13:47:59 +0530
Subject: MIPS: Netlogic: Watchdog improvements

1. make it a module
2. add smp execution for keepalive
3. remove unnecessary header files, macros etc.

Signed-off-by: Subhendu Sekhar Behera <sbehera@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index b50f5e1..f5d457e 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1071,7 +1071,7 @@ config TXX9_WDT
 	  Hardware driver for the built-in watchdog timer on TXx9 MIPS SoCs.
 
 config NLM_WATCHDOG
-	tristate "Netlogic XL* Hardware Watchdog"
+	bool "Netlogic XL* Hardware Watchdog"
 	depends on WATCHDOG_CORE && NLM_COMMON
 	help
 	  Hardware driver for the XL* watchdog. This is a watchdog timer
diff --git a/drivers/watchdog/nlm_common_wdt.c b/drivers/watchdog/nlm_common_wdt.c
index 73cf2ea..aba1f6c 100644
--- a/drivers/watchdog/nlm_common_wdt.c
+++ b/drivers/watchdog/nlm_common_wdt.c
@@ -27,15 +27,6 @@
  *
  * #BRCM_2# */
 
-
-/* 
- * TODO:
- * 2. Move from RESET to NMI, dump regs on NMI
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/types.h>
@@ -43,171 +34,125 @@
 #include <linux/miscdevice.h> /* for MODULE_ALIAS_MISCDEV */
 #include <linux/watchdog.h>
 #include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/cpufreq.h>
-#include <linux/slab.h>
 #include <linux/err.h>
-#include <linux/spinlock.h>
-#include <linux/cpu.h>
-#include <linux/smp.h>
-#include <linux/platform_device.h>
 
-#include <asm/netlogic/common.h>
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/mips-extns.h>
-
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 #include <asm/mach-netlogic/multi-node.h>
 
-#define WDOG_TIMEOUT	10
-#define WDOG_INDEX	0
+#define DRV_NAME		"nlm-wdt"
+
+#define WDOG_TIMEOUT		60
+#define WDOG_INDEX		0
 
-#define WDOG_RST_WRAP_CNT 3
-#define WDOG_NMI_WRAP_CNT 1
+/* keep no. of reset interrupts to maximum*/
+#define WDOG_RST_WRAP_CNT	3
 
 struct nlm_wdt_data {
-	spinlock_t lock;
+	u64 base;
+	struct watchdog_device nlm_wdt_wdd;
 };
 
+static struct platform_device *nlm_wdt_device;
+
 /* (secs) Default is 1 minute */
 static unsigned int heartbeat = WDOG_TIMEOUT;
-module_param(heartbeat, int, S_IRUGO);
+module_param(heartbeat, uint, S_IRUGO);
 MODULE_PARM_DESC(heartbeat,
 	"Watchdog heartbeat in seconds. (0 < heartbeat, default="
 				__MODULE_STRING(WDOG_TIMEOUT) ")");
 
 /* There are 2 watchdog timers, specify or '0' as default */
 static unsigned int wd_index = WDOG_INDEX;
-module_param(wd_index, int, S_IRUGO);
+module_param(wd_index, uint, S_IRUGO);
 MODULE_PARM_DESC(wd_index,
 	"Watchdog to use, 0 and 1 are valid inputs (default="
 				__MODULE_STRING(WDOG_INDEX) ")");
 
-static struct watchdog_info nlm_wdt_ident = {
-	.options =	WDIOF_MAGICCLOSE |
-			WDIOF_SETTIMEOUT |
-			WDIOF_KEEPALIVEPING,
-	.identity	= "XLP Watchdog",
-};
-
-#define get_pic_base_current() nlm_get_node(nlm_cpuid_to_node(smp_processor_id()))->picbase
-
-#define get_pic_base_cpu(c) nlm_get_node(nlm_cpuid_to_node((c)))->picbase
-
-static void nlm_wdt_cpu_setup(int cpu)
+static void nlm_wdt_cpu_setup(int cpu, u64 base)
 {
 	u64 val;
-	int base;
 	int cpuid = cpu_logical_map(cpu);
 
-	base = get_pic_base_cpu(cpu);
-
 	/* Enable0 can configure upto 64 threads, for more use Enable1 */
 	if (cpuid < 64) {
-	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
-	     val |= 1ULL << cpuid;
-	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
+		val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
+		val |= 1ULL << cpuid;
+		nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
 	} else	{
 		val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE1(wd_index));
-	     val |= 1ULL << (cpuid - 64);
-	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
+		val |= 1ULL << (cpuid - 64);
+		nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
 	}
 	/* Set the Beat for this cpu */
 	nlm_write_pic_reg(base, PIC_WDOG_BEATCMD(wd_index), cpuid);
 }
 
-static void nlm_wdt_cpu_cleanup(int cpu)
+static void nlm_wdt_cpu_cleanup(int cpu, u64 base)
 {
 	u64 val;
-	int base;
 	int cpuid = cpu_logical_map(cpu);
 
-	base = get_pic_base_cpu(cpu);
-
 	/* Enable0 can configure upto 64 threads, for more use Enable1 */
 	if (cpuid < 64) {
-	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
-	     val &= ~(1ULL << cpuid);
-	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
+		val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE0(wd_index));
+		val &= ~(1ULL << cpuid);
+		nlm_write_pic_reg(base, PIC_WDOG_ENABLE0(wd_index), val);
 	} else	{
-	     val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE1(wd_index));
-	     val &= ~(1ULL << (cpuid - 64));
-	     nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
-       }
+		val = nlm_read_pic_reg(base, PIC_WDOG_ENABLE1(wd_index));
+		val &= ~(1ULL << (cpuid - 64));
+		nlm_write_pic_reg(base, PIC_WDOG_ENABLE1(wd_index), val);
+	}
 }
 
-static int nlm_wdt_hotplug_notify(struct notifier_block *this,
-			      unsigned long code,
-			      void *hotcpu)
+static void nlm_wdt_keepalive(void *data)
 {
-	unsigned int cpu = (unsigned long)hotcpu;
-	switch (code) {
-	case CPU_ONLINE:
-		nlm_wdt_cpu_setup(cpu);
-		break;
-	case CPU_DOWN_PREPARE:
-		nlm_wdt_cpu_cleanup(cpu);
-		break;
-	default:
-		break;
-	}
-	return NOTIFY_DONE;
-}
+	struct nlm_wdt_data *wdt = data;
 
-static struct notifier_block nlm_notifier = {
-	.notifier_call = nlm_wdt_hotplug_notify,
-};
+	/*
+	 * BEATCMD should be written ((4 * cpuno) + threadno),
+	 * hard_smp_processor_id() is exactly that
+	 */
+	nlm_write_pic_reg(wdt->base, PIC_WDOG_BEATCMD(wd_index),
+		hard_smp_processor_id());
+}
 
-static int nlm_wdt_keepalive(struct watchdog_device *wdt_dev)
+static int nlm_wdt_ping(struct watchdog_device *wdt_dev)
 {
 	int lcpu;
-	u64 base;
 	struct nlm_wdt_data *wdt = watchdog_get_drvdata(wdt_dev);
-	base = get_pic_base_current();
-
-	spin_lock(&wdt->lock);
-	for_each_online_cpu(lcpu) {
-		u64 base = get_pic_base_cpu(lcpu);
-		int cpu = cpu_logical_map(lcpu);
-
-		/*
-		 * BEATCMD should be written ((4 * cpuno) + threadno),
-		 * cpu is exactly that
-		 */
-		nlm_write_pic_reg(base, PIC_WDOG_BEATCMD(wd_index), cpu);
 
-	}
-	spin_unlock(&wdt->lock);
+	for_each_online_cpu(lcpu)
+		smp_call_function_single(lcpu, nlm_wdt_keepalive, wdt, true);
 
 	return 0;
 }
 
-static int nlm_wdt_start(struct watchdog_device *wdt_dev) 
+static int nlm_wdt_start(struct watchdog_device *wdt_dev)
 {
 	int cpu;
-	u64 base = get_pic_base_current();
+	u64 ctrl;
+	struct nlm_wdt_data *wdt = watchdog_get_drvdata(wdt_dev);
 
 	/*
 	 * Program max value, once watchdog reaches 0,
 	 * value in this register is used to reload
 	 */
-	nlm_write_pic_reg(base, PIC_WDOG_MAXVAL(wd_index),
-				(pic_timer_freq() * heartbeat) >> 2);
+	nlm_write_pic_reg(wdt->base, PIC_WDOG_MAXVAL(wd_index),
+		((u64)(pic_timer_freq() * heartbeat)) >> 2);
 
 	for_each_online_cpu(cpu)
-		nlm_wdt_cpu_setup(cpu);
-
-	/* TODO: This should be changed to NMI */
-	/* Enable watchdog[0/1], also set wraparound count */
-	nlm_write_pic_reg(base, PIC_CTRL,
-			  nlm_read_pic_reg(base, PIC_CTRL) |
-			  WDOG_RST_WRAP_CNT << PIC_CTRL_WWR0 |
-			  WDOG_RST_WRAP_CNT << PIC_CTRL_WWR1 |
-			  //WDOG_NMI_WRAP_CNT << PIC_CTRL_WWN0 |
-			  //WDOG_NMI_WRAP_CNT << PIC_CTRL_WWN1 |
-			  1 << wd_index);
+		nlm_wdt_cpu_setup(cpu, wdt->base);
+
+	ctrl = nlm_read_pic_reg(wdt->base, PIC_CTRL);
+	ctrl |= (WDOG_RST_WRAP_CNT << PIC_CTRL_WWR0 |
+		 WDOG_RST_WRAP_CNT << PIC_CTRL_WWR1 |
+		 1 << wd_index);
+
+	nlm_write_pic_reg(wdt->base, PIC_CTRL, ctrl);
 
 	return 0;
 }
@@ -215,53 +160,61 @@ static int nlm_wdt_start(struct watchdog_device *wdt_dev)
 static int nlm_wdt_stop(struct watchdog_device *wdt_dev)
 {
 	int cpu;
-	u64 base = get_pic_base_current();
-	u64 val = nlm_read_pic_reg(base, PIC_CTRL);
+	u64 val;
+	struct nlm_wdt_data *wdt = watchdog_get_drvdata(wdt_dev);
 
+	val = nlm_read_pic_reg(wdt->base, PIC_CTRL);
 	val &= ~(1 << wd_index);
-	nlm_write_pic_reg(base, PIC_CTRL, val);
-			  
+	nlm_write_pic_reg(wdt->base, PIC_CTRL, val);
+
 	for_each_online_cpu(cpu)
-		nlm_wdt_cpu_cleanup(cpu);
+		nlm_wdt_cpu_cleanup(cpu, wdt->base);
 
 	return 0;
 }
 
 static int nlm_wdt_set_timeout(struct watchdog_device *wdt_dev, unsigned int t)
 {
-	u64 base = get_pic_base_current();
+	struct nlm_wdt_data *wdt = watchdog_get_drvdata(wdt_dev);
 
 	heartbeat = t;
-	nlm_write_pic_reg(base, PIC_WDOG_MAXVAL(wd_index),
-				(pic_timer_freq() * t) >> 2);
-        
+	nlm_write_pic_reg(wdt->base, PIC_WDOG_MAXVAL(wd_index),
+		(pic_timer_freq() * t) >> 2);
+
 	return 0;
 }
 
+static struct watchdog_info nlm_wdt_ident = {
+	.options = WDIOF_MAGICCLOSE |
+		   WDIOF_SETTIMEOUT |
+		   WDIOF_KEEPALIVEPING,
+	.identity = "XLP Watchdog",
+};
+
 static struct watchdog_ops nlm_wdt_ops = {
 	.owner = THIS_MODULE,
 	.start = nlm_wdt_start,
 	.stop = nlm_wdt_stop,
-	.ping = nlm_wdt_keepalive,
+	.ping = nlm_wdt_ping,
 	.set_timeout = nlm_wdt_set_timeout,
 };
 
-static struct watchdog_device nlm_wdt_wdd = {
-	.info = &nlm_wdt_ident,
-	.ops = &nlm_wdt_ops,
-};
-
-/* hotplug */
-
-static int __devinit nlm_wdt_probe(struct platform_device *pdev)
+static int nlm_wdt_probe(struct platform_device *pdev)
 {
 
 	struct nlm_wdt_data *wdt;
-	struct resource *res;
+	struct watchdog_device *wdd;
 	int ret;
 
+#ifdef CONFIG_NLM_MULTINODE
+	if (cpu_is_xlp9xx())
+		dev_info(&pdev->dev,
+			"Watchdog not supported in MNXLP9XX configuration\n");
+	return -ENODEV;
+#endif
+
 	/* set index to sane value */
-	wd_index = wd_index ? 1: 0;
+	wd_index = wd_index ? 1 : 0;
 
 	/*
 	 * Global watchdog, disabling percpu instances
@@ -269,75 +222,76 @@ static int __devinit nlm_wdt_probe(struct platform_device *pdev)
 	if (pdev->id != -1)
 		return -EINVAL;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (unlikely(!res))
-		ret = -EINVAL;
-
-	wdt = devm_kzalloc(&pdev->dev, sizeof(struct nlm_wdt_data),
-			   GFP_KERNEL);
+	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
 	if (unlikely(!wdt))
 		return -ENOMEM;
 
-	watchdog_set_drvdata(&nlm_wdt_wdd, wdt);
-
-	ret = watchdog_register_device(&nlm_wdt_wdd);
-	if (ret) {
-		pr_err("Can't register watchdog(ret=%d)\n", ret);
-		goto free_out;
-	}
+	wdt->base = nlm_get_node(0)->picbase;
+	wdd = &wdt->nlm_wdt_wdd;
+	wdd->info = &nlm_wdt_ident;
+	wdd->ops = &nlm_wdt_ops;
+	watchdog_set_drvdata(&wdt->nlm_wdt_wdd, wdt);
 
-	ret = register_hotcpu_notifier(&nlm_notifier);
+	ret = watchdog_register_device(&wdt->nlm_wdt_wdd);
 	if (ret) {
-		pr_err("Can't register notifier (err=%d)\n", ret);
-		goto unreg_wdd;
+		dev_err(&pdev->dev, "Can't register watchdog(ret=%d)\n", ret);
+		return ret;
 	}
 
 	platform_set_drvdata(pdev, wdt);
-
 	dev_info(&pdev->dev, "initialized.\n");
 
 	return 0;
-
-unreg_wdd:
-	watchdog_unregister_device(&nlm_wdt_wdd);
-free_out:
-	devm_kfree(&pdev->dev, wdt);
-	
-	return ret;
-
 }
 
-static int __devexit nlm_wdt_remove(struct platform_device *pdev)
+static int nlm_wdt_remove(struct platform_device *pdev)
 {
-	struct nlm_wdt_data *wdt = dev_get_drvdata(&pdev->dev);
-
-	watchdog_unregister_device(&nlm_wdt_wdd);
-
-	unregister_hotcpu_notifier(&nlm_notifier);
+	struct nlm_wdt_data *wdt;
 
-	devm_kfree(&pdev->dev, wdt);
+	wdt = platform_get_drvdata(pdev);
+	watchdog_unregister_device(&wdt->nlm_wdt_wdd);
 
 	return 0;
 }
 
-static const struct of_device_id nlm_wdt_match[] = {
-	{ .compatible = "netlogic,nlm-wdt" },
-	{},
-};
-
-
-
 static struct platform_driver nlm_wdt_driver = {
 	.probe = nlm_wdt_probe,
-	.remove = __devexit_p(nlm_wdt_remove),
+	.remove = nlm_wdt_remove,
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = "nlm-wdt",
-		.of_match_table = nlm_wdt_match,
+		.name = DRV_NAME,
 	},
 };
 
-module_platform_driver(nlm_wdt_driver);
+static int __init nlm_wdt_init(void)
+{
+	int ret = platform_driver_register(&nlm_wdt_driver);
+
+	if (ret)
+		return ret;
+
+	nlm_wdt_device = platform_device_register_simple(DRV_NAME, -1, NULL, 0);
+
+	if (IS_ERR(nlm_wdt_device)) {
+		ret = PTR_ERR(nlm_wdt_device);
+		goto unreg_nlm_wdt;
+	}
+
+	return 0;
+
+unreg_nlm_wdt:
+	platform_driver_unregister(&nlm_wdt_driver);
+	return ret;
+}
+
+static void __exit nlm_wdt_exit(void)
+{
+	platform_device_unregister(nlm_wdt_device);
+	platform_driver_unregister(&nlm_wdt_driver);
+}
+
+module_init(nlm_wdt_init);
+module_exit(nlm_wdt_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
-- 
1.7.1

