From c756ed4257321d64501934351eab5c84bfa16202 Mon Sep 17 00:00:00 2001
From: Prem Mallappa <pmallapp@broadcom.com>
Date: Tue, 9 Sep 2014 15:24:57 +0530
Subject: RNG: XLP: Support for DRNG.

Signed-off-by: Prem Mallappa <pmallapp@broadcom.com>

Conflicts:

	drivers/char/hw_random/Kconfig
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/iomap.h b/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
index 805bfd2..b2c7c65 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
@@ -111,6 +111,9 @@
 #define XLP_IO_SPI_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 7, 2)
 #define XLP_IO_MMC_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 7, 3)
 
+#define XLP_IO_RSA_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 5, 2)
+
+
 /* Things have changed drastically in XLP 9XX */
 #define XLP9XX_HDR_OFFSET(n, d, f)	\
 			XLP_IO_PCI_OFFSET(xlp9xx_get_socbus(n), d, f)
@@ -134,6 +137,9 @@
 #define XLP9XX_IO_USB_XHCI0_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 4, 1)
 #define XLP9XX_IO_USB_XHCI1_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 4, 2)
 
+/* RSA Engine */
+#define XLP9XX_IO_RSA_OFFSET(node)              XLP9XX_HDR_OFFSET(node, 5, 2)
+
 /* XLP9XX on-chip SATA controller */
 #define XLP9XX_IO_SATA_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 3, 2)
 
diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index 2f9dbf7..220c1f2 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -99,6 +99,19 @@ config HW_RANDOM_BCM2835
 
 	  If unsure, say Y.
 
+config HW_RANDOM_NETLOGIC
+	tristate "NetLogic Deterministic RNG Support"
+	depends on HW_RANDOM && NLM_XLP_BOARD
+	default HW_RANDOM
+	---help---
+	  This driver provides kernel-side support for the Random Number
+	  Generator on the Broadcom XLP-II Processors.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called netlogic-rng
+
+	  If unusure, say Y.
+
 config HW_RANDOM_GEODE
 	tristate "AMD Geode HW Random Number Generator support"
 	depends on HW_RANDOM && X86_32 && PCI
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index bed467c..eb38758 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_HW_RANDOM_INTEL) += intel-rng.o
 obj-$(CONFIG_HW_RANDOM_AMD) += amd-rng.o
 obj-$(CONFIG_HW_RANDOM_ATMEL) += atmel-rng.o
 obj-$(CONFIG_HW_RANDOM_BCM63XX)	+= bcm63xx-rng.o
+obj-$(CONFIG_HW_RANDOM_NETLOGIC) += netlogic-rng.o
 obj-$(CONFIG_HW_RANDOM_GEODE) += geode-rng.o
 obj-$(CONFIG_HW_RANDOM_N2RNG) += n2-rng.o
 n2-rng-y := n2-drv.o n2-asm.o
diff --git a/drivers/char/hw_random/netlogic-rng.c b/drivers/char/hw_random/netlogic-rng.c
new file mode 100644
index 0000000..30878e7
--- /dev/null
+++ b/drivers/char/hw_random/netlogic-rng.c
@@ -0,0 +1,304 @@
+/*
+ * Deterministic Random number generator for Netlogic XLP processors
+ *
+ * Copyright (C) 2014, Broadcom Corporation
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/hw_random.h>
+#include <linux/delay.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define XLP_DRNG_BASE		0x5c
+#define XLP_DRNG_CFG		(XLP_DRNG_BASE + 0)
+#define XLP_DRNG_RESEED_TIME	(XLP_DRNG_BASE + 1)
+#define XLP_DRNG_PERSONAL_STR0	(XLP_DRNG_BASE + 2)
+#define XLP_DRNG_PERSONAL_STR1	(XLP_DRNG_BASE + 3)
+#define XLP_DRNG_DATA(n)	(XLP_DRNG_BASE + 0x4 + (n))
+
+#define XLP9XX_DRNG_BASE		0x25
+#define XLP9XX_DRNG_CFG			((XLP9XX_DRNG_BASE + 0)*2)
+#define XLP9XX_DRNG_SWM			((XLP9XX_DRNG_BASE + 1)*2)
+#define XLP9XX_DRNG_RESEED_TIME		((XLP9XX_DRNG_BASE + 2)*2)
+#define XLP9XX_DRNG_PERSONAL_STR	((XLP9XX_DRNG_BASE + 3)*2)
+#define XLP9XX_DRNG_DATA(n)		((XLP9XX_DRNG_BASE + 0x4 + (n))*2)
+
+#define XLP_DRNG_CFG_ENABLE	0
+#define XLP_DRNG_CFG_RAWMODE	1
+#define XLP_DRNG_CFG_RESET	2
+#define XLP_DRNG_CFG_RESEED	3
+#define XLP_DRNG_CFG_BUSY	4
+#define XLP_DRNG_CFG_VALID	5
+#define XLP_DRNG_CFG_DRAW	6
+#define XLP_DRNG_CFG_ERR0	7
+#define XLP_DRNG_CFG_ERR1	8
+#define XLP_DRNG_CFG_ERR2	9
+
+/* Raw mode bypasses the Deterministic logic */
+static unsigned int global_raw_mode;
+module_param(global_raw_mode, int, S_IRUGO);
+MODULE_PARM_DESC(global_raw_mode,
+		"Raw mode, bypass the deterministic generator (Default="
+		__MODULE_STRING(0) ")");
+
+static int is_9xx;
+
+static inline uint32_t drng_get_data(uint32_t);
+static inline uint32_t drng_get_data_9xx(uint32_t);
+
+struct xlp_rng_data_priv {
+	uint64_t rsa_regbase;
+	uint32_t drng_base;
+	uint32_t drng_cfg;
+	uint32_t drng_swm;
+	uint32_t drng_reseed_time;
+	uint32_t drng_personal_str0;
+	uint32_t drng_personal_str1;
+	uint32_t max_data;
+	uint32_t (*rng_data) (uint32_t);
+	struct hwrng drng;
+} xlp_rng_data_list[] = {
+	[0] = { 0, XLP_DRNG_BASE, XLP_DRNG_CFG, -1,
+		XLP_DRNG_RESEED_TIME, XLP_DRNG_PERSONAL_STR0,
+		XLP_DRNG_PERSONAL_STR1, 8, drng_get_data },
+	[1] = { 0, XLP9XX_DRNG_BASE, XLP9XX_DRNG_CFG,
+		XLP9XX_DRNG_SWM, XLP9XX_DRNG_RESEED_TIME,
+		XLP9XX_DRNG_PERSONAL_STR, -1, 4, drng_get_data_9xx },
+};
+
+
+static inline void drng_write_reg(struct xlp_rng_data_priv *priv,
+			uint32_t reg, uint64_t val)
+{
+	is_9xx ? nlm_write_reg64(priv->rsa_regbase, reg, val) :
+		nlm_write_reg(priv->rsa_regbase, reg, (uint32_t)val);
+}
+
+static inline uint64_t drng_read_reg(struct xlp_rng_data_priv *priv,
+			uint32_t reg)
+{
+	return is_9xx ? nlm_read_reg64(priv->rsa_regbase, reg) :
+		(uint64_t)nlm_read_reg(priv->rsa_regbase, reg);
+}
+
+static inline uint32_t drng_get_data(uint32_t index)
+{
+	return XLP_DRNG_DATA(index);
+}
+
+static inline uint32_t drng_get_data_9xx(uint32_t index)
+{
+	return XLP9XX_DRNG_DATA(index);
+}
+
+static int nlm_drng_init(struct hwrng *rng)
+{
+	uint64_t errors, cfg;
+	struct xlp_rng_data_priv *priv =
+		container_of(rng, struct xlp_rng_data_priv, drng);
+
+	/* if already enabled then exit */
+	cfg = drng_read_reg(priv, priv->drng_cfg);
+	if (cfg & (1 << XLP_DRNG_CFG_ENABLE))
+		return 0;
+
+	/* Reset the device */
+	cfg = drng_read_reg(priv, priv->drng_cfg);
+	drng_write_reg(priv, priv->drng_cfg, cfg & ~(1 << XLP_DRNG_CFG_RESET));
+	drng_write_reg(priv, priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESET));
+
+	/* min 2 cycles for h/w to settle down */
+	udelay(10);
+
+	/* Ask the generator to reseed after every request */
+	drng_write_reg(priv, priv->drng_reseed_time, 100);
+
+	errors = (cfg >> XLP_DRNG_CFG_ERR0) & 0x7; /* 3 err bits */
+
+	if (errors || global_raw_mode) {
+		pr_crit("RNG Health Not good: 0x%lx\n", (unsigned long)errors);
+		pr_info("Using DRNG in raw mode");
+		cfg |= (1 << XLP_DRNG_CFG_RAWMODE);
+	}
+	cfg |= (1 << XLP_DRNG_CFG_ENABLE);
+
+	/* Enable now */
+	drng_write_reg(priv, priv->drng_cfg, cfg);
+
+	return 0;
+}
+
+static void nlm_drng_cleanup(struct hwrng *rng)
+{
+	/* just disable the device */
+	struct xlp_rng_data_priv *priv =
+		container_of(rng, struct xlp_rng_data_priv, drng);
+	uint64_t cfg = drng_read_reg(priv, priv->drng_cfg);
+	cfg &= ~1;
+	drng_write_reg(priv, priv->drng_cfg, cfg);
+}
+
+static inline int nlm_drng_data_valid(struct xlp_rng_data_priv *priv)
+{
+	uint64_t cfg;
+	cfg = drng_read_reg(priv, priv->drng_cfg);
+	return (cfg >> XLP_DRNG_CFG_VALID) & 1;
+}
+
+static int nlm_drng_data_present(struct hwrng *rng, int wait)
+{
+	int i = 20;
+	struct xlp_rng_data_priv *priv =
+		container_of(rng, struct xlp_rng_data_priv, drng);
+
+	/* check the data vaild bit is set or not */
+	while (!nlm_drng_data_valid(priv)) {
+		/* delay of 2us as capacity is 2M 256-bit data per sec. */
+		if (wait)
+			udelay(2);
+		if (i--)
+			break;
+	}
+
+	return nlm_drng_data_valid(priv);
+}
+
+static int nlm_drng_read(struct hwrng *rng, void *buffer,
+				size_t size, bool wait)
+{
+	int i;
+	int count = 0;
+	uint64_t cfg;
+	struct xlp_rng_data_priv *priv =
+		container_of(rng, struct xlp_rng_data_priv, drng);
+
+	/* check if data is available or not */
+	if (!rng->data_present(rng, wait))
+		return 0;
+
+	/* From manual, 0-7 registers must be read in-order */
+	if (is_9xx) {
+		uint64_t *val = (uint64_t *)buffer;
+		for (i = 0; (i < priv->max_data) && (count < size); i++) {
+			*val++ = drng_read_reg(priv, priv->rng_data(i));
+			count += sizeof(*val);
+		}
+	} else {
+		uint32_t *val = (uint32_t *)buffer;
+		for (i = 0; (i < priv->max_data) && (count < size); i++) {
+			*val++ = drng_read_reg(priv, priv->rng_data(i));
+			count += sizeof(*val);
+		}
+	}
+
+	/* set the reseed bit */
+	cfg = drng_read_reg(priv, priv->drng_cfg);
+	drng_write_reg(priv, priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESEED));
+
+	return count;
+}
+
+static int __devinit nlm_drng_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct xlp_rng_data_priv *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(&pdev->dev,
+		sizeof(struct xlp_rng_data_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_info("Couldn't get resource !!!\n");
+		return -ENOMEM;
+	}
+
+	*priv = cpu_is_xlp9xx() ? xlp_rng_data_list[1] : xlp_rng_data_list[0];
+	if (cpu_is_xlp9xx())
+		is_9xx = 1;
+	else
+		is_9xx = 0;
+
+	priv->rsa_regbase =
+		(unsigned long)devm_request_and_ioremap(&pdev->dev, res);
+	if (!priv->rsa_regbase) {
+		dev_err(&pdev->dev, "device io remap failed !!!\n");
+		return -ENOMEM;
+	}
+
+	priv->drng.priv = 0;
+	priv->drng.name = pdev->name;
+	priv->drng.init = nlm_drng_init;
+	priv->drng.cleanup = nlm_drng_cleanup;
+	priv->drng.data_present = nlm_drng_data_present;
+	priv->drng.read = nlm_drng_read;
+
+	ret = hwrng_register(&priv->drng);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register RNG\n");
+		goto out;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	/* Reset the device */
+	{
+		uint64_t cfg = drng_read_reg(priv, priv->drng_cfg);
+		drng_write_reg(priv,
+			priv->drng_cfg, cfg & ~(1 << XLP_DRNG_CFG_RESET));
+		drng_write_reg(priv,
+			priv->drng_cfg, cfg | (1 << XLP_DRNG_CFG_RESET));
+	}
+
+	dev_info(&pdev->dev, "Registered Nlm_Drng RNG\n");
+
+	return 0;
+out:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+
+}
+
+static int __devexit nlm_drng_remove(struct platform_device *pdev)
+{
+	struct xlp_rng_data_priv *priv = platform_get_drvdata(pdev);
+	devm_kfree(&pdev->dev, priv);
+	return 0;
+}
+
+static const struct of_device_id nlm_drng_match[] = {
+	{ .compatible = "netlogic,nlm-drng" },
+	{},
+};
+
+static struct platform_driver nlm_drng_driver = {
+	.probe		= nlm_drng_probe,
+	.remove		= __devexit_p(nlm_drng_remove),
+	.driver		= {
+		.name	= "nlm-drng",
+		.owner	= THIS_MODULE,
+		.of_match_table = nlm_drng_match,
+	},
+};
+
+module_platform_driver(nlm_drng_driver);
+
+MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
+MODULE_AUTHOR("Subhendu Sekhar Behera <sbehera@broadcom.com>");
+MODULE_DESCRIPTION("Netlogic XLP Random Number Generator");
+MODULE_LICENSE("GPL");
-- 
1.7.1

