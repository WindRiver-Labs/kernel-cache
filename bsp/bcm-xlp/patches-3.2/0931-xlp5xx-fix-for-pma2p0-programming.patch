From af6133148511d1dcc83f49dd7d42f1c0c534ae48 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Mon, 17 Feb 2014 12:59:14 +0530
Subject: xlp5xx: fix for pma2p0 programming.

* Clean up for redundant arrays used for calcualting base addresses of devices.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index f54a828..709ed4a 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -1774,7 +1774,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 		unsigned long long mask = ~0xf;
 		fmn_default_qsize = 0;
                 max_msg_blks = XLP5XX_MSG_BLK_MAX;
-		xlp_fmn_base[node] = mask & nlh_read_cfg_reg32(xlp5xx_fmn_base[node] + 0x10);
+		xlp_fmn_base[node] = mask & nlh_read_cfg_reg32(xlp9xx_fmn_base[node] + 0x10);
 	} else {
                 max_msg_blks = XLP_MSG_BLK_MAX;
 	}
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 470ef7e..724c664 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -653,7 +653,6 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		int extra_common_lanes = max_lanes;
 		if(!(is_nlm_xlp5xx())){
 			extra_common_lanes = 1;	
-			nlm_print("MAX extra_common_lanes is one \n");
 		}
 
 		for (lane_no=0; lane_no<extra_common_lanes; lane_no++) {
@@ -723,6 +722,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
         for (lane_no=0; lane_no<max_lanes; lane_no++) {
 #if 1
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0xd9);
+                __netsoc_write_pma2p0_reg(mac_base, lane_no, 21, 0x50);
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 22, 0x0);
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 23, 0x0);
                 __netsoc_write_pma2p0_reg(mac_base, lane_no, 87, 0x1f);
@@ -783,12 +783,16 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	
 	netsoc_api_print(NETSOC_APIDBG_PORT,"Waiting for block %d PCSOUTSYNTH_READY\n", block);
 	
-	pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 0x4, 0x4);
-	while((pma2p0_cmd& 0x1) != 0x1){
-		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 0x4, 0x4);
-	}
-	
     	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
+		if((!(is_nlm_xlp5xx())) && lane_no>0)
+			break;
+		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 0x4 + lane_no, 0x4);
+		while((pma2p0_cmd& 0x1) != 0x1){
+			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, 0x4 + lane_no, 0x4);
+		}
+	}	
+    	
+	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		netsoc_api_print(NETSOC_APIDBG_PORT,"PMA2P0: Waiting for block %d lane %d PCSOUT_RX_READY\n", block, lane_no);
 		pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, lane_no, 11);
 		while((pma2p0_cmd & 0x1) != 0x1){
@@ -815,9 +819,8 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma2p0_por , uint32_t speed, uint32_t phymode)
 {
 
-	uint32_t delay, pma2p0_config, lane_no, max_lanes;
+	uint32_t delay, pma2p0_config, lane_no, max_lanes =4;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
-	nlm_print("xlp9xx_config_pma2p0_serdes phymode= 0x%x\n", phymode);
 	if(block==2 && (phymode == PHYMODE_SGMII)){
 		max_lanes =1;
 	}
@@ -867,8 +870,9 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 	for(delay=0; delay<1000000; delay++);
 
 	if(is_nlm_xlp5xx()){
+		uint32_t data_rate_width = 0;
+		pma2p0_config = 0;
 		for (lane_no=0; lane_no<max_lanes; lane_no++) {
-			uint32_t data_rate_width = 0;
 			if (phymode == PHYMODE_SGMII){
 				data_rate_width = (PMA2P0_DATA_RATE_GTE_1P25G_LT_2P5G | PMA2P0_DATA_WIDTH_10BIT);
 			}else if (PHYMODE_XAUI==phymode){
@@ -898,7 +902,6 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t pma
 		}	
 
 	}else{
-
 		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL1);
 		pma2p0_config &= ~((0x7<<4) | 0x7);
 
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index af777e4..68cc7b6 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -419,7 +419,7 @@ __inline__ void nlm_hal_init(void)
 
         	/* PCI enumeration of supported devices*/
 
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 				
 			xlp9xx_mac0_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
 			xlp9xx_mac1_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
@@ -431,18 +431,6 @@ __inline__ void nlm_hal_init(void)
 
 			xlp_sae_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
 			xlp_rsa_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
-		} else if ((is_nlm_xlp5xx()) && (node == 0)) { /* xlp5xx have single node only */
-
-			xlp5xx_mac0_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
-			xlp5xx_mac1_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
-			xlp5xx_poe0_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE0));
-			xlp5xx_poe1_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE1));
-			xlp5xx_fmn_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
-			xlp_sys_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_SYS));
-			xlp5xx_sys_clk_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_CLK));
-
-			xlp_sae_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
-			xlp_rsa_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
 		} else
 		{
 			xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
@@ -459,8 +447,8 @@ __inline__ void nlm_hal_init(void)
 			xlp_rsa_base[node] = (xlp_io_base | XLP_PCIE_DEV_BASE(node, XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
 
 		}
+	}	
 
-	}
 	if(!is_nlm_xlp9xx()){
 		if ( is_nlm_xlp3xx() || is_nlm_xlp2xx() ) {
 			xlp_regex_base_pcie = (xlp_io_base | (XLP_PCIE_DEV_BASE(0, XLP_3XX_REGEX))) & 0x1fffffff;
-- 
1.7.1

