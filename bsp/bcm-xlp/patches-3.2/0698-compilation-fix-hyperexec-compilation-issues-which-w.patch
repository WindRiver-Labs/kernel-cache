From e83916314b72ba18c606c74be84c828e272357bc Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Wed, 5 Jun 2013 13:00:17 +0530
Subject: compilation: fix hyperexec compilation issues, which were due to restructuring of HAL.

    following compilation is successful now:
    - build_linux_hyperexec
    - build_linux_hyperapp_nae
    - build_linux_hyperapp_hello
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index c224230..da9ef10 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -830,6 +830,21 @@ enum {
     #define XAUI_PHY_TEST_LOW_FREQ      0x01
     #define XAUI_PHY_TEST_MIXED_FREQ    0x02
 
+#define NAE_THR_SEPARATION                 8
+#define NAE_MTU_LEN                     1518
+#define NAE_REACTION_LEN_XAUI           1463
+#define NAE_REACTION_LEN_SGMII          1126
+#define NAE_REACTION_LEN_PARSER           14
+#define NAE_INFLIGHT_LEN_XAUI            504
+#define NAE_INFLIGHT_LEN_SGMII           108
+#define NAE_SMALLEST_PKT_LEN              64
+#define NAE_XAUI_THR_GROUP                 1
+#define NAE_SGMII_THR_GROUP                2
+#define NAE_RXAUI_THR_GROUP                3
+#define NAE_ILK_THR_GROUP                  4
+#define NAE_RX_THR_BYTE_UNIT              16
+#define NAE_PAUSE_TIMER_DELTA             32
+
 
 #define NETIOR_HIGIG2_CTRL0		0x70
 #define NETIOR_HIGIG2_CTRL1		0x71
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index 6b8b8ae..6b14aff 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -381,6 +381,8 @@ extern int nlm_hal_is_intr_1588(int node);
 extern void nlm_hal_enable_1588_intr(int node,int mask);
 extern void nlm_hal_clear_1588_intr(int node, int timer);
 
+extern void nlm_hal_set_context_xon_xoff_threshold(int node, int mtu_len);
+
 enum NAE_REG_CMD {
         CMD_READ = 0,
         CMD_WRITE
diff --git a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
index 522533f..acacb86 100644
--- a/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/nlm_hal_nae.c
@@ -2695,6 +2695,69 @@ static inline void config_context_xoff_thr(int node, int thgrp, int maxbuf)
 			thgrp, (val >> 3) & 0x3fff, (val >> 17) & 0x3fff, maxbuf);
 }
 
+/**
+* @brief nlm_hal_set_context_xon_xoff_threshold function is used to set the rx buffer xon/xoff thresholds
+*
+* @param [in] node Node number
+* @param [in] mtu_len packet MTU length
+*
+* @return
+*       - none
+*
+* @ingroup hal_nae
+*
+*/
+void nlm_hal_set_context_xon_xoff_threshold(int node, int mtu_len)
+{
+	int i, xon_xoff_done[NLM_NAE_MAX_XONOFF_THR_GRPS];
+	int thrgrp, rx_buf_size, port = 0;
+
+	struct nlm_hal_nae_config *nae_cfg;
+
+	/* we need to set the xon/xoff threshold only once for each threshold group */
+	for (i=0; i<NLM_NAE_MAX_XONOFF_THR_GRPS; i++)
+		xon_xoff_done[i] = 0;
+
+	nae_cfg = nlm_node_cfg.nae_cfg[node];
+
+	for (port = 0; port < nae_cfg->num_ports; port++) {
+		if (nae_cfg->ports[port].valid) {
+			thrgrp = 0;
+			rx_buf_size = 0;
+
+			switch(nae_cfg->ports[port].iftype) {
+				case RXAUI_IF:
+					thrgrp = NAE_RXAUI_THR_GROUP;
+					rx_buf_size = nae_cfg->ports[port].rx_buf_size;
+					break;
+				case XAUI_IF:
+					thrgrp = NAE_XAUI_THR_GROUP;
+					rx_buf_size = nae_cfg->ports[port].rx_buf_size;
+					break;
+				case SGMII_IF:
+					thrgrp = NAE_SGMII_THR_GROUP;
+					rx_buf_size = nae_cfg->ports[port].rx_buf_size;
+					break;
+				case INTERLAKEN_IF:
+					thrgrp = NAE_ILK_THR_GROUP;
+					rx_buf_size = nae_cfg->ports[port].rx_buf_size;
+					break;
+				default:
+					break;
+			}
+
+			if( (rx_buf_size)  &&
+					(thrgrp < NLM_NAE_MAX_XONOFF_THR_GRPS) &&
+					(!(xon_xoff_done[thrgrp])) )
+			{
+				xon_xoff_done[thrgrp] = 1;
+				config_context_xoff_thr(node, thrgrp,  rx_buf_size / nae_cfg->ports[port].num_channels);
+			}
+
+		}
+	}
+}
+
 static inline void nlm_configure_rxbuffer(int node, int context_base, int num_channels, uint32_t base, uint32_t size,int thrgrp)
 {
 	int offset;
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h
index 7248a44..7a9b3b1 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_cde.h
@@ -110,7 +110,7 @@ static __inline__ int nlm_hal_9xxcde_make_cmp_msg(uint64_t *msg0, uint64_t *msg1
 /* Return error when parameter are invalid */
 static __inline__ int nlm_hal_cde_send_request(uint32_t dst_vc, uint64_t entry0, uint64_t entry1)
 {
-    if (cpu_is_xlp9xx())
+    if ( is_nlm_xlp9xx())
 	return nlm_hal_send_msg2(dst_vc, 0, entry0, entry1);
     else
 	return nlm_hal_send_msg1(dst_vc, 0, entry0);
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 619559b..3027a51 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1002,7 +1002,7 @@ void nlm_hal_set_sae_freq(int node, int freq)
 }
 
 
-int nlm_hal_get_chip_feature(void )
+int nlm_hal_get_sae_chip_feature(void )
 {
 	int chip_features;
 	if( is_nlm_xlp2xx())
@@ -1145,6 +1145,84 @@ uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module)
 }
 
 
+void nlm_hal_set_rsa_cge(int node, int enable)
+{
+#define NLM_RSA_CFG_REG 0x40
+	uint32_t d32 = nlm_hal_read_rsa_reg(NLM_RSA_CFG_REG);
+	if(enable)
+		d32 |= 1<<9;
+	else
+		d32 &= ~(1<<9);
+	nlm_hal_write_rsa_reg(NLM_RSA_CFG_REG, d32);
+}
+
+#define NLM_SAE_ENGINE_SELECT_REG_0 0x41
+void nlm_hal_set_sae_engine_sel(int node)
+{
+	int i, n;
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+	if(is_nlm_xlp3xx())
+		n = 1;
+	else
+		n = 8;
+
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, 0x00FFFFFF);
+	}
+}
+
+#define NLM_RSA_ENGINE_SELECT_REG_0 0x41
+void nlm_hal_set_rsa_engine_sel(void)
+{
+	int i, n;
+	unsigned int val;
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
+	if(is_nlm_xlp3xx()) {
+		n = 1;
+		val = 0xffff;
+	} else {
+		n = 3;
+		val = 0x7ffffff;
+	}
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_rsa_reg(NLM_RSA_ENGINE_SELECT_REG_0 + i, val);
+	}
+}
+
+void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
+{
+
+	if(is_nlm_xlp3xx()) {
+		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase = XLP_2XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_2XX_CRYPTO_VC_LIMIT;
+	} else {
+		*vcbase = XLP_CRYPTO_VC_BASE;
+		*vclimit = XLP_CRYPTO_VC_LIMIT;
+	}
+}
+
+void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
+{
+	if(is_nlm_xlp3xx()) {
+		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase  = XLP_2XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_2XX_RSA_ECC_VC_LIMIT;
+	} else {
+		*vcbase = XLP_RSA_ECC_VC_BASE;
+		*vclimit = XLP_RSA_ECC_VC_LIMIT;
+
+	}
+}
+
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
-- 
1.7.1

