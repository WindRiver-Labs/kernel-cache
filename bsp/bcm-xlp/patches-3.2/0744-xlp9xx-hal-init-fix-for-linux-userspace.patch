From 5d4c85c885f79988f40ae259260f250f94d5de93 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Thu, 11 Jul 2013 12:53:47 +0530
Subject: xlp9xx:hal init fix for linux-userspace

Reference: proposed/hareesh/hal-xlp9xx-linuxu
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 7509de6..be8e7f4 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -212,6 +212,7 @@ static inline uint32_t get_xlp3xx_epid(void)
 
 #define BRIDGE BDF2OFFSET(0, 0, 0)
 
+#ifdef NLM_HAL_LINUX_KERNEL
 inline static u32 xlp9xx_get_node_id(void)
 {
         u32 node = 0;
@@ -226,8 +227,16 @@ inline static u32 xlp9xx_get_node_id(void)
 
         return node;
 }
+#else
+inline static u32 xlp9xx_get_node_id(void)
+{
+	u32 cpuid = nlm_uaccess_hard_cpuid();
+	return ((cpuid >> 7) & 0x7);
+}
+#endif
 
 //node<0: use current cpu nodeid
+#ifdef NLM_HAL_LINUX_KERNEL
 inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
 {
 	volatile u32 * pcmu = NULL;
@@ -242,8 +251,28 @@ inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
 
         return (volatile u32 *)(DEFAULT_CPU_IO_BASE + (busno<<20) + (offset) + HDR_OFFSET);
 }
+#else
+inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
+{
+	volatile u32 * pcmu = NULL;
+	uint32_t busno, val;
+	if(node <0 )
+		node = xlp9xx_get_node_id();
+
+	pcmu = (volatile u32*)((DEFAULT_CPU_IO_BASE + ( (node&0x7) << 12)) & 0x1fffffff);
+	if( offset == BRIDGE ) return pcmu + 0x40;
+
+	val = nlm_hal_read_32bit_reg((uint64_t)pcmu, 6);
+	busno = (val >> 8 ) & 0xFF;  //get secondary bus number
+
+	return (volatile u32 *)((DEFAULT_CPU_IO_BASE + (busno<<20) +
+                              (offset) + HDR_OFFSET) & 0x1fffffff);
+}
+#endif
+
 //get device's mem bar0/1 and convert to 64bits uncached virtual memory
 
+#ifdef NLM_HAL_LINUX_KERNEL
 inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
 {
 	uint64_t phy;
@@ -253,7 +282,7 @@ inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
 	phy = mmio[4] ;
 
 	if( phy&1 )
-		phy &= ~((u64)3);	//io bar
+		phy &= ~((u64)3);       //io bar
 	else{
 		//64bits physical address
 		if( ((phy>>1) & 3) == 2 )  phy |= (u64)mmio[5] << 32;
@@ -263,6 +292,28 @@ inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
 	phy &= 0xFFFFFFFFFFULL; //40 bits phy addr
 	return (volatile u32*)(phy);
 }
+#else
+inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
+{
+	uint64_t phy,phy1;
+	volatile u32* mmio = xlp9xx_cpu_io_mmio(node, offset);
+
+	mmio -= HDR_OFFSET/sizeof(u32);
+	phy = (uint64_t)nlm_hal_read_32bit_reg((uint64_t)mmio, 4);
+	phy1 = (uint64_t)nlm_hal_read_32bit_reg((uint64_t)mmio, 5);
+
+	if( phy&1 )
+		phy &= ~((u64)3);	//io bar
+	else{
+		//64bits physical address
+		if( ((phy>>1) & 3) == 2 )  phy |= (u64)phy1 << 32;
+		phy &= ~((u64)0x7F);
+	}
+
+	phy &= 0xFFFFFFFFFFULL; //40 bits phy addr
+	return (volatile u32*)(phy);
+}
+#endif
 
 
 static inline uint64_t __get_nae_soc_phys_base(int node, int nae_id)
-- 
1.7.1

