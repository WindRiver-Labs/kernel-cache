From 67f66d5a009068b92c0064120bdd93f85bb784a8 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Thu, 29 Sep 2011 11:54:35 +0530
Subject: Earlier, VC base was called directly; now it uses a macro to obtain the CPU type (XLP or Storm).

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index 7155038..abdd988 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -42,7 +42,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/init.h>		/* for __init, module_{init,exit} */
 #include <linux/poll.h>		/* for POLLIN, etc. */
 #include <linux/proc_fs.h>
-
+#include <stdio.h>
 #include <asm/netlogic/msgring.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
@@ -135,7 +135,7 @@ struct crypto_hw_cntrs {
     static void
 nlm_crypto_print_hw_cntrs(struct crypto_hw_cntrs *hw_cnt)
 {
-    int i;
+    int i, num_vcs = nlm_hal_sae_get_num_vc();
 
     printf("***************** h/w counter dump start *****************n");
     printf("Ingress msg cntr: 0x%llx\n", (unsigned long long)
@@ -145,7 +145,7 @@ nlm_crypto_print_hw_cntrs(struct crypto_hw_cntrs *hw_cnt)
     printf("Egress error msg cntr: 0x%llx\n", (unsigned long long)
 	    hw_cnt->egress_err_msg_cntr);
 
-    for (i = 0; i < NUM_VC; i++) {
+    for (i = 0; i < num_vcs; i++) {
 	printf("================ VC %d counter ===============\n", i);
 
 	printf("DMA read bytes: 0x%llx\n", (unsigned long long)
@@ -201,7 +201,7 @@ nlm_crypto_read_reg_lo_hi(int regnum_lo, int regnum_hi)
     static void
 nlm_crypto_read_hw_counters(struct crypto_hw_cntrs *hw_cnt)
 {
-    int i;
+    int i, num_vcs = nlm_hal_sae_get_num_vc();
 
     hw_cnt->ingress_msg_cntr =
 	nlm_crypto_read_reg_lo_hi(NLM_CRYPTO_REG_ING_MSG_CNTR_LOW,
@@ -215,7 +215,7 @@ nlm_crypto_read_hw_counters(struct crypto_hw_cntrs *hw_cnt)
 	nlm_crypto_read_reg_lo_hi(NLM_CRYPTO_REG_EGR_ERR_MSG_CNTR_LOW,
 		NLM_CRYPTO_REG_EGR_ERR_MSG_CNTR_HIGH);
 
-    for (i = 0; i < NUM_VC; i++) {
+    for (i = 0; i < num_vcs; i++) {
 	hw_cnt->dma_rd_bytes[i] =
 	    nlm_crypto_read_reg_lo_hi(NLM_CRYPTO_REG_DMA_RD_LOW_BYTES
 		    (i),
@@ -266,48 +266,80 @@ nlm_crypto_read_hw_counters(struct crypto_hw_cntrs *hw_cnt)
     }
 }
 
-#if 0
+#if 1
 /********************* S/W Counters  *******************************/
-uint64_t crypto_cntr_crypt_ops[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
-uint64_t crypto_cntr_crypt_bytes[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
-uint64_t crypto_cntr_auth_ops[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX];
-uint64_t crypto_cntr_auth_bytes[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX];
+unsigned int crypto_cntr_crypt_ops[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
+unsigned int crypto_cntr_crypt_bytes[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX];
+unsigned int crypto_cntr_auth_ops[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX];
+unsigned int crypto_cntr_auth_bytes[NLM_AUTH_MAX][NLM_AUTH_MODE_MAX];
 
     static void
 print_crypto_stats(void)
 {
     // Take care of invalid modes...
+    int i;
+    unsigned char mode[NLM_CIPHER_MODE_MAX][16] = { "ECB", "CBC", "CFB", "OFB", "CTR", "AES_F8", "GCM", "CCM", "LRW", "XTS"};
+    unsigned char c_alg[NLM_CIPHER_MAX][16] = {"BYPASS", "DES", "3DES", "AES128", "AES192", "AES256", "ARC4", "KASUMI_F8", "SNOW3S_F8", "CAMELLIA128", "CAMELLIA192", "CAMELLIA256"};
+    unsigned char h_mode[NLM_AUTH_MODE_MAX][16] = {"SHA1", "SHA224", "SHA256", "SHA384", "SHA512", "CMAC", "XCBC", "CBC_MAC", "CCM", "GCM" };
+    unsigned char h_alg[NLM_AUTH_MAX][16] = {"BYPASS", "MD5", "SHA", "undefined", "AES128", "AES192", "AES256", "KASUMI_F9", "SNOW3G_F9", "CAMELLIA128", "CAMELLIA192", "CAMELLIA256", "GHASH"};
+
+    printf("\n================= algorithm-mode based statistics===============\n");
+    printf("cipher alg: cipher mode(number of operation / number of bytes)\n");
+
+    printf("\t\t\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t\n",mode[0],mode[1],mode[2],mode[3],mode[4],mode[5],mode[6],mode[7],mode[8],mode[9]);
+
+    for (i = 0; i < NLM_CIPHER_MAX; i++) {
+	printf("%12s:\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\n",c_alg[i],
+		crypto_cntr_crypt_ops[i][0], crypto_cntr_crypt_bytes[i][0],
+		crypto_cntr_crypt_ops[i][1], crypto_cntr_crypt_bytes[i][1],
+		crypto_cntr_crypt_ops[i][2], crypto_cntr_crypt_bytes[i][2],
+		crypto_cntr_crypt_ops[i][3], crypto_cntr_crypt_bytes[i][3],
+		crypto_cntr_crypt_ops[i][4], crypto_cntr_crypt_bytes[i][4],
+		crypto_cntr_crypt_ops[i][5], crypto_cntr_crypt_bytes[i][5],
+		crypto_cntr_crypt_ops[i][6], crypto_cntr_crypt_bytes[i][6],
+		crypto_cntr_crypt_ops[i][7], crypto_cntr_crypt_bytes[i][7],
+		crypto_cntr_crypt_ops[i][10], crypto_cntr_crypt_bytes[i][10],
+		crypto_cntr_crypt_ops[i][11], crypto_cntr_crypt_bytes[i][11] );
+    }
+    printf("\nauth alg: auth mode(number of operation / number of bytes) \n");
+    printf("\t\t\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t\n",h_mode[0],h_mode[1],h_mode[2],h_mode[3],h_mode[4],h_mode[5],h_mode[6],h_mode[7],h_mode[8],h_mode[9]);
+    for (i = 0; i < NLM_AUTH_MAX; i++) {
+	if(i != 3)
+	printf("%12s:\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\t%d/%d\n",h_alg[i],
+		crypto_cntr_auth_ops[i][0], crypto_cntr_auth_bytes[i][0],
+		crypto_cntr_auth_ops[i][1], crypto_cntr_auth_bytes[i][1],
+		crypto_cntr_auth_ops[i][2], crypto_cntr_auth_bytes[i][2],
+		crypto_cntr_auth_ops[i][3], crypto_cntr_auth_bytes[i][3],
+		crypto_cntr_auth_ops[i][4], crypto_cntr_auth_bytes[i][4],
+		crypto_cntr_auth_ops[i][5], crypto_cntr_auth_bytes[i][5],
+		crypto_cntr_auth_ops[i][6], crypto_cntr_auth_bytes[i][6],
+		crypto_cntr_auth_ops[i][7], crypto_cntr_auth_bytes[i][7],
+		crypto_cntr_auth_ops[i][8], crypto_cntr_auth_bytes[i][8],
+		crypto_cntr_auth_ops[i][9], crypto_cntr_auth_bytes[i][9] );
+    }
 }
 
     static void
-update_crypto_stats(int cipher_alg, int cipher_mode, int cipher_len,
-	int auth_alg, int auth_mode, int auth_len)
+update_cipher_stats(int cipher_alg, int cipher_mode, int cipher_len)
 {
     if (cipher_alg) {
 	crypto_cntr_crypt_ops[cipher_alg][cipher_mode]++;
 	crypto_cntr_crypt_bytes[cipher_alg][cipher_mode] += cipher_len;
     }
-    if (auth_alg) {
-	crypto_cntr_auth_ops[auth_alg][auth_mode]++;
-	crypto_cntr_auth_ops[auth_alg][auth_mode] += auth_len;
-    }
 }
 
-    static void
-update_session_stats(struct nlm_crypto_op *cop)
+static void update_auth_stats( int auth_alg, int auth_mode, int auth_len)
 {
-    update_crypto_stats(cop->session->cipher_alg,
-	    cop->session->cipher_mode,
-	    cop->cipher_len,
-	    cop->session->auth_alg,
-	    cop->session->auth_mode, cop->auth_len);
+    if (auth_alg) {
+	crypto_cntr_auth_ops[auth_alg][auth_mode]++;
+	crypto_cntr_auth_bytes[auth_alg][auth_mode] += auth_len;
+    }
 }
 
     static void
 reset_crypto_stats(void)
 {
     int i, j;
-
     for (i = 0; i < NLM_CIPHER_MAX; i++) {
 	for (j = 0; j < NLM_CIPHER_MODE_MAX; j++) {
 	    crypto_cntr_crypt_ops[i][j] = 0;
@@ -340,7 +372,7 @@ init_crypto_vc(void)
     static int
 crypto_get_vc(void)
 {
-    return NLM_CRYPTO_VC_BASE;
+    return nlm_hal_sae_get_vc_base();/*NLM_CRYPTO_VC_BASE*/;
 }
 
     static int
@@ -815,9 +847,14 @@ crypto_cipher_auth_op(struct crypto_session *session, struct crypto_param *cop)
     cprm.designer_fb[2] = cop->designer_fb[2];
     cprm.designer_fb[3] = cop->designer_fb[3];
 
+    if(session->cip)
+      update_cipher_stats(session->cip->cipher_alg, session->cip->cipher_mode, cop->cipher_len);
+    if(session->aip)
+      update_auth_stats(session->aip->auth_alg, session->aip->auth_mode, cop->auth_len);
     nlm_fb_vc = crypto_get_fb_vc();
     nlm_tx_id = (uint64_t) cop;
 
+    msg_hdl = 0;
     ret = nlm_hal_crypto_send_request(crypto_get_vc(), nlm_fb_vc,
 	    (void *) session->cntrl_desc,
 	    virt_to_phys(session->cntrl_desc),
@@ -825,7 +862,6 @@ crypto_cipher_auth_op(struct crypto_session *session, struct crypto_param *cop)
 	    virt_to_phys(session->pkt_desc),
 	    &cprm, nlm_tx_id);
 
-    msg_hdl = 0;
     while(msg_hdl == 0);/*Wait till message ring handler is invoked by freeback message*/
 
     ret = crypto_fb_msg_print_err(nlm_err_msg);
@@ -921,13 +957,6 @@ nlm_xlp_sae_msgring_handler(uint32_t vc, uint32_t src_id,
 }
 
 
-static struct device_info {
-        int version;
-        dev_t device;
-	struct proc_dir_entry *pdir;
-	struct proc_dir_entry *pstats;
-} dev_info;
-
 static int
 nlm_crypto_read_stats_proc(char *page, char **start, off_t offset, int count,
                        int *eof, void *data)
@@ -937,6 +966,7 @@ nlm_crypto_read_stats_proc(char *page, char **start, off_t offset, int count,
 
 	nlm_crypto_read_hw_counters(&hw_cnt);
 	nlm_crypto_print_hw_cntrs(&hw_cnt);
+	print_crypto_stats();
 
 	*start = page + offset;
         len = 0;
@@ -945,11 +975,11 @@ nlm_crypto_read_stats_proc(char *page, char **start, off_t offset, int count,
 }
 
 
+struct proc_dir_entry *entry = NULL;
 int
 nlm_crypto_init(void)
 {
     int ret = 0;
-    struct proc_dir_entry *entry;
 
     init_crypto_vc();
 
@@ -968,6 +998,8 @@ nlm_crypto_init(void)
 	    panic("can't register msgring handler for TX_STN_GMAC0");
     }
     sema_init(&sem, 0);
+    reset_crypto_stats();
+
     return ret;
 }
 
@@ -999,7 +1031,7 @@ xlp_sae_cleanup(void)
     xlp_aead_alg_fini();
     unregister_chrdev(xlp_sae_major, "NLM_XLP_SAE");
 
-    if(dev_info.pdir)
+    if(entry)
     	remove_proc_entry("crypto_stats", nlm_root_proc);
 }
 
-- 
1.7.1

