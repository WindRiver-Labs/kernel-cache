From bf2260e347faf3d28aeea718b76d53fd428c8378 Mon Sep 17 00:00:00 2001
From: Pavani Reddy <pavani@broadcom.com>
Date: Mon, 8 Dec 2014 18:51:56 +0530
Subject: soc_interface : Change the calculation of vc_mask

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index fab918f..c7ce1bd 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -39,6 +39,7 @@
 #include <linux/proc_fs.h>
 
 #include <asm/netlogic/mips-extns.h>
+#include <asm/mach-netlogic/multi-node.h>
 
 #include "nlm_msgring.h"
 #include "nlm_xlp.h"
@@ -1136,14 +1137,12 @@ void nlm_enable_vc_intr_9xx(void)
 {
         int cpu, node;
         int vc_index = 0;
-        int i = 0;
-
-        for(cpu=0; cpu < NR_CPUS; cpu++){
-                if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
-                        continue;
-		node = cpu_to_node(cpu_number_map(cpu));
-                for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
-			vc_index = (i + (cpu % NLM_MAX_CPU_PER_NODE_9XX)*NLM_MAX_VC_PER_THREAD_9XX);
+        int i = 0, hwcpu;
+		for_each_present_cpu(cpu) {
+			hwcpu = cpu_logical_map(cpu);
+			node = nlm_cpuid_to_node(hwcpu);
+			for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
+				vc_index = (i + (hwcpu % nlm_threads_per_node())*NLM_MAX_VC_PER_THREAD_9XX);
                         if(nlm_cpu_vc_mask[cpu] & (1<<i)){
                                 /*enable interrupts*/
                                 nlm_hal_enable_vc_intr(node, vc_index);
-- 
1.7.1

