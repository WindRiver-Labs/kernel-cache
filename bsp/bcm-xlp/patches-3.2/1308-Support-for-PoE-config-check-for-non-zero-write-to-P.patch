From 88a6c77ce00557f372987a4c34a477509a817acd Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Wed, 6 Oct 2010 22:54:51 -0700
Subject: Support for PoE config, check for non-zero write to PIC IPI thread mask register

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index bf6a886..fd3725f 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -2,6 +2,9 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 
+#include <asm/netlogic/msgring.h>
+
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_nae.h>
 #include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
 #include <ops.h>
@@ -13,7 +16,8 @@
 #define VAL_UCORE_RESET(x)             ( ( (x) &0xffff) << 8)
 
 /*
- *  Ucore support
+ *  Temporary direct ucore configuration. HAL needs to support stop and restart
+ * of ucores before reloading code
  */
 static int local_load_ucore(int ucore_mask, unsigned int *opcodes, int num_opcodes)
 {
@@ -94,6 +98,36 @@ static void parse_ucore_config(void)
 	kfree(uc_opcodes);
 }
 
+static void parse_poe_config(void)
+{
+	void *node;
+	int size = 0;
+	unsigned int *poe_regs;
+	uint32_t num_regs;
+
+	node = finddevice("/soc/nae-cfg/poe-pci-mem-regs");
+	if(!node) {
+		printk("[%s] Unable to parse poe configuration!\n", __func__);
+		return;
+	}
+
+	getprop(node, "num-regs", &num_regs, sizeof(uint32_t));
+
+	size = sizeof(uint32_t) * num_regs;
+	poe_regs = kmalloc(size, GFP_KERNEL);
+	if (!poe_regs) {
+		printk("[%s] Unable to allocate temporary memory\n", __func__);
+		return;
+	}
+
+	getprop(node, "regs", poe_regs, size);
+
+	//local_load_ucore(uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
+	nlm_hal_init_poe_regs(PCIE_MEM_POE_REG, poe_regs, num_regs);
+
+	kfree(poe_regs);
+}
+
 static void parse_fdt_cpu_config(void)
 {
 	void *node;
@@ -261,7 +295,7 @@ static void parse_fdt_nae_config(void)
 	}
 }
 
-static void config_poe_dist_vect(uint32_t cpumask, int rx_vc)
+static void config_poe_dist_vect(void)
 {
 	int reg_index_base = 0x400 >> 2;
 	int reg_offset = 0x30 >> 2;
@@ -283,6 +317,16 @@ static void config_poe_dist_vect(uint32_t cpumask, int rx_vc)
 
 }
 
+static void config_fmn(void)
+{
+	unsigned long mflags = 0;
+
+	/* Configure FMN again but only cpu credits */
+	msgrng_access_enable(mflags);
+	nlm_hal_fmn_init(0x10000000, 0x02000000, 50);
+	msgrng_access_disable(mflags);
+}
+
 void initialize_nae(void)
 {
 	if (check_header()) {
@@ -290,6 +334,8 @@ void initialize_nae(void)
 		return;
 	}
 
+	config_fmn();
+
 	printk("Configuring ucore...\n");
 	parse_ucore_config();
 
@@ -299,9 +345,11 @@ void initialize_nae(void)
 	printk("Configuring CPU-NAE...\n");
 	parse_fdt_cpu_config();
 
-	printk("Configuring POE distribution vector...\n");
-	uint32_t cpumask = 0xffffffff; // XXXXXXXXXXXXXXXXXXXX
-	config_poe_dist_vect(cpumask, nae_rx_vc);
+	printk("Configuring PoE...\n");
+	parse_poe_config();
+
+/* 	printk("Configuring POE distribution vector...\n"); */
+/* 	config_poe_dist_vect(); */
 
 	printk("NAE configuration done!\n");
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index bdc3397..e0b075e 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -96,9 +96,6 @@ static int drop_uboot_pkt = 1;
 module_param(drop_uboot_pkt, int, 0);
 static unsigned long stats_uboot_pkts;
 
-extern int hwemul;
-module_param(hwemul, int, 0);
-
 extern int naecfg_hack;
 module_param(naecfg_hack, int, 0);
 
@@ -361,7 +358,7 @@ static int mac_refill_frin_desc(unsigned long dev)
                 if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) )
 		{
 			print_fmn_send_error(__func__, ret);
-			printk("[%s]: giving up (qid=%d)\n", __func__, priv->nae_rx_qid);
+			printk("Unable to send configured free desc, check freein carving (qid=%d)\n", priv->nae_rx_qid);
 
 			/* free the buffer and return! */
 			dev_kfree_skb_any(skb);
@@ -395,16 +392,8 @@ static void nlm_xlp_nae_init(void)
 	struct proc_dir_entry *entry;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, hwemul=%d, naecfg_hack=%d drop_uboot_pkt=%d\n",
-	       debug, hwemul, naecfg_hack, drop_uboot_pkt);
-#if 1
-	if (1/*hwemul*/) {
-		unsigned long mflags = 0;
-		msgrng_access_enable(mflags);
-		nlm_hal_fmn_init(0x10000000, 0x02000000, 50);
-		msgrng_access_disable(mflags);
-	}
-#endif
+	printk("debug = %d, naecfg_hack=%d drop_uboot_pkt=%d\n",
+	       debug, naecfg_hack, drop_uboot_pkt);
 
 	initialize_nae();
 
@@ -482,7 +471,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	}
 
 	ret = mac_refill_frin_desc((unsigned long)dev);
-	if (0/*ret*/) goto out;
+	if (ret) goto out;
 
 #ifdef ENABLE_NAE_PIC_INT
 	{
@@ -898,13 +887,11 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			cpu_halt();
 			return;
 		}
-	}
-	else {
+	} else {
 		printk("[%s]: wrong vc=%d or size=%d?\n", __func__, vc, size);
 	}
 
 	return;
-
 }
 
 /**********************************************************************
@@ -986,17 +973,25 @@ static void nlm_xlp_mac_timer(unsigned long data)
 	/* printk("[%s] A0 Workaround, forcing FMN int handling \n",__func__); */
 	{
 		uint32_t cpumask = 0xffffffff;
+		uint32_t cpumask_lo;
+		uint32_t cpumask_hi;
+
 		pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
 		int cpu = hard_smp_processor_id();
 
 		cpumask = cpumask & ~(1 << cpu);
+		cpumask_hi = cpumask >> 16;;
+		cpumask_lo = cpumask & 0xffff;
 
 		/* Send IRQ_MSGRING vector in an IPI to all cpus but the current one */
-		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (cpumask & 0xffff) );
-		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (1 << 16)
-				      | ( (cpumask >> 16) & 0xffff) );
+		if (cpumask_lo)
+			nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | cpumask_lo );
+
+		if (cpumask_hi)
+			nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (IRQ_MSGRING << 20) | (1 << 16)
+					      | (cpumask_hi));
 
-		/* Run the IPI handler on this cpu too */
+		/* Run IPI handler on this cpu too */
 		nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
 	}
 
-- 
1.7.1

