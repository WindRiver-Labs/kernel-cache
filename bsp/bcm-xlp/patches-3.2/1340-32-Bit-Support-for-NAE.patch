From ac800ab5278bbb52a4d1821400c21b615cc43f04 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikasg@netlogicmicro.com>
Date: Tue, 24 Jan 2012 16:54:13 +0530
Subject: 32 Bit Support for NAE.

A Fix at RX path for allocating page count when a page is  allocated for CPU(n) rx buffer.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index fbb7e21..9c19e79 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -65,10 +65,22 @@
 #if 1
 #include <asm/atomic.h>
 
-#define STATS_SET(x,v)  atomic64_set((atomic64_t *)&(x), (v))
-#define STATS_ADD(x,v)  atomic64_add((long)(v), (atomic64_t *)&(x))
-#define STATS_INC(x)    atomic64_inc((atomic64_t *)&(x))
-#define STATS_READ(x)   atomic64_read((atomic64_t *)&(x))
+#ifdef CONFIG_64BIT
+#define STATS_SET(x,v)         atomic64_set((atomic64_t *)&(x), (v))
+#define STATS_ADD(x,v)         atomic64_add((long)(v), (atomic64_t *)&(x))
+#define STATS_DEC(x)           atomic64_dec((atomic64_t *)&(x))
+#define STATS_INC(x)           atomic64_inc((atomic64_t *)&(x))
+#define STATS_READ(x)          atomic64_read((atomic64_t *)&(x))
+#define STATS_INC_RET(x)       atomic64_inc_return((atomic64_t *)&(x))
+#else
+#define STATS_SET(x,v)         atomic_set((atomic_t *)&(x), (v))
+#define STATS_ADD(x,v)         atomic_add((long)(v), (atomic_t *)&(x))
+#define STATS_INC(x)           atomic_inc((atomic_t *)&(x))
+#define STATS_DEC(x)           atomic_dec((atomic_t *)&(x))
+#define STATS_READ(x)          atomic_read((atomic_t *)&(x))
+#define STATS_INC_RET(x)       atomic_inc_return((atomic_t *)&(x))
+#endif
+
 #else
 #define STATS_SET(x,v)  do { (x) = (v); } while (0)
 #define STATS_ADD(x,v)  do { (x) += (v); } while (0)
@@ -110,7 +122,11 @@
    7 buffers. We need 32 bytes for prepad and another cacheline for storing
    s/w info
  */
-#define DEFAULT_JUMBO_MTU	5568  // for mtu 16384
+#ifdef CONFIG_64BIT
+#define DEFAULT_JUMBO_MTU	5568  // for mtu 16384 : 5568
+#else
+#define DEFAULT_JUMBO_MTU       3268  // for mtu 16384 : 5568
+#endif
 #define JUMBO_RX_OFFSET		64
 #define PREPAD_LEN		0	
 /* THIS MUST be multiple of cache line size */
@@ -257,18 +273,17 @@ static __inline__ int tso_enable(struct net_device *dev, u32 data)
 
 #ifdef CONFIG_64BIT
 #define MY_XKPHYS 0xa800000000000000ULL
+#else
+#define MY_XKPHYS 0xc0000000
+#endif
 static inline struct jumbo_rx_cookie *get_rx_cookie(uint64_t phys)
 {
 	/* rx cookie is  stored one cacheline before the start of rxbuf */
 	unsigned long *ptr = (unsigned long *)(unsigned long)
 		 		(MY_XKPHYS | (phys - SMP_CACHE_BYTES));
 
-	//printk("Received pkt at 0x%llx %p\n", phys, ptr);
 	return (struct jumbo_rx_cookie *)ptr;
 }
-#else
-#error "get_rx_cookie() needs to be implemented"
-#endif
 
 /* Here 
    length -> is the exact length of the data (excluding BYTE_OFFSET, CRClen,
@@ -447,10 +462,9 @@ static __inline__ int mac_send_fr(struct dev_data *priv, unsigned long addr, int
 	struct xlp_msg msg;
 	int code = 0;
 	int ret;
-	msg.entry[0] = (unsigned long long)virt_to_bus(addr) & 0xffffffffe0ULL;
+	msg.entry[0] = (unsigned long long)addr & 0xffffffffe0ULL;
 	msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
 	/* Send the packet to nae rx  */
-	//printk("mac_send_fr phys set=0x%lx\n", msg.entry[0]);
 	__sync();
         if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) ){
 		print_fmn_send_error(__func__, ret);
@@ -488,7 +502,6 @@ void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_d
 
 	/*fill other frags*/
 	for(idx=1; idx<num_desc; idx++){
-		//printk("build_skb data_len=0x%x\n", skb->data_len);
 		fp = &sp->frags[idx];
 		rx_cookie = get_rx_cookie(rxp2d[idx]);	
 		pg = rx_cookie->page;
@@ -498,7 +511,6 @@ void build_skb(struct sk_buff *skb, uint64_t *rxp2d, uint32_t*p2d_len, int num_d
 		fp->page_offset = rx_cookie->page_offset + rx_offset;
 		fp->size = p2d_len[idx];
 	}	
-	//printk("build_skb data_len=0x%x\n", skb->data_len);
 	skb_shinfo(skb)->nr_frags = num_desc;
 }
 
@@ -517,7 +529,7 @@ static int mac_frin_replenish_one_normal_msg(struct net_device *dev)
 {
 	jumbo_rx_info_t *rx;
 	struct dev_data* priv = netdev_priv(dev);
-	int ret = 0;
+	int ret = 0,num_buff;
 	unsigned long msgrng_flags;
 	struct jumbo_rx_cookie *rx_cookie;
 	struct page *pg;
@@ -527,11 +539,8 @@ static int mac_frin_replenish_one_normal_msg(struct net_device *dev)
 
 	rx = &jumbo_rx_buff[cpu];
 
-	if((rx->space >= jumbo_buffer_size)) {
+	if(rx->space >= jumbo_buffer_size){
 		pg = rx->page;
-		/* if this is not the last particle in this page */
-		if((rx->space - jumbo_buffer_size) > jumbo_buffer_size)
-			get_page(pg);
 	} else {
 		/* alloc a new page */
 		pg = alloc_pages(GFP_KERNEL, 0);
@@ -542,7 +551,8 @@ static int mac_frin_replenish_one_normal_msg(struct net_device *dev)
 		rx->page = pg;
 		rx->page_offset = 0;
 		rx->space = PAGE_SIZE;
-		get_page(pg);
+		num_buff = (PAGE_SIZE/jumbo_buffer_size);
+		atomic_set(&pg->_count, num_buff);
 	}
 	va = page_address(pg) + rx->page_offset;
 	pa = page_to_phys(pg) + rx->page_offset;
@@ -624,7 +634,7 @@ static void mac_frin_replenish(unsigned long  arg/* ignored */)
 				mac_frin_replenish_one_normal_msg(dev);
 
 			atomic_sub(num_fr_in, frin_to_be_sent);
-			atomic64_add(num_fr_in, &priv->total_frin_sent);
+			atomic_add(num_fr_in, &priv->total_frin_sent);
 
 			continue;
 		skip:
@@ -657,7 +667,7 @@ static int mac_fill_rxfr(struct net_device *dev)
 
 	//if(!(MSGRNG_OWN(priv->cfg_flag)))
 	//	return ret; 
-	limit = atomic64_read(&priv->frin_to_be_sent);
+	limit = atomic_read(&priv->frin_to_be_sent);
 	
 	for(i = 0; i < limit; i++){
 		/*  get a page */
@@ -673,7 +683,6 @@ static int mac_fill_rxfr(struct net_device *dev)
 
 		pa = page_to_phys(pg);
 		va = page_address(pg);
-		//printk("Virt addr alloc_page=0x%lx\n", (unsigned long)va);
 		j = 0;
 		while(nr_buffs) {
 			rx_cookie = (struct jumbo_rx_cookie *)va;
@@ -699,9 +708,9 @@ static int mac_fill_rxfr(struct net_device *dev)
 				get_page(pg);
 			j++;
 			nr_buffs--;
-			atomic64_dec(&priv->frin_to_be_sent);
+			atomic_inc(&priv->frin_to_be_sent);
 
-			atomic64_inc(&priv->total_frin_sent);
+			atomic_inc(&priv->total_frin_sent);
 		}
 	}
 	return 0;
@@ -764,9 +773,9 @@ static void nlm_xlp_nae_init(void)
 		priv->port	= i;
 
 		priv->frin_desc_thres = nae_cfg.ports[i].num_free_desc / 3;
-		atomic64_set(&priv->frin_to_be_sent, nae_cfg.ports[i].num_free_desc);
-		atomic64_set(&priv->num_replenishes, 0);
-		atomic64_set(&priv->total_frin_sent, 0);
+		atomic_set(&priv->frin_to_be_sent, nae_cfg.ports[i].num_free_desc);
+		atomic_set(&priv->num_replenishes, 0);
+		atomic_set(&priv->total_frin_sent, 0);
 
 		priv->inited	= 0;
 		priv->block 	= nae_cfg.ports[i].hw_port_id / 4;
@@ -924,7 +933,6 @@ static int p2p_desc_mem_init(void)
 	dsize = ((((MAX_SKB_FRAGS + P2P_EXTRA_DESCS) * sizeof(uint64_t)) + CACHELINE_SIZE - 1) & (~((CACHELINE_SIZE)-1)));
 	tsize = dsize * MAX_TSO_SKB_PEND_REQS;
 
-	printk("%s in, dsize %d tsize %d \n", __FUNCTION__, dsize, tsize);
 
 	for(cpu = 0; cpu < NR_CPUS; cpu++) {
 		buf = cacheline_aligned_kmalloc(tsize, GFP_KERNEL);		      
@@ -1003,7 +1011,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct dev_data *priv = netdev_priv(dev);
 	uint64_t msg, mscmsg0, mscmsg1;
 	//unsigned int mflags;
-	uint64_t *p2pdesc;
+	unsigned long *p2pdesc;
 	int cpu = hard_smp_processor_id();
 	int  ret, retry_cnt = 0;
 	unsigned long mflags = 0;
@@ -1064,7 +1072,6 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	}
 
-
 	if((len = skb_headlen(skb)) != 0) {
 		idx = create_p2p_desc(virt_to_bus((char *)skb->data), len, p2pdesc, idx);
 	}
@@ -1181,7 +1188,6 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 	if(priv->type==INTERLAKEN_IF){
 		return -EINVAL;
 	}
-	printk("Setting mtu %d bytes \n", new_mtu);
 
 	spin_lock_irqsave(&priv->lock, flags);
 
@@ -1384,7 +1390,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			//printk("P2p size=0x%x\n", len);
 		}	
 		//printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-                 //      src_id, vc, size, msg0, msg1);
+                  //     src_id, vc, size, msg0, msg1);
 
 #ifdef DEBUG_RXPKT_ADDR_NULL
 		if (addr == 0) {
@@ -1433,7 +1439,6 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			rx_cookie = get_rx_cookie(addr);
 			pg = rx_cookie->page;
 			/*free page count for P2P desc as it is not going to network stack */
-			put_page(pg);
 			/*Get actual length*/
 			for(idx=0; idx<num_p2d; idx++){
 				vaddr = (uint64_t)bus_to_virt(addr + (8*idx)); //got p2d virt addr
@@ -1445,6 +1450,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				//printk("P2D is at = 0x%lx physbuff= 0x%lx len= 0x%x\n", vaddr, p2d_addr[idx],  p2d_len[idx] );
 			}
 			tot_desc = num_p2d +1; //p2ds + p2p
+			put_page(pg);
 			//printk("Total packet length is = 0x%x and desc = 0x%x\n", len, tot_desc);
 		}else{ /*only one P2Dl_skb*/
 			vaddr = (uint64_t)bus_to_virt(addr);
@@ -1553,7 +1559,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		priv->cpu_stats[cpu].rx_packets++;
 
 	out:
-		if (atomic64_inc_return(&priv->frin_to_be_sent) > priv->frin_desc_thres)
+		if (atomic_inc_ret(&priv->frin_to_be_sent) > priv->frin_desc_thres)
 		{
 			tasklet_schedule(&mac_refill_task[port]);
 			//mac_refill_frin_desc((unsigned long) skb->dev) ;
@@ -1594,9 +1600,9 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 		len += sprintf(page + len, "=============== port@%d ==================\n", i);
 
 		len += sprintf(page + len, "per port@%d: frin_to_be_sent = %ld num_replenishes = %ld frin_sent = %ld\n",
-			       i, atomic64_read(&priv->frin_to_be_sent),
-			       atomic64_read(&priv->num_replenishes),
-			       atomic64_read(&priv->total_frin_sent));
+			       i, atomic_read(&priv->frin_to_be_sent),
+			       atomic_read(&priv->num_replenishes),
+			       atomic_read(&priv->total_frin_sent));
 
 		len += sprintf(page + len,
 			       "per port@%d: %lu(rxp) %lu(rxb) %lu(txp) %lu(txerr) %lu(txb)\n",
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.h b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
index 6e241c3..f60bbf0 100644
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.h
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
@@ -49,7 +49,6 @@ struct phy_info {
         uint32_t *serdes_addr;
 };
 
-
 struct dev_data
 {
         struct net_device *dev;
@@ -66,9 +65,9 @@ struct dev_data
         struct sk_buff* skb;
         int phy_oldlinkstat;
 	uint32_t  frin_desc_thres;
-        atomic64_t frin_to_be_sent;
-	atomic64_t num_replenishes;
-	atomic64_t total_frin_sent;
+        atomic_t frin_to_be_sent;
+	atomic_t num_replenishes;
+	atomic_t total_frin_sent;
         __u8 hwaddr[6];
 
         xlp_mac_speed_t speed;  /* current speed */
-- 
1.7.1

