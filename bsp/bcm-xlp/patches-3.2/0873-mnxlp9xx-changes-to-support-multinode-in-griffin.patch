From c55c1df3d53ceb214866f89205a5faf9d8d28e78 Mon Sep 17 00:00:00 2001
From: Pavani Reddy <pavani@broadcom.com>
Date: Thu, 12 Dec 2013 18:10:18 +0530
Subject: mnxlp9xx : changes to support multinode in griffin

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
index 1d21ff8..95b2c8e 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
@@ -302,7 +302,6 @@ static __inline__ int nlm_hal_disable_rxqdepth(int node, int qid)
 extern int get_dom_fmn_node_ownership(void *fdt, int dom_id);
 extern void nlm_hal_fmn_init(void *fdt, int node);
 extern void nlm_hal_set_fmn_interrupt(int irq);
-
 extern void nlm_hal_disable_vc_intr(int node, int vc);
 extern void nlm_hal_enable_vc_intr(int node, int vc);
 int brcm_hal_config_popq_class(int node, int popq_class, uint8_t width, uint16_t base_id);
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 61f29dc..d9ad8b8 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -979,19 +979,11 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 							if ((credits+1) != nlm_node_cfg.fmn_cfg[node]->fmn_default_credits)
 								nlm_print("Overriding credis from source %d qid %d credits %d \n", base_vc, qid, credits);
 #endif
-
 							nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 14),
 								(0ULL << 42) /* type, credit value + 1 */
 								| (credits << 26) /* credit count */
 								| ((qid | (dst_node << 10)) << 13) /* destination */
-								| (base_vc | (node << 10)) ); /* source */
-				#if 0
-							*(uint64_t *)(xlp_fmn_base[0] + (1 << 14)) =
-								(0ULL << 42) /* type, credit value + 1 */
-								| (credits << 26) /* credit count */
-								| ((qid | (dst_node << 10)) << 13) /* destination */
-								| (base_vc | (node << 10)); /* source */
-				#endif
+								| (base_vc) ); /* source */
 					}
 				}
 			}
@@ -1471,7 +1463,7 @@ int parse_queue_config(void *fdt, int max_nodes)
 							credits = fdt32_to_cpu(*(unsigned int *)(pval));
 							nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn] = credits;
 #ifdef FMN_DEBUG
-                                                nlm_print("node %d station %s has %d credits to %d:Q %s\n", src_node, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].q_name, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn], node, fmn_q_config[d_stn].q_name);
+                                                	nlm_print("node %d station %s has %d credits to %d:Q %s\n", src_node, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].q_name, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn], node, fmn_q_config[d_stn].q_name);
 #endif
 						}
 					}
@@ -1667,8 +1659,10 @@ void nlm_hal_fmn_init(void *fdt, int node)
 
 
         if (is_nlm_xlp9xx()) {
+		unsigned long long mask = ~0xf;
 		fmn_default_qsize = 0;
                 max_msg_blks = XLP9XX_MSG_BLK_MAX;
+		xlp_fmn_base[node] = mask & nlh_read_cfg_reg32(xlp9xx_fmn_base[node] + 0x10);
 	}
         else
                 max_msg_blks = XLP_MSG_BLK_MAX;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 37ad0c8..161ae49 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -609,10 +609,18 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 				return -1;
 			}
 			
-			if (id == 0)
+			if (id == 0){
 				nae->pcie_base = nlm_hal_get_dev_base(node, bus, XLP_NAE_DEVICE, XLP_NAE_FUNC);
-			else
+				if(is_nlm_xlp9xx())
+					nae->pcie_base = xlp9xx_mac0_base[node];
+			}
+			else{
 				nae->pcie_base = nlm_hal_get_dev_base(node, bus, XLP9XX_NAE1_DEVICE, XLP9XX_NAE1_FUNC);
+				if(is_nlm_xlp9xx())
+					nae->pcie_base = xlp9xx_mac1_base[node];
+			}
+
+
 #ifdef XLP_SIM
                         netsoc_api_writel(nae->pcie_base, PCI_MEM_BAR_0, base);
                         nae->mac_base = base;
@@ -620,9 +628,9 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 #else
 			nae->mac_base = mask & netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
 #endif
+
 			nae->nae_base = nae->mac_base + 0xe000;
 			xlp_nae[node][id] = nae;
-			
 			dump_nae_config(nae);
 		}
 	
@@ -645,10 +653,17 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 				return -1;
 			}
 	
-			if (id == 0)
+			if (id == 0){
 				poe->pcie_base = nlm_hal_get_dev_base(node, bus, XLP_POE_DEVICE, XLP_POE_FUNC);
-			else
+				if(is_nlm_xlp9xx())
+					poe->pcie_base = xlp9xx_poe0_base[node];
+				
+			}
+			else{
 				poe->pcie_base = nlm_hal_get_dev_base(node, bus, XLP9XX_POE1_DEVICE, XLP9XX_POE1_FUNC);
+				if(is_nlm_xlp9xx())
+					poe->pcie_base = xlp9xx_poe1_base[node];
+			}
 
 #ifdef XLP_SIM
                         netsoc_api_writel(poe->pcie_base, PCI_MEM_BAR_0, base);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index b4e45f0..53aa881 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -4198,10 +4198,10 @@ int __netsoc_init_nae(nae_t *nae)
         int retval = 0, frin_q;
 
 	if (nae->owned) {
-
-		bar0 = netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
-		bar0 = membar_fixup(bar0);
-
+		 	if(!is_nlm_xlp9xx()){
+				bar0 = netsoc_api_readl(nae->pcie_base, PCI_MEM_BAR_0);
+				bar0 = membar_fixup(bar0);
+	     	}
         	/* frin_fifo represents the 20 pools of free-in descriptor fifos */
 	        __netsoc_drain_allfrin_fifo_descs(nae);
                 __netsoc_deflate_frin_fifo_carving(nae);
@@ -4213,9 +4213,9 @@ int __netsoc_init_nae(nae_t *nae)
                 __netsoc_reset_nae(nae);
                 nae->flags |= NAE_RESET_DONE;
 #endif
-
-                nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
-
+				if(!is_nlm_xlp9xx()){
+                	nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
+				}
 		// Load ucore code
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "Configuring ucore...\n");
                 __netsoc_init_ucore(nae);
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 451e0df..7415f88 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -252,6 +252,20 @@ inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
 
         return (volatile u32 *)(DEFAULT_CPU_IO_BASE + (busno<<20) + (offset) + HDR_OFFSET);
 }
+static inline volatile u32* xlp9xx_cpu_io(int node, u32 offset)
+{
+	volatile u32 * pcmu = NULL;
+	uint32_t busno;
+        if(node <0 )
+		node = xlp9xx_get_node_id();
+
+        pcmu = (volatile u32*)(DEFAULT_CPU_IO_BASE + ( (node&0x7) << 12) );
+        if( offset == BRIDGE ) return pcmu + 0x40;
+
+        busno = (pcmu[6] >> 8 ) & 0xFF;  //get secondary bus number
+
+        return (volatile u32 *)((DEFAULT_CPU_IO_BASE + (busno<<20) + (offset)) & 0x1fffffff);
+}
 #else
 inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
 {
@@ -269,6 +283,23 @@ inline static volatile u32* xlp9xx_cpu_io_mmio(int node, u32 offset)
 	return (volatile u32 *)((DEFAULT_CPU_IO_BASE + (busno<<20) +
                               (offset) + HDR_OFFSET) & 0x1fffffff);
 }
+
+static inline  volatile u32* xlp9xx_cpu_io(int node, u32 offset)
+{
+	volatile u32 * pcmu = NULL;
+	uint32_t busno, val;
+	if(node <0 )
+		node = xlp9xx_get_node_id();
+
+	pcmu = (volatile u32*)((DEFAULT_CPU_IO_BASE + ( (node&0x7) << 12)) & 0x1fffffff);
+	if( offset == BRIDGE ) return pcmu + 0x40;
+
+	val = nlm_hal_read_32bit_reg((uint64_t)pcmu, 6);
+	busno = (val >> 8 ) & 0xFF;  //get secondary bus number
+
+	return (volatile u32 *)((DEFAULT_CPU_IO_BASE + (busno<<20) +
+                              (offset)) & 0x1fffffff);
+}
 #endif
 
 //get device's mem bar0/1 and convert to 64bits uncached virtual memory
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
index 13c4239..89e9b4d 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
@@ -50,6 +50,14 @@ extern int nlm_chip_is_xlp3xx;
 extern unsigned long xlp_regex_base_pcie;
 extern unsigned long xlp_regex_base_pcim;
 
+extern unsigned long xlp9xx_mac0_base[];
+extern unsigned long xlp9xx_mac1_base[];
+extern unsigned long xlp9xx_poe0_base[];
+extern unsigned long xlp9xx_poe1_base[];
+extern unsigned long xlp9xx_fmn_base[];
+extern unsigned long xlp9xx_sys_clk_base[];
+
+
 
 #ifndef is_nlm_xlp8xx
 extern int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext);
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index de5eae3..9302e09 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -418,6 +418,18 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP9XX_ALE_DEVICE               3
 #define XLP9XX_ALE_FUNC                 5 
 
+#define XLP9XX_SYS_BUS			0x1
+#define XLP9XX_SYS_DEVICE		0x6
+#define XLP9XX_CLK_DEVICE		0x6
+#define XLP9XX_SYS_FUNC			0x0
+#define XLP9XX_CLK_FUNC			0x2
+
+
+#define XLP9XX_SAE_RSA_BUS_NUM		(1<<20)
+#define XLP9XX_PCIE_DEV_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+
+
+
 /*Sw Code */
 #define XLP_CODE_MAC		0
 #define XLP_CODE_SEC		1
@@ -498,20 +510,10 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP_SYS_DEVICE			0x6
 #define XLP_SYS_FUNC			0x5
 
-#define XLP9XX_SYS_BUS			0x1
-#define XLP9XX_SYS_DEVICE		0x6
-#define XLP9XX_SYS_FUNC			0x0
-
-#define XLP9XX_SYS_FUNC_CLKDEV  2
-
-#define XLP9XX_SYS_CLKDEV_BASE(node)   (0x18000000 + (XLP9XX_SYS_BUS << 20) + (((node * XLP_MAXDEV_PERNODE) + XLP9XX_SYS_DEVICE) << 15) + (XLP9XX_SYS_FUNC_CLKDEV << 12))
+#define XLP_PCIE_DEV_BASE(node, SOC)                ((((node * XLP_MAXDEV_PERNODE) + SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
 
 #define XLP_MAXDEV_PERNODE		8
 
-#define XLP9XX_SAE_RSA_BUS_NUM		(1<<20)
-#define XLP9XX_PCIE_DEV_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
-#define XLP_PCIE_DEV_BASE(node, SOC)                ((((node * XLP_MAXDEV_PERNODE) + SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
-
 #define XLP_NA_REG_BLOCK_SIZE       0x2000 /* 8KB */
 #define PCI_MEM_BAR_0               0x0004
 #define MAX_NUMBER_OF_SERDES_LANE   0x8
diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
index e996351..c633de2 100644
--- a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -150,14 +150,15 @@ enum dev_clk{
     3 - divide by 8
 */
 
+extern unsigned long  xlp9xx_sys_clk_base[];
 static inline uint64_t get_nae_frequency(int node) 
 {
     uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_NET * 2;
     uint32_t clk_freq;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node); 
+    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
 
-    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
-    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+    sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
 
     switch (sel) {
         case 0: pll_out = 133; break;
@@ -176,14 +177,14 @@ static inline uint64_t get_nae_frequency(int node)
     nlm_print("sel:%d div:%d NET_FREQUENCY :%d MHz\n", sel, div, clk_freq);
     return (uint64_t) (clk_freq * 1000000);
 }
-
 static inline int xlp9xx_set_gbu_frequency(int node, uint64_t freq)
 {
     int sel, div, dev_shift, i;
     const uint64_t mhz = 1000000;
     int dev_freq = freq / mhz;
     uint32_t val, dev_id = XLP9XX_CLKDEV_GBU;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+    	
 		
     switch (dev_freq) {
         case 133: sel = 0; div = 0; break;
@@ -211,27 +212,27 @@ static inline int xlp9xx_set_gbu_frequency(int node, uint64_t freq)
     dev_shift = dev_id * 2;	
     // Write the div and select register	
     val = ((sel & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
 	
     val = ((div & 0x3) << dev_shift);  
-    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
 	
     // Poll Change register
-    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+    syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
 
     i=0;
     while (i++ < 10) {
-      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+      val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
 
       if ((i==10) || ((val & (1 << dev_id)) == 0)) {
           // Check the status
-	  val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+	  val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
           if (val != sel) {
-              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
           }
-          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
           if (val != div) {
-              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
           }
           break;
       }
@@ -247,13 +248,13 @@ static inline int xlp9xx_set_nae_frequency(int node, uint64_t freq)
     int dev_freq;
     uint64_t nae_freq;
     uint32_t val, dev_id = XLP9XX_CLKDEV_NET;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
 
     nae_freq = get_nae_frequency(node);
 
     NLM_HAL_DO_DIV(nae_freq, mhz);
 
-    nlm_print("NAE frequency %lu MHz\n", nae_freq);
+    nlm_print("NAE frequency %lu MHz node :%d\n", nae_freq,node);
 		
     if (freq == get_nae_frequency(node))
 	return 0;
@@ -286,27 +287,27 @@ static inline int xlp9xx_set_nae_frequency(int node, uint64_t freq)
     dev_shift = dev_id * 2;	
     // Write the div and select register	
     val = ((sel & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
 	
     val = ((div & 0x3) << dev_shift);  
-    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
 	
     // Poll Change register
-    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+    syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
 
     i=0;
     while (i++ < 10) {
-      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+      val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
 
       if ((i==10) || ((val & (1 << dev_id)) == 0)) {
           // Check the status
-	  val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+	  val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
           if (val != sel) {
-              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
           }
-          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
           if (val != div) {
-              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
           }
           break;
       }
@@ -320,15 +321,15 @@ static inline uint64_t get_crypto_block_frequency(int node, int dev_id)
 {
     uint32_t sel, div, pll_out, dev_shift;
     uint32_t clk_freq;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
 
     if (dev_id == XLP9XX_CLKDEV_SEC) 
         dev_shift = XLP9XX_CLKDEV_SEC * 2;
     else 
         dev_shift = XLP9XX_CLKDEV_RSA * 2;
 
-    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
-    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+    sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
 
     switch (sel) {
         case 0: pll_out = 133; break;
@@ -356,7 +357,7 @@ static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq
     int dev_freq;
     uint64_t block_freq;
     uint32_t val;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
     char* block_name;
 
     NLM_HAL_DO_DIV(freq, mhz);
@@ -389,29 +390,29 @@ static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq
     dev_shift = dev_id * 2;
     // Write the div and select register
     val = ((sel & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
 
     val = ((div & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
 
     // Poll Change register
-    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+    syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
 
     i=0;
     while (i++ < 10) {
-      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+      val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
 
       if ((i==10) || ((val & (1 << dev_id)) == 0)) {
           // Check the status
-          val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
           if (val != sel) {
               nlm_print(" %s CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n",
-                          block_name, syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+                          block_name, syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
           }
-          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
           if (val != div) {
               nlm_print("%s CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n",
-                         block_name, syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+                         block_name, syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
           }
           break;
       }
@@ -427,10 +428,11 @@ static inline uint64_t get_dtre_frequency(int node)
 {
     uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_GDX * 2;
     uint32_t clk_freq;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+//    uint64_t sys_clk_base = XLP9XX_SYS_CLKDEV_BASE(node);
+   uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
 
-    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
-    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+    sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
 
     switch (sel) {
         case 0: pll_out = 133; break;
@@ -458,7 +460,9 @@ static inline int xlp9xx_set_dtre_frequency(int node, uint64_t freq)
     int dev_freq;
     uint64_t dtre_freq;
     uint32_t val, dev_id = XLP9XX_CLKDEV_GDX;
-    uint64_t sys_base = XLP9XX_SYS_CLKDEV_BASE(node);
+//    uint64_t sys_clk_base = XLP9XX_SYS_CLKDEV_BASE(node);
+	   uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
 
     dtre_freq = get_dtre_frequency(node);
 
@@ -500,27 +504,27 @@ static inline int xlp9xx_set_dtre_frequency(int node, uint64_t freq)
     dev_shift = dev_id * 2;
     /* Write the div and select register */
     val = ((sel & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
 
     val = ((div & 0x3) << dev_shift);
-    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+    syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
 
     /* This register determines which device's CLK_DEVSEL will be changed, device mapping  same as CLK_DEVDIS register,hardware deasserts this bit when done */
-    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+    syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
 
     i=0;
     while (i++ < 10) {
       /* Poll Change register to see if bit corresponding to our device has been deasserted */
-      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+      val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
       if ((i==10) || ((val & (1 << dev_id)) == 0)) {
           // Check the status
-          val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
           if (val != sel) {
-              nlm_print("DTRE CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+              nlm_print("DTRE CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
           }
-          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
           if (val != div) {
-              nlm_print("DTRE CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+              nlm_print("DTRE CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
           }
           break;
       }
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 000204c..8492a9b 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -78,9 +78,18 @@ unsigned long xlp_mac_base[NLM_MAX_NODES];
 unsigned long xlp_poe_base_pcie[NLM_MAX_NODES];
 unsigned long xlp_poe_base_pcim[NLM_MAX_NODES];
 unsigned long xlp_sys_base[NLM_MAX_NODES];
+unsigned long xlp_sys_clk_base[NLM_MAX_NODES];
 unsigned long xlp_regex_base_pcie;
 unsigned long xlp_regex_base_pcim;
 
+/*9XX*/
+unsigned long xlp9xx_mac0_base[NLM_MAX_NODES];
+unsigned long xlp9xx_mac1_base[NLM_MAX_NODES];
+unsigned long xlp9xx_poe0_base[NLM_MAX_NODES];
+unsigned long xlp9xx_poe1_base[NLM_MAX_NODES];
+unsigned long xlp9xx_fmn_base[NLM_MAX_NODES];
+unsigned long xlp9xx_sys_clk_base[NLM_MAX_NODES];
+
 struct nlm_node_config  nlm_node_cfg;
 
 
@@ -266,7 +275,7 @@ __inline__ uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func)
 	return (uint64_t)  (base +
 			    (bus << 20) +
 			    (dev << 15) +
-			    (node*8 << 15) +
+			    ((node*8) << 15) +
 			    (func << 12));
 }
 
@@ -391,11 +400,10 @@ __inline__ void nlm_hal_init(void)
 	nlm_hal_enumerate_pci();
 
 	nlm_node_cfg.valid = 1;
-	nlm_node_cfg.num_nodes = 1;
+	nlm_node_cfg.num_nodes = 1; 
 
  	for(node = 0; node < NLM_MAX_NODES; node++)
 	{
-		//nlm_node_cfg.nae_cfg[node] = NULL;
 		nlm_node_cfg.nae_cfg[node] = NULL;
 		nlm_node_cfg.fmn_cfg[node] = NULL;
 
@@ -404,13 +412,14 @@ __inline__ void nlm_hal_init(void)
         	/* PCI enumeration of supported devices*/
 
 		if (is_nlm_xlp9xx()) {
-			xlp_mac_base[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_NAE));
-			xlp_fmn_base[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
-			xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
-
-			xlp_poe_base_pcim[node] = (uint64_t)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_POE));
-			xlp_poe_base_pcie[node] = (xlp_io_base | XLP9XX_PCIE_DEV_BASE(XLP_POE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
-			xlp_sys_base[node] = (xlp_io_base | (XLP9XX_SYS_BUS << 20) | XLP9XX_PCIE_DEV_BASE(XLP9XX_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+				
+			xlp9xx_mac0_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
+			xlp9xx_mac1_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
+			xlp9xx_poe0_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE0));
+			xlp9xx_poe1_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE1));
+			xlp9xx_fmn_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
+			xlp_sys_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_SYS));
+			xlp9xx_sys_clk_base[node] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_CLK));
 
 			xlp_sae_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
 			xlp_rsa_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
@@ -478,6 +487,14 @@ EXPORT_SYMBOL(xlp_rsa_base);
 EXPORT_SYMBOL(xlp_poe_base_pcie);
 EXPORT_SYMBOL(xlp_poe_base_pcim);
 
+EXPORT_SYMBOL(xlp9xx_mac0_base);
+EXPORT_SYMBOL(xlp9xx_mac1_base);
+EXPORT_SYMBOL(xlp9xx_poe0_base);
+EXPORT_SYMBOL(xlp9xx_poe1_base);
+EXPORT_SYMBOL(xlp9xx_fmn_base);
+EXPORT_SYMBOL(xlp9xx_sys_clk_base);
+
+
 EXPORT_SYMBOL(nlm_hal_init);
 EXPORT_SYMBOL(nlm_hal_read_32bit_reg);
 EXPORT_SYMBOL(nlm_hal_write_32bit_reg);
-- 
1.7.1

