From b91433d4f865b30f0fa23446e9ced2bd1288d985 Mon Sep 17 00:00:00 2001
From: Tanmay Jagdale <tanmayj@broadcom.com>
Date: Tue, 25 Nov 2014 18:39:17 +0530
Subject: fdtconf: little endian fixes

All the DTB values should be in big endian format hence converted
the values to big endian before setting them.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/fdtconf/fdtconf.c b/drivers/misc/netlogic/fdtconf/fdtconf.c
index 5456d99..a2414b5 100644
--- a/drivers/misc/netlogic/fdtconf/fdtconf.c
+++ b/drivers/misc/netlogic/fdtconf/fdtconf.c
@@ -89,6 +89,7 @@ static void parse_and_fill_kern_params(void)
 			word = CPUMASK_WORDS - pcpu/32 - 1;
 			bit = pcpu % 32;
 			mask[word] |= 1u << bit;
+			mask[word] = cpu_to_fdt32(mask[word]);
 		}
 
 		err = fdt_setprop(fdt, node, "netlogic,cpumask", mask,
@@ -140,6 +141,7 @@ static void parse_and_fill_kern_params(void)
 
 		/* Node */
 		frin[0] = prop[0];
+		frin[0] = fdt32_to_cpu(frin[0]);
 
 		/* Freein Fifo start address */
 		frin[1] = (frin_fifo_address >> 32) & 0xffffffff;
@@ -149,6 +151,9 @@ static void parse_and_fill_kern_params(void)
 		frin[3] = ((frin_fifo_size / 2) >> 32) & 0xffffffff;
 		frin[4] = (frin_fifo_size / 2) & 0xffffffff;
 
+		for (i = 0; i < 5; i++)
+			frin[i] = cpu_to_fdt32(frin[i]);
+
 		if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
 				frin, sizeof(frin)))
 			dev_err(&fdtdev->dev, "Could not set "
@@ -174,6 +179,7 @@ static void parse_and_fill_kern_params(void)
 
 		/* Node */
 		frin[0] = prop[0];
+		frin[0] = fdt32_to_cpu(frin[0]);
 
 		/* Freein Fifo start address */
 		frin[1] = (frin_fifo_address >> 32) & 0xffffffff;
@@ -183,6 +189,9 @@ static void parse_and_fill_kern_params(void)
 		frin[3] = (frin_fifo_size >> 32) & 0xffffffff;/* High 32-bits */
 		frin[4] = frin_fifo_size & 0xffffffff;	/* Low 32-bits */
 
+		for (i = 0; i < 5; i++)
+			frin[i] = cpu_to_fdt32(frin[i]);
+
 		if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
 				frin, sizeof(frin)))
 			dev_err(&fdtdev->dev, "Could not set "
@@ -205,6 +214,7 @@ static void parse_and_fill_kern_params(void)
 
 	/* Node */
 	frin[0] = prop[0];
+	frin[0] = fdt32_to_cpu(frin[0]);
 
 	/* Freein Fifo start address */
 	frin[1] = (frin_fifo_address >> 32) & 0xffffffff; /* High 32-bits */
@@ -214,6 +224,9 @@ static void parse_and_fill_kern_params(void)
 	frin[3] = (frin_fifo_size >> 32) & 0xffffffff;	/* High 32-bits */
 	frin[4] = frin_fifo_size & 0xffffffff;		/* Low 32-bits */
 
+	for (i = 0; i < 5; i++)
+		frin[i] = cpu_to_fdt32(frin[i]);
+
 	if (fdt_setprop(fdt, node, "freein-fifo-replenish-addr-info",
 			frin, sizeof(frin)))
 		dev_err(&fdtdev->dev, "Could not set "
@@ -227,7 +240,7 @@ static int handle_opcodes(int node, char *file)
 {
 	const struct firmware	*fw;
 	char		*next;
-	uint32_t	*ucode_buf, ncodes, umask;
+	uint32_t	*ucode_buf, ncodes, umask, ncodes_be;
 	const uint32_t	*prop;
 	const char	*ucode, *end_of_ucode;
 	int		err;
@@ -261,11 +274,14 @@ static int handle_opcodes(int node, char *file)
 			continue;
 		}
 		ucode_buf[ncodes] = simple_strtoul(ucode, &next, 16);
+		ucode_buf[ncodes] = cpu_to_fdt32(ucode_buf[ncodes]);
 		ncodes++;
 		ucode = next;
 	}
 
-	err = fdt_setprop(fdt, node, "num-opcodes", &ncodes, sizeof(ncodes));
+	ncodes_be = cpu_to_fdt32(ncodes);
+	err = fdt_setprop(fdt, node, "num-opcodes", &ncodes_be,
+			sizeof(ncodes_be));
 	if (err)
 		goto free;
 
@@ -280,9 +296,11 @@ static int handle_opcodes(int node, char *file)
 		goto free;
 
 	umask = prop[0];
+	umask = fdt32_to_cpu(umask);
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
 		umask &= 0xff;
 
+	umask = cpu_to_fdt32(umask);
 	err = fdt_setprop(fdt, node, "mask", &umask, sizeof(umask));
 	if (err)
 		dev_err(&fdtdev->dev, "Could not set ucore mask");
-- 
1.7.1

