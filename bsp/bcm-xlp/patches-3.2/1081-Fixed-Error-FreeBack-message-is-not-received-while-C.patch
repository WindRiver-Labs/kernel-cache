From a5267a295a75c0c5e7b8ba52be6201f1f5d3ce94 Mon Sep 17 00:00:00 2001
From: Alok Agrawat <aagrawat@netlogicmicro.com>
Date: Thu, 6 Oct 2011 16:22:10 +0530
Subject: Fixed "Error: FreeBack message is not received" while CDE bring up on XLPEV LE mode. Fixed "RSA tests failed on XLPEV and STORM in LE mode"

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nlm_cde/nlm_cde.c b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
index 171532c..968f11f 100644
--- a/drivers/misc/netlogic/nlm_cde/nlm_cde.c
+++ b/drivers/misc/netlogic/nlm_cde/nlm_cde.c
@@ -270,7 +270,7 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
     length = SCRATCH_SIZE;
 
     cmp_data->src_desc[desc_idx] =
-      nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch));
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch)));
 
 #ifdef CDE_DEBUG
       printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
@@ -291,7 +291,7 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
 	cmp_data->src_desc[cur_desc] =
-	  nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
 
 #ifdef CDE_DEBUG
 	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
@@ -363,7 +363,7 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
     length = SCRATCH_SIZE;
 
     cmp_data->src_desc[desc_idx] =
-      nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch));
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch)));
 
 #ifdef CDE_DEBUG
       printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
@@ -386,11 +386,11 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
 	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
 	cmp_data->src_desc[cur_desc] =
-	  nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
 
 	if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
 		save = ( (eob == 1) & (eof == 0)) ;
-		cmp_data->src_desc[cur_desc+num_desc] = nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start));
+		cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
 #ifdef CDE_DEBUG
 	  printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n", 
 		cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
@@ -482,6 +482,7 @@ static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
   for (i = 0; i < num_desc; i++) {
     desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
 
+    *desc = cpu_to_be64(*desc);
     num_bytes = (*desc >> 40) & 0xffff;
     dest_addr = *desc & 0xffffffffffUll;
     tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
diff --git a/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
index 8c3cc61..5df8b5c 100644
--- a/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
+++ b/drivers/misc/netlogic/nlm_rsa/nlm_rsa.c
@@ -157,7 +157,7 @@ int dword_data_copy(uint64_t *dst, uint64_t *src, int len, int dlen)
     idx --;
 
     for(i = 0; i < dword_size; ++i) {
-	dst[idx--] = src[i];
+	dst[idx--] = cpu_to_be64(src[i]);
     }
 
     if(ret < dlen) {
@@ -325,7 +325,7 @@ nlm_xlp_rsa_msgring_handler(uint32_t vc, uint32_t src_id,
 int
 nlm_rsa_init(void)
 {
-    int ret = 0, i, size;
+    int ret = 0, i, size, boot_data_size = 0;
     struct nlm_rsa_param rprm;
     uint32_t rx_vc;
     uint64_t tx_id = 0x1234;
@@ -348,6 +348,9 @@ nlm_rsa_init(void)
 	printk("\n Memory allocation failed for nlm_rsa_init");	
 	return 0;
     }
+    boot_data_size = size/(sizeof(uint64_t));
+    for(i =0; i < boot_data_size; i++)
+	ucode_data[i] = cpu_to_be64(ucode_data[i]);
     memcpy(src, (unsigned char*)ucode_data, size);
     rx_vc = rsa_get_fb_vc();
     rprm.type = 0x70;
@@ -490,27 +493,27 @@ int nlmrsa_ecc_point_add (
 
 	dst = (uint64_t*)x1;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)y1;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)x2;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)y2;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)a;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)m;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
     }
     dst = (uint64_t*)out;
@@ -523,7 +526,7 @@ int nlmrsa_ecc_point_add (
     {
 	for(i = 0; i < data_size; i++)
 	{
-	    dst[index] = sd.dst_addr[index];
+	    dst[index] = cpu_to_be64(sd.dst_addr[index]);
 	    index++;
 	}
     }
@@ -596,19 +599,19 @@ int nlmrsa_ecc_point_double(
 
 	dst = (uint64_t*)x;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)y;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)a;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)m;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
     }
     dst = (uint64_t*)out;
@@ -623,7 +626,7 @@ int nlmrsa_ecc_point_double(
     {
 	for(i = 0; i < data_size; i++)
 	{
-	    dst[index] = sd.dst_addr[index];
+	    dst[index] = cpu_to_be64(sd.dst_addr[index]);
 	    index++;
 	}
     }
@@ -697,23 +700,23 @@ nlmrsa_ecc_point_mul (
 
 	dst = (uint64_t*)x;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)y;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)a;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)p;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)m;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
     }
     dst = (uint64_t*)out;
@@ -732,7 +735,7 @@ nlmrsa_ecc_point_mul (
     {
 	for(i = 0; i < data_size; i++)
 	{
-	    dst[index] = sd.dst_addr[index];
+	    dst[index] = cpu_to_be64(sd.dst_addr[index]);
 	    index++;
 	}
     }
@@ -805,23 +808,23 @@ int nlmrsa_ecc_point_verification(
 
 	dst = (uint64_t*)x;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)y;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)a;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)p;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)m;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
     }
     dst = (uint64_t*)out;
@@ -833,7 +836,7 @@ int nlmrsa_ecc_point_verification(
     {
 	for(i = 0; i < data_size; i++)
 	{
-	    dst[(data_size -i -1)] = sd.dst_addr[index];
+	    dst[(data_size -i -1)] = cpu_to_be64(sd.dst_addr[index]);
 	    index++;
 	}
     }
@@ -905,15 +908,15 @@ int nlmrsa_ecc_mod_mul( unsigned char *x, unsigned int x_len,
 
 	dst = (uint64_t*)x;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 	dst = (uint64_t*)p;
 
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
 	dst = (uint64_t*)m;
 	for(i = 0; i < data_size; i++)
-	    src[k++] = dst[i];
+	    src[k++] = cpu_to_be64(dst[i]);
 
     }
     dst = (uint64_t*)y;
@@ -923,7 +926,7 @@ int nlmrsa_ecc_mod_mul( unsigned char *x, unsigned int x_len,
     data_size--;
     for(i = 0; i <= data_size; i++)
     {
-	dst[i] = sd.dst_addr[i];
+	dst[i] = cpu_to_be64(sd.dst_addr[i]);
     }
 
     free_cache_aligned_mem(sd.src_addr);	
@@ -985,7 +988,7 @@ int rmisec_mod_exp (
     data_size--;
     for(i = 0; i <= data_size; i++)
     {
-	dst[data_size-i] = sd.dst_addr[i];
+	dst[data_size-i] = cpu_to_be64(sd.dst_addr[i]);
     }
 
     free_cache_aligned_mem(sd.src_addr);	
@@ -1214,12 +1217,12 @@ int nlmrsa_ecc_mod_substraction(uint64_t handle, unsigned char *x, int x_len, un
     memset(sd.src_addr, 0, (unit_len * num_inputs));
     memset(sd.dst_addr, 0, (unit_len * num_outputs));
 
-    sd.src_addr[0] = 78ULL;
-    sd.src_addr[1] = 45ULL;
-    sd.src_addr[2] = 7ULL;
+    sd.src_addr[0] = cpu_to_be64(78ULL);
+    sd.src_addr[1] = cpu_to_be64(45ULL);
+    sd.src_addr[2] = cpu_to_be64(7ULL);
 
     nlm_rsa_operation(&sd);
-    printk("output = %lld\n",sd.dst_addr[0]);
+    printk("output = %lld\n",cpu_to_be64(sd.dst_addr[0]));
 
     free_cache_aligned_mem(sd.src_addr);	
     free_cache_aligned_mem(sd.dst_addr);	
-- 
1.7.1

