From ca460c299f3a7e531bc3e1979b7f8d11809e53fc Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Thu, 25 Jul 2013 09:43:58 -0700
Subject: syslib: Added API to configure NET frequency

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
new file mode 100644
index 0000000..37cc950
--- /dev/null
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -0,0 +1,270 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef __XLP9XX_SYS_H__
+#define __XLP9XX_SYS_H__
+
+#include "nlm_hal.h"
+
+#ifndef __ASSEMBLY__
+enum processor_sys
+{
+        SYS_POWERONRESETCFG    = 0x0,
+        SYS_CHIPRESET          = 0x1,
+        SYS_CPURESET           = 0x2,
+        SYS_CPUNONCOHERENTMODE = 0x3,
+        SYS_CPUTHREADEN0       = 0x4,
+        SYS_CPUTHREADEN1       = 0x5,
+        SYS_SYSDISCFG0         = 0x25,
+        SYS_SYSDISCFG1         = 0x26,
+        SYS_SYSDISCFG2         = 0x27,
+        SYS_SYSDISCFG3         = 0x28,
+        SYS_SYSDISCFG4         = 0x29,
+        SYS_SYSDISCFG5         = 0x2a,
+        SYS_SYSDISCFG6         = 0x2b,
+        SYS_SYSDISCFG7         = 0x2c,
+        SYS_SYSDEVICEDIS       = 0x34,
+        SYS_SYSDEVICERESET     = 0x3c,
+        SYS_SYSRESETCFG        = 0x3d,
+        SYS_BYTESWAP           = 0x45,
+        SYS_SYSCTRL            = 0x46,
+        SYS_TIMEOUTBSI         = 0x47,
+        SYS_BISTRESET          = 0x48,
+        SYS_SYSCFG             = 0x49,
+        SYS_SYSHOTPLUGWAITOUT  = 0x4a,
+        SYS_SYSHOTPLUGWAITIN   = 0x4b,
+        SYS_SYSHOTPLUGDONE     = 0x4c,
+        SYS_SYSSCRATCH         = 0x69,
+        SYS_SYSCOUNTER         = 0x71,
+        SYS_SYSSTATUS          = 0x91,
+        SYS_SYSINTSTATUS       = 0x92,
+        SYS_SYSINTENABLE0      = 0x93,
+        SYS_SYSINTENABLE1      = 0x94,
+        SYS_MONITORCTRL        = 0x9c,
+        SYS_CPUMONITOR         = 0xa4,
+        SYS_DDRMONITOR         = 0x1a4,
+        SYS_SOCMONITOR         = 0x1ac,
+        SYS_MEMBISTGO          = 0x1c0,
+        SYS_MEMSTAT            = 0x200
+};
+
+//Device -6 , function - 2
+enum dev_sys {
+        PLL_CLKCTRL             = 0x41,
+        CLK_CHOPCTRL            = 0x45,
+        CPU_CLKCHOPEN           = 0x46,
+        SOC_CLKCHOPEN           = 0x47,
+        CPU_PLLCTRL_0_0         = 0x140,
+        CPU_PLLCTRL_1_0         = 0x141,
+        CPU_PLLCTRL_2_0         = 0x142,
+        CPU_PLLCTRL_3_0         = 0x143,
+
+        SYS_PLLCTRL_0           = 0x184,
+        SYS_PLLCTRL_1           = 0x185,
+        SYS_PLLCTRL_2           = 0x186,
+        SYS_PLLCTRL_3           = 0x187,
+
+        DEV_PLLCTRL_0           = 0x188,
+        DEV_PLLCTRL_1           = 0x189,
+        DEV_PLLCTRL_2           = 0x18a,
+        DEV_PLLCTRL_3           = 0x18b,
+
+        CPU_PLLCHG_CTRL         = 0x1c8,
+        SYS_PLLCHG_CTRL         = 0x1c9,
+        CLK_DEVDIS              = 0x1ca,
+        CLK_DEVSEL              = 0x1cb,
+        CLK_DEVDIV              = 0x1cd,
+        CLK_DEVCHG              = 0x1cf,
+
+	CLK_DEVSEL_STAT		= 0x1e4,
+	CLK_DEVDIV_STAT		= 0x1e6,
+};
+
+enum dev_clk{
+        XLP9XX_CLKDEV_PIC = 0,
+        XLP9XX_CLKDEV_GDX = 1,
+        XLP9XX_CLKDEV_CMP = 2,
+        XLP9XX_CLKDEV_REGXF = 3,
+        XLP9XX_CLKDEV_REGXS = 4,
+        XLP9XX_CLKDEV_SEC = 5,
+        XLP9XX_CLKDEV_RSA = 6,
+        XLP9XX_CLKDEV_NET = 7,
+        XLP9XX_CLKDEV_SATA = 8,
+        XLP9XX_CLKDEV_KBP = 9,
+        XLP9XX_CLKDEV_USB = 10,
+        XLP9XX_CLKDEV_GIO = 11,
+        XLP9XX_CLKDEV_GBU = 12,
+        XLP9XX_CLKDEV_MMC = 13,
+        XLP9XX_CLKDEV_NAND = 14,
+        XLP9XX_CLKDEV_LZS = 15,
+};
+
+#endif //__ASSEMBLY__
+
+#define SYS_BUS		1
+#define SYS_DEV		6
+#define SYS_FUNC_CLKDEV	2
+
+#define SYS_CLKDEV_BASE(node)   (0x18000000 + (SYS_BUS << 20) + (((node * XLP_MAXDEV_PERNODE) + SYS_DEV) << 15) + (SYS_FUNC_CLKDEV << 12))
+
+#define syssoc_write_reg(base, reg, val)	nlm_hal_write_32bit_reg(base, reg, val)
+#define syssoc_read_reg(base, reg)		nlm_hal_read_32bit_reg(base, reg)
+
+/* 
+    Following are the selections for clock source selector
+    0 - 133 MHz (Ref clock)
+    1 - 500 MHz (Dev 0 PLL clock)
+    2 - 667 MHz (Dev 1 PLL clock)
+    3 - 767 MHz (Dev 2 PLL clock)
+
+    Following are the selections for clock divide selector
+    0 - divide by 1
+    1 - divide by 2
+    2 - divide by 4
+    3 - divide by 8
+*/
+
+static inline uint64_t get_nae_frequency(int node) 
+{
+    uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_NET * 2;
+    uint32_t clk_freq;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node); 
+
+    sel = (syssoc_read_reg(sys_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+    div = (syssoc_read_reg(sys_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+    switch (sel) {
+        case 0: pll_out = 133; break;
+        case 1: pll_out = 500; break;
+        case 2: pll_out = 667; break;
+        case 3: pll_out = 767; break;
+    }
+
+    switch (div) {
+        case 0: clk_freq = pll_out; break;
+        case 1: clk_freq = pll_out/2; break;
+        case 2: clk_freq = pll_out/4; break;
+        case 3: clk_freq = pll_out/8; break;
+    }
+
+    nlm_print("sel:%d div:%d NET_FREQUENCY :%d MHz\n", sel, div, clk_freq);
+    return (uint64_t) (clk_freq * 1000000);
+}
+
+
+static inline int set_nae_frequency(int node, uint64_t freq)
+{
+    int sel, div, dev_shift, i;
+    const uint64_t mhz = 1000000;
+    int dev_freq = freq / mhz;
+    uint32_t val, dev_id = XLP9XX_CLKDEV_NET;
+    uint64_t sys_base = SYS_CLKDEV_BASE(node);
+
+    nlm_print("NAE frequency %d MHz\n",get_nae_frequency(node) / mhz);
+		
+    if (freq == get_nae_frequency(node))
+	return 0;	
+    switch (dev_freq) {
+        case 133: sel = 0; div = 0; break;
+        case 66:  sel = 0; div = 1; break;
+        case 33:  sel = 0; div = 2; break;
+        case 17:  sel = 0; div = 3; break;
+        case 500: sel = 1; div = 0; break;
+        case 250: sel = 1; div = 1; break;
+        case 125: sel = 1; div = 2; break;
+        case 63:  sel = 1; div = 3; break;
+        case 667: sel = 2; div = 0; break;
+        case 333: sel = 2; div = 1; break;
+        case 167: sel = 2; div = 2; break;
+        case 83:  sel = 2; div = 3; break;
+        case 767: sel = 3; div = 0; break;
+        case 383: sel = 3; div = 1; break;
+        case 192: sel = 3; div = 2; break;
+        case 96:  sel = 3; div = 3; break;
+        default: // Set it to 333 MHz
+            nlm_print("Can't set freq to given MHz. Setting NAE Freq to 667 MHz instead.\n");
+            sel = 2; div = 0;
+        break;
+    }
+
+    dev_shift = dev_id * 2;	
+    // Write the div and select register	
+    val = ((sel & 0x3) << dev_shift);
+    syssoc_write_reg(sys_base, CLK_DEVSEL, val);
+	
+    val = ((div & 0x3) << dev_shift);  
+    syssoc_write_reg(sys_base, CLK_DEVDIV, val);
+	
+    // Poll Change register
+    syssoc_write_reg(sys_base, CLK_DEVCHG, 0x1 << dev_id);
+
+    i=0;
+    while (i++ < 10) {
+      val = syssoc_read_reg(sys_base, CLK_DEVCHG);
+
+      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+          // Check the status
+	  val = (syssoc_read_reg(sys_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+          if (val != sel) {
+              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVSEL_STAT), sel, val);
+          }
+          val = (syssoc_read_reg(sys_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+          if (val != div) {
+              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_base, CLK_DEVDIV_STAT), div, val);
+          }
+          break;
+      }
+    }
+
+    nlm_print("NAE frequency %d MHz\n",get_nae_frequency(node) / mhz);
+    return 0;
+}
+
+
+static inline int set_soc_frequency(int node, int dev_id, uint64_t freq)
+{
+
+	switch(dev_id) {
+		case XLP9XX_CLKDEV_NET:
+			set_nae_frequency(node, freq);
+			break;
+		default:
+			nlm_print("%s error\n",__func__);
+			break;
+	}
+        return 0;
+}
+
+#endif
-- 
1.7.1

