From 87a0d76aa1b811928f607aefcee18416f3ee6b5a Mon Sep 17 00:00:00 2001
From: Alok Agrawat <alok@broadcom.com>
Date: Tue, 25 Sep 2012 02:52:58 -0700
Subject: nae: remove hard code MAC Address.

The Mac Address was hardcoded for MacSec Tests. Removing..
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index 569fe7b..32d69ab 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -72,7 +72,7 @@
 #define NLM_TCP_MODE	1
 #define NLM_RT_MODE	2
 
-#define TSO_ENABLED	1 
+#define TSO_ENABLED	1
 
 /*Enable sanity checks while receiving or transmitting buffer */
 #undef ENABLE_SANITY_CHECKS
@@ -144,7 +144,7 @@ static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 static struct net_device *dev_mac[NLM_MAX_NODES][MAX_GMAC_PORT];
 
 /*1588 ptp cycle counter */
-static uint64_t acc_1588[NLM_MAX_NODES];	
+static uint64_t acc_1588[NLM_MAX_NODES];
 
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
@@ -159,7 +159,7 @@ static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
 static void xlp_mac_setup_hwaddr(struct dev_data *priv);
 static int nlm_xlp_nae_set_hwaddr(struct net_device *dev, void *p);
-#ifdef IEEE_1588_PTP_ENABLED	
+#ifdef IEEE_1588_PTP_ENABLED
 static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb);
 #endif
 static cycle_t nlm_1588_read_clock0(const struct cyclecounter *tc);
@@ -176,7 +176,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
 #define Message(fmt, args...) { }
 //#define Message(fmt, args...) printk(fmt, ##args)
 
-
+//define MACSEC_DEBUG		1
 #define MAC_HEADER_LEN		12
 #define MAC_ADDR_LEN		6
 #define MACSEC_ETHER_TYPE	0x88e5
@@ -258,7 +258,7 @@ static void gen_mac_address(void)
 
 	eeprom_get_magic_bytes(nlm_eeprom,buf0_read,0);/* signature*/
 	eeprom_get_magic_bytes(nlm_eeprom,buf1_read,1);
-	
+
 
 	if((buf0_read[0]==buf_write[0]) && (buf0_read[1]==buf_write[1]))/*match the signature*/
 	{
@@ -279,17 +279,8 @@ static void gen_mac_address(void)
 		}
 	}
 	if( ((mac0_set | mac1_set) && if_mac_set) == 0){
-		//random_ether_addr(mac_base);
-	}
-	/* Temporarily added for MACSec. MACSec needs to know the correct MAC Address.
- 	   This function is broken. It is assigning MAC Address randomly
-	*/
-	mac_base[0]= 0x11;
-	mac_base[1]= 0x22;
-	mac_base[2]= 0x33;
-	mac_base[3]= 0x44;
-	mac_base[4]= 0x55;
-	mac_base[5]= 0x67;
+		random_ether_addr(mac_base);
+	}
 
 	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
 		for(j=0;j<18;j++){
@@ -576,10 +567,10 @@ static int get_hw_frfifo_queue_id(int rxnode, nlm_nae_config_ptr nae_cfg, int cp
 	qid = cpu_2_normal_frfifo[rxnode][node_cpu];
 	if (enable_jumbo)
 	{
-		if(truesize > NLM_RX_JUMBO_BUF_SIZE) 
+		if(truesize > NLM_RX_JUMBO_BUF_SIZE)
 			qid = cpu_2_jumbo_frfifo[rxnode][node_cpu];
 	}
-	/* all the nodes vfbtable should be filled with starting node of 0 to ending node 
+	/* all the nodes vfbtable should be filled with starting node of 0 to ending node
 	 with 20 entries each */
 	return nae_cfg->vfbtbl_hw_offset + (rxnode * NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE) + qid;
 }
@@ -596,7 +587,7 @@ static int mac_refill_frin_skb(int node, int cpu, uint64_t paddr, unsigned int b
 
 
 	qid = (bufsize >= NLM_RX_JUMBO_BUF_SIZE) ? cpu_2_jumbo_frfifo[node][node_cpu] : cpu_2_normal_frfifo[node][node_cpu];
-	
+
 	nae_cfg = nlm_node_cfg.nae_cfg[node];
 	if(nae_cfg == NULL) {
 		printk("%s Error, Invalid node id %d\n", __FUNCTION__, node);
@@ -630,8 +621,8 @@ static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu, unsigned
 
 	if (enable_jumbo)
 	{
-		if(truesize > NLM_RX_JUMBO_BUF_SIZE) 
-			buf_size = NLM_RX_JUMBO_BUF_SIZE; 
+		if(truesize > NLM_RX_JUMBO_BUF_SIZE)
+			buf_size = NLM_RX_JUMBO_BUF_SIZE;
 	}
 
 	skb = nlm_xlp_alloc_skb_atomic(buf_size, priv->node);
@@ -686,14 +677,14 @@ static int nae_proc_read(char *page, char **start, off_t off,
 	return len;
 }
 
-#ifdef IEEE_1588_PTP_ENABLED	
+#ifdef IEEE_1588_PTP_ENABLED
 static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb)
 {
 	struct skb_shared_hwtstamps shhwtstamps;
 	uint64_t regval;
 	uint64_t ns;
-	
-	
+
+
 	struct dev_data *priv = netdev_priv(skb->dev);
 	int if_num = priv->hw_port_id;
 	int node = priv->node;
@@ -707,9 +698,9 @@ static void nlm_1588_ptp_hwtstamp_tx(struct sk_buff *skb)
 	shhwtstamps.hwtstamp = ns_to_ktime(ns);
 	shhwtstamps.syststamp =	timecompare_transform(&priv->compare, ns);
 	skb_tstamp_tx(skb, &shhwtstamps);
-	Message("nlm_1588_ptp_hwtstamp_tx regval=0x%llx ns=0x%llx node=0x%x \n", regval, ns, node);	
+	Message("nlm_1588_ptp_hwtstamp_tx regval=0x%llx ns=0x%llx node=0x%x \n", regval, ns, node);
 }
-#endif 
+#endif
 
 static inline void process_tx_complete(int cpu, unsigned int src_id, unsigned long long msg0)
 {
@@ -746,12 +737,12 @@ static inline void process_tx_complete(int cpu, unsigned int src_id, unsigned lo
 
 	if(skb)
 	{
-#ifdef IEEE_1588_PTP_ENABLED	
-		if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE)) { 
+#ifdef IEEE_1588_PTP_ENABLED
+		if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE)) {
 			nlm_1588_ptp_hwtstamp_tx(skb);
 		}
 #endif
-		
+
 		dev_kfree_skb_any(skb);
 	}
 	else {
@@ -760,7 +751,7 @@ static inline void process_tx_complete(int cpu, unsigned int src_id, unsigned lo
 	}
 }
 
-static inline void process_rx_packets(int cpu, unsigned int src_id, 
+static inline void process_rx_packets(int cpu, unsigned int src_id,
 		unsigned long long msg0, unsigned long long msg1)
 {
 	uint64_t addr;
@@ -827,7 +818,7 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	priv = netdev_priv(pdev);
 
 	vaddr = (uint64_t)(unsigned long)bus_to_virt(addr);
-	
+
 	len = len  - ETH_FCS_LEN - PREPAD_LEN;
 
 	skb = mac_get_skb_back_ptr(vaddr);
@@ -865,7 +856,7 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 #ifdef MACSEC_DEBUG
 	printk("%s nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
 	__FUNCTION__, nae_cfg->sectag_offset[port], nae_cfg->sectag_len[port], nae_cfg->icv_len[port]);
-	dump_buffer(skb->data, len, "RX skb pkt:");		
+	dump_buffer(skb->data, len, "RX skb pkt:");
 	printk("msec_port = %x port = %d len = %d nae_cfg->msec_port_enable = %x\n",msec_port, port, len, nae_cfg->msec_port_enable);
 #endif
 	//if(1/*nae_cfg->msec_port_enable & msec_port*/)/* check if port is tx port is enabled for msec else bypass MACSec*/
@@ -873,14 +864,14 @@ static inline void process_rx_packets(int cpu, unsigned int src_id,
 	{
 		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
 
-		if((ether_type & 0xffff) == MACSEC_ETHER_TYPE)/*Enable MACSEc processing*/			
+		if((ether_type & 0xffff) == MACSEC_ETHER_TYPE)/*Enable MACSEc processing*/
 		{
 			memcpy((char*)(skb->data + MAC_HEADER_LEN + nae_cfg->sectag_len[port] - MAC_ADDR_LEN /*DST MAC LEN*/),(((char*)skb->data)+MAC_ADDR_LEN), MAC_ADDR_LEN);
 			memcpy((char*)(skb->data + MAC_HEADER_LEN + nae_cfg->sectag_len[port] - (MAC_ADDR_LEN * 2) /*SRC MAC LEN*/),((char*)skb->data), MAC_ADDR_LEN);
 			len = len - nae_cfg->sectag_len[port] - nae_cfg->icv_len[port];
 			skb_reserve(skb, nae_cfg->sectag_len[port]);
 #ifdef MACSEC_DEBUG
-			dump_buffer(skb->data, len, "RX mod skb pkt:");		
+			dump_buffer(skb->data, len, "RX mod skb pkt:");
 #endif
 		}
 	}
@@ -973,7 +964,7 @@ static void xlp_poll_upper(int cpu)
 	/* In non-exlusivevc , this vc can be shared with some other moduels */
 	if((nae_rx_vc == nae_fb_vc) || (!exclusive_vc))
 		return;
-	
+
 	while (1) {
 			msgrng_access_enable(mflags);
 			status = xlp_message_receive_1(nae_fb_vc, &src_id, &size, &code, &msg0);
@@ -983,7 +974,7 @@ static void xlp_poll_upper(int cpu)
 			__sync();
 
 			if(msg0 & (0x200000000000000ULL)) /*IEEE-1588 timestamp*/
-				return;				
+				return;
 
 			Message("poll upper cpu %d src_id %d size %d\n", cpu, src_id, size);
 			process_tx_complete(cpu, src_id, msg0);
@@ -1029,7 +1020,7 @@ static int xlp_poll_lower(int budget, int cpu)
 		else {
 			printk("%s , Error invalid message, size %d\n", __FUNCTION__, size);
 			continue;
-		}	
+		}
 	}
 #ifdef CONFIG_INET_LRO
 	if(enable_lro)
@@ -1062,7 +1053,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	}
 	else {
 		printk("%s , Error invalid message, vc %d size %d\n", __FUNCTION__, vc, size);
-	}	
+	}
 }
 
 /*
@@ -1114,7 +1105,7 @@ void nlm_spawn_kthread(void)
     char buf[20];
     static struct task_struct *task[NR_CPUS];
 
-    nr_cpus = nlm_node_cfg.num_nodes * NLM_NCPUS_PER_NODE;	
+    nr_cpus = nlm_node_cfg.num_nodes * NLM_NCPUS_PER_NODE;
     /*Spawn kthread*/
     for(i=0; i<nr_cpus; i++){
 	if(!cpu_isset(i, cpu_present_map))
@@ -1211,7 +1202,7 @@ static void nlm_xlp_nae_init(void)
 		enable_napi = 0;
 	}
 #endif
-	
+
 	for(i=0; i<NR_CPUS; i++)
 		nlm_mode[CPU_INDEX(i)] = perf_mode;
 
@@ -1230,7 +1221,7 @@ static void nlm_xlp_nae_init(void)
 	if (initialize_nae(phys_cpu_map, perf_mode, &enable_jumbo))
 		return;
 
-	maxnae = nlm_node_cfg.num_nodes;	
+	maxnae = nlm_node_cfg.num_nodes;
 	for(node = 0; node < maxnae; node++) {
 		nae_cfg = nlm_node_cfg.nae_cfg[node];
 		if (nae_cfg == NULL)
@@ -1309,7 +1300,7 @@ static void nlm_xlp_nae_init(void)
 				per_cpu_netdev[node][cpu][i] = dev;
 			}
 			printk("configuring PTP realted params\n");
-		
+
 			if(node==0)
 				 priv->cycles.read = nlm_1588_read_clock0;
 			if(node==1)
@@ -1320,23 +1311,23 @@ static void nlm_xlp_nae_init(void)
 				 priv->cycles.read = nlm_1588_read_clock3;
 
 			priv->cycles.mask = CLOCKSOURCE_MASK(64);
-			
+
 			if(is_nlm_xlp3xx() || is_nlm_xlp2xx())
 				priv->cycles.mult = 1000/XLP3XX_MAX_NAE_FREQUENCY; /*freq are in Mhz*/
 			else
 				priv->cycles.mult = 0x2; /*500 Mhz*/
-			
-			priv->cycles.shift = 0; 
-		
+
+			priv->cycles.shift = 0;
+
 			timecounter_init(&priv->clock, &priv->cycles, ktime_to_ns(ktime_get_real()));
-			
-			memset(&priv->compare, 0, sizeof(priv->compare)); 	 
+
+			memset(&priv->compare, 0, sizeof(priv->compare));
 			priv->compare.source = &priv->clock;
 			priv->compare.target = ktime_get_real;
 			priv->compare.num_samples = 0; /*we dont have a cyclecounter register so can't afford more samples */
 			timecompare_update(&priv->compare,0);
 		}
-		
+
 		nlm_hal_1588_ptp_clk_sel(node, NET_SYS_CLK);
 		nlm_hal_reset_1588_accum(node);
 		nlm_hal_1588_ld_user_val(node, 0, 0);
@@ -1530,7 +1521,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 #endif
 	uint32_t msec_port, send_msec = 0, msec_bypass = 0, pad_len, icv_len, param_index = 0;
 
-#ifdef MACSEC_DEBUF
+#ifdef MACSEC_DEBUG
 	printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
 	nae_cfg->sectag_offset[priv->port], nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
 #endif
@@ -1539,8 +1530,8 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	else
 		msec_port = 1 << priv->port;
 
-#ifdef MACSEC_DEBUF
-	dump_buffer(skb->data, skb->len, "Org skb pkt:");		
+#ifdef MACSEC_DEBUG
+	dump_buffer(skb->data, skb->len, "Org skb pkt:");
 	printk("msec_port = %x priv->port = %d priv->block = %d priv->index = %d skb->len = %d nae_cfg->msec_port_enable = %x\n",
 	msec_port, priv->port, priv->block, priv->index, skb->len, nae_cfg->msec_port_enable);
 #endif
@@ -1549,11 +1540,11 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	{
 		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
 
-#ifdef MACSEC_DEBUF
+#ifdef MACSEC_DEBUG
 	printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
 #endif
-		//if(1/*(ether_type & 0xffff) == PROTOCOL_TYPE_IP*/)/*Enable MACSEc processing*/			
-		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/			
+		//if(1/*(ether_type & 0xffff) == PROTOCOL_TYPE_IP*/)/*Enable MACSEc processing*/
+		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/
 		{
 			send_msec = 1;
 			param_index = (priv->port)?priv->port:1;/* it should be between 1 -7 */
@@ -1561,13 +1552,13 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 			pad_len =  nae_cfg->sectag_offset[priv->port] + nae_cfg->sectag_len[priv->port]; //12 + 8;
 			icv_len = nae_cfg->icv_len[priv->port];
 
-#ifdef MACSEC_DEBUF
+#ifdef MACSEC_DEBUG
 	printk("pad_len = %d icv_len = %d ether_type = %x\n", pad_len, icv_len, ether_type);
 #endif
 		}
 		else
 			msec_bypass = 1;
-		
+
 	}
 
 	p2pdesc = alloc_p2p_desc_mem(cpu);
@@ -1631,17 +1622,17 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	if(((len = skb_headlen(skb)) != 0)) {
 		if(send_msec)
 		{
-			memcpy((char*)&p2pdesc[P2P_SKB_OFF-8], skb->data, MAC_HEADER_LEN);		
+			memcpy((char*)&p2pdesc[P2P_SKB_OFF-8], skb->data, MAC_HEADER_LEN);
 			idx = create_p2p_desc(virt_to_bus((char *)&p2pdesc[P2P_SKB_OFF-8]), pad_len, p2pdesc, idx);
 
 			idx = create_p2p_desc(virt_to_bus((((char *)skb->data)+ MAC_HEADER_LEN)), (len - MAC_HEADER_LEN), p2pdesc, idx);
-#ifdef MACSEC_DEBUF
-			dump_buffer((char *)&p2pdesc[P2P_SKB_OFF-8], pad_len, "first_seg:");		
+#ifdef MACSEC_DEBUG
+			dump_buffer((char *)&p2pdesc[P2P_SKB_OFF-8], pad_len, "first_seg:");
 			printk(" len = %d pad_len = %d icv_len = %d param_index = %d\n", len, pad_len, icv_len, param_index);
 #endif
 		}
 		else
-#ifdef IEEE_1588_PTP_ENABLED	
+#ifdef IEEE_1588_PTP_ENABLED
 		if(!is_skbts)
 #endif
 			idx = create_p2p_desc(virt_to_bus((char *)skb->data), len, p2pdesc, idx);
@@ -1675,7 +1666,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 		create_last_p2p_desc(p2pdesc, skb, idx);
 		msg = nae_tx_desc(P2P, 0, qid, idx, virt_to_bus(p2pdesc));
 	}
-	
+
 
 	tso_dbg("msg0 %llx p2pdesc0 %llx p2pdesc1 %llx p2pdesc2 %llx idx %d\n",
 			msg, p2pdesc[0], p2pdesc[1], p2pdesc[2], idx);
@@ -1687,10 +1678,10 @@ retry_send:
 		ret = nlm_hal_send_msg3(priv->nae_tx_qid, 0, mscmsg0, mscmsg1, msg);
 	else if(skb->ip_summed == CHECKSUM_PARTIAL)
 		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, mscmsg0, msg);
-#ifdef IEEE_1588_PTP_ENABLED	
+#ifdef IEEE_1588_PTP_ENABLED
 	else if(is_skbts){
-		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg, msg1);	
-	} 
+		ret = nlm_hal_send_msg2(priv->nae_tx_qid, 0, msg, msg1);
+	}
 #endif
 	else if(send_msec || msec_bypass)
 	{
@@ -1739,7 +1730,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	volatile int hw_repl = 0;
 	int  offset, qid;
 	unsigned long __attribute__ ((unused)) mflags;
-#ifdef IEEE_1588_PTP_ENABLED	
+#ifdef IEEE_1588_PTP_ENABLED
 	union skb_shared_tx *shtx;
 #endif
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[priv->node];
@@ -1754,14 +1745,14 @@ printk("size of skb end = %llx head = %llx\n", (unsigned long)skb->end, (unsigne
 	else
 		msec_port = 1 << priv->port;
 
-dump_buffer(skb->data, skb->len, "Org skb pkt:");		
+dump_buffer(skb->data, skb->len, "Org skb pkt:");
 printk("msec_port = %x priv->port = %d priv->block = %d priv->index = %d skb->len = %d nae_cfg->msec_port_enable = %x\n",msec_port, priv->port, priv->block, priv->index, skb->len, nae_cfg->msec_port_enable);
 	if(1/*nae_cfg->msec_port_enable & msec_port*/)/* check if port is tx port is enabled for msec else bypass MACSec*/
 	{
 		short ether_type = *(short*)(((char*)skb->data) + MAC_HEADER_LEN);
 
 printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
-		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/			
+		if((ether_type & 0xffff) == PROTOCOL_TYPE_IP)/*Enable MACSEc processing*/
 		{
 			send_msec = 1;
 		/*	msec_pad_mem = (unsigned char*)cacheline_aligned_kmalloc(MAC_SEC_PADDING, GFP_KERNEL);
@@ -1771,14 +1762,14 @@ printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
 			pad_len = 12 + 8;
 			icv_len = nae_cfg->icv_len[priv->port];
 
-			memcpy(msec_pad_mem, skb->data, MAC_HEADER_LEN);		
+			memcpy(msec_pad_mem, skb->data, MAC_HEADER_LEN);
 			//skb_reserve(skb, MAC_HEADER_LEN);
 			//skb_push(skb, nae_cfg->sectag_offset[priv->port]);
 printk("skb->len = %d ether_type = %x\n", skb->len, ether_type);
-dump_buffer(msec_pad_mem, pad_len, "first_seg:");		
+dump_buffer(msec_pad_mem, pad_len, "first_seg:");
 		}
 //		skb->len +=  nae_cfg->icv_len[priv->port];
-		
+
 	}
 #endif
 
@@ -1817,7 +1808,7 @@ dump_buffer(msec_pad_mem, pad_len, "first_seg:");
 
 		fast_replenish_count[CPU_INDEX(cpu)]++;
 	}
-	else 
+	else
 #endif
 	{
 		qid = nae_cfg->vfbtbl_sw_offset + (cpu % NLM_NCPUS_PER_NODE);
@@ -1825,13 +1816,13 @@ dump_buffer(msec_pad_mem, pad_len, "first_seg:");
 
 		Message("Tx, tx complete to cpu, cpu %d len %d qid %d\n", cpu, skb->len, qid);
 	}
-	
+
 #ifdef IEEE_1588_PTP_ENABLED
 	if(skb->sk && sock_flag(skb->sk, SOCK_TIMESTAMPING_TX_HARDWARE)) {
 		msg1 = nae_tx_desc (P2D_EOP, 0, 126, skb->len, virt_to_bus((char *)skb->data));
 		shtx = skb_tx(skb);
 		shtx->in_progress = 1;
-		
+
 	}
 	else
 #endif
-- 
1.7.1

