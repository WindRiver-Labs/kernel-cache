From 09efc2e4e75e365851d8eb6bef1ee3c5f0ae0fe0 Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Sat, 7 Dec 2013 15:20:38 +0530
Subject: MIPS: Netlogic: Add KGDB support for XLP

Add KGDB code
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
index 3354f1e..7df21bf 100644
--- a/arch/mips/include/asm/netlogic/interrupt.h
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -42,5 +42,6 @@
 #define IRQ_FMN			5
 #define IRQ_PERF		6
 #define IRQ_TIMER		7
+#define IRQ_IPI_SMP_KGDB        9
 
 #endif
diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h
index 9199971..f0f0d8f 100644
--- a/arch/mips/include/asm/smp.h
+++ b/arch/mips/include/asm/smp.h
@@ -44,6 +44,8 @@ extern int __cpu_logical_map[NR_CPUS];
 /* Used by kexec crashdump to save all cpu's state */
 #define SMP_DUMP		0x8
 
+#define SMP_CALL_KGDB_HOOK      0x10
+
 extern volatile cpumask_t cpu_callin_map;
 
 extern void asmlinkage smp_bootstrap(void);
diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index fcaac2f..f6f3b1c 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -33,6 +33,13 @@
 #include <asm/processor.h>
 #include <asm/sigcontext.h>
 
+#ifdef CONFIG_CPU_XLP
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/interrupt.h>
+DEFINE_SPINLOCK(nlm_kgdb_lock);
+#endif
+
 static struct hard_trap_info {
 	unsigned char tt;	/* Trap type code for MIPS R3xxx and R4xxx */
 	unsigned char signo;	/* Signal that we map this trap into */
@@ -206,16 +213,64 @@ void arch_kgdb_breakpoint(void)
 		".set\treorder");
 }
 
+
+#ifdef CONFIG_CPU_XLP
+void nlm_kgdb_smp_hook(void)
+{
+        int i;
+        int cpu = smp_processor_id();
+        int cpus = num_online_cpus() - 1;
+        unsigned long flags;
+        extern struct plat_smp_ops *mp_ops;
+
+        BUG_ON(!cpu_online(cpu));
+
+        if (!cpus)
+                return;
+
+        spin_lock_irqsave(&nlm_kgdb_lock, flags);
+        for (i = 0; i < NR_CPUS; i++)
+                if (cpu_online(i) && i != cpu)
+                        mp_ops->send_ipi_single(i, SMP_CALL_KGDB_HOOK);
+        spin_unlock_irqrestore(&nlm_kgdb_lock, flags);
+}
+
+void nlm_kgdb_call_nmi_hook(unsigned int irq, struct pt_regs *regs)
+{
+        /* In addition to the nmi exception, eirr is also
+         * set for IRQ_IPI_SMP_KGDB. when the interrupts
+         * are enabled back after nmi exception handler, interrupt
+         * is raised for IRQ_IPI_SMP_KGDB but there is no handler
+         * registered for the same resulting in a NULL pointer access.
+         *
+         * clearing IRQ_IPI_SMP_KGDBC in eirr hereitself
+         * so as to avoid raising an interrupt unnecessarily
+         * where we aren't going to do anything there but just return.
+         *
+         * */
+
+        ack_c0_eirr(1ULL << IRQ_IPI_SMP_KGDB);
+        kgdb_nmicallback(raw_smp_processor_id(), regs);
+}
+#else
 static void kgdb_call_nmi_hook(void *ignored)
 {
 	kgdb_nmicallback(raw_smp_processor_id(), NULL);
 }
+#endif
+
 
 void kgdb_roundup_cpus(unsigned long flags)
 {
+#ifdef CONFIG_CPU_XLP
+        nlm_kgdb_smp_hook();
+        return;
+#else
 	local_irq_enable();
 	smp_call_function(kgdb_call_nmi_hook, NULL, 0);
 	local_irq_disable();
+#endif
+
 }
 
 static int compute_signal(int tt)
@@ -266,6 +321,10 @@ void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
 	*(ptr++) = regs->cp0_cause;
 	*(ptr++) = regs->cp0_epc;
 }
+#ifdef CONFIG_CPU_XLP
+extern void nlm_flush_l1_icache(void);
+extern void nlm_except_vec_nmi(void);
+#endif
 
 void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
 {
@@ -307,8 +366,12 @@ static int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,
 			regs->cp0_epc += 4;
 
 	/* In SMP mode, __flush_cache_all does IPI */
+#ifdef CONFIG_CPU_XLP
+        nlm_flush_l1_icache();
+#else
 	local_irq_enable();
 	__flush_cache_all();
+#endif 
 
 	return NOTIFY_STOP;
 }
@@ -376,6 +439,9 @@ int kgdb_arch_init(void)
 	};
 	memcpy(arch_kgdb_ops.gdb_bpt_instr, insn.byte, BREAK_INSTR_SIZE);
 
+#ifdef CONFIG_CPU_XLP
+        nlm_set_nmi_handler(nlm_except_vec_nmi);        
+#endif
 	register_die_notifier(&kgdb_notifier);
 
 	return 0;
diff --git a/arch/mips/mm/c-netlogic.c b/arch/mips/mm/c-netlogic.c
index b83516d..ab3f34f 100644
--- a/arch/mips/mm/c-netlogic.c
+++ b/arch/mips/mm/c-netlogic.c
@@ -93,7 +93,11 @@ static inline void cacheop_sync_istream(void)
 
 static int icache_size, dcache_size;
 
+#ifdef CONFIG_KGDB
+void nlm_flush_l1_icache(void)
+#else
 static inline void nlm_flush_l1_icache(void)
+#endif
 {
 	blast_icache32();
 	cacheop_sync_istream();
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 0395711..4799c7a 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -69,7 +69,8 @@
 
 #ifdef CONFIG_SMP
 #define SMP_IRQ_MASK	((1ULL << IRQ_IPI_SMP_FUNCTION) | \
-				 (1ULL << IRQ_IPI_SMP_RESCHEDULE))
+				 (1ULL << IRQ_IPI_SMP_RESCHEDULE) | \
+                                  (1ULL << IRQ_IPI_SMP_KGDB))
 #else
 #define SMP_IRQ_MASK	0
 #endif
@@ -178,6 +179,8 @@ static void __init nlm_init_percpu_irqs(void)
 			 nlm_smp_function_ipi_handler);
 	irq_set_chip_and_handler(IRQ_IPI_SMP_RESCHEDULE, &nlm_cpu_intr,
 			 nlm_smp_resched_ipi_handler);
+	irq_set_chip_and_handler(IRQ_IPI_SMP_KGDB, &nlm_cpu_intr,
+			 nlm_smp_function_ipi_handler);
 #endif
 }
 
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index f5c32d4..9a77130 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -70,6 +70,8 @@ void nlm_send_ipi_single(int logical_cpu, unsigned int action)
 		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_FUNCTION, 0);
 	if (action & SMP_RESCHEDULE_YOURSELF)
 		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_RESCHEDULE, 0);
+	if (action & SMP_CALL_KGDB_HOOK)
+		nlm_pic_send_ipi(picbase, cpu, IRQ_IPI_SMP_KGDB, 1);
 }
 
 void nlm_send_ipi_mask(const struct cpumask *mask, unsigned int action)
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 690f755..97d1af2 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -9,3 +9,4 @@ obj-$(subst m,y,$(CONFIG_SATA_AHCI))	+= ahci-init-xlp2.o
 obj-$(CONFIG_NUMA)		+= numa.o
 obj-$(CONFIG_NLM_FASTSYSCALL)	+= fastsyscall.o
 obj-$(CONFIG_NLM_ENABLE_COP2)	+= cop2.o
+obj-$(CONFIG_KGDB)		+= nmi.o
diff --git a/arch/mips/netlogic/xlp/nmi.S b/arch/mips/netlogic/xlp/nmi.S
new file mode 100644
index 0000000..1c3c190
--- /dev/null
+++ b/arch/mips/netlogic/xlp/nmi.S
@@ -0,0 +1,106 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/init.h>
+
+#include <asm/asm.h>
+#include <asm/asmmacro.h>
+#include <asm/cacheops.h>
+#include <asm/irqflags.h>
+#include <asm/regdef.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/war.h>
+#include <asm/netlogic/interrupt.h>
+
+#define OS_KGDB_SCRATCH_REG6    $22, 6
+#define OS_KGDB_SCRATCH_REG7    $22, 7
+
+
+
+NESTED(nlm_except_vec_nmi, 0, sp)
+	.set push
+	.set noat
+	.set mips64
+	.set noreorder
+	sll 	zero, 3              # ehb
+#ifdef CONFIG_KGDB
+	MTC0	k0, OS_KGDB_SCRATCH_REG6
+	nop
+	nop
+	PTR_LA	k0, nlm_nmi_kgdb_handler
+	jr       k0
+	nop
+#else
+1:	wait
+	b	1b
+	nop
+#endif
+	.set pop
+END(nlm_except_vec_nmi)
+
+#ifdef CONFIG_KGDB
+NESTED(nlm_nmi_kgdb_handler, PT_SIZE,  sp)
+	.set	push
+	.set	noat
+	.set noreorder
+	.set 	mips64
+
+	/* Save K0 and K1 first */
+	/* K0 is already saved in nlm_except_vec_nmi */
+	MTC0	k1, OS_KGDB_SCRATCH_REG7
+
+	/* Clear the  NMI and BEV bits */
+	MFC0	k0, CP0_STATUS
+	li 	k1, 0xffb7ffff
+	and	k0, k0, k1
+	MTC0	k0, CP0_STATUS
+
+	SAVE_ALL
+	CLI
+	TRACE_IRQS_OFF
+
+	li	a0, IRQ_IPI_SMP_KGDB
+	move	a1, sp
+
+	jal	nlm_kgdb_call_nmi_hook
+	nop
+
+	RESTORE_ALL
+
+	MFC0	k0, OS_KGDB_SCRATCH_REG6
+	MFC0	k1, OS_KGDB_SCRATCH_REG7
+
+	.set mips3
+	eret
+
+	.set pop
+END(nlm_nmi_kgdb_handler)
+#endif
-- 
1.7.1

