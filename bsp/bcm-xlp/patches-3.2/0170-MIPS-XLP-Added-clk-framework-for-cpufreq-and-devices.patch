From f80c83b47db79be4514f37bcc37e0f271ebad037 Mon Sep 17 00:00:00 2001
From: Prem Mallappa <pmallapp@broadcom.com>
Date: Tue, 30 Sep 2014 11:09:57 +0530
Subject: MIPS: XLP: Added clk framework for cpufreq and devices.

Add clock framework and cpu frequency driver for XLP series
processors

Signed-off-by: Prem Mallappa <pmallapp@broadcom.com>
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index c07f843..c3db014 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -818,6 +818,7 @@ config NLM_XLP_BOARD
 	select NLM_COMMON
 	select SYS_HAS_CPU_XLP
 	select SYS_SUPPORTS_SMP
+	select MIPS_EXTERNAL_TIMER
 	select HW_HAS_PCI
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
@@ -839,6 +840,8 @@ config NLM_XLP_BOARD
 	select USE_OF
 	select SYS_SUPPORTS_ZBOOT
 	select SYS_SUPPORTS_ZBOOT_UART16550
+	select HAVE_CLK
+	select CLKDEV_LOOKUP
 	help
 	  This board is based on Netlogic XLP Processor.
 	  Say Y here if you have a XLP based board.
@@ -1499,6 +1502,7 @@ config CPU_XLP
 	select CPU_HAS_PREFETCH
 	select CPU_MIPSR2
 	select CPU_SUPPORTS_HUGEPAGES
+	select COMMON_CLK
 	help
 	  Netlogic Microsystems XLP processors.
 endchoice
@@ -1653,6 +1657,7 @@ config SYS_HAS_CPU_XLR
 	bool
 
 config SYS_HAS_CPU_XLP
+	select CPU_SUPPORTS_CPUFREQ
 	bool
 
 #
diff --git a/arch/mips/include/asm/netlogic/clk.h b/arch/mips/include/asm/netlogic/clk.h
new file mode 100644
index 0000000..2fda120
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/clk.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __XLP_CLK_H__
+#define __XLP_CLK_H__
+
+/* DFS clock values */
+#define CLK_1KHZ                1000
+#define CLK_1MHZ                (CLK_1KHZ * 1000)
+#define CLK_KHZ(x)		((x) * 1000UL)
+#define CLK_MHZ(x)		(CLK_KHZ(x) * 1000UL)
+
+#define CLK_400MHZ		CLK_MHZ(400)
+#define CLK_100MHZ		CLK_MHZ(100)
+
+#define XLP_REF_CLK_NAME	"refclk"
+
+#define XLP_CLK_DEV_PIC_CLK_NAME	"pic-clk"
+#define XLP_CLK_DEV_DTRE_CLK_NAME	"dtre-clk"
+#define XLP_CLK_DEV_CMP_CLK_NAME	"cmp-clk"
+#define XLP_CLK_DEV_REGXF_CLK_NAME	"regxf-clk"
+#define XLP_CLK_DEV_REGXS_CLK_NAME	"regxs-clk"
+#define XLP_CLK_DEV_SEC_CLK_NAME	"sec-clk"
+#define XLP_CLK_DEV_RSA_CLK_NAME	"rsa-clk"
+#define XLP_CLK_DEV_NET_CLK_NAME	"net-clk"
+#define XLP_CLK_DEV_SATA_CLK_NAME	"sata-clk"
+#define XLP_CLK_DEV_KBP_CLK_NAME	"kbp-clk"
+#define XLP_CLK_DEV_USB_CLK_NAME	"usb-clk"
+#define XLP_CLK_DEV_GIO_CLK_NAME	"gio-clk"
+#define XLP_CLK_DEV_GBU_CLK_NAME	"gbu-clk"
+#define XLP_CLK_DEV_MMC_CLK_NAME	"mmc-clk"
+#define XLP_CLK_DEV_NAND_CLK_NAME	"nand-clk"
+#define XLP_CLK_DEV_LZS_CLK_NAME	"lzs-clk"
+#define XLP_CLK_DEV_GDX_CLK_NAME	"gdx-clk"
+#define XLP_CLK_DEV_DMC_CLK_NAME	"dmc-clk"
+
+#define XLPII_SOC_DEV_LZS		15
+#define XLPII_SOC_DEV_NAND		14
+#define XLPII_SOC_DEV_MMC		13
+#define XLPII_SOC_DEV_GBU		12
+#define XLPII_SOC_DEV_GIO		11
+#define XLPII_SOC_DEV_USB		10
+#define XLPII_SOC_DEV_KBP		9
+#define XLPII_SOC_DEV_SATA		8
+#define XLPII_SOC_DEV_NET		7
+#define XLPII_SOC_DEV_RSA		6
+#define XLPII_SOC_DEV_SEC		5
+#define XLPII_SOC_DEV_REGEX_SLOW	4
+#define XLPII_SOC_DEV_REGEX_FAST	3
+#define XLPII_SOC_DEV_CMP		2
+#define XLPII_SOC_DEV_DTRE		1
+#define XLPII_SOC_DEV_PIC		0
+
+#define XLP2XX_SOC_DEV_PIC	11
+#define XLP2XX_SOC_DEV_USB	10
+#define XLP2XX_SOC_DEV_REGEX_SLOW	9
+#define XLP2XX_SOC_DEV_REGEX_FAST	8
+#define XLP2XX_SOC_DEV_GBU	7
+#define XLP2XX_SOC_DEV_MMC	6
+#define XLP2XX_SOC_DEV_NAND	5
+#define XLP2XX_SOC_DEV_CMP	4
+#define XLP2XX_SOC_DEV_GDXd	3
+#define XLP2XX_SOC_DEV_RSA	2
+#define XLP2XX_SOC_DEV_SEC	1
+#define XLP2XX_SOC_DEV_NET	0
+
+#define XLP_SOC_DEV_CORE	10
+#define XLP_SOC_DEV_GBU		9
+#define XLP_SOC_DEV_MMC		8
+#define XLP_SOC_DEV_NAND	7
+#define XLP_SOC_DEV_DMC		6
+#define XLP_SOC_DEV_KBP		5
+#define XLP_SOC_DEV_CMP		4
+#define XLP_SOC_DEV_DTRE	3
+#define XLP_SOC_DEV_RSA		2
+#define XLP_SOC_DEV_SEC		1
+#define XLP_SOC_DEV_NET		0
+
+#define XLP2XX_CLOCK_FUNC_OFFSET        (0x0 << 12)
+/* XLP 2XX clock registers */
+#define XLP2XX_CLK_CPUPLLCHGCTRL        0x288
+#define XLP2XX_CLK_CPUPLLCTRL0          0x1c0
+#define XLP2XX_CLK_CPUPLLCTRL1          0x1c1
+#define XLP2XX_CLK_CPUPLLCTRL2          0x1c2
+
+#define XLP9XX_CLOCK_FUNC_OFFSET        (0x2 << 12)
+/* XLP 9XX clock registers */
+#define XLP9XX_CLK_CPUPLLCHGCTRL        0x188
+#define XLP9XX_CLK_CPUPLLCTRL0          0xC0
+#define XLP9XX_CLK_CPUPLLCTRL1          0xC1
+#define XLP9XX_CLK_CPUPLLCTRL2          0xC2
+
+#define XLP8XX_CLOCK_FUNC_OFFSET        (0x5 << 12)
+
+#endif	/* __XLP_CLK_H__ */
diff --git a/arch/mips/include/asm/netlogic/regulator.h b/arch/mips/include/asm/netlogic/regulator.h
new file mode 100644
index 0000000..8dee4ea
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/regulator.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __REGULATOR_XLP
+#define __REGULATOR_XLP
+
+#define XLP9XX_SFUSE_FUNC_OFFSET        (0x1 << 12)
+#define XLP9XX_POWER_FUNC_OFFSET        (0x3 << 12)
+
+/*
+ * XLP8XX/XLP2XX,
+ * VDD = 1.6125 - (vid * 0x00625)
+ * for vid=0x72, VDD=0.9V
+ */
+#define	XLP_VOLTAGE_STEP	6250	/* 0.00625 V */
+#define	XLP_VOLTAGE_MIN		775000	/* 0.5 - 0.9 V */
+#define	XLP_VOLTAGE_MAX		1050000 /* 1.05 V */
+#define	XLP_VOLTAGE_MAX_LMT	1612500 /* 1.61250 */
+
+#define XLP_VID_START		0x72 /* 0.9 V, reset Value */
+#define XLP_VID_END		0x42 /* 0x42 to 0x0 are rounded to 0x42 */
+
+#define XLP_VOLTAGE_TABLE_SZ						\
+ 	((XLP_VOLTAGE_MAX - XLP_VOLTAGE_MIN) / XLP_VOLTAGE_STEP + 1)
+
+
+/*
+ * XLP9XX/XLP5XX
+ */
+#define XLPII_VOLTAGE_START	250000	/* 0.2500 V */
+#define XLPII_VOLTAGE_END	1000000 /* 1 V */
+#define XLPII_VOLTAGE_STEP	5000
+
+#define XLPII_VID_START		0x1
+#define XLPII_VID_END		0x98
+
+#define XLPII_VOLTAGE_TABLE_SZ						\
+  	((XLPII_VOLTAGE_END - XLPII_VOLTAGE_START) / XLPII_VOLTAGE_STEP + 1)
+
+/* MININUM micro voltage corresponds to 400MHZ */
+#define XLP_MIN_MICVOLTAGE		775000
+#define XLP_MICVOLTAGE_OPRANGE		6250
+#define XLP9XX_MICVOLTAGE_OPRANGE	5000
+
+
+#define TI_VRM1_ADDR	0x60
+#define TI_VRM2_ADDR	0x61
+#define IS_VRM1_ADDR	0x70
+#define IS_VRM2_ADDR	0x74
+
+/* TI commands */
+#define CMDSET_TI_VRM_VID 0x21
+#define CMDGET_TI_VRM_VID 0x21
+/* 0x8B: actual vid; 0xD4:vout	*/
+#define CMDCTR_TI_VRM_VID 0xD2
+
+/* Intersil commands */
+#define CMDGET_IS_VRM_VID 0xDA
+#define CMDCTR_IS_VRM_VID 0xD6
+#define CMDSET_IS_VRM_VID 0xDA
+
+/* PMBUS registers taken from drivers/hwmon/pmbus/pmbus.h */
+
+#define PWR_PWRINTSTATUS_REG                  0x59
+
+#define PWR_PMBUSCMD_REG                      0xdb
+#define PWR_PMBUSDATA_REG                     0xdd
+#define PWR_PMBUSPEC_REG                      0xdc
+#define FUSE_DEVICECFG3_REG                   0xc3
+
+#endif /* __REGULATOR_XLP__ */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/sys.h b/arch/mips/include/asm/netlogic/xlp-hal/sys.h
index 6bcf395..2b137d1 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/sys.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/sys.h
@@ -116,6 +116,13 @@
 #define SYS_SCRTCH1				0x4a
 #define SYS_SCRTCH2				0x4b
 #define SYS_SCRTCH3				0x4c
+#define SYS_CLK_RST_CTRL			0x4f
+#define SYS_CLK_BYPASS				0x50
+#define SYS_CLK_PHS_CTRL			0x51
+#define SYS_CLK_DIV_INC				0x52
+#define SYS_CLK_DIV_DEC				0x53
+#define SYS_CLK_DIV 				0x54
+
 
 /* PLL registers XLP2XX */
 #define SYS_CPU_PLL_CTRL0(core)			(0x1c0 + (core * 4))
@@ -203,6 +210,9 @@
 #define nlm_get_fuse_regbase(node)	\
 			(nlm_get_fuse_pcibase(node) + XLP_IO_PCI_HDRSZ)
 
+/* XLP9XX Clock */
+#define nlm_read_clock_reg(b, r)	nlm_read_reg(b, r)
+#define nlm_write_clock_reg(b, r, v)	nlm_write_reg(b, r, v)
 #define nlm_get_clock_pcibase(node)	\
 			nlm_pcicfg_base(XLP9XX_IO_CLOCK_OFFSET(node))
 #define nlm_get_clock_regbase(node)	\
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 97c8f24..9afd135 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -82,6 +82,11 @@
 #define PIC_IRT_FIRST_IRQ		PIC_IRQ_BASE
 #define PIC_IRT_LAST_IRQ		63
 
+#define XLP_MAKE_CORE_CLK_NAME(buf, len, c, t)	\
+	snprintf((buf), (len), "%d-t%d",	\
+		 (c), (t))
+
+
 #ifndef __ASSEMBLY__
 #include <linux/cpumask.h>
 
@@ -104,6 +109,7 @@ static inline void xlp_numa_init(void) {}
 /* Device tree related */
 void *xlp_dt_init(void *fdtp);
 int xlp_dt_get_cpumask(cpumask_t *mask);
+unsigned int nlm_get_core_frequency(int node, int core);
 
 /* XLP CPU types */
 static inline int cpu_is_xlpii(void)
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 324347c..d25881b 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -3,5 +3,6 @@ obj-y				+= nlm-dma.o
 obj-y				+= reset.o
 obj-y				+= memory.o
 obj-y				+= io.o
+obj-y				+= clk.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_EARLY_PRINTK)	+= earlycons.o
diff --git a/arch/mips/netlogic/common/clk.c b/arch/mips/netlogic/common/clk.c
new file mode 100644
index 0000000..777837a
--- /dev/null
+++ b/arch/mips/netlogic/common/clk.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright (c) 2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * Author: Prem Mallappa <pmallappa@broadcom.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/netlogic/clk.h>
+
+#define XLP_CPU_PLL_CLK_NAME	"cpupll"
+
+#define XLP_CPU_CLK_SPEED	133333333UL
+
+#define XLP_CLK_DEBUG 1
+
+#define PLL_CORE_FREQ(div)					\
+	(CLK_400MHZ + ((unsigned long)(div) * CLK_100MHZ) / 3)
+
+static inline int xlp_cpu_to_node(int cpu)
+{
+	return nlm_cpuid_to_node(cpu_logical_map(cpu));
+}
+
+static inline int xlp_cpu_to_core(int cpu)
+{
+	int cpumap = cpu_logical_map(cpu);
+
+	return (cpumap / NLM_THREADS_PER_CORE) % nlm_cores_per_node();
+}
+
+struct clk_xlp {
+	struct clk_hw	hw;
+	uint8_t		cpuid;		/* SMP processor id */
+	uint8_t		coreid;
+	uint8_t		threadid;
+	uint8_t		nodeid;
+	uint32_t	rate;	/* in KHz */
+};
+
+#define to_clk_xlp(_hw) container_of(_hw, struct clk_xlp, hw)
+
+#define NR_XLP_DIV_TBL_ENTRIES 32
+
+struct clk_xlp_div_table {
+	unsigned long freq;
+	uint8_t div;
+	uint8_t mul;
+};
+
+static struct clk_xlp_div_table *clk_table;
+
+static int nlm_pll_div_table[] = {1, 2, 1, 4, 1, 1, 16, 8};
+
+static inline unsigned int __xlp_sys_read_reg(int nodeid, int reg)
+{
+	uint64_t sysbase = nlm_get_clock_regbase(nodeid);
+	return nlm_read_sys_reg(sysbase, reg);
+}
+
+static inline void __xlp_sys_write_reg(int nodeid, int reg,
+				       unsigned int val)
+{
+	uint64_t sysbase = nlm_get_clock_regbase(nodeid);
+	return nlm_write_sys_reg(sysbase, reg, val);
+}
+
+static int xlp_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+			    unsigned long prate)
+{
+	struct clk_xlp *cxlp = to_clk_xlp(hw);
+	u64 sysbase = nlm_get_node(cxlp->nodeid)->sysbase;
+	unsigned int count = 64; /* Safe termination of loop */
+
+	/* There is no direct way to scale the freqency, only option
+	   is to increment or decrement current freq */
+	if (cxlp->rate < rate) {
+		while (count-- &&
+		       (nlm_get_core_frequency(cxlp->nodeid, cxlp->cpuid) < rate))
+			nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIV_DEC_CTRL,
+					  1 << cxlp->coreid);
+			mdelay(10);
+	} else {
+		while (count-- &&
+		       (nlm_get_core_frequency(cxlp->nodeid, cxlp->cpuid) > rate))
+			nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIV_INC_CTRL,
+					  1 << cxlp->coreid);
+		mdelay(10);
+	}
+
+	cxlp->rate = nlm_get_core_frequency(cxlp->nodeid, cxlp->cpuid);
+
+	if (!count) {
+		pr_warn("Timedout while trying to set the freq\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * CPU_PLL_CTRL1(core)
+ * Freq (in Hz) = 400MHz + (33.333 * div[5:0])
+ */
+static int xlpii_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long prate)
+{
+	struct clk_xlp *cxlp = to_clk_xlp(hw);
+	int ctrl1, chg_ctrl, node = cxlp->nodeid;
+	uint32_t timeout = 1000000, div, core = 0;
+	u64 sysbase = nlm_get_node(cxlp->nodeid)->sysbase;
+	int64_t  nfreq;
+
+	ctrl1 = cpu_is_xlp9xx()? SYS_9XX_CPU_PLL_CTRL1(core) : SYS_CPU_PLL_CTRL1(core) ;
+	chg_ctrl = cpu_is_xlp9xx()? SYS_9XX_CPU_PLL_CHG_CTRL : SYS_CPU_PLL_CHG_CTRL ;
+
+	nfreq = rate - CLK_400MHZ; /* Convert to HZ */
+	div = ((unsigned long)(nfreq * 3) / CLK_100MHZ); /* Convert to MHz */
+
+	if (cpu_is_xlp9xx()) {
+		__xlp_sys_write_reg(node, ctrl1, div);
+		__xlp_sys_write_reg(node, chg_ctrl, (0x1 << core));
+
+		while (timeout-- &&
+		       ! (__xlp_sys_read_reg(node, chg_ctrl) & BIT(core))) {}
+
+	} else {
+		nlm_write_sys_reg(sysbase, ctrl1, div);
+		nlm_write_sys_reg(sysbase, chg_ctrl, (0x1 << core));
+
+		while (timeout-- &&
+		       ! (nlm_read_sys_reg(sysbase, chg_ctrl) & BIT(core))) {}
+	}
+
+	if (timeout == 0 ||
+	    (nlm_get_core_frequency(node, cxlp->coreid) != rate))
+		return -1;
+
+	return 0;
+}
+
+static int __xlp_clk_find_index(struct clk_xlp *cxlp, unsigned long rate)
+{
+	int i;
+	for (i = 0; clk_table[i].freq != 0; i++)
+		if (rate == clk_table[i].freq)
+			return i;
+	return -1;
+}
+
+
+static int __xlp_clk_find_nearest(struct clk_xlp *cxlp, unsigned long rate)
+{
+	int i, closest_idx = 0;
+
+	for (i = 0; clk_table[i].freq != 0; i++) {
+		if (!closest_idx || abs(rate - clk_table[i].freq) <
+		    abs(clk_table[closest_idx].freq - rate))
+			closest_idx = i;
+	}
+
+	return closest_idx;
+}
+
+/*
+ * @min: frequency minimum in Hz
+ * @max: frequency maximum in Hz
+ * @table: Table to fill with range of frequencies
+ * @rate: Rate at which each entry differs in Hz
+ */
+static void __init
+build_xlpii_freq_table(unsigned long min, unsigned long max,
+		       struct clk_xlp_div_table *table, int table_sz,
+		       unsigned int rate)
+{
+	int i;
+	for (i = 0; i < table_sz && min <= max; min += rate, i++) {
+		table[i].freq = min;
+		table[i].div = ((min * 3)/CLK_100MHZ) & 0x1f;
+	}
+}
+#if 1
+static void __init
+build_xlp_freq_table(unsigned long min, unsigned long max,
+		     struct clk_xlp_div_table *table, int table_sz)
+{
+	int i, idx = 0;
+	u64 nfreq, sysbase = nlm_get_node(0)->sysbase;
+	unsigned int pll_divf, pll_divr, ext_div, rstval, denom;
+	rstval = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+
+	pll_divf = ((rstval >> 10) & 0x7f) + 1;
+	pll_divr = ((rstval >> 8) & 0x3) + 1;
+	ext_div = ((rstval >> 30) & 0x3) + 1;
+
+	for (i = 0; i < 0xf && i < table_sz; i++) {
+		if ( i == 8 || i == 10 || i == 12 || i == 14)
+			continue;
+
+		nfreq = 800000000ULL * pll_divf;
+		denom = 3 * pll_divr * ext_div * (i + 1);
+
+		nfreq = nfreq / denom;
+		if (nfreq < min || nfreq > max)
+			continue;
+
+		table[idx].freq = nfreq;
+		table[idx].div = i;
+		idx++;
+	}
+}
+#endif
+
+static long xlp_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+			       unsigned long *prate)
+{
+	struct clk_xlp *cxlp = to_clk_xlp(hw);
+	int idx;
+
+	if (!clk_table) {
+		clk_table = kzalloc(sizeof(*clk_table) * NR_XLP_DIV_TBL_ENTRIES,
+				    GFP_KERNEL);
+		if (!clk_table)
+			return -ENOMEM;
+		/* We cannot go below 800MHZ, some systems freeze */
+		if (cpu_is_xlpii())
+			build_xlpii_freq_table(CLK_100MHZ * 8, 1600000000, clk_table,
+					       NR_XLP_DIV_TBL_ENTRIES, CLK_100MHZ);
+		else
+			build_xlp_freq_table(CLK_MHZ(800), CLK_MHZ(1600),
+					     clk_table, NR_XLP_DIV_TBL_ENTRIES);
+	}
+
+	idx = __xlp_clk_find_index(cxlp, rate);
+	if (idx < 0)
+		idx = __xlp_clk_find_nearest(cxlp, rate);
+
+	/* Refuse if it is too far in the spectrum */
+	if (abs(clk_table[idx].freq - rate) > CLK_100MHZ)
+		return -1;
+
+	return clk_table[idx].freq; /* Returns in HZ */
+}
+
+static unsigned int __nlm_xlpii_get_core_frequency(int node, int core)
+{
+	int ctrl1, ctrl0;
+	uint64_t denom, nfreq, ctrl0val, ctrl1val;
+	u64 sysbase = nlm_get_node(node)->sysbase;
+
+	ctrl1 = (cpu_is_xlp9xx())? SYS_9XX_CPU_PLL_CTRL1(core):
+		SYS_CPU_PLL_CTRL1(core);
+	ctrl0 = (cpu_is_xlp9xx())? SYS_9XX_CPU_PLL_CTRL0(core):
+		SYS_CPU_PLL_CTRL0(core);
+
+	if (cpu_is_xlp9xx()) {
+		ctrl1val = __xlp_sys_read_reg(node, ctrl1);
+		ctrl0val = __xlp_sys_read_reg(node, ctrl0);
+	} else {
+		ctrl1val = nlm_read_sys_reg(sysbase, ctrl1);
+		ctrl0val = nlm_read_sys_reg(sysbase, ctrl0);
+	}
+
+	nfreq = PLL_CORE_FREQ(ctrl1val & 0x3f);	/* Bits 5:0 */
+
+	denom = nlm_pll_div_table[ctrl0val>>24 & 0x7];
+
+	return nfreq / denom;
+}
+
+static unsigned int __nlm_xlp_get_core_frequency(int node, int core)
+{
+	unsigned int pll_divf, pll_divr, dfs_div, ext_div;
+	unsigned int rstval, dfsval, denom;
+	u64 nfreq, sysbase = nlm_get_node(node)->sysbase;
+
+	rstval = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+	dfsval = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIV_VALUE);
+
+	pll_divf = ((rstval >> 10) & 0x7f) + 1;
+	pll_divr = ((rstval >> 8)  & 0x3) + 1;
+	ext_div  = ((rstval >> 30) & 0x3) + 1;
+	dfs_div  = ((dfsval >> (core * 4)) & 0xf) + 1;
+
+	nfreq = 800000000ULL * pll_divf;
+	denom = 3 * pll_divr * ext_div * dfs_div;
+
+	return nfreq / denom;
+}
+
+unsigned int nlm_get_core_frequency(int node, int core)
+{
+	if (cpu_is_xlpii())
+		return __nlm_xlpii_get_core_frequency(node, core);
+	else
+	/* Frequency returned in HZ */
+	return __nlm_xlp_get_core_frequency(node, core);
+}
+
+static unsigned long
+xlp_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct clk_xlp *cxlp = to_clk_xlp(hw);
+
+	/* Freq expected in KHZ */
+	return nlm_get_core_frequency(cxlp->nodeid, cxlp->coreid) / CLK_1KHZ;
+}
+
+static int xlp_clk_is_enabled(struct clk_hw *hw)
+{
+	return 1;		/* Is always enabled */
+}
+
+struct clk_ops xlp_cpu_clk_ops = {
+	.set_rate = xlpii_clk_set_rate,
+	.round_rate = xlp_clk_round_rate,
+	.recalc_rate = xlp_clk_recalc_rate,
+	.is_enabled = xlp_clk_is_enabled,
+};
+
+static  __init struct clk *
+xlp_clk_cpu_pll_setup( char *name, const char *parent_name,
+		       int nodeid, int coreid, int threadid, int cpuid)
+{
+	struct clk_xlp *xclk;
+	struct clk *c;
+	struct clk_init_data id;
+
+	xclk = kzalloc(sizeof(*xclk), GFP_KERNEL);
+	if (!xclk)
+		return ERR_PTR(-ENOMEM);
+
+	id.name = name;
+	id.parent_names = &parent_name;
+	id.num_parents = 1;
+	id.flags = CLK_IS_BASIC;
+
+	if (!cpu_is_xlpii())
+		xlp_cpu_clk_ops.set_rate = xlp_clk_set_rate;
+
+	id.ops = &xlp_cpu_clk_ops;
+	xclk->hw.init = &id;
+	xclk->cpuid = cpuid;
+	xclk->coreid = coreid;
+	xclk->nodeid = nodeid;
+	xclk->threadid = threadid;
+
+	c = clk_register(NULL, &xclk->hw);
+	if (IS_ERR(c))
+		kfree(xclk);
+
+	return c;
+}
+
+#define CLK_NAME_MAX	32
+
+static char *core_names[] = {"core0", "core1", "core2", "core3", "core4",
+			     "core5", "core6", "core7", "core8", "core9",
+			     "core10", "core11", "core12", "core13", "core14",
+			     "core15", "core16", "core17", "core18", "core19",
+};
+
+static struct device_node *cpu_pll_node;
+
+static int __init xlp_cpu_clock_setup(struct device_node *node)
+{
+	struct clk *clk = NULL;
+	char clk_name[CLK_NAME_MAX];
+	int cpuid;
+
+	for_each_present_cpu(cpuid) {
+		int nodeid = nlm_cpuid_to_node(cpu_logical_map(cpuid));
+		int coreid = (cpu_logical_map(cpuid) / NLM_THREADS_PER_CORE) %
+			nlm_cores_per_node();
+		int threadid = cpuid % NLM_THREADS_PER_CORE;
+
+		if (threadid == 0) {
+			clk = xlp_clk_cpu_pll_setup(core_names[coreid],
+						    node->name,
+						    nodeid, coreid, threadid, cpuid);
+			if (IS_ERR(clk)) {
+				pr_err("Unable to setup clock for %s\n",
+				       core_names[coreid] );
+				return -1;
+			}
+		}
+
+		XLP_MAKE_CORE_CLK_NAME(clk_name, CLK_NAME_MAX, coreid, threadid);
+
+		clk_register_clkdev(clk, clk_name, NULL);
+	}
+
+	return 0;
+}
+
+static int __init xlp_cpupll_setup(struct device_node *np)
+{
+	struct clk *c;
+
+	c = clk_register_fixed_rate(NULL, np->name, XLP_REF_CLK_NAME,
+				    CLK_IS_BASIC, XLP_CPU_CLK_SPEED/1000); /* in KHZ */
+	if (IS_ERR(c)) {
+		pr_err("could not register pll clock : %s\n", np->name);
+		return PTR_ERR(c);
+	}
+	cpu_pll_node = np;
+
+	return xlp_cpu_clock_setup(cpu_pll_node);
+}
+
+void __init xlp_ref_clock_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 rate;
+
+	if (of_property_read_u32(node, "clock-frequency", &rate))
+		return;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	clk = clk_register_fixed_rate(NULL, clk_name, parent_name,
+				      CLK_IS_ROOT, rate/1000);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "netlogic,xlp-cpu-clock", .data = xlp_cpupll_setup,},
+	{ .compatible = "netlogic,xlp-ref-clock", .data = xlp_ref_clock_setup,},
+	{},
+};
+
+static int __init xlp_clk_init(void)
+{
+	of_clk_init(clk_match);
+
+	return 0;
+}
+
+postcore_initcall(xlp_clk_init);
+
diff --git a/arch/mips/netlogic/xlp/nlm_hal.c b/arch/mips/netlogic/xlp/nlm_hal.c
index a8f4144..8deb579 100644
--- a/arch/mips/netlogic/xlp/nlm_hal.c
+++ b/arch/mips/netlogic/xlp/nlm_hal.c
@@ -223,81 +223,6 @@ int nlm_irq_to_irt(int irq)
 		return xlp_irq_to_irt(irq);
 }
 
-static unsigned int nlm_xlp2_get_core_frequency(int node, int core)
-{
-	unsigned int pll_post_div, ctrl_val0, ctrl_val1, denom;
-	uint64_t num, sysbase, clockbase;
-
-	if (cpu_is_xlp9xx()) {
-		clockbase = nlm_get_clock_regbase(node);
-		ctrl_val0 = nlm_read_sys_reg(clockbase,
-					SYS_9XX_CPU_PLL_CTRL0(core));
-		ctrl_val1 = nlm_read_sys_reg(clockbase,
-					SYS_9XX_CPU_PLL_CTRL1(core));
-	} else {
-		sysbase = nlm_get_node(node)->sysbase;
-		ctrl_val0 = nlm_read_sys_reg(sysbase,
-						SYS_CPU_PLL_CTRL0(core));
-		ctrl_val1 = nlm_read_sys_reg(sysbase,
-						SYS_CPU_PLL_CTRL1(core));
-	}
-
-	/* Find PLL post divider value */
-	switch ((ctrl_val0 >> 24) & 0x7) {
-	case 1:
-		pll_post_div = 2;
-		break;
-	case 3:
-		pll_post_div = 4;
-		break;
-	case 7:
-		pll_post_div = 8;
-		break;
-	case 6:
-		pll_post_div = 16;
-		break;
-	case 0:
-	default:
-		pll_post_div = 1;
-		break;
-	}
-
-	num = 1000000ULL * (400 * 3 + 100 * (ctrl_val1 & 0x3f));
-	denom = 3 * pll_post_div;
-	do_div(num, denom);
-
-	return (unsigned int)num;
-}
-
-static unsigned int nlm_xlp_get_core_frequency(int node, int core)
-{
-	unsigned int pll_divf, pll_divr, dfs_div, ext_div;
-	unsigned int rstval, dfsval, denom;
-	uint64_t num, sysbase;
-
-	sysbase = nlm_get_node(node)->sysbase;
-	rstval = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
-	dfsval = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIV_VALUE);
-	pll_divf = ((rstval >> 10) & 0x7f) + 1;
-	pll_divr = ((rstval >> 8)  & 0x3) + 1;
-	ext_div  = ((rstval >> 30) & 0x3) + 1;
-	dfs_div  = ((dfsval >> (core * 4)) & 0xf) + 1;
-
-	num = 800000000ULL * pll_divf;
-	denom = 3 * pll_divr * ext_div * dfs_div;
-	do_div(num, denom);
-
-	return (unsigned int)num;
-}
-
-unsigned int nlm_get_core_frequency(int node, int core)
-{
-	if (cpu_is_xlpii())
-		return nlm_xlp2_get_core_frequency(node, core);
-	else
-		return nlm_xlp_get_core_frequency(node, core);
-}
-
 /*
  * Calculate PIC frequency from PLL registers.
  * freq_out = (ref_freq/2 * (6 + ctrl2[7:0]) + ctrl2[20:8]/2^13) /
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 137d3e7..8febf57 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_ARCH_VT8500)	+= clk-vt8500.o
 obj-$(CONFIG_ARCH_ZYNQ)		+= clk-zynq.o
 obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-$(CONFIG_PLAT_SAMSUNG)	+= samsung/
+obj-$(CONFIG_CPU_XLP)		+= clk-xlp.o
 
 obj-$(CONFIG_X86)		+= x86/
 
@@ -39,3 +40,4 @@ obj-$(CONFIG_COMMON_CLK_WM831X) += clk-wm831x.o
 obj-$(CONFIG_COMMON_CLK_MAX77686) += clk-max77686.o
 obj-$(CONFIG_COMMON_CLK_SI5351) += clk-si5351.o
 obj-$(CONFIG_CLK_TWL6040)	+= clk-twl6040.o
+
diff --git a/drivers/clk/clk-xlp.c b/drivers/clk/clk-xlp.c
new file mode 100644
index 0000000..dd84b96
--- /dev/null
+++ b/drivers/clk/clk-xlp.c
@@ -0,0 +1,582 @@
+/*
+ * Copyright (c) 2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Prem Mallappa <pmallapp@broadcom.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/netlogic/clk.h>
+
+//#define XLP_DEV_CLK_DEBUG 1
+#ifdef XLP_DEV_CLK_DEBUG
+#define DEBUG		pr_crit
+#else
+#define DEBUG(...)
+#endif
+
+enum {
+	CLK_XLP_DDR_CLK = 0,
+	CLK_XLP_PLL1,		/* 500 */
+	CLK_XLP_PLL2,		/* 600 or 677 */
+	CLK_XLP_PLL3,		/* 667 or 767 */
+};
+
+enum {CLK_XLP_SOC_4G = 0,};
+
+struct clk_xlp_dev {
+	struct clk_hw hw;
+	uint8_t device_id;
+	uint8_t parent;
+	uint8_t div;
+	unsigned long rate;
+};
+
+#define to_clk_xlp_dev(_hw) container_of(_hw, struct clk_xlp_dev, hw)
+
+struct xlp_clk_ops {
+	int (*get_div) (struct clk_xlp_dev *);
+	int (*get_parent) (struct clk_xlp_dev *);
+	int (*get_post_div) (struct clk_xlp_dev *);
+};
+
+static int nr_dev_pll_clks;
+
+struct clk_xlp_dev_clk_desc {
+	char *name;
+	uint8_t id;
+	uint8_t parent;
+	uint8_t div;
+};
+
+static __initdata struct clk_xlp_dev_clk_desc xlpii_dev_clk_desc[] = {
+        {XLP_CLK_DEV_PIC_CLK_NAME,  XLPII_SOC_DEV_PIC,        CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_DTRE_CLK_NAME, XLPII_SOC_DEV_DTRE,	      CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_CMP_CLK_NAME,  XLPII_SOC_DEV_CMP,	      CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_REGXF_CLK_NAME,XLPII_SOC_DEV_REGEX_FAST, CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_REGXS_CLK_NAME,XLPII_SOC_DEV_REGEX_SLOW, CLK_XLP_PLL2, 2},
+	{XLP_CLK_DEV_SEC_CLK_NAME,  XLPII_SOC_DEV_SEC,	      CLK_XLP_PLL2, 2},
+	{XLP_CLK_DEV_RSA_CLK_NAME,  XLPII_SOC_DEV_RSA,	      CLK_XLP_PLL3, 2},
+	{XLP_CLK_DEV_NET_CLK_NAME,  XLPII_SOC_DEV_NET,	      CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_SATA_CLK_NAME, XLPII_SOC_DEV_SATA,	      CLK_XLP_PLL1, 1},
+	{XLP_CLK_DEV_KBP_CLK_NAME,  XLPII_SOC_DEV_KBP,	      CLK_XLP_PLL1, 1},
+	{XLP_CLK_DEV_USB_CLK_NAME,  XLPII_SOC_DEV_USB,	      CLK_XLP_PLL3, 2},
+	{XLP_CLK_DEV_GIO_CLK_NAME,  XLPII_SOC_DEV_GIO,	      CLK_XLP_PLL1, 2},
+	{XLP_CLK_DEV_GBU_CLK_NAME,  XLPII_SOC_DEV_GBU,	      CLK_XLP_PLL1, 4},
+        {XLP_CLK_DEV_LZS_CLK_NAME,  XLPII_SOC_DEV_LZS,        CLK_XLP_PLL1, 2},
+};
+
+/* 2XX */
+static __initdata struct clk_xlp_dev_clk_desc xlp2xx_dev_clk_desc[] = {
+        {XLP_CLK_DEV_NET_CLK_NAME,  XLP2XX_SOC_DEV_NET,   CLK_XLP_PLL2, 2},
+        {XLP_CLK_DEV_SEC_CLK_NAME,  XLP2XX_SOC_DEV_SEC,   CLK_XLP_PLL2, 2},
+        {XLP_CLK_DEV_RSA_CLK_NAME,  XLP2XX_SOC_DEV_RSA,   CLK_XLP_PLL2, 2},
+        {XLP_CLK_DEV_GDX_CLK_NAME,  XLP2XX_SOC_DEV_GDXd,  CLK_XLP_PLL3, 3},
+        {XLP_CLK_DEV_CMP_CLK_NAME,  XLP2XX_SOC_DEV_CMP,   CLK_XLP_PLL3, 3},
+        {XLP_CLK_DEV_NAND_CLK_NAME, XLP2XX_SOC_DEV_NAND,  CLK_XLP_DDR_CLK, 0},
+        {XLP_CLK_DEV_MMC_CLK_NAME,  XLP2XX_SOC_DEV_MMC,   CLK_XLP_DDR_CLK, 0},
+        {XLP_CLK_DEV_GBU_CLK_NAME,  XLP2XX_SOC_DEV_GBU,   CLK_XLP_DDR_CLK, 0},
+        {XLP_CLK_DEV_REGXF_CLK_NAME, XLP2XX_SOC_DEV_REGEX_FAST, CLK_XLP_PLL2, 2},
+        {XLP_CLK_DEV_REGXS_CLK_NAME, XLP2XX_SOC_DEV_REGEX_SLOW, CLK_XLP_PLL1, 1},
+        {XLP_CLK_DEV_USB_CLK_NAME,   XLP2XX_SOC_DEV_USB,        CLK_XLP_PLL3, 3},
+        {XLP_CLK_DEV_PIC_CLK_NAME,   XLP2XX_SOC_DEV_PIC,        CLK_XLP_PLL1, 1},
+};
+
+/* 8XX - clocks */
+static __initdata struct clk_xlp_dev_clk_desc xlp_dev_clk_desc[] = {
+	{XLP_CLK_DEV_NET_CLK_NAME,  XLP_SOC_DEV_NET,	CLK_XLP_PLL2, 2},
+	{XLP_CLK_DEV_SEC_CLK_NAME,  XLP_SOC_DEV_SEC,	CLK_XLP_PLL2, 1},
+	{XLP_CLK_DEV_RSA_CLK_NAME,  XLP_SOC_DEV_RSA,	CLK_XLP_PLL2, 1},
+	{XLP_CLK_DEV_DTRE_CLK_NAME, XLP_SOC_DEV_DTRE,	CLK_XLP_PLL3, 1},
+	{XLP_CLK_DEV_CMP_CLK_NAME,  XLP_SOC_DEV_CMP,	CLK_XLP_PLL3, 1},
+	{XLP_CLK_DEV_KBP_CLK_NAME,  XLP_SOC_DEV_KBP,	CLK_XLP_PLL1, 1},
+	{XLP_CLK_DEV_DMC_CLK_NAME,  XLP_SOC_DEV_DMC,	CLK_XLP_DDR_CLK, 1}, // DMC
+	{XLP_CLK_DEV_NAND_CLK_NAME, XLP_SOC_DEV_NAND,	CLK_XLP_DDR_CLK, 1},
+	{XLP_CLK_DEV_MMC_CLK_NAME,  XLP_SOC_DEV_MMC,	CLK_XLP_DDR_CLK, 1},
+	{XLP_CLK_DEV_GBU_CLK_NAME,  XLP_SOC_DEV_GBU,	CLK_XLP_DDR_CLK, 1},
+};
+
+static const char const *clk_xlp_devclk_names[] = {
+	"dmc-pll",
+	"pll1",
+	"pll2",
+	"pll3",
+};
+
+#if 0
+static const char const *clk_xlp_devclk_names[] = {
+	"dev-pll",
+};
+#endif
+
+struct __xlp_dev_clks {
+	struct clk *clk;
+	uint8_t	 id;
+	uint8_t nodeid;
+	uint64_t rate;	/* in KHz */
+};
+
+/*
+ * This is not __initdata. And 500 KHz will be treated as 500MHz, as clk
+ * framework expects all frequency in KHz
+ */
+static struct __xlp_dev_clks clk_xlpii_dev_clks[] = {
+	{.rate = CLK_KHZ(1000), .id = CLK_XLP_DDR_CLK},
+	{.rate = CLK_KHZ(500), .id = 1},
+	{.rate = CLK_KHZ(667), .id = 2},
+	{.rate = CLK_KHZ(767), .id = 3},
+};
+
+static struct __xlp_dev_clks clk_xlp_dev_clks[] = {
+	{.rate = CLK_KHZ(1000), .id = CLK_XLP_DDR_CLK},
+	{.rate = CLK_KHZ(400), .id = 1},
+	{.rate = CLK_KHZ(500), .id = 2},
+	{.rate = CLK_KHZ(667), .id = 3},
+};
+
+static inline unsigned int __xlp_clk_read_reg(int reg)
+{
+	uint64_t clkbase = nlm_get_clock_regbase(nlm_nodeid());
+	return nlm_read_clock_reg(clkbase, reg);
+}
+
+static inline void __xlp_clk_write_reg(int reg, unsigned int val)
+{
+	uint64_t clkbase = nlm_get_clock_regbase(nlm_nodeid());
+	return nlm_write_clock_reg(clkbase, reg, val);
+}
+
+static inline int __xlp_get_parent(int device)
+{
+	return (__xlp_clk_read_reg(SYS_9XX_CLK_DEV_SEL) >> (device * 2)) & 0x3;
+}
+
+static inline int __xlp_get_div(int device)
+{
+	unsigned int reg, mask;
+	int bits;
+	if (cpu_is_xlpii()) {
+		reg = SYS_9XX_CLK_DEV_DIV;
+		if (cpu_is_xlp2xx())
+			reg = SYS_CLK_DEV_DIV;
+		bits = 2;
+	} else { /* 8XX */
+		reg = SYS_CLK_DIV;
+		bits = 4;
+	}
+
+	mask = (1 << bits) - 1;
+	return (__xlp_clk_read_reg(reg) >> (device * bits)) & mask;
+}
+
+static inline void __xlp_set_parent(int device, int div)
+{
+	/* only XLPII has multiple parents */
+	if (!cpu_is_xlpii())
+		return;
+
+	__xlp_clk_write_reg(cpu_is_xlp2xx()? SYS_CLK_DEV_SEL: SYS_9XX_CLK_DEV_SEL,
+			    div << (device * 2));
+}
+
+static inline void __xlp_set_div(int device, int div)
+{
+	unsigned int reg;
+
+	if (cpu_is_xlpii()) {
+		reg = cpu_is_xlp9xx()? SYS_9XX_CLK_DEV_DIV: SYS_CLK_DEV_DIV;
+		__xlp_clk_write_reg(reg, div << (device * 2));
+	} else {
+		int curdiv = __xlp_clk_read_reg(SYS_CLK_DEV_DIV);
+		int reg = SYS_CLK_DIV_INC;
+		if (div < curdiv) {
+			int tmp = curdiv;
+			curdiv = div;
+			div = tmp;
+			reg = SYS_CLK_DIV_DEC;
+		}
+
+		for (; curdiv < div; curdiv++)
+			__xlp_clk_write_reg(reg, device << 4);
+	}
+}
+
+static int xlp_clk_dev_is_enabled(struct clk_hw *hw)
+{
+	return 1;		/* Is always enabled */
+}
+
+/* The parent index is off by one, as the dmc_clock is also
+ * part of the parent list in the h/w but cannot be used to
+ * clock the devices
+ */
+static u8 xlp_clk_dev_get_parent(struct clk_hw *hw)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	int parent = __xlp_get_parent(xdclk->device_id);
+
+	if (parent != xdclk->parent)
+		xdclk->parent = parent;
+
+	return parent;
+}
+
+static int __xlp_clk_dev_set_parent(int device_id, int sel_reg, int chg_reg,
+				    uint8_t *parent, int index)
+{
+	int prt = __xlp_get_parent(device_id);
+	if (prt != index) {
+		int timeout = 10000;
+		*parent = index;
+
+		__xlp_clk_write_reg(sel_reg, index << device_id);
+
+		__xlp_clk_write_reg(chg_reg, 1 << device_id);
+
+		while (timeout--) {
+			if (__xlp_clk_read_reg(chg_reg) & BIT(device_id))
+				break;
+		}
+
+		if (timeout == 0) {
+			pr_crit("Unable to set parent %d for device: %d\n",
+				prt, device_id);
+			return -1;
+		}
+	}
+
+	return index;
+}
+
+static int xlp_clk_dev_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	int sel, chg;
+
+	if (!cpu_is_xlpii())	/* Cannot select parent for XLP devices */
+		return index;
+
+	sel = cpu_is_xlp2xx()? SYS_CLK_DEV_SEL : SYS_9XX_CLK_DEV_SEL;
+	chg = cpu_is_xlp2xx()? SYS_CLK_DEV_CHG : SYS_9XX_CLK_DEV_CHG;
+
+	return __xlp_clk_dev_set_parent(xdclk->device_id, sel, chg,
+						&xdclk->parent, index);
+}
+
+static unsigned long xlp_clk_dev_recalc_rate(struct clk_hw *hw,
+					     unsigned long parent_rate)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	int parent = __xlp_get_parent(xdclk->device_id);
+	int div = 1 << __xlp_get_div(xdclk->device_id);
+	struct __xlp_dev_clks *c = cpu_is_xlpii()?
+		&clk_xlpii_dev_clks[parent]: &clk_xlp_dev_clks[parent];
+
+	return c->rate / div;
+}
+
+static inline int __xlp_build_params(struct clk_xlp_dev *xdclk,
+				      struct clk_xlp_dev *new, unsigned long rate)
+{
+	int parent, div;
+	int divmax;
+	int nrparents;
+	struct __xlp_dev_clks *clks;
+
+	if (cpu_is_xlpii()) {
+		divmax = 3;
+		nrparents = 4;
+		clks = clk_xlpii_dev_clks;
+	} else {
+		divmax = 15;
+		nrparents = 1;
+		clks = clk_xlp_dev_clks;
+	}
+
+	new->rate = xdclk->rate;
+
+	for (parent = 1; parent < nrparents; parent++) {
+		for (div = 0; div <= divmax; div++) {
+			unsigned long freq;
+			switch (div) { /* Only for 8XX */
+			case 8: case 10: case 12: case 14:
+				continue;
+			}
+
+			freq = clks[parent].rate / (1 << div);
+			if ((freq - rate) < (freq - new->rate)) {
+				new->rate = freq;
+				new->parent = parent;
+				new->div = div;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static long xlp_clk_dev_round_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long *prate)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	struct clk_xlp_dev new = {{0}};
+	int ret = __xlp_build_params(xdclk, &new, rate);
+
+	if (ret < 0)
+		return ret;
+
+	*prate = clk_xlp_dev_clks[xdclk->parent].rate;
+
+	return new.rate;	/* we determined as closest to _rate_ */
+}
+
+static int __xlpii_clk_dev_set_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long prate)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	struct clk_xlp_dev new = {{0}}; /* To suppress GCC warning */
+	int ret = 0;
+	int chg_reg = cpu_is_xlp9xx()? SYS_9XX_CLK_DEV_CHG : SYS_CLK_DEV_CHG;
+
+	ret = __xlp_build_params(xdclk, &new, rate);
+	if (ret != 0)
+		return ret;
+
+	if (new.parent != xdclk->parent)
+		__xlp_set_parent(xdclk->device_id, new.parent);
+
+	if (new.div != xdclk->div)
+		__xlp_set_div(xdclk->device_id, new.div);
+
+	__xlp_clk_write_reg(chg_reg, xdclk->device_id);
+
+	xdclk->div = new.div;
+	xdclk->parent = new.parent;
+	xdclk->rate = new.rate;
+
+	return rate;
+}
+
+static int __xlp_clk_dev_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long prate)
+{
+	struct clk_xlp_dev *xdclk = to_clk_xlp_dev(hw);
+	struct clk_xlp_dev new = {{0}}; /* To suppress GCC warning */
+	int ret = 0;
+
+	ret = __xlp_build_params(xdclk, &new, rate);
+	if (ret != 0)
+		return ret;
+
+	if (new.div != xdclk->div)
+		__xlp_set_div(xdclk->device_id, new.div);
+
+	return rate;
+}
+
+static int xlp_clk_dev_set_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long prate)
+{
+	if(cpu_is_xlpii())
+		return __xlpii_clk_dev_set_rate(hw, rate, prate);
+
+	return __xlp_clk_dev_set_rate(hw, rate, prate);
+}
+
+static int xlp_clk_dev_enable(struct clk_hw *hw)
+{
+	return 0;
+}
+
+struct clk_ops clk_xlp_dev_clk_ops = {
+	.set_rate = xlp_clk_dev_set_rate,
+	.round_rate = xlp_clk_dev_round_rate,
+	.recalc_rate = xlp_clk_dev_recalc_rate,
+	.is_enabled = xlp_clk_dev_is_enabled,
+	.set_parent = xlp_clk_dev_set_parent,
+	.get_parent = xlp_clk_dev_get_parent,
+	.enable = xlp_clk_dev_enable,
+};
+
+static struct clk *xlp_clk_register(struct clk_xlp_dev_clk_desc *desc,
+				    const char const *parent_names[], int nparents)
+{
+	struct clk_xlp_dev *xclk;
+	struct clk_init_data init_data;
+	struct clk *c;
+
+	xclk = kzalloc(sizeof(*xclk), GFP_KERNEL);
+	if (!xclk)
+		return ERR_PTR(-ENOMEM);
+
+	init_data.name = desc->name;
+	init_data.parent_names = parent_names;
+	init_data.num_parents = nparents;
+	init_data.flags = CLK_IS_BASIC;
+	init_data.ops = &clk_xlp_dev_clk_ops;
+
+	xclk->hw.init = &init_data;
+	xclk->device_id = desc->id;
+	xclk->parent = desc->parent;
+	xclk->div = desc->div;
+
+	c = clk_register(NULL, &xclk->hw);
+	if (!IS_ERR(c))
+		clk_prepare_enable(c);
+	else
+		kfree(xclk);
+
+	return c;
+}
+
+struct clk *xlp_pll_clock_setup(struct device_node *np, struct clk_hw *hw,
+				struct clk_ops *ops)
+{
+	struct clk *clk = NULL;
+	struct clk_init_data init;
+	const char *parent_name;
+	u32 rate;
+	int err;
+
+	const char *name;
+	init.name = np->name;
+	init.ops = ops;
+
+	parent_name = of_clk_get_parent_name(np, 0);
+	init.num_parents = 1;
+	init.parent_names = &parent_name;
+	hw->init = &init;
+
+	err = of_property_read_u32(np, "clock-frequency", &rate);
+	if (err != -ENODATA) {
+		int err = of_property_read_string_index(np, "clock-output-names",
+							0, &name);
+		if (err == -ENODATA) {
+			pr_err("Unable to find value clock-output-mes in dts\n");
+			goto out;
+		}
+
+		clk = clk_register(NULL, hw);
+		if (WARN_ON(IS_ERR(clk)))
+			goto out;
+
+		err = of_clk_add_provider(np, of_clk_src_simple_get, clk);
+		if (WARN_ON(err))
+			goto out;
+	}
+
+out:
+	return clk;
+}
+
+void __init xlp_dev_clock_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 rate;
+
+	if (of_property_read_u32(node, "clock-frequency", &rate))
+		return;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	clk = clk_register_fixed_rate(NULL, clk_name, parent_name,
+				      CLK_IS_BASIC, rate/1000);
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "netlogic,xlp-dev-clock", .data = xlp_dev_clock_setup,},
+	{ }
+};
+
+static int __init xlp_dev_clk_init(void)
+{
+	struct clk_xlp_dev_clk_desc *dev_pll_clk;
+	int i;
+
+	of_clk_init(clk_match);
+
+	if (cpu_is_xlpii()) {	/* 9XX / 5XX */
+		dev_pll_clk = xlpii_dev_clk_desc;
+		nr_dev_pll_clks = ARRAY_SIZE(xlpii_dev_clk_desc);
+
+		if (cpu_is_xlp2xx()) { /* XLP 2XX */
+			dev_pll_clk = xlp2xx_dev_clk_desc;
+			nr_dev_pll_clks = ARRAY_SIZE(xlp2xx_dev_clk_desc);
+		}
+	} else {		/* XLP 8XX */
+		dev_pll_clk = xlp_dev_clk_desc;
+		nr_dev_pll_clks = ARRAY_SIZE(xlp_dev_clk_desc);
+	}
+
+	for (i = 0; i < nr_dev_pll_clks; i++) {
+		struct clk_xlp_dev_clk_desc *desc = &dev_pll_clk[i];
+		struct clk *clk;
+
+		clk =  xlp_clk_register(desc, clk_xlp_devclk_names,
+					ARRAY_SIZE(clk_xlp_devclk_names));
+		if (clk) {
+			int err;
+			/* This is for name lookup */
+			clk_register_clkdev(clk, desc->name, NULL);
+
+			err = of_clk_add_provider(NULL, of_clk_src_simple_get, clk);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+late_initcall(xlp_dev_clk_init);
diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index 534fcb8..5301fe3 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -251,6 +251,17 @@ config LOONGSON2_CPUFREQ
 
 	  If in doubt, say N.
 
+config XLP_CPUFREQ
+        tristate "Netlogic XLP CPUFreq Driver"
+        default y
+        select CPU_FREQ_TABLE
+        depends on CPU_XLP && MIPS_CPUFREQ
+        help
+          This option adds a CPUFreq driver for Netlogic XLP processors which
+          support software configurable cpu frequency.
+
+          If in doubt, say N.
+
 endmenu
 
 menu "PowerPC CPU frequency scaling drivers"
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 3b95322..061dfd7 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -92,3 +92,4 @@ obj-$(CONFIG_SH_CPU_FREQ)		+= sh-cpufreq.o
 obj-$(CONFIG_SPARC_US2E_CPUFREQ)	+= sparc-us2e-cpufreq.o
 obj-$(CONFIG_SPARC_US3_CPUFREQ)		+= sparc-us3-cpufreq.o
 obj-$(CONFIG_UNICORE32)			+= unicore2-cpufreq.o
+obj-$(CONFIG_CPU_XLP)			+= xlp-cpufreq.o
diff --git a/drivers/cpufreq/xlp-cpufreq.c b/drivers/cpufreq/xlp-cpufreq.c
new file mode 100644
index 0000000..d87bcfc
--- /dev/null
+++ b/drivers/cpufreq/xlp-cpufreq.c
@@ -0,0 +1,461 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+n * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/regulator.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/mach-netlogic/multi-node.h>
+#include <asm/netlogic/clk.h>
+
+#define XLPII_DIVS		61 /* (((2400 - 400) / 100) * 3) */
+#define XLP_DIVS		11
+
+//#define ENTER()		pr_crit("Enter:%s\n", __FUNCTION__)
+//#define EXIT()		pr_crit("Exit:%s:%d\n", __FUNCTION__, __LINE__)
+
+#define PLL_CORE_FREQ(div)					\
+	(CLK_MHZ(400) + ((unsigned long)div * CLK_MHZ(100)) / 3)
+
+static DEFINE_SPINLOCK(freq_lock);  /* unlocked */
+
+static inline int xlp_cpu_to_node(int cpu)
+{
+	return nlm_cpuid_to_node(cpu_logical_map(cpu));
+}
+
+static inline int xlp_cpu_to_core(int cpu)
+{
+	int cpumap = cpu_logical_map(cpu);
+
+	return (cpumap / NLM_THREADS_PER_CORE) % nlm_cores_per_node();
+}
+
+static struct cpumask xlp_affected_cpus[NR_CPUS];
+
+static struct cpufreq_frequency_table *xlp_freq_table;
+static int nr_tbl_entry;
+
+//static unsigned int xlp_cpufreq_get_speed(unsigned int cpu);
+
+#ifdef CONFIG_REGULATOR
+static struct regulator *vdd_xlp;
+
+static int xlp2xx_set_voltage(int new_freq);
+static int xlpii_set_voltage(int new_freq);
+static int (*xlp_set_voltage)(int new_freq);
+#endif
+
+int xlp_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, xlp_freq_table);
+}
+
+static int __init build_xlp_freq_table(struct cpufreq_frequency_table *tbl)
+{
+	u64 freq = CLK_100MHZ;
+	struct clk *clk;
+	int idx = 0;
+	char name[32];
+
+	XLP_MAKE_CORE_CLK_NAME(name, sizeof(name), 0, 0);
+
+	clk = clk_get(NULL, name);
+	if (!clk) {
+		pr_crit("Unable to find Clock source for core0\n");
+		return -1;
+	}
+
+	for (;freq < CLK_MHZ(4096); freq += CLK_100MHZ) {
+		long rate = clk_round_rate(clk, freq);
+
+		if (rate < 0)
+			continue;
+		tbl[idx].driver_data = idx;
+		tbl[idx].frequency = rate / CLK_1KHZ;
+		idx++;
+	}
+
+	tbl[idx].driver_data = 0;
+	tbl[idx].frequency = CPUFREQ_TABLE_END;
+
+	return 0;
+}
+
+static int xlp_freq_set(unsigned long cur, unsigned long new, int cpu)
+{
+	struct clk *clk;
+	unsigned long flags;
+	int ret = 0;
+	char name[32];
+
+	XLP_MAKE_CORE_CLK_NAME(name, sizeof(name),
+			       xlp_cpu_to_core(cpu),
+			       cpu % NLM_THREADS_PER_CORE);
+
+	spin_lock_irqsave(&freq_lock, flags);
+
+	clk = clk_get(NULL, name);
+
+	if (IS_ERR(clk)) {
+		spin_unlock_irqrestore(&freq_lock, flags);
+		pr_crit("Could not get clock for cpu%d\n", cpu);
+		return PTR_ERR(clk);
+	}
+	/* Converted from KHz to Hz */
+	ret = clk_set_rate(clk, new * CLK_1KHZ);
+	spin_unlock_irqrestore(&freq_lock, flags);
+
+	return ret;
+}
+
+#ifdef CONFIG_REGULATOR
+
+#define CPUFREQ_XLP_TBL_IDX	0
+#define CPUFREQ_XLPII_TBL_IDX	1
+#define CPUFREQ_XLP2XX_TBL_IDX  2
+
+#define NR_XLP_TBL_MAX	3
+
+struct xlp_dvfs {
+	unsigned int min, max;
+};
+
+static struct xlp_dvfs xlp_dvfs_table[NR_XLP_TBL_MAX][25] = {
+/* XLP */
+	{{800000, 806250}, {806250, 812500}, {812500, 825000}, /*400/500/600MHz*/
+	 {812500, 825000}, {825000, 837500}, {825000, 837500}, /*700 - 900MHz*/
+	 {837500, 850000}, {837500, 850000}, {850000, 862500}, /*1.0 - 1.2GHz*/
+	 {850000, 862500}, {862500, 875000}, {862500, 875000}, /*1.3 - 1.5GHz*/
+	 {875000, 887500}, {875000, 887500}, {887500, 900000}, /*1.6 - 1.8GHz*/
+	 /*{887500, 900000}, {900000, 912500}, {900000, 912500},
+	{912500, 925000}, {912500, 925000}, {1050000, 1100000}, {1050000, 1100000}, */
+	},
+/* XLPII */
+	{{800000, 805000}, {805000, 810000}, {820000, 840000}, /*400/500/600MHz*/
+	 {840000, 860000}, {860000, 880000}, {880000, 900000}, /*700 - 900 MHz*/
+	 {910000, 920000}, {920000, 930000}, {930000, 940000}, /*1.0 - 1.2 GHz*/
+	 {930000, 940000}, {940000, 950000}, {950000, 960000}, /*1.3 - 1.5GHz */
+	 {960000, 970000}, {970000, 980000}, {990000, 1000000}, /*1.6 - 1.8GHz */
+	},
+
+};
+
+/* For now we use static table for XLPII and calculations for XLP and
+ * 2XX, There is no guarantee either will work.
+ */
+static int xlp2xx_set_voltage(int new_freq)
+{
+	int div, ret;
+	unsigned long vdd_min, vdd_max;
+
+	div = (new_freq * CLK_1KHZ) - CLK_400MHZ;
+	div = ((unsigned long)(div) / CLK_100MHZ);
+
+	vdd_min = XLP_MIN_MICVOLTAGE + div * XLP_VOLTAGE_STEP;
+	vdd_max = vdd_min + XLP_MICVOLTAGE_OPRANGE;
+
+	/* actual index of target_freq in xlpii_freq_table */
+	ret = regulator_set_voltage(vdd_xlp,
+				    vdd_min,
+				    vdd_max);
+
+	if (ret != 0) {
+		pr_err("Failed to set VDD for %dkHz: %d\n",
+		       new_freq, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int xlpii_set_voltage(int new_freq)
+{
+	int ret;
+	unsigned long vdd_min, vdd_max;
+	struct xlp_dvfs *dvfs = (struct xlp_dvfs *)&xlp_dvfs_table[CPUFREQ_XLPII_TBL_IDX];
+	unsigned index = new_freq * CLK_1KHZ - CLK_400MHZ;
+
+	index /= (CLK_100MHZ);
+
+	vdd_min = dvfs[index].min;
+	vdd_max = dvfs[index].max;
+
+	/* actual index of target_freq in xlpii_freq_table */
+	ret = regulator_set_voltage(vdd_xlp,
+				    vdd_min,
+				    vdd_max);
+
+	if (ret != 0) {
+		pr_err("Failed to set VDD for %dkHz, min:%ld max:%ld\n",
+		       new_freq, vdd_min, vdd_max);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __xlp_cpu_freq_table_invalidate_entry(unsigned int target_freq)
+{
+	int i;
+	for (i = 0; i < nr_tbl_entry; i++) {
+		if (target_freq == xlp_freq_table[i].frequency) {
+			xlp_freq_table[i].frequency = CPUFREQ_ENTRY_INVALID;
+			xlp_freq_table[i].index = 0;
+		}
+	}
+}
+#endif
+
+static int xlp_cpufreq_set_target(struct cpufreq_policy *policy,
+				    unsigned int target_freq, unsigned int rel)
+{
+	struct cpufreq_freqs freq = {0,};
+	int ret;
+
+	if (!policy)
+		return -EFAULT;
+
+	if (policy->cur == target_freq)
+		return 0;
+
+	if (target_freq < policy->min)
+		target_freq = policy->min;
+
+	if (target_freq > policy->max)
+		target_freq = policy->max;
+
+	freq.old = policy->cur;
+	freq.new = target_freq;
+	freq.cpu = policy->cpu;
+	freq.flags = 0;
+
+	cpufreq_notify_transition(policy, &freq, CPUFREQ_PRECHANGE);
+
+#ifdef CONFIG_REGULATOR
+	if (vdd_xlp && freq.new > freq.old) {
+		ret = xlp_set_voltage(freq.new);
+		if (ret != 0) {
+			/* Mark this freq as invalid as we were not
+			 * able to set the proper voltage */
+			__xlp_cpu_freq_table_invalidate_entry(target_freq);
+			goto errout;
+		}
+		mdelay(100);
+	}
+#endif
+
+	ret = xlp_freq_set(policy->cur, target_freq, policy->cpu);
+	if (ret != 0)  goto errout;
+
+
+#ifdef CONFIG_REGULATOR
+	if (vdd_xlp && freq.new < freq.old) {
+		ret = xlp_set_voltage(freq.new);
+		if (ret != 0) goto errout;
+
+		mdelay(100);
+	}
+#endif
+
+	policy->cur = target_freq;
+
+	return 0;
+
+errout:
+	pr_err("Setting cpufrequency failed\n");
+	cpufreq_notify_transition(policy, &freq, CPUFREQ_POSTCHANGE);
+	return ret;
+}
+
+static unsigned int xlp_get_cpufreq(unsigned int cpu)
+{
+	unsigned int freq;
+	struct clk *clk;
+	char name[32];
+
+	XLP_MAKE_CORE_CLK_NAME(name, sizeof(name),
+			       xlp_cpu_to_core(cpu),
+			       cpu % NLM_THREADS_PER_CORE);
+
+	clk = clk_get(NULL, name);
+
+	if (IS_ERR(clk)) {
+		pr_crit("Could not get clock for cpu%d\n", cpu);
+		return PTR_ERR(clk);
+	}
+
+	freq = clk_get_rate(clk); /* Converted from KHz to Hz */
+
+	return freq / CLK_1KHZ;
+}
+
+static int xlp_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+	int ret;
+	unsigned long flags;
+
+	policy->cur = xlp_get_cpufreq(policy->cpu);
+
+	/* an optimal guess for latency from HW Team 20*1000*1000 */
+	policy->cpuinfo.transition_latency = 20 * 1000 * 1000;
+
+	spin_lock_irqsave(&freq_lock, flags);
+	cpumask_copy(policy->cpus, &xlp_affected_cpus[policy->cpu]);
+	spin_unlock_irqrestore(&freq_lock, flags);
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, xlp_freq_table);
+	if (ret != 0)
+		pr_err("Failed to configure frequency table: %d\n", ret);
+
+	cpufreq_frequency_table_get_attr(xlp_freq_table, policy->cpu);
+
+#ifdef CONFIG_REGULATOR
+	vdd_xlp = regulator_get(NULL, "regulator-xlp");
+	if (IS_ERR(vdd_xlp)) {
+		ret = PTR_ERR(vdd_xlp);
+		pr_err("failed to get xlp regulator\n");
+		vdd_xlp = NULL;
+	}
+#endif
+
+	return ret;
+}
+
+__exit static int xlp_cpufreq_driver_exit(struct cpufreq_policy *policy)
+{
+	return 0;
+}
+
+static struct freq_attr *xlp_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver xlp_cpufreq_driver = {
+	.owner		= THIS_MODULE,
+	.flags		= 0,
+	.verify		= xlp_cpufreq_verify,
+	.target		= xlp_cpufreq_set_target,
+	.get		= xlp_get_cpufreq,
+	.init		= xlp_cpufreq_driver_init,
+	.exit		= xlp_cpufreq_driver_exit,
+	.name		= "xlp-cpufreq",
+	.attr		= xlp_cpufreq_attr,
+};
+
+static int __init xlpii_cpufreq_register_driver(void)
+{
+	int ret = 0;
+
+#ifdef CONFIG_REGULATOR
+	if (cpu_is_xlp9xx() && !cpu_is_xlp2xx())
+		xlp_set_voltage = xlpii_set_voltage;
+	else
+		xlp_set_voltage = xlp2xx_set_voltage;
+#endif
+
+	ret = build_xlp_freq_table(xlp_freq_table);
+	if (ret < 0)
+		return ret;
+
+	return cpufreq_register_driver(&xlp_cpufreq_driver);
+}
+
+static void setup_affected_cpus(void)
+{
+	/* Find out the number of cores. Read SYS, reg 0x42 bits 0-7,
+	 * PRM 34.9.7.3 */
+	u32 idx;
+	struct cpumask thr;
+	unsigned long flags;
+
+	cpumask_clear(&thr);
+	cpumask_set_cpu(0, &thr);
+	cpumask_set_cpu(1, &thr);
+	cpumask_set_cpu(2, &thr);
+	cpumask_set_cpu(3, &thr);
+
+	spin_lock_irqsave(&freq_lock, flags);
+	for (idx = 0; idx < NR_CPUS; idx++) {
+		cpumask_and(&xlp_affected_cpus[idx], &thr, cpu_online_mask);
+		if (((idx + 1) % NLM_THREADS_PER_CORE) == 0) {
+			cpumask_shift_left(&thr, &thr, NLM_THREADS_PER_CORE);
+		}
+	}
+	spin_unlock_irqrestore(&freq_lock, flags);
+}
+
+static int __init xlp_cpufreq_init(void)
+{
+	int ret = 0;
+
+	setup_affected_cpus();
+
+	if (cpu_is_xlpii())
+		nr_tbl_entry = XLPII_DIVS;
+	else
+		nr_tbl_entry = XLP_DIVS;
+
+	xlp_freq_table = kzalloc(sizeof(*xlp_freq_table) * nr_tbl_entry,
+				 GFP_KERNEL);
+	if (!xlp_freq_table)
+		return -ENOMEM;
+
+	/* Call platform specific init() */
+	ret = xlpii_cpufreq_register_driver();
+	if (ret < 0)
+		kfree(xlp_freq_table);
+
+	return ret;
+}
+
+module_init(xlp_cpufreq_init);
+
+MODULE_AUTHOR("Sreekanth Molagavalli <sreekanth.molagavalli@broadcom.com>");
+MODULE_AUTHOR("Prem Mallappa <prem.mallappa@broadcom.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 47a34ff..619dc60 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -71,5 +71,6 @@ obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
 
+obj-$(CONFIG_CPU_XLP)		+= xlp-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/xlp-regulator.c b/drivers/regulator/xlp-regulator.c
new file mode 100644
index 0000000..f32f51b
--- /dev/null
+++ b/drivers/regulator/xlp-regulator.c
@@ -0,0 +1,450 @@
+/*
+ * Copyright (c) 2003-2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/slab.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/regulator.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/mach-netlogic/multi-node.h>
+
+//#define XLP_REGULATOR_DEBUG 1
+
+struct regulator_dev *xlp_regulator_rdev;
+
+static struct regulator_consumer_supply supply_xlp[] = {
+	{
+		.dev_name = "xlppmic",
+		.supply = "regulator_xlp", /* */
+	},
+};
+
+/*
+ * Based on need one can explore with
+ * .uV_step = XLP_VOLTAGE_STEP
+ * valid_ops_mask = |REGULATOR_CHANGE_STATUS
+ */
+static struct regulator_init_data xlp_initdata = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(supply_xlp),
+	.consumer_supplies = supply_xlp,
+};
+
+/* bus 0: SOC 1:CPU */
+int pmb_byte_tx(int bus, uint8_t slave_addr,
+		uint16_t cmd, int len, uint32_t *data)
+{
+	uint64_t sysbase;
+	uint32_t pmb_cmd = 0;
+
+	sysbase = nlm_get_node(0)->sysbase + XLP9XX_POWER_FUNC_OFFSET;
+	nlm_write_sys_reg(sysbase, PWR_PWRINTSTATUS_REG, 0x00FFFFFF);
+
+	pmb_cmd = cmd | 0x00180000 |
+		((uint32_t)(slave_addr & 0x7F) << 24);
+
+	if (bus == 1) /* default use bus 0 */
+		pmb_cmd |= 0x00800000;
+
+	pmb_cmd |= ((len - 1) & 0x03) << 16;
+	nlm_write_sys_reg(sysbase, PWR_PMBUSCMD_REG, pmb_cmd);
+	/* Write DATA register to initiate the PMBUS command */
+	nlm_write_sys_reg(sysbase, PWR_PMBUSDATA_REG, (uint32_t)(*data));
+
+	return 0;
+}
+
+int pmb_byte_rx(int bus, uint8_t slave_addr,
+		uint16_t cmd, int len, uint32_t *data)
+{
+	uint64_t sysbase;
+	uint32_t rdata, pmb_cmd = 0;
+
+	sysbase = nlm_get_node(0)->sysbase + XLP9XX_POWER_FUNC_OFFSET;
+
+	nlm_write_sys_reg(sysbase, PWR_PWRINTSTATUS_REG, 0x00FFFFFF);
+	nlm_write_sys_reg(sysbase, PWR_PMBUSDATA_REG, 0);
+	pmb_cmd = cmd | 0x00080000 | ((uint32_t)slave_addr << 24);
+
+	if (bus == 1)
+		pmb_cmd |= 0x00800000;
+
+	pmb_cmd |= ((len - 1) & 0x03) << 16;
+	nlm_write_sys_reg(sysbase, PWR_PMBUSCMD_REG, pmb_cmd);
+
+	/* Read DATA register to initiate the PMBUS command */
+	rdata = nlm_read_sys_reg(sysbase, PWR_PMBUSDATA_REG);
+
+	switch (len)
+	{
+	case 2:
+		*data = rdata & 0xFFFF;
+		break;
+	case 3:
+		*data = rdata & 0xFFFFFF;
+		break;
+	case 4:
+		*data = rdata;
+		break;
+	case 1:
+	default:
+		*data = rdata & 0xFF;
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef XLP_REGULATOR_DEBUG
+static int xlp9xx_vrm_dumppmbus(void)
+{
+	uint64_t sysbase;
+	int i,j;
+	uint32_t data;
+
+	sysbase = nlm_get_node(0)->sysbase + XLP9XX_POWER_FUNC_OFFSET;
+	printk("\n*** XLP9xx system power management reg dump ***\n");
+	for (j=0; j<0x100; j++) {
+		data = nlm_read_sys_reg(sysbase, j);
+		if (j%16==0)
+			printk("\n%llx:",sysbase+j);
+		printk(" %8x", data);
+	}
+	printk("\n*** XLP9xx system power management reg dump ***\n");
+
+	printk("\n****** TI VRM 1 ******\n");
+	for (i=0; i<0x90; i++) {
+		pmb_byte_rx(1, TI_VRM1_ADDR, i, 1, &data);
+		if (i%16==0)
+			printk("\n %x:",i);
+		printk(" %2x", data);
+	}
+
+	printk("\n****** TI VRM 2 ******\n");
+	for (i=0; i<0xfc; i++) {
+		pmb_byte_rx(1, TI_VRM2_ADDR, i, 1, &data);
+		if (i%16==0)
+			printk("\n %x:",i);
+		printk(" %2x", data);
+	}
+
+	printk("\n****** IS VRM 1 ******\n");
+	for (i=0; i<0x90; i++) {
+		pmb_byte_rx(1, IS_VRM1_ADDR, i, 1, &data);
+		if (i%16==0)
+			printk("\n %x:",i);
+		printk(" %2x", data);
+	}
+
+	printk("\n****** IS VRM 2 ******\n");
+	for (i=0; i<0x90; i++) {
+		pmb_byte_rx(1, IS_VRM2_ADDR, i, 1, &data);
+		if (i%16==0)
+			printk("\n %x:",i);
+		printk(" %2x", data);
+	}
+
+	return 0;
+}
+#endif
+
+static int xlp_get_voltage(struct regulator_dev *dev)
+{
+	uint64_t sysbase;
+	uint32_t div, nvol;
+
+	sysbase = nlm_get_node(0)->sysbase;
+	nvol = nlm_read_sys_reg(sysbase, SYS_EFUSE_DEVICE_CFG3);
+	div = nlm_read_sys_reg(sysbase, SYS_VRM_VID);
+	nvol = XLP_VOLTAGE_MAX_LMT - div * XLP_VOLTAGE_STEP;
+	return nvol;
+}
+
+static int xlp9xx_get_voltage(struct regulator_dev *dev)
+{
+	uint64_t sysbase;
+	uint32_t vid, nvol;
+	uint32_t data;
+	int xlp9xx_vid = 0x0;
+
+	sysbase = nlm_get_node(0)->sysbase + XLP9XX_SFUSE_FUNC_OFFSET;
+	/* Check any hardware fused limits */
+	vid = nlm_read_sys_reg(sysbase, FUSE_DEVICECFG3_REG) & 0xFF;
+
+	if (vid < 0xbf) {
+		vid = 0xbf; /*1.2V OR  0x83 =0.9V */
+	}
+
+	/* PMBUS , Try TI VRM first with both address, then try Intersil VRM */
+	pmb_byte_rx(1, TI_VRM1_ADDR, CMDSET_TI_VRM_VID, 2, &data);
+	if (!data)
+		pmb_byte_rx(1, TI_VRM2_ADDR, CMDSET_TI_VRM_VID, 2, &data);
+	if (!data)
+		pmb_byte_rx(1, IS_VRM1_ADDR, CMDSET_IS_VRM_VID, 2, &data);
+	if (!data)
+		pmb_byte_rx(1, IS_VRM2_ADDR, CMDSET_IS_VRM_VID, 2, &data);
+	if (!data)
+		return -1;	/* Unable to find a VRM */
+
+	xlp9xx_vid = data;
+
+	switch (data) {
+	case 0x2 ... 0x42:
+		xlp9xx_vid = 0x42; break;
+	case 0: case 1:
+	case 0xFE: case 0xFF:
+		return -1;
+	default:
+		xlp9xx_vid = vid;
+	}
+
+	nvol = XLPII_VOLTAGE_START + (XLPII_VOLTAGE_STEP * (xlp9xx_vid - 1));
+
+#ifdef XLP_REGULATOR_DEBUG
+	printk("xlp9xx voltage get base =%llx; vid= %x; \n", sysbase, vid);
+	printk("xlp9xx vid= %d; voltage=%d\n", xlp9xx_vid, nvol);
+	/*	xlp9xx_vrm_dumppmbus(); */
+#endif
+	return nvol;
+}
+
+/*
+ * Refer: XLP2XX PRM: XLP2XX_XLP1XXPR102REP
+ * Voltage Regulation and Maximum Voltage Control
+ */
+static int xlp_set_voltage_sel(struct regulator_dev *dev,
+			       unsigned selector)
+{
+	uint64_t sysbase;
+	int vid, voltage, lmt;
+
+	sysbase = nlm_get_node(0)->sysbase;
+
+	voltage = dev->desc->ops->list_voltage(dev, selector);
+	vid = (XLP_VOLTAGE_MAX_LMT - voltage) / XLP_VOLTAGE_STEP;
+
+	/* Check any hardware fused limits */
+	lmt = nlm_read_sys_reg(sysbase, SYS_EFUSE_DEVICE_CFG3);
+	if (vid < lmt)
+		vid = lmt;
+	nlm_write_sys_reg(sysbase, SYS_VRM_VID, vid);
+	return 0;
+}
+
+/*
+ * TI - hardware address 0x60
+ * Intersil - hardware address 0x70
+ */
+static int xlp9xx_set_voltage_sel(struct regulator_dev *dev,
+				  unsigned selector)
+{
+	uint64_t sysbase;
+	int vid, voltage, lmt;
+	uint32_t data;
+
+	sysbase = nlm_get_node(0)->sysbase + XLP9XX_SFUSE_FUNC_OFFSET;
+	/* Check any hardware fused limits */
+	lmt = nlm_read_sys_reg(sysbase, FUSE_DEVICECFG3_REG) & 0xFF;
+
+	if (lmt < 0xbf)
+		lmt = 0xbf; /*0x83 */
+
+	voltage = dev->desc->ops->list_voltage(dev, selector);
+	vid = ((voltage - XLPII_VOLTAGE_START) / XLPII_VOLTAGE_STEP) + 1;
+
+
+	printk("xlp9xx voltage set vid= %d; voltage=%d; sel =%d\n lmt=%d",
+	       vid, voltage, selector, lmt);
+
+	if (vid > lmt)
+		vid = lmt;
+
+	/*	nlm_write_sys_reg(sysbase, SYS_VRM_VID, vid);*/
+	/* PMBUS control of vout */
+	data = 1;
+	pmb_byte_tx(1, TI_VRM1_ADDR, CMDCTR_TI_VRM_VID, 1, &data);
+	pmb_byte_tx(1, TI_VRM2_ADDR, CMDCTR_TI_VRM_VID, 1, &data);
+	data  = 3;
+	pmb_byte_tx(1, IS_VRM1_ADDR, CMDCTR_IS_VRM_VID, 1, &data);
+	pmb_byte_tx(1, IS_VRM2_ADDR, CMDCTR_IS_VRM_VID, 1, &data);
+
+	/* set VID */
+	data = vid;
+	pmb_byte_tx(1, TI_VRM1_ADDR, CMDSET_TI_VRM_VID, 2, &data);
+	pmb_byte_tx(1, TI_VRM2_ADDR, CMDSET_TI_VRM_VID, 2, &data);
+	pmb_byte_tx(1, IS_VRM1_ADDR, CMDSET_IS_VRM_VID, 2, &data);
+	pmb_byte_tx(1, IS_VRM2_ADDR, CMDSET_IS_VRM_VID, 2, &data);
+
+	return 0;
+}
+
+static int xlp_regulator_is_enabled(struct regulator_dev *regulator) {
+	return 1;
+}
+
+static struct regulator_ops xlp9xx_ops = {
+	.map_voltage = regulator_map_voltage_linear,
+	.set_voltage_sel = xlp9xx_set_voltage_sel,
+	.get_voltage = xlp9xx_get_voltage,
+	.list_voltage = regulator_list_voltage_linear,
+	.is_enabled = xlp_regulator_is_enabled,
+};
+
+static struct regulator_ops xlp_ops = {
+	.map_voltage = regulator_map_voltage_linear,
+	.set_voltage_sel = xlp_set_voltage_sel,
+	.get_voltage = xlp_get_voltage,
+	.list_voltage = regulator_list_voltage_linear,
+	.is_enabled = xlp_regulator_is_enabled,
+};
+
+static struct regulator_desc xlp_desc = {
+	.name = "regulator-xlp",
+	.id = 0,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+	/* Rest will be filled bellow */
+};
+
+static int xlp_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_config config = { };
+	int ret;
+
+	config.dev = &pdev->dev;
+	config.init_data = &xlp_initdata;
+
+	if (cpu_is_xlpii() && !cpu_is_xlp2xx()) {
+		xlp_desc.uV_step = XLPII_VOLTAGE_STEP;
+		xlp_desc.ops = &xlp9xx_ops;
+		xlp_desc.min_uV = XLPII_VOLTAGE_START;
+		xlp_desc.n_voltages = XLPII_VOLTAGE_TABLE_SZ;
+
+		xlp_initdata.constraints.min_uV = XLPII_VOLTAGE_START;
+		xlp_initdata.constraints.max_uV = XLPII_VOLTAGE_END;
+
+	} else {
+		xlp_desc.uV_step = XLP_VOLTAGE_STEP;
+		xlp_desc.ops = &xlp_ops;
+		xlp_desc.min_uV = XLP_VOLTAGE_MIN;
+ 		xlp_desc.n_voltages = XLP_VOLTAGE_TABLE_SZ;
+
+		xlp_initdata.constraints.min_uV = XLP_VOLTAGE_MIN;
+		xlp_initdata.constraints.max_uV = XLP_VOLTAGE_MAX;
+	}
+
+	xlp_regulator_rdev = regulator_register(&xlp_desc, &config);
+
+#ifdef XLP_REGULATOR_DEBUG
+	xlp9xx_vrm_dumppmbus();
+#endif
+	if (IS_ERR(xlp_regulator_rdev)) {
+		ret = PTR_ERR(xlp_regulator_rdev);
+		pr_err("Failed to register regulator: %d\n", ret);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+static int xlp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver xlp_regulator_driver = {
+	.driver	= {
+		.name	= "xlp_regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= xlp_regulator_probe,
+	.remove		= xlp_regulator_remove,
+};
+
+static struct platform_device *xlp_pdev;
+
+static int __init xlp_regulator_init(void)
+{
+	int ret;
+
+	xlp_pdev = platform_device_alloc("xlp_regulator", 0);
+	if (!xlp_pdev) {
+		pr_err("Failed to allocate xlp regulator device\n");
+		return -EFAULT;
+	}
+
+	ret = platform_device_add(xlp_pdev);
+	if (ret != 0) {
+		pr_err("Failed to register xlp regulator device: %d\n", ret);
+		platform_device_put(xlp_pdev);
+		return -EFAULT;
+	}
+
+	ret = platform_driver_register(&xlp_regulator_driver);
+	if (ret != 0) {
+		pr_err("Failed to register xlp regulator driver: %d\n", ret);
+		platform_device_unregister(xlp_pdev);
+	}
+	return ret;
+}
+
+static void __exit xlp_cleanup(void)
+{
+	platform_driver_unregister(&xlp_regulator_driver);
+}
+
+subsys_initcall(xlp_regulator_init);
+module_exit(xlp_cleanup);
+
+MODULE_AUTHOR("Sreekanth M <sreekanth.molagavalli@broadcom.com>");
+MODULE_AUTHOR("Prem Mallappa <pmallapp@broadcom.com>");
+MODULE_DESCRIPTION("Broadcom XLP voltage regulator driver");
+MODULE_LICENSE("GPL v2");
-- 
1.7.1

