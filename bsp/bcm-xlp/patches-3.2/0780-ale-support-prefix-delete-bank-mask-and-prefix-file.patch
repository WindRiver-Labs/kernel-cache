From bdcd89b8213685d78463a20d5dde6026be98b1f3 Mon Sep 17 00:00:00 2001
From: yan sun <yansun@broadcom.com>
Date: Tue, 27 Aug 2013 12:22:16 -0700
Subject: ale: support prefix delete, bank mask and prefix file

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/alelib/ale_api.c b/arch/mips/netlogic/lib/alelib/ale_api.c
index 9684f0c..08d0ccd 100644
--- a/arch/mips/netlogic/lib/alelib/ale_api.c
+++ b/arch/mips/netlogic/lib/alelib/ale_api.c
@@ -360,12 +360,15 @@ ale_create_db(ale_t *ale,
     if (ale)
         ale_db_hw = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0];
 
-    ale_create_db_internal(prefix_table, prefix_num, ale_db_hw);
+    int node_cnt = ale_create_db_internal(prefix_table, prefix_num, ale_db_hw);
 
-   if (ale_db_hw) {
+    int shift = node_cnt/ALE_NODE_PER_BANK + ((node_cnt % ALE_NODE_PER_BANK == 0) ? 0 : 1);
+    uint8_t mask = 0x3f >> ((shift >= ALE_NODE_BANK_NUM) ? 0 : (ALE_NODE_BANK_NUM - shift));
+
+    if (ale_db_hw) {
         ale_print(ALE_DBG_INFO, "%s: ALE node base addr=%llx\n",
                   __func__, (unsigned long long)ale_virt_to_phys(ale_db_hw));
-        ale_download_node_bank(ale, fb_vc, 0x3f, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
+        ale_download_node_bank(ale, fb_vc, mask, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
     }
     return 0;
 }
@@ -393,7 +396,10 @@ ale_insert_prefix(ale_t* ale, uint16_t fb_vc, ale_prefix_t* prefix, int update_n
         for(i = 0; i < update_num - 1; i++)
             ale_insert_prefix_internal(ale, prefix++, 0);
     
-    ale_insert_prefix_internal(ale, prefix, last_update);
+    int node_cnt = ale_insert_prefix_internal(ale, prefix, last_update);
+
+    int shift = node_cnt/ALE_NODE_PER_BANK + ((node_cnt % ALE_NODE_PER_BANK == 0) ? 0 : 1);
+    uint8_t mask = 0x3f >> ((shift >= ALE_NODE_BANK_NUM) ? 0 : (ALE_NODE_BANK_NUM - shift));
 
     if(last_update){
         ale_db_entry_t* ale_db_hw;
@@ -402,7 +408,7 @@ ale_insert_prefix(ale_t* ale, uint16_t fb_vc, ale_prefix_t* prefix, int update_n
           ale_db_hw = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0]; 
           ale_print(ALE_DBG_INFO, "%s: ale_db_hw = %llx\n",
                     __func__, (long long unsigned int)ale_virt_to_phys(ale_db_hw));
-          ale_download_node_bank(ale, fb_vc, 0x3f, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
+          ale_download_node_bank(ale, fb_vc, mask, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
         }
     }
     return 0;
@@ -431,7 +437,10 @@ ale_delete_prefix(ale_t* ale, uint16_t fb_vc, ale_prefix_t* prefix, int update_n
         for(i = 0; i < update_num - 1; i++)
             ale_delete_prefix_internal(ale, prefix++, 0);
 
-    ale_delete_prefix_internal(ale, prefix, last_update);
+    int node_cnt = ale_delete_prefix_internal(ale, prefix, last_update);
+
+    int shift = node_cnt/ALE_NODE_PER_BANK + ((node_cnt % ALE_NODE_PER_BANK == 0) ? 0 : 1);
+    uint8_t mask = 0x3f >> ((shift >= ALE_NODE_BANK_NUM) ? 0 : (ALE_NODE_BANK_NUM - shift));
 
     if(last_update){
         ale_db_entry_t* ale_db_hw;
@@ -440,7 +449,7 @@ ale_delete_prefix(ale_t* ale, uint16_t fb_vc, ale_prefix_t* prefix, int update_n
           ale_db_hw = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0]; 
           ale_print(ALE_DBG_INFO, "%s: ale_db_hw = %llx\n",
                     __func__, (long long unsigned int)ale_virt_to_phys(ale_db_hw));
-          ale_download_node_bank(ale, fb_vc, 0x3f, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
+          ale_download_node_bank(ale, fb_vc, mask, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
         }
     }
     return 0;
diff --git a/arch/mips/netlogic/lib/alelib/ale_api.h b/arch/mips/netlogic/lib/alelib/ale_api.h
index 651711c..6dfe355 100644
--- a/arch/mips/netlogic/lib/alelib/ale_api.h
+++ b/arch/mips/netlogic/lib/alelib/ale_api.h
@@ -72,6 +72,7 @@
 #define ALE_NODE_DB_SIZE        (ALE_MAX_NODE / 2) * CACHELINE_SIZE 
 #define ALE_NODE_BANK_SIZE      1024 * CACHELINE_SIZE
 #define ALE_NODE_BANK_NUM       6
+#define ALE_NODE_PER_BANK       2048
 
 #define ale_write_register(base, reg, val)   nlm_hal_write_32bit_reg((uint64_t) base, (reg), (val))
 #define ale_read_register(base, reg)         nlm_hal_read_32bit_reg((uint64_t) base, (reg))
diff --git a/arch/mips/netlogic/lib/alelib/ale_node_db.c b/arch/mips/netlogic/lib/alelib/ale_node_db.c
index b0597b3..c39167e 100644
--- a/arch/mips/netlogic/lib/alelib/ale_node_db.c
+++ b/arch/mips/netlogic/lib/alelib/ale_node_db.c
@@ -36,7 +36,8 @@
 static ale_btree_node_t *btree = NULL;
 static ale_node_table_t *node_table = NULL;
 static ale_node_t *ale_db = NULL;
-static int *result_buf = NULL;
+static int *result_buf[2] = {NULL};
+static int result_buf_flag = 0;
 static int indextable[ALE_MAX_NODE] = {0}; //Index changing table, used to get index of the node table from the binary tree node
 
 static unsigned int btree_node_cnt;
@@ -77,137 +78,6 @@ ale_create_btree(ale_btree_node_t* btree,
     return node_cnt;
 }
 
-static int
-height(ale_btree_node_t* btree,
-       unsigned int node){
-
-    if(btree[node].left == 0 && btree[node].right == 0)
-        return 0;
-    else{
-        unsigned int count1 = 1;   // Start by counting the root.
-        unsigned int count2 = 1;   // Start by counting the root.
-        if(btree[node].left != 0)
-            count1 += height(btree, btree[node].left);  // Add the number of nodes in the left subtree.
-        if(btree[node].right != 0)
-            count2 += height(btree, btree[node].right); // Add the number of nodes in the right subtree
-        if(count1 >= count2)
-            return count1;
-        else
-            return count2;
-    }
-}
-
-static int
-is_tree_balanced(ale_btree_node_t* btree,
-                 unsigned int node){
-
-    int lh = 0, rh = 0, lBal = 0, rBal = 0;
-
-    if(btree[node].left == 0 && btree[node].right == 0)
-        return 1;
-    else{
-        if(btree[node].left != 0){
-            lh = height(btree, btree[node].left);
-            lBal = is_tree_balanced(btree, btree[node].left);
-        }
-        if(btree[node].right != 0){
-            rh = height(btree, btree[node].right);
-            rBal = is_tree_balanced(btree, btree[node].right);
-        }
-        if(lBal && rBal && (lh == rh))
-            return 1;
-        else
-            return 0;
-    }
-}
-
-static int
-is_dense_subtree(ale_btree_node_t* btree,
-                 unsigned int node){
-
-    return (height(btree, node) == ALE_STRIDE && is_tree_balanced(btree, node));
-}
-
-static unsigned int
-ale_set_dense_subtree(ale_btree_node_t* btree,
-                      ale_node_table_t* node_table,
-                      unsigned int root,
-                      unsigned int node,
-                      int level,
-                      unsigned int IntVal,
-                      unsigned int Intcnode){
-    ale_print(ALE_DBG_INFO, "Level %d, root %d, node %d, IntVal %d, Intcnode %d -- \n",
-              level, root, node, IntVal, Intcnode);
-    if(btree[node].index != 0 && level < (ALE_STRIDE - 1)){
-        node_table[root].BM1[IntVal/8] |= (1<<(IntVal%8));
-        node_table[root].result_buf[IntVal] = btree[node].index;        
-    }
-
-    if(level == (ALE_STRIDE-1)){
-        node_table[root].BM2[Intcnode/8] |= (1<<(Intcnode%8));
-        node_table[root].child_buf[Intcnode] = node;
-        node_table[root].node_type = ALE_NODE_TYPE_DENSE;        
-        return 1;
-    }
-    else if(btree[node].left == 0 && btree[node].right == 0){
-
-        return 1;
-    }
-    else{
-        if(btree[node].right != 0) {
-            
-            level++;
-            Intcnode = (Intcnode<<1)+1;
-            IntVal = Intcnode + (1<<(level+1)) - 1;
-            ale_set_dense_subtree(btree, node_table, root, btree[node].right, level, IntVal, Intcnode);
-            Intcnode = (Intcnode-1)>>1;
-            level--;
-        }
-
-        if(btree[node].left != 0) {            
-            level++;
-            Intcnode = (Intcnode << 1);
-            IntVal = Intcnode + (1<<(level+1)) - 1;
-            ale_set_dense_subtree(btree, node_table, root, btree[node].left, level, IntVal, Intcnode);
-            Intcnode = Intcnode >> 1;
-            level--;
-        }
-    }
-    return 1;
-}
-
-static int ale_encode_node(ale_btree_node_t* ,
-                ale_node_table_t* ,
-                unsigned int, unsigned int);
-
-static unsigned int
-ale_encode_dense_subtree(ale_btree_node_t* btree,
-                         ale_node_table_t* node_table,
-                         unsigned int node,
-                         int level) {
-
-    unsigned int flagL = 0, flagR = 0;
-
-    if(level % ALE_STRIDE == 0){
-        node_table[node_table_idx].node_type = ALE_NODE_TYPE_DENSE;
-        node_table[node_table_idx].btree_idx = node;
-        btree[node].node_index = node_table_idx;
-        ale_print(ALE_DBG_INFO, "Level %d, node %d, node_table_idx %d -- set node_table[%d] to dense node type\n",
-                  level, node, node_table_idx, node_table_idx);
-        ale_set_dense_subtree(btree, node_table, node_table_idx, node, -1, 0, 0);
-        node_table_idx++;
-    }
-
-    if(btree[node].left){
-        flagL = ale_encode_node(btree, node_table, btree[node].left, level + 1);
-    }
-
-    if(btree[node].right){
-        flagR = ale_encode_node(btree, node_table, btree[node].right, level + 1);
-    }
-    return flagL && flagR;
-}
-
 static unsigned int count_nodes(ale_btree_node_t* btree, unsigned int node){
 
     if(btree[node].left == 0 && btree[node].right == 0){
@@ -354,15 +224,9 @@ ale_encode_node(ale_btree_node_t* btree,
                 unsigned int node,
                 unsigned int level){
    
-    if(is_dense_subtree(btree, node)){
-        ale_print(ALE_DBG_INFO, "Build dense subtree\n");
-        ale_encode_dense_subtree(btree, node_table, node, level);
-    }
-    else{
-        ale_print(ALE_DBG_INFO, "Build sparse subtree\n");
-        ale_encode_sparse_subtree(btree, node_table, node, level);
-    }
-
+    ale_print(ALE_DBG_INFO, "Build sparse subtree\n");
+    ale_encode_sparse_subtree(btree, node_table, node, level);
+    
     return 1;
 }
 
@@ -389,34 +253,10 @@ ale_create_node_db(ale_db_entry_t* ale_db_hw,
    // ale_node_table node_table_tmp = node_table[node_table_idx-1]; //root node
 
     i = node_table_idx-1;
-    if(node_table[0].node_type == ALE_NODE_TYPE_DENSE)
-        i = 0;
 
     while(node_queue->size){
 
-        if(node_table[i].node_type == ALE_NODE_TYPE_DENSE){
-            ale_db[db_idx].node_type = ALE_NODE_TYPE_DENSE;
-            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
-            ale_db[db_idx].rptr = result_idx;
-
-            for(j = 0; j < max_SPARSE_node/4; j++){
-                for(k = 0; k < 8; k++){
-                    //copy result pointer and result buffer
-                    if(node_table[i].BM1[j] & (1 << k)){
-                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
-                        result_idx++;
-                    }
-                    //enqueue children
-                    if(node_table[i].BM2[j] & (1 << k)){
-                        Enqueue(node_queue, indextable[node_table[i].child_buf[j*8 + k]]);
-                    }
-                }
-                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
-                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
-            }
-        }
-
-        else if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
+        if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
             ale_db[db_idx].node_type = ALE_NODE_TYPE_SPARSE;
             //copy SBM
             for(j = 0; j < max_SPARSE_node/4; j++){
@@ -517,11 +357,16 @@ ale_create_db_internal(ale_prefix_t *prefix_table,
     ale_encode_node(btree, node_table, 0, 0);
 
     //result buffer
-    result_buf = (int*)ale_calloc(ALE_MAX_NODE, sizeof(int));
-    if (!result_buf){
+    result_buf[0] = (int*)ale_calloc(ALE_MAX_NODE, sizeof(int));
+    if (!result_buf[0]){
         ale_print(ALE_DBG_ERR, "ale result_buf calloc FAILED!\n");
     }
 
+    result_buf[1] = (int*)ale_calloc(ALE_MAX_NODE, sizeof(int));
+    if (!result_buf[1]){
+        ale_print(ALE_DBG_ERR, "ale result_buf2 calloc FAILED!\n");
+    }
+
     //ALE database
     ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
     if (!ale_db){
@@ -532,15 +377,17 @@ ale_create_db_internal(ale_prefix_t *prefix_table,
      * Build optimized ale database and update inactive node DB.
      * (0 -> NODE_BASE0, 1 -> NODE_BASE1)
      */
-    ale_create_node_db(ale_db_hw, node_table, ale_db, result_buf);
+    ale_create_node_db(ale_db_hw, node_table, ale_db, result_buf[0]);
 
     result_idx = 1;
+    int db_idx_tmp = db_idx;
     db_idx = 0;
     ale_db_hw_internal = ale_db_hw;
-    return 0;
+
+    return db_idx_tmp;
 }
 
-void ale_update_db(ale_db_entry_t* ale_db_hw,
+int ale_update_db(ale_db_entry_t* ale_db_hw,
                    ale_node_table_t* node_table, 
                    ale_node_t* ale_db, 
                    int* result_buf){
@@ -559,33 +406,9 @@ void ale_update_db(ale_db_entry_t* ale_db_hw,
     Enqueue(node_queue, node_table_idx-1);  
 
     i = node_table_idx-1;
-    if(node_table[0].node_type == ALE_NODE_TYPE_DENSE)
-        i = 0;
 
     while(node_queue->size){
-        if(node_table[i].node_type == ALE_NODE_TYPE_DENSE){
-            ale_db[db_idx].node_type = ALE_NODE_TYPE_DENSE;
-            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
-            ale_db[db_idx].rptr = result_idx;
-
-            for(j = 0; j < max_SPARSE_node/4; j++){
-                for(k = 0; k < 8; k++){
-                    //copy result pointer and result buffer
-                    if(node_table[i].BM1[j] & (1 << k)){
-                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
-                        result_idx++;
-                    }
-                    //enqueue children
-                    if(node_table[i].BM2[j] & (1 << k)){
-                        Enqueue(node_queue, indextable[node_table[i].child_buf[j*8 + k]]);
-                    }
-                }
-                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
-                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
-            }
-        }
-
-        else if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
+        if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
             ale_db[db_idx].node_type = ALE_NODE_TYPE_SPARSE;
             //copy SBM
             for(j = 0; j < max_SPARSE_node/4; j++){
@@ -644,12 +467,14 @@ void ale_update_db(ale_db_entry_t* ale_db_hw,
     ale_free(node_table);
     node_table_idx = 0;
     result_idx = 1;
+    int db_idx_tmp = db_idx;
     db_idx = 0;
+    return db_idx_tmp;
 }
 
 int ale_insert_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update){
 
-    int i, j;
+    int i, j, update_node_cnt;
     unsigned int current_node = 0; 
     
   
@@ -676,8 +501,7 @@ int ale_insert_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update
     
     if(last_update){  
         for(i = 0; i < ALE_MAX_NODE; i++){
-            indextable[i] = 0;
-            result_buf[i] = 0;            
+            indextable[i] = 0;                     
         }
         ale_free(ale_db);
         ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
@@ -690,18 +514,25 @@ int ale_insert_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update
         }   
         
         ale_encode_node(btree, node_table, 0, 0);
-        if(ale)
-            ale_db_hw_internal = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0];        
-        ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf); 
+        if(ale){
+            ale_db_hw_internal = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0]; 
+            if(ale->active_db)       
+                update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[0]); 
+            else
+                update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[1]); 
+            result_buf_flag = !result_buf_flag;
+        } 
+        else
+            update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[0]);
     }    
 
-    return 0;
+    return update_node_cnt;
 }
 
 
 int ale_delete_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update){
 
-    int i, j, total_result = 0, delete_idx = 0;
+    int i, j, update_node_cnt, total_result = 0, delete_idx = 0;
    //int  db_found;
     unsigned int current_node = 0;
     unsigned int latest_node = 0;
@@ -738,8 +569,7 @@ int ale_delete_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update
     
     if(last_update){  
         for(i = 0; i < ALE_MAX_NODE; i++){
-            indextable[i] = 0;
-            result_buf[i] = 0;            
+            indextable[i] = 0;                       
         }
         ale_free(ale_db);
         ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
@@ -751,12 +581,19 @@ int ale_delete_prefix_internal(ale_t* ale, ale_prefix_t* prefix, int last_update
             ale_print(ALE_DBG_ERR, "ale node_table calloc FAILED!\n");
         }        
         ale_encode_node(btree, node_table, 0, 0);
-        if(ale)
+        if(ale){
             ale_db_hw_internal = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0];  
-        ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf); 
+            if(ale->active_db)   
+                update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[0]); 
+            else
+                update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[1]);  
+            result_buf_flag = !result_buf_flag;
+        } 
+        else
+            update_node_cnt = ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf[0]);
     }
 
-    return 0;
+    return update_node_cnt;
 
 }
 
@@ -769,5 +606,9 @@ ale_string_search(ale_prefix_t* prefix){
 int
 ale_get_prefix_index(uint32_t ale_index){
 
-    return(result_buf[ale_index] - 1);
+    if(result_buf_flag)
+        return(result_buf[1][ale_index] - 1);
+    else
+        return(result_buf[0][ale_index] - 1);
+
 }
diff --git a/arch/mips/netlogic/lib/alelib/ale_sw_search.c b/arch/mips/netlogic/lib/alelib/ale_sw_search.c
index e937352..72c97d6 100644
--- a/arch/mips/netlogic/lib/alelib/ale_sw_search.c
+++ b/arch/mips/netlogic/lib/alelib/ale_sw_search.c
@@ -50,76 +50,6 @@ int count_ones(ale_node_t db_node, unsigned int bit, int BM){
     return ones;
 }
 
-unsigned int search_DENSE(ale_prefix_t* prefix, ale_node_t* ale_db) {
-
-    int i, length, OneCount;
-    int level = 0;
-    unsigned int ResultPtr = 0;
-    unsigned int  IntCnode = 0;
-    unsigned int  IntVal = 0;
-        
-    int node = 0; //search from Root
-    
-   // db_node = ale_db[node]; //start from root
-    length = prefix->pfx_len; 
-    
-    if(length == 0){
-        if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
-            return ale_db[node].rptr;
-
-    }
-    
-    if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
-        ResultPtr = ale_db[node].rptr;
-   
-    for(i = 0; i < length; i++){
-        level++;
-        if(prefix->prefix_string[i/32] & (1 << (31 - i%32))){//1
-            IntCnode = (IntCnode << 1) + 1; 
-            IntVal = (1<<level) - 1 + IntCnode;
-            if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
-                
-                OneCount = count_ones(ale_db[node], IntVal, 1); //check BM1             
-                ResultPtr = ale_db[node].rptr + OneCount;
-            }
-            if(level == ALE_STRIDE){
-                level = 0;
-                if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
-                    OneCount = count_ones(ale_db[node], IntCnode, 2);
-                    node = ale_db[node].cptr + OneCount;                
-                    IntCnode = 0;
-                    IntVal = 0;                    
-                    if((ale_db[node].BM1[0] & 1) == 1){                        
-                        ResultPtr = ale_db[node].rptr;
-                    }   
-                }
-            }
-        }           
-        else{//0
-            IntCnode = IntCnode << 1;    
-            IntVal = (1<<level) - 1 + IntCnode;
-            if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
-               
-                OneCount = count_ones(ale_db[node], IntVal, 1);              
-                ResultPtr = ale_db[node].rptr + OneCount;
-            }
-            if(level == ALE_STRIDE){
-                level = 0;
-                if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
-                    OneCount = count_ones(ale_db[node], IntCnode, 2);
-                    node = ale_db[node].cptr + OneCount;                  
-                    IntCnode = 0;
-                    IntVal = 0;
-                    if((ale_db[node].BM1[0] & 1) == 1){                        
-                        ResultPtr = ale_db[node].rptr;
-                    }               
-                }
-            }
-        }
-    }
-    
-    return ResultPtr;    
-}
 
 unsigned int bit_count_ones(ale_node_t db_node, unsigned int end, int BM, unsigned int start) {
 
@@ -316,177 +246,69 @@ unsigned int ale_string_search_internal(ale_prefix_t* prefix, ale_node_t* ale_db
    
     length = prefix->pfx_len; 
 
-    if(ale_db[node].node_type == ALE_NODE_TYPE_DENSE){
-        if(length == 0){
-            if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
-                return ale_db[node].rptr;
-        }
-    
-        if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
-            ResultPtr = ale_db[node].rptr;
-   
-        for(i = 0; i < length; i++){
-            level++;
-            if(prefix->prefix_string[i/32] & (1 << (31 - i%32))){//1
-                IntCnode = (IntCnode << 1) + 1; 
-                IntVal = (1<<level) - 1 + IntCnode;
-                if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
-                    OneCount = count_ones(ale_db[node], IntVal, 1); //check BM1
-                    ResultPtr = ale_db[node].rptr + OneCount;
-                }
-                if(level == ALE_STRIDE){
-                    level = 0;
-                    if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
-                        OneCount = count_ones(ale_db[node], IntCnode, 2);
-                        node = ale_db[node].cptr + OneCount;                              
-                        break;
-                    }
-                }
-            }           
-            else{//0
-                IntCnode = IntCnode << 1;    
-                IntVal = (1<<level) - 1 + IntCnode;
-                if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
-                    OneCount = count_ones(ale_db[node], IntVal, 1);
-                    ResultPtr = ale_db[node].rptr + OneCount;
-                }
-                if(level == ALE_STRIDE){
-                    level = 0;
-                    if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
-                        OneCount = count_ones(ale_db[node], IntCnode, 2);
-                        node = ale_db[node].cptr + OneCount;     
-                        break;              
-                    }
-                }
-            }
-        }
-
-        newbit = i + 1;
-        BitPos[0]=0;
-        NumNodes[0]=2;
-        EbmIdx=0;
-        IbmIdx=0;
-        i = 0;
-    
+    if(length == 0){
         if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
-            ResultPtr = ale_db[node].rptr;
-
-        for(j = newbit; j < length; j++){        
-            level++;
-            if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
-                Ibit = 1; 
-            else
-                Ibit = 0;
-            if(i == 0){
-                SbmIdx[0] = Ibit;
-                if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
-                    ResultPtr = ale_db[node].rptr;                
-                }
-            }
-            else{
-                BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
-                OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
-                NumNodes[i] = 2 * OneCount; 
-                if((SbmIdx[i-1]-1) >= BitPos[i-1])
-                    OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
-                else 
-                    OneCount = 0;
-                SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;                
-            }
- 
-            IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
-            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
-                TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//why use temp, the node is one step behind               
-            }
-            if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
-                if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
-                    ResultPtr = TempResultPtr;
-                }
-            } 
-            else {//complete this node
-                EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
-                if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node
-                    node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
-                    i = -1;
-                    BitPos[0]=0;
-                    NumNodes[0]=2;
-                    SbmIdx[0]=0;
-                    EbmIdx=0;
-                    IbmIdx=0;
-                } 
-                else{//can not find next node, finish searching
-                    break;
-                }
-            } 
-            i++;      
-        }         
-        return ResultPtr;
-    }//DENSE
-    else{//SPARSE
-        if(length == 0){
-            if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
-                return ale_db[node].rptr;
-        }   
-        BitPos[0]=0;
-        NumNodes[0]=2;
-        EbmIdx=0;
-        IbmIdx=0;
-        i = 0;
+            return ale_db[node].rptr;
+    }   
+    BitPos[0]=0;
+    NumNodes[0]=2;
+    EbmIdx=0;
+    IbmIdx=0;
+    i = 0;
     
-        if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
-            ResultPtr = ale_db[node].rptr;
+    if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+        ResultPtr = ale_db[node].rptr;
         
-        for(j = 0; j < length; j++){        
-            level++;            
-            if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
-                Ibit = 1; 
-            else
-                Ibit = 0;
-            if(i == 0){
-                SbmIdx[0] = Ibit;
-                if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
-                    ResultPtr = ale_db[node].rptr;                
-                }
-            }
-            else{
-                BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
-                OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
-                NumNodes[i] = 2 * OneCount; 
-                if((SbmIdx[i-1]-1) >= BitPos[i-1])
-                    OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
-                else 
-                    OneCount = 0;
-                SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;                
+    for(j = 0; j < length; j++){        
+        level++;            
+        if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
+            Ibit = 1; 
+        else
+            Ibit = 0;
+        if(i == 0){
+            SbmIdx[0] = Ibit;
+            if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
+                ResultPtr = ale_db[node].rptr;                
             }
+        }
+        else{
+            BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
+            OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
+            NumNodes[i] = 2 * OneCount; 
+            if((SbmIdx[i-1]-1) >= BitPos[i-1])
+                OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
+            else 
+                OneCount = 0;
+            SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;                
+        }
  
-            IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
-            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
-                TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//why use temp, the node is one step behind               
+        IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
+        if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
+            TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//why use temp, the node is one step behind               
+        }
+        if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
+            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
+                ResultPtr = TempResultPtr;
             }
-            if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
-                if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
-                    ResultPtr = TempResultPtr;
-                }
-            } 
-            else {//complete this node
-                EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
-                if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node
-                    node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
-                    i = -1;
-                    BitPos[0]=0;
-                    NumNodes[0]=2;
-                    SbmIdx[0]=0;
-                    EbmIdx=0;
-                    IbmIdx=0;
-                } 
-                else{//can not find next node, finish searching
-                    break;
-                }
+        } 
+        else {//complete this node
+            EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
+            if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node
+                node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
+                i = -1;
+                BitPos[0]=0;
+                NumNodes[0]=2;
+                SbmIdx[0]=0;
+                EbmIdx=0;
+                IbmIdx=0;
             } 
-            i++;      
-        }         
-        return ResultPtr;
-    }
+            else{//can not find next node, finish searching
+                break;
+            }
+        } 
+        i++;      
+    }         
+    return ResultPtr;    
 }
 
 
-- 
1.7.1

