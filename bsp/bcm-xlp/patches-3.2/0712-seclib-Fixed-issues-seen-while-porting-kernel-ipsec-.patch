From f9e873b9327a33685fe07a10b2c4f722772540a4 Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Wed, 12 Jun 2013 19:36:48 +0530
Subject: seclib: Fixed issues seen while porting kernel ipsec driver

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
index 38959b0..f778e76 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
@@ -142,11 +142,10 @@
 * implemented as part of this library
 *
 */
-
+#include <linux/types.h>
 #include "cryptosoc_ctx.h"
 #include "saesoc_defs.h"
 #include "cryptosoc_lib_priv.h"
-#include "nlm_hal_fmn.h"
 
 int cryptosoc_ptype_gen;
 static int cryptosoc_base_vc[CRYPTOSOC_TYPE_MAX];
@@ -570,6 +569,7 @@ int cryptosoc_new_context(
 		struct cryptosoc_ctx_params *cparam, 
 		struct cryptosoc_ctx **req_ctx)
 {
+#ifndef NLM_HAL_LINUX_KERNEL
 	int size, i;
 	struct cryptosoc_ctx *ctx = NULL;
 	struct cryptosoc_ctx_priv_data *cpriv;
@@ -666,6 +666,9 @@ err_exit:
 		free(ctx);
 	}
 	return -CRYPTOSOC_EINVAL;
+#endif
+	return CRYPTOSOC_OK;
+
 }
 
 /**
@@ -687,6 +690,7 @@ err_exit:
 */
 int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx)
 {
+#ifndef NLM_HAL_LINUX_KERNEL
 	int rv;
 	struct cryptosoc_ctx_priv_data *cpriv;
 
@@ -717,6 +721,7 @@ int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx)
 	}
 
 	free(ctx);
+#endif
 	return CRYPTOSOC_OK;
 }
 
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
index acae211..eaf827b 100644
--- a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
@@ -36,11 +36,7 @@
 #ifndef _CRYPTOSOC_LIB_H
 #define _CRYPTOSOC_LIB_H
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <unistd.h>
-#include <string.h>
+#include <nlm_hal_fmn.h>
 
 /* This should be included in the top before lib.h */
 
@@ -55,8 +51,13 @@ typedef  unsigned long long   _uint64_t;
 #define cryptosoc_is_cache_aligned(x) (((_uint64_t)x & (CRYPTOSOC_CACHELINE_SZ - 1)) == 0)
 #define cryptosoc_align(x, y)     ((x) & (~((y)-1)))
 #define cryptosoc_roundup(x, y)   (cryptosoc_align((x)+(y)-1, (y)))
+#ifndef NLM_HAL_LINUX_KERNEL
 #define cryptosoc_dbg_print(fmt, args...) printf(fmt, ##args)
 #define cryptosoc_err_print(fmt, args...) printf(fmt, ##args)
+#else
+#define cryptosoc_dbg_print(fmt, args...) printk(fmt, ##args)
+#define cryptosoc_err_print(fmt, args...) printk(fmt, ##args)
+#endif
 
 
 #define CRYPTOSOC_PTYPE_IS_GEN1 0x1
@@ -210,10 +211,29 @@ static inline unsigned int cryptosoc_get_lbs(unsigned int x)
 	return 32 - x;
 }
 
+/* find last bit cleared indication - from lsb to msb
+   clo instruction scans from msb to lsb for set bits 
+   get_lbc64(0) = 64, get_lbc64(0x80000000000000) = 63
+ */
+static inline int cryptosoc_get_lbc64(unsigned long long x)
+{
+	__asm__(".set push	\n"
+		".set mips64	\n"
+		"dclo %0, %1	\n"
+		".set pop	\n"
+		: "=r" (x) 
+		: "r" (x));
+	return 64 - x;
+}
+
 static inline void cryptosoc_lock(cryptosoc_lock_t *lock)
 {
 	unsigned int tmp, pid;
+#ifndef NLM_HAL_LINUX_KERNEL 
 	pid = getpid();
+#else
+	printk("do not call this\n");
+#endif
 
 	__asm__ __volatile__(
 			".set 	push\n"
@@ -242,7 +262,6 @@ static inline void cryptosoc_unlock(cryptosoc_lock_t *lock)
 			: "m" (lock->lock)
 			: "memory");
 }
-
 #endif //__mips__
 
 #endif
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
index 8931412..6117ce3 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
@@ -243,8 +243,8 @@ static char saesoc_gen1_hashmode[][32] = {
 "cmac",         // NLM_AUTH_MODE_CMAC
 "xcbc",         // NLM_AUTH_MODE_XCBC
 "cbc mac",      // NLM_AUTH_MODE_CBC_MAC
-"gcm",
 "ccm",
+"gcm",
 "undefined", // > max
 };
 
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
index dbf81f8..8df4582 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -117,6 +117,7 @@ struct saesoc_ddesc_priv_data {
 	int ldst_frag_idx; /* last destination fragment index */
 	int nfrag_idx; /* next available fragment index, this can be source or destination */
 	int max_descs;
+	int aad_len;
 	int ndesfb_descs;
 };
 
@@ -208,30 +209,30 @@ static int saesoc_gen1_hash_mode[SAESOC_HASH_TYPE_MAX+1] = {
 /* max iv size */
 static int saesoc_iv_size[0xf][0xf] = 
 {
-	/*                  ECB  CBC   CFB   OFB   CTR  AESF8    LRW  XTS    8   9   GCM   CCM */
-	/* AES128 */	{   0,    16,   16,  16,    6,   16,     16,  16,   0,   0,  16,   16},
-	/* AES192 */	{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  16,   16},
-	/* AES256 */	{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  16,   16},
-	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* CAMELLIA128*/{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  -1,   16},
-	/* CAMELLIA192*/{   0,    16,   16,  16,    16,  16,     15,  16,   0,   0,  -1,   16},
-	/* CAMELLIA256*/{   0,    16,   16,  16,    16,  16,     16,  16,   0,   0,  -1,   16},
-	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* BYPASS */	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* KASUMIF8*/  	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* SNOW3G F8 */ {   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* ZUC */	{  16,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* DES */   	{   0,     8,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* 3DES */  	{   0,     8,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
-	/* ARC4 */  	{   0,     0,    0,   0,     0,   0,      0,   0,   0,   0,   0,    0},
+	/*                  ECB  CBC   CFB   OFB   CTR  AESF8    LRW  XTS    GCM   CCM */
+	/* AES128 */	{   0,    16,   16,  16,    16,   16,     16,  16,   16,   16},
+	/* AES192 */	{   0,    16,   16,  16,    16,  16,     16,  16,    16,   16},
+	/* AES256 */	{   0,    16,   16,  16,    16,  16,     16,  16,    16,   16},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* CAMELLIA128*/{   0,    16,   16,  16,    16,  16,     16,  16,    -1,   16},
+	/* CAMELLIA192*/{   0,    16,   16,  16,    16,  16,     15,  16,    -1,   16},
+	/* CAMELLIA256*/{   0,    16,   16,  16,    16,  16,     16,  16,    -1,   16},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* BYPASS */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* KASUMIF8*/  	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* SNOW3G F8 */ {   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* ZUC */	{  16,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* DES */   	{   0,     8,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* 3DES */  	{   0,     8,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* ARC4 */  	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
 };
 
 /* max tag size */
 static int saesoc_gen1_tag_len[SAESOC_HASH_TYPE_MAX]= {
 
-/* AES128 */		16,
-/* AES192 */		24,
-/* AES256 */		32,
+/* AES128 */		128,
+/* AES192 */		128,
+/* AES256 */		128,
 /* BYPASS */		0, 
 /* CAMELLIA128 */	16,
 /* CAMELLIA192 */	24,
@@ -248,7 +249,7 @@ static int saesoc_gen1_tag_len[SAESOC_HASH_TYPE_MAX]= {
 /* MD5 */		128,
 /* SHA_1 */		160,
 /* SHA_224 */		224, 
-/* SHA_256 */		64,
+/* SHA_256 */		256,
 /* SHA_384 */		384,
 /* SHA_512 */		512,
 /* 3 */			0, 
@@ -310,7 +311,7 @@ struct saesoc_hash_init_params {
 		int aad_offset;
 		int addl_hash_len; 
 		unsigned int flags;
-} hash;
+}; 
 
 /**
 * struct saesoc_session_init_params - Session initialization parameters
@@ -450,6 +451,7 @@ static inline int saesoc_new_session(
 	int keyidx = 0;
 	int allocated = 0;
 	struct saesoc_session_desc  *sd;
+	struct saesoc_sdesc_priv_data *spriv ;
 
 	if(!initp || !sdesc)
 		return -CRYPTOSOC_EINVAL;
@@ -489,7 +491,7 @@ static inline int saesoc_new_session(
 	}
 
 	/* get the private info */
-	struct saesoc_sdesc_priv_data *spriv = (struct saesoc_sdesc_priv_data *)sd->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)sd->lib_priv;
 
 #ifdef SAESOC_PTYPE_GEN2_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN2
@@ -665,10 +667,14 @@ static inline int saesoc_new_session(
 		spriv->addl_hash_len = 0;
 
 		if(initp->hash.type != SAESOC_HASH_BYPASS) {
-			spriv->hash_en = 1;
-			spriv->addl_hash_len = initp->hash.addl_hash_len;
 			int hmac = initp->hash.key_len?1:0;
 			int mode ;
+			if ( (initp->hash.mode == SAESOC_HASH_MODE_XCBC) ||
+			  	(initp->hash.mode == SAESOC_HASH_MODE_GCM) || 
+				(initp->hash.mode == SAESOC_HASH_MODE_CCM))
+			       hmac = 0;	
+			spriv->hash_en = 1;
+			spriv->addl_hash_len = initp->hash.addl_hash_len;
 			if ( SAESOC_HASH_TYPE_ZUC == initp->hash.type )
 				hmac = 0;
 
@@ -874,6 +880,7 @@ static inline int saesoc_new_data_desc(
 	dpriv->nfrag_idx = 	spriv->frag_idx;
 	dpriv->max_descs = ndescs;
 	dpriv->ndesfb_descs = 0;
+	dpriv->aad_len = 0;
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	dd->descs[0] = spriv->ddesc[0];
 	dd->descs[1] = spriv->ddesc[1];
@@ -921,12 +928,14 @@ static inline int saesoc_add_frags(
 	struct saesoc_ddesc_priv_data *dpriv;
 	unsigned int maxfraglen = 1 << 16;
 	unsigned int sl, dl, max, i;
+	//printk("ddesc %p %p %p\n",ddesc,src,dst);
 
 	if(!ddesc || (!src && !dst))
 		return -CRYPTOSOC_EINVAL;
 
-	if((!src && slen) || (!dst && dlen))
+	if((!src && slen) || (!dst && dlen)) {
 		return -CRYPTOSOC_EINVAL;
+	}
 
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 
@@ -937,9 +946,9 @@ static inline int saesoc_add_frags(
 	IF_SAESOC_PTYPE_IS_GEN2
 	{
 		if((nf + dpriv->nfrag_idx) > dpriv->max_descs) {
-			cryptosoc_err_print(
-				"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
-				__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
+		//	cryptosoc_err_print(
+		//		"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
+		//		__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
 			return -CRYPTOSOC_EINVAL;
 		}
 		nf = dpriv->nfrag_idx;
@@ -1057,10 +1066,11 @@ static inline int saesoc_add_desfb_descs(
 		int desfb_vc)
 {
 	int nf, i;
+	struct saesoc_ddesc_priv_data *dpriv;
+
 	if(!ddesc || !desfb_descs)
 		return -CRYPTOSOC_EINVAL;
 
-	struct saesoc_ddesc_priv_data *dpriv;
 	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		nf = dpriv->nfrag_idx;
 		if((nf + ndesfb_descs) > dpriv->max_descs) {
@@ -1311,8 +1321,11 @@ static inline int saesoc_copy_ddesc(
 	dpriv_n->nfrag_idx = dpriv->nfrag_idx;
 	dpriv_n->max_descs = ndescs_new;
 	dpriv_n->ndesfb_descs = dpriv->ndesfb_descs;
-	for(i = 0; i < fragsused; i++) 
+	dpriv_n->aad_len = dpriv->aad_len;
+	for(i = 0; i < fragsused; i++) {
 		dd_n->descs[i] = ddesc->descs[i];
+	}
+
 
 	return CRYPTOSOC_OK;
 }
@@ -1353,7 +1366,7 @@ static inline int saesoc_set_payload_len (
 		if ( spriv->cipher_key_len_in_dw )
 			saesoc_gen1_set_cipher_len(ddesc->descs[1], payload_len);
 		if ( spriv->hash_en ) 
-			saesoc_gen1_set_hash_len(ddesc->descs[1], (payload_len+spriv->addl_hash_len));
+			saesoc_gen1_set_hash_len(ddesc->descs[1], (payload_len+spriv->addl_hash_len + dpriv->aad_len));
 		return CRYPTOSOC_OK;
 	}
 #endif
@@ -1385,7 +1398,16 @@ static inline int  saesoc_set_payload_bitcnt(
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
+		struct saesoc_ddesc_priv_data *dpriv;
+		struct saesoc_sdesc_priv_data *spriv;
+
+		if(!ddesc)
+			return -CRYPTOSOC_EINVAL;
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+		if ( spriv->cipher_key_len_in_dw )
 		saesoc_gen1_set_hash_bitcnt(ddesc->descs[2],payload_bitcnt);
+		if ( spriv->hash_en )
 		saesoc_gen1_set_cipher_bitcnt(ddesc->descs[2],payload_bitcnt);
 		return CRYPTOSOC_OK;
 	}
@@ -1487,13 +1509,29 @@ static inline int saesoc_set_aad_len(
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
 		struct saesoc_ddesc_priv_data *dpriv;
-		struct saesoc_sdesc_priv_data *spriv;
 
 		if(!ddesc)
 			return -CRYPTOSOC_EINVAL;
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
-		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
-		spriv->addl_hash_len += aad_len;
+
+		dpriv->aad_len = aad_len;
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+static inline int saesoc_set_ivoffset_payload_offset(
+		struct saesoc_data_desc *ddesc, 
+		int iv_offset, int payload_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_cipher_offset_clobber( ddesc->descs[2],
+				payload_offset,iv_offset);
 		return CRYPTOSOC_OK;
 	}
 #endif
@@ -1757,7 +1795,11 @@ static inline int saesoc_process_request(
 		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
 		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
 		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
-		nddescs = (dpriv->nfrag_idx + dpriv->ndesfb_descs)/2;
+		nddescs = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+		nddescs = ((nddescs /2) -1) + ( nddescs & 0x01);
+
+
+		
 
 		fmnentry0 = saesoc_gen1_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
 			dpriv->ndesfb_descs == 0 ? 0:1, spriv->cipher_key_len_in_dw, 
@@ -1789,6 +1831,7 @@ send_req:
 				fmnentry0, fmnentry1, fmnentry2, 
 				sync_res ? &sync_res->result : NULL,
 				rsp_msg_ptr);
+		saesoc_gen1_dump_fmnentry(fmnentry1,fmnentry2);
 	}
 }
 
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index d2a35c7..016f2e9 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1229,6 +1229,10 @@ EXPORT_SYMBOL(nlm_hal_get_sae_chip_feature);
 EXPORT_SYMBOL(nlm_hal_set_rsa_freq);
 EXPORT_SYMBOL(nlm_hal_set_dtre_freq);
 EXPORT_SYMBOL(nlm_hal_set_cde_freq);
+EXPORT_SYMBOL(nlm_hal_get_crypto_vc_nums);
+EXPORT_SYMBOL(nlm_hal_set_sae_engine_sel);
+EXPORT_SYMBOL(nlm_hal_set_rsa_engine_sel);
+EXPORT_SYMBOL(nlm_hal_get_rsa_vc_nums);
 
 EXPORT_SYMBOL(nlm_node_cfg);
 
-- 
1.7.1

