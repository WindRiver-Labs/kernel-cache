From 40db19a3f5e6adc9f322f6bf569b6d55ea1d8501 Mon Sep 17 00:00:00 2001
From: Debayan Ghosh <debayan.ghosh@broadcom.com>
Date: Tue, 22 Apr 2014 15:48:51 +0530
Subject: Compression: Added load balancing and soc frequency configuration support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
index 77d56e4..28c4ca5 100644
--- a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -133,6 +133,46 @@ enum xlp9xx_dev_sys {
 */
 
 extern unsigned long  xlp9xx_sys_clk_base[];
+
+static inline void xlp9xx_set_clkdev(int node, int dev_id, int sel, int div)
+{
+        unsigned int dev_shift;
+        int i; 
+        uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+        uint32_t val;
+
+        dev_shift = dev_id * 2;
+        /* Write the div and select register */
+        val = syssoc_read_reg(sys_clk_base, CLK_DEVSEL) & ~(0x3 << dev_shift);
+        val = val | ((sel & 0x3) << dev_shift);
+        syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
+
+        val = syssoc_read_reg(sys_clk_base, CLK_DEVDIV) & ~(0x3 << dev_shift);
+        val = val | ((div & 0x3) << dev_shift);
+        syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
+
+        /* This register determines which device's CLK_DEVSEL will be changed, device mapping  same as CLK_DEVDIS register,hardware deasserts this bit when done */
+        syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
+
+        i=0;
+        while (i++ < 10) {
+                /* Poll Change register to see if bit corresponding to our device has been deasserted */
+                val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
+                if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+                        // Check the status
+                        val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+                        if (val != sel) {
+                                nlm_print(" CLKSELDEV val 0x%x select bit is not correct exp:%d got:0x%x\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
+                        }
+                        val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+                        if (val != div) {
+                                nlm_print(" CLKSELDEV val 0x%x divide bit is not correct exp:%d got:0x%x\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
+                        }
+                        break;
+                }
+        }
+}
+
 static inline uint64_t get_nae_frequency(int node) 
 {
     uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_NET * 2;
@@ -160,30 +200,201 @@ static inline uint64_t get_nae_frequency(int node)
     return (uint64_t) (clk_freq * 1000000);
 }
 
-static inline void xlp9xx_set_clkdev(int node, int dev_id, int sel, int div)
+
+static inline uint64_t get_cmp_frequency(int node)
+{
+	uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_CMP * 2;
+	uint32_t clk_freq;
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
+	sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+	div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+	switch (sel) {
+		case 0: pll_out = 133; break;
+		case 1: pll_out = 500; break;
+		case 2: pll_out = 667; break;
+		case 3: pll_out = 767; break;
+	}
+
+	switch (div) {
+		case 0: clk_freq = pll_out; break;
+		case 1: clk_freq = pll_out/2; break;
+		case 2: clk_freq = pll_out/4; break;
+		case 3: clk_freq = pll_out/8; break;
+	}
+
+	nlm_print("sel:%d div:%d CMP_FREQUENCY :%d MHz\n", sel, div, clk_freq);
+	return (uint64_t) (clk_freq * 1000000);
+}
+
+
+static inline uint64_t get_lzs_frequency(int node)
+{
+	uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_LZS * 2;
+	uint32_t clk_freq;
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
+	sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+	div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+
+	switch (sel) {
+		case 0: pll_out = 133; break;
+		case 1: pll_out = 500; break;
+		case 2: pll_out = 667; break;
+		case 3: pll_out = 767; break;
+	}
+
+	switch (div) {
+		case 0: clk_freq = pll_out; break;
+		case 1: clk_freq = pll_out/2; break;
+		case 2: clk_freq = pll_out/4; break;
+		case 3: clk_freq = pll_out/8; break;
+	}
+
+	nlm_print("sel:%d div:%d LZS FREQUENCY :%d MHz\n", sel, div, clk_freq);
+	return (uint64_t) (clk_freq * 1000000);
+}
+
+
+static inline int xlp9xx_set_cmp_frequency(int node, uint64_t freq)
+{
+	int sel, div, dev_shift, i;
+	const uint64_t mhz = 1000000;
+	int dev_freq;
+	uint64_t cde_freq;
+	uint32_t val, dev_id = XLP9XX_CLKDEV_CMP;
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
+	cde_freq = get_cmp_frequency(node);
+
+	NLM_HAL_DO_DIV(cde_freq, mhz);
+
+	nlm_print("CDE frequency %llu MHz node :%d\n", (unsigned long long) cde_freq, node);
+
+	if (freq == get_cmp_frequency(node))
+		return 0;
+
+	NLM_HAL_DO_DIV(freq, mhz);
+	dev_freq = freq;
+	switch (dev_freq) {
+		case 133: sel = 0; div = 0; break;
+		case 66:  sel = 0; div = 1; break;
+		case 33:  sel = 0; div = 2; break;
+		case 17:  sel = 0; div = 3; break;
+		case 500: sel = 1; div = 0; break;
+		case 250: sel = 1; div = 1; break;
+		case 125: sel = 1; div = 2; break;
+		case 63:  sel = 1; div = 3; break;
+		case 667: sel = 2; div = 0; break;
+		case 333: sel = 2; div = 1; break;
+		case 167: sel = 2; div = 2; break;
+		case 83:  sel = 2; div = 3; break;
+		case 767: sel = 3; div = 0; break;
+		case 383: sel = 3; div = 1; break;
+		case 192: sel = 3; div = 2; break;
+		case 96:  sel = 3; div = 3; break;
+		default: // Set it to 667 MHz
+			  nlm_print("Can't set freq to given MHz. Setting CDE Freq to 667 MHz instead.\n");
+			  sel = 2; div = 0;
+			  dev_freq = 667;
+			  break;
+	}
+
+	dev_shift = dev_id * 2;	
+	// Write the div and select register	
+	val = ((sel & 0x3) << dev_shift);
+	syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
+
+	val = ((div & 0x3) << dev_shift);  
+	syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
+
+	// Poll Change register
+	syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
+
+	i=0;
+	while (i++ < 10) {
+		val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
+
+		if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+			// Check the status
+			val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+			if (val != sel) {
+				nlm_print("CMP CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
+			}
+			val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+			if (val != div) {
+				nlm_print("CMP CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
+			}
+			break;
+		}
+	}
+
+	nlm_print("CDE frequency changed to %d MHz\n", dev_freq);
+	return 0;
+}
+
+
+static inline int xlp9xx_set_lzs_frequency(int node, uint64_t freq)
 {
-	unsigned int dev_shift;
-	int i; 
+	int sel, div, dev_shift, i;
+	const uint64_t mhz = 1000000;
+	int dev_freq;
+	uint64_t lzs_freq;
+	uint32_t val, dev_id = XLP9XX_CLKDEV_CMP;
 	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
-	uint32_t val;
 
-	dev_shift = dev_id * 2;
-	/* Write the div and select register */
-	val = syssoc_read_reg(sys_clk_base, CLK_DEVSEL) & ~(0x3 << dev_shift);
-	val = val | ((sel & 0x3) << dev_shift);
+	lzs_freq = get_lzs_frequency(node);
+
+	NLM_HAL_DO_DIV(lzs_freq, mhz);
+
+	nlm_print("LZS frequency %llu MHz node :%d\n", (unsigned long long) lzs_freq, node);
+
+	if (freq == get_lzs_frequency(node))
+		return 0;
+
+	NLM_HAL_DO_DIV(freq, mhz);
+	dev_freq = freq;
+	switch (dev_freq) {
+		case 133: sel = 0; div = 0; break;
+		case 66:  sel = 0; div = 1; break;
+		case 33:  sel = 0; div = 2; break;
+		case 17:  sel = 0; div = 3; break;
+		case 500: sel = 1; div = 0; break;
+		case 250: sel = 1; div = 1; break;
+		case 125: sel = 1; div = 2; break;
+		case 63:  sel = 1; div = 3; break;
+		case 667: sel = 2; div = 0; break;
+		case 333: sel = 2; div = 1; break;
+		case 167: sel = 2; div = 2; break;
+		case 83:  sel = 2; div = 3; break;
+		case 767: sel = 3; div = 0; break;
+		case 383: sel = 3; div = 1; break;
+		case 192: sel = 3; div = 2; break;
+		case 96:  sel = 3; div = 3; break;
+		default: // Set it to 667 MHz
+			  nlm_print("Can't set freq to given MHz. Setting LZS Freq to 667 MHz instead.\n");
+			  dev_freq = 667;
+			  sel = 2; div = 0;
+			  break;
+	}
+
+	dev_shift = dev_id * 2;	
+	// Write the div and select register	
+	val = ((sel & 0x3) << dev_shift);
 	syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
 
-	val = syssoc_read_reg(sys_clk_base, CLK_DEVDIV) & ~(0x3 << dev_shift);
-	val = val | ((div & 0x3) << dev_shift);
+	val = ((div & 0x3) << dev_shift);  
 	syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
 
-	/* This register determines which device's CLK_DEVSEL will be changed, device mapping  same as CLK_DEVDIS register,hardware deasserts this bit when done */
+	// Poll Change register
 	syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
 
 	i=0;
 	while (i++ < 10) {
 		/* Poll Change register to see if bit corresponding to our device has been deasserted */
 		val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
+
 		if ((i==10) || ((val & (1 << dev_id)) == 0)) {
 			// Check the status
 			val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
@@ -192,11 +403,14 @@ static inline void xlp9xx_set_clkdev(int node, int dev_id, int sel, int div)
 			}
 			val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
 			if (val != div) {
-				nlm_print(" CLKSELDEV val 0x%x divide bit is not correct exp:%d got:0x%x\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
+				nlm_print("LZS CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
 			}
 			break;
 		}
 	}
+
+	nlm_print("LZS frequency changed to %d MHz\n", dev_freq);
+	return 0;
 }
 
 static inline int xlp9xx_set_gbu_frequency(int node, uint64_t freq)
@@ -545,5 +759,4 @@ static inline int xlp9xx_set_dtre_frequency(int node, uint64_t freq)
     return 0;
 }
 
-
 #endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index a34f363..6348663 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1062,6 +1062,9 @@ void nlm_hal_set_cde_freq(int node, int freq)
 	if(is_nlm_xlp2xx()) {
 		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_CMP, freq * mhz);
 	}
+	else if (is_nlm_xlp9xx()) {
+		xlp9xx_set_soc_frequency(node, XLP9XX_CLKDEV_CMP, freq * mhz);
+	}
 	else {
 		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_CMP, freq * mhz);
 		NLM_HAL_DO_DIV(set_freq, mhz);
@@ -1069,6 +1072,31 @@ void nlm_hal_set_cde_freq(int node, int freq)
 	}
 }
 
+/* LZS SUPPORT
+*/
+/**
+ * @brief nlm_hal_set_lzs_freq function sets the frequency of the LZS block.
+ *
+ * @param [in] node Node number
+ * @param [in] freq Frequency to set in MHz
+ *
+ * @return
+ *       - none
+ *
+ * @ingroup hal
+ *
+ */
+void nlm_hal_set_lzs_freq(int node, int freq)
+{
+	const uint64_t mhz = 1000000;
+	nlm_print("-- LZS requested Frequency : %d\n", freq);
+	if (is_nlm_xlp9xx()) {
+		xlp9xx_set_soc_frequency(node, XLP9XX_CLKDEV_LZS, freq * mhz);
+	}
+	else
+		nlm_print("Invalid request for LZS frequency operation\n");
+}
+
 /* DTRE SUPPORT
  */
 /**
-- 
1.7.1

