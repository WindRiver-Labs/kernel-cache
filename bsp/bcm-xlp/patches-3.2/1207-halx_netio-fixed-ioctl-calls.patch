From 73d25305ef32b52b8dba5768767b810d927e729c Mon Sep 17 00:00:00 2001
From: Saswat Dash <saswat.dash@broadcom.com>
Date: Wed, 26 Feb 2014 15:50:28 +0530
Subject: halx_netio : fixed ioctl calls

1. removed KVM_GUEST_MODE_EN check for ioctls in halx
2. same ioctl calls should handle root and guest mode
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/halx_netio/halx_netio_main.c b/drivers/misc/netlogic/halx_netio/halx_netio_main.c
index 2b0b837..9afa15b 100644
--- a/drivers/misc/netlogic/halx_netio/halx_netio_main.c
+++ b/drivers/misc/netlogic/halx_netio/halx_netio_main.c
@@ -48,6 +48,7 @@
 static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	int rc = 0, retval = 0;
+	void __user *argp = (void __user *)arg;
 
 	switch(cmd) {
 
@@ -55,14 +56,19 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
+		halx_domain_t *u_ctx = NULL;
 		halx_domain_t *ctx_dom_data = (halx_domain_t *)kmalloc(sizeof(halx_domain_t), GFP_KERNEL);
 
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
 			return -1;
 		}
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
 
-		retval = copy_from_user(ctx_dom_data, (halx_domain_t *)arg, sizeof(halx_domain_t));
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_domain_t));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -75,24 +81,31 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to register halx\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((halx_domain_t *)arg, ctx_dom_data, sizeof(halx_domain_t));
+			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_domain_t));
 			if (retval) {
 				printk("halx_netio: halif %d bytes not copied to user space \n",retval);
 			}
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_NET_INIT:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
-
+		halx_linux_net_arg *u_ctx = NULL;
 		halx_linux_net_arg *ctx_dom_data = (halx_linux_net_arg *)kmalloc(sizeof(halx_linux_net_arg), GFP_KERNEL);
+
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (halx_linux_net_arg *)arg, sizeof(halx_linux_net_arg));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_linux_net_arg));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -105,24 +118,26 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX NET INIT\n");
 			rc = -1;
 		} else {
-                        retval = copy_to_user((halx_linux_net_arg *)arg, ctx_dom_data, sizeof(halx_linux_net_arg));
+                        retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_linux_net_arg));
                         if (retval) {
                                 printk("halx_netio: halif %d bytes not copied to user space \n",retval);
                         }
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_OPEN_PORT:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
+		unsigned long *ctx_dom_data = (unsigned long *)kmalloc(sizeof(unsigned long), GFP_KERNEL);
 
-		unsigned long *ctx_dom_data = (unsigned long *)kmalloc(2 * sizeof(unsigned long), GFP_KERNEL);
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_OPEN_PORT\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (unsigned long *)arg, 2 * sizeof(unsigned long));
+
+		retval = copy_from_user(ctx_dom_data, (unsigned long *)argp, sizeof(unsigned long));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -135,24 +150,31 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX OPEN PORT\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((unsigned long *)arg, ctx_dom_data, 2 * sizeof(unsigned long));
+			retval = copy_to_user((unsigned long *)argp, ctx_dom_data, sizeof(unsigned long));
  			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                                printk("halx_netio: halif %d bytes not copied to user space\n",retval);
                         }
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_CLOSE_PORT:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
+		halx_port_op_t *u_ctx = NULL;
+		halx_port_op_t *ctx_dom_data = (unsigned long *)kmalloc(sizeof(halx_port_op_t), GFP_KERNEL);
 
-		unsigned long *ctx_dom_data = (unsigned long *)kmalloc(2 * sizeof(unsigned long), GFP_KERNEL);
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CLOSE_PORT\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (unsigned long *)arg, 2 * sizeof(unsigned long));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_port_op_t));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -165,24 +187,31 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX CLOSE PORT\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((unsigned long *)arg, ctx_dom_data, 2 * sizeof(unsigned long));
+			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_port_op_t));
  			if (retval) {
                                 printk("halx_netio: halif %d bytes not copied to user space \n",retval);
                         }
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_CONFIG_PORT:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
-
+		halx_config_port_io *u_ctx = NULL;
 		halx_config_port_io *ctx_dom_data = (halx_config_port_io *)kmalloc(sizeof(halx_config_port_io), GFP_KERNEL);
+
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CONFIG_PORT\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (halx_config_port_io *)arg, sizeof(halx_config_port_io));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_config_port_io));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -195,19 +224,26 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX CONFIG PORT\n");
 			rc = -1;
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_DEV_INFO:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
-
+		halx_dev_info *u_ctx;
 		halx_dev_info *ctx_dom_data = (halx_dev_info *)kmalloc(sizeof(halx_dev_info), GFP_KERNEL);
+
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_DEV_INFO\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (halx_dev_info *)arg, sizeof(halx_dev_info));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_dev_info));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -220,24 +256,31 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX DEV INFO\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((halx_dev_info *)arg, ctx_dom_data, sizeof(halx_dev_info));
+			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_dev_info));
  			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                                printk("halx_netio: halif %d bytes not copied to user space\n",retval);
                         }
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_PKT_ENGINE:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
-
+		halx_arg_attr_pktengine *u_ctx = NULL;
 		halx_arg_attr_pktengine *ctx_dom_data = (halx_arg_attr_pktengine *)kmalloc(sizeof(halx_arg_attr_pktengine), GFP_KERNEL);
+
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_ENGINE\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (halx_arg_attr_pktengine *)arg, sizeof(halx_arg_attr_pktengine));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_arg_attr_pktengine));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -250,24 +293,31 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX PKT ENGINE\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((halx_arg_attr_pktengine *)arg, ctx_dom_data, sizeof(halx_arg_attr_pktengine));
+			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_arg_attr_pktengine));
  			if (retval) {
                                 printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-                        }
+			}
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	case HALX_CMD_PKT_PARSER:
 	{
 		uint64_t ret = 0;
 		unsigned long phy_ctx_dom_data = 0;
-
+		halx_conf_parser_t *u_ctx;
 		halx_conf_parser_t *ctx_dom_data = (halx_conf_parser_t *)kmalloc(sizeof(halx_conf_parser_t), GFP_KERNEL);
+
 		if (ctx_dom_data == NULL) {
 			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_PARSER\n");
 			return -1;
 		}
-		retval = copy_from_user(ctx_dom_data, (halx_conf_parser_t *)arg, sizeof(halx_conf_parser_t));
+		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+
+		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_conf_parser_t));
 		if (retval) {
 			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
 		}
@@ -280,11 +330,12 @@ static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long
 			printk(KERN_ERR "halx_netio: failure to HALX PKT PARSER:\n");
 			rc = -1;
 		} else {
-			retval = copy_to_user((halx_conf_parser_t *)arg, ctx_dom_data, sizeof(halx_conf_parser_t));
+			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_conf_parser_t));
  			if (retval) {
                                 printk("halx_netio: halif %d bytes not copied to user space \n",retval);
                         }
 		}
+		kfree(ctx_dom_data);
 		break;
 	}
 	default:
-- 
1.7.1

