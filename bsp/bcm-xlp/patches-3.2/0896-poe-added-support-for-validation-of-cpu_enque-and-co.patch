From 06507e9709afc576473e446ec4f45b18fb5ee91a Mon Sep 17 00:00:00 2001
From: Abhishek Joshi <abjoshi@broadcom.com>
Date: Sun, 16 Feb 2014 22:22:21 +0530
Subject: poe: added support for validation of cpu_enque and context class mapping

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index dfdbf04..c986d49 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -38,6 +38,12 @@
 
 #define XLP9XX_SYSDEVICERESET     0x3c
 
+#define NUM_VALID_CPU_ENQ_MAPS		5
+#define NAE_RX_CLASS_INVALID		0
+#define NAE_RX_CLASS_VALID		1
+#define MIN_VALID_CLASS_INDX		0
+#define MAX_VALID_CLASS_INDX		1
+
 extern struct netsoc_info *current_netsoc;
 
 enum netv1_nae_reg{
@@ -59,6 +65,22 @@ enum net_path{
 	INGRESS_PATH,
 };
 
+/*
+ List of valid nae_rx classes when cpu enque mode ("class-map-mode" field
+ in dts) is enabled. Valid Range of classes for a "mode" is given  by
+ (valid_nae_rx_class[mode][0] -  valid_nae_rx_class[mode][1])
+*/
+
+static int valid_nae_rx_class[NUM_VALID_CPU_ENQ_MAPS][2] =
+{
+	{0,7},
+	{0,3},
+	{0,4},
+	{0,5},
+	{0,6}
+
+};
+
 #define DEFAULT_PARSER_THR		384 //448 //384
 #define VAL_UCORE_RESET(x) 		(((x) &0xffff) << 8)
 #define NLM_NAE_MAX_XONOFF_THR_GRPS 	8
@@ -1117,13 +1139,28 @@ static inline int __netsoc_nae_config_txrx(nae_t *nae, uint32_t enable, uint32_t
         return NETSOC_API_SUCCESS;
 }
 
+/*
+ Tries to map the passed context to the desired class.
+ If cpu_enqueue mode is enabled, checks for the validity
+ of the class. Traffic should be stopped before calling 
+ this function.
+*/
+
 static inline int __netsoc_map_context_toclass(nae_t *nae, uint32_t context, uint32_t class)
 {
-    	uint32_t val, index, ctxindex;
+	uint32_t val, index, ctxindex, cpu_poe_class_map;
 
         if (context >= current_netsoc->max_contexts)
               return -NETSOC_API_PARAM_INVALID;
 
+	cpu_poe_class_map = nae->poe->cpu_poe_class_map;
+	if (cpu_poe_class_map) {
+		if (class > valid_nae_rx_class[cpu_poe_class_map][MAX_VALID_CLASS_INDX] || class < valid_nae_rx_class[cpu_poe_class_map][MIN_VALID_CLASS_INDX]){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "%s Invalid NAE_RX TO POE Class Mapping\n", __func__);
+			return -NETSOC_API_PARAM_INVALID;
+		}
+	}
+
 	index = context / 8;
 	netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, (1<<7) | index);
         val = netsoc_read_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
index cb71934..f4c6da3 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_poe.h
@@ -265,6 +265,9 @@ static inline int __netsoc_poe_config_class_map(poe_t *poe, class_map_t mode)
             return -NETSOC_API_PARAM_INVALID;
 
         netsoc_write_poe_pcie_reg(poe->pcie_base, POE_CPUENQ_CLASS_MAP_MODE, mode);
+	if (mode) {
+		poe->cpu_poe_class_map = mode;
+	}
         return 0; 
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 654e452..44b0834 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -288,6 +288,7 @@ struct poe_config {
         uint64_t din_spill_base;
         uint32_t din_spill_size;
         uint32_t default_thr_sel; 
+        uint32_t cpu_poe_class_map;
 	nae_t *nae;		
 };
 
@@ -423,8 +424,6 @@ struct nlm_hal_nae_config {
        
         uint32_t cpu_bypass_mode;  /* ucore cpu bypass mode enable */
 	uint32_t default_class;
-	uint32_t poe_class_en;	/* If set to 1 then context to poe class mapping is enabled */
-	uint32_t *poe_cl_tbl;
         /* ALE */
         uint32_t ale_enable;
 	uint32_t parser_enable;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 9b5ee9a..bafd265 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -492,7 +492,6 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
                 nae->cntx2port[i] = MAX_NAE_PORTS_PERNODE;
         }
 	nae->default_class = 0;
-	nae->poe_class_en = 0;
 	__netsoc_set_frin_queue_base(nae);
 	__netsoc_set_frin_total_queue(nae);
 	
@@ -517,6 +516,7 @@ static void __netsoc_update_poe_defaultconfig(poe_t *poe)
         }else{   
                 poe->poe_queue_base = (poe->node << 10) | XLP_POE_VC_BASE;
         }
+	poe->cpu_poe_class_map=0;
 
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 84ee86d..5ad5b1d 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1232,6 +1232,14 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
                         poe->dest_threshold = fdt32_to_cpu(*(uint32_t *)(pval)) & 0xFFFF;
                 }
 
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "class-map-mode", &plen);
+		if (pval != NULL) {
+			poe->cpu_poe_class_map = fdt32_to_cpu(*(uint32_t *)(pval));
+		}
+		else {
+			poe->cpu_poe_class_map = 0;
+		}
+
                 pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "statistics-enable", &plen);
                 if (pval != NULL) {
                         poe->stats_en = fdt32_to_cpu(*(uint32_t *)(pval));
@@ -1357,63 +1365,6 @@ int fdt_get_nae_frequency(void *fdt, nae_t *nae)
         return 0;
 }
 
-int fdt_get_nae_poe_class_config(void *fdt, nae_t *nae)
-{
-	int nodeoffset, plen;
-	char path_str[50];
-	uint32_t *pval;
-
-	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
-
-	nodeoffset = fdt_path_offset(fdt, path_str);
-	if (nodeoffset >= 0) {
-		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "poe-class-context-enable", &plen);
-		if (pval != NULL) {
-			nae->poe_class_en = fdt32_to_cpu(*(uint32_t *)(pval));
-		}
-		else {
-			nae->poe_class_en = 0;
-		}
-	}
-	return 0;
-}
-
-int fdt_update_poe_class_tbl(void *fdt, nae_t *nae)
-{
-	int nodeoffset, plen;
-	char path_str[50];
-	uint32_t *pval;
-	int i, plen_index = 0;
-	int size = 0;
-	int index = 0;
-	uint32_t ctx = 0;
-	
-	/* allocating memory for poe class table */
-	size = sizeof(uint32_t) * (MAX_POE_CLASSES * POE_CTX_RANGE_WD);
-	nae->poe_cl_tbl = netsoc_api_malloc(size);
-	if (nae->poe_cl_tbl == NULL) {
-		netsoc_api_print(NETSOC_APIDBG_ERROR,"poe class tbl memory allocation failed");
-		return NETSOC_API_MALLOC_FAILED;
-        }
-	memset(nae->poe_cl_tbl, 0, size);
-
-	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
-
-	nodeoffset = fdt_path_offset(fdt, path_str);
-	if (nodeoffset >= 0) {
-		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "class-context-map", &plen);
-		plen /= sizeof(unsigned int);
-		plen_index = plen - 1;
-		if (pval != NULL) {
-			for (i = plen_index; i >= 0; i--) {
-				ctx = fdt32_to_cpu(pval[i]);
-				index = (plen_index - i);
-				nae->poe_cl_tbl[index] = ctx;
-			}
-		}
-	}
-	return 0;
-}
 
 int fdt_get_nae_ale_config(void *fdt, nae_t *nae)
 {
@@ -1599,11 +1550,6 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 		return 0;
 	}
 
-	fdt_get_nae_poe_class_config(fdt, nae);
-	if (nae->poe_class_en) {
-		fdt_update_poe_class_tbl(fdt, nae);
-	}
-
         if (current_netsoc->hw_features & NETSOC_ALE)
             fdt_get_nae_ale_config(fdt, nae);
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 657876f..5c6608d 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1109,6 +1109,20 @@ Returns:
 	0 on success
 */
 
+
+static int validate_nae_rx_class_map(nae_t *nae, uint32_t class)
+{
+
+	int cntx, class_map = nae->poe->cpu_poe_class_map;
+	if (class >= valid_nae_rx_class[class_map][MIN_VALID_CLASS_INDX] &&
+			class <= valid_nae_rx_class[class_map][MAX_VALID_CLASS_INDX]) {
+		return NAE_RX_CLASS_VALID;
+	}
+	else {
+		return NAE_RX_CLASS_INVALID;
+	}
+}
+
 int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl)
 {
 	int vfbid;
@@ -1127,20 +1141,6 @@ int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries
 	return NETSOC_API_SUCCESS;
 }
 
-static int get_poe_class_num(nae_t *nae, int ctx_num)
-{
-	int i;
-	int class_num = 0;
-
-	for (i = 0; i < (MAX_POE_CLASSES * POE_CTX_RANGE_WD); i += POE_CTX_RANGE_WD) {
-		if ((ctx_num >= nae->poe_cl_tbl[i]) && 
-				(ctx_num <= nae->poe_cl_tbl[i+1])) {
-			class_num = i / POE_CTX_RANGE_WD;
-			break;
-		}
-	}
-	return class_num;
-}
 
 /* __netsoc_config_poe_class: configure context to poe class mapping.
  *
@@ -1152,7 +1152,7 @@ static int get_poe_class_num(nae_t *nae, int ctx_num)
  * Above step is repeated for all table entries upto max_poe_tbl_sz.
  **/
 
-void __netsoc_config_poe_class(nae_t *nae)
+int __netsoc_config_poe_class(nae_t *nae)
 {
         int i, j;
         uint32_t val, cval;
@@ -1169,27 +1169,23 @@ void __netsoc_config_poe_class(nae_t *nae)
 		max_poe_tbl_sz++;
 
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "max_poe_tbl_sz %d\n",max_poe_tbl_sz);
-	if (nae->poe_class_en) {
-		netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s context to poe class mapping enabled \n",__func__);
+
+	if (nae->poe->cpu_poe_class_map) {
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s cpu enqueue class mapping enabled \n",__func__);
+		if (!(validate_nae_rx_class_map(nae, (nae->default_class & 0x7)))) {
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "%s Invalid NAE_RX TO POE Class Mapping\n", __func__);
+			return -NETSOC_API_ERROR;
+		}
 	}
 
         for (i = 0; i <max_poe_tbl_sz; ++i) {
                 val = (0x00 | i); /* clear the read bit 0x80 */
-		if (nae->poe_class_en) {
-			cval = 0;
-			ctx_num = (i * MAX_CTX_PER_ENTRY);
-			for (j = 0; j < MAX_CTX_PER_ENTRY; j++, ctx_num++) {
-				class_num = get_poe_class_num(nae, ctx_num);
-				cval |= ((class_num & POE_CLASS_MASK) << (j * POE_CLASS_BIT_SZ));
-			}
-                	val |= (cval << 8);
-		} else {
-                	val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
-		}
+                val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
 
                 netsoc_api_print(NETSOC_APIDBG_CONFIG, "POE index %d val %x \n",i, val);
                 netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val);
         }
+	return NETSOC_API_SUCCESS;
 }
 
 void __netsoc_config_context_xoff_thr(nae_t *nae, net_port_t *netport, int thgrp, int maxbuf, int mtu_len)
@@ -1511,13 +1507,16 @@ void __netsoc_config_ingress_fifo(nae_t *nae)
         }
 }
 
-void __netsoc_config_nae_global(nae_t *nae)
+int __netsoc_config_nae_global(nae_t *nae)
 {
 	uint32_t vfbid = 0, i = 0;
         volatile uint32_t val = 0;
         uint32_t dest;
 
-	__netsoc_config_poe_class(nae);
+	if (__netsoc_config_poe_class(nae) < 0){
+		netsoc_api_print (NETSOC_APIDBG_ERROR,"%s: poe class config failed\n",__func__);
+		return -1;
+	}
 
 	if (nae->flags & FREEBACK_TO_NAE) {
                 dest = nae->frin_queue_base;
@@ -1560,6 +1559,7 @@ void __netsoc_config_nae_global(nae_t *nae)
 		__netsoc_config_tx_calendar(nae);
 
 	__netsoc_config_flow_base(nae); // must be after one of the above functions.
+	return NETSOC_API_SUCCESS;
 }
 
 void  __netsoc_setparser_seq_thold(nae_t *nae , int thrs)
@@ -4284,7 +4284,10 @@ int __netsoc_init_nae(nae_t *nae)
         	        netsoc_write_nae_reg(nae->nae_base, TX_CONFIG, tx_config);
         	}
 
-	        __netsoc_config_nae_global(nae);
+	        if (__netsoc_config_nae_global(nae) < 0) {
+			netsoc_api_print(NETSOC_APIDBG_ERROR,"%s: global config for nae failed\n", __func__);
+			return -1;
+		}
 
         	if (nae->flags & VFBID_FROM_FDT) {
                 	__netsoc_config_vfbid_table(nae, 0 , MAX_VFBID_ENTRIES, nae_vfbid_tbl[nae->node][nae->nae_id]);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
index e9e00d1..189f461 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_poe.c
@@ -505,6 +505,13 @@ int __netsoc_init_poe(poe_t *poe)
 #endif	
 	__netsoc_poe_loc_msg_storage(poe);
 
+	if (poe->cpu_poe_class_map) {
+		if (__netsoc_poe_config_class_map(poe, poe->cpu_poe_class_map) < 0) {
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "%s: Invalid cpu to poe class map: Valid modes: 0-4\n", __func__);
+			return -NETSOC_API_PARAM_INVALID;
+		}
+	}
+
 	if (poe->poe_address_map > 0ULL && poe->poe_address_len > 0) 
         	__netsoc_init_poe_enq_deq_spill(poe, poe->poe_address_map, poe->poe_address_len);
 
-- 
1.7.1

