From 4b4cdcac12f50296ca4eec98c1c10c552b803402 Mon Sep 17 00:00:00 2001
From: Subhendu Sekhar Behera <sbehera@broadcom.com>
Date: Thu, 28 Aug 2014 15:11:33 +0530
Subject: MIPS: Netlogic: Support for reset using on board CPLD

Support using the on-board CPLD to reset the board instead of the standard
chip reset. This is needed on multi-node boards
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index bcf3a18..98f70d4 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -1,4 +1,5 @@
 obj-y				+= setup.o nlm_hal.o dt.o c-xlp.o
+obj-y				+= cpld.o
 obj-$(CONFIG_SMP)		+= wakeup.o
 obj-$(subst m,y,$(CONFIG_USB))	+= usb-init.o
 obj-$(subst m,y,$(CONFIG_USB))	+= usb-init-xlp2.o
diff --git a/arch/mips/netlogic/xlp/cpld.c b/arch/mips/netlogic/xlp/cpld.c
new file mode 100644
index 0000000..259d67c
--- /dev/null
+++ b/arch/mips/netlogic/xlp/cpld.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2003-2014 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <linux/kernel.h>
+#include <linux/of_fdt.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/pm.h>
+
+#include <asm/io.h>
+#include <asm/reboot.h>
+
+#define CPLD_DEFAULT_IO_WIDTH		2
+
+#define CPLD_DEFAULT_VERSION_REG	0
+#define CPLD_DEFAULT_RESET_REG		1
+
+struct xlp_cpld_data {
+	void __iomem	*reset_reg;
+	void __iomem	*version_reg;
+	unsigned int	reg_io_width;
+	unsigned int	little_endian;
+	struct device *dev;
+};
+
+static struct xlp_cpld_data cpld_data;
+
+static uint32_t xlp_read_cpld_reg(struct xlp_cpld_data *cpld, void __iomem *reg)
+{
+	u32 val = 0;
+
+	switch (cpld->reg_io_width) {
+	case 1:
+		val = __raw_readb(reg);
+		break;
+	case 2:
+		val = __raw_readw(reg);
+		if (cpld->little_endian)
+			val = le16_to_cpu(val);
+		else
+			val = be16_to_cpu(val);
+		break;
+	case 4:
+		val = __raw_readl(reg);
+		if (cpld->little_endian)
+			val = le32_to_cpu(val);
+		else
+			val = be32_to_cpu(val);
+	}
+	return val;
+}
+
+static void xlp_write_cpld_reg(struct xlp_cpld_data *cpld, void __iomem *reg,
+	u32 val)
+{
+	switch (cpld->reg_io_width) {
+	case 1:
+		__raw_writeb(val, reg);
+		break;
+	case 2:
+		if (cpld->little_endian)
+			val = le16_to_cpu(val);
+		else
+			val = be16_to_cpu(val);
+		__raw_writew(val, reg);
+		break;
+	case 4:
+		if (cpld->little_endian)
+			val = le32_to_cpu(val);
+		else
+			val = be32_to_cpu(val);
+		__raw_writel(val, reg);
+	}
+}
+
+static void xlp_print_cpld_version(struct platform_device *pdev,
+	struct xlp_cpld_data *cpld)
+{
+	u32 rev;
+	u32 maj, min;
+
+	rev = xlp_read_cpld_reg(cpld, cpld->version_reg);
+	switch (cpld->reg_io_width) {
+	case 1:
+		min = 0;
+		maj = rev;
+		break;
+	case 2:
+		min = rev & 0xff;
+		maj = (rev & 0xff00) >> 8;
+		break;
+	case 4:
+		min = rev & 0xffff;
+		maj = (rev & 0xffff0000) >> 16;
+		break;
+	default:
+		min = 0;
+		maj = 0;
+	}
+	dev_info(&pdev->dev, "CPLD rev %d.%d initialized.\n", maj, min);
+}
+
+static void xlp_cpld_reset(void *cmd)
+{
+	xlp_write_cpld_reg(&cpld_data, cpld_data.reset_reg, 0);
+}
+
+static void xlp_of_cpld_linux_exit(void)
+{
+	/* work-around to execute the reboot function on node 0 */
+#ifdef CONFIG_NLM_MULTINODE
+	dev_info(cpld_data.dev, "CPLD reset on multinode board.\n");
+	smp_call_function_any(cpumask_of_node(0), xlp_cpld_reset, NULL, 0);
+#else
+	dev_info(cpld_data.dev, "CPLD reset.\n");
+	xlp_cpld_reset(NULL);
+#endif
+}
+
+static int xlp_of_cpld_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device_node *np;
+	void __iomem *base;
+	u32 prop;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Could not get MEM resource!\n");
+		return -ENOMEM;
+	}
+
+	base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!base) {
+		dev_err(&pdev->dev, "Device IO mapping failed!\n");
+		return -EINVAL;
+	}
+
+	np = pdev->dev.of_node;
+
+	if (of_property_read_u32(np, "reg-io-width", &prop) == 0)
+		cpld_data.reg_io_width = prop;
+	else
+		cpld_data.reg_io_width = CPLD_DEFAULT_IO_WIDTH;
+
+	if (of_property_read_u32(np, "reset-reg", &prop) != 0)
+		prop = CPLD_DEFAULT_RESET_REG;
+	cpld_data.reset_reg = base + prop;
+
+	if (of_property_read_u32(np, "version-reg", &prop) != 0)
+		prop = CPLD_DEFAULT_VERSION_REG;
+	cpld_data.version_reg = base + prop;
+
+	if (of_property_read_bool(np, "little-endian"))
+		cpld_data.little_endian = 1;
+	else
+		cpld_data.little_endian = 0;
+
+	cpld_data.dev = &pdev->dev;
+
+	/* hook the reboot functions to xlp_of_cpld_linux_exit */
+	_machine_restart = (void (*)(char *))xlp_of_cpld_linux_exit;
+	_machine_halt = xlp_of_cpld_linux_exit;
+	pm_power_off = xlp_of_cpld_linux_exit;
+
+	xlp_print_cpld_version(pdev, &cpld_data);
+	return 0;
+}
+
+static struct of_device_id xlp_cpld_ids[] = {
+	{ .compatible = "netlogic,xlp-cpld",},
+	{},
+};
+
+static struct platform_driver xlp_cpld_driver = {
+	.driver		= {
+		.owner  = THIS_MODULE,
+		.name   = "xlp-cpld",
+		.of_match_table = xlp_cpld_ids,
+	},
+	.probe		= xlp_of_cpld_probe,
+};
+
+static int __init xlp_init_cpld(void)
+{
+	return platform_driver_register(&xlp_cpld_driver);
+}
+postcore_initcall(xlp_init_cpld);
-- 
1.7.1

