From cdf7e314b8d8fe94e1cdde498bb4ed291125bf02 Mon Sep 17 00:00:00 2001
From: Sreenidhi B R <sreenira@broadcom.com>
Date: Wed, 11 Sep 2013 01:25:50 -0700
Subject: fmnlib: outq configuration changed, now assuming 32 entries per page.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 8b135ea..300c90a 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -224,7 +224,7 @@ nlm_fmn_config_t xlp9xx_fmn_config[] = {
 
 extern struct nlm_node_config nlm_node_cfg;
 
-/*#define FMN_DEBUG 1 */
+/* #define FMN_DEBUG 1 */
 
 static unsigned int fmn_cfg_value[XLP_NET_VC_LIMIT + 1];
 static unsigned int fmn_default_credits = XLP_FMN_DEFAULT_CREDITS;
@@ -991,7 +991,7 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 
 	const uint32_t ram_base = 0;
 	uint32_t q_ram_base = 0;
-	uint32_t q_ram_start_page = 0;
+	uint32_t q_ram_start_page = 0, q_ram_end_page = 0;
 	const int q_ram_pages = 1;
 	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
 	const uint32_t q_ram_page_entries_9xx = 64; /* entries, not bytes */
@@ -1025,11 +1025,28 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 				/* enable output queue and setup on-chip output queue */
 				val = 1ULL << 63; /* enable */
 
-				q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries_9xx);
-				val |= ( ((q_ram_base >> 12) & 0x1f) << 12); /* [16:12] of q_ram_base */
-				q_ram_start_page = (q_ram_base >> 6) & 0x3f; /* [11:6] of q_ram_base */
-				val |= (q_ram_start_page << 0);
-				val |= ( (q_ram_start_page + q_ram_pages - 1) << 6);
+				/* here, we are assuming that each page
+				   has 32 entries.  Hence, each outq is configured
+				   for 2 pages (or 64 entries) */
+
+				if((q_ram_start_page+ 2) > q_ram_page_entries_9xx) {
+					q_ram_base++;
+					q_ram_start_page = 0;
+				}
+				q_ram_end_page = q_ram_start_page +1;
+
+				val |= (q_ram_base & 0x1f) <<12; /* [16:12] of q_ram_base */
+				val |= (q_ram_end_page & 0x3f)<<6; /* [11:6] of q_ram_base */
+				val |= (q_ram_start_page & 0x3f);  /* [5:0] of q_ram_base */
+
+#ifdef FMN_DEBUG
+				nlm_print("qid: %d, q_ram_base: %d, q_ram_start_page: %d, q_ram_end_page: %d.\n",
+						qid, (q_ram_base & 0x1f),
+						(q_ram_end_page & 0x3f),
+						(q_ram_start_page & 0x3f));
+#endif
+
+				q_ram_start_page = q_ram_end_page +1;
 
 
 #if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
@@ -1037,6 +1054,9 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 				 * In our configuration, each VC: 4KB
 				 */
 				if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+
+				val |= 1ULL << 62; /* enable spill */
+
 				/* carve the total fmn_spill area into all 32 VC's here */
 				q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
 				/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as
-- 
1.7.1

