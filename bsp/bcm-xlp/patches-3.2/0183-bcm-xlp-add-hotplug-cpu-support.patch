From cb1634c39ff66623761a8239d05e9f00edcac0d2 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Mon, 24 Mar 2014 16:58:36 +0800
Subject: bcm-xlp: add hotplug cpu support

It mainly implements or enhances the necessary interfaces proposed in
Documentation/cpu-hotplug.txt, such interfaces include:

cpu offline:

    o cpu_disable

	Called by _cpu_down() to clear cpu_online_map & cpu_callin_map,
	disable all interrupts, and flush cache & tlb.

    o cpu_die

	Called by _cpu_down() to Wait for cpu die(ready to be 0)

    o play_dead

	Called by cpu_idle() to make cpu die(set ready to 0): Enter into
	a loop till it is waked up by user-space /sys interface
	(till ready is set to 1).

cpu online:

    o boot_secondary

	Called by __cpu_up to re-activate the cpu and make it exit from the
	loop of play_dead() and re-init the cpu via calling the following
	functions orderly: ptr_smp_boot -> smp_bootstrap -> start_secondary
	-> init_secondary -> smp_finish. The interrupts will be re-enabled
	in init_secondary and smp_finish.

The top-level functions for offline and online is cpu_down() and
cpu_up() respectively, they are called in drivers/base/cpu.c when 0 or 1
is written to the /sys interface: /sys/devices/system/cpu/cpuX/online

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index c3db014..dd99e76 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -826,6 +826,7 @@ config NLM_XLP_BOARD
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select DMA_COHERENT
 	select NR_CPUS_DEFAULT_32
 	select CEVT_R4K
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 4799c7a..5c09061 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -356,3 +356,16 @@ void __init arch_init_irq(void)
 	of_irq_init(xlp_pic_irq_ids);
 #endif
 }
+
+#if defined(CONFIG_HOTPLUG_CPU)
+void fixup_irqs(unsigned int cpu, int flag)
+{
+	if (!flag) {
+		/*offline*/
+		irq_cpu_offline();
+	} else {
+		/*online*/
+		irq_cpu_online();
+	}
+}
+#endif
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index 9a77130..01cbe51 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -36,6 +36,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
+#include <linux/cpu.h>
 #include <linux/irq.h>
 
 #include <asm/mmu_context.h>
@@ -57,6 +58,40 @@
 #error "Unknown CPU"
 #endif
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern void fixup_irqs(unsigned int cpu, int flag);
+
+static int __cpuinit nlm_cpu_callback(struct notifier_block *nfb,
+		unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		pr_info("Cpu %d online\n", cpu);
+		break;
+	case CPU_DEAD:
+		pr_info("Cpu %d offline\n", cpu);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata nlm_cpu_notifier = {
+	.notifier_call = nlm_cpu_callback,
+};
+
+static int __cpuinit register_nlm_notifier(void)
+{
+	register_hotcpu_notifier(&nlm_cpu_notifier);
+
+	return 0;
+}
+
+late_initcall(register_nlm_notifier);
+#endif  /* CONFIG_HOTPLUG_CPU */
+
 void nlm_send_ipi_single(int logical_cpu, unsigned int action)
 {
 	int cpu, node;
@@ -133,8 +168,56 @@ void nlm_prepare_cpus(unsigned int max_cpus)
 	smp_num_siblings = nlm_threads_per_core;
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int nlm_cpu_disable(void)
+{
+	int cpu = hard_smp_processor_id();
+
+	if (cpu == 0)
+		return -EBUSY;
+
+	set_cpu_online(cpu, false);
+	cpu_clear(cpu, cpu_callin_map);
+
+	local_irq_disable();
+	fixup_irqs(cpu, 0);
+	local_irq_enable();
+
+	flush_cache_all();
+	local_flush_tlb_all();
+
+	return 0;
+}
+
+static void nlm_cpu_die(unsigned int logical_cpu)
+{
+	int cpu = cpu_logical_map(logical_cpu);
+	volatile u32 *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+
+	while (cpu_ready[cpu])
+		cpu_relax();
+}
+
+void play_dead(void)
+{
+	unsigned int cpu = smp_processor_id();
+	volatile u32 *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+
+	idle_task_exit();
+	cpu_ready[cpu] = 0;
+
+	local_irq_disable();
+	while (!cpu_ready[cpu])
+		cpu_relax();
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
 void nlm_smp_finish(void)
 {
+#ifdef CONFIG_HOTPLUG_CPU
+	int cpu = hard_smp_processor_id();
+	fixup_irqs(cpu, 1);
+#endif
 	local_irq_enable();
 }
 
@@ -177,6 +260,7 @@ void __init nlm_smp_setup(void)
 	cpumask_set_cpu(boot_cpu, &phys_cpu_present_mask);
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
+
 	set_cpu_possible(0, true);
 	cpumask_set_cpu(0, &nlm_get_node(0)->cpumask);
 
@@ -191,6 +275,7 @@ void __init nlm_smp_setup(void)
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
 			set_cpu_possible(num_cpus, true);
+			set_cpu_present(num_cpus, true);
 			node = nlm_cpuid_to_node(i);
 			cpumask_set_cpu(num_cpus, &nlm_get_node(node)->cpumask);
 			++num_cpus;
@@ -291,4 +376,8 @@ struct plat_smp_ops nlm_smp_ops = {
 	.boot_secondary		= nlm_boot_secondary,
 	.smp_setup		= nlm_smp_setup,
 	.prepare_cpus		= nlm_prepare_cpus,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_disable		= nlm_cpu_disable,
+	.cpu_die		= nlm_cpu_die,
+#endif
 };
-- 
1.7.1

