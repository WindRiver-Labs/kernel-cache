From 77f9da61f3cf067b5bf0caa76ebbf6d633c1da75 Mon Sep 17 00:00:00 2001
From: Quanyang Wang <quanyang.wang@windriver.com>
Date: Mon, 30 Mar 2015 21:47:17 +0800
Subject: bcm-xlp: fix irq threading issue

When use irq threading, sometimes irqthread run unmask function
after other CPU call irq_disable.Irq thread will ignore unmask
function when find that this irq is disabled. When unmask function
is different from enable function, this will cause that irq will never
be enabled again even if use irq_enable because unmask function not
run.So make mask function same with enable function.

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 00f5e03..26532b9 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -111,8 +111,11 @@ static void xlp_pic_disable(struct irq_data *d)
 static void xlp_pic_mask_ack(struct irq_data *d)
 {
 	struct nlm_pic_irq *pd = irq_data_get_irq_handler_data(d);
+	unsigned long flags;
 
-	clear_c0_eimr(pd->picirq);
+	spin_lock_irqsave(&pd->node->piclock, flags);
+	nlm_pic_disable_irt(pd->node->picbase, pd->irt);
+	spin_unlock_irqrestore(&pd->node->piclock, flags);
 	ack_c0_eirr(pd->picirq);
 }
 
@@ -125,8 +128,9 @@ static void xlp_pic_unmask(struct irq_data *d)
 	if (pd->extra_ack)
 		pd->extra_ack(d);
 
-	/* re-enable the intr on this cpu */
-	set_c0_eimr(pd->picirq);
+	spin_lock_irqsave(&pd->node->piclock, flags);
+	nlm_pic_enable_irt(pd->node->picbase, pd->irt);
+	spin_unlock_irqrestore(&pd->node->piclock, flags);
 
 	/* Ack is a single write, no need to lock */
 	nlm_pic_ack(pd->node->picbase, pd->irt);
-- 
1.7.1

