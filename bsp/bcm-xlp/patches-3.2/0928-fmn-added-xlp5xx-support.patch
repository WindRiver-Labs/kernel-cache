From b7c5fe852d324025d57e41df09ce712349021056 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Thu, 6 Feb 2014 13:56:20 +0530
Subject: fmn: added xlp5xx support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
index 1b8abe1..e62e9bd 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
@@ -84,7 +84,8 @@ enum FMN_MSG_BLKS {
 	XLP_MSG_BLK_NAE_1,
         XLP_MSG_BLK_ALE,
         XLP_MSG_BLK_KBP,
-	XLP9XX_MSG_BLK_MAX
+	XLP9XX_MSG_BLK_MAX,
+	XLP5XX_MSG_BLK_MAX = XLP9XX_MSG_BLK_MAX
 };
 
 
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index ebe50ad..534fddc 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -65,6 +65,9 @@
 #define DEFAULT_SINGLE_ENTRY_MSG_SZ	12
 #define XLP9XX_SINGLE_ENTRY_MSG_SZ	16
 
+#define XLP5XX_MAX_OUT_Q_BASE	16
+#define XLP9XX_MAX_OUT_Q_BASE	32
+
 nlm_fmn_config_t xlp3xx_fmn_config[] = {
 [XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
 [XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
@@ -222,6 +225,55 @@ nlm_fmn_config_t xlp9xx_fmn_config[] = {
 [XLP_MSG_HANDLE_MAX] = {XLP_9XX_INVALID_STATION, 0},
 };
 
+/*************5xx***************/
+nlm_fmn_config_t xlp5xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0]  = {XLP_STNID_CPU0,  XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1]  = {XLP_STNID_CPU1,  XLP_CPU1_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU2]  = {XLP_STNID_CPU2,  XLP_CPU2_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU3]  = {XLP_STNID_CPU3,  XLP_CPU3_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU4]  = {XLP_STNID_CPU4,  XLP_CPU4_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU5]  = {XLP_STNID_CPU5,  XLP_CPU5_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU6]  = {XLP_STNID_CPU6,  XLP_CPU6_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU7]  = {XLP_STNID_CPU7,  XLP_CPU7_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU8]  = {XLP_5XX_INVALID_STATION,  0},
+[XLP_MSG_HANDLE_CPU9]  = {XLP_5XX_INVALID_STATION,  0},
+[XLP_MSG_HANDLE_CPU10] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU11] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU12] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU13] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU14] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU15] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU16] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU17] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU18] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU19] = {XLP_5XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0]   = {XLP_5XX_PCIE0_VC_BASE, XLP_5XX_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1]   = {XLP_5XX_PCIE1_VC_BASE, XLP_5XX_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2]   = {XLP_5XX_PCIE2_VC_BASE, XLP_5XX_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3]   = {XLP_5XX_PCIE3_VC_BASE, XLP_5XX_PCIE3_VC_LIMIT},
+[XLP_MSG_HANDLE_DTRE]    = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_GDX_0]   = {XLP_5XX_GDX0_VC_BASE, XLP_5XX_GDX0_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]   = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_REGX]    = {XLP_5XX_RGX_VC_BASE, XLP_5XX_RGX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_5XX_RSA_VC_BASE, XLP_5XX_RSA_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO]  = {XLP_5XX_SEC_VC_BASE, XLP_5XX_SEC_VC_LIMIT},
+[XLP_MSG_HANDLE_SRIO]    = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CMP]    = {XLP_5XX_CMP_VC_BASE, XLP_5XX_CMP_VC_LIMIT},
+[XLP_MSG_HANDLE_LZS]    = {XLP_5XX_LZS_VC_BASE, XLP_5XX_LZS_VC_LIMIT},
+[XLP_MSG_HANDLE_KBP]    = {XLP_5XX_KBP_VC_BASE, XLP_5XX_KBP_VC_LIMIT}, /*FIXME*/
+
+[XLP_MSG_HANDLE_POE_0] = {XLP_5XX_POE0_VC_BASE, XLP_5XX_POE0_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_5XX_NET0_VC_BASE, XLP_5XX_NET0_VC_LIMIT},
+[XLP_MSG_HANDLE_POE_1] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_ALE]   = {XLP_5XX_ALE_VC_BASE,  XLP_5XX_ALE_VC_LIMIT},
+[XLP_MSG_HANDLE_POPQ]   = {XLP_5XX_POPQ_VC_BASE,  XLP_5XX_POPQ_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_5XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_5XX_INVALID_STATION, 0},
+};
+
 extern struct nlm_node_config nlm_node_cfg;
 
 //#define FMN_DEBUG 1
@@ -280,7 +332,7 @@ static int get_onchip_qsize(void *fdt, int node, int station)
 	pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"onchip-entries", &plen);
 	if(pval != NULL) {
 		onchip_qsize = fdt32_to_cpu(*(uint32_t *)pval);
-		if (is_nlm_xlp9xx()) {
+		if (IS_NLM_XLP9XX_FAMILY) {
 			if (onchip_qsize > XLP9XX_FMN_ONCHIP_PERQ)
 				return -1;
 		}
@@ -698,7 +750,7 @@ static void fmn_validate_credit(int node, int max_nodes)
 
 		/* considering single entry message only */
 		reqd_size = credits * DEFAULT_SINGLE_ENTRY_MSG_SZ;
-		if(is_nlm_xlp9xx()) {
+		if(IS_NLM_XLP9XX_FAMILY) {
 			reqd_size = credits * XLP9XX_SINGLE_ENTRY_MSG_SZ;
 		}
 
@@ -935,6 +987,24 @@ static int  fmn_9xx_is_vc_valid(int node, unsigned int base_vc)
 	return 0;
 }
 
+static int  fmn_5xx_is_vc_valid(int node, unsigned int base_vc)
+{
+	if (base_vc == XLP_9XX_INVALID_STATION) {
+		return 0;
+	}
+
+	return 1;
+
+	/* TODO: check cpu io mmio for xlp5xx */
+	/*volatile uint32_t * fuse = xlp9xx_cpu_io_mmio(node, (6<<15) | (1<<12) );
+	uint32_t cfg6 = fuse[0xc6];
+	uint32_t nCore = 20 - bitcount(cfg6);
+
+	if( XLP_9XX_PCIE0_VC_BASE <= base_vc   ) return 1;
+	if( base_vc < (XLP_CPU0_VC_LIMIT - XLP_CPU0_VC_BASE + 1)*nCore ) return 1; //core enabled
+
+	return 0;*/
+}
 
 static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 {
@@ -942,28 +1012,40 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 	nlm_fmn_config_t *fmn_config = NULL;
 	volatile int index;
 	uint32_t credits, cfgrd;
+	int vc_valid = 0;
 
 	if (!is_nlm_xlp9xx()) {
 		fmn_invalidate_blocks(node, XLP_MSG_BLK_POE_1);
 		fmn_invalidate_blocks(node, XLP_MSG_BLK_NAE_1);
-		fmn_invalidate_blocks(node, XLP_MSG_BLK_ALE);
 		fmn_invalidate_blocks(node, XLP_MSG_BLK_KBP);
 
+		if (!is_nlm_xlp5xx()) {
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_ALE);
+		}
 	}
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		/* XLP9XX / XLP7XX */
 		nlm_print(" XLP9XX/XLP7XX FMN credit configuration \n");
 		/* 9xx does not have SRIO engine */
 
-		fmn_config = &xlp9xx_fmn_config[0];
+		if (is_nlm_xlp9xx()) {
+			fmn_config = &xlp9xx_fmn_config[0];
+		} else {
+			fmn_config = &xlp5xx_fmn_config[0];
+		}
 
 		/* go through each valid station */
 		for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
 			int base_vc = fmn_config->base_vc;
 			if ((hndl == XLP_MSG_HANDLE_POPQ) || (hndl == XLP_MSG_HANDLE_INVALID))
 				continue;
-			if (fmn_9xx_is_vc_valid(node, base_vc) )
+			if (is_nlm_xlp9xx()) {
+				vc_valid = fmn_9xx_is_vc_valid(node, base_vc);
+			} else {
+				vc_valid = fmn_5xx_is_vc_valid(node, base_vc);
+			}
+			if (vc_valid)
 			{
 				int station;
 				/* configure credits from this base station to all other appropriate VC's */
@@ -1192,18 +1274,26 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 	if(fmn_update_qsize(node) < 0)
 		return -1;
 
-	if (is_nlm_xlp9xx()) {
+	if (IS_NLM_XLP9XX_FAMILY) {
 		int station;
 
-		/* XLP9XX / XLP7XX */
-		nlm_print(" XLP9XX/XLP7XX FMN output queue configuration \n");
+		/* XLP9XX / XLP7XX / XLP5XX*/
+		nlm_print(" XLP9XX/XLP7XX/XLP5XX FMN output queue configuration \n");
 
 		for (station = 0; station < max_msg_blks; station++) {
 
 			if (!fmn_q_config[station].valid) continue;
 
 			qid = fmn_q_config[station].b_stid;
-			if ( fmn_9xx_is_vc_valid(node, qid) == 0 ) continue;
+			if (is_nlm_xlp9xx()) {
+				if (fmn_9xx_is_vc_valid(node, qid) == 0) {
+					continue;
+				}
+			} else {
+				if (fmn_5xx_is_vc_valid(node, qid) == 0) {
+					continue;
+				}
+			}
 
 			oq_num32pages = get_onchip_qsize(fdt, node, station);
 			if (oq_num32pages < 0)
@@ -1271,14 +1361,25 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 					q_ram_base++;
 					q_ram_start_page = 0;
 				}
-				if (q_ram_base == 32) {
-					nlm_print("Invalid FMN onchip queue configuration \n");
-					return -1;
+				if (is_nlm_xlp5xx()) {
+					if (q_ram_base == XLP5XX_MAX_OUT_Q_BASE) {
+						nlm_print("XLP5XX: Invalid FMN onchip queue configuration \n");
+						return -1;
+					}
+				} else {
+					if (q_ram_base == XLP9XX_MAX_OUT_Q_BASE) {
+						nlm_print("XLP9XX: Invalid FMN onchip queue configuration \n");
+						return -1;
+					}
 				}
 
 				q_ram_end_page = q_ram_start_page + oq_num32pages - 1;
 
-				val |= (q_ram_base & 0x1f) <<12; /* [16:12] of q_ram_base */
+				if (is_nlm_xlp9xx()) {
+					val |= (q_ram_base & 0x1f) << 12; /* [16:12] of q_ram_base */
+				} else {
+					val |= (q_ram_base & 0xf) << 12; /* [15:12] of q_ram_base */
+				}
 				val |= (q_ram_end_page & 0x3f)<<6; /* [11:6] of q_ram_base */
 				val |= (q_ram_start_page & 0x3f);  /* [5:0] of q_ram_base */
 
@@ -1659,6 +1760,7 @@ int get_dom_fmn_node_ownership(void *fdt, int dom_id)
 void nlm_hal_fmn_init(void *fdt, int node)
 {
 	int max_nodes;
+	int hndl = 0;
 
 	nlm_fmn_config_t *fmn_config = NULL;
 
@@ -1668,9 +1770,14 @@ void nlm_hal_fmn_init(void *fdt, int node)
 		fmn_default_qsize = 0;
                 max_msg_blks = XLP9XX_MSG_BLK_MAX;
 		xlp_fmn_base[node] = mask & nlh_read_cfg_reg32(xlp9xx_fmn_base[node] + 0x10);
-	}
-        else
+	} else if (is_nlm_xlp5xx()) {
+		unsigned long long mask = ~0xf;
+		fmn_default_qsize = 0;
+                max_msg_blks = XLP5XX_MSG_BLK_MAX;
+		xlp_fmn_base[node] = mask & nlh_read_cfg_reg32(xlp5xx_fmn_base[node] + 0x10);
+	} else {
                 max_msg_blks = XLP_MSG_BLK_MAX;
+	}
 
 	max_nodes = parse_fdt_fmn_config(fdt);
 
@@ -1695,7 +1802,47 @@ void nlm_hal_fmn_init(void *fdt, int node)
 		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE1, 1, XLP_9XX_PCIE1_VC_BASE, XLP_9XX_PCIE1_VC_LIMIT);
 		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE2, 1, XLP_9XX_PCIE2_VC_BASE, XLP_9XX_PCIE2_VC_LIMIT);
 		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE3, 1, XLP_9XX_PCIE3_VC_BASE, XLP_9XX_PCIE3_VC_LIMIT);
-        }
+	} else if (is_nlm_xlp5xx()) {
+		
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_GDX1);
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_NAE_1);
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_POE_1);
+
+		fmn_config = &xlp5xx_fmn_config[0];
+
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_POPQ, 0, XLP_5XX_POPQ_VC_BASE, XLP_5XX_POPQ_VC_LIMIT);
+
+		if (is_nlm_xlp516()) {
+			for (hndl = XLP_MSG_HANDLE_CPU4; hndl < XLP_MSG_HANDLE_CPU8; hndl++) {
+				xlp5xx_fmn_config[hndl].base_vc = XLP_5XX_INVALID_STATION;
+				xlp5xx_fmn_config[hndl].vc_limit =0;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 4, XLP_CPU0_VC_BASE, XLP_CPU3_VC_LIMIT);
+		} else if (is_nlm_xlp524()) {
+			for (hndl = XLP_MSG_HANDLE_CPU6; hndl < XLP_MSG_HANDLE_CPU8; hndl++) {
+				xlp5xx_fmn_config[hndl].base_vc = XLP_5XX_INVALID_STATION;
+				xlp5xx_fmn_config[hndl].vc_limit =0;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 6, XLP_CPU0_VC_BASE, XLP_CPU5_VC_LIMIT);
+		} else {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 8, XLP_CPU0_VC_BASE, XLP_CPU7_VC_LIMIT);
+		}
+
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_GDX, 1, XLP_5XX_GDX0_VC_BASE, XLP_5XX_GDX0_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_REGX, 1, XLP_5XX_RGX_VC_BASE, XLP_5XX_RGX_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CMP, 1, XLP_5XX_CMP_VC_BASE, XLP_5XX_CMP_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_5XX_RSA_VC_BASE, XLP_5XX_RSA_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_5XX_SEC_VC_BASE, XLP_5XX_SEC_VC_LIMIT);
+
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_5XX_NET0_VC_BASE, XLP_5XX_NET0_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_POE, 1, XLP_5XX_POE0_VC_BASE, XLP_5XX_POE0_VC_LIMIT);
+
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE0, 1, XLP_5XX_PCIE0_VC_BASE, XLP_5XX_PCIE0_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE1, 1, XLP_5XX_PCIE1_VC_BASE, XLP_5XX_PCIE1_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE2, 1, XLP_5XX_PCIE2_VC_BASE, XLP_5XX_PCIE2_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_PCIE3, 1, XLP_5XX_PCIE3_VC_BASE, XLP_5XX_PCIE3_VC_LIMIT);
+	}
 
 	update_fmn_config();
 
@@ -1704,7 +1851,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 		while(1);
 	}
 
-	if(!is_nlm_xlp2xx() && !is_nlm_xlp9xx()) {
+	if(!is_nlm_xlp2xx() && !IS_NLM_XLP9XX_FAMILY) {
 		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
 	}
 
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
index 41ef502..4a8ffe0 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_macros.h
@@ -57,6 +57,13 @@ extern unsigned long xlp9xx_poe1_base[];
 extern unsigned long xlp9xx_fmn_base[];
 extern unsigned long xlp9xx_sys_clk_base[];
 
+extern unsigned long xlp5xx_mac0_base[];
+extern unsigned long xlp5xx_mac1_base[];
+extern unsigned long xlp5xx_poe0_base[];
+extern unsigned long xlp5xx_poe1_base[];
+extern unsigned long xlp5xx_fmn_base[];
+extern unsigned long xlp5xx_sys_clk_base[];
+
 
 
 #ifndef is_nlm_xlp8xx
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index f86cafd..fbbbc9c 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -455,6 +455,58 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP9XX_SYS_FUNC			0x0
 #define XLP9XX_CLK_FUNC			0x2
 
+/********xlp5xx***********/
+
+#define XLP_5XX_PCIE0_VC_BASE	0x180
+#define XLP_5XX_PCIE0_VC_LIMIT	0x181
+#define XLP_5XX_PCIE1_VC_BASE	0x182
+#define XLP_5XX_PCIE1_VC_LIMIT	0x183
+#define XLP_5XX_PCIE2_VC_BASE	0x184
+#define XLP_5XX_PCIE2_VC_LIMIT	0x185
+#define XLP_5XX_PCIE3_VC_BASE	0x186
+#define XLP_5XX_PCIE3_VC_LIMIT	0x187
+
+#define XLP_5XX_GDX0_VC_BASE	0x188
+#define XLP_5XX_GDX0_VC_LIMIT	0x189
+#define XLP_5XX_CMP_VC_BASE	0x190
+#define XLP_5XX_CMP_VC_LIMIT	0x191
+#define XLP_5XX_LZS_VC_BASE	0x19C
+#define XLP_5XX_LZS_VC_LIMIT	0x19f
+#define XLP_5XX_SEC_VC_BASE	0x1A8
+#define XLP_5XX_SEC_VC_LIMIT	0x1AB
+#define XLP_5XX_RSA_VC_BASE	0x1C0
+#define XLP_5XX_RSA_VC_LIMIT	0x1C3
+#define XLP_5XX_RGX_VC_BASE	0x1CC
+#define XLP_5XX_RGX_VC_LIMIT	0x1CF
+#define XLP_5XX_KBP_VC_BASE	0x1DC 
+#define XLP_5XX_KBP_VC_LIMIT	0x1DF 
+
+#define XLP_5XX_POE0_VC_BASE	0x200
+#define XLP_5XX_POE0_VC_LIMIT	0x207
+#define XLP_5XX_NET0_VC_BASE	0x208
+#define XLP_5XX_NET0_VC_LIMIT	0x257
+#define XLP_5XX_POE1_VC_BASE	0x280
+#define XLP_5XX_POE1_VC_LIMIT	0x287
+#define XLP_5XX_NET1_VC_BASE	0x288
+#define XLP_5XX_NET1_VC_LIMIT	0x2D7
+#define XLP_5XX_ALE_VC_BASE	0x2DA
+#define XLP_5XX_ALE_VC_LIMIT	0x2DB
+
+#define XLP_5XX_POPQ_VC_BASE	0x300
+#define XLP_5XX_POPQ_VC_LIMIT	0x3FF
+
+#define XLP_5XX_INVALID_STATION		0x2FF
+
+#define XLP_5XX_NET0_TX_VC_BASE      520
+#define XLP_5XX_NET0_TX_VC_LIMIT     583
+#define XLP_5XX_NET0_RX_VC_BASE      584
+#define XLP_5XX_NET0_RX_VC_LIMIT     599
+
+#define XLP_5XX_NET1_TX_VC_BASE      648
+#define XLP_5XX_NET1_TX_VC_LIMIT     711
+#define XLP_5XX_NET1_RX_VC_BASE      712
+#define XLP_5XX_NET1_RX_VC_LIMIT     727
+
 
 #define XLP9XX_SAE_RSA_BUS_NUM		(1<<20)
 #define XLP9XX_PCIE_DEV_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 7d7320c..5bdceb9 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -90,6 +90,14 @@ unsigned long xlp9xx_poe1_base[NLM_MAX_NODES];
 unsigned long xlp9xx_fmn_base[NLM_MAX_NODES];
 unsigned long xlp9xx_sys_clk_base[NLM_MAX_NODES];
 
+/*5XX*/
+unsigned long xlp5xx_mac0_base[NLM_MAX_NODES];
+unsigned long xlp5xx_mac1_base[NLM_MAX_NODES];
+unsigned long xlp5xx_poe0_base[NLM_MAX_NODES];
+unsigned long xlp5xx_poe1_base[NLM_MAX_NODES];
+unsigned long xlp5xx_fmn_base[NLM_MAX_NODES];
+unsigned long xlp5xx_sys_clk_base[NLM_MAX_NODES];
+
 struct nlm_node_config  nlm_node_cfg;
 
 
@@ -423,6 +431,18 @@ __inline__ void nlm_hal_init(void)
 
 			xlp_sae_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
 			xlp_rsa_base[node] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
+		} else if (is_nlm_xlp5xx()) {
+
+			xlp5xx_mac0_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
+			xlp5xx_mac1_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
+			xlp5xx_poe0_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE0));
+			xlp5xx_poe1_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_POE1));
+			xlp5xx_fmn_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
+			xlp_sys_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_SYS));
+			xlp5xx_sys_clk_base[0] = (uint64_t)xlp9xx_cpu_io(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_CLK));
+
+			xlp_sae_base[0] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_SAE)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+			xlp_rsa_base[0] = (xlp_io_base | XLP9XX_SAE_RSA_BUS_NUM | XLP9XX_PCIE_DEV_BASE(XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
 		} else
 		{
 			xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
@@ -494,6 +514,13 @@ EXPORT_SYMBOL(xlp9xx_poe1_base);
 EXPORT_SYMBOL(xlp9xx_fmn_base);
 EXPORT_SYMBOL(xlp9xx_sys_clk_base);
 
+EXPORT_SYMBOL(xlp5xx_mac0_base);
+EXPORT_SYMBOL(xlp5xx_mac1_base);
+EXPORT_SYMBOL(xlp5xx_poe0_base);
+EXPORT_SYMBOL(xlp5xx_poe1_base);
+EXPORT_SYMBOL(xlp5xx_fmn_base);
+EXPORT_SYMBOL(xlp5xx_sys_clk_base);
+
 
 EXPORT_SYMBOL(nlm_hal_init);
 EXPORT_SYMBOL(nlm_hal_read_32bit_reg);
-- 
1.7.1

