From 05e36c54fa048e4bb130f0256cb796f2167a0d9c Mon Sep 17 00:00:00 2001
From: kopal <kopal@broadcom.com>
Date: Thu, 28 Aug 2014 11:34:00 +0530
Subject: nae: restored the original functioning of port_index variable.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_init.h b/drivers/net/ethernet/broadcom/nae/xlpge_init.h
index 5d9dd95..f6de41f 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_init.h
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_init.h
@@ -45,7 +45,7 @@ extern int replenish_freein_fifos(void);
 extern int nlm_xlp_enable_napi(void);
 extern void  get_mac_address(char * const);
 extern int xlpge_eeprom_init(void);
-extern int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const,int port_index);
+extern int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae, char * const,int index);
 extern int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map,
                                 int mode, int *jumbo_enabled);
 extern int xlpge_get_dev_name_by_port_num (int port_num, char *dev_name);
diff --git a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
index b1207dc..a2b3904 100644
--- a/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlpge_nae.c
@@ -825,39 +825,39 @@ static int nlm_xlp_port_poll(void *buff)
 	static int arr[NLM_MAX_NODES][18];
 	maxnae = get_num_nae_pernode();
 	for (node = 0;node < NLM_MAX_NODES; node++) {
-		int num_nae, tmp, port_index=0;
+		int num_nae, tmp, index=0;
 		for(num_nae=0; num_nae<maxnae; num_nae++) {
 			nae_cfg = get_nae(node, num_nae);
 			if (nae_cfg == NULL)
 				continue;
-			for(i=0; i < nae_cfg->num_ports; i++, port_index++) {
-				arr[node][port_index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
+			for(i=0; i < nae_cfg->num_ports; i++, index++) {
+				arr[node][index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
 			}
 		}
 	}
 	while(1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		for (node = 0;node < NLM_MAX_NODES; node++) {
-			int num_nae, tmp, port_index=0;
+			int num_nae, tmp, index=0;
 			for(num_nae=0; num_nae<maxnae; num_nae++) {
 				nae_cfg = get_nae(node, num_nae);
 				if (nae_cfg == NULL)
 					continue;
-				for(i=0; i < nae_cfg->num_ports; i++, port_index++) {
-					tmp=arr[node][port_index];
-					arr[node][port_index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
-					if ((arr[node][port_index]>-1)&&(arr[node][port_index] > tmp)){
+				for(i=0; i < nae_cfg->num_ports; i++, index++) {
+					tmp=arr[node][index];
+					arr[node][index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
+					if ((arr[node][index]>-1)&&(arr[node][index] > tmp)){
 						netsoc_start_autoneg(&nae_cfg->ports[i]);
 						if(nae_cfg->ports[i].link_stat==1)
-							netif_carrier_on(xlp_dev_mac[node][port_index]);
+							netif_carrier_on(xlp_dev_mac[node][index]);
 						else
-							netif_carrier_off(xlp_dev_mac[node][port_index]);
+							netif_carrier_off(xlp_dev_mac[node][index]);
 					}
 					else {
 						if(nae_cfg->ports[i].link_stat==1)
-                                                        netif_carrier_on(xlp_dev_mac[node][port_index]);
+                                                        netif_carrier_on(xlp_dev_mac[node][index]);
                                                 else
-                                                        netif_carrier_off(xlp_dev_mac[node][port_index]);
+                                                        netif_carrier_off(xlp_dev_mac[node][index]);
 						continue;
 					}
 				}
@@ -1432,12 +1432,13 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 	.ndo_select_queue		= nlm_select_queue,
 };
 
-int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int num_nae, char * const mac_addr,int port_index)
+int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int num_nae, char * const mac_addr,int index)
 {
 	struct net_device *dev;
 	struct dev_data *priv;
 	int cpu;
 	int node = nae_cfg->node;
+	static int port_index=0;
 	if (!nae_cfg->ports[port].valid)
 		return -1;
 
@@ -1470,6 +1471,7 @@ int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int num_nae, char * const ma
 	priv->block	= nae_cfg->ports[port].hw_port_id / 4;
 	priv->type	= nae_cfg->ports[port].iftype;
 	priv->mgmt_port	= nae_cfg->ports[port].mgmt;
+	priv->port_index = port_index++;
 
 	switch(nae_cfg->ports[port].iftype) {
 	case SGMII_IF:
@@ -1506,7 +1508,7 @@ int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int num_nae, char * const ma
 	dev->features |= NETIF_F_LLTX;
 
 	register_netdev(dev);
-	xlp_dev_mac[node][port_index] = dev;
+	xlp_dev_mac[node][index] = dev;
 
 	//xlp_mac_setup_hwaddr(priv);
 
@@ -1633,7 +1635,7 @@ void nlm_xlp_nae_init(void)
 	get_mac_address(hw_mac_addr);
 	maxnae = get_num_nae_pernode();
 	for (node = 0; node < NLM_MAX_NODES; node++) {
-		int num_nae,port_index=0;;
+		int num_nae, index=0;
 		for(num_nae=0; num_nae<maxnae; num_nae++){
 			nae_cfg = get_nae(node, num_nae);
 			if (nae_cfg == NULL)
@@ -1647,8 +1649,8 @@ void nlm_xlp_nae_init(void)
                 __netsoc_prepad_enable(nae_cfg, 64);
 #endif
 
-			for(i = 0; i < nae_cfg->num_ports; i++, port_index++) {
-				nlm_per_port_nae_init(nae_cfg, i, num_nae, hw_mac_addr,port_index);
+			for(i = 0; i < nae_cfg->num_ports; i++, index++) {
+				nlm_per_port_nae_init(nae_cfg, i, num_nae, hw_mac_addr, index);
 				hw_mac_addr[5]++;
 				if(!(nae_cfg->port_fifo_en))
 					netsoc_map_interface_to_lifo(nae_cfg, i, 0xffff);
-- 
1.7.1

