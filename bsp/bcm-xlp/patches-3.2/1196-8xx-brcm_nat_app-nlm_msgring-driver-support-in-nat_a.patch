From 36877031e9a1b4a62e27c8a8f61813f1eabe202e Mon Sep 17 00:00:00 2001
From: Rahul Gupta <guptar@broadcom.com>
Date: Fri, 15 Nov 2013 14:28:07 +0530
Subject: 8xx brcm_nat_app: nlm_msgring driver support in nat_app.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nlm_msgring/msgring.h b/drivers/misc/netlogic/nlm_msgring/msgring.h
new file mode 100644
index 0000000..820744d
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_msgring/msgring.h
@@ -0,0 +1,107 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ASM_NLM_MSG_RING_H
+#define _ASM_NLM_MSG_RING_H
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+
+#define msgrng_enable(flags) 
+#define msgrng_disable(flags) 
+
+#else
+
+#define msgrng_enable(flags)                \
+do {                                        \
+  preempt_disable(); \
+  __asm__ volatile (                        \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+  preempt_enable(); \
+} while (0)
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#endif
+
+#define msgrng_flags_save(flags) msgrng_enable(flags)
+#define msgrng_flags_restore(flags) msgrng_disable(flags)
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+
+#define msgrng_access_save(lock, iflags, mflags)
+#define msgrng_access_restore(lock, iflags, mflags)
+
+#define msgrng_access_enable(mflags) ((void)(mflags))
+#define msgrng_access_disable(mflags) ((void)(mflags))
+
+#else
+
+#define msgrng_access_save(lock, iflags, mflags) do {        \
+  spin_lock_irqsave(lock, iflags);                           \
+  msgrng_flags_save(mflags);                                 \
+ }while(0)
+
+#define msgrng_access_restore(lock, iflags, mflags) do {     \
+  msgrng_flags_restore(mflags);                              \
+  spin_unlock_irqrestore(lock, iflags);                      \
+ }while(0)
+
+#define msgrng_access_enable(mflags) do {   \
+  preempt_disable();                        \
+  msgrng_flags_save(mflags);                \
+} while(0)
+#define msgrng_access_disable(mflags) do {   \
+  msgrng_flags_restore(mflags);              \
+  preempt_enable();                          \
+} while(0)
+
+#endif
+
+#ifdef CONFIG_NLM_XLP
+extern int register_xlp_msgring_handler(int major,
+                             void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+                                             uint64_t, uint64_t, uint64_t, uint64_t, void *),
+                             void *dev_id);
+extern int unregister_xlp_msgring_handler(int, void *);
+#endif
+
+#endif
diff --git a/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
new file mode 100644
index 0000000..5fa6c30
--- /dev/null
+++ b/drivers/misc/netlogic/nlm_msgring/nlm_msgring_main.c
@@ -0,0 +1,248 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/vmalloc.h>
+#include <linux/mman.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+//#include <asm/netlogic/msgring.h>
+#include "msgring.h"
+//nclude <asm/netlogic/hal/nlm_hal_macros.h>
+//#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
+
+//#include "hal/nlm_hal_macros.h"
+#include <nlm_hal_macros.h>
+//#include "hal/nlm_hal_xlp_dev.h"
+#include <nlm_hal_xlp_dev.h>
+#include <asm/netlogic/mips-extns.h>
+
+#define MSGRING_WAIT_CHRDEV_NAME "/dev/nlm_msgring"
+static int msgring_major;
+static wait_queue_head_t msgring_wq[NR_CPUS];
+static int msgring_status[NR_CPUS];
+static DEFINE_MUTEX(msgrng_mutex);
+static int msgring_timeout[NR_CPUS];
+
+/* Additions to work with udev */
+static struct class *msgring_class;
+static struct device *msgring_device;
+static dev_t msgring_devt;
+
+ 
+#define NLM_MSGRING_WAIT_IOC 'm'
+#define NLM_MSGRING_WAIT_VC   _IOWR(NLM_MSGRING_WAIT_IOC, 1, unsigned int *)
+#define NLM_MSGRING_WAIT_TIMEOUT   _IOWR(NLM_MSGRING_WAIT_IOC, 2, unsigned int *)
+extern unsigned int intr_vc_mask[];
+
+
+extern int nlm_xlp_register_intr_vc_handler(int (*handler)(int vc));
+extern int nlm_xlp_register_intr_vc(int cpu, int vc);
+
+static int msgring_event(int vc)
+{
+	int cpu = hard_smp_processor_id();
+	if(msgring_status[cpu] != 1)
+		return 0;
+	msgring_status[cpu] = 0;
+	wake_up_interruptible(&msgring_wq[cpu]);
+	return 0;
+}
+
+static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count, loff_t *offset)
+{
+	int cpu = hard_smp_processor_id();
+	unsigned int val;
+	unsigned long flags;
+
+#ifdef CONFIG_32BIT
+	unsigned long mflags;
+#endif
+
+	local_irq_save(flags);
+#ifdef CONFIG_32BIT
+	msgrng_access_enable(mflags);
+#endif
+
+	msgring_status[cpu] = 1;
+
+	/* Enable intr on the vcs */
+	/* Need write vcmask into the register */
+	val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+	val |= (intr_vc_mask[cpu] << 16);
+	_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+
+#ifdef CONFIG_32BIT
+	msgrng_access_disable(mflags);
+#endif
+	local_irq_restore(flags);
+	if(msgring_timeout[cpu] < 0)
+		 wait_event_interruptible(msgring_wq[cpu], (msgring_status[cpu] == 0));
+	else
+		 wait_event_interruptible_timeout(msgring_wq[cpu], (msgring_status[cpu] == 0), msgring_timeout[cpu]);
+	return 1;
+}
+
+static int msgring_open (struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int msgring_release (struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static long msgring_ioctl(struct file *filp, unsigned int cmd,
+		   unsigned long arg)
+{
+	int err = 0, rv, vc = -1;
+	unsigned int  *ptr = (unsigned int *) arg;
+	int cpu, timeout;
+
+	switch (cmd) {
+		case NLM_MSGRING_WAIT_VC:
+			rv = copy_from_user(&vc, ptr, sizeof(*ptr));
+			if(vc < 0 || vc > 3) {
+				printk("Error in %s, Invald vc %d\n", __FUNCTION__, vc);
+				err = -EINVAL;
+				break;
+			}
+			preempt_disable();
+			cpu = hard_smp_processor_id();
+			nlm_xlp_register_intr_vc(cpu, vc);
+			preempt_enable();
+			break;
+
+	       case NLM_MSGRING_WAIT_TIMEOUT:
+			 rv = copy_from_user(&timeout, ptr, sizeof(*ptr));
+			 preempt_disable();
+			 cpu = hard_smp_processor_id();
+			 msgring_timeout[cpu] = timeout;
+			 preempt_enable();
+			 printk("timeout for cpu %d is %d\n", cpu, timeout);
+			 break;
+
+		default:
+			printk("Invalid cmd in %s\n", __FUNCTION__);
+			err = -EINVAL;
+	}
+	return err;
+}
+
+static long msgring_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned long ret = -1;
+	mutex_lock(&msgrng_mutex);
+	ret = msgring_ioctl(filp,cmd,arg);
+	mutex_unlock(&msgrng_mutex);
+
+	if(ret){
+		printk("msgring_ioctl returned with an error %lx", ret);
+		return -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+static struct file_operations msgring_fops = {
+	owner:		THIS_MODULE,
+	read:		msgring_read,
+	open:  		msgring_open,
+	unlocked_ioctl:	msgring_ioctl,
+	compat_ioctl:   msgring_compat_ioctl,
+	release:        msgring_release,
+};
+
+static int msgring_init(void)
+{
+	int i;
+
+
+	msgring_major = register_chrdev(0, MSGRING_WAIT_CHRDEV_NAME, &msgring_fops);
+	if (msgring_major < 0) {
+		printk("[%s] Failed to register %s char device\n", __FUNCTION__, MSGRING_WAIT_CHRDEV_NAME);
+		return msgring_major;
+	}
+	printk("[%s] Registered nlm_msgring char device major=%d\n",
+			__FUNCTION__, msgring_major);
+
+	/* Register a class and a device so udev works */
+	msgring_class = class_create(THIS_MODULE, MSGRING_WAIT_CHRDEV_NAME);
+	if(IS_ERR(msgring_class)) {
+		printk("[%s] Failed to create %s class\n", __FUNCTION__, MSGRING_WAIT_CHRDEV_NAME);
+		unregister_chrdev(msgring_major, MSGRING_WAIT_CHRDEV_NAME);
+		return PTR_ERR(msgring_class);
+	}	
+	printk("[%s] Created %s class\n", __FUNCTION__, MSGRING_WAIT_CHRDEV_NAME);
+
+	msgring_devt = MKDEV(msgring_major, 0);
+	msgring_device = device_create(msgring_class, NULL, msgring_devt, NULL, MSGRING_WAIT_CHRDEV_NAME);
+	if(IS_ERR(msgring_device)) {
+		printk("[%s] Failed to create %s device\n", __FUNCTION__, MSGRING_WAIT_CHRDEV_NAME);
+		class_unregister(msgring_class);
+		class_destroy(msgring_class);
+		unregister_chrdev(msgring_major, MSGRING_WAIT_CHRDEV_NAME);
+		return PTR_ERR(msgring_device);
+	}
+	printk("[%s] Created %s device\n", __FUNCTION__, MSGRING_WAIT_CHRDEV_NAME);
+
+	/* Don't do this set-up unless we successfully register with the kernel */
+	for(i = 0; i < NR_CPUS; i++){
+		init_waitqueue_head(&msgring_wq[i]);
+		msgring_timeout[i] = -1;
+	}
+
+	nlm_xlp_register_intr_vc_handler(msgring_event);
+    printk(" returning from mgsring_init\n");
+	return 0;
+}
+
+static void msgring_exit(void)
+{
+	device_destroy(msgring_class, msgring_devt);
+	class_unregister(msgring_class);
+	class_destroy(msgring_class);
+	unregister_chrdev(msgring_major, MSGRING_WAIT_CHRDEV_NAME);
+
+}
+
+module_init(msgring_init);
+module_exit(msgring_exit);
+MODULE_AUTHOR("Netlogic");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Msgring driver");
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index 17c8c3c..8f23eb9 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -87,6 +87,7 @@ static vchandler xlp_napi_vc_handlers[NLM_MAX_VC_PER_THREAD];
 typedef int (*intr_vchandler)(int vc);
 static intr_vchandler xlp_intr_vc_handler;
 unsigned int intr_vc_mask[NR_CPUS];
+EXPORT_SYMBOL(intr_vc_mask);
 
 /* make this a read/write spinlock */
 spinlock_t msgrng_lock;
-- 
1.7.1

