From 1256bb867f08bcf6ad52cc3452462f50342a61b4 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthia@netlogicmicro.com>
Date: Fri, 27 Jan 2012 22:13:51 +0530
Subject: NAE driver multinode support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/net/ethernet/broadcom/nae/init_nae.c b/drivers/net/ethernet/broadcom/nae/init_nae.c
index 731a143..f9560ac 100644
--- a/drivers/net/ethernet/broadcom/nae/init_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/init_nae.c
@@ -36,7 +36,7 @@ static void config_fmn(void)
 
 int initialize_nae(uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3)
 {
-	int dom_id = 0;
+	int dom_id = 0, node;
 	unsigned long mflags;
 
 	config_fmn();
@@ -45,7 +45,16 @@ int initialize_nae(uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3)
 	nlm_hal_init_nae(fdt, dom_id);
 
 	printk("Overriding HAL POE configuration based on current active cpumask\n");
-	nlm_hal_init_poe_distvec(0, cm0, cm1, cm2, cm3, (1 << nae_cfg.rx_vc));
+	for(node = 0; node < nlm_node_cfg.num_nodes; node++) {
+		nlm_hal_init_poe_distvec(node, 0, cm0, cm1, cm2, cm3, (1 << nlm_node_cfg.nae_cfg[node]->rx_vc)); 
+	}
+	/* 
+	 {
+		nlm_hal_init_poe_distvec(0, 0, cm0, 0, 0, 0, (1 << nlm_node_cfg.nae_cfg[0]->rx_vc));
+		nlm_hal_init_poe_distvec(1, 0, 0, cm1, 0, 0, (1 << nlm_node_cfg.nae_cfg[1]->rx_vc));
+	 }
+	*/
+	
 
 	msgrng_access_disable(mflags);
 	return 0;
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_hw.c b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
index a015baf..8dad49f 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_hw.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_hw.c
@@ -217,7 +217,7 @@ static void xlp_get_regs(struct net_device *dev,
 
 	spin_lock_irqsave(&priv->lock, flags);
 	for(i=0; i <= NLM_NUM_REG_DUMP; i++)
-		*(data + i) = nlm_hal_read_mac_reg(priv->block, priv->index,  R_TX_CONTROL + i);
+		*(data + i) = nlm_hal_read_mac_reg(priv->node, priv->block, priv->index,  R_TX_CONTROL + i);
 	spin_unlock_irqrestore(&priv->lock, flags);
 }
 static u32 xlp_get_msglevel(struct net_device *dev)
@@ -329,21 +329,21 @@ void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
 	if (priv->type == INTERLAKEN_IF)
 		return;
 
-	stats->tx_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_FCS_ERROR_COUNTER);
-	stats->tx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
-	stats->multicast = nlm_hal_read_mac_reg( priv->block, priv->index, RX_MULTICAST_PACKET_COUNTER);
-	stats->collisions = nlm_hal_read_mac_reg( priv->block, priv->index, TX_TOTAL_COLLISION_COUNTER);
-	stats->rx_length_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FRAME_LENGTH_ERROR_COUNTER);
-	stats->rx_over_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
-	stats->rx_crc_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_FCS_ERROR_COUNTER);
-	stats->rx_frame_errors = nlm_hal_read_mac_reg( priv->block, priv->index, RX_ALIGNMENT_ERROR_COUNTER);
-	stats->rx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_DROP_PACKET_COUNTER);
-	stats->rx_missed_errors = nlm_hal_read_mac_reg( priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
+	stats->tx_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_FCS_ERROR_COUNTER);
+	stats->tx_dropped = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->multicast = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, RX_MULTICAST_PACKET_COUNTER);
+	stats->collisions = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_TOTAL_COLLISION_COUNTER);
+	stats->rx_length_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, RX_FRAME_LENGTH_ERROR_COUNTER);
+	stats->rx_over_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, RX_DROP_PACKET_COUNTER);
+	stats->rx_crc_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, RX_FCS_ERROR_COUNTER);
+	stats->rx_frame_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, RX_ALIGNMENT_ERROR_COUNTER);
+	stats->rx_fifo_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index,RX_DROP_PACKET_COUNTER);
+	stats->rx_missed_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index,RX_CARRIER_SENSE_ERROR_COUNTER);
 	stats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors + stats->rx_frame_errors + stats->rx_fifo_errors +stats->rx_missed_errors);
-	stats->tx_aborted_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
+	stats->tx_aborted_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_EXCESSIVE_COLLISION_PACKET_COUNTER);
 	/*
-	stats->tx_carrier_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
-	stats->tx_fifo_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_carrier_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_DROP_FRAME_COUNTER);
+	stats->tx_fifo_errors = nlm_hal_read_mac_reg( priv->node, priv->block, priv->index, TX_DROP_FRAME_COUNTER);
 	*/
 	return;
 }
@@ -389,7 +389,7 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
  ********************************************************************* */
 static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx)
 {
-        return nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx);
+        return nlm_hal_mdio_read(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx);
 }
 
 /**********************************************************************
@@ -405,7 +405,7 @@ static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int regidx)
  ********************************************************************* */
 static void nlm_xlp_mac_mii_write(struct dev_data *priv, int regidx, uint16_t regval)
 {
-	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx, regval);
+	nlm_hal_mdio_write(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, regidx, regval);
 	return;
 }
 
@@ -455,22 +455,22 @@ void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
 
 	if (flag) {
 		if (priv->type == SGMII_IF) {
-			if (nlm_hal_get_phy_status(inf, &speed, &duplex)) {
+			if (nlm_hal_get_phy_status(priv->node, inf, &speed, &duplex)) {
 				//nlm_print("mac set enable speed %d duplex %d\n",speed, duplex);
 				ifmode = ((speed == 2) ? 2: 1);
-				nlm_hal_mac_disable(inf, priv->type);
-			        netwk_inf  = read_gmac_reg(inf, NETWK_INF_CTRL_REG);
+				nlm_hal_mac_disable(priv->node, inf, priv->type);
+			        netwk_inf  = read_gmac_reg(priv->node, inf, NETWK_INF_CTRL_REG);
 		        	netwk_inf &= (~(0x3));
-	        		write_gmac_reg(inf , NETWK_INF_CTRL_REG, netwk_inf | speed);
-		        	mac_cfg2 = read_gmac_reg(inf, MAC_CONF2);
+	        		write_gmac_reg(priv->node, inf , NETWK_INF_CTRL_REG, netwk_inf | speed);
+		        	mac_cfg2 = read_gmac_reg(priv->node, inf, MAC_CONF2);
 	        		mac_cfg2 &= (~((0x3 << 8) | 1));
-		        	write_gmac_reg(inf , MAC_CONF2,
+		        	write_gmac_reg(priv->node, inf , MAC_CONF2,
                 			              mac_cfg2 | (ifmode << 8) | duplex);
 			}
 		}
-		nlm_hal_mac_enable(inf, priv->type);
+		nlm_hal_mac_enable(priv->node, inf, priv->type);
 	} else {
-		nlm_hal_mac_disable(inf, priv->type);
+		nlm_hal_mac_disable(priv->node, inf, priv->type);
 	}
 }
 
@@ -480,7 +480,7 @@ int nlm_xlp_link_up(struct dev_data *priv, int phy)
 
 	if (priv->type != SGMII_IF)
                 return -EIO;
-        nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 22, 0);
-        extstatus = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 17);
+        nlm_hal_mdio_write(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 22, 0);
+        extstatus = nlm_hal_mdio_read(priv->node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, priv->phy.addr, 17);
         return ((extstatus & 0x0400) ? 1 : 0 );
 }
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.c b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
index bc6913d..f343a10 100755
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.c
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.c
@@ -134,10 +134,11 @@
 		(DEFAULT_JUMBO_MTU + PREPAD_LEN + JUMBO_RX_OFFSET) 
 
 #define NETL_JUMBO_SKB_HDR_LEN 64
-#define MAC_FRIN_WORK_NUM 32
+#define MAC_FRIN_WORK_NUM NR_CPUS
 #define PHOENIX_MAX_MACS 18
 #define MAX_TSO_SKB_PEND_REQS 50
 
+static uint32_t maxnae;
 /* THIS MUST be multiple of cache line size */
 static int jumbo_buffer_size = DEFAULT_JUMBO_BUFFER_SIZE; /*or set in set_mtu */
 static int jumbo_mtu = DEFAULT_JUMBO_MTU; /* or set in set_mtu */
@@ -145,7 +146,7 @@ typedef struct jumbo_rx_info {
 	struct page *page;
 	unsigned int page_offset; 
 	unsigned int space;
-	atomic_t alloc_fails[PHOENIX_MAX_MACS];
+	atomic_t alloc_fails[NLM_MAX_NODES][PHOENIX_MAX_MACS];
 }jumbo_rx_info_t;
 
 /* This struct size MUST be at most 32 bytes */
@@ -312,10 +313,12 @@ module_param(rely_on_firmware_config, int, 0);
 static int frin_desc_thres = 24;
 module_param(frin_desc_thres, int, 0);
 
-static uint32_t nae_rx_vc = 0;
-static uint32_t nae_fb_vc = 0;
+extern uint32_t nae_rx_vc;
+extern uint32_t nae_fb_vc;
 /***************************************************************/
 
+unsigned char eth_hw_addr[NLM_MAX_NODES][18][6];
+/*
 unsigned char eth_hw_addr[18][6] = {
 	{0x00,0x01,0x02,0x03,0x04,0x05},
 	{0x00,0x01,0x02,0x03,0x04,0x06},
@@ -336,6 +339,7 @@ unsigned char eth_hw_addr[18][6] = {
 	{0x00,0x01,0x02,0x03,0x04,0x15},
 	{0x00,0x01,0x02,0x03,0x04,0x16}
 };
+*/
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -371,7 +375,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 static void nlm_xlp_mac_timer(unsigned long data);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 
-static struct net_device *dev_mac[MAX_GMAC_PORT];
+static struct net_device *dev_mac[NLM_MAX_NODES][MAX_GMAC_PORT];
 
 extern struct proc_dir_entry *nlm_root_proc;
 
@@ -469,7 +473,7 @@ static __inline__ int mac_send_fr(struct dev_data *priv, unsigned long addr, int
 	__sync();
         if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) ){
 		print_fmn_send_error(__func__, ret);
-		printk("Unable to send configured free desc, check freein carving (qid=%d)\n", priv->nae_rx_qid);			 
+		printk("Unable to send configured free desc, check freein carving (qid=%d) ret 0x%x\n", priv->nae_rx_qid, ret);			 
 		return ret;
 	}
 	return ret;		
@@ -544,7 +548,7 @@ static int mac_frin_replenish_one_normal_msg(struct net_device *dev)
 		pg = rx->page;
 	} else {
 		/* alloc a new page */
-		pg = alloc_pages(GFP_KERNEL, 0);
+		pg = alloc_pages_exact_node(priv->node, GFP_KERNEL, 0); //alloc_pages(GFP_KERNEL, 0);
 		if(pg == NULL) {
 			panic("alloc_pages failure\n");
 		}
@@ -586,7 +590,7 @@ static int mac_frin_replenish_msgs(struct net_device *dev, int num)
 	int cpu = smp_processor_id();
 
 	rx = &jumbo_rx_buff[cpu];
-	atomic_add(num, &rx->alloc_fails[priv->port]);
+	atomic_add(num, &rx->alloc_fails[priv->node][priv->port]);
 	schedule_work(&mac_frin_replenish_work[cpu]);
 	//tasklet_schedule(&mac_frin_replenish_task[cpu]);
 	return 0;
@@ -594,30 +598,29 @@ static int mac_frin_replenish_msgs(struct net_device *dev, int num)
 
 static void mac_frin_replenish(unsigned long  arg/* ignored */)
 {
+	int node = 0;
 	jumbo_rx_info_t *rx;
 	int cpu = smp_processor_id();
 	int done = 0, i, j;
 
 	rx = &jumbo_rx_buff[cpu];
 
-	for (;;) {
-
+	for(node = 0; node < maxnae; node++) {
+	    for (;;) {
 		done = 0;
-
-		for (i = 0; i < PHOENIX_MAX_MACS; i++) {
+	     	for (i = 0; i < PHOENIX_MAX_MACS; i++) {
 			struct net_device *dev;
 			struct dev_data* priv;
 			atomic_t *frin_to_be_sent;
 			int num_fr_in=0;
 
-			dev = dev_mac[i];
+			dev = dev_mac[node][i];
 			if (dev == 0)
 				goto skip;
 
 			priv = netdev_priv(dev);
-			frin_to_be_sent = &rx->alloc_fails[i];
+			frin_to_be_sent = &rx->alloc_fails[priv->node][i];
 			num_fr_in = atomic_read(frin_to_be_sent);
-
 			//if(!(MSGRNG_OWN(priv->cfg_flag)))
 			//	goto skip;
 
@@ -643,6 +646,7 @@ static void mac_frin_replenish(unsigned long  arg/* ignored */)
 		}
 		if (done == PHOENIX_MAX_MACS)
 			break;
+	    }
 	}
 }
 
@@ -672,7 +676,7 @@ static int mac_fill_rxfr(struct net_device *dev)
 	
 	for(i = 0; i < limit; i++){
 		/*  get a page */
-		pg = alloc_pages(GFP_KERNEL, 0);
+		pg = alloc_pages_exact_node(priv->node, GFP_KERNEL, 0); 
 		if(pg == NULL) {
 			ret = -ENOMEM;
 			break;
@@ -718,6 +722,23 @@ static int mac_fill_rxfr(struct net_device *dev)
 
 }
 
+static int nlm_initialize_vfbid(int node, int fbvc)
+{
+	int cpu, i, dst_node = 0;
+	uint32_t vfbid_tbl[128];
+
+	for(i = 0; i < 128; i++)
+		vfbid_tbl[i] = 0;
+
+	for (cpu = 0; cpu < NR_CPUS ; cpu++) {
+		if(!cpu_isset(cpu, cpu_present_map))
+                        continue;
+		dst_node = cpu / 32;
+		vfbid_tbl[cpu] = (dst_node << 10) | (((cpu % 32) * 4) + fbvc);
+	}
+	nlm_config_vfbid_table(node, 0, NR_CPUS, vfbid_tbl);	//FIXME change mappings for 127 and 126
+}
+
 /**********************************************************************
  * nlm_xlp_nae_init -  xlp_nae device driver init function
  * @dev  -  this is per device based function
@@ -728,92 +749,111 @@ static void nlm_xlp_nae_init(void)
 {
 	struct net_device *dev = NULL;
 	struct dev_data *priv;
-	int i;
+	int i, node = 0, cpu;
 	struct proc_dir_entry *entry;
+	nlm_nae_config_ptr nae_cfg;
+	uint32_t cpu_mask[NLM_MAX_NODES];
+	
+	for(i=0; i < NLM_MAX_NODES; i++)
+		cpu_mask[i] = 0;
+
+	for (cpu = 0, node = 0; cpu < NR_CPUS ; cpu++) {
+                if(!cpu_isset(cpu, cpu_present_map))
+                        continue;
+		node = cpu / 32;
+		cpu_mask[node] |= (1 << (cpu % 32));
+	}
 
 	printk("======= Module Parameters =========\n");
 	printk("debug = %d, frin_desc_thres=%d naecfg_hack=%d drop_uboot_pkt=%d\n",
 	       debug, frin_desc_thres, naecfg_hack, drop_uboot_pkt);
 	printk("rely_on_firmware_config = %d\n", rely_on_firmware_config);
 
-	if (initialize_nae(cpumask_to_uint32(&cpu_present_map), 0, 0, 0))
+	if (initialize_nae(cpu_mask[0], cpu_mask[1], cpu_mask[2], cpu_mask[3]))		//FIXME find a better way to do this
 		return;
 	p2p_desc_mem_init();
-		
-	for (i = 0; i < MAC_FRIN_WORK_NUM; i++) {
+	
+	for (i = 0; i < ((node+1) * 32); i++) {
 		//tasklet_init(&mac_frin_replenish_task[i], mac_frin_replenish, 0UL);		  
 		INIT_WORK(&mac_frin_replenish_work[i], mac_frin_replenish);
 	}
 
-	nae_fb_vc = nae_cfg.fb_vc;
-	nae_rx_vc = nae_cfg.rx_vc;
+	maxnae = nlm_node_cfg.num_nodes;	
+	for(node = 0; node < maxnae; node++) {
+		nae_cfg = nlm_node_cfg.nae_cfg[node];
+		if (nae_cfg == NULL)
+			continue;
 
-	for(i = 0; i < nae_cfg.num_ports; i++)
-	{
-		/* Register only valid ports which are management */
-		if (!nae_cfg.ports[i].valid)
+		for(i = 0; i < nae_cfg->num_ports; i++)
+		{
+			/* Register only valid ports which are management */
+			if (!nae_cfg->ports[i].valid)
 			continue;
 
-		dev = alloc_etherdev(sizeof(struct dev_data));
-		if(!dev)
-			return;
+			dev = alloc_etherdev(sizeof(struct dev_data));
+			if(!dev)
+				return;
 
-		ether_setup(dev);
+			ether_setup(dev);
 
-		priv = netdev_priv(dev);
-		spin_lock_init(&priv->lock);
-		priv->dev 	= dev;
-		dev->netdev_ops = &nlm_xlp_nae_ops;
-
-		/* set ethtool_ops which is inside xlp_ethtool.c file*/
-		xlp_set_ethtool_ops(dev);
-
-		/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16);*/
-
-		dev->dev_addr = eth_hw_addr[i];
-		priv->port	= i;
-
-		priv->frin_desc_thres = nae_cfg.ports[i].num_free_desc / 3;
-		atomic_set(&priv->frin_to_be_sent, nae_cfg.ports[i].num_free_desc);
-		atomic_set(&priv->num_replenishes, 0);
-		atomic_set(&priv->total_frin_sent, 0);
-
-		priv->inited	= 0;
-		priv->block 	= nae_cfg.ports[i].hw_port_id / 4;
-		priv->type = nae_cfg.ports[i].iftype;
-		switch(nae_cfg.ports[i].iftype) {
-			case SGMII_IF:
-				priv->index = nae_cfg.ports[i].hw_port_id & 0x3;
-				priv->phy.addr = nae_cfg.ports[i].hw_port_id;
-				break;
-			case XAUI_IF:
-				priv->index = XGMAC;
-				break;	
-			case INTERLAKEN_IF:
-				priv->index = INTERLAKEN;
-				if (nae_cfg.ports[i].hw_port_id == 0) {
-                                       if (dev_alloc_name(dev, "ilk0-%d") < 0)
-                                                printk("alloc name failed \n");
-                                }
-                                else {
-                                        if (dev_alloc_name(dev, "ilk8-%d") < 0)
-                                                printk("alloc name failed \n");
-                                }
-				break;
-			default:
-				priv->index=0;
-				break;
-		}
-		printk("port%d hw %d block %d index %d type %d \n",i, nae_cfg.ports[i].hw_port_id, 
+			priv = netdev_priv(dev);
+			spin_lock_init(&priv->lock);
+			priv->dev 	= dev;
+			dev->netdev_ops = &nlm_xlp_nae_ops;
+
+			/* set ethtool_ops which is inside xlp_ethtool.c file*/
+			xlp_set_ethtool_ops(dev);
+
+			/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16);*/
+
+			dev->dev_addr = eth_hw_addr[node][i];
+			priv->port	= i;
+
+			priv->frin_desc_thres = nae_cfg->ports[i].num_free_desc / 3;
+			atomic64_set(&priv->frin_to_be_sent, nae_cfg->ports[i].num_free_desc);
+			atomic64_set(&priv->num_replenishes, 0);
+			atomic64_set(&priv->total_frin_sent, 0);
+
+			priv->inited = 0;
+			priv->node = node;
+			priv->block 	= nae_cfg->ports[i].hw_port_id / 4;
+			priv->type = nae_cfg->ports[i].iftype;
+			switch(nae_cfg->ports[i].iftype) {
+				case SGMII_IF:
+					priv->index = nae_cfg->ports[i].hw_port_id & 0x3;
+					priv->phy.addr = nae_cfg->ports[i].hw_port_id;
+					break;
+				case XAUI_IF:
+					priv->index = XGMAC;
+					break;	
+				case INTERLAKEN_IF:
+					priv->index = INTERLAKEN;
+					if (nae_cfg->ports[i].hw_port_id == 0) {
+                        	               if (dev_alloc_name(dev, "ilk0-%d") < 0)
+                                	                printk("alloc name failed \n");
+		                        }
+                	                else {
+                        	                if (dev_alloc_name(dev, "ilk8-%d") < 0)
+                                	                printk("alloc name failed \n");
+	                                }
+					break;
+				default:
+					priv->index=0;
+					break;
+			}
+			printk("port%d hw %d block %d index %d type %d \n",i, nae_cfg->ports[i].hw_port_id, 
 									priv->block, priv->index, priv->type);
-		priv->nae_tx_qid 	= nae_cfg.ports[i].txq_range[0];
-		priv->nae_rx_qid 	= nae_cfg.ports[i].rxq;
+			priv->nae_tx_qid 	= nae_cfg->ports[i].txq;
+			priv->nae_rx_qid 	= nae_cfg->ports[i].rxq;
 
-		register_netdev(dev);
+			register_netdev(dev);
 
-		dev_mac[i] = dev;
-		xlp_mac_setup_hwaddr(priv);
+			dev_mac[node][i] = dev;
+			random_ether_addr(dev->dev_addr);
+			xlp_mac_setup_hwaddr(priv);
 
+		}
+		nlm_initialize_vfbid(node, nae_cfg->fb_vc);
 	}
 
 	entry = create_proc_read_entry("mac_stats", 0 /* def mode */ ,
@@ -869,7 +909,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	/* set timer to test rx routine */
 	init_timer(&priv->link_timer);
 	priv->link_timer.expires = jiffies + HZ ; /* First timer after 1 sec */
-	priv->link_timer.data    = (unsigned long) priv->port;
+	priv->link_timer.data    = (unsigned long)((priv->node << 16) | priv->port);
 	priv->link_timer.function = &nlm_xlp_mac_timer;
 	priv->phy_oldlinkstat = -1;
 
@@ -1142,16 +1182,18 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv)
 {
         struct net_device *dev = priv->dev;
 
-        nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_LO, (dev->dev_addr[5] << 24) |
+	dev->dev_addr[1] = priv->node;
+ 
+        nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_LO, (dev->dev_addr[5] << 24) |
 				(dev->dev_addr[4] << 16) | (dev->dev_addr[3] << 8) | (dev->dev_addr[2]));
 
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) | 
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_HI, (dev->dev_addr[1] << 24) | 
 				(dev->dev_addr[0] << 16));
 
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_MASK_LO, 0xFFFFFFFF);
-	nlm_hal_write_mac_reg(priv->block, priv->index, MAC_ADDR0_MASK_HI, 0xFFFFFFFF);
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_MASK_LO, 0xFFFFFFFF);
+	nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_ADDR0_MASK_HI, 0xFFFFFFFF);
 
-        nlm_hal_write_mac_reg(priv->block, priv->index, MAC_FILTER_CONFIG, (1 << MAC_FILTER_BCAST_EN_POS) |
+        nlm_hal_write_mac_reg(priv->node, priv->block, priv->index, MAC_FILTER_CONFIG, (1 << MAC_FILTER_BCAST_EN_POS) |
 						 (1 << MAC_FILTER_MCAST_EN_POS) | (1 << MAC_FILTER_ADDR0_VALID_POS) );
 
 }
@@ -1195,10 +1237,10 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 	local_jumbo_mtu = new_mtu + ETH_HLEN + ETH_FCS_LEN;
 	local_jumbo_mtu = (local_jumbo_mtu + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1);
 	if(priv->type==SGMII_IF){
-		nlm_hal_set_sgmii_framesize(priv->block, priv->index, local_jumbo_mtu);
+		nlm_hal_set_sgmii_framesize(priv->node, priv->block, priv->index, local_jumbo_mtu);
 	}
 	if(priv->type==XAUI_IF){
-		nlm_hal_set_xaui_framesize(priv->block, local_jumbo_mtu, local_jumbo_mtu);
+		nlm_hal_set_xaui_framesize(priv->node, priv->block, local_jumbo_mtu, local_jumbo_mtu);
 	}
 
 	dev->mtu = new_mtu;
@@ -1335,7 +1377,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
         uint64_t addr , vaddr = 0;
 	struct sk_buff* skb;
 	struct jumbo_rx_cookie *rx_cookie = NULL;
-	int cpu = 0;
+	int cpu = 0, node = 0;
 	uint64_t *p2pfbdesc;
 
 	cpu = hard_smp_processor_id();
@@ -1359,8 +1401,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				return;
 			}
 		}	
+		node = (src_id >> 10) & 0x3;
 		context = (msg0 >> 40) & 0x3fff;
-		port = cntx2port[context];
+		port = *(cntx2port[node] + context);
 		//nlm_xlp_free_skb(addr, port);
 //#if 0		
 		p2pfbdesc = bus_to_virt(addr);
@@ -1419,7 +1462,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			//printk("P2p size=0x%x\n", len);
 		}	
 		//printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-                  //     src_id, vc, size, msg0, msg1);
+                //       src_id, vc, size, msg0, msg1);
 
 #ifdef DEBUG_RXPKT_ADDR_NULL
 		if (addr == 0) {
@@ -1440,7 +1483,9 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			}
 		}
 
-		port = cntx2port[context];
+		node = (src_id >> 10) & 0x3;
+		port = *(cntx2port[node] + context);
+
 #ifdef DEBUG_CONTEXT_PORT_MAPPING
 		if (port == 0) printk("Rx context %d port %d \n",context, port);    
 #endif
@@ -1450,7 +1495,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			return;
 		}
 
-		pdev = (struct net_device*)dev_mac[port];
+		pdev = (struct net_device*)dev_mac[node][port];
 		if(!pdev) {
 			printk("[%s]: [rx] wrong port=%d(context=%d)? pdev = NULL!\n", __func__, port, context);
 			return;
@@ -1508,10 +1553,10 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				pg = rx_cookie->page;
 				put_page(pg);
 			}
-			mac_frin_replenish_msgs(dev_mac[port], tot_desc);
+			mac_frin_replenish_msgs(dev_mac[node][port], tot_desc);
 			return;
 		}
-		mac_frin_replenish_msgs(dev_mac[port], tot_desc);
+		mac_frin_replenish_msgs(dev_mac[node][port], tot_desc);
 
 		/* allocate an skb for header */
 		skb = dev_alloc_skb(NETL_JUMBO_SKB_HDR_LEN + 16);
@@ -1522,7 +1567,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 			recycle_rx_desc(addr, pdev);
 			return;
 		}
-		skb->dev = dev_mac[port];
+		skb->dev = dev_mac[node][port];
 		hlen = (len > NETL_JUMBO_SKB_HDR_LEN) ? 
 				NETL_JUMBO_SKB_HDR_LEN: len;
 		/* after this call, skb->data is pointing to start of MAChdr */
@@ -1676,8 +1721,9 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
  **********************************************************************/
 static void nlm_xlp_mac_timer(unsigned long data)
 {
-	unsigned port = data;
-        struct net_device *dev = (struct net_device *)dev_mac[port];
+	unsigned port = data & 0xffff;
+	unsigned node = (data >> 16) & 0xffff;
+        struct net_device *dev = (struct net_device *)dev_mac[node][port];
         struct dev_data *priv = netdev_priv(dev);
         int next_tick = HZ / 1000; /* 1ms */
 
@@ -1725,20 +1771,22 @@ static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pc
  **********************************************************************/
 static void nlm_xlp_nae_remove(void)
 {
-	int i;
+	int i,node;
 	struct net_device *dev = 0;
         struct dev_data *priv = 0;
 
-	for (i = 0; i < MAX_GMAC_PORT; i++)
-	{
-		dev = dev_mac[i];
+	for(node=0; node< maxnae ; node++) {
+		for (i = 0; i < MAX_GMAC_PORT; i++)
+		{
+			dev = dev_mac[node][i];
 
-		if (dev == 0) continue;
+			if (dev == 0) continue;
 
-		priv = netdev_priv(dev);
-		//netif_napi_del(&priv->napi);
-		unregister_netdev(dev);
-		free_netdev(dev);
+			priv = netdev_priv(dev);
+			//netif_napi_del(&priv->napi);
+			unregister_netdev(dev);
+			free_netdev(dev);
+		}
 	}
 
 	remove_proc_entry("mac_stats", nlm_root_proc /* parent dir*/ );
diff --git a/drivers/net/ethernet/broadcom/nae/xlp_nae.h b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
index f60bbf0..e191842 100644
--- a/drivers/net/ethernet/broadcom/nae/xlp_nae.h
+++ b/drivers/net/ethernet/broadcom/nae/xlp_nae.h
@@ -59,6 +59,7 @@ struct dev_data
         spinlock_t lock;
         unsigned short port;
 	unsigned short inited;
+	unsigned short node;
         unsigned short block;
         unsigned short index;
         unsigned short type;
-- 
1.7.1

