From 1f4fdc6bc56ceac241401e4510ae49e5d9d353df Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Date: Thu, 6 Jun 2013 13:18:51 +0530
Subject: pktmem: modify implementation to use pktmem values from DTS file

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
index 512bf0d..a91ee4a 100644
--- a/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
+++ b/drivers/misc/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -4,35 +4,28 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
+#include "libfdt.h"
 
 
 #define MAX_NODES 	8
 #define MB(x) 		(x*1024*1024)
 #define PKTMEM_MAJOR 	123
 
-/* module parameters as array */
-static int addr[MAX_NODES];
-static int size[MAX_NODES];
-static int addr_count;
-static int size_count;
-
-module_param_array(addr, int, &addr_count, 0);
-module_param_array(size, int, &size_count, 0);
-
 typedef struct memory_pool 
 {
 	struct memory_pool * next;
 	unsigned long long start;
 	uint32_t size;
-	int inst_id;
+	char shr_id[64];
 	int in_use;
 } memory_pool_t;
 
 memory_pool_t mem_pool_data[MAX_NODES];
+uint32_t pktregs[MAX_NODES * 4];
 
 typedef struct brcm_devmem_ioctl {
 	unsigned int node_id;
-	unsigned int inst_id;
+	char shr_id[64];
 	unsigned long long phys_addr;
 	unsigned long long size;
 } brcm_devmem_ioctl_t;
@@ -51,8 +44,8 @@ static int print_memory(brcm_devmem_ioctl_t * param)
 	printk("pktmem: printing for node %d.\n", param->node_id);
 	while (mem != NULL)
 	{
-		printk("pktmem: addr %#x, size %#x, inst_id %d, in_use %d.\n",
-				mem->start, mem->size, mem->inst_id, mem->in_use);
+		printk("pktmem: addr 0x%llx, size 0x%x, shr_id %s, in_use %d.\n",
+				mem->start, mem->size, mem->shr_id, mem->in_use);
 		mem = mem->next;
 	}
 
@@ -67,11 +60,11 @@ static int alloc_memory (brcm_devmem_ioctl_t * param)
 	/* take care of shared memory request first */
 	mem = &mem_pool_data[param->node_id];
 	alloc = 0;
-	if (param->inst_id)
+	if (param->shr_id != NULL)
 	{
 		while (mem != NULL)
 		{
-			if (param->inst_id == mem->inst_id)
+			if (strcmp(param->shr_id,mem->shr_id) == 0)
 			{
 				param->phys_addr = mem->start;
 				alloc = 1;
@@ -93,6 +86,10 @@ static int alloc_memory (brcm_devmem_ioctl_t * param)
 			if (mem->size == param->size)
 			{
 				param->phys_addr = mem->start;
+				if (param->shr_id != NULL)
+					sprintf(mem->shr_id, param->shr_id);
+				else
+					sprintf(mem->shr_id, NULL);
 				mem->in_use = 1;
 				alloc = 1;
 				break;
@@ -101,10 +98,20 @@ static int alloc_memory (brcm_devmem_ioctl_t * param)
 			if (mem->size > param->size)
 			{
 				newmem = (memory_pool_t *) kmalloc(sizeof(memory_pool_t), GFP_KERNEL);
+
+				if (newmem == NULL)
+				{
+					printk ("pktmem: kmalloc failed.\n");
+					return -1;
+				}
+
 				newmem->next = NULL;
 				newmem->start = mem->start;
 				newmem->size = param->size;
-				newmem->inst_id = param->inst_id;
+				if (param->shr_id != NULL)
+					sprintf(newmem->shr_id, param->shr_id);
+				else
+					sprintf(newmem->shr_id, NULL);
 				newmem->in_use = 1;
 
 				param->phys_addr = newmem->start;
@@ -143,7 +150,7 @@ static int free_memory (brcm_devmem_ioctl_t * param)
 	{
 		if (param->phys_addr == mem->start)
 		{
-			mem->inst_id = 0;
+			sprintf(mem->shr_id, NULL);
 			mem->in_use = 0;
 			free = 1;
 			break;
@@ -198,14 +205,32 @@ static const struct file_operations pktmem_ops = {
 	.unlocked_ioctl = pktmem_ioctl,
 };
 
-/*
-   It could be insmod pktmem.ko -mem_region <node_id>,<start_address>,<size> -mem_region <node_id>,<start_address>,<size> ...
-   modprobe pktmem.ko addr=1024,2048 size=32,64
-   */
+static inline int get_fdt_prop(void *fdt, const char* node_path,
+		const char *prop, void *prop_buf, int type)
+{
+	int prop_len;
+	const void *pbuf;
+	int node;
+
+	node = fdt_path_offset(fdt, node_path);
+	if (node < 0)
+		return -1;
+
+	pbuf = (char *)fdt_getprop(fdt, node, prop, &prop_len);
+	if (pbuf == NULL)
+		return -1;
+
+	memcpy((void *) prop_buf, (void * )pbuf, prop_len);
+
+	return 0;
+}
+
+extern void*fdt;
+/* see "pktmem" section in DTS file for providing memory */
 
 static int __init brcm_xlp_ppm_init (void)
 {
-	int i;
+	int i, node;
 
 	i = register_chrdev(PKTMEM_MAJOR, "brcm_pktmem", &pktmem_ops);
 	if (i < 0)
@@ -214,26 +239,33 @@ static int __init brcm_xlp_ppm_init (void)
 		return i;
 	}
 
-	printk("pktmem: addr count: %d, size count %d.\n", addr_count, size_count);
-	if ((addr_count != size_count) || !(addr_count) || !(size_count))
+	for (i=0; i<MAX_NODES*4; i++) pktregs[i] = 0;
+
+	/* read from FDT and fill the array */
+	if (get_fdt_prop(fdt, "/pktmem", "reg", pktregs, 1) == 0)
 	{
-		printk("pktmem: addr and size mismatch.\n");
-		printk("pktmem usage: modprobe pktmem.ko addr=10,20 size=2,4 in MB.\n");
+		for (i=0; i<MAX_NODES*4; i=i+4)
+		{
+			node = i/4;
+			mem_pool_data[node].next = NULL;
+			memset(mem_pool_data[node].shr_id, '\0', 64);
+			mem_pool_data[node].in_use = 0;
+			mem_pool_data[node].start = pktregs[i+1];
+			mem_pool_data[node].size = pktregs[i+3];
+		}
+	}
+	else
+	{
+		printk(KERN_ERR "brcm_pktmem: unable to read pktmem from DTB.\n");
 		return -1;
 	}
 
+
+	/* print the pktmem array */
 	for (i=0; i<MAX_NODES; i++)
 	{
-		mem_pool_data[i].next = NULL;
-		mem_pool_data[i].inst_id = 0;
-		mem_pool_data[i].in_use = 0;
-		mem_pool_data[i].start = (unsigned long long) MB(addr[i]);
-		mem_pool_data[i].size = (uint32_t) MB(size[i]);
-		printk("pktmem: node %d, addr %#x size %#x.\n", 
+		printk("pktmem: node %d, addr 0x%llx size 0x%x.\n",
 				i, mem_pool_data[i].start, mem_pool_data[i].size);
-#if 0
-		printk("pktmem: node %d, addr %d MB size %d MB.\n", i, addr[i], size[i]);
-#endif
 	}
 
 	printk (" brcm pkt mem module init.\n");
-- 
1.7.1

