From db880d910e1c53a2c232e3d8f910d614e58ce7b3 Mon Sep 17 00:00:00 2001
From: Anshu Kumari <anshuk@broadcom.com>
Date: Wed, 19 Nov 2014 12:12:53 +0530
Subject: xlp5xx nae: updated bring up sequence for XLAUI/XFI.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 9875614..8900915 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -781,9 +781,19 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                        pma2p0_cmd |= (1<<1) | (1<<0);
                        __netsoc_write_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0, 13, pma2p0_cmd);
                }
+      }
 
+      if(phy_mode == PHYMODE_XFI && is_nlm_xlp5xx()){
+               for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
+               			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base,  lane_no, 7);
+               			pma2p0_cmd |= (1<<2);
+               			__netsoc_write_pma2p0_reg(mac_base, lane_no, 7, pma2p0_cmd);
+               			pma2p0_cmd = __netsoc_read_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 13);
+               			pma2p0_cmd |= (1<<1) | (1<<0);
+               			__netsoc_write_pma2p0_reg(mac_base, PMA2P0_COMMON_LANE0 + lane_no, 13, pma2p0_cmd);
+               	}
+      }
 
-       }               
 
 
 	for(delay=0; delay<10000; delay++);
@@ -792,8 +802,8 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
 	if(is_nlm_xlp5xx()){
 
-    		pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET | PMA2P0_LANE0_SYNTH_HARD_RESET);
-		 pma2p0_config  &= ~(PMA2P0_LANE1_RXTX_HARD_RESET | PMA2P0_LANE1_SYNTH_HARD_RESET);
+     	        pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET | PMA2P0_LANE0_SYNTH_HARD_RESET);
+    	         pma2p0_config  &= ~(PMA2P0_LANE1_RXTX_HARD_RESET | PMA2P0_LANE1_SYNTH_HARD_RESET);
 		pma2p0_config &= ~(PMA2P0_LANE2_RXTX_HARD_RESET | PMA2P0_LANE2_SYNTH_HARD_RESET);
 		pma2p0_config &= ~(PMA2P0_LANE3_RXTX_HARD_RESET | PMA2P0_LANE3_SYNTH_HARD_RESET);
 	}else{
@@ -1525,10 +1535,11 @@ void __netsoc_pma2p0_txrx_hard_reset(nae_t *nae, int block, int lane_no)
 	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
 	pma2p0_config |= (PMA2P0_LANE0_RXTX_HARD_RESET <<lane_no);
 	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
-	nlm_mdelay(1);
+	nlm_mdelay(10);
 	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
 	pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET <<lane_no);
 	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	nlm_mdelay(10);
 }
 
 void __netsoc_pma2p0_synth_hard_reset(nae_t *nae, int block, int phymode)
@@ -1582,14 +1593,17 @@ void __netsoc_check_for_remote_fault(nae_t *nae)
 		if(netport->iftype == XFI_IF){
 			uint64_t mac_base = __netsoc_get_xgmac_base(netport);
 			rd_data	= netsoc_read_mac_reg(mac_base, XGMAC_CONFIG_REG3);
+			nlm_mdelay(1);
 			retry_count = 0;
 			while ((rd_data & (1<<25)) == (1<<25)) {
 				//nlm_print(" Remote fault bit is detected for complex%d lane(port)%d\n", netport->block_id, port);
 				__netsoc_pma2p0_txrx_hard_reset(nae, netport->block_id, netport->hw_port_id%4);
-				if (retry_count++ > 100) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"blockx%d lane%d: Uncorrectable Remote Fault\n",  netport->block_id, port);
+				if (retry_count++ > 25) {
+					//netsoc_api_print(NETSOC_APIDBG_ERROR,"blockx%d lane%d: Uncorrectable Remote Fault\n",  netport->block_id, port);
+					break;
 				}
 				rd_data	= netsoc_read_mac_reg(mac_base, XGMAC_CONFIG_REG3);
+				nlm_mdelay(1);
             		}
 		
 		}else if(netport->iftype == XLAUI_IF){
-- 
1.7.1

