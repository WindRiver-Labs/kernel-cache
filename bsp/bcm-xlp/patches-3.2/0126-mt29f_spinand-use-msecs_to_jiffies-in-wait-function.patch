From 983844608ad4b26dac38bb7243127fb5ad96e941 Mon Sep 17 00:00:00 2001
From: Kamlakant Patel <kamlakant.patel@broadcom.com>
Date: Tue, 9 Sep 2014 16:39:15 +0530
Subject: mt29f_spinand: use msecs_to_jiffies in wait function

 * Remove wait_till_ready to use generic waitfunc
 * Replace HZ with msecs_to_jiffies
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/staging/mt29f_spinand/mt29f_spinand.c b/drivers/staging/mt29f_spinand/mt29f_spinand.c
index 958fdfb..5f0d41b 100644
--- a/drivers/staging/mt29f_spinand/mt29f_spinand.c
+++ b/drivers/staging/mt29f_spinand/mt29f_spinand.c
@@ -163,29 +163,6 @@ static int spinand_read_status(struct spi_device *spi_nand, uint8_t *status)
 	return ret;
 }
 
-#define MAX_WAIT_JIFFIES  (40 * HZ)
-static int wait_till_ready(struct spi_device *spi_nand)
-{
-	unsigned long deadline;
-	int retval;
-	u8 stat = 0;
-
-	deadline = jiffies + MAX_WAIT_JIFFIES;
-	do {
-		retval = spinand_read_status(spi_nand, &stat);
-		if (retval < 0)
-			return -1;
-		else if (!(stat & 0x1))
-			break;
-
-		cond_resched();
-	} while (!time_after_eq(jiffies, deadline));
-
-	if ((stat & 0x1) == 0)
-		return 0;
-
-	return -1;
-}
 /**
  * spinand_get_otp- send command 0xf to read the SPI Nand OTP register
  * Description:
@@ -353,7 +330,8 @@ static int spinand_read_from_cache(struct spi_device *spi_nand, u16 page_id,
  *   The read includes two commands to the Nand: 0x13 and 0x03 commands
  *   Poll to read status to wait for tRD time.
  */
-static int spinand_read_page(struct spi_device *spi_nand, u16 page_id,
+static int spinand_read_page(struct nand_chip *chip,
+		struct spi_device *spi_nand, u16 page_id,
 		u16 offset, u16 len, u8 *rbuf)
 {
 	int ret;
@@ -369,8 +347,8 @@ static int spinand_read_page(struct spi_device *spi_nand, u16 page_id,
 	if (ret < 0)
 		return ret;
 
-	if (wait_till_ready(spi_nand))
-		dev_err(&spi_nand->dev, "WAIT timedout!!!\n");
+	if (chip->waitfunc(NULL, chip))
+		dev_err(&spi_nand->dev, "device not ready!!!\n");
 
 	while (1) {
 		ret = spinand_read_status(spi_nand, &status);
@@ -474,7 +452,8 @@ static int spinand_program_execute(struct spi_device *spi_nand, u16 page_id)
  *   write execute command.
  *   Poll to wait for the tPROG time to finish the transaction.
  */
-static int spinand_program_page(struct spi_device *spi_nand,
+static int spinand_program_page(struct nand_chip *chip,
+		struct spi_device *spi_nand,
 		u16 page_id, u16 offset, u16 len, u8 *buf)
 {
 	int retval;
@@ -485,7 +464,7 @@ static int spinand_program_page(struct spi_device *spi_nand,
 
 	enable_read_hw_ecc = 0;
 	wbuf = devm_kzalloc(&spi_nand->dev, CACHE_BUF, GFP_KERNEL);
-	spinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf);
+	spinand_read_page(chip, spi_nand, page_id, 0, CACHE_BUF, wbuf);
 
 	for (i = offset, j = 0; i < len; i++, j++)
 		wbuf[i] &= buf[j];
@@ -505,8 +484,9 @@ static int spinand_program_page(struct spi_device *spi_nand,
 		dev_err(&spi_nand->dev, "write enable failed!!\n");
 		return retval;
 	}
-	if (wait_till_ready(spi_nand))
-		dev_err(&spi_nand->dev, "wait timedout!!!\n");
+
+	if (chip->waitfunc(NULL, chip))
+		dev_err(&spi_nand->dev, "device not ready!!!\n");
 
 	retval = spinand_program_data_to_cache(spi_nand, page_id,
 			offset, len, wbuf);
@@ -581,14 +561,15 @@ static int spinand_erase_block_erase(struct spi_device *spi_nand, u16 block_id)
  *   and then send the 0xd8 erase command
  *   Poll to wait for the tERS time to complete the tranaction.
  */
-static int spinand_erase_block(struct spi_device *spi_nand, u16 block_id)
+static int spinand_erase_block(struct nand_chip *chip,
+		struct spi_device *spi_nand, u16 block_id)
 {
 	int retval;
 	u8 status = 0;
 
 	retval = spinand_write_enable(spi_nand);
-	if (wait_till_ready(spi_nand))
-		dev_err(&spi_nand->dev, "wait timedout!!!\n");
+	if (chip->waitfunc(NULL, chip))
+		dev_err(&spi_nand->dev, "device not ready!!!\n");
 
 	retval = spinand_erase_block_erase(spi_nand, block_id);
 	while (1) {
@@ -676,23 +657,27 @@ static int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	struct spinand_info *info = (struct spinand_info *)chip->priv;
 
-	unsigned long timeo = jiffies;
-	int retval, state = chip->state;
+	unsigned long timeout, stoptime, checktime;
 	u8 status;
+	int timedout;
 
-	if (state == FL_ERASING)
-		timeo += (HZ * 400) / 1000;
-	else
-		timeo += (HZ * 20) / 1000;
+	timeout = msecs_to_jiffies(100);
+	stoptime = jiffies + timeout;
+	timedout = 0;
+
+	while (!timedout) {
+		checktime = jiffies;
+		if (spinand_read_status(info->spi, &status) < 0)
+			break;
 
-	while (time_before(jiffies, timeo)) {
-		retval = spinand_read_status(info->spi, &status);
 		if ((status & STATUS_OIP_MASK) == STATUS_READY)
 			return 0;
 
-		cond_resched();
+		timedout = time_after(checktime, stoptime);
+
+		schedule();
 	}
-	return 0;
+	return -ETIMEDOUT;
 }
 
 static void spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
@@ -713,7 +698,7 @@ static void spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 /*
  * spinand_reset- send RESET command "0xff" to the Nand device.
  */
-static void spinand_reset(struct spi_device *spi_nand)
+static void spinand_reset(struct nand_chip *chip, struct spi_device *spi_nand)
 {
 	struct spinand_cmd cmd = {0};
 
@@ -725,8 +710,8 @@ static void spinand_reset(struct spi_device *spi_nand)
 	/* elapse 1ms before issuing any other command */
 	udelay(1000);
 
-	if (wait_till_ready(spi_nand))
-		dev_err(&spi_nand->dev, "wait timedout!\n");
+	if (chip->waitfunc(NULL, chip))
+		dev_err(&spi_nand->dev, "device not ready!!!\n");
 }
 
 static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
@@ -743,12 +728,13 @@ static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
 	case NAND_CMD_READ1:
 	case NAND_CMD_READ0:
 		state->buf_ptr = 0;
-		spinand_read_page(info->spi, page, 0x0, 0x840, state->buf);
+		spinand_read_page(chip, info->spi, page, 0, 0x840, state->buf);
 		break;
 	/* READOOB reads only the OOB because no ECC is performed. */
 	case NAND_CMD_READOOB:
 		state->buf_ptr = 0;
-		spinand_read_page(info->spi, page, 0x800, 0x40, state->buf);
+		spinand_read_page(chip, info->spi, page, 0x800, 0x40,
+				state->buf);
 		break;
 	case NAND_CMD_RNDOUT:
 		state->buf_ptr = column;
@@ -762,7 +748,7 @@ static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
 		break;
 	/* ERASE1 stores the block and page address */
 	case NAND_CMD_ERASE1:
-		spinand_erase_block(info->spi, page);
+		spinand_erase_block(chip, info->spi, page);
 		break;
 	/* ERASE2 uses the block and page address from ERASE1 */
 	case NAND_CMD_ERASE2:
@@ -775,7 +761,7 @@ static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
 		break;
 	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
 	case NAND_CMD_PAGEPROG:
-		spinand_program_page(info->spi, state->row, state->col,
+		spinand_program_page(chip, info->spi, state->row, state->col,
 				state->buf_ptr, state->buf);
 		break;
 	case NAND_CMD_STATUS:
@@ -786,11 +772,11 @@ static void spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
 		break;
 	/* RESET command */
 	case NAND_CMD_RESET:
-		if (wait_till_ready(info->spi))
-			dev_err(&info->spi->dev, "WAIT timedout!!!\n");
+		if (chip->waitfunc(NULL, chip))
+			dev_err(&info->spi->dev, "device not ready!!!\n");
 		/* a minimum of 250us must elapse before issuing RESET cmd*/
 		udelay(250);
-		spinand_reset(info->spi);
+		spinand_reset(chip, info->spi);
 		break;
 	default:
 		dev_err(&mtd->dev, "Unknown CMD: 0x%x\n", command);
-- 
1.7.1

