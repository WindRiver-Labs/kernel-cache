From 54fa53de7191cedc5ef2fc3613d6b284865089d8 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Tue, 14 May 2013 18:28:10 +0530
Subject: dtre: added xlp9xx support

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/dtre/nlm_adma.c b/drivers/misc/netlogic/dtre/nlm_adma.c
index 81181a5..7281270 100644
--- a/drivers/misc/netlogic/dtre/nlm_adma.c
+++ b/drivers/misc/netlogic/dtre/nlm_adma.c
@@ -426,6 +426,13 @@ static dma_cookie_t nlm_tx_submit (struct dma_async_tx_descriptor *tx)
 	chan = (struct nlm_adma_chan *)(nlm_tx->chan);
 
 	/* update dest vc_id from channel number */
+	/* TODO: xlp9xx
+	   1. check if any change is required here, while calculating vc_id
+	   2. probably not required, under following assumptions
+	      channel 0,1: belong to DTRE-0 and channel 0 is for RAID
+	      channel 2,3: belong to DTRE-1 and channel 2 is for RAID
+	      */
+
 	vc_id = DTRE_MIN_VC + chan->chan_num;
 
 	spin_lock_bh(&chan->lock);
@@ -1451,16 +1458,43 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 	int i, err, loop;
 	uint64_t base;
 	uint32_t value;
+	int is_raid = 0;
+
 
+	if (is_nlm_xlp9xx())
+	{
+		/* TODO: xlp9xx
+		   1. register station IDs of both engines
+		   2. confirm FMN station IDs
+		   3. check if any changes are required in onchip.c
+		*/
+		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_0, nlm_dtre_msgring_handler, NULL))
+		{
+			printk("Error: NLM-ADMA unable to register for msgring handler\n");
+			return -1;
+		}
 
-	if (register_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, nlm_dtre_msgring_handler, NULL)){
-		printk("Error: NLM-ADMA unable to register for msgring handler\n");
-		return -1;
+		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_GDX_1, nlm_dtre_msgring_handler, NULL))
+		{
+			printk("Error: NLM-ADMA unable to register for msgring handler\n");
+			return -1;
+		}
+	}
+	else
+	{
+		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_DTRE, nlm_dtre_msgring_handler, NULL)){
+			printk("Error: NLM-ADMA unable to register for msgring handler\n");
+			return -1;
+		}
 	}
 
 	for (loop = 0; loop < DTRE_NUM_CHANNELS; loop++)
 	{
+		/* assume current channel is DMA (not raid)
+		   change it later in the loop (if required) */
 
+		/* TODO: xlp9xx, check this logic */
+		is_raid = 0;
 		adev = kzalloc(sizeof(*adev), GFP_KERNEL);
 		if (!adev)
 			return -ENOMEM;
@@ -1503,9 +1537,30 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 
 		/* set base routines */
 
-		/* set RAID capabilities for chan 0 and 
-		   MEM capabilities for chan 1-3 */
-		if (loop == 0)
+		if (is_nlm_xlp9xx())
+		{
+			/* TODO: xlp9xx check this logic 
+			   assume channel 0 & 2 are for RAID 
+			   (ie., the first channel on each engine)
+			*/
+			if ((loop == 0) || (loop == 2)){
+				is_raid = 1;
+			} else {
+				is_raid = 0;
+			}
+		}
+		else
+		{
+			/* set RAID capabilities for chan 0 and 
+			   MEM capabilities for chan 1-3 */
+			if (loop == 0) {
+				is_raid = 1;
+			} else {
+				is_raid = 0;
+			}
+		}
+
+		if (is_raid == 1)
 		{
 			dma_cap_set(DMA_XOR, dma_dev->cap_mask);
 			dma_cap_set(DMA_XOR_VAL, dma_dev->cap_mask);
@@ -1550,13 +1605,33 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 
 	printk("NLM ASYNC Device Registered\n");
 
-	/* hal init stuff */
+	/* hal initialization */
 	nlm_hal_dtr_init(fdt);
 
+	/* for DTRE0 */
 	base = nlm_hal_get_dev_base (0 /*node*/, 0 /*B*/, 5 /*D*/, 0 /*F*/);
 	value = nlm_hal_read_32bit_reg (base, 0x40);
+
+	/* set channel 0 is raid - bit 4 */
 	nlm_hal_write_32bit_reg (base, 0x40, value | (0x10));
 
+	/* TODO: xlp9xx
+	   if this is xlp9xx, we need to set for engine DTRE1 also.
+	   1. check BDF values
+	   2. check master control register numbers
+	   3. update both master control register
+	   here, we are assuming one master control register for each engine
+	   */
+	if (is_nlm_xlp9xx())
+	{
+		/* for DTRE1 */
+		base = nlm_hal_get_dev_base (0 /*node*/, 0 /*B*/, 5 /*D*/, 6 /*F*/);
+		value = nlm_hal_read_32bit_reg (base, 0x40);
+
+		/* set channel 0 is raid - bit 4 */
+		nlm_hal_write_32bit_reg (base, 0x40, value | (0x10));
+	}
+
 	return 0;
 }
 
-- 
1.7.1

