From 13311550bb09362b092ae30c46ee7ca35c093776 Mon Sep 17 00:00:00 2001
From: P. Sadik <psadik@broadcom.com>
Date: Fri, 5 Jul 2013 12:16:48 +0530
Subject: hyperexec: Fix compilation errors.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 71931ef..1502ce0 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -105,7 +105,7 @@ static void fdt_derive_cpu_to_freein_fifo_map(nae_t *nae,
 }
 
 
-/* Returns 1 if the domain is the nae owner, 
+/* Returns 1 if the domain is the nae owner,
  Returns 0 otherwise */
 int fdt_get_dom_nae_node_ownership(void *fdt, int dom_id, nae_t *nae)
 {
@@ -140,14 +140,14 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
 	if(socnet_version_v0){
 		strcpy(xaui_chk_str, "xaui");
 	}else{
-		
+
 		strcpy(xaui_chk_str, "xgmac");
 	}
 #endif
 #ifndef XLP_SIM
         if (GET_PORT_STR_PROP("cpld", port_type_str, MAX_PROP_LEN) < 0) {
 		intf_type = DC_NOT_PRSNT;
-        } 
+        }
 	else {
 		if (!strcmp(port_type_str,"yes"))
                	 	intf_type = nlm_get_interface_type(node, block);
@@ -217,7 +217,7 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                                 netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Complex %d in XAUI_HIGIG mode\n", block);
                                 nae_cfg->ports[port].iftype = XAUI_IF;
                                 break;
-                        }      
+                        }
                         // FIXME interlaken supported only on node-0 nae
                         if ((is_nlm_xlp3xx()) || (node != 0)) {
                                 netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Interlaken not supported \n");
@@ -282,7 +282,7 @@ static void get_dom_nae_property(void *fdt, int dom_id, int nae_id, char *ppty,
         }
 }
 
-void fdt_extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, nae_t *nae_cfg)		
+void fdt_extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, nae_t *nae_cfg)
 {
         char dom_node_str[128];
         int i;
@@ -354,7 +354,7 @@ static void xlp9xx_fdt_derive_cpu_to_freein_fifo_map(nae_t *nae,
 
         while(i < XLP_NCPUS_PER_NODE){
                 for(j=0; j < XLP_NCPUS_PER_NODE && i < NLM_NCPUS_PER_NODE; j++){
-                        cpumapindex = j / 32; 
+                        cpumapindex = j / 32;
                         if(!(phys_cpu_map[cpumapindex] & (1 << j)))
                                 continue;
                         lcpu_2_pcpu[i] = j;
@@ -390,14 +390,14 @@ int xlp9xx_prepare_nae_shared_info(void *fdt, int dom_id, nae_t *nae_cfg)
 {
         char dom_node_str[128];
         int nodeoffset;
-        unsigned int *pval; 
+        unsigned int *pval;
         int plen, i, j;
         int pos, bitoff, max;
 #define XLP_NCPUS_PER_NODE_NENT		XLP_NCPUS_PER_NODE/ 32
         unsigned int map[NLM_MAX_NODES][XLP_NCPUS_PER_NODE_NENT], fmask[NLM_MAX_NODES], node = nae_cfg->node;
         struct nlm_nae_shinfo shinfo;
         static int shdomains[MAX_NAE_BLOCKS][NLM_NAE_MAX_SHARED_DOMS], shdom_extracted[MAX_NAE_BLOCKS] = {0, 0};
-        int domid = dom_id, cnt = 0, nae_id = nae_cfg->nae_id; 
+        int domid = dom_id, cnt = 0, nae_id = nae_cfg->nae_id;
         int frin_total_queue = __netsoc_get_frin_total_queue(nae_cfg);
         unsigned int lcpu_2_pcpu[XLP_NCPUS_PER_NODE], cpu_2_fifo[XLP_NCPUS_PER_NODE];
         unsigned int cpusonline[NLM_MAX_NODES];
@@ -422,7 +422,7 @@ start_for_dom:
 
         memset((char *)&shinfo, 0, sizeof(shinfo));
         memset(lcpu_2_pcpu, 0, sizeof(lcpu_2_pcpu));
-            
+
         sprintf(dom_node_str, "/doms/dom@%d/cpu", domid);
         nodeoffset = fdt_path_offset(fdt, dom_node_str);
         if(nodeoffset >= 0) {
@@ -441,7 +441,7 @@ start_for_dom:
 #ifdef NAE_SH_INFO_DBG
                         netsoc_api_print(NETSOC_APIDBG_FDT,"%s domid %d node %d cpumask %d: 0x%x \n", __FUNCTION__, domid, nodeindex,
                                             cpumapindex, map[nodeindex][cpumapindex]);
-#endif     
+#endif
                         }
                 }
                 pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-vc", &plen);
@@ -466,7 +466,7 @@ start_for_dom:
                 i = 0;
                 while(i < XLP_NCPUS_PER_NODE){
                         for(j=0; j < XLP_NCPUS_PER_NODE && i < XLP_NCPUS_PER_NODE; j++){
-                                cpumapindex = j / 32; 
+                                cpumapindex = j / 32;
                                 if(!(map[node][cpumapindex] & (1 << j)))
                                         continue;
                                 pos = i / NAEV1_SH_LCPU_TO_MAP_NVALS_PER_ENTRY;
@@ -489,12 +489,12 @@ start_for_dom:
 #endif
         }
 
-              /* We need to avoid usage same fifo in different cores if possible. Also the filling should 
-        be physical cpu id based, as the application knows only phys cpu id 
+              /* We need to avoid usage same fifo in different cores if possible. Also the filling should
+        be physical cpu id based, as the application knows only phys cpu id
          */
         if(fmask[node]) {
                 if (cpusonline[node])
-                     xlp9xx_fdt_derive_cpu_to_freein_fifo_map(nae_cfg, map[nae_cfg->node], fmask[nae_cfg->node], cpu_2_fifo);       
+                     xlp9xx_fdt_derive_cpu_to_freein_fifo_map(nae_cfg, map[nae_cfg->node], fmask[nae_cfg->node], cpu_2_fifo);
                 for(i = 0; i < XLP_NCPUS_PER_NODE; i++) {
                         pos = i / NAEV1_SH_LCPU_TO_MAP_NVALS_PER_ENTRY;
                         bitoff = (i % NAEV1_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) *
@@ -517,7 +517,7 @@ start_for_dom:
         shinfo.valid = 1;
         memcpy((char *)&nae_cfg->shinfo[cnt], (char *)&shinfo, sizeof(shinfo));
 err:
-  
+
         while(cnt < NLM_NAE_MAX_SHARED_DOMS) {
                 if((domid = shdomains[nae_id][cnt]) >= 0)
                         break;
@@ -618,8 +618,8 @@ start_for_dom:
 #endif
         }
 
-              /* We need to avoid usage same fifo in different cores if possible. Also the filling should 
-        be physical cpu id based, as the application knows only phys cpu id 
+              /* We need to avoid usage same fifo in different cores if possible. Also the filling should
+        be physical cpu id based, as the application knows only phys cpu id
          */
         if(fmask[node]) {
                 fdt_derive_cpu_to_freein_fifo_map(nae_cfg, map[nae_cfg->node], fmask[nae_cfg->node], cpu_2_fifo);	//FIXME
@@ -645,12 +645,12 @@ start_for_dom:
         shinfo.valid = 1;
         memcpy((char *)&nae_cfg->shinfo[cnt], (char *)&shinfo, sizeof(shinfo));
 err:
-   
+
         while(cnt < NLM_NAE_MAX_SHARED_DOMS) {
                 if((domid = shdomains[cnt]) >= 0)
                         break;
                 cnt++;
-        }  
+        }
         if(cnt < NLM_NAE_MAX_SHARED_DOMS)  {
                 cnt++;
                 goto start_for_dom;
@@ -719,7 +719,7 @@ static int fdt_parse_freein_fifo_cfg(void *fdt, nae_t *nae)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -729,7 +729,7 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
         char path_str[50];
         uint32_t count = 1, node=nae->node;
 	ucore_config_t *ucore;
-	
+
         for(count = 1; count <= MAX_UCORE_SRCS; count++) {
             if (socnet_version_v0) {
                sprintf(path_str, "/soc/nae@node-%d/ucore/src@%d",node, count);
@@ -738,7 +738,7 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
                sprintf(path_str, "/soc/net@node-%d/nae-%d/ucore/src@%d", node, nae->nae_id, count);
             }
 
-	    ucore = &nae->ucore_config[count-1];	
+	    ucore = &nae->ucore_config[count-1];
 	    nodeoffset = fdt_path_offset(fdt, path_str);
 	    if (nodeoffset >= 0) {
 		if (ucore->opcodes != NULL) {
@@ -748,7 +748,7 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
 
 		if (socnet_version_v0) {
 			if (GET_UCORE_PROP(path_str, "mask", &ucore->mask, sizeof(uint32_t)) < 0)
-				ucore->mask = current_netsoc->ucore_mask;	
+				ucore->mask = current_netsoc->ucore_mask;
 		}
 		else {
 			if (GET_UCORE_PROP(path_str, "mask", &ucore->mask, sizeof(uint32_t)) < 0) {
@@ -785,8 +785,8 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
 		netsoc_api_print(NETSOC_APIDBG_FDT,"Ucore Src %d not available\n", count);
 		ucore->valid = 0;
                 ucore->opcodes = NULL;
-	   }	
-	   netsoc_api_print(NETSOC_APIDBG_FDT, "src %d num_opcodes %d opc %p \n", count, ucore->num_opcodes, ucore->opcodes);		
+	   }
+	   netsoc_api_print(NETSOC_APIDBG_FDT, "src %d num_opcodes %d opc %p \n", count, ucore->num_opcodes, ucore->opcodes);
         }
 	return NETSOC_API_SUCCESS;
 }
@@ -799,7 +799,7 @@ int fdt_parse_ucore_config(void *fdt, nae_t *nae)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -840,7 +840,7 @@ int fdt_parse_vfbid_config(void *fdt, nae_t *nae_cfg)
         if(GET_NAE_PROP(vfbid_path, "hw-replenish", &hw_replenish, sizeof(uint32_t)) < 0){
                 //netsoc_api_print(NETSOC_APIDBG_FDT,"fdt missing hw-replenish\n");
         }
-        else {  
+        else {
                 if (hw_replenish != 0)
                         nae_cfg->flags |= FREEBACK_TO_NAE;
                 else
@@ -876,7 +876,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 		update_default_config(intf_type, cmplx->num_channels, get_numchannel(intf_type));
 		netsoc_api_print(NETSOC_APIDBG_FDT,"num channel %d\n",get_numchannel(intf_type));
 	}
-		
+
   	if (GET_PORT_PROP("num-free-descs", &cmplx->num_free_desc, sizeof(cmplx->num_free_desc)) < 0) {
 		update_default_config(intf_type, cmplx->num_free_desc, get_numfree_desc(intf_type));
 	}
@@ -903,15 +903,14 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 
         if (GET_PORT_PROP("higig-mode",&cmplx->higig_mode, sizeof(cmplx->higig_mode)) < 0) {
 			cmplx->higig_mode = get_higig_mode(intf_type);
-	} 
+	}
 
         if (GET_PORT_PROP("xgmii-speed",&cmplx->xgmii_speed, sizeof(cmplx->xgmii_speed)) < 0) {
 			cmplx->xgmii_speed = get_xgmii_speed(intf_type);
 	}
 
-        GET_PORT_PROP("msec-port-enable",&cmplx->msec_port_enable, sizeof(cmplx->msec_port_enable)); 
-	//printk("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cmplx->msec_port_enable = %x", cmplx->msec_port_enable);
-        
+        GET_PORT_PROP("msec-port-enable",&cmplx->msec_port_enable, sizeof(cmplx->msec_port_enable));
+
         if (GET_PORT_PROP("submode",&cmplx->rxaui_submode, sizeof(cmplx->rxaui_submode)) < 0) {
 		for(i=0; i<sizeof(cmplx->rxaui_submode)/sizeof(uint32_t); i++)
 			cmplx->rxaui_submode[i] = NLP1042_PHY_10G_NONE;
@@ -921,7 +920,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 		for(i=0; i<sizeof(cmplx->rxaui_scrambler)/sizeof(uint32_t); i++)
 			cmplx->rxaui_scrambler[i] = 0;
 	}
-        
+
 	if ((intf_type == RXAUI_IF) || (intf_type == XAUI_IF)) {
         	if (GET_PORT_PROP("ext-phy-addr",&cmplx->ext_phy_addr, sizeof(cmplx->ext_phy_addr)) < 0) {
 			for(i=0; i<sizeof(cmplx->ext_phy_addr)/sizeof(uint32_t); i++)
@@ -932,7 +931,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 				cmplx->ext_phy_bus[i] = 0;
 		}
 	}
-        
+
 	if (intf_type == SGMII_IF) {
                 if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                      for (i = 0 ; i < 4; i++) {
@@ -943,7 +942,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
                 GET_PORT_PROP("ext-phy-addr", &cmplx->ext_phy_addr, sizeof(cmplx->ext_phy_addr));
                 GET_PORT_PROP("ext-phy-bus", &cmplx->ext_phy_bus, sizeof(cmplx->ext_phy_bus));
         }
-        else if (intf_type == INTERLAKEN_IF) {  
+        else if (intf_type == INTERLAKEN_IF) {
                 if(GET_PORT_PROP("num-lanes", &cmplx->num_lanes, sizeof(uint32_t)) < 0) {
                         netsoc_api_print(NETSOC_APIDBG_FDT,"fdt missing num-lanes, default 4\n");
                         cmplx->num_lanes = 8;
@@ -992,10 +991,10 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
         else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                 txq = (node <<10) | XLP_3XX_NET_TX_VC_BASE;
         }
-        else {  
+        else {
                 txq = (node <<10) | XLP_NET_TX_VC_BASE;
         }
-	
+
 
 	for(block=0, port = 0; block < max_complex; block++) {
 #ifndef XLP_SIM
@@ -1118,7 +1117,6 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 
                 num_ports = get_num_ports(block, intf_type);
                 extract_complex_params(fdt, intf_type, nae_port_str, &cmplx_cfg);
-		//printk("%s cmplx_cfg.msec_port_enable = %x\n",__FUNCTION__, cmplx_cfg.msec_port_enable);
 
                 if(intf_type == XAUI_IF || intf_type == RXAUI_IF)
                 {
@@ -1134,8 +1132,6 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_cfg->higig_mode[block]=0;
                         nae_cfg->xgmii_speed[block]=1; /*1G SGMII*/
                 }
-                //printk("\n#@#@@@###################@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ nae_cfg->msec_port_enable = %x block = %d cmplx_cfg.msec_port_enable = %x\n",
-                //nae_cfg->msec_port_enable, block, cmplx_cfg.msec_port_enable);
 #ifdef MACSEC_DEBUG
                 netsoc_api_print(NETSOC_APIDBG_FDT," nae_cfg->msec_port_enable = %x block = %d cmplx_cfg.msec_port_enable = %x\n",
                 nae_cfg->msec_port_enable, block, cmplx_cfg.msec_port_enable);
@@ -1150,7 +1146,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_port->intf_fifo_size = cmplx_cfg.intf_fifo_size[offset];
                         nae_port->prsr_seq_fifo_size = cmplx_cfg.prsr_seq_fifo_size[offset];
                         nae_port->num_channels = cmplx_cfg.num_channels[offset];
-                        nae_port->rx_buf_size = cmplx_cfg.rx_buf_size[offset];  // RX buf size is per context. The value given in dts is for the interface. This should be divided by num_channels  
+                        nae_port->rx_buf_size = cmplx_cfg.rx_buf_size[offset];  // RX buf size is per context. The value given in dts is for the interface. This should be divided by num_channels
                         nae_port->ucore_mask = cmplx_cfg.ucore_mask[offset];
                         nae_port->ext_phy_addr = cmplx_cfg.ext_phy_addr[offset]; /*used for both 1G and 10G PHY*/
                         nae_port->ext_phy_bus = cmplx_cfg.ext_phy_bus[offset];
@@ -1159,13 +1155,12 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         //nae_port->msec_enable = cmplx_cfg.msec_port_enable[offset];;
                         nae_port->msec_enable = (cmplx_cfg.msec_port_enable >> offset) & 0x1;
                         //nae_port->msec_enable = 1;
-			//printk("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^nae_port->msec_enable = %d\n", nae_port->msec_enable);
- 
+
                         if (is_nlm_xlp9xx()|| is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                                 nae_port->ext_phy_bus = 0;
                         }
 			nae_port->ucore_mask &= current_netsoc->ucore_mask;
-				
+
                         nae_port->rx_slots_reqd = get_slots_required(nae_port->iftype);
                         nae_port->tx_slots_reqd = nae_port->rx_slots_reqd;
                         nae_cfg->lane_rate[nae_port->hw_port_id / XLP_ILK_MAX_LANES] = cmplx_cfg.lane_rate;
@@ -1205,7 +1200,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
 *
 * @return
 *  - none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1230,7 +1225,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
 
         if (socnet_version_v0) {
                sprintf(path_str, "/soc/nae@node-%d/poe", poe->node);
-        } 
+        }
         else {
                sprintf(path_str, "/soc/net@node-%d/poe-%d", poe->node, poe->poe_id);
         }
@@ -1289,12 +1284,12 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
                         if ((p_addr_map != NULL) && (p_addr_len != NULL)) {
                               poe->din_spill_base = fdt64_to_cpu(*p_addr_map);
                               poe->din_spill_size = fdt32_to_cpu(*p_addr_len);
-			      netsoc_api_print(NETSOC_APIDBG_FDT,"FDT din_spill_base 0x%llx din_spill_size 0x%x\n",(unsigned long long)poe->din_spill_base, poe->din_spill_size);	
+			      netsoc_api_print(NETSOC_APIDBG_FDT,"FDT din_spill_base 0x%llx din_spill_size 0x%x\n",(unsigned long long)poe->din_spill_base, poe->din_spill_size);
                         }
                         else {
 			      poe->din_spill_base = 0ULL;
-                              poe->din_spill_size = 0ULL; 
-                        } 
+                              poe->din_spill_size = 0ULL;
+                        }
 		}
 		else {
                         poe->din_spill_base = 0ULL;
@@ -1315,7 +1310,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
 			}
 
                         if (is_nlm_xlp9xx()) {
-                             sprintf(path_str, "/soc/net@node-%d/poe-%d/distribution", poe->node, poe->poe_id);      
+                             sprintf(path_str, "/soc/net@node-%d/poe-%d/distribution", poe->node, poe->poe_id);
                              nodeoffset = fdt_path_offset(fdt, path_str);
                              if (nodeoffset >= 0) {
                                  pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "default-thread-sel", &plen);
@@ -1325,7 +1320,7 @@ int fdt_parse_netsoc_poe_config(void *fdt,poe_t *poe)
                                  else {
                                       poe->default_thr_sel = 0;
                                  }
-                             }  
+                             }
                         }
                         else {
                              sprintf(path_str, "/soc/nae@node-%d/poe/distribution_vectors", poe->node);
@@ -1362,12 +1357,10 @@ int fdt_get_nae(void *fdt, nae_t *nae)
         int nodeoffset, plen;
         char path_str[50];
         uint32_t *pval;
-	
-	printk("node %d nae_id %d\n", nae->node, nae->nae_id);        
+
 	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
 
         nodeoffset = fdt_path_offset(fdt, path_str);
-	printk("nodeoffset =%d\n", nodeoffset);
         return (nodeoffset >= 0);
 }
 
@@ -1408,15 +1401,15 @@ int fdt_get_nae_ale_config(void *fdt, nae_t *nae)
               }
               else {
                       nae->ale_enable = 0;
-              }        
+              }
         }
         return 0;
 }
- 
+
 int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 {
         if (is_nlm_xlp9xx()) {
-		if(!fdt_get_nae(fdt, nae))	
+		if(!fdt_get_nae(fdt, nae))
              		return 1;
 	}
 
@@ -1425,7 +1418,7 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
         }
         else {
              nae->frequency = nlm_hal_get_fdt_freq(fdt, NLM_NAE);
-        } 
+        }
 
 	if (dom_id < 0) {
 		nae->owned = 0;
@@ -1436,7 +1429,7 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
         if (current_netsoc->hw_features & NETSOC_ALE)
             fdt_get_nae_ale_config(fdt, nae);
 
-	fdt_get_dom_nae_node_ownership(fdt, dom_id, nae);	
+	fdt_get_dom_nae_node_ownership(fdt, dom_id, nae);
 	fdt_extract_dom_nae_node_freein_fifo_info(fdt, dom_id, nae);
 
         if (is_nlm_xlp9xx())
-- 
1.7.1

