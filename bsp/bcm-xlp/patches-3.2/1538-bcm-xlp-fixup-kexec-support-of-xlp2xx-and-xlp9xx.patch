From fed3c75b0d26141d2e7f8fcd349645660509f607 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 25 Mar 2014 16:37:14 +0800
Subject: bcm-xlp: fixup kexec support of xlp2xx and xlp9xx

Based on WRLINUX 5.0

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index ee25ebb..dfdf52a 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -35,6 +35,7 @@ static inline void crash_setup_regs(struct pt_regs *newregs,
 
 #ifdef CONFIG_KEXEC
 struct kimage;
+extern struct resource kexeck_res;
 extern unsigned long kexec_args[4];
 extern int (*_machine_kexec_prepare)(struct kimage *);
 extern void (*_machine_kexec_shutdown)(void);
diff --git a/arch/mips/include/asm/netlogic/nlm_kexec.h b/arch/mips/include/asm/netlogic/nlm_kexec.h
new file mode 100644
index 0000000..4157840
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/nlm_kexec.h
@@ -0,0 +1,45 @@
+/* Copyright (c) 2011 Windriver Systems, Inc.
+ * Author: Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _NLM_KEXEC
+#define _NLM_KEXEC
+
+#ifndef NLM_HAL_LINUX_KERNEL
+#define NLM_HAL_LINUX_KERNEL
+#endif
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-extns.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+#include <asm/netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+#include <asm/setup.h>
+
+/* DTB is about 32kb */
+#define DTB_SIZE       (1 << 16)       /* 64kb */
+#define DTB_ORDER	((DTB_SIZE >> PAGE_SHIFT) - 1)
+
+#define MAX_PROP_LEN            256
+
+#define KEXEC_CMDLINE_OFFSET (DTB_SIZE - MAX_PROP_LEN - 1)
+#define kexec_cmdline_addr(base) (base + KEXEC_CMDLINE_OFFSET)
+
+#define KEXEC_BOOT_FLAG	0xebebebeb
+
+static inline bool is_kexec_boot(void)
+{
+	return fw_arg3 == KEXEC_BOOT_FLAG;
+}
+
+#endif /* _NLM_KEXEC */
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index 992e184..4365cf9 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -26,6 +26,15 @@ void (*_machine_crash_shutdown)(struct pt_regs *regs) = NULL;
 void (*relocated_kexec_smp_wait) (void *);
 atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
 #endif
+extern void nlm_smp_handle_restart(unsigned long reloc);
+
+/* Location of the reserved area for the kexec kernel */
+struct resource kexeck_res = {
+	.name  = "Kexec Kernel",
+	.start = 0,
+	.end   = 0,
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
 
 int
 machine_kexec_prepare(struct kimage *kimage)
@@ -103,6 +112,7 @@ machine_kexec(struct kimage *image)
 	/* All secondary cpus now may jump to kexec_wait cycle */
 	relocated_kexec_smp_wait = reboot_code_buffer +
 		(void *)(kexec_smp_wait - relocate_new_kernel);
+	nlm_smp_handle_restart(reboot_code_buffer);
 	smp_wmb();
 	atomic_set(&kexec_ready_to_reboot, 1);
 #endif
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 43d2d78..fa95a12 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -90,10 +90,44 @@ done:
 #else
 	sync
 #endif
+
+#ifdef CONFIG_CPU_XLP
+	bal     kexec_nlm_flush_cache
+	nop
+#endif
+
 	/* jump to kexec_start_address */
 	j		s1
 	END(relocate_new_kernel)
 
+#ifdef CONFIG_CPU_XLP
+LEAF(kexec_nlm_flush_cache)
+	/* From RMI's boot1/cache.S, but implemented with only 2 regs. */
+	/* FIXME: Obtain size and num cache lines from CP0 config1 reg.
+	 *        (Try to do the following with 2 regs in that case!)
+	 */
+	li		t9,0
+1:
+	li		t8,0x80000000
+	sll		t9,t9,5
+	add		t8,t8,t9
+	sra		t9,t9,5
+	cache		0,0(t8)
+	cache		1,0(t8)
+	addiu		t9,1
+	slti		t8,t9,1024
+	bnez		t8,1b
+	 nop
+	/* pipeline flush */
+	dla		t8, 2f
+	jr.hb 		t8
+	 nop
+	2: nop
+	jr		ra
+	 nop
+END(kexec_nlm_flush_cache)
+#endif /* CONFIG_CPU_XLP */
+
 #ifdef CONFIG_SMP
 /*
  * Other CPUs should wait until code is relocated and
@@ -131,7 +165,114 @@ LEAF(kexec_smp_wait)
 #endif
 	j		s1
 	END(kexec_smp_wait)
-#endif
+
+#ifdef CONFIG_CPU_XLP
+/* OK, RMI is interesting. The secondary CPUs do NOT start at the kernel entry,
+ * but rather are signalled to jump to an address in the second kernel, which
+ * is part of the RMI-specific init sequence called within setup_arch().
+ *
+ * The boot CPU calls a routine installed by the boot loader in boot loader
+ * memory. We have to mimic this by installing a routine in the control page.
+ * This routine will simply set a variable to 1, signalling the secondary CPUs
+ * that they can get out of their spin. The routine also installs a function
+ * pointer that tells the secondary CPUs to jump to a routine (namely
+ * prom_pre_boot_secondary_cpus()) in the second kernel.
+ *
+ * When computing addresses of relocated symbols here, we need the functions
+ * to be double-word aligned, since the pointers are 64-bit, to avoid taking
+ * non-aligned exceptions (the exception handlers are invalid at this point).
+ * The computations are done relative to the start of the functions so that
+ * the start point is aligned. We can't perform computation based on return
+ * addresses and forward symbols since the assembler might add NOPs after
+ * branches and thus throw the computation off, possibly giving a 4-byte
+ * aligned address instead of an 8-byte aligned one.
+ */
+
+LEAF(kexec_nlm_secondary_cpu_spin)
+	.align	3
+	bal	1f      /* MUST be first instruction */
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-8 /* -8 *if* bal is first instruction */
+	PTR_LA		t0,kexec_nlm_secondary_cpu_spin
+	PTR_LA		v0,kexec_secondary_cpu_spin_var
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated spin_var */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+2:
+	LONG_L		t1,(v0)
+	beq		t1,zero,2b
+	nop
+
+	/* out of the spin loop, kexec_secondary_cpu_next_kernel_entry_point
+	 * now contains the address where to jump to in the second kernel
+	 *
+	 * t0 still contains address of non-relocated
+	 * kexec_nlm_secondary_cpu_spin()
+	 */
+	PTR_LA		v0,kexec_secondary_cpu_next_kernel_entry_point
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated entry_pt */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+	PTR_L		t1,(v0)
+	bal		kexec_nlm_flush_cache
+	nop
+	jr		t1
+	nop
+END(kexec_nlm_secondary_cpu_spin)
+
+LEAF(kexec_nlm_boot_cpu_wakeup_secondary_cpus)
+	/* a0 contains the address the secondary CPUs will jump to in the
+	 * second kernel
+	 */
+	.align	3
+	move		t3,ra   /* save ra from the second kernel */
+
+	bal		1f      /* MUST be second instruction */
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-12 /* -12 *if* bal is second instruction */
+	PTR_LA		t0,kexec_nlm_boot_cpu_wakeup_secondary_cpus
+	PTR_LA		v0,kexec_secondary_cpu_next_kernel_entry_point
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated _wakeup_ */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated var addr */
+	PTR_S		a0,(v0) /* store addr in 2nd kernel where to jump */
+
+	sync
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* t0 still contains address of non-relocated
+	 * kexec_nlm_secondary_cpu_spin()
+	 */
+	PTR_LA		v0,kexec_secondary_cpu_spin_var
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated spin_var */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+	dli		t1,0x1
+	PTR_S		t1,(v0)
+
+	jr		t3
+	nop
+END(kexec_nlm_boot_cpu_wakeup_secondary_cpus)
+
+	.align	3
+kexec_secondary_cpu_spin_var:
+EXPORT(kexec_secondary_cpu_spin_var)
+	LONG	0x0
+	.size	kexec_secondary_cpu_spin_var, PTRSIZE
+
+	.align	3
+kexec_secondary_cpu_next_kernel_entry_point:
+EXPORT(kexec_secondary_cpu_next_kernel_entry_point)
+	PTR	0x0
+	.size	kexec_secondary_cpu_next_kernel_entry_point, PTRSIZE
+
+#endif /* CONFIG_CPU_XLP */
+
+#endif /* CONFIG_SMP */
 
 #ifdef __mips64
        /* all PTR's must be aligned to 8 byte in 64-bit mode */
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 20be962..6fbb88f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -621,6 +621,13 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 #endif
 #ifdef CONFIG_KEXEC
+	printk(KERN_INFO "Kexeckernel info: start = %llu end = %llu\n",
+		kexeck_res.start, kexeck_res.end);
+	if (kexeck_res.start != kexeck_res.end)
+		reserve_bootmem(kexeck_res.start,
+			kexeck_res.end - kexeck_res.start + 1,
+				BOOTMEM_DEFAULT);
+
 	if (crashk_res.start != crashk_res.end)
 		reserve_bootmem(crashk_res.start,
 				crashk_res.end - crashk_res.start + 1,
@@ -732,6 +739,10 @@ static void __init resource_init(void)
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
 		request_crashkernel(res);
+#ifdef CONFIG_KEXEC
+		if (kexeck_res.end != 0)
+			request_resource(res, &kexeck_res);
+#endif
 	}
 }
 
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index d25881b..0d98426 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -6,3 +6,6 @@ obj-y				+= io.o
 obj-y				+= clk.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_EARLY_PRINTK)	+= earlycons.o
+obj-$(CONFIG_KEXEC)		+= nlm_kexec.o
+CFLAGS_nlm_kexec.o += -Iarch/mips/netlogic/lib/netlib/include \
+	-Iarch/mips/netlogic/lib/syslib/include -DNLM_HAL_LINUX_KERNEL
diff --git a/arch/mips/netlogic/common/nlm_kexec.c b/arch/mips/netlogic/common/nlm_kexec.c
new file mode 100644
index 0000000..c25775c
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_kexec.c
@@ -0,0 +1,209 @@
+/*
+ * nlm_kexec.c, kexec support for NLM XLR832-based boards
+ *
+ * Copyright (c) 20011 Wind River Systems, Inc.
+ * Author:     Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Author:     Benjamin Walsh <benjamin.walsh@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-extns.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/ioport.h>
+
+#include <asm/netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+#include "nlm_hal_nae.h"
+
+#define WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS 10000
+
+static int nlm_kexec_prepare(struct kimage *);
+static void nlm_kexec_shutdown(void);
+static void nlm_crash_shutdown(struct pt_regs *regs);
+
+static int rebooting_cpu = -1;
+static cpumask_t cpus_in_reboot = CPU_MASK_NONE;
+
+#ifdef CONFIG_SMP
+void (*relocated_kexec_nlm_secondary_cpu_spin) (void);
+atomic_t kexec_relocate_kernel_ready = ATOMIC_INIT(0);
+extern void kexec_nlm_secondary_cpu_spin(void);
+#endif
+
+extern const unsigned char relocate_new_kernel[];
+extern const size_t relocate_new_kernel_size;
+
+extern int (*_machine_kexec_prepare) (struct kimage *);
+extern void (*_machine_kexec_shutdown) (void);
+extern void (*_machine_crash_shutdown) (struct pt_regs *regs);
+
+extern void local_flush_tlb_all(void);
+
+void nlm_kexec_init(void)
+{
+	_machine_kexec_prepare = nlm_kexec_prepare;
+	_machine_kexec_shutdown = nlm_kexec_shutdown;
+	_machine_crash_shutdown = nlm_crash_shutdown;
+
+	/* Resource need to be reserved: DTB, command line */
+	kexeck_res.start = __pa(fw_arg0);
+	kexeck_res.end = kexeck_res.start + DTB_SIZE - 1;
+}
+
+static void shutdown_secondary_cpus(void *crash)
+{
+	struct pt_regs *regs = NULL;
+	int cpu;
+
+	if ((unsigned long)crash)
+		regs = task_pt_regs(current);
+
+	local_irq_disable();
+	cpu = smp_processor_id();
+
+	if (!cpu_online(cpu))
+		return;
+
+	if (!cpu_isset(cpu, cpus_in_reboot)) {
+		if (regs)
+			crash_save_cpu(regs, cpu);
+		cpu_set(cpu, cpus_in_reboot);
+	}
+
+	while (!atomic_read(&kexec_relocate_kernel_ready))
+		cpu_relax();
+
+	local_flush_tlb_all();
+	relocated_kexec_nlm_secondary_cpu_spin();
+	/* NOTREACHED */
+}
+
+static void prepare_cpus(const unsigned long crash)
+{
+	smp_call_function(shutdown_secondary_cpus, (void *)crash, 0);
+	smp_wmb();
+	local_irq_disable();
+}
+
+static void wait_for_cpus(void)
+{
+	unsigned int msecs;
+	unsigned int ncpus = num_online_cpus();
+	unsigned int rebooting_cpus;
+
+	rebooting_cpu = smp_processor_id();
+	cpu_set(rebooting_cpu, cpus_in_reboot);
+
+	msecs = WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS;
+	while ((rebooting_cpus = cpus_weight(cpus_in_reboot)) < ncpus) {
+		if (--msecs <= 0)
+			break;
+		cpu_relax();
+		mdelay(1);
+	}
+}
+
+static int nlm_kexec_prepare(struct kimage *kimage)
+{
+	void *kexec_cmdline;
+	struct kexec_segment *s;
+	char buffer[32];
+	int len, i;
+
+	/* handle the arguments passed by kexec-tools */
+	for (i = 0; i < kimage->nr_segments; i++) {
+		s = &kimage->segment[i];
+		len = min(32, (int)s->bufsz);
+		copy_from_user((void *)buffer, s->buf, len);
+		buffer[len] = 0; /* just in case... */
+		if (strncmp(buffer, "kexec ", 6) == 0)
+			break;
+	}
+	kexec_cmdline = (void *)kexec_cmdline_addr(fw_arg0);
+	if (i != kimage->nr_segments) {
+		copy_from_user(kexec_cmdline,
+			(char *)kimage->segment[i].buf,
+			kimage->segment[i].bufsz);
+		pr_debug("%s: cmdline from kexec-tools:\n%s\n", __func__, (char *)(kexec_cmdline));
+	}
+
+	kexec_args[0] = fw_arg0;
+	kexec_args[1] = fw_arg1;
+	/* kexec_args[2] saves the wakeup callback in
+	 * nlm_patch_bootloader_wakeup_fn(), Init it to NULL here.
+	 */
+	kexec_args[2] = (unsigned long)NULL;
+	/* Use this flag to check whether boot from kexec */
+	kexec_args[3] = KEXEC_BOOT_FLAG;
+
+	return 0;
+}
+
+static void nlm_kexec_shutdown(void)
+{
+	prepare_cpus(0);
+	wait_for_cpus();
+	local_flush_tlb_all();
+}
+
+static void nlm_crash_shutdown(struct pt_regs *regs)
+{
+	crash_save_cpu(regs, smp_processor_id());
+	prepare_cpus(1);
+	wait_for_cpus();
+	local_flush_tlb_all();
+}
+
+#ifdef CONFIG_SMP
+extern void kexec_nlm_boot_cpu_wakeup_secondary_cpus(void *callback);
+
+void nlm_patch_bootloader_wakeup_fn(unsigned long reloc)
+{
+	void (*relocated_wakeup_callback)(void *);
+
+	relocated_wakeup_callback = (void *)(reloc +
+		((ulong)kexec_nlm_boot_cpu_wakeup_secondary_cpus -
+			(ulong)relocate_new_kernel));
+	/* Use fw_arg2 to save the wakeup callback */
+	kexec_args[2] = (uint64_t)relocated_wakeup_callback;
+}
+
+void nlm_smp_handle_restart(unsigned long reloc)
+{
+	/* All secondary cpus now may jump to kexec_wait cycle */
+	/* relocated_kexec_smp_wait =
+	    (void *)(reloc + (kexec_smp_wait - relocate_new_kernel)); */
+	nlm_patch_bootloader_wakeup_fn(reloc);
+	relocated_kexec_nlm_secondary_cpu_spin =
+	    (void *)(reloc + ((ulong) kexec_nlm_secondary_cpu_spin -
+			      (ulong) relocate_new_kernel));
+	smp_wmb();
+	atomic_set(&kexec_relocate_kernel_ready, 1);
+}
+
+#else
+static void nlm_smp_handle_restart(unsigned long reloc)
+{
+}
+#endif	/* CONFIG_SMP */
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 309c88e..d847ad2 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -43,6 +43,7 @@
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/mips-extns.h>
 #include <asm/netlogic/common.h>
+#include <asm/netlogic/nlm_kexec.h>
 
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/cpucontrol.h>
@@ -87,6 +88,7 @@ static void __init xlp_init_mem_from_bars(void)
 	}
 }
 
+extern void prom_pre_boot_secondary_cpus(void *);
 void __init plat_mem_setup(void)
 {
 #ifdef CONFIG_SMP
@@ -185,6 +187,9 @@ void nlm_percpu_init(int hwcpuid)
 {
 }
 
+#ifdef CONFIG_KEXEC
+extern void nlm_kexec_init(void);
+#endif
 void __init prom_init(void)
 {
 	void *reset_vec;
@@ -206,4 +211,8 @@ void __init prom_init(void)
 			(nlm_reset_entry_end - nlm_reset_entry));
 
 	set_system_type();
+
+#ifdef CONFIG_KEXEC
+	nlm_kexec_init();
+#endif
 }
-- 
1.7.1

