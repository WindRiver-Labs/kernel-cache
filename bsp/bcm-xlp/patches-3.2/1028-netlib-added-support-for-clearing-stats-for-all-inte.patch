From cc99c586836ddd51da2c122989d687409f8f1bbc Mon Sep 17 00:00:00 2001
From: Abhishek Joshi <abjoshi@broadcom.com>
Date: Fri, 17 Oct 2014 16:01:56 +0530
Subject: netlib: added support for clearing stats for all interfaces

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
index 0f6ca6f..5ae65b2 100644
--- a/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
+++ b/arch/mips/netlogic/lib/netlib/external/cortina_cs34x7/nlm_cortina_cs34x7.c
@@ -19,6 +19,7 @@
 #define XGE_MAC_STATS_DATA0     0x0728f
 #define XGE_MAC_STATS_DATA1     0x0728e
 #define XGE_MAC_STATS_DATA2     0x0728d
+#define XGE_MAC_COMMON_CONFIG	0x07270
 
 #define NLM_MAX_INTERLAKEN	2
 #define CORTINA_MAX_PORTS	4
@@ -326,6 +327,37 @@ int cortina_get_mac_stats(int node, int hwport, int port, void *devstats)
 
 	return 0;
 }
+
+int cortina_clear_stats(int node, int hwport, int port)
+{
+	int phys_port = 0;
+	int cs;
+	unsigned long long data = 0;
+
+	if (!is_ilk_card_onslot(hwport/4)) 
+		return -1;
+
+	if (hwport == XLP_ILK_PORT_0)
+		cs = XLP_ILK_PORT0_CS;
+	else if (hwport == XLP_ILK_PORT_1)
+		cs = XLP_ILK_PORT1_CS;
+	else
+		return -1;
+
+	if (port > (CORTINA_MAX_PORTS - 1))
+		return -1;
+
+	phys_port = logical_port_map[hwport/8][port];
+	data = (nlm_hal_cpld_read_16 (cs, XGE_MAC_COMMON_CONFIG + (0x1000 * phys_port)));
+	if ((data >> 5) & 0x1)
+		data = data & (~(1 << 5));
+	nlm_hal_cpld_write_16 (cs, (uint16_t)(data), XGE_MAC_COMMON_CONFIG + (0x1000 * phys_port));/*clear cntr reset bit if it was high previously*/
+	nlm_hal_cpld_write_16 (cs, (uint16_t)(data | 0x20), XGE_MAC_COMMON_CONFIG + (0x1000 * phys_port));/*set the cntr reset bit*/
+	nlm_hal_cpld_write_16 (cs, (uint16_t)(data), XGE_MAC_COMMON_CONFIG + (0x1000 * phys_port));/*reset to zero*/
+
+	return 0;
+
+}
 #endif
 
 int cortina_set_max_framesize(int hwport, int port, uint16_t framesize)
@@ -405,6 +437,7 @@ int nlm_hal_init_cs34x7(int hwport,int num_lanes, int lane_rate, int nae_id)
 
 #ifdef NLM_HAL_LINUX_KERNEL
 EXPORT_SYMBOL(cortina_get_mac_stats);
+EXPORT_SYMBOL(cortina_clear_stats);
 EXPORT_SYMBOL(cortina_set_max_framesize);
 EXPORT_SYMBOL(nlm_hal_init_cs34x7);
 EXPORT_SYMBOL(cortina_dump_mac_stats);
diff --git a/arch/mips/netlogic/lib/netlib/include/export_sym.h b/arch/mips/netlogic/lib/netlib/include/export_sym.h
index 42f23d5..da812b8 100644
--- a/arch/mips/netlogic/lib/netlib/include/export_sym.h
+++ b/arch/mips/netlogic/lib/netlib/include/export_sym.h
@@ -57,6 +57,7 @@ EXPORT_SYMBOL(get_poe);
 EXPORT_SYMBOL(get_num_poe_pernode);
 EXPORT_SYMBOL(get_netsoc_features);
 EXPORT_SYMBOL(netsoc_get_port_stats);
+EXPORT_SYMBOL(netsoc_port_stats_clear);
 EXPORT_SYMBOL(netsoc_get_frame_size);
 EXPORT_SYMBOL(netsoc_get_flowid);
 EXPORT_SYMBOL(netsoc_build_crc32_table);
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
index da1a30c..e5aa3ca 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_libiface.h
@@ -49,7 +49,6 @@ extern void (*netsoc_lib_contig_free)(void *buf);
 extern uint64_t (*netsoc_lib_virttophys)(void *);
 extern void *(*netsoc_lib_phystovirt)(uint64_t);
 
-
 enum netsoc_api_dbglevels{
 	NETSOC_APIDBG_DEFAULT = 0x1,
 	NETSOC_APIDBG_ERROR = 0x1,
@@ -420,30 +419,6 @@ static inline int netsoc_port_stats_disable(net_port_t *netport)
         return 0;
 }
 
-static inline int netsoc_port_stats_clear(net_port_t *netport)
-{
-        unsigned int netwk_inf = 0;
-        nae_t *nae = netport->nae;
-        uint64_t mac_base;
-
-        switch(netport->iftype) {
-                case SGMII_IF:
-                        mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
-                        netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
-                        netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf | (1<<15)));
-                        break;
-                case XAUI_IF:
-                case RXAUI_IF:
-                        mac_base = netsoc_get_macreg_base_for_xgmac0(nae->mac_base, netport->hw_port_id);
-                        netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
-                        netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf | (1<<16)));
-                        break;
-                default:
-                        return -1;
-        }
-        return 0;
-}
-
 static inline uint32_t netsoc_read_ucore_sprayvec(nae_t *nae, int hw_port_id)
 {
 	uint32_t vec;
@@ -555,6 +530,7 @@ extern void netsoc_modify_ucore_sram(nae_t *nae, uint32_t *data,uint32_t off, ui
 extern int netsoc_restart_ucore_using_fdt(nae_t *nae, void *fdt);
 extern int netsoc_restart_ucore(nae_t *nae, uint32_t ucore_mask, uint32_t *opcodes, uint32_t num_opcodes);
 extern void netsoc_get_port_stats(net_port_t *netport, dev_stat_t* dev_stat);
+extern int netsoc_port_stats_clear(net_port_t *netport);
 extern int netsoc_mac_disable(net_port_t *netport);
 extern int netsoc_mac_enable(net_port_t *netport);
 extern int netsoc_close_port(net_port_t *netport);
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index 8b9cf7e..b758f94 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -510,6 +510,7 @@ extern int cortina_set_max_framesize(int hwport, int port, uint16_t framesize);
 #ifdef NLM_HAL_LINUX_KERNEL
 #ifdef NLM_CORTINA_SUPPORT
 extern int cortina_get_mac_stats(int node, int hwport, int port, void *);
+extern int cortina_clear_stats(int node, int hwport, int port);
 #endif
 extern int nlm_hal_get_ilk_mac_stats(int node, int block, int port, void *);
 #endif
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 17513a5..4847d1d 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -455,6 +455,67 @@ void netsoc_get_port_stats(net_port_t *netport, dev_stat_t* dev_stat)
 	__netsoc_get_mac_statistics(netport, dev_stat);
 	return; 
 }
+
+
+int netsoc_port_stats_clear(net_port_t *netport)
+{
+	uint32_t netwk_inf = 0;
+	nae_t *nae = netport->nae;
+	uint64_t mac_base = 0;
+	unsigned long long data = 0;
+	int hwport = netport->hw_port_id;
+	int port = netport->ext_phy_addr;
+	int node = netport->nae->node;
+
+	switch(netport->iftype) {
+		case SGMII_IF:
+			mac_base = netsoc_get_macreg_base_for_gmac(nae->mac_base, netport->hw_port_id);
+			netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
+			if ((netwk_inf >> 15) & 0x1)		/*Set the SC bit to zero if it was not 0 already*/
+				netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf & (uint32_t)(~(1<<15))));
+			netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf  | (1<<15)));
+			do {
+				netwk_inf = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
+			} while (!((netwk_inf >> 15) & 0x1));	/*Wait for the bit to be set to 1*/
+			netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf & (uint32_t)(~(1<<15))));/*reset bit to zero*/
+			break;
+		case XAUI_IF:
+		case XFI_IF:
+		case RXAUI_IF:
+			mac_base = __netsoc_get_xgmac_base(netport);
+			netwk_inf  = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
+			if ((netwk_inf >> 16) & 0x1)		/*Set the SC bit to zero if it was not 0 already*/
+				netsoc_write_mac_reg(mac_base, NETWK_INF_CTRL_REG, (netwk_inf & (uint32_t)(~(1<<16))));
+				netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf | (1<<16)));
+			do {
+				netwk_inf = netsoc_read_mac_reg(mac_base, NETWK_INF_CTRL_REG);
+			} while (!((netwk_inf >> 16) & 0x1));	/*Wait for the bit to be set to 1*/
+			netsoc_write_mac_reg(mac_base , NETWK_INF_CTRL_REG, (netwk_inf & (uint32_t)(~(1<<16))));/*reset bit to zero*/
+			break;
+		case XLAUI_IF:
+			mac_base = netsoc_get_macreg_base_for_xlgmac(nae->mac_base, netport->hw_port_id);
+			netwk_inf  = __netsoc_read_xlgmac_reg(netport, XLAUI_COMMNAD_CONFIG);
+			netwk_inf = 0x220d3; // PFC disable
+			if (netport->vlan_pri_en) {
+				netwk_inf |= (1<<19); /*PFC enable*/
+			}
+			__netsoc_write_xlgmac_reg(netport , XLAUI_COMMNAD_CONFIG, (netwk_inf | (1<<12)));
+			__netsoc_write_xlgmac_reg(netport , XLAUI_COMMNAD_CONFIG, (netwk_inf & (uint32_t)(~(1<<12))));/*reset bit to zero*/
+			break;
+		case INTERLAKEN_IF:
+#ifdef NLM_HAL_LINUX_KERNEL
+			cortina_clear_stats(node, hwport, port);
+			break;
+#else
+			return 0;
+#endif
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+
 // UCORE 
 /**
 * @brief netsoc_restart_ucore function is used to load ucore code and restart ucore
-- 
1.7.1

