From e48a9c870025431b01400e804fe40d93521bdfbf Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Wed, 18 Dec 2013 13:02:32 +0530
Subject: kmod: added module to handle halx ioctls in guest

     1. added halx_netio module in kmod
     2. added iommu configuration for NAE in kvm_io_manager
     3. Modified qemu to handle exit hypercall reason
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/halx_netio/Makefile b/drivers/misc/netlogic/halx_netio/Makefile
new file mode 100644
index 0000000..9828a1e
--- /dev/null
+++ b/drivers/misc/netlogic/halx_netio/Makefile
@@ -0,0 +1,13 @@
+KERNELDIR =$(SDK_ROOT)/linux/
+HALX_DIR =$(SDK_ROOT)/halx
+HAL_NET_DIR = $(SDK_ROOT)/libraries/netlib
+
+ccflags-y += -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL \
+     -I$(SDK_ROOT)/libraries/fdt/libfdt -I$(HALX_DIR)/include -I$(HAL_NET_DIR)/include \
+     -I$(HALX_DIR)/halx-brcm/include -I$(HALX_DIR)/halx-brcm/arch/xlp
+
+KBUILD_EXTRA_SYMBOLS:= $(SDK_ROOT)/libraries/Module.symvers
+
+obj-m += halx_netio.o
+
+halx_netio-objs += halx_netio_main.o
diff --git a/drivers/misc/netlogic/halx_netio/halx_netio_iface.h b/drivers/misc/netlogic/halx_netio/halx_netio_iface.h
new file mode 100644
index 0000000..fa4fa1f
--- /dev/null
+++ b/drivers/misc/netlogic/halx_netio/halx_netio_iface.h
@@ -0,0 +1,48 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _HALX_NETIO_IFACE_H_
+#define _HALX_NETIO_IFACE_H_
+
+#define NETIF_DEV_NAME		"netif"
+#define HALX_NETIO_MAJOR	126
+/* #define HALX_NETIO_DEBUG	1 */
+
+#define NETIF_IOC       'N'
+#define HALX_CMD_REGISTER               _IOWR(NETIF_IOC, 1, unsigned long long)
+#define HALX_CMD_NET_INIT               _IOWR(NETIF_IOC, 2, unsigned long long)
+#define HALX_CMD_OPEN_PORT              _IOWR(NETIF_IOC, 3, unsigned long long)
+#define HALX_CMD_CLOSE_PORT             _IOWR(NETIF_IOC, 4, unsigned long long)
+#define HALX_CMD_CONFIG_PORT            _IOWR(NETIF_IOC, 5, unsigned long long)
+#define HALX_CMD_DEV_INFO		_IOWR(NETIF_IOC, 6, unsigned long long)
+#define HALX_CMD_PKT_ENGINE		_IOWR(NETIF_IOC, 7, unsigned long long)
+#define HALX_CMD_PKT_PARSER		_IOWR(NETIF_IOC, 8, unsigned long long)
+#define HALX_CMD_MSG_INIT		_IOWR(NETIF_IOC, 9, unsigned long long) 
+
+#endif
diff --git a/drivers/misc/netlogic/halx_netio/halx_netio_main.c b/drivers/misc/netlogic/halx_netio/halx_netio_main.c
new file mode 100644
index 0000000..2b0b837
--- /dev/null
+++ b/drivers/misc/netlogic/halx_netio/halx_netio_main.c
@@ -0,0 +1,333 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/netlogic/kvm_para.h>
+
+#include "libfdt.h"
+#include "halx_netio_iface.h"
+#include <halx.h>
+#include <halx_common.h>
+#include <halx_netcp.h>
+
+static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int rc = 0, retval = 0;
+
+	switch(cmd) {
+
+	case HALX_CMD_REGISTER:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+		halx_domain_t *ctx_dom_data = (halx_domain_t *)kmalloc(sizeof(halx_domain_t), GFP_KERNEL);
+
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
+			return -1;
+		}
+
+		retval = copy_from_user(ctx_dom_data, (halx_domain_t *)arg, sizeof(halx_domain_t));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+		printk("halx_netio: HALX_CMD_REGISTER phy_ctx_dom_data: 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_REGISTER, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to register halx\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((halx_domain_t *)arg, ctx_dom_data, sizeof(halx_domain_t));
+			if (retval) {
+				printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+			}
+		}
+		break;
+	}
+	case HALX_CMD_NET_INIT:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		halx_linux_net_arg *ctx_dom_data = (halx_linux_net_arg *)kmalloc(sizeof(halx_linux_net_arg), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (halx_linux_net_arg *)arg, sizeof(halx_linux_net_arg));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_NET_INIT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_NET_INIT, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX NET INIT\n");
+			rc = -1;
+		} else {
+                        retval = copy_to_user((halx_linux_net_arg *)arg, ctx_dom_data, sizeof(halx_linux_net_arg));
+                        if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	case HALX_CMD_OPEN_PORT:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		unsigned long *ctx_dom_data = (unsigned long *)kmalloc(2 * sizeof(unsigned long), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_OPEN_PORT\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (unsigned long *)arg, 2 * sizeof(unsigned long));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_OPEN_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_OPEN_PORT, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX OPEN PORT\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((unsigned long *)arg, ctx_dom_data, 2 * sizeof(unsigned long));
+ 			if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	case HALX_CMD_CLOSE_PORT:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		unsigned long *ctx_dom_data = (unsigned long *)kmalloc(2 * sizeof(unsigned long), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CLOSE_PORT\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (unsigned long *)arg, 2 * sizeof(unsigned long));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_CLOSE_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_CLOSE_PORT, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX CLOSE PORT\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((unsigned long *)arg, ctx_dom_data, 2 * sizeof(unsigned long));
+ 			if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	case HALX_CMD_CONFIG_PORT:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		halx_config_port_io *ctx_dom_data = (halx_config_port_io *)kmalloc(sizeof(halx_config_port_io), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CONFIG_PORT\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (halx_config_port_io *)arg, sizeof(halx_config_port_io));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_CONFIG_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_CONFIG_PORT, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX CONFIG PORT\n");
+			rc = -1;
+		}
+		break;
+	}
+	case HALX_CMD_DEV_INFO:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		halx_dev_info *ctx_dom_data = (halx_dev_info *)kmalloc(sizeof(halx_dev_info), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_DEV_INFO\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (halx_dev_info *)arg, sizeof(halx_dev_info));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_DEV_INFO phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_DEV_INFO, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX DEV INFO\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((halx_dev_info *)arg, ctx_dom_data, sizeof(halx_dev_info));
+ 			if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	case HALX_CMD_PKT_ENGINE:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		halx_arg_attr_pktengine *ctx_dom_data = (halx_arg_attr_pktengine *)kmalloc(sizeof(halx_arg_attr_pktengine), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_ENGINE\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (halx_arg_attr_pktengine *)arg, sizeof(halx_arg_attr_pktengine));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_PKT_ENGINE phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_PKT_ENGINE, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX PKT ENGINE\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((halx_arg_attr_pktengine *)arg, ctx_dom_data, sizeof(halx_arg_attr_pktengine));
+ 			if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	case HALX_CMD_PKT_PARSER:
+	{
+		uint64_t ret = 0;
+		unsigned long phy_ctx_dom_data = 0;
+
+		halx_conf_parser_t *ctx_dom_data = (halx_conf_parser_t *)kmalloc(sizeof(halx_conf_parser_t), GFP_KERNEL);
+		if (ctx_dom_data == NULL) {
+			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_PARSER\n");
+			return -1;
+		}
+		retval = copy_from_user(ctx_dom_data, (halx_conf_parser_t *)arg, sizeof(halx_conf_parser_t));
+		if (retval) {
+			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
+		}
+		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
+#ifdef HALX_NETIO_DEBUG
+                printk("halx_netio: HALX_CMD_PKT_PARSER phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
+#endif
+
+		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_PKT_PARSER, &ret)) {
+			printk(KERN_ERR "halx_netio: failure to HALX PKT PARSER:\n");
+			rc = -1;
+		} else {
+			retval = copy_to_user((halx_conf_parser_t *)arg, ctx_dom_data, sizeof(halx_conf_parser_t));
+ 			if (retval) {
+                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
+                        }
+		}
+		break;
+	}
+	default:
+		rc = -1;
+		break;
+
+	}
+	
+	return rc;
+}
+
+static const struct file_operations halx_netio_ops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = halx_netio_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = halx_netio_ioctl,
+#endif
+};
+
+static int __init brcm_halx_netio_init (void)
+{
+	int i;
+
+	i = register_chrdev(HALX_NETIO_MAJOR, NETIF_DEV_NAME, &halx_netio_ops);
+	if (i < 0)
+	{
+		printk(KERN_ERR "halx_netio: unable to register %d", HALX_NETIO_MAJOR);
+		return i;
+	}
+	printk("halx_netio: i %d\n", i);
+
+	return 0;
+}
+
+static void __exit brcm_halx_netio_exit (void)
+{
+	printk ("brcm halx_netio driver exit...\n");
+}
+
+module_init(brcm_halx_netio_init);
+module_exit(brcm_halx_netio_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("HALX NETIO Driver");
+MODULE_LICENSE("Proprietary");
+MODULE_VERSION("0.1");
diff --git a/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c b/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
index 0716db0..e2e98c0 100644
--- a/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
+++ b/drivers/misc/netlogic/soc_interface/libfdt-wrapper.c
@@ -58,7 +58,7 @@
 #define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
 #define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
 
-void *fdt;
+extern void *fdt;
 #if 0
 static void *buf; /* = NULL */
 #endif
diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index e86e7aa..87ab320 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -72,7 +72,7 @@ extern void nlm_cpu_stat_update_msgring_int(void);
 extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
 extern void nlm_cpu_stat_update_msgring_pic_int(void);
 extern void *fdt;
-EXPORT_SYMBOL(fdt);
+// EXPORT_SYMBOL(fdt);
 
 uint32_t msgring_global_thread_mask = 0;
 uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0}; 
-- 
1.7.1

