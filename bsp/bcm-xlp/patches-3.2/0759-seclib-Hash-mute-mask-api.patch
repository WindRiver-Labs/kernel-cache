From e5e627a7decfc476e1fafb7d85ab410085a7c6e8 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareeshr@broadcom.com>
Date: Wed, 17 Jul 2013 16:02:07 +0530
Subject: seclib: Hash mute mask api

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
index 417cc34..933962b 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
@@ -690,6 +690,12 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
        		SAESOC_GEN1_SET_BITS(hash_clobber, HASH_CLOBBER);	\
 	}	
 
+
+#define saesoc_gen1_get_hash_clobber( ddesc2, clob) { \
+	_uint64_t mask = SAESOC_GEN1_SET_MASK( HASH_CLOBBER ); \
+	clob = ddesc2 & mask; \
+}
+
 /* saesoc_gen1_set_hash_bitcnt - sets the hash params in ddesc2
  * @ddesc2 	: data Descriptor 2
  * @hash_bitcnt 	: This field indicates the number of valid bits in
@@ -705,24 +711,37 @@ static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_desc
 }
 
 /**
- * saesoc_gen1_set_cipher_offset_clobber - set the cipher params in ddes2
+ * saesoc_gen1_set_cipher_ivoffset - set the cipher params in ddes2
  * @ddesc2 	: data Descriptor 2
- * @cipher_offset  : Cipher Offset from start of data.
  * @cipher_iv_offset   : Offset from start of data. A value of 0 in this
  *                  field indicates an offset field of 0.
  * 
  * clears and sets the bits corresponding to cipher on data descriptor 2
  */
-#define saesoc_gen1_set_cipher_offset_clobber( ddesc2, 	\
-		cipher_offset, cipher_iv_offset) {				\
-	_uint64_t mask= SAESOC_GEN1_SET_MASK( CIPHER_OFFSET) |	\
-		SAESOC_GEN1_SET_MASK( IV_OFFSET );			\
+#define saesoc_gen1_set_cipher_ivoffset( ddesc2, 	\
+		cipher_iv_offset) {				\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( IV_OFFSET );			\
 	ddesc2 = ddesc2 & ~mask;					\
 	ddesc2 = ddesc2 |						\
-		SAESOC_GEN1_SET_BITS(cipher_offset,CIPHER_OFFSET) |	\
        		SAESOC_GEN1_SET_BITS(cipher_iv_offset, IV_OFFSET);	\
 	}	
 
+/**
+ * saesoc_gen1_set_cipher_offset - set the cipher params in ddes2
+ * @ddesc2 	: data Descriptor 2
+ * @cipher_offset  : Cipher Offset from start of data.
+ * 
+ * clears and sets the bits corresponding to cipher on data descriptor 2
+ */
+#define saesoc_gen1_set_cipher_offset( ddesc2, 	\
+		cipher_offset) {				\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( CIPHER_OFFSET) ;	\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+		SAESOC_GEN1_SET_BITS(cipher_offset,CIPHER_OFFSET) ;	\
+	}	
+
+
 
 /* saesoc_gen1_set_cipher_bitcnt - sets the cipher params in ddesc2
  * @ddesc2 	: data Descriptor 2
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
index a66a12a..7aea02e 100644
--- a/arch/mips/netlogic/lib/seclib/saesoc_lib.h
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -629,8 +629,10 @@ static inline int saesoc_new_session(
 		saesoc_gen1_set_hmac_extkeypad( spriv->ddesc[3],
 				(initp->hash.flags & SAESOC_HF_HMAC_KEY_PAD_EN)==0?1:0);
 
-		saesoc_gen1_set_cipher_offset_clobber( spriv->ddesc[2],
-				initp->payload_offset,initp->cipher.iv_offset);
+		saesoc_gen1_set_cipher_ivoffset( spriv->ddesc[2],
+				initp->cipher.iv_offset);
+		saesoc_gen1_set_cipher_offset( spriv->ddesc[2],
+				initp->payload_offset);
 
 		if( initp->cipher.type != SAESOC_CIPHER_BYPASS) {
 			saesoc_gen1_set_cipher_type_mode(sd->descs[0],
@@ -1535,9 +1537,70 @@ static inline int saesoc_set_aad_len(
 #endif
 	return -CRYPTOSOC_EINVAL;
 }
-static inline int saesoc_set_ivoffset_payload_offset(
+
+/**
+* saesoc_set_cipher_ivoffset - Set the cipher IV offset
+* @ddesc: Pointer to the data descriptor(input)
+* @iv_offset: iv offset
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_cipher_ivoffset(
+		struct saesoc_data_desc *ddesc, 
+		int iv_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_cipher_ivoffset( ddesc->descs[2],
+				iv_offset);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_payload_offset - Set the payload offset
+* @ddesc: Pointer to the data descriptor(input)
+* @payload_offset: Payload offset 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_payload_offset(
+		struct saesoc_data_desc *ddesc, 
+		int payload_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_cipher_offset( ddesc->descs[2],
+				payload_offset);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_aad_offset - Set the AAD offset
+* @ddesc: Pointer to the data descriptor(input)
+* @aad_offset: AAD offset 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_aad_offset(
 		struct saesoc_data_desc *ddesc, 
-		int iv_offset, int payload_offset)
+		int aad_offset)
 {
 	if(!ddesc)
 		return -CRYPTOSOC_EINVAL;
@@ -1545,14 +1608,19 @@ static inline int saesoc_set_ivoffset_payload_offset(
 #ifdef SAESOC_PTYPE_GEN1_SUPPORT
 	IF_SAESOC_PTYPE_IS_GEN1
 	{
-		saesoc_gen1_set_cipher_offset_clobber( ddesc->descs[2],
-				payload_offset,iv_offset);
+		_uint64_t clob = 0ULL;
+		saesoc_gen1_get_hash_clobber(ddesc->descs[2], clob);
+		saesoc_gen1_set_hash_offset_clobber(ddesc->descs[2],
+				aad_offset,
+				((clob)? 1 : 0));
 		return CRYPTOSOC_OK;
 	}
 #endif
 	return -CRYPTOSOC_EINVAL;
 }
 
+
+
 /**
 * saesoc_disable_wr_fragment - Disable engine result writing last dst fragments
 * @ddesc: Pointer to the data descriptor(input)
@@ -1650,9 +1718,15 @@ static inline int saesoc_result_valid(struct saesoc_rsp_result *res)
 * Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
 */
 
-static inline int saesoc_set_hash_mutemask(int index, unsigned int mask[8])
+static inline int saesoc_set_hash_mutemask(int index, unsigned long long mask[4])
 {
-	/* TODO */
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		/* part of sysconfig.*/
+		return -CRYPTOSOC_EINVAL;
+	}
+#endif
 	return -CRYPTOSOC_EINVAL;
 }
 
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index b80fe5b..eaae8bd 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -1240,6 +1240,23 @@ void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
 	}
 }
 
+#define NLM_SAE_HASH_MUTE_MASK_REG_0 0x28
+void nlm_hal_config_hash_mute_mask(int node, int index, unsigned long long val[4])
+{
+	int reg = NLM_SAE_HASH_MUTE_MASK_REG_0 + index * 4;
+	int i;
+
+	if (!is_nlm_xlp9xx()) 
+		return;
+
+	for(i = 0; i < 4; i++) {
+		reg += i;
+		nlm_hal_write_64bit_reg ((xlp_sae_base[node]), (reg), (val[i]));
+	}
+	nlm_print("Configured mutemask for index %d \n", index);
+	nlm_print(" %016llx %016llx %016llx %016llx\n", val[0], val[1], val[2], val[3]);
+}
+
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
@@ -1256,6 +1273,7 @@ EXPORT_SYMBOL(nlm_hal_get_crypto_vc_nums);
 EXPORT_SYMBOL(nlm_hal_set_sae_engine_sel);
 EXPORT_SYMBOL(nlm_hal_set_rsa_engine_sel);
 EXPORT_SYMBOL(nlm_hal_get_rsa_vc_nums);
+EXPORT_SYMBOL(nlm_hal_config_hash_mute_mask);
 
 EXPORT_SYMBOL(nlm_node_cfg);
 
-- 
1.7.1

