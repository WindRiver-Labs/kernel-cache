From 17711be6465e829013c6fee757de0fc9f9a80fb4 Mon Sep 17 00:00:00 2001
From: Hareesh Ramachandran <hareesh@london.(none)>
Date: Fri, 28 Oct 2011 01:45:20 -0700
Subject: nfs fix, tso_xmit_skb modified for udp packets

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.c b/drivers/misc/netlogic/nae-perf/xlp_nae.c
index dbc9e7c..973927b 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.c
@@ -502,14 +502,14 @@ static inline void create_last_p2p_desc(uint64_t *p2pmsg, struct sk_buff *skb, i
 	p2pmsg[P2P_SKB_OFF] = (uint64_t)skb;
 }
 
-uint16_t tcp_pseuodo_chksum(uint16_t *ipsrc)
+uint16_t pseuodo_chksum(uint16_t *ipsrc, uint16_t proto)
 {
 	uint32_t sum = 0;
 	sum += ipsrc[0];
 	sum += ipsrc[1];
 	sum += ipsrc[2];
 	sum += ipsrc[3];
-	sum += 6;
+	sum += proto;
 	while(sum >> 16)
 		sum = (sum & 0xffff)  + (sum >> 16);
 	//      sum = ~sum;
@@ -1412,6 +1412,8 @@ static void nlm_xlp_nae_init(void)
 				priv->phy.addr = nae_cfg.ports[i].hw_port_id;
 				break;
 			case XAUI_IF:
+				nlm_hal_write_mac_reg((nae_cfg.ports[i].hw_port_id / 4), 
+						XGMAC, XAUI_MAX_FRAME_LEN , 0x01800600);
 				priv->index = XGMAC;
 				break;
 			case INTERLAKEN_IF:
@@ -1627,13 +1629,12 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	struct dev_data *priv = netdev_priv(dev);
 	uint64_t msg, mscmsg0, mscmsg1;
 	//unsigned int mflags;
-	uint64_t *p2pdesc;
+	uint64_t *p2pdesc = NULL;
 	int cpu = hard_smp_processor_id();
 	int  ret, retry_cnt = 0;
 
 	p2pdesc = alloc_p2p_desc_mem(cpu);
 	if(p2pdesc == NULL) {
-		dev_kfree_skb_any(skb);
 		goto out_unlock;
 	}
 	tso_dbg("%s in gso_size %d nrfrags %d len %d p2pdesc %llx skb %llx headlen %d\n", __FUNCTION__,
@@ -1641,34 +1642,46 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 
 
 	if (((mss = sp->gso_size) != 0) || (skb->ip_summed == CHECKSUM_PARTIAL)) {
-		u32 iphdroff, tcphdroff, pyldoff, tcppcsum;
+		u32 iphdroff, tcphdroff, pyldoff, pcsum, tcp_packet = 1;
 
 		if (skb_header_cloned(skb) &&
 				pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
-			dev_kfree_skb_any(skb);
-			free_p2p_desc_mem(cpu, p2pdesc);
 			goto out_unlock;
 		}
-
+		
 		iph = ip_hdr(skb);
 		iphdroff = (char *)iph - (char *)skb->data;
 		tcphdroff = iphdroff + ip_hdrlen(skb);
-		pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct tcphdr) + tcp_optlen(skb);
+		if(ip_hdr(skb)->protocol == 0x6) {
+			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct tcphdr) + tcp_optlen(skb);
+			pcsum = pseuodo_chksum((uint16_t *)((char *)iph + 12), 0x6);
+			tcp_hdr(skb)->check = 0;
+		} else if(ip_hdr(skb)->protocol == 0x11) {
+			pyldoff = iphdroff + ip_hdrlen(skb) + sizeof(struct udphdr);
+			pcsum = pseuodo_chksum((uint16_t *)((char *)iph + 12), 0x11);
+			udp_hdr(skb)->check = 0;
+			tcp_packet = 0;
+		} else {
+			printk("Invalid packet in %s\n", __FUNCTION__);
+			goto out_unlock;
+		}
 
 		tso_dbg("iphdroff %d tcphdroff %d pyldoff %d\n", iphdroff, tcphdroff, pyldoff);
-		tcppcsum = tcp_pseuodo_chksum((uint16_t *)((char *)iph + 12));
-		tcp_hdr(skb)->check = 0;
 		if(mss) {
 			iph->check = 0;
 			iph->tot_len = 0;
 			mscmsg0 = nae_tso_desc0(MSC, 1, TSO_IP_TCP_CHKSUM,
 				iphdroff, tcphdroff, (iphdroff + 10),
-				tcppcsum, tcphdroff + 16, pyldoff);
+				pcsum, tcphdroff + 16, pyldoff);
 			mscmsg1 = nae_tso_desc1(MSC, 2, 0, mss, 0, 0);
-		} else {
+		} else if(tcp_packet) {
 			mscmsg0 = nae_tso_desc0(MSC, 0, TCP_CHKSUM,
 				iphdroff, tcphdroff, (iphdroff + 10),
-				tcppcsum, tcphdroff + 16, pyldoff);
+				pcsum, tcphdroff + 16, pyldoff);
+		} else {
+			mscmsg0 = nae_tso_desc0(MSC, 0, UDP_CHKSUM,
+				iphdroff, tcphdroff, (iphdroff + 10),
+				pcsum, tcphdroff + 6, pyldoff);
 		}
 
 	}
@@ -1703,8 +1716,6 @@ retry_send:
 		xlp_poll_upper(cpu);
 		retry_cnt++;
 		if(retry_cnt >= 128) {
-			dev_kfree_skb_any(skb);
-			free_p2p_desc_mem(cpu, p2pdesc);
 			goto out_unlock;
 		}
 		goto retry_send;
@@ -1715,7 +1726,11 @@ retry_send:
 	STATS_ADD(priv->stats.tx_packets, idx);
 	priv->cpu_stats[cpu].tx_packets += idx;
 
+	return NETDEV_TX_OK;
 out_unlock:
+	dev_kfree_skb_any(skb);
+	if(p2pdesc)
+		free_p2p_desc_mem(cpu, p2pdesc);
 	return NETDEV_TX_OK;
 }
 
-- 
1.7.1

