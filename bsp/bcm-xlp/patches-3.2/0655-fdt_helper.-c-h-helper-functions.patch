From 620114873bdac890652c3b1934ff87d4e6ef2e0b Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Tue, 14 Sep 2010 13:59:50 -0700
Subject: fdt_helper.{c,h}: helper functions

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/libfdt/contrib/fdt_helper.c b/libfdt/contrib/fdt_helper.c
new file mode 100644
index 0000000..6589a84
--- /dev/null
+++ b/libfdt/contrib/fdt_helper.c
@@ -0,0 +1,147 @@
+/*************************************************************************
+ Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ reserved.
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are
+ met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+ THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
+*******************************#NETL_2#**********************************/
+#if defined(__KERNEL__)
+#include <linux/kernel.h>
+
+#else
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#endif
+
+#include "libfdt.h"
+#include "fdt_helper.h"
+
+static int fdt_helper_print = 1;
+
+#if !defined(__KERNEL__)
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printf(x);    \
+} while (0)
+#else
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printk(x);    \
+} while (0)
+#endif
+
+int set_fdt_helper_print(int val)
+{
+	int old_val = fdt_helper_print;
+	fdt_helper_print = val;
+	return old_val;
+}
+
+#if !defined(__KERNEL__)
+void *open_fdt(int fd)
+{
+	struct stat st;
+	if (fstat(fd, &st) < 0) {
+		perror("fstat");
+		return NULL;
+	}
+
+	void *fdt;
+	fdt = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (fdt == MAP_FAILED) {
+		perror("mmap");
+		return NULL;
+	}
+	return fdt;
+}
+#else
+void *open_fdt(int fd) { return NULL; }
+#endif
+
+static void print_fdt_prop(const char *path, const char *prop,
+	enum prop_type type, const void *buf, int len)
+{
+	fdtprint("FDT: parsed %s.%s: ", path, prop);
+	if (type == PROP_CELL) {
+		const uint32_t *dst = (const uint32_t *)buf;
+		int cells = len / sizeof(uint32_t);
+		int i;
+
+		fdtprint("cells=%d val=", cells);
+		for (i = 0; i < cells; i++) {
+			fdtprint("0x%x(%d),", dst[i], dst[i]);
+		}
+	}
+	else {
+		fdtprint("len=%d val=%s", len, (const char *)buf);
+	}
+	fdtprint("\n");
+}
+
+int copy_fdt_prop(void *fdt, const char *path, const char *prop,
+	enum prop_type type, void *buf, int len)
+{
+	int nodeoffset;
+	const void *pval;
+	int plen;
+	int copylen;
+
+	nodeoffset = fdt_path_offset(fdt, path);
+	if (nodeoffset < 0) {
+		fdtprint("%s: Failed to parse path %s\n",
+		         fdt_strerror(nodeoffset), path);
+		return nodeoffset;
+	}
+
+	pval = fdt_getprop(fdt, nodeoffset, prop, &plen);
+	if (pval == NULL) {
+		fdtprint("%s: Failed to parse property %s\n",
+		         fdt_strerror(plen), prop);
+		return plen;
+	}
+
+	if (plen > len) {
+		fdtprint("WARNING: buf of %d is insufficient to store %d",
+		         len, plen);
+		copylen = len;
+	}
+	else {
+		copylen = plen;
+	}
+
+	if (type == PROP_CELL) {
+		const uint32_t *src = (const uint32_t *)pval;
+		uint32_t *dst = (uint32_t *)buf;
+		int i;
+		for (i = 0; i < copylen / sizeof(uint32_t); i++) {
+			dst[i] = fdt32_to_cpu(src[i]);
+		}
+	}
+	else {
+		memcpy(buf, pval, copylen);
+	}
+
+	print_fdt_prop(path, prop, type, buf, copylen);
+
+	return copylen;
+}
diff --git a/libfdt/contrib/fdt_helper.h b/libfdt/contrib/fdt_helper.h
new file mode 100644
index 0000000..fb3a556
--- /dev/null
+++ b/libfdt/contrib/fdt_helper.h
@@ -0,0 +1,86 @@
+/*************************************************************************
+ Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ reserved.
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are
+ met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+ THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
+*******************************#NETL_2#**********************************/
+#if !defined(__KERNEL__)
+#include <stdint.h>
+#endif
+
+/**
+ * open_fdt - get pointer to fdt blob for given file descriptor
+ * @fd: file descriptor for dtb
+ *
+ * returns:
+ * 	pointer to fdt blob, on success
+ * 	NULL, on error
+ */
+extern void *open_fdt(int fd);
+
+
+enum prop_type {
+	PROP_STR = 0,
+	PROP_CELL
+};
+
+/**
+ * copy_fdt_prop - copies value of given path and property
+ * @fdt: pointer to fdt blob
+ * @path: path of node to find
+ * @prop: property to find
+ * @type: type of property
+ * @buf: pointer to buffer (copy destination)
+ * @len: size of buffer (copy destination)
+ *
+ * returns:
+ * 	bytes copied to buffer, on success
+ * 	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ * 	-FDT_ERR_NOTFOUND, node does not exist or does not have named property
+ * 	-FDT_ERR_BADMAGIC,
+ * 	-FDT_ERR_BADVERSION,
+ * 	-FDT_ERR_BADSTATE,
+ * 	-FDT_ERR_BADSTRUCTURE,
+ * 	-FDT_ERR_TRUNCATED, standard meanings
+ */
+extern int copy_fdt_prop(void *fdt, const char *path, const char *prop,
+	enum prop_type type, void *buf, int len);
+
+static inline int copy_fprop_str(void *fdt,
+	const char *path, const char *prop, char *buf, int buflen) {
+	return copy_fdt_prop(fdt, path, prop, PROP_STR, (void *)buf, buflen);
+}
+
+static inline int copy_fprop_cell(void *fdt,
+	const char *path, const char *prop, uint32_t *cells, int numcells) {
+	int len = copy_fdt_prop(fdt, path, prop, PROP_CELL,
+	                        (void *)cells, numcells * sizeof(uint32_t));
+	return len / sizeof(uint32_t);
+}
+
+/**
+ * set_fdt_helper_print - switch for print output from helper functions
+ * @val: zero = off, non-zero = on
+ *
+ * returns:
+ * 	previous setting
+ */
+extern int set_fdt_helper_print(int val);
-- 
1.7.1

