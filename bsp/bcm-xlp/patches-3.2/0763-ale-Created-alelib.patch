From 33bf1bd26ee5fccee48af739825a0a3201edc42d Mon Sep 17 00:00:00 2001
From: Joa-Yu Wu <joayuwu@broadcom.com>
Date: Mon, 5 Aug 2013 16:25:10 -0700
Subject: ale: Created alelib.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/alelib/ale_api.c b/arch/mips/netlogic/lib/alelib/ale_api.c
new file mode 100644
index 0000000..6b0c972
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_api.c
@@ -0,0 +1,456 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+/**
+* @defgroup ale algorithmic Lookup Engine(ALE) API
+* @brief This section describes the ALE APIs <br>
+*
+* <b>Source:</b> libraries/alelib/ale_api.c <br>
+* 
+*/
+#include "ale_api.h"
+#include "nlm_hal_xlp_dev.h"
+#include "ale_node_db.h"
+#include "libfdt.h"
+
+
+static ale_t* xlp_ale[NLM_MAX_NODES][MAX_ALE_BLOCKS] = {{0}};
+void *(*ale_contig_alloc)(uint32_t align, uint32_t size);
+void (*ale_contig_free)(void *ptr);
+uint64_t (*ale_virt_to_phys)(void *);
+void *(*ale_phys_to_virt)(uint64_t);
+
+
+/**
+ * @brief alelib_init Create ale device instance and initalize based on fdt
+ *   Parse fdt for ale configuration and store the values in the ale_t structure.
+ *   ALE will be initialized based on the fdt configuration.
+ * @param [in] fdt fdt pointer
+ *   
+ * @return
+ *  - On success, returns 0
+ *  - On failure, returns -1
+ */
+int
+alelib_init(void *fdt,
+            ale_lib_param_t *param) {
+
+    ale_t *ale;
+    int i, j;
+
+    if (!param) {
+        ale_print(ALE_DBG_ERR, "%s: Missing alelib parameters!!!\n", __func__);
+        return -1;
+    } 
+
+    ale_contig_alloc = param->contig_alloc;
+    ale_contig_free = param->contig_free;
+    ale_virt_to_phys = param->virt_to_phys;
+    ale_phys_to_virt = param->phys_to_virt;
+    
+    for (i = 0; i < NLM_MAX_NODES; i++) {
+        j = 0;
+        for (; j < MAX_ALE_BLOCKS; j++) {
+            ale = ale_malloc(sizeof(ale_t));
+            if (ale == NULL) {
+                ale_print(ALE_DBG_ERR, "%s: Memory allocation failed\n", __func__);
+                return -1;
+            }
+
+            memset((char *)ale, 0, sizeof(ale_t));
+            ale->node_id = i;
+            ale->block_id = j;
+
+            /*
+             * Parse fdt for ale configuration and store the values in the ale_t structure.
+             * ALE will be initialized based on the fdt configuration.
+             */
+            if (fdt_parse_ale_config(fdt, ale) != 0) {
+                ale_print(ALE_DBG_ERR, "%s: parse ale fdt failed for node %d\n", __func__, ale->node_id);
+                ale_free(ale);
+                return -1;
+            }
+            xlp_ale[i][j]=ale;
+        }
+
+        ale->pcie_base = nlm_hal_get_dev_base(i, 1, XLP9XX_ALE_DEVICE, XLP9XX_ALE_FUNC);
+        dump_ale_config(ale);
+    }
+    return 0;
+}
+
+
+/**
+ * @brief alelib_deinit This function reset and frees alelib resources.
+ * @param [in] None
+ *   
+ * @return None
+ */
+void
+alelib_deinit() {
+
+    ale_t *ale;
+    int i, j;
+
+    for (i = 0; i < NLM_MAX_NODES; i++) {
+        for (j = 0; j < MAX_ALE_BLOCKS; j++) {
+            ale = xlp_ale[i][j];
+            if (!ale) {
+                ale_print(ALE_DBG_ERR, "%s: Error! alelib not initialized\n", __func__);
+            } else {
+                ale_free(ale);
+                xlp_ale[i][j] = NULL;
+            }
+        }
+    }
+
+    ale_contig_alloc = NULL;
+    ale_contig_free = NULL;
+    ale_virt_to_phys = NULL;
+    ale_phys_to_virt = NULL;
+}
+
+
+/**
+ * @brief ale_device_init This function allocates ALE node db resources and initialize
+ *                        the specified ALE block.
+ * @param [in] node_id node ID
+ * @param [in] block_id block ID
+ *   
+ * @return
+ *  - ale ale pointer
+ */
+ale_t *
+ale_device_init(int node_id,
+                int block_id) {
+
+    ale_t    *ale = xlp_ale[node_id][block_id];
+    int      i;
+
+    if (!ale) {
+        ale_print(ALE_DBG_ERR, "%s: Error! alelib not initialized\n", __func__);
+        return NULL;
+    }
+
+    if (!ale->enable) {
+        ale_print(ALE_DBG_ERR, "%s: Error! node %d ale not enabled!\n", __func__, node_id);
+        return ale;
+    }
+
+    for (i = 0; i < ALE_MAX_NODE_DB; i++) {
+        if (!(ale->node_base_addr[i] = ale_contig_alloc(CACHELINE_SIZE, ALE_NODE_DB_SIZE))) {
+            ale_print(ALE_DBG_ERR, "%s: Error! Failed to create ale node db%d!\n", __func__, i);
+            while (i-- > 0) {
+                ale_contig_free(ale->node_base_addr[i]);
+                ale->node_base_addr[i] = NULL;
+            }
+            return NULL;
+        }
+        ale->active_db = i;
+    }
+
+#ifdef ALE_DBG
+    /* read the PCIE header from the ALE pcie config space */
+    uint32_t reg_data;
+
+    ale_print(ALE_DBG_INFO, "%s: ALE PCIE header register:\n\t", __FUNCTION__);
+    for (i = 0; i < ALE_NODE_BANK_NUM; i++) {
+        reg_data = ale_read_register(ale->pcie_base, i);
+        ale_print(ALE_DBG_INFO, "%x ", reg_data);
+    }
+#define PCI_MEM_BAR_0 0x4
+    reg_data = ale_read_register(ale->pcie_base, PCI_MEM_BAR_0);
+    ale_print(ALE_DBG_INFO, "\nMEM_BAR_0: %x\n", reg_data);
+#endif
+
+    //ale_config_db_gstid(ale, 0, 0);
+    ale_config_node_base0(ale, ale_virt_to_phys(ale->node_base_addr[0]));
+    ale_config_node_base1(ale, ale_virt_to_phys(ale->node_base_addr[1]));
+    ale_config_bank_update_status(ale, ale->active_db, 0);
+
+    return ale;
+}
+
+
+/**
+ * @brief ale_device_deinit This function reset ALE hardware and frees ALE node db resouces
+ *                          for the specified ALE block.  
+ * @param [in] node_id node ID
+ * @param [in] block_id block ID
+ *  
+ * @return None
+ */
+void
+ale_device_deinit(int node_id,
+                  int block_id) {
+
+    ale_t    *ale = xlp_ale[node_id][block_id];
+    int      i;
+
+    if (!ale) {
+        ale_print(ALE_DBG_INFO, "%s: alelib not initialized\n", __func__);
+        return;
+    }
+
+    if (!ale->enable) {
+        ale_print(ALE_DBG_INFO, "%s: Node %d ale not enabled!\n", __func__, node_id);
+        return;
+    }
+
+    /* reset ALE node base addresses and update status */
+    ale_config_node_base0(ale, 0);
+    ale_config_node_base1(ale, 0);
+    ale_config_bank_update_status(ale, 0, 0);
+
+    /* release ALE node db memory */
+    for (i = 0; i < ALE_MAX_NODE_DB; i++) {
+        if (ale->node_base_addr[i]) {
+            ale_contig_free(ale->node_base_addr[i]);
+            ale->node_base_addr[i] = NULL;
+        }
+    }
+    ale->active_db = 0;
+    ale->enable = 0;
+}
+
+
+/************************************************
+  6 Banks on chip, and 12288 nodes can be stored.
+  Extra nodes will be stored in off chip memory
+
+        BANK: 0 : Nodes    0 ~ 7ff
+              1 : Nodes  800 ~ fff
+              2 : Nodes 1000 ~ 17ff
+              3 : Nodes 1800 ~ 1fff
+              4 : Nodes 2000 ~ 27ff
+              5 : Nodes 2800 ~ 2fff
+*************************************************/
+
+/**
+ * @brief ale_download_node_bank Load node database into on-chip Banks
+ * @DB Update Sequence
+ *
+ *   Set DBUPDATEINPROGRESS BIT.
+ *   Send Load DB Requests for all banks which need update.
+ *   Wait for response for each request sent out.
+ *   Configure DBACTIVE bit in BNK_UPDATE register to point to new database and Clear DBUPDATEINPROGRESS BIT.
+ *
+ * @param [in] ale ale pointer
+ * @param [in] fb_vc requester's freeback VC ID
+ * @param [in] bank_modified bitmap used to indicate which banks need to load
+ * @param [in] node_base_addr node base address
+ * @param [in] software_data software data
+ *
+ * @return
+ *  - NULL
+ */
+static int
+ale_download_node_bank(ale_t* ale,
+                       uint16_t fb_vc,
+                       uint8_t bank_modified,   //bitmap used to indicate which banks need to load
+                       uint64_t node_base_addr,
+                       uint64_t software_data
+                       ){
+
+    uint64_t load_db_req;
+    int      i, req_cnt = 0, rsp_cnt = 0;
+    uint32_t src, size, code;
+    uint64_t msg0;
+
+    /* set update in progress bit */
+    ale_config_bank_update_status(ale, ale->active_db, 1);
+    
+    /* download node DB */
+    for (i = 0; i < ALE_MAX_NODE_BANK; i++) {
+        if (bank_modified & 1) {
+            load_db_req = ale_load_db_desc0(fb_vc, i,
+                                            ((bank_modified & 0xfe) ? 0 : 1), 
+                                            (req_cnt ? 0 : 1),
+                                            node_base_addr);
+            while (nlm_hal_send_msg2(ALE_VC, 0, load_db_req, software_data) != 0);
+            req_cnt++;
+        }
+        bank_modified >>= 1;
+        node_base_addr += ALE_NODE_BANK_SIZE;
+
+        /* check for ale responses */
+        if ((rsp_cnt < req_cnt) &&
+            !nlm_hal_recv_msg1(FREEBACK_VC, &src, &size, &code, &msg0)){
+            ale_print(ALE_DBG_INFO, "%s: ld DB %d complete: received msg 0x%llx, bank = %d\n",
+                      __func__, i, (unsigned long long)msg0, (int)((msg0 >> 40) & 0x7));
+            rsp_cnt++;
+        }
+    }
+
+    /* wait for all responses back */
+    while(rsp_cnt < req_cnt){
+        if(!nlm_hal_recv_msg1(FREEBACK_VC, &src, &size, &code, &msg0)){
+            ale_print(ALE_DBG_INFO, "%s: ld DB %d complete: received msg 0x%llx, bank = %d\n",
+                      __func__, i, (unsigned long long)msg0, (int)((msg0 >> 40) & 0x7));
+            rsp_cnt++;
+        }
+    }
+
+    if (ale->active_db)
+        ale->active_db = 0;
+    else
+        ale->active_db = 1;
+ 
+    /* reset update in progress bit and configure new active_db */
+    ale_config_bank_update_status(ale, ale->active_db, 0);
+
+#ifdef ALE_DBG
+    uint64_t reg_data = 0;
+    reg_data = ale_read_register(ale->pcie_base, ALE_RX_VC0_REG);
+    ale_print(ALE_DBG_INFO, "ALE_RX_VC0_REG:%lx\n", reg_data);
+    reg_data = ale_read_register(ale->pcie_base, ALE_TX_VC0_REG);
+    ale_print(ALE_DBG_INFO, "ALE_TX_VC0_REG:%lx\n", reg_data);
+#endif
+
+    return 0;
+}
+
+
+/**
+ * @brief ale_create_db Create ale database based on given prefixes
+ *
+ * @param [in] ale ale pointer
+ * @param [in] fb_vc VC ID
+ * @param [in] prefix_table prefix table, 128 bit at most
+ * @param [in] prefix_num number of prefixes
+ *
+ * @return
+ *  - On success, returns 0
+ *  - On failure, returns -1
+ */
+int
+ale_create_db(ale_t *ale,
+              uint32_t fb_vc,
+              ale_prefix_t *prefix_table,
+              int prefix_num){
+
+    ale_db_entry_t* ale_db_hw = NULL;
+
+    if (ale)
+        ale_db_hw = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0];
+
+    ale_create_db_internal(fb_vc, prefix_table, prefix_num, ale_db_hw);
+
+   if (ale_db_hw) {
+        ale_print(ALE_DBG_INFO, "%s: ALE node base addr=%llx\n",
+                  __func__, (unsigned long long)ale_virt_to_phys(ale_db_hw));
+        ale_download_node_bank(ale, fb_vc, 0x3f, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
+    }
+    return 0;
+}
+
+
+/**
+ * @brief ale_insert_prefix Insert a single prefix into database
+ *
+ * @param [in] ale ale pointer
+ * @param [in] vc VC ID
+ * @param [in] prefix, 128 bit at most
+ * @param [in] root node of database tree
+ * @param [in] last_update if set, ALE will build and switch to a new database after this update
+ * 
+ * @return
+ *  - On success, returns 0
+ *  - On failure, returns -1
+ */
+int
+ale_insert_prefix(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update){
+   
+    if(last_update){
+        ale_db_entry_t* ale_db_hw;
+
+        ale_insert_prefix_internal(ale, vc, prefix, last_update);
+        if(ale){
+          ale_db_hw = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0]; 
+          ale_download_node_bank(ale, vc, 0x3f, ale_virt_to_phys(ale_db_hw), (uint64_t)NULL);
+        }
+        return 0;
+    }
+    else
+        return ale_insert_prefix_internal(ale, vc, prefix, last_update);
+}
+
+
+/**
+ * @brief ale_delete_prefix Delete a single prefix from database
+ *
+ * @param [in] ale ale pointer
+ * @param [in] vc VC ID
+ * @param [in] prefix 128 bit prefix at most
+ * @param [in] root node of database tree
+ * @param [in] last_update if set, ALE will build and switch to a new database after this update
+ *
+ * @return
+ *  - On success, returns 0
+ *  - On failure, returns -1
+ */
+int
+ale_delete_prefix(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update){
+
+    return ale_delete_prefix_internal(ale, vc, prefix, last_update);
+}
+
+
+/**
+ * @brief ale_get_prefix_index_from_ale_desc Get prefix index from ALE descriptor
+ *
+ * @param [in] desc ale descriptor
+ *
+ * @return
+ *  - prefix index
+ */
+uint32_t
+ale_get_prefix_index_from_ale_desc(uint64_t desc){
+
+    uint32_t   ale_index = desc & 0x7FFFFF;
+
+    return (ale_get_prefix_index(ale_index));
+}
+
+
+/**
+ * @brief ale_get_prefix_index_from_nae_desc Get prefix index from NAE descriptor
+ *
+ * @param [in] desc nae descriptor
+ *
+ * @return
+ *  - prefix index
+ */
+uint32_t
+ale_get_prefix_index_from_nae_desc(uint64_t desc){
+
+    uint32_t   ale_index = desc & 0x7FFFFF00000000;
+
+    return (ale_get_prefix_index(ale_index));
+}
diff --git a/arch/mips/netlogic/lib/alelib/ale_api.h b/arch/mips/netlogic/lib/alelib/ale_api.h
new file mode 100644
index 0000000..8b01529
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_api.h
@@ -0,0 +1,477 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+/**
+* @defgroup ale algorithmic Lookup Engine(ALE) API
+* @brief This section describes the ALE APIs supported in the HAL <br>
+*
+* <b>Source:</b> libraries/alelib/ale_api.h <br>
+* 
+*/
+
+#ifndef _ALE_API_H_
+#define _ALE_API_H_
+
+#ifdef NLM_HAL_LINUX_USER
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#else
+#include <linux/types.h>
+#include <linux/module.h>
+#endif
+#include "nlm_hal.h"
+#include "nlm_hal_fmn.h"
+#include "ale_msg.h"
+
+
+#define MAX_ALE_BLOCKS         1
+#define ALE_STRIDE             6
+#define ALE_MAX_NODE_DB        2
+#define ALE_VC                 0x2da
+#define FREEBACK_VC            3
+
+#define ALE_REQUEST_NAE        1
+#define ALE_REQUEST_CPU        2
+#define NET_UCORE_ALE_REG      0x8034
+
+#define ALE_ALGO_TYPE_LPM      0
+
+/*
+ * define contiguous memory size required for ale node db
+ */
+#define CACHELINE_SIZE          64
+#define ALE_MAX_NODE            1024*512
+#define ALE_NODE_DB_SIZE        (ALE_MAX_NODE / 2) * CACHELINE_SIZE 
+#define ALE_NODE_BANK_SIZE      1024 * CACHELINE_SIZE
+#define ALE_NODE_BANK_NUM       6
+
+#define ale_write_register(base, reg, val)   nlm_hal_write_32bit_reg((uint64_t) base, (reg), (val))
+#define ale_read_register(base, reg)         nlm_hal_read_32bit_reg((uint64_t) base, (reg))
+
+#define ALE_DBG_ALL             0
+#define ALE_DBG_INFO            1
+#define ALE_DBG_ERR             2
+
+#define ALE_DBG_LEVEL           ALE_DBG_ERR
+
+extern uint64_t (*ale_virt_to_phys)(void *);
+
+#if defined(NLM_HAL_LINUX_KERNEL)
+#define ale_malloc(size)        kmalloc(size, GFP_KERNEL)
+#define ale_calloc(n, size)     kzalloc((n) * (size), GFP_KERNEL)
+#define ale_free(ptr)           kfree(ptr)
+#define ale_print(dbg_level, fmt, args...) \
+{ \
+    if (dbg_level >= ALE_DBG_LEVEL) { \
+        printk(fmt, ##args); \
+    } \
+}
+#else
+#define ale_malloc(size)        malloc(size)
+#define ale_calloc(n, size)     calloc(n, size)
+#define ale_free(ptr)           free(ptr)
+#define ale_print(dbg_level, fmt, args...) \
+{ \
+    if (dbg_level >= ALE_DBG_LEVEL) { \
+        printf(fmt, ##args); \
+    } \
+}
+#endif
+
+typedef struct ale_lib_param_s {
+        void *(*contig_alloc)(uint32_t align, uint32_t size);
+        void (*contig_free)(void *ptr);
+        uint64_t (*virt_to_phys)(void *);
+        void *(*phys_to_virt)(uint64_t);
+} ale_lib_param_t;
+
+/*
+ *  ALE config Registers
+ */
+enum ale_cfg_regs {
+    ALE_CONTROL_REG           = 0x40,
+    ALE_BNK_UPDATE_REG        = 0x43,
+    ALE_REQ_TO_CNT_REG        = 0x45,
+    ALE_NODE_BASE0_LO_REG     = 0x54,
+    ALE_NODE_BASE0_HI_REG     = 0x55,
+    ALE_NODE_BASE1_LO_REG     = 0x56,
+    ALE_NODE_BASE1_HI_REG     = 0x57,
+    ALE_RX_VC0_REG            = 0x5D,
+    ALE_TX_VC0_REG            = 0x5F,
+    ALE_FMBBIU_RESET_REG      = 0x65,
+    ALE_LPM_BWIDTH_REG        = 0x66,
+    ALE_DB_GSTID_REG          = 0x67,
+};
+
+typedef struct{ 
+    uint32_t    node_id;
+    uint32_t    block_id;    
+    uint64_t    pcie_base;
+
+    // config parameters
+    uint32_t    enable;
+    uint32_t    cpu_threshold;
+    uint32_t    nae_threshold;
+
+    int         active_db;
+    void*       node_base_addr[ALE_MAX_NODE_DB];
+} ale_t;
+
+typedef struct{ 
+    uint32_t index;
+    uint32_t pfx_len;
+    uint32_t prefix_string[4];
+} ale_prefix_t;
+
+static uint32_t reverse_32(uint32_t x)
+{
+    x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));
+    x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));
+    x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));
+    x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));
+    return((x >> 16) | (x << 16));
+}
+
+/********************************************************
+   ALE search request APIs
+   -Send a direct LPM search request
+   -Send memory LPM search requests
+*********************************************************/
+
+/**
+ * @brief ale_direct_search_req Send a direct LPM search request
+ *        Caller has to poll for the response.
+ *
+ * @param [in] ale ale pointer
+ * @param [in] fb_vc freeback vc
+ * @param [in] algo_type ale algorithm type
+ * @param [in] str_len search string key len, from 0 to 128 bits
+ * @param [in] soft_data software data
+ * @param [in] str search string key
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline int
+ale_direct_search_req(ale_t* ale,              //ale pointer
+                      uint16_t fb_vc,          //freeback vc
+                      uint8_t algo_type,       //ale algorithm type, 0 for lpm
+                      uint8_t str_len,         //search string key len, from 0 to 128 bits
+                      uint64_t software_data,  //software data  
+                      uint32_t str[4]          //search string key
+                     ){
+    uint64_t  desc[4] = {0};
+    uint32_t* str_ptr;
+    int       i = 0;
+
+    if (str_len > 128) {
+        ale_print(ALE_DBG_ERR, "%s: Error! Unsupported search string length %d!\n", __func__, str_len);
+        return -1;
+    }
+
+    desc[i++] = ale_direct_search_desc0((software_data ? 0 : 1), fb_vc, str_len);
+
+    if (software_data)
+        desc[i++] = software_data;
+
+    /* reverse the prefix string and saved in 64-bit format */
+    str_ptr = str;
+
+    ale_print(ALE_DBG_INFO, "%s: Prefix: %x %x %x %x\n",
+              __func__, str_ptr[0], str_ptr[1], str_ptr[2], str_ptr[3]);
+    desc[i++] = (uint64_t)reverse_32(str_ptr[1]) << 32 | (uint64_t)reverse_32(str_ptr[0]); 
+    if(str_len > 64)
+        desc[i++] = (uint64_t)reverse_32(str_ptr[3]) << 32 | (uint64_t)reverse_32(str_ptr[2]); 
+
+    if (i == 2) {
+        while (nlm_hal_send_msg2(ALE_VC, 0, desc[0], desc[1]));   
+    } else if (i == 3) {
+        while (nlm_hal_send_msg3(ALE_VC, 0, desc[0], desc[1], desc[2]));   
+    } else {
+        while (nlm_hal_send_msg4(ALE_VC, 0, desc[0], desc[1], desc[2], desc[3]));   
+    }
+
+    return 0;
+}
+
+
+/**
+ * @brief ale_memory_search_req Memory LPM Requests
+ *
+ * @param [in] ale ale pointer
+ * @param [in] fb_vc freeback vc, and response will be sent to this vc
+ * @param [in] algo_type ale algorithm type, 0 for lpm
+ * @param [in] num_prefix number of lpm search key
+ * @param [in] prefix point to the search string list
+ * @param [in] req_ptr request pointer, 40-bit 
+ * @param [in] req_ptr_phys request pointer physical addr, and it must be continuous memory 
+ * @param [in] rsp_ptr_phys response pointer physical addr, and it must be continuous memory 
+ * @param [in] soft_data software data
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void *
+ale_memory_search_req(ale_t* ale,             //ale pointer
+                      uint16_t fb_vc,         //freeback vc
+                      uint8_t algo_type,      //ale algorithm type
+                      int num_prefix,         //number of lpm search key
+                      ale_prefix_t* prefix,   //point to the search string list
+                      uint64_t* req_ptr,      //request pointer
+                      uint64_t* rsp_ptr,      //response pointer
+                      uint64_t software_data  //software data  
+                     ){
+
+    uint32_t* str_ptr;
+    int       str_len, i;
+    int       req_cnt = 0, desc_cnt = 0;
+    uint64_t  desc0, desc2;
+        
+    /* fill valid lpm request into request memory */
+    for (i = 0; i < num_prefix; i++) {
+        if ((str_len = prefix->pfx_len) > 128) {
+            ale_print(ALE_DBG_ERR, "%s: Error! Prefix %d has unsupported string length %d!\n",
+                      __func__, i, str_len);
+            continue;
+        }
+        
+        *req_ptr++ = (uint64_t)str_len;       
+        desc_cnt++; 
+
+        str_ptr = prefix->prefix_string;
+
+        ale_print(ALE_DBG_INFO, "%s: Prefix[%d]: %x %x %x %x\n",
+                  __func__, i, str_ptr[0], str_ptr[1], str_ptr[2], str_ptr[3]);
+
+        *req_ptr++ = (uint64_t)reverse_32(str_ptr[1]) << 32 | (uint64_t)reverse_32(str_ptr[0]);  
+        desc_cnt++;
+        if(str_len > 64){
+            *req_ptr++ = (uint64_t)reverse_32(str_ptr[3]) << 32 | (uint64_t)reverse_32(str_ptr[2]);
+            desc_cnt++;
+        }  
+        req_cnt++;
+        prefix++;
+    }
+    
+    desc0 = ale_memory_search_desc0(1, fb_vc, desc_cnt, ale_virt_to_phys(req_ptr));
+    desc2 = ale_memory_search_desc2(req_cnt, ale_virt_to_phys(rsp_ptr)); 
+   
+    while (nlm_hal_send_msg3(ALE_VC, 0, desc0, 0, desc2)); 
+    return 0;
+}
+
+
+/**
+ * @brief ale_config_node_base0 Config off chip memory BASE ADDR 0
+ *
+ * @param [in] ale ale pointer
+ * @param [in] node_base0_addr NODE_BASE0 physical address, and it must be continuous memory 
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_node_base0(ale_t*   ale,            //ale pointer
+                                         uint64_t node_base0_addr //NODE_BASE0 address
+                                        ){      
+    ale_write_register(ale->pcie_base, ALE_NODE_BASE0_LO_REG, (uint32_t)node_base0_addr);
+    ale_write_register(ale->pcie_base, ALE_NODE_BASE0_HI_REG, (uint32_t)(node_base0_addr >> 32));    
+}
+
+
+/**
+ * @brief ale_config_node_base1 Config off chip memory BASE ADDR 1
+ *
+ * @param [in] ale ale pointer
+ * @param [in] node_base1_addr NODE_BASE1 physical address, and it must be continuous memory 
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_node_base1(ale_t*   ale,            //ale pointer
+                                                  uint64_t node_base1_addr //NODE_BASE1 address
+                                                 ){
+    ale_write_register(ale->pcie_base, ALE_NODE_BASE1_LO_REG, (uint32_t)node_base1_addr);
+    ale_write_register(ale->pcie_base, ALE_NODE_BASE1_HI_REG, (uint32_t)(node_base1_addr >> 32));  
+}
+
+
+/**
+ * @brief ale_config_control Config ALE CONTROL register, offset 0x40, reset value: 1
+ *
+ * @param [in] ale ale pointer
+ * @param [in] bsi_to_en enable BSI Req To
+ * @param [in] bnk_ecc_dis Disable ECC on Ale Banks
+ * @param [in] addrtransen Enable Addr Translation
+ * @param [in] byte_swap_dis Byte Swap Disable  
+ * @param [in] fmn_ecc_dis Disable ECC on FMB i/f  
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_control(ale_t*  ale,          //ale pointer
+                                               uint8_t bsi_to_en,    //enable BSI Req T0
+                                               uint8_t bnk_ecc_dis,  //Disable ECC on Ale Banks
+                                               uint8_t addrtransen,  //Enable Addr Translation
+                                               uint8_t byte_swap_dis,//Byte Swap Disable  
+                                               uint8_t fmn_ecc_dis   //Disable ECC on FMB i/f                    
+                                              ){
+    uint32_t control_reg = 0;
+
+    /*set CONTROL register*/
+    control_reg = bsi_to_en |
+                  bnk_ecc_dis << 1 |
+                  addrtransen << 2 |
+                  byte_swap_dis << 3 |  
+                  fmn_ecc_dis << 4; 
+    
+    ale_write_register(ale->pcie_base, ALE_CONTROL_REG, control_reg);        
+}
+
+
+/**
+ * @brief ale_config_db_gstid Config ALE DB_GSTID register, offset 0x67, reset value: 0
+ *
+ * @param [in] ale ale pointer
+ * @param [in] db0_gstid DB0 Guest ID
+ * @param [in] db1_gstid DB1 Guest ID
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_db_gstid(ale_t*  ale,        //ale pointer
+                                       uint8_t db0_gstid,  //DB0 Guest ID
+                                       uint8_t db1_gstid   //DB1 Guest ID
+                                      ){
+    uint32_t db_gstid = 0;
+    
+    db_gstid = db0_gstid |
+               db1_gstid << 8; 
+    
+    ale_write_register(ale->pcie_base, ALE_DB_GSTID_REG, db_gstid);    
+}
+
+
+/**
+ * @brief ale_config_bank_update_status Config Bank Update STatus register, offset 0x43, reset value: 0
+ *
+ * @param [in] ale ale pointer
+ * @param [in] dbactive Active DB pointer: 0 -> NODE_BASE0, 1 -> NODE_BASE1
+ * @param [in] dbupdateinprogress DB update in Progress when this bit is set by software
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_bank_update_status(ale_t*  ale,               //ale pointer
+                                                 uint8_t dbactive,          //Active DB pointer: 0 -> NODE_BASE0, 1 -> NODE_BASE1
+                                                 uint8_t dbupdateinprogress //DB update in Progress when this bit is set by software
+                                                ){
+    uint32_t bank_update_status = 0;
+    
+    bank_update_status = dbactive << 30 |
+                         dbupdateinprogress << 31; 
+    
+    ale_write_register(ale->pcie_base, ALE_BNK_UPDATE_REG, bank_update_status);  
+}
+
+
+/**
+ * @brief ale_config_fmbbiu_reset Config FMBBIU_RESET register, offset 0x65, reset value: 0
+ *
+ * @param [in] ale ale pointer
+ * @param [in] fmbbiu_reset Start Fmb Biu Reset
+ *
+ * @return
+ *  - 1 if Fmb Biu Reset is Done
+ *  - 0 if fail
+ */
+static inline int ale_config_fmbbiu_reset(ale_t* ale,          //ale pointer
+                                          uint8_t fmbbiu_reset //Start Fmb Biu Reset
+                                                  ){
+    uint32_t fmbbiu_reset_en = 0;
+    uint32_t fmbbiu_reset_done = 0;
+    int i;
+    
+    fmbbiu_reset_en = fmbbiu_reset & 1;    
+    ale_write_register(ale->pcie_base, ALE_FMBBIU_RESET_REG, fmbbiu_reset_en);
+
+    for(i = 0; i < 50; i++){
+        fmbbiu_reset_done = ale_read_register(ale->pcie_base, ALE_FMBBIU_RESET_REG);
+        if((fmbbiu_reset_done >> 1) & 1){
+            fmbbiu_reset_done = (fmbbiu_reset_done >> 1) & 1;
+        }
+    }
+    return fmbbiu_reset_done; 
+}
+
+
+/**
+ * @brief ale_config_threshold Config LPM Bwidth register
+ *
+ * @param [in] ale ale pointer
+ * @param [in] cputhreshold CPU Threshold for LPM bandwidth: default=32
+ * @param [in] naethreshold NAE Threshold for LPM bandwidth: default=80
+ *
+ * @return
+ *  - NULL
+ *
+ */
+static inline void ale_config_threshold(ale_t* ale,             //ale pointer
+                                        uint8_t cputhreshold,   //CPU Threshold for LPM bandwidth: default=32
+                                        uint8_t naethreshold    //NAE Threshold for LPM bandwidth: default=80
+                                       ){
+    uint32_t threshold = 0;
+    
+    threshold = naethreshold << 8 |
+                cputhreshold; 
+    
+    ale_write_register(ale->pcie_base, ALE_LPM_BWIDTH_REG, threshold); 
+}
+
+extern int alelib_init(void *fdt, ale_lib_param_t *param);
+extern ale_t* ale_device_init(int node_id, int block_id);
+extern int ale_create_db(ale_t *ale, uint32_t fb_vc, ale_prefix_t *prefix_table, int prefix_num);
+extern int fdt_parse_ale_config(void *fdt, ale_t *ale);
+extern void dump_ale_config(ale_t *ale);
+extern uint32_t ale_string_search(ale_prefix_t* prefix);
+extern uint32_t ale_get_prefix_index(uint32_t ale_index);
+extern uint32_t ale_get_prefix_index_from_ale_desc(uint64_t desc);
+extern uint32_t ale_get_prefix_index_from_nae_desc(uint64_t desc);
+extern int ale_insert_prefix(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update);
+extern int ale_delete_prefix(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update);
+
+#endif /* _ALE_API_H_ */
diff --git a/arch/mips/netlogic/lib/alelib/ale_fdt.c b/arch/mips/netlogic/lib/alelib/ale_fdt.c
new file mode 100644
index 0000000..6b564c5
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_fdt.c
@@ -0,0 +1,147 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include "ale_api.h"
+#include "libfdt.h"
+
+static int
+fdt_get_ale_enable(void *fdt, ale_t *ale)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint32_t *pval;
+
+        sprintf(path_str, "/soc/net@node-%d/ale-%d", ale->node_id, ale->block_id);
+
+        nodeoffset = fdt_path_offset(fdt, path_str);
+        if (nodeoffset >= 0) {
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "enable", &plen);
+                if (pval != NULL) {
+                        ale->enable = (fdt32_to_cpu(*pval) > 0) ? 1 : 0;
+                }
+                else {
+                        ale->enable = 0;
+                }
+        }
+        return 0;
+}
+
+static int
+fdt_get_ale_cpu_threshold(void *fdt, ale_t *ale)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint32_t *pval;
+
+        sprintf(path_str, "/soc/net@node-%d/ale-%d", ale->node_id, ale->block_id);
+
+        nodeoffset = fdt_path_offset(fdt, path_str);
+        if (nodeoffset >= 0) {
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "cpu-threshold", &plen);
+                if (pval != NULL) {
+                        ale->cpu_threshold = fdt32_to_cpu(*pval);
+                }
+                else {
+                        ale->cpu_threshold = 20;
+                }
+        }
+        return 0;
+}
+
+static int
+fdt_get_ale_nae_threshold(void *fdt, ale_t *ale)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint32_t *pval;
+
+        sprintf(path_str, "/soc/net@node-%d/ale-%d", ale->node_id, ale->block_id);
+
+        nodeoffset = fdt_path_offset(fdt, path_str);
+        if (nodeoffset >= 0) {
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "nae-threshold", &plen);
+                if (pval != NULL) {
+                        ale->nae_threshold = fdt32_to_cpu(*pval);
+                }
+                else {
+                        ale->nae_threshold = 80;
+                }
+        }
+        return 0;
+}
+
+#if 0
+static int
+fdt_get_ale_node_db_addr(void *fdt, ale_t *ale)
+{
+        int nodeoffset, plen;
+        char path_str[50];
+        uint64_t tmp[2];
+
+        sprintf(path_str, "/soc/net@node-%d/ale-%d", ale->node_id, ale->block_id);
+        if (copy_fdt_prop(fdt, path_str, "node-db-addr", PROP_STR, tmp, sizeof(tmp)) == sizeof(tmp)) {
+                if (tmp[0] != NULL) {
+                        ale->node_base0_addr = fdt64_to_cpu(tmp[0]);
+                }
+                else {
+                        ale->node_base0_addr = 0;
+                }
+
+                if (tmp[1] != NULL) {
+                        ale->node_base1_addr = fdt64_to_cpu(tmp[1]);
+                }
+                else {
+                        ale->node_base1_addr = 0;
+                }
+        }
+        return 0;
+}
+#endif
+
+int
+fdt_parse_ale_config(void *fdt, ale_t *ale)
+{
+        fdt_get_ale_enable(fdt, ale);
+        fdt_get_ale_cpu_threshold(fdt, ale);
+        fdt_get_ale_nae_threshold(fdt, ale);
+        //fdt_get_ale_node_db_addr(fdt, ale);
+        return 0;
+}
+
+void
+dump_ale_config(ale_t *ale)
+{
+       ale_print(ALE_DBG_INFO, " *** %s *** \n", __func__);
+       ale_print(ALE_DBG_INFO, "Ale %p node %d block %d pcie_base 0x%llx \n",
+                 ale, ale->node_id, ale->block_id, (unsigned long long)ale->pcie_base);
+       ale_print(ALE_DBG_INFO, "enable %x cpu_threshold %d nae_threshold %d \n",
+                 ale->enable, ale->cpu_threshold, ale->nae_threshold);
+       ale_print(ALE_DBG_INFO, " ******************** \n");
+}
+
diff --git a/arch/mips/netlogic/lib/alelib/ale_msg.h b/arch/mips/netlogic/lib/alelib/ale_msg.h
new file mode 100644
index 0000000..236c6ff
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_msg.h
@@ -0,0 +1,129 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef __ALE_MSG_H__
+#define __ALE_MSG_H__
+
+/* ALE message types */
+#define ALE_LOAD_DB_MSG_TYPE                 0
+#define ALE_DIRECT_SEARCH_MSG_TYPE           1
+#define ALE_MEMORY_SEARCH_MSG_TYPE           2
+
+/* ALE message common field mask defines */
+#define FIELD_MASK(size)                     ((1ULL << (size)) - 1)
+#define ALE_MSG_REQ_TYPE_MASK                FIELD_MASK(3)
+#define ALE_MSG_REQ_PTR_MASK                 FIELD_MASK(40)
+#define ALE_MSG_RSP_PTR_MASK                 FIELD_MASK(40)
+#define ALE_MSG_REQ_ID_MASK                  FIELD_MASK(13)
+
+#define ALE_MSG_REQ_TYPE_POS                 61
+
+/* ALE load db message specific defines */
+#define ALE_LOAD_DB_BANK_ID_MASK             FIELD_MASK(3)
+#define ALE_LOAD_DB_LAST_REQ_MASK            FIELD_MASK(1)
+#define ALE_LOAD_DB_FIRST_REQ_MASK           FIELD_MASK(1)
+
+#define ALE_LOAD_DB_REQ_ID_POS               47
+#define ALE_LOAD_DB_BANK_ID_POS              42
+#define ALE_LOAD_DB_LAST_REQ_POS             41
+#define ALE_LOAD_DB_FIRST_REQ_POS            40
+
+/* ALE direct search message specific defines */
+#define ALE_DIRECT_SEARCH_NO_SW_DATA_MASK    FIELD_MASK(1)
+#define ALE_DIRECT_SEARCH_STR_LEN_MASK       FIELD_MASK(8)
+
+#define ALE_DIRECT_SEARCH_NO_SW_DATA_POS     60
+#define ALE_DIRECT_SEARCH_REQ_ID_POS         47
+
+/* ALE memory search message specific defines */
+/* desc0 */
+#define ALE_MEMORY_SEARCH_CA_MASK            FIELD_MASK(1)
+#define ALE_MEMORY_SEARCH_DESC_CNT_MASK      FIELD_MASK(7)
+
+#define ALE_MEMORY_SEARCH_CA_POS             60
+#define ALE_MEMORY_SEARCH_REQ_ID_POS         47
+#define ALE_MEMORY_SEARCH_DESC_CNT_POS       40
+
+/* desc2 */
+#define ALE_MEMORY_SEARCH_REQ_CNT_MASK       FIELD_MASK(8)
+
+#define ALE_MEMORY_SEARCH_REQ_CNT_POS        40
+
+
+/*
+ * ALE message builders
+ */
+static __inline__ uint64_t
+ale_load_db_desc0(uint16_t req_id,    //requester ID
+                  uint8_t  bank,      //Bank ID, from 0 to 5
+                  uint8_t  last,      //last update request
+                  uint8_t  first,     //first update requset
+                  uint64_t req_ptr    //40-bit request pointer points to data base in memory, must be cache line aligned
+                 ){                   //request type = 0x0
+
+    return (((uint64_t)(req_id & ALE_MSG_REQ_ID_MASK) << ALE_LOAD_DB_REQ_ID_POS) |
+           ((uint64_t)(bank & ALE_LOAD_DB_BANK_ID_MASK) << ALE_LOAD_DB_BANK_ID_POS) |
+           ((uint64_t)(last & ALE_LOAD_DB_LAST_REQ_MASK) << ALE_LOAD_DB_LAST_REQ_POS) |
+           ((uint64_t)(first & ALE_LOAD_DB_FIRST_REQ_MASK) << ALE_LOAD_DB_FIRST_REQ_POS) |
+           (req_ptr & ALE_MSG_REQ_PTR_MASK));
+}
+
+static __inline__ uint64_t
+ale_direct_search_desc0(uint8_t  no_sw_data, //no software data
+                        uint16_t req_id,     //requester ID
+                        uint8_t  str_len     //search string key len, max value 128
+                      ){                     //request type = 0x1 
+    return (((uint64_t)(ALE_DIRECT_SEARCH_MSG_TYPE & ALE_MSG_REQ_TYPE_MASK) << ALE_MSG_REQ_TYPE_POS) |
+           ((uint64_t)(no_sw_data & ALE_DIRECT_SEARCH_NO_SW_DATA_MASK) << ALE_DIRECT_SEARCH_NO_SW_DATA_POS) |
+           ((uint64_t)(req_id & ALE_MSG_REQ_ID_MASK) << ALE_DIRECT_SEARCH_REQ_ID_POS) |
+           ((uint64_t)str_len & ALE_DIRECT_SEARCH_STR_LEN_MASK));
+}
+
+static __inline__ uint64_t
+ale_memory_search_desc0(uint8_t  ca,         //cache allocate on write
+                        uint16_t req_id,     //requester ID
+                        uint8_t  desc_cnt,   //descriptor count, max 128 descs, 7'd0 = 128 words
+                        uint64_t req_ptr     //request pointer, 40-bit
+                       ){                    //request type = 0x2 
+    return (((uint64_t)(ALE_MEMORY_SEARCH_MSG_TYPE & ALE_MSG_REQ_TYPE_MASK) << ALE_MSG_REQ_TYPE_POS) |
+           ((uint64_t)(ca & ALE_MEMORY_SEARCH_CA_MASK) << ALE_MEMORY_SEARCH_CA_POS) |
+           ((uint64_t)(req_id & ALE_MSG_REQ_ID_MASK) << ALE_MEMORY_SEARCH_REQ_ID_POS) |
+           ((uint64_t)(desc_cnt & ALE_MEMORY_SEARCH_DESC_CNT_MASK) << ALE_MEMORY_SEARCH_DESC_CNT_POS) |
+           (req_ptr & ALE_MSG_REQ_PTR_MASK));
+}
+
+static __inline__ uint64_t
+ale_memory_search_desc2(uint8_t  req_cnt,   //request count
+                        uint64_t rsp_ptr    //response pointer, 40-bit
+                       ){
+    return (((uint64_t)(req_cnt & ALE_MEMORY_SEARCH_REQ_CNT_MASK) << ALE_MEMORY_SEARCH_REQ_CNT_POS) |
+           (rsp_ptr & ALE_MSG_RSP_PTR_MASK));
+}
+
+#endif /* __ALE_MSG_H__ */
diff --git a/arch/mips/netlogic/lib/alelib/ale_node_db.c b/arch/mips/netlogic/lib/alelib/ale_node_db.c
new file mode 100644
index 0000000..b8685e0
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_node_db.c
@@ -0,0 +1,805 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include "ale_api.h"
+#include "ale_node_db.h"
+
+/*
+ * ale node database defines
+ */
+static ale_btree_node_t *btree = NULL;
+static ale_node_table_t *node_table = NULL;
+static ale_node_t *ale_db = NULL;
+static int *result_buf = NULL;
+static int indextable[ALE_MAX_NODE] = {0}; //Index changing table, used to get index of the node table from the binary tree node
+
+static unsigned int btree_node_cnt;
+static unsigned int node_table_idx = 0;
+static uint32_t result_idx = 1; //Start from 1, no match happens when match 0
+static uint32_t db_idx = 0;
+
+static int prefix_index;
+
+static unsigned int
+ale_create_btree(ale_btree_node_t* btree,
+                 ale_prefix_t* prefix,
+                 unsigned int prefix_cnt){
+
+    int i, j;
+    unsigned int current_node = 0;
+    unsigned int node_cnt = 1;
+
+    for(i = 0; i < prefix_cnt; i++) {        
+        for(j = 0; j < prefix[i].pfx_len; j++) {            
+            if(prefix[i].prefix_string[j/32] & (1 << (31 - j%32))){
+                if(btree[current_node].right == 0) {
+                    btree[current_node].right = node_cnt++;
+                }
+                current_node = btree[current_node].right;
+            }
+            else{
+                if(btree[current_node].left == 0){
+                    btree[current_node].left = node_cnt++;
+                }
+                current_node = btree[current_node].left;
+            }
+        }
+        btree[current_node].index = i + 1; //prefix starts from 1
+        current_node = 0;
+    }
+    prefix_index = prefix_cnt + 1;
+    return node_cnt;
+}
+
+static int
+height(ale_btree_node_t* btree,
+       unsigned int node){
+
+    if(btree[node].left == 0 && btree[node].right == 0)
+        return 0;
+    else{
+        unsigned int count1 = 1;   // Start by counting the root.
+        unsigned int count2 = 1;   // Start by counting the root.
+        if(btree[node].left != 0)
+            count1 += height(btree, btree[node].left);  // Add the number of nodes in the left subtree.
+        if(btree[node].right != 0)
+            count2 += height(btree, btree[node].right); // Add the number of nodes in the right subtree
+        if(count1 >= count2)
+            return count1;
+        else
+            return count2;
+    }
+}
+
+static int
+is_tree_balanced(ale_btree_node_t* btree,
+                 unsigned int node){
+
+    int lh = 0, rh = 0, lBal = 0, rBal = 0;
+
+    if(btree[node].left == 0 && btree[node].right == 0)
+        return 1;
+    else{
+        if(btree[node].left != 0){
+            lh = height(btree, btree[node].left);
+            lBal = is_tree_balanced(btree, btree[node].left);
+        }
+        if(btree[node].right != 0){
+            rh = height(btree, btree[node].right);
+            rBal = is_tree_balanced(btree, btree[node].right);
+        }
+        if(lBal && rBal && (lh == rh))
+            return 1;
+        else
+            return 0;
+    }
+}
+
+static int
+is_dense_subtree(ale_btree_node_t* btree,
+                 unsigned int node){
+
+    return (height(btree, node) == ALE_STRIDE && is_tree_balanced(btree, node));
+}
+
+static unsigned int
+ale_set_dense_subtree(ale_btree_node_t* btree,
+                      ale_node_table_t* node_table,
+                      unsigned int root,
+                      unsigned int node,
+                      int level,
+                      unsigned int IntVal,
+                      unsigned int Intcnode){
+    ale_print(ALE_DBG_INFO, "Level %d, root %d, node %d, IntVal %d, Intcnode %d -- \n",
+              level, root, node, IntVal, Intcnode);
+    if(btree[node].index != 0 && level < (ALE_STRIDE - 1)){
+        node_table[root].BM1[IntVal/8] |= (1<<(IntVal%8));
+        node_table[root].result_buf[IntVal] = btree[node].index;        
+    }
+
+    if(level == (ALE_STRIDE-1)){
+        node_table[root].BM2[Intcnode/8] |= (1<<(Intcnode%8));
+        node_table[root].child_buf[Intcnode] = node;
+        node_table[root].node_type = ALE_NODE_TYPE_DENSE;        
+        return 1;
+    }
+    else if(btree[node].left == 0 && btree[node].right == 0){
+
+        return 1;
+    }
+    else{
+        if(btree[node].right != 0) {
+            
+            level++;
+            Intcnode = (Intcnode<<1)+1;
+            IntVal = Intcnode + (1<<(level+1)) - 1;
+            ale_set_dense_subtree(btree, node_table, root, btree[node].right, level, IntVal, Intcnode);
+            Intcnode = (Intcnode-1)>>1;
+            level--;
+        }
+
+        if(btree[node].left != 0) {            
+            level++;
+            Intcnode = (Intcnode << 1);
+            IntVal = Intcnode + (1<<(level+1)) - 1;
+            ale_set_dense_subtree(btree, node_table, root, btree[node].left, level, IntVal, Intcnode);
+            Intcnode = Intcnode >> 1;
+            level--;
+        }
+    }
+    return 1;
+}
+
+static unsigned int
+ale_encode_dense_subtree(ale_btree_node_t* btree,
+                         ale_node_table_t* node_table,
+                         unsigned int node,
+                         int level) {
+
+    unsigned int flagL = 0, flagR = 0;
+
+    if(level % ALE_STRIDE == 0){
+        node_table[node_table_idx].node_type = ALE_NODE_TYPE_DENSE;
+        node_table[node_table_idx].btree_idx = node;
+        btree[node].node_index = node_table_idx;
+        ale_print(ALE_DBG_INFO, "Level %d, node %d, node_table_idx %d -- set node_table[%d] to dense node type\n",
+                  level, node, node_table_idx, node_table_idx);
+        ale_set_dense_subtree(btree, node_table, node_table_idx, node, -1, 0, 0);
+        node_table_idx++;
+    }
+
+    if(btree[node].left){
+        flagL = ale_encode_dense_subtree(btree, node_table, btree[node].left, level + 1);
+    }
+
+    if(btree[node].right){
+        flagR = ale_encode_dense_subtree(btree, node_table, btree[node].right, level + 1);
+    }
+    return flagL && flagR;
+}
+
+static unsigned int count_nodes(ale_btree_node_t* btree, unsigned int node){
+
+    if(btree[node].left == 0 && btree[node].right == 0){
+        return 1;  // The child tree is empty.  It contains no nodes.
+    }
+    else{
+        unsigned int count = 1;   // Start by counting the root.
+        if(btree[node].left != 0 && btree[btree[node].left].node_type == 0)
+            count += count_nodes(btree, btree[node].left);  // Add the number of nodes in the left subtree.
+        if(btree[node].right != 0 && btree[btree[node].right].node_type == 0)
+            count += count_nodes(btree, btree[node].right); // Add the number of nodes in the right subtree.
+        return count;  // Return the total.
+    }
+}
+
+static int is_sparse_subtree(ale_btree_node_t* btree, unsigned int node){
+    int max_SPARSE_node = (1 << (ALE_STRIDE-1)); //32
+    return (count_nodes(btree, node) <= max_SPARSE_node);
+}
+
+static unsigned int
+ale_set_sparse_subtree(ale_btree_node_t* btree,
+                       ale_node_table_t* node_table,
+                       unsigned int node){
+
+    Queue* NodeQ = createQueue(1 << ALE_STRIDE);
+    unsigned int ICnt,ECnt;
+    int max_SPARSE_node = (1 << (ALE_STRIDE - 1));
+    unsigned int table_idx = btree[node].node_index;
+
+    Enqueue(NodeQ, node);
+    ICnt = 0;
+    ECnt = max_SPARSE_node;
+
+    node_table[table_idx].node_type = ALE_NODE_TYPE_SPARSE;
+
+    while(NodeQ->size) {
+        unsigned int Curnode;
+
+        Curnode = front(NodeQ);
+        ale_print(ALE_DBG_INFO, "ICnt = %d, ECnt = %d, front of the queue = %d\n", ICnt, ECnt, Curnode);
+        ale_print(ALE_DBG_INFO, "left child = %d, right child = %d\n", btree[Curnode].left, btree[Curnode].right);
+        ale_print(ALE_DBG_INFO, "NodeType of left child = %02x \n", btree[btree[Curnode].left].node_type);
+        ale_print(ALE_DBG_INFO, "NodeType of right child = %02x \n", btree[btree[Curnode].right].node_type);
+        ale_print(ALE_DBG_INFO, "Index of current node = %04d \n", btree[Curnode].index);
+
+        if(btree[Curnode].left && (btree[btree[Curnode].left].node_type == 0)) {
+            ale_print(ALE_DBG_INFO, "Pushing %d\n", btree[Curnode].left);
+            Enqueue(NodeQ, btree[Curnode].left);
+
+            // SBM[(max_SPARSE_node*2)-1:0]
+            node_table[table_idx].BM1[(ICnt<<1)/8] |= (1<<((ICnt<<1)%8));
+            ale_print(ALE_DBG_INFO, "SBM: setting bit %d of BM1[%d], BM1 = %x\n",
+                      (ICnt<<1)%8, (ICnt<<1)/8, node_table[table_idx].BM1[(ICnt<<1)/8]);
+        }
+
+        if(btree[Curnode].right && (btree[btree[Curnode].right].node_type == 0)) {
+            ale_print(ALE_DBG_INFO, "Pushing %d\n", btree[Curnode].right);
+            Enqueue(NodeQ, btree[Curnode].right);
+
+            // SBM[(max_SPARSE_node*2)-1:0]
+            node_table[table_idx].BM1[(ICnt<<1)/8] |= (1<<(((ICnt<<1)+1)%8));
+            ale_print(ALE_DBG_INFO, "SBM: setting bit %d of BM1[%d], BM1 = %x\n",
+                      ((ICnt<<1)+1)%8, (ICnt<<1)/8, node_table[table_idx].BM1[(ICnt<<1)/8]);
+        }
+
+        // IBM[max_SPARSE_node-1:0]
+        if(btree[Curnode].index){
+            node_table[table_idx].BM2[ICnt/8] |= (1<<(ICnt%8));
+            node_table[table_idx].result_buf[ICnt] = btree[Curnode].index;
+            ale_print(ALE_DBG_INFO, "IBM: table_idx %d setting bit %d of BM2[%d], BM2=%x\n",
+                      table_idx, ICnt%8, ICnt/8, node_table[table_idx].BM2[ICnt/8]);
+            ale_print(ALE_DBG_INFO, "\tresult_buf[%d] = %d\n",
+                      ICnt, node_table[table_idx].result_buf[ICnt]);
+        }
+
+        // EBM[max_SPARSE_node:0]
+        if(btree[Curnode].left && (btree[btree[Curnode].left].node_type != 0)){
+            node_table[table_idx].BM2[ECnt/8] |= (1<<(ECnt%8));
+            node_table[table_idx].child_buf[ECnt-max_SPARSE_node] = btree[Curnode].left;
+            ale_print(ALE_DBG_INFO, "EBM: table_idx % d setting bit %d of BM2[%d], BM2=%x\n",
+                      table_idx, ECnt%8, ECnt/8, node_table[table_idx].BM2[ECnt/8]);
+            ale_print(ALE_DBG_INFO, "\tchild_buf[%d] = %d\n",
+                      ECnt-max_SPARSE_node, node_table[table_idx].child_buf[ECnt-max_SPARSE_node]);
+            ECnt++;
+        }
+        else if((btree[Curnode].left == 0))
+            ECnt++;
+
+        if(btree[Curnode].right && (btree[btree[Curnode].right].node_type != 0)){
+            node_table[table_idx].BM2[ECnt/8] |= (1<<(ECnt%8));
+            node_table[table_idx].child_buf[ECnt-max_SPARSE_node] = btree[Curnode].right;
+            ale_print(ALE_DBG_INFO, "EBM: table_idx %d setting bit %d of BM2[%d], BM2=%x\n",
+                      table_idx, ECnt%8, ECnt/8, node_table[table_idx].BM2[ECnt/8]);
+            ale_print(ALE_DBG_INFO, "\tchild_buf[%d] = %d\n",
+                      ECnt-max_SPARSE_node, node_table[table_idx].child_buf[ECnt-max_SPARSE_node]);
+            ECnt++;
+        }
+        else if(btree[Curnode].right == 0)
+            ECnt++;
+
+        ICnt++;
+        Dequeue(NodeQ);
+    }
+    return 1;
+}
+
+static int
+ale_encode_sparse_subtree(ale_btree_node_t* btree,
+                          ale_node_table_t* node_table,
+                          unsigned int node,
+                          unsigned int level){
+
+    Queue* treeQ = createQueue(1024*1024);
+    unsigned int Curnode;
+
+    while(btree[0].node_type == 0){        
+        Enqueue(treeQ, node);
+        while(treeQ->size){
+            Curnode = front(treeQ);
+            if(is_sparse_subtree(btree, Curnode)){
+                node_table[node_table_idx].node_type = ALE_NODE_TYPE_SPARSE;
+                btree[Curnode].node_type = ALE_NODE_TYPE_SPARSE;
+                node_table[node_table_idx].btree_idx = Curnode;
+                btree[Curnode].node_index = node_table_idx;
+                ale_set_sparse_subtree(btree, node_table, Curnode);
+                node_table_idx++;
+            }
+            else{
+                if(btree[Curnode].left && btree[btree[Curnode].left].node_type == 0)
+                    Enqueue(treeQ, btree[Curnode].left);
+                if(btree[Curnode].right && btree[btree[Curnode].right].node_type == 0)
+                    Enqueue(treeQ, btree[Curnode].right);
+            }
+            Dequeue(treeQ);
+        }
+    }
+    return 1;
+}
+
+static int
+ale_encode_node(ale_btree_node_t* btree,
+                ale_node_table_t* node_table,
+                unsigned int node,
+                unsigned int level){
+   
+    if(is_dense_subtree(btree, node)){
+        ale_print(ALE_DBG_INFO, "Build dense subtree\n");
+        ale_encode_dense_subtree(btree, node_table, node, level);
+    }
+    else{
+        ale_print(ALE_DBG_INFO, "Build sparse subtree\n");
+        ale_encode_sparse_subtree(btree, node_table, node, level);
+    }
+
+    return 1;
+}
+
+/*We use half a cache line per entry. So bits [176:0] will be node data and bits[177:255] will be unused. two entries per cache line */
+static void
+ale_create_node_db(ale_db_entry_t* ale_db_hw,
+                   ale_node_table_t* node_table,
+                   ale_node_t* ale_db,
+                   int* result_buf){
+
+    Queue* node_queue = createQueue(1024*1024);
+    int i, j, k;
+    int max_SPARSE_node = (1 << (ALE_STRIDE-1)); //32
+    int idx = 0;
+   
+    //generate index changing table
+    for(i = 0; i < node_table_idx; i++){
+        idx = node_table[i].btree_idx;
+        indextable[idx] = i;
+    }
+
+    Enqueue(node_queue, node_table_idx-1);
+
+   // ale_node_table node_table_tmp = node_table[node_table_idx-1]; //root node
+
+    i = node_table_idx-1;
+    if(node_table[0].node_type == ALE_NODE_TYPE_DENSE)
+        i = 0;
+
+    while(node_queue->size){
+
+        if(node_table[i].node_type == ALE_NODE_TYPE_DENSE){
+            ale_db[db_idx].node_type = ALE_NODE_TYPE_DENSE;
+            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
+            ale_db[db_idx].rptr = result_idx;
+
+            for(j = 0; j < max_SPARSE_node/4; j++){
+                for(k = 0; k < 8; k++){
+                    //copy result pointer and result buffer
+                    if(node_table[i].BM1[j] & (1 << k)){
+                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
+                        result_idx++;
+                    }
+                    //enqueue children
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        Enqueue(node_queue, indextable[node_table[i].child_buf[j*8 + k]]);
+                    }
+                }
+                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+        }
+
+        else if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
+            ale_db[db_idx].node_type = ALE_NODE_TYPE_SPARSE;
+            //copy SBM
+            for(j = 0; j < max_SPARSE_node/4; j++){
+                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
+            }
+
+            //copy result pointer, IBM and result buffer
+            ale_db[db_idx].rptr = result_idx;
+            for(j = 0; j < max_SPARSE_node/8; j++){
+                for(k = 0; k < 8; k++){
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
+                        result_idx++;
+                    }
+                }
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+
+            //copy and reset child pointer
+            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
+
+            //copy EBM
+            idx = 0;
+            for(j = max_SPARSE_node/8; j <= max_SPARSE_node/4; j++){
+                for(k = 0; k < 8; k++){
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        Enqueue(node_queue, indextable[node_table[i].child_buf[idx]]);
+                    }
+                    idx++;
+                }
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+        }
+
+        ale_print(ALE_DBG_INFO, "nodetype:%x, rptr=%x, cptr=%x, \n", 
+                  ale_db[db_idx].node_type, ale_db[db_idx].rptr, ale_db[db_idx].cptr);
+        ale_print(ALE_DBG_INFO, "\tBM2:%x,%x,%x,%x,%x,%x,%x,%x,%x, BM1:%x,%x,%x,%x,%x,%x,%x,%x\n",
+                  ale_db[db_idx].BM2[8], ale_db[db_idx].BM2[7], ale_db[db_idx].BM2[6],
+                  ale_db[db_idx].BM2[5], ale_db[db_idx].BM2[4], ale_db[db_idx].BM2[3],
+                  ale_db[db_idx].BM2[2], ale_db[db_idx].BM2[1], ale_db[db_idx].BM2[0],
+                  ale_db[db_idx].BM1[7], ale_db[db_idx].BM1[6], ale_db[db_idx].BM1[5],
+                  ale_db[db_idx].BM1[4], ale_db[db_idx].BM1[3], ale_db[db_idx].BM1[2],
+                  ale_db[db_idx].BM1[1], ale_db[db_idx].BM1[0]);
+
+        if (ale_db_hw) {
+            uint64_t tmp_BM1 = 0, tmp_BM2 = 0;
+            for(k = 0; k < 8; k++){
+                tmp_BM1 |= ((uint64_t)ale_db[db_idx].BM1[k] << (8*k));
+                tmp_BM2 |= ((uint64_t)ale_db[db_idx].BM2[k] << (8*k));
+            }
+
+            ale_print(ALE_DBG_INFO, "tmp_bm1:%llx, tmp_bm2:%llx\n",
+                      (unsigned long long)tmp_BM1, (unsigned long long)tmp_BM2);
+            ale_db_hw[db_idx].db[3] = ((uint64_t)tmp_BM1 << 2) |
+                                      ((uint64_t)ale_db[db_idx].node_type & 0x3);
+            ale_db_hw[db_idx].db[2] = ((uint64_t)tmp_BM2 << 2) |
+                                      ((uint64_t)tmp_BM1 >> 62);
+            ale_db_hw[db_idx].db[1] = ((uint64_t)ale_db[db_idx].rptr << 26) |
+                                      ((uint64_t)ale_db[db_idx].cptr << 3) |
+                                      (((uint64_t)ale_db[db_idx].BM2[8] & 1) << 2) |
+                                      ((uint64_t)tmp_BM2 >> 62);
+            ale_db_hw[db_idx].db[0] = 0;
+
+            ale_print(ALE_DBG_INFO, "177bit: %llx, %llx, %llx\n",
+                      (unsigned long long)ale_db_hw[db_idx].db[1],
+                      (unsigned long long)ale_db_hw[db_idx].db[2],
+                      (unsigned long long)ale_db_hw[db_idx].db[3]);
+        }
+
+        db_idx++;
+
+        Dequeue(node_queue);
+        if(node_queue->size)
+            i = front(node_queue);
+    }
+    ale_free(node_table);
+    node_table_idx = 0;
+}
+
+ale_db_entry_t* ale_db_hw_internal;
+int
+ale_create_db_internal(uint32_t fb_vc,
+                       ale_prefix_t *prefix_table,
+                       int prefix_num,
+                       ale_db_entry_t* ale_db_hw){
+
+    /* allocate and build prefix binary tree for ALE lookup verification */
+    btree = (ale_btree_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_btree_node_t));
+    if(!btree){
+        ale_print(ALE_DBG_ERR, "ale btree calloc FAILED!\n");
+    }
+    btree_node_cnt = ale_create_btree(btree, prefix_table, prefix_num);
+
+    /* allocate and build ale node table from the binary tree */
+    node_table = (ale_node_table_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_table_t));
+    if (!node_table){
+        ale_print(ALE_DBG_ERR, "ale node_table calloc FAILED!\n");
+    }
+    ale_encode_node(btree, node_table, 0, 0);
+
+    //result buffer
+    result_buf = (int*)ale_calloc(ALE_MAX_NODE, sizeof(int));
+    if (!result_buf){
+        ale_print(ALE_DBG_ERR, "ale result_buf calloc FAILED!\n");
+    }
+
+    //ALE database
+    ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
+    if (!ale_db){
+        ale_print(ALE_DBG_ERR, "ale ale_db calloc FAILED!\n");
+    }
+
+    /*
+     * Build optimized ale database and update inactive node DB.
+     * (0 -> NODE_BASE0, 1 -> NODE_BASE1)
+     */
+    ale_create_node_db(ale_db_hw, node_table, ale_db, result_buf);
+
+    result_idx = 1;
+    db_idx = 0;
+    ale_db_hw_internal = ale_db_hw;
+    return 0;
+}
+
+void ale_update_db(ale_db_entry_t* ale_db_hw,
+                   ale_node_table_t* node_table, 
+                   ale_node_t* ale_db, 
+                   int* result_buf){
+
+    Queue* node_queue = createQueue(1024*1024);
+    int i, j, k;
+    int max_SPARSE_node = (1 << (ALE_STRIDE-1)); //32
+    int idx = 0;
+   
+    //generate index changing table
+    for(i = 0; i < node_table_idx; i++){
+        idx = node_table[i].btree_idx;
+        indextable[idx] = i;
+    }
+
+    Enqueue(node_queue, node_table_idx-1);  
+
+    i = node_table_idx-1;
+    if(node_table[0].node_type == ALE_NODE_TYPE_DENSE)
+        i = 0;
+
+    while(node_queue->size){
+        if(node_table[i].node_type == ALE_NODE_TYPE_DENSE){
+            ale_db[db_idx].node_type = ALE_NODE_TYPE_DENSE;
+            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
+            ale_db[db_idx].rptr = result_idx;
+
+            for(j = 0; j < max_SPARSE_node/4; j++){
+                for(k = 0; k < 8; k++){
+                    //copy result pointer and result buffer
+                    if(node_table[i].BM1[j] & (1 << k)){
+                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
+                        result_idx++;
+                    }
+                    //enqueue children
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        Enqueue(node_queue, indextable[node_table[i].child_buf[j*8 + k]]);
+                    }
+                }
+                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+        }
+
+        else if(node_table[i].node_type == ALE_NODE_TYPE_SPARSE){
+            ale_db[db_idx].node_type = ALE_NODE_TYPE_SPARSE;
+            //copy SBM
+            for(j = 0; j < max_SPARSE_node/4; j++){
+                ale_db[db_idx].BM1[j] = node_table[i].BM1[j];
+            }
+
+            //copy result pointer, IBM and result buffer
+            ale_db[db_idx].rptr = result_idx;
+            for(j = 0; j < max_SPARSE_node/8; j++){
+                for(k = 0; k < 8; k++){
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        result_buf[result_idx] = node_table[i].result_buf[j*8 + k];
+                        result_idx++;
+                    }
+                }
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+
+            //copy and reset child pointer
+            ale_db[db_idx].cptr = db_idx + node_queue->size - 1;
+
+            //copy EBM
+            idx = 0;
+            for(j = max_SPARSE_node/8; j <= max_SPARSE_node/4; j++){
+                for(k = 0; k < 8; k++){
+                    if(node_table[i].BM2[j] & (1 << k)){
+                        Enqueue(node_queue, indextable[node_table[i].child_buf[idx]]);
+                    }
+                    idx++;
+                }
+                ale_db[db_idx].BM2[j] = node_table[i].BM2[j];
+            }
+        }
+
+        if (ale_db_hw) {
+            uint64_t tmp_BM1 = 0, tmp_BM2 = 0;
+            for(k = 0; k < 8; k++){
+                tmp_BM1 |= ((uint64_t)ale_db[db_idx].BM1[k] << (8*k));
+                tmp_BM2 |= ((uint64_t)ale_db[db_idx].BM2[k] << (8*k));
+            }
+            ale_db_hw[db_idx].db[3] = ((uint64_t)tmp_BM1 << 2) |
+                                      ((uint64_t)ale_db[db_idx].node_type & 0x3);
+            ale_db_hw[db_idx].db[2] = ((uint64_t)tmp_BM2 << 2) |
+                                      ((uint64_t)tmp_BM1 >> 62);
+            ale_db_hw[db_idx].db[1] = ((uint64_t)ale_db[db_idx].rptr << 26) |
+                                      ((uint64_t)ale_db[db_idx].cptr << 3) |
+                                      (((uint64_t)ale_db[db_idx].BM2[8] & 1) << 2) |
+                                      ((uint64_t)tmp_BM2 >> 62);
+            ale_db_hw[db_idx].db[0] = 0;
+        }
+        db_idx++;
+        Dequeue(node_queue);
+        if(node_queue->size)
+            i = front(node_queue);
+    }
+    ale_free(node_table);
+    node_table_idx = 0;
+    result_idx = 1;
+    db_idx = 0;
+}
+
+int ale_insert_prefix_internal(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update){
+
+    int i, j;
+    unsigned int current_node = 0; 
+    
+  
+    for(i=0; i < btree_node_cnt; i++){
+        btree[i].node_type = 0;
+        btree[i].node_index = 0;  
+    }
+
+    for(j = 0; j < prefix->pfx_len; j++){
+        if(prefix->prefix_string[j/32] & (1 << (31 - j%32))){
+            if(btree[current_node].right == 0){
+                btree[current_node].right = btree_node_cnt++;                      
+            }
+            current_node = btree[current_node].right;
+        }
+        else{
+            if(btree[current_node].left == 0){
+                btree[current_node].left = btree_node_cnt++;                      
+            }
+            current_node = btree[current_node].left; 
+        }
+    }
+    btree[current_node].index = prefix_index++;
+    
+    if(last_update){  
+        for(i = 0; i < ALE_MAX_NODE; i++){
+            indextable[i] = 0;
+            result_buf[i] = 0;            
+        }
+        ale_free(ale_db);
+        ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
+        if (!ale_db){
+            ale_print(ALE_DBG_ERR, "ale ale_db calloc FAILED!\n");
+        }              
+        node_table = (ale_node_table_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_table_t));
+        if (!node_table){
+            ale_print(ALE_DBG_ERR, "ale node_table calloc FAILED!\n");
+        }   
+        
+        ale_encode_node(btree, node_table, 0, 0);
+        if(ale)
+            ale_db_hw_internal = (!ale->active_db) ? ale->node_base_addr[1] : ale->node_base_addr[0];        
+        ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf); 
+    }    
+
+    return 0;
+}
+
+
+int ale_delete_prefix_internal(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update){
+
+    int i, j, total_result = 0, delete_idx = 0;
+   //int  db_found;
+    unsigned int current_node = 0;
+    unsigned int latest_node = 0;
+  
+    ale_node_table_t node_found;
+    for(i=0; i < btree_node_cnt; i++){
+        btree[i].node_type = 0;
+        btree[i].node_index = 0;  
+    }
+    //travel binary tree
+    for(i = 0; i < prefix->pfx_len; i++){
+        if(prefix->prefix_string[i/32] & (1 << (31 - i%32))){
+            if(btree[current_node].right == 0){
+                ale_print(ALE_DBG_ERR, "Can not find the prefix\n");                      
+            }
+            current_node = btree[current_node].right;
+            if(btree[current_node].node_index){
+                latest_node = current_node;                
+            }
+        }
+        else{
+            if(btree[current_node].left == 0){
+                ale_print(ALE_DBG_ERR, "Can not find the prefix\n");                      
+            }
+            current_node = btree[current_node].left;
+            if(btree[current_node].node_index){
+                latest_node = current_node;
+            }
+        }        
+    }
+    //delete from binary tree    
+    btree[current_node].index = 0;
+    
+    if(last_update){  
+        for(i = 0; i < ALE_MAX_NODE; i++){
+            indextable[i] = 0;
+            result_buf[i] = 0;            
+        }
+        ale_free(ale_db);
+        ale_db = (ale_node_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_t));
+        if (!ale_db){
+            ale_print(ALE_DBG_ERR, "ale ale_db calloc FAILED!\n");
+        }              
+        node_table = (ale_node_table_t*)ale_calloc(ALE_MAX_NODE, sizeof(ale_node_table_t));
+        if (!node_table){
+            ale_print(ALE_DBG_ERR, "ale node_table calloc FAILED!\n");
+        }        
+        ale_encode_node(btree, node_table, 0, 0);
+        ale_update_db(ale_db_hw_internal, node_table, ale_db, result_buf); 
+    }
+
+    return 0;
+
+    //found node in node table
+    node_found = node_table[btree[latest_node].node_index];
+    //delete from node table
+    for(i = 0; i < (1<<ALE_STRIDE); i++){
+        if(node_table[btree[latest_node].node_index].result_buf[i])
+            total_result++;
+        if(node_table[btree[latest_node].node_index].result_buf[i] == prefix->index){
+            delete_idx = total_result - 1;
+            if(node_found.node_type == ALE_NODE_TYPE_SPARSE)
+                node_table[btree[latest_node].node_index].BM2[i] = 0;
+            else
+                node_table[btree[latest_node].node_index].BM1[i] = 0;             
+        }
+    }
+
+    
+    for(i = 0; i < db_idx; i++){
+        if(result_buf[ale_db[i].rptr] == btree[latest_node].index){    
+            break;
+        }
+    }
+
+    //delete from result buffer
+    if(total_result > 1){
+        for(j = ale_db[i].rptr + delete_idx; j < ale_db[i].rptr + total_result - 1; j++)
+            result_buf[j] = result_buf[j + 1];
+    }
+    
+    //delete from database
+    for(j = 0; j < 1<<ALE_STRIDE; j++){
+        if(result_buf[node_found.rptr + j] == btree[latest_node].index){
+            if(ale_db[i].node_type == ALE_NODE_TYPE_DENSE)
+                ale_db[i].BM1[j/8] = ale_db[j].BM1[j/8] | (1 << j%8); 
+            else
+                ale_db[i].BM2[j/8] = ale_db[j].BM2[j/8] | (1 << j%8); 
+        }   
+    }
+    return 0;
+}
+
+unsigned int
+ale_string_search(ale_prefix_t* prefix){
+
+    return(ale_string_search_internal(prefix, ale_db));
+}
+
+uint32_t
+ale_get_prefix_index(uint32_t ale_index){
+
+    return(result_buf[ale_index]);
+}
diff --git a/arch/mips/netlogic/lib/alelib/ale_node_db.h b/arch/mips/netlogic/lib/alelib/ale_node_db.h
new file mode 100644
index 0000000..1140cb1
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_node_db.h
@@ -0,0 +1,138 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ALE_NODE_DB_H_
+#define _ALE_NODE_DB_H_
+
+#define ALE_STRIDE  6
+#define ALE_MAX_NODE_BANK 6
+
+#define ALE_NODE_TYPE_DENSE 1
+#define ALE_NODE_TYPE_SPARSE 3
+#define ALE_NODE_TYPE_HYBRID 2
+
+typedef struct{
+   uint32_t index;      //prefix index
+   uint32_t left;
+   uint32_t right;
+   uint32_t node_index; //Index of the ale_node
+   uint8_t node_type;  
+} ale_btree_node_t;
+
+typedef struct{
+    uint32_t btree_idx;                   // point to the binary tree node 
+    uint32_t child_buf[(1<<ALE_STRIDE)];  // buffer of pointer to child node
+    uint32_t result_buf[(1<<ALE_STRIDE)]; // buffer of pointer to results
+    uint32_t cptr;
+    uint32_t rptr;
+    uint8_t BM1[((1<<ALE_STRIDE)/8)];
+    uint8_t BM2[((1<<ALE_STRIDE)/8) + 1];
+    uint8_t node_type;
+} ale_node_table_t;
+
+typedef struct{
+    uint32_t cptr;
+    uint32_t rptr;
+    uint8_t BM1[((1<<ALE_STRIDE)/8)];
+    uint8_t BM2[((1<<ALE_STRIDE)/8) + 1];
+    uint8_t node_type;
+} ale_node_t;
+
+typedef struct{
+    uint64_t db[4];
+} ale_db_entry_t __attribute__((__aligned__(32)));
+
+typedef struct{
+    int capacity;  //maximum number of elements Queue can hold
+    int size;      //current size of the Queue
+    int front;     //index of first element
+    int rear;      //index of last element
+    unsigned int *elements;
+}Queue;
+
+static __inline__ Queue* createQueue(int maxElements){
+
+    Queue *Q;
+    Q = (Queue *)ale_malloc(sizeof(Queue));
+    Q->elements = (unsigned int *)ale_malloc(sizeof(int)*maxElements);
+    Q->size = 0;
+    Q->capacity = maxElements;
+    Q->front = 0;
+    Q->rear = -1;
+    return Q;
+}
+
+static __inline__ void Dequeue(Queue *Q)
+{
+    if(Q->size==0){
+        ale_print(ALE_DBG_ERR, "Dequeue: Queue is Empty\n");
+        return;
+    }
+    else{
+        Q->size--;
+        Q->front++;
+        if(Q->front==Q->capacity){
+            Q->front=0;
+        }
+    }
+    return;
+}
+
+static __inline__ unsigned int front(Queue *Q){
+
+    if(Q->size==0){
+        ale_print(ALE_DBG_ERR, "front: Queue is Empty\n");
+        return(0);
+    }
+    return Q->elements[Q->front];
+}
+
+static __inline__ void Enqueue(Queue *Q,unsigned int element)
+{
+    if(Q->size == Q->capacity){
+        ale_print(ALE_DBG_ERR, "Queue is Full\n");
+    }
+    else{
+        Q->size++;
+        Q->rear = Q->rear + 1;
+        if(Q->rear == Q->capacity){
+            Q->rear = 0;
+        }
+        Q->elements[Q->rear] = element;
+    }
+    return;
+}
+
+extern int ale_create_db_internal(uint32_t fb_vc, ale_prefix_t *prefix_table, int prefix_num, ale_db_entry_t* ale_db_hw);
+extern unsigned int ale_string_search_internal(ale_prefix_t* prefix, ale_node_t* ale_db);
+extern int ale_insert_prefix_internal(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update);
+extern int ale_delete_prefix_internal(ale_t* ale, uint16_t vc, ale_prefix_t* prefix, int last_update);
+
+#endif /* _ALE_NODE_DB_H_ */
+
diff --git a/arch/mips/netlogic/lib/alelib/ale_sw_search.c b/arch/mips/netlogic/lib/alelib/ale_sw_search.c
new file mode 100644
index 0000000..e937352
--- /dev/null
+++ b/arch/mips/netlogic/lib/alelib/ale_sw_search.c
@@ -0,0 +1,492 @@
+/*-
+ * Copyright (c) 2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include "ale_api.h"
+#include "ale_node_db.h"
+
+
+int count_ones(ale_node_t db_node, unsigned int bit, int BM){
+    int ones = 0;
+    int i;
+
+    if(BM == 1){//check BM1
+        for(i = 0; i < bit; i++){
+            if(db_node.BM1[i/8] & (1<<(i%8)))
+                ones++;
+        }    
+    }
+    else if(BM == 2){//check BM2
+        for(i = 0; i < bit; i++){
+            if(db_node.BM2[i/8] & (1<<(i%8)))
+                ones++;
+        }    
+    }
+    return ones;
+}
+
+unsigned int search_DENSE(ale_prefix_t* prefix, ale_node_t* ale_db) {
+
+    int i, length, OneCount;
+    int level = 0;
+    unsigned int ResultPtr = 0;
+    unsigned int  IntCnode = 0;
+    unsigned int  IntVal = 0;
+        
+    int node = 0; //search from Root
+    
+   // db_node = ale_db[node]; //start from root
+    length = prefix->pfx_len; 
+    
+    if(length == 0){
+        if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
+            return ale_db[node].rptr;
+
+    }
+    
+    if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
+        ResultPtr = ale_db[node].rptr;
+   
+    for(i = 0; i < length; i++){
+        level++;
+        if(prefix->prefix_string[i/32] & (1 << (31 - i%32))){//1
+            IntCnode = (IntCnode << 1) + 1; 
+            IntVal = (1<<level) - 1 + IntCnode;
+            if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
+                
+                OneCount = count_ones(ale_db[node], IntVal, 1); //check BM1             
+                ResultPtr = ale_db[node].rptr + OneCount;
+            }
+            if(level == ALE_STRIDE){
+                level = 0;
+                if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
+                    OneCount = count_ones(ale_db[node], IntCnode, 2);
+                    node = ale_db[node].cptr + OneCount;                
+                    IntCnode = 0;
+                    IntVal = 0;                    
+                    if((ale_db[node].BM1[0] & 1) == 1){                        
+                        ResultPtr = ale_db[node].rptr;
+                    }   
+                }
+            }
+        }           
+        else{//0
+            IntCnode = IntCnode << 1;    
+            IntVal = (1<<level) - 1 + IntCnode;
+            if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
+               
+                OneCount = count_ones(ale_db[node], IntVal, 1);              
+                ResultPtr = ale_db[node].rptr + OneCount;
+            }
+            if(level == ALE_STRIDE){
+                level = 0;
+                if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
+                    OneCount = count_ones(ale_db[node], IntCnode, 2);
+                    node = ale_db[node].cptr + OneCount;                  
+                    IntCnode = 0;
+                    IntVal = 0;
+                    if((ale_db[node].BM1[0] & 1) == 1){                        
+                        ResultPtr = ale_db[node].rptr;
+                    }               
+                }
+            }
+        }
+    }
+    
+    return ResultPtr;    
+}
+
+unsigned int bit_count_ones(ale_node_t db_node, unsigned int end, int BM, unsigned int start) {
+
+    unsigned int one_count = 0;
+    int i, j;
+
+    if(BM == 0){
+        for(i = start/8; i < 8; i++){// Count ones
+            if(i == start/8) 
+                j = start%8;
+            else j= 0;
+            
+            while(j<8){
+                if((i==end/8) && (j==end%8)) 
+                    break;
+                else if(db_node.BM1[i] & (1<<j)){
+                    one_count++;
+                }
+                j++;
+                if((i==end/8) && (j==end%8)) 
+                    break;
+            }
+            if((i==end/8) && (j==end%8)) 
+                break;
+        }
+    }
+    else{
+        for(i = start/8; i < 9; i++) {// Count ones
+            if(i == start/8) 
+                j = start%8;
+            else 
+                j = 0;
+            while(j < 8){
+                if((i==end/8) && (j==end%8)) 
+                    break;
+                else if(db_node.BM2[i] & (1<<j)){
+                    one_count++;
+                }
+                j++;
+                if((i==end/8) && (j==end%8)) 
+                    break;
+            }
+            if((i==end/8) && (j==end%8)) 
+                break;
+        }
+    } 
+    return one_count; 
+}
+
+unsigned int count_zero(ale_node_t db_node, unsigned int end, int BM, unsigned int start) {
+
+    unsigned int ZeroCount = 0;
+    int i, j;
+
+    if(BM == 0) {
+        for(i = start/8; i < 8; i++) {// Count 0s
+            if(i == start/8)
+                j = start%8;
+            else 
+                j = 0;
+  
+            while(j<8) {
+                if((i==end/8) && (j==end%8)) 
+                    break;
+                if(!(db_node.BM1[i] & (1<<j))) 
+                    ZeroCount++;
+                j++;
+            }
+            if((i==(end/8)) && (j==(end%8))) 
+                break;
+        }
+    }
+    else{
+        for(i = start/8; i < 9; i++) {// Count 0s
+            if(i==start/8) 
+                j=start%8;
+            else 
+                j=0;
+            while(j<8) {
+                if((i==end/8) && (j==end%8)) 
+                    break;
+                if(!(db_node.BM2[i] && (1<<j)))  
+                    ZeroCount++;
+                j++;
+            }
+            if((i==end/8) && (j==end%8))
+                break;
+        }
+    } 
+    return ZeroCount; 
+}
+
+unsigned int search_SPARSE(ale_prefix_t* prefix, ale_node_t* ale_db) {
+
+    int i, j, length, OneCount, Ibit;
+    int level = 0;
+    unsigned int TempResultPtr, ResultPtr=0;
+    int max_SPARSE_node = (1 << (ALE_STRIDE - 1));
+    int node = 0; //search from Root
+    unsigned int BitPos[2 * max_SPARSE_node];
+    unsigned int NumNodes[2 * max_SPARSE_node];
+    unsigned int SbmIdx[2 * max_SPARSE_node];
+    unsigned int EbmIdx;
+    unsigned int IbmIdx;
+   
+    
+  //  db_node = ale_db[node]; //start from root
+    length = prefix->pfx_len; 
+  
+    if(length == 0){
+        if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+            return ale_db[node].rptr;
+
+    }   
+    BitPos[0]=0;
+    NumNodes[0]=2;
+    EbmIdx=0;
+    IbmIdx=0;
+    i = 0;
+    
+    if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+        ResultPtr = ale_db[node].rptr;
+
+    for(j = 0; j < length; j++){
+      
+        level++;
+        if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
+            Ibit = 1; 
+        else
+            Ibit = 0;
+        if(i == 0){
+            SbmIdx[0] = Ibit;
+            if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
+                ResultPtr = ale_db[node].rptr;                
+            }
+        }
+        else{
+            BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
+            OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
+            NumNodes[i] = 2 * OneCount; 
+            if((SbmIdx[i-1]-1) >= BitPos[i-1])
+                OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
+            else 
+                OneCount = 0;
+            SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;           
+        }
+ 
+        IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
+        if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
+            TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//the node is one step behind           
+        }
+        if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
+            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
+                ResultPtr = TempResultPtr;
+            }
+        } 
+        else {//complete this node
+            EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
+          
+            if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node                
+                node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
+                i = -1;
+                BitPos[0]=0;
+                NumNodes[0]=2;
+                SbmIdx[0]=0;
+                EbmIdx=0;
+                IbmIdx=0;
+             // ale_print(ALE_DBG_INFO, "find a next node:%d\n", node);                
+            } 
+            else{//can not find next node, finish searching            
+                break;
+            }
+        } 
+        i++;      
+    }         
+    return ResultPtr;
+}
+
+unsigned int ale_string_search_internal(ale_prefix_t* prefix, ale_node_t* ale_db) {
+
+    int i, j, length, OneCount, Ibit;
+    int level = 0;
+    unsigned int TempResultPtr, ResultPtr=0;
+    unsigned int  IntCnode = 0;
+    unsigned int  IntVal = 0;    
+    int max_SPARSE_node = (1 << (ALE_STRIDE - 1));
+    int node = 0; //search from Root
+    unsigned int BitPos[2 * max_SPARSE_node];
+    unsigned int NumNodes[2 * max_SPARSE_node];
+    unsigned int SbmIdx[2 * max_SPARSE_node];
+    unsigned int EbmIdx;
+    unsigned int IbmIdx;
+    int newbit;
+   
+    length = prefix->pfx_len; 
+
+    if(ale_db[node].node_type == ALE_NODE_TYPE_DENSE){
+        if(length == 0){
+            if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
+                return ale_db[node].rptr;
+        }
+    
+        if(ale_db[node].BM1[0] & 1) // Check a bit in IBM
+            ResultPtr = ale_db[node].rptr;
+   
+        for(i = 0; i < length; i++){
+            level++;
+            if(prefix->prefix_string[i/32] & (1 << (31 - i%32))){//1
+                IntCnode = (IntCnode << 1) + 1; 
+                IntVal = (1<<level) - 1 + IntCnode;
+                if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
+                    OneCount = count_ones(ale_db[node], IntVal, 1); //check BM1
+                    ResultPtr = ale_db[node].rptr + OneCount;
+                }
+                if(level == ALE_STRIDE){
+                    level = 0;
+                    if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
+                        OneCount = count_ones(ale_db[node], IntCnode, 2);
+                        node = ale_db[node].cptr + OneCount;                              
+                        break;
+                    }
+                }
+            }           
+            else{//0
+                IntCnode = IntCnode << 1;    
+                IntVal = (1<<level) - 1 + IntCnode;
+                if(ale_db[node].BM1[IntVal/8] & (1<<(IntVal%8))){
+                    OneCount = count_ones(ale_db[node], IntVal, 1);
+                    ResultPtr = ale_db[node].rptr + OneCount;
+                }
+                if(level == ALE_STRIDE){
+                    level = 0;
+                    if((ale_db[node].BM2[IntCnode/8] & (1<<(IntCnode%8)))){
+                        OneCount = count_ones(ale_db[node], IntCnode, 2);
+                        node = ale_db[node].cptr + OneCount;     
+                        break;              
+                    }
+                }
+            }
+        }
+
+        newbit = i + 1;
+        BitPos[0]=0;
+        NumNodes[0]=2;
+        EbmIdx=0;
+        IbmIdx=0;
+        i = 0;
+    
+        if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+            ResultPtr = ale_db[node].rptr;
+
+        for(j = newbit; j < length; j++){        
+            level++;
+            if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
+                Ibit = 1; 
+            else
+                Ibit = 0;
+            if(i == 0){
+                SbmIdx[0] = Ibit;
+                if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
+                    ResultPtr = ale_db[node].rptr;                
+                }
+            }
+            else{
+                BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
+                OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
+                NumNodes[i] = 2 * OneCount; 
+                if((SbmIdx[i-1]-1) >= BitPos[i-1])
+                    OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
+                else 
+                    OneCount = 0;
+                SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;                
+            }
+ 
+            IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
+            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
+                TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//why use temp, the node is one step behind               
+            }
+            if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
+                if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
+                    ResultPtr = TempResultPtr;
+                }
+            } 
+            else {//complete this node
+                EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
+                if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node
+                    node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
+                    i = -1;
+                    BitPos[0]=0;
+                    NumNodes[0]=2;
+                    SbmIdx[0]=0;
+                    EbmIdx=0;
+                    IbmIdx=0;
+                } 
+                else{//can not find next node, finish searching
+                    break;
+                }
+            } 
+            i++;      
+        }         
+        return ResultPtr;
+    }//DENSE
+    else{//SPARSE
+        if(length == 0){
+            if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+                return ale_db[node].rptr;
+        }   
+        BitPos[0]=0;
+        NumNodes[0]=2;
+        EbmIdx=0;
+        IbmIdx=0;
+        i = 0;
+    
+        if(ale_db[node].BM2[0] & 1) //Check a bit in IBM
+            ResultPtr = ale_db[node].rptr;
+        
+        for(j = 0; j < length; j++){        
+            level++;            
+            if(prefix->prefix_string[j/32] & (1 << (31 - j%32)))//1
+                Ibit = 1; 
+            else
+                Ibit = 0;
+            if(i == 0){
+                SbmIdx[0] = Ibit;
+                if((ale_db[node].BM2[0] & 1)) {//Check one bit in IBM 
+                    ResultPtr = ale_db[node].rptr;                
+                }
+            }
+            else{
+                BitPos[i] = BitPos[i-1] + NumNodes[i-1]; //first node position in SBM
+                OneCount = bit_count_ones(ale_db[node], BitPos[i], 0, BitPos[i-1]);
+                NumNodes[i] = 2 * OneCount; 
+                if((SbmIdx[i-1]-1) >= BitPos[i-1])
+                    OneCount = bit_count_ones(ale_db[node], (SbmIdx[i-1]), 0,BitPos[i-1]);
+                else 
+                    OneCount = 0;
+                SbmIdx[i] = BitPos[i]+ (2 * OneCount) + Ibit;                
+            }
+ 
+            IbmIdx = bit_count_ones(ale_db[node], (SbmIdx[i]+1), 0, 0);
+            if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){//find a match result
+                TempResultPtr = ale_db[node].rptr + bit_count_ones(ale_db[node], IbmIdx, 2, 0);//why use temp, the node is one step behind               
+            }
+            if(ale_db[node].BM1[(SbmIdx[i])/8] & (1<<(SbmIdx[i]%8))){//continue to check next
+                if(ale_db[node].BM2[(IbmIdx)/8] & (1<<(IbmIdx%8))){
+                    ResultPtr = TempResultPtr;
+                }
+            } 
+            else {//complete this node
+                EbmIdx = count_zero(ale_db[node], SbmIdx[i], 0, 0);
+                if((ale_db[node].BM2[(max_SPARSE_node + EbmIdx)/8] & (1<<((max_SPARSE_node + EbmIdx)%8)))){//find a next node
+                    node = ale_db[node].cptr + bit_count_ones(ale_db[node], max_SPARSE_node + EbmIdx+1, 1, max_SPARSE_node);       
+                    i = -1;
+                    BitPos[0]=0;
+                    NumNodes[0]=2;
+                    SbmIdx[0]=0;
+                    EbmIdx=0;
+                    IbmIdx=0;
+                } 
+                else{//can not find next node, finish searching
+                    break;
+                }
+            } 
+            i++;      
+        }         
+        return ResultPtr;
+    }
+}
+
+
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
index 255e0bb..6f4560a 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
@@ -1005,6 +1005,8 @@ static inline int xlp_message_receive(uint32_t vc, uint32_t *src_id,
 	xlp_message_receive_1(dst, src, size, code, data0)
 #define nlm_hal_recv_msg2(dst, src, size, code, data0, data1) \
 	xlp_message_receive_2(dst, src, size, code, data0, data1)
+#define nlm_hal_recv_msg3(dst, src, size, code, data0, data1, data2) \
+	xlp_message_receive_3(dst, src, size, code, data0, data1, data2)
 
 /**
 * @brief xlp_message_receive_gid_1 function is used to receive a single entry message from a VC of the CPU. It also reads the 8b guest ID. Size should be used to determine how other 64b messages were available with data.
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index ca93486..342f6f2 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -420,6 +420,9 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP9XX_POE1_DEVICE              3
 #define XLP9XX_POE1_FUNC                4 
 
+#define XLP9XX_ALE_DEVICE               3
+#define XLP9XX_ALE_FUNC                 5 
+
 /*Sw Code */
 #define XLP_CODE_MAC		0
 #define XLP_CODE_SEC		1
-- 
1.7.1

