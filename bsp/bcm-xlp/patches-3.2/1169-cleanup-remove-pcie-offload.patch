From 5d2166df3af8093fc7fa74983c11cc0063b5fada Mon Sep 17 00:00:00 2001
From: P. Sadik <psadik@broadcom.com>
Date: Thu, 25 Jul 2013 18:50:58 +0530
Subject: cleanup: remove pcie-offload.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/pcie-offload/README.txt b/drivers/misc/netlogic/pcie-offload/README.txt
deleted file mode 100644
index ee99b2c..0000000
--- a/drivers/misc/netlogic/pcie-offload/README.txt
+++ /dev/null
@@ -1,86 +0,0 @@
-Location of this directory should be
-<TOP-OF-SDK>/linux-userspace/kmod/pcie-offload
-
-For Device deployment:
-=====================
-1. Source @<TOP-OF-SDK>/sdk-base/build.sh to configure cross compilation
-environment.
-2. Compile linux kernel for the device:
-   a. Run 'make menuconfig'.
-   b. Enable Machine selection  --->
-      	   [*] Enable XLP device mode
-   c. Device Drivers  --->
-      	     Character devices  --->
-   	     	       <*> Enable netlogic XLP DMA driver
-   d. make vmlinux
-3. Compile Driver modules.
-$ cd pcie-offload
-$ ./setup_dev.sh
-
-
-IMPORTANT NOTE :
-This script will compile the modules and installs the modules in the root file
-system. To use them, you might have to re-build linux kernel image again.
-
-For Host module compilation:
-===========================
-1. It is recommended that one should use another terminal console (one where
-build.sh is NOT sourced)
-$ cd pcie-offload
-$ ./setup_host.sh <path to host kernel sources>
-  e.g. on a typical Linux PC,
-   ./setup_host.sh /lib/modules/`uname -r`/build
-
-This command would compile character and network interface host drivers in
-respective char/host and net/host directories. One may optionally copy these
-kernel modules to another location.
-
-For the network over PCIe interface:
-===================================
-1. Use the vmlinux to boot the device
-2. In the booted pcie device, run
-   $ modprobe netl_pti
-3. In the HOST (as root or using sudo)
-   $ insmod ./char/host/netl_pti.ko
-4. In the pcie device
-   $ modprobe pcieip
-   $ ifconfig eth0 <IP addr> <netmask>	...etc
-4. In the host
-   $ insmod ./net/host/pcieip.ko
-   $ ifconfig ethX <IP addr> <netmas> ...etc
-   # You need to find the ethX using $ifconfig -a
-
-You can do ftp, tftp ..etc between the host and device interfaces now.
-
-For the character device interface :
-===================================
-Once card boots up
-#modprobe netl_pti.ko
-
-There are guidelines till an all automated version of this program is completed.
-
-1. The device has to be fully up before host driver portion is insmod-ed.
-   Once you execute the above 'modprobe' command, you would see some messages
-   appearing on the device console like,
-
-    0:<7>parse_hs_from_host()@/space/bringup-master/sdk-base/linux-userspace/pci-offload/char/device/netl_pti_dev.c:449 No host signature yet
-
-   You need to wait till these messages repeatedly printed out before insmod-ing
-   netl_pti.ko on the host side.
-
-2. Once the handshake is complete, you would see something like,
-	Init subsystem X
-	Subsystem Done X
-	X could be 0 - 7 (including)
-3. You need to figure out the minor and major numbers from /proc/devices before
-you create a node. Execute
- $ cat /proc/devices | grep netl_pti
-Use the major number printed like,
- #mknod /dev/netl_char1 c <MAJOR> 1 # 1 is minor number
- This character device would use subsystem 1
- You may not use the minor number 0, for this is reserved for control traffic
-
-4. Userspace components need be initialized before dd can work. For that,
- $ dd if=/dev/zero of=/dev/netl_char1 bs=4k count=0
-
-5. Repeat the above command on host side as well.
diff --git a/drivers/misc/netlogic/pcie-offload/char/device/Kbuild b/drivers/misc/netlogic/pcie-offload/char/device/Kbuild
deleted file mode 100644
index 9a6a85b..0000000
--- a/drivers/misc/netlogic/pcie-offload/char/device/Kbuild
+++ /dev/null
@@ -1,5 +0,0 @@
-EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL	-I$(src)/../../include -DNETL_PTI_DEVICE -DNETL_ERR_DEBUG
-EXTRA_CFLAGS += -DNETL_PTI_DEBUG -g
-
-obj-m += netl_pti.o
-netl_pti-y := netl_pti_dev.o netl_pti_common.o netl_pti_char.o
diff --git a/drivers/misc/netlogic/pcie-offload/char/device/Makefile b/drivers/misc/netlogic/pcie-offload/char/device/Makefile
deleted file mode 100644
index fe15940..0000000
--- a/drivers/misc/netlogic/pcie-offload/char/device/Makefile
+++ /dev/null
@@ -1,33 +0,0 @@
-# Just the make file.
-# Moved all module specific build instructions to Kbuild
-#
-PWD = $(shell pwd -L)
-KERNELDIR := $(shell readlink -fn $(PWD)/../../../../../linux/)
-ROOTFS_DIR = $(shell readlink -fn $(KERNELDIR)/usr/rootfs.xlp/)
-TAGS = /usr/bin/ctags
-CSCOPE = /usr/bin/cscope
-all: modules
-
-modules:
-	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@
-
-modules_install: modules
-	make -C $(KERNELDIR) M=$(PWD) modules_install INSTALL_MOD_PATH=$(ROOTFS_DIR)
-
-help:
-	make -C $(KERNELDIR) M=$(PWD) help
-
-cscope:
-	$(CSCOPE) $(CSCOPEFLAGS) -R
-
-tags:
-	$(TAGS) netl_pti_dev.c ../../include/{nlm_pcie.h,netl_pti_common.c,netl_pti_char.c,netl_pti.h,netl_pti_dev.h}
-
-clean:
-	make -C $(KERNELDIR) M=$(PWD) clean
-	rm -rf *.o *.mod.* *.ko *.o.p *.i
-distclean: clean
-	rm -rf cscope*
-	rm -rf tags
-
-.PHONY: help cscope tags clean distclean image install
diff --git a/drivers/misc/netlogic/pcie-offload/char/device/netl_pti_dev.c b/drivers/misc/netlogic/pcie-offload/char/device/netl_pti_dev.c
deleted file mode 100644
index 9dd018b..0000000
--- a/drivers/misc/netlogic/pcie-offload/char/device/netl_pti_dev.c
+++ /dev/null
@@ -1,561 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include <netl_pti.h>
-
-static struct handshake_struct *dev_hs;
-extern int init_subsystems(struct handshake_struct *hs);
-extern void dealloc_all_subsys(struct handshake_struct *hs);
-extern void dump_desc_ring(struct seq_file *seq, struct desc_ring *ring, int dump_all);
-extern void dump_descriptor(struct seq_file *seq, struct descriptor *ptr);
-extern int add_to_rxlist(struct pti_subsys *ss, volatile struct kvec *iov);
-extern int netl_register_chrdev(struct handshake_struct *hs);
-extern int init_handshake_struct(struct handshake_struct *hs);
-extern struct pti_subsys *init_one_subsys(struct handshake_struct *, int );
-void netl_unregister_chrdev(struct handshake_struct *hs);
-
-static u64 pti_mem_start;
-struct workqueue_struct *ss_workq;
-
-/* Function delcarations */
-void hs_set_cmdreg(struct handshake_struct *hs);
-void subsys_poll(struct pti_subsys *);
-static void subsys_poll_rx(struct pti_subsys *);
-int send_one_packet_to_host(struct pti_subsys *ss, unsigned long page, u32 len);
-void copy_desc_pci(volatile struct _desc_pci *new, volatile struct _desc_pci *orig);
-irqreturn_t dev_int_handler(int irq, void *d);
-static void temp_int_func(struct work_struct *work);
-volatile void *get_start_of_mem(void);
-int __dev_def_rx_cmpl(struct pti_subsys *ss, struct descriptor *d, struct iovec *iov);
-void check_and_set_int_flags(struct pti_subsys *ss);
-
-/*
- * Host worker function. Will take out after interrupt implementation
- *
- */
-static void temp_int_func(struct work_struct *work)
-{
-	struct handshake_struct *hs = container_of(work, struct handshake_struct, temp_int_work.work);
-	unsigned long flags;
-
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	dev_int_handler(PTI_DEV_IRQ, hs);
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-	schedule_delayed_work(&hs->temp_int_work, 0);
-}
-
-/*
- * Alternate function calls for temp_int_func
- */
-void hs_task_func(unsigned long d)
-{
-	struct handshake_struct *hs = (struct handshake_struct *)d;
-	// unsigned long flags;
-
-	dev_int_handler(PTI_DEV_IRQ, hs);
-	tasklet_schedule(&hs->hs_stask);
-}
-
-/* Interrupt handler
- *
- * @irq		: irq number
- * @d		: data supplied during registration
- */
-irqreturn_t dev_int_handler(int irq, void *d)
-{
-	struct handshake_struct *hs = (struct handshake_struct *)d;
-	struct pti_subsys *ss;
-	struct hlist_node *node;
-	int count;
-
-	/* go through registered subsystems and start threads */
-	for(count = 0; count < NETL_SUBSYS_HASH; count++){
-		if(hlist_empty(&hs->hhash[count])){
-			continue;
-		}
-		hlist_for_each_entry(ss, node, &hs->hhash[count], snode){
-		/* Need a better way findng out subsystem with job pending */
-			check_and_set_int_flags(ss);
-			subsys_poll(ss);
-		}
-	}
-	return IRQ_HANDLED;
-}
-
-/*
- * Async callback function to process data.
- *
- * @ptr	: descriptor id
- */
-void dev_def_rx_cmpl(void *ptr, uint64_t ignored)
-{
-	struct pti_subsys *ss = NULL;
-	struct descriptor *d = (struct descriptor *)ptr;
-	unsigned long flags;
-	volatile struct kvec rx;
-	u32 tmp;
-
-	if(!ptr){
-		fdebug("NULL func ptr\n");
-		return;
-	}
-	ss = d->pring->ss;
-	//fdebug("ss->id = %#x, d->idx = %#x\n", ss->id, d->idx);
-	spin_lock_irqsave(&d->pring->rng_lock, flags);
-	pti_pci_write32(0, (void *)&d->pci_desc->dma_stat);
-	d->pring->end = INCR_CEIL(d->idx);
-	/* Why increment idx before writing to tail?
-	 * Host side assumes,
-	 * a. head=tail => empty ring
-	 * b. buffers with DMA complete is from ring->start inclusive to tail-1
-	 * */
-	pti_pci_write32(INCR_CEIL(d->idx), (void *)d->pring->tail);
-	mb();
-#ifdef NETL_ERR_DEBUG
-	if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_stat)) != 0){
-		PERROR("W 0, R %#x\n", tmp);
-	}
-	if((tmp = pti_pci_read32((void *)d->pring->tail)) != INCR_CEIL(d->idx)){
-		PERROR("W %#x, R %#x\n", INCR_CEIL(d->idx), tmp);
-	}
-#endif
-	//fdebug("Updated STAT %#x, TAIL = %#x\n", pti_pci_read32((void *)&d->pci_desc->dma_stat), pti_pci_read32((void *)d->pring->tail));
-	/* Send data upstream here  TODO */
-	rx.iov_len = d->len;
-	ss->rxbytes += d->len;
-	rx.iov_base = (void *)d->buf;
-	spin_unlock_irqrestore(&d->pring->rng_lock, flags);
-	raise_host_interrupt(0);
-	add_to_rxlist(ss, &rx);
-	return;
-}
-
-/*
- * Function to call when a tx complete interrupt is received
- * When you have Tx int, that descriptor buffer should be free-ed.
- */
-void dev_def_tx_cmpl(void *ptr, uint64_t ignored)
-{
-	struct descriptor *d = (struct descriptor *)ptr;
-	struct pti_subsys *ss;
-	unsigned long flags;
-	u32 tmp;
-
-	if(unlikely(ptr == NULL)){
-		PERROR("NULL pointer BUG\n");
-		BUG_ON(ptr == NULL);
-	}
-	ss = d->pring->ss;
-	spin_lock_irqsave(&d->pring->rng_lock, flags);
-	pti_pci_write32(d->len, (void *)&d->pci_desc->dma_len);
-	pti_pci_write32(0, (void *)&d->pci_desc->dma_stat);
-	mb();
-	pti_pci_write32(INCR_CEIL(d->idx), (void *)d->pring->head);
-	mb();
-#ifdef NETL_ERR_DEBUG
-	if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_stat)) != 0){
-		PERROR("W 0, R %#x\n", tmp);
-	}
-	if((tmp = pti_pci_read32((void *)d->pring->head)) != INCR_CEIL(d->idx)){
-		PERROR("W %#x, R %#x\n", INCR_CEIL(d->idx), tmp);
-	}
-	if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_len)) != d->len){
-		PERROR("W %#x, R %#x\n", d->len, tmp);
-	}
-#endif
-	//fdebug("Cleared dma_stat:%p, head = %#x\n", &d->pci_desc->dma_stat, d->idx);
-	//dump_desc_ring(NULL, d->pring, 0);
-	spin_unlock_irqrestore(&d->pring->rng_lock, flags);
-	raise_host_interrupt(0);
-}
-
-static void subsys_poll_tx(struct pti_subsys *ss)
-{
-	struct desc_ring *txr;
-	unsigned long fl_rng;
-	volatile u32 tail;
-	int loops;
-
-	txr = ss->txring;
-	spin_lock_irqsave(&txr->rng_lock, fl_rng);
-	tail = pti_pci_read32((void *)txr->tail);
-	loops = (NETL_NR_DESC + tail - txr->end) % NETL_NR_DESC;
-	// fdebug("tail = %#x, END = %#x\n", tail, txr->end);
-	while(loops--){
-		//fdebug("loops = %d, end = %#x\n", loops+1, txr->end);
-		free_page(txr->pdesc[txr->end].buf);
-		txr->pdesc[txr->end].buf = 0;
-		txr->pdesc[txr->end].len = 0;
-		txr->nfree++;
-		txr->end = INCR_CEIL(txr->end);
-	}
-	spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-
-	spin_lock_irqsave(&ss->slock, fl_rng);
-	ss->flags &= ~SUBSYS_FLAGS_TX;
-	ss->flags &= ~SUBSYS_FLAGS_TX_PENDING;
-	spin_unlock_irqrestore(&ss->slock, fl_rng);
-	wake_up_interruptible(&ss->wrq);
-	return;
-}
-
-/*
- * Work queue for subsystem work threads
- */
-/*
- * Polling function
- *
- * @work	: ss->swork
- */
-static void subsys_poll_rx(struct pti_subsys *ss)
-{
-	struct desc_ring *rxr;
-	unsigned long fl_rng;
-	volatile struct _desc_pci d_cp;
-	volatile u32 head, stmp = 0;
-	int loops;
-	rxr = ss->rxring;
-	spin_lock_irqsave(&rxr->rng_lock, fl_rng);
-	head = pti_pci_read32((void *)rxr->head);
-	loops = (NETL_NR_DESC + head - rxr->start) % NETL_NR_DESC;
-	spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-	while(loops--){
-		spin_lock_irqsave(&rxr->rng_lock, fl_rng);
-		copy_desc_pci(&d_cp, rxr->pdesc[rxr->start].pci_desc);
-		if(!is_dma_set(d_cp.dma_stat)){
-			/* Nothing to do now. Should not happen*/
-			PERROR("Queue empty.rxr->start = %#x\n", rxr->start);
-			dump_desc_ring(NULL, rxr, 1);
-			spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-			return;
-		}
-		/* setup DMA with the tail we have now */
-		//fdebug("d_cp.dma_len = %#x\n", d_cp.dma_len);
-		rxr->pdesc[rxr->start].buf = get_zeroed_page(GFP_ATOMIC);
-		rxr->pdesc[rxr->start].len = d_cp.dma_len;
-		rxr->pdesc[rxr->start].idx = rxr->start;
-		//fdebug("head = %#x, rxr->start = %#x, idx = %#x\n", head, rxr->start, rxr->pdesc[rxr->start].idx);
-		stmp = rxr->start;
-		rxr->start= INCR_CEIL(rxr->start);
-		spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-		xlp_async_request_dma(((u64)d_cp.dma_addr),
-			virt_to_phys((void *)rxr->pdesc[stmp].buf),
-			d_cp.dma_len, dev_def_rx_cmpl,
-			(void *)&rxr->pdesc[stmp], DMA_TO_DEVICE);
-	}
-
-	spin_lock_irqsave(&ss->slock, fl_rng);
-	ss->flags &= ~SUBSYS_FLAGS_RX;
-	ss->flags &= ~SUBSYS_FLAGS_RX_PENDING;
-	spin_unlock_irqrestore(&ss->slock, fl_rng);
-//	fdebug("Exiting with head = %#x, start= %#x, end = %#x\n", head, rxr->start, rxr->end);
-	return;
-}
-
-/*
- * Adds one packet to Tx queue of device.
- * Tx queue is setup from the host side with physical addresses of buffers and
- * lengths.
- *
- * @ss	: subsystem through which we send packet.
- */
-int send_one_packet_to_host(struct pti_subsys *ss, unsigned long page, u32 len)
-{
-	struct desc_ring *txr;
-	unsigned long fl_rng;
-	volatile struct _desc_pci d_cp;
-	u32 tmp;
-	txr = ss->txring;
-	spin_lock_irqsave(&txr->rng_lock, fl_rng);
-	// fdebug("end = %#x, start = %#x\n", txr->end, txr->start);
-	if(INCR_CEIL(txr->start) == txr->end){	/* Queue full */
-		//fdebug("Queue full\n");
-		spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-		return EAGAIN;
-	}
-	copy_desc_pci(&d_cp, txr->pdesc[txr->start].pci_desc);
-	if(len > d_cp.dma_len){
-		PERROR("Req. len = %#x > dma_len %#x\n", len, d_cp.dma_len);
-		spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-		/* Allocated space on host is less than packet len. Abort */
-		return EINVAL;
-	}
-	if(!is_dma_set(d_cp.dma_stat)){
-		/* head to start-1 should be DMA-able */
-		PERROR("No DMA bit set@txring[%#x]: %#llx, %#x, %#x\n", txr->start, d_cp.dma_addr, d_cp.dma_len, d_cp.dma_stat);
-		dump_descriptor(NULL, &txr->pdesc[txr->start]);
-		dump_desc_ring(NULL, txr, 1);
-		spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-		return EAGAIN;
-	}
-	/* setup DMA now */
-	txr->pdesc[txr->start].buf = page;
-	txr->pdesc[txr->start].len = len;	/*len < PAGE_SIZE possible*/
-	/* update txr->head before starting async DMA */
-	tmp = txr->start;
-	txr->start = INCR_CEIL(txr->start);
-	txr->nfree--;
-	ss->txbytes += len;
-	spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-	if(xlp_async_request_dma(virt_to_phys((void *)page),
-		((u64)d_cp.dma_addr), len, dev_def_tx_cmpl,
-		(void *)&txr->pdesc[tmp], DMA_FROM_DEVICE) != 0){
-		PERROR("dma failure\n");
-		return EFAULT;
-	}
-	// fdebug("\n");
-	return 0;
-}
-
-EXPORT_SYMBOL(send_one_packet_to_host);
-void check_and_set_int_flags(struct pti_subsys *ss)
-{
-	unsigned long flags, flag1;
-	u32 tail, head;
-
-	spin_lock_irqsave(&ss->slock, flags);
-
-	/* Tx complete for sent data from device */
-	spin_lock_irqsave(&ss->txring->rng_lock, flag1);
-	tail = pti_pci_read32((void *)ss->txring->tail);
-	if(tail != ss->txring->end){
-		ss->flags |= SUBSYS_FLAGS_TX_PENDING;
-	}
-	spin_unlock_irqrestore(&ss->txring->rng_lock, flag1);
-
-	/* rx for sent data from host*/
-	spin_lock_irqsave(&ss->rxring->rng_lock, flag1);
-	head = pti_pci_read32((void *)ss->rxring->head);
-	if(head != ss->rxring->start){
-		ss->flags |= SUBSYS_FLAGS_RX_PENDING;
-	}
-	spin_unlock_irqrestore(&ss->rxring->rng_lock, flag1);
-
-	spin_unlock_irqrestore(&ss->slock, flags);
-}
-
-/*
- * Polling function
- *
- * @work	: ss->swork
- */
-void subsys_poll(struct pti_subsys *ss)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ss->slock, flags);
-	if(ss->flags & SUBSYS_FLAGS_TX_DISABLED){
-		spin_unlock_irqrestore(&ss->slock, flags);
-		goto tx_done;
-	}
-	if(ss->flags & SUBSYS_FLAGS_TX_PENDING){
-		if(ss->flags & SUBSYS_FLAGS_TX){
-			/* currently running and pending: clear flag and reschedule self */
-			ss->flags &= ~SUBSYS_FLAGS_TX_PENDING;
-			spin_unlock_irqrestore(&ss->slock, flags);
-		}else{
-			/* Tx not running. Run */
-			ss->flags |= SUBSYS_FLAGS_TX;
-			spin_unlock_irqrestore(&ss->slock, flags);
-			subsys_poll_tx(ss);
-		}
-	}else{
-		spin_unlock_irqrestore(&ss->slock, flags);
-	}
-tx_done:
-	spin_lock_irqsave(&ss->slock, flags);
-	if(ss->flags & SUBSYS_FLAGS_RX_DISABLED){
-		spin_unlock_irqrestore(&ss->slock, flags);
-		goto rx_done;
-	}
-	if(ss->flags & SUBSYS_FLAGS_RX_PENDING){
-		if(ss->flags & SUBSYS_FLAGS_RX){
-			/* running and pending; clear flag and reschedule self */
-			ss->flags &= ~SUBSYS_FLAGS_RX_PENDING;
-			spin_unlock_irqrestore(&ss->slock, flags);
-		}else{
-			/* Tx not running and pending. Run */
-			ss->flags |= SUBSYS_FLAGS_RX;
-			spin_unlock_irqrestore(&ss->slock, flags);
-			subsys_poll_rx(ss);
-		}
-	}else{
-		spin_unlock_irqrestore(&ss->slock, flags);
-	}
-rx_done:
-	return;
-}
-
-/*
- * This function is the looping handshake function for handshake
- *
- * @work : handshake_struct -> hs_work
- */
-void hs_work_func(struct work_struct *work)
-{
-	__label__ init_ss_fail;
-	struct handshake_struct *hs = container_of(
-		work, struct handshake_struct, hs_work.work);
-	unsigned long flags;
-	u32 ret, i;
-
-	pti_pci_write32(NETL_DEV_SIGNATURE, (void *)hs->start);
-	ret = pti_pci_read32((void *)(hs->start + 4));
-	//PDEBUG("hs->start = %p,* =%#x\n", hs->start, pti_pci_read32(hs->start));
-	if (ret != NETL_HOST_SIGNATURE) {
-		fdebug("No signature yet\n");
-		schedule_delayed_work(&hs->hs_work, HZ);
-		return;
-	}
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	hs->status = HS_DEV_READY_TXRX;
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-	netl_register_chrdev(hs);
-	for(i = 0; i < NETL_MAX_SUBSYS; i++) {
-		hs->ss[i] = init_one_subsys(hs, i);
-		if (hs->ss[i] == NULL) {
-			goto init_ss_fail;
-		}
-	}
-	/* No more self schedule. Just start tasklet */
-	tasklet_schedule(&hs->hs_stask);
-	return;
-init_ss_fail:
-	while (i--) {
-		/* free the subsystem  TBD TODO */
-	}
-	return;
-}
-
-int dev_specific_hs_init(struct handshake_struct *hs)
-{
-	hs->status = HS_STATUS_NOT_DONE;
-	INIT_DELAYED_WORK(&hs->temp_int_work, temp_int_func);
-	tasklet_init(&hs->hs_stask, hs_task_func, (long unsigned int)hs);
-	return 0;
-}
-
-/* Init function
- * Need to get the shared mem base and initialize the global variable.
- * Start kernel thread for commands on cmd0
- */
-int __init netl_pti_dev_init(void)
-{
-	dev_hs = kzalloc(sizeof(struct handshake_struct), GFP_KERNEL);
-	if(!dev_hs){
-		PERROR("No memory to allocate\n");
-		return ENOMEM;
-	}
-	pti_mem_start =  setup_pcie_shared_memspace((u64 *)&dev_hs->pci_len);
-	if (pti_mem_start == 0) {
-		return -ENOMEM;
-	}
-	ss_workq = create_workqueue("ss_workq");
-	BUG_ON(!ss_workq);
-
-	dev_hs->start = ioremap_nocache(virt_to_phys((volatile const void *)pti_mem_start), dev_hs->pci_len);
-	if (dev_hs->start == NULL) {
-		return -EFAULT;
-	}
-	dev_hs->start += PTI_ADDR_OFFSET;
-	init_handshake_struct(dev_hs);
-	schedule_delayed_work(&dev_hs->hs_work, HZ);
-	PERROR("pti_subsys = %ld, desc_ring = %ld, descriptor = %ld, _desc_pci = %ld, rx=%ld\n", sizeof(struct pti_subsys), sizeof(struct desc_ring), sizeof(struct descriptor), sizeof(struct _desc_pci), sizeof(struct rx_struct));
-	return 0;
-}
-
-int get_hs(struct handshake_struct **res)
-{
-	*res = dev_hs;
-	return 0;
-}
-
-void __exit netl_pti_dev_uninit(void)
-{
-	if(dev_hs->status == HS_DEV_READY_TXRX){
-		netl_unregister_chrdev(dev_hs);
-	}
-	dev_hs->status = HS_DEV_EXITING;
-	tasklet_kill(&dev_hs->hs_stask);
-	cancel_delayed_work_sync(&dev_hs->temp_int_work);
-	flush_delayed_work(&dev_hs->temp_int_work);
-	cancel_delayed_work_sync(&dev_hs->hs_work);
-	flush_delayed_work(&dev_hs->hs_work);
-	dealloc_all_subsys(dev_hs);
-	debugfs_remove_recursive(dev_hs->dbg_root);
-	kfree(dev_hs);
-	return;
-}
-
-module_init(netl_pti_dev_init);
-module_exit(netl_pti_dev_uninit);
-MODULE_LICENSE("GPL");
-
-#ifndef CONFIG_NLM_XLP
-static int xls_get_pci_mode(void)
-{
-	uint32_t mode;
-	phoenix_reg_t *pcix_ctrl_mmio = phoenix_io_mmio(PHOENIX_IO_GPIO_OFFSET);
-	/* gpio Reset Configuration Register */
-	mode = pcix_ctrl_mmio[21];
-	mode = mode >> 20;
-	if ((mode & 0x1) == 0) {
-		return XLR_PCI_DEV_MODE;
-	}
-	return XLR_PCI_HOST_MODE;
-}
-
-volatile void *get_start_of_mem(void)
-{
-	phoenix_reg_t *pcix_ctrl_mmio_le = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
-	phoenix_reg_t *bridge_mmio = (phoenix_reg_t *) phoenix_io_base;
-	u64 start;
-
-	if(xls_get_pci_mode() != XLR_PCI_DEV_MODE){
-		printk("ERROR: HOST MODE\n");
-		pti_mem_start= 0;
-		return NULL;
-	}
-
-	/* PRM : PCI Address Map Registers : 22.8.7 */
-	bridge_mmio[0x3a] |= 0x2;
-	bridge_mmio[0x42] = 0x8000ffff;
-	start = (u64)pcix_ctrl_mmio_le[28];
-	printk("start from mmio %llx\n", start);
-	start = ((u64)start >> 15) << 23;
-	printk("start address is %llx\n", start);
-	start = start | CKSEG1;
-	pti_mem_start = (volatile void *)start;
-	printk("start =  %llx\n", start);
-	printk("pti_mem_start =  %p\n", pti_mem_start);
-	printk("device mem is at %llx\n", (u64) bridge_mmio[0x42]);
-	return pti_mem_start;
-}
-
-#endif	// CONFIG_NLM_XLP
-
diff --git a/drivers/misc/netlogic/pcie-offload/char/host/Makefile b/drivers/misc/netlogic/pcie-offload/char/host/Makefile
deleted file mode 100644
index c469cff..0000000
--- a/drivers/misc/netlogic/pcie-offload/char/host/Makefile
+++ /dev/null
@@ -1,37 +0,0 @@
-CSCOPE = $(shell which cscope)
-CSCOPEFLAGS = -bvkq -R
-CTAGS = $(shell which ctags)
-#if host needs to send data (for testing) to device uncomment next line
-ifeq ($(KDIR),)
-	KDIR := /lib/modules/$(shell uname -r)/build
-endif
-# EXTRA_CFLAGS += -DNETL_PTI_TEST
-ifneq ($(KERNELRELEASE),)
-EXTRA_CFLAGS := -I$(src)/../../include -DNETL_PTI_HOST -DNETL_ERR_DEBUG
-EXTRA_CFLAGS += -DNETL_TARGET_XLP -DNETL_PTI_DEBUG -g
-obj-m += netl_pti.o
-netl_pti-objs := netl_pti_host.o netl_pti_common.o netl_pti_char.o
-
-else
-modules:
-	make -C $(KDIR) M=$(PWD) modules
-
-all: module
-
-help:
-	make -C $(KDIR) M=$(PWD) help
-
-cscope:
-	$(CSCOPE) $(CSCOPEFLAGS)
-
-tags:
-	$(CTAGS) netl_pti_host.c ../../include/{nlm_pcie.h,netl_pti_common.c,netl_pti_char.c,netl_pti.h,netl_pti_char.h}
-
-clean:
-	make -C $(KDIR) M=$(PWD) clean
-	rm -rf *.o *.mod.* *.ko
-distclean: clean
-	rm -rf cscope*
-	rm -rf tags
-.PHONY: help cscope tags clean distclean
-endif
diff --git a/drivers/misc/netlogic/pcie-offload/char/host/netl_pti_host.c b/drivers/misc/netlogic/pcie-offload/char/host/netl_pti_host.c
deleted file mode 100644
index 1bc7154..0000000
--- a/drivers/misc/netlogic/pcie-offload/char/host/netl_pti_host.c
+++ /dev/null
@@ -1,904 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include <netl_pti.h>
-
-struct workqueue_struct *ss_workq;	/* workqueue for int handling */
-
-#ifdef NETL_TARGET_XLP
-#define NETL_VENDOR_ID 0x184e
-#define NETL_DEVICE_ID 0x1004
-#else
-#define NETL_VENDOR_ID 0x182e
-#define NETL_DEVICE_ID 0xabcd
-#endif
-
-static struct pci_device_id netl_id_table[] = {
-	{NETL_VENDOR_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0,}
-};
-
-extern void dealloc_all_subsys(struct handshake_struct *hs);
-extern void dump_desc_ring(struct seq_file *seq, struct desc_ring *ring, int dump_all);
-extern void netl_unregister_chrdev(struct handshake_struct *hs);
-extern int netl_register_chrdev(struct handshake_struct *hs);
-extern int init_handshake_struct(struct handshake_struct *hs);
-extern struct pti_subsys *init_one_subsys(struct handshake_struct *hs, int id);
-
-#define NETL_DRIVER "netl_pti"
-
-/*
- * device_info keeps tracks of initialized instances of devices
- * one device is typically one card in the system.
- * A static allocation could be discontiguous in physical mem,
- * so, we go with a list of devices
- */
-struct netl_device{
-	int count;
-	spinlock_t lock;
-	struct list_head head;
-};
-struct netl_device *dev_list = NULL;
-
-/* function declarations */
-void netl_add_dev(struct handshake_struct *p);
-static int netl_phnx_generic_probe(struct pci_dev *pdev, const struct pci_device_id *id);
-void subsys_poll(struct pti_subsys*);
-static void subsys_poll_rx(struct pti_subsys *);
-void subsys_poll_tx(struct pti_subsys *);
-irqreturn_t host_msi_handler(int irq, void *d);
-int send_one_packet_to_device(struct pti_subsys *ss, unsigned long data, u32 len);
-void netl_rm_dev(struct handshake_struct *p);
-int init_device(struct handshake_struct *hs, int blocking);
-static void netl_phnx_generic_remove(struct pci_dev *pdev);
-int netl_pti_default_rx(uint8_t msg_code, void *laddr, unsigned int llen, void *addr, unsigned int len);
-static void raise_device_interrupt(void);
-int __host_def_rx_cmpl(struct pti_subsys *ss, struct descriptor *d, struct iovec *vec);
-int add_to_rxlist(struct pti_subsys *ss, volatile struct kvec *iov);
-
-struct pti_subsys *get_ss_from_idx(struct handshake_struct *hs, int idx);
-
-void temp_int_func(struct work_struct *work);
-int setup_host_irq(struct handshake_struct *);
-void hs_task_func(unsigned long d);
-
-static void raise_device_interrupt(void)
-{
-//	PDEBUG("Raising an interrupt to device\n");
-}
-
-static struct pci_driver netl_pci_driver = {
-	.name = NETL_DRIVER,
-	.id_table = netl_id_table,
-	.probe = netl_phnx_generic_probe,
-	.remove = netl_phnx_generic_remove,
-#ifdef POWER_MANAGEMENT
-	.suspend = netl_suspend,
-	.resume = netl_resume
-#endif
-};
-
-static void netl_phnx_generic_remove(struct pci_dev *pdev)
-{
-	struct handshake_struct *hs = NULL;
-	unsigned long flags;
-
-	hs = pci_get_drvdata(pdev);
-
-	netl_unregister_chrdev(hs);
-	/* Disable Interrupt scheduling */
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	hs->status = HS_DEV_EXITING;
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-#ifdef NETL_TARGET_XLP
-	if(hs->msi_flag == NETL_MSIX_ENABLE) {
-		free_irq(hs->msix.vector, hs);
-		pci_disable_msix(pdev);
-	} else if (hs->msi_flag == NETL_MSI_ENABLE) {
-		free_irq(pdev->irq, hs);
-		pci_disable_msi(pdev);
-	} else if (hs->msi_flag == NETL_INTX_ENABLE) {
-		free_irq(pdev->irq, pdev);
-	}
-#else
-	cancel_delayed_work(&hs->temp_int_work);
-	flush_delayed_work(&hs->temp_int_work);
-#endif
-	/* No more tasklet scheduling from now onwards */
-	netl_rm_dev(hs);
-	dealloc_all_subsys(hs);
-	del_timer_sync(&hs->link_timer);
-	debugfs_remove_recursive(hs->dbg_root);
-	kfree(hs->hhash);
-	pci_set_drvdata(pdev, NULL);
-	iounmap(hs->start);
-	pci_release_region(pdev, 0);
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-	pci_clear_master(pdev);
-	kfree(hs);
-
-	return;
-}
-
-
-/*
- * Function to call when a rx complete interrupt is received
- * What does this do?
- *	TODO
- * @ss : subsystem pointer
- * @d  : descriptor pointer (has a back reference to ss->{t,r}xring
- */
-int host_def_rx_cmpl(struct descriptor *d)
-{
-	struct pti_subsys *ss = d->pring->ss;
-	volatile struct kvec vec;
-	unsigned long buf = 0;
-	//unsigned long flags;
-	volatile dma_addr_t daddr, dm_old;
-	u32 tmp;
-
-	buf = get_zeroed_page(GFP_ATOMIC);
-	if(!buf){
-		PERROR("Mem Alloc fail in rx completion\n");
-		/* Discard current data and make it DMA-able in dma_stat */
-		pti_pci_write32(NETL_BUFSIZE, (void *)&d->pci_desc->dma_len);
-		pti_pci_write32(DESC_DMA_READY, (void *)&d->pci_desc->dma_stat);
-		d->pring->end = INCR_CEIL(d->idx);
-		pti_pci_write32(d->pring->end, (void *)d->pring->tail);
-		/* dma_addr and the corresponding d->buf remains the same */
-		return 0;
-	}
-	daddr = pci_map_single(ss->hs->p_dev, (void *)buf, NETL_BUFSIZE, DMA_FROM_DEVICE);
-	BUG_ON(!daddr);
-	// PDEBUG("d->buf = %#lx, daddr = %p\n", buf, (void *)daddr);
-
-	/* store what we need to send up (buf and len) */
-	vec.iov_len = pti_pci_read32((void *)&d->pci_desc->dma_len);
-	vec.iov_base = (void *)d->buf;
-	ss->rxbytes += vec.iov_len;
-
-	/* free up the mapping */
-	dm_old = pti_pci_read64((void *)&d->pci_desc->dma_addr);
-	pci_unmap_single(ss->hs->p_dev, dm_old, NETL_BUFSIZE, DMA_FROM_DEVICE);
-
-	/* Setup DMA with new address and length*/
-	pti_pci_write64(daddr, (void *)&d->pci_desc->dma_addr);
-	pti_pci_write32(NETL_BUFSIZE, (void *)&d->pci_desc->dma_len);
-	pti_pci_write32(DESC_DMA_READY, (void *)&d->pci_desc->dma_stat);
-	d->pring->end = INCR_CEIL(d->idx);
-	pti_pci_write32(d->pring->end, (void *)d->pring->tail);/* Incremented val */
-	mb();
-#ifdef NETL_ERR_DEBUG
-	/* This is for debugging */
-	dm_old = pti_pci_read64((void *)&d->pci_desc->dma_addr);
-	if(dm_old != daddr){
-		PERROR("W %llx, R %#llx\n", dm_old, daddr);
-	}
-	if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_stat)) != DESC_DMA_READY){
-		PERROR("W %#x, R %#x\n", DESC_DMA_READY, tmp);
-	}
-	if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_len)) != NETL_BUFSIZE){
-		PERROR("W %#x, R %#x\n", NETL_BUFSIZE, tmp);
-	}
-	if((tmp = pti_pci_read32((void *)d->pring->tail)) > NETL_NR_DESC){
-		PERROR("W %#x, R %#x\n", INCR_CEIL(d->idx), tmp);
-	}
-#endif
-	/* preserve buf info in the descriptor */
-	d->buf = buf;
-	d->len = NETL_BUFSIZE;
-#ifdef NETL_PTI_TEST
-	free_page((unsigned long)vec.iov_base);
-#else
-	/* Call user supplied function from here  TODO*/
-	if(add_to_rxlist(ss, &vec) != 0){
-		PERROR("Failed to add kvec to list\n");
-		free_page((unsigned long)vec.iov_base);
-		vec.iov_base = NULL;
-	}
-#endif
-	return 0;
-}
-/*
- * Handles the handshake of device
- * The device writes 'NETL'. Host waits till this value is read.
- * Then host writes elements of hs_params into shared space
- * This function is executed from a timer
- */
-void hs_work_func(struct work_struct *work)
-{
-	__label__ init_ss_fail, init_irq_fail;
-	struct handshake_struct *hs = container_of(
-		work, struct handshake_struct, hs_work.work);
-	unsigned long flags;
-	u32 ret, i;
-
-	ret = pti_pci_read32((void *)hs->start);
-	PDEBUG("hs->start = %p, * = %#x\n", hs->start, ret);
-	if(ret == NETL_DEV_SIGNATURE){
-		for(i = 0; i < NETL_MAX_SUBSYS; i++) {
-			hs->ss[i] = init_one_subsys(hs, i);
-			if (hs->ss[i] == NULL) {
-				goto init_ss_fail;
-			}
-		}
-		if(setup_host_irq(hs) < 0){
-			PERROR("Failed to setup Interrupt. Exiting\n");
-			goto init_irq_fail;
-		}
-		pti_pci_write32(NETL_HOST_SIGNATURE, (void *)hs->start + 4);
-		mdelay(500);
-		spin_lock_irqsave(&hs->hs_lock, flags);
-		hs->status = HS_DEV_READY_TXRX;
-		spin_unlock_irqrestore(&hs->hs_lock, flags);
-		PDEBUG("HS complete. Device ready for Tx and Rx\n");
-	}else{
-		schedule_delayed_work(&hs->hs_work, HZ);
-	}
-	return;
-init_irq_fail:
-init_ss_fail:
-	while (i--) {
-		/* free the subsystem  TBD TODO */
-	}
-	return;
-}
-
-/*
- * Starts the control system after handshaking with device
- *
- * @hs	: handshake struct
- */
-/* TBD REMOVE */
-#if 0
-static int start_host_control_subsys(struct handshake_struct *hs, struct pti_subsys **ctrl_ss)
-{
-	struct pti_subsys *ss;
-
-	ss = init_one_subsys(hs, NETL_CONTROL_SUBSYS);
-	if(ss == NULL){
-		return -EFAULT;
-	}
-	if(ctrl_ss != NULL){
-		*ctrl_ss = ss;
-	}
-	return 0;
-}
-#endif
-
-/*
- * Allocate and initialize handshake structure
- */
-int host_specific_hs_init(struct handshake_struct *hs)
-{
-	//hs->params.max_subsys = NETL_MAX_SUBSYS;
-	//hs->params.nr_desc = NETL_NR_DESC;
-	//hs->params.flags = 0;
-
-	hs->status = HS_STATUS_NOT_DONE;
-	INIT_LIST_HEAD(&hs->dhead);	/* device list */
-	hs->dev_list = dev_list;
-
-	/* host cmd/stat [0/4]
-	 * dev cmd/stat [8/0xc] */
-	INIT_DELAYED_WORK(&hs->temp_int_work, temp_int_func);
-	tasklet_init(&hs->hs_stask, hs_task_func, (long unsigned int)hs);
-	PDEBUG("HS initialization success\n");
-	return 0;
-}
-
-void __iomem *iomem_start = NULL;
-
-/*
- * Adds one packet to Tx queue of host
- * Tx queue is setup from the host side with physical addresses of buffers and
- * lengths. Even though host marks dma, actual DMA is under device's control
- *
- * @ss		: subsystem through which we send packet.
- * @page	: virtual page address to send
- * @len		: #of bytes in data
- */
-int send_one_packet_to_device(struct pti_subsys *ss, unsigned long page, u32 len)
-{
-	struct desc_ring *txr;
-	unsigned long fl_rng;
-	volatile u32 stat;
-	dma_addr_t dmaddr;
-	dma_addr_t dm_old;
-	u32 tmp, stmp;
-
-	txr = ss->txring;
-	dmaddr = pci_map_single(ss->hs->p_dev, (void *)page, NETL_BUFSIZE, DMA_TO_DEVICE);
-	if(!dmaddr){
-		return EAGAIN;
-	}
-	spin_lock_irqsave(&txr->rng_lock, fl_rng);
-	if(INCR_CEIL(txr->start) == txr->end){	/* Queue full, can't add */
-		BUG_ON(txr->nfree != 0);
-		spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-		return EAGAIN;
-	}
-	stat = pti_pci_read32((void *)&txr->pdesc[txr->start].pci_desc->dma_stat);
-	if(is_dma_set(stat)){
-		/* DMA under progress. Abandon write */
-		PERROR("DMA set for tx buffer\n");
-		pci_unmap_single(ss->hs->p_dev, dmaddr, len, DMA_TO_DEVICE);
-		spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-		// dump_desc_ring(NULL, txr, 1);
-		return EAGAIN;
-	}
-	txr->pdesc[txr->start].buf = page;
-	pti_pci_write64(dmaddr, (void *)&txr->pdesc[txr->start].pci_desc->dma_addr);
-	txr->pdesc[txr->start].len = len;
-	pti_pci_write32(len, (void *)&txr->pdesc[txr->start].pci_desc->dma_len);
-	pti_pci_write32(DESC_DMA_READY, (void *)&txr->pdesc[txr->start].pci_desc->dma_stat);
-	/* Incrementing txr->start should be the last step */
-	stmp = txr->start;
-	pti_pci_write32(INCR_CEIL(txr->start), (void *)txr->head);
-	txr->start = INCR_CEIL(txr->start);
-	mb();
-	ss->txbytes += len;
-#ifdef NETL_ERR_DEBUG
-	/* This is for debugging */
-	dm_old = pti_pci_read64((void *)&txr->pdesc[stmp].pci_desc->dma_addr);
-	if(dm_old != dmaddr){
-		PERROR("W %#llx, R %#llx\n", dmaddr, dm_old);
-	}
-	if((tmp = pti_pci_read32((void *)&txr->pdesc[stmp].pci_desc->dma_stat)) != DESC_DMA_READY){
-		PERROR("W %#x, R %#x\n", DESC_DMA_READY, tmp);
-	}
-	if((tmp = pti_pci_read32((void *)&txr->pdesc[stmp].pci_desc->dma_len)) != len){
-		PERROR("W %#x, R %#x\n", 0, tmp);
-	}
-	if((tmp = pti_pci_read32((void *)txr->head)) != INCR_CEIL(stmp)){
-		PERROR("W %#x, R %#x\n", INCR_CEIL(txr->pdesc[stmp].idx), tmp);
-	}
-#endif
-	txr->nfree--;
-	//PDEBUG("start = %#x, tail = %#x, nfree = %#x\n", txr->start, pti_pci_read32((void *)txr->tail), txr->nfree);
-	spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-	raise_device_interrupt();
-	return 0;
-}
-EXPORT_SYMBOL(send_one_packet_to_device);
-/* Interrupt handler
- *
- * @irq		: irq number
- * @d		: data supplied during registration
- */
-irqreturn_t host_msi_handler(int irq, void *d)
-{
-	struct handshake_struct *hs = (struct handshake_struct *)d;
-	int count;
-#if 0
-	/* 32 MB PCI Mem space is devided into four equal parts.
-	 * Last 8MB is used for register mapping
-	 */
-	volatile void *devint_mem = hs->start + ((0x3 << 23) + 0x8000);
-
-	// PDEBUG("hs->start = %llx, Read %x\n", hs->start, __be32_to_cpu(__raw_readl(devint_mem)));
-	/* Acknowledge interrupt by clearing ACK */
-	printk("cmd = %#x\n",__be32_to_cpu(__raw_readl(devint_mem + (0x258 << 2))));
-	printk("ack = %#x\n",__be32_to_cpu(__raw_readl(devint_mem + (0x259 << 2))));
-	__raw_writel(__cpu_to_be32(0x1), (devint_mem + (0x259 << 2)));
-	printk("cmd = %#x\n",__be32_to_cpu(__readl(devint_mem + (0x258 << 2))));
-	printk("ack = %#x\n",__be32_to_cpu(__readl(devint_mem + (0x259 << 2))));
-	__raw_writel(__cpu_to_be32(0x0), (devint_mem + (0x258 << 2)));
-#endif
-	/* go through registered subsystems and start threads */
-	for(count = 0; count < NETL_SUBSYS_HASH; count++){
-		if(hlist_empty(&hs->hhash[count])){
-			continue;
-		}
-		/* If at least one is not empty, schedule tasklet */
-		tasklet_schedule(&hs->hs_stask);
-		/*
-		hlist_for_each_entry(ss, node, &hs->hhash[count], snode){
-			tasklet_schedule(&ss->stask);
-		}
-		*/
-	}
-	return IRQ_HANDLED;
-}
-
-
-void check_and_set_int_flags(struct pti_subsys *ss)
-{
-	unsigned long flags, flag1;
-	u32 tail, head;
-
-	spin_lock_irqsave(&ss->slock, flags);
-	/* rx for sent data from device */
-	spin_lock_irqsave(&ss->rxring->rng_lock, flag1);
-	head = pti_pci_read32((void *)ss->rxring->head);
-	//PDEBUG("idx = %d, head = %#x, start = %#x\n", ss->id, head, ss->rxring->start);
-	if(head != ss->rxring->start){
-		ss->flags |= SUBSYS_FLAGS_RX_PENDING;
-	}
-	spin_unlock_irqrestore(&ss->rxring->rng_lock, flag1);
-
-	/* Tx complete for sent data from host */
-	spin_lock_irqsave(&ss->txring->rng_lock, flag1);
-	tail= pti_pci_read32((void *)ss->txring->tail);
-	//PDEBUG("idx = %d, tail = %#x, end = %#x\n", ss->id, tail, ss->txring->end);
-	if(tail != ss->txring->end){
-		ss->flags |= SUBSYS_FLAGS_TX_PENDING;
-	}
-	spin_unlock_irqrestore(&ss->txring->rng_lock, flag1);
-
-	spin_unlock_irqrestore(&ss->slock, flags);
-}
-
-void hs_task_func(unsigned long d)
-{
-	struct handshake_struct *hs = (struct handshake_struct *)d;
-	int count;
-	struct pti_subsys *ss;
-	struct hlist_node *node;
-
-
-	for(count = 0; count < NETL_SUBSYS_HASH; count++){
-		if(hlist_empty(&hs->hhash[count])){
-			continue;
-		}
-		hlist_for_each_entry(ss, node, &hs->hhash[count], snode){
-		/* Need a better way findng out subsystem with job pending */
-			check_and_set_int_flags(ss);
-			subsys_poll(ss);
-		}
-	}
-	return;
-}
-/*
- * Polling function
- *
- * @work	: ss->swork
- */
-void subsys_poll(struct pti_subsys *d)
-{
-	unsigned long flags;
-	struct pti_subsys *ss = (struct pti_subsys *)d;
-
-	spin_lock_irqsave(&ss->slock, flags);
-	if(ss->flags & SUBSYS_FLAGS_RX_DISABLED){
-		spin_unlock_irqrestore(&ss->slock, flags);
-		goto rx_done;
-	}
-	if(ss->flags & SUBSYS_FLAGS_RX_PENDING){
-		if(ss->flags & SUBSYS_FLAGS_RX){
-			/* running and pending; clear flag */
-			ss->flags &= ~SUBSYS_FLAGS_RX_PENDING;
-			spin_unlock_irqrestore(&ss->slock, flags);
-		}else{
-			/* Rx not running and pending. Run */
-			ss->flags |= SUBSYS_FLAGS_RX;
-			spin_unlock_irqrestore(&ss->slock, flags);
-			subsys_poll_rx(ss);
-		}
-	}else{
-		spin_unlock_irqrestore(&ss->slock, flags);
-	}
-rx_done:
-	spin_lock_irqsave(&ss->slock, flags);
-	if(ss->flags & SUBSYS_FLAGS_TX_DISABLED){
-		spin_unlock_irqrestore(&ss->slock, flags);
-		goto tx_done;
-	}
-	if(ss->flags & SUBSYS_FLAGS_TX_PENDING){
-		if(ss->flags & SUBSYS_FLAGS_TX){
-			/* running and pending; clear flag and reschedule self */
-			ss->flags &= ~SUBSYS_FLAGS_TX_PENDING;
-			spin_unlock_irqrestore(&ss->slock, flags);
-		}else{
-			/* Tx not running and pending. Run */
-			ss->flags |= SUBSYS_FLAGS_TX;
-			spin_unlock_irqrestore(&ss->slock, flags);
-			subsys_poll_tx(ss);
-		}
-	}else{
-		spin_unlock_irqrestore(&ss->slock, flags);
-	}
-tx_done:
-	return;
-}
-
-/*
- * Handles Tx complete interrupt
- *
- * @work	: work struct
- */
-void subsys_poll_tx(struct pti_subsys *ss)
-{
-	struct desc_ring *txr;
-	unsigned long fl_rng;
-	volatile u32 tail;
-	volatile u32 dmastat;
-	int loops;
-	struct descriptor *d;
-	volatile dma_addr_t dmaddr;
-	volatile dma_addr_t dm_old;
-	u32 tmp;
-
-	txr = ss->txring;
-	spin_lock_irqsave(&txr->rng_lock, fl_rng);
-	tail = pti_pci_read32((void *)txr->tail);
-	loops = (NETL_NR_DESC + tail - txr->end) % NETL_NR_DESC;
-	/* We loop from txr->end (incl) to tail (excl). As a result, at the end
-	 * of the loop, we would have freed all buffers with DMA complete and
-	 * reach
-	 * 1. head == tail == txr->end : Empty ring
-	 * 2. head != tail == txr->end : partially full ring
-	 * (valid data (DMA incompl by the device).
-	 * In 1., if data gets added, we start again from txr->end(incl)
-	 * In 2., we must begin processing from 'txr->end` because DMA can be
-	 * under progress and can get completed anytime
-	 */
-	while(loops--){
-		//PDEBUG("loops = %d, end = %#x, tail = %#x\n", loops+1, txr->end, tail);
-		BUG_ON(txr->end == tail);
-		d = &txr->pdesc[txr->end];
-		dmastat = pti_pci_read32((void *)&d->pci_desc->dma_stat);
-		if(is_dma_set(dmastat)){
-			spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-			PERROR("Error. DMA set in Tx complete buf %#x\n", d->idx);
-			dump_desc_ring(NULL, txr, 1);
-			// BUG_ON(is_dma_set(dmastat));
-			return;		/* No need, BUG() panics */
-		}
-		dmaddr = pti_pci_read64((void *)&d->pci_desc->dma_addr);
-		pci_unmap_single(ss->hs->p_dev, dmaddr, d->len, DMA_TO_DEVICE);
-		pti_pci_write64(0, (void *)&d->pci_desc->dma_addr);
-		pti_pci_write32(0, (void *)&d->pci_desc->dma_len);
-		pti_pci_write32(0, (void *)&d->pci_desc->dma_stat);
-#ifdef NETL_ERR_DEBUG
-		/* This is for debugging */
-		dm_old = pti_pci_read64((void *)&d->pci_desc->dma_addr);
-		if(dm_old != 0){
-			PERROR("W 0, R %#llx\n", dm_old);
-		}
-		if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_stat)) != 0){
-			PERROR("W %#x, R %#x\n", 0, tmp);
-		}
-		if((tmp = pti_pci_read32((void *)&d->pci_desc->dma_len)) != 0){
-			PERROR("W %#x, R %#x\n", 0, tmp);
-		}
-#endif
-		txr->end = INCR_CEIL(txr->end);
-		free_page(d->buf);
-		d->buf = 0;
-		d->len = 0;
-		txr->nfree++;
-		//PDEBUG("nfree = %#x\n", d->pring->nfree);
-	}
-	spin_unlock_irqrestore(&txr->rng_lock, fl_rng);
-
-	spin_lock_irqsave(&ss->slock, fl_rng);
-	ss->flags &= ~SUBSYS_FLAGS_TX;
-	ss->flags &= ~SUBSYS_FLAGS_TX_PENDING;
-	spin_unlock_irqrestore(&ss->slock, fl_rng);
-
-	/* Wake up any processes sleeping on ss->wrq */
-	//PDEBUG("Wake up process\n");
-	wake_up_interruptible(&ss->wrq);
-	tail = pti_pci_read32((void *)txr->tail);
-	loops = (NETL_NR_DESC + tail - txr->end) % NETL_NR_DESC;
-	if(loops > 0){
-		tasklet_schedule(&ss->hs->hs_stask);
-	}
-	return;
-}
-/*
- * Polling function for rx complete
- *
- * @work	: ss->swork
- */
-static void subsys_poll_rx(struct pti_subsys *ss)
-{
-	struct desc_ring *rxr;
-	unsigned long fl_rng;
-	volatile u32 head, tmp, dma_stat;
-	int loops;
-
-	rxr = ss->rxring;
-	spin_lock_irqsave(&rxr->rng_lock, fl_rng);
-	head = pti_pci_read32((void *)rxr->head);
-	loops = (NETL_NR_DESC + head - rxr->start) % NETL_NR_DESC;
-	//PDEBUG("LOOPS = %d, HEAD = %#x, START = %#x\n", loops, head, rxr->start);
-	while(loops--){
-		//PDEBUG("loops = %d, head = %#x, start = %#x\n", loops, head, rxr->start);
-		BUG_ON(head == rxr->start);
-		dma_stat = pti_pci_read32((void *)&rxr->pdesc[rxr->start].pci_desc->dma_stat);
-		if(dma_stat == 0xFFFFFFFF){
-//			PDEBUG("PCI read fail %llx\n", (void *)&rxr->pdesc[rxr->start].pci_desc->dma_stat);
-			spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-			return;
-		}
-		/* If empty, head = start, loops == 0 and does not enter this
-		 * loop. If full, INCR_CEIL(head) == rxr->start */
-		if(is_dma_set(dma_stat)){
-			PERROR("DMA under progress, idx = %#x, dma_stat = %#x\n", rxr->start, dma_stat);
-			//dump_desc_ring(NULL, rxr, 1);
-			spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-			return;
-		}
-		tmp = rxr->start;
-		rxr->start = INCR_CEIL(rxr->start);
-		/* call receive complete handler */
-		host_def_rx_cmpl(&rxr->pdesc[tmp]);
-	}
-	spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-
-	/* recalculate head and if loops > 0, reschedule ourself */
-	spin_lock_irqsave(&ss->slock, fl_rng);
-	ss->flags &= ~SUBSYS_FLAGS_RX;
-	ss->flags &= ~SUBSYS_FLAGS_RX_PENDING;
-	spin_unlock_irqrestore(&ss->slock, fl_rng);
-	head = pti_pci_read32((void *)rxr->head);
-	loops = (NETL_NR_DESC + head - rxr->start) % NETL_NR_DESC;
-	if(loops > 0){
-		tasklet_schedule(&ss->hs->hs_stask);
-	}
-	//PDEBUG("Exiting\n");
-	return;
-}
-
-void temp_int_func(struct work_struct *work)
-{
-	struct handshake_struct *hs = container_of(
-		work, struct handshake_struct, temp_int_work.work);
-	unsigned long flags;
-
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	host_msi_handler(0, hs);
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-	schedule_delayed_work(&hs->temp_int_work, HZ);
-}
-#ifdef NETL_TARGET_XLP
-/*
- * Sets up host irqs.
- * Currently handles only MSI.
- */
-int setup_host_irq(struct handshake_struct *hs)
-{
-	__label__ setup_linex, setup_msi;
-	int ret;
-
-	hs->msix.entry = 0;
-	ret = pci_enable_msix(hs->p_dev, &hs->msix, 1);
-	if (ret < 0) {
-		PDEBUG("NO MSI-X support. Trying MSI\n");
-		goto setup_msi;
-	}
-	hs->msi_flag = NETL_MSIX_ENABLE;
-	ret = request_irq(hs->msix.vector, host_msi_handler, 0, NETL_DRIVER, hs);
-	if (ret) {
-		PERROR("MSI-X request_irq failed for %#x\n", hs->msix.vector);
-		pci_disable_msix(hs->p_dev);
-		return ret;
-	}
-	return 0;
-setup_msi:
-	ret = pci_enable_msi(hs->p_dev);
-	if(ret < 0){
-		PDEBUG("No MSI. Falling back to INTX\n");
-		goto setup_linex;
-	}
-	ret = request_irq(hs->p_dev->irq, host_msi_handler, 0, NETL_DRIVER, hs);
-	if(ret){
-		PERROR("MSI request_irq failed for %#x\n", hs->p_dev->irq);
-		pci_disable_msi(hs->p_dev);
-		return ret;
-	}
-	hs->msi_flag = NETL_MSI_ENABLE;
-	return 0;
-setup_linex:
-	ret = request_irq(hs->p_dev->irq, host_msi_handler, 0, NETL_DRIVER, hs);
-	if(ret){
-		PERROR("LINE-X request_irq failed for %#x\n", hs->p_dev->irq);
-		return ret;
-	}
-	hs->msi_flag = NETL_INTX_ENABLE;
-	return 0;
-}
-#else
-int setup_host_irq(struct handshake_struct *hs)
-{
-	schedule_delayed_work(&hs->temp_int_work, 5 * HZ);
-	return 0;
-}
-#endif
-
-/*
- * PCI(e) device probe function
- *
- * @pdev	: pci dev structure of this device
- * @id		: device id list
- */
-static int netl_phnx_generic_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	int err;
-	unsigned long base;
-	u32 req_space, da_size;
-	struct handshake_struct *hs = NULL;
-
-	hs = kzalloc(sizeof(struct handshake_struct), GFP_KERNEL);
-	PDEBUG("ALLOCATED HS = %p\n", hs);
-	if(!hs){
-		return -ENOMEM;
-	}
-	da_size = DESC_ARRAY_SIZE(NETL_NR_DESC);
-	req_space = PTI_ADDR_OFFSET + 4 * sizeof(u32) +  da_size * 2 * NETL_MAX_SUBSYS;
-	//PDEBUG("Probing device\n");
-	hs->p_dev = pdev;
-	/* list_dev has 0 or more entries. Allocate this device now */
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
-		PERROR("No memory resource in BAR\n");
-		err = ENODEV;
-		goto err_return;
-	}
-	err = pci_request_region(pdev, 0, NETL_DRIVER);
-	if (err) {
-		PERROR("Cannot obtain PCI resources, aborting.");
-		err = ENODEV;
-		goto err_return;
-	}
-	base = pci_resource_start(pdev, 0);
-	if(base == 0){
-		PERROR("Cannot allocate memory resource in BAR\n");
-		goto resource_err;
-	}
-	iomem_start = ioremap_nocache(base, pci_resource_len(pdev, 0));
-	hs->start = (volatile void *)iomem_start + PTI_ADDR_OFFSET;
-	pci_set_drvdata(pdev, (void *)hs);
-	if(hs->start == NULL){
-		PERROR("IOREMAP failed on resource in BAR\n");
-		goto resource_err;	/* this is RIGHT */
-	}
-	hs->pci_len = pci_resource_len(pdev, 0);
-	if(hs->pci_len < req_space){
-		PERROR("pci_len = %lx, req_space = %x. Not enough memory allocated\n", hs->pci_len, req_space);
-		goto shmem_fail;
-	}
-	if(init_handshake_struct(hs)){
-		PERROR("Failed to handshake\n");
-		goto shmem_fail;
-	}
-	// PDEBUG("start = 0x%p, len = %#lx\n", hs->start, hs->pci_len);
-	if(netl_register_chrdev(hs) != 0){
-		PDEBUG("Registering chr device fail\n");
-		goto reg_dev_fail;
-	}
-	netl_add_dev(hs);
-	if ((err = pci_enable_device(pdev))) {
-		PERROR("Cannot enable PCI device, aborting.");
-		goto pci_en_fail;
-	}
-	pci_set_master(pdev);
-	schedule_delayed_work(&hs->hs_work, HZ);
-	return err;
-
-pci_en_fail:
-	// TODO Need to check all these labels
-// pci_reg_fail:
-	cdev_del(&hs->hs_cdev);
-// dev_init_fail:
-reg_dev_fail:
-	dealloc_all_subsys(hs);
-shmem_fail:
-	iounmap(hs->start);
-resource_err:
-	pci_release_region(pdev, 0);
-err_return:
-	pci_set_drvdata(pdev, NULL);
-	kfree(hs->hhash);
-	kfree(hs);
-	PDEBUG("Failed return");
-	return err;
-}
-
-/*
- * Adds a new device to global list of netl_device
- *
- * @p : device to be added
- */
-void netl_add_dev(struct handshake_struct *p)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev_list->lock, flags);
-	p->hsid = dev_list->count;
-	dev_list->count++;
-	list_add(&dev_list->head, &p->dhead);
-	spin_unlock_irqrestore(&dev_list->lock, flags);
-	return;
-}
-
-void netl_rm_dev(struct handshake_struct *p)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&dev_list->lock, flags);
-	list_del(&p->dhead);
-	dev_list->count--;
-	spin_unlock_irqrestore(&dev_list->lock, flags);
-	return;
-}
-
-int get_hs(struct handshake_struct **res)
-{
-	int idx = 0;
-	struct handshake_struct *cur, *n;
-
-	list_for_each_entry_safe(cur, n, &dev_list->head, dhead){
-		if(cur->hsid == idx){
-			*res = cur;
-			return 0;
-		}
-	}
-	return -ENODEV;
-}
-EXPORT_SYMBOL(get_hs);
-
-void __exit netl_pti_host_uninit(void)
-{
-	pci_unregister_driver(&netl_pci_driver);
-	destroy_workqueue(ss_workq);
-	kfree(dev_list);
-	PDEBUG("Exit complete\n");
-}
-
-int __init netl_pti_host_init(void)
-{
-	int ret = 0;
-
-	PDEBUG("Compiled on %s %s\n", __DATE__, __TIME__);
-	dev_list = kzalloc(sizeof(struct netl_device), GFP_KERNEL);
-	if((dev_list == NULL)){
-		return ENOMEM;
-	}
-	spin_lock_init(&dev_list->lock);
-	INIT_LIST_HEAD(&dev_list->head);
-	ss_workq = create_workqueue("ss_workq");
-	BUG_ON(!ss_workq);
-	//PDEBUG("Work queue created\n");
-	dev_list->count = 0;	/* setting explicitly */
-	ret = pci_register_driver(&netl_pci_driver);
-	if(ret < 0){
-		PDEBUG("Failed to register driver\n");
-		netl_pti_host_uninit();
-		return -1;
-	}
-PERROR("pti_subsys = %ld, desc_ring = %ld, descriptor = %ld, _desc_pci = %ld, rx=%ld\n", sizeof(struct pti_subsys), sizeof(struct desc_ring), sizeof(struct descriptor), sizeof(struct _desc_pci), sizeof(struct rx_struct));
-PERROR("host init success\n");
-	return 0;
-}
-module_init(netl_pti_host_init);
-module_exit(netl_pti_host_uninit);
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/netlogic/pcie-offload/include/chunking-api.h b/drivers/misc/netlogic/pcie-offload/include/chunking-api.h
deleted file mode 100644
index a1e4276..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/chunking-api.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef CHUNKING_API_H
-#define CHUNKING_API_H
-
-/*
- * NetL Digest APIs
- */
-#include <sys/types.h>
-#include <linux/types.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/uio.h>
-#include <sys/uio.h>
-#include <signal.h>
-#include "mgmt.h"
-#include "netl_pti.h"
-
-
-struct split_request {
-	uint32_t req_id; /* OUT: Returned by the API library and used
-			for polling this split request */
-	struct iovec* in_data; /* IN: array of input data to split
-			and hash.*/
-	int in_cnt; /* IN: number of in_data array elements */
-	int flags; /* IN: options to be passed to the remote DRE module */
-	int max_chunk_count; /* IN: max number of chunks that can be
-			returned in the result. */
-	struct chunking_result* result; /* OUT: result of this split
-			request */
-};
-int hwch_init(void* arg, size_t len);
-int hwch_open(void* open_arg, size_t len, uint64_t* ctx_handle);
-int hwch_split_request(uint64_t ctx_handle, struct split_request* split_req);
-int hwch_split_response(uint64_t ctx_handle, struct split_request **split_req);
-int hwch_get_state(uint64_t ctx_handle, void* state, size_t len);
-int hwch_set_state(uint64_t ctx_handle, void* state, size_t len);
-int hwch_select(uint64_t* ctx_handles, int count);
-int hwch_close(uint64_t ctx_handle);
-#endif
diff --git a/drivers/misc/netlogic/pcie-offload/include/chunking-lib.c b/drivers/misc/netlogic/pcie-offload/include/chunking-lib.c
deleted file mode 100644
index bced0b3..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/chunking-lib.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include "../../include/chunking-api.h"
-#include "../../include/netl_pti_char.h"
-
-/* control socket, initialized once */
-struct chunking_result *split(struct iovec* input_iovec, uint32_t n_iovec, struct comm_context *ctx, struct init_params *ip, struct hwch_params *hp);
-
-/* These are serialization buffers
- * In client/server swap them */
-struct chunking_result *process_rx_data(struct comm_context *, struct lib_chunk_header *);
-int send_chunk_info(struct comm_context *, struct lib_chunk_header *, struct chunking_result *);
-void print_sig(FILE *fptr, unsigned char *);
-int populate_lib_chunk_header(struct split_request *sr, struct mgmt_msg *m);
-
-struct sr_elem{
-	struct list_head head;
-	struct chunking_result *cr;
-	uint32_t req_id;
-};
-
-/*
- * Sends header data first
- *
- * @sock: socket on which we send data
- * @buf: buffer where data recide
- * @len: length of data to send
- */
-static int netl_msg_tx(int sock, void *buf, uint32_t len)
-{
-	uint32_t sent = 0;
-	char *start = (char *)buf;
-	int ret;
-	while(sent < len){
-		//DPRINT("sock = %x, Sent = %d len = %d\n", sock, sent, len);
-		if((ret = write(sock, start + sent, len-sent)) < 0){
-			perror("Socket write failed\n");
-			return ret;
-		}
-		sent += ret;
-	}
-	return sent;
-}
-
-
-int send_coalesced_ci(struct comm_context *ctx, struct chunking_result *cr)
-{
-	struct list_head *elem;
-	struct chunk_info_elem ce, *p;
-	char buf[SER_BUF_LEN];
-	int top = 0;
-
-	for_each_list(&cr->head, elem){
-		memset(&ce, 0, sizeof(struct chunk_info_elem));
-		p = container_of(elem, struct chunk_info_elem *, head);
-		memcpy(ce.cid.fp, p->cid.fp, FP_SIZE);
-		memcpy(ce.cid.md5, p->cid.md5, MD5_SIZE);
-		ce.cid.offset = htonl(p->cid.offset);
-		ce.cid.size = htonl(p->cid.size);
-		ce.cid.flags = htonl(p->cid.flags);
-
-		if (top + sizeof(chunk_info_data) < SER_BUF_LEN){
-			memcpy(buf + top, &ce.cid, CTRL_MSG_SIZE);
-			top += sizeof(chunk_info_data);
-		} else {
-			write(ctx->data_fd, buf, top);
-			memset(buf, 0, SER_BUF_LEN);
-			top = 0;
-		}
-	}
-	return 0;
-}
-
-static int read_split_to_cis(struct comm_context *ctx, struct chunking_result *cr)
-{
-	int len = sizeof(struct chunk_info_data);
-	int did = 0;
-	char buf[SER_BUF_LEN];
-	int once = (int)(SER_BUF_LEN/len);
-	int count;
-	struct chunk_info_data rdcd;
-	struct chunk_info_elem *h;
-	char *st;
-
-	while (did < cr->rsp.chunk_count) {
-		count = ((cr->rsp.chunk_count - did) > once) ?
-			once : (cr->rsp.chunk_count - did);
-		memset(buf, 0, SER_BUF_LEN);
-		read(ctx->data_fd, buf, (count * len));
-		did += count;
-		st = buf;
-		while (count--) {
-			memcpy(&rdcd, st, len);
-			st += len;
-			h = (struct chunk_info_elem *) malloc(sizeof(struct chunk_info_elem));
-			/* Error check TODO */
-			INIT_LIST_HEAD(&h->head);
-			memcpy(h->cid.fp, rdcd.fp, FP_SIZE);
-			memcpy(h->cid.md5, rdcd.md5, MD5_SIZE);
-			h->cid.offset = ntohl(rdcd.offset);
-			h->cid.size = ntohl(rdcd.size);
-			h->cid.flags = ntohl(rdcd.flags);
-			list_add_tail(&cr->head, &h->head);
-		}
-	}
-	return 0;
-}
-
-/*
- * receives messages sent using netl_msg_tx
- *
- */
-static struct mgmt_msg *rx_process_message(struct comm_context *ctx)
-{
-	int ret;
-	struct mgmt_msg rx_msg, *ret_msg;
-
-	DPRINT("Starting rx process\n");
-	ret_msg = (struct mgmt_msg *) malloc(CTRL_MSG_SIZE);
-	if(ret_msg == NULL){
-		return NULL;
-	}
-	if((ret = read(ctx->data_fd, &rx_msg, CTRL_MSG_SIZE)) < 0){
-		free(ret_msg);
-		perror("Read failure");
-		return NULL;
-	}
-	if(ret == 0){
-		DPRINT("EOF reached ... \n");
-		free(ret_msg);
-		return NULL;
-	}
-	/* We have a block of data now. convert it into host byte order */
-	cp_mgmt_msg_BO(ret_msg, &rx_msg, ntohl);
-	return ret_msg;
-}
-
-/*
- * this is the main processing loop for server.
- * this one initializes some params and loops for ever
- *
- * no params
- */
-void server_proc_loop(struct comm_context *ctx)
-{
-	struct mgmt_msg *msg_rx;
-	struct chunking_result *cr;
-	struct timeval start, med, end;
-	long double s, m, e, d;
-
-	/* intial global params are set. now loop for channel requests */
-	while(1){
-		DPRINT("Starts loop...\n");
-		msg_rx = rx_process_message(ctx);
-		if(msg_rx == NULL){
-			return;
-		}
-		/* process various type messages */
-		switch(msg_rx->type){
-		case MSG_CHUNK_HEADER:
-			/* here we do not send any response back
-			 * We wait for data to show up */
-			gettimeofday(&start, NULL);
-			cr = process_rx_data(ctx, &msg_rx->lch);
-			gettimeofday(&med, NULL);
-			send_chunk_info(ctx, &msg_rx->lch, cr);
-			gettimeofday(&end, NULL);
-
-			s = start.tv_sec * 1000000 + start.tv_usec;
-			m = med.tv_sec * 1000000 + med.tv_usec;
-			e = end.tv_sec * 1000000 + end.tv_usec;
-
-			d = (m - s)/1000000;
-			fprintf(stderr, "processing %.8Lf sec\n", d);
-			d = (e - m)/1000000;
-			fprintf(stderr, "Sending %.8Lf sec\n", d);
-			break;
-		default:
-			DPRINT("Invalid messages\n");
-			break;
-		}
-	}
-}
-
-int Read(int sock, void *buf, int total)
-{
-	int ret = 0, rd = 0, bal = total;
-	char *start = (char *)buf;
-
-	while(rd < total){
-		ret = read(sock, (void *)start, bal);
-		bal -= ret; rd += ret; start += ret;
-	}
-	return total;
-}
-
-struct chunking_result *process_rx_data(struct comm_context *ctx, struct lib_chunk_header *lch)
-{
-	uint32_t tot_read = 0;
-	int ret;
-	struct iovec *iov;
-	uint32_t iov_num = (lch->num_bytes + SER_BUF_LEN - 1) / SER_BUF_LEN;
-	uint32_t to_read, i;
-	struct chunking_result *result;
-	struct timeval start, end;
-	long double s, e, d;
-
-	iov = (struct iovec *)malloc(iov_num * sizeof(struct iovec));
-	if(iov == NULL){
-		/* TODO */
-		return NULL;
-	}
-	gettimeofday(&start, NULL);
-	for(i = 0; i < iov_num; i++){
-		iov[i].iov_base = malloc(SER_BUF_LEN);
-		iov[i].iov_len = SER_BUF_LEN;
-		to_read = (lch->num_bytes - tot_read) > SER_BUF_LEN ?
-			SER_BUF_LEN : (lch->num_bytes - tot_read);
-		ret = Read(ctx->data_fd, iov[i].iov_base, to_read);
-		if(ret < 0){
-			DPRINT("Error in reading\n");
-			return NULL;
-		} else if(ret == 0){
-			DPRINT("EOF in socket ...\n");
-			break;
-		}
-		tot_read += ret;
-		//DPRINT("read %d bytes in %d iovecs\n", tot_read, i+1);
-	}
-	gettimeofday(&end, NULL);
-	d = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));
-	d /= (long double)1000000;
-	printf("Total %ld bytes read in %.8Lf seconds. Rx Speed %.8Lf MBps\n",
-			tot_read, d, (tot_read/(d * 1024 * 1024)));
-	/* supply this parameter to split constructor */
-	gettimeofday(&start, NULL);
-	result = split(iov, iov_num, ctx, &ctx->ip.glbp, &ctx->hwchp.chnp);
-	gettimeofday(&end, NULL);
-
-	d = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));
-	d /= (long double)1000000;
-	printf("Split took %.8Lf seconds for %ld bytes. %.8Lf MBps\n",
-			d, tot_read, (tot_read/(d * 1024 * 1024)));
-	for (i = 0; i< iov_num; i++) {
-		free(iov[i].iov_base);
-	}
-	free(iov);
-	return result;
-}
-
-int send_chunk_info(struct comm_context * ctx, struct lib_chunk_header *lch,
-		struct chunking_result *cr)
-{
-	uint32_t len;
-	struct mgmt_msg h2send;
-	struct list_head *elem;
-	struct chunk_info_data cd;
-	struct chunk_info_elem *p;
-	char buf[SER_BUF_LEN];
-	int top = 0;
-
-	assert(SER_BUF_LEN > sizeof(struct chunk_info_data));
-	memset(&h2send, 0, CTRL_MSG_SIZE);
-	h2send.type = ntohl(MSG_CHUNK_RESPONSE);
-	h2send.msgid = 0;
-	h2send.crh.rem_chunk_count = htonl(cr->rsp.rem_chunk_count);
-	h2send.crh.chunk_count = htonl(cr->rsp.chunk_count);
-	memcpy(h2send.crh.md5sum, cr->rsp.md5sum, MD5_SIZE);
-	netl_msg_tx(ctx->data_fd, (char *)&h2send, CTRL_MSG_SIZE);
-	len = sizeof(struct chunk_info_data);
-
-	/* Now, coalesce the ci-s and send out */
-	len = sizeof(struct chunk_info_data);
-	for_each_list(&cr->head, elem){
-		memset(&cd, 0, len);
-		p = container_of(elem, struct chunk_info_elem *, head);
-		memcpy(cd.fp, p->cid.fp, FP_SIZE);
-		memcpy(cd.md5, p->cid.md5, MD5_SIZE);
-		cd.offset = htonl(p->cid.offset);
-		cd.size = htonl(p->cid.size);
-		cd.flags = htonl(p->cid.flags);
-
-		if (top + len < SER_BUF_LEN){
-			memcpy(buf + top, &cd, len);
-			top += len;
-		}
-		/* We have at least one cd written onto buffer
-		 * if we can write one more, go with next elem, else
-		 * write current buffer out */
-		if (top + len >= SER_BUF_LEN){
-			write(ctx->data_fd, buf, top);
-			memset(buf, 0, SER_BUF_LEN);
-			top = 0;
-		}
-	}
-	/* We hit the last elem, but buffer not written out because there is
-	 * free space. Check it and push buffer out if required */
-	if(top != 0){
-		write(ctx->data_fd, buf, top);
-	}
-	return 0;
-}
-
-/*
- * Sends data in iovec
- *
- */
-int send_iovec_data(struct comm_context *ctx, struct split_request *sr)
-{
-	int n, sent = 0;
-	struct iovec *iov;
-
-	for(n = 0; n < sr->in_cnt; n++){
-		iov = &sr->in_data[n];
-		/* now send buffer */
-		if((sent = netl_msg_tx(ctx->data_fd, (char *)iov->iov_base,
-						iov->iov_len)) < 0){
-			DPRINT("Failed to send iov\n");
-			return -1;
-		}
-	}
-	return 0;
-}
-
-void print_sig(FILE *fptr, unsigned char *digest)
-{
-	int n, *p = (int *)digest;
-	for(n = 0; n < 4; n++){
-		fprintf(fptr, "%08x", p[n]);
-	}
-	fprintf(fptr, "\n");
-}
-
-struct hw_handle {
-	struct comm_context ctx;
-	struct mgmt_msg hwch_params;
-	struct mgmt_msg init_params;
-	struct chunking_result *cr;
-};
-
-int hwch_init(void *p, size_t len)
-{
-	__label__ init_fail;
-	int ret = 0;
-	int fd;
-	struct mgmt_msg local;
-
-	if (p == NULL) {
-		return 0;
-	}
-	if (((struct mgmt_msg *)p)->type != MSG_INIT_PARAM) {
-		return -EINVAL;
-	}
-	if (len != CTRL_MSG_SIZE) {
-		DPRINT("Requires %d bytes\n", CTRL_MSG_SIZE);
-		return -EINVAL;
-	}
-	cp_mgmt_msg_BO(&local, (struct mgmt_msg *)p, htonl);
-
-	/* Open control connection */
-	fd = open(NETL_FILE_PATH, O_RDWR);
-	if (fd < 0) {
-		perror("File open failed\n");
-		return EFAULT;
-	}
-
-	/* set/modify global control parameters to passed param
-	 * What we do is to pass these params to the other end */
-	ret = write(fd, &local, CTRL_MSG_SIZE);
-	if (ret < 0) {
-		goto init_fail;
-	}
-init_fail:
-	close(fd);
-	return ret;
-}
-
-int hwch_open(void *open_arg, size_t len, uint64_t *hwc)
-{
-	/* Allocate a hw_handle struct and return it */
-	struct comm_context *ctx;
-	int ret;
-	char tmp[NETL_DEVFILE_LEN];
-	struct hwch_params *chp = (struct hwch_params *)open_arg;
-
-	if (chp == NULL) {
-		return -EINVAL;
-	}
-	if (chp->ssid <= 0) {
-		return -EINVAL;
-	}
-	ctx = (struct comm_context *) malloc(sizeof(struct comm_context));
-	if (ctx == NULL) {
-		return -ENOMEM;
-	}
-	sprintf(tmp, "%s%d", NETL_FILE_PATH, chp->ssid);
-	ret = open(tmp, O_RDWR);
-	if (ret == -1) {
-		free(ctx);
-		return -errno;
-	}
-	ctx->data_fd = ret;
-	memcpy(&ctx->hwchp.chnp, chp, sizeof(struct hwch_params));
-	ctx->hwchp.type = MSG_CHANNEL_PARAM;
-	ctx->hwchp.msgid = 0;
-
-	ret = open(NETL_FILE_PATH, O_RDWR);
-	if (ret == -1) {
-		close(ctx->data_fd);
-		free(ctx);
-		return -errno;
-	}
-	write(ret, &ctx->hwchp, CTRL_MSG_SIZE);
-	close(ret);
-	*((uint64_t *)hwc) = (uint64_t)ctx;
-	return 0;
-}
-
-int hwch_close(uint64_t ctx_handle)
-{
-	struct comm_context *ctx = (struct comm_context *)ctx_handle;
-	close(ctx->data_fd);
-	free(ctx);
-	return 0;
-}
-
-int hwch_split_request(uint64_t ctx_handle, struct split_request* split_req)
-{
-	struct mgmt_msg *rsp;
-	struct mgmt_msg lch;
-	struct chunking_result *cr = (struct chunking_result *) malloc(sizeof(struct chunking_result));
-	struct comm_context *ctx = (struct comm_context *)ctx_handle;
-	struct timeval start, end;
-	long double d;
-
-	if (cr == NULL) {
-		return -ENOMEM;
-	}
-	INIT_LIST_HEAD(&cr->head);
-	populate_lib_chunk_header(split_req, &lch);
-	netl_msg_tx(ctx->data_fd, &lch, CTRL_MSG_SIZE);
-	gettimeofday(&start, NULL);
-	send_iovec_data(ctx, split_req);
-	gettimeofday(&end, NULL);
-	d = ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec));
-	d /= (long double)1000000;
-	printf("Total %ld bytes sent in %.8Lf seconds. Tx Speed %.8Lf MBps\n",
-			htonl(lch.lch.num_bytes), d, ((long double)htonl(lch.lch.num_bytes)/(d * 1024 * 1024)));
-
-	rsp = rx_process_message(ctx);
-	memcpy(&cr->rsp, &rsp->crh, sizeof(struct chunk_rsp_header));
-	/* response contains #bytes to read for chunks */
-	read_split_to_cis(ctx, cr);
-	((struct comm_context *)ctx_handle)->cr = cr;	/* store away */
-	return 0;
-}
-
-/* TBD */
-int hwch_split_response(uint64_t ctx_handle, struct split_request** split_req)
-{
-	struct comm_context *ctx = (struct comm_context *)ctx_handle;
-	struct list_head *elem;
-	/* Shoudl check for max_chunk_count TODO */
-	(*split_req)->result = ctx->cr;
-	ctx->cr = NULL;
-	return 0;
-}
-
-int hwch_free_chunking_result(struct chunking_result *cr)
-{
-	/* TODO */
-	return 0;
-}
-
-int new_request_id(void)
-{
-	return 0;
-}
-
-int populate_lib_chunk_header(struct split_request *sr, struct mgmt_msg *m)
-{
-	int i;
-	int tot = 0;
-
-	for(i = 0; i < sr->in_cnt; i++){
-		tot += sr->in_data[i].iov_len;
-	}
-	DPRINT("Total bytes in iov = %d\n", tot);
-	sr->req_id = new_request_id();
-	sr->result = NULL;
-
-	m->type = htonl(MSG_CHUNK_HEADER);
-	m->msgid = 0;
-	m->lch.request_id = htonl(sr->req_id);
-	m->lch.flags = htonl(sr->flags);
-	m->lch.max_chunk_count = htonl(sr->max_chunk_count);
-	m->lch.num_bytes = htonl(tot);
-	return 0;
-}
-
-#ifndef SERVER
-/* Dummy function
- * Do not remove. Host will not compile */
-struct chunking_result *split(struct iovec* input_iovec, uint32_t n_iovec,
-		struct comm_context *ctx, struct init_params *ip,
-		struct hwch_params *hp)
-{
-       return NULL;
-}
-#endif
diff --git a/drivers/misc/netlogic/pcie-offload/include/mgmt.h b/drivers/misc/netlogic/pcie-offload/include/mgmt.h
deleted file mode 100644
index 9ac1f98..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/mgmt.h
+++ /dev/null
@@ -1,262 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef MGMT_H
-#define MGMT_H
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/uio.h>
-#include <pthread.h>
-#include <getopt.h>
-#include <sys/wait.h>
-#include <sys/time.h>
-#include <assert.h>
-
-#include "netl_pti_char.h"
-#include "chunking-api.h"
-
-#define NETL_DEVFILE_LEN	64
-#define NETL_FILE_PATH		"/dev/netl_char"
-#define NETL_MAX_CHANNELS	0x20
-#define NETL_CLIENT_PATH	"./client"
-#define NETL_SERVER_PATH	"./server"
-
-#ifdef DEBUG
-#define DPRINT(msg, args...)\
-do{\
-	fprintf(stderr, "%s()@%s:%d " msg, __func__,__FILE__, __LINE__, ##args);\
-} while(0)
-#else
-#define DPRINT(msg, args...)
-#endif
-
-#define container_of(ptr, type, member)\
-({\
-	type t1 = (type)(((char *)ptr) - (char *)&((type)0)->member);\
-	t1;\
-})
-
-#define SER_BUF_LEN	4096
-#define FP_SIZE		16
-#define MD5_SIZE	16
-
-struct list_head { struct list_head *next, *prev; };
-static inline void INIT_LIST_HEAD(struct list_head *list)
-{
-	list->next = list;
-	list->prev = list;
-}
-
-
-static inline void list_init(struct list_head *ptr)
-{
-	ptr->next = ptr->prev = ptr;
-}
-
-#define list_add_tail(head, n)\
-do {\
-	(n)->next = (head);\
-	(n)->prev = (head)->prev;\
-	(head)->prev = (n);\
-	(n)->prev->next = (n);\
-} while(0)
-
-#define list_remove_elem(head, r)\
-do{\
-	if((r) != head){\
-		(r)->next->prev = (r)->prev;\
-		(r)->prev->next = (r)->next;\
-		(r)->next = (r)->prev = NULL;\
-	}\
-}while(0)
-
-#define for_each_list(head, tmp)\
-	for((tmp) = (head)->next; (tmp) != (head) && (tmp) != NULL; (tmp) = (tmp)->next)
-
-enum mgmt_msg_type {
-	MSG_CHANNEL_PARAM	= 0X100,
-	MSG_INIT_PARAM,
-	MSG_STATUS_PARAM,
-	MSG_CHUNK_HEADER,
-	MSG_CHUNK_RESPONSE,
-};
-
-struct init_params {		/* parameters passed to init fn. */
-	uint32_t min_chunk_size;
-	uint32_t max_chunk_size;
-};
-
-struct hwch_params {
-	uint32_t ssid;
-	uint32_t rabin32_poly;
-	uint32_t rabin32_window_size;
-	uint32_t sig_size;
-	uint32_t md5_size;
-	uint32_t flags;
-} __attribute__((packed));
-
-struct response {
-	uint32_t status;
-} __attribute__((packed));
-
-struct lib_chunk_header {
-	uint32_t request_id;
-	uint32_t flags;
-	uint32_t max_chunk_count;
-	uint32_t num_bytes;
-}__attribute__((packed));
-
-struct chunk_rsp_header {	/* struct chunking result minus list_head */
-	int rem_chunk_count;
-	int chunk_count;
-	unsigned char md5sum[MD5_SIZE];
-}__attribute__((packed));
-
-struct chunk_info_data {
-	unsigned char fp[FP_SIZE];
-	unsigned char md5[MD5_SIZE];
-	int offset; /* offset from the first byte of the first iovec buffer */
-	int size;
-	int flags;
-}__attribute__((packed));
-
-struct chunk_info_elem {
-	struct chunk_info_data cid;
-	struct list_head head;
-}__attribute__((packed));
-
-struct chunking_result{
-	struct chunk_rsp_header rsp;
-	struct list_head head;
-};
-
-struct mgmt_msg {
-	/* This must have a predefined size
-	 * Eg. 64 bytes
-	 */
-	uint32_t type;
-	uint32_t msgid;
-	union {
-		/* This is the channel parameters */
-		struct hwch_params chnp;
-		/* Global parameters : for init only */
-		struct init_params glbp;
-		/* Response from a device/host */
-		struct response rsp;
-		/* lib chunk header */
-		struct lib_chunk_header lch;
-		/* chunk response */
-		struct chunk_rsp_header crh;
-		/* Padding so that size is always fixed : 64bytes */
-		uint32_t filler[14]; /* 16 - 2 (type, msgid) */
-	};
-}__attribute__((packed));
-
-struct comm_context {
-	int data_fd;
-	struct mgmt_msg hwchp;
-	struct mgmt_msg ip;
-	struct chunking_result *cr;
-}__attribute__((packed));
-
-typedef uint32_t (*nh_byteorder)(uint32_t);
-static inline void cp_mgmt_msg_BO(struct mgmt_msg *dst, struct mgmt_msg *src, nh_byteorder func)
-{
-	assert(func != NULL);
-	memset(dst, 0, CTRL_MSG_SIZE);
-	dst->msgid = func(src->msgid);
-	dst->type = func(src->type);
-	switch(dst->type){
-	case MSG_CHANNEL_PARAM:
-		dst->chnp.ssid = func(src->chnp.ssid);
-		dst->chnp.rabin32_poly = func(src->chnp.rabin32_poly);
-		dst->chnp.rabin32_window_size = func(src->chnp.rabin32_window_size);
-		dst->chnp.sig_size = func(src->chnp.sig_size);
-		dst->chnp.md5_size = func(src->chnp.md5_size);
-		dst->chnp.flags = func(src->chnp.md5_size);
-		break;
-	case MSG_INIT_PARAM:
-		dst->glbp.min_chunk_size = func(src->glbp.min_chunk_size);
-		dst->glbp.max_chunk_size = func(src->glbp.max_chunk_size);
-		break;
-	case MSG_STATUS_PARAM:
-		dst->rsp.status = func(src->rsp.status);
-		break;
-	case MSG_CHUNK_HEADER:
-		dst->lch.request_id = func(src->lch.request_id);
-		dst->lch.flags = func(src->lch.flags);
-		dst->lch.max_chunk_count = func(src->lch.max_chunk_count);
-		dst->lch.num_bytes = func(src->lch.num_bytes);
-		break;
-	case MSG_CHUNK_RESPONSE:
-		dst->crh.rem_chunk_count = func(src->crh.rem_chunk_count);
-		dst->crh.chunk_count = func(src->crh.chunk_count);
-		memcpy(dst->crh.md5sum, src->crh.md5sum, MD5_SIZE);
-		break;
-	default:
-		break;
-	}
-	return;
-}
-
-static inline void dump_mgmt_msg(struct mgmt_msg *src)
-{
-	DPRINT("src->msgid = %#x\n", src->msgid);
-	DPRINT("src->type = %#x\n", src->type);
-	switch(src->type){
-	case MSG_CHANNEL_PARAM:
-		DPRINT("src->chnp.ssid = %#x\n", src->chnp.ssid);
-		DPRINT("src->chnp.rabin32_poly = %#x\n", src->chnp.rabin32_poly);
-		DPRINT("src->chnp.rabin32_window_size = %#x\n", src->chnp.rabin32_window_size);
-		DPRINT("src->chnp.sig_size = %#x\n", src->chnp.sig_size);
-		DPRINT("src->chnp.md5_size = %#x\n", src->chnp.md5_size);
-		DPRINT("src->chnp.md5_size = %#x\n", src->chnp.md5_size);
-		break;
-	case MSG_INIT_PARAM:
-		DPRINT("src->glbp.min_chunk_size = %#x\n", src->glbp.min_chunk_size);
-		DPRINT("src->glbp.max_chunk_size = %#x\n", src->glbp.max_chunk_size);
-		break;
-	case MSG_STATUS_PARAM:
-		DPRINT("src->rsp.status = %#x\n", src->rsp.status);
-		break;
-	default:
-		break;
-	}
-	return;
-}
-
-#endif
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti.h b/drivers/misc/netlogic/pcie-offload/include/netl_pti.h
deleted file mode 100644
index f0193ca..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti.h
+++ /dev/null
@@ -1,350 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef _NETL_PTI_H
-#define _NETL_PTI_H
-
-
-#define NETL_CONTROL_SUBSYS		0
-#define NETL_DEF_MAX_SUBSYS		8
-#define NETL_BUFSIZE			4096	/*__MUST__ BE PAGE_SIZE */
-#define	NETL_NR_DESC			0x400
-#define NETL_MAX_SUBSYS			0x8
-
-#ifdef __KERNEL__
-#include <linux/types.h>
-#include <linux/spinlock.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/string.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/interrupt.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/signal.h>
-#include <linux/poll.h>
-#include <asm/bitops.h>
-
-#ifdef NETL_PTI_DEVICE
-
-#ifdef CONFIG_NLM_XLP
-#include <asm/netlogic/iomap.h>
-#include <asm/netlogic/cpumask.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/xlp_hal_pic.h>
-#include <hal/nlm_hal.h>
-#include <hal/nlm_hal_macros.h>
-#include <hal/nlm_hal_fmn.h>
-#include <hal/nlm_hal_xlp_dev.h>
-#endif	// CONFIG_NLM_XLP
-
-#endif	// NETL_PTI_DEVICE
-
-#define PTI_ADDR_OFFSET (unsigned long)0x00100000
-
-#define DPRINTK(level,fmt,args...)\
-do{\
-	printk(level "%s()@%s:%d " fmt,__func__, __FILE__, __LINE__, ##args);\
-}while(0)
-#ifndef CONFIG_NLM_XLP	// kludge, replace with fdebug
-#define fdebug(fmt, args...) DPRINTK(KERN_DEBUG, fmt, ##args)
-#endif
-#define PDEBUG(fmt, args...) DPRINTK(KERN_DEBUG, fmt, ##args)
-#define PWARN(fmt, args...)\
-	DPRINTK(KERN_WARNING, fmt, ##args)
-#define PERROR(fmt, args...)\
-	DPRINTK(KERN_ERR, fmt, ##args)
-
-#define PTI_DEV_IRQ		16
-#define DESC_DMA_READY		(0x80000000)
-#define is_dma_set(p)          ((p) & DESC_DMA_READY)
-#define NETL_HOST_SIGNATURE		0x4e45544c	/* NETL */
-#define NETL_DEV_SIGNATURE		0x4e444556	/* NDEV */
-
-extern void raise_host_interrupt(int vec);
-extern int xlp_async_request_dma(uint64_t src, uint64_t dest, uint32_t len,
-			void (*func)(void *,uint64_t),void *data,
-			enum dma_data_direction dir);
-extern u64 setup_pcie_shared_memspace(u64 * len);
-
-struct descriptor;
-struct pti_subsys;
-#define NETL_HS_PARAMSPACE	0x20
-
-#define _pti_pci
-struct _desc_pci{
-	/* descriptor will have two parts
-	 * 1. The portion on the PCI mapped space (This structure)
-	 * 2. The part on the virtual address space (struct descriptor)
-	 *
-	 * PCI access should take care of endianness
-	 * Virtual address access should not take care endianness
-	 */
-	_pti_pci volatile u64 dma_addr;
-	_pti_pci volatile u32 dma_len;
-	_pti_pci volatile u32 dma_stat;
-} __attribute__((packed));
-
-struct descriptor{
-	volatile struct _desc_pci *pci_desc;	/* must be casted to offset*/
-	unsigned long buf;			/* buffer page */
-	u32 len;
-	u64 buf_flag;
-	struct desc_ring *pring;
-	int idx;
-} __attribute__((packed));
-
-/*
- * Descriptor ring structure
- * Has start and end; but they are currently not requried as we have fixed
- * length structure. Nevertheless, we will implement it for sake of abstraction
- */
-
-#define DESC_RING_TYPE_TX_DEV	0x0
-#define DESC_RING_TYPE_RX_DEV	0x1
-#define DESC_RING_TYPE_RX_HOST	0x0
-#define DESC_RING_TYPE_TX_HOST	0x1
-struct desc_ring{
-	_pti_pci volatile u32 *head;	/* ring head, updated by Host Tx */
-	_pti_pci volatile u32 *tail;	/* ring tail, updated by dev Rx */
-	struct descriptor *pdesc;	/* Should be kzalloc-ed */
-	u32 start;			/* In tx int, start freeing from here*/
-	u32 end;			/* unused */
-	u32 nfree;			/* #of free descriptors */
-	struct pti_subsys *ss;
-	spinlock_t rng_lock;
-} __attribute__((packed));
-
-#define SUBSYS_FLAGS_TX			(0x1 << 0)
-#define SUBSYS_FLAGS_TX_DISABLED	(0x1 << 1)
-#define SUBSYS_FLAGS_TX_PENDING		(0x1 << 2)
-#define SUBSYS_FLAGS_RX			(0x1 << 8)
-#define SUBSYS_FLAGS_RX_DISABLED	(0x1 << 9)
-#define SUBSYS_FLAGS_RX_PENDING		(0x1 << 10)
-#define SUBSYS_FLAGS_ORPHANED		(0x1 << 16)
-struct pti_subsys{
-	u32 id;
-	void *priv_data;
-	struct hlist_node snode;
-	struct desc_ring *rxring;
-	struct desc_ring *txring;
-	unsigned long flags;
-	spinlock_t slock;
-	struct handshake_struct *hs;
-	//struct tasklet_struct stask;
-	wait_queue_head_t rdq, wrq;	/* read and write queue heads */
-	spinlock_t rxlock;		/* for rx buffer struct */
-	int rnum;			/* # received buffers in rx_head */
-	struct list_head rx_head;		/* receive buffers' list */
-	struct dentry *dbgf;
-	u32 msgid;
-	u64 rxbytes, txbytes;
-};
-
-struct rx_struct{
-	struct list_head rhead;
-	struct kvec iov;
-	unsigned long soffset;
-};
-
-/* calculate size of subsystem here */
-#define DESC_ARRAY_SIZE(_nr) ((sizeof(u32) * 2) + sizeof(struct _desc_pci) * (_nr));
-
-#define INCR_CEIL(x)\
-({typeof(x) _x = (x);\
- _x = ((_x + 1) % NETL_NR_DESC);\
- _x;\
-})
-extern int send_one_packet_to_device(struct pti_subsys *, unsigned long , u32);
-extern int send_one_packet_to_host(struct pti_subsys *, unsigned long , u32);
-extern struct pti_subsys *reserve_subsystem(int);
-int get_hs(struct handshake_struct **);
-
-// #define NETL_MAX_MSG_RETRIES		8
-enum hshake_cmd{
-	HS_DEV_READY_TXRX,
-	HS_STATUS_NOT_DONE,
-	HS_STATUS_PROGRESSING,
-	HS_STATUS_COMPLETE,
-	HS_DEV_EXITING,
-};
-
-#define NETL_LINK_TIMER_INTERVAL	100
-struct handshake_struct{
-	volatile void *start;		/* PCI Shared mem space start */
-	int status;
-	wait_queue_head_t openq;	/* blocking open wait queue */
-	spinlock_t hs_lock;
-	struct cdev hs_cdev;
-	struct dentry *dbg_root;
-	struct semaphore hhsem;
-	struct timer_list link_timer;
-	struct hlist_head *hhash;/* Array of NETL_SUBSYS_HASH hlist_heads */
-	volatile u64 rxpending;		/* bits corresponding to rxpending subsys */
-	volatile u64 txpending;		/* bits corresponding to txpending subsys */
-	struct delayed_work temp_int_work;	/* remove later */
-	struct delayed_work hs_work;		/* handshake thread */
-	struct tasklet_struct hs_stask;
-	unsigned long pci_len;		/* PCI space length */
-#ifdef NETL_PTI_HOST
-	int hsid;
-	struct netl_device *dev_list;	/* Back ref->list of devs present */
-	struct list_head dhead;		/* linked to dev_list */
-	struct pci_dev *p_dev;
-	unsigned int msi_flag;		/* MSI, MSIX or INTX */
-#ifdef CONFIG_PCI_MSI
-	struct msix_entry msix;		/* only one MSI-X entry */
-#endif
-#endif
-	struct pti_subsys *ss[NETL_MAX_SUBSYS];
-};
-
-/* Offsets from top of the memory + PTI_ADDR_OFFSET */
-#define NETL_DBG_ROOT		"netl"
-#define NETL_DBG_FNAME_LEN	0x10
-#define NETL_SUBSYS_HASH	512	/* Number of hash buckets */
-#define NETL_MSG_MATCH		0x25
-#define NETL_MSG_ANY		0x26
-#define NETL_MSGID_START	0xff
-#define	NETL_MSI_ENABLE		0xF1
-#define NETL_MSIX_ENABLE	0xF2
-#define NETL_INTX_ENABLE	0xF0
-
-/* One command structure has, u32 + u32 + u32 + u32 elements
- * Do not use sizeof() unless __packed.
- */
-#define pti_pci_read8(ptr)\
-({\
-	ioread8(ptr);\
-})
-
-#define pti_pci_read16(ptr)\
-({\
-	ioread16(ptr);\
-})
-
-#define pti_pci_read32(ptr)\
-({\
-	ioread32(ptr);\
-})
-
-#define pti_pci_read64(ptr)\
-({\
-	readq(ptr);\
-})
-
-#define pti_pci_write8(v,p)\
-do{\
-	iowrite(v,p);\
-}while(0)
-
-#define pti_pci_write16(v,p)\
-do{\
-	iowrite16(v,p);\
-}while(0)
-
-#define pti_pci_write32(v,p)\
-do{\
-	iowrite32(v,p);\
-}while(0)
-
-#define pti_pci_write64(v,p)\
-do{\
-	writeq(v, p);\
-}while(0)
-
-/* this is used by both host and device */
-
-#define NLMXLP_BDF2OFFSET(bus, dev, func)  (((bus) << 20) | ((dev) << 15) | ((func) << 12))
-#ifdef CONFIG_NLM_XLP
-/* This should go to iomap.h later // TODO
- */
-#define DEFAULT_NLMXLP_IO_BASE DEFAULT_NETLOGIC_IO_BASE
-#define NLMXLP_CONF_SIZE	0x40000ULL
-#define NLMXLP_PHYS_START_PCI_MEM		0x7e000000
-/* From U-Boot, include/asm-mips64/arch-xlp8xx/cpu.h */
-/* -------------------------------- */
-/* Interface   | Bus | Dev | Func   */
-/* -------------------------------- */
-#define	NLMXLP_BRIDGE_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	 NLMXLP_BDF2OFFSET(0, 0, 0))
-#define	NLMXLP_PIC_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 0, 4))
-#define	NLMXLP_UART0_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 0))
-#define	NLMXLP_UART1_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 1))
-#define	NLMXLP_I2C0_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 2))
-#define	NLMXLP_I2C1_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 3))
-#define	NLMXLP_GPIO_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 4))
-#define	NLMXLP_SYS_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 5))
-#define	NLMXLP_JTAG_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 6, 6))
-#define	NLMXLP_GBU_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 7, 0))
-#define	NLMXLP_NOR_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 7, 0))
-#define	NLMXLP_NAND_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 7, 1))
-#define	NLMXLP_SPI_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 7, 2))
-#define	NLMXLP_MMC_BASE(node)\
-	(DEFAULT_NLMXLP_IO_BASE + ((node) * NLMXLP_CONF_SIZE) +\
-	NLMXLP_BDF2OFFSET(0, 7, 3))
-/* -------------------------------- */
-#endif		/* CONFIG_NLM_XLP */
-
-#endif		/* __KERNEL__ */
-
-#endif		/* NETL_PTI_H */
-
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.c b/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.c
deleted file mode 100644
index fb91253..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.c
+++ /dev/null
@@ -1,517 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-/*
- * Implementation of a char device abstraction over netl_pti
- */
-#include "../include/netl_pti.h"
-#include "../include/netl_pti_char.h"
-
-#define NETL_CHAR_MAJOR		0x0	/* Let kernel decide */
-#define NETL_NUM_DEVS		0x8	/* 8 subsystems */
-
-static int major = 0;		/* default to dynamic major */
-module_param(major, int, 0);
-MODULE_PARM_DESC(major, "Major device number");
-
-int netl_char_open(struct inode *inode, struct file *filp);
-int netl_char_release(struct inode *inode, struct file *filp);
-loff_t netl_char_llseek(struct file *filp, loff_t offset, int orig);
-ssize_t netl_char_read(struct file *filp, char __user *buf, size_t len, loff_t *off);
-ssize_t netl_char_write(struct file *filp, const char __user *buf, size_t len, loff_t *off);
-ssize_t netl_char_aio_read(struct kiocb *kiocb, const struct iovec *iovec, unsigned long len, loff_t off);
-ssize_t netl_char_aio_write(struct kiocb *kiocb, const struct iovec *iovec, unsigned long len, loff_t off);
-void subsys_poll_tx(struct pti_subsys *);
-unsigned int netl_char_poll(struct file * filp, struct poll_table_struct *poll_table);
-long netl_char_unlocked_ioctl(struct file * filp, unsigned int cmd, unsigned long arg);
-long netl_char_compat_ioctl(struct file * filp, unsigned int cmd, unsigned long arg);
-int netl_char_mmap(struct file * filp, struct vm_area_struct *vma);
-int netl_char_flush(struct file *filp, fl_owner_t id);
-int netl_char_close(struct inode *inode, struct file *filp);
-void netl_unregister_chrdev(struct handshake_struct *hs);
-struct rx_struct *wait_control_response(struct pti_subsys *ss, u32 msgid, int match);
-
-extern struct pti_subsys *get_ss_from_idx(struct handshake_struct *hs, int idx);
-extern int hs_minor_to_idx(struct handshake_struct *hs, int minor);
-extern int get_packet_from_rxlist(struct pti_subsys *ss, struct rx_struct **ret);
-extern u32 netl_pti_max_subsys;
-extern void dump_desc_ring(struct seq_file *seq, struct desc_ring *ring, int dump_all);
-extern struct pti_subsys *init_one_subsys(struct handshake_struct *, int);
-extern void stop_subsystem(struct pti_subsys *ss);
-extern void dealloc_this_subsystem(struct pti_subsys *ss);
-extern int init_device(struct handshake_struct *hs, int blocking);
-extern void dump_raw_control_message(void *p);
-extern int copy_nbytes_from_rxlist(struct pti_subsys *ss, void *buf, ssize_t n, struct list_head *free_list);
-extern int start_host_control_subsys(struct handshake_struct *hs, struct pti_subsys **ctrl_ss);
-
-struct rx_struct *__dequeue_msg(struct pti_subsys *ss, u32 msgid, int match);
-#ifdef NETL_PTI_HOST
-int send_one_packet_to_device(struct pti_subsys *ss, unsigned long page, u32 len);
-#else
-int send_one_packet_to_host(struct pti_subsys *ss, unsigned long page, u32 len);
-#endif
-
-typedef int (*send_func)(struct pti_subsys *, unsigned long, u32);
-
-const struct file_operations netl_char = {
-	.owner = THIS_MODULE,
-	.open = netl_char_open,
-	.read = netl_char_read,
-	.write = netl_char_write,
-	.llseek = no_llseek,
-	.aio_read = netl_char_aio_read,
-	.aio_write = netl_char_aio_write,
-	.poll = netl_char_poll,
-	.unlocked_ioctl = netl_char_unlocked_ioctl,
-	.compat_ioctl = netl_char_compat_ioctl,
-	.mmap = netl_char_mmap,
-	.flush = netl_char_flush,
-	.release = netl_char_close,
-};
-
-int netl_char_open(struct inode *inode, struct file *filp)
-{
-	__label__ open_lbl;
-	struct handshake_struct *hs = container_of(inode->i_cdev, struct handshake_struct, hs_cdev);
-	int num_minor = iminor(inode);
-	struct pti_subsys *ss = NULL;
-
-	if(hs->status == HS_DEV_READY_TXRX){
-		goto open_lbl;
-	}
-	if(filp->f_flags & O_NONBLOCK){
-		return -EAGAIN;
-	}else{
-		PDEBUG("Waiting for READY_TXRX\n");
-		wait_event_interruptible(hs->openq,
-				(hs->status == HS_DEV_READY_TXRX));
-	}
-open_lbl:
-	/* check if subsystem is already open */
-	ss = get_ss_from_idx(hs, num_minor);
-	if(ss == NULL){
-		ss = init_one_subsys(hs, num_minor);
-		if(ss == NULL){
-			return -EFAULT;
-		}
-	}
-	PDEBUG("num_minor = %d, ss = %p\n", num_minor, ss);
-	filp->private_data = ss;
-	return nonseekable_open(inode, filp);	/* Do not MOVE this one */
-}
-
-int netl_char_release(struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-/*
- * read implementation for netl char device
- *
- * Bug? Does not take care of failed reads (in between *). Would cause data loss?
- *
- */
-ssize_t netl_char_read(struct file *filp, char __user *ubuf, size_t ulen, loff_t *off)
-{
-	struct pti_subsys *ss = filp->private_data;
-	void *kbuf = (void *)get_zeroed_page(GFP_KERNEL);
-	void *ustart = ubuf;
-	unsigned int totread = 0, this = 0;
-	unsigned int tocopy = 0;
-	int ret = 0;
-
-	if(ss->hs->status != HS_DEV_READY_TXRX){
-		return -EIO;
-	}
-	if(kbuf == NULL){
-		return -ENOMEM;
-	}
-	//PDEBUG("Reading buffers of %#x\n", ss->id);
-
-	while((ulen - totread) > 0){
-		tocopy = ulen - totread;
-		tocopy = (PAGE_SIZE > tocopy) ? tocopy: PAGE_SIZE;
-		this = copy_nbytes_from_rxlist(ss, kbuf, tocopy, NULL);
-		//PDEBUG("read %#x bytes\n", this);
-		if(this > 0){
-			/* we read something */
-			if(copy_to_user(ustart, kbuf, this)){
-				ret = -EFAULT;
-				goto read_some;
-			}
-			totread += this;
-			ustart += this;
-		}else{
-		/* could not read anything this time, for list could be
-		 * empty or we requested 0 bytes */
-			if(filp->f_flags & O_NONBLOCK){
-				/* Send data, if any, we read so far*/
-				goto read_some;
-			}else{
-				/* Block till we have data */
-//				PDEBUG("Waiting ss = %p, (rnum %#x)\n", ss, ss->rnum);
-				if(wait_event_interruptible(ss->rdq, (ss->rnum != 0))){
-					ret = -ERESTARTSYS;
-					PDEBUG("Signal delivery\n");
-					goto read_some;
-				}
-//				PDEBUG("Wait OVER ss = %p (rnum %#x)\n", ss, ss->rnum);
-				/* Wait over, retry reading */
-				continue;
-			}
-		}
-	}
-read_some:
-	//PDEBUG("totread = %#x\n", totread);
-	*off += totread;
-	free_page((unsigned long)kbuf);
-	return((totread != 0) ? totread : ret);
-}
-
-int add_to_rxlist(struct pti_subsys *, volatile struct kvec *);
-int send_on_loopback(struct pti_subsys *ss, unsigned long page, u32 len)
-{
-	volatile struct kvec vec;
-
-	/* No need to manipulate nfree on tx or rx */
-	vec.iov_len = len;
-	vec.iov_base = (void *)page;
-	ss->rxbytes += len;
-	ss->txbytes += len;
-	add_to_rxlist(ss, &vec);
-	return 0;
-}
-/*
- * Write function
- * Writes to the device using send_one_packet_to_device
- *
- */
-ssize_t netl_char_write(struct file *filp, const char __user *buf, size_t len, loff_t *off)
-{
-	unsigned long kpage = 0;
-	struct pti_subsys *ss = filp->private_data;
-	int ret = 0;
-	int len2s = 0, sent = 0;
-	int written = 0;
-#ifdef NETL_PTI_HOST
-	send_func send_packet = send_one_packet_to_device;
-#else
-	send_func send_packet = send_one_packet_to_host;
-#endif
-#ifdef NETL_LOOPBACK
-	send_packet = send_on_loopback;
-#endif
-	if(ss->hs->status != HS_DEV_READY_TXRX){
-		return -EIO;
-	}
-	/* split up the incoming packet
-	 * write(2) should succeed even if only one byte is written */
-	while(sent != len){
-		len2s = ((len - sent) > NETL_BUFSIZE) ? NETL_BUFSIZE: (len - sent);
-		//PDEBUG("len2s = %#x\n", len2s);
-		kpage = get_zeroed_page(GFP_KERNEL);
-		if(!kpage){
-			ret = -ENOMEM;
-			break;
-		}
-		if(copy_from_user((void *)kpage, (buf + sent), len2s)){
-			PDEBUG("copy from user failed\n");
-			free_page(kpage);
-			ret = -EFAULT;
-			break;
-		}
-		// PDEBUG("Sending packet on ss->id %#x\n", ss->id);
-		ret = send_packet(ss, kpage, len2s);
-		if(ret == 0){
-		//	PDEBUG("Sent one packet\n");
-			*off += len2s;
-			written = 1;
-			sent += len2s;
-			continue;
-		}
-		if(ret == EAGAIN){
-			free_page(kpage);
-			/* if noblock is set, return immediately */
-			if(filp->f_flags & O_NONBLOCK){
-				PDEBUG("NO space left\n");
-				ret = -EAGAIN;
-				break;
-			}
-			/* Else add to ss->wrq and wait */
-		//	PDEBUG("Waiting on queue, txring->nfree = %#x\n", ss->txring->nfree);
-			if(wait_event_interruptible(ss->wrq, (ss->txring->nfree != 0))){
-				ret = -ERESTARTSYS;
-				break;
-			}
-		}else{
-			PDEBUG("Sent fail\n");
-			free_page(kpage);
-			break;
-		}
-	}
-	//PDEBUG("sent bytes %#x\n", sent);
-	if(written){
-		return sent;
-	}else{
-		 return ret;
-	}
-}
-
-ssize_t netl_char_aio_read(struct kiocb *kiocb, const struct iovec *iovec, unsigned long len, loff_t off)
-{
-	return 0;
-}
-
-ssize_t netl_char_aio_write(struct kiocb *kiocb, const struct iovec *iovec, unsigned long len, loff_t off)
-{
-	return 0;
-}
-
-unsigned int netl_char_poll(struct file * filp, struct poll_table_struct *wait)
-{
-	struct pti_subsys *ss = (struct pti_subsys *)filp->private_data;
-	unsigned int mask = 0;
-	unsigned long flags;
-	int empty = 0;
-
-	PDEBUG("ss = %p\n", ss);
-	if(ss == NULL){		/* remove this check later TODO */
-		PDEBUG("No SS\n");
-		return 0;
-	}
-	PDEBUG("ss->id = %#x\n", ss->id);
-	/* I guess this call is applicable to control and data subsystems
-	 * So, not explicitly checking for ss->id == 0 */
-	poll_wait(filp, &ss->rdq, wait);
-	poll_wait(filp, &ss->wrq, wait);
-	spin_lock_irqsave(&ss->rxlock, flags);
-	empty = list_empty(&ss->rx_head);
-	spin_unlock_irqrestore(&ss->rxlock, flags);
-	if(!empty){
-		mask |= (POLLIN | POLLRDNORM);	/* Some data to read */
-	}
-	if(ss->txring->nfree != 0){
-		mask |= (POLLOUT | POLLWRNORM);	/* #free slot to write >= 1*/
-	}
-	PDEBUG("End of poll func\n");
-	return mask;
-}
-
-#ifdef NETL_PTI_HOST
-void host_flush_dma_pages(struct pti_subsys *ss)
-{
-	/* At this time, all rxdma pages are marked dma_stat = 0
-	 * Free all rxdma pages and any Tx dma pages */
-	struct desc_ring *rxr;
-	unsigned long fl_rng;
-	int loops;
-	volatile dma_addr_t dm_old;
-	u32 dma_stat;
-
-	subsys_poll_tx(ss);	/* Tx complete takes care of all pending tx */
-
-	rxr = ss->rxring;
-	spin_lock_irqsave(&rxr->rng_lock, fl_rng);
-	loops = NETL_NR_DESC;
-	while(loops--){
-		dma_stat = pti_pci_read32((void *)&rxr->pdesc[loops].pci_desc->dma_stat);
-		if(is_dma_set(dma_stat)){
-			PERROR("Feeing page (offset %#x) under DMA\n", loops);
-			// dump_desc_ring(NULL, rxr, 1);
-			spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-			return;
-		}
-		/* free up the mapping */
-		dm_old = pti_pci_read64((void *)&rxr->pdesc[loops].pci_desc->dma_addr);
-		pci_unmap_single(ss->hs->p_dev, dm_old, NETL_BUFSIZE, DMA_FROM_DEVICE);
-		free_page((unsigned long)rxr->pdesc[loops].buf);
-	}
-	spin_unlock_irqrestore(&rxr->rng_lock, fl_rng);
-	return;
-}
-#endif
-
-long netl_char_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	struct pti_subsys *ss = NULL;
-	struct inode *inode = filp->f_path.dentry->d_inode;
-	struct handshake_struct *hs = container_of(inode->i_cdev, struct handshake_struct, hs_cdev);
-
-	//PDEBUG("inode = 0x%p, hs = 0x%p\n", inode, hs, in_atomic());
-	if(down_interruptible(&hs->hhsem) != 0){
-		return -ERESTARTSYS;
-	}
-	switch(cmd){
-	case NETL_SS_SELECT:
-		PDEBUG("arg = %#x\n", (unsigned int)arg);
-		if(arg == 0){
-			up(&hs->hhsem);
-			return -EPERM;
-		}
-		ss = get_ss_from_idx(hs, (int)arg);
-		if(ss == NULL){
-			up(&hs->hhsem);
-			return -ENOENT;
-		}
-		filp->private_data = ss;
-		up(&hs->hhsem);
-		return 0;
-	case NETL_SS_PDATA_STORE:{
-		struct pti_subsys *ss;
-		void *ptr;
-
-		if (hs->status != HS_DEV_READY_TXRX) {
-			up(&hs->hhsem);
-			return -EAGAIN;
-		}
-		ptr = kmalloc(GFP_KERNEL, CTRL_MSG_SIZE);
-		if (!ptr) {
-			up(&hs->hhsem);
-			return -ENOMEM;
-		}
-		if (copy_from_user(ptr, (void *)arg, CTRL_MSG_SIZE)) {
-			kfree(ptr);
-			up(&hs->hhsem);
-			return -EFAULT;
-		}
-		ss = filp->private_data;
-		ss->priv_data = ptr;
-		up(&hs->hhsem);
-		return 0;
-	}
-	case NETL_SS_PDATA_FETCH:{
-		struct pti_subsys *ss;
-
-		if (hs->status != HS_DEV_READY_TXRX) {
-			up(&hs->hhsem);
-			return -EAGAIN;
-		}
-		ss = filp->private_data;
-		if (!ss->priv_data) {
-			up(&hs->hhsem);
-			return -ENOENT;
-		}
-		if (copy_to_user((void *)arg, ss->priv_data, CTRL_MSG_SIZE)) {
-			up(&hs->hhsem);
-			return -EFAULT;
-		}
-		up(&hs->hhsem);
-		return 0;
-	}
-	default:
-		up(&hs->hhsem);
-		return -ENOTTY;
-	}/* switch */
-	return 0;
-}
-
-long netl_char_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	//PDEBUG("cmd = %x, arg = %lx\n", cmd, arg);
-	return netl_char_unlocked_ioctl(filp, cmd, arg);
-}
-int netl_char_mmap(struct file * filp, struct vm_area_struct *vma)
-{
-	return 0;
-}
-
-int netl_char_flush(struct file *filp, fl_owner_t id)
-{
-	return 0;
-}
-
-int netl_char_close(struct inode *inode, struct file *filp)
-{
-	return 0;
-}
-
-
-int netl_register_chrdev(struct handshake_struct *hs)
-{
-	dev_t devid;
-	int rc;
-	int max_subsys = NETL_MAX_SUBSYS;
-
-	if(major){
-		devid = MKDEV(major, 0);
-		rc = register_chrdev_region(devid, max_subsys, "netl_char");
-	}else{
-		rc = alloc_chrdev_region(&devid, 0, max_subsys, "netl_char");
-		major = MAJOR(devid);
-	}
-	PDEBUG("Major number = %#x\n", major);
-	if(rc < 0){
-		PDEBUG("NetL PCI chrdev_region err: %d\n", rc);
-		return -1;
-	}
-	hs->hs_cdev.owner = THIS_MODULE;
-	cdev_init(&hs->hs_cdev, &netl_char);
-	rc = cdev_add(&hs->hs_cdev, devid, max_subsys);
-	if(rc != 0){
-		PDEBUG("Failed to register character device\n");
-		return rc;
-	}
-	return 0;
-}
-
-void netl_unregister_chrdev(struct handshake_struct *hs)
-{
-	dev_t devid = MKDEV(major, 0);
-	int max_subsys = NETL_MAX_SUBSYS;
-
-	cdev_del(&hs->hs_cdev);
-	unregister_chrdev_region(devid, max_subsys);
-	return;
-}
-
-
-/*
- * Creates a control message block
- *
- * @pg : page (buffer)
- * @ss : subsystem ptr
- * @len : length (return value)
- *
- * __ORDER OF COPYING IS IMPORTANT. CROSS CHECK WITH ``parse_control_message``
- * returns message id of the control message
- */
-#define COPY_CTRL_LE32(ptr, param, tmp)\
-do{\
-	tmp = cpu_to_le32(param);\
-	memcpy(ptr, &tmp, sizeof(u32));\
-	ptr += sizeof(u32);\
-}while(0)
-
-
-#define COPY_TO_CTRL_LE32(ptr)\
-({\
-	u32 tmp = __le32_to_cpup((u32 *)ptr);\
-	ptr += sizeof(u32);\
-	tmp;\
-})
-
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.h b/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.h
deleted file mode 100644
index 5e379fb..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti_char.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef NETL_PTI_CHAR_H
-#define NETL_PTI_CHAR_H
-#ifdef __KERNEL__
-#include <linux/ioctl.h>
-#include <linux/signal.h>
-#else
-#include <sys/ioctl.h>
-#include <sys/signal.h>
-#endif
-#define NETL_PTI_IOCTL_MAGIC	0xf3
-#define CTRL_MSG_SIZE		0x40
-/*
- * select : gets an idx, select the corresponding ss into the filp->private
- *	if no ss exists, filp->private is unset and returns EINVAL
- * setup : creates a ss corresponding to the arg. If already exists, returns
- *	error
- * setservapp	: sets up the server applicaiton on the device.
- */
-#define _NIO(m,n)	(((m) << 8)|(n))
-#define NETL_SS_SELECT		_NIO(NETL_PTI_IOCTL_MAGIC, 0x10)
-#define NETL_SS_SETUP		_NIO(NETL_PTI_IOCTL_MAGIC, 0x11)
-#define NETL_SS_PDATA_STORE	_NIO(NETL_PTI_IOCTL_MAGIC, 0x12)
-#define NETL_SS_PDATA_FETCH	_NIO(NETL_PTI_IOCTL_MAGIC, 0x13)
-#endif /* NETL_PTI_CHAR_H */
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti_common.c b/drivers/misc/netlogic/pcie-offload/include/netl_pti_common.c
deleted file mode 100644
index 0f4ce71..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti_common.c
+++ /dev/null
@@ -1,719 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include "../include/netl_pti.h"
-
-/* Static functions */
-static volatile u8 *ss_get_desc_offset(struct pti_subsys *ss, int idx, int is_rx);
-static volatile u8 *ss_get_ringcmd_offset(struct pti_subsys *ss, int is_rx);
-struct pti_subsys *init_one_subsys(struct handshake_struct *hs, int id);
-static void dealloc_desc_ring(struct desc_ring *ring, int type);
-static int init_desc_ring(struct pti_subsys *ss, struct desc_ring *ring, int type);
-int add_to_rxlist(struct pti_subsys *ss, volatile struct kvec *iov);
-static int netl_dbg_open(struct inode *inode, struct file *filp);
-int netl_pti_debugfs_init(struct handshake_struct *hs);
-int init_handshake_struct(struct handshake_struct *hs);
-
-/* functions called from other files */
-// int init_subsystems(struct handshake_struct *hs);
-void dealloc_all_subsys(struct handshake_struct *hs);
-void dealloc_this_subsystem(struct pti_subsys *ss);
-void copy_desc_pci(volatile struct _desc_pci *new, volatile struct _desc_pci *orig);
-void hs_clear_cmd(struct handshake_struct *hs, u32 sval);
-void hs_work_func(struct work_struct *);
-
-void dump_subsystem(struct seq_file *seq, struct pti_subsys *ss, int txr, int rxr);
-void dump_desc_ring(struct seq_file *seq, struct desc_ring *ring, int dump_all);
-void dump_descriptor(struct seq_file *seq, struct descriptor *ptr);
-int copy_nbytes_from_rxlist(struct pti_subsys *ss, void *buf, ssize_t n, struct list_head *free_list);
-
-/* extern functions declared in dev/host speicifc files */
-extern void subsys_poll(unsigned long);
-extern struct workqueue_struct *ss_workq;
-extern void set_hs_status(struct handshake_struct *hs, enum hshake_cmd cmd);
-int get_packet_from_rxlist(struct pti_subsys *ss, struct rx_struct **ret);
-
-/* Dbg file support */
-static struct file_operations netl_dbg_fops = {
-	.owner = THIS_MODULE,
-	.open = netl_dbg_open,
-	.llseek = seq_lseek,
-	.read = seq_read,
-	.release = single_release,
-};
-
-
-void copy_desc_pci(volatile struct _desc_pci *new, volatile struct _desc_pci *orig)
-{
-	memset((void *)new, 0, sizeof(struct _desc_pci));
-	/* Must copy dma_stat first */
-	new->dma_stat = pti_pci_read32((void *)&orig->dma_stat);
-	new->dma_len = pti_pci_read32((void *)&orig->dma_len);
-	new->dma_addr = pti_pci_read64((void *)&orig->dma_addr);
-}
-
-/*
- * Deallocate and frees a descriptor ring
- *
- * @ring : descriptor ring to allocate
- */
-static int init_desc_ring(struct pti_subsys *ss, struct desc_ring *ring, int type)
-{
-	int count;
-	struct descriptor *ptr;
-#ifdef NETL_PTI_HOST
-	dma_addr_t daddr;
-	u32 len;
-#endif
-
-	// PDEBUG("ss[%#x]->hs = %p, ring = %p\n", ss->id, ss->hs, ring);
-	ring->pdesc = kzalloc(sizeof(struct descriptor) * NETL_NR_DESC, GFP_KERNEL);
-	if(!ring->pdesc){
-		PDEBUG("Failed to allocate pdesc\n");
-		return ENOMEM;
-	}
-	ring->ss = ss;
-	spin_lock_init(&ring->rng_lock);
-	ring->start = ring->end = 0;
-	ring->head = (volatile u32 *)ss_get_ringcmd_offset(ss,type);
-	ring->tail = ring->head + 1;	/* pointer arithmetic */
-	ring->nfree = NETL_NR_DESC - 1;
-	/* Keeping one slot open. If head == tail, empty.
-	 * if tail == head + 1, full */
-#ifdef NETL_PTI_HOST
-	pti_pci_write32(0, (void *)ring->head);
-	pti_pci_write32(0, (void *)ring->tail);
-#endif
-	for(count = 0; count < NETL_NR_DESC; count++){
-		ptr = &ring->pdesc[count];
-		ptr->idx = count;
-		ptr->pring = ring;
-		ptr->pci_desc = (struct _desc_pci *)ss_get_desc_offset
-						(ss, count, type);
-		//PDEBUG("pci_desc = %p\n", ptr->pci_desc);
-#ifdef NETL_PTI_HOST
-		len = NETL_BUFSIZE;
-		if(type == DESC_RING_TYPE_RX_HOST){
-			ptr->buf = get_zeroed_page(GFP_ATOMIC|GFP_DMA32);
-			BUG_ON(!ptr->buf);
-			ptr->len = len;
-			daddr = pci_map_single(ss->hs->p_dev,
-				(void *)ptr->buf, len, DMA_FROM_DEVICE);
-			BUG_ON(!daddr);
-			//PDEBUG("ptr->buf = %p, daddr = %p, &dma_addr = %p\n", ptr->buf, (void *)daddr, &ptr->pci_desc->dma_addr);
-			pti_pci_write64(daddr, &ptr->pci_desc->dma_addr);
-			pti_pci_write32(len, (void *)&ptr->pci_desc->dma_len);
-			pti_pci_write32(DESC_DMA_READY, (void *)&ptr->pci_desc->dma_stat);
-		}else{
-			/* XXX Delete later */
-			pti_pci_write64(0xFF, &ptr->pci_desc->dma_addr);
-			pti_pci_write32(0xFF, (void *)&ptr->pci_desc->dma_len);
-			pti_pci_write32(0, (void *)&ptr->pci_desc->dma_stat);
-		}
-
-#else
-		ptr->buf = 0;	/* allocate later with dma_size */
-#endif
-	}
-	// PDEBUG("Success\n");
-	return 0;
-}
-
-/*
- * Sends the device to stop all DMAs in progress
- *	TODO
- */
-void send_device_dma_abort(void)
-{
-	PDEBUG("Messaging device to stop all DMAs\n");
-	return;
-}
-
-/*
- * Deallocate and frees a descriptor ring
- *
- * @ring : descriptor ring to deallocate
- */
-static void dealloc_desc_ring(struct desc_ring *ring, int type)
-{
-#ifdef NETL_PTI_HOST
-	int i;
-
-	send_device_dma_abort();
-	for(i = 0; i < NETL_NR_DESC; i++){
-		//PDEBUG("Freeing pdesc[%#x]\n", ring->pdesc[i].idx);
-		pti_pci_write32(0, (void *)&ring->pdesc[i].pci_desc->dma_stat);
-		pti_pci_write32(0, (void *)&ring->pdesc[i].pci_desc->dma_len);
-		pti_pci_write64(0, (void *)&ring->pdesc[i].pci_desc->dma_addr);
-		if(type == DESC_RING_TYPE_RX_HOST){
-			free_page(ring->pdesc[i].buf);
-		}
-		ring->pdesc[i].buf = 0;
-		ring->pdesc[i].pring = NULL;
-	}
-	pti_pci_write32(0, (void *)ring->head);
-	pti_pci_write32(0, (void *)ring->tail);
-#endif
-	kfree(ring->pdesc);
-	return;
-}
-
-/*
- * deallocate resources and frees a subsytem
- *
- * @hs	: handshake structure
- */
-void dealloc_all_subsys(struct handshake_struct *hs)
-{
-	struct pti_subsys *ss;
-	int count;
-	struct hlist_node *node, *n;
-	unsigned long flags;
-
-	// down(&hs->hhsem);	// Need to check the effect TODO
-	for(count = 0; count < NETL_SUBSYS_HASH; count++){
-		if(hlist_empty(&hs->hhash[count])){
-			continue;
-		}
-		hlist_for_each_entry_safe(ss, node, n, &hs->hhash[count], snode){
-			spin_lock_irqsave(&hs->hs_lock, flags);
-			hlist_del(&ss->snode);
-			spin_unlock_irqrestore(&hs->hs_lock, flags);
-			dealloc_this_subsystem(ss);
-			/* ss is freed and not valid anymore */
-		}
-	}
-	// up(&hs->hhsem);
-	return;
-}
-
-void dealloc_this_subsystem(struct pti_subsys *ss)
-{
-	debugfs_remove_recursive(ss->dbgf);
-#ifdef NETL_PTI_HOST
-	dealloc_desc_ring(ss->txring, DESC_RING_TYPE_RX_HOST);
-	dealloc_desc_ring(ss->rxring, DESC_RING_TYPE_TX_HOST);
-#else
-	dealloc_desc_ring(ss->txring, DESC_RING_TYPE_RX_DEV);
-	dealloc_desc_ring(ss->rxring, DESC_RING_TYPE_TX_DEV);
-#endif
-	kfree(ss->priv_data);
-	kfree(ss);
-	return;
-}
-
-/*
- * Initializes one subsystem denoted by idx
- *
- * @hs	:handshake struct
- * @idx	: index of the subsystem
- */
-struct pti_subsys *init_one_subsys(struct handshake_struct *hs, int id)
-{
-	char fname[NETL_DBG_FNAME_LEN];
-	unsigned long flags;
-	struct pti_subsys *ss = NULL;
-#ifdef NETL_PTI_DEVICE
-	int rx_flag = DESC_RING_TYPE_RX_DEV;
-	int tx_flag = DESC_RING_TYPE_TX_DEV;
-#else
-	int rx_flag = DESC_RING_TYPE_RX_HOST;
-	int tx_flag = DESC_RING_TYPE_TX_HOST;
-#endif
-
-	PDEBUG("Init subsystem %d\n", id);
-	ss = kzalloc(sizeof(struct pti_subsys), GFP_KERNEL);
-	if(!ss){
-		PDEBUG("Failed to allocate subsystem...\n");
-		return NULL;
-	}
-	ss->txring = kzalloc(sizeof(struct desc_ring), GFP_KERNEL);
-	ss->rxring = kzalloc(sizeof(struct desc_ring), GFP_KERNEL);
-	if(!ss->rxring || !ss->txring){
-		PDEBUG("ring alloc fail\n");
-		goto ring_fail;
-	}
-	ss->id = id;
-	ss->rxbytes = ss->txbytes = 0;
-	INIT_HLIST_NODE(&ss->snode);
-	ss->flags = 0;
-	spin_lock_init(&ss->slock);
-	ss->hs = hs;
-	ss->msgid = NETL_MSGID_START;
-	init_waitqueue_head(&ss->rdq);
-	init_waitqueue_head(&ss->wrq);
-	spin_lock_init(&ss->rxlock);
-	ss->rnum = 0;
-	INIT_LIST_HEAD(&ss->rx_head);
-
-	/* Now that all other fields are initialized, allocate and
-	* initialize rings. This MUST BE DONE BEFORE init_desc_ring
-	*/
-	if(init_desc_ring(ss, ss->rxring, rx_flag) != 0){
-		PDEBUG("Ring init RX fail\n");
-		goto rx_init_fail;
-	}
-	if(init_desc_ring(ss, ss->txring, tx_flag) != 0){
-		PDEBUG("Ring init TX fail\n");
-		goto tx_init_fail;
-	}
-	if(0 != ss->hs->dbg_root){
-		memset(fname, 0, NETL_DBG_FNAME_LEN);
-		sprintf(fname, "ss%x", ss->id);
-		ss->dbgf = debugfs_create_file(fname, S_IRUGO, ss->hs->dbg_root,
-				ss, &netl_dbg_fops);
-		if(!ss->dbgf || (IS_ERR(ss->dbgf) != 0)){
-			ss->dbgf = NULL;
-			PDEBUG("Failed to create debugfs entry for ss = %x\n", ss->id);
-		}
-		PDEBUG("created %s/%s\n", NETL_DBG_ROOT, fname);
-	}
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	hlist_add_head(&ss->snode, &(hs->hhash[ss->id % NETL_SUBSYS_HASH]));
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-	PDEBUG("Subsystem Done %d\n", ss->id);
-//	dump_subsystem(NULL, ss, 0, 0);
-//	Queueing should happen only after full initialization
-//	queue_delayed_work(ss_workq, &ss->swork, 10);
-	return ss;
-tx_init_fail:
-	kfree(ss->rxring->pdesc);
-rx_init_fail:
-ring_fail:
-	kfree(ss->txring);
-	kfree(ss->rxring);
-	kfree(ss);
-	return NULL;
-}
-
-/*
- * returns the offset of the pci memory space descriptor
- * for subsystem cmd register
- *
- * @desc_nr :	number of descriptors per ring
- * @ssid :	subsystem id
- * @idx:	index of desc_ring
- * @is_rx :	whether an rx ring or tx ring
- */
-volatile u8 *ss_get_ringcmd_offset(struct pti_subsys *ss, int is_rx)
-{
-	/* calculate size of subsystem here */
-	u32 offset;
-	u16 da_size = DESC_ARRAY_SIZE(NETL_NR_DESC);
-
-	offset = ((ss->id * 2 + is_rx) * da_size) + NETL_HS_PARAMSPACE;
-	return (volatile u8 *) (ss->hs->start + offset);
-}
-
-/*
- * returns the offset of the pci memory space descriptor
- * for descriptor in desc_ring of a subsystem[ssid]
- *
- * @desc_nr :	number of descriptors per ring
- * @ssid :	subsystem id
- * @idx:	index of desc_ring
- * @is_rx :	whether an rx ring or tx ring
- */
-volatile u8 *ss_get_desc_offset(struct pti_subsys *ss, int idx, int is_rx)
-{
-	volatile u8 *offset = ss_get_ringcmd_offset(ss, is_rx);
-	offset += (2 * (sizeof(u32))); /* head and tail */
-	offset += idx * (sizeof(struct _desc_pci));
-	return offset;
-}
-
-#define netl_print(seq,fmt,args...)\
-do{\
-	if(seq != NULL)\
-		seq_printf(seq, fmt, ##args);\
-	else\
-		printk(fmt, ##args);\
-}while(0)
-
-void dump_subsystem(struct seq_file *seq, struct pti_subsys *ss, int txr, int rxr)
-{
-	netl_print(seq, "id = %#x\n", ss->id);
-	netl_print(seq, "flags = %#lx\n", ss->flags);
-	netl_print(seq, "hs = %p\n", ss->hs);
-	netl_print(seq, "rxbytes = %llx\n", ss->rxbytes);
-	netl_print(seq, "txbytes = %llx\n", ss->txbytes);
-	netl_print(seq, "rxring = %p\n", ss->rxring);
-	dump_desc_ring(seq, ss->rxring, rxr);
-	netl_print(seq, "txring = %p\n", ss->txring);
-	dump_desc_ring(seq, ss->txring, txr);
-	return;
-}
-
-void dump_desc_ring(struct seq_file *seq, struct desc_ring *ring, int dump_all)
-{
-	int i = 0;
-
-	if(ring == NULL){
-		PDEBUG("Can't dump NULL ring\n");
-		return;
-	}
-	netl_print(seq, "\thead = %p, val = %#x\n",
-			ring->head, pti_pci_read32((void*)ring->head));
-	netl_print(seq, "\ttail = %p, val = %#x\n",
-			ring->tail, pti_pci_read32((void*)ring->tail));
-	netl_print(seq, "\tpdesc = %p\n", ring->pdesc);
-	netl_print(seq, "\tnfree = %#x\n", ring->nfree);
-	netl_print(seq, "\tstart = %#x\n", ring->start);
-	netl_print(seq, "\tend = %#x\n", ring->end);
-	netl_print(seq, "\tss = %p\n", ring->ss);
-	if(dump_all){
-		for(i = 0; i < NETL_NR_DESC; i++){
-			dump_descriptor(seq, &ring->pdesc[i]);
-			netl_print(seq, "\n");
-		}
-	}else{
-		dump_descriptor(seq, &ring->pdesc[0]);
-	}
-	return;
-}
-
-void dump_desc_pci(struct seq_file *seq, struct _desc_pci *pci)
-{
-	netl_print(seq, "%#llx %#x %#x\n", (u64)readq(&pci->dma_addr), readl(&pci->dma_len), readl(&pci->dma_stat));
-}
-
-void dump_descriptor(struct seq_file *seq, struct descriptor *ptr)
-{
-	struct descriptor *desc;
-	if(ptr == NULL){
-		PDEBUG("Null desc\n");
-		return;
-	}
-	desc = ptr;
-	netl_print(seq, "\t\tpci_desc = %p\n", desc->pci_desc);
-	netl_print(seq, "\t\t\tdma_addr = %p val = %#llx\n",
-	&desc->pci_desc->dma_addr, (u64)pti_pci_read64((void*)&desc->pci_desc->dma_addr));
-	netl_print(seq, "\t\t\tdma_len = %p val = %#x\n",
-	&desc->pci_desc->dma_len, pti_pci_read32((void*)&desc->pci_desc->dma_len));
-	netl_print(seq, "\t\t\tdma_stat = %p val = %#x\n",
-	&desc->pci_desc->dma_stat, pti_pci_read32((void*)&desc->pci_desc->dma_stat));
-	netl_print(seq, "\t\tbuf = %lx\n", desc->buf);
-	netl_print(seq, "\t\tlen = %#x\n", desc->len);
-	netl_print(seq, "\t\tbuf_flag = %#llx\n", desc->buf_flag);
-	netl_print(seq, "\t\tpring = %p\n", desc->pring);
-	netl_print(seq, "\t\tidx = %#x\n", desc->idx);
-	return;
-}
-
-static int netl_dbg_ss_show(struct seq_file *seq, void *v)
-{
-	struct pti_subsys *ss = (struct pti_subsys *)seq->private;
-	dump_subsystem(seq,ss,1,1);
-	return 0;
-}
-
-static int netl_dbg_open(struct inode *inode, struct file *filp)
-{
-	return single_open(filp, netl_dbg_ss_show, inode->i_private);
-}
-
-int netl_pti_debugfs_init(struct handshake_struct *hs)
-{
-	struct dentry *d = debugfs_create_dir(NETL_DBG_ROOT, NULL);
-	if(!d || (IS_ERR(d) != 0)){
-		PDEBUG("Failed to create debugfs, d = %p\n", d);
-		return PTR_ERR(d);
-	}
-	hs->dbg_root = d;
-	return 0;
-}
-
-/*
- * Dequeue a packet from rx buffer list
- * Must be called with ss->rxlock held
- */
-struct rx_struct *__dequeue_msg(struct pti_subsys *ss, u32 msgid, int match)
-{
-	struct rx_struct *pos = NULL, *n;
-
-	if(match == NETL_MSG_ANY){
-		pos = list_first_entry(&ss->rx_head, struct rx_struct, rhead);
-		list_del(&(pos->rhead));
-		ss->rnum--;
-		return pos;
-	}else{
-		list_for_each_entry_safe(pos, n, &ss->rx_head, rhead){
-			if(__le32_to_cpup((const u32 *)pos->iov.iov_base) == msgid){
-				list_del(&(pos->rhead));
-				ss->rnum--;
-				return pos;
-			}
-		}
-	}
-	PDEBUG("\n");
-	return NULL;
-}
-
-/*
- * Back end of read call : data path only
- *
- * @ss:	subsystem ptr
- * @buf	: kernel buffer to copy
- * @n	: #bytes to copy
- * @free_list :	list of rx_buf to re-insert if something gos wrong. This is currently unused.
- */
-int copy_nbytes_from_rxlist(struct pti_subsys *ss, void *buf, ssize_t n, struct list_head *free_list)
-{
-	unsigned long flags;
-	void *kstart = buf;
-	int totread = 0;
-	struct rx_struct *pos = NULL, *nxt;
-	void *start = NULL;
-	int tord = 0;
-
-	spin_lock_irqsave(&ss->rxlock, flags);
-	if(list_empty(&ss->rx_head)){
-		goto fnend;
-	}
-	list_for_each_entry_safe(pos, nxt, &ss->rx_head, rhead){
-	//PDEBUG("pos = %p, nxt = %p, &ss->rx_head = %p, next = %p, prev = %p\n", pos, nxt, &ss->rx_head, pos->rhead.next, pos->rhead.prev);
-	//PDEBUG("pos = %p, base = %p, soffset = %#lx\n", pos, pos->iov.iov_base, pos->soffset);
-		start = pos->iov.iov_base + pos->soffset;
-		tord = pos->iov.iov_len - pos->soffset;
-		tord = (tord > (n - totread)) ? (n - totread) : tord;
-//		PDEBUG("tord = %#x, n = %#x, totread = %#x\n", tord, n, totread);
-		memcpy(kstart, start, tord);
-		pos->soffset += tord;
-		totread += tord;
-		kstart += tord;
-		if(pos->soffset == pos->iov.iov_len){
-			/* Consumed one rx_struct */
-			ss->rnum--;
-//			PDEBUG("&pos->rhead = %pss->rnum = %#x\n", (&(pos->rhead)), ss->rnum);
-			list_del(&(pos->rhead));
-			if(free_list != NULL){
-				INIT_LIST_HEAD(&(pos->rhead));
-				list_add_tail(&(pos->rhead), free_list);
-			}else{
-				free_page((unsigned long)pos->iov.iov_base);
-				kfree(pos);
-			}
-		}else if(pos->soffset > pos->iov.iov_len){
-			/* Should never happen */
-			goto fnfail;
-		}
-		if(totread == n){
-			break;
-		}else if(totread > n){
-			/* Should never happen */
-			goto fnfail;
-		}
-	}	/* list_for_each_entry_safe */
-fnend:
-	spin_unlock_irqrestore(&ss->rxlock, flags);
-	return totread;
-fnfail:
-	spin_unlock_irqrestore(&ss->rxlock, flags);
-	PERROR("FATAL : Failed logic\n");
-	//PERROR("soffset = %#lx, len = %#x, kstart = %p, totread = %#x, " "n = %#lx\n",pos->soffset, pos->iov.iov_len, kstart, totread, n);
-	BUG();
-	return 0;	/* silence the compiler */
-}
-
-/*
- * Gets an rx_struct from list -- control and n/w path only
- */
-int get_packet_from_rxlist(struct pti_subsys *ss, struct rx_struct **ret)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&ss->rxlock, flags);
-	if(list_empty(&ss->rx_head)){
-		BUG_ON(ss->rnum != 0);
-		spin_unlock_irqrestore(&ss->rxlock, flags);
-		return -EAGAIN;
-	}
-	*ret = __dequeue_msg(ss, 0, NETL_MSG_ANY);
-	spin_unlock_irqrestore(&ss->rxlock, flags);
-	return 0;
-}
-
-EXPORT_SYMBOL(get_packet_from_rxlist);
-/*
- * Adds a buffer and length to the receive buffer list
- *
- * @ss	:subsystem
- * @buf	: buffer to add to rxlist
- * @len	: length of the buffer
- */
-int add_to_rxlist(struct pti_subsys *ss, volatile struct kvec *iov)
-{
-	unsigned long flags;
-	struct rx_struct *rx = kzalloc(sizeof(struct rx_struct), GFP_ATOMIC);
-
-	if(!rx){
-		PDEBUG("memory alloc failure\n");
-		return -ENOMEM;
-	}
-	INIT_LIST_HEAD(&rx->rhead);
-	spin_lock_irqsave(&ss->rxlock, flags);
-	rx->iov.iov_base = iov->iov_base;
-	rx->iov.iov_len = iov->iov_len;
-	list_add_tail(&rx->rhead, &ss->rx_head);
-	ss->rnum++;
-	spin_unlock_irqrestore(&ss->rxlock, flags);
-	//PDEBUG("waking up sleeping processes\n");
-	wake_up_interruptible(&ss->rdq);
-	return 0;
-}
-
-EXPORT_SYMBOL(add_to_rxlist);
-/*
- * If we support more than one device, handshake struct must have an entry
- * to show the minor number of the first device. minor_to_idx will return the
- * index# derived from minor number.
- *
- * @hs	: handshake structure
- * @minor	: minor number
- */
-int hs_minor_to_idx(struct handshake_struct *hs, int minor)
-{
-	return minor;
-}
-
-/*
- * Converts an integer to ss, if it is valid
- *
- * @hs	: handshake struct for this device
- * @idx	: index of the subsystem
- */
-struct pti_subsys *get_ss_from_idx(struct handshake_struct *hs, int idx)
-{
-	struct pti_subsys *ss;
-	struct hlist_node *node;
-	struct hlist_head *head;
-	unsigned long flags;
-
-	if(idx > NETL_MAX_SUBSYS){
-		return NULL;
-	}
-	spin_lock_irqsave(&hs->hs_lock, flags);
-	head = &hs->hhash[idx % NETL_SUBSYS_HASH];
-	hlist_for_each_entry(ss, node, head, snode){
-		if(idx == ss->id){
-			spin_unlock_irqrestore(&hs->hs_lock, flags);
-			return ss;
-		}
-	}
-	spin_unlock_irqrestore(&hs->hs_lock, flags);
-	return NULL;
-}
-
-void stop_subsystem(struct pti_subsys *ss)
-{
-	unsigned long flags;
-	struct desc_ring *r;
-	int count = 0;
-	struct rx_struct *ret;
-
-	spin_lock_irqsave(&ss->slock, flags);
-	ss->flags |= (SUBSYS_FLAGS_TX_DISABLED | SUBSYS_FLAGS_RX_DISABLED);
-	/* logic is suspect : TODO
-	if(ss->pid == 0){
-		ss->flags |= SUBSYS_FLAGS_ORPHANED;
-	}
-	*/
-	spin_unlock_irqrestore(&ss->slock, flags);
-
-	/* subsys_poll_* nad dev_def_*_cmpl have higher priority
-	 * So, I assume that by now, it must have executed fully
-	 * TODO : if suspects a race, change to rwlocks...???
-	 */
-	/* Mark all Tx and any Rx bufs as dma complete */
-	r = ss->rxring;
-	spin_lock_irqsave(&r->rng_lock, flags);
-	r->end = r->start = pti_pci_read32((void *)r->head);
-	for(count = 0; count < NETL_NR_DESC; count++){
-		pti_pci_write32(0, (void *)&r->pdesc[count].pci_desc->dma_stat);
-	}
-	pti_pci_write32(r->start, (void *)r->tail);
-	spin_unlock_irqrestore(&r->rng_lock, flags);
-
-	r = ss->txring;
-	spin_lock_irqsave(&r->rng_lock, flags);
-	r->end = r->start = pti_pci_read32((void *)r->head);
-	for(count = 0; count < NETL_NR_DESC; count++){
-		pti_pci_write32(0, (void *)&r->pdesc[count].pci_desc->dma_stat);
-	}
-	pti_pci_write32(r->start, (void *)r->tail);
-	spin_unlock_irqrestore(&r->rng_lock, flags);
-	while(ss->rnum != 0){
-		if(get_packet_from_rxlist(ss, &ret) != 0){
-			break;
-		}
-		free_page((unsigned long) ret->iov.iov_base);
-		kfree(ret);
-	}
-	dealloc_this_subsystem(ss);
-	return;
-}
-
-int init_handshake_struct(struct handshake_struct *hs)
-{
-	int ret, i;
-	typedef int(*sp_init)(struct handshake_struct *);
-	sp_init specific_init;
-#ifdef NETL_PTI_HOST
-	extern int host_specific_hs_init(struct handshake_struct *hs);
-	specific_init = host_specific_hs_init;
-#else
-	extern int dev_specific_hs_init(struct handshake_struct *hs);
-	specific_init = dev_specific_hs_init;
-#endif
-	init_waitqueue_head(&hs->openq);
-	spin_lock_init(&hs->hs_lock);
-	netl_pti_debugfs_init(hs);
-	hs->hhash = kzalloc(sizeof(struct hlist_head) * NETL_SUBSYS_HASH, GFP_KERNEL);
-	if(!hs->hhash){
-		kfree(hs);
-		return -ENOMEM;
-	}
-	for(i = 0; i < NETL_SUBSYS_HASH; i++){
-		INIT_HLIST_HEAD(&(hs->hhash[i]));
-	}
-	init_MUTEX(&hs->hhsem);
-	INIT_DELAYED_WORK(&hs->hs_work, hs_work_func);
-	if((ret = specific_init(hs)) != 0){
-		kfree(hs->hhash);
-		return ret;
-	}
-	return 0;
-}
-
-struct pti_subsys *reserve_subsystem(int idx)
-{
-	struct handshake_struct *hs;
-	get_hs(&hs);
-	return hs->ss[idx];
-}
-EXPORT_SYMBOL(reserve_subsystem);
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti_dev.h b/drivers/misc/netlogic/pcie-offload/include/netl_pti_dev.h
deleted file mode 100644
index 8721f18..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti_dev.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef _NETL_PTI_H
-#define _NETL_PTI_H
-
-
-struct netl_pti_subsys {
-	int module_id;
-	int registered;
-	netl_pti_recv_handler *recv_handler;
-	netl_pti_alloc *alloc;
-	int desc_nr;
-	struct netl_pti_desc *rx_ring_start;
-	struct netl_pti_desc *tx_ring_start;
-	struct netl_pti_ring_info *rx_ring_info;
-	struct netl_pti_ring_info *tx_ring_info;
-	uint8_t *tx_ring_start_inband;
-	uint8_t *rx_ring_start_inband;
-	unsigned int free_processed;
-	struct free_list *free_list;
-#ifdef NETL_PTI_DEV
-	struct recv_list *recv_list;
-#endif
-	spinlock_t send_lock;
-	spinlock_t free_lock;
-};
-
-//Have two instances in case we need dev to host msgs
-struct netl_pti_handshake {
-	uint32_t ver;
-	uint32_t host_endianness;
-	uint32_t dev_endianness;
-	uint32_t max_subsys;
-	uint32_t subsys_id;
-	uint32_t sent_msg_seq;
-	uint32_t recv_msg_seq;
-	uint32_t ring_ptr_off;
-	uint32_t tx_ring_start_off;
-	uint32_t rx_ring_start_off;
-	uint32_t tx_ring_start_inband_off;
-	uint32_t rx_ring_start_inband_off;
-	uint64_t app_data;
-	uint32_t hs_type;
-};
-
-#ifdef NETL_PTI_DEV
-#define dtoh_16 dtoh_16_dev
-#define dtoh_32 dtoh_32_dev
-#define dtoh_64 dtoh_64_dev
-#define netl_pti_unregister       netl_pti_unregister_dev
-#endif
-#ifdef NETL_PTI_HOST
-#define dtoh_16 dtoh_16_host
-#define dtoh_32 dtoh_32_host
-#define dtoh_64 dtoh_64_host
-#define netl_pti_send_with_inband netl_pti_send_with_inband_host
-#define netl_pti_unregister netl_pti_unregister_host
-#define netl_pti_send_inband netl_pti_send_inband_host
-#define netl_pti_send netl_pti_send_host
-#define netl_pti_send_sg netl_pti_send_sg_host
-#define netl_pti_register_subsys netl_pti_register_subsys_host
-#define handshake_status handshake_status_host
-#endif
-
-extern int netl_pti_register_subsys(uint8_t subsys_id, int desc_nr,
-				    netl_pti_recv_handler * recv_handler,
-				    netl_pti_alloc * alloc);
-int netl_pti_send_with_inband(uint8_t subsys_id, uint8_t msg_code, void *mem,
-			      int len, void *inband_mem, int inband_len,
-			      netl_pti_free free_func, void *free_info
-#ifdef NETL_PTI_DEV
-			      , uint64_t dma_addr
-#endif
-    );
-extern int netl_pti_send_inband(uint8_t subsys_id, uint8_t msg_code,
-				void *inband_mem, int inband_len);
-int netl_pti_send(uint8_t subsys_id, uint8_t msg_code, void *mem, int len,
-		  netl_pti_free * free_func, void *free_info
-#ifdef NETL_PTI_DEV
-		  , uint64_t dma_addr
-#endif
-    );
-int netl_pti_send_sg(uint8_t subsys_id, uint8_t msg_code,
-		     struct scatterlist *sg_list, int len, void *inband_mem,
-		     int inband_len, netl_pti_free * free_func, void *free_info
-#ifdef NETL_PTI_DEV
-		     , uint64_t dma_addr
-#endif
-    );
-extern int handshake_status(void);
-
-#endif
diff --git a/drivers/misc/netlogic/pcie-offload/include/netl_pti_test.c b/drivers/misc/netlogic/pcie-offload/include/netl_pti_test.c
deleted file mode 100644
index 6fc962e..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/netl_pti_test.c
+++ /dev/null
@@ -1,195 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include "../include/netl_pti.h"
-
-int send_packets_back(struct pti_subsys *ss);
-extern int add_to_rxlist(struct pti_subsys *ss, struct kvec *iov);
-extern int get_packet_from_rxlist(struct pti_subsys *ss, struct rx_struct **ret);
-extern int send_one_packet_to_host(struct pti_subsys *ss, void *data, u32 len);
-extern int send_one_packet_to_device(struct pti_subsys *ss, void *data, u32 len);
-extern int get_hs_from_idx(struct handshake_struct **res, int idx);
-extern struct pti_subsys *get_ss_from_idx(struct handshake_struct *hs, int idx);
-int netl_test_write(struct pti_subsys *ss, u32 len, char fill);
-
-struct netl_test_struct{
-	u64 wait_tot;
-	u64 spent_tot;
-	u64 sent_bytes;
-	struct dentry *dbg_root;
-};
-static ulong bytes2send = (1 << 12);
-module_param(bytes2send, ulong, 0);
-MODULE_PARM_DESC(bytes2send, "Bytes to send in one try");
-
-struct netl_test_struct gstat;
-
-static ssize_t netl_dbg_test_write(struct file *filp, const char __user *buf,
-		size_t len, loff_t *off)
-{
-	struct handshake_struct *hs = NULL;
-	struct pti_subsys *ss;
-	ulong inp;
-
-	if((get_hs_from_idx(&hs, 0) < 0) || (hs == NULL)){
-		PDEBUG("Failed to get HS\n");
-		return -ENODEV;
-	}
-	ss = get_ss_from_idx(hs, 1);
-	if(ss == NULL){
-		PDEBUG("SS = NULL\n");
-		return -ENODEV;
-	}
-	inp = simple_strtoul(buf, NULL, 0);
-	if(inp > 0){
-		PDEBUG("Setting bytes2send to %#lx\n", inp);
-		bytes2send = inp;
-	}else if(inp == 0){
-		PDEBUG("Clearing stat\n");
-		gstat.wait_tot = 0;
-		gstat.spent_tot = 0;
-		gstat.sent_bytes = 0;
-		return len;
-	}
-	netl_test_write(ss, bytes2send, 'A');
-	return len;
-}
-
-static int netl_test_dbg_show(struct seq_file *seq, void *v)
-{
-	struct timespec ts;
-	struct netl_test_struct *stat = (struct netl_test_struct *)seq->private;
-
-	seq_printf(seq, "Sent : %llu\n", stat->sent_bytes);
-	jiffies_to_timespec(stat->spent_tot, &ts);
-	seq_printf(seq, "Total time took: %llu(%ld.%09ld)\n",
-			stat->spent_tot, ts.tv_sec, ts.tv_nsec);
-	jiffies_to_timespec(stat->wait_tot, &ts);
-	seq_printf(seq, "Wait time: %llu(%ld.%09ld)\n",
-			stat->wait_tot, ts.tv_sec, ts.tv_nsec);
-	return 0;
-}
-
-static int netl_test_dbg_open(struct inode *inode, struct file *filp)
-{
-	return single_open(filp, netl_test_dbg_show, inode->i_private);
-}
-
-struct file_operations netl_test_dbg_ops = {
-	.owner = THIS_MODULE,
-	.open = netl_test_dbg_open,
-	.llseek = seq_lseek,
-	.read = seq_read,
-	.release = single_release,
-	.write = netl_dbg_test_write,
-};
-int netl_dev_test_init(void)
-{
-	struct dentry *d = debugfs_create_dir("netltest", NULL);
-	PDEBUG("Compiled on %s %s\n", __DATE__, __TIME__);
-
-	if(!d || (IS_ERR(d) != 0)){
-		PDEBUG("Failed to create debugfs, d = %p\n", d);
-		return PTR_ERR(d);
-	}
-	gstat.dbg_root = d;
-	debugfs_create_file("input", S_IRUGO|S_IWUGO, gstat.dbg_root, &gstat, &netl_test_dbg_ops);
-	return 0;
-}
-
-void netl_dev_test_exit(void)
-{
-	debugfs_remove_recursive(gstat.dbg_root);
-}
-
-module_init(netl_dev_test_init);
-module_exit(netl_dev_test_exit);
-MODULE_LICENSE("GPL");
-typedef int (*send_func)(struct pti_subsys *, void *, u32);
-
-int netl_test_write(struct pti_subsys *ss, u32 len, char fill)
-{
-	void *kpage = 0;
-	int ret = 0;
-	int len2s = 0, sent = 0;
-	int written = 0;
-	unsigned long beg, end, wbeg = 0, wend = 0;
-
-#ifdef NETL_PTI_HOST
-	send_func send_packet = send_one_packet_to_device;
-#else
-	send_func send_packet = send_one_packet_to_host;
-#endif
-
-	if(ss->hs->status != HS_DEV_READY_TXRX){
-		return -EIO;
-	}
-	/* split up the incoming packet
-	 * write(2) should succeed even if only one byte is written */
-	beg = jiffies;
-	while(sent != len){
-		len2s = ((len - sent) > NETL_BUFSIZE) ? NETL_BUFSIZE: (len - sent);
-		//PDEBUG("len2s = %#x\n", len2s);
-		kpage = (void *)__get_free_page(GFP_KERNEL);
-		if(!kpage){
-			ret = -ENOMEM;
-			break;
-		}
-		memset(kpage, fill, NETL_BUFSIZE);
-		//PDEBUG("Sending packet on ss->id %#x\n", ss->id);
-		ret = send_packet(ss, kpage, len2s);
-		if(ret == 0){
-			//PDEBUG("Sent one packet\n");
-			written = 1;
-			sent += len2s;
-			continue;
-		}
-		if(ret == EAGAIN){
-			//PDEBUG("Waiting\n");
-			free_page((unsigned long)kpage);
-			/* Else add to ss->wrq and wait */
-			wbeg = jiffies;
-			if(wait_event_interruptible(ss->wrq, (ss->txring->nfree != 0))){
-				ret = -ERESTARTSYS;
-				break;
-			}
-			wend = jiffies;
-			gstat.wait_tot += ((long)wend - (long)wbeg);
-		}else{
-			PDEBUG("Sent fail\n");
-			free_page((unsigned long)kpage);
-			break;
-		}
-	}
-	end = jiffies;
-	gstat.spent_tot += ((long)end - (long)beg);
-	gstat.sent_bytes += sent;
-	PDEBUG("sent bytes %#x, jiffies spent = %#lx, waited %#lx\n",
-			sent, ((long)end - (long)beg), ((long)wend - (long)wbeg));
-	return((written == 0) ? ret : sent);
-}
diff --git a/drivers/misc/netlogic/pcie-offload/include/nlm_pcieip.h b/drivers/misc/netlogic/pcie-offload/include/nlm_pcieip.h
deleted file mode 100644
index 5a87b84..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/nlm_pcieip.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef NLM_PCIEIP_H
-#define NLM_PCIEIP_H
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/socket.h>
-#include <linux/errno.h>
-#include <linux/fcntl.h>
-#include <linux/in.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/workqueue.h>
-#include <linux/inet.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/sock.h>
-#include <linux/if_ether.h>	/* For the statistics structure. */
-#include <linux/if_arp.h>	/* For ARPHRD_ETHER */
-#include <linux/proc_fs.h>
-#include <linux/version.h>
-#include <linux/spinlock.h>
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/io.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <asm/uaccess.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/signal.h>
-#include <linux/poll.h>
-#include <asm/bitops.h>
-#include <asm/system.h>
-#include <asm/cache.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-
-#ifndef CONFIG_NLM_XLP
-#define fdebug(fmt,arg...)\
-	printk(KERN_WARNING "%s:%d " fmt, __FILE__, __LINE__, ##arg)
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
-#include <generated/autoconf.h>
-#else
-#include <linux/autoconf.h>
-#endif
-
-#ifdef CONFIG_NLM_XLP
-#include <asm/netlogic/debug.h>
-#include <asm/netlogic/pci.h>
-#include <asm/netlogic/pic.h>
-#include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/msgring.h>
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/proc.h>
-#include <asm/netlogic/nlm_pcix_gen_dev.h>
-#include <asm/netlogic/nlm_dma.h>
-#include <nlm_dma.h>
-#endif
-#include <netl_pti.h>
-
-int pcieip_receive_skbuff(struct sk_buff *skb, void (*func)(void *,uint64_t),void *data);
-int pcieip_send_skbuff(struct sk_buff *skb, void (*func)(void *,uint64_t),void *data);
-extern int get_packet_from_rxlist(struct pti_subsys *ss, struct rx_struct **ret);
-#define DRV_NAME	"nlm_pcieip"
-#define DRV_VERSION	"0.95"
-#define DRV_RELDATE	"22dec2011"
-
-#define NLM_SMP_CACHE_BYTES		32
-#define PCIEIP_MAX_RXLEN		1536
-#define PCIEIP_FLAG_MSI_ENABLED		(0x1 << 0)
-#define PCIEIP_FLAG_EXITING		(0x1 << 2)
-#define PCIEIP_SKB_ALLOC_SIZE		(1536 + 32 + 32)
-#define PCIEIP_PTI_SUBSYS		1
-#define PCIEIP_MIN_RXLEN		(20)
-struct driver_data {
-	struct net_device *ndev;
-	spinlock_t lock;
-	struct net_device_stats stats;
-	struct delayed_work poll_work;
-	struct dentry *dbgf;
-	u32 poll_delay;
-	struct pti_subsys *ss;
-	u32 flags;
-};
-
-#endif	// NLM_PCIEIP_H
diff --git a/drivers/misc/netlogic/pcie-offload/include/perf.h b/drivers/misc/netlogic/pcie-offload/include/perf.h
deleted file mode 100644
index d4a3ffa..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/perf.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#ifndef _NETL_PERF_H
-#define _NETL_PERF_H
-#include "netl_pti.h"
-#include "netl_pti_char.h"
-#define NETL_FILE_MAXLEN	512
-static inline int Read(int fd, void *buf, int total)
-{
-	int ret = 0, rd = 0, bal = total;
-	char *start = (char *)buf;
-
-	while(rd < total){
-		ret = read(fd, (void *)start, bal);
-		if(ret < 0){
-			return ret;
-		}
-		bal -= ret; rd += ret; start += ret;
-	}
-	return rd;
-}
-
-static inline int Write(int fd, void *buf, int total)
-{
-	int ret = 0, rd = 0, bal = total;
-	char *start = (char *)buf;
-
-	while(rd < total){
-		ret = write(fd, (void *)start, bal);
-		if(ret < 0){
-			return ret;
-		}
-		bal -= ret; rd += ret; start += ret;
-	}
-	return rd;
-}
-
-#endif		/* _NETL_PERF_H */
diff --git a/drivers/misc/netlogic/pcie-offload/include/redirect.c b/drivers/misc/netlogic/pcie-offload/include/redirect.c
deleted file mode 100644
index 7e672b8..0000000
--- a/drivers/misc/netlogic/pcie-offload/include/redirect.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- * 
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * #BRCM_2# */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
-void usage(char **argv)
-{
-	fprintf(stderr, "%s <infile> <outfile>\n", argv[0]);
-	return;
-}
-
-int main(int argc, char **argv)
-{
-	int in, out;
-	char *inf, *outf;
-	int ret;
-	struct stat s;
-	off_t buf_sz;
-	char *buf;
-
-	if(argc != 3){
-		usage(argv);
-		exit(-1);
-	}
-	inf = argv[1];
-	outf = argv[2];
-	in = open(inf, O_RDONLY);
-	if(in < 0){
-		perror("Failed to open infile");
-		exit(-1);
-	}
-	out = open(outf, O_WRONLY|O_TRUNC|O_CREAT);
-	if(out < 0){
-		perror("Failed to open ");
-		exit(-1);
-	}
-	ret = fstat(in, &s);
-	if(ret < 0){
-		perror("Cannot stat ");
-		exit(-1);
-	}
-	buf_sz = s.st_size > 4096 ? s.st_size : 4096;
-	buf = malloc(sizeof(char) * buf_sz);
-	memset(buf, 0, sizeof(char) * buf_sz);
-	read(in, buf, 4096);
-	close(in);
-	while(1){
-		write(out, buf, 4096);
-	}
-	close(out);
-	return;
-}
diff --git a/drivers/misc/netlogic/pcie-offload/net/device/Kbuild b/drivers/misc/netlogic/pcie-offload/net/device/Kbuild
deleted file mode 100644
index 56f6efd..0000000
--- a/drivers/misc/netlogic/pcie-offload/net/device/Kbuild
+++ /dev/null
@@ -1,5 +0,0 @@
-EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL	-I$(src)/../../include -DCONFIG_NLM_PCIEIP_DEV
-# EXTRA_CFLAGS += -DCONFIG_HOST_NOIRQ
-
-obj-m += pcieip.o
-pcieip-y := pcieip_common.o
diff --git a/drivers/misc/netlogic/pcie-offload/net/device/Makefile b/drivers/misc/netlogic/pcie-offload/net/device/Makefile
deleted file mode 100644
index ff626e2..0000000
--- a/drivers/misc/netlogic/pcie-offload/net/device/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-# Just the make file.
-# Moved all module specific build instructions to Kbuild
-#
-PWD = $(shell pwd -L)
-KERNELDIR := $(shell readlink -fn $(PWD)/../../../../../linux/)
-ROOTFS_DIR = $(shell readlink -fn $(KERNELDIR)/usr/rootfs.xlp/)
-CTAGS = /usr/bin/ctags
-CSCOPE = /usr/bin/cscope
-
-all: modules
-
-modules:
-	$(MAKE) -C $(KERNELDIR) M=$(PWD) $@
-
-modules_install: modules
-	make -C $(KERNELDIR) M=$(PWD) modules_install INSTALL_MOD_PATH=$(ROOTFS_DIR)
-
-help:
-	make -C $(KERNELDIR) M=$(PWD) help
-
-cscope:
-	$(CSCOPE) $(CSCOPEFLAGS) -R  -s ../dma/
-
-tags:
-	$(CTAGS) pcieip_common.c pcieip_dev.c ../../include/nlm_pcieip.h
-
-clean:
-	make -C $(KERNELDIR) M=$(PWD) clean
-	rm -rf *.o *.mod.* *.ko *.o.p *.i
-
-distclean: clean
-	rm -rf cscope*
-	rm -rf tags
-
-.PHONY: help cscope tags clean distclean image install
diff --git a/drivers/misc/netlogic/pcie-offload/net/device/pcieip_common.c b/drivers/misc/netlogic/pcie-offload/net/device/pcieip_common.c
deleted file mode 100644
index 43e86f3..0000000
--- a/drivers/misc/netlogic/pcie-offload/net/device/pcieip_common.c
+++ /dev/null
@@ -1,277 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <nlm_pcieip.h>
-
-void put_dummy_mac_address(struct net_device *dev);
-int process_rx_dev(struct driver_data *priv);
-irqreturn_t ip_over_pci_rx (int unused, void *data);
-int pcieip_start_xmit(struct sk_buff *skb,struct net_device *ndev);
-static int poll_delay = 0;
-module_param(poll_delay, int, 0);
-MODULE_PARM_DESC(poll_delay, "Delay in jiffies between status polls\n");
-
-#ifndef CONFIG_NLM_PCIEIP_HOST
-extern int xlp_ctrl_fn_from_dev(const struct pci_dev *);
-#endif
-struct net_device *gndev;
-
-/*
- * Device specific allocation routine
- *
- * @size	: size to allocate
- * @flags	: flags to honor while allocating
- */
-struct sk_buff *pcieip_alloc_skb(u32 size, u32 flags)
-{
-	struct sk_buff *skb;
-	unsigned long offset;
-
-	skb = dev_alloc_skb(size);
-	if(!skb){
-		fdebug("SKB Allocation Failed");
-		return NULL;
-	}
-	offset = ((u64)skb->data + NLM_SMP_CACHE_BYTES) &
-			~(NLM_SMP_CACHE_BYTES - 1);
-	skb_reserve(skb,NLM_SMP_CACHE_BYTES + 2);
-	skb_reserve(skb, (offset - (unsigned long)skb->data));
-	return skb;
-}
-
-void temp_int_func(struct work_struct *w)
-{
-	struct driver_data *priv = container_of(w, struct driver_data, poll_work.work);
-	process_rx_dev(priv);
-	if (unlikely(priv->flags & PCIEIP_FLAG_EXITING)) {
-		return;
-	}
-	schedule_delayed_work(&priv->poll_work, priv->poll_delay);
-}
-
-/*
- * Standard open
- */
-static int pcieip_open(struct net_device *dev)
-{
-	netif_start_queue(dev);
-	return 0;
-}
-
-/*
- * Standard stop
- */
-static int pcieip_stop(struct net_device *dev)
-{
-	netif_stop_queue(dev);
-	return 0;
-}
-
-static struct net_device_stats* pcieip_get_stats(struct net_device *dev)
-{
-	return &(((struct driver_data *)(netdev_priv(dev)))->stats);
-}
-
-struct net_device_ops nlm_ops;
-
-/*
- * Setup net device operations
- */
-static void setup_net_ops(struct net_device *dev)
-{
-	nlm_ops.ndo_open = pcieip_open;
-	nlm_ops.ndo_stop = pcieip_stop;
-	nlm_ops.ndo_get_stats = pcieip_get_stats;
-	nlm_ops.ndo_start_xmit = pcieip_start_xmit;
-	dev->netdev_ops = &nlm_ops;
-	dev->flags |= IFF_NOARP;
-	dev->features |= NETIF_F_NO_CSUM;
-}
-
-/*
- * Initialize the device
- * @dev		: pci_dev struture
- * @start	: usable start address of the shared memory
- *			Must be ioremap_noache()-ed
- */
-int pcieip_init(struct pci_dev *pdev, volatile void *start)
-{
-	__label__ fail_register;
-	struct net_device *ndev = 0;
-	struct driver_data *priv = 0;
-	int ret = 0;
-
-	gndev = ndev = alloc_etherdev(sizeof(struct driver_data));
-	if (!ndev) {
-		return -ENOMEM;
-	}
-	priv = netdev_priv(ndev);
-	priv->ndev = ndev;	/* struct net_device corresponding to this */
-	spin_lock_init(&priv->lock);
-	put_dummy_mac_address(ndev);
-	ether_setup(ndev);
-	setup_net_ops(ndev);
-	priv->poll_delay = poll_delay;
-	priv->ss = reserve_subsystem(PCIEIP_PTI_SUBSYS);
-	ret = register_netdev(ndev);
-	if (ret < 0) {
-		fdebug("Failed to register ndev\n");
-		goto fail_register;
-	}
-	INIT_DELAYED_WORK(&priv->poll_work, temp_int_func);
-	schedule_delayed_work(&priv->poll_work, 10);
-	return ret;
-fail_register:
-	free_netdev(ndev);
-	return -ENODEV;
-}
-
-/*
- * Process rx on device
- *
- * @priv	: driver_data
- */
-int process_rx_dev(struct driver_data *priv)
-{
-	__label__ rx_errors;
-	struct sk_buff *skb;
-	unsigned long flags;
-	struct rx_struct *pkt;
-	int status;
-
-	skb = pcieip_alloc_skb(PCIEIP_SKB_ALLOC_SIZE, 0);
-	if (skb == NULL) {
-		return -ENOMEM;
-	}
-	if (get_packet_from_rxlist(priv->ss, &pkt) < 0) {
-		dev_kfree_skb(skb);
-		return -EAGAIN;
-	}
-	if (pkt->iov.iov_len > PCIEIP_MAX_RXLEN) {
-		priv->stats.rx_over_errors++;
-		goto rx_errors;
-	} else if (pkt->iov.iov_len < PCIEIP_MIN_RXLEN) {
-		priv->stats.rx_length_errors++;
-		goto rx_errors;
-	}
-	memcpy(skb->data, pkt->iov.iov_base, pkt->iov.iov_len);
-	skb_put(skb, pkt->iov.iov_len);
-	skb->dev = priv->ndev;
-	skb->protocol = eth_type_trans(skb, skb->dev);
-	skb->ip_summed = CHECKSUM_UNNECESSARY;
-	priv->stats.rx_packets++;
-	priv->stats.rx_bytes += skb->len;
-	if((status = netif_rx(skb)) == NET_RX_DROP){
-		fdebug("Sending up failed %d",status);
-		priv->stats.rx_dropped++;
-	}
-	free_page((unsigned long)pkt->iov.iov_base);
-	kfree(pkt);
-	return 0;
-rx_errors:
-	free_page((unsigned long)pkt->iov.iov_base);
-	kfree(pkt);
-	priv->stats.rx_errors++;
-	return -EAGAIN;
-}
-
-/*
- * Dummy mac address
- *
- * @dev		: net_device structure
- */
-void put_dummy_mac_address(struct net_device *dev)
-{
-	dev->dev_addr[0] = 0x0;
-	dev->dev_addr[1] = 0xb;
-	dev->dev_addr[2] = 0x0;
-	dev->dev_addr[3] = 0xb;
-	dev->dev_addr[4] = 0x0;
-	dev->dev_addr[5] = 0xb;
-}
-
-/*
- * Send data to other end
- *
- * @skb		: skb to send
- * @ndev	: net_device structure
- */
-netdev_tx_t pcieip_start_xmit(struct sk_buff *skb,struct net_device *ndev)
-{
-	//unsigned long mflags;
-	struct driver_data *priv = netdev_priv(ndev);
-	unsigned long page = get_zeroed_page(GFP_ATOMIC);
-
-	if (page == 0) {
-		return -ENOMEM;
-	}
-	if (skb->len > PCIEIP_SKB_ALLOC_SIZE) {
-		fdebug("Max rx len(%d) < skb->len(%d)\n", 1536, skb->len);
-		return NETDEV_TX_BUSY;
-	}
-	/* Queue up the DMA transfer */
-	memcpy((void *)page, skb->data, skb->len);
-#ifdef CONFIG_NLM_PCIEIP_HOST
-	send_one_packet_to_device(priv->ss, page, skb->len);
-#else
-	send_one_packet_to_host(priv->ss, page, skb->len);
-#endif
-	priv->stats.tx_packets++;
-	priv->stats.tx_bytes += skb->len;
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-
-int __init xlp_pcieip_init(void)
-{
-	fdebug("Compiled on %s %s\n", __DATE__, __TIME__);
-	if (pcieip_init(NULL, NULL) < 0) {
-		return -EFAULT;
-	}
-	return 0;
-}
-
-void __exit xlp_pcieip_exit(void)
-{
-	struct driver_data *priv = netdev_priv(gndev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	priv->flags |= PCIEIP_FLAG_EXITING;
-	spin_unlock_irqrestore(&priv->lock, flags);
-	cancel_delayed_work_sync(&priv->poll_work);
-	unregister_netdev(gndev);
-	free_netdev(gndev);
-	gndev = NULL;
-	fdebug("Exiting nlm_pcie\n");
-}
-
-module_init(xlp_pcieip_init);
-module_exit(xlp_pcieip_exit);
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/netlogic/pcie-offload/net/host/Makefile b/drivers/misc/netlogic/pcie-offload/net/host/Makefile
deleted file mode 100644
index 8aa428e..0000000
--- a/drivers/misc/netlogic/pcie-offload/net/host/Makefile
+++ /dev/null
@@ -1,35 +0,0 @@
-CSCOPE = $(shell which cscope)
-CSCOPEFLAGS = -bvkq -R
-CTAGS = $(shell which ctags)
-#if host needs to send data (for testing) to device uncomment next line
-ifeq ($(KDIR),)
-	KDIR := /lib/modules/$(shell uname -r)/build
-endif
-# EXTRA_CFLAGS += -DNETL_PTI_TEST
-ifneq ($(KERNELRELEASE),)
-EXTRA_CFLAGS := -I$(src)/../../include -g -DCONFIG_NLM_PCIEIP_HOST -DCONFIG_HOST_NOIRQ
-obj-m += pcieip.o
-pcieip-y := pcieip_common.o
-else
-modules:
-	make -C $(KDIR) M=$(PWD) modules
-
-all: module
-
-help:
-	make -C $(KDIR) M=$(PWD) help
-
-cscope:
-	$(CSCOPE) $(CSCOPEFLAGS)
-
-tags:
-	$(CTAGS) pcieip_host.c pcieip_common.c ../../include/{nlm_pcie.h,nlm_pcieip.h}
-
-clean:
-	make -C $(KDIR) M=$(PWD) clean
-	rm -rf *.o *.mod.* *.ko
-distclean: clean
-	rm -rf cscope*
-	rm -rf tags
-.PHONY: help cscope tags clean distclean
-endif
diff --git a/drivers/misc/netlogic/pcie-offload/setup_dev.sh b/drivers/misc/netlogic/pcie-offload/setup_dev.sh
deleted file mode 100755
index b987274..0000000
--- a/drivers/misc/netlogic/pcie-offload/setup_dev.sh
+++ /dev/null
@@ -1,57 +0,0 @@
-#! /bin/bash
-/usr/bin/which mips64-nlm-linux-gcc > /dev/null 2>&1
-if [ $? != 0 ]; then
-	echo "No cross compiler found. source build.sh before proceeding"
-	exit -1
-fi
-
-SCRIPT_PATH=$(readlink -f "${BASH_SOURCE[0]}")
-echo $SCRIPT_PATH
-if ([ -e "${SCRIPT_PATH}" ]); then
-	NETL_OFFLOAD_SRC=$(readlink -fn "$(dirname ${SCRIPT_PATH})")
-fi
-
-SRCDIR="${NETL_OFFLOAD_SRC}/char/device/"
-if [ "${TGDIR}" == "" ] ; then
-TGDIR=$(readlink -f "${NETL_OFFLOAD_SRC}/../../../linux/usr/rootfs.xlp")
-fi
-
-function make_and_check_charlinks {
-	pushd "${1}" > /dev/null
-	ln -sf  ${NETL_OFFLOAD_SRC}/include/netl_pti_char.c "${1}"
-	ln -sf  ${NETL_OFFLOAD_SRC}/include/netl_pti_char.h "${1}"
-	ln -sf  ${NETL_OFFLOAD_SRC}/include/netl_pti_common.c "${1}"
-	ln -sf  ${NETL_OFFLOAD_SRC}/include/netl_pti.h "${1}"
-	popd > /dev/null
-
-	if [ -h "${1}"/netl_pti_char.c ] ||
-		[ -h "${1}"/netl_pti_char.h ] ||
-		[ -h "${1}"/netl_pti_common.c ] ||
-		[ -h "${1}"/netl_pti.h ] ; then
-		return 0
-	fi
-	return -1
-}
-
-# check if links are created
-make_and_check_charlinks "${SRCDIR}"
-
-if [ "$?" != "0" ] ; then
-	echo "REQUIRED links are not created. Exiting"
-	exit -1
-fi
-
-if [ "$START_BUILD" != "0" ] ; then
-	echo "Starting build process for character device..."
-	pushd "${NETL_OFFLOAD_SRC}/char/device/" > /dev/null &&
-	make clean &&\
-	make modules &&\
-	make modules_install INSTALL_MOD_PATH="${TGDIR}" &&
-	popd > /dev/null
-	echo "Starting build process for net device ..."
-	pushd "${NETL_OFFLOAD_SRC}/net/device/" > /dev/null &&
-	make clean &&\
-	make modules &&\
-	make modules_install INSTALL_MOD_PATH="${TGDIR}" &&
-	popd > /dev/null
-fi
diff --git a/drivers/misc/netlogic/pcie-offload/setup_host.sh b/drivers/misc/netlogic/pcie-offload/setup_host.sh
deleted file mode 100755
index d45d920..0000000
--- a/drivers/misc/netlogic/pcie-offload/setup_host.sh
+++ /dev/null
@@ -1,59 +0,0 @@
-#! /bin/bash
-SCRIPT_PATH=$(readlink -f "${BASH_SOURCE[0]}")
-if ([ -e "${SCRIPT_PATH}" ]); then
-	NETL_OFFLOAD_SRC=$(readlink -fn "$(dirname ${SCRIPT_PATH})")
-fi
-
-function make_and_check_links {
-	pushd "${1}/char/host/" > /dev/null
-	ln -sf  ../../include/netl_pti_char.c
-	ln -sf  ../../include/netl_pti_char.h
-	ln -sf  ../../include/netl_pti_common.c
-	ln -sf  ../../include/netl_pti.h
-
-	if [ -h ./netl_pti_char.c ] || [ -h ./netl_pti_char.h ] ||
-		[ -h ./netl_pti_common.c ] || [ -h ./netl_pti.h ] ; then
-			popd > /dev/null
-			return 0
-	fi
-	popd > /dev/null
-	return -1
-}
-
-function make_and_check_net_links {
-	pushd "${1}/net/host/" > /dev/null
-	ln -sf ../device/pcieip_common.c
-	if [ -h ./pcieip_common.c ] ; then
-		popd > /dev/null
-		return 0
-	fi
-	popd > /dev/null
-	return -1
-}
-
-KDIR="${1}"
-if [ "${KDIR}" == "" ] ; then
-	echo "Please specify kernel source directory"
-	echo "$0 <path/to/host/kernel/source>"
-	exit -1
-fi
-
-# check if links are created
-make_and_check_links "${NETL_OFFLOAD_SRC}"
-
-if [ "$?" != "0" ] ; then
-	echo "REQUIRED links are not created in char. Exiting"
-fi
-make_and_check_net_links  "${NETL_OFFLOAD_SRC}"
-if [ "$?" != "0" ] ; then
-	echo "REQUIRED links are not created in net. Exiting"
-fi
-
-echo "Starting build process..."
-pushd "${NETL_OFFLOAD_SRC}/char/host/" > /dev/null
-make modules KDIR="${KDIR}"
-popd > /dev/null
-
-pushd "${NETL_OFFLOAD_SRC}/net/host/" > /dev/null
-make modules KDIR="${KDIR}"
-popd > /dev/null
-- 
1.7.1

