From 5f6af68e495bbe43c3770f175433cca24315a364 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Fri, 11 Apr 2014 16:24:07 +0530
Subject: SD: driver for XLP SD/MMC slots

PCI driver for SD/MMC slots. Handles XLP quirks.
[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9ab8f8d..b9146ef 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -260,6 +260,17 @@ config MMC_SDHCI_BCM2835
 
 	  If unsure, say N.
 
+config MMC_SDHCI_XLP
+       tristate "Netlogic XLP SD Interface support"
+       depends on MMC_SDHCI && CPU_XLP && PCI
+       help
+         This option enables support for the SD Host Controller Interface
+         on Netlogic XLP MIPS SoC.
+
+         If you have a XLP platform with a MMC slots, say Y or M here.
+
+         If unsure, say N.
+
 config MMC_OMAP
 	tristate "TI OMAP Multimedia Card Interface support"
 	depends on ARCH_OMAP
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index cd32280..29f41ea 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_MMC_SDHCI_PXAV2)	+= sdhci-pxav2.o
 obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_SDHCI_SIRF)   	+= sdhci-sirf.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
+obj-$(CONFIG_MMC_SDHCI_XLP)	+= sdhci-xlp.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
new file mode 100644
index 0000000..8bb0c01
--- /dev/null
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#include "sdhci.h"
+
+#define XLP_SLOT_SIZE		0x100
+#define XLP_NUM_SD_SLOT		2
+
+#define nlm_get_mmc_pcibase(node)	\
+	nlm_pcicfg_base(cpu_is_xlp9xx() ?  XLP9XX_IO_MMC_OFFSET(node) : \
+						XLP_IO_MMC_OFFSET(node))
+#define nlm_get_mmc_regbase(node)	\
+			(nlm_get_mmc_pcibase(node) + XLP_IO_PCI_HDRSZ)
+
+#define nlm_get_mmcsd_regbase(node, slot) \
+		(nlm_get_mmc_regbase(node) + slot * XLP_SLOT_SIZE)
+
+struct sdhci_xlp_chip {
+	struct pci_dev		*pdev;
+	struct sdhci_host	*host[XLP_NUM_SD_SLOT];
+};
+
+/* Setting XLP device and Vendor IDs */
+static const struct pci_device_id xlp_pci_ids[] = {
+	{
+		.vendor         = PCI_VENDOR_NETLOGIC,
+		.device         = PCI_DEVICE_ID_NLM_MMC,
+		.subvendor      = PCI_ANY_ID,
+		.subdevice      = PCI_ANY_ID,
+	},
+	{
+		.vendor         = PCI_VENDOR_ID_BROADCOM,
+		.device         = PCI_DEVICE_ID_XLP9XX_MMC,
+		.subvendor      = PCI_ANY_ID,
+		.subdevice      = PCI_ANY_ID,
+	},
+};
+
+static unsigned int xlp_get_max_clock(struct sdhci_host *sd_host)
+{
+	/*
+	 * SDHCI_CAPABILITIES[15:8] register gives 0x00 instead of 0x85(133)
+	 * on xlp2xx B0 and xlp9xx chips. Forcibly returning 133MHz.
+	 */
+	return 133000000;
+}
+static struct sdhci_ops xlp_sdhci_ops = {
+	.get_max_clock = xlp_get_max_clock,
+};
+
+static int sdhci_xlp_probe_slot(struct pci_dev *pdev,
+					struct sdhci_xlp_chip *chip, int sltno)
+{
+	struct sdhci_xlp_chip *chip_sd;
+	struct sdhci_host *sd_host;
+	int ret;
+
+	sd_host = sdhci_alloc_host(&pdev->dev, sizeof(struct sdhci_xlp_chip));
+	if (IS_ERR(sd_host)) {
+		dev_err(&pdev->dev, "sdhci_alloc_host() failed!\n");
+		return -ENODEV;
+	}
+
+	chip_sd = sdhci_priv(sd_host);
+	chip->host[sltno] = sd_host;
+	chip_sd->pdev = chip->pdev;
+
+	sd_host->hw_name = "xlp-mmc";
+	sd_host->ops = &xlp_sdhci_ops;
+	sd_host->irq = pdev->irq;
+
+	/*
+	 * The capabilities register reports block size as 3 for 4096,
+	 * force it to 2048.
+	 * The cmd and data lines are not getting cleared by hardware on writing
+	 * 0x2 and 0x4 to MMC_SWRESET [2,1] register, if the card is not present
+	 * in the slot.
+	 * Avoid reset if the card is not present.
+	 */
+	sd_host->quirks = SDHCI_QUIRK_FORCE_BLK_SZ_2048 |
+				SDHCI_QUIRK_NO_CARD_NO_RESET;
+
+	ret = pci_request_region(pdev, sltno, mmc_hostname(sd_host->mmc));
+	if (ret) {
+		dev_err(&pdev->dev, "can't request region\n");
+		goto err1;
+	}
+
+	sd_host->ioaddr = devm_ioremap(&pdev->dev,
+					pci_resource_start(pdev, sltno),
+					pci_resource_len(pdev, sltno));
+	if (!sd_host->ioaddr) {
+		dev_err(&pdev->dev, "failed to remap registers\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	/* Registering host */
+	ret = sdhci_add_host(sd_host);
+	if (ret) {
+		dev_err(&pdev->dev, "sdhci_add_host() failed\n");
+		goto err0;
+	}
+
+	return 0;
+
+err0:
+	pci_release_region(pdev, sltno);
+err1:
+	sdhci_free_host(sd_host);
+	return ret;
+}
+
+static int sdhci_xlp_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	struct sdhci_xlp_chip *chip;
+	struct resource res;
+	void __iomem *sys_addr;
+	int ret, slotno, node;
+
+	if (cpu_is_xlp9xx())
+		node = PCI_FUNC(pdev->bus->self->devfn);
+	else
+		node = PCI_SLOT(pdev->devfn) / 8;
+
+	chip = kzalloc(sizeof(struct sdhci_xlp_chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "pci_enable_device() failed!\n");
+		kfree(chip);
+		return ret;
+	}
+
+	pdev->irq = nlm_irq_to_xirq(node, PIC_MMC_IRQ);
+	chip->pdev = pdev;
+	pci_set_drvdata(pdev, chip);
+
+	/*
+	 * Enable slots.
+	 * Get system control base, node set to zero.
+	 * TODO: node need to be taken care on multinode case.
+	 */
+	res.start = CPHYSADDR(nlm_get_mmcsd_regbase(node, 2));
+	sys_addr = devm_ioremap(&pdev->dev, res.start, 0x28);
+	if (!sys_addr) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	writel(0x1C, sys_addr);
+
+	/*
+	 * The XLP MMC/SD controller has two slots. The registers for the
+	 * slots are at fixed location in the PCIe ECFG space, and not
+	 * in any PCI BARs.
+	 */
+	for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+		pdev->resource[slotno].flags = IORESOURCE_MEM;
+		pdev->resource[slotno].start =
+			CPHYSADDR(nlm_get_mmcsd_regbase(node, slotno));
+		pdev->resource[slotno].end = pdev->resource[slotno].start +
+						XLP_SLOT_SIZE - 1;
+
+		ret = sdhci_xlp_probe_slot(pdev, chip, slotno);
+		if (ret)
+			dev_err(&pdev->dev, "failed to probe slot%d\n", slotno);
+	}
+
+	return 0;
+
+err:
+	pci_disable_device(pdev);
+	kfree(chip);
+	return ret;
+}
+
+static void sdhci_xlp_remove(struct pci_dev *pdev)
+{
+	struct sdhci_xlp_chip *chip;
+	int slotno, dead;
+	u32 scratch;
+
+	chip = pci_get_drvdata(pdev);
+	if (chip) {
+		for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+			scratch = readl(chip->host[slotno]->ioaddr +
+					SDHCI_INT_STATUS);
+			if (scratch == (u32)-1)
+				dead = 1;
+
+			sdhci_remove_host(chip->host[slotno], dead);
+			pci_release_region(pdev, slotno);
+			sdhci_free_host(chip->host[slotno]);
+		}
+		pci_set_drvdata(pdev, NULL);
+	}
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver sdhci_xlp_driver = {
+	.name		= "sdhci-xlp",
+	.id_table	= xlp_pci_ids,
+	.probe		= sdhci_xlp_probe,
+	.remove		= sdhci_xlp_remove,
+};
+
+module_pci_driver(sdhci_xlp_driver);
+
+MODULE_AUTHOR("Kamlakant Patel <kamlakant.patel@broadcom.com>");
+MODULE_DESCRIPTION("SDHCI Driver for Netlogic XLP");
+MODULE_LICENSE("GPL v2");
-- 
1.7.1

