From 7133b7d8311bc7982e36cbf2370c085608237b11 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Sun, 2 Jun 2013 18:21:32 -0700
Subject: nae-1 supported.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 2babd03..9e88e8b 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -569,7 +569,8 @@ void nlm_hal_enable_vc_intr(int node, int vc)
 	uint64_t val = 0;
 	if (is_nlm_xlp9xx()) {
 		val =  (0ULL << 7) | (0x2ULL << 5) | (0x0ULL << 2) | (0x1ULL << 0);
-		*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = val;
+		//*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = val;
+		nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 13) + (vc << 3), val);
 	} else {
 		val = nlm_hal_read_outq_config(node, vc);
 		val &= ~((0x7ULL<<56) | (0x3ULL<<54) | (0x7ULL<<51) | (0x3ULL<<49));
@@ -585,7 +586,8 @@ void nlm_hal_disable_vc_intr(int node, int vc)
 {
 	uint64_t val = 0;
 	if (is_nlm_xlp9xx()) {
-		*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+		//*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+		nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 13) + (vc << 3), 0);
 	} else {
 		val = nlm_hal_read_outq_config(node, vc);
 		val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
@@ -760,11 +762,18 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 #else
 							credits = 50;
 #endif
+							nlh_write_cfg_reg64(xlp_fmn_base[0] + (1 << 14), 
+								(0ULL << 42) /* type, credit value + 1 */
+								| (credits << 26) /* credit count */
+								| ((qid | (dst_node << 10)) << 13) /* destination */
+								| (base_vc | (node << 10)) ); /* source */
+				#if 0
 							*(uint64_t *)(xlp_fmn_base[0] + (1 << 14)) =
 								(0ULL << 42) /* type, credit value + 1 */
 								| (credits << 26) /* credit count */
 								| ((qid | (dst_node << 10)) << 13) /* destination */
 								| (base_vc | (node << 10)); /* source */
+				#endif
 						}
 					}
 				}
@@ -1001,12 +1010,14 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 				val = val | (1ULL << 51);
 
 				/* configure */
-				*(uint64_t *)(xlp_fmn_base[node] + (qid << 3)) = val;
+				//*(uint64_t *)(xlp_fmn_base[node] + (qid << 3)) = val;
+				nlh_write_cfg_reg64(xlp_fmn_base[0] + (qid << 3), val);
 
 				/* disable interrupt by default, interrupt will be
 				 * enabled by respective OS configuration if needed.
 				 */
-				*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (qid << 3)) = 0x0;
+				//*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (qid << 3)) = 0x0;
+				nlh_write_cfg_reg64(xlp_fmn_base[0] + (1 << 13) + (qid << 3), 0);		
 			}
 		}
 	} else {
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 0ffe66e..b4d572d 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -324,6 +324,7 @@ struct nlm_hal_nae_config {
 	// total queues used = num_contexts
 	uint32_t num_contexts;
 
+	int serdes_init_cnt;
 	/* I am the owner or not, who initialize the node */
 	int owned;
 	/* Freein fifo mask. Out of the max rx fifos, domain ownership
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 5ff3545..0295f73 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -248,10 +248,27 @@ inline static volatile u32* xlp9xx_cpu_mem_base(u32 node, u32 offset)
 	}
 
 	phy &= 0xFFFFFFFFFFULL; //40 bits phy addr
-	return (volatile u32*)(XLP_XKPHYS_UNCACHED + phy );
+	return (volatile u32*)(phy);
 }
 
 
+static inline uint64_t __get_nae_soc_phys_base(int node, int nae_id)
+{
+	if(is_nlm_xlp9xx()){
+		if(nae_id==0)
+			return xlp9xx_cpu_mem_base(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE0));
+		else
+			return xlp9xx_cpu_mem_base(node, XLP9XX_PCIE_DEV_BASE(XLP9XX_NAE1));
+	}else{
+		if(nae_id)
+			return 0;
+		else{
+			uint64_t mask = ~0xf;
+			uint64_t pcie_cfg = 0x18000000 + XLP_PCIE_DEV_BASE(node, XLP_NAE);	
+			return (mask & nlm_hal_read_32bit_reg(pcie_cfg,PCI_MEM_BAR_0));	
+		}	
+	}
+}
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h
index 1bddbf0..75c5362 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_kbp.h
@@ -188,9 +188,6 @@ enum KBP_MDIO_DEV {
     MDIO_DEV_TX_BCAST = 31,
 };
 
-#define XLP_NA_REG_BLOCK_SIZE       0x2000 /* 8KB */
-#define PCI_MEM_BAR_0               0x0004
-#define MAX_NUMBER_OF_SERDES_LANE   0x8
 
 /**waste cpu clock cycle to achieve delay in time
  @param x - number of 64-bit add operation to perform
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
index 58dc355..0bc6615 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal_xlp_dev.h
@@ -400,14 +400,14 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 #define XLP_9XX_NET1_RX_VC_BASE      712
 #define XLP_9XX_NET1_RX_VC_LIMIT     727
 
-#define XLP9XX_NAE_DEVICE               3
-#define XLP9XX_NAE_FUNC                 0
+#define XLP9XX_NAE0_DEVICE               3
+#define XLP9XX_NAE0_FUNC                 0
 
 #define XLP9XX_NAE1_DEVICE              3
 #define XLP9XX_NAE1_FUNC                3
 
-#define XLP9XX_POE_DEVICE               3
-#define XLP9XX_POE_FUNC                 1
+#define XLP9XX_POE0_DEVICE               3
+#define XLP9XX_POE0_FUNC                 1
 
 #define XLP9XX_POE1_DEVICE              3
 #define XLP9XX_POE1_FUNC                4 
@@ -496,7 +496,13 @@ extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
 
 #define XLP_MAXDEV_PERNODE		8
 
-#define XLP_CFG_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+#define XLP9XX_PCIE_DEV_BASE(SOC)		(((SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+#define XLP_PCIE_DEV_BASE(node, SOC)                ((((node * XLP_MAXDEV_PERNODE) + SOC##_DEVICE) << 15) | (SOC##_FUNC << 12))
+
+#define XLP_NA_REG_BLOCK_SIZE       0x2000 /* 8KB */
+#define PCI_MEM_BAR_0               0x0004
+#define MAX_NUMBER_OF_SERDES_LANE   0x8
+
 
 
 #ifndef __ASSEMBLY__
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index b014bc4..b7ec3fa 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -431,8 +431,8 @@ __inline__ void nlm_hal_init(void)
 		printf("Node:%d NAE_NAE_Base:%lX\n", node, xlp_nae_base[node]);
 		printf("Node:%d NAE_MAC_Base:%lX\n", node, xlp_mac_base[node]);
 
-			xlp_mac_base[node] = xlp9xx_cpu_mem_base(-1, XLP_CFG_BASE(XLP_NAE));
-			xlp_fmn_base[node] = xlp9xx_cpu_mem_base(-1, XLP_CFG_BASE(XLP_FMN));
+			xlp_mac_base[node] = xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_NAE));
+			xlp_fmn_base[node] = xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_FMN));
 			xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
 		printf("After Node:%d NAE_fmn_Base:%lX\n", node, xlp_fmn_base[node]);
 		printf("Node:%d NAE_NAE_Base:%lX\n", node, xlp_nae_base[node]);
@@ -440,19 +440,19 @@ __inline__ void nlm_hal_init(void)
 			
 
 
-			xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg(( (1<<20) +0x18000000 + XLP_CFG_BASE( XLP_POE)), PCI_MEM_BAR_0);	//0x18019000
+			xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg(( (1<<20) +0x18000000 + XLP9XX_PCIE_DEV_BASE( XLP_POE)), PCI_MEM_BAR_0);	//0x18019000
 			xlp_poe_base_pcim[node] = (1<<20)+ 0x18000000 + (3<<15) + (1<<12) +0;	//0x18019000
-			xlp_poe_base_pcim[node] = xlp9xx_cpu_mem_base(-1, XLP_CFG_BASE(XLP_POE));
+			xlp_poe_base_pcim[node] = xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE(XLP_POE));
 			
 		printf("After modify xlp_xlp_poe_base_pcim is = 0x%llx\n", xlp_poe_base_pcim);
 		}
 
-		xlp_poe_base_pcie[node] = xlp_io_base | XLP_CFG_BASE(XLP_POE) & 0x1fffffff; /* For now . Will be fixed soon.*/
+		xlp_poe_base_pcie[node] = xlp_io_base | XLP9XX_PCIE_DEV_BASE(XLP_POE) & 0x1fffffff; /* For now . Will be fixed soon.*/
 		xlp_poe_base_pcie[node] = xlp_io_base + xlp_poe_base_pcim[node] & 0x1fffffff; 
 		printf("xlp_poe_base_pcie is = 0x%llx\n", xlp_poe_base_pcie);
 
-		xlp_sys_base[node] = (xlp_io_base | XLP_CFG_BASE( XLP_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
-		xlp_sys_base[node] = xlp_io_base | (unsigned long long)xlp9xx_cpu_mem_base(-1, XLP_CFG_BASE( XLP_SYS));
+		xlp_sys_base[node] = (xlp_io_base | XLP9XX_PCIE_DEV_BASE( XLP_SYS)) & 0x1fffffff; /*For now . Will be fixed soon.*/
+		xlp_sys_base[node] = xlp_io_base | (unsigned long long)xlp9xx_cpu_mem_base(-1, XLP9XX_PCIE_DEV_BASE( XLP_SYS));
 		printf("xlp_sys_base[node] is = 0x%llx\n", xlp_sys_base);
 		
 		//xlp_sae_base[node] = (xlp_io_base | XLP_CFG_BASE(node, XLP_SAE)) & 0x1fffffff; /* For now . Will be fixed soon.*/
-- 
1.7.1

