From c0787e6886c68332bef354858588073cb7a4941b Mon Sep 17 00:00:00 2001
From: Saswat Dash <saswat.dash@broadcom.com>
Date: Thu, 27 Mar 2014 12:18:08 +0530
Subject: cleanup: renamed halx_netio module to halx_guest, since it is used in guest mode only

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/halx_netio/Makefile b/drivers/misc/netlogic/halx_netio/Makefile
deleted file mode 100644
index 6b24789..0000000
--- a/drivers/misc/netlogic/halx_netio/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-KERNELDIR =$(SDK_ROOT)/linux/
-HALX_DIR =$(SDK_ROOT)/halx
-HAL_NET_DIR = $(SDK_ROOT)/libraries/netlib
-HAL_ROOT = $(SDK_ROOT)/libraries
-
-ccflags-y += -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL \
-     -I$(HAL_ROOT)/fdt/libfdt -I$(HAL_ROOT)/syslib/include/ -I$(HAL_ROOT)/alelib/ -I$(HAL_ROOT)/fmnlib -I$(HALX_DIR)/usr/include -I$(HAL_NET_DIR)/include \
-     -I$(HALX_DIR)/src/include -I$(HALX_DIR)/src/arch/xlp
-
-KBUILD_EXTRA_SYMBOLS:= $(SDK_ROOT)/libraries/Module.symvers
-
-obj-m += halx_netio.o
-
-halx_netio-objs += halx_netio_main.o
diff --git a/drivers/misc/netlogic/halx_netio/halx_netio_iface.h b/drivers/misc/netlogic/halx_netio/halx_netio_iface.h
deleted file mode 100644
index 43d5f92..0000000
--- a/drivers/misc/netlogic/halx_netio/halx_netio_iface.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#ifndef _HALX_NETIO_IFACE_H_
-#define _HALX_NETIO_IFACE_H_
-
-#define NETIF_DEV_NAME		"netif"
-#define HALX_NETIO_MAJOR	126
-/* #define HALX_NETIO_DEBUG	1 */
-
-#define NETIF_IOC       'N'
-#define HALX_CMD_REGISTER               _IOWR(NETIF_IOC, 1, unsigned long long)
-#define HALX_CMD_NET_INIT               _IOWR(NETIF_IOC, 2, unsigned long long)
-#define HALX_CMD_OPEN_PORT              _IOWR(NETIF_IOC, 3, unsigned long long)
-#define HALX_CMD_CLOSE_PORT             _IOWR(NETIF_IOC, 4, unsigned long long)
-#define HALX_CMD_CONFIG_PORT            _IOWR(NETIF_IOC, 5, unsigned long long)
-#define HALX_CMD_DEV_INFO		_IOWR(NETIF_IOC, 6, unsigned long long)
-#define HALX_CMD_PKT_ENGINE		_IOWR(NETIF_IOC, 7, unsigned long long)
-#define HALX_CMD_PKT_PARSER		_IOWR(NETIF_IOC, 8, unsigned long long)
-#define HALX_CMD_MSG_INIT		_IOWR(NETIF_IOC, 9, unsigned long long)
-#define HALX_CMD_DTR_INIT               _IOWR(NETIF_IOC, 10, unsigned long long)
-#define HALX_CMD_CDE_INIT               _IOWR(NETIF_IOC, 11, unsigned long long)
-#define HALX_CMD_CDE_COMPRESS           _IOWR(NETIF_IOC, 12, unsigned long long)
-#define HALX_CMD_CDE_DECOMPRESS         _IOWR(NETIF_IOC, 13, unsigned long long)
-#define HALX_CMD_CDE_RESULT             _IOWR(NETIF_IOC, 14, unsigned long long)
-#define HALX_CMD_CDE_CLEANUP            _IOWR(NETIF_IOC, 15, unsigned long long)
-#define HALX_CMD_POE_ENQ_STORAGE        _IOWR(NETIF_IOC, 16, unsigned long long)
-
-#endif
diff --git a/drivers/misc/netlogic/halx_netio/halx_netio_main.c b/drivers/misc/netlogic/halx_netio/halx_netio_main.c
deleted file mode 100644
index 5fbf90a..0000000
--- a/drivers/misc/netlogic/halx_netio/halx_netio_main.c
+++ /dev/null
@@ -1,459 +0,0 @@
-/*-
- * Copyright (c) 2003-2013 Broadcom Corporation
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * #BRCM_2# */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-
-#include <asm/cpu.h>
-#include <asm/mipsregs.h>
-#include <asm/netlogic/kvm_para.h>
-
-#include "libfdt.h"
-#include "halx_netio_iface.h"
-#include <halx.h>
-#include <halx_common.h>
-#include <halx_netcp.h>
-
-static long halx_netio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	int rc = 0, retval = 0;
-	void __user *argp = (void __user *)arg;
-
-	switch(cmd) {
-
-	case HALX_CMD_REGISTER:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_domain_t *u_ctx = NULL;
-		halx_domain_t *ctx_dom_data = (halx_domain_t *)kmalloc(sizeof(halx_domain_t), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_domain_t));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-		printk("halx_netio: HALX_CMD_REGISTER phy_ctx_dom_data: 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_REGISTER, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to register halx\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_domain_t));
-			if (retval) {
-				printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-			}
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_NET_INIT:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_linux_net_arg *u_ctx = NULL;
-		halx_linux_net_arg *ctx_dom_data = (halx_linux_net_arg *)kmalloc(sizeof(halx_linux_net_arg), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_REGISTER\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_linux_net_arg));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_NET_INIT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_NET_INIT, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX NET INIT\n");
-			rc = -1;
-		} else {
-                        retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_linux_net_arg));
-                        if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-                        }
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_OPEN_PORT:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_port_op_t *u_ctx = NULL;
-		halx_port_op_t *ctx_dom_data = (halx_port_op_t *)kmalloc(sizeof(halx_port_op_t), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_OPEN_PORT\n");
-			return -1;
-		}
-
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_port_op_t));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_OPEN_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_OPEN_PORT, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX OPEN PORT\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_port_op_t));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space\n",retval);
-                        }
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_CLOSE_PORT:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_port_op_t *u_ctx = NULL;
-		halx_port_op_t *ctx_dom_data = (unsigned long *)kmalloc(sizeof(halx_port_op_t), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CLOSE_PORT\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_port_op_t));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_CLOSE_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_CLOSE_PORT, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX CLOSE PORT\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_port_op_t));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-                        }
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_CONFIG_PORT:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_config_port_io *u_ctx = NULL;
-		halx_config_port_io *ctx_dom_data = (halx_config_port_io *)kmalloc(sizeof(halx_config_port_io), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_CONFIG_PORT\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_config_port_io));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_CONFIG_PORT phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_CONFIG_PORT, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX CONFIG PORT\n");
-			rc = -1;
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_DEV_INFO:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_dev_info *u_ctx;
-		halx_dev_info *ctx_dom_data = (halx_dev_info *)kmalloc(sizeof(halx_dev_info), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_DEV_INFO\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_dev_info));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_DEV_INFO phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_DEV_INFO, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX DEV INFO\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_dev_info));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space\n",retval);
-                        }
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_PKT_ENGINE:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_arg_attr_pktengine *u_ctx = NULL;
-		halx_arg_attr_pktengine *ctx_dom_data = (halx_arg_attr_pktengine *)kmalloc(sizeof(halx_arg_attr_pktengine), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_ENGINE\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_arg_attr_pktengine));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_PKT_ENGINE phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_PKT_ENGINE, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX PKT ENGINE\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_arg_attr_pktengine));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-			}
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_PKT_PARSER:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_conf_parser_t *u_ctx;
-		halx_conf_parser_t *ctx_dom_data = (halx_conf_parser_t *)kmalloc(sizeof(halx_conf_parser_t), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_PKT_PARSER\n");
-			return -1;
-		}
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_conf_parser_t));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_PKT_PARSER phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_PKT_PARSER, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX PKT PARSER:\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_conf_parser_t));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-                        }
-		}
-		kfree(ctx_dom_data);
-		break;
-	}
-	case HALX_CMD_POE_ENQ_STORAGE:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-
-		halx_alloc_poe_enq_storage_t *ctx_dom_data = (halx_conf_parser_t *)kmalloc(sizeof(halx_alloc_poe_enq_storage_t), GFP_KERNEL);
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_POE_ENQ_STORAGE\n");
-			return -1;
-		}
-		retval = copy_from_user(ctx_dom_data, (halx_alloc_poe_enq_storage_t *)arg, sizeof(halx_alloc_poe_enq_storage_t));
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-                printk("halx_netio: HALX_CMD_POE_ENQ_STORAGE phy_ctx_dom_data : 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_CMD_POE_ENQ_STORAGE, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX_CMD_POE_ENQ_STORAGE\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user((halx_alloc_poe_enq_storage_t *)arg, ctx_dom_data, sizeof(halx_alloc_poe_enq_storage_t));
- 			if (retval) {
-                                printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-                        }
-		}
-		break;
-	}
-	case HALX_CMD_MSG_INIT:
-	{
-		uint64_t ret = 0;
-		unsigned long phy_ctx_dom_data = 0;
-		halx_dev_t *u_ctx = NULL;
-		halx_dev_t *ctx_dom_data = (halx_dev_t *)kmalloc(sizeof(halx_dev_t), GFP_KERNEL);
-
-		if (ctx_dom_data == NULL) {
-			printk(KERN_ERR "halx_netio: kmalloc returning NULL in HALX_CMD_MSG_INIT\n");
-			return -1;
-		}
-
-		retval = copy_from_user(&u_ctx, argp, sizeof(&u_ctx));
-
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-
-		retval = copy_from_user(ctx_dom_data, u_ctx, sizeof(halx_dev_t));
-
-		if (retval) {
-			printk(KERN_ERR "%s %d: %d bytes not copied from userspace\n", __func__, __LINE__, retval);
-		}
-		phy_ctx_dom_data = virt_to_phys(ctx_dom_data);
-#ifdef HALX_NETIO_DEBUG
-		printk("halx_netio: HALX_CMD_MSG_INIT phy_ctx_dom_data: 0x%lx\n", phy_ctx_dom_data);
-#endif
-
-		if (do_hypcall_p2r1(KVM_HC_HALX_NETSOC, phy_ctx_dom_data, CMD_HALX_MSG_INIT, &ret)) {
-			printk(KERN_ERR "halx_netio: failure to HALX_CMD_MSG_INIT\n");
-			rc = -1;
-		} else {
-			retval = copy_to_user(u_ctx, ctx_dom_data, sizeof(halx_dev_t));
-			if (retval) {
-				printk("halx_netio: halif %d bytes not copied to user space \n",retval);
-			}
-		}
-		break;
-	}
-	default:
-		rc = -1;
-		break;
-
-	}
-	
-	return rc;
-}
-
-static const struct file_operations halx_netio_ops = {
-	.owner  = THIS_MODULE,
-	.unlocked_ioctl = halx_netio_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = halx_netio_ioctl,
-#endif
-};
-
-static int __init brcm_halx_netio_init (void)
-{
-	int i;
-
-	i = register_chrdev(HALX_NETIO_MAJOR, NETIF_DEV_NAME, &halx_netio_ops);
-	if (i < 0)
-	{
-		printk(KERN_ERR "halx_netio: unable to register %d", HALX_NETIO_MAJOR);
-		return i;
-	}
-	printk("halx_netio: i %d\n", i);
-
-	return 0;
-}
-
-static void __exit brcm_halx_netio_exit (void)
-{
-	printk ("brcm halx_netio driver exit...\n");
-}
-
-module_init(brcm_halx_netio_init);
-module_exit(brcm_halx_netio_exit);
-
-MODULE_AUTHOR("Broadcom");
-MODULE_DESCRIPTION("HALX NETIO Driver");
-MODULE_LICENSE("Proprietary");
-MODULE_VERSION("0.1");
-- 
1.7.1

