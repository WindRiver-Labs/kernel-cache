From 80ed474cf01c536cfb43db3b44eba225c135d401 Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Tue, 26 Aug 2014 12:00:58 +0530
Subject: netlib: updated bringup sequence for XLAUI/XFI on 5xx

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
index 7c51d1e..e79ccd1 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_dev.h
@@ -937,14 +937,6 @@ enum {
 #define NAE_PAUSE_TIMER_DELTA             32
 
 
-#define NETIOR_HIGIG2_CTRL0		0x70
-#define NETIOR_HIGIG2_CTRL1		0x71
-#define NETIOR_HIGIG2_CTRL2		0x72
-#define NETIOR_HIGIG2_PAUSE_CTRL1	0x73
-#define NETIOR_HIGIG2_MACSA		0x74
-#define NETIOR_HIGIG2_STATUS		0x75
-#define NETIOR_HIGIG2_MISC		0x76
-
 #define NETIOR_VLANTYPE_FILTER          0x76
         #define VLAN_RxHMC              0x16
         #define VLAN_RxPAC              0x17
@@ -973,8 +965,34 @@ enum {
 
     #define NETIOR_XGMAC_RXAUI_SCRAMBLER_POS 4
 
+
+#define XGMAC_CONFIG_REG1                0x00
+#define XGMAC_CONFIG_REG2                0x01
+#define XGMAC_CONFIG_REG3                0x02
+#define XGMAC_CONFIG_REG4                0x03
+#define XGMAC_ADD_LS                     0x04
+#define XGMAC_ADD_MS                     0x05
+#define XGMAC_MAXLENG                    0x08
+#define XGMAC_REVLEVEL                   0x0B
+#define XGMAC_AMIIM_COMMAND              0x10
+#define XGMAC_AMIIM_FEILD                0x11
+#define XGMAC_AMIIM_CONFIG               0x12
+#define XGMAC_AMIIM_LINKFAIL             0x13
+#define XGMAC_AMIIM_INDICATOR            0x14
+#define MAC_FILTER_CONFIG                0x5C
+#define HASH_TABLE_VECTOR_BASE           0x60
+
 #define NETIOR_XGMAC_CTRL2		0x7E
 #define NETIOR_XGMAC_CTRL3		0x7D
+#define NETIOR_HIGIG2_CTRL0		0x70
+#define NETIOR_HIGIG2_CTRL1		0x71
+#define NETIOR_HIGIG2_CTRL2		0x72
+#define NETIOR_HIGIG2_PAUSE_CTRL1	0x73
+#define NETIOR_HIGIG2_MACSA		0x74
+#define NETIOR_HIGIG2_STATUS		0x75
+#define NETIOR_HIGIG2_MISC		0x76
+
+
 
 #define MAC_ADDR0_LO			0x50
 #define MAC_ADDR0_HI			0x51
@@ -1250,6 +1268,27 @@ enum {
 #define XLAUI_CBFC_PAUSE_RECEIVED_0       0x1d8
 #define XLAUI_MAC_CTL_FRAME_TRANSMITTED   0x218
 #define XLAUI_MAC_CTL_FRAME_RECEIVED      0x220
+#define XLGMAC_FEC_CRTL0_REG              0x304
+#define XLGMAC_FEC_CRTL1_REG              0x324
+#define XLGMAC_FEC_CRTL2_REG              0x344
+#define XLGMAC_FEC_CRTL3_REG              0x364
+#define XLGMAC_REG_ADDR100                0x400
+#define XLGMAC_PCS_CONTROL1               0x400
+#define XLGMAC_PCS_RESET                  (1<<15)
+#define XLGMAC_PCS_LOOPBACK               (1<<14)
+#define XLGMAC_PCS_STATUS1                0x404
+#define XLGMAC_PCS_SPEED_ABILITY          0x410
+#define XLGMAC_PCS_CONTROL2               0x41C
+#define XLGMAC_PCS_STATUS2                0x420
+#define XLGMAC_PCS_ALIGN_STATUS1          0x4C8
+#define XLGMAC_PCS_ALIGN_STATUS2          0x4CC
+#define XLGMAC_PCS_ALIGN_STATUS3          0x4D0
+#define XLGMAC_PCS_ALIGN_STATUS4          0x4D4
+#define XLGMAC_PCS_BIP_ERR_CNT_LANE0      0x720
+#define XLGMAC_PCS_BIP_ERR_CNT_LANE1      0x724
+#define XLGMAC_PCS_BIP_ERR_CNT_LANE2      0x728
+#define XLGMAC_PCS_BIP_ERR_CNT_LANE3      0x72C
+
 /*KR/KR4 related registers*/
 #define KR_CMD                           0x10
 #define KR_DATA                          0x11
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index fded3f4..9a1b584 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -98,6 +98,7 @@ extern void __netsoc_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t
 extern void __netsoc_xfi_pcs_init(nae_t *nae, uint32_t xfi_cplx_mask, uint32_t phymode);
 extern void __netsoc_xlaui_pcs_init(nae_t *nae, uint32_t xlaui_cplx_mask, uint32_t phymode);
 extern int __netsoc_interlaken_pcs_init(nae_t *nae, uint32_t ilk_complex_map);
+extern void __netsoc_wait_for_pcs_sync(nae);
 extern int register_marvell_phy(void);
 extern int register_broadcom_phy(void);
 extern int register_external_phy(ext_phy_t *ext_phy);
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index 88f7ec4..d06b739 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -313,6 +313,7 @@ typedef struct {
 struct nlm_hal_nae_port {
         int  valid;
         int  mgmt;
+	int block_id;
         int  num_free_desc;
         int  txq;
         int  rxq;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
index 8f016f3..4d2d0ba 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_api.c
@@ -1772,7 +1772,8 @@ int  brcm_netsoc_lib_init(struct netsoc_lib_param *libparam)
                 netsoc_lib_contig_free = libparam->contig_free;
                 netsoc_lib_phystovirt = libparam->phys_to_virt;
 		netsoc_lib_virttophys = libparam->virt_to_phys;
-		netsoc_api_dbglvl = libparam->netsoc_debug_level;
+		if(!netsoc_api_dbglvl) 
+			netsoc_api_dbglvl = libparam->netsoc_debug_level;
 	}     
 
 	if(__netsoc_validate_lib_param(libparam)<0){
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 21646b8..c525c90 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1115,7 +1115,9 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg, struct netsoc_lib_pa
 
                 for(offset = 0; offset < num_ports; offset++) {
                         nae_port = &nae_cfg->ports[port];
+                        nae_port->nae = nae_cfg;	
 			nae_port->ext_phy_addr = cmplx_cfg.ext_phy_addr[offset];
+			nae_port->block_id = block;
 			if (nae_port->ext_phy_addr < 0 || nae_port->ext_phy_addr > 31)
 				continue;
                         nae_port->hw_port_id = get_intf_hw_port_id(block, intf_type, offset);
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index f152a0c..9b648e2 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -4008,6 +4008,7 @@ int __netsoc_pcs_init(nae_t *nae)
                 netsoc_api_print(NETSOC_APIDBG_GLOBAL, "node %d interlaken PCS init 0x%x\n", node, nae->ilk_complex_map);
                 __netsoc_interlaken_pcs_init(nae, nae->ilk_complex_map);
         }
+	__netsoc_wait_for_pcs_sync(nae);	
 	return NETSOC_API_SUCCESS;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index e5b9626..ac7426d 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -1518,7 +1518,115 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
         }
 }
 
-void __netsoc_wait_for_pcs_sync(nae_t *nae)
+void __netsoc_pma2p0_txrx_hard_reset(nae_t *nae, int block, int lane_no)
+{
+	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	volatile uint32_t pma2p0_config;
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config |= (PMA2P0_LANE0_RXTX_HARD_RESET <<lane_no);
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	nlm_mdelay(1);
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config &= ~(PMA2P0_LANE0_RXTX_HARD_RESET <<lane_no);
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+}
+
+void __netsoc_pma2p0_synth_hard_reset(nae_t *nae, int block, int phymode)
+{
+	volatile uint32_t pma2p0_config;
+	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config |= PMA2P0_LANE1_SYNTH_HARD_RESET;
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	//nlm_print("Lane1: Adding some delay before de-asserting the reset\n");
+	nlm_mdelay(1);
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config &= ~PMA2P0_LANE1_SYNTH_HARD_RESET;
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+
+	if ((phymode == PHYMODE_XFI) || phymode == PHYMODE_XLAUI) {
+		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+		pma2p0_config |= PMA2P0_LANE2_SYNTH_HARD_RESET;
+		netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+		//nlm_print("Lane2: Adding some delay before de-asserting the reset\n");
+		nlm_mdelay(1);
+		pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+		pma2p0_config &= ~PMA2P0_LANE2_SYNTH_HARD_RESET;
+		netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	}
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config |= PMA2P0_LANE3_SYNTH_HARD_RESET;
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+
+	//nlm_print("Lane3: Adding some delay before de-asserting the reset\n");
+	nlm_mdelay(1);
+	pma2p0_config = netsoc_read_mac_reg(mac_base, PMA2P0_CTL0);
+	pma2p0_config &= ~PMA2P0_LANE3_SYNTH_HARD_RESET;
+	netsoc_write_mac_reg(mac_base, PMA2P0_CTL0, pma2p0_config);
+	nlm_mdelay(1);
+
+	// // Do PCS reset 
+	// write_xaui_softreset_reg(inst_no, complex_no, 0x2); //Assert soft resets
+	// wait_cpu_cycles(1000000);
+	// write_xaui_softreset_reg(inst_no, complex_no, 0x0); //de-assert soft resets
+
+}
+
+/*check lane fault for all the ports*/
+void __netsoc_check_for_remote_fault(nae_t *nae)
+{
+	volatile uint32_t rd_data;
+	uint32_t port, retry_count;
+	for(port = 0; port < nae->num_ports; port++){
+		net_port_t* netport = &nae->ports[port];
+		if(netport->iftype == XFI_IF){
+			uint64_t mac_base = __netsoc_get_xgmac_base(netport);
+			rd_data	= netsoc_read_mac_reg(mac_base, XGMAC_CONFIG_REG3);
+			retry_count = 0;
+			while ((rd_data & (1<<25)) == (1<<25)) {
+				//nlm_print(" Remote fault bit is detected for complex%d lane(port)%d\n", netport->block_id, port);
+				__netsoc_pma2p0_txrx_hard_reset(nae, netport->block_id, netport->hw_port_id%4);
+				if (retry_count++ > 100) {
+					netsoc_api_print(NETSOC_APIDBG_ERROR,"blockx%d lane%d: Uncorrectable Remote Fault\n",  netport->block_id, port);
+				}
+				rd_data	= netsoc_read_mac_reg(mac_base, XGMAC_CONFIG_REG3);
+            		}
+		
+		}else if(netport->iftype == XLAUI_IF){
+			rd_data = __netsoc_read_xlgmac_reg(netport, XLAUI_GP_STATUS);
+        		// read the register again to clear the stale status
+			rd_data = __netsoc_read_xlgmac_reg(netport, XLAUI_GP_STATUS);
+			// Check for remote fault, bit1
+			while ((rd_data & (1<<1)) == (1<<1)) {
+				// Remote fault is set, do vsemi synth reset
+				 netsoc_api_print(NETSOC_APIDBG_ERROR,"Remote fault is set for complex:%d, calling synth reset\n", netport->block_id);
+				__netsoc_pma2p0_synth_hard_reset(nae, netport->block_id, PHYMODE_XLAUI);
+				// for (lane_no=1; lane_no<4; lane_no++) {
+				//     do_vsemi_txrx_hard_reset(inst_no, complex_no, lane_no);
+				// }
+
+				// Do PCS reset 
+				rd_data = __netsoc_read_xlgmac_reg(netport, XLGMAC_PCS_CONTROL1);
+				rd_data |= XLGMAC_PCS_RESET;
+				__netsoc_write_xlgmac_reg(netport, XLGMAC_PCS_CONTROL1, XLGMAC_PCS_RESET);
+				 netsoc_api_print(NETSOC_APIDBG_PORT,"PCS reset asserted for XLGMAC 0x%x\n", rd_data);
+				nlm_mdelay(1);
+				rd_data &= ~XLGMAC_PCS_RESET;
+				 netsoc_api_print(NETSOC_APIDBG_PORT,"PCS reset de-asserted for XLGMAC 0x%x\n", rd_data);
+				__netsoc_write_xlgmac_reg(netport, XLGMAC_PCS_CONTROL1, rd_data);
+
+				// Read 2 times to clear the remote fault
+				rd_data = __netsoc_read_xlgmac_reg(netport, XLAUI_GP_STATUS);
+				rd_data = __netsoc_read_xlgmac_reg(netport, XLAUI_GP_STATUS);
+				netsoc_api_print(NETSOC_APIDBG_PORT,"XLAUI_GP_STATUS for complex:%d is 0x%x\n", netport->block_id, rd_data);
+			}
+		
+		}else
+			return;
+	}
+}
+
+int __netsoc_wait_for_lanes_sync(nae_t *nae)
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
 	uint64_t mac_base;
@@ -1539,17 +1647,41 @@ void __netsoc_wait_for_pcs_sync(nae_t *nae)
 				/* Wait for XAUI Lane fault to be cleared */
 				count++;
 				if (count == timeout) {
-					netsoc_api_print(NETSOC_APIDBG_ERROR,"XFI/XLAUI lane fault not cleared \n");
-					nlm_print("XFI/XLAUI lane fault not cleared on block=%d lane=%d\n", block, PHY_LANE_3_STATUS-lane_status );
-					break;
+					netsoc_api_print(NETSOC_APIDBG_PORT, "XFI/XLAUI lane fault not cleared on block=%d lane=%d\n", block, PHY_LANE_3_STATUS-lane_status );
+					return -1;
 				}
 			}
 
-			nlm_print("Lane sync wait over \n");
 
 		}
+		nlm_print("All lanes are synchronized  for block = %d\n", block);
 	}
+	return 0;
+	
+}
 
+void __netsoc_wait_for_pcs_sync(nae_t *nae)
+{
+	int block, lane_no;
+	uint32_t cplx_mask = nae->xfi_complex_map | nae->xlgmac_complex_map;
+	if(!is_nlm_xlp5xx())
+		return;
+	__netsoc_wait_for_lanes_sync(nae);	
+	for( block = 0; block < 4; block++)
+	{
+		if ((cplx_mask & (1 << block)) == 0) {
+			continue;
+		}
+		for(lane_no=1; lane_no<4; lane_no++){ /* only 3 lanes */
+			__netsoc_pma2p0_txrx_hard_reset(nae, block, lane_no);
+		}	
+	}
+	__netsoc_wait_for_lanes_sync(nae);	
+	__netsoc_check_for_remote_fault(nae);
+	if(__netsoc_wait_for_lanes_sync(nae)<0){ /*finally print the message if lane fault is not cleared */
+		netsoc_api_print(NETSOC_APIDBG_ERROR, "XFI/XLAUI lane fault could not be cleared \n");
+	
+	}	
 }
 
 static void xlp9xx_10G_lane_pcs_init(nae_t *nae, uint32_t cplx_mask, uint32_t phymode)
-- 
1.7.1

