From 9b294000eb12e5ab21be03550b3a3a4f1929411d Mon Sep 17 00:00:00 2001
From: Sreekanth Molagavalli <sreekanth.molagavalli@broadcom.com>
Date: Thu, 22 May 2014 16:44:48 +0530
Subject: XLP9xx/5xx: Add APIs for device clock management.

APIs for freq setting of devices.
[Based on SDK 3.2]
Delete the variables of "sel" and "sys_clk_base" because of the compile error
as below:
arch/mips/netlogic/lib/syslib/src/nlm_hal.c:374:11: error: unused variable 'sys_clk_base' [-Werror=unused-variable]
  uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
           ^
arch/mips/netlogic/lib/syslib/src/nlm_hal.c:669:4: error: format '%llx' expects argument of type 'long long unsigned int', but argument 3 has type 'long unsigned int' [-Werror=format=]
    nlm_print("xlp9xx_sys_clk_base %d is =0x%llx\n", node, xlp9xx_sys_clk_base[node]);
    ^
Redefine type of the function "xlp9xx_config_dev_freq" from "static" to "static inline"
because of the compile error as below:
arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h:512:12: error: 'xlp9xx_config_dev_freq' defined but not used [-Werror=unused-function]
 static int xlp9xx_config_dev_freq(int node, unsigned int freq, int *devclock, int *div)
            ^

Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
index a197015..e1d9f3a 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_haliface.h
@@ -43,7 +43,7 @@
 #include "netsoc_libiface.h"
 #include "ext_phy.h"
 #include "nlm_hal_fmn.h"
-#include "xlp9xx_sys.h"
+//#include "xlp9xx_sys.h"
 
 extern uint32_t socnet_version_v0;
 extern struct netsoc_info *current_netsoc;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index e273073..5cd40fc 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1427,7 +1427,7 @@ int fdt_get_nae_ptp_config(void *fdt, nae_t *nae)
                       nae->ptp1588_enabled = fdt32_to_cpu(*(uint32_t *)(pval));
               }
               else {  
-                      nae->ptp1588_enabled = 1;
+                      nae->ptp1588_enabled = 0;
               }
         }
         return 0;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 3e073b1..24eec16 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1348,7 +1348,7 @@ void __netsoc_config_parserfifo(nae_t *nae, int hw_port_id, uint32_t start, uint
         {
 		if (IS_NLM_XLP9XX_FAMILY) {
                         xoff = size - 30 ;
-                        xon = (size/4) * 2;
+                        xon = xoff/ 2;
                         val = (xoff<<12) | (xon);
                 }
                 else {
@@ -4266,8 +4266,8 @@ int __netsoc_init_nae(nae_t *nae)
                  * which messes up Flash/CPLD/GBU BARs etc
                  */
 #ifndef XLP_SIM
-                __netsoc_reset_nae(nae);
                 nae->flags |= NAE_RESET_DONE;
+                __netsoc_reset_nae(nae);
 #endif
 		if(!IS_NLM_XLP9XX_FAMILY){
                 	nlm_hal_write_32bit_reg(nae->pcie_base, 0x4, bar0);
@@ -4278,7 +4278,6 @@ int __netsoc_init_nae(nae_t *nae)
 
 #ifndef XLP_SIM
 		//Set NAE frequency
-		__netsoc_set_frequency(nae, nae->frequency);
 #endif
 		__netsoc_mdio_init(nae);
 
@@ -4355,6 +4354,8 @@ int __netsoc_init_nae(nae_t *nae)
                  }
                  else
                          nae->msec_rx_port_enable =  nae->msec_tx_port_enable = 0;
+		
+		__netsoc_set_frequency(nae, nae->frequency);
 
 	}
 	return NETSOC_API_SUCCESS;
diff --git a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
index 7415f88..5dd2fca 100644
--- a/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
+++ b/arch/mips/netlogic/lib/syslib/include/nlm_hal.h
@@ -158,6 +158,11 @@ extern void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit);
 extern void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit);
 extern void nlm_hal_set_rsa_data_mode(int node, int bigend_fmt);
 
+extern int xlp9xx_set_nae_frequency(int node, uint64_t freq);
+extern int xlp9xx_set_soc_frequency(int node, int dev_id, uint64_t freq);
+extern void xlp9xx_device_clock_init(int node, void *fdt);	
+extern uint64_t xlp9xx_get_dev_freq(int node, int dev_id);
+
 #define nlh_read_dev_reg(dev, index) nlm_hal_read_32bit_reg(nlm_hal_get_dev_base(dev), index)
 #define nlh_write_dev_reg(dev, index, val) nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(dev), index, val)
 
@@ -185,6 +190,25 @@ struct nlm_rsa_init_param {
 	int freq;
 };
 
+enum dev_clk{
+        XLP9XX_CLKDEV_PIC = 0,
+        XLP9XX_CLKDEV_GDX = 1,
+        XLP9XX_CLKDEV_CMP = 2,
+        XLP9XX_CLKDEV_REGXF = 3,
+        XLP9XX_CLKDEV_REGXS = 4,
+        XLP9XX_CLKDEV_SEC = 5,
+        XLP9XX_CLKDEV_RSA = 6,
+        XLP9XX_CLKDEV_NET = 7,
+        XLP9XX_CLKDEV_SATA = 8,
+        XLP9XX_CLKDEV_KBP = 9,
+        XLP9XX_CLKDEV_USB = 10,
+        XLP9XX_CLKDEV_GIO = 11,
+        XLP9XX_CLKDEV_GBU = 12,
+        XLP9XX_CLKDEV_MMC = 13,
+        XLP9XX_CLKDEV_NAND = 14,
+        XLP9XX_CLKDEV_LZS = 15,
+};
+
 extern int nlm_hal_is_ref_clk_133MHz(void);
 #define XLP_PIT_TICK_RATE      nlm_hal_get_ref_clk_freq()
 
diff --git a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
index 6e769bf..e3e9fc1 100644
--- a/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
+++ b/arch/mips/netlogic/lib/syslib/include/xlp9xx_sys.h
@@ -112,24 +112,6 @@ enum xlp9xx_dev_sys {
 	CLK_DEVDIV_STAT		= 0x1e6,
 };
 
-enum dev_clk{
-        XLP9XX_CLKDEV_PIC = 0,
-        XLP9XX_CLKDEV_GDX = 1,
-        XLP9XX_CLKDEV_CMP = 2,
-        XLP9XX_CLKDEV_REGXF = 3,
-        XLP9XX_CLKDEV_REGXS = 4,
-        XLP9XX_CLKDEV_SEC = 5,
-        XLP9XX_CLKDEV_RSA = 6,
-        XLP9XX_CLKDEV_NET = 7,
-        XLP9XX_CLKDEV_SATA = 8,
-        XLP9XX_CLKDEV_KBP = 9,
-        XLP9XX_CLKDEV_USB = 10,
-        XLP9XX_CLKDEV_GIO = 11,
-        XLP9XX_CLKDEV_GBU = 12,
-        XLP9XX_CLKDEV_MMC = 13,
-        XLP9XX_CLKDEV_NAND = 14,
-        XLP9XX_CLKDEV_LZS = 15,
-};
 
 #endif //__ASSEMBLY__
 
@@ -177,6 +159,44 @@ static inline uint64_t get_nae_frequency(int node)
     nlm_print("sel:%d div:%d NET_FREQUENCY :%d MHz\n", sel, div, clk_freq);
     return (uint64_t) (clk_freq * 1000000);
 }
+
+static inline void xlp9xx_set_clkdev(int node, int dev_id, int sel, int div)
+{
+	unsigned int dev_shift;
+	int i; 
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+	uint32_t val;
+
+	dev_shift = dev_id * 2;
+	/* Write the div and select register */
+	val = ((sel & 0x3) << dev_shift);
+	syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
+
+	val = ((div & 0x3) << dev_shift);
+	syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
+
+	/* This register determines which device's CLK_DEVSEL will be changed, device mapping  same as CLK_DEVDIS register,hardware deasserts this bit when done */
+	syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
+
+	i=0;
+	while (i++ < 10) {
+		/* Poll Change register to see if bit corresponding to our device has been deasserted */
+		val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
+		if ((i==10) || ((val & (1 << dev_id)) == 0)) {
+			// Check the status
+			val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
+			if (val != sel) {
+				nlm_print(" CLKSELDEV val 0x%x select bit is not correct exp:%d got:0x%x\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
+			}
+			val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
+			if (val != div) {
+				nlm_print(" CLKSELDEV val 0x%x divide bit is not correct exp:%d got:0x%x\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
+			}
+			break;
+		}
+	}
+}
+
 static inline int xlp9xx_set_gbu_frequency(int node, uint64_t freq)
 {
     int sel, div, dev_shift, i;
@@ -240,81 +260,61 @@ static inline int xlp9xx_set_gbu_frequency(int node, uint64_t freq)
     return 0;
 }
 
-
-static inline int xlp9xx_set_nae_frequency(int node, uint64_t freq)
+/*
+ * @brief xlp9xx_config_dev_freq function is used to
+ * get the desired clock selection and dividers for a specific device freq.
+ * These are the Device clock PLL sources.
+ *
+ * @param [in]  node
+ * @param [in]  frequency we need for some device.
+ * @param [out]  pointer to the clock no.(dev clk 0, 1, 2)
+ * @param [out]  pointer to the division value.
+ *
+ * @return
+ * actual frequency on success & "-1" if the frency is not possible
+ * under the sel, division from dev clocks
+ * specified in fdt file.
+ *
+ * @ingroup hal
+ *
+ **/
+static inline int xlp9xx_config_dev_freq(int node, unsigned int freq, int *devclock, int *div)
 {
-    int sel, div, dev_shift, i;
-    const uint64_t mhz = 1000000;
-    int dev_freq;
-    uint64_t nae_freq;
-    uint32_t val, dev_id = XLP9XX_CLKDEV_NET;
-    uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
-
-    nae_freq = get_nae_frequency(node);
-
-    NLM_HAL_DO_DIV(nae_freq, mhz);
-
-    nlm_print("NAE frequency %llu MHz node :%d\n", (unsigned long long) nae_freq, node);
-		
-    if (freq == get_nae_frequency(node))
-	return 0;
-
-    NLM_HAL_DO_DIV(freq, mhz);
-    dev_freq = freq;
-    switch (dev_freq) {
-        case 133: sel = 0; div = 0; break;
-        case 66:  sel = 0; div = 1; break;
-        case 33:  sel = 0; div = 2; break;
-        case 17:  sel = 0; div = 3; break;
-        case 500: sel = 1; div = 0; break;
-        case 250: sel = 1; div = 1; break;
-        case 125: sel = 1; div = 2; break;
-        case 63:  sel = 1; div = 3; break;
-        case 667: sel = 2; div = 0; break;
-        case 333: sel = 2; div = 1; break;
-        case 167: sel = 2; div = 2; break;
-        case 83:  sel = 2; div = 3; break;
-        case 767: sel = 3; div = 0; break;
-        case 383: sel = 3; div = 1; break;
-        case 192: sel = 3; div = 2; break;
-        case 96:  sel = 3; div = 3; break;
-        default: // Set it to 333 MHz
-            nlm_print("Can't set freq to given MHz. Setting NAE Freq to 667 MHz instead.\n");
-            sel = 2; div = 0;
-        break;
-    }
-
-    dev_shift = dev_id * 2;	
-    // Write the div and select register	
-    val = ((sel & 0x3) << dev_shift);
-    syssoc_write_reg(sys_clk_base, CLK_DEVSEL, val);
-	
-    val = ((div & 0x3) << dev_shift);  
-    syssoc_write_reg(sys_clk_base, CLK_DEVDIV, val);
-	
-    // Poll Change register
-    syssoc_write_reg(sys_clk_base, CLK_DEVCHG, 0x1 << dev_id);
-
-    i=0;
-    while (i++ < 10) {
-      val = syssoc_read_reg(sys_clk_base, CLK_DEVCHG);
-
-      if ((i==10) || ((val & (1 << dev_id)) == 0)) {
-          // Check the status
-	  val = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT) >> dev_shift) & 0x3;
-          if (val != sel) {
-              nlm_print("NET CLKSELDEV val 0x%x select bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVSEL_STAT), sel, val);
-          }
-          val = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT) >> dev_shift) & 0x3;
-          if (val != div) {
-              nlm_print("NET CLKSELDEV val 0x%x divide bit is not correct exp:%d got:%d\n", syssoc_read_reg(sys_clk_base, CLK_DEVDIV_STAT), div, val);
-          }
-          break;
-      }
-    }
+	unsigned int  sel, division, mul, cal_freq;
+	int delta;
+	int ret = -1;  /* not found */
+	unsigned int dev_clock_freq;
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
+	for (sel = 0; sel < 4; sel++) {
+		if(sel==0){
+			dev_clock_freq = 133;
+		}else{
+			mul = syssoc_read_reg(sys_clk_base, DEV_PLLCTRL_1 + (4*(sel-1)));
+			nlm_print("Mul calc for sel = %d is = %d\n", sel, mul);
+			dev_clock_freq = 400 + 33*mul;
+		}
+
+		for (division = 0; division < 4; division++) {
+			
+			cal_freq = dev_clock_freq;
+			NLM_HAL_DO_DIV(cal_freq, (1<<division)) 
+			nlm_print(" Fre to bse set= %d and cal_freq= %d\n", freq, cal_freq);
+			delta = cal_freq - freq;
+			if ( ( delta <= 4) && (delta >= -4) ) {
+				*devclock = sel; /* 0 is system clk */
+				*div = division;
+				nlm_print("Found the match for frq with sel = %d and div= %d\n", sel, division);	
+				return 0;
+			}
+		}
+	}
 
-    nlm_print("NAE frequency changed to %llu MHz\n", (unsigned long long)nae_freq);
-    return 0;
+	/* 0: syclk; devclk0=1; devclk1=2; devclk2=3 */
+	*devclock = 1;
+	*div = 1;
+	/* default 250MHz = 500/2 i.e devclock 0 / divider 2 = 2 power 1 */
+	return ret;
 }
 
 static inline uint64_t get_crypto_block_frequency(int node, int dev_id)
@@ -424,6 +424,7 @@ static inline int set_crypto_block_frequency(int node, int dev_id, uint64_t freq
 }
 
 
+
 static inline uint64_t get_dtre_frequency(int node)
 {
     uint32_t sel, div, pll_out, dev_shift = XLP9XX_CLKDEV_GDX * 2;
@@ -536,28 +537,5 @@ static inline int xlp9xx_set_dtre_frequency(int node, uint64_t freq)
     return 0;
 }
 
-static inline int xlp9xx_set_soc_frequency(int node, int dev_id, uint64_t freq)
-{
-
-	switch(dev_id) {
-		case XLP9XX_CLKDEV_NET:
-			xlp9xx_set_nae_frequency(node, freq);
-			break;
-		case XLP9XX_CLKDEV_GBU:
-			xlp9xx_set_gbu_frequency(node, freq);
-			break;
-                case XLP9XX_CLKDEV_SEC:
-		case XLP9XX_CLKDEV_RSA:
-                        set_crypto_block_frequency(node, dev_id, freq);
-                        break;
-		case XLP9XX_CLKDEV_GDX:
-			xlp9xx_set_dtre_frequency(node, freq);
-			break;
-		default:
-			nlm_print("%s error\n",__func__);
-			break;
-	}
-        return 0;
-}
 
 #endif
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
index 3f3d087..be41aa7 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_hal.c
@@ -300,6 +300,193 @@ __inline__ int nlm_hal_is_xlp_le(void)
 	return little_endian;
 }
 
+static void inline xlp9xx_setup_devpll(uint64_t sys_clk_base, int dev_pll, int freq)
+{
+	volatile uint32_t pll_change, mul, mul0;
+	switch (freq) {
+		case 400: mul = 0 ; break; 
+		case 500: mul = 3 ; break; 
+		case 667: mul = 8 ; break; 
+		case 700: mul = 0x9 ; break; 
+		case 767: mul = 0xb ; break; 
+		default: 
+			  mul=0; break;
+	}
+	nlm_print("dev _pll = %d frq= %d mul = %d\n", dev_pll, freq, mul);
+	
+	mul0 = syssoc_read_reg(sys_clk_base, DEV_PLLCTRL_1 + (4*dev_pll));
+	nlm_print("DEV PLL[%d] present freq  =%d\n", dev_pll, 400 + 33*mul0);
+
+	syssoc_write_reg(sys_clk_base, DEV_PLLCTRL_1 + (4*dev_pll), mul);
+	syssoc_write_reg(sys_clk_base, XLP9XX_SYS_PLLCHG_CTRL, (1<<(2+dev_pll)));
+	pll_change = (1<<(2+dev_pll));
+	while (pll_change != 0) {
+		pll_change = syssoc_read_reg(sys_clk_base, XLP9XX_SYS_PLLCHG_CTRL);
+		//nlm_print("CLK_REG_SYSPLLCHGCTRL_ADDR = 0x%x\n", pll_change);
+	}
+	mul = syssoc_read_reg(sys_clk_base, DEV_PLLCTRL_1 + (4*dev_pll));
+	nlm_print("DEV PLL[%d] freq changed to =%d\n", dev_pll, 400 + 33*mul);
+
+}
+
+/*
+ * @brief nlm_hal_fdt_device_clock_init function is used to read the frequency
+ * of device clocks i.e 0,1,2 from FDT and set the clocks accordingly by programming
+ * device clk registers.
+ *
+ * @param [in]  pointer to the fdt file
+ * @param [in]  node
+ *
+ * @ingroup hal
+ *
+ **/
+void xlp9xx_device_clock_init(int node, void *fdt)
+{
+	char path_str[50];
+	unsigned int dev_clock[3];
+
+	sprintf(path_str,"/frequency-config");
+
+	if(copy_fdt_prop(fdt, path_str, "dev_clock0", PROP_CELL, &dev_clock[0], sizeof(uint32_t)) < 0) {
+		nlm_print("Unable to find the frequency in the FDT file for type: dev_clock0 \
+				using the default value 500Mhz\n");
+		dev_clock[0] = 500;
+	} else {
+		nlm_print("dev_clock0 = %d MHz \n", dev_clock[0]);
+	}
+
+	if(copy_fdt_prop(fdt, path_str, "dev_clock1", PROP_CELL, &dev_clock[1], sizeof(uint32_t)) < 0) {
+		nlm_print("Unable to find the frequency in the FDT file for type: dev_clock1 \
+				using the default value 667Mhz\n");
+		dev_clock[1] = 667;
+	} else {
+		nlm_print("dev_clock1 = %d MHz \n", dev_clock[1]);
+	}
+
+	if(copy_fdt_prop(fdt, path_str, "dev_clock2", PROP_CELL, &dev_clock[2], sizeof(uint32_t)) < 0) {
+		nlm_print("Unable to find the frequency in the FDT file for type: dev_clock2 \
+				using the default value 767Mhz\n");
+		dev_clock[2] = 767;
+	} else {
+		nlm_print("dev_clock2 = %d MHz \n", dev_clock[2]);
+	}
+
+	//for (sel = 0; sel < 3; sel++)
+	//	xlp9xx_setup_devpll(sys_clk_base, sel, dev_clock[sel]);
+}
+
+int xlp9xx_set_soc_frequency(int node, int dev_id, uint64_t freq)
+{
+
+	switch(dev_id) {
+		case XLP9XX_CLKDEV_NET:
+			xlp9xx_set_nae_frequency(node, freq);
+			break;
+		case XLP9XX_CLKDEV_GBU:
+			xlp9xx_set_gbu_frequency(node, freq);
+			break;
+                case XLP9XX_CLKDEV_SEC:
+		case XLP9XX_CLKDEV_RSA:
+                        set_crypto_block_frequency(node, dev_id, freq);
+                        break;
+		case XLP9XX_CLKDEV_GDX:
+			xlp9xx_set_dtre_frequency(node, freq);
+			break;
+		default:
+			nlm_print("%s error\n",__func__);
+			break;
+	}
+        return 0;
+}
+
+
+int xlp9xx_set_nae_frequency(int node, uint64_t freq)
+{
+	const uint64_t mhz = 1000000;
+	uint64_t nae_freq;
+	int clk_id, div;	
+
+	nae_freq = xlp9xx_get_dev_freq(node, XLP9XX_CLKDEV_NET);
+	NLM_HAL_DO_DIV(nae_freq, mhz);
+
+	NLM_HAL_DO_DIV(freq, mhz);
+	nlm_print("NAE frequency default set to %llu MHz for node :%d\n", (unsigned long long) nae_freq, node);
+	if(xlp9xx_config_dev_freq(node, freq, &clk_id, &div)<0){
+		nlm_print("WARN: Could not set the desired freq for NAE\n");
+		return -1;
+	}
+	
+	xlp9xx_set_clkdev(node, XLP9XX_CLKDEV_NET, clk_id, div);
+	
+	nae_freq = xlp9xx_get_dev_freq(node, XLP9XX_CLKDEV_NET);
+	NLM_HAL_DO_DIV(nae_freq, mhz);
+	nlm_print("NAE frequency changed to %llu MHz\n", (unsigned long long)nae_freq);
+
+	return 0;
+}
+
+#if 0 
+/*
+ * @brief nlm_hal_fdt_get_devfreq_params function used to
+ * read the device frequency specified in the fdt file.
+ * get the desired clock selection and dividers for a specific device freq.
+ *
+ * @param [in]  node
+ * @param [in]  pointer to the fdt file
+ * @param [in]  device_num ex: NLM_NAE
+ * @param [out]  pointer to the clock no.(dev clk 0, 1, 2)
+ * @param [out]  pointer to the division value.
+ *
+ * @ingroup hal
+ **/
+void nlm_hal_fdt_get_devfreq_params(int node, void *fdt, int dev_num, int *clock, int *div)
+{
+    int frequency = 0;
+
+    frequency = nlm_hal_get_fdt_freq(fdt, dev_num);
+
+	if (nlm_hal_get_devfreq_clk_div(node, frequency, clock, div))
+		nlm_print("unmatchable Dev_clock and divisor for the device=%d freq=%d : using defaults\n",
+			dev_num, frequency);
+
+}
+#endif
+
+/*
+ * @brief nlm_hal_read_dev_freq function is used to read the frequency
+ * of a device on the system.
+ *
+ * @param [in]  node
+ * @param [in]  device_id for which we need the frequency.
+ *
+ * @return
+ * actual frequency on system
+ *
+ * @ingroup hal
+ *
+ * Ex: dev_id = XLP9XX_CLKDEV_NET for nae
+ **/
+uint64_t xlp9xx_get_dev_freq(int node, int dev_id)
+{
+	uint32_t sel, div, mul, clk_freq;
+	uint32_t dev_shift = dev_id << 1;
+	uint64_t sys_clk_base = xlp9xx_sys_clk_base[node];
+
+	sel = (syssoc_read_reg(sys_clk_base, CLK_DEVSEL) >> dev_shift) & 0x3;
+	div = (syssoc_read_reg(sys_clk_base, CLK_DEVDIV) >> dev_shift) & 0x3;
+	mul = syssoc_read_reg(sys_clk_base, DEV_PLLCTRL_1 + (4*(sel-1)));
+
+	if (sel)
+		clk_freq = 400 + 33*mul;
+	else
+		clk_freq = 133; /* reference sys clk */
+
+	clk_freq /= 1 << div;
+
+	nlm_print("sel:%d div:%d FREQUENCY :%d MHz\n", sel, div, clk_freq);
+	return (uint64_t) (clk_freq * 1000000);
+}
+
 /*
  * @brief nlm_hal_get_fdt_freq function is used to read the frequency specified in the fdt file.
  *
@@ -1368,4 +1555,10 @@ EXPORT_SYMBOL(nlm_hal_get_fdt_freq);
 EXPORT_SYMBOL(nlm_hal_dtr_init);
 EXPORT_SYMBOL(nlm_hal_set_rsa_data_mode);
 
+EXPORT_SYMBOL(xlp9xx_set_nae_frequency);
+EXPORT_SYMBOL(xlp9xx_set_soc_frequency);
+
+EXPORT_SYMBOL(xlp9xx_device_clock_init);
+EXPORT_SYMBOL(xlp9xx_get_dev_freq);
+	
 #endif
-- 
1.7.1

