From 33dc385667a1f9b8818ea31758f3e66c4049e363 Mon Sep 17 00:00:00 2001
From: reshmic <reshmic@broadcom.com>
Date: Wed, 28 Mar 2012 12:48:14 +0530
Subject: Fixed sae compilation warning.

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/crypto/sae/nlm_aead.c b/drivers/crypto/sae/nlm_aead.c
index 3a01f7f..eb2c593 100755
--- a/drivers/crypto/sae/nlm_aead.c
+++ b/drivers/crypto/sae/nlm_aead.c
@@ -119,6 +119,7 @@ extern int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pk
 
 static int no_of_alg_registered = 0;
 
+#ifdef NLM_CRYPTO_DEBUG
 static void print_buf(unsigned char *msg, unsigned char *buf, int len)
 {
 #define TMP_BUF		50
@@ -140,7 +141,7 @@ static void print_buf(unsigned char *msg, unsigned char *buf, int len)
 		printk("[%s]\n",tmp_buf);
 	}
 }
-
+#endif
 static struct nlm_aead_ctx *nlm_crypto_aead_ctx(struct crypto_aead *tfm)
 {
 
@@ -515,7 +516,7 @@ static int aead_gcm_rfc4106_setkey( struct crypto_aead *tfm, const u8 *key,
 	}
 	
 	ret = nlm_crypto_fill_pkt_ctrl(ctrl,0,auth_alg,NLM_HASH_MODE_GCM,cipher_alg,
-		NLM_CIPHER_MODE_GCM,0,key,cipher_keylen,key,cipher_keylen);
+		NLM_CIPHER_MODE_GCM,0,(u8*)key,cipher_keylen,(u8*)key,cipher_keylen);
 	ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_HASH_MODE_GCM];
 #ifdef	NLM_CRYPTO_DEBUG
 	print_buf("KEY\n",key,cipher_keylen);	
@@ -563,7 +564,7 @@ static int aead_ccm_rfc4309_setkey(struct crypto_aead *tfm, const u8 *key,
 	
 
 	
-	ret = nlm_crypto_fill_pkt_ctrl(ctrl,0,auth_alg,NLM_HASH_MODE_CCM,cipher_alg,NLM_CIPHER_MODE_CCM,0,key,cipher_keylen,key,cipher_keylen);
+	ret = nlm_crypto_fill_pkt_ctrl(ctrl,0,auth_alg,NLM_HASH_MODE_CCM,cipher_alg,NLM_CIPHER_MODE_CCM,0,(u8*)key,cipher_keylen,(u8*)key,cipher_keylen);
 	ctx->iv_len = cipher_mode_iv_len[cipher_alg][NLM_HASH_MODE_GCM];
 #ifdef	NLM_CRYPTO_DEBUG
 	print_buf("KEY\n",key,cipher_keylen);	
@@ -732,7 +733,6 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
-	struct aead_tfm *crt = crypto_aead_crt(tfm);
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	struct nlm_crypto_pkt_param *param;
 	unsigned int cipher_off, auth_off, iv_off;
@@ -748,7 +748,9 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
 	char * iv = (uint8_t *)NLM_IV_OFFSET(aead_request_ctx(req)); 
 	uint8_t *tmp_iv = iv;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
@@ -846,10 +848,14 @@ static int aead_crypt_gcm(struct aead_request *req, unsigned int op)
 	tx_id = (uint64_t)(unsigned long)async;
 
 	//construct pkt, send to engine and receive reply
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	if(err){
 		printk("err\n");
 		return -EIO;
@@ -865,7 +871,6 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
-	struct aead_tfm *crt = crypto_aead_crt(tfm);
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	struct nlm_crypto_pkt_param *param;
 	unsigned int cipher_off, auth_off, iv_off;
@@ -885,7 +890,9 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	unsigned int extralen = 0, cipher_extralen =0;
 	int seg = 0;
 	uint8_t *tmp_iv = &iv[1];
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
@@ -1059,10 +1066,14 @@ static int aead_crypt_ccm(struct aead_request *req, unsigned int op)
 	tx_id = (uint64_t)(unsigned long)async;
 
 	//construct pkt, send to engine and receive reply
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	if(err){
 		printk("err\n");
 		return -EIO;
@@ -1078,7 +1089,6 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
-	struct aead_tfm *crt = crypto_aead_crt(tfm);
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	struct nlm_crypto_pkt_param *param;
 	unsigned int cipher_off, iv_off;
@@ -1095,7 +1105,9 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	unsigned int authsize,maxauthsize;
 	uint8_t *iv = NULL; 
 	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
@@ -1183,10 +1195,14 @@ static int aead_crypt_ctr(struct aead_request *req, unsigned int op)
 	tx_id = (uint64_t)(unsigned long)async;
 
 	//construct pkt, send to engine and receive reply
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	if(err){
 		return -EIO;
 	}
@@ -1200,7 +1216,6 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
-	struct aead_tfm *crt = crypto_aead_crt(tfm);
 	struct nlm_crypto_pkt_param *param;
 	unsigned int cipher_off, iv_off;
 	unsigned int auth_len, cipher_len, auth_off;
@@ -1214,7 +1229,9 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 	int err=0;
 	unsigned int authsize,maxauthsize;
 	struct nlm_crypto_pkt_ctrl *ctrl = NULL;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
@@ -1287,10 +1304,14 @@ static int aead_crypt_3des(struct aead_request *req, unsigned int op)
 	tx_id = (uint64_t)(unsigned long)async;
 
 	//construct pkt, send to engine and receive reply
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	if(err){
 		printk("err\n");
 		return -EIO;
@@ -1304,7 +1325,6 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct crypto_alg *alg = tfm->base.__crt_alg;
 	struct aead_alg *aead= &alg->cra_aead;
-	struct aead_tfm *crt = crypto_aead_crt(tfm);
 	struct nlm_aead_ctx *ctx = (struct nlm_aead_ctx *)nlm_crypto_aead_ctx(tfm);
 	struct nlm_crypto_pkt_param *param;
 	unsigned int cipher_off, iv_off;
@@ -1319,7 +1339,9 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 	int err=0;
 	unsigned int authsize,maxauthsize;
 	struct nlm_crypto_pkt_ctrl *ctrl = &ctx->ctrl;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	unsigned int max_frags  = MAX_FRAGS;
 	int node_sae_base;
 	int node;
@@ -1391,10 +1413,14 @@ static int aead_crypt(struct aead_request *req, unsigned int op)
 
 
 	//construct pkt, send to engine and receive reply
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	err = nlm_hal_send_msg3(node_sae_base, 0 /*code */ , entry0, entry1, tx_id);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	if(err){
 		printk("err\n");
 		return -EIO;
diff --git a/drivers/crypto/sae/nlm_auth.c b/drivers/crypto/sae/nlm_auth.c
index c66fb91..5aff0aa 100644
--- a/drivers/crypto/sae/nlm_auth.c
+++ b/drivers/crypto/sae/nlm_auth.c
@@ -271,7 +271,9 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 	uint16_t stat = auth_ctx->stat;
 	int cpu = hard_smp_processor_id();
         extern int ipsec_sync_vc;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	int node_sae_base;
 	int node;
 
@@ -297,7 +299,9 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 			0,auth_pkt_desc->total_len,0,out); 
 
 	preempt_disable();
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 
 	fb_vc = crypto_get_sync_fb_vc(&node);
 	entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
@@ -322,7 +326,9 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 
 	if (timeout >= 0xffffffffULL) {
 		printk("\nError: FreeBack message is not received");
+#ifdef CONFIG_32BIT
 		msgrng_access_disable(msgrng_flags);
+#endif
 		if ( auth_pkt_desc->is_allocated )
 			kfree(auth_pkt_desc->pkt_param);
 		preempt_enable();
@@ -332,7 +338,9 @@ xlp_auth_final(struct shash_desc *desc, uint8_t *out)
 #ifdef NLM_CRYPTO_DEBUG
 	print_buf("AUTH:", out, 16);
 #endif
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	preempt_enable();
 	if ( auth_pkt_desc->is_allocated )
 		kfree(auth_pkt_desc->pkt_param);
@@ -370,7 +378,9 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
         extern int ipsec_sync_vc;
 	uint64_t tx_id=0x12345678ULL;
 	uint64_t  timeout = 0;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
 	int node_sae_base;
 	int node;
 	char * tmp = kmalloc(keylen + sizeof(struct nlm_crypto_pkt_ctrl) + sizeof( struct nlm_crypto_pkt_param ) 
@@ -387,7 +397,9 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
         nlm_crypto_fill_src_dst_seg(pkt_param,0,MAX_FRAGS,tmp_key,keylen);
 
 
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
         fb_vc = crypto_get_sync_fb_vc(&node);
         entry0 = nlm_crypto_form_pkt_fmn_entry0(fb_vc, 0, 0, 0, virt_to_phys(ctrl));
         entry1 = nlm_crypto_form_pkt_fmn_entry1(0, 0, (32 + 16 ), virt_to_phys(pkt_param));
@@ -409,7 +421,9 @@ int hash_key(int alg, int mode, const uint8_t * key, unsigned int keylen, uint8_
                 nlm_hal_recv_msg2(ipsec_sync_vc, &src, &size, &code, &entry0, &entry1);
         } while(entry0 != tx_id && timeout < 0xfffffUL) ;
 	kfree(tmp);
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	return 0;
 
 	
diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index 03103aa..354be9f 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -118,6 +118,7 @@ int auth_mode_key_len[NLM_HASH_MAX][NLM_HASH_MODE_MAX] = {
 
 #define MAX_KEY_LEN_IN_DW 20
 #define NLM_CRYPTO_MAX_STR_LEN 200
+#ifdef NLM_CRYPTO_DEBUG
 static char str_cipher_alg[NLM_CIPHER_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
 "bypass",       // NLM_CIPHER_BYPASS
 "des",          // NLM_CIPHER_DES
@@ -175,7 +176,6 @@ static char str_auth_mode[NLM_HASH_MODE_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
 "cbc mac",      // NLM_AUTH_MODE_CBC_MAC
 "undefined", // > max
 };
-#ifdef NLM_CRYPTO_DEBUG
 void hex_dump(char * description,unsigned char *in, int num)
 {
         int i, j;
@@ -557,7 +557,7 @@ nlm_xlp_sae_msgring_handler(uint32_t vc, uint32_t src_id,
 	uint64_t msg0, uint64_t msg1,
 	uint64_t msg2, uint64_t msg3, void *data)
 {
-	struct nlm_async_crypto *async = (struct nlm_async_crypto *)(msg0);
+	struct nlm_async_crypto *async = (struct nlm_async_crypto *)(unsigned long )msg0;
 	if(async)	
 		async->callback(async, msg1);
 }
diff --git a/drivers/crypto/sae/nlm_enc.c b/drivers/crypto/sae/nlm_enc.c
index 2d8b40b..ac721cd 100755
--- a/drivers/crypto/sae/nlm_enc.c
+++ b/drivers/crypto/sae/nlm_enc.c
@@ -250,13 +250,15 @@ xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct
 	uint64_t msg0, msg1;
 	int pktdescsize = 0;
 	int fb_vc;
+#ifdef CONFIG_32BIT
 	unsigned long msgrng_flags;
+#endif
+	int node_sae_base;
+	int node ;
 	unsigned int max_frags= MAX_FRAGS;
 	unsigned int cipher_len = req->nbytes;
 	struct nlm_crypto_pkt_param * pkt_param = (struct nlm_crypto_pkt_param *) NLM_CRYPTO_PKT_PARAM_OFFSET(ablkcipher_request_ctx(req));
 	struct nlm_async_crypto * async =  (struct nlm_async_crypto *)NLM_ASYNC_PTR_PARAM_OFFSET(ablkcipher_request_ctx(req));;
-	int node_sae_base;
-	int node ;
 	async->pkt_param = NULL;
 
 	nlm_crypto_fill_cipher_pkt_param(ctrl, pkt_param, enc,0,iv_size,iv_size ,req->nbytes); 
@@ -293,10 +295,14 @@ xlp_crypt(struct ablkcipher_request *req, unsigned int enc, int iv_size, struct
 	async->stat = stat; 
 	async->bytes = req->nbytes; 
 	mb();
+#ifdef CONFIG_32BIT
 	msgrng_access_enable(msgrng_flags);
+#endif
 	node_sae_base = (node << NODE_BASE_SHIFT_BIT) | crypto_vc_base;
 	while( nlm_hal_send_msg3(node_sae_base, 0 /*code */ , msg0, msg1, (unsigned long )async) != 0 );
+#ifdef CONFIG_32BIT
 	msgrng_access_disable(msgrng_flags);
+#endif
 	preempt_enable();
 	return -EINPROGRESS;
 }
-- 
1.7.1

