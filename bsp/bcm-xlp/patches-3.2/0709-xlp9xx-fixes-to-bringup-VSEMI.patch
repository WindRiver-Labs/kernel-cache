From 412e14e5756a730710905f05239cc5f3b13bf3ae Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Tue, 4 Jun 2013 19:37:13 -0700
Subject: xlp9xx: fixes to bringup VSEMI

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
index 78aa030..1d8b945 100644
--- a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
+++ b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
@@ -466,6 +466,7 @@ int register_broadcom_phy(void)
 {
         register_external_phy(&bcm_ext_phy[0]);
 	register_external_phy(&bcm_ext_phy[1]);
+	register_external_phy(&bcm_ext_phy[2]);
         return 0;
 }
 
diff --git a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
index dd653de..a70c10a 100644
--- a/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/netsoc_nae.h
@@ -210,7 +210,7 @@ static int __netsoc_vsemi_cmd_poll_pend(uint64_t mac_base)
                 vsemi_cmd = netsoc_read_mac_reg(mac_base, VSEMI_CMD);
                 if( vsemi_cmd & (1<<31)){
                         retries++;
-                        nlm_mdelay(100);
+                        nlm_mdelay(1);
                         continue;
                 }else{  
                         //nlm_print("VSEMI cmd pend clear\n");  
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
index 77765b6..8eb6dcb 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_vsemi_data.h
@@ -12,7 +12,8 @@ extern void nlm_hal_config_vsemi_mem_xaui_4page(void);
 
 void nlm_hal_config_vsemi_mem_10G_lane(void);   
 void nlm_hal_config_vsemi_mem_10G_lane_4page(void);     
-
+void nlm_hal_config_vsemi_mem_sgmii_4page(void);
+void nlm_hal_config_vsemi_mem_sgmii(void);
 
 
 /*125 Mhz related functions*/
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 5930451..7b5cd41 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -133,8 +133,15 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
         int intf_type = DC_NOT_PRSNT, offset;
 	int node = nae_cfg->node;
         char port_type_str[MAX_PROP_LEN];
+	char xaui_chk_str[16];
 
 	netsoc_api_print(NETSOC_APIDBG_FDT,"get_interface_type node %d block %d port %d\n",node, block, port);
+	if(socnet_version_v0){
+		strcpy(xaui_chk_str, "xaui");
+	}else{
+		
+		strcpy(xaui_chk_str, "xgmac");
+	}
 #ifndef XLP_SIM
         if (GET_PORT_STR_PROP("cpld", port_type_str, MAX_PROP_LEN) < 0) {
 		intf_type = DC_NOT_PRSNT;
@@ -164,7 +171,7 @@ static int fdt_get_interface_type(void *fdt, char *nae_port_str, int block, int
                 if (!strcmp(port_type_str, "sgmii")) {
                         intf_type = DC_SGMII;
                 }
-                else if (!strcmp(port_type_str, "xaui")) {
+                else if (!strcmp(port_type_str, xaui_chk_str)) {
                         intf_type = DC_XAUI;
                 }
                 else if (!strcmp(port_type_str, "xfi")) {
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
index 6b23a11..bd61591 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_pcs.c
@@ -340,7 +340,7 @@ static int xlp3xx_8xxb0_lane_reset_txpll(nae_t *nae, uint32_t block, uint32_t la
 
 static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
 {
-        uint32_t val = 0;
+        uint32_t val = 0, count=0;
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
         netsoc_api_print(NETSOC_APIDBG_PORT,"%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
@@ -380,6 +380,14 @@ static void xlp9xx_lane_reset(nae_t *nae, int block, int lane_ctrl, int mode)
         	netsoc_write_mac_reg(mac_base, lane_ctrl, val);
         	netsoc_api_print(NETSOC_APIDBG_PORT,"%s Bit 30 epcs removed val =0x%x\n",__func__, val);
 	}
+        while(!((val = netsoc_read_mac_reg(mac_base, lane_ctrl-PHY_LANE_0_CTRL)) & PHY_LANE_STAT_PCR)) {
+                count++;
+                if (count == 1000) {
+                        netsoc_api_print(NETSOC_APIDBG_ERROR,"%s PMA controller not ready\n",__func__);
+			 netsoc_api_delay(1000);	
+                }
+        }
+	netsoc_api_print(NETSOC_APIDBG_PORT, "Lane reset complete - PMA ready\n");
 	return;
 }
 
@@ -580,10 +588,10 @@ static void xlp8xx_ilk_reset_pll(nae_t *nae, int ilk_block_base, int ilk_num_lan
 
 void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed, int phy_mode)
 {
-        uint32_t reg_addr, lane_no;
+        uint32_t reg_addr, lane_no, max_lanes =4;  
         uint32_t vsemi_cmd=0;
 	uint32_t delay, vsemi_config;
-	uint32_t lwidth = 0;
+	uint32_t lwidth = 1;
 	
 	uint32_t lane_speed = XAUI_TYPE_LANE;
 	
@@ -593,9 +601,12 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	if(phy_mode == PHYMODE_RXAUI){
 		lwidth =1; /*TODO: Verify for XLP9XX*/
 	}
+	if(block==2 && (phy_mode == PHYMODE_SGMII)){
+		max_lanes =1;
+	}	
 
         for (reg_addr=101; reg_addr <111; reg_addr++){
-                for (lane_no=0; lane_no<4; lane_no++) {
+                for (lane_no=0; lane_no<max_lanes; lane_no++) {
                         vsemi_cmd=0;
                         if((xgmii_speed==16 ) && (lane_speed ==XAUI_TYPE_LANE)){
                                 vsemi_cmd |= vsemi_mem_16G_4page[reg_addr];
@@ -627,7 +638,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
                 if((xgmii_speed==12 ) && (lane_speed ==XAUI_TYPE_LANE)){
                         vsemi_cmd |= vsemi_mem_12G[reg_addr];
                 }
-                if((xgmii_speed==10 ) && (lane_speed ==XFI_TYPE_LANE)){
+                if((xgmii_speed==10 ) && (lane_speed ==XAUI_TYPE_LANE)){
                         vsemi_cmd |= vsemi_mem_xaui[reg_addr];
                         //nlm_print("vsemi cmd: mem xaui [%X]:%X\n", reg_addr, vsemi_cmd);
                 }
@@ -657,14 +668,14 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 	}
 	
 
-        for (lane_no=0; lane_no<4; lane_no++) {
+        for (lane_no=0; lane_no<max_lanes; lane_no++) {
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 21, 0xd9);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 22, 0x0);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 23, 0x0);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 87, 0x1f);
         }
 
-        for (lane_no=0; lane_no<4; lane_no++) {
+        for (lane_no=0; lane_no<max_lanes; lane_no++) {
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 24, 0x2);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 25, 0x0);
                 __netsoc_write_vsemi_reg(mac_base, lane_no, 26, 0x08);
@@ -691,7 +702,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, 0x4, 0x4);
 	}
 	
-    	for (lane_no=0; lane_no<4; lane_no=lane_no+lwidth) {
+    	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: Waiting for block %d lane %d PCSOUT_RX_READY\n", block, lane_no);
 		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
 		while((vsemi_cmd & 0x1) != 0x1){
@@ -699,7 +710,7 @@ void xlp9xx_nae_write_pma2p0_mem(uint64_t mac_base, int block, int xgmii_speed,
 		}
 	}	
     	
-	for (lane_no=0; lane_no<4; lane_no=lane_no+lwidth) {
+	for (lane_no=0; lane_no<max_lanes; lane_no=lane_no+lwidth) {
 		netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: Waiting for block %d lane %d PCSOUT_TX_READY\n", block, lane_no);
 		vsemi_cmd = __netsoc_read_vsemi_reg(mac_base, lane_no, 11);
 		while((vsemi_cmd & 0x4) != 0x4){
@@ -716,9 +727,9 @@ static void xlp9xx_config_pma2p0_serdes(nae_t *nae, uint32_t block, uint32_t vse
 	uint64_t mac_base = netsoc_get_macreg_base_for_phy(nae->mac_base, block);
 
 	       	if(!vsemi_por){
-                        vsemi_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, block+1), VSEMI_CTL0);
+                        vsemi_config = netsoc_read_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), VSEMI_CTL0);
                         vsemi_config &= ~VSEMI_CTL_POR;
-                        netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, block+1), VSEMI_CTL0, vsemi_config);
+                        netsoc_write_mac_reg(netsoc_get_macreg_base_for_phy(nae->mac_base, 2), VSEMI_CTL0, vsemi_config);
                	}
                
 		vsemi_config = netsoc_read_mac_reg(mac_base, VSEMI_CTL0);
@@ -847,7 +858,6 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
         int block, lane_ctrl;
         unsigned int cplx_lane_enable = LM_SGMII | (LM_SGMII << 4) | (LM_SGMII << 8) | (LM_SGMII << 12);
         int lane_enable = 0;
-        static int vsemi_por=0;
 	uint64_t mac_base = netsoc_get_macreg_base_for_lanecfg(nae->mac_base);
 
         /*  Lane mode progamming
@@ -896,14 +906,12 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
                 }
 
                 if(is_nlm_xlp2xx()){
-			xlp2xx_config_block_vsemi(nae, block, vsemi_por, 0, PHYMODE_SGMII);
-			if (!vsemi_por)
-				vsemi_por++;
+			xlp2xx_config_block_vsemi(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
+			nae->serdes_init_cnt++; 
                 }
 		if(is_nlm_xlp9xx()){
-			xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, 0, PHYMODE_SGMII);
-			if (!vsemi_por)
-				vsemi_por++;
+			xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, 0, PHYMODE_SGMII);
+			nae->serdes_init_cnt++;	
 		}
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
@@ -926,18 +934,17 @@ static void __netsoc_xlp_nae_config_lane_gmac(nae_t *nae, int cplx_mask)
 
 static void xlp2xx_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
+
 	vsemi_mem_init_sgmii_125Mhzrefclk();
         nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz();
-
         __netsoc_xlp_nae_config_lane_gmac(nae, sgmii_cplx_mask);
         netsoc_api_print(NETSOC_APIDBG_PORT,"Net:   Completed XLP2XX SGMII PCS Configuration\n");
 }
 
 static void xlp9xx_sgmii_pcs_init(nae_t *nae, uint32_t sgmii_cplx_mask)
 {
-	vsemi_mem_init_sgmii_125Mhzrefclk();
-        nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz();
-
+        nlm_hal_config_vsemi_mem_sgmii();
+        nlm_hal_config_vsemi_mem_sgmii_4page();
         __netsoc_xlp_nae_config_lane_gmac(nae, sgmii_cplx_mask);
         netsoc_api_print(NETSOC_APIDBG_PORT,"Net: Completed XLP9XX SGMII PCS Configuration\n");
 }
@@ -1003,7 +1010,6 @@ static void config_lanes_for_xfi(nae_t *nae, uint32_t xfi_cplx_mask)
 static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t phymode)
 {
 	uint32_t block, lane_status, lane_ctrl, count, timeout = 10000;
-	static int vsemi_por=0;
 	uint64_t mac_base;
 	
 	config_lanes_for_xaui(nae, xaui_cplx_mask);
@@ -1032,11 +1038,8 @@ static void xlp2xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                         nlm_hal_config_vsemi_mem_xaui_125();
                 }
 		
-		xlp2xx_config_block_vsemi(nae, block, vsemi_por, xaui_speed, 0);
-                
-		if (!vsemi_por){
-                        vsemi_por++;
-                }
+		xlp2xx_config_block_vsemi(nae, block, nae->serdes_init_cnt, xaui_speed, 0);
+		nae->serdes_init_cnt++;	
 
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			//TODO: XLP9XX all four lanes used for RXAUI
@@ -1131,17 +1134,14 @@ static void xlp9xx_xaui_pcs_init(nae_t *nae, uint32_t xaui_cplx_mask, uint32_t p
                 }
                 else {
                         netsoc_api_print(NETSOC_APIDBG_PORT,"VSEMI: config data for 10G XAUI/RXAUI \n");
-                        nlm_hal_config_vsemi_mem_xaui_4page_125();
-                        nlm_hal_config_vsemi_mem_xaui_125();
+                        nlm_hal_config_vsemi_mem_xaui_4page();
+                        nlm_hal_config_vsemi_mem_xaui();
                 }
 		
 		/*config PMA2P0 block */
-		xlp9xx_config_pma2p0_serdes(nae, block, vsemi_por, xaui_speed, phymode);
+		xlp9xx_config_pma2p0_serdes(nae, block, nae->serdes_init_cnt, xaui_speed, phymode);
+		nae->serdes_init_cnt++;	
                 
-		if (!vsemi_por){
-                        vsemi_por++;
-                }
-
                 for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			//TODO: XLP9XX all four lanes used for RXAUI
 			if(phymode == PHYMODE_RXAUI && (lane_ctrl%2))
-- 
1.7.1

