From 4d8b0e4520d1e70a93896a1797d9269fdecfe7fc Mon Sep 17 00:00:00 2001
From: Rahul Jain <rajain@netlogicmicro.com>
Date: Thu, 9 Feb 2012 23:28:05 +0530
Subject: nae-perf: fixes for borderline scenarios

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.c b/drivers/misc/netlogic/nae-perf/xlp_nae.c
index d90b231..582a03a 100755
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.c
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.c
@@ -300,7 +300,7 @@ static __inline__ void print_fmn_send_error(const char *str, uint32_t send_resul
 
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
-        uint64_t *back_ptr = (uint64_t *)(addr - MAC_SKB_BACK_PTR_SIZE);
+        uint64_t *back_ptr = (uint64_t *)(addr - SKB_BACK_PTR_SIZE);
         /* this function should be used only for newly allocated packets. It assumes
          * the first cacheline is for the back pointer related book keeping info
          */
@@ -314,7 +314,7 @@ static __inline__ void mac_put_skb_back_ptr(struct sk_buff *skb)
         /* this function should be used only for newly allocated packets. It assumes
          * the first cacheline is for the back pointer related book keeping info
          */
-        skb_reserve(skb, MAC_SKB_BACK_PTR_SIZE);
+        skb_reserve(skb, SKB_BACK_PTR_SIZE);
         *back_ptr = (uint64_t)skb;
 }
 
@@ -342,7 +342,7 @@ static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
 static __inline__ struct sk_buff *nlm_xlp_alloc_skb(void)
 {
         int offset = 0;
-        struct sk_buff *skb = __dev_alloc_skb(NLM_RX_BUF_SIZE, GFP_KERNEL);
+        struct sk_buff *skb = __dev_alloc_skb(NLM_RX_ETH_BUF_SIZE, GFP_KERNEL);
 
         if (!skb) {
                 return NULL;
@@ -703,14 +703,24 @@ static int mac_refill_frin_skb(uint64_t paddr, int qid)
 	return ret;
 }
 
-static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu, int size)
+static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu, int len)
 {
 	struct dev_data* priv;
 	struct net_device *ndev;
 	struct sk_buff * skb;
 	int freein_fifo;
+	int buf_size;
 
-	skb = nlm_xlp_alloc_skb_atomic(size);
+	if (!enable_jumbo || ((len - ETH_HLEN) <= ETH_DATA_LEN))
+		buf_size = NLM_RX_ETH_BUF_SIZE;
+	else
+		buf_size = NLM_RX_JUMBO_BUF_SIZE;
+
+	freein_fifo = frin_queue_base + (cpu/num_cpu_share_freein);
+	if (enable_jumbo && ((len - ETH_HLEN) <= ETH_DATA_LEN) )
+		freein_fifo += jumbo_freein_offset;
+
+	skb = nlm_xlp_alloc_skb_atomic(buf_size);
 	if(!skb)
 	  {
 	    printk("[%s] alloc skb failed\n",__FUNCTION__);
@@ -722,10 +732,6 @@ static int mac_refill_frin_one_buffer(struct net_device *dev, int cpu, int size)
 	priv = netdev_priv(ndev);
 	skb->dev = ndev;
 
-	freein_fifo = frin_queue_base + (cpu/num_cpu_share_freein);
-	if (enable_jumbo && size > NLM_RX_BUF_SIZE)
-		freein_fifo += jumbo_freein_offset;
-
 	skb->queue_id = freein_fifo;
 
 	mac_put_skb_back_ptr(skb);
@@ -939,7 +945,7 @@ static int xlp_poll_lower(int budget, int cpu)
 
 		vaddr = (uint64_t)bus_to_virt(addr);
 
-		len = len  - MAC_CRC_LEN;
+		len = len  - ETH_FCS_LEN;
 
 		skb = mac_get_skb_back_ptr(vaddr);
 		//printk ("cpu %d Freein_fifo %d len %d skb->len %d \n", cpu, skb->queue_id, len, skb->len);
@@ -991,10 +997,7 @@ static int xlp_poll_lower(int budget, int cpu)
 		if (last_rcvd_skb[LAST_RCVD_INDEX(cpu)]) {
 		  //printk("[%s@%d]: Unwanted buffer allocation in driver data path!\n", __FILE__, __LINE__);
 			slow_replenish_count[LAST_RCVD_INDEX(cpu)]++;
-			if (!enable_jumbo || ((len + MAC_CRC_LEN) <= NLM_RX_BUF_SIZE))
-				mac_refill_frin_one_buffer(pdev, cpu, NLM_RX_BUF_SIZE);
-			else
-				mac_refill_frin_one_buffer(pdev, cpu, NLM_RX_JUMBO_BUF_SIZE);
+			mac_refill_frin_one_buffer(pdev, cpu, len);
 			last_rcvd_skb[LAST_RCVD_INDEX(cpu)] = NULL;
 		}
 	}
@@ -1120,7 +1123,7 @@ static void nlm_replenish_per_cpu_buffer(int qindex, int bufcnt)
 	int size = 0;
 
 	if (!enable_jumbo || (qindex < jumbo_freein_offset) || (qindex >= (jumbo_freein_offset * 2)))
-		size = NLM_RX_BUF_SIZE;
+		size = NLM_RX_ETH_BUF_SIZE;
 	else
 		size = NLM_RX_JUMBO_BUF_SIZE;
 
@@ -1301,13 +1304,15 @@ static void nlm_xlp_nae_init(void)
 	/* Update RX_CONFIG for desc size */
 	if(enable_jumbo)
 	{
-		nlm_hal_init_ingress (node, DEFAULT_JUMBO_MTU);
+		nlm_hal_init_ingress (node, ETH_JUMBO_DATA_LEN+ETH_HLEN+ETH_FCS_LEN);
 		num_cpu_share_freein = 4;
 		if (is_nlm_xlp8xx())
 			jumbo_freein_offset = (frin_total_queue - NUM_XLP8XX_MGMT_PORTS)/2;
 		else
 			jumbo_freein_offset = frin_total_queue/2;
 	}
+	else
+		nlm_hal_init_ingress (node, ETH_DATA_LEN+ETH_HLEN+ETH_FCS_LEN);
 
 
 	printk("nae_cfg frin_queue_base %d, frin_total_queue %d\n",nae_cfg->frin_queue_base, nae_cfg->frin_total_queue);
@@ -1836,33 +1841,32 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	unsigned long flags;
-	unsigned long local_jumbo_mtu;
+	unsigned long local_mtu;
 
-	if (enable_jumbo && ((new_mtu > (DEFAULT_JUMBO_MTU * MAX_SKB_FRAGS)) || (new_mtu < MIN_ETH_FRAME_SIZE))) {
+	if (enable_jumbo && (new_mtu > ETH_JUMBO_DATA_LEN || new_mtu < ETH_ZLEN)) {
+		printk ("MTU should be between %d and %d\n", ETH_ZLEN, ETH_JUMBO_DATA_LEN);
 		return -EINVAL;
 	}
 
-	if (!enable_jumbo && (new_mtu > MAC_MAX_FRAME_SIZE || new_mtu < MIN_ETH_FRAME_SIZE)) {
+	if (!enable_jumbo && (new_mtu > ETH_DATA_LEN || new_mtu < ETH_ZLEN)) {
+		printk ("MTU should be between %d and %d\n", ETH_ZLEN, ETH_DATA_LEN);
 		return -EINVAL;
 	}
 
 	if(priv->type==INTERLAKEN_IF){
 		return -EINVAL;
 	}
-	printk("Setting mtu %d bytes \n", new_mtu);
 
 	spin_lock_irqsave(&priv->lock, flags);
 
-	local_jumbo_mtu = new_mtu + ETH_HLEN + ETH_FCS_LEN;
-	local_jumbo_mtu = (local_jumbo_mtu + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1);
+	local_mtu = new_mtu + ETH_HLEN + ETH_FCS_LEN;
+	local_mtu = (local_mtu + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1);
 
 	if(priv->type==SGMII_IF){
-		nlm_hal_set_sgmii_framesize(priv->node, priv->block, priv->index, local_jumbo_mtu);
-		printk ("New MTU for MAC (SGMII) is %ld bytes\n", local_jumbo_mtu);
+		nlm_hal_set_sgmii_framesize(priv->node, priv->block, priv->index, local_mtu);
 	}
 	if(priv->type==XAUI_IF){
-		nlm_hal_set_xaui_framesize(priv->node, priv->block, local_jumbo_mtu, local_jumbo_mtu);
-		printk ("New MTU for MAC (XAUI) is %ld bytes\n", local_jumbo_mtu);
+		nlm_hal_set_xaui_framesize(priv->node, priv->block, local_mtu, local_mtu);
 	}
 
 	dev->mtu = new_mtu;
diff --git a/drivers/misc/netlogic/nae-perf/xlp_nae.h b/drivers/misc/netlogic/nae-perf/xlp_nae.h
index 01e3d8e..6009ff5 100644
--- a/drivers/misc/netlogic/nae-perf/xlp_nae.h
+++ b/drivers/misc/netlogic/nae-perf/xlp_nae.h
@@ -1,20 +1,32 @@
 #ifndef _XLP_NAE_H
 #define _XLP_NAE_H
 
-#define MIN_ETH_FRAME_SIZE	64
-#define MAC_MAX_FRAME_SIZE	1600
-#define DEFAULT_JUMBO_MTU	16384
-#define MAC_SKB_BACK_PTR_SIZE	SMP_CACHE_BYTES
+#if 0
+/*
+ *      IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *      and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN        6               /* Octets in one ethernet addr   */
+#define ETH_HLEN        14              /* Total octets in header.       */
+#define ETH_ZLEN        60              /* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN    1500            /* Max. octets in payload        */
+#define ETH_FRAME_LEN   1514            /* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN     4               /* Octets in the FCS             */
+#endif
 
 #define MAC_PREPAD		0
 #define BYTE_OFFSET		2
-#define NLM_RX_BUF_SIZE		(MAC_MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
-#define NLM_RX_JUMBO_BUF_SIZE	(DEFAULT_JUMBO_MTU+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
-#define MAC_HDR_LEN		14
-#define MAC_CRC_LEN		4
+#define ETH_JUMBO_DATA_LEN	16000
+
 #define CACHELINE_SIZE		(1ULL << 6)
 #define CACHELINE_ALIGNED(addr)	( ((addr) + (CACHELINE_SIZE-1)) & ~(CACHELINE_SIZE-1) )
 
+#define SKB_BACK_PTR_SIZE	CACHELINE_SIZE
+
+#define NLM_RX_ETH_BUF_SIZE	(ETH_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+MAC_PREPAD+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
+#define NLM_RX_JUMBO_BUF_SIZE	(ETH_JUMBO_DATA_LEN+ETH_HLEN+ETH_FCS_LEN+BYTE_OFFSET+MAC_PREPAD+SKB_BACK_PTR_SIZE+CACHELINE_SIZE)
+
 extern unsigned long long netlib_vaddrb;
 extern unsigned long long netlib_paddrb;
 #define INIT_VBASE( vbase, pbase) {netlib_vaddrb = vbase ; netlib_paddrb = pbase;}
-- 
1.7.1

