From 67fd98a6c831685519725de4702a6c8c3ae5d2d9 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Thu, 15 Aug 2013 16:34:55 +0530
Subject: fmn: enabled interrupts on all available cpu on xlp9xx

[Based on SDK 3.2]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/drivers/misc/netlogic/soc_interface/on_chip.c b/drivers/misc/netlogic/soc_interface/on_chip.c
index 4df329e..d170b57 100644
--- a/drivers/misc/netlogic/soc_interface/on_chip.c
+++ b/drivers/misc/netlogic/soc_interface/on_chip.c
@@ -52,6 +52,7 @@
 #include <linux/netdevice.h>
 
 #define MAX_VC	4096
+/* #define ONCHIP_DEBUG 1 */
 
 static int is_cpu_core_xlp_ii = 0;
 unsigned int xlp_napi_vc_mask = 0;
@@ -74,6 +75,7 @@ EXPORT_SYMBOL(fdt);
 
 uint32_t msgring_global_thread_mask = 0;
 uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
+uint32_t nlm_cpu_vc_mask_9xx[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0};
 
 uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
 
@@ -723,6 +725,34 @@ void nlm_enable_vc_intr(void)
 	}
 }
 
+void nlm_enable_vc_intr_9xx(void)
+{
+        int cpu, node;
+        int vc_index = 0;
+        int i = 0;
+
+        for(cpu=0; cpu < NR_CPUS; cpu++){
+                if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
+                        continue;
+                node = cpu / NLM_MAX_CPU_PER_NODE_9XX;
+                for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
+                        vc_index = (i + cpu * NLM_MAX_VC_PER_THREAD_9XX) & NLM_MAX_VC_MASK_9XX;
+                        if(nlm_cpu_vc_mask_9xx[cpu] & (1<<i)){
+                                /*enable interrupts*/
+                                nlm_hal_enable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("ENABLED: node = %d, vc = %d\n",node, vc_index);
+#endif
+                        } else{
+                                nlm_hal_disable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("DISABLED: node = %d, vc = %d\n",node, vc_index);
+#endif
+                        }
+                }
+        }
+}
+
 
 int xlp_fmn_poll(struct napi_struct *napi, int budget)
 {
@@ -927,6 +957,72 @@ static void parse_fmn_config(void)
 	}
 }
 
+void initialize_cpumask_new_9xx(int node, big_mask_t *onlinemask)
+{
+	onlinemask->map[node][0] = 0xffffffffffffffff;	/* 64 cpu */
+	onlinemask->map[node][1] = 0xffff;		/* 16 cpu */	
+}
+
+static void parse_fmn_config_9xx(void)
+{
+	uint32_t node_vc_mask[NLM_MAX_COREPAIR_PER_NODE_9XX] = {0};
+	unsigned char buf[30];
+	int i, j, id=0, k, tmp;
+	void *node;
+	big_mask_t onlinemask;
+
+	for(i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+		initialize_cpumask_new_9xx(i, &onlinemask);
+	}
+
+	node = finddevice("/doms/dom@0/fmn");
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask.map[i][0] || onlinemask.map[i][1]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
+						if(j < 64) {
+							if (onlinemask.map[i][0] & (1 << j))
+								nlm_cpu_vc_mask_9xx[id] = 0xf;
+						}
+						else {
+							if (onlinemask.map[i][1] & (1 << j))
+								nlm_cpu_vc_mask_9xx[id] = 0xf;
+						}
+					}
+				}
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = (NLM_MAX_COREPAIR_PER_NODE_9XX - 1); j >= 0; j--) {
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask_9xx[id++] = (tmp >> (k * 4)) & 0xf;
+					}
+				}
+			}
+		}
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+			if (onlinemask.map[i][0] || onlinemask.map[i][1]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
+					if(j < 64) {
+						if (onlinemask.map[i][0] & (1 << j))
+							nlm_cpu_vc_mask_9xx[id] = 0xf;
+					}
+					else {
+						if (onlinemask.map[i][1] & (1 << j))
+							nlm_cpu_vc_mask_9xx[id] = 0xf;
+					}
+				}
+			}
+		}
+	}
+}
+
 int nae_rx_vc = -1, nae_fb_vc = -1;
 int sae_rx_vc = -1, sae_rx_sync_vc = -1;
 int ipsec_async_vc = -1, ipsec_sync_vc = -1;
@@ -1004,7 +1100,12 @@ static int __init nlm_fmn_init(void)
                 printk("Skipping FMN initialization due to lack of ownership\n");
 
         /* Enable vc interupts for the online cpus */
-        nlm_enable_vc_intr();
+	if(is_nlm_xlp9xx()) {
+		nlm_enable_vc_intr_9xx();
+	}
+	else {
+		nlm_enable_vc_intr();
+	}
 
         return 0;
 
@@ -1039,7 +1140,12 @@ static int __init on_chip_init(void)
 	node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
 	nlm_proc_setup();
 
-	parse_fmn_config();
+	if(is_nlm_xlp9xx()) {
+		parse_fmn_config_9xx();
+	}
+	else {
+		parse_fmn_config();
+	}
 	pr_info("parse done\n");
 
 	parse_fdt_sae_vc_config();
-- 
1.7.1

