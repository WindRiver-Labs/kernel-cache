From c0d8391e5959535848b12bb5aefbcc708eb4ab1d Mon Sep 17 00:00:00 2001
From: P. Sadik <psadik@broadcom.com>
Date: Tue, 27 Nov 2012 11:14:44 +0530
Subject: [PATCH 633/762] NAND: Fix debug print. The debug print produces garbage output; fixed.

Based on Broadcom SDK 2.3.

Signed-off-by: P. Sadik <psadik@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/xlp_plat_nand.c |   44 ++++++++++++++++----------------
 1 files changed, 22 insertions(+), 22 deletions(-)

diff --git a/arch/mips/netlogic/xlp/xlp_plat_nand.c b/arch/mips/netlogic/xlp/xlp_plat_nand.c
index 04e62bb..281d8c6 100644
--- a/arch/mips/netlogic/xlp/xlp_plat_nand.c
+++ b/arch/mips/netlogic/xlp/xlp_plat_nand.c
@@ -70,7 +70,7 @@ static u64 xlp_dev_dmamask = DMA_BIT_MASK(32);
 */
 
 #define XLP_HWECC_OOBSIZE       0xc
-	
+
 struct plat_nand_data {
 	struct nand_chip	chip;
 	struct mtd_info		mtd;
@@ -153,7 +153,7 @@ static void print_oob_data(const unsigned char* p)
 
 static void print_onfi_params(struct nand_onfi_params * p)
 {
-	printk("OFNI parameter \n"); 
+	printk("OFNI parameter \n");
 	printk("rev info and features block\n");
 	printk("revision:%d\n", le16_to_cpu(p->revision));
 	printk("features:%x\n", p->features);
@@ -197,7 +197,7 @@ static void print_onfi_params(struct nand_onfi_params * p)
 	printk("input_pin_capacitance_max: %d\n", p->input_pin_capacitance_max);
 	printk("driver_strenght_support: %d\n", p->driver_strenght_support);
 	printk("t_int_r: %d\n", p->t_int_r);
-	printk("t_ald: %d\n", p->t_ald);        
+	printk("t_ald: %d\n", p->t_ald);
 	printk("crc: %x\n", p->crc);
 
 	printk("\nmanufacturer information block\n");
@@ -305,7 +305,7 @@ void onfi_init(struct nand_chip *chip)
 	{
 		nand_reg_write(node, NAND_ECC_CTRL, (ecc_val << 5));
 		nand_reg_write(node, NAND_ECC_OFFSET, state->page_size + ecc_offset);
-	
+
         	if (ecc_offset < XLP_HWECC_OOBSIZE)
                 	printk("Warning: (file %s): adjust XLP_HWECC_OOBSIZE smaller for nand flash driver!\n",
                         	__FILE__);
@@ -392,7 +392,7 @@ static void send_cmd(struct mtd_info *mtd,
         struct nand_chip *chip = (struct nand_chip *)mtd->priv;
         struct nand_info *info = (struct nand_info *)chip->priv;
         struct nand_state *state = (struct nand_state *)info->nand_state;
-	
+
 	uint64_t val;
 	int node = info->node;
 	int column2, len2;
@@ -463,14 +463,14 @@ static void send_cmd(struct mtd_info *mtd,
         	} else {
                 	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
         	}
-		
+
 		val = nand_reg_read(node, NAND_CTRL) ;
                	nand_reg_write(node, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
         	nand_reg_write(node, NAND_CMD, command | NAND_CMD_DMA_FLAG);
 		dma_wait(node, state->cs);
 		if (enable_hwecc)	{
 			val = nand_reg_read(node, NAND_CTRL);
-        		nand_reg_write(node, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1))); 
+        		nand_reg_write(node, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1)));
 		}
 	}
 
@@ -485,10 +485,10 @@ static void cmdfunc(struct mtd_info *mtd,
         struct nand_chip *chip = (struct nand_chip *)mtd->priv;
         struct nand_info *info = (struct nand_info *)chip->priv;
         struct nand_state *state = (struct nand_state *)info->nand_state;
-       	int node = info->node; 
+       	int node = info->node;
 	int len = 0 ;
         uint32_t val;
-        
+
 	if (state->cs < 0)
                 return;
 
@@ -625,7 +625,7 @@ static uint8_t read_byte(struct mtd_info *mtd)
         struct nand_info *info = (struct nand_info *)chip->priv;
         struct nand_state *state = (struct nand_state *)info->nand_state;
 	int node = info->node;
-        
+
 	uint32_t data ;
 
         if (state->cs < 0)
@@ -648,7 +648,7 @@ static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
         struct nand_info *info = (struct nand_info *)chip->priv;
         struct nand_state *state = (struct nand_state *)info->nand_state;
 	int i;
-        
+
 	if (state->cs < 0)
                 return;
 
@@ -689,7 +689,7 @@ static int read_page(struct mtd_info *mtd,
         if (state->cs < 0)
                 return -1;
 
-        dbp_print ("Read page %s\n",buf);
+        dbp_print ("Read page %p\n",buf);
         read_buf(mtd, buf, mtd->writesize);
 
         return 0;
@@ -750,18 +750,18 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
                 dev_err(&pdev->dev, "failed to get device structure.\n");
                 return -ENOMEM;
         }
-	
+
 	nand_reg_write(node, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
         val = ( NAND_TIME_SEQ0_TWHR(7) |
 		NAND_TIME_SEQ0_TRHW(7) |
 		NAND_TIME_SEQ0_TADL(7) |
 		NAND_TIME_SEQ0_TCCS(7) );
 	nand_reg_write(node, NAND_TIME_SEQ0, val);
-	
+
         val = NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
 	nand_reg_write(node, NAND_TIMINGS_ASYN, val);
 
-        
+
 	info             = (struct nand_info *)kzalloc(sizeof(struct nand_info), GFP_KERNEL);
 	if(!info)	{
 		return -ENOMEM;
@@ -779,7 +779,7 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
 	state->buf = dma_alloc_coherent(&(pdev->dev), BUF_SIZE, &(state->buf_dma), GFP_KERNEL);
 
 	info->node = pdev->id;
-        
+
 	data->chip.priv  = (void *)info;
 
         data->chip.read_byte   	= read_byte ;
@@ -800,7 +800,7 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
 
         data->chip.ecc.read_page  = read_page;
         data->chip.ecc.write_page = write_page;
-        
+
 
 #ifdef NAND_DEBUG
 	print_onfi_params(&data->chip.onfi_params);
@@ -900,20 +900,20 @@ int xlp_nand_flash_dev_init(void){
 			devid   = (val & 0xFFFF0000) >> 16;
 			if(devid != XLP_DEVID_NAND)
 				continue;
-			
+
 			xlp_nand_flash_resource.start  = mmio;
 			xlp_nand_flash_resource.end    = mmio + (0x1000 -1);
-		
-			pplatdev = platform_device_register_resndata( NULL, "gen_nand", i, 
+
+			pplatdev = platform_device_register_resndata( NULL, "gen_nand", i,
 					&xlp_nand_flash_resource, 1, &xlp_nand_flash_data, sizeof(xlp_nand_flash_data));
 			if(pplatdev)	{
 				pplatdev->dev.dma_mask	= &xlp_dev_dmamask;
 				pplatdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 			}
-			
+
 			pplatdev = NULL;
 		}
 	}
-       	
+
 	return 0;
 }
-- 
1.7.0.4

