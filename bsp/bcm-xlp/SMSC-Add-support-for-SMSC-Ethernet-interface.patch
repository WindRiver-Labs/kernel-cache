From 26b1de5248c2982d1076a34ca8c145dc0d551a3e Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Mon, 29 Oct 2012 17:44:40 +0530
Subject: [PATCH 613/761] SMSC : Add support for SMSC Ethernet interface.

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anurag.gopinath@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp_smsc.h |   43 +++++++++++++++++
 arch/mips/netlogic/xlp/Makefile           |    1 +
 arch/mips/netlogic/xlp/platform.c         |   37 +++++++++++++++
 arch/mips/netlogic/xlp/smsc-init.c        |   73 +++++++++++++++++++++++++++++
 drivers/net/ethernet/smsc/smsc911x.c      |   37 +++++++++++----
 5 files changed, 182 insertions(+), 9 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/xlp_smsc.h
 create mode 100644 arch/mips/netlogic/xlp/smsc-init.c

diff --git a/arch/mips/include/asm/netlogic/xlp_smsc.h b/arch/mips/include/asm/netlogic/xlp_smsc.h
new file mode 100644
index 0000000..da742f8
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp_smsc.h
@@ -0,0 +1,43 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
+
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define SMSC_GPIO_IRT_NUM      13
+#define XLP_SMC_START_OFFSET (0x17200000)
+
+void xlp_smsc_gpio_setup(void);
+void xlp_smsc_gpio_reg_ack(int irq);
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index d49bf96..221c562 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_XLP_CPUFREQ) += xlp-cpufreq.o
 obj-$(CONFIG_SATA_AHCI) += sata-init.o
 obj-$(CONFIG_RAPIDIO)  += xlp_srio.o
 obj-$(CONFIG_USB) += usb-init.o
+obj-$(CONFIG_SMSC911X) += smsc-init.o
 
 ifeq ($(CONFIG_XEN),y)
 obj-y += xenbootinfo.o
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 25804b4..a483588 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -33,6 +33,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/pci.h>
 #include <linux/serial_reg.h>
 #include <linux/spinlock.h>
+#include <linux/smsc911x.h>
 
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
@@ -41,6 +42,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 #include <asm/netlogic/iomap.h>
+#include <asm/netlogic/xlp_smsc.h>
 
 #define XLP_SOC_PCI_DRIVER "XLP SoC Driver"
 #define DEV_IRT_INFO		0x3D
@@ -64,6 +66,35 @@ enum driverType{
 	PCI_DRV	 = 1
 };
 
+static struct resource xlp_smc911x_resources[] = {
+        {
+                .start  = XLP_SMC_START_OFFSET,
+                .end    = XLP_SMC_START_OFFSET + 0x100000 - 1, /* 1 MB */
+                .flags  = IORESOURCE_MEM,
+        }, {
+                .start  = xlp_irt_to_irq(0, SMSC_GPIO_IRT_NUM),
+                .end    = xlp_irt_to_irq(0, SMSC_GPIO_IRT_NUM),
+                .flags  = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_SHAREABLE,
+        },
+};
+
+static struct smsc911x_platform_config xlp_smsc911x_info = {
+        .phy_interface  = PHY_INTERFACE_MODE_MII,
+        .irq_polarity   = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+        .irq_type       = SMSC911X_IRQ_TYPE_PUSH_PULL,
+        .flags          = SMSC911X_USE_16BIT | SMSC911X_SAVE_MAC_ADDRESS,
+};
+
+static struct platform_device xlp_smc911x_device = {
+        .name           = "smsc911x",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(xlp_smc911x_resources),
+        .resource       = xlp_smc911x_resources,
+        .dev            = {
+                .platform_data = &xlp_smsc911x_info,
+        },
+};
+
 struct dev2drv {
 	uint32_t 	devid;
 	uint8_t 	drvname[16];
@@ -221,9 +252,15 @@ static int xlp_find_pci_dev(void)
 }
 static int __init platform_devinit(void)
 {
+        int res;
 	xlp_find_pci_dev();
 	xlp_nor_flash_dev_init();
 	xlp_nand_flash_dev_init();
+
+        res = platform_device_register(&xlp_smc911x_device);
+        if (res)
+                printk("unable to register xlp_smc911x_device: %d\n", res);
+
 	return 0;
 }
 
diff --git a/arch/mips/netlogic/xlp/smsc-init.c b/arch/mips/netlogic/xlp/smsc-init.c
new file mode 100644
index 0000000..ca2843e
--- /dev/null
+++ b/arch/mips/netlogic/xlp/smsc-init.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <hal/nlm_hal_xlp_dev.h>
+#include <asm/gpio.h>
+#include <asm/netlogic/xlp_smsc.h>
+
+static __inline__ int32_t gpio_reg_read(int node, int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void gpio_reg_write(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+void xlp_smsc_gpio_setup(void)
+{
+        gpio_reg_write(0, XLP_GPIO_INTEN11,
+                        gpio_reg_read(0, XLP_GPIO_INTEN11) | 0x80);
+        gpio_reg_write(0, XLP_GPIO_INT_POLAR1,
+                        gpio_reg_read(0, XLP_GPIO_INT_POLAR1) | 0x80);
+        gpio_reg_write(0, XLP_GPIO_INT_TYPE1,
+                        gpio_reg_read(0, XLP_GPIO_INT_TYPE1) & ~(0x80));
+
+        /* clear all interrupts */
+        gpio_reg_write(0, XLP_GPIO_INT_STAT1, 0xffffffff);
+
+}
+
+void xlp_smsc_gpio_reg_ack(int irq)
+{
+        gpio_reg_write(0, XLP_GPIO_INT_STAT1,
+                gpio_reg_read(0, XLP_GPIO_INT_STAT1) & 0x80 );
+}
+
diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index 759e9b4..20018eb 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -60,6 +60,7 @@
 #include <linux/of_gpio.h>
 #include <linux/of_net.h>
 #include "smsc911x.h"
+#include <asm/netlogic/xlp_smsc.h>
 
 #define SMSC_CHIPNAME		"smsc911x"
 #define SMSC_MDIONAME		"smsc911x-mdio"
@@ -146,17 +147,31 @@ struct smsc911x_data {
 	struct regulator_bulk_data supplies[SMSC911X_NUM_SUPPLIES];
 };
 
+/* The 16-bit access functions are significantly slower, due to the locking
+ * necessary.  If your bus hardware can be configured to do this for you
+ * (in response to a single 32-bit operation from software), you should use
+ * the 32-bit access functions instead. */
+
+#define readw_local(x)          swab16(readw(x))
+#define writew_local(x,y)       writew(swab16(x),y)
+
+#ifdef __BIG_ENDIAN
+#define local_swab32    swab32
+#else
+#define local_swab32
+#endif
+
 /* Easy access to information */
 #define __smsc_shift(pdata, reg) ((reg) << ((pdata)->config.shift))
 
 static inline u32 __smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)
 {
 	if (pdata->config.flags & SMSC911X_USE_32BIT)
-		return readl(pdata->ioaddr + reg);
+		return local_swab32(readl(pdata->ioaddr + reg));
 
 	if (pdata->config.flags & SMSC911X_USE_16BIT)
-		return ((readw(pdata->ioaddr + reg) & 0xFFFF) |
-			((readw(pdata->ioaddr + reg + 2) & 0xFFFF) << 16));
+		return ((readw_local(pdata->ioaddr + reg) & 0xFFFF) |
+			((readw_local(pdata->ioaddr + reg + 2) & 0xFFFF) << 16));
 
 	BUG();
 	return 0;
@@ -194,13 +209,13 @@ static inline void __smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,
 					u32 val)
 {
 	if (pdata->config.flags & SMSC911X_USE_32BIT) {
-		writel(val, pdata->ioaddr + reg);
+		writel(local_swab32(val), pdata->ioaddr + reg);
 		return;
 	}
 
 	if (pdata->config.flags & SMSC911X_USE_16BIT) {
-		writew(val & 0xFFFF, pdata->ioaddr + reg);
-		writew((val >> 16) & 0xFFFF, pdata->ioaddr + reg + 2);
+		writew_local(val & 0xFFFF, pdata->ioaddr + reg);
+		writew_local((val >> 16) & 0xFFFF, pdata->ioaddr + reg + 2);
 		return;
 	}
 
@@ -248,7 +263,7 @@ smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
 			__smsc911x_reg_write(pdata, TX_DATA_FIFO,
-					     swab32(*buf++));
+					     local_swab32(*buf++));
 		goto out;
 	}
 
@@ -259,7 +274,7 @@ smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
 
 	if (pdata->config.flags & SMSC911X_USE_16BIT) {
 		while (wordcount--)
-			__smsc911x_reg_write(pdata, TX_DATA_FIFO, *buf++);
+			__smsc911x_reg_write(pdata, TX_DATA_FIFO,local_swab32(*buf++));
 		goto out;
 	}
 
@@ -325,7 +340,7 @@ smsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,
 
 	if (pdata->config.flags & SMSC911X_USE_16BIT) {
 		while (wordcount--)
-			*buf++ = __smsc911x_reg_read(pdata, RX_DATA_FIFO);
+			*buf++ =local_swab32(__smsc911x_reg_read(pdata, RX_DATA_FIFO));
 		goto out;
 	}
 
@@ -1761,6 +1776,8 @@ static irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)
 	int serviced = IRQ_NONE;
 	u32 temp;
 
+	xlp_smsc_gpio_reg_ack(irq);
+
 	if (unlikely(intsts & inten & INT_STS_SW_INT_)) {
 		temp = smsc911x_reg_read(pdata, INT_EN);
 		temp &= (~INT_EN_SW_INT_EN_);
@@ -2439,6 +2456,8 @@ static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 	/* Ensure interrupts are globally disabled before connecting ISR */
 	smsc911x_disable_irq_chip(dev);
 
+	xlp_smsc_gpio_setup();
+
 	retval = request_irq(dev->irq, smsc911x_irqhandler,
 			     irq_flags | IRQF_SHARED, dev->name, dev);
 	if (retval) {
-- 
1.7.10.4

