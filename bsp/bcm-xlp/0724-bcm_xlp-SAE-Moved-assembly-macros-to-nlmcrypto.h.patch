From f93cf014181eb2ac79adc4fe3bd64a50e0ba4554 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareesh@netlogicmicro.com>
Date: Mon, 13 Feb 2012 14:02:51 +0530
Subject: [PATCH 724/762] bcm_xlp: SAE: Moved assembly macros to nlmcrypto.h

SAE: Moved assembly macros to nlmcrypto.h

Based on Broadcom SDK 2.3.

Signed-off-by: Hareesh R <hareesh@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/sae/cryptoapi.c |    2 +-
 drivers/crypto/sae/cryptodev.h |   65 +--------------------------------
 drivers/crypto/sae/nlmcrypto.h |   78 ++++++++++++++++++++++++++++++++++++++-
 3 files changed, 79 insertions(+), 66 deletions(-)

diff --git a/drivers/crypto/sae/cryptoapi.c b/drivers/crypto/sae/cryptoapi.c
index ca473db..7630972 100644
--- a/drivers/crypto/sae/cryptoapi.c
+++ b/drivers/crypto/sae/cryptoapi.c
@@ -593,7 +593,7 @@ int nlm_crypto_do_op(nlm_crypto_ctx_t *ctxt, enum nlm_crypto_op_type_t optype,
 			int bitset;
 			op = rsac->op;
 			/* rsa starts from 512 bits, 9 is hardcoded */
-			bitset = get_flc(blksz_nbits) - 1;
+			bitset = crypto_get_lbs(blksz_nbits) - 1;
 			type = bitset - 9 + NLM_CRYPTO_RSA_TYPE_SVALUE;
 			if(type > NLM_CRYPTO_RSA_TYPE_EVALUE || ((blksz_nbits - (1 << bitset)) > 0))
 				return NLM_CRYPTO_ERROR;
diff --git a/drivers/crypto/sae/cryptodev.h b/drivers/crypto/sae/cryptodev.h
index d706ff2..0c21f3a 100644
--- a/drivers/crypto/sae/cryptodev.h
+++ b/drivers/crypto/sae/cryptodev.h
@@ -95,70 +95,9 @@ struct nlm_crypto_ctx {
 	struct nlm_crypto_msg msgs[1];
 };
 
-typedef struct {
-	volatile unsigned int lock;
-} cryptolock_t;
 
-static __inline__ void crypto_lock(cryptolock_t *lock)
-{
-	unsigned int tmp, pid;
-#ifdef NLM_HAL_LINUX_USER
-	pid = getpid();
-#else
-	pid = 1;
-#endif
 
-	__asm__ __volatile__(
-			".set\tnoreorder\t\t\t# crypto_lock\n"
-			"1:\tll\t%1, %2\n\t"
-			"bgtz\t%1, 1b\n\t"
-			"move\t%1, %3\n\t"
-			"sc\t%1, %0\n\t"
-			"beqz\t%1, 1b\n\t"
-			" sync\n\t"
-			".set\treorder"
-			: "=m" (lock->lock), "=&r" (tmp)
-			: "m" (lock->lock), "r" (pid)
-			: "memory");
-}
-
-static __inline__ void crypto_unlock(cryptolock_t *lock)
-{
-	__asm__ __volatile__(
-			".set\tnoreorder\t\t\t# crypto_unlock\n\t"
-			"sync\n\t"
-			"sw\t$0, %0\n\t"
-			".set\treorder"
-			: "=m" (lock->lock)
-			: "m" (lock->lock)
-			: "memory");
-}
-
-/* cleared bit indication, instruction scans from msb to lsb 
- get_flc(0) = 0, get_flc(1) = 1, get_flc(0x80000000) = 32*/
-static inline int get_flc(uint32_t x)
-{
-	__asm__(".set push	\n"
-		".set mips32	\n"
-		"clz %0, %1	\n"
-		".set pop	\n"
-		:"=r" (x) 
-		:"r" (x));
-	return 32 - x;
-}
-
-/* cleared bit indication, instruction scans from msb to lsb 
- get_flc(0) = 0, get_flc(1) = 1, */
-static inline int get_flc64(uint64_t x)
-{
-	__asm__(".set push	\n"
-		".set mips64	\n"
-		"dclz %0, %1	\n"
-		".set pop	\n"
-		: "=r" (x) 
-		: "r" (x));
-	return 64 - x;
-}
+
 
 /* This should be provided by the application/os/hyperexec */
 struct nlm_crypto_init_params 
diff --git a/drivers/crypto/sae/nlmcrypto.h b/drivers/crypto/sae/nlmcrypto.h
index 682545a..addc4d1 100644
--- a/drivers/crypto/sae/nlmcrypto.h
+++ b/drivers/crypto/sae/nlmcrypto.h
@@ -254,6 +254,7 @@ struct nlm_crypto_ecc_ctrl  {
 	int prime; /* 1 for prime curvers, 0 for binary */
 };
 
+#define NLM_CRYPTO_MAX_RSA_BITS_LEN    8192
 #define NLM_CRYPTO_ECC_MAX_BLK_SIZE 576
 #define NLM_CRYPTO_ECC_PARAMS_NELMNTS 6
 
@@ -562,7 +563,7 @@ static inline void nlm_crypto_fill_auth_pkt_param(
 static inline unsigned int nlm_crypto_fill_src_seg(struct nlm_crypto_pkt_param *param,  
 		int seg, unsigned char *input, unsigned int inlen)
 {
-	unsigned off = 0, len = 0;
+	unsigned int off = 0, len = 0;
 	unsigned int remlen = inlen;
 
 	for(; remlen > 0;) {
@@ -587,7 +588,7 @@ static inline unsigned int nlm_crypto_fill_src_seg(struct nlm_crypto_pkt_param *
 static inline unsigned int nlm_crypto_fill_dst_seg(struct nlm_crypto_pkt_param *param, 
 		int seg, unsigned char *output, unsigned int outlen)
 {
-	unsigned off = 0, len = 0;
+	unsigned int off = 0, len = 0;
 	unsigned int remlen = outlen;
 
 	for(; remlen > 0;) {
@@ -618,6 +619,79 @@ static inline int my_cpu_id(void)
 	return pid;
 }
 
+typedef struct {
+	volatile unsigned int lock;
+} cryptolock_t;
+
+static __inline__ void crypto_lock_init(cryptolock_t *lock)
+{
+	lock->lock = 0;
+}
+
+static __inline__ void crypto_lock(cryptolock_t *lock)
+{
+	unsigned int tmp, pid;
+#ifdef NLM_HAL_LINUX_USER
+	pid = getpid();
+#else
+	pid = 1;
+#endif
+
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"1:	ll %1, %2\n"
+			"bgtz	%1, 1b\n"
+			"move	%1, %3\n"
+			"sc	%1, %0\n"
+			"beqz	%1, 1b\n"
+			" sync	\n"
+			".set	pop\n"
+			: "=m" (lock->lock), "=&r" (tmp)
+			: "m" (lock->lock), "r" (pid)
+			: "memory");
+}
+
+static __inline__ void crypto_unlock(cryptolock_t *lock)
+{
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"sync	\n"
+			"sw	$0, %0\n"
+			".set	pop\n"
+			: "=m" (lock->lock)
+			: "m" (lock->lock)
+			: "memory");
+}
+
+/* last bit set indication - from lsb to msb ,
+   clz instruction looks for number of cleared bit from msb to lsb
+   get_lbs(0) = 0, get_lbs(1) = 1, get_lbs(0x80000000) = 32
+ */
+static inline unsigned int crypto_get_lbs(unsigned int x)
+{
+	__asm__(".set push      \n"
+			".set mips32    \n"
+			"clz %0, %1     \n"
+			".set pop       \n"
+			:"=r" (x)
+			:"r" (x));
+	return 32 - x;
+}
+
+static inline int crypto_get_lbs64(unsigned long long x)
+{
+	__asm__(".set push	\n"
+		".set mips64	\n"
+		"dclz %0, %1	\n"
+		".set pop	\n"
+		: "=r" (x) 
+		: "r" (x));
+	return 64 - x;
+}
+
+
 #ifndef XLP_CACHELINE_SIZE
 #define XLP_CACHELINE_SIZE 64
 #endif 
-- 
1.7.0.4

