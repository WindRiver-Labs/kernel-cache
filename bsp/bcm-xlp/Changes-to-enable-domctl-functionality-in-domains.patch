From 5e58ed258c18fcd2b93c79147ef1749092a12eb5 Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Date: Fri, 27 Aug 2010 11:22:07 -0700
Subject: [PATCH 147/761] Changes to enable domctl functionality in domains

Limited domctl functionality is required in domains
(besides userspace Xen tools). For tasks such as
waking up secondary cpus etc. This patch commits
the needed changes

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/xen/hypercall.h |    6 ----
 arch/mips/include/asm/xen/interface.h |   54 ++++++++++++++++++++++++++++-----
 arch/mips/netlogic/xlp/xenbootinfo.c  |   37 ++++++++++++++++++++--
 include/xen/interface/domctl.h        |   30 ++++++++++++++++++
 4 files changed, 112 insertions(+), 15 deletions(-)
 create mode 100644 include/xen/interface/domctl.h

diff --git a/arch/mips/include/asm/xen/hypercall.h b/arch/mips/include/asm/xen/hypercall.h
index 5663ed3..634e323 100644
--- a/arch/mips/include/asm/xen/hypercall.h
+++ b/arch/mips/include/asm/xen/hypercall.h
@@ -596,10 +596,4 @@ MULTI_stack_switch(struct multicall_entry *mcl,
 	mcl->args[1] = esp;
 }
 
-
-static inline int HYPERVISOR_wakeup_secondary(unsigned long entry_point)
-{
-	return _hypercall1(int, wakeup_secondary, entry_point);
-}
-
 #endif /* _ASM_MIPS_XEN_HYPERCALL_H */
diff --git a/arch/mips/include/asm/xen/interface.h b/arch/mips/include/asm/xen/interface.h
index 25c8e4f..7c9d3d2 100644
--- a/arch/mips/include/asm/xen/interface.h
+++ b/arch/mips/include/asm/xen/interface.h
@@ -34,7 +34,7 @@
 #include <linux/threads.h>
 #include <asm/sgidefs.h>
 
-#ifdef __XEN__
+#if __XEN_INTERFACE_VERSION__ >= 0x00030201
 #define __DEFINE_GUEST_HANDLE(name, type) \
     typedef struct { type *p; } __guest_handle_ ## name
 #else
@@ -47,6 +47,7 @@
 #define DEFINE_GUEST_HANDLE(name) __DEFINE_GUEST_HANDLE(name, name)
 #define GUEST_HANDLE(name)        __guest_handle_ ## name
 
+#define set_xen_guest_handle(hnd, val)  do { (hnd).p = val; } while (0)
 #ifdef __XEN_TOOLS__
 #define get_xen_guest_handle(val, hnd)  do { val = (hnd).p; } while (0)
 #endif
@@ -99,14 +100,53 @@ typedef uint64_t tsc_timestamp_t; /* RDTSC timestamp */
  * The following is all CPU context. Note that the 
  * fpu_ctxt block is filled  in by FXSAVE if the 
  * CPU has feature FXSR; otherwise FSAVE is used.
- *
- * FIXME: this should be something similar to
- *        the thread_context{} structure of the
- *        task_struct, in the sense that it
- *        would capture the entire cpu context
+ * 
  */
-struct vcpu_guest_context {
 
+#define NUM_FPU_REGS 32
+
+typedef unsigned long long __fpureg_t;
+
+struct __mips_fpu_struct {
+        __fpureg_t      fpr[NUM_FPU_REGS];
+        unsigned int    fcr31;
+};
+
+struct vcpu_guest_context {
+	/* Saved main processor registers. */
+	unsigned long reg4;
+	unsigned long reg5;
+	unsigned long reg6;
+	unsigned long reg7;
+	unsigned long reg16;
+	unsigned long reg17;
+	unsigned long reg18;
+	unsigned long reg19;
+	unsigned long reg20;
+	unsigned long reg21;
+	unsigned long reg22;
+	unsigned long reg23;
+	unsigned long reg29;
+	unsigned long reg30;
+	unsigned long reg31;
+
+	/* Saved cp0 stuff. */
+	unsigned long cp0_status;
+
+	/* Saved fpu/fpu emulator stuff. */
+	struct __mips_fpu_struct fpu;
+
+	/* Other stuff associated with the thread. */
+	unsigned long cp0_badvaddr; /* Last user fault */
+	unsigned long cp0_baduaddr; /* Last kernel fault accessing USEG */
+	unsigned long error_code;
+	unsigned long trap_no;
+#define MF_FIXADE  1           /* Fix address errors in software */
+#define MF_LOGADE  2           /* Log address errors to syslog */
+#define MF_32BIT_REGS  4       /* also implies 16/32 fprs */
+#define MF_32BIT_ADDR  8       /* 32-bit address space (o32/n32) */
+#define MF_FPUBOUND    0x10    /* thread bound to FPU-full CPU set */
+	unsigned long mflags;
 };
 typedef struct vcpu_guest_context vcpu_guest_context_t;
 DEFINE_GUEST_HANDLE(vcpu_guest_context_t);
diff --git a/arch/mips/netlogic/xlp/xenbootinfo.c b/arch/mips/netlogic/xlp/xenbootinfo.c
index 93f679e..e4083e7 100644
--- a/arch/mips/netlogic/xlp/xenbootinfo.c
+++ b/arch/mips/netlogic/xlp/xenbootinfo.c
@@ -8,12 +8,14 @@
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/bootinfo.h>
 #include <xen/interface/xen.h>
+#include <xen/interface/domctl.h>
 #include <asm/xen/hypervisor.h>
 #include <asm/xen/hypercall.h>
 
 #include <asm/netlogic/debug.h>
 
 extern char _end[];
+extern unsigned int onlinemask;
 
 extern void xen_setup_shared_info(void);
 
@@ -34,9 +36,40 @@ extern void prom_pre_boot_secondary_cpus(void *);
 #define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
 #endif
 
-int wakeup_secondary_cpus(void)
+static int count_ones(int v)
+{
+        v = v - ((v >> 1) & 0x55555555);
+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
+        return (((v + (v >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
+}
+
+static int xc_wakeup_secondary(int dom_id, unsigned long cpumask, unsigned long entry)
 {
-	HYPERVISOR_wakeup_secondary(secondary_cpus_bootup_func);
+	struct xen_domctl domctl;
+	struct vcpu_guest_context ctxt;
+	int vcpu, ret, nr_vcpu;
+	
+	domctl.interface_version = XEN_DOMCTL_INTERFACE_VERSION;
+	domctl.cmd = XEN_DOMCTL_bootvcpu;
+    domctl.domain = dom_id;
+
+	ctxt.reg31 = entry;
+    set_xen_guest_handle(domctl.u.vcpucontext.ctxt, &ctxt);
+
+	nr_vcpu = count_ones(cpumask);
+
+	for (vcpu = 1; vcpu < nr_vcpu; ++vcpu) {
+		domctl.u.vcpucontext.vcpu = vcpu;
+		ret = privcmd_call(__HYPERVISOR_domctl2, (unsigned long)&domctl, 0, 0, 0, 0);
+		if (ret != 0)
+			panic("Unable to launch vcpu\n");
+	}
 
 	return 0;
 }
+
+int wakeup_secondary_cpus(void)
+{
+	return xc_wakeup_secondary(0, onlinemask, 
+		       (unsigned long)secondary_cpus_bootup_func);
+}
diff --git a/include/xen/interface/domctl.h b/include/xen/interface/domctl.h
new file mode 100644
index 0000000..5f68f43
--- /dev/null
+++ b/include/xen/interface/domctl.h
@@ -0,0 +1,30 @@
+#ifndef __XEN_PUBLIC_DOMCTL_H__
+#define __XEN_PUBLIC_DOMCTL_H__
+
+#include <xen/interface/xen.h>
+#include <xen/interface/grant_table.h>
+
+#define XEN_DOMCTL_INTERFACE_VERSION 0x00000006
+
+struct xen_domctl_vcpucontext {
+    uint32_t vcpu;                  /* IN */
+    GUEST_HANDLE(vcpu_guest_context_t) ctxt; /* IN/OUT */
+};
+typedef struct xen_domctl_vcpucontext xen_domctl_vcpucontext_t;
+DEFINE_GUEST_HANDLE(xen_domctl_vcpucontext_t);
+
+struct xen_domctl {
+    uint32_t cmd;
+#define XEN_DOMCTL_destroydomain        1
+#define XEN_DOMCTL_bootvcpu             2
+    uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
+    domid_t domain;
+    union {
+        struct xen_domctl_vcpucontext vcpucontext;
+        uint8_t pad[128];
+    } u;
+};
+typedef struct xen_domctl xen_domctl_t;
+DEFINE_GUEST_HANDLE(xen_domctl_t);
+
+#endif
-- 
1.7.10.4

