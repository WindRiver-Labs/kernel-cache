From 0257f404951dcba67a36d38d3efbf987a515b04d Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Mon, 2 Aug 2010 17:33:39 +0530
Subject: [PATCH 123/761] Cleanup of generic serial driver changes.

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlr/platform.c |   78 ++++++++++++++++-
 arch/mips/netlogic/xlr/setup.c    |  138 ++++++++++++++++++++++++++---
 include/linux/serial_8250.h       |    1 +
 include/linux/serial_core.h       |  174 ++++++++++++++++++-------------------
 4 files changed, 286 insertions(+), 105 deletions(-)

diff --git a/arch/mips/netlogic/xlr/platform.c b/arch/mips/netlogic/xlr/platform.c
index b8c3e77..6f47a6c 100644
--- a/arch/mips/netlogic/xlr/platform.c
+++ b/arch/mips/netlogic/xlr/platform.c
@@ -21,6 +21,8 @@ the header of the original work apply to this derived work.
 #include <linux/i2c.h>
 #include <asm/netlogic/nlm_srio.h>
 #include <asm/netlogic/i2c.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
 
 int __initdata boot_noi2c;
 static u64 xls_usb_dmamask = ~(u32) 0;
@@ -128,8 +130,6 @@ static int __init nlm_i2c_init(void)
 {
 	int err=0;
 
-	printk(KERN_INFO "** %s.\n", __FUNCTION__);
-
 	if(boot_noi2c == 0) {
 		platform_device_register(&nlm_xlr_i2c_1);
 
@@ -148,9 +148,81 @@ static int __init xlr_noi2c_setup(char *str)
 	boot_noi2c = 1;
 	return 1;
 }
-__setup("xlr_noi2c", xlr_noi2c_setup);
 
+unsigned int nlm_xlr_uart_in(struct uart_port *p, int offset)
+{
+	nlm_reg_t *mmio;
+	unsigned int value;
+
+	/* XLR uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	value = netlogic_read_reg(mmio, 0);
+
+	/* See XLR/XLS errata */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	return value;
+
+}
+
+void nlm_xlr_uart_out(struct uart_port *p, int offset, int value)
+{
+	nlm_reg_t *mmio;
+
+	/* See XLR/XLS errata */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	/* XLR uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	netlogic_write_reg(mmio, 0, value);
+}
+
+
+#define PORT(_base, _irq)                               \
+	{                                               \
+		.iobase		= _base,                \
+		.membase	= (void __iomem *)_base,\
+		.mapbase	= _base,                \
+		.irq		= _irq,                 \
+		.regshift	= 2,                    \
+		.iotype		= UPIO_XLR,         	\
+		.flags		= (UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF),\
+		.uartclk        = 66666666,		\
+		.type		= PORT_16550A,		\
+		.serial_in	= nlm_xlr_uart_in,	\
+		.serial_out	= nlm_xlr_uart_out,	\
+	}
+
+static struct plat_serial8250_port xlr_uart_data[] = {
+        PORT(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET, PIC_UART_0_IRQ),
+        PORT(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_1_OFFSET, PIC_UART_1_IRQ),
+	{},
+};
+
+static struct platform_device uart_device = {
+	.name		= "serial8250",
+	.id		= PLAT8250_DEV_NETL_XLR,
+	.dev = {
+		.platform_data = xlr_uart_data,
+	},
+};
+
+static int __init nlm_uart_init(void)
+{
+	return platform_device_register(&uart_device);
+}
+
+__setup("xlr_noi2c", xlr_noi2c_setup);
 arch_initcall(nlm_i2c_init);
+arch_initcall(nlm_uart_init);
 
 
 
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 75d34bb..1b1f1ab 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -119,6 +119,8 @@ __attribute__((__section__(".data.init_task"),
 	       __aligned__(THREAD_SIZE)));
 
 extern void prom_pre_boot_secondary_cpus(void *);
+extern unsigned int nlm_xlr_uart_in(struct uart_port *p, int offset);
+extern void nlm_xlr_uart_out(struct uart_port *p, int offset, int value);
 
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
@@ -427,6 +429,16 @@ int xlr_boot_over_nfs = 0;
 
 unsigned long nlm_common_ebase = 0x0;
 
+#ifdef XLR_USE_FDT
+static char prop_buf[MAX_PROP_LEN];
+extern char _end;
+extern void *fdt;
+extern void *fdt_init(void *blob);
+extern void *simple_alloc_init(char *base, unsigned long heap_size,
+		                unsigned long granularity, unsigned long max_allocs);
+#endif
+
+
 //#if !defined(CONFIG_NLMCOMMON_MAC)
 //struct user_mac_data *user_mac;
 struct xlr_user_mac_config xlr_user_mac;
@@ -990,13 +1002,15 @@ static void nlm_early_serial_setup(void)
 
 	s.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
 	/* XLP_MERGE_TODO */
-	s.iotype = UPIO_MEM;
+	s.iotype = UPIO_XLR;
 	/* registers are 4 bytes wide */
 	s.regshift = 2;
 	/* hardware int 4 - the serial int, is CPU int 6
 	 but poll for now */
 	s.irq =  PIC_UART_0_IRQ;
 	s.uartclk = UART_CLK;
+	s.serial_in	= nlm_xlr_uart_in;
+	s.serial_out	= nlm_xlr_uart_out;
 	s.membase = (unsigned char __iomem *)(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
 	s.mapbase = (DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
 
@@ -1169,6 +1183,106 @@ static int build_arcs_cmdline(char *arcs_cmdline, int argc, char *argv[])
 	return 0;
 }
 
+#ifdef XLR_USE_FDT
+/* This function will get the following:
+   1. Boot args
+   2. Physical memory map
+   3. CPU online map to be used by Linux
+   */
+static int xlr_fdt_process(void)
+{
+	int  domain=0;
+	char domstr[32] = "";
+	int  i, na, ns, regs[4], entries;
+
+	/* If booted using FDT and U-Boot, all
+	 * we get is a pointer to an FDT Blob
+	 */
+	void *blob = (void *)fw_arg0;
+	void *node;
+
+	if(!blob)
+		return -1;
+	/* Create a region starting from
+	 * (_end + 64K) of size 8MB for
+	 * the FDT structures. The 64K is
+	 * the current page size for XEN
+	 */
+	simple_alloc_init((char *)((unsigned long)(&_end)+0x10000),
+			(8<<20), 32, 128);
+
+	/* Create a local copy of the FDT
+	 */
+	fdt = fdt_init(blob);
+	if(!fdt)
+		return -1;
+
+	/* extract cmdline params
+	 */
+	node = finddevice("/chosen");
+	if (node) {
+		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+			return -1;
+		strcat(arcs_cmdline, prop_buf);
+	}
+
+	/* extract memory ranges,
+	 * add to command line
+	 */
+	node = finddevice("/doms/dom@0");
+	if (node) {
+		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
+			na = 1;
+		na = fdt32_to_cpu(na);
+		if (na < 1 || na > 2)
+			printk("Can't cope with #address-cells == %d.\n\r", na);
+		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
+			ns = 1;
+		ns = fdt32_to_cpu(ns);
+		if (ns < 1 || ns > 2)
+			printk("Can't cope with #size-cells == %d.\n\r", ns);
+	}
+
+	node = finddevice("/doms/dom@0/memory");
+	if (node) {
+		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
+		if (!entries || (entries % (na+ns)))
+			printk("Invalid Memory Map Specified!\n");
+
+		boot_physaddr_info.nr_map = entries/2;
+		for (i=0; i<entries; i+=2) {
+			unsigned long long addr, size;
+			addr = fdt32_to_cpu(regs[i]);
+			size = fdt32_to_cpu(regs[i + 1]);
+			boot_physaddr_info.addr = addr;
+			boot_physaddr_info.size = size;
+			boot_physaddr_info.type = BOOT_MEM_RAM;
+		}
+	}
+
+	printk("FDT Cmdline: %s\n", arcs_cmdline);
+
+	/* extract CPU online mask for
+	 * domain 0 (linux)
+	 */
+	sprintf(domstr, "/doms/dom@%d/cpu", domain);
+
+	node = finddevice(domstr);
+	if (node) {
+		if (getprop(node, "onlinemask", &onlinemask,
+					sizeof(onlinemask)) < 0)
+			return -1;
+		onlinemask = fdt32_to_cpu(onlinemask);
+	}
+
+	if (!onlinemask)
+		/* something went wrong ? */
+		onlinemask = 0x1;
+
+	xlr_linux_cpu_mask = onlinemask;
+	return 0;
+}
+#endif
 
 
 void __init prom_init(void)
@@ -1182,6 +1296,11 @@ void __init prom_init(void)
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	setup_default_configuration();
+
+#ifdef XLR_USE_FDT
+	xlr_fdt_process();
+#endif
+
 	read_cmdline_args(&argc, n_argv, n_envp);
 	parse_cmdline_args(argc, n_argv);
 
@@ -1314,6 +1433,9 @@ static int merge_exclude_regions(struct boot_mem_map_exclude_region *x,
 	return 0;
 }
 
+
+#ifdef CONFIG_EARLY_PRINTK
+
 static void NS16550_putc(char c)
 {
 	nlm_reg_t *mmio = 
@@ -1323,19 +1445,11 @@ static void NS16550_putc(char c)
 	netlogic_write_reg(mmio, 0x0, c);
 }
 
-#ifdef CONFIG_EARLY_PRINTK
 void prom_putchar(char c)
 {
 	void (*putchar)(char);
 
-	if (loader_used == LOADER_UBOOT) {
-		/* u-boot */
-		putchar = ((void (*)(char c))(unsigned long)(&NS16550_putc));
-	}
-	else {
-		/* netlboot */
-		putchar = ((void (*)(char c))(unsigned long)(prom_info->uart_putchar));
-	}
+	putchar = ((void (*)(char c))(unsigned long)(&NS16550_putc));
 	putchar(c);
 }
 #endif
@@ -1350,7 +1464,3 @@ static int __init nlm_proc_setup(void)
 }
 rootfs_initcall(nlm_proc_setup);
 
-#ifdef CONFIG_NLM_XLP
-/*placeholder for smp setup function*/
-
-#endif //CONFIG_NLM_XLP
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 8cbd89f..4f82795 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -66,6 +66,7 @@ enum {
 	PLAT8250_DEV_MCA,
 	PLAT8250_DEV_AU1X00,
 	PLAT8250_DEV_SM501,
+	PLAT8250_DEV_NETL_XLR,
 };
 
 /*
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3b7e2b6..e2eaef6 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -44,10 +44,7 @@
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
-#define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
-#define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
-#define PORT_XR17D15X	21	/* Exar XR17D15x UART */
-#define PORT_MAX_8250	21	/* max port ID */
+#define PORT_MAX_8250	18	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -97,7 +94,7 @@
 /* PPC CPM type number */
 #define PORT_CPM        58
 
-/* MPC52xx (and MPC512x) type numbers */
+/* MPC52xx type numbers */
 #define PORT_MPC52xx	59
 
 /* IBM icom */
@@ -182,37 +179,6 @@
 /* BCM63xx family SoCs */
 #define PORT_BCM63XX	89
 
-/* Aeroflex Gaisler GRLIB APBUART */
-#define PORT_APBUART    90
-
-/* Altera UARTs */
-#define PORT_ALTERA_JTAGUART	91
-#define PORT_ALTERA_UART	92
-
-/* SH-SCI */
-#define PORT_SCIFB	93
-
-/* MAX3107 */
-#define PORT_MAX3107	94
-
-/* High Speed UART for Medfield */
-#define PORT_MFD	95
-
-/* TI OMAP-UART */
-#define PORT_OMAP	96
-
-/* VIA VT8500 SoC */
-#define PORT_VT8500	97
-
-/* Xilinx PSS UART */
-#define PORT_XUARTPS	98
-
-/* Atheros AR933X SoC */
-#define PORT_AR933X	99
-
-/* Energy Micro efm32 SoC */
-#define PORT_EFMUART   100
-
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
@@ -223,7 +189,6 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
-#include <linux/pps_kernel.h>
 
 struct uart_port;
 struct serial_struct;
@@ -248,7 +213,7 @@ struct uart_ops {
 	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
-	void		(*set_ldisc)(struct uart_port *, int new);
+	void		(*set_ldisc)(struct uart_port *);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
@@ -278,7 +243,6 @@ struct uart_ops {
 #endif
 };
 
-#define NO_POLL_CHAR		0x00ff0000
 #define UART_CONFIG_TYPE	(1 << 0)
 #define UART_CONFIG_IRQ		(1 << 1)
 
@@ -304,13 +268,6 @@ struct uart_port {
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		(*serial_in)(struct uart_port *, int);
 	void			(*serial_out)(struct uart_port *, int, int);
-	void			(*set_termios)(struct uart_port *,
-				               struct ktermios *new,
-				               struct ktermios *old);
-	int			(*handle_irq)(struct uart_port *);
-	void			(*pm)(struct uart_port *, unsigned int state,
-				      unsigned int old);
-	void			(*handle_break)(struct uart_port *);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -326,7 +283,9 @@ struct uart_port {
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
-#define UPIO_RM9000		(6)			/* RM9000 type IO */
+#define UPIO_DWAPB		(6)			/* DesignWare APB UART */
+#define UPIO_RM9000		(7)			/* RM9000 type IO */
+#define UPIO_XLR		(8)			/* Netlogic XLR(S) */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
@@ -357,8 +316,6 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
-#define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
-#define UPF_BUG_THRE		((__force upf_t) (1 << 26))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
@@ -379,24 +336,10 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		irq_wake;
 	unsigned char		unused[2];
 	void			*private_data;		/* generic platform data pointer */
-#ifdef CONFIG_CONSOLE_POLL
-	int		(*poll_rx_cb)(u8);
-#endif
 };
 
-static inline int serial_port_in(struct uart_port *up, int offset)
-{
-	return up->serial_in(up, offset);
-}
-
-static inline void serial_port_out(struct uart_port *up, int offset, int value)
-{
-	up->serial_out(up, offset, value);
-}
-
 /*
  * This is the state information which is persistent across opens.
  */
@@ -406,6 +349,7 @@ struct uart_state {
 	int			pm_state;
 	struct circ_buf		xmit;
 
+	struct tasklet_struct	tlet;
 	struct uart_port	*uart_port;
 };
 
@@ -447,14 +391,6 @@ unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 
-/* Base timer interval for polling */
-static inline int uart_poll_timeout(struct uart_port *port)
-{
-	int timeout = port->timeout;
-
-	return timeout > 6 ? (timeout / 2 - 2) : 1;
-}
-
 /*
  * Console helpers.
  */
@@ -504,31 +440,23 @@ static inline int uart_tx_stopped(struct uart_port *port)
 /*
  * The following are helper functions for the low level drivers.
  */
-
-extern void uart_handle_dcd_change(struct uart_port *uport,
-		unsigned int status);
-extern void uart_handle_cts_change(struct uart_port *uport,
-		unsigned int status);
-
-extern void uart_insert_char(struct uart_port *port, unsigned int status,
-		 unsigned int overrun, unsigned int ch, unsigned int flag);
-
-#ifdef SUPPORT_SYSRQ
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
+#ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch);
+			handle_sysrq(ch, port->state->port.tty);
 			port->sysrq = 0;
 			return 1;
 		}
 		port->sysrq = 0;
 	}
+#endif
 	return 0;
 }
-#else
-#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })
+#ifndef SUPPORT_SYSRQ
+#define uart_handle_sysrq_char(port,ch) uart_handle_sysrq_char(port, 0)
 #endif
 
 /*
@@ -537,10 +465,6 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 static inline int uart_handle_break(struct uart_port *port)
 {
 	struct uart_state *state = port->state;
-
-	if (port->handle_break)
-		port->handle_break(port);
-
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
 		if (!port->sysrq) {
@@ -555,6 +479,80 @@ static inline int uart_handle_break(struct uart_port *port)
 	return 0;
 }
 
+/**
+ *	uart_handle_dcd_change - handle a change of carrier detect state
+ *	@uport: uart_port structure for the open port
+ *	@status: new carrier detect status, nonzero if active
+ */
+static inline void
+uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
+{
+	struct uart_state *state = uport->state;
+	struct tty_port *port = &state->port;
+
+	uport->icount.dcd++;
+
+#ifdef CONFIG_HARD_PPS
+	if ((uport->flags & UPF_HARDPPS_CD) && status)
+		hardpps();
+#endif
+
+	if (port->flags & ASYNC_CHECK_CD) {
+		if (status)
+			wake_up_interruptible(&port->open_wait);
+		else if (port->tty)
+			tty_hangup(port->tty);
+	}
+}
+
+/**
+ *	uart_handle_cts_change - handle a change of clear-to-send state
+ *	@uport: uart_port structure for the open port
+ *	@status: new clear to send status, nonzero if active
+ */
+static inline void
+uart_handle_cts_change(struct uart_port *uport, unsigned int status)
+{
+	struct tty_port *port = &uport->state->port;
+	struct tty_struct *tty = port->tty;
+
+	uport->icount.cts++;
+
+	if (port->flags & ASYNC_CTS_FLOW) {
+		if (tty->hw_stopped) {
+			if (status) {
+				tty->hw_stopped = 0;
+				uport->ops->start_tx(uport);
+				uart_write_wakeup(uport);
+			}
+		} else {
+			if (!status) {
+				tty->hw_stopped = 1;
+				uport->ops->stop_tx(uport);
+			}
+		}
+	}
+}
+
+#include <linux/tty_flip.h>
+
+static inline void
+uart_insert_char(struct uart_port *port, unsigned int status,
+		 unsigned int overrun, unsigned int ch, unsigned int flag)
+{
+	struct tty_struct *tty = port->state->port.tty;
+
+	if ((status & port->ignore_status_mask & ~overrun) == 0)
+		tty_insert_flip_char(tty, ch, flag);
+
+	/*
+	 * Overrun is special.  Since it's reported immediately,
+	 * it doesn't affect the current character.
+	 */
+	if (status & ~port->ignore_status_mask & overrun)
+		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+}
+
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */
-- 
1.7.10.4

