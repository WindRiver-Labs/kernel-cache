From d3ca991aaa5ab78c714945a400cd206a8caa4ff5 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Sat, 28 Jul 2012 00:04:43 +0530
Subject: [PATCH 560/762] XLP base port: Write probe valid array and valid array to flush the l1 dcache

Based on Broadcom SDK 2.3.

Signed-off-by: Jayanthi A <jayanthi.annadurai@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h |   48 ++++++++++++++++--------
 arch/mips/include/asm/netlogic/iomap.h        |    4 ++
 arch/mips/mm/c-phoenix.c                      |   33 +++++++++--------
 arch/mips/netlogic/xlp/cpu_control_asm.S      |    2 +-
 arch/mips/netlogic/xlp/on_chip.c              |    2 +-
 arch/mips/netlogic/xlp/platform.c             |   10 +++---
 6 files changed, 61 insertions(+), 38 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index d08de67..f59507e 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -14,6 +14,9 @@
 #define ENABLE_128_TLB     0x20
 #define ENABLE_PGWALKER    0x8
 
+#define LSU_DEBUG_VALID_ARRAY		0
+#define LSU_DEBUG_PROBE_VALID_ARRAY	1
+
 #define USER_SEG 0
 
 #ifdef CONFIG_64BIT
@@ -86,41 +89,54 @@ static inline void nlm_unlock_l1(uint32_t core)
 #define NLM_XLP_L1_MAXWAY       2
 #define NLM_XLP_L1_MAXINDX      128
 
-static inline void nlm_flush_l1_dcache_line(uint32_t line)
+static inline void nlm_flush_l1_dcache_line(uint32_t index, uint32_t maxindex, uint32_t array)
 {
          __asm__ __volatile__ (
                 "       .set push                       \n"
                 "       .set noat                       \n"
                 "       .set noreorder                  \n"
                 "       li $8, "STR(LSU_DEBUG_DATA0)"   \n"
-                "       mtcr $0, $8                     \n"
                 "       li $9, "STR(LSU_DEBUG_ADDR)"    \n"
-                "       ori %0, %0, 0x1                 \n"
-                "       mtcr %0, $9                     \n"
-                "1:                                     \n"
-                "       mfcr $8, $9                     \n"
-                "       andi $8, $8, 0x1                \n"
-                "       bnez $8, 1b                     \n"
+		"	li $10, 0			\n"
+		"	sll  %2, %2, 14			\n"
+		"	sll  %0, %0, 5			\n"
+		"	sll  %1, %1, 5			\n"
+		"1:					\n"
+		"	mtcr $0, $8			\n"
+		"	or  $10, %0, %2			\n"
+                "       ori $10, $10, 0x3              	\n"
+                "       mtcr $10, $9                    \n"
+                "2:                                     \n"
+                "       mfcr $11, $9                    \n"
+                "       andi $11, 0x1                	\n"
+                "       bnez $11, 2b                    \n"
                 "       nop                             \n"
+		"	mtcr $0, $8			\n"
+		"	ori  $10, $10, 0x7		\n"
+		"	mtcr $10, $9			\n"
+		"3:					\n"
+		"	mfcr $11, $9                    \n"
+		"       andi $11, 0x1                   \n"
+		"       bnez $11, 3b                    \n"
+		"	nop				\n"
+		"	addi %0, 1			\n"
+		"	bne  %1, %0, 1b			\n"
+		"	nop				\n"
                 "       .set pop                        \n"
-                : : "r"(line) : "$8" , "$9");
+                : : "r"(index), "r"(maxindex), "r"(array) : "$8" , "$9", "$10", "$11");
 }
 
 static inline void nlm_flush_l1_dcache(void)
 {
-        uint32_t index, line, max;
+        uint32_t index, max;
 	uint32_t cpu = read_c0_ebase() & 0x7f;
         uint32_t thread = cpu & 0x3;
         
 	nlm_lock_l1(cpu >> 2);
 	max = (thread + 1) * NLM_XLP_L1_MAXINDX;
         index = thread * NLM_XLP_L1_MAXINDX;
-        for(;index < max ; index++) {
-        	line = (index << 5) | (1<<1);
-	        nlm_flush_l1_dcache_line(line);
-                line = (1 << 2) | (index << 5) | (1<<1);
-                nlm_flush_l1_dcache_line(line);
-        }
+	nlm_flush_l1_dcache_line(index, max, LSU_DEBUG_VALID_ARRAY);
+	nlm_flush_l1_dcache_line(index, max, LSU_DEBUG_PROBE_VALID_ARRAY);
 	nlm_unlock_l1(cpu >> 2);
 }
 
diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
index a7bbe00..f0ac70e 100644
--- a/arch/mips/include/asm/netlogic/iomap.h
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -30,7 +30,11 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define _ASM_RFI_IO_H
 
 #ifdef CONFIG_NLM_XLP
+#ifdef CONFIG_64BIT
 #define DEFAULT_NETLOGIC_IO_BASE 0xffffffffb8000000ULL
+#else
+#define DEFAULT_NETLOGIC_IO_BASE 0xb8000000
+#endif
 #define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x14000
 #define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x15000
 #define NETLOGIC_IO_DDR2_CHN2_OFFSET       0x16000
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index d6a8474..dd6759a 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -237,21 +237,24 @@ static void nlm_common_local_flush_icache(void)
 
 static void nlm_common_local_flush_dcache(void)
 {
-  int i=0;
-  unsigned long base = CKSEG0;
-  unsigned int lines;
-
-  //dbg_msg("flushing the whole damn local D-cache\n");
-
-  lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
-
-  /* Index Invalidate all the lines and the ways */
-  for(i=0;i<lines;i++) {
-    cacheop(Index_Writeback_Inv_D, base);
-    base += current_cpu_data.dcache.linesz;
-  }
-
-  cacheop_hazard();
+	int i=0;
+	unsigned long base = CKSEG0;
+	unsigned int lines;
+
+	//dbg_msg("flushing the whole damn local D-cache\n");
+	if (is_cpu_core_xlp_ii) {
+		lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
+
+		/* Index Invalidate all the lines and the ways */
+		for(i=0;i<lines;i++) {
+		    cacheop(Index_Writeback_Inv_D, base);
+		    base += current_cpu_data.dcache.linesz;
+  		}
+	}
+	else {
+		nlm_flush_l1_dcache();
+	}
+	cacheop_hazard();
 
 }
 
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 41d6f83..01f3b61 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -113,7 +113,7 @@
 	li	t0, LSU_DEBUG_DATA0
 	li      t1, LSU_DEBUG_ADDR
 	li	t2, 0
-	li 	t3, 0x200
+	li 	t3, 0x400
 1:
 	sll	v0, t2, 5	
 	mtcr	zero, t0
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 325151b..900163a 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -667,7 +667,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 	uint32_t size = 0, code = 0, src_id = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
-	uint64_t msg0, msg1, msg2, msg3;
+	uint64_t msg0=0, msg1=0, msg2=0, msg3=0;
 	int cpu = hard_smp_processor_id();
 	int count = 0;
 	int no_msg = 0;
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index dc300cc..c11b3dc 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -37,7 +37,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/xlp_hal_pic.h>
+#include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 #include <asm/netlogic/iomap.h>
@@ -96,11 +96,11 @@ static void xlp_init_uart(int port_id)
 {
         xlp_uart_port[port_id].mapbase       = DEFAULT_NETLOGIC_IO_BASE 
 						+ NETLOGIC_IO_UART_0_OFFSET + port_id * XLP_UART_PORTIO_OFFSET;
-        xlp_uart_port[port_id].membase       = (void __iomem *)xlp_uart_port[port_id].mapbase;
-        xlp_uart_port[port_id].irq           = XLP_UART_IRQ(port_id);
+        xlp_uart_port[port_id].membase       = (void __iomem *)((unsigned long)xlp_uart_port[port_id].mapbase);
+        xlp_uart_port[port_id].irq           = xlp_pic_irt_to_irq(XLP_PIC_IRT_UART(port_id));
 
         xlp_uart_port[port_id].uartclk       = UART_CLK;
-//        xlp_uart_port[port_id].iotype        = UPIO_NLM;
+        xlp_uart_port[port_id].iotype        = UPIO_MEM32;
         xlp_uart_port[port_id].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
         xlp_uart_port[port_id].type          = PORT_16550A;
         xlp_uart_port[port_id].regshift      = 2;
@@ -236,7 +236,7 @@ static int xlp_find_pci_dev(void)
 						pres[0].end	= mmio;
 						pres[0].flags	= IORESOURCE_MEM;
 						irt = (nlm_hal_read_32bit_reg(mmio, DEV_IRT_INFO) & 0xFFFF);
-						irq = xlp_irt_to_irq(irt);
+						irq = xlp_pic_irt_to_irq(irt);
 
 						pres[1].start = irq;
 						pres[1].end = irq;
-- 
1.7.0.4

