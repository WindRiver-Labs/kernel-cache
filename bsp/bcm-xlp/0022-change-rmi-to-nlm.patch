From 0a51bcbae8f0cd6555110bb258fcf0140ba394fe Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Sun, 16 May 2010 21:29:40 -0700
Subject: [PATCH 022/762] change rmi to nlm

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/netlogic/nlm_auth.c |    4 +-
 drivers/crypto/netlogic/nlm_enc.c  |   18 ++++++------
 drivers/crypto/netlogic/nlmsec.c   |   56 ++++++++++++++++++------------------
 3 files changed, 39 insertions(+), 39 deletions(-)

diff --git a/drivers/crypto/netlogic/nlm_auth.c b/drivers/crypto/netlogic/nlm_auth.c
index 107034a..1dcb53b 100644
--- a/drivers/crypto/netlogic/nlm_auth.c
+++ b/drivers/crypto/netlogic/nlm_auth.c
@@ -21,7 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/scatterlist.h>
 #include "nlm_state_info.h"
-#include "rmisae.h"
+#include "nlmsae.h"
 #include "nlmsec_internal.h" 
 
 #define XLR_AUTH_PRIORITY      300
@@ -77,7 +77,7 @@ static void xlr_auth_update(struct crypto_tfm *tfm,
 static void xlr_auth_final(struct crypto_tfm *tfm, uint8_t *out)
 {
 	struct xlr_crypt_state *op = ctx(tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	int ret;
 
 	ret = nlmsec_op_init(&handle);
diff --git a/drivers/crypto/netlogic/nlm_enc.c b/drivers/crypto/netlogic/nlm_enc.c
index d656e97..34890c6 100644
--- a/drivers/crypto/netlogic/nlm_enc.c
+++ b/drivers/crypto/netlogic/nlm_enc.c
@@ -23,7 +23,7 @@
 #include <asm/delay.h>
 #include <asm/netlogic/msgring.h>
 #include "nlm_state_info.h"
-#include "rmisae.h"
+#include "nlmsae.h"
 #include "nlmsec_internal.h" 
 
 
@@ -175,7 +175,7 @@ xlr_ecb_decrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
@@ -214,7 +214,7 @@ xlr_ecb_encrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
@@ -251,7 +251,7 @@ static void
 xlr_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
 	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	int ret;
 
@@ -280,7 +280,7 @@ static void
 xlr_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)
 {
 	struct xlr_crypt_state *op = crypto_tfm_ctx(tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	int ret;
 
@@ -311,7 +311,7 @@ xlr_cbc_decrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
@@ -366,7 +366,7 @@ xlr_cbc_encrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
@@ -416,7 +416,7 @@ xlr_ctr_decrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
@@ -470,7 +470,7 @@ xlr_ctr_encrypt(struct blkcipher_desc *desc,
 		  unsigned int nbytes)
 {
 	struct xlr_crypt_state *op = crypto_blkcipher_ctx(desc->tfm);
-	op_handle_t handle = RMISAE_HANDLE_INITIALIZER;
+	op_handle_t handle = NLMSAE_HANDLE_INITIALIZER;
 	Crypto_Operation_pt cop=NULL;
 	struct blkcipher_walk walk;
 	int err, ret;
diff --git a/drivers/crypto/netlogic/nlmsec.c b/drivers/crypto/netlogic/nlmsec.c
index b69fe4b..f9560dd 100644
--- a/drivers/crypto/netlogic/nlmsec.c
+++ b/drivers/crypto/netlogic/nlmsec.c
@@ -57,7 +57,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "ecc_ucode_data.h"
 
 #define	ECC_UC_LOAD 0x70
-MODULE_AUTHOR("RMI Corporation");
+MODULE_AUTHOR("Netlogic Microsystem Inc.");
 MODULE_DESCRIPTION("XLS/XLR SAE Driver");
 MODULE_LICENSE("Dual BSD/GPL");
 
@@ -100,8 +100,8 @@ extern __u32 cpu_to_frstid[];
 static char driver_name[] = DRIVER_NAME;
 static char debug_name[] __attribute__((unused)) = "debug";
 static char stats_name[] = "stats";
-static char RMISAE_BUILD_VERSION[] = "1.7";
-static const char *versionstr = RMISAE_BUILD_VERSION;
+static char NLMSAE_BUILD_VERSION[] = "1.7";
+static const char *versionstr = NLMSAE_BUILD_VERSION;
 extern int xlr_loader_support;
 extern int xlr_loader_sharedcore;
 
@@ -178,14 +178,14 @@ static inline void remote_napi_poll_upper(void)
 
 
 #ifdef CONFIG_OCF_OCF_MODULE
-int rmisae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri);
-int rmisae_ocf_freesession(device_t dev, u_int64_t sid);
-int rmisae_ocf_process(device_t dev, struct cryptop *crp, int hint);
-
-static device_method_t rmisae_ocf_methods = {
-	DEVMETHOD(cryptodev_newsession, rmisae_ocf_newsession),
-	DEVMETHOD(cryptodev_freesession, rmisae_ocf_freesession),
-	DEVMETHOD(cryptodev_process, rmisae_ocf_process)
+int nlmsae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri);
+int nlmsae_ocf_freesession(device_t dev, u_int64_t sid);
+int nlmsae_ocf_process(device_t dev, struct cryptop *crp, int hint);
+
+static device_method_t nlmsae_ocf_methods = {
+	DEVMETHOD(cryptodev_newsession, nlmsae_ocf_newsession),
+	DEVMETHOD(cryptodev_freesession, nlmsae_ocf_freesession),
+	DEVMETHOD(cryptodev_process, nlmsae_ocf_process)
 };
 
 static struct {
@@ -222,7 +222,7 @@ static struct {
 	{-1},/* CRYPTO_RIPEMD160 */
 };
 
-int rmisae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri)
+int nlmsae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri)
 {
 	Crypto_Operation_pt cop;
 	if(in_atomic() || in_interrupt()) {
@@ -265,17 +265,17 @@ int rmisae_ocf_newsession(device_t dev, u_int64_t *sidp, struct cryptoini *cri)
 	return nlmsec_op_init(sidp);
 }
 
-int rmisae_ocf_freesession(device_t dev, u_int64_t sid)
+int nlmsae_ocf_freesession(device_t dev, u_int64_t sid)
 {
 	op_handle_t op = (op_handle_t)sid;
 	return nlmsec_op_cleanup(&op);
 }
 
-int rmisae_ocf_process(device_t dev, struct cryptop *crp, int hint)
+int nlmsae_ocf_process(device_t dev, struct cryptop *crp, int hint)
 {
 	Crypto_Operation_pt *cop = (Crypto_Operation_pt)crp->crp_sid;
 	op_handle_t op;
-	int ret = RMISAE_SUCCESS;
+	int ret = NLMSAE_SUCCESS;
 
 	ret = nlmsec_op_init(&op);
 	if(ret) {
@@ -308,7 +308,7 @@ int rmisae_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	return ret;
 }
 
-void rmisae_ocf_callback(int result, unsigned long arg)
+void nlmsae_ocf_callback(int result, unsigned long arg)
 {
 }
 
@@ -1090,13 +1090,13 @@ int nlmsec_mmap(struct file *fptr, struct vm_area_struct *vma)
  * Returns:
  * EAGAIN         : if the operation could not be sent to security engine
  *                  due to credit failure
- * RMISAE_SUCCESS : If the operation succeded
+ * NLMSAE_SUCCESS : If the operation succeded
  */
 
 int send_to_sae(meminfo_pt mem, int allow_async)
 {
 	device_info_pt dinfo = &dev_info;
-	int ret = RMISAE_SUCCESS;
+	int ret = NLMSAE_SUCCESS;
 	int cs, stid;
 	unsigned long flags;
 	OpType_t op_type = mem->op_type;
@@ -1280,7 +1280,7 @@ nlmsec_ioctl(struct file *fptr, unsigned int type, unsigned long val)
 	meminfo_pt mem = NULL;
 	int ret = 0;
 
-	if(type == RMISEC_IOCTL_GET_MEMINFO) {
+	if(type == NLMSEC_IOCTL_GET_MEMINFO) {
 		spin_lock_bh(&dinfo->mem_lock);
 		proc_info = find_proc_memlist(dinfo);
 
@@ -1419,7 +1419,7 @@ nlmsec_read(struct file *fptr, char __user *cptr, size_t size,
 	if(async) {
 		mem->op_flags = OP_NO_WAIT;
 	}
-	mem->result = RMISAE_SUCCESS;
+	mem->result = NLMSAE_SUCCESS;
 //	mem->return_queue = proc_info->async_queue;
 //	mem->return_value = proc_info;
 	mem->op_type = ctrl.op_type;
@@ -1836,7 +1836,7 @@ void nlmsec_msgring_handler(int bucket, int size, int code, int stid,
 {
 	device_info_pt dinfo = (device_info_pt)data;
 	volatile meminfo_pt mem;
-	int ret = RMISAE_SUCCESS;
+	int ret = NLMSAE_SUCCESS;
 	control_struct_pt ctrl;
 #ifdef SAE_STATS
 	resp_recieved[hard_smp_processor_id()]++;
@@ -2003,7 +2003,7 @@ static int ecc_init(void)
 	mem.ctx = INIT_CTX;
 	mem.op_type = NLM_ECC_OP;
 	mem.in_progress = IN_PROGRESS;
-	mem.result = RMISAE_SUCCESS;
+	mem.result = NLMSAE_SUCCESS;
 	mem.return_value = (unsigned long)&mem;
 	init_waitqueue_head(&mem.wq);
 
@@ -2024,7 +2024,7 @@ static int ecc_init(void)
 
 	__free_page(page);
 
-	if(mem.result != RMISAE_SUCCESS) {
+	if(mem.result != NLMSAE_SUCCESS) {
 		printk(KERN_ALERT "%s:%d ECC init failed with error=%x\n", __FUNCTION__,
 		       __LINE__, mem.result);
 		return -1;
@@ -2132,19 +2132,19 @@ static int __init nlmsec_driver_init(void)
 
 #ifdef CONFIG_OCF_OCF_MODULE
     /* create a asyncrhonous queue to process OCF operations */
-    if(nlmsec_create_operation_callback(&dev_info.ocf_cb, rmisae_ocf_callback)) {
+    if(nlmsec_create_operation_callback(&dev_info.ocf_cb, nlmsae_ocf_callback)) {
 	    unregister_chrdev_region(dev_info.device, 1);
 	    printk(KERN_ALERT "%s:%d OCF async queue initialization failed.",
 		   __FUNCTION__, __LINE__);
 	    goto bail;
     }
 
-    softc_device_init(&dev_info.ocf_dev, "rmisae", 0, rmisae_methods);
+    softc_device_init(&dev_info.ocf_dev, "nlmsae", 0, nlmsae_methods);
     dev_info.ocf_id = crypto_get_driverid(softc_get_device(&dev_info.ocf_dev),
 					  CRYPTOCAP_F_HARDWARE);
     if(dev_info.ocf_id < 0) {
 	    unregister_chrdev_region(dev_info.device, 1);
-	    printk(KERN_ALERT "%s:%d RMISAE cannot initialize into OCF.",
+	    printk(KERN_ALERT "%s:%d NLMSAE cannot initialize into OCF.",
 		   __FUNCTION__, __LINE__);
 	    goto bail;
     } else {
@@ -2176,7 +2176,7 @@ static int __init nlmsec_driver_init(void)
     msgring_config_init();
 
     // create proc fs entries
-    dev_info.pdir = proc_mkdir("rmi/" DRIVER_NAME, NULL);
+    dev_info.pdir = proc_mkdir("netlogic/" DRIVER_NAME, NULL);
     if(dev_info.pdir == NULL)
     {
 	    printk("%s:%d failed creating proc directory: %s\n",
@@ -2205,7 +2205,7 @@ static int __init nlmsec_driver_init(void)
 #ifdef ENABLE_DEBUG_PROC
 		    remove_proc_entry(debug_name, dev_info.pdir);
 #endif /* ENABLE_DEBUG_PROC */
-		    remove_proc_entry("rmi/" DRIVER_NAME, NULL);
+		    remove_proc_entry("netlogic/" DRIVER_NAME, NULL);
 		    printk("%s:%d failed creating stats entry: %s/%s\n",
 			   __FUNCTION__, __LINE__, driver_name, stats_name);
 		    ret = -EINVAL;
-- 
1.7.0.4

