From b94af166f8fc4302a0110f1481fce9951cffd5e1 Mon Sep 17 00:00:00 2001
From: Hareesh Ramachandran <hareesh@london.(none)>
Date: Mon, 26 Dec 2011 22:48:17 -0800
Subject: [PATCH 722/762] bcm_xlp: SAE: Added crypto lib finish function

Added crypto lib finish function

Based on Broadcom SDK 2.3.

Signed-off-by: Hareesh Ramachandran <hareesh@london.(none)>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/sae/cryptoapi.c |   22 ++++++++++++++++++----
 drivers/crypto/sae/cryptodev.h |    3 ++-
 drivers/crypto/sae/nlmcrypto.h |    1 +
 3 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/drivers/crypto/sae/cryptoapi.c b/drivers/crypto/sae/cryptoapi.c
index 9abb7f8..da22967 100644
--- a/drivers/crypto/sae/cryptoapi.c
+++ b/drivers/crypto/sae/cryptoapi.c
@@ -115,9 +115,7 @@ static inline int crypto_async_pop_msg(struct nlm_crypto_ctx *ctx, void **ctrl,
 
 
 /**
-* @brief The crypto lib init fuction when it is called from linux-userspace, it mmaps the shared memory 
-* to the calling process context. Also it initializes the memory allocater and creates a /dev/ node 
-* for the crypto device. In netos it retrieves the fdt parameters.
+* @brief The crypto lib init fuction calls the application specific init function.
 * This should be called only once from every application.
 *
 * @return 
@@ -139,6 +137,22 @@ int nlm_crypto_lib_init(void)
 }
 
 /**
+* @brief The crypto lib finish fuction calls the application specific finish function. 
+* It should releases all the resources allocted during init
+*
+* @return 
+*  - On sucess,  returns NLM_CRYPTO_OK. 
+*  - On failure, returns NLM_CRYPTO_ERROR.
+*	  
+* @ingroup crypto
+*/
+
+int nlm_crypto_lib_finish(void)
+{
+	return crypto_app_lib_finish();
+}
+
+/**
 * @brief The crypto open sync session create a context memory for the given sync session. 
 * The context memory is allocated from the shared mem so that it can be accessed 
 * from both kernel and userspace. In netos mode, as the application affinity is always set, 
@@ -173,6 +187,7 @@ nlm_crypto_ctx_t *nlm_crypto_open_sync_session(int sync_mode, int cpu, void *arg
 	ctx->max_msgs = max_outstanding_reqs;
 	ctx->rsp_pend = 0;
 	ctx->arg = (uint64_t)arg;
+	ctx->lock = 0;
 
 	if((sync_mode == NLM_CRYPTO_MODE_SYNC_EXLVC) && (iparam.sae_rx_sync_vc >= 0)) {
 		ctx->rx_vc = iparam.sae_rx_sync_vc;
@@ -185,7 +200,6 @@ nlm_crypto_ctx_t *nlm_crypto_open_sync_session(int sync_mode, int cpu, void *arg
 	}
 #ifdef NLM_CRYPTO_LINUX_U
 	else if((sync_mode == NLM_CRYPTO_MODE_SYNC_SHDVC) && (iparam.sae_rx_vc >= 0))  {
-		ctx->lock = 0;
 		ctx->rx_vc = iparam.sae_rx_vc;
 		ctx->fd = eventfd(0, 0);
 		if(ctx->fd < 0) 
diff --git a/drivers/crypto/sae/cryptodev.h b/drivers/crypto/sae/cryptodev.h
index c7eec0f..d706ff2 100644
--- a/drivers/crypto/sae/cryptodev.h
+++ b/drivers/crypto/sae/cryptodev.h
@@ -82,7 +82,7 @@ struct nlm_crypto_ctx {
 	unsigned int pad;
 
 	unsigned int rsp_pend; /* number of pending responses */
-	unsigned int lock; /* */
+	volatile unsigned int lock; /* */
 	unsigned int mhead; /* head and tail for async operation */
 	unsigned int mtail;
 
@@ -174,6 +174,7 @@ struct nlm_crypto_init_params
 };
 
 extern int crypto_app_lib_init(struct nlm_crypto_init_params *);
+extern int crypto_app_lib_finish(void);
 
 extern int contig_memory_init(void *shmaddr, unsigned long long paddr, unsigned long long size);
 /* alignment */
diff --git a/drivers/crypto/sae/nlmcrypto.h b/drivers/crypto/sae/nlmcrypto.h
index 916c479..4e75fa6 100644
--- a/drivers/crypto/sae/nlmcrypto.h
+++ b/drivers/crypto/sae/nlmcrypto.h
@@ -641,6 +641,7 @@ static inline int my_cpu_id(void)
 extern unsigned long xlp_rsa_base;
 extern unsigned long xlp_sae_base;
 int nlm_crypto_lib_init(void);
+int nlm_crypto_lib_finish(void);
 nlm_crypto_ctx_t *nlm_crypto_open_sync_session(int sync_mode, int cpu, void *arg);
 nlm_crypto_ctx_t *nlm_crypto_open_async_session(int max_outstanding_reqs, 
 		int (*callback)(nlm_crypto_ctx_t *ctxt, void *ctrl, void *param, void *arg), void *arg);
-- 
1.7.0.4

