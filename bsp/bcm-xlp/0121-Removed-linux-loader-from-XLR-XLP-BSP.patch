From 626f7f3a80d7ca96997fb89404cd7a2abbac5cd5 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Tue, 27 Jul 2010 17:10:35 +0530
Subject: [PATCH 121/762] Removed linux loader from XLR/XLP BSP.

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/pci-dma.h      |    2 +
 arch/mips/include/asm/netlogic/nlm_common_loader.h |  170 -------
 arch/mips/netlogic/xlp/smp.c                       |   10 +-
 arch/mips/netlogic/xlr/config_net.c                |   23 -
 arch/mips/netlogic/xlr/on_chip.c                   |   31 +--
 arch/mips/netlogic/xlr/setup.c                     |  478 +-------------------
 arch/mips/netlogic/xlr/smp.c                       |    6 -
 drivers/char/nlm_xlr_msgring.c                     |    4 +-
 drivers/net/xlr_user_mac.c                         |    5 -
 include/user/netlogic/nlm_common_loader.h          |  148 ------
 10 files changed, 21 insertions(+), 856 deletions(-)
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_common_loader.h
 delete mode 100644 include/user/netlogic/nlm_common_loader.h

diff --git a/arch/mips/include/asm/mach-netlogic/pci-dma.h b/arch/mips/include/asm/mach-netlogic/pci-dma.h
index c669ada..c3480f7 100644
--- a/arch/mips/include/asm/mach-netlogic/pci-dma.h
+++ b/arch/mips/include/asm/mach-netlogic/pci-dma.h
@@ -1,6 +1,8 @@
 #ifndef __ASM_MACH_NLM_PCI_DMA_H
 #define __ASM_MACH_NLM_PCI_DMA_H
 
+#ifdef CONFIG_NLM_XLR
 #define HAVE_ARCH_PCI_SET_DMA_MASK 1
+#endif
 
 #endif  /* __ASM_MACH_NLM_PCI_DMA_H */
diff --git a/arch/mips/include/asm/netlogic/nlm_common_loader.h b/arch/mips/include/asm/netlogic/nlm_common_loader.h
deleted file mode 100644
index 29570ee..0000000
--- a/arch/mips/include/asm/netlogic/nlm_common_loader.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef _ASM_NLM_XLR_LOADER_H
-#define _ASM_NLM_XLR_LOADER_H
-#include <linux/list.h>
-#include <asm/netlogic/memory-exclusion.h>
-
-#define NLM_LOADER_KSEG0_VIRT_START         0x60000000
-#define NLM_LOADER_KSEG0_START         0x0c000000
-#define NLM_LOADER_KSEG0_SIZE         0x04000000
-
-#define NLM_LOADER_KUSEG_VIRT_START         0x20000000
-#define NLM_LOADER_KUSEG_PHYS_START         0x20000000ULL
-#define NLM_LOADER_KUSEG_PHYS_SIZE          0xf000000ULL /* for 512 MB boards*/
-
-/* the below macros go together */
-#define NLM_LOADER_PHYS_SIZE          (512<<20)
-#define NLM_LOADER_PMASK_SIZE         (NLM_LOADER_PHYS_SIZE >> 1)
-#define NLM_LOADER_PMASK_SIZE_256MB   0xffff
-
-#define NLM_LOADER_IPI_VECTOR 51
-
-
-#if (_MIPS_SIM == _MIPS_SIM_ABI64)
-#define PTR2U64(x) (unsigned long)(x)
-#define U642PTR(x) (void *)((unsigned long)(x))
-#else
-// preserve sign-extension
-#define PTR2U64(x) (int)(x)
-#define U642PTR(x) (void *)((int)(x))
-#endif
-
-#define NUM_WORDS 2048
-
-#define XLR_THREAD_SIZE (NUM_WORDS * sizeof(long))
-
-#define NLM_APP_SHMEM_MAX_SZ (512*1024*1024)
-#ifndef __ASSEMBLY__
-
-struct xlr_thread_info {
-	unsigned long stack[NUM_WORDS];
-};
-extern struct xlr_thread_info xlrthreads_info[];
-
-#endif
-
-#define PSB_MEM_MAP_MAX 32
-#define PSB_IO_MAP_MAX 32
-
-struct psb_mem_map {
-	int nr_map;
-	struct psb_mem_map_entry {
-		uint64_t addr;  /* start of memory segment */
-		uint64_t size;  /* size of memory segment */
-		uint32_t type;      /* type of memory segment */
-	} map[PSB_MEM_MAP_MAX];
-};
-
-struct psb_io_map {
-	int nr_map;
-	struct psb_io_map_entry {
-		uint64_t addr;  /* start of IO segment */
-		uint64_t size;  /* size of IO segment */
-		long type;      /* type of IO segment */
-	} map[PSB_IO_MAP_MAX];
-};
-
-struct r_exception_region {
-	    unsigned int data[1024];
-};
-
-#define PKT_DATA_LEN 1592
-#define PKT_SEC_AUTH_LEN 32
-#define PKT_SEC_CTRL_DESC_LEN 128
-#define PKT_SEC_PKT_DESC_LEN 32
-
-
-struct packet {
-	/* New cacheline */
-	uint8_t data[PKT_DATA_LEN];
-	uint32_t len;
-	uint32_t seq_num;
-	/* New cacheline */
-	uint8_t sec_ctrl_desc[PKT_SEC_CTRL_DESC_LEN];
-	/* New cacheline */
-	uint8_t sec_pkt_desc[PKT_SEC_PKT_DESC_LEN];
-	/* New cacheline */
-	uint8_t sec_auth[PKT_SEC_AUTH_LEN];
-	/* New cacheline */
-	uint16_t sec_cksum;
-	uint8_t sec_cksum_padding[30];
-	/* New cacheline */
-	uint32_t sec_error;
-	uint32_t sec_op_timestamp;
-	struct list_head sec_tx_list;
-	uint16_t sec_ctrl_desc_size;
-	uint8_t padding[14];
-	/* New cacheline */
-} __attribute__ ((aligned(32)));
-
-#define dprintk(fmt, args...) //printk(fmt, ##args)
-#define eprintk(fmt, args...) printk(fmt, ##args)
-
-#define MAX_LOADER_MEMORY_ENTRY 128
-
-#define XLR_MAX_THRDS 32
-
-#define MEM_ALLOC_REQUEST 1
-#define MEM_ALLOC_FAILED 2
-#define MEM_ALLOC_DONE 3
-#define MAX_NUM_KUSEG_BLOCKS 4
-
-struct nlm_common_loader_alloc_memory
-{
-	void *ptr;
-	size_t size;
-	int status;
-};
-
-struct nlm_common_loader_free_memory
-{
-	void *ptr;
-};
-
-struct xlr_rmios_pt_regs {
-	unsigned long long pad0[6];
-
-	unsigned long long regs[32];
-
-	unsigned long long cp0_status;
-	unsigned long long hi;
-	unsigned long long lo;
-
-	/*
-	 * saved cp0 registers
-	 */
-	unsigned long long cp0_badvaddr;
-	unsigned long long cp0_cause;
-	unsigned long long cp0_epc;
-};
-
-struct kuseg_mem_info {
-	uint64_t size;
-	uint64_t start_addr;
-};
-
-#endif
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 514a7fa..db6b046 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -40,13 +40,10 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
-#include <asm/netlogic/nlm_common_loader.h>
-#include <user/netlogic/nlm_common_loader.h>
 
 #include <asm/mach-netlogic/mmu.h>
 #include "cpu_control_macros.h"
 
-extern int xlr_loader_support;
 
 extern int onlinemask;
 
@@ -272,12 +269,7 @@ int wakeup_secondary_cpus(void)
 	unsigned int wait_count = 0;
 #endif
 
-	if (xlr_loader_support) {
-		wakeup_mask = xlp_linux_cpu_mask | nlm_common_loader_mask;
-		if (wakeup != NULL)
-			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
-	} 
-	else {
+	{
 		if (wakeup != NULL) {
 			wakeup((void *)secondary_cpus_bootup_func, 0, 
 				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
diff --git a/arch/mips/netlogic/xlr/config_net.c b/arch/mips/netlogic/xlr/config_net.c
index 037faca..8dfc0d8 100644
--- a/arch/mips/netlogic/xlr/config_net.c
+++ b/arch/mips/netlogic/xlr/config_net.c
@@ -64,9 +64,6 @@ static uint32_t xgs_irqs[] = { PIC_XGS_0_IRQ, PIC_XGS_1_IRQ };
 #define MAX_NUM_DESC		512
 #define NLM_BASE(x) (netlogic_io_base + x)
 
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-extern int xlr_loader_own_gmac;
 /*
    This functions returns:
    True (1): if block is in XAUI mode
@@ -429,26 +426,6 @@ void config_net_init(void)
 
 	/* Modify the basic configurations with the options 
 			supported in Linux */
-	/* Loader support */
-	if(xlr_loader_support) {
-		if(xlr_loader_sharedcore) {
-			/* GMAC, XGMAC and SPI4 are owned by apps */
-			for(i = 0; i < NETLOGIC_MAX_XGMACS; i++)  {
-				net_dev->xgs_port[i].cfg_flag     = 0;
-			}
-
-			/* GMAC will be owned by linux if xlr_loader_own_gmac = 1*/
-			for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
-				if(!xlr_loader_own_gmac) {
-					net_dev->gmac_port[i].cfg_flag     = 0;
-				} else if(!(is_xls())) {
-					net_dev->gmac_port[i].bucket = &shared_bucket_sizes.bucket[MSGRNG_STNID_GMAC];
-					net_dev->gmac_port[i].credit = &shared_cc_table_gmac;
-				}
-			}
-		}
-	}
-
 	/* usermac support */
 	if(xlr_hybrid_user_mac()) {
 		for(i = 0; i < NETLOGIC_MAX_GMACS; i++)  {
diff --git a/arch/mips/netlogic/xlr/on_chip.c b/arch/mips/netlogic/xlr/on_chip.c
index 10ba2fc..9be91ed 100644
--- a/arch/mips/netlogic/xlr/on_chip.c
+++ b/arch/mips/netlogic/xlr/on_chip.c
@@ -44,10 +44,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
-extern int xlr_loader_own_gmac;
-extern int xlr_loader_own_dma;
 int msgring_timer_irq;
 
 #define MSGRNG_CC_INIT_CPU_DEST(conf, dest,cpu) \
@@ -190,32 +186,7 @@ void nlm_common_msgring_cpu_init(void)
 
 	msgring_int_en = 1;
 
-	if (xlr_loader_support && xlr_loader_sharedcore) {
-		/* if support for loading apps on same core as Linux is enabled */
-		if (xlr_loader_own_gmac || xlr_loader_own_dma) {
-			/* pop should only the buckets matching with the thread
-			   on which linux is loaded */
-			shared_msgring = 1;
-			msgring_int_en = 0;
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] |= (1 << (id % 4));
-			if (pop_bucket_end[id >> 2] < (id % 4) + 1)
-				pop_bucket_end[id >> 2] = (id % 4) + 1;
-		} else if (xlr_hybrid_rmios_ipsec()) {
-			/* rmios will always send to the bucket 0 */
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] = 1;
-			pop_bucket_end[id >> 2] = 1;
-			put_cpu();
-			return;
-		} else {
-			/* all the stations are owned by apps, 
-			   linux should not poll for any bucket */
-			pop_bucket_start[id >> 2] = 0;
-			pop_bucket_mask[id >> 2] = 0;
-			pop_bucket_end[id >> 2] = 0;
-		}
-	} else if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
+	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
 		/* msgring interrupt should be disabled */
 		msgring_int_type = 0x0;
 
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 656039c..6a04f7d 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -51,8 +51,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlr_user_mac.h>
 #include <asm/netlogic/msgring.h>
 
-#include <asm/netlogic/nlm_common_loader.h>
-#include <user/netlogic/nlm_common_loader.h>
 #include <asm/netlogic/nlm_pcix_gen_dev.h>
 #include <asm/netlogic/bootinfo.h>
 #include <asm/netlogic/memory-exclusion.h>
@@ -77,6 +75,8 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 #endif
 
+#define dprintk(fmt, args...) //printk(fmt, ##args)
+
 /* Certain macros for this file
  */
 
@@ -86,8 +86,6 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 
 #define GPIO_SWRESET_REG 		8
 
-#define DEFAULT_LINUX_CPU_MASK 	0x1
-#define DEFAULT_LOADER_MASK 	~DEFAULT_LINUX_CPU_MASK
 
 #define PER_CPU_THREAD_SIZE 	(THREAD_SIZE >> 2)
 #define TOTAL_THREAD_SIZE       (PER_CPU_THREAD_SIZE * (NR_CPUS - 1))
@@ -100,13 +98,6 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #define DEF_PHYMEM_START_ADDR 	0x100000
 #define DEF_PHYMEM_SIZE 		0x0ff00000
 
-#define LOADER_KSEG_DEFAULTS nlm_common_loader_kseg_start = NLM_LOADER_KSEG0_START;\
-		nlm_common_loader_kseg_size = NLM_LOADER_KSEG0_SIZE;
-
-#define LOADER_KUSEG_DEFAULTS   \
-		memset(kuseg_mem_map, 0, (sizeof(struct kuseg_mem_info) * 4));	\
-		use_kuseg_defaults(map);
-
 extern char _end;
 
 /* by default, do not assume u-boot */
@@ -133,14 +124,6 @@ unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
 spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
 
 __u8 xlr_base_mac_addr[6];
-volatile nlm_common_loader_shared_struct_t *nlm_common_loader_sh_mem = NULL;
-/* used for command line parsing */
-uint32_t nlm_common_loader_kseg_start, nlm_common_loader_kseg_size;
-uint32_t nlm_common_loader_mask;
-/* Size of the shared memory b/w Linux userapp and rmios apps */
-uint32_t nlm_common_app_sh_mem_sz;
-unsigned long  nlm_common_app_shmem_start;
-static int index = 0;
 static char *hybrid_str = NULL;
 
 /* xls chip family variables */
@@ -171,8 +154,6 @@ struct environment xlr_bldr_env ;
 __u32 xlr_board_major_version = NLM_XLR_BOARD_ARIZONA_I;
 __u32 xlr_board_minor_version = 0;
 
-struct kuseg_mem_info kuseg_mem_map[MAX_NUM_KUSEG_BLOCKS];
-
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
 static int dyna_exc_index=0;
@@ -236,11 +217,6 @@ struct boot_mem_map boot_physaddr_info;
 static struct boot_mem_map_exclude_region dynamic_exclude_regions[] = {
 	[0] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
 	[1] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
-	[2] = {0, 0}, /* Loader KSEG0 region */
-	[3] = {0, 0}, /* Loader KUSEG region Block 1*/
-	[4] = {0, 0}, /* Loader KUSEG region Block 2 or Hybrid Mode exclusion*/
-	[5] = {0, 0}, /* Loader KUSEG region Block 3 or Hybrid Mode exclusion */
-	[6] = {0, 0}, /* Loader KUSEG region Block 4 or Hybrid Mode exclusion */
 	[7] = {0, 0}, /* Hybrid Mode exclusion*/
 	[8] = {0, 0}, /* END of the list - MUST be the last entry always */
 };
@@ -440,12 +416,7 @@ void prom_reconfigure_thr_resources(void)
 }
 
 int xlr_hybrid;
-int xlr_loader_support=0;
-int xlr_loader_sharedcore=0;
-int xlr_loader_own_gmac=0;
-int xlr_loader_own_dma=0;
 
-uint32_t xlr_linux_cpu_mask;
 int xlr_console_pci_con_dev = 0;
 int xlr_console_pci_con_baud = 0;
 int xlr_boot_over_nfs = 0;
@@ -472,18 +443,6 @@ static void setup_default_configuration(void)
 	xlr_hybrid = XLR_HYBRID_NONE;
 	xlr_user_mac.l4_extract = 0;
 	xlr_user_mac.fast_syscall = 1;
-	xlr_loader_support = 0;
-	xlr_loader_sharedcore = 0;
-	xlr_loader_own_gmac = 0;
-	xlr_loader_own_dma = 0;
-	xlr_linux_cpu_mask = DEFAULT_LINUX_CPU_MASK; 
-	nlm_common_loader_kseg_start = 0;
-	for ( index = 0 ; index < MAX_NUM_KUSEG_BLOCKS ; index++) {
-		kuseg_mem_map[index].start_addr = 0;
-		kuseg_mem_map[index].size = 0;
-	}
-	nlm_common_loader_kseg_size = 0;
-	nlm_common_loader_mask = DEFAULT_LOADER_MASK;
 
 	nlm_common_psb_shm = 0;
 
@@ -492,9 +451,6 @@ static void setup_default_configuration(void)
 
 void exclude_hybrid_mem_region(void)
 {
-	if (xlr_loader_support){
-		return;
-	}
 	dynamic_exclude_regions[dyna_exc_index].start = 1<<20;
 	dynamic_exclude_regions[dyna_exc_index].end = 
 		(unsigned long long)(((unsigned long)&_text) & 0x1fffffffUL);
@@ -504,16 +460,14 @@ void exclude_hybrid_mem_region(void)
 #ifndef CONFIG_MAPPED_KERNEL
 static void xlr_early_hybrid_setup(char *str)
 {
-
 	hybrid_str = str;
 
-
-    if ((strcmp(str, "=rmios_ipsec") == 0)||
-		 (strcmp(str, "rmios_ipsec") == 0)) {
-        exclude_hybrid_mem_region();
+	if ((strcmp(str, "=rmios_ipsec") == 0)||
+			(strcmp(str, "rmios_ipsec") == 0)) {
+		exclude_hybrid_mem_region();
 	}
 	else if ((strcmp(str, "=rmios_tcpip_stack") == 0)||
-		 (strcmp(str, "rmios_tcpip_stack") == 0)) {
+			(strcmp(str, "rmios_tcpip_stack") == 0)) {
 		exclude_hybrid_mem_region();
 	}
 }
@@ -521,11 +475,10 @@ static void xlr_early_hybrid_setup(char *str)
 
 static int xlr_hybrid_setup(char *str)
 {
-	uint32_t loader_reg;
 	uint64_t kernel_start;
 
 	if ((strcmp(str, "=user_mac_xgmac") == 0)||
-	    (strcmp(str, "user_mac_xgmac") == 0)) {
+			(strcmp(str, "user_mac_xgmac") == 0)) {
 		if (xlr_board_atx_ii()) {
 			xlr_hybrid = XLR_HYBRID_USER_MAC_XGMAC;
 			printk("Configured for Hybrid mode with USER_MAC_XGMAC\n");
@@ -534,25 +487,28 @@ static int xlr_hybrid_setup(char *str)
 			printk("Configured for Hybrid mode with USER_MAC_SPI4\n");
 		}
 		else {
-			printk("user_mac_xgmac hybrid mode is available only on ATX-II\n");
+			printk(
+		"user_mac_xgmac hybrid mode is available only on ATX-II\n");
 		}
 	}
-	else if ((strcmp(str, "=user_mac") == 0)||(strcmp(str, "user_mac") == 0)) {
+	else if ((strcmp(str, "=user_mac") == 0)||
+			(strcmp(str, "user_mac") == 0)) {
 		xlr_hybrid = XLR_HYBRID_USER_MAC;
 		printk("Configured for Hybrid mode with USER_MAC\n");
 	}
 	else if ((strcmp(str, "=rmios_ipsec") == 0) ||
-			 (strcmp(str, "rmios_ipsec") == 0)) {
+			(strcmp(str, "rmios_ipsec") == 0)) {
 		xlr_hybrid = XLR_HYBRID_RMIOS_IPSEC;
 		printk("Configured for Hybrid mode with RMIOS IPSEC\n");
 	}
 	else if ((strcmp(str, "=rmios_tcpip_stack") == 0)||
-			 (strcmp(str, "rmios_tcpip_stack") == 0)) {
+			(strcmp(str, "rmios_tcpip_stack") == 0)) {
 		xlr_hybrid = XLR_HYBRID_RMIOS_TCPIP_STACK;
-		kernel_start = (uint64_t)(((unsigned long)&_text) & 0x1fffffffUL);
+		kernel_start = (uint64_t)
+			(((unsigned long)&_text) & 0x1fffffffUL);
 		if (kernel_start < NLM_RMIOS_TCPIP_END) {
 			panic("Build kernel with loadaddress above %#x\n",
-			      NLM_RMIOS_TCPIP_END);
+					NLM_RMIOS_TCPIP_END);
 		}
 		printk("Configured for Hybrid mode with RMIOS_TCPIP_STACK\n");
 	}
@@ -561,44 +517,6 @@ static int xlr_hybrid_setup(char *str)
 		printk("Configured for Hybrid mode with None\n");
 	}
 
-	/* usermac/xgmac cannot work with shared core  */
-	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
-		if (xlr_loader_support && xlr_loader_sharedcore) {
-			printk("Disabling USER_MAC support:Cannot be enabled with shared_core option\n");
-			xlr_hybrid = XLR_HYBRID_NONE;
-		}
-	}
-
-	if ((xlr_hybrid != XLR_HYBRID_NONE) && (xlr_loader_support)) {
-		/* Don't allow loader feature if hybrid 
-		 * app and loader are using same memory 
-		 */
-		loader_reg = nlm_common_loader_kseg_start + nlm_common_loader_kseg_size;
-
-        if (xlr_hybrid == XLR_HYBRID_RMIOS_IPSEC) {
-            if (((NLM_RMIOS_IPSEC_START >= nlm_common_loader_kseg_start) &&
-	    		(NLM_RMIOS_IPSEC_END< loader_reg)) ||
-	           	  ((nlm_common_loader_kseg_start >= NLM_RMIOS_IPSEC_START) &&
-    		   (nlm_common_loader_kseg_start < NLM_RMIOS_IPSEC_END)))	{
-	    		xlr_loader_support=0;
-		    	printk("Disabling Loader support as hybrid mode is selected\n");
-    			printk("Use different memory range for loader KSEG region if hybrid mode needs to be enabled.\n");
-	    	}
-        }else if (xlr_hybrid == XLR_HYBRID_RMIOS_TCPIP_STACK) {
-            if (((NLM_RMIOS_TCPIP_START >= nlm_common_loader_kseg_start) &&
-			    (NLM_RMIOS_TCPIP_END< loader_reg)) ||
-			   ((nlm_common_loader_kseg_start >= NLM_RMIOS_TCPIP_START) &&
-			    (nlm_common_loader_kseg_start < NLM_RMIOS_TCPIP_END)))	{
-				xlr_loader_support=0;
-				printk("Disabling Loader support as hybrid mode is selected\n");
-				printk("Use different memory range for loader KSEG region if hybrid mode needs to be enabled.\n");
-			}
-		}
-	}
-
-//	}
-			
-	
 	return 1;
 }
 
@@ -736,44 +654,9 @@ struct nlm_common_name_value_struct {
 };
 
 static struct nlm_common_name_value_struct nlm_common_name_value_args[] = {
-	{"linux_cpu_mask=", &xlr_linux_cpu_mask },
-    {"kseg0_start=", &nlm_common_loader_kseg_start}, 
-	{"kseg0_size=", &nlm_common_loader_kseg_size},
-	{"app_sh_mem_sz=", &nlm_common_app_sh_mem_sz},
 	{NULL, NULL}
 };
 
-void parse_kuseg_mem_args(char *p)
-{
-	static int count = 0;
-	uint64_t start = 0, size= 0;
-
-	if (count == MAX_NUM_KUSEG_BLOCKS) {
-		printk("Max # of kuseg blocks allowed : %d! Ignoring (%s)\n",
-				MAX_NUM_KUSEG_BLOCKS, p);
-		return;
-	}
-
-	p = p + strlen("kumem=");
-	size = memparse(p, &p);
-
-	if ((size == 0) || ((size & (((uint64_t)2 << 20) - 1)) == (1 << 20 )))
-		return;
-
-	kuseg_mem_map[count].size = size;
-
-	if (*p == '@') {
-		start = memparse(p + 1, &p);
-		
-		/* start Addr should be the multiple of 2M 
-		 */
-		if (((size & (((uint64_t)2 << 20) - 1)) == (1 << 20 ) ) ) 
-			return;
-	}
-	
-	kuseg_mem_map[count].start_addr = start;
-    count++;
-}
 
 //void prom_parse_args(int argc, char *argv[])
 static void parse_cmdline_args(int argc, char *argv[])  
@@ -782,8 +665,6 @@ static void parse_cmdline_args(int argc, char *argv[])
 	int ret;
 	char *tmp = NULL;
 
-	/* Check if loader support needs to be enabled 
-	 */
 	for (i=1; i<argc; i++) {
 
 		if (argv && argv[i]) {
@@ -795,24 +676,6 @@ static void parse_cmdline_args(int argc, char *argv[])
 				nlm_asid_mask = 0xff;
 				printk("Disabling Shared TLB Support\n");
 #endif
-			} else if (strcmp(argv[i], "xlr_loader") == 0) {
-
-				xlr_loader_support = 1;
-
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-				nlm_shtlb = 0;
-				nlm_asid_mask = 0xff;
-#endif
-				printk("Enabling XLR Linux Loader support\n");
-
-			} else if (strcmp(argv[i], "shared_core") == 0) {
-
-				xlr_loader_sharedcore = 1;
-				printk("Linux/RMIOS apps can run on same core\n");
-
-			} else if (strstr(argv[i],"kumem=") != NULL) {
-				parse_kuseg_mem_args(argv[i]);
-
 			} else if (strcmp(argv[i],"console=/dev/pci_co0") == 0) {
 				xlr_console_pci_con_dev = 1;
 
@@ -822,10 +685,6 @@ static void parse_cmdline_args(int argc, char *argv[])
 			} else if (strcmp(argv[i],"root=/dev/nfs") == 0) {
 				xlr_boot_over_nfs = 1;
 
-			} else if (strcmp(argv[i], "own_gmac") == 0) {
-				xlr_loader_own_gmac = 1;
-				printk("Linux will own gmac ports\n");
-
 			} else if (strncmp(argv[i],"xlr_hybrid=",strlen("xlr_hybrid=")) == 0) {
 				tmp = argv[i]+strlen("xlr_hybrid=");
 
@@ -859,198 +718,6 @@ static void parse_cmdline_args(int argc, char *argv[])
 #endif
 }
 
-void check_cpu_mask(void) 
-{
-	uint32_t tmask,i;
-
-	if (!xlr_linux_cpu_mask)
-		xlr_linux_cpu_mask = 0x1;
-	
-	/* trim to what is available 
-	 */
-	xlr_linux_cpu_mask &= prom_info->nlm_cpu_online_map;
-	xlr_linux_cpu_mask |= (1U<<hard_smp_processor_id());
-
-	/* Exclude CPUs that boot linux from the loader CPU mask 
-	 */
-	nlm_common_loader_mask = ~xlr_linux_cpu_mask;
-	nlm_common_loader_mask &= prom_info->nlm_cpu_online_map;
-	
-	/* Loader should not run on the same core, 
-	 * unless "sharedcore" option is enabled 
-	 */
-	
-	if (xlr_loader_sharedcore == 0) {
-		tmask = 0xf;
-		for (i=0; i < 8; i++) {
-			if (tmask & xlr_linux_cpu_mask)
-				nlm_common_loader_mask &= ~tmask;
-			tmask = tmask << 4;
-		}
-	}
-
-	if (nlm_common_loader_mask == 0) {
-		xlr_loader_support = 0;
-		printk("Disabling loader support as loader mask is 0\n");
-		return;
-	}
-
-	printk("Using 0x%08x as linux cpu mask\n", xlr_linux_cpu_mask);
-	printk("Using 0x%08x as loader cpu mask\n", nlm_common_loader_mask);
-}
-
-void check_kseg_args(void)
-{
-	if ((nlm_common_loader_kseg_start == 0) ||(nlm_common_loader_kseg_size == 0)) {
-		/* no args passed 
-		 */
-		LOADER_KSEG_DEFAULTS;
-		printk("No KSEG args passed. Using defaults\n");
-		return;
-	}
-
-	dprintk("Checking kseg start %x with _end %p\n", 
-			nlm_common_loader_kseg_start, &_end);
-
-	if (((nlm_common_loader_kseg_start | CKSEG0) < (unsigned long)&_end) || 
-			(nlm_common_loader_kseg_start >= LOADER_KSEG_END)) {
-
-		printk("Invalid KSEG args passed. Using defaults\n");
-		printk("Start cannot overlap with image or bootloader region\n");
-		LOADER_KSEG_DEFAULTS;
-		return;
-	}
-
-	if (nlm_common_loader_kseg_start & ((2 << 20) - 1)) {
-		/* Start not aligned at 2MB boundary
-		 */
-		printk("Invalid KSEG args passed. Using defaults\n");
-		printk("Start address not aligned at 2MB boundry\n");
-		LOADER_KSEG_DEFAULTS;
-		return;
-	}
-
-	if ((nlm_common_loader_kseg_start + nlm_common_loader_kseg_size) > 
-			LOADER_KSEG_END) {
-
-		printk("Invalid KSEG args passed. Using defaults\n");
-		printk("Bootloader region cannot be used\n");
-		LOADER_KSEG_DEFAULTS;
-		return;
-	}
-
-	printk("Using 0x%08x as KSEG0 load start and 0x%08x as size\n",
-			nlm_common_loader_kseg_start, nlm_common_loader_kseg_size);
-
-	return;
-}
-
-static void use_kuseg_defaults(struct boot_mem_map *map)
-{
-	int i=0;
-
-	uint64_t start = NLM_LOADER_KUSEG_PHYS_START;
-	uint64_t size = NLM_LOADER_KUSEG_PHYS_SIZE;
-	
-	for (i=0; i<map->nr_map; i++) {
-		if (map->map[i].type != BOOT_MEM_RAM) continue;
-		if (map->map[i].addr >= start)
-			break;
-	}
-
-	if (i == map->nr_map) {
-		/* found no memory
-		 */
-		printk("\n[--------# WARNING #--------]");
-		printk("\nNo Loader KUSEG Region Found!\n");
-		return;
-	}
-
-	start = map->map[i].addr;
-	size = map->map[i].size > size ? size : map->map[i].size;
-	kuseg_mem_map[0].start_addr = start;
-	kuseg_mem_map[0].size = size;
-
-	printk("\nUsing Kuseg Region %#llx@%#llx\n",
-			(unsigned long long)kuseg_mem_map[0].size,
-			(unsigned long long)kuseg_mem_map[0].start_addr);
-	return;
-}
-
-void check_kuseg_args(struct boot_mem_map *map)
-{
-	int i,j;
-	uint64_t end1, end2;
-
-	for (j = 0; j < MAX_NUM_KUSEG_BLOCKS; j++) {
-		/* if size is 0 ignore the entry 
-		 */
-		if ( kuseg_mem_map[j].size == 0)
-			continue;
-
-		if ( kuseg_mem_map[j].start_addr < (512 << 20))  { 
-			/* cannot be < 512MB 
-			 */
-			printk("Kuseg start should be > 512MB. Using defaults for start addr %llx\n", 
-					(unsigned long long)kuseg_mem_map[j].start_addr);
-
-			LOADER_KUSEG_DEFAULTS;
-			return;
-		}
-
-		end1 = kuseg_mem_map[j].start_addr + kuseg_mem_map[j].size;
-
-		for (i=0; i < map->nr_map; i++) {
-			if (map->map[i].type != BOOT_MEM_RAM) continue;
-			end2 = map->map[i].addr +  map->map[i].size;
-			if (( kuseg_mem_map[j].start_addr >= map->map[i].addr) &&
-			   (end1 <= end2)) break;
-		}
-
-		if (i == map->nr_map) {
-			printk("Invalid KUSEG range passed. Using defaults\n");
-			LOADER_KUSEG_DEFAULTS;
-			return;
-		}
-
-		printk("Using 0x%llx as KUSEG start and 0x%llx as KUSEG size\n",
-		       (unsigned long long)kuseg_mem_map[j].start_addr,
-		       (unsigned long long)kuseg_mem_map[j].size);
-	}
-	/* if no input is given, use default 
-	 */
-	if ( kuseg_mem_map[0].start_addr == 0 )	{
-		LOADER_KUSEG_DEFAULTS;
-	}
-
-	return;
-}
-
-uint32_t align_shared_mem(uint32_t shared_mem)
-{
-	if (shared_mem <= (2<<20))
-		return (2<<20);
-	if (shared_mem <= (8 << 20))
-		return (8<<20);
-	if (shared_mem <= (32 << 20))
-		return (32<<20);
-	if (shared_mem <= (128 << 20))
-		return (128<<20);
-	if (shared_mem <= (512 << 20))
-		return (512<<20);
-	return (2<<20);
-}
-
-void prom_validate_loader_args(struct boot_mem_map *map)
-{
-	if (!xlr_loader_support) 
-		return;
-	check_cpu_mask();
-	check_kseg_args();
-	check_kuseg_args(map);
-	
-}
-
 /* Maintain in ascending order of 
  * the starting physical addresses 
  */
@@ -1062,76 +729,6 @@ static struct boot_mem_map_exclude_region static_exclude_regions[] = {
 	[0] = { 0,0},
 };
 
-void prom_exclude_kseg(void)
-{
-   	dynamic_exclude_regions[dyna_exc_index].start = (unsigned long long)
-		1<<20;
-   	dynamic_exclude_regions[dyna_exc_index].end = (unsigned long long)
-                (((unsigned long)&_text) & 0x1fffffffUL);
-   	dyna_exc_index++;
-
-	dynamic_exclude_regions[dyna_exc_index].start = (unsigned long long)
-		nlm_common_loader_kseg_start;
-	dynamic_exclude_regions[dyna_exc_index].end = (unsigned long long)
-		(nlm_common_loader_kseg_start + nlm_common_loader_kseg_size);
-	dyna_exc_index++;
-}
-
-void sort_kuseg_region(void)
-{
-	int i,j;
-	uint64_t temp_addr;
-	uint64_t temp_size;
-
-	for (i = 1; i < 4; i++) {
-		for ( j = 0; j < i; j++) {
-			if ( kuseg_mem_map[i].start_addr <  kuseg_mem_map[j].start_addr ) {
-				temp_addr = kuseg_mem_map[j].start_addr;
-				temp_size = kuseg_mem_map[j].size;
-				kuseg_mem_map[j].start_addr = kuseg_mem_map[i].start_addr;
-				kuseg_mem_map[j].size = kuseg_mem_map[i].size;
-				kuseg_mem_map[i].start_addr = temp_addr;
-				kuseg_mem_map[i].size = temp_size;
-			}
-		}
-	}
-}
-
-void check_kuseg_region_overlap(void)
-{
-	int i,max;
-	uint64_t end1, end2;
-
-	max = MAX_NUM_KUSEG_BLOCKS - 1;
-
-	sort_kuseg_region();
-	for ( i = 0 ;i < max; i++) {
-		end1 = kuseg_mem_map[i].start_addr + kuseg_mem_map[i].size ;
-		if ( ( kuseg_mem_map[i+1].start_addr <= end1 )&& ( kuseg_mem_map[i].start_addr != 0 ) ) {
-			end2 = kuseg_mem_map[i+1].start_addr + kuseg_mem_map[i+1].size;
-			if ( end2 >  end1 )
-				kuseg_mem_map[i].size = end2 - kuseg_mem_map[i].start_addr;
-			kuseg_mem_map[i+1].start_addr = 0;
-			kuseg_mem_map[i+1].size = 0;
-			sort_kuseg_region();
-		}
-	}
-}
-
-void prom_exclude_kuseg(void)
-{
-	int i = 0;
-	check_kuseg_region_overlap();
-
-	for (i = 0 ; i < MAX_NUM_KUSEG_BLOCKS ; i++) {
-		if ( (kuseg_mem_map[i].start_addr != 0 ) && (kuseg_mem_map[i].size != 0) ) {
-			dynamic_exclude_regions[dyna_exc_index].start = kuseg_mem_map[i].start_addr;
-			dynamic_exclude_regions[dyna_exc_index].end = kuseg_mem_map[i].start_addr + kuseg_mem_map[i].size;
-			dyna_exc_index++;
-		}
-	}
-}
-
 void prom_exclude_pci_shmem(void)
 {
 	dynamic_exclude_regions[dyna_exc_index].start =
@@ -1181,11 +778,6 @@ void prom_update_exclude_region(void)
 	}
 #endif
 
-	if (xlr_loader_support) {
-		prom_exclude_kseg();
-		prom_exclude_kuseg();
-	}
-    
 	sort_dynamic_exclude_region();
 	
 	exclude_regions = _exclude_regions[0];
@@ -1251,8 +843,6 @@ static void prom_add_memory(void)
 	if (use_default_phymem)
 		goto use_default;
 
-	prom_validate_loader_args(&prom_map);
-	
 	prom_update_exclude_region();
 	
 	/* TODO: Need to remove this hack
@@ -1314,7 +904,6 @@ static void prom_add_memory(void)
 	 */
 	add_memory_region (DEF_PHYMEM_START_ADDR, 
 			DEF_PHYMEM_SIZE-pref_backup, (long)BOOT_MEM_RAM);
-	xlr_loader_support = 0;
 }
 
 static void psb_print_physmap(void)
@@ -1506,15 +1095,6 @@ static void process_prominfo(void (*(*wakeup))(void *, void *, __u32))
 	       xlr_base_mac_addr[3], xlr_base_mac_addr[4], xlr_base_mac_addr[5]);
 #endif
 
-	if (xlr_loader_support) {
-		if (xlr_loader_sharedcore && 
-		    (xlr_board_atx_iii() || xlr_board_atx_v())) {
-			xlr_loader_own_dma = 1;
-		}
-/*		
- *		prom_init_xlr_loader_setup(prom_info);  
- */
-	}
 }
 
 unsigned long secondary_entry_point;
@@ -1550,32 +1130,6 @@ static int wakeup_secondary_cpus(struct psb_info *prom_info)
 		}
 	}
 
-#if 0
-	if (xlr_loader_support) {
-		wakeup_mask = xlr_linux_cpu_mask | nlm_common_loader_mask;
-		if (wakeup != NULL)
-			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
-	} 
-	else {
-		if (wakeup != NULL) {
-			wakeup((void *)secondary_cpus_bootup_func, 0, 
-				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
-#if defined(CONFIG_NLM_XLP_SIM)
-			unsigned int wait_count = 0;
-			
-			while (smp_boot.online_map != prom_info->nlm_cpu_online_map) {
-				if ((wait_count++ % 1000000) == 0) {
-					printk("[%s%d]: Master cpu waiting for slave cpus to wakeup from bootloader (%x != %llx)\n",
-					       __FUNCTION__, __LINE__, smp_boot.online_map, 
-						   (unsigned long long) prom_info->nlm_cpu_online_map);
-				}
-			}
-			printk("[%s@%d]: woke up prom_info->nlm_cpu_online_map=%016llx\n", __FILE__, __LINE__, 
-				   (unsigned long long) prom_info->nlm_cpu_online_map);
-#endif
-		}
-	}
-#endif
 
 	return 0;
 }
diff --git a/arch/mips/netlogic/xlr/smp.c b/arch/mips/netlogic/xlr/smp.c
index 38eb157..689a6d7 100644
--- a/arch/mips/netlogic/xlr/smp.c
+++ b/arch/mips/netlogic/xlr/smp.c
@@ -41,12 +41,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
-#include <asm/netlogic/nlm_common_loader.h>
-#include <user/netlogic/nlm_common_loader.h>
 
 #include <asm/mach-netlogic/mmu.h>
 
-extern int xlr_loader_support;
 extern volatile cpumask_t cpu_callin_map;
 extern void __init phoenix_smp_init(void); 
 extern void phoenix_smp_finish(void);
@@ -157,9 +154,6 @@ void __init nlm_smp_setup(void)
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	if(xlr_loader_support) {
-		smp_boot.online_map &= ~nlm_common_loader_mask;
-	}
 
 	boot_cpu_online_map = smp_boot.online_map;
 	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
diff --git a/drivers/char/nlm_xlr_msgring.c b/drivers/char/nlm_xlr_msgring.c
index 2b81580..af71bb4 100644
--- a/drivers/char/nlm_xlr_msgring.c
+++ b/drivers/char/nlm_xlr_msgring.c
@@ -112,8 +112,6 @@ extern unsigned long nlm_common_psb_shm_size;
 
 static int    msgring_major;
 
-extern int xlr_loader_support;
-extern int xlr_loader_sharedcore;
 
 struct fifo {
 	struct msgring_msg_data *data;
@@ -691,7 +689,7 @@ static int msgring_init(void)
 	int i=0;
 
 	/* if support for loading apps on same core as Linux is enabled */
-	if(xlr_loader_support && xlr_loader_sharedcore && !xlr_hybrid_rmios_ipsec())
+	if(!xlr_hybrid_rmios_ipsec())
 		return -EINVAL;
 
 	hybrid = strstr(saved_command_line, "hybrid=");
diff --git a/drivers/net/xlr_user_mac.c b/drivers/net/xlr_user_mac.c
index 3fd9345..c255c44 100644
--- a/drivers/net/xlr_user_mac.c
+++ b/drivers/net/xlr_user_mac.c
@@ -74,7 +74,6 @@ static unsigned int g_spi4_card_flag;
 #endif /* CONFIG_NLMCOMMON_SPI4 */
 
 //#define USER_MAC_LOOPBACK
-extern int xlr_loader_support, xlr_loader_sharedcore;
 
 extern void *nlm_common_psb_shm;
 extern unsigned long nlm_common_psb_shm_size;
@@ -1105,10 +1104,6 @@ static int user_mac_init(void)
 	usermac_dev.xgmac_present = 0;
 	usermac_dev.spi4_present = 0;
 
-	/* if support for loading apps on same core as Linux is enabled */
-	if(xlr_loader_support && xlr_loader_sharedcore)
-		return -EINVAL;
-
 	if (xlr_hybrid_user_mac())	{
 		for(i = 0; i < NETLOGIC_MAX_GMACS; i++) {
 			if(net_cfg->gmac_port[i].mmio_addr == 0 || net_cfg->gmac_port[i].cfg_flag == 0)
diff --git a/include/user/netlogic/nlm_common_loader.h b/include/user/netlogic/nlm_common_loader.h
deleted file mode 100644
index a27577e..0000000
--- a/include/user/netlogic/nlm_common_loader.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-#ifndef __USER_NLM_XLR_LOADER_H
-#define __USER_NLM_XLR_LOADER_H
-
-#include <asm/ioctl.h>
-#include <asm/types.h>
-
-#define XLR_MAP_SLAVE_DEVICE 0x1
-
-#define XLR_MAP_UNCACHED 0x1
-#define XLR_MAP_CACHED 0x2
-
-#define NLM_APP_LOADER_CHRDEV_NAME "xlr_app_loader"
-
-#define NLM_LOADER_IOC_MAGIC 'X'
-
-#define NLM_LOADER_IOC_SHMEM_SIZE _IOR(NLM_LOADER_IOC_MAGIC, 0, unsigned int)
-
-#define NLM_LOADER_IOC_MMAP_SHMEM _IOR(NLM_LOADER_IOC_MAGIC, 1, unsigned int)
-
-#define NLM_LOADER_IOC_LIB_BKP _IOR(NLM_LOADER_IOC_MAGIC, 2, unsigned int)
-
-#define NLM_LOADER_IOC_MMAP_LOAD_ADDR  _IOR(NLM_LOADER_IOC_MAGIC, 3, unsigned int)
-
-#define NLM_LOADER_IOC_START_IPI _IOR(NLM_LOADER_IOC_MAGIC, 4, unsigned int)
-
-#define NLM_LOADER_IOC_STOP_IPI  _IOR(NLM_LOADER_IOC_MAGIC, 5, unsigned int)
-
-#define NLM_LOADER_IOC_ALLOC_PERSISTENT_MEM  _IOR(NLM_LOADER_IOC_MAGIC, 6, unsigned int)
-
-#define NLM_LOADER_IOC_MMAP_PERSISTENT_MEM  _IOR(NLM_LOADER_IOC_MAGIC, 7, unsigned int)
-
-#define NLM_LOADER_IOC_FREE_PERSISTENT_MEM  _IOR(NLM_LOADER_IOC_MAGIC, 8, unsigned int)
-
-#define NLM_LOADER_IOC_SHMEM_KSEG_ADDR _IOR(NLM_LOADER_IOC_MAGIC, 10, unsigned int)
-
-#define NLM_LOADER_IOC_LAUNCH_KSEG _IOR(NLM_LOADER_IOC_MAGIC, 15, unsigned int)
-
-#define NLM_LOADER_IOC_APP_SHMEM_SIZE _IOR(NLM_LOADER_IOC_MAGIC, 25, unsigned int)
-
-#define NLM_LOADER_IOC_APP_SHMEM_RESERVE _IOR(NLM_LOADER_IOC_MAGIC, 35, unsigned int)
-
-#define NLM_LOADER_IOC_MMAP_APP_SHMEM _IOR(NLM_LOADER_IOC_MAGIC, 45, unsigned int)
-
-#define NLM_LOADER_IOC_APP_SHMEM_PHYS _IOR(NLM_LOADER_IOC_MAGIC, 55, unsigned int)
-
-#define NLM_LOADER_STORE_ENV _IOR(NLM_LOADER_IOC_MAGIC, 65, unsigned int)
-
-#define NLM_LOADER_SEND_IPI _IOR(NLM_LOADER_IOC_MAGIC, 75, unsigned int)
-
-#define NLM_LOADER_IOC_STORE_APP_SHMEM_INFO _IOR(NLM_LOADER_IOC_MAGIC, 85, unsigned int)
-
-#define NLM_LOADER_IOC_GET_APP_SHMEM_INFO _IOR(NLM_LOADER_IOC_MAGIC, 95, unsigned int)
-
-
-#define NLM_MAX_VCPUS 32
-
-enum { KUSEG_MODE, KSEG0_MODE };
-typedef enum {
-	STOP_THREAD=0xbeef,
-	START_THREAD,
-	RUN_FUNCTION, /* Used by wakeup and wakeup_os call */
-
-}loader_cmd;
-typedef enum {
-	THREAD_STOPPED=0x600d,
-	THREAD_RUNNING,
-	THREAD_SCHEDULED,
-}thread_status;
-
-struct cpu_tlb_mapping {
-	int page_size;
-	int asid;
-	int coherency;
-	int attr;
-	unsigned long virt;
-	uint64_t phys;
-};
-
-#define MAX_TLB_MAPPINGS 16
-#define MAX_ARGS 16
-#define MAX_ARGV_LEN 16
-struct cpu_wakeup_info {
-	int            master_cpu;
-	int            map_count;
-	int            valid;
-	unsigned long  func;
-	unsigned long  args;
-	int            argc;
-	uint32_t       buddy_mask;
-	uint32_t       cpu_mask;
-	char          *argv[32]; /* RMIOS LIB NEEDS this to be 32 */
-	char           buf[256];/* must be > MAX_ARGS * MAX_ARGV_LEN + some buffer */
-	struct cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
-};
-
-/* SHARED memory structure b/w loader app, linux and RMIOS apps */
-typedef struct nlm_common_loader_shared_struct {
-	unsigned long park_entry;
-	loader_cmd    cmd;
-	thread_status thr_status;
-	unsigned long entry; /* Entry point address */
-	int 	      run_mode;
-	struct cpu_wakeup_info run_info;
-	uint32_t 	app_sh_mem_sz; /* Size of the shared memory */
-	unsigned long	sp;/* Used for reentry */
-	unsigned long	gp;
-}nlm_common_loader_shared_struct_t;
-
-
-/* This structure is passed to all applications launched from the linux
-   loader through OS 7 scratch register
-   */
-#define NLM_LOADER_INFO_MAGIC 0x600ddeed
-typedef struct nlm_common_loader_info {
-	uint32_t magic;
-	/* nlm_common_loader_shared_struct_t for CPU 0 will start here */
-	unsigned long sh_mem_start;
-	/* Size of the shared memory b/w linux apps and rmios apps  */
-	uint32_t app_sh_mem_size;
-	uint8_t printk_lock[16]; /* used for printk */
-}nlm_common_loader_info_t;
-
-#endif
-- 
1.7.0.4

