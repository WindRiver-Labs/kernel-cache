From ea0ef48c14831c6cd1b3338a35c070c1b24239c7 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Wed, 24 Apr 2013 16:59:14 +0800
Subject: [PATCH 384/762] Resolve merge conflict: pick linux-3.0-stable

onfi

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/nand/nand_base.c |   87 +-----------------------------------------
 1 files changed, 2 insertions(+), 85 deletions(-)

diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 892bacf..821644a 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1,11 +1,3 @@
-/* **********************************************************************
-* Copyright 2003-2010 Netlogic Microsystems Inc. (â~@~\Netlogicâ~@~]).
-* This is a derived work from software originally provided by the external
-* entity identified below. The licensing terms and warranties specified in
-* the header of the original work apply to this derived work.
-*
-* *****************************#NETL_1#********************************/
-
 /*
  *  drivers/mtd/nand.c
  *
@@ -54,9 +46,6 @@
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/leds.h>
-#ifdef CONFIG_NLM_XLP
-#include <linux/crc16.h>
-#endif
 #include <linux/io.h>
 #include <linux/mtd/partitions.h>
 
@@ -103,43 +92,6 @@ static struct nand_ecclayout nand_oob_128 = {
 		{.offset = 2,
 		 .length = 78} }
 };
-#ifdef CONFIG_NLM_XLP
-static u16 onfi_crc(u16 crc, unsigned char const *p, size_t len)
-{
-        int i;
-        while (len--) {
-                crc ^= *p++ << 8;
-                for (i = 0; i < 8; i++)
-                        crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
-        }
-        return crc;
-}
-
-/*
- * sanitize ONFI strings so we can safely print them
- */
-static void sanitize_string(uint8_t *s, size_t len)
-{
-        ssize_t i;
-
-        /* null terminate */
-        s[len - 1] = 0;
-
-        /* remove non printable chars */
-        for (i = 0; i < len - 1; i++) {
-                if (s[i] < ' ' || s[i] > 127)
-                        s[i] = '?';
-        }
-	/* remove trailing spaces */
-	for (i = len - 1; i >= 0; i--) {
-		if (s[i] && s[i] != ' ')
-			break;
-		s[i] = 0;
-	}
-}
-#endif
-
-static int nand_manufacturer;
 
 static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
@@ -667,11 +619,6 @@ static void nand_command(struct mtd_info *mtd, unsigned int command,
 	case NAND_CMD_STATUS:
 		return;
 
-	/* In case of micron nand, we need to return */
-	case NAND_CMD_READID:
-		udelay(chip->chip_delay);
-		return;
-
 	case NAND_CMD_RESET:
 		if (chip->dev_ready)
 			break;
@@ -719,7 +666,6 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 			    int column, int page_addr)
 {
 	register struct nand_chip *chip = mtd->priv;
-	int micron_chip = 0;
 
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
@@ -755,14 +701,6 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	}
 	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
-	if ((mtd->name) && (nand_manufacturer == NAND_MFR_MICRON))
-		micron_chip = 1;
-
-	if (micron_chip) {
-		if (command == NAND_CMD_READID)
-			return;
-	}
-
 	/*
 	 * Program and erase have their own busy handlers status, sequential
 	 * in, and deplete1 need no delay.
@@ -833,10 +771,6 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	ndelay(100);
 
 	nand_wait_ready(mtd);
-	if ((micron_chip) && (command == NAND_CMD_READ0)) {
-		chip->cmd_ctrl(mtd, NAND_CMD_READ0,
-			       NAND_CLE | NAND_CTRL_CHANGE);
-	}
 }
 
 /**
@@ -3123,6 +3057,7 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		 */
 		mtd->erasesize = type->erasesize;
 		mtd->writesize = type->pagesize;
+		mtd->oobsize = mtd->writesize / 32;
 		busw = type->options & NAND_BUSWIDTH_16;
 
 		/*
@@ -3154,28 +3089,12 @@ ident_done:
 	 */
 	chip->options |= NAND_NO_AUTOINCR;
 
-#ifdef CONFIG_NLM_XLP
-        /* Get chip options, preserve non chip based options */
-        chip->options &= ~NAND_CHIPOPTIONS_MSK;
-        chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
-
-        /* Check if chip is a not a samsung device. Do not clear the
-         * options for chips which are not having an extended id.
-         */
-        if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
-                chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
-ident_done:
-
-        /*
-         * Set chip as a default. Board drivers can override it, if necessary
-         */
-        chip->options |= NAND_NO_AUTOINCR;
-#endif
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
 			break;
 	}
+
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct!
@@ -3248,8 +3167,6 @@ ident_done:
 		nand_manuf_ids[maf_idx].name,
 		chip->onfi_version ? chip->onfi_params.model : type->name);
 
-	nand_manufacturer =  *maf_id;
-
 	return type;
 }
 
-- 
1.7.0.4

