From f3b837947716817093d91baf641573d27bc96704 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 9 Sep 2013 10:49:44 +0800
Subject: [PATCH 560/565] bcm-xlp: clean up architecture codes

1. remove some unnecessary definitions: such as kernel config NLM_XLP_SIM;
2. restore some improper code changes which made in the previous patches;
3. use the new proc FS operations to replace the old.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                    |  19 ++-----
 arch/mips/Makefile                   |  10 ++--
 arch/mips/mm/tlb-r4k.c               |  51 +++--------------
 arch/mips/netlogic/Platform          |   4 +-
 arch/mips/netlogic/common/cpu_proc.c | 106 +++++++++++++----------------------
 arch/mips/netlogic/xlp/smp.c         |   2 +-
 arch/mips/netlogic/xlp/time.c        |  35 +++++++-----
 7 files changed, 81 insertions(+), 146 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 707117c..ffceb42 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -868,20 +868,6 @@ source "arch/mips/netlogic/Kconfig"
 
 endmenu
 
-menuconfig PARAVIRT_GUEST
-	bool "Paravirtualized guest support"
-	---help---
-	  Say Y here to get to see options related to running Linux under
-	  various hypervisors.  This option alone does not add any kernel code.
-
-	  If you say N, all options in this submenu will be skipped and disabled.
-
-if PARAVIRT_GUEST
-
-source "arch/mips/xen/Kconfig"
-
-endif
-
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
@@ -2129,7 +2115,9 @@ config SB1_PASS_2_1_WORKAROUNDS
 
 
 config 64BIT_PHYS_ADDR
+	select PHYS_ADDR_T_64BIT
 	bool
+	default y
 
 config ARCH_PHYS_ADDR_T_64BIT
        def_bool 64BIT_PHYS_ADDR
@@ -2267,6 +2255,7 @@ source "mm/Kconfig"
 config SMP
 	bool "Multi-Processing support"
 	depends on SYS_SUPPORTS_SMP
+	select IRQ_PER_CPU
 	select USE_GENERIC_SMP_HELPERS
 	help
 	  This enables support for systems with more than one CPU. If you have
@@ -2506,6 +2495,7 @@ config PCI
 	bool "Support for PCI controller"
 	depends on HW_HAS_PCI
 	select PCI_DOMAINS
+	select GENERIC_PCI_IOMAP
 	select NO_GENERIC_PCI_IOPORT_MAP
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
@@ -2644,6 +2634,7 @@ config BINFMT_ELF32
 endmenu
 
 menu "Power management options"
+
 config ARCH_HIBERNATION_POSSIBLE
 	def_bool y
 	depends on SYS_SUPPORTS_HOTPLUG_CPU || !SMP
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 8844bd4..3bc5164 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -248,17 +248,17 @@ endif
 
 KBUILD_AFLAGS	+= $(cflags-y)
 KBUILD_CFLAGS	+= $(cflags-y)
-KBUILD_CPPFLAGS += -D"VMLINUX_LOAD_ADDRESS=$(load-y)"
-KBUILD_CPPFLAGS += -D"DATAOFFSET=$(if $(dataoffset-y),$(dataoffset-y),0)"
+KBUILD_CPPFLAGS += -DVMLINUX_LOAD_ADDRESS=$(load-y)
+KBUILD_CPPFLAGS += -DDATAOFFSET=$(if $(dataoffset-y),$(dataoffset-y),0)
 
 LDFLAGS			+= -m $(ld-emul)
 
 ifdef CONFIG_MAPPED_KERNEL
-KBUILD_CPPFLAGS	+= -D"LOADADDR=$(load-y)" -D"PHYSADDR=$(CONFIG_PHYS_LOAD_ADDRESS)"
+KBUILD_CPPFLAGS	+= -DLOADADDR=$(load-y) -DPHYSADDR=$(CONFIG_PHYS_LOAD_ADDRESS)
 endif
 
 ifdef CONFIG_MIPS
-CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -x c /dev/null | \
+CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
 	egrep -vw '__GNUC_(|MINOR_|PATCHLEVEL_)_' | \
 	sed -e "s/^\#define /-D'/" -e "s/ /'='/" -e "s/$$/'/")
 ifdef CONFIG_64BIT
@@ -268,7 +268,7 @@ endif
 
 OBJCOPYFLAGS		+= --remove-section=.reginfo
 
-head-y := arch/mips/kernel/head.o arch/mips/kernel/init_task.o
+head-y := arch/mips/kernel/head.o
 
 libs-y			+= arch/mips/lib/
 
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 29bde4a..100a69c 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -479,39 +479,6 @@ out:
 	return ret;
 }
 
-static void __cpuinit probe_tlb(unsigned long config)
-{
-	struct cpuinfo_mips *c = &current_cpu_data;
-	unsigned int reg;
-
-	/*
-	 * If this isn't a MIPS32 / MIPS64 compliant CPU.  Config 1 register
-	 * is not supported, we assume R4k style.  Cpu probing already figured
-	 * out the number of tlb entries.
-	 */
-	if ((c->processor_id & 0xff0000) == PRID_COMP_LEGACY)
-		return;
-#ifdef CONFIG_MIPS_MT_SMTC
-	/*
-	 * If TLB is shared in SMTC system, total size already
-	 * has been calculated and written into cpu_data tlbsize
-	 */
-	if((smtc_status & SMTC_TLB_SHARED) == SMTC_TLB_SHARED)
-		return;
-#endif /* CONFIG_MIPS_MT_SMTC */
-
-	reg = read_c0_config1();
-	if (!((config >> 7) & 3))
-		panic("No TLB present");
-
-#if defined(CONFIG_NLM_XLP)
-	c->tlbsize = ((read_c0_config6() >> 16 ) & 0xffff) + 1;
-#else
-	c->tlbsize = ((reg >> 25) & 0x3f) + 1;
-#endif
-
-}
-
 static int __cpuinitdata ntlb;
 static int __init set_ntlb(char *str)
 {
@@ -554,17 +521,17 @@ void __cpuinit tlb_init(void)
 	write_c0_framemask(0);
 #endif
 
-   if (kernel_uses_smartmips_rixi) {
-       /*
-        * Enable the no read, no exec bits, and enable large virtual
-        * address.
-        */
-       u32 pg = PG_RIE | PG_XIE;
+	if (kernel_uses_smartmips_rixi) {
+		/*
+		 * Enable the no read, no exec bits, and enable large virtual
+		 * address.
+		 */
+		u32 pg = PG_RIE | PG_XIE;
 #ifdef CONFIG_64BIT
-       pg |= PG_ELPA;
+		pg |= PG_ELPA;
 #endif
-       write_c0_pagegrain(pg);
-   }
+		write_c0_pagegrain(pg);
+	}
 
 	temp_tlb_entry = current_cpu_data.tlbsize - 1;
 
diff --git a/arch/mips/netlogic/Platform b/arch/mips/netlogic/Platform
index 04ff9aa..b1b54d6 100644
--- a/arch/mips/netlogic/Platform
+++ b/arch/mips/netlogic/Platform
@@ -1,8 +1,8 @@
 #
 # NETLOGIC includes
 #
-cflags-$(CONFIG_NLMCOMMON)	+= -I$(srctree)/arch/mips/include/asm/mach-netlogic
-cflags-$(CONFIG_NLMCOMMON)	+= -I$(srctree)/arch/mips/include/asm/netlogic
+cflags-$(CONFIG_NLM_COMMON)	+= -I$(srctree)/arch/mips/include/asm/mach-netlogic
+cflags-$(CONFIG_NLM_COMMON)	+= -I$(srctree)/arch/mips/include/asm/netlogic
 
 #
 # use mips64 if xlr is not available
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index ad88837..865a7f6 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -117,113 +117,83 @@ void nlm_cpu_stat_update_msgring_pic_int(void)
 	preempt_enable();
 }
 
-static int nlm_cpu_proc_read(char *page, char **start, off_t off,
-			     int count, int *eof, void *data)
+static int nlm_cpu_proc_show(struct seq_file *m, void *v)
 {
 	int i = 0;
-	int len = 0;
-	off_t begin = 0;
 
-	len += sprintf(page + len, "CPU Frequency: %u HZ\n", (unsigned int)mips_hpt_frequency);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
+	seq_printf(m, "CPU Frequency: %u HZ\n", (unsigned int)mips_hpt_frequency);
 
 #ifdef CONFIG_32BIT
-        len += sprintf(page + len, "32 Bit ");
+        seq_printf(m, "32 Bit ");
 #else
-        len += sprintf(page + len, "64 Bit ");
+        seq_printf(m, "64 Bit ");
 #endif
-        if (!proc_pos_check(&begin, &len, off, count))
-               goto out;
 
 #ifdef CONFIG_CPU_BIG_ENDIAN
-        len += sprintf(page + len, "Big Endian ");
+        seq_printf(m, "Big Endian ");
 #else
-        len += sprintf(page + len, "Little Endian ");
+        seq_printf(m, "Little Endian ");
 #endif
-        if (!proc_pos_check(&begin, &len, off, count))
-               goto out;
 
 #ifdef CONFIG_MAPPED_KERNEL
-        len += sprintf(page + len, "Mapped Kernel.\n");
+        seq_printf(m, "Mapped Kernel.\n");
 #else
-        len += sprintf(page + len, "Un-Mapped Kernel.\n");
+        seq_printf(m, "Un-Mapped Kernel.\n");
 #endif
-        if (!proc_pos_check(&begin, &len, off, count))
-               goto out;
-
-	for(i=0;i<32;i++) {
 
+	for(i=0; i<NR_CPUS; i++) {
 		if (!nlm_cp2_exceptions[i]) continue;
-
-			len += sprintf(page + len,
-				       "cop2_exp: %03d 0x%016llx\n",
-				       i, (unsigned long long)nlm_cp2_exceptions[i]);
-			if (!proc_pos_check(&begin, &len, off, count))
-				goto out;
+		seq_printf(m, "cop2_exp: %03d 0x%016llx\n",
+				i, (unsigned long long)nlm_cp2_exceptions[i]);
 	}
 
-	for(i=0;i<32;i++) {
-
+	for(i=0; i<NR_CPUS; i++) {
 		if (!nlm_cpu_stats[i].msgring_pic_int && !nlm_cpu_stats[i].msgring_int)
 			continue;
-
-			len += sprintf(page + len,
-				       "msgring: %03d 0x%016llx 0x%016llx 0x%016llx\n",
-				       i, nlm_cpu_stats[i].msgring_pic_int,
-				       nlm_cpu_stats[i].msgring_int,
-				       nlm_cpu_stats[i].msgring_cycles);
-			if (!proc_pos_check(&begin, &len, off, count))
-				goto out;
+		seq_printf(m, "msgring: %03d 0x%016llx 0x%016llx 0x%016llx\n",
+				i, nlm_cpu_stats[i].msgring_pic_int,
+				nlm_cpu_stats[i].msgring_int,
+				nlm_cpu_stats[i].msgring_cycles);
 	}
 
-	for(i=0;i<32;i++) {
-
+	for(i=0; i<NR_CPUS; i++) {
 		if (!nlm_cpu_stats[i].fp_exp && !nlm_cpu_stats[i].rdhwr_exp)
 			continue;
-
-			len += sprintf(page + len,
-				       "cpu_exp: %03d 0x%016llx 0x%016llx\n",
-				       i, nlm_cpu_stats[i].fp_exp,
-				       nlm_cpu_stats[i].rdhwr_exp);
-			if (!proc_pos_check(&begin, &len, off, count))
-				goto out;
+		seq_printf(m, "cpu_exp: %03d 0x%016llx 0x%016llx\n",
+				i, nlm_cpu_stats[i].fp_exp,
+				nlm_cpu_stats[i].rdhwr_exp);
 	}
 
 	for (i = 0; i < 32; i++) {
-
 		if (!nlm_common_tlb_stats[i])
 			continue;
-
-		len += sprintf(page + len,
-			       "tlb: %03d 0x%016llx \n",
-			       i, nlm_common_tlb_stats[i]);
-		if (!proc_pos_check(&begin, &len, off, count))
-			goto out;
+		seq_printf(m, "tlb: %03d 0x%016llx \n",
+				i, nlm_common_tlb_stats[i]);
 	}
 
-	*eof = 1;
-
-      out:
-	*start = page + (off - begin);
-	len -= (off - begin);
-	if (len > count)
-		len = count;
-	if (len < 0)
-		len = 0;
+	return 0;
+}
 
-	return len;
+static int nlm_cpu_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nlm_cpu_proc_show, NULL);
 }
 
+static const struct file_operations nlm_cpu_proc_fops = {
+	.open		= nlm_cpu_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int nlm_cpu_proc_init(void)
 {
 	struct proc_dir_entry *entry;
 #ifdef CONFIG_NLM_XLP
-	entry = create_proc_read_entry("xlp_cpu", 0 /* def mode */ ,
-				       nlm_root_proc/* parent */ ,
-				       nlm_cpu_proc_read
-				       /* proc read function */ ,
-				       0	/* no client data */
+	entry = proc_create_data("xlp_cpu", 0 /* def mode */ ,
+				nlm_root_proc/* parent */ ,
+				&nlm_cpu_proc_fops,
+				0	/* no client data */
 		);
 #endif
 	if (!entry) {
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index b9a9882..7ca0970 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -337,7 +337,7 @@ int wakeup_secondary_cpus(void)
 	cpumask_clear(&mask32);
 	uint32_to_cpumask(&mask32, 0xffffffff);
 
-	for (node = 0; node < 4; node++) {
+	for (node = 0; node < 1; node++) {
 		cpumask_t tmpmask, nodemask;
 		cpumask_t tmploader_mask, loadernode_mask;
 		unsigned int onlinemask;
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index f4b7cda..c564c50 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -80,26 +80,34 @@ void __init plat_time_init(void)
 }
 
 #endif
-static int nlm_timer_proc_read(char *page, char **start, off_t off, int count,
-			       int *eof, void *data)
-{
-	int len = 0;
 
-	preempt_disable();
-	len += sprintf(page + len, "cpu = %d, eimr = 0x%016llx, status = 0x%x\n",
-				   /*smp_processor_id(), */
-				   hard_smp_processor_id(),
-                   (unsigned long long)read_64bit_cp0_eimr(), read_c0_status());
+static int nlm_timer_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "cpu = %d, eimr = 0x%016llx, status = 0x%x\n",
+			hard_smp_processor_id(),
+			(unsigned long long)read_64bit_cp0_eimr(),
+			read_c0_status());
 	preempt_enable();
-	*eof = 1;
 
-	return len;
+	return 0;
 }
 
 extern struct proc_dir_entry *nlm_root_proc;
 struct proc_dir_entry *main_entry;
 struct proc_dir_entry *sub_entry;
 
+static int nlm_timer_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nlm_timer_proc_show, NULL);
+}
+
+static const struct file_operations nlm_timer_proc_fops = {
+	.open		= nlm_timer_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int __maybe_unused init_pic_timer_procfs(void)
 {
 	main_entry = proc_mkdir("nlm_timer", nlm_root_proc);
@@ -108,15 +116,14 @@ static int __maybe_unused init_pic_timer_procfs(void)
 		return -ENOMEM;
 	}
 
-	sub_entry = create_proc_entry("debug", 0644, main_entry);
+	sub_entry = proc_create_data("debug", 0644,
+				 main_entry, &nlm_timer_proc_fops, 0);
 
 	if (!sub_entry) {
 		remove_proc_entry("nlm_timer", nlm_root_proc);
 		return -ENOMEM;
 	}
 
-	sub_entry->read_proc = nlm_timer_proc_read;
-
 	printk("created nlm_timer proc fs entry\n");
 
 	return 0;
-- 
1.8.4.93.g57e4c17

