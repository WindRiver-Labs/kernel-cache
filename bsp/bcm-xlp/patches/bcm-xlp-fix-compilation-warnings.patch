From acf9389cbbea4e53d47ce0614e2e75e7c6b37d1b Mon Sep 17 00:00:00 2001
From: VIRENDRA PATHAK <vpathak@lc-blr-162.ban.broadcom.com>
Date: Wed, 16 Jan 2013 18:18:05 +0530
Subject: [PATCH 476/565] bcm-xlp: fix compilation warnings

Fix compilation warnings.

Based on Broadcom SDK 2.3.

Signed-off-by: VIRENDRA PATHAK <vpathak@lc-blr-162.ban.broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/common/nlm_hal.c               | 51 +++--------------------
 arch/mips/netlogic/common/nlm_hal_nae.c           | 27 +++++-------
 arch/mips/netlogic/common/nlm_hal_nae_interface.c |  8 +++-
 3 files changed, 22 insertions(+), 64 deletions(-)

diff --git a/arch/mips/netlogic/common/nlm_hal.c b/arch/mips/netlogic/common/nlm_hal.c
index a5ee0af..793d2df 100644
--- a/arch/mips/netlogic/common/nlm_hal.c
+++ b/arch/mips/netlogic/common/nlm_hal.c
@@ -1244,7 +1244,7 @@ void nlm_hal_restart_an(int node, int inf)
 {
 	static int link_status[XLP_MAX_PORTS];
 	struct nlm_hal_ext_phy *phy=NULL;
-	int i = 0, int_inf, status, phyaddr, bus;
+	int i = 0, int_inf, status, bus;
 
 	while(regs_ext_phys[i].inf != -1)
 	{
@@ -1254,7 +1254,6 @@ void nlm_hal_restart_an(int node, int inf)
 		if((phy->phy_idfer == 0x60c1 || phy->phy_idfer == 0xbcb2))/* only for broadcom phys*/
 		{
 			int_inf = phy->inf;
-			phyaddr = phy->phy_addr;
 			bus = phy->ext_mdio_bus;
 
 			status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
@@ -1338,47 +1337,8 @@ static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node)
 static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 {
 	int status, count;
-	int phyaddr;
-	int bus;
 	int int_inf = phy->inf;
 
-	phyaddr = phy->phy_addr;
-        bus = phy->ext_mdio_bus;
-	/*switch to Copper registers mode*/
-	/*refer mode control register in broadcom datasheet*/
-	/*nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr); */
-#if 0
-	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
-	status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
-	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
-	status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x0);
-	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x0, status|(1<<9));
-	count=0;
-        do {
-		nlm_mdelay(100);
-		count++;
-		status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
-		if(status & (1<<5)){ /* check for autonegotiation to be completed */
-			nlm_print("Autonegotiation is OK for phyaddr=0x%x \n", phyaddr);
-			break;
-		}
-		status = -1;
-        }while(count<50);
-
-	if(status<0){
-		nlm_print("Autonegotiation is NOT OK for phyaddr=0x%x \n", phyaddr);
-		return;
-	}
-#endif
-
-
-	/*switch to 1000Base-X registers mode*/
-	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00); */
-	/*status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C); */
-	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1))); */
-	/*status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0); */
-	/*nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status|(1<<9)); Restart AN on SGMMII side of PHY*/
-	/*nlm_mdelay(1000); */
 	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); /* Restart XLP AN */
 	/*Wait for XLP<->SGMII-PHY AN to be OK*/
@@ -1756,7 +1716,10 @@ void register_phy(int node, int inf, int* hw_portid)
 {
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
 	int i = 0;
-	int phy_addr, ext_mdio_bus;
+	int phy_addr;
+#ifdef CONFIG_N511
+	int ext_mdio_bus;
+#endif
 	for(i=0; nae_cfg->num_ports; i++){
 		if(nae_cfg->ports[i].hw_port_id == inf)
 		break;
@@ -1773,11 +1736,9 @@ void register_phy(int node, int inf, int* hw_portid)
           nae_cfg->ports[i].ext_phy_addr = 0x10;
           nae_cfg->ports[i].ext_phy_bus = 1;
         }
+	ext_mdio_bus = nae_cfg->ports[i].ext_phy_bus;
 #endif
 	phy_addr = nae_cfg->ports[i].ext_phy_addr;
-	ext_mdio_bus = nae_cfg->ports[i].ext_phy_bus;
-	/*nlm_print("register_phy with inf=0x%x phy_addr=0%x ext_mdio_bus=0x%x\n", inf, phy_addr, ext_mdio_bus); */
-
 	*hw_portid = phy_addr;
 	/* make a inf and hw_port id pair*/
 	for(i=0; i<reg_num_phys; i++){
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index c8c15ed..d65f870 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -249,7 +249,6 @@ int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mo
 	int rext_sel = 0;
 	int count=0;
 	int count_max=1000;
-	uint32_t val_temp = 0;
 	NAE_DEBUG("%s: node %d block %d lane_ctrl %x \n", __func__, node, block, lane_ctrl);
 
 	/* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
@@ -260,7 +259,6 @@ int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mo
 		NAE_DEBUG("mode is %x so function is returning\n", mode);
 		return 0;
 	}
-
 	if(lane_ctrl != 4)
 		rext_sel = (1 << 23);
 
@@ -275,8 +273,7 @@ int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mo
 	val &= ~(1 << 17); //setting indirect register request access to 0
 	NAE_DEBUG("PHY LANE CTRL REG to be written with value: %x\n",val);
 	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n",  nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
 	nlm_mdelay(1);
 
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
@@ -290,22 +287,19 @@ int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mo
 	NAE_DEBUG("Clearing the Power Down Bit(Bit 29)\n");
 	val &= ~( (1 << 29) | (0x7ffff));
 	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
-	val_temp = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n",  nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
 
 	NAE_DEBUG("Setting the PMA Register Bit(Bit 20)\n");
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
 	val |= 0x100000;  /* Bit20: serdes reg reset Storm & Eagle B0 */
 	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n",  nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
 
 	NAE_DEBUG("Setting PMA Controller reset bit(Bit 30)\n");
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
 	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
 	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n",  nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
 
 	/* Setting Rext_Sel*/
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
@@ -650,7 +644,9 @@ void nlm_hal_config_sgmii_if(int node, int inf)
 	unsigned int netwk_inf = 0;
 	unsigned int ifmode, speed, duplex;
 	struct nlm_hal_ext_phy *this_phy=NULL;
+#if !defined(XLP_SIM) || defined(NLM_BOARD)
 	struct nlm_hal_mii_info mii_info;
+#endif
 
 	/* Disable TX , Rx for now */
 	mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
@@ -909,8 +905,8 @@ static void init_poe_enq_deq_spill(int node, uint64_t val, int len)
 		nlm_hal_write_poe_pcie_reg(node, enq_reg_high, enq_high);
 		nlm_hal_write_poe_pcie_reg(node, enq_reg_len, reg_len_64b_allign);
 
-		nlm_hal_write_poe_pcie_reg(node, deq_reg_low, enq_low);
-		nlm_hal_write_poe_pcie_reg(node, deq_reg_high, enq_high);
+		nlm_hal_write_poe_pcie_reg(node, deq_reg_low, deq_low);
+		nlm_hal_write_poe_pcie_reg(node, deq_reg_high,deq_high);
 		nlm_hal_write_poe_pcie_reg(node, deq_reg_len, reg_len_64b_allign);
 
 		enq_reg_low++;
@@ -1503,10 +1499,9 @@ static void nlm_config_flow_base(int node, nlm_nae_config_ptr nae_cfg)
 {
         int port = 0, hw_port = 0;
         int flow_mask = get_flow_mask(nae_cfg->num_ports);
-        uint32_t reg, cur_flow_base = 0, max_ports;
+        uint32_t reg, cur_flow_base = 0;
 	uint32_t per_port_num_flows = XLP_MAX_FLOWS / nae_cfg->num_ports;
 
-	max_ports = nlm_get_max_ports();
 	for (port = 0, hw_port = 0 ; port < nae_cfg->num_ports; hw_port++) {
             if (hw_port == nae_cfg->ports[port].hw_port_id) {
 		reg = (cur_flow_base << 16) | hw_port;
@@ -2680,12 +2675,10 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 {
 	int hw_port;
 	int num_ports = 0, port = 0;
-	uint32_t start_port, num_nae_regs, num_intf_regs;
 	uint32_t rx_config = 0, tx_config = 0;
 	int frequency, context = 0;
 
 	/* Parse Nae Config */
-	start_port = num_nae_regs = num_intf_regs = 0;
 
 	frequency = nlm_hal_get_fdt_freq(fdt, NLM_NAE);
 	set_nae_frequency(node, frequency);
@@ -3019,9 +3012,9 @@ static void reset_nae(int node)
 
 	nlm_hal_write_sys_reg(node, SYS_RESET, (0 << reset_bit));
 	nlm_mdelay(1);
-
 	rx_config = nlm_hal_read_nae_reg(node, RX_CONFIG);
 	nae_reset_done[node] = 1;
+	printf(" nae reset done with rx_config = %d\n", rx_config);
 }
 
 #if defined(__MIPSEL__)
diff --git a/arch/mips/netlogic/common/nlm_hal_nae_interface.c b/arch/mips/netlogic/common/nlm_hal_nae_interface.c
index 5a0466e..984240d 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae_interface.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae_interface.c
@@ -1870,16 +1870,20 @@ void nlm_hal_msec_set_rx_cam(int node, int index, int port_num, uint64_t sci, ui
 unsigned int nlm_hal_msec_get_rx_cam(int node, int index)
 {
 	unsigned int cntrl_reg_val =  (2 << 11)| (index & 0x7ff);
-	unsigned int data = 0, data1 = 0, data2 = 0;
-
+	unsigned int data = 0;
+#ifdef MACSEC_DEBUG
+	unsigned int data1 = 0, data2 = 0;
+#endif
 	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
 
 	cntrl_reg_val = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_CTRL_REG);
 	if(cntrl_reg_val & (1<< 23))
 	{
 		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_0);
+	#ifdef MACSEC_DEBUG
 		data1 = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_1);
 		data2 = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_2);
+	#endif
 	}
 #ifdef MACSEC_DEBUG
 	nlm_print("RX CAM index = %d, data0 = %x data_1 = %x data_2 = %x\n", index, data, data1, data2);
-- 
1.8.4.93.g57e4c17

