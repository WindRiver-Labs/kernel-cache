From e311ad6c445099b30acafd26db43fcb7a94e434e Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 25 Apr 2013 17:17:46 +0800
Subject: [PATCH 496/565] hugetlb: add support for hugetlb

- See Documentation/vm/hugetlbpage.txt for detailed information about
  how to use hugetlb through linux kernel
- By default, 8MB huge page size is assumed.

Based on Broadcom SDK 2.3.

Signed-off-by: Sreenidhi B R <sreenira@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig            | 42 ++++++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/tlb-r4k.c       | 39 ++++++++++++++++++++++++++++++++-------
 arch/mips/mm/tlbex-fault.S   |  7 +++++++
 arch/mips/mm/tlbex.c         | 15 +++++----------
 arch/mips/netlogic/xlp/mmu.c |  7 ++++++-
 5 files changed, 92 insertions(+), 18 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 8229997..2ab0a30 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -1841,6 +1841,48 @@ config PAGE_SIZE_64KB
 
 endchoice
 
+choice
+        prompt "Huge page size"
+	depends on HUGETLB_PAGE
+        default HUGE_PAGE_SIZE_8M
+
+config HUGE_PAGE_SIZE_128K
+        bool "128kB"
+	help
+	  Using 128KB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_512K
+        bool "512kB"
+	help
+	  Using 512KB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_2M
+        bool "2mB"
+	help
+	  Using 2MB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_8M
+        bool "8mB"
+	help
+	  Using 8MB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_32M
+        bool "32mB"
+	help
+	  Using 32MB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_128M
+        bool "128mB"
+	help
+	  Using 128MB as the hugetlb page size
+
+config HUGE_PAGE_SIZE_512M
+        bool "512mB"
+	help
+	  Using 512MB as the hugetlb page size
+
+endchoice
+
 config FORCE_MAX_ZONEORDER
 	int "Maximum zone order"
 	range 14 64 if HUGETLB_PAGE && PAGE_SIZE_64KB
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index b7bf169..29bde4a 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -264,6 +264,32 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 	}
 }
 
+#ifdef CONFIG_HUGETLB_PAGE
+asmlinkage void do_hugetlb_invalidate(void)
+{
+	int oldpid, idx;
+
+	oldpid = read_c0_entryhi();
+	tlb_probe();
+	tlb_probe_hazard();
+	idx = read_c0_index();
+	if (idx > 0) {
+		int ridx = idx & 0x1fff;
+
+		if (ridx > ((read_c0_config6() >> 6) & 0x3ff)) {
+			/* Make sure all entries differ. */
+			write_c0_entrylo0(0);
+			write_c0_entrylo1(0);
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx & 0x1fff));
+			mtc0_tlbw_hazard();
+			tlb_write_indexed();
+			tlbw_use_hazard();
+			write_c0_entryhi(oldpid);
+		}
+	}
+}
+#endif
+
 /*
  * This one is only used for pages with the global bit set so we don't care
  * much about the ASID.
@@ -333,19 +359,18 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 	idx = read_c0_index();
 #ifdef CONFIG_HUGETLB_PAGE
 	/* this could be a huge page  */
-	if (pmd_huge(*pmdp)) {
-		unsigned long lo;
+	if (is_vm_hugetlb_page(vma)) {
 		write_c0_pagemask(PM_HUGE_MASK);
-		ptep = (pte_t *)pmdp;
-		lo = pte_to_entrylo(pte_val(*ptep));
-		write_c0_entrylo0(lo);
-		write_c0_entrylo1(lo + (HPAGE_SIZE >> 7));
+		ptep = pte_offset_map(pmdp, address);
+		write_c0_entrylo0(pte_to_entrylo(pte_val(*ptep++)));
+		write_c0_entrylo1(pte_to_entrylo(pte_val(*ptep)));
 
 		mtc0_tlbw_hazard();
 		if (idx < 0)
 			tlb_write_random();
-		else
+		else {
 			tlb_write_indexed();
+		}
 		write_c0_pagemask(PM_DEFAULT_MASK);
 	} else
 #endif
diff --git a/arch/mips/mm/tlbex-fault.S b/arch/mips/mm/tlbex-fault.S
index e99eaa1..ca1369b 100644
--- a/arch/mips/mm/tlbex-fault.S
+++ b/arch/mips/mm/tlbex-fault.S
@@ -15,6 +15,13 @@
 	NESTED(tlb_do_page_fault_\write, PT_SIZE, sp)
 	SAVE_ALL
 	MFC0	a2, CP0_BADVADDR
+
+#ifdef CONFIG_HUGETLB_PAGE
+	/* invalidate the tlb entry in fixed tlb */
+	jal     do_hugetlb_invalidate
+	nop
+#endif
+
 	KMODE
 	move	a0, sp
 	REG_S	a2, PT_BVADDR(sp)
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 4cabc96..84f4d8a 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -1420,11 +1420,11 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		build_get_pgde32(&p, K0, K1); /* get pgd in K1 */
 #endif
 
+		build_get_ptep(&p, K0, K1);
 #ifdef CONFIG_HUGETLB_PAGE
 		build_is_huge_pte(&p, &r, K0, K1, label_tlb_huge_update);
 #endif
 
-		build_get_ptep(&p, K0, K1);
 		build_update_entries(&p, K0, K1);
 		build_tlb_write_entry(&p, &l, &r, tlb_random);
 		uasm_l_leave(&l, p);
@@ -1993,21 +1993,16 @@ build_r4000_tlbchange_handler_head(u32 **p, struct uasm_label **l,
 	build_get_pgde32(p, wr.r1, wr.r2); /* get pgd in ptr */
 #endif
 
-#ifdef CONFIG_HUGETLB_PAGE
-	/*
-	 * For huge tlb entries, pmd doesn't contain an address but
-	 * instead contains the tlb pte. Check the PAGE_HUGE bit and
-	 * see if we need to jump to huge tlb processing.
-	 */
-	build_is_huge_pte(p, r, wr.r1, wr.r2, label_tlb_huge_update);
-#endif
-
 	UASM_i_MFC0(p, wr.r1, C0_BADVADDR);
 	UASM_i_LW(p, wr.r2, 0, wr.r2);
 	UASM_i_SRL(p, wr.r1, wr.r1, PAGE_SHIFT + PTE_ORDER - PTE_T_LOG2);
 	uasm_i_andi(p, wr.r1, wr.r1, (PTRS_PER_PTE - 1) << PTE_T_LOG2);
 	UASM_i_ADDU(p, wr.r2, wr.r2, wr.r1);
 
+#ifdef CONFIG_HUGETLB_PAGE
+	build_is_huge_pte(p, r, wr.r1, wr.r2, label_tlb_huge_update);
+#endif
+
 #ifdef CONFIG_SMP
 	uasm_l_smp_pgtable_change(l, *p);
 #endif
diff --git a/arch/mips/netlogic/xlp/mmu.c b/arch/mips/netlogic/xlp/mmu.c
index 314aa80..f97aee0 100644
--- a/arch/mips/netlogic/xlp/mmu.c
+++ b/arch/mips/netlogic/xlp/mmu.c
@@ -307,7 +307,12 @@ void __cpuinit mmu_init(void)
                 * shift right half the number of 1s in
                 * the pagemask and populate that value
                 */
-                write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+#ifdef CONFIG_HUGETLB_PAGE
+		write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2))
+		| ((PM_HUGE_MASK >> (13 + (ffz(PM_HUGE_MASK >> 13) / 2))) << 8));
+#else
+		write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+#endif
 
 #ifdef DEBUG
                 printk(KERN_INFO "( %s ): write_c0_config7 = %d\n", __FUNCTION__,
-- 
1.8.4.93.g57e4c17

