From 6dd46bb20b99522bba16541d0e5f88dc9c62e7fb Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Date: Thu, 24 Jun 2010 15:44:32 -0700
Subject: [PATCH 029/565] committing the version of irq.c

This is the version that formed the basis for Henry's changes in the
non-xen branch of linux. However, those changes cause bootup issues
when Linux is booted on top of Xen with or without other domains. Hence
reverting back to the older version till the problem is diagnosed.

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c | 275 +++----------------------------------------
 1 file changed, 17 insertions(+), 258 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 80009b8..a70d61f 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -56,6 +56,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Externs */
 extern void nlm_common_timer_interrupt(struct pt_regs *regs, int irq);
+extern void nlm_common_smp_time_init(void);
 
 extern void *ht_config_base;
 extern int link0, link1;
@@ -64,251 +65,8 @@ struct pic_tmask pic_tmask[PIC_NUM_IRTS];
 __u64 nlm_common_irq_mask;
 DEFINE_SPINLOCK(nlm_common_pic_lock);
 
-void dump_irt_entry(short no)
-{
-	nlm_reg_t reg;
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
-	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(no));
-	printk("%d:\t%d\t%d\t%d\t%d\n",no, reg>>31,(reg>>20)&0x3f, (reg>>16)&0x3, reg&0xffff);
-
-}
-
-void dumpall_irt_entry(void)
-{
-	short i;
-
-	printk("IRT:\tEn\tRVec\tDB\tDTE\n");
-
-	for (i = 0; i < PIC_NUM_IRTS; i++)
-		dump_irt_entry(i);
-}
-
-static unsigned int __maybe_unused pic_startup(unsigned int irq)
-{
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
-	unsigned long flags;
-	nlm_reg_t reg;
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if (irt == -1)	{
-		printk("can't find irt for irq: %d\n",irq);
-		return -1;
-	}
-
-/* 	printk("[%s]: IN irq=%d\n", __func__, irq); */
-
-	spin_lock_irqsave(&nlm_common_pic_lock, flags);
-
-	/* What happens if this irq was previously not ack'ed? 
-	 * Assume, that doesn't happen?
-	 */
-	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
-	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
-	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
-	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg|(1 << 28)|(1 << 31));
-	printk("[%s] Writing IRT reg %ld with IRQ %d\n", __FUNCTION__,irt, irq);
-
-	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-
-	return 0;
-}
-
-static void __maybe_unused pic_unmask(unsigned int irq)
-{
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
-	unsigned long flags;
-	nlm_reg_t reg;
-/* 	printk("%s.%d: IN irq=%d\n", __func__, __LINE__, irq); */
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
-		printk("can't find irt for irq: %d\n",irq);
-		return;
-	}
-
-	spin_lock_irqsave(&nlm_common_pic_lock, flags);
-
-	/* What happens if this irq was previously not ack'ed? 
-	 * Assume, that doesn't happen?
-	 */
-	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
-	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
-	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
-	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg | (1 << 28) | (1 << 31));
-
-	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-
-	return;
-}
-
-static void __maybe_unused pic_ack(unsigned int irq)
-{
-	unsigned long flags;
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
-		printk("can't find irt for irq: %d\n",irq);
-		return;
-	}
-
-	/* If edge triggered IRQ, ack it immediately, else when the device
-	 * interrupt condition is cleared, we may lose interrupts 
-	 */
-	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
-		spin_lock_irqsave(&nlm_common_pic_lock, flags);
-		nlm_hal_ack_pic(irt);
-		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-	}
-}
-
-static void __maybe_unused pic_end(unsigned int irq)
-{
-	unsigned long flags;
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
-		printk("can't find irt for irq: %d\n",irq);
-		return;
-	}
-
-	/* If level triggered, ack it after the device condition is cleared */
-	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
-		spin_lock_irqsave(&nlm_common_pic_lock, flags);
-		nlm_hal_ack_pic(irt);
-		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-	}
-}
-
-static void __maybe_unused pic_shutdown(unsigned int irq)
-{
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
-	unsigned long flags;
-	nlm_reg_t reg;
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
-		printk("can't find irt for irq: %d\n",irq);
-		return;
-	}
-
-	//dbg_msg("IN irq=%d\n", irq);
-
-	spin_lock_irqsave(&nlm_common_pic_lock, flags);
-
-	/* What happens if this irq is currently pending an ack? 
-	 * Assume, that doesn't happen?
-	 */
-	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
-	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), (reg & ~(1 << 31)));
-	printk("[%s] disable IRT %ld with IRQ %d\n", __FUNCTION__,PIC_IRT(irt), irq);
-
-	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-}
-
-static int __maybe_unused pic_set_affinity(unsigned int irq, const struct cpumask *mask)
-{
-#ifdef XLP_MERGE_TODO
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
-#endif
-	unsigned long flags;
-	unsigned long irt;
-
-	irt = find_irt_from_irq(irq);
-	if (irt == -1) {
-		printk("can't find irt for irq: %d\n",irq);
-		return -1;
-	}
-
-	spin_lock_irqsave(&nlm_common_pic_lock, flags);
-#ifdef XLP_MERGE_TODO
-	nlm_hal_write_pic_reg(mmio, PIC_IRT(nlm_hal_irq_to_irt(irq)),(uint32_t) (mask->bits[0]));
-	printk("[%s] Writing IRT reg %d with IRQ %d\n", __FUNCTION__,PIC_IRT(nlm_hal_irq_to_irt(irq)), (nlm_hal_irq_to_irt(irq)));
-#endif
-	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
-
-	return 0;
-}
-
-static struct irq_chip nlm_common_pic __maybe_unused = {
+static struct irq_chip nlm_common_pic = {
 	.name = "XLP-PIC",
-#if 0
-	.unmask = pic_unmask,
-	.mask = pic_shutdown,
-	.ack = pic_ack,
-	.end = pic_end,
-	.set_affinity = pic_set_affinity
-#endif
-};
-
-static void __maybe_unused rsvd_pic_handler_1_1(unsigned int irq)
-{
-	if(irq < PIC_IRQ_BASE)
-		return;
-  dbg_msg("Requesting a reserved irq (%d)??", irq);
-  return;
-}
-
-static void __maybe_unused rsvd_pic_handler_1(unsigned int irq)
-{
-	if(irq < PIC_IRQ_BASE)
-		return;
-  dbg_msg("handler called for a reserved irq (%d)\n", irq);
-}
-
-static int __maybe_unused rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
-{
-	if(irq < PIC_IRQ_BASE)
-		return -1;
-  dbg_msg("handler called for a reserved irq (%d)\n", irq);
-  return 0;
-}
-
-struct irq_chip nlm_common_rsvd_pic_irq_timer = {
-  .name     =          "Count-Compare",
-#if 0
-  .unmask	=          rsvd_pic_handler_1_1,
-  .mask		=          rsvd_pic_handler_1,
-  .ack          =          rsvd_pic_handler_1,
-  .end          =          rsvd_pic_handler_1,
-  .set_affinity =          rsvd_pic_handler_2
-#endif
-};
-
-struct irq_chip nlm_common_rsvd_pic = {
-	.name = "Netlogic-RSVD-PIC",
-#if 0
-	.unmask = rsvd_pic_handler_1_1,
-	.mask = rsvd_pic_handler_1,
-	.ack = rsvd_pic_handler_1,
-	.end = rsvd_pic_handler_1,
-	.set_affinity = rsvd_pic_handler_2
-#endif
-};
-
-static irqreturn_t nlm_common_rsvd_irq_handler(int irq, void *dev_id)
-{
-	if(irq == IRQ_TIMER) 
-		return IRQ_HANDLED;
-  dbg_msg("handler for reserved irq %d\n", irq);
-  return IRQ_NONE;
-}
-
-struct irqaction nlm_common_rsvd_action = {
-	.handler = nlm_common_rsvd_irq_handler,
-	.flags = 0,
-	//.mask = 0,
-	.name = "nlm_common_rsvd_action",
-	.dev_id = 0,
-	.next = 0
 };
 
 void __init init_nlm_common_irqs(void)
@@ -317,26 +75,29 @@ void __init init_nlm_common_irqs(void)
 
 	for (i = 0; i < NR_IRQS; i++) {
 		//set_irq_chip(i, &nlm_common_pic);
+		irq_set_chip_and_handler(i,
+			&nlm_common_pic, handle_level_irq);
+
 	}
 
 #ifdef CONFIG_REMOTE_DEBUG
 	//irq_desc[IRQ_REMOTE_DEBUG].chip = &nlm_common_rsvd_pic;
-	irq_desc[IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
+	//irq_desc[IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
 	nlm_common_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
 #endif
 
 #ifdef CONFIG_SMP
 	//irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &nlm_common_rsvd_pic;
-	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &nlm_common_rsvd_action;
+	//irq_desc[IRQ_IPI_SMP_FUNCTION].action = &nlm_common_rsvd_action;
 
 	//irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &nlm_common_rsvd_pic;
-	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &nlm_common_rsvd_action;
+	//irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &nlm_common_rsvd_action;
 
 #ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
 	/* PR: New IPI added here for netrx balancing */
 	//irq_desc[IRQ_IPI_NETRX].chip = &nlm_common_rsvd_pic;
 	irq_desc[IRQ_IPI_NETRX].action = &nlm_common_rsvd_action;
-	nlm_common_irq_mask |= (1ULL << IRQ_IPI_NETRX);
+	//nlm_common_irq_mask |= (1ULL << IRQ_IPI_NETRX);
 #endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
 
 	nlm_common_irq_mask |=
@@ -345,7 +106,7 @@ void __init init_nlm_common_irqs(void)
 
 	/* msgring interrupt */
 	//irq_desc[IRQ_MSGRING].chip = &nlm_common_rsvd_pic;
-	irq_desc[IRQ_MSGRING].action = &nlm_common_rsvd_action;
+	//irq_desc[IRQ_MSGRING].action = &nlm_common_rsvd_action;
 	nlm_common_irq_mask |= (1ULL << IRQ_MSGRING);
 
 	/* unmask all PIC related interrupts. If no handler is installed by the 
@@ -404,8 +165,15 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 
 void __cpuinit nlm_smp_irq_init(void)
 {
+#ifdef XLP_MERGE_TODO
+	/* Set up kseg0 to be cachable coherent */
+	change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
+#endif
 	/* set interrupt mask for non-zero cpus */
 	write_64bit_cp0_eimr(nlm_common_irq_mask | (1 << IRQ_TIMER));
+#ifdef XLP_MERGE_TODO
+	nlm_common_smp_time_init();
+#endif
 }
 
 /* 
@@ -416,13 +184,6 @@ void __cpuinit nlm_smp_irq_init(void)
 
 struct irq_chip nlm_common_pic_msi = {
 	.name = "Netlogic-PIC-MSI",
-#if 0
-	.startup = pic_startup,
-	.shutdown = pic_shutdown,
-	.ack = pic_ack,
-	.end = pic_end,
-	.set_affinity = pic_set_affinity
-#endif
 };
 
 void destroy_irq(unsigned int irq)
@@ -560,7 +321,6 @@ void __init arch_init_irq(void)
 
 	write_64bit_cp0_eimr(nlm_common_irq_mask);
 
-//	dumpall_irt_entry();
 }
 
 asmlinkage void plat_irq_dispatch(void)
@@ -605,4 +365,3 @@ void pic_setup_threadmask(unsigned int irt, uint32_t mask)
 #endif
 	return;
 }
-
-- 
1.8.4.93.g57e4c17

