From bc4ca324a0a141a340efc601a88b9bf8a0beb55b Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Date: Tue, 25 May 2010 13:31:45 -0700
Subject: [PATCH 023/565] Support for parsing memory ranges

Support for parsing memory ranges.

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/setup.c | 76 +++++++++++++++++++++++++++++++-----------
 1 file changed, 57 insertions(+), 19 deletions(-)

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index f32a465..ea3a1e9 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -120,7 +120,7 @@ extern void *fdt_init(void *blob);
 extern void *simple_alloc_init(char *base, unsigned long heap_size,
 		unsigned long granularity, unsigned long max_allocs);
 
-int onlinemask = 0x1;
+unsigned int onlinemask = 0x1;
 
 /* Struct for temp. allocation
  * of sp/gp for secondary CPUs 
@@ -570,46 +570,84 @@ extern struct plat_smp_ops nlm_smp_ops;
 
 static int fdt_process(void) 
 {
+	int  domain=0;
+	char domstr[32] = "";
+	int  i, na, ns, regs[4], entries;
+
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
 	 */
 	void *blob = (void *)fw_arg0;
 	void *node;
 
-	/* We try to create a region starting
-	 * from (_end + 64K) of size 8MB for
-	 * the FDT structures. The 64K is the
-	 * current page size for XEN
+	/* Create a region starting from
+	 * (_end + 64K) of size 8MB for
+	 * the FDT structures. The 64K is
+	 * the current page size for XEN
 	 */
 	simple_alloc_init((char *)((unsigned long)(&_end)+0x10000),
 			(8<<20), 32, 128);
 
-	/* Create a local copy of the FDT */
+	/* Create a local copy of the FDT 
+	 */
 	fdt = fdt_init(blob);
 
-	/* Grab the bitmask of CPUs to 
-	 * bring online, from the FDT
+	/* extract cmdline params
 	 */
-	node = finddevice("/cpus");
+	node = finddevice("/chosen");
 	if (node) {
-		if (getprop(node, "onlinemask", &onlinemask, 
-					sizeof(onlinemask)) < 0)
+		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
 			return -1;
+		strcat(arcs_cmdline, prop_buf);
+	}
+	
+	/* extract memory ranges,
+	 * add to command line
+	 */
+	node = finddevice("/doms/dom@0");
+	if (node) {
+		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
+			na = 1;
+		if (na < 1 || na > 2)
+			printk("Can't cope with #address-cells == %d.\n\r", na);
+		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
+			ns = 1;
+		if (ns < 1 || ns > 2)
+			printk("Can't cope with #size-cells == %d.\n\r", ns);
 	}
-	if (!onlinemask) 
-		onlinemask = 0x1;
 
-	/* extract bootloader-passed
-	 * cmdline params
+	node = finddevice("/doms/dom@0/memory");
+	if (node) {
+		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
+		if (!entries || (entries % (na+ns)))
+			printk("Invalid Memory Map Specified!\n");
+		
+		for (i=0; i<entries; i+=2) {
+			sprintf(domstr, " mem=%dm@%dm ", 
+					(regs[i+1]>>20), (regs[i]>>20));
+			strcat(arcs_cmdline, domstr);
+			memset((void *)&domstr, '\0', sizeof(domstr));
+		}
+	}
+		
+	printk("FDT Cmdline: %s\n", arcs_cmdline);
+
+	/* extract CPU online mask for 
+	 * domain 0 (linux)
 	 */
-	node = finddevice("/chosen");
+	sprintf(domstr, "/doms/dom@%d/cpu", domain);
+
+	node = finddevice(domstr);
 	if (node) {
-		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+		if (getprop(node, "onlinemask", &onlinemask, 
+					sizeof(onlinemask)) < 0) 
 			return -1;
-		printk("Firmware Cmdline: %s\n", prop_buf);
-		strcat(arcs_cmdline, prop_buf);
 	}
 
+	if (!onlinemask) 
+		/* something went wrong ? */
+		onlinemask = 0x1;
+
 	return 0;
 }
 
-- 
1.8.4.93.g57e4c17

