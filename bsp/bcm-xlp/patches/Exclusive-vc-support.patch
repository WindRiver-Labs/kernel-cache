From 47825abe029b0440f1300b91c45fbea98c643117 Mon Sep 17 00:00:00 2001
From: Hareesh Ramachandran <hareesh@salton.(none)>
Date: Tue, 13 Dec 2011 06:00:45 -0800
Subject: [PATCH 312/565] Exclusive vc support

Exclusive vc support in msgring interrupt handler

Based on Broadcom SDK 2.3.

Signed-off-by: Hareesh Ramachandran <hareesh@salton.(none)>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/Kconfig       |  5 +++++
 arch/mips/netlogic/xlp/on_chip.c | 31 +++++++++++++++++++++++++++++++
 2 files changed, 36 insertions(+)

diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 3a90704..db4c5bc 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -246,3 +246,8 @@ config NLM_NET_OPTS
        bool "Enable Network Optimization (memcpy/memset)"
        depends on NLM_XLP && 64BIT
        default n
+
+config NLM_EXCL_VC_NAPI_HANDLER_SUPPORT
+       bool "Exclusive VC handler , where napi is done in the application code"
+       depends on NLM_XLP && 64BIT
+       default n
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index cd16728..a04f2b3 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -61,6 +61,9 @@ uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
 
 uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
 
+typedef void (*vchandler)(int vc);
+static vchandler xlp_vc_handlers[NLM_MAX_VC_PER_THREAD];
+
 /* make this a read/write spinlock */
 spinlock_t msgrng_lock;
 static nlm_common_atomic_t msgring_registered;
@@ -215,6 +218,27 @@ struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
 	[0 ... (XLP_MSG_HANDLE_MAX-1)] = {dummy_handler, NULL},
 };
 
+
+int nlm_xlp_register_vc_handler(int vc, void (*handler)(int vc))
+{
+	int i;
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("Invalid VC Passed %d\n", vc);
+		return -1;
+	}
+	xlp_vc_handlers[vc] = handler;
+
+	for(i=0; i<NR_CPUS; i++){
+		if(!cpu_isset(i, cpu_present_map))
+			continue;
+		nlm_hal_enable_vc_intr(0, i*NLM_MAX_VC_PER_THREAD + vc);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_vc_handler);
+
+
 /*********************************************************************
  * nlm_xlp_msgring_int_handler 
  *
@@ -256,6 +280,12 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		/* Read latest VC empty mask */
 		msg_status1 = xlp_read_status1();
 
+#ifdef CONFIG_NLM_EXCL_VC_NAPI_HANDLER_SUPPORT
+		for(vc = 0; vc < 4; vc++) {
+			if(xlp_vc_handlers[vc])
+				(xlp_vc_handlers)[vc](vc);
+		}
+#else
 		if((~(msg_status1>>24) & napi_vc_mask) && xlp_fmn_init_done) {
 			struct napi_struct *napi;
 
@@ -264,6 +294,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		        napi_schedule(napi);
 			pop_vc_mask = pop_vc_mask & ~napi_vc_mask;
 		}
+#endif
 
 		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
 		if (vc_empty_status == pop_vc_mask) break;  
-- 
1.8.4.93.g57e4c17

