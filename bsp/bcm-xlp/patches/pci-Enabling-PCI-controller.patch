From ba6223bd2740fc32e62e652d2555998050d793f6 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Wed, 8 Aug 2012 09:46:26 -0700
Subject: [PATCH 389/565] pci: Enabling PCI controller

This patch enables XLP's PCI controllers. Only supported mode of interrupt
is INTX. Some basic support for Multi node is included, but this feature
is not complete in this patch.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp_irq.h |   8 +
 arch/mips/netlogic/Kconfig               |   7 +-
 arch/mips/pci/pci-xlp.c                  | 661 +++++++++++++++++++++++++++++++
 3 files changed, 673 insertions(+), 3 deletions(-)
 create mode 100644 arch/mips/pci/pci-xlp.c

diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index aad99a5..3f1a09cf 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -47,6 +47,8 @@ void __nlh_pic_w64o(u8 nid, u64 offset, u64 val);
 extern u64 __nlh_pci_r64o(u8, u64);
 extern void __nlh_pci_w64o(u8, u64, u64);
 extern void xlp_ack_pic(u8, int);
+int xlp_intx_enable(u8 node, int fn);
+int xlp_intx_disable(u8 node, int fn);
 
 #if !defined CONFIG_XLP_REPLACE_R4K_TIMER
 void nlm_hal_pic_update_control(u64);
@@ -104,6 +106,12 @@ struct xlp_ip {
 	u32 valid;	/* can have at most 3 least significant bits set */
 };
 
+struct xlp_nodefn_struct {
+	/* Structure to distinguish the controller function */
+	u8 node;
+	u8 fn;
+};
+
 #define xlp_incr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, 1)
 #define xlp_decr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, -1)
 
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 1c701cf..b1cb565 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -157,8 +157,9 @@ config NLM_EXCL_VC_NAPI_HANDLER_SUPPORT
        depends on NLM_XLP && 64BIT
        default n
 
+# PCI_XLP is a non selectable value used only to compile PCI controller support
+# implemented in arch/mips/pci/pci-xlp.c
 config PCI_XLP
-	bool "Enable PCI support on XLP"
+	bool
 	depends on NLM_XLP && PCI
-	default n
-
+	default y
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
new file mode 100644
index 0000000..0f8982f
--- /dev/null
+++ b/arch/mips/pci/pci-xlp.c
@@ -0,0 +1,661 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+/*
+ * This file contains specific functions for XLP chipsets and
+ * EVP boards.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+#include <asm/io.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/io.h>
+#include <asm/netlogic/iomap.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/pic_hal.h>
+#include <asm/netlogic/pci_hal.h>
+
+static int pci_probe_only;
+static void *pci_config_base;
+static const volatile void *pci_io_base;
+
+u64 xlp_syscfg_base[NLM_MAX_CPU_NODE] = { XLP_BDF_BASE(0,6,5),
+	XLP_BDF_BASE(0,14,5), XLP_BDF_BASE(0,22,5), XLP_BDF_BASE(0,30,5) };
+/*
+ * Possible values are no more hard coded.
+ * For mapping of these values to IRT, refer
+ * arch/mips/netlogic/xlp/irq.c
+ *
+ * Here a table is defined to figure out the interrupt assignments to different
+ * cards placed on any of the 4 PCI slots.
+ *
+ * We have some unique problems here.
+ * 1. Board could be configured in different lane widths. That means, the cards
+ * could be controlled by different functions of the controller on board
+ * Eg. 2x8 config can have two cards (fn 0 and fn 2)
+ *	4x4 config can also have two cards (under fn0 through fn 3)
+ * 2. Cards can be placed on any available slot
+ * 3. The card can have a switch built in, thus giving rise to multiple devices
+ * on the slot.
+ * 4. All these problems can occur on four different nodes.
+ *
+ * So, it is important to figure out the lanes and nodes on which cards are
+ * placed.  First we read the lane config from POWER_ON_RESET_CFG on each node
+ * Then each line's LTSSM state would give the card presence
+ * Based on that we have to assign interrupt values; while keeping the
+ * possibility of same interrupt assigned to multiple devices open.
+ *
+ * So, we have a map: XLP irq map is as follows (on node 0, but similar for any
+ * node
+ *  \fn 0	1	2	3
+ *plc\
+ * 0	86	0	88	89
+ * 1	86	87	88	0
+ * 2	86	0	88	89
+ * 3	86	87	88	89
+ * This map can differ among different versions of processors. Check PRM or RTL
+ * because the values are a function of XLP_PCIE_LINK_IRT_OFFSET. To make them
+ * somewhat independent, I have defined macros and used them here.
+ *
+ * This map is dynamically populated based on card presence in the slot.
+ * If a card is present, and is a switch, then the secondary and subordinate
+ * numbers would be different. Based on this fact, we can figure out from
+ * pci_dev structure the slot where a card is placed at run time.
+ */
+
+/* There are 4 PCI lane config modes for every node.
+ * 0:	2x8 lanes (ctrl 0, 2)
+ * 1:	2x4 lanes (ctrl 0, 2), 1x8 lanes (ctrl 1)
+ * 2:	1x8 lanes (ctrl 0), 2x4 lanes (ctrl 2, 3)
+ * 3:	4x4 lanes (all ctrls 4 lanes)
+ * PRM 31.11.7.2 (power on reset config register)
+ */
+#define XLP_PCI_LANE_CONFIG	4
+
+struct xlp_link_struct {
+	int intno;
+	int sec;
+	int sub;
+};
+
+struct xlp_plc_fn_struct {
+	int plc;
+	struct xlp_link_struct farray[XLP_MAX_SLOTS];
+};
+
+static struct xlp_plc_fn_struct
+	node_irqmap[NLM_MAX_CPU_NODE][XLP_PCI_LANE_CONFIG] = {
+{
+	{0, {{XLP_PCIE_LINK_IRQ(0,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(0,2), 0, 0}, {0, 0, 0}}},
+	{1, {{XLP_PCIE_LINK_IRQ(0,0), 0, 0}, {XLP_PCIE_LINK_IRQ(0,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(0,2), 0, 0}, {0, 0, 0}}},
+	{2, {{XLP_PCIE_LINK_IRQ(0,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(0,2), 0, 0}, {XLP_PCIE_LINK_IRQ(0,3),0,0}}},
+	{3, {{XLP_PCIE_LINK_IRQ(0,0), 0, 0}, {XLP_PCIE_LINK_IRQ(0,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(0,2), 0, 0}, {XLP_PCIE_LINK_IRQ(0,3),0,0}}},
+}, {
+	{0, {{XLP_PCIE_LINK_IRQ(1,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(1,2), 0, 0}, {0, 0, 0}}},
+	{1, {{XLP_PCIE_LINK_IRQ(1,0), 0, 0}, {XLP_PCIE_LINK_IRQ(1,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(1,2), 0, 0}, {0, 0, 0}}},
+	{2, {{XLP_PCIE_LINK_IRQ(1,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(1,2), 0, 0}, {XLP_PCIE_LINK_IRQ(1,3),0,0}}},
+	{3, {{XLP_PCIE_LINK_IRQ(1,0), 0, 0}, {XLP_PCIE_LINK_IRQ(1,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(1,2), 0, 0}, {XLP_PCIE_LINK_IRQ(1,3),0,0}}},
+}, {
+	{0, {{XLP_PCIE_LINK_IRQ(2,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(2,2), 0, 0}, {0, 0, 0}}},
+	{1, {{XLP_PCIE_LINK_IRQ(2,0), 0, 0}, {XLP_PCIE_LINK_IRQ(2,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(2,2), 0, 0}, {0, 0, 0}}},
+	{2, {{XLP_PCIE_LINK_IRQ(2,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(2,2), 0, 0}, {XLP_PCIE_LINK_IRQ(2,3),0,0}}},
+	{3, {{XLP_PCIE_LINK_IRQ(2,0), 0, 0}, {XLP_PCIE_LINK_IRQ(2,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(2,2), 0, 0}, {XLP_PCIE_LINK_IRQ(2,3),0,0}}},
+}, {
+	{0, {{XLP_PCIE_LINK_IRQ(3,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(3,2), 0, 0}, {0, 0, 0}}},
+	{1, {{XLP_PCIE_LINK_IRQ(3,0), 0, 0}, {XLP_PCIE_LINK_IRQ(3,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(3,2), 0, 0}, {0, 0, 0}}},
+	{2, {{XLP_PCIE_LINK_IRQ(3,0), 0, 0}, {0, 0, 0},
+		{XLP_PCIE_LINK_IRQ(3,2), 0, 0}, {XLP_PCIE_LINK_IRQ(3,3),0,0}}},
+	{3, {{XLP_PCIE_LINK_IRQ(3,0), 0, 0}, {XLP_PCIE_LINK_IRQ(3,1), 0, 0},
+		{XLP_PCIE_LINK_IRQ(3,2), 0, 0}, {XLP_PCIE_LINK_IRQ(3,3),0,0}}},
+}
+};
+
+void dump_node_irqmap(u8 node, u32 plc)
+{
+	struct xlp_plc_fn_struct *p = &node_irqmap[node][plc];
+	u8 idx;
+
+	printk(KERN_WARNING "node_irqmap[%d][%d] PLC %d\n", node, plc, p->plc);
+	for (idx = 0; idx < XLP_MAX_SLOTS; idx++) {
+		printk("p->farray[%d] : int %d, sec %d, sub %d\n",idx,
+		p->farray[idx].intno, p->farray[idx].sec, p->farray[idx].sub);
+	}
+	return;
+}
+
+
+/* Just a helper function to fill up xlp_irq_map table's entries
+ * This function checks whether a PCIe slot is populated and if yes,
+ * fills up the table with subordinate and secondary bus numbers. These
+ * numbers would be different only if the PCIe device has a switch inside.
+ */
+static int xlp_map_helper(u8 node, int row, int fn)
+{
+	u32 reg6, ltssm;
+
+	ltssm = nlh_pci_r32r(node, fn,  0x25E);
+	if (ltssm != 0x00446000) {
+		printk(KERN_WARNING "LTSSM state is %#x. Fn %x link not up\n",
+				ltssm, fn);
+		return -ENODEV;
+	}
+	reg6 = nlh_pci_r32r(node, fn,  0x6);
+	node_irqmap[node][row].farray[fn].sec = (reg6 >> 8) & 0xff;
+	node_irqmap[node][row].farray[fn].sub = (reg6 >> 16) & 0xff;
+	return 0;
+}
+
+/*
+ * Iterates over buses to find out the slot (thus pci controller fn)
+ */
+int xlp_ctrl_fn_from_dev(const struct pci_dev *dev, struct xlp_nodefn_struct *n)
+{
+	__label__ out;
+	int row = 0, fn = 0, node;
+
+	for_each_online_node(node){
+		row = 0;
+		while (row < XLP_MAX_SLOTS) {
+			fn = 0;
+			while (fn < XLP_MAX_SLOTS) {
+				if ((dev->bus->number >= node_irqmap[node][row].farray[fn].sec)
+				&&(dev->bus->number <= node_irqmap[node][row].farray[fn].sub)){
+					goto out; /* No `break', note two loops */;
+				}
+				fn++;
+			}
+			row++;
+		}
+	}
+out:
+	if (fn >= 4) {
+		return -ENODEV;
+	}
+	n->node = node;
+	n->fn = fn;
+	return 0;
+}
+
+/*
+ * Controller is initialized and explicity disabled
+ *
+ * @fn : controller function no.
+ */
+void xlp_pcie_controller_setup(u8 node, int fn)
+{
+	u32 reg;
+
+#if defined CONFIG_PCI_MSI
+	xlp_msi_controller_init(node, fn);
+#endif
+	//xlp_msix_disable(fn);
+	//xlp_msi_disable(fn, 0xf);
+	/* By default, leave INTX enabled */
+	xlp_intx_enable(node, fn);
+
+	//enable timeout to void system hang, when there is no device on slot
+	reg=nlh_pci_r32r(node, fn,  0x240);
+	nlh_pci_w32r(node, fn, 0x240, reg | (3<<23) );
+	nlh_pci_w32r(node, fn, 0x244, 25*1000*1000);	//0.1 second delay, 250MHz clock
+	nlh_pci_w32r(node, fn, 0x245, 25*1000*1000);
+}
+
+/*
+ * Utility function to get syscfg
+ *
+ * @node : node id in multi chip config
+ */
+u32 xlp_get_power_on_reset_cfg(int node)
+{
+	return nlm_hal_read_32bit_reg(xlp_syscfg_base[node], 0x41);
+}
+EXPORT_SYMBOL(xlp_get_power_on_reset_cfg);
+
+
+/*
+ * Called from system startup routine
+ */
+static void pcie_controller_init_done(void)
+{
+	u32 plc, syscfg, mode, count = 0, node = 0;
+
+#if defined CONFIG_PCI_MSI
+#ifndef CONFIG_XLP_MSI_ADDRESSES
+	/* The controller will never read from /write to this area.
+	 * Strictly speaking this allocation is not necessary.
+	 * But if we don't allocate, we will have to keep in different
+	 * processors/boards a range of address which is not used anywhere else
+	 * like physical mem, pci mem ..etc. It is just easier to allocate
+	 * some memory and not use it for anything else.  */
+#ifdef CONFIG_32BIT
+	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL, get_order(0x100000));
+#else
+	/* We don't need 16M, all we need is 2 pages per controller
+	 * => 2 * 4ctr * 4 nodes pages */
+	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL,
+			get_order(0x1000000));
+#endif
+	if (XLP_MSI_ADDR == 0) {
+		printk(KERN_ERR "Failed to get memory for MSI/MSI-X tables\n");
+	}
+#endif
+#endif
+	if (!pci_probe_only){
+		printk(KERN_WARNING "PCIe bus IRQs configured incorrectly\n");
+		return;
+	}
+	for_each_online_node(node) {
+	syscfg = xlp_get_power_on_reset_cfg(node);
+	/* We don't manipulate pci_address space.
+	 * Get the link status from pcie lane config from 34.9.7.2 XLP PRM */
+	mode = (syscfg >> 19) & 0xf;
+	while (count < 4) {
+		printk(KERN_DEBUG "Controller %d is in %s mode\n",
+				count, (mode & (1 << count)) ? "RC" : "EP");
+		count++;
+	}
+	plc = (syscfg >> 23) & 0x3;
+	printk(KERN_DEBUG "node %d, PLC = %#x, mode = %#x\n", node, plc, mode);
+
+	switch (plc) {
+	/* The correlation between plc and lane config is very specific to XLP
+	 * and not very clear in PRM
+	 */
+	case 0:
+		/* controller 0 and 2 are active with 8lanes each */
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x4) {
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		break;
+	case 1:
+		/* controllers 0,1 and 2 are active */
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x2){
+			xlp_map_helper(node, plc, 1);
+			xlp_pcie_controller_setup(node, 1);
+		}
+		if (mode & 0x4){
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		break;
+	case 2:
+		/* controllers 0,2 and 3 are active */
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x4){
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		if (mode & 0x8){
+			xlp_map_helper(node, plc, 3);
+			xlp_pcie_controller_setup(node, 3);
+		}
+		break;
+	case 3:
+		/* All four controllers are active with 4 lanes each */
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x2){
+			xlp_map_helper(node, plc, 1);
+			xlp_pcie_controller_setup(node, 1);
+		}
+		if (mode & 0x4){
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		if (mode & 0x8){
+			xlp_map_helper(node, plc, 3);
+			xlp_pcie_controller_setup(node, 3);
+		}
+		break;
+	}
+	dump_node_irqmap(node, plc);
+	printk(KERN_DEBUG "[%s]: PCIE Controller initialization done\n", __FUNCTION__);
+	}	/* for_each_online_node */
+	return;
+}
+
+static inline __u32 pci_cfg_read_32bit(__u32 addr)
+{
+	__u32 temp = 0;
+	__u32 *p = (__u32 *) (pci_config_base + (addr & ~3));
+
+	temp = *p;
+
+	return temp;
+}
+
+static inline void pci_cfg_write_32bit(__u32 addr, __u32 data)
+{
+        unsigned int *p = (unsigned int *)(pci_config_base + (addr & ~3));
+
+	*p = data;
+}
+
+static int pci_bus_status = 0;
+//#define pci_cfg_offset(bus, devfn, where) (((bus)<<16)+((devfn)<<8)+(where))  //for PCI config space
+#define pci_cfg_offset(bus, devfn, where) (((bus)<<20)+((devfn)<<12)+(where))	//for PCIE config space
+#define pci_cfg_addr(bus, devfn, where) pci_cfg_offset((bus)->number,(devfn),where)
+
+static int xlp_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 * val)
+{
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (pci_bus_status)
+		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int xlp_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 val)
+{
+	__u32 cfgaddr = pci_cfg_offset((bus->number), devfn, where);
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!pci_bus_status)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else
+		data = val;
+
+	pci_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops xlp_pci_ops = {
+	.read  = xlp_pcibios_read,
+	.write = xlp_pcibios_write
+};
+
+/*
+ * XLP PCIE Controller
+ */
+#define DEFAULT_XLP_PCI_ECONFIG_BASE	(0x18000000ULL)
+#define DEFAULT_XLP_PCI_ECONFIG_SIZE	(32 << 20)
+#define DEFAULT_XLP_PCI_CONFIG_BASE	(0x1c000000ULL)
+#define DEFAULT_XLP_PCI_CONFIG_SIZE	(32 << 20)
+static struct resource xlp_mem_resource = {
+	.name           = "XLP PCI MEM",
+	.start          = 0xd0000000ULL,          /* 256MB PCI mem @ 0xd000_0000 */
+	.end            = 0xdfffffffULL,
+	.flags          = IORESOURCE_MEM,
+};
+static struct resource xlp_io_resource = {
+	.name           = "XLP IO MEM",
+	.start          = 0x14000000UL,         /* 32MB PCI IO @ 0x1400_0000 */
+	.end            = 0x15ffffffUL,
+	.flags          = IORESOURCE_IO,
+};
+struct pci_controller xlp_controller = {
+	.index          = 0,
+	.pci_ops        = &xlp_pci_ops,
+	.mem_resource   = &xlp_mem_resource,
+	.io_resource    = &xlp_io_resource,
+	.io_offset      = 0x00000000UL,
+	.mem_offset     = 0x00000000UL
+};
+
+/*
+ * This function is called for all pci controller functions
+ * viz. 0:1.0, 0:1.1, 0:1.2 and 0:1.3, 0:9.X, 0:17.X and 0:25.X
+ * In fact, we need not assign them any interrupt because they are not
+ * interrupt generating devices.
+ * But for any devices connected on these controllers, consult the populated
+ * table and return corresponding interrupt.
+ */
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int row = 0;
+	u8 node = 0;
+	struct xlp_nodefn_struct nfn;
+
+	if (xlp_ctrl_fn_from_dev(dev, &nfn) != 0) {
+		dev_printk(KERN_ERR, &dev->dev, "Could not resolve device to a node/bus pair\n");
+		return 0;
+	}
+	row = (xlp_get_power_on_reset_cfg(nfn.node) >> 23) & 0x3;
+	dev_printk(KERN_DEBUG, &dev->dev, "Assigning interrupt %#x\n", node_irqmap[nfn.node][row].farray[nfn.fn].intno);
+	return node_irqmap[nfn.node][row].farray[nfn.fn].intno;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+        return 0;
+}
+
+/* Enabled by default */
+static int __initdata xlp_nopci = 0;
+
+static int __init xlp_nopci_setup(char *str)
+{
+	/* Disable PCI/X/E; disables HT also */
+	xlp_nopci = 1;
+
+	return 1;
+}
+__setup("xlp_nopci", xlp_nopci_setup);
+
+static int __init pcibios_init(void)
+{
+	unsigned long phys = 0;
+	unsigned long size = 0;
+
+	if (xlp_nopci) return 0;
+
+	/* Firmware assigns PCI resources */
+	pci_set_flags(PCI_PROBE_ONLY);
+	pci_probe_only = 1;
+
+	/* Map the PCIX CFG space */
+	pci_config_base = ioremap(DEFAULT_XLP_PCI_ECONFIG_BASE, DEFAULT_XLP_PCI_CONFIG_SIZE);
+	if (!pci_config_base) {
+		printk(KERN_ERR "Unable to map PCI config space!\n");
+		return 1;
+	}
+
+	phys = xlp_io_resource.start;
+	size = xlp_io_resource.end - xlp_io_resource.start + 1;
+
+	pci_io_base = ioremap(phys, size);
+	if (!pci_io_base) {
+		printk(KERN_WARNING "[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+		       __FUNCTION__, phys, size);
+		/* Eventually this is going to panic() */
+	}
+	else {
+		printk(KERN_DEBUG "[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+		       __FUNCTION__, phys, size, pci_io_base);
+	}
+	set_io_port_base((unsigned long) pci_io_base);
+	xlp_controller.io_map_base = (unsigned long) pci_io_base;
+	xlp_controller.io_map_base -= xlp_controller.io_offset;
+
+	/* IO Range for 16MB from where the MEM Range Ends */
+	ioport_resource.start =  0;
+	ioport_resource.end   = ~0;
+
+	printk(KERN_DEBUG "Registering XLP PCIE Controller. \n");
+	/* Setting up controller specific data */
+	pcie_controller_init_done();
+	register_pci_controller(&xlp_controller);
+
+	pci_bus_status = 1;
+	return 0;
+}
+
+arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
+
+
+/*
+ * some ide specific io routines on PCI
+ */
+#define pci_ide_phys_to_virt(x) (((x) - (xlp_io_resource.start)) + (unsigned long)pci_io_base )
+
+inline void nlm_ide_mm_insw(unsigned long port, void *addr, u32 count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u16 *)addr = (readw((const volatile void *)v_port));
+		addr += 2;
+	}
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_insw);
+
+inline void nlm_ide_mm_insl(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		*(u32 *)addr = readl((const volatile void *) v_port);
+		addr += 4;
+	}
+}
+EXPORT_SYMBOL(nlm_ide_mm_insl);
+
+inline void nlm_ide_mm_outsw(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		writew(*(u16 *)addr, (volatile void *)v_port);
+		addr += 2;
+	}
+}
+EXPORT_SYMBOL(nlm_ide_mm_outsw);
+
+inline void nlm_ide_mm_outsl(unsigned long port, void *addr, unsigned int count)
+{
+	unsigned long v_port = pci_ide_phys_to_virt(port);
+	while (count--) {
+		writel(*(u32 *)addr, (volatile void *)v_port);
+		addr += 4;
+	}
+}
+EXPORT_SYMBOL(nlm_ide_mm_outsl);
+
+u8 nlm_ide_mm_inb (unsigned long port)
+{
+	return((u8)readb((const volatile void *)pci_ide_phys_to_virt(port)));
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_inb);
+u16 nlm_ide_mm_inw (unsigned long port)
+{
+	return ((u16) (readw((const volatile void *)pci_ide_phys_to_virt(port))));
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_inw);
+/* Not part of hwif anymore; remove static declaration */
+u32 nlm_ide_mm_inl (unsigned long port)
+{
+	return ((u32)readl((const volatile void *)pci_ide_phys_to_virt(port)));
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_inl);
+void nlm_ide_mm_outb (u8 value, unsigned long port)
+{
+	writeb(value, (volatile void *)pci_ide_phys_to_virt(port));
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_outb);
+void nlm_ide_mm_outw (u16 value, unsigned long port)
+{
+	writew(value, (volatile void *)pci_ide_phys_to_virt((u64)port));
+}
+
+EXPORT_SYMBOL(nlm_ide_mm_outw);
+/* Not part of hwif anymore; remove static declaration */
+void nlm_ide_mm_outl (u32 value, unsigned long port)
+{
+	writel((value), (volatile void *)pci_ide_phys_to_virt(port));
+}
+EXPORT_SYMBOL(nlm_ide_mm_outl);
-- 
1.8.4.93.g57e4c17

