From 6aff016a9dbf1e53aed9c6bae9e1ba8a467d6b36 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Mon, 4 Feb 2013 10:43:57 -0800
Subject: [PATCH 460/565] errata: software workaround for erroneous ade
 exception in XLP2XX Ax

  o In XLP2XX Ax chips, erroneous ade exception may happen for
    indirect branch prediction (jr/jalr instructions).
  o This workaround tries to detect whether a particular ade exception
    in XLP2XX Ax is fake or not. If it is fake, exception will
    be ignored and epc instruction will be re-executed.

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/stackframe.h | 11 +++++
 arch/mips/kernel/unaligned.c       | 99 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 110 insertions(+)

diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 236148c..2a2be4b 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -246,6 +246,17 @@
 		SAVE_AT
 		SAVE_TEMP
 		SAVE_STATIC
+#ifdef CONFIG_NLM_XLP
+		/* Workaround for XLP2XX A0/A1 fake ade errors */
+		LONG_L  v0, PT_CAUSE(sp)
+		srl     v0, v0, 2
+		andi    v0, v0, 0x1f
+		xori    v0, v0, 0x4
+		bnez    v0, 10f
+		move    a0, sp
+		jal     xlp_check_ade_errata
+		10:
+#endif
 		.endm
 
 		.macro	RESTORE_AT
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index 2fb7fbc..83fdaaf 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -89,6 +89,10 @@
 #include <asm/uaccess.h>
 #include <asm/fpu.h>
 #include <asm/fpu_emulator.h>
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#endif
 
 #define STR(x)	__STR(x)
 #define __STR(x)  #x
@@ -1557,6 +1561,12 @@ asmlinkage void do_ade(struct pt_regs *regs)
 	unsigned int __user *pc;
 	mm_segment_t seg;
 
+#ifdef CONFIG_NLM_XLP
+	/* check whether it is a fake ade, retry the same insn if it is */
+	if (regs->fake_ade)
+		return;
+#endif
+
 	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,
 			1, regs, regs->cp0_badvaddr);
 	/*
@@ -1662,3 +1672,92 @@ static int __init debugfs_unaligned(void)
 }
 __initcall(debugfs_unaligned);
 #endif
+
+#ifdef CONFIG_NLM_XLP
+asmlinkage void xlp_check_ade_errata(struct pt_regs *regs)
+{
+	/* When this function is called, interrupt is disabled, and
+	 * the exception is adel.
+	 */
+	unsigned long s_entryhi;
+	unsigned int  s_index;
+	int i, wired;
+
+	/* default, not a fake ade */
+	regs->fake_ade = 0;
+
+	/* The errata only applies to XLP2XX Ax */
+	if (!is_nlm_xlp2xx() || (read_c0_prid() & 0xff) >= 0x2)
+		return;
+
+	/* insn fetch: epc is the same as badvaddr */
+	if (regs->cp0_epc != regs->cp0_badvaddr)
+		return;
+
+	/* is this a real unaligned insn fetching? */
+	if (regs->cp0_epc & 0x3)
+		return;
+
+	/* permission checking */
+	if (((regs->cp0_status >> 3) & 0x3) == 2) {
+		/* user mode */
+		if (regs->cp0_badvaddr < 0x80000000ULL) {
+			; /* kuseg: always legal */
+		} else if (regs->cp0_badvaddr < 0x4000000000000000ULL) {
+			/* xkuseg */
+			if (((regs->cp0_status >> 5) & 0x1) == 0)
+				return; /* status.UX not set */
+		} else
+			return; /* non user segments */
+	} else if (((regs->cp0_status >> 3) & 0x3) == 0) {
+		/* kernel mode: kernel will die in normal case.
+		 * So let us print out some information and ignore. If it
+		 * is a real ade, it will be retriggered and then further debug
+		 * can be done.
+		 */
+		printk("Warning: Hit a kernel ADEL exception (badvaddr 0x%lx), ignored\n",
+			regs->cp0_badvaddr);
+		regs->fake_ade = 1;
+		return;
+	} else
+		return; /* supervisor mode, not used */
+
+	/* tlb testing, it is fake ade unless there is a tlb translation entry
+	 * and the CCA bit is illegal.
+	 */
+	regs->fake_ade = 1;
+
+	wired = read_c0_wired();
+	s_entryhi = read_c0_entryhi();
+	s_index = read_c0_index();
+
+	for (i = wired; i < current_cpu_data.tlbsize; i++) {
+		unsigned long entryhi;
+		unsigned long long entrylo;
+		int v, cca;
+
+		write_c0_index(i);
+		tlb_read();
+		entryhi  = read_c0_entryhi() & (PAGE_MASK << 1);
+		if (entryhi == (regs->cp0_badvaddr & (PAGE_MASK << 1))) {
+			if ((regs->cp0_badvaddr >> PAGE_SHIFT) & 0x1)
+				entrylo = read_c0_entrylo1();
+			else
+				entrylo = read_c0_entrylo0();
+
+			v = (entrylo >> 1) & 0x1;
+			cca = (entrylo >> 3) & 0x7;
+
+			if (v == 1 && (cca == 0 || cca == 1 || cca == 7)) {
+				regs->fake_ade = 0;
+				break;
+			}
+		}
+	}
+
+	write_c0_entryhi(s_entryhi);
+	write_c0_index(s_index);
+
+	return;
+}
+#endif
-- 
1.8.4.93.g57e4c17

