From dfce55639323427ee3375c68329ea8032286b115 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Fri, 13 Aug 2010 21:11:23 +0530
Subject: [PATCH 093/565] Fix for mmap

Move address change checks to arch/cpu specific functions.

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/ioremap.h | 41 +++++++++++++++++++++++++++
 arch/mips/netlogic/common/memory.c            | 12 ++++++++
 arch/mips/netlogic/xlp/setup.c                | 41 ++++++++-------------------
 3 files changed, 65 insertions(+), 29 deletions(-)
 create mode 100644 arch/mips/include/asm/mach-netlogic/ioremap.h

diff --git a/arch/mips/include/asm/mach-netlogic/ioremap.h b/arch/mips/include/asm/mach-netlogic/ioremap.h
new file mode 100644
index 0000000..d98eb20
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/ioremap.h
@@ -0,0 +1,41 @@
+/*
+ *	include/asm-mips/mach-generic/ioremap.h
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MACH_GENERIC_IOREMAP_H
+#define __ASM_MACH_GENERIC_IOREMAP_H
+
+#include <linux/types.h>
+
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+
+#define NETLOGIC_UNCACHED_START 0x10000000UL
+#define NETLOGIC_UNCACHED_END 0x20000000UL
+
+extern inline int valid_phys_addr_range(unsigned long addr, size_t count);
+extern inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+/*
+ * Allow physical addresses to be fixed up to help peripherals located
+ * outside the low 32-bit range -- generic pass-through version.
+ */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+
+static inline void __iomem *plat_ioremap(phys_t offset, unsigned long size,
+	unsigned long flags)
+{
+	return NULL;
+}
+
+static inline int plat_iounmap(const volatile void __iomem *addr)
+{
+	return 0;
+}
+
+#endif /* __ASM_MACH_GENERIC_IOREMAP_H */
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index 654fa7f..9c19b32 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -206,3 +206,15 @@ int __uncached_access(struct file *file, unsigned long addr)
 	   cached page for memory space. */
 	return nlm_common_get_pgprot(addr);
 }
+
+inline int valid_phys_addr_range(unsigned long addr, size_t count)
+{
+	/* for now return valid */
+	return 1;
+}
+
+inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size) 
+{
+	/* for now return valid */
+	return 1;
+}
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 077c2e8..deccd7a 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -227,38 +227,21 @@ static char *get_psb_physmap_name(int type)
 	}
 	return ("Unknown type");
 }
-
+/* Return value
+ * 	1 ==> IO (or not found)
+ *  0 ==> mem 
+ */
 int nlm_common_get_pgprot(unsigned long address)
 {
-	int i;
-	__u64 start=0, end=0;
-	char *name = NULL;
-
-	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
-		start = boot_physaddr_info.map[i].addr;
-		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
-		if ((address >= start) && (address < end)) {
-			name = get_psb_physmap_name(boot_physaddr_info.map[i].type);
-			if (!(strcmp(name, "Memory"))) {
-				return 0;
-			} else {
-				return 1;
-			}
-		}
-	}
-	return 1;
-}
+	/* return 1 if uncached and return 0 if cached access is required */
+	/* TODO:
+	   We need a actual "physical memory map" to implement this fully.
+	   For now, treat anything in 256MB to 512MB as uncached access
+	   */
+	if((address >= NETLOGIC_UNCACHED_START) && 
+			(address < NETLOGIC_UNCACHED_END))
+		return 1;
 
-int valid_mmap_nlm_common_addr_range(unsigned long pfn)
-{
-	int i;
-	__u64 end=0;
-	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
-		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
-		end = end >> PAGE_SHIFT;
-		if (pfn <= (unsigned long)end)
-			return 1;
-	}
 	return 0;
 }
 
-- 
1.8.4.93.g57e4c17

