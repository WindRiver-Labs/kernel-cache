From afd517b4f76d364dabcbabe13f8443af6632cf50 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Tue, 6 Sep 2011 12:58:54 -0700
Subject: [PATCH 252/565] fix irq and smp

1. Fix unassigned irqs caused resource collision.
When link is down, we did not assign irqs. This led to resource collisions.
As a fix, all IRQs are assigned to correct values irrespective of link status.
Removed some extraneous messages.

2. Linux hangs for onlinmasks other than 0x1 and 0xffffffff.
Linux did not handle logical<-->physical cpu conversions well, mostly because of
a bad merge. Fixed.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c |  6 ++---
 arch/mips/netlogic/xlp/smp.c | 26 ++++++++++---------
 arch/mips/pci/pci-xlp.c      | 62 ++++++++++++++++++--------------------------
 3 files changed, 42 insertions(+), 52 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index c2e45fa..4208f05 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -678,14 +678,14 @@ static void nlm_irq_shutdown(unsigned int irq)
 	}
 	spin_lock_irqsave(&xlp_pic_lock, flags);
 	if (irq_map[irq].usage == 0) {
-		fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
+		//fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
 		spin_unlock_irqrestore(&xlp_pic_lock, flags);
 		return;
 	} else if (irq_map[irq].usage > 0) {
 		irq_map[irq].usage--;
 	}
 	if (irq_map[irq].usage == 0) {
-		fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
+		//fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
 		rvec = xlp_rvec_from_irq(irq);
 		idx = irq - __irqbase_from_rvec(rvec);
 		clear_bit(idx, &(rvec_map[rvec].bitmap));
@@ -1101,7 +1101,7 @@ static int xlp_msi_compose_msg(struct pci_dev *pdev, struct msi_desc *desc,
 	if (fn < 0) return -EINVAL;
 	if (desc->msi_attrib.is_msix) {
 		if (irq < XLP_MSIX_INDEX_START) {	/* enforce minimum */
-			fdebug("Invalid irq %d", irq);
+			dev_err(&pdev->dev, "Invalid irq %d", irq);
 			return -EINVAL;
 		}
 		offset = irq - XLP_MSIX_INDEX_START;
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 7b831d5..2aa3612 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -65,9 +65,8 @@ extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
 
-void nlm_send_ipi_single(int logical_cpu, unsigned int action)
+void nlm_send_ipi_single(int cpu, unsigned int action)
 {
-	int cpu = cpu_logical_map(logical_cpu);
         __u32 node = cpu / 32;
         __u32 ipi = 0;
 	__u8 nmi = 0;
@@ -132,15 +131,18 @@ void nlm_cpus_done(void)
 {
 }
 
-/* Boot all other cpus in the system, initialize them, and
-   bring them into the boot fn */
-void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
+/*
+ * init/main.c : smp_init ==> cpu_up ==> _cpu_up => __cpu_up (arch/mips/kernel/
+ * smp.c) ==> mp_ops->boot_secondary
+ * The cpu argument is the bit number from cpu_present_mask (for_each_online_cpu
+ * ) => physical cpu id, not logical
+ */
+void nlm_boot_secondary(int cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
-	int cpu = cpu_logical_map(logical_cpu);
-	
-	printk("nlm_boot_secondary: logical cpu %d physical cpu %d\n", logical_cpu, cpu);
+
+	printk("nlm_boot_secondary: logical cpu %d physical cpu %d\n", __cpu_number_map[cpu], cpu);
 
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -188,11 +190,11 @@ void __init nlm_smp_setup(void)
 	}
 
 	cpumask_copy(&cpu_present_map, &fdt_cpumask);
-	cpumask_copy(&cpu_possible_map, &cpu_present_map);
-	cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
+	cpumask_copy(&cpu_possible_map, &fdt_cpumask);
+	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_present_map);
+	printk("Present CPU map %s\n", buf);
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
-	printk("Possible/Present CPU map %s\n", buf);
-
+	printk("Possible CPU map %s\n", buf);
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
 }
 
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 96655d2..c9d0cdb 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -273,73 +273,61 @@ static void pcie_controller_init_done(void)
 	case 0:
 		/* controller 0 and 2 are active with 8lanes each */
 		if (mode & 0x1){
-			if (xlp_map_helper(plc, 0) == 0) {
-				xlp_pcie_controller_setup(0);
-			}
+			xlp_map_helper(plc, 0);
+			xlp_pcie_controller_setup(0);
 		}
 		if (mode & 0x4) {
-			if (xlp_map_helper(plc, 2) == 0) {
-				xlp_pcie_controller_setup(2);
-			}
+			xlp_map_helper(plc, 2);
+			xlp_pcie_controller_setup(2);
 		}
 		break;
 	case 1:
 		/* controllers 0,1 and 2 are active */
 		if (mode & 0x1){
-			if (xlp_map_helper(plc, 0) == 0) {
-				xlp_pcie_controller_setup(0);
-			}
+			xlp_map_helper(plc, 0);
+			xlp_pcie_controller_setup(0);
 		}
 		if (mode & 0x2){
-			if (xlp_map_helper(plc, 1) == 0) {
-				xlp_pcie_controller_setup(1);
-			}
+			xlp_map_helper(plc, 1);
+			xlp_pcie_controller_setup(1);
 		}
 		if (mode & 0x4){
-			if (xlp_map_helper(plc, 2) == 0) {
-				xlp_pcie_controller_setup(2);
-			}
+			xlp_map_helper(plc, 2);
+			xlp_pcie_controller_setup(2);
 		}
 		break;
 	case 2:
 		/* controllers 0,2 and 3 are active */
 		if (mode & 0x1){
-			if (xlp_map_helper(plc, 0) == 0) {
-				xlp_pcie_controller_setup(0);
-			}
+			xlp_map_helper(plc, 0);
+			xlp_pcie_controller_setup(0);
 		}
 		if (mode & 0x4){
-			if (xlp_map_helper(plc, 2) == 0) {
-				xlp_pcie_controller_setup(2);
-			}
+			xlp_map_helper(plc, 2);
+			xlp_pcie_controller_setup(2);
 		}
 		if (mode & 0x8){
-			if (xlp_map_helper(plc, 3) == 0) {
-				xlp_pcie_controller_setup(3);
-			}
+			xlp_map_helper(plc, 3);
+			xlp_pcie_controller_setup(3);
 		}
 		break;
 	case 3:
 		/* All four controllers are active with 4 lanes each */
 		if (mode & 0x1){
-			if (xlp_map_helper(plc, 0) == 0) {
-				xlp_pcie_controller_setup(0);
-			}
+			xlp_map_helper(plc, 0);
+			xlp_pcie_controller_setup(0);
 		}
 		if (mode & 0x2){
-			if (xlp_map_helper(plc, 1) == 0) {
-				xlp_pcie_controller_setup(1);
-			}
+			xlp_map_helper(plc, 1);
+			xlp_pcie_controller_setup(1);
 		}
 		if (mode & 0x4){
-			if (xlp_map_helper(plc, 2) == 0) {
-				xlp_pcie_controller_setup(2);
-			}
+			xlp_map_helper(plc, 2);
+			xlp_pcie_controller_setup(2);
 		}
 		if (mode & 0x8){
-			if (xlp_map_helper(plc, 3) == 0) {
-				xlp_pcie_controller_setup(3);
-			}
+			xlp_map_helper(plc, 3);
+			xlp_pcie_controller_setup(3);
 		}
 		break;
 	}
@@ -857,7 +845,7 @@ void xlp_set_cpumask(const struct cpumask *m, int irt)
 		val = nlm_hal_read_64bit_reg(xlp_pic_base, offset);
 		val &= ~((1 << 28) | (1 << 19) | (0x7 << 16) | 0xffff);
 		val |= (i << 16);
-		fdebug("Writing val = %#llx\n", val);
+		//fdebug("Writing val = %#llx\n", val);
 		nlm_hal_write_64bit_reg(xlp_pic_base, offset, val);
 		return;
 	}
-- 
1.8.4.93.g57e4c17

