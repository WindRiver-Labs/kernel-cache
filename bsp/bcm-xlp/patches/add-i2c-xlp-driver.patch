From 6bdbc793d6684f5f3cb6a7497c2145af7f660cbe Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 14 Dec 2010 11:12:23 -0800
Subject: [PATCH 184/565] add i2c-xlp driver

add i2c-xlp.c board.c for i2c-xlp driver and support

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/board.c |  45 ++++
 drivers/i2c/busses/i2c-xlp.c   | 482 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 527 insertions(+)
 create mode 100644 arch/mips/netlogic/xlp/board.c
 create mode 100644 drivers/i2c/busses/i2c-xlp.c

diff --git a/arch/mips/netlogic/xlp/board.c b/arch/mips/netlogic/xlp/board.c
new file mode 100644
index 0000000..3033ed7
--- /dev/null
+++ b/arch/mips/netlogic/xlp/board.c
@@ -0,0 +1,45 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+static struct i2c_board_info xlp_i2c_device_info[] __initdata = {
+        {"ds1374",          0, 0x68, 0, 0, 0},
+        {"max6657",             0, 0x4c, 0, 0, 0},
+       /* {"at24c02",           0, 0x57, 0, 0, 0},
+        {"trx10gdp0310",      0, 0x70, 0, 0, 0},
+	*/
+};
+
+static int __init xlp_i2c_device_init(void)
+{
+	return i2c_register_board_info(1, xlp_i2c_device_info, ARRAY_SIZE(xlp_i2c_device_info));
+}
+
+arch_initcall(xlp_i2c_device_init);
+
diff --git a/drivers/i2c/busses/i2c-xlp.c b/drivers/i2c/busses/i2c-xlp.c
new file mode 100644
index 0000000..a8d9daf
--- /dev/null
+++ b/drivers/i2c/busses/i2c-xlp.c
@@ -0,0 +1,482 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+
+#define DEFAULT_VIRT_BASE               0x9000000000000000ULL
+#define I2C_TIMEOUT                     500000
+#define XLP_I2C_DEFAULT_SPEED           1000
+#define I2C_PRESCALER_LO                 0
+#define I2C_PRESCALER_HI                 1
+#define I2C_CONTROL                      2
+        #define I2C_CONTROL_EN           0x80
+        #define I2C_CONTROL_IEN          0x40
+#define I2C_DATA                         3               /* Data TX & RX Reg */
+#define I2C_COMMAND                      4
+        #define I2C_COMMAND_START        0x90
+        #define I2C_COMMAND_STOP         0x40
+        #define I2C_COMMAND_READ         0x20
+        #define I2C_COMMAND_WRITE        0x10
+        #define I2C_COMMAND_RDACK        0x20
+        #define I2C_COMMAND_RDNACK       0x28
+        #define I2C_COMMAND_IACK         0x01    /* Not used */
+#define I2C_STATUS                       4               /* Same as 'command' */
+        #define I2C_STATUS_NACK          0x80    /* Did not get an ACK */                                
+        #define I2C_STATUS_BUSY          0x40                            
+        #define I2C_STATUS_AL            0x20    /* Arbitration Lost */                          
+        #define I2C_STATUS_TIP           0x02    /* Transfer in Progress  */                             
+        #define I2C_STATUS_IF            0x01    /* Intr. Pending Flag, not used */
+#define I2C_WRITE_BIT			0x00
+#define I2C_READ_BIT			0x01
+#define I2C_DEFAULT_PRESCALER		0x3F
+
+struct i2c_xlp_data {
+	int 	node;
+	int	bus;
+	int	func;
+	int	xfer_timeout;
+	int	ack_timeout;
+	uint64_t* ioreg;
+	struct i2c_adapter adap;
+	struct resource *ioarea;
+};
+
+static __inline__ int32_t i2c_reg_read(int node, int func, int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, func);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void i2c_reg_write(int node, int func, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, func);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#ifdef XLP_I2C_DEBUG
+static void i2c_dump_reg()
+{
+        int i, j = 0;
+	for(j = 0; j < 1; j++)
+	{
+		printk("dump i2c_%d register\n", j);
+                for(i = 0; i < 6; i++) {
+			printk("0x%0x = 0x%8x\n", i, i2c_reg_read( 0, XLP_GIO_I2C0_FUNC+j, i));
+		}
+                for(i = 0x3C; i < 0x42; i++) {
+			printk("0x%0x = 0x%8x\n", i, i2c_reg_read( 0, XLP_GIO_I2C0_FUNC+j, i));
+		}
+	}
+}
+#endif
+
+static inline uint8_t i2c_read_reg8(struct i2c_xlp_data *adap, int offset) {
+
+        volatile uint32_t *i2c_mmio = (u32*)adap->ioreg;
+        return ((uint8_t)i2c_mmio[offset]);
+}
+
+static inline void i2c_write_reg8(struct i2c_xlp_data *adap,int offset, uint8_t value) {
+
+        volatile uint32_t *i2c_mmio = (u32*)adap->ioreg;
+        i2c_mmio[offset] = value;
+}
+
+static int wait_xfer_done(struct i2c_xlp_data *adap) {
+
+        volatile int timeout = I2C_TIMEOUT;
+        int retval = 0;
+
+        while ((i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_TIP) && timeout) {
+                timeout--;
+        }
+        if (timeout == 0) {
+                printk("Timed Out Waiting for TIP to Clear.\n");
+                retval = -1;
+        }
+        return retval;
+}
+
+static int bus_idle(struct i2c_xlp_data *adap) {
+
+        volatile int timeout = I2C_TIMEOUT;
+        int retval = 0;
+
+        while ((i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) && timeout) {
+                timeout--;
+        }
+        if (timeout == 0) {
+                printk("Timed Out Waiting for Bus Busy to Clear.\n");
+                retval = -1;
+        }
+        return retval;
+}
+
+static int wait_ack(struct i2c_xlp_data *adap) {
+
+        if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_NACK) {
+               return -1;
+        }
+        return 0;
+}
+
+int xlp_i2c_read(struct i2c_xlp_data *adap, uint8_t slave_addr, uint32_t slave_offset,
+              int alen, int len, uint8_t *data) {
+        int i ;
+
+        /* Verify the bus is idle */
+        if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) {
+                printk("I2C Bus BUSY (Not Available), Aborting.\n");
+                goto i2c_rx_error;
+        }
+
+        i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+        if (wait_xfer_done(adap) < 0) {
+                goto i2c_rx_error;
+        }
+        if (wait_ack(adap) < 0) {
+                goto i2c_rx_error;
+        }
+
+        /* Verify Arbitration is not Lost */
+        if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_AL) {
+                printk("I2C Bus Arbitration Lost, Aborting.\n");
+                goto i2c_rx_error;
+        }
+        for (i = 0; i<=alen; i++) {
+                i2c_write_reg8(adap, I2C_DATA, ( (slave_offset >> (i*8) ) & 0xff) | I2C_WRITE_BIT);
+                i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+                if (wait_xfer_done(adap) < 0) {
+                        goto i2c_rx_error;
+                }
+                if (wait_ack(adap) < 0) {
+                        goto i2c_rx_error;
+                }
+        }
+
+        /* Address Phase Done, Data Phase begins
+ 	 */
+        i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_READ_BIT);
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+        if (wait_xfer_done(adap) < 0) {
+                goto i2c_rx_error;
+        }
+        if (wait_ack(adap) < 0) {
+                goto i2c_rx_error;
+        }
+        if (len > 1) {
+
+                int bytenr = 0;
+
+                for (bytenr = 0; bytenr < len-1; bytenr++) {
+                        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_READ);
+                        if (wait_xfer_done(adap) < 0) {
+                                goto i2c_rx_error;
+                        }
+                        if (data != NULL) {
+                                *data = i2c_read_reg8(adap, I2C_DATA);
+                                data++;
+                        }
+                }
+        }
+
+        /* Last (or only) Byte: -
+         * Set RD, NACK, STOP Bits
+         */
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_RDNACK);
+        if (wait_xfer_done(adap) < 0) {
+                goto i2c_rx_error;
+        }
+	if(data != NULL)
+                *data = i2c_read_reg8(adap, I2C_DATA);
+        return bus_idle(adap);
+
+i2c_rx_error:
+        /* Release Bus */
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP);
+        bus_idle(adap);
+        return -1;
+}
+
+int xlp_i2c_write(struct i2c_xlp_data *adap, uint8_t slave_addr, uint16_t slave_offset, int alen,
+                int len, uint8_t *data) {
+        int i ;
+
+        /* Verify the bus is idle */
+        if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) {
+                printk("I2C Bus BUSY (Not Available), Aborting.\n");
+                goto i2c_tx_error;
+        }
+
+        i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+        if (wait_xfer_done(adap) < 0) {
+                goto i2c_tx_error;
+        }
+        if (wait_ack(adap) < 0) {
+                goto i2c_tx_error;
+        }
+
+        /* Verify Arbitration is not Lost */
+        if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_AL) {
+                printk("I2C Bus Arbitration Lost, Aborting.\n");
+                goto i2c_tx_error;
+        }
+
+        for (i = 0; i<=alen; i++) {
+                i2c_write_reg8(adap, I2C_DATA, ( (slave_offset >> (i*8) ) & 0xff) | I2C_WRITE_BIT);
+                i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+                if (wait_xfer_done(adap) < 0) {
+                        goto i2c_tx_error;
+                }
+                if (wait_ack(adap) < 0) {
+                        goto i2c_tx_error;
+                }
+        }
+
+        if (len > 1) {
+
+                int bytenr = 0;
+
+                for (bytenr = 0; bytenr < len-1; bytenr++) {
+                        i2c_write_reg8(adap, I2C_DATA, *data);
+                        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+                        if (wait_xfer_done(adap) < 0) {
+                                goto i2c_tx_error;
+                        }
+                        data++;
+                }
+        }
+        i2c_write_reg8(adap, I2C_DATA, *data);
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_WRITE);
+        if (wait_xfer_done(adap) < 0) {
+                goto i2c_tx_error;
+        }
+        if (wait_ack(adap) < 0) {
+                goto i2c_tx_error;
+        }
+
+        return bus_idle(adap);
+
+i2c_tx_error:
+        /* Release Bus */
+        i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP);
+        bus_idle(adap);
+        return -1;
+}
+
+static int
+xlp_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
+{
+	struct i2c_xlp_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int i, err = 0;
+
+
+	for (i = 0; !err && i < num; i++) {
+		p = &msgs[i];
+		if(!p)
+			break;
+	/*printk("[%s] p %x addr: 0x%x len: %d  num:%d \n",__func__, p, p->addr,p->len, num);*/
+		if (p->flags & I2C_M_RD)
+			err = xlp_i2c_read(adap, p->addr, 0, 0, p->len, p->buf);
+		else
+			err = xlp_i2c_write(adap, p->addr,0, 0, p->len, p->buf);
+	}
+
+	/* Return the number of messages processed, or the error code.
+	*/
+	if (err == 0)
+		err = num;
+
+
+	return err;
+}
+
+static uint32_t
+xlp_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm xlp_i2c_algo = {
+	.master_xfer	= xlp_i2c_xfer,
+	.functionality	= xlp_i2c_func,
+};
+
+static void i2c_xlp_setup(struct i2c_xlp_data *priv)
+{
+	uint32_t val, prescaler;
+
+	val = i2c_reg_read(priv->node, priv->func, XLP_I2C_CFG0);
+	val &= ~(XLP_I2C_EN | XLP_I2C_INT_EN);
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+
+	prescaler = I2C_DEFAULT_PRESCALER;
+	/*set the I2c speed 100 khz*/
+	val &= ~0xFFFF;
+	val |=  (prescaler & 0xFFFF);
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+
+	val |= XLP_I2C_EN; 
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);	
+
+}
+
+static void i2c_xlp_disable(struct i2c_xlp_data *priv)
+{
+	int32_t val;
+	
+	val = i2c_reg_read(priv->node, priv->func, XLP_I2C_CFG0);
+	val &= ~XLP_I2C_EN;
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);	
+}
+
+static int __devinit
+i2c_xlp_probe(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv;
+	int ret;
+#ifdef XLP_I2C_DEBUG
+	i2c_dump_reg();	
+#endif
+	priv = kzalloc(sizeof(struct i2c_xlp_data), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+
+	priv->node = 0;
+	priv->bus = pdev->id;
+	priv->func = priv-> bus + 2;
+	priv->xfer_timeout = 200;
+	priv->ack_timeout = 200;
+        priv->ioreg = (uint64_t*) (DEFAULT_VIRT_BASE + 
+			nlm_hal_get_dev_base(0, 0, XLP_PCIE_GIO_DEV, priv->func) + 0x100);
+	priv->adap.nr = pdev->id;
+	priv->adap.algo = &xlp_i2c_algo;
+	priv->adap.algo_data = priv;
+	priv->adap.dev.parent = &pdev->dev;
+	strlcpy(priv->adap.name, "i2c-xlp", sizeof(priv->adap.name));
+
+	/* Now, set up the PSC for SMBus PIO mode.
+	*/
+	i2c_xlp_setup(priv);
+
+	ret = i2c_add_numbered_adapter(&priv->adap);
+	if (ret == 0) {
+		platform_set_drvdata(pdev, priv);
+		printk("Initializing i2c-xlp host driver for i2c-xlp.%d\n",pdev->id);
+		return 0;
+	}
+
+	i2c_xlp_disable(priv);
+out:
+	return ret;
+}
+
+static int __devexit
+i2c_xlp_remove(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	i2c_del_adapter(&priv->adap);
+	i2c_xlp_disable(priv);
+	release_resource(priv->ioarea);
+	kfree(priv->ioarea);
+	kfree(priv);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int
+i2c_xlp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	i2c_xlp_disable(priv);
+
+	return 0;
+}
+
+static int
+i2c_xlp_resume(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	i2c_xlp_setup(priv);
+
+	return 0;
+}
+#else
+#define i2c_xlp_suspend	NULL
+#define i2c_xlp_resume	NULL
+#endif
+
+static struct platform_driver xlp_smbus_driver = {
+	.driver = {
+		.name	= "i2c-xlp",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= i2c_xlp_probe,
+	.remove		= __devexit_p(i2c_xlp_remove),
+	.suspend	= i2c_xlp_suspend,
+	.resume		= i2c_xlp_resume,
+};
+
+static int __init
+i2c_xlp_init(void)
+{
+	return platform_driver_register(&xlp_smbus_driver);
+}
+
+static void __exit
+i2c_xlp_exit(void)
+{
+	platform_driver_unregister(&xlp_smbus_driver);
+}
+
+MODULE_AUTHOR("Netlogic MicroSystems");
+MODULE_DESCRIPTION("I2C adapter for XLP soc");
+MODULE_LICENSE("GPL");
+
+module_init (i2c_xlp_init);
+module_exit (i2c_xlp_exit);
-- 
1.8.4.93.g57e4c17

