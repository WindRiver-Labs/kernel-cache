From 4d657b7d7722a246583b3c0a473e9d20cbcabe21 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 25 Apr 2013 17:13:34 +0800
Subject: [PATCH 495/565] bcm-xlp: Clock: Made mult and shift values

Clock: Made mult and shift values of clocksource and clockevent inline
with linux-2.6.32.

This fixes the nat app pkt drop in 1600Mhz cpu frequency.
On debugging, in some cpus the while loop inside hrtimer_interrupt
seems to spend around 15ms at times(like the scenario in the below print
where the ktime_get() seems to return different values in
hrtimer_interrupt and hrtimer_forward.until the 'basenow' becomes > 'exp'
in hrtimer_forward the loop in hrtimer_interrupt runs)during which nat_app
starves and the pkt drop is seen.

28:hrtimer_interrupt:1318 jiffy: 4295086534 entry: 419235355278
 basenow.tv64: 419235355278 exp: 419235000000 softexp: 419235000000
 offset: 0
28:hrtimer_forward:827 jiffies: 4295086534 basenow.tv64: 419234028077
  exp: 419235000000 softexp: 419235000000

Based on Broadcom SDK 2.3.

Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/cevt-r4k.c |  7 +++++++
 arch/mips/kernel/time.c     | 20 ++++++++++++++++++++
 kernel/time/clocksource.c   |  6 ++++++
 3 files changed, 33 insertions(+)

diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index c46eb72..f01bf54 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -192,7 +192,14 @@ int __cpuinit r4k_clockevent_init(void)
 	cd->name		= "MIPS";
 	cd->features		= CLOCK_EVT_FEAT_ONESHOT;
 
+
+#ifdef CONFIG_NLM_XLP
+	/* for 1GHz (and lesser), div_sc returns zero if shift = 32 */
+	cd->mult    = div_sc((unsigned long) mips_hpt_frequency, NSEC_PER_SEC, 30);
+	cd->shift       = 30;
+#else
 	clockevent_set_clock(cd, mips_hpt_frequency);
+#endif
 
 	/* Calculate the min / max delta */
 	cd->max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);
diff --git a/arch/mips/kernel/time.c b/arch/mips/kernel/time.c
index 99d73b7..8641d9b 100644
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -124,3 +124,23 @@ void __init time_init(void)
 	if (!mips_clockevent_init() || !cpu_has_mfc0_count_bug())
 		init_mips_clocksource();
 }
+
+#ifdef CONFIG_NLM_XLP
+void clocksource_set_clock(struct clocksource *cs, unsigned int clock)
+{
+	u64 temp;
+	u32 shift; 
+	int shift_val;
+	shift_val=30;
+
+	/* Find a shift value */
+	for (shift = shift_val; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, clock);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	cs->shift = shift;
+	cs->mult = (u32) temp;
+}
+#endif
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index c958338..ac63513 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -658,6 +658,11 @@ static void clocksource_enqueue(struct clocksource *cs)
  */
 void __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq)
 {
+#ifdef CONFIG_NLM_XLP
+	extern void clocksource_set_clock(struct clocksource *cs, unsigned int clock);
+
+	clocksource_set_clock(cs, freq);
+#else
 	u64 sec;
 	/*
 	 * Calc the maximum number of seconds which we can run before
@@ -679,6 +684,7 @@ void __clocksource_updatefreq_scale(struct clocksource *cs, u32 scale, u32 freq)
 
 	clocks_calc_mult_shift(&cs->mult, &cs->shift, freq,
 			       NSEC_PER_SEC / scale, sec * scale);
+#endif
 
 	/*
 	 * for clocksources that have large mults, to avoid overflow.
-- 
1.8.4.93.g57e4c17

