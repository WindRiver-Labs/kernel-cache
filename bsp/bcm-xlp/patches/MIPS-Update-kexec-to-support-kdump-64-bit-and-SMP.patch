From 02bf432ee09a817408d14184c29c5fe34a96f7bb Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Thu, 27 May 2010 17:38:08 -0400
Subject: [PATCH 542/565] MIPS: Update kexec to support kdump, 64-bit and SMP

Updates kernel part of kexec for MIPS platform to support kdump, 64-bit, SMP
and simplify code adaptation to new boards. It does the following:

- hooks for machine-specific actions are introduced
  (_machine_kexec_prepare, _machine_kexec_shutdown, _machine_crash_shutdown);
- kexec reboot on SMP machine is implemented;
- add boot parameters passing to new kernel (array kexec_args[] is copied to
  registers a0-a3 on reboot );
- crash dump functionality is added (boot kernel with non-default physical
  start, parse "crashkernel=..." command line parameter, copy_oldmem_page()
  is implemeted to read memory dump after reboot-on-crashi,
  crash_setup_regs() is updated to correctly store registers on crash);

kexec/kdump funtionality was tested on several Cavium Octeon boards
(mips64 SMP). The way we do it was the following:
- _machine_kexec_prepare was find kexec segment with command line and
  save it's pointed into internal bootloader structure.
- _machine_kexec_shutdown was used to stop boards IO and make all non-boot
  CPUs spin in function relocated_kexec_smp_wait()
- _machine_crash_shutdown just calls default_machine_crash_shutdown()
  We tested 1) 'common' kexec reboot (by 'kexec -e'), 2) kexec-on-panic
  ('kexec -p ...') and 3) access to/proc/vmcore (with gdb).

Signed-off-by: Maxim Syrchin <msyrchin@ru.mvista.com>
Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
Integrated-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Signed-off-by: Guojian Zhou <guojian.zhou@windriver.com>
---
 arch/mips/include/asm/kexec.h      | 23 +++++++++-
 arch/mips/kernel/machine_kexec.c   | 58 ++++++++++++++++++++++--
 arch/mips/kernel/relocate_kernel.S | 93 +++++++++++++++++++++++++++++++++++++-
 arch/mips/kernel/setup.c           | 10 +++-
 4 files changed, 175 insertions(+), 9 deletions(-)

diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index 4314892..72e9721 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -7,7 +7,9 @@
  */
 
 #ifndef _MIPS_KEXEC
-# define _MIPS_KEXEC
+#define _MIPS_KEXEC
+
+#include <linux/stacktrace.h>
 
 /* Maximum physical address we can use pages from */
 #define KEXEC_SOURCE_MEMORY_LIMIT (0x20000000)
@@ -24,7 +26,24 @@
 static inline void crash_setup_regs(struct pt_regs *newregs,
 				    struct pt_regs *oldregs)
 {
-	/* Dummy implementation for now */
+	if (oldregs)
+		memcpy(newregs, oldregs, sizeof(*newregs));
+	else
+	prepare_frametrace(newregs);
 }
 
+#ifdef CONFIG_KEXEC
+struct kimage;
+extern unsigned long kexec_args[4];
+extern int (*_machine_kexec_prepare)(struct kimage *);
+extern void (*_machine_kexec_shutdown)(void);
+extern void (*_machine_crash_shutdown)(struct pt_regs *regs);
+extern void default_machine_crash_shutdown(struct pt_regs *regs);
+#ifdef CONFIG_SMP
+extern const unsigned char kexec_smp_wait[];
+extern unsigned long secondary_kexec_args[4];
+extern void (*relocated_kexec_smp_wait)(void *);
+extern atomic_t kexec_ready_to_reboot;
+#endif
+#endif
 #endif /* !_MIPS_KEXEC */
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index 85beb9b..9c268ed 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -19,9 +19,19 @@ extern const size_t relocate_new_kernel_size;
 extern unsigned long kexec_start_address;
 extern unsigned long kexec_indirection_page;
 
+int (*_machine_kexec_prepare)(struct kimage *);
+void (*_machine_kexec_shutdown)(void);
+void (*_machine_crash_shutdown)(struct pt_regs *regs);
+#ifdef CONFIG_SMP
+void (*relocated_kexec_smp_wait) (void *);
+atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
+#endif
+
 int
 machine_kexec_prepare(struct kimage *kimage)
 {
+	if (_machine_kexec_prepare)
+		return _machine_kexec_prepare(kimage);
 	return 0;
 }
 
@@ -33,11 +43,17 @@ machine_kexec_cleanup(struct kimage *kimage)
 void
 machine_shutdown(void)
 {
+	if (_machine_kexec_shutdown)
+		_machine_kexec_shutdown();
 }
 
 void
 machine_crash_shutdown(struct pt_regs *regs)
 {
+	if (_machine_crash_shutdown)
+		_machine_crash_shutdown(regs);
+	else
+		default_machine_crash_shutdown(regs);
 }
 
 typedef void (*noretfun_t)(void) __attribute__((noreturn));
@@ -52,7 +68,8 @@ machine_kexec(struct kimage *image)
 	reboot_code_buffer =
 	  (unsigned long)page_address(image->control_code_page);
 
-	kexec_start_address = image->start;
+	kexec_start_address = (unsigned long) phys_to_virt(image->start);
+
 	kexec_indirection_page =
 		(unsigned long) phys_to_virt(image->head & PAGE_MASK);
 
@@ -60,10 +77,9 @@ machine_kexec(struct kimage *image)
 	       relocate_new_kernel_size);
 
 	/*
-	 * The generic kexec code builds a page list with physical
-	 * addresses. they are directly accessible through KSEG0 (or
-	 * CKSEG0 or XPHYS if on 64bit system), hence the
-	 * pys_to_virt() call.
+	 * The generic kexec code builds a page list with physical addresses.
+	 * They are directly accessible through KSEG0 (or CKSEG0 or XPHYS if on
+	 * 64bit system), hence the phys_to_virt() call.
 	 */
 	for (ptr = &image->head; (entry = *ptr) && !(entry &IND_DONE);
 	     ptr = (entry & IND_INDIRECTION) ?
@@ -81,5 +97,37 @@ machine_kexec(struct kimage *image)
 	printk("Will call new kernel at %08lx\n", image->start);
 	printk("Bye ...\n");
 	__flush_cache_all();
+#ifdef CONFIG_SMP
+	/* All secondary cpus now may jump to kexec_wait cycle */
+	relocated_kexec_smp_wait = reboot_code_buffer +
+		(kexec_smp_wait - relocate_new_kernel);
+	smp_wmb();
+	atomic_set(&kexec_ready_to_reboot, 1);
+#endif
 	((noretfun_t) reboot_code_buffer)();
 }
+
+/*
+ * crashkernel=size at addr specifies the location to reserve for
+ * a crash kernel.  By reserving this memory we guarantee
+ * that linux never sets it up as a DMA target.
+ * Useful for holding code to do something appropriate
+ * after a kernel panic.
+ */
+static int __init parse_crashkernel(char *arg) {
+	unsigned long size, base;
+
+	size = memparse(arg, &arg);
+	if (*arg == '@') {
+		base = memparse(arg+1, &arg);
+		/*
+		 * FIXME: Do I want a sanity check
+		 * to validate the memory range?
+		 */
+		crashk_res.start = base;
+		crashk_res.end   = base + size - 1;
+	}
+
+	return 0;
+}
+early_param("crashkernel", parse_crashkernel);
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 87481f9..e1e5628 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -14,7 +14,13 @@
 #include <asm/stackframe.h>
 #include <asm/addrspace.h>
 
+
 LEAF(relocate_new_kernel)
+     PTR_L a0,    arg0
+     PTR_L a1,    arg1
+     PTR_L a2,    arg2
+     PTR_L a3,    arg3
+
 	PTR_L		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
 
@@ -26,7 +32,6 @@ process_entry:
 	and		s3, s2, 0x1
 	beq		s3, zero, 1f
 	and		s4, s2, ~0x1	/* store destination addr in s4 */
-	move		a0, s4
 	b		process_entry
 
 1:
@@ -60,10 +65,96 @@ copy_word:
 	b		process_entry
 
 done:
+#ifdef CONFIG_SMP
+    /* kexec_flag reset is signal to other CPUs what kernel
+        was moved to it's location. Note - we need relocated address
+        of kexec_flag.  */
+
+     bal        1f
+ 1:     move        t1,ra;
+     PTR_LA        t2,1b
+     PTR_LA        t0,kexec_flag
+     PTR_SUB        t0,t0,t2;
+     PTR_ADD        t0,t1,t0;
+     LONG_S        zero,(t0)
+#endif
+
+     /* Some platforms need I-cache to be flushed before
+     * jumping to new kernel.
+      */
+
 	/* jump to kexec_start_address */
 	j		s1
 	END(relocate_new_kernel)
 
+#ifdef CONFIG_SMP
+/*
+ * Other CPUs should wait until code is relocated and
+ * then start at entry point.
+ */
+LEAF(kexec_smp_wait)
+    PTR_L        a0, s_arg0
+    PTR_L        a1, s_arg1
+    PTR_L        a2, s_arg2
+    PTR_L        a3, s_arg3
+    PTR_L        s1, kexec_start_address
+
+    /* Non-relocated address works for args and kexec_start_address ( old
+     * kernel is not overwritten). But we need relocated address of
+     * kexec_flag.
+     */
+
+    bal        1f
+1:    move        t1,ra;
+    PTR_LA        t2,1b
+    PTR_LA        t0,kexec_flag
+    PTR_SUB        t0,t0,t2;
+    PTR_ADD        t0,t1,t0;
+
+1:    LONG_L        s0, (t0)
+    bne        s0, zero,1b
+
+    j        s1
+    END(kexec_smp_wait)
+#endif
+
+
+#ifdef __mips64
+       /* all PTR's must be aligned to 8 byte in 64-bit mode */
+       .align  3
+#endif
+
+/* All parameters to new kernel are passed in registers a0-a3.
+ * kexec_args[0..3] are uses to prepare register values.
+ */
+
+kexec_args:
+    EXPORT(kexec_args)
+arg0:    PTR        0x0
+arg1:    PTR        0x0
+arg2:    PTR        0x0
+arg3:    PTR        0x0
+    .size    kexec_args,PTRSIZE*4
+
+#ifdef CONFIG_SMP
+/*
+ * Secondary CPUs may have different kernel parameters in
+ * their registers a0-a3. secondary_kexec_args[0..3] are used
+ * to prepare register values.
+ */
+secondary_kexec_args:
+    EXPORT(secondary_kexec_args)
+s_arg0:    PTR        0x0
+s_arg1:    PTR        0x0
+s_arg2:    PTR        0x0
+s_arg3:    PTR        0x0
+    .size    secondary_kexec_args,PTRSIZE*4
+kexec_flag:
+    LONG        0x1
+
+#endif
+
+
 kexec_start_address:
 	EXPORT(kexec_start_address)
 	PTR		0x0
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0d1e5a4..e325b6d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -31,7 +31,7 @@
 #include <linux/console.h>
 #include <linux/pfn.h>
 #include <linux/debugfs.h>
-
+#include <linux/kexec.h>
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
 #include <asm/bugs.h>
@@ -608,6 +608,11 @@ static void __init arch_mem_init(char **cmdline_p)
 #if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA) && !defined(CONFIG_NLM_16G_MEM_SUPPORT)
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
 #endif
+#ifdef CONFIG_KEXEC
+	if (crashk_res.start != crashk_res.end)
+		reserve_bootmem(crashk_res.start,
+				crashk_res.end - crashk_res.start + 1);
+#endif
 	device_tree_init();
 	sparse_init();
 	plat_swiotlb_setup();
@@ -665,6 +670,9 @@ static void __init resource_init(void)
 		 */
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
+#ifdef CONFIG_KEXEC
+		request_resource(res, &crashk_res);
+#endif
 	}
 }
 
-- 
1.8.4.93.g57e4c17

