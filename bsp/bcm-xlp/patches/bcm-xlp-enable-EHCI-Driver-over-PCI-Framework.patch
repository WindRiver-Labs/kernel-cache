From 66d4372c0297d819d30f03706688f9725afd3368 Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@netlogicmicro.com>
Date: Sat, 20 Nov 2010 00:29:42 -0800
Subject: [PATCH 173/565] bcm-xlp: enable EHCI Driver over PCI Framework

USB Changes to enable EHCI Driver over PCI Framework.

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp.h     | 24 ++++++++++
 arch/mips/include/asm/netlogic/xlp_usb.h | 42 +++++++++++++++++
 arch/mips/netlogic/xlp/Makefile          |  2 +-
 drivers/usb/host/Kconfig                 |  5 ++-
 drivers/usb/host/Makefile                |  3 ++
 drivers/usb/host/ehci-pci.c              | 77 +++++++++++++++++++++++++++++++-
 6 files changed, 150 insertions(+), 3 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/xlp_usb.h

diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index 42e5195..9149917 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -43,6 +43,30 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_REVISION_A0 	0xc0010
 #define MAX_CPU_REV_LEN		100
 
+#define PCI_NETL_VENDOR         0x184E
+#define XLP_DEVID_DRAM          0x1001
+#define XLP_DEVID_PIC           0x1003
+#define XLP_DEVID_INTLA         0x1005
+#define XLP_DEVID_USBDEV        0x1006
+#define XLP_DEVID_EHCI          0x1007  
+#define XLP_DEVID_OHCI          0x1008
+#define XLP_DEVID_NAE           0x1009
+#define XLP_DEVID_POE           0x100A
+#define XLP_DEVID_CMS           0x100B
+#define XLP_DEVID_DTRE_RAID     0x100C
+#define XLP_DEVID_SAE           0x100D
+#define XLP_DEVID_RSAECC        0x100E
+#define XLP_DEVID_CPM           0x100F
+#define XLP_DEVID_UART          0x1010
+#define XLP_DEVID_I2C           0x1011
+#define XLP_DEVID_GPIO          0x1012
+#define XLP_DEVID_SYS           0x1013
+#define XLP_DEVID_JTAG          0x1014
+#define XLP_DEVID_NOR           0x1015
+#define XLP_DEVID_NAND          0x1016
+#define XLP_DEVID_SPI           0x1017
+#define XLP_DEVID_MMC           0x1018
+
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
   volatile unsigned long sp;
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
new file mode 100644
index 0000000..513147f
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -0,0 +1,42 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+#ifndef __XLP_USB_H
+#define __XLP_USB_H
+
+static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void usb_reg_write(int node, int func, int regidx, int32_t val)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#endif //__XLP_USB_H
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index cfbdfc8..b3ee2ec 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -3,7 +3,7 @@ EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogi
 
 obj-y                    	= setup.o nmi.o
 obj-y 				+= irq.o time.o on_chip.o mmu.o
-obj-$(CONFIG_NLM_XLP) 		+= platform-xlp.o
+obj-$(CONFIG_NLM_XLP) 		+= platform.o
 obj-$(CONFIG_SMP)       	+= smp.o
 
 ifeq ($(CONFIG_XEN),y)
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 344d5e2..a422689 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -117,9 +117,11 @@ config USB_EHCI_HCD_PMC_MSP
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
+	default y if NLM_XLP && CPU_BIG_ENDIAN
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
+	default y if NLM_XLP && CPU_BIG_ENDIAN
 
 config XPS_USB_HCD_XILINX
 	bool "Use Xilinx usb host EHCI controller core"
@@ -496,11 +498,12 @@ config USB_OHCI_BIG_ENDIAN_DESC
 
 config USB_OHCI_BIG_ENDIAN_MMIO
 	bool
+	default y if NLM_XLP
 	default n
 
 config USB_OHCI_LITTLE_ENDIAN
 	bool
-	default n if STB03xxx || PPC_MPC52xx
+	default n if STB03xxx || PPC_MPC52xx || NLM_XLP
 	default y
 
 endif # USB_OHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 4fb73c1..2906668 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -1,6 +1,9 @@
 #
 # Makefile for USB Host Controller Drivers
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+	EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 595d210..687cabd 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -1,3 +1,11 @@
+/* **********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
+ * This is a derived work from software originally provided by the external
+ * entity identified below. The licensing terms and warranties specified in
+ * the header of the original work apply to this derived work.
+ *
+ * *****************************#NETL_1#********************************/
+
 /*
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *
@@ -34,6 +42,49 @@ static const char hcd_name[] = "ehci-pci";
 /* defined here to avoid adding to pci_ids.h for single instance use */
 #define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
 
+#ifdef CONFIG_NLM_XLP
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+volatile uint64_t *ehci_regs;
+
+static void xlp_usb_hw_start(int ctrl_no)
+{
+	int val;
+
+	/* enable USB interrupts
+	 */
+	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT1_EN;
+	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
+
+	return;
+}
+
+int xlp_ehci_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int irq, irt, ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+
+	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
+	irq = nlm_hal_request_shared_irq(irt);
+
+	if (!irq) {
+		printk("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", 
+				pci_name(dev));
+		return -ENODEV;
+	}
+
+	dev->irq = irq;
+	xlp_usb_hw_start(ctrl_no);
+
+	return usb_hcd_pci_probe(dev, id);
+}
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -75,6 +126,15 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	 * init and reset; they are located here too.
 	 */
 	switch (pdev->vendor) {
+	case PCI_VENDOR_ID_NETLOGIC:
+		if (pdev->device == 0x1007) {
+#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
+			ehci->big_endian_mmio = 1;
+#else
+			ehci->big_endian_mmio = 0;
+#endif
+		}
+		break;
 	case PCI_VENDOR_ID_TOSHIBA_2:
 		/* celleb's companion chip */
 		if (pdev->device == 0x01b5) {
@@ -383,10 +443,22 @@ static const struct ehci_driver_overrides pci_overrides __initconst = {
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
+#ifdef CONFIG_NLM_XLP
+	{
+		.vendor		 = PCI_VENDOR_ID_NETLOGIC,
+		.device		 = XLP_DEVID_EHCI,
+		.subvendor	 = 0,
+		.subdevice	 = 0,
+		.class		 = PCI_CLASS_SERIAL_USB_EHCI,
+		.class_mask	 = ~0,
+		.driver_data =	(unsigned long) &ehci_pci_hc_driver,
+	},
+#else
 	/* handle any USB 2.0 EHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	}, {
+#endif
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),
 	.driver_data = (unsigned long) &ehci_pci_hc_driver,
 	},
@@ -398,8 +470,11 @@ MODULE_DEVICE_TABLE(pci, pci_ids);
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
+#ifdef CONFIG_NLM_XLP
+	.probe =	xlp_ehci_hcd_pci_probe,
+#else
 	.probe =	usb_hcd_pci_probe,
+#endif
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
-- 
1.8.4.93.g57e4c17

