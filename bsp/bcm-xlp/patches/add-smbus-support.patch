From f108eaaa8d719a691703256e31fd000edf17f07e Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 15 Mar 2011 14:56:41 -0700
Subject: [PATCH 189/565] add smbus support

add smbus support function xlp_i2c_smbus_xfer function

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/i2c/busses/i2c-xlp.c | 91 ++++++++++++++++++++++++++++++++++++++------
 1 file changed, 80 insertions(+), 11 deletions(-)

diff --git a/drivers/i2c/busses/i2c-xlp.c b/drivers/i2c/busses/i2c-xlp.c
index a8d9daf..9fd2cfa 100644
--- a/drivers/i2c/busses/i2c-xlp.c
+++ b/drivers/i2c/busses/i2c-xlp.c
@@ -306,19 +306,33 @@ xlp_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
 {
 	struct i2c_xlp_data *adap = i2c_adap->algo_data;
 	struct i2c_msg *p;
-	int i, err = 0;
+	int err = 0, command, len;
 
-
-	for (i = 0; !err && i < num; i++) {
-		p = &msgs[i];
-		if(!p)
-			break;
-	/*printk("[%s] p %x addr: 0x%x len: %d  num:%d \n",__func__, p, p->addr,p->len, num);*/
-		if (p->flags & I2C_M_RD)
-			err = xlp_i2c_read(adap, p->addr, 0, 0, p->len, p->buf);
-		else
-			err = xlp_i2c_write(adap, p->addr,0, 0, p->len, p->buf);
+	command = msgs[0].buf[0];
+	if(num == 1) {
+		p = &msgs[0];
+		if(p && p->len == 0){
+			len = 1;
+		}
+		else if (p && (p->flags & I2C_M_RD)){
+			len = p->len;
+		}
+		else{
+			len = p->len - 1;
+		}
+	}
+	else if(num == 2) {
+		p = &msgs[1];
+		len = p->len;
 	}
+	else {
+		printk("%s ERR: msg num =%d large than 2\n");
+		return -1;
+	}
+	if (p->flags & I2C_M_RD)
+		err = xlp_i2c_read(adap, p->addr, command, 0, len, &p->buf[0]);
+	else
+		err = xlp_i2c_write(adap, p->addr, command, 0, len, &p->buf[1]);
 
 	/* Return the number of messages processed, or the error code.
 	*/
@@ -329,6 +343,60 @@ xlp_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
 	return err;
 }
 
+static int
+xlp_i2c_smbus_xfer(struct i2c_adapter *i2c_adap,
+		u16 		addr,
+		unsigned short	flags,
+		char		read_write,
+		u8 		command,
+		int 		protocol,
+		union i2c_smbus_data *data
+		)
+{
+	struct i2c_xlp_data *adap = i2c_adap->algo_data;
+	int err;
+	int len;
+
+	switch(protocol)
+	{
+	case I2C_SMBUS_BYTE:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 1, &data->byte);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 1, &command);
+
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 1, &data->byte);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 1, &data->byte);
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+	case I2C_SMBUS_PROC_CALL:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 2, (u8 *)&data->word);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 2, (u8 *)&data->word);
+
+		break;
+	case I2C_FUNC_SMBUS_BLOCK_DATA:
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		len = (data->block[0] > I2C_SMBUS_BLOCK_MAX) ? I2C_SMBUS_BLOCK_MAX: data->block[0];
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, len, &data->block[1]);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, len, &data->block[1]);
+
+		break;
+	default:
+		err = -1;
+
+	}
+	return err;
+}
+
 static uint32_t
 xlp_i2c_func(struct i2c_adapter *adap)
 {
@@ -337,6 +405,7 @@ xlp_i2c_func(struct i2c_adapter *adap)
 
 static const struct i2c_algorithm xlp_i2c_algo = {
 	.master_xfer	= xlp_i2c_xfer,
+	.smbus_xfer	= xlp_i2c_smbus_xfer,
 	.functionality	= xlp_i2c_func,
 };
 
-- 
1.8.4.93.g57e4c17

