From ea52ba175f1b14450af20f6293c9d45459190504 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 22 Apr 2013 17:25:35 +0800
Subject: [PATCH 303/565] enable mips-compliant hardware pagewalker

enable mips-compliant hardware pagewalker for XLP1XX etc.

Based on Broadcom SDK 2.3.

Signed-off-by: Yongjun Zhang <yzhang@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/mmu.c | 29 +++++++++++++++++++----------
 1 file changed, 19 insertions(+), 10 deletions(-)

diff --git a/arch/mips/netlogic/xlp/mmu.c b/arch/mips/netlogic/xlp/mmu.c
index 8d130bf..a654e25 100644
--- a/arch/mips/netlogic/xlp/mmu.c
+++ b/arch/mips/netlogic/xlp/mmu.c
@@ -37,7 +37,7 @@
 
 #define _PMD_T_LOG2 3
 
-static int __cpuinitdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB | ENABLE_PGWALKER);
+static int __initdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB | ENABLE_PGWALKER);
 
 int __init disable_etlb(char *str)
 {
@@ -74,7 +74,15 @@ static int pgtable_levels = PGD | PMD | PTE;
 static int pgtable_levels = PGD | PTE;
 #endif
 
-static void __cpuinit pgwalker_init(void)
+static int is_hwpw_mips_compliant(uint32_t proc_id)
+{
+	return (proc_id == CHIP_PROCESSOR_ID_XLP_3XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_2XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_1XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_9XX);
+}
+
+static void pgwalker_init(void)
 {
 	unsigned int value;
 	int i = 0;
@@ -145,7 +153,7 @@ static void __cpuinit pgwalker_init(void)
 	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
 }
 
-static void pgwalker_init_xlp2xx(void)
+static void pgwalker_init_mips_compliant(void)
 {
 	int i = 0;
 	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0, bd_shift = 0;
@@ -223,7 +231,7 @@ void dump_pgwalker_config(void)
 	int i = 0;
 	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0;
 	uint32_t pwctl_val = 0;
-        int is_soc_xlp2xx = (get_proc_id() == CHIP_PROCESSOR_ID_XLP_2XX);
+	int hwpw_mips_compliant = is_hwpw_mips_compliant(get_proc_id());
 
 	pgw_print_w(PGW_MMU_INFO);
 	pgw_print_w(PGW_PGD_SHIFT);
@@ -239,7 +247,7 @@ void dump_pgwalker_config(void)
 	for(i = 0; i < NR_ADDR_SEGMENTS; i++) {
 		printk("pgd_bases[%d] = 0x%lx\n", i, __get_cpu_var(pgd_bases)[i]);
 	}
-	if (is_soc_xlp2xx) {
+	if (hwpw_mips_compliant) {
 		pwbase_val = read_c0_pwbase();
 		pwfield_val = read_c0_pwfield();
 		pwsize_val = read_c0_pwsize();
@@ -276,10 +284,11 @@ static void pgwalker_workaround_setup(void)
 static void pgwalker_workaround_setup(void) {}
 #endif
 
-void __cpuinit mmu_init(void)
+void mmu_init(void)
 {
 	uint32_t config4_val = 0;
-	int is_soc_xlp2xx = (get_proc_id() == CHIP_PROCESSOR_ID_XLP_2XX);
+	uint32_t proc_id = get_proc_id();
+	int hwpw_mips_compliant = is_hwpw_mips_compliant(proc_id);
 
 	/* For XLP832 A0-A2 chips, the page walker needs to be shutdown to
 	 * prevent potential errors.
@@ -302,7 +311,7 @@ void __cpuinit mmu_init(void)
 		   read_c0_config7());
 #endif
 
-	if (is_soc_xlp2xx) {
+	if (hwpw_mips_compliant) {
 		/* set config4 to use 64KB page */
 		config4_val = read_c0_config4();
 		config4_val &= ~(((uint32_t)0x1f) << CFG4_FTLBPAGESIZE_O); /*clear 5-bit width field*/
@@ -318,8 +327,8 @@ void __cpuinit mmu_init(void)
 	pagegrain_write(pagegrain_read() | READ_INHIBIT);
 #endif
 
-	if (is_soc_xlp2xx) {
-		pgwalker_init_xlp2xx();
+	if (hwpw_mips_compliant) {
+		pgwalker_init_mips_compliant();
 	} else {
 		pgwalker_init();
 	}
-- 
1.8.4.93.g57e4c17

