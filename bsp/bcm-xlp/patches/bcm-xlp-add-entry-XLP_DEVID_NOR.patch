From 49453fc6ab74d77bec996c833ce87251345f053a Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 15 Apr 2011 15:01:10 -0700
Subject: [PATCH 211/565] bcm-xlp: add entry XLP_DEVID_NOR

Add entry XLP_DEVID_NOR for pnor flash.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/platform.c | 262 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 262 insertions(+)
 create mode 100644 arch/mips/netlogic/xlp/platform.c

diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
new file mode 100644
index 0000000..b4240d6
--- /dev/null
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -0,0 +1,262 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/pci.h>
+#include <linux/serial_reg.h>
+#include <linux/spinlock.h>
+
+#include <asm/time.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+#define XLP_SOC_PCI_DRIVER "XLP SoC Driver"
+#define DEV_IRT_INFO		0x3D
+
+#define XLP_MAX_DEVICE		8
+#define XLP_MAX_FUNC		8
+#define MAX_DEV2DRV		10
+#define MAX_NUM_UARTS		4
+#define UART_CLK 		133333333
+#define XLP_UART_PORTIO_OFFSET	0x1000
+
+static struct plat_serial8250_port xlp_uart_port[MAX_NUM_UARTS];
+
+static u64 xlp_dev_dmamask = DMA_BIT_MASK(32);
+
+enum driverType{
+	PLAT_DRV = 0,
+	PCI_DRV	 = 1
+};
+
+struct dev2drv {
+	uint32_t 	devid;
+	uint8_t 	drvname[16];
+	uint8_t 	len;
+	uint8_t 	id;
+	uint8_t		drivetype;
+};
+
+unsigned int xlp_uart_in(struct uart_port *p, int offset) {
+
+	nlm_reg_t *mmio;
+	unsigned int value;
+
+	/* XLP uart does not need any mapping of regs 
+	 */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	value = netlogic_read_reg(mmio, 0);
+
+	return value;
+}
+
+void xlp_uart_out(struct uart_port *p, int offset, int value)
+{
+	nlm_reg_t *mmio;
+
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	netlogic_write_reg(mmio, 0, value);
+}
+
+static void xlp_init_uart(int port_id)
+{
+        xlp_uart_port[port_id].mapbase       = DEFAULT_NETLOGIC_IO_BASE 
+						+ NETLOGIC_IO_UART_0_OFFSET + port_id * XLP_UART_PORTIO_OFFSET;
+        xlp_uart_port[port_id].membase       = (void __iomem *)xlp_uart_port[port_id].mapbase;
+        xlp_uart_port[port_id].irq           = PIC_UART_0_IRQ + port_id;
+
+        xlp_uart_port[port_id].uartclk       = UART_CLK;
+        xlp_uart_port[port_id].iotype        = UPIO_NLM;
+        xlp_uart_port[port_id].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
+        xlp_uart_port[port_id].type          = PORT_16550A;
+        xlp_uart_port[port_id].regshift      = 2;
+        xlp_uart_port[port_id].serial_in     = xlp_uart_in;
+        xlp_uart_port[port_id].serial_out    = xlp_uart_out;
+}
+
+static void xlp_usb_hw_start(int ctrl_no)
+{
+	int val;
+
+	/* reset USB phy 
+	 */
+	val = usb_reg_read( 0, ctrl_no, XLP_USB_PHY0);
+
+	if(ctrl_no == 0)
+		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
+	else if(ctrl_no == 3)
+		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
+
+	usb_reg_write(0, ctrl_no, XLP_USB_PHY0, val);
+
+	udelay(2000);
+
+	val = usb_reg_read( 0, ctrl_no, XLP_USB_CTL0);
+	val &= ~(USBCONTROLLERRESET );
+	val |= 0x4;
+	usb_reg_write(0, ctrl_no, XLP_USB_CTL0, val);
+
+	return;
+}
+
+struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
+	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
+	{XLP_DEVID_I2C,	 "i2c-xlp",	8,	0, 	PLAT_DRV},
+	{XLP_DEVID_MMC,	 "mmc-xlp",	8,	0, 	PLAT_DRV},
+	{XLP_DEVID_SPI,	 "spi-xlp",	8,	0, 	PLAT_DRV},
+	{XLP_DEVID_NOR,	 "nor-xlp",	8,	0, 	PLAT_DRV},
+	{0x0, 			 "",	0,	0,	PLAT_DRV},
+};
+
+static int get_dev2drv(uint32_t x) 
+{
+	int i;
+
+	for(i=0; i<MAX_DEV2DRV; i++) {	
+		if(x == dev2drv_table[i].devid)
+			return i;
+	}
+	return i;
+}
+
+static int xlp_find_pci_dev(void)
+{
+	uint16_t i, j, id, idx = 0;
+	volatile uint64_t mmio;
+	uint32_t val, devid, vid, irt, irq;
+	struct platform_device* pplatdev;
+	struct resource* pres;
+
+	pres = (struct resource*) kmalloc(sizeof(struct resource) * 2, 
+			GFP_KERNEL);
+	if(!pres) {
+		printk("kmalloc struct resource failedi!\n");
+		return -ENOMEM;
+	}
+
+	for (i=0; i<XLP_MAX_DEVICE; i++) {
+
+		for (j=0; j<XLP_MAX_FUNC; j++) {
+
+			mmio = nlm_hal_get_dev_base(0, 0, i, j);
+			val  = nlm_hal_read_32bit_reg(mmio, 0);
+
+			if(val != 0xFFFFFFFF) {
+
+				devid	= (val & 0xFFFF0000) >> 16;
+				vid 	= (val & 0xFFFF);
+				idx 	= get_dev2drv(devid);
+
+				if(idx >= 0 && idx < MAX_DEV2DRV) {
+
+					if(dev2drv_table[idx].drivetype == PLAT_DRV) {
+
+						id = dev2drv_table[idx].id;
+
+						if (devid == XLP_DEVID_EHCI) {
+							if(id == 1)
+								id = 3;
+						}
+
+						if( devid == XLP_DEVID_OHCI) {
+							if(id < 2)
+								id = id + 1;
+							else if (id >=2)
+								id = id + 2;
+						}
+
+						if (devid == XLP_DEVID_UART)
+							id += PLAT8250_DEV_PLATFORM;
+
+						pplatdev =  platform_device_alloc(
+								(const char*)dev2drv_table[idx].drvname, id);
+						if (!pplatdev) {
+							printk("platform_device_alloc  failed!\n");
+							continue;
+						}
+
+						if(devid == XLP_DEVID_UART) {
+							pplatdev->dev.platform_data = &xlp_uart_port[dev2drv_table[idx].id];
+							xlp_init_uart(dev2drv_table[idx].id);
+						}
+
+						dev2drv_table[idx].id = dev2drv_table[idx].id + 1;	
+
+						pres[0].start	= mmio;
+						pres[0].end		= mmio;
+						pres[0].flags	= IORESOURCE_MEM;
+
+						irt = (nlm_hal_read_32bit_reg(mmio, DEV_IRT_INFO) & 0xFFFF);
+					   	if(nlm_hal_is_shared_irt(irt))
+							irq = nlm_hal_request_shared_irq(irt);
+						else
+							irq = nlm_hal_irt_to_irq(irt);
+
+						pres[1].start	= irq;
+						pres[1].end		= irq;
+						pres[1].flags	= IORESOURCE_IRQ;
+
+						platform_device_add_resources(pplatdev, pres, 2);
+
+						pplatdev->dev.dma_mask	= &xlp_dev_dmamask;
+
+						pplatdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+						platform_device_add( pplatdev);
+					}
+				}
+			}
+		}
+	}
+	kfree(pres);
+	return 0;	
+}
+static int __init platform_devinit(void)
+{
+	xlp_find_pci_dev();
+#ifdef CONFIG_USB
+	xlp_usb_hw_start(0);
+	xlp_usb_hw_start(3);
+#endif
+	return 0;
+}
+
+static void __init platform_devexit(void)
+{
+	return;
+}
+
+module_init(platform_devinit);
+module_exit(platform_devexit);
-- 
1.8.4.93.g57e4c17

