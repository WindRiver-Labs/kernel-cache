From a4eaaae5776131cbeb8b43cb98e5a5ddc7b2cb57 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Mon, 31 May 2010 03:27:36 -0700
Subject: [PATCH 039/565] multiple fix for msgring interrupt

Multiple fix for msgring interrupt mechanism.
Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c | 153 ++++++++++++++++++++++-----------------
 1 file changed, 86 insertions(+), 67 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index ab6af26..a29990b 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -29,7 +29,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/spinlock.h>
 #include <linux/module.h>
 #include <linux/timer.h>
-#include <linux/slab.h>
 
 #include <asm/netlogic/msgring.h>
 #include <asm/netlogic/iomap.h>
@@ -38,7 +37,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlr_user_mac.h>
 #include <asm/netlogic/sim.h>
 
-#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
@@ -48,6 +48,7 @@ extern int xlr_loader_sharedcore;
 extern int xlr_loader_own_gmac;
 extern int xlr_loader_own_dma;
 int msgring_timer_irq;
+extern uint32_t xlp_linux_cpu_mask;
 
 #define MSGRNG_CC_INIT_CPU_DEST(conf, dest,cpu) \
 do { \
@@ -128,41 +129,64 @@ extern int xlr_napi_ready;
 extern void xlr_napi_rx_schedule(void);
 #endif				/* CONFIG_NLMCOMMON_MSGRING_NAPI */
 
-struct tx_stn tx_stns[MAX_TX_STNS];
-
-int rxstn_to_txstn_map[128] = {
-	[0 ... 7] = TX_STN_CPU_0,
-	[8 ... 15] = TX_STN_CPU_1,
-	[16 ... 23] = TX_STN_CPU_2,
-	[24 ... 31] = TX_STN_CPU_3,
-	[32 ... 39] = TX_STN_CPU_4,
-	[40 ... 47] = TX_STN_CPU_5,
-	[48 ... 55] = TX_STN_CPU_6,
-	[56 ... 63] = TX_STN_CPU_7,
-	[64 ... 95] = TX_STN_INVALID,
-	[96 ... 103] = TX_STN_GMAC,
-	[104 ... 107] = TX_STN_DMA,
-	[108 ... 111] = TX_STN_INVALID,
-	[112 ... 113] = TX_STN_XGS_0,
-	[114 ... 115] = TX_STN_XGS_1,
-	[116 ... 119] = TX_STN_INVALID,
-	[120 ... 127] = TX_STN_SEC
+struct tx_stn tx_stns[XLP_MAX_TX_STNS];
+
+/*
+int stnid_to_index[XLP_MAX_TX_STNS] = {
+	XLP_MSG_HANDLE_CPU0,          
+	XLP_MSG_HANDLE_CPU1,         
+	XLP_MSG_HANDLE_CPU2,          
+	XLP_MSG_HANDLE_CPU3,         
+	XLP_MSG_HANDLE_CPU4,          
+	XLP_MSG_HANDLE_CPU5,          
+	XLP_MSG_HANDLE_CPU6,          
+	XLP_MSG_HANDLE_CPU7,          
+	XLP_MSG_HANDLE_PCIE0,         
+	XLP_MSG_HANDLE_PCIE1,         
+	XLP_MSG_HANDLE_PCIE2,
+	XLP_MSG_HANDLE_PCIE3,
+	XLP_MSG_HANDLE_GDX,
+	XLP_MSG_HANDLE_RSA_ECC,
+	XLP_MSG_HANDLE_CRYPTO,
+	XLP_MSG_HANDLE_CMP,
+	XLP_MSG_HANDLE_POE,
+	XLP_MSG_HANDLE_NAE_TX,
+	XLP_MSG_HANDLE_NAE_RX,
+	XLP_MSG_HANDLE_INVALID,
 };
-
-int xls_rxstn_to_txstn_map[128] = {
-        [0 ... 7] = TX_STN_CPU_0,
-        [8 ... 15] = TX_STN_CPU_1,
-	[16 ... 23] = TX_STN_CPU_2,
-	[24 ... 31] = TX_STN_CPU_3,
-        [32 ... 80] = TX_STN_INVALID,
-	[80 ... 87] = TX_STN_GMAC1,
-	[96 ... 103] = TX_STN_GMAC0,
-	[104 ... 107] = TX_STN_DMA,
-	[108 ... 111] = TX_STN_CMP,
-	[112 ... 115] = TX_STN_INVALID,
-	[116 ... 119] = TX_STN_PCIE,
-	[120 ... 121] = TX_STN_SEC,
-	[122 ... 127] = TX_STN_INVALID,
+*/
+
+int rxstn_to_txstn_map[1024] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 85] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_CPU4,
+	[208 ... 223] = XLP_MSG_HANDLE_CPU5,
+	[224 ... 239] = XLP_MSG_HANDLE_CPU6,
+	[240 ... 255] = XLP_MSG_HANDLE_CPU7,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 271] = XLP_MSG_HANDLE_GDX,
+	[272 ... 280] = XLP_MSG_HANDLE_RSA_ECC,
+	[281 ... 296] = XLP_MSG_HANDLE_CRYPTO,
+	[297 ... 304] = XLP_MSG_HANDLE_CMP,
+	[305 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_POE,
+	[392 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 999] = XLP_MSG_HANDLE_NAE_TX,
+	[1000 ... 1019] = XLP_MSG_HANDLE_NAE_RX,
+	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID
 };
 
 void dummy_handler(int bucket, int size, int code, int tx_stid,
@@ -184,8 +208,7 @@ void nlm_common_msgring_cpu_init(void)
 	unsigned long flags;
 	int shared_msgring = 0;
 
-//	id = cpu_logical_map(get_cpu());
-	id = 0;
+	id = cpu_logical_map(get_cpu());
 
 	msgring_int_en = 1;
 
@@ -484,9 +507,12 @@ void msgring_process_rx_msgs(int start_bucket, int end_bucket,
 	struct tx_stn_handler *handler = 0;
 	unsigned int status = 0;
 
+printk("[%s] \n", __FUNCTION__);
+
 #ifdef CONFIG_NLMCOMMON_MSGRING_NAPI
 	if (xlr_napi_ready && in_irq()) {
 		xlr_napi_rx_schedule();
+printk("xlr_napi_rx_schedule\n");
 		return;
 	}
 #endif				/* CONFIG_NLMCOMMON_MSGRING_NAPI */
@@ -497,6 +523,7 @@ void msgring_process_rx_msgs(int start_bucket, int end_bucket,
 		bucket_empty_bm =
 		    (msgrng_read_status() >> 24) & pop_bucket_mask;
 
+printk("bucket_empty_bm:%d pop_bucket_mask %d \n", bucket_empty_bm, pop_bucket_mask);
 		/* all buckets empty, break */
 		if (bucket_empty_bm == pop_bucket_mask)
 			break;
@@ -514,6 +541,7 @@ void msgring_process_rx_msgs(int start_bucket, int end_bucket,
 				continue;
 
 			handler = &tx_stn_handler_map[rx_stid];
+printk("rx_stid:%d  \n", rx_stid);
 			/* Handler is always present. If not actual, atleast 
 			 * dummy_handler
 			 */
@@ -539,6 +567,7 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned long mflags;
 	int core;
 	__u32 cycles = 0;
+printk("[%s] \n",__FUNCTION__);
 
 	if (irq == IRQ_MSGRING) {
 		/* normal message ring interrupt */
@@ -550,15 +579,14 @@ void nlm_common_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	irq_enter();
 
-	//dbg_msg("IN irq=%d\n", irq);
+	dbg_msg("[%s] IN irq=%d\n",__function__, irq);
 
 	/* TODO: not necessary to disable preemption */
 	msgrng_flags_save(mflags);
 
 	cycles = read_c0_count();
 
-//	core = cpu_logical_map(smp_processor_id()) >> 2;
-	core = 0;
+	core = cpu_logical_map(smp_processor_id()) >> 2;
 	msgring_process_rx_msgs(pop_bucket_start[core], pop_bucket_end[core], pop_bucket_mask[core]);
 
 	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
@@ -591,9 +619,11 @@ static void enable_msgring_int(void *info)
 #endif
 
 	/* enable the message ring interrupts */
+/*
 	msgrng_write_config((msgring_watermark_count << 24) |
 			    (IRQ_MSGRING << 16)
 			    | (th_mask << 8) | msgring_int_type);
+*/
 	msgrng_access_restore(&msgrng_lock, flags, mflags);
 }
 
@@ -624,14 +654,14 @@ int register_msgring_handler(int major,
 {
 	struct tx_stn_handler *handler = 0;
 	int ret = 1;
-	int i,j,tx_stid;
+	int i,j,tx_stid, handle_index;
 	unsigned long flags = 0;
 	cpumask_t timer_cpu_mask;
 
-	if (major >= MAX_TX_STNS || action == NULL) {
+	if (major >= XLP_MAX_TX_STNS || action == NULL) {
 		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
-		       "MAX_TX_STN=%d action=%p",
-		       __FUNCTION__, __LINE__, major, MAX_TX_STNS, action);
+		       "XLP_MAX_TX_STN=%d action=%p",
+		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
 		return ret;
 	}
 
@@ -639,17 +669,15 @@ int register_msgring_handler(int major,
 	spin_lock_irqsave(&msgrng_lock, flags);
 
 	for (i = 0; i < 128; i++) {
-		if (is_xls())
-			tx_stid = xls_rxstn_to_txstn_map[i];
-		else
-			tx_stid = rxstn_to_txstn_map[i];
+		tx_stid = rxstn_to_txstn_map[i];
 		if (tx_stid == major) {
+printk("[%s]tx_stid : %x\n",__FUNCTION__, tx_stid);
 			tx_stn_handler_map[i].action = action;
 			tx_stn_handler_map[i].dev_id = dev_id;
 		}
 	}
 
-	handler = &tx_stns[major].handler;
+	handler = &tx_stns[tx_stid].handler;
 
 	// dbg_msg("major=%d, action=%p, dev_id=%p\n", major, action, dev_id);
 	handler->action = action;
@@ -663,10 +691,9 @@ int register_msgring_handler(int major,
 
 		hard_cpu_online_map = 0;
 		for (i = 0; i < NR_CPUS; i++) {
-			//if (cpu_isset(i, hard_cpu_online_map))
+			if (cpu_isset(i, cpu_online_map))
 				hard_cpu_online_map |=
-//				    (1 << cpu_logical_map(i));
-					0;
+				    (1 << cpu_logical_map(i));
 		}
 
 		/* derive the cpu to bucket map */
@@ -709,16 +736,10 @@ int register_msgring_handler(int major,
 						break;
 				}
 				phys_id = (i*NR_CPUS_PER_CORE) + j;
-				//logical_id = cpu_number_map(phys_id);
-				logical_id = 0;
+				logical_id = cpu_number_map(phys_id);
 				cpu_set(logical_id, timer_cpu_mask);
 			}
 		}
-		preempt_disable();
-		smp_call_function_many(&timer_cpu_mask, enable_msgring_timer, NULL, 1);
-		preempt_enable();
-		//if(cpu_isset(cpu_number_map(hard_smp_processor_id()),timer_cpu_mask))
-			enable_msgring_timer(NULL);
 	}
 
 	return ret;
@@ -789,28 +810,26 @@ void on_chip_init(void)
 {
 	int i = 0, j = 0;
 
-	//cpu_logical_map(0)  = hard_smp_processor_id();
+	cpu_logical_map(0)  = hard_smp_processor_id();
 
 	/* Set netlogic_io_base to the run time value */
 	spin_lock_init(&msgrng_lock);
 
 	msgring_registered.value = 0;
 
-#if defined(CONFIG_NLM_XLP)
 	nlm_hal_init();
-#endif
 
-	nlm_common_msgring_config();
+	nlm_hal_fmn_init( xlp_linux_cpu_mask );
 
+	nlm_common_msgring_config();
+	
 	pic_init(); 
 
 	/* XLP FMN code Not Yet ported! */
 #if !defined(CONFIG_NLM_XLP)
-	nlm_common_msgring_cpu_init();
+//	nlm_common_msgring_cpu_init();
 #endif
 
-
-
 	for (i = 0; i < NR_CPUS; i++)
 		for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
-- 
1.8.4.93.g57e4c17

