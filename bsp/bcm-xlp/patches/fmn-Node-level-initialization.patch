From f8d42f42409eeaa0c4a9140bcbe7aab887612a85 Mon Sep 17 00:00:00 2001
From: "P. Sadik" <psadik@broadcom.com>
Date: Wed, 14 Nov 2012 15:39:49 +0530
Subject: [PATCH 424/565] fmn : Node level initialization

    Instead of one cpu initialize all the stations, each node cpu
    initializes its stations.
    Added timeout feature in the msgring driver.

    The changes were pulled in from linux-2.6.32:

    commit 4331742cecdd72e4bf54f951b032fe0b827a5c55
    Author:     Hareesh R <hareeshr@broadcom.com>
    AuthorDate: Mon Nov 5 09:30:24 2012 +0530
    Commit:     Hareesh R <hareeshr@broadcom.com>
    CommitDate: Mon Nov 5 09:35:02 2012 +0530

Based on Broadcom SDK 2.3.

Signed-off-by: P. Sadik <psadik@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/smp.c | 48 +++++++++++++++++++++++++++++++++++---------
 drivers/char/nlm_msgring.c   | 27 +++++++++++++++++++------
 2 files changed, 60 insertions(+), 15 deletions(-)

diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 22b5904..29a15ca 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -37,6 +37,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/cacheops.h>
 
 #include <asm/netlogic/xlp.h>
+#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/xlp_irq.h>
 #ifdef CONFIG_XLP_FMN_SUPPORT
@@ -74,6 +75,7 @@ extern void enable_msgconfig_int(void);
 void nlm_enable_vc_intr(void);
 #endif
 extern void xlp_pic_ite_init(const struct cpumask *);
+static int node_exist[NLM_MAX_NODES];
 
 /*
  * Input parameter is logical cpu number.
@@ -142,18 +144,20 @@ void nlm_smp_finish(void)
 	local_irq_enable();
 }
 
+
 int irq_select_affinity_usr(unsigned int irq);
 void xlp_prog_all_node_ites(void );
+
+static long fmn_config(void *arg)
+{
+        extern void *fdt;
+        printk("Doing fmn init from cpu %d for node %d\n", hard_smp_processor_id(), (int)(long)arg);
+        nlm_hal_fmn_init(fdt, (int)(long)arg);
+        return 0;
+}
+
 void nlm_cpus_done(void)
 {
-#ifdef CONFIG_XLP_FMN_SUPPORT
-	int node = 0;
-	extern void *fdt;
-	nlm_hal_fmn_init(fdt, node);
-	
-	/* Enable vc interupts for the online cpus */
-	nlm_enable_vc_intr();
-#endif
 	xlp_prog_all_node_ites();
 #if defined CONFIG_XLP_REPLACE_R4K_TIMER
 	irq_select_affinity_usr(XLP_TIMER_IRQ(0));
@@ -207,7 +211,7 @@ void __init nlm_smp_setup(void)
 	cpumask_clear(&phys_cpu_present_map);
 	cpu_set(0, cpu_possible_map);
 	cpu_set(boot_cpu, phys_cpu_present_map);
-
+	node_exist[boot_cpu / NLM_NCPUS_PER_NODE] = (boot_cpu << 16) | 1;
 	/* Setup map for other cpus */
 	for (i = 0; i < NR_CPUS; i++) {
 
@@ -220,6 +224,8 @@ void __init nlm_smp_setup(void)
 			cpu_set(num_cpus, cpu_possible_map);
 			cpu_set(i, phys_cpu_present_map);
 			num_cpus++;
+			if(node_exist[i / NLM_NCPUS_PER_NODE] == 0)
+				 node_exist[i/ NLM_NCPUS_PER_NODE] = (i << 16) | 1;
 		}
 	}
 	cpu_present_map = cpu_possible_map;
@@ -371,3 +377,27 @@ void prom_boot_cpus_secondary(void *args)
 	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp,
 		     smp_boot.boot_info[cpu].gp);
 }
+static int __init nlm_fmn_init(void)
+{
+        extern void *fdt;
+        int node, rv;
+
+        /* Better to do node level fmn initialization */
+        if(get_dom_fmn_node_ownership(fdt, 0)) {
+                for(node = 0; node < NLM_MAX_NODES; node++) {
+                        if(!node_exist[node])
+                                continue;
+                        rv = work_on_cpu(node_exist[node] >> 16, fmn_config, (void *)(long)node);
+                        if(rv < 0)
+                                panic("Fmn init failed\n");
+                }
+        } else
+                printk("Skipping FMN initialization due to lack of ownership\n");
+
+        /* Enable vc interupts for the online cpus */
+        nlm_enable_vc_intr();
+
+        return 0;
+
+}
+core_initcall(nlm_fmn_init);
diff --git a/drivers/char/nlm_msgring.c b/drivers/char/nlm_msgring.c
index 0683d65..744959b 100644
--- a/drivers/char/nlm_msgring.c
+++ b/drivers/char/nlm_msgring.c
@@ -45,9 +45,11 @@ static int msgring_major;
 static wait_queue_head_t msgring_wq[NR_CPUS];
 static int msgring_status[NR_CPUS];
 static DEFINE_MUTEX(msgrng_mutex);
+static int msgring_timeout[NR_CPUS];
 
 #define NLM_MSGRING_WAIT_IOC 'm'
 #define NLM_MSGRING_WAIT_VC   _IOWR(NLM_MSGRING_WAIT_IOC, 1, unsigned int *)
+#define NLM_MSGRING_WAIT_TIMEOUT   _IOWR(NLM_MSGRING_WAIT_IOC, 2, unsigned int *)
 extern unsigned int intr_vc_mask[];
 
 
@@ -78,7 +80,7 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 #ifdef CONFIG_32BIT
 	msgrng_access_enable(mflags);
 #endif
-	
+
 	msgring_status[cpu] = 1;
 
 	/* Enable intr on the vcs */
@@ -91,8 +93,10 @@ static ssize_t msgring_read (struct file *filp, char __user *buf, size_t count,
 	msgrng_access_disable(mflags);
 #endif
 	local_irq_restore(flags);
-	
-	wait_event_interruptible(msgring_wq[cpu], (msgring_status[cpu] == 0));
+	if(msgring_timeout[cpu] < 0)
+		 wait_event_interruptible(msgring_wq[cpu], (msgring_status[cpu] == 0));
+	else
+		 wait_event_interruptible_timeout(msgring_wq[cpu], (msgring_status[cpu] == 0), msgring_timeout[cpu]);
 	return 1;
 }
 
@@ -111,7 +115,7 @@ static long msgring_ioctl(struct file *filp, unsigned int cmd,
 {
 	int err = 0, rv, vc = -1;
 	unsigned int  *ptr = (unsigned int *) arg;
-	int cpu;
+	int cpu, timeout;
 
 	switch (cmd) {
 		case NLM_MSGRING_WAIT_VC:
@@ -126,10 +130,20 @@ static long msgring_ioctl(struct file *filp, unsigned int cmd,
 			nlm_xlp_register_intr_vc(cpu, vc);
 			preempt_enable();
 			break;
+
+	       case NLM_MSGRING_WAIT_TIMEOUT:
+			 rv = copy_from_user(&timeout, ptr, sizeof(*ptr));
+			 preempt_disable();
+			 cpu = hard_smp_processor_id();
+			 msgring_timeout[cpu] = timeout;
+			 preempt_enable();
+			 printk("timeout for cpu %d is %d\n", cpu, timeout);
+			 break;
+
 		default:
 			printk("Invalid cmd in %s\n", __FUNCTION__);
 			err = -EINVAL;
-	}	
+	}
 	return err;
 }
 
@@ -162,6 +176,7 @@ static int msgring_init(void)
 
 	for(i = 0; i < NR_CPUS; i++) {
 		init_waitqueue_head(&msgring_wq[i]);
+		msgring_timeout[i] = -1;
 	}
 
 	nlm_xlp_register_intr_vc_handler(msgring_event);
@@ -183,7 +198,7 @@ static void msgring_exit(void)
 	unregister_chrdev (msgring_major, MSGRING_WAIT_CHRDEV_NAME);
 }
 
-	
+
 
 
 module_init(msgring_init);
-- 
1.8.4.93.g57e4c17

