From 4598a75ae51e1d7ad2075bc11c795536b712af06 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 30 Jun 2010 16:37:16 -0700
Subject: [PATCH 056/565] bcm-xlp: clean up debug message and unused code

1. clean up debug message and unused code;
2. change xlp_receive_msg status check logic to reflect no library change.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c | 233 +++++++++++++++++++--------------------
 1 file changed, 112 insertions(+), 121 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 356d11e..f0b02d6 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -36,14 +36,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/debug.h>
 #include <asm/netlogic/sim.h>
 
-#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
-extern uint32_t xlp_linux_cpu_mask;
 
+extern uint32_t xlp_linux_cpu_mask;
 
 uint32_t hard_cpu_online_map = 0;
 uint32_t msgring_global_thread_mask = 0;
@@ -52,19 +51,15 @@ uint32_t msgring_global_thread_mask = 0;
 spinlock_t msgrng_lock;
 static nlm_common_atomic_t msgring_registered;
 
-int msgring_int_type;
-int msgring_int_en;
-int msgring_watermark_count;
 static __u32 msgring_thread_mask;
 
-extern int nlm_dev_own_bucket_list_get(int *start, int *end, int *mask);
-extern struct irq_chip nlm_common_rsvd_pic;
-extern struct irqaction nlm_common_rsvd_action;
+static void msgring_enable_timer_int_handler(void);
 
 struct msgstn_handler {
         void (*action)(uint32_t, uint32_t, uint32_t, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);
         void *dev_id;
 };
+
 static uint16_t vc_to_handle_map[1024] = {
 	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
 	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
@@ -134,6 +129,20 @@ static uint16_t vc_to_handle_map[1024] = {
 	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID
 };
 
+/******************************************************************************************
+ *  dummy_handler 
+ *
+ *  @vc		cpu vc number
+ *  @src_id	msg sender station vc
+ *  @size	msg_size-1
+ *  @code	software code nae or poe can put in
+ *  @msg0	64 bit msg0 structure 
+ *  @msg1	64 bit msg1 structure 
+ *  @msg2	64 bit msg2 structure 
+ *  @msg3	64 bit msg3 structure 
+ *  @dev_id	driver write can save a device id here
+ *
+ ******************************************************************************************/
 void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code, 
 		   uint64_t msg0, uint64_t msg1, uint64_t msg2, uint64_t msg3, void *dev_id)
 {
@@ -143,101 +152,114 @@ void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code,
 	       (unsigned long long)msg0);
 }
 
+/******************************************************************************************
+ *
+ * intial msg_hander_map with dummy_handler, when real driver msgring handler registered
+ * it will override the entry with hander driver writer provided
+ *
+ ******************************************************************************************/
 struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
 	[0 ... (XLP_MSG_HANDLE_MAX-1)] = {dummy_handler, NULL},
 };
 
-
-extern void nlm_cpu_stat_update_msgring_int(void);
-extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
-extern void nlm_cpu_stat_update_msgring_pic_int(void);
-
-#if !defined(CONFIG_NLMCOMMON_MAC) && !defined(CONFIG_NLM_XLP)
-void nlm_cpu_stat_update_msgring_int(void) { }
-void nlm_cpu_stat_update_msgring_cycles(__u32 cycles) { }
-void nlm_cpu_stat_update_msgring_pic_int(void) { }
-#endif /* CONFIG_NLMCOMMON_MAC */
-
-__u32 msgrng_msg_cycles = 0;
+/*********************************************************************
+ * nlm_xlp_msgring_int_handler 
+ *
+ *  @irq	msgring irq number
+ *  @regs	linux systems call back function provide struct pt_regs 
+ *  
+ ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
 	unsigned long mflags;
-	int core, i;
-	__u32 cycles = 0;
+	int core;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
-	uint64_t val;
 
 	msg0 = msg1 = msg2 = msg3 = 0;
 
-	if (irq == IRQ_MSGRING) {
-		/* normal message ring interrupt */
-		xlr_inc_counter(MSGRNG_INT);
-		nlm_cpu_stat_update_msgring_int();
-	} else {
-		nlm_cpu_stat_update_msgring_pic_int();
-	}
-
 	irq_enter();
 
 	core = cpu_logical_map(hard_smp_processor_id()) >> 2;
         msgrng_access_enable(mflags);
-	for( vc = core; vc < (core+4); vc++){
-//		for( i = 0; i < 10; i++) 
-		{
+
+	//for(int i = 0; i < 10; i++) 
+	{
+	for( vc = core; vc < (core+4); vc++)
+	{
 		status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
-		if(status == 0 )
+		if(status != 0)
 			continue;
 		
 		{
-//printk("[%s] status: %x  vc:%d  src_id:%d handler_id %d\n", __FUNCTION__, status, vc, src_id, vc_to_handle_map[src_id]);
+			/*
+			printk("[%s] status: %x  vc:%d  src_id:%d handler_id %d\n", 
+			__FUNCTION__, status, vc, src_id, vc_to_handle_map[src_id]);
+			*/
 			if(src_id >= 0 && src_id < 1024)
 			{
 				handler = &msg_handler_map[vc_to_handle_map[src_id]];
 				(handler->action) (vc, src_id, size, code, msg0, msg1, msg2, msg3, handler->dev_id);
 			}
 		}
-		}
+	}
 	}
         msgrng_access_disable(mflags);
 
-
 	irq_exit();
 }
 
-static void enable_msgring_int(void *info)
+/*******************************************************************************************
+ *  register_xlp_msgring_handler 
+ *
+ *  @major      handler id number, each type handler has an ID
+ *  @action     handler callback function (see dummy_handler above for detail)
+ *  @dev_id	optional dev_id paramter for driver write to save device id
+ *******************************************************************************************/
+int register_xlp_msgring_handler(int major,
+			     void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+					     uint64_t, uint64_t, uint64_t, uint64_t, void *),
+			     void *dev_id)
 {
-#if 0
-	unsigned long flags = 0, mflags = 0;
-	unsigned int th_mask, i;
-	unsigned int core;
-	uint64_t val;
-	msgrng_access_save(&msgrng_lock, flags, mflags);
+	int ret = 1;
+	unsigned long flags = 0;
 
-	core = hard_smp_processor_id() & ~(0x3);
-	th_mask = (msgring_global_thread_mask >> core) & 0x0f;
+	if (major >= XLP_MSG_HANDLE_MAX || action == NULL) {
+		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+		       "XLP_MAX_TX_STN=%d action=%p",
+		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
+		return ret;
+	}
 
-	/* enable the message ring interrupts */
+	/* Check if the message station is valid, if not return error */
+	spin_lock_irqsave(&msgrng_lock, flags);
 
-	for(i = 0; i < 128; i++)
-	{
-		val = nlm_hal_read_outq_config(i);
-		/* clear and then set int level value and high watermark field*/
-		val &= ~(0xfULL << 54);
-		val |= ((uint64_t)HWM_NON_EMPTY << 56)|((uint64_t)LVL_INT_HIGH_WM << 54);	
-		/*enable interrupt*/	
-		if( val & ( 1ULL << 59))
-			val &= ( 1ULL << 59 );
-		nlm_hal_write_outq_config(i, val);
-	}
 
-	msgrng_access_restore(&msgrng_lock, flags, mflags);
-#endif
+	msg_handler_map[major].action = action;
+	msg_handler_map[major].dev_id = dev_id;
+
+	ret = 0;
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+
+	nlm_common_test_and_set(&msgring_registered);
+
+	/* use timer interrupt cpu instead of cpu outq interrupt*/
+	//msgring_enable_timer_int_handler();
+
+	return ret;
 }
 
+EXPORT_SYMBOL(register_xlp_msgring_handler);
+
+/*********************************************************************
+ *  msgring_bkp_timer 
+ *  
+ *  @data     parameter that can be passed to timer handler 
+ *  
+ ********************************************************************/
 static void msgring_bkp_timer(unsigned long data)
 {
 	unsigned long flags;
@@ -248,6 +270,12 @@ static void msgring_bkp_timer(unsigned long data)
 	mod_timer(timer, timer->expires+HZ/10000);
 }
 
+/*********************************************************************
+ *  enable_msgring_timer 
+ *  
+ *  @data     timer hander paramete
+ *
+ ********************************************************************/
 static void enable_msgring_timer(void *data)
 {
 	struct timer_list *timer;
@@ -257,34 +285,19 @@ static void enable_msgring_timer(void *data)
 	add_timer(timer);
 }
 
-int register_xlp_msgring_handler(int major,
-			     void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
-					     uint64_t, uint64_t, uint64_t, uint64_t, void *),
-			     void *dev_id)
+/*********************************************************************
+ *  enable_msgring_timer 
+ *  
+ *  this is xlr inherited routine, here we keep it for test purpose to 
+ *  user timer interrupt to call msgring interrupt handler routine 
+ * 
+ ********************************************************************/
+static void msgring_enable_timer_int_handler()
 {
-	int ret = 1;
-	int i, j, tx_stid=0;
-	unsigned long flags = 0;
+	int i, j;
 	cpumask_t timer_cpu_mask;
 
-	if (major >= XLP_MSG_HANDLE_MAX || action == NULL) {
-		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
-		       "XLP_MAX_TX_STN=%d action=%p",
-		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
-		return ret;
-	}
-
-	/* Check if the message station is valid, if not return error */
-	spin_lock_irqsave(&msgrng_lock, flags);
-
-
-	msg_handler_map[major].action = action;
-	msg_handler_map[major].dev_id = dev_id;
-
-	ret = 0;
-	spin_unlock_irqrestore(&msgrng_lock, flags);
-
-	if (!ret && nlm_common_test_and_set(&msgring_registered)) {
+	if ( nlm_common_test_and_set(&msgring_registered)) {
 		i=0;
 		hard_cpu_online_map = 0;
 		for (i = 0; i < NR_CPUS; i++) {
@@ -293,9 +306,6 @@ int register_xlp_msgring_handler(int major,
 				    (1 << cpu_logical_map(i));
 		}
 
-		/* derive the cpu to bucket map */
-		//nlm_common_derive_cpu_to_bkt_map();
-
 
 		/* Configure PIC to deliver msgring interrupt for timeouts */
 		if (msgring_global_thread_mask == 0) {
@@ -307,22 +317,11 @@ int register_xlp_msgring_handler(int major,
 
 		msgring_global_thread_mask &= hard_cpu_online_map;
 
-		/* configure the msgring interrupt on all cpus */
-		if (msgring_int_en)
-			on_each_cpu(enable_msgring_int, 0, 1);
-
-/* 		printk("[%s]: cpu_online_map = %lx, hard_cpu_online_map=%x, " */
-/* 		       "msgring_global_thread_mask=%x\n", */
-/* 		       __FUNCTION__,  */
-/* 		       (unsigned long)cpu_online_map,  */
-/* 		       hard_cpu_online_map,  */
-/* 		       msgring_global_thread_mask); */
 
 		/* Schedule a messagering backup timer at every 2 jiffies on one 
 		   therad per core 
 		 */
 
-#if 1 
 		cpus_clear(timer_cpu_mask);
 		for(i = 0; i < NR_CORES; i++) {
 			int core_mask;			
@@ -338,24 +337,21 @@ int register_xlp_msgring_handler(int major,
 				cpu_set(logical_id, timer_cpu_mask);
 			}
 		}
-#endif
-#if 1 
                 preempt_disable();
                 smp_call_function_many(&timer_cpu_mask, enable_msgring_timer, NULL, 1);
                 preempt_enable();
                 if(cpu_isset(cpu_number_map(hard_smp_processor_id()),timer_cpu_mask))
                         enable_msgring_timer(NULL);
-#endif
 	}
-//enable_msgring_int(0);
-	return ret;
 }
 
-EXPORT_SYMBOL(register_xlp_msgring_handler);
 
+/*********************************************************************
+ *  pic_init
+ *  
+ ********************************************************************/
 static void pic_init(void)
 {
-//	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_PIC_OFFSET);
 	int i = 0;
 	int level;
 	uint32_t thread_mask = (1 << hard_smp_processor_id());
@@ -364,8 +360,6 @@ static void pic_init(void)
 
 		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
 
-		/* Bind all PIC irqs to boot cpu */
-//		mmio = 0;	/* For compiler sake */
 		/* Use local scheduling and high polarity for all IRTs
 		 * Invalidate all IRTs, by default
 		 */
@@ -375,18 +369,17 @@ static void pic_init(void)
 
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
 
+/*********************************************************************
+ *  nlm_usb_init 
+ *
+ ********************************************************************/
 static void nlm_usb_init (void)
 {
 	volatile unsigned int value;
-//	nlm_reg_t * gpio_mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
 	nlm_reg_t * gpio_mmio = (nlm_reg_t*)xlp_gpio_base;
-//	nlm_reg_t * usb_mmio  = netlogic_io_mmio(NETLOGIC_IO_USB_1_OFFSET);
 
 	/* The NLM-Specific USB Block */
-//	netlogic_write_reg(usb_mmio, 49, 0x10000000); //Clear Rogue Phy INTs
-//	netlogic_write_reg(usb_mmio, 50, 0x1f000000);
 
-//	netlogic_write_reg(usb_mmio,  1, 0x07000500);
 	nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 49, 0x10000000); //Clear Rogue Phy INTs
 	nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 50, 0x1f000000);
 
@@ -395,16 +388,18 @@ static void nlm_usb_init (void)
 	value = gpio_mmio[21];
 	if ((value >> 22) & 0x01) {
 		printk("Detected USB Host mode..\n");
-//		netlogic_write_reg(usb_mmio,  0, 0x02000000);
 		nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 0, 0x02000000);
 	}
 	else {
 		printk("Detected USB Device mode..\n");
-//		netlogic_write_reg(usb_mmio,  0, 0x01000000);
 		nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base,  0, 0x01000000);
 	}
 }
 
+/*********************************************************************
+ * on_chip_init
+ *  
+ ********************************************************************/
 void on_chip_init(void)
 {
 	int i = 0, j = 0;
@@ -418,17 +413,13 @@ void on_chip_init(void)
 
 	nlm_hal_init();
 
-//	nlm_hal_pcie_base();
+	// nlm_hal_pcie_base();
 
 	nlm_hal_fmn_init( xlp_linux_cpu_mask );
 
 	
 	pic_init(); 
 
-#if !defined(CONFIG_NLM_XLP)
-//	nlm_xlp_msgring_cpu_init();
-#endif
-
 	for (i = 0; i < NR_CPUS; i++)
 	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
-- 
1.8.4.93.g57e4c17

