From b024d3e662ab1e4f10e0a06bd57a1f703c57d34f Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 4 Sep 2010 17:31:44 -0700
Subject: [PATCH 127/565] bcm-xlp: use hwemul module parameter

Use hwemul module parameter, deleted trailing whitespace,
hooked up txc/interrupts proc stats.

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/xlp_nae/xlp_nae.c | 149 +++++++++++++++++++-----------------------
 1 file changed, 67 insertions(+), 82 deletions(-)

diff --git a/drivers/net/xlp_nae/xlp_nae.c b/drivers/net/xlp_nae/xlp_nae.c
index 0963e7a..4c53ce9 100644
--- a/drivers/net/xlp_nae/xlp_nae.c
+++ b/drivers/net/xlp_nae/xlp_nae.c
@@ -47,8 +47,8 @@
 #include <linux/mm.h>
 #include <linux/pci.h>
 #include <asm/current.h>
-#include <asm/system.h> 
-#include <asm/uaccess.h> 
+#include <asm/system.h>
+#include <asm/uaccess.h>
 #include <asm/netlogic/msgring.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
@@ -65,11 +65,11 @@
 #define PCI_DEVID_OFF_NET		0
 #define MAX_NUM_UARTS			2
 #define FREE_DEFAULT_SIZE		256
-#define NUM_FREE_DESC			18	
+#define NUM_FREE_DESC			18
 #define FREE_DESC_POOL_WIDTH		20
 #define NUM_FREEIN_QUEUE		18
 #define MAX_NUM_DESC                    32
-#define MIN_FRIN_DESC_THRESHD		16	
+#define MIN_FRIN_DESC_THRESHD		16
 #define MAX_NET_INF             	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
@@ -81,8 +81,6 @@
 #define ETH_MTU_SIZE		 	2048
 #define MIN_ETH_FRAME_SIZE		64
 
-#define  DUMP_RCV_PKT				0	
-#define  DUMP_XMIT_PKT				0
 #define  DUMP_PKT(x, y)	if (debug == 2)  {	\
 	int i;      				\
         for(i = 0; i < y; i++)			\
@@ -93,11 +91,10 @@
         }					\
 	printk("\n"); }
 
-#define RUN_ON_SIM_ONLY			 	0
-#define IP_HEADER_4BYTE_ALIGN_WKAROUND 		0
-
+/* Module Parameters */
 static int debug = 0;
 module_param(debug, int, 0);
+
 static int hwemul = 0;
 module_param(hwemul, int, 0);
 
@@ -136,8 +133,6 @@ spinlock_t  nlm_xlp_nae_lock;
 static void nlm_xlp_sgmii_setcontext(void);
 static void nlm_xlp_nae_init(void);
 static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
-static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf);
-static void mac_send_one_desc(unsigned long dev);
 static int  nlm_xlp_nae_open (struct net_device *dev);
 static int  nlm_xlp_nae_stop (struct net_device *dev);
 static int  nlm_xlp_nae_start_xmit (struct sk_buff *skb, struct net_device *dev);
@@ -147,19 +142,17 @@ static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
 
-static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id, 
-					uint32_t size, uint32_t code,  
-					uint64_t msg0, uint64_t msg1, 
+static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
+					uint32_t size, uint32_t code,
+					uint64_t msg0, uint64_t msg1,
 					uint64_t msg2, uint64_t msg3, void* data);
 
 static void nlm_xlp_mac_timer(unsigned long data);
-static void  nlm_xlp_nae_rx(struct sk_buff* skb, struct net_device *dev);
 static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev);
 
 static struct net_device *dev_mac[MAX_GMAC_PORT];
 struct net_device *dev_mac_type[MAX_XLP_NET_TYPES][MAX_GMAC_PORT];
 
-
 extern struct proc_dir_entry *nlm_root_proc;
 static struct tasklet_struct mac_refill_task[MAX_GMAC_PORT];
 static void mac_refill_frin_desc(unsigned long dev);
@@ -180,8 +173,7 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
-        uint64_t *back_ptr =
-                (uint64_t *)(addr - CACHELINE_SIZE);
+        uint64_t *back_ptr = (uint64_t *)(addr - CACHELINE_SIZE);
         /* this function should be used only for newly allocated packets. It assumes
          * the first cacheline is for the back pointer related book keeping info
          */
@@ -202,7 +194,7 @@ static __inline__ void mac_put_skb_back_ptr(struct sk_buff *skb)
 #define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(CACHELINE_SIZE-1))
 
 /**********************************************************************
- * cacheline_aligned_kmalloc -  64 bits cache aligned kmalloc 
+ * cacheline_aligned_kmalloc -  64 bits cache aligned kmalloc
  * return -  buffer address
  *
  **********************************************************************/
@@ -341,18 +333,18 @@ retry_send:
  *
  **********************************************************************/
 static void mac_refill_frin_desc(unsigned long dev)
-{ 
+{
 	struct dev_data* priv;
 	struct net_device *ndev;
         int ret, mflags, i, code,limit;
         struct xlp_msg msg;
 	struct sk_buff * skb;
 	uint64_t *idx_ptr;
-	
+
 	ndev = (struct net_device *) dev;
 	priv = netdev_priv(ndev);
 	ret = 0;
-	
+
 	/* TODO ALERT: priv->num_desc access needs to atomic */
 	limit = MAX_NUM_DESC - priv->num_desc;
 
@@ -418,7 +410,7 @@ retry_send:
 /**********************************************************************
  * nlm_xlp_nae_init -  xlp_nae device driver init function
  * @dev  -  this is per device based function
- * 
+ *
  **********************************************************************/
 
 static void nlm_xlp_nae_init(void)
@@ -432,14 +424,12 @@ static void nlm_xlp_nae_init(void)
 	printk("======= Module Parameters =========\n");
 	printk("debug = %d, hwemul=%d\n", debug, hwemul);
 
-#define HW_EMULATOR                            1
-#ifdef HW_EMULATOR
-	unsigned long mflags = 0;
-	msgrng_access_enable(mflags);
-        nlm_hal_fmn_init(0xE0000000ULL, 0x1000000, 50);
-	// nlm_hal_dump_outq();
-	msgrng_access_disable(mflags);
-#endif
+	if (hwemul) {
+		unsigned long mflags = 0;
+		msgrng_access_enable(mflags);
+		nlm_hal_fmn_init(0xE0000000ULL, 0x1000000, 50);
+		msgrng_access_disable(mflags);
+	}
 
  	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
@@ -453,29 +443,20 @@ static void nlm_xlp_nae_init(void)
 
 	spin_lock_irq(&nlm_xlp_nae_lock);
 
-	/* initial 18 gmac block */	
+	/* initial 18 gmac block */
         for(i = 0; i < 1/*MAX_NET_INF*/; i++)
 	{
 		/* init_gmac(i); */
 		nlm_hal_open_if(GMAC_IF, i);
 	}
-#if 0
-	/* init tx if credit */	
-	init_tx_if_credit( 0, 0x7FFFF );
-#endif
 
 	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
 	{
 		init_ucore(0xffffUL, i);
 	}
 
-	ucore_load_apps(0xffffUL);	
+	ucore_load_apps(0xffffUL);
 
-#if 0
-	/*  init egress and igress interface */
-	init_ingress();
-	init_egress(); 
-#endif
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
 	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
@@ -489,12 +470,13 @@ static void nlm_xlp_nae_init(void)
         	priv = netdev_priv(dev);
 		priv->dev 	= dev;
 		dev->netdev_ops = &nlm_xlp_nae_ops;
+
 		/* set ethtool_ops which is inside xlp_ethtool.c file*/
 		xlp_set_ethtool_ops(dev);
 
 		/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16);*/
 
-		dev->dev_addr = eth_hw_addr[i];  
+		dev->dev_addr = eth_hw_addr[i];
 		priv->port	= i;
 		priv->num_desc  = 0;
 		priv->inited	= 0;
@@ -509,8 +491,8 @@ static void nlm_xlp_nae_init(void)
 
 		tasklet_init(&mac_refill_task[priv->port],mac_refill_frin_desc,(unsigned long)dev);
 	}
- 
-	entry = create_proc_read_entry("nlm_mac_stats", 0 /* def mode */ ,
+
+	entry = create_proc_read_entry("mac_stats", 0 /* def mode */ ,
 				       nlm_root_proc /* parent */ ,
 				       xlp_mac_proc_read /* proc read function */ ,
 				       0	/* no client data */
@@ -523,8 +505,8 @@ static void nlm_xlp_nae_init(void)
 	spin_lock_irq(&nlm_xlp_nae_lock);
 	for(i = 0; i < FREE_DESC_POOL_WIDTH; i++)
 	{
-		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );	
-		
+		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
+
 		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
 		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
 
@@ -587,13 +569,13 @@ static void nlm_xlp_sgmii_setcontext(void)
 /**********************************************************************
  * nlm_xlp_nae_open -  called when bring up a device interface
  * @dev  -  this is per device based function
- * 
+ *
  **********************************************************************/
 static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
 	int port = priv->port;
-	int ret  = 0, i;
+	int i;
 
 	if (priv->inited) return 0;
 
@@ -620,12 +602,9 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 	priv->link_timer.function = &nlm_xlp_mac_timer;
 	priv->phy_oldlinkstat = -1;
 
-#ifdef RUN_ON_SIM_ONLY
 	add_timer(&priv->link_timer);
-#endif
-/*	napi_enable(&priv->napi);*/
-
 
+/*	napi_enable(&priv->napi);*/
 
 	priv->stats.tx_packets	= 0;
 	priv->stats.tx_errors	= 0;
@@ -655,7 +634,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 /**********************************************************************
  * nlm_xlp_nae_stop -  called when bring down the interface
  * @dev  -  this is per device based function
- * 
+ *
  **********************************************************************/
 static int  nlm_xlp_nae_stop (struct net_device *dev)
 {
@@ -667,7 +646,7 @@ static int  nlm_xlp_nae_stop (struct net_device *dev)
 	del_timer_sync(&priv->link_timer);
 	netif_tx_stop_all_queues(dev);
 
-	napi_disable(&priv->napi);	
+	napi_disable(&priv->napi);
 	spin_unlock_irq(&priv->lock);
 	return 0;
 }
@@ -706,7 +685,7 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	msg.entry[2] = msg.entry[3] = 0;
 
-  	DUMP_PKT(skb->data, skb->len)
+  	DUMP_PKT(skb->data, skb->len);
 
 	__sync();
 
@@ -761,15 +740,15 @@ retry_send:
 }
 
 /**********************************************************************
- * nlm_xlp_set_multicast_list 
+ * nlm_xlp_set_multicast_list
  *
  **********************************************************************/
 static void  nlm_xlp_set_multicast_list (struct net_device *dev)
 {
 	if (dev->flags & IFF_ALLMULTI) {
-		/* 
-		 * Enable ALL multicasts.  Do this by inverting the 
-		 * multicast enable bit. 
+		/*
+		 * Enable ALL multicasts.  Do this by inverting the
+		 * multicast enable bit.
 		 */
 		return;
 	}
@@ -777,7 +756,7 @@ static void  nlm_xlp_set_multicast_list (struct net_device *dev)
 }
 
 /**********************************************************************
- * nlm_xlp_nae_ioctl 
+ * nlm_xlp_nae_ioctl
  *
  **********************************************************************/
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
@@ -793,7 +772,7 @@ static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd
 }
 
 /**********************************************************************
- * nlm_xlp_nae_change_mtu 
+ * nlm_xlp_nae_change_mtu
  *
  **********************************************************************/
 static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
@@ -844,7 +823,7 @@ static struct net_device_stats *nlm_xlp_mac_get_stats(struct net_device *dev)
 /**********************************************************************
  * nlm_xlp_nae_tx_timeout -  called when transmiter timeout
  * @dev  -  this is per device based function
- * 
+ *
  **********************************************************************/
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 {
@@ -865,14 +844,18 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 /**********************************************************************
  * nlm_xlp_nae_int_handler -  interrupt handler
  * @irq     -  irq number
- * @dev_id  -  this device 
- * 
+ * @dev_id  -  this device
+ *
  **********************************************************************/
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 {
         struct net_device *dev;
         struct dev_data *priv;
 	int i;
+	int cpu = 0;
+
+	cpu = hard_smp_processor_id();
+	priv->cpu_stats[cpu].interrupts++;
 
 	if(!dev_id)
 	{
@@ -881,7 +864,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 	}
 	dev = (struct net_device*)dev_id;
     	priv = netdev_priv(dev);
-	
+
 	i = find_irt_from_irq(irq);
 
 
@@ -891,22 +874,23 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 /**********************************************************************
  * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
  * @vc-  virtual channel number
- * @dev_id  -  this device 
- * 
+ * @dev_id  -  this device
+ *
  **********************************************************************/
-static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id, 
-					uint32_t size, uint32_t code,  
-					uint64_t msg0, uint64_t msg1, 
+static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
+					uint32_t size, uint32_t code,
+					uint64_t msg0, uint64_t msg1,
 					uint64_t msg2, uint64_t msg3, void* data)
 {
         struct net_device *pdev;
         struct dev_data *priv;
-	unsigned int len, port = 0, cpu, context;
+	unsigned int len, port = 0, context;
         unsigned char* buf;
         uint64_t addr , vaddr;
 	struct sk_buff* skb;
+	int cpu = 0;
 
-	cpu = vc >> 4;
+	cpu = hard_smp_processor_id();
 	vc = vc & 0x03;
 
        if (debug) {
@@ -942,6 +926,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 				       __func__, addr, skb, context, port);
 			}
 			dev_kfree_skb_any(skb);
+
+                	priv->cpu_stats[cpu].txc_packets++;
 		}
 		else {
 			printk("[%s]: [txc] wrong addr = %llx\n", __func__, addr);
@@ -1031,8 +1017,8 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 /**********************************************************************
  * xlp_mac_proc_read -  proc file system read routine
  * @page     -  buffer address
- * @dev_id  -  this device 
- * 
+ * @dev_id  -  this device
+ *
  **********************************************************************/
 static int xlp_mac_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
@@ -1050,7 +1036,6 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 			continue;
 
 		priv = netdev_priv(dev);
-		
 
 		len += sprintf(page + len,
 			       "per port:  %d %lx %lx %lx %lx\n",
@@ -1059,7 +1044,7 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 			       priv->stats.tx_packets, priv->stats.tx_bytes);
 	}
 	for(cpu=0;cpu<8;cpu++) {
-			len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n", 
+			len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
 				        cpu,
 				       priv->cpu_stats[cpu].tx_packets,
 				       priv->cpu_stats[cpu].txc_packets,
@@ -1076,7 +1061,7 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 	if (len < 0)
 		len = 0;
 
-	return len;	
+	return len;
 }
 
 
@@ -1112,7 +1097,7 @@ static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pc
 static void nlm_xlp_nae_remove(struct net_device * dev)
 {
 	int i;
-        struct dev_data *priv; 
+        struct dev_data *priv;
 
 	for (i = 0; i < MAX_GMAC_PORT; i++)
 	{
@@ -1123,7 +1108,7 @@ static void nlm_xlp_nae_remove(struct net_device * dev)
 		free_netdev(dev);
 	}
 
-	remove_proc_entry("nlm_mac_stats", nlm_root_proc /* parent dir*/ );
+	remove_proc_entry("mac_stats", nlm_root_proc /* parent dir*/ );
 
 }
 
@@ -1152,5 +1137,5 @@ module_exit(nlm_xlp_mac_exit);
 
 MODULE_AUTHOR("Netlogic Microsystems");
 MODULE_DESCRIPTION("Netlogic XLP SoC Network driver ");
-MODULE_LICENSE("GPL"); 
-MODULE_VERSION("0.1"); 
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
-- 
1.8.4.93.g57e4c17

