From 0b686de0ca05d2760559c7549c725f5d3ca817f2 Mon Sep 17 00:00:00 2001
From: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Date: Thu, 7 Feb 2013 14:18:24 +0530
Subject: [PATCH 473/565] nae: configure the MISC_CTRL registers

nae: configure the MISC_CTRL registers correctly.

Based on Broadcom SDK 2.3.

Signed-off-by: Prasanna Mumbai <prasanna.mumbai@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h |  6 ++++
 arch/mips/netlogic/common/nlm_hal_nae.c          | 46 ++++++++++++++++++------
 2 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
index 94f18ad..dae9f42 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
@@ -122,6 +122,12 @@
 
 /*################################*/
 
+#define NETIOR_CMPLX_0_INIT_CREDIT	0
+#define NETIOR_CMPLX_1_INIT_CREDIT	8
+#define NETIOR_CMPLX_2_INIT_CREDIT	16
+#define NETIOR_CMPLX_3_INIT_CREDIT	24
+#define NETIOR_CMPLX_4_INIT_CREDIT	18
+
 struct nae_complex_config {
 	uint32_t num_free_desc[MAX_PORTS_PERBLOCK];
 	uint32_t free_desc_size[MAX_PORTS_PERBLOCK];
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index b9de738..747444b 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -73,7 +73,7 @@ extern int nlm_hal_is_xlp_ilk_lanealigned(int node, int blk);
 extern void nlm_hal_xlp2xx_nae_program_vsemi(int node, int block, int xaui_speed, int phy_mode);
 
 uint32_t *cntx2port[NLM_MAX_NODES];
-
+uint32_t nae_cmplx_fifo_val_min[NLM_MAX_NODES][XLP8XX_MAX_NAE_COMPLEX];
 
 extern void vsemi_mem_init_sgmii_125Mhzrefclk(void);
 extern void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void);
@@ -2605,6 +2605,7 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		nlm_print(" nae_cfg->msec_port_enable = %x block = %d cmplx_cfg.msec_port_enable = %x\n",
 		nae_cfg->msec_port_enable, block, cmplx_cfg.msec_port_enable);
 #endif
+		nae_cmplx_fifo_val_min[node][block] = cmplx_cfg.intf_fifo_size[0] - 1;
 		for(offset = 0; offset < num_ports; offset++, port++) {
 			nae_port = &nae_cfg->ports[port];
 			nae_port->hw_port_id = (block * MAX_PORTS_PERBLOCK) + offset;
@@ -2640,6 +2641,15 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 				return -1;
 			rx_slots += nae_port->rx_slots_reqd;
 			txq += nae_port->num_channels;
+
+			if (nae_cmplx_fifo_val_min[node][block] > nae_port->intf_fifo_size) {
+				if (nae_port->intf_fifo_size > 0)
+					nae_cmplx_fifo_val_min[node][block] = nae_port->intf_fifo_size - 1;
+				else {
+					nlm_print("Interface FIFO size is 0\n");
+					nae_cmplx_fifo_val_min[node][block] = 0;
+				}
+			}
 		}
 		if (intf_type == INTERLAKEN_IF)
 			block++;
@@ -3176,7 +3186,6 @@ int nlm_hal_init_if(int node, int intf_type, int  block, uint32_t *regs, int num
 * @brief init_netior function is used to initialize the network IO ring.
 *
 * @param [in] node Node number
-* @param [in] type Interface type (SGMII, XAUI, Interlaken..)
 *
 * @return
 * 	- 0 on success
@@ -3184,21 +3193,31 @@ int nlm_hal_init_if(int node, int intf_type, int  block, uint32_t *regs, int num
 * @ingroup hal_nae
 *
 */
-static int init_netior(int node, int type)
+static int init_netior(int node)
 {
 	nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_SOFTRESET, 0);
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
-		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR , 0x0 );
-                nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR , 0x0707 );
-                nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x00ff );
+		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR , 0x0);
+                nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR,
+			(nae_cmplx_fifo_val_min[node][0] |
+			 (nae_cmplx_fifo_val_min[node][1] << NETIOR_CMPLX_1_INIT_CREDIT)));
+                nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x00ff);
 	}
 	else {
-		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR , (0x0 | (0x0007 << 18) ) );
-		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR , 0x07070707 );
-		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x00fffff );
+		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR,
+			(nae_cmplx_fifo_val_min[node][4] << NETIOR_CMPLX_4_INIT_CREDIT));
+		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR,
+			((nae_cmplx_fifo_val_min[node][0] & 0xff) |
+			 ((nae_cmplx_fifo_val_min[node][1] & 0xff) << NETIOR_CMPLX_1_INIT_CREDIT) |
+			 ((nae_cmplx_fifo_val_min[node][2] & 0xff) << NETIOR_CMPLX_2_INIT_CREDIT) |
+			 ((nae_cmplx_fifo_val_min[node][3] & 0xff) << NETIOR_CMPLX_3_INIT_CREDIT)));
+		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x00fffff);
 	}
 	nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x0);
 
+	NAE_DEBUG("NETIOR_MISC_REG2_ADDR: 0X%x  NETIOR_MISC_REG3_ADDR:0X%x\n",
+		nlm_hal_read_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR),
+		nlm_hal_read_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR));
 	return 0;
 }
 
@@ -3313,14 +3332,19 @@ int nlm_hal_open_if(int node, int intf_type, int block)
 	uint32_t ifmask = 0;
 	unsigned int mac_cfg1 = 0;
 	unsigned int netior_ctrl3 = 0;
+	static int done = 0;
 
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 	int hw_portid ;
 #endif
 
 	NAE_DEBUG("%s: %d node %d ",__func__,block, node);
-	/* Init Netior ... Need to fixed */
-	init_netior(node, intf_type);
+
+	/* Call init_netior to update the registers only once*/
+	if(!done) {
+		init_netior(node);
+		done = 1;
+	}
 
 	NAE_DEBUG("intf_type:%d\n", intf_type);
 	switch(intf_type) {
-- 
1.8.4.93.g57e4c17

