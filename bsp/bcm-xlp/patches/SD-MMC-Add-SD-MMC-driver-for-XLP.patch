From f306bfb3feb65b95e05d27ec93b0aab6905ca419 Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Tue, 28 Aug 2012 10:43:44 +0530
Subject: [PATCH 395/565] SD/MMC : Add SD/MMC driver for XLP

SD/MMC : Add SD/MMC driver for XLP

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anurag.gopinath@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c      |   3 +
 arch/mips/netlogic/xlp/platform.c |   5 +-
 drivers/mmc/host/sdhci-xlp.c      | 314 ++++++++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci.c          |  90 ++++++++++-
 drivers/mmc/host/sdhci.h          |  12 +-
 include/linux/mmc/sdhci.h         |   1 +
 6 files changed, 415 insertions(+), 10 deletions(-)
 create mode 100644 drivers/mmc/host/sdhci-xlp.c

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 26c2b31..ffe90d4 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -547,6 +547,7 @@ void __init init_xlp_irqs(void)
 			(0x1ULL << (XLP_IRQ_RESERVED_MAX + 16)) |	/* nae */
 			(0x3ULL << (XLP_IRQ_RESERVED_MAX + 18)) |	/* nae */
 			(0x3ULL	<< (XLP_IRQ_RESERVED_MAX + 26))| /* uart */
+			(0x3ULL	<< (XLP_IRQ_RESERVED_MAX + 23))| /* uart on xlp3xx*/
 	//		(0xfULL << 13) |	/* gpio */
 //			(0x1ULL << 31) |	/* SATA on xlp3xx */
 //			(0x1ULL << 30) |	/* SMSC  - xlp3xx */
@@ -559,6 +560,8 @@ void __init init_xlp_irqs(void)
 #endif
 #endif
 			(1ULL << XLP_IRQ_MSGRING_RVEC) |
+			(0x3ULL	<< (XLP_IRQ_RESERVED_MAX + 31)) | /* nor, nand, spi and mmc on xlp3xx*/
+			(0x3ULL << (XLP_IRQ_RESERVED_MAX + 35)) | /* gpio */
 			(0x3ULL	<< (XLP_IRQ_RESERVED_MAX + 36)) /* nor, nand, spi and mmc */
 	       );
 	/* set interrupt mask for non-zero cpus */
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 4d8eff8..f35ab6f 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -154,7 +154,8 @@ static void xlp_usb_hw_start(void)
 struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
 	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
 	{XLP_DEVID_I2C,	 "i2c-xlp",	8,	0, 	PLAT_DRV},
-	{XLP_DEVID_MMC,	 "mmc-xlp",	8,	0, 	PLAT_DRV},
+	//{XLP_DEVID_MMC,	 "mmc-xlp",	8,	0, 	PLAT_DRV},
+        {XLP_DEVID_MMC,  "sdhci",       8,      0,      PLAT_DRV},        
 	{XLP_DEVID_SPI,	 "spi-xlp",	8,	0, 	PLAT_DRV},
 	{XLP_DEVID_NOR,	 "nor-xlp",	8,	0, 	PLAT_DRV},
 	{XLP_DEVID_NAND, "nand-xlp",	9,	0, 	PLAT_DRV},
@@ -236,7 +237,7 @@ static int xlp_find_pci_dev(void)
 						dev2drv_table[idx].id = dev2drv_table[idx].id + 1;
 
 						pres[0].start	= mmio;
-						pres[0].end	= mmio;
+						pres[0].end	= mmio + 0x100;
 						pres[0].flags	= IORESOURCE_MEM;
 						irt = (nlm_hal_read_32bit_reg(mmio, DEV_IRT_INFO) & 0xFFFF);
 						irq = xlp_irt_to_irq(0, irt);
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
new file mode 100644
index 0000000..2636c42
--- /dev/null
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -0,0 +1,314 @@
+/*
+ * sdhci-pltfm.c Support for SDHCI platform devices
+ * Copyright (c) 2009 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Supports:
+ * SDHCI platform devices
+ *
+ * Inspired by sdhci-pci.c, by Pierre Ossman
+ */
+
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h> 
+#include <linux/module.h>
+
+#include <linux/mmc/host.h>
+
+#include <linux/io.h>
+
+#include "sdhci.h"
+#include "sdhci-pltfm.h"
+
+/*****************************************************************************\
+ *                                                                           *
+ * SDHCI core callbacks                                                      *
+ *                                                                           *
+\*****************************************************************************/
+
+static struct sdhci_ops sdhci_pltfm_ops = {
+};
+
+#define XLP_SLOT_SIZE          0x100
+#define XLP_NUM_SD_SLOT        2
+#define XLP_IO_PCI_HDRSZ       0x100
+
+struct sdhci_xlp_node {
+        struct platform_device  *pdev;
+        struct sdhci_host       *host[XLP_NUM_SD_SLOT];
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Device probing/removal                                                    *
+ *                                                                           *
+\*****************************************************************************/
+
+static int sdhci_pltfm_slot_probe(struct platform_device *pdev, 
+                                struct sdhci_xlp_node *node, int irq, int slotno)
+{
+        struct sdhci_xlp_node *node_sd;
+        struct sdhci_host *sd_host;
+	const struct platform_device_id *platid = platform_get_device_id(pdev);
+	struct sdhci_pltfm_data *pdata;
+        int ret;
+    
+        sd_host = sdhci_alloc_host(&pdev->dev, sizeof(struct sdhci_xlp_node));
+        if (IS_ERR(sd_host)) {
+                dev_err(&pdev->dev, "sdhci_alloc_host() failed!\n");
+                return -ENODEV;
+        }
+        node_sd = sdhci_priv(sd_host);
+        node_sd->host[slotno] = sd_host;
+        node_sd->pdev = node->pdev;
+        
+        sd_host->hw_name = "platform";
+        sd_host->irq = irq;
+
+	if (platid && platid->driver_data)
+		pdata = (void *)platid->driver_data;
+	else
+		pdata = pdev->dev.platform_data;
+
+        /*
+        * The capabilites register reports block size as 3 for 4096,
+        * force it to 2048
+        */
+	if (pdata)
+		sd_host->quirks = pdata->quirks;
+
+        sd_host->quirks |= SDHCI_QUIRK_FORCE_BLK_SZ_2048;
+
+	if (pdata && pdata->ops)
+		sd_host->ops = pdata->ops;
+	else
+		sd_host->ops = &sdhci_pltfm_ops;
+
+#if 0
+	if (pdata && pdata->init) {
+		ret = pdata->init(sd_host, pdata);
+		if (ret)
+			goto err_plat_init;
+	}
+#endif
+
+	if (!request_mem_region(pdev->resource[slotno].start, 
+                (pdev->resource[slotno].end - (pdev->resource[slotno].start)),
+		mmc_hostname(sd_host->mmc))) {
+		dev_err(&pdev->dev, "cannot request region\n");
+		ret = -EBUSY;
+		goto err_request;
+	}
+
+	sd_host->ioaddr = ioremap(pdev->resource[slotno].start,
+                (pdev->resource[slotno].end - (pdev->resource[slotno].start)));
+
+	if (!sd_host->ioaddr) {
+		dev_err(&pdev->dev, "failed to remap registers\n");
+		ret = -ENOMEM;
+		goto err_remap;
+	}
+
+	ret = sdhci_add_host(sd_host);
+	if (ret)
+		goto err_add_host;
+	return 0;
+
+err_add_host:
+#if 0
+	if (pdata && pdata->exit)
+		pdata->exit(sd_host);
+#endif
+err_plat_init:
+	iounmap(sd_host->ioaddr);
+err_remap:
+	release_mem_region(pdev->resource[slotno].start, 
+                (pdev->resource[slotno].end - (pdev->resource[slotno].start)));
+err_request:
+	sdhci_free_host(sd_host);
+        return ret;
+}
+
+static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
+{
+        struct sdhci_xlp_node *node;
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	int ret,slotno;
+        void __iomem *sys_addr;
+        struct resource res;
+	struct resource *iomem;
+        int irq;
+        volatile u32 *mmc_ctrl_base;
+
+        node = kmalloc(sizeof(struct sdhci_xlp_node), GFP_KERNEL);
+        if (!node)
+                return -ENOMEM;
+
+#if 1
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!iomem) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	if (resource_size(iomem) < 0x100)
+		dev_err(&pdev->dev, "Invalid iomem size. You may "
+			"experience problems.\n");
+#endif
+	pltfm_host = sdhci_priv(host);
+
+        /*
+         * Enable slots.
+         * Get system control base, node set to zero.
+         * TODO: node need to be taken care on multinode case.
+         */
+        res.start = iomem->start + XLP_IO_PCI_HDRSZ + XLP_SLOT_SIZE*2;
+        sys_addr  = ioremap(res.start, 0x28);
+        if (!sys_addr) {
+                ret = -ENOMEM;
+                goto err;
+        }
+        mmc_ctrl_base = sys_addr;
+        mmc_ctrl_base[0>>2] = 0x1C;;
+
+        /*
+        * The XLP MMC/SD controller has two slots. The registers for the
+        * slots are at fixed location in the PCIe ECFG space, and not
+        * in any PCI BARs.
+        */
+        irq = platform_get_irq(pdev, 0);
+        for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+            pdev->resource[slotno].flags = IORESOURCE_MEM;
+            pdev->resource[slotno].start = iomem->start + (0x100); 
+            pdev->resource[slotno].end = pdev->resource[slotno].start + 
+                                         XLP_SLOT_SIZE - 1;
+            
+            ret = sdhci_pltfm_slot_probe(pdev, node, irq, slotno);
+
+            if (ret)
+                dev_err(&pdev->dev, "failed to probe slot%d\n", slotno);
+        }
+
+	platform_set_drvdata(pdev, node);
+
+	return 0;
+
+err:
+	printk(KERN_ERR"Probing of sdhci-pltfm failed: %d\n", ret);
+	return ret;
+}
+
+static int __devexit sdhci_pltfm_remove(struct platform_device *pdev)
+{
+	struct sdhci_pltfm_data *pdata = pdev->dev.platform_data;
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	int dead;
+	u32 scratch;
+
+	dead = 0;
+	scratch = readl(host->ioaddr + SDHCI_INT_STATUS);
+	if (scratch == (u32)-1)
+		dead = 1;
+
+	sdhci_remove_host(host, dead);
+#if 0
+	if (pdata && pdata->exit)
+		pdata->exit(host);
+#endif
+	iounmap(host->ioaddr);
+	release_mem_region(iomem->start, resource_size(iomem));
+	sdhci_free_host(host);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct platform_device_id sdhci_pltfm_ids[] = {
+	{ "sdhci", },
+#ifdef CONFIG_MMC_SDHCI_CNS3XXX
+	{ "sdhci-cns3xxx", (kernel_ulong_t)&sdhci_cns3xxx_pdata },
+#endif
+#ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
+	{ "sdhci-esdhc-imx", (kernel_ulong_t)&sdhci_esdhc_imx_pdata },
+#endif
+#ifdef CONFIG_MMC_SDHCI_DOVE
+	{ "sdhci-dove", (kernel_ulong_t)&sdhci_dove_pdata },
+#endif
+#ifdef CONFIG_MMC_SDHCI_TEGRA
+	{ "sdhci-tegra", (kernel_ulong_t)&sdhci_tegra_pdata },
+#endif
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, sdhci_pltfm_ids);
+
+#ifdef CONFIG_PM
+static int sdhci_pltfm_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct sdhci_host *host = platform_get_drvdata(dev);
+
+	return sdhci_suspend_host(host, state);
+}
+
+static int sdhci_pltfm_resume(struct platform_device *dev)
+{
+	struct sdhci_host *host = platform_get_drvdata(dev);
+
+	return sdhci_resume_host(host);
+}
+#else
+#define sdhci_pltfm_suspend	NULL
+#define sdhci_pltfm_resume	NULL
+#endif	/* CONFIG_PM */
+
+static struct platform_driver sdhci_pltfm_driver = {
+	.driver = {
+		.name	= "sdhci",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= sdhci_pltfm_probe,
+	.remove		= __devexit_p(sdhci_pltfm_remove),
+	.id_table	= sdhci_pltfm_ids,
+	.suspend	= sdhci_pltfm_suspend,
+	.resume		= sdhci_pltfm_resume,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Driver init/exit                                                          *
+ *                                                                           *
+\*****************************************************************************/
+
+static int __init sdhci_drv_init(void)
+{
+	return platform_driver_register(&sdhci_pltfm_driver);
+}
+
+static void __exit sdhci_drv_exit(void)
+{
+	platform_driver_unregister(&sdhci_pltfm_driver);
+}
+
+module_init(sdhci_drv_init);
+module_exit(sdhci_drv_exit);
+
+MODULE_DESCRIPTION("Secure Digital Host Controller Interface platform driver");
+MODULE_AUTHOR("Mocean Laboratories <info@mocean-labs.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 2ea429c..4dac2fe 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -29,8 +29,12 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/slot-gpio.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <hal/nlm_hal_xlp_dev.h>
 
 #include "sdhci.h"
+#include "xlpmmc.h"
 
 #define DRIVER_NAME "sdhci"
 
@@ -55,6 +59,9 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
 static void sdhci_tuning_timer(unsigned long data);
 static void sdhci_enable_preset_value(struct sdhci_host *host, bool enable);
 
+#define GPIO_MMC_DETECT 29
+/*#define XLP_MMC_DEBUG*/
+
 #ifdef CONFIG_PM_RUNTIME
 static int sdhci_runtime_pm_get(struct sdhci_host *host);
 static int sdhci_runtime_pm_put(struct sdhci_host *host);
@@ -145,6 +152,20 @@ static void sdhci_mask_irqs(struct sdhci_host *host, u32 irqs)
 	sdhci_clear_set_irqs(host, irqs, 0);
 }
 
+static __inline__ int32_t gpio_regread(int node, int regidx) 
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void gpio_regwrite(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
 static void sdhci_set_card_detection(struct sdhci_host *host, bool enable)
 {
 	u32 present, irqs;
@@ -235,7 +256,9 @@ static void sdhci_init(struct sdhci_host *host, int soft)
 		SDHCI_INT_BUS_POWER | SDHCI_INT_DATA_END_BIT |
 		SDHCI_INT_DATA_CRC | SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_INDEX |
 		SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
-		SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE);
+                SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE |
+                SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE );
+
 
 	if (soft) {
 		/* force clock reconfiguration */
@@ -1002,7 +1025,7 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 		mdelay(1);
 	}
 
-	mod_timer(&host->timer, jiffies + 10 * HZ);
+	mod_timer(&host->timer, jiffies + 1 * HZ);
 
 	host->cmd = cmd;
 
@@ -1210,7 +1233,7 @@ clock_set:
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 
 	/* Wait max 20 ms */
-	timeout = 20;
+	timeout = 200;
 	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
 		& SDHCI_CLOCK_INT_STABLE)) {
 		if (timeout == 0) {
@@ -2383,6 +2406,32 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 	}
 }
 
+static irqreturn_t sdhci_det_irq(int irq, void *dev_id)
+{
+        struct sdhci_host *host = (struct sdhci_host *) dev_id;
+        int present = !gpio_get_value(GPIO_MMC_DETECT); 
+#ifdef XLP_MMC_DEBUG
+        printk("Entered sdhci_det_irq\n");
+#endif
+        /*
+        * we expect this irq on both insert and remove,
+        * and use a short delay to debounce.
+        */
+        gpio_regwrite(0, XLP_GPIO_INT_STAT0, gpio_regread(0, XLP_GPIO_INT_STAT0) & 0x20000000);
+        if(present)
+                gpio_regwrite(0, XLP_GPIO_INT_POLAR0, gpio_regread(0, XLP_GPIO_INT_POLAR0) & 0xDFFFFFFF);
+        else
+                gpio_regwrite(0, XLP_GPIO_INT_POLAR0, gpio_regread(0, XLP_GPIO_INT_POLAR0) | 0x20000000);
+
+        if (present != host->present) {
+                host->present = present;
+                pr_debug("%s: card %s\n", mmc_hostname(host->mmc),
+                        present ? "insert" : "remove");
+                mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+        }
+        return IRQ_HANDLED;
+}
+
 static irqreturn_t sdhci_irq(int irq, void *dev_id)
 {
 	irqreturn_t result;
@@ -3141,7 +3190,7 @@ int sdhci_add_host(struct sdhci_host *host)
 	} else {
 		mmc->max_blk_size = (caps[0] & SDHCI_MAX_BLOCK_MASK) >>
 				SDHCI_MAX_BLOCK_SHIFT;
-		if (mmc->max_blk_size >= 3) {
+		if (mmc->max_blk_size > 3) {
 			pr_warning("%s: Invalid maximum block size, "
 				"assuming 512 bytes\n", mmc_hostname(mmc));
 			mmc->max_blk_size = 0;
@@ -3155,6 +3204,28 @@ int sdhci_add_host(struct sdhci_host *host)
 	 */
 	mmc->max_blk_count = (host->quirks & SDHCI_QUIRK_NO_MULTIBLOCK) ? 1 : 65535;
 
+        if (is_nlm_xlp8xx()) {
+                gpio_regwrite(0, XLP_GPIO_INTEN00,   
+                        gpio_regread(0, XLP_GPIO_INTEN00) | 0x20000000);
+                gpio_regwrite(0, XLP_GPIO_INT_POLAR0, 
+                        gpio_regread(0, XLP_GPIO_INT_POLAR0) | 0x20000000);
+                gpio_regwrite(0, XLP_GPIO_INT_TYPE0, 
+                        gpio_regread(0, XLP_GPIO_INT_TYPE0) | 0x20000000);
+
+                ret = request_irq(xlp_irt_to_irq(0, XLP_GPIO_INT0_IRT), sdhci_det_irq,
+                        IRQF_SHARED, "mmc-gpio", host);
+                if (ret) {
+                        free_irq(xlp_irt_to_irq(0, XLP_GPIO_INT0_IRT), host);
+                        return ret;
+                }   
+    
+                if (gpio_is_valid(GPIO_MMC_DETECT)) {
+                        if (gpio_request(GPIO_MMC_DETECT, "mmc_detect")) {
+                                pr_debug("no detect pin available\n");
+                        }   
+                }   
+        }
+
 	/*
 	 * Init tasklets.
 	 */
@@ -3222,6 +3293,12 @@ reset:
 	sdhci_reset(host, SDHCI_RESET_ALL);
 	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 	free_irq(host->irq, host);
+
+        free_irq(xlp_irt_to_irq(XLP_GPIO_INT0_IRT), host);
+        if (gpio_is_valid(GPIO_MMC_DETECT)) {
+                gpio_free(GPIO_MMC_DETECT);
+        }
+
 #endif
 untasklet:
 	tasklet_kill(&host->card_tasklet);
@@ -3266,6 +3343,11 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 	free_irq(host->irq, host);
 
+        free_irq(xlp_irt_to_irq(0, XLP_GPIO_INT0_IRT), host);
+        if (gpio_is_valid(GPIO_MMC_DETECT)) {
+                gpio_free(GPIO_MMC_DETECT);
+        }
+
 	del_timer_sync(&host->timer);
 
 	tasklet_kill(&host->card_tasklet);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 379e09d..e3ee2f0 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -350,12 +350,14 @@ static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
 
 static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
 {
-	writel(val, host->ioaddr + reg);
+	volatile u32 *mmc_base = host->ioaddr;
+        mmc_base[reg>>2] = val;
 }
 
 static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
 {
-	writew(val, host->ioaddr + reg);
+	volatile u16 *mmc_base = host->ioaddr;
+        mmc_base[reg>>1] = val;
 }
 
 static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
@@ -365,12 +367,14 @@ static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
 
 static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
 {
-	return readl(host->ioaddr + reg);
+	volatile u32 *mmc_base = host->ioaddr;
+        return   mmc_base[reg>>2];
 }
 
 static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
 {
-	return readw(host->ioaddr + reg);
+	volatile u16 *mmc_base = host->ioaddr;
+        return   mmc_base[reg>>1];
 }
 
 static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index b838ffc..35d4c91 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -147,6 +147,7 @@ struct sdhci_host {
 
 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
 	unsigned int blocks;	/* remaining PIO blocks */
+        int                     present;        /* status of card */
 
 	int sg_count;		/* Mapped sg entries */
 
-- 
1.8.4.93.g57e4c17

