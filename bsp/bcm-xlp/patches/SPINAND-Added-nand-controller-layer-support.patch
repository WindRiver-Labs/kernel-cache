From b2fa9110364b80a40f9f1534306f2c07215986a1 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 25 Apr 2013 17:10:48 +0800
Subject: [PATCH 494/565] SPINAND: Added nand controller layer support

Added framework in the chip driver for using linux nand
controller layer functions

Based on Broadcom SDK 2.3.

Signed-off-by: Divya Sakthidharan <divyas@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/devices/spinand_lld.c | 415 +++++++++++++++++++++++++++++++-------
 drivers/mtd/nand/nand_ids.c       |   2 +
 include/linux/mtd/spinand.h       |  51 ++---
 3 files changed, 360 insertions(+), 108 deletions(-)

diff --git a/drivers/mtd/devices/spinand_lld.c b/drivers/mtd/devices/spinand_lld.c
index 008bafc..347b402 100644
--- a/drivers/mtd/devices/spinand_lld.c
+++ b/drivers/mtd/devices/spinand_lld.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2013 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
 spinand_lld.c
 
@@ -21,9 +29,11 @@ GNU General Public License for more details.
 #include <linux/interrupt.h>
 #include <linux/mutex.h>
 #include <linux/math64.h>
+#include <linux/delay.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
 #include <linux/mtd/spinand.h>
 
 #include <linux/spi/spi.h>
@@ -36,6 +46,11 @@ GNU General Public License for more details.
 /**
    OOB area specification layout:  Total 32 available free bytes.
 */
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+int enable_hw_ecc = 0;
+int enable_read_hw_ecc = 0;
+#endif
 static struct nand_ecclayout spinand_oob_64 = {
 	.eccbytes = 24,
 	.eccpos = {
@@ -54,6 +69,7 @@ static struct nand_ecclayout spinand_oob_64 = {
 		{.offset = 56,
 		 .length = 8}, }
 };
+
 /**
  * spinand_cmd - to process a command to send to the SPI Nand
  * 
@@ -61,12 +77,14 @@ static struct nand_ecclayout spinand_oob_64 = {
  *    Set up the command buffer to send to the SPI controller.
  *    The command buffer has to initized to 0
  */
+
 int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 {
-	int					ret;
+	int	ret;
 	struct spi_message	message;
-	struct spi_transfer		x[4];
+	struct spi_transfer	x[4];
 	u8 dummy = 0xff;
+	char cmd_buff[16];
 
 
 	spi_message_init(&message);
@@ -74,19 +92,28 @@ int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 	
 	x[0].len = 1;
 	x[0].tx_buf = &cmd->cmd;
-	spi_message_add_tail(&x[0], &message);
+	
+	memcpy(cmd_buff,  &cmd->cmd, 1);
 	
 	if (cmd->n_addr)
 	{
 		x[1].len = cmd->n_addr;
 		x[1].tx_buf = cmd->addr;
-		spi_message_add_tail(&x[1], &message);
+		x[0].len = 1 +  x[1].len;
+		memcpy(&cmd_buff[1],  cmd->addr, x[1].len);
 	}
 
+	x[0].tx_buf = &cmd_buff[0];
+	if(cmd->n_tx || cmd->n_rx)
+		x[0].spi_cont_cmd = 1;
+	spi_message_add_tail(&x[0], &message);
+	
+
 	if (cmd->n_dummy)
 	{
 		x[2].len = cmd->n_dummy;
 		x[2].tx_buf = &dummy;
+		x[2].spi_cont_cmd = 1;
 		spi_message_add_tail(&x[2], &message);		
 	}
 
@@ -110,20 +137,6 @@ int spinand_cmd(struct spi_device *spi, struct spinand_cmd *cmd)
 }
 
 /**
- * spinand_reset- send reset command "0xff" to the Nand device
- * 
- * Description:
- *    Reset the SPI Nand with the reset command 0xff
- */
-static int spinand_reset(struct spi_device *spi_nand)
-{
-	struct spinand_cmd cmd = {0};
-
-	cmd.cmd = CMD_RESET;
-
-	return spinand_cmd(spi_nand, &cmd);
-}
-/**
  * spinand_read_id- Read SPI Nand ID
  * 
  * Description:
@@ -133,12 +146,12 @@ static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 {
 	struct spinand_cmd cmd = {0};
 	ssize_t retval;
+	u8 nand_id[3];
 
 	
 	cmd.cmd = CMD_READ_ID;
-	cmd.n_dummy = 1;
-	cmd.n_rx = 2;
-	cmd.rx_buf = id;
+	cmd.n_rx = 3;
+	cmd.rx_buf = &nand_id[0];
 	
 	retval = spinand_cmd(spi_nand, &cmd);
 
@@ -147,7 +160,9 @@ static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 				(int) retval);
 		return retval;
 	}
-	
+	id[0] = nand_id[1];
+        id[1] = nand_id[2];	
+
 	return 0;	
 }
 
@@ -188,7 +203,7 @@ static int spinand_lock_block(struct spi_device *spi_nand, struct spinand_info *
  *    This function is to allow reading the status of the command: read, write, and erase.
  *    Once the status turns to be ready, the other status bits also are valid status bits.
  */
-static int spinand_read_status(struct spi_device *spi_nand, struct spinand_info *info, u8 *status)
+static int spinand_read_status(struct spi_device *spi_nand, struct spinand_info *info, uint8_t *status)
 {
 	struct spinand_cmd cmd = {0};
 	ssize_t retval;
@@ -271,8 +286,9 @@ static int spinand_set_otp(struct spi_device *spi_nand, struct spinand_info *inf
 	return 0;
 }
 
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
 /**
- * sspinand_enable_ecc- send command 0x1f to write the SPI Nand OTP register
+ * spinand_enable_ecc- send command 0x1f to write the SPI Nand OTP register
  * 
  * Description:
  *   There is one bit( bit 0x10 ) to set or to clear the internal ECC.
@@ -298,6 +314,7 @@ static int spinand_enable_ecc(struct spi_device *spi_nand, struct spinand_info *
 		return retval;
 	}
 }
+#endif
 
 static int spinand_disable_ecc(struct spi_device *spi_nand, struct spinand_info *info)
 {
@@ -321,7 +338,7 @@ static int spinand_disable_ecc(struct spi_device *spi_nand, struct spinand_info
 }
 
 /**
- * sspinand_write_enable- send command 0x06 to enable write or erase the Nand cells
+ * spinand_write_enable- send command 0x06 to enable write or erase the Nand cells
  * 
  * Description:
  *   Before write and erase the Nand cells, the write enable has to be set.
@@ -367,10 +384,11 @@ static int spinand_read_from_cache(struct spi_device *spi_nand, struct spinand_i
 	column = byte_id;
 
 	cmd.cmd = CMD_READ_RDM;
-	cmd.n_addr = 2;
+	cmd.n_addr = 3;
 	cmd.addr[0] = (u8)((column&0xff00)>>8);
 	cmd.addr[1] = (u8)(column&0x00ff);
-	cmd.n_dummy = 1;
+	cmd.addr[2] = (u8)(0xff);
+	cmd.n_dummy = 0;
 	cmd.n_rx = len;
 	cmd.rx_buf = rbuf;
 	
@@ -393,6 +411,10 @@ static int spinand_read_page(struct spi_device *spi_nand, struct spinand_info *i
 	ssize_t retval;
 	u8 status = 0;
 	
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_read_hw_ecc)	
+		retval = spinand_enable_ecc(spi_nand, info);
+#endif	
 	retval = spinand_read_page_to_cache(spi_nand, info, page_id);
 
 	while (1)
@@ -409,16 +431,20 @@ static int spinand_read_page(struct spi_device *spi_nand, struct spinand_info *i
 			if ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR)
 			{
 				dev_err(&spi_nand->dev, "ecc error, page=%d\n", page_id);
-				if (spi_nand == SPI_NAND_MICRON_DRIVER_KEY)
-					printk(KERN_INFO "Error: reformat or erase your device. \n"); 
-				else
-				return -1;
+				return 0;
 			}
 			break;
 		}
 	}
 
 	retval = spinand_read_from_cache(spi_nand, info, offset, len, rbuf);
+
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_read_hw_ecc)	{	
+		retval = spinand_disable_ecc(spi_nand, info);
+		enable_read_hw_ecc = 0;
+	}
+#endif	
 	return 0;
 		
 }
@@ -485,10 +511,27 @@ static int spinand_program_execute(struct spi_device *spi_nand, struct spinand_i
  *   sent, the write cache command, and the write execute command
  *   Poll to wait for the tPROG time to finish the transaction.
  */
-static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* wbuf)
+static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* buf)
 {
 	ssize_t retval;
 	u8 status = 0;
+	uint8_t *wbuf;
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	unsigned int i, j;
+
+	enable_read_hw_ecc = 0;
+	wbuf = kzalloc(2112,GFP_KERNEL);
+	spinand_read_page(spi_nand, info, page_id, 0, 2112, wbuf);
+	for(i=offset, j=0; i<len; i++,j++)
+	{
+		wbuf[i] &= buf[j];
+	}
+	if(enable_hw_ecc)
+		retval = spinand_enable_ecc(spi_nand, info);
+
+#else
+	wbuf = buf;
+#endif
 
 	retval = spinand_write_enable(spi_nand, info);
 	
@@ -517,6 +560,13 @@ static int spinand_program_page(struct spi_device *spi_nand, struct spinand_info
 				break;
 		}
 	}
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+	if(enable_hw_ecc)	{
+		retval = spinand_disable_ecc(spi_nand, info);
+		enable_hw_ecc = 0;
+	}
+	kfree(wbuf);
+#endif
 
 	return 0;
 }
@@ -534,7 +584,8 @@ static int spinand_erase_block_erase(struct spi_device *spi_nand, struct spinand
 	struct spinand_cmd cmd = {0};
 	u16 row;
 
-	row = block_id << 6;
+	//row = block_id << 6;
+	row = block_id;
 	cmd.cmd = CMD_ERASE_BLK;
 	cmd.n_addr = 3;
 	cmd.addr[1] = (u8)((row&0xff00)>>8);
@@ -556,7 +607,7 @@ static int spinand_erase_block(struct spi_device *spi_nand, struct spinand_info
 {
 	ssize_t retval;
 	u8 status= 0;
-
+	
 	retval = spinand_write_enable(spi_nand, info);
 	
 	retval = spinand_erase_block_erase(spi_nand, info, block_id);
@@ -613,15 +664,197 @@ static int spinand_get_info(struct spi_device *spi_nand, struct spinand_info *in
 
 		info->page_shift = 11;
 		info->page_mask = 0x7ff;
-		
-		info->ecclayout = &spinand_oob_64;
 	}	
 	
 	return 0;
 }
 
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC 
+static void spinand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
+{
+	const uint8_t *p = buf;
+	int eccsize = chip->ecc.size;
+	int eccsteps = chip->ecc.steps;
+
+	enable_hw_ecc = 1;
+	chip->write_buf(mtd, p, eccsize * eccsteps);
+	return;
+}
+
+static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int page)
+{
+	u8 retval, status;
+	uint8_t *p = buf;
+	int eccsize = chip->ecc.size;
+	int eccsteps = chip->ecc.steps;
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+
+	enable_read_hw_ecc = 1;	
+
+	chip->read_buf(mtd, p, eccsize*eccsteps);
+	while(1)
+	{	
+		retval = spinand_read_status(info->spi, info, &status);
+		if ((status & STATUS_OIP_MASK) == STATUS_READY)
+		{
+			if ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR)
+			{
+				printk("spinand: ECC error \n");
+				mtd->ecc_stats.failed++;
+			}
+			else if((status & STATUS_ECC_MASK) == STATUS_ECC_1BIT_CORRECTED )	{
+				mtd->ecc_stats.corrected ++;
+			}
+			break;
+		}
+
+	
+	}
+	return 0;
+
+}
+#endif
+
+static void spinand_select_chip(struct mtd_info *mtd, int dev)
+{
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct spinand_info *info = (struct spinand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->priv;
+
+                state->cs = 1;
+}
+
+
+static uint8_t spinand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+	u8 data;
+
+	data = state->buf[state->buf_ptr];
+	state->buf_ptr++;
+	return data;
+}
+
+static int spinand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+
+	unsigned long timeo = jiffies;
+	int retval, state = chip->state;
+	u8 status;
+
+	if (state == FL_ERASING)
+		timeo += (HZ * 400) / 1000;
+	else
+		timeo += (HZ * 20) / 1000;
+	
+
+	while (time_before(jiffies, timeo)) {
+		retval = spinand_read_status(info->spi, info, &status);
+		if ((status & STATUS_OIP_MASK) == STATUS_READY)
+		{
+			return 0;
+		}
+		cond_resched();
+	}
+	return 0;
+}
+
+static void spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+
+	memcpy(state->buf+state->buf_ptr, buf, len);
+	state->buf_ptr += len;
+	return;
+}
+
+static void spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+
+	memcpy(buf, state->buf+state->buf_ptr, len);
+	state->buf_ptr += len;
+	return;
+}
+
+static void cmdfunc(struct mtd_info *mtd,
+                    unsigned int command,
+                    int column,
+                    int page)
+{
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct spinand_info *info = (struct spinand_info *)chip->priv;
+	struct nand_state *state = (struct nand_state *)info->priv;
+        switch (command) {
+	/*
+	 * READ0 - read in first  0x800 bytes
+	 */
+        case NAND_CMD_READ1:
+        case NAND_CMD_READ0:
+                state->buf_ptr = 0;
+		spinand_read_page(info->spi, info, page, 0x0, 0x840, state->buf);
+		break;
+        /* READOOB reads only the OOB because no ECC is performed. */
+        case NAND_CMD_READOOB:
+		state->buf_ptr = 0;
+		spinand_read_page(info->spi, info, page, 0x800, 0x40, state->buf);
+		break;
+	case NAND_CMD_RNDOUT:
+		state->buf_ptr = column;
+		break;
+        case NAND_CMD_READID:
+                state->buf_ptr = 0;
+		spinand_read_id(info->spi, (u8*)state->buf);
+		break;
+        case NAND_CMD_PARAM:
+                state->buf_ptr = 0;
+		break;
+        /* ERASE1 stores the block and page address */
+        case NAND_CMD_ERASE1:
+		spinand_erase_block(info->spi, info, page);
+		break;
+        /* ERASE2 uses the block and page address from ERASE1 */
+        case NAND_CMD_ERASE2:
+		break;
+        /* SEQIN sets up the addr buffer and all registers except the length */
+        case NAND_CMD_SEQIN:
+		state->col	= column;
+		state->row	= page;
+		state->buf_ptr = 0;
+		break;
+        /* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+        case NAND_CMD_PAGEPROG:
+		spinand_program_page(info->spi, info, state->row, state->col, state->buf_ptr, state->buf);
+		break;
+
+        case NAND_CMD_STATUS:
+		spinand_get_otp(info->spi, info, state->buf);
+		
+		if(!(state->buf[0] & 0x80))
+		state->buf[0] = 0x80;
+		state->buf_ptr = 0;
+
+		break;
+        /* RESET command */
+        case NAND_CMD_RESET:
+		break;
+	default:
+		printk("command: 0x%x \n", command);
+		break;
+        }
+}
+
+
+
 /**
- * spinand_probe - [spinand Interface] 
+* spinand_probe - [spinand Interface] 
 * @spi_nand: registered device driver.
  *
  * Description:
@@ -631,12 +864,12 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 {
 	ssize_t retval;
 	struct mtd_info *mtd;
-	struct spinand_chip *chip; 
+	struct nand_chip *chip; 
 	struct spinand_info *info;
-	u8 id[2]= {0};
+	struct nand_state *state;
+	u8 id[2]= {2};
+	
 	
-	retval = spinand_reset(spi_nand);
-	retval = spinand_reset(spi_nand);
 	retval = spinand_read_id(spi_nand, (u8*)&id);
 	if (id[0]==0 && id[1]==0)
 	{
@@ -647,37 +880,61 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 	info  = kzalloc(sizeof(struct spinand_info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
+
+	info->spi = spi_nand;
 	
 	retval = spinand_get_info(spi_nand, info, (u8*)&id);
 	printk(KERN_INFO "SPINAND: 0x%02x, 0x%02x, %s\n", id[0], id[1], info->name); 
 	printk(KERN_INFO "%s\n", mu_spi_nand_driver_version);
 	retval = spinand_lock_block(spi_nand, info, BL_ALL_UNLOCKED);
 
+	state = kzalloc(sizeof(struct nand_state), GFP_KERNEL);
+	if(!state)
+		return -ENOMEM; 
+	
+	info->priv = state;
+	state->last_cmd  = 0;
+	state->cs        = 0;
+	state->buf_ptr   = 0 ;
+	state->buf =  kzalloc(10 * 64 * 2048, GFP_KERNEL);
+	if(!state->buf)
+		return -ENOMEM;
+	
+	chip  = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	
+	chip->ecc.mode      = NAND_ECC_NONE;
+
+#ifdef CONFIG_MTD_SPINAND_SWECC
+	chip->ecc.mode      = NAND_ECC_SOFT;
+	chip->ecc.size	    = 0x200;
+	chip->ecc.steps     = 0x4;
+	chip->ecc.total     = chip->ecc.steps * chip->ecc.bytes;
+	chip->ecc.layout    = &spinand_oob_64;
+#endif
+
 #ifdef CONFIG_MTD_SPINAND_ONDIEECC
-	retval = spinand_enable_ecc(spi_nand, info);
+	chip->ecc.mode      = NAND_ECC_HW;
+	chip->ecc.size	    = 0x200;
+	chip->ecc.bytes     = 0x6;
+	chip->ecc.steps     = 0x4;
+	chip->ecc.total     = chip->ecc.steps * chip->ecc.bytes;
+	chip->ecc.layout    = &spinand_oob_64;
+        chip->ecc.write_page= spinand_write_page_hwecc;
+	chip->ecc.read_page = spinand_read_page_hwecc;	
 #else
 	retval = spinand_disable_ecc(spi_nand, info);
 #endif
 
-	chip  = kzalloc(sizeof(struct spinand_chip), GFP_KERNEL);
-	if (!chip)
-		return -ENOMEM;
-
-	chip->spi_nand = spi_nand;
-	chip->info = info;
-	chip->reset = spinand_reset;
-	chip->read_id = spinand_read_id;
-	chip->read_page = spinand_read_page;
-	chip->program_page = spinand_program_page;
-	chip->erase_block = spinand_erase_block;
-
-	chip->buf = kzalloc(info->page_size, GFP_KERNEL);
-	if (!chip->buf)
-		return -ENOMEM;
-
-	chip->oobbuf = kzalloc(info->ecclayout->oobavail, GFP_KERNEL);
-	if (!chip->oobbuf)
-		return -ENOMEM;
+	chip->priv = info;
+	chip->options |= NAND_CACHEPRG | NAND_SKIP_BBTSCAN;
+	chip->read_buf   = spinand_read_buf;
+	chip->write_buf  = spinand_write_buf;
+	chip->read_byte  = spinand_read_byte;
+	chip->select_chip = spinand_select_chip;
+	chip->cmdfunc      = cmdfunc;
+	chip->waitfunc      = spinand_wait;
 
 	mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
 	if (!mtd)
@@ -686,9 +943,12 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 	dev_set_drvdata(&spi_nand->dev, mtd);
 	
 	mtd->priv = chip;
+	mtd->oobsize = 64;
 
-	retval = spinand_mtd(mtd);
-	
+	if(nand_scan(mtd, 1))	{
+		return -1;
+	}
+	 mtd_device_register(mtd, NULL, 0);
 	return retval;
 }
 
@@ -702,19 +962,21 @@ static int __devinit spinand_probe(struct spi_device *spi_nand)
 static int __devexit spinand_remove(struct spi_device *spi)
 {
 	struct mtd_info *mtd;
-	struct spinand_chip *chip; 
-
-	DEBUG(MTD_DEBUG_LEVEL1, "%s: remove\n", dev_name(&spi->dev));
+	struct nand_chip *chip; 
+	struct spinand_info *info;
+	struct nand_state *state;
 
 	mtd = dev_get_drvdata(&spi->dev);
 	
-	spinand_mtd_release(mtd);
 
-	chip = mtd->priv;
+	chip = (struct nand_chip *)mtd->priv;
+	info = (struct spinand_info *)chip->priv;
+	state = (struct nand_state *)info->priv;
+
+	mtd_device_unregister(mtd);
 	
-	kfree(chip->info);
-	kfree(chip->buf);
-	kfree(chip->oobbuf);
+	kfree(state);
+	kfree(info);
 	kfree(chip);
 	kfree(mtd);
 	
@@ -726,7 +988,7 @@ static int __devexit spinand_remove(struct spi_device *spi)
 */
 static struct spi_driver spinand_driver = {
 	.driver = {
-		.name		= "spi_nand",
+		.name		= "mt29f",
 		.bus		= &spi_bus_type,
 		.owner		= THIS_MODULE,
 	},
@@ -740,7 +1002,9 @@ static struct spi_driver spinand_driver = {
 */
 static int __init spinand_init(void)
 {
-	return spi_register_driver(&spinand_driver);
+	int val;
+	val = spi_register_driver(&spinand_driver);
+	return val;
 }
 
 /**
@@ -756,5 +1020,6 @@ module_exit(spinand_exit);
 
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Henry Pan <hspan@micron.com>");
-MODULE_DESCRIPTION("SPI NAND driver code");
+MODULE_AUTHOR("Netlogicmicro System Inc.");
+MODULE_DESCRIPTION("MTD SPI driver for Micron MT29f nand chips");
+MODULE_ALIAS("platform:spinand");
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 683813a..dde41df 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -98,6 +98,8 @@ struct nand_flash_dev nand_flash_ids[] = {
 	EXTENDED_ID_NAND("NAND 128MiB 1,8V 16-bit", 0xB1, 128, LP_OPTIONS16),
 	EXTENDED_ID_NAND("NAND 128MiB 3,3V 16-bit", 0xC1, 128, LP_OPTIONS16),
 	EXTENDED_ID_NAND("NAND 128MiB 1,8V 16-bit", 0xAD, 128, LP_OPTIONS16),
+	EXTENDED_ID_NAND("SPINAND 128MiB 3,3V 8-bit", 0x11, 2048, 128, 0x20000, LP_OPTIONS),
+	EXTENDED_ID_NAND("SPINAND 128MiB 3,3V 8-bit", 0x12, 2048, 128, 0x20000, LP_OPTIONS),
 
 	/* 2 Gigabit */
 	EXTENDED_ID_NAND("NAND 256MiB 1,8V 8-bit",  0xAA, 256, LP_OPTIONS),
diff --git a/include/linux/mtd/spinand.h b/include/linux/mtd/spinand.h
index afc1d3d..508b080 100644
--- a/include/linux/mtd/spinand.h
+++ b/include/linux/mtd/spinand.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2013 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  *  linux/include/linux/mtd/spinand.h
  *
@@ -104,47 +112,24 @@ struct spinand_info {
 	u16		page_mask;
 
 	struct nand_ecclayout *ecclayout;
+	struct spi_device *spi; 
+	void *priv;
 };
 
-typedef enum {
-	FL_READY,
-	FL_READING,
-	FL_WRITING,
-	FL_ERASING,
-	FL_SYNCING,
-	FL_LOCKING,
-	FL_RESETING,
-	FL_OTPING,
-	FL_PM_SUSPENDED,
-} spinand_state_t;
-	
-struct spinand_chip { /* used for multi chip */
-	spinlock_t		chip_lock;
-	wait_queue_head_t wq;	
-	spinand_state_t	state;
-	struct spi_device	*spi_nand;
-	struct spinand_info *info;
-	/*struct mtd_info	*mtd; */
-
-	int (*reset) (struct spi_device *spi_nand);
-	int (*read_id) (struct spi_device *spi_nand, u8* id);
-	int (*read_page) (struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* rbuf);
-	int (*program_page) (struct spi_device *spi_nand, struct spinand_info *info, u16 page_id, u16 offset, u16 len, u8* wbuf);
-	int (*erase_block) (struct spi_device *spi_nand, struct spinand_info *info, u16 block_id);
-
+struct nand_state {
+	int cs ;
+	uint32_t col;
+	uint32_t row;
+	uint32_t last_cmd;
+	int buf_ptr;
 	u8 *buf;
-	u8 *oobbuf; /* temp buffer */
-
-
-#ifdef CONFIG_MTD_SPINAND_SWECC
-	u8 ecc_calc[12];
-	u8 ecc_code[12];
-#endif
 };
 
 struct spinand_cmd {
 	u8 cmd;
+	u8 cmd_cnt;
 	unsigned n_addr;	
+	u8 addr_cmd_cnt;
 	u8 addr[3];
 	unsigned n_dummy;
 	unsigned n_tx;	
-- 
1.8.4.93.g57e4c17

