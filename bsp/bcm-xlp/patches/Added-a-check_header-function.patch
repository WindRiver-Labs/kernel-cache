From 226c0ba568f3136d3b1721df1edc88e969022497 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 11 Sep 2010 12:44:54 -0700
Subject: [PATCH 134/565] Added a check_header function

Add a check_header function to FDT wrapper, turned off use of local FDT copy.

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/boot/libfdt-wrapper.c | 37 +++++++++++++++++++++++---------
 arch/mips/netlogic/boot/ops.h            |  9 ++++++++
 arch/mips/netlogic/xlp/setup.c           |  1 +
 3 files changed, 37 insertions(+), 10 deletions(-)

diff --git a/arch/mips/netlogic/boot/libfdt-wrapper.c b/arch/mips/netlogic/boot/libfdt-wrapper.c
index 3b9e8bd..0ed262a 100644
--- a/arch/mips/netlogic/boot/libfdt-wrapper.c
+++ b/arch/mips/netlogic/boot/libfdt-wrapper.c
@@ -176,11 +176,18 @@ static unsigned long fdt_wrapper_finalize(void)
 	return (unsigned long)fdt;
 }
 
-void *fdt_init(void *blob)
+static int fdt_wrapper_check_header(void)
 {
 	int err;
-	int bufsize;
 
+	if ((err = fdt_check_header(fdt)) != 0)
+		return err;
+
+	return 0;
+}
+
+void *fdt_init(void *blob)
+{
 	dt_ops.finddevice = fdt_wrapper_finddevice;
 	dt_ops.getprop = fdt_wrapper_getprop;
 	dt_ops.setprop = fdt_wrapper_setprop;
@@ -191,21 +198,31 @@ void *fdt_init(void *blob)
 	dt_ops.del_node = fdt_wrapper_del_node;
 	dt_ops.get_path = fdt_wrapper_get_path;
 	dt_ops.finalize = fdt_wrapper_finalize;
+	dt_ops.check_header = fdt_wrapper_check_header;
 
 	/* Make sure the dt blob is the right version and so forth */
 	fdt = blob;
 
-	bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
-	buf = malloc(bufsize);
-	//if(!buf)
-	//	fatal("malloc failed. can't relocate the device tree\n\r");
+	/* Don't use local copy as Kernel claims this memory after mem init
+	 * As a result, FDT can not be parsed in kernel modules
+	 */
+#ifdef USE_LOCAL_FDT_COPY
+	{
+		int err;
+		int bufsize;
 
-	err = fdt_open_into(fdt, buf, bufsize);
+		bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
+		buf = malloc(bufsize);
+		//if(!buf)
+		//	fatal("malloc failed. can't relocate the device tree\n\r");
 
-	//if (err != 0)
-	//	fatal("fdt_init(): %s\n\r", fdt_strerror(err));
+		err = fdt_open_into(fdt, buf, bufsize);
 
-	fdt = buf;
+		//if (err != 0)
+		//	fatal("fdt_init(): %s\n\r", fdt_strerror(err));
 
+		fdt = buf;
+	}
+#endif
 	return fdt;
 }
diff --git a/arch/mips/netlogic/boot/ops.h b/arch/mips/netlogic/boot/ops.h
index 6459ab2..a60c2d5 100644
--- a/arch/mips/netlogic/boot/ops.h
+++ b/arch/mips/netlogic/boot/ops.h
@@ -51,6 +51,7 @@ struct dt_ops {
 	                                 const char *compat);
 	unsigned long (*finalize)(void);
 	char *(*get_path)(const void *phandle, char *buf, int len);
+	int (*check_header)(void);
 };
 extern struct dt_ops dt_ops;
 
@@ -94,6 +95,7 @@ int dt_is_compatible(void *node, const char *compat);
 void dt_get_reg_format(void *node, unsigned int *naddr, unsigned int *nsize);
 int dt_get_virtual_reg(void *node, void **addr, int nres);
 
+
 static inline void *finddevice(const char *name)
 {
 	return (dt_ops.finddevice) ? dt_ops.finddevice(name) : NULL;
@@ -186,6 +188,13 @@ static inline void *find_node_by_compatible(const void *prev,
 	return NULL;
 }
 
+static inline int check_header(void)
+{
+	if (dt_ops.check_header)
+		return dt_ops.check_header();
+	return -1;
+}
+
 void dt_fixup_memory(unsigned long long start, unsigned long long size);
 void dt_fixup_cpu_clocks(unsigned int cpufreq, unsigned int tbfreq, unsigned int busfreq);
 void dt_fixup_clock(const char *path, unsigned int freq);
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index cac4172..432a95a 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -387,6 +387,7 @@ static int fdt_process(void)
 	fdt = fdt_init(blob);
 	if(!fdt)
 		return -1;
+	printk("Cached handle for FDT @ %p\n", fdt);
 
 	/* extract cmdline params
 	 */
-- 
1.8.4.93.g57e4c17

