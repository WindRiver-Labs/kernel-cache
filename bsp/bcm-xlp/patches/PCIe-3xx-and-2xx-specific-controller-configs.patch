From 8653a96745f788b7e79fb690cdcf4abe68d07271 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Thu, 17 Jan 2013 10:53:12 -0800
Subject: [PATCH 456/565] PCIe : 3xx and 2xx specific controller configs

Depending on the cpu type and board, pcie controllers need to be initialized
differently. This commit implements cpu/board specific configurations for
2xx, 3xx, 3xx_L, 3xx_LP, 3xx_LPV2

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/pci/pci-xlp.c | 170 ++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 136 insertions(+), 34 deletions(-)

diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 9af3062..26ce2c1 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -38,7 +38,11 @@
 #include <linux/mm.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#if defined CONFIG_PCIEPORTBUS
+#include <linux/pcieport_if.h>
+#endif
 #include <asm/io.h>
+
 #include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/io.h>
 #include <asm/netlogic/iomap.h>
@@ -102,6 +106,9 @@ u64 xlp_syscfg_base[NLM_MAX_CPU_NODE] = { XLP_BDF_BASE(0,6,5),
  * 2:	1x8 lanes (ctrl 0), 2x4 lanes (ctrl 2, 3)
  * 3:	4x4 lanes (all ctrls 4 lanes)
  * PRM 31.11.7.2 (power on reset config register)
+ *
+ * But XLP3xx{L,H,Q} have fixed configuration (no need to read plc)
+ * given in Section 22 of PRM
  */
 #define XLP_PCI_LANE_CONFIG	4
 
@@ -192,6 +199,23 @@ static int xlp_map_helper(u8 node, int row, int fn)
 	return 0;
 }
 
+#if defined CONFIG_PCIEPORTBUS
+int xlp_is_dev_rc(struct pci_dev *dev)
+{
+	u16 reg16 = 0;
+	int pos, port_type = 0;
+
+	if (!(pos = pci_find_capability(dev, PCI_CAP_ID_EXP)))
+		return -EINVAL;
+	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
+	port_type = (reg16 >> 4) & PORT_TYPE_MASK;
+	if (port_type == PCIE_RC_PORT) {
+		return 0;
+	}
+	return -EINVAL;
+}
+#endif
+
 /*
  * Iterates over buses to find out the slot (thus pci controller fn)
  */
@@ -200,6 +224,15 @@ int xlp_ctrl_fn_from_dev(const struct pci_dev *dev, struct xlp_nodefn_struct *n)
 	__label__ out;
 	int row = 0, fn = 0, node;
 
+#if defined CONFIG_PCIEPORTBUS
+	if (xlp_is_dev_rc(dev) == 0) {
+		int slot = (dev->devfn >> 3) & 0x1f;
+		fn = dev->devfn & 0x3;
+		node = slot / 8;
+		n->node = node; n->fn = fn;
+		return 0;
+	}
+#endif
 	for_each_online_node(node){
 		row = 0;
 		while (row < XLP_MAX_SLOTS) {
@@ -500,6 +533,16 @@ static inline __u32 pci_cfg_read_32bit(__u32 addr)
 	return temp;
 }
 
+static inline __u16 pci_cfg_read_16bit(__u32 addr)
+{
+    return *((__u16*)(pci_config_base + (addr & ~1)));
+}
+
+static inline __u8 pci_cfg_read_8bit(__u32 addr)
+{
+    return *((__u8 *)(pci_config_base + (addr & ~0)));
+}
+
 static inline void pci_cfg_write_32bit(__u32 addr, __u32 data)
 {
         unsigned int *p = (unsigned int *)(pci_config_base + (addr & ~3));
@@ -507,6 +550,16 @@ static inline void pci_cfg_write_32bit(__u32 addr, __u32 data)
 	*p = data;
 }
 
+static inline void pci_cfg_write_16bit(__u32 addr, __u16 data)
+{
+    *((__u16*)(pci_config_base + (addr & ~1))) = data;
+}
+
+static inline void pci_cfg_write_8bit(__u32 addr, __u8 data)
+{
+    *((__u8 *)(pci_config_base + (addr & ~0))) = data;
+}
+
 static int pci_bus_status = 0;
 //#define pci_cfg_offset(bus, devfn, where) (((bus)<<16)+((devfn)<<8)+(where))  //for PCI config space
 #define pci_cfg_offset(bus, devfn, where) (((bus)<<20)+((devfn)<<12)+(where))	//for PCIE config space
@@ -515,26 +568,34 @@ static int pci_bus_status = 0;
 static int xlp_pcibios_read(struct pci_bus *bus, unsigned int devfn,
 				int where, int size, u32 * val)
 {
-	__u32 data = 0;
-
-	if ((size == 2) && (where & 1))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	else if ((size == 4) && (where & 3))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	if (pci_bus_status)
-		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
-	else
-		data = 0xFFFFFFFF;
-
-	if (size == 1)
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-	else if (size == 2)
-		*val = (data >> ((where & 3) << 3)) & 0xffff;
-	else
-		*val = data;
-
-	return PCIBIOS_SUCCESSFUL;
+    if( (!bus->self) || (bus->self->vendor ==  PCI_VENDOR_ID_NETLOGIC)) {
+        __u32 data = 0;
+
+        if ((size == 2) && (where & 1))
+            return PCIBIOS_BAD_REGISTER_NUMBER;
+        else if ((size == 4) && (where & 3))
+            return PCIBIOS_BAD_REGISTER_NUMBER;
+
+        if (pci_bus_status)
+            data = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
+        else
+            data = 0xFFFFFFFF;
+
+        if (size == 1)
+            *val = (data >> ((where & 3) << 3)) & 0xff;
+        else if (size == 2)
+            *val = (data >> ((where & 3) << 3)) & 0xffff;
+        else
+            *val = data;
+    } else { /* other vendors */
+        if      (size == 1)
+            *val = pci_cfg_read_8bit (pci_cfg_offset((bus->number), devfn, where));
+        else if (size == 2)
+            *val = pci_cfg_read_16bit(pci_cfg_offset((bus->number), devfn, where));
+        else  /*(size == 4) */
+            *val = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
+    }
+    return PCIBIOS_SUCCESSFUL;
 }
 
 static int xlp_pcibios_write(struct pci_bus *bus, unsigned int devfn,
@@ -551,18 +612,27 @@ static int xlp_pcibios_write(struct pci_bus *bus, unsigned int devfn,
 	if (!pci_bus_status)
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	data = pci_cfg_read_32bit(cfgaddr);
-
-	if (size == 1)
-		data = (data & ~(0xff << ((where & 3) << 3))) |
-			(val << ((where & 3) << 3));
-	else if (size == 2)
-		data = (data & ~(0xffff << ((where & 3) << 3))) |
-			(val << ((where & 3) << 3));
-	else
-		data = val;
-
-	pci_cfg_write_32bit(cfgaddr, data);
+	if( (!bus->self) || (bus->self->vendor ==  PCI_VENDOR_ID_NETLOGIC)) {
+		data = pci_cfg_read_32bit(cfgaddr);
+
+		if (size == 1)
+			data = (data & ~(0xff << ((where & 3) << 3))) |
+				    ((val & 0xff) << ((where & 3) << 3));
+		else if (size == 2)
+			data = (data & ~(0xffff << ((where & 3) << 3))) |
+				    ((val & 0xffff) << ((where & 3) << 3));
+		else
+			data = val;
+
+		pci_cfg_write_32bit(cfgaddr, data);
+	} else { /* every other vendor can have byte, word or double word access */
+		if      (size == 1)
+			pci_cfg_write_8bit ( cfgaddr, (__u8 )val);
+		else if (size == 2)
+			pci_cfg_write_16bit( cfgaddr, (__u16)val);
+		else /* (size == 4) */
+			pci_cfg_write_32bit( cfgaddr,        val);
+	}
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -608,7 +678,7 @@ struct pci_controller xlp_controller = {
  * But for any devices connected on these controllers, consult the populated
  * table and return corresponding interrupt.
  */
-int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+int __init xlp_8xx_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int row = 0;
 	struct xlp_nodefn_struct nfn;
@@ -617,11 +687,43 @@ int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 		dev_printk(KERN_ERR, &dev->dev, "Could not resolve device to a node/bus pair\n");
 		return 0;
 	}
-	row = (xlp_get_power_on_reset_cfg(nfn.node) >> 23) & 0x3;
+	if (is_nlm_xlp8xx()) {
+		row = (xlp_get_power_on_reset_cfg(nfn.node) >> 23) & 0x3;
+	} else {
+		row = (xlp_get_power_on_reset_cfg(nfn.node) >> 12) & 0x3;
+	}
 	dev_printk(KERN_DEBUG, &dev->dev, "Assigning interrupt %#x\n", node_irqmap[nfn.node][row].farray[nfn.fn].intno);
 	return node_irqmap[nfn.node][row].farray[nfn.fn].intno;
 }
 
+int __init xlp_3xx_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int row = 0;
+	struct xlp_nodefn_struct nfn;
+
+	if (xlp_ctrl_fn_from_dev(dev, &nfn) != 0) {
+		dev_printk(KERN_ERR, &dev->dev, "Could not resolve device to a node/bus pair\n");
+		return 0;
+	}
+	dev_printk(KERN_DEBUG, &dev->dev, "Assigning interrupt %#x\n", node_irqmap[nfn.node][row].farray[nfn.fn].intno);
+	return node_irqmap[nfn.node][row].farray[nfn.fn].intno;
+
+}
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (dev->bus->number == 0) {
+		return 0;
+	}
+	if (is_nlm_xlp8xx() || is_nlm_xlp2xx()) {
+		return xlp_8xx_pcibios_map_irq(dev, slot, pin);
+	} else if (is_nlm_xlp3xx()) {
+		return xlp_3xx_pcibios_map_irq(dev, slot, pin);
+	}
+	panic("Can't map IRQ for unknown CPU type\n");
+}
+
+
 /* Do platform specific device initialization at pci_enable_device() time */
 int pcibios_plat_dev_init(struct pci_dev *dev)
 {
-- 
1.8.4.93.g57e4c17

