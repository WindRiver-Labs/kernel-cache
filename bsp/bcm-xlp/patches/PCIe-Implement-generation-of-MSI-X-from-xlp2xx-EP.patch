From ea44de735e6979cf9570340e133b00db4d71e926 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Fri, 11 Jan 2013 14:46:43 -0800
Subject: [PATCH 451/565] PCIe : Implement generation of MSI-X from xlp2xx EP

XLP EP requires MSI-X control register enable bit set in order to write the
message table entries. This commit implements this feature specific to XLP EPs
on XLP RCs

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/msi.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/arch/mips/netlogic/xlp/msi.c b/arch/mips/netlogic/xlp/msi.c
index b995858..a9e881f 100644
--- a/arch/mips/netlogic/xlp/msi.c
+++ b/arch/mips/netlogic/xlp/msi.c
@@ -97,6 +97,31 @@ static int xlp_msi_compose_msg(struct pci_dev *pdev, struct msi_desc *desc,
 
 #ifdef arch_setup_msi_irqs
 /*
+ * For xlp EP, in order for access to msix table space (internal to pci
+ * controller) to succeed, msix bit should be enabled
+ */
+void setup_xlpep_msi_access(struct pci_dev *dev, int mode, int enable)
+{
+	int pos;
+	u16 control;
+
+	if((dev->vendor != PCI_VENDOR_ID_NETLOGIC) || (dev->device != 0x1004)){
+		return;
+	}
+	if (mode != XLP_INTMODE_MSIX) { /* Non MSI-X access */
+		return;
+	}
+	/* read msix control reg */
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
+	pci_read_config_word(dev, pos + PCI_MSIX_FLAGS, &control);
+	if (enable != 0) { /* enable msix */
+		control |= PCI_MSIX_FLAGS_ENABLE;
+	} else {
+		control &= ~PCI_MSIX_FLAGS_ENABLE;
+	}
+	pci_write_config_word(dev, pos + PCI_MSIX_FLAGS, control);
+}
+/*
  * Backend function that sets up MSI.
  * Called from arch_setup_msi_irqs()
  *
@@ -134,6 +159,7 @@ int xlp_setup_msi_irq(struct pci_dev *dev, int nvec)
 	old_count = msi_vec[nfn.node][nfn.fn].count;
 
 	bit = idx = 0;
+	setup_xlpep_msi_access(dev, XLP_INTMODE_MSI, 1);
 	list_for_each_entry(desc, &dev->msi_list, list) {
 		if (msi_vec[nfn.node][nfn.fn].bitmap == 0) {
 			bit = 0;
@@ -160,6 +186,7 @@ int xlp_setup_msi_irq(struct pci_dev *dev, int nvec)
 		write_msi_msg(base_msi + bit, &msg);
 		idx++;
 	}
+	setup_xlpep_msi_access(dev, XLP_INTMODE_MSI, 0);
 	ret = xlp_set_ctrl_intmode(nfn.node, nfn.fn, XLP_INTMODE_MSI);
 	if (ret == 0) {	/* success */
 		dev->irq = new_irq;
@@ -212,6 +239,7 @@ int xlp_setup_msix_irq(struct pci_dev *dev, int nvec)
 		goto setup_end;
 	}
 	bit = 0, idx = 0;
+	setup_xlpep_msi_access(dev, XLP_INTMODE_MSIX, 1);
 	list_for_each_entry(desc, &dev->msi_list, list) {
 		/* this loops exactly nvec times */
 		if (msix_vec[nfn.node][nfn.fn].bitmap == 0) {
@@ -241,6 +269,7 @@ int xlp_setup_msix_irq(struct pci_dev *dev, int nvec)
 		write_msi_msg(base_msix + bit, &msg);
 		idx++;
 	}
+	setup_xlpep_msi_access(dev, XLP_INTMODE_MSIX, 0);
 	spin_unlock_irqrestore(&xlp_msi_lock, flags);
 	return 0;
 fail_loop:
-- 
1.8.4.93.g57e4c17

