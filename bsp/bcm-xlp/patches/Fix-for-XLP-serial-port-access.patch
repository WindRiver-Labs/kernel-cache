From 7a1339f50313973fa129f30b2d5000041914a9dd Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Wed, 11 Aug 2010 19:22:19 +0530
Subject: [PATCH 090/565] Fix for XLP serial port access

Fix for XLP serial port access(XLP also needs the same workaround as XLR).

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/platform-xlp.c | 45 ++++++++++++++++++++++++++++++++---
 1 file changed, 42 insertions(+), 3 deletions(-)

diff --git a/arch/mips/netlogic/xlp/platform-xlp.c b/arch/mips/netlogic/xlp/platform-xlp.c
index 4819ad7..06de273 100644
--- a/arch/mips/netlogic/xlp/platform-xlp.c
+++ b/arch/mips/netlogic/xlp/platform-xlp.c
@@ -29,6 +29,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
 #include <linux/pci.h>
+#include <linux/serial_reg.h>
 
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
@@ -139,6 +140,42 @@ static void xlp_default_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_ba
 {
 }
 
+unsigned int xlp_uart_in(struct uart_port *p, int offset)
+{
+	nlm_reg_t *mmio;
+	unsigned int value;
+
+	/* XLP uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	value = netlogic_read_reg(mmio, 0);
+
+	/* IS this required for XLP too ? */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	return value;
+
+}
+
+void xlp_uart_out(struct uart_port *p, int offset, int value)
+{
+	nlm_reg_t *mmio;
+
+	/* IS this required for XLP too ? */
+	if (offset == UART_MSR)
+		value ^= 0xF0;
+	else if (offset == UART_MCR)
+		value ^= 0x3;
+
+	/* XLP uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	netlogic_write_reg(mmio, 0, value);
+}
+
 static void xlp_uart_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
 {
 	static atomic_t num_uarts = ATOMIC_INIT(0);
@@ -174,10 +211,12 @@ static void xlp_uart_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
 	uart_ports[instance].irq           = PIC_UART_0_IRQ + instance;
 
 	uart_ports[instance].uartclk       = UART_CLK;
-	uart_ports[instance].iotype        = UPIO_MEM;
-	uart_ports[instance].flags         = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
-	uart_ports[instance].type          = UPIO_PORT;
+	uart_ports[instance].iotype        = UPIO_NLM;
+	uart_ports[instance].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
+	uart_ports[instance].type          = PORT_16550A;
 	uart_ports[instance].regshift      = 2;
+	uart_ports[instance].serial_in      = xlp_uart_in;
+	uart_ports[instance].serial_out      = xlp_uart_out;
 
 	printk("Platform added UART port_%d (irq=%d, @%lx)\n", instance,
 	       uart_ports[instance].irq, (unsigned long)uart_ports[instance].mapbase);
-- 
1.8.4.93.g57e4c17

