From 07265073f21983c5dcc77494dd7471c69412927d Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Date: Sun, 23 May 2010 15:58:05 -0700
Subject: [PATCH 022/565] Followup to the previous cleanup-checkin.

Remove more unwanted code and references
from xlp_setup.c, now that xlr_setup.c is
separated. Includes the usb-4g check removal
as well.

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/setup.c | 200 +++++------------------------------------
 arch/mips/netlogic/xlp/smp.c   |   5 --
 2 files changed, 22 insertions(+), 183 deletions(-)

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 2b5cd1b..f32a465 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -102,23 +102,24 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #define DEF_PHYMEM_START_ADDR 	0x100000
 #define DEF_PHYMEM_SIZE 		0x0ff00000
 
-#define LOADER_KSEG_DEFAULTS nlm_common_loader_kseg_start = NLM_LOADER_KSEG0_START;\
-		nlm_common_loader_kseg_size = NLM_LOADER_KSEG0_SIZE;
-
-#define LOADER_KUSEG_DEFAULTS   \
-		memset(kuseg_mem_map, 0, (sizeof(struct kuseg_mem_info) * 4));	\
-		use_kuseg_defaults(map);
+int xlr_hybrid;
+int xlr_loader_support=0;
+int xlr_loader_sharedcore=0;
+int xlr_loader_own_gmac=0;
+int xlr_loader_own_dma=0;
+uint32_t xlr_linux_cpu_mask;
+int xlr_console_pci_con_dev = 0;
+int xlr_console_pci_con_baud = 0;
+int xlr_boot_over_nfs = 0;
+unsigned long nlm_common_ebase = 0x0;
 
-extern void *fdt;
 static char prop_buf[MAX_PROP_LEN];
 extern char _end;
-
+extern void *fdt;
 extern void *fdt_init(void *blob);
 extern void *simple_alloc_init(char *base, unsigned long heap_size,
 		unsigned long granularity, unsigned long max_allocs);
 
-/* by default, do not assume u-boot */
-int loader_used = LOADER_UBOOT;
 int onlinemask = 0x1;
 
 /* Struct for temp. allocation
@@ -140,14 +141,6 @@ unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
 spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
 
 __u8 nlm_common_base_mac_addr[6];
-volatile nlm_common_loader_shared_struct_t *nlm_common_loader_sh_mem = NULL;
-/* used for command line parsing */
-uint32_t nlm_common_loader_kseg_start, nlm_common_loader_kseg_size;
-uint32_t nlm_common_loader_mask;
-/* Size of the shared memory b/w Linux userapp and rmios apps */
-uint32_t nlm_common_app_sh_mem_sz;
-unsigned long  nlm_common_app_shmem_start;
-static int index = 0;
 
 /* xls chip family variables */
 int chip_is_xls6xx = 0;
@@ -181,7 +174,6 @@ struct kuseg_mem_info kuseg_mem_map[MAX_NUM_KUSEG_BLOCKS];
 
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
-static int dyna_exc_index=0;
 extern unsigned long _text[];
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
@@ -220,21 +212,6 @@ static struct physmap_info {
 
 struct boot_mem_map boot_physaddr_info;
 
-/* Maintain in ascending order of 
- * the starting physical addresses 
- */
-static struct boot_mem_map_exclude_region dynamic_exclude_regions[] = {
-	[0] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
-	[1] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
-	[2] = {0, 0}, /* Loader KSEG0 region */
-	[3] = {0, 0}, /* Loader KUSEG region Block 1*/
-	[4] = {0, 0}, /* Loader KUSEG region Block 2 or Hybrid Mode exclusion*/
-	[5] = {0, 0}, /* Loader KUSEG region Block 3 or Hybrid Mode exclusion */
-	[6] = {0, 0}, /* Loader KUSEG region Block 4 or Hybrid Mode exclusion */
-	[7] = {0, 0}, /* Hybrid Mode exclusion*/
-	[8] = {0, 0}, /* END of the list - MUST be the last entry always */
-};
-
 static char *get_psb_physmap_name(int type)
 {
 	int i = 0;
@@ -248,10 +225,6 @@ static char *get_psb_physmap_name(int type)
 	return ("Unknown type");
 }
 
-/* Return value
- * 	1 ==> IO (or not found)
- *  0 ==> mem 
- */
 int nlm_common_get_pgprot(unsigned long address)
 {
 	int i;
@@ -295,13 +268,7 @@ const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
 
 const char *get_system_type(void)
 {
-#ifdef CONFIG_NLM_XLP
 	return "Netlogic XLP SIM";
-#else
-	if ( is_xls() )
-		return "Netlogic XLS";
-	return "Netlogic XLR";
-#endif
 }
 
 #ifdef CONFIG_SMP
@@ -348,7 +315,6 @@ void prom_reconfigure_thr_resources(void)
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 	/* netlogic kernel configures this 
 	 */
-
 	if (nlm_shtlb && (nlm_asid_mask == 0x3f)) {
 		/* Global TLB will work only if all 
 		 * the enabled cores have all their
@@ -374,14 +340,10 @@ void prom_reconfigure_thr_resources(void)
 			return;
 		}
 	}
-	
 	return;
-
 #endif /* CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID */
 
-
 	 if (netlogic_thr_id() == 0) { 
-
 		for (i=0;i<4;i++) {
 			if (thr_mask & (1<<i)) {
 				if (i != count)
@@ -389,38 +351,21 @@ void prom_reconfigure_thr_resources(void)
 				count++;
 			}
 		}
-
 		switch(count) {
 			case 1: value = 0x00; break;
 			case 2: value = 0x02; break;
 			default:
 					value = 0x03; break;
 		}
-
 		if (dis_contig)
 			value = 0x3; 
-
 		mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
 		mmu_setup = mmu_setup & ~0x06;
 		mmu_setup |= (value << 1);
-
 		write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
 	} 
 }
 
-int xlr_hybrid;
-int xlr_loader_support=0;
-int xlr_loader_sharedcore=0;
-int xlr_loader_own_gmac=0;
-int xlr_loader_own_dma=0;
-
-uint32_t xlr_linux_cpu_mask;
-int xlr_console_pci_con_dev = 0;
-int xlr_console_pci_con_baud = 0;
-int xlr_boot_over_nfs = 0;
-
-unsigned long nlm_common_ebase = 0x0;
-
 #if !defined(CONFIG_NLMCOMMON_MAC)
 struct user_mac_data *user_mac;
 struct xlr_user_mac_config xlr_user_mac;
@@ -446,131 +391,31 @@ static void setup_default_configuration(void)
 	xlr_loader_own_gmac = 0;
 	xlr_loader_own_dma = 0;
 	xlr_linux_cpu_mask = DEFAULT_LINUX_CPU_MASK; 
-	nlm_common_loader_kseg_start = 0;
-	for ( index = 0 ; index < MAX_NUM_KUSEG_BLOCKS ; index++) {
-		kuseg_mem_map[index].start_addr = 0;
-		kuseg_mem_map[index].size = 0;
-	}
-	nlm_common_loader_kseg_size = 0;
-	nlm_common_loader_mask = DEFAULT_LOADER_MASK;
-
-	nlm_common_psb_shm = 0;
-
 	init_default_macaddr();
 }
 
-void exclude_hybrid_mem_region(void)
-{
-	if (xlr_loader_support){
-		return;
-	}
-	dynamic_exclude_regions[dyna_exc_index].start = 1<<20;
-	dynamic_exclude_regions[dyna_exc_index].end = 
-		(unsigned long long)(((unsigned long)&_text) & 0x1fffffffUL);
-	dyna_exc_index++;
-}
-
-#ifndef CONFIG_MAPPED_KERNEL
-static void xlr_early_hybrid_setup(char *str)
-{
-
-	hybrid_str = str;
-
-
-    if ((strcmp(str, "=rmios_ipsec") == 0)||
-		 (strcmp(str, "rmios_ipsec") == 0)) {
-        exclude_hybrid_mem_region();
-	}
-	else if ((strcmp(str, "=rmios_tcpip_stack") == 0)||
-		 (strcmp(str, "rmios_tcpip_stack") == 0)) {
-		exclude_hybrid_mem_region();
-	}
-}
-#endif
-
 unsigned int __cpuinit get_c0_compare_int(void)
 {
     return IRQ_TIMER;
 }
 
+/* TODO: Get this from FDT */
 void plat_time_init(void)
 {
-    extern void nlm_common_timer_setup(void);
-
-	if (loader_used == LOADER_UBOOT) {
-		/* this is currently hardcoded from
-		 * the bootloader value, to be fixed
-		 */
-    	mips_hpt_frequency = (unsigned int)0x5f5e1000;
-	}
-	else {
-    	mips_hpt_frequency = (unsigned int)prom_info->cpu_frequency;
-	}
-
-    printk("mips_hpt_frequency = %u\n", mips_hpt_frequency);
-
-    nlm_common_timer_setup();
-}
-
-#ifdef CONFIG_NLM_COMMON
-int avail_mem_above_4G;
-int force_usb __initdata = 0;
-static int __init xls_force_usb(char *p)
-{
-    force_usb = 1;
-        return 0;
+	extern void nlm_common_timer_setup(void);
+	mips_hpt_frequency = (unsigned int)0x5f5e1000;
+	printk("mips_hpt_frequency = %u\n", mips_hpt_frequency);
+	nlm_common_timer_setup();
 }
-early_param("forceusb", xls_force_usb);
-
-
-/* This routine is useful when USB is desired on
- * 64-Bit Linux with DRAM mapped >4G. On such systems,
- * since the XLS USB controller is 32-bit, USB is
- * disabled. Use command line option 'forceusb' to
- * enable it; This adjusts the mapped available mem
- * to a max of till 0xFFFFFFFF.
- */
-static void __init tweak_avail_dram_map(void) {
-
-    int j=0;
-    int nrmap_ctr = (boot_mem_map.nr_map - 1);
-
-    avail_mem_above_4G = 0;
-
-    for (j=nrmap_ctr; j>=0; j--) {
-        if ((boot_mem_map.map[j].addr + boot_mem_map.map[j].size)
-                > 0x100000000ULL) {
-            avail_mem_above_4G++;
-#ifdef CONFIG_64BIT
-            if (force_usb) {
-                printk(KERN_WARNING "[USB]:Re-adjusting Available DRAM map\n");
-                if (boot_mem_map.map[j].addr > 0x100000000ULL) {
-                    boot_mem_map.nr_map--;
-                }
-                else {
-                    /* Reclaim whatever we can... */
-                    boot_mem_map.map[j].size =
-                        0x100000000ULL - boot_mem_map.map[j].addr;
-                }
-            }
-#endif
-        }
-    }
-}
-#endif
 
 void __init plat_mem_setup(void)
 {
 	extern int panic_timeout;
   
-	panic_timeout = 5;  
-  
+	panic_timeout 	 = 5;  
 	_machine_restart = (void (*)(char *))ptr_linux_exit;
 	_machine_halt    = ptr_linux_exit;
 	pm_power_off 	 = ptr_linux_exit;
-
-        tweak_avail_dram_map();
-
 	return;
 }  
 
@@ -747,7 +592,8 @@ static int fdt_process(void)
 	 */
 	node = finddevice("/cpus");
 	if (node) {
-		if (getprop(node, "onlinemask", &onlinemask, sizeof(onlinemask)) < 0)
+		if (getprop(node, "onlinemask", &onlinemask, 
+					sizeof(onlinemask)) < 0)
 			return -1;
 	}
 	if (!onlinemask) 
@@ -775,12 +621,10 @@ void __init prom_init(void)
 
 	fdt_process();
 
-	if (loader_used == LOADER_UBOOT) {
-		use_default_phymem = TRUE;
-		goto setup_ebase;
-	}
+	/* TODO: Use regular memory map */
+	 
+	use_default_phymem = TRUE;
 
-setup_ebase:
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
 	prom_add_memory();
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 4ee5902..fab8745 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -52,7 +52,6 @@ extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 struct smp_boot_info smp_boot;
 extern void prom_reconfigure_thr_resources(void);
-extern uint32_t nlm_common_loader_mask;
 extern unsigned long nlm_common_ebase;
 
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
@@ -149,10 +148,6 @@ void __init nlm_smp_setup(void)
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	if(xlr_loader_support) {
-		smp_boot.online_map &= ~nlm_common_loader_mask;
-	}
-
 	boot_cpu_online_map = smp_boot.online_map;
 	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
 
-- 
1.8.4.93.g57e4c17

