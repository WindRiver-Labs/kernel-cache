From 2af19122e9c281e403c3278f3af8193af0ebcd08 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 9 Sep 2013 11:06:58 +0800
Subject: [PATCH 556/565] bcm-xlp: clean up some drivers codes

Clean up some of this board's special drivers codes:
1. remove some deprecated codes in Linux V3.10, such as __devinitdata;
2. use the new proc FS operations to replace the old.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/sae/nlm_crypto.c | 865 +++++++++++++++++++++-------------------
 drivers/dma/nlm_adma.c          |   4 +-
 drivers/i2c/busses/i2c-xlp.c    |   6 +-
 drivers/mmc/host/sdhci-xlp.c    |  24 +-
 drivers/spi/spi_xlp.c           |   6 +-
 5 files changed, 461 insertions(+), 444 deletions(-)

diff --git a/drivers/crypto/sae/nlm_crypto.c b/drivers/crypto/sae/nlm_crypto.c
index cce94f2..bddd839 100644
--- a/drivers/crypto/sae/nlm_crypto.c
+++ b/drivers/crypto/sae/nlm_crypto.c
@@ -15,6 +15,7 @@
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msgring.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <asm/netlogic/proc.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
@@ -24,19 +25,17 @@
 #include <linux/crypto.h>
 #include "nlm_async.h"
 
-
 #ifdef TRACING
 #define TRACE_TEXT(str) printk(str);
 #define TRACE_RET printk(")")
-#else				/* !TRACING */
+#else /* !TRACING */
 #define TRACE_TEXT(str) ((void) 0)
 #define TRACE_RET ((void) 0)
-#endif				/* TRACING */
+#endif /* TRACING */
 #undef NLM_CRYPTO_DEBUG
 #define NETL_OP_ENCRYPT 1
 #define NETL_OP_DECRYPT 0
 
-
 /**
  * @defgroup crypto Crypto API
  * @brief Description about the crypto apis
@@ -46,7 +45,6 @@
 
 #define xtract_bits(x, bitpos, numofbits) ((x) >> (bitpos) & ((1ULL << (numofbits)) - 1))
 
-
 extern struct proc_dir_entry *nlm_root_proc;
 extern int xlp_aead_alg_init(void);
 extern void xlp_aead_alg_fini(void);
@@ -63,9 +61,7 @@ static int xlp_sae_release(struct inode *, struct file *);
 struct nlm_crypto_stat crypto_stat[MAX_CPU];
 int crypto_vc_base;
 int crypto_vc_limit;
-int nlm_crypto_chip_features = 0 ;
-
-
+int nlm_crypto_chip_features = 0;
 
 /*
  * is the following table needed for all modes?
@@ -78,125 +74,117 @@ Cipher            keylen           iv_len
 //CBC, CFB, OFB and CTR modes..
 int cipher_mode_iv_len[NLM_CIPHER_MAX][NLM_CIPHER_MODE_MAX] = {
 /*		       ECB  CBC   CFB   OFB   CTR  AESF8    GCM  CCM    8   9  LRW   XTS */
-/* BYPASS */       {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* DES */          {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* 3DES */         {   0,    8,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* AES128 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* AES192 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* AES256 */       {   0,    16,   16,   16,   8,   16,     8,   8,   0,  0,  16,   16,},
-/* ARC4 */         {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* KASUMI F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* SNOW3G F8 */    {   0,    0,    0,    0,    0,    0,      0,    0,   0,  0,  0,    0,},
-/* CAMELLIA128 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,},
-/* CAMELLIA192 */  {   0,    16,   16,   16,   16,   16,     -1,   0,   0,  0,  16,   16,}, 
-/* CAMELLIA256 */  {   0,    16,   16,   16,   16,   16      -1,   0,   0,  0,  16,   16,},
+/* BYPASS */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* DES */ {0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* 3DES */ {0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* AES128 */ {0, 16, 16, 16, 8, 16, 8, 8, 0, 0, 16, 16,},
+/* AES192 */ {0, 16, 16, 16, 8, 16, 8, 8, 0, 0, 16, 16,},
+/* AES256 */ {0, 16, 16, 16, 8, 16, 8, 8, 0, 0, 16, 16,},
+/* ARC4 */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* KASUMI F8 */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* SNOW3G F8 */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
+/* CAMELLIA128 */ {0, 16, 16, 16, 16, 16, -1, 0, 0, 0, 16, 16,},
+/* CAMELLIA192 */ {0, 16, 16, 16, 16, 16, -1, 0, 0, 0, 16, 16,},
+/* CAMELLIA256 */ {0, 16, 16, 16, 16, 16 - 1, 0, 0, 0, 16, 16,},
 };
 
 #define NLM_CRYPTO_MAX_STR_LEN 200
 #ifdef NLM_CRYPTO_DEBUG
 static char str_cipher_alg[NLM_CIPHER_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"bypass",       // NLM_CIPHER_BYPASS
-"des",          // NLM_CIPHER_DES
-"3des",         // NLM_CIPHER_3DES
-"aes 128",      // NLM_CIPHER_AES128
-"aes 192",      // NLM_CIPHER_AES192
-"aes 256",      // NLM_CIPHER_AES256
-"arc4",         // NLM_CIPHER_ARC4
-"Kasumi f8",    // NLM_CIPHER_KASUMI_F8
-"snow3g f8",    // NLM_CIPHER_SNOW3G_F8
-"camellia 128", // NLM_CIPHER_CAMELLIA128
-"camelia 192",  // NLM_CIPHER_CAMELLIA192
-"camelia 256",  // NLM_CIPHER_CAMELLIA256
-"undefined",  // > max
+	"bypass",		// NLM_CIPHER_BYPASS
+	"des",			// NLM_CIPHER_DES
+	"3des",			// NLM_CIPHER_3DES
+	"aes 128",		// NLM_CIPHER_AES128
+	"aes 192",		// NLM_CIPHER_AES192
+	"aes 256",		// NLM_CIPHER_AES256
+	"arc4",			// NLM_CIPHER_ARC4
+	"Kasumi f8",		// NLM_CIPHER_KASUMI_F8
+	"snow3g f8",		// NLM_CIPHER_SNOW3G_F8
+	"camellia 128",		// NLM_CIPHER_CAMELLIA128
+	"camelia 192",		// NLM_CIPHER_CAMELLIA192
+	"camelia 256",		// NLM_CIPHER_CAMELLIA256
+	"undefined",		// > max
 };
-static char str_cipher_mode[NLM_CIPHER_MODE_MAX+ 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"ecb",          // NLM_CIPHER_MODE_ECB
-"cbc",          // NLM_CIPHER_MODE_CBC
-"cfb",          // NLM_CIPHER_MODE_CFB
-"ofb",          // NLM_CIPHER_MODE_OFB
-"ctr",          // NLM_CIPHER_MODE_CTR
-"aes f8",       // NLM_CIPHER_MODE_AES_F8
-"gcm",          // NLM_CIPHER_MODE_GCM
-"ccm",          // NLM_CIPHER_MODE_CCM
-"undefined",    // NLM_CIPHER_MODE_UNDEFINED1
-"undefined",    // NLM_CIPHER_MODE_UNDEFINED2
-"lrw",          // NLM_CIPHER_MODE_LRW
-"xts",          // NLM_CIPHER_MODE_XTS
-"undefined", // > max
+
+static char str_cipher_mode[NLM_CIPHER_MODE_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
+	"ecb",			// NLM_CIPHER_MODE_ECB
+	"cbc",			// NLM_CIPHER_MODE_CBC
+	"cfb",			// NLM_CIPHER_MODE_CFB
+	"ofb",			// NLM_CIPHER_MODE_OFB
+	"ctr",			// NLM_CIPHER_MODE_CTR
+	"aes f8",		// NLM_CIPHER_MODE_AES_F8
+	"gcm",			// NLM_CIPHER_MODE_GCM
+	"ccm",			// NLM_CIPHER_MODE_CCM
+	"undefined",		// NLM_CIPHER_MODE_UNDEFINED1
+	"undefined",		// NLM_CIPHER_MODE_UNDEFINED2
+	"lrw",			// NLM_CIPHER_MODE_LRW
+	"xts",			// NLM_CIPHER_MODE_XTS
+	"undefined",		// > max
 };
+
 static char str_auth_alg[NLM_HASH_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"bypass",       // NLM_AUTH_BYPASS
-"md5",          // NLM_AUTH_MD5
-"sha",          // NLM_AUTH_SHA
-"invalid",       // NLM_AUTH_UNDEFINED
-"aes 128",      // NLM_AUTH_AES128
-"aes 192",      // NLM_AUTH_AES192
-"aes 256",      // NLM_AUTH_AES256
-"kasumi f9",    // NLM_AUTH_KASUMI_F9
-"snow3g f9",    // NLM_AUTH_SNOW3G_F9
-"camellia 128", // NLM_AUTH_CAMELLIA128
-"camellia 192", // NLM_AUTH_CAMELLIA192
-"camellia 256", // NLM_AUTH_CAMELLIA256
-"ghash",        // NLM_AUTH_GHASH
-"undefined",    // > max
+	"bypass",		// NLM_AUTH_BYPASS
+	"md5",			// NLM_AUTH_MD5
+	"sha",			// NLM_AUTH_SHA
+	"invalid",		// NLM_AUTH_UNDEFINED
+	"aes 128",		// NLM_AUTH_AES128
+	"aes 192",		// NLM_AUTH_AES192
+	"aes 256",		// NLM_AUTH_AES256
+	"kasumi f9",		// NLM_AUTH_KASUMI_F9
+	"snow3g f9",		// NLM_AUTH_SNOW3G_F9
+	"camellia 128",		// NLM_AUTH_CAMELLIA128
+	"camellia 192",		// NLM_AUTH_CAMELLIA192
+	"camellia 256",		// NLM_AUTH_CAMELLIA256
+	"ghash",		// NLM_AUTH_GHASH
+	"undefined",		// > max
 };
+
 static char str_auth_mode[NLM_HASH_MODE_MAX + 1][NLM_CRYPTO_MAX_STR_LEN] = {
-"sha1",         // NLM_AUTH_MODE_SHA1
-"sha 224",      // NLM_AUTH_MODE_SHA224
-"sha 256",      // NLM_AUTH_MODE_SHA256
-"sha 384",      // NLM_AUTH_MODE_SHA384
-"sha 512",      // NLM_AUTH_MODE_SHA512
-"cmac",         // NLM_AUTH_MODE_CMAC
-"xcbc",         // NLM_AUTH_MODE_XCBC
-"cbc mac",      // NLM_AUTH_MODE_CBC_MAC
-"undefined", // > max
+	"sha1",			// NLM_AUTH_MODE_SHA1
+	"sha 224",		// NLM_AUTH_MODE_SHA224
+	"sha 256",		// NLM_AUTH_MODE_SHA256
+	"sha 384",		// NLM_AUTH_MODE_SHA384
+	"sha 512",		// NLM_AUTH_MODE_SHA512
+	"cmac",			// NLM_AUTH_MODE_CMAC
+	"xcbc",			// NLM_AUTH_MODE_XCBC
+	"cbc mac",		// NLM_AUTH_MODE_CBC_MAC
+	"undefined",		// > max
 };
-void hex_dump(char * description,unsigned char *in, int num)
+
+void hex_dump(char *description, unsigned char *in, int num)
 {
-        int i, j;
-        char buf[50];
-        char *buf_ptr;
-        printk("%s\n",description);
-
-        for (i = 0; i < num; i+= 16) {
-                if (i + 16 > num) {
-                        buf_ptr = buf;
-                        sprintf(buf_ptr, "    ");
-                        buf_ptr += 4;
-                        for (j = 0 ; j < num - i ; j++) {
-                                sprintf(buf_ptr, "%02x ", in[j + i]);
-                                buf_ptr += 3;
-                        }
-                        *buf_ptr = '\0';
-                        printk("%s\n",buf);
-                        break;
-                }
-                printk("    %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
-                        in[i + 0 ],
-                        in[i + 1 ],
-                        in[i + 2 ],
-                        in[i + 3 ],
-                        in[i + 4 ],
-                        in[i + 5 ],
-                        in[i + 6 ],
-                        in[i + 7 ],
-                        in[i + 8 ],
-                        in[i + 9 ],
-                        in[i + 10],
-                        in[i + 11],
-                        in[i + 12],
-                        in[i + 13],
-                        in[i + 14],
-                        in[i + 15]
-              );
-        }
+	int i, j;
+	char buf[50];
+	char *buf_ptr;
+	printk("%s\n", description);
+
+	for (i = 0; i < num; i += 16) {
+		if (i + 16 > num) {
+			buf_ptr = buf;
+			sprintf(buf_ptr, "    ");
+			buf_ptr += 4;
+			for (j = 0; j < num - i; j++) {
+				sprintf(buf_ptr, "%02x ", in[j + i]);
+				buf_ptr += 3;
+			}
+			*buf_ptr = '\0';
+			printk("%s\n", buf);
+			break;
+		}
+		printk
+		    ("    %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+		     in[i + 0], in[i + 1], in[i + 2], in[i + 3], in[i + 4],
+		     in[i + 5], in[i + 6], in[i + 7], in[i + 8], in[i + 9],
+		     in[i + 10], in[i + 11], in[i + 12], in[i + 13], in[i + 14],
+		     in[i + 15]);
+	}
 }
 
 char *nlm_crypto_cipher_alg_get_name(unsigned int cipher_alg)
 {
 	if (cipher_alg >= NLM_CIPHER_MAX)
 		return str_cipher_alg[NLM_CIPHER_MAX];
-	else 
+	else
 		return str_cipher_alg[cipher_alg];
 }
 
@@ -204,7 +192,7 @@ char *nlm_crypto_cipher_mode_get_name(unsigned int cipher_mode)
 {
 	if (cipher_mode >= NLM_CIPHER_MODE_MAX)
 		return str_cipher_mode[NLM_CIPHER_MODE_MAX];
-	else 
+	else
 		return str_cipher_mode[cipher_mode];
 }
 
@@ -212,7 +200,7 @@ char *nlm_crypto_auth_alg_get_name(unsigned int auth_alg)
 {
 	if (auth_alg >= NLM_HASH_MAX)
 		return str_auth_alg[NLM_HASH_MAX];
-	else 
+	else
 		return str_auth_alg[auth_alg];
 }
 
@@ -220,33 +208,40 @@ char *nlm_crypto_auth_mode_get_name(unsigned int auth_mode)
 {
 	if (auth_mode >= NLM_HASH_MODE_MAX)
 		return str_auth_mode[NLM_HASH_MODE_MAX];
-	else 
+	else
 		return str_auth_mode[auth_mode];
 }
 
 void print_crypto_msg_desc(uint64_t entry1, uint64_t entry2, uint64_t entry3)
 {
-        printk("Security Message Descriptor 0: 0x%llx\n", entry1);
-        printk("Security Message Descriptor 1: 0x%llx\n", entry2);
-        printk("Security Message Descriptor 2: 0x%llx\n", entry3);
-
-
-        printk("Free descriptor response destination : 0x%llx  \n", xtract_bits(entry1, 48, 16));
-        printk("Use designer freeback : 0x%llx  \n", xtract_bits(entry1, 45, 1));
-        printk("cipher key length (in dwords) : 0x%llx  \n", xtract_bits(entry1, 40, 5));
-        printf("Control desc cacheline addr : 0x%llx  \n", xtract_bits(entry1, 0, 34));
-        if (xtract_bits(entry1, 45, 1)) {
-                printf("Designer freeback length (actual len - 1): 0x%llx  \n", xtract_bits(entry1, 46, 2));
-        }
-
+	printk("Security Message Descriptor 0: 0x%llx\n", entry1);
+	printk("Security Message Descriptor 1: 0x%llx\n", entry2);
+	printk("Security Message Descriptor 2: 0x%llx\n", entry3);
+
+	printk("Free descriptor response destination : 0x%llx  \n",
+	       xtract_bits(entry1, 48, 16));
+	printk("Use designer freeback : 0x%llx  \n",
+	       xtract_bits(entry1, 45, 1));
+	printk("cipher key length (in dwords) : 0x%llx  \n",
+	       xtract_bits(entry1, 40, 5));
+	printf("Control desc cacheline addr : 0x%llx  \n",
+	       xtract_bits(entry1, 0, 34));
+	if (xtract_bits(entry1, 45, 1)) {
+		printf("Designer freeback length (actual len - 1): 0x%llx  \n",
+		       xtract_bits(entry1, 46, 2));
+	}
 
-        printf("Arc4 load state : 0x%llx  \n", xtract_bits(entry2, 63, 1));
-        printf("Hash key length (in dwords) : 0x%llx  \n", xtract_bits(entry2, 56, 5));
-        printf("Pkt desc length (in multiple of 16 bytes - 1): 0x%llx  \n", xtract_bits(entry2, 43, 12));
-        printf("Pkt desc cacheline addr : 0x%llx  \n", xtract_bits(entry2, 0, 34));
+	printf("Arc4 load state : 0x%llx  \n", xtract_bits(entry2, 63, 1));
+	printf("Hash key length (in dwords) : 0x%llx  \n",
+	       xtract_bits(entry2, 56, 5));
+	printf("Pkt desc length (in multiple of 16 bytes - 1): 0x%llx  \n",
+	       xtract_bits(entry2, 43, 12));
+	printf("Pkt desc cacheline addr : 0x%llx  \n",
+	       xtract_bits(entry2, 0, 34));
 
-        printf("Software Scratch Pad : 0x%llx  \n", xtract_bits(entry3, 0, 34));
+	printf("Software Scratch Pad : 0x%llx  \n", xtract_bits(entry3, 0, 34));
 }
+
 void print_cntl_instr(uint64_t cntl_desc)
 {
 	unsigned int tmp;
@@ -254,9 +249,10 @@ void print_cntl_instr(uint64_t cntl_desc)
 	char s[NLM_CRYPTO_MAX_STR_LEN];
 	cntl_desc = ccpu_to_be64(cntl_desc);
 
-	printf("control description: 0x%016llx\n", (unsigned long long)cntl_desc);
+	printf("control description: 0x%016llx\n",
+	       (unsigned long long)cntl_desc);
 	printf("HMac = 0x%llx  \n", xtract_bits(cntl_desc, 61, 1));
-//	printk("Pad Hash = 0x%llx  \n", xtract_bits(cntl_desc, 62, 1));
+//      printk("Pad Hash = 0x%llx  \n", xtract_bits(cntl_desc, 62, 1));
 	/* Check cipher, hash type and mode b4 printing */
 	tmp = xtract_bits(cntl_desc, 52, 8);
 	x = nlm_crypto_auth_alg_get_name(tmp);
@@ -269,120 +265,153 @@ void print_cntl_instr(uint64_t cntl_desc)
 	tmp = xtract_bits(cntl_desc, 34, 8);
 	x = nlm_crypto_cipher_alg_get_name(tmp);
 	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Cipher Type = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 34, 8), s);
+	printf("Cipher Type = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 34, 8),
+	       s);
 	tmp = xtract_bits(cntl_desc, 25, 8);
 	x = nlm_crypto_cipher_mode_get_name(tmp);
 	strncpy(s, x, NLM_CRYPTO_MAX_STR_LEN);
-	printf("Cipher Mode = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 25, 8), s);
-
+	printf("Cipher Mode = 0x%llx(%s)  \n", xtract_bits(cntl_desc, 25, 8),
+	       s);
 
 	if (xtract_bits(cntl_desc, 34, 8) == NLM_CIPHER_ARC4) {
-		printf("Arc4 cipher key byte count= 0x%llx  \n", xtract_bits(cntl_desc, 18, 5));
-		printf("Arc4 key init = 0x%llx  \n", xtract_bits(cntl_desc, 17, 1));
+		printf("Arc4 cipher key byte count= 0x%llx  \n",
+		       xtract_bits(cntl_desc, 18, 5));
+		printf("Arc4 key init = 0x%llx  \n",
+		       xtract_bits(cntl_desc, 17, 1));
 	}
 
 }
+
 struct pkt_desc_src_dst {
 	uint64_t pkt_desc4;
 	uint64_t pkt_desc5;
 };
 
-struct designer_desc{
+struct designer_desc {
 	uint64_t desc0;
 	uint64_t desc1;
 	uint64_t desc2;
 	uint64_t desc3;
 };
 
-
-void print_pkt_desc(struct nlm_crypto_pkt_param  *pkt_desc1, int index)
+void print_pkt_desc(struct nlm_crypto_pkt_param *pkt_desc1, int index)
 {
 	int i;
-	unsigned long  phys;
-	void * virt;
-	
-	struct nlm_crypto_pkt_param * pkt_desc = kmalloc(sizeof(struct nlm_crypto_pkt_param) + 256 ,GFP_KERNEL);;
-	pkt_desc->desc0 = ccpu_to_be64(pkt_desc1->desc0); 
-	pkt_desc->desc1 = ccpu_to_be64(pkt_desc1->desc1); 
-	pkt_desc->desc2 = ccpu_to_be64(pkt_desc1->desc2); 
-	pkt_desc->desc3 = ccpu_to_be64(pkt_desc1->desc3); 
-	
-
-	printf("Packet desc address = %p\n",pkt_desc);
-	printf("Packet Descriptor 0: 0x%016llx\n", (unsigned long long)pkt_desc->desc0);
-	printf("Packet Descriptor 1: 0x%016llx\n", (unsigned long long)pkt_desc->desc1);
-	printf("Packet Descriptor 2: 0x%016llx\n", (unsigned long long)pkt_desc->desc2);
-	printf("Packet Descriptor 3: 0x%016llx\n", (unsigned long long)pkt_desc->desc3);
+	unsigned long phys;
+	void *virt;
+
+	struct nlm_crypto_pkt_param *pkt_desc =
+	    kmalloc(sizeof(struct nlm_crypto_pkt_param) + 256, GFP_KERNEL);;
+	pkt_desc->desc0 = ccpu_to_be64(pkt_desc1->desc0);
+	pkt_desc->desc1 = ccpu_to_be64(pkt_desc1->desc1);
+	pkt_desc->desc2 = ccpu_to_be64(pkt_desc1->desc2);
+	pkt_desc->desc3 = ccpu_to_be64(pkt_desc1->desc3);
+
+	printf("Packet desc address = %p\n", pkt_desc);
+	printf("Packet Descriptor 0: 0x%016llx\n",
+	       (unsigned long long)pkt_desc->desc0);
+	printf("Packet Descriptor 1: 0x%016llx\n",
+	       (unsigned long long)pkt_desc->desc1);
+	printf("Packet Descriptor 2: 0x%016llx\n",
+	       (unsigned long long)pkt_desc->desc2);
+	printf("Packet Descriptor 3: 0x%016llx\n",
+	       (unsigned long long)pkt_desc->desc3);
 
 	printf("\nPacket Descriptor 0\n");
-	printf("TLS protocol = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 63, 1));
-	printf("Hash source(0-plain, 1-encrypted text) = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 62, 1));
-	printf("Hash output l3 alloc = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 60, 1));
-	printf("Encrypt(1)/Decrypt(0)= 0x%llx  \n", xtract_bits(pkt_desc->desc0, 59, 1));
+	printf("TLS protocol = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc0, 63, 1));
+	printf("Hash source(0-plain, 1-encrypted text) = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc0, 62, 1));
+	printf("Hash output l3 alloc = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc0, 60, 1));
+	printf("Encrypt(1)/Decrypt(0)= 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc0, 59, 1));
 	printf("IV length = 0x%llx  \n", xtract_bits(pkt_desc->desc0, 41, 16));
-	printf("Hash Dest addr = 0x%llx \n", xtract_bits(pkt_desc->desc0, 0, 39));
+	printf("Hash Dest addr = 0x%llx \n",
+	       xtract_bits(pkt_desc->desc0, 0, 39));
 
 	printf("\nPacket Descriptor 1\n");
-	printf("Cipher length = 0x%llx \n", xtract_bits(pkt_desc->desc1, 32, 32));
+	printf("Cipher length = 0x%llx \n",
+	       xtract_bits(pkt_desc->desc1, 32, 32));
 	printf("Hash length = 0x%llx  \n", xtract_bits(pkt_desc->desc1, 0, 32));
 	printf("IV Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 45, 17));
 
 	printf("\nPacket Descriptor 2\n");
-	printf("Cipher bit count = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 42, 3));
-	printf("Cipher Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 22, 16));
-	printf("Hash bit count = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 19, 3));
-	printf("Hash clobber = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 18, 1));
+	printf("Cipher bit count = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc2, 42, 3));
+	printf("Cipher Offset = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc2, 22, 16));
+	printf("Hash bit count = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc2, 19, 3));
+	printf("Hash clobber = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc2, 18, 1));
 	printf("Hash Offset = 0x%llx  \n", xtract_bits(pkt_desc->desc2, 0, 16));
 
-
 	printf("\nPacket Descriptor 3\n");
-	printf("designer fb dest id = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 48, 16));
+	printf("designer fb dest id = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc3, 48, 16));
 	printf("tag length = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 11, 16));
 
-	printf("arc4 sbox l3 alloc = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 8, 1));
-	printf("arc4 save box = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 6, 1));
-	printf("hmac ext pad key = 0x%llx  \n", xtract_bits(pkt_desc->desc3, 5, 1));
+	printf("arc4 sbox l3 alloc = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc3, 8, 1));
+	printf("arc4 save box = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc3, 6, 1));
+	printf("hmac ext pad key = 0x%llx  \n",
+	       xtract_bits(pkt_desc->desc3, 5, 1));
 	int len;
 
-        for (i=0; i < index; i++) {
-		pkt_desc->segment[i][0] = ccpu_to_be64(pkt_desc1->segment[i][0]); 
-		pkt_desc->segment[i][1] = ccpu_to_be64(pkt_desc1->segment[i][1]);
-		printf("Packet Descriptor frag src %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][0]);
-		printf("Packet Descriptor frag dst %d: 0x%016llx\n", i, (unsigned long long)pkt_desc->segment[i][1]);
-
-		phys = xtract_bits(pkt_desc->segment[i][0], 0,40);
+	for (i = 0; i < index; i++) {
+		pkt_desc->segment[i][0] =
+		    ccpu_to_be64(pkt_desc1->segment[i][0]);
+		pkt_desc->segment[i][1] =
+		    ccpu_to_be64(pkt_desc1->segment[i][1]);
+		printf("Packet Descriptor frag src %d: 0x%016llx\n", i,
+		       (unsigned long long)pkt_desc->segment[i][0]);
+		printf("Packet Descriptor frag dst %d: 0x%016llx\n", i,
+		       (unsigned long long)pkt_desc->segment[i][1]);
+
+		phys = xtract_bits(pkt_desc->segment[i][0], 0, 40);
 		virt = phys_to_virt(phys);
-		len = xtract_bits(pkt_desc->segment[i][0], 48, 16); 
-		len = (len > 64 ) ? 64 : len;
-		hex_dump("src",virt,len);
-
-
-                printf("frag src length = 0x%llx  \n", xtract_bits(pkt_desc->segment[i][0], 48, 16));
-                printf("frag src = 0x%llx \n", xtract_bits(pkt_desc->segment[i][0], 0, 40));
-
-                printf("frag dest length = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 48, 16));
-                printf("cipher output l3 alloc = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 46, 1));
-                printf("cipher output write clobber = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 41, 1));
-                printf("frag dest = 0x%llx \n", xtract_bits(pkt_desc->segment[i][1], 0, 40));
-        }
+		len = xtract_bits(pkt_desc->segment[i][0], 48, 16);
+		len = (len > 64) ? 64 : len;
+		hex_dump("src", virt, len);
+
+		printf("frag src length = 0x%llx  \n",
+		       xtract_bits(pkt_desc->segment[i][0], 48, 16));
+		printf("frag src = 0x%llx \n",
+		       xtract_bits(pkt_desc->segment[i][0], 0, 40));
+
+		printf("frag dest length = 0x%llx \n",
+		       xtract_bits(pkt_desc->segment[i][1], 48, 16));
+		printf("cipher output l3 alloc = 0x%llx \n",
+		       xtract_bits(pkt_desc->segment[i][1], 46, 1));
+		printf("cipher output write clobber = 0x%llx \n",
+		       xtract_bits(pkt_desc->segment[i][1], 41, 1));
+		printf("frag dest = 0x%llx \n",
+		       xtract_bits(pkt_desc->segment[i][1], 0, 40));
+	}
 }
 #endif
 
-int alloc_pkt_param( struct nlm_async_crypto * async,struct nlm_crypto_pkt_param ** pkt_param , int max_frags)
+int
+alloc_pkt_param(struct nlm_async_crypto *async,
+		struct nlm_crypto_pkt_param **pkt_param, int max_frags)
 {
-	uint8_t * new_pkt_param = NULL;
-	async->pkt_param = kmalloc((sizeof (struct nlm_crypto_pkt_param) +( max_frags * 2 * 8 )+ 64),GFP_KERNEL);
+	uint8_t *new_pkt_param = NULL;
+	async->pkt_param =
+	    kmalloc((sizeof(struct nlm_crypto_pkt_param) + (max_frags * 2 * 8) +
+		     64), GFP_KERNEL);
 
-	if ( !async->pkt_param) {
+	if (!async->pkt_param) {
 		return -1;
 	}
 
-	new_pkt_param = (uint8_t * )(((unsigned long)async->pkt_param + 64) & ~0x3fUL);
+	new_pkt_param =
+	    (uint8_t *) (((unsigned long)async->pkt_param + 64) & ~0x3fUL);
 
-	memcpy(new_pkt_param,*pkt_param,sizeof(struct nlm_crypto_pkt_param));
+	memcpy(new_pkt_param, *pkt_param, sizeof(struct nlm_crypto_pkt_param));
 	*pkt_param = (struct nlm_crypto_pkt_param *)new_pkt_param;
 
-	
 	return 1;
 }
 
@@ -393,17 +422,18 @@ int nlm_crypto_sae_num_seg_reqd(void *data, unsigned int buflen)
 
 int nlm_crypto_calc_rem_len(struct scatterlist *sg, unsigned int cipher_len)
 {
-	int len,seg = 0;
-	for (;cipher_len > 0;sg = scatterwalk_sg_next(sg)){
+	int len, seg = 0;
+	for (; cipher_len > 0; sg = scatterwalk_sg_next(sg)) {
 		len = min(cipher_len, sg->length);
-		seg += nlm_crypto_sae_num_seg_reqd(NULL,len);
+		seg += nlm_crypto_sae_num_seg_reqd(NULL, len);
 		cipher_len -= len;
 	}
 	return seg;
 }
 
-int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsigned int cipher_len, 
-		struct nlm_crypto_pkt_param *param, 
+int
+fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg,
+		unsigned int cipher_len, struct nlm_crypto_pkt_param *param,
 		int seg, unsigned int max_frags, int op)
 {
 	struct scatterlist *sg;
@@ -413,48 +443,64 @@ int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsi
 	int rv = 0;
 	int i;
 
-	if (src_sg == dst_sg ) {
-		for( sg = src_sg; sg != NULL ; sg = scatterwalk_sg_next(sg)) {
+	if (src_sg == dst_sg) {
+		for (sg = src_sg; sg != NULL; sg = scatterwalk_sg_next(sg)) {
 			len = min(cipher_len, sg->length);
 			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-			if ( cipher_len > 0 ) {
-				rv = nlm_crypto_fill_src_dst_seg(param, seg, max_frags, virt, len);
-				if ( rv < seg ) {
-					return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags; 
-				}
-				else
+			virt =
+			    page_address(scatterwalk_page(&walk)) +
+			    offset_in_page(walk.offset);
+			if (cipher_len > 0) {
+				rv = nlm_crypto_fill_src_dst_seg(param, seg,
+								 max_frags,
+								 virt, len);
+				if (rv < seg) {
+					return nlm_crypto_calc_rem_len(sg,
+								       cipher_len)
+					    + max_frags;
+				} else
 					seg = rv;
 			}
 			cipher_len -= len;
 		}
 		return seg;
-	}
-	else {
+	} else {
 		int nr_src_frags = 0;
 		int nr_dst_frags = 0;
 		int index = seg;
 		int nbytes = cipher_len;
-		for (sg = src_sg,seg;cipher_len > 0; sg = scatterwalk_sg_next(sg)) {
+		for (sg = src_sg, seg; cipher_len > 0;
+		     sg = scatterwalk_sg_next(sg)) {
 			len = min(cipher_len, sg->length);
 			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-			rv = nlm_crypto_fill_src_seg(param,seg,max_frags,virt,len);
-			if ( rv <= seg )
-				return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags;
+			virt =
+			    page_address(scatterwalk_page(&walk)) +
+			    offset_in_page(walk.offset);
+			rv = nlm_crypto_fill_src_seg(param, seg, max_frags,
+						     virt, len);
+			if (rv <= seg)
+				return nlm_crypto_calc_rem_len(sg,
+							       cipher_len) +
+				    max_frags;
 			else
 				seg = rv;
 			cipher_len -= len;
 		}
 		nr_src_frags = seg;
 		cipher_len = nbytes;
-		for (sg = dst_sg,seg = index ;cipher_len > 0; sg = scatterwalk_sg_next(sg)) {
+		for (sg = dst_sg, seg = index; cipher_len > 0;
+		     sg = scatterwalk_sg_next(sg)) {
 			len = min(cipher_len, sg->length);
 			scatterwalk_start(&walk, sg);
-			virt = page_address(scatterwalk_page(&walk)) + offset_in_page(walk.offset);
-			rv = nlm_crypto_fill_dst_seg(param,seg,max_frags,virt,len);
-			if ( rv <= seg )
-				return nlm_crypto_calc_rem_len(sg,cipher_len) + max_frags;
+			virt =
+			    page_address(scatterwalk_page(&walk)) +
+			    offset_in_page(walk.offset);
+			rv = nlm_crypto_fill_dst_seg(param, seg, max_frags,
+						     virt, len);
+			if (rv <= seg)
+				return nlm_crypto_calc_rem_len(sg,
+							       cipher_len) +
+				    max_frags;
 			else
 				seg = rv;
 			cipher_len -= len;
@@ -464,13 +510,16 @@ int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsi
 
 		if ((nr_src_frags > nr_dst_frags) && (nr_src_frags < max_frags)) {
 			for (i = 0; i < nr_src_frags - nr_dst_frags; i++)
-				param->segment[index + nr_dst_frags + i][1] = 0ULL;
+				param->segment[index + nr_dst_frags + i][1] =
+				    0ULL;
 			seg = nr_src_frags;
-		}
-		else  { 
-			if ((nr_src_frags < nr_dst_frags) && (nr_dst_frags < max_frags )){
-				for (i = 0; i < nr_dst_frags - nr_src_frags; i++)
-					param->segment[index + nr_src_frags + i][0] = 0ULL;
+		} else {
+			if ((nr_src_frags < nr_dst_frags)
+			    && (nr_dst_frags < max_frags)) {
+				for (i = 0; i < nr_dst_frags - nr_src_frags;
+				     i++)
+					param->segment[index + nr_src_frags +
+						       i][0] = 0ULL;
 			}
 			seg = nr_dst_frags;
 		}
@@ -479,265 +528,251 @@ int fill_src_dst_sg(struct scatterlist *src_sg, struct scatterlist *dst_sg, unsi
 
 }
 
-    static void
-reset_crypto_stats(void)
+static void reset_crypto_stats(void)
 {
-    int i, j;
-    for (i = 0; i < MAX_CPU; i++) {
-	for (j = 0; j < ENC_MAX_STAT; j++) {
-		crypto_stat[i].enc[j] = 0;
-		crypto_stat[i].enc_tbytes[j] = 0;
-	}
-	for (j = 0; j < AUTH_MAX_STAT; j++) {
-		crypto_stat[i].auth[j] = 0;
-		crypto_stat[i].auth_tbytes[j] = 0;
+	int i, j;
+	for (i = 0; i < MAX_CPU; i++) {
+		for (j = 0; j < ENC_MAX_STAT; j++) {
+			crypto_stat[i].enc[j] = 0;
+			crypto_stat[i].enc_tbytes[j] = 0;
+		}
+		for (j = 0; j < AUTH_MAX_STAT; j++) {
+			crypto_stat[i].auth[j] = 0;
+			crypto_stat[i].auth_tbytes[j] = 0;
+		}
+
 	}
-		
-    }
 
 }
 
-int
-crypto_get_fb_vc(int * node)
+int crypto_get_fb_vc(int *node)
 {
-    int cpu;
-    int node_id = 0;
-    extern int ipsec_async_vc;
-
-
-    cpu = hard_smp_processor_id();	//processor_id();
-    node_id = (cpu >> NODE_ID_SHIFT_BIT);
-    cpu = (node_id << NODE_BASE_SHIFT_BIT) | (((cpu & 0x1f) * 4) + ipsec_async_vc);
-    *node = node_id;
-
-    return cpu;
+	int cpu;
+	int node_id = 0;
+	extern int ipsec_async_vc;
+
+	cpu = hard_smp_processor_id();	//processor_id();
+	node_id = (cpu >> NODE_ID_SHIFT_BIT);
+	cpu =
+	    (node_id << NODE_BASE_SHIFT_BIT) | (((cpu & 0x1f) * 4) +
+						ipsec_async_vc);
+	*node = node_id;
+
+	return cpu;
 }
 
 static const struct file_operations xlp_sae_fops = {
-    .owner = THIS_MODULE,
-    .open = xlp_sae_open,
-    .release = xlp_sae_release,
+	.owner = THIS_MODULE,
+	.open = xlp_sae_open,
+	.release = xlp_sae_release,
 };
 
 /* Note that nobody ever sets xlp_sae_busy... */
-    static int
-xlp_sae_open(struct inode *inode, struct file *file)
+static int xlp_sae_open(struct inode *inode, struct file *file)
 {
-    TRACE_TEXT("(xlp_sae_open");
-    return 0;
+	TRACE_TEXT("(xlp_sae_open");
+	return 0;
 }
 
-    static int
-xlp_sae_release(struct inode *inode, struct file *file)
+static int xlp_sae_release(struct inode *inode, struct file *file)
 {
-    TRACE_TEXT("(xlp_sae_release");
+	TRACE_TEXT("(xlp_sae_release");
 
-    return 0;
+	return 0;
 }
 
-    static void
+static void
 nlm_xlp_sae_msgring_handler(uint32_t vc, uint32_t src_id,
-	uint32_t size, uint32_t code,
-	uint64_t msg0, uint64_t msg1,
-	uint64_t msg2, uint64_t msg3, void *data)
+			    uint32_t size, uint32_t code,
+			    uint64_t msg0, uint64_t msg1,
+			    uint64_t msg2, uint64_t msg3, void *data)
 {
-	struct nlm_async_crypto *async = (struct nlm_async_crypto *)(unsigned long )msg0;
-	if(async)	
+	struct nlm_async_crypto *async =
+	    (struct nlm_async_crypto *)(unsigned long)msg0;
+	if (async)
 		async->callback(async, msg1);
 }
 
-static int
-nlm_crypto_read_stats_proc(char *page, char **start, off_t off, int count,
-                       int *eof, void *data)
+static ssize_t nlm_crypto_clear_stat_proc(struct file *file,
+					  const char __user * buffer,
+					  size_t count, loff_t * data)
 {
-        int len = 0;
-	int i,j;
-	off_t begin = 0;
+	char buf[16];
+	unsigned long val;
+
+	copy_from_user(buf, buffer, count);
+	val = simple_strtol(buf, NULL, 0);
+
+	if (val == 1)
+		reset_crypto_stats();
+
+	return 1;
+
+}
+
+static int nlm_crypto_proc_show(struct seq_file *m, void *v)
+{
+	int i, j;
 	uint64_t enc_tp[ENC_MAX_STAT];
 	uint64_t auth_tp[AUTH_MAX_STAT];
 	uint64_t enc_tb[ENC_MAX_STAT];
 	uint64_t auth_tb[AUTH_MAX_STAT];
 
-	len += sprintf(page + len, "\t\tPkt\t\tTotal Bytes\n");
+	seq_printf(m, "\t\tPkt\t\tTotal Bytes\n");
 
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
 	for (j = 0; j < ENC_MAX_STAT; j++) {
-		enc_tp[j] = 0;	
+		enc_tp[j] = 0;
 		enc_tb[j] = 0;
-		for(i = 0; i < MAX_CPU; i++)  {
+		for (i = 0; i < MAX_CPU; i++) {
 			enc_tp[j] = enc_tp[j] + crypto_stat[i].enc[j];
 			enc_tb[j] = enc_tb[j] + crypto_stat[i].enc_tbytes[j];
 		}
-			
+
 	}
 
-	len += sprintf(page + len,"DES-CBC\t\t%lld\t\t%lld\nTDES-CBC\t%lld\t\t%lld\nAES128-CBC\t%lld\t\t%lld\n",
-			enc_tp[DES_CBC_STAT],enc_tb[DES_CBC_STAT],enc_tp[TDES_CBC_STAT],enc_tb[TDES_CBC_STAT],
-			enc_tp[AES128_CBC_STAT],enc_tb[AES128_CBC_STAT]);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
+	seq_printf(m,
+		   "DES-CBC\t\t%lld\t\t%lld\nTDES-CBC\t%lld\t\t%lld\nAES128-CBC\t%lld\t\t%lld\n",
+		   enc_tp[DES_CBC_STAT], enc_tb[DES_CBC_STAT],
+		   enc_tp[TDES_CBC_STAT], enc_tb[TDES_CBC_STAT],
+		   enc_tp[AES128_CBC_STAT], enc_tb[AES128_CBC_STAT]);
 
-	len += sprintf(page + len,"AES192-CBC\t%lld\t\t%lld\nAES256-CBC\t%lld\t\t%lld\nAES128-CTR\t%lld\t\t%lld\n",
-		enc_tp[AES192_CBC_STAT],enc_tb[AES192_CBC_STAT],enc_tp[AES256_CBC_STAT],enc_tb[AES256_CBC_STAT],
-		enc_tp[AES128_CTR_STAT],enc_tb[AES128_CTR_STAT]);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
+	seq_printf(m,
+		   "AES192-CBC\t%lld\t\t%lld\nAES256-CBC\t%lld\t\t%lld\nAES128-CTR\t%lld\t\t%lld\n",
+		   enc_tp[AES192_CBC_STAT], enc_tb[AES192_CBC_STAT],
+		   enc_tp[AES256_CBC_STAT], enc_tb[AES256_CBC_STAT],
+		   enc_tp[AES128_CTR_STAT], enc_tb[AES128_CTR_STAT]);
 
-	len += sprintf(page + len,"AES192-CTR\t%lld\t\t%lld\nAES256-CTR\t%lld\t\t%lld\n",
-		enc_tp[AES192_CTR_STAT],enc_tb[AES192_CTR_STAT],enc_tp[AES256_CTR_STAT],enc_tb[AES256_CTR_STAT]);
-	if (!proc_pos_check(&begin, &len, off, count))
-		goto out;
+	seq_printf(m, "AES192-CTR\t%lld\t\t%lld\nAES256-CTR\t%lld\t\t%lld\n",
+		   enc_tp[AES192_CTR_STAT], enc_tb[AES192_CTR_STAT],
+		   enc_tp[AES256_CTR_STAT], enc_tb[AES256_CTR_STAT]);
 
-	for(j =0 ;j < AUTH_MAX_STAT; j++) {
+	for (j = 0; j < AUTH_MAX_STAT; j++) {
 		auth_tp[j] = 0;
 		auth_tb[j] = 0;
-		for(i = 0; i < MAX_CPU; i++) { 
-			auth_tp[j] +=  crypto_stat[i].auth[j];
+		for (i = 0; i < MAX_CPU; i++) {
+			auth_tp[j] += crypto_stat[i].auth[j];
 			auth_tb[j] += crypto_stat[i].auth_tbytes[j];
 		}
 	}
 
-	len  += sprintf(page + len,"MD5\t\t%lld\t\t%lld\nH-SHA1\t\t%lld\t\t%lld\nH-SHA256\t%lld\t\t%lld\n",
-				    auth_tp[MD5_STAT],auth_tb[MD5_STAT],auth_tp[H_SHA1_STAT],auth_tb[H_SHA1_STAT],auth_tp[H_SHA256_STAT],auth_tb[H_SHA256_STAT]);
-	if (!proc_pos_check(&begin, &len, off, count))
-		 goto out;
-
-	len  += sprintf(page + len,"AES128-XCBC\t%lld\t\t%lld\nAES198-XCBC\t%lld\t\t%lld\nAES256-XCBC\t%lld\t\t%lld\n",
-		auth_tp[AES128_XCBC_STAT],auth_tb[AES128_XCBC_STAT],auth_tp[AES192_XCBC_STAT],auth_tb[AES192_XCBC_STAT],auth_tp[AES256_XCBC_STAT],auth_tb[AES256_XCBC_STAT]);
-
-	if (!proc_pos_check(&begin, &len, off, count))
-		 goto out;
-
-	len  += sprintf(page + len,"GCM\t\t%lld\t\t%lld\nCCM\t\t%lld\t\t%lld\n",auth_tp[GCM_STAT],auth_tb[GCM_STAT],auth_tp[CCM_STAT],auth_tb[CCM_STAT]);
-
-	if (!proc_pos_check(&begin, &len, off, count))
-		 goto out;
-
-        *eof = 1;
-
-      out:
-        *start = page + (off - begin);
-        len -= (off - begin);
-        if (len > count)
-                len = count;
-        if (len < 0)
-                len = 0;
-
-        return len;
-
-}
-int nlm_crypto_clear_stat_proc(struct file *file, const char __user *buffer, 
-		unsigned long count, void *data)
-{
-	char buf[16];
-	unsigned long val;
-
-	copy_from_user(buf, buffer, count);
-	val =  simple_strtol(buf, NULL, 0);	
-
-	if ( val  == 1)
-    		reset_crypto_stats();
-
-	return 1;
-
+	seq_printf(m,
+		   "MD5\t\t%lld\t\t%lld\nH-SHA1\t\t%lld\t\t%lld\nH-SHA256\t%lld\t\t%lld\n",
+		   auth_tp[MD5_STAT], auth_tb[MD5_STAT], auth_tp[H_SHA1_STAT],
+		   auth_tb[H_SHA1_STAT], auth_tp[H_SHA256_STAT],
+		   auth_tb[H_SHA256_STAT]);
+
+	seq_printf(m,
+		   "AES128-XCBC\t%lld\t\t%lld\nAES198-XCBC\t%lld\t\t%lld\nAES256-XCBC\t%lld\t\t%lld\n",
+		   auth_tp[AES128_XCBC_STAT], auth_tb[AES128_XCBC_STAT],
+		   auth_tp[AES192_XCBC_STAT], auth_tb[AES192_XCBC_STAT],
+		   auth_tp[AES256_XCBC_STAT], auth_tb[AES256_XCBC_STAT]);
+
+	seq_printf(m, "GCM\t\t%lld\t\t%lld\nCCM\t\t%lld\t\t%lld\n",
+		   auth_tp[GCM_STAT], auth_tb[GCM_STAT], auth_tp[CCM_STAT],
+		   auth_tb[CCM_STAT]);
+	return 0;
 }
 
-int
-nlm_crypto_init(void)
+static int nlm_crypto_proc_open(struct inode *inode, struct file *file)
 {
-    int ret = 0;
-    struct proc_dir_entry *entry = NULL;
-    struct proc_dir_entry *clear_entry  = NULL;
-
-    entry = create_proc_read_entry("crypto_stats", 0, nlm_root_proc,
-		    nlm_crypto_read_stats_proc,
-		    0);
-
-    if(entry == NULL) {
-	    printk("%s:%d failed creating proc stats entry.\n",
-			    __FUNCTION__, __LINE__);
-	    ret = -EINVAL;
-    }
-
-    clear_entry = create_proc_entry("clear_crypto_stats", S_IFREG|S_IRUGO|S_IWUSR,nlm_root_proc);
-
-    if ( clear_entry != NULL ) {
-	   clear_entry->write_proc = nlm_crypto_clear_stat_proc;
-    }
-
-   nlm_hal_get_crypto_vc_nums(&crypto_vc_base, &crypto_vc_limit); 
+	return single_open(file, nlm_crypto_proc_show, NULL);
+}
 
-    if (register_xlp_msgring_handler
-		    (XLP_MSG_HANDLE_CRYPTO, nlm_xlp_sae_msgring_handler, NULL)) {
-	    panic("can't register msgring handler for TX_STN_GMAC0");
-    }
-    reset_crypto_stats();
+static const struct file_operations nlm_crypto_proc_fops = {
+	.open = nlm_crypto_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = nlm_crypto_clear_stat_proc,
+};
 
+int nlm_crypto_init(void)
+{
+	int ret = 0;
+	struct proc_dir_entry *entry = NULL;
+	struct proc_dir_entry *clear_entry = NULL;
+
+	entry = proc_create_data("crypto_stats", 0 /* def mode */ ,
+				 nlm_root_proc /* parent */ ,
+				 &nlm_crypto_proc_fops, 0	/* no client data */
+	    );
+	if (entry == NULL) {
+		printk("%s:%d failed creating proc stats entry.\n",
+		       __FUNCTION__, __LINE__);
+		ret = -EINVAL;
+	}
 
+	clear_entry = proc_create_data("clear_crypto_stats",
+				       S_IFREG | S_IRUGO | S_IWUSR,
+				       nlm_root_proc /* parent */ ,
+				       &nlm_crypto_proc_fops, 0	/* no client data */
+	    );
 
-    return ret;
+	nlm_hal_get_crypto_vc_nums(&crypto_vc_base, &crypto_vc_limit);
+	if (register_xlp_msgring_handler
+	    (XLP_MSG_HANDLE_CRYPTO, nlm_xlp_sae_msgring_handler, NULL)) {
+		panic("can't register msgring handler for TX_STN_GMAC0");
+	}
+	reset_crypto_stats();
+	return ret;
 }
 
-static void  init_sae(void)
+static void init_sae(void)
 {
 	extern void *fdt;
 	int freq;
 	int node;
-
 	freq = nlm_hal_get_fdt_freq(fdt, NLM_SAE);
-
 	for_each_node(node) {
-
 		nlm_hal_set_sae_freq(node, freq);
 		nlm_hal_set_sae_engine_sel(node);
 	}
 
 }
 
-    static int __init
-xlp_sae_init(void)
+static int __init xlp_sae_init(void)
 {
-    extern int ipsec_sync_vc;
-    extern int ipsec_async_vc;
-    printk(KERN_ERR ",\n XLP SAE/Crypto Initialization \n");
-
-    xlp_sae_major = register_chrdev(0, "NLM_XLP_SAE", &xlp_sae_fops);
-    if (xlp_sae_major < 0) {
-	printk(KERN_ERR "XLP_SAE - cannot register device\n");
-	return xlp_sae_major;
-    }
-    //  printk (KERN_ERR ",XLP SAE MAJOR %d\n", xlp_sae_major);
-    if ( (ipsec_async_vc == -1) && (ipsec_sync_vc == -1) )  {
-	printk(KERN_ERR "XLP_SAE - cannot be loaeded,Please set ipsec-async-vc and ipsec-sync-vc in the dts file\n");
-    	return -1;
-    }
-    nlm_crypto_init();
-    init_sae();
-    nlm_crypto_chip_features = nlm_hal_get_sae_chip_feature();
-    if(ipsec_async_vc != -1){
-    	xlp_crypt_alg_init();
-    	xlp_aead_alg_init();
-    }else{
-	printk(KERN_ERR "Cannot perform aead/enc operation, Please set ipsec-async-vc in the dts file\n");
-    }
-    if(ipsec_sync_vc != -1){
-    	xlp_auth_alg_init();
-    }else{
-	printk(KERN_ERR "Cannot perform auth operation, Please exclude ipsec_sync_vc from the node-vc-mask in dts\n");	
-	return 0;
-    }
+	extern int ipsec_sync_vc;
+	extern int ipsec_async_vc;
+	printk(KERN_ERR ",\n XLP SAE/Crypto Initialization \n");
+	xlp_sae_major = register_chrdev(0, "NLM_XLP_SAE", &xlp_sae_fops);
+	if (xlp_sae_major < 0) {
+		printk(KERN_ERR "XLP_SAE - cannot register device\n");
+		return xlp_sae_major;
+	}
+	if ((ipsec_async_vc == -1)
+	    && (ipsec_sync_vc == -1)) {
+		printk(KERN_ERR
+		       "XLP_SAE - cannot be loaeded,Please set ipsec-async-vc and ipsec-sync-vc in the dts file\n");
+		return -1;
+	}
+	nlm_crypto_init();
+	init_sae();
+	nlm_crypto_chip_features = nlm_hal_get_sae_chip_feature();
+	if (ipsec_async_vc != -1) {
+		xlp_crypt_alg_init();
+		xlp_aead_alg_init();
+	} else {
+		printk(KERN_ERR
+		       "Cannot perform aead/enc operation, Please set ipsec-async-vc in the dts file\n");
+	}
+	if (ipsec_sync_vc != -1) {
+		xlp_auth_alg_init();
+	} else {
+		printk(KERN_ERR
+		       "Cannot perform auth operation, Please exclude ipsec_sync_vc from the node-vc-mask in dts\n");
+		return 0;
+	}
 
-    return 0;
+	return 0;
 }
 
-    static void __exit
-xlp_sae_cleanup(void)
+static void __exit xlp_sae_cleanup(void)
 {
-    xlp_crypt_alg_fini();
-    xlp_auth_alg_fini();
-    xlp_aead_alg_fini();
-    unregister_chrdev(xlp_sae_major, "NLM_XLP_SAE");
+	xlp_crypt_alg_fini();
+	xlp_auth_alg_fini();
+	xlp_aead_alg_fini();
+	unregister_chrdev(xlp_sae_major, "NLM_XLP_SAE");
 }
 
 module_init(xlp_sae_init);
diff --git a/drivers/dma/nlm_adma.c b/drivers/dma/nlm_adma.c
index 174b2b7..42f0157 100644
--- a/drivers/dma/nlm_adma.c
+++ b/drivers/dma/nlm_adma.c
@@ -1439,7 +1439,7 @@ static int alloc_initial_tx_desc_pool (struct nlm_adma_chan *nlm_chan, int count
 
 }
 
-static int __devinit nlm_adma_probe(struct platform_device *pdev)
+static int nlm_adma_probe(struct platform_device *pdev)
 {
 	struct nlm_adma_device *adev;
 	struct dma_device *dma_dev;
@@ -1557,7 +1557,7 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 }
 
 
-static int __devexit nlm_adma_remove(struct platform_device *dev)
+static int nlm_adma_remove(struct platform_device *dev)
 {
 	return 0;
 }
diff --git a/drivers/i2c/busses/i2c-xlp.c b/drivers/i2c/busses/i2c-xlp.c
index abceaf4..4ab9eb7 100644
--- a/drivers/i2c/busses/i2c-xlp.c
+++ b/drivers/i2c/busses/i2c-xlp.c
@@ -433,7 +433,7 @@ static void i2c_xlp_disable(struct i2c_xlp_data *priv)
 	i2c_reg_write(priv->node, priv->func, XLP_I2C_CONTROL, val);	
 }
 
-static int __devinit
+static int
 i2c_xlp_probe(struct platform_device *pdev)
 {
 	struct i2c_xlp_data *priv;
@@ -493,7 +493,7 @@ out:
 	return ret;
 }
 
-static int __devexit
+static int
 i2c_xlp_remove(struct platform_device *pdev)
 {
 	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
@@ -538,7 +538,7 @@ static struct platform_driver xlp_smbus_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= i2c_xlp_probe,
-	.remove		= __devexit_p(i2c_xlp_remove),
+	.remove		= i2c_xlp_remove,
 	.suspend	= i2c_xlp_suspend,
 	.resume		= i2c_xlp_resume,
 };
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
index 130f801..86350b1 100644
--- a/drivers/mmc/host/sdhci-xlp.c
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -116,14 +116,6 @@ static int sdhci_pltfm_slot_probe(struct platform_device *pdev,
 	else
 		sd_host->ops = &sdhci_pltfm_ops;
 
-#if 0
-	if (pdata && pdata->init) {
-		ret = pdata->init(sd_host, pdata);
-		if (ret)
-			goto err_plat_init;
-	}
-#endif
-
 	if (!request_mem_region(pdev->resource[slotno].start, 
                 (pdev->resource[slotno].end - (pdev->resource[slotno].start)),
 		mmc_hostname(sd_host->mmc))) {
@@ -147,11 +139,6 @@ static int sdhci_pltfm_slot_probe(struct platform_device *pdev,
 	return 0;
 
 err_add_host:
-#if 0
-	if (pdata && pdata->exit)
-		pdata->exit(sd_host);
-#endif
-err_plat_init:
 	iounmap(sd_host->ioaddr);
 err_remap:
 	release_mem_region(pdev->resource[slotno].start, 
@@ -161,7 +148,7 @@ err_request:
         return ret;
 }
 
-static int __devinit sdhci_pltfm_probe(struct platform_device *pdev)
+static int sdhci_pltfm_probe(struct platform_device *pdev)
 {
         struct sdhci_xlp_node *node;
 	struct sdhci_host *host;
@@ -236,9 +223,8 @@ err:
 	return ret;
 }
 
-static int __devexit sdhci_pltfm_remove(struct platform_device *pdev)
+static int sdhci_pltfm_remove(struct platform_device *pdev)
 {
-	struct sdhci_pltfm_data *pdata = pdev->dev.platform_data;
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	int dead;
@@ -250,10 +236,6 @@ static int __devexit sdhci_pltfm_remove(struct platform_device *pdev)
 		dead = 1;
 
 	sdhci_remove_host(host, dead);
-#if 0
-	if (pdata && pdata->exit)
-		pdata->exit(host);
-#endif
 	iounmap(host->ioaddr);
 	release_mem_region(iomem->start, resource_size(iomem));
 	sdhci_free_host(host);
@@ -305,7 +287,7 @@ static struct platform_driver sdhci_pltfm_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= sdhci_pltfm_probe,
-	.remove		= __devexit_p(sdhci_pltfm_remove),
+	.remove		= sdhci_pltfm_remove,
 	.id_table	= sdhci_pltfm_ids,
 	.suspend	= sdhci_pltfm_suspend,
 	.resume		= sdhci_pltfm_resume,
diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
index a28b989..a09c08e 100644
--- a/drivers/spi/spi_xlp.c
+++ b/drivers/spi/spi_xlp.c
@@ -359,7 +359,7 @@ static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
         return ret;
 }
 
-static int __devinit spi_xlp_probe(struct platform_device *dev)
+static int spi_xlp_probe(struct platform_device *dev)
 {
 	int ret = 0;
 	struct spi_master *master;
@@ -419,7 +419,7 @@ put_master:
 	return ret;
 }
 
-static int __devexit spi_xlp_remove(struct platform_device *dev)
+static int spi_xlp_remove(struct platform_device *dev)
 {
 	struct spi_xlp *pspi;
 	struct spi_master *master;
@@ -437,7 +437,7 @@ static int __devexit spi_xlp_remove(struct platform_device *dev)
 
 static struct platform_driver spi_xlp_driver = {
 	.probe	= spi_xlp_probe,
-	.remove	= __devexit_p(spi_xlp_remove),
+	.remove	= spi_xlp_remove,
 	.driver = {
 		.name = "spi-xlp",
 		.owner = THIS_MODULE,
-- 
1.8.4.93.g57e4c17

