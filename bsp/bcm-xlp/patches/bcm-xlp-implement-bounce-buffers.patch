From 48afbf6c915ea08dc0df79fc45b2741a7c9347f3 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Thu, 15 Sep 2011 10:11:34 -0700
Subject: [PATCH 256/565] bcm-xlp: implement bounce buffers

Implement bounce buffers so that DMA access above 4GB ram can succeed.
Required for MMC.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/card/queue.c   | 4 ++++
 drivers/mmc/core/bus.c     | 4 ++++
 drivers/mmc/core/mmc_ops.c | 4 ++++
 drivers/mmc/core/sd.c      | 8 ++++++++
 drivers/mmc/host/xlpmmc.c  | 7 +++++++
 5 files changed, 27 insertions(+)

diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 9447a0e..413183d 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -226,7 +226,11 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 			bouncesz = host->max_blk_count * 512;
 
 		if (bouncesz > 512) {
+#ifdef CONFIG_MMC_XLP
+			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL|GFP_DMA);
+#else
 			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+#endif
 			if (!mqrq_cur->bounce_buf) {
 				pr_warning("%s: unable to "
 					"allocate bounce cur buffer\n",
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index e219c97..6a9eda2 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -237,7 +237,11 @@ struct mmc_card *mmc_alloc_card(struct mmc_host *host, struct device_type *type)
 {
 	struct mmc_card *card;
 
+#ifdef CONFIG_MMC_XLP
+	card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL|GFP_DMA);
+#else
 	card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);
+#endif
 	if (!card)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 49f04bc..489bab9 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -253,7 +253,11 @@ mmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,
 		 * dma onto stack is unsafe/nonportable, but callers to this
 		 * routine normally provide temporary on-stack buffers ...
 		 */
+#ifdef CONFIG_MMC_XLP
+		data_buf = kmalloc(len, GFP_KERNEL|GFP_DMA);
+#else
 		data_buf = kmalloc(len, GFP_KERNEL);
+#endif
 		if (!data_buf)
 			return -ENOMEM;
 	} else
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 9e645e1..877256f 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -282,7 +282,11 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	err = -EIO;
 
+#ifdef CONFIG_MMC_XLP
+	status = kmalloc(64, GFP_KERNEL|GFP_DMA);
+#else
 	status = kmalloc(64, GFP_KERNEL);
+#endif
 	if (!status) {
 		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n",
@@ -348,7 +352,11 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 
 	err = -EIO;
 
+#ifdef CONFIG_MMC_XLP
+	status = kmalloc(64, GFP_KERNEL|GFP_DMA);
+#else
 	status = kmalloc(64, GFP_KERNEL);
+#endif
 	if (!status) {
 		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
diff --git a/drivers/mmc/host/xlpmmc.c b/drivers/mmc/host/xlpmmc.c
index b0d2254..d6a6774 100644
--- a/drivers/mmc/host/xlpmmc.c
+++ b/drivers/mmc/host/xlpmmc.c
@@ -474,6 +474,13 @@ static int xlpmmc_prepare_data(struct xlpmmc_host *host,
 
 	if(host->flags & HOST_F_DMA){
 		struct scatterlist *sg = &data->sg[0];
+#if 0
+		if(sg_phys(sg) >= (4ULL<<30)){
+			extern void dump_stack(void);
+			printk(">4G ADDR: sg_phys(sg) = %#lx\n",sg_phys(sg));
+			dump_stack();
+		}
+#endif
 		hc_wr32(host->base, HC_SDMA_SA_OR_ARG2_LO, (unsigned long)sg_phys(sg), 0);
 	}else{	
 		host->pio.index = 0;
-- 
1.8.4.93.g57e4c17

