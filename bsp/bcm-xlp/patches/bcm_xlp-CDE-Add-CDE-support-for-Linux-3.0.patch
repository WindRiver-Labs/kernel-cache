From 5783a4f78909a2e3848b831df6c0176905e86b23 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Tue, 7 May 2013 16:21:29 +0800
Subject: [PATCH 538/565] bcm_xlp: CDE: Add CDE support for Linux 3.0

Add CDE support for Linux 3.0

Based on Broadcom SDK 2.3.

Signed-off-by: Alok Agrawat <alok@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h |  108 +++
 drivers/misc/Kconfig                             |   11 +
 drivers/misc/Makefile                            |    1 +
 drivers/misc/nlm_cde/Makefile                    |   12 +
 drivers/misc/nlm_cde/cdetest.c                   |  242 +++++
 drivers/misc/nlm_cde/nlm_cde.c                   | 1019 ++++++++++++++++++++++
 drivers/misc/nlm_cde/nlm_cde.h                   |   91 ++
 drivers/misc/nlm_cde/nlm_cde_api.h               |   62 ++
 8 files changed, 1546 insertions(+)
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
 create mode 100644 drivers/misc/nlm_cde/Makefile
 create mode 100644 drivers/misc/nlm_cde/cdetest.c
 create mode 100644 drivers/misc/nlm_cde/nlm_cde.c
 create mode 100644 drivers/misc/nlm_cde/nlm_cde.h
 create mode 100644 drivers/misc/nlm_cde/nlm_cde_api.h

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
new file mode 100644
index 0000000..de7a569
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
@@ -0,0 +1,108 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLM_HAL_CDE_H_
+#define _NLM_HAL_CDE_H_
+
+#include "nlm_hal.h"
+
+#define nlm_hal_write_cde_reg(reg, val) nlm_hal_write_32bit_reg \
+					(nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg), (val))
+#define nlm_hal_read_cde_reg(reg) nlm_hal_read_32bit_reg( \
+					nlm_hal_get_dev_base \
+					(XLP_CDE_NODE, XLP_CDE_BUS, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
+					 (reg))
+
+static __inline__ int nlm_hal_cde_make_fd_msg(uint64_t *msg0, uint64_t free_addr)
+{
+  int stid = XLP_STNID_CMP;
+
+  *msg0 = ( ((uint64_t)free_addr & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+static __inline__ int nlm_hal_cde_make_cmp_msg(uint64_t *msg0, int readp, int op, int rtn_bkt,
+				   int length, uint64_t src_addr)
+{
+  int stid = XLP_STNID_CMP;
+  
+  *msg0 = ( ((uint64_t) readp <<63) |
+		((uint64_t) op << 62)  | 
+                ((uint64_t) rtn_bkt << 50) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) src_addr & 0xffffffffffULL)
+                );
+  return stid;
+}
+
+
+static __inline__ uint64_t nlm_hal_cde_make_data_desc(int eof, int type, int sod, int sob, int save,
+					 int restore, int eob, int length, uint64_t src_addr)
+{
+  uint64_t src_desc = 0;
+  src_desc = (  ((uint64_t) eof << 63) | 
+                ((uint64_t) type << 61) |
+                ((uint64_t) sod << 60) |
+                ((uint64_t) sob << 59) |
+                ((uint64_t) save << 58) |
+                ((uint64_t) restore << 57) |
+                ((uint64_t) eob << 56) |
+                ((uint64_t) length << 40) |
+                ((uint64_t) src_addr & 0xffffffffffULL)
+                );
+  return src_desc;
+}
+
+/* Return error when parameter are invalid */
+static __inline__ int nlm_hal_cde_send_request(uint32_t dst_vc, uint64_t entry0)
+{
+	return nlm_hal_send_msg1(dst_vc, 0, entry0);
+
+}
+
+static __inline__ void nlm_hal_cde_receive_response(uint32_t rx_vc, uint64_t *entry0, uint64_t *entry1)
+{
+        uint32_t size = 0, code = 0, src = 0;
+/*        uint64_t entry0 = 0, entry1 = 0; */
+
+        nlm_hal_recv_msg2(rx_vc, &src, &size, &code, entry0, entry1);
+}
+#endif				/*#ifndef _NLM_HAL_CDE_H_ */
+
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c002d86..1497b6c 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -527,6 +527,17 @@ config SRAM
 	  the genalloc API. It is supposed to be used for small on-chip SRAM
 	  areas found on many SoCs.
 
+config XLP_CDE
+        tristate "broadcom xlp CDE driver"
+        default m
+        help
+          This driver supports broadcom's compression/decompression Engine.
+          For more information on xlp CDE driver, please visit
+
+          <http://support.broadcom.com>
+
+	  To compile this driver as a module, choose M here.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c235d5b..79ee3a9 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_PCH_PHUB)		+= pch_phub.o
 obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
 obj-y				+= carma/
+obj-$(CONFIG_XLP_CDE)		+= nlm_cde/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
diff --git a/drivers/misc/nlm_cde/Makefile b/drivers/misc/nlm_cde/Makefile
new file mode 100644
index 0000000..0e7793b
--- /dev/null
+++ b/drivers/misc/nlm_cde/Makefile
@@ -0,0 +1,12 @@
+
+################################################################################
+
+#
+# Makefile for xlp_cde driver
+#
+
+#EXTRA_CFLAGS := -Werror
+EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
+EXTRA_CFLAGS += -Iarch/mips/netlogic/boot
+
+obj-$(CONFIG_XLP_CDE) 		+= nlm_cde.o
diff --git a/drivers/misc/nlm_cde/cdetest.c b/drivers/misc/nlm_cde/cdetest.c
new file mode 100644
index 0000000..27e5b9b
--- /dev/null
+++ b/drivers/misc/nlm_cde/cdetest.c
@@ -0,0 +1,242 @@
+/***********************************************************************
+Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+/* Reference application for compression driver
+ * usage: mips64-nlm-linux-gcc  -g cdetest.c -o cdetest
+ *>../cdetest <inputfile>
+ */
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+
+static int sleep_usec = 100;
+static int LEN = 1024 * 16;
+static int dfd;
+struct nlm_cde_op
+{
+        unsigned int compression_type;
+        unsigned int sof;
+        unsigned int eof;
+};
+
+struct nlm_cde_op cde;
+
+void test()
+{
+        int i, ret, cd_fd;
+        unsigned char *buf;
+
+        for(i = 0; i < 10; i++)
+        {
+                ret = ioctl(dfd, i, (unsigned long)buf);
+	   	printf("ioctl %d bytes of data to devicee\n", ret);
+	        ret = read(dfd, buf, 10);
+	   	printf("read %d bytes of data to devicee\n", ret);
+	        ret = write(dfd, buf, 10);
+	   	printf("write %d bytes of data to devicee\n", ret);
+        }
+
+}
+
+static int cde_op(int op, char *buf, int len)
+{
+        int ret;
+       
+        ret = ioctl(dfd, op, (unsigned long)&cde);
+
+	if (ret < 0) {
+		perror("can't ioctl");
+		return -1;
+	}
+
+	ret = write(dfd, buf, len);
+	if (ret < 0) {
+		perror("can't write to device");
+		return -1;
+	}
+	else {
+	   	printf("write %d bytes of data to devicee\n", ret);
+	}
+
+	return ret;
+}
+
+static int cde_result(char *buf, int len)
+{
+	int ret = 0;
+
+        while(ret == 0)
+        {
+                ret = read(dfd, buf, len);
+                if (ret < 0) {
+                        perror("can't read device");
+                        return -1;
+                }
+        }
+	printf("read %d bytes of data from devicee\n", ret);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+        char buf[LEN];
+	char buf1[LEN];
+        char buf2[LEN];
+	unsigned char *cde_mmap_mem = NULL;
+
+	int tfd = open(argv[1], O_RDONLY);
+        int vfd = open("out.txt",O_WRONLY);
+        if (tfd < 0 || vfd < 0) {
+		perror("can't open test file");
+		return -1;
+	}
+
+        int data_len = read(tfd, buf, LEN);
+        if (data_len < 0) {
+		perror("can't read test file");
+		return -1;
+	}
+	else {
+	   	printf("read %d bytes of data from test file\n", data_len);
+	}	
+
+	char *dev_name = "/dev/nlm_cde";
+	dfd = open(dev_name, O_RDWR);
+
+        if (dfd < 0) {
+		perror("can't open device");
+		return -1;
+	}
+//        test();
+  //      return 0;
+#if 1
+       cde_mmap_mem = mmap (0, 2048, PROT_READ | PROT_WRITE, MAP_SHARED, dfd, 0);
+       if(cde_mmap_mem)
+               strcpy(cde_mmap_mem, "HelloWorld\n");
+#endif
+
+        cde.compression_type = 1;
+        cde.sof = 1;
+        cde.eof = 1;
+
+	int ret = 0;
+        /*block_test();*/
+        if(0)
+        {
+        int i, num_blk = 2, data_len_ext, j = 0, def_len = 0;
+        data_len_ext = data_len /num_blk;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(2, &buf[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(2, &buf[j], data_len_ext);//deflate
+	 	ret = cde_result(&buf1[def_len], LEN);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        data_len = def_len;
+        data_len_ext = data_len /num_blk;
+        cde.sof = 1;
+        j = 0;
+        def_len = 0;
+        for(i = 0; i < num_blk; i++)
+        {
+                if (i ==0)
+                        cde.eof = 0;
+                if(i == (num_blk -1))
+                {
+                        cde.eof = 1;
+		        ret = cde_op(1, &buf1[j], (data_len - (data_len_ext * i)));//deflate
+                }
+                else
+		        ret = cde_op(1, &buf1[j], data_len_ext); //inflate
+	        if (ret < 0) break;
+
+	 	ret = cde_result(&buf2[def_len], LEN);
+	        if (ret < 0) break;
+                write(vfd, &buf2[def_len], ret);
+                j += data_len_ext;
+                cde.sof = 0;
+                def_len += ret;
+        }
+        return 0;
+        }
+        
+	do 
+        {
+		ret = cde_op(2, buf, data_len);//deflate
+	        //if (ret < 0) break;
+
+	        usleep(sleep_usec);
+
+	        char buf1[LEN];
+	 	ret = cde_result(buf1, LEN);
+	  //      if (ret < 0) break;
+
+	        usleep(sleep_usec);
+//                printf("read buf = %s ret = %d\n",buf1, ret );
+
+		ret = cde_op(1, buf1, ret); //inflate
+	        if (ret < 0) break;
+	
+	        usleep(sleep_usec);
+
+	 	ret = cde_result(buf2, LEN);
+	        if (ret < 0) break;
+                write(vfd, buf2, ret);
+	} 
+        while (0);
+
+	close(dfd);	
+
+	if (ret <= 0) {
+	         printf("test aborted !\n");
+	         return -1;
+        }
+	
+        if (ret != data_len) {
+	         printf("test failed: size mismatch !\n");
+	         return -1;
+        }
+
+        ret = memcmp(buf, buf2, data_len);
+        if (ret != 0) {
+	         printf("test failed: data mismatch !\n");
+	         return -1;
+        }
+
+	printf("test passed !\n");	       
+        return 0;
+}
+
+
diff --git a/drivers/misc/nlm_cde/nlm_cde.c b/drivers/misc/nlm_cde/nlm_cde.c
new file mode 100644
index 0000000..cdebb27
--- /dev/null
+++ b/drivers/misc/nlm_cde/nlm_cde.c
@@ -0,0 +1,1019 @@
+/*************************************************************************
+  Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NLMOGIC OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************#NLM_2#**********************************/
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for request_region */
+#include <linux/delay.h>	/* for loops_per_jiffy */
+#include <linux/sched.h>
+#include <linux/ioctl.h>	
+#include <asm/io.h>		/* for inb_p, outb_p, inb, outb, etc. */
+#include <asm/uaccess.h>	/* for get_user, etc. */
+#include <linux/init.h>		/* for __init, module_{init,exit} */
+#include <linux/poll.h>		/* for POLLIN, etc. */
+#include <asm/netlogic/msgring.h>
+#include <asm/mutex.h>
+
+#include <asm/netlogic/hal/nlm_hal_fmn.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_cde.h>
+#include "nlm_cde.h"
+#include "nlm_cde_api.h"
+
+#define printf(a, b...) printk(KERN_ERR a, ##b)
+#define malloc(a) kmalloc(a, GFP_ATOMIC)
+#define free kfree
+
+#define L3_CACHELINE_SIZE 64
+#define L3_CACHELINE_MASK 0x3fULL
+#define VC_MODE_ROUND_ROBIN 1
+
+struct msgrng_msg {
+  __u64 msg0;
+  __u64 msg1;
+  __u64 msg2;
+  __u64 msg3;
+};
+
+static int xlp_cde_major;
+int xlp_cde_open(struct inode *, struct file *);
+int xlp_cde_release(struct inode *, struct file *);
+int xlp_cde_ioctl(struct file *fptr, unsigned int type, unsigned long val);
+ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma);
+static unsigned char* cde_mem_start = NULL, *cde_mem_start_1, *cde_mem_start_2, *cde_mem_start_3, *cde_mem_start_4, *cde_mem_start_5, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
+static unsigned int cde_mem_size, cde_mem_size_1, cde_mem_size_2, cde_mem_size_3, cde_mem_size_4, cde_mem_size_5;
+//static void test(void);
+
+int num_cde_engine;
+
+struct nlm_cde_op
+{
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+};
+typedef struct free_page_structure {
+	  char *data_array;
+} fr_page;
+
+volatile msg cmp_msg[MAX_NUM_MESSAGES]    __attribute__((aligned(32)));
+volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
+volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
+
+//#define CDE_DEBUG 1
+#ifdef CDE_DEBUG
+static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    printk("\n %s", msg);
+    for(k = 0; k < len; k++)
+    {
+	printk(" %.2x",buf[k]);
+	if((k+1) % 16 == 0)
+	    printk("\n");
+    }
+    printk("\n");
+}
+#endif
+
+static void *
+get_cache_aligned_mem(size_t size)
+{
+    void *addr, **tmp;
+    uint64_t loc;
+    addr = malloc(size + L3_CACHELINE_SIZE * 2);
+
+    if (addr == NULL) {
+	printk(KERN_ERR
+		"\n Malloc failed for cache aligned memory allocation");
+	return NULL;    //NLM_ERR_NO_MEM;
+    }
+    loc = (uint64_t) addr;
+    loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
+
+    tmp = (void **) loc;
+
+    *tmp = addr;
+
+    loc += L3_CACHELINE_SIZE;
+
+    addr = (void *) loc;
+
+    return addr;
+}
+
+static void
+free_cache_aligned_mem(void *addr)
+{
+    uint64_t loc;
+
+    loc = (uint64_t) addr;
+
+    loc -= 64;
+
+    addr = (void *) loc;
+
+    addr = (void *) *(uint64_t*) addr;
+
+    free(addr);
+}
+
+static int
+cde_get_fb_vc(void)
+{
+    int vc, cpu;
+
+    vc = RTN_BKT;
+    cpu = hard_smp_processor_id();
+    cpu = cpu * 4 + vc;
+    return cpu;
+}
+
+static const struct file_operations xlp_cde_fops = {
+    .owner = THIS_MODULE,
+    .open = xlp_cde_open,
+    .read = xlp_cde_read,
+    .write = xlp_cde_write,
+    .compat_ioctl = xlp_cde_ioctl,
+    .mmap = xlp_cde_mmap,
+    .release = xlp_cde_release,
+};
+
+
+static int config_cmp(void)
+{
+  int i;
+   
+#ifdef CDE_DEBUG
+	printk("config_cmp \n");
+#endif
+  for(i = 0; i < num_cde_engine; i++)
+  {
+    unsigned int val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
+#ifdef CDE_DEBUG
+	printk("config_cmp i = %d cntrl_reg val = %x\n", i, val);
+#endif
+    val = nlm_hal_read_cde_reg(CMP_REG_SCRATCH_PAGE(i));
+#ifdef CDE_DEBUG
+	printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
+#endif
+    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
+  }
+  return 0;
+}
+
+static int send_message(int stid, struct msgrng_msg *msg)
+{
+  int ret = 0;
+  unsigned long __attribute__ ((unused)) mflags;
+
+#ifdef CDE_DEBUG
+	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
+#endif
+  msgrng_access_enable(mflags);
+  nlm_hal_cde_send_request(stid, msg->msg0);
+  msgrng_access_disable(mflags);
+
+  return ret;
+}
+
+
+static int send_free_desc(void)
+{
+  int i;
+  int status = 0;
+  int stid;
+  struct msgrng_msg fd_msg;
+
+  // send free descriptors to cmp block
+  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+    if (!page_array[i].data_array)	  
+	page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
+    if (!page_array[i].data_array)	{
+	    printk("cacheline_aligned_kmalloc returmed error desc_num = %d\n", i);
+	    return -1;
+    }
+
+    stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (uint64_t)virt_to_phys(page_array[i].data_array));
+#ifdef CDE_DEBUG
+    	printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
+#endif
+
+    if(is_nlm_xlp2xx())
+    	status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+    else
+      	status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+
+    if (status != 0) {
+      printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
+	     __FUNCTION__, __LINE__, i, status);
+      return -1;
+    }
+  }
+
+#ifdef CDE_DEBUG
+    printk("[%s@%d]: Sent %d free desc to comp engine\n",
+	   __FUNCTION__, __LINE__, i);
+#endif
+
+  return 0;
+}
+
+
+int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+  int num_messages, num_desc, num_blk;
+  int i,j,k,stid;
+
+  int rtn_bkt;
+
+  int cur_blk = 0;
+  int cur_desc = 0;
+
+  int eof  = 0;
+  int sod  = 0;
+  int sob  = 0;
+  int eob  = 0;
+  int save = 0;
+  int restore = 0;
+
+  int desc_idx = 0;
+  int length = 0;
+  int start = 0;
+  int div;
+
+ /* Number of block and number of messages are always 1. 
+    User is expected to send one block at a time */
+  num_blk = num_desc = num_messages = 1;
+  div = num_blk * num_desc;
+
+  rtn_bkt = cde_get_fb_vc();
+  type = 1;
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+  {
+	  printk("ERROR:src_size = %d if more than %d. No space to store\n", (int)cmp_data->src_size, (int)MAX_INPUT_BUFFER_SIZE);
+	  return 0;
+  }
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+  for (i = 0; i < num_messages; i++) {
+    //create scratch page descriptor
+    cur_desc = 0;
+    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+    length = SCRATCH_SIZE ;
+    cmp_data->src_desc[desc_idx] =
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch_inf)));
+#ifdef CDE_DEBUG
+      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
+	     cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
+#endif
+    cur_desc++;
+
+    for (j = 0; j < num_blk; j++) {
+      for (k = 0; k < num_desc; k++) {
+	eof = end_of_file;
+
+	sod = 1;//(start == 0);
+	sob = (k == 0);
+	eob = (k == num_desc-1);
+	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
+	restore = 0; //restore only can be 1 on scratch descriptor
+//save = 0;
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+
+	cmp_data->src_desc[cur_desc] =
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+//printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
+
+#ifdef CDE_DEBUG
+	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+	  
+	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+		 __FUNCTION__, __LINE__,
+		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+
+	start = start + length;
+	cur_desc++;
+      }
+
+      cur_blk++;
+    }
+
+    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+      printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
+#endif
+
+    desc_idx = desc_idx + cur_desc;
+  }
+
+  // returns the number of messages created
+  return (num_messages);
+}
+
+int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of_file)
+{
+  int num_messages, num_desc, num_blk;
+  int i,j,k,stid;
+
+  int rtn_bkt;
+
+  int cur_blk = 0;
+  int cur_desc = 0;
+
+  int eof  = 0;
+  int sod  = 0;
+  int sob  = 0;
+  int eob  = 0;
+  int save = 0;
+  int restore = 0;
+
+  int desc_idx = 0;
+  int length = 0;
+  int start = 0;
+  int div;
+
+  num_blk = num_desc = num_messages = 1;
+  div = num_blk * num_desc;
+
+  rtn_bkt = cde_get_fb_vc();
+
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
+  {
+	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
+	  return 0;
+  }
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
+  for (i = 0; i < num_messages; i++) {
+    //create scratch page descriptor
+    cur_desc = 0;
+    restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
+    length = SCRATCH_SIZE ;
+
+    cmp_data->src_desc[desc_idx] =
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch)));
+
+#ifdef CDE_DEBUG
+      printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
+	     cmp_data->scratch, virt_to_phys(cmp_data->scratch), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
+#endif
+
+    cur_desc++;
+
+    for (j = 0; j < num_blk/num_messages; j++) {
+      for (k = 0; k < num_desc; k++) {
+	eof = end_of_file;
+
+	sod = 1;//(start == 0);
+	sob = (k == 0);
+	eob = (k == num_desc-1);
+	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
+	restore = 0; //restore only can be 1 on scratch descriptor
+
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+	cmp_data->src_desc[cur_desc] =
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+
+	if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
+		save = ( (eob == 1) & (eof == 0)) ;
+		cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
+#ifdef CDE_DEBUG
+	  printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n", 
+		cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
+#endif
+	}
+
+#ifdef CDE_DEBUG
+	  printk("[%s@%d]: eof=%d, sod=%d, sob=%d, eob=%d, save=%d, restore=0, length=%d\n",
+		 __FUNCTION__, __LINE__, eof, sod, sob, eob, save, length);
+	  
+	  printk("[%s@%d]: cur_desc=%d, i=%d, j=%d, k=%d, &(cmp_data->src)=0x%p, src_desc[1]=0x%llx &(src_desc[1])=0x%p\n",
+		 __FUNCTION__, __LINE__,
+		 cur_desc, i, j, k, cmp_data->src, cmp_data->src_desc[cur_desc], &(cmp_data->src_desc[cur_desc]));
+#endif
+	start = start + length;
+	cur_desc++;
+      }
+
+      if (type == CDE_DYNAMIC) {//dynamic has 2x descriptors
+	cur_desc = cur_desc + num_desc;
+      }
+
+      cur_blk++;
+    }
+
+    stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
+			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
+#ifdef CDE_DEBUG
+    printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
+	 __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
+#endif
+
+    desc_idx = desc_idx + cur_desc;
+  }
+
+  // returns the number of messages created
+  return (num_messages);
+}
+
+
+volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
+void return_free_descriptors(msg *msg_list, int msg_index)
+{
+  int i, j, k, status, num_desc;
+  msg return_msg, fd_msg;
+  uint64_t * temp_desc;
+  uint64_t dest_desc;
+  int used_fd_index = 0;
+
+
+  for (i = 0; i < msg_index; i++) {
+
+    memcpy ((void *) &return_msg, (void *)(msg_list+i), sizeof(msg));
+    used_fd[used_fd_index++] = ((uint64_t) return_msg.msg1 & 0xffffffffffUll);
+
+    num_desc = (return_msg.msg1>>40 & 0xffff);
+
+    temp_desc = (uint64_t *) phys_to_virt(return_msg.msg1 & 0xffffffffffUll);
+
+    for (j = 0; j< num_desc; j++) {
+      dest_desc = temp_desc[j];
+      used_fd[used_fd_index++] = ((uint64_t) dest_desc & 0xffffffffffUll);
+    }
+
+
+    if (used_fd_index > FD_BURST_SIZE) {
+      for (k = 0; k < used_fd_index; k++) {
+	fd_msg.msg0 = ((uint64_t) used_fd[k]);
+    	if(is_nlm_xlp2xx())
+    		status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+    	else
+		status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+	if (status != 0)
+	  printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
+	}
+        used_fd_index = 0;
+    }
+  }
+}
+
+static cmp_data_t *cmp_data = 0;
+
+static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
+{
+  uint64_t i,j,num_bytes;
+  int offset = 0;
+  uint64_t *desc, dest_addr;
+  int num_desc = (payload >> 40) & 0x3fff;
+  char * tmp_ptr;
+  for (i = 0; i < num_desc; i++) {
+    desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
+
+    *desc = cpu_to_be64(*desc);
+    num_bytes = (*desc >> 40) & 0xffff;
+    dest_addr = *desc & 0xffffffffffUll;
+    tmp_ptr = (char *) phys_to_virt(dest_addr & 0xffffffffffUll);
+
+    for (j = 0; j < num_bytes; j++) {
+      buffer[offset+j] = tmp_ptr[j];
+    }
+    offset = offset + num_bytes;
+  }
+  return offset;
+}
+
+/* Due compiler warning it is declraed globally */
+struct msgrng_msg msg_list_g[MAX_NUM_MESSAGES]; 
+static void
+nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
+        uint32_t size, uint32_t code,
+        uint64_t msg0, uint64_t msg1,
+        uint64_t msg2, uint64_t msg3, void *data)
+{
+  struct msgrng_msg *msg, temp_msg;
+  int last = 0; 
+  int msg_index = 0; 
+  int offset = cmp_data->target_size;
+
+#ifdef CDE_DEBUG
+  printk("nlm_xlp_cde_msgring_handler = vc = %d, src_id = %d size = %d code = %d msg0 = %llx, msg1 = %llx msg2 = %llx\n", vc, src_id, size, code, msg0, msg1, msg2);
+#endif
+
+  msg = (struct msgrng_msg *)&temp_msg;
+  msg->msg0 = msg0;
+  msg->msg1 = msg1;
+
+  last = ((msg->msg0 >> 63) & 0x1ULL); 
+  
+#ifdef CDE_DEBUG
+  printk("[%s@%d]: last = %d offset = %d target_size = %d\n", __FUNCTION__, __LINE__, last, offset, cmp_data->target_size); 
+#endif
+    
+  offset = cmp_data->target_size; 
+  cmp_data->target_size += nlm_hal_cde_read_cmp_msg((char *) cmp_data->target + offset, msg->msg1);
+
+#ifdef CDE_DEBUG
+  printk("cmp_data->target_size = %d\n",cmp_data->target_size);
+  dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
+#endif
+
+  memcpy((void *)&msg_list_g[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
+
+  return_free_descriptors(msg_list_g, msg_index); 
+#ifdef CDE_DEBUG
+  printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
+#endif
+}
+
+cmp_data_t* nlm_cde_init()
+{
+  cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
+  if (!cmp_data)
+    return NULL;
+  memset(cmp_data, 0, sizeof(cmp_data_t));
+
+  cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
+  if (! cmp_data->src)	{
+	  printk("kmalloc returns Error : cmp_data->src\n");
+	  kfree(cmp_data);
+	  
+	  return NULL;
+  }
+	  
+  cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
+  if (! cmp_data->target)	{
+	  printk("kmalloc returns Error : cmp_data->target\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+  cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
+  if (! cmp_data->src_desc)	{
+	  printk("kmalloc returns Error : cmp_data->src_desc\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data->target);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+  cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+  cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+  if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
+	  printk("kmalloc returns Error : cmp_data->scratch\n");
+	  kfree(cmp_data->src);
+	  kfree(cmp_data->target);
+	  kfree(cmp_data->src_desc);
+	  kfree(cmp_data);
+	  return NULL;
+  }
+
+  cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
+  cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
+  cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
+  cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
+
+  if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
+
+  cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
+  if(cde_mem_start_1 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
+    return NULL;
+  }
+  cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
+  if(cde_mem_start_2 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
+    return NULL;
+  }
+  cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
+  if(cde_mem_start_3 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
+    return NULL;
+  }
+  cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
+  if(cde_mem_start_4 == NULL)
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
+    return NULL;
+  }
+  cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
+  if(cde_mem_start_5 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
+    return NULL;
+  }
+  cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+  
+  memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
+  memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
+
+  memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
+  memset(cmp_data->scratch, 0, SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+
+  if (config_cmp() == -1)
+	return NULL;
+
+  if (send_free_desc() == -1)
+	return NULL;
+
+  return cmp_data;
+}
+
+int xlp_cde_open(struct inode *inode, struct file *filp)
+{
+#ifdef CDE_DEBUG
+	printk("xlp_cde_open \n");
+#endif
+
+  return 0;
+}
+
+
+void nlm_cde_cleanup(cmp_data_t *cmp_data)
+{
+  int i;
+  if (cmp_data->src)  
+	free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
+  if (cmp_data->target)  
+	free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
+  if (cmp_data->src_desc)  
+	  kfree(cmp_data->src_desc);
+  if (cmp_data->scratch)  
+	  kfree(cmp_data->scratch);
+  if (cmp_data->scratch_inf)  
+	  kfree(cmp_data->scratch_inf);
+
+  free_pages((ulong)cde_mem_start_1, get_order(cde_mem_size_1));
+  free_pages((ulong)cde_mem_start_2, get_order(cde_mem_size_2));
+  free_pages((ulong)cde_mem_start_3, get_order(cde_mem_size_3));
+  free_pages((ulong)cde_mem_start_4, get_order(cde_mem_size_4));
+  free_pages((ulong)cde_mem_start_5, get_order(cde_mem_size_5));
+
+  cmp_data->src = NULL;
+  cmp_data->target = NULL;
+  cmp_data->src_desc = NULL; 
+  cmp_data->scratch = NULL;
+  cmp_data->scratch_inf = NULL;
+
+  if (cmp_data)
+    kfree(cmp_data);
+
+  for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
+    if (page_array[i].data_array)	{
+	free_cache_aligned_mem((void*)page_array[i].data_array);
+	page_array[i].data_array = NULL;
+    }	
+  }
+}
+
+
+static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long size = 0;
+	int result = 0, result_t = 0;
+	unsigned long cde_pfn_addr = 0, vm_start = vma->vm_start;
+	if (cde_mem_size <= 0) return -ENXIO;
+
+	if (offset >= cde_mem_size) return -ESPIPE;
+
+	if (vma->vm_flags & VM_LOCKED) return -EPERM;
+
+	size = vma->vm_end - vma->vm_start;
+	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
+	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
+
+	
+	cde_pfn_addr = ((uint64_t)cde_mem_start_1 >> PAGE_SHIFT);
+	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_1, 
+								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_1);
+
+	cde_pfn_addr = ((uint64_t)cde_mem_start_2 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_2, 
+								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_2);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_3 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_3, 
+								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_3);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_4 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_4, 
+								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_4);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_5 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_5, 
+								vma->vm_page_prot);
+	vma->vm_start = vm_start;
+	if (result) return -EAGAIN;
+
+	return 0;
+}
+
+int xlp_cde_release(struct inode *inode, struct file *filp)
+{ 
+  cmp_data->target_size = 0;
+  cmp_data->offset = 0;
+  memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
+  return 0;
+}
+
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf, unsigned int count)
+{
+  int size = 0;
+  if(cmp_data->target_size)
+  {
+	size = (count < cmp_data->target_size) ? count : cmp_data->target_size;
+
+	memcpy(buf, &cmp_data->target[cmp_data->offset], size);
+#ifdef CDE_DEBUG
+	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->Target_size, size);
+	dump_buffer(cmp_data->target, size, "Output:");
+#endif
+	cmp_data->offset += size;
+	cmp_data->target_size = cmp_data->target_size - size;
+	if(cmp_data->target_size == 0)
+		cmp_data->offset = 0;
+
+	return size;
+  }
+  else
+  {
+	cmp_data->offset = 0;
+	return 0;
+  }
+}
+
+ssize_t xlp_cde_read(struct file *filp, char __user *buf,
+		 size_t count, loff_t *f_pos)
+{
+	unsigned char temp_buf[count+1];
+	int size;
+	size = nlm_cde_receive_response(cmp_data, (unsigned char*)temp_buf, count);
+	if(count >= size)
+	{
+		if (copy_to_user(buf, temp_buf, size)) {
+                  printk("copy_to_user failed\n");
+                  size = -EFAULT;
+        	}
+	}
+	return size;
+}
+
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+			unsigned int type, 
+			unsigned int sof, 
+			unsigned int eof, 
+			unsigned char *src_buf, 
+			unsigned int size)
+{
+  int i;
+  int num_messages = 0;
+
+  memcpy(cmp_data->src, src_buf, size);
+  cmp_data->src_size = size;
+
+#ifdef CDE_DEBUG
+	printk("xlp_cde_write count = %d\n", size);
+ 	dump_buffer(cmp_data->src, cmp_data->src_size, "\nInput Buf:");
+	printk("write: cmp_data->compression_type = %d cmp_data->sof = %d, cmp_data->eof = %d\n",cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+#endif
+
+  if(cmp_data->op == 0/*CDE_INFLATE*/)
+    num_messages = create_inf_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+  else
+    num_messages = create_message(cmp_data, cmp_data->compression_type, cmp_data->sof, cmp_data->eof);
+
+  // send message
+  for (i = 0; i < num_messages; i++) {
+
+    int status;
+    if(is_nlm_xlp2xx())
+	status =  send_message(MSGRNG_2XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+    else
+	status =  send_message(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+#ifdef CDE_DEBUG
+    printk("write: status = %x\n", status);
+#endif
+    if (status != 0) {
+	    printk("Cmp Message didnt not reach cmp, status=%0d\n", status);
+    }
+  }
+
+  return size;
+}
+
+ssize_t xlp_cde_write(struct file *filp, const char __user *buf,
+		size_t count, loff_t *f_pos)
+{
+  unsigned char temp_buf[count+1];
+  if (copy_from_user(temp_buf, buf, count)) {
+        printk("copy from user failed \n");
+          return -EFAULT;
+  }
+
+  return nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)temp_buf, count);
+}
+
+
+int xlp_cde_ioctl(struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+{
+  int err = 0, i = 0;
+  struct nlm_cde_op *cde;
+  unsigned int input_size = 0, output_size = 0, size;
+  unsigned char *input_mem, *output_mem, *mem_start;
+
+#ifdef CDE_DEBUG
+  printk("xlp_cde_ioctl: cmd = %d\n", cmd);
+#endif
+  switch(cmd) {
+
+  case CDE_INFLATE:
+    cmp_data->op = 0;
+    input_mem = cde_inf_input_mem;
+    output_mem = cde_inf_output_mem;
+    mem_start = cde_inf_mem_start;
+    break;
+
+  case CDE_DEFLATE:
+    cmp_data->op = 1;
+    input_mem = cde_input_mem;
+    output_mem = cde_output_mem;
+    mem_start = cde_mem_start;
+    break;
+  default:
+	printk("xlp_cde_ioctl: default\n");
+    return -ENOTTY;
+  }
+
+  cde = (struct nlm_cde_op*)mem_start;
+  input_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op));
+  output_size = *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int));
+#ifdef CDE_DEBUG
+  printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof, input_size, output_size);
+#endif
+  cmp_data->compression_type = cde->compression_type;
+  cmp_data->sof = cde->sof;
+  cmp_data->eof = cde->eof;
+  size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
+//printk("#%d written %d byte of data\n", k++, size);
+  size = 0;
+  do{
+    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+    i++;
+  }while(size == 0 && i < 0xffffff); 
+  *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
+//printk("Read %d byte of data\n", size);
+//dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
+  return err;
+}
+
+
+#if 0
+static unsigned strtonum(char c)
+{
+        if(c >= '0' && c <= '9')
+                return (c - '0');
+
+        if(c >= 'A' && c <= 'F')
+                return (c - 'A' + 10);
+
+        if(c >= 'a' && c <= 'f')
+                return (c - 'a' + 10);
+}
+static void test()
+{
+  int i = 0;
+  unsigned int input_size = 0, output_size = 0, size;
+  unsigned char *input_mem, *output_mem, *mem_start;
+  
+  input_mem = cde_inf_input_mem;
+  output_mem = cde_inf_output_mem;
+  mem_start = cde_inf_mem_start;
+  
+  input_size = sizeof(src_gz_data)/2;//200;
+  output_size = MAX_BUFFER_SIZE;
+  for(i = 0; i < (input_size*2); i=i+2)
+  {
+    input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
+  }
+//dump_buffer(input_mem, input_size, "input:");
+  size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
+  printk("written %d byte of data\n", size);
+  size = 0;
+  do{
+    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+    i++;
+  }while(size == 0 && i < 0xffffff); 
+  printk("Read %d byte of data\n", size);
+//dump_buffer(output_mem, size, "output:");
+
+}
+#endif
+
+static int __init xlp_cde_init(void)
+{
+    printk(KERN_ERR ",\n XLP CDE Initialization \n");
+
+    xlp_cde_major = register_chrdev(0, "NLM_XLP_CDE", &xlp_cde_fops);
+    if (xlp_cde_major < 0) {
+	printk(KERN_ERR "XLP_CDE - cannot register device\n");
+	return xlp_cde_major;
+    }
+    printk (KERN_ERR ",XLP CDE MAJOR %d\n", xlp_cde_major);
+
+    if (register_xlp_msgring_handler
+	    (XLP_MSG_HANDLE_CMP, nlm_xlp_cde_msgring_handler, NULL)) {
+	panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
+    }
+    printk("xlp_cde_init done\n\n");
+    if(is_nlm_xlp2xx())
+  	num_cde_engine = NUM_CDE_ENGINE_XLP2XX;
+    else
+  	num_cde_engine = NUM_CDE_ENGINE;
+{
+  int i =0;
+  unsigned int ret;
+  int frequency = 0;
+  int node = 0;
+
+  for(i = 0; i < num_cde_engine; i++)
+  {
+    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+    printk("reset_reg = ret = %x\n", ret);
+#endif
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x8);
+    do {
+    ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
+#ifdef CDE_DEBUG
+    printk("reset_reg = ret = %x\n", ret);
+#endif
+    if (((ret >> 4) & 0x1) == 1)
+      break;
+    } while (1);
+
+    frequency = nlm_hal_get_fdt_freq(fdt, NLM_CDE);
+    nlm_hal_set_cde_freq(node, frequency);
+
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x01);
+    nlm_hal_write_cde_reg(CMP_REG_RESET_REG(i), 0x00);
+  }  
+  /*TEMP*/
+  nlm_cde_init();
+}
+ //test();
+
+    return 0;
+}
+
+static void __exit xlp_cde_cleanup(void)
+{
+  /*TEMP*/
+    nlm_cde_cleanup(cmp_data);
+    unregister_chrdev(xlp_cde_major, "NLM_XLP_CDE");
+}
+
+module_init(xlp_cde_init);
+module_exit(xlp_cde_cleanup);
+MODULE_DESCRIPTION("XLP Hardware CDE Support.");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
+MODULE_AUTHOR("Alok Agrawat");
diff --git a/drivers/misc/nlm_cde/nlm_cde.h b/drivers/misc/nlm_cde/nlm_cde.h
new file mode 100644
index 0000000..f1f7356
--- /dev/null
+++ b/drivers/misc/nlm_cde/nlm_cde.h
@@ -0,0 +1,91 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#ifndef _NLM_CDE_H_
+#define _NLM_CDE_H_
+
+#define NUM_VC 8
+#define NLM_CDE_VC_BASE 297
+#define NUM_CDE_ENGINE 4
+#define NUM_CDE_ENGINE_XLP2XX 	1
+
+#define CDE_INFLATE 			1
+#define CDE_DEFLATE 			2
+
+#define CDE_NON      0
+#define CDE_STATIC   1
+#define CDE_DYNAMIC  2
+#define CDE_DYNAMIC2 3
+
+#define CMP_REG_SCRATCH_PAGE(i)  (0x47 + i * 0x10)
+#define CMP_REG_RESET_REG(i)     (0x4c + i * 0x10)
+#define CMP_REG_CTRL_REG(i)	(0x41 + (i * 0x10))
+
+#define MSGRNG_STNID_CMP0 XLP_STNID_CMP
+#define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
+
+#define MSGRNG_2XX_STNID_CMP0 XLP_2XX_CDE_VC_BASE
+#define MSGRNG_2XX_STNID_CMP1 (XLP_2XX_CDE_VC_BASE + 1)
+
+#define RTN_BKT 1
+#define FD_BURST_SIZE 1
+#define NUM_FREE_DESCRIPTORS 256 //must be less or equal to MAX_NUM_PAGES
+#define MAX_NUM_PAGES 256
+#define MAX_BUFFER_SIZE (1024*2048)
+#define MAX_INPUT_BUFFER_SIZE (1024*64)
+#define CMP_PAGE_SIZE   (2*1024)
+#define FD_CMP_PAGE_SIZE   (32*1024)
+#define SCRATCH_SIZE    (8*1024)
+#define MAX_NUM_MESSAGES 100
+
+extern void *fdt;
+
+unsigned char src_gz_data[] = {"edc13101000000c2a0f54f6d085fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e03"};
+
+typedef struct cmp_data_structure {
+  char *src;    // source data
+  char *target; // inflated or deflated result
+  unsigned long long *src_desc;  // source descriptors
+  unsigned long long *scratch;    // scratch page
+  unsigned long long *scratch_inf;    // scratch page
+  unsigned long long src_size;    //size of source data
+  unsigned long long target_size; // size of result
+  unsigned long long num_desc;    // number of source descriptors including scratch desc
+  short op;                       // to deflate or inflate
+  unsigned int compression_type;
+  unsigned int sof;
+  unsigned int eof;
+  unsigned int offset;
+} cmp_data_t;
+
+typedef enum {
+	CDE_READ_DONE = 0,
+	CDE_WRITE_PENDING,
+	CDE_WRITE_DONE
+} nlm_cde_state;
+
+typedef struct msgrng_msg msg;
+
+#endif
+
diff --git a/drivers/misc/nlm_cde/nlm_cde_api.h b/drivers/misc/nlm_cde/nlm_cde_api.h
new file mode 100644
index 0000000..d865c50
--- /dev/null
+++ b/drivers/misc/nlm_cde/nlm_cde_api.h
@@ -0,0 +1,62 @@
+/***********************************************************************
+  Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+  reserved.
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+ *****************************#NETL_2#********************************/
+#ifndef _NLM_CDE_API_H_
+#define _NLM_CDE_API_H_
+
+/**
+ * @file_name nlm_cde_api.h
+ */
+
+/**
+ * @defgroup cde Compression/Decompression API
+ * @brief Description about the cde apis supported.
+ */
+
+
+#define NLM_ERR_BASE				0xEAE0000
+#define NLM_ERR_CDE_PARAM_NULL 			(NLM_ERR_BASE | 1)
+#define NLM_ERR_INVALID_PARAM 			(NLM_ERR_BASE | 2)
+#define NLM_ERR_NO_MEM 				(NLM_ERR_BASE | 3)
+#define NLM_ERR_UNSPECIFIED 			(NLM_ERR_BASE | 4)
+#define	NLM_ERR_SEND_TIMEOUT 			(NLM_ERR_BASE | 5)
+#define NLM_ERR_IN_PROGRESS 			(NLM_ERR_BASE | 6)
+
+#define NLM_ERR_FREEBACK_NOT_RECEIVED 		(NLM_ERR_BASE | 256)
+
+
+
+cmp_data_t* nlm_cde_init(void);
+unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
+			unsigned int type, 
+			unsigned int sof, 
+			unsigned int eof, 
+			unsigned char *src_buf, 
+			unsigned int size);
+unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, 
+						unsigned char *buf, 
+						unsigned int count);
+void nlm_cde_cleanup(cmp_data_t *cmp_data);
+
+#endif
-- 
1.8.4.93.g57e4c17

