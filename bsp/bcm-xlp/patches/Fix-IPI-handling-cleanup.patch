From a85f943a809e9ba6d3360784fea2b781fac67065 Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Thu, 27 Oct 2011 15:19:08 -0700
Subject: [PATCH 288/565] Fix IPI handling, cleanup.

Fix IPI handling, cleanup.

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c | 241 ++++++++++++++++++++++++++-----------------
 arch/mips/netlogic/xlp/smp.c |  23 +++++
 2 files changed, 168 insertions(+), 96 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index c68c5b2..925a9e4 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -93,7 +93,7 @@ static volatile uint64_t xlp_irq_mask;
 /* spin lock for all interrupt related data structures
  * This variable is used in timer init, so we export it
  */
-spinlock_t xlp_pic_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(xlp_pic_lock);
 EXPORT_SYMBOL(xlp_pic_lock);
 #if defined CONFIG_PCI_MSI
 /*
@@ -503,14 +503,16 @@ static void __nlm_irq_mask(unsigned int irq)
 	return;
 }
 
+#if 0 /* DEPRECATED */
 /*
  * Interface function (unlocked version) to mask an IRQ
  * Calls helper function after input tests and spin_lock holds
  *
  * @irq : IRQ number
  */
-static void nlm_irq_mask(unsigned int irq)
+static void nlm_irq_mask(struct irq_data *d)
 {
+	unsigned int irq = d->irq;
 	//unsigned long flags;
 
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
@@ -525,7 +527,7 @@ static void nlm_irq_mask(unsigned int irq)
 	//spin_unlock_irqrestore(&xlp_pic_lock, flags);	// XXX remove
 	return;
 }
-
+#endif
 
 /*
  * Changes eimr bit value corresponding to IRT
@@ -545,14 +547,16 @@ static void __nlm_irq_unmask(int irq)
 	return;
 }
 
+#if 0 /* DEPRECATED */
 /*
  * Interface function (unlocked version) to mask an IRQ
  * Calls helper function after input tests and spin_lock holds
  *
  * @irq : IRQ number
  */
-static void nlm_irq_unmask(unsigned int irq)
+static void nlm_irq_unmask(struct irq_data *d)
 {
+	unsigned int irq = d->irq;
 	//unsigned long flags;
 
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
@@ -566,27 +570,11 @@ static void nlm_irq_unmask(unsigned int irq)
 	//spin_unlock_irqrestore(&xlp_pic_lock, flags);
 	return;
 }
+#endif
 
-static void nlm_irq_ack(unsigned int irq)
-{
-	unsigned long flags;
-
-	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
-		return;
-	} else if(irq >= XLP_IRQ_MAX) {
-		pr_err("irq = %d. Invalid irq requested\n", irq);
-		return;
-	}
-	/* If edge triggered, ack it ASAP. Handle the interrupt later */
-	if (PIC_IRQ_IS_EDGE_TRIGGERED(xlp_irq_to_irt(irq))) {
-		spin_lock_irqsave(&xlp_pic_lock, flags);
-		nlm_hal_ack_pic(xlp_irq_to_irt(irq));
-		spin_unlock_irqrestore(&xlp_pic_lock, flags);
-	}
-}
-
-static void nlm_irq_end(unsigned int irq)
+static void xlp_pic_unmask(struct irq_data *d)
 {
+	unsigned int irq = d->irq;
 	unsigned long flags;
 
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
@@ -595,13 +583,9 @@ static void nlm_irq_end(unsigned int irq)
 		pr_err("irq = %d. Invalid irq requested\n", irq);
 		return;
 	}
-	/* If level triggered, ack it after the device condition is cleared */
-	if (!PIC_IRQ_IS_EDGE_TRIGGERED(xlp_irq_to_irt(irq))) {
-		spin_lock_irqsave(&xlp_pic_lock, flags);
-		nlm_hal_ack_pic(xlp_irq_to_irt(irq));
-		spin_unlock_irqrestore(&xlp_pic_lock, flags);
-	}
-	return;
+	spin_lock_irqsave(&xlp_pic_lock, flags);
+	nlm_hal_ack_pic(xlp_irq_to_irt(irq));
+	spin_unlock_irqrestore(&xlp_pic_lock, flags);
 }
 
 /*
@@ -613,9 +597,10 @@ static void nlm_irq_end(unsigned int irq)
  * When an interrupt is started, we force it to be enabled only in cpu0, it can
  * be changed later by calling nlm_irq_set_affinity()
  */
-static unsigned int nlm_irq_startup(unsigned int irq)
+static unsigned int nlm_irq_startup(struct irq_data *d)
 {
 	__label__ __failure;
+	unsigned int irq = d->irq;
 	int ret = 0;
 	unsigned long flags;
 	int idx, rvec;
@@ -676,8 +661,9 @@ __failure:
  * chip->shutdown(). In this function, the rvec bit in every EIMR is cleared if
  * usage falls to zero (in case of shared interrupts)
  */
-static void nlm_irq_shutdown(unsigned int irq)
+static void nlm_irq_shutdown(struct irq_data *d)
 {
+	unsigned int irq = d->irq;
 	unsigned long flags;
 	int idx, rvec;
 
@@ -727,8 +713,9 @@ static void nlm_irq_shutdown(unsigned int irq)
  * The actual bitmask can be different from the specified bitmask based
  * on the logic of xlp_closest_match_cpumask()
  */
-static int nlm_irq_set_affinity(unsigned int irq, const struct cpumask *mask)
+static int nlm_irq_set_affinity(struct irq_data *d, const struct cpumask *mask, bool force)
 {
+	unsigned int irq = d->irq;
 	unsigned long flags;
 	const struct cpumask *m;
 	struct cpumask n;
@@ -751,19 +738,29 @@ static int nlm_irq_set_affinity(unsigned int irq, const struct cpumask *mask)
 	return 0;
 }
 
+/* For default handle_level_irq, the flow is as follows:
+	desc->irq_data.chip->irq_mask_ack();
+	handle_irq_event(desc->action);
+	desc->irq_data.chip->irq_unmask();
+*/
+static void xlp_pic_mask_ack(struct irq_data *d)
+{
+	/* Do nothing here. */
+	/* Since rvec is multiplexed, we do not ack eirr here. */
+}
+
 static struct irq_chip nlm_irq_pic = {
 	.name = "XLP-PIC",
-	.mask = nlm_irq_mask,
-	.unmask = nlm_irq_unmask,
-	.startup = nlm_irq_startup,
-	.mask = nlm_irq_shutdown,
-	.ack = nlm_irq_ack,
-	.end = nlm_irq_end,
-	.set_affinity = nlm_irq_set_affinity
+	.irq_mask_ack = xlp_pic_mask_ack,
+	.irq_unmask = xlp_pic_unmask,
+	.irq_enable = nlm_irq_startup,
+	.irq_disable = nlm_irq_shutdown,
+	.irq_set_affinity = nlm_irq_set_affinity
 };
 
-static void rsvd_pic_handler_1_1(unsigned int irq)
+static void rsvd_pic_handler_1(struct irq_data *d)
 {
+	unsigned int irq = d->irq;
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
 		return;
 	} else if(irq >= XLP_IRQ_MAX) {
@@ -774,20 +771,9 @@ static void rsvd_pic_handler_1_1(unsigned int irq)
 	return;
 }
 
-static void rsvd_pic_handler_1(unsigned int irq)
-{
-	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
-		return;
-	} else if(irq >= XLP_IRQ_MAX) {
-		pr_err("irq = %d. Invalid irq requested\n", irq);
-		return;
-	}
-	pr_err("Requesting a reserved irq (%d)??", irq);
-	return;
-}
-
-static int rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
+static int rsvd_pic_handler_2(struct irq_data *d, const struct cpumask *mask, bool force)
 {
+	unsigned int irq = d->irq;
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
 		return 0;
 	} else if(irq >= XLP_IRQ_MAX) {
@@ -800,11 +786,11 @@ static int rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
 
 struct irq_chip nlm_common_rsvd_pic = {
 	.name = "Netlogic-RSVD-PIC",
-	.unmask = rsvd_pic_handler_1_1,
-	.mask = rsvd_pic_handler_1,
-	.ack = rsvd_pic_handler_1,
-	.end = rsvd_pic_handler_1,
-	.set_affinity = rsvd_pic_handler_2
+	.irq_unmask = rsvd_pic_handler_1,
+	.irq_mask = rsvd_pic_handler_1,
+	.irq_ack = rsvd_pic_handler_1,
+	// .end = rsvd_pic_handler_1, /* deprecated */
+	.irq_set_affinity = rsvd_pic_handler_2
 };
 
 static irqreturn_t nlm_common_rsvd_irq_handler(int irq, void *dev_id)
@@ -833,8 +819,7 @@ struct irqaction nlm_common_rsvd_action = {
 void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 {
 	if (irq == XLP_IRQ_IPI_SMP_FUNCTION || irq == XLP_IRQ_IPI_SMP_RESCHEDULE) {
-		nlm_common_ipi_handler(irq, regs);
-		return;
+		/* do nothing */
 	}
 	if (irq == XLP_IRQ_MSGRING) {
 		nlm_xlp_msgring_int_handler(irq, regs);
@@ -990,13 +975,13 @@ static void nlm_msi_unmask(unsigned int msi)
 
 struct irq_chip nlm_msi_pic = {
 	.name = "XLP-PIC-MSI",
-	.startup = nlm_msi_startup,
-	.shutdown = nlm_msi_shutdown,
-	.ack = nlm_msi_ack,
-	.end = nlm_msi_end,
-	.mask = nlm_msi_mask,
-	.unmask = nlm_msi_unmask,
-	.set_affinity = nlm_msi_set_affinity
+	.irq_startup = nlm_msi_startup,
+	.irq_shutdown = nlm_msi_shutdown,
+	.irq_ack = nlm_msi_ack,
+	// .end = nlm_msi_end, /* deprecated */
+	.irq_mask = nlm_msi_mask,
+	.irq_unmask = nlm_msi_unmask,
+	.irq_set_affinity = nlm_msi_set_affinity
 };
 
 /*
@@ -1089,13 +1074,13 @@ static void nlm_msix_shutdown(unsigned int msix)
 
 struct irq_chip nlm_msix_pic = {
 	.name = "XLP-PIC-MSIX",
-	.startup = nlm_msix_startup,
-	.shutdown = nlm_msix_shutdown,
-	.ack = nlm_msix_ack,
-	.end = nlm_msix_end,
-	.mask = nlm_msix_mask,
-	.unmask = nlm_msix_unmask,
-	.set_affinity = nlm_msix_set_affinity
+	.irq_startup = nlm_msix_startup,
+	.irq_shutdown = nlm_msix_shutdown,
+	.irq_ack = nlm_msix_ack,
+	// .end = nlm_msix_end, /* deprecated */
+	.irq_mask = nlm_msix_mask,
+	.irq_unmask = nlm_msix_unmask,
+	.irq_set_affinity = nlm_msix_set_affinity
 };
 
 
@@ -1232,15 +1217,10 @@ asmlinkage void plat_irq_dispatch(void)
 		return;
 	}
 	eirr &= ~(1ULL << rvec);
-	if (rvec != XLP_IRQ_MSGRING) {
-		write_64bit_cp0_eirr(1ULL << rvec);
-	}
+
 	if (rvec < XLP_IRQ_RESERVED_MAX) {
 		irq = rvec;
 		do_nlm_common_IRQ(irq, pt_regs);
-		if (rvec == XLP_IRQ_MSGRING) {
-			write_64bit_cp0_eirr(1ULL << rvec);
-		}
 		return;
 	} else {
 		/* We need to loop through all possible irqs for an rvec */
@@ -1252,9 +1232,8 @@ asmlinkage void plat_irq_dispatch(void)
 		bitmap = rvec_map[rvec].bitmap;
 		spin_unlock_irqrestore(&xlp_pic_lock, flags);
 		switch(base_irq) {
-		/* For INTX, bitmap and base irq already set */
 #if defined CONFIG_PCI_MSI
-		/* These are not MSI vector numbers, but IRT #s */
+		/* These are not MSIs, but IRT #s */
 		case XLP_PCIE_LINK_IRQ(0) ... XLP_PCIE_LINK_IRQ(3):
 			/* Here fn # of controller is easily calculated
 			 * Check the IRT table : 0 -> 78, 1-> 79 ..etc */
@@ -1284,7 +1263,7 @@ asmlinkage void plat_irq_dispatch(void)
 			idx = ffs(bitmap) - 1;	/* man ffs */
 			bitmap &= ~(1 << idx);
 			irq = base_irq + idx;
-			do_nlm_common_IRQ(irq, pt_regs);
+			do_IRQ(irq);
 		}
 		write_64bit_cp0_eirr(1ULL << rvec);
 	}
@@ -1386,7 +1365,7 @@ int xlp_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc, int nvec)
 	if (ret < 0) {
 		return max;
 	}
-	set_irq_msi(base_msi, desc);
+	irq_set_msi_desc(base_msi, desc);
 	ret = xlp_msi_compose_msg(dev, desc, base_msi, &msg);
 	if (ret < 0) {
 		return ret;
@@ -1444,7 +1423,7 @@ int xlp_setup_msix_irq(struct pci_dev *dev, struct msi_desc *desc, int nvec)
 	if (idx == XLP_MSIX_PER_SLOT) {
 		return -ENOSPC;
 	}
-	set_irq_msi(base_msix + idx, desc);
+	irq_set_msi_desc(base_msix + idx, desc);
 	ret = xlp_msi_compose_msg(dev, desc, base_msix + idx, &msg);
 	if (ret < 0) {
 		return ret;
@@ -1487,38 +1466,108 @@ EXPORT_SYMBOL(arch_setup_msi_irqs);
 #endif
 #endif
 
+#define PIC_IRQ_BASE XLP_IRQ_RESERVED_MAX
+
+static void clear_cp0_eimr_bit(unsigned int bit)
+{
+	u64 mask;
+
+	mask = read_64bit_cp0_eimr();
+	mask &= ~(1ULL << bit);
+	write_64bit_cp0_eimr(mask);
+}
+
+static void set_cp0_eimr_bit(unsigned int bit)
+{
+	u64 mask;
+
+	mask = read_64bit_cp0_eimr();
+	mask |= (1ULL << bit);
+	write_64bit_cp0_eimr(mask);
+}
+
+static void xlp_cpu_enable(struct irq_data *d)
+{
+	set_cp0_eimr_bit(d->irq);
+}
+
+static void xlp_cpu_disable(struct irq_data *d)
+{
+	clear_cp0_eimr_bit(d->irq);
+}
+
+static void xlp_cpu_mask(struct irq_data *d)
+{
+	clear_cp0_eimr_bit(d->irq);
+}
+
+static void xlp_cpu_unmask(struct irq_data *d)
+{
+	set_cp0_eimr_bit(d->irq);
+}
+
+static void xlp_cpu_ack(struct irq_data *d)
+{
+	clear_cp0_eimr_bit(d->irq);
+}
+
+static void xlp_cpu_eoi(struct irq_data *d)
+{
+	set_cp0_eimr_bit(d->irq);
+}
+
+/*
+ * Chip definition for CPU originated interrupts(timer, msg) and
+ * IPIs
+ */
+struct irq_chip nlm_cpu_intr = {
+	.name           = "XLP-CPU-INTR",
+	.irq_enable     = xlp_cpu_enable,
+	.irq_disable    = xlp_cpu_disable,
+	.irq_mask	= xlp_cpu_mask,
+	.irq_unmask	= xlp_cpu_unmask,
+	.irq_ack        = xlp_cpu_ack,
+	.irq_eoi	= xlp_cpu_eoi,
+};
+
+static inline void irq_desc_set_chip(struct irq_desc *desc, struct irq_chip *chip)
+{
+	irq_desc_get_irq_data(desc)->chip = chip;
+}
+
 void __init init_nlm_common_irqs(void)
 {
 	int i;
 	u64	mask = 0;
 
 	for (i = 0; i < XLP_IRQ_MAX; i++) {	// IRQ : 0 - 167
-		set_irq_chip(i, &nlm_irq_pic);
+		if (i >= PIC_IRQ_BASE)
+			irq_set_chip_and_handler(i, &nlm_irq_pic,
+						 handle_level_irq);
+		else
+			irq_set_chip_and_handler(i, &nlm_cpu_intr,
+						 handle_percpu_irq);
 	}
 #ifdef CONFIG_PCI_MSI
 	for (i = XLP_MSI_INDEX_START; i <= XLP_MSI_INDEX_END; i++) {
-		set_irq_chip(i, &nlm_msi_pic);
+		irq_set_chip(i, &nlm_msi_pic);
 	}
 	for (i = XLP_MSIX_INDEX_START; i <= XLP_MSIX_INDEX_END; i++) {
-		set_irq_chip(i, &nlm_msix_pic);
+		irq_set_chip(i, &nlm_msix_pic);
 	}
 #endif
 
 #ifdef CONFIG_REMOTE_DEBUG	/* REMOVE on XLP TODO */
+	irq_desc_set_chip(&irq_desc[XLP_IRQ_REMOTE_DEBUG], &nlm_common_rsvd_pic);
 	irq_desc[XLP_IRQ_REMOTE_DEBUG].chip = &nlm_common_rsvd_pic;
 	irq_desc[XLP_IRQ_REMOTE_DEBUG].action = nlm_common_rsvd_action;
 	// xlp_irq_mask |= (1ULL << XLP_IRQ_REMOTE_DEBUG);
 #endif
 #ifdef CONFIG_SMP
-	irq_desc[XLP_IRQ_IPI_SMP_FUNCTION].chip = &nlm_common_rsvd_pic;
-	irq_desc[XLP_IRQ_IPI_SMP_FUNCTION].action = &nlm_common_rsvd_action;
-
-	irq_desc[XLP_IRQ_IPI_SMP_RESCHEDULE].chip = &nlm_common_rsvd_pic;
-	irq_desc[XLP_IRQ_IPI_SMP_RESCHEDULE].action = &nlm_common_rsvd_action;
 
 #ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY	/* REMOVE on XLP TODO */
 	/* PR: New IPI added here for netrx balancing */
-	irq_desc[XLP_IRQ_IPI_NETRX].chip = &nlm_common_rsvd_pic;
+	irq_desc_set_chip(&irq_desc[XLP_IRQ_IPI_NETRX], &nlm_common_rsvd_pic);
 	irq_desc[XLP_IRQ_IPI_NETRX].action = &nlm_common_rsvd_action;
 	//xlp_irq_mask |= (1ULL << XLP_IRQ_IPI_NETRX);
 #endif				/* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
@@ -1526,7 +1575,7 @@ void __init init_nlm_common_irqs(void)
 #endif
 
 	/* msgring interrupt */
-	irq_desc[XLP_IRQ_MSGRING].chip = &nlm_common_rsvd_pic;
+	irq_desc_set_chip(&irq_desc[XLP_IRQ_MSGRING], &nlm_common_rsvd_pic);
 	irq_desc[XLP_IRQ_MSGRING].action = &nlm_common_rsvd_action;
 
 	mask = (
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index eb91625..7cfebfa 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -28,6 +28,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
+#include <linux/interrupt.h>
 
 #include <asm/mipsregs.h>
 #include <asm/mmu_context.h>
@@ -265,8 +266,30 @@ int wakeup_secondary_cpus(void)
 	return 0;
 }
 
+static irqreturn_t smp_resched_ipi_handler(int irq, void *dev_id)
+{
+	write_64bit_cp0_eirr(1ULL << irq);
+	scheduler_ipi();
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t smp_function_ipi_handler(int irq, void *dev_id)
+{
+	write_64bit_cp0_eirr(1ULL << irq);
+	smp_call_function_interrupt();
+	return IRQ_HANDLED;
+}
+
 void nlm_prepare_cpus(unsigned int max_cpus)
 {
+	if (request_irq(XLP_IRQ_IPI_SMP_FUNCTION, smp_function_ipi_handler, 0,
+			"IPI:smp function", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_FUNCTION)\n");
+	}
+	if (request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE, smp_resched_ipi_handler, 0,
+			"IPI:smp reschedule", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE)\n");
+	}
 }
 
 struct plat_smp_ops nlm_smp_ops = {
-- 
1.8.4.93.g57e4c17

