From 948c25ed4096d97cc805e00344a1e51eb967ed13 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 18 May 2011 10:22:25 -0700
Subject: [PATCH 224/565] bcm-xlp: add spansion serial nor falsh driver

Add spansion serial nor falsh driver m25p80.c and its dependent
spi_xlp driver and related files.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/board.c |  12 +--
 drivers/mtd/devices/m25p80.c   |  81 +++++++++----------
 drivers/spi/spi_xlp.c          | 179 ++++++++++++++++-------------------------
 3 files changed, 116 insertions(+), 156 deletions(-)

diff --git a/arch/mips/netlogic/xlp/board.c b/arch/mips/netlogic/xlp/board.c
index 7498075..8fc1610 100644
--- a/arch/mips/netlogic/xlp/board.c
+++ b/arch/mips/netlogic/xlp/board.c
@@ -29,13 +29,9 @@
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
 
-
 static struct i2c_board_info xlp_i2c_device_info[] __initdata = {
         {"ds1374",          0, 0x68, 0, 0, 0},
-        {"max6657",             0, 0x4c, 0, 0, 0},
-       /* {"at24c02",           0, 0x57, 0, 0, 0},
-        {"trx10gdp0310",      0, 0x70, 0, 0, 0},
-	*/
+        {"max6657",         0, 0x4c, 0, 0, 0},
 };
 
 static int __init xlp_i2c_device_init(void)
@@ -52,6 +48,12 @@ static struct spi_board_info spsn_spi_board_info[] __initdata = {
 		.bus_num = 0,
 		.chip_select = 1
 	},
+	{
+		.modalias = "mt29f",
+		.max_speed_hz = 50000000,
+		.bus_num = 0,
+		.chip_select = 2
+	},
 };
 
 static int __init xlp_spi_device_init(void)
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 8cbcf4a..e1f36f4 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -1,11 +1,3 @@
-/***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems Inc. ("Netlogic").
- * This is a derived work from software originally provided by the external
- * entity identified below. The licensing terms and warranties specified in
- * the header of the original work apply to this derived work.
- *
- * *****************************#NETL_1#********************************/
-
 /*
  * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
  *
@@ -102,7 +94,6 @@ static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
 	return container_of(mtd, struct m25p, mtd);
 }
 
-
 /****************************************************************************/
 
 /*
@@ -471,15 +462,9 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 			write_enable(flash);
 
-#ifdef CONFIG_NLM_XLP
-			spi_write(flash->spi, flash->command, CMD_SIZE);
-#endif
 			spi_sync(flash->spi, &m);
 
 			*retlen += m.actual_length - m25p_cmdsz(flash);
-#ifdef CONFIG_NLM_XLP
-			write_disable(flash);
-#endif
 		}
 	}
 
@@ -932,52 +917,64 @@ static struct mtd_partition xlp_spi_parti[] = {
                 .size = MTDPART_SIZ_FULL,
         }
 };
+#ifdef M25P_TEST
 static void m25p_test(struct m25p * flash)
 {
-	int i, xfer_len;
+	int i, j, xfer_len;
 	unsigned char buf[4096];
 	size_t retlen;
 	memset(buf, 0, 4096);
 	retlen 		= 0;
-	xfer_len 	= 2048;
+	xfer_len 	= 370;
 
-	printk("\n######################### erase_sector\n");
-	erase_sector(flash, 0);
+	j = flash->mtd.size / flash->mtd.erasesize;
+        for( i = 0; i < 5; i++)
+        {
 
+		printk("\n######################### erase_sector\n");
+		erase_sector(flash, 0);
+	}
 	printk("\n######################### read\n");
 	printk("\nFlash read back %d\n",xfer_len);
-	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
-	for( i = 0; i < xfer_len; i++)
-        {
-                printk("%02x",buf[i]);
-                if((i % 16) == 0xf)
-                        printk("\n");
-        }
 
-	/* fill buf with number */
-	for(i = 0; i < xfer_len; i++){
-		buf[i] = i % 0x100;
+        for(j = 0; j < 1; j++)
+        {
+		m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+		for( i = 0; i < xfer_len; i++) {
+			printk("%02x",buf[i]);
+			if((i % 16) == 0xf)
+				printk("\n");
+		}
 	}
-	retlen = xfer_len;
 
-	printk("\n######################### write\n");
-	printk("\nFlash write %d test\n",xfer_len);
+	/* fill buf with number */
+        for(j = 0; j < 5; j++)
+        {
+		for(i = 0; i < xfer_len; i++){
+			buf[i] = i % 0x100;
+		}
+		retlen = xfer_len;
 
-	m25p80_write(&flash->mtd, 0, xfer_len, &retlen, buf);
+		printk("\n######################### write\n");
+		printk("\nFlash write %d test\n",xfer_len);
 
+		m25p80_write(&flash->mtd, 0, xfer_len, &retlen, buf);
+	}
 	printk("\n######################### read\n");
 
-	xfer_len +=32;
-
-	printk("\n\nFlash read back %d\n",xfer_len);
-	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
-	for( i = 0; i < xfer_len; i++)
+       for(j = 0; j < 5; j++)
         {
-                printk("%02x",buf[i]);
-               if((i % 16) == 0xf)
-                        printk("\n");
-        }
+		printk("\n\nFlash read back %d\n",xfer_len);
+		m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+		for( i = 0; i < xfer_len; i++) {
+			printk("%02x",buf[i]);
+			if((i % 16) == 0xf)
+			printk("\n");
+		}
+	}
 }
+#endif //#ifdef M25P_TEST
+
 #endif
 
 /*
diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
index 39e80a3..e9db811 100644
--- a/drivers/spi/spi_xlp.c
+++ b/drivers/spi/spi_xlp.c
@@ -39,6 +39,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/xlp.h>
 
 #undef XLP_SPI_DEBUG
+
 #define CONFIG_SPI_REFCLK		133333334
 #define SPI_CHAN_OFFSET			0x10
 #define CMD_RDID			0x9f
@@ -47,8 +48,15 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define CMD_WRDI			0x04
 #define CMD_BE_4K			0x20
 #define CMD_BE_32K			0x52
-#define CMD_CHIP_ERASE		0xc7
-#define CMD_SE			0xd8
+#define CMD_CHIP_ERASE			0xc7
+#define CMD_SE				0xd8
+#define CMD_GET_FEATURE			0x0f
+#define CMD_SET_FEATURE			0x1f
+#define CMD_RESET			0xff
+#define CMD_PR				0x13
+#define CMD_PL				0x02
+#define CMD_PROGEXE			0x10
+
 #define DEFAULT_CS_FDIV			0x10
 #define XLP_SPI_MAX_XFER_SIZE		0x2000
 #define XLP_SPI_FIFO_SIZE		8
@@ -178,7 +186,6 @@ out:
 
 }
 
-
 static void spi_xlp_fill_txfifo(struct spi_xlp *pspi, uint32_t* len, unsigned char** data)
 {
         uint32_t txfifo_cnt;
@@ -222,8 +229,11 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 	if(opcode[0] == CMD_WREN 	||
 	   opcode[0] == CMD_BE_4K	||
 	   opcode[0] == CMD_BE_32K	||
-	   opcode[0] == CMD_CHIP_ERASE||
-	   opcode[0] == CMD_SE	||
+	   opcode[0] == CMD_CHIP_ERASE	||
+	   opcode[0] == CMD_SE		||
+	   opcode[0] == CMD_RESET	||
+	   opcode[0] == CMD_PROGEXE	||
+	   opcode[0] == CMD_SET_FEATURE	||
 	   opcode[0] == CMD_WRDI )
 		return 1;
 	else
@@ -233,39 +243,40 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, uint32_t xfer_len)
 {
 	uint32_t val;
-        uint32_t rx_data, tx_len, rx_len, rxfifo_cnt;
+	uint32_t rx_data, tx_len, rx_len, rxfifo_cnt, sent_bytes;
 	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+	unsigned char* rx_buf = NULL;
+	unsigned char* tx_buf = NULL;
 
-	pspi->tx_buf = (unsigned char*)t->tx_buf;
-	pspi->rx_buf = (unsigned char*)t->rx_buf;
-	pspi->rcounter = xfer_len;
+	tx_buf = (unsigned char*)t->tx_buf;
+	rx_buf = (unsigned char*)t->rx_buf;
 
-        if (xfer_len == 0)
+	if (!tx_buf && !rx_buf)
                 return -1;
 
-        tx_len = (pspi->tx_buf == NULL) ? 0 : xfer_len;
-        rx_len = (pspi->rx_buf == NULL) ? 0 : xfer_len;
+	tx_len = (tx_buf == NULL) ? 0 : xfer_len;
+	rx_len = (rx_buf == NULL) ? 0 : xfer_len;
+	sent_bytes = 0;
 
 	val = XLP_SPI_CMD_IDLE;
-        if (tx_len) {
-                spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
-		t->len = tx_len;
+	if (tx_len) {
+		spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+		sent_bytes = xfer_len - tx_len;
 		if(xfer_len <= NOR_SPI_CMD_SIZE){
 			val |= XLP_SPI_CMD_CONT;
 		}
-
 		if(spi_disable_cont_cmd((unsigned char*)t->tx_buf))
 		{
 			val &= ~XLP_SPI_CMD_CONT;
 		}
         }
 
-	if(pspi->tx_buf != 0)
+	if(t->tx_buf)
 		val |= XLP_SPI_CMD_TX;
-	if(pspi->rx_buf != 0)
+	if(t->rx_buf)
 		val |= XLP_SPI_CMD_RX;
         if(xfer_len)
-		val |= ((xfer_len * 8 -1) << XLP_SPI_XFR_BITCNT_POS);
+		val |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_POS);
 
 	spi_reg_write(0, pspi->cs, XLP_SPI_CMD, val);
 
@@ -282,131 +293,92 @@ static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, ui
 				rxfifo_cnt--;
 
                                 if (rx_len <= 1) {
-                                        pspi->rx_buf[0] = (uint8_t) (rx_data & 0xff);
+                                        rx_buf[0] = (uint8_t) (rx_data & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 2) {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 3) {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else {
-                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
-                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len -= 4;
                                 }
-
-                                pspi->rx_buf += 4;
+                                rx_buf += 4;
                         }
-			t->len = rx_len;
+			sent_bytes = xfer_len - rx_len;
                 }
                 if (tx_len) {
-                        spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
-			t->len = tx_len;
+			spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+			sent_bytes = xfer_len - tx_len;	
                 }
         }
 
 	do {
 		val = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
-        } while( (val & XLP_SPI_XFR_DONE) == 0);
+		if(val & XLP_SPI_TX_OV_TH)
+		{
+			printk("[%s] tx over threshold, stop sendinging\n",__func__);
+		}
+        } while((val & XLP_SPI_XFR_DONE) == 0);
 
-        return 0;
+        return sent_bytes;
 }
 
 static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
         int ret;
-	uint32_t len = t->len;
-        while (len) {
-
-                if (len > XLP_SPI_MAX_XFER_SIZE) {
-                        ret = spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
-
-                        len = len - XLP_SPI_MAX_XFER_SIZE;
-
-                        if (t->tx_buf)
-                                t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
-                        if (t->rx_buf)
-                                t->rx_buf = t->rx_buf  + XLP_SPI_MAX_XFER_SIZE;
-                        if (ret)
-                                return ret;
-
-                } else {
-                        ret = spi_xlp_xfer_block(spi, t, len);
-                        return ret;
-                }
-        }
-        return 0;
-}
-
-static irqreturn_t spi_xlp_irq(int irq, void *dev_id)
-{
-	struct spi_xlp *pspi = dev_id;
-	uint32_t int_stat;
-
-	int_stat = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
-
-	if (int_stat & XLP_SPI_INT_XFR_DONE) {
-		uint32_t sr;
-
-		sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
-		while ((sr & XLP_SPI_INT_RX_THRESH) == 0) {
-			uint32_t data;
-
-			data = spi_reg_read(0, pspi->cs,XLP_SPI_RXDATA_FIFO);
-			if (pspi->rx_buf) {
-				memcpy(pspi->rx_buf, &data, 4);
-			}
-			sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
-		}
-
-		if (pspi->rcounter > 0) {
-			spi_xlp_fill_txfifo(pspi, &pspi->rcounter, &pspi->tx_buf);
-		} else {
-			complete(&pspi->done);
-		}
+	uint32_t len;
+
+	ret = 0;
+	len = t->len;
+	while (len > XLP_SPI_MAX_XFER_SIZE) {
+		ret += spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
+		len = len - XLP_SPI_MAX_XFER_SIZE;
+		if (t->tx_buf)
+			t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+		if (t->rx_buf)
+			t->rx_buf = t->rx_buf + XLP_SPI_MAX_XFER_SIZE;
 	}
+        ret += spi_xlp_xfer_block(spi, t, len);
 
-	return IRQ_HANDLED;
+        return ret;
 }
 
 static int __init spi_xlp_probe(struct platform_device *dev)
 {
-	int ret = 0 , irt;
+	int ret = 0;
 	struct spi_master *master;
 	struct spi_xlp *pspi;
 	struct resource *r;
 
-
 	master = spi_alloc_master(&dev->dev, sizeof(struct spi_xlp));
-	if(!master) {
-		printk("[%s] failed to allocate spi master\n",__func__);
+
+	if (master == NULL) {
 		return -ENOMEM;
 	}
 
 	dev_set_drvdata(&dev->dev, master);
 
 	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (!r) {
+	if (r == NULL) {
 		ret = -ENODEV;
 		goto put_master;
 	}
 
 	pspi = spi_master_get_devdata(master);
-	platform_set_drvdata(dev, pspi);
-
-	/* setup spi bitbang adaptor */
 	pspi->bitbang.master 		= spi_master_get(master);
 	pspi->bitbang.chipselect	= spi_xlp_chipselect;
 	pspi->bitbang.setup_transfer	= spi_xlp_setup_transfer;
 	pspi->bitbang.txrx_bufs		= spi_xlp_txrx_bufs;
 	pspi->bitbang.master->setup	= spi_xlp_setup;
-	pspi->bitbang.master->num_chipselect = XLP_SPI_MAX_CS;
 	init_completion(&pspi->done);
 
 	if (!request_mem_region(r->start,
@@ -420,29 +392,19 @@ static int __init spi_xlp_probe(struct platform_device *dev)
 		ret = -ENOMEM;
 		goto put_master;
 	}
-        irt = spi_reg_read(0, 0, 0x3D) & 0xFFFF;
-        pspi->irq = nlm_hal_irt_to_irq(irt);
-	if (pspi->irq < 0) {
-		ret = -ENXIO;
-		goto unmap_io;
-	}
 
 	master->bus_num = 0;
 	master->num_chipselect = XLP_SPI_MAX_CS;
 
 	xlp_spi_init(pspi);
-	ret = request_irq(pspi->irq, spi_xlp_irq, 0, "spi-xlp", pspi);
-	if (ret != 0)
-		goto unmap_io;
 	ret = spi_bitbang_start(&pspi->bitbang);
 	if (ret != 0) {
-		printk("[%s] spi_bitbang_start FAILED\n", __func__);
-		goto free_irq;
+		dev_err(&dev->dev, "spi_bitbang_start FAILED\n");
+		goto unmap_io;
 	}
+
 	return ret;
 
-free_irq:
-	free_irq(pspi->irq, pspi);
 unmap_io:
 	iounmap(pspi->regs);
 put_master:
@@ -459,7 +421,6 @@ static int __devexit spi_xlp_remove(struct platform_device *dev)
 	pspi = spi_master_get_devdata(master);
 
 	spi_bitbang_stop(&pspi->bitbang);
-	free_irq(pspi->irq, pspi);
 	iounmap(pspi->regs);
 	platform_set_drvdata(dev, 0);
 	spi_master_put(pspi->bitbang.master);
-- 
1.8.4.93.g57e4c17

