From 3b91c20701f6cdf6af29b26021a19f27d9e14ed4 Mon Sep 17 00:00:00 2001
From: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Date: Thu, 23 Jun 2011 19:23:27 +0530
Subject: [PATCH 231/565] bcm-xlp: addressing review comments

Addressing review comments: - use proper conversion for PHYS addr
to VIRT addr - use cacheline_aligned_kzalloc() instead of kzalloc().

Based on Broadcom SDK 2.3.

Signed-off-by: Sreenidhi BR <sreenidhibr@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/dma/nlm_adma.c | 26 +++++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/nlm_adma.c b/drivers/dma/nlm_adma.c
index 51dc836..98d942e 100644
--- a/drivers/dma/nlm_adma.c
+++ b/drivers/dma/nlm_adma.c
@@ -53,6 +53,20 @@ extern void nlm_hal_dtr_init();
 struct nlm_adma_device nlm_adma_raid_device;
 struct page * nlm_dtre_null_page;
 
+#define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+static __inline__ void *cacheline_aligned_kzalloc(int size, int gfp_mask)
+{
+	void *buf = kzalloc(size + SMP_CACHE_BYTES, gfp_mask);
+	if (buf)
+		buf =
+			(void
+			 *)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
+					 SMP_CACHE_BYTES));
+	return buf;
+}
+
+
 static inline int nlm_adma_get_max_xor(void)
 {
 	/*
@@ -429,7 +443,7 @@ static dma_cookie_t nlm_tx_submit (struct dma_async_tx_descriptor *tx)
 	{
 		if ((nlm_tx->len > PAGE_SIZE) || (nlm_tx->memset_val != 0))
 		{
-			memset((phys_to_virt(nlm_tx->hw_desc.dst)), nlm_tx->memset_val, nlm_tx->len);
+			memset(page_address(pfn_to_page((nlm_tx->hw_desc.dst)>>PAGE_SHIFT)), nlm_tx->memset_val, nlm_tx->len);
 			nlm_tx->done_flag = 1;
 			wmb();
 			tasklet_schedule(&chan->irq_tasklet);
@@ -442,7 +456,7 @@ static dma_cookie_t nlm_tx_submit (struct dma_async_tx_descriptor *tx)
 		/* handle in CPU */
 		if (nlm_tx->len >= DTRE_MAX_MEMCPY_DESC_SIZE)
 		{
-			memcpy((phys_to_virt(nlm_tx->hw_desc.dst)), (phys_to_virt(nlm_tx->hw_desc.src)), nlm_tx->len);
+			memcpy(page_address(pfn_to_page((nlm_tx->hw_desc.dst)>>PAGE_SHIFT)), page_address(pfn_to_page((nlm_tx->hw_desc.src)>>PAGE_SHIFT)), nlm_tx->len);
 			nlm_tx->done_flag = 1;
 			wmb();
 			tasklet_schedule(&chan->irq_tasklet);
@@ -455,6 +469,8 @@ static dma_cookie_t nlm_tx_submit (struct dma_async_tx_descriptor *tx)
 				(nlm_tx->len <= DTRE_MAX_MEMCPY_DESC_SIZE))
 		{
 			msg_len = nlm_tx->len;
+
+			/* 8 bytes per entry * 4 entry msg */
 			memset(nlm_tx->list_desc, 0, (8*4*DTRE_MAX_MEMCPY_DESC_LIST));
 
 			/* construct a list of msgtype 0 (msg transfer) */
@@ -609,7 +625,7 @@ static struct nlm_tx_desc *alloc_tx_desc(struct nlm_adma_chan *chan)
 		return ptr;
 	} else {
 		/* dynamic allocation */
-		ptr = kzalloc(sizeof(struct nlm_tx_desc), GFP_KERNEL);
+		ptr = cacheline_aligned_kzalloc(sizeof(struct nlm_tx_desc), GFP_KERNEL);
 		if(!ptr) {
 			spin_unlock_bh(&chan->lock);
 			panic("OUT OF TX descriptors");
@@ -1389,7 +1405,7 @@ static int alloc_initial_tx_desc_pool (struct nlm_adma_chan *nlm_chan, int count
 	head->next = NULL;
 
 	for(i=0; i < count; i++) {
-		ptr = kzalloc(sizeof(struct nlm_tx_desc), GFP_KERNEL);
+		ptr = cacheline_aligned_kzalloc(sizeof(struct nlm_tx_desc), GFP_KERNEL);
 		if(!ptr) {
 			break;
 		}
@@ -1500,7 +1516,7 @@ static int __devinit nlm_adma_probe(struct platform_device *pdev)
 		printk("DTRE error: page allocation failed.\n");
 		return 0;
 	}
-	memset((void *)(phys_to_virt(page_to_phys(nlm_dtre_null_page))), 0, PAGE_SIZE);
+	memset((void *)(page_address(nlm_dtre_null_page)), 0, PAGE_SIZE);
 
 	printk("NLM ASYNC Device Registered\n");
 
-- 
1.8.4.93.g57e4c17

