From d5cdb1f85da0d00b12dae74275c0b6df314d25ec Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Fri, 6 May 2011 11:31:33 -0700
Subject: [PATCH 215/565] LE, PCI mem bar special handling

LE, PCI mem bar special handling for A0, A1 and A2 chip revisions.
This works in tandem with bootloader configuration of PCI mem bar.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/pci/probe.c | 55 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 54 insertions(+), 1 deletion(-)

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ea37072..1d63cb0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -156,6 +156,59 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 	return flags;
 }
 
+#if defined (CONFIG_NLM_XLP) && defined (__LITTLE_ENDIAN)
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+#define XLP_PCI_DEV_BASE 0x1000
+
+static u32 nlm_xlp_membar_fixup(u32 l, struct pci_dev *dev,
+	unsigned int pos, enum pci_bar_type type)
+{
+	unsigned char b;
+	u32 fixup;
+	int rev;
+
+	if (!is_nlm_xlp8xx()) {
+		return l;
+	}
+
+	if (!l)
+		return l;
+	if (pci_calc_resource_flags(l) != IORESOURCE_MEM)
+		return l;
+	rev = read_c0_prid() & 0xff;
+	if (!((rev == XLP_REVISION_A0) || (rev == XLP_REVISION_A1) ||
+			(rev == XLP_REVISION_A2))){
+		return l;
+	}
+	/* If not xlp chip or if the device < 0x1000 skip this device.
+	 * (XLP onchip devices start with device id 0x1000) and this fix
+	 * is applicable only to onchip devices
+	 */
+	if ((dev->vendor != PCI_VENDOR_ID_NETLOGIC) ||
+			(dev->device < XLP_PCI_DEV_BASE)) {
+		return l;
+	}
+	if (type == pci_bar_unknown) {
+		if ((l & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY) {
+			if ((l & ~PCI_BASE_ADDRESS_MEM_MASK) & PCI_BASE_ADDRESS_MEM_TYPE_64)
+				type = pci_bar_mem64;
+			else
+				type = pci_bar_mem32;
+		}
+	}
+	if ((type != pci_bar_mem32) && (type != pci_bar_mem64))
+		return l;
+
+	b = (l >> 24) & 0xff;
+	fixup = ((b << 24) | (b << 16) | (b << 8) | (b));
+	return fixup;
+}
+
+#else /* CONFIG_NLM_XLP */
+#define nlm_xlp_membar_fixup(x, u1, u2, u3)(x)
+#endif /* CONFIG_NLM_XLP */
+
 /**
  * pci_read_base - read a PCI BAR
  * @dev: the PCI device
@@ -187,7 +240,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &l);
 	pci_write_config_dword(dev, pos, l | mask);
 	pci_read_config_dword(dev, pos, &sz);
-	pci_write_config_dword(dev, pos, l);
+	pci_write_config_dword(dev, pos, nlm_xlp_membar_fixup(l, dev, pos, type));
 
 	/*
 	 * All bits set in sz means the device isn't working properly.
-- 
1.8.4.93.g57e4c17

