From 27f55a61bb5b151eaf52e1ec7e1430a09e4f5636 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Sat, 4 Sep 2010 23:50:39 -0700
Subject: [PATCH 128/565] Workaround for simulator's lack

Workaround for simulator's lack of support for cop2 vc_empty_status1

	* Generic cleanup in NAE driver
		- Deleted trailing whitespace
		- Removed unused preprocessor macros
		- Fixes for warnings
		- Unhook nae_remove from pci driver remove

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c |  12 +-
 arch/mips/netlogic/xlp/setup.c   |   6 +-
 drivers/net/xlp_nae/xlp_hw.c     |  36 +++---
 drivers/net/xlp_nae/xlp_nae.c    | 269 +++++++++++++++++++--------------------
 4 files changed, 168 insertions(+), 155 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 30b3390..981db64 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -46,6 +46,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
 
+extern uint32_t xlp_linux_cpu_mask;
+extern int hwemul;
+
 extern void nlm_cpu_stat_update_msgring_int(void);
 extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
 extern void nlm_cpu_stat_update_msgring_pic_int(void);
@@ -205,6 +208,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	for (;;) {
 		/* Read latest VC empty mask */
 		msg_status1 = xlp_read_status1();
+
 		vc_empty_status = (msg_status1 >> 24) & 0xf;
 		if (vc_empty_status == 0xf) break;
 
@@ -216,9 +220,15 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 			if(src_id >= 0 && src_id < MAX_VC)
 			{
 				handler = &msg_handler_map[vc_to_handle_map[src_id]];
-				(handler->action) (vc, src_id, size, code, msg0, msg1, msg2, msg3, handler->dev_id);
+
+				/* Execute device driver fmn handler */
+				(handler->action)(vc, src_id, size, code,
+						  msg0, msg1, msg2, msg3, handler->dev_id);
 			}
 		}
+
+		/* Simulator currently doesn't simulate vc_empty_status1 bits! */
+		if (!hwemul) break;
 	}
 	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
 
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 6fadfa9..a73e224 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -123,12 +123,16 @@ __u8 nlm_common_base_mac_addr[6];
 
 int chip_is_xls = 0;
 int chip_is_xls_b0 = 0;
-int xlp_sgmii_ports = 1;
 
+int xlp_sgmii_ports = 1;
+int hwemul = 0;
 
 EXPORT_SYMBOL(chip_is_xls);
 EXPORT_SYMBOL(chip_is_xls_b0);
 EXPORT_SYMBOL(xlp_sgmii_ports);
+EXPORT_SYMBOL(hwemul);
+
+uint32_t xlp_linux_cpu_mask;
 
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
diff --git a/drivers/net/xlp_nae/xlp_hw.c b/drivers/net/xlp_nae/xlp_hw.c
index b5c4ab7..c5f51fa 100644
--- a/drivers/net/xlp_nae/xlp_hw.c
+++ b/drivers/net/xlp_nae/xlp_hw.c
@@ -73,8 +73,8 @@ static int xlp_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 	}else{
 
-		cmd->supported = SUPPORTED_10baseT_Full | 
-			SUPPORTED_10baseT_Half | 
+		cmd->supported = SUPPORTED_10baseT_Full |
+			SUPPORTED_10baseT_Half |
 			SUPPORTED_100baseT_Full | SUPPORTED_100baseT_Half |
 			SUPPORTED_1000baseT_Full | SUPPORTED_MII |
 			SUPPORTED_Autoneg | SUPPORTED_TP;
@@ -194,14 +194,14 @@ static int xlp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	return ret;
 }
 
-static void xlp_get_drvinfo(struct net_device *dev, 
+static void xlp_get_drvinfo(struct net_device *dev,
 				struct ethtool_drvinfo *info)
 {
 	strcpy(info->driver, DRV_NAME);
 	strcpy(info->version, DRV_VERSION);
 }
 
-static int xlp_get_regs_len(struct net_device *dev) 
+static int xlp_get_regs_len(struct net_device *dev)
 {
 	return NLM_ETHTOOL_REG_LEN;
 }
@@ -243,7 +243,7 @@ static int xlp_nway_reset(struct net_device *dev)
 	mii_status = nlm_xlp_mac_mii_read(priv, priv->phy.addr, MII_BMCR);
 	if(mii_status & BMCR_ANENABLE)
 	{
-		nlm_xlp_mac_mii_write(priv, priv->phy.addr, 
+		nlm_xlp_mac_mii_write(priv, priv->phy.addr,
 				MII_BMCR, BMCR_ANRESTART | mii_status);
 		ret = 0;
 	}
@@ -306,11 +306,11 @@ static void xlp_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
 {
 	switch (stringset) {
 	case ETH_SS_STATS:
-		memcpy(buf, &xlp_ethtool_stats_keys, 
+		memcpy(buf, &xlp_ethtool_stats_keys,
 				sizeof(xlp_ethtool_stats_keys));
 		break;
 	default:
-		printk(KERN_WARNING "%s: Invalid stringset %d\n", 
+		printk(KERN_WARNING "%s: Invalid stringset %d\n",
 				__FUNCTION__, stringset);
 		break;
 	}
@@ -325,7 +325,7 @@ static void xlp_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
 void xlp_get_mac_stats(struct net_device *dev, struct net_device_stats *stats)
 {
 	struct dev_data *priv = netdev_priv(dev);
-	
+
 	stats->tx_errors = nlm_hal_read_mac_reg( priv->block, priv->index, TX_FCS_ERROR_COUNTER);
 	stats->rx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, RX_DROP_PACKET_COUNTER);
 	stats->tx_dropped = nlm_hal_read_mac_reg( priv->block, priv->index, TX_DROP_FRAME_COUNTER);
@@ -356,12 +356,12 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
 	struct dev_data *priv = netdev_priv(dev);
 	unsigned long flags;
 	unsigned long *tmp_stats;
-	
+
 	spin_lock_irqsave(&priv->lock, flags);
-	
+
 	xlp_get_mac_stats(dev, &priv->stats);
-	
-	
+
+
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	tmp_stats = (unsigned long *)&priv->stats;
@@ -374,12 +374,12 @@ static void xlp_get_ethtool_stats (struct net_device *dev,
 
 /**********************************************************************
  *  nlm_xlp_mac_mii_read - Read mac mii phy register
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   priv - priv structure
  *  	   phyaddr - PHY's address
  *  	   regidx = index of register to read
- *  	   
+ *
  *  Return value:
  *  	   value read (16 bits), or 0xffffffff if an error occurred.
  ********************************************************************* */
@@ -412,13 +412,13 @@ static unsigned int nlm_xlp_mac_mii_read(struct dev_data *priv, int phyaddr, int
 
 /**********************************************************************
  *  nlm_xlp_mac_mii_write -Write mac mii PHY register.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   priv - priv structure
  *  	   phyaddr - PHY to use
  *  	   regidx - register within the PHY
  *  	   regval - data to write to register
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
diff --git a/drivers/net/xlp_nae/xlp_nae.c b/drivers/net/xlp_nae/xlp_nae.c
index 4c53ce9..89ad42d 100644
--- a/drivers/net/xlp_nae/xlp_nae.c
+++ b/drivers/net/xlp_nae/xlp_nae.c
@@ -59,26 +59,30 @@
 #include "xlp_nae.h"
 
 #define XLP_SOC_MAC_DRIVER "XLP Mac Driver"
-#define MAX_NUM_MACS 			1
+
+/* On-Chip NAE PCI Header */
 #define PCI_NETL_VENDOR			0xfecc
 #define PCI_DEVID_BASE			0
 #define PCI_DEVID_OFF_NET		0
-#define MAX_NUM_UARTS			2
-#define FREE_DEFAULT_SIZE		256
-#define NUM_FREE_DESC			18
-#define FREE_DESC_POOL_WIDTH		20
-#define NUM_FREEIN_QUEUE		18
+
+/* Currently Spill areas are not configured, so number of
+ * desc sent to NAE should be less than default free frin
+ * fifo size (50)
+ */
 #define MAX_NUM_DESC                    32
 #define MIN_FRIN_DESC_THRESHD		16
-#define MAX_NET_INF             	18
+#define FREE_DESC_POOL_WIDTH		20
+
+#define MAX_NET_INF             	1
+#define MAX_GMAC_PORT               	18
 #define XLP_SGMII_RCV_CONTEXT_NUM	8
 
+/* FMN send failure errors */
 #define MSG_DST_FC_FAIL                 0x01
 #define MSG_INFLIGHT_MSG_EX             0x02
 #define MSG_TXQ_FULL                    0x04
-#define ICMP_LEN                     	74
-#define MAX_GMAC_PORT               	18
-#define ETH_MTU_SIZE		 	2048
+
+#define ETH_MTU_SIZE		 	1536
 #define MIN_ETH_FRAME_SIZE		64
 
 #define  DUMP_PKT(x, y)	if (debug == 2)  {	\
@@ -95,29 +99,32 @@
 static int debug = 0;
 module_param(debug, int, 0);
 
-static int hwemul = 0;
+extern int hwemul;
 module_param(hwemul, int, 0);
 
+extern int  xlp_sgmii_ports;
+module_param(xlp_sgmii_ports, int, 0);
+
 unsigned char eth_hw_addr[18][6] = {
-					{0x00,0x01,0x02,0x03,0x04,0x05},
-					{0x00,0x01,0x02,0x03,0x04,0x06},
-					{0x00,0x01,0x02,0x03,0x04,0x07},
-					{0x00,0x01,0x02,0x03,0x04,0x08},
-					{0x00,0x01,0x02,0x03,0x04,0x09},
-					{0x00,0x01,0x02,0x03,0x04,0x0A},
-					{0x00,0x01,0x02,0x03,0x04,0x0B},
-					{0x00,0x01,0x02,0x03,0x04,0x0C},
-					{0x00,0x01,0x02,0x03,0x04,0x0D},
-					{0x00,0x01,0x02,0x03,0x04,0x0E},
-					{0x00,0x01,0x02,0x03,0x04,0x0F},
-					{0x00,0x01,0x02,0x03,0x04,0x10},
-					{0x00,0x01,0x02,0x03,0x04,0x11},
-					{0x00,0x01,0x02,0x03,0x04,0x12},
-					{0x00,0x01,0x02,0x03,0x04,0x13},
-					{0x00,0x01,0x02,0x03,0x04,0x14},
-					{0x00,0x01,0x02,0x03,0x04,0x15},
-					{0x00,0x01,0x02,0x03,0x04,0x16}
-				   };
+	{0x00,0x01,0x02,0x03,0x04,0x05},
+	{0x00,0x01,0x02,0x03,0x04,0x06},
+	{0x00,0x01,0x02,0x03,0x04,0x07},
+	{0x00,0x01,0x02,0x03,0x04,0x08},
+	{0x00,0x01,0x02,0x03,0x04,0x09},
+	{0x00,0x01,0x02,0x03,0x04,0x0A},
+	{0x00,0x01,0x02,0x03,0x04,0x0B},
+	{0x00,0x01,0x02,0x03,0x04,0x0C},
+	{0x00,0x01,0x02,0x03,0x04,0x0D},
+	{0x00,0x01,0x02,0x03,0x04,0x0E},
+	{0x00,0x01,0x02,0x03,0x04,0x0F},
+	{0x00,0x01,0x02,0x03,0x04,0x10},
+	{0x00,0x01,0x02,0x03,0x04,0x11},
+	{0x00,0x01,0x02,0x03,0x04,0x12},
+	{0x00,0x01,0x02,0x03,0x04,0x13},
+	{0x00,0x01,0x02,0x03,0x04,0x14},
+	{0x00,0x01,0x02,0x03,0x04,0x15},
+	{0x00,0x01,0x02,0x03,0x04,0x16}
+};
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -126,7 +133,6 @@ static struct pci_device_id soc_pci_table[] __devinitdata = {
         {}
 };
 
-extern int  xlp_sgmii_ports;
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
 spinlock_t  nlm_xlp_nae_lock;
@@ -140,7 +146,10 @@ static void  nlm_xlp_set_multicast_list (struct net_device *dev);
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);
 static int  nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu);
 static void  nlm_xlp_nae_tx_timeout (struct net_device *dev);
+
+#ifdef  ENABLE_NAE_PIC_INT
 static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id);
+#endif
 
 static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 					uint32_t size, uint32_t code,
@@ -171,6 +180,34 @@ static const struct net_device_ops nlm_xlp_nae_ops = {
 	.ndo_get_stats = nlm_xlp_mac_get_stats,
 };
 
+static __inline__ void print_fmn_send_error(uint32_t send_result, uint32_t status1)
+{
+	if(send_result & MSG_DST_FC_FAIL)
+	{
+		status1 = xlp_read_status1();
+		if( status1 & (1 << 31))
+		{
+			printk("CPU receive queue written when Full\n");
+
+		}
+		else if (status1 & (1 << 30))
+		{
+			printk("Fmn input credit overflow hardware error\n");
+		}
+		else if (status1 & (1 << 29))
+		{
+			printk("Fmn output credit overflow error, Outq ID: %d\n", status1 & 0xfff);
+		}
+		printk("TX message destination flow control credit fail\n");
+	}
+	else if (send_result & MSG_INFLIGHT_MSG_EX) {
+		printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
+	}
+	else if (send_result & MSG_TXQ_FULL) {
+		printk("TX message Q fulll\n");
+	}
+}
+
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
         uint64_t *back_ptr = (uint64_t *)(addr - CACHELINE_SIZE);
@@ -203,7 +240,7 @@ static __inline__ void *cacheline_aligned_kmalloc(int size, int gfp_mask)
         void *buf = kmalloc(size + CACHELINE_SIZE, gfp_mask);
         if (buf)
                 buf =(void*)(CACHELINE_ALIGNED_ADDR((unsigned long)buf +
-                                                   CACHELINE_SIZE));
+						    CACHELINE_SIZE));
         return buf;
 }
 
@@ -370,35 +407,11 @@ static void mac_refill_frin_desc(unsigned long dev)
         	msg.entry[1]= msg.entry[2] = msg.entry[3] = 0;
         	/* Send the packet to nae rx  */
 		__sync();
-retry_send:
-                if ((ret = nlm_hal_send_msg1( priv->nae_rx_qid, code, msg.entry[0])))
+	retry_send:
+                if ( (ret = nlm_hal_send_msg1(priv->nae_rx_qid, code, msg.entry[0])) )
 		{
-                       	if(ret & MSG_DST_FC_FAIL)
-			{
-		               	ret = xlp_read_status1();
-                        	if( ret & (1 << 31))
-                        	{
-                                	printk("CPU receive queue written when Full\n");
-
-                        	}
-                        	else if(ret & (1 << 30))
-                        	{
-                                	printk("Fmn input credit overflow hardware error\n");
-                        	}
-                        	else if( ret & (1 << 29))
-                        	{
-                                	printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-                        	}
-                                printk("TX message destination flow control credit fail\n");
-			}
-                        else if(ret & MSG_INFLIGHT_MSG_EX) {
-				printk("[%s] MSG_INFLIGHT_MSG_EX\n", __func__);
-			}
-                        else if(ret & MSG_TXQ_FULL) {
-                                printk("TX message Q fulll\n");
-			}
-
-			printk("[%s]: retrying...\n", __func__);
+			print_fmn_send_error(ret, xlp_read_status1());
+			if (debug) printk("[%s]: retrying...\n", __func__);
 			goto retry_send;
                 }
 		msgrng_access_disable(mflags);
@@ -422,7 +435,7 @@ static void nlm_xlp_nae_init(void)
 	uint32_t val;
 
 	printk("======= Module Parameters =========\n");
-	printk("debug = %d, hwemul=%d\n", debug, hwemul);
+	printk("debug = %d, hwemul=%d, xlp_sgmii_ports=%d\n", debug, hwemul, xlp_sgmii_ports);
 
 	if (hwemul) {
 		unsigned long mflags = 0;
@@ -431,9 +444,10 @@ static void nlm_xlp_nae_init(void)
 		msgrng_access_disable(mflags);
 	}
 
- 	if(xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
+ 	if (xlp_sgmii_ports <= 0 || xlp_sgmii_ports > MAX_GMAC_PORT)
 	{
-		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",__FUNCTION__, xlp_sgmii_ports);
+		printk("NET: [%s] driver init is diabled. xlp_sgmii_ports=%d \n",
+		       __FUNCTION__, xlp_sgmii_ports);
 		return;
 	}
 
@@ -443,23 +457,22 @@ static void nlm_xlp_nae_init(void)
 
 	spin_lock_irq(&nlm_xlp_nae_lock);
 
-	/* initial 18 gmac block */
-        for(i = 0; i < 1/*MAX_NET_INF*/; i++)
+	/* initial NAE interfaces */
+        for(i = 0; i < MAX_NET_INF; i++)
 	{
-		/* init_gmac(i); */
 		nlm_hal_open_if(GMAC_IF, i);
 	}
 
-	for (i = 0; i < 1 /*MAX_NET_INF*/; i++ )
+	/* Currently HAL doesn't initialize ucores, so initialize them */
+	for (i = 0; i < MAX_NET_INF; i++ )
 	{
 		init_ucore(0xffffUL, i);
 	}
-
 	ucore_load_apps(0xffffUL);
 
 	spin_unlock_irq(&nlm_xlp_nae_lock);
 
-	for(i = 0; i< xlp_sgmii_ports /*MAX_GMAC_PORT*/; i++)
+	for(i = 0; i < xlp_sgmii_ports; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
 		if(!dev)
@@ -496,16 +509,18 @@ static void nlm_xlp_nae_init(void)
 				       nlm_root_proc /* parent */ ,
 				       xlp_mac_proc_read /* proc read function */ ,
 				       0	/* no client data */
-					);
+		);
 	if (!entry) {
 		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",
 		       __FUNCTION__);
 	}
+
 	/*config free fifo context mapping*/
 	spin_lock_irq(&nlm_xlp_nae_lock);
+
 	for(i = 0; i < FREE_DESC_POOL_WIDTH; i++)
 	{
-		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );
+		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG);
 
 		val = (1 << 31)|(26<<20) |((i*26) << 8) | i*26;
 		nlm_hal_write_nae_reg(FREE_IN_FIFO_CFG, val );
@@ -534,7 +549,7 @@ static void nlm_xlp_sgmii_setcontext(void)
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
  	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_1, val );
-	 i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
+	i +=  XLP_SGMII_RCV_CONTEXT_NUM * 2;
 
 	val = ((i + XLP_SGMII_RCV_CONTEXT_NUM ) << 16) |i;
  	nlm_hal_write_nae_reg(RX_IF_BASE_CONFIG_2, val );
@@ -574,7 +589,6 @@ static void nlm_xlp_sgmii_setcontext(void)
 static int  nlm_xlp_nae_open (struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
-	int port = priv->port;
 	int i;
 
 	if (priv->inited) return 0;
@@ -586,14 +600,17 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 
 	mac_refill_frin_desc((unsigned long)dev);
 
-/*
-	irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
-	if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
-		ret = -EBUSY;
-		printk("can't get mac interrupt line (%d)\n",dev->irq);
+#ifdef ENABLE_NAE_PIC_INT
+	{
+		int port = priv->port;
+		irq  = irt_irq_table[PIC_IRT_NA_INDEX(port)][0];
+		if(request_irq( irq, nlm_xlp_nae_int_handler, IRQF_SHARED,dev->name, dev)){
+			ret = -EBUSY;
+			printk("can't get mac interrupt line (%d)\n",dev->irq);
+		}
+		dump_irt_entry(PIC_IRT_NA_INDEX(port));
 	}
-*/
-	/*dump_irt_entry(PIC_IRT_NA_INDEX(port)); */
+#endif
 
 	/* set timer to test rx routine */
 	init_timer(&priv->link_timer);
@@ -660,7 +677,6 @@ static int  nlm_xlp_nae_stop (struct net_device *dev)
 static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dev_data *priv = netdev_priv(dev);
-	int port = priv->port;
 	unsigned long mflags = 0;
 	int cpu = 0, ret = 0;
 	struct xlp_msg msg =  { {0, 0, 0, 0} };
@@ -678,10 +694,10 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	msg.entry[0] = nae_tx_desc(P2D_NEOP, 0, CPU_Q_ID( 0, 0, 1), 0, virt_to_bus(skb));
 	msg.entry[1] = nae_tx_desc(P2D_EOP,
-							 0,
-							 NULL_VFBID,
-							 skb->len,
-							 virt_to_bus(skb->data));
+				   0,
+				   NULL_VFBID,
+				   skb->len,
+				   virt_to_bus(skb->data));
 
 	msg.entry[2] = msg.entry[3] = 0;
 
@@ -689,43 +705,20 @@ static int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	__sync();
 
-       if (debug) {
-	       printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
-		      priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
-       }
+	if (debug) {
+		printk("[%s]: tx_qid=%d, entry0=%llx, entry1=%llx\n", __func__,
+		       priv->nae_tx_qid, msg.entry[0], msg.entry[1]);
+	}
 
 	msgrng_access_enable(mflags);
-retry_send:
-        if ((ret = nlm_hal_send_msg2( priv->nae_tx_qid,
-                           0,
-                           msg.entry[0],
-                           msg.entry[1])))
+ retry_send:
+        if ( (ret = nlm_hal_send_msg2(priv->nae_tx_qid,
+				      0,
+				      msg.entry[0],
+				      msg.entry[1])) )
         {
-                if(ret & MSG_DST_FC_FAIL)
-		{
-			ret = xlp_read_status1();
-			if( ret & (1 << 31))
-			{
-				printk("CPU receive queue written when Full\n");
-
-			}
-			else if(ret & (1 << 30))
-			{
-				printk("Fmn input credit overflow hardware error\n");
-			}
-			else if( ret & (1 << 29))
-			{
-				printk("Fmn output credit overflow error, Outq ID: %d\n", ret & 0xfff);
-			}
-		}
-                else if(ret & MSG_INFLIGHT_MSG_EX) {
-			printk("[%s]: MSG_INFLIGHT_MSG_EX\n", __func__);
-		}
-                else if(ret & MSG_TXQ_FULL)
-		{
-                        printk("TX message Q fulll\n");
-		}
-		printk("[%s]: retrying...\n", __func__);
+		print_fmn_send_error(ret, xlp_read_status1());
+		if (debug) printk("[%s]: retrying message send...\n", __func__);
 		goto retry_send;
         }
 
@@ -841,13 +834,14 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 	return;
 }
 
+#ifdef ENABLE_NAE_PIC_INT
 /**********************************************************************
  * nlm_xlp_nae_int_handler -  interrupt handler
  * @irq     -  irq number
  * @dev_id  -  this device
  *
  **********************************************************************/
-static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
+static irqreturn_t nlm_xlp_nae_int_handler(int irq, void *dev_id)
 {
         struct net_device *dev;
         struct dev_data *priv;
@@ -870,6 +864,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void * dev_id)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 /**********************************************************************
  * nlm_xlp_nae_msgring_handler -  message ring interrupt handler
@@ -893,10 +888,10 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	cpu = hard_smp_processor_id();
 	vc = vc & 0x03;
 
-       if (debug) {
-	       printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
-		      src_id, vc, size, msg0, msg1);
-       }
+	if (debug) {
+		printk("[%s] src_id=%d vc = %d, size = %d, entry0=%llx entry1=%llx\n", __func__,
+		       src_id, vc, size, msg0, msg1);
+	}
 
 	if( vc == 1 && size == 1)
 	{
@@ -1044,13 +1039,13 @@ static int xlp_mac_proc_read(char *page, char **start, off_t off,
 			       priv->stats.tx_packets, priv->stats.tx_bytes);
 	}
 	for(cpu=0;cpu<8;cpu++) {
-			len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
-				        cpu,
-				       priv->cpu_stats[cpu].tx_packets,
-				       priv->cpu_stats[cpu].txc_packets,
-				       priv->cpu_stats[cpu].rx_packets,
-				       priv->cpu_stats[cpu].interrupts);
-		}
+		len += sprintf(page + len, "per cpu:  %d %lx %lx %lx %lx\n",
+			       cpu,
+			       priv->cpu_stats[cpu].tx_packets,
+			       priv->cpu_stats[cpu].txc_packets,
+			       priv->cpu_stats[cpu].rx_packets,
+			       priv->cpu_stats[cpu].interrupts);
+	}
 
 	*eof = 1;
 
@@ -1086,6 +1081,7 @@ static void nlm_xlp_mac_timer(unsigned long data)
 static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
         int result = 0;
+
         result = pci_enable_device(pdev);
 	return result;
 }
@@ -1094,10 +1090,11 @@ static int __devinit nlm_xlp_nae_pci_probe(struct pci_dev *pdev, const struct pc
  * nlm_xlp_nae_remove - driver remove routine
  * @pdev - pci device.
  **********************************************************************/
-static void nlm_xlp_nae_remove(struct net_device * dev)
+static void nlm_xlp_nae_remove(void)
 {
 	int i;
-        struct dev_data *priv;
+	struct net_device *dev = 0;
+        struct dev_data *priv = 0;
 
 	for (i = 0; i < MAX_GMAC_PORT; i++)
 	{
@@ -1116,12 +1113,11 @@ static struct pci_driver soc_driver = {
 	.name             = XLP_SOC_MAC_DRIVER,
 	.id_table         = soc_pci_table,
 	.probe            = nlm_xlp_nae_pci_probe,
-	.remove		  = nlm_xlp_nae_remove,
+	.remove		  = NULL,
 };
 
 static int __init nlm_xlp_mac_init(void)
 {
-
 	nlm_xlp_nae_init();
 
     	return pci_register_driver(&soc_driver);
@@ -1129,6 +1125,9 @@ static int __init nlm_xlp_mac_init(void)
 
 static void __exit nlm_xlp_mac_exit(void)
 {
+	/* unregister mac driver */
+	nlm_xlp_nae_remove();
+
 	pci_unregister_driver(&soc_driver);
 }
 
-- 
1.8.4.93.g57e4c17

