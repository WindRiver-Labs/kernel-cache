From d9deb3fa0ccfcafd31720f956098f58a86fd8ed3 Mon Sep 17 00:00:00 2001
From: Mehul <vmehul@netlogicmicro.com>
Date: Thu, 17 Nov 2011 11:50:14 +0530
Subject: [PATCH 304/565] Modified FMN driver

Modify FMN driver to poll messages in softirq context for napi vc

Based on Broadcom SDK 2.3.

Signed-off-by: Mehul <vmehul@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c | 116 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 114 insertions(+), 2 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index e466674..e5d8128 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -41,6 +41,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/xlp_hal_pic.h>
 
+#include <linux/netdevice.h>
+
 #define MAX_VC	4096
 
 extern int xlp_rvec_from_irt(int);
@@ -68,6 +70,13 @@ struct msgstn_handler {
         void *dev_id;
 };
 
+struct net_device xlp_napi_fmn_dummy_dev;
+DEFINE_PER_CPU(struct napi_struct, xlp_napi_fmn_poll_struct);
+DEFINE_PER_CPU(unsigned long long, xlp_napi_fmn_rx_count);
+static int xlp_napi_vc_count = 0;
+static int xlp_fmn_init_done = 0;
+extern unsigned int xlp_napi_vc_mask;
+
 static uint16_t vc_to_handle_map[MAX_VC] = {
 	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
 	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
@@ -224,7 +233,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
 	int cpu = hard_smp_processor_id();
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
-
 	msg0 = msg1 = msg2 = msg3 = 0;
 
 	if (irq == XLP_IRQ_MSGRING) {
@@ -246,6 +254,15 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		/* Read latest VC empty mask */
 		msg_status1 = xlp_read_status1();
 
+		if(xlp_fmn_init_done && (~(msg_status1>>24) & xlp_napi_vc_mask)){
+			struct napi_struct *napi;
+
+			/*Schedule napi routine to process messages from napi vc*/
+		        napi = &__get_cpu_var(xlp_napi_fmn_poll_struct);
+		        napi_schedule(napi);
+			pop_vc_mask = pop_vc_mask & ~xlp_napi_vc_mask;
+		}
+
 		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
 		if (vc_empty_status == pop_vc_mask) break;  
 
@@ -372,6 +389,9 @@ int register_xlp_msgring_handler(int major,
 	/* Check if the message station is valid, if not return error */
 	spin_lock_irqsave(&msgrng_lock, flags);
 
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+
 	if(msg_handler_timer_enabled == 0) {
 		msg_handler_timer_enabled = 1;
 		spin_unlock_irqrestore(&msgrng_lock, flags);
@@ -598,8 +618,8 @@ void nlm_enable_vc_intr(void)
 
 	for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
 	{
+		vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
 		if(nlm_cpu_vc_mask[cpu] & (1<<i)){
-			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
 			/*enable interrupts*/
 			nlm_hal_enable_vc_intr(0, vc_index);
 		}else{
@@ -608,6 +628,95 @@ void nlm_enable_vc_intr(void)
 	}
 }
 
+int xlp_fmn_poll(struct napi_struct *napi, int budget)
+{
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
+	struct msgstn_handler *handler = 0;
+	unsigned int status = 0;
+	uint64_t msg0, msg1, msg2, msg3;
+	int cpu = hard_smp_processor_id();
+	int count = 0;
+	int no_msg = 0;
+
+	while(count < budget){
+		for( no_msg = 0, vc = 0; vc < 4; vc++)
+		{
+			if(!(xlp_napi_vc_mask & (1<<vc)))
+				continue;
+
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			if(status != 0){
+				no_msg++;
+				continue;
+			}
+			count++;
+			if (is_nlm_xlp3xx()) {
+				handler = &msg_handler_map[xlp3xx_vc_to_handle_map[src_id]];
+			}
+			else {
+				handler = &msg_handler_map[vc_to_handle_map[src_id]];
+			}
+
+			/* Execute device driver fmn handler */
+			(handler->action)(vc, src_id, size, code,
+				  msg0, msg1, msg2, msg3, handler->dev_id);
+		}
+		if(no_msg == xlp_napi_vc_count)
+			break;
+	}
+
+	/*Ack fmn interrupts.*/
+	if(count < budget) {
+		uint32_t val;
+                napi_complete(napi);
+		/* Need write vc into the register */
+		val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+		//val |= ((1 << vc) << 16);
+		val |= (xlp_napi_vc_mask << 16);
+		_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+		return count;
+	}
+	return budget;
+}
+
+static inline int num_ones(unsigned int mask)
+{
+	int ret = 0;
+
+	if (!mask) return 0;
+	while ((mask &= (mask - 1))) ret++;
+	return (ret + 1);
+}
+
+
+static int xlp_napi_fmn_setup(void)
+{
+	int i, cpu_count;
+	struct napi_struct *napi;
+	int weight_p = 300;
+
+	xlp_napi_vc_count = num_ones(xlp_napi_vc_mask);
+	printk("MSGRING_NAPI: Initializing NLM NAPI subsystem\n");
+
+	init_dummy_netdev(&xlp_napi_fmn_dummy_dev);
+
+	for (cpu_count = 0; cpu_count < NR_CPUS; cpu_count++)
+	{
+		napi = &per_cpu(xlp_napi_fmn_poll_struct, cpu_count);
+		memset(napi, 0, sizeof(*napi));
+		netif_napi_add(&xlp_napi_fmn_dummy_dev, napi, xlp_fmn_poll, weight_p);
+		napi_enable(napi);
+	}
+
+	for (i = 0; i < NR_CPUS; i++) {
+		per_cpu(xlp_napi_fmn_rx_count, i) = 0;
+	}
+	return 0;
+}
+
+
+
 /*********************************************************************
  * on_chip_init
  *  
@@ -634,4 +743,7 @@ void on_chip_init(void)
 
 	/*enable vc interrupts*/
 	nlm_enable_vc_intr();
+
+	if(xlp_napi_vc_mask)
+		xlp_napi_fmn_setup();
 }
-- 
1.8.4.93.g57e4c17

