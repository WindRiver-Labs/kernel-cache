From 65e6407d2d36019605887be6aee6efb1754fd253 Mon Sep 17 00:00:00 2001
From: Hareesh R <hareesh@netlogicmicro.com>
Date: Wed, 7 Dec 2011 15:25:33 +0530
Subject: [PATCH 309/565] Enable/disable vc intr

Enable/disable vc intr is done after fmn init

Based on Broadcom SDK 2.3.

Signed-off-by: Hareesh R <hareesh@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c | 86 +++++++++++++++++++++++++++++++++-------
 arch/mips/netlogic/xlp/smp.c     |  6 ++-
 2 files changed, 75 insertions(+), 17 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 228af24..41e277e 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -231,6 +231,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
+	int loop = 0;
 	int cpu = hard_smp_processor_id();
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
 	msg0 = msg1 = msg2 = msg3 = 0;
@@ -435,6 +436,30 @@ int unregister_xlp_msgring_handler(int major, void *dev_id)
 
 EXPORT_SYMBOL(unregister_xlp_msgring_handler);
 
+#include <asm/netlogic/cpumask.h>
+void nlm_nmi_cpus(unsigned int mask)
+{
+	uint32_t cpumask = cpumask_to_uint32(&cpu_present_map); /* doesn't handle non-n0 nodes */
+	uint32_t cpumask_lo;
+	uint32_t cpumask_hi;
+	const int nmi = 1;
+
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	cpumask = cpumask & mask;
+
+	cpumask_hi = cpumask >> 16;;
+	cpumask_lo = cpumask & 0xffff;
+
+	/* Send IRQ_MSGRING vector in an IPI to all cpus but the current one */
+	if (cpumask_lo)
+		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (nmi << 31) | cpumask_lo );
+
+	if (cpumask_hi)
+		nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, (nmi << 31) | (1 << 16) | (cpumask_hi));
+}
+
+
 /*********************************************************************
  * enable_msgconfig_int 
  *
@@ -577,6 +602,32 @@ void xlp_set_cpumask(const struct cpumask *m, int irt)
 	return;
 }
 
+
+/*********************************************************************
+ *  pic_init
+ *  
+ ********************************************************************/
+static void pic_init(void)
+{
+	int i = 0;
+	int level, vcpu;
+	uint32_t thread_mask;
+
+	vcpu = hard_smp_processor_id() & 0x1F;
+
+	thread_mask = (1 << vcpu);
+
+	for (i = XLP_IRQ_RESERVED_MAX; i < XLP_IRT_NUM; i++) {
+		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
+		/* Use local scheduling and high polarity for all IRTs
+		 * Invalidate all IRTs, by default */
+		nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, xlp_rvec_from_irq(i), 1, 0, thread_mask);
+	}
+
+	/* On XLP, MSGRING config register is per hw-thread */
+	enable_msgconfig_int();
+}
+
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
 
 /*********************************************************************
@@ -613,18 +664,26 @@ static void nlm_usb_init (void)
  *********************************************************************/
 void nlm_enable_vc_intr(void)
 {
-	int cpu = hard_smp_processor_id();
+	int cpu;
 	int vc_index = 0;
 	int i = 0;
+	uint32_t cpu_map;
 
-	for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
-	{
-		vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
-		if(nlm_cpu_vc_mask[cpu] & (1<<i)){
-			/*enable interrupts*/
-			nlm_hal_enable_vc_intr(0, vc_index);
-		}else{
-			nlm_hal_disable_vc_intr(0, vc_index);
+	cpu_map = cpumask_to_uint32(&cpu_present_map);
+
+	for(cpu = 0; cpu < 32; cpu++) {
+		if(!(cpu_map & (1 << cpu)))
+			continue;
+	
+		for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
+		{
+			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+				/*enable interrupts*/
+				nlm_hal_enable_vc_intr(0, vc_index);
+			}else{
+				nlm_hal_disable_vc_intr(0, vc_index);
+			}
 		}
 	}
 }
@@ -736,16 +795,13 @@ void on_chip_init(void)
 
 	nlm_hal_init();
 
+	pic_init(); 
+
 	for (i = 0; i < NR_CPUS; i++)
 	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
 
-	/* On XLP, MSGRING config register is per hw-thread */
-	enable_msgconfig_int();
-
-	/*enable vc interrupts*/
-	nlm_enable_vc_intr();
-
+	
 	if(xlp_napi_vc_mask)
 		xlp_napi_fmn_setup();
 }
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index e43336c..4841b09 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -122,8 +122,7 @@ static void __cpuinit nlm_init_secondary(void)
 	    }
     }
 
-    /* Enable vc interupts for this thread*/
-    nlm_enable_vc_intr();
+
 }
 
 void nlm_smp_finish(void)
@@ -135,6 +134,9 @@ void nlm_cpus_done(void)
 	int node = 0;
 	extern void *fdt;
 	nlm_hal_fmn_init(fdt, (void *)(long)node);
+	
+	/* Enable vc interupts for the online cpus */
+	nlm_enable_vc_intr();
 }
 
 /*
-- 
1.8.4.93.g57e4c17

