From 66304acf1ca1e0c323ddaf2fffee885576de5e63 Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Tue, 10 Jan 2012 19:13:57 -0800
Subject: [PATCH 328/565] bcm-xlp: XLR: cleanup

XLR: cleanup, purge legacy files, contain SDK changes to XLP.

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/addrspace.h                  |   2 +-
 arch/mips/include/asm/cacheflush.h                 |   2 +-
 arch/mips/include/asm/dma.h                        |   2 +-
 arch/mips/include/asm/mach-netlogic/ioremap.h      |   6 +-
 .../include/asm/mach-netlogic/kernel-entry-init.h  |   6 +
 arch/mips/include/asm/mach-netlogic/mmu.h          |  11 --
 arch/mips/include/asm/mmu_context.h                |  15 +--
 arch/mips/include/asm/netlogic/bootinfo.h          |   6 +-
 arch/mips/include/asm/netlogic/cpumask.h           |   3 +
 arch/mips/include/asm/netlogic/debug.h             |   3 +
 arch/mips/include/asm/netlogic/gpio.h              |  47 +------
 arch/mips/include/asm/netlogic/io.h                |   3 +
 arch/mips/include/asm/netlogic/iomap.h             |   3 +
 arch/mips/include/asm/netlogic/mips-exts.h         |  33 +----
 arch/mips/include/asm/netlogic/msidef.h            |   3 +
 arch/mips/include/asm/netlogic/nlm_dma.h           |   3 +
 arch/mips/include/asm/netlogic/nlm_fs.h            |   3 +
 arch/mips/include/asm/netlogic/nlm_rw_lock.h       |   3 +
 arch/mips/include/asm/netlogic/phnx_loader.h       |   3 +
 arch/mips/include/asm/netlogic/pic.h               |   3 +
 arch/mips/include/asm/netlogic/proc.h              |   3 +
 arch/mips/include/asm/netlogic/xlp.h               |   3 +
 arch/mips/include/asm/netlogic/xlp8xx/cpu.h        |   3 +
 .../asm/netlogic/xlp8xx/cpu_control_macros.h       |   3 +
 arch/mips/include/asm/netlogic/xlp_hal_pic.h       |   3 +
 arch/mips/include/asm/netlogic/xlp_irq.h           |   8 +-
 arch/mips/include/asm/netlogic/xlp_usb.h           |   3 +
 arch/mips/include/asm/pci.h                        |   2 -
 arch/mips/include/asm/smp.h                        |   2 +-
 arch/mips/include/asm/timex.h                      |   4 +-
 arch/mips/kernel/asm-offsets.c                     |  23 +---
 arch/mips/kernel/cpu-probe.c                       |  61 +++++++++
 arch/mips/kernel/head.S                            |  44 ++++++-
 arch/mips/kernel/kgdb.c                            |  11 +-
 arch/mips/kernel/nlm_fs_handler.S                  |   7 +-
 arch/mips/kernel/ptrace.c                          |   6 +-
 arch/mips/kernel/r4k_switch.S                      |   4 +
 arch/mips/kernel/setup.c                           |  15 +--
 arch/mips/kernel/unaligned.c                       |  12 ++
 arch/mips/kernel/vmlinux.lds.S                     |  16 ++-
 arch/mips/mm/c-phoenix.c                           |  16 ---
 arch/mips/mm/cache.c                               |   3 +-
 arch/mips/mm/cex-gen.S                             |   2 +-
 arch/mips/mm/tlb-r4k.c                             |  57 +-------
 arch/mips/netlogic/Kconfig                         | 146 +++------------------
 arch/mips/netlogic/common/Makefile                 |   9 +-
 arch/mips/netlogic/common/cpu_proc.c               |  17 ---
 arch/mips/netlogic/xlp/cpu_control_asm.S           |   2 +
 arch/mips/netlogic/xlp/on_chip.c                   |  10 --
 arch/mips/netlogic/xlp/smp.c                       |   3 +-
 arch/mips/netlogic/xlp/time.c                      |  65 +--------
 arch/mips/oprofile/Makefile                        |   1 -
 arch/mips/pci/pci-xlp.c                            |  84 ------------
 arch/mips/xen/Kconfig                              |   2 +-
 drivers/char/Kconfig                               |  19 ---
 drivers/char/Makefile                              |   2 +-
 drivers/i2c/busses/Kconfig                         |  11 --
 drivers/mtd/maps/Makefile                          |   1 -
 drivers/net/Kconfig                                |  15 ---
 drivers/net/Makefile                               |   4 -
 drivers/pci/proc.c                                 |   2 +-
 drivers/watchdog/Kconfig                           |   8 --
 drivers/watchdog/Makefile                          |   1 -
 63 files changed, 277 insertions(+), 596 deletions(-)

diff --git a/arch/mips/include/asm/addrspace.h b/arch/mips/include/asm/addrspace.h
index 7cf85bd..6b97876 100644
--- a/arch/mips/include/asm/addrspace.h
+++ b/arch/mips/include/asm/addrspace.h
@@ -134,7 +134,7 @@
  * the region, 3 bits for the CCA mode.  This leaves 59 bits of which the
  * R8000 implements most with its 48-bit physical address space.
  */
-#if defined(CONFIG_CPU_XLR) || defined(CONFIG_CPU_XLP)
+#if defined(CONFIG_CPU_XLP)
 #define TO_PHYS_MASK	_CONST64_(0x000000ffffffffff)	/* 2^^40 - 1 */
 #else
 #define TO_PHYS_MASK	_CONST64_(0x07ffffffffffffff)	/* 2^^59 - 1 */
diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index 662a599..0fd7b59 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -49,7 +49,7 @@ extern void __flush_dcache_page(struct page *page);
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	extern void nlm_common_flush_dcache_page(struct page *page);
 	nlm_common_flush_dcache_page(page);
 #else
diff --git a/arch/mips/include/asm/dma.h b/arch/mips/include/asm/dma.h
index 976a5f8..4289d2c 100644
--- a/arch/mips/include/asm/dma.h
+++ b/arch/mips/include/asm/dma.h
@@ -87,7 +87,7 @@
 /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
 #define MAX_DMA_ADDRESS		PAGE_OFFSET
 #else
-#if defined(CONFIG_NLM_COMMON) && defined(CONFIG_64BIT)
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_64BIT)
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x80000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
diff --git a/arch/mips/include/asm/mach-netlogic/ioremap.h b/arch/mips/include/asm/mach-netlogic/ioremap.h
index d98eb20..215919a 100644
--- a/arch/mips/include/asm/mach-netlogic/ioremap.h
+++ b/arch/mips/include/asm/mach-netlogic/ioremap.h
@@ -11,13 +11,13 @@
 
 #include <linux/types.h>
 
+#ifdef CONFIG_NLM_XLP
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
 
-#define NETLOGIC_UNCACHED_START 0x10000000UL
-#define NETLOGIC_UNCACHED_END 0x20000000UL
-
 extern inline int valid_phys_addr_range(unsigned long addr, size_t count);
 extern inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+#endif
+
 /*
  * Allow physical addresses to be fixed up to help peripherals located
  * outside the low 32-bit range -- generic pass-through version.
diff --git a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
index ea24e3f..786f70a 100644
--- a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
@@ -1,6 +1,10 @@
 #ifndef __ASM_MACH_NLM_KERNEL_ENTRY_H
 #define __ASM_MACH_NLM_KERNEL_ENTRY_H
 
+#include <asm/mach-generic/kernel-entry-init.h>
+
+#ifdef CONFIG_NLM_XLP
+
 /* XLP_MERGE_TODO */
 #if !defined(CKSSEG)
 #define CKSSEG			0xffffffffc0000000
@@ -55,4 +59,6 @@ mapped_space:
 #endif
 	.endm
 
+#endif /* CONFIG_NLM_XLP */
+
 #endif /* __ASM_MACH_NLM_KERNEL_ENTRY_H */
diff --git a/arch/mips/include/asm/mach-netlogic/mmu.h b/arch/mips/include/asm/mach-netlogic/mmu.h
index c866b59..ec69f2c 100644
--- a/arch/mips/include/asm/mach-netlogic/mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/mmu.h
@@ -49,13 +49,7 @@ static inline void nlm_update_tlb_stats(void *arg)
 }
 
 #define tlbstats_init() nlm_write_os_scratch_2(0ULL)
-
-#ifdef CONFIG_HUGETLBFS
-#define entrylo0_mask_init() \
-nlm_write_os_scratch_3(~(((1ULL << HUGETLB_PAGE_ORDER) - 1) << ENTRYLO_PFN_SHIFT))
-#else
 #define entrylo0_mask_init()
-#endif
 
 extern void setup_mapped_kernel_tlbs(int index, int secondary_cpu);
 extern unsigned long recalculate_max_low_pfn(unsigned long max_low_pfn);
@@ -64,10 +58,5 @@ extern unsigned long recalculate_max_low_pfn(unsigned long max_low_pfn);
 extern void __init nlm_numa_bootmem_init(unsigned long);
 #endif
 
-#ifndef CONFIG_NLM_XLP
-#define disable_pgwalker(flags) (void)flags
-#define enable_pgwalker(flags) (void) flags
-#endif
-
 #endif /* __ASSEMBLY__ */
 #endif
diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index 7730a79..dd52b6d 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -24,13 +24,13 @@
 #endif /* SMTC */
 #include <asm-generic/mm_hooks.h>
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
 #include <asm/mach-netlogic/mmu.h>
-#endif
-
-#ifndef CONFIG_NLM_XLP
+#else
+#define disable_pgwalker(flags)	(void)flags
+#define enable_pgwalker(flags)	(void)flags
 static inline void setup_user_pgd(pgd_t *pgd) { }
 #endif
 
@@ -97,15 +97,8 @@ extern unsigned long smtc_asid_mask;
 /* End SMTC/34K debug hack */
 #else /* FIXME: not correct for R6000 */
 
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-#define ASID_INC    0x1
-extern unsigned long nlm_asid_mask;
-#define ASID_MASK   nlm_asid_mask
-#else
-
 #define ASID_INC	0x1
 #define ASID_MASK	0xff
-#endif
 
 #endif
 
diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 3486087..2b0535b 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -1,6 +1,10 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NETLOGIC_BOOTINFO_H
 #define _ASM_NETLOGIC_BOOTINFO_H
 
+#ifdef CONFIG_NLM_XLP
 #define LOADER_UBOOT   1
 #define LOADER_OTHER   2
 
@@ -21,8 +25,6 @@ struct boot_mem_map_exclude_region {
 };
 extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
 
-
-#ifdef CONFIG_NLM_XLP
 extern struct psb_info *prom_info;
 extern struct psb_info prom_info_copy;
 extern struct boot_mem_map boot_physaddr_info;
diff --git a/arch/mips/include/asm/netlogic/cpumask.h b/arch/mips/include/asm/netlogic/cpumask.h
index b72ae27..a64b35c 100644
--- a/arch/mips/include/asm/netlogic/cpumask.h
+++ b/arch/mips/include/asm/netlogic/cpumask.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NETLOGIC_CPUMASK_H
 #define _ASM_NETLOGIC_CPUMASK_H
 
diff --git a/arch/mips/include/asm/netlogic/debug.h b/arch/mips/include/asm/netlogic/debug.h
index 20b6d78..086a2b6 100644
--- a/arch/mips/include/asm/netlogic/debug.h
+++ b/arch/mips/include/asm/netlogic/debug.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/gpio.h b/arch/mips/include/asm/netlogic/gpio.h
index c673c93..1cbcfd5 100644
--- a/arch/mips/include/asm/netlogic/gpio.h
+++ b/arch/mips/include/asm/netlogic/gpio.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -26,50 +29,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _ASM_NLM_GPIO_H
 #define _ASM_NLM_GPIO_H
 
-#include <asm/netlogic/iomap.h>
-
-#define NETLOGIC_GPIO_INT_EN_REG 0
-#define NETLOGIC_GPIO_INPUT_INVERSION_REG 1
-#define NETLOGIC_GPIO_IO_DIR_REG 2
-#define NETLOGIC_GPIO_IO_DATA_WR_REG 3
-#define NETLOGIC_GPIO_IO_DATA_RD_REG 4
-
-#define NETLOGIC_GPIO_SWRESET_REG 8
-
-#define NETLOGIC_GPIO_DRAM1_CNTRL_REG 9
-#define NETLOGIC_GPIO_DRAM1_RATIO_REG 10
-#define NETLOGIC_GPIO_DRAM1_RESET_REG 11
-#define NETLOGIC_GPIO_DRAM1_STATUS_REG 12
-
-#define NETLOGIC_GPIO_DRAM2_CNTRL_REG 13
-#define NETLOGIC_GPIO_DRAM2_RATIO_REG 14
-#define NETLOGIC_GPIO_DRAM2_RESET_REG 15
-#define NETLOGIC_GPIO_DRAM2_STATUS_REG 16
-
-#define NETLOGIC_GPIO_PWRON_RESET_CFG_REG 21
-
-#define NETLOGIC_GPIO_BIST_ALL_GO_STATUS_REG 24
-#define NETLOGIC_GPIO_BIST_CPU_GO_STATUS_REG 25
-#define NETLOGIC_GPIO_BIST_DEV_GO_STATUS_REG 26
-
-#define NETLOGIC_GPIO_FUSE_BANK_REG 35
-
-#define NETLOGIC_GPIO_CPU_RESET_REG 40
-
-#define NETLOGIC_GPIO_RNG_REG 43
-
-#define NETLOGIC_PWRON_RESET_PCMCIA_BOOT 17
-
-#define NETLOGIC_GPIO_LED_BITMAP 0x1700000
-#define NETLOGIC_GPIO_LED_0_SHIFT 20
-#define NETLOGIC_GPIO_LED_1_SHIFT 24
-
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_RESET 0x01
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
-#define NETLOGIC_GPIO_LED_OUTPUT_CODE_MAIN 0x04
-
 #ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/iomap.h>
 #include <asm-generic/gpio.h>
 #define gpio_get_value __gpio_get_value
 #define gpio_set_value __gpio_set_value
diff --git a/arch/mips/include/asm/netlogic/io.h b/arch/mips/include/asm/netlogic/io.h
index c6a7437..db4d4ef 100644
--- a/arch/mips/include/asm/netlogic/io.h
+++ b/arch/mips/include/asm/netlogic/io.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
index 8a1418e..a7bbe00 100644
--- a/arch/mips/include/asm/netlogic/iomap.h
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index b8c3087..5b374e8 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -290,9 +293,6 @@ static __inline__ int netlogic_thr_id(void)
 #define CPU_BLOCKID_MMU      4
 #define CPU_BLOCKID_PRF      5
 
-#ifdef CONFIG_NLM_XLR
-#define LSU_CERRLOG_REGID    9
-#else
 #define CPU_BLOCKID_SCU      8
 
 #define ICU_CERRLOG0_REGID   0x10
@@ -306,8 +306,6 @@ static __inline__ int netlogic_thr_id(void)
 #define SCU_CERRLOG1_REGID   0x11
 #define SCU_CERRLOG2_REGID   0x12
 
-#endif
-
 static __inline__ unsigned int read_32bit_nlm_ctrl_reg(int block, int reg)
 {
   unsigned int __res;
@@ -394,27 +392,6 @@ static __inline__ void write_64bit_nlm_ctrl_reg(int block, int reg,unsigned long
 
 typedef struct { volatile int value; } nlm_common_atomic_t;
 
-#ifdef CONFIG_NLM_XLR
-static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
-{
-  int oldval = 0;
-
-  __asm__ __volatile__ (".set push\n"
-			".set noreorder\n"
-			"move $9, %2\n"
-			"li $8, 1\n"
-			//"swapw $8, $9\n"
-			".word 0x71280014\n"
-			"move %1, $8\n"
-			".set pop\n"
-			: "+m" (lock->value), "=r" (oldval)
-			: "r" ((unsigned long)&lock->value)
-			: "$8", "$9"
-			);
-  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
-}
-#endif /* CONFIG_NLM_XLR */
-
 #define nlm_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
 #define nlm_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
 
@@ -422,10 +399,6 @@ static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
 #define nlm_read_os_scratch_3()	__read_64bit_c0_register($22, 3)
 #endif
 
-#ifdef CONFIG_CPU_XLP
 #define SET_MIPS64 .set mips64r2
-#else
-#define SET_MIPS64 .set mips64
-#endif
 
 #endif /* _ASM_NLM_MIPS_EXTS_H */
diff --git a/arch/mips/include/asm/netlogic/msidef.h b/arch/mips/include/asm/netlogic/msidef.h
index df92e36..9754fc4 100644
--- a/arch/mips/include/asm/netlogic/msidef.h
+++ b/arch/mips/include/asm/netlogic/msidef.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/nlm_dma.h b/arch/mips/include/asm/netlogic/nlm_dma.h
index afacc42..32267fa 100644
--- a/arch/mips/include/asm/netlogic/nlm_dma.h
+++ b/arch/mips/include/asm/netlogic/nlm_dma.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _NLM_DMA_H
 #define _NLM_DMA_H
 
diff --git a/arch/mips/include/asm/netlogic/nlm_fs.h b/arch/mips/include/asm/netlogic/nlm_fs.h
index 4156f79..f89d623 100644
--- a/arch/mips/include/asm/netlogic/nlm_fs.h
+++ b/arch/mips/include/asm/netlogic/nlm_fs.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef _ASM_NLM_XLR_UACCESS_H
 #define _ASM_NLM_XLR_UACCESS_H
 
diff --git a/arch/mips/include/asm/netlogic/nlm_rw_lock.h b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
index c331bf2..020fb8cf 100644
--- a/arch/mips/include/asm/netlogic/nlm_rw_lock.h
+++ b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/phnx_loader.h b/arch/mips/include/asm/netlogic/phnx_loader.h
index 429884a..dc6b99f 100644
--- a/arch/mips/include/asm/netlogic/phnx_loader.h
+++ b/arch/mips/include/asm/netlogic/phnx_loader.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
  * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
  * reserved.
diff --git a/arch/mips/include/asm/netlogic/pic.h b/arch/mips/include/asm/netlogic/pic.h
index 76a42f3..49fbca4 100644
--- a/arch/mips/include/asm/netlogic/pic.h
+++ b/arch/mips/include/asm/netlogic/pic.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/proc.h b/arch/mips/include/asm/netlogic/proc.h
index da729e3..55d1903 100644
--- a/arch/mips/include/asm/netlogic/proc.h
+++ b/arch/mips/include/asm/netlogic/proc.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index e7c864a..58c3ca6 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
index ab1a881..f71c9b7 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /*
  * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
  * reserved. Redistribution and use in source and binary forms, with 
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
index ea85462..5f9c6c9 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 #ifndef __CPUCONTROL_MACROS_H__
 #define __CPUCONTROL_MACROS_H__
 #include <asm/netlogic/xlp8xx/cpu.h>
diff --git a/arch/mips/include/asm/netlogic/xlp_hal_pic.h b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
index 8a78ac2..e6b5314 100644
--- a/arch/mips/include/asm/netlogic/xlp_hal_pic.h
+++ b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 70b5742..fee3f41 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -59,11 +62,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_IRQ_IPI_SMP_KGDB	     50
 #define XLP_IRQ_IPI_OPROFILE         51
 
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-#define XLP_IRQ_IPI_NETRX		49
-#define SMP_NETRX_IPI			32
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
 /* if you want some common #defines, please do it here */
 #define NLM_IRQ_DUMMY_UART		XLP_IRQ_DUMMY_UART
 #define NLM_IRQ_IPI_SMP_FUNCTION	XLP_IRQ_IPI_SMP_FUNCTION
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
index 513147f..49b5e13 100644
--- a/arch/mips/include/asm/netlogic/xlp_usb.h
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
  * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
  * reserved.
diff --git a/arch/mips/include/asm/pci.h b/arch/mips/include/asm/pci.h
index 9b27624..fcd4060 100644
--- a/arch/mips/include/asm/pci.h
+++ b/arch/mips/include/asm/pci.h
@@ -125,8 +125,6 @@ static inline int pci_proc_domain(struct pci_bus *bus)
 
 /* implement the pci_ DMA API in terms of the generic device dma_ one */
 #include <asm-generic/pci-dma-compat.h>
-/* Give hook for any pci_ DMA API overrides. */
-#include <pci-dma.h>
 
 /* Do platform specific device initialization at pci_enable_device() time */
 extern int pcibios_plat_dev_init(struct pci_dev *dev);
diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h
index 25eeb28..fa3de45 100644
--- a/arch/mips/include/asm/smp.h
+++ b/arch/mips/include/asm/smp.h
@@ -21,7 +21,7 @@ the header of the original work apply to this derived work.
 
 #include <linux/bitops.h>
 #include <linux/linkage.h>
-#ifndef CONFIG_NLM_COMMON
+#ifndef CONFIG_NLM_XLP
 #include <linux/smp.h>
 #endif
 #include <linux/threads.h>
diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index f155232..d2cddd9 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -135,10 +135,10 @@ static inline int unsynchronized_tsc(void)
 	return !tsc_is_sync();
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #define ARCH_HAS_READ_CURRENT_TIMER	1
 extern int read_current_timer(unsigned long *timer_val);
-#endif /* CONFIG_NLM_COMMON */
+#endif /* CONFIG_NLM_XLP */
 
 #endif /* __KERNEL__ */
 
diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c
index 70811e2..771b441 100644
--- a/arch/mips/kernel/asm-offsets.c
+++ b/arch/mips/kernel/asm-offsets.c
@@ -81,14 +81,6 @@ void output_ptreg_defines(void)
 	OFFSET(NLM_COP2_MSG_CONFIG, pt_regs, msg_config);
 	OFFSET(NLM_COP2_MSG_ERR, pt_regs, msg_err);
 #endif
-
-#ifdef XLP_MERGE_TODO /*CONFIG_NLM_XLP_SIM*/
-	OFFSET("#define PT_CRC_POLY_0 ", pt_regs, crc_poly_0);
-	OFFSET("#define PT_CRC_POLY_1 ", pt_regs, crc_poly_1);
-	OFFSET("#define PT_CRC_POLY_2 ", pt_regs, crc_poly_2);
-	OFFSET("#define PT_CRC_POLY_3 ", pt_regs, crc_poly_3);
-#endif /* CONFIG_NLM_XLP_SIM */
-
 	DEFINE(PT_SIZE, sizeof(struct pt_regs));
 	BLANK();
 }
@@ -224,6 +216,11 @@ void output_mm_defines(void)
 	DEFINE(_PTRS_PER_PGD, PTRS_PER_PGD);
 	DEFINE(_PTRS_PER_PMD, PTRS_PER_PMD);
 	DEFINE(_PTRS_PER_PTE, PTRS_PER_PTE);
+#ifdef CONFIG_XEN
+ 	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+ 	DEFINE(PAGE_SHIFT_asm, PAGE_SHIFT);
+ 	BLANK();
+#endif
 	BLANK();
 	DEFINE(_PAGE_SHIFT, PAGE_SHIFT);
 	DEFINE(_PAGE_SIZE, PAGE_SIZE);
@@ -351,16 +348,6 @@ void output_octeon_cop2_state_defines(void)
 }
 #endif
 
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/sim.h>
-void output_psb_info_defines(void)
-{
-        COMMENT("RMI struct psb_info structure offsets");
-        OFFSET(PSB_CPU_FREQUENCY, psb_info, cpu_frequency);
-	BLANK();
-}
-#endif /* CONFIG_NLM_COMMON */
-
 #ifdef CONFIG_HIBERNATION
 void output_pbe_defines(void)
 {
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index c6568bf..23fb6d5 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -25,6 +25,10 @@
 #include <asm/watch.h>
 #include <asm/elf.h>
 #include <asm/spram.h>
+#if defined(CONFIG_NLM_XLP)
+#include <asm/netlogic/xlp.h>
+#endif
+
 #include <asm/uaccess.h>
 
 static int __cpuinitdata mips_fpu_disabled;
@@ -888,6 +892,7 @@ static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
 	}
 }
 
+#ifndef CONFIG_NLM_XLP
 static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 {
 	decode_configs(c);
@@ -960,6 +965,62 @@ static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 		c->tlbsize = ((read_c0_config1() >> 25) & 0x3f) + 1;
 	}
 }
+#endif /* CONFIG_NLM_XLP */
+
+#ifdef CONFIG_NLM_XLP
+static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
+{
+	decode_configs(c);
+
+	c->options = (MIPS_CPU_TLB     |
+		      MIPS_CPU_4KEX    |
+		      MIPS_CPU_COUNTER |
+		      MIPS_CPU_DIVEC   |
+		      MIPS_CPU_WATCH   |
+		      MIPS_CPU_EJTAG   |
+		      MIPS_CPU_NLM_CACHE |
+		      MIPS_CPU_LLSC);
+
+	switch ((c->processor_id & 0xff00) >> 8) {
+	case CHIP_PROCESSOR_ID_XLP_8_4_XX:
+	case CHIP_PROCESSOR_ID_XLP_8XX:
+	case CHIP_PROCESSOR_ID_XLP_816:
+	case CHIP_PROCESSOR_ID_XLP_432:
+	case CHIP_PROCESSOR_ID_XLP_416:
+	case CHIP_PROCESSOR_ID_XLP_408:
+	case CHIP_PROCESSOR_ID_XLP_3XX:
+	case CHIP_PROCESSOR_ID_XLP_208:
+	case CHIP_PROCESSOR_ID_XLP_204:
+	case CHIP_PROCESSOR_ID_XLP_104:
+	case CHIP_PROCESSOR_ID_XLP_2XX:
+	{
+		c->cputype = CPU_XLP;
+
+		c->isa_level = MIPS_CPU_ISA_M64R2;
+		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
+
+		c->tlbsize = ((read_c0_config6() >> 16 ) & 0xffff) + 1;
+		__cpu_name[cpu] = (const char *)get_cpu_info();
+
+		printk("Enabling XLP CPU (%s): pr id 0x%x  smp id %d\n",
+		       cpu_name_string(), c->processor_id, cpu);
+	}
+	break;
+	default:
+		c->isa_level = MIPS_CPU_ISA_M64R2;
+		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
+
+		c->tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+
+		c->cputype = CPU_XLP;
+		__cpu_name[cpu] = "Netlogic XLP";
+		printk(KERN_INFO "Unknown Netlogic chip id [%02x]!\n",
+		       c->processor_id);
+		break;
+
+	}
+}
+#endif /* CONFIG_NLM_XLP */
 
 #ifdef CONFIG_64BIT
 /* For use by uaccess.h */
diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S
index bdbcfe2..03a514c 100644
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -29,6 +29,47 @@
 #include <asm/mach-netlogic/kernel-entry-init.h>
 #include <asm/mach-generic/kernel-entry-init.h>
 
+#ifndef CONFIG_NLM_XLP
+	/*
+	 * inputs are the text nasid in t1, data nasid in t2.
+	 */
+	.macro MAPPED_KERNEL_SETUP_TLB
+#ifdef CONFIG_MAPPED_KERNEL
+	/*
+	 * This needs to read the nasid - assume 0 for now.
+	 * Drop in 0xffffffffc0000000 in tlbhi, 0+VG in tlblo_0,
+	 * 0+DVG in tlblo_1.
+	 */
+	dli	t0, 0xffffffffc0000000
+	dmtc0	t0, CP0_ENTRYHI
+	li	t0, 0x1c000		# Offset of text into node memory
+	dsll	t1, NASID_SHFT		# Shift text nasid into place
+	dsll	t2, NASID_SHFT		# Same for data nasid
+	or	t1, t1, t0		# Physical load address of kernel text
+	or	t2, t2, t0		# Physical load address of kernel data
+	dsrl	t1, 12			# 4K pfn
+	dsrl	t2, 12			# 4K pfn
+	dsll	t1, 6			# Get pfn into place
+	dsll	t2, 6			# Get pfn into place
+	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _CACHE_CACHABLE_COW) >> 6)
+	or	t0, t0, t1
+	mtc0	t0, CP0_ENTRYLO0	# physaddr, VG, cach exlwr
+	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _PAGE_DIRTY|_CACHE_CACHABLE_COW) >> 6)
+	or	t0, t0, t2
+	mtc0	t0, CP0_ENTRYLO1	# physaddr, DVG, cach exlwr
+	li	t0, 0x1ffe000		# MAPPED_KERN_TLBMASK, TLBPGMASK_16M
+	mtc0	t0, CP0_PAGEMASK
+	li	t0, 0			# KMAP_INX
+	mtc0	t0, CP0_INDEX
+	li	t0, 1
+	mtc0	t0, CP0_WIRED
+	tlbwi
+#else
+	mtc0	zero, CP0_WIRED
+#endif
+	.endm
+#endif /* CONFIG_NLM_XLP */
+
 	/*
 	 * For the moment disable interrupts, mark the kernel mode and
 	 * set ST0_KX so that the CPU does not spit fire when using
@@ -107,8 +148,9 @@ FEXPORT(__kernel_entry)
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
 
+#ifdef CONFIG_NLM_XLP
 	MAPPED_KERNEL_SETUP_TLB
-
+#endif
 	kernel_entry_setup			# cpu specific setup
 
 	setup_c0_status_pri
diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index d9f7ee1..e9699e9 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -234,8 +234,9 @@ static void kgdb_call_nmi_hook(void *ignored)
 	kgdb_nmicallback(raw_smp_processor_id(), NULL);
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/interrupt.h>
+#include <linux/irqreturn.h>
 DEFINE_SPINLOCK(nlm_kgdb_lock);
 
 void nlm_kgdb_smp_hook(void)
@@ -266,7 +267,7 @@ void nlm_kgdb_call_nmi_hook(void)
 
 void kgdb_roundup_cpus(unsigned long flags)
 {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_kgdb_smp_hook();
 	return;
 #else
@@ -330,12 +331,12 @@ void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
 	regs->cp0_epc = pc;
 }
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 extern void nlm_common_flush_l1_icache_ipi(void *);
 extern void nlm_common_flush_l1_caches_ipi(void *);
 #endif
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs)
 {
 	//int cpu = smp_processor_id();
@@ -447,7 +448,7 @@ static int kgdb_mips_notify(struct notifier_block *self, unsigned long cmd,
 			regs->cp0_epc += 4;
 
 	/* In SMP mode, __flush_cache_all does IPI */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_common_flush_l1_icache_ipi(NULL);
 #else
 	local_irq_enable();
diff --git a/arch/mips/kernel/nlm_fs_handler.S b/arch/mips/kernel/nlm_fs_handler.S
index 670c032..5c47f08 100644
--- a/arch/mips/kernel/nlm_fs_handler.S
+++ b/arch/mips/kernel/nlm_fs_handler.S
@@ -31,7 +31,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/stackframe.h>
 #include <asm/asm-offsets.h>
 
-#include <asm/netlogic/perf_ctr.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/nlm_fs.h>
 
@@ -385,6 +384,12 @@ NESTED(nlm_fs_msg_read, PT_SIZE, sp)
 	fs_eret
 END(nlm_fs_msg_read)
 
+#define CP0_PERF_CTR            CP0_PERFORMANCE
+#define PERF_CTR_EVENT0         0
+#define PERF_CTR_EVENT0_VALUE   1
+#define PERF_CTR_EVENT1         2
+#define PERF_CTR_EVENT1_VALUE   3
+
 NESTED(nlm_fs_perf_ctr_start, PT_SIZE, sp)
 
 	/* reset value counters */
diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c
index 53b944b..87f1974 100644
--- a/arch/mips/kernel/ptrace.c
+++ b/arch/mips/kernel/ptrace.c
@@ -45,7 +45,9 @@ the header of the original work apply to this derived work.
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
 #include <asm/reg.h>
+#ifdef CONFIG_NLM_XLP
 #include <asm/cacheflush.h>
+#endif
 
 /*
  * Called by kernel/ptrace.c when detaching..
@@ -274,7 +276,7 @@ long arch_ptrace(struct task_struct *child, long request,
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
 	case PTRACE_PEEKTEXT: /* read word at location addr. */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		__flush_cache_all();
 		/* Fall through */
 #endif
@@ -409,7 +411,7 @@ long arch_ptrace(struct task_struct *child, long request,
 
 	/* when I and D space are separate, this will have to be fixed. */
 	case PTRACE_POKETEXT: /* write the word at location addr. */
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 		__flush_cache_all();
 		/* Fall through */
 #endif
diff --git a/arch/mips/kernel/r4k_switch.S b/arch/mips/kernel/r4k_switch.S
index 75abfe8..d4edd5b 100644
--- a/arch/mips/kernel/r4k_switch.S
+++ b/arch/mips/kernel/r4k_switch.S
@@ -97,7 +97,11 @@
 	move	ra,t1
 #endif /* CONFIG_MIPS_MT_SMTC */
 	mfc0	t1, CP0_STATUS		/* Do we really need this? */
+#ifdef CONFIG_NLM_XLP
 	li	a3, 0x4000ff01
+#else
+	li	a3, 0xff01
+#endif
 	and	t1, a3
 	LONG_L	a2, THREAD_STATUS(a1)
 	nor	a3, $0, a3
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 08c2108..fd6a633 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -41,9 +41,11 @@ the header of the original work apply to this derived work.
 #include <asm/smp-ops.h>
 #include <asm/prom.h>
 
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/debug.h>
 #include <asm/mach-netlogic/mmu.h>
+#endif /* CONFIG_NLM_XLP */
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
@@ -53,13 +55,6 @@ EXPORT_SYMBOL(cpu_data);
 struct screen_info screen_info;
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-extern unsigned long long nlm_vmips_highmem_start;
-#undef  HIGHMEM_START
-#define        HIGHMEM_START   (nlm_vmips_highmem_start)
-#endif
-
-
 /*
  * Despite it's name this variable is even if we don't have PCI
  */
@@ -98,7 +93,7 @@ static struct resource data_resource = { .name = "Kernel data", };
 void __init add_memory_region(uint64_t start, uint64_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
-#ifndef CONFIG_NUMA
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
 #endif
 
@@ -108,8 +103,8 @@ void __init add_memory_region(uint64_t start, uint64_t size, long type)
 		return;
 	}
 
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	/* For numa, we want to avoid merging memories from different nodes */
-#ifndef CONFIG_NUMA
 	/*
 	 * Try to merge with previous entry if any.  This is far less than
 	 * perfect but is sufficient for most real world cases.
@@ -587,7 +582,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
     
 	bootmem_init();
-#ifndef CONFIG_NUMA
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_NUMA)
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
 #endif
 	device_tree_init();
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index 203d885..2fb7fbc 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -102,8 +102,12 @@ enum {
 static u32 unaligned_instructions;
 static u32 unaligned_action;
 #else
+#ifdef CONFIG_NLM_XLP
+#define unaligned_action UNALIGNED_ACTION_SHOW
+#else
 #define unaligned_action UNALIGNED_ACTION_QUIET
 #endif
+#endif
 extern void show_registers(struct pt_regs *regs);
 
 #ifdef __BIG_ENDIAN
@@ -1565,6 +1569,14 @@ asmlinkage void do_ade(struct pt_regs *regs)
 		goto sigbus;
 	if (unaligned_action == UNALIGNED_ACTION_SIGNAL)
 		goto sigbus;
+#ifdef CONFIG_NLM_XLP
+	else if (unaligned_action == UNALIGNED_ACTION_SHOW) {
+		printk("[%s]: Killing process (%s) which is using ualigned accesses!\n",
+		       __FUNCTION__, current->comm);
+		show_registers(regs);
+		goto sigbus;
+	}
+#endif
 
 	/*
 	 * Do branch emulation only if we didn't forward the exception.
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index 4f93018..17f341b 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -6,14 +6,8 @@
 #undef mips
 #define mips mips
 OUTPUT_ARCH(mips)
-
-#ifdef PHYSADDR
-ENTRY(phys_entry)
-#define AT_LOCATION AT(PHYSADDR)
-#else
-ENTRY(kernel_entry)
+#ifdef CONFIG_NLM_XLP
 #define AT_LOCATION
-#endif
 
 PHDRS {
 	text PT_LOAD AT_LOCATION FLAGS(7);	/* RWX */
@@ -23,6 +17,14 @@ PHDRS {
 #ifdef PHYSADDR
 phys_entry = kernel_entry - LOADADDR + PHYSADDR;
 #endif
+ENTRY(phys_entry)
+#else /* CONFIG_NLM_XLP */
+ENTRY(kernel_entry)
+PHDRS {
+	text PT_LOAD FLAGS(7);	/* RWX */
+	note PT_NOTE FLAGS(4);	/* R__ */
+}
+#endif /* CONFIG_NLM_XLP */
 
 #ifdef CONFIG_32BIT
 	#ifdef CONFIG_CPU_LITTLE_ENDIAN
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index 6d214e1..6978edf 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -43,12 +43,6 @@ the header of the original work apply to this derived work.
 static unsigned int icache_linesz;
 static unsigned int icache_lines;
 
-#ifdef CONFIG_NLM_VMIPS
-extern void nlm_vmips_temp_xkphys_tlb_add(phys_t start, phys_t end, int *tlbs, int *tlbe);
-extern void nlm_vmips_wired_entry_remove(int index);
-#endif
-
-
 #define cacheop(op, base) __asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
 
 #define cacheop_extable(op, base) do {                    \
@@ -512,11 +506,6 @@ static void nlm_common_local_flush_icache_range_paddr(phys_t start, phys_t end)
 	unsigned long flags;
 	phys_t temp;
 #endif
-#ifdef CONFIG_NLM_VMIPS
-	int tlbs = 0, tlbe = 0;
-	nlm_vmips_temp_xkphys_tlb_add(start, end, &tlbs, &tlbe);
-#endif
-
 #ifdef CONFIG_NLM_XLP
 	int sets_per_way, niter, i;
 	uint64_t mask;
@@ -545,11 +534,6 @@ static void nlm_common_local_flush_icache_range_paddr(phys_t start, phys_t end)
 	disable_KX(flags);
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-	for(;tlbe >= tlbs; tlbe--)
-        nlm_vmips_wired_entry_remove(tlbe);
-
-#endif
 	cacheop_sync_istream();
 }
 
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 3e77374..09a1f0a 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -216,12 +216,13 @@ void __cpuinit cpu_cache_init(void)
 
 		tx39_cache_init();
 	}
+#ifdef CONFIG_NLM_XLP
 	if (cpu_has_nlm_cache) {
 		extern void __weak ld_mmu_xlr(void);
 
 		ld_mmu_xlr();
 	}
-
+#endif
 	if (cpu_has_octeon_cache) {
 		extern void __weak octeon_cache_init(void);
 
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index 2e4274b..1eac431 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -44,7 +44,7 @@ the header of the original work apply to this derived work.
 	nop
 	nop
 	nop
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 
 	/* If some other cpu is already in the handler
 	 * just wait... */
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 8df5264..0f03457 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -27,7 +27,7 @@ the header of the original work apply to this derived work.
 #include <asm/mmu_context.h>
 #include <asm/pgtable.h>
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/mips-exts.h>
 #include <asm/mach-netlogic/mmu.h>
 #endif
@@ -79,11 +79,6 @@ extern void build_tlb_refill_handler(void);
 
 #endif
 
-#ifdef CONFIG_NLM_VMIPS
-#define UNIQUE_VMIPS_ENTRYHI(idx)  ((1ULL << 63) + (1ULL << 40) + ((idx) << (PAGE_SHIFT + 1)) + ( 1 << 8))
-extern int nlm_vmips_max_wired_entries;
-#endif
-
 void local_flush_tlb_all(void)
 {
 	unsigned long flags, config6_flags __maybe_unused;
@@ -106,11 +101,7 @@ void local_flush_tlb_all(void)
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
-#else
-        __write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(entry)));
-#endif
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -177,11 +168,7 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-				__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -226,11 +213,7 @@ void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-			__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -267,11 +250,7 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -306,11 +285,7 @@ void local_flush_tlb_one(unsigned long page)
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
-#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-#else
-		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
-#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -520,23 +495,13 @@ static int __init set_ntlb(char *str)
 
 __setup("ntlb=", set_ntlb);
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 extern void nlm_common_tlb_init(void);
 
 void nlm_tlb_stats_init(void)
 {
 	nlm_write_os_scratch_2(0ULL);
 }
-
-#ifdef CONFIG_HUGETLBFS
-void nlm_tlb_entrylo0_mask_init(void);
-void nlm_tlb_entrylo0_mask_init()
-{
-	unsigned long long mask = ~(((1ULL<<HUGETLB_PAGE_ORDER)-1)<<6);
-	nlm_write_os_scratch_3(mask);
-}
-#endif
-
 #endif
 
 void __cpuinit tlb_init(void)
@@ -549,19 +514,17 @@ void __cpuinit tlb_init(void)
 	 *     be set to fixed-size pages.
 	 */
 	write_c0_pagemask(PM_DEFAULT_MASK);
-
-#if defined(CONFIG_NLM_VMIPS)
-	if(ntlb && ((current_cpu_data.tlbsize-ntlb) < nlm_vmips_max_wired_entries))
-		ntlb = current_cpu_data.tlbsize - nlm_vmips_max_wired_entries;
+#if !defined(CONFIG_MAPPED_KERNEL)
+	write_c0_wired(0);
 #endif
 
+
 	if (current_cpu_type() == CPU_R10000 ||
 	    current_cpu_type() == CPU_R12000 ||
 	    current_cpu_type() == CPU_R14000)
 		write_c0_framemask(0);
 
-#if !defined(CONFIG_MAPPED_KERNEL)
-	write_c0_wired(0);
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_MAPPED_KERNEL)
 	write_c0_framemask(0);
 #endif
 
@@ -594,14 +557,8 @@ void __cpuinit tlb_init(void)
 			printk("Ignoring invalid argument ntlb=%d\n", ntlb);
 	}
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLP
 	nlm_tlb_stats_init();
-
-#ifdef CONFIG_HUGETLBFS
-	nlm_tlb_entrylo0_mask_init();
 #endif
-
-#endif
-
 	build_tlb_refill_handler();
 }
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index db4c5bc..e30155e 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -1,10 +1,10 @@
 config NLM_COMMON
-	bool 
+	bool
 
 config NLM_XLR
-	select GENERIC_HARDIRQS_NO__DO_IRQ
-	select FDT
-	select NLM_ATOMICS
+	bool
+
+config NLMCOMMON
 	bool
 
 config NLM_XLP
@@ -21,138 +21,28 @@ config NLM_XLP_A0_WORKAROUNDS
 
 config NLMCOMMON_VM_DEBUG
 	bool "Debug VM System"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 
 config NLMCOMMON_USERSEGV_DEBUG
 	bool "Debug User process SEGV crash"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 
 config NLMCOMMON_SMP_PREFIX
 	bool "Prefix the cpu number for every printk"
-	depends on NLM_COMMON
-	default y
-
-config NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-        bool "Enable Shared TLB in each CPU core"
-	depends on NLM_XLR
-	default n
-	help
-		This option enables the sharing of TLBs by all the threads in core.
-		
-
-config NLMCOMMON_MAC
-	bool "Enable On-Chip Networking support"
-	depends on NLM_XLR
-	default y
-
-config NLMCOMMON_PCIX_GEN_DRIVER
-	bool
-
-config NLMCOMMON_IP_OVER_PCI
-        bool "Enable IP-Over-Pci Networking Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_BOOT_OVER_PCI
-        bool "Enable Boot-Over-Pci Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_CONSOLE_OVER_PCI 
-        bool "Enable Console Over PCI Support"
-        depends on NLM_XLR
-	select NLMCOMMON_PCIX_GEN_DRIVER
-        default n
-
-config NLMCOMMON_SPI4
-        bool 'Support for on-chip SPI4 interfaces'
-        depends on NLM_XLR
-        default y
-        help
-          With the Vitesse SPI4 daughter card, this driver will abstract the
-          20 SPI4 channels as Gigabit ethernet interfaces.
-
-config NLMCOMMON_PSB
-	bool "Enable support for ATX eval board bootloader"
-
-config NLMCOMMON_MSGRING_NAPI
-	bool "XLR/XLS message ring NAPI"
-	depends on NLM_XLR
-	default y
-	help
-	  NAPI is a new driver API designed to reduce CPU and interrupt load
-	  when the driver is receiving lots of packets. This option enables 
-	  NAPI implementation for XLR/XLS message ring receive path.
-
-	  See <file:Documentation/networking/NAPI_HOWTO.txt> for more
-	  information.
-
-	  If in doubt, say N.
-
-
-config NLMCOMMON_HW_BUFFER_MGMT
-	bool "Enable support for network buffer recycling via hardware"
-	depends on NLM_XLR
+	depends on NLMCOMMON
 	default y
-	help
-	  Experimental addition to GMAC functionality allowing "recycling" of 
-          packet buffers by requesting HW to queue free elements upon Tx-complete 
-          back to the Rx free list.
-          This type of performance ehancement is important to forwarder-like
-          applications where fast path should stay as lean as possible.
-
-	  If in doubt, say N.
-
-
-config NLMCOMMON_IP_FLOW_AFFINITY
-	bool "Enable support for IP flow affinity"
-	depends on NLM_XLR
-	default n
-	help
-	  Experimental feature of GMAC driver guranteeing that IP flows are processed 
-          on logical CPUs corresponding to buckets assigned by packet classifier engine.
-          E.g. for XLR core #X, packets arriving to buckets 0 & 4 are processed by thread 0,
-          packets arriving to buckets 1 & 5 are processed by thread 1 and so on..
-          Such feature might be important for applications which require IP flows 
-          be seen on one logcal CPUs. Use of this feature involves performance cost.
-
-	  If in doubt, say N.
-
-config NLMCOMMON_IP_QUEUE_AFFINITY
-	bool "Enable multiprocess support for IP Queues"
-	depends on NLM_XLR && IP_NF_QUEUE
-	default n
-	help
-	  Experimental feature extending IP Queues by allowing multiple user space 
-          processes to receive IP packets from the kernel. Client processes should come 
-          with CPU affinity set to single logical CPU and will get packets which are 
-          recieved and processed by network stack on that logical CPU.
-
-          Example:
-
-               Let's Process_1 has CPU affinity set to x
-               Let's Process_2 has CPU affinity set to y
-
-               Packet1 --> Interrupt on CPU x --> IP Queues --> Process_1
-               Packet1 --> Interrupt on CPU y --> IP Queues --> Process_2
-
-          This feature could be useful for packet processing architectures requiring user 
-          space handling of multiple IP flows.
-
-          If in doubt, say N.
 
 config MAPPED_KERNEL
-       bool "Mapped kernel" 
+       bool "Mapped kernel"
+       depends on NLM_XLP
        default y
        help
-         Select this option if you want the kernel's code and data to 
-         be in mapped memory.  The kernel will be mapped using a 
+         Select this option if you want the kernel's code and data to
+         be in mapped memory.  The kernel will be mapped using a
          single wired TLB entry, thus reducing the number of
-         available TLB entries by one.  Kernel modules will be able 
+         available TLB entries by one.  Kernel modules will be able
          to use a more efficient calling convention.
 
 config PHYS_LOAD_ADDRESS
@@ -163,26 +53,26 @@ config PHYS_LOAD_ADDRESS
          The physical load address reflected as the program header
          physical address in the kernel ELF image.
 
-config NLM_COMMON_LOAD_ADDRESS
+config NLMCOMMON_LOAD_ADDRESS
 	hex "Netlogic Linux kernel start address"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default "0xffffffffc4000000"
 	help
 	  This is start address for the linux kernel. Default value
-          should be good for most of the applications unless specified 
+          should be good for most of the applications unless specified
           explicitly: e.g. running Netlogic ToE requires kernel to be linked
 	  at address 0xffffffff86000000.
  
 config NLMCOMMON_PTP_SUPPORT
 	bool "1588PTP Support(enables prepad)"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	 Support for 1588 timing feature. Timestamps Rx/Tx packets. 
          
 config NLM_VMIPS
 	bool "Virtual Mips support"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	 The kseg0 and kseg1 unmapped access will become mapped. 
@@ -194,7 +84,7 @@ config KSEG2_LOWMEM
 
 config NLM_NAS
 	bool "Enable NAS optimizations"
-	depends on NLM_COMMON
+	depends on NLMCOMMON
 	default n
 	help
 	  This options enables some optimizations done for XLS NAS solutions
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 6c0e5f6..53ffad1 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -1,5 +1,5 @@
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
-obj-y :=   cpu_proc.o memory.o bootinfo.o
+obj-$(CONFIG_NLM_XLP) :=   cpu_proc.o memory.o bootinfo.o
 
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_sys.o nlm_evp_cpld.o nlm_hal_cpu_info.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_eeprom.o fdt_helper.o
@@ -14,14 +14,15 @@ obj-y					+= cortina_cs34x7/nlm_cortina_cs34x7.o cortina_cs34x7/nlm_cortina_cs34
 					   cortina_cs34x7/nlm_cortina_cs34x7_p12.o
 EXTRA_CFLAGS += -DNLM_CORTINA_SUPPORT
 endif
-obj-$(CONFIG_RAPIDIO)             	+= srio.o
-obj-$(CONFIG_NLMCOMMON_IP_OVER_PCI) 	+= dma.o
+
+ifdef CONFIG_NLM_XLP
 obj-$(CONFIG_SMP)                 	+= smp.o
+endif
 
 EXTRA_AFLAGS := $(CFLAGS)
 
 clean-files += nlm_hal_fmn_config.o nlm_hal_cpu_info.o
 clean-files += nlm_hal.o
-clean-files += srio.o dma.o smp.o cpu_proc.o
+clean-files += smp.o cpu_proc.o
 clean-files += nlm_hal.c
 
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 09e7a73..515b84c 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -39,10 +39,6 @@
 
 extern struct proc_dir_entry *nlm_root_proc;
 
-#ifndef CONFIG_BTLB_LOADER
-extern void nlm_update_tlb_stats(void *ignored);
-#endif
-
 struct nlm_cpu_stat {
 	unsigned long long msgring_pic_int;
 	unsigned long long msgring_int;
@@ -124,11 +120,6 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 	int len = 0;
 	off_t begin = 0;
 
-#ifndef CONFIG_BTLB_LOADER
-	/* Update the TLB stats from other CPUs */
-	on_each_cpu(nlm_update_tlb_stats, NULL, 1);
-#endif
-
 	len += sprintf(page + len, "CPU Frequency: %u HZ\n", (unsigned int)mips_hpt_frequency);
 	if (!proc_pos_check(&begin, &len, off, count))
 		goto out;
@@ -199,14 +190,6 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 static int nlm_cpu_proc_init(void)
 {
 	struct proc_dir_entry *entry;
-#ifdef CONFIG_NLM_XLR
-	entry = create_proc_read_entry("xlr_cpu", 0 /* def mode */ ,
-				       nlm_root_proc/* parent */ ,
-				       nlm_cpu_proc_read
-				       /* proc read function */ ,
-				       0	/* no client data */
-		);
-#endif
 #ifdef CONFIG_NLM_XLP
 	entry = create_proc_read_entry("xlp_cpu", 0 /* def mode */ ,
 				       nlm_root_proc/* parent */ ,
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 4d9a0a7..42329dc 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -8,6 +8,8 @@
 #include <asm/mach-netlogic/kernel-entry-init.h>
 #include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
+#define SET_MIPS64 .set mips64r2
+
 	.macro  prog_c0_status set clr
 	.set 	push
 	mfc0    t0, CP0_STATUS
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 0731606..cd2d890 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -32,7 +32,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/module.h>
 #include <linux/timer.h>
 
-#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
@@ -248,7 +247,6 @@ EXPORT_SYMBOL(nlm_xlp_register_vc_handler);
  ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
-	unsigned long mflags;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
 	struct msgstn_handler *handler = 0;
@@ -272,7 +270,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	irq_enter();
 
-        msgrng_access_enable(mflags);
 	cycles = read_c0_count();
 
 	for (;;) {
@@ -328,8 +325,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	/* Clear VC interrupt status by writing 1s */
 	xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
 
-        msgrng_access_disable(mflags);
-
 	irq_exit();
 }
 
@@ -370,7 +365,6 @@ void xlp_poll_vc0_messages(void)
         unsigned int msg_status1 = 0, vc_empty_status = 0;
         int loop = 0;
         int pop_vc_mask = 0x1;
-	unsigned long mflags;
 #if 0
 	if (hard_smp_processor_id() != 0)
 		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
@@ -378,7 +372,6 @@ void xlp_poll_vc0_messages(void)
 			       __FUNCTION__,xlp_read_status1());
 #endif
         msg0 = msg1 = msg2 = msg3 = 0;
-        msgrng_access_enable(mflags);
         for (loop = 0; loop < 16; loop++) {
                 /* Read latest VC empty mask */
                 msg_status1 = xlp_read_status1();
@@ -393,7 +386,6 @@ void xlp_poll_vc0_messages(void)
                 (handler->action)(vc, src_id, size, code,
                                 msg0, msg1, msg2, msg3, handler->dev_id);
         }
-        msgrng_access_disable(mflags);
 }
 EXPORT_SYMBOL(xlp_poll_vc0_messages);
 
@@ -500,9 +492,7 @@ void enable_msgconfig_int(void)
 	uint32_t flags;
 
 	/* Need write interrupt vector to cp2 msgconfig register */
-	msgrng_access_enable(flags);
 	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING);
-	msgrng_access_disable(flags);
 }
 
 /*
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 76fe379..4422e43 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -35,7 +35,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/cacheops.h>
 
 #include <asm/netlogic/xlp.h>
-#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/xlp_hal_pic.h>
@@ -137,7 +136,7 @@ void nlm_cpus_done(void)
 {
 	int node = 0;
 	extern void *fdt;
-	nlm_hal_fmn_init(fdt, (void *)(long)node);
+	nlm_hal_fmn_init(fdt, node);
 	
 	/* Enable vc interupts for the online cpus */
 	nlm_enable_vc_intr();
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index 2a0bb6d..941304f 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -40,18 +40,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 extern spinlock_t xlp_pic_lock;
 
-#ifndef CONFIG_NLMCOMMON_MAC
-void nlm_common_user_mac_update_time(void)
-{
-}
-void nlm_common_user_mac_update_ktime(void)
-{
-}
-#else
-extern void nlm_common_user_mac_update_time(void);
-extern void nlm_common_user_mac_update_ktime(void);
-#endif
- 
 void save_epc(unsigned long *epc)
 {
 	__asm__ __volatile__(".set push\n"
@@ -63,60 +51,11 @@ void save_epc(unsigned long *epc)
 extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
 					 struct pt_regs *regs);
 #endif
-void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
-{
-//	int cpu = smp_processor_id();
-	int cpu = hard_smp_processor_id();
-
-#ifdef CONFIG_NLM_WATCHDOG
-        pic_reg_t *mmio = nlm_hal_pic_offset();
-
-	/* ack the watchdog */
-	/* Need to choose (?) the right heartbeat reg (0/1) and right chunk */
-	nlm_hal_write_pic_reg(mmio, PIC_WD_HEARTBEAT_0(0), 1 << cpu_logical_map(cpu));
-#endif
-
-#if defined (CONFIG_OPROFILE)
-	int    perfctr_overflow = 0;
-#endif
-
-#ifdef CONFIG_NLM_WATCHDOG
-	/* ack the watchdog */
-	netlogic_write_reg(mmio, 0x0c, 1 << cpu_logical_map(cpu));
-#endif
-
-	if (irq != XLP_IRQ_TIMER) {
-		printk("[%s]:cpu_%d: bad timer irq = %x\n", __FUNCTION__, cpu, irq);
-		BUG();
-	}
-
-#if defined (CONFIG_OPROFILE)
-    perfctr_overflow = ((read_c0_cause() >> 26) & 0x1);
-
-    if(perfctr_overflow == 0)
-#endif
-    {
-        do_IRQ(irq);
-
-        if (cpu == 0) {
-            nlm_common_user_mac_update_time();
-	    nlm_common_user_mac_update_ktime();
-        }
-    }
-
-#if defined (CONFIG_OPROFILE)
-	if (perfctr_overflow) {
-			nlm_common_oprofile_int_handler (irq, NULL, regs);
-		}
-#endif
-
-}
-
 /* PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit 
    counter is sufficient
    */
 #define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
-cycle_t xlr_hpt_read(void)
+cycle_t xlp_hpt_read(void)
 {
 	uint32_t counter;
 	pic_reg_t *mmio = nlm_hal_pic_offset();
@@ -126,7 +65,7 @@ cycle_t xlr_hpt_read(void)
 
 int read_current_timer(unsigned long *timer_val)
 {
-	*timer_val = xlr_hpt_read();
+	*timer_val = xlp_hpt_read();
 	return 0;
 }
 
diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index d1b5b78..061a8f4 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -15,6 +15,5 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
-oprofile-$(CONFIG_NLM_XLR)		+= op_model_mips_xlr.o
 oprofile-$(CONFIG_NLM_XLP)		+= op_model_mips_xlp.o
 oprofile-$(CONFIG_CPU_LOONGSON2)	+= op_model_loongson2.o
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 3b1fa0c..6ef9696 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -919,87 +919,3 @@ struct pci_fixup pcibios_fixups[] = {
 	{0}
 };
 
-
-/*
- * some ide specific io routines on PCI
- */
-#define pci_ide_phys_to_virt(x) (((x) - (xlp_io_resource.start)) + (unsigned long)pci_io_base )
-
-inline void nlm_ide_mm_insw(unsigned long port, void *addr, u32 count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		*(u16 *)addr = (readw((const volatile void *)v_port));
-		addr += 2;
-	}
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_insw);
-
-inline void nlm_ide_mm_insl(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		*(u32 *)addr = readl((const volatile void *) v_port);
-		addr += 4;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_insl);
-
-inline void nlm_ide_mm_outsw(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		writew(*(u16 *)addr, (volatile void *)v_port);
-		addr += 2;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_outsw);
-
-inline void nlm_ide_mm_outsl(unsigned long port, void *addr, unsigned int count)
-{
-	unsigned long v_port = pci_ide_phys_to_virt(port);
-	while (count--) {
-		writel(*(u32 *)addr, (volatile void *)v_port);
-		addr += 4;
-	}
-}
-EXPORT_SYMBOL(nlm_ide_mm_outsl);
-
-u8 nlm_ide_mm_inb (unsigned long port)
-{
-	return((u8)readb((const volatile void *)pci_ide_phys_to_virt(port)));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inb);
-u16 nlm_ide_mm_inw (unsigned long port)
-{
-	return ((u16) (readw((const volatile void *)pci_ide_phys_to_virt(port))));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inw);
-/* Not part of hwif anymore; remove static declaration */
-u32 nlm_ide_mm_inl (unsigned long port)
-{
-	return ((u32)readl((const volatile void *)pci_ide_phys_to_virt(port)));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_inl);
-void nlm_ide_mm_outb (u8 value, unsigned long port)
-{
-	writeb(value, (volatile void *)pci_ide_phys_to_virt(port));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_outb);
-void nlm_ide_mm_outw (u16 value, unsigned long port)
-{
-	writew(value, (volatile void *)pci_ide_phys_to_virt((u64)port));
-}
-
-EXPORT_SYMBOL(nlm_ide_mm_outw);
-/* Not part of hwif anymore; remove static declaration */
-void nlm_ide_mm_outl (u32 value, unsigned long port)
-{
-	writel((value), (volatile void *)pci_ide_phys_to_virt(port));
-}
-EXPORT_SYMBOL(nlm_ide_mm_outl);
diff --git a/arch/mips/xen/Kconfig b/arch/mips/xen/Kconfig
index c50136f..9f6ca9b 100644
--- a/arch/mips/xen/Kconfig
+++ b/arch/mips/xen/Kconfig
@@ -6,7 +6,7 @@ config XEN
 	bool "Xen guest support"
 	select PARAVIRT
 	select PARAVIRT_CLOCK
-	depends on RMI_XLR || RMI_XLP
+	depends on NLM_XLP
 	help
 	  This is the Linux Xen port.  Enabling this will allow the
 	  kernel to boot in a paravirtualized environment under the
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 55e7924..dfd2731 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -248,18 +248,6 @@ config NWFLASH
 
 source "drivers/char/hw_random/Kconfig"
 
-config NETLOGIC_RMIOS_DEBUGGER
-	bool "RMIOS Debugger support"
-	depends on NLM_COMMON!=n
-	default n
-	---help---
-	This module provides debugging facility for rmios images loaded on the
-	board, before loading linux image. Network interface is used to
-	communicate with remote gdb host. GDB clients communicate using the
-	network connection. Multiple rmios sessions can be run on different
-	virtual cpus. These gdb capable rmios sessions can be debugged
-	remotely by connecting to these session remotely through gdb.
-
 config NVRAM
 	tristate "/dev/nvram support"
 	depends on ATARI || X86 || (ARM && RTC_DRV_CMOS) || GENERIC_NVRAM
@@ -628,11 +616,4 @@ config NLM_XLP_DMA
 	    If you want this as a module, choose M here. The driver
 	    will be called nlm_xlp_dma.ko
 
-config RMICDE
-	tristate "RMI Compression/Decompression Engine"
-	depends on NLM_COMMON!=n
-	default n
-	help
-	  The CDE allows deflate/inflate through hardware
-
 endmenu
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7eddbea..61abf9d 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the kernel character device drivers.
 #
 
-EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL 
+EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
 
 obj-y				+= mem.o random.o
 obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 7296bac..3729148 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -322,17 +322,6 @@ config I2C_AT91
 	  the latency to fill the transmission register is too long. If you
 	  are facing this situation, use the i2c-gpio driver.
 
-config I2C_BK3220
-        tristate "PalmChip BK-3220"
-        depends on I2C && EXPERIMENTAL
-        select I2C_ALGOPALM
-        help
-          This supports the BK-3220 I2C adapter.  Say Y if you own
-          such an adapter.
-
-          This support is also available as a module.  If so, the module
-          will be called i2c-bk3220.
-
 config I2C_AU1550
 	tristate "Au1550/Au1200/Au1300 SMBus interface"
 	depends on MIPS_ALCHEMY
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 1526295..989f1c3 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -46,7 +46,6 @@ obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
-obj-$(CONFIG_MTD_XLR)           += xlr-flash.o
 obj-$(CONFIG_MTD_XLP)           += xlp-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
 obj-$(CONFIG_MTD_LATCH_ADDR)	+= latch-addr-flash.o
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 04a0ea7..3835321 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -168,12 +168,6 @@ config NETCONSOLE
 	If you want to log kernel messages over the network, enable this.
 	See <file:Documentation/networking/netconsole.txt> for details.
 
-config NLM_VNET
-	bool "Virtual Networking for CRF"
-	---help---
-	This enables internal network for CRF domains using shared memory and
-	event queues.
-
 config NETCONSOLE_DYNAMIC
 	bool "Dynamic reconfiguration of logging targets"
 	depends on NETCONSOLE && SYSFS && CONFIGFS_FS && \
@@ -362,13 +356,4 @@ config VMXNET3
 
 source "drivers/net/hyperv/Kconfig"
 
-config XLP_NAE 
-	tristate "netlogic microsystems xlp nae mac driver"
-#	depends on m
-	---help---
-	  This driver supports netlogic xls/xlr/xlp soc network driver. 
-	  For more information on xls/xlr/xlp mac driver, please visit
-
-	  <http://support.netlogicmicro.com/support>
-
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 27a9e8b..04f3c58 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -27,11 +27,7 @@ obj-$(CONFIG_MDIO) += mdio.o
 obj-$(CONFIG_NET) += Space.o loopback.o
 obj-$(CONFIG_NETCONSOLE) += netconsole.o
 obj-$(CONFIG_PHYLIB) += phy/
-ifdef CONFIG_NLM_COMMON
-obj-$(CONFIG_RIONET) += nlm_rionet.o
-else
 obj-$(CONFIG_RIONET) += rionet.o
-endif
 obj-$(CONFIG_NET_TEAM) += team/
 obj-$(CONFIG_TUN) += tun.o
 obj-$(CONFIG_VETH) += veth.o
diff --git a/drivers/pci/proc.c b/drivers/pci/proc.c
index 838ecd0..0dfcfa0 100644
--- a/drivers/pci/proc.c
+++ b/drivers/pci/proc.c
@@ -403,7 +403,7 @@ int pci_proc_attach_device(struct pci_dev *dev)
 		return -EACCES;
 
 	if (!bus->procdir) {
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLMCOMMON
 		/* 
 		   create /proc entries in "%02x" format at all times.
 		   Otherwise, for HT, it will be created in "%04x:%02x" format
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index f3b75ec..e5d5487 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -1104,14 +1104,6 @@ config LANTIQ_WDT
 	help
 	  Hardware driver for the Lantiq SoC Watchdog Timer.
 
-config NLM_WATCHDOG
-        tristate "Netlogic XL* Hardware Watchdog"
-        depends on WATCHDOG && NLM_COMMON
-        help
-          Hardware driver for the XL* watchdog. This is a watchdog timer
-          that will reboot the machine after a 60 second timer expired
-          and no process has written to /dev/watchdog during that time.
-
 # PARISC Architecture
 
 # POWERPC Architecture
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 8cf251c..a300b94 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -131,7 +131,6 @@ obj-$(CONFIG_PNX833X_WDT) += pnx833x_wdt.o
 obj-$(CONFIG_SIBYTE_WDOG) += sb_wdog.o
 obj-$(CONFIG_AR7_WDT) += ar7_wdt.o
 obj-$(CONFIG_TXX9_WDT) += txx9wdt.o
-obj-$(CONFIG_NLM_WATCHDOG) += nlm_common_wdt.o
 obj-$(CONFIG_OCTEON_WDT) += octeon-wdt.o
 octeon-wdt-y := octeon-wdt-main.o octeon-wdt-nmi.o
 obj-$(CONFIG_LANTIQ_WDT) += lantiq_wdt.o
-- 
1.8.4.93.g57e4c17

