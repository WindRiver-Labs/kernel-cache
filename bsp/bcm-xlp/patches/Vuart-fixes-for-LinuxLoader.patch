From b1e4ad6e0fd0ac26ad143c8dfda5f90030bbd1c9 Mon Sep 17 00:00:00 2001
From: Rahul Jain <rajain@netlogicmicro.com>
Date: Sat, 10 Dec 2011 21:40:43 +0530
Subject: [PATCH 311/565] Vuart fixes for LinuxLoader

Vuart fixes for LinuxLoader

Based on Broadcom SDK 2.3.

Signed-off-by: Rahul Jain <rajain@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c |   9 +--
 drivers/char/nlm_vuart.c         | 121 ++++++++++++++++++++++++++++-----------
 2 files changed, 92 insertions(+), 38 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 41e277e..cd16728 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -231,11 +231,11 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
-	int loop = 0;
 	int cpu = hard_smp_processor_id();
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
+	uint32_t napi_vc_mask;
 	msg0 = msg1 = msg2 = msg3 = 0;
-	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
+	napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
 	
 	if (irq == XLP_IRQ_MSGRING) {
                 /* normal message ring interrupt */
@@ -621,7 +621,8 @@ static void pic_init(void)
 		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
 		/* Use local scheduling and high polarity for all IRTs
 		 * Invalidate all IRTs, by default */
-		nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, xlp_rvec_from_irq(i), 1, 0, thread_mask);
+		//nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, xlp_rvec_from_irq(i), 1, 0, thread_mask);
+		nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, i, 1, 0, thread_mask);
 	}
 
 	/* On XLP, MSGRING config register is per hw-thread */
@@ -691,7 +692,7 @@ void nlm_enable_vc_intr(void)
 int xlp_fmn_poll(struct napi_struct *napi, int budget)
 {
 	int vc = 0;
-	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
+	uint32_t size = 0, code = 0, src_id = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
diff --git a/drivers/char/nlm_vuart.c b/drivers/char/nlm_vuart.c
index 0b0e778..e3a1f40 100644
--- a/drivers/char/nlm_vuart.c
+++ b/drivers/char/nlm_vuart.c
@@ -1,27 +1,31 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ( Netlogic ). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
 
 #include <linux/module.h>
 #include <linux/init.h>
@@ -36,27 +40,35 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/vmalloc.h>
 #include <linux/mman.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 #include <linux/device.h>
+#include <linux/mutex.h>
 
+#ifdef CONFIG_XEN
 #include <xen/interface/xen.h>
 #include <xen/grant_table.h>
 #include <asm/xen/hypercall.h>
+#endif
 
 #define VUART_MAJOR 251
 #define VUART_NAME "nlm_vuart"
 #define CASE1 1
 #define CASE2 2
 
+static DEFINE_MUTEX(vuart_mutex);
 static unsigned int counter = 0;
 static char string [128];
 static int data;
 
 DECLARE_WAIT_QUEUE_HEAD(vuart_wait);
 static int data_not_ready = 0;
+#ifdef CONFIG_XEN
 extern int gnttab_grant_foreign_access(domid_t domid, unsigned long frame, int readonly);
-extern void gnttab_update_service (uint32_t service_for_dom_id, uint32_t start_ref_id, 
-								   uint32_t nr_pages, uint64_t pfn, uint32_t service_id);
+extern void gnttab_update_service (uint32_t service_for_dom_id, uint32_t start_ref_id,
+				uint32_t nr_pages, uint64_t pfn, uint32_t service_id);
+#else
+static unsigned long uart_sharedcfg_base = (496 << 20);
+//static unsigned long uart_sharedcfg_size = (4 << 20);
+#endif
 
 static int vuart_open (struct inode *inode, struct file *file) {
 	return 0;
@@ -72,7 +84,7 @@ static ssize_t vuart_read (struct file *file, char *buf,
 	int len, err;
 
 	/*
-	 * check if we have data - if not, sleep wake up in 
+	 * check if we have data - if not, sleep wake up in
 	 * interrupt_handler
 	 */
 	while (data_not_ready)
@@ -135,9 +147,9 @@ static long vuart_compat_ioctl(struct file *filp, unsigned int cmd, unsigned lon
 {
 	unsigned long ret = -1;
 
-	lock_kernel();
+	mutex_lock(&vuart_mutex);
 	ret = vuart_ioctl(NULL, filp, cmd, arg);
-	unlock_kernel();
+	mutex_unlock(&vuart_mutex);
 
 	if (ret)
 		return -ENOIOCTLCMD;
@@ -145,6 +157,7 @@ static long vuart_compat_ioctl(struct file *filp, unsigned int cmd, unsigned lon
 	return ret;
 }
 
+#ifdef CONFIG_XEN
 #define NUM_VUARTS 32
 #define NLM_VUART_ID 100
 static unsigned long shared_page_paddr = 0;
@@ -169,21 +182,59 @@ static int vuart_mmap(struct file * filp, struct vm_area_struct * vma)
 		shared_page_paddr = (unsigned long) __pa(free_page);
 	}
 
-	if (remap_pfn_range (vma, (unsigned long) vma->vm_start, 
-						 shared_page_paddr >> PAGE_SHIFT, 
-						 1 << (PAGE_SHIFT + get_order (NUM_VUARTS/2 * PAGE_SIZE)), 
+	if (remap_pfn_range (vma, (unsigned long) vma->vm_start,
+						 shared_page_paddr >> PAGE_SHIFT,
+						 1 << (PAGE_SHIFT + get_order (NUM_VUARTS/2 * PAGE_SIZE)),
 						 vma->vm_page_prot))
 		return -EAGAIN;
 
 	return 0;
 }
+#else
+static int vuart_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+	unsigned long vm_size = vma->vm_end - vma->vm_start;
+
+	if (vma->vm_flags & VM_LOCKED)
+	{
+		printk("%s: VM_LOCKED flag is set \n", __func__);
+		return -EPERM;
+	}
+
+	vma->vm_flags |= (VM_RESERVED | VM_IO);
+
+        if (remap_pfn_range(vma, vma->vm_start, (uart_sharedcfg_base >> PAGE_SHIFT),
+			    vm_size, vma->vm_page_prot))
+	{
+		printk("%s: remap_pfn_range failed\n", __func__);
+		return -EAGAIN;
+	}
+
+	printk("[%s]: Linux Loader pbase=%#lx size=%#lx\n", __FUNCTION__, uart_sharedcfg_base, vm_size);
+
+	return 0;
+}
+
+static unsigned int vuart_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	unsigned int mask;
+
+	if (!filp->private_data) return -EINVAL;
+
+	mask = 0;
+
+	return mask;
+}
+#endif
 
 struct file_operations vuart_fops = {
 	.owner	      =	THIS_MODULE,
 	.read	      =	vuart_read,
 	.write	      =	vuart_write,
 	.mmap	      =	vuart_mmap,
-	.ioctl	      =	vuart_ioctl,
+#ifndef CONFIG_XEN
+	.poll	  =	vuart_poll,
+#endif
 	.compat_ioctl =	vuart_compat_ioctl,
 	.open	      =	vuart_open,
 	.release      =	vuart_release,
@@ -199,11 +250,13 @@ static int vuart_init (void)
 		return -EIO;
 	}
 
+	printk("[%s] Registered char device major=%d\n", __FUNCTION__, VUART_MAJOR);
 	return 0;
 }
 
 static void vuart_cleanup (void)
 {
+	printk("cleaning up module\n");
 	unregister_chrdev (VUART_MAJOR, VUART_NAME);
 }
 
-- 
1.8.4.93.g57e4c17

