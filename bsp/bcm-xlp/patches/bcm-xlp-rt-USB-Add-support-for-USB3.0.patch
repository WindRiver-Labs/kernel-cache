From b5b41c63e08a29117a8a5318f8f58f97da57667d Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Sun, 21 Oct 2012 00:22:47 +0530
Subject: [PATCH 1/6] bcm-xlp-rt: USB : Add support for USB3.0

Add support for USB3.0

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anurag.gopinath@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp.h     |   3 +
 arch/mips/include/asm/netlogic/xlp_irq.h |   2 +
 arch/mips/include/asm/netlogic/xlp_usb.h |  17 ++-
 arch/mips/netlogic/xlp/usb-init.c        | 182 +++++++++++++++++++++----------
 drivers/usb/core/hcd.c                   |  18 +++
 drivers/usb/host/xhci-pci.c              |   7 +-
 drivers/usb/host/xhci.h                  |  49 ++++++++-
 7 files changed, 210 insertions(+), 68 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index bd0ecca..f334f16 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -71,6 +71,9 @@
 #define XLP_DEVID_SPI           0x1017
 #define XLP_DEVID_MMC           0x1018
 #define XLP_DEVID_RIO		0x101B
+#define XLP_DEVID_XHCI0         0x101D
+#define XLP_DEVID_XHCI1         0x101E
+#define XLP_DEVID_XHCI2         0x101F
 
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index caf50ff..aa5f782 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -120,6 +120,8 @@ struct xlp_nodefn_struct {
 
 #define xlp_incr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, 1)
 #define xlp_decr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, -1)
+#define xlp_soc_pcidev_to_node(dev) ((u8)(PCI_SLOT(dev->devfn)/8))
+#define nlm_xlp_request_irq(node, irt)  xlp_irt_to_irq(node, irt)
 
 #endif		/* __ASSEMBLY__ */
 
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
index 063b3f2..fa57c13 100644
--- a/arch/mips/include/asm/netlogic/xlp_usb.h
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -54,17 +54,26 @@
 #define PIC_IRT_OHCI_2                  119
 #define PIC_IRT_OHCI_3                  120
 
-static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
+#define PIC_IRT_XHCI_0                  115
+#define PIC_IRT_XHCI_1                  116
+#define PIC_IRT_XHCI_2                  117
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+
+extern int xlp_usb_dev;
+
+static __inline__ uint32_t usb_reg_read(int node, int func, int regidx)
 {
 	volatile uint64_t mmio;
-	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+        mmio = nlm_hal_get_dev_base(node, 0, xlp_usb_dev, func);
 	return nlm_hal_read_32bit_reg(mmio, regidx);
 }
 
-static __inline__ void usb_reg_write(int node, int func, int regidx, int32_t val)
+static __inline__ void usb_reg_write(int node, int func, int regidx, uint32_t val)
 {
 	volatile uint64_t mmio;
-	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+        mmio = nlm_hal_get_dev_base(node, 0, xlp_usb_dev, func);
 	nlm_hal_write_32bit_reg(mmio, regidx, val);
 }
 
diff --git a/arch/mips/netlogic/xlp/usb-init.c b/arch/mips/netlogic/xlp/usb-init.c
index 9c401dd..7a3933d 100644
--- a/arch/mips/netlogic/xlp/usb-init.c
+++ b/arch/mips/netlogic/xlp/usb-init.c
@@ -39,75 +39,128 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
 
-/*
- * USB glue logic registers, used only during initialization
- */
-#define USB_CTL_0			0x01
-#define USB_PHY_0			0x0A
-#define USB_PHY_RESET			0x01
-#define USB_PHY_PORT_RESET_0		0x10
-#define USB_PHY_PORT_RESET_1		0x20
-#define USB_CONTROLLER_RESET		0x01
-#define USB_INT_STATUS			0x0E
-#define USB_INT_EN			0x0F
-#define USB_PHY_INTERRUPT_EN		0x01
-#define USB_OHCI_INTERRUPT_EN		0x02
-#define USB_OHCI_INTERRUPT1_EN		0x04
-#define USB_OHCI_INTERRUPT2_EN		0x08
-#define USB_CTRL_INTERRUPT_EN		0x10
-
-#define nlm_read_usb_reg(b, r)			nlm_read_reg(b, r)
-#define nlm_write_usb_reg(b, r, v)		nlm_write_reg(b, r, v)
-#define nlm_get_usb_pcibase(node, inst)		\
-	nlm_pcicfg_base(XLP_IO_USB_OFFSET(node, inst))
-#define nlm_get_usb_regbase(node, inst)		\
-	(nlm_get_usb_pcibase(node, inst) + XLP_IO_PCI_HDRSZ)
+#define PCI_MEM_BAR_0 0x4
+int xlp_usb_dev;
+int nlm_xlp_nativexhci;
 
 static void nlm_usb_intr_en(int node, int port)
 {
 	uint32_t val;
-	uint64_t port_addr;
 
-	port_addr = nlm_get_usb_regbase(node, port);
-	val = nlm_read_usb_reg(port_addr, USB_INT_EN);
+        val = usb_reg_read(node, port, USB_INT_EN);
 	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN |
-		USB_OHCI_INTERRUPT1_EN | USB_CTRL_INTERRUPT_EN	|
-		USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT2_EN;
-	nlm_write_usb_reg(port_addr, USB_INT_EN, val);
+		USB_OHCI_INTERRUPT1_EN | USB_OHCI_INTERRUPT2_EN;
+        usb_reg_write(node, port, USB_INT_EN, val);
+
 }
 
 static void nlm_usb_hw_reset(int node, int port)
 {
-	uint64_t port_addr;
 	uint32_t val;
 
 	/* reset USB phy */
-	port_addr = nlm_get_usb_regbase(node, port);
-	val = nlm_read_usb_reg(port_addr, USB_PHY_0);
+        val = usb_reg_read(node, port, USB_PHY_0);
 	val &= ~(USB_PHY_RESET | USB_PHY_PORT_RESET_0 | USB_PHY_PORT_RESET_1);
-	nlm_write_usb_reg(port_addr, USB_PHY_0, val);
+        usb_reg_write(node, port, USB_PHY_0, val);
 
 	mdelay(100);
-	val = nlm_read_usb_reg(port_addr, USB_CTL_0);
+        val = usb_reg_read(node, port, USB_CTL_0);
 	val &= ~(USB_CONTROLLER_RESET);
 	val |= 0x4;
-	nlm_write_usb_reg(port_addr, USB_CTL_0, val);
+        usb_reg_write(node, port, USB_CTL_0, val);
+}
+
+static void xlp_usb3_hw_start_controller(int node, int ctrl_no)
+{
+       volatile uint32_t val;
+        uint64_t base = nlm_hal_get_dev_base (node, 0, XLP_PCIE_USB3_DEV, ctrl_no);
+        uint64_t corebase;
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV);
+        val &= 0xfc0fffff;
+        val |= (0x27 << 20);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_REF_CLK);
+        val |= (1<<30);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_REF_CLK, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_TEST);
+        val &= 0xfffffffe;
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_TEST, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP_USB3_CTL);
+        usb_reg_write(node, ctrl_no, XLP_USB3_CTL, 0x2e02203);
+
+        /* mask bits [7:0] -- these are core interrupts */
+        usb_reg_write(node, ctrl_no, XLP_USB3_INT_MASK, 0x000fff01);
+
+        /* clear all interrupts */
+        usb_reg_write(node, ctrl_no, XLP_USB3_INT, 0xffffffff);
+
+        udelay(2000);
+
+        if (ctrl_no == 1) {
+               corebase = (~0xf) & nlm_hal_read_32bit_reg(base, PCI_MEM_BAR_0);
+               printk("USB %d corebase 0x%llx\n", ctrl_no, corebase);
+               nlh_write_cfg_reg32(corebase | 0xc2c0, 0x240002);
+
+               val = nlh_read_cfg_reg32(corebase | 0xc110);
+               val &= ~(0x3<<12);
+               val |= (1<<12);
+               nlh_write_cfg_reg32(corebase | 0xc110, val);
+               udelay(1000);
+                 printk("GCTL 0x%x\n", val);
+
+                 val = nlh_read_cfg_reg32(corebase | 0xc200);
+                 val &= ~(1<<6);
+                 nlh_write_cfg_reg32(corebase | 0xc200, val);
+                 printk("PHYCFG 0x%xx \n",val);
+                 udelay(1000);
+
+                 val = nlh_read_cfg_reg32(corebase | 0xc2c0);
+                 val &= ~(1<<17);
+                 nlh_write_cfg_reg32(corebase | 0xc2c0, val);
+                 printk("PIPECTL 0x%x\n",val);
+
+        }
+   return;
 }
 
 static int __init nlm_platform_usb_init(void)
 {
+        int n, online;
+        int total=num_possible_nodes();
+
 	pr_info("Initializing USB Interface\n");
-	nlm_usb_hw_reset(0, 0);
-	nlm_usb_hw_reset(0, 3);
 
-	/* Enable PHY interrupts */
-	nlm_usb_intr_en(0, 0);
-	nlm_usb_intr_en(0, 3);
+        if (is_nlm_xlp2xx())
+                xlp_usb_dev = XLP_PCIE_USB3_DEV;
+        else
+                xlp_usb_dev = XLP_PCIE_USB_DEV;
+
+        for(n=0; n<total; n++) {
+                online=node_online(n);
+                if(!online)     continue;
+
+                if (is_nlm_xlp2xx()) {
+                        xlp_usb3_hw_start_controller(n, 1);
+                        xlp_usb3_hw_start_controller(n, 2);
+                        xlp_usb3_hw_start_controller(n, 3);
+                } else {
+	                nlm_usb_hw_reset(n, 0);
+	                nlm_usb_hw_reset(n, 3);
 
+	                /* Enable PHY interrupts */
+	                nlm_usb_intr_en(n, 0);
+	                nlm_usb_intr_en(n, 3);
+                }
+        }
 	return 0;
 }
 
@@ -122,26 +175,41 @@ static void nlm_usb_fixup_final(struct pci_dev *dev)
 	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(64);
 	switch (dev->devfn) {
 	case 0x10:
-		dev->irq = PIC_EHCI_0_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_EHCI_0);
+	       break;
 	case 0x11:
-		dev->irq = PIC_OHCI_0_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_0);
+	       break;
 	case 0x12:
-		dev->irq = PIC_OHCI_1_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_1);
+	       break;
 	case 0x13:
-		dev->irq = PIC_EHCI_1_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_EHCI_1);
+	       break;
 	case 0x14:
-		dev->irq = PIC_OHCI_2_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_2);
+	       break;
 	case 0x15:
-		dev->irq = PIC_OHCI_3_IRQ;
-		break;
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_3);
+	       break;
+	case 0x21:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_0);
+	       break;
+	case 0x22:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_1);
+	       break;
+	case 0x23:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_2);
+	       break;
 	}
 }
-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_EHCI,
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_EHCI,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_OHCI,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI0,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI1,
 		nlm_usb_fixup_final);
-DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_OHCI,
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI2,
 		nlm_usb_fixup_final);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 499be83..af54728 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -43,6 +43,11 @@
 
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
+#if defined(CONFIG_NLM_XLP)
+#include <linux/pci.h>
+#include <asm/netlogic/xlp_usb.h>
+#endif
+
 
 #include "usb.h"
 
@@ -2216,6 +2221,11 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	struct usb_hcd		*hcd = __hcd;
 	unsigned long		flags;
 	irqreturn_t		rc;
+#if defined(CONFIG_NLM_XLP)
+	struct pci_dev      *dev;
+	int             fun, node;
+#endif
+
 
 	/* IRQF_DISABLED doesn't work correctly with shared IRQs
 	 * when the first handler doesn't use it.  So let's just
@@ -2230,6 +2240,14 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	else
 		rc = IRQ_HANDLED;
 
+#if defined(CONFIG_NLM_XLP)
+	dev = to_pci_dev(hcd->self.controller);
+	fun = dev->devfn & 0x7;
+	node = xlp_soc_pcidev_to_node(dev);
+	/* clear all interrupts */
+	usb_reg_write(node, fun, 0x102, 0xffffffff);
+#endif
+
 	local_irq_restore_nort(flags);
 	return rc;
 }
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index f00cb20..50955e3 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -162,6 +162,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	 * to say USB 2.0, but I'm not sure what the implications would be in
 	 * the other parts of the HCD code.
 	 */
+	if (dev->vendor == PCI_VENDOR_ID_NETLOGIC)
+                nlm_xlp_nativexhci = 1;
+
 	retval = usb_hcd_pci_probe(dev, id);
 
 	if (retval)
@@ -326,7 +329,9 @@ static const struct hc_driver xhci_pci_hc_driver = {
 /*-------------------------------------------------------------------------*/
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id pci_ids[] = { {
+static const DEFINE_PCI_DEVICE_TABLE(pci_ids) = { {
+	PCI_VDEVICE(NETLOGIC, 0x101D), (unsigned long) &xhci_pci_hc_driver},
+	{
 	/* handle any USB 3.0 xHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
 	.driver_data =	(unsigned long) &xhci_pci_hc_driver,
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 77600ce..2d84a7e 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1567,17 +1567,40 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 #define xhci_warn_ratelimited(xhci, fmt, args...) \
 	dev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
+/*
+ * In NLM_XLP, USB controller apparently changes endianness : it has the same
+ * endianness as the CPU. That explains the following, I hope.
+ */
+extern int nlm_xlp_nativexhci;
+#define readl_native(addr)     __raw_readl((__force unsigned *)addr)
+#define writel_native(val, addr)   __raw_writel(val, (__force unsigned *)addr)
+
+/*
+ * In NLM_XLP, USB controller apparently changes endianness : it has the same
+ * endianness as the CPU. That explains the following, I hope.
+ */
+extern int nlm_xlp_nativexhci;
+#define readl_native(addr)     __raw_readl((__force unsigned *)addr)
+#define writel_native(val, addr)   __raw_writel(val, (__force unsigned *)addr)
+
 /* TODO: copied from ehci.h - can be refactored? */
 /* xHCI spec says all registers are little endian */
 static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
 		__le32 __iomem *regs)
 {
-	return readl(regs);
+	if (nlm_xlp_nativexhci)
+		return readl_native(regs);
+	else
+		return readl(regs);
 }
+
 static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __le32 __iomem *regs)
 {
-	writel(val, regs);
+	if (nlm_xlp_nativexhci)
+		writel_native(val, regs);
+	else
+		writel(val, regs);
 }
 
 /*
@@ -1593,10 +1616,19 @@ static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
 		__le64 __iomem *regs)
 {
 	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u64 val_lo = readl(ptr);
-	u64 val_hi = readl(ptr + 1);
+	u64 val_lo, val_hi;
+
+	if (nlm_xlp_nativexhci) {
+		val_lo = readl_native(ptr);
+		val_hi = readl_native(ptr + 1);
+	} else {
+		val_lo = readl(ptr);
+		val_hi = readl(ptr + 1);
+	}
+
 	return val_lo + (val_hi << 32);
 }
+
 static inline void xhci_write_64(struct xhci_hcd *xhci,
 				 const u64 val, __le64 __iomem *regs)
 {
@@ -1604,8 +1636,13 @@ static inline void xhci_write_64(struct xhci_hcd *xhci,
 	u32 val_lo = lower_32_bits(val);
 	u32 val_hi = upper_32_bits(val);
 
-	writel(val_lo, ptr);
-	writel(val_hi, ptr + 1);
+	if (nlm_xlp_nativexhci) {
+		writel_native(val_lo, ptr);
+		writel_native(val_hi, ptr + 1);
+	} else {
+		writel(val_lo, ptr);
+		writel(val_hi, ptr + 1);
+	}
 }
 
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
-- 
1.8.4.93.g57e4c17

