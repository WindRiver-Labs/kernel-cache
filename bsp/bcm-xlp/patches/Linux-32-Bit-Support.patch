From 6804f6bc58ad40697c0309cb81e78d8e7992171f Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthia@netlogicmicro.com>
Date: Fri, 18 Nov 2011 12:50:14 +0530
Subject: [PATCH 329/565] Linux 32 Bit Support

Linux 32 Bit Support

Based on Broadcom SDK 2.3.

Signed-off-by: Jayanthi A <jayanthia@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Makefile                                 |  3 +-
 .../include/asm/mach-netlogic/kernel-entry-init.h  |  4 ++
 .../asm/netlogic/xlp8xx/cpu_control_macros.h       |  4 ++
 arch/mips/include/asm/netlogic/xlp_hal_pic.h       | 76 ++++++++++++++++++++++
 arch/mips/kernel/vmlinux.lds.S                     | 21 +++---
 arch/mips/netlogic/Kconfig                         |  2 +-
 arch/mips/netlogic/boot/string.h                   |  5 +-
 arch/mips/netlogic/common/cpu_proc.c               | 24 +++++++
 arch/mips/netlogic/common/memory.c                 | 13 ++--
 arch/mips/netlogic/xlp/cpu_control.c               | 10 +--
 arch/mips/netlogic/xlp/cpu_control_asm.S           | 22 +++++++
 arch/mips/netlogic/xlp/on_chip.c                   | 18 ++++-
 arch/mips/pci/pci-xlp.c                            |  4 ++
 13 files changed, 184 insertions(+), 22 deletions(-)

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index e4e3f38..6c4f1fd 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -265,7 +265,8 @@ PHYS_LOAD_ADDRESS = -D"PHYSADDR=$(CONFIG_PHYS_LOAD_ADDRESS)"
 endif
 
 ifdef CONFIG_MAPPED_KERNEL
-KBUILD_CFLAGS += -D"LOADADDR=$(load-y)" $(PHYS_LOAD_ADDRESS)
+KBUILD_CFLAGS += -D"LOADADDR=$(load-y)ULL" -D"PHYSADDR=$(CONFIG_PHYS_LOAD_ADDRESS)ULL"
+KBUILD_CFLAGS += -D"LOADADDR_ASM=$(load-y)" -D"PHYSADDR_ASM=$(CONFIG_PHYS_LOAD_ADDRESS)"
 endif
 head-y := arch/mips/kernel/head.o arch/mips/kernel/init_task.o
 
diff --git a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
index 786f70a..7e48651 100644
--- a/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
+++ b/arch/mips/include/asm/mach-netlogic/kernel-entry-init.h
@@ -7,7 +7,11 @@
 
 /* XLP_MERGE_TODO */
 #if !defined(CKSSEG)
+#ifdef CONFIG_64BIT
 #define CKSSEG			0xffffffffc0000000
+#else
+#define CKSSEG                  0xc0000000
+#endif
 #endif
 
 #ifdef CONFIG_64BIT
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
index 5f9c6c9..b1b66e8 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
@@ -6,7 +6,11 @@
 #include <asm/netlogic/xlp8xx/cpu.h>
 #include <asm/netlogic/xlp8xx/xlp_sys.h>
 #define CP0_EBASE	$15
+#ifdef CONFIG_64BIT
 #define NMI_BASE    	0xffffffffbfc00000UL
+#else
+#define NMI_BASE        0xbfc00000UL	
+#endif
 #define NMI_BASE_ASM   	0xbfc00000
 
 #define LSU_DEFEATURE 0x304
diff --git a/arch/mips/include/asm/netlogic/xlp_hal_pic.h b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
index e6b5314..627f4d5 100644
--- a/arch/mips/include/asm/netlogic/xlp_hal_pic.h
+++ b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
@@ -117,6 +117,8 @@ static __inline__ pic_reg_t* nlm_hal_pic_offset(void)
 	return ((pic_reg_t *) (XLP_IO_PIC_OFFSET + NODE_OFFSET(CPU_TO_NODE(cpu))));
 }
 
+#ifdef CONFIG_64BIT
+
 static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base,
 		unsigned int offset, unsigned long long value)
 {
@@ -129,6 +131,80 @@ static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base,
 	return ((base)[offset]);
 }
 
+#else
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+        uint32_t lsw, msw;
+        uint64_t val;
+        uint32_t ls, ms;
+        unsigned long flags;
+
+        lsw = (uint32_t) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+        val = (uint64_t)value;
+
+        ls = (uint32_t) (val & 0xffffffff);
+        ms = (uint32_t) (val >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "dsll32 $8, %4, 0\n"
+                        "dsll32 %3, 0\n"
+                        "dsrl32 %3, 0\n"
+                        "or $8, $8, %3\n"
+                        "sd $8, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(val), "r"(lsw), "r"(msw), "r"(ls), "r"(ms)
+                        :"$1", "$8");
+        disable_KX(flags);
+}
+ 
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+        uint32_t lsw, msw;
+        uint64_t value = 0;
+        uint32_t lo, hi;
+        unsigned long flags;
+
+        lsw = (uint32_t) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %3, 0\n"
+                        "dsll32 %2, 0\n"
+                        "dsrl32 %2, 0\n"
+                        "or $1, $1, %2\n"
+                        "ld $8, 0($1) \n"
+                        "dsrl32 %1, $8, 0\n"
+                        "dsll32 $8, $8, 0\n"
+                        "dsrl32 %0, $8, 0\n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(lo), "=r"(hi)
+                        :"r"(lsw), "r"(msw)
+                        :"$1", "$8");
+
+        disable_KX(flags);
+        value = hi;
+        value = (uint64_t) ((value<<32) | lo);
+        return (value);
+}
+#endif
+
 static __inline__ void nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu)
 {
 	pic_reg_t *mmio = nlm_hal_pic_offset();
diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S
index 17f341b..c5a8994 100644
--- a/arch/mips/kernel/vmlinux.lds.S
+++ b/arch/mips/kernel/vmlinux.lds.S
@@ -6,25 +6,29 @@
 #undef mips
 #define mips mips
 OUTPUT_ARCH(mips)
-#ifdef CONFIG_NLM_XLP
+
+#ifdef CONFIG_MAPPED_KERNEL
 #define AT_LOCATION
+#endif
 
 PHDRS {
+#ifdef CONFIG_MAPPED_KERNEL
 	text PT_LOAD AT_LOCATION FLAGS(7);	/* RWX */
+#else
+	text PT_LOAD FLAGS(7);  /* RWX */
+#endif
 	note PT_NOTE FLAGS(4);	/* R__ */
 }
 
+#ifdef CONFIG_MAPPED_KERNEL
 #ifdef PHYSADDR
-phys_entry = kernel_entry - LOADADDR + PHYSADDR;
+phys_entry = kernel_entry - LOADADDR_ASM + PHYSADDR_ASM;
 #endif
 ENTRY(phys_entry)
-#else /* CONFIG_NLM_XLP */
+#else
 ENTRY(kernel_entry)
-PHDRS {
-	text PT_LOAD FLAGS(7);	/* RWX */
-	note PT_NOTE FLAGS(4);	/* R__ */
-}
-#endif /* CONFIG_NLM_XLP */
+#endif
+
 
 #ifdef CONFIG_32BIT
 	#ifdef CONFIG_CPU_LITTLE_ENDIAN
@@ -53,6 +57,7 @@ SECTIONS
 	/* . = 0xa800000000300000; */
 	. = 0xffffffff80300000;
 #endif
+
 	. = VMLINUX_LOAD_ADDRESS;
 	/* read-only */
 	_text = .;	/* Text and read-only data */
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index e30155e..cbda2a4 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -79,7 +79,7 @@ config NLM_VMIPS
 
 config KSEG2_LOWMEM
        bool "Mapped Lowmem"
-       depends on MAPPED_KERNEL && 64BIT
+       depends on MAPPED_KERNEL && (64BIT || 32BIT)
        default y
 
 config NLM_NAS
diff --git a/arch/mips/netlogic/boot/string.h b/arch/mips/netlogic/boot/string.h
index 50091cc..ac26c1d 100644
--- a/arch/mips/netlogic/boot/string.h
+++ b/arch/mips/netlogic/boot/string.h
@@ -1,6 +1,7 @@
 #ifndef _PPC_BOOT_STRING_H_
 #define _PPC_BOOT_STRING_H_
 #include <stddef.h>
+#include <asm/string.h>
 
 extern char *strcpy(char *dest, const char *src);
 extern char *strncpy(char *dest, const char *src, size_t n);
@@ -12,8 +13,8 @@ extern size_t strlen(const char *s);
 extern size_t strnlen(const char *s, size_t count);
 
 extern void *memset(void *s, int c, size_t n);
-extern void *memmove(void *dest, const void *src, unsigned long n);
-extern void *memcpy(void *dest, const void *src, unsigned long n);
+extern void *memmove(void *dest, const void *src, size_t n);
+extern void *memcpy(void *dest, const void *src, size_t n);
 extern void *memchr(const void *s, int c, size_t n);
 extern int memcmp(const void *s1, const void *s2, size_t n);
 
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 515b84c..31fe177 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -124,6 +124,30 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 	if (!proc_pos_check(&begin, &len, off, count))
 		goto out;
 
+#ifdef CONFIG_32BIT
+        len += sprintf(page + len, "32 Bit ");
+#else
+        len += sprintf(page + len, "64 Bit ");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+        len += sprintf(page + len, "Big Endian ");
+#else
+        len += sprintf(page + len, "Little Endian ");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
+#ifdef CONFIG_MAPPED_KERNEL
+        len += sprintf(page + len, "Mapped Kernel.\n");
+#else
+        len += sprintf(page + len, "Un-Mapped Kernel.\n");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
 	for(i=0;i<32;i++) {
 
 		if (!nlm_cp2_exceptions[i]) continue;
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index 9c19b32..a53eeb6 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -122,11 +122,17 @@ EXPORT_SYMBOL(__vmalloc_start);
 static volatile int max_low_pfn_set = 0;
 extern unsigned long max_low_pfn;
 
+#ifdef CONFIG_64BIT
+#define TLB_VADDR	XKSEG	
+#else
+#define TLB_VADDR       KSEG2
+#endif
+
 void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 {
 	tlb_info_t tlb;
 
-    tlb.pagesize = LARGEST_TLBPAGE_SZ; /* we set up the largest pages */
+	tlb.pagesize = LARGEST_TLBPAGE_SZ; /* we set up the largest pages */
 
 	/*
 	 * In NetLogic's Linux kernel, the second 256MB of physical
@@ -138,7 +144,7 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 	 * difference through the following unseemly if condition
 	 */
 	if (firstpage) {
-		tlb.vaddr = XKSEG;
+                tlb.vaddr = TLB_VADDR;
 		tlb.paddr1 = tlb.paddr0 = 0;
 		tlb.attr0 = ((_CACHE_CACHABLE_COW |_PAGE_DIRTY |  _PAGE_VALID | _PAGE_GLOBAL) >> ENTRYLO_PFN_SHIFT);
 		tlb.attr1 = _PAGE_GLOBAL >> ENTRYLO_PFN_SHIFT;
@@ -154,8 +160,7 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 		if (!primary_cpu)
 			while (!max_low_pfn_set)
 				;
-
-		tlb.vaddr = XKSEG + 2 * LARGEST_TLBPAGE_SZ; 
+		tlb.vaddr = TLB_VADDR + 2 * LARGEST_TLBPAGE_SZ; 
 		tlb.paddr0 = 2 * LARGEST_TLBPAGE_SZ;
 		for (; tlb.paddr0 < (max_low_pfn << PAGE_SHIFT);
 			 tlb.paddr0 += 2 * tlb.pagesize, tlb.vaddr += 2 * tlb.pagesize) {
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index a0f3a84..be0c65e 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -230,11 +230,10 @@ static u32 get_pll_period(int divf,int divr) {
  */
 static uint64_t get_pll_freq(int divf,int divr)
 {
-	uint64_t hz_freq;
-	uint64_t hz_mult = (1000ULL * 1000ULL * 1000ULL * 1000ULL * 1000ULL); /* 1e15 */
+	uint64_t hz_freq = 1000000000000000ULL; /* 1e15 */
 	u32 pll_period_fs = get_pll_period(divf,divr);
 
-	hz_freq   = hz_mult/((uint64_t) pll_period_fs);
+	do_div(hz_freq, ((uint64_t) pll_period_fs));
 
 	return hz_freq;
 }
@@ -244,6 +243,7 @@ static uint64_t get_pll_freq(int divf,int divr)
 u32 get_cpu_freq(int cpu_num)
 {
 	volatile u32* mmio;
+	uint64_t pll_freq;
 	u32 pwron_rst_reg;
 	u32 core_dfs, divf, divr, dfs, core, ext_div;
 	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
@@ -257,7 +257,9 @@ u32 get_cpu_freq(int cpu_num)
 	ext_div = SYS_PWRON_EXTDIV(pwron_rst_reg) + 1;
 	dfs  = SYS_CORE_DFS(core_dfs,core) + 1;
 
-	return ((u32)(get_pll_freq(divf,divr)/((uint64_t)(ext_div * dfs))));
+	pll_freq = get_pll_freq(divf,divr);
+	do_div( pll_freq, ((uint64_t)(ext_div * dfs)));
+	return ((u32) pll_freq);
 }
 
 EXPORT_SYMBOL(get_cpu_freq);
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 42329dc..a8b644d 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -25,8 +25,13 @@
 	 * cpus for KSEG2 access
 	 */
 	.macro 	SETUP_PERTHREAD_TLB
+#ifdef CONFIG_64BIT
 	dli     t3, CKSSEG
 	dmtc0   t3, CP0_ENTRYHI
+#else
+	li      t3, CKSSEG
+	mtc0    t3, CP0_ENTRYHI
+#endif
 	li      t1, 0x1f
 	MTC0    t1, CP0_ENTRYLO0    # physaddr, VG, cach exlwr
 	li      t2, 0x1
@@ -42,7 +47,9 @@
 
 	.macro 	__start_secondary
 	.set push
+#ifdef CONFIG_MAPPED_KERNEL
 	SETUP_PERTHREAD_TLB
+#endif
 #ifdef CONFIG_64BIT
 	prog_c0_status ST0_KX ST0_BEV
 #else
@@ -132,7 +139,11 @@ EXPORT(reset_entry)
 	li      t1, 0x1
 	sll     t0, t1, t0
 	nor     t0, t0, zero
+#ifdef CONFIG_64BIT
 	dla     t2, CPU_MMIO_OFFSET(0, SYS)
+#else
+	la      t2, CPU_MMIO_OFFSET(0, SYS)
+#endif
 	add	t2, t2, t3  #get node based SYS offset
 	lw      t1, (SYS_CPUNONCOHERENTMODE_REG << 2)(t2)
 	and     t1, t1, t0
@@ -145,8 +156,13 @@ EXPORT(reset_entry)
 	/* Configure LSU on Non-0 Cores. */
 	__config_lsu
 
+#ifdef CONFIG_64BIT
 	dla     t1, boot_siblings_start
 	dla     t2, __boot_siblings
+#else
+	la      t1, boot_siblings_start
+	la      t2, __boot_siblings
+#endif
 	subu	t2, t2, t1		/* t2 now has the jump offset */
 
 	/* Jump to KSEG0 addr of __boot_siblings
@@ -180,8 +196,14 @@ EXPORT(__boot_siblings)				/* T0 of every core in every node starts from here */
 	srl     t3, t3 , 2
 	and     t3, t3 , 0x7  			/* t3 contains the core number */
 	mul	 t3, t3 , 4                        
+#ifdef CONFIG_64BIT
 	dla     t0, threads_to_enable
+#else
+	la      t0, threads_to_enable
+#endif
+#ifdef CONFIG_MAPPED_KERNEL
 	subu	 t0, t0, 0x40000000		/* t0 has the kseg0 address of threads_to_enable */
+#endif
 	lw  	 t1, 0(t0)			/* t1 now has the entire threads_to_enable */
 	srl	 t1, t3                     
 	and	 t1, t1, 0xf 			/* t1 has the threads to enable for this core. */
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index cd2d890..dde20b1 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -489,7 +489,7 @@ void nlm_nmi_cpus(unsigned int mask)
  ********************************************************************/
 void enable_msgconfig_int(void)
 {
-	uint32_t flags;
+	unsigned long flags  = 0;
 
 	/* Need write interrupt vector to cp2 msgconfig register */
 	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING);
@@ -721,14 +721,22 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 	int count = 0;
 	int no_msg = 0;
 	uint32_t napi_vc_mask = xlp_napi_vc_mask & nlm_cpu_vc_mask[cpu];
+#ifdef CONFIG_32BIT
+	unsigned long mflags;
+#endif
 
 	while(count < budget){
 		for( no_msg = 0, vc = 0; vc < 4; vc++)
 		{
 			if(!(napi_vc_mask & (1<<vc)))
 				continue;
-
+#ifdef CONFIG_32BIT
+			msgrng_access_enable(mflags);
+#endif
 			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+#ifdef CONFIG_32BIT
+			msgrng_access_disable(mflags);
+#endif
 			if(status != 0){
 				no_msg++;
 				continue;
@@ -754,12 +762,18 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		uint32_t val;
 		unsigned long flags;
 		local_irq_save(flags);
+#ifdef CONFIG_32BIT
+		msgrng_access_enable(mflags);
+#endif
                 napi_complete(napi);
 		/* Need write vc into the register */
 		val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
 		//val |= ((1 << vc) << 16);
 		val |= (napi_vc_mask << 16);
 		_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+#ifdef CONFIG_32BIT
+		msgrng_access_disable(mflags);
+#endif
 		local_irq_restore(flags);
 		return count;
 	}
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 6ef9696..8f589df 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -318,7 +318,11 @@ static void pcie_controller_init_done(void)
 	u32 plc, syscfg, mode, count = 0;
 
 #ifndef CONFIG_XLP_MSI_ADDRESSES
+#ifdef CONFIG_32BIT
+	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL, get_order(0x100000));
+#else
 	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL, get_order(0x1000000));
+#endif
 	if (XLP_MSI_ADDR == 0) {
 		printk(KERN_ERR "Failed to get memory for MSI/MSI-X tables\n");
 	}
-- 
1.8.4.93.g57e4c17

