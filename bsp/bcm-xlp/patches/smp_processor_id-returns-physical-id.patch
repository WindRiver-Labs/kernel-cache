From d10dfe6995f05e7752869786b4973e1eb75b78e5 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Tue, 13 Dec 2011 15:13:06 -0800
Subject: [PATCH 314/565] smp_processor_id() returns physical id

This patch corrects an earlier faulty commit. Now smp_processor_id()
returns logical processor id, not the physical one.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/smp.c | 62 ++++++++++++++++----------------------------
 drivers/char/nlm_xlp_dma.c   |  7 +++--
 2 files changed, 27 insertions(+), 42 deletions(-)

diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 4841b09..76fe379 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -28,7 +28,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
-#include <linux/interrupt.h>
 
 #include <asm/mipsregs.h>
 #include <asm/mmu_context.h>
@@ -68,12 +67,17 @@ extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
 extern void xlp_pic_ite_init(const struct cpumask *);
 
-void nlm_send_ipi_single(int cpu, unsigned int action)
+/*
+ * Input parameter is logical cpu number.
+ * Should convert to physical cpu before using it
+ */
+void nlm_send_ipi_single(int lcpu, unsigned int action)
 {
-        __u32 node = cpu / 32;
+	int phys_cpu = cpu_logical_map(lcpu);
+        __u32 node = phys_cpu / 32;
         __u32 ipi = 0;
 	__u8 nmi = 0;
-	cpu = cpu % 32;
+	phys_cpu = phys_cpu % 32;	/* This need to be changed for NUMA?? */
 
         if (action & SMP_CALL_FUNCTION) {
                 ipi |= XLP_IRQ_IPI_SMP_FUNCTION;
@@ -90,7 +94,7 @@ void nlm_send_ipi_single(int cpu, unsigned int action)
 
 	smp_mb();
 
-        nlm_hal_pic_send_ipi(nmi, (ipi & 0x3f), node, cpu);
+        nlm_hal_pic_send_ipi(nmi, (ipi & 0x3f), node, phys_cpu);
 }
 
 void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
@@ -143,22 +147,23 @@ void nlm_cpus_done(void)
  * init/main.c : smp_init ==> cpu_up ==> _cpu_up => __cpu_up (arch/mips/kernel/
  * smp.c) ==> mp_ops->boot_secondary
  * The cpu argument is the bit number from cpu_present_mask (for_each_online_cpu
- * ) => physical cpu id, not logical
+ * ) => logical cpu id
  */
-void __cpuinit nlm_boot_secondary(int cpu, struct task_struct *idle)
+void nlm_boot_secondary(int cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
+	int phys_cpu = cpu_logical_map(cpu);
 
-	printk("nlm_boot_secondary: logical cpu %d physical cpu %d\n", __cpu_number_map[cpu], cpu);
+	printk("nlm_boot_secondary: logical cpu %d physical cpu %d\n", cpu, phys_cpu);
 
-	smp_boot.boot_info[cpu].sp = sp;
-	smp_boot.boot_info[cpu].gp = gp;
-	smp_boot.boot_info[cpu].fn = (unsigned long)&smp_bootstrap;
+	smp_boot.boot_info[phys_cpu].sp = sp;
+	smp_boot.boot_info[phys_cpu].gp = gp;
+	smp_boot.boot_info[phys_cpu].fn = (unsigned long)&smp_bootstrap;
 
 	/* barrier */
 	__sync();
-	smp_boot.boot_info[cpu].ready = 1;
+	smp_boot.boot_info[phys_cpu].ready = 1;
 
 /*  	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu);  */
 }
@@ -192,20 +197,19 @@ void __init nlm_smp_setup(void)
 		if (cpumask_test_cpu(i, &fdt_cpumask)) {
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
-			cpu_data[i].core = (int) (i/XLP_THREADS_PER_CORE);
+			cpu_data[num_cpus].core = (int) (__cpu_logical_map[num_cpus]/XLP_THREADS_PER_CORE);
+			cpu_set(num_cpus, cpu_possible_map);
 			num_cpus++;
 		}
 	}
-
-	cpumask_copy(&cpu_present_map, &fdt_cpumask);
-	cpumask_copy(&cpu_possible_map, &fdt_cpumask);
+	cpu_present_map = cpu_possible_map;
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_present_map);
 	printk("Present CPU map %s\n", buf);
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
 	printk("Possible CPU map %s\n", buf);
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
-	/* Setup PIC with cpu_present_mask */
-	xlp_pic_ite_init((const struct cpumask *)&cpu_present_map);
+	/* Setup PIC with passed fdt_cpumask : PIC requires physical CPU ids*/
+	xlp_pic_ite_init((const struct cpumask *)&fdt_cpumask);
 }
 
 #ifdef CONFIG_XEN
@@ -276,30 +280,8 @@ int wakeup_secondary_cpus(void)
 	return 0;
 }
 
-static irqreturn_t smp_resched_ipi_handler(int irq, void *dev_id)
-{
-	scheduler_ipi();
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t smp_function_ipi_handler(int irq, void *dev_id)
-{
-	smp_call_function_interrupt();
-	return IRQ_HANDLED;
-}
-
 void nlm_prepare_cpus(unsigned int max_cpus)
 {
-	if (request_irq(XLP_IRQ_IPI_SMP_FUNCTION, smp_function_ipi_handler,
-			IRQF_PERCPU | IRQF_NO_THREAD,
-			"IPI:smp function", NULL)) {
-		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_FUNCTION)\n");
-	}
-	if (request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE, smp_resched_ipi_handler,
-			IRQF_PERCPU | IRQF_NO_THREAD,
-			"IPI:smp reschedule", NULL)) {
-		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE)\n");
-	}
 }
 
 struct plat_smp_ops nlm_smp_ops = {
diff --git a/drivers/char/nlm_xlp_dma.c b/drivers/char/nlm_xlp_dma.c
index fe1cf86..1848dfa 100644
--- a/drivers/char/nlm_xlp_dma.c
+++ b/drivers/char/nlm_xlp_dma.c
@@ -540,8 +540,11 @@ static void config_fmn(void)
 	msgrng_access_enable(mflags);
 	//nlm_xlp_msgring_int_handler(IRQ_MSGRING, NULL);
 	/* Configure credits to non-n0c0 cores */
-	printk(KERN_ERR "Potential collission. Change params of nlm_hal_fmn_init\n");
-	nlm_hal_fmn_init(0x10000000, 0x02000000, 50);
+	/* Following two lines are commented out because
+	 * nlm_hal_fmn_init() signature is changed. No longer can we do
+	 * this call. FMN should be initialized before dma engine init */
+	//printk(KERN_ERR "Potential collission. Change params of nlm_hal_fmn_init\n");
+	//nlm_hal_fmn_init(0x10000000, 0x02000000, 50);
 	msgrng_access_disable(mflags);
 	sched_bindto_restore_affinity(&cpumask);
 }
-- 
1.8.4.93.g57e4c17

