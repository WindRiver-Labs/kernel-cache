From 70f1f752acfc2e70ce7293adf4d791fadb1e478c Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 28 Dec 2010 02:02:03 -0800
Subject: [PATCH 203/565] add spansion s25sl12801 driver

Add spansion s25sl12801 serial flash driver to spi bus.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/board.c |  1 +
 drivers/mtd/devices/m25p80.c   | 63 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 64 insertions(+)

diff --git a/arch/mips/netlogic/xlp/board.c b/arch/mips/netlogic/xlp/board.c
index 606ccca..7498075 100644
--- a/arch/mips/netlogic/xlp/board.c
+++ b/arch/mips/netlogic/xlp/board.c
@@ -29,6 +29,7 @@
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
 
+
 static struct i2c_board_info xlp_i2c_device_info[] __initdata = {
         {"ds1374",          0, 0x68, 0, 0, 0},
         {"max6657",             0, 0x4c, 0, 0, 0},
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 96b6ad3..e7bb2fa 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -1,3 +1,11 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems Inc. ("Netlogic").
+ * This is a derived work from software originally provided by the external
+ * entity identified below. The licensing terms and warranties specified in
+ * the header of the original work apply to this derived work.
+ *
+ * *****************************#NETL_1#********************************/
+
 /*
  * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
  *
@@ -94,6 +102,7 @@ static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
 	return container_of(mtd, struct m25p, mtd);
 }
 
+
 /****************************************************************************/
 
 /*
@@ -462,9 +471,15 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 			write_enable(flash);
 
+#ifdef CONFIG_NLM_XLP
+			spi_write(flash->spi, flash->command, CMD_SIZE);
+#endif
 			spi_sync(flash->spi, &m);
 
 			*retlen += m.actual_length - m25p_cmdsz(flash);
+#ifdef CONFIG_NLM_XLP
+			write_disable(flash);
+#endif
 		}
 	}
 
@@ -909,6 +924,54 @@ static const struct spi_device_id *jedec_probe(struct spi_device *spi)
 	return ERR_PTR(-ENODEV);
 }
 
+#ifdef CONFIG_NLM_XLP
+static void m25p_test(struct m25p * flash)
+{
+	int i, xfer_len;
+	unsigned char buf[4096];
+	size_t retlen;
+	memset(buf, 0, 4096);
+	retlen 		= 0;
+	xfer_len 	= 2048;
+
+	printk("\n######################### erase_sector\n");
+	erase_sector(flash, 0);
+
+	printk("\n######################### read\n");
+	printk("\nFlash read back %d\n",xfer_len);
+	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+	for( i = 0; i < xfer_len; i++)
+        {
+                printk("%02x",buf[i]);
+                if((i % 16) == 0xf)
+                        printk("\n");
+        }
+
+	/* fill buf with number */
+	for(i = 0; i < xfer_len; i++){
+		buf[i] = i % 0x100;
+	}
+	retlen = xfer_len;
+
+	printk("\n######################### write\n");
+	printk("\nFlash write %d test\n",xfer_len);
+
+	m25p80_write(&flash->mtd, 0, xfer_len, &retlen, buf);
+
+	printk("\n######################### read\n");
+
+	xfer_len +=32;
+
+	printk("\n\nFlash read back %d\n",xfer_len);
+	m25p80_read(&flash->mtd, 0x0, xfer_len, &retlen, buf);
+	for( i = 0; i < xfer_len; i++)
+        {
+                printk("%02x",buf[i]);
+               if((i % 16) == 0xf)
+                        printk("\n");
+        }
+}
+#endif
 
 /*
  * board specific setup should have ensured the SPI clock used here
-- 
1.8.4.93.g57e4c17

