From 6e4b65b61250fb474545f2e80250adbd9b87a670 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 30 Jun 2010 16:34:53 -0700
Subject: [PATCH 055/565] bcm-xlp: add context support

1. add context support for RX interface;
2. add spin_lock to protect register operation.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/xlp_nae/xlp_nae.c | 48 +++++++++++++++++++++----------------------
 1 file changed, 23 insertions(+), 25 deletions(-)

diff --git a/drivers/net/xlp_nae/xlp_nae.c b/drivers/net/xlp_nae/xlp_nae.c
index cc16a62..12ac3eb 100644
--- a/drivers/net/xlp_nae/xlp_nae.c
+++ b/drivers/net/xlp_nae/xlp_nae.c
@@ -135,8 +135,8 @@ uint8_t myeth[6]     = {0x00,0x01,0x02,0x03,0x04,0x05};
 extern int  xlp_with_mac_driver;
 extern void xlp_set_ethtool_ops(struct net_device *netdev);
 extern void xlp_get_mac_stats(struct net_device* dev, struct net_device_stats* stats);
-
-static void nlm_xlp_sgmii_setcontext();
+spinlock_t  nlm_xlp_nae_lock;
+static void nlm_xlp_sgmii_setcontext(void);
 static void nlm_xlp_nae_init(void);
 static int xlp_mac_proc_read(char *page, char **start, off_t off,int count, int *eof, void *data);
 static int nlm_xlp_nae_fill_rxfr(struct net_device *dev, unsigned int intf);
@@ -408,7 +408,6 @@ static void nlm_xlp_nae_init(void)
 	struct net_device *dev = NULL;
 	struct dev_data *tp;
 	int i;
-	unsigned long mflags;
 	struct proc_dir_entry *entry;
 	uint32_t val;
 /*
@@ -418,24 +417,25 @@ static void nlm_xlp_nae_init(void)
 		return;
 	}
 */
+	spin_lock_init(&nlm_xlp_nae_lock);
+
 	//initial base address for nae, gmac, fmn ...
 	nlm_hal_init();
 
+	spin_lock_irq(&nlm_xlp_nae_lock);
+
 	//initial 18 gmac block	
         for(i = 0; i < MAX_NET_INF; i++)
 	{
 		init_gmac(i);
 	}
+	        
 
 	//init fmn
-	//fmn_init(g_credit);
-
-	msgrng_access_enable(mflags);
 
 	//init tx if credit	
 	init_tx_if_credit( 0, 0x7FFFF );
 
-	msgrng_access_disable(mflags);
 
 	for (i = 0; i < 1/* MAX_NET_INF*/; i++ )
 	{
@@ -446,8 +446,9 @@ static void nlm_xlp_nae_init(void)
 
 	// init egress and igress interface
 	init_ingress();
-	init_egress();
- 
+	init_egress(); 
+	spin_unlock_irq(&nlm_xlp_nae_lock);
+
 	for(i = 0; i< 1 /*MAX_GMAC_PORT*/; i++)
 	{
 		dev = alloc_etherdev(sizeof(struct dev_data));
@@ -490,6 +491,7 @@ static void nlm_xlp_nae_init(void)
 		       __FUNCTION__);
 	}
 	/*config free fifo context mapping*/
+	spin_lock_irq(&nlm_xlp_nae_lock);
 	for(i = 0; i < 20; i++)
 	{
 		val = nlm_hal_read_nae_reg(FREE_IN_FIFO_CFG );	
@@ -502,9 +504,10 @@ static void nlm_xlp_nae_init(void)
 	}
 	nlm_xlp_sgmii_setcontext();
 
+	spin_unlock_irq(&nlm_xlp_nae_lock);
 }
 
-static void nlm_xlp_sgmii_setcontext()
+static void nlm_xlp_sgmii_setcontext(void)
 {
 	int i = 0;
 	uint32_t val;
@@ -1030,7 +1033,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 					uint64_t msg0, uint64_t msg1, 
 					uint64_t msg2, uint64_t msg3, void* data)
 {
-        struct net_device *dev;
+        struct net_device *ndev;
         struct dev_data *priv;
 	unsigned int len, port = 0, src, cpu, context;
         unsigned char* buf;
@@ -1052,17 +1055,17 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 
                 if(addr && (len==0))
                 {
-        		dev = (struct net_device*)dev_mac[port];
-			if(!dev)
+        		ndev = (struct net_device*)dev_mac[port];
+			if(!ndev)
 				return;
-        		priv = netdev_priv(dev);
+        		priv = netdev_priv(ndev);
 
                         skb = (struct sk_buff *)bus_to_virt(addr);
                         if(skb)
                         {
                                 priv->stats.rx_packets++;
                                 if(priv->stats.rx_packets % MIN_FRIN_DESC_THRESHD == 15){
-                                       netif_tx_wake_all_queues(dev);
+                                       netif_tx_wake_all_queues(ndev);
                                 }
                                 dev_kfree_skb_any(skb);
                         }
@@ -1075,7 +1078,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
                 else if(addr == 0)
                 {
                         //case tx queue is stopped
-                        netif_tx_wake_all_queues(dev);
+                        netif_tx_wake_all_queues(ndev);
                 }			
 	}
 	else if(vc == 0)
@@ -1092,10 +1095,10 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 		{
 			port = 0;
 		}
-        	dev = (struct net_device*)dev_mac[port];
-		if(!dev)
+        	ndev = (struct net_device*)dev_mac[port];
+		if(!ndev)
 			return;
-        	priv = netdev_priv(dev);
+        	priv = netdev_priv(ndev);
 	
 		
         	if(!len || addr == 0)
@@ -1174,12 +1177,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	}
 
 	return;
-fill_desc:
-        if(priv->num_desc < MIN_FRIN_DESC_THRESHD)
-        {
-                tasklet_schedule(&mac_refill_task[priv->port]);
-        }
-        return;
+
 }
 
 /**********************************************************************
-- 
1.8.4.93.g57e4c17

