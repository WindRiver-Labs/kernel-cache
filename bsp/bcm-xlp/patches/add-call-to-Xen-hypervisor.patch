From 91ec5e364fffa3b4eaa50763b272902666267c86 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 22 Apr 2013 17:07:55 +0800
Subject: [PATCH 071/565] add call to Xen hypervisor

Add call to Xen hypervisor to wakeup secondary cpus

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/xen/hypercall.h |   7 +++
 arch/mips/netlogic/xlp/smp.c          | 101 +++++-----------------------------
 arch/mips/netlogic/xlp/xenbootinfo.c  |  13 +++++
 3 files changed, 35 insertions(+), 86 deletions(-)

diff --git a/arch/mips/include/asm/xen/hypercall.h b/arch/mips/include/asm/xen/hypercall.h
index 35bc7d5..ff1df8f 100644
--- a/arch/mips/include/asm/xen/hypercall.h
+++ b/arch/mips/include/asm/xen/hypercall.h
@@ -38,6 +38,7 @@
 #include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#include <linux/percpu.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -593,4 +594,10 @@ MULTI_stack_switch(struct multicall_entry *mcl,
 	mcl->args[1] = esp;
 }
 
+
+static inline int HYPERVISOR_wakeup_secondary(unsigned long entry_point)
+{
+	return _hypercall1(int, wakeup_secondary, entry_point);
+}
+
 #endif /* _ASM_MIPS_XEN_HYPERCALL_H */
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 944cce71..16be62c 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -42,28 +42,23 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/processor.h>
 
 #include <asm/mach-netlogic/mmu.h>
-#include "cpu_control_macros.h"
 
 extern int xlr_loader_support;
-extern volatile cpumask_t cpu_callin_map;
 
 extern int onlinemask;
 
 extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 struct smp_boot_info smp_boot;
-struct node_mask smp_node;
 extern void prom_reconfigure_thr_resources(void);
 extern unsigned long nlm_common_ebase;
-extern void enable_cpus(unsigned int node, unsigned online_mask);
-extern void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num);
 
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
 cpumask_t phys_cpu_present_map;
 extern void asmlinkage smp_bootstrap(void);
 extern void core_send_ipi(int cpu, unsigned int action);
 
-extern void enable_cpus( unsigned int node, unsigned int onlinemask );
+extern void enable_cpus(unsigned long thread_bitmask);
 
 void nlm_send_ipi_single(int cpu, unsigned int action)
 {
@@ -81,9 +76,10 @@ void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
 /*
  * Code to run on secondary just after probing the CPU
  */
-extern void nlm_smp_irq_init(void);
 static void __cpuinit nlm_init_secondary(void)
 {
+    extern void nlm_smp_irq_init(void);
+
     nlm_smp_irq_init();
     /* Time init for this cpu is done in mips_clockevent_init() */
 }
@@ -91,7 +87,7 @@ static void __cpuinit nlm_init_secondary(void)
 void nlm_smp_finish(void)
 {
 #if !defined(CONFIG_NLM_XLP)
-    phoenix_msgring_cpu_init();
+    nlm_common_msgring_cpu_init();
 #endif
 }
 
@@ -103,18 +99,12 @@ void nlm_cpus_done(void)
    bring them into the boot fn */
 void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 {
- printk("[%s] logical_cpu: %d\n", __FUNCTION__,logical_cpu); 
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
 	int cpu = cpu_logical_map(logical_cpu);
 
-	if(cpu == 32)
-	{
-		//enable_cores( 1,0x3,4); 
-		enable_cpus( 1, smp_node.onlinemask[1]);
-	}
- 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", 
- 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); 
+/* 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", */
+/* 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); */
   
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -123,14 +113,13 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 	__sync();
 	smp_boot.boot_info[cpu].ready = 1;
   
- 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); 
+/* 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); */
 }
 
 unsigned int fast_syscall_cpumask_phy = 0x1;
 
 void __init nlm_smp_setup(void)
 {
- printk("[%s]\n", __FUNCTION__); 
 	int num_cpus = 1;
 	__u32 boot_cpu_online_map = 0, boot_cpu = 0x0;
 
@@ -158,8 +147,7 @@ void __init nlm_smp_setup(void)
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	boot_cpu_online_map = smp_node.onlinemask[0];
-	smp_boot.online_map = smp_node.onlinemask[0];
+	boot_cpu_online_map = smp_boot.online_map;
 	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
 
 	/* 0th entry in the logical_map should be the bootcpu and all
@@ -171,7 +159,7 @@ void __init nlm_smp_setup(void)
 	__cpu_logical_map[0] = boot_cpu;
 //	cpu_set(0, cpu_possible_map);
 
-	for(i = 0; i < 32; i++) {
+	for(i = 0;i<NR_CPUS;i++) {
 		if (boot_cpu_online_map & (1<<i)) {
 			cpu_set(i, phys_cpu_present_map);
 			__cpu_number_map[i] = num_cpus;
@@ -181,22 +169,6 @@ void __init nlm_smp_setup(void)
 		}
 	}
 
-	for(j = 1; j < 4; j++)
-	{
-		boot_cpu_online_map = smp_node.onlinemask[j];
-		if(boot_cpu_online_map == 0)
-			continue;
-
-		for(i = 0; i < 32; i++) {
-			if (boot_cpu_online_map & (1<<i)) {
-				cpu_set(i + 32*j, phys_cpu_present_map);
-				__cpu_number_map[i+32*j] = num_cpus;
-				__cpu_logical_map[num_cpus] = i+32*j;
-				cpu_set(num_cpus, cpu_possible_map);
-				++num_cpus;
-			}
-		}
-	}
 
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
 
@@ -228,7 +200,7 @@ struct plat_smp_ops nlm_smp_ops = {
 void prom_boot_cpus_secondary(void *args)
 {
 	int cpu = hard_smp_processor_id();
- printk("[%s]\n", __FUNCTION__); 
+  
 	write_c0_ebase((uint32_t)nlm_common_ebase);
 	atomic_add((1<<cpu), (atomic_t *)&smp_boot.online_map);
 	for(;;) {
@@ -245,59 +217,16 @@ void prom_boot_cpus_secondary(void *args)
 		     smp_boot.boot_info[cpu].gp);
 }
 
-#ifdef CONFIG_NLM_XLP
-
-extern void prom_pre_boot_secondary_cpus(void *);
-extern uint32_t xlp_linux_cpu_mask;
+extern uint32_t xlr_linux_cpu_mask;
  
-#ifdef CONFIG_MAPPED_KERNEL
-#define secondary_cpus_bootup_func \
-       ((unsigned long)prom_pre_boot_secondary_cpus - \
-        (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
-#else
-#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
-#endif
+#ifndef CONFIG_XEN
 
 int wakeup_secondary_cpus(void)
 {
-#if 1 
-	smp_node.onlinemask[0] = 0x00000001;
-	smp_node.onlinemask[1] = 0x00000000;
-	smp_node.onlinemask[2] = 0x00000000;
-	smp_node.onlinemask[3] = 0x00000000;
-
-	enable_cpus( 0, smp_node.onlinemask[0]);
-//#if 0
-#else
-	__u32 wakeup_mask;
-#if defined(CONFIG_NLM_XLP_SIM)
-	unsigned int wait_count = 0;
-#endif
+	printk("Enabling CPU Mask [0x%x]\n", onlinemask);
+	enable_cpus(onlinemask);
 
-	if (xlr_loader_support) {
-		wakeup_mask = xlp_linux_cpu_mask | nlm_common_loader_mask;
-		if (wakeup != NULL)
-			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
-	} 
-	else {
-		if (wakeup != NULL) {
-			wakeup((void *)secondary_cpus_bootup_func, 0, 
-				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
-#if defined(CONFIG_NLM_XLP_SIM)
-			while (smp_boot.online_map != prom_info->nlm_cpu_online_map) {
-				if ((wait_count++ % 1000000) == 0) {
-					printk("[%s%d]: Master cpu waiting for slave cpus to wakeup from bootloader (%x != %llx)\n",
-					       __FUNCTION__, __LINE__, smp_boot.online_map, 
-						   (unsigned long long) prom_info->nlm_cpu_online_map);
-				}
-			}
-			printk("[%s@%d]: woke up prom_info->nlm_cpu_online_map=%016llx\n", __FILE__, __LINE__, 
-				   (unsigned long long) prom_info->nlm_cpu_online_map);
-#endif
-		}
-	}
-#endif
 	return 0;
 }
 
-#endif /* #ifdef CONFIG_NLM_XLP */
+#endif
diff --git a/arch/mips/netlogic/xlp/xenbootinfo.c b/arch/mips/netlogic/xlp/xenbootinfo.c
index 6f249b2..16e2c42 100644
--- a/arch/mips/netlogic/xlp/xenbootinfo.c
+++ b/arch/mips/netlogic/xlp/xenbootinfo.c
@@ -9,6 +9,7 @@
 #include <asm/netlogic/bootinfo.h>
 #include <xen/interface/xen.h>
 #include <asm/xen/hypervisor.h>
+#include <asm/xen/hypercall.h>
 
 #include <asm/netlogic/debug.h>
 
@@ -45,7 +46,19 @@ int fdt_process(void)
 	return 0;
 }
 
+extern void prom_pre_boot_secondary_cpus(void *);
+
+#ifdef CONFIG_MAPPED_KERNEL
+#define secondary_cpus_bootup_func \
+       ((unsigned long)prom_pre_boot_secondary_cpus - \
+        (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
+#else
+#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
+#endif
+
 int wakeup_secondary_cpus(void)
 {
+	HYPERVISOR_wakeup_secondary(secondary_cpus_bootup_func);
+
 	return 0;
 }
-- 
1.8.4.93.g57e4c17

