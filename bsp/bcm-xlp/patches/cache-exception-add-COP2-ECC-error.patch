From d49bc356c8119d007bec5d5b089efad3be0a5d50 Mon Sep 17 00:00:00 2001
From: Wei Zhang <wezhang@broadcom.com>
Date: Tue, 17 Jul 2012 17:14:58 -0700
Subject: [PATCH 381/565] cache-exception:add COP2 ECC error

cache-exception:add COP2 ECC error into cache exception handler

Based on Broadcom SDK 2.3.

Signed-off-by: Wei Zhang <wezhang@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/cerr-nlm.c | 181 +++++++++++++++++++++++++++++++++++-------------
 1 file changed, 132 insertions(+), 49 deletions(-)

diff --git a/arch/mips/mm/cerr-nlm.c b/arch/mips/mm/cerr-nlm.c
index 53fa5f6..beed0cd 100644
--- a/arch/mips/mm/cerr-nlm.c
+++ b/arch/mips/mm/cerr-nlm.c
@@ -37,14 +37,15 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/fpu.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
+#include <hal/nlm_hal_macros.h>
 
 unsigned char nlm_cerr_stack[8192];
 volatile int nlm_cerr_lock;
 
-static void LoadRegisters(struct pt_regs *regs, unsigned long *pErrepc);
-static void RestoreRegisters(struct pt_regs *regs, unsigned long errepc);
-static int compute_return_registers(struct pt_regs *regs, unsigned long *pErrepc);
-static int update_registers(void);
+static void load_registers(struct pt_regs *regs, unsigned long *pErrepc);
+static void restore_registers(struct pt_regs *regs, unsigned long errepc);
+static int  compute_return_registers(struct pt_regs *regs, unsigned long *pErrepc);
+static int  update_registers(void);
 
 static __inline__ void cerr_cpu_halt(void)
 {
@@ -168,7 +169,7 @@ static int print_cerr_info(void)
 
 static void dump_cerr_info(void)
 {
-	int n, num_controllers, iRet;
+	int n, num_controllers, ret;
 	uint32_t dram_log1, dram_log2;
 	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
 	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
@@ -192,7 +193,22 @@ static void dump_cerr_info(void)
 	uint32_t l3_reg1 = nlm_hal_read_32bit_reg(mmio, 0xDA);
 	uint32_t l3_reg2 = nlm_hal_read_32bit_reg(mmio, 0xDB);
 
+	uint32_t cop2_txmsgstatus, cop2_msgstatus1, cop2_msgerr0;
+	uint32_t cop2_msgerr1, cop2_msgerr2, cop2_msgerr3;
+	cop2_txmsgstatus = (uint32_t) _read_32bit_cp2_register($2);
+	cop2_msgstatus1  = (uint32_t) _read_32bit_cp2_register($4);
+	cop2_msgerr0 = (uint32_t) _read_32bit_cp2_register_sel($6, 0);
+	cop2_msgerr1 = (uint32_t) _read_32bit_cp2_register_sel($6, 1);
+	cop2_msgerr2 = (uint32_t) _read_32bit_cp2_register_sel($6, 2);
+	cop2_msgerr3 = (uint32_t) _read_32bit_cp2_register_sel($6, 3);
+	cop2_msgerr3 = (uint32_t) _read_32bit_cp2_register_sel($6, 3);
+
 	cerr_printk("CPU (XLP specific) registers dump: Node=%d \n", node);
+	cerr_printk("    COP2: TxMsgStatus = 0x%08x, MsgStatus1 = 0x%08x, MsgError0 = 0x%08x\n",
+				cop2_txmsgstatus, cop2_msgstatus1, cop2_msgerr0 );
+	cerr_printk("          MsgError1 = 0x%08x, MsgError2 = 0x%08x, MsgError3 = 0x%08x\n",
+				cop2_msgerr1, cop2_msgerr2, cop2_msgerr3 );
+
 	cerr_printk("     ICU: log0 = 0x%08x, log1 = 0x%08x, log2 = 0x%08x\n",
 				icu_log0, icu_log1, icu_log2);
 
@@ -208,12 +224,12 @@ static void dump_cerr_info(void)
 				nbu_reg0, nbu_reg1, nbu_reg2);
 
 	num_controllers = 4;	//8xx has 4 controller 
-	iRet=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
-	if( iRet ) num_controllers = 2;
+	ret=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
+	if( ret ) num_controllers = 2;
 	else
 	{
-		iRet=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
-		if( iRet ) num_controllers = 1;
+		ret=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
+		if( ret ) num_controllers = 1;
 	}
 
 	for(n=0; n<num_controllers; n++)
@@ -229,13 +245,56 @@ static void dump_cerr_info(void)
 	cerr_printk("*******************************************************************************************\n");
 }
 
+static int check_COP2_error(void)
+{
+	uint32_t cop2_txmsgstatus, cop2_msgstatus1, cop2_msgerr0;
+	uint32_t cop2_msgerr1, cop2_msgerr2, cop2_msgerr3;
+	cop2_txmsgstatus = (uint32_t)_read_32bit_cp2_register( $2 );
+	cop2_msgstatus1  = (uint32_t)_read_32bit_cp2_register( $4 );
+	cop2_msgerr0 = (uint32_t)_read_32bit_cp2_register_sel($6, 0);
+	cop2_msgerr1 = (uint32_t)_read_32bit_cp2_register_sel($6, 1);
+	cop2_msgerr2 = (uint32_t)_read_32bit_cp2_register_sel($6, 2);
+	cop2_msgerr3 = (uint32_t)_read_32bit_cp2_register_sel($6, 3);
+
+	if( ((cop2_txmsgstatus >> 3) & 1) == 0 && ((cop2_msgstatus1 >> 12) & 1) == 0 ) return 0;
+
+	cerr_printk("COP2 Cache error: \n");
+	if( (cop2_txmsgstatus >> 3) & 1 )
+	{
+		cerr_printk("  TQF: %s\n", (cop2_txmsgstatus >> 24) ? "Queue full" : "Queue not full");
+		cerr_printk("  DFC: 0x%04x\n", (cop2_txmsgstatus >> 4) & 0xFFFF);
+		cerr_printk(" DFCF: ECC error during OQ credit RAM read from COP2 RAM\n");
+		cerr_printk("   PS: %s\n", (cop2_txmsgstatus >> 2) & 1 ? "failed due to pending synchronization" : "Status good");
+		cerr_printk("  IQC: %s\n", (cop2_txmsgstatus >> 1) & 1 ? "error insufficient input credit" : "Status good" );
+		cerr_printk("  OQC: %s\n", (cop2_txmsgstatus >> 0) & 1 ? "error insufficient output credit": "Status good" );
+	}
+
+	if( (cop2_msgstatus1 >> 12) & 1 )
+	{
+		cerr_printk("      VCE: 0x%x\n", (cop2_msgstatus1 >> 24 ) & 0xF );
+		cerr_printk("      RWF: %d\n",   (cop2_msgstatus1 >> 23 ) & 1 );
+		cerr_printk("      ICO: %d\n",   (cop2_msgstatus1 >> 22 ) & 1 );
+		cerr_printk("      OCO: %d\n",   (cop2_msgstatus1 >> 21 ) & 1 );
+		cerr_printk("       ME: %d\n",   (cop2_msgstatus1 >> 20 ) & 1 );
+		cerr_printk("  VC_Pend: %d\n",   (cop2_msgstatus1 >> 16 ) & 0xF );
+		cerr_printk("   MSGSTA: ECC error in COP2 RAM\n");
+		cerr_printk("     OQID: 0x%03x\n", cop2_msgstatus1 & 0xFFF );
+	}
+
+	cerr_printk("  The receive massage that has error:\n");
+	cerr_printk("    bits[31:0]=0x%08x, bits[63:32]=0x%08x, bits[95:64]=0x%08x, bits[103:96]=0x%x\n",
+				cop2_msgerr0, cop2_msgerr1, cop2_msgerr2, cop2_msgerr3);
+
+	return -1;
+}
+
 static char * c_icu_errinfo[]={
 	[0] = "L1 tag RAM",
 	[1] = "L1 data RAM",
 	[2] = "Not defined"
 };
 
-static int Check_ICU_error(void)
+static int check_ICU_error(void)
 {
 	uint32_t icu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
 	uint32_t icu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
@@ -253,7 +312,7 @@ static int Check_ICU_error(void)
 	{
 		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU,ICU_CERRLOG1_REGID, 0);
 		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU,ICU_CERRLOG2_REGID, 0);
-		return 0;
+		return 1;
 	}
 	else
 	{
@@ -263,11 +322,11 @@ static int Check_ICU_error(void)
 		cerr_printk("    Uncorrectable: %d\n", ( icu_log0 >> 5) & 1);
 		cerr_printk("         Overflow: %d\n", ( icu_log0 >> 4 ) & 1);
 		cerr_printk("     Threads Mask: %x\n", icu_log0 & 0xF );
-		return 1;
+		return -1;
 	}
 }
 
-static int Check_LSU_error(void)
+static int check_LSU_error(void)
 {
 	uint32_t lsu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
 	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
@@ -278,7 +337,7 @@ static int Check_LSU_error(void)
 	if( (lsu_log0 & 0xF ) == 0 )
 	{
 		write_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID, 0);
-		return 0;
+		return 1;
 	}
 	else
 	{
@@ -288,7 +347,7 @@ static int Check_LSU_error(void)
 		cerr_printk("   Ucorrectable Error: %d\n", (lsu_log0>>5)&1);
 		cerr_printk("       Error Overflow: %d\n", (lsu_log0>>4)&1);
 		cerr_printk("   Error threads mask: %x\n", lsu_log0&0xF);
-		return 1;
+		return -1;
 	}
 }
 
@@ -313,7 +372,7 @@ static char *c_l2_erroptype[] = {
 	[6] = "Reserved"
 };
 
-static int Check_SCU_error(void)
+static int check_SCU_error(void)
 {
 	uint32_t scu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
 	uint32_t scu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
@@ -331,7 +390,7 @@ static int Check_SCU_error(void)
 	{
 		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID, 0);
 		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID, 0);
-		return 0;
+		return 1;
 	}
 	else
 	{
@@ -341,7 +400,7 @@ static int Check_SCU_error(void)
 		cerr_printk("    Uncorrectable: %d\n", (scu_log0>>2)&1);
 		cerr_printk("         Overflow: %d\n", (scu_log0>>1)&1);
 		cerr_printk("      Error Valid: %d\n", scu_log0&1);
-		return 1;
+		return -1;
 	}
 }
 
@@ -365,7 +424,7 @@ static char *c_l3_ErOpTy[] = {
 	[3] = "Reserved"
 };
 
-static int Check_L3_error(void)
+static int check_L3_error(void)
 {
 	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
 	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
@@ -387,7 +446,7 @@ static int Check_L3_error(void)
 	{
 		nlm_hal_write_32bit_reg(mmio, 0xDA, 0);
 		nlm_hal_write_32bit_reg(mmio, 0xDB, 0);
-		return 0;
+		return 1;
 	}
 	else
 	{
@@ -397,11 +456,11 @@ static int Check_L3_error(void)
 		cerr_printk("   Uncorrectable: %d\n", ( reg0 >> 2 ) & 1);
 		cerr_printk("        Overflow: %d\n", ( reg0 >> 1 ) & 1);
 		cerr_printk("           Valid: %d\n", reg0 & 1 );
-		return 1;
+		return -1;
 	}
 }
 
-static int Check_DRAM_error(void)
+static int check_DRAM_error(void)
 {
 	int n, error=0;
 	uint32_t log1, log2;
@@ -409,12 +468,12 @@ static int Check_DRAM_error(void)
 	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
 
 	int num_controllers = 4;	//8xx has 4 controller 
-	int iRet=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
-	if( iRet ) num_controllers = 2;
+	int ret=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
+	if( ret ) num_controllers = 2;
 	else
 	{
-		iRet=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
-		if( iRet ) num_controllers = 1;
+		ret=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
+		if( ret ) num_controllers = 1;
 	}
 
 	for(n=0; n<num_controllers; n++)
@@ -439,7 +498,7 @@ static int Check_DRAM_error(void)
 		error++;
 	}
 
-	return 0 < error ? 1 : 0;
+	return 0 < error ? -1 : 0;
 }
 
 static char *c_nbu_reqsrc[] = {
@@ -472,7 +531,7 @@ static char *c_nbu_reqtype[] = {
 	[7] = "IO Read Exclusive",
 };
 
-static int Check_NBU_error(void)
+static int check_NBU_error(void)
 {
 	int node = CPU_TO_NODE(nlm_hal_cpu_id());
 	uint64_t nbu_mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
@@ -496,7 +555,7 @@ static int Check_NBU_error(void)
 	{
 		nlm_hal_write_32bit_reg(nbu_mmio, 0xA3, 0);
 		nlm_hal_write_32bit_reg(nbu_mmio, 0xA4, 0);
-		return 0;
+		return 1;
 	}
 	else
 	{
@@ -504,30 +563,54 @@ static int Check_NBU_error(void)
 		cerr_printk("         ReqType: %s\n", c_nbu_reqtype[type] );
 		cerr_printk("        Overflow: %d\n", overflow);
 		cerr_printk("  	  Error Valid: %d\n", valid);
-		return 1;
+		return -1;
 	}
 }
 
 static int  print_cerr_info(void)
 {
-	int iRet = 0 ;
+	int ret = 0, error=0, warning=0 ;
 
 	print_error_header();
 	dump_cerr_info();
 
-	iRet += Check_ICU_error();
+	ret = check_COP2_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_ICU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
 
-	iRet += Check_LSU_error();
+	ret = check_LSU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
 
-	iRet += Check_SCU_error();
+	ret = check_SCU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
 
-	iRet += Check_L3_error();
+	ret = check_L3_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
 
-	iRet += Check_NBU_error();
+	ret = check_NBU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
 
-	iRet += Check_DRAM_error();
+	ret = check_DRAM_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = 0;
+	if( 0 < error ) ret = -1;
+	else if( warning <= 0 )
+	{
+		cerr_printk(" Unknown Cache error in exception handler!\n");
+		ret = -1;
+	}
 
-	return iRet;
+	return ret;
 }
 #endif
 
@@ -538,13 +621,13 @@ static int  print_cerr_info(void)
  */
 asmlinkage void nlm_cache_error(void)
 {
-	int iRet = 0 ;
+	int ret = 0 ;
 
-	iRet = print_cerr_info();
+	ret = print_cerr_info();
 
-	if( iRet == 0 )	iRet=update_registers();
+	if( ret == 0 )	ret=update_registers();
 
-	if( iRet == 0 )	cerr_printk("\n ------- CPU return to normal execution! ------------\n\n");
+	if( ret == 0 )	cerr_printk("\n ------- CPU return to normal execution! ------------\n\n");
 	else
 	{
 		cerr_printk("Can not handle bus/cache error - Halting cpu\n\n");
@@ -556,22 +639,22 @@ static int update_registers(void)
 {
 	unsigned long errepc;
 	struct pt_regs regs;
-	int iRet=0;
+	int ret=0;
 
-	LoadRegisters(&regs, &errepc);
+	load_registers(&regs, &errepc);
 
-	iRet=compute_return_registers(&regs, &errepc);
-	if(iRet!=0)
+	ret=compute_return_registers(&regs, &errepc);
+	if(ret!=0)
 	{
 		cerr_printk("  Update registers fail! CPU could not return to normal execution!\n");
 		return -1;
 	}
 
-	RestoreRegisters(&regs, errepc);
+	restore_registers(&regs, errepc);
 	return 0;
 }
 
-static void LoadRegisters(struct pt_regs *regs, unsigned long *pErrepc)
+static void load_registers(struct pt_regs *regs, unsigned long *pErrepc)
 {
 	int iRegPos, n;
 	uint64_t *pReg;
@@ -616,7 +699,7 @@ static void LoadRegisters(struct pt_regs *regs, unsigned long *pErrepc)
 	regs->regs[27] = k1 ;
 }
 
-static void RestoreRegisters(struct pt_regs *regs, unsigned long errepc)
+static void restore_registers(struct pt_regs *regs, unsigned long errepc)
 {
 	int iRegPos, n;
 	uint64_t *pReg;
-- 
1.8.4.93.g57e4c17

