From f422b08395dad1d16f0a1a09841c48db51b33853 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Mon, 16 Aug 2010 17:55:06 -0700
Subject: [PATCH 095/565] cleanup unused vaiables and functions

cleanup unused vaiables and functions.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/Makefile          |   2 +-
 arch/mips/netlogic/xlp/bootinfo.c        |   2 +-
 arch/mips/netlogic/xlp/cpu_control.c     |   2 +-
 arch/mips/netlogic/xlp/cpu_control_asm.S |   2 +-
 arch/mips/netlogic/xlp/irq.c             |  19 +--
 arch/mips/netlogic/xlp/nmi.S             |   2 +-
 arch/mips/netlogic/xlp/on_chip.c         |  29 +---
 arch/mips/netlogic/xlp/setup.c           | 268 +++++++++++++------------------
 arch/mips/netlogic/xlp/smp.c             |  10 +-
 9 files changed, 135 insertions(+), 201 deletions(-)

diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 8a739fe..61172ef 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -1,7 +1,7 @@
 EXTRA_CFLAGS := -Werror
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 
-obj-y                    = setup.o config_net.o
+obj-y                    = setup.o 
 obj-y 			+= irq.o time.o on_chip.o mmu.o
 obj-$(CONFIG_NLM_XLP) 	+= platform-xlp.o
 obj-$(CONFIG_SMP)       += smp.o smpboot.o
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
index bf87715..673d86c 100644
--- a/arch/mips/netlogic/xlp/bootinfo.c
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -2,7 +2,7 @@
 #include <linux/string.h>
 
 #include <asm/bootinfo.h>
-#include <asm/netlogic/sim.h>
+#include <asm/netlogic/xlp.h>
 #include <asm/netlogic/bootinfo.h>
 
 static int is_valid_prominfo(struct psb_info *info)
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index b006d6a..0af64ba 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -40,7 +40,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/atomic.h>
 #include <asm/cacheflush.h>
 
-#include <asm/netlogic/sim.h>
+#include <asm/netlogic/xlp.h>
 #include <asm/netlogic/hal/nlm_hal.h>
 
 #include "cpu_control_macros.h"
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index e54dcf6..3c2bf25 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -53,7 +53,7 @@
 	srl		t2, 2
 	andi 		t0, 0x7f
 	or		t0, t0, t2
-	PTR_LA		t1, xlr_stack_pages_temp
+	PTR_LA		t1, xlp_stack_pages_temp
 	li   		t2, _THREAD_SIZE
 	srl  		t2, 2
 	mul  		t3, t2, t0
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 143a3f2..9a8a783 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -1,5 +1,5 @@
 /***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic") All rights
 reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
@@ -39,8 +39,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/kgdb.h>
 #include <asm/mipsregs.h>
 
-#include <asm/netlogic/sim.h>
-#include <asm/netlogic/nlm_srio.h>
+#include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msidef.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/pic.h>
@@ -63,7 +62,7 @@ extern void *ht_config_base;
 extern int link0, link1;
 struct pic_tmask pic_tmask[PIC_NUM_IRTS];
 
-__u64 nlm_xlp_irq_mask;
+uint64_t nlm_xlp_irq_mask;
 spinlock_t nlm_common_pic_lock = SPIN_LOCK_UNLOCKED;
 
 void dump_irt_entry(short no)
@@ -239,10 +238,8 @@ static int pic_set_affinity(unsigned int irq, const struct cpumask *mask)
 		if(cpumask_test_cpu(cpu, mask))
 		{
 			nlm_hal_set_irq_to_cpu(irq, cpu);
-		//	printk("[%s]: IN irq=%d cpu %d\n", __func__, irq , cpu); 
 		}
 	}
-//	nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu);
 	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 
 	return 0;
@@ -375,6 +372,7 @@ extern irqreturn_t xlp_kgdb_ipi_handler(int irq, struct pt_regs *regs);
 extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
 					 struct pt_regs *regs);
 #endif
+
 void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 {
 #ifdef CONFIG_SMP
@@ -482,20 +480,16 @@ int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 }
 #endif
 
-#if defined(CONFIG_NLM_XLP)
 static int xlp_perf_irq(void)
 {
 	return IRQ_HANDLED;
 }
-#endif
 
 void __init arch_init_irq(void)
 {
-#if defined(CONFIG_NLM_XLP)
 	extern int (*perf_irq)(void);
 
 	perf_irq = xlp_perf_irq;
-#endif
 
 #ifdef CONFIG_KGDB
 	if (kgdb_early_setup)
@@ -511,7 +505,10 @@ void __init arch_init_irq(void)
 	init_nlm_common_irqs();
 
 	write_64bit_cp0_eimr(nlm_xlp_irq_mask);
-	//dumpall_irt_entry();
+
+	/*
+		dumpall_irt_entry();
+	*/
 }
 
 asmlinkage void plat_irq_dispatch(void)
diff --git a/arch/mips/netlogic/xlp/nmi.S b/arch/mips/netlogic/xlp/nmi.S
index 26d2fa7..a584663 100644
--- a/arch/mips/netlogic/xlp/nmi.S
+++ b/arch/mips/netlogic/xlp/nmi.S
@@ -1,5 +1,5 @@
 /***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (�~@~\Netlogic�~@~]). All rights
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic")�~l rights
 reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 25abbe1..027002b 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -36,11 +36,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
-#include <asm/netlogic/sim.h>
+#include <asm/netlogic/xlp.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 
+#define MAX_VC	1024	
+
 unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
 
@@ -53,17 +55,14 @@ uint32_t msgring_global_thread_mask = 0;
 spinlock_t msgrng_lock;
 static nlm_common_atomic_t msgring_registered;
 
-static __u32 msgring_thread_mask;
 static void enable_msgconfig_int(void);
 
-static void msgring_enable_timer_int_handler(void);
-
 struct msgstn_handler {
         void (*action)(uint32_t, uint32_t, uint32_t, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);
         void *dev_id;
 };
 
-static uint16_t vc_to_handle_map[1024] = {
+static uint16_t vc_to_handle_map[MAX_VC] = {
 	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
 	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
 	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
@@ -190,8 +189,6 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	vcpu = vcpu << 2;
         msgrng_access_enable(mflags);
 
-	/* for(int i = 0; i < 10; i++) */
-	{
 	for( vc = vcpu; vc < (vcpu + 4); vc++)
 	{
 		status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
@@ -199,18 +196,13 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 			continue;
 		
 		{
-			/*
-			printk("[%s] status: %x  vc:%d  src_id:%d handler_id %d\n", 
-			__FUNCTION__, status, vc, src_id, vc_to_handle_map[src_id]);
-			*/
-			if(src_id >= 0 && src_id < 1024)
+			if(src_id >= 0 && src_id < MAX_VC)
 			{
 				handler = &msg_handler_map[vc_to_handle_map[src_id]];
 				(handler->action) (vc, src_id, size, code, msg0, msg1, msg2, msg3, handler->dev_id);
 			}
 		}
 	}
-	}
         msgrng_access_disable(mflags);
 
 	irq_exit();
@@ -250,9 +242,6 @@ int register_xlp_msgring_handler(int major,
 
 	nlm_common_test_and_set(&msgring_registered);
 
-	/* use timer interrupt cpu instead of cpu outq interrupt*/
-	//msgring_enable_timer_int_handler();
-
 	return ret;
 }
 
@@ -283,9 +272,11 @@ static void pic_init(void)
 {
 	int i = 0;
 	int level, vcpu;
+	uint32_t thread_mask;
 
 	vcpu = hard_smp_processor_id() & 0x1F;
-	uint32_t thread_mask = (1 << vcpu);
+
+	thread_mask = (1 << vcpu);
 
 	for (i = 0; i < PIC_NUM_IRTS; i++) {
 
@@ -354,14 +345,10 @@ void on_chip_init(void)
 
 	nlm_hal_init();
 
-	// nlm_hal_pcie_base();
-
-	nlm_hal_fmn_init( xlp_linux_cpu_mask );
 	pic_init(); 
 
 	for (i = 0; i < NR_CPUS; i++)
 	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
 
-//	nlm_usb_init();
 }
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index deccd7a..abe6b35 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -1,5 +1,5 @@
 /* **********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
  * reserved.
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -44,16 +44,13 @@
 #include <asm/atomic.h>
 #include <asm/cacheflush.h>
 
-#include <asm/netlogic/sim.h>
 #include <asm/mipsregs.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/debug.h>
-#include <asm/netlogic/xlr_user_mac.h>
+#include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msgring.h>
 
-#include <asm/netlogic/nlm_common_loader.h>
-#include <user/netlogic/nlm_common_loader.h>
 #include <asm/netlogic/nlm_pcix_gen_dev.h>
 #include <asm/netlogic/memory-exclusion.h>
 
@@ -64,19 +61,8 @@
 #include <asm/mach-netlogic/mmu.h>
 #include <asm/netlogic/bootinfo.h>
 
-#ifdef NLM_BRIDGE_WKAROUND
-#include <asm/netlogic/nlm_rw_lock.h>
-#include <asm/netlogic/global_shmem.h>
-nlm_rwlock_t *nlm_bridge_lock;
-EXPORT_SYMBOL(nlm_bridge_lock);
-int nlm_enable_br_wrkaround = 0;
-EXPORT_SYMBOL(nlm_enable_br_wrkaround);
-#endif
-
-#ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
-#endif
 
 #include "../boot/ops.h"
 
@@ -86,31 +72,20 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #define TRUE 					1
 #define FALSE 					0
 
-#define GPIO_SWRESET_REG 		8
-
-#define DEFAULT_LINUX_CPU_MASK 	0x1
-#define DEFAULT_LOADER_MASK 	~DEFAULT_LINUX_CPU_MASK
+#define DEFAULT_LINUX_CPU_MASK			0x1
+#define DEFAULT_LOADER_MASK 			~DEFAULT_LINUX_CPU_MASK
 
-#define PER_CPU_THREAD_SIZE 	(THREAD_SIZE >> 2)
-#define TOTAL_THREAD_SIZE       (PER_CPU_THREAD_SIZE * (NR_CPUS - 1))
+#define PER_CPU_THREAD_SIZE 			(THREAD_SIZE >> 2)
+#define TOTAL_THREAD_SIZE       		(PER_CPU_THREAD_SIZE * (NR_CPUS - 1))
 
-#define BOOT_LOADER_REGION_SZ 	0x04000000
-#define LOADER_KSEG_END 		0x10000000
+#define BOOT_LOADER_REGION_SZ 			0x04000000
+#define LOADER_KSEG_END 			0x10000000
 
 /* used by the default memory map
  */
-#define DEF_PHYMEM_START_ADDR 	0x100000
-#define DEF_PHYMEM_SIZE 		0x0ff00000
-
-int xlr_hybrid;
-int xlr_loader_support=0;
-int xlr_loader_sharedcore=0;
-int xlr_loader_own_gmac=0;
-int xlr_loader_own_dma=0;
-uint32_t xlr_linux_cpu_mask;
-int xlr_console_pci_con_dev = 0;
-int xlr_console_pci_con_baud = 0;
-int xlr_boot_over_nfs = 0;
+#define DEF_PHYMEM_START_ADDR 			0x100000
+#define DEF_PHYMEM_SIZE 			0x0ff00000
+
 unsigned long nlm_common_ebase = 0x0;
 
 static char prop_buf[MAX_PROP_LEN];
@@ -120,18 +95,20 @@ extern void *fdt_init(void *blob);
 extern void *simple_alloc_init(char *base, unsigned long heap_size,
 		unsigned long granularity, unsigned long max_allocs);
 
-unsigned int onlinemask = 0x1;
-int use_default_phymem = 0;
+extern unsigned int xlp_uart_in(struct uart_port *p, int offset);
+extern void xlp_uart_out(struct uart_port *p, int offset, int value);
+
+unsigned int onlinemask	= 0x1;
+int use_default_phymem 	= 0;
 struct boot_mem_map prom_map;
 
 /* Struct for temp. allocation
- * of sp/gp for secondary CPUs 
+ * of sp/gp for secondary CPUs
  */
-struct xlr_stack_pages {
+struct xlp_stack_pages {
 	unsigned long stack[(TOTAL_THREAD_SIZE)/sizeof(long)];
 };
-
-struct xlr_stack_pages xlr_stack_pages_temp
+struct xlp_stack_pages xlp_stack_pages_temp
 __attribute__((__section__(".data.init_task"),
 	       __aligned__(THREAD_SIZE)));
 
@@ -144,37 +121,16 @@ spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
 
 __u8 nlm_common_base_mac_addr[6];
 
-/* xls chip family variables */
-int chip_is_xls6xx = 0;
-int chip_is_xls4xx = 0;
-int chip_is_xls2xx = 0;
-int chip_is_xls1xx = 0;
 int chip_is_xls = 0;
 int chip_is_xls_b0 = 0;
-int chip_is_xls6xx_b0 = 0;
-int chip_is_xls4xx_b0 = 0;
-EXPORT_SYMBOL(chip_is_xls6xx);
-EXPORT_SYMBOL(chip_is_xls4xx);
-EXPORT_SYMBOL(chip_is_xls2xx);
-EXPORT_SYMBOL(chip_is_xls1xx);
+int xlp_sgmii_ports = 1;
+
+
 EXPORT_SYMBOL(chip_is_xls);
 EXPORT_SYMBOL(chip_is_xls_b0);
-EXPORT_SYMBOL(chip_is_xls6xx_b0);
-EXPORT_SYMBOL(chip_is_xls4xx_b0);
-
-int xlp_sgmii_ports = 1;
 EXPORT_SYMBOL(xlp_sgmii_ports);
 uint32_t xlp_linux_cpu_mask;
 
-/* Environment Variables
- */
-struct environment xlr_bldr_env ;
-
-__u32 xlr_board_major_version = NLM_XLR_BOARD_ARIZONA_I;
-__u32 xlr_board_minor_version = 0;
-
-struct kuseg_mem_info kuseg_mem_map[MAX_NUM_KUSEG_BLOCKS];
-
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
 extern unsigned long _text[];
@@ -227,29 +183,42 @@ static char *get_psb_physmap_name(int type)
 	}
 	return ("Unknown type");
 }
-/* Return value
- * 	1 ==> IO (or not found)
- *  0 ==> mem 
- */
+
 int nlm_common_get_pgprot(unsigned long address)
 {
-	/* return 1 if uncached and return 0 if cached access is required */
-	/* TODO:
-	   We need a actual "physical memory map" to implement this fully.
-	   For now, treat anything in 256MB to 512MB as uncached access
-	   */
-	if((address >= NETLOGIC_UNCACHED_START) && 
-			(address < NETLOGIC_UNCACHED_END))
-		return 1;
+	int i;
+	__u64 start=0, end=0;
+	char *name = NULL;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		start = boot_physaddr_info.map[i].addr;
+		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
+		if ((address >= start) && (address < end)) {
+			name = get_psb_physmap_name(boot_physaddr_info.map[i].type);
+			if (!(strcmp(name, "Memory"))) {
+				return 0;
+			} else {
+				return 1;
+			}
+		}
+	}
+	return 1;
+}
 
+int valid_mmap_nlm_common_addr_range(unsigned long pfn)
+{
+	int i;
+	__u64 end=0;
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
+		end = end >> PAGE_SHIFT;
+		if (pfn <= (unsigned long)end)
+			return 1;
+	}
 	return 0;
 }
 
-#if defined(CONFIG_NLM_XLP_SIM)
 const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
-#else
-const char *DEFAULT_CONSOLE_BOOT_PARAMS = "mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
-#endif
 const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
 
 const char *get_system_type(void)
@@ -263,9 +232,9 @@ atomic_t cpus_rebooted = ATOMIC_INIT(0);
 
 static void ptr_linux_exit(void)
 {
-	// trigger a chip reset 
+	// trigger a chip reset
 	write_32bit_cfg_reg((uint32_t *)xlp_sys_base, 0x40 | CHIP_RESET, 1);
-	for ( ; ; ) 
+	for ( ; ; )
 		cpu_wait();
 }
 
@@ -279,23 +248,23 @@ void prom_reconfigure_thr_resources(void)
 	int i=0, count=0, dis_contig=0;
 	int value = 0;
 
-	__u32 online_map, thr_mask; 
+	__u32 online_map, thr_mask;
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 	uint32_t map;
 #endif
 
 	online_map = onlinemask;    /* from fdt */
-	
+
 	thr_mask = online_map >> (netlogic_cpu_id()<<2);
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
-	/* netlogic kernel configures this 
+	/* netlogic kernel configures this
 	 */
 	if (nlm_shtlb && (nlm_asid_mask == 0x3f)) {
-		/* Global TLB will work only if all 
+		/* Global TLB will work only if all
 		 * the enabled cores have all their
-		 * threads owned by Linux. 
+		 * threads owned by Linux.
 		 */
 		map = online_map;
 		for (i = 0; i < NR_CPUS; i += 4) {
@@ -312,7 +281,7 @@ void prom_reconfigure_thr_resources(void)
 			mmu_setup = mmu_setup | 0x1;
 			write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
 
-			printk("CPU %d: Enabled Shared TLB mode \n", 
+			printk("CPU %d: Enabled Shared TLB mode \n",
 					netlogic_cpu_id());
 			return;
 		}
@@ -320,7 +289,7 @@ void prom_reconfigure_thr_resources(void)
 	return;
 #endif /* CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID */
 
-	 if (netlogic_thr_id() == 0) { 
+	 if (netlogic_thr_id() == 0) {
 		for (i=0;i<4;i++) {
 			if (thr_mask & (1<<i)) {
 				if (i != count)
@@ -335,40 +304,12 @@ void prom_reconfigure_thr_resources(void)
 					value = 0x03; break;
 		}
 		if (dis_contig)
-			value = 0x3; 
+			value = 0x3;
 		mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
 		mmu_setup = mmu_setup & ~0x06;
 		mmu_setup |= (value << 1);
 		write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
-	} 
-}
-
-#if !defined(CONFIG_NLMCOMMON_MAC)
-struct user_mac_data *user_mac;
-struct xlr_user_mac_config xlr_user_mac;
-#endif
-
-static inline void init_default_macaddr(void)
-{
-	nlm_common_base_mac_addr[0] = 0x00;
-	nlm_common_base_mac_addr[1] = 0x01;
-	nlm_common_base_mac_addr[2] = 0x02;
-	nlm_common_base_mac_addr[3] = 0x03;
-	nlm_common_base_mac_addr[4] = 0x04;
-	nlm_common_base_mac_addr[5] = 0x05;
-}
-
-static void setup_default_configuration(void)
-{
-	xlr_hybrid = XLR_HYBRID_NONE;
-	xlr_user_mac.l4_extract = 0;
-	xlr_user_mac.fast_syscall = 1;
-	xlr_loader_support = 0;
-	xlr_loader_sharedcore = 0;
-	xlr_loader_own_gmac = 0;
-	xlr_loader_own_dma = 0;
-	xlr_linux_cpu_mask = DEFAULT_LINUX_CPU_MASK; 
-	init_default_macaddr();
+	}
 }
 
 unsigned int __cpuinit get_c0_compare_int(void)
@@ -388,20 +329,19 @@ void plat_time_init(void)
 void __init plat_mem_setup(void)
 {
 	extern int panic_timeout;
-  
-	panic_timeout 	 = 5;  
+
+	panic_timeout 	 = 5;
 	_machine_restart = (void (*)(char *))ptr_linux_exit;
 	_machine_halt    = ptr_linux_exit;
 	pm_power_off 	 = ptr_linux_exit;
 	return;
-}  
+}
 
 struct nlm_common_name_value_struct {
 	char *name;
 	uint32_t *val;
 };
 
-#ifndef CONFIG_XEN
 static void prom_add_memory(uint64_t start, uint64_t size)
 {
 	__u64 pref_backup = 512;
@@ -411,7 +351,7 @@ static void prom_add_memory(uint64_t start, uint64_t size)
 			BOOT_MEM_RAM);
 	return;
 }
-#endif
+
 
 extern void (*board_nmi_handler_setup)(void );
 
@@ -430,11 +370,8 @@ void __init nlm_nmi_setup (void)
 
 /* setup early serial port driver */
 #ifdef CONFIG_SERIAL_8250
-#ifdef CONFIG_NLM_XLR
-#define UART_CLK 66666666
-#else
 #define UART_CLK 133333333
-#endif
+
 static void nlm_early_serial_setup(void)
 {
 	struct uart_port s;
@@ -443,8 +380,7 @@ static void nlm_early_serial_setup(void)
 	memset(&s, 0, sizeof(s));
 
 	s.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
-	/* XLP_MERGE_TODO */
-	s.iotype = UPIO_MEM;
+	s.iotype = UPIO_NLM;
 	/* registers are 4 bytes wide */
 	s.regshift = 2;
 	/* hardware int 4 - the serial int, is CPU int 6
@@ -453,6 +389,8 @@ static void nlm_early_serial_setup(void)
 	s.uartclk = UART_CLK;
 	s.membase = (unsigned char __iomem *)(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
 	s.mapbase = (DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
+	s.serial_in	= xlp_uart_in;
+	s.serial_out	= xlp_uart_out;
 
 	if (early_serial_setup(&s) != 0) {
 		printk(KERN_ERR "Serial setup failed!\n");
@@ -466,12 +404,15 @@ static void nlm_early_serial_setup(void) {}
 
 extern struct plat_smp_ops nlm_smp_ops;
 
-#ifndef CONFIG_XEN
-static int fdt_process(void) 
+#define fdt32_to_cpu(x) be32_to_cpu(x)
+
+static int fdt_process(void)
 {
 	int  domain=0;
 	char domstr[32] = "";
 	int  i, na, ns, regs[4], entries;
+	uint32_t spill_base = 0;
+	uint32_t spill_size = 0, tx_vc = 0;	
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -489,7 +430,7 @@ static int fdt_process(void)
 	simple_alloc_init((char *)((unsigned long)(&_end)+0x10000),
 			(8<<20), 32, 128);
 
-	/* Create a local copy of the FDT 
+	/* Create a local copy of the FDT
 	 */
 	fdt = fdt_init(blob);
 	if(!fdt)
@@ -503,7 +444,7 @@ static int fdt_process(void)
 			return -1;
 		strcat(arcs_cmdline, prop_buf);
 	}
-	
+
 	/* extract memory ranges,
 	 * add to command line
 	 */
@@ -511,10 +452,12 @@ static int fdt_process(void)
 	if (node) {
 		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
 			na = 1;
+		na = fdt32_to_cpu(na);
 		if (na < 1 || na > 2)
 			printk("Can't cope with #address-cells == %d.\n\r", na);
 		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
 			ns = 1;
+		ns = fdt32_to_cpu(ns);
 		if (ns < 1 || ns > 2)
 			printk("Can't cope with #size-cells == %d.\n\r", ns);
 	}
@@ -524,61 +467,74 @@ static int fdt_process(void)
 		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
 		if (!entries || (entries % (na+ns)))
 			printk("Invalid Memory Map Specified!\n");
-		
+
 		for (i=0; i<entries; i+=2) {
-			sprintf(domstr, " mem=%dm@%dm ", 
-					(regs[i+1]>>20), (regs[i]>>20));
+			unsigned long long addr, size;
+			addr = fdt32_to_cpu(regs[i]) >> 20;
+			size = fdt32_to_cpu(regs[i + 1]) >> 20;
+			sprintf(domstr, " mem=%lldm@%lldm ", size, addr);
 			strcat(arcs_cmdline, domstr);
 			memset((void *)&domstr, '\0', sizeof(domstr));
 
 			/* Register these memory regions
 			 */
 			if (!use_default_phymem)
-				prom_add_memory(regs[i], regs[i+1]);
+				prom_add_memory(addr, size);
 		}
 	}
-		
+   	node = finddevice("/doms/dom@0/fmn");
+        if (node) {
+                if(getprop(node, "spill_base", &spill_base, sizeof(spill_base))<0)
+                        printk("Invalid spill_base!\n");
+                if(getprop(node, "spill_size", &spill_size, sizeof(spill_size))<0)
+                        printk("Invalid spill_size!\n");
+                if(getprop(node, "tx_vc", &tx_vc, sizeof(tx_vc))<0)
+                        printk("Invalid tx_vc!\n");
+
+		printk("spill_base 0x%llx  spill_size: %d tx_vc: %d\n",spill_base, spill_size, tx_vc);
+
+	}
+
 	if (use_default_phymem) {
-		printk("Using Default Physical Mem Map\n"); 
+		printk("Using Default Physical Mem Map\n");
 		add_memory_region (
-				DEF_PHYMEM_START_ADDR, 
+				DEF_PHYMEM_START_ADDR,
 				DEF_PHYMEM_SIZE-512, 	/* CHECK! */
 				BOOT_MEM_RAM);
 	}
-	
+
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
-	/* extract CPU online mask for 
+	/* extract CPU online mask for
 	 * domain 0 (linux)
 	 */
 	sprintf(domstr, "/doms/dom@%d/cpu", domain);
 
 	node = finddevice(domstr);
 	if (node) {
-		if (getprop(node, "onlinemask", &onlinemask, 
-					sizeof(onlinemask)) < 0) 
+		if (getprop(node, "onlinemask", &onlinemask,
+					sizeof(onlinemask)) < 0)
 			return -1;
+		onlinemask = fdt32_to_cpu(onlinemask);
 	}
 
-	if (!onlinemask) 
+	if (!onlinemask)
 		/* something went wrong ? */
 		onlinemask = 0x1;
-	
+
 	xlp_linux_cpu_mask = onlinemask;
 	return 0;
 }
-#else
-extern int fdt_process(void);
-#endif
 
 void __init prom_init(void)
 {
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
+/*
 	setup_default_configuration();
-
+*/
 	fdt_process();
-	
+
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
 	smp_boot.online_map = (1 << hard_smp_processor_id());
@@ -624,10 +580,10 @@ void prom_putchar(char c)
 
 static int __init nlm_proc_setup(void)
 {
-	nlm_root_proc = proc_mkdir("netlogic", 0);	
+	nlm_root_proc = proc_mkdir("netlogic", 0);
 	if (!nlm_root_proc)
 		return -ENOMEM;
-	
+
 	return 0;
 }
 rootfs_initcall(nlm_proc_setup);
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 40dface..1730f8b 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -32,10 +32,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/mmu_context.h>
 #include <asm/atomic.h>
 
-#include <asm/netlogic/sim.h>
+#include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msgring.h>
 #include <asm/netlogic/mips-exts.h>
-#include <asm/netlogic/xlr_user_mac.h>
 
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
@@ -47,7 +46,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 extern int xlr_loader_support;
 
 extern int onlinemask;
-
+unsigned int fast_syscall_cpumask_phy = 0x1;
 extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 struct smp_boot_info smp_boot;
@@ -111,10 +110,6 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 		//enable_cores( 1,0x3,4); 
 		enable_cpus( 1, smp_node.onlinemask[1]);
 	}
-#if 0
- 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", 
- 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); 
-#endif
 
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -126,7 +121,6 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
  	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); 
 }
 
-unsigned int fast_syscall_cpumask_phy = 0x1;
 
 void __init nlm_smp_setup(void)
 {
-- 
1.8.4.93.g57e4c17

