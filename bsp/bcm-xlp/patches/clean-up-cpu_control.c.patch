From 77bd24a235de29da48bd484b29d456fc431282f5 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Fri, 27 Aug 2010 16:53:21 -0700
Subject: [PATCH 111/565] clean up cpu_control.c

Clean up cpu_control.c and make it multinode support.

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c | 124 +++++++++++++++--------------------
 1 file changed, 53 insertions(+), 71 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 96f92e3..2f3601c 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -108,20 +108,7 @@ void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_n
         sys_mmio =(uint64_t) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
 
 	for (core=start_core; core!=(0x1<<8); core<<=1) {
-
-		if(thread_num != 4)
-		{
-			value = (thread_num-1) << (i*2);
-			nlm_hal_write_32bit_reg(sys_mmio, 0x4C, value);
-		}
-
 		if (cbitmap & core) {
-
-			if(thread_num != 4)
-			{
-	                        value = (thread_num-1) << (i*2);
-	                        nlm_hal_write_32bit_reg(sys_mmio, 0x4C, 0x1/*value*/);
-			}
 			/* Enable CPU clock 
 			 */
                         value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
@@ -154,77 +141,72 @@ void enable_cpus( unsigned int node, unsigned int onlinemask)
 	/* Extract the bitmap of 'cores'
 	 * from the complete input bitmask
 	 */
-//	for(i = 0; i < 4 ; i++)
-	{
-		thread_bitmask = onlinemask;
-//		if(thread_bitmask == 0)
-//			continue;
+	thread_bitmask = onlinemask;
 
-		t0_bitmap = thread_bitmask & 0x11111111;
+	t0_bitmap = thread_bitmask & 0x11111111;
 
-		cores_bitmap = 0x1;
+	cores_bitmap = 0x1;
 
-		for (t0_positions = 4; t0_positions <=28; t0_positions+=4) {
-			cores_bitmap |= ((t0_bitmap & (1 << t0_positions)) >> index);
-			index+=3;
-		}
+	for (t0_positions = 4; t0_positions <=28; t0_positions+=4) {
+		cores_bitmap |= ((t0_bitmap & (1 << t0_positions)) >> index);
+		index+=3;
+	}
 
 		/* Enable unaligned access on Core0. */
 		if (node == 0)
 			enable_unaligned();
 
-		/* As for the threads to be enabled
-	 	* per core, use Core0 as a reference
-	 	*/
-		thread_bitmask = thread_bitmask & 0xf;
-
-		switch (thread_bitmask) {
-			case 0x1:
-			if (num_ones(cores_bitmap) == 1) {
-				printk("Core0/Thread0 is enabled.\n");
-				return;
-			}
-			case 0x3:
-			case 0xf:
-			threads_to_enable = num_ones(thread_bitmask);
-			printk("Enabling (%d) cores, (%d) threads/core\n",
-					num_ones(cores_bitmap), threads_to_enable);
-			/* C0T0 should always be enabled.
-			 * In the GPIO SW Reset Register, 
-			 * 	'0' => Core is enabled
-			 */
-			cbitmap = cores_bitmap;
-			cores_bitmap = ~(cores_bitmap) & 0xfe;
-			break;
-			default:
-			printk("[Core 0] : Invalid Threads number!\n");
+	/* As for the threads to be enabled
+	* per core, use Core0 as a reference
+	*/
+	thread_bitmask = thread_bitmask & 0xf;
+
+	switch (thread_bitmask) {
+		case 0x1:
+		if (num_ones(cores_bitmap) == 1) {
+			printk("Core0/Thread0 is enabled.\n");
 			return;
 		}
+		case 0x3:
+		case 0xf:
+		threads_to_enable = num_ones(thread_bitmask);
+		printk("Enabling (%d) cores, (%d) threads/core\n",
+		num_ones(cores_bitmap), threads_to_enable);
+		/* C0T0 should always be enabled.
+		 * In the GPIO SW Reset Register, 
+		 * 	'0' => Core is enabled
+		 */
+		cbitmap = cores_bitmap;
+		cores_bitmap = ~(cores_bitmap) & 0xfe;
+		break;
+		default:
+		printk("[Core 0] : Invalid Threads number!\n");
+		return;
+	}
         	
-		spin_lock_irqsave(&smp_lock, flags);
-
-		/* Linux runs out of KSEG2. Setup TLBs
-	 	* for other threads, by running from
-	 	* KSEG0. Then, jump back into KSEG2.
-	 	*/
-		memcpy((void *)(NMI_BASE + (2<<10)), 
-		   (void *)&boot_siblings_start, 
-		   (boot_siblings_end - boot_siblings_start));
-
-		jump_address(NMI_BASE + (2<<10));
-
-		/* Bring the other cores online here
-	 	* Copy reset code into KSEG0 space
-	 	*/
-		if ((cores_bitmap != 0xfe)||(node > 0)) {
-			memcpy((void *)(NMI_BASE), 
-			   (void *)&reset_entry, 
-			   (reset_entry_end - reset_entry));
-		}
+	spin_lock_irqsave(&smp_lock, flags);
+
+	/* Linux runs out of KSEG2. Setup TLBs
+	 * for other threads, by running from
+	 * KSEG0. Then, jump back into KSEG2.
+	 */
+	memcpy((void *)(NMI_BASE + (2<<10)), 
+	   (void *)&boot_siblings_start, 
+	   (boot_siblings_end - boot_siblings_start));
 
-		enable_cores( node, cbitmap, threads_to_enable);
+	jump_address(NMI_BASE + (2<<10));
 
-        	spin_unlock_irqrestore(&smp_lock, flags);
+	/* Bring the other cores online here
+	 * Copy reset code into KSEG0 space
+	 */
+	if ((cores_bitmap != 0xfe)||(node > 0)) {
+		memcpy((void *)(NMI_BASE), 
+		   (void *)&reset_entry, 
+		   (reset_entry_end - reset_entry));
 	}
+
+	enable_cores( node, cbitmap, threads_to_enable);
+
+	spin_unlock_irqrestore(&smp_lock, flags);
 	return;
 }
-- 
1.8.4.93.g57e4c17

