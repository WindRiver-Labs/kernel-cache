From dd2b01ff8eee743d310805bb25bf2b523a0b5294 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Fri, 8 Oct 2010 22:26:30 -0700
Subject: [PATCH 157/565] Bug fixes for multi-node cpu wakeup

Bug fixes for multi-node cpu wakeup.

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c     | 180 ++++++++++++-------------------
 arch/mips/netlogic/xlp/cpu_control_asm.S |  27 ++---
 2 files changed, 81 insertions(+), 126 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 98fb40b..c855a08 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -48,21 +48,12 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_ECFG_BASE           0x18000000
 #define XLP_SYS_DEV_BASE        0x35000
 
-
-
-
-/* Globals Section 
- */ 
-uint32_t cores_bitmap = 0x1;	/* Bitmap of cores to enable  */
-int threads_to_enable; 			/* Threads to enable per core */
-spinlock_t smp_lock;
-
 /* temporary storage space for
  * stack pointers
  */
 unsigned long linuxsp[NR_CPUS];
 
-/* Externs 
+/* Externs
  */
 extern unsigned char __stack[];
 extern char boot_siblings_start[], boot_siblings_end[];
@@ -98,125 +89,94 @@ static inline void config_lsu(void)
 	);
 }
 
-void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num) {
-	uint32_t core, value, start_core, i = 0;
+static void enable_cores(unsigned int node, unsigned int cores_bitmap)
+{
+	uint32_t core, value;
 	uint64_t sys_mmio;
+	uint32_t cbitmap = cores_bitmap;
+
+	/* if n0c0t0, don't pull yourself out of reset! */
+	if(node == 0) cbitmap = cbitmap & 0xfe;
+
+	printk("[%s] node@%d, cores_bitmap = 0x%08x cbitmap = 0x%08x\n",
+	       __func__, node, cores_bitmap, cbitmap);
 
-       if(node == 0)
-                start_core = 0x2;
-        else
-                start_core = 0x1;
-
-        sys_mmio =(uint64_t) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
-
-	for (core=start_core; core!=(0x1<<8); core<<=1) {
-		if (cbitmap & core) {
-
-	                if(thread_num != 4)
-        	        {
-                	        value = (thread_num-1) << (i*2);
-                        	nlm_hal_write_32bit_reg(sys_mmio, 0x4C, value);
-                	}
-
-			/* Enable CPU clock 
-			 */
-                        value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
-                        nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
-
-			/* Remove CPU Reset */
-                        value = nlm_hal_read_32bit_reg(sys_mmio, 0x4B) & ~core;
-                        nlm_hal_write_32bit_reg(sys_mmio, 0x4B, value);
-
-			/* Poll for CPU to mark itself coherent */
-			do {
-                                value = nlm_hal_read_32bit_reg(sys_mmio, 0x4D) & core;
-				if( node > 0)
-				   break;	
-			} while (value);
+        sys_mmio = (uint64_t) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
+
+	for (core = 0x1; core != (0x1 << 8); core <<= 1) {
+
+		if ( (cbitmap & core) == 0) continue;
+
+		/* Enable CPU clock
+		 */
+		value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
+		nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
+
+		/* Remove CPU Reset */
+		value = nlm_hal_read_32bit_reg(sys_mmio, 0x4B) & ~core;
+		nlm_hal_write_32bit_reg(sys_mmio, 0x4B, value);
+
+		/* Poll for CPU to mark itself coherent */
+		for(;;) {
+			value = nlm_hal_read_32bit_reg(sys_mmio, 0x4D) & core;
+			if (!value) break;
 		}
-		i++;
 	}
 }
 
-/* Main routine 
+int threads_to_enable = 1;
+/*
+ * This function is called once for each node. However, it is executed
+ * only on "master cpu", mostly on n0c0t0
  */
-void enable_cpus( unsigned int node, unsigned int onlinemask)
+void enable_cpus(unsigned int node, unsigned int node_cpumask)
 {
-	uint32_t cbitmap;
 	uint32_t t0_bitmap = 0x0;
-	uint32_t t0_positions = 0, index=3;
-	uint32_t thread_bitmask;
-	unsigned long flags;
-	/* Extract the bitmap of 'cores'
-	 * from the complete input bitmask
-	 */
-	thread_bitmask = onlinemask;
-
-	t0_bitmap = thread_bitmask & 0x11111111;
+	uint32_t t0_positions = 0, index = 0;
+	uint32_t cores_bitmap;
 
-	cores_bitmap = 0x1;
-
-	for (t0_positions = 4; t0_positions <=28; t0_positions+=4) {
-		cores_bitmap |= ((t0_bitmap & (1 << t0_positions)) >> index);
-		index+=3;
+	if (hard_smp_processor_id() != 0) {
+		printk("[%s]: Running on non n0c0t0 cpu??\n", __func__);
+		return;
 	}
 
-	/* Configure LSU on Core0. */
-	if (node == 0)
-		config_lsu();
+	/* Setup Exception vectors only the first time around */
+	if (!node) {
 
-	/* As for the threads to be enabled
-	* per core, use Core0 as a reference
-	*/
-	thread_bitmask = thread_bitmask & 0xf;
+		config_lsu();
 
-	switch (thread_bitmask) {
-		case 0x1:
-		if ((num_ones(cores_bitmap) == 1) && (node == 0)) {
-			printk("Core0/Thread0 is enabled.\n");
-			return;
-		}
-		case 0x3:
-		case 0xf:
-		threads_to_enable = num_ones(thread_bitmask);
-		printk("Enabling (%d) cores, (%d) threads/core\n",
-		num_ones(cores_bitmap), threads_to_enable);
-		/* C0T0 should always be enabled.
-		 * In the GPIO SW Reset Register, 
-		 * 	'0' => Core is enabled
+		/* Linux runs out of KSEG2. Setup TLBs
+		 * for other threads, by running from
+		 * KSEG0. Then, jump back into KSEG2.
 		 */
-		cbitmap = cores_bitmap;
-		cores_bitmap = ~(cores_bitmap) & 0xfe;
-		break;
-		default:
-		printk("[Core 0] : Invalid Threads number!\n");
-		return;
+		memcpy((void *)(NMI_BASE + (2<<10)),
+		       (void *)&boot_siblings_start,
+		       (boot_siblings_end - boot_siblings_start));
+
+		/* setup the reset vector */
+		memcpy((void *)(NMI_BASE), (void *)&reset_entry, (reset_entry_end - reset_entry));
+
 	}
-        	
-	spin_lock_irqsave(&smp_lock, flags);
-
-	/* Linux runs out of KSEG2. Setup TLBs
-	 * for other threads, by running from
-	 * KSEG0. Then, jump back into KSEG2.
-	 */
-	memcpy((void *)(NMI_BASE + (2<<10)), 
-	   (void *)&boot_siblings_start, 
-	   (boot_siblings_end - boot_siblings_start));
-
-	jump_address(NMI_BASE + (2<<10));
-
-	/* Bring the other cores online here
-	 * Copy reset code into KSEG0 space
-	 */
-	if ((cores_bitmap != 0xfe)||(node > 0)) {
-		memcpy((void *)(NMI_BASE), 
-		   (void *)&reset_entry, 
-		   (reset_entry_end - reset_entry));
+
+	/* bitmap of thread@0 of every core in this node */
+	t0_bitmap = node_cpumask & 0x11111111;
+
+	cores_bitmap = 0;
+	for (t0_positions = 0, index = 0; t0_positions < 32; t0_positions += 4, index++) {
+		if (t0_bitmap & (1 << t0_positions))
+			cores_bitmap |= (1 << index);
 	}
 
-	enable_cores( node, cbitmap, threads_to_enable);
+	threads_to_enable = num_ones(node_cpumask & 0xf);
 
-	spin_unlock_irqrestore(&smp_lock, flags);
+	printk("node@%d: t0_bitmap = 0x%08x, cores_bitmap = 0x%08x\n", node, t0_bitmap, cores_bitmap);
+
+	enable_cores(node, cores_bitmap);
+
+	if (!node) {
+		/* Wakeup threads of n0c0 */
+		jump_address(NMI_BASE + (2<<10));
+	}
 
 	return;
 }
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 7927fca3..7695f8c 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -7,7 +7,7 @@
 
 #include <asm/mach-netlogic/kernel-entry-init.h>
 #include "cpu_control_macros.h"
-	
+
 	.macro  prog_c0_status set clr
 	.set 	push
 	mfc0    t0, CP0_STATUS
@@ -42,7 +42,7 @@
 	li      t0, 1
 	mtc0    t0, CP0_WIRED
 	EHB
-	.endm	
+	.endm
 
 	.macro 	__start_secondary
 	.set push
@@ -129,18 +129,18 @@ EXPORT(reset_entry_end)
 
 	/* boot_siblings is copied into
 	 * NMI_BASE in KSEG0 space. This
-	 * sets up TLBs for other threads 
+	 * sets up TLBs for other threads
 	 * so that non-0 threads can run
 	 * out of KSEG2
 	 */
 
-EXPORT(boot_siblings_start)
+EXPORT(boot_siblings_start)			/* "Master" (n0c0t0) cpu starts from here */
 	.set 	noreorder
 	LONG_S  sp, linuxsp($0)
 	SAVE_ALL
 	sync
-	
-EXPORT(__boot_siblings)
+
+EXPORT(__boot_siblings)				/* T0 of every core in every node starts from here */
 	dla     t0, threads_to_enable
 	subu	t0, t0, 0x40000000		/* kseg0 */
 	lw  	t1, 0(t0)
@@ -153,19 +153,20 @@ EXPORT(__boot_siblings)
 	or  	t2, t2, t1
 	mtcr    t2, t0
 
-	/* threads (incl. T0) of this core 
+	/* threads (incl. T0) of this core
 	 * start fetching from this point
 	 */
 	mfc0    t0, CP0_EBASE, 1		/* EBASE, Select 1 	*/
-	andi    t0, 0x7f		/* Linear CPU ID	*/
+	andi    t0, 0x7f		        /* Linear CPU ID	*/
 	beqz    t0, 2f
 	nop
 1:
-    __start_secondary
+    __start_secondary				/* "Slave" cpu (of every core on every node) go here */
 2:
-	LONG_L   sp, linuxsp($0)
+	LONG_L   sp, linuxsp($0)		/* "Master" (n0c0t0) cpu restores from here */
 	PTR_SUBU sp, PT_SIZE
 	RESTORE_ALL
+
 	jr   ra
 	nop
 EXPORT(boot_siblings_end)
@@ -211,12 +212,6 @@ NESTED(prom_pre_boot_secondary_cpus, 16, sp)
         li   t2, _THREAD_SIZE
         srl  t2, 2
         mul  t3, t2, t0
-        nop
-        nop
-        nop
-        nop
-        nop
-        nop
         PTR_ADDU  gp, t1, t3
         PTR_ADDU       sp, gp, t2
         PTR_ADDI       sp, sp, -32
-- 
1.8.4.93.g57e4c17

