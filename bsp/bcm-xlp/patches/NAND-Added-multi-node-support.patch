From b9e49c818dfb00519bcb638b8975e304993e9b7d Mon Sep 17 00:00:00 2001
From: Divya Sakthidharan <divyas@broadcom.com>
Date: Mon, 29 Oct 2012 15:30:13 +0530
Subject: [PATCH 412/565] NAND: Added multi node support

Added multi node support and enabled nand in numa defconfig files.
Did some clean up also

Based on Broadcom SDK 2.3.

Signed-off-by: Divya Sakthidharan <divyas@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/xlp_plat_nand.c | 267 +++++++++++++++++++--------------
 1 file changed, 155 insertions(+), 112 deletions(-)

diff --git a/arch/mips/netlogic/xlp/xlp_plat_nand.c b/arch/mips/netlogic/xlp/xlp_plat_nand.c
index 88fe61d..ca017c7 100644
--- a/arch/mips/netlogic/xlp/xlp_plat_nand.c
+++ b/arch/mips/netlogic/xlp/xlp_plat_nand.c
@@ -35,6 +35,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/physmap.h>
+#include <linux/dma-mapping.h>
 #include <asm/netlogic/xlp.h>
 #ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/hal/nlm_hal.h>
@@ -45,7 +46,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 static int debug = 0;
 static int enable_hwecc = 1;
-
 #undef	NAND_DEBUG
 #define BUF_SIZE 		(16*1024)
 #define dbp_print		if(debug) printk
@@ -55,8 +55,8 @@ static int enable_hwecc = 1;
 #define NAND_DEV_CS		1
 #endif
 
-int debug_enable=0;
-#define printk_debug	if(debug_enable) printk
+#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+static u64 xlp_dev_dmamask = DMA_BIT_MASK(32);
 
 /* The oobsize is the area visible to software, and software will read/write in this region.
 * If hardware ecc is enabled, since our implementation of write_page does not calculate
@@ -88,10 +88,16 @@ struct nand_state {
         uint32_t pages_per_block;
         uint32_t spare_size ;
         uint32_t last_cmd ;
+	dma_addr_t buf_dma;
         int buf_ptr ;
         u8* buf ;
 } ;
 
+struct nand_info	{
+	int node;
+	struct nand_state *nand_state;
+};
+
 static int column_prog = 0;
 static int page_prog = 0;
 static int waitfunc (struct mtd_info *mtd, struct nand_chip *chip) ;
@@ -114,15 +120,15 @@ static __inline__ void nand_reg_write(int node, int regidx, int32_t val)
 }
 
 
-static int dma_wait(int cs)
+static int dma_wait(int node, int cs)
 {
         int timeout = 0xfffff ;
-        while ( ( (nand_reg_read(0, NAND_STATUS) & (1 << cs) ) == 0) ||
-                ( (nand_reg_read(0, NAND_DMA_CTRL) & 0x01) == 0) )  {
+        while ( ( (nand_reg_read(node, NAND_STATUS) & (1 << cs) ) == 0) ||
+                ( (nand_reg_read(node, NAND_DMA_CTRL) & 0x01) == 0) )  {
 
                 timeout--;
                 if (timeout == 0) {
-                        dbp_print("DMA timed out NAND_STATUS:%x\n",nand_reg_read(0,NAND_STATUS)) ;
+                        dbp_print("DMA timed out NAND_STATUS:%x\n",nand_reg_read(node,NAND_STATUS)) ;
                         return -1 ;
                 }
         }
@@ -206,7 +212,8 @@ static void print_onfi_params(struct nand_onfi_params * p)
 
 void onfi_init(struct nand_chip *chip)
 {
-        struct nand_state *state = chip->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
         u8* param_ptr = state->buf ;
         uint32_t page_val ;
         uint32_t block_val;
@@ -218,6 +225,7 @@ void onfi_init(struct nand_chip *chip)
         uint32_t val ;
         uint32_t ecc_offset;
         int i ;
+	int node = info->node;
 
 #ifdef NAND_DEBUG
 	print_oob_data(state->buf);
@@ -295,26 +303,26 @@ void onfi_init(struct nand_chip *chip)
 
 	if(enable_hwecc)
 	{
-		nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
-		nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
+		nand_reg_write(node, NAND_ECC_CTRL, (ecc_val << 5));
+		nand_reg_write(node, NAND_ECC_OFFSET, state->page_size + ecc_offset);
 	
         	if (ecc_offset < XLP_HWECC_OOBSIZE)
                 	printk("Warning: (file %s): adjust XLP_HWECC_OOBSIZE smaller for nand flash driver!\n",
                         	__FILE__);
-		nand_reg_write(0, NAND_SPARE_SIZE, XLP_HWECC_OOBSIZE);
+		nand_reg_write(node, NAND_SPARE_SIZE, XLP_HWECC_OOBSIZE);
 
-		val = nand_reg_read(0, NAND_CTRL);
+		val = nand_reg_read(node, NAND_CTRL);
 		val |= (NAND_CTRL_ECC_EN(1)		|
 			NAND_CTRL_PAGE_SIZE(page_val)	|
 			NAND_CTRL_BLOCK_SIZE(block_val)	|
 			NAND_CTRL_ADDR_CYCLE(addr_val))	;
-		nand_reg_write(0, NAND_CTRL, val);
+		nand_reg_write(node, NAND_CTRL, val);
 
 		chip->ecc.size   = 512;
 		chip->ecc.bytes  = ecc_bytes;
 		chip->ecc.steps	 = state->page_size / 512;
 		chip->ecc.total	 = chip->ecc.steps * chip->ecc.bytes;
-		chip->ecc.layout = kmalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
+		chip->ecc.layout = kzalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
 		chip->ecc.layout->eccbytes = ecc_bytes;
 
 		for (i=0; i < ecc_bytes; i++) {
@@ -325,40 +333,40 @@ void onfi_init(struct nand_chip *chip)
 	}
 	else
 	{
-		nand_reg_write(0, NAND_SPARE_SIZE, state->spare_size);
-		val = nand_reg_read(0, NAND_CTRL);
-		val |= (NAND_CTRL_ECC_EN(0)		|
-			NAND_CTRL_PAGE_SIZE(page_val)	|
+		nand_reg_write(node, NAND_SPARE_SIZE, state->spare_size);
+		val = nand_reg_read(node, NAND_CTRL);
+		val &= ~NAND_CTRL_ECC_EN(1) ;
+		val |= 	(NAND_CTRL_PAGE_SIZE(page_val)	|
 			NAND_CTRL_BLOCK_SIZE(block_val)	|
-			NAND_CTRL_ADDR_CYCLE(addr_val))	;
-		nand_reg_write(0, NAND_CTRL, val);
+			 NAND_CTRL_ADDR_CYCLE(addr_val))	;
+		nand_reg_write(node, NAND_CTRL, val);
 	}
 }
 
 
 
 #ifdef NAND_DEBUG
-static void nand_dump_reg(void)
+static void nand_dump_reg(int node)
 {
 	int i;
 
 	for(i = 0; i < 6; i++) {
-		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(node,i));
 	}
 
 	for(i = 0x30; i < 0x4A; i++) {
-		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(node,i));
 	}
 
 	for(i = 0x50; i < 0x5C; i++) {
-		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(node,i));
 	}
 	for(i = 0x60; i < 0x70; i++) {
-		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(node,i));
 	}
 
 	for(i = 0x80; i < 0x82; i++) {
-		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(node,i));
 	}
 }
 
@@ -381,13 +389,14 @@ static void send_cmd(struct mtd_info *mtd,
                      int page_addr,
                      int len)
 {
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
+	
 	uint64_t val;
-	int node = 0;
+	int node = info->node;
 	int column2, len2;
 
-
 	/* The hardware ECC will be generated if the size is mtd->writesize.
 	 * So if the write data is more than mtd->writesize, let us break it into two.
 	 * hardware ECC will be disabled for the second part.
@@ -398,13 +407,11 @@ static void send_cmd(struct mtd_info *mtd,
                         column2 = mtd->writesize;
                         len2 = column + len - mtd->writesize;
                         len = mtd->writesize - column;
-		printk_debug("column2 = %x, len2 = %d, len = %d \n", column2, len2, len);
                 } else {
                         /* not initialized yet, ECC has to be disabled as it has not been configured properly */
                         column2 = column;
                         len2 = len;
                         len = 0;
-		printk_debug("column2 = %x, len2 = %d, len = %d \n", column2, len2, len);
                 }
         } else {
                 column2 = 0;
@@ -412,7 +419,6 @@ static void send_cmd(struct mtd_info *mtd,
         }
 
 	if (len > 0) {
-		printk_debug("state->buf_ptr = %d, len = %d \n", state->buf_ptr, len);
         	nand_reg_write(node, NAND_DATA_SIZE, len);
         	nand_reg_write(node, NAND_DMA_CNT, len);
 
@@ -420,11 +426,10 @@ static void send_cmd(struct mtd_info *mtd,
         	nand_reg_write(node, NAND_ADDR0_H, val);
 		val = ( (page_addr << (state->col_cyc * 8) ) | column);
         	nand_reg_write(node, NAND_ADDR0_L, val) ;
-		val = virt_to_phys((void *) state->buf) + state->buf_ptr;
+		val = state->buf_dma + state->buf_ptr;
         	nand_reg_write(node, NAND_DMA_ADDR, val);
 		nand_reg_write(node, NAND_DMA_ADDR_H, (val >> 32));
 
-		printk_debug("test 0\n");
 
         	if ( (command == NAND_READ_PAGE_CMD) ||
              	     (command == NAND_READ_ID_CMD)   ||
@@ -434,10 +439,8 @@ static void send_cmd(struct mtd_info *mtd,
                 	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
         	}
 
-		printk_debug("test 1\n");
         	nand_reg_write(node, NAND_CMD, command | NAND_CMD_DMA_FLAG);
-        	dma_wait(state->cs);
-		printk_debug("len = %d \n", len);
+        	dma_wait(node, state->cs);
 	}
 
 	if (len2 > 0) {
@@ -448,7 +451,8 @@ static void send_cmd(struct mtd_info *mtd,
         	nand_reg_write(node, NAND_ADDR0_H, val);
 		val = ( (page_addr << (state->col_cyc * 8) ) | column2);
         	nand_reg_write(node, NAND_ADDR0_L, val) ;
-		val = virt_to_phys((void *) state->buf) + state->buf_ptr + len;
+		//val = virt_to_phys((void *) state->buf) + state->buf_ptr + len;
+		val = state->buf_dma + state->buf_ptr;
         	nand_reg_write(node, NAND_DMA_ADDR, val);
 		nand_reg_write(node, NAND_DMA_ADDR_H, (val >> 32));
 
@@ -459,14 +463,15 @@ static void send_cmd(struct mtd_info *mtd,
         	} else {
                 	nand_reg_write(node, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
         	}
-
-		val = nand_reg_read(node, NAND_CTRL);
+		
+		val = nand_reg_read(node, NAND_CTRL) ;
                	nand_reg_write(node, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
         	nand_reg_write(node, NAND_CMD, command | NAND_CMD_DMA_FLAG);
-        	dma_wait(state->cs);
-		val = nand_reg_read(node, NAND_CTRL);
-        	nand_reg_write(node, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1))); 
-		printk_debug("len2 = %d \n", len2);
+		dma_wait(node, state->cs);
+		if (enable_hwecc)	{
+			val = nand_reg_read(node, NAND_CTRL);
+        		nand_reg_write(node, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1))); 
+		}
 	}
 
         state->last_cmd    = command;
@@ -477,9 +482,11 @@ static void cmdfunc(struct mtd_info *mtd,
                     int column,
                     int page_addr)
 {
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
-        int len = 0 ;
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
+       	int node = info->node; 
+	int len = 0 ;
         uint32_t val;
         
 	if (state->cs < 0)
@@ -494,7 +501,6 @@ static void cmdfunc(struct mtd_info *mtd,
                 column += 256;
         case NAND_CMD_READ0:
                 state->buf_ptr = 0;
-		printk_debug("column = %x, page_addr = %x, mtd->writesize = %d \n", column, page_addr, mtd->writesize);
                 send_cmd(mtd,
                          NAND_READ_PAGE_CMD,
                          column,
@@ -546,16 +552,16 @@ static void cmdfunc(struct mtd_info *mtd,
                     "page_addr: 0x%x, column: 0x%x.\n",
                     page_addr, column);
                 val = (page_addr >> (32 - (state->col_cyc*8)));
-		nand_reg_write(0, NAND_ADDR1_L, val);
+		nand_reg_write(node, NAND_ADDR1_L, val);
                 val = ((page_addr << (state->col_cyc * 8)));
-		nand_reg_write(0, NAND_ADDR0_L, val);
+		nand_reg_write(node, NAND_ADDR0_L, val);
 		break;
         /* ERASE2 uses the block and page address from ERASE1 */
         case NAND_CMD_ERASE2:
                 dbp_print("NAND_CMD_ERASE2, "
                     "addr 0x%x\n",
-		nand_reg_read(0, NAND_ADDR0_L));
-		nand_reg_write(0, NAND_CMD, NAND_ERASE_BLOCK_CMD);
+		nand_reg_read(node, NAND_ADDR0_L));
+		nand_reg_write(node, NAND_CMD, NAND_ERASE_BLOCK_CMD);
 		state->last_cmd         = NAND_ERASE_BLOCK_CMD ;
 		waitfunc(mtd,chip) ;
 		break;
@@ -582,13 +588,13 @@ static void cmdfunc(struct mtd_info *mtd,
 		break;
 
         case NAND_CMD_STATUS:
-                nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
+                nand_reg_write(node, NAND_CMD, NAND_READ_STATUS_CMD);
                 state->last_cmd = NAND_READ_STATUS_CMD;
                 dbp_print("Status read\n");
 		break;
         /* RESET command */
         case NAND_CMD_RESET:
-                nand_reg_write(0, NAND_CMD, NAND_RESET_CMD);
+                nand_reg_write(node, NAND_CMD, NAND_RESET_CMD);
                 state->last_cmd = NAND_RESET_CMD;
                 waitfunc(mtd,chip);
 		break;
@@ -600,10 +606,13 @@ static void cmdfunc(struct mtd_info *mtd,
 
 static void select_chip(struct mtd_info *mtd, int dev)
 {
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
-        if ( (dev >= 0) && (dev < 8) ) {
-                nand_reg_write(0, NAND_MEMCTRL, dev + NAND_DEV_CS);
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
+	int node = info->node;
+
+	if ( (dev >= 0) && (dev < 8) ) {
+                nand_reg_write(node, NAND_MEMCTRL, dev + NAND_DEV_CS);
 		state->cs = dev + NAND_DEV_CS;
         } else {
                 state->cs = -1;
@@ -612,18 +621,20 @@ static void select_chip(struct mtd_info *mtd, int dev)
 
 static uint8_t read_byte(struct mtd_info *mtd)
 {
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
-        uint32_t data ;
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
+	int node = info->node;
+        
+	uint32_t data ;
 
         if (state->cs < 0)
                 return 0;
 
-	printk_debug("%s \n",__FUNCTION__);
         if (state->last_cmd == NAND_READ_STATUS_CMD) {
-                data = nand_reg_read(0, NAND_READ_STATUS);
+                data = nand_reg_read(node, NAND_READ_STATUS);
                 dbp_print("Status: %x\n",data);
-                return nand_reg_read(0, NAND_READ_STATUS);
+                return nand_reg_read(node, NAND_READ_STATUS);
         } else {
                 data = state->buf[state->buf_ptr];
                 state->buf_ptr = (state->buf_ptr+1)%BUF_SIZE;
@@ -633,9 +644,10 @@ static uint8_t read_byte(struct mtd_info *mtd)
 
 static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
-        int i;
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
+	int i;
         
 	if (state->cs < 0)
                 return;
@@ -651,9 +663,10 @@ static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 
 static void write_buf(struct mtd_info *mtd, const u8 *buf, int len)
 {
+        struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
         int i=0;
-        struct nand_chip *chip = mtd->priv;
-        struct nand_state *state = chip->priv;
 
         if (state->cs < 0)
                 return;
@@ -670,7 +683,8 @@ static int read_page(struct mtd_info *mtd,
                      struct nand_chip *chip,
                      uint8_t *buf, int page)
 {
-        struct nand_state *state = chip->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
 
         if (state->cs < 0)
                 return -1;
@@ -685,7 +699,8 @@ static void write_page(struct mtd_info *mtd,
                        struct nand_chip *chip,
                        const uint8_t *buf)
 {
-        struct nand_state *state = chip->priv;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
 
         if (state->cs < 0)
                 return;
@@ -695,24 +710,27 @@ static void write_page(struct mtd_info *mtd,
 
 static int waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
 {
-        struct nand_state *state = chip->priv;
-        int timeout = 0xfffff;
+        struct nand_info *info = (struct nand_info *)chip->priv;
+        struct nand_state *state = (struct nand_state *)info->nand_state;
         uint32_t val;
+        int timeout = 0xfffff;
+	int node = info->node;
 
         if (state->cs < 0)
                 return -1;
-		val = nand_reg_read(0, NAND_STATUS);
+
+	val = nand_reg_read(node, NAND_STATUS);
         while ((val & (1 << state->cs)) == 0) {
                 timeout--;
                 if (timeout == 0) {
                         dbp_print("wait func out\n");
                         return -1 ;
                 }
-			val = nand_reg_read(0, NAND_STATUS);
+		val = nand_reg_read(node, NAND_STATUS);
 	}
 
-        nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
-        return nand_reg_read(0, NAND_READ_STATUS);
+        nand_reg_write(node, NAND_CMD, NAND_READ_STATUS_CMD);
+        return nand_reg_read(node, NAND_READ_STATUS);
 }
 
 /*
@@ -721,41 +739,54 @@ static int waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
 static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
 {
         struct plat_nand_data *data = NULL;
-        struct nand_state *state ;
+	struct nand_info *info = NULL;
+        struct nand_state *state = NULL;
         uint32_t val;
+	int node = pdev->id;
+
 
         data = (struct plat_nand_data *)(platform_get_drvdata(pdev));
-		
         if (!data) {
                 dev_err(&pdev->dev, "failed to get device structure.\n");
                 return -ENOMEM;
         }
-
-
-        nand_reg_write(0, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
-
+	
+	nand_reg_write(node, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
         val = ( NAND_TIME_SEQ0_TWHR(7) |
 		NAND_TIME_SEQ0_TRHW(7) |
 		NAND_TIME_SEQ0_TADL(7) |
 		NAND_TIME_SEQ0_TCCS(7) );
-	nand_reg_write(0, NAND_TIME_SEQ0, val);
+	nand_reg_write(node, NAND_TIME_SEQ0, val);
 	
         val = NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
-	nand_reg_write(0, NAND_TIMINGS_ASYN, val);
-	
-        state            = kmalloc(sizeof(struct nand_state), GFP_KERNEL);
+	nand_reg_write(node, NAND_TIMINGS_ASYN, val);
+
+        
+	info             = (struct nand_info *)kzalloc(sizeof(struct nand_info), GFP_KERNEL);
+	if(!info)	{
+		return -ENOMEM;
+	}
+
+        info->nand_state = (struct nand_state *)kzalloc(sizeof(struct nand_state), GFP_KERNEL);
+	if(!info->nand_state)	{
+		kfree(info);
+		return -ENOMEM;
+	}
+	state      	 = info->nand_state;
         state->last_cmd  = 0;
         state->cs        = 0;
         state->buf_ptr   = 0 ;
-        state->buf       = kmalloc(BUF_SIZE, GFP_KERNEL);
+	state->buf = dma_alloc_coherent(&(pdev->dev), BUF_SIZE, &(state->buf_dma), GFP_KERNEL);
 
-        data->chip.priv = state;
+	info->node = pdev->id;
+        
+	data->chip.priv  = (void *)info;
 
         data->chip.read_byte   	= read_byte ;
         data->chip.cmdfunc	= cmdfunc ;
         data->chip.waitfunc	= waitfunc ;
-
-	
+	data->io_base = ioremap(pdev->resource[0].start + 0x100,
+				pdev->resource[0].end - pdev->resource[0].start + 1);
 	if (enable_hwecc)
 		data->mtd.oobsize = XLP_HWECC_OOBSIZE;
 	else
@@ -769,6 +800,7 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
 
         data->chip.ecc.read_page  = read_page;
         data->chip.ecc.write_page = write_page;
+        
 
 #ifdef NAND_DEBUG
 	print_onfi_params(&data->chip.onfi_params);
@@ -822,25 +854,36 @@ static struct platform_nand_data xlp_nand_flash_data = {
 
 };
 
-struct platform_device xlp_nand_flash = {
-        .name   =       "gen_nand",
-        .id    =       XLP_DEVID_NAND,
-        .num_resources = 1,
-        .dev = {
-                .platform_data  = &xlp_nand_flash_data,
-        },
-        .resource = &xlp_nand_flash_resource,
-};
-
-
 int xlp_nand_flash_dev_init(void){
-        int res;
-	
-        xlp_nand_flash_resource.start  = (nlm_hal_get_dev_base(0, 0, XLP_PCIE_NAND_FLASH_DEV,XLP_PCIE_NAND)) +  0x100;
-        xlp_nand_flash_resource.end    = (xlp_nand_flash_resource.start) + (0x1000 -1) - 0x100;
-        res = platform_device_register(&xlp_nand_flash);
-        if (res)
-                printk("unable to register xlp-nand-flash: %d\n", res);
-       
-        return 0;
+         int i, devid;
+	 int total=num_online_nodes();
+	 struct platform_device* pplatdev = NULL;
+	 uint32_t val;
+	 volatile uint64_t mmio;
+
+
+	 for(i=0; i<total; i++) {
+		mmio = nlm_hal_get_dev_base(i, 0, XLP_PCIE_NAND_FLASH_DEV, XLP_PCIE_NAND);
+		val  = nlm_hal_read_32bit_reg(mmio, 0);
+
+		if(val != 0xFFFFFFFF) {
+			devid   = (val & 0xFFFF0000) >> 16;
+			if(devid != XLP_DEVID_NAND)
+				continue;
+			
+			xlp_nand_flash_resource.start  = mmio;
+			xlp_nand_flash_resource.end    = mmio + (0x1000 -1);
+		
+			pplatdev = platform_device_register_resndata( NULL, "gen_nand", i, 
+					&xlp_nand_flash_resource, 1, &xlp_nand_flash_data, sizeof(xlp_nand_flash_data));
+			if(pplatdev)	{
+				pplatdev->dev.dma_mask	= &xlp_dev_dmamask;
+				pplatdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+			}
+			
+			pplatdev = NULL;
+		}
+	}
+       	
+	return 0;
 }
-- 
1.8.4.93.g57e4c17

