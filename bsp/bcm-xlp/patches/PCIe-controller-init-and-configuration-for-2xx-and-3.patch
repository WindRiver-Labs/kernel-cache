From 8317f81f0cecff848a070de40a35a846b79775ef Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Mon, 14 Jan 2013 14:02:39 -0800
Subject: [PATCH 452/565] PCIe : controller init and configuration for 2xx and
 3xx

     Depending on the type of board, PCI controllers need
to be initialized and configured differently.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/pci/pci-xlp-msi.c |   6 ++
 arch/mips/pci/pci-xlp.c     | 157 ++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 151 insertions(+), 12 deletions(-)

diff --git a/arch/mips/pci/pci-xlp-msi.c b/arch/mips/pci/pci-xlp-msi.c
index 9aadb5d..0c34b5b 100644
--- a/arch/mips/pci/pci-xlp-msi.c
+++ b/arch/mips/pci/pci-xlp-msi.c
@@ -45,8 +45,14 @@ int setup_msi_base_address(void)
 	 * some memory and not use it for anything else.  */
 	/* We don't need 16M, all we need is 2 pages per controller
 	 * => 2 * 4ctr * 4 nodes pages */
+#ifdef CONFIG_32BIT
+	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL, get_order(0x100000));
+#else
+	/* We don't need 16M, all we need is 2 pages per controller
+	 * => 2 * 4ctr * 4 nodes pages */
 	XLP_MSI_ADDR = (u64)__get_free_pages(GFP_KERNEL,
 			get_order(size));
+#endif
 	if (XLP_MSI_ADDR == 0) {
 		printk(KERN_ERR "Failed to get memory for MSI/MSI-X tables\n");
 		return -ENOMEM;
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index b8f47de1..9af3062 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -258,21 +258,72 @@ u32 xlp_get_power_on_reset_cfg(int node)
 }
 EXPORT_SYMBOL(xlp_get_power_on_reset_cfg);
 
-
-/*
- * Called from system startup routine
- */
-static void pcie_controller_init_done(void)
+static void xlp_2xx_pcie_controller_init(void)
 {
 	u32 plc, syscfg, mode, count = 0, node = 0;
 
-#if defined CONFIG_PCI_MSI
-	BUG_ON(setup_msi_base_address() < 0);
-#endif
-	if (!pci_probe_only){
-		printk(KERN_WARNING "PCIe bus IRQs configured incorrectly\n");
-		return;
+	for_each_online_node(node) {
+	syscfg = xlp_get_power_on_reset_cfg(node);
+	/* We don't manipulate pci_address space.
+	 * Get the link status from pcie lane config from 34.9.7.2 XLP PRM */
+	mode = (syscfg >> 8) & 0xf;
+	while (count < 4) {
+		printk(KERN_DEBUG "Controller %d is in %s mode\n",
+				count, (mode & (1 << count)) ? "RC" : "EP");
+		count++;
 	}
+	plc = (syscfg >> 12) & 0x3;
+	printk(KERN_DEBUG "node %d, PLC = %#x, mode = %#x\n", node, plc, mode);
+
+	switch (plc) {
+	 /* The correlation between plc and lane config is very specific to XLP */
+	case 0:
+		/* controller 0 is active on x4 mode */
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		break;
+	case 1:
+		/* controllers 0 and 2 are active in x2 mode*/
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x4){
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		break;
+	case 2 ... 3:
+		/* controllers 0, 1, 2 and 3 are active in x1 mode*/
+		if (mode & 0x1){
+			xlp_map_helper(node, plc, 0);
+			xlp_pcie_controller_setup(node, 0);
+		}
+		if (mode & 0x2){
+			xlp_map_helper(node, plc, 1);
+			xlp_pcie_controller_setup(node, 1);
+		}
+		if (mode & 0x4){
+			xlp_map_helper(node, plc, 2);
+			xlp_pcie_controller_setup(node, 2);
+		}
+		if (mode & 0x8){
+			xlp_map_helper(node, plc, 3);
+			xlp_pcie_controller_setup(node, 3);
+		}
+		break;
+	}
+	dump_node_irqmap(node, plc);
+	}	/* for_each_online_node */
+	return;
+}
+
+static void xlp_8xx_pcie_controller_init(void)
+{
+	u32 plc, syscfg, mode, count = 0, node = 0;
+
 	for_each_online_node(node) {
 	syscfg = xlp_get_power_on_reset_cfg(node);
 	/* We don't manipulate pci_address space.
@@ -352,11 +403,93 @@ static void pcie_controller_init_done(void)
 		break;
 	}
 	dump_node_irqmap(node, plc);
-	printk(KERN_DEBUG "[%s]: PCIE Controller initialization done\n", __FUNCTION__);
 	}	/* for_each_online_node */
 	return;
 }
 
+static void xlp_3xx_pcie_controller_init(u32 pid)
+{
+	struct xlp_plc_fn_struct *nirqmap = &node_irqmap[0][0];
+	/* zero out node_irqmap */
+	memset(node_irqmap, 0, sizeof(struct xlp_plc_fn_struct) * NLM_MAX_CPU_NODE * XLP_PCI_LANE_CONFIG);
+	switch(pid) {
+		case CPU_EXTPID_XLP_3XX_L:
+			/* Single node, port 0 only in x4 lane mode*/
+			nirqmap->plc = 0;
+			nirqmap->farray[0].intno = XLP_PCIE_INTX_IRQ(0,0);
+			xlp_map_helper(0, 0, 0);
+			xlp_pcie_controller_setup(0, 0);
+			break;
+		case CPU_EXTPID_XLP_3XX_LP:
+			/* Port 0 and port 1 are active in x2 lane mode*/
+			nirqmap->plc = 0;
+			nirqmap->farray[0].intno = XLP_PCIE_INTX_IRQ(0,0);
+			nirqmap->farray[1].intno = XLP_PCIE_INTX_IRQ(0,1);
+			xlp_map_helper(0, 0, 0);
+			xlp_pcie_controller_setup(0, 0);
+			xlp_map_helper(0, 0, 1);
+			xlp_pcie_controller_setup(0, 1);
+			break;
+		case CPU_EXTPID_XLP_3XX_LP2:
+			/* All ports (0, 1, 2, 3) are active in x1 lane mode */
+			nirqmap->plc = 0;
+			nirqmap->farray[0].intno = XLP_PCIE_INTX_IRQ(0,0);
+			nirqmap->farray[1].intno = XLP_PCIE_INTX_IRQ(0,1);
+			nirqmap->farray[2].intno = XLP_PCIE_INTX_IRQ(0,2);
+			nirqmap->farray[3].intno = XLP_PCIE_INTX_IRQ(0,3);
+			xlp_map_helper(0, 0, 0);
+			xlp_pcie_controller_setup(0, 0);
+			xlp_map_helper(0, 0, 1);
+			xlp_pcie_controller_setup(0, 1);
+			xlp_map_helper(0, 0, 2);
+			xlp_pcie_controller_setup(0, 2);
+			xlp_map_helper(0, 0, 3);
+			xlp_pcie_controller_setup(0, 3);
+			break;
+		default:
+			printk(KERN_WARNING "Could not find a PCI interrupt allocation scheme\n");
+			break;
+	}
+	dump_node_irqmap(0, 0);
+}
+
+/*
+ * Called from system startup routine
+ */
+static void pcie_controller_init_done(void)
+{
+#if defined CONFIG_PCI_MSI
+	BUG_ON(setup_msi_base_address() < 0);
+#endif
+	if (!pci_probe_only){
+		printk(KERN_WARNING "PCIe bus IRQs configured incorrectly\n");
+		return;
+	}
+	/* Configure controllers for running cpu type */
+	if (is_nlm_xlp8xx()) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp8xx/4xx\n");
+		xlp_8xx_pcie_controller_init();
+	} else if (is_nlm_xlp2xx()) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp2xx\n");
+		xlp_2xx_pcie_controller_init();
+	} else if (is_nlm_xlp3xx_L(XLP_REVISION_ANY)) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp3xx_L\n");
+		xlp_3xx_pcie_controller_init(CPU_EXTPID_XLP_3XX_L);
+	} else if (is_nlm_xlp3xx_LP(XLP_REVISION_ANY)) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp3xx_LP\n");
+		xlp_3xx_pcie_controller_init(CPU_EXTPID_XLP_3XX_LP);
+	} else if (is_nlm_xlp3xx_LP2(XLP_REVISION_ANY)) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp3xx_LP2\n");
+		xlp_3xx_pcie_controller_init(CPU_EXTPID_XLP_3XX_LP2);
+	} else if (is_nlm_xlp3xx_B(XLP_REVISION_ANY)) {
+		printk(KERN_DEBUG "Initializing PCIe for xlp3xx\n");
+		/* ordinary 3xx and 8xx has same controller init seq. */
+		xlp_8xx_pcie_controller_init();
+	} else {
+		panic("Can't configure PCIe controller for unknown CPU type\n");
+	}
+}
+
 static inline __u32 pci_cfg_read_32bit(__u32 addr)
 {
 	__u32 temp = 0;
-- 
1.8.4.93.g57e4c17

