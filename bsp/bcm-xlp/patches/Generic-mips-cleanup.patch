From 6e34d411816d5b242643133f9aab1d3d8f7218c4 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Tue, 22 Jun 2010 14:08:51 +0530
Subject: [PATCH 076/565] Generic mips cleanup

Generic mips cleanup - boot_mem_map cleanup.

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/bootinfo.h          | 39 +++++--------------------------
 arch/mips/include/asm/netlogic/bootinfo.h | 25 ++++++++++++++++++++
 arch/mips/netlogic/common/bootinfo.c      | 24 +++++++++++++++++++
 arch/mips/netlogic/xlp/bootinfo.c         | 16 +++++++------
 4 files changed, 64 insertions(+), 40 deletions(-)
 create mode 100644 arch/mips/netlogic/common/bootinfo.c

diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index a6823d9..84e411b 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -77,15 +77,7 @@ the header of the original work apply to this derived work.
 #define MACH_LEMOTE_ML2F7      3
 #define MACH_LEMOTE_YL2F89     4
 #define MACH_DEXXON_GDIUM2F10  5
-#define MACH_LEMOTE_NAS        6
-#define MACH_LEMOTE_LL2F       7
-#define MACH_LOONGSON_END      8
-
-/*
- * Valid machtype for group INGENIC
- */
-#define  MACH_INGENIC_JZ4730	0	/* JZ4730 SOC		*/
-#define  MACH_INGENIC_JZ4740	1	/* JZ4740 SOC		*/
+#define MACH_LOONGSON_END      6
 
 #ifdef CONFIG_NLM_COMMON
 #define CL_SIZE			(2048)
@@ -102,7 +94,6 @@ extern unsigned long mips_machtype;
 #define BOOT_MEM_RAM		1
 #define BOOT_MEM_ROM_DATA	2
 #define BOOT_MEM_RESERVED	3
-#define BOOT_MEM_INIT_RAM	4
 
 /*
  * A memory map that's built upon what was determined
@@ -111,10 +102,10 @@ extern unsigned long mips_machtype;
 struct boot_mem_map {
 	int nr_map;
 	struct boot_mem_map_entry {
-		uint64_t addr;	/* start of memory segment */
-		uint64_t size;	/* size of memory segment */
-		uint32_t type;		/* type of memory segment */
-	} map[BOOT_MEM_MAP_MAX + 1];
+		phys_t addr;	/* start of memory segment */
+		phys_t size;	/* size of memory segment */
+		long type;		/* type of memory segment */
+	} map[BOOT_MEM_MAP_MAX];
 };
 
 extern struct boot_mem_map boot_mem_map;
@@ -130,7 +121,7 @@ extern void free_init_pages(const char *what,
 /*
  * Initial kernel command line, usually setup by prom_init()
  */
-extern char arcs_cmdline[COMMAND_LINE_SIZE];
+extern char arcs_cmdline[CL_SIZE];
 
 /*
  * Registers a0, a1, a3 and a4 as passed to the kernel entry by firmware
@@ -142,22 +133,4 @@ extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
  */
 extern void plat_mem_setup(void);
 
-#ifdef CONFIG_SWIOTLB
-/*
- * Optional platform hook to call swiotlb_setup().
- */
-extern void plat_swiotlb_setup(void);
-
-#else
-
-static inline void plat_swiotlb_setup(void) {}
-
-#endif /* CONFIG_SWIOTLB */
-
-#define MAX_EXCLUDE 16
-struct boot_mem_map_exclude_region {
-	uint64_t start;
-	uint64_t end;
-};
-
 #endif /* _ASM_BOOTINFO_H */
diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 555476f..3b19097 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -4,6 +4,25 @@
 #define LOADER_UBOOT   1
 #define LOADER_OTHER   2
 
+/* This is what netlboot passes and linux boot_mem_map is subtly different */
+struct nlm_boot_mem_map {
+	int nr_map;
+	struct nlm_boot_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;          /* type of memory segment */
+	} map[BOOT_MEM_MAP_MAX];
+};
+
+#define MAX_EXCLUDE 16
+struct boot_mem_map_exclude_region {
+	uint64_t start;
+	uint64_t end;
+};
+extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
+
+
+#ifdef CONFIG_NLM_XLP
 extern struct psb_info *prom_info;
 extern struct psb_info prom_info_copy;
 extern struct boot_mem_map prom_map;
@@ -14,6 +33,12 @@ extern int read_prominfo(void);
 extern int read_dram_info(void);
 extern int read_physaddr_map(void);
 
+#ifdef CONFIG_FDT
 extern int wakeup_secondary_cpus(void);
+#else
+extern int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), 
+		struct psb_info *prom_info);
+#endif
+#endif
 
 #endif
diff --git a/arch/mips/netlogic/common/bootinfo.c b/arch/mips/netlogic/common/bootinfo.c
new file mode 100644
index 0000000..c880180
--- /dev/null
+++ b/arch/mips/netlogic/common/bootinfo.c
@@ -0,0 +1,24 @@
+
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
+This is a derived work from software originally provided by the external
+entity identified below. The licensing terms and warranties specified in
+the header of the original work apply to this derived work.
+
+*****************************#NETL_1#********************************/
+
+#include <linux/kernel.h>
+#include <asm/bootinfo.h>
+#include <asm/netlogic/bootinfo.h>
+
+void copy_mem_map(struct boot_mem_map *dst, struct nlm_boot_mem_map *src)
+{
+	int i;
+
+	dst->nr_map = src->nr_map;
+	for(i=0; i < dst->nr_map; i++) {
+		dst->map[i].addr = (phys_t)src->map[i].addr;
+		dst->map[i].size = (phys_t)src->map[i].size;
+		dst->map[i].type = (long)src->map[i].type;
+	}
+}
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
index 1e37d95..bf87715 100644
--- a/arch/mips/netlogic/xlp/bootinfo.c
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -55,36 +55,38 @@ int read_prominfo(void)
 	return is_valid_prominfo(prom_info);
 }
 
+/* TODO: Need to add right code here for XLP here */
 int read_dram_info(void)
 {
-	struct boot_mem_map *map;
+	struct nlm_boot_mem_map *map;
 
 	if (!prom_info || (!prom_info->psb_mem_map && !prom_info->avail_mem_map)) 
 		return -1;
 
 	/* copy the mem_map from bootloader */
 	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
-		map = (struct boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
+		map = (struct nlm_boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
 	else
-		map = (struct boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
+		map = (struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
 	
 	if (!(map->nr_map > 0 && map->nr_map <= 32))
 		return -1;
 
-	memcpy (&prom_map, map,	sizeof(struct boot_mem_map));
+	copy_mem_map(&prom_map, map);
 	
 	return 0;
 }
 
+/* TODO: Is this valid for XLP ? */
 int read_physaddr_map(void)
 {
-	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+	struct nlm_boot_mem_map *physaddr_map = (struct nlm_boot_mem_map *)
+		((unsigned long)prom_info->psb_physaddr_map);
 
 	if (physaddr_map == NULL)
 		return -1;
 
-	memcpy(&boot_physaddr_info,  physaddr_map, sizeof(struct boot_mem_map));
+	copy_mem_map(&boot_physaddr_info,  physaddr_map);
 
 	return 0;
 }
-- 
1.8.4.93.g57e4c17

