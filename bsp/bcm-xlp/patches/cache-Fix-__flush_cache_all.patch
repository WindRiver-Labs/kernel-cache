From ba2f22cc08d2f55a7efdc886430698ffaac72c12 Mon Sep 17 00:00:00 2001
From: Ashok Kumar <ashoks@broadcom.com>
Date: Mon, 10 Dec 2012 16:49:42 +0530
Subject: [PATCH 437/565] cache: Fix __flush_cache_all

Pulled in from linux-2.6.32:

commit 38d71c50246bd1ab8c29f065490806f083b2793f
Author:     Ashok Kumar <ashoks@broadcom.com>
AuthorDate: Wed Sep 26 10:33:03 2012 +0530
Commit:     P. Sadik <psadik@broadcom.com>
CommitDate: Thu Sep 27 09:25:16 2012 +0530

    cache: Fix __flush_cache_all routine.

        Clearing probe valid array in addition to the valid array.

Based on Broadcom SDK 2.3.

Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h | 148 +++++++++++++++-----------
 arch/mips/netlogic/xlp/cpu_control_asm.S      |  24 +++++
 2 files changed, 111 insertions(+), 61 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index 8b91aaf..3f51e05 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -1,3 +1,32 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #ifndef _ASM_MACH_NLM_XLP_MMU_H
 #define _ASM_MACH_NLM_XLP_MMU_H
 
@@ -14,9 +43,6 @@
 #define ENABLE_128_TLB     0x20
 #define ENABLE_PGWALKER    0x8
 
-#define LSU_DEBUG_VALID_ARRAY		0
-#define LSU_DEBUG_PROBE_VALID_ARRAY	1
-
 #define USER_SEG 0
 
 #ifdef CONFIG_64BIT
@@ -28,11 +54,12 @@
 #define VMALLOC_SEG 1
 #endif /* CONFIG_64BIT */
 
-extern int is_cpu_core_xlp_ii;
 extern DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
 
 extern uint32_t nlm_l1_lock[NR_CPUS/4];
 
+extern int is_nlm_xlp2xx_compat;
+
 static inline void setup_user_pgd(pgd_t *pgd)
 {
 	get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
@@ -89,55 +116,50 @@ static inline void nlm_unlock_l1(uint32_t core)
 #define NLM_XLP_L1_MAXWAY       2
 #define NLM_XLP_L1_MAXINDX      128
 
-static inline void nlm_flush_l1_dcache_line(uint32_t index, uint32_t maxindex, uint32_t array)
+static inline void nlm_flush_l1_dcache_line(uint32_t line)
 {
          __asm__ __volatile__ (
                 "       .set push                       \n"
                 "       .set noat                       \n"
                 "       .set noreorder                  \n"
                 "       li $8, "STR(LSU_DEBUG_DATA0)"   \n"
+                "       mtcr $0, $8                     \n"
                 "       li $9, "STR(LSU_DEBUG_ADDR)"    \n"
-		"	li $10, 0			\n"
-		"	sll  %2, %2, 14			\n"
-		"	sll  %0, %0, 5			\n"
-		"	sll  %1, %1, 5			\n"
-		"1:					\n"
-		"	mtcr $0, $8			\n"
-		"	or  $10, %0, %2			\n"
-                "       ori $10, $10, 0x3              	\n"
-                "       mtcr $10, $9                    \n"
-                "2:                                     \n"
-                "       mfcr $11, $9                    \n"
-                "       andi $11, 0x1                	\n"
-                "       bnez $11, 2b                    \n"
+                "       ori %0, %0, 0x1                 \n"
+                "       mtcr %0, $9                     \n"
+                "1:                                     \n"
+                "       mfcr $8, $9                     \n"
+                "       andi $8, $8, 0x1                \n"
+                "       bnez $8, 1b                     \n"
                 "       nop                             \n"
-		"	mtcr $0, $8			\n"
-		"	ori  $10, $10, 0x7		\n"
-		"	mtcr $10, $9			\n"
-		"3:					\n"
-		"	mfcr $11, $9                    \n"
-		"       andi $11, 0x1                   \n"
-		"       bnez $11, 3b                    \n"
-		"	nop				\n"
-		"	addi %0, 0x20			\n"
-		"	bne  %1, %0, 1b			\n"
-		"	nop				\n"
                 "       .set pop                        \n"
-                : : "r"(index), "r"(maxindex), "r"(array) : "$8" , "$9", "$10", "$11");
+                : : "r"(line) : "$8" , "$9");
 }
 
 static inline void nlm_flush_l1_dcache(void)
 {
-        uint32_t index, max;
-	uint32_t cpu = read_c0_ebase() & 0x7f;
-        uint32_t thread = cpu & 0x3;
-        
-	nlm_lock_l1(cpu >> 2);
-	max = (thread + 1) * NLM_XLP_L1_MAXINDX;
-        index = thread * NLM_XLP_L1_MAXINDX;
-	nlm_flush_l1_dcache_line(index, max, LSU_DEBUG_VALID_ARRAY);
-	nlm_flush_l1_dcache_line(index, max, LSU_DEBUG_PROBE_VALID_ARRAY);
-	nlm_unlock_l1(cpu >> 2);
+    uint32_t index, line, max;
+    uint32_t cpu = read_c0_ebase() & 0x7f;
+    uint32_t thread = cpu & 0x3;
+
+    nlm_lock_l1(cpu >> 2);
+    max = (thread + 1) * current_cpu_data.dcache.sets;
+    index = thread * current_cpu_data.dcache.sets;
+
+    for(; index < max; index++) {
+
+        line = (index << 5) | (1<<1);
+        nlm_flush_l1_dcache_line(line);
+        line = (1 << 2) | (index << 5) | (1<<1);
+        nlm_flush_l1_dcache_line(line);
+
+        line = (index << 5) | (1<<1) | (0x1 << 14);
+        nlm_flush_l1_dcache_line(line);
+        line = (1 << 2) | (index << 5) | (1<<1) | (0x1 << 14);
+        nlm_flush_l1_dcache_line(line);
+    }
+
+    nlm_unlock_l1(cpu >> 2);
 }
 
 static __inline__ void pipeline_flush(void)
@@ -156,28 +178,32 @@ static __inline__ void pipeline_flush(void)
 		);
 }
 
+#ifdef CONFIG_32BIT
+#define disable_pgwalker(flags) (void)flags
+#define enable_pgwalker(flags) (void) flags
+#else
 #define disable_pgwalker(flags)						\
-	({                                                              \
-           if (!is_cpu_core_xlp_ii) {					\
-		flags = read_c0_config6();                              \
-		pipeline_flush();                                       \
-		write_c0_config6(flags & ~ENABLE_PGWALKER);             \
-		pipeline_flush();                                       \
- 	   }else {                                                      \
-	   flags = read_c0_pwctl();                                     \
-                pipeline_flush();                                       \
-                write_c0_pwctl(flags & ~(1 <<  PWCTL_PW_EN_O));         \
-                pipeline_flush();                                       \
-	   }                                                            \
+	({ if (!is_nlm_xlp2xx_compat) {				\
+	        flags = read_c0_config6();				\
+		pipeline_flush();					\
+		write_c0_config6(read_c0_config6() & ~ENABLE_PGWALKER);	\
+		pipeline_flush();					\
+	   } else { 							\
+	        flags = read_c0_pwctl();				\
+		pipeline_flush();					\
+		write_c0_pwctl(flags & ~(1 <<  PWCTL_PW_EN_O));		\
+		pipeline_flush();					\
+	   }								\
+	  })
+
+#define enable_pgwalker(flags)								\
+	({ 										\
+	    if (!is_nlm_xlp2xx_compat) {						\
+		write_c0_config6(read_c0_config6() | (flags & ENABLE_PGWALKER));	\
+	    } else {									\
+		write_c0_pwctl(read_c0_pwctl() | (flags & (1 << PWCTL_PW_EN_O)));	\
+	    }										\
 	})
 
-#define enable_pgwalker(flags)                                                	  	\
-        ({                                                                     		\
-            if (!is_cpu_core_xlp_ii) {                                         		\
-                write_c0_config6(read_c0_config6() | (flags | ENABLE_PGWALKER));	\
-            } else {                                                            	\
-                write_c0_pwctl(read_c0_pwctl() | (flags & (1 << PWCTL_PW_EN_O)));       \
-            }                                                 		                \
-        })
-
+#endif
 #endif
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 0d5dd7a..6a119a7 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -205,6 +205,30 @@
 	addi	t2, 1
 	bne	t3, t2, 1b
 	nop
+
+        li t2, 0
+4:
+        sll     v0, t2, 5
+        mtcr    zero, t0
+        ori     v1, v0, 0x4003
+        mtcr    v1, t1
+5:
+        mfcr    v1, t1
+        andi    v1, 0x1
+        bnez    v1, 5b
+        nop
+        mtcr    zero, t0
+        ori     v1, v0, 0x4007
+        mtcr    v1, t1
+6:
+        mfcr    v1, t1
+        andi    v1, 0x1
+        bnez    v1, 6b
+        nop
+        addi    t2, 1
+        bne     t3, t2, 4b
+        nop
+
 	.set pop
 .endm
 
-- 
1.8.4.93.g57e4c17

