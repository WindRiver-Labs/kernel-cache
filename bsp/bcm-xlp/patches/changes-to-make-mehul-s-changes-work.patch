From 088e3b908fcee4d9f08baf5a2281ec5d0746ae4f Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Date: Fri, 3 Dec 2010 13:50:58 -0800
Subject: [PATCH 180/565] changes to make mehul's changes work

Changes to make mehul's changes work with master branch

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/setup.c | 63 +++++++++++++++++++++---------------------
 1 file changed, 32 insertions(+), 31 deletions(-)

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 362739da..6a16eeb 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -414,6 +414,7 @@ static int fdt_process(void)
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
 	unsigned char buf[30];	
 	int j, id=0, k, tmp;
+	uint32_t onlinemask[MAX_CPUMASK_CELLS];
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -497,22 +498,24 @@ static int fdt_process(void)
 
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
-	/* extract CPU online mask for
-	 * domain 0 (linux)
+
+	/* 
+	 * extract CPU online mask for domain 0 (linux)
 	 */
+	for (i = 0; i < MAX_CPUMASK_CELLS; i++)
+		onlinemask[i] = 0;
+
 	sprintf(domstr, "/doms/dom@%d/cpu", domain);
 
 	node = finddevice(domstr);
 	if (node) {
 		uint32_t onlinemask_buf[MAX_CPUMASK_CELLS];
-		uint32_t onlinemask[MAX_CPUMASK_CELLS];
+
 		char buf[CPUMASK_BUF];
 
 		/* Initialize buffers */
-		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
+		for (i = 0; i < MAX_CPUMASK_CELLS; i++)
 			onlinemask_buf[i] = 0;
-			onlinemask[i] = 0;
-		}
 
 		/* Parse cpumask from FDT and handle endianness */
 		getprop(node, "onlinemask", &onlinemask_buf[0], sizeof(uint32_t) * cpu_cells);
@@ -525,16 +528,15 @@ static int fdt_process(void)
 		}
 
 		/* Store cpumask in predefined order */
-		for (i = 0; i < cpu_cells; i++) {
+		for (i = 0; i < cpu_cells; i++)
 			onlinemask[i] = onlinemask_buf[cpu_cells - 1 - i];
-		}
 
 		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
 			int j = 0;
 
 			for (j = 0; j < 32; j++) {
-				if ((onlinemask[i] & (1 << j)) == 0) continue;
-
+				if ((onlinemask[i] & (1 << j)) == 0) 
+					continue;
 				cpumask_set_cpu((i * 32 + j), &fdt_cpumask);
 			}
 		}
@@ -544,34 +546,34 @@ static int fdt_process(void)
 	}
 
 	node = finddevice("/doms/dom@0/fmn");
-	if (node){
-		for(i=0; i<NLM_MAX_CPU_NODE; i++){
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
 			sprintf(buf, "node_%d_vc_mask",i);
 			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
-			if(getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
-				/*If no mask is passed, derive it from cpu online mask*/
-				if(smp_node.onlinemask[i]){
-					for(j=0; j<NLM_MAX_CPU_PER_NODE; j++, id++){
-						if(smp_node.onlinemask[i] & (1<<j))
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask[i]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+						if (onlinemask[i] & (1 << j))
 							nlm_cpu_vc_mask[id] = 0xf;
 					}
 				}
-			}else{
-				/*Get vc mask from the fdt*/
-				for(j=0; j<4; j++){
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = 0; j < 4; j++) {
 					tmp = fdt32_to_cpu(node_vc_mask[j]);
-					for(k=0; k<8; k++){
-						nlm_cpu_vc_mask[id++] = (tmp>>(k*4)) & 0xf;
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
 					}
 				}
 			}
 		}
-	}else{
-		/*Derive vc mask from cpu online map*/
-		for(i=0; i<NLM_MAX_CPU_NODE; i++){
-			if(smp_node.onlinemask[i]){
-				for(j=0; j<NLM_MAX_CPU_PER_NODE; j++, id++){
-					if(smp_node.onlinemask[i] & (1<<j))
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
+			if (onlinemask[i]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+					if (onlinemask[i] & (1 << j))
 						nlm_cpu_vc_mask[id] = 0xf;
 				}
 			}
@@ -580,10 +582,9 @@ static int fdt_process(void)
 
 	sprintf(domstr, "/doms/dom@%d/uart", domain);
 	node = finddevice(domstr);
-	if(node){
-		if(getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid)) < 0){
+	if (node) {
+		if (getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid)) < 0)
 			return -1;
-		}
 	}
 
 	return 0;
-- 
1.8.4.93.g57e4c17

