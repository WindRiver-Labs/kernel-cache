From ae56867440f0d8ce82b58170c6487789f9edb342 Mon Sep 17 00:00:00 2001
From: Jayanthi Annadurai <jayanthia@netlogicmicro.com>
Date: Wed, 3 Aug 2011 07:13:46 -0700
Subject: [PATCH 237/565] L1 Dcache workaround

L1 Dcache workaround

Based on Broadcom SDK 2.3.

Signed-off-by: Jayanthi Annadurai <jayanthia@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h | 92 +++++++++++++++++++++++++++
 arch/mips/netlogic/xlp/cpu_control_asm.S      | 34 ++++++++++
 arch/mips/netlogic/xlp/on_chip.c              |  2 +
 3 files changed, 128 insertions(+)

diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index f52ca2e..259fe18 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -25,12 +25,104 @@
 
 extern DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
 
+extern uint32_t nlm_l1_lock[NR_CPUS/4];
+
 static inline void setup_user_pgd(pgd_t *pgd)
 {
 	get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
 	put_cpu_var(pgd_bases);
 };
 
+
+static inline void nlm_lock_l1(uint32_t core)
+{
+        uint32_t temp;
+        __asm__ __volatile__(
+                "       .set    noreorder       \n"
+                "1:     ll      %1, %2          \n"
+                "       bgtz    %1, 2f          \n"
+                "       ori     %1, 1           \n"
+                "       sc      %1, %0          \n"
+                "       beqz    %1, 1b          \n"
+                "       nop                     \n"
+                "       .subsection 2           \n"
+                "2:     ll      %1, %2          \n"
+                "       bgtz    %1, 2b          \n"
+                "       nop                     \n"
+                "       b       1b              \n"
+                "        nop                    \n"
+                "       .previous               \n"
+                "       .set    reorder         \n"
+                : "=m" (nlm_l1_lock[core]), "=&r" (temp)
+                : "m" (nlm_l1_lock[core])
+                : "memory");
+}
+
+static inline void nlm_unlock_l1(uint32_t core)
+{
+        uint32_t temp;
+
+        __asm__ __volatile__(
+                "       .set    noreorder 	         \n"
+                "1:     ll      %1, %2          	 \n"
+                "       sub     %1, 1                    \n"
+                "       sc      %1, %0                   \n"
+                "       beqz    %1, 2f                   \n"
+                "        nop                             \n"
+                "       .subsection 2                    \n"
+                "2:     b       1b                       \n"
+                "        nop                             \n"
+                "       .previous                        \n"
+                "       .set    reorder                  \n"
+                : "=m" (nlm_l1_lock[core]), "=&r" (temp)
+                : "m" (nlm_l1_lock[core])
+                : "memory");
+
+}
+
+#define NLM_XLP_L1_MAXWAY       2
+#define NLM_XLP_L1_MAXINDX      128
+#define LSU_DEBUG_DATA0         0x306
+#define LSU_DEBUG_ADDR          0x305
+
+static inline void nlm_flush_l1_dcache_line(uint32_t line)
+{
+         __asm__ __volatile__ (
+                "       .set push                       \n"
+                "       .set noat                       \n"
+                "       .set noreorder                  \n"
+                "       li $8, "STR(LSU_DEBUG_DATA0)"   \n"
+                "       mtcr $0, $8                     \n"
+                "       li $9, "STR(LSU_DEBUG_ADDR)"    \n"
+                "       ori %0, %0, 0x1                 \n"
+                "       mtcr %0, $9                     \n"
+                "1:                                     \n"
+                "       mfcr $8, $9                     \n"
+                "       andi $8, $8, 0x1                \n"
+                "       bnez $8, 1b                     \n"
+                "       nop                             \n"
+                "       .set pop                        \n"
+                : : "r"(line) : "$8" , "$9");
+}
+
+static inline void nlm_flush_l1_dcache(void)
+{
+        uint32_t index, line, max;
+	uint32_t cpu = read_c0_ebase() & 0x7f;
+        uint32_t thread = cpu & 0x3;
+        
+	nlm_lock_l1(cpu >> 2);
+	max = (thread + 1) * NLM_XLP_L1_MAXINDX;
+        index = thread * NLM_XLP_L1_MAXINDX;
+        for(;index < max ; index++) {
+        	line = (index << 5) | (1<<1);
+	        nlm_flush_l1_dcache_line(line);
+                line = (1 << 2) | (index << 5) | (1<<1);
+                nlm_flush_l1_dcache_line(line);
+        }
+	nlm_unlock_l1(cpu >> 2);
+}
+
 static __inline__ void pipeline_flush(void)
 {
 	__asm__ __volatile__ (
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index 39da2e7..949b3f1 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -82,6 +82,37 @@
 	.set pop
 .endm
 
+.macro	flush_l1_dcache
+	.set push
+	.set noreorder
+	li	t0, LSU_DEBUG_DATA0
+	li      t1, LSU_DEBUG_ADDR
+	li	t2, 0
+	li 	t3, 0x200
+1:
+	sll	v0, t2, 5	
+	mtcr	zero, t0
+	ori	v1, v0, 0x3
+	mtcr	v1, t1
+2:
+	mfcr	v1, t1
+	andi	v1, 0x1
+	bnez	v1, 2b
+	nop
+	mtcr    zero, t0
+	ori	v1, v0, 0x7
+	mtcr    v1, t1
+3:
+	mfcr    v1, t1
+	andi    v1, 0x1
+	bnez    v1, 3b
+	nop
+	addi	t2, 1
+	bne	t3, t2, 1b
+	nop
+	.set pop
+.endm
+
 	/* T0 of Non-0 Cores jump
 	 * here, from enable_cores
 	 * This code sits in KSEG0
@@ -140,6 +171,9 @@ EXPORT(boot_siblings_start)			/* "Master" (n0c0t0) cpu starts from here */
 	sync
 
 EXPORT(__boot_siblings)				/* T0 of every core in every node starts from here */
+
+	flush_l1_dcache
+
 	mfc0    t3, CP0_EBASE, 1
 	srl     t3, t3 , 2
 	and     t3, t3 , 0x7  			/* t3 contains the core number */
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 9cb2e79..1591743 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -55,6 +55,8 @@ extern void nlm_cpu_stat_update_msgring_pic_int(void);
 uint32_t msgring_global_thread_mask = 0;
 uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
 
+uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
+
 /* make this a read/write spinlock */
 spinlock_t msgrng_lock;
 
-- 
1.8.4.93.g57e4c17

