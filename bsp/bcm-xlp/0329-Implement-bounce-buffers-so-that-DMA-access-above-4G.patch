From f3e6ff85b6e62a810ca16080bd733e7c8448d064 Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Thu, 15 Sep 2011 10:11:34 -0700
Subject: [PATCH 329/762] Implement bounce buffers so that DMA access above 4GB ram can succeed. Required for MMC.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/card/queue.c   |    4 ++++
 drivers/mmc/core/bus.c     |    4 ++++
 drivers/mmc/core/mmc_ops.c |    4 ++++
 drivers/mmc/core/sd.c      |    8 ++++++++
 drivers/mmc/host/xlpmmc.c  |    7 +++++++
 5 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 996f8e3..6c923ea 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -200,7 +200,11 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 			bouncesz = host->max_blk_count * 512;
 
 		if (bouncesz > 512) {
+#ifdef CONFIG_MMC_XLP
+			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL|GFP_DMA);
+#else
 			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+#endif
 			if (!mqrq_cur->bounce_buf) {
 				pr_warning("%s: unable to "
 					"allocate bounce cur buffer\n",
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index c60cee9..b9448c2 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -236,7 +236,11 @@ struct mmc_card *mmc_alloc_card(struct mmc_host *host, struct device_type *type)
 {
 	struct mmc_card *card;
 
+#ifdef CONFIG_MMC_XLP
+	card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL|GFP_DMA);
+#else
 	card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);
+#endif
 	if (!card)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 69370f4..3a4ce7e 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -243,7 +243,11 @@ mmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,
 	/* dma onto stack is unsafe/nonportable, but callers to this
 	 * routine normally provide temporary on-stack buffers ...
 	 */
+#ifdef CONFIG_MMC_XLP
+	data_buf = kmalloc(len, GFP_KERNEL|GFP_DMA);
+#else
 	data_buf = kmalloc(len, GFP_KERNEL);
+#endif
 	if (data_buf == NULL)
 		return -ENOMEM;
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c272c68..2c858b6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -282,7 +282,11 @@ static int mmc_read_switch(struct mmc_card *card)
 
 	err = -EIO;
 
+#ifdef CONFIG_MMC_XLP
+	status = kmalloc(64, GFP_KERNEL|GFP_DMA);
+#else
 	status = kmalloc(64, GFP_KERNEL);
+#endif
 	if (!status) {
 		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n",
@@ -382,7 +386,11 @@ int mmc_sd_switch_hs(struct mmc_card *card)
 
 	err = -EIO;
 
+#ifdef CONFIG_MMC_XLP
+	status = kmalloc(64, GFP_KERNEL|GFP_DMA);
+#else
 	status = kmalloc(64, GFP_KERNEL);
+#endif
 	if (!status) {
 		pr_err("%s: could not allocate a buffer for "
 			"switch capabilities.\n", mmc_hostname(card->host));
diff --git a/drivers/mmc/host/xlpmmc.c b/drivers/mmc/host/xlpmmc.c
index b0d2254..d6a6774 100644
--- a/drivers/mmc/host/xlpmmc.c
+++ b/drivers/mmc/host/xlpmmc.c
@@ -474,6 +474,13 @@ static int xlpmmc_prepare_data(struct xlpmmc_host *host,
 
 	if(host->flags & HOST_F_DMA){
 		struct scatterlist *sg = &data->sg[0];
+#if 0
+		if(sg_phys(sg) >= (4ULL<<30)){
+			extern void dump_stack(void);
+			printk(">4G ADDR: sg_phys(sg) = %#lx\n",sg_phys(sg));
+			dump_stack();
+		}
+#endif
 		hc_wr32(host->base, HC_SDMA_SA_OR_ARG2_LO, (unsigned long)sg_phys(sg), 0);
 	}else{	
 		host->pio.index = 0;
-- 
1.7.0.4

