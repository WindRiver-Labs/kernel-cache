From bfbfbf8217ceef0caadc24a560df4dc045a8f57a Mon Sep 17 00:00:00 2001
From: Vishvambhar Dayal <vishvambhard@netlogicmicro.com>
Date: Fri, 27 May 2011 21:32:31 +0530
Subject: [PATCH 283/762] cpu bootup logic to use logical cpus.

Based on Broadcom SDK 2.3.

Signed-off-by: Vishvambhar Dayal <vishvambhard@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c |    9 +++++++++
 arch/mips/netlogic/xlp/smp.c         |   16 ++++++++++++----
 2 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 905c242..d56fa1b 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -131,6 +131,15 @@ int threads_to_enable = 0;
 /*
  * This function is called once for each node. However, it is executed
  * only on "master cpu", mostly on n0c0t0
+ *
+ * t0_bitmap: bitmap of thread@0 of those cores in the given node, which 
+ *            are enabled in node_cpumask
+ *
+ * cores_bitmap: bitmap of cores (core 0's) which have at least one thread
+ *               enabled (considering ALL nodes and cores)
+ *
+ * threads_to_enable: count bitmap of threads to enable in all enabled cores.
+ *
  */
 void enable_cpus(unsigned int node, unsigned int node_cpumask)
 {
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 6c481d2..32f703b 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -60,8 +60,9 @@ extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
 
-void nlm_send_ipi_single(int cpu, unsigned int action)
+void nlm_send_ipi_single(int logical_cpu, unsigned int action)
 {
+	int cpu = cpu_logical_map(logical_cpu);
         __u32 node = cpu / 32;
         __u32 ipi = 0;
 	__u8 nmi = 0;
@@ -129,10 +130,13 @@ void nlm_cpus_done(void)
 
 /* Boot all other cpus in the system, initialize them, and
    bring them into the boot fn */
-void nlm_boot_secondary(int cpu, struct task_struct *idle)
+void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
+	int cpu = cpu_logical_map(logical_cpu);
+	
+	printk("nlm_boot_secondary: logical cpu %d physical cpu %d\n", logical_cpu, cpu);
 
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -162,6 +166,7 @@ void __init nlm_smp_setup(void)
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
 	num_cpus = 1;
+	cpu_set(0, cpu_possible_map);
 
 	/* Setup map for other cpus */
 	for (i = 0; i < NR_CPUS; i++) {
@@ -172,15 +177,18 @@ void __init nlm_smp_setup(void)
 
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
+			cpu_set(num_cpus, cpu_possible_map);
 
 			num_cpus++;
 		}
 	}
 
-	cpu_present_map = cpu_possible_map = fdt_cpumask;
+	cpu_present_map = cpu_possible_map;
 
+	cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
+	printk("FDT CPU map %s\n", buf);
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
-	printk("Possible/Present/FDT CPU map %s\n", buf);
+	printk("Possible/Present CPU map %s\n", buf);
 
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
 }
-- 
1.7.0.4

