From ed2ed5de35664b4f5a589e1a6be9d7e1b40b5f6d Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Mon, 26 Nov 2012 13:59:01 -0800
Subject: [PATCH 753/760] 16g_support: wire the first memory region above dma region

  o If the first memory region above dma region is not wired by default,
    wire it. This memory region is used before the exception handlers
    are properly set up.

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/kernel/setup.c           |   16 ++++++++++++++++
 arch/mips/netlogic/common/memory.c |   18 ++++++++++++++++++
 2 files changed, 34 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2384ce9..0d1e5a4 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -56,6 +56,10 @@ EXPORT_SYMBOL(cpu_data);
 struct screen_info screen_info;
 #endif
 
+#if defined(CONFIG_NLM_16G_MEM_SUPPORT) && !defined(CONFIG_NUMA)
+unsigned long non_dma_start_pfn = 0;
+#endif
+
 /*
  * Despite it's name this variable is even if we don't have PCI
  */
@@ -422,6 +426,18 @@ static void __init bootmem_init(void)
 			continue;
 #endif
 
+#if defined(CONFIG_NLM_16G_MEM_SUPPORT) && !defined(CONFIG_NUMA)
+		{
+			/* 40 bit physical address, min_start_pfn is the minimum above dma region */
+			unsigned long max_dma_pfn = (MAX_DMA_ADDRESS & 0xffffffffffULL) >> PAGE_SHIFT;
+
+			if (start >= max_dma_pfn) {
+				if (non_dma_start_pfn == 0 || non_dma_start_pfn > start)
+					non_dma_start_pfn = start;
+			}
+		}
+#endif
+
 		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), 0);
 	}
 
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index 34e254d..a499f29 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -214,6 +214,8 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 #ifdef CONFIG_NUMA
 		int node;
 		extern struct nlm_node_mem_info node_mem_info[];
+#else
+		extern unsigned long non_dma_start_pfn;
 #endif
 		/*
 		 * the primary cpu reads the memory map and records
@@ -277,6 +279,22 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 			tlb.wired = TRUE;
 			setup_tlb(&tlb, pagesize);
 		}
+#else
+		/* Wire the first non-dma-region entry if it is above the MAX_WIRED_PFN.
+		 * Apparently, kernel tries to grab the memory from there.
+		 */
+		if (non_dma_start_pfn >= MAX_WIRED_PFN) {
+			paddr = PFN_PHYS(non_dma_start_pfn);
+			if (paddr % ( 2 * LARGEST_TLBPAGE_SZ))
+				paddr -= (paddr % (2 * LARGEST_TLBPAGE_SZ));
+
+			vaddr = KERNEL_SEG_START + paddr;
+			tlb.entryHi = vaddr;
+			tlb.entrylo0 = page_entrylo(paddr, attr);
+			tlb.entrylo1 = page_entrylo(paddr + pagesize, attr);
+			tlb.wired = TRUE;
+			setup_tlb(&tlb, pagesize);
+		}
 #endif
 	}
 }
-- 
1.7.0.4

