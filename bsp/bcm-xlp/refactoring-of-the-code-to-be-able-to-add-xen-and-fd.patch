From f4dd588dc8d27daa15de0b6407f5bdab845647d1 Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@kanton.razamicroelectronics.com>
Date: Wed, 12 May 2010 21:07:51 -0700
Subject: [PATCH 016/761] refactoring of the code to be able to add xen and
 fdt functionality

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@kanton.razamicroelectronics.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/bootinfo.h |   20 +++++++
 arch/mips/include/asm/netlogic/sim.h      |    2 +-
 arch/mips/netlogic/xlp/Makefile           |    3 +
 arch/mips/netlogic/xlp/bootinfo.c         |   91 +++++++++++++++++++++++++++++
 arch/mips/netlogic/xlp/irq.c              |   19 +++---
 arch/mips/netlogic/xlp/smp.c              |   56 ++++++++++++++----
 6 files changed, 169 insertions(+), 22 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/bootinfo.h
 create mode 100644 arch/mips/netlogic/xlp/bootinfo.c

diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
new file mode 100644
index 0000000..1454abc
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -0,0 +1,20 @@
+#ifndef _ASM_NETLOGIC_BOOTINFO_H
+#define _ASM_NETLOGIC_BOOTINFO_H
+
+#define LOADER_UBOOT   1
+#define LOADER_OTHER   2
+
+extern struct psb_info *prom_info;
+extern struct psb_info prom_info_copy;
+extern struct boot_mem_map prom_map;
+extern struct boot_mem_map boot_physaddr_info;
+
+extern int read_cmdline_args(int *argc, char *n_argv[], char *n_envp[]);
+extern int read_prominfo(void);
+extern int read_dram_info(void);
+extern int read_physaddr_map(void);
+
+extern int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), 
+								 struct psb_info *prom_info);
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
index 5269360..9a75b1b 100644
--- a/arch/mips/include/asm/netlogic/sim.h
+++ b/arch/mips/include/asm/netlogic/sim.h
@@ -438,7 +438,7 @@ static __inline__ int is_xls_b0(void)
 
 #define NR_CORES 8
 #define NR_CPUS_PER_CORE 4
-#define NLM_MAX_ARGS 64
+#define NLM_MAX_ARGS 32
 #define NLM_MAX_ENVS 32
 
 #endif /* _ASM_SIM_H */
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index e6a575e..f7133cd 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -10,3 +10,6 @@ obj-y += irq.o time.o on_chip.o mmu.o
 obj-$(CONFIG_NLM_XLP) += platform-xlp.o
 obj-$(CONFIG_SMP)      += smp.o smpboot.o
 obj-$(CONFIG_KGDB)      += nmi.o
+obj-y += bootinfo.o
+
+
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
new file mode 100644
index 0000000..0df3f80
--- /dev/null
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -0,0 +1,91 @@
+#include <linux/stddef.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/netlogic/sim.h>
+#include <asm/netlogic/bootinfo.h>
+#include <xen/interface/xen.h>
+
+static int is_valid_prominfo(struct psb_info *info)
+{
+	if (!prom_info) 
+		return -1;
+  
+	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef) 
+		return -1;
+
+	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION) 
+		return -1;
+
+	return 0;
+}
+
+int read_cmdline_args(int *argc, char *n_argv[], char *n_envp[])
+{
+	char **argv, **envp;
+	int i;
+	int32_t *t_argv;
+
+	*argc = (int)fw_arg0;
+	argv = (char **)(unsigned long)(int)fw_arg1;
+	envp = (char **)(unsigned long)(int)fw_arg2;
+
+		
+	for (i = 0, t_argv = (int32_t *)argv; i < *argc; i++, t_argv++)
+		n_argv[i] = (char *)(unsigned long)(*t_argv);
+
+		if (envp != NULL) {
+			int32_t *t_envp;
+
+			for (i = 0, t_envp = (int32_t *)envp; *t_envp; i++) {
+				n_envp[i] = (char *)(unsigned long)(*t_envp);
+				t_envp++;
+		}
+	}
+
+	return 0;
+}
+
+int read_prominfo(void)
+{
+	prom_info = &prom_info_copy;
+
+	memcpy((void *)prom_info, (void *)(unsigned long)(int)fw_arg3, 
+		   sizeof(struct psb_info));
+	
+	return is_valid_prominfo(prom_info);
+}
+
+int read_dram_info(void)
+{
+	struct boot_mem_map *map;
+
+	if (!prom_info || (!prom_info->psb_mem_map && !prom_info->avail_mem_map)) 
+		return -1;
+
+	/* copy the mem_map from bootloader */
+	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
+		map = (struct boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
+	else
+		map = (struct boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
+	
+	if (!(map->nr_map > 0 && map->nr_map <= 32))
+		return -1;
+
+	memcpy (&prom_map, map,	sizeof(struct boot_mem_map));
+	
+	return 0;
+}
+
+int read_physaddr_map(void)
+{
+	struct boot_mem_map *physaddr_map = 
+		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+
+	if (physaddr_map == NULL)
+		return -1;
+
+	memcpy(&boot_physaddr_info,  physaddr_map, sizeof(struct boot_mem_map));
+
+	return 0;
+}
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index f69fd51..fea53bf 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -76,11 +76,11 @@ void dump_irt_entry(short no)
 void dumpall_irt_entry(void)
 {
 	short i;
+
 	printk("IRT:\tEn\tRVec\tDB\tDTE\n");
+
 	for (i = 0; i < PIC_NUM_IRTS; i++)
-	{
 		dump_irt_entry(i);
-	}
 }
 
 static unsigned int __maybe_unused pic_startup(unsigned int irq)
@@ -91,8 +91,7 @@ static unsigned int __maybe_unused pic_startup(unsigned int irq)
 	unsigned long irt;
 
 	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
+	if (irt == -1)	{
 		printk("can't find irt for irq: %d\n",irq);
 		return -1;
 	}
@@ -108,7 +107,7 @@ static unsigned int __maybe_unused pic_startup(unsigned int irq)
 	/* netlogic_write_reg(mmio, PIC_IRT_1_BASE + irq_to_irt(irq), reg | (1<<31)); */
 	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), reg|(1 << 28)|(1 << 31));
-	printk("[%s] Writing IRT reg %lu with IRQ %d\n", __FUNCTION__,irt, irq);
+	printk("[%s] Writing IRT reg %ld with IRQ %d\n", __FUNCTION__,irt, irq);
 
 	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 
@@ -210,25 +209,25 @@ static void __maybe_unused pic_shutdown(unsigned int irq)
 	 */
 	reg = nlm_hal_read_pic_reg(mmio, PIC_IRT(irt));
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt), (reg & ~(1 << 31)));
-	printk("[%s] disable IRT %lu with IRQ %d\n", __FUNCTION__,PIC_IRT(irt), irq);
+	printk("[%s] disable IRT %ld with IRQ %d\n", __FUNCTION__,PIC_IRT(irt), irq);
 
 	spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 }
 
 static int __maybe_unused pic_set_affinity(unsigned int irq, const struct cpumask *mask)
 {
-	pic_reg_t *mmio __maybe_unused = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+#ifdef XLP_MERGE_TODO
+	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+#endif
 	unsigned long flags;
 	unsigned long irt;
 
 	irt = find_irt_from_irq(irq);
-	if(irt == -1)
-	{
+	if (irt == -1) {
 		printk("can't find irt for irq: %d\n",irq);
 		return -1;
 	}
 
-
 	spin_lock_irqsave(&nlm_common_pic_lock, flags);
 #ifdef XLP_MERGE_TODO
 	nlm_hal_write_pic_reg(mmio, PIC_IRT(nlm_hal_irq_to_irt(irq)),(uint32_t) (mask->bits[0]));
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 75d6b86..203ac91 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -56,7 +56,6 @@ extern void prom_reconfigure_thr_resources(void);
 extern uint32_t nlm_common_loader_mask;
 extern unsigned long nlm_common_ebase;
 
-
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
 cpumask_t phys_cpu_present_map;
 extern void asmlinkage smp_bootstrap(void);
@@ -89,7 +88,7 @@ static void __cpuinit nlm_init_secondary(void)
 void nlm_smp_finish(void)
 {
 #if !defined(CONFIG_NLM_XLP)
-    nlm_common_msgring_cpu_init();
+    phoenix_msgring_cpu_init();
 #endif
 }
 
@@ -118,12 +117,6 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 /* 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); */
 }
 
-extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
-struct smp_boot_info smp_boot;
-extern void prom_reconfigure_thr_resources(void);
-extern uint32_t nlm_common_loader_mask;
-extern unsigned long nlm_common_ebase;
-
 unsigned int fast_syscall_cpumask_phy = 0x1;
 
 void __init nlm_smp_setup(void)
@@ -229,9 +222,50 @@ void prom_boot_cpus_secondary(void *args)
 		     smp_boot.boot_info[cpu].gp);
 }
 
+#ifdef CONFIG_NLM_XLP
+
+extern void prom_pre_boot_secondary_cpus(void *);
+extern uint32_t xlr_linux_cpu_mask;
+ 
+#ifdef CONFIG_MAPPED_KERNEL
+#define secondary_cpus_bootup_func \
+       ((unsigned long)prom_pre_boot_secondary_cpus - \
+        (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
+#else
+#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
+#endif
 
+int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), struct psb_info *prom_info)
+{
+	__u32 wakeup_mask;
+#if defined(CONFIG_NLM_XLP_SIM)
+	unsigned int wait_count = 0;
+#endif
 
-#ifdef CONFIG_NLM_XLP
-/* place holder for boot multiple cpu function */
+	if (xlr_loader_support) {
+		wakeup_mask = xlr_linux_cpu_mask | nlm_common_loader_mask;
+		if (wakeup != NULL)
+			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
+	} 
+	else {
+		if (wakeup != NULL) {
+			wakeup((void *)secondary_cpus_bootup_func, 0, 
+				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
+#if defined(CONFIG_NLM_XLP_SIM)
+			while (smp_boot.online_map != prom_info->nlm_cpu_online_map) {
+				if ((wait_count++ % 1000000) == 0) {
+					printk("[%s%d]: Master cpu waiting for slave cpus to wakeup from bootloader (%x != %llx)\n",
+					       __FUNCTION__, __LINE__, smp_boot.online_map, 
+						   (unsigned long long) prom_info->nlm_cpu_online_map);
+				}
+			}
+			printk("[%s@%d]: woke up prom_info->nlm_cpu_online_map=%016llx\n", __FILE__, __LINE__, 
+				   (unsigned long long) prom_info->nlm_cpu_online_map);
+#endif
+		}
+	}
+
+	return 0;
+}
 
-#endif //CONFIG_NLM_XLP
+#endif /* #ifdef CONFIG_NLM_XLP */
-- 
1.7.10.4

