From 4e4131b728a458acc479c86d174d69374942a8ec Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 6 Jul 2011 15:20:21 +0800
Subject: [PATCH 06/10] nlm_xlp_64_be: Add kexec/kdump support

Basic Kexec/kdump support is added for XLP832 board with the
following limitations:

  o Only UP is supported by the second kernel, so "nosmp" argument
  needs to be passed by kexec-tools.

  o USB doesn't work in the second kernel.

More details:

  o Simplify the kernel specific support for kexec booting

    kexec booting differs from traditional booting and needs specific
    support, a is_kexec_boot() is added to determine whether the kernel
    is booted by kexec and hence simply the whole soure code.

  o Reserving memory of DTB needed by the 2nd kernel

    XLP need DTB to describe some of the devices, currently, we don't
    support loading a new DTB for the 2nd kernel but simply reserve the
    memory of DTB in the 1st kernel. A kexeck_res struct is added for
    this support.

  o Ignore original wakeup of the secondary cpus

    The secondary cpus are not initialized before entering into the 1st
    kernel and hence are needed to be waken up in hardware methods, but
    for the 2nd kernel, those cpus are put into loops, which are only
    needed to be waken up by setting a flag. But setting a flag is not
    enough, the waking up order of the secondary cpus may be not the
    same as the order in the 1st kernel, therefore, the related
    operations in prom_boot_cpus_secondary() and nlm_boot_secondary()
    should be changed. Of course, the waking up operation:
    wakeup_secondary_cpus() should be changed too. This will be done in
    the future, we only support UP for the 2nd kernel currently, so,
    "nosmp" argument should be passed to the 2nd kernel.

  o Kdump specific memory map

    The memory map of dump-capture kernel(the 2nd kernel) is set by
    kexec-tools automatically, we can not re-config it with the
    description in DTS.

  o More

    + Fix and Enhance nlm_local_flush_tlb_all(), nlm_common_flush_l1_caches_ipi()
    + Add kexec_flush_icache_page() for MIPS, based on powerpc.
    + prom_init() is moved after setup_early_printk() to make debugging
      available in fdt_process()

These changes are derived from the kexec support for the XLR732-based
boards completed in the previous release.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
Signed-off-by: Guojian Zhou <guojian.zhou@windriver.com>
---
 arch/mips/include/asm/kexec.h                   |    7 +
 arch/mips/include/asm/mach-netlogic/nlm_kexec.h |   48 +++++
 arch/mips/kernel/machine_kexec.c                |    8 +
 arch/mips/kernel/relocate_kernel.S              |  161 +++++++++++++---
 arch/mips/kernel/setup.c                        |   15 ++-
 arch/mips/netlogic/common/Makefile              |    1 +
 arch/mips/netlogic/common/nlm_kexec.c           |  234 +++++++++++++++++++++++
 arch/mips/netlogic/xlp/setup.c                  |  129 ++++++++-----
 8 files changed, 526 insertions(+), 77 deletions(-)
 create mode 100644 arch/mips/include/asm/mach-netlogic/nlm_kexec.h
 create mode 100644 arch/mips/netlogic/common/nlm_kexec.c

diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index 54302d4..b282f83 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -33,7 +33,14 @@ static inline void crash_setup_regs(struct pt_regs *newregs,
 }
 
 #ifdef CONFIG_KEXEC
+
+#define kexec_flush_icache_page(page) do {			\
+	unsigned long addr = (unsigned long)page_address(page);	\
+	flush_icache_range(addr, addr + PAGE_SIZE);		\
+} while (0)
+
 struct kimage;
+extern struct resource kexeck_res;
 extern unsigned long kexec_args[4];
 extern int (*_machine_kexec_prepare)(struct kimage *);
 extern void (*_machine_kexec_shutdown)(void);
diff --git a/arch/mips/include/asm/mach-netlogic/nlm_kexec.h b/arch/mips/include/asm/mach-netlogic/nlm_kexec.h
new file mode 100644
index 0000000..035a131
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/nlm_kexec.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2011 Windriver Systems, Inc.
+ * Author: Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _NLM_KEXEC
+#define _NLM_KEXEC
+
+#ifndef NLM_HAL_LINUX_KERNEL
+#define NLM_HAL_LINUX_KERNEL
+#endif
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-exts.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+#include <asm/setup.h>
+
+/* DTB is about 9kb */
+#define DTB_SIZE	(1 << 14)	/* 16kb */
+#define DTB_ORDER	((DTB_SIZE >> PAGE_SHIFT) - 1)
+
+#ifndef MAX_PROP_LEN
+#define MAX_PROP_LEN 256
+#endif
+
+#define KEXEC_CMDLINE_OFFSET (DTB_SIZE - MAX_PROP_LEN - 1)
+#define kexec_cmdline_addr(base) (base + KEXEC_CMDLINE_OFFSET)
+
+#define KEXEC_BOOT_FLAG	0xebebebeb
+
+static inline bool is_kexec_boot(void)
+{
+	return fw_arg3 == KEXEC_BOOT_FLAG;
+}
+
+#endif /* _NLM_KEXEC */
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index cbdb9be..96fe604 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -25,6 +25,14 @@ void (*_machine_crash_shutdown)(struct pt_regs *regs);
 void (*_machine_cache_flush)(void) = NULL;
 void (*_machine_smp_handle_restart)(unsigned long reloc) = NULL;
 
+/* Location of the reserved area for the kexec kernel */
+struct resource kexeck_res = {
+	.name  = "Kexec Kernel",
+	.start = 0,
+	.end   = 0,
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
+
 int
 machine_kexec_prepare(struct kimage *kimage)
 {
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 4324671..28950e6 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -14,12 +14,25 @@
 #include <asm/stackframe.h>
 #include <asm/addrspace.h>
 
+/* These are taken from linux/kexec.h and should always be in sync */
+#ifndef IND_DESTINATION
+#define IND_DESTINATION  0x1
+#endif
+#ifndef IND_INDIRECTION
+#define IND_INDIRECTION  0x2
+#endif
+#ifndef IND_DONE
+#define IND_DONE         0x4
+#endif
+#ifndef IND_SOURCE
+#define IND_SOURCE       0x8
+#endif
 
 LEAF(relocate_new_kernel)
-     PTR_L a0,    arg0
-     PTR_L a1,    arg1
-     PTR_L a2,    arg2
-     PTR_L a3,    arg3
+	PTR_L		a0, arg0
+	PTR_L		a1, arg1
+	PTR_L		a2, arg2
+	PTR_L		a3, arg3
 
 	PTR_LA		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
@@ -28,44 +41,37 @@ process_entry:
 	PTR_L		s2, (s0)
 	PTR_ADD		s0, s0, SZREG
 
-	/* destination page */
-	and		s3, s2, 0x1
+	/* destination page, store it in s4 */
+	and		s3, s2, IND_DESTINATION
 	beq		s3, zero, 1f
 	nop
-	and		s4, s2, ~0x1	/* store destination addr in s4 */
-
-	nop
+	and		s4, s2, ~IND_DESTINATION
 	b		process_entry
 	nop
 
 1:
 	/* indirection page, update s0  */
-	and		s3, s2, 0x2
+	and		s3, s2, IND_INDIRECTION
 	beq		s3, zero, 1f
 	nop
-	and		s0, s2, ~0x2
-
-	nop
-
+	and		s0, s2, ~IND_INDIRECTION
 	b		process_entry
 	nop
 
 1:
-	/* done page */
-	and		s3, s2, 0x4
+	/* done page, stop */
+	and		s3, s2, IND_DONE
 	beq		s3, zero, 1f
 	nop
-
-	nop
 	b		done
 	nop
 
 1:
-	/* source page */
-	and		s3, s2, 0x8
+	/* source page?: copy; if not, skip it (we somehow got crap) */
+	and		s3, s2, IND_SOURCE
 	beq		s3, zero, process_entry
 	nop
-	and		s2, s2, ~0x8
+	and		s2, s2, ~IND_SOURCE
 	li		s6, (1 << PAGE_SHIFT) / SZREG
 
 copy_word:
@@ -81,7 +87,6 @@ copy_word:
 	nop
 
 1:
-	nop
 	b 		process_entry
 	nop
 
@@ -92,7 +97,7 @@ done:
         of kexec_flag.  */
 
 	.align	3
-	bal	1f
+	bal	1f	/* MUST be first instruction in done: */
 	nop
 1:
 	.align	3
@@ -100,8 +105,8 @@ done:
 	move		t1, ra;
 	PTR_LA		t2, done
 	PTR_LA		t0, kexec_flag
-	PTR_SUB		t0, t0, t2;
-	PTR_ADD		t0, t1, t0;
+	PTR_SUBU	t0, t0, t2;
+	PTR_ADDU	t0, t1, t0;
 	LONG_S		zero, (t0)
 #endif
 
@@ -111,13 +116,43 @@ done:
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 	cache	0, 0($0)
 #endif
+#ifdef CONFIG_CPU_XLP
+	bal     kexec_nlm_flush_cache
+	nop
+#endif
 
 	/* jump to kexec_start_address */
 	j		s1
 	nop
-	nop
-	nop
-	END(relocate_new_kernel)
+END(relocate_new_kernel)
+
+#ifdef CONFIG_CPU_XLP
+LEAF(kexec_nlm_flush_cache)
+	/* From RMI's boot1/cache.S, but implemented with only 2 regs. */
+	/* FIXME: Obtain size and num cache lines from CP0 config1 reg.
+	 *        (Try to do the following with 2 regs in that case!)
+	 */
+	li		t9,0
+1:
+	li		t8,0x80000000
+	sll		t9,t9,5
+	add		t8,t8,t9
+	sra		t9,t9,5
+	cache		0,0(t8)
+	cache		1,0(t8)
+	addiu		t9,1
+	slti		t8,t9,1024
+	bnez		t8,1b
+	 nop
+	/* pipeline flush */
+	dla		t8, 2f
+	jr.hb 		t8
+	 nop
+	2: nop
+	jr		ra
+	 nop
+END(kexec_nlm_flush_cache)
+#endif /* CONFIG_CPU_XLP */
 
 #ifdef CONFIG_SMP
 /*
@@ -161,8 +196,76 @@ wait:
 	j        s1
 	nop
 	END(kexec_smp_wait)
-#endif
 
+#ifdef CONFIG_CPU_XLP
+/* OK, RMI is interesting. The secondary CPUs do NOT start at the kernel entry,
+ * but rather are signalled to jump to an address in the second kernel, which
+ * is part of the RMI-specific init sequence called within setup_arch().
+ *
+ * The boot CPU calls a routine installed by the boot loader in boot loader
+ * memory. We have to mimic this by installing a routine in the control page.
+ * This routine will simply set a variable to 1, signalling the secondary CPUs
+ * that they can get out of their spin. The routine also installs a function
+ * pointer that tells the secondary CPUs to jump to a routine (namely
+ * prom_pre_boot_secondary_cpus()) in the second kernel.
+ *
+ * When computing addresses of relocated symbols here, we need the functions
+ * to be double-word aligned, since the pointers are 64-bit, to avoid taking
+ * non-aligned exceptions (the exception handlers are invalid at this point).
+ * The computations are done relative to the start of the functions so that
+ * the start point is aligned. We can't perform computation based on return
+ * addresses and forward symbols since the assembler might add NOPs after
+ * branches and thus throw the computation off, possibly giving a 4-byte
+ * aligned address instead of an 8-byte aligned one.
+ */
+
+LEAF(kexec_nlm_secondary_cpu_spin)
+	.align	3
+	bal	1f      /* MUST be first instruction */
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-8 /* -8 *if* bal is first instruction */
+	PTR_LA		t0,kexec_nlm_secondary_cpu_spin
+	PTR_LA		v0,kexec_secondary_cpu_spin_var
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated spin_var */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+2:
+	LONG_L		t1,(v0)
+	beq		t1,zero,2b
+	nop
+
+	/* out of the spin loop, kexec_secondary_cpu_next_kernel_entry_point
+	 * now contains the address where to jump to in the second kernel
+	 *
+	 * t0 still contains address of non-relocated
+	 * kexec_nlm_secondary_cpu_spin()
+	 */
+	PTR_LA		v0,kexec_secondary_cpu_next_kernel_entry_point
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated entry_pt */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+	PTR_L		t1,(v0)
+	bal		kexec_nlm_flush_cache
+	nop
+	jr		t1
+	nop
+END(kexec_nlm_secondary_cpu_spin)
+
+	.align	3
+kexec_secondary_cpu_spin_var:
+EXPORT(kexec_secondary_cpu_spin_var)
+	LONG	0x0
+	.size	kexec_secondary_cpu_spin_var, PTRSIZE
+
+	.align	3
+kexec_secondary_cpu_next_kernel_entry_point:
+EXPORT(kexec_secondary_cpu_next_kernel_entry_point)
+	PTR	0x0
+	.size	kexec_secondary_cpu_next_kernel_entry_point, PTRSIZE
+
+#endif /* CONFIG_CPU_XLP */
+
+#endif /* CONFIG_SMP */
 
 #ifdef __mips64
        /* all PTR's must be aligned to 8 byte in 64-bit mode */
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 597339b..3432c56 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -609,6 +609,12 @@ static void __init arch_mem_init(char **cmdline_p)
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
 #endif
 #ifdef CONFIG_KEXEC
+	pr_info("Kexeckernel info: start = %llu end = %llu\n",
+		kexeck_res.start, kexeck_res.end);
+	if (kexeck_res.start != kexeck_res.end)
+		reserve_bootmem(kexeck_res.start,
+			kexeck_res.end - kexeck_res.start + 1, 0);
+
 	pr_info("Crashkernel info:\n");
 	pr_info("\tstart=%llu end=%llu\n", crashk_res.start, crashk_res.end);
 	if (crashk_res.start != crashk_res.end)
@@ -673,7 +679,10 @@ static void __init resource_init(void)
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
 #ifdef CONFIG_KEXEC
-		request_resource(res, &crashk_res);
+		if (kexeck_res.end != 0)
+			request_resource(res, &kexeck_res);
+		if (crashk_res.end != 0)
+			request_resource(res, &crashk_res);
 #endif
 	}
 }
@@ -684,11 +693,13 @@ void __init setup_arch(char **cmdline_p)
         is_cpu_core_xlp_ii = is_nlm_xlp2xx();
 
 	cpu_probe();
-	prom_init();
 
 #ifdef CONFIG_EARLY_PRINTK
 	setup_early_printk();
 #endif
+
+	prom_init();
+
 	cpu_report();
 	check_bugs_early();
 
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 9915ba3..92a40c5 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_eeprom.o fdt_helper.o
 obj-$(CONFIG_XLP_NAE_SUPPORT)		+= nlm_hal_mdio.o nlm_hal_vsemi_config.o nlm_hal_nae_interface.o
 obj-$(CONFIG_XLP_NAE_SUPPORT)		+= nlm_hal_nae.o 
 obj-$(CONFIG_XLP_FMN_SUPPORT)		+= nlm_hal_fmn_config.o
+obj-$(CONFIG_KEXEC)                   	+= nlm_kexec.o
 
 ifeq ($(CONFIG_NLM_CORTINA_SUPPORT),y)
 EXTRA_CFLAGS += -DNLM_CORTINA_SUPPORT
diff --git a/arch/mips/netlogic/common/nlm_kexec.c b/arch/mips/netlogic/common/nlm_kexec.c
new file mode 100644
index 0000000..9efa05f
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_kexec.c
@@ -0,0 +1,234 @@
+/*
+ * nlm_kexec.c, kexec support for NLM XLR832-based boards
+ *
+ * Copyright (c) 20011 Wind River Systems, Inc.
+ * Author:     Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Author:     Benjamin Walsh <benjamin.walsh@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-exts.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/ioport.h>
+
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+
+#define WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS 10000
+
+static int nlm_kexec_prepare(struct kimage *);
+static void nlm_kexec_shutdown(void);
+static void nlm_smp_handle_restart(unsigned long reloc);
+static void nlm_crash_shutdown(struct pt_regs *regs);
+static void nlm_do_cache_flush(void);
+extern void nlm_local_flush_tlb_all(void);
+
+static int rebooting_cpu = -1;
+static cpumask_t cpus_in_reboot = CPU_MASK_NONE;
+
+#ifdef CONFIG_SMP
+void (*relocated_kexec_nlm_secondary_cpu_spin) (void);
+atomic_t kexec_relocate_kernel_ready = ATOMIC_INIT(0);
+extern void kexec_nlm_secondary_cpu_spin(void);
+#endif
+
+extern const unsigned char relocate_new_kernel[];
+extern const size_t relocate_new_kernel_size;
+
+extern int (*_machine_kexec_prepare) (struct kimage *);
+extern void (*_machine_kexec_shutdown) (void);
+extern void (*_machine_crash_shutdown) (struct pt_regs *regs);
+extern void (*_machine_cache_flush) (void);
+extern void (*_machine_smp_handle_restart) (unsigned long reloc);
+
+void nlm_local_flush_tlb_all(void)
+{
+	unsigned long old_ctx;
+	int entry;
+	int tlbsize;
+
+	/* Refer to arch/mips/netlogic/xlp/mmu.c */
+	tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = (read_c0_entryhi() & 0xff);
+	write_c0_entrylo0(0);
+	write_c0_entrylo1(0);
+	for (entry = 0; entry < tlbsize; entry++) {
+		write_c0_entryhi(((unsigned long)CKSEG0 +
+				  (PAGE_SIZE << 1) * entry));
+		write_c0_index(entry);
+		mtc0_tlbw_hazard();
+		tlb_write_indexed();
+	}
+	tlbw_use_hazard();
+	write_c0_entryhi(old_ctx);
+}
+
+void nlm_kexec_init(void)
+{
+	_machine_kexec_prepare = nlm_kexec_prepare;
+	_machine_kexec_shutdown = nlm_kexec_shutdown;
+	_machine_crash_shutdown = nlm_crash_shutdown;
+	_machine_cache_flush = nlm_do_cache_flush;
+	_machine_smp_handle_restart = nlm_smp_handle_restart;
+
+	/* Resource need to be reserved: DTB, command line */
+	kexeck_res.start = __pa(fw_arg0);
+	kexeck_res.end = kexeck_res.start + DTB_SIZE - 1;
+}
+
+extern void nlm_common_flush_l1_caches_ipi(void *info);
+
+static void nlm_do_cache_flush(void)
+{
+	nlm_common_flush_l1_caches_ipi(NULL);
+}
+
+static void shutdown_secondary_cpus(void *crash)
+{
+	struct pt_regs *regs = NULL;
+	int cpu;
+
+	if ((unsigned long)crash)
+		regs = task_pt_regs(current);
+
+	local_irq_disable();
+	cpu = smp_processor_id();
+
+	if (!cpu_online(cpu))
+		return;
+
+	if (!cpu_isset(cpu, cpus_in_reboot)) {
+		if (regs)
+			crash_save_cpu(regs, cpu);
+		cpu_set(cpu, cpus_in_reboot);
+	}
+
+	while (!atomic_read(&kexec_relocate_kernel_ready))
+		cpu_relax();
+
+	nlm_local_flush_tlb_all();
+	relocated_kexec_nlm_secondary_cpu_spin();
+	/* NOTREACHED */
+}
+
+extern void fixup_irqs(unsigned int cpu, int flag);
+
+static void prepare_cpus(const unsigned long crash)
+{
+	int cpu;
+
+	smp_call_function(shutdown_secondary_cpus, (void *)crash, 0);
+	smp_wmb();
+	local_irq_disable();
+	/* Reset some devices for rebooting */
+	for_each_online_cpu(cpu)
+		fixup_irqs(cpu, 0);
+}
+
+static void wait_for_cpus(void)
+{
+	unsigned int msecs;
+	unsigned int ncpus = num_online_cpus();
+	unsigned int rebooting_cpus;
+
+	rebooting_cpu = smp_processor_id();
+	cpu_set(rebooting_cpu, cpus_in_reboot);
+
+	msecs = WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS;
+	while ((rebooting_cpus = cpus_weight(cpus_in_reboot)) < ncpus) {
+		if (--msecs <= 0)
+			break;
+		cpu_relax();
+		mdelay(1);
+	}
+}
+
+static int nlm_kexec_prepare(struct kimage *kimage)
+{
+	void *kexec_cmdline;
+	struct kexec_segment *s;
+	char buffer[32];
+	int len, i;
+
+	/* handle the arguments passed by kexec-tools */
+	for (i = 0; i < kimage->nr_segments; i++) {
+		s = &kimage->segment[i];
+		len = min(32, (int)s->bufsz);
+		copy_from_user((void *)buffer, s->buf, len);
+		buffer[len] = 0; /* just in case... */
+		if (strncmp(buffer, "kexec ", 6) == 0)
+			break;
+	}
+	kexec_cmdline = kexec_cmdline_addr(fw_arg0);
+	if (i != kimage->nr_segments) {
+		copy_from_user(kexec_cmdline,
+			(char *)kimage->segment[i].buf,
+			kimage->segment[i].bufsz);
+		pr_debug("%s: cmdline from kexec-tools:\n%s\n", __func__, (char *)(kexec_cmdline));
+	}
+
+	kexec_args[0] = fw_arg0;
+	kexec_args[1] = fw_arg1;
+	kexec_args[2] = fw_arg2;
+	/* Use this flag to check whether boot from kexec */
+	kexec_args[3] = KEXEC_BOOT_FLAG;
+
+	return 0;
+}
+
+static void nlm_kexec_shutdown(void)
+{
+	prepare_cpus(0);
+	wait_for_cpus();
+	nlm_local_flush_tlb_all();
+}
+
+static void nlm_crash_shutdown(struct pt_regs *regs)
+{
+	crash_save_cpu(regs, smp_processor_id());
+	prepare_cpus(1);
+	wait_for_cpus();
+	nlm_local_flush_tlb_all();
+}
+
+#ifdef CONFIG_SMP
+static void nlm_smp_handle_restart(unsigned long reloc)
+{
+	/* All secondary cpus now may jump to kexec_wait cycle */
+	relocated_kexec_smp_wait =
+	    (void *)(reloc + (kexec_smp_wait - relocate_new_kernel));
+	relocated_kexec_nlm_secondary_cpu_spin =
+	    (void *)(reloc + ((ulong) kexec_nlm_secondary_cpu_spin -
+			      (ulong) relocate_new_kernel));
+	smp_wmb();
+	atomic_set(&kexec_relocate_kernel_ready, 1);
+}
+#else
+static void nlm_smp_handle_restart(unsigned long reloc)
+{
+}
+#endif	/* CONFIG_SMP */
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index fcd0fa4..2981886 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -64,6 +64,7 @@
 #include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/xlp_irq_map.h>
 #include <asm/netlogic/phnx_loader.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
 #include "../boot/ops.h"
 #include <asm/netlogic/hal/nlm_hal.h>
 /* Certain macros for this file
@@ -599,6 +600,26 @@ static int __init fdt_process(void)
 	 */
 	void *blob = (void *)fw_arg0;
 	void *node;
+	int have_kexec_cmdline = 0;
+	int boot_for_kdump = 0;
+
+	if (is_kexec_boot()) {
+		/* Copy out the cmdline from the kexec control page reserved by parent kernel */
+		memset(prop_buf, '\0', MAX_PROP_LEN);
+		pr_debug("%s: copy cmdline from %p\n", __func__, kexec_cmdline_addr(blob));
+		memcpy(prop_buf, kexec_cmdline_addr(blob), MAX_PROP_LEN);
+		pr_debug("%s: cmdline = \n%s\n", __func__, prop_buf);
+		if (strncmp(prop_buf, "kexec ", 6) == 0) {
+			have_kexec_cmdline = 1;
+			/* elfcorehdr= is passed by kexec-tools when
+			 * booting from kernel panic.
+			 */
+			if ((strstr(prop_buf, "elfcorehdr=")) != NULL) {
+				pr_debug("%s: Boot from kernel panic\n", __func__);
+				boot_for_kdump = 1;
+			}
+		}
+	}
 
 	cpumask_clear(&fdt_cpumask);
 	cpumask_clear(&fdt_loadermask);
@@ -622,63 +643,71 @@ static int __init fdt_process(void)
 
 	/* extract cmdline params
 	 */
-	node = finddevice("/chosen");
-	if (node) {
-		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
-			return -1;
+	if (have_kexec_cmdline) {
+		/* If kexec-tools passes kernel arguments, we ignore the
+		 * ones passed from DTS to avoid duplication.
+		 */
 		strcat(arcs_cmdline, prop_buf);
+	} else {
+		node = finddevice("/chosen");
+		if (node) {
+			if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+				return -1;
+			strcat(arcs_cmdline, prop_buf);
+		}
 	}
 
 	/* extract memory ranges,
 	 * add to command line
 	 */
-	node=finddevice("/");
-	if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
-			na = 1;
-	else
-		na = fdt32_to_cpu(na);
-	if (na < 1 || na > 2)
-		printk("Can't cope with #address-cells == %d.\n\r", na);
-
-	if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
-		ns = 1;
-	else
-		ns = fdt32_to_cpu(ns);
-	if (ns < 1 || ns > 2)
-		printk("Can't cope with #size-cells == %d.\n\r", ns);
-
-	node = finddevice("/memory");
-	if (node) {
-		entries = (getprop(node, "reg", regs, MAX_PROP_LEN)) / sizeof(regs[0]);
-		if (!entries || (entries % (na+ns)))
-			printk("Invalid Memory Map Specified!\n");
+	if (!boot_for_kdump) {
+		node=finddevice("/");
+		if (getprop(node, "#address-cells", &na, sizeof(na)) < 0)
+				na = 1;
+		else
+			na = fdt32_to_cpu(na);
+		if (na < 1 || na > 2)
+			printk("Can't cope with #address-cells == %d.\n\r", na);
 
-		for (i=0; i<entries; i+=na+ns) {
-			int base = i;
-			uint64_t addr, size;
+		if (getprop(node, "#size-cells", &ns, sizeof(ns)) < 0)
+			ns = 1;
+		else
+			ns = fdt32_to_cpu(ns);
+		if (ns < 1 || ns > 2)
+			printk("Can't cope with #size-cells == %d.\n\r", ns);
 
-			addr = fdt32_to_cpu(regs[base++]);
-			if (na == 2)
-			{
-				/* handle 2 address-cells (ie. 64-bits of address) */
-				addr <<= 32;
-				addr |= fdt32_to_cpu(regs[base++]);
-			}
+		node = finddevice("/memory");
+		if (node) {
+			entries = (getprop(node, "reg", regs, MAX_PROP_LEN)) / sizeof(regs[0]);
+			if (!entries || (entries % (na+ns)))
+				printk("Invalid Memory Map Specified!\n");
+
+			for (i=0; i<entries; i+=na+ns) {
+				int base = i;
+				uint64_t addr, size;
+
+				addr = fdt32_to_cpu(regs[base++]);
+				if (na == 2)
+				{
+					/* handle 2 address-cells (ie. 64-bits of address) */
+					addr <<= 32;
+					addr |= fdt32_to_cpu(regs[base++]);
+				}
 
-			size = fdt32_to_cpu(regs[base++]);
-			if (ns == 2)
-			{
-				/* handle 2 size-cells (ie. 64-bits of size) */
-				size <<= 32;
-				size |= fdt32_to_cpu(regs[base++]);
-			}
+				size = fdt32_to_cpu(regs[base++]);
+				if (ns == 2)
+				{
+					/* handle 2 size-cells (ie. 64-bits of size) */
+					size <<= 32;
+					size |= fdt32_to_cpu(regs[base++]);
+				}
 
-			sprintf(domstr, " mem=%lldm@%lldm ", (size >> 20), (addr >> 20));
-			strcat(arcs_cmdline, domstr);
-			memset((void *)&domstr, '\0', sizeof(domstr));
+				sprintf(domstr, " mem=%lldm@%lldm ", (size >> 20), (addr >> 20));
+				strcat(arcs_cmdline, domstr);
+				memset((void *)&domstr, '\0', sizeof(domstr));
+			}
 		}
 	}
-
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
 	node = finddevice("/doms/dom@0");
@@ -1028,6 +1057,9 @@ int nlm_config_ici(void)
 
 #endif
 
+#ifdef CONFIG_KEXEC
+extern void nlm_kexec_init(void);
+#endif
 void __init prom_init(void)
 {
 	unsigned int c0status;
@@ -1074,7 +1106,12 @@ void __init prom_init(void)
 
 	register_smp_ops(&nlm_smp_ops);
 
-	wakeup_secondary_cpus();
+	if (!is_kexec_boot())
+		wakeup_secondary_cpus();
+
+#ifdef CONFIG_KEXEC
+	nlm_kexec_init();
+#endif
 }
 
 void prom_free_prom_memory(void)
-- 
1.7.2.1

