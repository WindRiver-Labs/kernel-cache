From 1583043ac33d97af80fac637416939c55fac2b8f Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Thu, 22 Sep 2011 17:51:40 -0700
Subject: [PATCH 335/762] Fix for setting ITE masks too early

ITE of PIC must be initialized after cpus are bought online. Changed init
function to accept a parameter so that it can be used at the time of
hot insertion/removal of cpus as well.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/on_chip.c |   25 ++++++++++++-------------
 arch/mips/netlogic/xlp/smp.c     |    3 +++
 2 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index ae7a01e..fe1ae01 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -468,7 +468,7 @@ void enable_msgconfig_int(void)
  * These are programmer defined groups and can be changed as warranted.
  */
 static struct cpumask xlp_ite_cpumask[XLP_ITE_ENTRIES];
-void xlp_pic_ite_init(void)
+void xlp_pic_ite_init(const struct cpumask *tgt_mask)
 {
 	int i;
 	struct cpumask m;
@@ -482,34 +482,34 @@ void xlp_pic_ite_init(void)
 	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
 		cpumask_clear(&xlp_ite_cpumask[i]);
 	}
-	cpumask_set_cpu(cpumask_first(cpu_online_mask), &xlp_ite_cpumask[0]);
+	cpumask_set_cpu(cpumask_first(tgt_mask), &xlp_ite_cpumask[0]);
 
 	/* Set 0-31 cpus, if present in cpu_online mask */
-	for (i = cpumask_first(cpu_online_mask); i < 32; ) {
+	for (i = cpumask_first(tgt_mask); i < 32; ) {
 		bitmask |= (1ULL << i);
-		i = cpumask_next(i, cpu_online_mask);
+		i = cpumask_next(i, tgt_mask);
 	}
-	cpumask_scnprintf(buf, 140, cpu_online_mask); fdebug("cpu_online_mask -> %s\n", buf);
-	cpumask_copy(&xlp_ite_cpumask[1], cpu_online_mask);
+	cpumask_scnprintf(buf, 140, tgt_mask); fdebug("Target cpumask -> %s\n", buf);
+	cpumask_copy(&xlp_ite_cpumask[1], tgt_mask);
 
 	/* Set 0-7 cpus */
 	for (i = 0; i < 8; i++) {
 		cpumask_set_cpu(i, &m);
 	}
 	/* logical and with cpuonline mask to get the actual mask */
-	cpumask_and(&xlp_ite_cpumask[2], &m, cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[2], &m, tgt_mask);
 	cpumask_shift_left(&xlp_ite_cpumask[3], &m, 8);
-	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], tgt_mask);
 	cpumask_shift_left(&xlp_ite_cpumask[4], &m, 16);
-	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], tgt_mask);
 	cpumask_shift_left(&xlp_ite_cpumask[5], &m, 24);
-	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], tgt_mask);
 
 	cpumask_shift_left(&xlp_ite_cpumask[6], &m, 8);
 	cpumask_or(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], &m);
 	cpumask_shift_left(&xlp_ite_cpumask[7], &xlp_ite_cpumask[6], 16);
-	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], cpu_online_mask);
-	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], cpu_online_mask);
+	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], tgt_mask);
+	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], tgt_mask);
 
 
 	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
@@ -605,7 +605,6 @@ static void pic_init(void)
 
 	/* On XLP, MSGRING config register is per hw-thread */
 	enable_msgconfig_int();
-	xlp_pic_ite_init();// Initialize even if xlp is passed nopci option
 }
 
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 8c2b5e2..e668509 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -64,6 +64,7 @@ extern void enable_cpus(unsigned int node, unsigned online_mask);
 extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
+extern void xlp_pic_ite_init(const struct cpumask *);
 
 void nlm_send_ipi_single(int cpu, unsigned int action)
 {
@@ -196,6 +197,8 @@ void __init nlm_smp_setup(void)
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
 	printk("Possible CPU map %s\n", buf);
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
+	/* Setup PIC with cpu_present_mask */
+	xlp_pic_ite_init((const struct cpumask *)&cpu_present_map);
 }
 
 #ifdef CONFIG_XEN
-- 
1.7.0.4

