From 1cd251a2edd205139fbf7ac7fae8cb58709f06e8 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Tue, 17 Aug 2010 18:52:40 -0700
Subject: [PATCH 140/762] add xlp_cpu on entry on /proc to support cpu stats collection

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/common/cpu_proc.c |   52 +++++++++++++++++++--------------
 arch/mips/netlogic/xlp/on_chip.c     |   17 ++++++++++-
 2 files changed, 46 insertions(+), 23 deletions(-)

diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 2e83e7d..33fe483 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -43,7 +43,7 @@ extern struct proc_dir_entry *nlm_root_proc;
 extern void nlm_update_tlb_stats(void *ignored);
 #endif
 
-struct xlr_cpu_stat {
+struct nlm_cpu_stat {
 	unsigned long long msgring_pic_int;
 	unsigned long long msgring_int;
 	unsigned long long msgring_cycles;
@@ -51,8 +51,8 @@ struct xlr_cpu_stat {
 	unsigned long long rdhwr_exp;
 };
 
-struct xlr_cpu_stat xlr_cpu_stats[32];
-__u64 xlr_cp2_exceptions[32];
+struct nlm_cpu_stat nlm_cpu_stats[NR_CPUS];
+__u64 nlm_cp2_exceptions[NR_CPUS];
 
 extern unsigned long long nlm_common_tlb_stats[];
 
@@ -64,7 +64,7 @@ void nlm_cpu_stat_update_rdhwr(void)
 	preempt_disable();
 
 	cpu = hard_smp_processor_id();
-	xlr_cpu_stats[cpu].rdhwr_exp++;
+	nlm_cpu_stats[cpu].rdhwr_exp++;
 
 	preempt_enable();
 }
@@ -76,7 +76,7 @@ void nlm_cpu_stat_update_fp(void)
 	preempt_disable();
 
 	cpu = hard_smp_processor_id();
-	xlr_cpu_stats[cpu].fp_exp++;
+	nlm_cpu_stats[cpu].fp_exp++;
 
 	preempt_enable();
 }
@@ -88,7 +88,7 @@ void nlm_cpu_stat_update_msgring_int(void)
 	preempt_disable();
 
 	cpu = hard_smp_processor_id();
-	xlr_cpu_stats[cpu].msgring_int++;
+	nlm_cpu_stats[cpu].msgring_int++;
 
 	preempt_enable();
 }
@@ -100,7 +100,7 @@ void nlm_cpu_stat_update_msgring_cycles(__u32 cycles)
 	preempt_disable();
 
 	cpu = hard_smp_processor_id();
-	xlr_cpu_stats[cpu].msgring_cycles += cycles;
+	nlm_cpu_stats[cpu].msgring_cycles += cycles;
 
 	preempt_enable();
 }
@@ -112,12 +112,12 @@ void nlm_cpu_stat_update_msgring_pic_int(void)
 	preempt_disable();
 
 	cpu = hard_smp_processor_id();
-	xlr_cpu_stats[cpu].msgring_pic_int++;
+	nlm_cpu_stats[cpu].msgring_pic_int++;
 
 	preempt_enable();
 }
 
-static int xlr_cpu_proc_read(char *page, char **start, off_t off,
+static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
 {
 	int i = 0;
@@ -135,38 +135,38 @@ static int xlr_cpu_proc_read(char *page, char **start, off_t off,
 
 	for(i=0;i<32;i++) {
 
-		if (!xlr_cp2_exceptions[i]) continue;
+		if (!nlm_cp2_exceptions[i]) continue;
 
 			len += sprintf(page + len,
 				       "cop2_exp: %d %llx\n",
-				       i, (unsigned long long)xlr_cp2_exceptions[i]);
+				       i, (unsigned long long)nlm_cp2_exceptions[i]);
 			if (!proc_pos_check(&begin, &len, off, count))
 				goto out;
 	}
 
 	for(i=0;i<32;i++) {
 
-		if (!xlr_cpu_stats[i].msgring_pic_int && !xlr_cpu_stats[i].msgring_int)
+		if (!nlm_cpu_stats[i].msgring_pic_int && !nlm_cpu_stats[i].msgring_int)
 			continue;
 
 			len += sprintf(page + len,
 				       "msgring: %d %llx %llx %llx\n",
-				       i, xlr_cpu_stats[i].msgring_pic_int,
-				       xlr_cpu_stats[i].msgring_int,
-				       xlr_cpu_stats[i].msgring_cycles);
+				       i, nlm_cpu_stats[i].msgring_pic_int,
+				       nlm_cpu_stats[i].msgring_int,
+				       nlm_cpu_stats[i].msgring_cycles);
 			if (!proc_pos_check(&begin, &len, off, count))
 				goto out;
 	}
 
 	for(i=0;i<32;i++) {
 
-		if (!xlr_cpu_stats[i].fp_exp && !xlr_cpu_stats[i].rdhwr_exp)
+		if (!nlm_cpu_stats[i].fp_exp && !nlm_cpu_stats[i].rdhwr_exp)
 			continue;
 
 			len += sprintf(page + len,
 				       "cpu_exp: %d %llx %llx\n",
-				       i, xlr_cpu_stats[i].fp_exp,
-				       xlr_cpu_stats[i].rdhwr_exp);
+				       i, nlm_cpu_stats[i].fp_exp,
+				       nlm_cpu_stats[i].rdhwr_exp);
 			if (!proc_pos_check(&begin, &len, off, count))
 				goto out;
 	}
@@ -199,16 +199,24 @@ static int xlr_cpu_proc_read(char *page, char **start, off_t off,
 static int nlm_cpu_proc_init(void)
 {
 	struct proc_dir_entry *entry;
-
+#ifdef CONFIG_NLM_XLR
 	entry = create_proc_read_entry("xlr_cpu", 0 /* def mode */ ,
 				       nlm_root_proc/* parent */ ,
-				       xlr_cpu_proc_read
+				       nlm_cpu_proc_read
 				       /* proc read function */ ,
 				       0	/* no client data */
 		);
-
+#endif
+#ifdef CONFIG_NLM_XLP
+	entry = create_proc_read_entry("xlp_cpu", 0 /* def mode */ ,
+				       nlm_root_proc/* parent */ ,
+				       nlm_cpu_proc_read
+				       /* proc read function */ ,
+				       0	/* no client data */
+		);
+#endif
 	if (!entry) {
-		printk("[%s]: Unable to create proc read entry for xlr_cpu!\n",
+		printk("[%s]: Unable to create proc read entry for cpu!\n",
 		       __FUNCTION__);
 	}
 
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 027002b..d77190c 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -47,6 +47,9 @@ unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
 EXPORT_SYMBOL(netlogic_io_base);
 
 extern uint32_t xlp_linux_cpu_mask;
+extern void nlm_cpu_stat_update_msgring_int(void);
+extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
+extern void nlm_cpu_stat_update_msgring_pic_int(void);
 
 uint32_t hard_cpu_online_map = 0;
 uint32_t msgring_global_thread_mask = 0;
@@ -176,18 +179,28 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned long mflags;
 	int vcpu;
 	int vc = 0;
-	uint32_t size = 0, code = 0, src_id = 0;
+	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
 
 	msg0 = msg1 = msg2 = msg3 = 0;
 
+        if (irq == IRQ_MSGRING) {
+                /* normal message ring interrupt */
+                /* xlr_inc_counter(MSGRNG_INT);  */
+                nlm_cpu_stat_update_msgring_int();
+        } else {
+                nlm_cpu_stat_update_msgring_pic_int();
+        }
+
+
 	irq_enter();
 
 	vcpu = hard_smp_processor_id() & 0x1f;
 	vcpu = vcpu << 2;
         msgrng_access_enable(mflags);
+	cycles = read_c0_count();
 
 	for( vc = vcpu; vc < (vcpu + 4); vc++)
 	{
@@ -203,6 +216,8 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 			}
 		}
 	}
+	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
+
         msgrng_access_disable(mflags);
 
 	irq_exit();
-- 
1.7.0.4

