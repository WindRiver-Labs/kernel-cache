From 7b23590c1a1e253e7209b54b76f574354b7523ca Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 12 Nov 2014 10:32:53 +0800
Subject: [PATCH 1/2] Revert "bcm-xlp: use the unsleep raw spinlock in mmc
 driver"

serial can work in irq thread, forcely making them
work in interrupt context will introduce other bug like below:

BUG: sleeping function called from invalid context at kernel/rtmutex.c:1189
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Preemption disabled at:[< (null)>] (null)

CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.10.38-ltsi-rt34-WR6.0.0.0_preempt-rt #1
Stack : 0000000000000000 0000000000000053 0000000000000000 0000000000000000
0000000000000004 ffffffffc0cc0000 0000000000000000 0000000000000000
ffffffffc1020000 0000000000000000 0000000000000053 0000000000000006
ffffffffc0bcf750 ffffffffc02a0da0 0000000000000000 0000000000000000
0000000000000000 0000000000000000 ffffffffc1000000 ffffffffc1000000
ffffffffc0b13938 ffffffffc0cb5a37 ffffffffc0ffaf48 ffffffffc0cb5ed0
0000000000000000 0000000000000000 0000000000000002 0000000000000001
ffffffffc0bcf7d0 ffffffffc0bcf6e0 ffffffffc0bcf7f8 ffffffffc0a08e00
ffffffffc0bcf830 ffffffffc02a2a38 ffffffffc0cb5b30 ffffffffc0b13938
0000000000000000 ffffffffc0273c38 0000000000000000 0000000000000000
...
Call Trace:
[<ffffffffc0273c38>] show_stack+0xd8/0xf8
[<ffffffffc0a08e00>] rt_mutex_lock+0x38/0xa8
[<ffffffffc06a45dc>] reset_buffer_flags+0x5c/0xb8
[<ffffffffc06a5abc>] n_tty_flush_buffer+0x2c/0x70
[<ffffffffc06a641c>] n_tty_receive_buf+0x91c/0x1388
[<ffffffffc06ab914>] flush_to_ldisc+0x18c/0x218
[<ffffffffc06c7e6c>] serial8250_rx_chars+0x144/0x2b8
[<ffffffffc06ca768>] serial8250_handle_irq.part.17+0x98/0x128
[<ffffffffc06c9350>] serial8250_interrupt+0x70/0x140
[<ffffffffc03333dc>] handle_irq_event_percpu+0xa4/0x328
[<ffffffffc03336e4>] handle_irq_event+0x84/0xe0
[<ffffffffc033765c>] handle_level_irq+0xe4/0x1a8
[<ffffffffc03327cc>] generic_handle_irq+0x54/0x88
[<ffffffffc0a0a25c>] do_IRQ+0x2c/0x40
[<ffffffffc026e1a0>] ret_from_irq+0x0/0x4
[<ffffffffc026e440>] __r4k_wait+0x20/0x40
[<ffffffffc02f77f8>] cpu_startup_entry+0x180/0x2e8
[<ffffffffc0d30af0>] start_kernel+0x4a8/0x4c8

Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 drivers/tty/serial/8250/8250_core.c |   80 ++++++++++++++--------------
 drivers/tty/serial/of_serial.c      |    2 +-
 drivers/tty/serial/serial_core.c    |   96 +++++++++++++++++-----------------
 drivers/tty/tty_buffer.c            |   28 +++++-----
 include/linux/serial_core.h         |    2 +-
 include/linux/tty.h                 |    2 +-
 6 files changed, 105 insertions(+), 105 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index acdb58b..eee06e6 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -134,7 +134,7 @@ static unsigned int probe_rsa_count;
 struct irq_info {
 	struct			hlist_node node;
 	int			irq;
-	raw_spinlock_t		lock;	/* Protects list not the hash */
+	spinlock_t		lock;	/* Protects list not the hash */
 	struct list_head	*head;
 };
 
@@ -613,9 +613,9 @@ static void enable_rsa(struct uart_8250_port *up)
 {
 	if (up->port.type == PORT_RSA) {
 		if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
-			raw_spin_lock_irq(&up->port.lock);
+			spin_lock_irq(&up->port.lock);
 			__enable_rsa(up);
-			raw_spin_unlock_irq(&up->port.lock);
+			spin_unlock_irq(&up->port.lock);
 		}
 		if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
 			serial_out(up, UART_RSA_FRR, 0);
@@ -635,7 +635,7 @@ static void disable_rsa(struct uart_8250_port *up)
 
 	if (up->port.type == PORT_RSA &&
 	    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {
-		raw_spin_lock_irq(&up->port.lock);
+		spin_lock_irq(&up->port.lock);
 
 		mode = serial_in(up, UART_RSA_MSR);
 		result = !(mode & UART_RSA_MSR_FIFO);
@@ -648,7 +648,7 @@ static void disable_rsa(struct uart_8250_port *up)
 
 		if (result)
 			up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
-		raw_spin_unlock_irq(&up->port.lock);
+		spin_unlock_irq(&up->port.lock);
 	}
 }
 #endif /* CONFIG_SERIAL_8250_RSA */
@@ -1072,7 +1072,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	 * We really do need global IRQs disabled here - we're going to
 	 * be frobbing the chips IRQ enable register to see if it exists.
 	 */
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 
 	up->capabilities = 0;
 	up->bugs = 0;
@@ -1111,7 +1111,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 			/*
 			 * We failed; there's nothing here
 			 */
-			raw_spin_unlock_irqrestore(&port->lock, flags);
+			spin_unlock_irqrestore(&port->lock, flags);
 			DEBUG_AUTOCONF("IER test failed (%02x, %02x) ",
 				       scratch2, scratch3);
 			goto out;
@@ -1135,7 +1135,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 		status1 = serial_in(up, UART_MSR) & 0xF0;
 		serial_out(up, UART_MCR, save_mcr);
 		if (status1 != 0x90) {
-			raw_spin_unlock_irqrestore(&port->lock, flags);
+			spin_unlock_irqrestore(&port->lock, flags);
 			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
 				       status1);
 			goto out;
@@ -1215,7 +1215,7 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 		serial_out(up, UART_IER, 0);
 
 out_lock:
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 	if (up->capabilities != old_capabilities) {
 		printk(KERN_WARNING
 		       "ttyS%d: detected caps %08x should be %08x\n",
@@ -1429,9 +1429,9 @@ serial8250_rx_chars(struct uart_8250_port *up, unsigned char lsr)
 ignore_char:
 		lsr = serial_in(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));
-	raw_spin_unlock(&port->lock);
+	spin_unlock(&port->lock);
 	tty_flip_buffer_push(&port->state->port);
-	raw_spin_lock(&port->lock);
+	spin_lock(&port->lock);
 	return lsr;
 }
 EXPORT_SYMBOL_GPL(serial8250_rx_chars);
@@ -1520,7 +1520,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	if (iir & UART_IIR_NO_INT)
 		return 0;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 
 	status = serial_port_in(port, UART_LSR);
 
@@ -1537,7 +1537,7 @@ int serial8250_handle_irq(struct uart_port *port, unsigned int iir)
 	if (!up->dma && (status & UART_LSR_THRE))
 		serial8250_tx_chars(up);
 
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 	return 1;
 }
 EXPORT_SYMBOL_GPL(serial8250_handle_irq);
@@ -1596,7 +1596,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
-	raw_spin_lock(&i->lock);
+	spin_lock(&i->lock);
 
 	l = i->head;
 	do {
@@ -1622,7 +1622,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 		}
 	} while (l != end);
 
-	raw_spin_unlock(&i->lock);
+	spin_unlock(&i->lock);
 
 	DEBUG_INTR("end.\n");
 
@@ -1638,7 +1638,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
  */
 static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
 {
-	raw_spin_lock_irq(&i->lock);
+	spin_lock_irq(&i->lock);
 
 	if (!list_empty(i->head)) {
 		if (i->head == &up->list)
@@ -1648,7 +1648,7 @@ static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
 		BUG_ON(i->head != &up->list);
 		i->head = NULL;
 	}
-	raw_spin_unlock_irq(&i->lock);
+	spin_unlock_irq(&i->lock);
 	/* List empty so throw away the hash node */
 	if (i->head == NULL) {
 		hlist_del(&i->node);
@@ -1679,26 +1679,26 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 			mutex_unlock(&hash_mutex);
 			return -ENOMEM;
 		}
-		raw_spin_lock_init(&i->lock);
+		spin_lock_init(&i->lock);
 		i->irq = up->port.irq;
 		hlist_add_head(&i->node, h);
 	}
 	mutex_unlock(&hash_mutex);
 
-	raw_spin_lock_irq(&i->lock);
+	spin_lock_irq(&i->lock);
 
 	if (i->head) {
 		list_add(&up->list, i->head);
-		raw_spin_unlock_irq(&i->lock);
+		spin_unlock_irq(&i->lock);
 
 		ret = 0;
 	} else {
 		INIT_LIST_HEAD(&up->list);
 		i->head = &up->list;
-		raw_spin_unlock_irq(&i->lock);
+		spin_unlock_irq(&i->lock);
 		irq_flags |= up->port.irqflags;
 		ret = request_irq(up->port.irq, serial8250_interrupt,
-				  irq_flags | IRQF_NO_THREAD, "serial", i);
+				  irq_flags, "serial", i);
 		if (ret < 0)
 			serial_do_unlink(i, up);
 	}
@@ -1752,7 +1752,7 @@ static void serial8250_backup_timeout(unsigned long data)
 	unsigned int iir, ier = 0, lsr;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&up->port.lock, flags);
+	spin_lock_irqsave(&up->port.lock, flags);
 
 	/*
 	 * Must disable interrupts or else we risk racing with the interrupt
@@ -1786,7 +1786,7 @@ static void serial8250_backup_timeout(unsigned long data)
 	if (up->port.irq)
 		serial_out(up, UART_IER, ier);
 
-	raw_spin_unlock_irqrestore(&up->port.lock, flags);
+	spin_unlock_irqrestore(&up->port.lock, flags);
 
 	/* Standard timer interval plus 0.2s to keep the port running */
 	mod_timer(&up->timer,
@@ -1800,10 +1800,10 @@ static unsigned int serial8250_tx_empty(struct uart_port *port)
 	unsigned long flags;
 	unsigned int lsr;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	lsr = serial_port_in(port, UART_LSR);
 	up->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	return (lsr & BOTH_EMPTY) == BOTH_EMPTY ? TIOCSER_TEMT : 0;
 }
@@ -1857,13 +1857,13 @@ static void serial8250_break_ctl(struct uart_port *port, int break_state)
 		container_of(port, struct uart_8250_port, port);
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	if (break_state == -1)
 		up->lcr |= UART_LCR_SBC;
 	else
 		up->lcr &= ~UART_LCR_SBC;
 	serial_port_out(port, UART_LCR, up->lcr);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 /*
@@ -2052,7 +2052,7 @@ static int serial8250_startup(struct uart_port *port)
 		 * the interrupt is enabled.  Delays are necessary to
 		 * allow register changes to become visible.
 		 */
-		raw_spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&port->lock, flags);
 		if (up->port.irqflags & IRQF_SHARED)
 			disable_irq_nosync(port->irq);
 
@@ -2068,7 +2068,7 @@ static int serial8250_startup(struct uart_port *port)
 
 		if (port->irqflags & IRQF_SHARED)
 			enable_irq(port->irq);
-		raw_spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&port->lock, flags);
 
 		/*
 		 * If the interrupt is not reasserted, or we otherwise
@@ -2113,7 +2113,7 @@ static int serial8250_startup(struct uart_port *port)
 	 */
 	serial_port_out(port, UART_LCR, UART_LCR_WLEN8);
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	if (up->port.flags & UPF_FOURPORT) {
 		if (!up->port.irq)
 			up->port.mctrl |= TIOCM_OUT1;
@@ -2160,7 +2160,7 @@ static int serial8250_startup(struct uart_port *port)
 	}
 
 dont_test_tx_en:
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	/*
 	 * Clear the interrupt registers again for luck, and clear the
@@ -2222,7 +2222,7 @@ static void serial8250_shutdown(struct uart_port *port)
 	if (up->dma)
 		serial8250_release_dma(up);
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	if (port->flags & UPF_FOURPORT) {
 		/* reset interrupts on the AST Fourport board */
 		inb((port->iobase & 0xfe0) | 0x1f);
@@ -2231,7 +2231,7 @@ static void serial8250_shutdown(struct uart_port *port)
 		port->mctrl &= ~TIOCM_OUT2;
 
 	serial8250_set_mctrl(port, port->mctrl);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	/*
 	 * Disable break condition and FIFOs
@@ -2360,7 +2360,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * Ok, we're now changing the port state.  Do it with
 	 * interrupts disabled.
 	 */
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 
 	/*
 	 * Update the per-port timeout.
@@ -2462,7 +2462,7 @@ serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
 		serial_port_out(port, UART_FCR, fcr);		/* set fcr */
 	}
 	serial8250_set_mctrl(port, port->mctrl);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 	/* Don't rewrite B0 */
 	if (tty_termios_baud_rate(termios))
 		tty_termios_encode_baud_rate(termios, baud, baud);
@@ -2778,7 +2778,7 @@ static void __init serial8250_isa_init_ports(void)
 		struct uart_port *port = &up->port;
 
 		port->line = i;
-		raw_spin_lock_init(&port->lock);
+		spin_lock_init(&port->lock);
 
 		init_timer(&up->timer);
 		up->timer.function = serial8250_timeout;
@@ -2879,9 +2879,9 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 	touch_nmi_watchdog();
 
 	if (port->sysrq || oops_in_progress || in_kdb_printk())
-		locked = raw_spin_trylock_irqsave(&port->lock, flags);
+		locked = spin_trylock_irqsave(&port->lock, flags);
 	else
-		raw_spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&port->lock, flags);
 
 	/*
 	 *	First save the IER then disable the interrupts
@@ -2913,7 +2913,7 @@ serial8250_console_write(struct console *co, const char *s, unsigned int count)
 		serial8250_modem_status(up);
 
 	if (locked)
-		raw_spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static int __init serial8250_console_setup(struct console *co, char *options)
diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c
index d2b7ca1..39c7ea4 100644
--- a/drivers/tty/serial/of_serial.c
+++ b/drivers/tty/serial/of_serial.c
@@ -87,7 +87,7 @@ static int of_platform_serial_setup(struct platform_device *ofdev,
 		goto out;
 	}
 
-	raw_spin_lock_init(&port->lock);
+	spin_lock_init(&port->lock);
 	port->mapbase = resource.start;
 
 	/* Check for shifted address mapping */
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 10b4079..19814fc 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -79,9 +79,9 @@ static void uart_stop(struct tty_struct *tty)
 	struct uart_port *port = state->uart_port;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	port->ops->stop_tx(port);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static void __uart_start(struct tty_struct *tty)
@@ -100,9 +100,9 @@ static void uart_start(struct tty_struct *tty)
 	struct uart_port *port = state->uart_port;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	__uart_start(tty);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static inline void
@@ -111,12 +111,12 @@ uart_update_mctrl(struct uart_port *port, unsigned int set, unsigned int clear)
 	unsigned long flags;
 	unsigned int old;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	old = port->mctrl;
 	port->mctrl = (old & ~clear) | set;
 	if (old != port->mctrl)
 		port->ops->set_mctrl(port, port->mctrl);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 #define uart_set_mctrl(port, set)	uart_update_mctrl(port, set, 0)
@@ -172,10 +172,10 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 		}
 
 		if (tty_port_cts_enabled(port)) {
-			raw_spin_lock_irq(&uport->lock);
+			spin_lock_irq(&uport->lock);
 			if (!(uport->ops->get_mctrl(uport) & TIOCM_CTS))
 				tty->hw_stopped = 1;
-			raw_spin_unlock_irq(&uport->lock);
+			spin_unlock_irq(&uport->lock);
 		}
 	}
 
@@ -468,13 +468,13 @@ static inline int __uart_put_char(struct uart_port *port,
 	if (!circ->buf)
 		return 0;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	if (uart_circ_chars_free(circ) != 0) {
 		circ->buf[circ->head] = c;
 		circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);
 		ret = 1;
 	}
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 	return ret;
 }
 
@@ -514,7 +514,7 @@ static int uart_write(struct tty_struct *tty,
 	if (!circ->buf)
 		return 0;
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	while (1) {
 		c = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);
 		if (count < c)
@@ -527,7 +527,7 @@ static int uart_write(struct tty_struct *tty,
 		count -= c;
 		ret += c;
 	}
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	uart_start(tty);
 	return ret;
@@ -539,9 +539,9 @@ static int uart_write_room(struct tty_struct *tty)
 	unsigned long flags;
 	int ret;
 
-	raw_spin_lock_irqsave(&state->uart_port->lock, flags);
+	spin_lock_irqsave(&state->uart_port->lock, flags);
 	ret = uart_circ_chars_free(&state->xmit);
-	raw_spin_unlock_irqrestore(&state->uart_port->lock, flags);
+	spin_unlock_irqrestore(&state->uart_port->lock, flags);
 	return ret;
 }
 
@@ -551,9 +551,9 @@ static int uart_chars_in_buffer(struct tty_struct *tty)
 	unsigned long flags;
 	int ret;
 
-	raw_spin_lock_irqsave(&state->uart_port->lock, flags);
+	spin_lock_irqsave(&state->uart_port->lock, flags);
 	ret = uart_circ_chars_pending(&state->xmit);
-	raw_spin_unlock_irqrestore(&state->uart_port->lock, flags);
+	spin_unlock_irqrestore(&state->uart_port->lock, flags);
 	return ret;
 }
 
@@ -575,11 +575,11 @@ static void uart_flush_buffer(struct tty_struct *tty)
 	port = state->uart_port;
 	pr_debug("uart_flush_buffer(%d) called\n", tty->index);
 
-	raw_spin_lock_irqsave(&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	uart_circ_clear(&state->xmit);
 	if (port->ops->flush_buffer)
 		port->ops->flush_buffer(port);
-	raw_spin_unlock_irqrestore(&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
 	tty_wakeup(tty);
 }
 
@@ -598,9 +598,9 @@ static void uart_send_xchar(struct tty_struct *tty, char ch)
 	else {
 		port->x_char = ch;
 		if (ch) {
-			raw_spin_lock_irqsave(&port->lock, flags);
+			spin_lock_irqsave(&port->lock, flags);
 			port->ops->start_tx(port);
-			raw_spin_unlock_irqrestore(&port->lock, flags);
+			spin_unlock_irqrestore(&port->lock, flags);
 		}
 	}
 }
@@ -956,9 +956,9 @@ static int uart_tiocmget(struct tty_struct *tty)
 	mutex_lock(&port->mutex);
 	if (!(tty->flags & (1 << TTY_IO_ERROR))) {
 		result = uport->mctrl;
-		raw_spin_lock_irq(&uport->lock);
+		spin_lock_irq(&uport->lock);
 		result |= uport->ops->get_mctrl(uport);
-		raw_spin_unlock_irq(&uport->lock);
+		spin_unlock_irq(&uport->lock);
 	}
 	mutex_unlock(&port->mutex);
 
@@ -1062,20 +1062,20 @@ uart_wait_modem_status(struct uart_state *state, unsigned long arg)
 	/*
 	 * note the counters on entry
 	 */
-	raw_spin_lock_irq(&uport->lock);
+	spin_lock_irq(&uport->lock);
 	memcpy(&cprev, &uport->icount, sizeof(struct uart_icount));
 
 	/*
 	 * Force modem status interrupts on
 	 */
 	uport->ops->enable_ms(uport);
-	raw_spin_unlock_irq(&uport->lock);
+	spin_unlock_irq(&uport->lock);
 
 	add_wait_queue(&port->delta_msr_wait, &wait);
 	for (;;) {
-		raw_spin_lock_irq(&uport->lock);
+		spin_lock_irq(&uport->lock);
 		memcpy(&cnow, &uport->icount, sizeof(struct uart_icount));
-		raw_spin_unlock_irq(&uport->lock);
+		spin_unlock_irq(&uport->lock);
 
 		set_current_state(TASK_INTERRUPTIBLE);
 
@@ -1117,9 +1117,9 @@ static int uart_get_icount(struct tty_struct *tty,
 	struct uart_icount cnow;
 	struct uart_port *uport = state->uart_port;
 
-	raw_spin_lock_irq(&uport->lock);
+	spin_lock_irq(&uport->lock);
 	memcpy(&cnow, &uport->icount, sizeof(struct uart_icount));
-	raw_spin_unlock_irq(&uport->lock);
+	spin_unlock_irq(&uport->lock);
 
 	icount->cts         = cnow.cts;
 	icount->dsr         = cnow.dsr;
@@ -1287,19 +1287,19 @@ static void uart_set_termios(struct tty_struct *tty,
 
 	/* Handle turning off CRTSCTS */
 	if ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {
-		raw_spin_lock_irqsave(&uport->lock, flags);
+		spin_lock_irqsave(&uport->lock, flags);
 		tty->hw_stopped = 0;
 		__uart_start(tty);
-		raw_spin_unlock_irqrestore(&uport->lock, flags);
+		spin_unlock_irqrestore(&uport->lock, flags);
 	}
 	/* Handle turning on CRTSCTS */
 	else if (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {
-		raw_spin_lock_irqsave(&uport->lock, flags);
+		spin_lock_irqsave(&uport->lock, flags);
 		if (!(uport->ops->get_mctrl(uport) & TIOCM_CTS)) {
 			tty->hw_stopped = 1;
 			uport->ops->stop_tx(uport);
 		}
-		raw_spin_unlock_irqrestore(&uport->lock, flags);
+		spin_unlock_irqrestore(&uport->lock, flags);
 	}
 }
 
@@ -1333,9 +1333,9 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 	 */
 	if (port->flags & ASYNC_INITIALIZED) {
 		unsigned long flags;
-		raw_spin_lock_irqsave(&uport->lock, flags);
+		spin_lock_irqsave(&uport->lock, flags);
 		uport->ops->stop_rx(uport);
-		raw_spin_unlock_irqrestore(&uport->lock, flags);
+		spin_unlock_irqrestore(&uport->lock, flags);
 		/*
 		 * Before we drop DTR, make sure the UART transmitter
 		 * has completely drained; this is especially
@@ -1496,10 +1496,10 @@ static int uart_carrier_raised(struct tty_port *port)
 	struct uart_state *state = container_of(port, struct uart_state, port);
 	struct uart_port *uport = state->uart_port;
 	int mctrl;
-	raw_spin_lock_irq(&uport->lock);
+	spin_lock_irq(&uport->lock);
 	uport->ops->enable_ms(uport);
 	mctrl = uport->ops->get_mctrl(uport);
-	raw_spin_unlock_irq(&uport->lock);
+	spin_unlock_irq(&uport->lock);
 	if (mctrl & TIOCM_CAR)
 		return 1;
 	return 0;
@@ -1644,9 +1644,9 @@ static void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)
 		pm_state = state->pm_state;
 		if (pm_state != UART_PM_STATE_ON)
 			uart_change_pm(state, UART_PM_STATE_ON);
-		raw_spin_lock_irq(&uport->lock);
+		spin_lock_irq(&uport->lock);
 		status = uport->ops->get_mctrl(uport);
-		raw_spin_unlock_irq(&uport->lock);
+		spin_unlock_irq(&uport->lock);
 		if (pm_state != UART_PM_STATE_ON)
 			uart_change_pm(state, pm_state);
 		mutex_unlock(&port->mutex);
@@ -1834,7 +1834,7 @@ uart_set_options(struct uart_port *port, struct console *co,
 	 * Ensure that the serial console lock is initialised
 	 * early.
 	 */
-	raw_spin_lock_init(&port->lock);
+	spin_lock_init(&port->lock);
 	lockdep_set_class(&port->lock, &port_lock_key);
 
 	memset(&termios, 0, sizeof(struct ktermios));
@@ -1951,11 +1951,11 @@ int uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)
 			set_bit(ASYNCB_SUSPENDED, &port->flags);
 			clear_bit(ASYNCB_INITIALIZED, &port->flags);
 
-			raw_spin_lock_irq(&uport->lock);
+			spin_lock_irq(&uport->lock);
 			ops->stop_tx(uport);
 			ops->set_mctrl(uport, 0);
 			ops->stop_rx(uport);
-			raw_spin_unlock_irq(&uport->lock);
+			spin_unlock_irq(&uport->lock);
 		}
 
 		/*
@@ -2040,9 +2040,9 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 		int ret;
 
 		uart_change_pm(state, UART_PM_STATE_ON);
-		raw_spin_lock_irq(&uport->lock);
+		spin_lock_irq(&uport->lock);
 		ops->set_mctrl(uport, 0);
-		raw_spin_unlock_irq(&uport->lock);
+		spin_unlock_irq(&uport->lock);
 		if (console_suspend_enabled || !uart_console(uport)) {
 			/* Protected by port mutex for now */
 			struct tty_struct *tty = port->tty;
@@ -2050,10 +2050,10 @@ int uart_resume_port(struct uart_driver *drv, struct uart_port *uport)
 			if (ret == 0) {
 				if (tty)
 					uart_change_speed(tty, state, NULL);
-				raw_spin_lock_irq(&uport->lock);
+				spin_lock_irq(&uport->lock);
 				ops->set_mctrl(uport, uport->mctrl);
 				ops->start_tx(uport);
-				raw_spin_unlock_irq(&uport->lock);
+				spin_unlock_irq(&uport->lock);
 				set_bit(ASYNCB_INITIALIZED, &port->flags);
 			} else {
 				/*
@@ -2146,9 +2146,9 @@ uart_configure_port(struct uart_driver *drv, struct uart_state *state,
 		 * keep the DTR setting that is set in uart_set_options()
 		 * We probably don't need a spinlock around this, but
 		 */
-		raw_spin_lock_irqsave(&port->lock, flags);
+		spin_lock_irqsave(&port->lock, flags);
 		port->ops->set_mctrl(port, port->mctrl & TIOCM_DTR);
-		raw_spin_unlock_irqrestore(&port->lock, flags);
+		spin_unlock_irqrestore(&port->lock, flags);
 
 		/*
 		 * If this driver supports console, and it hasn't been
@@ -2621,7 +2621,7 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)
 	 * initialised.
 	 */
 	if (!(uart_console(uport) && (uport->cons->flags & CON_ENABLED))) {
-		raw_spin_lock_init(&uport->lock);
+		spin_lock_init(&uport->lock);
 		lockdep_set_class(&uport->lock, &port_lock_key);
 	}
 
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 67119eb..59c7366 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -154,20 +154,20 @@ void tty_buffer_flush(struct tty_struct *tty)
 	struct tty_bufhead *buf = &port->buf;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&buf->lock, flags);
+	spin_lock_irqsave(&buf->lock, flags);
 
 	/* If the data is being pushed to the tty layer then we can't
 	   process it here. Instead set a flag and the flush_to_ldisc
 	   path will process the flush request before it exits */
 	if (test_bit(TTYP_FLUSHING, &port->iflags)) {
 		set_bit(TTYP_FLUSHPENDING, &port->iflags);
-		raw_spin_unlock_irqrestore(&buf->lock, flags);
+		spin_unlock_irqrestore(&buf->lock, flags);
 		wait_event(tty->read_wait,
 				test_bit(TTYP_FLUSHPENDING, &port->iflags) == 0);
 		return;
 	} else
 		__tty_buffer_flush(port);
-	raw_spin_unlock_irqrestore(&buf->lock, flags);
+	spin_unlock_irqrestore(&buf->lock, flags);
 }
 
 /**
@@ -220,7 +220,7 @@ int tty_buffer_request_room(struct tty_port *port, size_t size)
 	struct tty_buffer *b, *n;
 	int left;
 	unsigned long flags;
-	raw_spin_lock_irqsave(&buf->lock, flags);
+	spin_lock_irqsave(&buf->lock, flags);
 	/* OPTIMISATION: We could keep a per tty "zero" sized buffer to
 	   remove this conditional if its worth it. This would be invisible
 	   to the callers */
@@ -242,7 +242,7 @@ int tty_buffer_request_room(struct tty_port *port, size_t size)
 		} else
 			size = left;
 	}
-	raw_spin_unlock_irqrestore(&buf->lock, flags);
+	spin_unlock_irqrestore(&buf->lock, flags);
 	return size;
 }
 EXPORT_SYMBOL_GPL(tty_buffer_request_room);
@@ -342,10 +342,10 @@ void tty_schedule_flip(struct tty_port *port)
 	unsigned long flags;
 	WARN_ON(port->low_latency);
 
-	raw_spin_lock_irqsave(&buf->lock, flags);
+	spin_lock_irqsave(&buf->lock, flags);
 	if (buf->tail != NULL)
 		buf->tail->commit = buf->tail->used;
-	raw_spin_unlock_irqrestore(&buf->lock, flags);
+	spin_unlock_irqrestore(&buf->lock, flags);
 	schedule_work(&buf->work);
 }
 EXPORT_SYMBOL(tty_schedule_flip);
@@ -439,7 +439,7 @@ static void flush_to_ldisc(struct work_struct *work)
 	if (disc == NULL)	/*  !TTY_LDISC */
 		return;
 
-	raw_spin_lock_irqsave(&buf->lock, flags);
+	spin_lock_irqsave(&buf->lock, flags);
 
 	if (!test_and_set_bit(TTYP_FLUSHING, &port->iflags)) {
 		struct tty_buffer *head;
@@ -463,10 +463,10 @@ static void flush_to_ldisc(struct work_struct *work)
 			char_buf = head->char_buf_ptr + head->read;
 			flag_buf = head->flag_buf_ptr + head->read;
 			head->read += count;
-			raw_spin_unlock_irqrestore(&buf->lock, flags);
+			spin_unlock_irqrestore(&buf->lock, flags);
 			disc->ops->receive_buf(tty, char_buf,
 							flag_buf, count);
-			raw_spin_lock_irqsave(&buf->lock, flags);
+			spin_lock_irqsave(&buf->lock, flags);
 			/* Ldisc or user is trying to flush the buffers.
 			   We may have a deferred request to flush the
 			   input buffer, if so pull the chain under the lock
@@ -481,7 +481,7 @@ static void flush_to_ldisc(struct work_struct *work)
 		clear_bit(TTYP_FLUSHING, &port->iflags);
 	}
 
-	raw_spin_unlock_irqrestore(&buf->lock, flags);
+	spin_unlock_irqrestore(&buf->lock, flags);
 
 	tty_ldisc_deref(disc);
 }
@@ -523,10 +523,10 @@ void tty_flip_buffer_push(struct tty_port *port)
 	struct tty_bufhead *buf = &port->buf;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&buf->lock, flags);
+	spin_lock_irqsave(&buf->lock, flags);
 	if (buf->tail != NULL)
 		buf->tail->commit = buf->tail->used;
-	raw_spin_unlock_irqrestore(&buf->lock, flags);
+	spin_unlock_irqrestore(&buf->lock, flags);
 
 #ifndef CONFIG_PREEMPT_RT_FULL
 	if (port->low_latency)
@@ -554,7 +554,7 @@ void tty_buffer_init(struct tty_port *port)
 {
 	struct tty_bufhead *buf = &port->buf;
 
-	raw_spin_lock_init(&buf->lock);
+	spin_lock_init(&buf->lock);
 	buf->head = NULL;
 	buf->tail = NULL;
 	buf->free = NULL;
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6414962..2ea3a99 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -115,7 +115,7 @@ struct uart_icount {
 typedef unsigned int __bitwise__ upf_t;
 
 struct uart_port {
-	raw_spinlock_t		lock;			/* port lock */
+	spinlock_t		lock;			/* port lock */
 	unsigned long		iobase;			/* in/out[bwl] */
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		(*serial_in)(struct uart_port *, int);
diff --git a/include/linux/tty.h b/include/linux/tty.h
index f28ce4d..8780bd2 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -53,7 +53,7 @@ struct tty_buffer {
 
 struct tty_bufhead {
 	struct work_struct work;
-	raw_spinlock_t lock;
+	spinlock_t lock;
 	struct tty_buffer *head;	/* Queue head */
 	struct tty_buffer *tail;	/* Active buffer */
 	struct tty_buffer *free;	/* Free queue head */
-- 
1.7.5.4

