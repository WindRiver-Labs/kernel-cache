From fa81ac6681ff93627ac29c51da9b106a05f65655 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Thu, 21 Apr 2011 19:42:48 -0700
Subject: [PATCH 260/761] little endian support plus code cleanup

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/spi/spi_xlp.c |  163 ++++++++++++++++++++-----------------------------
 1 file changed, 65 insertions(+), 98 deletions(-)

diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
index ba73b82..39e80a3 100644
--- a/drivers/spi/spi_xlp.c
+++ b/drivers/spi/spi_xlp.c
@@ -38,33 +38,34 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 #include <asm/netlogic/xlp.h>
 
+#undef XLP_SPI_DEBUG
 #define CONFIG_SPI_REFCLK		133333334
 #define SPI_CHAN_OFFSET			0x10
-#define OPCODE_RDID			0x9f
-#define OPCODE_RDSR			0x05
-#define OPCODE_WREN			0x06
-#define OPCODE_WRDI			0x04
-#define OPCODE_BE_4K			0x20
-#define OPCODE_BE_32K			0x52
-#define OPCODE_CHIP_ERASE		0xc7
-#define OPCODE_SE			0xd8
+#define CMD_RDID			0x9f
+#define CMD_RDSR			0x05
+#define CMD_WREN			0x06
+#define CMD_WRDI			0x04
+#define CMD_BE_4K			0x20
+#define CMD_BE_32K			0x52
+#define CMD_CHIP_ERASE		0xc7
+#define CMD_SE			0xd8
 #define DEFAULT_CS_FDIV			0x10
 #define XLP_SPI_MAX_XFER_SIZE		0x2000
 #define XLP_SPI_FIFO_SIZE		8
 #define NOR_SPI_CMD_SIZE		5
+#define XLP_SPI_MAX_CS			4
 
 struct spi_xlp {
-	/* bitbang has to be first */
 	struct spi_bitbang bitbang;
 	struct completion done;
 	uint8_t 	cs;
 	uint8_t 	cs_active;
-	void __iomem	*regs;		/* virt. address of the control registers */
+	void __iomem	*regs;
 	uint32_t	irq;
-	uint32_t	speed_hz; 	/* SCK has a fixed frequency of speed_hz Hz */
-	unsigned char *prxbuf;		/* pointer in the Tx buffer */
-	unsigned char *ptxbuf;		/* pointer in the Rx buffer */
-	int remaining_bytes;		/* the number of bytes left to transfer */
+	uint32_t	speed_hz;
+	unsigned char	*rx_buf;
+	unsigned char	*tx_buf;
+	int32_t 	rcounter;
 };
 
 static __inline__ int32_t spi_reg_read(int node, int cs, int regidx)
@@ -90,7 +91,7 @@ static void spi_dump_reg()
 	for(i = 0; i < 8; i++) {
 		printk("0x%0x = 0x%8x\n", i, spi_reg_read( 0, j, i));
 	}
-        for(j = 0; j < 4; j++)
+        for(j = 0; j < XLP_SPI_MAX_CS; j++)
         {
                 printk("dump spi_%d register\n", j);
                 for(i = 0x40; i < 0x47; i++) {
@@ -104,15 +105,13 @@ static void spi_dump_reg()
 static void xlp_spi_init(struct spi_xlp *pspi)
 {
 	uint32_t i, val;
-	/* Reset the SPI device */
 
 	val = spi_reg_read(0, 0, XLP_SPI_SYSCTRL);
 	val |= XLP_SPI_SYS_PMEN;
         spi_reg_write(0, 0, XLP_SPI_SYSCTRL, (XLP_SPI_SYS_RESET << pspi->cs));
 
 	pspi->cs_active = 0;
-	/* set cfg register */
-	for(i = 0; i < 4; i++)
+	for(i = 0; i < XLP_SPI_MAX_CS; i++)
 	{
 		val = spi_reg_read(0, i, XLP_SPI_CONFIG);
 		val |= XLP_SPI_TXMOSI_EN |XLP_SPI_RXMISO_EN;
@@ -128,20 +127,12 @@ static void spi_xlp_chipselect(struct spi_device *spi, int is_on)
                 pspi->cs =  spi->chip_select;
 
 	if (is_on == BITBANG_CS_INACTIVE) {
-		/* Deselect the slave on the SPI bus */
 		pspi->cs_active = 0;
 	} else if (is_on == BITBANG_CS_ACTIVE) {
-		/* Activate the chip select */
 		pspi->cs_active = 1;
 	}
 }
 
-/* spi_bitbang requires custom setup_transfer() to be defined if there is a
- * custom txrx_bufs(). We have nothing to setup here as the SPI IP block
- * supports just 8 bits per word, and SPI clock can't be changed in software.
- * Check for 8 bits per word. Chip select delay calculations could be
- * added here as soon as bitbang_work() can be made aware of the delay value.
- */
 static int spi_xlp_setup_transfer(struct spi_device *spi,
 		struct spi_transfer *t)
 {
@@ -153,8 +144,7 @@ static int spi_xlp_setup_transfer(struct spi_device *spi,
 	hz = (t) ? t->speed_hz : spi->max_speed_hz;
 
 	if (hz && pspi->speed_hz > hz) {
-		dev_err(&spi->dev, "%s, unsupported clock rate %uHz\n",
-			__FUNCTION__, hz);
+		printk("%s, unsupported clk rate %uHz\n", __func__, hz);
 		return -EINVAL;
 	}
 
@@ -169,10 +159,8 @@ static int spi_xlp_setup(struct spi_device *spi)
 	pspi = spi_master_get_devdata(spi->master);
 	bitbang = &pspi->bitbang;
 
-	/* enable spi pin muxing */
 	spi_reg_write(0, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
 
-	/* set XLP_SPI_FDIV */
        if ((1000000 < CONFIG_SPI_REFCLK/4) &&
                 (1000000 > CONFIG_SPI_REFCLK/(64*1024))) {
                 spi_reg_write(0, pspi->cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
@@ -193,7 +181,6 @@ out:
 
 static void spi_xlp_fill_txfifo(struct spi_xlp *pspi, uint32_t* len, unsigned char** data)
 {
-
         uint32_t txfifo_cnt;
         uint32_t tx_data;
         txfifo_cnt = spi_reg_read(0, pspi->cs, XLP_SPI_FIFO_WCNT);
@@ -232,12 +219,12 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 	if(opcode == NULL)
 		return 0;
 
-	if(opcode[0] == OPCODE_WREN 	||
-	   opcode[0] == OPCODE_BE_4K	||
-	   opcode[0] == OPCODE_BE_32K	||
-	   opcode[0] == OPCODE_CHIP_ERASE||
-	   opcode[0] == OPCODE_SE	||
-	   opcode[0] == OPCODE_WRDI )
+	if(opcode[0] == CMD_WREN 	||
+	   opcode[0] == CMD_BE_4K	||
+	   opcode[0] == CMD_BE_32K	||
+	   opcode[0] == CMD_CHIP_ERASE||
+	   opcode[0] == CMD_SE	||
+	   opcode[0] == CMD_WRDI )
 		return 1;
 	else
 		return 0;
@@ -246,22 +233,22 @@ static int spi_disable_cont_cmd(unsigned char* opcode)
 static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, uint32_t xfer_len)
 {
 	uint32_t val;
-        uint32_t rx_data, tx_len, rx_len, rxfifo_cnt /*, txfifo_cnt*/;
+        uint32_t rx_data, tx_len, rx_len, rxfifo_cnt;
 	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
 
-	pspi->ptxbuf = (unsigned char*)t->tx_buf;
-	pspi->prxbuf = (unsigned char*)t->rx_buf;
-	pspi->remaining_bytes = xfer_len;
+	pspi->tx_buf = (unsigned char*)t->tx_buf;
+	pspi->rx_buf = (unsigned char*)t->rx_buf;
+	pspi->rcounter = xfer_len;
 
         if (xfer_len == 0)
                 return -1;
 
-        tx_len = (pspi->ptxbuf == NULL) ? 0 : xfer_len;
-        rx_len = (pspi->prxbuf == NULL) ? 0 : xfer_len;
+        tx_len = (pspi->tx_buf == NULL) ? 0 : xfer_len;
+        rx_len = (pspi->rx_buf == NULL) ? 0 : xfer_len;
 
 	val = XLP_SPI_CMD_IDLE;
         if (tx_len) {
-                spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->ptxbuf);
+                spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
 		t->len = tx_len;
 		if(xfer_len <= NOR_SPI_CMD_SIZE){
 			val |= XLP_SPI_CMD_CONT;
@@ -273,9 +260,9 @@ static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, ui
 		}
         }
 
-	if(pspi->ptxbuf != 0)
+	if(pspi->tx_buf != 0)
 		val |= XLP_SPI_CMD_TX;
-	if(pspi->prxbuf != 0)
+	if(pspi->rx_buf != 0)
 		val |= XLP_SPI_CMD_RX;
         if(xfer_len)
 		val |= ((xfer_len * 8 -1) << XLP_SPI_XFR_BITCNT_POS);
@@ -295,31 +282,31 @@ static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, ui
 				rxfifo_cnt--;
 
                                 if (rx_len <= 1) {
-                                        pspi->prxbuf[0] = (uint8_t) (rx_data & 0xff);
+                                        pspi->rx_buf[0] = (uint8_t) (rx_data & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 2) {
-                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else if (rx_len <= 3) {
-                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->prxbuf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len = 0;
                                 } else {
-                                        pspi->prxbuf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
-                                        pspi->prxbuf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
-                                        pspi->prxbuf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
-                                        pspi->prxbuf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        pspi->rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
+                                        pspi->rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        pspi->rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        pspi->rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
                                         rx_len -= 4;
                                 }
 
-                                pspi->prxbuf += 4;
+                                pspi->rx_buf += 4;
                         }
 			t->len = rx_len;
                 }
                 if (tx_len) {
-                        spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->ptxbuf);
+                        spi_xlp_fill_txfifo(pspi, &tx_len, &pspi->tx_buf);
 			t->len = tx_len;
                 }
         }
@@ -357,47 +344,30 @@ static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
         return 0;
 }
 
-
-/* This driver supports single master mode only. Hence Tx FIFO Empty
- * is the only interrupt we care about.
- * Receive FIFO Overrun, Transmit FIFO Underrun, Mode Fault, and Slave Mode
- * Fault are not to happen.
- */
 static irqreturn_t spi_xlp_irq(int irq, void *dev_id)
 {
 	struct spi_xlp *pspi = dev_id;
 	uint32_t int_stat;
 
-	/* Get the IPIF interrupts, and clear them immediately */
 	int_stat = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
 
-	if (int_stat & XLP_SPI_INT_XFR_DONE) {	/* Transmission completed */
+	if (int_stat & XLP_SPI_INT_XFR_DONE) {
 		uint32_t sr;
 
-		/* A transmit has just completed. Process received data and
-		 * check for more data to transmit. Always inhibit the
-		 * transmitter while the Isr refills the transmit register/FIFO,
-		 * or make sure it is stopped if we're done.
-		 */
-		/* Read out all the data from the Rx FIFO */
 		sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
 		while ((sr & XLP_SPI_INT_RX_THRESH) == 0) {
 			uint32_t data;
 
 			data = spi_reg_read(0, pspi->cs,XLP_SPI_RXDATA_FIFO);
-			if (pspi->prxbuf) {
-				memcpy(pspi->prxbuf, &data, 4);
+			if (pspi->rx_buf) {
+				memcpy(pspi->rx_buf, &data, 4);
 			}
 			sr = spi_reg_read(0, pspi->cs,XLP_SPI_STATUS);
 		}
 
-		/* See if there is more data to send */
-		if (pspi->remaining_bytes > 0) {
-			spi_xlp_fill_txfifo(pspi, &pspi->remaining_bytes, &pspi->ptxbuf);
+		if (pspi->rcounter > 0) {
+			spi_xlp_fill_txfifo(pspi, &pspi->rcounter, &pspi->tx_buf);
 		} else {
-			/* No more data to send.
-			 * Indicate the transfer is completed.
-			 */
 			complete(&pspi->done);
 		}
 	}
@@ -407,32 +377,36 @@ static irqreturn_t spi_xlp_irq(int irq, void *dev_id)
 
 static int __init spi_xlp_probe(struct platform_device *dev)
 {
-	int ret = 0, irt;
+	int ret = 0 , irt;
 	struct spi_master *master;
 	struct spi_xlp *pspi;
 	struct resource *r;
 
 
 	master = spi_alloc_master(&dev->dev, sizeof(struct spi_xlp));
-
-	if (master == NULL) {
+	if(!master) {
+		printk("[%s] failed to allocate spi master\n",__func__);
 		return -ENOMEM;
 	}
 
 	dev_set_drvdata(&dev->dev, master);
 
 	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (r == NULL) {
+	if (!r) {
 		ret = -ENODEV;
 		goto put_master;
 	}
 
 	pspi = spi_master_get_devdata(master);
-	pspi->bitbang.master = spi_master_get(master);
-	pspi->bitbang.chipselect = spi_xlp_chipselect;
-	pspi->bitbang.setup_transfer = spi_xlp_setup_transfer;
-	pspi->bitbang.txrx_bufs = spi_xlp_txrx_bufs;
-	pspi->bitbang.master->setup = spi_xlp_setup;
+	platform_set_drvdata(dev, pspi);
+
+	/* setup spi bitbang adaptor */
+	pspi->bitbang.master 		= spi_master_get(master);
+	pspi->bitbang.chipselect	= spi_xlp_chipselect;
+	pspi->bitbang.setup_transfer	= spi_xlp_setup_transfer;
+	pspi->bitbang.txrx_bufs		= spi_xlp_txrx_bufs;
+	pspi->bitbang.master->setup	= spi_xlp_setup;
+	pspi->bitbang.master->num_chipselect = XLP_SPI_MAX_CS;
 	init_completion(&pspi->done);
 
 	if (!request_mem_region(r->start,
@@ -446,7 +420,6 @@ static int __init spi_xlp_probe(struct platform_device *dev)
 		ret = -ENOMEM;
 		goto put_master;
 	}
-
         irt = spi_reg_read(0, 0, 0x3D) & 0xFFFF;
         pspi->irq = nlm_hal_irt_to_irq(irt);
 	if (pspi->irq < 0) {
@@ -455,23 +428,17 @@ static int __init spi_xlp_probe(struct platform_device *dev)
 	}
 
 	master->bus_num = 0;
-	master->num_chipselect = 4;
+	master->num_chipselect = XLP_SPI_MAX_CS;
 
-	/* SPI controller initializations */
 	xlp_spi_init(pspi);
-
-	/* Register for SPI Interrupt */
 	ret = request_irq(pspi->irq, spi_xlp_irq, 0, "spi-xlp", pspi);
 	if (ret != 0)
 		goto unmap_io;
-
 	ret = spi_bitbang_start(&pspi->bitbang);
 	if (ret != 0) {
-		dev_err(&dev->dev, "spi_bitbang_start FAILED\n");
+		printk("[%s] spi_bitbang_start FAILED\n", __func__);
 		goto free_irq;
 	}
-
-
 	return ret;
 
 free_irq:
-- 
1.7.10.4

