From 6805d0be774985470c4a59fae4296c952cd63422 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Mon, 13 Dec 2010 12:12:15 -0800
Subject: [PATCH 231/762] NLM Fast Syscall code cleanup, enabled 64-bit c0 perf_ctr in fast syscall

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/nlm_fs.h         |   63 +++
 arch/mips/include/asm/netlogic/nlm_uaccess_fs.h |   64 ---
 arch/mips/kernel/Makefile                       |    4 +-
 arch/mips/kernel/nlm_fs.c                       |   47 ++
 arch/mips/kernel/nlm_fs_handler.S               |  474 +++++++++++++++++++++
 arch/mips/kernel/scall32-o32.S                  |    2 +-
 arch/mips/kernel/scall64-o32.S                  |    6 +-
 arch/mips/kernel/syscall.c                      |   52 ---
 arch/mips/kernel/xlr_fast_sys_call_handler.S    |  518 -----------------------
 arch/mips/netlogic/xlr/setup.c                  |    4 +-
 10 files changed, 593 insertions(+), 641 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/nlm_fs.h
 delete mode 100644 arch/mips/include/asm/netlogic/nlm_uaccess_fs.h
 create mode 100644 arch/mips/kernel/nlm_fs.c
 create mode 100644 arch/mips/kernel/nlm_fs_handler.S
 delete mode 100644 arch/mips/kernel/xlr_fast_sys_call_handler.S

diff --git a/arch/mips/include/asm/netlogic/nlm_fs.h b/arch/mips/include/asm/netlogic/nlm_fs.h
new file mode 100644
index 0000000..67200f5
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/nlm_fs.h
@@ -0,0 +1,63 @@
+#ifndef _ASM_NLM_XLR_UACCESS_H
+#define _ASM_NLM_XLR_UACCESS_H
+
+#define NLM_FS_UNUSED             0
+#define NLM_FS_MSGSND             1
+#define NLM_FS_MSGRCV             2
+#define NLM_FS_C0_COUNT           3
+#define NLM_FS_MEM_READ           4
+#define NLM_FS_MEM_WRITE          5
+#define NLM_FS_MSGINT             6
+#define NLM_FS_READ_COP           7
+#define NLM_FS_PERFCTR_START      8
+#define NLM_FS_PERFCTR_STOP       9
+#define NLM_FS_READ_CPUMASKS      10
+#define NLM_FS_READ_PROCID        11
+#define NLM_FS_PROMINFO           12
+#define NLM_FS_READ_TIMER         13
+#define NLM_FS_HARD_CPUID         14
+#define NLM_FS_ENDIANESS          15
+#define NLM_FS_REVERSE_ENDIANESS  16
+#define NLM_FS_USPACE_64BIT_INS   17
+#define NLM_FS_CPU_MAX_FREQ       18
+#define NLM_FS_MEM_READ64         19
+#define NLM_FS_MEM_WRITE64        20
+#define NLM_FS_MEM_READ32         21
+#define NLM_FS_MEM_WRITE32        22
+#define NLM_FS_MSGSND3            23
+#define NLM_FS_MSGRCV1            24
+
+#ifndef __ASSEMBLY__
+
+extern void nlm_fs_mem_read32(void);
+extern void nlm_fs_mem_write32(void);
+extern void nlm_fs_mem_read64(void);
+extern void nlm_fs_mem_write64(void);
+extern void nlm_fs_msgsnd(void);
+extern void nlm_fs_msgrcv(void);
+extern void nlm_fs_c0_count(void);
+extern void nlm_fs_processorId(void);
+extern void nlm_fs_iomem_read(void);
+extern void nlm_fs_iomem_write(void);
+extern void nlm_fs_msg_read(void);
+extern void nlm_fs_perf_ctr_start(void);
+extern void nlm_fs_perf_ctr_stop(void);
+extern void nlm_fs_get_cpumasks(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_hard_cpuid(void);
+extern void nlm_fs_is_big_endian(void);
+extern void nlm_fs_is_endian_reversed(void);
+extern void nlm_fs_uspace_64bit_ins_enabled(void);
+extern void nlm_fs_cpu_max_freq(void);
+
+#if defined(CONFIG_NLM_XLR)
+extern void nlm_fs_prominfo(void);
+#else
+extern void nlm_fs_msgsnd3(void);
+extern void nlm_fs_msgrcv1(void);
+#endif /* CONFIG_NLM_XLR */
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_NLM_XLR_UACCESS_H */
diff --git a/arch/mips/include/asm/netlogic/nlm_uaccess_fs.h b/arch/mips/include/asm/netlogic/nlm_uaccess_fs.h
deleted file mode 100644
index f64b5c1..0000000
--- a/arch/mips/include/asm/netlogic/nlm_uaccess_fs.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef _ASM_NLM_XLR_UACCESS_H
-#define _ASM_NLM_XLR_UACCESS_H
-
-#define NLM_UACCESS_FS_UNUSED             0
-#define NLM_UACCESS_FS_MSGSND             1
-#define NLM_UACCESS_FS_MSGRCV             2
-#define NLM_UACCESS_FS_C0_COUNT           3
-#define NLM_UACCESS_FS_MEM_READ           4
-#define NLM_UACCESS_FS_MEM_WRITE          5
-#define NLM_UACCESS_FS_MSGINT             6
-#define NLM_UACCESS_FS_READ_COP           7
-#define NLM_UACCESS_FS_PERFCTR_START      8
-#define NLM_UACCESS_FS_PERFCTR_STOP       9
-#define NLM_UACCESS_FS_READ_CPUMASKS      10
-#define NLM_UACCESS_FS_READ_PROCID        11
-#define NLM_UACCESS_FS_PROMINFO           12
-#define NLM_UACCESS_FS_READ_TIMER         13
-#define NLM_UACCESS_FS_HARD_CPUID         14
-#define NLM_UACCESS_FS_ENDIANESS          15
-#define NLM_UACCESS_FS_REVERSE_ENDIANESS  16
-#define NLM_UACCESS_FS_USPACE_64BIT_INS   17
-#define NLM_UACCESS_FS_CPU_MAX_FREQ       18
-#if defined(CONFIG_NLM_XLP)
-#define NLM_UACCESS_FS_MEM_READ64         19
-#define NLM_UACCESS_FS_MEM_WRITE64        20
-#define NLM_UACCESS_FS_MEM_READ32         21
-#define NLM_UACCESS_FS_MEM_WRITE32        22
-#define NLM_UACCESS_FS_MSGSND3            23
-#define NLM_UACCESS_FS_MSGRCV1            24
-#endif /* CONFIG_NLM_XLP */
-#ifndef __ASSEMBLY__
-#if defined(CONFIG_NLM_XLP)
-extern void nlm_uaccess_fs_msgsnd(void);
-extern void nlm_uaccess_fs_msgrcv(void);
-extern void nlm_uaccess_fs_mem_read32(void);
-extern void nlm_uaccess_fs_mem_write32(void);
-extern void nlm_uaccess_fs_mem_read64(void);
-extern void nlm_uaccess_fs_mem_write64(void);
-extern void nlm_uaccess_fs_msgsnd3(void);
-extern void nlm_uaccess_fs_msgrcv1(void);
-#endif /* CONFIG_NLM_XLP */
-extern void xlr_fast_syscall_msgsnd(void);
-extern void xlr_fast_syscall_msgld(void);
-extern void xlr_fast_syscall_c0_count(void);
-extern void xlr_fast_syscall_processorId(void);
-extern void xlr_fast_syscall_iomem_read(void);
-extern void xlr_fast_syscall_iomem_write(void);
-extern void xlr_fast_syscall_msg_read(void);
-extern void xlr_fast_syscall_perf_ctr_start(void);
-extern void xlr_fast_syscall_perf_ctr_stop(void);
-extern void xlr_fast_syscall_get_cpumasks(void);
-extern void nlm_uaccess_fs_read_timer(void);
-extern void nlm_uaccess_fs_read_timer(void);
-extern void nlm_uaccess_fs_hard_cpuid(void);
-extern void nlm_uaccess_fs_is_big_endian(void);
-extern void nlm_uaccess_fs_is_endian_reversed(void);
-extern void nlm_uaccess_fs_uspace_64bit_ins_enabled(void);
-#if defined(CONFIG_NLM_XLR)
-extern void xlr_fast_syscall_prominfo(void);
-#endif
-extern void nlm_uaccess_fs_cpu_max_freq(void);
-#endif
-
-#endif /* _ASM_NLM_XLR_UACCESS_H */
diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
index 0543c17..33f806e 100644
--- a/arch/mips/kernel/Makefile
+++ b/arch/mips/kernel/Makefile
@@ -55,9 +55,11 @@ obj-$(CONFIG_CPU_TX39XX)	+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_TX49XX)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_VR41XX)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= octeon_switch.o
+
 obj-$(CONFIG_CPU_XLR)		+= r4k_fpu.o r4k_switch.o
+obj-$(CONFIG_CPU_XLR)		+= nlm_fs_handler.o nlm_fs.o
 obj-$(CONFIG_CPU_XLP)		+= r4k_fpu.o r4k_switch.o
-obj-$(CONFIG_CPU_XLP)		+= xlr_fast_sys_call_handler.o
+obj-$(CONFIG_CPU_XLP)		+= nlm_fs_handler.o nlm_fs.o
 
 obj-$(CONFIG_SMP)		+= smp.o
 obj-$(CONFIG_SMP_UP)		+= smp-up.o
diff --git a/arch/mips/kernel/nlm_fs.c b/arch/mips/kernel/nlm_fs.c
new file mode 100644
index 0000000..4f6e24d
--- /dev/null
+++ b/arch/mips/kernel/nlm_fs.c
@@ -0,0 +1,47 @@
+#include <linux/compiler.h>
+#include <linux/module.h>
+
+#include <asm/netlogic/nlm_fs.h>
+
+static void nlm_fs_unused(void)
+{
+	/* dummy function */
+}
+
+unsigned long nlm_fs_table[] = {
+	[NLM_FS_UNUSED]           = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGSND]           = (unsigned long)nlm_fs_msgsnd,
+	[NLM_FS_MSGRCV]           = (unsigned long)nlm_fs_msgrcv,
+	[NLM_FS_C0_COUNT]         = (unsigned long)nlm_fs_c0_count,
+	[NLM_FS_MEM_READ]         = (unsigned long)nlm_fs_iomem_read,
+	[NLM_FS_MEM_WRITE]        = (unsigned long)nlm_fs_iomem_write,
+	[NLM_FS_MSGINT]           = (unsigned long)nlm_fs_unused,
+	[NLM_FS_READ_COP]         = (unsigned long)nlm_fs_msg_read,
+	[NLM_FS_PERFCTR_START]    = (unsigned long)nlm_fs_perf_ctr_start,
+	[NLM_FS_PERFCTR_STOP]     = (unsigned long)nlm_fs_perf_ctr_stop,
+	[NLM_FS_CPU_MAX_FREQ]     = (unsigned long)nlm_fs_cpu_max_freq,
+	[NLM_FS_READ_PROCID]      = (unsigned long)nlm_fs_processorId,
+	[NLM_FS_READ_TIMER]       = (unsigned long)nlm_fs_read_timer,
+	[NLM_FS_HARD_CPUID]       = (unsigned long)nlm_fs_hard_cpuid,
+	[NLM_FS_ENDIANESS]        = (unsigned long)nlm_fs_is_big_endian,
+	[NLM_FS_REVERSE_ENDIANESS]= (unsigned long)nlm_fs_is_endian_reversed,
+	[NLM_FS_USPACE_64BIT_INS] = (unsigned long)nlm_fs_uspace_64bit_ins_enabled,
+	[NLM_FS_MEM_READ64]       = (unsigned long)nlm_fs_mem_read64,
+	[NLM_FS_MEM_WRITE64]      = (unsigned long)nlm_fs_mem_write64,
+	[NLM_FS_MEM_READ32]       = (unsigned long)nlm_fs_mem_read32,
+	[NLM_FS_MEM_WRITE32]      = (unsigned long)nlm_fs_mem_write32,
+
+#if defined(CONFIG_NLM_XLR)
+	[NLM_FS_READ_CPUMASKS]    = (unsigned long)nlm_fs_get_cpumasks,
+	[NLM_FS_PROMINFO]         = (unsigned long)nlm_fs_prominfo,
+	[NLM_FS_MSGSND3]          = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGRCV1]          = (unsigned long)nlm_fs_unused,
+#else
+	[NLM_FS_READ_CPUMASKS]    = (unsigned long)nlm_fs_unused,
+	[NLM_FS_PROMINFO]         = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGSND3]          = (unsigned long)nlm_fs_msgsnd3,
+	[NLM_FS_MSGRCV1]          = (unsigned long)nlm_fs_msgrcv1,
+#endif /* CONFIG_NLM_XLR */
+	0
+};
+
diff --git a/arch/mips/kernel/nlm_fs_handler.S b/arch/mips/kernel/nlm_fs_handler.S
new file mode 100644
index 0000000..563dea9
--- /dev/null
+++ b/arch/mips/kernel/nlm_fs_handler.S
@@ -0,0 +1,474 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permited provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/asm-offsets.h>
+
+#include <asm/netlogic/perf_ctr.h>
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/nlm_fs.h>
+
+#ifdef CONFIG_32BIT
+	#define T0 t0
+	#define T1 t1
+	#define T2 t2
+	#define T3 t3
+	#define T4 t4
+	#define T5 t5
+	#define T6 t6
+	#define T7 t7
+#else
+	#define T0 ta0
+	#define T1 ta1
+	#define T2 ta2
+	#define T3 ta3
+	#define T4 t0
+	#define T5 t1
+	#define T6 t2
+	#define T7 t3
+#endif
+	.text
+	.set	push
+	.set	noreorder
+	.set	mips64
+	.align	5
+
+.macro	fs_eret
+	/* skip the syscall instruction */
+	MFC0    k0, CP0_EPC
+	PTR_ADDIU   k0, 4
+	MTC0    k0, CP0_EPC
+	eret
+.endm
+
+#if defined(CONFIG_NLM_XLR)
+
+NESTED(nlm_fs_msgsnd, PT_SIZE, sp)
+
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, $0, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, $0, 1
+
+	/* msgsnd dst is in t0 */
+1:	c2	0x80001
+	mfc2	T1, $2
+	andi	T1, T1, 0x06
+	bnez	T1, 1b
+	nop
+
+	fs_eret
+END(nlm_fs_msgsnd)
+
+NESTED(nlm_fs_msgrcv, PT_SIZE, sp)
+	/* t0 has the bucket arg */
+	c2	0x80002
+1:	mfc2	T3, $2
+	andi	k0, T3, 0x08
+	bnez	k0, 1b
+	nop
+	andi    T0, T3, 0x30
+	bnez	T0, 2f
+	nop
+	dmfc2	T2, $1, 0
+	dmfc2   T5, $1, 1
+	nop
+	dsra32  T1, T2, 0
+	dsra32  T4, T5, 0
+2:
+
+	/* move    t0, k0 */
+
+	fs_eret
+END(nlm_fs_msgrcv)
+
+NESTED(nlm_fs_get_cpumasks, PT_SIZE, sp)
+
+	.word 0x40088007
+	move k0, T0
+	srl  T0, T0, 4
+	andi T0, T0, 0x3f
+	sll  T0, T0, 2
+	andi k0, k0, 0x0f
+	or T0, T0, k0
+
+	PTR_LA k0, fast_syscall_cpumask_phy		;
+	lw T1, (k0)
+
+	fs_eret
+END(nlm_fs_get_cpumasks)
+
+NESTED(nlm_fs_prominfo, PT_SIZE, sp)
+
+	PTR_LA	k0, prom_info_copy
+	move	k1, T0
+	sll	k1, k1, 3
+	addu	k0, k0, k1
+	lw	T1, (k0)
+	lw	T2, 4(k0)
+
+	fs_eret
+END(nlm_fs_prominfo)
+
+#else /* CONFIG_NLM_XLR */
+
+#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
+
+	.set	arch=xlp
+
+NESTED(nlm_fs_msgsnd3, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	/* msgsnd arg1 is in (t5, t6) */
+	dsll32  k0, T5, 0
+	dsll32	k1, T6, 0
+	dsrl32	T6, k1, 0
+	or      T5, k0, T6
+	dmtc2   T5, XLP_TX_BUF_REG, 2
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd3)
+
+NESTED(nlm_fs_msgsnd, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd)
+
+NESTED(nlm_fs_msgrcv, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dmfc2   T5, XLP_RX_BUF_REG, 1
+	dsra32  T1, T2, 0
+	dsra32  T4, T5, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv)
+
+NESTED(nlm_fs_msgrcv1, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dsra32  T1, T2, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv1)
+
+#endif /* CONFIG_NLM_XLP */
+
+NESTED(nlm_fs_mem_read64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	ld	T3, (T0)
+	dsra32	T2, T3, 0
+
+	fs_eret
+END(nlm_fs_mem_read64)
+
+NESTED(nlm_fs_mem_write64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	dsll32  k0, T2, 0
+	dsll32	k1, T3, 0
+	dsrl32	T3, k1, 0
+	or      T1, k0, T3
+
+	sd	T1, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write64)
+
+NESTED(nlm_fs_mem_read32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	lw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_read32)
+
+NESTED(nlm_fs_mem_write32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	sw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write32)
+
+NESTED(nlm_fs_c0_count, PT_SIZE, sp)
+
+	mfc0    T0, $9, 0
+
+	fs_eret
+END(nlm_fs_c0_count)
+
+NESTED(nlm_fs_iomem_read, PT_SIZE, sp)
+
+	/* t0 has the address */
+	lw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_read)
+
+NESTED(nlm_fs_iomem_write, PT_SIZE, sp)
+
+	/* t0 has the address, t1 has the data */
+	sw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_write)
+
+
+NESTED(nlm_fs_msg_write, PT_SIZE, sp)
+
+	/* disable the message ring interrupts and enable 64 bits operations */
+	mfc0    k0, CP0_STATUS
+	li      k1, 1
+	dsll    k1, k1, 30
+	or      k0, k0, k1
+	li      k1, 1
+	dsll    k1, k1, 23
+	or      k0, k0, k1
+	mtc0    k0, CP0_STATUS
+	bnez	T1, 1f
+	nop
+	mtc2    T1, $3, 0
+1:
+
+	fs_eret
+END(nlm_fs_msg_write)
+
+
+NESTED(nlm_fs_msg_read, PT_SIZE, sp)
+
+	/* read C0 and C2 registers */
+	mfc0    T0, CP0_STATUS
+	mfc2    T1, $2, 0
+	mfc2    T2, $2, 1
+	mfc2    T3, $3, 0
+	mfc2    T4, $3, 1
+
+	fs_eret
+END(nlm_fs_msg_read)
+
+NESTED(nlm_fs_perf_ctr_start, PT_SIZE, sp)
+
+	/* reset value counters */
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+
+	/* arm the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T1, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	fs_eret
+END(nlm_fs_perf_ctr_start)
+
+	/* {evt@0:hi=T1, evt@0:lo=T0}
+	 * {evt@1:hi=T3, evt@1:lo=T2}
+	 * nlm_fs_perf_ctr_stop(uint32_t val) */
+NESTED(nlm_fs_perf_ctr_stop, PT_SIZE, sp)
+
+	/* stop the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	/* load return values */
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dsrl32 	 T1, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T0, k1, 0
+
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+	dsrl32 	 T3, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T2, k1, 0
+
+	fs_eret
+END(nlm_fs_perf_ctr_stop)
+
+NESTED(nlm_fs_processorId, PT_SIZE, sp)
+
+	mfc0    T1, $15, 0
+
+	fs_eret
+END(nlm_fs_processorId)
+
+NESTED(nlm_fs_read_timer, PT_SIZE, sp)
+
+#if defined(CONFIG_NLM_XLP)
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+        MFC0    k0, CP0_PRID, 1
+        andi    k0, k0, 0x3ff
+        srl     k0, k0, 5  /* grab node id */
+        sll     k0, k0, 18 /* Use local PIC */
+        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        dadd    k0, k1, k0
+	ld	k1, 0(k0)
+	dsrl32	$9, k1, 0
+	dsll32  $8, k1, 0
+	dsrl32  $8, T0, 0
+#else
+	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_0 << 2)
+	lw	$8, 0(k0)
+	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_1 << 2)
+	lw	$9, 0(k0)
+#endif
+	fs_eret
+
+END(nlm_fs_read_timer)
+
+NESTED(nlm_fs_hard_cpuid, PT_SIZE, sp)
+
+	mfc0	T0, $15, 1
+	andi	T0, T0, 0x3ff
+
+	fs_eret
+
+END(nlm_fs_hard_cpuid)
+
+NESTED(nlm_fs_is_big_endian, PT_SIZE, sp)
+	mfc0	T0, $16, 0
+	andi	T0, T0, 0x8000
+
+	fs_eret
+END(nlm_fs_is_big_endian)
+
+NESTED(nlm_fs_is_endian_reversed, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x2000000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_is_endian_reversed)
+
+NESTED(nlm_fs_uspace_64bit_ins_enabled, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x800000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_uspace_64bit_ins_enabled)
+
+	/* {hi=T1, lo=T0} nlm_fs_cpu_max_freq(void) */
+NESTED(nlm_fs_cpu_max_freq, PT_SIZE, sp)
+	PTR_LA k0, mips_hpt_frequency
+	lw     k1, 0(k0)
+	dsrl32 T1, k1, 0
+	dsll32 k1, k1, 0
+	dsrl32 T0, k1, 0
+
+	fs_eret
+END(nlm_fs_cpu_max_freq)
+
+	.set pop
diff --git a/arch/mips/kernel/scall32-o32.S b/arch/mips/kernel/scall32-o32.S
index ebdc3e5..f4750b1 100644
--- a/arch/mips/kernel/scall32-o32.S
+++ b/arch/mips/kernel/scall32-o32.S
@@ -47,7 +47,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 	beqz	k0, 1f
 	nop
 	sll	k0, k0, 2
-	lw	k1, xlr_fast_sys_call_table(k0)
+	lw	k1, nlm_fs_table(k0)
 	jr	k1
 	nop
 	/* should never come here */
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index d8fb3e1..3cab205 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -28,7 +28,7 @@
 	.align  5
 NESTED(handle_sys, PT_SIZE, sp)
 #ifdef CONFIG_64BIT
-#ifdef CONFIG_NLM_COMMON 
+#ifdef CONFIG_NLM_COMMON
 	.set push
 	.set	noat
 	.set mips64
@@ -40,7 +40,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 	beqz	k0, 1f
 	nop
 	sll	k0, k0, 3
-	PTR_LA  k1, xlr_fast_sys_call_table
+	PTR_LA  k1, nlm_fs_table
 	PTR_ADDU k1,k0,k1
 	ld	k1, 0(k1)
 	jr	k1
@@ -49,7 +49,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 2:	wait
 	b	2b
 	nop
-1:		
+1:
 	.set pop
 #endif
 #endif
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index 9dc022b..ee290d2 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -52,58 +52,6 @@ the header of the original work apply to this derived work.
 #include <asm/uaccess.h>
 #include <asm/switch_to.h>
 
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/nlm_uaccess_fs.h>
-
-#if defined(CONFIG_NLM_XLP)
-#define xlr_fast_syscall_msgsnd nlm_uaccess_fs_msgsnd
-#define xlr_fast_syscall_msgld  nlm_uaccess_fs_msgrcv
-#endif /* CONFIG_NLM_XLP */
-
-static void xlr_fast_syscall_unused(void) {}
-unsigned long xlr_fast_sys_call_table[] = {
-	[NLM_UACCESS_FS_UNUSED] = (unsigned long)xlr_fast_syscall_unused,
-	[NLM_UACCESS_FS_MSGSND] = (unsigned long)xlr_fast_syscall_msgsnd,
-	[NLM_UACCESS_FS_MSGRCV] = (unsigned long)xlr_fast_syscall_msgld,
-	[NLM_UACCESS_FS_C0_COUNT] = (unsigned long)xlr_fast_syscall_c0_count,
-	[NLM_UACCESS_FS_MEM_READ] = (unsigned long)xlr_fast_syscall_iomem_read,
-	[NLM_UACCESS_FS_MEM_WRITE] = (unsigned long)xlr_fast_syscall_iomem_write,
-	[NLM_UACCESS_FS_MSGINT] = (unsigned long)xlr_fast_syscall_unused,
-	[NLM_UACCESS_FS_READ_COP] = (unsigned long)xlr_fast_syscall_msg_read,
-	[NLM_UACCESS_FS_PERFCTR_START] = (unsigned long)xlr_fast_syscall_perf_ctr_start,
-	[NLM_UACCESS_FS_PERFCTR_STOP] = (unsigned long)xlr_fast_syscall_perf_ctr_stop,
-
-#if defined(CONFIG_NLM_XLR)
-	[NLM_UACCESS_FS_READ_CPUMASKS] = (unsigned long)xlr_fast_syscall_get_cpumasks,
-#else
-	[NLM_UACCESS_FS_READ_CPUMASKS] = (unsigned long)xlr_fast_syscall_unused,
-#endif
-
-	[NLM_UACCESS_FS_READ_PROCID] = (unsigned long)xlr_fast_syscall_processorId,
-	[NLM_UACCESS_FS_READ_TIMER] = (unsigned long)nlm_uaccess_fs_read_timer,
-	[NLM_UACCESS_FS_HARD_CPUID] = (unsigned long)nlm_uaccess_fs_hard_cpuid,
-	[NLM_UACCESS_FS_ENDIANESS] = (unsigned long)nlm_uaccess_fs_is_big_endian,
-	[NLM_UACCESS_FS_REVERSE_ENDIANESS] = (unsigned long)nlm_uaccess_fs_is_endian_reversed,
-	[NLM_UACCESS_FS_USPACE_64BIT_INS] = (unsigned long)nlm_uaccess_fs_uspace_64bit_ins_enabled,
-
-#if defined(CONFIG_NLM_XLR)
-	[NLM_UACCESS_FS_PROMINFO] = (unsigned long)xlr_fast_syscall_prominfo,
-#endif
-	[NLM_UACCESS_FS_CPU_MAX_FREQ] = (unsigned long)nlm_uaccess_fs_cpu_max_freq,
-
-#if defined(CONFIG_NLM_XLP)
-	[NLM_UACCESS_FS_MEM_READ64] = (unsigned long)nlm_uaccess_fs_mem_read64,
-	[NLM_UACCESS_FS_MEM_WRITE64] = (unsigned long)nlm_uaccess_fs_mem_write64,
-	[NLM_UACCESS_FS_MEM_READ32] = (unsigned long)nlm_uaccess_fs_mem_read32,
-	[NLM_UACCESS_FS_MEM_WRITE32] = (unsigned long)nlm_uaccess_fs_mem_write32,
-	[NLM_UACCESS_FS_MSGSND3] = (unsigned long)nlm_uaccess_fs_msgsnd3,
-	[NLM_UACCESS_FS_MSGRCV1] = (unsigned long)nlm_uaccess_fs_msgrcv1,
-#endif /* CONFIG_NLM_XLP */
-	0
-};
-
-#endif
-
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
  * convention.  It returns results in registers $v0 / $v1 which means there
diff --git a/arch/mips/kernel/xlr_fast_sys_call_handler.S b/arch/mips/kernel/xlr_fast_sys_call_handler.S
deleted file mode 100644
index ab88dc9..0000000
--- a/arch/mips/kernel/xlr_fast_sys_call_handler.S
+++ /dev/null
@@ -1,518 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permited provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
-
-#include <asm/addrspace.h>
-#include <asm/asm.h>
-#include <asm/mipsregs.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-#include <asm/netlogic/perf_ctr.h>
-#include <asm/netlogic/interrupt.h>
-#include <asm/netlogic/nlm_uaccess_fs.h>
-#include <asm/asm-offsets.h>
-
-#ifdef CONFIG_32BIT
-	#define T0 t0
-	#define T1 t1
-	#define T2 t2
-	#define T3 t3
-	#define T4 t4
-	#define T5 t5
-	#define T6 t6
-	#define T7 t7
-#else
-	#define T0 ta0
-	#define T1 ta1
-	#define T2 ta2
-	#define T3 ta3
-	#define T4 t0
-	#define T5 t1
-	#define T6 t2
-	#define T7 t3
-#endif
-	.text
-	.set	push
-	.set	noreorder
-	.set	mips64
-	.align	5
-
-.macro	fs_eret
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-.endm
-
-#if defined(CONFIG_NLM_XLP)
-#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
-
-	.set	arch=xlp
-
-NESTED(nlm_uaccess_fs_msgsnd3, PT_SIZE, sp)
-	/* msgsnd arg0 is in (t1, t2) */
-	dsll32  k0, T1, 0
-	dsll32	k1, T2, 0
-	dsrl32	T2, k1, 0
-	or      T1, k0, T2
-	dmtc2	T1, XLP_TX_BUF_REG, 0
-
-	/* msgsnd arg1 is in (t3, t4) */
-	dsll32  k0, T3, 0
-	dsll32	k1, T4, 0
-	dsrl32	T4, k1, 0
-	or      T3, k0, T4
-	dmtc2   T3, XLP_TX_BUF_REG, 1
-
-	/* msgsnd arg1 is in (t5, t6) */
-	dsll32  k0, T5, 0
-	dsll32	k1, T6, 0
-	dsrl32	T6, k1, 0
-	or      T5, k0, T6
-	dmtc2   T5, XLP_TX_BUF_REG, 2
-
-	sync
-
-	/* msgsnd dst is in t0, status returned in t1 */
-1:	msgsnds	T1, T0
-	beqz	T1, 1b /* comment out the branch              */
-	nop            /* for non-blocking msgsnd fastsyscall */
-
-	fs_eret
-END(nlm_uaccess_fs_msgsnd3)
-
-NESTED(nlm_uaccess_fs_msgsnd, PT_SIZE, sp)
-	/* msgsnd arg0 is in (t1, t2) */
-	dsll32  k0, T1, 0
-	dsll32	k1, T2, 0
-	dsrl32	T2, k1, 0
-	or      T1, k0, T2
-	dmtc2	T1, XLP_TX_BUF_REG, 0
-
-	/* msgsnd arg1 is in (t3, t4) */
-	dsll32  k0, T3, 0
-	dsll32	k1, T4, 0
-	dsrl32	T4, k1, 0
-	or      T3, k0, T4
-	dmtc2   T3, XLP_TX_BUF_REG, 1
-
-	sync
-
-	/* msgsnd dst is in t0, status returned in t1 */
-1:	msgsnds	T1, T0
-	beqz	T1, 1b /* comment out the branch              */
-	nop            /* for non-blocking msgsnd fastsyscall */
-
-	fs_eret
-END(nlm_uaccess_fs_msgsnd)
-
-NESTED(nlm_uaccess_fs_msgrcv, PT_SIZE, sp)
-	/* msgld vc is in t0, status returned in k0 */
-	msglds	k0, T0
-	beqz	k0, 1f
-	move	T0, k0
-
-	/* msgld status  t0       *
-	 * arg0          (t1, t2) *
-	 * msg_rxstatus  t3       *
-	 * arg1          (t4, t5) */
-	mfc2	T3, XLP_MSG_RXSTATUS_REG
-	dmfc2	T2, XLP_RX_BUF_REG, 0
-	dmfc2   T5, XLP_RX_BUF_REG, 1
-	dsra32  T1, T2, 0
-	dsra32  T4, T5, 0
-1:
-	fs_eret
-END(nlm_uaccess_fs_msgrcv)
-
-NESTED(nlm_uaccess_fs_msgrcv1, PT_SIZE, sp)
-	/* msgld vc is in t0, status returned in k0 */
-	msglds	k0, T0
-	beqz	k0, 1f
-	move	T0, k0
-
-	/* msgld status  t0       *
-	 * arg0          (t1, t2) *
-	 * msg_rxstatus  t3       *
-	 * arg1          (t4, t5) */
-	mfc2	T3, XLP_MSG_RXSTATUS_REG
-	dmfc2	T2, XLP_RX_BUF_REG, 0
-	dsra32  T1, T2, 0
-1:
-	fs_eret
-END(nlm_uaccess_fs_msgrcv1)
-
-
-NESTED(nlm_uaccess_fs_mem_read64, PT_SIZE, sp)
-	/* address is in (t0, t1) */
-	dsll32  k0, T0, 0
-	dsll32	k1, T1, 0
-	dsrl32	T1, k1, 0
-	or      T0, k0, T1
-
-	/* data is in (t2, t3) */
-	ld	T3, (T0)
-	dsra32	T2, T3, 0
-
-	fs_eret
-END(nlm_uaccess_fs_mem_read64)
-
-NESTED(nlm_uaccess_fs_mem_write64, PT_SIZE, sp)
-	/* address is in (t0, t1) */
-	dsll32  k0, T0, 0
-	dsll32	k1, T1, 0
-	dsrl32	T1, k1, 0
-	or      T0, k0, T1
-
-	/* data is in (t2, t3) */
-	dsll32  k0, T2, 0
-	dsll32	k1, T3, 0
-	dsrl32	T3, k1, 0
-	or      T1, k0, T3
-
-	sd	T1, (T0)
-
-	fs_eret
-END(nlm_uaccess_fs_mem_write64)
-
-NESTED(nlm_uaccess_fs_mem_read32, PT_SIZE, sp)
-	/* address is in (t0, t1) */
-	dsll32  k0, T0, 0
-	dsll32	k1, T1, 0
-	dsrl32	T1, k1, 0
-	or      T0, k0, T1
-
-	/* data is in t2 */
-	lw	T2, (T0)
-
-	fs_eret
-END(nlm_uaccess_fs_mem_read32)
-
-NESTED(nlm_uaccess_fs_mem_write32, PT_SIZE, sp)
-	/* address is in (t0, t1) */
-	dsll32  k0, T0, 0
-	dsll32	k1, T1, 0
-	dsrl32	T1, k1, 0
-	or      T0, k0, T1
-
-	/* data is in t2 */
-	sw	T2, (T0)
-
-	fs_eret
-END(nlm_uaccess_fs_mem_write32)
-
-
-#endif /* CONFIG_NLM_XLP */
-
-	NESTED(xlr_fast_syscall_msgsnd, PT_SIZE, sp)
-
-	/* msgsnd arg0 is in (t1, t2) */
-	dsll32  k0, T1, 0
-	dsll32	k1, T2, 0
-	dsrl32	T2, k1, 0
-	or      T1, k0, T2
-	dmtc2	T1, $0, 0
-
-	/* msgsnd arg1 is in (t3, t4) */
-	dsll32  k0, T3, 0
-	dsll32	k1, T4, 0
-	dsrl32	T4, k1, 0
-	or      T3, k0, T4
-	dmtc2   T3, $0, 1
-
-	/* msgsnd dst is in t0 */
-1:	c2	0x80001
-	mfc2	T1, $2
-	andi	T1, T1, 0x06
-	bnez	T1, 1b
-	nop
-
-	/* skip the syscall instruction */
-	MFC0	k0, CP0_EPC
-	PTR_ADDIU	k0, 4
-	MTC0	k0, CP0_EPC
-	eret
-	END(xlr_fast_syscall_msgsnd)
-
-	NESTED(xlr_fast_syscall_msgld, PT_SIZE, sp)
-	/* t0 has the bucket arg */
-	c2	0x80002
-1:	mfc2	T3, $2
-	andi	k0, T3, 0x08
-	bnez	k0, 1b
-	nop
-	andi    T0, T3, 0x30
-	bnez	T0, 2f
-	nop
-	dmfc2	T2, $1, 0
-	dmfc2   T5, $1, 1
-	nop
-	dsra32  T1, T2, 0
-	dsra32  T4, T5, 0
-2:
-
-	/* move    t0, k0 */
-
-	/* skip the syscall instruction */
-	MFC0	k0, CP0_EPC
-	PTR_ADDIU	k0, 4
-	MTC0	k0, CP0_EPC
-	eret
-	END(xlr_fast_syscall_msgld)
-
-	NESTED(xlr_fast_syscall_c0_count, PT_SIZE, sp)
-
-	mfc0    T0, $9, 0
-
-	/* skip the syscall instruction */
-	MFC0	k0, CP0_EPC
-	PTR_ADDIU	k0, 4
-	MTC0	k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_c0_count)
-
-	NESTED(xlr_fast_syscall_iomem_read, PT_SIZE, sp)
-
-	/* t0 has the address */
-	lw      T1, (T0)
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_iomem_read)
-
-	NESTED(xlr_fast_syscall_iomem_write, PT_SIZE, sp)
-
-	/* t0 has the address, t1 has the data */
-	sw      T1, (T0)
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_iomem_write)
-
-
-	NESTED(xlr_fast_syscall_msg_write, PT_SIZE, sp)
-
-	/* disable the message ring interrupts and enable 64 bits operations */
-	mfc0    k0, CP0_STATUS
-	li      k1, 1
-	dsll    k1, k1, 30
-	or      k0, k0, k1
-	li      k1, 1
-	dsll    k1, k1, 23
-	or      k0, k0, k1
-	mtc0    k0, CP0_STATUS
-	bnez	T1, 1f
-	nop
-	mtc2    T1, $3, 0
-1:
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_msg_write)
-
-
-	NESTED(xlr_fast_syscall_msg_read, PT_SIZE, sp)
-
-	/* read C0 and C2 registers */
-	mfc0    T0, CP0_STATUS
-	mfc2    T1, $2, 0
-	mfc2    T2, $2, 1
-	mfc2    T3, $3, 0
-	mfc2    T4, $3, 1
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_msg_read)
-
-	NESTED(xlr_fast_syscall_perf_ctr_start, PT_SIZE, sp)
-
-	mtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
-	mtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
-	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
-	mtc0    T1, CP0_PERF_CTR, PERF_CTR_EVENT1
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_perf_ctr_start)
-
-	NESTED(xlr_fast_syscall_perf_ctr_stop, PT_SIZE, sp)
-
-	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
-	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT1
-	mfc0    T1, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
-	mfc0    T2, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU   k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_perf_ctr_stop)
-
-#if defined(CONFIG_NLM_XLR)
-	NESTED(xlr_fast_syscall_get_cpumasks, PT_SIZE, sp)
-
-		.word 0x40088007
-		move k0, T0
-		srl  T0, T0, 4
-		andi T0, T0, 0x3f
-		sll  T0, T0, 2
-		andi k0, k0, 0x0f
-		or T0, T0, k0
-
-		PTR_LA k0, fast_syscall_cpumask_phy		;
-		lw T1, (k0)
-
-		/* skip the syscall instruction */
-		MFC0	k0, CP0_EPC
-		PTR_ADDIU	k0, 4
-		MTC0	k0, CP0_EPC
-
-		eret
-
-	END(xlr_fast_syscall_get_cpumasks)
-#endif
-
-	NESTED(xlr_fast_syscall_processorId, PT_SIZE, sp)
-
-	mfc0    T1, $15, 0
-
-	/* skip the syscall instruction */
-	MFC0	k0, CP0_EPC
-	PTR_ADDIU	k0, 4
-	MTC0	k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_processorId)
-
-#if defined(CONFIG_NLM_XLR)
-	NESTED(xlr_fast_syscall_prominfo, PT_SIZE, sp)
-
-	PTR_LA	k0, prom_info_copy
-	move	k1, T0
-	sll	k1, k1, 3
-	addu	k0, k0, k1
-	lw	T1, (k0)
-	lw	T2, 4(k0)
-
-	/* skip the syscall instruction */
-	MFC0    k0, CP0_EPC
-	PTR_ADDIU       k0, 4
-	MTC0    k0, CP0_EPC
-	eret
-
-	END(xlr_fast_syscall_prominfo)
-#endif
-	NESTED(nlm_uaccess_fs_read_timer, PT_SIZE, sp)
-
-#if defined(CONFIG_NLM_XLP)
-#include <asm/netlogic/hal/nlm_hal_pic.h>
-        MFC0    k0, CP0_PRID, 1
-        andi    k0, k0, 0x3ff
-        srl     k0, k0, 5  /* grab node id */
-        sll     k0, k0, 18 /* Use local PIC */
-        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
-        dadd    k0, k1, k0
-	ld	k1, 0(k0)
-	dsrl32	$9, k1, 0
-	dsll32  $8, k1, 0
-	dsrl32  $8, T0, 0
-#else
-	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_0 << 2)
-	lw	$8, 0(k0)
-	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_1 << 2)
-	lw	$9, 0(k0)
-#endif
-	fs_eret
-
-	END(nlm_uaccess_fs_read_timer)
-
-	NESTED(nlm_uaccess_fs_hard_cpuid, PT_SIZE, sp)
-
-	mfc0	T0, $15, 1
-	andi	T0, T0, 0x3ff
-
-	fs_eret
-
-	END(nlm_uaccess_fs_hard_cpuid)
-
-	NESTED(nlm_uaccess_fs_is_big_endian, PT_SIZE, sp)
-	mfc0	T0, $16, 0
-	andi	T0, T0, 0x8000
-
-	fs_eret
-	END(nlm_uaccess_fs_is_big_endian)
-
-	NESTED(nlm_uaccess_fs_is_endian_reversed, PT_SIZE, sp)
-	mfc0	T0, $12, 0
-	li	k1, 0x2000000
-	and	T0, T0, k1
-
-	fs_eret
-	END(nlm_uaccess_fs_is_endian_reversed)
-
-	NESTED(nlm_uaccess_fs_uspace_64bit_ins_enabled, PT_SIZE, sp)
-	mfc0	T0, $12, 0
-	li	k1, 0x800000
-	and	T0, T0, k1
-
-	fs_eret
-	END(nlm_uaccess_fs_uspace_64bit_ins_enabled)
-
-	/* {hi=T1, lo=T0} nlm_uaccess_fs_cpu_max_freq(void) */
-	NESTED(nlm_uaccess_fs_cpu_max_freq, PT_SIZE, sp)
-	PTR_LA k0, mips_hpt_frequency
-	lw     k1, 0(k0)
-	dsrl32 T1, k1, 0
-	dsll32 k1, k1, 0
-	dsrl32 T0, k1, 0
-
-	fs_eret
-	END(nlm_uaccess_fs_cpu_max_freq)
-
-	.set pop
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index de01ab4..4cfefa6 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -179,8 +179,8 @@ unsigned long nlm_asid_mask = 0x3f;
 unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
 #endif
 
-/* TODO: This should be removed eventually after taking a look at 
-   nlm_uaccess_fs_cpu_max_freq() and xlr_fast_syscall_prominfo
+/* TODO: This should be removed eventually after taking a look at
+   nlm_fs_cpu_max_freq() and nlm_fs_prominfo
    */
 struct psb_info prom_info_copy; /* Bootloader prom_info is saved here */
 
-- 
1.7.0.4

