From 84e70722889c4cddbbb3b2c867650565fb88abfd Mon Sep 17 00:00:00 2001
From: Om Narasimhan <omn@broadcom.com>
Date: Thu, 7 Jun 2012 14:35:30 -0700
Subject: [PATCH 583/762] frequency : Bug fixes for cpu frequency scaling driver

Existing cpufreq scaling driver did not take care of multiple nodes. This
commit makes the driver multi node aware.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <omn@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c |   21 ---------------------
 arch/mips/netlogic/xlp/xlp-cpufreq.c |   31 +++++++++++++++++++++++++++----
 2 files changed, 27 insertions(+), 25 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 057f475..e0ef8f6 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -277,24 +277,3 @@ u32 get_core_dfs(int cpu_num)
 
 EXPORT_SYMBOL(get_core_dfs);
 
-/*
- * @cpu_num : # of the cpu
- * @dec	: whether to decrement frequency
- * NOTE: If frequency to be decremented, multiplier should be incremented
- */
-u32 change_cpu_freq(int cpu_num, int dec)
-{
-	volatile u32 *mmio;
-	u32 val;
-	/* INC freq --> DEC multiplier */
-	u32 reg = (dec == 1) ? SYS_COREDFSDIVINCCTRL: SYS_COREDFSDIVDECCTRL;
-
-	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
-	val = (0x1 << (cpu_num >> 2));
-	nlm_hal_write_32bit_reg((uint64_t)mmio, reg, val);
-	//printk("NLM: %#x\n", nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL));
-	return 0;
-}
-
-EXPORT_SYMBOL(change_cpu_freq);
-
diff --git a/arch/mips/netlogic/xlp/xlp-cpufreq.c b/arch/mips/netlogic/xlp/xlp-cpufreq.c
index bca080c..f5925a0 100644
--- a/arch/mips/netlogic/xlp/xlp-cpufreq.c
+++ b/arch/mips/netlogic/xlp/xlp-cpufreq.c
@@ -43,6 +43,28 @@ static int xlp_cpufreq_verify_speed(struct cpufreq_policy *policy)
 	return cpufreq_frequency_table_verify(policy, xlp_freq_table);
 }
 
+static u64 xlp_syscfg_base[NLM_MAX_CPU_NODE] = { XLP_BDF_BASE(0,6,5),
+	XLP_BDF_BASE(0,14,5), XLP_BDF_BASE(0,22,5), XLP_BDF_BASE(0,30,5) };
+/*
+ * @cpu_num : # of the cpu
+ * @dec	: whether to decrement frequency
+ * NOTE: If frequency to be decremented, multiplier should be incremented
+ */
+u32 change_cpu_freq(int cpu, int dec)
+{
+	u32 val;
+	u8 node = cpu / NLM_MAX_CPU_PER_NODE;
+	cpu %= NLM_MAX_CPU_PER_NODE;
+
+	/* INC freq --> DEC multiplier */
+	u32 reg = (dec == 1) ? 0x52 : 0x53;	/* Increment/Decrement reg */
+	val = (0x1 << (cpu >> 2));
+	nlm_hal_write_32bit_reg(xlp_syscfg_base[node], reg, val);
+	return 0;
+}
+
+EXPORT_SYMBOL(change_cpu_freq);
+
 static void setup_affected_cpus(struct cpumask map)
 {
 	/* Find out the number of cores. Read SYS, reg 0x42 bits 0-7,
@@ -108,9 +130,10 @@ static int xlp_freq_set(struct cpufreq_frequency_table *from,
 
 	spin_lock_irqsave(&freq_lock, flags);
 	for (i = from->index; i != to->index; ){
-			change_cpu_freq(cpu, dec);
-			/* To decrement frequency, INC index */
-			i = (dec == 1) ? (i + 1) : (i - 1);
+		fdebug("i = %d\n", i);
+		change_cpu_freq(cpu, dec);
+		/* To decrement frequency, INC index */
+		i = (dec == 1) ? (i + 1) : (i - 1);
 	}
 	spin_unlock_irqrestore(&freq_lock, flags);
 	return 0;
@@ -120,7 +143,7 @@ static int xlp_cpufreq_set_target(struct cpufreq_policy *policy,
 				      unsigned int relation)
 {
 	int ret;
-	unsigned int i = 0, tmp = 0, cpu;
+	unsigned int i = 0, tmp = 0;
 	struct cpufreq_freqs freq;
 	u32 cur_freq;
 	u32 start, end;
-- 
1.7.0.4

