From a1a5a95b112ab37162398294b141e053d455d11a Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikasg@netlogicmicro.com>
Date: Thu, 5 May 2011 11:41:17 +0530
Subject: [PATCH 275/762] DMA support added followed by some cleanups.

Based on Broadcom SDK 2.3.

Signed-off-by: Vikas Gupta <vikasg@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mmc/host/xlpmmc.c |   67 ++++++++++++++++++++++++++++++++-------------
 drivers/mmc/host/xlpmmc.h |    5 +++-
 2 files changed, 52 insertions(+), 20 deletions(-)

diff --git a/drivers/mmc/host/xlpmmc.c b/drivers/mmc/host/xlpmmc.c
index 5a6993c..94d04a8 100644
--- a/drivers/mmc/host/xlpmmc.c
+++ b/drivers/mmc/host/xlpmmc.c
@@ -1,6 +1,5 @@
-
 /***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems ("Netlogic" ). All rights
+ * Copyright 2003-2011 Netlogic Microsystems ("Netlogic" ). All rights
  * reserved.
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -75,6 +74,9 @@ struct xlpmmc_host {
 	struct platform_device *pdev;
 };
 
+#define XLPMMC_DESCRIPTOR_SIZE (64<<10)
+#define XLPMMC_DESCRIPTOR_COUNT  1	
+
 /* Status flags used by the host structure */
 #define HOST_F_XMIT	0x0001
 #define HOST_F_RECV	0x0002
@@ -128,9 +130,12 @@ static inline u32 hc_rd16(void *iobase, int offset, int slot) {
 
 static void dump_hc_regs(struct xlpmmc_host *host)
 {
+#ifdef XLP_MMC_DEBUG	
 	printk ("MMC_PRESENT STATE = 0x%x\n", hc_rd32((host->base), HC_PRESENT_STATE_LO, 0));
 	printk ("MMC_POWER_CTL = 0x%x\n", hc_rd16((host->base), HC_PC_HC, 0));
 	printk ("MMC_CLOK_CTL = 0x%x\n", hc_rd16((host->base), HC_CLOCK_CTRL, 0));
+	printk ("MMC_CAP0 = 0x%x\n", hc_rd32((host->base), 0x204, 0));
+#endif
 }
 
 static void xlpmmc_set_power(struct xlpmmc_host *host, int state)
@@ -220,6 +225,9 @@ static int xlpmmc_send_command(struct xlpmmc_host *host, int wait,
 
 		/*enable block count*/	
 		mmccmd |= (1<<1);
+		/*enable dma*/
+		if(host->flags & HOST_F_DMA)
+			mmccmd |= DMA_EN;
 		
 		if (data->blocks == 1){
 			mmccmd |= MBS_SINGLE;
@@ -269,8 +277,12 @@ static void xlpmmc_data_complete(struct xlpmmc_host *host)
 	data->bytes_xfered = 0;
 
 	if (!data->error) {
-		data->bytes_xfered =
-		(data->blocks * data->blksz) - host->pio.len;
+		if(host->flags & HOST_F_DMA){	
+			data->bytes_xfered = (data->blocks * data->blksz); 
+		}else{
+			data->bytes_xfered = (data->blocks * data->blksz) - host->pio.len;
+			
+		}
 	}
 		
 	xlpmmc_finish_request(host);
@@ -445,7 +457,7 @@ static int xlpmmc_prepare_data(struct xlpmmc_host *host,
 	int datalen = data->blocks * data->blksz;
 	u32 mmc_blk_ctl = 0;
 #ifdef XLP_MMC_DEBUG
-	printk("xlpmmc_prepare_data datablks=%d\n", data->blocks);
+	printk("xlpmmc_prepare_data datablks=%d block sz= 0x%x\n", data->blocks,  data->blksz);
 #endif
 	if (data->flags & MMC_DATA_READ)
 		host->flags |= HOST_F_RECV;
@@ -460,6 +472,15 @@ static int xlpmmc_prepare_data(struct xlpmmc_host *host,
 	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
 				   data->sg_len, host->dma.dir);
 
+	if(host->flags & HOST_F_DMA){
+		struct scatterlist *sg = &data->sg[0];
+		hc_wr32(host->base, HC_SDMA_SA_OR_ARG2_LO, (unsigned long)sg_phys(sg), 0);
+	}else{	
+		host->pio.index = 0;
+		host->pio.offset = 0;
+		host->pio.len = datalen;
+	}
+
 	if (host->dma.len == 0)
 		return -ETIMEDOUT;
 
@@ -467,18 +488,18 @@ static int xlpmmc_prepare_data(struct xlpmmc_host *host,
 		mmc_blk_ctl |=  data->blocks<<BLK_CNT_SHT;
 	else
 		mmc_blk_ctl &= 0xffff;
+	
+	/*Lets slways set 64KB Host bufsize*/
+	mmc_blk_ctl |= HOST_BUF_SZ_64;
+	
 	/*block size bit Xsz[0:11]=[0:11] and Xsz[12]=[15]*/
-	//mmc_blk_ctl |= (data->blksz<< 0)&(0xfff);
 	mmc_blk_ctl |= (data->blksz<< 0);
 	if(data->blksz & BLK_SZ_LOW_BITS)
 		mmc_blk_ctl |= BLK_SZ_HGH_BIT;
 	else
 		mmc_blk_ctl &= ~BLK_SZ_HGH_BIT;
 	hc_wr32(host->base, HC_BLOCK_SIZE, mmc_blk_ctl, 0);
-	
-	host->pio.index = 0;
-	host->pio.offset = 0;
-	host->pio.len = datalen;
+
 	
 	return 0;
 }
@@ -577,9 +598,7 @@ static void xlpmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	}
 	hc_wr16 (host->base, HC_PC_HC, hc_pc_hc, 0);
 	msleep(5);
-#ifdef XLP_MMC_DEBUG
 	dump_hc_regs(host);
-#endif
 }
 
 static irqreturn_t xlpmmc_irq(int irq, void *dev_id)
@@ -633,8 +652,15 @@ static irqreturn_t xlpmmc_irq(int irq, void *dev_id)
 			xlpmmc_data_complete(host);
 			
 
-	} else if (intstatus |= 0x33) { /*TODO: change it as we enable other interrupts in signal register*/
-			printk("Unhandled status 0x%x\n",intstatus);
+	}
+	if((host->flags & HOST_F_DMA) && (intstatus & HNIS_TC_CMPL)){
+		xlpmmc_data_complete(host);
+	}
+	if(!(intstatus &= (HNIS_ERR 
+			| HNIS_CMD_CMPL
+			| HNIS_BUFF_WR_RDY | HNIS_BUFF_RD_RDY
+			| HNIS_TC_CMPL | HNIS_DMA ))){
+			printk("Unhandled status 0x%x\n", intstatus);
 	}
 	
 	spin_unlock(&host->irq_lock);
@@ -709,15 +735,17 @@ static int __devinit xlpmmc_probe(struct platform_device *pdev)
 	mmc->f_max =   16667000;  
 	spin_lock_init(&host->irq_lock);
 
-	/*Set max_seg_size in case of DMA*/
-	/*-------------------------------*/
-
 	mmc->max_blk_size = 512;
 	mmc->max_blk_count = 2048;
 
+	mmc->max_seg_size = XLPMMC_DESCRIPTOR_SIZE;
+	mmc->max_phys_segs = XLPMMC_DESCRIPTOR_COUNT;	
+	
+	/* Enable DMA mode. Defualt is PIO*/
+	host->flags |= HOST_F_DMA;
+
 	mmc->ocr_avail = XLPMMC_OCR; /* volt 2.70 ~ 3.60 */
 	
-	//mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_NEEDS_POLL;
 	mmc->caps = MMC_CAP_4_BIT_DATA;
 
 	host->status = HOST_S_IDLE;
@@ -740,7 +768,8 @@ static int __devinit xlpmmc_probe(struct platform_device *pdev)
 
 out6:
 	/*Disable the host if init fails*/
-	/*---------------*/
+	mmc_remove_host(host->mmc);
+	xlpmmc_set_power(host, 0);
 
 	free_irq(host->irq, host);
 out3:
diff --git a/drivers/mmc/host/xlpmmc.h b/drivers/mmc/host/xlpmmc.h
index 2871048..d159175 100644
--- a/drivers/mmc/host/xlpmmc.h
+++ b/drivers/mmc/host/xlpmmc.h
@@ -45,6 +45,7 @@
 #define DDIR_READ                       (0x1 << 4)
 #define MBS_SINGLE			(0x0 << 5)
 #define MBS_MTPLE			(0x1 << 5)
+#define DMA_EN				(0x1 << 0)
 
 /* Response types */
 #define RSP_TYPE_NONE   (RSP_TYPE_NORSP   | CCCE_NOCHECK | CICE_NOCHECK)
@@ -57,7 +58,8 @@
 #define RSP_TYPE_R6     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
 #define RSP_TYPE_R7     (RSP_TYPE_LGHT48  | CCCE_CHECK   | CICE_CHECK)
 
-
+/* Host buf size*/
+#define HOST_BUF_SZ_64				(1<<14)
 /*Command Support Registers*/	
 
 #define HC_SDMA_SA_OR_ARG2_LO 		0x0000 
@@ -113,6 +115,7 @@
 #define HC_NORMAL_INT_STS 		0x0030
 	#define HNIS_CMD_CMPL 				(1<<0) /* command completion intr. */
 	#define HNIS_TC_CMPL 				(1<<1) /* transaction completion intr. */
+	#define HNIS_DMA 				(1<<3) /* DMA interrupt */
 	#define HNIS_BUFF_RD_RDY			(1<<5) /* ready to read buffer intr. */
 	#define HNIS_BUFF_WR_RDY			(1<<4) /* write buffer ready  intr. */
 	#define HNIS_ERR 				(1<<15) /* An error Interrupt */
-- 
1.7.0.4

