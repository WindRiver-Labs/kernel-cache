From 07877d3f474264de7b8b1cd75a5c7568a9557d83 Mon Sep 17 00:00:00 2001
From: Rahul Jain <rajain@netlogicmicro.com>
Date: Thu, 14 Apr 2011 17:26:55 +0530
Subject: [PATCH 287/762] Support added for Linux Loader to be added as a module.

Based on Broadcom SDK 2.3.

Signed-off-by: Rahul Jain <rajain@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/phnx_loader.h |  210 ++++++++++++++++++++++++++
 arch/mips/kernel/setup.c                     |    1 +
 arch/mips/netlogic/xlp/setup.c               |   69 +++++++++-
 arch/mips/netlogic/xlp/smp.c                 |   23 +++-
 4 files changed, 300 insertions(+), 3 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/phnx_loader.h

diff --git a/arch/mips/include/asm/netlogic/phnx_loader.h b/arch/mips/include/asm/netlogic/phnx_loader.h
new file mode 100644
index 0000000..429884a
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/phnx_loader.h
@@ -0,0 +1,210 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+#ifndef __USER_RMI_PHNX_LOADER_H
+#define __USER_RMI_PHNX_LOADER_H
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define PHNX_LOADER_INFO_MAGIC 			0x600ddeed
+#define XLR_MAP_SLAVE_DEVICE 			0x1
+#define XLR_MAP_UNCACHED 			0x1
+#define XLR_MAP_CACHED 				0x2
+#define PHNX_APP_LOADER_CHRDEV_NAME 		"xlr_app_loader"
+#define MAX_NUM_LOADER_MEM_BLK 			4
+#define SHARED_MEM_ADDR            		(3 << 20)
+#define XLP_APP_LOADER_MAJOR       		(245)
+
+#define PSB_MEM_MAP_MAX 			32
+#define PSB_IO_MAP_MAX 				32
+#define MAX_FRAGMENTS 				32
+
+#define MAX_TLB_MAPPINGS 			16
+#define MAX_ARGS 				16
+#define MAX_ARGV_LEN 				16
+
+#define PHNX_LOADER_IOC_MAGIC 			'X'
+#define PHNX_LOADER_IOC_SHMEM_SIZE 		_IOR(PHNX_LOADER_IOC_MAGIC, 0, unsigned int)
+#define PHNX_LOADER_IOC_MMAP_SHMEM 		_IOR(PHNX_LOADER_IOC_MAGIC, 1, unsigned int)
+#define PHNX_LOADER_IOC_LIB_BKP 		_IOR(PHNX_LOADER_IOC_MAGIC, 2, unsigned int)
+#define PHNX_LOADER_IOC_MMAP_LOAD_ADDR  	_IOR(PHNX_LOADER_IOC_MAGIC, 3, unsigned int)
+#define PHNX_LOADER_IOC_START_IPI 		_IOR(PHNX_LOADER_IOC_MAGIC, 4, unsigned int)
+#define PHNX_LOADER_IOC_STOP_IPI  		_IOR(PHNX_LOADER_IOC_MAGIC, 5, unsigned int)
+#define PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 6, unsigned int)
+#define PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 7, unsigned int)
+#define PHNX_LOADER_IOC_FREE_PERSISTENT_MEM  	_IOR(PHNX_LOADER_IOC_MAGIC, 8, unsigned int)
+#define PHNX_LOADER_IOC_SHMEM_KSEG_ADDR 	_IOR(PHNX_LOADER_IOC_MAGIC, 10, unsigned int)
+#define PHNX_LOADER_IOC_LAUNCH_KSEG 		_IOR(PHNX_LOADER_IOC_MAGIC, 15, unsigned int)
+#define PHNX_LOADER_IOC_APP_SHMEM_SIZE 		_IOR(PHNX_LOADER_IOC_MAGIC, 25, unsigned int)
+#define PHNX_LOADER_IOC_APP_SHMEM_RESERVE 	_IOR(PHNX_LOADER_IOC_MAGIC, 35, unsigned int)
+#define PHNX_LOADER_IOC_MMAP_APP_SHMEM 		_IOR(PHNX_LOADER_IOC_MAGIC, 45, unsigned int)
+#define PHNX_LOADER_IOC_APP_SHMEM_PHYS 		_IOR(PHNX_LOADER_IOC_MAGIC, 55, unsigned int)
+#define PHNX_LOADER_STORE_ENV 			_IOR(PHNX_LOADER_IOC_MAGIC, 65, unsigned int)
+#define PHNX_LOADER_SEND_IPI 			_IOR(PHNX_LOADER_IOC_MAGIC, 75, unsigned int)
+#define PHNX_LOADER_IOC_STORE_APP_SHMEM_INFO 	_IOR(PHNX_LOADER_IOC_MAGIC, 85, unsigned int)
+#define PHNX_LOADER_IOC_GET_APP_SHMEM_INFO 	_IOR(PHNX_LOADER_IOC_MAGIC, 95, unsigned int)
+#define PHNX_LOADER_IOC_FDT_CPUMASK 		_IOWR(PHNX_LOADER_IOC_MAGIC, 105, unsigned int)
+
+enum { KUSEG_MODE, KSEG0_MODE };
+typedef enum {
+	STOP_THREAD=0xbeef,
+	START_THREAD,
+	RUN_FUNCTION, /* Used by wakeup and wakeup_os call */
+
+}loader_cmd;
+
+typedef enum {
+	THREAD_STOPPED=0x600d,
+	THREAD_RUNNING,
+	THREAD_SCHEDULED,
+}thread_status;
+
+struct cpu_tlb_mapping {
+	int page_size;
+	int asid;
+	int coherency;
+	int attr;
+	unsigned long virt;
+	uint64_t phys;
+};
+
+struct cpu_wakeup_info {
+	int            master_cpu;
+	int            map_count;
+	int            valid;
+	unsigned long  func;
+	unsigned long  args;
+	int            argc;
+	uint32_t       buddy_mask;
+	uint32_t       cpu_mask;
+	char          *argv[32]; /* RMIOS LIB NEEDS this to be 32 */
+	char           buf[256];/* must be > MAX_ARGS * MAX_ARGV_LEN + some buffer */
+	struct cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
+};
+
+/* SHARED memory structure b/w loader app, linux and RMIOS apps */
+typedef struct phnx_loader_shared_struct {
+	unsigned long park_entry;
+	loader_cmd    cmd;
+	thread_status thr_status;
+	unsigned long entry; /* Entry point address */
+	int 	      run_mode;
+	struct cpu_wakeup_info run_info;
+	uint32_t 	app_sh_mem_sz; /* Size of the shared memory */
+	unsigned long	sp;/* Used for reentry */
+	unsigned long	gp;
+}phnx_loader_shared_struct_t;
+
+
+/* This structure is passed to all applications launched from the linux
+   loader through OS 7 scratch register
+   */
+typedef struct phnx_loader_info {
+	uint32_t magic;
+	/* phnx_loader_shared_struct_t for CPU 0 will start here */
+	unsigned long sh_mem_start;
+	/* Size of the shared memory b/w linux apps and rmios apps  */
+	uint32_t app_sh_mem_size;
+	uint8_t printk_lock[16]; /* used for printk */
+}phnx_loader_info_t;
+
+struct psb_mem_map {
+	int nr_map;
+	struct psb_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;      /* type of memory segment */
+	} map[PSB_MEM_MAP_MAX];
+};
+
+struct psb_io_map {
+	int nr_map;
+	struct psb_io_map_entry {
+		uint64_t addr;  /* start of IO segment */
+		uint64_t size;  /* size of IO segment */
+		long type;      /* type of IO segment */
+	} map[PSB_IO_MAP_MAX];
+};
+
+struct r_exception_region {
+	    unsigned int data[1024];
+};
+
+struct xlr_rmios_pt_regs {
+	unsigned long long pad0[6];
+
+	unsigned long long regs[32];
+
+	unsigned long long cp0_status;
+	unsigned long long hi;
+	unsigned long long lo;
+
+	/*
+	 * saved cp0 registers
+	 */
+	unsigned long long cp0_badvaddr;
+	unsigned long long cp0_cause;
+	unsigned long long cp0_epc;
+};
+
+struct domain_info
+{
+	uint32_t domain;
+	uint32_t cpumask;	////cpu mask -- currently 32bit.
+	uint32_t mastercpu;	///master cpu id
+	uint32_t mode; //// 0-smp, 1-amp
+	uint64_t app_addr;	//Hyperapp app load address
+	uint64_t fdt_blob;	//FDT blob address.
+};
+
+struct wakeup_info
+{
+       int vcpu;
+       unsigned long long func;
+       unsigned long long data;
+};
+
+struct xlr_load_addr
+{
+       uint64_t phys;
+       uint64_t size;
+       uint32_t flag;
+};
+
+struct xlr_lib_shared_mem
+{
+	uint64_t entries;
+	uint64_t tot_size;
+	uint64_t addr[MAX_FRAGMENTS];
+	uint64_t size[MAX_FRAGMENTS];
+};
+
+struct loader_mem_info{
+	uint64_t size;
+	uint64_t start_addr;
+};
+
+#endif
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 489ebe4..6ee84fe 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -644,6 +644,7 @@ void __init setup_arch(char **cmdline_p)
 
 unsigned long kernelsp[NR_CPUS];
 unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
+EXPORT_SYMBOL(fw_arg0);
 
 #ifdef CONFIG_DEBUG_FS
 struct dentry *mips_debugfs_dir;
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 6a6d86f..9f62e96 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -61,7 +61,7 @@
 #include <asm/netlogic/cpumask.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
-
+#include <asm/netlogic/phnx_loader.h>
 #include "../boot/ops.h"
 
 /* Certain macros for this file
@@ -97,6 +97,8 @@ extern void xlp_uart_out(struct uart_port *p, int offset, int value);
 extern void (*board_nmi_handler_setup)(void );
 extern unsigned long _text[];
 extern cpumask_t fdt_cpumask;
+extern cpumask_t fdt_loadermask;
+int xlp_loader_support = 0;
 
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
@@ -401,6 +403,7 @@ static void nlm_early_serial_setup(int uart_id) {}
 #endif /* CONFIG_SERIAL_8250 */
 
 extern struct plat_smp_ops nlm_smp_ops;
+struct loader_mem_info loader_mem_map[MAX_NUM_LOADER_MEM_BLK];
 
 #define MAX_CPUMASK_CELLS 4
 #define fdt32_to_cpu(x) be32_to_cpu(x)
@@ -422,11 +425,13 @@ static int fdt_process(void)
 	int  domain=0;
 	char domstr[32] = "";
 	uint32_t  i, na, ns, regs[16], entries, cpu_cells;
+ 	int index = 0;
 	uint32_t node_vc_mask[4] = {0};
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
 	unsigned char buf[30];	
 	int j, id=0, k, tmp;
 	uint32_t onlinemask[MAX_CPUMASK_CELLS];
+ 	uint32_t linux_loader_mask[MAX_CPUMASK_CELLS] = {0};
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -435,6 +440,7 @@ static int fdt_process(void)
 	void *node;
 
 	cpumask_clear(&fdt_cpumask);
+	cpumask_clear(&fdt_loadermask);
 
 	if(!blob)
 		return -1;
@@ -557,6 +563,67 @@ static int fdt_process(void)
 		printk("fdt_cpumask: %s\n", buf);
 	}
 
+	sprintf(domstr, "/doms/dom@%d/linuxloader", domain);
+	node = finddevice(domstr);
+	if (node) {
+		uint32_t loadermask_buf[MAX_CPUMASK_CELLS];
+		char buf[CPUMASK_BUF];
+
+		xlp_loader_support = 1;
+		/* Initialize buffers */
+		for (i = 0; i < MAX_CPUMASK_CELLS; i++)
+			loadermask_buf[i] = 0;
+
+		/* Parse cpumask from FDT and handle endianness */
+		if((getprop(node, "loadermask", &loadermask_buf[0], sizeof(uint32_t) * cpu_cells) < 0)){
+			xlp_loader_support = 0;
+			goto noloadermask;
+		}
+
+		for (i = 0; i < cpu_cells; i++) {
+			loadermask_buf[i] = fdt32_to_cpu(loadermask_buf[i]);
+
+			printk("FDT: cpu_cells: %d loadermask_buf[%d]: %#08x\n",
+			       cpu_cells, i, loadermask_buf[i]);
+		}
+
+		/* Store cpumask in predefined order */
+		for (i = 0; i < cpu_cells; i++){
+			linux_loader_mask[i] = loadermask_buf[cpu_cells - 1 - i];
+			printk("linux_loader_mask[%d] = %#x\n",i,linux_loader_mask[i]);
+		}
+
+		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
+			int j = 0;
+
+			for (j = 0; j < 32; j++) {
+				if ((linux_loader_mask[i] & (1 << j)) == 0) 
+					continue;
+				cpumask_set_cpu((i * 32 + j), &fdt_loadermask);
+			}
+		}
+		
+		entries = (getprop(node, "memory", regs, sizeof(regs))) / sizeof(regs[0]);
+		if (!entries || (entries % (na+ns))){
+			printk("Invalid Memory Map Specified!\n");
+			xlp_loader_support = 0;
+			goto noloadermask;
+		}
+		for (i=0,index=0; i<entries; i+=4, index++) {
+				unsigned long long lsb_addr, msb_addr, lsb_size, msb_size;
+				msb_addr = fdt32_to_cpu(regs[i]);
+				lsb_addr = fdt32_to_cpu(regs[i + 1]);
+				msb_size = fdt32_to_cpu(regs[i + 2]);
+				lsb_size = fdt32_to_cpu(regs[i + 3]);
+				loader_mem_map[index].start_addr = lsb_addr | (msb_addr << 32);
+				loader_mem_map[index].size  = lsb_size | (msb_size << 32);
+				printk("LoaderMemory [%#llx] @ [%#llx]\n",loader_mem_map[index].size, loader_mem_map[index].start_addr);
+		}
+noloadermask:
+		cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_loadermask);
+		printk("fdt_loadermask: %s\n", buf);
+	}
+
 	node = finddevice("/doms/dom@0/fmn");
 	if (node) {
 		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 32f703b..d9d0083 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -24,6 +24,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 *****************************#NETL_2#********************************/
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
@@ -31,6 +32,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/mipsregs.h>
 #include <asm/mmu_context.h>
 #include <asm/atomic.h>
+#include <asm/cacheops.h>
 
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/msgring.h>
@@ -49,7 +51,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "cpu_control_macros.h"
 
 struct smp_boot_info smp_boot;
+EXPORT_SYMBOL(smp_boot);
 cpumask_t fdt_cpumask;
+cpumask_t fdt_loadermask;
 
 void nlm_enable_vc_intr(void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
@@ -229,18 +233,24 @@ int wakeup_secondary_cpus(void)
 
 	for (node = 0; node < 4; node++) {
 		cpumask_t tmpmask, nodemask;
+		cpumask_t tmploader_mask, loadernode_mask;
 		unsigned int onlinemask;
 
 		cpumask_clear(&tmpmask);
 		cpumask_clear(&nodemask);
+		cpumask_clear(&tmploader_mask);
+		cpumask_clear(&loadernode_mask);
 
 		cpumask_shift_right(&nodemask, &fdt_cpumask, 32 * node);
 		cpumask_and(&tmpmask, &nodemask, &mask32);
 
-		if (cpumask_empty(&tmpmask))
+		cpumask_shift_right(&loadernode_mask, &fdt_loadermask, 32 * node);
+		cpumask_and(&tmploader_mask, &loadernode_mask, &mask32);
+
+		if (cpumask_empty(&tmpmask) && cpumask_empty(&tmploader_mask))
 			continue;
 
-		onlinemask = cpumask_to_uint32(&tmpmask);
+		onlinemask = cpumask_to_uint32(&tmpmask) | cpumask_to_uint32(&tmploader_mask);
 		hw_enable_cpus(node, onlinemask);
 
 		printk("Enabled cpus (0x%08x) on node@%d\n", onlinemask, node);
@@ -276,6 +286,7 @@ void prom_boot_cpus_secondary(void *args)
 	/* Announce that this cpu is available */
 	cpumask_test_and_set_cpu(cpu, &smp_boot.online_map);
 
+
 	/* Wait for master to signal */
 	for (;;) {
 		if (smp_boot.boot_info[cpu].ready) break;
@@ -289,6 +300,14 @@ void prom_boot_cpus_secondary(void *args)
         setup_mapped_kernel_tlbs(TRUE, FALSE);
         setup_mapped_kernel_tlbs(FALSE, FALSE);
 
+	if (cpumask_test_cpu(cpu, &fdt_loadermask)) {
+		/* TLBMISS_HANDLER_SETUP */
+		write_c0_context(cpu << 26);
+		back_to_back_c0_hazard();
+		pgd_current[cpu] = (unsigned long)(swapper_pg_dir);
+		write_c0_pagemask(PM_DEFAULT_MASK);
+	}
+
 	/* Entry into the kernel (smp_bootstrap) */
 	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp,
 		     smp_boot.boot_info[cpu].gp);
-- 
1.7.0.4

