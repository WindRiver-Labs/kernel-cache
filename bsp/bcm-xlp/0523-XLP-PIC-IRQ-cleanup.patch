From e312e9117ee2d0000a6254bdc316796c29e60b09 Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Thu, 19 Jan 2012 15:24:31 -0800
Subject: [PATCH 523/762] XLP: PIC/IRQ cleanup

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp_hal_pic.h |  153 +++++++++---
 arch/mips/include/asm/netlogic/xlp_irq.h     |  329 +++++++-------------------
 arch/mips/include/asm/smp.h                  |    6 +-
 arch/mips/kernel/nlm_fs_handler.S            |    2 +-
 arch/mips/netlogic/xlp/irq.c                 |   10 +
 arch/mips/netlogic/xlp/on_chip.c             |  192 +--------------
 arch/mips/netlogic/xlp/platform.c            |    5 +-
 arch/mips/netlogic/xlp/smp.c                 |   28 ++-
 arch/mips/netlogic/xlp/time.c                |   25 +--
 arch/mips/netlogic/xlp/xlp_hal_pic.c         |    1 +
 10 files changed, 263 insertions(+), 488 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp_hal_pic.h b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
index 627f4d5..38c9b76 100644
--- a/arch/mips/include/asm/netlogic/xlp_hal_pic.h
+++ b/arch/mips/include/asm/netlogic/xlp_hal_pic.h
@@ -29,7 +29,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _NLM_HAL_PIC_H
 #define _NLM_HAL_PIC_H
 
-#include "nlm_hal.h"
 /*
  *     Register Offsets
  */
@@ -53,43 +52,108 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define PIC_WD0_HEARBEATCMD  0x10
 #define PIC_WD0_HEARBEAT_0   0x11
 #define PIC_WD0_HEARBEAT_1   0x12
-#define PIC_SYS_TIMER_0_COUNTER   0x22
 
-#define PIC_INT_THR_ENABLE_0_N01   0x2a
-#define PIC_INT_THR_ENABLE_0_N23   0x2b
-#define PIC_INT_THR_ENABLE_N01(id) (PIC_INT_THR_ENABLE_0_N12 + ((id) * 2))
-#define PIC_INT_THR_ENABLE_N23(id) (PIC_INT_THR_ENABLE_0_N12 + ((id) * 2))
+#define PIC_SYSTIMER_0_MAXVALUE   0x1a
+#define PIC_SYSTIMER_MAXVALUE(id) (PIC_SYSTIMER_0_MAXVALUE + (id))
+
+#define PIC_SYSTIMER_0_COUNT   0x22
+#define PIC_SYSTIMER_COUNT(id) (PIC_SYSTIMER_0_COUNT + (id))
+
+#define PIC_NUM_SYSTIMER 8
+
+#define PIC_ITE_0_N01   0x2a
+#define PIC_ITE_0_N23   0x2b
+#define PIC_ITE_N01(id) (PIC_ITE_0_N01 + ((id) * 2))
+#define PIC_ITE_N23(id) (PIC_ITE_0_N23 + ((id) * 2))
+
+#define PIC_NUM_ITE 8
+
+#define PIC_IRT_0            0x3a
+#define PIC_IRT(id)          (PIC_IRT_0 + (id))
+
+/* IRT Map */
+#define XLP_PIC_IRT_WD_0		0
+#define XLP_PIC_IRT_WD_1		1
+#define XLP_PIC_IRT_WD(x)		((x) + XLP_PIC_IRT_WD_0)
+#define XLP_PIC_IRT_WDNMI_0		2
+#define XLP_PIC_IRT_WDNMI_1		3
+#define XLP_PIC_IRT_WDNMI(x)		((x) + XLP_PIC_IRT_WDNMI_0)
+#define XLP_PIC_IRT_SYSTIMER_0		4
+#define XLP_PIC_IRT_SYSTIMER_7		11
+#define XLP_PIC_IRT_SYSTIMER(x)		((x) + XLP_PIC_IRT_SYSTIMER_0)
+#define XLP_PIC_IRT_FMN_POPQ_0		12
+#define XLP_PIC_IRT_FMN_POPQ_31		43
+#define XLP_PIC_IRT_FMN_POPQ(x)		((x) + XLP_PIC_IRT_FMN_POPQ_0)
+#define XLP_PIC_IRT_FMN_FATAL		44
+#define XLP_PIC_IRT_FMN_NONFATAL	45
+#define XLP_PIC_IRT_PCIE_MSIX_0		46
+#define XLP_PIC_IRT_PCIE_MSIX_31	77
+#define XLP_PIC_IRT_PCIE_MSIX(x)	((x) + XLP_PIC_IRT_PCIE_MSIX_0)
+#define XLP_PIC_IRT_PCIE_0		78
+#define XLP_PIC_IRT_PCIE_3		81
+#define XLP_PIC_IRT_PCIE(x)		((x) + XLP_PIC_IRT_PCIE_0)
+#define XLP_PIC_IRT_NET_IF_0		82
+#define XLP_PIC_IRT_NET_IF_18		100
+#define XLP_PIC_IRT_NET_IF(x)		((x) + XLP_PIC_IRT_NET_IF_0)
+#define XLP_PIC_IRT_NET_COMMON_0	102
+#define XLP_PIC_IRT_NET_COMMON_1	103
+#define XLP_PIC_IRT_NET_COMMON(x)	((x) + XLP_PIC_IRT_NET_COMMON_0)
+#define XLP_PIC_IRT_POE			114
+#define XLP_PIC_IRT_USB_0		115
+#define XLP_PIC_IRT_USB_5		120
+#define XLP_PIC_IRT_USB(x)		((x) + XLP_PIC_IRT_USB_0)
+#define XLP_PIC_IRT_DTR			121
+#define XLP_PIC_IRT_SAE			122
+#define XLP_PIC_IRT_RSA			123
+#define XLP_PIC_IRT_CDE_0		124
+#define XLP_PIC_IRT_CDE_3		127
+#define XLP_PIC_IRT_CDE(x)		((x) + XLP_PIC_IRT_CDE_0)
+#define XLP_PIC_IRT_ICI_0		129
+#define XLP_PIC_IRT_ICI_2		131
+#define XLP_PIC_IRT_ICI(x)		((x) + XLP_PIC_IRT_ICI_0)
+#define XLP_PIC_IRT_KBP			132
+#define XLP_PIC_IRT_UART_0		133
+#define XLP_PIC_IRT_UART_1		134
+#define XLP_PIC_IRT_UART(x)		((x) + XLP_PIC_IRT_UART_0)
+#define XLP_PIC_IRT_I2C_0		135
+#define XLP_PIC_IRT_I2C_1		136
+#define XLP_PIC_IRT_I2C(x)		((x) + XLP_PIC_IRT_I2C_0)
+#define XLP_PIC_IRT_SYS_0		137
+#define XLP_PIC_IRT_SYS_1		138
+#define XLP_PIC_IRT_SYS(x)		((x) + XLP_PIC_IRT_SYS_0)
+#define XLP_PIC_IRT_JTAG		139
+#define XLP_PIC_IRT_PIC			140
+#define XLP_PIC_IRT_GPIO_0		146
+#define XLP_PIC_IRT_GPIO_3		149
+#define XLP_PIC_IRT_GPIO(x)		((x) + XLP_PIC_IRT_GPIO_0)
+#define XLP_PIC_IRT_NOR			150
+#define XLP_PIC_IRT_NAND		151
+#define XLP_PIC_IRT_SPI			152
+#define XLP_PIC_IRT_MMC			153
+#define XLP_PIC_IRT_NBU			154
+#define XLP_PIC_IRT_TCU			155
+#define XLP_PIC_IRT_GCU			156
+#define XLP_PIC_IRT_DMC_0		157
+#define XLP_PIC_IRT_DMC_1		158
+#define XLP_PIC_IRT_DMC(x)		((x) + XLP_PIC_IRT_DMC_0)
+#define XLP_PIC_IRT_TCB			159
+#define XLP_PIC_NUM_IRTS		160
+
 
-#define PIC_IRT_0   0x3a
-#define PIC_IRT(id) (PIC_IRT_0 + (id))
-#define PIC_CLOCK_TIMER     7
 #define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
 #define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
 #define XLP_IO_PIC_OFFSET        C_XLP_IO_PIC_OFFSET
 
 #ifndef __ASSEMBLY__
-#define __nlm_hal_set_irq_to_cpu	__nlm_hal_set_irt_to_cpu
 void __nlm_hal_set_irt_to_cpu(int, int);
 void __nlm_hal_release_irq(int);
 int __nlm_hal_request_irq(int, int);
-#define CPUIDBITS01(X) ((X) & 0x3)
-#define CPUIDBIT2(X) ((X >> 2) & 0x1)
 
-#if 0
-static inline int nlm_hal_irt_to_irq(int irt_num)
-{
-	return __nlm_hal_find_irt_from_irq(irt_num);
-}
+#define CPUIDBITS01(X) ((X) & 0x3)
+#define CPUIDBIT2(X)   (((X) >> 2) & 0x1)
 
-static inline int nlm_hal_irq_to_irt(int irq_num)
-{
-	int irt = __nlm_hal_find_irt_from_irq(irq_num); // same function
-	return irt;
-}
-#endif
-#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) 0 // XLP interrupts are level triggered
 #define NODE_OFFSET(node) ((node) << 18)
-#define CPU_TO_NODE(cpu) ((cpu) >> 5)
+#define CPU_TO_NODE(cpu)  ((cpu) >> 5)
 
 static __inline__ int nlm_hal_cpu_id(void)
 {
@@ -112,7 +176,7 @@ typedef volatile unsigned long long pic_reg_t;
 
 static __inline__ pic_reg_t* nlm_hal_pic_offset(void)
 {
-	uint32_t cpu = nlm_hal_cpu_id();
+	unsigned int cpu = nlm_hal_cpu_id();
 
 	return ((pic_reg_t *) (XLP_IO_PIC_OFFSET + NODE_OFFSET(CPU_TO_NODE(cpu))));
 }
@@ -230,14 +294,6 @@ static __inline__ void nlm_hal_pic_write_control(unsigned long long control)
 	nlm_hal_write_pic_reg(mmio, PIC_CTRL, control);
 }
 
-static __inline__ void nlm_hal_pic_update_control(unsigned long long control)
-{
-	pic_reg_t *mmio = nlm_hal_pic_offset();
-
-	nlm_hal_write_pic_reg(mmio, PIC_CTRL,
-			(control | nlm_hal_read_pic_reg(mmio, PIC_CTRL)));
-}
-
 static __inline__ void nlm_hal_ack_pic(int irt_num)
 {
 	pic_reg_t *mmio = nlm_hal_pic_offset();
@@ -290,18 +346,43 @@ static __inline__ void nlm_hal_pic_write_irt_direct(int irt_num, int en, int nmi
 	/* Does not support multi node support yet */
 }
 
+static __inline__ void nlm_hal_pic_enable_timer(int timer)
+{
+	pic_reg_t control;
+	control = nlm_hal_pic_read_control();
+	control |= 1 << (10 + timer);
+	nlm_hal_pic_write_control(control);
+}
+
+static __inline__ void nlm_hal_pic_disable_timer(int timer)
+{
+	pic_reg_t control;
+	control = nlm_hal_pic_read_control();
+	control &= ~(1 << (10 + timer));
+	nlm_hal_pic_write_control(control);
+}
+
+#define PIC_SYSTIMER_MAXVAL ((unsigned long long)-1)
+
+static __inline__ void nlm_hal_pic_init_timer(int timer, pic_reg_t value)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_SYSTIMER_MAXVALUE(timer), value);
+}
+
 static __inline__ unsigned long long nlm_hal_pic_read_timer(int timer)
 {
 	pic_reg_t *mmio = nlm_hal_pic_offset();
 
-	return nlm_hal_read_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer));
+	return nlm_hal_read_pic_reg(mmio, PIC_SYSTIMER_COUNT(timer));
 }
 
 static __inline__ void nlm_hal_pic_write_timer(int timer, pic_reg_t value)
 {
 	pic_reg_t *mmio = nlm_hal_pic_offset();
 
-	nlm_hal_write_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer), value);
+	nlm_hal_write_pic_reg(mmio, PIC_SYSTIMER_COUNT(timer), value);
 }
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 1a17003..796f5e3 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -1,3 +1,6 @@
+#ifndef CONFIG_NLM_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
 /***********************************************************************
 Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
 reserved.
@@ -26,267 +29,95 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _ASM_NLM_XLP_IRQ_H
 #define _ASM_NLM_XLP_IRQ_H
 
-/* Defines for the IRQ numbers */
-/* We define NR_IRQs to be 254, but IRT entries are 160 in size
- * Effectively, we cannot use anything more than 159 */
-#define NR_IRQS			384
-/* Maximum IRQ vector numbers supported by MIPS */
+/* Maximum IRQ vectors */
 #define XLP_EIRR_SIZE		64
-#define XLP_IRT_NUM	160
-#define XLP_IRQ_MAX	168	/* 0-7 are reserved + 160 IRT entries */
-
-/* The following interrupt assignments (0-7) are special.
- * I need to find out what governs these assignments
- * XXX
- */
-#define fdebug(fmt,arg...)\
-	printk(KERN_DEBUG "%s:%d " fmt, __FILE__, __LINE__, ##arg)
 
-#define XLP_IRQ_DUMMY_UART           2
+#define XLP_IRQ_IPI_SMP_KGDB         2
 #define XLP_IRQ_IPI_SMP_FUNCTION     3
 #define XLP_IRQ_IPI_SMP_RESCHEDULE   4
-// #define XLP_IRQ_REMOTE_DEBUG         5
 #define XLP_IRQ_MSGRING              5
-#define XLP_IRQ_OPROFILE             6
+#define XLP_IRQ_PERFCTR              6
 #define XLP_IRQ_TIMER                7
-#define XLP_IRQ_RESERVED_MAX		8
-#define XLP_PIC_IRQ_BASE		XLP_IRQ_RESERVED_MAX
+#define XLP_IRQ_RESERVED_MAX         8
+
+#define XLP_PIC_IRQ_BASE             XLP_IRQ_RESERVED_MAX
 
 #define xlp_pic_irt_to_irq(irt) ((irt) + XLP_PIC_IRQ_BASE)
 #define xlp_pic_irq_to_irt(irq) ((irq) - XLP_PIC_IRQ_BASE)
 
-#define XLP_IRQ_IPI_SMP_KGDB	     50
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-#define XLP_IRQ_IPI_NETRX		49
-#define SMP_NETRX_IPI			32
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
-/* if you want some common #defines, please do it here */
-#define NLM_IRQ_DUMMY_UART		XLP_IRQ_DUMMY_UART
-#define NLM_IRQ_IPI_SMP_FUNCTION	XLP_IRQ_IPI_SMP_FUNCTION
-#define NLM_IRQ_IPI_SMP_RESCHEDULE	XLP_IRQ_IPI_SMP_RESCHEDULE
-#define NLM_IRQ_REMOTE_DEBUG		XLP_IRQ_REMOTE_DEBUG
-#define NLM_IRQ_MSGRING			XLP_IRQ_MSGRING
-#define NLM_IRQ_TIMER			XLP_IRQ_TIMER
-#define NLM_IRQ_IPI_SMP_KGDB		XLP_IRQ_IPI_SMP_KGDB
-
-/* These are flags required for SMP
- * Not XLP specifc -- possibly mips specific.
- * Need to move out XXX
- */
-#define SMP_CALL_KGDB_HOOK	8
-#define SMP_OPROFILE_IPI        16
-
-#define TIMER_CYCLES_MAXVAL        0xffffffffffffffffULL
-
-/*
- *    IRT Map
- */
-
-#define arch_setup_msi_irqs	arch_setup_msi_irqs /* defines arch. specific msi setup function */
-#define xlp_irq_to_irt(x)	((x) - XLP_IRQ_RESERVED_MAX)
-#define xlp_irt_to_irq(x)	((x) + XLP_IRQ_RESERVED_MAX)
-#define XLP_PIC_NUM_IRTS	160
-
-#define XLP_WD_BASE			(0 + XLP_IRQ_RESERVED_MAX)
-#define XLP_WD_IRQ_IRQ(x) (XLP_WD_BASE + (x))
-
-#define XLP_WD_NMI_IRT_OFFSET		(2 + XLP_IRQ_RESERVED_MAX)
-#define XLP_WD_NMI_IRQ(x) (XLP_WD_NMI_IRT_OFFSET + (x))
-
-#define XLP_TIMER_IRT_OFFSET		(4 + XLP_IRQ_RESERVED_MAX)
-#define XLP_TIMER_IRQ(x)	(XLP_TIMER_IRT_OFFSET + (x))
-
-#define XLP_MSGQ_IRT_OFFSET			(12 + XLP_IRQ_RESERVED_MAX)
-#define XLP_MSGQ_IRQ(x)	(XLP_MSGQ_IRT_OFFSET + (x))
-
-#define XLP_MSG_IRT_OFFSET			(44 + XLP_IRQ_RESERVED_MAX)
-#define XLP_MSG_IRQ(x)	(XLP_MSG_IRT_OFFSET + (x))
-
-#define XLP_PCIE_MSIX_IRT_OFFSET		(46 + XLP_IRQ_RESERVED_MAX)
-#define XLP_PCIE_MSIX_IRQ(x)	(XLP_PCIE_MSIX_IRT_OFFSET + (x))
-
-#define XLP_PCIE_LINK_IRT_OFFSET		(78 + XLP_IRQ_RESERVED_MAX)
-#define XLP_PCIE_LINK_IRQ(x)	(XLP_PCIE_LINK_IRT_OFFSET + (x))
-
-#define XLP_NAE_IRT_OFFSET			(82 + XLP_IRQ_RESERVED_MAX)
-#define XLP_XLP_NAE_IRQ(x)	(XLP_XLP_NAE_IRT_OFFSET + (x))
-
-#define XLP_POE_IRT_OFFSET			(114 + XLP_IRQ_RESERVED_MAX)
-#define XLP_POE_IRQ(x)	(XLP_POE_IRT_OFFSET + (x))
-
-#define XLP_USB_IRT_OFFSET			(115 + XLP_IRQ_RESERVED_MAX)
-#define XLP_USB_IRQ(x)	(XLP_USB_IRT_OFFSET + (x))
-
-#define XLP_DTR_IRT_OFFSET			(121 + XLP_IRQ_RESERVED_MAX)
-#define XLP_DTR_IRQ(x)	(XLP_DTR_IRT_OFFSET + (x))
-
-#define XLP_SAE_IRT_OFFSET			(122 + XLP_IRQ_RESERVED_MAX)
-#define XLP_SAE_IRQ(x)	(XLP_SAE_IRT_OFFSET + (x))
-
-#define XLP_RSA_IRT_OFFSET			(123 + XLP_IRQ_RESERVED_MAX)
-#define XLP_RSA_IRQ(x)	(XLP_RSA_IRT_OFFSET + (x))
-
-#define XLP_COMP_IRT_OFFSET			(124 + XLP_IRQ_RESERVED_MAX)
-#define XLP_COMP_IRQ(x)	(XLP_COMP_IRT_OFFSET + (x))
-
-#define XLP_FLASH_IRT_OFFSET		(128 + XLP_IRQ_RESERVED_MAX)
-#define XLP_FLASH_IRQ(x)	(XLP_FLASH_IRT_OFFSET + (x))
-
-#define	XLP_ICI_IRT_OFFSET			(131 + XLP_IRQ_RESERVED_MAX)
-#define XLP_ICI_IRQ(x)	(XLP_ICI_IRT_OFFSET + (x))
-
-#define	XLP_KBP_IRT_OFFSET			(132 + XLP_IRQ_RESERVED_MAX)
-#define XLP_KBP_IRQ(x)	(XLP_KBP_IRT_OFFSET + (x))
-
-#define XLP_UART_IRT_OFFSET			(133 + XLP_IRQ_RESERVED_MAX)
-#define XLP_UART_IRQ(x)	(XLP_UART_IRT_OFFSET + (x))
-
-#define XLP_PIC_IRT_UART_0		133
-#define XLP_PIC_IRT_UART_1		134
-#define XLP_PIC_IRT_UART(x)		((x) + XLP_PIC_IRT_UART_0)
-
+#define XLP_IRQ(irt) xlp_pic_irt_to_irq(irt)
+
+#include <asm/netlogic/xlp_hal_pic.h>
+
+#define NR_IRQS		(XLP_IRQ_RESERVED_MAX + XLP_PIC_NUM_IRTS)
+
+#if 0
+#define XLP_PIC_IRQ_WD_0		(XLP_PIC_IRT_WD_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_WD_1		(XLP_PIC_IRT_WD_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_WD(x)		((x) + XLP_PIC_IRQ_WD_0)
+#define XLP_PIC_IRQ_WDNMI_0		(XLP_PIC_IRT_WDNMI_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_WDNMI_1		(XLP_PIC_IRT_WDNMI_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_WDNMI(x)		((x) + XLP_PIC_IRQ_WDNMI_0)
+#define XLP_PIC_IRQ_SYSTIMER_0		(XLP_PIC_IRT_SYSTIMER_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SYSTIMER_7		(XLP_PIC_IRT_SYSTIMER_7 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SYSTIMER(x)		((x) + XLP_PIC_IRQ_SYSTIMER_0)
+#define XLP_PIC_IRQ_FMN_POPQ_0		(XLP_PIC_IRT_FMN_POPQ_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_FMN_POPQ_31		(XLP_PIC_IRT_FMN_POPQ_31 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_FMN_POPQ(x)		((x) + XLP_PIC_IRQ_FMN_POPQ_0)
+#define XLP_PIC_IRQ_FMN_FATAL		(XLP_PIC_IRT_FMN_NONFATAL + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_FMN_NONFATAL	(XLP_PIC_IRT_FMN_FATAL + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PCIE_MSIX_0		(XLP_PIC_IRT_PCIE_MSIX_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PCIE_MSIX_31	(XLP_PIC_IRT_PCIE_MSIX_31 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PCIE_MSIX(x)	((x) + XLP_PIC_IRQ_PCIE_MSIX_0)
+#define XLP_PIC_IRQ_PCIE_0		(XLP_PIC_IRT_PCIE_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PCIE_3		(XLP_PIC_IRT_PCIE_3 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PCIE(x)		((x) + XLP_PIC_IRQ_PCIE_0)
+#define XLP_PIC_IRQ_NET_IF_0		(XLP_PIC_IRT_NET_IF_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NET_IF_18		(XLP_PIC_IRT_NET_IF_18 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NET_IF(x)		((x) + XLP_PIC_IRQ_NET_IF_0)
+#define XLP_PIC_IRQ_NET_COMMON_0	(XLP_PIC_IRT_NET_COMMON_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NET_COMMON_1	(XLP_PIC_IRT_NET_COMMON_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NET_COMMON(x)	((x) + XLP_PIC_IRQ_NET_COMMON_0)
+#define XLP_PIC_IRQ_POE			(XLP_PIC_IRT_POE + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_USB_0		(XLP_PIC_IRT_USB_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_USB_5		(XLP_PIC_IRT_USB_5 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_USB(x)		((x) + XLP_PIC_IRQ_USB_0)
+#define XLP_PIC_IRQ_DTR			(XLP_PIC_IRT_DTR + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SAE			(XLP_PIC_IRT_SAE + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_RSA			(XLP_PIC_IRT_RSA + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_CDE_0		(XLP_PIC_IRT_CDE_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_CDE_3		(XLP_PIC_IRT_CDE_3 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_CDE(x)		((x) + XLP_PIC_IRQ_CDE_0)
+#define XLP_PIC_IRQ_ICI_0		(XLP_PIC_IRT_ICI_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_ICI_2		(XLP_PIC_IRT_ICI_2 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_ICI(x)		((x) + XLP_PIC_IRQ_ICI_0)
+#define XLP_PIC_IRQ_KBP			(XLP_PIC_IRT_KBP + XLP_PIC_IRQ_BASE)
 #define XLP_PIC_IRQ_UART_0		(XLP_PIC_IRT_UART_0 + XLP_PIC_IRQ_BASE)
 #define XLP_PIC_IRQ_UART_1		(XLP_PIC_IRT_UART_1 + XLP_PIC_IRQ_BASE)
-#define XLP_PIC_IRQ_UART(x)		(XLP_PIC_IRT_UART(x) + XLP_PIC_IRQ_BASE)
-
-#define XLP_I2C_IRT_OFFSET			(135 + XLP_IRQ_RESERVED_MAX)
-#define XLP_I2C_IRQ(x)	(XLP_I2C_IRT_OFFSET + (x))
-
-#define XLP_SM_IRT_OFFSET			(137 + XLP_IRQ_RESERVED_MAX)
-#define XLP_SM_IRQ(x)	(XLP_SM_IRT_OFFSET + (x))
-
-#define	XLP_JTAG_IRT_OFFSET			(139 + XLP_IRQ_RESERVED_MAX)
-#define XLP_JTAG_IRQ(x)	(XLP_JTAG_IRT_OFFSET + (x))
-
-#define XLP_PIC_IRT_OFFSET			(140 + XLP_IRQ_RESERVED_MAX)
-#define XLP_PIC_IRQ(x)	(XLP_PIC_IRT_OFFSET + (x))
-
-#define XLP_MIOCB_IRT_OFFSET		(141 + XLP_IRQ_RESERVED_MAX)
-#define XLP_MIOCB_IRQ(x)	(XLP_MIOCB_IRT_OFFSET + (x))
-
-#define XLP_TCU_IRT_OFFSET			(142 + XLP_IRQ_RESERVED_MAX)
-#define XLP_TCU_IRQ(x)	(XLP_TCU_IRT_OFFSET + (x))
-
-#define XLP_GCU_IRT_OFFSET			(143 + XLP_IRQ_RESERVED_MAX)
-#define XLP_GCU_IRQ(x)	(XLP_GCU_IRT_OFFSET + (x))
-
-#define XLP_DRAM_IRT_OFFSET			(144 + XLP_IRQ_RESERVED_MAX)
-#define XLP_DRAM_IRQ(x)	(XLP_DRAM_IRT_OFFSET + (x))
-
-#define XLP_GPIO_IRT_OFFSET			(146 + XLP_IRQ_RESERVED_MAX)
-#define XLP_GPIO_IRQ(x)	(XLP_GPIO_IRT_OFFSET + (x))
-
-#define XLP_NOR_IRT_OFFSET			(150 + XLP_IRQ_RESERVED_MAX)
-#define XLP_NOR_IRQ(x)	(XLP_NOR_IRT_OFFSET + (x))
-
-#define XLP_NAND_IRT_OFFSET			(151 + XLP_IRQ_RESERVED_MAX)
-#define XLP_NAND_IRQ(x)	(XLP_NAND_IRT_OFFSET + (x))
-
-#define XLP_SPI_IRT_OFFSET			(152 + XLP_IRQ_RESERVED_MAX)
-#define XLP_SPI_IRQ(x)	(XLP_SPI_IRT_OFFSET + (x))
-
-#define XLP_MMC_IRT_OFFSET			(153 + XLP_IRQ_RESERVED_MAX)
-#define XLP_MMC_IRQ(x)	(XLP_MMC_IRT_OFFSET + (x))
-
-/* The following are the values supported per slot. A slot can have a device or
- * a bridge, but only this much MSI/MSI-X can be alloted on that slot
- * This is a kludge to keep NR_IRQS == 256 and can be expanded later
- * We are using IRQ 192 - 255 for MSI/MSI-X
- * */
-
-#define XLP_PIC_IRTREG_START 0xB4
-#define XLP_ITE_ENTRIES		8
-#ifdef CONFIG_XLP_MSI_ADDRESSES
-#define XLP_MSI_ADDR		0xFEE00000
+#define XLP_PIC_IRQ_UART(x)		((x) + XLP_PIC_IRQ_UART_0)
+#define XLP_PIC_IRQ_I2C_0		(XLP_PIC_IRT_I2C_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_I2C_1		(XLP_PIC_IRT_I2C_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_I2C(x)		((x) + XLP_PIC_IRQ_I2C_0)
+#define XLP_PIC_IRQ_SYS_0		(XLP_PIC_IRT_SYS_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SYS_1		(XLP_PIC_IRT_SYS_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SYS(x)		((x) + XLP_PIC_IRQ_SYS_0)
+#define XLP_PIC_IRQ_JTAG		(XLP_PIC_IRT_JTAG + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_PIC			(XLP_PIC_IRT_PIC + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_GPIO_0		(XLP_PIC_IRT_GPIO_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_GPIO_3		(XLP_PIC_IRT_GPIO_3 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_GPIO(x)		((x) + XLP_PIC_IRQ_GPIO_0)
+#define XLP_PIC_IRQ_NOR			(XLP_PIC_IRT_NOR + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NAND		(XLP_PIC_IRT_NAND + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_SPI			(XLP_PIC_IRT_SPI + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_MMC			(XLP_PIC_IRT_MMC + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_NBU			(XLP_PIC_IRT_NBU + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_TCU			(XLP_PIC_IRT_TCU + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_GCU			(XLP_PIC_IRT_GCU + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_DMC_0		(XLP_PIC_IRT_DMC_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_DMC_1		(XLP_PIC_IRT_DMC_1 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_DMC(x)		((x) + XLP_PIC_IRQ_DMC_0)
+#define XLP_PIC_IRQ_TCB			(XLP_PIC_IRT_TCB + XLP_PIC_IRQ_BASE)
 #endif
-#define XLP_INTX_TO_CTRL_FN(irq) ((irq - XLP_PCIE_LINK_IRQ(0)) & 0x3)
-#define XLP_MSI_ADDR_SIZE	0x00002000
-#define XLP_MSIX_ADDR_SIZE	0x00008000
-#define XLP_BDF_BASE(b,d,f)	(0x18000000 + ((b) << 20) + ((d) << 15) + ((f) << 12))
-#define XLP_MAX_SLOTS		4	/* Only 4 slots now */
-#define XLP_PCIE_CTRL_DEVFN(node, ctr)	PCI_DEVFN((node + 1), ctr)
-
-#ifdef CONFIG_PCI_MSI
-#define XLP_MSI_MM_CAP		5	/* Multiple message capability */
-#define XLP_MSI_PER_SLOT	(1 << XLP_MSI_MM_CAP)
-#define XLP_MSI_IRQ_OFFSET	256	/* Note IRQ not IRT */
-#define XLP_MSI_IRQ_START(fn)	(XLP_MSI_IRQ_OFFSET + (fn) * XLP_MSI_PER_SLOT)
-#define XLP_MSI_INDEX_START	XLP_MSI_IRQ_START(0)
-#define XLP_MSI_INDEX_END	(XLP_MSI_IRQ_START(XLP_MAX_SLOTS) - 1) /* 128 Vectors */
-#define XLP_MSI_TO_CTRL_FN(msi) (((msi) >> (XLP_MSI_MM_CAP)) & 3)
 
-#define XLP_MSIX_PER_SLOT	8
-#define XLP_MSIX_IRQ_OFFSET	192
-#define XLP_MSIX_TO_CTRL_FN(msix) (((msix) >> 3) & 3)
-#define XLP_MSIX_IRQ_START(fn)	(XLP_MSIX_IRQ_OFFSET + (fn) * XLP_MSIX_PER_SLOT)
-#define XLP_MSIX_INDEX_START	XLP_MSIX_IRQ_START(0)
-#define XLP_MSIX_INDEX_END	(XLP_MSIX_IRQ_START(XLP_MAX_SLOTS) - 1)// 31 vectors
+#endif /* _ASM_NLM_XLP_IRQ_H */
 
-#endif
-
-#define	XLP_INTMODE_NONE  0
-#define	XLP_INTMODE_INTX  1
-#define	XLP_INTMODE_MSI  2
-#define	XLP_INTMODE_MSIX  4
-
-#define xlp_incr_ctrl_intmode(fn, mode) xlp_ctrl_intmode_add(fn, mode, 1)
-#define xlp_decr_ctrl_intmode(fn, mode) xlp_ctrl_intmode_add(fn, mode, -1)
-/*
- *     Register Offsets
- */
-#define PIC_CTRL             0x00
-#define PIC_BYTESWAP         0x01
-#define PIC_STATUS           0x02
-#define PIC_INT_TIMEOUT      0x03
-#define PIC_ICI0_INT_TIMEOUT 0x04
-#define PIC_ICI1_INT_TIMEOUT 0x05
-#define PIC_ICI2_INT_TIMEOUT 0x06
-#define PIC_IPI_CTL          0x07
-#define PIC_INT_ACK          0x08
-#define PIC_INT_PENDING0     0x09
-#define PIC_INT_PENDING1     0x0a
-#define PIC_INT_PENDING2     0x0b
-
-#define PIC_WD0_MAX_VAL      0x0c
-#define PIC_WD0_COUNT        0x0d
-#define PIC_WD0_MASK_0       0x0e
-#define PIC_WD0_MASK_1       0x0f
-#define PIC_WD0_HEARBEATCMD  0x10
-#define PIC_WD0_HEARBEAT_0   0x11
-#define PIC_WD0_HEARBEAT_1   0x12
-
-#define PIC_WD_MAX_VAL(id)    (PIC_WD0_MAX_VAL + ((id) ? 7 : 0))
-#define PIC_WD_COUNT(id)      (PIC_WD0_COUNT + ((id) ? 7 : 0))
-#define PIC_WD_MASK_0(id)     (PIC_WD0_MASK_0 + ((id) ? 7 : 0))
-#define PIC_WD_MASK_1(id)     (PIC_WD0_MASK_1 + ((id) ? 7 : 0))
-#define PIC_WD_HEARBEAT_0(id) (PIC_WD0_HEARTBEAT_0 + ((id) ? 7 : 0))
-#define PIC_WD_HEARBEAT_1(id) (PIC_WD0_HEARTBEAT_1 + ((id) ? 7 : 0))
-
-#define PIC_SYS_TIMER_0_MAX_VAL   0x1a
-#define PIC_SYS_TIMER_MAX_VAL(id) (PIC_SYS_TIMER_0_MAX_VAL + (id))
-
-#define PIC_SYS_TIMER_0_COUNTER   0x22
-#define PIC_SYS_TIMER_COUNTER(id) (PIC_SYS_TIMER_0_COUNTER + (id))
-
-#define PIC_TIMER_0_MAXVAL   PIC_SYS_TIMER_0_MAX_VAL
-#define PIC_TIMER_0_COUNTER  PIC_SYS_TIMER_0_COUNTER
-#define PIC_TIMER_7_MAXVAL   PIC_SYS_TIMER_MAX_VAL(7)
-#define PIC_TIMER_7_COUNTER  PIC_SYS_TIMER_COUNTER(7)
-#define PIC_TIMER_6_MAXVAL   PIC_SYS_TIMER_MAX_VAL(6)
-#define PIC_TIMER_6_COUNTER  PIC_SYS_TIMER_COUNTER(6)
-
-#define PIC_INT_THR_ENABLE_0_N01   0x2a
-#define PIC_INT_THR_ENABLE_0_N23   0x2b
-#define PIC_INT_THR_ENABLE_N01(id) (PIC_INT_THR_ENABLE_0_N12 + ((id) * 2))
-#define PIC_INT_THR_ENABLE_N23(id) (PIC_INT_THR_ENABLE_0_N12 + ((id) * 2))
-
-#define PIC_IRT_0   0x3a
-#define PIC_IRT(id) (PIC_IRT_0 + (id))
-
-
-#define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
-#define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
-
-#endif
diff --git a/arch/mips/include/asm/smp.h b/arch/mips/include/asm/smp.h
index fa3de45..bdc47b9 100644
--- a/arch/mips/include/asm/smp.h
+++ b/arch/mips/include/asm/smp.h
@@ -21,9 +21,7 @@ the header of the original work apply to this derived work.
 
 #include <linux/bitops.h>
 #include <linux/linkage.h>
-#ifndef CONFIG_NLM_XLP
 #include <linux/smp.h>
-#endif
 #include <linux/threads.h>
 #include <linux/cpumask.h>
 
@@ -52,11 +50,13 @@ extern int __cpu_logical_map[NR_CPUS];
 #define SMP_CALL_FUNCTION	0x2
 /* Octeon - Tell another core to flush its icache */
 #define SMP_ICACHE_FLUSH	0x4
+#ifdef CONFIG_NLM_XLP
+#define SMP_CALL_KGDB_HOOK	0x8
+#endif
 
 extern volatile cpumask_t cpu_callin_map;
 
 extern void asmlinkage smp_bootstrap(void);
-extern void core_send_ipi(int cpu, unsigned int action);
 
 /*
  * this function sends a 'reschedule' IPI to another CPU.
diff --git a/arch/mips/kernel/nlm_fs_handler.S b/arch/mips/kernel/nlm_fs_handler.S
index a22b0b9..9e83ac2 100644
--- a/arch/mips/kernel/nlm_fs_handler.S
+++ b/arch/mips/kernel/nlm_fs_handler.S
@@ -358,7 +358,7 @@ NESTED(nlm_fs_read_timer, PT_SIZE, sp)
         andi    k0, k0, 0x3ff
         srl     k0, k0, 5  /* grab node id */
         sll     k0, k0, 18 /* Use local PIC */
-        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_SYSTIMER_COUNT(6) << 3)
         dadd    k0, k1, k0
 	ld	k1, 0(k0)
 	dsrl32	$9, k1, 0
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index c8d306b..56c3600 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -45,6 +45,16 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/pic.h>
 #include <asm/netlogic/debug.h>
 
+#define XLP_IRT_NUM	160
+#define XLP_IRQ_MAX	168	/* 0-7 are reserved + 160 IRT entries */
+
+#define XLP_PIC_IRT_UART_0		133
+#define XLP_PIC_IRT_UART_1		134
+#define XLP_PIC_IRT_UART(x)		((x) + XLP_PIC_IRT_UART_0)
+
+#define XLP_PIC_IRQ_UART_0		(XLP_PIC_IRT_UART_0 + XLP_PIC_IRQ_BASE)
+#define XLP_PIC_IRQ_UART_1		(XLP_PIC_IRT_UART_1 + XLP_PIC_IRQ_BASE)
+
 DEFINE_SPINLOCK(xlp_pic_lock);
 
 static uint64_t xlp_irq_mask;
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index dde20b1..b969aa4 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -32,13 +32,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/module.h>
 #include <linux/timer.h>
 
+#include <asm/netlogic/msgring.h>
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/mips-exts.h>
 #include <asm/netlogic/debug.h>
 #include <asm/netlogic/xlp.h>
 
 #include <asm/netlogic/hal/nlm_hal_fmn.h>
-#include <asm/netlogic/xlp_hal_pic.h>
 
 #include <linux/netdevice.h>
 
@@ -170,7 +170,7 @@ static uint16_t xlp3xx_vc_to_handle_map[MAX_VC] = {
 	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
 	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
 	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
-	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[264 ... 267] = XLP_MSG_HANDLE_GDX,
 	[268 ... 271] = XLP_MSG_HANDLE_REGX,
 	[272 ... 275] = XLP_MSG_HANDLE_RSA_ECC,
 	[276 ... 279] = XLP_MSG_HANDLE_CRYPTO,
@@ -247,6 +247,7 @@ EXPORT_SYMBOL(nlm_xlp_register_vc_handler);
  ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
+	unsigned long mflags;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
 	struct msgstn_handler *handler = 0;
@@ -255,9 +256,8 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
 	int cpu = hard_smp_processor_id();
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
-	uint32_t napi_vc_mask;
+	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
 	msg0 = msg1 = msg2 = msg3 = 0;
-	napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
 	
 	if (irq == XLP_IRQ_MSGRING) {
                 /* normal message ring interrupt */
@@ -270,6 +270,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 
 	irq_enter();
 
+        msgrng_access_enable(mflags);
 	cycles = read_c0_count();
 
 	for (;;) {
@@ -325,6 +326,8 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	/* Clear VC interrupt status by writing 1s */
 	xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
 
+        msgrng_access_disable(mflags);
+
 	irq_exit();
 }
 
@@ -365,6 +368,7 @@ void xlp_poll_vc0_messages(void)
         unsigned int msg_status1 = 0, vc_empty_status = 0;
         int loop = 0;
         int pop_vc_mask = 0x1;
+	unsigned long mflags;
 #if 0
 	if (hard_smp_processor_id() != 0)
 		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
@@ -372,6 +376,7 @@ void xlp_poll_vc0_messages(void)
 			       __FUNCTION__,xlp_read_status1());
 #endif
         msg0 = msg1 = msg2 = msg3 = 0;
+        msgrng_access_enable(mflags);
         for (loop = 0; loop < 16; loop++) {
                 /* Read latest VC empty mask */
                 msg_status1 = xlp_read_status1();
@@ -386,6 +391,7 @@ void xlp_poll_vc0_messages(void)
                 (handler->action)(vc, src_id, size, code,
                                 msg0, msg1, msg2, msg3, handler->dev_id);
         }
+        msgrng_access_disable(mflags);
 }
 EXPORT_SYMBOL(xlp_poll_vc0_messages);
 
@@ -489,165 +495,12 @@ void nlm_nmi_cpus(unsigned int mask)
  ********************************************************************/
 void enable_msgconfig_int(void)
 {
-	unsigned long flags  = 0;
+	uint32_t flags;
 
 	/* Need write interrupt vector to cp2 msgconfig register */
+	msgrng_access_enable(flags);
 	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING);
-}
-
-/*
- * Initializes PIC ITE entries PRM 9.5.6.26
- * XLP restricts CPU affinity to 8 groups. They are,
- * 0 =>	Only cpu0/thread0; mask = 1
- * 1 => All CPUs/threads and nodes; mask = (~0 & online_cpu_mask) on all nodes
- * 2 => cpu0-1 on all nodes. mask = 0x000000ff& online_cpu_mask  on all nodes
- * 3 => cpu2-3 on all nodes; mask = 0x0000ff00 & online_cpu_mask on all nodes
- * 4 => cpu4-5 on all nodes; mask = 0x00ff0000 & online_cpu_mask on all nodes
- * 5 => cpu6-7 on all nodes; mask = 0xff000000 & online_cpu_mask on all nodes
- * 6 => cpu0-15 on all nodes; mask = 0x0000ffff & online_cpu_mask on all nodes
- * 7 => cpu15-31 on all nodes; mask = 0xffff0000 & online_cpu_mask on all nodes
- *
- * These are programmer defined groups and can be changed as warranted.
- */
-static struct cpumask xlp_ite_cpumask[XLP_ITE_ENTRIES];
-void xlp_pic_ite_init(const struct cpumask *tgt_mask)
-{
-	int i;
-	struct cpumask m;
-	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
-	char buf[140];
-	u64 bitmask = 0;
-
-	printk(KERN_WARNING "Setting ITE entries only for 0-31 (Node 0) CPUs!\n");
-	cpumask_clear(&m);
-	/* We manipulate only NODE0 ITE entries here */
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_clear(&xlp_ite_cpumask[i]);
-	}
-	cpumask_set_cpu(cpumask_first(tgt_mask), &xlp_ite_cpumask[0]);
-
-	/* Set 0-31 cpus, if present in cpu_online mask */
-	for (i = cpumask_first(tgt_mask); i < 32; ) {
-		bitmask |= (1ULL << i);
-		i = cpumask_next(i, tgt_mask);
-	}
-	cpumask_scnprintf(buf, 140, tgt_mask); fdebug("Target cpumask -> %s\n", buf);
-	cpumask_copy(&xlp_ite_cpumask[1], tgt_mask);
-
-	/* Set 0-7 cpus */
-	for (i = 0; i < 8; i++) {
-		cpumask_set_cpu(i, &m);
-	}
-	/* logical and with cpuonline mask to get the actual mask */
-	cpumask_and(&xlp_ite_cpumask[2], &m, tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[3], &m, 8);
-	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[4], &m, 16);
-	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[5], &m, 24);
-	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], tgt_mask);
-
-	cpumask_shift_left(&xlp_ite_cpumask[6], &m, 8);
-	cpumask_or(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], &m);
-	cpumask_shift_left(&xlp_ite_cpumask[7], &xlp_ite_cpumask[6], 16);
-	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], tgt_mask);
-	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], tgt_mask);
-
-
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_scnprintf(buf, 140, &xlp_ite_cpumask[i]);
-		printk(KERN_DEBUG "Supported CPUMASK (%d) -> %s\n", i, buf);
-	}
-
-	/* Right shift by 1 is required by HAL, _DO_NOT_REMOVE_ */
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x94 >> 1, (0x00000001 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x98 >> 1, (0xffffffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x9C >> 1, (0x000000ff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA0 >> 1, (0x0000ff00 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA4 >> 1, (0x00ff0000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA8 >> 1, (0xff000000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xAC >> 1, (0x0000ffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xB0 >> 1, (0xffff0000 & bitmask));
-	/* We don't populate redirection to other nodes now */
-}
-
-/*
- * This function returns closest match cpumask among the supported bitmasks
- * in XLP
- * Logic is moot, need to improve it later.
- * XXX
- *
- * @m	: user supplied cpumask
- */
-const struct cpumask *xlp_closest_match_cpumask(struct cpumask *m)
-{
-	int i;
-
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		if (cpumask_equal(m, &xlp_ite_cpumask[i])) {
-			return &xlp_ite_cpumask[i];
-		}
-	}
-	return NULL;
-}
-
-/*
- * This function sets the cpumask for an interrupt vector
- * @m	: CPU mask resulting from xlp_closest_match_cpumask() call
- */
-void xlp_set_cpumask(const struct cpumask *m, int irt)
-{
-	int i;
-	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
-	u64 val;
-	u32 offset = ((XLP_PIC_IRTREG_START + (irt << 1)) >> 1);	// Hal requires this nasty right shift
-
-	/* We set the following in IRT entry
-	 * 28 : clear to indicate global delivery
-	 * 19 : clear to indicate DB selects ITE
-	 * 16-18 : set to indicate ITE
-	 * 0-15 : Clear
-	 */
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		if (m != &xlp_ite_cpumask[i]) {
-			continue;
-		}
-		val = nlm_hal_read_64bit_reg(xlp_pic_base, offset);
-		val &= ~((1 << 28) | (1 << 19) | (0x7 << 16) | 0xffff);
-		val |= (i << 16);
-		//fdebug("Writing val = %#llx\n", val);
-		nlm_hal_write_64bit_reg(xlp_pic_base, offset, val);
-		return;
-	}
-	printk(KERN_WARNING "Failed to program IRT entry %d\n", irt);
-	return;
-}
-
-
-/*********************************************************************
- *  pic_init
- *  
- ********************************************************************/
-static void pic_init(void)
-{
-	int i = 0;
-	int level, vcpu;
-	uint32_t thread_mask;
-
-	vcpu = hard_smp_processor_id() & 0x1F;
-
-	thread_mask = (1 << vcpu);
-
-	for (i = XLP_IRQ_RESERVED_MAX; i < XLP_IRT_NUM; i++) {
-		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
-		/* Use local scheduling and high polarity for all IRTs
-		 * Invalidate all IRTs, by default */
-		//nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, xlp_rvec_from_irq(i), 1, 0, thread_mask);
-		nlm_hal_pic_write_irt(xlp_irq_to_irt(i), 0, 0, 1, i, 1, 0, thread_mask);
-	}
-
-	/* On XLP, MSGRING config register is per hw-thread */
-	enable_msgconfig_int();
+	msgrng_access_disable(flags);
 }
 
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
@@ -721,22 +574,14 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 	int count = 0;
 	int no_msg = 0;
 	uint32_t napi_vc_mask = xlp_napi_vc_mask & nlm_cpu_vc_mask[cpu];
-#ifdef CONFIG_32BIT
-	unsigned long mflags;
-#endif
 
 	while(count < budget){
 		for( no_msg = 0, vc = 0; vc < 4; vc++)
 		{
 			if(!(napi_vc_mask & (1<<vc)))
 				continue;
-#ifdef CONFIG_32BIT
-			msgrng_access_enable(mflags);
-#endif
+
 			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
-#ifdef CONFIG_32BIT
-			msgrng_access_disable(mflags);
-#endif
 			if(status != 0){
 				no_msg++;
 				continue;
@@ -762,18 +607,12 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		uint32_t val;
 		unsigned long flags;
 		local_irq_save(flags);
-#ifdef CONFIG_32BIT
-		msgrng_access_enable(mflags);
-#endif
                 napi_complete(napi);
 		/* Need write vc into the register */
 		val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
 		//val |= ((1 << vc) << 16);
 		val |= (napi_vc_mask << 16);
 		_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
-#ifdef CONFIG_32BIT
-		msgrng_access_disable(mflags);
-#endif
 		local_irq_restore(flags);
 		return count;
 	}
@@ -834,13 +673,10 @@ void on_chip_init(void)
 
 	nlm_hal_init();
 
-	pic_init(); 
-
 	for (i = 0; i < NR_CPUS; i++)
 	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
 
-	
 	if(xlp_napi_vc_mask)
 		xlp_napi_fmn_setup();
 }
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 81ed1fb..8a7622d 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -36,7 +36,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
-#include <asm/netlogic/xlp_hal_pic.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 #include <asm/netlogic/iomap.h>
@@ -96,7 +97,7 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].mapbase       = DEFAULT_NETLOGIC_IO_BASE 
 						+ NETLOGIC_IO_UART_0_OFFSET + port_id * XLP_UART_PORTIO_OFFSET;
         xlp_uart_port[port_id].membase       = (void __iomem *)xlp_uart_port[port_id].mapbase;
-        xlp_uart_port[port_id].irq           = XLP_PIC_IRQ_UART(port_id);
+        xlp_uart_port[port_id].irq           = xlp_pic_irt_to_irq(XLP_PIC_IRT_UART(port_id));
 
         xlp_uart_port[port_id].uartclk       = UART_CLK;
         xlp_uart_port[port_id].iotype        = UPIO_MEM32;
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 146046b..7f1b840 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -28,6 +28,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
+#include <linux/interrupt.h>
 
 #include <asm/mipsregs.h>
 #include <asm/mmu_context.h>
@@ -64,7 +65,6 @@ extern void enable_cpus(unsigned int node, unsigned online_mask);
 extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
-extern void xlp_pic_ite_init(const struct cpumask *);
 
 /*
  * Input parameter is logical cpu number.
@@ -146,7 +146,7 @@ void nlm_cpus_done(void)
  * The cpu argument is the bit number from cpu_present_mask (for_each_online_cpu
  * ) => logical cpu id
  */
-void nlm_boot_secondary(int cpu, struct task_struct *idle)
+void __cpuinit nlm_boot_secondary(int cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
@@ -205,8 +205,6 @@ void __init nlm_smp_setup(void)
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
 	printk("Possible CPU map %s\n", buf);
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
-	/* Setup PIC with passed fdt_cpumask : PIC requires physical CPU ids*/
-	xlp_pic_ite_init((const struct cpumask *)&fdt_cpumask);
 }
 
 #ifdef CONFIG_XEN
@@ -277,8 +275,30 @@ int wakeup_secondary_cpus(void)
 	return 0;
 }
 
+static irqreturn_t smp_resched_ipi_handler(int irq, void *dev_id)
+{
+	scheduler_ipi();
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t smp_function_ipi_handler(int irq, void *dev_id)
+{
+	smp_call_function_interrupt();
+	return IRQ_HANDLED;
+}
+
 void nlm_prepare_cpus(unsigned int max_cpus)
 {
+	if (request_irq(XLP_IRQ_IPI_SMP_FUNCTION, smp_function_ipi_handler,
+			IRQF_PERCPU | IRQF_NO_THREAD,
+			"IPI:smp function", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_FUNCTION)\n");
+	}
+	if (request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE, smp_resched_ipi_handler,
+			IRQF_PERCPU | IRQF_NO_THREAD,
+			"IPI:smp reschedule", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_IPI_SMP_RESCHEDULE)\n");
+	}
 }
 
 struct plat_smp_ops nlm_smp_ops = {
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index 2385598..f7e796a 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -51,17 +51,17 @@ void save_epc(unsigned long *epc)
 extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
 					 struct pt_regs *regs);
 #endif
-/* PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit 
-   counter is sufficient
-   */
-#define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
+
+/* Use PIC Timer 6 as a free running counter */
+#define FRC        6
+#define FRC_MAXVAL PIC_SYSTIMER_MAXVAL
+
 cycle_t xlp_hpt_read(void)
 {
-	uint32_t counter;
-	pic_reg_t *mmio = nlm_hal_pic_offset();
-	counter = (uint32_t) nlm_hal_read_pic_reg(mmio, PIC_TIMER_6_COUNTER);
-	return (cycle_t)(PIC_FREE_RUNNING_TIMER_MAX_VAL - counter);
+	cycle_t counter = nlm_hal_pic_read_timer(FRC);
+	return (FRC_MAXVAL - counter);
 }
+EXPORT_SYMBOL(xlp_hpt_read);
 
 int read_current_timer(unsigned long *timer_val)
 {
@@ -71,19 +71,14 @@ int read_current_timer(unsigned long *timer_val)
 
 void nlm_common_timer_setup(void)
 {
-        pic_reg_t *mmio = nlm_hal_pic_offset();
         unsigned long flags = 0;
 
         spin_lock_irqsave(&xlp_pic_lock, flags);
 
-        /* Use PIC Timer 6 as a free running counter */
-        nlm_hal_write_pic_reg(mmio, PIC_TIMER_6_MAXVAL, 0xffffffffffffffffULL);
-
-	/* enable the timer */
-        nlm_hal_pic_update_control(1 << (10 + 6));
+	nlm_hal_pic_init_timer(FRC, FRC_MAXVAL);
+	nlm_hal_pic_enable_timer(FRC);
 
         spin_unlock_irqrestore(&xlp_pic_lock, flags);
-
 }
 
 static int nlm_timer_proc_read(char *page, char **start, off_t off, int count,
diff --git a/arch/mips/netlogic/xlp/xlp_hal_pic.c b/arch/mips/netlogic/xlp/xlp_hal_pic.c
index 3a0520a..6ed7bb2 100644
--- a/arch/mips/netlogic/xlp/xlp_hal_pic.c
+++ b/arch/mips/netlogic/xlp/xlp_hal_pic.c
@@ -1,4 +1,5 @@
 #include <asm/netlogic/xlp_hal_pic.h>
+#include <linux/types.h>
 
 /*
  * __nlm_hal_request_irq
-- 
1.7.0.4

