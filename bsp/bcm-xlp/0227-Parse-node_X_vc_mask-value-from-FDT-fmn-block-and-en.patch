From 7a964b55a71e06dddca9595cc7ef0dbbd48e6b8b Mon Sep 17 00:00:00 2001
From: Mehul <vmehul@netlogicmicro.com>
Date: Fri, 17 Sep 2010 16:50:12 +0530
Subject: [PATCH 227/762] Parse "node_X_vc_mask" value from FDT - fmn block and enable interrupts of the VCs owned by linux.

Based on Broadcom SDK 2.3.

Signed-off-by: Mehul <vmehul@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp.h |    4 +++
 arch/mips/netlogic/xlp/on_chip.c     |   33 ++++++++++++++++++++++++++--
 arch/mips/netlogic/xlp/setup.c       |   39 ++++++++++++++++++++++++++++++++++
 arch/mips/netlogic/xlp/smp.c         |    4 +++
 4 files changed, 77 insertions(+), 3 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index 9149917..3ca893e 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -42,6 +42,10 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #define XLP_REVISION_A0 	0xc0010
 #define MAX_CPU_REV_LEN		100
+#define NLM_MAX_CPU_NODE		4
+#define NLM_MAX_CPU_PER_NODE	32
+#define NLM_MAX_THREADS_PER_CPU	4
+#define NLM_MAX_VC_PER_THREAD	4
 
 #define PCI_NETL_VENDOR         0x184E
 #define XLP_DEVID_DRAM          0x1001
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 7b56e0d..b41a685 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -53,6 +53,7 @@ extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
 extern void nlm_cpu_stat_update_msgring_pic_int(void);
 
 uint32_t msgring_global_thread_mask = 0;
+uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE] = {0};
 
 /* make this a read/write spinlock */
 spinlock_t msgrng_lock;
@@ -182,6 +183,8 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	uint64_t msg0, msg1, msg2, msg3;
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
 	int loop = 0;
+	int cpu = hard_smp_processor_id();
+	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
 
 	msg0 = msg1 = msg2 = msg3 = 0;
 
@@ -205,11 +208,13 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 		/* Read latest VC empty mask */
 		msg_status1 = xlp_read_status1();
 
-		vc_empty_status = (msg_status1 >> 24) & 0xf;
-		if (vc_empty_status == 0xf) break;
+		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+		if (vc_empty_status == pop_vc_mask) break;
 
 		for( vc = 0; vc < 4; vc++)
 		{
+			if(!(pop_vc_mask & (1<<vc)))
+				continue;
 			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
 			if(status != 0)
 				continue;
@@ -228,7 +233,7 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
 
 	/* Clear VC interrupt status by writing 1s */
-	xlp_write_status1( (msg_status1 | (0xf << 16)) );
+	xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
 
         msgrng_access_disable(mflags);
 
@@ -373,6 +378,26 @@ static void nlm_usb_init (void)
 	}
 }
 
+
+/*********************************************************************
+ * nlm_enable_vc_intr
+ *********************************************************************/
+void nlm_enable_vc_intr(void)
+{
+	int cpu = hard_smp_processor_id();
+	int vc_index = 0;
+	int i = 0;
+
+	for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
+	{
+		if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			/*enable interrupts*/
+			nlm_hal_enable_vc_intr(vc_index);
+		}
+	}
+}
+
 /*********************************************************************
  * on_chip_init
  *  
@@ -396,4 +421,6 @@ void on_chip_init(void)
 	for (j = 0; j < NLM_MAX_COUNTERS; j++)
 			atomic_set(&nlm_common_counters[i][j], 0);
 
+	/*enable vc interrupts*/
+	nlm_enable_vc_intr();
 }
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index f3fc4f6..362739d 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -410,6 +410,10 @@ static int fdt_process(void)
 	int  domain=0;
 	char domstr[32] = "";
 	int  i, na, ns, regs[4], entries, cpu_cells;
+	uint32_t node_vc_mask[4] = {0};
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
+	unsigned char buf[30];	
+	int j, id=0, k, tmp;
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -539,6 +543,41 @@ static int fdt_process(void)
 		printk("fdt_cpumask: %s\n", buf);
 	}
 
+	node = finddevice("/doms/dom@0/fmn");
+	if (node){
+		for(i=0; i<NLM_MAX_CPU_NODE; i++){
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if(getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/*If no mask is passed, derive it from cpu online mask*/
+				if(smp_node.onlinemask[i]){
+					for(j=0; j<NLM_MAX_CPU_PER_NODE; j++, id++){
+						if(smp_node.onlinemask[i] & (1<<j))
+							nlm_cpu_vc_mask[id] = 0xf;
+					}
+				}
+			}else{
+				/*Get vc mask from the fdt*/
+				for(j=0; j<4; j++){
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for(k=0; k<8; k++){
+						nlm_cpu_vc_mask[id++] = (tmp>>(k*4)) & 0xf;
+					}
+				}
+			}
+		}
+	}else{
+		/*Derive vc mask from cpu online map*/
+		for(i=0; i<NLM_MAX_CPU_NODE; i++){
+			if(smp_node.onlinemask[i]){
+				for(j=0; j<NLM_MAX_CPU_PER_NODE; j++, id++){
+					if(smp_node.onlinemask[i] & (1<<j))
+						nlm_cpu_vc_mask[id] = 0xf;
+				}
+			}
+		}
+	}
+
 	sprintf(domstr, "/doms/dom@%d/uart", domain);
 	node = finddevice(domstr);
 	if(node){
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index f137d64..6c481d2 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -51,6 +51,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 struct smp_boot_info smp_boot;
 cpumask_t fdt_cpumask;
 
+void nlm_enable_vc_intr(void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 extern void prom_reconfigure_thr_resources(void);
 extern unsigned long nlm_common_ebase;
@@ -113,6 +114,9 @@ static void __cpuinit nlm_init_secondary(void)
 		    nlm_common_timer_setup();
 	    }
     }
+
+    /* Enable vc interupts for this thread*/
+    nlm_enable_vc_intr();
 }
 
 void nlm_smp_finish(void)
-- 
1.7.0.4

