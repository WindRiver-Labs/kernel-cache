From a5956b819223ee23d690b619980be701390b4a96 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Fri, 8 Oct 2010 18:15:34 -0700
Subject: [PATCH 203/762] First set of changes for multi-node, currently boots on single node

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/bootinfo.h    |    3 +-
 arch/mips/include/asm/netlogic/mips-exts.h   |   39 +----
 arch/mips/include/asm/netlogic/sim.h         |    2 +-
 arch/mips/include/asm/netlogic/xlp.h         |    8 +-
 arch/mips/kernel/syscall.c                   |    8 +
 arch/mips/kernel/xlr_fast_sys_call_handler.S |    4 +-
 arch/mips/netlogic/xlp/cpu_control.c         |    1 +
 arch/mips/netlogic/xlp/setup.c               |  201 +++++++++++++++-----------
 arch/mips/netlogic/xlp/smp.c                 |  132 +++++++++--------
 arch/mips/netlogic/xlp/xenbootinfo.c         |   12 +-
 10 files changed, 217 insertions(+), 193 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 3b19097..7ac65f4 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -25,7 +25,6 @@ extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
 #ifdef CONFIG_NLM_XLP
 extern struct psb_info *prom_info;
 extern struct psb_info prom_info_copy;
-extern struct boot_mem_map prom_map;
 extern struct boot_mem_map boot_physaddr_info;
 
 extern int read_cmdline_args(int *argc, char *n_argv[], char *n_envp[]);
@@ -37,7 +36,7 @@ extern int read_physaddr_map(void);
 extern int wakeup_secondary_cpus(void);
 #else
 extern int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), 
-		struct psb_info *prom_info);
+				 struct psb_info *prom_info);
 #endif
 #endif
 
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index ca30429..247d6dd 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -249,31 +249,6 @@ static __inline__ void ldadd_wu_no_read(unsigned int value,
                        );
 }
 
-#define netlogic_cpu_id()                                        \
-({int __id;                                                     \
- __asm__ __volatile__ (                                         \
-		       ".set push\n"                            \
-		       ".set noreorder\n"                       \
-                       ".set mips32\n"                          \
-                       "mfc0 $8, $15, 1\n"                      \
-		       "andi $8, $8, 0x3ff\n"                   \
-		       "srl %0, $8, 1\n"                        \
-		       ".set pop\n"                             \
-		       : "=r" (__id) : : "$8");                 \
- __id;})
-
-#define netlogic_thr_id()                                        \
-({int __id;                                                     \
- __asm__ __volatile__ (                                         \
-		       ".set push\n"                            \
-		       ".set noreorder\n"                       \
-                       ".set mips32\n"                          \
-                       "mfc0 $8, $15, 1\n"                      \
-		       "andi %0, $8, 0x3\n"                     \
-		       ".set pop\n"                             \
-		       : "=r" (__id) : : "$8");                 \
- __id;})
-
 static __inline__ int hard_smp_processor_id(void)
 {
 	int cpu;
@@ -282,17 +257,19 @@ static __inline__ int hard_smp_processor_id(void)
 		".set push\n"
 		".set noreorder\n"
                 ".set mips32\n"
-                "mfc0 $8, $15, 1\n"
-		"andi %0, $8, 0x3ff\n"
+                "mfc0 %0, $15, 1\n"
+		"andi %0, %0, 0x3ff\n"
 		".set pop\n"
-		: "=&r"(cpu) : : "$8"
+		: "=&r"(cpu)
 		);
 
-	return ((cpu & 0x7f));
+	return cpu;
 }
 
-#define netlogic_cpu_to_thrid(cpu) (phys_proc_id[(cpu)] >> 2)
-#define netlogic_cpu_to_cpuid(cpu) (phys_proc_id[(cpu)] & 0x3)
+static __inline__ int netlogic_thr_id(void)
+{
+	return hard_smp_processor_id() & 0x03;
+}
 
 #define CPU_BLOCKID_IFU      0
 #define CPU_BLOCKID_ICU      1
diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
index 8f2f1df..307af89 100644
--- a/arch/mips/include/asm/netlogic/sim.h
+++ b/arch/mips/include/asm/netlogic/sim.h
@@ -115,7 +115,7 @@ struct smp_boot_info_percpu {
 };
 
 struct smp_boot_info {
-  struct smp_boot_info_percpu boot_info[128];
+  struct smp_boot_info_percpu boot_info[NR_CPUS];
   __u32 online_map;
 };
 
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index e61e3fb..42e5195 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -51,17 +51,13 @@ struct smp_boot_info_percpu {
 };
 
 struct smp_boot_info {
-  struct smp_boot_info_percpu boot_info[128];
-  __u32 online_map;
+  struct smp_boot_info_percpu boot_info[NR_CPUS];
+  cpumask_t online_map;
 };
 
 extern struct smp_boot_info smp_boot;
 extern void prom_boot_cpus_secondary(void *);
 
-struct node_mask{
-	uint32_t onlinemask[4];
-};
-
 extern char cpu_model_info[MAX_CPU_REV_LEN];
 extern char* get_cpu_info(void);
 #endif /*_ASM_XLP_H */ 
diff --git a/arch/mips/kernel/syscall.c b/arch/mips/kernel/syscall.c
index a09214a..0a43bc8 100644
--- a/arch/mips/kernel/syscall.c
+++ b/arch/mips/kernel/syscall.c
@@ -72,17 +72,25 @@ unsigned long xlr_fast_sys_call_table[] = {
 	[NLM_UACCESS_FS_READ_COP] = (unsigned long)xlr_fast_syscall_msg_read,
 	[NLM_UACCESS_FS_PERFCTR_START] = (unsigned long)xlr_fast_syscall_perf_ctr_start,
 	[NLM_UACCESS_FS_PERFCTR_STOP] = (unsigned long)xlr_fast_syscall_perf_ctr_stop,
+
+#if defined(CONFIG_NLM_XLR)
 	[NLM_UACCESS_FS_READ_CPUMASKS] = (unsigned long)xlr_fast_syscall_get_cpumasks,
+#else
+	[NLM_UACCESS_FS_READ_CPUMASKS] = (unsigned long)xlr_fast_syscall_unused,
+#endif
+
 	[NLM_UACCESS_FS_READ_PROCID] = (unsigned long)xlr_fast_syscall_processorId,
 	[NLM_UACCESS_FS_READ_TIMER] = (unsigned long)nlm_uaccess_fs_read_timer,
 	[NLM_UACCESS_FS_HARD_CPUID] = (unsigned long)nlm_uaccess_fs_hard_cpuid,
 	[NLM_UACCESS_FS_ENDIANESS] = (unsigned long)nlm_uaccess_fs_is_big_endian,
 	[NLM_UACCESS_FS_REVERSE_ENDIANESS] = (unsigned long)nlm_uaccess_fs_is_endian_reversed,
 	[NLM_UACCESS_FS_USPACE_64BIT_INS] = (unsigned long)nlm_uaccess_fs_uspace_64bit_ins_enabled,
+
 #if defined(CONFIG_NLM_XLR)
 	[NLM_UACCESS_FS_PROMINFO] = (unsigned long)xlr_fast_syscall_prominfo,
 	[NLM_UACCESS_FS_CPU_MAX_FREQ] = (unsigned long)nlm_uaccess_fs_cpu_max_freq,
 #endif
+
 #if defined(CONFIG_NLM_XLP)
 	[NLM_UACCESS_FS_MEM_READ64] = (unsigned long)nlm_uaccess_fs_mem_read64,
 	[NLM_UACCESS_FS_MEM_WRITE64] = (unsigned long)nlm_uaccess_fs_mem_write64,
diff --git a/arch/mips/kernel/xlr_fast_sys_call_handler.S b/arch/mips/kernel/xlr_fast_sys_call_handler.S
index 0ff319c..c88568a 100644
--- a/arch/mips/kernel/xlr_fast_sys_call_handler.S
+++ b/arch/mips/kernel/xlr_fast_sys_call_handler.S
@@ -393,7 +393,7 @@ END(nlm_uaccess_fs_mem_write32)
 
 	END(xlr_fast_syscall_perf_ctr_stop)
 
-
+#if defined(CONFIG_NLM_XLR)
 	NESTED(xlr_fast_syscall_get_cpumasks, PT_SIZE, sp)
 
 		.word 0x40088007
@@ -415,7 +415,7 @@ END(nlm_uaccess_fs_mem_write32)
 		eret
 
 	END(xlr_fast_syscall_get_cpumasks)
-
+#endif
 
 	NESTED(xlr_fast_syscall_processorId, PT_SIZE, sp)
 
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 942adaf..98fb40b 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -217,5 +217,6 @@ void enable_cpus( unsigned int node, unsigned int onlinemask)
 	enable_cores( node, cbitmap, threads_to_enable);
 
 	spin_unlock_irqrestore(&smp_lock, flags);
+
 	return;
 }
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 63ee181..bb044eb 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -58,6 +58,7 @@
 #include <linux/proc_fs.h>
 #include <asm/mach-netlogic/mmu.h>
 #include <asm/netlogic/bootinfo.h>
+#include <asm/netlogic/cpumask.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 
@@ -78,12 +79,8 @@
 #define BOOT_LOADER_REGION_SZ 			0x04000000
 #define LOADER_KSEG_END 			0x10000000
 
-static unsigned int xlp_uart_portid = 0;
-unsigned long nlm_common_ebase = 0x0;
-
 #define PROCESSOR_ID_MAX_LEN 			6
-char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
-static char prop_buf[MAX_PROP_LEN];
+
 extern char _end;
 extern void *fdt;
 
@@ -96,39 +93,51 @@ extern void *simple_alloc_init(char *base, unsigned long heap_size,
 extern unsigned int xlp_uart_in(struct uart_port *p, int offset);
 extern void xlp_uart_out(struct uart_port *p, int offset, int value);
 
-int use_default_phymem 	= 0;
-struct boot_mem_map prom_map;
-
-/* Struct for temp. allocation
- * of sp/gp for secondary CPUs
- */
-struct xlp_stack_pages {
-	unsigned long stack[(TOTAL_THREAD_SIZE)/sizeof(long)];
-};
-struct xlp_stack_pages xlp_stack_pages_temp
-__attribute__((__section__(".data.init_task"),
-	       __aligned__(THREAD_SIZE)));
+extern void (*board_nmi_handler_setup)(void );
+extern unsigned long _text[];
+extern cpumask_t fdt_cpumask;
 
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
 
-unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
+unsigned long nlm_common_ebase = 0x0;
 
-spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
+char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
 
-int hwemul = 0;
-EXPORT_SYMBOL(hwemul);
+static unsigned int xlp_uart_portid = 0;
+
+static char prop_buf[MAX_PROP_LEN];
 
 void *nlm_common_psb_shm = 0;
 unsigned long nlm_common_psb_shm_size = 0;
-extern unsigned long _text[];
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 unsigned long nlm_asid_mask = 0x3f;
 unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
 #endif
 
-extern struct node_mask smp_node;
+const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
+const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
+
+#ifdef CONFIG_SMP
+atomic_t cpus_rebooted = ATOMIC_INIT(0);
+#endif
+
+unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
+spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
+
+int hwemul = 0;
+EXPORT_SYMBOL(hwemul);
+
+/* Struct for temp. allocation
+ * of sp/gp for secondary CPUs
+ */
+struct xlp_stack_pages {
+	unsigned long stack[(TOTAL_THREAD_SIZE)/sizeof(long)];
+};
+struct xlp_stack_pages xlp_stack_pages_temp
+__attribute__((__section__(".data.init_task"),
+	       __aligned__(THREAD_SIZE)));
 
 struct boot_mem_map boot_physaddr_info = {
 	.nr_map = 5,
@@ -160,6 +169,7 @@ struct boot_mem_map boot_physaddr_info = {
 		},
 	}
 };
+
 int nlm_common_get_pgprot(unsigned long address)
 {
 	int i = 0;
@@ -198,18 +208,11 @@ int valid_mmap_nlm_common_addr_range(unsigned long pfn)
 	return 0;
 }
 
-const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
-const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
-
 const char *get_system_type(void)
 {
 	return "Netlogic XLP SIM";
 }
 
-#ifdef CONFIG_SMP
-atomic_t cpus_rebooted = ATOMIC_INIT(0);
-#endif
-
 static void ptr_linux_exit(void)
 {
 	// trigger a chip reset
@@ -224,24 +227,25 @@ void __init bus_error_init(void)
 
 void prom_reconfigure_thr_resources(void)
 {
-	unsigned int mmu_setup=0;
-	int i=0, count=0, dis_contig=0;
+	unsigned int mmu_setup = 0;
+	int i = 0, num_threads = 0, dis_contig = 0;
 	int value = 0;
+	int cpu = 0;
 
-	__u32 online_map, thr_mask;
+	/* Configure thread resources only if it is thread_0 of that core */
+	if (netlogic_thr_id() != 0) return;
+
+#if 0 /* Fix for Multi-Node */
 
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 	uint32_t map;
-#endif
-
-	online_map = smp_node.onlinemask[0];    /* from fdt */
 
-	thr_mask = online_map >> (netlogic_cpu_id()<<2);
-
-#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 	/* netlogic kernel configures this
 	 */
 	if (nlm_shtlb && (nlm_asid_mask == 0x3f)) {
+
+		uint32_t online_map = smp_node.onlinemask[0];    /* from fdt */
+
 		/* Global TLB will work only if all
 		 * the enabled cores have all their
 		 * threads owned by Linux.
@@ -269,27 +273,32 @@ void prom_reconfigure_thr_resources(void)
 	return;
 #endif /* CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID */
 
-	 if (netlogic_thr_id() == 0) {
-		for (i=0;i<4;i++) {
-			if (thr_mask & (1<<i)) {
-				if (i != count)
-					dis_contig = 1;
-				count++;
-			}
-		}
-		switch(count) {
-			case 1: value = 0x00; break;
-			case 2: value = 0x02; break;
-			default:
-					value = 0x03; break;
-		}
-		if (dis_contig)
-			value = 0x3;
-		mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
-		mmu_setup = mmu_setup & ~0x06;
-		mmu_setup |= (value << 1);
-		write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
+#endif
+	/* cpu has to be thread@0 */
+	cpu = hard_smp_processor_id();
+
+	for (i = 0; i < 4; i++) {
+
+		if (!cpumask_test_cpu(cpu + i, &fdt_cpumask)) continue;
+
+		if (i != num_threads)	dis_contig = 1;
+
+		num_threads++;
 	}
+
+	switch(num_threads) {
+	case 1: value = 0x00; break;
+	case 2: value = 0x02; break;
+	default:
+		value = 0x03; break;
+	}
+
+	if (dis_contig)	value = 0x3;
+
+	mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
+	mmu_setup = mmu_setup & ~0x06;
+	mmu_setup |= (value << 1);
+	write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
 }
 
 unsigned int __cpuinit get_c0_compare_int(void)
@@ -334,8 +343,6 @@ static void prom_add_memory(uint64_t start, uint64_t size)
 }
 
 
-extern void (*board_nmi_handler_setup)(void );
-
 void __init nlm_nmi_setup (void)
 {
 	/* setup nmi handler only if KGDB is enabled */
@@ -352,6 +359,7 @@ void __init nlm_nmi_setup (void)
 /* setup early serial port driver */
 #ifdef CONFIG_SERIAL_8250
 #define UART_CLK 133333333
+
 static void nlm_early_serial_setup(int uart_id)
 {
 	struct uart_port s;
@@ -395,13 +403,14 @@ static void nlm_early_serial_setup(int uart_id) {}
 
 extern struct plat_smp_ops nlm_smp_ops;
 
+#define MAX_CPUMASK_CELLS 4
 #define fdt32_to_cpu(x) be32_to_cpu(x)
 
 static int fdt_process(void)
 {
 	int  domain=0;
 	char domstr[32] = "";
-	int  i, na, ns, regs[4], entries, cpu_nodes;
+	int  i, na, ns, regs[4], entries, cpu_cells;
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -409,6 +418,8 @@ static int fdt_process(void)
 	void *blob = (void *)fw_arg0;
 	void *node;
 
+	cpumask_clear(&fdt_cpumask);
+
 	if(!blob)
 		return -1;
 	/* Create a region starting from
@@ -454,12 +465,13 @@ static int fdt_process(void)
 		if (ns < 1 || ns > 2)
 			printk("Can't cope with #size-cells == %d.\n\r", ns);
 
-		if (getprop(node, "#cpumask-cells", &cpu_nodes, sizeof(cpu_nodes)) < 0)
-			cpu_nodes = 1;
+		if (getprop(node, "#cpumask-cells", &cpu_cells, sizeof(cpu_cells)) < 0)
+			cpu_cells = 1;
 		else
-			cpu_nodes = fdt32_to_cpu(cpu_nodes);
-		if (cpu_nodes < 1 || cpu_nodes > 4)
-			printk("Can't cope with #cpumask-cells == %d.\n\r", ns);
+			cpu_cells = fdt32_to_cpu(cpu_cells);
+
+		if (cpu_cells < 1 || cpu_cells > MAX_CPUMASK_CELLS)
+			printk("Can't cope with #cpumask-cells == %d\n\r", cpu_cells);
 	}
 
 	node = finddevice("/doms/dom@0/memory");
@@ -486,32 +498,47 @@ static int fdt_process(void)
 	 * domain 0 (linux)
 	 */
 	sprintf(domstr, "/doms/dom@%d/cpu", domain);
-	
-	for(i = 0; i < 4; i++)
-		smp_node.onlinemask[i] = 0;
 
 	node = finddevice(domstr);
 	if (node) {
-		if(cpu_nodes > 1)
-		{	
-			getprop(node, "onlinemask", &smp_node.onlinemask[0], sizeof(struct node_mask));
+		uint32_t onlinemask_buf[MAX_CPUMASK_CELLS];
+		uint32_t onlinemask[MAX_CPUMASK_CELLS];
+		char buf[CPUMASK_BUF];
+
+		/* Initialize buffers */
+		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
+			onlinemask_buf[i] = 0;
+			onlinemask[i] = 0;
 		}
-		else
-		{
-			getprop(node, "onlinemask", &smp_node.onlinemask[0], sizeof(smp_node.onlinemask[0])); 
+
+		/* Parse cpumask from FDT and handle endianness */
+		getprop(node, "onlinemask", &onlinemask_buf[0], sizeof(uint32_t) * cpu_cells);
+
+		for (i = 0; i < cpu_cells; i++) {
+			onlinemask_buf[i] = fdt32_to_cpu(onlinemask_buf[i]);
+
+			printk("FDT: cpu_cells: %d onlinemask[%d]: %08x\n",
+			       cpu_cells, i, onlinemask_buf[i]);
 		}
-		for(i = 0; i < cpu_nodes; i++)
-		{
-			smp_node.onlinemask[i] = fdt32_to_cpu(smp_node.onlinemask[i]);
-			printk("FDT: cpu_nodes: %d smp_node.onlinemask[%d]: %x\n",cpu_nodes, i , smp_node.onlinemask[i]);
+
+		/* Store cpumask in predefined order */
+		for (i = 0; i < cpu_cells; i++) {
+			onlinemask[i] = onlinemask_buf[cpu_cells - 1 - i];
 		}
 
+		for (i = 0; i < MAX_CPUMASK_CELLS; i++) {
+			int j = 0;
 
-	}
+			for (j = 0; j < 32; j++) {
+				if ((onlinemask[i] & (1 << j)) == 0) continue;
 
-	if (!smp_node.onlinemask[0])
-		/* something went wrong ? */
-		smp_node.onlinemask[0] = 0x1;
+				cpumask_set_cpu((i * 32 + j), &fdt_cpumask);
+			}
+		}
+
+		cpumask_scnprintf(buf, CPUMASK_BUF, &fdt_cpumask);
+		printk("fdt_cpumask: %s\n", buf);
+	}
 
 	sprintf(domstr, "/doms/dom@%d/uart", domain);
 	node = finddevice(domstr);
@@ -563,13 +590,13 @@ void __init prom_init(void)
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	fdt_process();
-	
+
 	xen_init();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
-	smp_boot.online_map = (1 << hard_smp_processor_id());
-
+	cpumask_clear(&smp_boot.online_map);
+	cpumask_set_cpu(hard_smp_processor_id(), &smp_boot.online_map);
 
 	board_nmi_handler_setup = nlm_nmi_setup;
 
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 76d2a99..acc3cf1 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -42,14 +42,14 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 
+#include <asm/netlogic/cpumask.h>
+
 #include <asm/mach-netlogic/mmu.h>
-#include "cpu_control_macros.h"
 
+#include "cpu_control_macros.h"
 
-unsigned int fast_syscall_cpumask_phy = 0x1;
 struct smp_boot_info smp_boot;
-struct node_mask smp_node;
-cpumask_t phys_cpu_present_map;
+cpumask_t fdt_cpumask;
 
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 extern void prom_reconfigure_thr_resources(void);
@@ -81,10 +81,11 @@ void nlm_send_ipi_single(int cpu, unsigned int action)
 
 void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
 {
-    int cpu;
-    for_each_cpu(cpu, mask){
-	 nlm_send_ipi_single(cpu, action);
-    }
+	int cpu;
+
+	for_each_cpu(cpu, mask){
+		nlm_send_ipi_single(cpu, action);
+	}
 }
 
 /*
@@ -120,78 +121,84 @@ void nlm_boot_secondary(int cpu, struct task_struct *idle)
 	/* barrier */
 	__sync();
 	smp_boot.boot_info[cpu].ready = 1;
-  
+
 /*  	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu);  */
 }
 
-
 void __init nlm_smp_setup(void)
 {
-	int num_cpus;
-	__u32 boot_cpu_online_map = 0, boot_cpu = 0x0;
-	int i=0, j=0;
+	int num_cpus = 0;
+	int boot_cpu = hard_smp_processor_id();
+	int i = 0;
+	char buf[CPUMASK_BUF];
+
+	/* Initialize maps */
+	for (i = 0; i < NR_CPUS; i++) {
+		__cpu_number_map[i] = 0;
+		__cpu_logical_map[i] = boot_cpu;
+	}
 
-	boot_cpu = hard_smp_processor_id();
+	/* Setup map for master cpu */
+	__cpu_number_map[boot_cpu] = 0;
+	__cpu_logical_map[0] = boot_cpu;
+	num_cpus = 1;
 
-	cpus_clear(phys_cpu_present_map);
+	/* Setup map for other cpus */
+	for (i = 0; i < NR_CPUS; i++) {
 
-	boot_cpu_online_map = smp_node.onlinemask[0];
-	smp_boot.online_map = smp_node.onlinemask[0];
+		if (i == boot_cpu) continue;
 
-	/* Fill the entries for boot cpu */
-	boot_cpu_online_map &= (~(1 << boot_cpu));
-	cpu_set(boot_cpu, phys_cpu_present_map);
+		if (cpumask_test_cpu(i, &fdt_cpumask)) {
 
-	cpus_clear(cpu_possible_map);
-	__cpu_number_map[boot_cpu] = 0;
-	__cpu_logical_map[0] = boot_cpu;
-	cpu_set(0, cpu_possible_map);
-	num_cpus = 1;
-	for(i = 0; i < 32; i++) {
-		if (boot_cpu_online_map & (1<<i)) {
-			cpu_set(i, cpu_possible_map);
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
-			++num_cpus;
-		}
-	}
-
-	for(j = 1; j < 4; j++)
-	{
-		boot_cpu_online_map = smp_node.onlinemask[j];
-		if(boot_cpu_online_map == 0)
-			continue;
 
-		for(i = 0; i < 32; i++) {
-			if (boot_cpu_online_map & (1<<i)) {
-				cpu_set(i + 32*j, cpu_possible_map);
-				__cpu_number_map[i+32*j] = num_cpus;
-				__cpu_logical_map[num_cpus] = i+32*j;
-				++num_cpus;
-			}
+			num_cpus++;
 		}
 	}
-	phys_cpu_present_map	= cpu_possible_map;
-	cpu_present_map		= cpu_possible_map;
 
-	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
-	printk("Phys CPU present map: %lx, possible map %lx\n", 
-	       (unsigned long)phys_cpu_present_map.bits[0], 
-	       (unsigned long)cpu_possible_map.bits[0]);
+	cpu_present_map = cpu_possible_map = fdt_cpumask;
+
+	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
+	printk("Possible/Present/FDT CPU map %s\n", buf);
 
-	printk("Detected %i Slave CPU(s)\n", num_cpus);
+	printk("Detected %d Slave CPU(s)\n", num_cpus);
 }
 
+#ifdef CONFIG_XEN
+extern int xen_enable_cpus(int node, uint32_t onlinemask);
+#define hw_enable_cpus xen_enable_cpus
+#else
+#define hw_enable_cpus enable_cpus
+#endif
+
 int wakeup_secondary_cpus(void)
 {
-	int i;
-	for(i = 0; i < 4; i++)
-	{
-		if(smp_node.onlinemask[i] == 0)
+	cpumask_t mask32;
+	int node;
+
+	cpumask_clear(&mask32);
+	uint32_to_cpumask(&mask32, 0xffffffff);
+
+	for (node = 0; node < 4; node++) {
+		cpumask_t tmpmask, nodemask;
+		unsigned int onlinemask;
+
+		cpumask_clear(&tmpmask);
+		cpumask_clear(&nodemask);
+
+		cpumask_shift_right(&nodemask, &fdt_cpumask, 32 * node);
+		cpumask_and(&tmpmask, &nodemask, &mask32);
+
+		if (cpumask_empty(&tmpmask))
 			continue;
-		enable_cpus( i, smp_node.onlinemask[i]);
-		printk("enable node %d  smp_node.onlinemask[%d]): %x\n", i,i, smp_node.onlinemask[i]);
+
+		onlinemask = cpumask_to_uint32(&tmpmask);
+		hw_enable_cpus(node, onlinemask);
+
+		printk("Enabled cpus (0x%08x) on node@%d\n", onlinemask, node);
 	}
+
 	return 0;
 }
 
@@ -215,8 +222,12 @@ void prom_boot_cpus_secondary(void *args)
 	int cpu = hard_smp_processor_id();
 
 	write_c0_ebase((uint32_t)nlm_common_ebase);
-	atomic_add((1<<cpu), (atomic_t *)&smp_boot.online_map);
-	for(;;) {
+
+	/* Announce that this cpu is available */
+	cpumask_test_and_set_cpu(cpu, &smp_boot.online_map);
+
+	/* Wait for master to signal */
+	for (;;) {
 		if (smp_boot.boot_info[cpu].ready) break;
 	}
 	__sync();
@@ -226,6 +237,7 @@ void prom_boot_cpus_secondary(void *args)
         setup_mapped_kernel_tlbs(TRUE, FALSE);
         setup_mapped_kernel_tlbs(FALSE, FALSE);
 
-	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp, 
+	/* Entry into the kernel (smp_bootstrap) */
+	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp,
 		     smp_boot.boot_info[cpu].gp);
 }
diff --git a/arch/mips/netlogic/xlp/xenbootinfo.c b/arch/mips/netlogic/xlp/xenbootinfo.c
index fedfe23..f5fda4e 100644
--- a/arch/mips/netlogic/xlp/xenbootinfo.c
+++ b/arch/mips/netlogic/xlp/xenbootinfo.c
@@ -5,7 +5,6 @@
 
 #include <asm/page.h>
 #include <asm/bootinfo.h>
-#include <asm/netlogic/sim.h>
 #include <asm/netlogic/bootinfo.h>
 #include <xen/interface/xen.h>
 #include <xen/interface/domctl.h>
@@ -13,6 +12,7 @@
 #include <asm/xen/hypercall.h>
 
 #include <asm/netlogic/debug.h>
+#include <asm/netlogic/xlp.h>
 
 extern char _end[];
 extern unsigned int onlinemask;
@@ -75,8 +75,12 @@ static int xc_wakeup_secondary(int dom_id, unsigned long cpumask, unsigned long
 	return 0;
 }
 
-int wakeup_secondary_cpus(void)
+int xen_enable_cpus(int node, uint32_t onlinemask)
 {
-	return xc_wakeup_secondary(0, onlinemask, 
-		       (unsigned long)secondary_cpus_bootup_func);
+	if (node) {
+		printk("XEN Multi-Node not available yet!\n");
+		return;
+	}
+
+	return xc_wakeup_secondary(0, onlinemask, (unsigned long)secondary_cpus_bootup_func);
 }
-- 
1.7.0.4

