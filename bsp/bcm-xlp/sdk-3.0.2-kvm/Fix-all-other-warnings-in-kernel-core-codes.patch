From a8ceb7da58015ed2589bd01496d60a21027dd9e1 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Thu, 27 Nov 2014 20:53:54 -0500
Subject: [PATCH] Fix all other warnings in kernel core codes

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/block/compat_ioctl.c b/block/compat_ioctl.c
index 21ad686..b96031e 100644
--- a/block/compat_ioctl.c
+++ b/block/compat_ioctl.c
@@ -186,8 +186,8 @@ static int compat_blkpg_ioctl(struct block_device *bdev, fmode_t mode,
 		unsigned int cmd, struct compat_blkpg_ioctl_arg __user *ua32)
 {
 	struct blkpg_ioctl_arg __user *a = compat_alloc_user_space(sizeof(*a));
-	compat_caddr_t udata;
-	compat_int_t n;
+	compat_caddr_t udata = 0;
+	compat_int_t n = 0;
 	int err;
 
 	err = get_user(n, &ua32->op);
diff --git a/drivers/hwmon/max6653.c b/drivers/hwmon/max6653.c
index 248ff06..7f47bd4 100644
--- a/drivers/hwmon/max6653.c
+++ b/drivers/hwmon/max6653.c
@@ -342,7 +342,7 @@ exit_remove:
 
 static int max6653_init_client(struct i2c_client *client)
 {
-	u8 cfg2, cfg;
+	u8 cfg2;
 
 	/* Reset the chip */
 	max6653_write(client, MAX6653_REG_CFG2, MAX6653_CFG2_RESET);
@@ -352,7 +352,7 @@ static int max6653_init_client(struct i2c_client *client)
 	cfg2=max6653_read(client, MAX6653_REG_CFG2);
 	/* disable INT input function */
 	cfg2 &= ~(1<<4);
-	max6653_write(client, MAX6653_REG_CFG2, cfg);
+	max6653_write(client, MAX6653_REG_CFG2, cfg2);
 	max6653_write(client, MAX6653_REG_REMTMP_OFF,0x80);
 	return 0;
 }
@@ -378,7 +378,6 @@ static int max6653_write(struct i2c_client *client, u8 reg, u8 value)
 
 static struct max6653_data *max6653_update_device(struct device *dev)
 {
-	int i;
 	struct i2c_client *client = to_i2c_client(dev);
 	struct max6653_data *data = i2c_get_clientdata(client);
 
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 2aa75fd..1ba3bcc 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -439,6 +439,7 @@ static void cfi_fixup_major_minor(struct cfi_private *cfi,
 	}
 }
 
+#ifdef CONFIG_MTD_XIP
 static int is_s29gl(struct cfi_private *cfi)
 {
 	if (cfi->mfr == CFI_MFR_AMD &&
@@ -448,6 +449,7 @@ static int is_s29gl(struct cfi_private *cfi)
 
 	return 0;
 }
+#endif
 
 static int is_m29ew(struct cfi_private *cfi)
 {
@@ -477,6 +479,7 @@ static void cfi_fixup_m29ew_erase_suspend(struct map_info *map,
 		map_write(map, CMD(0xF0), adr);
 }
 
+#ifdef CONFIG_MTD_XIP
 static void cfi_fixup_s29gl_delay_after_resume(struct cfi_private *cfi)
 {
 	/*
@@ -486,40 +489,7 @@ static void cfi_fixup_s29gl_delay_after_resume(struct cfi_private *cfi)
 	if (is_s29gl(cfi))
 		cfi_udelay(200);
 }
-
-/*
- * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 22:
- *
- * Some revisions of the M29EW (for example, A1 and A2 step revisions)
- * are affected by a problem that could cause a hang up when an ERASE SUSPEND
- * command is issued after an ERASE RESUME operation without waiting for a
- * minimum delay.  The result is that once the ERASE seems to be completed
- * (no bits are toggling), the contents of the Flash memory block on which
- * the erase was ongoing could be inconsistent with the expected values
- * (typically, the array value is stuck to the 0xC0, 0xC4, 0x80, or 0x84
- * values), causing a consequent failure of the ERASE operation.
- * The occurrence of this issue could be high, especially when file system
- * operations on the Flash are intensive.  As a result, it is recommended
- * that a patch be applied.  Intensive file system operations can cause many
- * calls to the garbage routine to free Flash space (also by erasing physical
- * Flash blocks) and as a result, many consecutive SUSPEND and RESUME
- * commands can occur.  The problem disappears when a delay is inserted after
- * the RESUME command by using the udelay() function available in Linux.
- * The DELAY value must be tuned based on the customer's platform.
- * The maximum value that fixes the problem in all cases is 500us.
- * But, in our experience, a delay of 30 µs to 50 µs is sufficient
- * in most cases.
- * We have chosen 500µs because this latency is acceptable.
- */
-static void cfi_fixup_m29ew_delay_after_resume(struct cfi_private *cfi)
-{
-	/*
-	 * Resolving the Delay After Resume Issue see Micron TN-13-07
-	 * Worst case delay must be 500µs but 30-50µs should be ok as well
-	 */
-	if (is_m29ew(cfi))
-		cfi_udelay(500);
-}
+#endif
 
 struct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)
 {
diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index 7d89a41..fb68f43 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -309,7 +309,7 @@ smsc911x_tx_writefifo_swab(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -333,7 +333,7 @@ smsc911x_tx_writefifo_swab(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 
@@ -409,7 +409,7 @@ smsc911x_rx_readfifo_swab(struct smsc911x_data *pdata, unsigned int *buf,
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&pdata->dev_lock, flags);
+	raw_spin_lock_irqsave(&pdata->dev_lock, flags);
 
 	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
 		while (wordcount--)
@@ -432,7 +432,7 @@ smsc911x_rx_readfifo_swab(struct smsc911x_data *pdata, unsigned int *buf,
 
 	BUG();
 out:
-	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+	raw_spin_unlock_irqrestore(&pdata->dev_lock, flags);
 }
 
 
diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c
index 148ffe4..6565ac5 100644
--- a/drivers/tty/serial/8250/8250_dma.c
+++ b/drivers/tty/serial/8250/8250_dma.c
@@ -25,7 +25,7 @@ static void __dma_tx_complete(void *param)
 	dma_sync_single_for_cpu(dma->txchan->device->dev, dma->tx_addr,
 				UART_XMIT_SIZE, DMA_TO_DEVICE);
 
-	spin_lock_irqsave(&p->port.lock, flags);
+	raw_spin_lock_irqsave(&p->port.lock, flags);
 
 	dma->tx_running = 0;
 
@@ -39,7 +39,7 @@ static void __dma_tx_complete(void *param)
 	if (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port))
 		serial8250_tx_dma(p);
 
-	spin_unlock_irqrestore(&p->port.lock, flags);
+	raw_spin_unlock_irqrestore(&p->port.lock, flags);
 }
 
 static void __dma_rx_complete(void *param)
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 9587f2b..58104b5 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -3513,7 +3513,9 @@ void xhci_free_dev(struct usb_hcd *hcd, struct usb_device *udev)
 {
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 	struct xhci_virt_device *virt_dev;
+#ifndef CONFIG_USB_DEFAULT_PERSIST
 	struct device *dev = hcd->self.controller;
+#endif
 	unsigned long flags;
 	u32 state;
 	int i, ret;
@@ -3599,7 +3601,9 @@ static int xhci_reserve_host_control_ep_resources(struct xhci_hcd *xhci)
 int xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev)
 {
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
+#ifndef CONFIG_USB_DEFAULT_PERSIST
 	struct device *dev = hcd->self.controller;
+#endif
 	unsigned long flags;
 	int timeleft;
 	int ret;
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 996cdc5..b4de588 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -174,8 +174,8 @@ static int do_video_stillpicture(unsigned int fd, unsigned int cmd,
 	struct compat_video_still_picture __user *up)
 {
 	struct video_still_picture __user *up_native;
-	compat_uptr_t fp;
-	int32_t size;
+	compat_uptr_t fp = 0;
+	int32_t size = 0;
 	int err;
 
 	err  = get_user(fp, &up->iFrame);
@@ -205,8 +205,8 @@ static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
 		struct compat_video_spu_palette __user *up)
 {
 	struct video_spu_palette __user *up_native;
-	compat_uptr_t palp;
-	int length, err;
+	compat_uptr_t palp = 0;
+	int length = 0, err;
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 4fafb84..1f8d639 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -2282,7 +2282,7 @@ static void fuse_register_polled_file(struct fuse_conn *fc,
 {
 	spin_lock(&fc->lock);
 	if (RB_EMPTY_NODE(&ff->polled_node)) {
-		struct rb_node **link, *parent;
+		struct rb_node **link, *parent = NULL;
 
 		link = fuse_find_polled_node(fc, ff->kh, &parent);
 		BUG_ON(*link);
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 3020751..7b506f7 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -3288,7 +3288,9 @@ void __sched schedule_preempt_disabled(void)
  */
 asmlinkage void __sched notrace preempt_schedule(void)
 {
+#ifdef CONFIG_PREEMPT_LAZY
 	struct thread_info *ti = current_thread_info();
+#endif
 
 	/*
 	 * If there is a non-zero preempt_count or interrupts are disabled,
diff --git a/kernel/signal.c b/kernel/signal.c
index 2f223e1..43c2f47 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -3487,7 +3487,7 @@ COMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,
 		return -EINVAL;
 
 	if (act) {
-		compat_uptr_t handler;
+		compat_uptr_t handler = 0;
 		ret = get_user(handler, &act->sa_handler);
 		new_ka.sa.sa_handler = compat_ptr(handler);
 #ifdef __ARCH_HAS_SA_RESTORER
-- 
1.9.1

