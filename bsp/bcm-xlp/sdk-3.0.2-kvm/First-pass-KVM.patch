From 138e369ae084c6f95419b36c18b23d0ff1580db3 Mon Sep 17 00:00:00 2001
From: Jayachandran C <jchandra@broadcom.com>
Date: Wed, 28 Aug 2013 12:45:31 +0530
Subject: [PATCH] First pass KVM

Commit 84b22e8b3b4f906594c761234f590eb572a2831e from Broadcom SDK 3.0.2

The kernel tree at this point already has most changes in this SDK
commit. This patch only contains the remaining changes after merging.

Signed-off-by: Jayachandran C <jchandra@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/asmmacro-64.h b/arch/mips/include/asm/asmmacro-64.h
index ad115d1..01c06de 100644
--- a/arch/mips/include/asm/asmmacro-64.h
+++ b/arch/mips/include/asm/asmmacro-64.h
@@ -315,7 +315,45 @@
 	or	k0, k0, k1
 	mtc0	k0, $10, 4
 	tlbinvf
+
+	/* workaround for tlbginvf */
+#if 0
+	/* flush guest tlbs with the guestctl1.rid */
 	tlbginvf
+#else
+	/* read guest config6 register, invalidate all guest tlb entries */
+	mfgc0	v0, $16, 6
+	srl	v0, 16
+	addiu	v0, 1
+	li	v1, 0
+99:
+	slt	k0, v1, v0
+	beqz	k0, 100f
+	nop
+
+	/* guest entryhi, unique for each entry */
+	lui	k0, 0x8000
+	sll	k1, v1, 17
+	daddu	k0, k1
+	dmtgc0  k0, $10, 0
+
+	/* use the root pagemask. */
+	mfc0	k0, $5, 0
+	dmtgc0  k0, $5, 0
+
+	dmtgc0  $0, $2, 0
+	dmtgc0  $0, $3, 0
+
+	/* guest index */
+	mtgc0   v1, $0, 0
+
+	tlbgwi
+
+	addiu	v1, 1
+	j	99b
+	nop
+100:
+#endif
 
 	/* wired entries */
 	LONG_L  k0, THREAD_VM_GUEST_WIRED(\thread)
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 4ec5ea2..da093ad 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -233,6 +233,12 @@ static void __show_regs(const struct pt_regs *regs)
 	unsigned int cause = regs->cp0_cause;
 	int i;
 
+#ifdef CONFIG_KVM
+	if (regs->cp0_guestctl0 >> 31)
+		printk("Exception in KVM: due to guest ...\n");
+	else
+		printk("Exception in KVM: due to root ...\n");
+#endif
 	show_regs_print_info(KERN_DEFAULT);
 
 	/*
@@ -262,11 +268,21 @@ static void __show_regs(const struct pt_regs *regs)
 	/*
 	 * Saved cp0 registers
 	 */
+#ifdef CONFIG_KVM
+	if (regs->cp0_guestctl0 >> 31) {
+		printk("epc   : %0*lx\n", field, regs->cp0_epc);
+		printk("    %s\n", print_tainted());
+		printk("ra    : %0*lx\n", field, regs->regs[31]);
+	} else {
+#endif
 	printk("epc   : %0*lx %pS\n", field, regs->cp0_epc,
 	       (void *) regs->cp0_epc);
 	printk("    %s\n", print_tainted());
 	printk("ra    : %0*lx %pS\n", field, regs->regs[31],
 	       (void *) regs->regs[31]);
+#ifdef CONFIG_KVM
+	}
+#endif
 
 	printk("Status: %08x	", (uint32_t) regs->cp0_status);
 
@@ -328,6 +344,15 @@ static void __show_regs(const struct pt_regs *regs)
 
 	printk("PrId  : %08x (%s)\n", read_c0_prid(),
 	       cpu_name_string());
+
+#ifdef CONFIG_KVM
+	if (regs->cp0_guestctl0 >> 31) {
+		printk("Badinstr  : %08x\n", (uint32_t)regs->cp0_badinstr);
+		printk("Badinstrp : %08x\n", (uint32_t)regs->cp0_badinstrp);
+		printk("GuestCtl0 : %08x\n", (uint32_t)regs->cp0_guestctl0);
+		printk("GuestCtl1 : %08x\n", (uint32_t)regs->cp0_guestctl1);
+	}
+#endif
 }
 
 /*
@@ -355,9 +380,17 @@ void show_registers(struct pt_regs *regs)
 			printk("*HwTLS: %0*lx\n", field, tls);
 	}
 
+#ifdef CONFIG_KVM
+	if (!(regs->cp0_guestctl0 >> 31)) {
+		show_stacktrace(current, regs);
+		show_code((unsigned int __user *) regs->cp0_epc);
+		printk("\n");
+	}
+#else
 	show_stacktrace(current, regs);
 	show_code((unsigned int __user *) regs->cp0_epc);
 	printk("\n");
+#endif
 }
 
 static int regs_to_trapnr(struct pt_regs *regs)
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 0e3e3d2..a0917ad 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -48,6 +48,10 @@
 
 #include "8250.h"
 
+#ifdef CONFIG_CPU_XLP
+#include <asm/netlogic/kvm_para.h>
+#endif
+
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -1598,6 +1602,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 	do {
 		struct uart_8250_port *up;
 		struct uart_port *port;
+		int pass_limit;
 
 		up = list_entry(l, struct uart_8250_port, list);
 		port = &up->port;
@@ -1610,7 +1615,33 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 		l = l->next;
 
-		if (l == i->head && pass_counter++ > PASS_LIMIT) {
+#ifdef CONFIG_CPU_XLP
+		/* For guest OS, set pass limit a larger value.
+		 *
+		 * For bare-metal linux, during interrupt routine execution, uart interrupt
+		 * is masked out (eimr). Therefore, the loop is typically executed twice:
+		 * first to process the interrupt and the second to verify no new interrupts.
+		 * The interrupt will be re-generated by hardware once eimr mask is set again
+		 * in caller of this interrupt routine.
+		 *
+		 * For guest OS, eimr change will not trap to KVM. So KVM will not be able
+		 * to exactly inject the guest uart interrupt the way root does. So
+		 * an interrupt is generated by KVM for every transmitted character when
+		 * the char is transmitted. This will cause more looping here.
+		 *
+		 * If a large number of characters are transmitted by guest in a single
+		 * uart_start transaction, guest may bail out with the warning.
+		 *
+		 * Hence, setting the pass_limit to a larger value is the right choice
+		 * considering the amount of new serial interrupts generated in guest OS.
+		 */
+		if (is_nlm_guest_os)
+			pass_limit = PASS_LIMIT * 32;
+		else
+#endif
+			pass_limit = PASS_LIMIT;
+
+		if (l == i->head && pass_counter++ > pass_limit) {
 			/* If we hit this, we're dead. */
 			printk_ratelimited(KERN_ERR
 				"serial8250: too much work for irq%d\n", irq);
-- 
1.9.1

