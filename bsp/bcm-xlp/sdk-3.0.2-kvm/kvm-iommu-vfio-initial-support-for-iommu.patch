From cc558064678a1aac29ca0381acbdcc0bf76713a2 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Wed, 13 Nov 2013 10:10:26 -0800
Subject: [PATCH] kvm: iommu: vfio: initial support for iommu

Commit 950bfcb2e603a58533e92c306efdbb751b6101c5 from Broadcom SDK 3.0.2

o iommu is a framework in linux to handle a device iommu configuration.
o Our current kvm port has kept the cpu-side translation inside kvm, not
  in iommu framework. The device-side translation as an outside module.
  This may need to be consolidated in the future.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/kvm/Makefile b/arch/mips/kvm/Makefile
index d9f55b9..59cd048 100644
--- a/arch/mips/kvm/Makefile
+++ b/arch/mips/kvm/Makefile
@@ -3,3 +3,4 @@
 common-objs = $(addprefix ../../../virt/kvm/, kvm_main.o)
 
 obj-$(CONFIG_KVM) += $(common-objs) kvm.o xlp.o context_switch.o
+obj-$(CONFIG_IOMMU_API) += kvm_iommu.o
diff --git a/arch/mips/kvm/kvm_iommu.c b/arch/mips/kvm/kvm_iommu.c
new file mode 100644
index 0000000..2e7384e
--- /dev/null
+++ b/arch/mips/kvm/kvm_iommu.c
@@ -0,0 +1,12 @@
+
+#include <linux/kvm_host.h>
+
+int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
+{
+	return 0;
+}
+
+void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
+{
+	return;
+}
diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig
index c332fb9..c6416a7 100644
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -261,4 +261,13 @@ config SHMOBILE_IOMMU_L1SIZE
 	default 256 if SHMOBILE_IOMMU_ADDRSIZE_64MB
 	default 128 if SHMOBILE_IOMMU_ADDRSIZE_32MB
 
+config XLP_IOMMU
+	bool "XLP IOMMU Support"
+	depends on CPU_XLP
+	select IOMMU_API
+	help
+	  Support for IOMMU of Broadcom XLP processor.
+
+	  If unsure, say N here.
+
 endif # IOMMU_SUPPORT
diff --git a/drivers/iommu/xlp-iommu.c b/drivers/iommu/xlp-iommu.c
new file mode 100644
index 0000000..2e496df
--- /dev/null
+++ b/drivers/iommu/xlp-iommu.c
@@ -0,0 +1,167 @@
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/iommu.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/memblock.h>
+#include <linux/export.h>
+#include <linux/pci.h>
+
+#include <asm/cacheflush.h>
+#include <asm/pgtable.h>
+
+/* bitmap of the page sizes currently supported */
+#define XLP_IOMMU_PGSIZES      (0xffff0000)
+
+static int xlp_iommu_probe(struct platform_device *pdev)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static struct platform_driver xlp_iommu_driver = {
+	.probe		= xlp_iommu_probe,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "xlp-iommu",
+	}
+};
+
+static int xlp_iommu_domain_init(struct iommu_domain *domain)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static void xlp_iommu_domain_destroy(struct iommu_domain *domain)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return;
+}
+
+static int xlp_iommu_attach_device(struct iommu_domain *domain,
+	struct device *dev)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static void xlp_iommu_detach_device(struct iommu_domain *domain,
+	struct device *dev)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return;
+}
+
+static int xlp_iommu_map(struct iommu_domain *domain, unsigned long iova,
+	phys_addr_t paddr, size_t size, int prot)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static size_t xlp_iommu_unmap(struct iommu_domain *domain,
+	unsigned long iova, size_t size)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static int xlp_iommu_domain_has_cap(struct iommu_domain *domain,
+	unsigned long cap)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static phys_addr_t xlp_iommu_iova_to_phys(struct iommu_domain *domain,
+                                          unsigned long iova)
+{
+	printk("%s is called (iova 0x%lx)...\n", __FUNCTION__, iova);
+	return 0;
+}
+
+static int xlp_iommu_add_device(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pci_dev *dma_pdev = NULL;
+	struct iommu_group *group;
+	int ret;
+
+	printk("%s is called ...\n", __FUNCTION__);
+
+	dma_pdev = pci_dev_get(pdev);
+	group = iommu_group_get(&dma_pdev->dev);
+	pci_dev_put(dma_pdev);
+	if (!group) {
+		group = iommu_group_alloc();
+		if (IS_ERR(group))
+			return PTR_ERR(group);
+	}
+
+	ret = iommu_group_add_device(group, dev);
+	iommu_group_put(group);
+	return ret;
+}
+
+static void xlp_iommu_remove_device(struct device *dev)
+{
+	iommu_group_remove_device(dev);
+}
+
+static struct iommu_ops xlp_iommu_ops = {
+        .domain_init = &xlp_iommu_domain_init,
+        .domain_destroy = &xlp_iommu_domain_destroy,
+        .attach_dev = &xlp_iommu_attach_device,
+        .detach_dev = &xlp_iommu_detach_device,
+        .map = &xlp_iommu_map,
+        .unmap = &xlp_iommu_unmap,
+        .iova_to_phys = &xlp_iommu_iova_to_phys,
+	.add_device = &xlp_iommu_add_device,
+	.remove_device = &xlp_iommu_remove_device,
+	.domain_has_cap = &xlp_iommu_domain_has_cap,
+        .pgsize_bitmap = XLP_IOMMU_PGSIZES,
+};
+
+static int device_notifier(struct notifier_block *nb, unsigned long action, void *data)
+{
+	printk("%s is called ...\n", __FUNCTION__);
+	return 0;
+}
+
+static struct notifier_block device_nb = {
+	.notifier_call = device_notifier,
+};
+
+static int __init xlp_iommu_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&xlp_iommu_driver);
+	if (ret == 0) {
+		bus_set_iommu(&pci_bus_type, &xlp_iommu_ops);
+		bus_register_notifier(&pci_bus_type, &device_nb);
+	}
+
+	return ret;
+}
+
+static void __exit xlp_iommu_exit(void)
+{
+	platform_driver_unregister(&xlp_iommu_driver);
+}
+
+module_init(xlp_iommu_init);
+module_exit(xlp_iommu_exit);
+
+MODULE_DESCRIPTION("IOMMU API in XLP II");
+MODULE_AUTHOR("Broadcom");
+MODULE_ALIAS("platform:xlp-iommu");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/vfio/Kconfig b/drivers/vfio/Kconfig
index 7cd5dec..c2d2cc6 100644
--- a/drivers/vfio/Kconfig
+++ b/drivers/vfio/Kconfig
@@ -7,6 +7,7 @@ menuconfig VFIO
 	tristate "VFIO Non-Privileged userspace driver framework"
 	depends on IOMMU_API
 	select VFIO_IOMMU_TYPE1 if X86
+	select VFIO_IOMMU_TYPE1 if CPU_XLP
 	help
 	  VFIO provides a framework for secure userspace device drivers.
 	  See Documentation/vfio.txt for more details.
diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c
index 6d78736..10ed3ae 100644
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@ -1409,12 +1409,17 @@ static int __init vfio_init(void)
 
 	pr_info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
 
+#if 0
+	/* Let user explicitly insert module vfio_iommu_type1.
+	 * The reason is that user may pass additional module argument.
+	 */
 	/*
 	 * Attempt to load known iommu-drivers.  This gives us a working
 	 * environment without the user needing to explicitly load iommu
 	 * drivers.
 	 */
 	request_module_nowait("vfio_iommu_type1");
+#endif
 
 	return 0;
 
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index dde9fe2..28b2a6e 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -735,7 +735,7 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id);
 /* For vcpu->arch.iommu_flags */
 #define KVM_IOMMU_CACHE_COHERENCY	0x1
 
-#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT
+#ifdef CONFIG_IOMMU_API
 int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot);
 void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot);
 int kvm_iommu_map_guest(struct kvm *kvm);
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 2b0bcb0..3561b8a 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -33,6 +33,7 @@ EXPORT_SYMBOL(contig_page_data);
 unsigned long max_low_pfn;
 unsigned long min_low_pfn;
 unsigned long max_pfn;
+EXPORT_SYMBOL(min_low_pfn); /* for build vfio related modules */
 
 bootmem_data_t bootmem_node_data[MAX_NUMNODES] __initdata;
 
-- 
1.9.1

