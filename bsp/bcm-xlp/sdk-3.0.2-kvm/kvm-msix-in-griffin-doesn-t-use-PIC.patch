From 774d9fd0f3846308b0301d053a8418975f2498e2 Mon Sep 17 00:00:00 2001
From: Ashok Kumar <ashoks@broadcom.com>
Date: Mon, 6 Jan 2014 15:50:48 +0530
Subject: [PATCH] kvm: msix in griffin doesn't use PIC

Commit 4012a00e84e0b74a54267bd32a844d4d545b20b4 from Broadcom SDK 3.0.2

o) converted MSIX IRT directly to CPU rvec as it doesn't
   use PIC. Ideally should get it from MSIX rvec programming.
   hacked it for now.
o) In SMP host, because of race interrupt could be lost.
   So pip_vector is cleared immediately after it is
   set in guest's eirr

Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/kvm/kvm_pic.c b/arch/mips/netlogic/kvm/kvm_pic.c
index f3abb2c..d4cba9e 100644
--- a/arch/mips/netlogic/kvm/kvm_pic.c
+++ b/arch/mips/netlogic/kvm/kvm_pic.c
@@ -56,6 +56,10 @@
 
 #include <asm/netlogic/kvm_xlp.h>
 #include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/haldefs.h>
+
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
 
 // #define DEBUG
 
@@ -87,11 +91,19 @@ void kvm_pic_inject_guest_ext(struct kvm *kvm, struct kvm_arch *arch, unsigned i
 	unsigned int rvec;
 	struct kvm_vcpu_arch *vcpu_arch;
 
-	/* FIXME: We should really look at irt_entry and deliver it to proper cpu
-	 * according to the schedule type.
-	 */
-	irt_entry = arch->pic.u.v64[(0x200 >> 1) + irt];
-	rvec = (irt_entry >> 24) & 0x3f;
+	/* FIXME: MSIX in 9XX doesn't use PIC and directly interrupts cpu
+	 * using rvec. hacked for now! */
+	if ((irt >= PIC_IRT_PCIE_MSIX_0_INDEX) &&
+		(irt <= (PIC_IRT_PCIE_MSIX_0_INDEX + 31))) {
+		rvec = (irt - PIC_IRT_PCIE_MSIX_0_INDEX) / 32 + PIC_PCIE_MSIX_IRQ_BASE;
+	}
+	else {
+		/* FIXME: We should really look at irt_entry and deliver it to proper cpu
+		 * according to the schedule type.
+		 */
+		irt_entry = arch->pic.u.v64[(0x200 >> 1) + irt];
+		rvec = (irt_entry >> 24) & 0x3f;
+	}
 	vcpu_arch = kvm_get_vcpu_arch_ext(kvm, cpuid);
 #ifdef DEBUG
 	printk("===== Inject IRT %u, RVEC %u to the guest (irt_entry %llx)\n", irt, rvec, irt_entry);
@@ -170,7 +182,10 @@ printk("Sending %s from cpuid %d to cpuid %d\n", (val & (1 << 23)) ? "NMI" : "IP
 #ifdef DEBUG
 		printk("===== ACK IRT %u RVEC %u from guest\n", irt, rvec);
 #endif
-		atomic_and_llong(&vcpu_arch->pip_vector, ~(1ULL << rvec));
+		/* No need to clear pip_vector as it is already 
+		 * cleared in RESTORE_GUEST. clearing here results in
+		 * interrupt loss in SMP scenario. check EPSW-1139 for more information */
+		//atomic_and_llong(&vcpu_arch->pip_vector, ~(1ULL << rvec));
 
 	} else if (rindex >= 0x74 && rindex <= 0x82) {
 		/* pic timer 0-7 max value */
-- 
1.9.1

