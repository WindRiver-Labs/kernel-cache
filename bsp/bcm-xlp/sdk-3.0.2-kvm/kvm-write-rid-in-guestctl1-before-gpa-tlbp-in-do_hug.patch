From 0c125acffa52174c92e418438a1f0c1da1cdedbe Mon Sep 17 00:00:00 2001
From: Ashok Kumar <ashoks@broadcom.com>
Date: Mon, 25 Nov 2013 18:38:46 +0530
Subject: [PATCH] kvm: write rid in guestctl1 before gpa tlbp in
 do_hugetlb_invalidate

Commit 64523838acb1e7afd1abfde39555aa189168a07d from Broadcom SDK 3.0.2

In do_hugetlb_invalidate, rid in guestctl1 should
be written before doing gpa tlbp. Also nlm_kvm_populate_page
should populate all the ptes of the hugepage in case of
huge page as build_is_huge_pte doesn't check both the ptes and
also to avoid the race between refill and load exception in SMP.

Signed-off-by: Ashok Kumar <ashoks@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index eec4e59..c3f379c 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -1244,6 +1244,14 @@ do {									\
 #define read_c0_brcm_sleepcount()	__read_32bit_c0_register($22, 7)
 #define write_c0_brcm_sleepcount(val)	__write_32bit_c0_register($22, 7, val)
 
+#ifdef CONFIG_KVM
+#define read_c0_guestctl0() __read_32bit_c0_register($12, 6)
+#define write_c0_guestctl0(val) __write_32bit_c0_register($12, 6, val)
+
+#define read_c0_guestctl1() __read_32bit_c0_register($10, 4)
+#define write_c0_guestctl1(val) __write_32bit_c0_register($10, 4, val)
+#endif
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index aef2b18..fdb3839 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -44,18 +44,34 @@ static void nlm_kvm_populate_page(struct pt_regs *regs, unsigned long address,
 {
 	pgd_t		*pgdp;
 	pud_t		*pudp;
-        pmd_t		*pmdp;
-        pte_t		*ptep, pte;
-        struct kvm_vcpu	*vcpu;
-        unsigned long	*ptr;
-        int		i;
-
+	pmd_t		*pmdp;
+	pte_t		*ptep, pte;
+	struct kvm_vcpu	*vcpu;
+	unsigned long	*ptr;
+	int		i;
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	int pg = 0, nr_pg = 1, is_huge_page= 0;
+
+	for (pg = 0;pg < nr_pg;) {
+#endif
 	pgdp = current->mm->pgd + __pgd_offset(address);
 	pudp = pud_offset(pgdp, address);
 	pmdp = pmd_offset(pudp, address);
 	ptep = pte_offset(pmdp, address);
 	pte = *ptep;
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	/* populate the other odd-even pair */
+	if (!is_huge_page && pte_huge(pte))
+	{
+		is_huge_page = 1;
+		nr_pg = HPAGE_SIZE / PAGE_SIZE;
+		address &= HPAGE_MASK;
+		gpa_address &= HPAGE_MASK;
+		continue;
+	}
+#endif
+
 	vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
 	pgdp = (pgd_t *)vcpu->arch.gpa_pgd + __pgd_offset(gpa_address);
 	pudp = (pud_t *)pgdp;
@@ -89,6 +105,14 @@ static void nlm_kvm_populate_page(struct pt_regs *regs, unsigned long address,
 	*page_size = PAGE_SIZE;
 	*ptep = pte;
 	*pa_address = (pte_val(pte) >> (_PAGE_GLOBAL_SHIFT + 6)) << 12;
+
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	pg++;
+	address += PAGE_SIZE;
+	gpa_address += PAGE_SIZE;
+	}
+#endif
+
 }
 #endif
 
@@ -278,7 +302,7 @@ good_area:
 
 #ifdef CONFIG_KVM
 	if (regs->cp0_guestctl0 >> 31) {
-		unsigned long pa_address, page_size;
+		unsigned long pa_address = 0, page_size;
 
 		/* Populate the gpa->pa page table. */
 		nlm_kvm_populate_page(regs, address, gpa_address, &pa_address, &page_size);
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 7543efd..dd0df06 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -387,15 +387,29 @@ void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 }
 
 #if defined(CONFIG_CPU_XLP) && defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
-asmlinkage void do_hugetlb_invalidate(void)
+asmlinkage void do_hugetlb_invalidate(__attribute__((unused)) struct pt_regs *regs)
 {
 	int idx;
 	uint64_t oldpid;
+#ifdef CONFIG_KVM
+	uint32_t oldgctl1 = 0x0;
+
+	if (regs->cp0_guestctl0 >> 31)
+	{
+		oldgctl1 = read_c0_guestctl1();
+		write_c0_guestctl1(regs->cp0_guestctl1);
+	}
+#endif
 
 	oldpid = read_c0_entryhi();
 	tlb_probe();
 	tlb_probe_hazard();
 	idx = read_c0_index();
+#ifdef CONFIG_KVM
+	if (regs->cp0_guestctl0 >> 31)
+		write_c0_guestctl1(oldgctl1);
+#endif
+
 	if (idx > 0) {
 		int ridx = idx & 0x1fff;
 
@@ -403,7 +417,7 @@ asmlinkage void do_hugetlb_invalidate(void)
 			/* Make sure all entries differ. */
 			write_c0_entrylo0(0);
 			write_c0_entrylo1(0);
-			write_c0_entryhi(UNIQUE_ENTRYHI(idx & 0x1fff));
+			write_c0_entryhi(UNIQUE_ENTRYHI(ridx));
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 			tlbw_use_hazard();
diff --git a/arch/mips/mm/tlbex-fault.S b/arch/mips/mm/tlbex-fault.S
index c00e405..c2885c7 100644
--- a/arch/mips/mm/tlbex-fault.S
+++ b/arch/mips/mm/tlbex-fault.S
@@ -15,6 +15,7 @@
 	SAVE_ALL
 
 #if defined(CONFIG_CPU_XLP) && defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
+	move	a0, sp
 	/* invalidate the tlb entry */
 	jal	do_hugetlb_invalidate
 	nop
-- 
1.9.1

