From 49dde69c698f68ba6aae1a5ce8a4dd2176ce8a9a Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Thu, 27 Nov 2014 20:47:57 -0500
Subject: [PATCH] bcm-xlp: fix build warnings.

Fix all build warnings introduced by original SDK patches.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 160044a..c56a20c 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -1173,7 +1173,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 	const int q_ram_pages = 1;
 	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
 	const uint32_t q_ram_page_entries_9xx = 64; /* entries, not bytes */
-	int cnt =0, oq_num32pages = 0, oq_num32pages_stn , num_valid_queues;
+	int cnt =0, oq_num32pages = 0, oq_num32pages_stn , num_valid_queues = 0;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
 	int single_sae_vc = 0;
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index afbdd21..1222d3d 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -387,7 +387,7 @@ static int prepare_nae_shared_info(void *fdt, int domid, nae_t *nae_cfg)
 {
         char dom_node_str[128];
         int nodeoffset;
-        unsigned int *pval, mask = 0x0;
+        unsigned int *pval = NULL, mask = 0x0;
         int plen, i, j;
         struct nlm_nae_shinfo shinfo;
         static int shdomains[NLM_NAE_MAX_SHARED_DOMS], shdom_extracted = 0;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 3c0528a..4f70061 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -3959,7 +3959,7 @@ int __netsoc_pcs_init(nae_t *nae)
 static int __netsoc_config_freein_fifo(nae_t *nae)
 {
         uint32_t reg, size, spillsz;
-        int start = 0, i,  th_hi, th_lo, minsz;
+        int start = 0, i,  th_hi, th_lo, minsz = 0;
         uint64_t spill_addr, spill_mem_addr, spill_mem_size;
         int freein_fifo_total_queues = nae->frin_total_queue;
         void *buf;
@@ -4243,7 +4243,7 @@ extern void __netsoc_bkpl_auneg_complete(nae_t *nae, uint32_t block, uint32_t la
 //extern void enable_autoneg(nae_t* nae);
 int __netsoc_init_nae(nae_t *nae)
 {
-	uint64_t bar0;
+	uint64_t bar0 = 0;
 	uint32_t tx_config, rx_config;
         int retval = 0, frin_q;
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c b/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
index 1d8970b..65bce2b 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_parser.c
@@ -119,7 +119,7 @@ int __netsoc_config_enable_flow_table(nae_t *nae, parser_config_t *cfg_parser)
 	uint32_t val;
 	int port = 0;
 	int l2proto = 1;
-	uint32_t dest_vc, max_vc;
+	uint32_t dest_vc = 0, max_vc;
 	int i = 0, cpu = 0, shift = 0;
 	int word_num;
 
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index fa34565..bb86c30 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -211,7 +211,7 @@ int xlp_socdev_to_node(const struct pci_dev *lnkdev)
 
 int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
-	struct pci_dev *lnkdev;
+	const struct pci_dev *lnkdev;
 	int lnkfunc, node;
 
 	/*
@@ -343,7 +343,7 @@ int xlp_fixup_numa_node(struct device *dev)
 #endif
 #ifdef PCIE_HOT_RESET_ENABLE
 
-static void modify_def_value()
+static void modify_def_value(void)
 {
 	uint64_t sysbase = nlm_get_sys_regbase(0);
 	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
@@ -389,7 +389,7 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 
 	if(pciint & 0x1)
 	{
-		if((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21) != 0)
+		if(((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0)
 		{
 			pr_info("Transaction Pending \n");
 			pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
@@ -399,7 +399,7 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
 		nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1 << 3));
 
-		while((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21) != 0)
+		while(((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21)) != 0)
 		{
 			//udelay(200);
 		}
diff --git a/drivers/netlogic/dtre/nlm_adma.c b/drivers/netlogic/dtre/nlm_adma.c
index 4de75ce..da2c5bd 100644
--- a/drivers/netlogic/dtre/nlm_adma.c
+++ b/drivers/netlogic/dtre/nlm_adma.c
@@ -358,7 +358,7 @@ static void __process_completed_tx(struct nlm_adma_chan * chan)
 
 static void dtre_send_message(int vc_id, int msgtype, uint64_t * msg)
 {
-	uint64_t pop_data[4];
+	uint64_t pop_data[2];
 	uint32_t pop_vc, pop_src, pop_size, pop_code;
 	uint32_t freeback_msg_dest_id, msgstatus1;
 	int rc, i;
@@ -381,7 +381,8 @@ static void dtre_send_message(int vc_id, int msgtype, uint64_t * msg)
 		{
 			if (nlm_dtre_debug)
 				printk("POP msg found in vc.\n");
-			nlm_dtre_msgring_handler(pop_vc, pop_src, pop_size, pop_code, pop_data[0], pop_data[1], pop_data[2], pop_data[3], NULL);
+			/* Passing 0 to the arguments because they are not used */
+			nlm_dtre_msgring_handler(pop_vc, pop_src, pop_size, pop_code, pop_data[0], pop_data[1], 0, 0, NULL);
 		}
 
 		if ((i%100) == 0) {
diff --git a/drivers/netlogic/nlm_cde/nlm_cde.c b/drivers/netlogic/nlm_cde/nlm_cde.c
index a7f294d..5ebd6bf 100644
--- a/drivers/netlogic/nlm_cde/nlm_cde.c
+++ b/drivers/netlogic/nlm_cde/nlm_cde.c
@@ -117,11 +117,6 @@ static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg
 	}
 	printk("\n");
 }
-#else
-static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
-{
-
-}
 #endif
 
 static void *
@@ -584,7 +579,7 @@ void return_free_descriptors(msg *msg_list, int msg_index)
 
 static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
 {
-	uint64_t i,j,num_bytes;
+	uint64_t i,num_bytes;
 	int offset = 0;
 	uint64_t *desc, dest_addr;
 	int num_desc = (payload >> 40) & 0x1fff;
@@ -1015,7 +1010,7 @@ static long xlp_cde_ioctl(struct file *filp,
 	printk("cde.compression_type = %d cde.sof = %d, cde.eof = %d\n",cde->compression_type, cde->sof, cde->eof);
 #endif
 	if(sanity_test)
-		cde = (struct nlmcde*)arg;
+		cde = (struct nlm_cde_op*)arg;
 
 	cmp_data->compression_type = cde->compression_type;
 	cmp_data->sof = cde->sof;
@@ -1073,7 +1068,9 @@ static void test()
 	{
 		input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
 	}
+#if CDE_DEBUG
 	//dump_buffer(input_mem, input_size, "input:");
+#endif
 	size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
 	printk("written %d byte of data\n", size);
 	size = 0;
@@ -1082,7 +1079,9 @@ static void test()
 		i++;
 	}while(size == 0 && i < 0xffffff);
 	printk("Read %d byte of data\n", size);
+#if CDE_DEBUG
 	//dump_buffer(output_mem, size, "output:");
+#endif
 
 }
 #endif
@@ -1091,7 +1090,6 @@ void xlp_cde_dev_initialize(void)
 	int i =0;
 	unsigned int ret;
 	int frequency = 0;
-	int node = 0;
 
 	for(i = 0; i < num_cde_engine; i++)
 	{
diff --git a/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c
index bc018b6..b6aba59 100644
--- a/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c
+++ b/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -14,7 +14,7 @@
 #define MAX_NODES 	8
 #define MB(x) 		(x*1024*1024)
 #define PKTMEM_MAJOR 	123
-static DEFINE_SPINLOCK(ioctl_lock);
+static DEFINE_RAW_SPINLOCK(ioctl_lock);
 static DEFINE_SPINLOCK(cache_lock);
 
 #define cache_op(op,addr)                                               \
@@ -194,6 +194,7 @@ static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
 {
 	
 	int rc;
+	uint64_t paddr = dp;
 	brcm_devmem_ioctl_t *dptr, data;
 	
 #ifdef PKTMEM_DEBUG
@@ -203,7 +204,6 @@ static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
 	if(cmd == CACHE_FLUSH) 
 	{
 		spin_lock(&cache_lock);
-		uint64_t paddr = dp;
 		cache_op(Hit_Writeback_Inv_D,paddr);
 		cache_op(Hit_Writeback_Inv_D,paddr+32);
 		udelay(30);
@@ -216,7 +216,7 @@ static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
 	dptr = &data;
 	rc = 0;
 
-	copy_from_user(dptr, dp, sizeof(brcm_devmem_ioctl_t));
+	copy_from_user(dptr, (const void __user *)dp, sizeof(brcm_devmem_ioctl_t));
 
 #ifdef PKTMEM_DEBUG
 	printk("pktmem: memory map before\n");
@@ -245,7 +245,7 @@ static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
 	printk("pktmem: ioctl returns rc %d.\n", rc);
 #endif
 
-	copy_to_user(dp, dptr, sizeof(brcm_devmem_ioctl_t));
+	copy_to_user((void __user *)dp, dptr, sizeof(brcm_devmem_ioctl_t));
 
 	raw_spin_unlock(&ioctl_lock);
 	return rc;
diff --git a/drivers/netlogic/sae/nlm_enc.c b/drivers/netlogic/sae/nlm_enc.c
index 442ee6d..ac1d526 100644
--- a/drivers/netlogic/sae/nlm_enc.c
+++ b/drivers/netlogic/sae/nlm_enc.c
@@ -82,7 +82,6 @@ xlp_setkey(struct crypto_ablkcipher *tfm, uint16_t stat)
 	struct nlm_enc_ctx *nlm_ctx = nlm_crypto_ablkcipher_ctx(tfm); 
 	int nsdescs = saesoc_calc_sdesc_cnt(&nlm_ctx->initp,NULL);
 	struct saesoc_session_desc *s_desc = &nlm_ctx->enc_s_desc;
-        struct saesoc_session_init_params *initp = &nlm_ctx->initp;
 
 	nlm_ctx->stat = stat;
 
diff --git a/drivers/netlogic/soc_interface/on_chip.c b/drivers/netlogic/soc_interface/on_chip.c
index 9c55d40..cf33554 100644
--- a/drivers/netlogic/soc_interface/on_chip.c
+++ b/drivers/netlogic/soc_interface/on_chip.c
@@ -716,7 +716,7 @@ struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
 };
 
 
-int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(int vc, int budget))
+int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(void *arg, int vc, int budget))
 {
 	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
 		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
@@ -1442,8 +1442,7 @@ static long fmn_config(void *arg)
 
 static int __init nlm_fmn_init(void)
 {
-        int node, rv;
-	int node_exist[8] = {1, 0, 0, 0, 0, 0, 0, 0};
+	int node;
 	int max_nodes = NLM_MAX_NODES;
 	uint32_t fmn_owner_mask = 0;
 
-- 
1.9.1

