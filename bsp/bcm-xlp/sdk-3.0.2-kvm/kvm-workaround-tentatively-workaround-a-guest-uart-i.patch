From b9e5426678b223b0b7730221e480d1133fafc648 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 16 Jul 2013 12:08:47 -0700
Subject: [PATCH] kvm: workaround: tentatively workaround a guest uart issue

Commit 865455fbbf6225be756babe059e8829613012032 from Broadcom SDK 3.0.2

o A burst of guest uart output may cause root uart output incorrectly.
  However, switching the console to qemu and then to guest indicates
  that guest uart output (through kvm/qemu) seems fine.
o The reason is not known yet, add some delay during guest char xmit
  emulation seems resolving the issue for now.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 108f367..9b1e6b1 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -412,7 +412,10 @@ void kvm_uart_insert_char(struct kvm *kvm, char c)
 
 	/* We want to inject the char back to the guest, generate an interrupt */
 	arch->uart.lsr  |= 0x1;
-	arch->uart.iir  = (0x2 << 1) | 0x00;
+	if (arch->uart.iir & 0x1)
+		arch->uart.iir  = (0x2 << 1) | 0x00;
+	else
+		arch->uart.iir  = arch->uart.iir | (0x2 << 1);
 	kvm_pic_inject_guest_ext(kvm, arch, arch->uart.header[0x3d] & 0xffff, 0);
 }
 
diff --git a/arch/mips/netlogic/kvm/kvm_uart.c b/arch/mips/netlogic/kvm/kvm_uart.c
index b70359b..7f31997 100644
--- a/arch/mips/netlogic/kvm/kvm_uart.c
+++ b/arch/mips/netlogic/kvm/kvm_uart.c
@@ -53,6 +53,7 @@
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
+#include <asm/delay.h>
 
 #include <asm/netlogic/kvm_xlp.h>
 
@@ -83,14 +84,42 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 				uint32_t val, badinstr, epc_badinstr;
 
 				if (arch->uart.ier & 0x2) {
-					arch->uart.iir = 0x2;
+					if (arch->uart.iir & 0x1)
+						arch->uart.iir = 0x2;
+					else
+						arch->uart.iir = arch->uart.iir | 0x2;
 
-					/* populate an interrupt to guest */
+					/* For every transmit char, we always generate an interrupt
+					 * for guest to look at the buffer again. This will generate
+					 * one more interrupt than in an actual system:
+					 *  . for the last transmied char, root may simply
+					 *    turned off uart tx interrupt. However, we may still
+					 *    generate this interrupt and guest needs to go through
+					 *    interrupt routine one more time.
+					 *
+					 *    Checked the uart interrupt code. It looks guest OS is
+					 *    able to handle this extra interrupt properly.
+					 */
 					kvm_pic_inject_guest(arch,
 						arch->uart.header[0x3d] & 0xffff,
 						regs);
 				}
 
+#if 1
+				/* Huge amount of guest output in a short period of time
+				 * may cause guest uart function incorrectly.
+				 * The below can reproduce the issue:
+				 *    while true; do cat /proc/cpuinfo; done
+				 * If the console switched to qemu and then back to guest, the
+				 * output will be good for a while before it turns bad again.
+				 * The qemu can still break in and kill the guest.
+				 *
+				 * FIXME: it looks like the below workaround fixed the issue.
+				 * But the root cause is unknown at this point.
+				 */
+				udelay(100);
+#endif
+
 				/* Quit the guest and go to QEMU for real print */
 				val = (KVM_EXIT_CHAR_PRINT << 24) | c;
 				kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
-- 
1.9.1

