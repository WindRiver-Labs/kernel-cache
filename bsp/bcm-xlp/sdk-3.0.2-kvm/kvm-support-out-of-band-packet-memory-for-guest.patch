From 07978cdca8c4fcae9c45f29fbac39dc156ef63d1 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 25 Jun 2013 13:30:34 -0700
Subject: [PATCH] kvm: support out-of-band packet memory for guest

Commit c214eaf8e301b242de09fd2e4abd3044e457dc6e from Broadcom SDK 3.0.2

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm.h b/arch/mips/include/asm/kvm.h
index 40702c7..d94170f 100644
--- a/arch/mips/include/asm/kvm.h
+++ b/arch/mips/include/asm/kvm.h
@@ -10,11 +10,18 @@ struct kvm_guest_info {
 	uint32_t	guest_id;
 };
 
+struct kvm_pktmem_info {
+	uint64_t	gpa_start;
+	uint64_t	rpa_start;
+	uint64_t	size;
+};
+
 #define KVM_MIPS_GUEST_INPUT      _IOW(KVMIO,  0xa0, struct kvm_guest_input)
 #define KVM_MIPS_EXIT_REQUEST	  _IOW(KVMIO,  0xa1, int)
 #define KVM_MIPS_INFO_REQUEST     _IOW(KVMIO,  0xa2, struct kvm_guest_info)
 #define KVM_MIPS_SYNC_GPA_MAP	  _IOW(KVMIO,  0xa3, int)
 #define KVM_MIPS_HUGEPAGE_SIZE	  _IOW(KVMIO,  0xa4, unsigned long long)
+#define KVM_MIPS_ADD_PKTMEM	  _IOW(KVMIO,  0xa5, struct kvm_pktmem_info)
 
 /* Used to capture a guest state */
 struct kvm_regs {
diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 2dcbeec..e370cd8 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -32,6 +32,11 @@ struct kvm_arch {
 	unsigned int	exit_request;
 	unsigned long long gpa_pgd;
 	struct {
+		unsigned long long gpa_start;
+		unsigned long long rpa_start;
+		unsigned long long size;
+	} pktmem;
+	struct {
 		union {
 			unsigned int v32[MAX_XLP_PIC_REG_NUM];
 			unsigned long long v64[MAX_XLP_PIC_REG_NUM/2];
diff --git a/arch/mips/kvm/kvm.c b/arch/mips/kvm/kvm.c
index e52655d..0c6832f 100644
--- a/arch/mips/kvm/kvm.c
+++ b/arch/mips/kvm/kvm.c
@@ -160,6 +160,63 @@ static void kvm_sync_gpa_map(struct kvm *kvm)
 		}
 	}
 
+	/* packet memory */
+	if (kvm->arch.pktmem.gpa_start != (-1)) {
+		uint64_t msize, gpa, address, pa;
+
+		msize = kvm->arch.pktmem.size;
+		gpa = kvm->arch.pktmem.gpa_start;
+		pa = kvm->arch.pktmem.rpa_start;
+
+		/* enumerate all hva pages */
+		for (address = gpa; address < (gpa + msize);) {
+			pgd_t *pgdp;
+			pud_t *pudp;
+#ifndef __PAGETABLE_PMD_FOLDED
+			pmd_t *pmdp;
+#endif
+			pte_t *ptep;
+			int i;
+			unsigned long *ptr;
+
+			/* map gpa to pte in page table pointed to by gpa_pgd */
+			pgdp = (pgd_t *)gpa_pgd + __pgd_offset(address);
+			pudp = (pud_t *)pgdp;
+#ifndef __PAGETABLE_PMD_FOLDED
+			if (*(unsigned long *)pudp == (unsigned long)invalid_pmd_table) {
+				/* allocate a page for pmd and initialize it */
+				ptr = (unsigned long *)__get_free_page(GFP_KERNEL|GFP_DMA);
+				for (i = 0; i < PTRS_PER_PMD; i++)
+					ptr[i] = (unsigned long)invalid_pte_table;
+				*(unsigned long *)pudp = (unsigned long)ptr;
+
+			}
+			pmdp = (pmd_t *)*(unsigned long *)pudp + __pmd_offset(address);
+			if (*(unsigned long *)pmdp == (unsigned long)invalid_pte_table) {
+				/* allocate a page for pmd and initialize it */
+				ptr = (unsigned long *)__get_free_page(GFP_KERNEL|GFP_DMA);
+				for (i = 0; i < PTRS_PER_PTE; i++)
+					ptr[i] = 0;
+				*(unsigned long *)pmdp = (unsigned long)ptr;
+			}
+			ptep = (pte_t *)*(unsigned long *)pmdp + __pte_offset(address);
+#else
+			if (*(unsigned long *)pudp == (unsigned long)invalid_pte_table) {
+				/* allocate a page for pmd and initialize it */
+				ptr = (unsigned long *)__get_free_page(GFP_KERNEL|GFP_DMA);
+				for (i = 0; i < PTRS_PER_PTE; i++)
+					ptr[i] = 0;
+				*(unsigned long *)pudp = (unsigned long)ptr;
+
+			}
+			ptep = (pte_t *)*(unsigned long *)pudp + __pte_offset(address);
+#endif
+			*ptep = __pte(((pa >> 12) << (_PAGE_GLOBAL_SHIFT + 6))| pgprot_val(PAGE_SHARED));
+
+			address += PAGE_SIZE, pa += PAGE_SIZE;
+		}
+	}
+
 	return;
 }
 
@@ -698,6 +755,24 @@ long kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)
 		}
 		break;
 	}
+	case KVM_MIPS_ADD_PKTMEM:
+	{
+		struct kvm_pktmem_info pktmem;
+
+		if (copy_from_user(&pktmem, argp, sizeof(struct kvm_pktmem_info))) {
+			r = -EFAULT;
+			break;
+		}
+		/* Only support one packet memory region */
+		if (kvm->arch.pktmem.gpa_start != (-1)) {
+			r = -EFAULT;
+			break;
+		}
+		kvm->arch.pktmem.gpa_start = pktmem.gpa_start;
+		kvm->arch.pktmem.rpa_start = pktmem.rpa_start;
+		kvm->arch.pktmem.size = pktmem.size;
+		break;
+	}
 	default:
 		r = -EINVAL;
 		break;
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index d99d3c7..2700353 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -342,6 +342,7 @@ void xlp_kvm_init_vm(struct kvm *kvm)
 	/* Assign a new Guest ID */
 	arch->guest_id = kvm_get_new_guest_id();
 	arch->exit_request = 0;
+	arch->pktmem.gpa_start = -1;
 
 	arch->gpa_pgd = (uint64_t)pgd_alloc(NULL);
 
-- 
1.9.1

