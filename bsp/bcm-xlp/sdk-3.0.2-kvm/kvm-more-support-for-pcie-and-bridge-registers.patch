From 3ec8e1b216952c5e1126597641745e913a47173a Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Thu, 25 Jul 2013 14:14:14 -0700
Subject: [PATCH] kvm: more support for pcie and bridge registers

Commit c845808516e64964cb289b663c495dca6ef7600a from Broadcom SDK 3.0.2

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 51467cf..5bcaea2 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -108,7 +108,11 @@ struct kvm_arch {
 	} bridge;
 	struct {
 		struct {
-			int32_t config0;
+			int32_t regs[0x40];
+			int32_t byteswapmembase;
+			int32_t byteswapmemlimit;
+			int32_t byteswapiobase;
+			int32_t byteswapiolimit;
 		} link[4];
 	} pcie;
 };
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index d74e90a..75abd73 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -388,7 +388,7 @@ static void xlp_kvm_init_pcie(struct kvm_arch *arch)
 
 	/* by default, no bus/device attached */
 	for (i = 0; i < 4; i++)
-		arch->pcie.link[i].config0 = 0xffffffff;
+		arch->pcie.link[i].regs[0x0]= 0xffffffff;
 }
 
 void xlp_kvm_init_vm(struct kvm *kvm)
diff --git a/arch/mips/netlogic/kvm/kvm_bridge.c b/arch/mips/netlogic/kvm/kvm_bridge.c
index 7941a18..38ee6e1 100644
--- a/arch/mips/netlogic/kvm/kvm_bridge.c
+++ b/arch/mips/netlogic/kvm/kvm_bridge.c
@@ -79,10 +79,29 @@ void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
 	}
 	else if (rindex == 0x99 || rindex == 0x9a || rindex == 0x9b
 		|| rindex == 0x9c) {
-		/* pcie link 0, 1, 2, 3 */
 		if (!write) {
-			regs->regs[reg_num] = (uint32_t)arch->bridge.pcie_membase[rindex - 0x99];
-// printk("!!! return value: 0x%lx\n", regs->regs[reg_num]);
+			regs->regs[reg_num] = arch->bridge.pcie_membase[rindex - 0x99];
+			return;
+		}
+	}
+	else if (rindex == 0x9d || rindex == 0x9e || rindex == 0x9f
+		|| rindex == 0xa0) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_memlimit[rindex - 0x9d];
+			return;
+		}
+	}
+	else if (rindex == 0xa1 || rindex == 0xa2 || rindex == 0xa3
+		|| rindex == 0xa4) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_iobase[rindex - 0xa1];
+			return;
+		}
+	}
+	else if (rindex == 0xa5 || rindex == 0xa6 || rindex == 0xa7
+		|| rindex == 0xa8) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_iolimit[rindex - 0xa5];
 			return;
 		}
 	}
diff --git a/arch/mips/netlogic/kvm/kvm_pcie.c b/arch/mips/netlogic/kvm/kvm_pcie.c
index 0fd40a1..6a14555 100644
--- a/arch/mips/netlogic/kvm/kvm_pcie.c
+++ b/arch/mips/netlogic/kvm/kvm_pcie.c
@@ -57,10 +57,10 @@
 #include <asm/netlogic/kvm_xlp.h>
 
 static inline void unhandled_exception(const char *func, unsigned long addr,
-	unsigned long epc, unsigned long write)
+	unsigned long epc, unsigned long write, int link)
 {
-	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
-		func, addr, epc, write);
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx, link %d\n",
+		func, addr, epc, write, link);
 }
 
 void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
@@ -71,12 +71,41 @@ void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
 
 // printk("=== kvm_handle_pcie_pcie: address = 0x%lx, link: %d\n", address, link);
 
-	if (rindex == 0x0) {
-		if (!write) {
-			regs->regs[reg_num] = arch->pcie.link[link].config0;
-			return;
-		}
+	if (rindex < 0x40) {
+		if (write)
+			arch->pcie.link[link].regs[rindex] = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pcie.link[link].regs[rindex];
+		return;
+	}
+	else if (rindex == 0x25c) {
+		if (write)
+			arch->pcie.link[link].byteswapmembase = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pcie.link[link].byteswapmembase;
+		return;
+	}
+	else if (rindex == 0x25d) {
+		if (write)
+			arch->pcie.link[link].byteswapmemlimit = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pcie.link[link].byteswapmemlimit;
+		return;
+	}
+	else if (rindex == 0x25e) {
+		if (write)
+			arch->pcie.link[link].byteswapiobase = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pcie.link[link].byteswapiobase;
+		return;
+	}
+	else if (rindex == 0x25f) {
+		if (write)
+			arch->pcie.link[link].byteswapiolimit = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pcie.link[link].byteswapiolimit;
+		return;
 	}
 
-	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write, link);
 }
-- 
1.9.1

