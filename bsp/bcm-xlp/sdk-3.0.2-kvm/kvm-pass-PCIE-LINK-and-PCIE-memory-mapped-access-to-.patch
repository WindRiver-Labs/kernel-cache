From 2b81f00da146f64aae7711795e055f150aac44ad Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 13 Aug 2013 10:52:10 -0700
Subject: [PATCH] kvm: pass PCIE LINK and PCIE memory mapped access to QEMU for
 handling

Commit afa897574943cc54039109eae2538bcf7fc493ee from Broadcom SDK 3.0.2

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 898e6e1..6cb4663 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -112,15 +112,6 @@ struct kvm_arch {
 		int32_t pcie_iobase[4];
 		int32_t pcie_iolimit[4];
 	} bridge;
-	struct {
-		struct {
-			int32_t regs[0x40];
-			int32_t byteswapmembase;
-			int32_t byteswapmemlimit;
-			int32_t byteswapiobase;
-			int32_t byteswapiolimit;
-		} link[4];
-	} pcie;
 };
 
 struct kvm_vcpu_guest {
@@ -149,6 +140,14 @@ struct kvm_vcpu_arch {
 	uint64_t host_vcpuid; /* corresponding host vcpu id, for fast guest IPI delivery */
 	uint64_t nmi;
 
+	struct {
+		int64_t  addr;
+		int64_t  val;
+		uint32_t is_write:1;
+		uint32_t reg_num:5;
+		uint32_t len;
+	} mmio;
+
 	/* vcpu state */
 	struct kvm_vcpu_guest	guest;
 	struct kvm_vcpu_root	root;
diff --git a/arch/mips/include/asm/netlogic/kvm_xlp.h b/arch/mips/include/asm/netlogic/kvm_xlp.h
index 968de42..d0b59a9 100644
--- a/arch/mips/include/asm/netlogic/kvm_xlp.h
+++ b/arch/mips/include/asm/netlogic/kvm_xlp.h
@@ -134,6 +134,7 @@ extern void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
 
 /* defined in arch/mips/netlogic/kvm/kvm_pcie.c */
 extern void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
-	unsigned long address, unsigned long reg_num, int link);
+	unsigned long address, unsigned long reg_num, uint32_t badinstr,
+	uint32_t epc_badinstr);
 
 #endif
diff --git a/arch/mips/kvm/kvm.c b/arch/mips/kvm/kvm.c
index a05b03d..84d1bb4 100644
--- a/arch/mips/kvm/kvm.c
+++ b/arch/mips/kvm/kvm.c
@@ -387,6 +387,17 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 	if (vcpu->sigset_active)
 		sigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);
 
+	if (vcpu->mmio_needed) {
+		/* complete mmio */
+		if (run->mmio.len == 1)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(unsigned char *)run->mmio.data;
+		else if (run->mmio.len == 4)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(int *)run->mmio.data;
+		else
+			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(long *)run->mmio.data;
+		vcpu->mmio_needed = 0;
+	}
+
 	if (vcpu->kvm->arch.exit_request == 0) {
 		local_irq_disable();
 		kvm_guest_enter();
@@ -428,6 +439,17 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		run->exit_reason = ret >> 24;
 		run->mips_output_char.c = ret & 0xff;
 		break;
+	case KVM_EXIT_MMIO:
+		/* mmio exit */
+		run->exit_reason = ret >> 24;
+		run->mmio.phys_addr = vcpu->arch.mmio.addr;
+		run->mmio.len = vcpu->arch.mmio.len;
+		memcpy(run->mmio.data, &vcpu->arch.mmio.val, 8);
+		run->mmio.is_write = vcpu->arch.mmio.is_write;
+		if (!run->mmio.is_write)
+			vcpu->mmio_needed = 1;
+
+		break;
 #if 0
 	case KVM_EXIT_IRQ_WINDOW_OPEN:
 		run->exit_reason = ret >> 24;
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 40b8e90..0ed8f70 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -384,15 +384,6 @@ static void xlp_kvm_init_bridge(struct kvm_arch *arch)
 	}
 }
 
-static void xlp_kvm_init_pcie(struct kvm_arch *arch)
-{
-	int i;
-
-	/* by default, no bus/device attached */
-	for (i = 0; i < 4; i++)
-		arch->pcie.link[i].regs[0x0]= 0xffffffff;
-}
-
 void xlp_kvm_init_vm(struct kvm *kvm)
 {
 	struct kvm_arch *arch = &kvm->arch;
@@ -409,7 +400,6 @@ void xlp_kvm_init_vm(struct kvm *kvm)
 	xlp_kvm_init_pic(arch);
 	xlp_kvm_init_sysmgt(arch);
 	xlp_kvm_init_bridge(arch);
-	xlp_kvm_init_pcie(arch);
 }
 
 void kvm_save_guest_context(struct pt_regs *regs, struct kvm_vcpu_guest *guest)
diff --git a/arch/mips/netlogic/kvm/kvm_fault.c b/arch/mips/netlogic/kvm/kvm_fault.c
index 59e3fe9..09ff27f 100644
--- a/arch/mips/netlogic/kvm/kvm_fault.c
+++ b/arch/mips/netlogic/kvm/kvm_fault.c
@@ -140,14 +140,15 @@ static void handle_pci_config_space(struct pt_regs *regs, unsigned long write,
 asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 				    unsigned long address)
 {
+	unsigned int reg_num = 0;
+	unsigned int badinstr, epc_badinstr;
+
 	/* check whether the fault is from guest. */
 	if ((regs->cp0_guestctl0 >> 31) == 0)
 		return 0;
 
 	if (address >= 0x18000000 && address < 0x1c000000) {
 		/* pcie register configuration space */
-		unsigned int badinstr, epc_badinstr;
-		unsigned int reg_num = 0;
 
 		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
 
@@ -174,19 +175,19 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 		}
 		else if ((address & 0xfffff000) == 0x18108000) {
 			/* pcie link 0: dev 1, func 0 */
-			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 0);
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
 		}
 		else if ((address & 0xfffff000) == 0x18109000) {
 			/* pcie link 1: dev 1, func 1 */
-			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 1);
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
 		}
 		else if ((address & 0xfffff000) == 0x1810a000) {
 			/* pcie link 2: dev 1, func 2 */
-			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 2);
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
 		}
 		else if ((address & 0xfffff000) == 0x1810b000) {
 			/* pcie link 3: dev 1, func 3 */
-			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 3);
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
 		}
 		else if ((address & 0xfffff000) == 0x18110000) {
 			/* pic: dev 2, func 0 */
@@ -204,7 +205,10 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 			/* fuse: dev 6, func 1 */
 			kvm_handle_pcie_fuse(regs, write, address & 0xfff, reg_num);
 		}
-		else {
+		else if (((address & 0xfff00000) != 0x18000000) && ((address & 0xfff00000) != 0x18100000)) {
+			/* not bus 0, bus 1, a real bridge */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		} else {
 			/* disable the device */
 			if (!write && (address & 0xfff) == 0)
 				regs->regs[reg_num] = 0xffffffff;
@@ -218,8 +222,6 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 		return 1;
 	} else if (address >= 0x1c000000 && address < 0x1d000000) {
 		/* pci register configuration space */
-		unsigned int badinstr, epc_badinstr;
-		unsigned int reg_num = 0;
 
 		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
 
@@ -239,16 +241,26 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 		compute_guest_return_epc(regs, epc_badinstr);
 
 		return 1;
-	} else if (address >= 0xc0000000ul && address < 0xc0100000ul) {
-		unsigned int badinstr, epc_badinstr;
-
-		printk("Caught one pcim address 0x%lx, epc 0x%lx\n", address, regs->cp0_epc);
+	} else if (address >= 0xd0000000ul && address < 0xe0000000ul) {
 
 		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
 
-		/* temporary ignore here */
-		printk("caught one guest pcim address: %lx, epc %lx\n",
-			address, regs->cp0_epc);
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0x80000000 /* lb */
+		    || (badinstr & 0xfc000000) == 0xa0000000 /* sb */
+		    || (badinstr & 0xfc000000) == 0x90000000 /* lbu */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+                else {
+			printk("%s: 0x%x, unhandled epc %lx, address %lx\n",
+				__FUNCTION__, badinstr, regs->cp0_epc, address);
+			return 0;
+                }
+
+                kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
 
 		compute_guest_return_epc(regs, epc_badinstr);
 
diff --git a/arch/mips/netlogic/kvm/kvm_pcie.c b/arch/mips/netlogic/kvm/kvm_pcie.c
index 6a14555..d7d13e0 100644
--- a/arch/mips/netlogic/kvm/kvm_pcie.c
+++ b/arch/mips/netlogic/kvm/kvm_pcie.c
@@ -56,56 +56,37 @@
 
 #include <asm/netlogic/kvm_xlp.h>
 
-static inline void unhandled_exception(const char *func, unsigned long addr,
-	unsigned long epc, unsigned long write, int link)
-{
-	printk("%s: unhandled address %lx, epc %lx, is_write %lx, link %d\n",
-		func, addr, epc, write, link);
-}
-
 void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
-		unsigned long address, unsigned long reg_num, int link)
+		unsigned long address, unsigned long reg_num, uint32_t badinstr,
+		uint32_t epc_badinstr)
 {
-	unsigned int rindex = address >> 2;
-	struct kvm_arch *arch = kvm_get_arch(regs);
+	uint32_t val;
+	struct kvm_vcpu *vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
+
+#if 0
+	printk("=== pcie: address 0x%lx, epc 0x%lx, write %ld\n",
+		address, regs->cp0_epc, write);
+#endif
+
+	val = KVM_EXIT_MMIO << 24;
+	vcpu->arch.mmio.addr = address;
+	vcpu->arch.mmio.is_write = write;
+	vcpu->arch.mmio.reg_num = reg_num;
 
-// printk("=== kvm_handle_pcie_pcie: address = 0x%lx, link: %d\n", address, link);
+	if ((badinstr & 0xfc000000) == 0x80000000
+	    || (badinstr & 0xfc000000) == 0x90000000
+	    || (badinstr & 0xfc000000) == 0xa0000000)
+		vcpu->arch.mmio.len = 1;
+	else if ((badinstr & 0xfc000000) == 0x8c000000
+	    || (badinstr & 0xfc000000) == 0xac000000)
+		vcpu->arch.mmio.len = 4;
+	else
+		vcpu->arch.mmio.len = 8;
 
-	if (rindex < 0x40) {
-		if (write)
-			arch->pcie.link[link].regs[rindex] = regs->regs[reg_num];
-		else
-			regs->regs[reg_num] = arch->pcie.link[link].regs[rindex];
-		return;
-	}
-	else if (rindex == 0x25c) {
-		if (write)
-			arch->pcie.link[link].byteswapmembase = regs->regs[reg_num];
-		else
-			regs->regs[reg_num] = arch->pcie.link[link].byteswapmembase;
-		return;
-	}
-	else if (rindex == 0x25d) {
-		if (write)
-			arch->pcie.link[link].byteswapmemlimit = regs->regs[reg_num];
-		else
-			regs->regs[reg_num] = arch->pcie.link[link].byteswapmemlimit;
-		return;
-	}
-	else if (rindex == 0x25e) {
-		if (write)
-			arch->pcie.link[link].byteswapiobase = regs->regs[reg_num];
-		else
-			regs->regs[reg_num] = arch->pcie.link[link].byteswapiobase;
-		return;
-	}
-	else if (rindex == 0x25f) {
-		if (write)
-			arch->pcie.link[link].byteswapiolimit = regs->regs[reg_num];
-		else
-			regs->regs[reg_num] = arch->pcie.link[link].byteswapiolimit;
-		return;
-	}
+	if (write)
+		vcpu->arch.mmio.val = regs->regs[reg_num];
 
-	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write, link);
+	compute_guest_return_epc(regs, epc_badinstr);
+	kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+	__kvm_vcpu_leave_guest(vcpu, val);
 }
-- 
1.9.1

