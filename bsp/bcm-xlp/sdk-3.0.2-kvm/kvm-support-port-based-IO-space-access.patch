From 0190fa3623f5e68003a9f8eedfae9801312e43cd Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 27 Aug 2013 09:35:06 -0700
Subject: [PATCH] kvm: support port-based IO space access

Commit aafe6290db38a2c69df40723e60517758b814ba6 from Broadcom SDK 3.0.2

o The IO request will be delivered to QEMU

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm.h b/arch/mips/include/asm/kvm.h
index fb23524..98adcc3 100644
--- a/arch/mips/include/asm/kvm.h
+++ b/arch/mips/include/asm/kvm.h
@@ -57,6 +57,7 @@ struct kvm_pktmem_info {
 #define KVM_MIPS_HUGEPAGE_SIZE	  _IOW(KVMIO,  0xa4, unsigned long long)
 #define KVM_MIPS_ADD_PKTMEM	  _IOW(KVMIO,  0xa5, struct kvm_pktmem_info)
 #define KVM_MIPS_SET_BINDING	  _IOW(KVMIO,  0xa6, int)
+#define KVM_MIPS_INJECT_PCIE_INTX _IOW(KVMIO,  0xa7, int)
 
 /* Used to capture a guest state */
 struct kvm_regs {
diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 6cb4663..79ee561 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -139,6 +139,7 @@ struct kvm_vcpu_arch {
 	uint64_t guest_vcpu_p[32]; /* guest vcpu pointer */
 	uint64_t host_vcpuid; /* corresponding host vcpu id, for fast guest IPI delivery */
 	uint64_t nmi;
+	uint64_t pio_needed;
 
 	struct {
 		int64_t  addr;
@@ -148,6 +149,16 @@ struct kvm_vcpu_arch {
 		uint32_t len;
 	} mmio;
 
+	struct {
+		uint8_t	 direction;
+		uint8_t	 size;
+		uint8_t  count;
+		uint8_t  reg_num;
+		uint16_t port;
+		uint16_t data_offset;
+		int64_t  val;
+	} pio;
+
 	/* vcpu state */
 	struct kvm_vcpu_guest	guest;
 	struct kvm_vcpu_root	root;
diff --git a/arch/mips/include/asm/netlogic/kvm_xlp.h b/arch/mips/include/asm/netlogic/kvm_xlp.h
index d0b59a9..4d3d442 100644
--- a/arch/mips/include/asm/netlogic/kvm_xlp.h
+++ b/arch/mips/include/asm/netlogic/kvm_xlp.h
@@ -136,5 +136,8 @@ extern void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
 extern void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num, uint32_t badinstr,
 	uint32_t epc_badinstr);
+extern void kvm_handle_pcie_io(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num, uint32_t badinstr,
+	uint32_t epc_badinstr);
 
 #endif
diff --git a/arch/mips/kvm/kvm.c b/arch/mips/kvm/kvm.c
index 3b710fd..10a5459 100644
--- a/arch/mips/kvm/kvm.c
+++ b/arch/mips/kvm/kvm.c
@@ -70,7 +70,14 @@
 
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/common.h>
 #include <asm/netlogic/kvm_xlp.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
 
 struct kvm_stats_debugfs_item debugfs_entries[] = {
 	{ NULL }
@@ -391,6 +398,8 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		/* complete mmio */
 		if (run->mmio.len == 1)
 			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(unsigned char *)run->mmio.data;
+		else if (run->mmio.len == 2)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(unsigned short *)run->mmio.data;
 		else if (run->mmio.len == 4)
 			vcpu->arch.guest.gpu.regs[vcpu->arch.mmio.reg_num] = *(int *)run->mmio.data;
 		else
@@ -398,6 +407,19 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		vcpu->mmio_needed = 0;
 	}
 
+	if (vcpu->arch.pio_needed) {
+		/* complete pio */
+		if (run->io.size == 1)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.pio.reg_num] = *(unsigned char *)run->mips_exit_io.data;
+		else if (run->io.size == 2)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.pio.reg_num] = *(unsigned short *)run->mips_exit_io.data;
+		else if (run->io.size == 4)
+			vcpu->arch.guest.gpu.regs[vcpu->arch.pio.reg_num] = *(int *)run->mips_exit_io.data;
+		else
+			vcpu->arch.guest.gpu.regs[vcpu->arch.pio.reg_num] = *(long *)run->mips_exit_io.data;
+		vcpu->arch.pio_needed = 0;
+	}
+
 	if (vcpu->kvm->arch.exit_request == 0) {
 		local_irq_disable();
 		kvm_guest_enter();
@@ -447,6 +469,8 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 
 		if (run->mmio.len == 1)
 			run->mmio.data[0] = (uint8_t)vcpu->arch.mmio.val;
+		else if (run->mmio.len == 2)
+			*(uint16_t *)run->mmio.data = (uint16_t)vcpu->arch.mmio.val;
 		else if (run->mmio.len == 4)
 			*(uint32_t *)run->mmio.data = (uint32_t)vcpu->arch.mmio.val;
 		else if (run->mmio.len == 8)
@@ -457,6 +481,29 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 			vcpu->mmio_needed = 1;
 
 		break;
+	case KVM_EXIT_IO:
+		/* pio exit */
+		run->exit_reason = ret >> 24;
+		run->io.direction = vcpu->arch.pio.direction;
+		run->io.size = vcpu->arch.pio.size;
+		run->io.port = vcpu->arch.pio.port;
+		run->io.count = vcpu->arch.pio.count;
+		run->io.data_offset = vcpu->arch.pio.data_offset;
+
+		if (run->io.direction == KVM_EXIT_IO_OUT) {
+			if (run->io.size == 1)
+				run->mips_exit_io.data[0] = (uint8_t)vcpu->arch.pio.val;
+			else if (run->io.size == 2)
+				*(uint16_t *)run->mips_exit_io.data = (uint16_t)vcpu->arch.pio.val;
+			else if (run->io.size == 4)
+				*(uint32_t *)run->mips_exit_io.data = (uint32_t)vcpu->arch.pio.val;
+			else if (run->io.size == 8)
+				*(uint64_t *)run->mips_exit_io.data = (uint64_t)vcpu->arch.pio.val;
+		} else {
+			vcpu->arch.pio_needed = 1;
+		}
+
+		break;
 #if 0
 	case KVM_EXIT_IRQ_WINDOW_OPEN:
 		run->exit_reason = ret >> 24;
@@ -565,6 +612,7 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	vcpu->arch.gpa_pgd = 0;
 	vcpu->arch.nmi = 0;
 	vcpu->arch.host_vcpuid = -1;
+	vcpu->arch.pio_needed = 0;
 #if 0
 	printk("Guest vcpu %p initialization\n", vcpu);
 #endif
@@ -852,6 +900,14 @@ long kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)
 		}
 		break;
 	}
+	case KVM_MIPS_INJECT_PCIE_INTX:
+	{
+		struct kvm_arch *arch = &kvm->arch;
+		int link = (int)(long)argp;
+
+		kvm_pic_inject_guest_ext(kvm, arch, PIC_XLP9XX_IRT_PCIE_LINK_0_INDEX + link, 0);
+		break;
+	}
 	default:
 		r = -EINVAL;
 		break;
diff --git a/arch/mips/netlogic/kvm/kvm_fault.c b/arch/mips/netlogic/kvm/kvm_fault.c
index 09ff27f..159a791 100644
--- a/arch/mips/netlogic/kvm/kvm_fault.c
+++ b/arch/mips/netlogic/kvm/kvm_fault.c
@@ -147,7 +147,33 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 	if ((regs->cp0_guestctl0 >> 31) == 0)
 		return 0;
 
-	if (address >= 0x18000000 && address < 0x1c000000) {
+	if (address >= 0x14000000 && address < 0x16000000) {
+		/* I/O address */
+		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0x80000000 /* lb */
+		    || (badinstr & 0xfc000000) == 0xa0000000 /* sb */
+		    || (badinstr & 0xfc000000) == 0x90000000 /* lbu */
+		    || (badinstr & 0xfc000000) == 0xa4000000 /* sh */
+		    || (badinstr & 0xfc000000) == 0x94000000 /* lhu */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+                else {
+			printk("%s: 0x%x, unhandled epc %lx, address %lx\n",
+				__FUNCTION__, badinstr, regs->cp0_epc, address);
+			return 0;
+                }
+
+		kvm_handle_pcie_io(regs, write, address, reg_num, badinstr, epc_badinstr);
+
+		compute_guest_return_epc(regs, epc_badinstr);
+
+		return 1;
+	} else if (address >= 0x18000000 && address < 0x1c000000) {
 		/* pcie register configuration space */
 
 		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
@@ -250,6 +276,8 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 		    || (badinstr & 0xfc000000) == 0x80000000 /* lb */
 		    || (badinstr & 0xfc000000) == 0xa0000000 /* sb */
 		    || (badinstr & 0xfc000000) == 0x90000000 /* lbu */
+		    || (badinstr & 0xfc000000) == 0xa4000000 /* sh */
+		    || (badinstr & 0xfc000000) == 0x94000000 /* lhu */
 		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
 		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
 		   )
diff --git a/arch/mips/netlogic/kvm/kvm_pcie.c b/arch/mips/netlogic/kvm/kvm_pcie.c
index d7d13e0..11160e4 100644
--- a/arch/mips/netlogic/kvm/kvm_pcie.c
+++ b/arch/mips/netlogic/kvm/kvm_pcie.c
@@ -64,7 +64,7 @@ void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
 	struct kvm_vcpu *vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
 
 #if 0
-	printk("=== pcie: address 0x%lx, epc 0x%lx, write %ld\n",
+	printk("=== pcie_pcie: address 0x%lx, epc 0x%lx, write %ld\n",
 		address, regs->cp0_epc, write);
 #endif
 
@@ -77,6 +77,9 @@ void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
 	    || (badinstr & 0xfc000000) == 0x90000000
 	    || (badinstr & 0xfc000000) == 0xa0000000)
 		vcpu->arch.mmio.len = 1;
+	else if ((badinstr & 0xfc000000) == 0xa4000000
+	    || (badinstr & 0xfc000000) == 0x94000000)
+		vcpu->arch.mmio.len = 2;
 	else if ((badinstr & 0xfc000000) == 0x8c000000
 	    || (badinstr & 0xfc000000) == 0xac000000)
 		vcpu->arch.mmio.len = 4;
@@ -90,3 +93,44 @@ void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
 	kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
 	__kvm_vcpu_leave_guest(vcpu, val);
 }
+
+void kvm_handle_pcie_io(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num, uint32_t badinstr,
+		uint32_t epc_badinstr)
+{
+	uint32_t val;
+	struct kvm_vcpu *vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
+
+#if 0
+	printk("=== pcie_io: address 0x%lx, epc 0x%lx, write %ld\n",
+		address, regs->cp0_epc, write);
+#endif
+
+	val = KVM_EXIT_IO << 24;
+	vcpu->arch.pio.direction = (write ? KVM_EXIT_IO_OUT : KVM_EXIT_IO_IN);
+	vcpu->arch.pio.port = address & 0xffff; /* ignore upper bits */
+
+	if ((badinstr & 0xfc000000) == 0x80000000
+	    || (badinstr & 0xfc000000) == 0x90000000
+	    || (badinstr & 0xfc000000) == 0xa0000000)
+		vcpu->arch.pio.size = 1;
+	else if ((badinstr & 0xfc000000) == 0xa4000000
+	    || (badinstr & 0xfc000000) == 0x94000000)
+		vcpu->arch.pio.size = 2;
+	else if ((badinstr & 0xfc000000) == 0x8c000000
+	    || (badinstr & 0xfc000000) == 0xac000000)
+		vcpu->arch.pio.size = 4;
+	else
+		vcpu->arch.pio.size = 8;
+	vcpu->arch.pio.count = 1;
+	vcpu->arch.pio.data_offset = (uint64_t)&(((struct kvm_run *)0)->mips_exit_io.data);
+
+	if (write)
+		vcpu->arch.pio.val = regs->regs[reg_num];
+
+	vcpu->arch.pio.reg_num = reg_num;
+
+	compute_guest_return_epc(regs, epc_badinstr);
+	kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+	__kvm_vcpu_leave_guest(vcpu, val);
+}
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 57d860d..88e319c 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -212,6 +212,13 @@ struct kvm_run {
 	__u64 psw_mask; /* psw upper half */
 	__u64 psw_addr; /* psw lower half */
 #endif
+
+#ifdef CONFIG_CPU_XLP
+	/* Data portion of KVM_EXIT_IO */
+	struct {
+		__u8 data[8];
+	} mips_exit_io;
+#endif
 	union {
 		/* KVM_EXIT_UNKNOWN */
 		struct {
-- 
1.9.1

