From 9650dfa2dfa7a8a7a9120a94b854c991bf2843f2 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Fri, 19 Jul 2013 10:21:44 -0700
Subject: [PATCH] kvm: add enumation of part of fuse block

Commit 25834451feb25ec04783f483179bafdfc95db1a3 from Broadcom SDK 3.0.2

o Also check whether address is from guest or not
  before doing pcie checking. Certain N32 virtual address may
  fault into pcie physical address range

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/netlogic/kvm_xlp.h b/arch/mips/include/asm/netlogic/kvm_xlp.h
index f73ba61..ca1c830 100644
--- a/arch/mips/include/asm/netlogic/kvm_xlp.h
+++ b/arch/mips/include/asm/netlogic/kvm_xlp.h
@@ -124,4 +124,8 @@ extern void kvm_pic_inject_guest_ext(struct kvm *kvm, struct kvm_arch *arch,
 extern void kvm_handle_pcie_sysmgt(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num);
 
+/* defined in arch/mips/mm/kvm_fuse.c */
+extern void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
 #endif
diff --git a/arch/mips/netlogic/kvm/Makefile b/arch/mips/netlogic/kvm/Makefile
index 7ff9965..a7c118c 100644
--- a/arch/mips/netlogic/kvm/Makefile
+++ b/arch/mips/netlogic/kvm/Makefile
@@ -1,4 +1,4 @@
 EXTRA_CFLAGS := -Werror
-EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
+EXTRA_CFLAGS := $(CFLAGS)
 
-obj-y                    	= kvm_traps.o kvm_fault.o kvm_pic.o kvm_uart.o kvm_sysmgt.o
+obj-y                    	= kvm_traps.o kvm_fault.o kvm_pic.o kvm_uart.o kvm_sysmgt.o kvm_fuse.o
diff --git a/arch/mips/netlogic/kvm/kvm_fault.c b/arch/mips/netlogic/kvm/kvm_fault.c
index 7ac3adf..2ca1dec 100644
--- a/arch/mips/netlogic/kvm/kvm_fault.c
+++ b/arch/mips/netlogic/kvm/kvm_fault.c
@@ -220,6 +220,10 @@ static void handle_pci_config_space(struct pt_regs *regs, unsigned long write,
 asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 				    unsigned long address)
 {
+	/* check whether the fault is from guest. */
+	if ((regs->cp0_guestctl0 >> 31) == 0)
+		return 0;
+
 	if (address >= 0x18000000 && address < 0x1c000000) {
 		/* pcie register configuration space */
 		unsigned int badinstr, epc_badinstr;
@@ -241,7 +245,6 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 			/* The guest gives us wrong information. What to do? */
 			printk("%s: unhandled epc %lx, address %lx\n",
 				__FUNCTION__, regs->cp0_epc, address);
-			compute_guest_return_epc(regs, epc_badinstr);
 			return 0;
 		}
 
@@ -269,6 +272,10 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 			/* sys management: dev 6, func 0 */
 			kvm_handle_pcie_sysmgt(regs, write, address & 0xfff, reg_num);
 		}
+		else if ((address & 0xfffff000) == 0x18131000) {
+			/* fuse: dev 6, func 1 */
+			kvm_handle_pcie_fuse(regs, write, address & 0xfff, reg_num);
+		}
 		else if ((address & 0xfffff000) == 0x18138000) {
 			/* NOR flash: dev 7, func 0 */
 			handle_pcie_nor(regs, write, address & 0xfff, reg_num);
@@ -302,7 +309,6 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 		else {
 			printk("%s: unhandled epc %lx, address %lx\n",
 				__FUNCTION__, regs->cp0_epc, address);
-			compute_guest_return_epc(regs, epc_badinstr);
 			return 0;
 		}
 
diff --git a/arch/mips/netlogic/kvm/kvm_fuse.c b/arch/mips/netlogic/kvm/kvm_fuse.c
new file mode 100644
index 0000000..30a150b
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_fuse.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+
+	if (rindex == 0x106) {
+		/* cpu disables */
+		if (!write) {
+			regs->regs[reg_num] = 0x0;
+			return;
+		}
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
-- 
1.9.1

