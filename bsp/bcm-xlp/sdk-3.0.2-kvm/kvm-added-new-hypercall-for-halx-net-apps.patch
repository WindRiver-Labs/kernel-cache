From 5e0681f1958bab06870f225f47a6828cb96fb3a6 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Wed, 20 Nov 2013 17:33:57 +0530
Subject: [PATCH] kvm: added new hypercall for halx net apps

Commit cd1ee20f7860cc2be7614387c801a718e18824c2 from Broadcom SDK 3.0.2

1. new hypercall for halx net apps
2. gpa_to_hva

Signed-off-by: Virendra Pathak <vpathak@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/configs/nlm_xlp_defconfig b/arch/mips/configs/nlm_xlp_defconfig
index 5468b1c..5d3a5dd 100644
--- a/arch/mips/configs/nlm_xlp_defconfig
+++ b/arch/mips/configs/nlm_xlp_defconfig
@@ -1,3 +1,4 @@
+CONFIG_CPU_GENERIC_DUMP_TLB=y
 CONFIG_NLM_XLP_BOARD=y
 CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_16KB=y
diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 090eaba..f25f934 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -165,6 +165,14 @@ struct kvm_vcpu_arch {
 	/* vcpu state */
 	struct kvm_vcpu_guest	guest;
 	struct kvm_vcpu_root	root;
+
+	struct {
+		uint32_t domid;
+		uint32_t guestid;
+		uint32_t soc_type;
+		uint64_t cmd;
+		uint64_t args[4];
+	}mips_hypcall;
 };
 
 
diff --git a/arch/mips/include/asm/netlogic/kvm_para.h b/arch/mips/include/asm/netlogic/kvm_para.h
index 233615d..45a175d 100644
--- a/arch/mips/include/asm/netlogic/kvm_para.h
+++ b/arch/mips/include/asm/netlogic/kvm_para.h
@@ -38,6 +38,17 @@
 extern int is_nlm_guest_os;
 
 #define KVM_HC_GET_HARD_CPUID	0x1  /* p1r1 */
+#define KVM_HC_HALX_NETSOC	0x2
+
+/* Halx specific sub cmds */
+#define CMD_HALX_REGISTER	0x1
+#define CMD_HALX_NET_INIT	0x2
+#define CMD_HALX_OPEN_PORT	0x3
+#define CMD_HALX_CLOSE_PORT	0x4
+#define CMD_HALX_CONFIG_PORT	0x5
+#define CMD_HALX_DEV_INFO	0x6
+#define CMD_HALX_PKT_ENGINE	0x7
+#define CMD_HALX_PKT_PARSER	0x8
 
 static inline int do_hypcall_p1r1(int num, uint64_t param0, uint64_t *ret0)
 {
@@ -59,4 +70,26 @@ static inline int do_hypcall_p1r1(int num, uint64_t param0, uint64_t *ret0)
 	return ret;
 }
 
+static inline int do_hypcall_p2r1(int num, uint64_t param0, uint64_t param1, uint64_t *ret0)
+{
+        int      ret;
+        uint64_t result;
+
+        __asm__ __volatile__(
+                "move $2, %2\n"
+                "move $3, %3\n"
+		"move $4, %4\n"
+                "hypcall\n"
+                "move %0, $2\n"
+                "move %1, $3\n"
+                : "=r"(ret), "=r"(result)
+                : "r"(num), "r"(param0), "r"(param1)
+                : "$2","$3","$4", "memory"
+        );
+
+        *ret0 = result;
+        ret = 0;
+        return ret;
+}
+
 #endif
diff --git a/arch/mips/kvm/kvm.c b/arch/mips/kvm/kvm.c
index 7ab1c0a..82a3e88 100644
--- a/arch/mips/kvm/kvm.c
+++ b/arch/mips/kvm/kvm.c
@@ -457,6 +457,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		run->mips_spawn_thread.start_hw_cpuid = ret & 0xff;
 		break;
 	case KVM_EXIT_ENABLE_CORE:
+		printk("KVM_EXIT_ENABLE_CORE\n");
 		run->exit_reason = ret >> 24;
 		run->mips_spawn_thread.start_hw_cpuid = ret & 0xff;
 		break;
@@ -465,6 +466,9 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		run->exit_reason = ret >> 24;
 		break;
 	case KVM_EXIT_QUIT_KVM:
+		printk("KVM_EXIT_QUIT_KVM Running guest (vcpu %p, kvm %p, Entry PC: 0x%llx, GuestId 0x%llx, Guest vcpu id: 0x%llx) ...\n",
+                vcpu, vcpu->kvm, r->root_epc, r->root_guestctl1 & 0xff, r->guest_ebase & 0x3ff);
+
 		/* quit kvm */
 		run->exit_reason = ret >> 24;
 		/* also clear guestctl1 */
@@ -517,6 +521,12 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 			vcpu->arch.pio_needed = 1;
 		}
 
+	case KVM_EXIT_HC_HALX_NETSOC:
+		run->mips_hypcall.args[0] = vcpu->arch.mips_hypcall.args[0];
+		run->mips_hypcall.cmd = vcpu->arch.mips_hypcall.cmd;
+		run->exit_reason = ret >> 24;
+		printk("KVM_EXIT_HC_HALX_NETSOC. run->mips_hypcall.args[0] = 0x%lx\n", (long unsigned int)run->mips_hypcall.args[0]);
+		printk("KVM_EXIT_HC_HALX_NETSOC. run->exit_reason = 0x%lx, run->mips_hypcall.cmd = %d\n", (long unsigned int)run->exit_reason, (int)run->mips_hypcall.cmd);
 		break;
 #if 0
 	case KVM_EXIT_IRQ_WINDOW_OPEN:
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 039ec48..4de3371 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -460,7 +460,7 @@ void kvm_xlp_check_exit_request(struct kvm_vcpu *vcpu)
 {
 	unsigned int val;
 
-#if 0
+#if 1
 	printk("Guest vcpu %lld exiting\n", vcpu->arch.guest.gpu.guest_ebase & 0x3ff);
 #endif
 
diff --git a/arch/mips/lib/dump_tlb.c b/arch/mips/lib/dump_tlb.c
index 32b9f21..d0bfcf1 100644
--- a/arch/mips/lib/dump_tlb.c
+++ b/arch/mips/lib/dump_tlb.c
@@ -6,7 +6,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
-
+#include <linux/module.h>
 #include <asm/mipsregs.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -111,3 +111,4 @@ void dump_tlb_all(void)
 {
 	dump_tlb(0, current_cpu_data.tlbsize - 1);
 }
+EXPORT_SYMBOL(dump_tlb_all);
diff --git a/arch/mips/netlogic/kvm/kvm_traps.c b/arch/mips/netlogic/kvm/kvm_traps.c
index 5dbcb1e..f8ab256 100644
--- a/arch/mips/netlogic/kvm/kvm_traps.c
+++ b/arch/mips/netlogic/kvm/kvm_traps.c
@@ -57,6 +57,70 @@
 /* Enable guest counting of guest mode */
 #define PERF_GUEST_EC   (0x2 << 23)
 
+
+
+/*static int gpa_to_pa(struct kvm_vcpu *vcpu, unsigned long gpa_address, unsigned long *pa_address)
+{
+	pgd_t           *pgdp;
+	pud_t           *pudp;
+#ifndef __PAGETABLE_PMD_FOLDED
+	pmd_t           *pmdp;
+#endif
+	pte_t           *ptep, pte;
+	int t;
+	unsigned long address;
+
+	address = gpa_address;
+	printk("gpa_address %lx address %lx \n",gpa_address, address);
+	for (t = 0; t < KVM_MEMORY_SLOTS; t++) {
+		struct kvm_memory_slot *s = &vcpu->kvm->memslots->memslots[t];
+
+		if (gpa_address >= (s->base_gfn << PAGE_SHIFT)
+				&& gpa_address < ((s->base_gfn + s->npages) << PAGE_SHIFT)) {
+			address = s->userspace_addr + gpa_address - (s->base_gfn << PAGE_SHIFT);
+			break;
+		}
+	}
+
+	printk("gpa_address %lx address %lx \n",gpa_address, address);
+
+	address = gpa_address;
+
+	pgdp = (pgd_t *)vcpu->arch.gpa_pgd + __pgd_offset(address);
+	pudp = (pud_t *)pgdp;
+#ifndef __PAGETABLE_PMD_FOLDED
+	pmdp = pmd_offset(pudp, address);
+	ptep = pte_offset(pmdp, address);
+#else
+	ptep = pte_offset((pmd_t *)pudp, address);
+#endif
+	pte = *ptep;
+
+	*pa_address = (pte_val(pte) >> (_PAGE_GLOBAL_SHIFT + 6)) << 12;
+
+	return 0;
+}*/
+
+static int gpa_to_hva (struct kvm_vcpu *vcpu, unsigned long gpa_address, unsigned long *hva_address)
+{
+	int t;
+	unsigned long address = 0;
+
+	for (t = 0; t < KVM_MEMORY_SLOTS; t++) {
+		struct kvm_memory_slot *s = &vcpu->kvm->memslots->memslots[t];
+
+		if (gpa_address >= (s->base_gfn << PAGE_SHIFT)
+				&& gpa_address < ((s->base_gfn + s->npages) << PAGE_SHIFT)) {
+			address = s->userspace_addr + gpa_address - (s->base_gfn << PAGE_SHIFT);
+			break;
+		}
+	}
+	printk("hva address 0x%lx \n", address);
+	*hva_address = address;
+	return 0;
+}
+
+
 /* Guest privileged sensitive instruction */
 static void process_psi(struct pt_regs *regs)
 {
@@ -408,6 +472,8 @@ static void process_hc(struct pt_regs *regs)
 		struct kvm_vcpu *vcpu;
 
 		kvm = ((struct kvm_vcpu *)regs->cp0_osscratch7)->kvm;
+		printk("Hypercall exception (number %d) KVM_HC_GET_HARD_CPUID:\n",hc_num);
+
 		kvm_for_each_vcpu(i, vcpu, kvm) {
 			if (vcpu->vcpu_id == guest_cpuid) {
 				host_cpuid = __cpu_logical_map[vcpu->arch.host_vcpuid];
@@ -424,6 +490,56 @@ static void process_hc(struct pt_regs *regs)
 		}
 		break;
 	}
+	case KVM_HC_HALX_NETSOC:
+	{
+		int val;
+		unsigned long gpa_addr, hva_addr = 0;
+		struct kvm *kvm;
+		struct kvm_vcpu *vcpu = NULL;
+		int sub_cmd;
+		int i;
+		/* TODO: check guest_cpuid, make sure it in regs[3] */
+		/*int guest_cpuid = regs->regs[3];*/
+		int guest_cpuid = 0;
+
+		kvm = ((struct kvm_vcpu *)regs->cp0_osscratch7)->kvm;
+		printk("Hypercall exception (number %d) netsoc: 0x%lx\n",hc_num, regs->regs[3]);
+
+		kvm_for_each_vcpu(i, vcpu, kvm) {
+			if (vcpu->vcpu_id == guest_cpuid) {
+				break;
+			}
+		}
+		if (vcpu == NULL) {
+			printk(" *** ERROR NULL vcpu ***\n");
+		}
+
+		/*
+		 * val[15:0]: start cpu id (ebase).
+		 * val[23:16]: # of cpus to spawn.
+		 * val[31:24]: exit code.
+		 */
+		val = regs->guest_cp0_ebase & 0x3ff;
+		val ++;
+		val |= (1 << 3);
+		val |= (KVM_EXIT_HC_HALX_NETSOC << 24);
+
+		gpa_addr = regs->regs[3];
+		sub_cmd = regs->regs[4];
+		gpa_to_hva((struct kvm_vcpu *)regs->cp0_osscratch7, gpa_addr, &hva_addr);
+
+		printk("Tentatively Leaving the guest ...gpa 0x%lx hva 0x%lx\n", gpa_addr, hva_addr);
+		printk("KVM_HC_HALX_NETSOC: sub_cmd = %d\n",  sub_cmd);
+
+		vcpu->arch.mips_hypcall.args[0] = hva_addr;
+		vcpu->arch.mips_hypcall.cmd = sub_cmd;
+
+		compute_guest_return_epc(regs, epc_badinstr);
+		kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+		__kvm_vcpu_leave_guest((struct kvm_vcpu *)regs->cp0_osscratch7, val);
+
+		break;
+	}
 	default:
 		printk("Hypercall exception (number %d) not implemented:\n", hc_num);
 		printk("\tepc 0x%lx, badinstr: 0x%x\n", epc, badinstr);
@@ -457,6 +573,7 @@ void process_virt_exception(struct pt_regs *regs)
 		process_fc(regs);
 		break;
 	case 0x2:
+		printk("Hypercall\n");
 		process_hc(regs);
 		break;
 	case 0x3:
diff --git a/arch/mips/netlogic/xlp/dt.c b/arch/mips/netlogic/xlp/dt.c
index 6f011b2..0296935 100644
--- a/arch/mips/netlogic/xlp/dt.c
+++ b/arch/mips/netlogic/xlp/dt.c
@@ -42,10 +42,16 @@
 
 extern u32 __dtb_xlp_evp_begin[], __dtb_xlp_svp_begin[],
 	__dtb_xlp_fvp_begin[], __dtb_xlp_gvp_begin[], __dtb_start[];
+#include <asm/netlogic/xlp-hal/xlp.h>
+//#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/haldefs.h>
 
 void *fdt;
 EXPORT_SYMBOL(fdt);
 
+extern u32 __dtb_xlp_evp_begin[], __dtb_xlp_svp_begin[], __dtb_xlp_fvp_begin[],
+	__dtb_xlp_gvp_begin[], __dtb_start[];
+
 void __init *xlp_dt_init(void *fdtp)
 {
 	if (!fdtp) {
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 88e319c..b631827 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -181,6 +181,7 @@ struct kvm_pit_config {
 #define	KVM_EXIT_QUIT_KVM	  27
 #define	KVM_EXIT_CHAR_PRINT	  28
 #define	KVM_EXIT_REQUEST_QUIT	  29
+#define KVM_EXIT_HC_HALX_NETSOC	  30
 #endif
 
 /* For KVM_EXIT_INTERNAL_ERROR */
@@ -329,6 +330,14 @@ struct kvm_run {
 		struct {
 			__u8 c;
 		} mips_output_char;
+	        struct {
+		        __u32 domid;
+			__u32 guestid;
+	                __u32 soc_type;
+		        __u64 cmd;
+			__u64 args[4];
+		}mips_hypcall;
+
 #endif
 		char padding[256];
 	};
-- 
1.9.1

