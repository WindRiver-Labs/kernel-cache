From 1d77eac57415a4bc0c8ba4df3c7d019d068f5706 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Wed, 8 May 2013 08:50:57 -0700
Subject: [PATCH] kvm: add guest NMI support so that smp guest can be booted up

Commit 21e409e27e4114456408caaeb07d132a7b679edf from Broadcom SDK 3.0.2

o Current NMI support does not add NMI checking at guest exception return.
  Instead, the checking of NMI is placed during handling "wait", to
  avoid adding overhead for every exception.
o So this is not a generic guest NMI support. Support can be added if
  it is truely needed.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 7c5311d..2dcbeec 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -86,6 +86,7 @@ struct kvm_vcpu_arch {
 	uint64_t gpa_pgd; /* guest physical address pgd */
 	uint64_t guest_vcpu_p[32]; /* guest vcpu pointer */
 	uint64_t host_vcpuid; /* corresponding host vcpu id, for fast guest IPI delivery */
+	uint64_t nmi;
 
 	/* vcpu state */
 	struct kvm_vcpu_guest	guest;
diff --git a/arch/mips/kvm/kvm.c b/arch/mips/kvm/kvm.c
index 9111d6b..a1a25d4 100644
--- a/arch/mips/kvm/kvm.c
+++ b/arch/mips/kvm/kvm.c
@@ -424,6 +424,7 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	vcpu->arch.init_guest = 1;
 	vcpu->arch.hva_pgd = 0;
 	vcpu->arch.gpa_pgd = 0;
+	vcpu->arch.nmi = 0;
 	printk("Guest vcpu %p initialization\n", vcpu);
 	return 0;
 }
diff --git a/arch/mips/netlogic/kvm/kvm_pic.c b/arch/mips/netlogic/kvm/kvm_pic.c
index c6f26f7..0834bfa 100644
--- a/arch/mips/netlogic/kvm/kvm_pic.c
+++ b/arch/mips/netlogic/kvm/kvm_pic.c
@@ -112,19 +112,23 @@ void kvm_handle_pcie_pic(struct pt_regs *regs, unsigned long write,
 
 			arch->pic.u.v64[rindex >> 1] = val;
 
-			if (val & (1 << 23))
-				printk("===== NMI IPI is not supported\n");
-
-			if ((val & (0x7 << 20)) != 0)
+			if ((val & (0x7 << 20)) != 0) {
 				printk("===== Non Unicast IPI is not supported\n");
+				return;
+			}
 
-			rvec = (val >> 24) & 0x3f;
 			cpuid = xlp_kvm_get_ipi_cpuid (val);
 #ifdef DEBUG
-printk("Sending IPI from cpuid %d to cpuid %d\n", (int)(regs->guest_cp0_ebase & 0x3ff), cpuid);
+printk("Sending %s from cpuid %d to cpuid %d\n", (val & (1 << 23)) ? "NMI" : "IPI",
+	(int)(regs->guest_cp0_ebase & 0x3ff), cpuid);
 #endif
 			vcpu_arch = kvm_get_vcpu_arch_with_cpuid(regs, cpuid);
-			atomic_or_llong(&vcpu_arch->pip_vector, 1ULL << rvec);
+			if (val & (1 << 23)) {
+				vcpu_arch->nmi = 1;
+			} else {
+				rvec = (val >> 24) & 0x3f;
+				atomic_or_llong(&vcpu_arch->pip_vector, 1ULL << rvec);
+			}
 		} else
 			regs->regs[reg_num] = arch->pic.u.v64[rindex >> 1];
 
diff --git a/arch/mips/netlogic/kvm/kvm_traps.c b/arch/mips/netlogic/kvm/kvm_traps.c
index c11e152..552f32b 100644
--- a/arch/mips/netlogic/kvm/kvm_traps.c
+++ b/arch/mips/netlogic/kvm/kvm_traps.c
@@ -34,6 +34,17 @@ static void process_psi(struct pt_regs *regs)
 	if ((badinstr >> 26) == 0x10) {
 		/* cop0 */
 		if ((badinstr & 0xfe00003f) == 0x42000020) {
+			struct kvm_vcpu_arch *vcpu_arch;
+
+			vcpu_arch = kvm_get_vcpu_arch(regs);
+			if (vcpu_arch->nmi == 1) {
+				regs->cp0_epc = 0xffffffffbfc00000;
+				__write_32bit_guest_c0_register($12, 0,
+					__read_32bit_guest_c0_register($12, 0) | 0x80000);
+				vcpu_arch->nmi = 0;
+				return;
+			}
+
 			/* We do not want to simply bounce back. As for SMT,
 			 * this will have performance implication.
 			 */
-- 
1.9.1

