From 99ead8a49eb8f830bb8428bdbba4b35c89fa10ac Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 30 Jul 2013 09:25:10 -0700
Subject: [PATCH] kvm: add a lock for virtualized uart

Commit 32a8e8a1dec3bb683b8d9c4e9d5ac26949efbe12 from Broadcom SDK 3.0.2

o In virtualized uart, the registers may be accessed at the same by
  guest vcpu and qemu itself. qemu itself is used to inject uart input
  to guest.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 5bcaea2..898e6e1 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -94,6 +94,12 @@ struct kvm_arch {
 		/* input buffers */
 		unsigned int input_size;
 		unsigned char input_buf[KVM_MAX_UART_IN_SIZE];
+
+		/* uart registers and input_buf may be accessed by different
+		 * cpus at the same time (qemu injecting input, and output from guest).
+		 * a lock is presented here.
+		 */
+		spinlock_t lock;
 	} uart;
 	struct {
 		unsigned int regs[MAX_XLP_SYSMGT_REG_NUM];
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 75abd73..2101732 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -343,6 +343,7 @@ static void xlp_kvm_init_uart0(struct kvm_arch *arch)
 	arch->uart.dlb2 = 0x0;
 
 	arch->uart.input_size = 0;
+	spin_lock_init(&arch->uart.lock);
 }
 
 static void xlp_kvm_init_pic(struct kvm_arch *arch)
@@ -423,16 +424,18 @@ void kvm_save_guest_context(struct pt_regs *regs, struct kvm_vcpu_guest *guest)
 void kvm_uart_insert_char(struct kvm *kvm, char c)
 {
 	struct kvm_arch *arch = &kvm->arch;
+	int overflow = 0;
 
 	if (arch->exit_request)
 		return;
 
+	spin_lock(&arch->uart.lock);
+
 	if (arch->uart.input_size < KVM_MAX_UART_IN_SIZE) {
 		arch->uart.input_buf[arch->uart.input_size] = c;
 		arch->uart.input_size ++;
 	} else {
-		/* Overflows: ignore */
-		printk("%s: guest input overflows\n", __FUNCTION__);
+		overflow = 1;
 	}
 
 	/* We want to inject the char back to the guest, generate an interrupt */
@@ -442,6 +445,11 @@ void kvm_uart_insert_char(struct kvm *kvm, char c)
 	else
 		arch->uart.iir  = arch->uart.iir | (0x2 << 1);
 	kvm_pic_inject_guest_ext(kvm, arch, arch->uart.header[0x3d] & 0xffff, 0);
+
+	spin_unlock(&arch->uart.lock);
+
+	if (overflow)
+		printk("%s: guest input overflows\n", __FUNCTION__);
 }
 
 void kvm_xlp_check_exit_request(struct kvm_vcpu *vcpu)
diff --git a/arch/mips/netlogic/kvm/kvm_uart.c b/arch/mips/netlogic/kvm/kvm_uart.c
index 7f31997..430a831 100644
--- a/arch/mips/netlogic/kvm/kvm_uart.c
+++ b/arch/mips/netlogic/kvm/kvm_uart.c
@@ -67,14 +67,16 @@ static inline void unhandled_exception(const char *func, unsigned long addr,
 void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 		unsigned long address, unsigned long reg_num)
 {
-	unsigned int rindex = address >> 2;
+	unsigned int rindex = address >> 2, unhandled = 0;
 	struct kvm_arch *arch = kvm_get_arch(regs);
 
+	spin_lock(&arch->uart.lock);
+
 	if (rindex == 0x0 || rindex == 0x2 || rindex == 0x3d) {
 		if (!write)
 			regs->regs[reg_num] = arch->uart.header[rindex];
 		else
-			unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+			unhandled = 1;
 	} else if (rindex == 0x40) {
 		if (write) {
 			if (arch->uart.lcr & (1 << 7))
@@ -121,6 +123,8 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 #endif
 
 				/* Quit the guest and go to QEMU for real print */
+				spin_unlock(&arch->uart.lock);
+
 				val = (KVM_EXIT_CHAR_PRINT << 24) | c;
 				kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
 				compute_guest_return_epc(regs, epc_badinstr);
@@ -210,5 +214,10 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 		else
 			regs->regs[reg_num] = arch->uart.msr;
 	} else
+		unhandled = 1;
+
+	spin_unlock(&arch->uart.lock);
+
+	if (unhandled)
 		unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
 }
-- 
1.9.1

