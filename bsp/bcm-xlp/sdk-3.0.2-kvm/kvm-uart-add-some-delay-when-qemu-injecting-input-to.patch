From 1a97fd93c636890ffdb8162861515dc8f9878a95 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Wed, 31 Jul 2013 13:06:35 -0700
Subject: [PATCH] kvm: uart: add some delay when qemu injecting input to guest

Commit b3b3ea251a2156e411d6cbbb1c09d74a3552a74a from Broadcom SDK 3.0.2

o QEMU injecting input to guest through qemu thread
o Guest vcpu thread to accept input
o If QEMU injection is too fast, the buffer may overflow

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 2101732..40b8e90 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -42,6 +42,7 @@
 #include <asm/inst.h>
 #include <asm/ptrace.h>
 #include <asm/kvm_host.h>
+#include <asm/delay.h>
 #include <asm/netlogic/kvm_xlp.h>
 
 #include <asm/netlogic/haldefs.h>
@@ -424,7 +425,6 @@ void kvm_save_guest_context(struct pt_regs *regs, struct kvm_vcpu_guest *guest)
 void kvm_uart_insert_char(struct kvm *kvm, char c)
 {
 	struct kvm_arch *arch = &kvm->arch;
-	int overflow = 0;
 
 	if (arch->exit_request)
 		return;
@@ -435,21 +435,28 @@ void kvm_uart_insert_char(struct kvm *kvm, char c)
 		arch->uart.input_buf[arch->uart.input_size] = c;
 		arch->uart.input_size ++;
 	} else {
-		overflow = 1;
+		printk("Guest UART buffer overflowed, reset the buffer ...\n");
+		arch->uart.input_size = 0;
+
+		arch->uart.input_buf[arch->uart.input_size] = c;
+		arch->uart.input_size ++;
 	}
 
 	/* We want to inject the char back to the guest, generate an interrupt */
 	arch->uart.lsr  |= 0x1;
-	if (arch->uart.iir & 0x1)
-		arch->uart.iir  = (0x2 << 1) | 0x00;
-	else
-		arch->uart.iir  = arch->uart.iir | (0x2 << 1);
+	arch->uart.iir  = (0x2 << 1) | 0x00;
 	kvm_pic_inject_guest_ext(kvm, arch, arch->uart.header[0x3d] & 0xffff, 0);
 
 	spin_unlock(&arch->uart.lock);
 
-	if (overflow)
-		printk("%s: guest input overflows\n", __FUNCTION__);
+	/* Slow down the input injection to guest. The injection process is asynchronous.
+ 	 * qemu thread:  inject inputs to guest
+ 	 * guest thread: accept the input
+ 	 *
+ 	 * If the guest is slow to accept the input, the buffer could overflow and the input
+ 	 * may lose.
+ 	 */
+	udelay(1000 * arch->uart.input_size);
 }
 
 void kvm_xlp_check_exit_request(struct kvm_vcpu *vcpu)
diff --git a/arch/mips/netlogic/kvm/kvm_uart.c b/arch/mips/netlogic/kvm/kvm_uart.c
index 430a831..9c06b3a 100644
--- a/arch/mips/netlogic/kvm/kvm_uart.c
+++ b/arch/mips/netlogic/kvm/kvm_uart.c
@@ -86,10 +86,7 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 				uint32_t val, badinstr, epc_badinstr;
 
 				if (arch->uart.ier & 0x2) {
-					if (arch->uart.iir & 0x1)
-						arch->uart.iir = 0x2;
-					else
-						arch->uart.iir = arch->uart.iir | 0x2;
+					arch->uart.iir = 0x2;
 
 					/* For every transmit char, we always generate an interrupt
 					 * for guest to look at the buffer again. This will generate
@@ -107,6 +104,9 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 						regs);
 				}
 
+				/* Quit the guest and go to QEMU for real print */
+				spin_unlock(&arch->uart.lock);
+
 #if 1
 				/* Huge amount of guest output in a short period of time
 				 * may cause guest uart function incorrectly.
@@ -122,9 +122,6 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 				udelay(100);
 #endif
 
-				/* Quit the guest and go to QEMU for real print */
-				spin_unlock(&arch->uart.lock);
-
 				val = (KVM_EXIT_CHAR_PRINT << 24) | c;
 				kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
 				compute_guest_return_epc(regs, epc_badinstr);
@@ -153,8 +150,7 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 
 					/* clear "receive data ready" and interrupt */
 					if ((arch->uart.iir & 0xe) == 4) {
-						arch->uart.iir &= ~0x4;
-						arch->uart.iir |= 0x1;
+						arch->uart.iir = 0x1;
 					}
 				}
 			}
@@ -163,8 +159,15 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 		if (write) {
 			if (arch->uart.lcr & (1 << 7))
 				arch->uart.dlb2 = regs->regs[reg_num];
-			else
+			else {
 				arch->uart.ier = regs->regs[reg_num] & 0xf;
+
+				/* clear the "transmit" ready interrupt */
+				if ((arch->uart.ier & 0x2) == 0) {
+					if (arch->uart.iir == 0x2)
+						arch->uart.iir = 0x1;
+				}
+			}
 		} else {
 			if (arch->uart.lcr & (1 << 7))
 				regs->regs[reg_num] = arch->uart.dlb2;
@@ -178,11 +181,6 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 		else {
 			unsigned int tmp = arch->uart.iir;
 			regs->regs[reg_num] = tmp;
-
-			if ((tmp & 0x0e) == 0x02) {
-				arch->uart.iir &= ~0x02;
-				arch->uart.iir |= 0x1;
-			}
 		}
 	} else if (rindex == 0x43) {
 		/* line control */
@@ -198,14 +196,10 @@ void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 			regs->regs[reg_num] = arch->uart.mcr;
 	} else if (rindex == 0x45) {
 		/* line status */
-		if (write)
+		if (write) {
 			arch->uart.lsr = regs->regs[reg_num];
-		else {
+		} else {
 			regs->regs[reg_num] = arch->uart.lsr;
-
-			/* clear the related bits and clear the interrupt upon read */
-			arch->uart.lsr &= 0x61;
-			arch->uart.iir |= 0x01;
 		}
 	} else if (rindex == 0x46) {
 		/* modem status  */
-- 
1.9.1

