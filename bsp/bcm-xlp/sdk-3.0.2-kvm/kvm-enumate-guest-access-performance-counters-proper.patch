From 26abc32b4a67d07d56a48badfc3774303bfab281 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Tue, 30 Jul 2013 13:31:14 -0700
Subject: [PATCH] kvm: enumate guest-access performance counters properly

Commit c5f405346521a8b418d417f5da7c9988cd1d4a53 from Broadcom SDK 3.0.2

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/kvm/kvm_traps.c b/arch/mips/netlogic/kvm/kvm_traps.c
index a3cf8d7..5dbcb1e 100644
--- a/arch/mips/netlogic/kvm/kvm_traps.c
+++ b/arch/mips/netlogic/kvm/kvm_traps.c
@@ -123,13 +123,37 @@ static void process_psi(struct pt_regs *regs)
 				} else if (sel == 4) {
 					val = read_c0_perfctrl2();
 					write_c0_perfctrl2(val | PERF_GUEST_EC);
-				} else if (sel == 6) {
+				} else {
 					val = read_c0_perfctrl3();
 					write_c0_perfctrl3(val | PERF_GUEST_EC);
 				}
 				regs->regs[rt] = val;
 			} else
 				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else if (((badinstr >> 21) & 0x1f) == 0x1) {
+			/* DMF */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 25 && (sel == 1 || sel == 3 || sel == 5 || sel == 7)) {
+				/* perf counter control registers: enable guest use */
+
+				if (sel == 1) {
+					write_c0_perfctrl0(read_c0_perfctrl0() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr0_64();
+				} else if (sel == 3) {
+					write_c0_perfctrl1(read_c0_perfctrl1() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr1_64();
+				} else if (sel == 5) {
+					write_c0_perfctrl2(read_c0_perfctrl2() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr2_64();
+				} else {
+					write_c0_perfctrl3(read_c0_perfctrl3() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr3_64();
+				}
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
 		} else if (((badinstr >> 21) & 0x1f) == 0x4) {
 			/* MT */
 			unsigned int rt = (badinstr >> 16) & 0x1f;
@@ -148,10 +172,35 @@ static void process_psi(struct pt_regs *regs)
 					write_c0_perfctrl1(regs->regs[rt] | PERF_GUEST_EC);
 				else if (sel == 4)
 					write_c0_perfctrl2(regs->regs[rt] | PERF_GUEST_EC);
-				else if (sel == 6)
+				else
 					write_c0_perfctrl3(regs->regs[rt] | PERF_GUEST_EC);
 			} else
 				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else if (((badinstr >> 21) & 0x1f) == 0x5) {
+			/* DMT */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 25 && (sel == 1 || sel == 3 || sel == 5 || sel == 7)) {
+				/* perf cnt registers */
+
+				if (sel == 1) {
+					write_c0_perfctrl0(read_c0_perfctrl0() | PERF_GUEST_EC);
+					write_c0_perfcntr0_64(regs->regs[rt]);
+				} else if (sel == 3) {
+					write_c0_perfctrl1(read_c0_perfctrl1() | PERF_GUEST_EC);
+					write_c0_perfcntr1_64(regs->regs[rt]);
+				} else if (sel == 5) {
+					write_c0_perfctrl2(read_c0_perfctrl2() | PERF_GUEST_EC);
+					write_c0_perfcntr2_64(regs->regs[rt]);
+				} else {
+					write_c0_perfctrl3(read_c0_perfctrl3() | PERF_GUEST_EC);
+					write_c0_perfcntr3_64(regs->regs[rt]);
+				}
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+
 		} else
 			PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
 	} else if ((badinstr >> 26) == 0x1c) {
@@ -328,7 +377,7 @@ static void process_fc(struct pt_regs *regs)
 					write_c0_perfctrl1(regs->regs[rt] | PERF_GUEST_EC);
 				else if (sel == 4)
 					write_c0_perfctrl2(regs->regs[rt] | PERF_GUEST_EC);
-				else if (sel == 6)
+				else
 					write_c0_perfctrl3(regs->regs[rt] | PERF_GUEST_EC);
 			} else
 				FC_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
-- 
1.9.1

