From d667fd6da078f4f4dbd79a5079b6591173157909 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Wed, 24 Jul 2013 13:24:47 -0700
Subject: [PATCH] kvm: add initial virtualization support for bridge and pcie

Commit fdda55303de3cb1f07506a8c78e1175bc123fad6 from Broadcom SDK 3.0.2

o Remove the workaround in pcibios_init which prevents pcie discovery for guest
o Guest may need to work through pcie bus for later para-virtualized I/O driver like virtio

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index c9f66a1..51467cf 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -98,6 +98,19 @@ struct kvm_arch {
 	struct {
 		unsigned int regs[MAX_XLP_SYSMGT_REG_NUM];
 	} sysmgt;
+	struct {
+		int32_t config0;
+		int32_t pcie_busnum[4];
+		int32_t pcie_membase[4];
+		int32_t pcie_memlimit[4];
+		int32_t pcie_iobase[4];
+		int32_t pcie_iolimit[4];
+	} bridge;
+	struct {
+		struct {
+			int32_t config0;
+		} link[4];
+	} pcie;
 };
 
 struct kvm_vcpu_guest {
diff --git a/arch/mips/include/asm/netlogic/kvm_xlp.h b/arch/mips/include/asm/netlogic/kvm_xlp.h
index ca1c830..968de42 100644
--- a/arch/mips/include/asm/netlogic/kvm_xlp.h
+++ b/arch/mips/include/asm/netlogic/kvm_xlp.h
@@ -106,11 +106,11 @@ extern void xlp_kvm_destroy_vm(struct kvm *kvm);
 extern void kvm_xlp_check_exit_request(struct kvm_vcpu *);
 extern void nlm_flush_cache_L2L3(unsigned long, unsigned long);
 
-/* defined in arch/mips/mm/kvm_uart.c */
+/* defined in arch/mips/netlogic/kvm/kvm_uart.c */
 extern void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num);
 
-/* defined in arch/mips/mm/kvm_pic.c */
+/* defined in arch/mips/netlogic/kvm/kvm_pic.c */
 extern void kvm_handle_pcie_pic(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num);
 extern void kvm_pic_inject_guest(struct kvm_arch *arch, unsigned int irt,
@@ -120,12 +120,20 @@ extern void kvm_pic_inject_guest_cpuid(struct kvm_arch *arch, unsigned int irt,
 extern void kvm_pic_inject_guest_ext(struct kvm *kvm, struct kvm_arch *arch,
 	unsigned int irt, unsigned int cpuid);
 
-/* defined in arch/mips/mm/kvm_sysmgt.c */
+/* defined in arch/mips/netlogic/kvm/kvm_sysmgt.c */
 extern void kvm_handle_pcie_sysmgt(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num);
 
-/* defined in arch/mips/mm/kvm_fuse.c */
+/* defined in arch/mips/netlogic/kvm/kvm_fuse.c */
 extern void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
 	unsigned long address, unsigned long reg_num);
 
+/* defined in arch/mips/netlogic/kvm/kvm_bridge.c */
+extern void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_pcie.c */
+extern void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num, int link);
+
 #endif
diff --git a/arch/mips/kvm/xlp.c b/arch/mips/kvm/xlp.c
index 9b1e6b1..d74e90a 100644
--- a/arch/mips/kvm/xlp.c
+++ b/arch/mips/kvm/xlp.c
@@ -326,7 +326,7 @@ void xlp_kvm_destroy_vm(struct kvm *kvm)
 static void xlp_kvm_init_uart0(struct kvm_arch *arch)
 {
 	/* common headers */
-	arch->uart.header[0]    = 0x9010184e;
+	arch->uart.header[0]    = 0xffffffff;
 	arch->uart.header[2]    = 0x07000200;
 	arch->uart.header[0x3d] = 0x00010085;
 
@@ -347,7 +347,7 @@ static void xlp_kvm_init_uart0(struct kvm_arch *arch)
 
 static void xlp_kvm_init_pic(struct kvm_arch *arch)
 {
-	arch->pic.u.v32[0]    = 0x9003184e;
+	arch->pic.u.v32[0]    = 0xffffffff;
 	arch->pic.u.v32[2]    = 0x08000010;
 	arch->pic.u.v32[0x3d] = 0x0001008c;
 }
@@ -368,6 +368,29 @@ static void xlp_kvm_init_sysmgt(struct kvm_arch *arch)
 	arch->sysmgt.regs[0x43] = 0xffffe;
 }
 
+static void xlp_kvm_init_bridge(struct kvm_arch *arch)
+{
+	int i;
+
+	arch->bridge.config0 = 0xffffffff;
+	for (i = 0; i < 4; i++) {
+		arch->bridge.pcie_busnum[i]   = 0x0;
+		arch->bridge.pcie_membase[i]  = 0x0;
+		arch->bridge.pcie_memlimit[i] = 0x0;
+		arch->bridge.pcie_iobase[i]   = 0x0;
+		arch->bridge.pcie_iolimit[i]  = 0x0;
+	}
+}
+
+static void xlp_kvm_init_pcie(struct kvm_arch *arch)
+{
+	int i;
+
+	/* by default, no bus/device attached */
+	for (i = 0; i < 4; i++)
+		arch->pcie.link[i].config0 = 0xffffffff;
+}
+
 void xlp_kvm_init_vm(struct kvm *kvm)
 {
 	struct kvm_arch *arch = &kvm->arch;
@@ -383,6 +406,8 @@ void xlp_kvm_init_vm(struct kvm *kvm)
 	xlp_kvm_init_uart0(arch);
 	xlp_kvm_init_pic(arch);
 	xlp_kvm_init_sysmgt(arch);
+	xlp_kvm_init_bridge(arch);
+	xlp_kvm_init_pcie(arch);
 }
 
 void kvm_save_guest_context(struct pt_regs *regs, struct kvm_vcpu_guest *guest)
diff --git a/arch/mips/netlogic/kvm/Makefile b/arch/mips/netlogic/kvm/Makefile
index a7c118c..b816d53 100644
--- a/arch/mips/netlogic/kvm/Makefile
+++ b/arch/mips/netlogic/kvm/Makefile
@@ -1,4 +1,5 @@
 EXTRA_CFLAGS := -Werror
 EXTRA_CFLAGS := $(CFLAGS)
 
-obj-y                    	= kvm_traps.o kvm_fault.o kvm_pic.o kvm_uart.o kvm_sysmgt.o kvm_fuse.o
+obj-y = kvm_traps.o kvm_fault.o kvm_pic.o kvm_uart.o kvm_sysmgt.o kvm_fuse.o \
+	kvm_bridge.o kvm_pcie.o
diff --git a/arch/mips/netlogic/kvm/kvm_bridge.c b/arch/mips/netlogic/kvm/kvm_bridge.c
new file mode 100644
index 0000000..7941a18
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_bridge.c
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+
+// printk("!!! bridge register: 0x%x, reg_num: %d, epc: 0x%lx\n", rindex, (int)reg_num, regs->cp0_epc);
+
+	if (rindex == 0x0) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.config0;
+			return;
+		}
+	}
+	else if (rindex == 0x99 || rindex == 0x9a || rindex == 0x9b
+		|| rindex == 0x9c) {
+		/* pcie link 0, 1, 2, 3 */
+		if (!write) {
+			regs->regs[reg_num] = (uint32_t)arch->bridge.pcie_membase[rindex - 0x99];
+// printk("!!! return value: 0x%lx\n", regs->regs[reg_num]);
+			return;
+		}
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_fault.c b/arch/mips/netlogic/kvm/kvm_fault.c
index 2ca1dec..ab9c43d 100644
--- a/arch/mips/netlogic/kvm/kvm_fault.c
+++ b/arch/mips/netlogic/kvm/kvm_fault.c
@@ -248,7 +248,27 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 			return 0;
 		}
 
-		if ((address & 0xfffff000) == 0x18110000) {
+		if ((address & 0xfffff000) == 0x18000000) {
+			/* bridge: bus 0, dev 0, func 0 */
+			kvm_handle_pcie_bridge(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18108000) {
+			/* pcie link 0: dev 1, func 0 */
+			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 0);
+		}
+		else if ((address & 0xfffff000) == 0x18109000) {
+			/* pcie link 1: dev 1, func 1 */
+			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 1);
+		}
+		else if ((address & 0xfffff000) == 0x1810a000) {
+			/* pcie link 2: dev 1, func 2 */
+			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 2);
+		}
+		else if ((address & 0xfffff000) == 0x1810b000) {
+			/* pcie link 3: dev 1, func 3 */
+			kvm_handle_pcie_pcie(regs, write, address & 0xfff, reg_num, 3);
+		}
+		else if ((address & 0xfffff000) == 0x18110000) {
 			/* pic: dev 2, func 0 */
 			kvm_handle_pcie_pic(regs, write, address & 0xfff, reg_num);
 		}
@@ -288,7 +308,6 @@ asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
 				printk("caught one guest pcie address: %lx, epc %lx\n",
 						address, regs->cp0_epc);
 			}
-
 		}
 
 		compute_guest_return_epc(regs, epc_badinstr);
diff --git a/arch/mips/netlogic/kvm/kvm_pcie.c b/arch/mips/netlogic/kvm/kvm_pcie.c
new file mode 100644
index 0000000..0fd40a1
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_pcie.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num, int link)
+{
+	unsigned int rindex = address >> 2;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+
+// printk("=== kvm_handle_pcie_pcie: address = 0x%lx, link: %d\n", address, link);
+
+	if (rindex == 0x0) {
+		if (!write) {
+			regs->regs[reg_num] = arch->pcie.link[link].config0;
+			return;
+		}
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
-- 
1.9.1

