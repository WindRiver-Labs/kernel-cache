From 51b9f14eb6e2bca939933a32f8ed9d063c9c762d Mon Sep 17 00:00:00 2001
From: Divya Sakthidharan <divyas@broadcom.com>
Date: Wed, 7 Nov 2012 11:26:47 +0530
Subject: [PATCH 618/762] oprofile: add oprofile support.

Based on Broadcom SDK 2.3.

Signed-off-by: Divya Sakthidharan <divyas@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/irq.c           |   27 +++++++++++++++++++++++++--
 arch/mips/oprofile/op_model_mips_xlp.c |   23 ++++++++++++++++-------
 2 files changed, 41 insertions(+), 9 deletions(-)

diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 615b84f..61b4d47 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -61,6 +61,21 @@ THE POSSIBILITY OF SUCH DAMAGE.
 /* Externs */
 extern void nlm_xlp_msgring_int_handler(int , struct pt_regs *);
 extern int xlp_get_ctrl_intmode(u8, int);
+#ifdef CONFIG_OPROFILE
+extern void nlm_common_oprofile_int_handler(int irq, void *dev_id,
+		                                         struct pt_regs *regs);
+void nlm_oprofile_interrupt(struct pt_regs *regs, int irq)
+{
+
+	int    perfctr_overflow = 0;
+	perfctr_overflow = ((read_c0_cause() >> 26) & 0x1);
+			         
+	if (perfctr_overflow) {
+		nlm_common_oprofile_int_handler (irq, NULL, regs);
+	} 
+}
+
+#endif          
 
 /* xlp_irq_mask is retained for legacy. It can be removed at a later point of
  * time. Initially it was meant to keep a copy of present interrupt mask; with
@@ -402,6 +417,13 @@ asmlinkage void plat_irq_dispatch(void)
 		eirr &= ~(1ULL << XLP_IRQ_TIMER_RVEC);
 		if (!eirr) return;
 	}
+#ifdef CONFIG_OPROFILE
+	if (eirr & (1ULL << XLP_IRQ_OPROFILE_RVEC)) {
+		nlm_oprofile_interrupt(pt_regs, XLP_IRQ_TIMER_RVEC); 
+		eirr &= ~(1ULL << XLP_IRQ_OPROFILE_RVEC);
+		if (!eirr) return;
+	}
+#endif
 #else
 	/* Dedicated processing only for timer interrupt (RVEC 26, IRT 12) */
 	if (eirr & (1ULL << XLP_PIC_SYSTIMER_RVEC)) {
@@ -413,7 +435,6 @@ asmlinkage void plat_irq_dispatch(void)
 #endif
 	/* Loop till all bits of eirr is cleared */
 	while (eirr) {
-
 	rvec = __ilog2_u64(eirr);
 	if (rvec == -1) return;
 	eirr &= ~(1ULL << rvec);
@@ -528,7 +549,6 @@ void __init init_xlp_irqs(void)
 	/* msgring interrupt */
 	set_percpu_irq(XLP_IRQ_MSGRING_RVEC, &xlp_cpu_intr);
 	msgring_irq_init();
-//	set_percpu_irq(XLP_IRQ_PERFCTR, &xlp_cpu_intr);
 #if defined CONFIG_XLP_REPLACE_R4K_TIMER
 #error "Has to fix timer interrupt setup for CONFIG_XLP_REPLACE_R4K_TIMER"
 #else
@@ -560,6 +580,9 @@ void __init init_xlp_irqs(void)
 			(1ULL << XLP_IRQ_IPI_SMP_KGDB_RVEC) |
 #endif
 #endif
+#ifdef CONFIG_OPROFILE
+			(1ULL << XLP_IRQ_OPROFILE_RVEC) |
+#endif
 			(1ULL << XLP_IRQ_MSGRING_RVEC) |
 			(0x3ULL	<< (XLP_IRQ_RESERVED_MAX + 31)) | /* nor, nand, spi and mmc on xlp3xx*/
 			(0x3ULL << (XLP_IRQ_RESERVED_MAX + 35)) | /* gpio */
diff --git a/arch/mips/oprofile/op_model_mips_xlp.c b/arch/mips/oprofile/op_model_mips_xlp.c
index b62eac9..fd00e17 100644
--- a/arch/mips/oprofile/op_model_mips_xlp.c
+++ b/arch/mips/oprofile/op_model_mips_xlp.c
@@ -27,6 +27,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
+#include <linux/slab.h>
 #include <asm/mipsregs.h>
 
 #include "op_impl.h"
@@ -42,7 +43,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NETLOGIC_PMC_COUNT_ALL_THREADS	(1U << 25)
 
 #define XLP_MAX_PERF_COUNTERS 4
-#define XLP_MAX_CPU_CORES 8
 #define XLP_MAX_CPUS 32
 
 extern struct op_mips_model op_model_xlp;
@@ -52,7 +52,7 @@ static struct nlm_common_register_config {
 	uint64_t reset_counter[XLP_MAX_PERF_COUNTERS];
 }reg;
 
-volatile int g_stop_pmc[XLP_MAX_CPUS];
+volatile int *g_stop_pmc = NULL;
 
 
 static void nlm_common_reg_setup(struct op_counter_config *ctr)
@@ -112,7 +112,7 @@ static void netlogic_cpu_start(void *args)
 	local_irq_restore(flags);
 
 	local_irq_save(flags);
-	g_stop_pmc[hard_smp_processor_id()] = 0;
+	*(g_stop_pmc + hard_smp_processor_id()) = 0;
 	local_irq_restore(flags);
 
 	wmb();
@@ -124,7 +124,7 @@ static void netlogic_cpu_stop(void *args)
 	unsigned long flags;
 
 	local_irq_save(flags);
-	g_stop_pmc[hard_smp_processor_id()] = 1;
+	*(g_stop_pmc +hard_smp_processor_id()) = 1;
 	local_irq_restore(flags);
 
 	/* Stop all counters on current CPU */
@@ -149,7 +149,7 @@ void nlm_common_oprofile_int_handler(int irq, void * dev_id,
 	uint64_t counter3, counter4;
 	int h_id = hard_smp_processor_id();/* 0, 1, 2, 3, 4, .....31 */
 
-	if(g_stop_pmc[h_id])
+	if (*(g_stop_pmc + h_id)) 
 		return;
 
 	counter1 = __read_64bit_c0_register ($25, 1);
@@ -216,17 +216,26 @@ static void nlm_common_reset_perf_counters(void)
 static int nlm_common_init(void)
 {
 	int i;
+	int online_nodes =num_online_nodes();
+	int total_cpus = online_nodes * XLP_MAX_CPUS;
+
+	g_stop_pmc = kmalloc((sizeof (int) * total_cpus), GFP_KERNEL);
+	if(!g_stop_pmc)
+		return -1;
+
+	for(i=0; i < total_cpus; i++)
+		*(g_stop_pmc + i) = 1;
 
-	for(i=0; i < XLP_MAX_CPUS; i++)
-		g_stop_pmc[i] = 1;
 	nlm_common_reset_perf_counters();
 
+
 	return 0;
 }
 
 static void nlm_common_exit(void)
 {
 	nlm_common_reset_perf_counters();
+	kfree((void *)g_stop_pmc);
 	return;
 }
 
-- 
1.7.0.4

