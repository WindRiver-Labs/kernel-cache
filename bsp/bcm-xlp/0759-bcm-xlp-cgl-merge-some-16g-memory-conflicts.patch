From 6449497d89499620acb449a9be672fbf60cfa59c Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Tue, 4 Jun 2013 15:32:18 +0800
Subject: [PATCH 759/762] bcm-xlp-cgl: merge some 16g memory conflicts

Merge some 16g memory conflicts.

Based on Broadcom SDK 2.3.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/fault.c |   44 ++++++++++++++++++++++++++++++++++++++++++++
 kernel/fork.c        |    4 ++++
 mm/memory.c          |   33 +++++++++++++++++++++++++++++++++
 mm/mmap.c            |    8 ++++++++
 4 files changed, 89 insertions(+), 0 deletions(-)

diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index 87fdc85..531a79b 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -48,6 +48,50 @@ void pax_report_insns(struct pt_regs *regs, void *pc, void *sp)
 }
 #endif
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+#define ENTER_CRITICAL(flags) local_irq_save(flags)
+#define EXIT_CRITICAL(flags) local_irq_restore(flags)
+
+extern void dump_pgtable(pgd_t *pgd);
+extern void print_pgtable(unsigned long, unsigned long);
+
+extern unsigned long NONWIRED_START, NONWIRED_END;
+
+static void update_kernel_tlb(unsigned long address)
+{
+	unsigned long flags;
+	pgd_t *pgdp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int pid;
+	unsigned long config6_flags;
+
+	ENTER_CRITICAL(flags);
+	disable_pgwalker(config6_flags);
+
+	pid = read_c0_entryhi() & ASID_MASK;
+	address &= (PAGE_MASK << 1);
+	write_c0_entryhi(address | pid);
+	pgdp = pgd_offset_k(address);
+	mtc0_tlbw_hazard();
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
+	{
+		ptep = pte_offset_map(pmdp, address);
+
+		write_c0_entrylo0(pte_to_entrylo(pte_val(*ptep++)));
+		write_c0_entrylo1(pte_to_entrylo(pte_val(*ptep)));
+		mtc0_tlbw_hazard();
+		tlb_write_random();
+	}
+	tlbw_use_hazard();
+//      FLUSH_ITLB_VM(vma);
+	enable_pgwalker(config6_flags);
+	EXIT_CRITICAL(flags);
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff --git a/kernel/fork.c b/kernel/fork.c
index 50feda1..061c626 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -340,7 +340,11 @@ static struct vm_area_struct *dup_vma(struct mm_struct *mm, struct mm_struct *ol
 			goto fail_nomem;
 		charge = len;
 	}
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 	tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+#endif
 	if (!tmp)
 		goto fail_nomem;
 	*tmp = *mpnt;
diff --git a/mm/memory.c b/mm/memory.c
index a45143c..568a3d4 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4485,3 +4485,36 @@ void copy_user_huge_page(struct page *dst, struct page *src,
 	}
 }
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE || CONFIG_HUGETLBFS */
+
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+#include <asm/mach-netlogic/mmu.h>
+
+int __init map_kernel_addrspace(unsigned long addr, unsigned long pfn,
+				unsigned long max_pfn)
+{
+	pgd_t *pgd;
+	unsigned long end;
+	unsigned long next;
+	pgprot_t prot;
+	int err;
+
+	printk("(%s): addr = 0x%lx, pfn = 0x%lx, max_pfn = 0x%lx\n", __func__,
+		addr, pfn, max_pfn);
+
+	end = addr + ((max_pfn - pfn) << PAGE_SHIFT);
+
+	prot = __pgprot(KERNEL_PAGE_ATTR);
+	pfn -= addr >> PAGE_SHIFT;
+	pgd = pgd_offset(&init_mm, addr);
+	do {
+		next = pgd_addr_end(addr, end);
+		err = remap_pud_range(&init_mm, pgd, addr, next,
+		pfn + (addr >> PAGE_SHIFT), prot);
+		if (err)
+			break;
+	} while (pgd++, addr = next, addr != end);
+
+	return err;
+}
+#endif /* CONFIG_NLM_16G_MEM_SUPPORT */
+
diff --git a/mm/mmap.c b/mm/mmap.c
index f034309..4d1e5ea 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -2316,7 +2316,11 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 	vma_m = pax_find_mirror_vma(vma);
 #endif
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
+#endif
 	if (!new)
 		goto out_err;
 
@@ -2696,7 +2700,11 @@ static unsigned long do_brk(unsigned long addr, unsigned long len)
 	/*
 	 * create a vma struct for an anonymous mapping
 	 */
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL | GFP_DMA);
+#else
 	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+#endif
 	if (!vma) {
 		vm_unacct_memory(charged);
 		return -ENOMEM;
-- 
1.7.0.4

