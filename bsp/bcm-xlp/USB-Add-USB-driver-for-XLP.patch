From 9d9dd13407dc71955aed4317e261b42d1e92535e Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Thu, 11 Oct 2012 22:47:57 +0530
Subject: [PATCH 604/761] USB : Add USB driver for XLP

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anurag.gopinath@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp_usb.h |   21 +++++
 arch/mips/netlogic/xlp/Makefile          |    1 +
 arch/mips/netlogic/xlp/platform.c        |   43 ----------
 arch/mips/netlogic/xlp/usb-init.c        |  128 ++++++++++++++++++++++++++++++
 drivers/usb/host/ehci-pci.c              |   79 ++----------------
 drivers/usb/host/ohci-pci.c              |  104 +-----------------------
 6 files changed, 158 insertions(+), 218 deletions(-)
 create mode 100644 arch/mips/netlogic/xlp/usb-init.c

diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
index 49b5e13..004f891 100644
--- a/arch/mips/include/asm/netlogic/xlp_usb.h
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -28,6 +28,27 @@
 #ifndef __XLP_USB_H
 #define __XLP_USB_H
 
+#define USB_CTL_0                      0x41
+#define USB_PHY_0                      0x4A
+#define USB_PHY_RESET                  0x01
+#define USB_PHY_PORT_RESET_0           0x10
+#define USB_PHY_PORT_RESET_1           0x20
+#define USB_CONTROLLER_RESET           0x01
+#define USB_INT_STATUS                 0x4E
+#define USB_INT_EN                     0x4F
+#define USB_PHY_INTERRUPT_EN           0x01
+#define USB_OHCI_INTERRUPT_EN          0x02
+#define USB_OHCI_INTERRUPT1_EN         0x04
+#define USB_OHCI_INTERRUPT2_EN         0x08
+#define USB_CTRL_INTERRUPT_EN          0x10
+
+#define PIC_IRT_EHCI_0                  115
+#define PIC_IRT_OHCI_0                  116
+#define PIC_IRT_OHCI_1                  117
+#define PIC_IRT_EHCI_1                  118
+#define PIC_IRT_OHCI_2                  119
+#define PIC_IRT_OHCI_3                  120
+
 static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
 {
 	volatile uint64_t mmio;
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 7361f0e..efe6f18 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_NLM_XLP) += cop2.o
 obj-$(CONFIG_XLP_CPUFREQ) += xlp-cpufreq.o
 obj-$(CONFIG_SATA_AHCI) += sata-init.o
 obj-$(CONFIG_RAPIDIO)  += xlp_srio.o
+obj-$(CONFIG_USB) += usb-init.o
 
 ifeq ($(CONFIG_XEN),y)
 obj-y += xenbootinfo.o
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index fcee2d8..45a87ad 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -112,46 +112,6 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].serial_out    = xlp_uart_out;
 }
 
-#ifdef CONFIG_USB
-static void xlp_usb_hw_start_controller(int node, int ctrl_no)
-{
-	int val;
-	/* Reset USB phy */
-	val = usb_reg_read( node, ctrl_no, XLP_USB_PHY0);
-
-	if(ctrl_no == 0)
-		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
-	else if(ctrl_no == 3)
-		val &= ~(USBPHYPORTRESET0 | USBPHYPORTRESET1);
-	usb_reg_write(node, ctrl_no, XLP_USB_PHY0, val);
-
-	udelay(2000);
-	/* Bring usb controller out of reset
- *  	 */
-	val = usb_reg_read( node, ctrl_no, XLP_USB_CTL0);
-	val &= ~(USBCONTROLLERRESET );
-	val |= 0x4;
-	usb_reg_write(node, ctrl_no, XLP_USB_CTL0, val);
-
-	return;
-}
-
-static void xlp_usb_hw_start(void)
-{
-	int n, online;
-	int total=num_possible_nodes();
-
-	for(n=0; n<total; n++) {
-		online=node_online(n);
-		if(!online)	continue;
-
-		xlp_usb_hw_start_controller(n, 0);
-		xlp_usb_hw_start_controller(n, 3);
-	}
-}
-#endif
-
-
 struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
 	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
 	{XLP_DEVID_I2C,	 "i2c-xlp",	8,	0, 	PLAT_DRV},
@@ -263,9 +223,6 @@ static int __init platform_devinit(void)
 {
 	xlp_find_pci_dev();
 	xlp_nor_flash_dev_init();
-#ifdef CONFIG_USB
-	xlp_usb_hw_start();
-#endif
 	return 0;
 }
 
diff --git a/arch/mips/netlogic/xlp/usb-init.c b/arch/mips/netlogic/xlp/usb-init.c
new file mode 100644
index 0000000..ccc9635
--- /dev/null
+++ b/arch/mips/netlogic/xlp/usb-init.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_usb.h>
+
+static void nlm_usb_intr_en(int node, int port)
+{
+	uint32_t val;
+
+        val = usb_reg_read(node, port, USB_INT_EN);
+	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN |
+		USB_OHCI_INTERRUPT1_EN | USB_OHCI_INTERRUPT2_EN;
+        usb_reg_write(node, port, USB_INT_EN, val);
+
+}
+
+static void nlm_usb_hw_reset(int node, int port)
+{
+	uint32_t val;
+
+	/* reset USB phy */
+        val = usb_reg_read(node, port, USB_PHY_0);
+	val &= ~(USB_PHY_RESET | USB_PHY_PORT_RESET_0 | USB_PHY_PORT_RESET_1);
+        usb_reg_write(node, port, USB_PHY_0, val);
+
+	mdelay(100);
+        val = usb_reg_read(node, port, USB_CTL_0);
+	val &= ~(USB_CONTROLLER_RESET);
+	val |= 0x4;
+        usb_reg_write(node, port, USB_CTL_0, val);
+}
+
+static int __init nlm_platform_usb_init(void)
+{
+        int n, online;
+        int total=num_possible_nodes();
+
+	pr_info("Initializing USB Interface\n");
+        for(n=0; n<total; n++) {
+                online=node_online(n);
+                if(!online)     continue;
+
+	        nlm_usb_hw_reset(n, 0);
+	        nlm_usb_hw_reset(n, 3);
+
+	        /* Enable PHY interrupts */
+	        nlm_usb_intr_en(n, 0);
+	        nlm_usb_intr_en(n, 3);
+        }
+
+	return 0;
+}
+
+arch_initcall(nlm_platform_usb_init);
+
+static u64 xlp_usb_dmamask = ~(u32)0;
+
+/* Fixup the IRQ for USB devices which is exist on XLP SOC PCIE bus */
+static void nlm_usb_fixup_final(struct pci_dev *dev)
+{
+	dev->dev.dma_mask		= &xlp_usb_dmamask;
+	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(64);
+	switch (dev->devfn) {
+	case 0x10:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_EHCI_0);
+	       break;
+	case 0x11:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_0);
+	       break;
+	case 0x12:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_1);
+	       break;
+	case 0x13:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_EHCI_1);
+	       break;
+	case 0x14:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_2);
+	       break;
+	case 0x15:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_3);
+	       break;
+	}
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_EHCI,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_OHCI,
+		nlm_usb_fixup_final);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index de6be0b..a2dbaf3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -1,11 +1,3 @@
-/* **********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
- * This is a derived work from software originally provided by the external
- * entity identified below. The licensing terms and warranties specified in
- * the header of the original work apply to this derived work.
- *
- * *****************************#NETL_1#********************************/
-
 /*
  * EHCI HCD (Host Controller Driver) PCI Bus Glue.
  *
@@ -33,48 +25,6 @@
 /* defined here to avoid adding to pci_ids.h for single instance use */
 #define PCI_DEVICE_ID_INTEL_CE4100_USB	0x2e70
 
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-
-#include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/xlp_hal_pic.h>
-#include <asm/netlogic/xlp.h>
-#include <asm/netlogic/xlp_usb.h>
-volatile uint64_t *ehci_regs;
-
-static void xlp_usb_hw_start(int ctrl_no)
-{
-	int val;
-
-	/* enable USB interrupts
-	 */
-	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT1_EN;
-	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
-
-	return;
-}
-
-int xlp_ehci_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
-{
-	int irq, irt, ctrl_no;
-
-	ctrl_no = dev->devfn & 0xF;
-
-	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
-	irq = xlp_pic_irt_to_irq(irt);
-
-	if (!irq) {
-		printk("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", 
-				pci_name(dev));
-		return -ENODEV;
-	}
-
-	dev->irq = irq;
-	xlp_usb_hw_start(ctrl_no);
-
-	return usb_hcd_pci_probe(dev, id);
-}
-#endif
-
 /*-------------------------------------------------------------------------*/
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -116,15 +66,15 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 #endif
 		}
 		break;
-	case PCI_VENDOR_ID_NETLOGIC:
-		if (pdev->device == 0x1007) {
+       case PCI_VENDOR_ID_NETLOGIC:
+               if (pdev->device == 0x1007) {
 #if defined CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
-			ehci->big_endian_mmio = 1;
+                        ehci->big_endian_mmio = 1;
 #else
-			ehci->big_endian_mmio = 0;
+                        ehci->big_endian_mmio = 0;
 #endif
-		}
-		break;
+                   }
+                   break;
 	}
 
 	ehci->caps = hcd->regs;
@@ -588,22 +538,10 @@ static const struct hc_driver ehci_pci_hc_driver = {
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
 static const struct pci_device_id pci_ids [] = { {
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-	{
-		.vendor		 = PCI_VENDOR_ID_NETLOGIC,
-		.device		 = XLP_DEVID_EHCI,
-		.subvendor	 = 0,
-		.subdevice	 = 0,
-		.class		 = PCI_CLASS_SERIAL_USB_EHCI,
-		.class_mask	 = ~0,
-		.driver_data =	(unsigned long) &ehci_pci_hc_driver,
-	},
-#else
 	/* handle any USB 2.0 EHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	}, {
-#endif
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),
 	.driver_data = (unsigned long) &ehci_pci_hc_driver,
 	},
@@ -615,11 +553,8 @@ MODULE_DEVICE_TABLE(pci, pci_ids);
 static struct pci_driver ehci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-	.probe =	xlp_ehci_hcd_pci_probe,
-#else
+
 	.probe =	usb_hcd_pci_probe,
-#endif
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 8c2fefe..1843bb6 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -1,11 +1,3 @@
-/***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
- * This is a derived work from software originally provided by the external
- * entity identified below. The licensing terms and warranties specified in
- * the header of the original work apply to this derived work.
- *
- * *****************************#NETL_1#********************************/
-
 /*
  * OHCI HCD (Host Controller Driver) for USB.
  *
@@ -30,83 +22,6 @@
 #include <linux/io.h>
 
 
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-
-#include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/xlp.h>
-#include <asm/netlogic/xlp_usb.h>
-
-static void xlp_usb_start_ohc(int ctrl_no)
-{
-	/* enable interrupts
-	 */
-	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN,
-			USB_CTRL_INTERRUPT_EN
-			| USB_OHCI_INTERRUPT12_EN
-			| USB_OHCI_INTERRUPT1_EN);
-	return;
-}
-
-static void xlp_usb_stop_ohc(int ctrl_no)
-{
-	int val;
-
-	/* disable interrupts
-	 */
-	val = usb_reg_read(0, ctrl_no, XLP_USB_INT_EN);
-	val &= ~(USB_CTRL_INTERRUPT_EN
-			| USB_OHCI_INTERRUPT12_EN
-			| USB_OHCI_INTERRUPT1_EN);
-	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
-
-	return;
-}
-
-int xlp_ohci_hcd_pci_probe(struct pci_dev *dev, 
-		const struct pci_device_id *id)
-{
-	int irq, irt, ctrl_no, val;
-
-	ctrl_no = dev->devfn & 0xF;
-
-	irt = usb_reg_read( 0, ctrl_no, 0x3D) & 0xFFFF;
-	irq = xlp_pic_irt_to_irq(irt);
-
-	if (!irq) {
-		printk("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n", 
-				pci_name(dev));
-		return -ENODEV;
-	}
-
-	dev->irq = irq;
-	val = usb_hcd_pci_probe(dev, id);
-	xlp_usb_start_ohc(ctrl_no);
-	return val;
-}
-
-void xlp_ohci_hcd_pci_remove(struct pci_dev *dev)
-{
-	int ctrl_no;
-
-	ctrl_no = dev->devfn & 0xF;
-	xlp_usb_stop_ohc(ctrl_no);
-
-	usb_hcd_pci_remove(dev);
-	return;
-}
-
-void xlp_ohci_hcd_pci_shutdown(struct pci_dev *dev)
-{
-	int ctrl_no;
-
-	ctrl_no = dev->devfn & 0xF;
-	xlp_usb_stop_ohc(ctrl_no);
-
-	usb_hcd_pci_shutdown(dev);
-	return;
-}
-#endif
-
 /*-------------------------------------------------------------------------*/
 
 static int broken_suspend(struct usb_hcd *hcd)
@@ -479,22 +394,10 @@ static const struct hc_driver ohci_pci_hc_driver = {
 
 
 static const struct pci_device_id pci_ids [] = { {
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-	{
-		.vendor         = PCI_VENDOR_ID_NETLOGIC,
-		.device         = XLP_DEVID_OHCI,
-		.subvendor      = 0,
-		.subdevice      = 0,
-		.class          = PCI_CLASS_SERIAL_USB_OHCI,
-		.class_mask     = ~0,
-		.driver_data =  (unsigned long) &ohci_pci_hc_driver,
-	},
-#else
 	/* handle any USB OHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	}, {
-#endif
 	/* The device in the ConneXT I/O hub has no class reg */
 	PCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_OHCI),
 	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
@@ -506,15 +409,10 @@ MODULE_DEVICE_TABLE (pci, pci_ids);
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
-	.probe =	xlp_ohci_hcd_pci_probe,
-	.remove =	xlp_ohci_hcd_pci_remove,
-	.shutdown =	xlp_ohci_hcd_pci_shutdown,
-#else
+
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
-#endif
 
 #ifdef CONFIG_PM_SLEEP
 	.driver =	{
-- 
1.7.10.4

