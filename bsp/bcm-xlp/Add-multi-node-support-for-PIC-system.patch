From 766147508b7c7a88fdf798cd675e3ff2cb2e48e1 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@netlogicmicro.com>
Date: Mon, 23 Jan 2012 15:11:25 -0800
Subject: [PATCH 526/761] Add multi-node support for PIC system

   o In current implementation, the interrupt is served only
     on the local node.

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/xlp_hal_pic.c |   80 ++++++++++++++++++++++++++++++----
 1 file changed, 71 insertions(+), 9 deletions(-)

diff --git a/arch/mips/netlogic/xlp/xlp_hal_pic.c b/arch/mips/netlogic/xlp/xlp_hal_pic.c
index 6ed7bb2..8392ae6 100644
--- a/arch/mips/netlogic/xlp/xlp_hal_pic.c
+++ b/arch/mips/netlogic/xlp/xlp_hal_pic.c
@@ -1,5 +1,11 @@
-#include <asm/netlogic/xlp_hal_pic.h>
 #include <linux/types.h>
+#ifdef CONFIG_NUMA
+#include <asm/topology.h>
+#endif
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp_hal_pic.h>
+#include <asm/smp.h>
 
 /*
  * __nlm_hal_request_irq
@@ -16,11 +22,25 @@
 int __nlm_hal_request_irq(int irt, int rvec)
 {
         uint64_t  val;
-        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
-        /* clear DB and DTE field */
+
+#ifndef CONFIG_NUMA
+	val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
+	/* clear DB and DTE field */
 	val &= ~(0x3f << 20);
 	val |= ((rvec << 20) | (1 << 31));
 	nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt), val);
+#else
+	uint8_t	nid;
+	
+	for_each_online_node (nid) {
+		uint64_t xlp_pic_base = nlm_hal_get_dev_base(nid, 0, 8, 4);
+
+		val = nlm_hal_read_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt);
+		val &= ~(0x3f << 20);
+		val |= ((rvec << 20) | (1 << 31));
+		nlm_hal_write_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt, val);
+	}
+#endif
         return 0;
 }
 
@@ -37,9 +57,21 @@ void __nlm_hal_release_irq(int irt)
 {
         uint64_t  val;
 
-        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
+#ifndef CONFIG_NUMA
+	val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
 	val &= ~(1 << 31);
 	nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt), val);
+#else
+	uint8_t	nid;
+	
+	for_each_online_node (nid) {
+		uint64_t xlp_pic_base = nlm_hal_get_dev_base(nid, 0, 8, 4);
+
+		val = nlm_hal_read_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt);
+		val &= ~(1 << 31);
+		nlm_hal_write_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt, val);
+	}
+#endif
 }
 
 /*
@@ -51,7 +83,11 @@ void __nlm_hal_set_irt_to_cpu(int irt, int cpu)
 {
         uint64_t val;
 	uint cpuid, threadid;
-	uint nodeid = 0;	/* TBD */
+	uint nodeid;
+#ifdef CONFIG_NUMA
+	uint64_t xlp_pic_base;
+#endif
+
 	/* DT is set 1 ==> Destination thread is specificed in DB and
 	 * DTE fields.
 	 * DB : (18-17 : Node id)
@@ -62,14 +98,40 @@ void __nlm_hal_set_irt_to_cpu(int irt, int cpu)
 	 * threadid = (cpu & 0xf)
 	 * cpuid = (cpu >> 4)
 	 */
+#ifndef CONFIG_NUMA
+	nodeid = 0;
 	cpuid = (cpu >> 4) & 1;	/* DB group of CPU */
 	threadid = cpu & 0xf;	/* range 0 - 15 for threadid */
-        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
-        val &= ~(0xfffff);	/* Clear DT, DB and DTE */
-        val |= ((1 << 19) | (nodeid << 17) | (cpuid << 16) | ( 1 << threadid));
-        nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt), val);
+	val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
+	val &= ~(0xfffff);	/* Clear DT, DB and DTE */
+	val |= ((1 << 19) | (nodeid << 17) | (cpuid << 16) | ( 1 << threadid));
+	nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt), val);
+#else
+	nodeid = cpu_to_node(cpu);
+	cpuid = (cpu >> 4) & 1;
+	threadid = cpu & 0xf;
+	xlp_pic_base = nlm_hal_get_dev_base(nodeid, 0, 8, 4);
+	val = nlm_hal_read_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt);
+	val &= ~(0xfffff);
+	val |= ((1 << 19) | (nodeid << 17) | (cpuid << 16) | ( 1 << threadid));
+	nlm_hal_write_64bit_reg(xlp_pic_base, (0xB4 >> 1) + irt, val);
+#endif
 }
 
+#ifdef CONFIG_NUMA
+void xlp_numa_ack_pic(int irt)
+{
+	int 	 nid = cpu_to_node(smp_processor_id());
+	uint64_t xlp_pic_base = nlm_hal_get_dev_base(nid, 0, 8, 4);
+
+	nlm_hal_write_64bit_reg(xlp_pic_base, 0x50 >> 1, irt);
+
+	/* Ack the Status register for Watchdog & System timers */
+	if (irt < 12)
+		nlm_hal_write_64bit_reg(xlp_pic_base, 0x44 >> 1, 1 << irt);
+}
+#endif
+
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/kernel.h>
 #include <linux/module.h>
-- 
1.7.10.4

