From 1b5619a719ac37b00f883d7738fe7baaaf3820c6 Mon Sep 17 00:00:00 2001
From: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Date: Sun, 23 May 2010 14:35:10 -0700
Subject: [PATCH 033/761] Cleanup for XLP setup.c file

Part of changes to xlp setup.c file,
removing XLR hybridOS code as well as
parts of the now-deprecated loader
code.

Based on Broadcom SDK 2.3.

Signed-off-by: Nebu Philips <nphilips@jakarta.razamicroelectronics.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/setup.c |  806 +++++++++++++++++++++++++++++++++-------
 1 file changed, 682 insertions(+), 124 deletions(-)

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 564eb7a..2b5cd1b 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -1,58 +1,84 @@
-/*
- * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+/* **********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
  * reserved.
- *
- * This software is available to you under a choice of one of two
- * licenses.  You may choose to be licensed under the terms of the GNU
- * General Public License (GPL) Version 2, available from the file
- * COPYING in the main directory of this source tree, or the NetLogic
- * license below:
- *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
+ * modification, are permitted provided that the following conditions are
+ * met:
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ * notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * ****************************#NETL_2#*******************************
  */
 
-#include <linux/kernel.h>
-#include <linux/serial_8250.h>
-#include <linux/pm.h>
+/*
+ * Setup code for Netlogic's XLP-based boards
+ */
+
+#include <linux/spinlock.h>
+#include <linux/mm.h>
 #include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/pm.h>
 
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
-#include <asm/bootinfo.h>
-
-#include <linux/of_fdt.h>
-#include <linux/of_platform.h>
-#include <linux/of_device.h>
+#include <linux/interrupt.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
 
-#include <asm/netlogic/haldefs.h>
-#include <asm/netlogic/common.h>
+#include <asm/netlogic/sim.h>
+#include <asm/mipsregs.h>
+#include <asm/netlogic/mips-exts.h>
+#include <asm/netlogic/iomap.h>
+#include <asm/netlogic/debug.h>
+#include <asm/netlogic/xlr_user_mac.h>
+#include <asm/netlogic/msgring.h>
+
+#include <asm/netlogic/nlm_common_loader.h>
+#include <user/netlogic/nlm_common_loader.h>
+#include <asm/netlogic/nlm_pcix_gen_dev.h>
+#include <asm/netlogic/memory-exclusion.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/mach-netlogic/mmu.h>
+#include <asm/netlogic/bootinfo.h>
+
+#ifdef NLM_BRIDGE_WKAROUND
+#include <asm/netlogic/nlm_rw_lock.h>
+#include <asm/netlogic/global_shmem.h>
+nlm_rwlock_t *nlm_bridge_lock;
+EXPORT_SYMBOL(nlm_bridge_lock);
+int nlm_enable_br_wrkaround = 0;
+EXPORT_SYMBOL(nlm_enable_br_wrkaround);
+#endif
 
-#include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/xlp.h>
-#include <asm/netlogic/xlp-hal/sys.h>
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+#endif
 
-#include <asm/netlogic/sim.h>
+#include "../boot/ops.h"
 
 /* Certain macros for this file
  */
@@ -60,9 +86,6 @@
 #define TRUE 					1
 #define FALSE 					0
 
-#define LOADER_UBOOT			1
-#define LOADER_OTHER			2
-
 #define GPIO_SWRESET_REG 		8
 
 #define DEFAULT_LINUX_CPU_MASK 	0x1
@@ -86,10 +109,17 @@
 		memset(kuseg_mem_map, 0, (sizeof(struct kuseg_mem_info) * 4));	\
 		use_kuseg_defaults(map);
 
+extern void *fdt;
+static char prop_buf[MAX_PROP_LEN];
 extern char _end;
 
+extern void *fdt_init(void *blob);
+extern void *simple_alloc_init(char *base, unsigned long heap_size,
+		unsigned long granularity, unsigned long max_allocs);
+
 /* by default, do not assume u-boot */
-int loader_used = LOADER_OTHER; 
+int loader_used = LOADER_UBOOT;
+int onlinemask = 0x1;
 
 /* Struct for temp. allocation
  * of sp/gp for secondary CPUs 
@@ -102,17 +132,22 @@ struct xlr_stack_pages xlr_stack_pages_temp
 __attribute__((__section__(".data.init_task"),
 	       __aligned__(THREAD_SIZE)));
 
-extern void prom_pre_boot_secondary_cpus(void *);
-
 struct proc_dir_entry *nlm_root_proc;
 EXPORT_SYMBOL(nlm_root_proc);
 
+unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
+
+spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
+
+__u8 nlm_common_base_mac_addr[6];
+volatile nlm_common_loader_shared_struct_t *nlm_common_loader_sh_mem = NULL;
 /* used for command line parsing */
 uint32_t nlm_common_loader_kseg_start, nlm_common_loader_kseg_size;
 uint32_t nlm_common_loader_mask;
 /* Size of the shared memory b/w Linux userapp and rmios apps */
 uint32_t nlm_common_app_sh_mem_sz;
 unsigned long  nlm_common_app_shmem_start;
+static int index = 0;
 
 /* xls chip family variables */
 int chip_is_xls6xx = 0;
@@ -132,10 +167,247 @@ EXPORT_SYMBOL(chip_is_xls_b0);
 EXPORT_SYMBOL(chip_is_xls6xx_b0);
 EXPORT_SYMBOL(chip_is_xls4xx_b0);
 
-__u32 xlr_board_major_version = 0;
+int xlp_with_mac_driver = 0;
+EXPORT_SYMBOL(xlp_with_mac_driver);
+
+/* Environment Variables
+ */
+struct environment xlr_bldr_env ;
+
+__u32 xlr_board_major_version = NLM_XLR_BOARD_ARIZONA_I;
 __u32 xlr_board_minor_version = 0;
 
+struct kuseg_mem_info kuseg_mem_map[MAX_NUM_KUSEG_BLOCKS];
+
+void *nlm_common_psb_shm = 0;
+unsigned long nlm_common_psb_shm_size = 0;
+static int dyna_exc_index=0;
+extern unsigned long _text[];
+
+#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
+unsigned long nlm_asid_mask = 0x3f;
+unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
+#endif
+
+extern struct psb_info *nlm_boot_info;
+struct psb_info *prom_info = NULL;
 struct psb_info prom_info_copy; /* Bootloader prom_info is saved here */
+
+static struct physmap_info {
+	int type;
+	char *name;
+} psb_physmap_info[] =
+{
+	{ 0x01 , "Memory" },
+	{ 0x02 , " *** HOLE ***" },
+	{ 0x03 , "Exception Vectors" },
+	{ 0x04 , "Bootloader 0" },
+	{ 0x05 , "NMI Memory" },
+	{ 0x10 , "PCI ECFG Space" },
+	{ 0x11 , "PCIX IO Space"    },
+	{ 0x12 , "PCIX CFG Space"   },
+	{ 0x13 , "PCIX Memory Space"},
+	{ 0x14 , "HT IO Space"      },
+	{ 0x15 , "HT CFG Space" },
+	{ 0x16 , "HT Memory Space" },
+	{ 0x17 , "SRAM (QDR) Space" },
+	{ 0x18 , "Flash Region(Re-mapped)" },
+	{ 0x19 , "PCIE IO Space"    },
+	{ 0x1A , "PCIE CFG Space"   },
+	{ 0x1B , "PCIE Memory Space"},
+	{ 0xff , "Unknown type" }
+};
+
+struct boot_mem_map boot_physaddr_info;
+
+/* Maintain in ascending order of 
+ * the starting physical addresses 
+ */
+static struct boot_mem_map_exclude_region dynamic_exclude_regions[] = {
+	[0] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
+	[1] = {0, 0}, /* PCI Shared Mem Or RMIOS Lib Memory*/
+	[2] = {0, 0}, /* Loader KSEG0 region */
+	[3] = {0, 0}, /* Loader KUSEG region Block 1*/
+	[4] = {0, 0}, /* Loader KUSEG region Block 2 or Hybrid Mode exclusion*/
+	[5] = {0, 0}, /* Loader KUSEG region Block 3 or Hybrid Mode exclusion */
+	[6] = {0, 0}, /* Loader KUSEG region Block 4 or Hybrid Mode exclusion */
+	[7] = {0, 0}, /* Hybrid Mode exclusion*/
+	[8] = {0, 0}, /* END of the list - MUST be the last entry always */
+};
+
+static char *get_psb_physmap_name(int type)
+{
+	int i = 0;
+	int tsize = sizeof(psb_physmap_info) / sizeof(struct physmap_info);
+
+	for (i = 0; i < tsize; i++)	{
+		if ( (psb_physmap_info[i].type == type ) ||
+		    (psb_physmap_info[i].type == 0xff ) )
+			return psb_physmap_info[i].name;
+	}
+	return ("Unknown type");
+}
+
+/* Return value
+ * 	1 ==> IO (or not found)
+ *  0 ==> mem 
+ */
+int nlm_common_get_pgprot(unsigned long address)
+{
+	int i;
+	__u64 start=0, end=0;
+	char *name = NULL;
+
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		start = boot_physaddr_info.map[i].addr;
+		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
+		if ((address >= start) && (address < end)) {
+			name = get_psb_physmap_name(boot_physaddr_info.map[i].type);
+			if (!(strcmp(name, "Memory"))) {
+				return 0;
+			} else {
+				return 1;
+			}
+		}
+	}
+	return 1;
+}
+
+int valid_mmap_nlm_common_addr_range(unsigned long pfn)
+{
+	int i;
+	__u64 end=0;
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		end = boot_physaddr_info.map[i].addr + boot_physaddr_info.map[i].size;
+		end = end >> PAGE_SHIFT;
+		if (pfn <= (unsigned long)end)
+			return 1;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_NLM_XLP_SIM)
+const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
+#else
+const char *DEFAULT_CONSOLE_BOOT_PARAMS = "mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
+#endif
+const char *DEFAULT_INITRD_BOOT_PARAMS = "rdinit=/sbin/init ";
+
+const char *get_system_type(void)
+{
+#ifdef CONFIG_NLM_XLP
+	return "Netlogic XLP SIM";
+#else
+	if ( is_xls() )
+		return "Netlogic XLS";
+	return "Netlogic XLR";
+#endif
+}
+
+#ifdef CONFIG_SMP
+atomic_t cpus_rebooted = ATOMIC_INIT(0);
+#endif
+
+static void ptr_linux_exit(void)
+{
+#ifdef CONFIG_NLM_XLP
+	write_32bit_cfg_reg((uint32_t *)xlp_sys_base, 0x40 | CHIP_RESET, 1);
+#else
+	nlm_reg_t *mmio;
+
+	/* 
+	 * trigger a chip reset 
+	 */	
+	mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
+	netlogic_write_reg(mmio, GPIO_SWRESET_REG, 1);
+#endif
+	for ( ; ; ) 
+		cpu_wait();
+}
+
+void __init bus_error_init(void)
+{
+}
+
+void prom_reconfigure_thr_resources(void)
+{
+	unsigned int mmu_setup=0;
+	int i=0, count=0, dis_contig=0;
+	int value = 0;
+
+	__u32 online_map, thr_mask; 
+
+#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
+	uint32_t map;
+#endif
+
+	online_map = onlinemask;    /* from fdt */
+	
+	thr_mask = online_map >> (netlogic_cpu_id()<<2);
+
+#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
+	/* netlogic kernel configures this 
+	 */
+
+	if (nlm_shtlb && (nlm_asid_mask == 0x3f)) {
+		/* Global TLB will work only if all 
+		 * the enabled cores have all their
+		 * threads owned by Linux. 
+		 */
+		map = online_map;
+		for (i = 0; i < NR_CPUS; i += 4) {
+			if ((map & 0xf) && ((map & 0xf) != 0xf)) {
+				nlm_asid_mask = 0xff;
+				nlm_shtlb = 0;
+				printk("Disabling Shared TLB mode\n");
+				break;
+			}
+			map >>= 4;
+		}
+		if ((nlm_asid_mask == 0x3f) && (netlogic_thr_id() == 0)) {
+			mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
+			mmu_setup = mmu_setup | 0x1;
+			write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
+
+			printk("CPU %d: Enabled Shared TLB mode \n", 
+					netlogic_cpu_id());
+			return;
+		}
+	}
+	
+	return;
+
+#endif /* CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID */
+
+
+	 if (netlogic_thr_id() == 0) { 
+
+		for (i=0;i<4;i++) {
+			if (thr_mask & (1<<i)) {
+				if (i != count)
+					dis_contig = 1;
+				count++;
+			}
+		}
+
+		switch(count) {
+			case 1: value = 0x00; break;
+			case 2: value = 0x02; break;
+			default:
+					value = 0x03; break;
+		}
+
+		if (dis_contig)
+			value = 0x3; 
+
+		mmu_setup = read_32bit_nlm_ctrl_reg(4, 0);
+		mmu_setup = mmu_setup & ~0x06;
+		mmu_setup |= (value << 1);
+
+		write_32bit_nlm_ctrl_reg(4, 0, mmu_setup);
+	} 
+}
+
 int xlr_hybrid;
 int xlr_loader_support=0;
 int xlr_loader_sharedcore=0;
@@ -148,131 +420,417 @@ int xlr_console_pci_con_baud = 0;
 int xlr_boot_over_nfs = 0;
 
 unsigned long nlm_common_ebase = 0x0;
- 
-unsigned long long nlm_common_tlb_stats[NR_CPUS] __cacheline_aligned;
 
-/* default to uniprocessor */
-uint32_t nlm_coremask = 1, nlm_cpumask  = 1;
-int  nlm_threads_per_core = 1;
-extern u32 __dtb_start[];
+#if !defined(CONFIG_NLMCOMMON_MAC)
+struct user_mac_data *user_mac;
+struct xlr_user_mac_config xlr_user_mac;
+#endif
 
-void prom_reconfigure_thr_resources(void)
+static inline void init_default_macaddr(void)
 {
+	nlm_common_base_mac_addr[0] = 0x00;
+	nlm_common_base_mac_addr[1] = 0x01;
+	nlm_common_base_mac_addr[2] = 0x02;
+	nlm_common_base_mac_addr[3] = 0x03;
+	nlm_common_base_mac_addr[4] = 0x04;
+	nlm_common_base_mac_addr[5] = 0x05;
 }
 
-int nlm_common_get_pgprot(unsigned long address)
+static void setup_default_configuration(void)
 {
-	return 0;
+	xlr_hybrid = XLR_HYBRID_NONE;
+	xlr_user_mac.l4_extract = 0;
+	xlr_user_mac.fast_syscall = 1;
+	xlr_loader_support = 0;
+	xlr_loader_sharedcore = 0;
+	xlr_loader_own_gmac = 0;
+	xlr_loader_own_dma = 0;
+	xlr_linux_cpu_mask = DEFAULT_LINUX_CPU_MASK; 
+	nlm_common_loader_kseg_start = 0;
+	for ( index = 0 ; index < MAX_NUM_KUSEG_BLOCKS ; index++) {
+		kuseg_mem_map[index].start_addr = 0;
+		kuseg_mem_map[index].size = 0;
+	}
+	nlm_common_loader_kseg_size = 0;
+	nlm_common_loader_mask = DEFAULT_LOADER_MASK;
+
+	nlm_common_psb_shm = 0;
+
+	init_default_macaddr();
 }
 
-void plat_time_init(void)
+void exclude_hybrid_mem_region(void)
 {
+	if (xlr_loader_support){
+		return;
+	}
+	dynamic_exclude_regions[dyna_exc_index].start = 1<<20;
+	dynamic_exclude_regions[dyna_exc_index].end = 
+		(unsigned long long)(((unsigned long)&_text) & 0x1fffffffUL);
+	dyna_exc_index++;
 }
 
-int valid_mmap_nlm_common_addr_range(unsigned long pfn)
+#ifndef CONFIG_MAPPED_KERNEL
+static void xlr_early_hybrid_setup(char *str)
 {
-	return 0;
+
+	hybrid_str = str;
+
+
+    if ((strcmp(str, "=rmios_ipsec") == 0)||
+		 (strcmp(str, "rmios_ipsec") == 0)) {
+        exclude_hybrid_mem_region();
+	}
+	else if ((strcmp(str, "=rmios_tcpip_stack") == 0)||
+		 (strcmp(str, "rmios_tcpip_stack") == 0)) {
+		exclude_hybrid_mem_region();
+	}
 }
+#endif
 
-static void nlm_linux_exit(void)
+unsigned int __cpuinit get_c0_compare_int(void)
 {
-	nlm_write_sys_reg(nlm_sys_base, SYS_CHIP_RESET, 1);
-	for ( ; ; )
-		cpu_wait();
+    return IRQ_TIMER;
 }
 
-void __init plat_mem_setup(void)
+void plat_time_init(void)
 {
-	panic_timeout	= 5;
-	_machine_restart = (void (*)(char *))nlm_linux_exit;
-	_machine_halt	= nlm_linux_exit;
-	pm_power_off	= nlm_linux_exit;
+    extern void nlm_common_timer_setup(void);
+
+	if (loader_used == LOADER_UBOOT) {
+		/* this is currently hardcoded from
+		 * the bootloader value, to be fixed
+		 */
+    	mips_hpt_frequency = (unsigned int)0x5f5e1000;
+	}
+	else {
+    	mips_hpt_frequency = (unsigned int)prom_info->cpu_frequency;
+	}
+
+    printk("mips_hpt_frequency = %u\n", mips_hpt_frequency);
+
+    nlm_common_timer_setup();
 }
 
-#ifdef CONFIG_MAPPED_KERNEL
-#define secondary_cpus_bootup_func \
-	((unsigned long)prom_pre_boot_secondary_cpus - \
-	 (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
-#else
-#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
+#ifdef CONFIG_NLM_COMMON
+int avail_mem_above_4G;
+int force_usb __initdata = 0;
+static int __init xls_force_usb(char *p)
+{
+    force_usb = 1;
+        return 0;
+}
+early_param("forceusb", xls_force_usb);
+
+
+/* This routine is useful when USB is desired on
+ * 64-Bit Linux with DRAM mapped >4G. On such systems,
+ * since the XLS USB controller is 32-bit, USB is
+ * disabled. Use command line option 'forceusb' to
+ * enable it; This adjusts the mapped available mem
+ * to a max of till 0xFFFFFFFF.
+ */
+static void __init tweak_avail_dram_map(void) {
+
+    int j=0;
+    int nrmap_ctr = (boot_mem_map.nr_map - 1);
+
+    avail_mem_above_4G = 0;
+
+    for (j=nrmap_ctr; j>=0; j--) {
+        if ((boot_mem_map.map[j].addr + boot_mem_map.map[j].size)
+                > 0x100000000ULL) {
+            avail_mem_above_4G++;
+#ifdef CONFIG_64BIT
+            if (force_usb) {
+                printk(KERN_WARNING "[USB]:Re-adjusting Available DRAM map\n");
+                if (boot_mem_map.map[j].addr > 0x100000000ULL) {
+                    boot_mem_map.nr_map--;
+                }
+                else {
+                    /* Reclaim whatever we can... */
+                    boot_mem_map.map[j].size =
+                        0x100000000ULL - boot_mem_map.map[j].addr;
+                }
+            }
+#endif
+        }
+    }
+}
 #endif
 
-const char *get_system_type(void)
+void __init plat_mem_setup(void)
 {
-	return "Netlogic XLP Series";
-}
+	extern int panic_timeout;
+  
+	panic_timeout = 5;  
+  
+	_machine_restart = (void (*)(char *))ptr_linux_exit;
+	_machine_halt    = ptr_linux_exit;
+	pm_power_off 	 = ptr_linux_exit;
+
+        tweak_avail_dram_map();
+
+	return;
+}  
+
+struct nlm_common_name_value_struct {
+	char *name;
+	uint32_t *val;
+};
 
-void __init prom_free_prom_memory(void)
+/* Maintain in ascending order of 
+ * the starting physical addresses 
+ */
+static struct boot_mem_map_exclude_region _exclude_regions[2][MAX_EXCLUDE + 2];
+
+static struct boot_mem_map_exclude_region *exclude_regions = _exclude_regions[1];
+
+struct boot_mem_map prom_map;
+int use_default_phymem = TRUE;
+
+static void prom_add_memory(void)
 {
-	/* Nothing yet */
+	int i = 0, j = 0;
+	__u64 start = 0, end = 0, exc_start = 0, exc_end = 0;
+	__u64 pref_backup = 512;
+
+	if (use_default_phymem)
+		goto use_default;
+
+	/* TODO: Need to remove this hack
+	 */
+	if (prom_map.map[0].size == 0x0c000000)
+		prom_map.map[0].size = 0x0ff00000;
+	
+	for (i = 0; i < prom_map.nr_map; i++) {
+		start = prom_map.map[i].addr;
+		end = prom_map.map[i].addr + prom_map.map[i].size;
+
+		for (j = 0; j < MAX_EXCLUDE; j++) {
+			exc_start = exclude_regions[j].start;
+			exc_end = exclude_regions[j].end;
+			
+			if ((exc_start == 0) && (exc_end == 0)) /* Empty slot */
+				continue;
+
+			if (exc_start >= start && exc_start < end) {
+				if (exc_start == start) { /* Continuous exclude */
+					start = exc_end;
+					continue;
+				}
+				if (prom_map.map[i].type == BOOT_MEM_RAM) {
+
+					/*
+					 * memcpy/__copy_user prefetch, which
+					 * will cause a bus error for
+					 * KSEG/KUSEG addrs not backed by RAM.
+					 * Hence, reserve some padding for the
+					 * prefetch distance.
+				 	*/
+					if (exc_start-start > pref_backup) {
+						add_memory_region(start,
+									  exc_start-start-pref_backup, 
+									  (long)prom_map.map[i].type);
+					}
+					start = exc_end;
+				}
+			} 
+			else if ((exc_start < start) && (exc_end > start)) {
+				/* Overlapping excludes 
+				 */
+				start = exc_end;
+			}
+		}
+		if (start != end)
+			if (prom_map.map[i].type == BOOT_MEM_RAM) {
+				if (end-start > pref_backup)
+					add_memory_region(start, end-start-pref_backup, (long)prom_map.map[i].type);
+			}
+	}
+	
+	return;
+	
+ use_default:
+	printk("Using Default Physical Mem Map\n"); 
+	/* 255m@1m 
+	 */
+	add_memory_region (DEF_PHYMEM_START_ADDR, 
+			DEF_PHYMEM_SIZE-pref_backup, (long)BOOT_MEM_RAM);
+	xlr_loader_support = 0;
 }
 
-void xlp_mmu_init(void)
+/* disable dedicated interrupt vector for virtual mips mode */
+void disable_divec(void)
 {
-	/* enable extended TLB and Large Fixed TLB */
-	write_c0_config6(read_c0_config6() | 0x24);
+    int i;
+    for (i = 0; i < NR_CPUS; i++)
+        cpu_data[i].options &= ~MIPS_CPU_DIVEC;
 
-	/* set page mask of Fixed TLB in config7 */
-	write_c0_config7(PM_DEFAULT_MASK >>
-		(13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+    return;
 }
 
-void __init prom_init(void)
+extern void (*board_nmi_handler_setup)(void );
+
+void __init nlm_nmi_setup (void)
+{
+	/* setup nmi handler only if KGDB is enabled */
+#ifdef CONFIG_KGDB
+	void *base;
+	extern char nlm_except_vec_nmi;
+
+	printk("Setting up NMI Handler \n");
+	base = (void *)(unsigned long)0xffffffffbfc00000ULL;
+	memcpy(base, &nlm_except_vec_nmi, 0x80);
+#endif
+}
+
+/* setup early serial port driver */
+#ifdef CONFIG_SERIAL_8250
+#ifdef CONFIG_NLM_XLR
+#define UART_CLK 66666666
+#else
+#define UART_CLK 133333333
+#endif
+static void nlm_early_serial_setup(void)
 {
-	void *fdtp;
+	struct uart_port s;
+	extern int __init early_serial_setup(struct uart_port *port);
 
-	xlp_mmu_init();
-	nlm_hal_init();
+	memset(&s, 0, sizeof(s));
 
-	/*
-	 * If no FDT pointer is passed in, use the built-in FDT.
-	 * device_tree_init() does not handle CKSEG0 pointers in
-	 * 64-bit, so convert pointer.
+	s.flags = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
+	/* XLP_MERGE_TODO */
+	s.iotype = UPIO_MEM;
+	/* registers are 4 bytes wide */
+	s.regshift = 2;
+	/* hardware int 4 - the serial int, is CPU int 6
+	 but poll for now */
+	s.irq =  PIC_UART_0_IRQ;
+	s.uartclk = UART_CLK;
+	s.membase = (unsigned char __iomem *)(DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
+	s.mapbase = (DEFAULT_NETLOGIC_IO_BASE+NETLOGIC_IO_UART_0_OFFSET);
+
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial setup failed!\n");
+	}
+
+
+}
+#else
+static void nlm_early_serial_setup(void) {}
+#endif /* CONFIG_SERIAL_8250 */
+
+extern struct plat_smp_ops nlm_smp_ops;
+
+static int fdt_process(void) 
+{
+	/* If booted using FDT and U-Boot, all
+	 * we get is a pointer to an FDT Blob
 	 */
-	fdtp = (void *)(long)fw_arg0;
-	if (!fdtp)
-		fdtp = __dtb_start;
-	fdtp = phys_to_virt(__pa(fdtp));
-	early_init_devtree(fdtp);
+	void *blob = (void *)fw_arg0;
+	void *node;
 
-	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
-#ifdef CONFIG_SMP
-	/* update TLB size after waking up threads */
-	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+	/* We try to create a region starting
+	 * from (_end + 64K) of size 8MB for
+	 * the FDT structures. The 64K is the
+	 * current page size for XEN
+	 */
+	simple_alloc_init((char *)((unsigned long)(&_end)+0x10000),
+			(8<<20), 32, 128);
 
-	register_smp_ops(&nlm_smp_ops);
-#endif
+	/* Create a local copy of the FDT */
+	fdt = fdt_init(blob);
+
+	/* Grab the bitmask of CPUs to 
+	 * bring online, from the FDT
+	 */
+	node = finddevice("/cpus");
+	if (node) {
+		if (getprop(node, "onlinemask", &onlinemask, sizeof(onlinemask)) < 0)
+			return -1;
+	}
+	if (!onlinemask) 
+		onlinemask = 0x1;
+
+	/* extract bootloader-passed
+	 * cmdline params
+	 */
+	node = finddevice("/chosen");
+	if (node) {
+		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+			return -1;
+		printk("Firmware Cmdline: %s\n", prop_buf);
+		strcat(arcs_cmdline, prop_buf);
+	}
+
+	return 0;
 }
 
-void __init device_tree_init(void)
+void __init prom_init(void)
 {
-	unsigned long base, size;
+	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
-	if (!initial_boot_params)
-		return;
+	setup_default_configuration();
 
-	base = virt_to_phys((void *)initial_boot_params);
-	size = be32_to_cpu(initial_boot_params->totalsize);
+	fdt_process();
 
-	/* Before we do anything, lets reserve the dt blob */
-	reserve_bootmem(base, size, BOOTMEM_DEFAULT);
+	if (loader_used == LOADER_UBOOT) {
+		use_default_phymem = TRUE;
+		goto setup_ebase;
+	}
 
-	unflatten_device_tree();
+setup_ebase:
+	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
-	/* free the space reserved for the dt blob */
-	free_bootmem(base, size);
+	prom_add_memory();
+
+	smp_boot.online_map = (1 << hard_smp_processor_id());
+
+	wakeup_secondary_cpus();
+
+	board_nmi_handler_setup = nlm_nmi_setup;
+
+	on_chip_init();
+
+	prom_reconfigure_thr_resources();
+
+	/* setup early serial port driver */
+	nlm_early_serial_setup();
+
+	register_smp_ops(&nlm_smp_ops);
 }
 
-static struct of_device_id __initdata xlp_ids[] = {
-	{ .compatible = "simple-bus", },
-	{},
-};
+void prom_free_prom_memory(void)
+{
+	/* nothing to free */
+}
+
+#ifdef CONFIG_EARLY_PRINTK
+static void NS16550_putc(char c)
+{
+	nlm_reg_t *mmio = 
+		netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
+
+	while (netlogic_read_reg(mmio, 0x5) == 0);
+	netlogic_write_reg(mmio, 0x0, c);
+}
 
-int __init xlp8xx_ds_publish_devices(void)
+void prom_putchar(char c)
 {
-	if (!of_have_populated_dt())
-		return 0;
-	return of_platform_bus_probe(NULL, xlp_ids, NULL);
+	void (*putchar)(char);
+
+	putchar = ((void (*)(char c))(unsigned long)(&NS16550_putc));
+	putchar(c);
 }
+#endif
 
-device_initcall(xlp8xx_ds_publish_devices);
+static int __init nlm_proc_setup(void)
+{
+	nlm_root_proc = proc_mkdir("netlogic", 0);	
+	if (!nlm_root_proc)
+		return -ENOMEM;
+	
+	return 0;
+}
+rootfs_initcall(nlm_proc_setup);
-- 
1.7.10.4

