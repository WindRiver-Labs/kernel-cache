From eace2ac901ffba16877810fec40724a93665d1bd Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Thu, 12 May 2011 11:34:28 -0700
Subject: [PATCH 281/761] Nandflash: Add ECC_SOFT and ECC_HW mode. Fix bugs on
 ECC_HW mode so jffs2 filesystem can be created
 cleanly

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/nand/nand_base.c     |    1 -
 drivers/mtd/nand/xlp_plat_nand.c |  150 ++++++++++++++++++--------------------
 include/linux/mtd/nand.h         |  117 ++++++++++++++---------------
 3 files changed, 130 insertions(+), 138 deletions(-)

diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 9701c5b..892bacf 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -3123,7 +3123,6 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		 */
 		mtd->erasesize = type->erasesize;
 		mtd->writesize = type->pagesize;
-		mtd->oobsize = mtd->writesize / 32;
 		busw = type->options & NAND_BUSWIDTH_16;
 
 		/*
diff --git a/drivers/mtd/nand/xlp_plat_nand.c b/drivers/mtd/nand/xlp_plat_nand.c
index 195b3c6..e6c2b2f 100644
--- a/drivers/mtd/nand/xlp_plat_nand.c
+++ b/drivers/mtd/nand/xlp_plat_nand.c
@@ -39,6 +39,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "xlp_plat_nand.h"
 
 int debug = 0;
+int enable_hwecc = 1;
 
 #undef	NAND_DEBUG
 #define BUF_SIZE 		(16*1024)
@@ -54,7 +55,7 @@ static struct mtd_partition xlp_nand_partition_info[] = {
         },
         {
         .name = "NAND FS 1",
-        .offset = MTDPART_OFS_APPEND , /* Rest@62M */
+        .offset = MTDPART_OFS_APPEND ,
         .size = MTDPART_SIZ_FULL ,
         },
 };
@@ -124,30 +125,45 @@ static int dma_wait(int cs)
 }
 
 #ifdef NAND_DEBUG
+static void print_oob_data(const unsigned char* p)
+{
+	int i;
+
+	if(!p)
+		return;
+
+	for(i = 0; i < 256; i++) {
+		printk("%02x",p[i]);
+		if((i % 16) == 0xf)
+			printk("\n");
+	}
+        printk("\n");
+}
+
 static void print_onfi_params(struct nand_onfi_params * p)
 {
 	printk("OFNI parameter \n"); 
 	printk("rev info and features block\n");
-	printk("revision:%d\n", p->revision);
+	printk("revision:%d\n", le16_to_cpu(p->revision));
 	printk("features:%x\n", p->features);
 	printk("opt_cmd::%x\n", p->opt_cmd);
 
 	printk("\n memory organization block \n");
 
 
-	printk("byte_per_page:%d\n",p->byte_per_page);
-	printk("spare_bytes_per_page: %d\n", p->spare_bytes_per_page);
-	printk("data_bytes_per_ppage: %d\n", p->data_bytes_per_ppage);
-	printk("sparre_bytes_per_ppage: %d\n", p->sparre_bytes_per_ppage);
-	printk("pages_per_block: %d\n", p->pages_per_block);
-	printk("blocks_per_lun: %d\n", p->blocks_per_lun);
+	printk("byte_per_page:%d\n",le32_to_cpu(p->byte_per_page));
+	printk("spare_bytes_per_page: %d\n", le16_to_cpu(p->spare_bytes_per_page));
+	printk("data_bytes_per_ppage: %d\n", le32_to_cpu(p->data_bytes_per_ppage));
+	printk("spare_bytes_per_ppage: %d\n", le16_to_cpu(p->spare_bytes_per_ppage));
+	printk("pages_per_block: %d\n", le32_to_cpu(p->pages_per_block));
+	printk("blocks_per_lun: %d\n", le32_to_cpu(p->blocks_per_lun));
 	printk("lun_count: %d\n", p->lun_count);
 	printk("addr_cycles: %d\n", p->addr_cycles);
 	printk("bits_per_cell: %d\n", p->bits_per_cell);
-	printk("bb_per_lun: %d\n", p->bb_per_lun);
-	printk("block_endurance: %d\n", p->block_endurance);
+	printk("bb_per_lun: %d\n",  le16_to_cpu(p->bb_per_lun));
+	printk("block_endurance: %d\n",  le16_to_cpu(p->block_endurance));
 	printk("guaranteed_good_blocks: %d\n", p->guaranteed_good_blocks);
-	printk("guaranteed_block_endurance: %d\n", p->guaranteed_block_endurance);
+	printk("guaranteed_block_endurance: %d\n", le16_to_cpu(p->guaranteed_block_endurance));
 	printk("programs_per_page: %d\n", p->programs_per_page);
 	printk("ppage_attr: %d\n", p->ppage_attr);
 	printk("ecc_bits: %d\n", p->ecc_bits);
@@ -198,6 +214,9 @@ void onfi_init(struct nand_chip *chip)
         uint32_t ecc_offset;
         int i ;
 
+#ifdef NAND_DEBUG
+	print_oob_data(state->buf);
+#endif
         state->page_size = ( (unsigned int) (param_ptr[80] << 0)  |
                              (unsigned int) (param_ptr[81] << 8)  |
                              (unsigned int) (param_ptr[82] << 16) |
@@ -249,8 +268,8 @@ void onfi_init(struct nand_chip *chip)
                 ecc_bits  = 2 ;
                 ecc_val   = 0 ;
         } else if (spare_bytes_per_512 <= 16) {
-                ecc_bytes = 8 ;
-                ecc_bits  = 13 ;
+                ecc_bytes = 13 ;
+                ecc_bits  = 8 ;
                 ecc_val   = 3 ;
         } else if (spare_bytes_per_512 <= 24) {
                 ecc_bytes = 20 ;
@@ -264,25 +283,40 @@ void onfi_init(struct nand_chip *chip)
         ecc_offset = state->spare_size - ( (state->page_size/512) * ecc_bytes);
 
 
-        nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
-        nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
+	if(enable_hwecc)
+	{
+		nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
+		nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
 	
-	val = nand_reg_read(0, NAND_CTRL);
-        val |= (NAND_CTRL_ECC_EN(1)		  |
-		NAND_CTRL_PAGE_SIZE(page_val)  |
-		NAND_CTRL_BLOCK_SIZE(block_val)|
-		NAND_CTRL_ADDR_CYCLE(addr_val));
-	nand_reg_write(0, NAND_CTRL, val);
-
-        chip->ecc.size   = 512;
-        chip->ecc.bytes  = ecc_bytes;
-        chip->ecc.layout = kmalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
-        chip->ecc.layout->eccbytes = (ecc_bytes * (state->page_size / 512));
-        for (i=0; i < ecc_bytes; i++) {
-                chip->ecc.layout->eccpos[i] = ecc_offset + i;
-        }
-        chip->ecc.layout->oobfree[0].offset = 2 ;
-        chip->ecc.layout->oobfree[0].length = state->spare_size - chip->ecc.layout->eccbytes - 2;
+		val = nand_reg_read(0, NAND_CTRL);
+		val |= (NAND_CTRL_ECC_EN(1)		|
+			NAND_CTRL_PAGE_SIZE(page_val)	|
+			NAND_CTRL_BLOCK_SIZE(block_val)	|
+			NAND_CTRL_ADDR_CYCLE(addr_val))	;
+		nand_reg_write(0, NAND_CTRL, val);
+
+		chip->ecc.size   = 512;
+		chip->ecc.bytes  = ecc_bytes;
+		chip->ecc.steps	 = state->page_size / 512;
+		chip->ecc.total	 = chip->ecc.steps * chip->ecc.bytes;
+		chip->ecc.layout = kmalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
+		chip->ecc.layout->eccbytes = ecc_bytes;
+
+		for (i=0; i < ecc_bytes; i++) {
+			chip->ecc.layout->eccpos[i] = ecc_offset + i;
+		}
+		chip->ecc.layout->oobfree[0].offset = 2 ;
+		chip->ecc.layout->oobfree[0].length = state->spare_size - chip->ecc.layout->eccbytes*chip->ecc.steps - 2;
+	}
+	else
+	{
+		val = nand_reg_read(0, NAND_CTRL);
+		val |= (NAND_CTRL_ECC_EN(0)		|
+			NAND_CTRL_PAGE_SIZE(page_val)	|
+			NAND_CTRL_BLOCK_SIZE(block_val)	|
+			NAND_CTRL_ADDR_CYCLE(addr_val))	;
+		nand_reg_write(0, NAND_CTRL, val);
+	}
 }
 
 
@@ -606,52 +640,6 @@ static int waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
         return nand_reg_read(0, NAND_READ_STATUS);
 }
 
-int board_nand_init(struct nand_chip *nand)
-{
-        struct nand_state *state ;
-        uint32_t val;
-
-        nand_reg_write(0, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
-
-	val = 	NAND_TIME_SEQ0_TWHR(7) |
-		NAND_TIME_SEQ0_TRHW(7) |
-		NAND_TIME_SEQ0_TADL(7) |
-		NAND_TIME_SEQ0_TCCS(7);
-
-	val =  NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
-
-	nand_reg_write(0, NAND_TIMINGS_ASYN, val);
-
-
-        nand->ecc.read_page  = read_page;
-        nand->ecc.write_page = write_page;
-
-
-        nand->ecc.mode    = NAND_ECC_HW;
-
-        nand->read_byte   = read_byte;
-        nand->write_buf   = write_buf;
-        nand->read_buf    = read_buf;
-        nand->verify_buf  = NULL;
-        nand->select_chip = select_chip;
-        nand->cmdfunc     = cmdfunc;
-        nand->waitfunc    = waitfunc;
-
-        nand->options     = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT;
-
-
-        state            = kmalloc(sizeof(struct nand_state), GFP_KERNEL);
-        state->last_cmd  = 0;
-        state->cs        = 0;
-        state->buf_ptr   = 0;
-        state->buf       = kmalloc(BUF_SIZE, GFP_KERNEL);
-        nand->priv       = state;
-
-        dbp_print("Nand buffer virt: %p  phys: %p\n",state->buf,(u8 *) virt_to_phys((void *) state->buf) );
-        return 0;
-}
-
-
 /*
  * Probe for the NAND device.
  */
@@ -703,6 +691,7 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
         data->mtd.priv = &data->chip;
         data->mtd.owner = THIS_MODULE;
         data->mtd.name = dev_name(&pdev->dev);
+	data->mtd.oobsize = 64;
 
         data->chip.IO_ADDR_R = data->io_base;
         data->chip.IO_ADDR_W = data->io_base;
@@ -716,8 +705,11 @@ static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
         data->chip.waitfunc	= waitfunc ;
         data->chip.chip_delay	= 15;
 
-        data->chip.options     = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT ;
-        data->chip.ecc.mode = NAND_ECC_HW;
+        data->chip.options      = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT ;
+	if(enable_hwecc)
+	        data->chip.ecc.mode = NAND_ECC_HW;
+	else
+		data->chip.ecc.mode = NAND_ECC_SOFT;
 
         data->chip.ecc.read_page  = read_page;
         data->chip.ecc.write_page = write_page;
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 41a450a..990cdae 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -303,64 +303,65 @@ struct nand_onfi_params {
 
 #ifdef CONFIG_NLM_XLP
 struct nand_onfi_params {
-	/* rev info and features block */
-	uint8_t		sig[4]; /* 'O' 'N' 'F' 'I'  */
-	uint16_t	revision;
-	uint16_t	features;
-	uint16_t	opt_cmd;
-	uint8_t		reserved[22];
-
-	/* manufacturer information block */
-	char		manufacturer[12];
-	char		model[20];
-	uint8_t		jedec_id;
-	uint16_t	date_code;
-	uint8_t		reserved2[13];
-
-	/* memory organization block */
-	uint32_t	byte_per_page;
-	uint16_t	spare_bytes_per_page;
-	uint32_t	data_bytes_per_ppage;
-	uint16_t	sparre_bytes_per_ppage;
-	uint32_t	pages_per_block;
-	uint32_t	blocks_per_lun;
-	uint8_t		lun_count;
-	uint8_t		addr_cycles;
-	uint8_t		bits_per_cell;
-	uint16_t	bb_per_lun;
-	uint16_t	block_endurance;
-	uint8_t		guaranteed_good_blocks;
-	uint16_t	guaranteed_block_endurance;
-	uint8_t		programs_per_page;
-	uint8_t		ppage_attr;
-	uint8_t		ecc_bits;
-	uint8_t		interleaved_bits;
-	uint8_t		interleaved_ops;
-        uint8_t		reserved3[13];
-	
-	/* electrical parameter block */
-	uint8_t		io_pin_capacitance_max;
-	uint16_t	async_timing_mode;
-	uint16_t	program_cache_timing_mode;
-	uint16_t	t_prog;
-	uint16_t	t_bers;
-	uint16_t	t_r;
-	uint16_t	t_ccs;
-	uint16_t	src_sync_timing_mode;
-	uint16_t	src_ssync_features;
-	uint16_t	clk_pin_capacitance_typ;
-	uint16_t	io_pin_capacitance_typ;
-	uint16_t	input_pin_capacitance_typ;
-	uint8_t		input_pin_capacitance_max;
-	uint8_t		driver_strenght_support;
-	uint16_t	t_int_r;
-	uint16_t	t_ald;
-	uint8_t		reserved4[7];
-
-	/* vendor */
-	uint8_t		reserved5[90];
-
-	uint16_t	crc;
+        /* rev info and features block */
+        /* 'O' 'N' 'F' 'I'  */
+        u8 sig[4];
+        __le16 revision;
+        __le16 features;
+        __le16 opt_cmd;
+        u8 reserved[22];
+
+        /* manufacturer information block */
+        char manufacturer[12];
+        char model[20];
+        u8 jedec_id;
+        __le16 date_code;
+        u8 reserved2[13];
+
+        /* memory organization block */
+        __le32 byte_per_page;
+        __le16 spare_bytes_per_page;
+        __le32 data_bytes_per_ppage;
+        __le16 spare_bytes_per_ppage;
+        __le32 pages_per_block;
+        __le32 blocks_per_lun;
+        u8 lun_count;
+        u8 addr_cycles;
+        u8 bits_per_cell;
+        __le16 bb_per_lun;
+        __le16 block_endurance;
+        u8 guaranteed_good_blocks;
+        __le16 guaranteed_block_endurance;
+        u8 programs_per_page;
+        u8 ppage_attr;
+        u8 ecc_bits;
+        u8 interleaved_bits;
+        u8 interleaved_ops;
+        u8 reserved3[13];
+
+        /* electrical parameter block */
+        u8 io_pin_capacitance_max;
+        __le16 async_timing_mode;
+        __le16 program_cache_timing_mode;
+        __le16 t_prog;
+        __le16 t_bers;
+        __le16 t_r;
+        __le16 t_ccs;
+        __le16 src_sync_timing_mode;
+        __le16 src_ssync_features;
+        __le16 clk_pin_capacitance_typ;
+        __le16 io_pin_capacitance_typ;
+        __le16 input_pin_capacitance_typ;
+        u8 input_pin_capacitance_max;
+        u8 driver_strenght_support;
+        __le16 t_int_r;
+        __le16 t_ald;
+        u8 reserved4[7];
+
+        /* vendor */
+        u8 reserved5[90];
+
+        __le16 crc;
 } __attribute__((packed));
 
 #define ONFI_CRC_BASE  0x4F4E
-- 
1.7.10.4

