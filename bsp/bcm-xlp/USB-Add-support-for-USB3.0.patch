From 99e0e077658ca78d191212ebc10e8925bd92f7e5 Mon Sep 17 00:00:00 2001
From: Anurag <anurag.gopinath@broadcom.com>
Date: Sun, 21 Oct 2012 00:22:47 +0530
Subject: [PATCH 608/761] USB : Add support for USB3.0

Add support for USB3.0

Based on Broadcom SDK 2.3.

Signed-off-by: Anurag <anurag.gopinath@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp.h     |    3 +
 arch/mips/include/asm/netlogic/xlp_irq.h |    2 +
 arch/mips/include/asm/netlogic/xlp_usb.h |   17 +++--
 arch/mips/netlogic/xlp/usb-init.c        |  101 +++++++++++++++++++++++++++---
 drivers/usb/core/hcd.c                   |   10 +++
 drivers/usb/host/xhci-pci.c              |   23 ++++---
 drivers/usb/host/xhci.h                  |   40 ++++++++++--
 7 files changed, 172 insertions(+), 24 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index cffed3b..bdb2f62 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -66,6 +66,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_DEVID_SPI           0x1017
 #define XLP_DEVID_MMC           0x1018
 #define XLP_DEVID_RIO		0x101B
+#define XLP_DEVID_XHCI0         0x101D
+#define XLP_DEVID_XHCI1         0x101E
+#define XLP_DEVID_XHCI2         0x101F
 
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 4aa7512..1e48184 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -114,6 +114,8 @@ struct xlp_nodefn_struct {
 
 #define xlp_incr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, 1)
 #define xlp_decr_ctrl_intmode(n, fn, mode) xlp_ctrl_intmode_add(n, fn, mode, -1)
+#define xlp_soc_pcidev_to_node(dev) ((u8)(PCI_SLOT(dev->devfn)/8))
+#define nlm_xlp_request_irq(node, irt)  xlp_irt_to_irq(node, irt)
 
 #endif		/* __ASSEMBLY__ */
 
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
index 004f891..15ecc43 100644
--- a/arch/mips/include/asm/netlogic/xlp_usb.h
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -49,17 +49,26 @@
 #define PIC_IRT_OHCI_2                  119
 #define PIC_IRT_OHCI_3                  120
 
-static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
+#define PIC_IRT_XHCI_0                  115
+#define PIC_IRT_XHCI_1                  116
+#define PIC_IRT_XHCI_2                  117
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+
+extern int xlp_usb_dev;
+
+static __inline__ uint32_t usb_reg_read(int node, int func, int regidx)
 {
 	volatile uint64_t mmio;
-	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+        mmio = nlm_hal_get_dev_base(node, 0, xlp_usb_dev, func);
 	return nlm_hal_read_32bit_reg(mmio, regidx);
 }
 
-static __inline__ void usb_reg_write(int node, int func, int regidx, int32_t val)
+static __inline__ void usb_reg_write(int node, int func, int regidx, uint32_t val)
 {
 	volatile uint64_t mmio;
-	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+        mmio = nlm_hal_get_dev_base(node, 0, xlp_usb_dev, func);
 	nlm_hal_write_32bit_reg(mmio, regidx, val);
 }
 
diff --git a/arch/mips/netlogic/xlp/usb-init.c b/arch/mips/netlogic/xlp/usb-init.c
index ccc9635..7a3933d 100644
--- a/arch/mips/netlogic/xlp/usb-init.c
+++ b/arch/mips/netlogic/xlp/usb-init.c
@@ -44,6 +44,10 @@
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 
+#define PCI_MEM_BAR_0 0x4
+int xlp_usb_dev;
+int nlm_xlp_nativexhci;
+
 static void nlm_usb_intr_en(int node, int port)
 {
 	uint32_t val;
@@ -71,24 +75,92 @@ static void nlm_usb_hw_reset(int node, int port)
         usb_reg_write(node, port, USB_CTL_0, val);
 }
 
+static void xlp_usb3_hw_start_controller(int node, int ctrl_no)
+{
+       volatile uint32_t val;
+        uint64_t base = nlm_hal_get_dev_base (node, 0, XLP_PCIE_USB3_DEV, ctrl_no);
+        uint64_t corebase;
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV);
+        val &= 0xfc0fffff;
+        val |= (0x27 << 20);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_REF_CLK);
+        val |= (1<<30);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_REF_CLK, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_TEST);
+        val &= 0xfffffffe;
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_TEST, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP_USB3_CTL);
+        usb_reg_write(node, ctrl_no, XLP_USB3_CTL, 0x2e02203);
+
+        /* mask bits [7:0] -- these are core interrupts */
+        usb_reg_write(node, ctrl_no, XLP_USB3_INT_MASK, 0x000fff01);
+
+        /* clear all interrupts */
+        usb_reg_write(node, ctrl_no, XLP_USB3_INT, 0xffffffff);
+
+        udelay(2000);
+
+        if (ctrl_no == 1) {
+               corebase = (~0xf) & nlm_hal_read_32bit_reg(base, PCI_MEM_BAR_0);
+               printk("USB %d corebase 0x%llx\n", ctrl_no, corebase);
+               nlh_write_cfg_reg32(corebase | 0xc2c0, 0x240002);
+
+               val = nlh_read_cfg_reg32(corebase | 0xc110);
+               val &= ~(0x3<<12);
+               val |= (1<<12);
+               nlh_write_cfg_reg32(corebase | 0xc110, val);
+               udelay(1000);
+                 printk("GCTL 0x%x\n", val);
+
+                 val = nlh_read_cfg_reg32(corebase | 0xc200);
+                 val &= ~(1<<6);
+                 nlh_write_cfg_reg32(corebase | 0xc200, val);
+                 printk("PHYCFG 0x%xx \n",val);
+                 udelay(1000);
+
+                 val = nlh_read_cfg_reg32(corebase | 0xc2c0);
+                 val &= ~(1<<17);
+                 nlh_write_cfg_reg32(corebase | 0xc2c0, val);
+                 printk("PIPECTL 0x%x\n",val);
+
+        }
+   return;
+}
+
 static int __init nlm_platform_usb_init(void)
 {
         int n, online;
         int total=num_possible_nodes();
 
 	pr_info("Initializing USB Interface\n");
+
+        if (is_nlm_xlp2xx())
+                xlp_usb_dev = XLP_PCIE_USB3_DEV;
+        else
+                xlp_usb_dev = XLP_PCIE_USB_DEV;
+
         for(n=0; n<total; n++) {
                 online=node_online(n);
                 if(!online)     continue;
 
-	        nlm_usb_hw_reset(n, 0);
-	        nlm_usb_hw_reset(n, 3);
-
-	        /* Enable PHY interrupts */
-	        nlm_usb_intr_en(n, 0);
-	        nlm_usb_intr_en(n, 3);
+                if (is_nlm_xlp2xx()) {
+                        xlp_usb3_hw_start_controller(n, 1);
+                        xlp_usb3_hw_start_controller(n, 2);
+                        xlp_usb3_hw_start_controller(n, 3);
+                } else {
+	                nlm_usb_hw_reset(n, 0);
+	                nlm_usb_hw_reset(n, 3);
+
+	                /* Enable PHY interrupts */
+	                nlm_usb_intr_en(n, 0);
+	                nlm_usb_intr_en(n, 3);
+                }
         }
-
 	return 0;
 }
 
@@ -120,9 +192,24 @@ static void nlm_usb_fixup_final(struct pci_dev *dev)
 	case 0x15:
 	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_OHCI_3);
 	       break;
+	case 0x21:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_0);
+	       break;
+	case 0x22:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_1);
+	       break;
+	case 0x23:
+	       dev->irq = xlp_irt_to_irq(0, PIC_IRT_XHCI_2);
+	       break;
 	}
 }
 DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_EHCI,
 		nlm_usb_fixup_final);
 DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_OHCI,
 		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI0,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI1,
+		nlm_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_NETL_VENDOR, XLP_DEVID_XHCI2,
+		nlm_usb_fixup_final);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index c597f12..0f0388b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -41,6 +41,11 @@
 
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
+#if defined(CONFIG_NLM_XLP)
+#include <linux/pci.h>
+#include <asm/netlogic/xlp_usb.h>
+#endif
+
 
 #include "usb.h"
 
@@ -2152,6 +2157,11 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	struct usb_hcd		*hcd = __hcd;
 	unsigned long		flags;
 	irqreturn_t		rc;
+#if defined(CONFIG_NLM_XLP)
+    struct pci_dev      *dev;
+    int             fun, node;
+#endif
+
 
 	/* IRQF_DISABLED doesn't work correctly with shared IRQs
 	 * when the first handler doesn't use it.  So let's just
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 84e82dc..cb163fb 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -159,6 +159,9 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	 * to say USB 2.0, but I'm not sure what the implications would be in
 	 * the other parts of the HCD code.
 	 */
+	if (dev->vendor == PCI_VENDOR_ID_NETLOGIC)
+                nlm_xlp_nativexhci = 1;
+
 	retval = usb_hcd_pci_probe(dev, id);
 
 	if (retval)
@@ -312,20 +315,26 @@ static const struct hc_driver xhci_pci_hc_driver = {
 /*-------------------------------------------------------------------------*/
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id pci_ids[] = { {
-	/* handle any USB 3.0 xHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
-	.driver_data =	(unsigned long) &xhci_pci_hc_driver,
-	},
-	{ /* end: all zeroes */ }
+static const struct pci_device_id pci_ids[] = {
+   { PCI_VDEVICE(NETLOGIC, 0x101D), (unsigned long) &xhci_pci_hc_driver},
+#if 0
+   { PCI_VDEVICE(NETLOGIC, 0x101E), (unsigned long) &xhci_pci_hc_driver},
+   { PCI_VDEVICE(NETLOGIC, 0x101F), (unsigned long) &xhci_pci_hc_driver},
+#endif
+   {
+   /* handle any USB 3.0 xHCI controller */
+   PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),
+   .driver_data =  (unsigned long) &xhci_pci_hc_driver,
+   },
+   { /* end: all zeroes */ }
 };
+
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver xhci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-
 	.probe =	xhci_pci_probe,
 	.remove =	xhci_pci_remove,
 	/* suspend and resume implemented later */
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 5361fd8..59ea3a1 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1553,17 +1553,31 @@ static inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)
 #define xhci_warn(xhci, fmt, args...) \
 	dev_warn(xhci_to_hcd(xhci)->self.controller , fmt , ## args)
 
+/*
+ * In NLM_XLP, USB controller apparently changes endianness : it has the same
+ * endianness as the CPU. That explains the following, I hope.
+ */
+extern int nlm_xlp_nativexhci;
+#define readl_native(addr)     __raw_readl((__force unsigned *)addr)
+#define writel_native(val, addr)   __raw_writel(val, (__force unsigned *)addr)
+
 /* TODO: copied from ehci.h - can be refactored? */
 /* xHCI spec says all registers are little endian */
 static inline unsigned int xhci_readl(const struct xhci_hcd *xhci,
 		__le32 __iomem *regs)
 {
-	return readl(regs);
+    if(nlm_xlp_nativexhci)
+        return readl_native(regs);
+    else
+        return readl(regs);
 }
 static inline void xhci_writel(struct xhci_hcd *xhci,
 		const unsigned int val, __le32 __iomem *regs)
 {
-	writel(val, regs);
+    if(nlm_xlp_nativexhci)
+        writel_native(val, regs);
+    else
+        writel(val, regs);
 }
 
 /*
@@ -1579,19 +1593,33 @@ static inline u64 xhci_read_64(const struct xhci_hcd *xhci,
 		__le64 __iomem *regs)
 {
 	__u32 __iomem *ptr = (__u32 __iomem *) regs;
-	u64 val_lo = readl(ptr);
-	u64 val_hi = readl(ptr + 1);
+        u64 val_lo, val_hi;
+
+        if(nlm_xlp_nativexhci) {
+                val_lo = readl_native(ptr);
+                val_hi = readl_native(ptr + 1);
+        }else{
+	        val_lo = readl(ptr);
+	        val_hi = readl(ptr + 1);
+        }
+
 	return val_lo + (val_hi << 32);
 }
 static inline void xhci_write_64(struct xhci_hcd *xhci,
 				 const u64 val, __le64 __iomem *regs)
 {
 	__u32 __iomem *ptr = (__u32 __iomem *) regs;
+
 	u32 val_lo = lower_32_bits(val);
 	u32 val_hi = upper_32_bits(val);
 
-	writel(val_lo, ptr);
-	writel(val_hi, ptr + 1);
+        if(nlm_xlp_nativexhci) {
+                writel_native(val_lo, ptr);
+                writel_native(val_hi, ptr + 1);
+        } else {
+	        writel(val_lo, ptr);
+	        writel(val_hi, ptr + 1);
+        }
 }
 
 static inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)
-- 
1.7.10.4

