From a146b772ee784b2bb6c5e69726dfc294a313c5fd Mon Sep 17 00:00:00 2001
From: Zi Shen Lim <zlim@netlogicmicro.com>
Date: Thu, 29 Sep 2011 15:33:16 -0700
Subject: [PATCH 369/761] Resolve merge conflict: merge, cosmetic cleanup

Based on Broadcom SDK 2.3.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/tlbex.c |  130 ++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 94 insertions(+), 36 deletions(-)

diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index c5d1ed4..1f67614 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -32,11 +32,6 @@
 #include <asm/pgtable.h>
 #include <asm/war.h>
 #include <asm/uasm.h>
-#include <asm/setup.h>
-
-#ifdef CONFIG_NLM_COMMON
-#include <asm/netlogic/mips-exts.h>
-#endif
 
 /*
  * TLB load/store/modify handlers.
@@ -60,6 +55,10 @@ struct tlb_reg_save {
 
 static struct tlb_reg_save handler_reg_save[NR_CPUS];
 
+#ifdef CONFIG_NLM_COMMON
+#include <asm/netlogic/mips-exts.h>
+#endif
+
 static inline int r45k_bvahwbug(void)
 {
 	/* XXX: We should probe for the presence of this bug, but we don't. */
@@ -164,6 +163,13 @@ enum label_id {
 #ifdef CONFIG_HUGETLB_PAGE
 	label_tlb_huge_update,
 #endif
+	label_nohpage_tlbs,
+	label_hpage_tlb_leave,
+	label_non_btlb_process,
+	label_read_entrylo1,
+	label_illegal_access_tlbl,
+	label_exl_refill_exception,
+	label_r4000_write_probe_fail,
 };
 
 UASM_L_LA(_second_part)
@@ -183,6 +189,13 @@ UASM_L_LA(_large_segbits_fault)
 #ifdef CONFIG_HUGETLB_PAGE
 UASM_L_LA(_tlb_huge_update)
 #endif
+UASM_L_LA(_nohpage_tlbs)
+UASM_L_LA(_hpage_tlb_leave)
+UASM_L_LA(_non_btlb_process)
+UASM_L_LA(_read_entrylo1)
+UASM_L_LA(_illegal_access_tlbl)
+UASM_L_LA(_exl_refill_exception)
+UASM_L_LA(_r4000_write_probe_fail)
 
 /*
  * For debug purposes.
@@ -215,6 +228,8 @@ static inline void dump_handler(const u32 *handler, int count)
 #define C0_ENTRYHI	10, 0
 #define C0_EPC		14, 0
 #define C0_XCONTEXT	20, 0
+#define v0    2
+#define C0_SCRATCH_4  22, 4
 
 #ifdef CONFIG_64BIT
 # define GET_CONTEXT(buf, reg) UASM_i_MFC0(buf, reg, C0_XCONTEXT)
@@ -233,7 +248,7 @@ static inline void dump_handler(const u32 *handler, int count)
 #if defined(CONFIG_MAPPED_KERNEL)
 static u32 tlb_handler[128];
 #else
-static u32 tlb_handler[128] __cpuinitdata ;
+static u32 tlb_handler[128] __cpuinitdata;
 #endif
 
 /* simply assume worst case size for labels and relocs */
@@ -431,7 +446,6 @@ static void __cpuinit __maybe_unused build_tlb_probe_entry(u32 **p)
 	case CPU_R5000:
 	case CPU_R5000A:
 	case CPU_NEVADA:
-	case CPU_4KC:
 		uasm_i_nop(p);
 		uasm_i_tlbp(p);
 		break;
@@ -487,7 +501,6 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 	case CPU_R4700:
 	case CPU_R5000:
 	case CPU_R5000A:
-	case CPU_4KC:
 		uasm_i_nop(p);
 		tlbw(p);
 		uasm_i_nop(p);
@@ -506,6 +519,7 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 	case CPU_R10000:
 	case CPU_R12000:
 	case CPU_R14000:
+	case CPU_4KC:
 	case CPU_4KEC:
 	case CPU_SB1:
 	case CPU_SB1A:
@@ -598,8 +612,16 @@ static __cpuinit __maybe_unused void build_convert_pte_to_entrylo(u32 **p,
 								  unsigned int reg)
 {
 	if (kernel_uses_smartmips_rixi) {
+#ifdef CONFIG_NLM_XLP
+#ifdef CONFIG_64BIT_PHYS_ADDR
+		uasm_i_dsrl(p, reg, reg, ilog2(_PAGE_GLOBAL));
+#else
+		UASM_i_SRL(p, reg, reg, ilog2(_PAGE_GLOBAL));
+#endif
+#else /* CONFIG_NLM_XLP */
 		UASM_i_SRL(p, reg, reg, ilog2(_PAGE_NO_EXEC));
 		UASM_i_ROTR(p, reg, reg, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
+#endif /* CONFIG_NLM_XLP */
 	} else {
 #ifdef CONFIG_64BIT_PHYS_ADDR
 		uasm_i_dsrl_safe(p, reg, reg, ilog2(_PAGE_GLOBAL));
@@ -1002,11 +1024,17 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 		uasm_i_ld(p, tmp, 0, ptep); /* get even pte */
 		uasm_i_ld(p, ptep, sizeof(pte_t), ptep); /* get odd pte */
 		if (kernel_uses_smartmips_rixi) {
+#ifdef CONFIG_NLM_XLP
+			uasm_i_dsrl_safe(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+			UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
+			uasm_i_dsrl_safe(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo1 */
+#else /* CONFIG_NLM_XLP */
 			UASM_i_SRL(p, tmp, tmp, ilog2(_PAGE_NO_EXEC));
 			UASM_i_SRL(p, ptep, ptep, ilog2(_PAGE_NO_EXEC));
 			UASM_i_ROTR(p, tmp, tmp, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
 			UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
 			UASM_i_ROTR(p, ptep, ptep, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
+#endif /* CONFIG_NLM_XLP */
 		} else {
 			uasm_i_dsrl_safe(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
 			UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
@@ -1029,6 +1057,15 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 	if (r45k_bvahwbug())
 		build_tlb_probe_entry(p);
 	if (kernel_uses_smartmips_rixi) {
+#ifdef CONFIG_NLM_XLP
+		UASM_i_SRL(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+		if (r4k_250MHZhwbug())
+			UASM_i_MTC0(p, 0, C0_ENTRYLO0);
+		UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
+		UASM_i_SRL(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo1 */
+		if (r45k_bvahwbug())
+			uasm_i_mfc0(p, tmp, C0_INDEX);
+#else /* CONFIG_NLM_XLP */
 		UASM_i_SRL(p, tmp, tmp, ilog2(_PAGE_NO_EXEC));
 		UASM_i_SRL(p, ptep, ptep, ilog2(_PAGE_NO_EXEC));
 		UASM_i_ROTR(p, tmp, tmp, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
@@ -1036,6 +1073,7 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 			UASM_i_MTC0(p, 0, C0_ENTRYLO0);
 		UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
 		UASM_i_ROTR(p, ptep, ptep, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
+#endif /* CONFIG_NLM_XLP */
 	} else {
 		UASM_i_SRL(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
 		if (r4k_250MHZhwbug())
@@ -1243,19 +1281,19 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	u32 *p = tlb_handler;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
-	unsigned int final_len = 0;
-	struct mips_huge_tlb_info htlb_info __maybe_unused;
-	enum vmalloc64_mode vmalloc_mode __maybe_unused;
-
 #if !defined(CONFIG_MAPPED_KERNEL)
 	u32 *f;
-
-	memset(final_handler, 0, sizeof(final_handler));
 #endif
+	unsigned int final_len;
+	struct mips_huge_tlb_info htlb_info __maybe_unused;
+	enum vmalloc64_mode vmalloc_mode __maybe_unused;
 
 	memset(tlb_handler, 0, sizeof(tlb_handler));
 	memset(labels, 0, sizeof(labels));
 	memset(relocs, 0, sizeof(relocs));
+#if !defined(CONFIG_MAPPED_KERNEL)
+	memset(final_handler, 0, sizeof(final_handler));
+#endif
 
 	if ((scratch_reg > 0 || scratchpad_available()) && use_bbit_insns()) {
 		htlb_info = build_fast_tlb_refill_handler(&p, &l, &r, K0, K1,
@@ -1283,9 +1321,9 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		}
 
 #ifdef CONFIG_NLM_COMMON
-        uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
-        uasm_i_daddiu(&p, K0, K0, 1);
-        uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
+		uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
+		uasm_i_daddiu(&p, K0, K0, 1);
+		uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
 #endif
 
 #ifdef CONFIG_64BIT
@@ -1302,16 +1340,13 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		build_update_entries(&p, K0, K1);
 		build_tlb_write_entry(&p, &l, &r, tlb_random);
 		uasm_l_leave(&l, p);
-	/*
-	 * FIXME: Do we need the following ifdef functionality
-	 */
 #ifdef CONFIG_NLM_COMMON
-	/* this is to avoid split of the table at eret instruction 
-	   The code below does a split at 30th instruction.
-	 */
-	if((p - tlb_handler) == 30) {
-		uasm_i_nop(&p);
-	}
+		/* this is to avoid split of the table at eret instruction
+		   The code below does a split at 30th instruction.
+		 */
+		if ((p - tlb_handler) == 30) {
+			uasm_i_nop(&p);
+		}
 #endif
 		uasm_i_eret(&p); /* return from trap */
 	}
@@ -1467,16 +1502,6 @@ static void __cpuinit __attribute__((unused)) build_r4000_tlb_refill_handler_stu
 #endif /* defined(CONFIG_MAPPED_KERNEL) */
 
 /*
- * TLB load/store/modify handlers.
- *
- * Only the fastpath gets synthesized at runtime, the slowpath for
- * do_page_fault remains normal asm.
- */
-extern void tlb_do_page_fault_0(void);
-extern void tlb_do_page_fault_1(void);
-extern void tlb_do_page_fault_2(void);
-
-/*
  * 128 instructions for the fastpath handler is generous and should
  * never be exceeded.
  */
@@ -1911,7 +1936,31 @@ build_r4000_tlbchange_handler_tail(u32 **p, struct uasm_label **l,
 	uasm_i_ori(p, ptr, ptr, sizeof(pte_t));
 	uasm_i_xori(p, ptr, ptr, sizeof(pte_t));
 	build_update_entries(p, tmp, ptr);
+	uasm_i_tlbp(p);
+	uasm_i_ehb(p);
+	uasm_i_mfc0(p, ptr, C0_INDEX);
+	uasm_il_bltz(p, r, ptr, label_r4000_write_probe_fail);
+	uasm_i_nop(p);
+
 	build_tlb_write_entry(p, l, r, tlb_indexed);
+
+#ifdef CONFIG_HUGETLBFS
+#ifdef CONFIG_PAGE_SIZE_4KB
+	uasm_i_mtc0(p, ZERO, C0_PAGEMASK);
+#else
+	uasm_i_mtc0(p, K0, C0_PAGEMASK);
+#endif
+#endif
+	uasm_i_eret(p);
+	uasm_l_r4000_write_probe_fail(l, *p);
+	build_tlb_write_entry(p, l, r, tlb_random);
+#ifdef CONFIG_HUGETLBFS
+#ifdef CONFIG_PAGE_SIZE_4KB
+	i_mtc0(p, ZERO, C0_PAGEMASK);
+#else
+	i_mtc0(p, K0, C0_PAGEMASK);
+#endif
+#endif
 	uasm_l_leave(l, *p);
 	build_restore_work_registers(p);
 	uasm_i_eret(p); /* return from trap */
@@ -1964,6 +2013,15 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 			uasm_il_beqz(&p, &r, wr.r3, label_tlbl_goaround1);
 		}
 		uasm_i_nop(&p);
+#ifdef CONFIG_NLM_XLP
+		/*
+		 *if tlb probe has failed, skip to label_tlbl_goaround assuming
+		 *exception is due to valid bit not being set in entrylo.
+		 */
+		uasm_i_mfc0(&p, K0, C0_INDEX);
+		uasm_il_bltz(&p, &r, K0, label_tlbl_goaround1);
+		uasm_i_nop(&p);
+#endif
 
 		uasm_i_tlbr(&p);
 		/* Examine  entrylo 0 or 1 based on ptr. */
-- 
1.7.10.4

