From 27573260f53ed42ed977614d373e6210bd328b0d Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 30 May 2013 17:14:43 +0800
Subject: [PATCH 747/761] bcm_xlp: update flush_icache_range

The function smp_call_function_many() can't be called with irqs_disabled.
But ftrace_init() disables interrupts before calling it, so use for_each_cpu()
to replace on_each_cpu(), else we got the below call trace.

  0:<4>------------[ cut here ]------------
  0:<4>WARNING: at ...kernel/smp.c:464 smp_call_function_many+0x13c/0x3f8()
  0:<d>Modules linked in:  0:
  0:Call Trace:
  0:[<ffffffffc17b3538>] dump_stack+0x1c/0x50
  0:[<ffffffffc10f086c>] warn_slowpath_common+0x8c/0xc0
  0:[<ffffffffc10f08cc>] warn_slowpath_null+0x2c/0x40
  0:[<ffffffffc114da4c>] smp_call_function_many+0x13c/0x3f8
  0:[<ffffffffc114dd70>] on_each_cpu_mask+0x68/0x108
  0:[<ffffffffc10dccfc>] nlm_common_flush_icache_range+0x10c/0x120
  0:[<ffffffffc10cb700>] ftrace_modify_code+0x30/0x48
  0:[<ffffffffc1c58430>] ftrace_dyn_arch_init+0x8c/0xb0
  0:[<ffffffffc1c5dfc8>] ftrace_init+0x38/0x1ac
  0:[<ffffffffc1c50a58>] start_kernel+0x408/0x43c

Based on Broadcom SDK 2.3.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/mm/c-phoenix.c |   95 +++++++++++++++++++++++++++++++++-------------
 1 file changed, 68 insertions(+), 27 deletions(-)

diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index a51337b..b181aac 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -177,24 +177,34 @@ static void nlm_common_flush_icache_range_ipi(void *info)
 
 void nlm_common_flush_icache_range(unsigned long start, unsigned long end)
 {
-  struct flush_icache_range_args args;
+	struct flush_icache_range_args args;
+	int cpu;
+	cpumask_t mask;
 
 #ifdef CONFIG_NLMCOMMON_VM_DEBUG
-  dbg_msg("return address: ");
-  print_symbol("ra[0]=%s\n", return_address());
+	dbg_msg("return address: ");
+	print_symbol("ra[0]=%s\n", return_address());
 #endif
 
-  if ((end - start) > PAGE_SIZE) {
-    dbg_msg("flushing more than page size of icache addresses starting @ %lx\n", start);
-  }
-
-  args.start = start;
-  args.end = end;
-  /* TODO: don't even send ipi to non-zero thread ids
-   * This may require some changes to smp_call_function interface, for now just avoid
-   * redundant cache ops
-   */
-  on_each_cpu(nlm_common_flush_icache_range_ipi, &args, 1);
+	if ((end - start) > PAGE_SIZE)
+		dbg_msg("flushing more than page size of"
+			"icache addresses starting @ %lx\n", start);
+
+	args.start = start;
+	args.end = end;
+/* TODO: don't even send ipi to non-zero thread ids
+ * This may require some changes to smp_call_function interface,
+ * for now just avoid redundant cache ops
+*/
+	preempt_disable();
+	cpu = smp_processor_id();
+	mask = *cpu_online_mask;
+	cpumask_clear_cpu(cpu, &mask);
+
+	for_each_cpu(cpu, &mask)
+		nlm_common_flush_icache_range_ipi((void *)&args);
+
+	preempt_enable();
 }
 
 static void nlm_common_flush_cache_sigtramp_ipi(void *info)
@@ -210,7 +220,18 @@ static void nlm_common_flush_cache_sigtramp_ipi(void *info)
 
 static void nlm_common_flush_cache_sigtramp(unsigned long addr)
 {
-  on_each_cpu(nlm_common_flush_cache_sigtramp_ipi, (void *) addr, 1);
+	int cpu;
+	cpumask_t mask;
+
+	preempt_disable();
+	cpu = smp_processor_id();
+	mask = *cpu_online_mask;
+	cpumask_clear_cpu(cpu, &mask);
+
+	for_each_cpu(cpu, &mask)
+		nlm_common_flush_cache_sigtramp_ipi((void *) addr);
+
+	preempt_enable();
 }
 
 /*****************************************************************************************
@@ -281,8 +302,18 @@ static void nlm_common_flush_l1_caches_ipi(void *info)
 
 static void nlm_common_flush_l1_caches(void)
 {
-  //dbg_msg("NASTY CACHE FLUSH: flushing L1 caches on all cpus!\n");
-  on_each_cpu(nlm_common_flush_l1_caches_ipi, (void *)NULL, 1);
+	int cpu;
+	cpumask_t mask;
+
+	preempt_disable();
+	cpu = smp_processor_id();
+	mask = *cpu_online_mask;
+	cpumask_clear_cpu(cpu, &mask);
+
+	for_each_cpu(cpu, &mask)
+		nlm_common_flush_l1_caches_ipi((void *)NULL);
+
+	preempt_enable();
 }
 
 /*****************************************************************************************/
@@ -552,20 +583,30 @@ static void nlm_common_flush_icache_range_paddr_ipi(void *info)
 
 void nlm_common_flush_icache_range_paddr(phys_t start)
 {
-  struct flush_icache_range_args_paddr args;
+	struct flush_icache_range_args_paddr args;
+	int cpu;
+	cpumask_t mask;
 
 #ifdef CONFIG_NLMCOMMON_VM_DEBUG
-  dbg_msg("return address: ");
-  print_symbol("ra[0]=%s\n", (unsigned long) return_address());
+	dbg_msg("return address: ");
+	print_symbol("ra[0]=%s\n", return_address());
 #endif
 
-  args.start = start;
-  args.end = start + PAGE_SIZE;
-  /* TODO: don't even send ipi to non-zero thread ids
-   * This may require some changes to smp_call_function interface, for now just avoid
-   * redundant cache ops
-   */
-  on_each_cpu(nlm_common_flush_icache_range_paddr_ipi, &args, 1);
+	args.start = start;
+	args.end = start + PAGE_SIZE;
+/* TODO: don't even send ipi to non-zero thread ids
+ * This may require some changes to smp_call_function interface,
+ * for now just avoid redundant cache ops
+*/
+	preempt_disable();
+	cpu = smp_processor_id();
+	mask = *cpu_online_mask;
+	cpumask_clear_cpu(cpu, &mask);
+
+	for_each_cpu(cpu, &mask)
+		nlm_common_flush_icache_range_paddr_ipi((void *)&args);
+
+	preempt_enable();
 }
 
 
-- 
1.7.10.4

