From 383d98bfd5f2f021aa4b66293f3a5ff11a0bebbe Mon Sep 17 00:00:00 2001
From: Jack Tan <jiankemeng@gmail.com>
Date: Thu, 14 Aug 2014 16:59:16 +0800
Subject: [PATCH] bcm-xlp: mtd: remove the xilinx nand flash support

This affect the m25p80 (spi0.1: s25sl12801) driver in xlp832

Backport from sdk 3.0.2

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mtd/devices/m25p80.c |  580 +++++-------------------------------------
 1 files changed, 63 insertions(+), 517 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index d16e550..d8665dc 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -26,7 +26,6 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/mod_devicetable.h>
-#include <linux/of_device.h>
 
 #include <linux/mtd/cfi.h>
 #include <linux/mtd/mtd.h>
@@ -42,16 +41,12 @@
 #define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
 #define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
 #define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
-#define OPCODE_QUAD_READ	0x6b	/* Quad read command */
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
-#define OPCODE_QPP		0x32	/* Quad page program */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
-#define OPCODE_RDFSR		0x70	/* Read Flag Status Register */
-#define OPCODE_WREAR		0xc5	/* Write Extended Address Register */
 
 /* Used for SST flashes only. */
 #define	OPCODE_BP		0x02	/* Byte program */
@@ -64,7 +59,6 @@
 
 /* Used for Spansion flashes only. */
 #define	OPCODE_BRWR		0x17	/* Bank register write */
-#define	OPCODE_BRRD		0x16	/* Bank register read */
 
 /* Status Register bits. */
 #define	SR_WIP			1	/* Write in progress */
@@ -75,13 +69,18 @@
 #define	SR_BP2			0x10	/* Block protect 2 */
 #define	SR_SRWD			0x80	/* SR write protect */
 
-/* Flag Status Register bits. */
-#define FSR_RDY			0x80	/* Ready/Busy program erase
-					controller */
 /* Define max times to check status register before we give up. */
-#define	MAX_READY_WAIT_JIFFIES	(480 * HZ) /* N25Q specs 480s max chip erase */
+#define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
 #define	MAX_CMD_SIZE		5
 
+#ifdef CONFIG_M25PXX_USE_FAST_READ
+#define OPCODE_READ 	OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 1
+#else
+#define OPCODE_READ 	OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 0
+#endif
+
 #define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
 
 /****************************************************************************/
@@ -94,16 +93,6 @@ struct m25p {
 	u16			addr_width;
 	u8			erase_opcode;
 	u8			*command;
-	bool			fast_read;
-	u16			curbank;
-	u32			jedec_id;
-	bool			check_fsr;
-	bool			shift;
-	bool			isparallel;
-	bool			isstacked;
-	u8			read_opcode;
-	u8			prog_opcode;
-	u8			dummycount;
 };
 
 static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
@@ -118,19 +107,21 @@ static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
  */
 
 /*
- * Read register, returning its value in the location
+ * Read the status register, returning its value in the location
+ * Return the status register value.
  * Returns negative if error occurred.
  */
-static inline int read_spi_reg(struct m25p *flash, u8 code, const char *name)
+static int read_sr(struct m25p *flash)
 {
 	ssize_t retval;
+	u8 code = OPCODE_RDSR;
 	u8 val;
 
 	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
 
 	if (retval < 0) {
-		dev_err(&flash->spi->dev, "error %d reading %s\n",
-				(int) retval, name);
+		dev_err(&flash->spi->dev, "error %d reading SR\n",
+				(int) retval);
 		return retval;
 	}
 
@@ -138,26 +129,6 @@ static inline int read_spi_reg(struct m25p *flash, u8 code, const char *name)
 }
 
 /*
- * Read flag status register, returning its value in the location
- * Return flag status register value.
- * Returns negative if error occurred.
- */
-static int read_fsr(struct m25p *flash)
-{
-	return read_spi_reg(flash, OPCODE_RDFSR, "FSR");
-}
-
-/*
- * Read the status register, returning its value in the location
- * Return the status register value.
- * Returns negative if error occurred.
- */
-static int read_sr(struct m25p *flash)
-{
-	return read_spi_reg(flash, OPCODE_RDSR, "SR");
-}
-
-/*
  * Write status register 1 byte
  * Returns negative if error occurred.
  */
@@ -195,31 +166,15 @@ static inline int write_disable(struct m25p *flash)
  */
 static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 {
-	int ret;
-	u8 val;
-
 	switch (JEDEC_MFR(jedec_id)) {
 	case CFI_MFR_MACRONIX:
-	case 0xEF /* winbond */:
 		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
 		return spi_write(flash->spi, flash->command, 1);
 	default:
 		/* Spansion style */
 		flash->command[0] = OPCODE_BRWR;
 		flash->command[1] = enable << 7;
-		ret = spi_write(flash->spi, flash->command, 2);
-
-		/* verify the 4 byte mode is enabled */
-		flash->command[0] = OPCODE_BRRD;
-		spi_write_then_read(flash->spi, flash->command, 1, &val, 1);
-		if (val != enable << 7) {
-			dev_warn(&flash->spi->dev,
-				 "fallback to 3-byte address mode\n");
-			dev_warn(&flash->spi->dev,
-				 "maximum accessible size is 16MB\n");
-			flash->addr_width = 3;
-		}
-		return ret;
+		return spi_write(flash->spi, flash->command, 2);
 	}
 }
 
@@ -230,21 +185,15 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 static int wait_till_ready(struct m25p *flash)
 {
 	unsigned long deadline;
-	int sr, fsr;
+	int sr;
 
 	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
 
 	do {
 		if ((sr = read_sr(flash)) < 0)
 			break;
-		else if (!(sr & SR_WIP)) {
-			if (flash->check_fsr) {
-				fsr = read_fsr(flash);
-				if (!(fsr & FSR_RDY))
-					return 1;
-			}
+		else if (!(sr & SR_WIP))
 			return 0;
-		}
 
 		cond_resched();
 
@@ -254,48 +203,6 @@ static int wait_till_ready(struct m25p *flash)
 }
 
 /*
- * Update Extended Address/bank selection Register.
- * Call with flash->lock locked.
- */
-static int write_ear(struct m25p *flash, u32 addr)
-{
-	u8 ear;
-	int ret;
-
-	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
-		return 1;
-
-	if (flash->mtd.size <= (0x1000000) << flash->shift)
-		return 0;
-
-	addr = addr % (u32) flash->mtd.size;
-	ear = addr >> 24;
-
-	if ((!flash->isstacked) && (ear == flash->curbank))
-		return 0;
-
-	if (flash->isstacked && (flash->mtd.size <= 0x2000000))
-		return 0;
-
-	if (JEDEC_MFR(flash->jedec_id) == 0x01)
-		flash->command[0] = OPCODE_BRWR;
-	if (JEDEC_MFR(flash->jedec_id) == 0x20) {
-		write_enable(flash);
-		flash->command[0] = OPCODE_WREAR;
-	}
-	flash->command[1] = ear;
-
-	ret = spi_write(flash->spi, flash->command, 2);
-	if (ret)
-		return ret;
-
-	flash->curbank = ear;
-
-	return 0;
-}
-
-/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -309,9 +216,6 @@ static int erase_chip(struct m25p *flash)
 	if (wait_till_ready(flash))
 		return 1;
 
-	if (flash->isstacked)
-		flash->spi->master->flags &= ~SPI_MASTER_U_PAGE;
-
 	/* Send write enable, then erase commands. */
 	write_enable(flash);
 
@@ -320,32 +224,16 @@ static int erase_chip(struct m25p *flash)
 
 	spi_write(flash->spi, flash->command, 1);
 
-	if (flash->isstacked) {
-		/* Wait until finished previous write command. */
-		if (wait_till_ready(flash))
-			return 1;
-
-		flash->spi->master->flags |= SPI_MASTER_U_PAGE;
-
-		/* Send write enable, then erase commands. */
-		write_enable(flash);
-
-		/* Set up command buffer. */
-		flash->command[0] = OPCODE_CHIP_ERASE;
-
-		spi_write(flash->spi, flash->command, 1);
-	}
-
 	return 0;
 }
 
 static void m25p_addr2cmd(struct m25p *flash, unsigned int addr, u8 *cmd)
 {
-	int i;
-
 	/* opcode is in cmd[0] */
-	for (i = 1; i <= flash->addr_width; i++)
-		cmd[i] = addr >> (flash->addr_width * 8 - i * 8);
+	cmd[1] = addr >> (flash->addr_width * 8 -  8);
+	cmd[2] = addr >> (flash->addr_width * 8 - 16);
+	cmd[3] = addr >> (flash->addr_width * 8 - 24);
+	cmd[4] = addr >> (flash->addr_width * 8 - 32);
 }
 
 static int m25p_cmdsz(struct m25p *flash)
@@ -368,10 +256,6 @@ static int erase_sector(struct m25p *flash, u32 offset)
 	if (wait_till_ready(flash))
 		return 1;
 
-	/* update Extended Address Register */
-	if (write_ear(flash, offset))
-		return 1;
-
 	/* Send write enable, then erase commands. */
 	write_enable(flash);
 
@@ -397,7 +281,7 @@ static int erase_sector(struct m25p *flash, u32 offset)
 static int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct m25p *flash = mtd_to_m25p(mtd);
-	u32 addr, len, offset;
+	u32 addr,len;
 	uint32_t rem;
 
 	pr_debug("%s: %s at 0x%llx, len %lld\n", dev_name(&flash->spi->dev),
@@ -429,19 +313,7 @@ static int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)
 	/* "sector"-at-a-time erase */
 	} else {
 		while (len) {
-			offset = addr;
-			if (flash->isparallel == 1)
-				offset /= 2;
-			if (flash->isstacked == 1) {
-				if (offset >= (flash->mtd.size / 2)) {
-					offset = offset - (flash->mtd.size / 2);
-					flash->spi->master->flags |=
-							SPI_MASTER_U_PAGE;
-				} else
-					flash->spi->master->flags &=
-							~SPI_MASTER_U_PAGE;
-			}
-			if (erase_sector(flash, offset)) {
+			if (erase_sector(flash, addr)) {
 				instr->state = MTD_ERASE_FAILED;
 				mutex_unlock(&flash->lock);
 				return -EIO;
@@ -482,17 +354,21 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	 * Should add 1 byte DUMMY_BYTE.
 	 */
 	t[0].tx_buf = flash->command;
-	t[0].len = m25p_cmdsz(flash) + flash->dummycount;
+	t[0].len = m25p_cmdsz(flash) + FAST_READ_DUMMY_BYTE;
 	spi_message_add_tail(&t[0], &m);
 
 	t[1].rx_buf = buf;
 	t[1].len = len;
 	spi_message_add_tail(&t[1], &m);
 
+	mutex_lock(&flash->lock);
+
 	/* Wait till previous write/erase is done. */
-	if (wait_till_ready(flash))
+	if (wait_till_ready(flash)) {
 		/* REVISIT status return?? */
+		mutex_unlock(&flash->lock);
 		return 1;
+	}
 
 	/* FIXME switch to OPCODE_FAST_READ.  It's required for higher
 	 * clocks; and at this writing, every chip this driver handles
@@ -500,65 +376,15 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	 */
 
 	/* Set up the write data buffer. */
-	flash->command[0] = flash->read_opcode;
+	flash->command[0] = OPCODE_READ;
 	m25p_addr2cmd(flash, from, flash->command);
 
 	spi_sync(flash->spi, &m);
 
-	*retlen = m.actual_length - m25p_cmdsz(flash) -
-			flash->dummycount;
-
-	return 0;
-}
-
-static int m25p80_read_ext(struct mtd_info *mtd, loff_t from, size_t len,
-	size_t *retlen, u_char *buf)
-{
-	struct m25p *flash = mtd_to_m25p(mtd);
-	u32 addr = from;
-	u32 offset = from;
-	u32 read_len = 0;
-	u32 actual_len = 0;
-	u32 read_count = 0;
-	u32 rem_bank_len = 0;
-	u8 bank = 0;
-
-#define OFFSET_16_MB 0x1000000
-
-	mutex_lock(&flash->lock);
-
-	while (len) {
-		bank = addr / (OFFSET_16_MB << flash->shift);
-		rem_bank_len = ((OFFSET_16_MB << flash->shift) * (bank + 1)) -
-				addr;
-		offset = addr;
-		if (flash->isparallel == 1)
-			offset /= 2;
-		if (flash->isstacked == 1) {
-			if (offset >= (flash->mtd.size / 2)) {
-				offset = offset - (flash->mtd.size / 2);
-				flash->spi->master->flags |= SPI_MASTER_U_PAGE;
-			} else {
-				flash->spi->master->flags &= ~SPI_MASTER_U_PAGE;
-			}
-		}
-		write_ear(flash, offset);
-		if (len < rem_bank_len)
-			read_len = len;
-		else
-			read_len = rem_bank_len;
-
-		m25p80_read(mtd, offset, read_len, &actual_len, buf);
-
-		addr += actual_len;
-		len -= actual_len;
-		buf += actual_len;
-		read_count += actual_len;
-	}
-
-	*retlen = read_count;
+	*retlen = m.actual_length - m25p_cmdsz(flash) - FAST_READ_DUMMY_BYTE;
 
 	mutex_unlock(&flash->lock);
+
 	return 0;
 }
 
@@ -588,15 +414,19 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	t[1].tx_buf = buf;
 	spi_message_add_tail(&t[1], &m);
 
+	mutex_lock(&flash->lock);
+
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
+	if (wait_till_ready(flash)) {
+		mutex_unlock(&flash->lock);
 		return 1;
+	}
 
 	write_enable(flash);
 
 	/* Set up the opcode in the write buffer. */
-	flash->command[0] = flash->prog_opcode;
-	m25p_addr2cmd(flash, (to >> flash->shift), flash->command);
+	flash->command[0] = OPCODE_PP;
+	m25p_addr2cmd(flash, to, flash->command);
 
 	page_offset = to & (flash->page_size - 1);
 
@@ -625,14 +455,12 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 				page_size = flash->page_size;
 
 			/* write the next page to flash */
-			m25p_addr2cmd(flash, ((to + i) >> flash->shift),
-					flash->command);
+			m25p_addr2cmd(flash, to + i, flash->command);
 
 			t[1].tx_buf = buf + i;
 			t[1].len = page_size;
 
-			if (wait_till_ready(flash))
-				return 1;
+			wait_till_ready(flash);
 
 			write_enable(flash);
 
@@ -642,55 +470,8 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 		}
 	}
 
-	return 0;
-}
-
-static int m25p80_write_ext(struct mtd_info *mtd, loff_t to, size_t len,
-	size_t *retlen, const u_char *buf)
-{
-	struct m25p *flash = mtd_to_m25p(mtd);
-	u32 addr = to;
-	u32 offset = to;
-	u32 write_len = 0;
-	u32 actual_len = 0;
-	u32 write_count = 0;
-	u32 rem_bank_len = 0;
-	u8 bank = 0;
-
-#define OFFSET_16_MB 0x1000000
-
-	mutex_lock(&flash->lock);
-	while (len) {
-		bank = addr / (OFFSET_16_MB << flash->shift);
-		rem_bank_len = ((OFFSET_16_MB << flash->shift) * (bank + 1)) -
-				addr;
-		offset = addr;
-
-		if (flash->isstacked == 1) {
-			if (offset >= (flash->mtd.size / 2)) {
-				offset = offset - (flash->mtd.size / 2);
-				flash->spi->master->flags |= SPI_MASTER_U_PAGE;
-			} else {
-				flash->spi->master->flags &= ~SPI_MASTER_U_PAGE;
-			}
-		}
-		write_ear(flash, (offset >> flash->shift));
-		if (len < rem_bank_len)
-			write_len = len;
-		else
-			write_len = rem_bank_len;
-
-		m25p80_write(mtd, offset, write_len, &actual_len, buf);
-
-		addr += actual_len;
-		len -= actual_len;
-		buf += actual_len;
-		write_count += actual_len;
-	}
-
-	*retlen = write_count;
-
 	mutex_unlock(&flash->lock);
+
 	return 0;
 }
 
@@ -787,96 +568,6 @@ time_out:
 	return ret;
 }
 
-static int m25p80_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	struct m25p *flash = mtd_to_m25p(mtd);
-	uint32_t offset = ofs;
-	uint8_t status_old, status_new;
-	int res = 0;
-
-	mutex_lock(&flash->lock);
-	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
-		res = 1;
-		goto err;
-	}
-
-	status_old = read_sr(flash);
-
-	if (offset < flash->mtd.size-(flash->mtd.size/2))
-		status_new = status_old | SR_BP2 | SR_BP1 | SR_BP0;
-	else if (offset < flash->mtd.size-(flash->mtd.size/4))
-		status_new = (status_old & ~SR_BP0) | SR_BP2 | SR_BP1;
-	else if (offset < flash->mtd.size-(flash->mtd.size/8))
-		status_new = (status_old & ~SR_BP1) | SR_BP2 | SR_BP0;
-	else if (offset < flash->mtd.size-(flash->mtd.size/16))
-		status_new = (status_old & ~(SR_BP0|SR_BP1)) | SR_BP2;
-	else if (offset < flash->mtd.size-(flash->mtd.size/32))
-		status_new = (status_old & ~SR_BP2) | SR_BP1 | SR_BP0;
-	else if (offset < flash->mtd.size-(flash->mtd.size/64))
-		status_new = (status_old & ~(SR_BP2|SR_BP0)) | SR_BP1;
-	else
-		status_new = (status_old & ~(SR_BP2|SR_BP1)) | SR_BP0;
-
-	/* Only modify protection if it will not unlock other areas */
-	if ((status_new&(SR_BP2|SR_BP1|SR_BP0)) >
-					(status_old&(SR_BP2|SR_BP1|SR_BP0))) {
-		write_enable(flash);
-		if (write_sr(flash, status_new) < 0) {
-			res = 1;
-			goto err;
-		}
-	}
-
-err:	mutex_unlock(&flash->lock);
-	return res;
-}
-
-static int m25p80_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	struct m25p *flash = mtd_to_m25p(mtd);
-	uint32_t offset = ofs;
-	uint8_t status_old, status_new;
-	int res = 0;
-
-	mutex_lock(&flash->lock);
-	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
-		res = 1;
-		goto err;
-	}
-
-	status_old = read_sr(flash);
-
-	if (offset+len > flash->mtd.size-(flash->mtd.size/64))
-		status_new = status_old & ~(SR_BP2|SR_BP1|SR_BP0);
-	else if (offset+len > flash->mtd.size-(flash->mtd.size/32))
-		status_new = (status_old & ~(SR_BP2|SR_BP1)) | SR_BP0;
-	else if (offset+len > flash->mtd.size-(flash->mtd.size/16))
-		status_new = (status_old & ~(SR_BP2|SR_BP0)) | SR_BP1;
-	else if (offset+len > flash->mtd.size-(flash->mtd.size/8))
-		status_new = (status_old & ~SR_BP2) | SR_BP1 | SR_BP0;
-	else if (offset+len > flash->mtd.size-(flash->mtd.size/4))
-		status_new = (status_old & ~(SR_BP0|SR_BP1)) | SR_BP2;
-	else if (offset+len > flash->mtd.size-(flash->mtd.size/2))
-		status_new = (status_old & ~SR_BP1) | SR_BP2 | SR_BP0;
-	else
-		status_new = (status_old & ~SR_BP0) | SR_BP2 | SR_BP1;
-
-	/* Only modify protection if it will not lock other areas */
-	if ((status_new&(SR_BP2|SR_BP1|SR_BP0)) <
-					(status_old&(SR_BP2|SR_BP1|SR_BP0))) {
-		write_enable(flash);
-		if (write_sr(flash, status_new) < 0) {
-			res = 1;
-			goto err;
-		}
-	}
-
-err:	mutex_unlock(&flash->lock);
-	return res;
-}
-
 /****************************************************************************/
 
 /*
@@ -903,9 +594,6 @@ struct flash_info {
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
-#define	SST_WRITE	0x04		/* use SST byte programming */
-#define	SECT_32K	0x10		/* OPCODE_BE_32K */
-#define E_FSR		0x08		/* Flag SR exists for flash */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -953,19 +641,15 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "en25q32b", INFO(0x1c3016, 0, 64 * 1024,  64, 0) },
 	{ "en25p64", INFO(0x1c2017, 0, 64 * 1024, 128, 0) },
 	{ "en25q64", INFO(0x1c3017, 0, 64 * 1024, 128, SECT_4K) },
-	{ "en25qh256", INFO(0x1c7019, 0, 64 * 1024, 512, 0) },
 
 	/* Everspin */
 	{ "mr25h256", CAT25_INFO(  32 * 1024, 1, 256, 2) },
 
-	/* GigaDevice */
-	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
-	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
-
 	/* Intel/Numonyx -- xxxs33b */
 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
+	{ "n25q064",  INFO(0x20ba17, 0, 64 * 1024, 128, 0) },
 
 	/* Macronix */
 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
@@ -978,22 +662,10 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
-	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, 0) },
 
 	/* Micron */
-	{ "n25q064",  INFO(0x20ba17, 0, 64 * 1024, 128, 0) },
-	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024, 256, 0) },
-	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
+	{ "n25q128",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
 	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, SECT_4K) },
-	/* Numonyx flash n25q128 - FIXME check the name */
-	{ "n25q128",   INFO(0x20bb18, 0, 64 * 1024, 256, 0) },
-	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024, 256, E_FSR) },
-	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256, E_FSR) },
-	{ "n25q256a13", INFO(0x20ba19,  0, 64 * 1024,  512, SECT_4K | E_FSR) },
-	{ "n25q256a11", INFO(0x20bb19,  0, 64 * 1024,  512, SECT_4K | E_FSR) },
-	{ "n25q512a13", INFO(0x20ba20,  0, 64 * 1024,  1024, SECT_4K | E_FSR) },
-	{ "n25q512a11", INFO(0x20bb20,  0, 64 * 1024,  1024, SECT_4K | E_FSR) },
-	{ "n25q00aa13", INFO(0x20ba21,  0, 64 * 1024,  2048, SECT_4K | E_FSR) },
 
 	/* Spansion -- single (large) sector size only, at least
 	 * for the chips listed here (without boot sectors).
@@ -1014,23 +686,17 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "s25sl032a",  INFO(0x010215,      0,  64 * 1024,  64, 0) },
 	{ "s25sl064a",  INFO(0x010216,      0,  64 * 1024, 128, 0) },
 	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
-	/* s25fl064k supports 4KiB, 32KiB and 64KiB sectors erase size. */
-	/* To support JFFS2, the minimum erase size is 8KiB(>4KiB). */
-	/* And thus, the sector size of s25fl064k is set to 32KiB for */
-	/* JFFS2 support. */
-	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_32K) },
+	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
 
 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
-	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
-	{ "sst25vf080b", INFO(0xbf258e, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
-	{ "sst25vf016b", INFO(0xbf2541, 0, 64 * 1024, 32, SECT_4K | SST_WRITE) },
-	{ "sst25vf032b", INFO(0xbf254a, 0, 64 * 1024, 64, SECT_4K | SST_WRITE) },
-	{ "sst25vf064c", INFO(0xbf254b, 0, 64 * 1024, 128, SECT_4K) },
-	{ "sst25wf512", INFO(0xbf2501, 0, 64 * 1024,  1, SECT_4K | SST_WRITE) },
-	{ "sst25wf010", INFO(0xbf2502, 0, 64 * 1024,  2, SECT_4K | SST_WRITE) },
-	{ "sst25wf020", INFO(0xbf2503, 0, 64 * 1024,  4, SECT_4K | SST_WRITE) },
-	{ "sst25wf040", INFO(0xbf2504, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
-	{ "sst25wf080", INFO(0xbf2505, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
+	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K) },
+	{ "sst25vf080b", INFO(0xbf258e, 0, 64 * 1024, 16, SECT_4K) },
+	{ "sst25vf016b", INFO(0xbf2541, 0, 64 * 1024, 32, SECT_4K) },
+	{ "sst25vf032b", INFO(0xbf254a, 0, 64 * 1024, 64, SECT_4K) },
+	{ "sst25wf512",  INFO(0xbf2501, 0, 64 * 1024,  1, SECT_4K) },
+	{ "sst25wf010",  INFO(0xbf2502, 0, 64 * 1024,  2, SECT_4K) },
+	{ "sst25wf020",  INFO(0xbf2503, 0, 64 * 1024,  4, SECT_4K) },
+	{ "sst25wf040",  INFO(0xbf2504, 0, 64 * 1024,  8, SECT_4K) },
 
 	/* ST Microelectronics -- newer production may have feature updates */
 	{ "m25p05",  INFO(0x202010,  0,  32 * 1024,   2, 0) },
@@ -1044,10 +710,6 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "m25p128", INFO(0x202018,  0, 256 * 1024,  64, 0) },
 	{ "n25q032", INFO(0x20ba16,  0,  64 * 1024,  64, 0) },
 
-	/* Numonyx */
-	{ "n25q032",  INFO(0x20bb16,  0,  64 * 1024,  64, 0) },
-	{ "n25q128",  INFO(0x20bb18,  0,  256 * 1024,  64, 0) },
-
 	{ "m25p05-nonjedec",  INFO(0, 0,  32 * 1024,   2, 0) },
 	{ "m25p10-nonjedec",  INFO(0, 0,  32 * 1024,   4, 0) },
 	{ "m25p20-nonjedec",  INFO(0, 0,  64 * 1024,   4, 0) },
@@ -1081,16 +743,8 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25q32dw", INFO(0xef6016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
-	/* Winbond -- w25q "blocks" are 64K, "sectors" are 32KiB */
-	/* w25q64 supports 4KiB, 32KiB and 64KiB sectors erase size. */
-	/* To support JFFS2, the minimum erase size is 8KiB(>4KiB). */
-	/* And thus, the sector size of w25q64 is set to 32KiB for */
-	/* JFFS2 support. */
-	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_32K) },
+	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
-	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
-	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
-	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
 	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
@@ -1102,16 +756,6 @@ static const struct spi_device_id m25p_ids[] = {
 };
 MODULE_DEVICE_TABLE(spi, m25p_ids);
 
-#ifdef CONFIG_OF
-const struct of_device_id m25p_dt_ids[] = {
-	{ .compatible = "st,m25p", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, m25p_dt_ids);
-#else
-#define m25p_dt_ids NULL
-#endif
-
 static const struct spi_device_id *jedec_probe(struct spi_device *spi)
 {
 	int			tmp;
@@ -1165,10 +809,9 @@ static int m25p_probe(struct spi_device *spi)
 	struct flash_info		*info;
 	unsigned			i;
 	struct mtd_part_parser_data	ppdata;
-	struct device_node __maybe_unused *np = spi->dev.of_node;
 
 #ifdef CONFIG_MTD_OF_PARTS
-	if (!of_device_is_available(np))
+	if (!of_device_is_available(spi->dev.of_node))
 		return -ENODEV;
 #endif
 
@@ -1220,8 +863,7 @@ static int m25p_probe(struct spi_device *spi)
 	flash = kzalloc(sizeof *flash, GFP_KERNEL);
 	if (!flash)
 		return -ENOMEM;
-	flash->command = kmalloc(MAX_CMD_SIZE + (flash->fast_read ? 1 : 0),
-					GFP_KERNEL);
+	flash->command = kmalloc(MAX_CMD_SIZE + FAST_READ_DUMMY_BYTE, GFP_KERNEL);
 	if (!flash->command) {
 		kfree(flash);
 		return -ENOMEM;
@@ -1252,134 +894,39 @@ static int m25p_probe(struct spi_device *spi)
 	flash->mtd.writesize = 1;
 	flash->mtd.flags = MTD_CAP_NORFLASH;
 	flash->mtd.size = info->sector_size * info->n_sectors;
-
-	{
-#ifdef CONFIG_OF
-		const char *comp_str;
-		u32 is_dual;
-		np = of_get_next_parent(spi->dev.of_node);
-		of_property_read_string(np, "compatible", &comp_str);
-		if (!strcmp(comp_str, "xlnx,ps7-qspi-1.00.a")) {
-			if (of_property_read_u32(np, "is-dual", &is_dual) < 0) {
-				/* Default to single if prop not defined */
-				flash->shift = 0;
-				flash->isstacked = 0;
-				flash->isparallel = 0;
-			} else {
-				if (is_dual == 1) {
-					/* dual parallel */
-					flash->shift = 1;
-					info->sector_size <<= flash->shift;
-					info->page_size <<= flash->shift;
-					flash->mtd.size <<= flash->shift;
-					flash->isparallel = 1;
-					flash->isstacked = 0;
-				} else {
-#ifdef CONFIG_SPI_XILINX_PS_QSPI_DUAL_STACKED
-					/* dual stacked */
-					flash->shift = 0;
-					flash->mtd.size <<= 1;
-					flash->isstacked = 1;
-					flash->isparallel = 0;
-#else
-					/* single */
-					flash->shift = 0;
-					flash->isstacked = 0;
-					flash->isparallel = 0;
-#endif
-				}
-			}
-		}
-#else
-		/* Default to single */
-		flash->shift = 0;
-		flash->isstacked = 0;
-		flash->isparallel = 0;
-#endif
-	}
-
 	flash->mtd._erase = m25p80_erase;
-	flash->mtd._read = m25p80_read_ext;
-
-	/* flash protection support for STmicro chips */
-	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ST) {
-		flash->mtd._lock = m25p80_lock;
-		flash->mtd._unlock = m25p80_unlock;
-	}
+	flash->mtd._read = m25p80_read;
 
 	/* sst flash chips use AAI word program */
-	if (info->flags & SST_WRITE)
+	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_SST)
 		flash->mtd._write = sst_write;
 	else
-		flash->mtd._write = m25p80_write_ext;
+		flash->mtd._write = m25p80_write;
 
 	/* prefer "small sector" erase if possible */
 	if (info->flags & SECT_4K) {
 		flash->erase_opcode = OPCODE_BE_4K;
-		flash->mtd.erasesize = 4096 << flash->shift;
-	} else if (info->flags & SECT_32K) {
-		flash->erase_opcode = OPCODE_BE_32K;
-		flash->mtd.erasesize = 32768 << flash->shift;
+		flash->mtd.erasesize = 4096;
 	} else {
 		flash->erase_opcode = OPCODE_SE;
 		flash->mtd.erasesize = info->sector_size;
 	}
 
-	flash->read_opcode = OPCODE_NORM_READ;
-	flash->prog_opcode = OPCODE_PP;
-	flash->dummycount = 0;
-
 	if (info->flags & M25P_NO_ERASE)
 		flash->mtd.flags |= MTD_NO_ERASE;
 
-	if (info->flags & E_FSR)
-		flash->check_fsr = 1;
-
-	flash->jedec_id = info->jedec_id;
 	ppdata.of_node = spi->dev.of_node;
 	flash->mtd.dev.parent = &spi->dev;
 	flash->page_size = info->page_size;
 	flash->mtd.writebufsize = flash->page_size;
 
-	flash->fast_read = false;
-#ifdef CONFIG_OF
-	if (np && of_property_read_bool(np, "m25p,fast-read"))
-		flash->fast_read = true;
-#endif
-
-#ifdef CONFIG_M25PXX_USE_FAST_READ
-	flash->fast_read = true;
-#endif
-	if (flash->fast_read) {
-		flash->read_opcode = OPCODE_FAST_READ;
-		flash->dummycount = 1;
-	}
-
-	if (spi->master->flags & SPI_MASTER_QUAD_MODE) {
-		flash->read_opcode = OPCODE_QUAD_READ;
-		flash->prog_opcode = OPCODE_QPP;
-		flash->dummycount = 1;
-	}
-
 	if (info->addr_width)
 		flash->addr_width = info->addr_width;
 	else {
 		/* enable 4-byte addressing if the device exceeds 16MiB */
 		if (flash->mtd.size > 0x1000000) {
-#ifdef CONFIG_OF
-			const char *comp_str;
-			np = of_get_next_parent(spi->dev.of_node);
-			of_property_read_string(np, "compatible", &comp_str);
-			if (!strcmp(comp_str, "xlnx,ps7-qspi-1.00.a")) {
-				flash->addr_width = 3;
-				set_4byte(flash, info->jedec_id, 0);
-			} else {
-#endif
-				flash->addr_width = 4;
-				set_4byte(flash, info->jedec_id, 1);
-#ifdef CONFIG_OF
-			}
-#endif
+			flash->addr_width = 4;
+			set_4byte(flash, info->jedec_id, 1);
 		} else
 			flash->addr_width = 3;
 	}
@@ -1433,7 +980,6 @@ static struct spi_driver m25p80_driver = {
 	.driver = {
 		.name	= "m25p80",
 		.owner	= THIS_MODULE,
-		.of_match_table = m25p_dt_ids,
 	},
 	.id_table	= m25p_ids,
 	.probe	= m25p_probe,
-- 
1.7.5.4

