From 8e46d060d6763363b42ce21a053ae2538c7ac24c Mon Sep 17 00:00:00 2001
From: Wei Zhang <wzhang@netlogicmicro.com>
Date: Wed, 25 Jan 2012 11:42:43 -0800
Subject: [PATCH 530/761] Init USB EHCI controller on node 1~3 (Bug 17853)

--Runtime detect nodes and initiation the USB EHCI controller on other nodes.

Based on Broadcom SDK 2.3.

Signed-off-by: Wei Zhang <wzhang@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp_irq.h |    7 +++++
 arch/mips/netlogic/xlp/platform.c        |   42 +++++++++++++++++++-----------
 2 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 796f5e3..00e8098 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -40,6 +40,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_IRQ_TIMER                7
 #define XLP_IRQ_RESERVED_MAX         8
 
+#define arch_setup_msi_irqs	arch_setup_msi_irqs /* defines arch. specific msi setup function */
+#define xlp_irq_to_irt(x)	((x) - XLP_IRQ_RESERVED_MAX)
+#define xlp_irt_to_irq(x)	((x) + XLP_IRQ_RESERVED_MAX)
+
+#define XLP_UART_IRT_OFFSET			(133 + XLP_IRQ_RESERVED_MAX)
+#define XLP_UART_IRQ(x)	(XLP_UART_IRT_OFFSET + (x))
+
 #define XLP_PIC_IRQ_BASE             XLP_IRQ_RESERVED_MAX
 
 #define xlp_pic_irt_to_irq(irt) ((irt) + XLP_PIC_IRQ_BASE)
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 8a7622d..7d11053 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -37,7 +37,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal.h>
-#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/xlp_hal_pic.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 #include <asm/netlogic/iomap.h>
@@ -97,10 +97,10 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].mapbase       = DEFAULT_NETLOGIC_IO_BASE 
 						+ NETLOGIC_IO_UART_0_OFFSET + port_id * XLP_UART_PORTIO_OFFSET;
         xlp_uart_port[port_id].membase       = (void __iomem *)xlp_uart_port[port_id].mapbase;
-        xlp_uart_port[port_id].irq           = xlp_pic_irt_to_irq(XLP_PIC_IRT_UART(port_id));
+        xlp_uart_port[port_id].irq           = XLP_UART_IRQ(port_id);
 
         xlp_uart_port[port_id].uartclk       = UART_CLK;
-        xlp_uart_port[port_id].iotype        = UPIO_MEM32;
+//        xlp_uart_port[port_id].iotype        = UPIO_NLM;
         xlp_uart_port[port_id].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
         xlp_uart_port[port_id].type          = PORT_16550A;
         xlp_uart_port[port_id].regshift      = 2;
@@ -108,30 +108,42 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].serial_out    = xlp_uart_out;
 }
 
-#ifdef CONFIG_USB
-static void xlp_usb_hw_start(int ctrl_no)
+static void xlp_usb_hw_start_controller(int node, int ctrl_no)
 {
 	int val;
 	/* Reset USB phy */
-	val = usb_reg_read( 0, ctrl_no, XLP_USB_PHY0);
+	val = usb_reg_read( node, ctrl_no, XLP_USB_PHY0);
 
 	if(ctrl_no == 0)
 		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
 	else if(ctrl_no == 3)
-		val &= ~(USBPHYRESET | USBPHYPORTRESET0 | USBPHYPORTRESET1);
-	usb_reg_write(0, ctrl_no, XLP_USB_PHY0, val);
+		val &= ~(USBPHYPORTRESET0 | USBPHYPORTRESET1);
+	usb_reg_write(node, ctrl_no, XLP_USB_PHY0, val);
 
 	udelay(2000);
 	/* Bring usb controller out of reset
- 	 */
-	val = usb_reg_read( 0, ctrl_no, XLP_USB_CTL0);
+ *  	 */
+	val = usb_reg_read( node, ctrl_no, XLP_USB_CTL0);
 	val &= ~(USBCONTROLLERRESET );
 	val |= 0x4;
-	usb_reg_write(0, ctrl_no, XLP_USB_CTL0, val);
+	usb_reg_write(node, ctrl_no, XLP_USB_CTL0, val);
 
 	return;
 }
-#endif
+
+static void xlp_usb_hw_start(void)
+{
+	int n, online;
+	int total=num_possible_nodes();
+
+	for(n=0; n<total; n++) {
+		online=node_online(n);
+		if(!online)	continue;
+
+		xlp_usb_hw_start_controller(n, 0);
+		xlp_usb_hw_start_controller(n, 3);
+	}
+}
 
 struct dev2drv dev2drv_table[MAX_DEV2DRV] = {
 	{XLP_DEVID_UART, "serial8250",	11,	0,	PLAT_DRV},
@@ -221,7 +233,7 @@ static int xlp_find_pci_dev(void)
 						pres[0].end	= mmio;
 						pres[0].flags	= IORESOURCE_MEM;
 						irt = (nlm_hal_read_32bit_reg(mmio, DEV_IRT_INFO) & 0xFFFF);
-						irq = xlp_pic_irt_to_irq(irt);
+						irq = xlp_irt_to_irq(irt);
 
 						pres[1].start = irq;
 						pres[1].end = irq;
@@ -242,9 +254,9 @@ static int xlp_find_pci_dev(void)
 static int __init platform_devinit(void)
 {
 	xlp_find_pci_dev();
+
 #ifdef CONFIG_USB
-	xlp_usb_hw_start(0);
-	xlp_usb_hw_start(3);
+	xlp_usb_hw_start();
 #endif
 	return 0;
 }
-- 
1.7.10.4

