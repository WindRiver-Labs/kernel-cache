From bc030d5fc10e823ca40ecf434b08dea95f08681b Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@broadcom.com>
Date: Mon, 26 Nov 2012 09:29:03 -0800
Subject: [PATCH 752/760] 16g_support: fix compilation issue and additional port from 2.6.32

  o Recreate 16g default configs based on the latest evp default configs
  o Port additional changes from 2.6.32 (mostly related numa)

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@broadcom.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/mmzone.h |    1 +
 arch/mips/netlogic/common/memory.c           |   17 ++++++++++++++++-
 arch/mips/netlogic/xlp/numa.c                |   22 ++++++++++++++++++----
 mm/percpu-vm.c                               |    8 ++++++++
 4 files changed, 43 insertions(+), 5 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/mmzone.h b/arch/mips/include/asm/mach-netlogic/mmzone.h
index 28f9a37..47db26e 100644
--- a/arch/mips/include/asm/mach-netlogic/mmzone.h
+++ b/arch/mips/include/asm/mach-netlogic/mmzone.h
@@ -25,6 +25,7 @@ struct nlm_node_mem_info {
 	struct nlm_node_mem_frag mem[NLM_MAX_MEM_FRAGS_PER_NODE];
 	int frags;
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	/* node 0: minimum start pfn about DMA region; other nodes: minimum start pfn */
 	int min_start_pfn;
 #endif
 };
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index d606d2e..34e254d 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -37,6 +37,7 @@
 
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
 #include <linux/bootmem.h>
+#include <linux/gfp.h>
 #include <asm/pgtable.h>
 #endif
 
@@ -249,12 +250,26 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 #ifdef CONFIG_NUMA
 		/* For NUMA, for each node, we have to wire the minimum physical page for that node.
 		 * NUMA uses that piece of memory immediately to keep its internal data structure.
+		 *
+		 * For node 0: the first chunk of memory above the MAX_DMA_ADDRESS needs to be wired
+		 * as the kernel will allocate space in that area before the exception handlers etc.
+		 * are setup.
+		 *
+		 * For other nodes, the first chunk of memory available on that node needs to be wired.
 		 */
-		for (node = 1; node < NLM_MAX_CPU_NODE; node ++) {
+		for (node = 0; node < NLM_MAX_CPU_NODE; node ++) {
 			paddr = PFN_PHYS(node_mem_info[node].min_start_pfn);
 			if (paddr == 0)
 				continue;
 
+			/* for node 0, wire extra lines only if it is not wired yet */
+			if (node == 0 && node_mem_info[0].min_start_pfn < MAX_WIRED_PFN)
+				continue;
+
+			/* make sure the paddr is aligned also */
+			if (paddr % ( 2 * LARGEST_TLBPAGE_SZ))
+				paddr -= (paddr % (2 * LARGEST_TLBPAGE_SZ));
+
 			vaddr = KERNEL_SEG_START + paddr;
 			tlb.entryHi = vaddr;
 			tlb.entrylo0 = page_entrylo(paddr, attr);
diff --git a/arch/mips/netlogic/xlp/numa.c b/arch/mips/netlogic/xlp/numa.c
index 16cd814..8963bf2 100644
--- a/arch/mips/netlogic/xlp/numa.c
+++ b/arch/mips/netlogic/xlp/numa.c
@@ -199,10 +199,24 @@ void __init nlm_numa_bootmem_init(unsigned long reserved_end)
 		node_mem_info[node].frags++;
 
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
-		if (seg == 0)
-			node_mem_info[node].min_start_pfn = start;
-		else if (start < node_mem_info[node].min_start_pfn)
-			node_mem_info[node].min_start_pfn = start;
+		if (node == 0) {
+			/* 40 bit physical address, min_start_pfn is the minimum above dma region */
+			unsigned long max_dma_pfn = (MAX_DMA_ADDRESS & 0xffffffffffULL) >> PAGE_SHIFT;
+			if (seg == 0) {
+				if (start >= max_dma_pfn)
+					node_mem_info[node].min_start_pfn = start;
+			} else if (start > max_dma_pfn) {
+				if (node_mem_info[node].min_start_pfn == 0)
+					node_mem_info[node].min_start_pfn = start;
+				else if (start < node_mem_info[node].min_start_pfn)
+					node_mem_info[node].min_start_pfn = start;
+			}
+		} else {
+			if (seg == 0)
+				node_mem_info[node].min_start_pfn = start;
+			else if (start < node_mem_info[node].min_start_pfn)
+				node_mem_info[node].min_start_pfn = start;
+		}
 #endif
 
 		if (end > max_low_pfn)
diff --git a/mm/percpu-vm.c b/mm/percpu-vm.c
index 405d331..aa81658 100644
--- a/mm/percpu-vm.c
+++ b/mm/percpu-vm.c
@@ -107,10 +107,18 @@ static int pcpu_alloc_pages(struct pcpu_chunk *chunk,
 			    struct page **pages, unsigned long *populated,
 			    int page_start, int page_end)
 {
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	gfp_t gfp = GFP_KERNEL | __GFP_HIGHMEM | __GFP_COLD;
+#else
 	const gfp_t gfp = GFP_KERNEL | __GFP_HIGHMEM | __GFP_COLD;
+#endif
 	unsigned int cpu;
 	int i;
 
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+	gfp |= GFP_DMA;
+#endif
+
 	for_each_possible_cpu(cpu) {
 		for (i = page_start; i < page_end; i++) {
 			struct page **pagep = &pages[pcpu_page_idx(cpu, i)];
-- 
1.7.0.4

