From e5ffa7f3846d67fe738f2efed8ee9c8c048d5011 Mon Sep 17 00:00:00 2001
From: Yonghong Song <ysong@netlogicmicro.com>
Date: Tue, 31 Jan 2012 14:35:09 -0800
Subject: [PATCH 535/762] Remove some workarounds for XLP8xx B0 and XLP3xx

  o These workarounds are needed for XLP8xx A0 and A1. Since we do not
    have proper APIs in HAL yet, so I also keep the workaround
    for XLP8xx A2.
  o When no support for XLP8xx A1 chips, these workarounds can be
    removed from the source code base.

Based on Broadcom SDK 2.3.

Signed-off-by: Yonghong Song <ysong@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../asm/netlogic/xlp8xx/cpu_control_macros.h       |    1 +
 arch/mips/netlogic/xlp/cpu_control.c               |   47 +++++++++++++-------
 arch/mips/netlogic/xlp/cpu_control_asm.S           |   24 ++++++++--
 arch/mips/netlogic/xlp/setup.c                     |    5 ++
 arch/mips/netlogic/xlp/smp.c                       |    3 +
 5 files changed, 59 insertions(+), 21 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
index b1b66e8..e851b4a 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu_control_macros.h
@@ -26,6 +26,7 @@ u32 get_cpu_freq(int);
 void enable_cpus(unsigned int, unsigned int);
 u32 get_core_dfs(int);
 u32 change_cpu_freq(int, int);
+extern int xlp8xx_a01_workaround_needed;
 #define get_cpu_freq_masked(cpu_num, mask)\
 	((get_cpu_freq(cpu_num)/1000ULL) & (mask))
 #define XLP_FREQ_MASK	(0xfffffff0)
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index be0c65e..bba5f5e 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -74,22 +74,37 @@ static inline void jump_address(unsigned long entry)
 static inline void config_lsu(void)
 {
 	uint32_t tmp0, tmp1, tmp2;
-	__asm__ __volatile__ (
-		".set push\n"
-		".set noreorder\n"
-		"li      %0, "STR(LSU_DEFEATURE)"\n"
-		"mfcr    %1, %0\n"
-		"lui     %2, 0x4080\n"
-		"or      %1, %1, %2\n"
-		"li	 %2, ~0xe\n"
-		"and	 %1, %1, %2\n"
-		"mtcr    %1, %0\n"
-		"li      %0, "STR(SCHED_DEFEATURE)"\n"
-		"lui     %1, 0x0100\n"
-		"mtcr    %1, %0\n"
-		".set pop\n"
-		: "=r" (tmp0), "=r" (tmp1), "=r" (tmp2)
-	);
+
+	if (xlp8xx_a01_workaround_needed) {
+		__asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			"li      %0, "STR(LSU_DEFEATURE)"\n"
+			"mfcr    %1, %0\n"
+			"lui     %2, 0x4080\n"
+			"or      %1, %1, %2\n"
+			"li	 %2, ~0xe\n"
+			"and	 %1, %1, %2\n"
+			"mtcr    %1, %0\n"
+			"li      %0, "STR(SCHED_DEFEATURE)"\n"
+			"lui     %1, 0x0100\n"
+			"mtcr    %1, %0\n"
+			".set pop\n"
+			: "=r" (tmp0), "=r" (tmp1), "=r" (tmp2)
+		);
+	} else {
+		__asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			"li      %0, "STR(LSU_DEFEATURE)"\n"
+			"mfcr    %1, %0\n"
+			"lui     %2, 0x4080\n"
+			"or      %1, %1, %2\n"
+			"mtcr    %1, %0\n"
+			".set pop\n"
+			: "=r" (tmp0), "=r" (tmp1), "=r" (tmp2)
+		);
+	}
 }
 
 static void enable_cores(unsigned int node, unsigned int cores_bitmap)
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index a8b644d..e1a31ae 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -56,7 +56,17 @@
 	prog_c0_status 0 ST0_BEV
 #endif
 	mfc0 		t0, CP0_EBASE, 1
+	andi		t0, 0x3
+	bnez		t0, 20f
+
+	/* Do this after tlb is set up */
+	__config_lsu
+
+20:
+
+	mfc0 		t0, CP0_EBASE, 1
 	andi 		t0, 0x7f
+
 	PTR_LA		t1, xlp_stack_pages_temp
 	li   		t2, _THREAD_SIZE
 	srl  		t2, 2
@@ -74,20 +84,27 @@
 	.set push
 	.set noreorder
 	li      t0, LSU_DEFEATURE
-	mfcr    t1, t0
 
+	mfcr    t1, t0
 	lui     t2, 0x4080  # Enable Unaligned Access, L2HPE
 	or      t1, t1, t2
+	mtcr    t1, t0
+
+        PTR_LA	t2, xlp8xx_a01_workaround_needed
+	lw	t2, 0(t2)
+	beqz	t2, 10f
 
+	mfcr    t1, t0
 	li	t2, ~0xe    # S1RCM
 	and	t1, t1, t2
-
 	mtcr    t1, t0
 
 	li      t0, SCHED_DEFEATURE
 	lui     t1, 0x0100 # Experimental: Disable BRU accepting ALU ops
 	mtcr    t1, t0
 
+10:
+
 	.set pop
 .endm
 
@@ -153,9 +170,6 @@ EXPORT(reset_entry)
 	lw      t1, (SYS_CPUNONCOHERENTMODE_REG << 2)(t2)
 	sync
 
-	/* Configure LSU on Non-0 Cores. */
-	__config_lsu
-
 #ifdef CONFIG_64BIT
 	dla     t1, boot_siblings_start
 	dla     t2, __boot_siblings
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 096e0e8..1dfb6c6 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -615,6 +615,11 @@ void __init prom_init(void)
 
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
+	/* FIXME: we should also remove it for xlp8xx a2, but we do not have interface function
+	 * for it yet. Once A1 is phased out in the field, this workaround code should be removed.
+	 */
+	xlp8xx_a01_workaround_needed = is_nlm_xlp8xx_ax();
+
 #ifdef CONFIG_SMP
 	/* update TLB size after waking up threads */
 	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index fd54eae..74f69cd 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -220,6 +220,9 @@ static inline void config_mmu(void)
 {
 	uint32_t tmp0;
 
+	if (!xlp8xx_a01_workaround_needed)
+		return;
+
 	/*
 	 * Dummy write for A0 bug in MMU
 	 */
-- 
1.7.0.4

