From 26811a66c3db23ce7817d0481553a04ec91b2aef Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 22 Apr 2013 17:09:36 +0800
Subject: [PATCH 094/762] cleanup debug and unused code

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlp/cpu_control.c |  160 +---------------------------------
 arch/mips/netlogic/xlp/irq.c         |   42 +---------
 arch/mips/netlogic/xlp/on_chip.c     |   14 ++--
 arch/mips/netlogic/xlp/smp.c         |   95 +++++++++++++++++---
 4 files changed, 93 insertions(+), 218 deletions(-)

diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 8c1b1e8..3eaabea 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -53,7 +53,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* Globals Section 
  */ 
-#define XLP_SYS_DEV_BASE	0x35000
 uint32_t cores_bitmap = 0x1;	/* Bitmap of cores to enable  */
 int threads_to_enable; 			/* Threads to enable per core */
 spinlock_t smp_lock;
@@ -67,155 +66,6 @@ unsigned long linuxsp[NR_CPUS];
  */
 extern unsigned char __stack[];
 extern char boot_siblings_start[], boot_siblings_end[];
-#ifndef __CPUCONTROL_MACROS_H__
-#define __CPUCONTROL_MACROS_H__
-
-#define CHIP_PID_XLP    0x00
-#define NMI_BASE    	0xffffffffbfc00000UL
-#define NMI_BASE_ASM   	0xbfc00000
-
-/* CPU Internal Blocks specific to XLP .
- * These are accessed using the mfcr/mtcr
- * instructions. Blocks [0-5] are same for
- * XLR and XLP
- */
-#define CPU_BLOCKID_MAP                         0x0a
-/* Offsets of interest from the 'MAP' Block */
-#define BLKID_MAP_THREADMODE                    0x00 
-#define BLKID_MAP_EXT_EBASE_ENABLE              0x04 
-#define BLKID_MAP_CCDI_CONFIG                   0x08
-#define BLKID_MAP_THRD0_CCDI_STATUS             0x0c    
-#define BLKID_MAP_THRD1_CCDI_STATUS             0x10
-#define BLKID_MAP_THRD2_CCDI_STATUS             0x14    
-#define BLKID_MAP_THRD3_CCDI_STATUS             0x18
-#define BLKID_MAP_THRD0_DEBUG_MODE              0x1c
-#define BLKID_MAP_THRD1_DEBUG_MODE              0x20
-#define BLKID_MAP_THRD2_DEBUG_MODE              0x24
-#define BLKID_MAP_THRD3_DEBUG_MODE              0x28
-#define BLKID_MAP_MISC_STATE                    0x60
-#define BLKID_MAP_DEBUG_READ_CTL                0x64
-#define BLKID_MAP_DEBUG_READ_REG0               0x68
-#define BLKID_MAP_DEBUG_READ_REG1               0x6c
-
-#define CPU_BLOCKID_SCH                         7
-#define CPU_BLOCKID_SCU                         8
-#define CPU_BLOCKID_FPU                         9
-
-/* ----------------------------------
- *   XLP RESET Physical Address Map
- * ----------------------------------
- * PCI ECFG : 0x18000000 - 0x1bffffff 
- * PCI CFG  : 0x1c000000 - 0x1cffffff 
- * FLASH    : 0x1fc00000 - 0x1fffffff 
- * ----------------------------------
- */
-
-/* 
- * The DEFAULT_XLP_IO_BASE value is what is
- * programmed in the NBU's (NorthBridge Unit) 
- * ECFG_BAR register. The NBU itself is 
- * accessible as [BDF:0,0,0].
- */
-#define DEFAULT_XLP_IO_BASE       0xffffffffb8000000ULL
-#define DEFAULT_XLP_IO_BASE_VIRT  0xffffffffb8000000      /* IO_BASE for Assembly macros */
-#define DEFAULT_CPU_IO_BASE       DEFAULT_XLP_IO_BASE
-#define DEFAULT_CPU_IO_BASE_VIRT  DEFAULT_XLP_IO_BASE_VIRT
-#define CPU_IO_SIZE               (64<<20)        /* Size of the ECFG Space      */
-#define HDR_OFFSET                0x100           /* Skip 256 bytes of cfg. hdrs */
-
-/* The On-Chip functional blocks for XLP */
-
-/* --------------------------------------------------------------*/
-/* Accesses Based on Enhanced Configuration Mechanism            */
-/* --------------------------------------------------------------*/
-/* Interface | Bus          | Dev       |  Func                  */
-/* --------------------------------------------------------------*/
-#define        BRIDGE        (0x00<<20) | (0x00<<15) | (0x00<<12)
-#define        PIC           (0x00<<20) | (0x00<<15) | (0x04<<12)
-#define        CMS           (0x00<<20) | (0x04<<15) | (0x00<<12)
-#define        UART0         (0x00<<20) | (0x06<<15) | (0x00<<12)
-#define        UART1         (0x00<<20) | (0x06<<15) | (0x01<<12)
-#define        I2C0          (0x00<<20) | (0x06<<15) | (0x02<<12)
-#define        I2C1          (0x00<<20) | (0x06<<15) | (0x03<<12)
-#define        GPIO          (0x00<<20) | (0x06<<15) | (0x04<<12)
-#define        SYS           (0x00<<20) | (0x06<<15) | (0x05<<12)
-#define        JTAG          (0x00<<20) | (0x06<<15) | (0x06<<12)
-#define        NOR           (0x00<<20) | (0x07<<15) | (0x00<<12)
-#define        NAND          (0x00<<20) | (0x07<<15) | (0x01<<12)
-#define        SPI           (0x00<<20) | (0x07<<15) | (0x02<<12)
-#define        MMC           (0x00<<20) | (0x07<<15) | (0x03<<12)
-
-#define CPU_MMIO_OFFSET(x) (DEFAULT_CPU_IO_BASE_VIRT + (x) + HDR_OFFSET)
-
-
-#define SYS_CHIPRST_REG                 0
-#define SYS_PWRONRSTCFG0_REG            1
-#define SYS_EFUSEDEV_CFG0_REG           2
-#define SYS_EFUSEDEV_CFG1_REG           3
-#define SYS_EFUSEDEV_CFG2_REG           4
-#define SYS_EFUSEDEV_CFG3_REG           5
-#define SYS_EFUSEDEV_CFG4_REG           6
-#define SYS_EFUSEDEV_CFG5_REG           7
-#define SYS_EFUSEDEV_CFG6_REG           8
-#define SYS_EFUSEDEV_CFG7_REG           9 
-#define SYS_PLLCTRL_REG                 10
-#define SYS_CPURST_REG                  11
-#define SYS_CPUTHREADEN_REG             12
-#define SYS_CPUNONCOHERENTMODE_REG      13
-#define SYS_COREDFSDISCTRL_REG          14
-#define SYS_COREDFSRSTCTRL_REG          15
-#define SYS_COREDFSBYPCTRL_REG          16
-#define SYS_COREDFSPHACTRL_REG          17
-#define SYS_COREDFSDIVCTRL_REG          18
-#define SYS_SYSRST_REG                  19
-#define SYS_SYSDFSDISCTRL_REG           20
-#define SYS_SYSDFSRSTCTRL_REG           21
-#define SYS_SYSDFSBYPCTRL_REG           22
-#define SYS_SYSDFSDIVCTRL_REG           23
-#define SYS_DMCDFSCTRL_REG              24
-
-
-#ifndef __ASSEMBLY__
-static inline int num_ones(unsigned long mask)
-{
-	int  nones;
-	for (nones = 0; mask; mask >>= 1) {
-		if (mask & 0x1)
-			++nones;
-	}
-	return nones;
-}
-
-enum processor_sys
-{
-	SYS_CHIPRST                     = 0,
-	SYS_PWRONRSTCFG0                = 1,
-	SYS_EFUSEDEV_CFG0               = 2,
-	SYS_EFUSEDEV_CFG1               = 3,
-	SYS_EFUSEDEV_CFG2               = 4,
-	SYS_EFUSEDEV_CFG3               = 5,
-	SYS_EFUSEDEV_CFG4               = 6,
-	SYS_EFUSEDEV_CFG5               = 7,
-	SYS_EFUSEDEV_CFG6               = 8,
-	SYS_EFUSEDEV_CFG7               = 9, 
-	SYS_PLLCTRL                     = 10,
-	SYS_CPURST                      = 11,
-	SYS_CPUTHREADEN                 = 12,
-	SYS_CPUNONCOHERENTMODE          = 13,
-	SYS_COREDFSDISCTRL              = 14,
-	SYS_COREDFSRSTCTRL              = 15,
-	SYS_COREDFSBYPCTRL              = 16,
-	SYS_COREDFSPHACTRL              = 17,
-	SYS_COREDFSDIVCTRL              = 18,
-	SYS_SYSRST                      = 19,
-	SYS_SYSDFSDISCTRL               = 20,
-	SYS_SYSDFSRSTCTRL               = 21,
-	SYS_SYSDFSBYPCTRL               = 22,
-	SYS_SYSDFSDIVCTRL               = 23,
-	SYS_DMCDFSCTRL                  = 24
-};
-#endif
-#endif /* __CPUCONTROL_MACROS_H__ */
 extern char reset_entry[], reset_entry_end[];
 //extern void xlr_loader_init(void);
 
@@ -232,15 +82,14 @@ static inline void jump_address(unsigned long entry)
 
 void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num) {
 	uint32_t core, value, start_core, i = 0;
+	uint64_t sys_mmio;
 
        if(node == 0)
                 start_core = 0x2;
         else
                 start_core = 0x1;
 
-        nlm_reg_t *sys_mmio =(nlm_reg_t *) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
-
-	printk("sys_mmio = %p\n", sys_mmio);
+        sys_mmio =(uint64_t) (XLP_ECFG_BASE + XLP_SYS_DEV_BASE + 0x40000 * node );
 
 	for (core=start_core; core!=(0x1<<8); core<<=1) {
 
@@ -281,11 +130,11 @@ void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_n
  */
 void enable_cpus( unsigned int node, unsigned int onlinemask)
 {
-printk("[%s] node:%p \n", __FUNCTION__, node );
 	uint32_t cbitmap;
 	uint32_t t0_bitmap = 0x0;
 	uint32_t t0_positions = 0, index=3;
-	uint32_t thread_bitmask, flags;
+	uint32_t thread_bitmask;
+	unsigned long flags;
 	/* Extract the bitmap of 'cores'
 	 * from the complete input bitmask
 	 */
@@ -304,7 +153,6 @@ printk("[%s] node:%p \n", __FUNCTION__, node );
 			index+=3;
 		}
 
-		printk("Node %d Cores Bitmap=0x%x\n", node, cores_bitmap);
 
 		/* As for the threads to be enabled
 	 	* per core, use Core0 as a reference
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 5e43a70..143a3f2 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -162,28 +162,13 @@ static void pic_ack(unsigned int irq)
 		printk("can't find irt for irq: %d\n",irq);
 		return;
 	}
-	/*
-	if(irq!=7 && irq != 17 && irq != 18)
- 	printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
-	*/
 	/* If edge triggered IRQ, ack it immediately, else when the device
 	 * interrupt condition is cleared, we may lose interrupts 
 	 */
 	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
 		spin_lock_irqsave(&nlm_common_pic_lock, flags);
-		/*
-		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-		if(irq!=7 && irq != 17 && irq != 18)
-		printk("[%s] pending1 :%lx\n", __func__,val);
-		*/
 
 		nlm_hal_ack_pic(irt);
-		/*
-		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-		
-		if(irq!=7 && irq != 17 && irq != 18)
-		printk("[%s] pending1 :%lx\n", __func__,val);
-		*/
 		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 	}
 }
@@ -203,24 +188,10 @@ static void pic_end(unsigned int irq)
 		printk("can't find irt for irq: %d\n",irq);
 		return;
 	}
-	/*
-	if(irq!=7 && irq != 17 && irq != 18)
- 		printk("[%s]: IN irq=%d irt=%d\n", __func__, irq , irt); 
-	*/
 	/* If level triggered, ack it after the device condition is cleared */
 	if (!PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
 		spin_lock_irqsave(&nlm_common_pic_lock, flags);
-		/*
-		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-		if(irq!=7 && irq != 17 && irq != 18)
-		printk("[%s] pending1 :%lx\n", __func__,val);
-		*/
 		nlm_hal_ack_pic(irt);
-		/*
-		val = nlm_hal_read_pic_reg((pic_reg_t *)XLP_IO_PIC_OFFSET, PIC_INT_PENDING1);
-		if(irq!=7 && irq != 17 && irq != 18)
-			printk("[%s] pending1 :%lx\n", __func__,val);
-		*/
 		spin_unlock_irqrestore(&nlm_common_pic_lock, flags);
 	}
 }
@@ -435,7 +406,6 @@ void do_nlm_common_IRQ(unsigned int irq, struct pt_regs *regs)
 
 void __cpuinit nlm_smp_irq_init(void)
 {
-	printk("[%s]\n",__FUNCTION__);
 	/* set interrupt mask for non-zero cpus */
 	write_64bit_cp0_eimr(nlm_xlp_irq_mask | (1 << IRQ_TIMER));
 }
@@ -558,7 +528,7 @@ asmlinkage void plat_irq_dispatch(void)
 		nlm_common_timer_interrupt(pt_regs, IRQ_TIMER);
 		return;
 	}
-	/*TODO use dcltz: optimize below code */
+	
 	for (i = 63; i != -1; i--) {
 		if (eirr & (1ULL << i))
 			break;
@@ -567,17 +537,9 @@ asmlinkage void plat_irq_dispatch(void)
 		printk("no interrupt !!\n");
 		return;
 	}
-	/*ack eirr */
-	if(i == 58 || i == 6)
-	{
-//		printk("[%s] ack cp0_eirr:%lx %d\n",__func__,eirr, i);
-	}
+	
 	write_64bit_cp0_eirr(1ULL << i);
 	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
-	if(i == 58)
-	{
-		printk("[%s] ack cp0_eirr:%llx %d\n",__func__,eirr, i);
-	}
 	do_nlm_common_IRQ(i, pt_regs);
 	return;
 }
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index f0b02d6..abdb4be 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -376,23 +376,23 @@ atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
 static void nlm_usb_init (void)
 {
 	volatile unsigned int value;
-	nlm_reg_t * gpio_mmio = (nlm_reg_t*)xlp_gpio_base;
 
-	/* The NLM-Specific USB Block */
+        nlm_reg_t * gpio_mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
+        nlm_reg_t * usb_mmio  = netlogic_io_mmio(NETLOGIC_IO_USB_1_OFFSET);
 
-	nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 49, 0x10000000); //Clear Rogue Phy INTs
-	nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 50, 0x1f000000);
+	netlogic_write_reg(usb_mmio, 49, 0x10000000); //Clear Rogue Phy INTs
+	netlogic_write_reg(usb_mmio, 50, 0x1f000000);
 
-	nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base,  1, 0x07000500);
+        netlogic_write_reg(usb_mmio,  1, 0x07000500);
 
 	value = gpio_mmio[21];
 	if ((value >> 22) & 0x01) {
 		printk("Detected USB Host mode..\n");
-		nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base, 0, 0x02000000);
+		netlogic_write_reg(usb_mmio,  0, 0x02000000);
 	}
 	else {
 		printk("Detected USB Device mode..\n");
-		nlm_hal_write_32bit_reg(xlp_usb_ehci_1_base,  0, 0x01000000);
+		netlogic_write_reg(usb_mmio,  0, 0x01000000);
 	}
 }
 
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 562d963..c924a14 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -44,6 +44,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <user/netlogic/nlm_common_loader.h>
 
 #include <asm/mach-netlogic/mmu.h>
+#include "cpu_control_macros.h"
 
 extern int xlr_loader_support;
 
@@ -52,15 +53,18 @@ extern int onlinemask;
 extern void smp_tune_scheduling (void);
 extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 struct smp_boot_info smp_boot;
+struct node_mask smp_node;
 extern void prom_reconfigure_thr_resources(void);
 extern unsigned long nlm_common_ebase;
+extern void enable_cpus(unsigned int node, unsigned online_mask);
+extern void enable_cores(unsigned int node, unsigned int cbitmap, unsigned int thread_num);
 
 int phys_proc_id[NR_CPUS]; /* cpuid+thrid of each logical CPU */
 cpumask_t phys_cpu_present_map;
 extern void asmlinkage smp_bootstrap(void);
 extern void core_send_ipi(int cpu, unsigned int action);
 
-extern void enable_cpus(unsigned long thread_bitmask);
+extern void enable_cpus( unsigned int node, unsigned int onlinemask );
 
 void nlm_send_ipi_single(int cpu, unsigned int action)
 {
@@ -78,10 +82,9 @@ void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
 /*
  * Code to run on secondary just after probing the CPU
  */
+extern void nlm_smp_irq_init(void);
 static void __cpuinit nlm_init_secondary(void)
 {
-    extern void nlm_smp_irq_init(void);
-
     nlm_smp_irq_init();
     /* Time init for this cpu is done in mips_clockevent_init() */
 }
@@ -105,8 +108,13 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 	unsigned long sp = (unsigned long)__KSTK_TOS(idle);
 	int cpu = cpu_logical_map(logical_cpu);
 
-/* 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", */
-/* 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); */
+	if(cpu == 32)
+	{
+		//enable_cores( 1,0x3,4); 
+		enable_cpus( 1, smp_node.onlinemask[1]);
+	}
+ 	printk("[%s]: (PROM): waking up phys cpu# %d: address of boot_info=%p (addressof(ready)=%p)\n", 
+ 	       __FUNCTION__, cpu, &(smp_boot.boot_info[cpu]), &((smp_boot.boot_info[cpu]).ready)); 
   
 	smp_boot.boot_info[cpu].sp = sp;
 	smp_boot.boot_info[cpu].gp = gp;
@@ -115,7 +123,7 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 	__sync();
 	smp_boot.boot_info[cpu].ready = 1;
   
-/* 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); */
+ 	printk("[%s]: (PROM): sent a wakeup message to cpu %d\n", __FUNCTION__, cpu); 
 }
 
 unsigned int fast_syscall_cpumask_phy = 0x1;
@@ -149,8 +157,8 @@ void __init nlm_smp_setup(void)
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	boot_cpu_online_map = smp_boot.online_map;
-	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
+	boot_cpu_online_map = smp_node.onlinemask[0];
+	smp_boot.online_map = smp_node.onlinemask[0];
 
 	/* 0th entry in the logical_map should be the bootcpu and all
        others proceeds after that */
@@ -161,7 +169,7 @@ void __init nlm_smp_setup(void)
 	__cpu_logical_map[0] = boot_cpu;
 //	cpu_set(0, cpu_possible_map);
 
-	for(i = 0;i<NR_CPUS;i++) {
+	for(i = 0; i < 32; i++) {
 		if (boot_cpu_online_map & (1<<i)) {
 			cpu_set(i, phys_cpu_present_map);
 			__cpu_number_map[i] = num_cpus;
@@ -171,6 +179,22 @@ void __init nlm_smp_setup(void)
 		}
 	}
 
+	for(j = 1; j < 4; j++)
+	{
+		boot_cpu_online_map = smp_node.onlinemask[j];
+		if(boot_cpu_online_map == 0)
+			continue;
+
+		for(i = 0; i < 32; i++) {
+			if (boot_cpu_online_map & (1<<i)) {
+				cpu_set(i + 32*j, phys_cpu_present_map);
+				__cpu_number_map[i+32*j] = num_cpus;
+				__cpu_logical_map[num_cpus] = i+32*j;
+				cpu_set(num_cpus, cpu_possible_map);
+				++num_cpus;
+			}
+		}
+	}
 
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
 
@@ -202,7 +226,6 @@ struct plat_smp_ops nlm_smp_ops = {
 void prom_boot_cpus_secondary(void *args)
 {
 	int cpu = hard_smp_processor_id();
-  
 	write_c0_ebase((uint32_t)nlm_common_ebase);
 	atomic_add((1<<cpu), (atomic_t *)&smp_boot.online_map);
 	for(;;) {
@@ -219,16 +242,58 @@ void prom_boot_cpus_secondary(void *args)
 		     smp_boot.boot_info[cpu].gp);
 }
 
-extern uint32_t xlr_linux_cpu_mask;
+#ifdef CONFIG_NLM_XLP
+
+extern void prom_pre_boot_secondary_cpus(void *);
+extern uint32_t xlp_linux_cpu_mask;
  
-#ifndef CONFIG_XEN
+#ifdef CONFIG_MAPPED_KERNEL
+#define secondary_cpus_bootup_func \
+       ((unsigned long)prom_pre_boot_secondary_cpus - \
+        (unsigned long)LOADADDR + (unsigned long)PHYSADDR)
+#else
+#define secondary_cpus_bootup_func prom_pre_boot_secondary_cpus
+#endif
 
 int wakeup_secondary_cpus(void)
 {
-	printk("Enabling CPU Mask [0x%x]\n", onlinemask);
-	enable_cpus(onlinemask);
+#if 1 
+	smp_node.onlinemask[0] = 0x00000001;
+	smp_node.onlinemask[1] = 0x00000000;
+	smp_node.onlinemask[2] = 0x00000000;
+	smp_node.onlinemask[3] = 0x00000000;
+
+	enable_cpus( 0, smp_node.onlinemask[0]);
+#else
+	__u32 wakeup_mask;
+#if defined(CONFIG_NLM_XLP_SIM)
+	unsigned int wait_count = 0;
+#endif
 
+	if (xlr_loader_support) {
+		wakeup_mask = xlp_linux_cpu_mask | nlm_common_loader_mask;
+		if (wakeup != NULL)
+			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
+	} 
+	else {
+		if (wakeup != NULL) {
+			wakeup((void *)secondary_cpus_bootup_func, 0, 
+				   (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map));
+#if defined(CONFIG_NLM_XLP_SIM)
+			while (smp_boot.online_map != prom_info->nlm_cpu_online_map) {
+				if ((wait_count++ % 1000000) == 0) {
+					printk("[%s%d]: Master cpu waiting for slave cpus to wakeup from bootloader (%x != %llx)\n",
+					       __FUNCTION__, __LINE__, smp_boot.online_map, 
+						   (unsigned long long) prom_info->nlm_cpu_online_map);
+				}
+			}
+			printk("[%s@%d]: woke up prom_info->nlm_cpu_online_map=%016llx\n", __FILE__, __LINE__, 
+				   (unsigned long long) prom_info->nlm_cpu_online_map);
+#endif
+		}
+	}
+#endif
 	return 0;
 }
 
-#endif
+#endif /* #ifdef CONFIG_NLM_XLP */
-- 
1.7.0.4

