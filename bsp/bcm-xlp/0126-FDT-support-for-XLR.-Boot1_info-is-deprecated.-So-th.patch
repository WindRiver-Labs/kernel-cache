From 6766c5111e3453779ee70658cd0bfd04c6d5b229 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Fri, 6 Aug 2010 12:33:46 +0530
Subject: [PATCH 126/762] FDT support for XLR. Boot1_info is deprecated. So this verion of XLR linux will boot only with bootm command of netlboot (or uboot when it is available)

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/Kconfig     |    1 +
 arch/mips/netlogic/xlr/board.c |   14 ++-
 arch/mips/netlogic/xlr/setup.c |  289 +++++++++++++++-------------------------
 3 files changed, 118 insertions(+), 186 deletions(-)

diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 837212d..4774bc5 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -3,6 +3,7 @@ config NLM_COMMON
 
 config NLM_XLR
 	select GENERIC_HARDIRQS_NO__DO_IRQ
+	select FDT
 	bool
 
 config NLM_XLP
diff --git a/arch/mips/netlogic/xlr/board.c b/arch/mips/netlogic/xlr/board.c
index b4c8395..b45fad2 100644
--- a/arch/mips/netlogic/xlr/board.c
+++ b/arch/mips/netlogic/xlr/board.c
@@ -140,7 +140,9 @@ int  read_board_info(xlr_board_info_t *board)
 	volatile uint32_t regVal, i, tmp;
 	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_I2C_1_OFFSET);
 
-	get_cpu_clock(board);
+	/* if this is not read from FDT */
+	if(board->cpu_freq == 0)
+		get_cpu_clock(board);
 
 	/* Read other board dependent stuff */
 	/* EEPROM on Netlogic XLR/XLS boards are on BUS 1 */
@@ -202,11 +204,15 @@ int  read_board_info(xlr_board_info_t *board)
 		}
 	}
 	
-	board->major = ebuf[EEPROM_MAJOR_OFFSET] - '0';
+	if(board->major == 0) 
+		board->major = ebuf[EEPROM_MAJOR_OFFSET] - '0';
+	if(board->minor == 0) 
 	board->minor = ebuf[EEPROM_MINOR_OFFSET] - '0';
 
-	for(i=0; i < 6; i++) 
-		board->mac_addr[i] = ebuf[EEPROM_ETH_MAC_OFFSET + i];
+	if(*((uint32_t *)board->mac_addr) == 0) {
+		for(i=0; i < 6; i++) 
+			board->mac_addr[i] = ebuf[EEPROM_ETH_MAC_OFFSET + i];
+	}
 	return 0;
 
 }
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 1b1f1ab..3ecde4f 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -61,6 +61,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/proc_fs.h>
 #include <asm/mach-netlogic/mmu.h>
 #include <asm/netlogic/xlr_board.h>
+#include "libfdt/libfdt_env.h"
+#include "ops.h"
 
 
 #ifdef NLM_BRIDGE_WKAROUND
@@ -69,6 +71,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 nlm_rwlock_t *nlm_bridge_lock;
 EXPORT_SYMBOL(nlm_bridge_lock);
 int nlm_enable_br_wrkaround = 0;
+unsigned long global_shmem_addr = 0;
 EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #endif
 
@@ -128,6 +131,8 @@ EXPORT_SYMBOL(nlm_root_proc);
 unsigned long long nlm_common_tlb_stats[32] __cacheline_aligned;
 
 spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
+uint32_t xlr_linux_cpu_mask;
+unsigned int onlinemask = 0x1;
 
 __u8 xlr_base_mac_addr[6];
 static char *hybrid_str = NULL;
@@ -171,22 +176,11 @@ unsigned long nlm_asid_mask = 0x3f;
 unsigned int nlm_shtlb = 1; /* by default shared TLB is enabled */
 #endif
 
-extern struct psb_info *nlm_boot_info;
-static struct psb_info *prom_info = NULL;
+/* TODO: This should be removed eventually after taking a look at 
+   nlm_uaccess_fs_cpu_max_freq() and xlr_fast_syscall_prominfo
+   */
 struct psb_info prom_info_copy; /* Bootloader prom_info is saved here */
-static struct psb_info default_prom_info = {
-	.boot_level              = 2,
-	.io_base                 = DEFAULT_NETLOGIC_IO_BASE,
-	.output_device           = 2,
-	.nlm_cpu_online_map          = 0x01,
-	.magic_dword             = (((__u64)0x900dbeef << 32)|PSB_INFO_VERSION),
-	.size                    = sizeof(struct psb_info),
-	.mac_addr                = 0x000102030405ULL,
-	.cpu_frequency           = 1200000000,
-	.board_version           = 1,
-	.board_major_version     = 1,
-	.board_minor_version     = 0,
-};
+
 
 static struct physmap_info {
 	int type;
@@ -278,19 +272,6 @@ int valid_mmap_nlm_common_addr_range(unsigned long pfn)
 	return 0;
 }
 
-static int is_valid_prominfo(struct psb_info *info)
-{
-	if (!prom_info) 
-		return -1;
-  
-	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef) 
-		return -1;
-
-	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION) 
-		return -1;
-
-	return 0;
-}
 
 #if defined(CONFIG_NLM_XLP_SIM)
 const char *DEFAULT_CONSOLE_BOOT_PARAMS = "boot_noi2c mem=255m@1m mem=512m@512m console=ttyS0,115200 ";
@@ -318,14 +299,10 @@ static void ptr_linux_exit(void)
 {
        nlm_reg_t *mmio;
 
-#ifdef CONFIG_NLM_XLP
-	write_32bit_cfg_reg((uint32_t *)xlp_sys_base, 0x40 | CHIP_RESET, 1);
-#else
 	/* trigger a chip reset 
 	 */
 	mmio = netlogic_io_mmio(NETLOGIC_IO_GPIO_OFFSET);
 	netlogic_write_reg(mmio, GPIO_SWRESET_REG, 1);
-#endif
 	for ( ; ; ) 
 		cpu_wait();
 }
@@ -345,16 +322,7 @@ void prom_reconfigure_thr_resources(void)
 #ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
 	uint32_t map;
 #endif
-
-	if (loader_used == LOADER_UBOOT) {
-		/* currently, only 1Core
-		 * 1Thread supported in u-boot
-		 */
-		online_map = 0x01;
-	}
-	else {
-		online_map = prom_info->nlm_cpu_online_map;
-	}
+	online_map = xlr_linux_cpu_mask;
 	
 	thr_mask = online_map >> (netlogic_cpu_id()<<2);
 
@@ -429,14 +397,12 @@ int xlr_boot_over_nfs = 0;
 
 unsigned long nlm_common_ebase = 0x0;
 
-#ifdef XLR_USE_FDT
 static char prop_buf[MAX_PROP_LEN];
 extern char _end;
 extern void *fdt;
 extern void *fdt_init(void *blob);
 extern void *simple_alloc_init(char *base, unsigned long heap_size,
 		                unsigned long granularity, unsigned long max_allocs);
-#endif
 
 
 //#if !defined(CONFIG_NLMCOMMON_MAC)
@@ -575,24 +541,24 @@ early_param("forceusb", xls_force_usb);
 static void __init tweak_avail_dram_map(void) {
 
     int j=0;
-    int nrmap_ctr = (boot_mem_map.nr_map - 1);
+    int nrmap_ctr = (boot_physaddr_info.nr_map - 1);
 
     avail_mem_above_4G = 0;
 
     for (j=nrmap_ctr; j>=0; j--) {
-        if ((boot_mem_map.map[j].addr + boot_mem_map.map[j].size)
+        if ((boot_physaddr_info.map[j].addr + boot_physaddr_info.map[j].size)
                 > 0x100000000ULL) {
             avail_mem_above_4G++;
 #ifdef CONFIG_64BIT
             if (force_usb) {
                 printk(KERN_WARNING "[USB]:Re-adjusting Available DRAM map\n");
-                if (boot_mem_map.map[j].addr > 0x100000000ULL) {
-                    boot_mem_map.nr_map--;
+                if (boot_physaddr_info.map[j].addr > 0x100000000ULL) {
+                    boot_physaddr_info.nr_map--;
                 }
                 else {
                     /* Reclaim whatever we can... */
-                    boot_mem_map.map[j].size =
-                        0x100000000ULL - boot_mem_map.map[j].addr;
+                    boot_physaddr_info.map[j].size =
+                        0x100000000ULL - boot_physaddr_info.map[j].addr;
                 }
             }
 #endif
@@ -667,7 +633,6 @@ static struct nlm_common_name_value_struct nlm_common_name_value_args[] = {
 };
 
 
-//void prom_parse_args(int argc, char *argv[])
 static void parse_cmdline_args(int argc, char *argv[])  
 {
 	int i, j;
@@ -806,33 +771,16 @@ void prom_update_exclude_region(void)
 	}
 }
 
-struct boot_mem_map prom_map;
-int use_default_phymem = FALSE;
+/* Reset this only if we find a valid FDT info passed */
+int use_default_phymem = TRUE;
 
 
-void read_prom_memory(void)
+void validate_mem_map(void)
 {
-	struct nlm_boot_mem_map *map;
+	struct boot_mem_map *map = &boot_physaddr_info;
 
-	if (loader_used == LOADER_UBOOT)
-		goto set_default_mmap;
-		
-	/* sanity check prom_info 
-	 * and it's mem_map fields 
-	 */
-	if (!prom_info || (!prom_info->psb_mem_map && !prom_info->avail_mem_map)) 
-		goto set_default_mmap;
-
-	/* copy the mem_map from bootloader */
-	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
-		map = (struct nlm_boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
-	else
-		map = (struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
-	
 	if (!(map->nr_map > 0 && map->nr_map <= 32))
 		goto set_default_mmap;
-
-	copy_mem_map(&prom_map, map);
 	
 	return;
 
@@ -854,14 +802,10 @@ static void prom_add_memory(void)
 
 	prom_update_exclude_region();
 	
-	/* TODO: Need to remove this hack
-	 */
-	if (prom_map.map[0].size == 0x0c000000)
-		prom_map.map[0].size = 0x0ff00000;
-	
-	for (i = 0; i < prom_map.nr_map; i++) {
-		start = prom_map.map[i].addr;
-		end = prom_map.map[i].addr + prom_map.map[i].size;
+	for (i = 0; i < boot_physaddr_info.nr_map; i++) {
+		start = boot_physaddr_info.map[i].addr;
+		end = boot_physaddr_info.map[i].addr + 
+			boot_physaddr_info.map[i].size;
 
 		for (j = 0; j < MAX_EXCLUDE; j++) {
 			exc_start = exclude_regions[j].start;
@@ -875,7 +819,7 @@ static void prom_add_memory(void)
 					start = exc_end;
 					continue;
 				}
-				if (prom_map.map[i].type == BOOT_MEM_RAM) {
+				if (boot_physaddr_info.map[i].type == BOOT_MEM_RAM) {
 
 					/*
 					 * memcpy/__copy_user prefetch, which
@@ -886,8 +830,8 @@ static void prom_add_memory(void)
 				 	*/
 					if (exc_start-start > pref_backup) {
 						add_memory_region(start,
-									  exc_start-start-pref_backup, 
-									  (long)prom_map.map[i].type);
+						exc_start-start-pref_backup, 
+						(long)boot_physaddr_info.map[i].type);
 					}
 					start = exc_end;
 				}
@@ -899,9 +843,11 @@ static void prom_add_memory(void)
 			}
 		}
 		if (start != end)
-			if (prom_map.map[i].type == BOOT_MEM_RAM) {
+			if (boot_physaddr_info.map[i].type == BOOT_MEM_RAM) {
 				if (end-start > pref_backup)
-					add_memory_region(start, end-start-pref_backup, (long)prom_map.map[i].type);
+					add_memory_region(start, 
+						end-start-pref_backup, 
+						(long)boot_physaddr_info.map[i].type);
 			}
 	}
 	
@@ -917,14 +863,11 @@ static void prom_add_memory(void)
 
 static void psb_print_physmap(void)
 {
-	struct nlm_boot_mem_map *physaddr_map = (struct nlm_boot_mem_map *)
-				((unsigned long)prom_info->psb_physaddr_map);
+	struct boot_mem_map *physaddr_map = &boot_physaddr_info;
 	char *name;
 	int i = 0;
 	int max;
 
-	if (physaddr_map == NULL)
-		return;
 
 	max = physaddr_map->nr_map;
 
@@ -947,18 +890,6 @@ static void psb_print_physmap(void)
 	}
 }
 
-static void save_physaddr_info(void)
-{
-	struct nlm_boot_mem_map *physaddr_map = 
-		(struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
-
-	if (physaddr_map == NULL)
-		return;
-
-	copy_mem_map(&boot_physaddr_info, physaddr_map);
-	return;
-}
-
 /* disable dedicated interrupt vector for virtual mips mode */
 void disable_divec(void)
 {
@@ -1025,64 +956,20 @@ static void nlm_early_serial_setup(void) {}
 #endif
 
 extern struct plat_smp_ops nlm_smp_ops;
-/*
- * prom_init is called just after the cpu type is detenetlogicned, from setup_arch()
- */
-
-static int read_cmdline_args(int *argc, char *n_argv[], char *n_envp[])
-{
-	char **argv, **envp;
-	int i;
-	int32_t *t_argv;
-	int32_t *t_envp;
 
-	*argc = (int)fw_arg0;
-	argv = (char **)(unsigned long)(int)fw_arg1;
-	envp = (char **)(unsigned long)(int)fw_arg2;
-		
-	for (i = 0, t_argv = (int32_t *)argv; i < *argc; i++, t_argv++)
-		n_argv[i] = (char *)(unsigned long)(*t_argv);
 
-		if (envp != NULL) {
-
-			for (i = 0, t_envp = (int32_t *)envp; *t_envp; i++) {
-				n_envp[i] = (char *)(unsigned long)(*t_envp);
-				t_envp++;
-		}
-	}
-
-	return 0;
-}
-
-static int read_prominfo(void)
-{
-	struct psb_info *t_prom_info;
-
-	prom_info = &prom_info_copy;
-
-	t_prom_info = (struct psb_info *)(unsigned long)(int)fw_arg3;
-	memcpy((void *)prom_info, (void *)t_prom_info, sizeof(struct psb_info));
-	
-	return is_valid_prominfo(prom_info);
-}
 
 static void process_prominfo(void (*(*wakeup))(void *, void *, __u32))
 {
 #ifdef NLM_BRIDGE_WKAROUND
-	if (prom_info->global_shmem_size == GLOBAL_SHMEM_SIZE) {
+	if (global_shmem_addr != 0) {
 		nlm_bridge_lock = (nlm_rwlock_t *)(unsigned long)
-			(prom_info->global_shmem_addr + BRIDGE_WKAROUND_AREA_OFFSET);
+			(global_shmem_addr + BRIDGE_WKAROUND_AREA_OFFSET);
 		nlm_enable_br_wrkaround = 1;
 		printk("Enabling Bridge Workaround \n");
 	}
 #endif
 
-	/* Copy Environment variable */
-	if (prom_info->bldr_envp) {
-		memcpy(&xlr_bldr_env, (void *)(unsigned long)prom_info->bldr_envp, 
-			   sizeof(xlr_bldr_env));
-	}
-
 	xlr_board_major_version = nlm_xlr_board_info.major;
 	xlr_board_minor_version = nlm_xlr_board_info.minor;
 
@@ -1091,9 +978,6 @@ static void process_prominfo(void (*(*wakeup))(void *, void *, __u32))
 
 	psb_print_physmap();
 
-	save_physaddr_info();
-
-	*wakeup = ((void (*)(void *, void *, __u32))(unsigned long)(prom_info->wakeup));
 
 	/* update the nlm_common  mac addr */
 	xlr_base_mac_addr[0] = nlm_xlr_board_info.mac_addr[0];
@@ -1132,7 +1016,8 @@ static int wakeup_secondary_cpus(struct psb_info *prom_info)
 
 	prepare_wakeup((unsigned long)secondary_cpus_bootup_func);
 
-	wakeup_mask = (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map);
+	//wakeup_mask = (__u32)prom_info->nlm_cpu_online_map & (~smp_boot.online_map);
+	wakeup_mask = (__u32)xlr_linux_cpu_mask & (~smp_boot.online_map);
 
 	for(i=0; i < NR_CPUS; i++) {
 		if(wakeup_mask & (1 << i)) {
@@ -1152,7 +1037,7 @@ static int build_arcs_cmdline(char *arcs_cmdline, int argc, char *argv[])
 {
 	int i;
 
-	for (i = 1; i < argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
 			strcat(arcs_cmdline, argv[i]);
 			strcat(arcs_cmdline, " ");
@@ -1183,7 +1068,7 @@ static int build_arcs_cmdline(char *arcs_cmdline, int argc, char *argv[])
 	return 0;
 }
 
-#ifdef XLR_USE_FDT
+char xlr_arcs_cmdline[CL_SIZE];
 /* This function will get the following:
    1. Boot args
    2. Physical memory map
@@ -1193,7 +1078,9 @@ static int xlr_fdt_process(void)
 {
 	int  domain=0;
 	char domstr[32] = "";
-	int  i, na, ns, regs[4], entries;
+	int  i,j, na, ns, regs[4], entries;
+	char macaddress[6];
+	uint32_t shmem_addr;
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -1214,16 +1101,49 @@ static int xlr_fdt_process(void)
 	/* Create a local copy of the FDT
 	 */
 	fdt = fdt_init(blob);
-	if(!fdt)
+	if(!fdt) {
+		printk("FDT Init failed\n");
 		return -1;
+	}
 
 	/* extract cmdline params
 	 */
 	node = finddevice("/chosen");
 	if (node) {
-		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
-			return -1;
-		strcat(arcs_cmdline, prop_buf);
+		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) >= 0) {
+			strcat(xlr_arcs_cmdline, prop_buf);
+		}
+	}
+
+	node = finddevice("/system"); 
+	if(node) {
+		if (getprop(node, "boardmajor", &nlm_xlr_board_info.major,
+					sizeof(nlm_xlr_board_info.major)) >= 0) {
+			nlm_xlr_board_info.major = 
+				fdt32_to_cpu(nlm_xlr_board_info.major);
+		}
+
+		if (getprop(node, "boardminor", &nlm_xlr_board_info.minor,
+					sizeof(nlm_xlr_board_info.minor)) >= 0) {
+			nlm_xlr_board_info.minor = 
+				fdt32_to_cpu(nlm_xlr_board_info.minor);
+		}
+
+		if (getprop(node, "cpufrequency", &nlm_xlr_board_info.cpu_freq,
+					sizeof(nlm_xlr_board_info.cpu_freq)) >= 0) {
+			nlm_xlr_board_info.cpu_freq = 
+				fdt32_to_cpu(nlm_xlr_board_info.cpu_freq);
+		}
+
+		if (getprop(node, "globalshmem", &shmem_addr,
+					sizeof(shmem_addr)) >= 0) {
+			global_shmem_addr = (int)fdt32_to_cpu(shmem_addr);
+		}
+
+		if (getprop(node, "macaddress", macaddress, 6) >= 0) {
+			for(i=0; i < 6; i++) 
+				nlm_xlr_board_info.mac_addr[i] = macaddress[i];
+		}
 	}
 
 	/* extract memory ranges,
@@ -1250,17 +1170,23 @@ static int xlr_fdt_process(void)
 			printk("Invalid Memory Map Specified!\n");
 
 		boot_physaddr_info.nr_map = entries/2;
+		j = 0;
+		use_default_phymem = FALSE;
 		for (i=0; i<entries; i+=2) {
 			unsigned long long addr, size;
 			addr = fdt32_to_cpu(regs[i]);
 			size = fdt32_to_cpu(regs[i + 1]);
-			boot_physaddr_info.addr = addr;
-			boot_physaddr_info.size = size;
-			boot_physaddr_info.type = BOOT_MEM_RAM;
+			boot_physaddr_info.map[j].addr = addr;
+			boot_physaddr_info.map[j].size = size;
+			boot_physaddr_info.map[j].type = BOOT_MEM_RAM;
+			j++;
+			printk("FDT mem[%d] start = %llx size %llx\n",
+					j, addr, size);
+
 		}
 	}
 
-	printk("FDT Cmdline: %s\n", arcs_cmdline);
+	printk("FDT Cmdline: %s\n", xlr_arcs_cmdline);
 
 	/* extract CPU online mask for
 	 * domain 0 (linux)
@@ -1282,39 +1208,41 @@ static int xlr_fdt_process(void)
 	xlr_linux_cpu_mask = onlinemask;
 	return 0;
 }
-#endif
 
+void xlr_split_args(int *argc, char *argv[])
+{
+	char *temp_cmdline = xlr_arcs_cmdline;
+	int i=0;
+
+	while(temp_cmdline) {
+		argv[i] = (char *)strsep(&temp_cmdline, " ");
+		i++;
+	}
+	*argc = i;
+}
 
+/*
+ * prom_init is called just after the cpu type is detenetlogicned, from setup_arch()
+ */
 void __init prom_init(void)
 {
-	int argc, retval;
+	int argc;
 	
 	char *n_argv[NLM_MAX_ARGS] = {NULL};
-	char *n_envp[NLM_MAX_ENVS] = {NULL};
 	void (*wakeup)(void *, void *, __u32) = NULL;
 
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	setup_default_configuration();
 
-#ifdef XLR_USE_FDT
 	xlr_fdt_process();
-#endif
+	/* split the args from arcs_cmdline to argv array */
+	xlr_split_args(&argc, n_argv);
 
-	read_cmdline_args(&argc, n_argv, n_envp);
 	parse_cmdline_args(argc, n_argv);
 
 	build_arcs_cmdline(arcs_cmdline, argc, n_argv);
 
-	if (loader_used == LOADER_UBOOT)
-		goto setup_memory;
-
-	retval = read_prominfo();
-	if (retval != 0) {
-		prom_info = &default_prom_info;
-		goto rest_prom_int;
-	}
-
 	set_xls_chip_family_types();
 
 	/* Try to get the board major, minor, mac address etc if no FDT info is 
@@ -1326,8 +1254,7 @@ void __init prom_init(void)
 
 	process_prominfo(&wakeup);
 
-setup_memory:
-	read_prom_memory();
+	validate_mem_map();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
@@ -1336,9 +1263,7 @@ setup_memory:
 
 	smp_boot.online_map = (1 << hard_smp_processor_id());
 
-	wakeup_secondary_cpus(prom_info);
-
-rest_prom_int:
+	wakeup_secondary_cpus(NULL);
 
 	if (hybrid_str != NULL)
 		xlr_hybrid_setup(hybrid_str);
-- 
1.7.0.4

