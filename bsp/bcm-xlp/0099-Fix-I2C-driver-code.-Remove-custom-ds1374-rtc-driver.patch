From b952e1f57ecdc56716761c86643286694c0a436a Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Tue, 22 Jun 2010 15:45:54 +0530
Subject: [PATCH 099/762] Fix I2C driver code. Remove custom ds1374-rtc driver. Use default rtc driver

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/xlr/Makefile   |    2 +-
 arch/mips/netlogic/xlr/platform.c |   25 ++
 drivers/i2c/algos/i2c-algo-palm.c |  274 ++++++++++----------
 drivers/i2c/chips/ds1374-rtc.c    |  528 -------------------------------------
 4 files changed, 167 insertions(+), 662 deletions(-)
 delete mode 100644 drivers/i2c/chips/ds1374-rtc.c

diff --git a/arch/mips/netlogic/xlr/Makefile b/arch/mips/netlogic/xlr/Makefile
index 9631ab8..de43e9b 100644
--- a/arch/mips/netlogic/xlr/Makefile
+++ b/arch/mips/netlogic/xlr/Makefile
@@ -4,7 +4,7 @@ EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogi
 
 obj-y                   = setup.o config_net.o
 obj-y += irq.o time.o on_chip.o mmu.o
-#obj-$(CONFIG_NLM_XLR) += platform.o
+obj-$(CONFIG_NLM_XLR) += platform.o
 obj-$(CONFIG_SMP)      += smp.o smpboot.o
 obj-$(CONFIG_KGDB)      += nmi.o
 
diff --git a/arch/mips/netlogic/xlr/platform.c b/arch/mips/netlogic/xlr/platform.c
index 8616902..49981c9 100644
--- a/arch/mips/netlogic/xlr/platform.c
+++ b/arch/mips/netlogic/xlr/platform.c
@@ -18,6 +18,7 @@ the header of the original work apply to this derived work.
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/resource.h>
+#include <linux/i2c.h>
 #include <asm/netlogic/nlm_srio.h>
 
 static u64 xls_usb_dmamask = ~(u32) 0;
@@ -107,3 +108,27 @@ void platform_rio_init(void)
 	nlm_rio_setup();
 }
 #endif				/* CONFIG_RAPIDIO */
+
+static struct i2c_board_info phoenix_i2c_info1[] __initdata = {
+	/* All XLR boards have this RTC Chip */
+	{
+		I2C_BOARD_INFO("ds1374", 0x68),
+	},
+};
+
+static int __init phoenix_i2c_init(void)
+{
+	int err;
+
+	printk(KERN_INFO "** %s.\n", __FUNCTION__);
+
+	err = i2c_register_board_info(1, phoenix_i2c_info1,
+			ARRAY_SIZE(phoenix_i2c_info1));
+	if (err < 0)
+		printk(KERN_ERR
+	            "phoenix-i2c: cannot register board I2C devices\n");
+	return err;
+}
+
+arch_initcall(phoenix_i2c_init);
+
diff --git a/drivers/i2c/algos/i2c-algo-palm.c b/drivers/i2c/algos/i2c-algo-palm.c
index 8712587..70f8534 100644
--- a/drivers/i2c/algos/i2c-algo-palm.c
+++ b/drivers/i2c/algos/i2c-algo-palm.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
 
 /*
  *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
@@ -75,142 +80,141 @@ static int wait_for_idle(struct i2c_algo_palm_data *algo_data)
 		return 0;
 }
 
-/*
- * Transmit Routine
- */
-static int palm_tx(struct i2c_algo_palm_data *algo_data,  __u16 len, 
-		__u8 *buf, __u16 addr, __u8 offset)
+
+static int palm_rx(struct i2c_algo_palm_data *algo_data, __u8 *buf,
+		__u16 addr, __u16 length)
 {
-	volatile __u32 regVal=0x00;
-	int timeOut, ctr=0x00, numBytes=len;
+	volatile __u32 tmp, regVal;
+	int len = length, i;
+
+	if(length == 0) /* special case of I2C_SMBUS_QUICK */ {
+		/* issue a address only transaction */
+		palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+		palm_write(algo_data, I2C_PALM_CFG,     0xfa);
+		palm_write(algo_data, I2C_PALM_STARTXFR,0x3);
 
-	for (ctr=0x00; ctr<len; ctr++) {
-		if (wait_for_idle(algo_data) < 0) {
-			printk("TimedOut on Waiting for I2C Bus Idle.\n");
-			return -EIO;
-		}
-		palm_write(algo_data, I2C_PALM_CFG, 0xF8);			
-		palm_write(algo_data, I2C_PALM_BYTECNT, 0x00);
-		palm_write(algo_data, I2C_PALM_DEVADDR, addr); //0x4c, 0x68	
-		palm_write(algo_data, I2C_PALM_ADDR, offset+numBytes-1); //offset
-		palm_write(algo_data, I2C_PALM_DATAOUT, buf[ctr]);
-		palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR );
-		spin_lock_irq(&palm_lock);
-		mdelay(0x1);
-		spin_unlock_irq(&palm_lock);
-		
 		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		spin_lock_irq(&palm_lock);
-		mdelay(0x01);
-		spin_unlock_irq(&palm_lock);
 		if (regVal & 0x0008) {
-			printk("palm_tx: ACKERR. Aborting...\n");
-			return -1;
-		}
-		timeOut= 0x1000;
-		while (!(regVal & 0x0002) && timeOut) {
-			regVal = palm_read(algo_data, I2C_PALM_STATUS);
-			timeOut--;
-		}
-		if (timeOut==0x00) {
-			printk("palm_tx: [TimeOut] SDOEMPTY Not Set\n");
+			printk("start quick: ACKERR. Aborting...\n");
 			return -1;
 		}
-		timeOut=1000;
-		while ((regVal & 0x0030) && timeOut) {
-			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR);
+		return 0;
+	}
+
+
+	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+	palm_write(algo_data, I2C_PALM_CFG,     0xfa);
+	palm_write(algo_data, I2C_PALM_BYTECNT, len-1);
+	palm_write(algo_data, I2C_PALM_STARTXFR,0x1);
+
+
+	regVal = palm_read(algo_data, I2C_PALM_STATUS);
+	if (regVal & 0x0008) {
+		printk("start read: ACKERR. Aborting...\n");
+		return -1;
+	}
+
+	for(tmp=0; tmp < len; tmp++) {
+		i = 0;
+		while(1) {
 			regVal = palm_read(algo_data, I2C_PALM_STATUS);
-			timeOut--;
-		}
-		if (timeOut==0x00) {
-			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
-			return -1;
+			if (regVal & 0x4) {
+				buf[tmp] = (__u8)palm_read(algo_data, 
+							I2C_PALM_DATAIN);
+				break;
+
+			}
+			mdelay(1);
+			i++;
+			if (i >= 1000) {
+				printk("* read Timed OUT byte %d.\n", tmp);
+				return -1;
+			}
 		}
-		numBytes--;
 	}
 	return 0;
 }
-static int palm_addr_only(struct i2c_algo_palm_data *algo_data, __u8 *buf,
-		__u16 addr, __u8 offset)
+
+
+
+
+static int palm_tx(struct i2c_algo_palm_data *algo_data,  __u16 len, 
+		__u8 *buf, __u16 addr)
 {
-	volatile __u32 regVal=0x00;
+	volatile __u32 tmp, regVal;
+	int i;
+
+	if (wait_for_idle(algo_data) < 0) {
+		printk("TimedOut on Waiting for I2C Bus Idle.\n");
+		return -1;
+	}
+
+	if(len == 0) { /* special case of I2C_SMBUS_QUICK */
+		/* issue a address only transaction */
+		palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+		palm_write(algo_data, I2C_PALM_CFG,     0xfa);
+		palm_write(algo_data, I2C_PALM_STARTXFR,0x2);
+
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		if (regVal & 0x0008) {
+			printk("start quick: ACKERR. Aborting...\n");
+			return -1;
+		}
+		return 0;
+	}
 
-	palm_write(algo_data, I2C_PALM_ADDR,    offset);
 	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+	palm_write(algo_data, I2C_PALM_DATAOUT, buf[0]);
 	palm_write(algo_data, I2C_PALM_CFG,     0xfa);
-	palm_write(algo_data, I2C_PALM_STARTXFR,0x02);
+	palm_write(algo_data, I2C_PALM_BYTECNT, len-1);
+	palm_write(algo_data, I2C_PALM_STARTXFR, 0x0);
+
 	regVal = palm_read(algo_data, I2C_PALM_STATUS);
 	if (regVal & 0x0008) {
-		printk("palm_addr_only: ACKERR. Aborting...\n");
+		printk("write: ACKERR. Aborting...\n");
 		return -1;
 	}
-	return 0;
-}
 
 
-/*
- * Receive Routine
- * Read 'len' bytes from device @ 'addr'
- */
-static int palm_rx(struct i2c_algo_palm_data *algo_data, __u16 len,
-		__u8 *buf, __u16 addr, __u8 offset)
-{	
-	volatile __u32 regVal=0x00, ctr=0x00;
-	int timeOut, numBytes=0x00;
-
-	palm_write(algo_data, I2C_PALM_CFG, 0xfa);
-	palm_write(algo_data, I2C_PALM_BYTECNT, len);
-	palm_write(algo_data, I2C_PALM_DEVADDR, addr); //DEVADDR=0x4c, 0x68
-	spin_lock_irq(&palm_lock);
-	mdelay(0x01);
-	spin_unlock_irq(&palm_lock);
-
-	for (numBytes=0x00; numBytes < len; numBytes++) {
-		palm_write(algo_data, I2C_PALM_ADDR,  offset+numBytes);//I2C_PALM_ADDR:offset	
-		spin_lock_irq(&palm_lock);
-		mdelay(0x01);
-		spin_unlock_irq(&palm_lock);
-		if (!ctr) {
-			/* Trigger a READ Transaction */
-			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
-			ctr++;
-		}
+	i= 0x1000;
+	regVal = palm_read(algo_data, I2C_PALM_STATUS);
+	while (!(regVal & 0x0002) && i) {
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		i--;
+	}
+	if (i==0x00) {
+		printk(" Write %d Test failed.[TimeOut]SDOEMPTY Not Set\n", tmp);
+		printk(" status: 0x%x.\n", regVal);
+		return -1;
+	}
+
+	for(tmp=1; tmp < len; tmp++) {
+		// palm_write(algo_data, I2C_PALM_CFG,     0xfa);
+		// palm_write(algo_data, I2C_PALM_BYTECNT, 0);
+		palm_write(algo_data, I2C_PALM_DATAOUT, buf[tmp]);
+		palm_write(algo_data, I2C_PALM_STARTXFR,0x0);
 
-		/* Error Conditions [Begin] */
 		regVal = palm_read(algo_data, I2C_PALM_STATUS);
-		spin_lock_irq(&palm_lock);
-		mdelay(0x01);
-		spin_unlock_irq(&palm_lock);
 		if (regVal & 0x0008) {
-			printk("palm_rx: ACKERR. Aborting...\n");
+			printk("start write: ACKERR. Aborting...\n");
 			return -1;
 		}
-		timeOut=10;
-		while ((regVal & 0x0030) && timeOut--) {
-			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
+
+		i= 0x1000;
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		while (!(regVal & 0x0002) && i) {
 			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+			i--;
 		}
-		if (timeOut==0x00) {
-			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
-			return -1;
-		}
-		timeOut=10;
-		/* Do we have valid data from the device yet..? */
-		regVal &= 0x0004;
-		while (!regVal && timeOut--) {
-			regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0004;
-		}
-		if (timeOut==0x00) {
-			printk("palm_rx: TimedOut Waiting for Valid Data\n");
+		if (i==0x00) {
+			printk(" Write %d Test failed.[TimeOut]SDOEMPTY Not Set\n", tmp);
 			return -1;
 		}
-		/* Error Conditions [End] */
-		/* Read the data */
-		buf[numBytes] = (__u8)palm_read(algo_data, I2C_PALM_DATAIN);
 	}
 	return 0;
 }
 
+
 static int palm_xfer(struct i2c_adapter *i2c_adap,
 		struct i2c_msg msgs[],
 		int num)
@@ -219,6 +223,7 @@ static int palm_xfer(struct i2c_adapter *i2c_adap,
 	struct 	i2c_msg *msg = NULL;
 	int 	curmsg;
 
+
 	for (curmsg = 0; curmsg < num; curmsg++) {
 
 		int addr;
@@ -236,17 +241,17 @@ static int palm_xfer(struct i2c_adapter *i2c_adap,
 			return -EIO;
 		}
 		if (msg->flags & I2C_M_RD ) {
-			if (palm_addr_only(algo_data, &msg->buf[0], addr, msg->offset) == -1) {
-				printk("I2C ADDRONLY Phase Fail.\n");
-				return -EIO;
-			}
-			if (palm_rx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+			if ((palm_rx(algo_data, &msg->buf[0], addr, 
+							msg->len)) == -1) {
 				printk("I2C Read Fail.\n");
 				return -EIO;
 			}
+			if(msg->flags & I2C_M_RECV_LEN)
+				msg->len += msg->buf[0];
 		}
 		else {
-			if (palm_tx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+			if ((palm_tx(algo_data, msg->len, &msg->buf[0], 
+						addr)) == -1) {
 				printk("I2C Write Fail.\n");
 				return -EIO;
 			}
@@ -291,6 +296,8 @@ int i2c_palm_add_bus(struct i2c_adapter *adap)
 	int rval;
 
 /* 	adap->id |= palm_algo.id; */
+	/* HLDS */
+	adap->nr = 1;
 	adap->algo = &palm_algo;
 
 	adap->timeout = 100;		
@@ -300,7 +307,8 @@ int i2c_palm_add_bus(struct i2c_adapter *adap)
 
 	/* register new adapter to i2c module... */
 	if (!rval)
-		i2c_add_adapter(adap);
+		i2c_add_numbered_adapter(adap);
+		//i2c_add_adapter(adap);
 
 	return rval;
 }
diff --git a/drivers/i2c/chips/ds1374-rtc.c b/drivers/i2c/chips/ds1374-rtc.c
deleted file mode 100644
index b4e068c..0000000
--- a/drivers/i2c/chips/ds1374-rtc.c
+++ /dev/null
@@ -1,528 +0,0 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-/*
- *  linux/drivers/char/ds1374-rtc.c
- *
- *	based on drivers/char/x1226-rtc.c
- *	Steve Longerbeam <stevel@mvista.com, or source@mvista.com>
- *	2002-2003 (c) MontaVista Software, Inc.
- *
- * RTC Driver for the Maxim DS1374 32-bit Binary
- * Counter WatchDog/RTC
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/rtc.h>		/* get the user-level API */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/miscdevice.h>
-#include <linux/fcntl.h>
-#include <linux/fs.h>
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-#include <asm/system.h>
-#include <asm/time.h>
-
-#include <asm/netlogic/sim.h>
-
-/* #define	DEBUG_DS1374 */
-
-#define EPOCH 		2000
-#define SYS_EPOCH 	1900
-
-#ifdef DEBUG_DS1374		
-#define dbg(fmt, args...) 	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
-#else
-#define dbg(fmt, args...)
-#endif
-
-#define err(format, arg...) 	printk(KERN_ERR ": " format , ## arg)
-#define info(format, arg...) 	printk(KERN_INFO ": " format , ## arg)
-
-#define DEVID_RTC    	   	0x68
-#define DS1374_RTC_BASE    	0x00
-
-#define NETLOGIC_I2C_DRIVERID_DS1374   	0x00
-
-extern struct proc_dir_entry *nlm_root_proc;
-
-static struct 	i2c_driver ds1374_driver;
-static struct 	i2c_client *this_client = NULL;
-static int 	ds1374_use_count = 0;
-static int 	rtc_read_proc(char *page, char **start, off_t off, int count, 
-		int *eof, void *data);
-static void 	ds1374_BinaryToDate(unsigned long binary, struct rtc_time *datetime);
-
-
-/* This is an image of the RTC registers starting at offset 0x00 */
-struct rtc_registers {
-	unsigned char todc_byte0;     	// 0x00
-	unsigned char todc_byte1;     	// 0x01
-	unsigned char todc_byte2;    	// 0x02
-	unsigned char todc_byte3; 	// 0x03
-};
-
-/* Array representing the number of days in one non-leap year at 
-   the beginning of each month */
-
-unsigned long DaysToMonth[13] = {
-	0,31,59,90,120,151,181,212,243,273,304,334,365
-};
-
-static int
-ds1374_read(struct i2c_client *client, u16 offset, u8 * buf, int len)
-{
-	int ret;
-	struct i2c_msg todc_read[1] = {
-		{
-			client->addr,			/* 0x68 */
-			client->flags | I2C_M_RD,	/* I2C Read Command */
-            offset,
-			4,				/* Need 4 Bytes */
-			buf				/* Store the result here */
-		}
-	};
-
-	if ((ret = i2c_transfer(client->adapter, todc_read, 1)) != 1) {
-		err("i2c_transfer failed, ret=%d\n", ret);
-		ret = -ENXIO;
-	}
-
-	return ret;
-}
-
-static int
-ds1374_write(struct i2c_client *client, u16 offset, u8 * buf, int len)
-{
-	int ret;
-	struct i2c_msg todc_write = {
-		client->addr,			/* 0x68 */
-		client->flags,			/* I2C Write Command */
-        offset, // register offset which to write
-		4,				/* Write 4 Bytes */
-		buf				/* Data to be written */
-	};
-
-	if ((ret = i2c_transfer(client->adapter, &todc_write, 1)) != 1) {
-		err("i2c_transfer failed, ret=%d\n", ret);
-		ret = -ENXIO;
-	}
-	return ret;
-}
-
-
-/* The DS1374 gives a 32-bit up-counter counting in seconds.
- * We rely on a Maxim Algorithm to convert this 32-bit binary
- * to a user-friendly time/date format
- */
-static void ds1374_BinaryToDate(unsigned long binary, struct rtc_time *datetime) {
-
-	unsigned long hour;
-	unsigned long day;
-	unsigned long minute;
-	unsigned long second;
-	unsigned long month;
-	unsigned long year;
-
-	unsigned long whole_minutes;
-	unsigned long whole_hours;
-	unsigned long whole_days;
-	unsigned long whole_days_since_1968;
-	unsigned long leap_year_periods;
-	unsigned long days_since_current_lyear;
-	unsigned long whole_years;
-	unsigned long days_since_first_of_year;
-	unsigned long days_to_month;
-	unsigned long day_of_week;
-
-	whole_minutes = binary / 60;
-	second = binary - (60 * whole_minutes);			/* leftover seconds */
-
-	whole_hours  = whole_minutes / 60;
-	minute = whole_minutes - (60 * whole_hours);		/* leftover minutes */
-
-	whole_days   = whole_hours / 24;
-	hour         = whole_hours - (24 * whole_days);		/* leftover hours */
-
-	whole_days_since_1968 = whole_days + 365 + 366;
-	leap_year_periods = whole_days_since_1968 / ((4 * 365) + 1);
-
-	days_since_current_lyear = whole_days_since_1968 % ((4 * 365) + 1);
-
-	/* if days are after a current leap year then add a leap year period */
-	if ((days_since_current_lyear >= (31 + 29))) {
-		leap_year_periods++;
-	}
-	whole_years = (whole_days_since_1968 - leap_year_periods) / 365;
-	days_since_first_of_year = whole_days_since_1968 - 
-		(whole_years * 365) - leap_year_periods;
-
-	if ((days_since_current_lyear <= 365) && (days_since_current_lyear >= 60)) {
-		days_since_first_of_year++;
-	}
-	year = whole_years + 68;
-
-	/* setup for a search for what month it is based on how many days have past
-	 * within the current year	
-	 */
-	month = 13;
-	days_to_month = 366;
-	while (days_since_first_of_year < days_to_month) {
-		month--;
-		days_to_month = DaysToMonth[month];
-		if ((month >= 2) && ((year % 4) == 0)) {
-			days_to_month++;
-		}
-	}
-	day = days_since_first_of_year - days_to_month + 1;
-
-	day_of_week = (whole_days  + 4) % 7;
-
-	datetime->tm_yday =  days_since_first_of_year;	/* days since Jan 1 - [0,365]*/
-	datetime->tm_sec  = second;			/* seconds after the minute - [0,59]*/
-	datetime->tm_min  = minute;			/* minutes after the hour - [0,59]*/
-	datetime->tm_hour = hour;			/* hours since midnight - [0,23]*/
-	datetime->tm_mday = day;			/* day of the month - [1,31]*/
-	datetime->tm_wday = day_of_week;		/* days since Sunday - [0,6]*/
-	datetime->tm_mon  = month;			/* months since January - [0,11]*/
-	datetime->tm_year = year;			/* years since 1900*/
-}
-
-/* Converting DateTime format to the 32-bit Binary */
-unsigned long ds1374_DateToBinary(struct rtc_time *datetime) {
-
-	unsigned long iday;
-	unsigned long val;
-
-	iday = (365 * (datetime->tm_year - 70)) + DaysToMonth[datetime->tm_mon] + (datetime->tm_mday - 1);
-	iday = iday + ((datetime->tm_year - 69) / 4);
-	if ((datetime->tm_mon > 1) && ((datetime->tm_year % 4) == 0)) {
-		iday++;
-	}
-	val = datetime->tm_sec + (60 * datetime->tm_min) + (3600 * (datetime->tm_hour + (24 * iday)));
-	dbg("ds1374_DateToBinary: 0x%lx [%d]\n", val, val);
-	return val;
-}
-
-static int
-ds1374_get_time(struct i2c_client *client, struct rtc_time *tm)
-{
-	struct rtc_registers rtc;
-	int ret;
-	unsigned int binary=0x00, binary1;
-	int limit=10;
-
-	if (!client) return -ENXIO;
-	
-retry:
-	/* read RTC registers */
-	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
-					sizeof (struct rtc_registers))) < 0) {
-		dbg("couldn't read RTC\n");
-		return ret;
-	}
-
-	dbg("IN: todc_B0=%02d, todc_B1=%02d, todc_B2=%02d, todc_B3=%02d\n",
-			rtc.todc_byte0, 
-			rtc.todc_byte1, 
-			rtc.todc_byte2, 
-			rtc.todc_byte3);
-
-	binary = 	(rtc.todc_byte0) + (rtc.todc_byte1 << 8) + 
-		  	(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
-
-	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
-					sizeof (struct rtc_registers))) < 0) {
-		dbg("couldn't read RTC\n");
-		return ret;
-	}
-	binary1 = (rtc.todc_byte0) + (rtc.todc_byte1 << 8) +
-		(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
-
-	if((binary1 != binary) && limit) {
-		limit--;
-		goto retry;
-	}
-	if(binary1 != binary)
-		printk("ds1374_read:Unable to read consistent date value\n");
-
-	ds1374_BinaryToDate(binary, tm);
-
-	dbg("Date [%02d:%02d:%04d] Time [%02d:%02d:%02d]\n",
-			tm->tm_mon+1, tm->tm_mday,  (1900+tm->tm_year),
-			tm->tm_hour, tm->tm_min, tm->tm_sec);
-	return 0;
-}
-
-static int
-ds1374_set_time(struct i2c_client *client, struct rtc_time *tm)
-{
-	struct rtc_registers rtc, rtc1;
-	unsigned int binary=0x00, binary1;
-	int limit;
-
-	if (!client) return -ENXIO;
-	
-	dbg("IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
-			tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
-			tm->tm_min, tm->tm_sec);
-
-	binary = ds1374_DateToBinary(tm);
-
-	rtc.todc_byte0	= (unsigned char)(binary >> 24);
-	rtc.todc_byte1	= (unsigned char)(binary >> 16);
-	rtc.todc_byte2	= (unsigned char)(binary >> 8);
-	rtc.todc_byte3	= (unsigned char)(binary & 0xFF);
-
-	/* write RTC registers */
-	limit = 10;
-	do {
-		ds1374_write(client, DS1374_RTC_BASE, (u8 *)&rtc, 
-				sizeof (struct rtc_registers));
-		ds1374_read(client, DS1374_RTC_BASE, (u8 *)&rtc1, 
-				sizeof (struct rtc_registers));
-		binary1 = (rtc1.todc_byte0) + (rtc1.todc_byte1 << 8) + 
-			(rtc1.todc_byte2 << 16) + (rtc1.todc_byte3 << 24);
-	} while ((binary1 != binary) && limit--);
-
-	if(binary1 != binary)
-		printk("ds1374_set_time: cannot set date on rtc\n");
-	return 0;
-}
-
-static int
-ds1374_probe(struct i2c_adapter *adap)
-{
-	int ret;
-	struct rtc_time dummy_tm;
-	struct i2c_board_info info;
-
-	memset(&info, 0, sizeof(struct i2c_board_info));
-	strlcpy(info.type, "DS1374", I2C_NAME_SIZE);
-	info.addr = DEVID_RTC;
-
-	this_client = i2c_new_device(adap, &info);
-	if (this_client == NULL)
-		ret = -1;
-
-	/* use ds1374_get_time() to probe for a DS1374 on this bus.  */
-	if ((ret = ds1374_get_time(this_client, &dummy_tm)) < 0) {
-		i2c_unregister_device(this_client);
-		this_client = NULL;
-		return ret;
-	}
-
-	info("Found DS1374 on %s\n", adap->name);
-	return 0;
-}
-
-static int
-ds1374_detach(struct i2c_client *client)
-{
-	i2c_unregister_device(client);
-
-	return 0;
-}
-
-int
-rtc_open(struct inode *minode, struct file *mfile)
-{
-	/*if(MOD_IN_USE) */
-	if (ds1374_use_count > 0) {
-		return -EBUSY;
-	}
-/* 	MOD_INC_USE_COUNT; */
-	++ds1374_use_count;
-	return 0;
-}
-
-int
-rtc_release(struct inode *minode, struct file *mfile)
-{
-/* 	MOD_DEC_USE_COUNT; */
-	--ds1374_use_count;
-	return 0;
-}
-
-static loff_t
-rtc_llseek(struct file *mfile, loff_t offset, int origint)
-{
-	return -ESPIPE;
-}
-
-static int
-ds1374_command(struct i2c_client *client, unsigned int cmd, void *arg)
-{
-	return -EINVAL;
-}
-
-static int
-rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	struct rtc_time rtc_tm;
-	int ret;
-
-	switch (cmd) {
-		case RTC_RD_TIME:       /* Read the time/date from RTC  */
-			memset(&rtc_tm, 0, sizeof(rtc_tm));
-			if ((ret = ds1374_get_time(this_client, &rtc_tm)) < 0)
-				return ret;
-			return copy_to_user((void *) arg, &rtc_tm, sizeof (rtc_tm)) ?
-				-EFAULT : 0;
-		case RTC_SET_TIME:      /* Set the RTC */
-			if (!capable(CAP_SYS_TIME))
-				return -EACCES;
-
-			if (copy_from_user(&rtc_tm,
-						(struct rtc_time *) arg,
-						sizeof (struct rtc_time)))
-				return -EFAULT;
-			return ds1374_set_time(this_client, &rtc_tm);
-			return 0;
-		default:
-			return -EINVAL;
-	}
-}
-
-static struct i2c_driver ds1374_driver = {
-	//.id		= NETLOGIC_I2C_DRIVERID_DS1374,
-	.driver = {
-		.name   = "ds1374",
-	},
-	.attach_adapter = ds1374_probe,
-	.remove 	= ds1374_detach,
-	.command	= ds1374_command
-};
-
-static struct file_operations rtc_fops = {
-	.owner 		= THIS_MODULE,
-	.llseek 	= rtc_llseek,
-	.ioctl 		= rtc_ioctl,
-	.open 		= rtc_open,
-	.release 	= rtc_release,
-};
-
-static struct miscdevice ds1374_miscdev = {
-	RTC_MINOR,
-	"rtc",
-	&rtc_fops
-};
-
-static int __init ds1374_init(void)
-{
-	int ret;
-	extern int xlr_noi2c;
-
-	if(xlr_noi2c)
-		return 0;
-
-	printk("Registering Netlogic xlr I2C based RTC driver...\n");
-	ret = i2c_add_driver(&ds1374_driver);
-	if (ret) {
-		printk("Unable to register xlr RTC driver!\n");
-		return ret;		
-	}	
-
-	ret = misc_register(&ds1374_miscdev);
-	if (ret) {
-		err("Register misc driver failed, errno is %d\n", ret);
-		i2c_del_driver(&ds1374_driver);
-		return ret;
-	}
-
-	create_proc_read_entry("rtc", 0, nlm_root_proc, rtc_read_proc, NULL);
-
-	return 0;
-}
-
-static void __exit ds1374_exit(void)
-{
-	remove_proc_entry("rtc", nlm_root_proc);
-	misc_deregister(&ds1374_miscdev);
-	i2c_del_driver(&ds1374_driver);
-}
-
-
-module_init(ds1374_init);
-module_exit(ds1374_exit);
-
-/*
- * Info exported via "/proc/driver/rtc".
- */
-
-static int
-rtc_proc_output(char *buf)
-{
-	char *p;
-	struct rtc_time tm;
-	int ret;
-
-	if (!this_client) {
-		p = buf;
-		p += sprintf(p, "Driver Not Initialized Properly!\n");		
-		return p - buf;		
-	}
-	
-	if ((ret = ds1374_get_time(this_client, &tm)) < 0)
-		return ret;
-
-	p = buf;
-	/*
-	 * There is no way to tell if the luser has the RTC set for local
-	 * time or for Universal Standard Time (GMT). Probably local though.
-	 */
-	p += sprintf(p,
-			"rtc_time\t: %02d:%02d:%02d\n"
-			"rtc_date\t: %04d-%02d-%02d\n"
-			"rtc_epoch\t: %04d\n",
-			tm.tm_hour, tm.tm_min, tm.tm_sec,
-			tm.tm_year + SYS_EPOCH, tm.tm_mon + 1, tm.tm_mday, EPOCH);
-	return p - buf;
-}
-
-static int
-rtc_read_proc(char *page, char **start, off_t off,
-		int count, int *eof, void *data)
-{
-	int len = rtc_proc_output(page);
-	if (len <= off + count)
-		*eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len > count)
-		len = count;
-	if (len < 0)
-		len = 0;
-	return len;
-}
-
-MODULE_AUTHOR("RMI Inc.");
-MODULE_DESCRIPTION("Maxim DS1374 RTC Driver");
-MODULE_LICENSE("GPL");
-- 
1.7.0.4

