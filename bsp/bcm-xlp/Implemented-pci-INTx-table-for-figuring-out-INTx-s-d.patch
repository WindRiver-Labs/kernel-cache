From b7b7fcf91eb5f2dd0e9d17a8fca97fe792171bba Mon Sep 17 00:00:00 2001
From: Om Narasimhan <onarasimhan@netlogicmicro.com>
Date: Wed, 18 May 2011 11:26:44 -0700
Subject: [PATCH 295/761] Implemented pci INTx table for figuring out INTx's
 depending on configuration.

After controller is initialized, choose interrupts from the table of possible configurations.
Check LTSSM for card presence and power on config for board configs.

Based on Broadcom SDK 2.3.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/pci/pci-xlp.c |  125 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 123 insertions(+), 2 deletions(-)

diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index aeac050..f7ba322 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -38,6 +38,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/io.h>
 #include <asm/netlogic/iomap.h>
 #include <asm/netlogic/sim.h>
+#define NLM_HAL_LINUX_KERNEL
+#include <asm/netlogic/hal/nlm_hal_pic.h>
 
 extern int pci_probe_only;
 
@@ -50,9 +52,112 @@ static void *pci_io_base;
         (((x) & 0x0000ff00) << 8)  |		\
         (((x) & 0x00ff0000) >> 8)
 
+/*
+ * Possible values are 44, 43, 42 or 41 for interrupts
+ * For mapping of these values to IRT, refer
+ * arch/mips/netlogic/common/nlm_hal.c
+ *
+ * We have some unique problems here.
+ * 1. Board could be configured in different lane widths. That means, the cards
+ * could be controlled by different functions
+ * Eg. 2x8 config can have two cards (fn 0 and fn 2)
+ *	4x4 config can also have two cards (under fn0 - fn 3)
+ * So, it is important to figure out the lanes on which cards are placed.
+ * First we read the lane config from POWER_ON_RESET_CFG
+ * Then each line's LTSSM state would give the card presence
+ * Based on that we have to assign interrupt values
+ *
+ * XLP irq map is as follows
+ *  \fn 0	1	2	3
+ *plc\
+ * 0	44	0	42	41
+ * 1	44	43	42	0
+ * 2	44	0	42	41
+ * 3	44	43	42	41
+ */
+static int xlp_irq_map[4][4][3] = {
+	{{44, 0, 0}, {0, 0, 0}, {42, 0, 0}, {0, 0, 0}},
+	{{44, 0, 0}, {43, 0, 0}, {42, 0, 0}, {0, 0, 0}},
+	{{44, 0, 0}, {0, 0, 0}, {42, 0, 0}, {41, 0, 0}},
+	{{44, 0, 0}, {43, 0, 0}, {42, 0, 0}, {41, 0, 0}},
+};
+
+static void xlp_map_helper(int row, int fn)
+{
+	u64 xlp_pci_base;
+	u32 reg6, ltssm;
+
+	xlp_pci_base = 0x18000000 + (0 << 20) + (1 << 15) + ( fn << 12);
+	ltssm = nlm_hal_read_32bit_reg(xlp_pci_base, 0x25E);
+	if (ltssm != 0x00446000) {
+		printk(KERN_WARNING "LTSSM state is %#x. Fn %x link not up\n",
+				ltssm, fn);
+		return;
+	}
+	reg6 = nlm_hal_read_32bit_reg(xlp_pci_base, 0x6);
+	xlp_irq_map[row][fn][1] = (reg6 >> 8) & 0xff;
+	xlp_irq_map[row][fn][2] = (reg6 >> 16) & 0xff;
+	printk(KERN_WARNING "Set sec = %x, sub = %x for fn = %#x\n",
+		xlp_irq_map[row][fn][1], xlp_irq_map[row][fn][2],fn);
+	return;
+}
+
 static void pcie_controller_init_done(void)
 {
-	/* XLP_MERGE_TODO */
+	u64 xlp_syscfg_base = 0x18000000 + (0 << 20) + (6 << 15) + ( 5 << 12);
+	u32 plc, syscfg, mode, count = 0;
+
+	if (!pci_probe_only){
+		printk(KERN_WARNING "PCIe bus IRQs configured incorrectly\n");
+		return;
+	}
+	/* We don't manipulate pci_address space.
+	 * Get the link status from pcie lane config from 34.9.7.2 XLP PRM */
+	syscfg = nlm_hal_read_32bit_reg(xlp_syscfg_base, 0x41);
+	mode = (syscfg >> 19) & 0xf;
+	while (count < 4) {
+		printk(KERN_WARNING "Controller %d is in %s mode\n",
+				count, (mode & (1 << count)) ? "RC" : "EP");
+		count++;
+	}
+	plc = (syscfg >> 23) & 0x3;
+	printk(KERN_WARNING "PLC = %#x, mode = %#x\n", plc, mode);
+	switch (plc) {
+		/* In each case find subordinate and primary numbers */
+	case 0:
+		/* controller 0 and 2 are active */
+		if (mode & 0x1)
+			xlp_map_helper(plc, 0);
+		if (mode & 0x4)
+			xlp_map_helper(plc, 2);
+		break;
+	case 1:
+		if (mode & 0x1)
+			xlp_map_helper(plc, 0);
+		if (mode & 0x2)
+			xlp_map_helper(plc, 1);
+		if (mode & 0x4)
+			xlp_map_helper(plc, 2);
+		break;
+	case 2:
+		if (mode & 0x1)
+			xlp_map_helper(plc, 0);
+		if (mode & 0x4)
+			xlp_map_helper(plc, 2);
+		if (mode & 0x8)
+			xlp_map_helper(plc, 3);
+		break;
+	case 3:
+		if (mode & 0x1)
+			xlp_map_helper(plc, 0);
+		if (mode & 0x2)
+			xlp_map_helper(plc, 1);
+		if (mode & 0x4)
+			xlp_map_helper(plc, 2);
+		if (mode & 0x8)
+			xlp_map_helper(plc, 3);
+		break;
+	}
 	printk("[%s]: PCIE Controller initialization to be done\n", __FUNCTION__);
 	return;
 }
@@ -165,7 +270,23 @@ struct pci_controller xlp_controller = {
 
 int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
-	return slot + 43;
+	int ret = 0;
+	int row = 0, fn = 0;
+
+	while (row < 4) {
+		while (fn < 4) {
+			if ((dev->bus->number >= xlp_irq_map[row][fn][1]) &&
+				(dev->bus->number <= xlp_irq_map[row][fn][2])) {
+				ret = xlp_irq_map[row][fn][0];
+				goto out;
+			}
+			fn++;
+		}
+		row++;
+	}
+out:
+	dev_printk(KERN_WARNING, &dev->dev, "Assigning interrupt %#x\n", ret);
+	return ret;
 }
 
 /* Do platform specific device initialization at pci_enable_device() time */
-- 
1.7.10.4

