From 48dfa84d810dcf8eb0da8b8fc973ed1041ab1fd0 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Fri, 8 Oct 2010 20:21:43 -0700
Subject: [PATCH 204/761] PIC access fixes for XLP A0 Multi-Node bug

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/xlr_mac.h     |  254 +++++++++++++-------------
 arch/mips/kernel/xlr_fast_sys_call_handler.S |    7 +-
 arch/mips/netlogic/xlp/irq.c                 |   11 +-
 arch/mips/netlogic/xlp/smp.c                 |   11 ++
 arch/mips/netlogic/xlp/time.c                |    6 +-
 init/main.c                                  |   21 +++
 kernel/printk.c                              |   19 +-
 7 files changed, 184 insertions(+), 145 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlr_mac.h b/arch/mips/include/asm/netlogic/xlr_mac.h
index 3bcf53c..46515eb 100644
--- a/arch/mips/include/asm/netlogic/xlr_mac.h
+++ b/arch/mips/include/asm/netlogic/xlr_mac.h
@@ -173,7 +173,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define   O_XGMAC_CONFIG_2__hstmlnkflth             27
 #define   O_XGMAC_CONFIG_2__hstalnkflth             26
 #define   O_XGMAC_CONFIG_2__rflnkflt                24
-#define   W_XGMAC_CONFIG_2__rflnkflt                 2                          
+#define   W_XGMAC_CONFIG_2__rflnkflt                 2
 #define   O_XGMAC_CONFIG_2__hstipgextmod            16
 #define   W_XGMAC_CONFIG_2__hstipgextmod             5
 #define   O_XGMAC_CONFIG_2__hstrctlfrcp             15
@@ -952,9 +952,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
 #define MAC_PREPAD             32
-#else 
-#define MAC_PREPAD             0 
-#endif 
+#else
+#define MAC_PREPAD             0
+#endif
 
 #define BYTE_OFFSET             2
 #define NLM_RX_BUF_SIZE (MAC_MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
@@ -968,105 +968,105 @@ enum {
 };
 
 enum tsv_rsv_reg{
-  TX_RX_64_BYTE_FRAME = 0x20,
-  TX_RX_64_127_BYTE_FRAME,
-  TX_RX_128_255_BYTE_FRAME,
-  TX_RX_256_511_BYTE_FRAME,
-  TX_RX_512_1023_BYTE_FRAME,
-  TX_RX_1024_1518_BYTE_FRAME,
-  TX_RX_1519_1522_VLAN_BYTE_FRAME,
+	TX_RX_64_BYTE_FRAME = 0x20,
+	TX_RX_64_127_BYTE_FRAME,
+	TX_RX_128_255_BYTE_FRAME,
+	TX_RX_256_511_BYTE_FRAME,
+	TX_RX_512_1023_BYTE_FRAME,
+	TX_RX_1024_1518_BYTE_FRAME,
+	TX_RX_1519_1522_VLAN_BYTE_FRAME,
 
-  RX_BYTE_COUNTER = 0x27,
-  RX_PACKET_COUNTER,
-  RX_FCS_ERROR_COUNTER,
-  RX_MULTICAST_PACKET_COUNTER,
-  RX_BROADCAST_PACKET_COUNTER,
-  RX_CONTROL_FRAME_PACKET_COUNTER,
-  RX_PAUSE_FRAME_PACKET_COUNTER,
-  RX_UNKNOWN_OP_CODE_COUNTER,
-  RX_ALIGNMENT_ERROR_COUNTER,
-  RX_FRAME_LENGTH_ERROR_COUNTER,
-  RX_CODE_ERROR_COUNTER,
-  RX_CARRIER_SENSE_ERROR_COUNTER,
-  RX_UNDERSIZE_PACKET_COUNTER,
-  RX_OVERSIZE_PACKET_COUNTER,
-  RX_FRAGMENTS_COUNTER,
-  RX_JABBER_COUNTER,
-  RX_DROP_PACKET_COUNTER,
+	RX_BYTE_COUNTER = 0x27,
+	RX_PACKET_COUNTER,
+	RX_FCS_ERROR_COUNTER,
+	RX_MULTICAST_PACKET_COUNTER,
+	RX_BROADCAST_PACKET_COUNTER,
+	RX_CONTROL_FRAME_PACKET_COUNTER,
+	RX_PAUSE_FRAME_PACKET_COUNTER,
+	RX_UNKNOWN_OP_CODE_COUNTER,
+	RX_ALIGNMENT_ERROR_COUNTER,
+	RX_FRAME_LENGTH_ERROR_COUNTER,
+	RX_CODE_ERROR_COUNTER,
+	RX_CARRIER_SENSE_ERROR_COUNTER,
+	RX_UNDERSIZE_PACKET_COUNTER,
+	RX_OVERSIZE_PACKET_COUNTER,
+	RX_FRAGMENTS_COUNTER,
+	RX_JABBER_COUNTER,
+	RX_DROP_PACKET_COUNTER,
 
-  TX_BYTE_COUNTER   = 0x38,
-  TX_PACKET_COUNTER,
-  TX_MULTICAST_PACKET_COUNTER,
-  TX_BROADCAST_PACKET_COUNTER,
-  TX_PAUSE_CONTROL_FRAME_COUNTER,
-  TX_DEFERRAL_PACKET_COUNTER,
-  TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
-  TX_SINGLE_COLLISION_PACKET_COUNTER,
-  TX_MULTI_COLLISION_PACKET_COUNTER,
-  TX_LATE_COLLISION_PACKET_COUNTER,
-  TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
-  TX_TOTAL_COLLISION_COUNTER,
-  TX_PAUSE_FRAME_HONERED_COUNTER,
-  TX_DROP_FRAME_COUNTER,
-  TX_JABBER_FRAME_COUNTER,
-  TX_FCS_ERROR_COUNTER,
-  TX_CONTROL_FRAME_COUNTER,
-  TX_OVERSIZE_FRAME_COUNTER,
-  TX_UNDERSIZE_FRAME_COUNTER,
-  TX_FRAGMENT_FRAME_COUNTER,
+	TX_BYTE_COUNTER   = 0x38,
+	TX_PACKET_COUNTER,
+	TX_MULTICAST_PACKET_COUNTER,
+	TX_BROADCAST_PACKET_COUNTER,
+	TX_PAUSE_CONTROL_FRAME_COUNTER,
+	TX_DEFERRAL_PACKET_COUNTER,
+	TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
+	TX_SINGLE_COLLISION_PACKET_COUNTER,
+	TX_MULTI_COLLISION_PACKET_COUNTER,
+	TX_LATE_COLLISION_PACKET_COUNTER,
+	TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
+	TX_TOTAL_COLLISION_COUNTER,
+	TX_PAUSE_FRAME_HONERED_COUNTER,
+	TX_DROP_FRAME_COUNTER,
+	TX_JABBER_FRAME_COUNTER,
+	TX_FCS_ERROR_COUNTER,
+	TX_CONTROL_FRAME_COUNTER,
+	TX_OVERSIZE_FRAME_COUNTER,
+	TX_UNDERSIZE_FRAME_COUNTER,
+	TX_FRAGMENT_FRAME_COUNTER,
 
-  CARRY_REG_1 = 0x4c,
-  CARRY_REG_2 = 0x4d,
+	CARRY_REG_1 = 0x4c,
+	CARRY_REG_2 = 0x4d,
 };
 
 struct size_1_desc {
-  uint64_t entry0;
+	uint64_t entry0;
 };
 
 struct size_2_desc {
-  uint64_t entry0;
-  uint64_t entry1;
+	uint64_t entry0;
+	uint64_t entry1;
 };
 
 struct size_3_desc {
-  uint64_t entry0;
-  uint64_t entry1;
-  uint64_t entry2;
+	uint64_t entry0;
+	uint64_t entry1;
+	uint64_t entry2;
 };
 
 struct size_4_desc {
-  uint64_t entry0;
-  uint64_t entry1;
-  uint64_t entry2;
-  uint64_t entry3;
+	uint64_t entry0;
+	uint64_t entry1;
+	uint64_t entry2;
+	uint64_t entry3;
 };
 
 struct fr_desc {
-  struct size_1_desc d1;
+	struct size_1_desc d1;
 };
 
 union rx_tx_desc {
-  struct size_1_desc d1;
+	struct size_1_desc d1;
 };
 
 static inline int mac_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
 				    unsigned long addr)
 {
-  int stid = 0;
-  
-  if (type == TYPE_XGMAC) stid = msgrng_xgmac_stid_rfr(id);
-  else  {
+	int stid = 0;
+
+	if (type == TYPE_XGMAC) stid = msgrng_xgmac_stid_rfr(id);
+	else  {
 #ifdef MAC_SPLIT_MODE
-    stid =  msgrng_gmac_stid_rfr_split_mode(id);
+		stid =  msgrng_gmac_stid_rfr_split_mode(id);
 #else
-    stid = msgrng_gmac_stid_rfr(id);
-#endif 
-  }
-  msg->msg0 = (((uint64_t)CTRL_REG_FREE << 61) | 
-	       ((uint64_t)stid<<52) | 
-	       (uint64_t)addr);
-  msg->msg1 = msg->msg2 = msg->msg3 = 0;
-  return stid;
+		stid = msgrng_gmac_stid_rfr(id);
+#endif
+	}
+	msg->msg0 = (((uint64_t)CTRL_REG_FREE << 61) |
+		     ((uint64_t)stid<<52) |
+		     (uint64_t)addr);
+	msg->msg1 = msg->msg2 = msg->msg3 = 0;
+	return stid;
 }
 
 
@@ -1074,71 +1074,71 @@ static inline int mac_make_desc_rfr(struct msgrng_msg *msg, int id, int type,
 static inline int
 msgrng_stid_rfr(int id, int type)
 {
-    int stid = 0;
+	int stid = 0;
 
-  if (type == TYPE_XGMAC) 
-    stid = msgrng_xgmac_stid_rfr(id);
-    else  {
-        if (id < 4) {
+	if (type == TYPE_XGMAC)
+		stid = msgrng_xgmac_stid_rfr(id);
+	else  {
+		if (id < 4) {
 #ifdef MAC_SPLIT_MODE
-            stid =  msgrng_gmac_stid_rfr_split_mode(id);
+			stid =  msgrng_gmac_stid_rfr_split_mode(id);
 #else
-            stid = msgrng_gmac_stid_rfr(id);
-#endif 
-        }
-        else
-            stid = msgrng_gmac1_stid_rfr(id);
-    }
-  return stid;
+			stid = msgrng_gmac_stid_rfr(id);
+#endif
+		}
+		else
+			stid = msgrng_gmac1_stid_rfr(id);
+	}
+	return stid;
 }
 
 
 
 static inline int mac_make_desc_b0_rfr(struct msgrng_msg *msg, int id, int type,
-        unsigned long addr)
+				       unsigned long addr)
 {
-    int stid = msgrng_stid_rfr(id, type);
+	int stid = msgrng_stid_rfr(id, type);
 
-    msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
-    msg->msg1 = msg->msg2 = msg->msg3 = 0;
+	msg->msg0 = (uint64_t)addr & 0xffffffffe0ULL;
+	msg->msg1 = msg->msg2 = msg->msg3 = 0;
 
-    return stid;
+	return stid;
 }
 
 #define MAC_TX_DESC_ALIGNMENT (SMP_CACHE_BYTES - 1)
 static inline int mac_make_desc_tx(struct msgrng_msg *msg, int id, int type,
-        unsigned long addr, int len)
+				   unsigned long addr, int len)
 {
-    int tx_stid = 0;
-    int fr_stid = 0;
-    int desc_offset = addr & MAC_TX_DESC_ALIGNMENT;
+	int tx_stid = 0;
+	int fr_stid = 0;
+	int desc_offset = addr & MAC_TX_DESC_ALIGNMENT;
 
-    if (type == TYPE_XGMAC) {
-        tx_stid = msgrng_xgmac_stid_tx(id);
-        fr_stid = 0;
-    }
-    else {
-        int cpu = netlogic_cpu_id();
-        if (id < 4)
-            tx_stid = msgrng_gmac_stid_tx(id);
-        else
-            tx_stid = msgrng_gmac1_stid_tx(id);
-        fr_stid = (cpu << 3) + netlogic_thr_id();
-    }
+	if (type == TYPE_XGMAC) {
+		tx_stid = msgrng_xgmac_stid_tx(id);
+		fr_stid = 0;
+	}
+	else {
+		int cpu = hard_smp_processor_id() >> 2;
+		if (id < 4)
+			tx_stid = msgrng_gmac_stid_tx(id);
+		else
+			tx_stid = msgrng_gmac1_stid_tx(id);
+		fr_stid = (cpu << 3) + netlogic_thr_id();
+	}
 
-    msg->msg0 = ( ((uint64_t)CTRL_SNGL << 61) | 
-            ((uint64_t)desc_offset << 40) | 
-            ((uint64_t)tx_stid << 52) |
-            ((uint64_t)addr & ~MAC_TX_DESC_ALIGNMENT)
-            );
-    msg->msg1 = ( ( (uint64_t)CTRL_EOP << 61) |  
-            ( ((uint64_t)fr_stid) << 54) | 
-            ( (uint64_t)len << 40)
-            );
+	msg->msg0 = ( ((uint64_t)CTRL_SNGL << 61) |
+		      ((uint64_t)desc_offset << 40) |
+		      ((uint64_t)tx_stid << 52) |
+		      ((uint64_t)addr & ~MAC_TX_DESC_ALIGNMENT)
+		);
+	msg->msg1 = ( ( (uint64_t)CTRL_EOP << 61) |
+		      ( ((uint64_t)fr_stid) << 54) |
+		      ( (uint64_t)len << 40)
+		);
 
-    msg->msg2 = msg->msg3 = 0;
+	msg->msg2 = msg->msg3 = 0;
 
-    return tx_stid;
+	return tx_stid;
 }
 
 extern __u8 xlr_base_mac_addr[];
@@ -1146,13 +1146,13 @@ extern __u8 xlr_base_mac_addr[];
  * Structure of an rmios ipsec packet
  */
 typedef struct tagIPSEC_PACKET {
-    // cacheline-aligned portion
-    PacketDescriptor_t packet_desc; // multiple of 32 (32)
-    PacketDescriptor_t particle_desc;// second particle (GCM)
-    unsigned char auth_dest[PHXSEC_HMAC_LENGTH];    // multiple of 32 (32)
-    unsigned char packet_data[IPSEC_PACKET_PAYLOAD_SIZE];
-    // end of cacheline-aligned portion
-    int src_id;
+	// cacheline-aligned portion
+	PacketDescriptor_t packet_desc; // multiple of 32 (32)
+	PacketDescriptor_t particle_desc;// second particle (GCM)
+	unsigned char auth_dest[PHXSEC_HMAC_LENGTH];    // multiple of 32 (32)
+	unsigned char packet_data[IPSEC_PACKET_PAYLOAD_SIZE];
+	// end of cacheline-aligned portion
+	int src_id;
 } IPSEC_PACKET ____cacheline_aligned;
 
 #endif
diff --git a/arch/mips/kernel/xlr_fast_sys_call_handler.S b/arch/mips/kernel/xlr_fast_sys_call_handler.S
index c88568a..6464cfd 100644
--- a/arch/mips/kernel/xlr_fast_sys_call_handler.S
+++ b/arch/mips/kernel/xlr_fast_sys_call_handler.S
@@ -451,7 +451,12 @@ END(nlm_uaccess_fs_mem_write32)
 
 #if defined(CONFIG_NLM_XLP)
 #include <asm/netlogic/hal/nlm_hal_pic.h>
-	dli	k0, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        MFC0    k0, CP0_PRID, 1
+        andi    k0, k0, 0x3ff
+        srl     k0, k0, 5  /* grab node id */
+        sll     k0, k0, 18 /* Use local PIC */
+        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        dadd    k0, k1, k0
 	ld	k1, 0(k0)
 	dsrl32	$9, k1, 0
 	dsll32  $8, k1, 0
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 7dd1fb4..11c689e 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -67,7 +67,7 @@ spinlock_t nlm_common_pic_lock = SPIN_LOCK_UNLOCKED;
 
 static unsigned int pic_startup(unsigned int irq)
 {
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	pic_reg_t *mmio = nlm_hal_pic_offset();
 	unsigned long flags;
 	nlm_reg_t reg;
 	unsigned long irt;
@@ -97,7 +97,7 @@ static unsigned int pic_startup(unsigned int irq)
 
 static void pic_unmask(unsigned int irq)
 {
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	pic_reg_t *mmio = nlm_hal_pic_offset();
 	unsigned long flags;
 	nlm_reg_t reg;
 	unsigned long irt;
@@ -178,7 +178,7 @@ static void pic_end(unsigned int irq)
 
 static void pic_shutdown(unsigned int irq)
 {
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	pic_reg_t *mmio = nlm_hal_pic_offset();
 	unsigned long flags;
 	nlm_reg_t reg;
 	unsigned long irt;
@@ -254,8 +254,9 @@ static int rsvd_pic_handler_2(unsigned int irq, const struct cpumask *mask)
 {
 	if(irq < PIC_IRQ_BASE)
 		return -1;
-  dbg_msg("handler called for a reserved irq (%d)\n", irq);
-  return 0;
+
+	dbg_msg("handler called for a reserved irq (%d)\n", irq);
+	return 0;
 }
 
 struct irq_chip nlm_common_rsvd_pic = {
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index acc3cf1..2acce0d 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -88,6 +88,7 @@ void nlm_send_ipi_mask(const struct cpumask * mask, unsigned int action)
 	}
 }
 
+extern void nlm_common_timer_setup(void);
 /*
  * Code to run on secondary just after probing the CPU
  */
@@ -97,6 +98,16 @@ static void __cpuinit nlm_init_secondary(void)
     nlm_smp_irq_init();
 
     enable_msgconfig_int();
+
+    /* Workaround for XLP A0 Multi-Node bug */
+    {
+	    int cpu = hard_smp_processor_id();
+
+	    if ( (cpu % 32) == 0) {
+		    /* If this cpu@0 of any of the nodes, initialize PIC */
+		    nlm_common_timer_setup();
+	    }
+    }
 }
 
 void nlm_smp_finish(void)
diff --git a/arch/mips/netlogic/xlp/time.c b/arch/mips/netlogic/xlp/time.c
index 66884db..f22dce8 100644
--- a/arch/mips/netlogic/xlp/time.c
+++ b/arch/mips/netlogic/xlp/time.c
@@ -74,7 +74,7 @@ void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
 	int cpu = hard_smp_processor_id();
 
 #ifdef CONFIG_NLM_WATCHDOG
-        pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+        pic_reg_t *mmio = nlm_hal_pic_offset();
 
 	/* ack the watchdog */
 	/* Need to choose (?) the right heartbeat reg (0/1) and right chunk */
@@ -144,7 +144,7 @@ void nlm_common_timer_interrupt(struct pt_regs *regs, int irq)
 cycle_t xlr_hpt_read(void)
 {
 	uint32_t counter;
-	pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+	pic_reg_t *mmio = nlm_hal_pic_offset();
 	counter = (uint32_t) nlm_hal_read_pic_reg(mmio, PIC_TIMER_6_COUNTER);
 	return (cycle_t)(PIC_FREE_RUNNING_TIMER_MAX_VAL - counter);
 }
@@ -157,7 +157,7 @@ int read_current_timer(unsigned long *timer_val)
 
 void nlm_common_timer_setup(void)
 {
-        pic_reg_t *mmio = (pic_reg_t *) XLP_IO_PIC_OFFSET;
+        pic_reg_t *mmio = nlm_hal_pic_offset();
         unsigned long flags = 0;
 
         spin_lock_irqsave(&nlm_common_pic_lock, flags);
diff --git a/init/main.c b/init/main.c
index 1d493ff..5bdb0f6 100644
--- a/init/main.c
+++ b/init/main.c
@@ -805,11 +805,32 @@ static void run_init_process(const char *init_filename)
 	kernel_execve(init_filename, argv_init, envp_init);
 }
 
+static __inline__ void sched_bindto_save_affinity(int cpu, struct cpumask *mask)
+{
+	struct cpumask node0cpu0mask;
+
+	/* Save the current affinity mask */
+	sched_getaffinity(0, mask);
+
+	/* Force the process to run on the specified cpu */
+	cpumask_clear(&node0cpu0mask);
+	cpumask_set_cpu(cpu, &node0cpu0mask);
+
+	sched_setaffinity(0, &node0cpu0mask);
+}
+
+static __inline__ void sched_restore_affinity(struct cpumask *mask)
+{
+	sched_setaffinity(0, mask);
+}
+
 /* This is a non __init function. Force it to be noinline otherwise gcc
  * makes it inline to init() and it becomes part of init.text section
  */
 static noinline int init_post(void)
 {
+	struct cpumask cpumask;
+
 	/* need to finish all async __init code before freeing the memory */
 	async_synchronize_full();
 	free_initmem();
diff --git a/kernel/printk.c b/kernel/printk.c
index 61f3db1..9034467 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -1,3 +1,11 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems Inc. (¡°Netlogic¡±).
+This is a derived work from software originally provided by the external
+entity identified below. The licensing terms and warranties specified in
+the header of the original work apply to this derived work.
+
+*****************************#NETL_1#********************************/
+
 /*
  *  linux/kernel/printk.c
  *
@@ -898,15 +906,8 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 		printed_len = strlen(recursion_bug_msg);
 	}
 #ifdef CONFIG_NLMCOMMON_SMP_PREFIX
-    if ((smp_processor_id() & 0xff) > 9) {
-		sprintf(printk_buf+printed_len, "%2d:", 
-				(smp_processor_id() & 0xff));
-		printed_len += 3;
-    } else {
-		sprintf(printk_buf+printed_len, "%1d:", 
-				(smp_processor_id() & 0xff));
-		printed_len += 2;
-    }
+	sprintf(printk_buf+printed_len, "% 3d:", (smp_processor_id() & 0xff));
+	printed_len += 4;
 #endif
 
 	/* Emit the output into the temporary buffer */
-- 
1.7.10.4

