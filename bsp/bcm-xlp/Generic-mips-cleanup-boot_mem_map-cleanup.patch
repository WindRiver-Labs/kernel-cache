From ba193fa1b49008ba670148b3e8b300f2308935f1 Mon Sep 17 00:00:00 2001
From: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Date: Tue, 22 Jun 2010 14:08:51 +0530
Subject: [PATCH 098/761] Generic mips cleanup - boot_mem_map cleanup

Based on Broadcom SDK 2.3.

Signed-off-by: Krishnamurthy D V <kmurthy@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/bootinfo.h          |   39 +++++------------------------
 arch/mips/include/asm/netlogic/bootinfo.h |   25 ++++++++++++++++++
 arch/mips/netlogic/common/bootinfo.c      |   24 ++++++++++++++++++
 arch/mips/netlogic/xlp/bootinfo.c         |   16 ++++++------
 arch/mips/netlogic/xlr/setup.c            |   39 ++++++++++-------------------
 5 files changed, 77 insertions(+), 66 deletions(-)
 create mode 100644 arch/mips/netlogic/common/bootinfo.c

diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index a6823d9..84e411b 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -77,15 +77,7 @@ the header of the original work apply to this derived work.
 #define MACH_LEMOTE_ML2F7      3
 #define MACH_LEMOTE_YL2F89     4
 #define MACH_DEXXON_GDIUM2F10  5
-#define MACH_LEMOTE_NAS        6
-#define MACH_LEMOTE_LL2F       7
-#define MACH_LOONGSON_END      8
-
-/*
- * Valid machtype for group INGENIC
- */
-#define  MACH_INGENIC_JZ4730	0	/* JZ4730 SOC		*/
-#define  MACH_INGENIC_JZ4740	1	/* JZ4740 SOC		*/
+#define MACH_LOONGSON_END      6
 
 #ifdef CONFIG_NLM_COMMON
 #define CL_SIZE			(2048)
@@ -102,7 +94,6 @@ extern unsigned long mips_machtype;
 #define BOOT_MEM_RAM		1
 #define BOOT_MEM_ROM_DATA	2
 #define BOOT_MEM_RESERVED	3
-#define BOOT_MEM_INIT_RAM	4
 
 /*
  * A memory map that's built upon what was determined
@@ -111,10 +102,10 @@ extern unsigned long mips_machtype;
 struct boot_mem_map {
 	int nr_map;
 	struct boot_mem_map_entry {
-		uint64_t addr;	/* start of memory segment */
-		uint64_t size;	/* size of memory segment */
-		uint32_t type;		/* type of memory segment */
-	} map[BOOT_MEM_MAP_MAX + 1];
+		phys_t addr;	/* start of memory segment */
+		phys_t size;	/* size of memory segment */
+		long type;		/* type of memory segment */
+	} map[BOOT_MEM_MAP_MAX];
 };
 
 extern struct boot_mem_map boot_mem_map;
@@ -130,7 +121,7 @@ extern void free_init_pages(const char *what,
 /*
  * Initial kernel command line, usually setup by prom_init()
  */
-extern char arcs_cmdline[COMMAND_LINE_SIZE];
+extern char arcs_cmdline[CL_SIZE];
 
 /*
  * Registers a0, a1, a3 and a4 as passed to the kernel entry by firmware
@@ -142,22 +133,4 @@ extern unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
  */
 extern void plat_mem_setup(void);
 
-#ifdef CONFIG_SWIOTLB
-/*
- * Optional platform hook to call swiotlb_setup().
- */
-extern void plat_swiotlb_setup(void);
-
-#else
-
-static inline void plat_swiotlb_setup(void) {}
-
-#endif /* CONFIG_SWIOTLB */
-
-#define MAX_EXCLUDE 16
-struct boot_mem_map_exclude_region {
-	uint64_t start;
-	uint64_t end;
-};
-
 #endif /* _ASM_BOOTINFO_H */
diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
index 555476f..3b19097 100644
--- a/arch/mips/include/asm/netlogic/bootinfo.h
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -4,6 +4,25 @@
 #define LOADER_UBOOT   1
 #define LOADER_OTHER   2
 
+/* This is what netlboot passes and linux boot_mem_map is subtly different */
+struct nlm_boot_mem_map {
+	int nr_map;
+	struct nlm_boot_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;          /* type of memory segment */
+	} map[BOOT_MEM_MAP_MAX];
+};
+
+#define MAX_EXCLUDE 16
+struct boot_mem_map_exclude_region {
+	uint64_t start;
+	uint64_t end;
+};
+extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
+
+
+#ifdef CONFIG_NLM_XLP
 extern struct psb_info *prom_info;
 extern struct psb_info prom_info_copy;
 extern struct boot_mem_map prom_map;
@@ -14,6 +33,12 @@ extern int read_prominfo(void);
 extern int read_dram_info(void);
 extern int read_physaddr_map(void);
 
+#ifdef CONFIG_FDT
 extern int wakeup_secondary_cpus(void);
+#else
+extern int wakeup_secondary_cpus(void (*wakeup)(void *, void *, __u32), 
+		struct psb_info *prom_info);
+#endif
+#endif
 
 #endif
diff --git a/arch/mips/netlogic/common/bootinfo.c b/arch/mips/netlogic/common/bootinfo.c
new file mode 100644
index 0000000..c880180
--- /dev/null
+++ b/arch/mips/netlogic/common/bootinfo.c
@@ -0,0 +1,24 @@
+
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems Inc. (“Netlogic”).
+This is a derived work from software originally provided by the external
+entity identified below. The licensing terms and warranties specified in
+the header of the original work apply to this derived work.
+
+*****************************#NETL_1#********************************/
+
+#include <linux/kernel.h>
+#include <asm/bootinfo.h>
+#include <asm/netlogic/bootinfo.h>
+
+void copy_mem_map(struct boot_mem_map *dst, struct nlm_boot_mem_map *src)
+{
+	int i;
+
+	dst->nr_map = src->nr_map;
+	for(i=0; i < dst->nr_map; i++) {
+		dst->map[i].addr = (phys_t)src->map[i].addr;
+		dst->map[i].size = (phys_t)src->map[i].size;
+		dst->map[i].type = (long)src->map[i].type;
+	}
+}
diff --git a/arch/mips/netlogic/xlp/bootinfo.c b/arch/mips/netlogic/xlp/bootinfo.c
index 1e37d95..bf87715 100644
--- a/arch/mips/netlogic/xlp/bootinfo.c
+++ b/arch/mips/netlogic/xlp/bootinfo.c
@@ -55,36 +55,38 @@ int read_prominfo(void)
 	return is_valid_prominfo(prom_info);
 }
 
+/* TODO: Need to add right code here for XLP here */
 int read_dram_info(void)
 {
-	struct boot_mem_map *map;
+	struct nlm_boot_mem_map *map;
 
 	if (!prom_info || (!prom_info->psb_mem_map && !prom_info->avail_mem_map)) 
 		return -1;
 
 	/* copy the mem_map from bootloader */
 	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
-		map = (struct boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
+		map = (struct nlm_boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
 	else
-		map = (struct boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
+		map = (struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
 	
 	if (!(map->nr_map > 0 && map->nr_map <= 32))
 		return -1;
 
-	memcpy (&prom_map, map,	sizeof(struct boot_mem_map));
+	copy_mem_map(&prom_map, map);
 	
 	return 0;
 }
 
+/* TODO: Is this valid for XLP ? */
 int read_physaddr_map(void)
 {
-	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+	struct nlm_boot_mem_map *physaddr_map = (struct nlm_boot_mem_map *)
+		((unsigned long)prom_info->psb_physaddr_map);
 
 	if (physaddr_map == NULL)
 		return -1;
 
-	memcpy(&boot_physaddr_info,  physaddr_map, sizeof(struct boot_mem_map));
+	copy_mem_map(&boot_physaddr_info,  physaddr_map);
 
 	return 0;
 }
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index fc61b3e..49bd899 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -54,6 +54,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/nlm_common_loader.h>
 #include <user/netlogic/nlm_common_loader.h>
 #include <asm/netlogic/nlm_pcix_gen_dev.h>
+#include <asm/netlogic/bootinfo.h>
 #include <asm/netlogic/memory-exclusion.h>
 
 #include <linux/serial.h>
@@ -82,8 +83,6 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #define TRUE 					1
 #define FALSE 					0
 
-#define LOADER_UBOOT			1
-#define LOADER_OTHER			2
 
 #define GPIO_SWRESET_REG 		8
 
@@ -226,6 +225,8 @@ static struct physmap_info {
 	{ 0xff , "Unknown type" }
 };
 
+
+
 struct boot_mem_map boot_physaddr_info;
 
 /* Maintain in ascending order of 
@@ -1206,9 +1207,10 @@ void prom_update_exclude_region(void)
 struct boot_mem_map prom_map;
 int use_default_phymem = FALSE;
 
+
 void read_prom_memory(void)
 {
-	struct boot_mem_map *map;
+	struct nlm_boot_mem_map *map;
 
 	if (loader_used == LOADER_UBOOT)
 		goto set_default_mmap;
@@ -1221,14 +1223,14 @@ void read_prom_memory(void)
 
 	/* copy the mem_map from bootloader */
 	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
-		map = (struct boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
+		map = (struct nlm_boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
 	else
-		map = (struct boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
+		map = (struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
 	
 	if (!(map->nr_map > 0 && map->nr_map <= 32))
 		goto set_default_mmap;
 
-	memcpy (&prom_map, map,	sizeof(struct boot_mem_map));
+	copy_mem_map(&prom_map, map);
 	
 	return;
 
@@ -1316,8 +1318,8 @@ static void prom_add_memory(void)
 
 static void psb_print_physmap(void)
 {
-	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+	struct nlm_boot_mem_map *physaddr_map = (struct nlm_boot_mem_map *)
+				((unsigned long)prom_info->psb_physaddr_map);
 	char *name;
 	int i = 0;
 	int max;
@@ -1348,13 +1350,13 @@ static void psb_print_physmap(void)
 
 static void save_physaddr_info(void)
 {
-	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+	struct nlm_boot_mem_map *physaddr_map = 
+		(struct nlm_boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
 
 	if (physaddr_map == NULL)
 		return;
 
-	memcpy(&boot_physaddr_info,  physaddr_map, sizeof(struct boot_mem_map));
+	copy_mem_map(&boot_physaddr_info, physaddr_map);
 	return;
 }
 
@@ -1658,21 +1660,6 @@ void read_cp0_regs(void)
 		);
 }
 
-struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type)
-{
-	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
-
-	int i = 0;
-	int max = physaddr_map->nr_map;
-
-	for (i=0 ; i <max ; i++) {
-		if (physaddr_map->map[i].type == type)
-			return (physaddr_map->map);
-	}
-	return NULL;
-}
-
 void static add_region(struct boot_mem_map_exclude_region *x, int *k,
 		       uint64_t start, uint64_t end)
 {
-- 
1.7.10.4

