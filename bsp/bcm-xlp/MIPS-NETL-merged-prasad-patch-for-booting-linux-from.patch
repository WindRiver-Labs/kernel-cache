From a940185383849f2a865d594c7968cee9f0b4dc01 Mon Sep 17 00:00:00 2001
From: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Date: Thu, 4 Mar 2010 14:33:43 -0800
Subject: [PATCH 007/761] MIPS: NETL: merged prasad patch for booting linux
 from xen

Based on Broadcom SDK 2.3.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/bootinfo.h |    8 +-
 arch/mips/include/asm/rmi/sim.h  |    6 +-
 arch/mips/kernel/setup.c         |    5 +-
 arch/mips/rmi/Kconfig            |    4 +
 arch/mips/rmi/ptr/setup.c        |  233 +++++++++++++++++++++-----------------
 5 files changed, 144 insertions(+), 112 deletions(-)

diff --git a/arch/mips/include/asm/bootinfo.h b/arch/mips/include/asm/bootinfo.h
index 5f35b7f..0014011 100644
--- a/arch/mips/include/asm/bootinfo.h
+++ b/arch/mips/include/asm/bootinfo.h
@@ -118,7 +118,7 @@ struct boot_mem_map {
 		uint64_t addr;	/* start of memory segment */
 		uint64_t size;	/* size of memory segment */
 		uint32_t type;		/* type of memory segment */
-	} map[BOOT_MEM_MAP_MAX];
+	} map[BOOT_MEM_MAP_MAX + 1];
 };
 
 extern struct boot_mem_map boot_mem_map;
@@ -164,4 +164,10 @@ struct boot_mem_map_exclude_region {
 	uint64_t end;
 };
 
+#ifdef CONFIG_MIPS_XEN
+#define PROMDATA_HIDE(ptr, field) (((ptr)->field == 0) ? 0 : __va((unsigned long)(ptr)->field))
+#else
+#define PROMDATA_HIDE(ptr, field) ((unsigned long)(ptr)->field)
+#endif
+
 #endif /* _ASM_BOOTINFO_H */
diff --git a/arch/mips/include/asm/rmi/sim.h b/arch/mips/include/asm/rmi/sim.h
index e4bf509..8525341 100644
--- a/arch/mips/include/asm/rmi/sim.h
+++ b/arch/mips/include/asm/rmi/sim.h
@@ -76,9 +76,13 @@ struct psb_info {
 	uint64_t xlr_loaderip_config;
 	uint64_t bldr_envp;
 	uint64_t avail_mem_map;
+#ifdef CONFIG_MIPS_XEN
+ 	uint64_t argc;
+ 	uint64_t argv;
+ 	uint64_t envp;
+#endif
 };
 
-
 enum {
         PHOENIX_IO_SPACE = 0x10,
         PCIX_IO_SPACE,
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c9d013f..ae41808 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -339,7 +339,7 @@ static void __init bootmem_init(void)
 	 * of usable memory.
 	 */
 	reserved_end = max(init_initrd(),
-			   (unsigned long) PFN_UP(__pa_symbol(&_end)));
+			   (unsigned long) PFN_UP(__pa_symbol(&_end) + PAGE_SIZE));
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
@@ -604,9 +604,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	tweak_avail_dram_map();
 #endif
     
-/*
-	setup_mapped_kernel_tlbs(TRUE, TRUE);
-*/
 	bootmem_init();
 /*
 	setup_mapped_kernel_tlbs(FALSE, TRUE);
diff --git a/arch/mips/rmi/Kconfig b/arch/mips/rmi/Kconfig
index 37b2e80..1519964 100644
--- a/arch/mips/rmi/Kconfig
+++ b/arch/mips/rmi/Kconfig
@@ -197,3 +197,7 @@ config EXEC_INHIBIT
        depends on RMI_XLP
        default n
 
+config MIPS_XEN
+       bool "Enable Paravirtualization for Xen"
+       depends on RMI_XLP
+       default n
diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
index e687735..89b6829 100644
--- a/arch/mips/rmi/ptr/setup.c
+++ b/arch/mips/rmi/ptr/setup.c
@@ -67,6 +67,7 @@
 #include <linux/serial_core.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
+#include <asm/mach-rmi/mmu.h>
 
 #ifdef RMI_BRIDGE_WKAROUND
 #include <asm/rmi/rmi_rw_lock.h>
@@ -77,6 +78,10 @@ int rmi_enable_br_wrkaround = 0;
 EXPORT_SYMBOL(rmi_enable_br_wrkaround);
 #endif
 
+#ifdef CONFIG_MIPS_XEN
+#include <xen/interface/xen.h>
+#endif
+
 struct proc_dir_entry *rmi_root_proc;
 EXPORT_SYMBOL(rmi_root_proc);
 
@@ -186,36 +191,13 @@ static struct boot_mem_map_exclude_region dynamic_exclude_regions[] = {
 	[8] = {0, 0}, /* END of the list - MUST be the last entry always */
 };
 
-#if 0
-static void _early_print(const char *fmt, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
-{
-	if(prom_info && prom_info->uart_print){
-		((void (*)(const char *, int, int, int, int, int, int, int, int, int, int))(unsigned long)prom_info->uart_print)(fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
-	}
-}
-
-static void _rmi_early_print(const char *fmt)
-{
-	_early_print(fmt, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
-}
-
-void rmi_early_print(const char *func, int line)
-{
-	char buf[100] = {0};
-	sprintf(buf,"%s %d\n",func,line);
-	_rmi_early_print(buf);
-}
-#endif
-
 static char *get_psb_physmap_name(int type)
 {
 	int i = 0;
 	int tsize = sizeof(psb_physmap_info) / sizeof(struct physmap_info);
 
-	for( i = 0; i < tsize; i++ )
-	{
-		if( (psb_physmap_info[i].type == type ) ||
-		    (psb_physmap_info[i].type == 0xff ) )
+	for (i = 0; i < tsize; i++) {
+		if ((psb_physmap_info[i].type == type) || (psb_physmap_info[i].type == 0xff))
 			return psb_physmap_info[i].name;
 	}
 	return ("Unknown type");
@@ -262,13 +244,12 @@ int valid_mmap_phnx_addr_range(unsigned long pfn)
 	return 0;
 }
 
-static int sanity_check_prom_info(struct psb_info *info)
+static int is_valid_prominfo(struct psb_info *prom_info)
 {
-	if (!prom_info) return 0;
-  
-	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef) return 0;
-	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION) return 0;
-	//if (prom_info->size < sizeof(struct psb_info)) return 0;
+	if ((prom_info->magic_dword & 0xffffffffULL) != 0x900dbeef) 
+		return 0;
+	if ((prom_info->magic_dword >> 32) != PSB_INFO_VERSION) 
+		return 0;
 
 	return 1;
 }
@@ -586,8 +567,6 @@ void __init plat_mem_setup(void)
   
 	panic_timeout = 5;  
   
-	//board_be_handler = ptr_be_handler;
-  
 	_machine_restart   = (void (*)(char *))ptr_linux_exit;
 	_machine_halt      = ptr_linux_exit;
 	pm_power_off = ptr_linux_exit;
@@ -1112,14 +1091,22 @@ void read_prom_memory(void)
 	struct boot_mem_map *map;
 
 	/* sanity check prom_info and it's mem_map fields */
-	if (!prom_info || (!prom_info->psb_mem_map && !prom_info->avail_mem_map)) 
+#if 0
+	if (!prom_info || 
+		((!PROMDATA_HIDE(prom_info,psb_mem_map) && !PROMDATA_HIDE(prom_info,avail_mem_map))))
+#else
+	if (!prom_info || 
+		(!(prom_info->psb_mem_map) && !(prom_info->avail_mem_map)))
+#endif
 		goto use_default;
 
 	/* copy the mem_map from bootloader */
 	if (sizeof(*prom_info) <= prom_info->size && prom_info->avail_mem_map)
-		map = (struct boot_mem_map *) ((unsigned long)prom_info->avail_mem_map);	
+//		map = (struct boot_mem_map *)__va((unsigned long)prom_info->avail_mem_map);
+		map = (struct boot_mem_map *)PROMDATA_HIDE(prom_info,avail_mem_map);
 	else
-		map = (struct boot_mem_map *)((unsigned long)prom_info->psb_mem_map);
+//		map = (struct boot_mem_map *)PROMDATA_HIDE(prom_info,psb_mem_map);
+		map = (struct boot_mem_map *)prom_info->psb_mem_map;
 	
 	if (!(map->nr_map > 0 && map->nr_map <= 32))
 		goto use_default;
@@ -1211,7 +1198,8 @@ static void prom_add_memory(void)
 static void psb_print_physmap(void)
 {
 	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+		(struct boot_mem_map *)__va((unsigned long)prom_info->psb_physaddr_map);
+//		(struct boot_mem_map *)PROMDATA_HIDE(prom_info, psb_physaddr_map);
 	char *name;
 	int i = 0;
 	int max;
@@ -1238,7 +1226,8 @@ static void psb_print_physmap(void)
 static void save_physaddr_info(void)
 {
 	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+		(struct boot_mem_map *)__va((unsigned long)prom_info->psb_physaddr_map);
+//		(struct boot_mem_map *)PROMDATA_HIDE(prom_info, psb_physaddr_map);
 
 	if(physaddr_map == NULL)
 		return;
@@ -1293,7 +1282,7 @@ static void rmi_early_serial_setup(void)
 	s.iotype = UPIO_MEM;
 	/* registers are 4 bytes wide */
 	s.regshift = 2;
-	/* hardware int 4 - the serial int, is CPU int 6
+	/* hardware int 4 - the serial int, is CPU int 6	struct psb_info *t_prom_info;
 	 but poll for now */
 	s.irq =  PIC_UART_0_IRQ;
 	s.uartclk = UART_CLK;
@@ -1311,39 +1300,104 @@ static void rmi_early_serial_setup(void) {}
 #endif
 
 extern struct plat_smp_ops rmi_smp_ops;
+
+#ifdef CONFIG_MIPS_XEN
+int read_bootinfo(int *argc, char *n_argv[], char *n_envp[])
+{
+	char **argv, **envp;
+	void *xen_bootargs;
+	struct start_info *si;
+	int i;
+
+	xen_bootargs = __va((unsigned long) PFN_ALIGN(__pa_symbol(&_end)));
+	si = (struct start_info *)xen_bootargs;
+	prom_info = PTR_ALIGN((struct psb_info *)((unsigned long)si + sizeof(struct start_info)),
+						  sizeof(void *));
+	*argc = (int)prom_info->argc;
+//	argv = (char **)PROMDATA_HIDE(prom_info, argv);
+//	envp = (char **)PROMDATA_HIDE(prom_info, envp);
+	argv = (char **)__va((unsigned long)prom_info->argv);
+	envp = (char **)__va((unsigned long)prom_info->envp);
+
+	if (!dev_tree_en) {
+		char **t_argv = argv;
+
+		for (i = 0; i < *argc; i++, t_argv++)
+			n_argv[i] = *t_argv;
+		
+		if (envp != NULL) {
+			char **t_envp = envp;
+
+			for (i = 0; *t_envp; i++, t_envp++)
+				n_envp[i] = *t_envp;
+		}
+	}
+
+	return 0;
+}
+#else
+int read_bootinfo(int *argc, char *n_argv[], char *n_envp[])
+{
+	char **argv, **envp;
+	struct psb_info *t_prom_info;
+	long temp;
+	int i;
+
+	*argc = (int)fw_arg0;
+	temp = (int)fw_arg1; argv = (char **)temp;
+	temp = (int)fw_arg2; envp = (char **)temp;
+
+	/* initialise from rmi-kernel if booted with */
+	rmik_init(n_argv, argc, n_envp);
+
+	prom_info = &prom_info_copy;
+	if (rmik_en) {
+		t_prom_info = (struct psb_info *)rmi_boot_info;
+		t_prom_info->wakeup = PTR2U64(&rmik_wakeup_cpus);
+	} else {
+		temp = (int)fw_arg3;
+		t_prom_info = (struct psb_info *)temp;
+	}
+	memcpy((void *)prom_info, (void *)t_prom_info, sizeof(struct psb_info));
+
+	if (!dev_tree_en) {
+		int32_t *t_argv;
+		
+		t_argv = (int32_t *)argv;
+		for (i = 0; i < *argc; i++, t_argv++)
+			n_argv[i] = (char *)(unsigned long)(*t_argv);
+
+		if (envp != NULL) {
+			int32_t *t_envp;
+			t_envp = (int32_t *)envp;
+			for (i = 0; *t_envp; i++) {
+				n_envp[i] = (char *)(unsigned long)(*t_envp);
+				t_envp++;
+			}
+		}
+	}
+
+	return 0;
+}
+#endif
+
 /*
  * prom_init is called just after the cpu type is determined, from setup_arch()
  */
 void __init prom_init(void)
 {
-	int i=0;
-	int argc = (int)fw_arg0;
-	long temp ;
-	char **argv;
-	char **envp;
-	int t_argc = argc;
+	int i, argc;
 	char *n_argv[RMI_MAX_ARGS] = {NULL};
 	char *n_envp[RMI_MAX_ENVS] = {NULL};
-	struct psb_info *t_prom_info;
-
 	void (*wakeup)(void *, void *, __u32);
 	__u32 wakeup_mask;
 
-	temp = (int)fw_arg1;
-	argv = (char **)temp;
-
-	temp = (int)fw_arg2;
-	envp = (char **)temp;
+	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
-#if 0
-	mips_machgroup = MACH_GROUP_RMI;
-#endif
+	read_bootinfo(&argc, n_argv, n_envp);
 	
 	xlr_initialize_setups();
 
-	/* initialise from rmi-kernel if booted with */
-	rmik_init(n_argv, &argc, n_envp);
-
 	/* default mac addr */
 	phoenix_base_mac_addr[0] = 0x00;
 	phoenix_base_mac_addr[1] = 0x01;
@@ -1354,19 +1408,8 @@ void __init prom_init(void)
 
 	phoenix_psb_shm = 0;
   
-	prom_info = &prom_info_copy;
-	if(rmik_en) {
-		t_prom_info = (struct psb_info *)rmi_boot_info;
-		t_prom_info->wakeup = PTR2U64(&rmik_wakeup_cpus);
-	} else {
-		temp = (int)fw_arg3;
-		prom_info = &prom_info_copy;
-		t_prom_info = (struct psb_info *)temp;
-	}
-	memcpy((void *)prom_info, (void *)t_prom_info, sizeof(struct psb_info));
-
 #ifdef RMI_BRIDGE_WKAROUND
-	if(prom_info->global_shmem_size == GLOBAL_SHMEM_SIZE) {
+	if (prom_info->global_shmem_size == GLOBAL_SHMEM_SIZE) {
 		rmi_bridge_lock = 
 			(rmi_rwlock_t *)(unsigned long)
 			(prom_info->global_shmem_addr + BRIDGE_WKAROUND_AREA_OFFSET);
@@ -1375,32 +1418,7 @@ void __init prom_init(void)
 	}
 #endif
 
-	if(!dev_tree_en)
-	{
-		/* Get the right 64bit pointers from bootloader args */
-		{
-			int32_t *t_argv;
-
-			t_argv = (int32_t *)argv;
-			for(i=0; i < t_argc; i++, t_argv++) {
-				n_argv[i] = (char *)(unsigned long)(*t_argv);
-			}
-		}
-		argc = t_argc;
-
-		/* Get the right env pointers */
-		if(envp != NULL)
-		{
-			int32_t *t_envp;
-			t_envp = (int32_t *)envp;
-			for(i=0; *t_envp; i++) {
-				n_envp[i] = (char *)(unsigned long)(*t_envp);
-				t_envp++;
-			}
-		}
-	} /* devtree en */
-
-	if (!sanity_check_prom_info(prom_info)) {
+	if (!is_valid_prominfo(prom_info)) {
 		printk("Sanity Check failed on prom_info @ %p\n", prom_info);
 		if (prom_info) {
 			printk("sizeof(psb_info) = %d, psb_info_version = %x, "
@@ -1414,7 +1432,7 @@ void __init prom_init(void)
 	}
 
 	/*Copy Environment variable*/
-	if(prom_info->bldr_envp)
+	if (prom_info->bldr_envp)
 		memcpy(&xlr_bldr_env,
 		       (void *)(unsigned long)prom_info->bldr_envp,
 		       sizeof(xlr_bldr_env));
@@ -1461,7 +1479,8 @@ void __init prom_init(void)
 		if(wakeup != 0x0)
 			wakeup((void *)secondary_cpus_bootup_func, 0, wakeup_mask);
 	} else {
-		if(wakeup != 0x0) {
+		if (wakeup != 0x0) {
+			printk("wakeup = %p\n", wakeup);
 			wakeup((void *)secondary_cpus_bootup_func, 0, (__u32)prom_info->rmi_cpu_online_map & (~smp_boot.online_map));
 #if defined(CONFIG_RMI_XLP_SIM)
 			{
@@ -1481,9 +1500,9 @@ void __init prom_init(void)
 		}
 	}
 
- parse_args:
+parse_args:
 
-	for(i=1;i<argc;i++) {
+	for (i = 1; i < argc; i++) {
 		if (n_argv[i]) {
 			strcat(arcs_cmdline, n_argv[i]);
 			strcat(arcs_cmdline, " ");
@@ -1494,7 +1513,7 @@ void __init prom_init(void)
 	}
 	strcat(arcs_cmdline, " ");
 
-	if(rmik_en) {
+	if (rmik_en) {
 		fdt_add_console_string(arcs_cmdline);
 		disable_divec();
 	}
@@ -1517,8 +1536,9 @@ void __init prom_init(void)
 #endif
 	strcat(arcs_cmdline, " ");
 
-	for(i=0; n_envp[i];i++) {
-		if (strcmp(n_envp[i], "") == 0) break;
+	for (i = 0; n_envp[i]; i++) {
+		if (strcmp(n_envp[i], "") == 0) 
+			break;
 	}
 
 #ifdef DEBUG
@@ -1526,7 +1546,7 @@ void __init prom_init(void)
 	       phoenix_base_mac_addr[0], phoenix_base_mac_addr[1], phoenix_base_mac_addr[2],
 	       phoenix_base_mac_addr[3], phoenix_base_mac_addr[4], phoenix_base_mac_addr[5]);
 #endif
-	if(hybrid_str != NULL)
+	if (hybrid_str != NULL)
 		xlr_hybrid_setup(hybrid_str);
 
 	config_net_init();
@@ -1538,7 +1558,7 @@ void __init prom_init(void)
 	/* setup early serial port driver */
 	rmi_early_serial_setup();
 
-    	register_smp_ops(&rmi_smp_ops);
+	register_smp_ops(&rmi_smp_ops);
 }
 
 void prom_free_prom_memory(void)
@@ -1564,7 +1584,8 @@ void read_cp0_regs(void)
 struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type)
 {
 	struct boot_mem_map *physaddr_map = 
-		(struct boot_mem_map *)((unsigned long)prom_info->psb_physaddr_map);
+//		(struct boot_mem_map *)__va((unsigned long)prom_info->psb_physaddr_map);
+		(struct boot_mem_map *)PROMDATA_HIDE(prom_info, psb_physaddr_map);
 
 	int i = 0;
 	int max = physaddr_map->nr_map;
-- 
1.7.10.4

