From eca83e92f8fd8c0c4a51c746fb2ecb2f57737e59 Mon Sep 17 00:00:00 2001
From: henry shao <hshao@netlogicmicro.com>
Date: Wed, 15 Sep 2010 14:21:34 -0700
Subject: [PATCH 183/761] 1. get rid of chip_is_xls from xlp/setup.c 2. reorg
 kernel/cpu_probe.c by move get_xlr(p)_proc_name
 get_xlr(p)_revision function into respective
 xlp/setup.c xlr/setup.c file. 3. Remove unused enum
 from xlp.h 4. change sim.h and xlp.h to help
 achieve 2

Based on Broadcom SDK 2.3.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/sim.h |    6 ++
 arch/mips/include/asm/netlogic/xlp.h |   33 +++++---
 arch/mips/netlogic/xlp/setup.c       |   55 +++++++++---
 arch/mips/netlogic/xlr/setup.c       |  154 ++++++++++++++++++++++++++++++++++
 drivers/usb/host/ehci-hcd.c          |    8 +-
 5 files changed, 230 insertions(+), 26 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
index a1faee6..8f2f1df 100644
--- a/arch/mips/include/asm/netlogic/sim.h
+++ b/arch/mips/include/asm/netlogic/sim.h
@@ -29,6 +29,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/types.h>
 #include <asm/cpu.h>
 #include <asm/mipsregs.h>
+
+#define MAX_CPU_REV_LEN	 100
 #define PSB_INFO_VERSION 0x0001
 
 struct psb_info {
@@ -73,6 +75,7 @@ struct psb_info {
 	uint64_t avail_mem_map;
 };
 
+
 enum {
         NETLOGIC_IO_SPACE = 0x10,
         PCIX_IO_SPACE,
@@ -440,4 +443,7 @@ static __inline__ int is_xls_b0(void)
 #define NLM_MAX_ARGS 32
 #define NLM_MAX_ENVS 32
 
+extern char cpu_model_info[MAX_CPU_REV_LEN];
+extern char* get_cpu_info(void);
+
 #endif /* _ASM_SIM_H */
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index 1442c5a..f628e5d 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -30,17 +30,20 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/cpu.h>
 #include <asm/mipsregs.h>
 
-enum {
-        NETLOGIC_IO_SPACE = 0x10,
-        PCIX_IO_SPACE,
-        PCIX_CFG_SPACE,
-        PCIX_MEMORY_SPACE,
-        HT_IO_SPACE,
-        HT_CFG_SPACE,
-        HT_MEMORY_SPACE,
-        SRAM_SPACE,
-        FLASH_CONTROLLER_SPACE
-};
+#if defined(CONFIG_NLM_XLP)
+/* Fake Values for bring-up */
+#define CHIP_PROCESSOR_ID_XLP_A_832   0x00
+#define CHIP_PROCESSOR_ID_XLR_C_732   0xff
+#else
+/* Real Values */
+#define CHIP_PROCESSOR_ID_XLP_A_832   0x90
+#define CHIP_PROCESSOR_ID_XLR_C_732   0x00
+#endif
+
+#define XLP_REVISION_A0 		0xc0010
+#define MAX_REG_ENTRY           12
+#define MAX_UCORE_ENTRY		128
+#define MAX_CPU_REV_LEN		100
 
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
@@ -61,4 +64,12 @@ struct node_mask{
 	uint32_t onlinemask[4];
 };
 
+typedef struct nae_port {
+        uint8_t num_free_desc;
+        uint32_t nae_regs[MAX_REG_ENTRY];
+        uint32_t gmac_regs[MAX_REG_ENTRY];
+} NAE_PORT_T;
+
+extern char cpu_model_info[MAX_CPU_REV_LEN];
+extern char* get_cpu_info(void);
 #endif /*_ASM_XLP_H */ 
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 432a95a..ef60f97 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -63,6 +63,7 @@
 
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
 
 #include "../boot/ops.h"
 
@@ -80,7 +81,6 @@
 
 #define BOOT_LOADER_REGION_SZ 			0x04000000
 #define LOADER_KSEG_END 			0x10000000
-
 /* used by the default memory map
  */
 #define DEF_PHYMEM_START_ADDR 			0x100000
@@ -89,6 +89,8 @@
 static unsigned int xlp_uart_portid = 0;
 unsigned long nlm_common_ebase = 0x0;
 
+#define PROCESSOR_ID_MAX_LEN 			6
+char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
 static char prop_buf[MAX_PROP_LEN];
 extern char _end;
 extern void *fdt;
@@ -124,13 +126,7 @@ spinlock_t atomic_lock = SPIN_LOCK_UNLOCKED;
 
 __u8 nlm_common_base_mac_addr[6];
 
-int chip_is_xls = 0;
-int chip_is_xls_b0 = 0;
-
 int hwemul = 0;
-
-EXPORT_SYMBOL(chip_is_xls);
-EXPORT_SYMBOL(chip_is_xls_b0);
 EXPORT_SYMBOL(hwemul);
 
 void *nlm_common_psb_shm = 0;
@@ -146,6 +142,7 @@ extern struct node_mask smp_node;
 
 int nlm_common_get_pgprot(unsigned long address)
 {
+
 	return 1;
 }
 struct boot_mem_map boot_physaddr_info;
@@ -483,19 +480,55 @@ static int fdt_process(void)
 	sprintf(domstr, "/doms/dom@%d/uart", domain);
 	node = finddevice(domstr);
 	if(node){
-		if(getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid))
-				< 0){
+		if(getprop(node, "id", &xlp_uart_portid, sizeof(xlp_uart_portid)) < 0){
 			return -1;
 		}
 	}
+
 	return 0;
 }
 
+static int get_xlp_proc_name(void )
+{
+        strcpy(cpu_model_info,"XLP832");
+        return 0;
+}
+
+static int get_xlp_revision(void )
+{
+        int revision = read_c0_prid() & 0xff00ff;
+        switch( revision ) {
+        case XLP_REVISION_A0:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev A0");
+                break;
+        default:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev ??");
+                return -1;
+        }
+        return 0;
+}
+
+char* get_cpu_info(void)
+{
+	get_xlp_proc_name();
+	get_xlp_revision();
+	
+	return cpu_model_info;
+}
+
+#ifdef CONFIG_XEN
+extern void xen_init(void);
+#else
+static void xen_init(void) {}
+#endif
+
 void __init prom_init(void)
 {
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	fdt_process();
+	
+	xen_init();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
 
@@ -554,7 +587,7 @@ void nlm_early_printk(const char *fmt, ...)
 #ifdef CONFIG_EARLY_PRINTK
 static void NS16550_putc(char c)
 {
-        nlm_reg_t *mmio;
+	nlm_reg_t *mmio;
 	switch(xlp_uart_portid){
 		default:
 		case 0:
@@ -564,7 +597,7 @@ static void NS16550_putc(char c)
 			mmio = netlogic_io_mmio(NETLOGIC_IO_UART_1_OFFSET);
 			break;
 	}
-        while (netlogic_read_reg( mmio, 0x5) == 0);
+	while (netlogic_read_reg( mmio, 0x5) == 0);
 		netlogic_write_reg( mmio, 0x0, c);
 }
 
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 6b1d069..d3ac686 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -102,6 +102,9 @@ EXPORT_SYMBOL(nlm_enable_br_wrkaround);
 #define DEF_PHYMEM_START_ADDR 	0x100000
 #define DEF_PHYMEM_SIZE 		0x0ff00000
 
+char cpu_model_info[100]={'X','L','R'};
+#define PROCESSOR_ID_MAX_LEN 		6
+
 extern char _end;
 
 /* by default, do not assume u-boot */
@@ -1368,3 +1371,154 @@ static int __init nlm_proc_setup(void)
 }
 rootfs_initcall(nlm_proc_setup);
 
+static int get_xls_proc_name(void)
+{
+        int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+        switch ( processor_id ) {
+        case CHIP_PROCESSOR_ID_XLS_608:
+        case CHIP_PROCESSOR_ID_XLS_608_B0:
+                strcpy(cpu_model_info,"XLS608");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_408:
+        case CHIP_PROCESSOR_ID_XLS_408_B0:
+                strcpy(cpu_model_info,"XLS408");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_404:
+        case CHIP_PROCESSOR_ID_XLS_404_B0:
+                strcpy(cpu_model_info,"XLS404");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_208:
+                strcpy(cpu_model_info,"XLS208");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_204:
+                strcpy(cpu_model_info,"XLS204");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_616_B0:
+                strcpy(cpu_model_info,"XLS616");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_416_B0:
+                strcpy(cpu_model_info,"XLS416");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_412_B0:
+                strcpy(cpu_model_info,"XLS412");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_108:
+                strcpy(cpu_model_info,"XLS108");
+                break;
+        case CHIP_PROCESSOR_ID_XLS_104:
+                strcpy(cpu_model_info,"XLS104");
+                break;
+        default:
+                strcpy(cpu_model_info,"XLS???");
+                return -1;
+        }
+        return 0;
+}
+
+static int get_xlr_proc_name(void )
+{
+        int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+        if ( xlr_revision_c()) {
+                switch ( processor_id ) {
+                case CHIP_PROCESSOR_ID_XLR_C_308:
+                        strcpy(cpu_model_info,"XLR308");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_C_508:
+                        strcpy(cpu_model_info,"XLR508");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_C_516:
+                        strcpy(cpu_model_info,"XLR516");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_C_532:
+                        strcpy(cpu_model_info,"XLR532");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_C_716:
+                        strcpy(cpu_model_info,"XLR716");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_C_732:
+                        strcpy(cpu_model_info,"XLR732");
+                        break;
+                default:
+                        strcpy(cpu_model_info,"XLR???");
+                        return -1;
+                }
+        } else {
+                switch ( processor_id ) {
+                case CHIP_PROCESSOR_ID_XLR_B_308:
+                        strcpy(cpu_model_info,"XLR308");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_B_508:
+                        strcpy(cpu_model_info,"XLR508");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_B_516:
+                        strcpy(cpu_model_info,"XLR516");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_B_532:
+                        strcpy(cpu_model_info,"XLR532");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_B_716:
+                        strcpy(cpu_model_info,"XLR716");
+                        break;
+                case CHIP_PROCESSOR_ID_XLR_B_732:
+                        strcpy(cpu_model_info,"XLR732");
+                        break;
+                default:
+                        strcpy(cpu_model_info,"XLR???");
+                        return -1;
+                }
+        }
+        return 0;
+}
+
+static int get_xlr_revision(void )
+{
+        int revision =  xlr_revision();
+        switch( revision ) {
+        case XLR_REVISION_A0:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev A0");
+                break;
+        case XLR_REVISION_A1:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev A1");
+                break;
+        case XLR_REVISION_B0:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev B0");
+                break;
+        case XLR_REVISION_B1:
+                strcpy(cpu_model_info+ PROCESSOR_ID_MAX_LEN," Rev B1");
+                break;
+        case XLR_REVISION_B2:
+                strcpy(cpu_model_info+ PROCESSOR_ID_MAX_LEN," Rev B2");
+                break;
+        case XLR_REVISION_C0:
+                strcpy(cpu_model_info + PROCESSOR_ID_MAX_LEN," Rev C0");
+                break;
+        case XLR_REVISION_C1:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev C1");
+                break;
+        case XLR_REVISION_C2:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev C2");
+                break;
+        case XLR_REVISION_C3:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev C3");
+                break;
+        case XLR_REVISION_C4:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev C4");
+                break;
+        default:
+                strcpy(cpu_model_info+PROCESSOR_ID_MAX_LEN," Rev ??");
+                return -1;
+        }
+        return 0;
+}
+
+char* get_cpu_info()
+{
+                if (is_xls())
+                        get_xls_proc_name();
+                else
+                        get_xlr_proc_name();
+
+                get_xlr_revision();
+
+		return cpu_model_info;
+}
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5303e40..78c1a6b 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -59,7 +59,7 @@ the header of the original work apply to this derived work.
 #include <asm/firmware.h>
 #endif
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 #include <asm/netlogic/sim.h>
 #endif
 
@@ -1327,7 +1327,7 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
 #endif
 
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
 #include "ehci-xls.c"
 #define  PLATFORM_DRIVER      ehci_xls_driver
 #endif
@@ -1446,7 +1446,7 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
     /* On the XLS, use the internal USB Controller */
     if (is_xls())
 #endif
@@ -1520,7 +1520,7 @@ static void __exit ehci_hcd_cleanup(void)
 	platform_driver_unregister(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
-#ifdef CONFIG_NLM_COMMON
+#ifdef CONFIG_NLM_XLR
     /* On the XLS, use the internal USB Controller */
     if (is_xls())
 #endif 
-- 
1.7.10.4

