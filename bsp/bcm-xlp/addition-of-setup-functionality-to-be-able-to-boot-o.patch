From 72ef26b4d230028f20bf81067dcbe57dda09c0d4 Mon Sep 17 00:00:00 2001
From: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Date: Thu, 13 May 2010 12:30:40 -0700
Subject: [PATCH 019/761] addition of setup functionality to be able to boot
 on Xen

Based on Broadcom SDK 2.3.

Signed-off-by: Prasad Boddupalli <pboddupalli@netlogicmicro.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/sim.h |    1 -
 arch/mips/kernel/setup.c             |    5 ++
 arch/mips/netlogic/xlp/Makefile      |    7 ++-
 arch/mips/netlogic/xlp/xenbootinfo.c |   91 ++++++++++++++++++++++++++++++++++
 4 files changed, 101 insertions(+), 3 deletions(-)
 create mode 100644 arch/mips/netlogic/xlp/xenbootinfo.c

diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
index 9a75b1b..8b44a14 100644
--- a/arch/mips/include/asm/netlogic/sim.h
+++ b/arch/mips/include/asm/netlogic/sim.h
@@ -73,7 +73,6 @@ struct psb_info {
 	uint64_t avail_mem_map;
 };
 
-
 enum {
         NETLOGIC_IO_SPACE = 0x10,
         PCIX_IO_SPACE,
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5c721c7..bd09542 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -286,8 +286,13 @@ static void __init bootmem_init(void)
 	 * not selected. Once that done we can determine the low bound
 	 * of usable memory.
 	 */
+#ifdef CONFIG_MIPS_XEN
 	reserved_end = max(init_initrd(),
 			   (unsigned long) PFN_UP(__pa_symbol(&_end) + PAGE_SIZE));
+#else
+	reserved_end = max(init_initrd(),
+			   (unsigned long) PFN_UP(__pa_symbol(&_end)));
+#endif
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index f7133cd..cddac1d 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -10,6 +10,9 @@ obj-y += irq.o time.o on_chip.o mmu.o
 obj-$(CONFIG_NLM_XLP) += platform-xlp.o
 obj-$(CONFIG_SMP)      += smp.o smpboot.o
 obj-$(CONFIG_KGDB)      += nmi.o
-obj-y += bootinfo.o
-
 
+ifeq ($(CONFIG_MIPS_XEN),y)
+obj-y += xenbootinfo.o
+else
+obj-y += bootinfo.o
+endif
diff --git a/arch/mips/netlogic/xlp/xenbootinfo.c b/arch/mips/netlogic/xlp/xenbootinfo.c
new file mode 100644
index 0000000..6091cbb
--- /dev/null
+++ b/arch/mips/netlogic/xlp/xenbootinfo.c
@@ -0,0 +1,91 @@
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/pfn.h>
+
+#include <asm/page.h>
+#include <asm/bootinfo.h>
+#include <asm/netlogic/sim.h>
+#include <asm/netlogic/bootinfo.h>
+#include <xen/interface/xen.h>
+
+#define XEN_PAGE_SIZE (64 << 10)
+
+static unsigned long memmap_start;
+extern char _end[];
+
+static int deserialize_strings(char **dst, char *src)
+{
+	int narg, i;
+	char *_src = src;
+        
+	memcpy(&narg, src, sizeof(int)); 
+	src += sizeof(int);
+	for (i = 0; i < narg; ++i) {
+		dst[i] = src;
+		src += strlen(src) + 1;
+	}
+	dst[i] = (void *)0;
+
+	return (src - _src);
+}
+
+int read_cmdline_args(int *argc, char *g_argv[], char *g_envp[])
+{
+	unsigned long dst;
+
+	dst = (unsigned long)__va((unsigned long) PFN_ALIGN(__pa_symbol(&_end)));
+
+	/*
+	 * skip xen start_info page and prom_info structures
+	 */
+	dst += ALIGN(sizeof(struct start_info), sizeof(void *));
+	dst += ALIGN(sizeof(struct psb_info), sizeof(void *));
+
+	memcpy((void *)argc, (void *)dst, sizeof(int));
+
+	printk("dst = 0x%lx\n", dst);
+
+	dst += ALIGN(sizeof(int), sizeof(void *));
+	dst += ALIGN(deserialize_strings(g_argv, (char *)dst), sizeof(void *));
+	dst += ALIGN(deserialize_strings(g_envp, (char *)dst), sizeof(void *));
+
+	memmap_start = dst;
+
+	return 0;
+}
+
+int read_prominfo(void)
+{
+	struct start_info *si;
+	unsigned long dst;
+
+	dst = (unsigned long)__va((unsigned long) PFN_ALIGN(__pa_symbol(&_end)));
+
+	si = (struct start_info *)dst;
+	dst += ALIGN(sizeof(struct start_info), sizeof(void *));
+
+	prom_info = (struct psb_info *)dst;
+
+	/*
+	 * FIXME: we do not check the validity of start_info 
+	 *        page and prom_info structure.
+	 */
+	return 0;
+}
+
+int read_dram_info(void)
+{
+	memcpy ((void *)&prom_map, (void *)memmap_start, sizeof(struct boot_mem_map));
+	memmap_start += sizeof(struct boot_mem_map);
+
+	return 0;
+}
+
+int read_physaddr_map(void)
+{
+	memcpy(&boot_physaddr_info, (void *)memmap_start, sizeof(struct boot_mem_map));
+	memmap_start += sizeof(struct boot_mem_map);
+
+	return 0;
+}
-- 
1.7.10.4

