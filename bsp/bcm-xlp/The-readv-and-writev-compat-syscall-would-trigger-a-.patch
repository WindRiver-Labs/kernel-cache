From 4bb5a95566f79dea90c839d3f8b02f2f478c2664 Mon Sep 17 00:00:00 2001
From: Guojian Zhou <guojian.zhou@windriver.com>
Date: Fri, 3 Jan 2014 14:35:59 +0800
Subject: [PATCH] The readv and writev compat syscall would trigger a -EFAULT
 error.

commit 8aec0f5d4137 [Fix: compat_rw_copy_check_uvector() misuse in aio, readv, writev, and security keys]
adds a access_ok() check in compat_rw_copy_check_uvector().

commit 72ec35163f9f [Fix: switch compat readv/writev variants to COMPAT_SYSCALL_DEFINE]
adds a access_ok() check in compat_do_readv_writev() before calling compat_rw_copy_check_uvector().
And it would trigger a -EFAULT error in the compat code.

According to the linux programmer's manual, the readv() system call should return -EINVAL
when the vector count iovcnt is less than zero. The compat_rw_copy_check_uvector() would do
these arguments check and return the appropriate errno.
If calling access_ok() before compat_rw_copy_check_uvector(), access_ok() would return failed
when the nr_segs(iovcnt) is less than zero, then it would return the -EFAULT directly. So the
compat syscall readv and writev would return the unexpected errno.

Remove the access_ok() check in the compat_do_readv_writev() to fix this issue.

Signed-off-by: Guojian Zhou <guojian.zhou@windriver.com>
---
 fs/read_write.c |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/fs/read_write.c b/fs/read_write.c
index 2cefa41..ab47b13 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -880,10 +880,6 @@ static ssize_t compat_do_readv_writev(int type, struct file *file,
 	if (!file->f_op)
 		goto out;
 
-	ret = -EFAULT;
-	if (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))
-		goto out;
-
 	ret = compat_rw_copy_check_uvector(type, uvector, nr_segs,
 					       UIO_FASTIOV, iovstack, &iov);
 	if (ret <= 0)
-- 
1.7.5.4

