From faf6e0608366f8cfd5f70474b3ff528b257f8b73 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 17:56:49 +0800
Subject: [PATCH 37/58] bcm-xlp2: add the soc interface

Get from SDK_DIR/linux-userspace/kmod/soc_interface

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/netlogic/soc_interface/Makefile         |    7 +
 drivers/netlogic/soc_interface/cpu_proc.c       |   11 +
 drivers/netlogic/soc_interface/libfdt-wrapper.c |  230 ++++
 drivers/netlogic/soc_interface/nlm_cpumask.h    |   59 +
 drivers/netlogic/soc_interface/nlm_debug.h      |  119 ++
 drivers/netlogic/soc_interface/on_chip.c        | 1552 +++++++++++++++++++++++
 drivers/netlogic/soc_interface/ops.h            |  265 ++++
 7 files changed, 2243 insertions(+)

diff --git a/drivers/netlogic/soc_interface/Makefile b/drivers/netlogic/soc_interface/Makefile
new file mode 100644
index 0000000..30c01b0
--- /dev/null
+++ b/drivers/netlogic/soc_interface/Makefile
@@ -0,0 +1,7 @@
+EXTRA_CFLAGS := -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/syslib/include
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/fmnlib
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt
+
+obj-$(CONFIG_NLM_XLP_BOARD) += soc_interface.o
+soc_interface-objs += on_chip.o cpu_proc.o libfdt-wrapper.o
diff --git a/drivers/netlogic/soc_interface/cpu_proc.c b/drivers/netlogic/soc_interface/cpu_proc.c
new file mode 100644
index 0000000..c4c0a46
--- /dev/null
+++ b/drivers/netlogic/soc_interface/cpu_proc.c
@@ -0,0 +1,11 @@
+#include <linux/kernel.h>
+
+void nlm_cpu_stat_update_msgring_pic_int(void)
+{
+}
+void nlm_cpu_stat_update_msgring_cycles(__u32 cycles)
+{
+}
+void nlm_cpu_stat_update_msgring_int(void)
+{
+}
diff --git a/drivers/netlogic/soc_interface/libfdt-wrapper.c b/drivers/netlogic/soc_interface/libfdt-wrapper.c
new file mode 100644
index 0000000..0716db0
--- /dev/null
+++ b/drivers/netlogic/soc_interface/libfdt-wrapper.c
@@ -0,0 +1,230 @@
+/*
+ * This file does the necessary interface mapping between the bootwrapper
+ * device tree operations and the interface provided by shared source
+ * files flatdevicetree.[ch].
+ *
+ * Copyright 2007 David Gibson, IBM Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <stddef.h>
+#include <libfdt.h>
+#include "ops.h"
+
+#if 0
+(BAD_ERROR(err) || ((err < 0) && DEBUG)) 
+	printf("%s():%d  %s\n\r", __func__, __LINE__, fdt_strerror(err)); 
+#endif
+
+#define min(x,y) ({ \
+		typeof(x) _x = (x); \
+		typeof(y) _y = (y); \
+		(void) (&_x == &_y);    \
+		_x < _y ? _x : _y; })
+
+
+#define DEBUG	0
+#define BAD_ERROR(err)	(((err) < 0) \
+			 && ((err) != -FDT_ERR_NOTFOUND) \
+			 && ((err) != -FDT_ERR_EXISTS))
+
+#define check_err(err) \
+	({ \
+		if (BAD_ERROR(err)) \
+			exit(); \
+		(err < 0) ? -1 : 0; \
+	})
+
+#define offset_devp(off)	\
+	({ \
+		int _offset = (off); \
+		check_err(_offset) ? NULL : (void *)(unsigned long)(_offset+1); \
+	})
+
+#define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
+#define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
+
+void *fdt;
+#if 0
+static void *buf; /* = NULL */
+#endif
+
+#define EXPAND_GRANULARITY	1024
+
+struct platform_ops platform_ops;
+struct dt_ops dt_ops;
+
+
+static void expand_buf(int minexpand)
+{
+#if 0
+	int size = fdt_totalsize(fdt);
+	int rc;
+
+	size = _ALIGN(size + minexpand, EXPAND_GRANULARITY);
+	buf = platform_ops.realloc(buf, size);
+	rc = fdt_open_into(fdt, buf, size);
+	fdt = buf;
+#endif
+}
+
+static void *fdt_wrapper_finddevice(const char *path)
+{
+	return offset_devp(fdt_path_offset(fdt, path));
+}
+
+static int fdt_wrapper_getprop(const void *devp, const char *name,
+			       void *buf, const int buflen)
+{
+	const void *p;
+	int len;
+
+	p = fdt_getprop(fdt, devp_offset(devp), name, &len);
+	if (!p)
+		return check_err(len);
+	memcpy(buf, p, min(len, buflen));
+	return len;
+}
+
+static int fdt_wrapper_setprop(const void *devp, const char *name,
+			       const void *buf, const int len)
+{
+	int rc;
+
+	rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	if (rc == -FDT_ERR_NOSPACE) {
+		expand_buf(len + 16);
+		rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	}
+
+	return check_err(rc);
+}
+
+static int fdt_wrapper_del_node(const void *devp)
+{
+	return fdt_del_node(fdt, devp_offset(devp));
+}
+
+static void *fdt_wrapper_get_parent(const void *devp)
+{
+	return offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));
+}
+
+static void *fdt_wrapper_create_node(const void *devp, const char *name)
+{
+	int offset;
+
+	offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	if (offset == -FDT_ERR_NOSPACE) {
+		expand_buf(strlen(name) + 16);
+		offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	}
+
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_prop_value(const void *prev,
+						 const char *name,
+						 const char *val,
+						 int len)
+{
+	int offset = fdt_node_offset_by_prop_value(fdt, devp_offset_find(prev),
+	                                           name, val, len);
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_compatible(const void *prev,
+						 const char *val)
+{
+	int offset = fdt_node_offset_by_compatible(fdt, devp_offset_find(prev),
+	                                           val);
+	return offset_devp(offset);
+}
+
+static char *fdt_wrapper_get_path(const void *devp, char *buf, int len)
+{
+	int rc;
+
+	rc = fdt_get_path(fdt, devp_offset(devp), buf, len);
+	if (check_err(rc))
+		return NULL;
+	return buf;
+}
+
+static unsigned long fdt_wrapper_finalize(void)
+{
+	int rc;
+
+	rc = fdt_pack(fdt);
+#if 0
+	if (rc != 0)
+		fatal("Couldn't pack flat tree: %s\n\r",
+		      fdt_strerror(rc));
+#endif
+	return (unsigned long)fdt;
+}
+
+static int fdt_wrapper_check_header(void)
+{
+	int err;
+
+	if ((err = fdt_check_header(fdt)) != 0)
+		return err;
+
+	return 0;
+}
+
+void *fdt_init(void *blob)
+{
+	dt_ops.finddevice = fdt_wrapper_finddevice;
+	dt_ops.getprop = fdt_wrapper_getprop;
+	dt_ops.setprop = fdt_wrapper_setprop;
+	dt_ops.get_parent = fdt_wrapper_get_parent;
+	dt_ops.create_node = fdt_wrapper_create_node;
+	dt_ops.find_node_by_prop_value = fdt_wrapper_find_node_by_prop_value;
+	dt_ops.find_node_by_compatible = fdt_wrapper_find_node_by_compatible;
+	dt_ops.del_node = fdt_wrapper_del_node;
+	dt_ops.get_path = fdt_wrapper_get_path;
+	dt_ops.finalize = fdt_wrapper_finalize;
+	dt_ops.check_header = fdt_wrapper_check_header;
+
+	/* Make sure the dt blob is the right version and so forth */
+	fdt = blob;
+
+	/* Don't use local copy as Kernel claims this memory after mem init
+	 * As a result, FDT can not be parsed in kernel modules
+	 */
+#ifdef USE_LOCAL_FDT_COPY
+	{
+		int err;
+		int bufsize;
+
+		bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
+		buf = malloc(bufsize);
+		//if(!buf)
+		//	fatal("malloc failed. can't relocate the device tree\n\r");
+
+		err = fdt_open_into(fdt, buf, bufsize);
+
+		//if (err != 0)
+		//	fatal("fdt_init(): %s\n\r", fdt_strerror(err));
+
+		fdt = buf;
+	}
+#endif
+	return fdt;
+}
diff --git a/drivers/netlogic/soc_interface/nlm_cpumask.h b/drivers/netlogic/soc_interface/nlm_cpumask.h
new file mode 100644
index 0000000..e6b542f
--- /dev/null
+++ b/drivers/netlogic/soc_interface/nlm_cpumask.h
@@ -0,0 +1,59 @@
+#ifndef CONFIG_CPU_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
+#ifndef _ASM_NETLOGIC_CPUMASK_H
+#define _ASM_NETLOGIC_CPUMASK_H
+
+#include <linux/cpumask.h>
+#include <linux/sched.h>
+
+#define CPUMASK_BUF 256
+
+static __inline__ unsigned int cpumask_to_uint32(cpumask_t *cpumask)
+{
+	unsigned int mask = 0;
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (cpumask_test_cpu(i, cpumask)) {
+			mask |= (1 << i);
+		}
+	}
+	return mask;
+}
+
+static __inline__ void uint32_to_cpumask(cpumask_t *cpumask, unsigned int mask)
+{
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (mask & (1 << i)) {
+			cpumask_set_cpu(i, cpumask);
+		}
+		else {
+			cpumask_clear_cpu(i, cpumask);
+		}
+	}
+}
+
+static __inline__ void sched_bindto_save_affinity(int cpu, struct cpumask *mask)
+{
+	struct cpumask node0cpu0mask;
+
+	/* Save the current affinity mask */
+	sched_getaffinity(0, mask);
+
+	/* Force the process to run on the specified cpu */
+	cpumask_clear(&node0cpu0mask);
+	cpumask_set_cpu(cpu, &node0cpu0mask);
+
+	sched_setaffinity(0, &node0cpu0mask);
+}
+
+static __inline__ void sched_bindto_restore_affinity(struct cpumask *mask)
+{
+	sched_setaffinity(0, mask);
+}
+
+
+#endif /* _ASM_NETLOGIC_CPUMASK_H */
diff --git a/drivers/netlogic/soc_interface/nlm_debug.h b/drivers/netlogic/soc_interface/nlm_debug.h
new file mode 100644
index 0000000..6acdd4a
--- /dev/null
+++ b/drivers/netlogic/soc_interface/nlm_debug.h
@@ -0,0 +1,119 @@
+#ifndef CONFIG_CPU_XLP /* temporary tripwire */
+#error "Should only be used by XLP"
+#endif
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ASM_NLM_DEBUG_H
+#define _ASM_NLM_DEBUG_H
+
+/*Enable below macro to enable net stats. */
+//#define CONFIG_NLM_STATS
+extern void prom_printf(char *fmt, ...);
+#include <linux/threads.h>
+#include <asm/atomic.h>
+
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  NLM_MAX_COUNTERS = 40
+};
+extern atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#ifdef CONFIG_NLM_STATS 
+#define xlr_inc_counter(x) atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) atomic_read(&nlm_common_counters[0][(x)])
+#else
+#define xlr_inc_counter(x) //atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) //atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) //atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) //atomic_read(&nlm_common_counters[0][(x)])
+#endif
+#if 0
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__, smp_processor_id(), ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/drivers/netlogic/soc_interface/on_chip.c b/drivers/netlogic/soc_interface/on_chip.c
new file mode 100644
index 0000000..17c8c3c
--- /dev/null
+++ b/drivers/netlogic/soc_interface/on_chip.c
@@ -0,0 +1,1552 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/hardirq.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+
+#include "nlm_msgring.h"
+#include "nlm_xlp.h"
+#include "nlm_debug.h"
+#include "nlm_hal.h"
+#include "libfdt.h"   /*fdt*/
+#include "ops.h"   /*fdt*/
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+#include "nlm_hal_fmn.h"
+#endif
+
+#include <linux/netdevice.h>
+
+#define MAX_VC	4096
+#define MAX_VC_9XX	8192
+/* #define ONCHIP_DEBUG 1 */
+
+static int is_cpu_core_xlp_ii = 0;
+unsigned int xlp_napi_vc_mask = 0;
+
+cpumask_t phys_cpu_present_map;
+EXPORT_SYMBOL(phys_cpu_present_map);
+
+atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
+
+extern int xlp_rvec_from_irt(int);
+extern int xlp_rvec_from_irq(int);
+unsigned long netlogic_io_base = (unsigned long)(DEFAULT_NETLOGIC_IO_BASE);
+EXPORT_SYMBOL(netlogic_io_base);
+
+extern void nlm_cpu_stat_update_msgring_int(void);
+extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
+extern void nlm_cpu_stat_update_msgring_pic_int(void);
+extern void *fdt;
+EXPORT_SYMBOL(fdt);
+
+uint32_t msgring_global_thread_mask = 0;
+uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0}; 
+/* nlm_cpu_vc_mask is superset and will work in other chip type too. for eg in xlp8xx case it will use just 4x32 fields */
+
+uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+typedef int (*vchandler)(void *arg, int vc, int budget);
+static vchandler xlp_napi_vc_handlers[NLM_MAX_VC_PER_THREAD];
+
+typedef int (*intr_vchandler)(int vc);
+static intr_vchandler xlp_intr_vc_handler;
+unsigned int intr_vc_mask[NR_CPUS];
+
+/* make this a read/write spinlock */
+spinlock_t msgrng_lock;
+static nlm_common_atomic_t msgring_registered;
+
+struct msgstn_handler {
+        void (*action)(uint32_t, uint32_t, uint32_t, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);
+        void *dev_id;
+	void (*napi_final)(void *arg);
+	void *napi_final_arg;
+};
+
+static int napi_final_needed[NR_CPUS][XLP_MSG_HANDLE_MAX];
+struct net_device xlp_napi_fmn_dummy_dev;
+DEFINE_PER_CPU(struct napi_struct, xlp_napi_fmn_poll_struct);
+DEFINE_PER_CPU(unsigned long long, xlp_napi_fmn_rx_count);
+static int xlp_napi_vc_count = 0;
+static int xlp_fmn_init_done = 0;
+extern unsigned int xlp_napi_vc_mask;
+
+static uint16_t vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 95] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_CPU4,
+	[208 ... 223] = XLP_MSG_HANDLE_CPU5,
+	[224 ... 239] = XLP_MSG_HANDLE_CPU6,
+	[240 ... 255] = XLP_MSG_HANDLE_CPU7,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[268 ... 271] = XLP_MSG_HANDLE_GDX,
+	[272 ... 280] = XLP_MSG_HANDLE_RSA_ECC,
+	[281 ... 296] = XLP_MSG_HANDLE_CRYPTO,
+	[297 ... 304] = XLP_MSG_HANDLE_CMP,
+	[305 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_POE_0,
+	[392 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 1019] = XLP_MSG_HANDLE_NAE_0,
+	[1020 ... 1023] = XLP_MSG_HANDLE_INVALID,
+	//NODE-1
+	[1024 ... 1039] = XLP_MSG_HANDLE_CPU0,
+	[1040 ... 1055] = XLP_MSG_HANDLE_CPU1,
+	[1056 ... 1071] = XLP_MSG_HANDLE_CPU2,
+	[1072 ... 1087] = XLP_MSG_HANDLE_CPU3,
+	[1088 ... 1103] = XLP_MSG_HANDLE_CPU4,
+	[1104 ... 1119] = XLP_MSG_HANDLE_CPU5,
+	[1120 ... 1135] = XLP_MSG_HANDLE_CPU6,
+	[1136 ... 1151] = XLP_MSG_HANDLE_CPU7,
+	[1158 ... 1279] = XLP_MSG_HANDLE_INVALID,
+	[1280 ... 1281] = XLP_MSG_HANDLE_PCIE0,
+	[1282 ... 1283] = XLP_MSG_HANDLE_PCIE1,
+	[1284 ... 1285] = XLP_MSG_HANDLE_PCIE2,
+	[1286 ... 1287] = XLP_MSG_HANDLE_PCIE3,
+	[1288 ... 1291] = XLP_MSG_HANDLE_DTRE,
+	[1292 ... 1295] = XLP_MSG_HANDLE_GDX,
+	[1296 ... 1304] = XLP_MSG_HANDLE_RSA_ECC,
+	[1305 ... 1320] = XLP_MSG_HANDLE_CRYPTO,
+	[1321 ... 1328] = XLP_MSG_HANDLE_CMP,
+	[1329 ... 1407] = XLP_MSG_HANDLE_INVALID,
+	[1408 ... 1415] = XLP_MSG_HANDLE_POE_0,
+	[1416 ... 1499] = XLP_MSG_HANDLE_INVALID,
+	[1500 ... 2043] = XLP_MSG_HANDLE_NAE_0,
+	[2044 ... 2047] = XLP_MSG_HANDLE_INVALID,
+	// NODE-2
+	[2048 ... 2063] = XLP_MSG_HANDLE_CPU0,
+	[2064 ... 2079] = XLP_MSG_HANDLE_CPU1,
+	[2080 ... 2095] = XLP_MSG_HANDLE_CPU2,
+	[2096 ... 2111] = XLP_MSG_HANDLE_CPU3,
+	[2112 ... 2127] = XLP_MSG_HANDLE_CPU4,
+	[2128 ... 2143] = XLP_MSG_HANDLE_CPU5,
+	[2144 ... 2159] = XLP_MSG_HANDLE_CPU6,
+	[2160 ... 2175] = XLP_MSG_HANDLE_CPU7,
+	[2176 ... 2303] = XLP_MSG_HANDLE_INVALID,
+	[2304 ... 2305] = XLP_MSG_HANDLE_PCIE0,
+	[2306 ... 2307] = XLP_MSG_HANDLE_PCIE1,
+	[2308 ... 2309] = XLP_MSG_HANDLE_PCIE2,
+	[2310 ... 2311] = XLP_MSG_HANDLE_PCIE3,
+	[2312 ... 2315] = XLP_MSG_HANDLE_DTRE,
+	[2316 ... 2319] = XLP_MSG_HANDLE_GDX,
+	[2320 ... 2328] = XLP_MSG_HANDLE_RSA_ECC,
+	[2329 ... 2344] = XLP_MSG_HANDLE_CRYPTO,
+	[2345 ... 2352] = XLP_MSG_HANDLE_CMP,
+	[2353 ... 2431] = XLP_MSG_HANDLE_INVALID,
+	[2432 ... 2439] = XLP_MSG_HANDLE_POE_0,
+	[2440 ... 2523] = XLP_MSG_HANDLE_INVALID,
+	[2524 ... 3067] = XLP_MSG_HANDLE_NAE_0,
+	[3068 ... 3071] = XLP_MSG_HANDLE_INVALID,
+
+	// NODE-3
+	[3072 ... 3087] = XLP_MSG_HANDLE_CPU0,
+	[3088 ... 3103] = XLP_MSG_HANDLE_CPU1,
+	[3104 ... 3119] = XLP_MSG_HANDLE_CPU2,
+	[3120 ... 3135] = XLP_MSG_HANDLE_CPU3,
+	[3136 ... 3151] = XLP_MSG_HANDLE_CPU4,
+	[3152 ... 3167] = XLP_MSG_HANDLE_CPU5,
+	[3168 ... 3183] = XLP_MSG_HANDLE_CPU6,
+	[3184 ... 3199] = XLP_MSG_HANDLE_CPU7,
+	[3200 ... 3327] = XLP_MSG_HANDLE_INVALID,
+	[3328 ... 3329] = XLP_MSG_HANDLE_PCIE0,
+	[3330 ... 3331] = XLP_MSG_HANDLE_PCIE1,
+	[3332 ... 3333] = XLP_MSG_HANDLE_PCIE2,
+	[3334 ... 3335] = XLP_MSG_HANDLE_PCIE3,
+	[3336 ... 3339] = XLP_MSG_HANDLE_DTRE,
+	[3340 ... 3343] = XLP_MSG_HANDLE_GDX,
+	[3344 ... 3352] = XLP_MSG_HANDLE_RSA_ECC,
+	[3353 ... 3368] = XLP_MSG_HANDLE_CRYPTO,
+	[3369 ... 3376] = XLP_MSG_HANDLE_CMP,
+	[3377 ... 3455] = XLP_MSG_HANDLE_INVALID,
+	[3456 ... 3463] = XLP_MSG_HANDLE_POE_0,
+	[3464 ... 3547] = XLP_MSG_HANDLE_INVALID,
+	[3548 ... 4091] = XLP_MSG_HANDLE_NAE_0,
+	[4092 ... 4095] = XLP_MSG_HANDLE_INVALID,
+};
+
+static uint16_t xlp3xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_INVALID,
+	[80 ... 95] = XLP_MSG_HANDLE_INVALID,
+	[96 ... 111] = XLP_MSG_HANDLE_INVALID,
+	[112 ... 127] = XLP_MSG_HANDLE_INVALID,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU2,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU3,
+	[192 ... 207] = XLP_MSG_HANDLE_INVALID,
+	[208 ... 223] = XLP_MSG_HANDLE_INVALID,
+	[224 ... 239] = XLP_MSG_HANDLE_INVALID,
+	[240 ... 255] = XLP_MSG_HANDLE_INVALID,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 267] = XLP_MSG_HANDLE_DTRE,
+	[268 ... 271] = XLP_MSG_HANDLE_REGX,
+	[272 ... 275] = XLP_MSG_HANDLE_RSA_ECC,
+	[276 ... 279] = XLP_MSG_HANDLE_CRYPTO,
+	[280 ... 288] = XLP_MSG_HANDLE_SRIO,
+	[289 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_POE_0,
+	[392 ... 431] = XLP_MSG_HANDLE_INVALID,
+	[432 ... 511] = XLP_MSG_HANDLE_NAE_0,
+	[512 ... 4095]= XLP_MSG_HANDLE_INVALID
+};
+
+static uint16_t xlp2xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 127] = XLP_MSG_HANDLE_INVALID,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 255] = XLP_MSG_HANDLE_INVALID,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 265] = XLP_MSG_HANDLE_DTRE,
+	[266 ... 267] = XLP_MSG_HANDLE_CMP,
+	[268 ... 271] = XLP_MSG_HANDLE_REGX,
+	[272 ... 272] = XLP_MSG_HANDLE_RSA_ECC,
+	[273 ... 275] = XLP_MSG_HANDLE_INVALID,
+	[276 ... 276] = XLP_MSG_HANDLE_CRYPTO,
+	[277 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_POE_0,
+	[392 ... 431] = XLP_MSG_HANDLE_INVALID,
+	[432 ... 503] = XLP_MSG_HANDLE_NAE_0,
+	[504 ... 4095]= XLP_MSG_HANDLE_INVALID
+
+};
+
+/* TODO: popq handlers are to be added.
+   */
+
+static uint16_t xlp9xx_vc_to_handle_map[MAX_VC_9XX] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 47] = XLP_MSG_HANDLE_CPU2,
+	[48 ... 63] = XLP_MSG_HANDLE_CPU3,
+	[64 ... 79] = XLP_MSG_HANDLE_CPU4,
+	[80 ... 95] = XLP_MSG_HANDLE_CPU5,
+	[96 ... 111] = XLP_MSG_HANDLE_CPU6,
+	[112 ... 127] = XLP_MSG_HANDLE_CPU7,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU8,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU9,
+	[160 ... 175] = XLP_MSG_HANDLE_CPU10,
+	[176 ... 191] = XLP_MSG_HANDLE_CPU11,
+	[192 ... 207] = XLP_MSG_HANDLE_CPU12,
+	[208 ... 223] = XLP_MSG_HANDLE_CPU13,
+	[224 ... 239] = XLP_MSG_HANDLE_CPU14,
+	[240 ... 255] = XLP_MSG_HANDLE_CPU15,
+	[256 ... 271] = XLP_MSG_HANDLE_CPU16,
+	[272 ... 287] = XLP_MSG_HANDLE_CPU17,
+	[288 ... 303] = XLP_MSG_HANDLE_CPU18,
+	[304 ... 319] = XLP_MSG_HANDLE_CPU19,
+	[320 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 385] = XLP_MSG_HANDLE_PCIE0,
+	[386 ... 387] = XLP_MSG_HANDLE_PCIE1,
+	[388 ... 389] = XLP_MSG_HANDLE_PCIE2,
+	[390 ... 391] = XLP_MSG_HANDLE_PCIE3,
+	[392 ... 393] = XLP_MSG_HANDLE_GDX_0,
+	[394 ... 395] = XLP_MSG_HANDLE_GDX_1,
+	[396 ... 399] = XLP_MSG_HANDLE_INVALID,
+	[400 ... 406] = XLP_MSG_HANDLE_CMP,
+	[407 ... 411] = XLP_MSG_HANDLE_INVALID,
+	[412 ... 418] = XLP_MSG_HANDLE_LZS,
+	[419 ... 423] = XLP_MSG_HANDLE_INVALID,
+	[424 ... 431] = XLP_MSG_HANDLE_CRYPTO,
+	[432 ... 447] = XLP_MSG_HANDLE_INVALID,
+	[448 ... 451] = XLP_MSG_HANDLE_RSA_ECC,
+	[452 ... 459] = XLP_MSG_HANDLE_INVALID,
+	[460 ... 463] = XLP_MSG_HANDLE_REGX,
+	[464 ... 475] = XLP_MSG_HANDLE_INVALID,
+	[476 ... 479] = XLP_MSG_HANDLE_KBP,
+	[480 ... 511] = XLP_MSG_HANDLE_INVALID,
+	[512 ... 519] = XLP_MSG_HANDLE_POE_0,
+	[520 ... 599] = XLP_MSG_HANDLE_NAE_0,
+	[600 ... 639] = XLP_MSG_HANDLE_INVALID,
+	[640 ... 647] = XLP_MSG_HANDLE_POE_1,
+	[648 ... 727] = XLP_MSG_HANDLE_NAE_1,
+	[728 ... 729] = XLP_MSG_HANDLE_INVALID,
+	[730 ... 731] = XLP_MSG_HANDLE_ALE,
+	[732 ... 1023]= XLP_MSG_HANDLE_INVALID,
+
+	/* NODE 1 */
+	[1024 ... 1039] = XLP_MSG_HANDLE_CPU0,
+	[1040 ... 1055] = XLP_MSG_HANDLE_CPU1,
+	[1056 ... 1071] = XLP_MSG_HANDLE_CPU2,
+	[1072 ... 1087] = XLP_MSG_HANDLE_CPU3,
+	[1088 ... 1103] = XLP_MSG_HANDLE_CPU4,
+	[1104 ... 1119] = XLP_MSG_HANDLE_CPU5,
+	[1120 ... 1135] = XLP_MSG_HANDLE_CPU6,
+	[1136 ... 1151] = XLP_MSG_HANDLE_CPU7,
+	[1152 ... 1167] = XLP_MSG_HANDLE_CPU8,
+	[1168 ... 1183] = XLP_MSG_HANDLE_CPU9,
+	[1184 ... 1199] = XLP_MSG_HANDLE_CPU10,
+	[1200 ... 1215] = XLP_MSG_HANDLE_CPU11,
+	[1216 ... 1231] = XLP_MSG_HANDLE_CPU12,
+	[1232 ... 1247] = XLP_MSG_HANDLE_CPU13,
+	[1248 ... 1263] = XLP_MSG_HANDLE_CPU14,
+	[1264 ... 1279] = XLP_MSG_HANDLE_CPU15,
+	[1280 ... 1295] = XLP_MSG_HANDLE_CPU16,
+	[1296 ... 1311] = XLP_MSG_HANDLE_CPU17,
+	[1312 ... 1327] = XLP_MSG_HANDLE_CPU18,
+	[1328 ... 1343] = XLP_MSG_HANDLE_CPU19,
+	[1344 ... 1407] = XLP_MSG_HANDLE_INVALID,
+	[1408 ... 1409] = XLP_MSG_HANDLE_PCIE0,
+	[1410 ... 1411] = XLP_MSG_HANDLE_PCIE1,
+	[1412 ... 1413] = XLP_MSG_HANDLE_PCIE2,
+	[1414 ... 1415] = XLP_MSG_HANDLE_PCIE3,
+	[1416 ... 1417] = XLP_MSG_HANDLE_GDX_0,
+	[1418 ... 1419] = XLP_MSG_HANDLE_GDX_1,
+	[1420 ... 1423] = XLP_MSG_HANDLE_INVALID,
+	[1424 ... 1430] = XLP_MSG_HANDLE_CMP,
+	[1431 ... 1435] = XLP_MSG_HANDLE_INVALID,
+	[1436 ... 1442] = XLP_MSG_HANDLE_LZS,
+	[1443 ... 1447] = XLP_MSG_HANDLE_INVALID,
+	[1448 ... 1455] = XLP_MSG_HANDLE_CRYPTO,
+	[1456 ... 1471] = XLP_MSG_HANDLE_INVALID,
+	[1472 ... 1475] = XLP_MSG_HANDLE_RSA_ECC,
+	[1476 ... 1483] = XLP_MSG_HANDLE_INVALID,
+	[1484 ... 1487] = XLP_MSG_HANDLE_REGX,
+	[1488 ... 1499] = XLP_MSG_HANDLE_INVALID,
+	[1500 ... 1503] = XLP_MSG_HANDLE_KBP,
+	[1504 ... 1535] = XLP_MSG_HANDLE_INVALID,
+	[1536 ... 1543] = XLP_MSG_HANDLE_POE_0,
+	[1544 ... 1623] = XLP_MSG_HANDLE_NAE_0,
+	[1624 ... 1663] = XLP_MSG_HANDLE_INVALID,
+	[1664 ... 1671] = XLP_MSG_HANDLE_POE_1,
+	[1672 ... 1751] = XLP_MSG_HANDLE_NAE_1,
+	[1752 ... 1753] = XLP_MSG_HANDLE_INVALID,
+	[1754 ... 1755] = XLP_MSG_HANDLE_ALE,
+	[1756 ... 2047]= XLP_MSG_HANDLE_INVALID,
+	
+	/* NODE 2 */
+	[2048 ... 2063] = XLP_MSG_HANDLE_CPU0,
+	[2064 ... 2079] = XLP_MSG_HANDLE_CPU1,
+	[2080 ... 2095] = XLP_MSG_HANDLE_CPU2,
+	[2096 ... 2111] = XLP_MSG_HANDLE_CPU3,
+	[2112 ... 2127] = XLP_MSG_HANDLE_CPU4,
+	[2128 ... 2143] = XLP_MSG_HANDLE_CPU5,
+	[2144 ... 2159] = XLP_MSG_HANDLE_CPU6,
+	[2160 ... 2175] = XLP_MSG_HANDLE_CPU7,
+	[2176 ... 2191] = XLP_MSG_HANDLE_CPU8,
+	[2192 ... 2207] = XLP_MSG_HANDLE_CPU9,
+	[2208 ... 2223] = XLP_MSG_HANDLE_CPU10,
+	[2224 ... 2239] = XLP_MSG_HANDLE_CPU11,
+	[2240 ... 2255] = XLP_MSG_HANDLE_CPU12,
+	[2256 ... 2271] = XLP_MSG_HANDLE_CPU13,
+	[2272 ... 2287] = XLP_MSG_HANDLE_CPU14,
+	[2288 ... 2303] = XLP_MSG_HANDLE_CPU15,
+	[2304 ... 2319] = XLP_MSG_HANDLE_CPU16,
+	[2320 ... 2335] = XLP_MSG_HANDLE_CPU17,
+	[2336 ... 2351] = XLP_MSG_HANDLE_CPU18,
+	[2352 ... 2367] = XLP_MSG_HANDLE_CPU19,
+	[2368 ... 2431] = XLP_MSG_HANDLE_INVALID,
+	[2432 ... 2433] = XLP_MSG_HANDLE_PCIE0,
+	[2434 ... 2435] = XLP_MSG_HANDLE_PCIE1,
+	[2436 ... 2437] = XLP_MSG_HANDLE_PCIE2,
+	[2438 ... 2439] = XLP_MSG_HANDLE_PCIE3,
+	[2440 ... 2441] = XLP_MSG_HANDLE_GDX_0,
+	[2442 ... 2443] = XLP_MSG_HANDLE_GDX_1,
+	[2444 ... 2447] = XLP_MSG_HANDLE_INVALID,
+	[2448 ... 2454] = XLP_MSG_HANDLE_CMP,
+	[2455 ... 2459] = XLP_MSG_HANDLE_INVALID,
+	[2460 ... 2466] = XLP_MSG_HANDLE_LZS,
+	[2467 ... 2471] = XLP_MSG_HANDLE_INVALID,
+	[2472 ... 2479] = XLP_MSG_HANDLE_CRYPTO,
+	[2480 ... 2495] = XLP_MSG_HANDLE_INVALID,
+	[2496 ... 2499] = XLP_MSG_HANDLE_RSA_ECC,
+	[2500 ... 2507] = XLP_MSG_HANDLE_INVALID,
+	[2508 ... 2511] = XLP_MSG_HANDLE_REGX,
+	[2512 ... 2523] = XLP_MSG_HANDLE_INVALID,
+	[2524 ... 2527] = XLP_MSG_HANDLE_KBP,
+	[2528 ... 2559] = XLP_MSG_HANDLE_INVALID,
+	[2560 ... 2567] = XLP_MSG_HANDLE_POE_0,
+	[2568 ... 2647] = XLP_MSG_HANDLE_NAE_0,
+	[2648 ... 2687] = XLP_MSG_HANDLE_INVALID,
+	[2688 ... 2695] = XLP_MSG_HANDLE_POE_1,
+	[2696 ... 2775] = XLP_MSG_HANDLE_NAE_1,
+	[2776 ... 2777] = XLP_MSG_HANDLE_INVALID,
+	[2778 ... 2779] = XLP_MSG_HANDLE_ALE,
+	[2780 ... 3071]= XLP_MSG_HANDLE_INVALID,
+	
+	/* NODE 3 */
+	[3072 ... 3087] = XLP_MSG_HANDLE_CPU0,
+	[3088 ... 3103] = XLP_MSG_HANDLE_CPU1,
+	[3104 ... 3119] = XLP_MSG_HANDLE_CPU2,
+	[3120 ... 3135] = XLP_MSG_HANDLE_CPU3,
+	[3136 ... 3151] = XLP_MSG_HANDLE_CPU4,
+	[3152 ... 3167] = XLP_MSG_HANDLE_CPU5,
+	[3168 ... 3183] = XLP_MSG_HANDLE_CPU6,
+	[3184 ... 3199] = XLP_MSG_HANDLE_CPU7,
+	[3200 ... 3215] = XLP_MSG_HANDLE_CPU8,
+	[3216 ... 3231] = XLP_MSG_HANDLE_CPU9,
+	[3232 ... 3247] = XLP_MSG_HANDLE_CPU10,
+	[3248 ... 3263] = XLP_MSG_HANDLE_CPU11,
+	[3264 ... 3279] = XLP_MSG_HANDLE_CPU12,
+	[3280 ... 3295] = XLP_MSG_HANDLE_CPU13,
+	[3296 ... 3311] = XLP_MSG_HANDLE_CPU14,
+	[3312 ... 3327] = XLP_MSG_HANDLE_CPU15,
+	[3328 ... 3343] = XLP_MSG_HANDLE_CPU16,
+	[3344 ... 3359] = XLP_MSG_HANDLE_CPU17,
+	[3360 ... 3375] = XLP_MSG_HANDLE_CPU18,
+	[3376 ... 3391] = XLP_MSG_HANDLE_CPU19,
+	[3392 ... 3455] = XLP_MSG_HANDLE_INVALID,
+	[3456 ... 3457] = XLP_MSG_HANDLE_PCIE0,
+	[3458 ... 3459] = XLP_MSG_HANDLE_PCIE1,
+	[3460 ... 3461] = XLP_MSG_HANDLE_PCIE2,
+	[3462 ... 3463] = XLP_MSG_HANDLE_PCIE3,
+	[3464 ... 3465] = XLP_MSG_HANDLE_GDX_0,
+	[3466 ... 3467] = XLP_MSG_HANDLE_GDX_1,
+	[3468 ... 3471] = XLP_MSG_HANDLE_INVALID,
+	[3472 ... 3478] = XLP_MSG_HANDLE_CMP,
+	[3479 ... 3483] = XLP_MSG_HANDLE_INVALID,
+	[3484 ... 3490] = XLP_MSG_HANDLE_LZS,
+	[3491 ... 3495] = XLP_MSG_HANDLE_INVALID,
+	[3496 ... 3503] = XLP_MSG_HANDLE_CRYPTO,
+	[3504 ... 3519] = XLP_MSG_HANDLE_INVALID,
+	[3520 ... 3523] = XLP_MSG_HANDLE_RSA_ECC,
+	[3524 ... 3531] = XLP_MSG_HANDLE_INVALID,
+	[3532 ... 3535] = XLP_MSG_HANDLE_REGX,
+	[3536 ... 3547] = XLP_MSG_HANDLE_INVALID,
+	[3548 ... 3551] = XLP_MSG_HANDLE_KBP,
+	[3552 ... 3583] = XLP_MSG_HANDLE_INVALID,
+	[3584 ... 3591] = XLP_MSG_HANDLE_POE_0,
+	[3592 ... 3671] = XLP_MSG_HANDLE_NAE_0,
+	[3672 ... 3711] = XLP_MSG_HANDLE_INVALID,
+	[3712 ... 3719] = XLP_MSG_HANDLE_POE_1,
+	[3720 ... 3799] = XLP_MSG_HANDLE_NAE_1,
+	[3800 ... 3801] = XLP_MSG_HANDLE_INVALID,
+	[3802 ... 3803] = XLP_MSG_HANDLE_ALE,
+	[3804 ... 4095]= XLP_MSG_HANDLE_INVALID,
+	
+	/* NODE 4 */
+	[4096 ... 4111] = XLP_MSG_HANDLE_CPU0,
+	[4112 ... 4127] = XLP_MSG_HANDLE_CPU1,
+	[4128 ... 4143] = XLP_MSG_HANDLE_CPU2,
+	[4144 ... 4159] = XLP_MSG_HANDLE_CPU3,
+	[4160 ... 4175] = XLP_MSG_HANDLE_CPU4,
+	[4176 ... 4191] = XLP_MSG_HANDLE_CPU5,
+	[4192 ... 4207] = XLP_MSG_HANDLE_CPU6,
+	[4208 ... 4223] = XLP_MSG_HANDLE_CPU7,
+	[4224 ... 4239] = XLP_MSG_HANDLE_CPU8,
+	[4240 ... 4255] = XLP_MSG_HANDLE_CPU9,
+	[4256 ... 4271] = XLP_MSG_HANDLE_CPU10,
+	[4272 ... 4287] = XLP_MSG_HANDLE_CPU11,
+	[4288 ... 4303] = XLP_MSG_HANDLE_CPU12,
+	[4304 ... 4319] = XLP_MSG_HANDLE_CPU13,
+	[4320 ... 4335] = XLP_MSG_HANDLE_CPU14,
+	[4336 ... 4351] = XLP_MSG_HANDLE_CPU15,
+	[4352 ... 4367] = XLP_MSG_HANDLE_CPU16,
+	[4368 ... 4383] = XLP_MSG_HANDLE_CPU17,
+	[4384 ... 4399] = XLP_MSG_HANDLE_CPU18,
+	[4400 ... 4415] = XLP_MSG_HANDLE_CPU19,
+	[4416 ... 4479] = XLP_MSG_HANDLE_INVALID,
+	[4480 ... 4481] = XLP_MSG_HANDLE_PCIE0,
+	[4482 ... 4483] = XLP_MSG_HANDLE_PCIE1,
+	[4484 ... 4485] = XLP_MSG_HANDLE_PCIE2,
+	[4486 ... 4487] = XLP_MSG_HANDLE_PCIE3,
+	[4488 ... 4489] = XLP_MSG_HANDLE_GDX_0,
+	[4490 ... 4491] = XLP_MSG_HANDLE_GDX_1,
+	[4492 ... 4495] = XLP_MSG_HANDLE_INVALID,
+	[4496 ... 4502] = XLP_MSG_HANDLE_CMP,
+	[4503 ... 4507] = XLP_MSG_HANDLE_INVALID,
+	[4508 ... 4514] = XLP_MSG_HANDLE_LZS,
+	[4515 ... 4519] = XLP_MSG_HANDLE_INVALID,
+	[4520 ... 4527] = XLP_MSG_HANDLE_CRYPTO,
+	[4528 ... 4543] = XLP_MSG_HANDLE_INVALID,
+	[4544 ... 4547] = XLP_MSG_HANDLE_RSA_ECC,
+	[4548 ... 4555] = XLP_MSG_HANDLE_INVALID,
+	[4556 ... 4559] = XLP_MSG_HANDLE_REGX,
+	[4560 ... 4571] = XLP_MSG_HANDLE_INVALID,
+	[4572 ... 4575] = XLP_MSG_HANDLE_KBP,
+	[4576 ... 4607] = XLP_MSG_HANDLE_INVALID,
+	[4608 ... 4615] = XLP_MSG_HANDLE_POE_0,
+	[4616 ... 4695] = XLP_MSG_HANDLE_NAE_0,
+	[4696 ... 4735] = XLP_MSG_HANDLE_INVALID,
+	[4736 ... 4743] = XLP_MSG_HANDLE_POE_1,
+	[4744 ... 4823] = XLP_MSG_HANDLE_NAE_1,
+	[4824 ... 4825] = XLP_MSG_HANDLE_INVALID,
+	[4826 ... 4827] = XLP_MSG_HANDLE_ALE,
+	[4828 ... 5119]= XLP_MSG_HANDLE_INVALID,
+
+	/* NODE 5 */
+	[5120 ... 5135] = XLP_MSG_HANDLE_CPU0,
+	[5136 ... 5151] = XLP_MSG_HANDLE_CPU1,
+	[5152 ... 5167] = XLP_MSG_HANDLE_CPU2,
+	[5168 ... 5183] = XLP_MSG_HANDLE_CPU3,
+	[5184 ... 5199] = XLP_MSG_HANDLE_CPU4,
+	[5200 ... 5215] = XLP_MSG_HANDLE_CPU5,
+	[5216 ... 5231] = XLP_MSG_HANDLE_CPU6,
+	[5232 ... 5247] = XLP_MSG_HANDLE_CPU7,
+	[5248 ... 5263] = XLP_MSG_HANDLE_CPU8,
+	[5264 ... 5279] = XLP_MSG_HANDLE_CPU9,
+	[5280 ... 5295] = XLP_MSG_HANDLE_CPU10,
+	[5296 ... 5311] = XLP_MSG_HANDLE_CPU11,
+	[5312 ... 5327] = XLP_MSG_HANDLE_CPU12,
+	[5328 ... 5343] = XLP_MSG_HANDLE_CPU13,
+	[5344 ... 5359] = XLP_MSG_HANDLE_CPU14,
+	[5360 ... 5375] = XLP_MSG_HANDLE_CPU15,
+	[5376 ... 5391] = XLP_MSG_HANDLE_CPU16,
+	[5392 ... 5407] = XLP_MSG_HANDLE_CPU17,
+	[5408 ... 5423] = XLP_MSG_HANDLE_CPU18,
+	[5424 ... 5439] = XLP_MSG_HANDLE_CPU19,
+	[5440 ... 5503] = XLP_MSG_HANDLE_INVALID,
+	[5504 ... 5505] = XLP_MSG_HANDLE_PCIE0,
+	[5506 ... 5507] = XLP_MSG_HANDLE_PCIE1,
+	[5508 ... 5509] = XLP_MSG_HANDLE_PCIE2,
+	[5510 ... 5511] = XLP_MSG_HANDLE_PCIE3,
+	[5512 ... 5513] = XLP_MSG_HANDLE_GDX_0,
+	[5514 ... 5515] = XLP_MSG_HANDLE_GDX_1,
+	[5516 ... 5519] = XLP_MSG_HANDLE_INVALID,
+	[5520 ... 5526] = XLP_MSG_HANDLE_CMP,
+	[5527 ... 5531] = XLP_MSG_HANDLE_INVALID,
+	[5532 ... 5538] = XLP_MSG_HANDLE_LZS,
+	[5539 ... 5543] = XLP_MSG_HANDLE_INVALID,
+	[5544 ... 5551] = XLP_MSG_HANDLE_CRYPTO,
+	[5552 ... 5567] = XLP_MSG_HANDLE_INVALID,
+	[5568 ... 5571] = XLP_MSG_HANDLE_RSA_ECC,
+	[5572 ... 5579] = XLP_MSG_HANDLE_INVALID,
+	[5580 ... 5583] = XLP_MSG_HANDLE_REGX,
+	[5584 ... 5595] = XLP_MSG_HANDLE_INVALID,
+	[5596 ... 5599] = XLP_MSG_HANDLE_KBP,
+	[5600 ... 5631] = XLP_MSG_HANDLE_INVALID,
+	[5632 ... 5639] = XLP_MSG_HANDLE_POE_0,
+	[5640 ... 5719] = XLP_MSG_HANDLE_NAE_0,
+	[5720 ... 5759] = XLP_MSG_HANDLE_INVALID,
+	[5760 ... 5767] = XLP_MSG_HANDLE_POE_1,
+	[5768 ... 5847] = XLP_MSG_HANDLE_NAE_1,
+	[5848 ... 5849] = XLP_MSG_HANDLE_INVALID,
+	[5850 ... 5851] = XLP_MSG_HANDLE_ALE,
+	[5852 ... 6143]= XLP_MSG_HANDLE_INVALID,
+
+	/* NODE 6 */
+	[6144 ... 6159] = XLP_MSG_HANDLE_CPU0,
+	[6160 ... 6175] = XLP_MSG_HANDLE_CPU1,
+	[6176 ... 6191] = XLP_MSG_HANDLE_CPU2,
+	[6192 ... 6207] = XLP_MSG_HANDLE_CPU3,
+	[6208 ... 6223] = XLP_MSG_HANDLE_CPU4,
+	[6224 ... 6239] = XLP_MSG_HANDLE_CPU5,
+	[6240 ... 6255] = XLP_MSG_HANDLE_CPU6,
+	[6256 ... 6271] = XLP_MSG_HANDLE_CPU7,
+	[6272 ... 6287] = XLP_MSG_HANDLE_CPU8,
+	[6288 ... 6303] = XLP_MSG_HANDLE_CPU9,
+	[6304 ... 6319] = XLP_MSG_HANDLE_CPU10,
+	[6320 ... 6335] = XLP_MSG_HANDLE_CPU11,
+	[6336 ... 6351] = XLP_MSG_HANDLE_CPU12,
+	[6352 ... 6367] = XLP_MSG_HANDLE_CPU13,
+	[6368 ... 6383] = XLP_MSG_HANDLE_CPU14,
+	[6384 ... 6399] = XLP_MSG_HANDLE_CPU15,
+	[6400 ... 6415] = XLP_MSG_HANDLE_CPU16,
+	[6416 ... 6431] = XLP_MSG_HANDLE_CPU17,
+	[6432 ... 6447] = XLP_MSG_HANDLE_CPU18,
+	[6448 ... 6463] = XLP_MSG_HANDLE_CPU19,
+	[6464 ... 6527] = XLP_MSG_HANDLE_INVALID,
+	[6528 ... 6529] = XLP_MSG_HANDLE_PCIE0,
+	[6530 ... 6531] = XLP_MSG_HANDLE_PCIE1,
+	[6532 ... 6533] = XLP_MSG_HANDLE_PCIE2,
+	[6534 ... 6535] = XLP_MSG_HANDLE_PCIE3,
+	[6536 ... 6537] = XLP_MSG_HANDLE_GDX_0,
+	[6538 ... 6539] = XLP_MSG_HANDLE_GDX_1,
+	[6540 ... 6543] = XLP_MSG_HANDLE_INVALID,
+	[6544 ... 6550] = XLP_MSG_HANDLE_CMP,
+	[6551 ... 6555] = XLP_MSG_HANDLE_INVALID,
+	[6556 ... 6562] = XLP_MSG_HANDLE_LZS,
+	[6563 ... 6567] = XLP_MSG_HANDLE_INVALID,
+	[6568 ... 6575] = XLP_MSG_HANDLE_CRYPTO,
+	[6576 ... 6591] = XLP_MSG_HANDLE_INVALID,
+	[6592 ... 6595] = XLP_MSG_HANDLE_RSA_ECC,
+	[6596 ... 6603] = XLP_MSG_HANDLE_INVALID,
+	[6604 ... 6607] = XLP_MSG_HANDLE_REGX,
+	[6608 ... 6619] = XLP_MSG_HANDLE_INVALID,
+	[6620 ... 6623] = XLP_MSG_HANDLE_KBP,
+	[6624 ... 6655] = XLP_MSG_HANDLE_INVALID,
+	[6656 ... 6663] = XLP_MSG_HANDLE_POE_0,
+	[6664 ... 6743] = XLP_MSG_HANDLE_NAE_0,
+	[6744 ... 6783] = XLP_MSG_HANDLE_INVALID,
+	[6784 ... 6791] = XLP_MSG_HANDLE_POE_1,
+	[6792 ... 6871] = XLP_MSG_HANDLE_NAE_1,
+	[6872 ... 6873] = XLP_MSG_HANDLE_INVALID,
+	[6874 ... 6875] = XLP_MSG_HANDLE_ALE,
+	[6876 ... 7167]= XLP_MSG_HANDLE_INVALID,
+
+	/* NODE 7 */
+	[7168 ... 7183] = XLP_MSG_HANDLE_CPU0,
+	[7184 ... 7199] = XLP_MSG_HANDLE_CPU1,
+	[7200 ... 7215] = XLP_MSG_HANDLE_CPU2,
+	[7216 ... 7231] = XLP_MSG_HANDLE_CPU3,
+	[7232 ... 7247] = XLP_MSG_HANDLE_CPU4,
+	[7248 ... 7263] = XLP_MSG_HANDLE_CPU5,
+	[7264 ... 7279] = XLP_MSG_HANDLE_CPU6,
+	[7280 ... 7295] = XLP_MSG_HANDLE_CPU7,
+	[7296 ... 7311] = XLP_MSG_HANDLE_CPU8,
+	[7312 ... 7327] = XLP_MSG_HANDLE_CPU9,
+	[7328 ... 7343] = XLP_MSG_HANDLE_CPU10,
+	[7344 ... 7359] = XLP_MSG_HANDLE_CPU11,
+	[7360 ... 7375] = XLP_MSG_HANDLE_CPU12,
+	[7376 ... 7391] = XLP_MSG_HANDLE_CPU13,
+	[7392 ... 7407] = XLP_MSG_HANDLE_CPU14,
+	[7408 ... 7423] = XLP_MSG_HANDLE_CPU15,
+	[7424 ... 7439] = XLP_MSG_HANDLE_CPU16,
+	[7440 ... 7455] = XLP_MSG_HANDLE_CPU17,
+	[7456 ... 7471] = XLP_MSG_HANDLE_CPU18,
+	[7472 ... 7487] = XLP_MSG_HANDLE_CPU19,
+	[7488 ... 7551] = XLP_MSG_HANDLE_INVALID,
+	[7552 ... 7553] = XLP_MSG_HANDLE_PCIE0,
+	[7554 ... 7555] = XLP_MSG_HANDLE_PCIE1,
+	[7556 ... 7557] = XLP_MSG_HANDLE_PCIE2,
+	[7558 ... 7559] = XLP_MSG_HANDLE_PCIE3,
+	[7560 ... 7561] = XLP_MSG_HANDLE_GDX_0,
+	[7562 ... 7563] = XLP_MSG_HANDLE_GDX_1,
+	[7564 ... 7567] = XLP_MSG_HANDLE_INVALID,
+	[7568 ... 7574] = XLP_MSG_HANDLE_CMP,
+	[7575 ... 7579] = XLP_MSG_HANDLE_INVALID,
+	[7580 ... 7586] = XLP_MSG_HANDLE_LZS,
+	[7587 ... 7591] = XLP_MSG_HANDLE_INVALID,
+	[7592 ... 7599] = XLP_MSG_HANDLE_CRYPTO,
+	[7600 ... 7615] = XLP_MSG_HANDLE_INVALID,
+	[7616 ... 7619] = XLP_MSG_HANDLE_RSA_ECC,
+	[7620 ... 7627] = XLP_MSG_HANDLE_INVALID,
+	[7628 ... 7631] = XLP_MSG_HANDLE_REGX,
+	[7632 ... 7643] = XLP_MSG_HANDLE_INVALID,
+	[7644 ... 7647] = XLP_MSG_HANDLE_KBP,
+	[7648 ... 7679] = XLP_MSG_HANDLE_INVALID,
+	[7680 ... 7687] = XLP_MSG_HANDLE_POE_0,
+	[7688 ... 7767] = XLP_MSG_HANDLE_NAE_0,
+	[7768 ... 7807] = XLP_MSG_HANDLE_INVALID,
+	[7808 ... 7815] = XLP_MSG_HANDLE_POE_1,
+	[7816 ... 7895] = XLP_MSG_HANDLE_NAE_1,
+	[7896 ... 7897] = XLP_MSG_HANDLE_INVALID,
+	[7898 ... 7899] = XLP_MSG_HANDLE_ALE,
+	[7900 ... 8191]= XLP_MSG_HANDLE_INVALID,
+};
+
+static uint16_t *vc_to_handle = vc_to_handle_map;
+
+/******************************************************************************************
+ *  dummy_handler
+ *
+ *  @vc		cpu vc number
+ *  @src_id	msg sender station vc
+ *  @size	msg_size-1
+ *  @code	software code nae or poe can put in
+ *  @msg0	64 bit msg0 structure
+ *  @msg1	64 bit msg1 structure
+ *  @msg2	64 bit msg2 structure
+ *  @msg3	64 bit msg3 structure
+ *  @dev_id	driver write can save a device id here
+ *
+ ******************************************************************************************/
+void dummy_handler(uint32_t vc, uint32_t src_id, uint32_t size, uint32_t code,
+		   uint64_t msg0, uint64_t msg1, uint64_t msg2, uint64_t msg3, void *dev_id)
+{
+//#if 0
+	printk("[%s]: No Handler for message from stn_id=%d, bucket=%d, "
+	       "size=%d, msg0=%llx, msg1=%llx dropping message\n",
+	       __FUNCTION__, src_id, vc, size,
+	       (unsigned long long)msg0, (unsigned long long)msg1);
+//#endif
+}
+
+/******************************************************************************************
+ *
+ * intial msg_hander_map with dummy_handler, when real driver msgring handler registered
+ * it will override the entry with hander driver writer provided
+ *
+ ******************************************************************************************/
+struct msgstn_handler msg_handler_map[XLP_MSG_HANDLE_MAX] = {
+	[0 ... (XLP_MSG_HANDLE_MAX-1)] = {dummy_handler, NULL, NULL, NULL},
+};
+
+
+int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(int vc, int budget))
+{
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	if(!((1 << vc) & xlp_napi_vc_mask)) {
+		printk("%s , Error, VC is not specified in napi vc mask\n", __FUNCTION__);
+		return -1;
+	}
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+
+	xlp_napi_vc_handlers[vc] = handler;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_napi_vc_handler);
+
+
+int nlm_xlp_unregister_napi_vc_handler(int vc)
+{
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+	xlp_napi_vc_handlers[vc] = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_unregister_napi_vc_handler);
+
+int nlm_xlp_register_intr_vc_handler(int (*handler)(int vc))
+{
+	xlp_intr_vc_handler = handler;
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_intr_vc_handler);
+
+int nlm_xlp_register_intr_vc(int cpu, int vc)
+{
+	int node;
+	unsigned long flags;
+
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+
+	node = cpu / 32;
+	nlm_hal_enable_vc_intr(node, (cpu*4 + vc) & 0x7f);
+
+	spin_lock_irqsave(&msgrng_lock, flags);
+	intr_vc_mask[cpu] |= (1 << vc);
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+
+	/*printk("%s in, cpu %d intr_vc_mask %x\n", __FUNCTION__, cpu, intr_vc_mask[cpu]);*/
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_register_intr_vc);
+
+int nlm_xlp_unregister_intr_vc(int cpu, int vc)
+{
+	unsigned long flags;
+
+	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
+		printk("%s, Error, invalid VC Passed %d\n", __FUNCTION__, vc);
+		return -1;
+	}
+
+	spin_lock_irqsave(&msgrng_lock, flags);
+	intr_vc_mask[cpu] &= (~(1 << vc));
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(nlm_xlp_unregister_intr_vc);
+
+/*********************************************************************
+ * nlm_xlp_msgring_int_handler
+ *
+ *  @irq	msgring irq number
+ *  @regs	linux systems call back function provide struct pt_regs
+ *
+ ********************************************************************/
+void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
+{
+	unsigned long mflags;
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
+	struct msgstn_handler *handler = 0;
+	unsigned int status = 0;
+	uint64_t msg0, msg1, msg2, msg3;
+	unsigned int msg_status1 = 0, vc_empty_status = 0;
+	int cpu = hard_smp_processor_id();
+	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
+	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
+	unsigned int vcmask;
+
+	msg0 = msg1 = msg2 = msg3 = 0;
+
+	if (irq == XLP_IRQ_MSGRING_RVEC) {
+                /* normal message ring interrupt */
+                /* xlr_inc_counter(MSGRNG_INT);  */
+                nlm_cpu_stat_update_msgring_int();
+        } else {
+                nlm_cpu_stat_update_msgring_pic_int();
+        }
+
+
+        msgrng_access_enable(mflags);
+	cycles = read_c0_count();
+
+	for (;;) {
+
+		/* Read latest VC empty mask */
+		msg_status1 = xlp_read_status1();
+
+		vcmask = (~(msg_status1>>24) & intr_vc_mask[cpu]);
+		if(vcmask && xlp_intr_vc_handler) {
+			for(vc = 0; vc < 4; vc++) {
+				if(!(vcmask & (1<<vc)))
+					continue;
+				xlp_intr_vc_handler(vc);
+			}
+		}
+
+		if((~(msg_status1>>24) & napi_vc_mask) && xlp_fmn_init_done) {
+			struct napi_struct *napi;
+
+			/*Schedule napi routine to process messages from napi vc*/
+		        napi = &__get_cpu_var(xlp_napi_fmn_poll_struct);
+		        napi_schedule(napi);
+			pop_vc_mask = pop_vc_mask & ~napi_vc_mask;
+		}
+
+		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+		if (vc_empty_status == pop_vc_mask) break;
+
+		for( vc = 0; vc < 4; vc++)
+		{
+			if(!(pop_vc_mask & (1<<vc)))
+				continue;
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			if(status != 0)
+				continue;
+
+			handler = &msg_handler_map[vc_to_handle[src_id]];
+
+			/* Execute device driver fmn handler */
+			(handler->action)(vc, src_id, size, code,
+					  msg0, msg1, msg2, msg3, handler->dev_id);
+
+		}
+	}
+	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
+
+	/* Clear VC interrupt status by writing 1s */
+        if (is_cpu_core_xlp_ii) {
+                xlp_write_msg_int((pop_vc_mask));
+        } else {
+                xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
+        }
+
+        msgrng_access_disable(mflags);
+}
+
+EXPORT_SYMBOL(nlm_xlp_msgring_int_handler);
+
+static DEFINE_PER_CPU(struct timer_list, msg_int_bkup_timer);
+static int msg_handler_timer_enabled=0;
+static void msg_timer_handler(unsigned long data)
+{
+	int cpu = smp_processor_id();
+	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
+
+	nlm_xlp_msgring_int_handler(XLP_IRQ_MSGRING_RVEC, NULL);
+
+	mod_timer_pinned(timer, jiffies + (HZ/100));
+}
+void init_msg_bkp_timer(void *data)
+{
+	int cpu = smp_processor_id();
+	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
+
+	init_timer(timer);
+	timer->expires = jiffies + 10;
+	timer->data = 0;
+	timer->function = msg_timer_handler;
+	add_timer_on(timer, cpu);
+}
+
+void xlp_poll_vc0_messages(void)
+{
+        int vc = 0;
+        uint32_t size = 0, code = 0, src_id = 0;
+        struct msgstn_handler *handler = 0;
+        unsigned int status = 0;
+        uint64_t msg0, msg1, msg2, msg3;
+        unsigned int msg_status1 = 0, vc_empty_status = 0;
+        int loop = 0;
+        int pop_vc_mask = 0x1;
+	unsigned long mflags;
+#if 0
+	if (hard_smp_processor_id() != 0)
+		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
+			       hard_smp_processor_id(),
+			       __FUNCTION__,xlp_read_status1());
+#endif
+        msg0 = msg1 = msg2 = msg3 = 0;
+        msgrng_access_enable(mflags);
+        for (loop = 0; loop < 16; loop++) {
+                /* Read latest VC empty mask */
+                msg_status1 = xlp_read_status1();
+                vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
+                if (vc_empty_status == pop_vc_mask)
+                        break;
+                status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+                if(status != 0)
+                        continue;
+                handler = &msg_handler_map[vc_to_handle_map[src_id]];
+                /* Execute device driver fmn handler */
+                (handler->action)(vc, src_id, size, code,
+                                msg0, msg1, msg2, msg3, handler->dev_id);
+        }
+        msgrng_access_disable(mflags);
+}
+EXPORT_SYMBOL(xlp_poll_vc0_messages);
+
+/*******************************************************************************************
+ *  register_xlp_msgring_handler
+ *
+ *  @major      handler id number, each type handler has an ID
+ *  @action     handler callback function (see dummy_handler above for detail)
+ *  @dev_id	optional dev_id paramter for driver write to save device id
+ *******************************************************************************************/
+int register_xlp_msgring_handler(int major,
+			     void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+					     uint64_t, uint64_t, uint64_t, uint64_t, void *),
+			     void *dev_id)
+{
+	int ret = 1;
+	unsigned long flags = 0;
+
+	if (major >= XLP_MSG_HANDLE_MAX || action == NULL) {
+		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+		       "XLP_MAX_TX_STN=%d action=%p",
+		       __FUNCTION__, __LINE__, major, XLP_MAX_TX_STNS, action);
+		return ret;
+	}
+
+	/* Check if the message station is valid, if not return error */
+	spin_lock_irqsave(&msgrng_lock, flags);
+
+	if(!xlp_fmn_init_done)
+		xlp_fmn_init_done = 1;
+
+	if (is_nlm_xlp8xx_ax()) {
+		if(msg_handler_timer_enabled == 0) {
+			msg_handler_timer_enabled = 1;
+			spin_unlock_irqrestore(&msgrng_lock, flags);
+			// init_msg_bkp_timer(0);	Not required, taken care by on_each_cpu()
+			on_each_cpu(init_msg_bkp_timer, 0, 1);
+			spin_lock_irqsave(&msgrng_lock, flags);
+		}
+	}
+
+	msg_handler_map[major].action = action;
+	msg_handler_map[major].dev_id = dev_id;
+
+	ret = 0;
+	msgring_registered.value = 1;
+
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(register_xlp_msgring_handler);
+
+int unregister_xlp_msgring_handler(int major, void *dev_id)
+{
+	unsigned long flags;
+
+	if(major >= XLP_MSG_HANDLE_MAX){
+		printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+		       "XLP_MAX_TX_STN=%d", __FUNCTION__, __LINE__, major,
+		       XLP_MAX_TX_STNS);
+		return -1;
+	}
+	spin_lock_irqsave(&msgrng_lock, flags);
+	if(msg_handler_map[major].dev_id == dev_id){
+		msg_handler_map[major].action = dummy_handler;
+		msg_handler_map[major].dev_id = NULL;
+		msg_handler_map[major].napi_final = NULL;
+		msg_handler_map[major].napi_final_arg = NULL;
+	}
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(unregister_xlp_msgring_handler);
+
+int nlm_xlp_register_napi_final_handler(int major, void (*napi_final)(void *arg), void *arg)
+{
+      if(major >= XLP_MSG_HANDLE_MAX){
+              printk(KERN_ALERT "%s:%d  Invalid parameter: major=%d, "
+                    "XLP_MAX_TX_STN=%d", __FUNCTION__, __LINE__, major,
+                     XLP_MAX_TX_STNS);
+              return -1;
+      }
+      msg_handler_map[major].napi_final = napi_final;
+      msg_handler_map[major].napi_final_arg = arg;
+      return 0;
+}
+
+EXPORT_SYMBOL(nlm_xlp_register_napi_final_handler);
+
+
+#include "nlm_cpumask.h"
+
+/*********************************************************************
+ * enable_msgconfig_int
+ *
+ ********************************************************************/
+void enable_msgconfig_int(void *data)
+{
+	unsigned long flags  = 0;
+
+	/* Need write interrupt vector to cp2 msgconfig register */
+	msgrng_access_enable(flags);
+	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING_RVEC);
+	msgrng_access_disable(flags);
+}
+
+/*********************************************************************
+ * nlm_enable_vc_intr
+ *********************************************************************/
+void nlm_enable_vc_intr(void)
+{
+	int cpu, node;
+	int vc_index = 0;
+	int i = 0;
+
+	for(cpu=0; cpu<NR_CPUS; cpu++){
+                if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
+                        continue;
+		node = cpu / 32;
+		for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
+		{
+			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+				/*enable interrupts*/
+				nlm_hal_enable_vc_intr(node, vc_index);
+			}else{
+				nlm_hal_disable_vc_intr(node, vc_index);
+			}
+		}
+	}
+}
+
+void nlm_enable_vc_intr_9xx(void)
+{
+        int cpu, node;
+        int vc_index = 0;
+        int i = 0;
+
+        for(cpu=0; cpu < NR_CPUS; cpu++){
+                if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
+                        continue;
+                node = cpu / NLM_MAX_CPU_PER_NODE_9XX;
+                for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
+                        vc_index = (i + cpu * NLM_MAX_VC_PER_THREAD_9XX) & NLM_MAX_VC_MASK_9XX;
+                        if(nlm_cpu_vc_mask[cpu] & (1<<i)){
+                                /*enable interrupts*/
+                                nlm_hal_enable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("ENABLED: node = %d, vc = %d\n",node, vc_index);
+#endif
+                        } else{
+                                nlm_hal_disable_vc_intr(node, vc_index);
+#ifdef ONCHIP_DEBUG
+				pr_info("DISABLED: node = %d, vc = %d\n",node, vc_index);
+#endif
+                        }
+                }
+        }
+}
+
+
+int xlp_fmn_poll(struct napi_struct *napi, int budget)
+{
+	int vc = 0;
+	uint32_t size = 0, code = 0, src_id = 0;
+	struct msgstn_handler *handler = 0;
+	unsigned int status = 0;
+	uint64_t msg0=0, msg1=0, msg2=0, msg3=0;
+	int cpu = hard_smp_processor_id();
+	int count = 0;
+	int no_msg = 0;
+	uint32_t napi_vc_mask = xlp_napi_vc_mask & nlm_cpu_vc_mask[cpu];
+	unsigned long mflags;
+	unsigned long napi_final_hndlr[XLP_MSG_HANDLE_MAX];
+	int hndlr_cnt = 0, hndlr_id, i, rv;
+
+	while(count < budget){
+		for( no_msg = 0, vc = 0; vc < 4; vc++)
+		{
+
+			if(!(napi_vc_mask & (1<<vc)))
+				continue;
+
+			/* Explicit per vc napi handlers. Here the vc handler does the polling of
+			 all the packets */
+			if(xlp_napi_vc_handlers[vc]) {
+				rv = (xlp_napi_vc_handlers)[vc]((void *)napi, vc, budget);
+				count += rv;
+				if(rv == 0)
+					no_msg++;
+				continue;
+			}
+
+			msgrng_access_enable(mflags);
+			status = xlp_message_receive( vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
+			msgrng_access_disable(mflags);
+			if(status != 0){
+				no_msg++;
+				continue;
+			}
+			count++;
+			hndlr_id = vc_to_handle[src_id];
+			handler = &msg_handler_map[hndlr_id];
+
+			/* Execute device driver fmn handler */
+			(handler->action)(vc, src_id, size, code,
+				  msg0, msg1, msg2, msg3, handler->dev_id);
+
+			if(handler->napi_final && (napi_final_needed[cpu][hndlr_id] == 0)) {
+				napi_final_needed[cpu][hndlr_id] = 1;
+				napi_final_hndlr[hndlr_cnt] = (unsigned long)handler;
+				hndlr_cnt++;
+			}
+		}
+		if(no_msg == xlp_napi_vc_count)
+			break;
+	}
+
+	for(i = 0; i < hndlr_cnt; i++) {
+		handler = (struct msgstn_handler *)napi_final_hndlr[i];
+		handler->napi_final(handler->napi_final_arg);
+		hndlr_id = handler - &msg_handler_map[0];
+		napi_final_needed[cpu][hndlr_id] = 0;
+	}
+
+
+	/*Ack fmn interrupts.*/
+	if(count < budget) {
+		uint32_t val;
+		unsigned long flags;
+
+		napi_complete(napi);
+
+		local_irq_save(flags);
+		msgrng_access_enable(mflags);
+
+		if (is_cpu_core_xlp_ii) {
+                	xlp_write_msg_int(napi_vc_mask);
+		}
+		else {
+			/* Need write vc into the register */
+			val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+			//val |= ((1 << vc) << 16);
+			val |= (napi_vc_mask << 16);
+			_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+		}
+		msgrng_access_disable(mflags);
+		local_irq_restore(flags);
+
+		return count;
+	}
+	return budget;
+}
+
+static inline int num_ones(unsigned int mask)
+{
+	int ret = 0;
+
+	if (!mask) return 0;
+	while ((mask &= (mask - 1))) ret++;
+	return (ret + 1);
+}
+
+static int xlp_napi_fmn_setup(void)
+{
+	int i, cpu_count;
+	struct napi_struct *napi;
+	int weight_p = 300;
+
+	xlp_napi_vc_count = num_ones(xlp_napi_vc_mask);
+	printk("MSGRING_NAPI: Initializing NLM NAPI subsystem\n");
+
+	init_dummy_netdev(&xlp_napi_fmn_dummy_dev);
+
+	for (cpu_count = 0; cpu_count < NR_CPUS; cpu_count++)
+	{
+		napi = &per_cpu(xlp_napi_fmn_poll_struct, cpu_count);
+		memset(napi, 0, sizeof(*napi));
+		netif_napi_add(&xlp_napi_fmn_dummy_dev, napi, xlp_fmn_poll, weight_p);
+		napi_enable(napi);
+	}
+
+	for (i = 0; i < NR_CPUS; i++) {
+		per_cpu(xlp_napi_fmn_rx_count, i) = 0;
+	}
+	return 0;
+}
+
+static irqreturn_t msgring_irq_handler(int irq, void *dev_id)
+{
+	nlm_xlp_msgring_int_handler(irq, NULL);
+	return IRQ_HANDLED;
+}
+
+void msgring_irq_init(void)
+{
+	if (request_irq(XLP_IRQ_MSGRING_RVEC, msgring_irq_handler,
+			IRQF_PERCPU | IRQF_NO_THREAD,
+			"FMN", NULL)) {
+		panic("Cannot request_irq(XLP_IRQ_MSGRING_RVEC)\n");
+	}
+}
+EXPORT_SYMBOL(msgring_irq_init);
+#endif
+
+
+/*********************************************************************
+ * on_chip_init
+ *
+ ********************************************************************/
+struct proc_dir_entry *nlm_root_proc;
+EXPORT_SYMBOL(nlm_root_proc);
+static int __init nlm_proc_setup(void)
+{
+        nlm_root_proc = proc_mkdir("netlogic", 0);
+        if (!nlm_root_proc)
+                return -ENOMEM;
+
+	pr_info("proc setup done\n");
+        return 0;
+}
+
+static void parse_fmn_config(void)
+{
+        uint32_t node_vc_mask[NLM_MAX_CPU_NODE] = {0};
+        unsigned char buf[30];
+        int i, j, id=0, k, tmp;
+	void *node;
+	uint32_t onlinemask[4] = {~0u};
+
+
+	node = finddevice("/doms/dom@0/fmn");
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask[i]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+						if (onlinemask[i] & (1 << j))
+							nlm_cpu_vc_mask[id] = 0xf;
+					}
+				}
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = 3; j >= 0; j--) {
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
+					}
+				}
+			}
+		}
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE; i++) {
+			if (onlinemask[i]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE; j++, id++) {
+					if (onlinemask[i] & (1 << j))
+						nlm_cpu_vc_mask[id] = 0xf;
+				}
+			}
+		}
+	}
+}
+
+void initialize_cpumask_new_9xx(int node, big_mask_t *onlinemask)
+{
+	onlinemask->map[node][0] = 0xffffffffffffffff;	/* 64 cpu */
+	onlinemask->map[node][1] = 0xffff;		/* 16 cpu */	
+}
+
+static void parse_fmn_config_9xx(void)
+{
+	uint32_t node_vc_mask[NLM_MAX_COREPAIR_PER_NODE_9XX] = {0};
+	unsigned char buf[30];
+	int i, j, id=0, k, tmp;
+	void *node;
+	big_mask_t onlinemask;
+
+	for(i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+		initialize_cpumask_new_9xx(i, &onlinemask);
+	}
+
+	node = finddevice("/doms/dom@0/fmn");
+	if (node) {
+		for (i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+			sprintf(buf, "node_%d_vc_mask",i);
+			memset(&node_vc_mask, 0, sizeof(node_vc_mask));
+			if (getprop(node, buf, &node_vc_mask, sizeof(node_vc_mask)) < 0) {
+				/* If no mask is passed, derive it from cpu online mask */
+				if (onlinemask.map[i][0] || onlinemask.map[i][1]) {
+					for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
+						if(j < 64) {
+							if (onlinemask.map[i][0] & (1 << j))
+								nlm_cpu_vc_mask[id] = 0xf;
+						}
+						else {
+							if (onlinemask.map[i][1] & (1 << j))
+								nlm_cpu_vc_mask[id] = 0xf;
+						}
+					}
+				}
+			}
+			else {	/* Get vc mask from the fdt */
+				for (j = (NLM_MAX_COREPAIR_PER_NODE_9XX - 1); j >= 0; j--) {
+					tmp = fdt32_to_cpu(node_vc_mask[j]);
+					for (k = 0; k < 8; k++) {
+						nlm_cpu_vc_mask[id++] = (tmp >> (k * 4)) & 0xf;
+					}
+				}
+			}
+		}
+	}
+	else {	/* Derive vc mask from cpu online map */
+		for (i = 0; i < NLM_MAX_CPU_NODE_9XX; i++) {
+			if (onlinemask.map[i][0] || onlinemask.map[i][1]) {
+				for (j = 0; j < NLM_MAX_CPU_PER_NODE_9XX; j++, id++) {
+					if(j < 64) {
+						if (onlinemask.map[i][0] & (1 << j))
+							nlm_cpu_vc_mask[id] = 0xf;
+					}
+					else {
+						if (onlinemask.map[i][1] & (1 << j))
+							nlm_cpu_vc_mask[id] = 0xf;
+					}
+				}
+			}
+		}
+	}
+}
+
+int nae_rx_vc = -1, nae_fb_vc = -1;
+int sae_rx_vc = -1, sae_rx_sync_vc = -1;
+int ipsec_async_vc = -1, ipsec_sync_vc = -1;
+static void parse_fdt_sae_vc_config(void)
+{
+	void *node;
+	void * valid_node;
+	int i;
+	int num_nodes = 1;
+	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX];
+
+	node = finddevice("/doms/dom@0/cpu");
+	if(node) {
+		if (getprop(node, "nae-rx-vc", &nae_rx_vc, 4) > 0)
+                        nae_rx_vc = fdt32_to_cpu(nae_rx_vc);
+
+		if (getprop(node, "nae-fb-vc", &nae_fb_vc, 4) > 0)
+                        nae_fb_vc = fdt32_to_cpu(nae_fb_vc);
+
+		if (getprop(node, "napi-vc-mask", &xlp_napi_vc_mask, 4) > 0)
+			xlp_napi_vc_mask = fdt32_to_cpu(xlp_napi_vc_mask);
+
+		if (getprop(node, "sae-rx-vc", &sae_rx_vc, 4) > 0)
+			sae_rx_vc = fdt32_to_cpu(sae_rx_vc);
+
+		if (getprop(node, "sae-rx-sync-vc", &sae_rx_sync_vc, 4) > 0)
+			sae_rx_sync_vc = fdt32_to_cpu(sae_rx_sync_vc);
+
+		if (getprop(node, "ipsec-async-vc", &ipsec_async_vc, 4) > 0)
+			ipsec_async_vc = fdt32_to_cpu(ipsec_async_vc);
+
+		if (getprop(node, "ipsec-sync-vc", &ipsec_sync_vc, 4) > 0)
+			ipsec_sync_vc = fdt32_to_cpu(ipsec_sync_vc);
+
+		valid_node  = finddevice("/soc/nodes");
+
+		if (getprop(valid_node, "num-nodes", &num_nodes, 4) > 0 )
+			num_nodes = fdt32_to_cpu(num_nodes);
+
+		for(i =0 ; i < num_nodes*NLM_MAX_CPU_PER_NODE; i++) {
+			if(nlm_cpu_vc_mask[i] & (1 << ipsec_sync_vc)) {
+				ipsec_sync_vc = -1;
+			}
+
+		}
+	}
+	pr_info("parse fdt node %p\n", node);
+
+	return;
+}
+/* from smp.c */
+
+static long fmn_config(void *arg)
+{
+        pr_info("Doing fmn init from cpu %d for node %d fdt %p\n", hard_smp_processor_id(), (int)(long)arg, fdt);
+        nlm_hal_fmn_init(fdt, (int)(long)arg);
+        return 0;
+}
+
+static int __init nlm_fmn_init(void)
+{
+        int node, rv;
+	int node_exist[8] = {1, 0, 0, 0, 0, 0, 0, 0};
+	int max_nodes = NLM_MAX_NODES;
+
+	if(is_nlm_xlp9xx())
+		max_nodes = NLM_MAX_CPU_NODE_9XX;
+
+        /* Better to do node level fmn initialization */
+        if(get_dom_fmn_node_ownership(fdt, 0)) {
+                for(node = 0; node < max_nodes; node++) {
+                        if(!node_exist[node])
+                                continue;
+                        rv = work_on_cpu(node_exist[node] >> 16, fmn_config, (void *)(long)node);
+                        if(rv < 0)
+                                panic("Fmn init failed\n");
+                }
+        } else
+                printk("Skipping FMN initialization due to lack of ownership\n");
+
+        /* Enable vc interupts for the online cpus */
+	if(is_nlm_xlp9xx()) {
+		nlm_enable_vc_intr_9xx();
+	}
+	else {
+		nlm_enable_vc_intr();
+	}
+
+        return 0;
+
+}
+
+EXPORT_SYMBOL(nae_rx_vc);
+EXPORT_SYMBOL(nae_fb_vc);
+EXPORT_SYMBOL(sae_rx_vc);
+EXPORT_SYMBOL(sae_rx_sync_vc);
+EXPORT_SYMBOL(ipsec_async_vc);
+EXPORT_SYMBOL(ipsec_sync_vc);
+
+extern void *initial_boot_params;
+static int __init on_chip_init(void)
+{
+	int i = 0, j = 0;
+	u8 node;
+
+	fdt = initial_boot_params;
+	if (fdt == NULL) {
+		pr_err("Null FDT blob\n");
+		return -ENODEV;
+	}
+	pr_info("Init at %p\n", fdt);
+	fdt_init(fdt);
+
+	cpumask_clear(&phys_cpu_present_map);
+	for_each_possible_cpu(i)
+		cpumask_set_cpu(cpu_logical_map(i), &phys_cpu_present_map);
+
+	is_cpu_core_xlp_ii = is_nlm_xlp2xx() | is_nlm_xlp9xx() ;
+	node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	nlm_proc_setup();
+
+	if(is_nlm_xlp9xx()) {
+		parse_fmn_config_9xx();
+	}
+	else {
+		parse_fmn_config();
+	}
+	pr_info("parse done\n");
+
+	parse_fdt_sae_vc_config();
+	pr_info("parse vc done\n");
+
+	/* Set netlogic_io_base to the run time value */
+#ifdef CONFIG_XLP_FMN_SUPPORT
+	spin_lock_init(&msgrng_lock);
+
+	msgring_registered.value = 0;
+#endif
+
+	nlm_hal_init();
+
+	for (i = 0; i < NR_CPUS; i++)
+		for (j = 0; j < NLM_MAX_COUNTERS; j++)
+			atomic_set(&nlm_common_counters[i][j], 0);
+
+#ifdef CONFIG_XLP_FMN_SUPPORT
+	on_each_cpu(enable_msgconfig_int, 0, 1);
+
+	if (is_nlm_xlp2xx())
+		vc_to_handle = xlp2xx_vc_to_handle_map;
+	else if (is_nlm_xlp3xx())
+		vc_to_handle = xlp3xx_vc_to_handle_map;
+	else if (is_nlm_xlp9xx())
+		vc_to_handle = xlp9xx_vc_to_handle_map;
+	else
+		vc_to_handle = vc_to_handle_map;
+
+	if(xlp_napi_vc_mask)
+		xlp_napi_fmn_setup();
+#endif
+
+	nlm_fmn_init();
+
+	msgring_irq_init();
+	return 0;
+}
+
+module_init(on_chip_init);
+MODULE_AUTHOR("Broadcom ");
+MODULE_DESCRIPTION("NAE driver advanced features ");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.1");
+
diff --git a/drivers/netlogic/soc_interface/ops.h b/drivers/netlogic/soc_interface/ops.h
new file mode 100644
index 0000000..c58c196
--- /dev/null
+++ b/drivers/netlogic/soc_interface/ops.h
@@ -0,0 +1,265 @@
+/*
+ * Global definition of all the bootwrapper operations.
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef _PPC_BOOT_OPS_H_
+#define _PPC_BOOT_OPS_H_
+
+
+//#define	COMMAND_LINE_SIZE	512
+#define	MAX_PATH_LEN		256
+#define	MAX_PROP_LEN		256 /* What should this be? */
+
+typedef void (*kernel_entry_t)(unsigned long r3, unsigned long r4, void *r5);
+
+/* Platform specific operations */
+struct platform_ops {
+	void	(*fixups)(void);
+	void	(*image_hdr)(const void *);
+	void *	(*malloc)(unsigned long size);
+	void	(*free)(void *ptr);
+	void *	(*realloc)(void *ptr, unsigned long size);
+	void	(*exit)(void);
+	void *	(*vmlinux_alloc)(unsigned long size);
+};
+extern struct platform_ops platform_ops;
+
+/* Device Tree operations */
+struct dt_ops {
+	void *	(*finddevice)(const char *name);
+	int	(*getprop)(const void *phandle, const char *name, void *buf,
+			const int buflen);
+	int	(*setprop)(const void *phandle, const char *name,
+			const void *buf, const int buflen);
+	int (*del_node)(const void *phandle);
+	void *(*get_parent)(const void *phandle);
+	/* The node must not already exist. */
+	void *(*create_node)(const void *parent, const char *name);
+	void *(*find_node_by_prop_value)(const void *prev,
+	                                 const char *propname,
+	                                 const char *propval, int proplen);
+	void *(*find_node_by_compatible)(const void *prev,
+	                                 const char *compat);
+	unsigned long (*finalize)(void);
+	char *(*get_path)(const void *phandle, char *buf, int len);
+	int (*check_header)(void);
+};
+extern struct dt_ops dt_ops;
+
+/* Console operations */
+struct console_ops {
+	int		(*open)(void);
+	void	(*write)(const char *buf, int len);
+	void	(*edit_cmdline)(char *buf, int len);
+	void	(*close)(void);
+	void	*data;
+};
+extern struct console_ops console_ops;
+
+/* Serial console operations */
+struct serial_console_data {
+	int		(*open)(void);
+	void	(*putc)(unsigned char c);
+	unsigned char	(*getc)(void);
+	unsigned char		(*tstc)(void);
+	void	(*close)(void);
+};
+
+struct loader_info {
+	void *promptr;
+	unsigned long initrd_addr, initrd_size;
+	char *cmdline;
+	int cmdline_len;
+};
+extern struct loader_info loader_info;
+
+void start(void);
+void *fdt_init(void *blob);
+//int serial_console_init(void);
+int ns16550_console_init(void *devp, struct serial_console_data *scdp);
+void *simple_alloc_init(char *base, unsigned long heap_size,
+			unsigned long granularity, unsigned long max_allocs);
+extern void flush_cache(void *, unsigned long);
+int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size);
+int dt_xlate_addr(void *node, unsigned int *buf, int buflen, unsigned long *xlated_addr);
+int dt_is_compatible(void *node, const char *compat);
+void dt_get_reg_format(void *node, unsigned int *naddr, unsigned int *nsize);
+int dt_get_virtual_reg(void *node, void **addr, int nres);
+
+
+static inline void *finddevice(const char *name)
+{
+	return (dt_ops.finddevice) ? dt_ops.finddevice(name) : NULL;
+}
+
+static inline int getprop(void *devp, const char *name, void *buf, int buflen)
+{
+	return (dt_ops.getprop) ? dt_ops.getprop(devp, name, buf, buflen) : -1;
+}
+
+static inline int setprop(void *devp, const char *name,
+                          const void *buf, int buflen)
+{
+	return (dt_ops.setprop) ? dt_ops.setprop(devp, name, buf, buflen) : -1;
+}
+#define setprop_val(devp, name, val) \
+	do { \
+		typeof(val) x = (val); \
+		setprop((devp), (name), &x, sizeof(x)); \
+	} while (0)
+
+static inline int setprop_str(void *devp, const char *name, const char *buf)
+{
+	if (dt_ops.setprop)
+		return dt_ops.setprop(devp, name, buf, strlen(buf) + 1);
+
+	return -1;
+}
+
+static inline int del_node(const void *devp)
+{
+	return dt_ops.del_node ? dt_ops.del_node(devp) : -1;
+}
+
+static inline void *get_parent(const char *devp)
+{
+	return dt_ops.get_parent ? dt_ops.get_parent(devp) : NULL;
+}
+
+static inline void *create_node(const void *parent, const char *name)
+{
+	return dt_ops.create_node ? dt_ops.create_node(parent, name) : NULL;
+}
+
+
+static inline void *find_node_by_prop_value(const void *prev,
+                                            const char *propname,
+                                            const char *propval, int proplen)
+{
+	if (dt_ops.find_node_by_prop_value)
+		return dt_ops.find_node_by_prop_value(prev, propname,
+		                                      propval, proplen);
+
+	return NULL;
+}
+
+static inline void *find_node_by_prop_value_str(const void *prev,
+                                                const char *propname,
+                                                const char *propval)
+{
+	return find_node_by_prop_value(prev, propname, propval,
+	                               strlen(propval) + 1);
+}
+
+static inline void *find_node_by_devtype(const void *prev,
+                                         const char *type)
+{
+	return find_node_by_prop_value_str(prev, "device_type", type);
+}
+
+static inline void *find_node_by_alias(const char *alias)
+{
+	void *devp = finddevice("/aliases");
+
+	if (devp) {
+		char path[MAX_PATH_LEN];
+		if (getprop(devp, alias, path, MAX_PATH_LEN) > 0)
+			return finddevice(path);
+	}
+
+	return NULL;
+}
+
+static inline void *find_node_by_compatible(const void *prev,
+                                            const char *compat)
+{
+	if (dt_ops.find_node_by_compatible)
+		return dt_ops.find_node_by_compatible(prev, compat);
+
+	return NULL;
+}
+
+static inline int check_header(void)
+{
+	if (dt_ops.check_header)
+		return dt_ops.check_header();
+	return -1;
+}
+
+void dt_fixup_memory(unsigned long long start, unsigned long long size);
+void dt_fixup_cpu_clocks(unsigned int cpufreq, unsigned int tbfreq, unsigned int busfreq);
+void dt_fixup_clock(const char *path, unsigned int freq);
+void dt_fixup_mac_address_by_alias(const char *alias, const unsigned char *addr);
+void dt_fixup_mac_address(unsigned int index, const unsigned char *addr);
+void __dt_fixup_mac_addresses(unsigned int startindex, ...);
+#define dt_fixup_mac_addresses(...) \
+	__dt_fixup_mac_addresses(0, __VA_ARGS__, NULL)
+
+
+static inline void *find_node_by_linuxphandle(const unsigned int linuxphandle)
+{
+	return find_node_by_prop_value(NULL, "linux,phandle",
+			(char *)&linuxphandle, sizeof(unsigned int));
+}
+
+static inline char *get_path(const void *phandle, char *buf, int len)
+{
+	if (dt_ops.get_path)
+		return dt_ops.get_path(phandle, buf, len);
+
+	return NULL;
+}
+
+static inline void *malloc(unsigned long size)
+{
+	return (platform_ops.malloc) ? platform_ops.malloc(size) : NULL;
+}
+
+static inline void free(void *ptr)
+{
+	if (platform_ops.free)
+		platform_ops.free(ptr);
+}
+
+static inline void exit(void)
+{
+	if (platform_ops.exit)
+		platform_ops.exit();
+	for(;;);
+}
+#define fatal(args...) { printf(args); exit(); }
+
+
+#define BSS_STACK(size) \
+	static char _bss_stack[size]; \
+	void *_platform_stack_top = _bss_stack + sizeof(_bss_stack);
+
+extern unsigned long timebase_period_ns;
+//void udelay(long delay);
+#if 0
+extern char _start[];
+extern char __bss_start[];
+extern char _end[];
+extern char _vmlinux_start[];
+extern char _vmlinux_end[];
+extern char _initrd_start[];
+extern char _initrd_end[];
+extern char _dtb_start[];
+extern char _dtb_end[];
+
+static inline __attribute__((const))
+int __ilog2_u32(unsigned int n)
+{
+	int bit;
+	asm ("cntlzw %0,%1" : "=r" (bit) : "r" (n));
+	return 31 - bit;
+}
+#endif
+
+#endif /* _PPC_BOOT_OPS_H_ */
-- 
1.7.9.5

