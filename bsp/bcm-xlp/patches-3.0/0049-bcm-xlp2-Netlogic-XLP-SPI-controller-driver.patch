From 2a3addcf44100cf0506b39159d2bd12e70a8738a Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 19:46:10 +0800
Subject: [PATCH 49/58] bcm-xlp2: Netlogic XLP SPI controller driver

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/spi/Kconfig   |   11 ++
 drivers/spi/Makefile  |    1 +
 drivers/spi/spi-xlp.c |  480 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 492 insertions(+)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 92a9345..fa4dd83 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -480,6 +480,17 @@ config SPI_XILINX
 
 	  Or for the DS570, see "XPS Serial Peripheral Interface (SPI) (v2.00b)"
 
+config SPI_XLP
+	tristate "Netlogic XLP SPI controller driver"
+	depends on CPU_XLP
+	help
+	  Enable support for the SPI controller on the Netlogic XLP SoCs.
+	  This driver provides basic support for SPI master controller.
+	  If you have a Netlogic XLP platform say Y here.
+
+	  If unsure, say N.
+
+
 config SPI_NUC900
 	tristate "Nuvoton NUC900 series SPI"
 	depends on ARCH_W90X900
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 33f9c09..2a4fda1 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -74,3 +74,4 @@ obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
 obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
 obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
+obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
diff --git a/drivers/spi/spi-xlp.c b/drivers/spi/spi-xlp.c
new file mode 100644
index 0000000..22ebf96
--- /dev/null
+++ b/drivers/spi/spi-xlp.c
@@ -0,0 +1,480 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#define XLP_SPI_CONFIG			0x40
+#define XLP_SPI_CPHA			BIT(0)
+#define XLP_SPI_CPOL			BIT(1)
+#define XLP_SPI_CS_POL			BIT(2)
+#define XLP_SPI_TXMISO_EN		BIT(3)
+#define XLP_SPI_TXMOSI_EN		BIT(4)
+#define XLP_SPI_RXMISO_EN		BIT(5)
+#define XLP_SPI_CS_LSBFE		BIT(10)
+#define XLP_SPI_RXCAP_EV		BIT(11)
+
+#define XLP_SPI_FDIV			0x41
+#define XLP_SPI_CMD			0x42
+#define XLP_SPI_CMD_IDLE_MASK		0x0
+#define XLP_SPI_CMD_TX_MASK		0x1
+#define XLP_SPI_CMD_RX_MASK		0x2
+#define XLP_SPI_CMD_TXRX_MASK		0x3
+#define XLP_SPI_CMD_CONT		BIT(4)
+#define XLP_SPI_XFR_BITCNT_SHIFT	16
+
+#define XLP_SPI_STATUS			0x43
+#define XLP_SPI_XFR_PENDING		BIT(0)
+#define XLP_SPI_XFR_DONE		BIT(1)
+#define XLP_SPI_TX_TH_OV		BIT(2)
+#define XLP_SPI_RX_TH_OV		BIT(3)
+#define XLP_SPI_TX_UF			BIT(4)
+#define XLP_SPI_RX_OF			BIT(5)
+
+#define XLP_SPI_INTR_EN			0x44
+#define XLP_SPI_INTR_DONE		BIT(0)
+#define XLP_SPI_INTR_MASK		0x1f
+
+#define XLP_SPI_FIFO_THRESH		0x45
+#define XLP_SPI_RXFIFO_THRESH_SHIFT	0
+#define XLP_SPI_TXFIFO_THRESH_SHIFT	4
+
+#define XLP_SPI_FIFO_WCNT		0x46
+#define XLP_SPI_RXFIFO_WCNT_SHIFT	0
+#define XLP_SPI_TXFIFO_WCNT_SHIFT	4
+#define XLP_SPI_FIFO_WCNT_MASK		0xf
+
+#define XLP_SPI_TXDATA_FIFO		0x47
+#define XLP_SPI_RXDATA_FIFO		0x48
+#define XLP_SPI_SYSCTRL			0x80
+#define XLP_SPI_SYS_RESET		BIT(0)
+#define XLP_SPI_SYS_CLKDIS		BIT(1)
+#define XLP_SPI_SYS_PMEN		BIT(8)
+
+#define XLP_SPI_MAX_XFER_SIZE		0x1000
+#define SPI_CHAN_OFFSET			0x10
+#define DEFAULT_CS_FDIV			0x10
+#define XLP_SPI_FIFO_SIZE		8
+#define XLP_SPI_MAX_CS			4
+
+struct xlp_spi_priv {
+	struct spi_master	*master;
+	void __iomem		*base;
+	/* data buffers */
+	unsigned char		*rx_buf;
+	const unsigned char	*tx_buf;
+	int			tx_len;
+	int			rx_len;
+	struct device		*dev;
+	int			cs;
+	bool			cmd_cont;
+	struct completion	done;
+};
+
+static inline int xlp_spi_reg_read(struct xlp_spi_priv *priv,
+					int cs, int regidx)
+{
+	void __iomem *addr;
+
+	regidx += cs * SPI_CHAN_OFFSET;
+	addr = priv->base + (regidx << 2);
+	return readl(addr);
+}
+
+static inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,
+		int regidx, u32 val)
+{
+	void __iomem *addr;
+
+	regidx += cs * SPI_CHAN_OFFSET;
+	addr = priv->base + (regidx << 2);
+	writel(val, addr);
+}
+
+/* reset all spi channels */
+static void xlp_spi_slave_reset(struct xlp_spi_priv *xspi)
+{
+	int cs;
+
+	for (cs = 0; cs < XLP_SPI_MAX_CS; cs++)
+		xlp_spi_reg_write(xspi, 0, XLP_SPI_SYSCTRL,
+				(XLP_SPI_SYS_RESET << cs));
+}
+
+static int xlp_spi_check_transfer(struct spi_device *spi,
+		struct spi_transfer *t)
+{
+	u8 bits_per_word;
+
+	bits_per_word = spi->bits_per_word;
+	if (t && t->bits_per_word)
+		bits_per_word = t->bits_per_word;
+
+	if (bits_per_word != 8) {
+		dev_err(&spi->dev, "unsupported bits_per_word %d\n",
+				bits_per_word);
+		return -EINVAL;
+	}
+
+	if (spi->chip_select > spi->master->num_chipselect) {
+		dev_err(&spi->dev, "unsupported slave %d\n", spi->chip_select);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xlp_spi_setup(struct spi_device *spi)
+{
+	struct xlp_spi_priv *xspi;
+	int cfg;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	if (xlp_spi_check_transfer(spi, NULL) < 0)
+		return -EINVAL;
+
+	xspi = spi_master_get_devdata(spi->master);
+	xspi->cs = spi->chip_select;
+
+	/* Enable pin muxing. In this mode, the GPIO[28:22] external pins
+	 * are configured for SPI operations.
+	 */
+	xlp_spi_reg_write(xspi, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_FIFO_THRESH, 0x80);
+
+	cfg = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_CONFIG);
+	if (spi->mode & XLP_SPI_CPHA)
+		cfg |= XLP_SPI_CPHA;
+	if (spi->mode & XLP_SPI_CPOL)
+		cfg |= XLP_SPI_CPOL;
+	if ((spi->mode & SPI_CS_HIGH))
+		cfg |= XLP_SPI_CS_POL;
+	if (spi->mode & SPI_LSB_FIRST)
+		cfg |= XLP_SPI_CS_LSBFE;
+
+	cfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN;
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CONFIG, cfg);
+
+	return 0;
+}
+
+static void xlp_spi_read_rxfifo(struct xlp_spi_priv *xspi)
+{
+	uint32_t rx_data;
+	int i, j, limit, rxfifo_cnt;
+
+	rxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs,
+			XLP_SPI_FIFO_WCNT);
+	rxfifo_cnt = rxfifo_cnt & XLP_SPI_FIFO_WCNT_MASK;
+
+	while (rxfifo_cnt) {
+		rx_data = xlp_spi_reg_read(xspi, xspi->cs,
+				XLP_SPI_RXDATA_FIFO);
+		rxfifo_cnt--;
+
+		j = 0;
+
+		limit = xspi->rx_len > 3 ? 3 : xspi->rx_len - 1;
+		for (i = limit; i >= 0; i--) {
+			xspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;
+			j++;
+		}
+		xspi->rx_len -= (limit + 1);
+		xspi->rx_buf += (limit + 1);
+	}
+}
+
+static void xlp_spi_fill_txfifo(struct xlp_spi_priv *xspi)
+{
+	uint32_t tx_data;
+	int i, j, txfifo_cnt, limit;
+
+	txfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
+	txfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_SHIFT;
+	txfifo_cnt &= XLP_SPI_FIFO_WCNT_MASK;
+
+	while ((xspi->tx_len) && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {
+		j = 0;
+		tx_data = 0;
+
+		limit = xspi->tx_len > 3 ? 3 : xspi->tx_len - 1;
+		for (i = limit; i >= 0; i--) {
+			tx_data |= xspi->tx_buf[i] << (j * 8);
+			j++;
+		}
+
+		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
+
+		xspi->tx_len -= (limit + 1);
+		xspi->tx_buf += (limit + 1);
+		txfifo_cnt++;
+	}
+}
+
+static void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,
+		int cmd_cont)
+{
+	int val = 0;
+
+	if (xspi->tx_buf)
+		val |= XLP_SPI_CMD_TX_MASK;
+	if (xspi->rx_buf)
+		val |= XLP_SPI_CMD_RX_MASK;
+	if (cmd_cont)
+		val |= XLP_SPI_CMD_CONT;
+	if (xfer_len) {
+		val |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_SHIFT);
+		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, val);
+	}
+}
+
+/* wait for transfer status done */
+static inline int xlp_spi_wait_xfer_done(struct xlp_spi_priv *xspi)
+{
+	unsigned long timeout, stoptime, checktime;
+	int timedout;
+	u32 status;
+
+	timeout = msecs_to_jiffies(500);
+	stoptime = jiffies + timeout;
+	timedout = 0;
+
+	while (!timedout) {
+		checktime = jiffies;
+		status = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS);
+
+		if (status & XLP_SPI_XFR_DONE)
+			return 0;
+		timedout = time_after(checktime, stoptime);
+
+		if (timedout)
+			break;
+	}
+	return -ETIMEDOUT;
+}
+
+static int xlp_spi_xfer_block(struct spi_device *spi, struct spi_transfer *t,
+		int xfer_len, int cmd_cont)
+{
+	struct xlp_spi_priv *xs = spi_master_get_devdata(spi->master);
+	int ret;
+
+	xs->rx_buf = NULL;
+	xs->tx_buf = NULL;
+
+	xs->tx_buf = t->tx_buf;
+	xs->rx_buf = t->rx_buf;
+
+	xs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;
+	xs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;
+
+	/* fill TXDATA_FIFO, then send the CMD */
+	if (xs->tx_len)
+		xlp_spi_fill_txfifo(xs);
+
+	xlp_spi_send_cmd(xs, xfer_len, cmd_cont);
+
+	while (xs->tx_len || xs->rx_len) {
+		if (xs->rx_len)
+			xlp_spi_read_rxfifo(xs);
+
+		if (xs->tx_len)
+			xlp_spi_fill_txfifo(xs);
+	}
+
+	ret = xlp_spi_wait_xfer_done(xs);
+	if (ret) {
+		pr_info("spi%d: xfer timedout!!\n", xs->cs);
+		return ret;
+	}
+
+	return xfer_len;
+}
+
+static int xlp_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	int ret, len, total_len;
+	struct xlp_spi_priv *xs = spi_master_get_devdata(spi->master);
+
+	ret = 0;
+	total_len = 0;
+	len = t->len;
+	while (len > XLP_SPI_MAX_XFER_SIZE) {
+		ret = xlp_spi_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE, 1);
+		if (ret < 0)
+			return ret;
+		else
+			total_len += ret;
+
+		len = len - XLP_SPI_MAX_XFER_SIZE;
+		if (t->tx_buf)
+			t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+		if (t->rx_buf)
+			t->rx_buf = t->rx_buf + XLP_SPI_MAX_XFER_SIZE;
+	}
+	if (len) {
+		ret = xlp_spi_xfer_block(spi, t, len, xs->cmd_cont);
+		if (ret < 0)
+			return ret;
+		else
+			total_len += ret;
+	}
+
+	return total_len;
+}
+
+static int xlp_spi_transfer_one(struct spi_master *master,
+					struct spi_message *msg)
+{
+	struct spi_transfer *t;
+	struct spi_device *spi = msg->spi;
+	struct xlp_spi_priv *xspi = spi_master_get_devdata(spi->master);
+	int status, r;
+
+	status = 0;
+	r = 0;
+	xspi->cs = spi->chip_select;
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+		status = xlp_spi_check_transfer(spi, t);
+		if (status)
+			goto err;
+
+		xspi->cmd_cont = 0;
+		if (t->len) {
+			if (!(t->transfer_list.next == &msg->transfers))
+				xspi->cmd_cont = 1;
+			r = xlp_spi_txrx_bufs(spi, t);
+		}
+
+		if (r != t->len || r < 0) {
+			if (r > 0)
+				status = -EREMOTEIO;
+
+			goto err;
+		} else
+			msg->actual_length += r;
+	}
+err:
+	msg->status = status;
+	spi_finalize_current_message(master);
+
+	return status;
+}
+
+static int xlp_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct xlp_spi_priv *xspi;
+	struct resource *res;
+	int ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
+	if (!master) {
+		dev_err(&pdev->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	xspi = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, master);
+
+	xspi->master = master;
+
+	master->bus_num = 0;
+	master->num_chipselect = XLP_SPI_MAX_CS;
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+	master->setup = xlp_spi_setup;
+	master->transfer_one_message = xlp_spi_transfer_one;
+	master->dev.of_node = pdev->dev.of_node;
+
+	init_completion(&xspi->done);
+
+	xspi->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (xspi->base == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+	xlp_spi_slave_reset(xspi);
+	/* register our spi controller */
+	ret = spi_register_master(master);
+	if (ret) {
+		dev_err(&pdev->dev, "spi register master failed!\n");
+		goto put_master;
+	}
+
+	return 0;
+
+put_master:
+	spi_master_put(master);
+	return ret;
+}
+
+static int xlp_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master;
+
+	master = platform_get_drvdata(pdev);
+	platform_set_drvdata(pdev, 0);
+	spi_unregister_master(master);
+	spi_master_put(master);
+
+	return 0;
+}
+
+static struct of_device_id xlp_spi_dt_id[] = {
+	{ .compatible = "netlogic,xlp-spi" },
+};
+
+static struct platform_driver xlp_spi_driver = {
+	.probe	= xlp_spi_probe,
+	.remove	= xlp_spi_remove,
+	.driver = {
+		.name	= "xlp-spi",
+		.owner	= THIS_MODULE,
+		.of_match_table = xlp_spi_dt_id,
+	},
+};
+module_platform_driver(xlp_spi_driver);
+
+MODULE_AUTHOR("Kamlakant Patel <kamlakant.patel@broadcom.com>");
+MODULE_DESCRIPTION("Netlogic XLP SPI controller driver");
+MODULE_LICENSE("GPL v2");
-- 
1.7.9.5

