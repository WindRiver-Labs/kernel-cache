From 263e451fdc8ca4ad79ae2e405462f8b8e879cde8 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 Mar 2014 15:54:29 +0800
Subject: [PATCH] bcm-xlp: use the unsleep raw spinlock in mmc driver

replace the spin_lock/unlock with raw_spin_lock/unlock

otherwise we get the following message:

Freeing unused kernel memory: 704K (ffffffffc0c90000 - ffffffffc0d40000)
udevd[484]: starting version 182
BUG: sleeping function called from invalid context at kernel/rtmutex.c:659
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Preemption disabled at:[<          (null)>]           (null)

CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.10.19-rt11-WR6.0.0.0_preempt-rt #26
Stack : 0000000000000000 000000000000004f 0000000000000000 0000000000000000
      0000000000000004 ffffffffc0c20000 0000000000000000 0000000000000000
      ffffffffc0f90000 0000000000000000 000000000000004f 0000000000000006
      ffffffffc0b2f890 ffffffffc02262b0 0000000000000000 0000000000000000
      0000000000000000 0000000000000000 ffffffffc0f70000 ffffffffc0f70000
      ffffffffc0a7f0d8 ffffffffc0c1d8f7 ffffffffc0f6ade8 ffffffffc0c1dd90
      0000000000000000 0000000000000000 ffffffffc0b32c80 c0000000bb9a3c60
      ffffffffc0b2f910 ffffffffc0b2f820 ffffffffc0b2f938 ffffffffc0977d78
      ffffffffc0b2f970 ffffffffc0227f48 ffffffffc0c1d9f0 ffffffffc0a7f0d8
      0000000000000000 ffffffffc01f9158 0000000000000000 0000000000000000
      ...
Call Trace:
[<ffffffffc01f9158>] show_stack+0xd8/0xf8
[<ffffffffc0977d78>] rt_spin_lock+0x38/0x98
[<ffffffffc07ba554>] sdhci_irq+0x54/0x8a0
[<ffffffffc02b5c4c>] handle_irq_event_percpu+0xa4/0x328
[<ffffffffc02b5f54>] handle_irq_event+0x84/0xe0
[<ffffffffc02b9ecc>] handle_level_irq+0xe4/0x1a8
[<ffffffffc02b4fd4>] generic_handle_irq+0x54/0x88
[<ffffffffc0978ab4>] do_IRQ+0x2c/0x40
[<ffffffffc01f3740>] ret_from_irq+0x0/0x4
[<ffffffffc0261974>] finish_task_switch.isra.72+0x5c/0x138
[<ffffffffc09760c4>] __schedule+0x3ac/0x670
[<ffffffffc09763cc>] schedule+0x44/0xe8
[<ffffffffc0976b4c>] schedule_preempt_disabled+0x2c/0x48
[<ffffffffc0279e5c>] cpu_startup_entry+0x154/0x2e8
[<ffffffffc0c90af0>] start_kernel+0x4a8/0x4c8

Signed-off-by: Jack Tan <jack.tan@windriver.com>

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index c40396f23202..f4e9e5b5fb06 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -871,15 +871,15 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	might_sleep();
 
 	add_wait_queue(&host->wq, &wait);
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
 		if (stop || !host->claimed || host->claimer == current)
 			break;
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
 	if (!stop) {
@@ -888,7 +888,7 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 		host->claim_cnt += 1;
 	} else
 		wake_up(&host->wq);
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
 	if (host->ops->enable && !stop && host->claim_cnt == 1)
 		host->ops->enable(host);
@@ -908,14 +908,14 @@ int mmc_try_claim_host(struct mmc_host *host)
 	int claimed_host = 0;
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	if (!host->claimed || host->claimer == current) {
 		host->claimed = 1;
 		host->claimer = current;
 		host->claim_cnt += 1;
 		claimed_host = 1;
 	}
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
 		host->ops->enable(host);
 	return claimed_host;
@@ -938,14 +938,14 @@ void mmc_release_host(struct mmc_host *host)
 	if (host->ops->disable && host->claim_cnt == 1)
 		host->ops->disable(host);
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	if (--host->claim_cnt) {
 		/* Release for nested claim */
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 	} else {
 		host->claimed = 0;
 		host->claimer = NULL;
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		wake_up(&host->wq);
 	}
 }
@@ -1571,9 +1571,9 @@ static inline void mmc_bus_get(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	host->bus_refs++;
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1584,11 +1584,11 @@ static inline void mmc_bus_put(struct mmc_host *host)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	host->bus_refs--;
 	if ((host->bus_refs == 0) && host->bus_ops)
 		__mmc_release_bus(host);
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1604,7 +1604,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 
 	WARN_ON(!host->claimed);
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	BUG_ON(host->bus_ops);
 	BUG_ON(host->bus_refs);
@@ -1613,7 +1613,7 @@ void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)
 	host->bus_refs = 1;
 	host->bus_dead = 0;
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*
@@ -1628,11 +1628,11 @@ void mmc_detach_bus(struct mmc_host *host)
 	WARN_ON(!host->claimed);
 	WARN_ON(!host->bus_ops);
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	host->bus_dead = 1;
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	mmc_bus_put(host);
 }
@@ -1651,9 +1651,9 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	WARN_ON(host->removed);
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 #endif
 	host->detect_change = 1;
 	mmc_schedule_delayed_work(&host->detect, delay);
@@ -2427,9 +2427,9 @@ void mmc_stop_host(struct mmc_host *host)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	host->removed = 1;
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
 	host->rescan_disable = 1;
@@ -2738,9 +2738,9 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 			mmc_card_clr_doing_bkops(host->card);
 		}
 
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 1;
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
 		if (!host->bus_ops || host->bus_ops->suspend)
@@ -2761,9 +2761,9 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	case PM_POST_HIBERNATION:
 	case PM_POST_RESTORE:
 
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
 
 	}
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 2a3593d9f87d..9ab9cc747538 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -457,7 +457,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	mutex_init(&host->slot.lock);
 	host->slot.cd_irq = -EINVAL;
 
-	spin_lock_init(&host->lock);
+	raw_spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 #ifdef CONFIG_PM
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 8a66737c20e3..652a6cbdfa99 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -288,7 +288,7 @@ static void sdhci_led_control(struct led_classdev *led,
 	struct sdhci_host *host = container_of(led, struct sdhci_host, led);
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	if (host->runtime_suspended)
 		goto out;
@@ -298,7 +298,7 @@ static void sdhci_led_control(struct led_classdev *led,
 	else
 		sdhci_activate_led(host);
 out:
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 #endif
 
@@ -1318,7 +1318,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	present = mmc_gpio_get_cd(host->mmc);
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	WARN_ON(host->mrq != NULL);
 
@@ -1375,9 +1375,9 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 					mmc->card->type == MMC_TYPE_MMC ?
 					MMC_SEND_TUNING_BLOCK_HS200 :
 					MMC_SEND_TUNING_BLOCK;
-				spin_unlock_irqrestore(&host->lock, flags);
+				raw_spin_unlock_irqrestore(&host->lock, flags);
 				sdhci_execute_tuning(mmc, tuning_opcode);
-				spin_lock_irqsave(&host->lock, flags);
+				raw_spin_lock_irqsave(&host->lock, flags);
 
 				/* Restore original mmc_request structure */
 				host->mrq = mrq;
@@ -1391,7 +1391,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	}
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
@@ -1400,10 +1400,10 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	int vdd_bit = -1;
 	u8 ctrl;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD) {
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		if (host->vmmc && ios->power_mode == MMC_POWER_OFF)
 			mmc_regulator_set_ocr(host->mmc, host->vmmc, 0);
 		return;
@@ -1430,9 +1430,9 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 		vdd_bit = sdhci_set_power(host, ios->vdd);
 
 	if (host->vmmc && vdd_bit != -1) {
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		mmc_regulator_set_ocr(host->mmc, host->vmmc, vdd_bit);
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 	}
 
 	if (host->ops->platform_send_init_74_clocks)
@@ -1570,7 +1570,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 		sdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -1618,7 +1618,7 @@ static int sdhci_check_ro(struct sdhci_host *host)
 	unsigned long flags;
 	int is_readonly;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	if (host->flags & SDHCI_DEVICE_DEAD)
 		is_readonly = 0;
@@ -1628,7 +1628,7 @@ static int sdhci_check_ro(struct sdhci_host *host)
 		is_readonly = !(sdhci_readl(host, SDHCI_PRESENT_STATE)
 				& SDHCI_WRITE_PROTECT);
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	/* This quirk needs to be replaced by a callback-function later */
 	return host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT ?
@@ -1701,9 +1701,9 @@ static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	sdhci_enable_sdio_irq_nolock(host, enable);
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
@@ -1834,7 +1834,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 
 	sdhci_runtime_pm_get(host);
 	disable_irq(host->irq);
-	spin_lock(&host->lock);
+	raw_spin_lock(&host->lock);
 
 	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 
@@ -1854,7 +1854,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	    requires_tuning_nonuhs)
 		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 	else {
-		spin_unlock(&host->lock);
+		raw_spin_unlock(&host->lock);
 		enable_irq(host->irq);
 		sdhci_runtime_pm_put(host);
 		return 0;
@@ -1927,7 +1927,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		host->cmd = NULL;
 		host->mrq = NULL;
 
-		spin_unlock(&host->lock);
+		raw_spin_unlock(&host->lock);
 		enable_irq(host->irq);
 
 		/* Wait for Buffer Read Ready interrupt */
@@ -1935,7 +1935,7 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 					(host->tuning_done == 1),
 					msecs_to_jiffies(50));
 		disable_irq(host->irq);
-		spin_lock(&host->lock);
+		raw_spin_lock(&host->lock);
 
 		if (!host->tuning_done) {
 			pr_info(DRIVER_NAME ": Timeout waiting for "
@@ -2009,7 +2009,7 @@ out:
 		err = 0;
 
 	sdhci_clear_set_irqs(host, SDHCI_INT_DATA_AVAIL, ier);
-	spin_unlock(&host->lock);
+	raw_spin_unlock(&host->lock);
 	enable_irq(host->irq);
 	sdhci_runtime_pm_put(host);
 
@@ -2047,7 +2047,7 @@ static void sdhci_card_event(struct mmc_host *mmc)
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	/* Check host->mrq first in case we are runtime suspended */
 	if (host->mrq &&
@@ -2064,7 +2064,7 @@ static void sdhci_card_event(struct mmc_host *mmc)
 		tasklet_schedule(&host->finish_tasklet);
 	}
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static const struct mmc_host_ops sdhci_ops = {
@@ -2103,14 +2103,14 @@ static void sdhci_tasklet_finish(unsigned long param)
 
 	host = (struct sdhci_host*)param;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
         /*
          * If this tasklet gets rescheduled while running, it will
          * be run again afterwards but without any active request.
          */
 	if (!host->mrq) {
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 		return;
 	}
 
@@ -2148,7 +2148,7 @@ static void sdhci_tasklet_finish(unsigned long param)
 #endif
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	mmc_request_done(host->mmc, mrq);
 	sdhci_runtime_pm_put(host);
@@ -2161,7 +2161,7 @@ static void sdhci_timeout_timer(unsigned long data)
 
 	host = (struct sdhci_host*)data;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	if (host->mrq) {
 		pr_err("%s: Timeout waiting for hardware "
@@ -2182,7 +2182,7 @@ static void sdhci_timeout_timer(unsigned long data)
 	}
 
 	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 static void sdhci_tuning_timer(unsigned long data)
@@ -2192,11 +2192,11 @@ static void sdhci_tuning_timer(unsigned long data)
 
 	host = (struct sdhci_host *)data;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	host->flags |= SDHCI_NEEDS_RETUNING;
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 }
 
 /*****************************************************************************\
@@ -2391,10 +2391,10 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 	u32 intmask, unexpected = 0;
 	int cardint = 0, max_loops = 16;
 
-	spin_lock(&host->lock);
+	raw_spin_lock(&host->lock);
 
 	if (host->runtime_suspended) {
-		spin_unlock(&host->lock);
+		raw_spin_unlock(&host->lock);
 		return IRQ_NONE;
 	}
 
@@ -2474,7 +2474,7 @@ again:
 	if (intmask && --max_loops)
 		goto again;
 out:
-	spin_unlock(&host->lock);
+	raw_spin_unlock(&host->lock);
 
 	if (unexpected) {
 		pr_err("%s: Unexpected interrupt 0x%08x.\n",
@@ -2574,7 +2574,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 	}
 
 	if (!device_may_wakeup(mmc_dev(host->mmc))) {
-		ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
+		ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED | IRQF_NO_THREAD,
 				  mmc_hostname(host->mmc), host);
 		if (ret)
 			return ret;
@@ -2635,15 +2635,15 @@ int sdhci_runtime_suspend_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_NEEDS_RETUNING;
 	}
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	synchronize_irq(host->irq);
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 	host->runtime_suspended = true;
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	return ret;
 }
@@ -2669,16 +2669,16 @@ int sdhci_runtime_resume_host(struct sdhci_host *host)
 	sdhci_do_start_signal_voltage_switch(host, &host->mmc->ios);
 	if ((host_flags & SDHCI_PV_ENABLED) &&
 		!(host->quirks2 & SDHCI_QUIRK2_PRESET_VALUE_BROKEN)) {
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 		sdhci_enable_preset_value(host, true);
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 	}
 
 	/* Set the re-tuning expiration flag */
 	if (host->flags & SDHCI_USING_RETUNING_TIMER)
 		host->flags |= SDHCI_NEEDS_RETUNING;
 
-	spin_lock_irqsave(&host->lock, flags);
+	raw_spin_lock_irqsave(&host->lock, flags);
 
 	host->runtime_suspended = false;
 
@@ -2689,7 +2689,7 @@ int sdhci_runtime_resume_host(struct sdhci_host *host)
 	/* Enable Card Detection */
 	sdhci_enable_card_detection(host);
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	raw_spin_unlock_irqrestore(&host->lock, flags);
 
 	return ret;
 }
@@ -3098,7 +3098,7 @@ int sdhci_add_host(struct sdhci_host *host)
 		return -ENODEV;
 	}
 
-	spin_lock_init(&host->lock);
+	raw_spin_lock_init(&host->lock);
 
 	/*
 	 * Maximum number of segments. Depends on if the hardware
@@ -3173,7 +3173,7 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->tuning_timer.function = sdhci_tuning_timer;
 	}
 
-	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED,
+	ret = request_irq(host->irq, sdhci_irq, IRQF_SHARED | IRQF_NO_THREAD,
 		mmc_hostname(mmc), host);
 	if (ret) {
 		pr_err("%s: Failed to request IRQ %d: %d\n",
@@ -3236,7 +3236,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	unsigned long flags;
 
 	if (dead) {
-		spin_lock_irqsave(&host->lock, flags);
+		raw_spin_lock_irqsave(&host->lock, flags);
 
 		host->flags |= SDHCI_DEVICE_DEAD;
 
@@ -3248,7 +3248,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 			tasklet_schedule(&host->finish_tasklet);
 		}
 
-		spin_unlock_irqrestore(&host->lock, flags);
+		raw_spin_unlock_irqrestore(&host->lock, flags);
 	}
 
 	sdhci_disable_card_detection(host);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index e326ae2882a0..f2dd5782ca68 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -306,7 +306,7 @@ struct mmc_host {
 	unsigned int		max_discard_to;	/* max. discard timeout in ms */
 
 	/* private data */
-	spinlock_t		lock;		/* lock for claim and bus ops */
+	raw_spinlock_t		lock;		/* lock for claim and bus ops */
 
 	struct mmc_ios		ios;		/* current io bus settings */
 	u32			ocr;		/* the current OCR setting */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index b838ffc49e4a..4003cbf55080 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -113,7 +113,7 @@ struct sdhci_host {
 	char led_name[32];
 #endif
 
-	spinlock_t lock;	/* Mutex */
+	raw_spinlock_t lock;	/* Mutex */
 
 	int flags;		/* Host attributes */
 #define SDHCI_USE_SDMA		(1<<0)	/* Host is SDMA capable */
-- 
2.1.0

