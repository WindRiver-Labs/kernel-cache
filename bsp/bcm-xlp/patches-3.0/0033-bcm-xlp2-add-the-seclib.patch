From c6bc9a56e2a1ae858a495c03734dd7e1a26b76bc Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 17:38:40 +0800
Subject: [PATCH 33/58] bcm-xlp2: add the seclib

Get from SDK_DIR/libraries/seclib

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h      |  209 +++
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.c      | 1088 +++++++++++
 arch/mips/netlogic/lib/seclib/cryptosoc_lib.h      |  313 ++++
 arch/mips/netlogic/lib/seclib/eccsoc_defs.h        |  144 ++
 .../netlogic/lib/seclib/eccsoc_gen1_hal_defs.h     |  173 ++
 arch/mips/netlogic/lib/seclib/eccsoc_lib.h         | 1645 +++++++++++++++++
 arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h  |  795 ++++++++
 arch/mips/netlogic/lib/seclib/rsasoc_defs.h        |  122 ++
 .../netlogic/lib/seclib/rsasoc_gen1_hal_defs.h     |  172 ++
 arch/mips/netlogic/lib/seclib/rsasoc_lib.h         |  745 ++++++++
 arch/mips/netlogic/lib/seclib/rsasoc_ucode.h       | 1841 ++++++++++++++++++
 arch/mips/netlogic/lib/seclib/saesoc_defs.h        |  394 ++++
 .../netlogic/lib/seclib/saesoc_gen1_hal_defs.h     |  932 ++++++++++
 .../netlogic/lib/seclib/saesoc_gen2_hal_defs.h     | 1072 +++++++++++
 arch/mips/netlogic/lib/seclib/saesoc_lib.h         | 1949 ++++++++++++++++++++
 15 files changed, 11594 insertions(+)

diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h b/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h
new file mode 100644
index 0000000..f26a670
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_ctx.h
@@ -0,0 +1,209 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _CRYPTOSOC_CTX_H
+#define _CRYPTOSOC_CTX_H
+
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+
+/** 
+ * enum cryptosoc_ctx_mode - Possible modes of the context
+ * @CRYPTOSOC_CTX_MODE_SYNC_EXCL : Session is synchronous exclusive
+ * @CRYPTOSOC_CTX_MODE_SYNC_SHRD : Session is synchronous shared
+ * @CRYPTOSOC_CTX_MODE_ASYNC : Session is asynchronous
+ */
+enum cryptosoc_ctx_mode {
+	CRYPTOSOC_CTX_MODE_SYNC_EXCL,
+	CRYPTOSOC_CTX_MODE_SYNC_SHRD,
+	CRYPTOSOC_CTX_MODE_ASYNC
+};
+
+#define  fifo_full(t, nentries, h) (((t+1) % nentries) == h)
+#define  fifo_empty(t, h) (t == h)
+
+/* In async when max_msgs > 1, the message send id is specified in 52nd bit onwards
+ int the msg2 
+ 0-31(32 bits) - session id
+ 32-51(20 bits) - rsp index 
+ 52-63(12 bits) - msg index */
+
+#define CRYPTOSOC_SESSION_ID_OFF 0
+#define CRYPTOSOC_GET_SESSION_ID(x) ((unsigned long long)x & ((1ULL << 32) - 1))
+
+#define CRYPTOSOC_RSP_ID_OFF 32
+#define CRYPTOSOC_GET_RSP_ID(x) (((unsigned long long)x >> 32) & ((1ULL << 20) - 1))
+
+#define CRYPTOSOC_ASYNC_MSG_OUT_OFF 52
+#define CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(x) ((unsigned long long)x >> 52)
+
+/* increment the 16 bits of the session id portion. Not used during the 
+*  response */
+#define CRYPTOSOC_CTX_RSP_GEN_ID_MODIFY(x, val) \
+	((x & ~0xffffULL) | ((val) & 0xffff));
+
+
+
+/**
+* defines ctx_param_flags - Context specific flags
+* @CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER : Async response mode(1/0). 
+* If it is set,the response will be given to the application in the  order 
+* the request has been sent to the soc even if the result are  out of order. 
+* If it is unset, the respose will be given to the application in the order 
+* the respose has been received
+*  This is ignored if RSP_POP_BY_APP is set
+* @CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP: If this is set, the response from the 
+* engine is poped by the application instead of the interrupt handler. 
+* Interrupt on this vc should not be enabled if this is set.
+*/
+/*!defines ctx_param_flags < */
+#define CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER 	0x1
+#define CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP	0x2
+/*!defines ctx_param_flags > */
+
+/**
+* struct cryptosoc_ctx_params - Crypto(sae,rsa,ecc) soc context creation
+*  parameters 
+* @mode: Mode of the context, see cryptosoc_context_mode . 
+* @max_pending_reqs: Maximum pending requests per context for 
+*   async/sync-shared mode. If the number of requests exceeds this limit, 
+*   the call will be returned with the error codes(EAGAIN).
+* @flags : See ctx_param_flags
+*/
+struct cryptosoc_ctx_params {
+	enum cryptosoc_ctx_mode mode;
+	int max_pending_reqs;
+	unsigned int flags;
+};
+
+struct cryptosoc_rsp_msg {
+	/* operation result message from the engine */
+	volatile _uint64_t res_val;
+	/* rsp_message given in the send request time. Interrupt handler should 
+	*  increment the gen-id portion before writing this value */
+	volatile _uint64_t rsp_val;
+};	
+
+struct cryptosoc_req_msg {
+	/* rsp_usr_arg is what is user has given during the send request. 
+	*  The rsp_msg is what we send to the engine. Before the interrupt
+	*  handler writes this message, it should increment the generation id
+	*  portion of rsp_msg. We read this from the rsp before sending 
+	*  this request to assure that this entry is modified */
+	volatile _uint64_t async_rsp_usr_arg;
+	volatile _uint64_t rsp_val; 
+};
+
+
+struct cryptosoc_rsp {
+	/* Used to save responses from the engine, used in async and shared-vc 
+	*  mode */
+	struct cryptosoc_rsp_msg rsp_msg[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX]; 
+	unsigned int nrcvd; /* number of messages received by kernel */
+	unsigned int index; 
+	unsigned int sessionid;
+	unsigned int owner; /* pid, Only it can delete the context */
+	unsigned int allocated; /* whether it is allocated or not */
+	/* head & tail are pointing to the rsp_msg, 
+	*  used only if response in_order == false */
+	unsigned int head;
+	unsigned int tail;
+#ifdef NLM_HAL_LINUX_KERNEL
+	atomic_t used_by_intr; /* used by interrupt */
+#else
+	unsigned int used_by_intr;
+#endif
+	unsigned long long fdctxt;
+	char priv_data[16]; /* used by kernel*/
+};
+
+
+struct cryptosoc_ctx_priv_data {
+	unsigned int mode;
+
+	unsigned int max_pending_reqs;
+	unsigned int num_rsp_pend; /* number of pending responses */
+
+	cryptosoc_lock_t lock; /* */
+	unsigned int req_send_failure;
+
+	unsigned int req_head; /* head and tail for async operation */
+	unsigned int req_tail;
+
+	unsigned int flags;
+
+	/* used in async out-of-order processing or sync-shared mode */
+	int free_req_index[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX]; 
+
+	struct cryptosoc_req_msg req_msg[CRYPTOSOC_MAX_PENDING_REQS_PER_CTX];
+	struct cryptosoc_rsp *rsp; /* mmaped to userspace and written by the 
+								  kernel */
+};
+
+/**
+* struct cryptosoc_ctx_params - Crypto(sae,rsa,ecc) soc context parameters 
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @fd: Event file descriptor associated with this context. 
+*   Used only in async/sync-shared mode
+*/
+struct cryptosoc_ctx {
+	char lib_priv[sizeof(struct cryptosoc_ctx_priv_data)];
+	char app_priv[CRYPTOSOC_CTX_APP_PRIV_SZ];
+	int fd; 
+};
+
+extern int cryptosoc_new_context(
+		struct cryptosoc_ctx_params *cparam, 
+		struct cryptosoc_ctx **ctxt);
+extern int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx);
+extern int cryptosoc_get_response(struct cryptosoc_ctx  *ctx, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res);
+extern int cryptosoc_process_response(
+		struct cryptosoc_ctx  *ctx, 
+		enum cryptosoc_soc_type soc, 
+		_uint64_t msg0, _uint64_t msg1,
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res);
+extern int cryptosoc_process_ctx_request(int gen1, 
+		struct cryptosoc_ctx *ctx, 
+		enum cryptosoc_soc_type soc,
+		int txvc,
+		int fbvc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t req_usr_arg,
+		_uint64_t *rx_msg, _uint64_t *rsp_msg);
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
new file mode 100644
index 0000000..622a385
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.c
@@ -0,0 +1,1088 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+/**
+* DOC: Crypto Library API Design approach
+* 
+* The library has been implemented as 3 layers: Crypto-HAL, Crypto Abstraction
+*  and Crypto Protocol Specific library.  Also this library provides context
+*  APIs by which the linux-userspace application can implement a scalable 
+*  sync/async implementation. .
+*
+* The details of these API layers are described below.
+*/
+
+/**
+* DOC: Crypto HAL Library
+*
+* Crypto HAL library provides SAE engine direct interface APIs. Here the API 
+* definitions will differ depending on the processor type. Applications that 
+* are going to work only on a particular processor type can make use these 
+* APIs.
+*/
+
+/**
+* DOC: Crypto Abstraction Library
+*
+* This layer will abstract the SAE/RSA/ECC engine. This will internally calls
+*  the Crypto hal library depending on the processor type.
+*
+* These APIs support generic crypto operations and will not change from one 
+* chip to another. Applications should use this layer extensively
+*
+* Some of the APIs to support a few chip features in software (for older chips)
+* can be part of this layer
+*
+* Session and data descriptor formation will be handled transparently
+*
+* Most of the crypto operation input parameters will be taken during session 
+* creation which is one time operation. 
+*
+* Per operation parameters will be taken in the fast path APIs. These fast 
+* path APIs will take few most common input parameters and modify APIs will be 
+* provided for other parameters that can be modified for each operation 
+* (Note: Griffin and Eagle vary here a lot)
+*
+* During init time, a bitmask of all fields that can be modified on a per 
+* packet (operation) basis will be returned based on the chip type. 
+* Ex: for griffin, AAD length, payload bit count etc. For eagle, this will be 
+* IV length, IV offset etc.
+*
+* Another bit mask of all the CHIP capabilities will be returned: Following 
+* are examples of some chip capabilities:
+*  ZUC
+*  3DES Key swap
+*  Tag Compare result
+*  Tag truncation
+*  HASH muting 
+*
+* Applications that intend to be generic should make use of these flags and 
+* call appropriate APIs only if the feature is supported
+*/
+
+/**
+* DOC: Crypto Abstraction Library Application defines
+*
+* The library code is kept under GEN1(ex : xlp, storm) or GEN2(Ex:Griffin)
+* macros. This can be specified at compile time. 
+*
+* The library can be compiled for all the processor versions(GEN_ALL) or for a 
+* specified version(GEN1, GEN2). 
+*
+* If the library is compiled for (GEN_ALL), then it internally read the 
+*  processor type and calls the appropriate HAL apis.  
+*
+* If the library is compiled  only for GEN1/GEN2, then only those specific 
+* code will be executed.(No runtime checks)
+*
+*
+* This library is expecting the following macros to be defined by the 
+* application. The library code includes an application provided file named 
+* cryptosoc_lib_ifc.h. User should define the following parameters in that. 
+* 
+* _uint64_t cryptosoc_virt_to_phys(unsigned long vaddr): 
+*   Return the physical address corresponding to the given virtual address.
+*
+* unsigned long cryptosoc_phys_to_virt(_uint64_t paddr):
+*   Return the virtual address corresponding to the given physical address.
+*
+
+*
+* Also the application should register the following callback routines using 
+* the api cryptosoc_lib_init()
+*
+* a. mem_alloc:  Returns physically contiguous memory 
+*
+* b. mem_free: To free the memory allocated using mem_alloc routine             
+* 
+*/
+
+/**
+* DOC: Crypto Protocol Specific Library
+*
+* This layer provides helper functions which are protocol specific such as 
+* IPSEC, SSL etc. For example, the CCM implementation requires the B0, B1 
+* blocks to be created by the application before giving to the engine, 
+* so that any applications can make use of that instead of duplicating the 
+* code. 
+*
+* Similarly SSL specific padding which is not supported by the engine can make use of the APIs 
+* implemented as part of this library
+*
+*/
+#include "cryptosoc_ctx.h"
+#include "saesoc_defs.h"
+#include "cryptosoc_lib_priv.h"
+
+int cryptosoc_ptype_gen;
+static int cryptosoc_base_vc[CRYPTOSOC_TYPE_MAX];
+static int cryptosoc_lmt_vc[CRYPTOSOC_TYPE_MAX];
+
+cryptosoc__mem_alloc *cryptosoc_mem_alloc;
+cryptosoc__mem_free *cryptosoc_mem_free;
+
+/**
+* cryptosoc_lib_init - Initialize the sae/rsa/ecc soc library parameters 
+*  based on the processor type.
+* @params: Pointer to lib param structure(output) 
+* @mem_alloc: Function pointer to allocate physically contiguous memory
+*    This should return memory pointer in success.(input)
+* @mem_free: Function to free the memory.(input)
+* @arg: For future use
+*
+* This should be called once from every application which is intended 
+* to use this library. This function fills the params struct and returned
+* to the user. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		void *(mem_alloc)(size_t align, size_t size),
+		void (mem_free)(void *ptr),
+		void *arg)
+{
+	int i;
+
+	/* return error if callbacks are not provided */
+	if(!mem_alloc  || !mem_free) {
+			cryptosoc_err_print("%s:%d, Lib callbacks are not registered\n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+	}
+	cryptosoc_mem_alloc = mem_alloc;
+	cryptosoc_mem_free	= mem_free;
+
+	/* gen type should be filled by the priv init 
+	implementation specific init routine */
+	if(cryptosoc_lib_priv_init() < 0)
+		return  -CRYPTOSOC_EINVAL;
+
+	if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2) {
+		/* for griffin and associated versions */
+		params->saesoc_feature_set = SAESOC_FF_GEN2_PTYPE;
+		params->saesoc_per_pkt_update_set = 0;
+	} else { 
+		/* For eagle and associated versions */
+		//params->saesoc_feature_set = SAESOC_FF_GEN1_PTYPE | 
+		  //SAESOC_FF_3DES_KEY_SWAP_SUPPORT | SAESOC_FF_CIPHER_ZUC_SUPPORT;
+		params->saesoc_feature_set = SAESOC_FF_GEN1_PTYPE;
+		/* TODO : If xlp 3xx add zuc support */
+		params->saesoc_per_pkt_update_set = SAESOC_PER_PKT_UF_GEN1_PTYPE;
+	}
+
+	for(i = 0; i < CRYPTOSOC_TYPE_MAX; i++)
+		cryptosoc_get_basevc_limitvc(i,
+			&cryptosoc_base_vc[i], &cryptosoc_lmt_vc[i]);
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* cryptosoc_lib_finish - Crypto library finish function 
+* This should be called when the process is done with the 
+* current crypto library contexts.
+*/
+int cryptosoc_lib_finish(struct cryptosoc_lib_params *params)
+{
+	return cryptosoc_lib_priv_finish();
+}	
+
+/**
+* cryptosoc_get_basevc_limitvc - Retrieve the SAE/RSA/ECC base vc and limit vc
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @base_vc : Base vc
+* @lmt_vc  : End vc
+*/ 
+int cryptosoc_get_basevc_limitvc(enum cryptosoc_soc_type soc, int *base_vc, int *lmt_vc)
+{
+	/* Look at the processor type and return the value,
+	*  Need to call the kernel driver */
+	return crypto_get_soc_vc_numbers(soc, base_vc, lmt_vc);
+}
+
+/**
+* cryptosoc_get_single_channel_vcmask - Retrieve the SAE/RSA/ECC single 
+* channel vc mask.
+* The single channel vc mask is that those vcs are mapped to only single engine,
+* so that requests send to this vc id will be processed in order only.
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id. 
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_single_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x1; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* cryptosoc_get_multi_channel_vcmask - Retrieve the SAE/RSA/ECC  
+* multi channel vc mask.
+* The multi channel vc mask is that those vcs are mapped to multiple engines,
+* so that requests send to this vc id will be processed in by one of the free 
+* engines.
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_multi_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x2; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* cryptosoc_get_highpri_channel_vcmask - Retrieve the SAE/RSA/ECC  
+* high priority channel vc mask.
+* The high priority vc mask is that those vcs have high priority
+* in processing the requests compared to normal vcs,
+* The application need to add the base_vc with the set-bits positon 
+* in the mask to get the vc-id
+* @soc : Soc type, see enum cryptosoc_soc_type
+* @vc_mask : Engine vc mask
+*/ 
+int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask)
+{
+	/* TODO , Look at the processor type and return the value,
+	*  Need to call teh kernel driver */
+	/* right now return for xlp8xx */
+	*vc_mask = 0x4; 
+	return CRYPTOSOC_OK;
+}
+
+/**
+* DOC: Crypto Sync/Async Context Implementation Details
+* 
+* This section describes the implementation of Crypto context APIs 
+* which can be used from a Linux userspace application or a hyperexec 
+* application. Broadcom GEN1/GEN2 processor architecture allows Linux 
+* userspace  applications to directly send messages to the sae and perform 
+* various crypto operations and receive the response directly from the sae. 
+* This implementation will have a userspace and a small kernel driver 
+* component. 
+*
+* It is not mandatory that application should always use the contexts. In
+* some cases where the application takes care of receiving the responses
+* can still use all the library functions without using the contexts.
+*/
+
+/**
+* DOC: Async Model
+*
+* In the async model, the calling task can sleep after sending a crypto 
+* operation request to the sae. Application should open an async context 
+* for each connection. Async model supports 2 ways of handling the responses. 
+*
+* a. Driver pops the messages:
+*
+* In this case  the library is depends on a userspace and a small 
+* kernel driver component. The kernel driver is mainly used in this model
+* for implementing the select-wakeup semantics. The context is associated 
+* with a context memory and an eventfd. Here the message_send is done from 
+* userspace but the  message_recv is done by the linux interrupt handler 
+* and the response will be passed to the corresponding process through the 
+* context memory.  
+* 
+* The process that sent the message can block on the eventfd using 
+* select/epoll. The kernel driver will wake up the eventfd after copying the 
+* response to the context memory. The application should call the 
+* get_response() function to get the response. Eventfd is based on a 64
+* bit counter. The select/read will be successfull as long as the counter
+* value is > 0. When the application reads from the fd, the counter value
+* reset to 0. The argument to the read should be a 64 bit variable. So the 
+* application should call the get_response() function till it returns 
+* "no result". Otherwise the application may hang forever if there are
+* no further results.
+*
+* a.1 In-order & Out-of-order Processing
+*
+* In this model, the process can send multiple requests and the response will 
+* be delivered in request-sequence(in-order processing) or in 
+* response-sequence(out-of-order processing). 
+*
+* In the in-order processing, even if the second requests completes before 
+* first one, event will be delivered to the process, but the get_response()
+* function fails to retrieve any message. Whenever the head response arrives,
+* the application should POP all the responses by calling get_response() 
+* until it returns an error. 
+*
+* But in the out-of-order processing, the process can receive the response
+* whenever a response comes for any of the pending requests.
+*
+* b. Application pops the message:
+*
+* In this case the kernel driver component will not be used. Here
+* the application should continuously poll for the responses from the 
+* rx_vc and should call the process_response() function to extract
+* the context and user_args associated with the response.
+*
+* In this model, there is no concept of in-order or out-of-order processing.
+*/
+
+/**
+* DOC: Sync Model Exclusive VC
+*
+* In sync model, application will submit a crypto request and the 
+* library api will be continuously polling for the response. Here both 
+* message_send and message_recv are done from userspace. This requires a 
+* specific receive VC (for each CPU) and it cannot be shared with any 
+* other msgring stations (for ex. NAE). 
+*
+* The cpu set_affinity should be set for each application requesting sync 
+* operations. Otherwise if the message_send task is scheduled out of the 
+* called cpu, then the return message will be lost or will be received by 
+* some other task.
+*
+* As there is no way to order the request/response, only one outstanding 
+* SAE requests will  be allowed per cpu. For example if cpu 0 has 2 processes 
+* running , and if process-A is  waiting for a SAE response then process-B 
+* request can be sent only after receiving the response from process-A. 
+* This should be taken care by application if multiple sync-contexts are 
+* running on the same cpu.
+*/
+
+/**
+* DOC: Sync Model Shared VC
+*
+* This model is almost similar to Async model, but the crypto api will go to 
+* the sleep mode, and it will be woken up once the message reply arrives.
+* The message response will be copied to the context memory by the interrupt
+* handler. he advantage of this model compared to the sync-exclusive model is 
+* that there is no need for the explicit VC and cpu_set_affinity. 
+* The VC can be shared with other message ring stations
+*
+* This is not supported in helinux mode. Use sync-exclusive instead.
+*/
+
+/**
+* DOC: Application given macros
+*
+* CRYPTOSOC_MAX_PENDING_REQS_PER_CTX : This configures the maximum 
+* pending requests per context for async/sync-shared contexts. 
+* The memory consumption  per context will be more if it is set to a 
+* large value. Default can be set to 64.  Maximum of is is 4K.
+* The actual number of pending requests can be specified in 
+* the context creation time. When the number of pending requests exceeds 
+* this limit, the library returns EAGAIN, and then the application should 
+* pop atleast one response before sending  any more requests.
+*
+* CRYPTOSOC_CTX_APP_PRIV_SZ: Application private data size in the context 
+* structure.
+*/
+
+/**
+* DOC: Note
+* 
+* Contexts should not be shared with multiple forked processes. Result is 
+* unpredictable if the context created by one process used by another. 
+* Child process cannot use the same context created by parent because the
+* state of the context will not be valid for the child process(locks, 
+* outstanding requests, eventfd etc). 
+*
+* Also, as there is a kernel memory + application memory associated with the 
+* context, it cannot be shared with multiple processes.  If the kernel memory
+* is shared by 2 processes, the library cannot differentiate the request 
+* sending process. 
+*
+* Context can be shared with multiple threads(posix threads). 
+* 
+*/
+
+
+
+#define cryptosoc_gen_msg2(cpriv, rv)  \
+	(((_uint64_t)cpriv->rsp->sessionid << CRYPTOSOC_SESSION_ID_OFF) | \
+	((_uint64_t)cpriv->rsp->index << CRYPTOSOC_RSP_ID_OFF) | \
+	((_uint64_t)rv << CRYPTOSOC_ASYNC_MSG_OUT_OFF)) 
+
+
+#define CRYPTOSOC__MAX_PENDING_REQS_PER_CTX  \
+	(1 << (64 - CRYPTOSOC_ASYNC_MSG_OUT_OFF))
+
+static inline int cryptosoc_async_inorder_push_req(
+		struct cryptosoc_ctx_priv_data *cpriv, _uint64_t rsp_usr_arg)
+{
+
+	if(fifo_full(cpriv->req_tail, cpriv->max_pending_reqs, cpriv->req_head))
+		return -CRYPTOSOC_EAGAIN;
+	cpriv->req_tail = (cpriv->req_tail + 1) % cpriv->max_pending_reqs;
+
+	cpriv->req_msg[cpriv->req_tail].rsp_val = 
+					cpriv->rsp->rsp_msg[cpriv->req_tail].rsp_val;
+	cpriv->req_msg[cpriv->req_tail].async_rsp_usr_arg = rsp_usr_arg;
+	cpriv->num_rsp_pend++;
+
+	return cpriv->req_tail;
+}
+
+static inline int cryptosoc_async_inorder_pop_rsp(
+		struct cryptosoc_ctx_priv_data *cpriv, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	int tmp;
+
+	if(fifo_empty(cpriv->req_tail, cpriv->req_head))
+		return 0;
+
+	tmp = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+
+	/* no change in the response msg with generator id . 
+	*  TODO generator id implementation */
+	if(cpriv->req_msg[tmp].rsp_val == cpriv->rsp->rsp_msg[tmp].rsp_val)
+	       return 0;	
+
+	cpriv->req_head = tmp;
+	if(res) {
+		/* all the results are uint64_t size. */
+		res->sae_res.result = cpriv->rsp->rsp_msg[tmp].res_val;
+	}
+	if(rsp_usr_arg)
+		*rsp_usr_arg = cpriv->req_msg[tmp].async_rsp_usr_arg;
+
+	cpriv->num_rsp_pend--;
+	return 1;
+}
+
+static inline void cryptosoc_async_inorder_pop_send_failure_reqs(
+		struct cryptosoc_ctx_priv_data *cpriv)
+{
+	int i = 0, tmp;
+
+	tmp = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+	for(;i < cpriv->max_pending_reqs; i++) {
+			if(cpriv->req_msg[tmp].rsp_val != 0xdeadbeefULL)
+				break;
+			cpriv->req_head = tmp;
+			tmp = (tmp + 1) % cpriv->max_pending_reqs;
+			cpriv->req_send_failure--;
+			cpriv->num_rsp_pend--;
+			if(!cpriv->req_send_failure)
+				break;
+	}
+}
+
+static inline void cryptosoc_async_inorder_mark_send_failure_reqs(
+		struct cryptosoc_ctx_priv_data *cpriv, int req_id)
+{
+	/* if tail is not moved. Basically no other requests 
+	*  are not sent out from other shared threads */
+	if(cpriv->req_tail == req_id) {
+		if(req_id == 0)
+			cpriv->req_tail = cpriv->max_pending_reqs - 1;
+		else
+			 cpriv->req_tail--;
+		cpriv->num_rsp_pend--;
+		return;
+	}
+	cpriv->req_msg[req_id].rsp_val = 0xdeadbeefULL;
+	cpriv->req_send_failure++;
+}
+
+/* no-order pop response */
+static inline int cryptosoc_async_pop_rsp(
+		struct cryptosoc_ctx_priv_data *cpriv, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	_uint64_t msg;
+	int req_id;
+
+	if(cpriv->rsp->head == cpriv->req_head) {
+		return 0;
+	}
+	msg = cpriv->rsp->rsp_msg[cpriv->req_head].rsp_val;	 
+	req_id = CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(msg);
+	if(rsp_usr_arg)
+		*rsp_usr_arg = cpriv->req_msg[req_id].async_rsp_usr_arg;
+	/* as all the results are of same size, we can use sae_res.
+	*  The application should read it based on the soc type */
+	if(res)
+		res->sae_res.result = cpriv->rsp->rsp_msg[cpriv->req_head].res_val;
+	cpriv->free_req_index[cpriv->req_tail] = req_id;
+	cpriv->req_tail++;
+	cpriv->req_head = (cpriv->req_head + 1) % cpriv->max_pending_reqs;
+	cpriv->num_rsp_pend--;
+	return 1;
+}
+
+
+/**
+* cryptosoc_new_context - The crypto new context function create a 
+*  context memory for the sync/async session. The context memory is 
+*  allocated from the heap. It will have userspace component and 
+*  kernel component depending on the context mode. 
+*
+* @cparam : Context init parameter(input)
+* @req_ctx : Pointer to the new context created(output)
+*
+* Return : CRYPTOSOC_OK for success, CRYPTOSOC_EINVAL for invalid argument, 
+*	  
+*/
+int cryptosoc_new_context(
+		struct cryptosoc_ctx_params *cparam, 
+		struct cryptosoc_ctx **req_ctx)
+{
+#ifndef NLM_HAL_LINUX_KERNEL
+	int size, i;
+	struct cryptosoc_ctx *ctx = NULL;
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+
+	if(!cparam || !req_ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	/* In sync, as there is no way to order the requests and response, only one 
+	 outstanding request is allowed. */
+	size =  sizeof(struct cryptosoc_ctx);
+	if((ctx = malloc(size)) == NULL) 
+		goto err_exit;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+	
+	cpriv->mode = cparam->mode;
+	cpriv->max_pending_reqs = 1;
+	cpriv->num_rsp_pend = 0;
+	cryptosoc_lock_init(&cpriv->lock);
+	ctx->fd = -1;
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_EXCL) {
+		cryptosoc_dbg_print("Created exclusive session\n");
+
+	} else if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_SHRD) {
+
+		if(cparam->max_pending_reqs > CRYPTOSOC_MAX_PENDING_REQS_PER_CTX) {
+			cryptosoc_err_print(
+					"%s, Error, Number of requests exceeded the max limit\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+		cpriv->max_pending_reqs = cparam->max_pending_reqs;
+
+		if(crypto_ctxt_alloc(ctx) < 0) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+
+		for(i = 0; i < cpriv->max_pending_reqs ; i++)
+			cpriv->free_req_index[i] = i;
+		cpriv->req_head = 0;
+		cpriv->req_tail = i;
+
+		cryptosoc_dbg_print("Created sync-shared session, fd %d\n", ctx->fd);
+	} else if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) {
+		if(cparam->max_pending_reqs > CRYPTOSOC_MAX_PENDING_REQS_PER_CTX) {
+			cryptosoc_err_print(
+					"%s, Error, Number of requests exceeded the max limit\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+		cpriv->max_pending_reqs = cparam->max_pending_reqs;
+
+		/* actual number of requests will be one less than the original, 
+		*  take care of it here */
+		if(cparam->max_pending_reqs < CRYPTOSOC_MAX_PENDING_REQS_PER_CTX)
+			 cpriv->max_pending_reqs++;
+
+		if(crypto_ctxt_alloc(ctx) < 0) {
+			cryptosoc_err_print("%s, Error, Context creation failed\n",
+					__FUNCTION__); 
+			goto err_exit;
+		}
+
+		cpriv->flags = cparam->flags;
+
+		/* initialize the head and tail pointers based on the response mode*/
+		if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+			cpriv->req_head = 0;
+			cpriv->req_tail = 0;
+			cpriv->req_send_failure = 0;
+		} else {
+			for(i = 0; i < cpriv->max_pending_reqs ; i++)
+				cpriv->free_req_index[i] = i;
+			cpriv->req_head = 0; 
+			cpriv->req_tail = i;
+		}
+
+		cryptosoc_dbg_print("Created async session, fd %d\n", ctx->fd);
+	} else {
+		cryptosoc_err_print("%s in, Invalid mode\n", __FUNCTION__);
+		goto err_exit;
+	}
+	*req_ctx = ctx;
+	return CRYPTOSOC_OK;
+err_exit:
+		
+	if(ctx) {
+		if(ctx->fd >= 0)
+			close(ctx->fd);
+		free(ctx);
+	}
+	return -CRYPTOSOC_EINVAL;
+#endif
+	return CRYPTOSOC_OK;
+
+}
+
+/**
+* cryptosoc_close_ctx - The close context function closes the fd and 
+*  removes the ctxt mem allocated. Returns error(EAGAIN) if the context 
+*  has any pending responses from the security engine. When the call
+*  returns EAGAIN, it should wait for sometime and call the function
+*  again.
+*
+* @ctx : Pointer to the ctx structure. 
+*
+* Return : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_EAGAIN
+*
+* Note :  It is the application responsibility that this function should 
+* be called only after all the threads sharing this context came 
+* to a done state. None of the threads should be using this context
+* during this call.
+*
+*/
+int cryptosoc_close_ctx(struct cryptosoc_ctx *ctx)
+{
+#ifndef NLM_HAL_LINUX_KERNEL
+	int rv;
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->num_rsp_pend > 0) {
+			if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER)
+				cryptosoc_async_inorder_pop_rsp(cpriv, NULL, NULL);
+			else
+				cryptosoc_async_pop_rsp(cpriv, NULL, NULL);
+			if(cpriv->num_rsp_pend > 0) {
+				cryptosoc_unlock(&cpriv->lock);
+				return -CRYPTOSOC_EAGAIN;
+			}
+		}
+		cryptosoc_unlock(&cpriv->lock);
+	}
+	if(ctx->fd >= 0) {
+		if((rv = crypto_ctxt_free(ctx)) < 0)
+			return rv;
+		if(close(ctx->fd) < 0)
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	free(ctx);
+#endif
+	return CRYPTOSOC_OK;
+}
+
+/*local function, not exported */
+static int cryptosoc_process_sync_excl_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1,
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+	unsigned int src, size;
+	uint64_t rx_msg0, rx_msg1;
+
+	cryptosoc_dbg_print("Mode is exclusive\n");
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, 0ULL) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if ( retry_count == 0)
+		return -CRYPTOSOC_EAGAIN;
+
+cont_rcv:
+	while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
+				&rx_msg0, &rx_msg1) != 0);
+
+	if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+		cryptosoc_err_print(
+				"Error : Msg recved from unknown src %d, continuing the loop\n", 
+				src);
+		goto cont_rcv;
+	}
+
+	cryptosoc_dbg_print( "Msg rcvd msg0 %llx msg1 %llx\n", 
+			(unsigned long long)rx_msg0, (unsigned long long)rx_msg1);
+
+	/* rsa result is at msg0 and crypto is at msg1 */
+	if(res_msg) 
+		*res_msg = soc == CRYPTOSOC_SAE ? rx_msg1 : rx_msg0;
+
+	return CRYPTOSOC_OK;
+}
+
+static int cryptosoc_process_sync_shrd_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		int fd,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, 
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+
+	_uint64_t msg2;
+	int req_id, rv;
+
+	cryptosoc_lock(&cpriv->lock);
+	if(cpriv->req_tail == 0) {
+		cryptosoc_unlock(&cpriv->lock);
+		return -CRYPTOSOC_EAGAIN;
+	}
+	cpriv->req_tail--;
+	req_id = cpriv->free_req_index[cpriv->req_tail];
+	cryptosoc_unlock(&cpriv->lock);
+
+	cpriv->req_msg[req_id].rsp_val = cpriv->rsp->rsp_msg[req_id].rsp_val;
+	msg2 = cryptosoc_gen_msg2(cpriv, req_id);
+
+	cryptosoc_dbg_print("Mode is shared-vc ,msg2 %llx\n", (unsigned long long)msg2);
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(rsp_msg)
+				*rsp_msg = msg2;
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if (retry_count == 0)  {
+		rv = -CRYPTOSOC_EAGAIN;
+		goto shrd_exit;
+	}
+
+retry:
+	if((rv = crypto_ctxt_shrd_wait_for_response(fd)) < 0)
+		return rv;
+		
+	/* if no change in the response generator id */
+	if(cpriv->req_msg[req_id].rsp_val == cpriv->rsp->rsp_msg[req_id].rsp_val)
+		goto retry;
+
+	if(res_msg)
+		*res_msg = cpriv->rsp->rsp_msg[req_id].res_val;
+	rv = CRYPTOSOC_OK;
+
+shrd_exit:
+	cryptosoc_lock(&cpriv->lock);
+	cpriv->free_req_index[cpriv->req_tail] = req_id;
+	cpriv->req_tail++;
+	cryptosoc_unlock(&cpriv->lock);
+	return rv;
+
+}
+
+static int cryptosoc_process_async_request(int gen_type2, 
+		struct cryptosoc_ctx_priv_data *cpriv,
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t rsp_usr_arg,
+		 _uint64_t *rsp_msg)
+{
+	int req_id;
+	_uint64_t msg2;
+
+	cryptosoc_lock(&cpriv->lock);
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+		if((req_id = cryptosoc_async_inorder_push_req(cpriv, rsp_usr_arg)) < 0) {
+			cryptosoc_unlock(&cpriv->lock);
+			return req_id;
+		}
+	} else {
+		/* we cannot use 1 slot */
+		if(cpriv->req_tail == 1) {
+			cryptosoc_unlock(&cpriv->lock);
+			return -CRYPTOSOC_EAGAIN;
+		}
+		cpriv->req_tail--;
+		req_id = cpriv->free_req_index[cpriv->req_tail];
+		cpriv->num_rsp_pend++;
+	}
+	cryptosoc_unlock(&cpriv->lock);
+
+	/* save the per request user argument */
+	cpriv->req_msg[req_id].async_rsp_usr_arg = rsp_usr_arg;
+
+	msg2 = cryptosoc_gen_msg2(cpriv, req_id);
+	cryptosoc_dbg_print("Mode is async ,msg2 %llx\n", 
+			(unsigned long long)msg2);
+
+	while(retry_count > 0 ) {
+		if(gen_type2) {
+			if(rsp_msg)
+				*rsp_msg = msg2;
+			if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+			if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if (retry_count == 0)  {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+			cryptosoc_async_inorder_mark_send_failure_reqs(cpriv, req_id);
+		} else  {
+			cpriv->free_req_index[cpriv->req_tail] = req_id;
+			cpriv->req_tail++;
+			cpriv->num_rsp_pend--;
+		}
+		cryptosoc_unlock(&cpriv->lock);
+		return -CRYPTOSOC_EAGAIN;
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* local function not exported */
+int cryptosoc_process_ctx_request(int gen_type2, 
+		struct cryptosoc_ctx *ctx, 
+		enum cryptosoc_soc_type soc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		_uint64_t msg0,	_uint64_t msg1, _uint64_t rsp_usr_arg,
+		_uint64_t *res_msg, _uint64_t *rsp_msg)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_EXCL) 
+		return cryptosoc_process_sync_excl_request(
+				gen_type2, cpriv, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, 
+				res_msg, rsp_msg);
+
+	else if(cpriv->mode == CRYPTOSOC_CTX_MODE_SYNC_SHRD) 
+		return cryptosoc_process_sync_shrd_request(
+				gen_type2, cpriv, ctx->fd, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, 
+				res_msg, rsp_msg);
+
+	else if(cpriv->mode == CRYPTOSOC_CTX_MODE_ASYNC) 
+		return cryptosoc_process_async_request(
+				gen_type2, cpriv, soc, req_vc, rsp_vc,
+				code, retry_count, msg0, msg1, rsp_usr_arg, rsp_msg);
+	else
+		return  -CRYPTOSOC_EINVAL;
+}
+
+/* local function not exported */
+int cryptosoc_process_request(int gen_type2, 
+		enum cryptosoc_soc_type soc,
+		int req_vc, int rsp_vc, 
+		int code, int retry_count,
+		_uint64_t msg0, _uint64_t msg1, _uint64_t msg2,
+		_uint64_t *res_msg)
+{
+	unsigned int src, size;
+
+	while(retry_count > 0 ) {
+		if (gen_type2) {
+		   if(xlp_message_send_2(req_vc, code, msg0, msg1) == 0)
+				break;
+		} else {
+		   if(xlp_message_send_3(req_vc, code, msg0, msg1, msg2) == 0)
+				break;
+		}
+		retry_count--;
+	}
+	if(retry_count == 0)
+		return -CRYPTOSOC_EAGAIN;
+
+	if(res_msg) {
+cont_rcv:
+		while(xlp_message_receive_2(rsp_vc, &src, &size, (unsigned int *)&code, 
+					(uint64_t *)&msg0, (uint64_t *)&msg1) != 0);
+		if(!(src >= cryptosoc_base_vc[soc] && src <= cryptosoc_lmt_vc[soc])) {
+			cryptosoc_err_print(
+			"Error : Msg recved from unknown src %d, continuing the loop\n", 
+					src);
+			goto cont_rcv;
+		}
+
+		/* rsa result is at msg0 and crypto is at msg1 */
+		*res_msg = soc == CRYPTOSOC_SAE ? msg1 : msg0;
+	}
+	return CRYPTOSOC_OK;
+}
+
+
+/**
+* cryptosoc_get_response - Get the response from the context if any.
+* Used only in async case.
+* @ctx: Pointer to the context(input)
+* @rsp_usr_arg: Value given as part of request send(output)
+* @res : Engine result response(output)
+*
+* Return: Number of messages read(0/1), or CRYPTOSOC_EINVAL
+*
+* Note : As multiple responses might have been queued up for 
+* this context, when the process wokeup, it should call the 
+* this routine till it returns "no-message(0)". See the async-
+* model session for details.
+*/
+
+int cryptosoc_get_response(struct cryptosoc_ctx  *ctx, 
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+	int rv = 1;
+
+	if(!ctx)
+		return -CRYPTOSOC_EINVAL;
+
+	cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_POP_BY_APP)
+		return  -CRYPTOSOC_EINVAL;
+
+	if(cpriv->flags & CRYPTOSOC_CTX_ASYNC_RSP_IN_ORDER) {
+		cryptosoc_lock(&cpriv->lock);
+		if(cpriv->req_send_failure)
+			cryptosoc_async_inorder_pop_send_failure_reqs(cpriv);
+		rv = cryptosoc_async_inorder_pop_rsp(cpriv, rsp_usr_arg, res);
+		cryptosoc_unlock(&cpriv->lock);
+	} else {
+		/* In this mode, the kernel fills the responses from start to end 
+		*  in circular way irrespective of the request id. We should maintain
+		*  the last read index. This should  be ok, as we read the responses 
+		*  from the head to make an empty slot  for the responses */
+		cryptosoc_lock(&cpriv->lock);
+		rv = cryptosoc_async_pop_rsp(cpriv, rsp_usr_arg, res);
+		cryptosoc_unlock(&cpriv->lock);
+	}
+	return rv;
+}
+
+/**
+* cryptosoc_process_response - Get the rsp arg and result from 
+* the received message. This will be called when the application receives
+* the messages directly. Here the kernel driver component is not used 
+* in receiving the messages.
+*
+* @ctx: Pointer to the context(output)
+* @soc : Soc type, see cryptosoc_soc_type enum
+* @msg0: Received message 0
+* @msg1: Received message 1
+* @rsp_usr_arg: Value given as part of request send(output)
+* @res : Engine result response(output)
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note:
+* This can be called with a valid ctx or ctxt=null. When ctx is null
+* the rsp_usr_arg will be copied with the recieved arg. Otherwise
+* it will be copied with usr arg given during the request sent.
+*/
+
+int cryptosoc_process_response(
+		struct cryptosoc_ctx  *ctx, 
+		enum cryptosoc_soc_type soc, 
+		_uint64_t msg0, _uint64_t msg1,
+		_uint64_t *rsp_usr_arg, struct cryptosoc_rsp_result *res)
+{
+	struct cryptosoc_ctx_priv_data *cpriv;
+	int req_id;
+	_uint64_t res_msg, rsp_msg;
+
+
+	/* rsa result is at msg0 and crypto is at msg1 */
+	res_msg = soc == CRYPTOSOC_SAE ? msg1 : msg0;
+	rsp_msg = soc == CRYPTOSOC_SAE ? msg0 : msg1;
+	
+	if(res)
+		res->sae_res.result = res_msg;
+
+	if(rsp_usr_arg)
+		*rsp_usr_arg = rsp_msg;
+
+	/* override the rsp_usr_arg if context is supported */
+
+	if(ctx) {
+		cpriv = (struct cryptosoc_ctx_priv_data *)(ctx->lib_priv);
+
+		req_id = CRYPTOSOC_GET_ASYNC_MSG_OUT_ID(rsp_msg);
+		if(req_id >= cpriv->max_pending_reqs)
+			return  -CRYPTOSOC_EINVAL;
+
+		if(rsp_usr_arg)
+			*rsp_usr_arg = cpriv->req_msg[req_id].async_rsp_usr_arg;
+	}
+
+	return CRYPTOSOC_OK;
+}
diff --git a/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
new file mode 100644
index 0000000..8a20f1a
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/cryptosoc_lib.h
@@ -0,0 +1,313 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _CRYPTOSOC_LIB_H
+#define _CRYPTOSOC_LIB_H
+
+#include <nlm_hal_fmn.h>
+
+/* This should be included in the top before lib.h */
+
+#ifndef _UINT64_T
+#define _UINT64_T
+typedef  unsigned long long   _uint64_t;
+#endif
+
+#define CRYPTOSOC_CACHELINE_SZ		64ULL
+#define CRYPTOSOC_CACHELINE_SHIFT  6
+#define ___cryptosoc_cacheline_aligned __attribute__((__aligned__(CRYPTOSOC_CACHELINE_SZ)))
+#define cryptosoc_is_cache_aligned(x) (((_uint64_t)x & (CRYPTOSOC_CACHELINE_SZ - 1)) == 0)
+#define cryptosoc_align(x, y)     ((x) & (~((y)-1)))
+#define cryptosoc_roundup(x, y)   (cryptosoc_align((x)+(y)-1, (y)))
+
+#ifndef NLM_HAL_LINUX_KERNEL
+	#ifdef CRYPTOSOC_DBG_EN
+	#define cryptosoc_dbg_print(fmt, args...) printf(fmt, ##args)
+	#endif
+	#define cryptosoc_err_print(fmt, args...) printf(fmt, ##args)
+	#define cryptosoc_print(fmt, args...) printf(fmt, ##args)
+#else
+	#ifdef CRYPTOSOC_DBG_EN
+	#define cryptosoc_dbg_print(fmt, args...) printk(fmt, ##args)
+	#endif
+	#define cryptosoc_err_print(fmt, args...) printk(fmt, ##args)
+	#define cryptosoc_print(fmt, args...) printk(fmt, ##args)
+#endif
+
+#define crypto_swap64(x)   ( (unsigned long long)((x & 0x000000FF) << 56) | \
+		(unsigned long long)((x & 0x0000FF00) << 40) | \
+		(unsigned long long)((x & 0x00FF0000) << 24) | \
+		(unsigned long long)((x & 0xFF000000) <<  8) | \
+		((x & (unsigned long long)0xFF << 32) >>  8) | \
+		((x & (unsigned long long)0xFF << 40) >> 24) | \
+		((x & (unsigned long long)0xFF << 48) >> 40) | \
+		((x & (unsigned long long)0xFF << 56) >> 56)   \
+		)
+
+#define crypto_swap32(x) ((unsigned int)((x & 0x000000ff) << 24) | \
+		(unsigned int)((x & 0x0000ff00) <<  8) | \
+		(unsigned int)((x & 0x00ff0000) >>  8) | \
+		(unsigned int)((x & 0xff000000) >> 24) \
+		)
+
+#define crypto_swap16(x) ((unsigned short)((x & 0x00ff) << 8) | \
+			(unsigned short)((x & 0xff00) >> 8) \
+		)
+
+#if !defined(__MIPSEL__) && !defined(__MIPSEB__)
+	$(error ENDIANESS is not specified(__MIPSEL__ , __MIPSEB__))
+#endif
+
+#ifdef __MIPSEL__
+#define ccpu_to_be64(x) crypto_swap64(x)
+#define ccpu_to_be32(x) crypto_swap32(x)
+#define ccpu_to_be16(x) crypto_swap16(x)
+#else
+#define ccpu_to_be64(x) (x)
+#define ccpu_to_be32(x) (x)
+#define ccpu_to_be16(x) (x)
+#endif
+
+
+
+#ifndef CRYPTOSOC_DBG_EN
+#define cryptosoc_dbg_print(fmt, args...) { }
+#endif
+
+#define CRYPTOSOC_PTYPE_IS_GEN1 0x1
+#define CRYPTOSOC_PTYPE_IS_GEN2 0x2
+
+/** 
+ * enum cryptosoc_err - Possible error codes returned by the APIs
+ *
+ * @CRYPTOSOC_OK: The API executed successfully.
+ * @CRYPTOSOC_EPERM: Operation not permitted.
+ * @CRYPTOSOC_ENOENT: Object look up failed
+ * @CRYPTOSOC_EIO: I/O Error
+ * @CRYPTOSOC_EAGAIN: Try again
+ * @CRYPTOSOC_ENOMEM: Out of memory
+ * @CRYPTOSOC_EINVAL: Invalid argument
+ * @CRYPTOSOC_ENOSPC: No space left on device
+ * @CRYPTOSOC_ETIMEDOUT: Operation timed out
+ */
+ 
+enum cryptosoc_err { 
+	CRYPTOSOC_OK = 0, 
+	CRYPTOSOC_EPERM    = 1,
+	CRYPTOSOC_ENOENT   = 2,
+	CRYPTOSOC_EIO      = 5,
+	CRYPTOSOC_EAGAIN	=11,
+	CRYPTOSOC_ENOMEM   = 12,
+	CRYPTOSOC_EINVAL   = 22,
+	CRYPTOSOC_ENOSPC   = 28,
+	CRYPTOSOC_ETIMEDOUT = 60,
+};
+
+/** 
+ * enum cryptosoc_soc_type - Crypto soc types
+ * @CRYPTOSOC_RSA : RSA engine
+ * @CRYPTOSOC_ECC : ECC engine
+ * @CRYPTOSOC_SAE : SAE engine
+ * @CRYPTOSOC_TYPE_MAX : End of crypto soc type
+ */
+enum cryptosoc_soc_type {
+	CRYPTOSOC_RSA,
+	CRYPTOSOC_ECC,
+	CRYPTOSOC_SAE,
+	CRYPTOSOC_TYPE_MAX
+};
+
+/**
+* struct cryptosoc_lib_params - Crypto(sae,rsa,ecc) soc library params based on 
+*  the processor type
+* @saesoc_feature_set: Feature set variable and associated flags for SAE engine. 
+* 	See the feature set flag(output)
+* @saesoc_per_pkt_update_set: SAE parameters that are modifiable on every packet 
+* 	depending on the processor type. See the uf_flag above(output)
+*/
+struct cryptosoc_lib_params {
+	unsigned int saesoc_feature_set ; 
+	unsigned int saesoc_per_pkt_update_set ; 
+};
+
+
+/**
+* struct saesoc_rsp_result - Crypto engine result 
+* @result: Result value is copied here 
+*/
+struct saesoc_rsp_result {
+	_uint64_t result;
+};
+
+/**
+* struct rsasoc_rsp_result - RSA engine result 
+* @result: Result value is copied here 
+*/
+struct rsasoc_rsp_result {
+	_uint64_t result;
+};
+
+/**
+* struct esssoc_rsp_result - ECC engine result 
+* @result: Result value is copied here 
+*/
+struct eccsoc_rsp_result {
+	_uint64_t result;
+};
+
+/*
+* struct cryptosoc_rsp_result - Union of sae/rsa/ecc result.
+* The application should look in to the appropriate values, 
+* based on the station from which the response has been
+* received.
+* @sae_res: SAE Result value is copied here 
+* @rsa_res: RSA Result value is copied here 
+* @ecc_res: ECC Result value is copied here 
+*/
+
+struct cryptosoc_rsp_result {
+	union {
+		struct saesoc_rsp_result sae_res;
+		struct rsasoc_rsp_result rsa_res;
+		struct eccsoc_rsp_result ecc_res;
+	};
+};
+
+typedef struct {
+	volatile unsigned int lock;
+} cryptosoc_lock_t;
+
+static inline void cryptosoc_lock_init(cryptosoc_lock_t *lock)
+{
+	lock->lock = 0;
+}
+
+
+
+typedef void *cryptosoc__mem_alloc(size_t align, size_t size);
+typedef void cryptosoc__mem_free(void *ptr);
+
+extern cryptosoc__mem_alloc *cryptosoc_mem_alloc;
+extern cryptosoc__mem_free *cryptosoc_mem_free;
+extern int cryptosoc_ptype_gen;
+extern int cryptosoc_lib_init(struct cryptosoc_lib_params *params, 
+		void *(mem_alloc)(size_t align, size_t size),
+		void (mem_free)(void *ptr),
+		void *arg);
+extern int cryptosoc_get_basevc_limitvc(enum cryptosoc_soc_type soc, 
+		int *base_vc, int *lmt_vc);
+extern int cryptosoc_get_single_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+extern int cryptosoc_get_multi_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+int cryptosoc_get_highpri_channel_vcmask(enum cryptosoc_soc_type soc, 
+		unsigned int *vc_mask);
+extern int cryptosoc_process_request(int gen_type2, 
+		enum cryptosoc_soc_type soc,
+		int req_vc, int fbvc, 
+		int code, int retry_count,
+		_uint64_t msg0, _uint64_t msg1, _uint64_t msg2,
+		_uint64_t *rx_msg);
+
+#if defined(__mips__)
+/* last bit set indication - from lsb to msb ,
+*  clz instruction looks for number of cleared bit from msb to lsb
+*  get_lbs(0) = 0, get_lbs(1) = 1, get_lbs(0x80000000) = 32
+*/
+static inline unsigned int cryptosoc_get_lbs(unsigned int x)
+{
+	__asm__(".set push      \n"
+			".set mips32    \n"
+			"clz %0, %1     \n"
+			".set pop       \n"
+			:"=r" (x)
+			:"r" (x));
+	return 32 - x;
+}
+
+/* find last bit cleared indication - from lsb to msb
+   clo instruction scans from msb to lsb for set bits 
+   get_lbc64(0) = 64, get_lbc64(0x80000000000000) = 63
+ */
+static inline int cryptosoc_get_lbc64(unsigned long long x)
+{
+	__asm__(".set push	\n"
+		".set mips64	\n"
+		"dclo %0, %1	\n"
+		".set pop	\n"
+		: "=r" (x) 
+		: "r" (x));
+	return 64 - x;
+}
+
+static inline void cryptosoc_lock(cryptosoc_lock_t *lock)
+{
+	unsigned int tmp, pid;
+#ifndef NLM_HAL_LINUX_KERNEL 
+	pid = getpid();
+#else
+	printk("do not call this\n");
+#endif
+
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"1:	ll %1, %2\n"
+			"bgtz	%1, 1b\n"
+			"move	%1, %3\n"
+			"sc	%1, %0\n"
+			"beqz	%1, 1b\n"
+			" sync	\n"
+			".set	pop\n"
+			: "=m" (lock->lock), "=&r" (tmp)
+			: "m" (lock->lock), "r" (pid)
+			: "memory");
+}
+
+static inline void cryptosoc_unlock(cryptosoc_lock_t *lock)
+{
+	__asm__ __volatile__(
+			".set 	push\n"
+			".set	noreorder\n"
+			"sync	\n"
+			"sw	$0, %0\n"
+			".set	pop\n"
+			: "=m" (lock->lock)
+			: "m" (lock->lock)
+			: "memory");
+}
+#endif //__mips__
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_defs.h b/arch/mips/netlogic/lib/seclib/eccsoc_defs.h
new file mode 100644
index 0000000..fe88495
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_defs.h
@@ -0,0 +1,144 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _ECCSOC_DEFS_H
+#define _ECCSOC_DEFS_H
+
+/**
+* enum eccsoc_data_format - RSA Data input/output format
+*
+* @ECCSOC_DATA_WSZ_64BIT_MSW_FIRST: Individual unit size is 64bit and 
+* 		most significant word is first. Memory should be dword aligned,
+* 		and total allocated size should be multiple of dword size.
+* @ECCSOC_DATA_WSZ_64BIT_LSW_FIRST: Individual unit size is 64bit and 
+* 		least significant word is first. Memory should be dword aligned,
+* 		and total allocated size should be multiple of dword size
+* @ECCSOC_DATA_WSZ_32BIT_MSW_FIRST: Individual unit size is 32bit and 
+* 		most significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @ECCSOC_DATA_WSZ_32BIT_LSW_FIRST: Individual unit size is 32bit and 
+* 		least significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @ECCSOC_DATA_WSZ_8BIT_MSW_FIRST: Individual unit size is 8bit and 
+* 		most significant word is first
+* @ECCSOC_DATA_WSZ_8BIT_LSW_FIRST: Individual unit size is 8bit and 
+* 		least significant word is first
+* @ECCSOC_DATA_FMT_MAX: End of data format type
+*/
+enum eccsoc_data_format {
+	ECCSOC_DATA_WSZ_64BIT_MSW_FIRST=0,
+	ECCSOC_DATA_WSZ_64BIT_LSW_FIRST,
+	ECCSOC_DATA_WSZ_32BIT_MSW_FIRST,
+	ECCSOC_DATA_WSZ_32BIT_LSW_FIRST,
+	ECCSOC_DATA_WSZ_8BIT_MSW_FIRST,
+	ECCSOC_DATA_WSZ_8BIT_LSW_FIRST,
+	ECCSOC_DATA_FMT_MAX
+};
+
+#define ECCSOC_DATA_FORMAT_SET
+
+/**
+* enum eccsoc_op_type - ECC Operation type
+* @ECCSOC_TYPE_64  : 64 bits  operation
+* @ECCSOC_TYPE_128  : 128 bits operation
+* @ECCSOC_TYPE_192  : 192 bits operation
+* @ECCSOC_TYPE_256  : 256 bits operation
+* @ECCSOC_TYPE_320  : 320 bits operation
+* @ECCSOC_TYPE_384  : 384 bits operation
+* @ECCSOC_TYPE_448  : 448 bits operation
+* @ECCSOC_TYPE_512  : 512 bits operation
+* @ECCSOC_TYPE_576  : 576 bits operation
+*/
+enum eccsoc_op_type {
+	ECCSOC_TYPE_64=0x0,
+	ECCSOC_TYPE_128,
+	ECCSOC_TYPE_192,
+	ECCSOC_TYPE_256,
+	ECCSOC_TYPE_320,
+	ECCSOC_TYPE_384,
+	ECCSOC_TYPE_448,
+	ECCSOC_TYPE_512,
+	ECCSOC_TYPE_576
+};
+
+/**
+* enum eccsoc_op - ECC Operation
+* @ECCSOC_POINT_MUL  : Point multiplication
+* @ECCSOC_POINT_ADD  : Point addition 
+* @ECCSOC_POINT_DBL : Point double 
+* @ECCSOC_POINT_VERIFY : Point verification 
+* @ECCSOC_MOD_ADD : Modular addition 
+* @ECCSOC_MOD_SUB : Modular subtraction 
+* @ECCSOC_MOD_MUL : Modular multiplication 
+* @ECCSOC_MOD_DIV : Modular division 
+* @ECCSOC_MOD_INV : Modular inversion 
+* @ECCSOC_MOD_RED : Modular reduction 
+* @ECCSOC_OP_MAX : End of operation 
+*/
+enum eccsoc_op {
+	ECCSOC_POINT_MUL = 0x0,
+	ECCSOC_POINT_ADD,
+	ECCSOC_POINT_DBL,
+	ECCSOC_POINT_VERIFY,
+	ECCSOC_MOD_ADD,
+	ECCSOC_MOD_SUB,
+	ECCSOC_MOD_MUL,
+	ECCSOC_MOD_DIV,
+	ECCSOC_MOD_INV,
+	ECCSOC_MOD_RED,
+	ECCSOC_OP_MAX
+	
+};
+
+/**
+* defines ecc_req_flags - Rsa operation request flags
+* @RSASOC_SRC_L3_ALLOC: Casuses source data to transit through L3 cache
+* @RSASOC_DST_L3_ALLOC: Causes data written to the dram is also copied to l3 cache
+* @RSASOC_DST_CLOBBER: Causes data to be written as 64byte cacheline, 
+*   no read modify write
+* @ECCSOC_ARGS_MEM_REGION_CRYPTOSOC: All the arguments are allocated 
+*    using cryptosoc_mem_alloc. So that virt_to_phys conversion can be done.
+*/
+
+/*!defines ecc_req_flags < */
+#define ECCSOC_SRC_L3_ALLOC 0x01
+#define ECCSOC_DST_L3_ALLOC 0x02
+#define ECCSOC_DST_CLOBBER  0x04
+#define ECCSOC_ARGS_MEM_REGION_CRYPTOSOC 0x8
+/*!defines ecc_req_flags > */
+
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h
new file mode 100644
index 0000000..4989c0d
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_gen1_hal_defs.h
@@ -0,0 +1,173 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _ECCSOC_GEN1_HAL_DEFS_H_
+#define _ECCSOC_GEN1_HAL_DEFS_H_
+
+#include "cryptosoc_lib.h"
+
+#define ECCSOC_GEN1_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & ECCSOC_GEN1_##PARAM##_MASK) << ECCSOC_GEN1_##PARAM##_SHIFT)
+
+#define ECCSOC_GEN1_GET_BITS(X,PARAM) \
+	 ((_uint64_t)(( (_uint64_t)X >> ECCSOC_GEN1_##PARAM##_SHIFT) & \
+		 ECCSOC_GEN1_##PARAM##_MASK)) 
+	
+
+#define ECCSOC_GEN1_SRC_L3_ALLOC_MASK 0x1ULL
+#define ECCSOC_GEN1_SRC_L3_ALLOC_SHIFT 61
+
+#define ECCSOC_GEN1_TYPE_MASK 0x7fULL
+#define ECCSOC_GEN1_TYPE_SHIFT 46
+
+#define ECCSOC_GEN1_FUNC_MASK 0x3fULL
+#define ECCSOC_GEN1_FUNC_SHIFT 40
+
+#define ECCSOC_GEN1_SRC_ADDR_MASK 0xffffffffffULL
+#define ECCSOC_GEN1_SRC_ADDR_SHIFT 0
+
+
+#define ECCSOC_GEN1_DST_CLOBBER_MASK 0x1ULL
+#define ECCSOC_GEN1_DST_CLOBBER_SHIFT 62
+
+#define ECCSOC_GEN1_DST_L3_ALLOC_MASK 0x1ULL
+#define ECCSOC_GEN1_DST_L3_ALLOC_SHIFT 61
+
+#define ECCSOC_GEN1_FBVC_MASK 0xfffULL
+#define ECCSOC_GEN1_FBVC_SHIFT 40
+
+#define ECCSOC_GEN1_DST_ADDR_MASK 0xffffffffffULL
+#define ECCSOC_GEN1_DST_ADDR_SHIFT 0
+
+
+
+/**
+* eccsoc_gen1_form_fmn_entry0 - Generate crypto rsa fmn message entry 0
+* @src_l3_alloc: 1/0, 1 casuses source data to transit through l3 cache
+* @type: type of the operation, see rsasoc_op_type
+* @func: operation function, see rsasoc_op
+* @src_addr : source address
+*
+* Returns: Filled fmn entry0
+*/
+
+static inline _uint64_t  eccsoc_gen1_form_fmn_entry0(unsigned int src_l3_alloc, 
+		unsigned int type, 
+		unsigned int func, _uint64_t src_addr)
+{
+	return( ECCSOC_GEN1_SET_BITS(src_l3_alloc, SRC_L3_ALLOC) |
+		ECCSOC_GEN1_SET_BITS(type, TYPE) | 
+		ECCSOC_GEN1_SET_BITS(func, FUNC) |
+		ECCSOC_GEN1_SET_BITS(src_addr, SRC_ADDR));
+}
+
+/**
+* eccsoc_gen1_form_fmn_entry1 -  Generate crypto rsa fmn message entry 1
+* 
+* @dst_clobber: 1/0, 1 causes data to be written as 64byte cacheline
+* @dst_l3_alloc: 1/0, 1 causes data written to the dram is also copied to l3 cache
+* @fbvc: freeback message vc
+* @dst_addr : destination address where result will be copied
+*
+* Returns: Filled fmn entry1
+*/
+
+
+static inline _uint64_t  eccsoc_gen1_form_fmn_entry1(unsigned int dst_clobber, 
+		unsigned int dst_l3_alloc, 
+		unsigned int fbvc, _uint64_t dst_addr)
+{
+
+	return( ECCSOC_GEN1_SET_BITS(dst_clobber, DST_CLOBBER) |
+		ECCSOC_GEN1_SET_BITS(dst_l3_alloc, DST_L3_ALLOC) | 
+		ECCSOC_GEN1_SET_BITS(fbvc, FBVC) |
+		ECCSOC_GEN1_SET_BITS(dst_addr, DST_ADDR));
+
+}
+
+static inline char *eccsoc_get_op_type(int val, char *buf)
+{
+	strcpy(buf, "Reserved");
+
+	if(val <= 8)
+		sprintf(buf, "P%d", (val + 1) * 64);
+	else if(val >= 0x20 && val <= 0x28)
+		sprintf(buf, "B%d", ((val - 0x20) + 1) * 64);
+	return buf;
+}
+
+static inline char *eccsoc_get_op_func(int val, char *buf)
+{
+	char op[][16] = { 
+		"PointMul", "PointAdd", "PointDbl", "PointVerify",
+		"ModAdd", "ModSub", "ModMul", 
+		"ModDiv", "ModInv", "ModRed" };
+
+	strcpy(buf, "Reserved");
+	if(val <= 9)
+		 strcpy(buf, op[val]);
+	return buf;
+}
+
+
+
+static inline void eccsoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+{
+	char buf[32], buf1[32];
+	cryptosoc_dbg_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_dbg_print("  %-16s %-16s %-16s %-16s\n",
+			"SrcL3Alloc","Type", "Func", "SrcAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16s %-16s %-16llx\n",
+			ECCSOC_GEN1_GET_BITS(entry0, SRC_L3_ALLOC),
+			eccsoc_get_op_type(ECCSOC_GEN1_GET_BITS(entry0, TYPE), buf),
+			eccsoc_get_op_func(ECCSOC_GEN1_GET_BITS(entry0, FUNC), buf1),
+			ECCSOC_GEN1_GET_BITS(entry0, SRC_ADDR));
+
+	cryptosoc_dbg_print("\n  %-16s %-16s %-16s %-16s\n",
+			"DstClobber","DstL3Alloc", "FbVC", "DstAddr");
+
+	cryptosoc_dbg_print("  %-16lld %-16lld %-16lld %-16llx\n",
+			ECCSOC_GEN1_GET_BITS(entry1, DST_CLOBBER),
+			ECCSOC_GEN1_GET_BITS(entry1, DST_L3_ALLOC),
+			ECCSOC_GEN1_GET_BITS(entry1, FBVC),
+			ECCSOC_GEN1_GET_BITS(entry1, DST_ADDR));
+
+	cryptosoc_dbg_print("\n");
+
+}
+
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/eccsoc_lib.h b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
new file mode 100644
index 0000000..cf5c4bf
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/eccsoc_lib.h
@@ -0,0 +1,1645 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _ECCSOC_LIB_H
+#define _ECCSOC_LIB_H
+
+/* Include file for application specific macros */
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
+
+#ifdef ECCSOC_PTYPE_GEN_ALL_SUPPORT
+#define ECCSOC_PTYPE_GEN2_SUPPORT
+#define ECCSOC_PTYPE_GEN1_SUPPORT
+#endif
+
+#include "eccsoc_defs.h"
+#include "rsaecc_soc_common.h"
+
+/* Include file for processor specific macros to set the descriptors. 
+*  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
+#ifdef ECCSOC_PTYPE_GEN2_SUPPORT
+#include "eccsoc_gen1_hal_defs.h"
+#endif
+
+#ifdef ECCSOC_PTYPE_GEN1_SUPPORT
+#include "eccsoc_gen1_hal_defs.h"
+#endif
+
+
+#ifdef ECCSOC_PTYPE_GEN_ALL_SUPPORT
+#define IF_ECCSOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_ECCSOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+#else
+#define IF_ECCSOC_PTYPE_IS_GEN1
+#define IF_ECCSOC_PTYPE_IS_GEN2 
+#endif
+
+#include "nlm_hal_fmn.h"
+
+#define ECCSOC_BINARY_TYPE_SVALUE 0x20
+
+/**
+* DOC: ECCSOC
+*
+* These APIs abstract the ECC SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* ECCSOC_REQ_DESC_APP_PRIV_SZ:
+*   Application private data size in the request descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either ECCSOC_PTYPE_GEN_ALL_SUPPORT or 
+*  ECCSOC_PTYPE_GEN2_SUPPORT/ECCSOC_PTYPE_GEN1_SUPPORT
+*/
+
+
+struct eccsoc_req_desc_priv_data {
+	/* number of operations to perform. The application can fill
+	*  multiple operations in one structure and can send to the engine 
+	*  in parallel or serial. 
+	*  */
+	int num_reqs; 
+	/* To save the input/return data address,
+	num_reqs size, dynamically allocated */
+	int max_reqs;
+	struct eccsoc_req_info *req_info; 
+};
+
+
+/* This should be aligned to 8 bytes, as the engine 
+*  data starts after this and that should be aligned 
+*  to 8 bytes */
+struct eccsoc_req_info {
+	void *inp; /* data memory - allocated by the library */
+	void *res; /* result memory - allocated by the library */
+
+	int inp_alloc; /* if inp is separately allocated */
+	int res_alloc; /* if res is separately allocated */
+
+	int inp_size; /* size of input mem */
+	int res_size; /* size of result mem */
+
+	void *eng_inp; /* input data memory, either inp or input-args */
+	void *eng_res; /* result data memory, either res or result-args  */
+
+	void *usr_res_x; /* user given result memory */
+	void *usr_res_y; /* user given result memory */
+
+	int rxlen_in_bits; /* user given result memory bitlen */
+	int rylen_in_bits; /* user given result memory bitlen */
+
+	int blksz_in_bits;
+	int out_word_bigendian;
+
+	int op; /* operation */
+	int type; /* type */
+
+	int flags;
+	int out_data_fmt;
+
+};
+
+
+#define ECCSOC_DATA_DESC_LIB_PRIV_SZ \
+	 (((sizeof(struct eccsoc_req_desc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define ECCSOC_MAX_BLOCK_SZ_IN_BITS 	576
+
+/**
+* struct eccsoc_arg - Operation data argument type
+* @v: Pointer to the value
+* @len_in_bits : Data length in bits
+*/
+struct eccsoc_arg {
+	void *v;
+	int  len_in_bits;
+};
+
+/**
+* struct eccsoc_point_arg - Operation point argument type
+* @x: Pointer to the x access value
+* @xlen_in_bits : x access data length in bits
+* @y: Pointer to the y access value
+* @ylen_in_bits : y access data length in bits
+*/
+struct eccsoc_point_arg {
+	void *x;
+	int  xlen_in_bits;
+	void *y;
+	int  ylen_in_bits;
+};
+
+
+/**
+* struct eccsoc_pmul_args - Point multiplication operation argument (r(x,y)=k*p(x,y))
+* @p : Point input
+* @a : Curve paramter
+* @k : Scalar
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_pmul_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg k;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_padd_args - Point addition operation argument (r(x,y)=p(x,y)+q(x,y))
+* @p : Point input-1
+* @q : Point input-2
+* @a : Curve paramter
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_padd_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_point_arg q;
+	struct eccsoc_arg a;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_pdbl_args - Point double operation argument (r(x,y)=2*p(x,y)))
+* @p : Point input
+* @a : Curve paramter
+* @n : Modulus
+* @r : Result point
+*/
+struct eccsoc_pdbl_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg n;
+	struct eccsoc_point_arg r;
+};
+
+/**
+* struct eccsoc_pverify_args - Point verify operation argument 
+*   (r(x,y)=1 when p(x,y) is on curve, 0 otherwise)
+* @p : Point input
+* @a : Curve paramter
+* @b : Curve paramter
+* @n : Modulus
+* @r : Result pointer
+*/
+struct eccsoc_pverify_args {
+	struct eccsoc_point_arg p;
+	struct eccsoc_arg a;
+	struct eccsoc_arg b;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_madd_args -  Modular addition operation argument(r= x+y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_madd_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_msub_args -  Modular subtraction operation argument(r= x-y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_msub_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+
+/**
+* struct eccsoc_mmul_args -  Modular multiplication operation argument(r= x*y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mmul_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_mdiv_args -  Modular divition operation argument(r= x/y mod n)
+* @x : Parameter 1
+* @y : Parameter 2
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mdiv_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg y;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_minv_args -  Modular inverse operation argument(r= 1/x mod n)
+* @x : Parameter 1
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_minv_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_mred_args -  Modular reduction operation argument(r= x mod n)
+* @x : Parameter 1
+* @n : Modulus
+* @r : Result 
+*/
+struct eccsoc_mred_args {
+	struct eccsoc_arg x;
+	struct eccsoc_arg n;
+	struct eccsoc_arg r;
+};
+
+/**
+* struct eccsoc_request_params - Each operation request parameters
+* @inp_data_fmt: Input data format, see enum rsasoc_data_format
+* @out_data_fmt: Output data format, see enum rsasoc_data_format
+* @req_num: Request number
+* @word_bigendian: 1/0, Depending on the data word is big endian/little endian
+* @prime: 1/0, Set to 1 when the operation is prime, 0 for binary
+* @flags: Request flags, see define ecc_req_flags
+*/
+struct eccsoc_request_params {
+	enum eccsoc_data_format inp_data_fmt;
+	enum eccsoc_data_format out_data_fmt;
+	int req_num;
+	int word_bigendian;
+	int prime;
+	int flags; 
+};
+
+/**
+* struct eccsoc_request_desc - Data descriptor parameters
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @data: Data storage space. Dynamic sized depending on the block size.
+*/
+struct eccsoc_request_desc {
+	char lib_priv[ECCSOC_DATA_DESC_LIB_PRIV_SZ];
+	char app_priv[RSASOC_REQ_DESC_APP_PRIV_SZ];
+	char data[0];
+}___cryptosoc_cacheline_aligned;
+
+
+/**
+* struct eccsoc_extra_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of requests from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct eccsoc_extra_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+
+
+static int eccsoc_max_req_args[] =  {
+	[ECCSOC_POINT_MUL] = 5,
+	[ECCSOC_POINT_ADD] = 6,
+	[ECCSOC_POINT_DBL] = 4,
+	[ECCSOC_POINT_VERIFY] = 5,
+	[ECCSOC_MOD_ADD] = 3,
+	[ECCSOC_MOD_SUB] = 3,
+	[ECCSOC_MOD_MUL] = 3,
+	[ECCSOC_MOD_DIV] = 3,
+	[ECCSOC_MOD_INV] = 2,
+	[ECCSOC_MOD_RED] = 2
+};
+
+static int eccsoc_max_rsp_args[] =  {
+	[ECCSOC_POINT_MUL] = 2,
+	[ECCSOC_POINT_ADD] = 2,
+	[ECCSOC_POINT_DBL] = 2,
+	[ECCSOC_POINT_VERIFY] = 1,
+	[ECCSOC_MOD_ADD] = 1,
+	[ECCSOC_MOD_SUB] = 1,
+	[ECCSOC_MOD_MUL] = 1,
+	[ECCSOC_MOD_DIV] = 1,
+	[ECCSOC_MOD_INV] = 1,
+	[ECCSOC_MOD_RED] = 1
+};
+
+static inline int eccsoc_validate_input(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc *desc, void *margs)
+{
+
+	struct eccsoc_req_desc_priv_data *dpriv;
+
+	if(!req_p || !margs)
+		return -CRYPTOSOC_EINVAL;
+
+
+	if(desc) {
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+	   	if(dpriv->max_reqs < req_p->req_num) {
+			cryptosoc_err_print("%s:%d, Error - Request overflow \n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+		}
+	} else if(req_p->req_num != 1 || max_reqs <= 0) {
+		/* request number should be one for the new descriptor 
+		*  creation */
+		cryptosoc_err_print("%s:%d, Error - Invalid request number \n", 
+					__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+	return CRYPTOSOC_OK;
+}
+
+
+
+static inline int eccsoc_get_blksz_in_bits(int max_len_in_bits)
+{
+	int rv = max_len_in_bits;
+	/* block size starts from 64, roundup the size to the next one supported
+	*  by the engine */
+	if((rv % 64) != 0) 
+		rv = (rv + 63) & (~63); 
+	return rv;
+}
+
+static inline void eccsoc_save_res_info(
+		 struct eccsoc_req_desc_priv_data *dpriv, 
+		 int req_num, int res_size, 
+		 char *res,  char *rx, int rxlen_in_bits, 
+		 char *ry,  int rylen_in_bits, int out_data_fmt)
+{
+	if(res_size) {
+		 dpriv->req_info[req_num].eng_res =  res;
+		 dpriv->req_info[req_num].usr_res_x =  rx;
+		 dpriv->req_info[req_num].usr_res_y =  ry;
+		 dpriv->req_info[req_num].rxlen_in_bits = rxlen_in_bits;
+		 dpriv->req_info[req_num].rylen_in_bits = rylen_in_bits;
+		 dpriv->req_info[req_num].out_data_fmt = out_data_fmt;
+	} else {
+		 dpriv->req_info[req_num].eng_res =  rx;
+		 dpriv->req_info[req_num].usr_res_x = NULL;
+		 dpriv->req_info[req_num].usr_res_y = NULL;
+	}
+}
+
+static inline void	eccsoc_save_req_info(
+		 struct eccsoc_req_desc_priv_data *dpriv, int prime, int op,
+		 int req_num, int blksz_in_bits, int req_flags, int word_bigendian)
+{
+	int type = (blksz_in_bits / 64) - 1;
+	if(!prime)
+		type += ECCSOC_BINARY_TYPE_SVALUE;
+
+	dpriv->req_info[req_num].type = type;
+	dpriv->req_info[req_num].op = op;
+	dpriv->req_info[req_num].blksz_in_bits = blksz_in_bits;
+
+	dpriv->req_info[req_num].flags = req_flags;
+	dpriv->req_info[req_num].out_word_bigendian = word_bigendian;
+	/* request number is decremented above */
+	if(req_num >= dpriv->num_reqs)
+		dpriv->num_reqs++;
+}
+
+
+
+static inline struct eccsoc_request_desc *eccsoc_create_new_desc(
+		struct eccsoc_request_desc *desc,
+		int req_num, 
+		int max_reqs, int inp_size, int res_size)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int idx= 0;
+
+	if(desc) {
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+		/* check the input */
+		if(inp_size && (dpriv->req_info[req_num].inp_size < inp_size)) {
+			cryptosoc_dbg_print("%s, reqnum %d input prevsize %d required %d\n", 
+					__FUNCTION__, req_num,
+					dpriv->req_info[req_num].inp_size, inp_size);
+			if(dpriv->req_info[req_num].inp_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp = cryptosoc_mem_alloc(8, inp_size);
+			if(!dpriv->req_info[req_num].inp)
+				return NULL;
+			dpriv->req_info[req_num].inp_alloc = 1;
+		  	dpriv->req_info[req_num].inp_size = inp_size;
+		}
+
+		/* check the result */
+		if(res_size && (dpriv->req_info[req_num].res_size < res_size)) {
+			cryptosoc_dbg_print("%s, reqnum %d result  prevsize %d required %d\n", 
+					__FUNCTION__, req_num,
+					dpriv->req_info[req_num].res_size, res_size);
+			if(dpriv->req_info[req_num].res_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res = cryptosoc_mem_alloc(8, res_size);
+			if(!dpriv->req_info[req_num].res)
+				return NULL;
+			dpriv->req_info[req_num].res_alloc = 1;
+		  	dpriv->req_info[req_num].res_size = res_size;
+		}
+	} else {
+		int req_info_sz = max_reqs * sizeof(struct eccsoc_req_info);
+		int size = inp_size + res_size + req_info_sz;
+		void *mbase;
+		desc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ, sizeof(*desc) + size);
+		if(!desc)
+			return NULL; 
+		dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+		dpriv->num_reqs = 0;
+		dpriv->max_reqs = max_reqs;
+		dpriv->req_info =  (struct eccsoc_req_info *)&desc->data[0];
+	
+		mbase = (void *)((unsigned long)dpriv->req_info + req_info_sz);
+
+		/* part of desc */
+		dpriv->req_info[0].inp_alloc= 0;
+		dpriv->req_info[0].res_alloc= 0;
+		dpriv->req_info[0].op = -1;
+
+		if(inp_size) {
+			dpriv->req_info[0].inp = mbase;
+			dpriv->req_info[0].inp_size = inp_size;
+			mbase += inp_size;
+		} else
+			dpriv->req_info[0].inp_size = 0;
+
+		if(res_size) {
+			dpriv->req_info[0].res = mbase;
+			dpriv->req_info[0].res_size = res_size;
+		} else
+			 dpriv->req_info[0].res_size = 0;
+
+		for(idx = 1; idx < max_reqs; idx++) {
+			dpriv->req_info[idx].inp_alloc= 0;
+			dpriv->req_info[idx].res_alloc= 0;
+			dpriv->req_info[idx].inp_size = 0;
+			dpriv->req_info[idx].res_size = 0;
+		}
+	}
+	return desc;
+}
+
+/**
+* eccsoc_create_point_mul_request - Create point multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_mul_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pmul_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+	
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max5(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->k.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_MUL;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->k.v) ||
+			((margs->k.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_5(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->k.v, margs->k.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_point_add_request - Create point addition request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point addition args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_add_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_padd_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max6(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->q.xlen_in_bits,margs->q.ylen_in_bits, 
+			margs->a.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_ADD;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->q.x) ||
+			((margs->q.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_6(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->q.x, margs->q.xlen_in_bits,
+					 margs->q.y, margs->q.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+/**
+* eccsoc_create_point_dbl_request - Create point double request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point double args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_dbl_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pdbl_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.xlen_in_bits < margs->n.len_in_bits || 
+			margs->r.ylen_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max4(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_DBL;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+		if(((margs->r.x + blk) != margs->r.y) ||
+			(margs->r.xlen_in_bits != blksz_in_bits) ||
+			(margs->r.ylen_in_bits != blksz_in_bits) ||
+			(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_4(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.x, margs->r.xlen_in_bits, 
+			margs->r.y,  margs->r.ylen_in_bits, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_point_verify_request - Create point verification request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to point verification args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_point_verify_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_pverify_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max5(
+			margs->p.xlen_in_bits, margs->p.ylen_in_bits, 
+			margs->a.len_in_bits, margs->b.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_POINT_VERIFY;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->p.x + blk) != margs->p.y) ||
+			((margs->p.y + blk) != margs->a.v) ||
+			((margs->a.v + blk) != margs->b.v) ||
+			((margs->b.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_5(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->p.x, margs->p.xlen_in_bits,
+					 margs->p.y, margs->p.ylen_in_bits,
+					 margs->a.v, margs->a.len_in_bits,
+					 margs->b.v, margs->b.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->p.x;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_add_request - Create modular addition request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod addition args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_add_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_madd_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max3(
+			margs->x.len_in_bits, margs->y.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_MOD_ADD;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->y.v) ||
+			((margs->y.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_3(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->x.v, margs->x.len_in_bits,
+					 margs->y.v, margs->y.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_sub_request - Create modular subtraction request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod subtraction args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_sub_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_msub_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_SUB;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_mul_request - Create modular multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_mul_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mmul_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_MUL;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_div_request - Create modular division request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod division args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_div_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mdiv_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_add_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_madd_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_DIV;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_create_mod_inv_request - Create modular inversion request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod inversion args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_inv_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_minv_args *margs)
+{
+
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int op, req_num;	
+	struct eccsoc_req_desc_priv_data *dpriv;
+	struct eccsoc_request_desc *desc = NULL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	if(eccsoc_validate_input(req_p, max_reqs, desc, (void *)margs) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	req_num = req_p->req_num;
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* find the block size */
+	max_len_in_bits = rsa_ecc_soc_find_max2(
+			margs->x.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > ECCSOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	blksz_in_bits = eccsoc_get_blksz_in_bits(max_len_in_bits);
+	blk = blksz_in_bits / 8;
+	op = ECCSOC_MOD_INV;
+
+	/* check whether input copy required */
+	if(!(req_p->flags & ECCSOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  eccsoc_max_req_args[op] * blk;
+		res_size = eccsoc_max_rsp_args[op] * blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->n.v) ||
+			(margs->n.len_in_bits != blksz_in_bits) ||
+			(req_p->inp_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+		  		inp_size =  eccsoc_max_req_args[op] * blk;
+
+			if((margs->r.len_in_bits != blksz_in_bits) ||
+				(req_p->out_data_fmt !=  ECCSOC_DATA_WSZ_64BIT_LSW_FIRST))
+				res_size = eccsoc_max_rsp_args[op] * blk;
+	}
+
+	req_num--;
+
+	desc = eccsoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct eccsoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_2(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					 margs->x.v, margs->x.len_in_bits,
+					 margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+
+	eccsoc_save_res_info(dpriv, req_num, res_size, 
+			dpriv->req_info[req_num].res, 
+			margs->r.v, margs->r.len_in_bits, 
+			NULL,  0, req_p->out_data_fmt);
+
+	eccsoc_save_req_info(dpriv, req_p->prime, op, req_num, 
+			blksz_in_bits, req_p->flags, req_p->word_bigendian);
+
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* eccsoc_create_mod_red_request - Create modular reduction request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod reduction args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int eccsoc_create_mod_red_request(
+		struct eccsoc_request_params *req_p,
+		int max_reqs,
+		struct eccsoc_request_desc **req_desc,
+		struct eccsoc_mred_args *margs)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = eccsoc_create_mod_inv_request(req_p, max_reqs, req_desc, 
+			(struct eccsoc_minv_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct eccsoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = ECCSOC_MOD_RED;
+	}
+	return rv;
+}
+
+/**
+* eccsoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output). 
+* Rsp should be allocated for the number of requests that
+* are going to be sent out.
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*/
+static inline int eccsoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct eccsoc_request_desc *req_desc, 
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		struct eccsoc_extra_req_send_params *mparam,
+		struct eccsoc_rsp_result *sync_res)
+{
+
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2=0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = eccsoc_gen1_form_fmn_entry0( 
+				dpriv->req_info[idx].flags & ECCSOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+		fmn_entry1 = eccsoc_gen1_form_fmn_entry1( 
+				dpriv->req_info[idx].flags & ECCSOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & ECCSOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+		cryptosoc_dbg_print("ECC process req, req_num %d type %d func %d\n",
+			idx, dpriv->req_info[idx].type, dpriv->req_info[idx].op);
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_ECC, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv = cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_ECC,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+		if(rv < 0)
+			break;
+
+	}
+	return rv;
+}
+
+/**
+* eccsoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int eccsoc_result_valid(struct eccsoc_rsp_result *res)
+{
+	/* TODO */
+	return 1;
+}
+
+/**
+* eccsoc_copy_result - Copy the result from the engine to the user
+*   given argument during the operation request. This should be called
+*   by the application after getting back the valid response from the 
+*   given request
+* @req_desc: Pointer to the request data descriptor
+* @req_num: Request index
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+static inline int eccsoc_copy_result(struct eccsoc_request_desc *req_desc, int req_num)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	void *rmem;
+	int blk;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return -CRYPTOSOC_EINVAL;
+
+	/* Nothing to do if application already passed the 
+	*  data in the required format */
+	if(!dpriv->req_info[req_num].usr_res_x)
+		return  CRYPTOSOC_OK;
+
+	if(dpriv->req_info[req_num].op < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	rmem = dpriv->req_info[req_num].eng_res;
+
+	if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+				dpriv->req_info[req_num].out_word_bigendian,
+				dpriv->req_info[req_num].usr_res_x, 
+				dpriv->req_info[req_num].rxlen_in_bits, 
+				rmem, dpriv->req_info[req_num].blksz_in_bits) < 0) 
+		return -CRYPTOSOC_EINVAL;
+
+	if(dpriv->req_info[req_num].rylen_in_bits) {
+		blk = dpriv->req_info[req_num].blksz_in_bits/8;
+		rmem += blk;
+		if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+					dpriv->req_info[req_num].out_word_bigendian,
+					dpriv->req_info[req_num].usr_res_y, 
+					dpriv->req_info[req_num].rylen_in_bits, 
+					rmem, dpriv->req_info[req_num].blksz_in_bits) < 0) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* eccsoc_reset_request_desc - Reset the request descriptor. 
+* Application should call this function if  this descriptor 
+* was used for more than one request  and to start from the req_num=1
+* again.
+* @req_desc: Pointer to the request descriptor. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL;
+*/
+static inline int eccsoc_reset_request_desc(struct eccsoc_request_desc *req_desc)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp_alloc = 0;
+			dpriv->req_info[req_num].inp_size = 0;
+		}
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res_alloc = 0;
+			dpriv->req_info[req_num].res_size = 0;
+		}
+		dpriv->req_info[req_num].op = -1;
+	}
+
+	dpriv->num_reqs = 0;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* eccsoc_free_request_desc - Free the request descriptor
+* @req_desc: Pointer to the request descriptor
+*
+*/
+static inline void eccsoc_free_request_desc(struct eccsoc_request_desc *req_desc)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp)
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res)
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+	}
+	cryptosoc_mem_free(req_desc);
+}
+
+/**
+* eccsoc_dump_request_data - Dump the input data in the engine format
+* @req_desc: Pointer to the request data descriptor
+* @req_num: Request index
+*
+*/
+static inline void eccsoc_dump_request_data(
+		struct eccsoc_request_desc *req_desc, int req_num)
+{
+	struct eccsoc_req_desc_priv_data *dpriv;
+	int blk, i, arg, max_args;
+	char *mem;
+	char (*tmp)[4];
+	/* names in the order of operation */
+	char names[][4]={
+		"px", "py", "a",  "k",  "n",  "",  /* pmul*/
+		"px", "py", "qx", "qy",  "a", "n",  /* padd */
+		"px", "py", "a",  "n",   "",   "", /* pdbl */
+		"px", "py", "a",   "b",  "n",  "", /* pver */
+		"x",   "y",  "n",  "",   "",   "", /* madd */
+		"x",   "y",  "n",  "",   "",   "", /* msub */
+		"x",   "y",  "n",  "",   "",   "", /* mmul */
+		"x",   "y",  "n",  "",   "",   "", /* mdiv */
+		"x",   "n",  "",   "",   "",   "", /* mod-inv*/
+		"x",   "n",  "",   "",   "",   ""  /* mod-red */
+	};
+
+	if(!req_desc)
+		return;
+
+	dpriv = (struct eccsoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return;
+
+	blk = dpriv->req_info[req_num].blksz_in_bits / 8;
+
+	cryptosoc_dbg_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
+			dpriv->req_info[req_num].blksz_in_bits,
+			dpriv->max_reqs, dpriv->num_reqs, 
+			dpriv->req_info[req_num].inp_size, 
+			dpriv->req_info[req_num].res_size);
+
+	mem = dpriv->req_info[req_num].eng_inp;
+	max_args =  eccsoc_max_req_args[dpriv->req_info[req_num].op];
+	tmp =  &names[dpriv->req_info[req_num].op * 6];
+
+	for(arg=0; arg < max_args; arg++) {
+		cryptosoc_dbg_print("%s\n", tmp[arg]);
+		for(i = 0; i < blk; ) {
+			cryptosoc_dbg_print(" <%016llx>", *(_uint64_t *)(mem + i));
+			i += 8;
+			if((i % 32) == 0)
+				cryptosoc_dbg_print("\n");
+		}
+		cryptosoc_dbg_print("\n");
+		mem = mem + blk;
+	}
+	return;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
new file mode 100644
index 0000000..fe9ba34
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsaecc_soc_common.h
@@ -0,0 +1,795 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSAECC_SOC_COMMON_H
+#define _RSAECC_SOC_COMMON_H
+
+//#define cryptosoc_dbg_print printf
+/* engine request and result data format conversion routine */
+typedef int (*rsa_ecc_soc_data_copy)(int,  unsigned char *, int, unsigned char *, int);
+
+/* input copy : src format is dword and most significant dword first */
+static int rsa_ecc_soc_input_copy_fmt_dword_msdwf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i = 0;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0)
+		goto end;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the lsword */
+	slen = cryptosoc_roundup(slen, 8);
+	src += (slen - 8);
+	for(i = 0; i < slen; i+=8)  {
+		*(_uint64_t *)(dst + i) = *(_uint64_t *)src;
+		src -= 8;
+	}
+end:
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is dword and most significant dword first */
+static int rsa_ecc_soc_result_copy_fmt_dword_msdwf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy from ls to ms */
+	dlen = cryptosoc_roundup(dlen, 8);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+	
+	dst += (dlen - 8);
+
+	for(i = 0; i < min; i+=8) {
+		*(_uint64_t *)(dst) =  *(_uint64_t *)(src);
+		src += 8;
+		dst -= 8;
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is dword and least significant dword first */
+static int rsa_ecc_soc_input_copy_fmt_dword_lsdwf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x7UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		*(_uint64_t *)(dst + i) = *(_uint64_t *)(src + i);
+	}
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is dword and least significant dword first */
+static int rsa_ecc_soc_result_copy_fmt_dword_lsdwf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	dlen = cryptosoc_roundup(dlen, 8);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+
+	for(i = 0; i < min; i+=8) {
+		*(_uint64_t *)(dst + i) =  *(_uint64_t *)(src + i);
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is word and most significant word first */
+static int rsa_ecc_soc_input_copy_fmt_word_mswf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i = 0;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0ULL;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0)
+		goto end;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the lsword */
+	slen = cryptosoc_roundup(slen, 4);
+	src += (slen - 4);
+	for(i = 0; i < slen; i+=8)  {
+		val =  *(unsigned int *)src;
+		src -= 4;
+		val |=  (((_uint64_t)(*(unsigned int *)src)) << 32);
+		src -= 4;
+		*(_uint64_t *)(dst + i) = val;
+	}
+	/* if slen is not dword, make last msb 0 */
+	if(slen & 7)
+		*(_uint64_t *)(dst + i - 8) = val & 0xffffffffULL;
+
+end:
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is word and most significant word first */
+static int rsa_ecc_soc_result_copy_fmt_word_mswf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+	_uint64_t val;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x3UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy from ls to ms */
+	/* goto the end of the dest */
+	dlen = cryptosoc_roundup(dlen, 4);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+
+	dst += (dlen - 4);
+	/* if min is not dword aligned */
+
+	for(i = 0; i < (min & ~0x7); i+=8) {
+		val = *(_uint64_t *)(src);
+		*(unsigned int *)dst = (unsigned int)val;
+		dst -= 4;
+		*(unsigned int *)dst = (unsigned int)(val >> 32);
+		dst -= 4;
+		src += 8;
+	}
+	if(min & 0x7)
+		*(unsigned int *)dst = (*(_uint64_t *)(src)) & 0xffffffffULL;
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is word and most significant word first */
+static int rsa_ecc_soc_input_copy_fmt_word_lswf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0x0ULL;
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)src & 0x3UL || (unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+
+	/* return error if source length is greater than engine length */
+	slen = cryptosoc_roundup(slen, 4);
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		val =  *(unsigned int *)src;
+		src += 4;
+		val |=  (((_uint64_t)(*(unsigned int *)src)) << 32);
+		src += 4;
+		*(_uint64_t *)(dst + i) = val;
+	}
+
+	/* if slen is not dword, make last msb 0 */
+	if(slen & 7)
+		*(_uint64_t *)(dst + i - 8) = val & 0xffffffffULL;
+
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is word and most significant word first */
+static int rsa_ecc_soc_result_copy_fmt_word_lswf(int dst_big_endian,
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+	int i, min;
+	int dlen = (d_nbits + 7) / 8;
+	int slen = s_nbits / 8;
+	_uint64_t val;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x4UL || (unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	dlen = cryptosoc_roundup(dlen, 4);
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+
+	for(i = 0; i < (min & ~0x7); i+=8) {
+		val = *(_uint64_t *)(src);
+		*(unsigned int *)(dst) = (unsigned int)val;
+		dst += 4;
+		*(unsigned int *)(dst) = (unsigned int)(val >> 32);
+		dst += 4;
+		src += 8;
+	}
+	if(min & 0x7)
+		*(unsigned int *)dst = (*(_uint64_t *)(src)) & 0xffffffffULL;
+
+	return CRYPTOSOC_OK;
+}
+
+
+/* input copy : src format is byte and most significant byte first */
+static int rsa_ecc_soc_input_copy_fmt_msbf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i = 0, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0)
+		goto end;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	/* goto the end of the source to get the last byte */
+	src += (slen - 1);
+	for(i = 0; i < slen; i+=8)  {
+		max = (slen - i) > 8 ? 8 : (slen - i);
+		val = 0ULL;
+		for(j=0; j<max; j++) {
+			/* end address contains lsb */
+			val |= (((_uint64_t)(*src)) << ((j % 8) * 8));
+			src -= 1;
+		}
+		*(_uint64_t *)(dst + i) = val;
+	}
+end:
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is byte and most significant byte first */
+static int rsa_ecc_soc_result_copy_fmt_msbf(int dst_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max, min;
+
+	cryptosoc_dbg_print("%s in dst %lx d_nbits %d src %lx s_nbits %d\n", __FUNCTION__,
+			(long)dst, d_nbits, (long)src, s_nbits);
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	if((unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the beginning */
+	if(min < dlen) 
+		memset(dst, 0, dlen - min);
+
+	/* got the end of destination */
+	dst += (dlen - 1);
+
+	for(i = 0; i < min; i+=8)  {
+		max = (min - i) > 8 ? 8 : (min - i);
+		val = *(_uint64_t *)(src + i);
+		for(j=0; j<max; j++) {
+			/* input is bigendian format, end address contains lsb */
+			*dst = (val >> ((j % 8) * 8)) & 0xffUL;
+			dst--;
+		}
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* input copy : src format is byte and least significant byte first */
+static int rsa_ecc_soc_input_copy_fmt_lsbf(int src_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max;
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if src is not  dword aligned, 
+	*      *  Engine dst and dlen should always be dword aligned */
+
+	cryptosoc_dbg_print("%s dst %lx src %lx dlen %d slen %d\n",
+			__FUNCTION__, (long)dst, (long)src, dlen, slen);
+
+	if((unsigned long)dst & 0x7UL || (dlen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* return error if source length is greater than engine length */
+	if(slen > dlen)
+		return -CRYPTOSOC_EINVAL;
+
+	for(i = 0; i < slen; i+=8)  {
+		max = (slen - i) > 8 ? 8 : (slen - i);
+		val = 0ULL;
+		for(j=0; j<max; j++) {
+			/* start address contains lsb */
+			val |= (((_uint64_t)(*src)) << ((j % 8) * 8));
+			src += 1;
+		}
+		*(_uint64_t *)(dst + i) = val;
+	}
+	/* clear the extra memory in the last */
+	if(i < dlen)
+		memset((dst + i), 0, (dlen - i));
+
+	return CRYPTOSOC_OK;
+}
+
+/* result copy : dst format is byte and least significant byte first */
+static int rsa_ecc_soc_result_copy_fmt_lsbf(int dst_big_endian, 
+		unsigned char *dst, int d_nbits, unsigned char *src, int s_nbits)
+{
+
+	int i, j;
+	int dlen = d_nbits / 8;
+	int slen = (s_nbits + 7) / 8;
+	_uint64_t val = 0;
+	int max, min;
+
+	cryptosoc_dbg_print("%s in dst %lx d_nbits %d src %lx s_nbits %d\n", __FUNCTION__,
+			(long)dst, d_nbits, (long)src, s_nbits);
+
+	/* Engine format is ms-dword last and in bigendian format.*/
+	/* Return error if dst is not dword aligned, 
+	*         Engine src and slen should always be dword aligned */
+
+	if((unsigned long)src & 0x7UL || (slen & 0x7))
+		return -CRYPTOSOC_EINVAL;
+
+	if(slen == 0 || dlen == 0)
+		return -CRYPTOSOC_EINVAL;
+
+	/* copy only the mininum of slen & dlen */
+	min = slen > dlen ? dlen : slen;
+
+	/* clear the extra memory in the last */
+	if(min < dlen) 
+		memset(dst + min, 0, dlen - min);
+	
+	for(i = 0; i < min; i+=8)  {
+		max = (min - i) > 8 ? 8 : (min - i);
+		val = *(_uint64_t *)(src + i);
+		for(j=0; j<max; j++) {
+			/* input is bigendian format, end address contains lsb */
+			*dst = val >> ((j % 8) * 8) & 0xff;
+			dst++; 
+		}
+	}
+
+	return CRYPTOSOC_OK;
+}
+
+/* RSA & ECC both have the same type of conversion routines */
+#ifdef ECCSOC_DATA_FORMAT_SET
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+	[ECCSOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_lsdwf,
+	[ECCSOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_mswf,
+	[ECCSOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_lswf,
+	[ECCSOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_msbf,
+	[ECCSOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_lsbf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[ECCSOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+	[ECCSOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_lsdwf,
+	[ECCSOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_mswf,
+	[ECCSOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_lswf,
+	[ECCSOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_msbf,
+	[ECCSOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_lsbf,
+};
+#else
+/* engine request and result data format conversion routine */
+static rsa_ecc_soc_data_copy rsa_ecc_soc_input_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_msdwf,
+	[RSASOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_dword_lsdwf,
+	[RSASOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_mswf,
+	[RSASOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_word_lswf,
+	[RSASOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_input_copy_fmt_msbf,
+	[RSASOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_input_copy_fmt_lsbf,
+};
+
+static rsa_ecc_soc_data_copy rsa_ecc_soc_result_copy_func[] = {
+	[RSASOC_DATA_WSZ_64BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_msdwf,
+	[RSASOC_DATA_WSZ_64BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_dword_lsdwf,
+	[RSASOC_DATA_WSZ_32BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_mswf,
+	[RSASOC_DATA_WSZ_32BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_word_lswf,
+	[RSASOC_DATA_WSZ_8BIT_MSW_FIRST] = rsa_ecc_soc_result_copy_fmt_msbf,
+	[RSASOC_DATA_WSZ_8BIT_LSW_FIRST] = rsa_ecc_soc_result_copy_fmt_lsbf,
+};
+#endif
+
+
+static inline int rsa_ecc_soc_find_max2(int a, int b)
+{	
+	if(a < b)
+		return b;
+	return a;
+}
+
+static inline int rsa_ecc_soc_find_max3(int a, int b, int c)
+{
+	int max = a;
+	if(max < b)
+		max = b;
+	if(max < c)
+		max = c;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max4(int a, int b, int c, int d)
+{
+	int max = rsa_ecc_soc_find_max3(a, b, c);
+	if(max < d)
+		max = d;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max5(int a, int b, int c, int d, int e)
+{
+	int max = rsa_ecc_soc_find_max4(a, b, c, d);
+	if(max < e)
+		max = e;
+	return max;
+}
+
+static inline int rsa_ecc_soc_find_max6(int a, int b, int c, int d, int e, int f)
+{
+	int max = rsa_ecc_soc_find_max5(a, b, c, d, e);
+	if(max < f)
+		max = f;
+	return max;
+}
+
+
+static inline int rsa_ecc_soc_input_copy_2(int inp_data_fmt, 
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, a, alen_in_bits)) < 0)
+		return rv;
+
+	mem += blk;
+
+	rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, b, blen_in_bits);
+	return rv;
+
+}
+
+static inline int rsa_ecc_soc_input_copy_3(int inp_data_fmt, 
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_2(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 2;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, c, clen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_4(int inp_data_fmt, 
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_3(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 3;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, d, dlen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_5(int inp_data_fmt, 
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits,
+		unsigned char *e, int elen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_4(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits, d, dlen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 4;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, e, elen_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_input_copy_6(int inp_data_fmt, 
+		int word_bigendian, unsigned char *mem, int blksz_in_bits,
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits,
+		unsigned char *c, int clen_in_bits, unsigned char *d, int dlen_in_bits,
+		unsigned char *e, int elen_in_bits, unsigned char *f, int flen_in_bits)
+{
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_input_copy_5(inp_data_fmt, word_bigendian, mem, 
+			blksz_in_bits, a, alen_in_bits, b, blen_in_bits,
+			c, clen_in_bits, d, dlen_in_bits, e, elen_in_bits)) < 0)
+		return rv;
+
+	mem  = mem + blk * 5;
+
+	rv = rsa_ecc_soc_input_copy_func[inp_data_fmt](
+			word_bigendian, mem, blksz_in_bits, f, flen_in_bits);
+	return rv;
+}
+	
+static inline int rsa_ecc_soc_result_copy_1(int res_data_fmt, 
+		int word_bigendian, unsigned char *a, int alen_in_bits,
+		unsigned char *mem, int blksz_in_bits)
+{
+	int rv;
+
+	rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, a, alen_in_bits, mem, blksz_in_bits);
+	return rv;
+}
+
+static inline int rsa_ecc_soc_result_copy_2(int res_data_fmt, 
+		int word_bigendian, 
+		unsigned char *a, int alen_in_bits, unsigned char *b, int blen_in_bits, 
+		unsigned char *mem, int blksz_in_bits)
+{
+
+	int rv;
+	int blk = blksz_in_bits / 8;
+
+	if((rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, a, alen_in_bits, mem, blksz_in_bits)) < 0)
+		return rv;
+
+	mem += blk;
+
+	rv = rsa_ecc_soc_result_copy_func[res_data_fmt](
+			word_bigendian, b, blen_in_bits, mem, blksz_in_bits);
+	return rv;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_defs.h b/arch/mips/netlogic/lib/seclib/rsasoc_defs.h
new file mode 100644
index 0000000..2088838
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_defs.h
@@ -0,0 +1,122 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_DEFS_H
+#define _RSASOC_DEFS_H
+
+/**
+* enum rsasoc_data_format - RSA Data input/output format
+*
+* @RSASOC_DATA_WSZ_64BIT_MSW_FIRST: Individual unit size is 64bit and 
+* 		most significant word is first. Memory should be dword aligned,
+*		and total allocated size should be multiple of dword size.
+* @RSASOC_DATA_WSZ_64BIT_LSW_FIRST: Individual unit size is dword and 
+* 		least significant dword is first. Memory should be dword aligned,
+*       and total allocated size should be multiple of dword size
+* @RSASOC_DATA_WSZ_32BIT_MSW_FIRST: Individual unit size is 32bit and 
+* 		most significant word is first. Memory should be word aligned
+* 		and total allocated size should be multiple of word size.
+* @RSASOC_DATA_WSZ_32BIT_LSW_FIRST: Individual unit size is 32bit and 
+* 		least significant word is first. Memory should be word aligned
+*       and total allocated size should be multiple of word size.
+* @RSASOC_DATA_WSZ_8BIT_MSW_FIRST: Individual unit size is 8bit and 
+* 		most significant word is first. 
+* @RSASOC_DATA_WSZ_8BIT_LSW_FIRST: Individual unit size is 8bit and 
+* 		least significant word is first
+* @RSASOC_DATA_FMT_MAX: End of data format type
+*/
+enum rsasoc_data_format {
+	RSASOC_DATA_WSZ_64BIT_MSW_FIRST=0,
+	RSASOC_DATA_WSZ_64BIT_LSW_FIRST,
+	RSASOC_DATA_WSZ_32BIT_MSW_FIRST,
+	RSASOC_DATA_WSZ_32BIT_LSW_FIRST,
+	RSASOC_DATA_WSZ_8BIT_MSW_FIRST,
+	RSASOC_DATA_WSZ_8BIT_LSW_FIRST,
+	RSASOC_DATA_FMT_MAX
+};
+
+#define RSASOC_DATA_FORMAT_SET
+
+/**
+* enum rsasoc_op_type - RSA Operation type
+* @RSASOC_TYPE_512  : 512 bits operation
+* @RSASOC_TYPE_1024  : 1024 bits operation
+* @RSASOC_TYPE_2048  : 2048 bits operation
+* @RSASOC_TYPE_4096  : 4096 bits operation
+* @RSASOC_TYPE_8192  : 8192 bits operation
+* @RSASOC_TYPE_MICROCODE_LOAD  : Microcode load operation
+*/
+enum rsasoc_op_type {
+	RSASOC_TYPE_512=0x40,
+	RSASOC_TYPE_1024=0x41,
+	RSASOC_TYPE_2048=0x42,
+	RSASOC_TYPE_4096=0x43,
+	RSASOC_TYPE_8192=0x44,
+	RSASOC_TYPE_MICROCODE_LOAD=0x70
+};
+
+/**
+* enum rsasoc_op - RSA Operation
+* @RSASOC_MOD_EXP  : Mod exponentiation
+* @RSASOC_MOD_MUL  : Mod multiplication 
+* @RSASOC_OP_MAX : End of operation
+*/
+enum rsasoc_op {
+	RSASOC_MOD_EXP = 0x0,
+	RSASOC_MOD_MUL,
+	RSASOC_OP_MAX
+	
+};
+
+/**
+* defines rsa_req_flags - Rsa operation request flags
+* @RSASOC_SRC_L3_ALLOC: Casuses source data to transit through L3 cache
+* @RSASOC_DST_L3_ALLOC: Causes data written to the dram is also copied to l3 cache
+* @RSASOC_DST_CLOBBER: Causes data to be written as 64byte cacheline, 
+*   no read modify write
+* @RSASOC_ARGS_MEM_REGION_CRYPTOSOC: All the arguments are allocated 
+*    using cryptosoc_mem_alloc. So that virt_to_phys conversion can be done.
+
+*/
+
+/*!defines rsa_req_flags < */
+#define RSASOC_SRC_L3_ALLOC 0x01
+#define RSASOC_DST_L3_ALLOC 0x02
+#define RSASOC_DST_CLOBBER  0x04
+#define RSASOC_ARGS_MEM_REGION_CRYPTOSOC 0x8
+/*!defines rsa_req_flags > */
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
new file mode 100644
index 0000000..2372b0d
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_gen1_hal_defs.h
@@ -0,0 +1,172 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _RSASOC_GEN1_HAL_DEFS_H_
+#define _RSASOC_GEN1_HAL_DEFS_H_
+
+#include "cryptosoc_lib.h"
+
+#define RSASOC_GEN1_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & RSASOC_GEN1_##PARAM##_MASK) << RSASOC_GEN1_##PARAM##_SHIFT)
+
+#define RSASOC_GEN1_GET_BITS(X,PARAM) \
+	 ((_uint64_t)(( (_uint64_t)X >> RSASOC_GEN1_##PARAM##_SHIFT) & \
+		 RSASOC_GEN1_##PARAM##_MASK)) 
+	
+
+#define RSASOC_GEN1_SRC_L3_ALLOC_MASK 0x1ULL
+#define RSASOC_GEN1_SRC_L3_ALLOC_SHIFT 61
+
+#define RSASOC_GEN1_TYPE_MASK 0x7fULL
+#define RSASOC_GEN1_TYPE_SHIFT 46
+
+#define RSASOC_GEN1_FUNC_MASK 0x3fULL
+#define RSASOC_GEN1_FUNC_SHIFT 40
+
+#define RSASOC_GEN1_SRC_ADDR_MASK 0xffffffffffULL
+#define RSASOC_GEN1_SRC_ADDR_SHIFT 0
+
+
+#define RSASOC_GEN1_DST_CLOBBER_MASK 0x1ULL
+#define RSASOC_GEN1_DST_CLOBBER_SHIFT 62
+
+#define RSASOC_GEN1_DST_L3_ALLOC_MASK 0x1ULL
+#define RSASOC_GEN1_DST_L3_ALLOC_SHIFT 61
+
+#define RSASOC_GEN1_FBVC_MASK 0xfffULL
+#define RSASOC_GEN1_FBVC_SHIFT 40
+
+#define RSASOC_GEN1_DST_ADDR_MASK 0xffffffffffULL
+#define RSASOC_GEN1_DST_ADDR_SHIFT 0
+
+
+
+/**
+* rsasoc_gen1_form_fmn_entry0 - Generate crypto rsa fmn message entry 0
+* @src_l3_alloc: 1/0, 1 casuses source data to transit through l3 cache
+* @type: type of the operation, see rsasoc_op_type
+* @func: operation function, see rsasoc_op_func
+* @src_addr : source address
+*
+* Returns: Filled fmn entry0
+*/
+
+static inline _uint64_t  rsasoc_gen1_form_fmn_entry0(unsigned int src_l3_alloc, 
+		unsigned int type, 
+		unsigned int func, _uint64_t src_addr)
+{
+	return( RSASOC_GEN1_SET_BITS(src_l3_alloc, SRC_L3_ALLOC) |
+		RSASOC_GEN1_SET_BITS(type, TYPE) | 
+		RSASOC_GEN1_SET_BITS(func, FUNC) |
+		RSASOC_GEN1_SET_BITS(src_addr, SRC_ADDR));
+}
+
+/**
+* rsasoc_gen1_form_fmn_entry1 -  Generate crypto rsa fmn message entry 1
+* 
+* @dst_clobber: 1/0, 1 causes data to be written as 64byte cacheline
+* @dst_l3_alloc: 1/0, 1 causes data written to the dram is also copied to l3 cache
+* @fbvc: freeback message vc
+* @dst_addr : destination address where result will be copied
+*
+* Returns: Filled fmn entry1
+*/
+
+
+static inline _uint64_t  rsasoc_gen1_form_fmn_entry1(unsigned int dst_clobber, 
+		unsigned int dst_l3_alloc, 
+		unsigned int fbvc, _uint64_t dst_addr)
+{
+
+	return( RSASOC_GEN1_SET_BITS(dst_clobber, DST_CLOBBER) |
+		RSASOC_GEN1_SET_BITS(dst_l3_alloc, DST_L3_ALLOC) | 
+		RSASOC_GEN1_SET_BITS(fbvc, FBVC) |
+		RSASOC_GEN1_SET_BITS(dst_addr, DST_ADDR));
+
+}
+
+static inline char *rsasoc_get_op_type(int val, char *buf)
+{
+	char op_type[][16] = {
+		"Mod512", "Mod1024", "Mod2048",
+		"Mod4096", "Mod8192", "MicroLoad" };
+
+	strcpy(buf, "Reserved");
+	if(val >= 0x40 && val <= 0x44)
+		strcpy(buf, op_type[val - 0x40]);
+	if(val == 0x70)
+		strcpy(buf, op_type[5]);
+	return buf;
+}
+
+static inline char *rsasoc_get_op_func(int val, char *buf)
+{
+	char op[][16] = { "ModExp",  "ModMul" };
+	strcpy(buf, "Reserved");
+	if(val <= 1)
+		strcpy(buf, op[val]);
+	return buf;
+}
+
+
+
+static inline void rsasoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+{
+	char buf[32], buf1[32];
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n",
+			"SrcL3Alloc","Type", "Func", "SrcAddr");
+
+	cryptosoc_print("  %-16lld %-16s %-16s %-16llx\n",
+			RSASOC_GEN1_GET_BITS(entry0, SRC_L3_ALLOC),
+			rsasoc_get_op_type(RSASOC_GEN1_GET_BITS(entry0, TYPE), buf),
+			rsasoc_get_op_func(RSASOC_GEN1_GET_BITS(entry0, FUNC), buf1),
+			RSASOC_GEN1_GET_BITS(entry0, SRC_ADDR));
+
+	cryptosoc_print("\n  %-16s %-16s %-16s %-16s\n",
+			"DstClobber","DstL3Alloc", "FbVC", "DstAddr");
+
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx\n",
+			RSASOC_GEN1_GET_BITS(entry1, DST_CLOBBER),
+			RSASOC_GEN1_GET_BITS(entry1, DST_L3_ALLOC),
+			RSASOC_GEN1_GET_BITS(entry1, FBVC),
+			RSASOC_GEN1_GET_BITS(entry1, DST_ADDR));
+
+	cryptosoc_print("\n");
+
+}
+
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_lib.h b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
new file mode 100644
index 0000000..958b01b
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_lib.h
@@ -0,0 +1,745 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_LIB_H
+#define _RSASOC_LIB_H
+
+/* Include file for application specific macros */
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
+
+#ifdef RSASOC_PTYPE_GEN_ALL_SUPPORT
+#define RSASOC_PTYPE_GEN2_SUPPORT
+#define RSASOC_PTYPE_GEN1_SUPPORT
+#endif
+
+#include "rsasoc_defs.h"
+#include "rsaecc_soc_common.h"
+
+/* Include file for processor specific macros to set the descriptors. 
+*  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
+#ifdef RSASOC_PTYPE_GEN2_SUPPORT
+#include "rsasoc_gen1_hal_defs.h"
+#endif
+
+#ifdef RSASOC_PTYPE_GEN1_SUPPORT
+#include "rsasoc_gen1_hal_defs.h"
+#endif
+
+
+#ifdef RSASOC_PTYPE_GEN_ALL_SUPPORT
+#define IF_RSASOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_RSASOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+#else
+#define IF_RSASOC_PTYPE_IS_GEN1
+#define IF_RSASOC_PTYPE_IS_GEN2 
+#endif
+
+#include "nlm_hal_fmn.h"
+
+/**
+* DOC: RSASOC
+*
+* These APIs abstract the RSA SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* RSASOC_REQ_DESC_APP_PRIV_SZ:
+*   Application private data size in the request descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either RSASOC_PTYPE_GEN_ALL_SUPPORT or 
+*  RSASOC_PTYPE_GEN2_SUPPORT/RSASOC_PTYPE_GEN1_SUPPORT
+*/
+
+
+struct rsasoc_req_desc_priv_data {
+	/* number of operations to perform. The application can fill
+	*  multiple operations in one structure and can send to the engine 
+	*  in parallel or serial. 
+	*  */
+	int num_reqs; 
+	/* To save the input/return data address,
+	num_reqs size, dynamically allocated */
+	int max_reqs;
+	struct rsasoc_req_info *req_info; 
+};
+
+/* This should be aligned to 8 bytes, as the engine 
+*  data starts after this and that should be aligned 
+*  to 8 bytes */
+struct rsasoc_req_info {
+	void *inp; /* data memory - allocated by the library */
+	void *res; /* result memory - allocated by the library */
+
+	int inp_alloc; /* if inp is separately allocated */
+	int res_alloc; /* if res is separately allocated */
+
+	int inp_size; /* size of input mem */
+	int res_size; /* size of result mem */
+
+	void *eng_inp; /* input data memory, either inp or input-args */
+	void *eng_res; /* result data memory, either res or result-args  */
+
+	void *usr_res; /* user given result memory */
+	void *pad;
+
+	int rlen_in_bits; /* user given result memory bitlen */
+	int blksz_in_bits;
+
+	int op; /* operation */
+	int type; /* type */
+
+	int flags;
+	int out_data_fmt;
+
+	int out_word_bigendian;
+	int pad1;
+	
+};
+
+
+#define RSASOC_REQ_DESC_LIB_PRIV_SZ \
+	 (((sizeof(struct rsasoc_req_desc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define RSASOC_MAX_BLOCK_SZ_IN_BITS 	8192
+#define RSASOC_MAX_DATA_ARGS			4
+#define RSASOC_TYPE_SVALUE				0x40
+
+/**
+* struct rsasoc_arg - Operation data argument type
+* @v: Input value
+* @len_in_bits : Value length in bits
+*/
+struct rsasoc_arg {
+	void *v;
+	int  len_in_bits;
+};
+
+/**
+* struct rsasoc_mexp_args - Mod exponentiation data arguments(r = x^y mod n)
+* @x : Input parameter-1
+* @y : Input parameter-2
+* @n : Modulus
+* @r : Result
+*/
+struct rsasoc_mexp_args {
+	struct rsasoc_arg x;
+	struct rsasoc_arg y;
+	struct rsasoc_arg n;
+	struct rsasoc_arg r;
+};
+
+/**
+* struct rsasoc_mmul_args - Mod multiplication data arguments(r = x*n mod n)
+* @x : Input parameter-1
+* @y : Input parameter-2
+* @n : Modulus
+* @r : Result
+*/
+struct rsasoc_mmul_args {
+	struct rsasoc_arg x;
+	struct rsasoc_arg y;
+	struct rsasoc_arg n;
+	struct rsasoc_arg r;
+};
+
+
+/**
+* struct rsasoc_request_params - Each operation request parameters
+* @inp_data_fmt: Input data format, see enum rsasoc_data_format
+* @out_data_fmt: Output data format, see enum rsasoc_data_format
+* @word_bigendian: 1/0, Depending on the data word is big endian/little endian
+* @req_num : Request number
+* @flags: Request flags, see define rsa_req_flags
+*/
+struct rsasoc_request_params {
+	enum rsasoc_data_format inp_data_fmt;
+	enum rsasoc_data_format out_data_fmt;
+	int word_bigendian;
+	int req_num;
+	int flags; 
+};
+
+
+
+/**
+* struct rsasoc_request_desc - Operation request descriptor parameters
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @data: Data storage space. Dynamic sized depending on the block size.
+*/
+struct rsasoc_request_desc {
+	char lib_priv[RSASOC_REQ_DESC_LIB_PRIV_SZ];
+	char app_priv[RSASOC_REQ_DESC_APP_PRIV_SZ];
+	char data[0];
+}___cryptosoc_cacheline_aligned;
+
+/**
+* struct rsasoc_extra_req_send_params - RSA send request options
+* @send_all_requests : 1/0, Send all the requests present in the data descriptor
+* @sreq_num : Starting request number, Ignored 
+*    if the send_all_requests is true.
+* @num_reqs : Number of request from sreq_num, Ignored 
+*    if the send_all_requests is true.
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct rsasoc_extra_req_send_params {
+	int send_all_requests;
+	int sreq_num;
+	int num_reqs;
+	_uint64_t async_rsp_arg;
+};
+
+static inline struct rsasoc_request_desc *rsasoc_create_new_desc(
+		struct rsasoc_request_desc *desc,
+		int req_num, 
+		int max_reqs, int inp_size, int res_size)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int idx= 0;
+
+	if(desc) {
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+		/* check the input */
+		if(inp_size && (dpriv->req_info[req_num].inp_size < inp_size)) {
+			if(dpriv->req_info[req_num].inp_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp = cryptosoc_mem_alloc(8, inp_size);
+			if(!dpriv->req_info[req_num].inp)
+				return NULL;
+			dpriv->req_info[req_num].inp_alloc = 1;
+		  	dpriv->req_info[req_num].inp_size = inp_size;
+		}
+
+		/* check the result */
+		if(res_size && (dpriv->req_info[req_num].res_size < res_size)) {
+			if(dpriv->req_info[req_num].res_alloc)
+				cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res = cryptosoc_mem_alloc(8, res_size);
+			if(!dpriv->req_info[req_num].res)
+				return NULL;
+			dpriv->req_info[req_num].res_alloc = 1;
+		  	dpriv->req_info[req_num].res_size = res_size;
+		}
+	} else {
+		int req_info_sz = max_reqs * sizeof(struct rsasoc_req_info);
+		int size = inp_size + res_size + req_info_sz;
+		void *mbase;
+		desc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ, sizeof(*desc) + size);
+		if(!desc)
+			return NULL; 
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+		dpriv->num_reqs = 0;
+		dpriv->max_reqs = max_reqs;
+		dpriv->req_info =  (struct rsasoc_req_info *)&desc->data[0];
+	
+		mbase = (void *)((unsigned long)dpriv->req_info + req_info_sz);
+
+		/* part of desc */
+		dpriv->req_info[0].inp_alloc= 0;
+		dpriv->req_info[0].res_alloc= 0;
+		dpriv->req_info[0].op = -1;
+
+		if(inp_size) {
+			dpriv->req_info[0].inp = mbase;
+			dpriv->req_info[0].inp_size = inp_size;
+			mbase += inp_size;
+		} else
+			dpriv->req_info[0].inp_size = 0;
+
+		if(res_size) {
+			dpriv->req_info[0].res = mbase;
+			dpriv->req_info[0].res_size = res_size;
+		} else
+			 dpriv->req_info[0].res_size = 0;
+
+		for(idx = 1; idx < max_reqs; idx++) {
+			dpriv->req_info[idx].inp_alloc= 0;
+			dpriv->req_info[idx].res_alloc= 0;
+			dpriv->req_info[idx].inp_size = 0;
+			dpriv->req_info[idx].res_size = 0;
+		}
+	}
+	return desc;
+}
+
+
+/**
+* rsasoc_create_mod_exp_request - Create mod-exponentiation request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod exponentiation args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int rsasoc_create_mod_exp_request(
+		struct rsasoc_request_params *req_p,
+		int max_reqs,
+		struct rsasoc_request_desc **req_desc,
+		struct rsasoc_mexp_args *margs)
+{
+	int blksz_in_bits, blk, max_len_in_bits;
+	int inp_size = 0, res_size = 0;
+    int bitset, type;	
+	struct rsasoc_req_desc_priv_data *dpriv;
+	struct rsasoc_request_desc *desc = NULL;
+	int req_num;
+
+	if(!req_p || !margs )
+		return -CRYPTOSOC_EINVAL;
+
+	if(req_desc)
+		desc = *req_desc;
+
+	req_num = req_p->req_num;
+	if(desc) {
+		dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+	   	if(dpriv->max_reqs < req_num) {
+			cryptosoc_err_print("%s:%d, Error - Request overflow \n", 
+					__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+		}
+	} else if(req_num != 1 || max_reqs <= 0) {
+		/* request number should be one for the new descriptor 
+		*  creation */
+		cryptosoc_err_print("%s:%d, Error - Invalid request number \n", 
+					__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* result length should be greater or equal to the 
+	*  modulus length */
+	if(margs->r.len_in_bits < margs->n.len_in_bits) {
+		cryptosoc_err_print("%s:%d, Error - Result size  < modsize \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+
+	max_len_in_bits = rsa_ecc_soc_find_max3(margs->x.len_in_bits,
+		   margs->y.len_in_bits, margs->n.len_in_bits);
+
+	if(max_len_in_bits > RSASOC_MAX_BLOCK_SZ_IN_BITS) {
+		cryptosoc_err_print("%s:%d, Error - Invalid block size \n", 
+				__FUNCTION__, __LINE__);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	/* block size starts from 512, roundup the size to the next one supported
+	*  by the engine */
+	bitset = cryptosoc_get_lbs(max_len_in_bits) - 1;
+	if(bitset < 9) 
+		bitset = 9;
+	else if ((max_len_in_bits - (1 << bitset)) > 0)
+		bitset++;
+
+	blksz_in_bits = 1 << bitset;
+	blk = blksz_in_bits / 8;
+
+
+	/* check whether input copy required */
+	if(!(req_p->flags & RSASOC_ARGS_MEM_REGION_CRYPTOSOC))  {
+		inp_size =  (RSASOC_MAX_DATA_ARGS - 1) * blk;
+		res_size = blk;
+	} else  {
+		if(((margs->x.v + blk) != margs->y.v) ||
+				((margs->y.v + blk) != margs->n.v) ||
+				(margs->n.len_in_bits != blksz_in_bits) ||
+				(req_p->inp_data_fmt !=  RSASOC_DATA_WSZ_64BIT_LSW_FIRST))
+			inp_size =  (RSASOC_MAX_DATA_ARGS - 1) * blk;
+
+		if((margs->r.len_in_bits != blksz_in_bits) || 
+				(req_p->out_data_fmt !=  RSASOC_DATA_WSZ_64BIT_LSW_FIRST))
+			res_size = blk;
+	}
+
+	req_num--;
+
+	desc = rsasoc_create_new_desc(desc, req_num, 
+			max_reqs, inp_size, res_size);
+	if(!desc)
+		return -CRYPTOSOC_ENOMEM;
+	dpriv = (struct rsasoc_req_desc_priv_data *)desc->lib_priv;
+
+	if(inp_size) {
+		void *mem = dpriv->req_info[req_num].inp;
+		dpriv->req_info[req_num].eng_inp = mem;
+
+		if(rsa_ecc_soc_input_copy_3(req_p->inp_data_fmt,
+					 req_p->word_bigendian, mem, blksz_in_bits,
+					  margs->x.v, margs->x.len_in_bits,
+					  margs->y.v, margs->y.len_in_bits,
+					  margs->n.v, margs->n.len_in_bits) < 0)
+			goto err_exit;
+	} else
+		dpriv->req_info[req_num].eng_inp = margs->x.v;
+	
+	if(res_size) {
+		 dpriv->req_info[req_num].eng_res =  dpriv->req_info[req_num].res;
+		 dpriv->req_info[req_num].usr_res =  margs->r.v;
+		 dpriv->req_info[req_num].rlen_in_bits = margs->r.len_in_bits;
+		 dpriv->req_info[req_num].out_data_fmt = req_p->out_data_fmt;
+		 dpriv->req_info[req_num].out_word_bigendian = req_p->word_bigendian;
+		 dpriv->req_info[req_num].flags = req_p->flags;
+	} else {
+		 dpriv->req_info[req_num].eng_res =  margs->r.v;
+		 dpriv->req_info[req_num].usr_res = NULL;
+	}
+
+	bitset = cryptosoc_get_lbs(blksz_in_bits) - 1;
+	type = bitset - 9 + RSASOC_TYPE_SVALUE;
+
+	dpriv->req_info[req_num].type = type;
+	dpriv->req_info[req_num].op = RSASOC_MOD_EXP;
+	dpriv->req_info[req_num].blksz_in_bits = blksz_in_bits;
+
+	/* request number is decremented above */
+	if(req_num >= dpriv->num_reqs)
+		dpriv->num_reqs++;
+	*req_desc = desc;
+	return CRYPTOSOC_OK;
+err_exit:
+	cryptosoc_err_print("%s:%d, Error - Data copy failed \n", 
+		__FUNCTION__, __LINE__);
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+/**
+* rsasoc_create_mod_mul_request - Create mod-multiplication request
+* @req_p : Pointer to the operation request param(input)
+* @max_reqs: Number of operations present in one descriptor
+*   The application can fill multiple operations in one structure and can 
+*   send to the engine in parallel or serial. Considered only when
+*   req_desc = NULL;
+* @req_desc : Pointer to request descriptor(input/output)
+* @margs : Pointer to mod multiplication args(input)
+*
+* Returns : CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM
+*/
+static inline int rsasoc_create_mod_mul_request(
+		struct rsasoc_request_params *req_p,
+		int max_reqs,
+		struct rsasoc_request_desc **req_desc,
+		struct rsasoc_mmul_args *margs)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int rv;
+	/* parameter passing is the same for both mod-exp and mod-mul */
+	rv = rsasoc_create_mod_exp_request(req_p, max_reqs, req_desc, 
+			(struct rsasoc_mexp_args *)margs);
+	if(rv == CRYPTOSOC_OK) {
+		int req_num = req_p->req_num;
+		dpriv = (struct rsasoc_req_desc_priv_data *)((*req_desc)->lib_priv);
+		dpriv->req_info[req_num - 1].op = RSASOC_MOD_MUL;
+	}
+	return rv;
+}
+
+/**
+* rsasoc_process_request - Send/Receive the descriptor info to/from 
+* the engine
+* @ctx : Pointer to the context(input). 
+* @req_desc : Pointer to the request descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. 
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request(input)
+*   Functions sends out all the requests if mparam==NULL
+* @sync_res: Engine result response if mode is sync(output)
+* Rsp should be allocated for the number of requests that
+* are going to be sent out
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*
+*/
+static inline int rsasoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct rsasoc_request_desc *req_desc, 
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		struct rsasoc_extra_req_send_params *mparam,
+		struct rsasoc_rsp_result *sync_res)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int idx, gen_type2 = 0;
+	_uint64_t fmn_entry0, fmn_entry1, fmn_entry2 = 0ULL;
+	void *mem, *rmem;
+	int sreq_num, ereq_num;
+	int rv = -CRYPTOSOC_EINVAL;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	if(mparam == NULL || mparam->send_all_requests) {
+		sreq_num = 0;
+		ereq_num = dpriv->num_reqs;
+	} else {
+		sreq_num = mparam->sreq_num - 1;
+		ereq_num = sreq_num  +  mparam->num_reqs;
+
+		if((sreq_num >= dpriv->num_reqs) || (ereq_num >  dpriv->num_reqs)) 
+			return -CRYPTOSOC_EINVAL;
+	}
+
+	fmn_entry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+	for(idx = sreq_num; idx < ereq_num; idx++) {
+		mem = dpriv->req_info[idx].eng_inp;
+		rmem = dpriv->req_info[idx].eng_res;
+
+		if(dpriv->req_info[idx].op < 0)
+			return -CRYPTOSOC_EINVAL;
+
+		fmn_entry0 = rsasoc_gen1_form_fmn_entry0(
+				dpriv->req_info[idx].flags & RSASOC_SRC_L3_ALLOC ? 1 : 0, 
+				dpriv->req_info[idx].type, dpriv->req_info[idx].op, 
+				cryptosoc_virt_to_phys((unsigned long)mem));
+
+		fmn_entry1 = rsasoc_gen1_form_fmn_entry1(
+				dpriv->req_info[idx].flags & RSASOC_DST_CLOBBER ? 1: 0,
+				dpriv->req_info[idx].flags & RSASOC_DST_L3_ALLOC ? 1 : 0,
+				rsp_vc, 
+				cryptosoc_virt_to_phys((unsigned long)rmem));
+
+
+		if(!ctx) {
+			rv = cryptosoc_process_request(gen_type2, CRYPTOSOC_RSA, 
+					req_vc, rsp_vc, code, retry_count,
+					fmn_entry0, fmn_entry1, fmn_entry2,
+					sync_res ? &sync_res->result : NULL);
+		} else {
+			rv =  cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_RSA,
+					req_vc, rsp_vc, code, retry_count, 
+					fmn_entry0, fmn_entry1, fmn_entry2, 
+					sync_res ? &sync_res->result : NULL, NULL);
+		}
+		if(sync_res)
+			sync_res++;
+
+		if(rv < 0)
+			break;
+	}
+	return rv;
+}
+
+/**
+* rsasoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int rsasoc_result_valid(struct rsasoc_rsp_result *res)
+{
+	/* TODO */
+	return 1;
+}
+
+/**
+* rsasoc_copy_result - Copy the result from the engine to the user
+*   given argument during operation request. This should be called
+*   by the application after getting back the valid response from the 
+*   given request.
+* @req_desc: Pointer to the request descriptor
+* @req_num: Request number
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+static inline int rsasoc_copy_result(struct rsasoc_request_desc *req_desc, int req_num)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	void *rmem;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return -CRYPTOSOC_EINVAL;
+
+	/* Nothing to do if application already passed the 
+	*  result address in the required format */
+	if(!dpriv->req_info[req_num].usr_res)
+		return  CRYPTOSOC_OK;
+
+	if(dpriv->req_info[req_num].op < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	rmem = dpriv->req_info[req_num].eng_res;
+
+	if(rsa_ecc_soc_result_copy_1(dpriv->req_info[req_num].out_data_fmt,
+			dpriv->req_info[req_num].out_word_bigendian,
+			dpriv->req_info[req_num].usr_res,
+			dpriv->req_info[req_num].rlen_in_bits,
+			rmem, dpriv->req_info[req_num].blksz_in_bits) < 0)
+		return -CRYPTOSOC_EINVAL;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* rsasoc_reset_request_desc - Reset the request descriptor. 
+* Application should call this function if  this descriptor 
+* was used for more than one request,  and to start from the req_num=1
+* again.
+* @req_desc: Pointer to the request descriptor. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL;
+*/
+static inline int rsasoc_reset_request_desc(struct rsasoc_request_desc *req_desc)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int req_num;
+
+	if(!req_desc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+			dpriv->req_info[req_num].inp_alloc = 0;
+			dpriv->req_info[req_num].inp_size = 0;
+		}
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res) {
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+			dpriv->req_info[req_num].res_alloc = 0;
+			 dpriv->req_info[req_num].res_size = 0;
+		}
+		dpriv->req_info[req_num].op = -1;
+	}
+
+	dpriv->num_reqs = 0;
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* rsasoc_free_request_desc - Free the request descriptor
+* @req_desc: Pointer to the request descriptor
+*
+*/
+static inline void rsasoc_free_request_desc(struct rsasoc_request_desc *req_desc)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int req_num;
+	if(!req_desc)
+		return;
+
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+	for(req_num = 0; req_num < dpriv->num_reqs; req_num++) {
+		if(dpriv->req_info[req_num].inp_alloc && 
+				dpriv->req_info[req_num].inp)
+			cryptosoc_mem_free(dpriv->req_info[req_num].inp);
+		if(dpriv->req_info[req_num].res_alloc && 
+				dpriv->req_info[req_num].res)
+			cryptosoc_mem_free(dpriv->req_info[req_num].res);
+	}
+	cryptosoc_mem_free(req_desc);
+}
+
+/**
+* rsasoc_dump_request_data - Dump the input data in the engine format
+* @req_desc: Pointer to the request descriptor
+* @req_num: Request number
+*
+*/
+static inline void rsasoc_dump_request_data(
+		struct rsasoc_request_desc *req_desc, int req_num)
+{
+	struct rsasoc_req_desc_priv_data *dpriv;
+	int blk, i, arg;
+	char *mem;
+	char p[][4]={"x", "y", "n"};
+
+	if(!req_desc)
+		return;
+	dpriv = (struct rsasoc_req_desc_priv_data *)req_desc->lib_priv;
+
+	req_num--;
+	if(req_num >= dpriv->num_reqs)
+		return;
+
+	blk = dpriv->req_info[req_num].blksz_in_bits / 8;
+
+	cryptosoc_print("BlkszInBits %d  MaxReqs %d NumReqs %d InpSize %d ResSize %d\n", 
+			dpriv->req_info[req_num].blksz_in_bits,
+			dpriv->max_reqs, dpriv->num_reqs, 
+			dpriv->req_info[req_num].inp_size, 
+			dpriv->req_info[req_num].res_size);
+
+	mem = dpriv->req_info[req_num].eng_inp;
+
+	for(arg=0; arg < 3; arg++) {
+		cryptosoc_print("%s\n", p[arg]);
+		for(i = 0; i < blk; ) {
+			cryptosoc_print(" <%016llx>", *(_uint64_t *)(mem + i));
+			i += 8;
+			if((i % 32) == 0)
+				cryptosoc_print("\n");
+		}
+		cryptosoc_print("\n");
+		mem = mem + blk;
+	}
+	return;
+}
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/rsasoc_ucode.h b/arch/mips/netlogic/lib/seclib/rsasoc_ucode.h
new file mode 100644
index 0000000..427352d
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/rsasoc_ucode.h
@@ -0,0 +1,1841 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _RSASOC_UCODE_H
+#define _RSASOC_UCODE_H
+static uint64_t  rsasoc_gen1_ucode_data [] = {
+0x0000000000000000ULL,
+0x00000000503840ecULL,
+0x00000001903800ecULL,
+0x00000002c03820ecULL,
+0x0000003760000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x00000007d000010cULL,
+0x0000001b80000c0cULL,
+0x00000000e03fc0ecULL,
+0x00000001103fc1ecULL,
+0x00000001403f42ecULL,
+0x00000001403fc4ecULL,
+0x0000003760000044ULL,
+0x000000001800003cULL,
+0x0000000d8000030cULL,
+0x0000000630000044ULL,
+0x000000002800003cULL,
+0x0000000ef000030cULL,
+0x0000000630000044ULL,
+0x00000000503fc23cULL,
+0x00000000a03fc33cULL,
+0x00000001403fc43cULL,
+0x00000010c000030cULL,
+0x0000000630000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x0000001c1000070cULL,
+0x0000002500000d0cULL,
+0x00000027c0000e0cULL,
+0x0000002d60000f0cULL,
+0x00000002603f00ecULL,
+0x00000002603f82ecULL,
+0x00000002803f83ecULL,
+0x00000002803f04ecULL,
+0x00000002a03f06ecULL,
+0x00000002a03f88ecULL,
+0x0000003760000044ULL,
+0x000000086000010cULL,
+0x00000003f0000044ULL,
+0x00000008d000010cULL,
+0x00000004b0000044ULL,
+0x00000008d000010cULL,
+0x0000000570000044ULL,
+0x000000000000001cULL,
+0x000000076000000cULL,
+0x0000001c1000070cULL,
+0x0000002690000d0cULL,
+0x0000002990000e0cULL,
+0x0000002e10000f0cULL,
+0x00000003903f20ecULL,
+0x00000003903fa2ecULL,
+0x00000003b03fa3ecULL,
+0x00000003b03f24ecULL,
+0x00000003d03f26ecULL,
+0x00000003d03fa8ecULL,
+0x0000003760000044ULL,
+0x000000096000010cULL,
+0x00000003f0000044ULL,
+0x0000000a0000010cULL,
+0x00000004b0000044ULL,
+0x0000000a0000010cULL,
+0x0000000570000044ULL,
+0x000000000800003cULL,
+0x0000000af000020cULL,
+0x0000000bc000030cULL,
+0x000000129000040cULL,
+0x000000178000050cULL,
+0x000000191000060cULL,
+0x0000001ff000080cULL,
+0x000000205000090cULL,
+0x00000022c0000a0cULL,
+0x00000020b0000b0cULL,
+0x0000001ac0000c0cULL,
+0x0000000680000044ULL,
+0x000000001000003cULL,
+0x0000000b5000020cULL,
+0x0000000c5000030cULL,
+0x000000137000040cULL,
+0x00000017e000050cULL,
+0x000000197000060cULL,
+0x000000200000080cULL,
+0x000000206000090cULL,
+0x0000002340000a0cULL,
+0x0000002110000b0cULL,
+0x0000001b10000c0cULL,
+0x0000000680000044ULL,
+0x000000001800003cULL,
+0x0000000b5000020cULL,
+0x0000000d8000030cULL,
+0x000000154000040cULL,
+0x000000187000050cULL,
+0x0000001a0000060cULL,
+0x000000202000080cULL,
+0x000000208000090cULL,
+0x0000002410000a0cULL,
+0x00000021c0000b0cULL,
+0x0000001b80000c0cULL,
+0x0000000680000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x0000002ed01f80e4ULL,
+0x00000030101f81e4ULL,
+0x0000003760000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x00000030d01f00e4ULL,
+0x00000030d01f82e4ULL,
+0x00000034801f83e4ULL,
+0x00000035401e04e4ULL,
+0x00000037101f88e4ULL,
+0x00000035401f89e4ULL,
+0x0000003760000044ULL,
+0x0000000000000074ULL,
+0x0000000f0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x0000000000000074ULL,
+0x0000000c000000a4ULL,
+0x0000000004004071ULL,
+0x0000000b0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x0000000000000000ULL,
+0x0000000004000802ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000081000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x000000089000006cULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000091000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x0000000990000064ULL,
+0x000000004a8b0021ULL,
+0x0000000000898611ULL,
+0x0000000c000000a4ULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x0000000a40000064ULL,
+0x0000000088800021ULL,
+0x0000000880800423ULL,
+0x00000000001004a1ULL,
+0x0000000c000000a4ULL,
+0x00000002c88b0061ULL,
+0x0000000a808b0463ULL,
+0x00000000000000c4ULL,
+0x00000000058f0011ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000004d8f0021ULL,
+0x0000000b10000044ULL,
+0x00000007058f0013ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000034c0f0021ULL,
+0x0000000b058f0423ULL,
+0x0000000b70000044ULL,
+0x0000000000180001ULL,
+0x000000000b600031ULL,
+0x00000008000000a4ULL,
+0x0000000004800041ULL,
+0x00000008000000a4ULL,
+0x0000000007c03f41ULL,
+0x00000000440ac491ULL,
+0x00000004000000a4ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c3430431ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000117982861ULL,
+0x0000000088a03631ULL,
+0x00000002c3430c31ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000347cb2861ULL,
+0x000000034c09f691ULL,
+0x00000003040a8491ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000283430431ULL,
+0x000000080000009cULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000104202861ULL,
+0x0000000117d82861ULL,
+0x0000000088a02f31ULL,
+0x00000002c0833c31ULL,
+0x0000002283430c3bULL,
+0x0000000000000000ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x0000000307cb2861ULL,
+0x000000034c09ef91ULL,
+0x000000030409bc91ULL,
+0x00000003040a8491ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000283430531ULL,
+0x0000000a00038007ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000000b8a02b31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c33c31ULL,
+0x0000000004900041ULL,
+0x0000002e83430d3bULL,
+0x0000000200038000ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000001e80830433ULL,
+0x0000000283430431ULL,
+0x0000000b2c03ab67ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000001e80832833ULL,
+0x0000002e83430c3bULL,
+0x000000032c03ab61ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000000140001ULL,
+0x0000004000140001ULL,
+0x000000000b600061ULL,
+0x000000400b600061ULL,
+0x00000004000000a4ULL,
+0x0000000004800041ULL,
+0x0000004004800041ULL,
+0x00000004000000a4ULL,
+0x0000000007c03f41ULL,
+0x0000004007c03f41ULL,
+0x00000000440ac591ULL,
+0x00000040440ac591ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c3430561ULL,
+0x00000042c3430561ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000117f42961ULL,
+0x0000004117f42961ULL,
+0x0000000088e03f61ULL,
+0x0000004088e03f61ULL,
+0x00000002c3430d61ULL,
+0x00000042c3430d61ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000347eb2961ULL,
+0x0000004347eb2961ULL,
+0x000000034c7dff91ULL,
+0x000000434c7dff91ULL,
+0x00000003040a0591ULL,
+0x00000043040a0591ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c0c30561ULL,
+0x00000042c0c30561ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430561ULL,
+0x0000004283430561ULL,
+0x0000000b2c43ab47ULL,
+0x000000432c43ab41ULL,
+0x0000000344602961ULL,
+0x0000004344602961ULL,
+0x0000000317d72961ULL,
+0x0000004317d72961ULL,
+0x00000002b8e3ab61ULL,
+0x00000042b8e3ab61ULL,
+0x00000002c0c32961ULL,
+0x00000042c0c32961ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430d61ULL,
+0x0000007683430d6bULL,
+0x000000032c43ab41ULL,
+0x000000432c43ab41ULL,
+0x00000003446b2961ULL,
+0x00000043446b2961ULL,
+0x0000000307cb2961ULL,
+0x0000004307cb2961ULL,
+0x000000037c7de791ULL,
+0x000000437c7de791ULL,
+0x0000000304499d91ULL,
+0x0000004304499d91ULL,
+0x00000003040a0591ULL,
+0x00000043040a059dULL,
+0x0000000048840011ULL,
+0x00000000028b3691ULL,
+0x000000000e09c691ULL,
+0x000000000c09c691ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000212ab3691ULL,
+0x0000000080800411ULL,
+0x0000000002cb3691ULL,
+0x000000034c29ef91ULL,
+0x0000000006098491ULL,
+0x000000034c09ef91ULL,
+0x0000000004098491ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000210ab3a91ULL,
+0x0000000880800415ULL,
+0x00000006128b3699ULL,
+0x000000034c29eb91ULL,
+0x0000000f0409a893ULL,
+0x0000000026098891ULL,
+0x000000034c09eb91ULL,
+0x0000000f0409a893ULL,
+0x000000000409849dULL,
+0x0000000048841011ULL,
+0x00000000068b7691ULL,
+0x000000000e099611ULL,
+0x000000000c098611ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000216ab7691ULL,
+0x0000000080801411ULL,
+0x0000000006cb3691ULL,
+0x000000034c29af11ULL,
+0x0000000006099411ULL,
+0x000000034c09af11ULL,
+0x0000000004098411ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000214ab7a91ULL,
+0x0000000c80800415ULL,
+0x00000006168b3699ULL,
+0x0000000080801411ULL,
+0x00000002168b3691ULL,
+0x000000034c29ab11ULL,
+0x0000000f0409a813ULL,
+0x0000000026099811ULL,
+0x000000034c09ab11ULL,
+0x0000000f0409a813ULL,
+0x000000000409841dULL,
+0x0000000c000000d4ULL,
+0x0000000000000000ULL,
+0x000000004a801011ULL,
+0x000000000e004691ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000200098001ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000c00800415ULL,
+0x0000000584003699ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000a00098003ULL,
+0x000000000009800dULL,
+0x000000200000302aULL,
+0x00000000000e0012ULL,
+0x0000000000100211ULL,
+0x0000000002000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000ccULL,
+0x0000000006000302ULL,
+0x00000002810b0011ULL,
+0x0000000a808b0013ULL,
+0x0000000002010002ULL,
+0x00000006108b0093ULL,
+0x0000000002800002ULL,
+0x00000007040b0013ULL,
+0x0000000006800002ULL,
+0x00000007040b0013ULL,
+0x0000000003000002ULL,
+0x0000000000090101ULL,
+0x0000000200098001ULL,
+0x0000000a000b0003ULL,
+0x0000000007000302ULL,
+0x0000000400890015ULL,
+0x0000000784098019ULL,
+0x0000000007800002ULL,
+0x0000000000090001ULL,
+0x0000000000098101ULL,
+0x0000001dd000006cULL,
+0x000000280300060aULL,
+0x0000000000000000ULL,
+0x0000000000000e02ULL,
+0x0000000001000011ULL,
+0x00000010000000a4ULL,
+0x0000001dc0000064ULL,
+0x0000000000000f02ULL,
+0x0000000001000011ULL,
+0x0000000002000602ULL,
+0x0000000680890013ULL,
+0x0000000002806002ULL,
+0x0000000004000011ULL,
+0x000000031489f691ULL,
+0x0000000804000415ULL,
+0x000000071489b699ULL,
+0x0000000006000e02ULL,
+0x0000000680890013ULL,
+0x0000000006800e02ULL,
+0x0000000680898013ULL,
+0x0000002c0300540aULL,
+0x0000000007800012ULL,
+0x00000000000b8000ULL,
+0x000000000700cd42ULL,
+0x0000000000800011ULL,
+0x000000029489f691ULL,
+0x0000000800800415ULL,
+0x000000069489b699ULL,
+0x000000200000e02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000001dc0000064ULL,
+0x000000240000c02aULL,
+0x0000000002000012ULL,
+0x0000000600090003ULL,
+0x00000000000000c4ULL,
+0x000000001680409dULL,
+0x0000000014804091ULL,
+0x000000001680049dULL,
+0x0000000014804091ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x000000001680419dULL,
+0x0000000014804191ULL,
+0x000000001680049dULL,
+0x0000000014804191ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x0000000000800011ULL,
+0x00000000068b5691ULL,
+0x0000000004098611ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x0000000296cb569dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000801411ULL,
+0x00000000068b3691ULL,
+0x000000034409af11ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x00000000068b3a91ULL,
+0x000000034409ab11ULL,
+0x000000030409a411ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000001000011ULL,
+0x0000000006098611ULL,
+0x0000000000000000ULL,
+0x0000000007000e02ULL,
+0x0000000000888061ULL,
+0x0000000003000602ULL,
+0x0000000000888061ULL,
+0x00000000000984edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000002800002ULL,
+0x000000500220220aULL,
+0x000000140606550aULL,
+0x000000140606c50aULL,
+0x0000000002a01202ULL,
+0x000000500680100aULL,
+0x000000140286550aULL,
+0x000000000300d502ULL,
+0x000000500220340aULL,
+0x000000140306660aULL,
+0x000000140686c40aULL,
+0x000000140206660aULL,
+0x000000000600dd02ULL,
+0x000000500720550aULL,
+0x0000001806064c0aULL,
+0x000000180306c60aULL,
+0x0000000002001102ULL,
+0x000000500020c50aULL,
+0x000000000600e402ULL,
+0x000000500220440aULL,
+0x000000140606cc0aULL,
+0x000000000320d602ULL,
+0x000000500100e50aULL,
+0x000000180086c60aULL,
+0x00000000000000c4ULL,
+0x0000000002000002ULL,
+0x0000005002a0210aULL,
+0x000000140280540aULL,
+0x0000000003005502ULL,
+0x000000500620200aULL,
+0x000000140680c50aULL,
+0x0000000002004402ULL,
+0x0000005003a0cc0aULL,
+0x0000000002a03702ULL,
+0x000000500700c50aULL,
+0x000000140280650aULL,
+0x000000140280e50aULL,
+0x000000000000c502ULL,
+0x000000500120c70aULL,
+0x000000000200c402ULL,
+0x0000005000a0d50aULL,
+0x0000000000000000ULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000006009202ULL,
+0x000000500220a10aULL,
+0x0000001806064c0aULL,
+0x0000000002808202ULL,
+0x0000005006a0a00aULL,
+0x000000180706d50aULL,
+0x000000000320cc02ULL,
+0x000000500280ee0aULL,
+0x0000000006a0d502ULL,
+0x000000500780a20aULL,
+0x000000140386dd0aULL,
+0x000000000300f602ULL,
+0x0000005002a0e50aULL,
+0x000000180306560aULL,
+0x0000000000000000ULL,
+0x000000180306760aULL,
+0x0000001806866d0aULL,
+0x000000000380f502ULL,
+0x0000005007a0450aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000600dc02ULL,
+0x000000500020e60aULL,
+0x000000180086fc0aULL,
+0x000000140107170aULL,
+0x00000000000000c4ULL,
+0x000000000200a102ULL,
+0x000000500620920aULL,
+0x000000140600c40aULL,
+0x000000000200a002ULL,
+0x0000005006a0820aULL,
+0x000000140680d40aULL,
+0x000000140200dc0aULL,
+0x000000000700a202ULL,
+0x0000005002a0dd0aULL,
+0x000000000300c402ULL,
+0x0000005003a0350aULL,
+0x0000000000000000ULL,
+0x000000140300670aULL,
+0x000000000380d502ULL,
+0x0000005007a0e60aULL,
+0x0000000000000000ULL,
+0x0000001407807f0aULL,
+0x000000000380d102ULL,
+0x000000500320c00aULL,
+0x0000000000000000ULL,
+0x000000140380760aULL,
+0x0000000003007502ULL,
+0x0000005002a0d50aULL,
+0x000000000200f402ULL,
+0x0000005003a0e50aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000000df02ULL,
+0x0000005000a0a60aULL,
+0x000000140101170aULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x000000300281020aULL,
+0x0000003006810a0aULL,
+0x0000003006010c0aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d1000006cULL,
+0x000000200000a02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d5000006cULL,
+0x000000200000c02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002cd0000064ULL,
+0x00000034000000d4ULL,
+0x00000000000000c4ULL,
+0x0000000001000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x000000140001180aULL,
+0x000000140081190aULL,
+0x0000001401011a0aULL,
+0x00000000000000c4ULL,
+0x00000000000000c4ULL,
+0x0000000001810302ULL,
+0x0000005005a10b0aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140206340aULL,
+0x000000180606cb0aULL,
+0x0000000002000402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x0000000002801002ULL,
+0x0000005005a10b0aULL,
+0x000000140286b50aULL,
+0x000000140186300aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140606c50aULL,
+0x0000000002003402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x0000002ff000005cULL,
+0x0000002f4000004cULL,
+0x00000002000b0101ULL,
+0x0000000a000b0003ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ff0000054ULL,
+0x0000000c0000800aULL,
+0x0000002fb000004cULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000003640000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0180430eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x0000000001010002ULL,
+0x00000006108b0093ULL,
+0x0000000005010002ULL,
+0x00000006108b0093ULL,
+0x0000000000000000ULL,
+0x00000032e01f80e4ULL,
+0x00000034401f81e4ULL,
+0x00000034601f82e4ULL,
+0x0000000c0181020aULL,
+0x0000000c0181030aULL,
+0x0000001c000000d4ULL,
+0x0000000000004002ULL,
+0x0000005000a0410aULL,
+0x0000000001004202ULL,
+0x000000500021000aULL,
+0x0000000000810102ULL,
+0x000000500121020aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000000000000002ULL,
+0x0000000600098003ULL,
+0x0000000000810002ULL,
+0x0000000610898093ULL,
+0x0000003760000044ULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000004800102ULL,
+0x00000006808b0013ULL,
+0x0000000005000202ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x000000342000005cULL,
+0x000000334000004cULL,
+0x0000001000000084ULL,
+0x00000006000b0009ULL,
+0x00000002000b0101ULL,
+0x0000002000000084ULL,
+0x00000006000b0009ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x00000034000000d4ULL,
+0x0000003420000054ULL,
+0x00000038000000d4ULL,
+0x00000033e000004cULL,
+0x00000031d0000044ULL,
+0x00000038000000d4ULL,
+0x00000031d0000044ULL,
+0x00000034000000d4ULL,
+0x00000031d0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x0000000005840002ULL,
+0x00000007040b0013ULL,
+0x0000003c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000200000402aULL,
+0x0000000000000012ULL,
+0x00000000000b0001ULL,
+0x0000000000098101ULL,
+0x0000003760000044ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0000400eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036c01f87e4ULL,
+0x00000036401f89e4ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0400480eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036a01f86e4ULL,
+0x000000080180000aULL,
+0x00000036601f84e4ULL,
+0x00000036801f85e4ULL,
+0x000000300001000aULL,
+0x0000003760000044ULL,
+0x000000140006800aULL,
+0x0000003640000044ULL,
+0x000000180006800aULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x0000003640000044ULL,
+0x0000000c0181080aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x0000000c0000400aULL,
+0x0000003640000044ULL,
+0x0000000c0181000aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000140001140aULL,
+0x0000003640000044ULL,
+0x0000000c000000a4ULL,
+0x0000000000000044ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+};
+
+static uint64_t  rsasoc_gen2_ucode_data [] = {
+0x0000000000000000ULL,
+0x00000000503840ecULL,
+0x00000001d03800ecULL,
+0x00000002d03820ecULL,
+0x00000036a0000044ULL,
+0x0000000000000014ULL,
+0x000000063000000cULL,
+0x000000075000010cULL,
+0x0000001760000c0cULL,
+0x00000000f03fc0ecULL,
+0x00000001303fc1ecULL,
+0x00000001603fc2ecULL,
+0x00000001903fc3ecULL,
+0x00000001903fc4ecULL,
+0x00000036a0000044ULL,
+0x00000016f0000c0cULL,
+0x000000001000003cULL,
+0x0000000bd000030cULL,
+0x0000000550000044ULL,
+0x000000001800003cULL,
+0x0000000d0000030cULL,
+0x0000000550000044ULL,
+0x000000003000003cULL,
+0x0000000e7000030cULL,
+0x0000000550000044ULL,
+0x00000000603fc33cULL,
+0x00000000c03fc43cULL,
+0x000000104000030cULL,
+0x0000000550000044ULL,
+0x0000000000000014ULL,
+0x000000063000000cULL,
+0x00000017f000070cULL,
+0x0000001e90000d0cULL,
+0x0000002150000e0cULL,
+0x00000027d0000f0cULL,
+0x00000002903e00ecULL,
+0x00000002903f84ecULL,
+0x00000002b03f85ecULL,
+0x00000002b03f06ecULL,
+0x00000002b03f88ecULL,
+0x00000036a0000044ULL,
+0x00000007e000010cULL,
+0x00000003d0000044ULL,
+0x000000085000010cULL,
+0x0000000490000044ULL,
+0x000000000000001cULL,
+0x00000006b000000cULL,
+0x00000017f000070cULL,
+0x0000002020000d0cULL,
+0x0000002360000e0cULL,
+0x0000002880000f0cULL,
+0x00000003903e20ecULL,
+0x00000003903fa4ecULL,
+0x00000003b03fa5ecULL,
+0x00000003b03f26ecULL,
+0x00000003b03fa8ecULL,
+0x00000036a0000044ULL,
+0x00000008e000010cULL,
+0x00000003d0000044ULL,
+0x000000098000010cULL,
+0x0000000490000044ULL,
+0x000000000800003cULL,
+0x0000000a7000020cULL,
+0x0000000b4000030cULL,
+0x000000121000040cULL,
+0x00000014c000050cULL,
+0x00000015b000060cULL,
+0x0000001bd000080cULL,
+0x0000001c0000090cULL,
+0x0000001d40000a0cULL,
+0x0000001c30000b0cULL,
+0x00000016a0000c0cULL,
+0x00000005a0000044ULL,
+0x000000001000003cULL,
+0x0000000ad000020cULL,
+0x0000000bd000030cULL,
+0x00000012f000040cULL,
+0x000000152000050cULL,
+0x000000161000060cULL,
+0x0000001be000080cULL,
+0x0000001c1000090cULL,
+0x0000001dc0000a0cULL,
+0x0000001c90000b0cULL,
+0x00000016f0000c0cULL,
+0x00000005a0000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x00000029401f80e4ULL,
+0x0000002f101f81e4ULL,
+0x00000036a0000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x0000002ff01f00e4ULL,
+0x0000002ff01f82e4ULL,
+0x00000033a01f83e4ULL,
+0x00000034601e04e4ULL,
+0x00000036501f88e4ULL,
+0x00000034601f89e4ULL,
+0x00000036a0000044ULL,
+0x0000000000000074ULL,
+0x000000320000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x000000220000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x0000000000000074ULL,
+0x0000000c000000a4ULL,
+0x0000000004004071ULL,
+0x0000002e0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x000000220000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000004000802ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000079000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x000000081000006cULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000089000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x0000000910000064ULL,
+0x000000004a8b0021ULL,
+0x0000000000898611ULL,
+0x0000000c000000a4ULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x00000009c0000064ULL,
+0x0000000088800021ULL,
+0x0000000880800423ULL,
+0x00000000001004a1ULL,
+0x0000000c000000a4ULL,
+0x00000002c88b0061ULL,
+0x0000000a808b0463ULL,
+0x00000000000000c4ULL,
+0x00000000058f0011ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000004d8f0021ULL,
+0x0000000a90000044ULL,
+0x00000007058f0013ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000034c0f0021ULL,
+0x0000000b058f0423ULL,
+0x0000000af0000044ULL,
+0x0000000000180001ULL,
+0x000000000b600031ULL,
+0x00000008000000a4ULL,
+0x0000000004800041ULL,
+0x00000008000000a4ULL,
+0x0000000007c03f41ULL,
+0x00000000440ac491ULL,
+0x00000004000000a4ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c3430431ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000117982861ULL,
+0x0000000088a03631ULL,
+0x00000002c3430c31ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000347cb2861ULL,
+0x000000034c09f691ULL,
+0x00000003040a8491ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000283430431ULL,
+0x000000080000009cULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000104202861ULL,
+0x0000000117d82861ULL,
+0x0000000088a02f31ULL,
+0x00000002c0833c31ULL,
+0x0000002283430c3bULL,
+0x0000000000000000ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x0000000307cb2861ULL,
+0x000000034c09ef91ULL,
+0x000000030409bc91ULL,
+0x00000003040a8491ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000000283430431ULL,
+0x0000000a00038007ULL,
+0x000000012c002b41ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000002e83430c3bULL,
+0x0000000200038000ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000001e80830433ULL,
+0x0000000283430431ULL,
+0x0000000b2c03ab67ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000001e80832833ULL,
+0x0000002e83430c3bULL,
+0x000000032c03ab61ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000000140001ULL,
+0x0000004000140001ULL,
+0x000000000b600061ULL,
+0x000000400b600061ULL,
+0x00000004000000a4ULL,
+0x0000000004800041ULL,
+0x0000004004800041ULL,
+0x00000004000000a4ULL,
+0x0000000007c03f41ULL,
+0x0000004007c03f41ULL,
+0x00000000440ac591ULL,
+0x00000040440ac591ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c3430561ULL,
+0x00000042c3430561ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000117f42961ULL,
+0x0000004117f42961ULL,
+0x0000000088e03f61ULL,
+0x0000004088e03f61ULL,
+0x00000002c3430d61ULL,
+0x00000042c3430d61ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000347eb2961ULL,
+0x0000004347eb2961ULL,
+0x000000034c7dff91ULL,
+0x000000434c7dff91ULL,
+0x00000003040a0591ULL,
+0x00000043040a0591ULL,
+0x00000000000000c4ULL,
+0x0000000048840011ULL,
+0x00000000028b3691ULL,
+0x000000000e09c691ULL,
+0x000000000c09c691ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000212ab3691ULL,
+0x0000000080800411ULL,
+0x0000000002cb3691ULL,
+0x000000034c29ef91ULL,
+0x0000000006098491ULL,
+0x000000034c09ef91ULL,
+0x0000000004098491ULL,
+0x00000000000000c4ULL,
+0x0000000048841011ULL,
+0x00000000068b7691ULL,
+0x000000000e099611ULL,
+0x000000000c098611ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000216ab7691ULL,
+0x0000000080801411ULL,
+0x0000000006cb3691ULL,
+0x000000034c29af11ULL,
+0x0000000006099411ULL,
+0x000000034c09af11ULL,
+0x0000000004098411ULL,
+0x00000000000000c4ULL,
+0x0000000c000000d4ULL,
+0x0000000000000000ULL,
+0x000000004a801011ULL,
+0x000000000e004691ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000200098001ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000c00800415ULL,
+0x0000000584003699ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000a00098003ULL,
+0x000000000009800dULL,
+0x000000200000302aULL,
+0x00000000000e0012ULL,
+0x0000000000100211ULL,
+0x0000000002000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000ccULL,
+0x0000000006000302ULL,
+0x00000002810b0011ULL,
+0x0000000a808b0013ULL,
+0x0000000002010002ULL,
+0x00000006108b0093ULL,
+0x0000000002800002ULL,
+0x00000007040b0013ULL,
+0x0000000006800002ULL,
+0x00000007040b0013ULL,
+0x0000000003000002ULL,
+0x0000000000090101ULL,
+0x0000000200098001ULL,
+0x0000000a000b0003ULL,
+0x0000000007000302ULL,
+0x0000000400890015ULL,
+0x0000000784098019ULL,
+0x0000000007800002ULL,
+0x0000000000090001ULL,
+0x0000000000098101ULL,
+0x00000019b000006cULL,
+0x000000280300060aULL,
+0x0000000000000000ULL,
+0x0000000000000e02ULL,
+0x0000000001000011ULL,
+0x00000010000000a4ULL,
+0x00000019a0000064ULL,
+0x0000000000000f02ULL,
+0x0000000001000011ULL,
+0x0000000002000602ULL,
+0x0000000680890013ULL,
+0x0000000002806002ULL,
+0x0000000004000011ULL,
+0x000000031489f691ULL,
+0x0000000804000415ULL,
+0x000000071489b699ULL,
+0x0000000006000e02ULL,
+0x0000000680890013ULL,
+0x0000000006800e02ULL,
+0x0000000680898013ULL,
+0x0000002c0300540aULL,
+0x0000000007800012ULL,
+0x00000000000b8000ULL,
+0x000000000700cd42ULL,
+0x0000000000800011ULL,
+0x000000029489f691ULL,
+0x0000000800800415ULL,
+0x000000069489b699ULL,
+0x000000200000e02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x00000019a0000064ULL,
+0x000000240000c02aULL,
+0x0000000002000012ULL,
+0x0000000600090003ULL,
+0x00000000000000c4ULL,
+0x000000001680409dULL,
+0x0000000014804091ULL,
+0x000000001680049dULL,
+0x000000001680419dULL,
+0x0000000014804191ULL,
+0x000000001680049dULL,
+0x0000000000800011ULL,
+0x00000000068b5691ULL,
+0x0000000004098611ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x0000000296cb569dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000801411ULL,
+0x00000000068b3691ULL,
+0x000000034409af11ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000001000011ULL,
+0x0000000006098611ULL,
+0x0000000000000000ULL,
+0x0000000007000e02ULL,
+0x0000000000888061ULL,
+0x0000000003000602ULL,
+0x0000000000888061ULL,
+0x00000000000984edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000002800002ULL,
+0x000000500220220aULL,
+0x000000140606550aULL,
+0x000000140606c50aULL,
+0x0000000002a01202ULL,
+0x000000500680100aULL,
+0x000000140286550aULL,
+0x000000000300d502ULL,
+0x000000500220340aULL,
+0x000000140306660aULL,
+0x000000140686c40aULL,
+0x000000140206660aULL,
+0x000000000600dd02ULL,
+0x000000500720550aULL,
+0x0000001806064c0aULL,
+0x000000180306c60aULL,
+0x0000000002001102ULL,
+0x000000500020c50aULL,
+0x000000000600e402ULL,
+0x000000500220440aULL,
+0x000000140606cc0aULL,
+0x000000000320d602ULL,
+0x000000500100e50aULL,
+0x000000180086c60aULL,
+0x00000000000000c4ULL,
+0x0000000002000002ULL,
+0x0000005002a0210aULL,
+0x000000140280540aULL,
+0x0000000003005502ULL,
+0x000000500620200aULL,
+0x000000140680c50aULL,
+0x0000000002004402ULL,
+0x0000005003a0cc0aULL,
+0x0000000002a03702ULL,
+0x000000500700c50aULL,
+0x000000140280650aULL,
+0x000000140280e50aULL,
+0x000000000000c502ULL,
+0x000000500120c70aULL,
+0x000000000200c402ULL,
+0x0000005000a0d50aULL,
+0x0000000000000000ULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000006009202ULL,
+0x000000500220a10aULL,
+0x0000001806064c0aULL,
+0x0000000002808202ULL,
+0x0000005006a0a00aULL,
+0x000000180706d50aULL,
+0x000000000320cc02ULL,
+0x000000500280ee0aULL,
+0x0000000006a0d502ULL,
+0x000000500780a20aULL,
+0x000000140386dd0aULL,
+0x000000000300f602ULL,
+0x0000005002a0e50aULL,
+0x000000180306560aULL,
+0x0000000000000000ULL,
+0x000000180306760aULL,
+0x0000001806866d0aULL,
+0x000000000280f502ULL,
+0x0000005007a0450aULL,
+0x0000000000000000ULL,
+0x0000000003810502ULL,
+0x00000006808b0013ULL,
+0x000000300281050aULL,
+0x00000008000000a4ULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x00000025d000006cULL,
+0x000000000600dc02ULL,
+0x000000500020e60aULL,
+0x000000180086fc0aULL,
+0x000000140107170aULL,
+0x00000000000000c4ULL,
+0x000000000200a102ULL,
+0x000000500620920aULL,
+0x000000140600c40aULL,
+0x000000000200a002ULL,
+0x0000005006a0820aULL,
+0x000000140680d40aULL,
+0x000000140200dc0aULL,
+0x000000000700a202ULL,
+0x0000005002a0dd0aULL,
+0x000000000300c402ULL,
+0x0000005003a0350aULL,
+0x0000000000000000ULL,
+0x000000140300670aULL,
+0x000000000380d502ULL,
+0x0000005007a0e60aULL,
+0x0000000000000000ULL,
+0x0000001407807f0aULL,
+0x000000000380d102ULL,
+0x000000500320c00aULL,
+0x0000000000000000ULL,
+0x000000140380760aULL,
+0x0000000003007502ULL,
+0x0000005002a0d50aULL,
+0x000000000200f402ULL,
+0x0000005002a0e50aULL,
+0x0000000000000000ULL,
+0x0000000003810502ULL,
+0x00000006808b0013ULL,
+0x000000300281050aULL,
+0x00000008000000a4ULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x00000025d000006cULL,
+0x000000000000df02ULL,
+0x0000005000a0a60aULL,
+0x000000140101170aULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000002810202ULL,
+0x00000006808b0013ULL,
+0x0000000000000000ULL,
+0x000000300281050aULL,
+0x0000000006810a02ULL,
+0x00000006808b0013ULL,
+0x0000000000000000ULL,
+0x0000003006810d0aULL,
+0x0000003006010c0aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x000000278000006cULL,
+0x000000200000d02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x00000027c000006cULL,
+0x000000200000c02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002740000064ULL,
+0x00000034000000d4ULL,
+0x00000000000000c4ULL,
+0x0000000001000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x000000140001180aULL,
+0x000000140081190aULL,
+0x0000001401011a0aULL,
+0x00000000000000c4ULL,
+0x00000000000000c4ULL,
+0x0000000001810302ULL,
+0x0000005005a10b0aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140206340aULL,
+0x000000180606cb0aULL,
+0x0000000002000402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x0000000002801002ULL,
+0x0000005005a10b0aULL,
+0x000000140286b50aULL,
+0x000000140186300aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140606c50aULL,
+0x0000000002003402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x00000008000000a4ULL,
+0x0000000040000002ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400000aULL,
+0x0000000c0400880aULL,
+0x0000000c0400880aULL,
+0x00000008000000a4ULL,
+0x0000000000000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000008000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000010000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000018000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000020000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000028000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000030000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000c0400800aULL,
+0x00000008000000a4ULL,
+0x0000000038000802ULL,
+0x0000000000400024ULL,
+0x0000000000400034ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x0000002ce000005cULL,
+0x0000002c7000004cULL,
+0x00000002000b0101ULL,
+0x0000000a000b0003ULL,
+0x00000036a0000044ULL,
+0x0000002e50400444ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ce0000054ULL,
+0x0000000c0000000aULL,
+0x0000000c0000000aULL,
+0x0000000c0000000aULL,
+0x000000000040000cULL,
+0x0000000000000034ULL,
+0x0000000000000000ULL,
+0x000000000040041cULL,
+0x0000000000000034ULL,
+0x0000000000000000ULL,
+0x000000000040021cULL,
+0x0000000000000034ULL,
+0x0000000000000000ULL,
+0x000000000040011cULL,
+0x00000008000000a4ULL,
+0x000000007c000002ULL,
+0x000000000040002cULL,
+0x000000000040003cULL,
+0x0000000c0000800aULL,
+0x0000002ce0000044ULL,
+0x00000008000000a4ULL,
+0x0000000044000002ULL,
+0x000000000040002cULL,
+0x000000000040003cULL,
+0x0000002ee0000044ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ee0000054ULL,
+0x0000000c0000800aULL,
+0x0000002ea000004cULL,
+0x00000035801800f4ULL,
+0x0000003560000044ULL,
+0x0000000c0000800aULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x00000035801800f4ULL,
+0x0000003560000044ULL,
+0x00000036a0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0180430eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x0000000001010002ULL,
+0x00000006108b0093ULL,
+0x0000000005010002ULL,
+0x00000006108b0093ULL,
+0x0000000000000000ULL,
+0x00000032001f80e4ULL,
+0x00000033601f81e4ULL,
+0x00000033801f82e4ULL,
+0x0000000c0181020aULL,
+0x0000000c0181030aULL,
+0x0000001c000000d4ULL,
+0x0000000001004252ULL,
+0x0000005000a0410aULL,
+0x0000000000004002ULL,
+0x000000500121020aULL,
+0x000000300021000aULL,
+0x000000300081010aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000000000000002ULL,
+0x0000000600098003ULL,
+0x0000000000810002ULL,
+0x0000000610898093ULL,
+0x00000036a0000044ULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000004800102ULL,
+0x00000006808b0013ULL,
+0x0000000005000202ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x000000334000005cULL,
+0x000000326000004cULL,
+0x0000000800000084ULL,
+0x00000006000b0009ULL,
+0x00000002000b0101ULL,
+0x0000001000000084ULL,
+0x00000006000b0009ULL,
+0x00000036a0000044ULL,
+0x0000000000000034ULL,
+0x00000034000000d4ULL,
+0x0000003340000054ULL,
+0x00000038000000d4ULL,
+0x000000330000004cULL,
+0x00000030f0000044ULL,
+0x00000038000000d4ULL,
+0x00000030f0000044ULL,
+0x00000034000000d4ULL,
+0x00000030f0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x0000000005840052ULL,
+0x00000007040b0013ULL,
+0x0000003c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000200000402aULL,
+0x0000000000000012ULL,
+0x00000000000b0001ULL,
+0x0000000000098101ULL,
+0x00000036a0000044ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0000400eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036001f87e4ULL,
+0x00000035801f89e4ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0400480eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000035e01f86e4ULL,
+0x000000080180000aULL,
+0x00000035a01f84e4ULL,
+0x00000035c01f85e4ULL,
+0x000000300001000aULL,
+0x00000036a0000044ULL,
+0x000000300001005aULL,
+0x00000036a0000044ULL,
+0x000000140006805aULL,
+0x0000003560000044ULL,
+0x000000180006805aULL,
+0x0000003560000044ULL,
+0x0000000c0000805aULL,
+0x0000003560000044ULL,
+0x0000000c0181080aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x0000000c0000405aULL,
+0x0000003560000044ULL,
+0x0000000c0181000aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000140001145aULL,
+0x0000003560000044ULL,
+0x0000000c000000a4ULL,
+0x0000000000000044ULL,
+};
+
+#endif				/**/
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
new file mode 100644
index 0000000..5b4ce21
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/saesoc_defs.h
@@ -0,0 +1,394 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _SAESOC_DEFS_H
+#define _SAESOC_DEFS_H
+
+/**
+* defines saesoc_feature_flags - Feature definitions
+* @SAESOC_FF_RABIN_SUPPORT: Rabin finger print support exist or not.
+* @SAESOC_FF_CHKTAG_SUPPORT: SAE engine gives back the result(matching or
+* 	 non-matching) after comparing the authentication result with the 
+* 	 ICV value present in the packet. If it is supported then the 
+* 	 application can use the chk_tag api to know the result. 
+* 	 Otherwise the application should do the memcmp by itself.
+* @SAESOC_FF_TAG_LOC_EOP_SUPPORT: Application can specify the tag output/input 
+* 	is at end of payload. If it is not supported then the application should 
+* 	copy the tag result from the tag-out pointer to the end of payload
+* @SAESOC_FF_TAGIN_OFF_SUPPORT: Application can specify the location where the 
+* 	tag is present in the packet. If it is not supported the taginoffset 
+* 	parameter in the session_init is ignored .
+* @SAESOC_FF_TRUNC_TAG_SUPPORT : Truncated Tag support
+* 	If it is supported then the application needs to allocate the tag output 
+* 	memory to the truncated length only.  Otherwise the tag-out memory should 
+* 	have sufficient memory to copy the entire tag output as per the standard, 
+* 	and application should truncate the result and copy the required size to 
+* 	the packet.
+* @SAESOC_FF_EXPLICIT_IV_SUPPORT: This option allows to specify the IV as part 
+* 	of the packet descriptor. Used in GCM/CCM case where the actual IV is not 
+* 	part of the packet. If it is supported, application can call the 
+* 	set_explicit_iv api to copy the iv in to the packet descriptor. 
+* 	Otherwise the iv should be copied to memory and give to the engine as a 
+* 	new fragment.
+* @SAESOC_FF_HASHMUTE_SUPPORT: This option allows muting some section of the 
+* 	packet while authenticating the packet. Used mainly in the AH 
+* 	implementation for IPSEC. If it is supported, application can set the 
+* 	mute mask by using the api set_mute_mask  and refer the index while 
+* 	creating the session.  Otherwise the application should copy the mutable 
+* 	fields in to some local memory or unused part of the packet descriptor 
+* 	and copy it back to the packet after getting the response from the engine
+*
+* @SAESOC_FF_NAAD_SUPPORT: Support for unused bytes b/w the AAD and Payload.
+* 	In Eagle, there cannot be any gap b/w the hash_offset (aad_offset)  and 
+* 	cipheroffset (payloadoffset).  So if there is a gap b/w this field, 
+* 	it should be given as 2 fragments; one for the AAD and the other for the 
+* 	Payload. 
+* 	When to create extra fragments in Eagle - For example in AES-GCM-ESP, 
+* 	8 bytes iv present in the packet should not be part of the ICV calculation. 
+* 	So in Eagle this can be achieved by creating 2 fragments from the packet
+*
+* @SAESOC_FF_SRC_DST_FRAG_STRICT_ORDER: In griffin the strict ordering is 
+* 	not maintained. The number of src fragment need not be equal to number of
+* 	destination fragment or vice versa. Also there can be multiple source 
+* 	fragments (upto 16) before a destination fragment. 
+* 	But in Eagle, the number of source fragment should be equal to number of 
+* 	destination fragment. Application should take care of this when the same 
+* 	app is intended to work on both Eagle and Griffin
+*
+* @SAESOC_FF_CIPHER_PAD_SUPPORT: Support for cipher padding. 
+* 	In griffin, engine can do the cipher padding. But in XLP, cipher padding 
+* 	should be done by the application.
+*
+* @SAESOC_FF_CIPHER_ZUC_SUPPORT: Zuc support is exist or not.
+* @SAESOC_FF_HASH_RABIN_SUPPORT: Rabin hash support exist or not
+* @SAESOC_FF_DIS_WR_FRAG_SUPPORT: Disable the fragment write 
+* @SAESOC_FF_3DES_KEY_SWAP_SUPPORT: 2xx and  griffin supports ZUC
+*/
+
+/*!defines saesoc_feature_flags < */
+#define SAESOC_FF_RABIN_SUPPORT 0x01
+#define SAESOC_FF_CHKTAG_SUPPORT 0x02
+#define SAESOC_FF_TAG_LOC_EOP_SUPPORT 0x4
+#define SAESOC_FF_TAGIN_OFF_SUPPORT 0x8
+#define SAESOC_FF_TRUNC_TAG_SUPPORT 0x10
+#define SAESOC_FF_EXPLICIT_IV_SUPPORT 0x20
+#define SAESOC_FF_HASHMUTE_SUPPORT	0x40
+#define SAESOC_FF_NAAD_SUPPORT		0x80
+#define SAESOC_FF_SRC_DST_FRAG_STRICT_ORDER 0x100
+#define SAESOC_FF_CIPHER_PAD_SUPPORT 0x200
+#define SAESOC_FF_CIPHER_ZUC_SUPPORT 0x400
+#define SAESOC_FF_HASH_RABIN_SUPPORT 0x800
+#define SAESOC_FF_DIS_WR_FRAG_SUPPORT 0x1000
+#define SAESOC_FF_3DES_KEY_SWAP_SUPPORT 0x2000
+/*!defines saesoc_feature_flags > */
+
+/* for generation 1 like eagle, storm, the below 1 is a must */
+#define SAESOC_FF_GEN1_PTYPE (SAESOC_FF_SRC_DST_FRAG_STRICT_ORDER)
+
+/* for generation 2 like griffin, everything is supported */
+#define SAESOC_FF_GEN2_PTYPE (SAESOC_FF_RABIN_SUPPORT | \
+		SAESOC_FF_CHKTAG_SUPPORT | \
+	   	SAESOC_FF_TAG_LOC_EOP_SUPPORT | SAESOC_FF_TAGIN_OFF_SUPPORT | \
+		SAESOC_FF_TRUNC_TAG_SUPPORT | SAESOC_FF_EXPLICIT_IV_SUPPORT | \
+		SAESOC_FF_HASHMUTE_SUPPORT | SAESOC_FF_NAAD_SUPPORT | \
+		SAESOC_FF_DIS_WR_FRAG_SUPPORT)
+
+/**
+* defines per_pkt_update_flags : Per packet modifiable parameters. These are the apis which differs 
+* in its setting depending on the processor type.  The application should 
+* check the per_pkt_update_set bits and decide the action accordingly. 
+* For example, iv_offset can be modified on every packet in Eagle, but in 
+* Griffin it is a session parameter.  
+*
+* If there is a requirement in Griffin to modify the iv_offset for a 
+* particular packet in a session, the application should copy the session 
+* descriptor and use that session descriptor for that particular operation. 
+* Because the iv_offset_set api will modify the session descriptor instead 
+* of the data descriptor in Griffin case
+*
+* @SAESOC_PER_PKT_UF_AADOFF_SUPPORT: Aad offset is part of the packet 
+* 	descriptor or not
+* @SAESOC_PER_PKT_UF_IVOFF_SUPPORT: IV offset is part of the packet descriptor
+* 	or not
+* @SAESOC_PER_PKT_UF_PYLDOFF_SUPPORT: Payload offset is part of the packet 
+* 	descriptor or not
+*/
+
+/*!defines per_pkt_update_flags < */
+#define SAESOC_PER_PKT_UF_AADOFF_SUPPORT 0x01
+#define SAESOC_PER_PKT_UF_IVOFF_SUPPORT 0x2
+#define SAESOC_PER_PKT_UF_PYLDOFF_SUPPORT 0x4
+/*!defines per_pkt_update_flags > */
+
+#define SAESOC_PER_PKT_UF_GEN1_PTYPE (SAESOC_PER_PKT_UF_AADOFF_SUPPORT | \
+		SAESOC_PER_PKT_UF_IVOFF_SUPPORT | SAESOC_PER_PKT_UF_PYLDOFF_SUPPORT)
+
+
+
+/**
+* enum saesoc_iv_mode - Cipher & Hash IV mode values
+*
+* @SAESOC_IV_FROM_PKT_SRC: IV value is taken from the packet source
+* @SAESOC_IV_FROM_PKT_DESC: IV value is taken from the packet descriptor
+* 					Valid only if PKT_DESC in the feature flag is set
+*/
+enum saesoc_iv_mode {
+	SAESOC_IV_FROM_PKT_SRC = 0,
+	SAESOC_IV_FROM_PKT_DESC = 1
+};
+
+/** 
+ * enum saesoc_ddesc_reset_op - Possible types to reset the data descriptor
+ *
+ * @SAESOC_DDESC_RESET_ALL_FRAGS: Reset all the frags. Keep IV and other 
+ * 		msg informations.
+ * @SAESOC_DDESC_RESET_FRAGIDX: Reset till the given fragments.
+ */
+
+enum saesoc_ddesc_reset_op {
+	SAESOC_DDESC_RESET_ALL_FRAGS = 1,
+	SAESOC_DDESC_RESET_FRAGIDX
+};
+	
+/**
+* defines sess_init_flags : Session initialization flags 
+*
+* @SAESOC_IF_RFP_OUT_ON: Enable Rabin finger print output along with 
+*  	chunk size and hash output. 
+*  	Valid only if RABIN in the feature flags is set 
+* @SAESOC_IF_TLS_ON: Generate tag & encrypt. Used in SSL/TLS mode.
+* @SAESOC_IF_DATA_OUT_L3_ALLOC:	Alloc l3 cache for while writing the op result
+* @SAESOC_IF_DATA_OUT_CLOBBER: 	No read-modify-write while writing the op result
+* @SAESOC_IF_DATA_WR_MOD_ONLY_EN: Write only the modified data while writing 
+* 	the op result. Ignored if the processor does not support this feature.
+*
+*/
+/*!defines sess_init_flags < */
+#define SAESOC_IF_RFP_OUT_ON	0x1   
+#define SAESOC_IF_TLS_ON 		0x4
+#define SAESOC_IF_DATA_OUT_L3_ALLOC 0x8
+#define SAESOC_IF_DATA_OUT_CLOBBER  0x10
+#define SAESOC_IF_DATA_WR_MOD_ONLY_EN 0x20
+/*!defines sess_init_flags > */
+
+/**
+* defines ciph_init_flags - Cipher initialization flags
+* @SAESOC_CF_ENCRYPT: 	Session is for encryption.
+* @SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC: Alloc l3 cache while writing the 
+* 	arc4 state. Ignored if the processor does not support this feature
+* @SAESOC_CF_CIPHER_PAD_ON: Cipher padding is enabled
+*	Valid only if CIPHER_PAD in the feature flag is set
+* @SAESOC_CF_ARC4_KEY_INIT: Arc4 key is initted for the first time, for the next
+*	from next time init key has to be reseted to 0.
+* @SAESOC_CF_DES3_KEYSWAP_DONE: DES3 key swap is already done by the application
+*/
+
+/*!defines ciph_init_flags < */
+#define	SAESOC_CF_ENCRYPT 	0x1
+#define SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC 0x2
+#define SAESOC_CF_CIPHER_PAD_ON	 0x4
+#define SAESOC_CF_ARC4_KEY_INIT 0x8
+#define SAESOC_CF_DES3_KEYSWAP_DONE 0x10
+/*!defines ciph_init_flags > */
+
+/**
+* defines hash_init_flags - Hash initialization flags
+* @SAESOC_HF_HASHINP_IS_CIPHEROUT: Cipher output is given to hash input 
+* @SAESOC_HF_CHKTAG_ON: Engine compares the tag result with the tag value 
+* 	present in the packet. Valid only if CHK_TAG in the feature flag is set 
+* @SAESOC_HF_TAGIN_EOP: Specify that the tag input is at the End of packet.
+*	Valid only if TAG_LOC_EOP in the feature flag is set 
+* @SAESOC_HF_TAGOUT_EOP: Specify that copy the tag output to end of packet.
+* 							Valid only if TAG_LOC_EOP in the feature flag is set 
+* @SAESOC_HF_HMAC_KEY_PAD_EN: Hmac key padding will be done by the engine.
+* @SAESOC_HF_HASH_L3_ALLOC: Alloc l3 cache while writing the tag output
+* @SAESOC_HF_HASH_CLOBBER: No read-modify-write while writing the tag output
+* @SAESOC_HF_HASH_MUTE_MASK_EN: Enable hash mutable option
+* 	Valid only if HASH_MUTE in the feature flag is set
+*
+*/
+
+/*!defines hash_init_flags < */
+#define SAESOC_HF_HASHINP_IS_CIPHEROUT 0x01
+#define SAESOC_HF_CHKTAG_ON 		0x02		
+#define SAESOC_HF_TAGIN_EOP 	0x04
+#define SAESOC_HF_TAGOUT_EOP	0x08
+#define SAESOC_HF_HMAC_KEY_PAD_EN	0x10
+#define SAESOC_HF_HASH_L3_ALLOC		0x20
+#define SAESOC_HF_HASH_CLOBBER		0x40
+#define SAESOC_HF_HASH_MUTE_MASK_EN		0x80
+/*!defines hash_init_flags > */
+
+/**
+* enum saesoc_cipher_type - Supported cipher types
+* @SAESOC_CIPHER_TYPE_AES_128: Cipher type is AES 128
+* @SAESOC_CIPHER_TYPE_AES_192: Cipher type is AES 192
+* @SAESOC_CIPHER_TYPE_AES_256: Cipher type is AES 256
+* @SAESOC_CIPHER_TYPE_CAMELLIA_128: Cipher type is Camellia 128
+* @SAESOC_CIPHER_TYPE_CAMELLIA_192: Cipher type is Camellia 192
+* @SAESOC_CIPHER_TYPE_CAMELLIA_256: Cipher type is Camellia 256
+* @SAESOC_CIPHER_BYPASS: No Cipher operation
+* @SAESOC_CIPHER_TYPE_KASUMI: Cipher type is Kasumi
+* @SAESOC_CIPHER_TYPE_SNOW3G: Cipher type is Snow3G
+* @SAESOC_CIPHER_TYPE_ZUC: Cipher type is ZUC
+* @SAESOC_CIPHER_TYPE_DES: Cipher type is DES
+* @SAESOC_CIPHER_TYPE_TDES: Cipher type is TDES
+* @SAESOC_CIPHER_TYPE_ARC4: Cipher type is ARC4
+* @SAESOC_CIPHER_TYPE_MAX: End of cipher type
+*/
+
+enum saesoc_cipher_type {
+	SAESOC_CIPHER_TYPE_AES_128 = 0x00,
+	SAESOC_CIPHER_TYPE_AES_192 = 0x01,
+	SAESOC_CIPHER_TYPE_AES_256 = 0x02,
+	SAESOC_CIPHER_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_CIPHER_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_CIPHER_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_CIPHER_BYPASS = 0x08,
+	SAESOC_CIPHER_TYPE_KASUMI = 0x09,
+	SAESOC_CIPHER_TYPE_SNOW3G = 0x0a,
+	SAESOC_CIPHER_TYPE_ZUC = 0x0b,
+	SAESOC_CIPHER_TYPE_DES = 0x0c,
+	SAESOC_CIPHER_TYPE_TDES = 0x0d,
+	SAESOC_CIPHER_TYPE_ARC4 = 0x0e,
+	SAESOC_CIPHER_TYPE_MAX
+};
+
+/*
+* enum saesoc_cipher_modes - Supported cipher modes
+* @SAESOC_CIPHER_MODE_ECB: Cipher mode is ECB
+* @SAESOC_CIPHER_MODE_CBC: Cipher mode is CBC
+* @SAESOC_CIPHER_MODE_CFB: Cipher mode is CFB
+* @SAESOC_CIPHER_MODE_OFB: Cipher mode is OFB
+* @SAESOC_CIPHER_MODE_CTR: Cipher mode is Counter
+* @SAESOC_CIPHER_MODE_AES_F8: Cipher mode is AES F8
+* @SAESOC_CIPHER_MODE_LRW: Cipher mode is LRW
+* @SAESOC_CIPHER_MODE_XTS: Cipher mode is XTS
+* @SAESOC_CIPHER_MODE_CCM: Cipher mode is CCM
+* @SAESOC_CIPHER_MODE_GCM: Cipher mode is GCM
+* @SAESOC_CIPHER_MODE_MAX: End of cipher mode
+*/
+
+enum saesoc_cipher_mode {
+	SAESOC_CIPHER_MODE_ECB = 0x00,
+	SAESOC_CIPHER_MODE_CBC = 0x01,
+	SAESOC_CIPHER_MODE_CFB = 0x02,
+	SAESOC_CIPHER_MODE_OFB = 0x03,
+	SAESOC_CIPHER_MODE_CTR = 0x04,
+	SAESOC_CIPHER_MODE_AES_F8 = 0x05,
+	SAESOC_CIPHER_MODE_LRW = 0x06,
+	SAESOC_CIPHER_MODE_XTS = 0x07,
+	SAESOC_CIPHER_MODE_CCM = 0x08,
+	SAESOC_CIPHER_MODE_GCM = 0x09,
+	SAESOC_CIPHER_MODE_MAX
+};
+
+
+/*
+* enum saesoc_hash_type - Supported hash types
+*
+* @SAESOC_HASH_TYPE_AES_128: Hash type is AES 128
+* @SAESOC_HASH_TYPE_AES_192: Hash type is AES 192
+* @SAESOC_HASH_TYPE_AES_256: Hash type is AES 256
+* @SAESOC_HASH_TYPE_CAMELLIA_128: Hash type is Camellia 128
+* @SAESOC_HASH_TYPE_CAMELLIA_192: Hash type is Camellia 192
+* @SAESOC_HASH_TYPE_CAMELLIA_256: Hash type is Camellia 256
+* @SAESOC_HASH_BYPASS: No hash operation
+* @SAESOC_HASH_TYPE_KASUMI: Hash type is Kasumi
+* @SAESOC_HASH_TYPE_SNOW3G: Hash type is Snow3G
+* @SAESOC_HASH_TYPE_ZUC: Hash type is ZUC
+* @SAESOC_HASH_TYPE_RABIN: Hash type is RABIN
+* @SAESOC_HASH_TYPE_GHASH: Hash type is GHASH
+* @SAESOC_HASH_TYPE_MD5: Hash type is MD5
+* @SAESOC_HASH_TYPE_SHA_1: Hash type is SHA-1
+* @SAESOC_HASH_TYPE_SHA_224: Hash type is SHA-224
+* @SAESOC_HASH_TYPE_SHA_256: Hash type is SHA-256
+* @SAESOC_HASH_TYPE_SHA_384: Hash type is SHA-384
+* @SAESOC_HASH_TYPE_SHA_512: Hash type is SHA-512
+* @SAESOC_HASH_TYPE_SHA_512_224: Hash type is SHA-512/224
+* @SAESOC_HASH_TYPE_SHA_512_256: Hash type is SHAR-512/256
+* @SAESOC_HASH_TYPE_MAX : End of Hash type 
+*/
+
+enum saesoc_hash_type {
+	SAESOC_HASH_TYPE_AES_128 = 0x00,
+	SAESOC_HASH_TYPE_AES_192 = 0x01,
+	SAESOC_HASH_TYPE_AES_256 = 0x02,
+	SAESOC_HASH_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_HASH_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_HASH_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_HASH_BYPASS = 0x08,
+	SAESOC_HASH_TYPE_KASUMI = 0x09,
+	SAESOC_HASH_TYPE_SNOW3G = 0x0a,
+	SAESOC_HASH_TYPE_ZUC = 0x0b,
+	SAESOC_HASH_TYPE_RABIN = 0x0c,
+	SAESOC_HASH_TYPE_GHASH = 0x0d,
+	SAESOC_HASH_TYPE_MD5 = 0x10,
+	SAESOC_HASH_TYPE_SHA_1 = 0x11, 
+	SAESOC_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_HASH_TYPE_SHA_256 = 0x13,
+	SAESOC_HASH_TYPE_SHA_384 = 0x14,
+	SAESOC_HASH_TYPE_SHA_512 = 0x15,
+	SAESOC_HASH_TYPE_SHA_512_224 = 0x16,
+	SAESOC_HASH_TYPE_SHA_512_256 = 0x17,
+	SAESOC_HASH_TYPE_MAX
+};
+
+/*
+* enum saesoc_hash_mode - Supported hash modes
+*
+* @SAESOC_HASH_MODE_CMAC: Hash mode is CMAC 
+* @SAESOC_HASH_MODE_CBC: Hash mode is CBC
+* @SAESOC_HASH_MODE_XCBC: Hash mode is XCBC
+* @SAESOC_HASH_MODE_HMAC: Hash mode is HMAC
+* @SAESOC_HASH_MODE_RABIN_TERMINATION: Hash mode is RABIN TERMINATION
+* @SAESOC_HASH_MODE_CCM: Hash mode is CCM
+* @SAESOC_HASH_MODE_GCM: Hash mode is GCM
+* @SAESOC_HASH_MODE_MAX: End of hash mode
+*/
+enum saesoc_hash_mode {
+	SAESOC_HASH_MODE_CMAC = 0x00,
+	SAESOC_HASH_MODE_CBC = 0x01,
+	SAESOC_HASH_MODE_XCBC = 0x02,
+	SAESOC_HASH_MODE_HMAC = 0x04,
+	SAESOC_HASH_MODE_RABIN_TERMINATION = 0x05,
+	SAESOC_HASH_MODE_CCM = 0x08,
+	SAESOC_HASH_MODE_GCM = 0x09,
+	SAESOC_HASH_MODE_MAX
+};
+
+
+#endif
+
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
new file mode 100644
index 0000000..d100a59
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen1_hal_defs.h
@@ -0,0 +1,932 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _SAESOC_GEN1_HAL_DEFS_H_
+#define _SAESOC_GEN1_HAL_DEFS_H_
+
+#include "cryptosoc_lib.h"
+
+#define SAESOC_GEN1_SET_MASK(PARAM) \
+	(SAESOC_GEN1_##PARAM##_MASK) << (SAESOC_GEN1_##PARAM##_SHIFT)
+#define SAESOC_GEN1_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & SAESOC_GEN1_##PARAM##_MASK) << SAESOC_GEN1_##PARAM##_SHIFT)
+#define SAESOC_GEN1_GET_BITS(X,PARAM) \
+	 ((_uint64_t)(( (_uint64_t)X >> SAESOC_GEN1_##PARAM##_SHIFT) & \
+		 SAESOC_GEN1_##PARAM##_MASK)) 
+	 
+
+
+#define SAESOC_GEN1_HMAC_MASK 0x1ULL
+#define SAESOC_GEN1_HMAC_SHIFT 61
+
+#define SAESOC_GEN1_HASH_TYPE_MASK 0xfULL
+#define SAESOC_GEN1_HASH_TYPE_SHIFT 52
+
+#define SAESOC_GEN1_HASH_MODE_MASK 0xffULL
+#define SAESOC_GEN1_HASH_MODE_SHIFT 43
+
+#define SAESOC_GEN1_CIPHER_TYPE_MASK 0xffULL
+#define SAESOC_GEN1_CIPHER_TYPE_SHIFT 34
+
+#define SAESOC_GEN1_CIPHER_MODE_MASK 0xffULL
+#define SAESOC_GEN1_CIPHER_MODE_SHIFT 25
+
+#define SAESOC_GEN1_ARC4_KEY_LEN_MASK 0x1fULL
+#define SAESOC_GEN1_ARC4_KEY_LEN_SHIFT 18
+
+#define SAESOC_GEN1_ARC4_KEY_INIT_MASK 0x1ULL
+#define SAESOC_GEN1_ARC4_KEY_INIT_SHIFT 17 
+
+#define SAESOC_GEN1_CFB_MASK_MASK 0x7ULL
+#define SAESOC_GEN1_CFB_MASK_SHIFT 0 
+
+
+/* pkt desc */
+#define SAESOC_GEN1_TLS_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN1_TLS_ENABLE_SHIFT 63 
+
+#define SAESOC_GEN1_HASH_SRC_SEL_MASK 0x1ULL
+#define SAESOC_GEN1_HASH_SRC_SEL_SHIFT 62
+
+#define SAESOC_GEN1_HASH_L3_ALLOCATE_MASK 0x1ULL
+#define SAESOC_GEN1_HASH_L3_ALLOCATE_SHIFT 60
+
+#define SAESOC_GEN1_CIPHER_ENCRYPT_MASK 0x1ULL
+#define SAESOC_GEN1_CIPHER_ENCRYPT_SHIFT 59
+
+#define SAESOC_GEN1_IVLEN_MASK 0xffffULL
+#define SAESOC_GEN1_IVLEN_SHIFT 41
+
+#define SAESOC_GEN1_HASH_DEST_ADDR_MASK 0xffffffffffULL
+#define SAESOC_GEN1_HASH_DEST_ADDR_SHIFT 0
+
+/* pkt desc 1 */
+#define SAESOC_GEN1_CIPHER_LEN_MASK 0xffffffffULL
+#define SAESOC_GEN1_CIPHER_LEN_SHIFT 32
+
+
+#define SAESOC_GEN1_HASH_LEN_MASK 0xffffffffULL
+#define SAESOC_GEN1_HASH_LEN_SHIFT 0 
+/* pkt desc2*/
+
+
+#define SAESOC_GEN1_IV_OFFSET_MASK 0x1ffffULL
+#define SAESOC_GEN1_IV_OFFSET_SHIFT 45 
+
+#define SAESOC_GEN1_CIPHER_BIT_CNT_MASK 0x7ULL
+#define SAESOC_GEN1_CIPHER_BIT_CNT_SHIFT 42 
+
+#define SAESOC_GEN1_CIPHER_OFFSET_MASK 0xffffULL
+#define SAESOC_GEN1_CIPHER_OFFSET_SHIFT 22
+
+#define SAESOC_GEN1_HASH_BIT_CNT_MASK 0x7ULL
+#define SAESOC_GEN1_HASH_BIT_CNT_SHIFT 19
+
+#define SAESOC_GEN1_HASH_CLOBBER_MASK 0x1ULL
+#define SAESOC_GEN1_HASH_CLOBBER_SHIFT 18 
+
+#define SAESOC_GEN1_HASH_OFFSET_MASK 0xffffULL
+#define SAESOC_GEN1_HASH_OFFSET_SHIFT 0
+
+/* pkt desc 3*/
+#define SAESOC_GEN1_FB_DEST_ID_MASK 0xffffULL
+#define SAESOC_GEN1_FB_DEST_ID_SHIFT 48
+
+#define SAESOC_GEN1_TAGLEN_MASK 0xffffULL
+#define SAESOC_GEN1_TAGLEN_SHIFT 11
+
+#define SAESOC_GEN1_ARC4_L3_ALLOC_MASK 0x1ULL
+#define SAESOC_GEN1_ARC4_L3_ALLOC_SHIFT 8 
+
+#define SAESOC_GEN1_ARC4_SAVE_SATE_EN_MASK 0x1ULL
+#define SAESOC_GEN1_ARC4_SAVE_SATE_EN_SHIFT 6
+
+#define SAESOC_GEN1_HMAC_EXTPAD_KEY_MASK 0x1ULL
+#define SAESOC_GEN1_HMAC_EXTPAD_KEY_SHIFT 5
+
+/* pkt desc 4 */
+#define SAESOC_GEN1_PAYLOEAD_LEN_MASK 0xffffULL
+#define SAESOC_GEN1_PAYLOEAD_LEN_SHIFT 48
+
+#define SAESOC_GEN1_PAYLOEAD_SRC_ADDR_MASK 0xffffffffffULL
+#define SAESOC_GEN1_PAYLOEAD_SRC_ADDR_SHIFT 0
+
+/* pkt desc 5 */
+#define SAESOC_GEN1_DEST_PAYLOAD_LEN_MASK 0xffffULL
+#define SAESOC_GEN1_DEST_PAYLOAD_LEN_SHIFT 48
+
+#define SAESOC_GEN1_CIPHER_L3_ALLOC_MASK 0x1ULL
+#define SAESOC_GEN1_CIPHER_L3_ALLOC_SHIFT 46
+
+#define SAESOC_GEN1_CIPHER_CLOBBER_MASK 0x1ULL
+#define SAESOC_GEN1_CIPHER_CLOBBER_SHIFT 41 
+
+#define SAESOC_GEN1_CIPHER_DEST_ADDR_MASK 0xffffffffffULL
+#define SAESOC_GEN1_CIPHER_DEST_ADDR_SHIFT 0
+/*fmn 0 */
+#define SAESOC_GEN1_REG_FB_DEST_ID_MASK 0xffffULL
+#define SAESOC_GEN1_REG_FB_DEST_ID_SHIFT 48
+
+#define SAESOC_GEN1_DESIGN_FB_LEN_MASK 0x3ULL
+#define SAESOC_GEN1_DESIGN_FB_LEN_SHIFT 46
+
+#define SAESOC_GEN1_DESIGN_FB_EN_MASK 0x1ULL
+#define SAESOC_GEN1_DESIGN_FB_EN_SHIFT 45
+
+#define SAESOC_GEN1_CIPHER_KEY_LEN_MASK 0x1fULL
+#define SAESOC_GEN1_CIPHER_KEY_LEN_SHIFT 40 
+
+#define SAESOC_GEN1_CTRL_DESC_ADDR_MASK 0x3ffffffffULL
+#define SAESOC_GEN1_CTRL_DESC_ADDR_SHIFT 0
+
+/*fmn 1 */
+#define SAESOC_GEN1_ARC4_STATE_LD_EN_MASK 0x1ULL
+#define SAESOC_GEN1_ARC4_STATE_LD_EN_SHIFT 63
+
+#define SAESOC_GEN1_HASH_KEY_LEN_MASK 0x1fULL
+#define SAESOC_GEN1_HASH_KEY_LEN_SHIFT 56 
+
+#define SAESOC_GEN1_PKT_DESC_LEN_MASK 0xfffULL
+#define SAESOC_GEN1_PKT_DESC_LEN_SHIFT 43 
+
+#define SAESOC_GEN1_PKT_DESC_ADDR_MASK 0x3ffffffffULL
+#define SAESOC_GEN1_PKT_DESC_ADDR_SHIFT 0
+
+	
+static char saesoc_gen1_cipher_type[][32] = {
+"bypass",       // NLM_CIPHER_BYPASS
+"des",          // NLM_CIPHER_DES
+"3des",         // NLM_CIPHER_3DES
+"aes 128",      // NLM_CIPHER_AES128
+"aes 192",      // NLM_CIPHER_AES192
+"aes 256",      // NLM_CIPHER_AES256
+"arc4",         // NLM_CIPHER_ARC4
+"Kasumi f8",    // NLM_CIPHER_KASUMI_F8
+"snow3g f8",    // NLM_CIPHER_SNOW3G_F8
+"camellia 128", // NLM_CIPHER_CAMELLIA128
+"camelia 192",  // NLM_CIPHER_CAMELLIA192
+"camelia 256",  // NLM_CIPHER_CAMELLIA256
+"undefined",  // > max
+"zuc",
+"undefined",
+};
+static char saesoc_gen1_cipher_mode[][32] = {
+"ecb",          // NLM_CIPHER_MODE_ECB
+"cbc",          // NLM_CIPHER_MODE_CBC
+"cfb",          // NLM_CIPHER_MODE_CFB
+"ofb",          // NLM_CIPHER_MODE_OFB
+"ctr",          // NLM_CIPHER_MODE_CTR
+"aes f8",       // NLM_CIPHER_MODE_AES_F8
+"gcm",          // NLM_CIPHER_MODE_GCM
+"ccm",          // NLM_CIPHER_MODE_CCM
+"undefined",    // NLM_CIPHER_MODE_UNDEFINED1
+"undefined",    // NLM_CIPHER_MODE_UNDEFINED2
+"lrw",          // NLM_CIPHER_MODE_LRW
+"xts",          // NLM_CIPHER_MODE_XTS
+"undefined", // > max
+};
+static char saesoc_gen1_hash_type[][32] = {
+"bypass",       // NLM_AUTH_BYPASS
+"md5",          // NLM_AUTH_MD5
+"sha",          // NLM_AUTH_SHA
+"invalid",       // NLM_AUTH_UNDEFINED
+"aes 128",      // NLM_AUTH_AES128
+"aes 192",      // NLM_AUTH_AES192
+"aes 256",      // NLM_AUTH_AES256
+"kasumi f9",    // NLM_AUTH_KASUMI_F9
+"snow3g f9",    // NLM_AUTH_SNOW3G_F9
+"camellia 128", // NLM_AUTH_CAMELLIA128
+"camellia 192", // NLM_AUTH_CAMELLIA192
+"camellia 256", // NLM_AUTH_CAMELLIA256
+"ghash",        // NLM_AUTH_GHASH
+"zuc",
+"undefined",    // > max
+};
+static char saesoc_gen1_hashmode[][32] = {
+"sha1",         // NLM_AUTH_MODE_SHA1
+"sha 224",      // NLM_AUTH_MODE_SHA224
+"sha 256",      // NLM_AUTH_MODE_SHA256
+"sha 384",      // NLM_AUTH_MODE_SHA384
+"sha 512",      // NLM_AUTH_MODE_SHA512
+"cmac",         // NLM_AUTH_MODE_CMAC
+"xcbc",         // NLM_AUTH_MODE_XCBC
+"cbc mac",      // NLM_AUTH_MODE_CBC_MAC
+"ccm",
+"gcm",
+"undefined", // > max
+};
+
+enum saesoc_gen1_hash_type {
+	SAESOC_GEN1_HASH_TYPE_AES_128 = 0x4,
+	SAESOC_GEN1_HASH_TYPE_AES_192 = 0x5,
+	SAESOC_GEN1_HASH_TYPE_AES_256 = 0x6,
+    SAESOC_GEN1_HASH_TYPE_CAMELLIA_128 = 0x09,
+	SAESOC_GEN1_HASH_TYPE_CAMELLIA_192 = 0x0a,
+	SAESOC_GEN1_HASH_TYPE_CAMELLIA_256 = 0x0b,	
+	SAESOC_GEN1_HASH_BYPASS = 0x00,
+	SAESOC_GEN1_HASH_TYPE_KASUMI = 0x07,
+	SAESOC_GEN1_HASH_TYPE_SNOW3G = 0x08,
+	SAESOC_GEN1_HASH_TYPE_ZUC = 0x0d,
+	SAESOC_GEN1_HASH_TYPE_RABIN = 0x0,
+	SAESOC_GEN1_HASH_TYPE_GHASH = 0x0c,
+	SAESOC_GEN1_HASH_TYPE_MD5 = 0x01,
+	SAESOC_GEN1_HASH_TYPE_SHA_1 = 0x02,
+	SAESOC_GEN1_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_GEN1_HASH_TYPE_SHA_256 = 0x22,
+	SAESOC_GEN1_HASH_TYPE_SHA_384 = 0x32,
+	SAESOC_GEN1_HASH_TYPE_SHA_512 = 0x42,
+	SAESOC_GEN1_HASH_TYPE_MAX = 0xff
+};
+
+enum saesoc_gen1_cipher_type {
+	SAESOC_GEN1_CIPHER_TYPE_AES_128 = 0x3,
+	SAESOC_GEN1_CIPHER_TYPE_AES_192 = 0x4,
+	SAESOC_GEN1_CIPHER_TYPE_AES_256 = 0x5,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_128 = 0x9,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_192 = 0xa,
+	SAESOC_GEN1_CIPHER_TYPE_CAMELLIA_256 = 0xb,
+	SAESOC_GEN1_CIPHER_BYPASS = 0x0,
+	SAESOC_GEN1_CIPHER_TYPE_KASUMI = 0x7,
+	SAESOC_GEN1_CIPHER_TYPE_SNOW3G = 0x8,
+	SAESOC_GEN1_CIPHER_TYPE_ZUC =0xd,
+	SAESOC_GEN1_CIPHER_TYPE_DES =0x1,
+	SAESOC_GEN1_CIPHER_TYPE_TDES = 0x2,
+	SAESOC_GEN1_CIPHER_TYPE_ARC4 = 0x6,
+	SAESOC_GEN1_CIPHER_TYPE_MAX = 0xf
+};
+
+static inline void saesoc_gen1_dump_fmnentry(_uint64_t entry0, _uint64_t entry1)
+{
+
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s \n",
+			"RegFb","DesFbEn", "DesFbLen", "KeyLenInDw", "CtrlDescAddr");
+
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+			SAESOC_GEN1_GET_BITS(entry0, REG_FB_DEST_ID),
+			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_EN),
+			SAESOC_GEN1_GET_BITS(entry0, DESIGN_FB_LEN) + 1,
+			SAESOC_GEN1_GET_BITS(entry0, CIPHER_KEY_LEN),
+			(SAESOC_GEN1_GET_BITS(entry0, CTRL_DESC_ADDR) << 
+			 		CRYPTOSOC_CACHELINE_SHIFT));
+
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s \n", 
+			"Arc4StateLdEn", "Hashkeylen", "PktDescLen", "PktDescAddr");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx \n",
+			SAESOC_GEN1_GET_BITS(entry1, ARC4_STATE_LD_EN), 
+			SAESOC_GEN1_GET_BITS(entry1, HASH_KEY_LEN),
+			SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_LEN), 
+			(SAESOC_GEN1_GET_BITS(entry1, PKT_DESC_ADDR) << 
+			 			CRYPTOSOC_CACHELINE_SHIFT));
+
+}
+
+/**
+ * saesoc_gen1_dump_cdesc - Extract the control descriptors and dump the
+ * 	 values
+ * @cdescs: Pointer to the control descriptor
+ * @ndescs: Number of descriptors present
+ */
+static void saesoc_gen1_dump_cdesc(_uint64_t *cdescs, int ndescs)
+{
+	unsigned int type,mode;
+	_uint64_t cdesc = cdescs[0];
+
+	cryptosoc_print("\ncontrol description info:\n");
+       	cryptosoc_print(" %-16s \n", "Desc");
+	cryptosoc_print(" %-16llx\n", (unsigned long long)cdesc);
+
+	type = SAESOC_GEN1_GET_BITS(cdesc, HASH_TYPE); 
+	mode = SAESOC_GEN1_GET_BITS(cdesc, HASH_MODE);
+
+	cryptosoc_print(" %-16s %-16s %-16s \n","Hmac","HashType","HashMode");
+	cryptosoc_print(" %-16llx %-16s %-16s\n",
+			SAESOC_GEN1_GET_BITS(cdesc, HMAC),
+			saesoc_gen1_hash_type[type],saesoc_gen1_hashmode[mode]);
+
+	type =  SAESOC_GEN1_GET_BITS(cdesc,CIPHER_TYPE );
+	mode = SAESOC_GEN1_GET_BITS(cdesc,CIPHER_MODE );
+
+	cryptosoc_print(" %-16s %-16s\n","CipherType","CipherMode");
+	cryptosoc_print(" %-16s %-16s\n",saesoc_gen1_cipher_type[type],
+			saesoc_gen1_cipher_mode[mode]);
+
+	cryptosoc_print(" %-16s %-16s %-16s\n",
+			"Arc4KeyLen","Arc4KeyInit","CfbMask");
+	cryptosoc_print(" %-16lld %-16lld %-16llx\n",
+			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_LEN),
+			SAESOC_GEN1_GET_BITS(cdesc, ARC4_KEY_INIT),
+			SAESOC_GEN1_GET_BITS(cdesc, CFB_MASK));
+
+	if(ndescs > 1) {
+		int i;
+		cryptosoc_print("\nKey info:\n");
+		for(i = 1; i < ndescs; i++)
+			cryptosoc_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_print("\n");
+	}
+}
+
+/**
+ * saesoc_gen1_dump_ddesc - Extract the data descriptors and dump the values
+ * @ddesc: Pointer to the data descriptor array
+ * @ndescs: Number of descriptors present
+ * @ndesfb_descs: Number of designer freeback descriptors present
+ */
+static void saesoc_gen1_dump_ddesc(_uint64_t *ddesc, int ndescs, int ndesfb_descs)
+{
+	int nd = 0;
+	_uint64_t desc0, desc1, desc2, desc3;
+	int i;
+
+	desc0 = ddesc[nd++];
+	desc1 = ddesc[nd++];
+	desc2 = ddesc[nd++];
+	desc3 = ddesc[nd++];
+
+	cryptosoc_print("\nData Descriptor info:\n");
+	cryptosoc_print(" %-16s %-16s %-16s %-16s\n",
+			"Desc0","Desc1","Desc2","Desc3");
+
+	cryptosoc_print(" %-16llx %-16llx %-16llx %-16llx\n",
+			desc0, desc1, desc2,desc3);	
+
+	cryptosoc_print(" %-16s %-16s\n","TLSProto","HashSource");
+	cryptosoc_print(" %-16lld %-16lld\n",
+			SAESOC_GEN1_GET_BITS(desc0,TLS_ENABLE),
+			SAESOC_GEN1_GET_BITS(desc0, HASH_SRC_SEL));
+
+	cryptosoc_print(" %-16s %-16s %-16s\n","HashL3","HashAddr","HashLen");
+	cryptosoc_print(" %-16lld %-16llx %-16lld\n",
+			SAESOC_GEN1_GET_BITS(desc0,HASH_L3_ALLOCATE ),
+			SAESOC_GEN1_GET_BITS(desc0,HASH_DEST_ADDR ),
+			SAESOC_GEN1_GET_BITS(desc1,HASH_LEN));
+
+	cryptosoc_print(" %-16s %-16s %-16s \n","HashBitCnt","HashClobber",
+			"HashOffset");
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
+		SAESOC_GEN1_GET_BITS(desc2,HASH_BIT_CNT ),
+		SAESOC_GEN1_GET_BITS(desc2,HASH_CLOBBER ),
+		SAESOC_GEN1_GET_BITS(desc2,HASH_OFFSET ));
+
+	cryptosoc_print(" %-16s %-16s\n","TagLen","ExtPadKey");
+	cryptosoc_print(" %-16lld %-16lld\n",
+		SAESOC_GEN1_GET_BITS(desc3, TAGLEN),
+		SAESOC_GEN1_GET_BITS(desc3,HMAC_EXTPAD_KEY ));
+
+	cryptosoc_print(" %-16s %-16s %-16s\n","Encrypt","IVLength",
+			"IVOffset");
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN1_GET_BITS(desc0,CIPHER_ENCRYPT ),	
+			SAESOC_GEN1_GET_BITS(desc0,IVLEN ),
+			SAESOC_GEN1_GET_BITS(desc2,IV_OFFSET ));
+
+	cryptosoc_print(" %-16s %-16s %-16s\n","CipherLen","CipherBitCnt",
+			"CipherOffset");
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
+		SAESOC_GEN1_GET_BITS(desc1, CIPHER_LEN),
+		SAESOC_GEN1_GET_BITS(desc2, CIPHER_BIT_CNT),
+		SAESOC_GEN1_GET_BITS(desc2, CIPHER_OFFSET));
+
+	cryptosoc_print(" %-16s %-16s %-16s\n","DesignerFb","Arc4L3",
+			"Arc4SaveState");
+	cryptosoc_print(" %-16lld %-16lld %-16lld\n",
+		SAESOC_GEN1_GET_BITS(desc3, FB_DEST_ID),
+		SAESOC_GEN1_GET_BITS(desc3, ARC4_L3_ALLOC),
+		SAESOC_GEN1_GET_BITS(desc3, ARC4_SAVE_SATE_EN));
+
+	for (i=nd; i < ndescs - ndesfb_descs; ) {
+		desc0 = ddesc[i++];
+		desc1 = ddesc[i++];
+
+		cryptosoc_print(
+				"\nPacket Fragment info: Srcfrag %-16llx DstFrag %-16llx\n",
+				desc0, desc1);
+
+		cryptosoc_print(" %-16s %-16s \n",
+				"SrcFragLen","SrcFragPaddr");
+		cryptosoc_print(" %-16lld %-16llx\n",
+                	SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_LEN),
+               		SAESOC_GEN1_GET_BITS(desc0, PAYLOEAD_SRC_ADDR));
+
+		cryptosoc_print(" %-16s %-16s %-16s %-16s\n",
+				"DstFragLen","DstFragPaddr", "CipherL3", "CipherClobber");
+		cryptosoc_print(" %-16lld %-16llx %-16lld %-16lld \n",
+                	SAESOC_GEN1_GET_BITS(desc1, DEST_PAYLOAD_LEN),
+                	SAESOC_GEN1_GET_BITS(desc1, CIPHER_DEST_ADDR),
+                	SAESOC_GEN1_GET_BITS(desc1, CIPHER_L3_ALLOC),
+                	SAESOC_GEN1_GET_BITS(desc1, CIPHER_CLOBBER));
+	}
+	if(ndesfb_descs) {
+		cryptosoc_print("\nDesigner Fb descs:\n");
+		for(; (i < ndescs); i++) 
+			cryptosoc_print("  %-16llx", ddesc[i]);
+		cryptosoc_print("\n");
+	}
+	cryptosoc_print("\n");
+}
+
+/**
+ * saesoc_gen1_set_hash_type_mode - Set the control descriptor with Hash Parameters
+ * @cdesc        : ctrl Descriptor  
+ * @hmac          : 1/0 Hash with/without HMAC
+ * @type      : refer saesoc_hash_type_xlp
+ * @mode      : refer saesoc_hash_mode_xlp
+ *
+ * Ctrl Descriptor param bits corresponding to hash params are cleared 
+ * and is set with the new values. 
+ */
+
+#define saesoc_gen1_set_hash_type_mode( cdesc, hmac, type,	\
+		mode)				{		\
+	_uint64_t mask = (SAESOC_GEN1_SET_MASK(HASH_TYPE) | 		\
+			SAESOC_GEN1_SET_MASK(HASH_MODE) | 		\
+			SAESOC_GEN1_SET_MASK(HMAC) ); 		\
+	cdesc = cdesc & ~mask; 						\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(type,HASH_TYPE) | 	\
+		SAESOC_GEN1_SET_BITS(mode, HASH_MODE) |		\
+		SAESOC_GEN1_SET_BITS(hmac, HMAC);			\
+	}
+
+/**
+ * saesoc_gen1_set_cipher_type_mode - Set the control descriptor with cipher 
+ *  parameters.
+ * @cdesc          : ctrl Descriptor 
+ * @type	   : refer saesoc_cipher_type
+ * @mode     : refer saesoc_cipher_mode
+ *
+ * Ctrl Descriptor param bits corresponding CipherType,CipherMode, 
+ * are cleared and sets with the new values.
+ */
+#define saesoc_gen1_set_cipher_type_mode( cdesc, type, mode) {	\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(CIPHER_TYPE) |		\
+			SAESOC_GEN1_SET_MASK(CIPHER_MODE) ; 		\
+	cdesc = cdesc & ~mask;						\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(type, CIPHER_TYPE)|\
+	    SAESOC_GEN1_SET_BITS(mode, CIPHER_MODE) ;		\
+	}
+
+/**
+ * saesoc_gen1_set_hash_bypass - Set the control descriptor with 
+ * 	Hash bypass
+ * @cdesc        : ctrl Descriptor 
+ */
+#define saesoc_gen1_set_hash_bypass(cdesc) {	\
+	 _uint64_t mask = SAESOC_GEN1_SET_MASK(HASH_TYPE); \
+	cdesc = cdesc & ~mask;					\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(SAESOC_GEN1_HASH_BYPASS, HASH_TYPE); \
+}
+
+/**
+ * saesoc_gen1_set_cipher_bypass - Set the control descriptor with 
+ *  Cipher bypass
+ * @cdesc        : ctrl Descriptor 
+ */
+#define saesoc_gen1_set_cipher_bypass(cdesc) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_TYPE); \
+	cdesc = cdesc & ~mask;					\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(SAESOC_GEN1_CIPHER_BYPASS, CIPHER_TYPE); \
+}
+
+/**
+ * saesoc_gen1_set_arc4_param - Set the control descriptor with arc4 
+ *  parameters.
+ * @cdesc         	: ctrl Descriptor  
+ * @key_init		: ARC key init. Done for the first time. 
+ * @key_len     	: ARC4 Key Length in bytes , 0 means 256 bytes
+ *
+ * ctrl Descriptor param bits corresponding to Arc4KeyInit
+ * and arc4KeyLen are cleared and is set with the new values.
+ */
+#define saesoc_gen1_set_arc4_param( cdesc, key_init, key_len){		\
+	_uint64_t mask = (SAESOC_GEN1_SET_MASK(ARC4_KEY_INIT) |	\
+			SAESOC_GEN1_SET_MASK(ARC4_KEY_LEN)); 		\
+	cdesc = cdesc & ~mask;						\
+	cdesc = cdesc | 						\
+	 SAESOC_GEN1_SET_BITS(key_init, ARC4_KEY_INIT) |		\
+		SAESOC_GEN1_SET_BITS(key_len, ARC4_KEY_LEN);	\
+}
+
+/**
+ * saesoc_gen1_set_cfbmask - Set the control descriptor with aes-cfb bit mask
+ * @cdesc         : ctrl Descriptor 
+ * @cfbmask	   : 111 Select 128 bits of CipherText for feedback.
+ *		     110 Select 64 bits of CipherText for feedback.
+ *                   101 Select 32 bits of CipherText for feedback.
+ *                   100 Select 16 bits of CipherText for feedback.
+ *                   011 Select 8 bits of CipherText for feedback.
+ *                   010 Select 4 bits of CipherText for feedback.
+ *                   001 Select 2 bits of CipherText for feedback.
+ *                   000 Select 1 bit of CipherText for feedback.
+ * 
+ * sets the bits of ciphertext for feedback in the ctrl descriptor.
+ */
+
+#define saesoc_gen1_set_cfbmask( cdesc, cfbmask) {				\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(CFB_MASK);		\
+	cdesc = cdesc & ~mask;						\
+	cdesc = cdesc | SAESOC_GEN1_SET_BITS(cfbmask,CFB_MASK);	\
+	}
+
+/**
+ * saesoc_gen1_set_tls - Enable tls mode operation
+ * @ddesc0          : data Descriptor 0
+ * @tls_en       : Enable/Disable Tls 
+ *
+ * data Descriptor param bits corresponding to TlsEnable and HashSrcSel
+ * are cleared and is set with the new values.
+ */
+#define saesoc_gen1_set_tls(ddesc0, tls_en) {			\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(TLS_ENABLE) | 		\
+	ddesc0 = ddesc0 & ~mask;					\
+	ddesc0 = ddesc0 | 						\
+		SAESOC_GEN1_SET_BITS(tls_en, TLS_ENABLE);		\
+	}
+
+/**
+ * saesoc_gen1_set_hash_srcsel - Set the hash source select param
+ * @ddesc0          : data Descriptor 0
+ * @hash_src_sel    : 1 Hash input is cipher output.
+ *
+ * data Descriptor param bits corresponding to HashSrcSel
+ * are cleared and is set with the new values.
+ */
+#define saesoc_gen1_set_hash_srcsel(ddesc0, hash_src_sel) {			\
+	_uint64_t mask =  					\
+		SAESOC_GEN1_SET_MASK(HASH_SRC_SEL) ;			\
+	ddesc0 = ddesc0 & ~mask;				\
+	ddesc0 =ddesc0 |					\
+		SAESOC_GEN1_SET_BITS(hash_src_sel,HASH_SRC_SEL);	\
+	}
+
+/**
+ * saesoc_gen1_set_tag_dstaddr - set tag addrs  in ddesc0
+ * @ddesc0          : data Descriptor 0
+ * @tag_dst_addr   : Byte aligned pointer to hash destination.
+ *
+ * clears the hash param field of data Descriptor 0 and sets with new
+ * values.
+ */
+#define saesoc_gen1_set_tag_dstaddr( ddesc0, tag_dst_addr){ 	\
+	_uint64_t mask =  					\
+		SAESOC_GEN1_SET_MASK(HASH_DEST_ADDR); \
+	ddesc0 = ddesc0 & ~mask;				\
+	ddesc0 =ddesc0 |					\
+		SAESOC_GEN1_SET_BITS(tag_dst_addr,HASH_DEST_ADDR); \
+	}	
+
+/**
+ * saesoc_gen1_set_hash_l3allocate -  set hash params in ddesc0
+ * @ddesc0          : data Descriptor 0
+ * @hash_l3_allocate : Enable/Disable L3 allocation for tag write   
+ *
+ * clears the hash param field of data Descriptor 0 and sets with new
+ * values.
+ */
+#define saesoc_gen1_set_hash_l3allocate( ddesc0, hash_l3_allocate) {				\
+	_uint64_t mask =  SAESOC_GEN1_SET_MASK(HASH_L3_ALLOCATE);	\
+	ddesc0 = ddesc0 & ~mask;					\
+	ddesc0 =ddesc0 | SAESOC_GEN1_SET_BITS(hash_l3_allocate,HASH_L3_ALLOCATE);\
+	}	
+
+/**
+ * saesoc_gen1_set_enc_ivlen - sets the Encrypt/Decrypt and iv len 
+ * @ddesc0          : data Descriptor 0
+ * @encrypt 	    : 1/0 Encrypted/Decrypted 
+ * @iv_len           : IV length -1
+ *
+ * clears the cipher params of data  Descriptor 0 and sets with new
+ * values.
+ */
+#define saesoc_gen1_set_cipher_enc_ivlen( ddesc0, encrypt , iv_len){		\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(CIPHER_ENCRYPT)|        \
+		SAESOC_GEN1_SET_MASK(IVLEN);				\
+	ddesc0 = ddesc0 & ~mask;					\
+	if( iv_len ) {							\
+		ddesc0 = ddesc0 |					\
+			 SAESOC_GEN1_SET_BITS(encrypt,CIPHER_ENCRYPT) | \
+		SAESOC_GEN1_SET_BITS((iv_len-1),IVLEN);  		\
+	}else								\
+		ddesc0 = ddesc0 | 					\
+			 SAESOC_GEN1_SET_BITS(encrypt,CIPHER_ENCRYPT);  \
+	}
+
+/**
+ * saesoc_gen1_set_cipher_len - sets the cipher length
+ * @ddesc1          : data Descriptor 1
+ * @cipher_len       : cipher length -1 
+ *
+ * sets the cipher length in the data descriptor 1 
+ */
+
+#define saesoc_gen1_set_cipher_len( ddesc1, cipher_len) {			\
+	 _uint64_t mask=SAESOC_GEN1_SET_MASK(CIPHER_LEN);		\
+	ddesc1 = ddesc1 & ~mask;					\
+	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS((cipher_len-1),CIPHER_LEN);	\
+	}
+
+/**
+ * saesoc_gen1_set_hash_len - sets the hash length 
+ * @ddesc1          : data Descriptor 1
+ * @hash_len	    : hash length -1 
+ *
+ * sets the hash length in the data descriptor 1
+ */
+#define saesoc_gen1_set_hash_len( ddesc1, hash_len) {				\
+	_uint64_t mask=SAESOC_GEN1_SET_MASK(HASH_LEN);		\
+	ddesc1 = ddesc1 & ~mask;					\
+	ddesc1 = ddesc1 | SAESOC_GEN1_SET_BITS((hash_len-1),HASH_LEN);	\
+	}
+
+/**
+ * saesoc_gen1_set_hash_offset_clobber - set the hash params in ddesc2
+ * @ddesc2 	: data Descriptor 2
+ * @hash_offset  : Hash Offset from start of data.
+ * @hash_clobber : When this bit is set, the output is written out as multiples 
+ *                of cache lines. No readmodifywrite is done. 
+ * 
+ * clears and sets the bits corresponding to hash on data descriptor 2
+ */
+#define saesoc_gen1_set_hash_offset_clobber( ddesc2, 	 	\
+		hash_offset, hash_clobber) {				\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( HASH_OFFSET) |		\
+		SAESOC_GEN1_SET_MASK( HASH_CLOBBER );			\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+		SAESOC_GEN1_SET_BITS( hash_offset,HASH_OFFSET) |	\
+       		SAESOC_GEN1_SET_BITS(hash_clobber, HASH_CLOBBER);	\
+	}	
+
+
+#define saesoc_gen1_get_hash_clobber( ddesc2, clob) { \
+	_uint64_t mask = SAESOC_GEN1_SET_MASK( HASH_CLOBBER ); \
+	clob = ddesc2 & mask; \
+}
+
+/* saesoc_gen1_set_hash_bitcnt - sets the hash params in ddesc2
+ * @ddesc2 	: data Descriptor 2
+ * @hash_bitcnt 	: This field indicates the number of valid bits in
+ *                the last input byte to the hash
+ * clears and sets the bits corresponding to hash on data descriptor 2
+ */
+
+#define saesoc_gen1_set_hash_bitcnt( ddesc2, hash_bitcnt){		\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( HASH_BIT_CNT);		\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+		SAESOC_GEN1_SET_BITS(hash_bitcnt,HASH_BIT_CNT)	;	\
+}
+
+/**
+ * saesoc_gen1_set_cipher_ivoffset - set the cipher params in ddes2
+ * @ddesc2 	: data Descriptor 2
+ * @cipher_iv_offset   : Offset from start of data. A value of 0 in this
+ *                  field indicates an offset field of 0.
+ * 
+ * clears and sets the bits corresponding to cipher on data descriptor 2
+ */
+#define saesoc_gen1_set_cipher_ivoffset( ddesc2, 	\
+		cipher_iv_offset) {				\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( IV_OFFSET );			\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+       		SAESOC_GEN1_SET_BITS(cipher_iv_offset, IV_OFFSET);	\
+	}	
+
+/**
+ * saesoc_gen1_set_cipher_offset - set the cipher params in ddes2
+ * @ddesc2 	: data Descriptor 2
+ * @cipher_offset  : Cipher Offset from start of data.
+ * 
+ * clears and sets the bits corresponding to cipher on data descriptor 2
+ */
+#define saesoc_gen1_set_cipher_offset( ddesc2, 	\
+		cipher_offset) {				\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( CIPHER_OFFSET) ;	\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+		SAESOC_GEN1_SET_BITS(cipher_offset,CIPHER_OFFSET) ;	\
+	}	
+
+
+
+/* saesoc_gen1_set_cipher_bitcnt - sets the cipher params in ddesc2
+ * @ddesc2 	: data Descriptor 2
+ * @cipher_bitcnt 	: This field indicates the number of valid bits in
+ *                the last input byte to the cipher
+ * clears and sets the bits corresponding to hash on data descriptor 2
+ */
+
+#define saesoc_gen1_set_cipher_bitcnt( ddesc2, cipher_bitcnt){		\
+	_uint64_t mask= SAESOC_GEN1_SET_MASK( CIPHER_BIT_CNT);		\
+	ddesc2 = ddesc2 & ~mask;					\
+	ddesc2 = ddesc2 |						\
+		SAESOC_GEN1_SET_BITS(cipher_bitcnt,CIPHER_BIT_CNT);	\
+}
+
+/**
+ * saesoc_gen1_set_desfb - sets station ID for designer freeback 
+ * @ddesc3        : Data Descriptor 3
+ * @desfb_dst_id   : Message station ID of designer freeback destination. 
+ *
+ * If an error occurs in the packet, the freeback message is sent to the 
+ * regular freeback destination instead of the designer 
+ * freeback destination. 
+ */
+#define saesoc_gen1_set_desfb( ddesc3, desfb_dst_id) {			\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(FB_DEST_ID);	\
+	ddesc3 = ddesc3 & ~mask; 					\
+	ddesc3 = ddesc3 | 						\
+		SAESOC_GEN1_SET_BITS(desfb_dst_id, FB_DEST_ID);	\
+	}
+
+/**
+ * saesoc_gen1_set_taglen - sets the tag length for hash
+ * @ddesc3         : Data Descriptor 3
+ * @tag_len	   : Tag length in bytes. TagLength must be less than the 
+ *                   maximum tag length allowed by the selected hash 
+ *                   type/mode.
+ *
+ * Sets the tag length.
+ */
+#define saesoc_gen1_set_tag_len( ddesc3, tag_len) {				\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(TAGLEN);		\
+	ddesc3 = ddesc3 & ~mask;					\
+	ddesc3 = ddesc3 | SAESOC_GEN1_SET_BITS(tag_len, TAGLEN);	\
+	}
+		
+
+/**
+ * saesoc_gen1_set_arc4_l3param - saves the arc4 l3 param
+ * @ddesc3        : Data Descriptor 3
+ * @arc4_l3_alloc   : the ARC4 state is saved, it transits through the L3 
+ *                  cache
+ *
+ * Applicable only for arc4.
+ */
+#define saesoc_gen1_set_arc4_l3param(ddesc3, arc4_l3_alloc) {	\
+	 _uint64_t mask = 					\
+			SAESOC_GEN1_SET_MASK(ARC4_L3_ALLOC);		\
+	ddesc3 = ddesc3 & ~mask;					\
+	ddesc3 = ddesc3 | 						\
+		SAESOC_GEN1_SET_BITS(arc4_l3_alloc,ARC4_L3_ALLOC);	\
+	}
+
+/**
+ * saesoc_gen1_set_arc4_savestate - saves the arc4 key state.
+ * @ddesc3        : Data Descriptor 3 
+ * @arc4_save_state : do/donot write ARC4 State to memory when packet
+ *                  complete.
+ *
+ * Applicable only for arc4.
+ */
+#define saesoc_gen1_set_arc4_savestate(ddesc3, arc4_save_state) {	\
+	 _uint64_t mask = SAESOC_GEN1_SET_MASK(ARC4_SAVE_SATE_EN) ;	\
+	ddesc3 = ddesc3 & ~mask;					\
+	ddesc3 = ddesc3 | 						\
+	SAESOC_GEN1_SET_BITS(arc4_save_state, ARC4_SAVE_SATE_EN);	\
+	}
+
+
+/**
+ * saesoc_gen1_set_hmac_extkeypad - sets padding is added to the end of payload.
+ * @ddesc3         : data Descriptor 3
+ * @hmac_extpad_key  : The ipad and  opad for the HMAC have been done 
+ *                   already, allowing hardware to skip these two 
+ *                   padding steps
+ *                   
+ * enables/disbales extended key pad for HMAC. 
+ */
+#define saesoc_gen1_set_hmac_extkeypad( ddesc3, hmac_extpad_key) {	\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(HMAC_EXTPAD_KEY);	\
+	ddesc3 = ddesc3 & ~mask;					\
+	ddesc3 = ddesc3 | 						\
+		SAESOC_GEN1_SET_BITS(hmac_extpad_key,HMAC_EXTPAD_KEY);	\
+	}
+
+/**
+ * saesoc_gen1_set_src_frag - sets the payload length and src addr  
+ * @ddesc4  	:  data Descriptor 4
+ * @frag_len 	:  A value of 0 in this field indicates length of 1 byte. 
+ * @src_addr     :  Byte aligned read address for fetching security
+ *                 payload
+ *
+ * Sets the length and src address for payload.
+ */
+#define saesoc_gen1_set_src_frag( ddesc4, frag_len, src_addr) {	\
+	ddesc4 = SAESOC_GEN1_SET_BITS( (frag_len-1), PAYLOEAD_LEN) |	\
+		SAESOC_GEN1_SET_BITS( src_addr, PAYLOEAD_SRC_ADDR);	\
+	}
+
+
+/**
+ * saesoc_gen1_set_dst_frag - sets the dst payload length and addr
+ * @ddesc5	: data Descriptor 5
+ * @frag_len  : A value of 0 in this field indicates a length of 1 byte
+ * @dst_addr 	: Bytealigned write address for encrypted/decrypted data
+ *
+ * Clears and sets payload destination length and address 
+ */
+#define saesoc_gen1_set_dst_frag(ddesc5, frag_len, dst_addr) { \
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(DEST_PAYLOAD_LEN) |	\
+			SAESOC_GEN1_SET_MASK(CIPHER_DEST_ADDR);		\
+	ddesc5 = ddesc5 & ~mask;					\
+	ddesc5 = ddesc5 |SAESOC_GEN1_SET_BITS((frag_len-1),DEST_PAYLOAD_LEN) | \
+		SAESOC_GEN1_SET_BITS(dst_addr, CIPHER_DEST_ADDR);		\
+	}
+
+/**
+ * saesoc_gen1_set_cipher_l3param - sets the cipher l3 parameters
+ * @ddesc5	: data Descriptor 5
+ * @cipher_l3_allocate	: Enable/Disable L3 allocation for packet write 
+ * @cipher_clobber     	: Enable/Disable Clobber cacheline on packet write
+ *
+ * clears and sets the l3 allocate and clobber bits .
+ */
+#define saesoc_gen1_set_cipher_l3param(ddesc5, cipher_l3_allocate,		\
+		cipher_clobber) {					\
+	_uint64_t mask = SAESOC_GEN1_SET_MASK(CIPHER_L3_ALLOC) |	\
+			SAESOC_GEN1_SET_MASK(CIPHER_CLOBBER);		\
+	ddesc5 = ddesc5 & ~mask;					\
+	ddesc5 = SAESOC_GEN1_SET_BITS(cipher_l3_allocate,CIPHER_L3_ALLOC) |	\
+	   	SAESOC_GEN1_SET_BITS(cipher_clobber, CIPHER_CLOBBER);	\
+	}
+
+/**
+ * saesoc_gen1_form_fmn_entry0 - fmn entry 0 with regular and designer freeback
+ * @reg_fb_dst_id : Regular Freeback Destination ID
+ *                station Id for error freebacks in case of designer fb.
+ * @des_fb_len : Number of freeback entries , 0 means 4
+ * @des_fb_en   : Enable Designer Fb.
+ * @cipher_key_len_in_dw: Cipher key Length in doublewords. 
+ * @ctrl_desc_addr : Cacheline aligned address of the control descriptor. 
+ *
+ * Return      : filled fmn entry 0
+ *
+ */
+static inline _uint64_t  saesoc_gen1_form_fmn_entry0(
+		unsigned int reg_fb_dst_id, unsigned int des_fb_len, 
+		unsigned int des_fb_en,
+		unsigned int cipher_key_len_in_dw, _uint64_t ctrl_desc_addr)
+{
+	return( SAESOC_GEN1_SET_BITS(reg_fb_dst_id, REG_FB_DEST_ID) |
+		SAESOC_GEN1_SET_BITS(des_fb_len - 1, DESIGN_FB_LEN) | 
+		SAESOC_GEN1_SET_BITS(des_fb_en, DESIGN_FB_EN) |
+		SAESOC_GEN1_SET_BITS(cipher_key_len_in_dw, CIPHER_KEY_LEN) | 
+		SAESOC_GEN1_SET_BITS(ctrl_desc_addr, CTRL_DESC_ADDR));
+}
+
+/**
+ * saesoc_gen1_form_fmn_entry1 - forms the fmn entry 1
+ * @arc4_load_state: Load the arc4 state before the operation
+ * @hash_key_len_in_dw: length of Hash key in doublewords.
+ * @pkt_desc_len_in_dw: packet Descriptor Length -1 in doublewords.0 means 16.
+ * @pkt_desc_addr: Cacheline aligned address of packet descriptor. 
+ *
+ * Return : filled fmn entry 1 
+ * 
+ */
+static inline _uint64_t  saesoc_gen1_form_fmn_entry1( unsigned int arc4_load_state,
+		_uint64_t hash_key_len_in_dw,
+		_uint64_t pkt_desc_len_in_dw, _uint64_t pkt_desc_addr)  
+{
+	return(	SAESOC_GEN1_SET_BITS(arc4_load_state ,ARC4_STATE_LD_EN)|
+		SAESOC_GEN1_SET_BITS(hash_key_len_in_dw ,HASH_KEY_LEN) | 
+		SAESOC_GEN1_SET_BITS(pkt_desc_len_in_dw, PKT_DESC_LEN)|
+		SAESOC_GEN1_SET_BITS(pkt_desc_addr, PKT_DESC_ADDR));
+}
+
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
new file mode 100644
index 0000000..200c227
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/saesoc_gen2_hal_defs.h
@@ -0,0 +1,1072 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+#ifndef _SAESOC_GEN2_HAL_DEFS_H
+#define _SAESOC_GEN2_HAL_DEFS_H
+
+/* Common definitions are given in the below file */
+#include "cryptosoc_lib.h"
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+
+#define SAESOC_GEN2_SET_MASK(PARAM) \
+	(SAESOC_GEN2_##PARAM##_MASK << SAESOC_GEN2_##PARAM##_SHIFT)
+#define SAESOC_GEN2_SET_BITS(X,PARAM) \
+	(((_uint64_t)X & SAESOC_GEN2_##PARAM##_MASK) << SAESOC_GEN2_##PARAM##_SHIFT)
+#define SAESOC_GEN2_GET_BITS(X,PARAM) \
+	((_uint64_t)(( (_uint64_t)X >> SAESOC_GEN2_##PARAM##_SHIFT) & \
+		SAESOC_GEN2_##PARAM##_MASK))
+
+/* Control descriptor 0*/
+#define SAESOC_GEN2_ADDL_HASH_LEN_MASK 0xfULL
+#define SAESOC_GEN2_ADDL_HASH_LEN_SHIFT 60
+
+#define SAESOC_GEN2_RABIN_FINGERPRINT_MASK 0x1ULL
+#define SAESOC_GEN2_RABIN_FINGERPRINT_SHIFT 59
+
+#define SAESOC_GEN2_ARC4_L3_ALLOCATE_MASK 0x1ULL
+#define SAESOC_GEN2_ARC4_L3_ALLOCATE_SHIFT 58
+
+#define SAESOC_GEN2_DATA_OUT_L3_ALLOCATE_MASK 0x1ULL
+#define SAESOC_GEN2_DATA_OUT_L3_ALLOCATE_SHIFT 57
+
+#define SAESOC_GEN2_DATA_OUT_CLOBBER_MASK 0x1ULL
+#define SAESOC_GEN2_DATA_OUT_CLOBBER_SHIFT 56
+
+#define SAESOC_GEN2_HASH_L3_ALLOCATE_MASK 0x1ULL
+#define SAESOC_GEN2_HASH_L3_ALLOCATE_SHIFT 55
+
+#define SAESOC_GEN2_HASH_CLOBBER_MASK 0x1ULL
+#define SAESOC_GEN2_HASH_CLOBBER_SHIFT 54
+
+#define SAESOC_GEN2_WR_MODI_ONLY_EN_MASK 0x1ULL
+#define SAESOC_GEN2_WR_MODI_ONLY_EN_SHIFT 53
+
+#define SAESOC_GEN2_TLS_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN2_TLS_ENABLE_SHIFT 52
+
+#define SAESOC_GEN2_ARC4_KEY_LEN_MASK 0xffULL
+#define SAESOC_GEN2_ARC4_KEY_LEN_SHIFT 44
+
+#define SAESOC_GEN2_HMAC_KEY_LEN_MASK 0x7fULL
+#define SAESOC_GEN2_HMAC_KEY_LEN_SHIFT 37
+
+#define SAESOC_GEN2_HMAC_HW_KEY_PAD_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN2_HMAC_HW_KEY_PAD_ENABLE_SHIFT 36
+
+#define SAESOC_GEN2_HASH_MUTE_MASK_SEL_MASK 0x3ULL
+#define SAESOC_GEN2_HASH_MUTE_MASK_SEL_SHIFT 34
+
+#define SAESOC_GEN2_HASH_MUTE_MASK_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN2_HASH_MUTE_MASK_ENABLE_SHIFT 33
+
+#define SAESOC_GEN2_HASH_SRC_SEL_MASK 0x1ULL
+#define SAESOC_GEN2_HASH_SRC_SEL_SHIFT 32
+
+#define SAESOC_GEN2_HASH_IV_MODE_MASK 0x3ULL
+#define SAESOC_GEN2_HASH_IV_MODE_SHIFT 30
+
+#define SAESOC_GEN2_HASH_TYPE_MASK 0x1fULL
+#define SAESOC_GEN2_HASH_TYPE_SHIFT 25
+
+#define SAESOC_GEN2_HASH_MODE_MASK 0x1fULL
+#define SAESOC_GEN2_HASH_MODE_SHIFT 20
+
+#define SAESOC_GEN2_HASH_IV_OFFSET_MASK 0x3ffULL
+#define SAESOC_GEN2_HASH_IV_OFFSET_SHIFT 10
+
+#define SAESOC_GEN2_AAD_OFFSET_MASK 0x3ffULL
+#define SAESOC_GEN2_AAD_OFFSET_SHIFT 0
+
+/* Control descriptor 1 */
+#define SAESOC_GEN2_CIPHER_PAD_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN2_CIPHER_PAD_ENABLE_SHIFT 56
+
+#define SAESOC_GEN2_CHECK_TAG_ENABLE_MASK 0x1ULL
+#define SAESOC_GEN2_CHECK_TAG_ENABLE_SHIFT 55
+
+#define SAESOC_GEN2_TAG_IN_LOC_SEL_MASK 0x1ULL
+#define SAESOC_GEN2_TAG_IN_LOC_SEL_SHIFT 54
+
+#define SAESOC_GEN2_TAG_OUT_LOC_SEL_MASK 0x1ULL
+#define SAESOC_GEN2_TAG_OUT_LOC_SEL_SHIFT 53
+
+#define SAESOC_GEN2_TAG_LEN_MASK 0x7fULL
+#define SAESOC_GEN2_TAG_LEN_SHIFT 46
+
+#define SAESOC_GEN2_TAGIN_OFFSET_MASK 0x3ffULL
+#define SAESOC_GEN2_TAGIN_OFFSET_SHIFT 36
+
+#define SAESOC_GEN2_CIPHER_ENCRYPT_MASK 0x1ULL
+#define SAESOC_GEN2_CIPHER_ENCRYPT_SHIFT 35
+
+#define SAESOC_GEN2_CFB_MASK_MASK 0x7ULL
+#define SAESOC_GEN2_CFB_MASK_SHIFT 32
+
+#define SAESOC_GEN2_CIPHER_IV_MODE_MASK 0x3ULL
+#define SAESOC_GEN2_CIPHER_IV_MODE_SHIFT 30
+
+#define SAESOC_GEN2_CIPHER_TYPE_MASK 0x1fULL
+#define SAESOC_GEN2_CIPHER_TYPE_SHIFT 25
+
+#define SAESOC_GEN2_CIPHER_MODE_MASK 0x1fULL
+#define SAESOC_GEN2_CIPHER_MODE_SHIFT 20
+
+#define SAESOC_GEN2_CIPHER_IV_OFFSET_MASK 0x3ffULL
+#define SAESOC_GEN2_CIPHER_IV_OFFSET_SHIFT 10
+
+#define SAESOC_GEN2_PAYLOAD_OFFSET_MASK 0x3ffULL
+#define SAESOC_GEN2_PAYLOAD_OFFSET_SHIFT 0
+
+/* Data descriptor 0 */
+
+#define SAESOC_GEN2_PAYLOAD_LEN_MASK 0xffffffffULL
+#define SAESOC_GEN2_PAYLOAD_LEN_SHIFT 32
+
+#define SAESOC_GEN2_CIPHER_PAD_VAL_MASK 0xffULL
+#define SAESOC_GEN2_CIPHER_PAD_VAL_SHIFT 24
+
+#define SAESOC_GEN2_AADLEN_MASK 0xffffffULL
+#define SAESOC_GEN2_AADLEN_SHIFT 0
+
+/* Data descriptor 1*/
+
+#define SAESOC_GEN2_ARC4_SAVE_SATE_EN_MASK 0x1ULL
+#define SAESOC_GEN2_ARC4_SAVE_SATE_EN_SHIFT 62
+
+#define SAESOC_GEN2_PAY_LOAD_BIT_CNT_MASK 0x7ULL
+#define SAESOC_GEN2_PAY_LOAD_BIT_CNT_SHIFT 56
+
+#define SAESOC_GEN2_DESC_FB_DEST_ID_MASK 0xffffULL
+#define SAESOC_GEN2_DESC_FB_DEST_ID_SHIFT 40
+
+#define SAESOC_GEN2_TAG_DEST_ADDR_MASK 0xffffffffffULL
+#define SAESOC_GEN2_TAG_DEST_ADDR_SHIFT 0
+
+/* Data descriptor 2 */
+#define SAESOC_GEN2_FRAG_TYPE_MASK 0x1ULL
+#define SAESOC_GEN2_FRAG_TYPE_SHIFT 63
+
+#define SAESOC_GEN2_WR_FRAG_DIS_MASK 0x1ULL
+#define SAESOC_GEN2_WR_FRAG_DIS_SHIFT 62
+
+#define SAESOC_GEN2_LAST_SRC_DESC_MASK 0x1ULL
+#define SAESOC_GEN2_LAST_SRC_DESC_SHIFT 61
+
+#define SAESOC_GEN2_FRAG_LEN_MASK 0xffffULL
+#define SAESOC_GEN2_FRAG_LEN_SHIFT 40
+
+#define SAESOC_GEN2_FRAG_ADDR_MASK 0xffffffffffULL
+#define SAESOC_GEN2_FRAG_ADDR_SHIFT 0
+
+/* Data descriptor 3 */
+#define SAESOC_GEN2_FB_ENTRY_MASK 0xffffffffffffffffULL
+#define SAESOC_GEN2_FB_ENTRY_SHIFT 0
+
+/* Fmn entry 0 */
+#define SAESOC_GEN2_REG_FB_DEST_ID_MASK 0xffffULL
+#define SAESOC_GEN2_REG_FB_DEST_ID_SHIFT 48
+
+#define SAESOC_GEN2_DESIGN_FB_LEN_MASK 0x3ULL
+#define SAESOC_GEN2_DESIGN_FB_LEN_SHIFT 46
+
+#define SAESOC_GEN2_DESIGN_FB_EN_MASK 0x1ULL
+#define SAESOC_GEN2_DESIGN_FB_EN_SHIFT 45
+
+#define SAESOC_GEN2_CTRL_DESC_LEN_MASK 0x7fULL
+#define SAESOC_GEN2_CTRL_DESC_LEN_SHIFT 34
+
+#define SAESOC_GEN2_CTRL_DESC_ADDR_MASK 0x3ffffffffULL
+#define SAESOC_GEN2_CTRL_DESC_ADDR_SHIFT 0
+
+/* Fmn entry 1 */
+#define SAESOC_GEN2_ARC4_STATE_LD_EN_MASK 0x1ULL
+#define SAESOC_GEN2_ARC4_STATE_LD_EN_SHIFT 63
+
+#define SAESOC_GEN2_PKT_IV_LEN_MASK 0x7ULL
+#define SAESOC_GEN2_PKT_IV_LEN_SHIFT 60
+
+#define SAESOC_GEN2_PKT_DESC_LEN_MASK 0x1fff
+#define SAESOC_GEN2_PKT_DESC_LEN_SHIFT 34
+
+#define SAESOC_GEN2_PKT_DESC_ADDR_MASK 0x3ffffffffULL
+#define SAESOC_GEN2_PKT_DESC_ADDR_SHIFT 0
+
+
+/* Debug routines */
+static char  saesoc_gen2_cipher_type_name[][32] = {
+	"AES_128",
+	"AES_192",
+	"AES_256",
+	"RESERVED",
+	"CAMELLIA_128",
+	"CAMELLIA_192",
+	"CAMELLIA_256",
+	"RESERVED",
+	"BYPASS",
+	"KASUMI",
+	"SNOW3G",
+	"ZUC",
+	"DES",
+	"TDES",
+	"ARC4",
+};
+
+static char  saesoc_gen2_cipher_mode_name[][32] = {
+	"ECB",
+	"CBC",
+	"CFB",
+	"OFB",
+	"CTR",
+	"AES_F8",
+	"LRW",
+	"XTS",
+	"CCM",
+	"GCM"
+};
+static char  saesoc_gen2_hash_type_name[][32] = {
+	"AES_128",
+	"AES_192",
+	"AES_256",
+	"RESERVED",
+	"CAMELLIA_128",
+	"CAMELLIA_192",
+	"CAMELLIA_256",
+	"RESERVED",
+	"BYPASS",
+	"KASUMI",
+	"SNOW3G",
+	"ZUC",
+	"RABIN",
+	"GHASH",
+	"RESERVED",
+	"RESERVED",
+	"MD5",
+	"SHA_1",
+	"SHA_224",
+	"SHA_256",
+	"SHA_384",
+	"SHA_512",
+	"SHA_512/224",
+	"SHA_512/256"
+};
+
+static char  saesoc_gen2_hash_mode_name[][32] = {
+	"CMAC",
+	"CBC",
+	"XCBC",
+	"RESERVED",
+	"HMAC",
+	"RABIN_TERMINATION",
+	"RESERVED",
+	"RESERVED",
+	"CCM",
+	"GCM"
+};
+
+static char saesoc_gen2_ivmode_name[][32] = {
+	"PKT",
+	"PKT_DESC",
+	"RESERVED",
+	"RESERVED"
+};
+
+enum saesoc_gen2_cipher_type {
+    SAESOC_GEN2_CIPHER_TYPE_AES_128 = 0x00,
+	SAESOC_GEN2_CIPHER_TYPE_AES_192 = 0x01,
+	SAESOC_GEN2_CIPHER_TYPE_AES_256 = 0x02,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_GEN2_CIPHER_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_GEN2_CIPHER_BYPASS = 0x08,
+	SAESOC_GEN2_CIPHER_TYPE_KASUMI = 0x09,
+	SAESOC_GEN2_CIPHER_TYPE_SNOW3G = 0x0a,
+	SAESOC_GEN2_CIPHER_TYPE_ZUC = 0x0b,
+	SAESOC_GEN2_CIPHER_TYPE_DES = 0x0c,
+	SAESOC_GEN2_CIPHER_TYPE_TDES = 0x0d,
+	SAESOC_GEN2_CIPHER_TYPE_ARC4 = 0x0e,
+	SAESOC_GEN2_CIPHER_TYPE_MAX
+};
+
+enum saesoc_gen2_hash_type {
+	SAESOC_GEN2_HASH_TYPE_AES_128 = 0x00,
+	SAESOC_GEN2_HASH_TYPE_AES_192 = 0x01,
+	SAESOC_GEN2_HASH_TYPE_AES_256 = 0x02,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_128 = 0x04,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_192 = 0x05,
+	SAESOC_GEN2_HASH_TYPE_CAMELLIA_256 = 0x06,
+	SAESOC_GEN2_HASH_BYPASS = 0x08,
+	SAESOC_GEN2_HASH_TYPE_KASUMI = 0x09,
+	SAESOC_GEN2_HASH_TYPE_SNOW3G = 0x0a,
+	SAESOC_GEN2_HASH_TYPE_ZUC = 0x0b,
+	SAESOC_GEN2_HASH_TYPE_RABIN = 0x0c,
+	SAESOC_GEN2_HASH_TYPE_GHASH = 0x0d,
+	SAESOC_GEN2_HASH_TYPE_MD5 = 0x10,
+	SAESOC_GEN2_HASH_TYPE_SHA_1 = 0x11, 
+	SAESOC_GEN2_HASH_TYPE_SHA_224 = 0x12,
+	SAESOC_GEN2_HASH_TYPE_SHA_256 = 0x13,
+	SAESOC_GEN2_HASH_TYPE_SHA_384 = 0x14,
+	SAESOC_GEN2_HASH_TYPE_SHA_512 = 0x15,
+	SAESOC_GEN2_HASH_TYPE_SHA_512_224 = 0x16,
+	SAESOC_GEN2_HASH_TYPE_SHA_512_256 = 0x17,
+	SAESOC_GEN2_HASH_TYPE_MAX
+};
+
+
+
+/**
+ * saesoc_gen2_dump_cdesc - Extract the control descriptors and dump the
+ * 	 values
+ * @cdescs: Pointer to the control descriptor
+ * @ndescs: Number of descriptors in the list
+ */
+
+static void  saesoc_gen2_dump_cdesc(_uint64_t *cdescs, int ndescs)
+{
+	unsigned int type, mode, ivmode;
+	_uint64_t cdesc0 = cdescs[0];
+	_uint64_t cdesc1 = cdescs[1];
+
+
+	cryptosoc_print("\nCtrl Descriptor info:\n");
+	cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_print("  %-16llx %-16llx \n", cdesc0, cdesc1);
+
+	cryptosoc_print("\nHASH info:\n");
+
+	type = SAESOC_GEN2_GET_BITS(cdesc0, HASH_TYPE);
+	mode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_MODE);
+	ivmode = SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_MODE);
+
+	cryptosoc_print("  %-16s %-16s %-16s \n", 
+			"HashType", "HashMode", "HashIvMode");
+	cryptosoc_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s \n",
+			type, saesoc_gen2_hash_type_name[type], 
+			mode, saesoc_gen2_hash_mode_name[mode], 
+			ivmode, saesoc_gen2_ivmode_name[ivmode]);
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"HashIvOff", "AadOff",  "HashMuteEn", "HashMuteSel");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_IV_OFFSET), 
+			SAESOC_GEN2_GET_BITS(cdesc0, AAD_OFFSET),
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_ENABLE),
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_MUTE_MASK_SEL));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"AddlHashLen","HashSrcSel", "HmacKeyLen", "HmacKeyPad");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc0, ADDL_HASH_LEN),
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_SRC_SEL), 
+			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_KEY_LEN),
+			SAESOC_GEN2_GET_BITS(cdesc0, HMAC_HW_KEY_PAD_ENABLE));
+
+	cryptosoc_print("  %-16s %-16s\n", "HashL3Alloc", "HashClobber");
+	cryptosoc_print("  %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_L3_ALLOCATE), 
+			SAESOC_GEN2_GET_BITS(cdesc0, HASH_CLOBBER));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+			"Chktag", "TaginLoc", "TagoutLoc", "TagLen", "TagInoff");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc1, CHECK_TAG_ENABLE),  
+			SAESOC_GEN2_GET_BITS(cdesc1, TAG_IN_LOC_SEL),
+			SAESOC_GEN2_GET_BITS(cdesc1, TAG_OUT_LOC_SEL), 
+			SAESOC_GEN2_GET_BITS(cdesc1, TAG_LEN),
+			SAESOC_GEN2_GET_BITS(cdesc1, TAGIN_OFFSET));
+
+	cryptosoc_print("\nCIPHER info:\n");
+
+	type = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_TYPE);
+	mode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_MODE);
+	ivmode = SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_MODE);
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"CipherType", "CipherMode", "CipherIvMode", "CipherPadEn");
+	cryptosoc_print("  %-4d%-8s     %-4d%-8s     %-4d%-8s    %-16lld\n",
+			type, saesoc_gen2_cipher_type_name[type], 
+			mode, saesoc_gen2_cipher_mode_name[mode], 
+			ivmode, saesoc_gen2_ivmode_name[ivmode], 
+			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_PAD_ENABLE));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"CipherIvOff", "Encrypt", "Cfbmask", "Arc4Keylen");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_IV_OFFSET),
+			SAESOC_GEN2_GET_BITS(cdesc1, CIPHER_ENCRYPT),
+			SAESOC_GEN2_GET_BITS(cdesc1, CFB_MASK),
+			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_KEY_LEN));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"Arc4L3Alloc", "Pktl3Alloc", "PktClobber", "WrModify");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc0, ARC4_L3_ALLOCATE),	
+			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_L3_ALLOCATE),	
+			SAESOC_GEN2_GET_BITS(cdesc0, DATA_OUT_CLOBBER), 
+			SAESOC_GEN2_GET_BITS(cdesc0, WR_MODI_ONLY_EN));
+
+	cryptosoc_print("\nCOMMON info:\n");
+
+	cryptosoc_print("  %-16s %-16s %-16s\n", 
+			"PayloadOff", "Rabin", "TLS");
+	cryptosoc_print("  %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(cdesc1, PAYLOAD_OFFSET), 
+			SAESOC_GEN2_GET_BITS(cdesc0, RABIN_FINGERPRINT),
+			SAESOC_GEN2_GET_BITS(cdesc0, TLS_ENABLE));
+	
+	if(ndescs > 2) {
+		int i;
+		cryptosoc_print("\nKey info:\n");
+		for(i = 2; i < ndescs; i++)
+			cryptosoc_print("  <%-16llx>", cdescs[i]);
+		cryptosoc_print("\n");
+	}
+}
+
+/**
+ * saesoc_gen2_dump_ddesc - Extract the data descriptors and dump the values
+ * @ddesc: Pointer to the data descriptor array
+ * @ndescs: Number of descriptors present
+ * @hash_iv_mode: Hash iv mode
+ * @cipher_iv_mode: Cipher iv mode
+ * @ndesfb_descs: Number of designer freeback descriptors in the array
+ */
+
+static void saesoc_gen2_dump_ddesc(_uint64_t *ddesc, int ndescs,
+	   	int hash_iv_mode, int cipher_iv_mode, int ndesfb_descs)
+{
+	int nd = 0;
+	 _uint64_t desc0, desc1, desc;
+	int i;
+
+	desc0 = ddesc[nd++];
+	desc1 = ddesc[nd++];
+	cryptosoc_print("\nData Descriptor info:\n");
+	cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+	cryptosoc_print("  %-16llx %-16llx \n", desc0, desc1);
+
+	cryptosoc_print("  %-16s %-16s %-16s\n", 
+			"PayloadLen", "CipherPadVal", "AadLen");
+	cryptosoc_print("  %-16lld %-16lld %-16lld\n",
+			SAESOC_GEN2_GET_BITS(desc0, PAYLOAD_LEN), 
+			SAESOC_GEN2_GET_BITS(desc0, CIPHER_PAD_VAL),
+			SAESOC_GEN2_GET_BITS(desc0, AADLEN));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s\n", 
+			"Arc4SaveState", "PayloadBitCnt", "DesFbDst", "Tagaddr");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx\n",
+			SAESOC_GEN2_GET_BITS(desc1, ARC4_SAVE_SATE_EN), 
+			SAESOC_GEN2_GET_BITS(desc1, PAY_LOAD_BIT_CNT),
+			SAESOC_GEN2_GET_BITS(desc1, DESC_FB_DEST_ID), 
+			SAESOC_GEN2_GET_BITS(desc1, TAG_DEST_ADDR));
+
+	if(hash_iv_mode == 1) {
+		cryptosoc_print("\nHash IV info:\n");
+		cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		nd += 2;
+	}
+
+	if(cipher_iv_mode == 1)  {
+		cryptosoc_print("\nCipher IV info:\n");
+		cryptosoc_print("  %-16s %-16s \n", "Desc0", "Desc1");
+		cryptosoc_print("  %-16llx %-16llx \n", ddesc[nd], ddesc[nd + 1]);
+		nd += 2;
+	}
+
+	for(i = nd; i<ndescs-ndesfb_descs; i++) {	
+		desc = ddesc[i];
+		cryptosoc_print("\nPacket Fragment info (ind %d Entry %llx):\n", i, desc);
+		cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s\n", 
+				"DstFrag", "WriteFragDis", "LastFrag", "FragLen", "FragAddr");
+		cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+				SAESOC_GEN2_GET_BITS(desc, FRAG_TYPE), 
+				SAESOC_GEN2_GET_BITS(desc, WR_FRAG_DIS),
+				SAESOC_GEN2_GET_BITS(desc, LAST_SRC_DESC), 
+				SAESOC_GEN2_GET_BITS(desc, FRAG_LEN),
+				SAESOC_GEN2_GET_BITS(desc, FRAG_ADDR));
+	}
+	if(ndesfb_descs) {
+		cryptosoc_print("\nDesigner Fb descs:\n");
+		for(; (i < ndescs); i++) 
+			cryptosoc_print("  %-16llx", ddesc[i]);
+		cryptosoc_print("\n");
+	}
+	cryptosoc_print("\n");
+}
+
+/**
+ * saesoc_gen2_dump_fmnentry - Extract the fmn messages and dump the values
+ * @entry0: fmn entry0 message
+ * @entry1: fmn entry1 message
+ */
+
+static inline void saesoc_gen2_dump_fmnentry(_uint64_t entry0, _uint64_t entry1) 
+{
+	cryptosoc_print("\nFmn Info entry0 %llx entry1 %llx\n",entry0, entry1);
+	cryptosoc_print("  %-16s %-16s %-16s %-16s %-16s \n", 
+			"RegFb","DesFbEn", "DesFbLen", "CtrlDescLen", "CtrlDescAddr");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16lld %-16llx\n",
+			SAESOC_GEN2_GET_BITS(entry0, REG_FB_DEST_ID), 
+			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_EN),
+			SAESOC_GEN2_GET_BITS(entry0, DESIGN_FB_LEN), 
+			SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_LEN),
+			(SAESOC_GEN2_GET_BITS(entry0, CTRL_DESC_ADDR) << 
+			 		CRYPTOSOC_CACHELINE_SHIFT));
+
+	cryptosoc_print("  %-16s %-16s %-16s %-16s \n", 
+			"Arc4StateLdEn", "PktIvLenDW", "PktDescLen", "PktDescAddr");
+	cryptosoc_print("  %-16lld %-16lld %-16lld %-16llx \n",
+			SAESOC_GEN2_GET_BITS(entry1, ARC4_STATE_LD_EN), 
+			SAESOC_GEN2_GET_BITS(entry1, PKT_IV_LEN),
+			SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_LEN), 
+			(SAESOC_GEN2_GET_BITS(entry1, PKT_DESC_ADDR) << 
+			 CRYPTOSOC_CACHELINE_SHIFT));
+
+}
+
+
+/**
+ * saesoc_gen2_set_hash_type_mode_offset - Set the control descriptor with 
+ * 	Hash parameters
+ * @cdesc0        : ctrl Descriptor 0 
+ * @type      : refer saesoc_gen2_hash_type
+ * @mode      : refer saesoc_gen2_hash_mode
+ * @hmac_key_len    : Hmac key len in bytes, 0 means 256 bytes
+ * @src_sel    : Hash input is cipher output(1).
+ *                  Hash input is packet data(0).
+ * @iv_offset : bytes offset from start of the packet
+ *                  Ignored if the ivmode is from packet descriptor
+ * @aad_offset    : bytes offset from start of the packet
+ * @iv_mode    : Use unaltered IV from packet source(00)
+ *                  Use unaltered IV from packet descriptor(01) 
+ * @hmac_key_pad_en: Engine does/doesnot the XOR with ipad/opad
+ *                  if set HmacKeyLen is ignored
+ *
+ * Ctrl Descriptor parameter bits corresponding to hash params are cleared 
+ * and is set with the new values.If HmacHwKeyPadEn is set HmacKeyLen is 
+ * ignored and s/w must pad the hmac key to 128B (MD5/SHA1/SHA224/SHA256) 
+ * or 256B of key (SHA-384/SHA-512/SHA-512-224/SHA-512-256).
+ *
+ */
+
+#define saesoc_gen2_set_hash_type_mode_offset( cdesc0, type, mode,	\
+	hmac_key_len, src_sel, iv_offset, aad_offset, iv_mode,	\
+		hmac_key_pad_en){ 					\
+	_uint64_t mask = (SAESOC_GEN2_SET_MASK(HASH_TYPE) | 		\
+			SAESOC_GEN2_SET_MASK(HASH_MODE) | 		\
+			SAESOC_GEN2_SET_MASK(HMAC_KEY_LEN) | 		\
+			SAESOC_GEN2_SET_MASK(HASH_SRC_SEL) |		\
+			SAESOC_GEN2_SET_MASK(HASH_IV_OFFSET) | 	\
+			SAESOC_GEN2_SET_MASK(AAD_OFFSET) | 		\
+			SAESOC_GEN2_SET_MASK(HASH_IV_MODE) | 		\
+			SAESOC_GEN2_SET_MASK(HMAC_HW_KEY_PAD_ENABLE));\
+	cdesc0 = cdesc0 & ~mask; 					\
+	cdesc0 = cdesc0 | SAESOC_GEN2_SET_BITS(type,HASH_TYPE) | 	\
+		SAESOC_GEN2_SET_BITS(mode, HASH_MODE) |		\
+		SAESOC_GEN2_SET_BITS(hmac_key_len, HMAC_KEY_LEN)|	\
+		SAESOC_GEN2_SET_BITS(src_sel, HASH_SRC_SEL) | 	\
+		SAESOC_GEN2_SET_BITS(iv_offset, HASH_IV_OFFSET) | \
+		SAESOC_GEN2_SET_BITS(aad_offset, AAD_OFFSET) | 	\
+		SAESOC_GEN2_SET_BITS(iv_mode, HASH_IV_MODE) | 	\
+	SAESOC_GEN2_SET_BITS(hmac_key_pad_en, HMAC_HW_KEY_PAD_ENABLE);	\
+	}
+
+/**
+ * saesoc_gen2_set_cipher_type_mode_offset - Set the control descriptor with 
+ * 	Cipher parameters
+ * @cdesc1         : ctrl Descriptor 1
+ * @encrypt        : Encrypt(1)/Decrypt(0)
+ * @type	   : refer saesoc_gen2_cipher_type
+ * @mode     : refer saesoc_gen2_cipher_mode
+ * @iv_offset : Byte offset from start of packet.
+ *                   Ignored if the ivmode is from packet descriptor
+ * @iv_mode   : Use unaltered IV from packet descriptor(01)
+ *                   Use unaltered IV from packet source(00) 
+ *
+ * Ctrl Descriptor parameter bits corresponding Encrypt,CipherType,CipherMode, 
+ * CipherIvOffset, cipherIvMode are cleared and sets with the new values.
+ */
+#define saesoc_gen2_set_cipher_type_mode_offset( cdesc1, encrypt, type,\
+		mode, iv_offset, iv_mode){		\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_ENCRYPT) | 	\
+			SAESOC_GEN2_SET_MASK(CIPHER_TYPE) |		\
+			SAESOC_GEN2_SET_MASK(CIPHER_MODE) | 		\
+			SAESOC_GEN2_SET_MASK(CIPHER_IV_OFFSET) |  	\
+			SAESOC_GEN2_SET_MASK(CIPHER_IV_MODE);		\
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 |SAESOC_GEN2_SET_BITS(encrypt,CIPHER_ENCRYPT)|\
+	    SAESOC_GEN2_SET_BITS(type, CIPHER_TYPE) | 		\
+	    SAESOC_GEN2_SET_BITS(mode, CIPHER_MODE) |		\
+	    SAESOC_GEN2_SET_BITS(iv_offset, CIPHER_IV_OFFSET) |	\
+	    SAESOC_GEN2_SET_BITS(iv_mode, CIPHER_IV_MODE);	\
+	}
+
+/**
+ * saesoc_gen2_set_hash_bypass - Set the control descriptor with 
+ * 	Hash bypass
+ * @cdesc0        : ctrl Descriptor 0 
+ */
+#define saesoc_gen2_set_hash_bypass(cdesc0) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(HASH_TYPE); \
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | SAESOC_GEN2_SET_BITS(SAESOC_GEN2_HASH_BYPASS, HASH_TYPE); \
+}
+
+/**
+ * saesoc_gen2_set_cipher_bypass - Set the control descriptor with 
+ *  Cipher bypass
+ * @cdesc0        : ctrl Descriptor 0 
+ */
+#define saesoc_gen2_set_cipher_bypass(cdesc1) {	\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_TYPE); \
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | SAESOC_GEN2_SET_BITS(SAESOC_GEN2_CIPHER_BYPASS, CIPHER_TYPE); \
+}
+
+/**
+ * saesoc_gen2_set_arc4_param - Set the control descriptor with ARC4 
+ * 	parameters
+ * @cdesc0         	: ctrl Descriptor 0 
+ * @arc4_state_l3_allocate : Enable/Disable L3 allocation for packet write 
+ * @key_len     	: ARC4 Key Length in bytes , 0 means 256 bytes
+ *
+ * ctrl Descriptor param bits corresponding to arc4StateL3Allocate
+ * and arc4KeyLen are cleared and is set with the new values.
+ */
+#define saesoc_gen2_set_arc4_param( cdesc0, arc4_state_l3_allocate, key_len){\
+	_uint64_t mask = (SAESOC_GEN2_SET_MASK(ARC4_L3_ALLOCATE) |	\
+			SAESOC_GEN2_SET_MASK(ARC4_KEY_LEN)); 		\
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | 						\
+	 SAESOC_GEN2_SET_BITS(arc4_state_l3_allocate, ARC4_L3_ALLOCATE) |\
+		SAESOC_GEN2_SET_BITS(key_len, ARC4_KEY_LEN);	\
+}
+
+/**
+ * saesoc_gen2_set_cfbmask - Set the control descriptor with cfbmask parameter
+ * @cdesc1         : ctrl Descriptor 1
+ * @cfbmask	   : 111 Select 128 bits of CipherText for feedback.
+ *		     110 Select 64 bits of CipherText for feedback.
+ *                   101 Select 32 bits of CipherText for feedback.
+ *                   100 Select 16 bits of CipherText for feedback.
+ *                   011 Select 8 bits of CipherText for feedback.
+ *                   010 Select 4 bits of CipherText for feedback.
+ *                   001 Select 2 bits of CipherText for feedback.
+ *                   000 Select 1 bit of CipherText for feedback.
+ * 
+ * sets the bits of ciphertext for feedback in the ctrl descriptor.
+ */
+
+#define saesoc_gen2_set_cfbmask( cdesc1, cfbmask) {				\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CFB_MASK);		\
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | SAESOC_GEN2_SET_BITS(cfbmask,CFB_MASK);		\
+	}
+
+/**
+ * saesoc_gen2_set_tls - Set the control descriptor with TLS parameters
+ * @cdesc0             : ctrl Descriptor 0
+ * @tls_enable       : Enable/Disable Tls 
+ *
+ * Ctrl Descriptor param bits corresponding to TlsEnable are cleared 
+ * and is set with the new values.
+ */
+#define saesoc_gen2_set_tls(cdesc0, tls_enable) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(TLS_ENABLE);	\
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | SAESOC_GEN2_SET_BITS(tls_enable,TLS_ENABLE);	\
+	}
+
+/**
+ * saesoc_gen2_set_l3param - Set the control descriptor with L3 cache 
+ * 	parameters
+ * @cdesc0         : ctrl Descriptor 0 
+ * @data_out_l3_alloc : Enable/Disable L3 allocation for data write 
+ * @data_out_clobber : Enable/Disable Clobber cacheline on data write
+ * @wr_modify_only_en : Enable/Disable  Only write the portion of the 
+ *                   data that has been modified
+ * @hash_l3_allocate : Enable/Disable L3 allocation for tag write   
+ *                   TagLocSel == EndOfPayload
+ * @hash_clobber    : Enable/Disable Clobber cacheline on tag write
+ *
+ * ctrl Descriptor l3 param bits corresponding to L3Allocate,Clobber, 
+ * WrModifyOnlyEn, HashL3Allocate, HashClobber are cleared and is set 
+ * with the new values.
+ */
+#define saesoc_gen2_set_l3param(cdesc0, data_out_l3_alloc, data_out_clobber,		\
+		wr_modify_only_en, hash_l3_allocate, hash_clobber) {	\
+	_uint64_t mask = (SAESOC_GEN2_SET_MASK(DATA_OUT_L3_ALLOCATE) | 	\
+			SAESOC_GEN2_SET_MASK(DATA_OUT_CLOBBER)	 |	\
+			SAESOC_GEN2_SET_MASK(WR_MODI_ONLY_EN) | 	\
+			SAESOC_GEN2_SET_MASK(HASH_L3_ALLOCATE) | 	\
+			SAESOC_GEN2_SET_MASK(HASH_CLOBBER));	\
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | 						\
+		SAESOC_GEN2_SET_BITS(data_out_l3_alloc, DATA_OUT_L3_ALLOCATE)|	\
+		SAESOC_GEN2_SET_BITS(data_out_clobber, DATA_OUT_CLOBBER) |	\
+		SAESOC_GEN2_SET_BITS(wr_modify_only_en, WR_MODI_ONLY_EN)|\
+		SAESOC_GEN2_SET_BITS(hash_l3_allocate, HASH_L3_ALLOCATE)|\
+		SAESOC_GEN2_SET_BITS(hash_clobber, HASH_CLOBBER); 	\
+	}
+
+/**
+ * saesoc_gen2_set_hash_mutemask - Set the control descriptor with 
+ * 	Hash Mute Mask parameters
+ * @cdesc0         	: ctrl Descriptor 0 
+ * @hash_mute_mask_sel  : which mutable mask register to read
+ * @hash_mute_mask_en   : Enable/Disable selected mutable mask to packet data  
+ *                     starting at AadOffset
+ *
+ * Ctrl Descriptor param bits corresponding to HashMuteMaskSel and 
+ * HashMuteMaskEn are cleared and is set with the new values.
+ */
+#define saesoc_gen2_set_hash_mutemask( cdesc0, hash_mute_mask_sel, 		\
+			hash_mute_mask_en) {				\
+	_uint64_t mask = (SAESOC_GEN2_SET_MASK(HASH_MUTE_MASK_SEL) | 	\
+			 SAESOC_GEN2_SET_MASK(HASH_MUTE_MASK_ENABLE));\
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | 						\
+	  SAESOC_GEN2_SET_BITS(hash_mute_mask_sel, HASH_MUTE_MASK_SEL) |	\
+	  SAESOC_GEN2_SET_BITS(hash_mute_mask_en, HASH_MUTE_MASK_ENABLE);\
+	}
+
+
+/**
+ * saesoc_gen2_set_hash_addllen - Set the control descriptor with 
+ * 	Additional Hash Length parameter
+ * @cdesc0             : ctrl Descriptor 0 
+ * @addl_hash_len        : Number of bytes after the Payload to authenticate.
+ *
+ * Ctrl Descriptor param bits corresponding to Hash Length is cleared and
+ * is set with the new values.The value indicates the actual number of 
+ * bytes. 
+ */
+#define saesoc_gen2_set_hash_addllen(cdesc0, addl_hash_len) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(ADDL_HASH_LEN) ; 	\
+	cdesc0 = cdesc0 & ~mask;					\
+	cdesc0 = cdesc0 | 						\
+		SAESOC_GEN2_SET_BITS(addl_hash_len, ADDL_HASH_LEN) ;	\
+	}								
+	
+/**
+ * saesoc_gen2_set_rabinfnprint - Set the control descriptor with 
+ * 	Rabin Finger Print parameter 
+ * @cdesc0             : ctrl Descriptor 0
+ * @rabin_fprint_out_en   : Enable/Disable Rabin Finger Print output alogn 
+ * 	with chunksize and hash
+ *
+ * Ctrl Descriptor param bits corresponding to RabinFprintOutEn is 
+ * is cleared and is set with the new values. 
+ */
+#define saesoc_gen2_set_rabinfnprint(cdesc0, rabin_fprint_out_en) {		\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(RABIN_FINGERPRINT);	\
+	cdesc0 = cdesc0 & ~mask; 					\
+	cdesc0 = cdesc0 | 						\
+	SAESOC_GEN2_SET_BITS(rabin_fprint_out_en, RABIN_FINGERPRINT);	\
+	}
+
+/**
+ * saesoc_gen2_set_payload_offset - Set the control descriptor with 
+ * 	payload offset parameter
+ * @cdesc1         : ctrl Descriptor 1
+ * @payload_offset  : Byte offset of the payload from start of packet.
+ *
+ * Sets Byte offset of the payload from start of packet. Used by both 
+ * hash and cipher operations.
+ */
+#define saesoc_gen2_set_payload_offset( cdesc1, payload_offset) {		\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(PAYLOAD_OFFSET);	\
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | 						\
+	SAESOC_GEN2_SET_BITS(payload_offset, PAYLOAD_OFFSET);		\
+	}
+
+/** 
+ * saesoc_gen2_set_tag_offset_len - Set the control descriptor with 
+ * 	ICV parameters
+ * @cdesc1         : ctrl Descriptor 1
+ * @chk_tag_en       : Enable/Disbale Tag Check
+ * @tag_in_loc_sel    : End of payload(1), TagOffset(0)
+ * @tag_out_loc_sel   : End of payload(1), TagDstAddr(0)
+ * @tag_in_offset     : Byte offset of expected tag from start of packet.
+ *                   Ignored if ChkTagEn == 0 or TagInLocSel == 1.
+ * @tag_len	   : Tag length in bytes. TagLength must be less than the 
+ *                   maximum tag length allowed by the selected hash 
+ *                   type/mode.
+ *
+ * Enables the tag checking to be done on the in bound traffic. The tag  
+ * can be at the end of payload or at a specific offset.
+ */
+#define saesoc_gen2_set_tag_offset_len(cdesc1, chk_tag_en, tag_in_loc_sel,	\
+			tag_out_loc_sel, tag_in_offset, tag_len) {					\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(CHECK_TAG_ENABLE) | 	\
+			SAESOC_GEN2_SET_MASK(TAG_IN_LOC_SEL) | 	\
+			SAESOC_GEN2_SET_MASK(TAG_OUT_LOC_SEL) | 	\
+			SAESOC_GEN2_SET_MASK(TAGIN_OFFSET)	|	\
+			SAESOC_GEN2_SET_MASK(TAG_LEN);	\
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | 						\
+		SAESOC_GEN2_SET_BITS(chk_tag_en, CHECK_TAG_ENABLE) |	\
+		SAESOC_GEN2_SET_BITS(tag_in_loc_sel, TAG_IN_LOC_SEL) |	\
+		SAESOC_GEN2_SET_BITS(tag_out_loc_sel, TAG_OUT_LOC_SEL) |	\
+		SAESOC_GEN2_SET_BITS(tag_in_offset, TAGIN_OFFSET) |		\
+		SAESOC_GEN2_SET_BITS(tag_len, TAG_LEN);	\
+	}
+	
+/**
+ * saesoc_gen2_enable_cipher_pad - Set the control descriptor with 
+ * 	Cipher Pad parameter.
+ * @cdesc1         : ctrl Descriptor 1
+ * @cipher_pad_en	   : Enable/Diable Padding
+ *                   
+ * This should only be set for TLS packets or IPsec packets.
+ */
+#define saesoc_gen2_enable_cipher_pad( cdesc1, cipher_pad_en) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_PAD_ENABLE);	\
+	cdesc1 = cdesc1 & ~mask;					\
+	cdesc1 = cdesc1 | 						\
+		SAESOC_GEN2_SET_BITS(cipher_pad_en, CIPHER_PAD_ENABLE);	\
+	}
+
+/**
+ * saesoc_gen2_set_payload_len -  Set the data descriptor with 
+ * 	Payload Length parameter
+ * @ddesc0    : Data Descriptor 0
+ * @payload_len: Length of the payload field of the packet.
+ *              A value of 0 indicates no payload.
+ * 
+ * sets the payload length in bytes.
+ */
+#define saesoc_gen2_set_payload_len( ddesc0, payload_len) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(PAYLOAD_LEN);		\
+	ddesc0 = ddesc0 & ~mask;					\
+	ddesc0 = ddesc0 |SAESOC_GEN2_SET_BITS(payload_len,PAYLOAD_LEN);\
+	}
+
+/**
+ * saesoc_gen2_set_cipher_padval - Set the data descriptor with 
+ * 	Cipher pad value parameter
+ * @ddesc0    : Data Descriptor 0
+ * @cipher_pad_val: If TlsEn == 0 and Encrypt == 1, CiphPadVal is the 
+ *		final byte of the padding. Otherwise, CiphPadVal is the 
+ *		padding length.
+ *
+ * sets the cipher pad value.
+ */
+#define saesoc_gen2_set_cipher_padval( ddesc0, cipher_pad_val) {		\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(CIPHER_PAD_VAL);	\
+	ddesc0 = ddesc0 & ~mask;					\
+	ddesc0=ddesc0|SAESOC_GEN2_SET_BITS(cipher_pad_val,CIPHER_PAD_VAL);\
+	}
+
+/**
+ * saesoc_gen2_set_aadlen - Set the data descriptor with Aad Length parameter
+ * @ddesc0    : Data Descriptor 0
+ * @aad_len    : Length of additionally authenticated data (AAD) in bytes,
+ *              A value of 0 indicates no AAD.
+ * 
+ * sets the dditionally authenticated data length in bytes.
+ */
+#define saesoc_gen2_set_aadlen( ddesc0, aad_len) {				\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(AADLEN);		\
+	ddesc0 = ddesc0 & ~mask;					\
+	ddesc0 = ddesc0 | SAESOC_GEN2_SET_BITS(aad_len, AADLEN);	\
+	}
+
+/**
+ * saesoc_gen2_set_arc4_savestate - Set the data descriptor with ARC4 save 
+ * 	state parameter
+ * @ddesc1        : Data Descriptor 1 
+ * @arc4_save_state : do/donot write ARC4 State to memory when packet
+ *                   complete.
+ *
+ * Applicable only for arc4.
+ */
+#define saesoc_gen2_set_arc4_savestate(ddesc1, arc4_save_state) {			\
+	 _uint64_t mask = SAESOC_GEN2_SET_MASK(ARC4_SAVE_SATE_EN);	\
+	ddesc1 = ddesc1 & ~mask;					\
+	ddesc1 = ddesc1 | 						\
+	SAESOC_GEN2_SET_BITS(arc4_save_state, ARC4_SAVE_SATE_EN);	\
+	}
+
+
+/**
+ * saesoc_gen2_set_payload_bitcnt - Set the data descriptor with 
+ * 	Payload bit count parameter 
+ * @ddesc1        : Data Descriptor 1
+ * @payload_bitcnt  : 111 for 7 bits , 110 for 6 bits and so on.
+ *                  0 for 8 bits.
+ * 
+ * set the number of bit in the last bytes of payload. 0 stands for 
+ * full byte.
+ */
+#define saesoc_gen2_set_payload_bitcnt( ddesc1, payload_bitcnt){		\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(PAY_LOAD_BIT_CNT);	\
+	ddesc1 = ddesc1 & ~mask; 					\
+	ddesc1 = ddesc1 | 						\
+		SAESOC_GEN2_SET_BITS(payload_bitcnt, PAY_LOAD_BIT_CNT);\
+	}
+
+/**
+ * saesoc_gen2_set_desfb - Set the data descriptor with 
+ * 	Designer Freeback parameter
+ * @ddesc1        : Data Descriptor 1
+ * @desfb_dst_id   : Message station ID of designer freeback destination. 
+ *
+ * If an error occurs in the packet, the freeback message is sent to the 
+ * regular freeback destination instead of the designer 
+ * freeback destination. 
+ */
+#define saesoc_gen2_set_desfb( ddesc1, desfb_dst_id) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(DESC_FB_DEST_ID);	\
+	ddesc1 = ddesc1 & ~mask; 					\
+	ddesc1 = ddesc1 | 						\
+		SAESOC_GEN2_SET_BITS(desfb_dst_id, DESC_FB_DEST_ID);	\
+	}
+
+/**
+ * saesoc_gen2_set_tag_dstaddr - Set the data descriptor with Tag 
+ * 	Destination address
+ * @ddesc1        : Data Descriptor 1
+ * @tag_dst_addr    : Byte aligned address in memory to write the tag.
+ *                  Ignored if TagOutLocSel == 1.
+ *
+ * Sets the byte aligned tag address.
+ */
+#define saesoc_gen2_set_tag_dstaddr( ddesc1, tag_dst_addr) {			\
+	_uint64_t mask = SAESOC_GEN2_SET_MASK(TAG_DEST_ADDR);		\
+	ddesc1 = ddesc1 & ~mask; 					\
+	ddesc1 = ddesc1 | 						\
+		SAESOC_GEN2_SET_BITS(tag_dst_addr, TAG_DEST_ADDR);	\
+	}
+
+/**
+ * saesoc_gen2_set_src_frag - Generates the source fragment descriptor.
+ * @src_frag_desc        : Data source fragment descriptor(output).  
+ * @last_frag    : Set 1/0 depending on the current fragment is the last frament
+ * @frag_len      : length in bytes of the sources fragments
+ * @frag_addr     : byte-aligned source address
+ *
+ * Generates the source fragment descriptor from the specified parameter.
+ */
+#define saesoc_gen2_set_src_frag(src_frag_desc, last_frag, frag_len , \
+		frag_addr) {	\
+	src_frag_desc = SAESOC_GEN2_SET_BITS(last_frag, LAST_SRC_DESC) |	\
+		 SAESOC_GEN2_SET_BITS(frag_len, FRAG_LEN) | 		\
+		SAESOC_GEN2_SET_BITS(frag_addr, FRAG_ADDR);		\
+	}
+	
+/**
+ * saesoc_gen2_set_dst_frag - Generates the destination fragment descriptor
+ * @dst_frag_desc       : Data destination fragment descriptor(output)
+ * @last_frag  : Set 1/0 depending on the current fragment is the last frament
+ * @frag_len      : length in bytes of the sources fragments
+ * @frag_addr     : byte-aligned source address
+ * @wr_frag_dis    : Yes/No. Write Fragment Disable. 
+ *
+ * Generates the destination fragment descriptor from the specified parameters.
+ */
+#define saesoc_gen2_set_dst_frag(dst_frag_desc, last_frag, frag_len , 		\
+		frag_addr, wr_frag_dis) {					\
+	dst_frag_desc = SAESOC_GEN2_SET_BITS(1, FRAG_TYPE) | 			\
+		SAESOC_GEN2_SET_BITS(wr_frag_dis, WR_FRAG_DIS) |	\
+		SAESOC_GEN2_SET_BITS(last_frag, LAST_SRC_DESC) |	\
+		SAESOC_GEN2_SET_BITS(frag_len, FRAG_LEN) | 		\
+		SAESOC_GEN2_SET_BITS(frag_addr, FRAG_ADDR);		\
+	}
+
+/**
+* saesoc_gen2_set_last_frag - Set the last source/destination fragment bit
+* @frag_desc : Source or Destination fragment descriptor
+*/
+#define saesoc_gen2_set_last_frag(frag_desc) \
+		frag_desc |= SAESOC_GEN2_SET_BITS(1, LAST_SRC_DESC);
+
+/**
+* saesoc_gen2_disble_wrfrag -  Set the fragment write disable bit
+* @dst_frag_desc : Data destination fragment descriptor
+*/
+#define saesoc_gen2_disble_wrfrag(dst_frag_desc) \
+		dst_frag_desc |= SAESOC_GEN2_SET_BITS(1, WR_FRAG_DIS);
+
+
+/**
+ * saesoc_gen2_form_fmn_entry0 - Forms fmn entry0 with regular/designer freeback
+ * @reg_fb_dst_id: Regular Freeback Destination ID. 
+ * 	 Station Id for error freebacks when Designer fb is enabled.
+ * @des_fb_len_in_dw: Number of designer freeback entries , 0 means 4
+ * @des_fb_en :  Enable designer freeback
+ * @ctrl_desc_len_in_dw: Control Descriptor Length in doublewords. 0 means 128.
+ * @ctrl_desc_addr: Cacheline aligned address of the control descriptor. 
+ *
+ * Return      :   filled fmn entry 0
+ *
+ */
+static inline _uint64_t  saesoc_gen2_form_fmn_entry0(
+   unsigned int reg_fb_dst_id, unsigned int des_fb_len_in_dw, 
+   unsigned int des_fb_en, unsigned int ctrl_desc_len_in_dw,
+	 _uint64_t ctrl_desc_addr) 
+{
+	
+	return (SAESOC_GEN2_SET_BITS(reg_fb_dst_id, REG_FB_DEST_ID) | 
+		SAESOC_GEN2_SET_BITS(des_fb_len_in_dw, DESIGN_FB_LEN) | 
+		SAESOC_GEN2_SET_BITS(des_fb_en, DESIGN_FB_EN) |
+		SAESOC_GEN2_SET_BITS(ctrl_desc_len_in_dw, CTRL_DESC_LEN) |
+		SAESOC_GEN2_SET_BITS(ctrl_desc_addr, CTRL_DESC_ADDR));
+} 
+
+/**
+ * saesoc_gen2_form_fmn_entry1 - Forms the fmn entry1
+ * @arc4_load_state: Load the ARC4 state before the operation
+ * @pkt_iv_len_in_dw : length of the IV in doublewords.
+ * @pkt_desc_len_in_dw : packet Descriptor Length in doublewords.0 means 8192.
+ * @pkt_desc_addr: Cacheline aligned address of packet descriptor. 
+ *
+ * Return : filled fmn entry 1 
+ * 
+ */
+static inline _uint64_t  saesoc_gen2_form_fmn_entry1( 
+		unsigned int arc4_load_state, _uint64_t pkt_iv_len_in_dw,
+        _uint64_t pkt_desc_len_in_dw, _uint64_t pkt_desc_addr)  
+{
+	return(	SAESOC_GEN2_SET_BITS(arc4_load_state, ARC4_STATE_LD_EN) |
+			SAESOC_GEN2_SET_BITS(pkt_iv_len_in_dw, PKT_IV_LEN) | 
+			SAESOC_GEN2_SET_BITS(pkt_desc_len_in_dw, PKT_DESC_LEN) |
+			SAESOC_GEN2_SET_BITS(pkt_desc_addr, PKT_DESC_ADDR));
+}
+
+#endif //GEN2_SUPPORT
+#endif
diff --git a/arch/mips/netlogic/lib/seclib/saesoc_lib.h b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
new file mode 100644
index 0000000..bc77cfe
--- /dev/null
+++ b/arch/mips/netlogic/lib/seclib/saesoc_lib.h
@@ -0,0 +1,1949 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifndef _SAESOC_LIB_H
+#define _SAESOC_LIB_H
+
+/* Include file for application specific macros */
+#include "cryptosoc_lib.h"
+#include "cryptosoc_lib_ifc.h"
+#include "cryptosoc_ctx.h"
+
+#ifdef SAESOC_PTYPE_GEN_ALL_SUPPORT
+#define SAESOC_PTYPE_GEN2_SUPPORT
+#define SAESOC_PTYPE_GEN1_SUPPORT
+#endif
+
+#include "saesoc_defs.h"
+
+/* Include file for processor specific macros to set the descriptors. 
+*  hal macros should be after _ifc.h(Because of -GEN2- en/dis */
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+#include "saesoc_gen2_hal_defs.h"
+#endif
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+#include "saesoc_gen1_hal_defs.h"
+#endif
+
+
+#ifdef SAESOC_PTYPE_GEN_ALL_SUPPORT
+#define IF_SAESOC_PTYPE_IS_GEN1 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN1)
+#define IF_SAESOC_PTYPE_IS_GEN2 if(cryptosoc_ptype_gen == CRYPTOSOC_PTYPE_IS_GEN2)
+#else
+#define IF_SAESOC_PTYPE_IS_GEN1
+#define IF_SAESOC_PTYPE_IS_GEN2 
+#endif
+
+#include "nlm_hal_fmn.h"
+
+/**
+* DOC: SAESOC
+*
+* These APIs abstract the SAE SOC present in the processor.
+*
+* The below macros should be defined by the application. 
+* 
+* SAESOC_SESSION_DESC_APP_PRIV_SZ:
+*   Application private data size in the session descriptor. Should be 
+*   multiple of cachelines.
+*
+* SAESOC_DATA_DESC_APP_PRIV_SZ:
+*   Application private data size in the data descriptor. Should be 
+*   multiple of cachelines.
+*
+* Processor type : Either SAESOC_PTYPE_GEN_ALL_SUPPORT or 
+*  SAESOC_PTYPE_GEN2_SUPPORT/SAESOC_PTYPE_GEN1_SUPPORT
+*/
+
+/* local session, data private info. The structure size 
+*  should be below the PRIV_SZ macros. */
+struct saesoc_sdesc_priv_data {
+	int cipher_key_len_in_dw; /* valid for gen1 only */
+	int hash_key_len_in_dw; /* valid for gen1 only */
+	int cipher_iv_descs; /* only if iv is taken from pkt desc(valid for gen2 only) */
+	int hash_iv_descs; /* only if iv is taken from pkt desc(valid for gen2 only) */
+	int cipher_en;
+	int hash_en;
+	int ldesc; /* last session descriptor index */
+	/* data descriptor starting fragment index - 
+	*  based on the ivdescs count */
+	int frag_idx;
+	int addl_hash_len;
+	_uint64_t ddesc[6]; /* valid for gen1 only */
+};
+
+#define SAESOC_SESSION_DESC_LIB_PRIV_SZ \
+	(((sizeof(struct saesoc_sdesc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+		CRYPTOSOC_CACHELINE_SZ)
+
+
+struct saesoc_ddesc_priv_data {
+	struct saesoc_session_desc *sdesc;
+	/* current src and dstfrag free index */
+	int lsrc_frag_idx;  /* last source fragment index */
+	int ldst_frag_idx; /* last destination fragment index */
+	int nfrag_idx; /* next available fragment index, this can be source or destination */
+	int max_descs;
+	int aad_len;
+	int ndesfb_descs;
+};
+
+#define SAESOC_DATA_DESC_LIB_PRIV_SZ \
+	 (((sizeof(struct saesoc_ddesc_priv_data) / CRYPTOSOC_CACHELINE_SZ) + 1) * \
+	          CRYPTOSOC_CACHELINE_SZ)
+
+#define saesoc_get_cacheline_phys_addr(x) \
+	(cryptosoc_virt_to_phys((_uint64_t)(unsigned long)x) >> CRYPTOSOC_CACHELINE_SHIFT)
+
+
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+/* saesoc_gen1_cipher_table_map for generation 1 chip sets */
+static int saesoc_gen1_cipher_table_map[SAESOC_CIPHER_TYPE_MAX+1] = {
+	[SAESOC_CIPHER_TYPE_AES_128] = 0x3,
+	[SAESOC_CIPHER_TYPE_AES_192] = 0x4,
+	[SAESOC_CIPHER_TYPE_AES_256] = 0x5,
+	[SAESOC_CIPHER_TYPE_CAMELLIA_128] = 0x9,
+	[SAESOC_CIPHER_TYPE_CAMELLIA_192] = 0xa,
+	[SAESOC_CIPHER_TYPE_CAMELLIA_256] = 0xb,
+	[SAESOC_CIPHER_BYPASS] = 0x0,
+	[SAESOC_CIPHER_TYPE_KASUMI] = 0x7,
+	[SAESOC_CIPHER_TYPE_SNOW3G] = 0x8,
+	[SAESOC_CIPHER_TYPE_ZUC] =0xd,
+	[SAESOC_CIPHER_TYPE_DES] =0x1,
+	[SAESOC_CIPHER_TYPE_TDES] = 0x2,
+	[SAESOC_CIPHER_TYPE_ARC4] = 0x6,
+	[SAESOC_CIPHER_TYPE_MAX] = 0xf
+};
+
+/* saesoc_gen1_cipher_mode_map for generation 1 chip sets */
+static int saesoc_gen1_cipher_mode_map[SAESOC_CIPHER_MODE_MAX+1] ={
+	[SAESOC_CIPHER_MODE_ECB] = 0x0,
+	[SAESOC_CIPHER_MODE_CBC] = 0x1,
+	[SAESOC_CIPHER_MODE_CFB] = 0x2,
+	[SAESOC_CIPHER_MODE_OFB] = 0x3,
+	[SAESOC_CIPHER_MODE_CTR] = 0x4,
+	[SAESOC_CIPHER_MODE_AES_F8] = 0x5,
+	[SAESOC_CIPHER_MODE_LRW] = 0xa,
+	[SAESOC_CIPHER_MODE_XTS] = 0xb,
+	[SAESOC_CIPHER_MODE_CCM] = 0x7,
+	[SAESOC_CIPHER_MODE_GCM] = 0x6,
+	[SAESOC_CIPHER_MODE_MAX] = 0xc,
+};
+
+/* saesoc_gen1_hash_type_map for generation 1 chip sets */
+static int saesoc_gen1_hash_type_map[SAESOC_HASH_TYPE_MAX +1] = {
+	[SAESOC_HASH_TYPE_AES_128] = 0x4,
+	[SAESOC_HASH_TYPE_AES_192] = 0x5,
+	[SAESOC_HASH_TYPE_AES_256] = 0x6,
+        [SAESOC_HASH_TYPE_CAMELLIA_128] = 0x09,
+	[SAESOC_HASH_TYPE_CAMELLIA_192] = 0x0a,
+	[SAESOC_HASH_TYPE_CAMELLIA_256] = 0x0b,	
+	[SAESOC_HASH_BYPASS] = 0x00,
+	[SAESOC_HASH_TYPE_KASUMI] = 0x07,
+	[SAESOC_HASH_TYPE_SNOW3G] = 0x08,
+	[SAESOC_HASH_TYPE_ZUC] = 0x0d,
+	[SAESOC_HASH_TYPE_RABIN] = 0x0,
+	[SAESOC_HASH_TYPE_GHASH] = 0x0c,
+	[SAESOC_HASH_TYPE_MD5] = 0x01,
+	[SAESOC_HASH_TYPE_SHA_1] = 0x02,
+	[SAESOC_HASH_TYPE_SHA_224] = 0x12,
+	[SAESOC_HASH_TYPE_SHA_256] = 0x22,
+	[SAESOC_HASH_TYPE_SHA_384] = 0x32,
+	[SAESOC_HASH_TYPE_SHA_512] = 0x42,
+	[SAESOC_HASH_TYPE_SHA_512_224] = 0x00,
+	[SAESOC_HASH_TYPE_SHA_512_256] = 0x00,
+	[SAESOC_HASH_TYPE_MAX] = 0xff,
+};
+
+/* saesoc_gen1_hash_mode for generation 1 chip sets */
+static int saesoc_gen1_hash_mode[SAESOC_HASH_TYPE_MAX+1] = {
+	[SAESOC_HASH_MODE_CMAC] = 0x05,
+	[SAESOC_HASH_MODE_CBC] = 0x07,
+	[SAESOC_HASH_MODE_XCBC] = 0x06,
+	[SAESOC_HASH_MODE_RABIN_TERMINATION] = 0x0a,
+	[SAESOC_HASH_MODE_CCM] = 0x08,
+	[SAESOC_HASH_MODE_GCM] = 0x09,
+	[SAESOC_HASH_TYPE_ZUC] = 0x00, 
+	[SAESOC_HASH_TYPE_MD5] = 0x00,
+	[SAESOC_HASH_TYPE_SHA_1] = 0x00,
+	[SAESOC_HASH_TYPE_SHA_224] = 0x01,
+	[SAESOC_HASH_TYPE_SHA_256] = 0x02,
+	[SAESOC_HASH_TYPE_SHA_384] = 0x03,
+	[SAESOC_HASH_TYPE_SHA_512] = 0x04,
+};
+
+/* max iv size */
+static int saesoc_iv_size[0xf][0xf] = 
+{
+	/*                  ECB  CBC   CFB   OFB   CTR  AESF8    LRW  XTS    GCM   CCM */
+	/* AES128 */	{   0,    16,   16,  16,    16,   16,     16,  16,   16,   16},
+	/* AES192 */	{   0,    16,   16,  16,    16,  16,     16,  16,    16,   16},
+	/* AES256 */	{   0,    16,   16,  16,    16,  16,     16,  16,    16,   16},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* CAMELLIA128*/{   0,    16,   16,  16,    16,  16,     16,  16,    -1,   16},
+	/* CAMELLIA192*/{   0,    16,   16,  16,    16,  16,     15,  16,    -1,   16},
+	/* CAMELLIA256*/{   0,    16,   16,  16,    16,  16,     16,  16,    -1,   16},
+	/* NONE */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* BYPASS */	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* KASUMIF8*/  	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* SNOW3G F8 */ {   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* ZUC */	{  16,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* DES */   	{   0,     8,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* 3DES */  	{   0,     8,    0,   0,     0,   0,      0,   0,     0,    0},
+	/* ARC4 */  	{   0,     0,    0,   0,     0,   0,      0,   0,     0,    0},
+};
+
+/* max tag size */
+static int saesoc_gen1_tag_len[SAESOC_HASH_TYPE_MAX]= {
+
+/* AES128 */		128,
+/* AES192 */		128,
+/* AES256 */		128,
+/* BYPASS */		0, 
+/* CAMELLIA128 */	16,
+/* CAMELLIA192 */	24,
+/* CAMELLIA256 */	32,
+/* BYPASS */		0, 
+/* BYPASS */		0,
+/* KASUMI_F9 */		32,
+/* SNOW3G_F9 */		32,
+/* ZUC */		32,
+/* RABIN */		0,
+/* GHASH */		0,
+/* BYPASS */		0,
+/* BYPASS */		0,
+/* MD5 */		128,
+/* SHA_1 */		160,
+/* SHA_224 */		224, 
+/* SHA_256 */		256,
+/* SHA_384 */		384,
+/* SHA_512 */		512,
+/* 3 */			0, 
+/* GHASH */		0,  //todo:
+};
+#endif
+
+/**
+* struct saesoc_cipher_init_params - Cipher initialization parameters
+* @type: cipher type
+* @mode: cipher mode
+* @iv_offset: iv offset. Ignored if iv_mode==_PKT_DESC_
+* @key : cipher key
+* @key_len: cipher key length
+* @iv_mode: cipher iv_mode
+* @cfb_mask: cipher freeback mode mask 
+* @flags: cipher specific flags
+*/
+struct saesoc_cipher_init_params {
+	enum saesoc_cipher_type type;
+	enum saesoc_cipher_mode mode;
+	int iv_offset;
+	enum saesoc_iv_mode iv_mode;
+	char *key;
+	int key_len;
+	int cfb_mask;
+	unsigned int flags;
+};
+
+/**
+* struct saesoc_hash_init_params - Hash initialization parameters
+* @type: hash type
+* @mode: hash mode
+* @iv_offset: iv offset. Ignored if iv_mode=_PKT_DESC_
+* @key: hmac key
+* @key_len: hmac key length
+* @iv_mode: iv mode
+* @mute_mask_sel: hash mute mask select. 
+* 			Valid only if HASH_MUTE in the feature flag is set.
+* @tag_len: length of the tag output in bytes.
+* 			Truncated tag length will be supported only if TRUNC_TAG 
+* 			in the feature flag is set
+* @tagin_offset: Offset from the start of the input where tag is present
+* 			Valid only if TAG_OFFSET in the feature flag is set
+* @aad_offset: Additional auth offset from the start of the input
+* @addl_hash_len: Additional hash length.
+* @flags: hash specific flags
+*/
+struct saesoc_hash_init_params {
+		enum saesoc_hash_type type;
+		enum saesoc_hash_mode mode;
+		int iv_offset;
+		enum saesoc_iv_mode iv_mode;
+		char *key;
+		int key_len;
+		int mute_mask_sel; 
+		int tag_len; 
+		int tagin_offset; 
+		int aad_offset;
+		int addl_hash_len; 
+		unsigned int flags;
+}; 
+
+/**
+* struct saesoc_session_init_params - Session initialization parameters
+* @cipher: cipher initialization parameters
+* @hash: hash initialization parameters
+* @payload_offset: payload offset
+* @flags: See session init flags 
+*/
+struct saesoc_session_init_params {
+	struct saesoc_cipher_init_params cipher;
+	struct saesoc_hash_init_params hash;
+	int payload_offset;	
+	unsigned int flags; 
+};
+
+
+/**
+* struct saesoc_session_desc - Crypto session descriptor
+* @lib_priv: Space to store the private data by the library. 
+* 	Application should not modify this area
+* @app_priv: Application private memory.
+* @descs: Descriptor space. Dynamic sized depending on the key length.
+*/
+struct saesoc_session_desc {
+		/* save private information for the session, 
+		*  Should be multiple of cache lines. 
+		*/	
+		char lib_priv[SAESOC_SESSION_DESC_LIB_PRIV_SZ]; 
+		char app_priv[SAESOC_SESSION_DESC_APP_PRIV_SZ];
+		_uint64_t descs[0]; 
+} ___cryptosoc_cacheline_aligned;
+
+
+/**
+* struct saesoc_data_desc - Crypto data descriptor
+* @lib_priv: Space to store the private data by the library.
+* 	Application should not modify this area.
+* @app_priv: Application private memory 
+* @descs: Descriptor space. Dynamic sized depending on the fragments and iv.
+*/
+
+struct saesoc_data_desc {
+		/* save private information for the op, 
+		*  Should be multiple of cache lines.
+		*/	
+		char lib_priv[SAESOC_DATA_DESC_LIB_PRIV_SZ]; 
+		char app_priv[SAESOC_DATA_DESC_APP_PRIV_SZ]; 
+		_uint64_t descs[0]; 
+} ___cryptosoc_cacheline_aligned;
+
+
+/**
+*  struct saesoc_extra_req_send_params:Extra parameters during request send 
+*  @arc4_load_state: Load the ARC4 state before the operation
+*  @async_rsp_arg: User given callback argument, used in async mode only
+*/
+struct saesoc_extra_req_send_params {
+	int arc4_load_state; /* 1 or 0 */
+	_uint64_t async_rsp_arg;
+};
+
+
+
+/**
+* saesoc_calc_sdesc_cnt - Find the number of descriptors required for the 
+* 	session descriptor.
+* @initp: Initialization parameters filled(input)
+* @arg: For future use
+*
+* Return: Descriptor count, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_calc_sdesc_cnt(
+		struct saesoc_session_init_params 	*initp, 
+		void *arg)
+{
+	int ndescs;
+	if(!initp)
+		return -CRYPTOSOC_EINVAL;
+	
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		ndescs = 2; /* initial descriptors */
+		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
+			ndescs += (cryptosoc_roundup(initp->cipher.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t);
+		}
+		if(initp->hash.type != SAESOC_HASH_BYPASS) {
+			ndescs += (cryptosoc_roundup(initp->hash.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t);
+		}
+		return ndescs;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		ndescs = 1; /* initial descriptors */
+		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
+			ndescs += (cryptosoc_roundup(initp->cipher.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t);
+		}
+		if(initp->hash.type != SAESOC_HASH_BYPASS) {
+			ndescs += (cryptosoc_roundup(initp->hash.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t);
+		}
+		return ndescs;
+	
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_new_session - Initialize the session with the specified parameters.
+* @initp: Initialization parameters filled(input) 
+* @sdesc: Pointer to session descriptor. 
+* 	The session create allocates the sufficient memory, 
+* 	maximum of (ndescs passed, required) if *sdesc == NULL(input/output)
+* @ndescs: Number of descriptors allocated/required. Can be -1 if *sdesc == NULL
+* @arg: For future use
+* 
+* Note: Freeing of the session descriptor after use should be taken care by the 
+* application even if it is allocated by the API. 
+*
+* Returns: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
+*/
+
+static inline int saesoc_new_session(
+		struct saesoc_session_init_params 	*initp, 
+		struct saesoc_session_desc 	**sdesc,
+		int 					ndescs,	
+		void 					*arg)
+{
+	int dcnt;
+	int keyidx = 0;
+	int allocated = 0;
+	struct saesoc_session_desc  *sd;
+	struct saesoc_sdesc_priv_data *spriv ;
+
+	if(!initp || !sdesc)
+		return -CRYPTOSOC_EINVAL;
+
+	dcnt = saesoc_calc_sdesc_cnt(initp, NULL);
+	if(dcnt < 0) {
+		cryptosoc_err_print("%s:%d, Error - New session failed, err %d\n", 
+				__FUNCTION__, __LINE__, dcnt);
+		return dcnt;
+	}
+
+	/* The number of descriptors given is less than what 
+	*  is required for the specified hash/cipher type */
+	if((*sdesc != NULL) && (dcnt > ndescs)) {
+		cryptosoc_err_print("%s:%d, Error - New session failed, err %d\n", 
+				__FUNCTION__, __LINE__, dcnt);
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	if(*sdesc == NULL) {
+		/* take the maximum of it*/
+		dcnt = ndescs > dcnt ? ndescs : dcnt;
+
+		*sdesc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
+				sizeof(struct saesoc_session_desc) + dcnt * sizeof(_uint64_t));
+		if(*sdesc == NULL)
+			return -CRYPTOSOC_ENOMEM;
+		allocated = 1;
+	}
+	sd = *sdesc;
+
+	/* return error if descriptor is not cache aligned */
+	if(!cryptosoc_is_cache_aligned((unsigned long)sd->descs)) {
+		cryptosoc_err_print("%s:%d, Error - Session descriptor is not cache aligned\n", 
+				__FUNCTION__, __LINE__);
+		goto err_exit;
+	}
+
+	/* get the private info */
+	spriv = (struct saesoc_sdesc_priv_data *)sd->lib_priv;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		int frag_idx;
+		/* session descriptor index where key should be copied */
+		keyidx = 2;
+		/* data descriptor index where fragment should be copied 
+		*  we will calculate this here based on the iv_mode */
+		frag_idx = 2;
+
+		/* clear the memory */
+		sd->descs[0] = 0x0ULL;
+		sd->descs[1] = 0x0ULL;
+
+		if(initp->hash.type != SAESOC_HASH_BYPASS) {
+			saesoc_gen2_set_hash_type_mode_offset(sd->descs[0],
+				initp->hash.type, initp->hash.mode,
+				initp->hash.key_len, 
+				(initp->hash.flags & SAESOC_HF_HASHINP_IS_CIPHEROUT)==0?0:1,
+				initp->hash.iv_offset,
+					initp->hash.aad_offset,
+					initp->hash.iv_mode,
+					(initp->hash.flags & SAESOC_HF_HMAC_KEY_PAD_EN)==0?0:1);
+			saesoc_gen2_set_hash_mutemask(sd->descs[0],
+					initp->hash.mute_mask_sel,
+					(initp->hash.flags & SAESOC_HF_HASH_MUTE_MASK_EN)==0?0:1);
+			saesoc_gen2_set_hash_addllen(sd->descs[0], initp->hash.addl_hash_len);
+			saesoc_gen2_set_rabinfnprint(sd->descs[0], 
+					(initp->flags & SAESOC_IF_RFP_OUT_ON)==0?0:1);
+			saesoc_gen2_set_tag_offset_len(sd->descs[1], 
+					(initp->hash.flags & SAESOC_HF_CHKTAG_ON)==0?0:1,
+					(initp->hash.flags &  SAESOC_HF_TAGIN_EOP)==0?0:1,
+					(initp->hash.flags &  SAESOC_HF_TAGOUT_EOP)==0?0:1,
+					initp->hash.tagin_offset, 
+					initp->hash.tag_len);
+
+			/* copy the key , hash key first then cipher key*/
+			memcpy((char *)(long)&sd->descs[keyidx], 
+					initp->hash.key, initp->hash.key_len);
+			keyidx += ((cryptosoc_roundup(initp->hash.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t));
+
+			/* copy the init info to the private structure */
+			spriv->hash_en = 1;
+			if(initp->hash.iv_mode == SAESOC_IV_FROM_PKT_DESC) {
+				/* IV can be 8 byte or 16 byte (space is for 128 bit always) */
+				spriv->hash_iv_descs = 2;
+				frag_idx += spriv->hash_iv_descs;
+			} else
+				 spriv->hash_iv_descs = 0;
+		} else {
+			saesoc_gen2_set_hash_bypass(sd->descs[0]);
+			spriv->hash_iv_descs = 0;
+		}
+
+		if(initp->cipher.type != SAESOC_CIPHER_BYPASS) {
+			saesoc_gen2_set_cipher_type_mode_offset(sd->descs[1], 
+					(initp->cipher.flags & SAESOC_CF_ENCRYPT)==0?0:1,
+					initp->cipher.type, initp->cipher.mode,
+					initp->cipher.iv_offset, initp->cipher.iv_mode);
+			if(initp->cipher.type == SAESOC_CIPHER_TYPE_ARC4) {
+				saesoc_gen2_set_arc4_param(sd->descs[0], 
+					(initp->cipher.flags & 
+					 SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC)==0?0:1,
+						initp->cipher.key_len);
+			}
+			saesoc_gen2_enable_cipher_pad(sd->descs[1],
+					(initp->cipher.flags & SAESOC_CF_CIPHER_PAD_ON)==0?0:1);
+
+			if(initp->cipher.mode == SAESOC_CIPHER_MODE_CFB)
+				saesoc_gen2_set_cfbmask(sd->descs[1], initp->cipher.cfb_mask);
+	
+			/* copy the key , hash key first then cipher key*/
+			memcpy((char *)(long)&sd->descs[keyidx], 
+					initp->cipher.key, initp->cipher.key_len);
+
+			keyidx += ((cryptosoc_roundup(initp->cipher.key_len, 
+						sizeof(_uint64_t))) / sizeof(_uint64_t));
+
+			/* copy the init info to the private structure */
+			spriv->cipher_en = 1;
+			if(initp->cipher.iv_mode == SAESOC_IV_FROM_PKT_DESC) {
+				/* IV can be 8 byte or 16 byte (space is for 128 bit always) */
+				spriv->cipher_iv_descs = 2;
+				frag_idx += spriv->cipher_iv_descs;
+			} else
+				spriv->cipher_iv_descs = 0;
+		} else {
+			saesoc_gen2_set_cipher_bypass(sd->descs[1]);
+			spriv->cipher_iv_descs = 0;
+		}
+
+
+		saesoc_gen2_set_l3param(sd->descs[0],
+				(initp->flags & SAESOC_IF_DATA_OUT_L3_ALLOC) == 0 ? 0 :1,
+				(initp->flags & SAESOC_IF_DATA_OUT_CLOBBER) == 0 ? 0 :1,
+				(initp->flags & SAESOC_IF_DATA_WR_MOD_ONLY_EN) == 0 ? 0 :1,
+				(initp->hash.flags & SAESOC_HF_HASH_L3_ALLOC) == 0 ? 0 : 1,
+				(initp->hash.flags & SAESOC_HF_HASH_CLOBBER) == 0 ? 0 : 1);
+		saesoc_gen2_set_tls(sd->descs[0], 
+				(initp->flags & SAESOC_IF_TLS_ON) == 0 ? 0 :1);
+		saesoc_gen2_set_payload_offset(sd->descs[1], initp->payload_offset);
+
+		/* copy the init info to the private structure */
+		spriv->ldesc = keyidx;
+		spriv->frag_idx = frag_idx;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1 
+	{
+		/* session descriptor index where key should be copied */
+		keyidx = 1;
+		/* clear the memory */
+		sd->descs[0] = 0ULL;
+		spriv->ddesc[0]= spriv->ddesc[1] = 0ULL;
+		spriv->ddesc[2]= spriv->ddesc[3] = 0ULL;
+		spriv->ddesc[4] = spriv->ddesc[5] = 0ULL;
+		spriv->hash_key_len_in_dw = 0; 
+		spriv->cipher_key_len_in_dw = 0;  
+
+		saesoc_gen1_set_cipher_l3param(spriv->ddesc[5],
+				(initp->flags & SAESOC_IF_DATA_OUT_L3_ALLOC) == 0 ? 0:1,
+				(initp->flags & SAESOC_IF_DATA_OUT_CLOBBER ) == 0 ? 0:1);
+		saesoc_gen1_set_hash_srcsel(spriv->ddesc[0],
+				(initp->hash.flags & SAESOC_HF_HASHINP_IS_CIPHEROUT)==0?0:1);
+		saesoc_gen1_set_hash_l3allocate(spriv->ddesc[0],
+				(initp->hash.flags & SAESOC_HF_HASH_L3_ALLOC) == 0 ? 0:1);
+
+		saesoc_gen1_set_hash_offset_clobber( spriv->ddesc[2],
+				initp->hash.aad_offset,
+				((initp->hash.flags & SAESOC_HF_HASH_CLOBBER) == 0 ? 0:1));
+
+		saesoc_gen1_set_hmac_extkeypad( spriv->ddesc[3],
+				(initp->hash.flags & SAESOC_HF_HMAC_KEY_PAD_EN)==0?1:0);
+
+		saesoc_gen1_set_cipher_ivoffset( spriv->ddesc[2],
+				initp->cipher.iv_offset);
+		saesoc_gen1_set_cipher_offset( spriv->ddesc[2],
+				initp->payload_offset);
+
+		if( initp->cipher.type != SAESOC_CIPHER_BYPASS) {
+			saesoc_gen1_set_cipher_type_mode(sd->descs[0],
+					saesoc_gen1_cipher_table_map[initp->cipher.type],
+					saesoc_gen1_cipher_mode_map[initp->cipher.mode]);
+			saesoc_gen1_set_cipher_enc_ivlen(spriv->ddesc[0],
+					(initp->cipher.flags & SAESOC_CF_ENCRYPT)==0?0:1,
+					saesoc_iv_size[initp->cipher.type][initp->cipher.mode]);
+
+			if(initp->cipher.type == SAESOC_CIPHER_TYPE_ARC4) {
+				saesoc_gen1_set_arc4_param(sd->descs[0],
+						(initp->cipher.flags & SAESOC_CF_ARC4_KEY_INIT)==0?0:1,
+						initp->cipher.key_len);
+				saesoc_gen1_set_arc4_l3param(  spriv->ddesc[3],
+						(initp->cipher.flags & SAESOC_CF_ARC4_STATE_OUT_L3_ALLOC)==0?0:1);
+			}
+			if(initp->cipher.mode == SAESOC_CIPHER_MODE_CFB) {
+				saesoc_gen1_set_cfbmask(sd->descs[0],initp->cipher.cfb_mask);
+			}	
+			if ( (saesoc_gen1_cipher_table_map[initp->cipher.type] == 0x2) && 
+					!(initp->cipher.flags & SAESOC_CF_ENCRYPT) &&
+					!(initp->cipher.flags & SAESOC_CF_DES3_KEYSWAP_DONE) )
+			{	
+				unsigned long long  * key = (unsigned long long  *)initp->cipher.key;
+				sd->descs[keyidx] = key[2];
+				sd->descs[keyidx+1] = key[1];
+				sd->descs[keyidx+2] = key[0];
+			}
+			else
+				memcpy((char *)(long)&sd->descs[keyidx],initp->cipher.key, 
+					initp->cipher.key_len);
+			spriv->cipher_key_len_in_dw = 	((cryptosoc_roundup(initp->cipher.key_len,
+							sizeof(_uint64_t))) / sizeof(_uint64_t)); 
+			keyidx += spriv->cipher_key_len_in_dw;
+
+		} else
+			saesoc_gen1_set_cipher_bypass(sd->descs[0]);
+		spriv->addl_hash_len = 0;
+
+		if(initp->hash.type != SAESOC_HASH_BYPASS) {
+			int hmac = initp->hash.key_len?1:0;
+			int mode ;
+			if ( (initp->hash.mode == SAESOC_HASH_MODE_XCBC) ||
+			  	(initp->hash.mode == SAESOC_HASH_MODE_GCM) || 
+				(initp->hash.mode == SAESOC_HASH_MODE_CCM))
+			       hmac = 0;	
+			spriv->hash_en = 1;
+			spriv->addl_hash_len = initp->hash.addl_hash_len;
+			if ( SAESOC_HASH_TYPE_ZUC == initp->hash.type )
+				hmac = 0;
+
+
+			if ( initp->hash.type > SAESOC_HASH_TYPE_SNOW3G)
+
+				mode =  saesoc_gen1_hash_mode[initp->hash.type];
+			else
+				mode =  saesoc_gen1_hash_mode[initp->hash.mode];
+
+			/* Gen1 does not support truncated tag length. The auth-buffer
+			*  should have space for the tag length */
+			if(initp->hash.tag_len <  (saesoc_gen1_tag_len[initp->hash.type] / 8)) {
+				cryptosoc_err_print("%s:%d, Error - Tag length is less than required\n", 
+				__FUNCTION__, __LINE__);
+				goto err_exit;
+			}
+
+			saesoc_gen1_set_tag_len(spriv->ddesc[3], saesoc_gen1_tag_len[initp->hash.type]);
+			saesoc_gen1_set_hash_type_mode(sd->descs[0],hmac,
+					saesoc_gen1_hash_type_map[initp->hash.type],
+					mode );
+			memcpy((char *)(long)&sd->descs[keyidx], 
+					initp->hash.key, initp->hash.key_len);
+
+			spriv->hash_key_len_in_dw = ((cryptosoc_roundup(initp->hash.key_len, 
+							sizeof(_uint64_t))) / sizeof(_uint64_t));
+			 keyidx += spriv->hash_key_len_in_dw;
+		} else
+			saesoc_gen1_set_hash_bypass(sd->descs[0]);
+		spriv->ldesc = keyidx;
+		spriv->frag_idx = 4;
+	}
+#endif	
+	return CRYPTOSOC_OK;
+
+err_exit:
+	if(allocated && sd)
+		cryptosoc_mem_free(sd);
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+
+/**
+* saesoc_get_sdesc_cnt - Get the number of descriptors allocated for a  session
+* @sdesc: Pointer to the session descriptor(input)
+*
+* Return: Descriptor count, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_get_sdesc_cnt(struct saesoc_session_desc *sdesc)
+{
+	struct saesoc_sdesc_priv_data *spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+	return spriv->ldesc;
+}
+
+
+
+/**
+* saesoc_calc_ddesc_desc_cnt - Find the number of descriptors required for the 
+* 	data descriptor.
+* @sdesc: Pointer to the session descriptor(input)
+* @ndesfb_descs : Number of designer free back descriptors.
+* @nextra_descs : Space for number of extra descriptors. 
+* 		Can be used if the application does not know the number of fragments 
+* 		exactly at the creation time.
+* @arg : For future use.
+*
+* Note: If EXPLICIT_IV support is there and the mode is enabled, 
+* the api should add its size also to the required size.
+* if the AAD is not part of the packet, pass this in "nexdescs" 
+*
+* Return: Descriptor count, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_calc_ddesc_desc_cnt(
+		struct saesoc_session_desc *sdesc,
+		int 	ndesfb_descs,
+		int		nextra_descs,
+		void 		*arg)
+{
+	struct saesoc_sdesc_priv_data *spriv;
+	int ndescs = ndesfb_descs + nextra_descs;
+
+	if(!sdesc)
+		return -CRYPTOSOC_EINVAL;
+
+	/* For gen2, the freeback descriptor should be copied to the last descriptor */
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		ndescs += 1;
+	}
+#endif
+
+	spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+	ndescs += spriv->frag_idx;
+	return (ndescs);
+}
+
+
+/**
+* saesoc_calc_frags_desc_cnt - Find the number of descriptors required for
+* 	the given payload src and dst length
+* @sdesc: Pointer to the session descriptor(input)
+* @src: Data source pointer(input).
+* @slen: Source data length
+* @dst: Data destination pointer(input).
+* @dlen: Destination data length 
+*
+* Return: Descriptor count
+*/
+ 
+static inline int saesoc_calc_frags_desc_cnt(struct saesoc_session_desc *sdesc, 
+		char *src,
+		unsigned int slen,
+		char *dst,
+		unsigned int dlen)
+{
+	int ndescs = 0;
+	/* Fraglen is same for both generation of processors */
+	unsigned int maxfraglen = 1 << 16;
+	(void)sdesc;
+ 
+  	if(src)	
+		ndescs = ((slen / maxfraglen) + ((slen % maxfraglen) != 0));
+	if(dst)
+		ndescs += ((dlen / maxfraglen) + ((dlen % maxfraglen) != 0));
+
+	return ndescs;
+}
+	
+/**
+* saesoc_new_data_desc - Initialize the data descriptor
+* @sdesc : Pointer to the session descriptor(input)
+* @ddesc : Pointer data descriptor. It will be allocated if 
+* 	*ddesc == NULL(input/output)
+* @ndescs : Data descriptor count. 
+* @arg : For future use
+*
+* Data descriptor saves the session descriptor address, data descriptor 
+* size etc in its private area for its Internal purpose. 
+*
+* Note: Freeing of the data descriptor after use should be taken care by the 
+* application even if it is allocated by the API.
+* 
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
+*/
+
+static inline int saesoc_new_data_desc(
+		struct saesoc_session_desc *sdesc, 
+		struct saesoc_data_desc **ddesc,
+		int ndescs,
+		void *arg)
+{
+	int allocated = 0;
+	struct saesoc_data_desc *dd;
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_sdesc_priv_data *spriv;
+
+	if(!sdesc || !ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+		/* TOTO : Should find out the minimun required, assuming 1 fragment now */
+		if(ndescs < (spriv->frag_idx + 1)) {
+			cryptosoc_err_print(
+				"%s:%d, Error-Data descriptor size is < minimum required\n", 
+				__FUNCTION__, __LINE__);
+			return -CRYPTOSOC_EINVAL;
+		}
+	}
+#endif
+
+	if(*ddesc == NULL) {
+		*ddesc = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
+				sizeof(struct saesoc_data_desc) + ndescs * sizeof(_uint64_t));
+		if(*ddesc == NULL)
+			return -CRYPTOSOC_ENOMEM;
+		allocated = 1;
+	}
+	
+	dd = *ddesc;
+
+	if(!cryptosoc_is_cache_aligned((unsigned long)dd->descs)) {
+		cryptosoc_err_print("%s:%d, Error-Data descriptor is not cache aligned\n", 
+				__FUNCTION__, __LINE__);
+		goto err_exit;
+	}
+
+
+	dpriv = (struct saesoc_ddesc_priv_data *)dd->lib_priv;
+	dpriv->sdesc = sdesc;
+	spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+
+	/* set the starting free fragment index */
+	dpriv->lsrc_frag_idx = -1;
+	dpriv->ldst_frag_idx = -1;
+	dpriv->nfrag_idx = 	spriv->frag_idx;
+	dpriv->max_descs = ndescs;
+	dpriv->ndesfb_descs = 0;
+	dpriv->aad_len = 0;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		dd->descs[0] = 0ULL;
+		dd->descs[1] = 0ULL;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+	dd->descs[0] = spriv->ddesc[0];
+	dd->descs[1] = spriv->ddesc[1];
+	dd->descs[2] = spriv->ddesc[2];
+	dd->descs[3] = spriv->ddesc[3];
+	dd->descs[4] = spriv->ddesc[4];
+	dd->descs[5] = spriv->ddesc[5];
+	}
+#endif
+
+	return CRYPTOSOC_OK;
+
+err_exit:
+	if(allocated && dd)
+		cryptosoc_mem_free(dd);
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_add_frags - Add the source and destination fragment info in 
+* 	to the data descriptor. 
+* @ddesc: Pointer to the data descriptor(input)
+* @src: Data source pointer(input).
+* @slen: Source data length
+* @dst: Data destination pointer(input).
+* @dlen: Destination data length
+*
+* Note: The current free source, destination fragment index is saved 
+* in the private area in the data descriptor. 
+* For griffin the source and destination fragment can be in any order. 
+* But for Eagle it should be alternate and the number of source & destination 
+* segments should be the same. See FEATURE_SRC_DST_FRAG_STRIC_ORDER flag
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
+*
+*/
+
+static inline int saesoc_add_frags(
+		struct saesoc_data_desc *ddesc,
+		char *src,
+		unsigned int slen,
+		char *dst,
+		unsigned int dlen)
+{
+	int nf = 0;
+	struct saesoc_ddesc_priv_data *dpriv;
+	unsigned int maxfraglen = 1 << 16;
+	unsigned int sl, dl, max, i;
+	//printk("ddesc %p %p %p\n",ddesc,src,dst);
+
+	if(!ddesc || (!src && !dst))
+		return -CRYPTOSOC_EINVAL;
+
+	if((!src && slen) || (!dst && dlen)) {
+		return -CRYPTOSOC_EINVAL;
+	}
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+
+	/* find number of descriptors required for source and destination */
+	nf = saesoc_calc_frags_desc_cnt(dpriv->sdesc, src, slen, dst, dlen);
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		if((nf + dpriv->nfrag_idx) > dpriv->max_descs) {
+		//	cryptosoc_err_print(
+		//		"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
+		//		__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
+			return -CRYPTOSOC_EINVAL;
+		}
+		nf = dpriv->nfrag_idx;
+
+		/* Here any order of source and destination are possible. 
+		*  As per the engine spec, in cipher mode, there should be at least 
+		*  one destination fragment before 16 source fragment. 
+		*  Flag error when the difference b/w source and destination fragment 
+		*  idx is 16 */
+		/* TODO : Error checks */
+		/* we will do alternate src & dst fragments if both are present */
+		max = slen > dlen ? slen : dlen;
+		for(i = 0; i < max; i++) {
+				sl = 0; dl = 0;
+				if(slen > i) {
+					sl = slen - i > maxfraglen ? maxfraglen : slen - i;
+					saesoc_gen2_set_src_frag(ddesc->descs[nf], 0, sl, 
+							cryptosoc_virt_to_phys((unsigned long)src + i));
+					dpriv->lsrc_frag_idx = nf;
+					nf++;
+				} 
+				if(dlen > i) {
+					dl = dlen - i > maxfraglen ? maxfraglen : dlen - i;
+					saesoc_gen2_set_dst_frag(ddesc->descs[nf], 0, dl, 
+							cryptosoc_virt_to_phys((unsigned long)dst + i), 0);
+					dpriv->ldst_frag_idx = nf;
+					nf++;
+				}
+				sl = sl > dl ? sl : dl;
+				i += sl;		
+		}
+		/* update the last fragment index */
+		dpriv->nfrag_idx = nf;
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_sdesc_priv_data *spriv;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+
+		if((nf + dpriv->nfrag_idx) > dpriv->max_descs) {
+			cryptosoc_err_print(
+				"%s:%d, Error - Fragments overflow max %d cur %d more %d\n", 
+				__FUNCTION__, __LINE__,dpriv->max_descs, dpriv->nfrag_idx, nf);
+			return -CRYPTOSOC_EINVAL;
+		}
+		nf = dpriv->nfrag_idx;
+
+		/* Here any order of source and destination are possible. 
+		*  As per the engine spec, in cipher mode, there should be at least 
+		*  one destination fragment before 16 source fragment. 
+		*  Flag error when the difference b/w source and destination fragment 
+		*  idx is 16 */
+		/* TODO : Error checks */
+		/* we will do alternate src & dst fragments if both are present */
+		max = slen > dlen ? slen : dlen;
+		for(i = 0; i < max; i++) {
+				sl = 0; dl = 0;
+				if(slen > i) {
+					ddesc->descs[nf] = spriv->ddesc[4];
+					sl = slen - i > maxfraglen ? maxfraglen : slen - i;
+					saesoc_gen1_set_src_frag(
+							ddesc->descs[nf], sl, 
+							cryptosoc_virt_to_phys((unsigned long)src + i));
+					dpriv->lsrc_frag_idx = nf;
+					nf++;
+				} 
+				if(dlen > i) {
+					dl = dlen - i > maxfraglen ? maxfraglen : dlen - i;
+					ddesc->descs[nf] = spriv->ddesc[5];
+					saesoc_gen1_set_dst_frag( 
+						ddesc->descs[nf], dl, 
+						cryptosoc_virt_to_phys((unsigned long)dst + i));
+					dpriv->ldst_frag_idx = nf;
+					nf++;
+				}
+				sl = sl > dl ? sl : dl;
+				i += sl;		
+			}
+		/* update the last fragment index */
+		dpriv->nfrag_idx = nf;
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_add_desfb_descs - Add the designer freeback descriptors
+*  to the data descriptor.
+* @ddesc: Pointer to the data descriptor(input)
+* @desfb_descs: Pointer to the designer descriptors(input)
+* @ndesfb_descs:Number of designer descriptors
+* @desfb_vc: Designer freeback vc
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
+*
+* This should be called only after all the fragment are filled in. 
+* Otherwise this info might be overwritten with the fragments.
+*
+*/
+
+static inline int saesoc_add_desfb_descs(
+		struct saesoc_data_desc *ddesc,
+		_uint64_t *desfb_descs,
+		int ndesfb_descs,
+		int desfb_vc)
+{
+	int nf, i;
+	struct saesoc_ddesc_priv_data *dpriv;
+
+	if(!ddesc || !desfb_descs)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		nf = dpriv->nfrag_idx;
+		if((nf + ndesfb_descs) > dpriv->max_descs) {
+			cryptosoc_err_print(
+				"%s:%d, Error - Fragments overflow max %d cur %d reqd %d\n", 
+				__FUNCTION__, __LINE__,  dpriv->max_descs, nf, ndesfb_descs);
+			return -CRYPTOSOC_EINVAL;
+		}
+		for(i = 0; i < ndesfb_descs; i++)
+			ddesc->descs[nf + i] = desfb_descs[i];
+		dpriv->ndesfb_descs = ndesfb_descs;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_desfb(ddesc->descs[1], desfb_vc);
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_desfb(ddesc->descs[3], desfb_vc);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_explicit_iv - Copy the iv in to the data descriptor
+* @ddesc: Pointer to the data descriptor(input)
+* @cipher_iv: Pointer to the cipher iv(input)
+* @cipher_iv_len: Cipher iv length
+* @hash_iv: Pointer to the hash iv(input)
+* @hash_iv_len: Hash iv length
+*
+* This can be called only if EXPLICIT_IV is set in the chip feature. 
+* IV length is extracted from the session descriptor.
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOSPACE
+*/
+
+static inline int saesoc_set_explicit_iv(
+		struct saesoc_data_desc *ddesc,
+		char *cipher_iv,
+		int cipher_iv_len,
+		char *hash_iv,
+		int hash_iv_len)
+{
+
+	struct saesoc_sdesc_priv_data *spriv;
+	struct saesoc_ddesc_priv_data *dpriv;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		int sseg=2;
+		/* We can have both HashIvMode == CipherIvMode == PKT_DSC.  
+		*  When this is done, the HashIv will come in the first 128 bits and 
+		*  the CiphIv will come in the second 128 bits.  Please note that 
+		*  this applies even if the IV is only 64 bits.  In this case, the 
+		*  IV should be in the upper 64 bits of the 128 bit field 
+		*/
+		if(spriv->hash_iv_descs) {
+			if((hash_iv_len / sizeof(_uint64_t)) > spriv->hash_iv_descs)
+				return -CRYPTOSOC_EINVAL;
+			memcpy((char *)(long)&ddesc->descs[sseg], hash_iv, hash_iv_len);
+			/* iv area is always for 128 bits */
+			sseg += 2;
+		}
+		if(spriv->cipher_iv_descs) {
+			if((cipher_iv_len / sizeof(_uint64_t)) > spriv->cipher_iv_descs)
+				return -CRYPTOSOC_EINVAL;
+			memcpy((char *)(long)&ddesc->descs[sseg], cipher_iv, cipher_iv_len);
+		}
+		return CRYPTOSOC_OK;
+	}
+#endif
+
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_get_frag_index - Get the current source and destination 
+* 	descriptor index 
+* @ddesc: Pointer to the data descriptor(input)
+* @src_idx: Source descriptor index(output)
+* @dst_idx: Destination descriptor index(output)
+* @max_descs: Maximum descriptors allowed(output)
+*
+* Note: For Eagle, the source and destination address should be in-order. 
+* But for Griffin, as the source and destination can be anywhere. So in griffin,
+* the above call returns the same value for srcidx & dstidx. 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_get_frag_index(
+		struct saesoc_data_desc *ddesc, 
+		int  *src_idx,
+		int *dst_idx,
+		int *max_descs)
+{
+	struct saesoc_ddesc_priv_data *dpriv;
+
+	if(!ddesc || !src_idx || !dst_idx || !max_descs)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+
+	*src_idx = dpriv->lsrc_frag_idx;
+	*dst_idx = dpriv->ldst_frag_idx;
+	*max_descs = dpriv->max_descs;
+	return CRYPTOSOC_OK;
+}
+
+/**
+* saesoc_reset_ddesc - Reset the data descriptor 
+* @ddesc: Pointer to the data descriptor(input)
+* @op: Reset operation type
+* @src_idx: Source fragment index
+* @dst_idx: Destination fragment index
+*
+* Set the current source and destination descriptor index. 
+* This can be used to reset the current data descriptor memory. 
+* Also this can be used to abort the previous operation and re-use it 
+*
+* Note: 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_reset_ddesc(
+		struct saesoc_data_desc *ddesc,
+		enum saesoc_ddesc_reset_op op,
+		int src_idx,
+		int dst_idx )
+{
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_sdesc_priv_data *spriv;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+	if(op == SAESOC_DDESC_RESET_ALL_FRAGS) {
+		/* set the starting free fragment index */
+		dpriv->lsrc_frag_idx = -1;
+		dpriv->ldst_frag_idx = -1;
+		dpriv->nfrag_idx = spriv->frag_idx;		
+		dpriv->ndesfb_descs = 0;
+	} else if(op == SAESOC_DDESC_RESET_FRAGIDX) {
+		if((src_idx < dpriv->max_descs) && (dst_idx < dpriv->max_descs)) {
+			dpriv->lsrc_frag_idx = src_idx;
+			dpriv->ldst_frag_idx = dst_idx;
+			/* last descriptor is the maximum of this */
+			dpriv->nfrag_idx = src_idx > dst_idx ? src_idx : dst_idx;
+			dpriv->nfrag_idx++; /* it is the next availabe slot */
+		} else
+			return -CRYPTOSOC_EINVAL;
+	} else
+		return -CRYPTOSOC_EINVAL;
+
+	return CRYPTOSOC_OK;
+};
+
+
+/**
+* saesoc_get_ddesc_cnt - Get the descriptor used count
+* @ddesc: Pointer to the data descriptor(input)
+*
+* Return: Desciptor count, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_get_ddesc_cnt(struct saesoc_data_desc *ddesc)
+{
+	struct saesoc_ddesc_priv_data *dpriv;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	return (dpriv->nfrag_idx + dpriv->ndesfb_descs);
+}
+
+/**
+* saesoc_copy_ddesc - Copy the current data descriptor to new one
+* @ddesc: Pointer to the existing data descriptor(input)
+* @ddesc_new: Pointer to the new data descriptor(input/output). 
+* 		If *ddesc_new == NULL, the api allocates a new one and copy it.
+* @ndescs_new: Number of descriptors required for the new data descriptor
+* 		This should be >= descriptors required to copy from the current desc.
+* @arg: For future use
+*
+* The old/new descriptor should be freed by the application.
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL, CRYPTOSOC_ENOMEM, CRYPTOSOC_ENOSPACE
+*/
+
+static inline int saesoc_copy_ddesc(
+		struct saesoc_data_desc *ddesc,
+		struct saesoc_data_desc **ddesc_new,
+		int ndescs_new,
+		void *arg)
+{
+
+	struct saesoc_ddesc_priv_data *dpriv, *dpriv_n;
+	int fragsused, i;
+	struct saesoc_data_desc *dd_n;
+
+
+	if(!ddesc || !ddesc_new)
+		return -CRYPTOSOC_EINVAL;
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+
+	fragsused = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+
+	if(fragsused > ndescs_new) {
+			cryptosoc_err_print(
+				"%s:%d, Error - Copy failed cur-frags %d given %d\n", 
+				__FUNCTION__, __LINE__,  fragsused, ndescs_new);
+			return -CRYPTOSOC_EINVAL;
+	}
+
+
+	if(*ddesc_new == NULL) {
+		*ddesc_new = cryptosoc_mem_alloc(CRYPTOSOC_CACHELINE_SZ,
+			sizeof(struct saesoc_data_desc) + ndescs_new * sizeof(_uint64_t));
+		if(*ddesc_new == NULL)
+			return -CRYPTOSOC_ENOMEM;
+	}
+	
+	dd_n = *ddesc_new;
+	dpriv_n = (struct saesoc_ddesc_priv_data *)dd_n->lib_priv;
+	dpriv_n->sdesc = dpriv->sdesc;
+
+	/* set the starting free fragment index */
+	dpriv_n->lsrc_frag_idx = dpriv->lsrc_frag_idx;
+	dpriv_n->ldst_frag_idx = dpriv->ldst_frag_idx;
+	dpriv_n->nfrag_idx = dpriv->nfrag_idx;
+	dpriv_n->max_descs = ndescs_new;
+	dpriv_n->ndesfb_descs = dpriv->ndesfb_descs;
+	dpriv_n->aad_len = dpriv->aad_len;
+	for(i = 0; i < fragsused; i++) {
+		dd_n->descs[i] = ddesc->descs[i];
+	}
+
+
+	return CRYPTOSOC_OK;
+}
+
+/**
+* saesoc_set_payload_len - Set the payload length
+* @ddesc: Pointer to the data descriptor(input)
+* @payload_len: Payload length
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_payload_len (
+		struct saesoc_data_desc *ddesc,
+		unsigned int payload_len)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_payload_len(ddesc->descs[0], payload_len);
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		struct saesoc_ddesc_priv_data *dpriv;
+		struct saesoc_sdesc_priv_data *spriv;
+
+		if(!ddesc)
+			return -CRYPTOSOC_EINVAL;
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+		if ( spriv->cipher_key_len_in_dw )
+			saesoc_gen1_set_cipher_len(ddesc->descs[1], payload_len);
+		if ( spriv->hash_en ) 
+			saesoc_gen1_set_hash_len(ddesc->descs[1], (payload_len+spriv->addl_hash_len + dpriv->aad_len));
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_payload_bitcnt - Set the payload bit count
+* @ddesc: Pointer to the data descriptor(input)
+* @payload_bitcnt: Number of valid bits in the last byte of the input
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int  saesoc_set_payload_bitcnt(
+		struct saesoc_data_desc *ddesc,
+		int payload_bitcnt)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_payload_bitcnt(ddesc->descs[1], payload_bitcnt);
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		struct saesoc_ddesc_priv_data *dpriv;
+		struct saesoc_sdesc_priv_data *spriv;
+
+		if(!ddesc)
+			return -CRYPTOSOC_EINVAL;
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+		if ( spriv->cipher_key_len_in_dw )
+		saesoc_gen1_set_hash_bitcnt(ddesc->descs[2],payload_bitcnt);
+		if ( spriv->hash_en )
+		saesoc_gen1_set_cipher_bitcnt(ddesc->descs[2],payload_bitcnt);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_tag_dstaddr - Set the tag destination address
+* @ddesc: Pointer to the data descriptor(input)
+* @tag_dst_addr: Tag destination address
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_tag_dstaddr(
+		struct saesoc_data_desc *ddesc,
+		char *tag_dst_addr)
+{
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_tag_dstaddr(ddesc->descs[1], 
+				cryptosoc_virt_to_phys((unsigned long)tag_dst_addr));
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_tag_dstaddr(ddesc->descs[0],
+				cryptosoc_virt_to_phys((unsigned long)tag_dst_addr));
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_arc4_savestate - Set the arc4 save state option
+* @ddesc: Pointer to the data descriptor(input)
+* @save_state: boolean, enable/disable
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_arc4_savestate(
+		struct saesoc_data_desc *ddesc, 
+		int save_state)
+{
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_arc4_savestate(ddesc->descs[1], save_state);
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_arc4_savestate(ddesc->descs[3],save_state);
+		return CRYPTOSOC_OK; 
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_aad_len - Set the AAD length
+* @ddesc: Pointer to the data descriptor(input)
+* @aad_len: AAD length
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_aad_len(
+		struct saesoc_data_desc *ddesc, 
+		int aad_len)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_aadlen(ddesc->descs[0], aad_len);
+		return CRYPTOSOC_OK;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		struct saesoc_ddesc_priv_data *dpriv;
+
+		if(!ddesc)
+			return -CRYPTOSOC_EINVAL;
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+
+		dpriv->aad_len = aad_len;
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_cipher_ivoffset - Set the cipher IV offset
+* @ddesc: Pointer to the data descriptor(input)
+* @iv_offset: iv offset
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_cipher_ivoffset(
+		struct saesoc_data_desc *ddesc, 
+		int iv_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_cipher_ivoffset( ddesc->descs[2],
+				iv_offset);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_payload_offset - Set the payload offset
+* @ddesc: Pointer to the data descriptor(input)
+* @payload_offset: Payload offset 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_payload_offset(
+		struct saesoc_data_desc *ddesc, 
+		int payload_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		saesoc_gen1_set_cipher_offset( ddesc->descs[2],
+				payload_offset);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_aad_offset - Set the AAD offset
+* @ddesc: Pointer to the data descriptor(input)
+* @aad_offset: AAD offset 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_aad_offset(
+		struct saesoc_data_desc *ddesc, 
+		int aad_offset)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		_uint64_t clob = 0ULL;
+		saesoc_gen1_get_hash_clobber(ddesc->descs[2], clob);
+		saesoc_gen1_set_hash_offset_clobber(ddesc->descs[2],
+				aad_offset,
+				((clob)? 1 : 0));
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+
+/**
+* saesoc_disable_wr_fragment - Disable engine result writing last dst fragments
+* @ddesc: Pointer to the data descriptor(input)
+*
+* Note: Can be called only if DIS_WR_FRAGMENT_ option is set in the feature set
+* This should be called immediately setting a fragment. 
+* 
+*/
+
+static inline int saesoc_disable_wr_fragment(
+		struct saesoc_data_desc *ddesc)
+{
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+
+		struct saesoc_ddesc_priv_data *dpriv;
+		if(!ddesc)
+			return -CRYPTOSOC_EINVAL;
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		if(dpriv->ldst_frag_idx)
+			saesoc_gen2_disble_wrfrag(ddesc->descs[dpriv->ldst_frag_idx]);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_set_cipher_padval - Set the cipher pad value
+* @ddesc: Pointer to the data descriptor(input)
+* @pad_val: Cipher pad value
+*
+* Note: This can be called only if PAD_ option is set in the feature set
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int  saesoc_set_cipher_padval(
+		struct saesoc_data_desc *ddesc,
+		int pad_val)
+{
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		saesoc_gen2_set_cipher_padval(ddesc->descs[0], pad_val);
+		return CRYPTOSOC_OK;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+
+
+/**
+* saesoc_chk_tag_compare_result - Check the ICV values are matching or not
+* @res: Engine result response
+*
+* Note: Can be called only if CHK_TAG is enabled in the feature set
+*
+* Return: 1 if it is matching, 0 otherwise
+*/
+
+static inline int saesoc_chk_tag_compare_result(struct saesoc_rsp_result *res)
+{
+	/* TODO */
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_result_valid - Check the whether the result from the engine is 
+* valid or not
+* @res: Engine result response
+*
+*
+* Return: 1 if it is valid, 0 otherwise
+*/
+static inline int saesoc_result_valid(struct saesoc_rsp_result *res)
+{
+	/* TODO */
+	return 1;
+}
+
+/**
+* saesoc_set_hash_mutemask - Set hash mutable mask
+* @index: Hash mutable index
+* @mask: 256 bits of mask
+*
+* Note: Can be called only if HASH_MUTE is set on the feature set
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EINVAL
+*/
+
+static inline int saesoc_set_hash_mutemask(int index, unsigned long long mask[4])
+{
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		/* part of sysconfig.*/
+		return -CRYPTOSOC_EINVAL;
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+}
+
+/**
+* saesoc_dump_desc_info - Dump the descriptor information
+* @sdesc: Pointer to the session descriptor(input)
+* @ddesc: Pointer to the data descriptor(input)
+*
+*
+* Return: 
+*/
+
+static inline void saesoc_dump_desc_info(
+		struct saesoc_session_desc *sdesc,
+		struct saesoc_data_desc *ddesc)
+{
+	int ndescs;
+	struct saesoc_sdesc_priv_data *spriv;
+	struct saesoc_ddesc_priv_data *dpriv;
+
+	dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+	spriv = (struct saesoc_sdesc_priv_data *)dpriv->sdesc->lib_priv;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		if(sdesc) {
+			ndescs = saesoc_get_sdesc_cnt(sdesc);
+			saesoc_gen2_dump_cdesc(sdesc->descs, ndescs);
+		} if(ddesc) {
+			ndescs = saesoc_get_ddesc_cnt(ddesc);
+			if(ndescs < 0)
+				return;
+			saesoc_gen2_dump_ddesc(ddesc->descs, ndescs,
+					spriv->hash_iv_descs != 0, spriv->cipher_iv_descs != 0,
+					dpriv->ndesfb_descs);
+		}
+		return;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+		if(sdesc) {
+			ndescs = saesoc_get_sdesc_cnt(sdesc);
+			saesoc_gen1_dump_cdesc(sdesc->descs, ndescs);
+		} if(ddesc) {
+			ndescs = saesoc_get_ddesc_cnt(ddesc);
+			if(ndescs < 0)
+				return;
+			saesoc_gen1_dump_ddesc(ddesc->descs, ndescs, dpriv->ndesfb_descs);
+		}
+		return;
+	}
+#endif
+
+
+}
+
+/**
+* saesoc_process_request - Send/Receive the descriptor info to/from
+* the engine
+* @ctx : Pointer to the context(input). 
+* @ddesc:Pointer to the data descriptor(input)
+* @req_vc: Transmit vc id.
+* @rsp_vc: Freeback vc id. This should be the error freeback vc 
+* 	if designer freeback is enabled.
+* @code: Message send code.
+* @retry_count: How many times the send should be retried before
+* 	telling it is failed
+* @mparam: Extra parameters for the send request
+* @sync_res: Engine result response if mode is sync(output). 
+*
+* Return: CRYPTOSOC_OK, CRYPTOSOC_EAGAIN, CRYPTOSOC_EINVAL
+*
+* Note: 
+* if ctx != null, it does the operation as per the ctx mode
+* If ctx == null &  rsp != null, function sends the message
+* and wait for the response. 
+* if ctx == null & rsp == null, the function just send the message
+*/
+
+static inline int saesoc_process_request(
+		struct cryptosoc_ctx *ctx,
+		struct saesoc_data_desc *ddesc,
+		int req_vc,
+		int rsp_vc,
+		int code,
+		int retry_count,
+		struct saesoc_extra_req_send_params *mparam,
+		struct saesoc_rsp_result *sync_res)
+{
+	struct saesoc_sdesc_priv_data *spriv;
+	struct saesoc_ddesc_priv_data *dpriv;
+	struct saesoc_session_desc    *sdesc;
+	int nddescs;
+	_uint64_t fmnentry0, fmnentry1, fmnentry2;
+	_uint64_t *rsp_msg_ptr = NULL;
+	int gen_type2 = 0;
+
+	if(!ddesc)
+		return -CRYPTOSOC_EINVAL;
+
+#ifdef SAESOC_PTYPE_GEN2_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN2
+	{
+		int nsdescs, ivdescs = 0;
+		gen_type2 = 1;
+
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
+		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+
+
+		nsdescs = spriv->ldesc;
+		nddescs = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+		ivdescs = spriv->hash_iv_descs + spriv->cipher_iv_descs;
+
+		/* for gen2 the freeback entry should be copied to the last */
+		if((nddescs + 1) > dpriv->max_descs) {
+			cryptosoc_err_print(
+				"%s:%d, Error - Fragments overflow max %d cur %d \n", 
+				__FUNCTION__, __LINE__,  dpriv->max_descs, nddescs);
+			return -CRYPTOSOC_EINVAL;
+		}
+
+                /* Designer freeback is only enabled in asyn mode */
+                if (dpriv->ndesfb_descs == 0) {
+		    fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+		    ddesc->descs[nddescs] = fmnentry2;
+		    rsp_msg_ptr = &ddesc->descs[nddescs];
+	            nddescs++;
+                }
+
+		fmnentry0 = saesoc_gen2_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, nsdescs, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
+
+		fmnentry1 = saesoc_gen2_form_fmn_entry1(
+			mparam != NULL ? mparam->arc4_load_state : 0, 
+			ivdescs, nddescs, 
+			saesoc_get_cacheline_phys_addr(&ddesc->descs));
+
+		/* Set the last frag bits */
+		if(dpriv->lsrc_frag_idx)
+			saesoc_gen2_set_last_frag(ddesc->descs[dpriv->lsrc_frag_idx]);
+		if(dpriv->ldst_frag_idx)
+			saesoc_gen2_set_last_frag(ddesc->descs[dpriv->ldst_frag_idx]);
+
+
+		//saesoc_dump_desc_info(sdesc, ddesc);
+		//saesoc_gen2_dump_fmnentry(fmnentry0, fmnentry1);
+		
+
+		goto send_req;
+	}
+#endif
+#ifdef SAESOC_PTYPE_GEN1_SUPPORT
+	IF_SAESOC_PTYPE_IS_GEN1
+	{
+	
+		dpriv = (struct saesoc_ddesc_priv_data *)ddesc->lib_priv;
+		sdesc = (struct saesoc_session_desc    *)dpriv->sdesc;
+		spriv = (struct saesoc_sdesc_priv_data *)sdesc->lib_priv;
+		nddescs = dpriv->nfrag_idx + dpriv->ndesfb_descs;
+		nddescs = ((nddescs /2) -1) + ( nddescs & 0x01);
+
+
+		
+
+		fmnentry0 = saesoc_gen1_form_fmn_entry0(rsp_vc, dpriv->ndesfb_descs, 
+			dpriv->ndesfb_descs == 0 ? 0:1, spriv->cipher_key_len_in_dw, 
+			saesoc_get_cacheline_phys_addr(&sdesc->descs));
+
+		fmnentry1 = saesoc_gen1_form_fmn_entry1(
+				mparam != NULL ? mparam->arc4_load_state : 0, 
+				spriv->hash_key_len_in_dw, nddescs, 
+				saesoc_get_cacheline_phys_addr(&ddesc->descs[0]));
+
+		fmnentry2 = mparam != NULL ? mparam->async_rsp_arg : 0ULL;
+
+		goto send_req;
+
+	}
+#endif
+	return -CRYPTOSOC_EINVAL;
+
+send_req:
+
+	if(!ctx) {
+		return cryptosoc_process_request(gen_type2, CRYPTOSOC_SAE, 
+				req_vc, rsp_vc, code, retry_count,
+				fmnentry0, fmnentry1, fmnentry2,
+				sync_res ? &sync_res->result : NULL);
+	} else {
+		return cryptosoc_process_ctx_request(gen_type2, ctx, CRYPTOSOC_SAE,
+				req_vc, rsp_vc, code, retry_count, 
+				fmnentry0, fmnentry1, fmnentry2, 
+				sync_res ? &sync_res->result : NULL,
+				rsp_msg_ptr);
+	}
+}
+
+static inline int my_cpu_id(void)
+{
+	unsigned int pid = 0;
+
+	__asm__ volatile (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"rdhwr %0, $0\n"
+			".set pop\n"
+			: "=r" (pid)
+			:);
+
+	return pid;
+}
+
+#endif
+
-- 
1.7.9.5

