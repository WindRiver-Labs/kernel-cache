From 555fe8cc1b105718c1213e6ac241247c4d2105cf Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 23 Jan 2014 15:44:26 +0800
Subject: [PATCH 02/58] bcm-xlp2: BCM XLP series common platform implementation

add arch/mips/include/asm/netlogic dir

This patch update the arch support of the xlp9xx and xlp2xx

Based on sdk 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/netlogic/common.h            |   61 ++++--
 arch/mips/include/asm/netlogic/interrupt.h         |    1 +
 arch/mips/include/asm/netlogic/kvm_para.h          |   62 ++++++
 arch/mips/include/asm/netlogic/kvm_xlp.h           |  147 +++++++++++++
 arch/mips/include/asm/netlogic/mips-extns.h        |  157 +++++++++++++-
 arch/mips/include/asm/netlogic/xlp-hal/bridge.h    |   85 ++++----
 .../mips/include/asm/netlogic/xlp-hal/cpucontrol.h |   57 ++++-
 arch/mips/include/asm/netlogic/xlp-hal/iomap.h     |  121 ++++++++---
 arch/mips/include/asm/netlogic/xlp-hal/pcibus.h    |   60 ++++--
 arch/mips/include/asm/netlogic/xlp-hal/pic.h       |  209 ++++++++++--------
 arch/mips/include/asm/netlogic/xlp-hal/sys.h       |  228 +++++++++++++-------
 arch/mips/include/asm/netlogic/xlp-hal/uart.h      |    7 +-
 arch/mips/include/asm/netlogic/xlp-hal/xlp.h       |   70 +++++-
 arch/mips/include/asm/netlogic/xlr/bridge.h        |   14 +-
 arch/mips/include/asm/netlogic/xlr/fmn.h           |  216 ++++++++++---------
 arch/mips/include/asm/netlogic/xlr/iomap.h         |   88 ++++----
 arch/mips/include/asm/netlogic/xlr/msidef.h        |   18 +-
 arch/mips/include/asm/netlogic/xlr/pic.h           |   12 +-
 18 files changed, 1169 insertions(+), 444 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/common.h b/arch/mips/include/asm/netlogic/common.h
index aef560a..7993886 100644
--- a/arch/mips/include/asm/netlogic/common.h
+++ b/arch/mips/include/asm/netlogic/common.h
@@ -39,11 +39,28 @@
  * Common SMP definitions
  */
 #define RESET_VEC_PHYS		0x1fc00000
+#define RESET_VEC_SIZE		8192		/* 8KB reset code and data */
 #define RESET_DATA_PHYS		(RESET_VEC_PHYS + (1<<10))
+
+/* Offsets of parameters in the RESET_DATA_PHYS area */
 #define BOOT_THREAD_MODE	0
 #define BOOT_NMI_LOCK		4
 #define BOOT_NMI_HANDLER	8
 
+/* TLB entry save area for mapped kernel */
+#define BOOT_NTLBS		64
+#define BOOT_TLBS_START		72
+#define BOOT_TLB_SIZE		32
+
+/* four u64 entries per TLB */
+#define BOOT_TLB_ENTRYHI	0
+#define BOOT_TLB_ENTRYLO0	1
+#define BOOT_TLB_ENTRYLO1	2
+#define BOOT_TLB_PAGEMASK	3
+
+/* CPU ready flags for each CPU */
+#define BOOT_CPU_READY		2048
+
 #ifndef __ASSEMBLY__
 #include <linux/cpumask.h>
 #include <linux/spinlock.h>
@@ -59,46 +76,49 @@ int nlm_wakeup_secondary_cpus(void);
 void nlm_rmiboot_preboot(void);
 void nlm_percpu_init(int hwcpuid);
 
+static inline void *
+nlm_get_boot_data(int offset)
+{
+	return (void *)(CKSEG1ADDR(RESET_DATA_PHYS) + offset);
+}
+
 static inline void
 nlm_set_nmi_handler(void *handler)
 {
-	char *reset_data;
+	void *nmih = nlm_get_boot_data(BOOT_NMI_HANDLER);
 
-	reset_data = (char *)CKSEG1ADDR(RESET_DATA_PHYS);
-	*(int64_t *)(reset_data + BOOT_NMI_HANDLER) = (long)handler;
+	*(int64_t *)nmih = (long)handler;
 }
 
 /*
  * Misc.
  */
+void nlm_init_boot_cpu(void);
 unsigned int nlm_get_cpu_frequency(void);
-void nlm_node_init(int node);
 extern struct plat_smp_ops nlm_smp_ops;
 extern char nlm_reset_entry[], nlm_reset_entry_end[];
 
+/* SWIOTLB */
+extern struct dma_map_ops nlm_swiotlb_dma_ops;
+
+/* mapped kernel */
+void nlm_fixup_mem(void);
+void nlm_calc_wired_tlbs(void);
+void nlm_setup_wired_tlbs(void);
+
 extern unsigned int nlm_threads_per_core;
 extern cpumask_t nlm_cpumask;
 
-struct nlm_soc_info {
-	unsigned long coremask; /* cores enabled on the soc */
-	unsigned long ebase;
-	uint64_t irqmask;
-	uint64_t sysbase;	/* only for XLP */
-	uint64_t picbase;
-	spinlock_t piclock;
-};
-
-#define nlm_get_node(i)		(&nlm_nodes[i])
-#ifdef CONFIG_CPU_XLR
-#define nlm_current_node()	(&nlm_nodes[0])
-#else
-#define nlm_current_node()	(&nlm_nodes[nlm_nodeid()])
-#endif
-
 struct irq_data;
 uint64_t nlm_pci_irqmask(int node);
+void nlm_setup_pic_irq(int node, int picirq, int irq, int irt);
 void nlm_set_pic_extra_ack(int node, int irq,  void (*xack)(struct irq_data *));
 
+#ifdef CONFIG_PCI_MSI
+void nlm_dispatch_msi(int node, int lirq);
+void nlm_dispatch_msix(int node, int msixirq);
+#endif
+
 /*
  * The NR_IRQs is divided between nodes, each of them has a separate irq space
  */
@@ -107,7 +127,6 @@ static inline int nlm_irq_to_xirq(int node, int irq)
 	return node * NR_IRQS / NLM_NR_NODES + irq;
 }
 
-extern struct nlm_soc_info nlm_nodes[NLM_NR_NODES];
 extern int nlm_cpu_ready[];
 #endif
 #endif /* _NETLOGIC_COMMON_H_ */
diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
index ed5993d..3354f1e 100644
--- a/arch/mips/include/asm/netlogic/interrupt.h
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -40,6 +40,7 @@
 #define IRQ_IPI_SMP_FUNCTION	3
 #define IRQ_IPI_SMP_RESCHEDULE	4
 #define IRQ_FMN			5
+#define IRQ_PERF		6
 #define IRQ_TIMER		7
 
 #endif
diff --git a/arch/mips/include/asm/netlogic/kvm_para.h b/arch/mips/include/asm/netlogic/kvm_para.h
new file mode 100644
index 0000000..233615d
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/kvm_para.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ASM_KVM_PARA
+#define __ASM_KVM_PARA
+
+extern int is_nlm_guest_os;
+
+#define KVM_HC_GET_HARD_CPUID	0x1  /* p1r1 */
+
+static inline int do_hypcall_p1r1(int num, uint64_t param0, uint64_t *ret0)
+{
+	int	 ret;
+	uint64_t result;
+
+	__asm__ __volatile__(
+		"move $2, %2\n"
+		"move $3, %3\n"
+		"hypcall\n"
+		"move %0, $2\n"
+		"move %1, $3\n"
+		: "=r"(ret), "=r"(result)
+		: "r"(num), "r"(param0)
+		: "$2","$3", "memory"
+	);
+
+	*ret0 = result;
+	return ret;
+}
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/kvm_xlp.h b/arch/mips/include/asm/netlogic/kvm_xlp.h
new file mode 100644
index 0000000..1c206bf
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/kvm_xlp.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __ASM_KVM_XLP
+#define __ASM_KVM_XLP
+
+#include <asm/branch.h>
+
+/* Maximum # of guest ids supported by hardware */
+#define KVM_MAX_NUM_GID		256
+
+static inline struct kvm_arch * kvm_get_arch(struct pt_regs *regs)
+{
+	struct kvm *kvm = ((struct kvm_vcpu *)regs->cp0_osscratch7)->kvm;
+	return &kvm->arch;
+}
+
+static inline struct kvm_vcpu_guest * kvm_get_vcpu_guest_regs(struct pt_regs *regs)
+{
+	return &((struct kvm_vcpu *)regs->cp0_osscratch7)->arch.guest;
+}
+
+static inline struct kvm_vcpu_root * kvm_get_vcpu_root_regs(struct pt_regs *regs)
+{
+	return &((struct kvm_vcpu *)regs->cp0_osscratch7)->arch.root;
+}
+
+static inline struct kvm_vcpu_arch * kvm_get_vcpu_arch(struct pt_regs *regs)
+{
+	return &((struct kvm_vcpu *)regs->cp0_osscratch7)->arch;
+}
+
+static inline struct kvm_vcpu_arch * kvm_get_vcpu_arch_with_cpuid(struct pt_regs *regs,
+	unsigned int cpuid)
+{
+	struct kvm *kvm = ((struct kvm_vcpu *)regs->cp0_osscratch7)->kvm;
+	unsigned int i;
+
+	for (i = 0; i < KVM_MAX_VCPUS; i++) {
+		if ((kvm->vcpus[i]->arch.guest.gpu.guest_ebase & 0x3ff) == cpuid)
+			return &kvm->vcpus[i]->arch;
+	}
+	return NULL;
+}
+
+static inline struct kvm_vcpu_arch * kvm_get_vcpu_arch_ext(struct kvm *kvm, unsigned int cpuid)
+{
+	unsigned int i;
+
+	for (i = 0; i < KVM_MAX_VCPUS; i++) {
+		if ((kvm->vcpus[i]->arch.guest.gpu.guest_ebase & 0x3ff) == cpuid)
+			return &kvm->vcpus[i]->arch;
+	}
+	return NULL;
+}
+
+static inline void kvm_get_badinstr(struct pt_regs *regs, unsigned int *badinstr,
+	unsigned int *epc_badinstr)
+{
+	*badinstr = regs->cp0_badinstr;
+	if (delay_slot(regs))
+		*epc_badinstr = regs->cp0_badinstrp;
+	else
+		*epc_badinstr = regs->cp0_badinstr;
+}
+
+extern int xlp_kvm_check_processor_compat(void);
+extern int __kvm_vcpu_run_guest(void *);
+extern void __kvm_vcpu_leave_guest(void *, int);
+extern int compute_guest_return_epc(struct pt_regs *regs, unsigned int badinstr);
+extern void xlp_kvm_init_vm(struct kvm *kvm);
+extern void kvm_save_guest_context(struct pt_regs *regs, struct kvm_vcpu_guest *guest);
+extern void kvm_uart_insert_char(struct kvm *kvm, char c);
+extern void xlp_kvm_destroy_vm(struct kvm *kvm);
+extern void kvm_xlp_check_exit_request(struct kvm_vcpu *);
+extern void nlm_flush_cache_L2L3(unsigned long, unsigned long);
+
+/* defined in arch/mips/netlogic/kvm/kvm_uart.c */
+extern void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_pic.c */
+extern void kvm_handle_pcie_pic(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+extern void kvm_pic_inject_guest(struct kvm_arch *arch, unsigned int irt,
+	struct pt_regs *regs);
+extern void kvm_pic_inject_guest_cpuid(struct kvm_arch *arch, unsigned int irt,
+	unsigned int cpuid);
+extern void kvm_pic_inject_guest_ext(struct kvm *kvm, struct kvm_arch *arch,
+	unsigned int irt, unsigned int cpuid);
+
+/* defined in arch/mips/netlogic/kvm/kvm_sysmgt.c */
+extern void kvm_handle_pcie_sysmgt(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_fuse.c */
+extern void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_clk.c */
+extern void kvm_handle_pcie_clk(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_bridge.c */
+extern void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num);
+
+/* defined in arch/mips/netlogic/kvm/kvm_pcie.c */
+extern void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num, uint32_t badinstr,
+	uint32_t epc_badinstr);
+extern void kvm_handle_pcie_io(struct pt_regs *regs, unsigned long write,
+	unsigned long address, unsigned long reg_num, uint32_t badinstr,
+	uint32_t epc_badinstr);
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/mips-extns.h b/arch/mips/include/asm/netlogic/mips-extns.h
index f299d31..a12f973 100644
--- a/arch/mips/include/asm/netlogic/mips-extns.h
+++ b/arch/mips/include/asm/netlogic/mips-extns.h
@@ -139,6 +139,53 @@ static inline uint64_t read_c0_eirr_and_eimr(void)
 	return val;
 }
 
+static inline uint64_t nlm_read_tsc(void)
+{
+	uint64_t __res;
+
+	__asm__ __volatile__(
+		".set\tpush\n\t"
+		".set\tnoreorder\n\t"
+		"dmfur $12, $18\n\t"
+		"move %0, $12\n\t"
+		".set\tpop"
+		: "=r" (__res)
+		:
+		: "$12");
+
+		return __res;
+}
+
+static inline void nlm_write_tsc(uint64_t val)
+{
+	__asm__ __volatile__(
+		".set\tpush\n\t"
+		".set\tnoreorder\n\t"
+		"move $12, %0\n\t"
+		"dmtur $12, $18\n\t"
+		".set\tpop"
+		:
+		: "r" (val)
+		: "$12");
+
+	return;
+}
+
+static __inline__ void write_xlp_pausetime(unsigned long long val)
+{
+	__asm__ __volatile__(
+		".set\tpush\n\t"
+		".set\tnoreorder\n\t"
+		"move $12, %0\n\t"
+		"dmtur $12, $17\n\t"
+		".set\tpop"
+		:
+		: "r" (val)
+		: "$12");
+
+	return;
+}
+
 static inline int hard_smp_processor_id(void)
 {
 	return __read_32bit_c0_register($15, 1) & 0x3ff;
@@ -146,7 +193,12 @@ static inline int hard_smp_processor_id(void)
 
 static inline int nlm_nodeid(void)
 {
-	return (__read_32bit_c0_register($15, 1) >> 5) & 0x3;
+	uint32_t prid = read_c0_prid();
+
+	if ((prid & 0xff00) == PRID_IMP_NETLOGIC_XLP9XX)
+		return (__read_32bit_c0_register($15, 1) >> 7) & 0x7;
+	else
+		return (__read_32bit_c0_register($15, 1) >> 5) & 0x3;
 }
 
 static inline unsigned int nlm_core_id(void)
@@ -159,6 +211,48 @@ static inline unsigned int nlm_thread_id(void)
 	return read_c0_ebase() & 0x3;
 }
 
+static __inline__ void atomic_or_llong(volatile unsigned long long *ptr, unsigned long long val)
+{
+	unsigned long long temp;
+
+	__asm__ volatile (
+		".set push\n"
+		".set noreorder\n"
+		"1: lld %0, %3\n"
+		"or %0, %2\n"
+		"scd %0, %1\n"
+		"beqz %0, 1b\n"
+		"nop\n"
+		".set pop\n"
+		: "=&r"(temp), "=m"(*ptr)
+		: "r"(val), "m"(*ptr)
+		: "memory"
+	);
+
+	return;
+}
+
+static __inline__ void atomic_and_llong(volatile unsigned long long *ptr, unsigned long long val)
+{
+	unsigned long long temp;
+
+	__asm__ volatile (
+		".set push\n"
+		".set noreorder\n"
+		"1: lld %0, %3\n"
+		"and %0, %2\n"
+		"scd %0, %1\n"
+		"beqz %0, 1b\n"
+		"nop\n"
+		".set pop\n"
+		: "=&r"(temp), "=m"(*ptr)
+		: "r"(val), "m"(*ptr)
+		: "memory"
+	);
+
+	return;
+}
+
 #define __read_64bit_c2_split(source, sel)				\
 ({									\
 	unsigned long long __val;					\
@@ -279,11 +373,70 @@ do {									\
 			".set\tmips0\n\t"				\
 			: : "Jr" (value));				\
 	else								\
-		__asm__ __volatile__(					\
+		__asm__ __volatile__(                                   \
 			".set\tmips32\n\t"				\
 			"mtc2\t%z0, " #reg ", " #sel "\n\t"		\
 			".set\tmips0\n\t"				\
 			: : "Jr" (value));				\
 })
 
+#ifdef CONFIG_64BIT
+static inline uint64_t nlm_mfcr(uint32_t reg)
+{
+	uint64_t res;
+	__asm__ __volatile__(
+		".set	push\n\t"
+		".set	arch=xlr\n\t"
+		"mfcr	%0, %1\n\t"
+		".set	pop\n\t"
+		: "=r" (res) : "r"(reg));
+	return res;
+}
+static inline void nlm_mtcr(uint32_t reg, uint64_t val)
+{
+	__asm__ __volatile__(
+		".set	push\n\t"
+		".set	arch=xlr\n\t"
+		"mtcr	%0, %1\n\t"
+		".set	pop\n\t"
+		:
+		: "r" (val), "r"(reg));
+
+	return;
+}
+
+#else
+static inline  uint64_t nlm_mfcr(uint32_t reg)
+{
+	uint32_t hi, lo;
+
+	__asm__ __volatile__ (
+		".set	push\n"
+		".set	arch=xlr\n"
+		"mfcr	$8, %2\n\t"
+		"dsra32	%0, $8, 0\n"
+		"sll	%1, $8, 0\n"
+		".set	pop\n"
+		: "=r"(hi), "=r"(lo)
+		: "r"(reg) : "$8", "$9");
+
+	return (((uint64_t)hi) << 32) | lo;
+}
+static inline void nlm_mtcr(uint32_t reg, uint64_t val)
+{
+	__asm__ __volatile__(
+		".set	push\n\t"
+		".set	arch=xlr\n\t"
+		"dsll	%L0, %L0, 32\n\t"
+		"dsrl	%L0, %L0, 32\n\t"
+		"dsll	%M0, %M0, 32\n\t"
+		"or	%L0, %L0, %M0\n\t"
+		"mtcr	%L0, %1\n\t"
+		".set	pop\n\t"
+		:
+		: "r" (val), "r"(reg));
+
+	return;
+}
+#endif
 #endif /*_ASM_NLM_MIPS_EXTS_H */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/bridge.h b/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
index 790f0f1..e1588ba 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/bridge.h
@@ -69,41 +69,10 @@
 #define BRIDGE_FLASH_LIMIT3		0x13
 
 #define BRIDGE_DRAM_BAR(i)		(0x14 + (i))
-#define BRIDGE_DRAM_BAR0		0x14
-#define BRIDGE_DRAM_BAR1		0x15
-#define BRIDGE_DRAM_BAR2		0x16
-#define BRIDGE_DRAM_BAR3		0x17
-#define BRIDGE_DRAM_BAR4		0x18
-#define BRIDGE_DRAM_BAR5		0x19
-#define BRIDGE_DRAM_BAR6		0x1a
-#define BRIDGE_DRAM_BAR7		0x1b
-
 #define BRIDGE_DRAM_LIMIT(i)		(0x1c + (i))
-#define BRIDGE_DRAM_LIMIT0		0x1c
-#define BRIDGE_DRAM_LIMIT1		0x1d
-#define BRIDGE_DRAM_LIMIT2		0x1e
-#define BRIDGE_DRAM_LIMIT3		0x1f
-#define BRIDGE_DRAM_LIMIT4		0x20
-#define BRIDGE_DRAM_LIMIT5		0x21
-#define BRIDGE_DRAM_LIMIT6		0x22
-#define BRIDGE_DRAM_LIMIT7		0x23
-
-#define BRIDGE_DRAM_NODE_TRANSLN0	0x24
-#define BRIDGE_DRAM_NODE_TRANSLN1	0x25
-#define BRIDGE_DRAM_NODE_TRANSLN2	0x26
-#define BRIDGE_DRAM_NODE_TRANSLN3	0x27
-#define BRIDGE_DRAM_NODE_TRANSLN4	0x28
-#define BRIDGE_DRAM_NODE_TRANSLN5	0x29
-#define BRIDGE_DRAM_NODE_TRANSLN6	0x2a
-#define BRIDGE_DRAM_NODE_TRANSLN7	0x2b
-#define BRIDGE_DRAM_CHNL_TRANSLN0	0x2c
-#define BRIDGE_DRAM_CHNL_TRANSLN1	0x2d
-#define BRIDGE_DRAM_CHNL_TRANSLN2	0x2e
-#define BRIDGE_DRAM_CHNL_TRANSLN3	0x2f
-#define BRIDGE_DRAM_CHNL_TRANSLN4	0x30
-#define BRIDGE_DRAM_CHNL_TRANSLN5	0x31
-#define BRIDGE_DRAM_CHNL_TRANSLN6	0x32
-#define BRIDGE_DRAM_CHNL_TRANSLN7	0x33
+#define BRIDGE_DRAM_NODE_TRANSLN(i)	(0x24 + (i))
+#define BRIDGE_DRAM_CHNL_TRANSLN(i)	(0x2c + (i))
+
 #define BRIDGE_PCIEMEM_BASE0		0x34
 #define BRIDGE_PCIEMEM_BASE1		0x35
 #define BRIDGE_PCIEMEM_BASE2		0x36
@@ -150,7 +119,15 @@
 #define BRIDGE_TRACEBUF_READ_DATA2	0x5f
 #define BRIDGE_TRACEBUF_READ_DATA3	0x60
 #define BRIDGE_TRACEBUF_STATUS		0x61
+
 #define BRIDGE_ADDRESS_ERROR0		0x62
+#define BRIDGE_ERR_VALID_MASK		0x4
+#define BRIDGE_ERR_OV_MASK		0x8
+#define BRIDGE_REQ_TYPE_SHIFT		4
+#define BRIDGE_REQ_TYPE_MASK		0x70
+#define BRIDGE_REQ_SRC_SHIFT		7
+#define BRIDGE_REQ_SRC_MASK		0x780
+
 #define BRIDGE_ADDRESS_ERROR1		0x63
 #define BRIDGE_ADDRESS_ERROR2		0x64
 #define BRIDGE_TAG_ECC_ADDR_ERROR0	0x65
@@ -174,12 +151,48 @@
 #define BRIDGE_GIO_WEIGHT		0x2cb
 #define BRIDGE_FLASH_WEIGHT		0x2cc
 
+/* FIXME verify */
+#define BRIDGE_9XX_FLASH_BAR(i)		(0x11 + (i))
+#define BRIDGE_9XX_FLASH_BAR_LIMIT(i)	(0x15 + (i))
+
+#define BRIDGE_9XX_DRAM_BAR(i)		(0x19 + (i))
+#define BRIDGE_9XX_DRAM_LIMIT(i)	(0x29 + (i))
+#define BRIDGE_9XX_DRAM_NODE_TRANSLN(i)	(0x39 + (i))
+#define BRIDGE_9XX_DRAM_CHNL_TRANSLN(i)	(0x49 + (i))
+
+#define BRIDGE_9XX_ADDRESS_ERROR0	0x9d
+#define BRIDGE_9XX_ADDRESS_ERROR1	0x9e
+#define BRIDGE_9XX_ADDRESS_ERROR2	0x9f
+
+#define BRIDGE_9XX_PCIEMEM_BASE0	0x59
+#define BRIDGE_9XX_PCIEMEM_BASE1	0x5a
+#define BRIDGE_9XX_PCIEMEM_BASE2	0x5b
+#define BRIDGE_9XX_PCIEMEM_BASE3	0x5c
+#define BRIDGE_9XX_PCIEMEM_LIMIT0	0x5d
+#define BRIDGE_9XX_PCIEMEM_LIMIT1	0x5e
+#define BRIDGE_9XX_PCIEMEM_LIMIT2	0x5f
+#define BRIDGE_9XX_PCIEMEM_LIMIT3	0x60
+#define BRIDGE_9XX_PCIEIO_BASE0		0x61
+#define BRIDGE_9XX_PCIEIO_BASE1		0x62
+#define BRIDGE_9XX_PCIEIO_BASE2		0x63
+#define BRIDGE_9XX_PCIEIO_BASE3		0x64
+#define BRIDGE_9XX_PCIEIO_LIMIT0	0x65
+#define BRIDGE_9XX_PCIEIO_LIMIT1	0x66
+#define BRIDGE_9XX_PCIEIO_LIMIT2	0x67
+#define BRIDGE_9XX_PCIEIO_LIMIT3	0x68
+
+#define BRIDGE_DMC_ECCLOG1		0xdd
+#define BRIDGE_DMC_ECCLOG2		0xde
+
+#define BRIDGE_9XX_DMC_ECCLOG1		0x15d
+#define BRIDGE_9XX_DMC_ECCLOG2		0x15e
+
 #ifndef __ASSEMBLY__
 
 #define nlm_read_bridge_reg(b, r)	nlm_read_reg(b, r)
 #define nlm_write_bridge_reg(b, r, v)	nlm_write_reg(b, r, v)
-#define nlm_get_bridge_pcibase(node)	\
-			nlm_pcicfg_base(XLP_IO_BRIDGE_OFFSET(node))
+#define nlm_get_bridge_pcibase(node)	nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+		XLP9XX_IO_BRIDGE_OFFSET(node) : XLP_IO_BRIDGE_OFFSET(node))
 #define nlm_get_bridge_regbase(node)	\
 			(nlm_get_bridge_pcibase(node) + XLP_IO_PCI_HDRSZ)
 
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
index 6d2e58a..77a6d4d 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/cpucontrol.h
@@ -46,14 +46,28 @@
 #define CPU_BLOCKID_FPU		9
 #define CPU_BLOCKID_MAP		10
 
+#define	IFU_BRUB_RESERVE	0x007
+
 #define ICU_DEFEATURE		0x100
+#define ICU_CERR_LOG0		0x110
+#define ICU_CERR_LOG1		0x111
+#define ICU_CERR_LOG2		0x112
 
 #define LSU_DEFEATURE		0x304
 #define LSU_DEBUG_ADDR		0x305
 #define LSU_DEBUG_DATA0		0x306
-#define LSU_CERRLOG_REGID	0x309
+#define LSU_CERR_LOG0		0x308
+#define LSU_CERR_LOG1		0x309
+#define LSU_CERR_INJ0		0x30a
+#define LSU_CERR_INJ1		0x30b
+#define LSU_CERR_INT		0x30c
 #define SCHED_DEFEATURE		0x700
 
+/* L2 Cache Error Registers */
+#define SCU_CERR_LOG0		0x810
+#define SCU_CERR_LOG1		0x811
+#define SCU_CERR_LOG2		0x812
+
 /* Offsets of interest from the 'MAP' Block */
 #define MAP_THREADMODE			0x00
 #define MAP_EXT_EBASE_ENABLE		0x04
@@ -84,4 +98,45 @@
 #define MMU_PGWKR_PTESHFT	0x418
 #define MMU_PGWKR_PTEMASK	0x419
 
+#define SCU_CERR_LOG0		0x810
+#define SCU_CERR_LOG1		0x811
+#define SCU_CERR_LOG2		0x812
+
+#ifndef __ASSEMBLY__
+
+/* Hardware Pagewalker related configuration parameters */
+#define USER_SEG 0
+#ifdef CONFIG_64BIT
+#define NR_ADDR_SEGMENTS 8  /* MUST be a power of 2 */
+#define MODULE_SEG 7
+#define VMALLOC_SEG 6
+#else /* CONFIG_32BIT */
+#define NR_ADDR_SEGMENTS 2 /* MUST be a power of 2 */
+#define VMALLOC_SEG 1
+#endif /* CONFIG_64BIT */
+
+enum {
+  //offset, width pair
+  PWFIELD_BD_O  = 32, PWFIELD_BD_W  = 6,
+  PWFIELD_GD_O  = 24, PWFIELD_GD_W  = 6,
+  PWFIELD_UD_O  = 18, PWFIELD_UD_W  = 6,
+  PWFIELD_MD_O  = 12, PWFIELD_MD_W  = 6,
+  PWFIELD_PT_O  =  6, PWFIELD_PT_W  = 6,
+  PWFIELD_PTE_O =  0, PWFIELD_PTE_W = 6,
+
+  PWSIZE_BD_O  = 32, PWSIZE_BD_W  = 6,
+  PWSIZE_PS_O  = 30, PWSIZE_PS_W  = 1,
+  PWSIZE_GD_O  = 24, PWSIZE_GD_W  = 6,
+  PWSIZE_UD_O  = 18, PWSIZE_UD_W  = 6,
+  PWSIZE_MD_O  = 12, PWSIZE_MD_W  = 6,
+  PWSIZE_PT_O  =  6, PWSIZE_PT_W  = 6,
+  PWSIZE_PTE_O =  0, PWSIZE_PTE_W = 6,
+
+  PWCTL_PW_EN_O = 31, PWCTL_PW_EN_W = 1,
+  PWCTL_PW_EN_HUGETLB = 6,
+  PWCTL_PW_HUGEVLD_PSN = 0,
+};
+
+#endif /* __ASSEMBLY__ */
+
 #endif /* __NLM_CPUCONTROL_H__ */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/iomap.h b/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
index 9fac46f..f4bd816 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/iomap.h
@@ -35,12 +35,12 @@
 #ifndef __NLM_HAL_IOMAP_H__
 #define __NLM_HAL_IOMAP_H__
 
-#define XLP_DEFAULT_IO_BASE		0x18000000
+#define XLP_DEFAULT_IO_BASE             0x18000000
 #define XLP_DEFAULT_PCI_ECFG_BASE	XLP_DEFAULT_IO_BASE
 #define XLP_DEFAULT_PCI_CFG_BASE	0x1c000000
 
 #define NMI_BASE			0xbfc00000
-#define XLP_IO_CLK			133333333
+#define	XLP_IO_CLK			133333333
 
 #define XLP_PCIE_CFG_SIZE		0x1000		/* 4K */
 #define XLP_PCIE_DEV_BLK_SIZE		(8 * XLP_PCIE_CFG_SIZE)
@@ -48,8 +48,10 @@
 #define XLP_IO_SIZE			(64 << 20)	/* ECFG space size */
 #define XLP_IO_PCI_HDRSZ		0x100
 #define XLP_IO_DEV(node, dev)		((dev) + (node) * 8)
-#define XLP_HDR_OFFSET(node, bus, dev, fn)	(((bus) << 20) | \
-				((XLP_IO_DEV(node, dev)) << 15) | ((fn) << 12))
+#define XLP_IO_PCI_OFFSET(b, d, f)	(((b) << 20) | ((d) << 15) | ((f) << 12))
+
+#define XLP_HDR_OFFSET(node, bus, dev, fn) \
+		XLP_IO_PCI_OFFSET(bus, XLP_IO_DEV(node, dev), fn)
 
 #define XLP_IO_BRIDGE_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 0, 0)
 /* coherent inter chip */
@@ -72,9 +74,18 @@
 #define XLP_IO_USB_OHCI2_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 2, 4)
 #define XLP_IO_USB_OHCI3_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 2, 5)
 
+/* XLP2xx has an updated USB block */
+#define XLP2XX_IO_USB_OFFSET(node, i)	XLP_HDR_OFFSET(node, 0, 4, i)
+#define XLP2XX_IO_USB_XHCI0_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 4, 1)
+#define XLP2XX_IO_USB_XHCI1_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 4, 2)
+#define XLP2XX_IO_USB_XHCI2_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 4, 3)
+
 #define XLP_IO_NAE_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 3, 0)
 #define XLP_IO_POE_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 3, 1)
 
+/* XLP3XX has on-chip SATA controller */
+#define XLP3XX_IO_SATA_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 3, 2)
+
 #define XLP_IO_CMS_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 4, 0)
 
 #define XLP_IO_DMA_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 5, 1)
@@ -88,6 +99,9 @@
 #define XLP_IO_I2C0_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 6, 2)
 #define XLP_IO_I2C1_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 6, 3)
 #define XLP_IO_GPIO_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 6, 4)
+/* on 2XX, all I2C busses are on the same block */
+#define XLP2XX_IO_I2C_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 6, 7)
+
 /* system management */
 #define XLP_IO_SYS_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 6, 5)
 #define XLP_IO_JTAG_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 6, 6)
@@ -96,9 +110,47 @@
 #define XLP_IO_NAND_OFFSET(node)	XLP_HDR_OFFSET(node, 0, 7, 1)
 #define XLP_IO_SPI_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 7, 2)
 /* SD flash */
-#define XLP_IO_SD_OFFSET(node)		XLP_HDR_OFFSET(node, 0, 7, 3)
-#define XLP_IO_MMC_OFFSET(node, slot)	\
-		((XLP_IO_SD_OFFSET(node))+(slot*0x100)+XLP_IO_PCI_HDRSZ)
+#define XLP_IO_MMC_OFFSET(node)          XLP_HDR_OFFSET(node, 0, 7, 3)
+#define XLP_IO_MMCSD_OFFSET(node, slot)   \
+		((XLP_IO_MMC_OFFSET(node))+(slot*0x100)+XLP_IO_PCI_HDRSZ)
+#define XLP_SD_SLOT_BASE(node, slot)	\
+		(XLP_IO_MMCSD_OFFSET(node, slot) + XLP_DEFAULT_PCI_ECFG_BASE)
+
+/* Things have changed drastically in XLP 9XX */
+#define XLP9XX_HDR_OFFSET(n, d, f)	\
+			XLP_IO_PCI_OFFSET(xlp9xx_get_socbus(n), d, f)
+
+#define XLP9XX_IO_BRIDGE_OFFSET(node)	XLP_IO_PCI_OFFSET(0, 0, node)
+#define XLP9XX_IO_PIC_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 2, 0)
+#define XLP9XX_IO_UART_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 2, 2)
+#define XLP9XX_IO_SYS_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 6, 0)
+#define XLP9XX_IO_FUSE_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 6, 1)
+#define XLP9XX_IO_CLOCK_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 6, 2)
+#define XLP9XX_IO_POWER_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 6, 3)
+#define XLP9XX_IO_JTAG_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 6, 4)
+
+#define XLP9XX_IO_PCIE_OFFSET(node, i)	XLP9XX_HDR_OFFSET(node, 1, i)
+#define XLP9XX_IO_PCIE0_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 1, 0)
+#define XLP9XX_IO_PCIE2_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 1, 2)
+#define XLP9XX_IO_PCIE3_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 1, 3)
+
+/* XLP9xx USB block */
+#define XLP9XX_IO_USB_OFFSET(node, i)		XLP9XX_HDR_OFFSET(node, 4, i)
+#define XLP9XX_IO_USB_XHCI0_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 4, 1)
+#define XLP9XX_IO_USB_XHCI1_OFFSET(node)	XLP9XX_HDR_OFFSET(node, 4, 2)
+
+/* XLP9XX on-chip SATA controller */
+#define XLP9XX_IO_SATA_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 3, 2)
+
+#define XLP9XX_IO_NOR_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 7, 0)
+#define XLP9XX_IO_NAND_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 7, 1)
+#define XLP9XX_IO_SPI_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 7, 2)
+/* SD flash */
+#define XLP9XX_IO_MMC_OFFSET(node)		XLP9XX_HDR_OFFSET(node, 7, 3)
+#define XLP9XX_IO_MMCSD_OFFSET(node, slot)   \
+		((XLP9XX_IO_MMC_OFFSET(node))+(slot*0x100)+XLP_IO_PCI_HDRSZ)
+#define XLP9XX_SD_SLOT_BASE(node, slot) (XLP9XX_IO_MMCSD_OFFSET(node, slot) \
+		     + XLP_DEFAULT_PCI_ECFG_BASE)
 
 /* PCI config header register id's */
 #define XLP_PCI_CFGREG0			0x00
@@ -125,32 +177,47 @@
 #define XLP_PCI_SBB_WT_REG		0x3f
 
 /* PCI IDs for SoC device */
-#define PCI_VENDOR_NETLOGIC		0x184e
-
-#define PCI_DEVICE_ID_NLM_ROOT		0x1001
-#define PCI_DEVICE_ID_NLM_ICI		0x1002
-#define PCI_DEVICE_ID_NLM_PIC		0x1003
-#define PCI_DEVICE_ID_NLM_PCIE		0x1004
-#define PCI_DEVICE_ID_NLM_EHCI		0x1007
-#define PCI_DEVICE_ID_NLM_OHCI		0x1008
-#define PCI_DEVICE_ID_NLM_NAE		0x1009
-#define PCI_DEVICE_ID_NLM_POE		0x100A
-#define PCI_DEVICE_ID_NLM_FMN		0x100B
-#define PCI_DEVICE_ID_NLM_RAID		0x100D
-#define PCI_DEVICE_ID_NLM_SAE		0x100D
-#define PCI_DEVICE_ID_NLM_RSA		0x100E
-#define PCI_DEVICE_ID_NLM_CMP		0x100F
-#define PCI_DEVICE_ID_NLM_UART		0x1010
-#define PCI_DEVICE_ID_NLM_I2C		0x1011
-#define PCI_DEVICE_ID_NLM_NOR		0x1015
-#define PCI_DEVICE_ID_NLM_NAND		0x1016
-#define PCI_DEVICE_ID_NLM_MMC		0x1018
+#define	PCI_VENDOR_NETLOGIC		0x184e
+
+#define	PCI_DEVICE_ID_NLM_ROOT		0x1001
+#define	PCI_DEVICE_ID_NLM_ICI		0x1002
+#define	PCI_DEVICE_ID_NLM_PIC		0x1003
+#define	PCI_DEVICE_ID_NLM_PCIE		0x1004
+#define	PCI_DEVICE_ID_NLM_EHCI		0x1007
+#define	PCI_DEVICE_ID_NLM_OHCI		0x1008
+#define	PCI_DEVICE_ID_NLM_NAE		0x1009
+#define	PCI_DEVICE_ID_NLM_POE		0x100A
+#define	PCI_DEVICE_ID_NLM_FMN		0x100B
+#define	PCI_DEVICE_ID_NLM_RAID		0x100D
+#define	PCI_DEVICE_ID_NLM_SAE		0x100D
+#define	PCI_DEVICE_ID_NLM_RSA		0x100E
+#define	PCI_DEVICE_ID_NLM_CMP		0x100F
+#define	PCI_DEVICE_ID_NLM_UART		0x1010
+#define	PCI_DEVICE_ID_NLM_I2C		0x1011
+#define	PCI_DEVICE_ID_NLM_NOR		0x1015
+#define	PCI_DEVICE_ID_NLM_NAND		0x1016
+#define	PCI_DEVICE_ID_NLM_MMC		0x1018
+#define	PCI_DEVICE_ID_NLM_SATA		0x101A
+#define PCI_DEVICE_ID_NLM_XHCI		0x101D
+
+#define	PCI_DEVICE_ID_XLP9XX_MMC	0x9018
+#define	PCI_DEVICE_ID_XLP9XX_SATA	0x901A
+#define	PCI_DEVICE_ID_XLP9XX_XHCI	0x901D
 
 #ifndef __ASSEMBLY__
 
 #define nlm_read_pci_reg(b, r)		nlm_read_reg(b, r)
 #define nlm_write_pci_reg(b, r, v)	nlm_write_reg(b, r, v)
 
+static inline int xlp9xx_get_socbus(int node)
+{
+	uint64_t socbridge;
+
+	if (node == 0)
+		return 1;
+	socbridge = nlm_pcicfg_base(XLP9XX_IO_BRIDGE_OFFSET(node));
+	return (nlm_read_pci_reg(socbridge, 0x6) >> 8) & 0xff;
+}
 #endif /* !__ASSEMBLY */
 
 #endif /* __NLM_HAL_IOMAP_H__ */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
index b559cb9..53372ce 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/pcibus.h
@@ -33,44 +33,66 @@
  */
 
 #ifndef __NLM_HAL_PCIBUS_H__
-#define __NLM_HAL_PCIBUS_H__
+#define	__NLM_HAL_PCIBUS_H__
 
 /* PCIE Memory and IO regions */
-#define PCIE_MEM_BASE			0xd0000000ULL
-#define PCIE_MEM_LIMIT			0xdfffffffULL
-#define PCIE_IO_BASE			0x14000000ULL
-#define PCIE_IO_LIMIT			0x15ffffffULL
+#define	PCIE_MEM_BASE			0xd0000000ULL
+#define	PCIE_MEM_LIMIT			0xdfffffffULL
+#define	PCIE_IO_BASE			0x14000000ULL
+#define	PCIE_IO_LIMIT			0x15ffffffULL
 
-#define PCIE_BRIDGE_CMD			0x1
-#define PCIE_BRIDGE_MSI_CAP		0x14
-#define PCIE_BRIDGE_MSI_ADDRL		0x15
-#define PCIE_BRIDGE_MSI_ADDRH		0x16
-#define PCIE_BRIDGE_MSI_DATA		0x17
+#define	PCIE_BRIDGE_CMD			0x1
+#define	PCIE_BRIDGE_MSI_CAP		0x14
+#define	PCIE_BRIDGE_MSI_ADDRL		0x15
+#define	PCIE_BRIDGE_MSI_ADDRH		0x16
+#define	PCIE_BRIDGE_MSI_DATA		0x17
 
 /* XLP Global PCIE configuration space registers */
 #define PCIE_BYTE_SWAP_MEM_BASE		0x247
 #define PCIE_BYTE_SWAP_MEM_LIM		0x248
 #define PCIE_BYTE_SWAP_IO_BASE		0x249
 #define PCIE_BYTE_SWAP_IO_LIM		0x24A
+#define PCIE_BRIDGE_MSIX_ADDR_BASE	0x24F
+#define PCIE_BRIDGE_MSIX_ADDR_LIMIT	0x250
 #define PCIE_MSI_STATUS			0x25A
 #define PCIE_MSI_EN			0x25B
+#define PCIE_MSIX_STATUS		0x25D
+#define PCIE_INT_STATUS0		0x25F
+#define PCIE_INT_STATUS1		0x260
 #define PCIE_INT_EN0			0x261
+#define PCIE_INT_EN1			0x262
 
-/* PCIE_MSI_EN */
-#define PCIE_MSI_VECTOR_INT_EN		0xFFFFFFFF
+/* XLP9XX has basic changes */
+#define PCIE_9XX_BYTE_SWAP_MEM_BASE	0x25c
+#define PCIE_9XX_BYTE_SWAP_MEM_LIM	0x25d
+#define PCIE_9XX_BYTE_SWAP_IO_BASE	0x25e
+#define PCIE_9XX_BYTE_SWAP_IO_LIM	0x25f
 
-/* PCIE_INT_EN0 */
-#define PCIE_MSI_INT_EN			(1 << 9)
+/* other */
+#define PCIE_NLINKS			4
 
+/* PCIE_MSI_EN */
+#define MSI_ADDR_BASE			0xfffee00000ULL
+#define MSI_ADDR_SZ			0x10000
+#define MSI_LINK_ADDR(n, l)		(MSI_ADDR_BASE + \
+				(PCIE_NLINKS * (n) + (l)) * MSI_ADDR_SZ)
+#define MSIX_ADDR_BASE			0xfffef00000ULL
+#define MSIX_LINK_ADDR(n, l)		(MSIX_ADDR_BASE + \
+				(PCIE_NLINKS * (n) + (l)) * MSI_ADDR_SZ)
 #ifndef __ASSEMBLY__
 
 #define nlm_read_pcie_reg(b, r)		nlm_read_reg(b, r)
 #define nlm_write_pcie_reg(b, r, v)	nlm_write_reg(b, r, v)
-#define nlm_get_pcie_base(node, inst)	\
-			nlm_pcicfg_base(XLP_IO_PCIE_OFFSET(node, inst))
-#define nlm_get_pcie_regbase(node, inst)	\
-			(nlm_get_pcie_base(node, inst) + XLP_IO_PCI_HDRSZ)
+#define nlm_get_pcie_base(node, inst)	nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+	XLP9XX_IO_PCIE_OFFSET(node, inst) : XLP_IO_PCIE_OFFSET(node, inst))
+
+#ifdef CONFIG_PCI_MSI
+void xlp_init_node_msi_irqs(int node, int link);
+#else
+static inline void xlp_init_node_msi_irqs(int node, int link) {}
+#endif
+
+const struct pci_dev *xlp_get_pcie_link(const struct pci_dev *dev);
 
-int xlp_pcie_link_irt(int link);
 #endif
 #endif /* __NLM_HAL_PCIBUS_H__ */
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/pic.h b/arch/mips/include/asm/netlogic/xlp-hal/pic.h
index a981f46..dd10d89 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/pic.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/pic.h
@@ -36,7 +36,7 @@
 #define _NLM_HAL_PIC_H
 
 /* PIC Specific registers */
-#define PIC_CTRL		0x00
+#define PIC_CTRL                0x00
 
 /* PIC control register defines */
 #define PIC_CTRL_ITV		32 /* interrupt timeout value */
@@ -71,41 +71,41 @@
 #define PIC_IRT_DB		16 /* Destination base */
 #define PIC_IRT_DTE		0  /* Destination thread enables */
 
-#define PIC_BYTESWAP		0x02
-#define PIC_STATUS		0x04
+#define PIC_BYTESWAP            0x02
+#define PIC_STATUS              0x04
 #define PIC_INTR_TIMEOUT	0x06
 #define PIC_ICI0_INTR_TIMEOUT	0x08
 #define PIC_ICI1_INTR_TIMEOUT	0x0a
 #define PIC_ICI2_INTR_TIMEOUT	0x0c
 #define PIC_IPI_CTL		0x0e
-#define PIC_INT_ACK		0x10
-#define PIC_INT_PENDING0	0x12
-#define PIC_INT_PENDING1	0x14
-#define PIC_INT_PENDING2	0x16
-
-#define PIC_WDOG0_MAXVAL	0x18
-#define PIC_WDOG0_COUNT		0x1a
-#define PIC_WDOG0_ENABLE0	0x1c
-#define PIC_WDOG0_ENABLE1	0x1e
-#define PIC_WDOG0_BEATCMD	0x20
-#define PIC_WDOG0_BEAT0		0x22
-#define PIC_WDOG0_BEAT1		0x24
-
-#define PIC_WDOG1_MAXVAL	0x26
-#define PIC_WDOG1_COUNT		0x28
-#define PIC_WDOG1_ENABLE0	0x2a
-#define PIC_WDOG1_ENABLE1	0x2c
-#define PIC_WDOG1_BEATCMD	0x2e
-#define PIC_WDOG1_BEAT0		0x30
-#define PIC_WDOG1_BEAT1		0x32
-
-#define PIC_WDOG_MAXVAL(i)	(PIC_WDOG0_MAXVAL + ((i) ? 7 : 0))
-#define PIC_WDOG_COUNT(i)	(PIC_WDOG0_COUNT + ((i) ? 7 : 0))
-#define PIC_WDOG_ENABLE0(i)	(PIC_WDOG0_ENABLE0 + ((i) ? 7 : 0))
-#define PIC_WDOG_ENABLE1(i)	(PIC_WDOG0_ENABLE1 + ((i) ? 7 : 0))
-#define PIC_WDOG_BEATCMD(i)	(PIC_WDOG0_BEATCMD + ((i) ? 7 : 0))
-#define PIC_WDOG_BEAT0(i)	(PIC_WDOG0_BEAT0 + ((i) ? 7 : 0))
-#define PIC_WDOG_BEAT1(i)	(PIC_WDOG0_BEAT1 + ((i) ? 7 : 0))
+#define PIC_INT_ACK             0x10
+#define PIC_INT_PENDING0        0x12
+#define PIC_INT_PENDING1        0x14
+#define PIC_INT_PENDING2        0x16
+
+#define PIC_WDOG0_MAXVAL        0x18
+#define PIC_WDOG0_COUNT         0x1a
+#define PIC_WDOG0_ENABLE0       0x1c
+#define PIC_WDOG0_ENABLE1       0x1e
+#define PIC_WDOG0_BEATCMD       0x20
+#define PIC_WDOG0_BEAT0         0x22
+#define PIC_WDOG0_BEAT1         0x24
+
+#define PIC_WDOG1_MAXVAL        0x26
+#define PIC_WDOG1_COUNT         0x28
+#define PIC_WDOG1_ENABLE0       0x2a
+#define PIC_WDOG1_ENABLE1       0x2c
+#define PIC_WDOG1_BEATCMD       0x2e
+#define PIC_WDOG1_BEAT0         0x30
+#define PIC_WDOG1_BEAT1         0x32
+
+#define PIC_WDOG_MAXVAL(i)      (PIC_WDOG0_MAXVAL + ((i) ? 7 : 0))
+#define PIC_WDOG_COUNT(i)       (PIC_WDOG0_COUNT + ((i) ? 7 : 0))
+#define PIC_WDOG_ENABLE0(i)     (PIC_WDOG0_ENABLE0 + ((i) ? 7 : 0))
+#define PIC_WDOG_ENABLE1(i)     (PIC_WDOG0_ENABLE1 + ((i) ? 7 : 0))
+#define PIC_WDOG_BEATCMD(i)     (PIC_WDOG0_BEATCMD + ((i) ? 7 : 0))
+#define PIC_WDOG_BEAT0(i)       (PIC_WDOG0_BEAT0 + ((i) ? 7 : 0))
+#define PIC_WDOG_BEAT1(i)       (PIC_WDOG0_BEAT1 + ((i) ? 7 : 0))
 
 #define PIC_TIMER0_MAXVAL    0x34
 #define PIC_TIMER1_MAXVAL    0x36
@@ -127,35 +127,42 @@
 #define PIC_TIMER7_COUNT     0x52
 #define PIC_TIMER_COUNT(i)   (PIC_TIMER0_COUNT + ((i) * 2))
 
-#define PIC_ITE0_N0_N1		0x54
-#define PIC_ITE1_N0_N1		0x58
-#define PIC_ITE2_N0_N1		0x5c
-#define PIC_ITE3_N0_N1		0x60
-#define PIC_ITE4_N0_N1		0x64
-#define PIC_ITE5_N0_N1		0x68
-#define PIC_ITE6_N0_N1		0x6c
-#define PIC_ITE7_N0_N1		0x70
-#define PIC_ITE_N0_N1(i)	(PIC_ITE0_N0_N1 + ((i) * 4))
-
-#define PIC_ITE0_N2_N3		0x56
-#define PIC_ITE1_N2_N3		0x5a
-#define PIC_ITE2_N2_N3		0x5e
-#define PIC_ITE3_N2_N3		0x62
-#define PIC_ITE4_N2_N3		0x66
-#define PIC_ITE5_N2_N3		0x6a
-#define PIC_ITE6_N2_N3		0x6e
-#define PIC_ITE7_N2_N3		0x72
-#define PIC_ITE_N2_N3(i)	(PIC_ITE0_N2_N3 + ((i) * 4))
-
-#define PIC_IRT0		0x74
-#define PIC_IRT(i)		(PIC_IRT0 + ((i) * 2))
-
-#define TIMER_CYCLES_MAXVAL	0xffffffffffffffffULL
+#define PIC_ITE0_N0_N1          0x54
+#define PIC_ITE1_N0_N1          0x58
+#define PIC_ITE2_N0_N1          0x5c
+#define PIC_ITE3_N0_N1          0x60
+#define PIC_ITE4_N0_N1          0x64
+#define PIC_ITE5_N0_N1          0x68
+#define PIC_ITE6_N0_N1          0x6c
+#define PIC_ITE7_N0_N1          0x70
+#define PIC_ITE_N0_N1(i)        (PIC_ITE0_N0_N1 + ((i) * 4))
+
+#define PIC_ITE0_N2_N3          0x56
+#define PIC_ITE1_N2_N3          0x5a
+#define PIC_ITE2_N2_N3          0x5e
+#define PIC_ITE3_N2_N3          0x62
+#define PIC_ITE4_N2_N3          0x66
+#define PIC_ITE5_N2_N3          0x6a
+#define PIC_ITE6_N2_N3          0x6e
+#define PIC_ITE7_N2_N3          0x72
+#define PIC_ITE_N2_N3(i)        (PIC_ITE0_N2_N3 + ((i) * 4))
+
+#define PIC_IRT0                0x74
+#define PIC_IRT(i)              (PIC_IRT0 + ((i) * 2))
+
+#define PIC_9XX_PENDING_0	0x6
+#define PIC_9XX_PENDING_1	0x8
+#define PIC_9XX_PENDING_2	0xa
+#define PIC_9XX_PENDING_3	0xc
+
+#define PIC_9XX_IRT0		0x1c0
+#define PIC_9XX_IRT(i)		(PIC_9XX_IRT0 + ((i) * 2))
 
 /*
  *    IRT Map
  */
 #define PIC_NUM_IRTS		160
+#define PIC_9XX_NUM_IRTS	256
 
 #define PIC_IRT_WD_0_INDEX	0
 #define PIC_IRT_WD_1_INDEX	1
@@ -177,6 +184,23 @@
 #define PIC_NUM_MSG_Q_IRTS	32
 #define PIC_IRT_MSG_Q0_INDEX	12
 #define PIC_IRT_MSG_Q_INDEX(qid)	((qid) + PIC_IRT_MSG_Q0_INDEX)
+
+/* GPIO IRTs for XLP3xx */
+#define PIC_3XX_GPIO_NUM_IRTS           12
+#define PIC_3XX_IRT_GPIO_0_INDEX        12
+#define PIC_3XX_IRT_GPIO_1_INDEX        13
+#define PIC_3XX_IRT_GPIO_2_INDEX        14
+#define PIC_3XX_IRT_GPIO_3_INDEX        15
+#define PIC_3XX_IRT_GPIO_4_INDEX        16
+#define PIC_3XX_IRT_GPIO_5_INDEX        17
+#define PIC_3XX_IRT_GPIO_6_INDEX        18
+#define PIC_3XX_IRT_GPIO_7_INDEX        19
+#define PIC_3XX_IRT_GPIO_8_INDEX        20
+#define PIC_3XX_IRT_GPIO_9_INDEX        21
+#define PIC_3XX_IRT_GPIO_10_INDEX       22
+#define PIC_3XX_IRT_GPIO_11_INDEX       23
+#define PIC_3XX_IRT_GPIO_INDEX(i)       (12 + (i))
+
 /* 12 to 43 */
 #define PIC_IRT_MSG_0_INDEX	44
 #define PIC_IRT_MSG_1_INDEX	45
@@ -192,15 +216,12 @@
 #define PIC_IRT_PCIE_LINK_3_INDEX	81
 #define PIC_IRT_PCIE_LINK_INDEX(num)	((num) + PIC_IRT_PCIE_LINK_0_INDEX)
 
+#define PIC_XLP9XX_IRT_PCIE_LINK_0_INDEX	191
+
 #define PIC_CLOCK_TIMER			7
-#define PIC_IRQ_BASE			8
 
 #if !defined(LOCORE) && !defined(__ASSEMBLY__)
 
-#define PIC_IRT_FIRST_IRQ		(PIC_IRQ_BASE)
-#define PIC_IRT_LAST_IRQ		63
-#define PIC_IRQ_IS_IRT(irq)		((irq) >= PIC_IRT_FIRST_IRQ)
-
 /*
  *   Misc
  */
@@ -208,31 +229,28 @@
 #define PIC_LOCAL_SCHEDULING		1
 #define PIC_GLOBAL_SCHEDULING		0
 
-#define PIC_CLK_HZ			133333333
-
 #define nlm_read_pic_reg(b, r)	nlm_read_reg64(b, r)
 #define nlm_write_pic_reg(b, r, v) nlm_write_reg64(b, r, v)
-#define nlm_get_pic_pcibase(node) nlm_pcicfg_base(XLP_IO_PIC_OFFSET(node))
+#define nlm_get_pic_pcibase(node)	nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+		XLP9XX_IO_PIC_OFFSET(node) : XLP_IO_PIC_OFFSET(node))
 #define nlm_get_pic_regbase(node) (nlm_get_pic_pcibase(node) + XLP_IO_PCI_HDRSZ)
 
-/* IRT and h/w interrupt routines */
-static inline int
-nlm_pic_read_irt(uint64_t base, int irt_index)
-{
-	return nlm_read_pic_reg(base, PIC_IRT(irt_index));
-}
+/* We use PIC on node 0 as a timer */
+#define pic_timer_freq()		nlm_get_pic_frequency(0)
 
+/* IRT and h/w interrupt routines */
 static inline void
-nlm_set_irt_to_cpu(uint64_t base, int irt, int cpu)
+nlm_9xx_pic_write_irt(uint64_t base, int irt_num, int en, int nmi,
+	int sch, int vec, int dt, int db, int cpu)
 {
 	uint64_t val;
 
-	val = nlm_read_pic_reg(base, PIC_IRT(irt));
-	/* clear cpuset and mask */
-	val &= ~((0x7ull << 16) | 0xffff);
-	/* set DB, cpuset and cpumask */
-	val |= (1 << 19) | ((cpu >> 4) << 16) | (1 << (cpu & 0xf));
-	nlm_write_pic_reg(base, PIC_IRT(irt), val);
+	val = (((uint64_t)en & 0x1) << 22) | ((nmi & 0x1) << 23) |
+			((0 /*mc*/) << 20) | ((vec & 0x3f) << 24) |
+			((dt & 0x1) << 21) | (0 /*ptr*/ << 16) |
+			(cpu & 0x3ff);
+
+	nlm_write_pic_reg(base, PIC_9XX_IRT(irt_num), val);
 }
 
 static inline void
@@ -253,9 +271,13 @@ static inline void
 nlm_pic_write_irt_direct(uint64_t base, int irt_num, int en, int nmi,
 	int sch, int vec, int cpu)
 {
-	nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
-		(cpu >> 4),		/* thread group */
-		1 << (cpu & 0xf));	/* thread mask */
+	if (cpu_is_xlp9xx())
+		nlm_9xx_pic_write_irt(base, irt_num, en, nmi, sch, vec,
+							1, 0, cpu);
+	else
+		nlm_pic_write_irt(base, irt_num, en, nmi, sch, vec, 1,
+			(cpu >> 4),		/* thread group */
+			1 << (cpu & 0xf));	/* thread mask */
 }
 
 static inline uint64_t
@@ -297,8 +319,13 @@ nlm_pic_enable_irt(uint64_t base, int irt)
 {
 	uint64_t reg;
 
-	reg = nlm_read_pic_reg(base, PIC_IRT(irt));
-	nlm_write_pic_reg(base, PIC_IRT(irt), reg | (1u << 31));
+	if (cpu_is_xlp9xx()) {
+		reg = nlm_read_pic_reg(base, PIC_9XX_IRT(irt));
+		nlm_write_pic_reg(base, PIC_9XX_IRT(irt), reg | (1 << 22));
+	} else {
+		reg = nlm_read_pic_reg(base, PIC_IRT(irt));
+		nlm_write_pic_reg(base, PIC_IRT(irt), reg | (1u << 31));
+	}
 }
 
 static inline void
@@ -306,8 +333,15 @@ nlm_pic_disable_irt(uint64_t base, int irt)
 {
 	uint64_t reg;
 
-	reg = nlm_read_pic_reg(base, PIC_IRT(irt));
-	nlm_write_pic_reg(base, PIC_IRT(irt), reg & ~((uint64_t)1 << 31));
+	if (cpu_is_xlp9xx()) {
+		reg = nlm_read_pic_reg(base, PIC_9XX_IRT(irt));
+		reg &= ~((uint64_t)1 << 22);
+		nlm_write_pic_reg(base, PIC_9XX_IRT(irt), reg);
+	} else {
+		reg = nlm_read_pic_reg(base, PIC_IRT(irt));
+		reg &= ~((uint64_t)1 << 31);
+		nlm_write_pic_reg(base, PIC_IRT(irt), reg);
+	}
 }
 
 static inline void
@@ -315,8 +349,13 @@ nlm_pic_send_ipi(uint64_t base, int hwt, int irq, int nmi)
 {
 	uint64_t ipi;
 
-	ipi = (nmi << 31) | (irq << 20);
-	ipi |= ((hwt >> 4) << 16) | (1 << (hwt & 0xf)); /* cpuset and mask */
+	if (cpu_is_xlp9xx())
+		ipi = (nmi << 23) | (irq << 24) |
+			(0/*mcm*/ << 20) | (0/*ptr*/ << 16) | hwt;
+	else
+		ipi = ((uint64_t)nmi << 31) | (irq << 20) |
+			((hwt >> 4) << 16) | (1 << (hwt & 0xf));
+
 	nlm_write_pic_reg(base, PIC_IPI_CTL, ipi);
 }
 
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/sys.h b/arch/mips/include/asm/netlogic/xlp-hal/sys.h
index 470e52b..641d856 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/sys.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/sys.h
@@ -40,89 +40,161 @@
 * @author Netlogic Microsystems
 * @brief HAL for System configuration registers
 */
-#define SYS_CHIP_RESET				0x00
-#define SYS_POWER_ON_RESET_CFG			0x01
-#define SYS_EFUSE_DEVICE_CFG_STATUS0		0x02
-#define SYS_EFUSE_DEVICE_CFG_STATUS1		0x03
-#define SYS_EFUSE_DEVICE_CFG_STATUS2		0x04
-#define SYS_EFUSE_DEVICE_CFG3			0x05
-#define SYS_EFUSE_DEVICE_CFG4			0x06
-#define SYS_EFUSE_DEVICE_CFG5			0x07
-#define SYS_EFUSE_DEVICE_CFG6			0x08
-#define SYS_EFUSE_DEVICE_CFG7			0x09
-#define SYS_PLL_CTRL				0x0a
-#define SYS_CPU_RESET				0x0b
-#define SYS_CPU_NONCOHERENT_MODE		0x0d
-#define SYS_CORE_DFS_DIS_CTRL			0x0e
-#define SYS_CORE_DFS_RST_CTRL			0x0f
-#define SYS_CORE_DFS_BYP_CTRL			0x10
-#define SYS_CORE_DFS_PHA_CTRL			0x11
-#define SYS_CORE_DFS_DIV_INC_CTRL		0x12
-#define SYS_CORE_DFS_DIV_DEC_CTRL		0x13
-#define SYS_CORE_DFS_DIV_VALUE			0x14
-#define SYS_RESET				0x15
-#define SYS_DFS_DIS_CTRL			0x16
-#define SYS_DFS_RST_CTRL			0x17
-#define SYS_DFS_BYP_CTRL			0x18
-#define SYS_DFS_DIV_INC_CTRL			0x19
-#define SYS_DFS_DIV_DEC_CTRL			0x1a
-#define SYS_DFS_DIV_VALUE0			0x1b
-#define SYS_DFS_DIV_VALUE1			0x1c
-#define SYS_SENSE_AMP_DLY			0x1d
-#define SYS_SOC_SENSE_AMP_DLY			0x1e
-#define SYS_CTRL0				0x1f
-#define SYS_CTRL1				0x20
-#define SYS_TIMEOUT_BS1				0x21
-#define SYS_BYTE_SWAP				0x22
-#define SYS_VRM_VID				0x23
-#define SYS_PWR_RAM_CMD				0x24
-#define SYS_PWR_RAM_ADDR			0x25
-#define SYS_PWR_RAM_DATA0			0x26
-#define SYS_PWR_RAM_DATA1			0x27
-#define SYS_PWR_RAM_DATA2			0x28
-#define SYS_PWR_UCODE				0x29
-#define SYS_CPU0_PWR_STATUS			0x2a
-#define SYS_CPU1_PWR_STATUS			0x2b
-#define SYS_CPU2_PWR_STATUS			0x2c
-#define SYS_CPU3_PWR_STATUS			0x2d
-#define SYS_CPU4_PWR_STATUS			0x2e
-#define SYS_CPU5_PWR_STATUS			0x2f
-#define SYS_CPU6_PWR_STATUS			0x30
-#define SYS_CPU7_PWR_STATUS			0x31
-#define SYS_STATUS				0x32
-#define SYS_INT_POL				0x33
-#define SYS_INT_TYPE				0x34
-#define SYS_INT_STATUS				0x35
-#define SYS_INT_MASK0				0x36
-#define SYS_INT_MASK1				0x37
-#define SYS_UCO_S_ECC				0x38
-#define SYS_UCO_M_ECC				0x39
-#define SYS_UCO_ADDR				0x3a
-#define SYS_UCO_INSTR				0x3b
-#define SYS_MEM_BIST0				0x3c
-#define SYS_MEM_BIST1				0x3d
-#define SYS_MEM_BIST2				0x3e
-#define SYS_MEM_BIST3				0x3f
-#define SYS_MEM_BIST4				0x40
-#define SYS_MEM_BIST5				0x41
-#define SYS_MEM_BIST6				0x42
-#define SYS_MEM_BIST7				0x43
-#define SYS_MEM_BIST8				0x44
-#define SYS_MEM_BIST9				0x45
-#define SYS_MEM_BIST10				0x46
-#define SYS_MEM_BIST11				0x47
-#define SYS_MEM_BIST12				0x48
-#define SYS_SCRTCH0				0x49
-#define SYS_SCRTCH1				0x4a
-#define SYS_SCRTCH2				0x4b
-#define SYS_SCRTCH3				0x4c
+#define	SYS_CHIP_RESET				0x00
+#define	SYS_POWER_ON_RESET_CFG			0x01
+#define	SYS_EFUSE_DEVICE_CFG_STATUS0		0x02
+#define	SYS_EFUSE_DEVICE_CFG_STATUS1		0x03
+#define	SYS_EFUSE_DEVICE_CFG_STATUS2		0x04
+#define	SYS_EFUSE_DEVICE_CFG3			0x05
+#define	SYS_EFUSE_DEVICE_CFG4			0x06
+#define	SYS_EFUSE_DEVICE_CFG5			0x07
+#define	SYS_EFUSE_DEVICE_CFG6			0x08
+#define	SYS_EFUSE_DEVICE_CFG7			0x09
+#define	SYS_PLL_CTRL				0x0a
+#define	SYS_CPU_RESET				0x0b
+#define	SYS_CPU_NONCOHERENT_MODE		0x0d
+#define	SYS_CORE_DFS_DIS_CTRL			0x0e
+#define	SYS_CORE_DFS_RST_CTRL			0x0f
+#define	SYS_CORE_DFS_BYP_CTRL			0x10
+#define	SYS_CORE_DFS_PHA_CTRL			0x11
+#define	SYS_CORE_DFS_DIV_INC_CTRL		0x12
+#define	SYS_CORE_DFS_DIV_DEC_CTRL		0x13
+#define	SYS_CORE_DFS_DIV_VALUE			0x14
+#define	SYS_RESET				0x15
+#define	SYS_DFS_DIS_CTRL			0x16
+#define	SYS_DFS_RST_CTRL			0x17
+#define	SYS_DFS_BYP_CTRL			0x18
+#define	SYS_DFS_DIV_INC_CTRL			0x19
+#define	SYS_DFS_DIV_DEC_CTRL			0x1a
+#define	SYS_DFS_DIV_VALUE0			0x1b
+#define	SYS_DFS_DIV_VALUE1			0x1c
+#define	SYS_SENSE_AMP_DLY			0x1d
+#define	SYS_SOC_SENSE_AMP_DLY			0x1e
+#define	SYS_CTRL0				0x1f
+#define	SYS_CTRL1				0x20
+#define	SYS_TIMEOUT_BS1				0x21
+#define	SYS_BYTE_SWAP				0x22
+#define	SYS_VRM_VID				0x23
+#define	SYS_PWR_RAM_CMD				0x24
+#define	SYS_PWR_RAM_ADDR			0x25
+#define	SYS_PWR_RAM_DATA0			0x26
+#define	SYS_PWR_RAM_DATA1			0x27
+#define	SYS_PWR_RAM_DATA2			0x28
+#define	SYS_PWR_UCODE				0x29
+#define	SYS_CPU0_PWR_STATUS			0x2a
+#define	SYS_CPU1_PWR_STATUS			0x2b
+#define	SYS_CPU2_PWR_STATUS			0x2c
+#define	SYS_CPU3_PWR_STATUS			0x2d
+#define	SYS_CPU4_PWR_STATUS			0x2e
+#define	SYS_CPU5_PWR_STATUS			0x2f
+#define	SYS_CPU6_PWR_STATUS			0x30
+#define	SYS_CPU7_PWR_STATUS			0x31
+#define	SYS_STATUS				0x32
+#define	SYS_INT_POL				0x33
+#define	SYS_INT_TYPE				0x34
+#define	SYS_INT_STATUS				0x35
+#define	SYS_INT_MASK0				0x36
+#define	SYS_INT_MASK1				0x37
+#define	SYS_UCO_S_ECC				0x38
+#define	SYS_UCO_M_ECC				0x39
+#define	SYS_UCO_ADDR				0x3a
+#define	SYS_UCO_INSTR				0x3b
+#define	SYS_MEM_BIST0				0x3c
+#define	SYS_MEM_BIST1				0x3d
+#define	SYS_MEM_BIST2				0x3e
+#define	SYS_MEM_BIST3				0x3f
+#define	SYS_MEM_BIST4				0x40
+#define	SYS_MEM_BIST5				0x41
+#define	SYS_MEM_BIST6				0x42
+#define	SYS_MEM_BIST7				0x43
+#define	SYS_MEM_BIST8				0x44
+#define	SYS_MEM_BIST9				0x45
+#define	SYS_MEM_BIST10				0x46
+#define	SYS_MEM_BIST11				0x47
+#define	SYS_MEM_BIST12				0x48
+#define	SYS_SCRTCH0				0x49
+#define	SYS_SCRTCH1				0x4a
+#define	SYS_SCRTCH2				0x4b
+#define	SYS_SCRTCH3				0x4c
 
-#ifndef __ASSEMBLY__
+/* PLL registers XLP2XX */
+#define SYS_PLL_CTRL0				0x240
+#define SYS_PLL_CTRL1				0x241
+#define SYS_PLL_CTRL2				0x242
+#define SYS_PLL_CTRL3				0x243
+#define SYS_DMC_PLL_CTRL0			0x244
+#define SYS_DMC_PLL_CTRL1			0x245
+#define SYS_DMC_PLL_CTRL2			0x246
+#define SYS_DMC_PLL_CTRL3			0x247
+
+#define SYS_PLL_CTRL0_DEVX(x)			(0x248 + (x) * 4)
+#define SYS_PLL_CTRL1_DEVX(x)			(0x249 + (x) * 4)
+#define SYS_PLL_CTRL2_DEVX(x)			(0x24a + (x) * 4)
+#define SYS_PLL_CTRL3_DEVX(x)			(0x24b + (x) * 4)
+
+#define SYS_CPU_PLL_CHG_CTRL			0x288
+#define SYS_PLL_CHG_CTRL			0x289
+#define SYS_CLK_DEV_DIS				0x28a
+#define SYS_CLK_DEV_SEL				0x28b
+#define SYS_CLK_DEV_DIV				0x28c
+#define SYS_CLK_DEV_CHG				0x28d
+#define SYS_CLK_DEV_SEL_REG			0x28e
+#define SYS_CLK_DEV_DIV_REG			0x28f
+#define SYS_CPU_PLL_LOCK			0x29f
+#define SYS_SYS_PLL_LOCK			0x2a0
+#define SYS_PLL_MEM_CMD				0x2a1
+#define SYS_CPU_PLL_MEM_REQ			0x2a2
+#define SYS_SYS_PLL_MEM_REQ			0x2a3
+#define SYS_PLL_MEM_STAT			0x2a4
+
+/* PLL registers XLP9XX */
+#define SYS_9XX_DMC_PLL_CTRL0			0x140
+#define SYS_9XX_DMC_PLL_CTRL1			0x141
+#define SYS_9XX_DMC_PLL_CTRL2			0x142
+#define SYS_9XX_DMC_PLL_CTRL3			0x143
+#define SYS_9XX_PLL_CTRL0			0x144
+#define SYS_9XX_PLL_CTRL1			0x145
+#define SYS_9XX_PLL_CTRL2			0x146
+#define SYS_9XX_PLL_CTRL3			0x147
+
+#define SYS_9XX_PLL_CTRL0_DEVX(x)		(0x148 + (x) * 4)
+#define SYS_9XX_PLL_CTRL1_DEVX(x)		(0x149 + (x) * 4)
+#define SYS_9XX_PLL_CTRL2_DEVX(x)		(0x14a + (x) * 4)
+#define SYS_9XX_PLL_CTRL3_DEVX(x)		(0x14b + (x) * 4)
+
+#define SYS_9XX_CPU_PLL_CHG_CTRL		0x188
+#define SYS_9XX_PLL_CHG_CTRL			0x189
+#define SYS_9XX_CLK_DEV_DIS			0x18a
+#define SYS_9XX_CLK_DEV_SEL			0x18b
+#define SYS_9XX_CLK_DEV_DIV			0x18d
+#define SYS_9XX_CLK_DEV_CHG			0x18f
 
+/* Registers changed on 9XX */
+#define SYS_9XX_POWER_ON_RESET_CFG		0x00
+#define SYS_9XX_CHIP_RESET			0x01
+#define SYS_9XX_CPU_RESET			0x02
+#define SYS_9XX_CPU_NONCOHERENT_MODE		0x03
+
+/* XLP 9XX fuse block registers */
+#define FUSE_9XX_DEVCFG6			0xc6
+
+#ifndef __ASSEMBLY__
 #define nlm_read_sys_reg(b, r)		nlm_read_reg(b, r)
 #define nlm_write_sys_reg(b, r, v)	nlm_write_reg(b, r, v)
-#define nlm_get_sys_pcibase(node) nlm_pcicfg_base(XLP_IO_SYS_OFFSET(node))
+#define nlm_get_sys_pcibase(node)	nlm_pcicfg_base(cpu_is_xlp9xx() ? \
+		XLP9XX_IO_SYS_OFFSET(node) : XLP_IO_SYS_OFFSET(node))
 #define nlm_get_sys_regbase(node) (nlm_get_sys_pcibase(node) + XLP_IO_PCI_HDRSZ)
 
+#define nlm_get_fuse_pcibase(node) 	\
+			nlm_pcicfg_base(XLP9XX_IO_FUSE_OFFSET(node))
+#define nlm_get_fuse_regbase(node)	\
+			(nlm_get_fuse_pcibase(node) + XLP_IO_PCI_HDRSZ)
+
+#define nlm_get_clock_pcibase(node)	\
+			nlm_pcicfg_base(XLP9XX_IO_CLOCK_OFFSET(node))
+#define nlm_get_clock_regbase(node)	\
+			(nlm_get_clock_pcibase(node) + XLP_IO_PCI_HDRSZ)
+
+unsigned int nlm_get_pic_frequency(int node);
 #endif
 #endif
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/uart.h b/arch/mips/include/asm/netlogic/xlp-hal/uart.h
index 86d16e1..926ff9f 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/uart.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/uart.h
@@ -91,10 +91,11 @@
 
 #if !defined(LOCORE) && !defined(__ASSEMBLY__)
 
-#define nlm_read_uart_reg(b, r)		nlm_read_reg(b, r)
-#define nlm_write_uart_reg(b, r, v)	nlm_write_reg(b, r, v)
+#define	nlm_read_uart_reg(b, r)		nlm_read_reg(b, r)
+#define	nlm_write_uart_reg(b, r, v)	nlm_write_reg(b, r, v)
 #define nlm_get_uart_pcibase(node, inst)	\
-		nlm_pcicfg_base(XLP_IO_UART_OFFSET(node, inst))
+	nlm_pcicfg_base(cpu_is_xlp9xx() ?  XLP9XX_IO_UART_OFFSET(node) : \
+						XLP_IO_UART_OFFSET(node, inst))
 #define nlm_get_uart_regbase(node, inst)	\
 			(nlm_get_uart_pcibase(node, inst) + XLP_IO_PCI_HDRSZ)
 
diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 7e47209..75eab94 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -37,21 +37,56 @@
 
 #define PIC_UART_0_IRQ			17
 #define PIC_UART_1_IRQ			18
-#define PIC_PCIE_LINK_0_IRQ		19
-#define PIC_PCIE_LINK_1_IRQ		20
-#define PIC_PCIE_LINK_2_IRQ		21
-#define PIC_PCIE_LINK_3_IRQ		22
+
+#define PIC_PCIE_LINK_LEGACY_IRQ_BASE	19
+#define PIC_PCIE_LINK_LEGACY_IRQ(i)	(19 + (i))
+
 #define PIC_EHCI_0_IRQ			23
 #define PIC_EHCI_1_IRQ			24
 #define PIC_OHCI_0_IRQ			25
 #define PIC_OHCI_1_IRQ			26
 #define PIC_OHCI_2_IRQ			27
 #define PIC_OHCI_3_IRQ			28
+#define PIC_2XX_XHCI_0_IRQ		23
+#define PIC_2XX_XHCI_1_IRQ		24
+#define PIC_2XX_XHCI_2_IRQ		25
+#define PIC_9XX_XHCI_0_IRQ		23
+#define PIC_9XX_XHCI_1_IRQ		24
+
 #define PIC_MMC_IRQ			29
 #define PIC_I2C_0_IRQ			30
 #define PIC_I2C_1_IRQ			31
+#define PIC_I2C_2_IRQ			32
+#define PIC_I2C_3_IRQ			33
+
+#define PIC_SATA_IRQ			38
+
+#define PIC_GPIO_0_IRQ			39
+#define PIC_GPIO_1_IRQ			40
+#define PIC_GPIO_2_IRQ			41
+#define PIC_GPIO_3_IRQ			42
+
+#define PIC_PCIE_LINK_MSI_IRQ_BASE	44	/* 44 - 47 MSI IRQ */
+#define PIC_PCIE_LINK_MSI_IRQ(i)	(44 + (i))
+
+/* MSI-X with second link-level dispatch */
+#define PIC_PCIE_MSIX_IRQ_BASE		48	/* 48 - 51 MSI-X IRQ */
+#define PIC_PCIE_MSIX_IRQ(i)		(48 + (i))
+
+#define NLM_MSIX_VEC_BASE		96	/* 96 - 127 - MSIX mapped */
+#define NLM_MSI_VEC_BASE		128	/* 128 -255 - MSI mapped */
+
+#define NLM_PIC_INDIRECT_VEC_BASE	512
+#define NLM_GPIO_VEC_BASE		768
+
+#define PIC_IRQ_BASE			8
+#define PIC_IRT_FIRST_IRQ		PIC_IRQ_BASE
+#define PIC_IRT_LAST_IRQ		63
+
+#define PIC_NAND_IRQ			43
 
 #ifndef __ASSEMBLY__
+#include <linux/cpumask.h>
 
 /* SMP support functions */
 void xlp_boot_core0_siblings(void);
@@ -59,6 +94,33 @@ void xlp_wakeup_secondary_cpus(void);
 
 void xlp_mmu_init(void);
 void nlm_hal_init(void);
+int xlp_get_dram_map(int n, uint64_t *dram_map);
+void pgwalker_init(void);
+#ifdef CONFIG_NUMA
+void xlp_numa_init(void);
+#endif
+struct pci_dev;
+int xlp_socdev_to_node(const struct pci_dev *dev);
+
+/* Device tree related */
+void *xlp_dt_init(void *fdtp);
+int xlp_dt_get_cpumask(cpumask_t *mask);
+unsigned int nlm_get_core_frequency(int node, int core);
+
+/* XLP CPU types */
+static inline int cpu_is_xlpii(void)
+{
+	int chip = read_c0_prid() & 0xff00;
+
+	return chip == PRID_IMP_NETLOGIC_XLP2XX ||
+		chip == PRID_IMP_NETLOGIC_XLP9XX;
+}
+
+static inline int cpu_is_xlp9xx(void)
+{
+	int chip = read_c0_prid() & 0xff00;
 
+	return chip == PRID_IMP_NETLOGIC_XLP9XX;
+}
 #endif /* !__ASSEMBLY__ */
 #endif /* _ASM_NLM_XLP_H */
diff --git a/arch/mips/include/asm/netlogic/xlr/bridge.h b/arch/mips/include/asm/netlogic/xlr/bridge.h
index 2d02428..2a7b840 100644
--- a/arch/mips/include/asm/netlogic/xlr/bridge.h
+++ b/arch/mips/include/asm/netlogic/xlr/bridge.h
@@ -72,13 +72,20 @@
 #define BRIDGE_PCIXMEM_BAR		35
 #define BRIDGE_PCIXIO_BAR		36
 #define BRIDGE_DEVICE_MASK		37
+
+#define BRIDGE_AERR_INTR_LOG1		38
+#define BRIDGE_AERR_VALID_MASK		0x1
+#define BRIDGE_AERR_STAT_MASK		0x70
+#define BRIDGE_AERR_DEVID_MASK		0x1f00
+#define BRIDGE_AERR_CMD_MASK		0x70000
+
 #define BRIDGE_AERR_INTR_LOG1		38
 #define BRIDGE_AERR_INTR_LOG2		39
 #define BRIDGE_AERR_INTR_LOG3		40
 #define BRIDGE_AERR_DEV_STAT		41
-#define BRIDGE_AERR1_LOG1		42
-#define BRIDGE_AERR1_LOG2		43
-#define BRIDGE_AERR1_LOG3		44
+#define BRIDGE_AERR1_INTR_LOG1		42
+#define BRIDGE_AERR1_INTR_LOG2		43
+#define BRIDGE_AERR1_INTR_LOG3		44
 #define BRIDGE_AERR1_DEV_STAT		45
 #define BRIDGE_AERR_INTR_EN		46
 #define BRIDGE_AERR_UPG			47
@@ -100,5 +107,4 @@
 #define BRIDGE_SCRATCH1			61
 #define BRIDGE_SCRATCH2			62
 #define BRIDGE_SCRATCH3			63
-
 #endif
diff --git a/arch/mips/include/asm/netlogic/xlr/fmn.h b/arch/mips/include/asm/netlogic/xlr/fmn.h
index 2a78929..d9ade93 100644
--- a/arch/mips/include/asm/netlogic/xlr/fmn.h
+++ b/arch/mips/include/asm/netlogic/xlr/fmn.h
@@ -38,108 +38,108 @@
 #include <asm/netlogic/mips-extns.h> /* for COP2 access */
 
 /* Station IDs */
-#define FMN_STNID_CPU0			0x00
-#define FMN_STNID_CPU1			0x08
-#define FMN_STNID_CPU2			0x10
-#define FMN_STNID_CPU3			0x18
-#define FMN_STNID_CPU4			0x20
-#define FMN_STNID_CPU5			0x28
-#define FMN_STNID_CPU6			0x30
-#define FMN_STNID_CPU7			0x38
-
-#define FMN_STNID_XGS0_TX		64
-#define FMN_STNID_XMAC0_00_TX		64
-#define FMN_STNID_XMAC0_01_TX		65
-#define FMN_STNID_XMAC0_02_TX		66
-#define FMN_STNID_XMAC0_03_TX		67
-#define FMN_STNID_XMAC0_04_TX		68
-#define FMN_STNID_XMAC0_05_TX		69
-#define FMN_STNID_XMAC0_06_TX		70
-#define FMN_STNID_XMAC0_07_TX		71
-#define FMN_STNID_XMAC0_08_TX		72
-#define FMN_STNID_XMAC0_09_TX		73
-#define FMN_STNID_XMAC0_10_TX		74
-#define FMN_STNID_XMAC0_11_TX		75
-#define FMN_STNID_XMAC0_12_TX		76
-#define FMN_STNID_XMAC0_13_TX		77
-#define FMN_STNID_XMAC0_14_TX		78
-#define FMN_STNID_XMAC0_15_TX		79
-
-#define FMN_STNID_XGS1_TX		80
-#define FMN_STNID_XMAC1_00_TX		80
-#define FMN_STNID_XMAC1_01_TX		81
-#define FMN_STNID_XMAC1_02_TX		82
-#define FMN_STNID_XMAC1_03_TX		83
-#define FMN_STNID_XMAC1_04_TX		84
-#define FMN_STNID_XMAC1_05_TX		85
-#define FMN_STNID_XMAC1_06_TX		86
-#define FMN_STNID_XMAC1_07_TX		87
-#define FMN_STNID_XMAC1_08_TX		88
-#define FMN_STNID_XMAC1_09_TX		89
-#define FMN_STNID_XMAC1_10_TX		90
-#define FMN_STNID_XMAC1_11_TX		91
-#define FMN_STNID_XMAC1_12_TX		92
-#define FMN_STNID_XMAC1_13_TX		93
-#define FMN_STNID_XMAC1_14_TX		94
-#define FMN_STNID_XMAC1_15_TX		95
-
-#define FMN_STNID_GMAC			96
-#define FMN_STNID_GMACJFR_0		96
-#define FMN_STNID_GMACRFR_0		97
-#define FMN_STNID_GMACTX0		98
-#define FMN_STNID_GMACTX1		99
-#define FMN_STNID_GMACTX2		100
-#define FMN_STNID_GMACTX3		101
-#define FMN_STNID_GMACJFR_1		102
-#define FMN_STNID_GMACRFR_1		103
-
-#define FMN_STNID_DMA			104
-#define FMN_STNID_DMA_0			104
-#define FMN_STNID_DMA_1			105
-#define FMN_STNID_DMA_2			106
-#define FMN_STNID_DMA_3			107
-
-#define FMN_STNID_XGS0FR		112
-#define FMN_STNID_XMAC0JFR		112
-#define FMN_STNID_XMAC0RFR		113
-
-#define FMN_STNID_XGS1FR		114
-#define FMN_STNID_XMAC1JFR		114
-#define FMN_STNID_XMAC1RFR		115
-#define FMN_STNID_SEC			120
-#define FMN_STNID_SEC0			120
-#define FMN_STNID_SEC1			121
-#define FMN_STNID_SEC2			122
-#define FMN_STNID_SEC3			123
-#define FMN_STNID_PK0			124
-#define FMN_STNID_SEC_RSA		124
-#define FMN_STNID_SEC_RSVD0		125
-#define FMN_STNID_SEC_RSVD1		126
-#define FMN_STNID_SEC_RSVD2		127
-
-#define FMN_STNID_GMAC1			80
-#define FMN_STNID_GMAC1_FR_0		81
-#define FMN_STNID_GMAC1_TX0		82
-#define FMN_STNID_GMAC1_TX1		83
-#define FMN_STNID_GMAC1_TX2		84
-#define FMN_STNID_GMAC1_TX3		85
-#define FMN_STNID_GMAC1_FR_1		87
-#define FMN_STNID_GMAC0			96
-#define FMN_STNID_GMAC0_FR_0		97
-#define FMN_STNID_GMAC0_TX0		98
-#define FMN_STNID_GMAC0_TX1		99
-#define FMN_STNID_GMAC0_TX2		100
-#define FMN_STNID_GMAC0_TX3		101
-#define FMN_STNID_GMAC0_FR_1		103
-#define FMN_STNID_CMP_0			108
-#define FMN_STNID_CMP_1			109
-#define FMN_STNID_CMP_2			110
-#define FMN_STNID_CMP_3			111
-#define FMN_STNID_PCIE_0		116
-#define FMN_STNID_PCIE_1		117
-#define FMN_STNID_PCIE_2		118
-#define FMN_STNID_PCIE_3		119
-#define FMN_STNID_XLS_PK0		121
+#define	FMN_STNID_CPU0			0x00
+#define	FMN_STNID_CPU1			0x08
+#define	FMN_STNID_CPU2			0x10
+#define	FMN_STNID_CPU3			0x18
+#define	FMN_STNID_CPU4			0x20
+#define	FMN_STNID_CPU5			0x28
+#define	FMN_STNID_CPU6			0x30
+#define	FMN_STNID_CPU7			0x38
+
+#define	FMN_STNID_XGS0_TX		64
+#define	FMN_STNID_XMAC0_00_TX		64
+#define	FMN_STNID_XMAC0_01_TX		65
+#define	FMN_STNID_XMAC0_02_TX		66
+#define	FMN_STNID_XMAC0_03_TX		67
+#define	FMN_STNID_XMAC0_04_TX		68
+#define	FMN_STNID_XMAC0_05_TX		69
+#define	FMN_STNID_XMAC0_06_TX		70
+#define	FMN_STNID_XMAC0_07_TX		71
+#define	FMN_STNID_XMAC0_08_TX		72
+#define	FMN_STNID_XMAC0_09_TX		73
+#define	FMN_STNID_XMAC0_10_TX		74
+#define	FMN_STNID_XMAC0_11_TX		75
+#define	FMN_STNID_XMAC0_12_TX		76
+#define	FMN_STNID_XMAC0_13_TX		77
+#define	FMN_STNID_XMAC0_14_TX		78
+#define	FMN_STNID_XMAC0_15_TX		79
+
+#define	FMN_STNID_XGS1_TX		80
+#define	FMN_STNID_XMAC1_00_TX		80
+#define	FMN_STNID_XMAC1_01_TX		81
+#define	FMN_STNID_XMAC1_02_TX		82
+#define	FMN_STNID_XMAC1_03_TX		83
+#define	FMN_STNID_XMAC1_04_TX		84
+#define	FMN_STNID_XMAC1_05_TX		85
+#define	FMN_STNID_XMAC1_06_TX		86
+#define	FMN_STNID_XMAC1_07_TX		87
+#define	FMN_STNID_XMAC1_08_TX		88
+#define	FMN_STNID_XMAC1_09_TX		89
+#define	FMN_STNID_XMAC1_10_TX		90
+#define	FMN_STNID_XMAC1_11_TX		91
+#define	FMN_STNID_XMAC1_12_TX		92
+#define	FMN_STNID_XMAC1_13_TX		93
+#define	FMN_STNID_XMAC1_14_TX		94
+#define	FMN_STNID_XMAC1_15_TX		95
+
+#define	FMN_STNID_GMAC			96
+#define	FMN_STNID_GMACJFR_0		96
+#define	FMN_STNID_GMACRFR_0		97
+#define	FMN_STNID_GMACTX0		98
+#define	FMN_STNID_GMACTX1		99
+#define	FMN_STNID_GMACTX2		100
+#define	FMN_STNID_GMACTX3		101
+#define	FMN_STNID_GMACJFR_1		102
+#define	FMN_STNID_GMACRFR_1		103
+
+#define	FMN_STNID_DMA			104
+#define	FMN_STNID_DMA_0			104
+#define	FMN_STNID_DMA_1			105
+#define	FMN_STNID_DMA_2			106
+#define	FMN_STNID_DMA_3			107
+
+#define	FMN_STNID_XGS0FR		112
+#define	FMN_STNID_XMAC0JFR		112
+#define	FMN_STNID_XMAC0RFR		113
+
+#define	FMN_STNID_XGS1FR		114
+#define	FMN_STNID_XMAC1JFR		114
+#define	FMN_STNID_XMAC1RFR		115
+#define	FMN_STNID_SEC			120
+#define	FMN_STNID_SEC0			120
+#define	FMN_STNID_SEC1			121
+#define	FMN_STNID_SEC2			122
+#define	FMN_STNID_SEC3			123
+#define	FMN_STNID_PK0			124
+#define	FMN_STNID_SEC_RSA		124
+#define	FMN_STNID_SEC_RSVD0		125
+#define	FMN_STNID_SEC_RSVD1		126
+#define	FMN_STNID_SEC_RSVD2		127
+
+#define	FMN_STNID_GMAC1			80
+#define	FMN_STNID_GMAC1_FR_0		81
+#define	FMN_STNID_GMAC1_TX0		82
+#define	FMN_STNID_GMAC1_TX1		83
+#define	FMN_STNID_GMAC1_TX2		84
+#define	FMN_STNID_GMAC1_TX3		85
+#define	FMN_STNID_GMAC1_FR_1		87
+#define	FMN_STNID_GMAC0			96
+#define	FMN_STNID_GMAC0_FR_0		97
+#define	FMN_STNID_GMAC0_TX0		98
+#define	FMN_STNID_GMAC0_TX1		99
+#define	FMN_STNID_GMAC0_TX2		100
+#define	FMN_STNID_GMAC0_TX3		101
+#define	FMN_STNID_GMAC0_FR_1		103
+#define	FMN_STNID_CMP_0			108
+#define	FMN_STNID_CMP_1			109
+#define	FMN_STNID_CMP_2			110
+#define	FMN_STNID_CMP_3			111
+#define	FMN_STNID_PCIE_0		116
+#define	FMN_STNID_PCIE_1		117
+#define	FMN_STNID_PCIE_2		118
+#define	FMN_STNID_PCIE_3		119
+#define	FMN_STNID_XLS_PK0		121
 
 #define nlm_read_c2_cc0(s)		__read_32bit_c2_register($16, s)
 #define nlm_read_c2_cc1(s)		__read_32bit_c2_register($17, s)
@@ -175,6 +175,10 @@
 #define nlm_write_c2_cc14(s, v)		__write_32bit_c2_register($30, s, v)
 #define nlm_write_c2_cc15(s, v)		__write_32bit_c2_register($31, s, v)
 
+#define nlm_read_c2_status0()		__read_32bit_c2_register($2, 0)
+#define nlm_write_c2_status0(v)		__write_32bit_c2_register($2, 0, v)
+#define nlm_read_c2_status1()		__read_32bit_c2_register($2, 1)
+#define nlm_write_c2_status1(v)		__write_32bit_c2_register($2, 1, v)
 #define nlm_read_c2_status(sel)		__read_32bit_c2_register($2, 0)
 #define nlm_read_c2_config()		__read_32bit_c2_register($3, 0)
 #define nlm_write_c2_config(v)		__write_32bit_c2_register($3, 0, v)
@@ -237,7 +241,7 @@ static inline void nlm_msgwait(unsigned int mask)
 /*
  * Disable interrupts and enable COP2 access
  */
-static inline uint32_t nlm_cop2_enable(void)
+static inline uint32_t nlm_cop2_enable_irqsave(void)
 {
 	uint32_t sr = read_c0_status();
 
@@ -245,7 +249,7 @@ static inline uint32_t nlm_cop2_enable(void)
 	return sr;
 }
 
-static inline void nlm_cop2_restore(uint32_t sr)
+static inline void nlm_cop2_disable_irqrestore(uint32_t sr)
 {
 	write_c0_status(sr);
 }
@@ -296,7 +300,7 @@ static inline int nlm_fmn_send(unsigned int size, unsigned int code,
 	 */
 	for (i = 0; i < 8; i++) {
 		nlm_msgsnd(dest);
-		status = nlm_read_c2_status(0);
+		status = nlm_read_c2_status0();
 		if ((status & 0x2) == 1)
 			pr_info("Send pending fail!\n");
 		if ((status & 0x4) == 0)
@@ -316,7 +320,7 @@ static inline int nlm_fmn_receive(int bucket, int *size, int *code, int *stid,
 
 	/* wait for load pending to clear */
 	do {
-		status = nlm_read_c2_status(1);
+		status = nlm_read_c2_status0();
 	} while ((status & 0x08) != 0);
 
 	/* receive error bits */
diff --git a/arch/mips/include/asm/netlogic/xlr/iomap.h b/arch/mips/include/asm/netlogic/xlr/iomap.h
index ff4533d..2e768f0 100644
--- a/arch/mips/include/asm/netlogic/xlr/iomap.h
+++ b/arch/mips/include/asm/netlogic/xlr/iomap.h
@@ -35,66 +35,66 @@
 #ifndef _ASM_NLM_IOMAP_H
 #define _ASM_NLM_IOMAP_H
 
-#define DEFAULT_NETLOGIC_IO_BASE	   CKSEG1ADDR(0x1ef00000)
-#define NETLOGIC_IO_DDR2_CHN0_OFFSET	   0x01000
-#define NETLOGIC_IO_DDR2_CHN1_OFFSET	   0x02000
-#define NETLOGIC_IO_DDR2_CHN2_OFFSET	   0x03000
-#define NETLOGIC_IO_DDR2_CHN3_OFFSET	   0x04000
-#define NETLOGIC_IO_PIC_OFFSET		   0x08000
-#define NETLOGIC_IO_UART_0_OFFSET	   0x14000
-#define NETLOGIC_IO_UART_1_OFFSET	   0x15100
+#define DEFAULT_NETLOGIC_IO_BASE           CKSEG1ADDR(0x1ef00000)
+#define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x01000
+#define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x02000
+#define NETLOGIC_IO_DDR2_CHN2_OFFSET       0x03000
+#define NETLOGIC_IO_DDR2_CHN3_OFFSET       0x04000
+#define NETLOGIC_IO_PIC_OFFSET             0x08000
+#define NETLOGIC_IO_UART_0_OFFSET          0x14000
+#define NETLOGIC_IO_UART_1_OFFSET          0x15100
 
-#define NETLOGIC_IO_SIZE		   0x1000
+#define NETLOGIC_IO_SIZE                   0x1000
 
-#define NETLOGIC_IO_BRIDGE_OFFSET	   0x00000
+#define NETLOGIC_IO_BRIDGE_OFFSET          0x00000
 
-#define NETLOGIC_IO_RLD2_CHN0_OFFSET	   0x05000
-#define NETLOGIC_IO_RLD2_CHN1_OFFSET	   0x06000
+#define NETLOGIC_IO_RLD2_CHN0_OFFSET       0x05000
+#define NETLOGIC_IO_RLD2_CHN1_OFFSET       0x06000
 
-#define NETLOGIC_IO_SRAM_OFFSET		   0x07000
+#define NETLOGIC_IO_SRAM_OFFSET            0x07000
 
-#define NETLOGIC_IO_PCIX_OFFSET		   0x09000
-#define NETLOGIC_IO_HT_OFFSET		   0x0A000
+#define NETLOGIC_IO_PCIX_OFFSET            0x09000
+#define NETLOGIC_IO_HT_OFFSET              0x0A000
 
-#define NETLOGIC_IO_SECURITY_OFFSET	   0x0B000
+#define NETLOGIC_IO_SECURITY_OFFSET        0x0B000
 
-#define NETLOGIC_IO_GMAC_0_OFFSET	   0x0C000
-#define NETLOGIC_IO_GMAC_1_OFFSET	   0x0D000
-#define NETLOGIC_IO_GMAC_2_OFFSET	   0x0E000
-#define NETLOGIC_IO_GMAC_3_OFFSET	   0x0F000
+#define NETLOGIC_IO_GMAC_0_OFFSET          0x0C000
+#define NETLOGIC_IO_GMAC_1_OFFSET          0x0D000
+#define NETLOGIC_IO_GMAC_2_OFFSET          0x0E000
+#define NETLOGIC_IO_GMAC_3_OFFSET          0x0F000
 
 /* XLS devices */
-#define NETLOGIC_IO_GMAC_4_OFFSET	   0x20000
-#define NETLOGIC_IO_GMAC_5_OFFSET	   0x21000
-#define NETLOGIC_IO_GMAC_6_OFFSET	   0x22000
-#define NETLOGIC_IO_GMAC_7_OFFSET	   0x23000
+#define NETLOGIC_IO_GMAC_4_OFFSET          0x20000
+#define NETLOGIC_IO_GMAC_5_OFFSET          0x21000
+#define NETLOGIC_IO_GMAC_6_OFFSET          0x22000
+#define NETLOGIC_IO_GMAC_7_OFFSET          0x23000
 
-#define NETLOGIC_IO_PCIE_0_OFFSET	   0x1E000
-#define NETLOGIC_IO_PCIE_1_OFFSET	   0x1F000
-#define NETLOGIC_IO_SRIO_0_OFFSET	   0x1E000
-#define NETLOGIC_IO_SRIO_1_OFFSET	   0x1F000
+#define NETLOGIC_IO_PCIE_0_OFFSET          0x1E000
+#define NETLOGIC_IO_PCIE_1_OFFSET          0x1F000
+#define NETLOGIC_IO_SRIO_0_OFFSET          0x1E000
+#define NETLOGIC_IO_SRIO_1_OFFSET          0x1F000
 
-#define NETLOGIC_IO_USB_0_OFFSET	   0x24000
-#define NETLOGIC_IO_USB_1_OFFSET	   0x25000
+#define NETLOGIC_IO_USB_0_OFFSET           0x24000
+#define NETLOGIC_IO_USB_1_OFFSET           0x25000
 
-#define NETLOGIC_IO_COMP_OFFSET		   0x1D000
+#define NETLOGIC_IO_COMP_OFFSET            0x1D000
 /* end XLS devices */
 
 /* XLR devices */
-#define NETLOGIC_IO_SPI4_0_OFFSET	   0x10000
-#define NETLOGIC_IO_XGMAC_0_OFFSET	   0x11000
-#define NETLOGIC_IO_SPI4_1_OFFSET	   0x12000
-#define NETLOGIC_IO_XGMAC_1_OFFSET	   0x13000
+#define NETLOGIC_IO_SPI4_0_OFFSET          0x10000
+#define NETLOGIC_IO_XGMAC_0_OFFSET         0x11000
+#define NETLOGIC_IO_SPI4_1_OFFSET          0x12000
+#define NETLOGIC_IO_XGMAC_1_OFFSET         0x13000
 /* end XLR devices */
 
-#define NETLOGIC_IO_I2C_0_OFFSET	   0x16000
-#define NETLOGIC_IO_I2C_1_OFFSET	   0x17000
+#define NETLOGIC_IO_I2C_0_OFFSET           0x16000
+#define NETLOGIC_IO_I2C_1_OFFSET           0x17000
 
-#define NETLOGIC_IO_GPIO_OFFSET		   0x18000
-#define NETLOGIC_IO_FLASH_OFFSET	   0x19000
-#define NETLOGIC_IO_TB_OFFSET		   0x1C000
+#define NETLOGIC_IO_GPIO_OFFSET            0x18000
+#define NETLOGIC_IO_FLASH_OFFSET           0x19000
+#define NETLOGIC_IO_TB_OFFSET              0x1C000
 
-#define NETLOGIC_CPLD_OFFSET		   KSEG1ADDR(0x1d840000)
+#define NETLOGIC_CPLD_OFFSET               KSEG1ADDR(0x1d840000)
 
 /*
  * Base Address (Virtual) of the PCI Config address space
@@ -102,8 +102,8 @@
  * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
  * ie 1<<24 = 16M
  */
-#define DEFAULT_PCI_CONFIG_BASE		0x18000000
-#define DEFAULT_HT_TYPE0_CFG_BASE	0x16000000
-#define DEFAULT_HT_TYPE1_CFG_BASE	0x17000000
+#define DEFAULT_PCI_CONFIG_BASE         0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
 
 #endif
diff --git a/arch/mips/include/asm/netlogic/xlr/msidef.h b/arch/mips/include/asm/netlogic/xlr/msidef.h
index c95d18e..7e39d40 100644
--- a/arch/mips/include/asm/netlogic/xlr/msidef.h
+++ b/arch/mips/include/asm/netlogic/xlr/msidef.h
@@ -45,21 +45,21 @@
  */
 
 #define MSI_DATA_VECTOR_SHIFT		0
-#define	 MSI_DATA_VECTOR_MASK		0x000000ff
+#define  MSI_DATA_VECTOR_MASK		0x000000ff
 #define	 MSI_DATA_VECTOR(v)		(((v) << MSI_DATA_VECTOR_SHIFT) & \
 						MSI_DATA_VECTOR_MASK)
 
 #define MSI_DATA_DELIVERY_MODE_SHIFT	8
-#define	 MSI_DATA_DELIVERY_FIXED	(0 << MSI_DATA_DELIVERY_MODE_SHIFT)
-#define	 MSI_DATA_DELIVERY_LOWPRI	(1 << MSI_DATA_DELIVERY_MODE_SHIFT)
+#define  MSI_DATA_DELIVERY_FIXED	(0 << MSI_DATA_DELIVERY_MODE_SHIFT)
+#define  MSI_DATA_DELIVERY_LOWPRI	(1 << MSI_DATA_DELIVERY_MODE_SHIFT)
 
 #define MSI_DATA_LEVEL_SHIFT		14
 #define	 MSI_DATA_LEVEL_DEASSERT	(0 << MSI_DATA_LEVEL_SHIFT)
 #define	 MSI_DATA_LEVEL_ASSERT		(1 << MSI_DATA_LEVEL_SHIFT)
 
 #define MSI_DATA_TRIGGER_SHIFT		15
-#define	 MSI_DATA_TRIGGER_EDGE		(0 << MSI_DATA_TRIGGER_SHIFT)
-#define	 MSI_DATA_TRIGGER_LEVEL		(1 << MSI_DATA_TRIGGER_SHIFT)
+#define  MSI_DATA_TRIGGER_EDGE		(0 << MSI_DATA_TRIGGER_SHIFT)
+#define  MSI_DATA_TRIGGER_LEVEL		(1 << MSI_DATA_TRIGGER_SHIFT)
 
 /*
  * Shift/mask fields for msi address
@@ -69,16 +69,16 @@
 #define MSI_ADDR_BASE_LO		0xfee00000
 
 #define MSI_ADDR_DEST_MODE_SHIFT	2
-#define	 MSI_ADDR_DEST_MODE_PHYSICAL	(0 << MSI_ADDR_DEST_MODE_SHIFT)
+#define  MSI_ADDR_DEST_MODE_PHYSICAL	(0 << MSI_ADDR_DEST_MODE_SHIFT)
 #define	 MSI_ADDR_DEST_MODE_LOGICAL	(1 << MSI_ADDR_DEST_MODE_SHIFT)
 
 #define MSI_ADDR_REDIRECTION_SHIFT	3
-#define	 MSI_ADDR_REDIRECTION_CPU	(0 << MSI_ADDR_REDIRECTION_SHIFT)
-#define	 MSI_ADDR_REDIRECTION_LOWPRI	(1 << MSI_ADDR_REDIRECTION_SHIFT)
+#define  MSI_ADDR_REDIRECTION_CPU	(0 << MSI_ADDR_REDIRECTION_SHIFT)
+#define  MSI_ADDR_REDIRECTION_LOWPRI	(1 << MSI_ADDR_REDIRECTION_SHIFT)
 
 #define MSI_ADDR_DEST_ID_SHIFT		12
 #define	 MSI_ADDR_DEST_ID_MASK		0x00ffff0
-#define	 MSI_ADDR_DEST_ID(dest)		(((dest) << MSI_ADDR_DEST_ID_SHIFT) & \
+#define  MSI_ADDR_DEST_ID(dest)		(((dest) << MSI_ADDR_DEST_ID_SHIFT) & \
 						 MSI_ADDR_DEST_ID_MASK)
 
 #endif /* ASM_RMI_MSIDEF_H */
diff --git a/arch/mips/include/asm/netlogic/xlr/pic.h b/arch/mips/include/asm/netlogic/xlr/pic.h
index 63c9917..04cd8fa 100644
--- a/arch/mips/include/asm/netlogic/xlr/pic.h
+++ b/arch/mips/include/asm/netlogic/xlr/pic.h
@@ -36,6 +36,8 @@
 #define _ASM_NLM_XLR_PIC_H
 
 #define PIC_CLK_HZ			66666666
+#define pic_timer_freq()		PIC_CLK_HZ
+
 /* PIC hardware interrupt numbers */
 #define PIC_IRT_WD_INDEX		0
 #define PIC_IRT_TIMER_0_INDEX		1
@@ -118,7 +120,7 @@
 #define PIC_TIMER_COUNT_0_BASE		0x120
 #define PIC_TIMER_COUNT_1_BASE		0x130
 
-#define PIC_IRT_0(picintr)	(PIC_IRT_0_BASE + (picintr))
+#define PIC_IRT_0(picintr)      (PIC_IRT_0_BASE + (picintr))
 #define PIC_IRT_1(picintr)	(PIC_IRT_1_BASE + (picintr))
 
 #define PIC_TIMER_MAXVAL_0(i)	(PIC_TIMER_MAXVAL_0_BASE + (i))
@@ -132,9 +134,9 @@
  * 8-39. This leaves the IRQ 0-7 for cpu interrupts like
  * count/compare and FMN
  */
-#define PIC_IRQ_BASE		8
-#define PIC_INTR_TO_IRQ(i)	(PIC_IRQ_BASE + (i))
-#define PIC_IRQ_TO_INTR(i)	((i) - PIC_IRQ_BASE)
+#define PIC_IRQ_BASE            8
+#define PIC_INTR_TO_IRQ(i)      (PIC_IRQ_BASE + (i))
+#define PIC_IRQ_TO_INTR(i)      ((i) - PIC_IRQ_BASE)
 
 #define PIC_IRT_FIRST_IRQ	PIC_IRQ_BASE
 #define PIC_WD_IRQ		PIC_INTR_TO_IRQ(PIC_IRT_WD_INDEX)
@@ -170,7 +172,7 @@
 #define PIC_BRIDGE_AERR_IRQ	PIC_INTR_TO_IRQ(PIC_IRT_BRIDGE_AERR_INDEX)
 #define PIC_BRIDGE_BERR_IRQ	PIC_INTR_TO_IRQ(PIC_IRT_BRIDGE_BERR_INDEX)
 #define PIC_BRIDGE_TB_XLR_IRQ	PIC_INTR_TO_IRQ(PIC_IRT_BRIDGE_TB_XLR_INDEX)
-#define PIC_BRIDGE_AERR_NMI_IRQ PIC_INTR_TO_IRQ(PIC_IRT_BRIDGE_AERR_NMI_INDEX)
+#define PIC_BRIDGE_AERR_NMI_IRQ	PIC_INTR_TO_IRQ(PIC_IRT_BRIDGE_AERR_NMI_INDEX)
 /* XLS defines */
 #define PIC_GMAC_4_IRQ		PIC_INTR_TO_IRQ(PIC_IRT_GMAC4_INDEX)
 #define PIC_GMAC_5_IRQ		PIC_INTR_TO_IRQ(PIC_IRT_GMAC5_INDEX)
-- 
1.7.9.5

