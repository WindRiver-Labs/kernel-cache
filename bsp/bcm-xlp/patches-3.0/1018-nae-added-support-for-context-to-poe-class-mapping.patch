From 2c5fc34a2fae449e6d51480a46e9147126e93534 Mon Sep 17 00:00:00 2001
From: Virendra Pathak <vpathak@broadcom.com>
Date: Mon, 28 Oct 2013 15:41:09 +0530
Subject: [PATCH 018/160] nae: added support for context to poe class mapping

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 .../mips/netlogic/lib/netlib/include/nlm_hal_nae.h |    1 -
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |    7 +++
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |    1 +
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |   63 ++++++++++++++++++++
 arch/mips/netlogic/lib/netlib/src/netsoc_nae.c     |   47 ++++++++++++++-
 5 files changed, 115 insertions(+), 4 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index d460725..d614956 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -70,7 +70,6 @@
 #define XLP3XX_MAX_NAE_FREQUENCY	250 /* in MHZ */
 #define XLP3XX_MAX_NAE_COMPLEX	2
 #define XLP3XX_MAX_NAE_CONTEXTS	64
-#define MAX_POE_CLASSES     	8
 #define MAX_POE_CLASS_CTXT_TBL_SZ ((MAX_NAE_CONTEXTS / MAX_POE_CLASSES) + 1)
 #define XLP3XX_MAX_POE_CLASS_CTXT_TBL_SZ ((XLP3XX_MAX_NAE_CONTEXTS / MAX_POE_CLASSES))
 #define XLP3XX_SGMII_PARSERSEQ_FIFO_MAX	30
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index cd5414c..c177857 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -66,6 +66,11 @@
 
 #define MAX_PORTS_PERBLOCK     4
 #define MAX_POE_DV             16
+#define MAX_POE_CLASSES        8
+#define POE_CLASS_MASK         0X7
+#define POE_CLASS_BIT_SZ       3
+#define POE_CTX_RANGE_WD       2
+#define MAX_CTX_PER_ENTRY      8
 
 #define NLM_NAE_LNX_SHINFO_FL_VALID     0x01
 #define NLM_NAE_LNX_SHINFO_FL_JUMBO_EN  0x02
@@ -388,6 +393,8 @@ struct nlm_hal_nae_config {
        
         uint32_t cpu_bypass_mode;  /* ucore cpu bypass mode enable */
 	uint32_t default_class;
+	uint32_t poe_class_en;	/* If set to 1 then context to poe class mapping is enabled */
+	uint32_t *poe_cl_tbl;
         /* ALE */
         uint32_t ale_enable;
 	uint32_t parser_enable;
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 6ebafae..4a9210c 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -492,6 +492,7 @@ static void __netsoc_update_nae_defaultconfig(nae_t *nae)
                 nae->cntx2port[i] = MAX_NAE_PORTS_PERNODE;
         }
 	nae->default_class = 0;
+	nae->poe_class_en = 0;
 	__netsoc_set_frin_queue_base(nae);
 	__netsoc_set_frin_total_queue(nae);
 	
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 145cf9f..41ca6b3 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -1302,6 +1302,64 @@ int fdt_get_nae_frequency(void *fdt, nae_t *nae)
         return 0;
 }
 
+int fdt_get_nae_poe_class_config(void *fdt, nae_t *nae)
+{
+	int nodeoffset, plen;
+	char path_str[50];
+	uint32_t *pval;
+
+	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
+
+	nodeoffset = fdt_path_offset(fdt, path_str);
+	if (nodeoffset >= 0) {
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "poe-class-context-enable", &plen);
+		if (pval != NULL) {
+			nae->poe_class_en = fdt32_to_cpu(*(uint32_t *)(pval));
+		}
+		else {
+			nae->poe_class_en = 0;
+		}
+	}
+	return 0;
+}
+
+int fdt_update_poe_class_tbl(void *fdt, nae_t *nae)
+{
+	int nodeoffset, plen;
+	char path_str[50];
+	uint32_t *pval;
+	int i, plen_index = 0;
+	int size = 0;
+	int index = 0;
+	uint32_t ctx = 0;
+	
+	/* allocating memory for poe class table */
+	size = sizeof(uint32_t) * (MAX_POE_CLASSES * POE_CTX_RANGE_WD);
+	nae->poe_cl_tbl = netsoc_api_malloc(size);
+	if (nae->poe_cl_tbl == NULL) {
+		netsoc_api_print(NETSOC_APIDBG_ERROR,"poe class tbl memory allocation failed");
+		return NETSOC_API_MALLOC_FAILED;
+        }
+	memset(nae->poe_cl_tbl, 0, size);
+
+	sprintf(path_str, "/soc/net@node-%d/nae-%d", nae->node, nae->nae_id);
+
+	nodeoffset = fdt_path_offset(fdt, path_str);
+	if (nodeoffset >= 0) {
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "class-context-map", &plen);
+		plen /= sizeof(unsigned int);
+		plen_index = plen - 1;
+		if (pval != NULL) {
+			for (i = plen_index; i >= 0; i--) {
+				ctx = fdt32_to_cpu(pval[i]);
+				index = (plen_index - i);
+				nae->poe_cl_tbl[index] = ctx;
+			}
+		}
+	}
+	return 0;
+}
+
 int fdt_get_nae_ale_config(void *fdt, nae_t *nae)
 {
         int nodeoffset, plen;
@@ -1403,6 +1461,11 @@ int fdt_parse_netsoc_nae_config(void *fdt, int dom_id, nae_t *nae)
 		return 0;
 	}
 
+	fdt_get_nae_poe_class_config(fdt, nae);
+	if (nae->poe_class_en) {
+		fdt_update_poe_class_tbl(fdt, nae);
+	}
+
         if (current_netsoc->hw_features & NETSOC_ALE)
             fdt_get_nae_ale_config(fdt, nae);
 
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
index 9ffb07c..8ea693a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_nae.c
@@ -1112,11 +1112,38 @@ int __netsoc_config_vfbid_table(nae_t *nae, uint32_t start, uint32_t num_entries
 	return NETSOC_API_SUCCESS;
 }
 
+static int get_poe_class_num(nae_t *nae, int ctx_num)
+{
+	int i;
+	int class_num = 0;
+
+	for (i = 0; i < (MAX_POE_CLASSES * POE_CTX_RANGE_WD); i += POE_CTX_RANGE_WD) {
+		if ((ctx_num >= nae->poe_cl_tbl[i]) && 
+				(ctx_num <= nae->poe_cl_tbl[i+1])) {
+			class_num = i / POE_CTX_RANGE_WD;
+			break;
+		}
+	}
+	return class_num;
+}
+
+/* __netsoc_config_poe_class: configure context to poe class mapping.
+ *
+ * If poe class mapping is not enabled then all context are mapped
+ * to a default class (nae->default_class).
+ * Otherwise for each context within a poe class table entry, class values 
+ * are calculated from nae->poe_cl_tbl. Then calculated mapping (val)
+ * is updated in POE_CLASS_SETUP_CFG.
+ * Above step is repeated for all table entries upto max_poe_tbl_sz.
+ **/
+
 void __netsoc_config_poe_class(nae_t *nae)
 {
-        int i;
-        uint32_t val;
+        int i, j;
+        uint32_t val, cval;
 	int max_poe_tbl_sz;
+	int class_num = 0;
+	int ctx_num;
         int poe_cl_tbl[MAX_POE_CLASSES] = {0x0, 0x249249, 0x492492,
                                            0x6db6db, 0x924924, 0xb6db6d,
                                            0xdb6db6, 0xffffff};
@@ -1127,9 +1154,23 @@ void __netsoc_config_poe_class(nae_t *nae)
 		max_poe_tbl_sz++;
 
         netsoc_api_print(NETSOC_APIDBG_CONFIG, "max_poe_tbl_sz %d\n",max_poe_tbl_sz);
+	if (nae->poe_class_en) {
+		netsoc_api_print(NETSOC_APIDBG_CONFIG, "%s context to poe class mapping enabled \n",__func__);
+	}
+
         for (i = 0; i <max_poe_tbl_sz; ++i) {
                 val = (0x00 | i); /* clear the read bit 0x80 */
-                val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
+		if (nae->poe_class_en) {
+			cval = 0;
+			ctx_num = (i * MAX_CTX_PER_ENTRY);
+			for (j = 0; j < MAX_CTX_PER_ENTRY; j++, ctx_num++) {
+				class_num = get_poe_class_num(nae, ctx_num);
+				cval |= ((class_num & POE_CLASS_MASK) << (j * POE_CLASS_BIT_SZ));
+			}
+                	val |= (cval << 8);
+		} else {
+                	val |= (poe_cl_tbl[nae->default_class & 0x7] << 8); // All the contexts are mapped to default class number.
+		}
 
                 netsoc_api_print(NETSOC_APIDBG_CONFIG, "POE index %d val %x \n",i, val);
                 netsoc_write_nae_reg(nae->nae_base, POE_CLASS_SETUP_CFG, val);
-- 
1.7.9.5

