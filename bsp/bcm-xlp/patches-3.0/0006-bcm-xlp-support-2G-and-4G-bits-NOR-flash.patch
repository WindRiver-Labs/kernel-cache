From 835e023bd30bf119f637209202a8d91f6f6ad8cd Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 14 Aug 2014 13:30:02 +0800
Subject: [PATCH 6/8] bcm-xlp: support 2G and 4G bits NOR flash

Support 2G and 4G bits NOR flash.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/chips/cfi_cmdset_0002.c | 120 ++++++++++++++++++++++++++++--------
 1 file changed, 93 insertions(+), 27 deletions(-)

diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index fff665d..2aa75fd 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -50,6 +50,8 @@
 #define SST49LF008A		0x005a
 #define AT49BV6416		0x00d6
 
+#define SECONDCHIPSTART		0x8000000
+
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -437,6 +439,16 @@ static void cfi_fixup_major_minor(struct cfi_private *cfi,
 	}
 }
 
+static int is_s29gl(struct cfi_private *cfi)
+{
+	if (cfi->mfr == CFI_MFR_AMD &&
+	((cfi->device_type == CFI_DEVICETYPE_X8 && (cfi->id & 0xff) == 0x01) ||
+	(cfi->device_type == CFI_DEVICETYPE_X16 && cfi->id == 0x4801)))
+		return 1;
+
+	return 0;
+}
+
 static int is_m29ew(struct cfi_private *cfi)
 {
 	if (cfi->mfr == CFI_MFR_INTEL &&
@@ -465,6 +477,16 @@ static void cfi_fixup_m29ew_erase_suspend(struct map_info *map,
 		map_write(map, CMD(0xF0), adr);
 }
 
+static void cfi_fixup_s29gl_delay_after_resume(struct cfi_private *cfi)
+{
+	/*
+	 * Resolving the Delay After Resume Issue
+	 * Worst case delay must be 200¦Ìs or shorter
+	 */
+	if (is_s29gl(cfi))
+		cfi_udelay(200);
+}
+
 /*
  * From TN-13-07: Patching the Linux Kernel and U-Boot for M29 Flash, page 22:
  *
@@ -784,6 +806,8 @@ static int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr
 		    !(mode == FL_READY || mode == FL_POINT ||
 		    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))
 			goto sleep;
+		if (unlikely(is_m29ew(cfi)))
+			goto sleep;
 
 		/* We could check to see if we're trying to access the sector
 		 * that is currently being erased. However, no user will try
@@ -859,7 +883,6 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 		cfi_fixup_m29ew_erase_suspend(map,
 			chip->in_progress_block_addr);
 		map_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);
-		cfi_fixup_m29ew_delay_after_resume(cfi);
 		chip->oldstate = FL_READY;
 		chip->state = FL_ERASING;
 		break;
@@ -1003,6 +1026,7 @@ static void __xipram xip_udelay(struct map_info *map, struct flchip *chip,
 			cfi_fixup_m29ew_erase_suspend(map, adr);
 			/* Resume the write or erase operation */
 			map_write(map, cfi->sector_erase_cmd, adr);
+			cfi_fixup_s29gl_delay_after_resume(cfi);
 			chip->state = oldstate;
 			start = xip_currtime();
 		} else if (usec >= 1000000/HZ) {
@@ -1238,10 +1262,11 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	 * depending of the conditions.	 The ' + 1' is to avoid having a
 	 * timeout of 0 jiffies if HZ is smaller than 1000.
 	 */
-	unsigned long uWriteTimeout = ( HZ / 1000 ) + 1;
+	unsigned long U_WRITE_TIMEOUT = (HZ / 1000) + 1;
 	int ret = 0;
 	map_word oldd;
 	int retry_cnt = 0;
+	unsigned long start = chip->start;
 
 	adr += chip->start;
 
@@ -1271,10 +1296,16 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	XIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));
 	ENABLE_VPP(map);
 	xip_disable(map, chip, adr);
+
+	if (adr >= SECONDCHIPSTART * cfi->interleave + chip->start)
+		start = SECONDCHIPSTART * cfi->interleave + chip->start;
  retry:
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1,
+			start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2,
+			start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1,
+			start, map, cfi, cfi->device_type, NULL);
 	map_write(map, datum, adr);
 	chip->state = FL_WRITING;
 
@@ -1283,7 +1314,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 				chip->word_write_time);
 
 	/* See comment above for timeout value. */
-	timeo = jiffies + uWriteTimeout;
+	timeo = jiffies + U_WRITE_TIMEOUT;
 	for (;;) {
 		if (chip->state != FL_WRITING) {
 			/* Someone's suspended the write. Sleep */
@@ -1315,7 +1346,7 @@ static int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,
 	/* Did we succeed? */
 	if (!chip_good(map, adr, datum)) {
 		/* reset on all failures. */
-		map_write( map, CMD(0xF0), chip->start );
+		map_write(map, CMD(0xF0), start);
 		/* FIXME - should have reset delay before continuing */
 
 		if (++retry_cnt <= MAX_WORD_RETRIES)
@@ -1468,11 +1499,12 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 	struct cfi_private *cfi = map->fldrv_priv;
 	unsigned long timeo = jiffies + HZ;
 	/* see comments in do_write_oneword() regarding uWriteTimeo. */
-	unsigned long uWriteTimeout = ( HZ / 1000 ) + 1;
+	unsigned long U_WRITE_TIMEOUT = (HZ / 1000) + 1;
 	int ret = -EIO;
 	unsigned long cmd_adr;
 	int z, words;
 	map_word datum;
+	unsigned long start = chip->start;
 
 	adr += chip->start;
 	cmd_adr = adr;
@@ -1493,8 +1525,12 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 	ENABLE_VPP(map);
 	xip_disable(map, chip, cmd_adr);
 
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	if (adr >= SECONDCHIPSTART * cfi->interleave + chip->start)
+		start = SECONDCHIPSTART * cfi->interleave + chip->start;
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2,
+		start, map, cfi, cfi->device_type, NULL);
 
 	/* Write Buffer Load */
 	map_write(map, CMD(0x25), cmd_adr);
@@ -1525,7 +1561,14 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 				adr, map_bankwidth(map),
 				chip->word_write_time);
 
-	timeo = jiffies + uWriteTimeout;
+	/* U_WRITE_TIMEOUT is only one experienced time slot. So its necessary
+	 * to add the given chip buffer write time to make sure the actual write
+	 * timeout is enough.
+	 */
+	if (U_WRITE_TIMEOUT < chip->buffer_write_time)
+		U_WRITE_TIMEOUT += chip->buffer_write_time;
+
+	timeo = jiffies + U_WRITE_TIMEOUT;
 
 	for (;;) {
 		if (chip->state != FL_WRITING) {
@@ -1562,11 +1605,11 @@ static int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,
 	 * See e.g.
 	 * http://www.spansion.com/Support/Application%20Notes/MirrorBit_Write_Buffer_Prog_Page_Buffer_Read_AN.pdf
 	 */
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, start, map, cfi,
 			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, start, map, cfi,
 			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, chip->start, map, cfi,
+	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, start, map, cfi,
 			 cfi->device_type, NULL);
 	xip_enable(map, chip, adr);
 	/* FIXME - should have reset delay before continuing */
@@ -1674,6 +1717,7 @@ static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
 	struct cfi_private *cfi = map->fldrv_priv;
 	int retries = 10;
 	int i;
+	unsigned long start = chip->start;
 
 	/*
 	 * If the driver thinks the chip is idle, and no toggle bits
@@ -1688,11 +1732,13 @@ static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
 	 * delay isn't a big problem: the kernel is dying anyway. It
 	 * is more important to save the messages.
 	 */
+	if (adr >= SECONDCHIPSTART * cfi->interleave + chip->start)
+		start = SECONDCHIPSTART * cfi->interleave + chip->start;
 	while (retries > 0) {
 		const unsigned long timeo = (HZ / 1000) + 1;
 
 		/* send the reset command */
-		map_write(map, CMD(0xF0), chip->start);
+		map_write(map, CMD(0xF0), start);
 
 		/* wait for the chip to become ready */
 		for (i = 0; i < jiffies_to_usecs(timeo); i++) {
@@ -1721,12 +1767,13 @@ static int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,
 static int do_panic_write_oneword(struct map_info *map, struct flchip *chip,
 				  unsigned long adr, map_word datum)
 {
-	const unsigned long uWriteTimeout = (HZ / 1000) + 1;
+	const unsigned long U_WRITE_TIMEOUT = (HZ / 1000) + 1;
 	struct cfi_private *cfi = map->fldrv_priv;
 	int retry_cnt = 0;
 	map_word oldd;
 	int ret = 0;
 	int i;
+	unsigned long start = chip->start;
 
 	adr += chip->start;
 
@@ -1751,13 +1798,18 @@ static int do_panic_write_oneword(struct map_info *map, struct flchip *chip,
 
 	ENABLE_VPP(map);
 
+	if (adr >= SECONDCHIPSTART * cfi->interleave + chip->start)
+		start = SECONDCHIPSTART * cfi->interleave + chip->start;
 retry:
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
 	map_write(map, datum, adr);
 
-	for (i = 0; i < jiffies_to_usecs(uWriteTimeout); i++) {
+	for (i = 0; i < jiffies_to_usecs(U_WRITE_TIMEOUT); i++) {
 		if (chip_ready(map, adr))
 			break;
 
@@ -1766,7 +1818,7 @@ retry:
 
 	if (!chip_good(map, adr, datum)) {
 		/* reset on all failures. */
-		map_write(map, CMD(0xF0), chip->start);
+		map_write(map, CMD(0xF0), start);
 		/* FIXME - should have reset delay before continuing */
 
 		if (++retry_cnt <= MAX_WORD_RETRIES)
@@ -1993,6 +2045,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	unsigned long timeo = jiffies + HZ;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret = 0;
+	unsigned long start = chip->start;
 
 	adr += chip->start;
 
@@ -2010,11 +2063,18 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	ENABLE_VPP(map);
 	xip_disable(map, chip, adr);
 
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
+	if (adr >= SECONDCHIPSTART * cfi->interleave + chip->start)
+		start = SECONDCHIPSTART * cfi->interleave + chip->start;
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x80, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1,
+		start, map, cfi, cfi->device_type, NULL);
+	cfi_send_gen_cmd(0x55, cfi->addr_unlock2,
+		start, map, cfi, cfi->device_type, NULL);
 	map_write(map, cfi->sector_erase_cmd, adr);
 
 	chip->state = FL_ERASING;
@@ -2063,7 +2123,7 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	/* Did we succeed? */
 	if (!chip_good(map, adr, map_word_ff(map))) {
 		/* reset on all failures. */
-		map_write( map, CMD(0xF0), chip->start );
+		map_write(map, CMD(0xF0), start);
 		/* FIXME - should have reset delay before continuing */
 
 		ret = -EIO;
@@ -2521,6 +2581,9 @@ static void cfi_amdstd_resume(struct mtd_info *mtd)
 		if (chip->state == FL_PM_SUSPENDED) {
 			chip->state = FL_READY;
 			map_write(map, CMD(0xF0), chip->start);
+			if (map->size >= SECONDCHIPSTART)
+				map_write(map, CMD(0xF0),
+				SECONDCHIPSTART * cfi->interleave);
 			wake_up(&chip->wq);
 		}
 		else
@@ -2553,6 +2616,9 @@ static int cfi_amdstd_reset(struct mtd_info *mtd)
 		ret = get_chip(map, chip, chip->start, FL_SHUTDOWN);
 		if (!ret) {
 			map_write(map, CMD(0xF0), chip->start);
+			if (map->size >= SECONDCHIPSTART)
+				map_write(map, CMD(0xF0),
+				SECONDCHIPSTART * cfi->interleave);
 			chip->state = FL_SHUTDOWN;
 			put_chip(map, chip, chip->start);
 		}
-- 
1.9.1

