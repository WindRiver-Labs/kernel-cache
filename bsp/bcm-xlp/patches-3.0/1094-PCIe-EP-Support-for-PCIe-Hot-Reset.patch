From 59d4776cf7485c28d6035c56f375e306dc78c229 Mon Sep 17 00:00:00 2001
From: ajesh <ajesh@broadcom.com>
Date: Wed, 8 Jan 2014 20:32:43 +0530
Subject: [PATCH 094/163] PCIe EP: Support for PCIe Hot Reset

Typically, when the system is in Device Mode, the Hardware takes care of links
when a hotreset request comes from the Host. However, on XLP, it has to be done
through Software.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/pci/pci-xlp.c |  138 +++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 135 insertions(+), 3 deletions(-)

diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 768ce5e..a28cfb8c 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -41,6 +41,8 @@
 #include <linux/irq.h>
 #include <linux/irqdesc.h>
 #include <linux/console.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 
@@ -52,12 +54,13 @@
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
 #include <asm/netlogic/xlp-hal/pcibus.h>
 #include <asm/netlogic/xlp-hal/bridge.h>
 #include <asm/netlogic/kvm_para.h>
 
 static void *pci_config_base;
-
+#define PCIE_HOT_RESET_ENABLE 1
 #define pci_cfg_addr(bus, devfn, off) (((bus) << 20) | ((devfn) << 12) | (off))
 
 /* PCI ops */
@@ -328,7 +331,7 @@ int xlp_fixup_numa_node(struct device *dev)
 
 		/* fix the node numbers in top level devices */
 		if (pdev->bus->number == 0) {
-			if (cpu_is_xlp9xx())
+		}if (cpu_is_xlp9xx())
 				node = PCI_FUNC(pdev->devfn);
 			else
 				node = PCI_SLOT(pdev->devfn) / 8;
@@ -338,7 +341,132 @@ int xlp_fixup_numa_node(struct device *dev)
 	return 0;
 }
 #endif
+#ifdef PCIE_HOT_RESET_ENABLE
+
+static void modify_def_value()
+{
+	uint64_t sysbase = nlm_get_sys_pcibase(0);
+	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
+	uint32_t pcfg = (sysreg >> 12) & 0x3;
+	uint64_t pciebase = nlm_get_pcie_base(0,0);
+	uint32_t pcicontrol, link;
+
+	switch(pcfg)
+	{
+		case 1:
+			link = nlm_read_pci_reg(pciebase, 0x1f);
+			nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x20));
+			break;
+		case 2:
+		case 3:
+		    link = nlm_read_pci_reg(pciebase, 0x1f);
+			nlm_write_pci_reg(pciebase, 0x1f, ((link & 0xfffffc0f) | 0x10));
+			break;
+		default:
+			break;
+	}
+
+	nlm_write_pci_reg(pciebase, 0x5f, 0x00000000);
+
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+	nlm_write_pci_reg(pciebase, 0x240,(pcicontrol | (1 << 21)));
+
+	pcicontrol = nlm_read_pci_reg(pciebase,0x65);
+	nlm_write_pci_reg(pciebase,0x65,((pcicontrol & 0xf) | 0x3ff1));
+
+	pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+	nlm_write_pci_reg(pciebase, 0x240, (pcicontrol & ~(1 << 21)));
+}
+static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
+{
+	uint64_t pciebase;
+	uint32_t pciint, pcicontrol;
+
+	pr_err("In Int Handler\n");
+	pciebase = nlm_get_pcie_base(0,0);
+
+	pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
+
+	if(pciint & 0x1)
+	{
+		if((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21) != 0)
+		{
+			pr_info("Transaction Pending \n");
+			pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+			nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x3 << 27));
+		}
+		
+		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+		nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1 << 3));
+
+		while((nlm_read_pci_reg(pciebase, 0x1e)) & (0x1 << 21) != 0)
+		{
+			//udelay(200);
+		}
+		pr_err("Transaction Cleared\n");
+
+		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+        nlm_write_pci_reg(pciebase, 0x240, pcicontrol & ~(0x1));
 
+		pcicontrol = nlm_read_pci_reg(pciebase, 0x241);
+		nlm_write_pci_reg(pciebase, 0x241, pcicontrol | (0x1 << 17));
+		udelay(1000);
+
+		nlm_write_pci_reg(pciebase, 0x241, pcicontrol & ~(0x1 << 17));
+
+		pcicontrol = nlm_read_pci_reg(pciebase, 0x240);
+        nlm_write_pci_reg(pciebase, 0x240, pcicontrol | (0x9));
+
+		pciint = nlm_read_pci_reg(pciebase, PCIE_INT_STATUS1);
+		nlm_write_pci_reg(pciebase, PCIE_INT_STATUS1, pciint | 0x1);
+
+		modify_def_value();
+
+		pr_info("Hot Reset Interrupt handled \n");
+	}
+	else
+	{
+		pr_info("spurious Interrupt PCIe hot Reset \n");
+	}
+	return IRQ_HANDLED;
+}
+
+static int __init xlp_pci_hot_reset_init(void)
+{
+	uint64_t sysbase = nlm_get_sys_pcibase(0);
+	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
+	uint64_t pciebase = nlm_get_pcie_base(0,0);
+	uint64_t picbase, picreg;
+	uint32_t irq, pciintenable;
+
+	if(((sysreg >> 8) & 0xf) & 0x1)
+	{
+		pr_err("PCIE in RC Mode \n");
+		return 0;
+	}
+
+	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
+	pciintenable |= 0x1;
+	nlm_write_pci_reg(pciebase,PCIE_INT_EN1, pciintenable);
+
+	pr_err("PCIE in Mode \n");
+	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
+	picbase = nlm_get_pic_pcibase(0);
+	/* enable the link interrupt */
+	picreg = nlm_read_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX));
+	nlm_write_pic_reg(picbase, PIC_IRT(PIC_IRT_PCIE_LINK_0_INDEX), picreg | (1u << 31));
+
+	irq = PIC_PCIE_LINK_LEGACY_IRQ_BASE;
+	if(request_irq(irq, xlp_pcie_hot_reset_handler,0,"PCIE_HOTRESET",NULL))
+		{
+			pr_info("Could not register PCIe hot Reset interrupt handler \n");
+			return 0;
+		}
+	pr_err("PCIE in Mode 2\n");
+	return 0;
+}
+late_initcall(xlp_pci_hot_reset_init);
+#endif
 static int __init pcibios_init(void)
 {
 	struct nlm_soc_info *nodep;
@@ -365,7 +493,11 @@ static int __init pcibios_init(void)
 				continue;
 			xlp_config_pci_bswap(n, link);
 			xlp_init_node_msi_irqs(n, link);
-
+#ifdef PCIE_HOT_RESET_ENABLE			
+			//pr_err("PCIE in Hot Reset \n");
+			//xlp_pci_hot_reset_init();
+			//pr_err("PCIE in Hot Reset Done\n");
+#endif
 			/* put in intpin and irq - u-boot does not */
 			reg = nlm_read_pci_reg(pciebase, 0xf);
 			reg &= ~0x1ffu;
-- 
1.7.9.5

