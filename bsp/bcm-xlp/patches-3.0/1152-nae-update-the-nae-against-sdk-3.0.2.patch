From fb5f650e813f23e94b95b64ce0136ddf2354b09d Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 19 Jun 2014 11:15:13 +0800
Subject: [PATCH 152/160] nae: update the nae against sdk 3.0.2

rebase the nae to sdk 3.0.2

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 drivers/netlogic/nae/Makefile        |    1 +
 drivers/netlogic/nae/xlpge.h         |   43 ++++++---
 drivers/netlogic/nae/xlpge_board.c   |    5 -
 drivers/netlogic/nae/xlpge_ethtool.c |    2 +-
 drivers/netlogic/nae/xlpge_lro.h     |    4 +-
 drivers/netlogic/nae/xlpge_nae.c     |  175 +++++++++++++++++++++-------------
 drivers/netlogic/nae/xlpge_proc.c    |    4 +-
 drivers/netlogic/nae/xlpge_rx.c      |   75 +++++++--------
 drivers/netlogic/nae/xlpge_tso.h     |   18 ++--
 drivers/netlogic/nae/xlpge_tx.c      |   12 +--
 10 files changed, 195 insertions(+), 144 deletions(-)

diff --git a/drivers/netlogic/nae/Makefile b/drivers/netlogic/nae/Makefile
index 9393f36..d693c56 100644
--- a/drivers/netlogic/nae/Makefile
+++ b/drivers/netlogic/nae/Makefile
@@ -4,6 +4,7 @@
 #
 
 EXTRA_CFLAGS := -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL
+EXTRA_CFLAGS += -DCONFIG_NLM_ENABLE_LOAD_BALANCING -Wno-format -Wno-unused-function
 EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/syslib/include
 EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/fmnlib
 EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/netlib/include
diff --git a/drivers/netlogic/nae/xlpge.h b/drivers/netlogic/nae/xlpge.h
index 0cb32a8..9e36c86 100644
--- a/drivers/netlogic/nae/xlpge.h
+++ b/drivers/netlogic/nae/xlpge.h
@@ -232,6 +232,25 @@ struct phy_info {
         uint32_t *serdes_addr;
 };
 
+extern int nae_debug_level;
+
+enum nae_dbglevels{
+	NAE_DBG_DEFAULT = 0x1,
+	NAE_DBG_ERROR = 0x1,
+	NAE_DBG_FDT = 0x2,
+	NAE_DBG_CONFIG = 0x4,
+	NAE_DBG_PORT = 0x8,
+	NAE_DBG_GLOBAL = NAE_DBG_PORT | NAE_DBG_CONFIG,
+	NAE_DBG_TRACE = 0x10,
+};
+
+#define nae_print(dbglvl, fmt, args...) \
+{ \
+	if (dbglvl & nae_debug_level) { \
+		printk(fmt, ##args); \
+	} \
+}
+
 #ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
 /*Flow Meta Info*/
 struct flow_meta_info
@@ -291,7 +310,6 @@ struct dev_data
 	/*1588 ptp timer*/
 	struct cyclecounter cycles;
 	struct timecounter clock;
-	//struct timecompare compare;
 };
 
 
@@ -385,18 +403,18 @@ static __inline__ void print_fmn_send_error(const char *str,
 {
 	if(send_result & MSG_DST_FC_FAIL)
 	{
-		printk("[%s] Msg Destination flow control credit fail "
+		nae_print(NAE_DBG_ERROR, "[%s] Msg Destination flow control credit fail "
 			"(send_result=%08x)\n",
 			str, send_result);
 	}
-	else if (send_result & MSG_INFLIGHT_MSG_EX)
-		printk("[%s] MSG_INFLIGHT_MSG_EX(send_result=%08x)\n",
+	else if (send_result & MSG_INFLIGHT_MSG_EX) {
+		nae_print(NAE_DBG_ERROR, "[%s] MSG_INFLIGHT_MSG_EX(send_result=%08x)\n",
 			__func__, send_result);
-	else if (send_result & MSG_TXQ_FULL)
-		printk("[%s] TX message Q full(send_result=%08x)\n",
+	}else if (send_result & MSG_TXQ_FULL) {
+		nae_print(NAE_DBG_ERROR, "[%s] TX message Q full(send_result=%08x)\n",
 			__func__, send_result);
-	else
-		printk("[%s] Unknown send error type(send_result=%08x)\n",
+	}else
+		nae_print(NAE_DBG_ERROR, "[%s] Unknown send error type(send_result=%08x)\n",
 			__func__, send_result);
 }
 
@@ -406,14 +424,14 @@ static __inline__ void dump_buffer(unsigned char *buf, uint32_t len,
 	int k, olen = 0;
 	char out[512];
 
-	printk("\n%s\n", msg);
+	nae_print(NAE_DBG_TRACE, "\n%s\n", msg);
 
 	for (k = 0; k < len; k++) {
 		olen += snprintf(&out[olen], 512 - olen, "<%.2x> ", buf[k]);
 		if ((k + 1) % 16 == 0)
 			olen += snprintf(&out[olen], 512 - olen, "\n");
 	}
-	printk("%s\n", out);
+	nae_print(NAE_DBG_TRACE, "%s\n", out);
 }
 
 static inline int mac_refill_frin_skb(nae_t* nae_cfg, int cpu, uint64_t paddr,
@@ -436,7 +454,7 @@ static inline int mac_refill_frin_skb(nae_t* nae_cfg, int cpu, uint64_t paddr,
 	node_cpu = phys_cpu_to_log_map[node][nae_id][cpu];
 
 	if (nae_cfg == NULL) {
-		printk("%s Error, Invalid node id %d\n", __FUNCTION__, node);
+		nae_print(NAE_DBG_ERROR, "%s Error, Invalid node id %d\n", __FUNCTION__, node);
 		return -1;
 	}
 
@@ -485,7 +503,7 @@ static inline int mac_refill_frin_one_buffer(struct net_device *dev, int cpu,
 
 	skb = nlm_xlp_alloc_skb_atomic(buf_size, priv->node);
 	if (!skb) {
-		printk("[%s] alloc skb failed\n",__FUNCTION__);
+		nae_print(NAE_DBG_ERROR, "[%s] alloc skb failed\n",__FUNCTION__);
 		panic("panic...");
 		return -ENOMEM;
 	}
@@ -497,7 +515,6 @@ static inline int mac_refill_frin_one_buffer(struct net_device *dev, int cpu,
 	return mac_refill_frin_skb(nae_cfg, cpu, (uint64_t)virt_to_bus(skb->data), buf_size, priv->hw_port_id);
 }
 
-
 void nlm_xlp_nae_init(void);
 void nlm_xlp_nae_remove(void);
 extern int xlpge_eeprom_init(void);
diff --git a/drivers/netlogic/nae/xlpge_board.c b/drivers/netlogic/nae/xlpge_board.c
index 9fdd795..bf5c3ee 100644
--- a/drivers/netlogic/nae/xlpge_board.c
+++ b/drivers/netlogic/nae/xlpge_board.c
@@ -77,11 +77,6 @@ void gen_mac_address(void)
         if( ((mac0_set | mac1_set) && if_mac_set) == 0){
                 random_ether_addr(mac_base);
         }
-
-	/* SMSC911X occupies the first MAC address on XLP2XX/3XX */
-	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
-		mac_base[5] += 1;
-
 	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
                 for(j=0;j<18;j++){
                         memcpy(eth_hw_addr[i][j], mac_base, 6);
diff --git a/drivers/netlogic/nae/xlpge_ethtool.c b/drivers/netlogic/nae/xlpge_ethtool.c
index 418c36b..3ed091b 100644
--- a/drivers/netlogic/nae/xlpge_ethtool.c
+++ b/drivers/netlogic/nae/xlpge_ethtool.c
@@ -315,7 +315,7 @@ static void xlp_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
 			sizeof(xlp_ethtool_stats_keys));
 		break;
 	default:
-		printk(KERN_WARNING "%s: Invalid stringset %d\n",
+		nae_print(NAE_DBG_ERROR, "%s: Invalid stringset %d\n",
 			__func__, stringset);
 		break;
 	}
diff --git a/drivers/netlogic/nae/xlpge_lro.h b/drivers/netlogic/nae/xlpge_lro.h
index 153cfc1..04725cf 100644
--- a/drivers/netlogic/nae/xlpge_lro.h
+++ b/drivers/netlogic/nae/xlpge_lro.h
@@ -71,7 +71,7 @@ static int lro_get_skb_hdr(struct sk_buff *skb, void **iphdr, void **tcph,
 	return 0;
 }
 
-static void __maybe_unused lro_init(struct net_device *dev)
+static void lro_init(struct net_device *dev)
 {
 	struct dev_data* priv;
 	struct net_lro_mgr *lp;
@@ -80,7 +80,7 @@ static void __maybe_unused lro_init(struct net_device *dev)
 	priv = netdev_priv(dev);
 
 	if (enable_lro) {
-		printk("LRO is enabled \n");
+		nae_print(NAE_DBG_CONFIG, "LRO is enabled \n");
 		dev->features |= NETIF_F_LRO;
 	//	dev->features |= NETIF_F_GRO;
 	//	return;
diff --git a/drivers/netlogic/nae/xlpge_nae.c b/drivers/netlogic/nae/xlpge_nae.c
index 6c57fa4..e9a5bb8 100644
--- a/drivers/netlogic/nae/xlpge_nae.c
+++ b/drivers/netlogic/nae/xlpge_nae.c
@@ -35,6 +35,7 @@
 #include <linux/clocksource.h>
 #include <linux/proc_fs.h>
 #include <linux/timer.h>
+#include <linux/kthread.h>
 //#include <nlm_xlp.h>
 //#include <nlm_msgring.h>
 //#include <nlm_hal_fmn.h>
@@ -98,9 +99,9 @@ module_param(enable_jumbo, int, 0);
 struct p2p_desc_mem p2p_desc_mem[NR_CPUS] __cacheline_aligned;
 static unsigned int phys_cpu_map[NLM_MAX_NODES];
 struct timer_list phy_int_timer;
+struct task_struct *kthread_an;
 #ifdef CONFIG_NLM_ENABLE_LOAD_BALANCING
-struct file_operations nlm_load_balance_proc_fops = {
-	.owner = THIS_MODULE,
+static const struct file_operations nlm_load_balance_proc_fops = {
 	.open = nlm_load_balance_proc_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
@@ -115,6 +116,12 @@ uint32_t last_rcvd_node[NR_CPUS * 8] ____cacheline_aligned;
 uint64_t last_rcvd_skb_phys[NR_CPUS * 8] ____cacheline_aligned;
 #endif
 
+int nae_debug_level = 1;
+module_param(nae_debug_level, int, 0);
+MODULE_PARM_DESC(nae_debug_level,
+	"Vaild debug levels 1-5 (default="
+		__MODULE_STRING(nae_debug_level)")");
+
 static unsigned short nlm_select_queue(struct net_device *dev,
 				       struct sk_buff *skb)
 {
@@ -138,7 +145,7 @@ static int init_dummy_entries_for_port_fifos(nae_t* nae_cfg)
 
 	skb = nlm_xlp_alloc_skb_atomic(size, node);
 	if (!skb) {
-		printk("[%s] alloc skb failed\n", __func__);
+		nae_print(NAE_DBG_ERROR, "[%s] alloc skb failed\n", __func__);
 		panic("panic...");
 		return -ENOMEM;
 	}
@@ -153,7 +160,7 @@ static int init_dummy_entries_for_port_fifos(nae_t* nae_cfg)
 	return 0;
 
 //	msgrng_access_enable(mflags);
-	printk("Total free ins = 0x%x\n", nae_cfg->frin_total_queue);
+	nae_print(NAE_DBG_CONFIG, "Total free ins = 0x%x\n", nae_cfg->frin_total_queue);
 	for (i = 0; i < nae_cfg->frin_total_queue; i++) {
 		/* nothing to do, if it is owned by some domain */
 		if((1 << i) & fifo_mask)
@@ -168,20 +175,20 @@ static int init_dummy_entries_for_port_fifos(nae_t* nae_cfg)
 		for (j = 0; j < 4; j++) {
 			//netsoc_nae_send_freein_buf(nae_cfg, vc_index, msg);
 //#if 0
-				printk("Sending message check freein carving (qid=%d)\n",
+				nae_print(NAE_DBG_TRACE, "Sending message check freein carving (qid=%d)\n",
 					vc_index);
 			if ((ret = xlp_message_send_1(vc_index, code, msg))
 				& 0x7) {
 				print_fmn_send_error(__func__, ret);
-				printk("Unable to send configured free desc\n");
-				printk("check freein carving (qid=%d)\n",
+				nae_print(NAE_DBG_ERROR, "Unable to send configured free desc\n");
+				nae_print(NAE_DBG_TRACE, "check freein carving (qid=%d)\n",
 					vc_index);
 				rv = -1;
 				goto err;
 			}
 //#endif
 		}
-		printk("Send %d dummy descriptors for queue %d(vc %d) of length %d\n",
+		nae_print(NAE_DBG_TRACE, "Send %d dummy descriptors for queue %d(vc %d) of length %d\n",
 			j, i, vc_index, size);
 	}
 err:
@@ -264,7 +271,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 	int len = 0, i = 0;
 	char *paddr_info, *desc_info;
 
-	printk("%s in \n", __FUNCTION__);
+	nae_print(NAE_DBG_TRACE, "%s in \n", __FUNCTION__);
 
 	for(shdom = 0; shdom <= NLM_NAE_MAX_SHARED_DOMS; shdom++) {
 		if(!nae_cfg->shinfo[shdom].valid)
@@ -279,7 +286,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 		desc_info = nae_cfg->shinfo[shdom].desc_info;
 		desc_info_len = nae_cfg->shinfo[shdom].desc_info_len;
 
-		printk("shind %d dom %d repl %d paddr_ptr %lx len %d desc_ptr %lx dlen %d\n",
+		nae_print(NAE_DBG_TRACE, "shind %d dom %d repl %d paddr_ptr %lx len %d desc_ptr %lx dlen %d\n",
 				shdom, nae_cfg->shinfo[shdom].domid, owner_replenish,
 				(long)paddr_info, paddr_info_len, (long)desc_info, desc_info_len);
 
@@ -302,7 +309,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 				break;
 		} while(len < paddr_info_len);
 
-		printk("domid %d node %d addr %llx size %llx\n",
+		nae_print(NAE_DBG_TRACE, "domid %d node %d addr %llx size %llx\n",
 					nae_cfg->shinfo[shdom].domid, cnode,
 					paddr, psize);
 
@@ -324,7 +331,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 			if(cnode != node)
 				continue;
 
-			printk("node %d fmask %x dsize %d dppadsz %d ndescs %d \n",
+			nae_print(NAE_DBG_TRACE, "node %d fmask %x dsize %d dppadsz %d ndescs %d \n",
 					cnode, fmask, dsize, dppadsz, ndescs);
 
 			for(fifo = 0; fifo < NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE;
@@ -336,7 +343,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 				for(descs = 0; descs < ndescs; descs++) {
 					if((paddr + dsize) > epaddr) {
 						msgrng_access_disable(mflags);
-						printk("Error, descriptors \
+						nae_print(NAE_DBG_ERROR, "Error, descriptors \
 							buffer overflow \n");
 						err = -1;
 						goto err_exit;
@@ -347,7 +354,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 					rv = xlp_message_send_1(vc_index, code, msg);
 					if(rv & 0x7) {
 						msgrng_access_disable(mflags);
-						printk("Unable to send \
+						nae_print(NAE_DBG_ERROR, "Unable to send \
 							configured free desc, \
 							check freein carving \
 							(qid=%d)\n", vc_index);
@@ -359,7 +366,7 @@ static int nlm_configure_shared_freein_fifo(int node,
 
 				}
 				msgrng_access_disable(mflags);
-				printk("Send %d descriptors for queue \
+				nae_print(NAE_DBG_TRACE, "Send %d descriptors for queue \
 						%d(%d) of length %d\n",
 						ndescs, fifo, vc_index, dsize);
 
@@ -396,7 +403,7 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 
 
 	for (i = 0; i <= NLM_NAE_MAX_SHARED_DOMS; i++) {
-		printk("naeid %d shind %d dom %d valid %x numcpus %d\n", nae_id,
+		nae_print(NAE_DBG_CONFIG, "naeid %d shind %d dom %d valid %x numcpus %d\n", nae_id,
 				i, nae_cfg->shinfo[i].domid, nae_cfg->shinfo[i].valid, nae_cfg->shinfo[i].num_cpus);
 		lnx_shinfo[i] = (struct nlm_nae_linux_shinfo *)mem;
 		lnx_shinfo[i]->flags  = nae_cfg->shinfo[i].valid ? NLM_NAE_LNX_SHINFO_FL_VALID : 0;
@@ -408,7 +415,7 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 		for(cpus = 0; cpus < lnx_shinfo[i]->num_cpus; cpus++)  {
 			int phys_cpu;
 			lnx_shinfo[i]->fwd_info[cpus] = nae_cfg->shinfo[i].fwd_info[cpus];
-			printk("cpu %d value %08x\n", cpus, nae_cfg->shinfo[i].fwd_info[cpus]);
+			nae_print(NAE_DBG_TRACE, "cpu %d value %08x\n", cpus, nae_cfg->shinfo[i].fwd_info[cpus]);
 			phys_cpu = (lnx_shinfo[i]->fwd_info[cpus] >> NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF) &
 				NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_MASK;
 			phys_cpu_to_log_map[node][nae_id][phys_cpu] = cpus;
@@ -469,8 +476,8 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 					(cpu_2_jumbo_frfifo[node][nae_id][cpus] << NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_JF_OFF);
 			}
 		} else {
-			printk("freein-fifo unavailable: ");
-			printk("Disabling Jumbo\n");
+			nae_print(NAE_DBG_DEFAULT, "freein-fifo unavailable: ");
+			nae_print(NAE_DBG_DEFAULT, "Disabling Jumbo\n");
 			*jumbo_enabled = 0;
 		}
 	} else if (*jumbo_enabled == 0) {
@@ -495,9 +502,9 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 	if (nae_cfg->owned) {
 		if(netsoc_write_ucore_shmem(nae_cfg,
 			(uint32_t *)lnx_shinfo[0],  size/sizeof(uint32_t)) != 0) {
-			printk("Error, Write ucore sram failed!!!, size %d\n", size);
+			nae_print(NAE_DBG_ERROR, "Error, Write ucore sram failed!!!, size %d\n", size);
 		} else
-			printk("Write ucore sram success, size %d\n", size);
+			nae_print(NAE_DBG_TRACE, "Write ucore sram success, size %d\n", size);
 
 		netsoc_restart_ucore_using_fdt(nae_cfg, fdt);
 	}
@@ -538,10 +545,10 @@ static int initialize_nae_per_node(nae_t * nae_cfg, uint32_t *phys_cpu_map, int
 
 #if 1
 	for (i = 0; i <= NLM_NAE_MAX_SHARED_DOMS; i++) {
-		printk("naeid %d domid %d node %d flag %x\n", nae_id,
+		nae_print(NAE_DBG_CONFIG, "naeid %d domid %d node %d flag %x\n", nae_id,
 				lnx_shinfo[i]->domid, lnx_shinfo[i]->node, lnx_shinfo[i]->flags);
 		for(cpus = 0; cpus < lnx_shinfo[i]->num_cpus; cpus++) {
-			printk("lcpu %d value %08x (pcpu %d rxfifo %d jfifo %d)\n",
+			nae_print(NAE_DBG_TRACE, "lcpu %d value %08x (pcpu %d rxfifo %d jfifo %d)\n",
 					cpus, lnx_shinfo[i]->fwd_info[cpus],
 					(lnx_shinfo[i]->fwd_info[cpus] >> NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_PCPU_OFF) & 0xff ,
 					(lnx_shinfo[i]->fwd_info[cpus] >> NLM_NAE_LNX_SHINFO_FWD_INFO_LCPU_2_RF_OFF) & 0xff,
@@ -576,7 +583,7 @@ err:
 	return rv;
 }
 
-static void *allocate_contig_phys(uint32_t align, uint32_t size)
+static void * allocate_contig_phys(uint32_t align, uint32_t size)
 {
 	void *buf = kmalloc(size + align, GFP_KERNEL);
         if (buf == NULL)
@@ -600,6 +607,8 @@ int initialize_nae(uint32_t *phys_cpu_map, int mode, int *jumbo_enabled)
 	nae_t* nae;
 	struct netsoc_lib_param mod_api;
 
+	memset(&mod_api, 0, sizeof (struct netsoc_lib_param));
+
 	msgrng_access_enable(mflags);
 	mod_api.contig_alloc = allocate_contig_phys;
 	mod_api.malloc = NULL;
@@ -609,14 +618,15 @@ int initialize_nae(uint32_t *phys_cpu_map, int mode, int *jumbo_enabled)
 	mod_api.writel = NULL;
 	mod_api.free = NULL;
 	mod_api.contig_free = NULL;
+	mod_api.netsoc_debug_level = nae_debug_level;
 
 	brcm_netsoc_lib_init(&mod_api);
 
-	if (init_netsoc(fdt, dom_id) < 0) {
-                printk("NETSOC initialization failed \n");
+	if (init_netsoc(fdt, dom_id, &mod_api) < 0) {
+                nae_print(NAE_DBG_ERROR, "NETSOC initialization failed \n");
 		return -1;
 	}
-	printk("DONE WITH INIT NETSOC #######\n");
+	nae_print(NAE_DBG_DEFAULT, "DONE WITH INIT NETSOC #######\n");
 
 	/*get max nae*/
 	max_nae_units = get_num_nae_pernode();
@@ -629,7 +639,7 @@ int initialize_nae(uint32_t *phys_cpu_map, int mode, int *jumbo_enabled)
 	}
 
 	msgrng_access_disable(mflags);
-	printk("%s done\n", __FUNCTION__);
+	nae_print(NAE_DBG_DEFAULT, "%s done\n", __FUNCTION__);
 	return 0;
 }
 
@@ -660,7 +670,7 @@ static int nlm_replenish_per_cpu_buffer(nae_t* nae_cfg,
 		vc_index = qindex + nae_cfg->frin_queue_base;
 		skb = nlm_xlp_alloc_skb_atomic(size, node);
 		if (!skb) {
-			printk("[%s] alloc skb failed\n",__FUNCTION__);
+			nae_print(NAE_DBG_ERROR, "[%s] alloc skb failed\n",__FUNCTION__);
 			break;
 		}
 
@@ -678,8 +688,8 @@ static int nlm_replenish_per_cpu_buffer(nae_t* nae_cfg,
 
 		if ((ret = xlp_message_send_1(vc_index, code, msg)) & 0x7) {
 			print_fmn_send_error(__func__, ret);
-			printk("Unable to send configured free desc, ");
-			printk("check freein carving (qid=%d)\n", vc_index);
+			nae_print(NAE_DBG_ERROR, "Unable to send configured free desc, ");
+			nae_print(NAE_DBG_ERROR, "check freein carving (qid=%d)\n", vc_index);
 
 			/* free the buffer and return! */
 			dev_kfree_skb_any(skb);
@@ -691,7 +701,7 @@ static int nlm_replenish_per_cpu_buffer(nae_t* nae_cfg,
 		msgrng_access_disable(mflags);
 	}
 
-	printk("Send %d descriptors for queue %d(vc %d) of length %d\n",
+	nae_print(NAE_DBG_TRACE, "Send %d descriptors for queue %d(vc %d) of length %d\n",
 		bufcnt, qindex, vc_index, size);
 
 	return ret;
@@ -789,26 +799,57 @@ void nlm_xlp_nae_remove(void)
 	nlm_nae_remove_procentries();
 }
 
-#if 0
+static int __maybe_unused nlm_xlp_port_poll(void *buff)
+{
+	uint32_t i, maxnae, node, speed, duplex, port_index;
+	nae_t *nae_cfg;
+	static int arr[NLM_MAX_NODES][18];
+	maxnae = get_num_nae_pernode();
+	while(1) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		for (node = 0;node < NLM_MAX_NODES; node++) {
+			int num_nae, tmp;
+			for(num_nae=0; num_nae<maxnae; num_nae++) {
+				nae_cfg = get_nae(node, num_nae);
+				if (nae_cfg == NULL)
+					continue;
+				for(i=0; i < nae_cfg->num_ports; i++) {
+					port_index = i + (nae_cfg->nae_id * nae_cfg->num_ports);
+					tmp=arr[node][port_index];
+					arr[node][port_index]=netsoc_get_phy_status(&nae_cfg->ports[i],&speed,&duplex);
+					if ((arr[node][port_index]>-1)&&(arr[node][port_index]<tmp))
+						netsoc_start_autoneg(&nae_cfg->ports[i]);
+					else
+						continue;
+				}
+			}
+		}
+		schedule();
+	}
+	return 0;
+}
+
 static void phy_st_timer_handler(unsigned long data)
 {
         struct timer_list *timer = &phy_int_timer;
-        nlm_hal_restart_an(0, 0);
-
+	wake_up_process(kthread_an);
         timer->expires = jiffies + (HZ * 2);
         add_timer(timer);
 }
 void init_phy_state_timer(void *data)
 {
-
         struct timer_list *timer = &phy_int_timer;
+	kthread_an = kthread_create(nlm_xlp_port_poll, NULL, "nae_port_poll");
+	if (IS_ERR(kthread_an)) {
+		nae_print(NAE_DBG_ERROR, "Can't create nae port probe thread !!!\n");
+		nae_print(NAE_DBG_ERROR, "Skipping phy state timer initialization !!!\n");
+	}
         init_timer(timer);
         timer->expires = jiffies + 10;
         timer->data = 0;
         timer->function = phy_st_timer_handler;
         add_timer(timer);
 }
-#endif
 
 #if 0
 void nlm_xlp_mac_set_enable(struct dev_data *priv, int flag)
@@ -881,7 +922,7 @@ static int p2p_desc_mem_init(void)
 			CACHELINE_SIZE - 1) & (~((CACHELINE_SIZE)-1)));
 	tsize = dsize * MAX_TSO_SKB_PEND_REQS;
 
-	printk("%s in, dsize %d tsize %d \n", __FUNCTION__, dsize, tsize);
+	nae_print(NAE_DBG_CONFIG, "%s in, dsize %d tsize %d \n", __FUNCTION__, dsize, tsize);
 
 	for (cpu = 0; cpu < NR_CPUS; cpu++) {
 		buf = cacheline_aligned_kmalloc(tsize, GFP_KERNEL);
@@ -905,7 +946,7 @@ static void nlm_enable_l3_l4_parser(nae_t *nae)
 	l3_parser_config_t l3;
 	l4_parser_config_t l4;
 
-	printk("Enabling parser for nae node %d naeid %d\n",
+	nae_print(NAE_DBG_TRACE, "Enabling parser for nae node %d naeid %d\n",
 			nae->node, nae->nae_id);
 
 	memset(&l2, 0, sizeof(l2));
@@ -1016,7 +1057,7 @@ static int  nlm_xlp_nae_open (struct net_device *dev)
 		if (request_irq( irq, nlm_xlp_nae_int_handler,
 			IRQF_SHARED, dev->name, dev)) {
 			ret = -EBUSY;
-			printk("can't get mac interrupt line (%d)\n",dev->irq);
+			nae_print(NAE_DBG_ERROR, "can't get mac interrupt line (%d)\n",dev->irq);
 		}
 		dump_irt_entry(PIC_IRT_NA_INDEX(port));
 	}
@@ -1166,10 +1207,10 @@ static void xlp_mac_setup_hwaddr(struct dev_data *priv)
 static int  nlm_xlp_nae_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int rc = 0;
-	printk("nlm_xlp_nae_ioctl called \n");
+	nae_print(NAE_DBG_TRACE, "nlm_xlp_nae_ioctl called \n");
 	switch (cmd) {
 	case SIOCSHWTSTAMP:
-		printk("HW time stamping supported by HW\n");
+		nae_print(NAE_DBG_CONFIG, "HW time stamping supported by HW\n");
 		return 0;
 	default:
 		rc = -EOPNOTSUPP;
@@ -1194,14 +1235,14 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 
 	if (enable_jumbo &&
 		(new_mtu > ETH_JUMBO_DATA_LEN || new_mtu < ETH_ZLEN)) {
-		printk ("MTU should be between %d and %d\n",
+		nae_print(NAE_DBG_TRACE, "MTU should be between %d and %d\n",
 			ETH_ZLEN, ETH_JUMBO_DATA_LEN);
 		return -EINVAL;
 	}
 
 	if (!enable_jumbo &&
 		(new_mtu > ETH_DATA_LEN || new_mtu < ETH_ZLEN)) {
-		printk ("MTU should be between %d and %d\n",
+		nae_print(NAE_DBG_TRACE, "MTU should be between %d and %d\n",
 			ETH_ZLEN, ETH_DATA_LEN);
 		return -EINVAL;
 	}
@@ -1218,13 +1259,9 @@ static int nlm_xlp_nae_change_mtu(struct net_device *dev, int new_mtu)
 			//nlm_xlp_mac_set_enable(priv, 0); /* Disable MAC TX/RX */
 	}
 
-	if (priv->type==SGMII_IF || priv->type==XAUI_IF || priv->type== XLAUI_IF || priv->type== XFI_IF)
+	if (priv->type==SGMII_IF || priv->type==XAUI_IF || priv->type== XLAUI_IF || priv->type== XFI_IF
+										|| priv->type==RXAUI_IF || priv->type==INTERLAKEN_IF)
 		netsoc_set_framesize(nae_port, local_mtu);
-	else if (priv->type==INTERLAKEN_IF){
-		/*TODO: Add IL frame set in brcm_netsoc */
-		//nlm_hal_set_ilk_framesize(priv->node, priv->block,
-		//	priv->phy.addr, local_mtu);
-	}
 	else {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		return -1;
@@ -1281,7 +1318,7 @@ static void  nlm_xlp_nae_tx_timeout (struct net_device *dev)
 
 	netif_tx_wake_all_queues(dev);
 
-	printk(KERN_WARNING "%s: Transmit timed out\n", dev->name);
+	nae_print(NAE_DBG_ERROR, "%s: Transmit timed out\n", dev->name);
 	return;
 }
 #if 0
@@ -1332,7 +1369,7 @@ static irqreturn_t nlm_xlp_nae_int_handler(int irq, void *dev_id)
 	priv->cpu_stats[cpu].interrupts++;
 
 	if(!dev_id) {
-		printk("[%s]: NULL dev_id \n", __FUNCTION__ );
+		nae_print(NAE_DBG_ERROR, "[%s]: NULL dev_id \n", __FUNCTION__ );
 		return IRQ_HANDLED;
 	}
 	dev = (struct net_device*)dev_id;
@@ -1419,11 +1456,11 @@ static int nlm_per_port_nae_init(nae_t* nae_cfg, int port, int maxnae)
 		priv->phy.addr = nae_cfg->ports[port].ext_phy_addr;
 		if (nae_cfg->ports[port].hw_port_id == 0) {
 			if (dev_alloc_name(dev, "ilk0-%d") < 0)
-				printk("alloc name failed \n");
+				nae_print(NAE_DBG_ERROR, "alloc name failed \n");
 		}
 		else {
 			if (dev_alloc_name(dev, "ilk8-%d") < 0)
-				printk("alloc name failed \n");
+				nae_print(NAE_DBG_ERROR, "alloc name failed \n");
 		}
 		break;
 	default:
@@ -1492,15 +1529,18 @@ void nlm_xlp_nae_init(void)
 	unsigned char *mode_str[3] = {"INVALID","TCP_PERF","ROUTE_PERF"};
 	nae_t* nae_cfg;
 
+	nae_debug_level = (1 << nae_debug_level) - 1;
+
 	if (!(perf_mode == NLM_TCP_MODE || perf_mode == NLM_RT_MODE)) {
-		printk("Invalid perf mode passed -- Using TCP_PERF mode\n");
+		nae_print(NAE_DBG_DEFAULT, "Invalid perf mode passed -- Using TCP_PERF mode\n");
 		perf_mode = NLM_TCP_MODE;
 	}
 
-	printk("======= Module Parameters =========\n");
-	printk("num_descs_per_normalq=%d num_descs_per_jumboq=%d ",
+	nae_print(NAE_DBG_DEFAULT, "======= Module Parameters =========\n");
+	nae_print(NAE_DBG_DEFAULT, "nae debug mask 0x%x\n", nae_debug_level); 
+	nae_print(NAE_DBG_DEFAULT, "num_descs_per_normalq=%d num_descs_per_jumboq=%d ",
 	       num_descs_per_normalq, num_descs_per_jumboq);
-	printk("perf_mode=%s enable_lro=%d enable_jumbo=%d \n",
+	nae_print(NAE_DBG_DEFAULT, "perf_mode=%s enable_lro=%d enable_jumbo=%d \n",
 	       mode_str[perf_mode], enable_lro, enable_jumbo);
 
 	for (i = 0; i < NR_CPUS; i++)
@@ -1564,23 +1604,22 @@ void nlm_xlp_nae_init(void)
 	if ((perf_mode == NLM_TCP_MODE) && load_balance_en) {
 		nlm_prepad_len = PREPAD_LEN;
 
-		entry = create_proc_entry(
-				"load_info",
-				0,		/* def mode */
-				nlm_root_proc	/* parent   */
-				);
-		if (entry)
-			entry->proc_fops = &nlm_load_balance_proc_fops;
-		printk("Enabling load balance option\n");
+		entry = proc_create_data("load_info",
+					0,		/* def mode */
+					nlm_root_proc,	/* parent   */
+					&nlm_load_balance_proc_fops,
+					0
+					);
+		nae_print(NAE_DBG_DEFAULT, "Enabling load balance option\n");
 		nlm_init_load_balance();
 	} else {
-		printk("Disabling load balance option\n");
+		nae_print(NAE_DBG_DEFAULT, "Disabling load balance option\n");
 		load_balance_en = 0;
 	}
 #endif
 
 	if (replenish_freein_fifos() != 0)
-		printk("Replenishmemt of freein fifos failed\n");
+		nae_print(NAE_DBG_ERROR, "Replenishmemt of freein fifos failed\n");
 
 	if (enable_napi)
 		nlm_xlp_enable_napi();
diff --git a/drivers/netlogic/nae/xlpge_proc.c b/drivers/netlogic/nae/xlpge_proc.c
index 9eb7b5e..9dbbc31 100644
--- a/drivers/netlogic/nae/xlpge_proc.c
+++ b/drivers/netlogic/nae/xlpge_proc.c
@@ -55,7 +55,7 @@ int nae_proc_read(char *page, char **start, off_t off,
 				(err_replenish_count[CPU_INDEX(i)] == 0))
 			continue;
 
-		printk("cpu%d, recv %ld fast_repl %ld, slow_repl %ld "
+		nae_print(NAE_DBG_TRACE, "cpu%d, recv %ld fast_repl %ld, slow_repl %ld "
 			"err_repl %ld p2pdalloc %lld\n", i,
 			(ulong)receive_count[CPU_INDEX(i)],
 			(ulong)fast_replenish_count[CPU_INDEX(i)],
@@ -75,7 +75,7 @@ int nae_proc_read(char *page, char **start, off_t off,
 		receive_count[CPU_INDEX(i)] = 0;
 	}
 	/*check how many hash are empty...*/
-	printk("TOTAL_FAST_REPL %ld, TOTAL_SLOW_REPL %ld,"
+	nae_print(NAE_DBG_CONFIG, "TOTAL_FAST_REPL %ld, TOTAL_SLOW_REPL %ld,"
 	       " TOTAL_ERR_REPL %ld TOTAL_RECV %ld\n",
 			(ulong)total_fast,
 			(ulong)total_slow,
diff --git a/drivers/netlogic/nae/xlpge_rx.c b/drivers/netlogic/nae/xlpge_rx.c
index 36f11c8..68ab93a 100644
--- a/drivers/netlogic/nae/xlpge_rx.c
+++ b/drivers/netlogic/nae/xlpge_rx.c
@@ -106,7 +106,7 @@ inline void process_tx_complete(int cpu, uint32_t src_id, uint64_t msg0)
                 dev_kfree_skb_any(skb);
         }
         else {
-                printk("[%s]: [txc] Null skb? "
+                nae_print(NAE_DBG_ERROR, "[%s]: [txc] Null skb? "
                        " paddr = %llx (halting cpu!)\n", __func__, addr);
                 cpu_halt();
         }
@@ -175,7 +175,7 @@ static void nlm_remove_inactive_flow(int cpu)
 		fmi = nlm_flow_meta_info + index;
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
 		if (index > NLM_UCORE_SHARED_TABLE_SIZE)
-			printk("??? Index %d\n",index);
+			nae_print(NAE_DBG_TRACE, "??? Index %d\n",index);
 #endif
 		bytes_received = fmi->total_bytes_rcvd - fmi->last_sample_bytes;
 		fmi->last_sample_bytes = fmi->total_bytes_rcvd;
@@ -183,7 +183,7 @@ static void nlm_remove_inactive_flow(int cpu)
 		if (bytes_received == 0) {
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
 			if (fmi->cpu_owner != cpu) {
-				printk("Error!! fmi->cpu_owner = %lld, cpu %d, "
+				nae_print(NAE_DBG_ERROR, "Error!! fmi->cpu_owner = %lld, cpu %d, "
 					"entry %d, total_active_flows %lld\n",
 					fmi->cpu_owner, cpu, i,
 					afl->nr_active_flows);
@@ -234,7 +234,7 @@ static void setup_search_path(void)
 		num_phy_cpu++;
 	}
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
-	printk("num_phy_cpu %d, nlm_pcpu_mask %#x\n",
+	nae_print(NAE_DBG_TRACE, "num_phy_cpu %d, nlm_pcpu_mask %#x\n",
 		num_phy_cpu, nlm_pcpu_mask[0]);
 #endif
 	for (pcpu = 0; pcpu < NUM_LOAD_BALANCE_CPU; pcpu++) {
@@ -295,7 +295,7 @@ static void setup_search_path(void)
 		}
 	}
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
-	printk("\nSearchPath:\n");
+	nae_print(NAE_DBG_TRACE, "\nSearchPath:\n");
 	for (i = 0; i < NUM_LOAD_BALANCE_CPU; i++) {
 		int len;
 		sprintf(buf, "Cpu%d ==> ", i);
@@ -306,7 +306,7 @@ static void setup_search_path(void)
 			len = strlen(buf);
 		}
 		sprintf(buf + len,"\n");
-		printk(buf);
+		nae_print(NAE_DBG_TRACE, (buf);
 	}
 #endif
 	return;
@@ -438,14 +438,14 @@ void nlm_init_load_balance(void)
 		NUM_LOAD_BALANCE_CPU);
 
 	if (!nlm_active_flow_list) {
-	printk("\nAllocation Failed!!! for size %lu bytes\n",
+	nae_print(NAE_DBG_ERROR, "Allocation Failed!!! for size %lu bytes\n",
 		sizeof(struct active_flow_list) * NUM_LOAD_BALANCE_CPU);
 		return;
 	}
 	memset(nlm_active_flow_list, 0, sizeof(struct active_flow_list) *
 		NUM_LOAD_BALANCE_CPU);
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
-	printk("Allocated active_flow_list @ %#lx, size %lu bytes\n",
+	nae_print(NAE_DBG_CONFIG, "Allocated active_flow_list @ %#lx, size %lu bytes\n",
 		(unsigned long)nlm_active_flow_list,
 		sizeof(struct active_flow_list) * NUM_LOAD_BALANCE_CPU);
 #endif 
@@ -453,14 +453,14 @@ void nlm_init_load_balance(void)
 		(NLM_UCORE_SHARED_TABLE_SIZE + 1));
 
 	if (!nlm_flow_meta_info) {
-		printk("\nAllocation Failed!!! for size %lu bytes\n",
+		nae_print(NAE_DBG_ERROR, "\nAllocation Failed!!! for size %lu bytes\n",
 			sizeof(struct flow_meta_info) * NUM_LOAD_BALANCE_CPU);
 		return;
 	}
 	memset(nlm_flow_meta_info, 0, sizeof(struct flow_meta_info) *
 		(NLM_UCORE_SHARED_TABLE_SIZE + 1));
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
-	printk("Allocated flow_meta_info @ %#lx, size %lu bytes\n",
+	nae_print(NAE_DBG_CONFIG, "Allocated flow_meta_info @ %#lx, size %lu bytes\n",
 		(ulong)nlm_flow_meta_info, sizeof(struct flow_meta_info) *
 		(NLM_UCORE_SHARED_TABLE_SIZE + 1));
 #endif 
@@ -487,7 +487,7 @@ void nlm_init_load_balance(void)
 	ucore_shared_data = vmalloc(NLM_UCORE_SHARED_TABLE_SIZE *
 		sizeof(uint32_t));
 	if (!ucore_shared_data) {
-		printk("Ucore updation failed!!\n");
+		nae_print(NAE_DBG_ERROR, "Ucore updation failed!!\n");
 		return;
 	}
 
@@ -518,7 +518,7 @@ static void dump_packet(unsigned char *vaddr, int len)
 {
 	int i = 0;
 	for (i = 0; i < len; i+=8) {
-		printk("[%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x]\n",
+		nae_print(NAE_DBG_TRACE, "[%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x]\n",
 			*(vaddr + i + 0), *(vaddr + i + 1), *(vaddr + i + 2),
 			*(vaddr + i + 3), *(vaddr + i + 4), *(vaddr + i + 5),
 			*(vaddr + i + 6), *(vaddr + i + 7));
@@ -532,11 +532,11 @@ static void dump_prepad(unsigned char *vaddr)
 
 	if (*tmp == 0xdeadbeef) {
 		for(i = 0; i < 4; i++)
-			printk("[%d] ==> [%#x]\n", i, *(tmp + i));
+			nae_print(NAE_DBG_TRACE, "[%d] ==> [%#x]\n", i, *(tmp + i));
 	} else {
 #if 1
 	for (i = 0; i < 16; i+=8){
-		printk("[%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x]\n",
+		nae_print(NAE_DBG_TRACE, "[%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x] [%#x]\n",
 			*(vaddr + i + 0), *(vaddr + i + 1), *(vaddr + i + 2),
 			*(vaddr + i + 3), *(vaddr + i + 4), *(vaddr + i + 5),
 			*(vaddr + i + 6), *(vaddr + i + 7));
@@ -562,7 +562,7 @@ static inline void nlm_update_flow_stats(unsigned int *prepad,
 	if (*prepad != NLM_LOAD_BALANCING_MAGIC) {
 		/*No extractions have happend...*/
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
-		printk("Invalid Packet!!\n");
+		nae_print(NAE_DBG_ERROR, "Invalid Packet!!\n");
 		dump_packet(prepad, 64 + 16);
 #endif
 		return;
@@ -587,7 +587,7 @@ static inline void nlm_update_flow_stats(unsigned int *prepad,
 		index = afl->nr_active_flows;
 #ifdef LOAD_BALANCE_DEBUG_ENABLE
 		if (index >= NLM_UCORE_SHARED_TABLE_SIZE)
-			printk("Index %lld Crossing Table size...\n", index);
+			nae_print(NAE_DBG_TRACE, "Index %lld Crossing Table size...\n", index);
 #endif
 		afl->index_to_flow_meta_info[index] = hash_index;
 		mb();
@@ -617,7 +617,7 @@ static int inline valid_buffer_lifo(int cpu, uint64_t msg1, uint32_t src_id)
 		if(is_nlm_xlp9xx()){
 				nae = get_nae(node, nae_id);
 				if(!(nae->freein_fifo_dom_mask & (1<<lifo))){
-						printk("Error Packet: Cpu %d, msg1 %#lx, lifo %d, Owner fifo mask %#lx\n", 
+						nae_print(NAE_DBG_ERROR, "Error Packet: Cpu %d, msg1 %#llx, lifo %d, Owner fifo mask %#lx\n", 
 										cpu, msg1, lifo, nae->freein_fifo_dom_mask);
 						msgrng_access_enable(mflags);
 						qid = nae->frin_queue_base + lifo;
@@ -644,7 +644,6 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 	struct sk_buff* skb;
 	nae_t* nae_cfg;
 	uint32_t msec_port;
-	struct napi_struct *napi = (struct napi_struct *)arg;
 
 	if(is_nlm_xlp9xx()){
 		msg1 = msg2;	
@@ -672,7 +671,7 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 
 #ifdef ENABLE_SANITY_CHECKS
 	if (port >= MAX_GMAC_PORT) {
-		printk("[%s]: bad port=%d, context=%d\n", __func__,
+		nae_print(NAE_DBG_ERROR, "[%s]: bad port=%d, context=%d\n", __func__,
 			port, context);
 		/*TODO: Where to replenish this packet ???? Context is out of range!*/
 		return;
@@ -682,13 +681,13 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 
 #ifdef ENABLE_SANITY_CHECKS
 	if(nae_cfg->nae_id!=0 && nae_cfg->nae_id !=1)
-		printk("Nae ID is  wrong\n");
+		nae_print(NAE_DBG_ERROR, "Nae ID is  wrong\n");
 #endif
 	pdev = per_cpu_netdev[node][cpu][nae_cfg->nae_id][port];
 	 
 #ifdef ENABLE_SANITY_CHECKS
 	if (!pdev) {
-		printk("[%s]: [rx] wrong port=%d(context=%d)? pdev = NULL!\n",
+		nae_print(NAE_DBG_ERROR, "[%s]: [rx] wrong port=%d(context=%d)? pdev = NULL!\n",
 			__func__, port, context);
 		return;
 	}
@@ -709,7 +708,7 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 
 #ifdef ENABLE_SANITY_CHECKS
 	if (!skb) {
-		printk("[%s] Null skb? addr=%llx, vaddr=%llx, "
+		nae_print(NAE_DBG_TRACE, "[%s] Null skb? addr=%llx, vaddr=%llx, "
 		       "dropping it and losing one buffer!\n",
 				__func__, addr, vaddr);
 		err_replenish_count[CPU_INDEX(cpu)]++;
@@ -733,11 +732,11 @@ static inline void process_rx_packets(void *arg, int cpu, unsigned int src_id,
 	nae_cfg = priv->nae;
 
 #ifdef MACSEC_DEBUG
-	printk("%s nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+	nae_print(NAE_DBG_CONFIG, "%s nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
 		__func__, nae_cfg->sectag_offset[port],
 		nae_cfg->sectag_len[port], nae_cfg->icv_len[port]);
 	dump_buffer(skb->data, len, "RX skb pkt:");
-	printk("msec_port = %x port = %d len = %d \
+	nae_print(NAE_DBG_CONFIG, "msec_port = %x port = %d len = %d \
 		nae_cfg->msec_rx_port_enable = %x\n",msec_port, port,
 		len, nae_cfg->msec_rx_port_enable);
 #endif
@@ -883,7 +882,7 @@ static int xlp_poll_lower(void *arg, int budget, int cpu)
 		no_rx_pkt_rcvd++;
 #ifdef ENABLE_SANITY_CHECKS
 		if ((size < 1) && (size > 3)) {
-			printk("Unexpected single entry packet\n");
+			nae_print(NAE_DBG_ERROR, "Unexpected single entry packet\n");
 			continue;
 		}
 #endif
@@ -892,7 +891,7 @@ static int xlp_poll_lower(void *arg, int budget, int cpu)
 		else if (size == 1)
 			process_tx_complete(cpu, src_id, msg0);
 		else {
-			printk("%s , Error invalid message, size %d\n",
+			nae_print(NAE_DBG_ERROR, "%s , Error invalid message, size %d\n",
 				__func__, size);
 			continue;
 		}	
@@ -924,7 +923,7 @@ static void nlm_xlp_nae_msgring_handler(uint32_t vc, uint32_t src_id,
 	else if (vc == nae_fb_vc && size == 1)
 		process_tx_complete(cpu, src_id, msg0);
 	else {
-		printk("%s , Error invalid message, vc %d size %d\n",
+		nae_print(NAE_DBG_ERROR, "%s , Error invalid message, vc %d size %d\n",
 			__func__, vc, size);
 	}
 }
@@ -1022,40 +1021,40 @@ extern int nlm_xlp_register_napi_final_handler(int major,
 int nlm_xlp_enable_napi(void)
 {
 	if (exclusive_vc) {
-		printk("Registering exclusive napi vc handler....\n");
+		nae_print(NAE_DBG_TRACE, "Registering exclusive napi vc handler....\n");
 		nlm_xlp_register_napi_vc_handler(nae_rx_vc, xlp_nae_napi_poll);
 		nlm_xlp_register_napi_vc_handler(nae_fb_vc, xlp_nae_napi_poll);
 
 		return 0;
 	}
 
-	printk("Registering  poe0->cpu msgring handler\n");
+	nae_print(NAE_DBG_TRACE, "Registering  poe0->cpu msgring handler\n");
 	if (register_xlp_msgring_handler(XLP_MSG_HANDLE_POE_0,
 		nlm_xlp_nae_msgring_handler, NULL)) {
-		printk("Fatal error! Can't register msgring handler "
+		nae_print(NAE_DBG_ERROR, "Fatal error! Can't register msgring handler "
 		       "for XLP_MSG_HANDLE_NAE_0\n");
 		return -1;
 	}
-	printk("Registering nae-0 FB msgring handler\n");
+	nae_print(NAE_DBG_TRACE, "Registering nae-0 FB msgring handler\n");
 	if (register_xlp_msgring_handler(XLP_MSG_HANDLE_NAE_0,
 		nlm_xlp_nae_msgring_handler, NULL)) {
-		printk("Fatal error! Can't register msgring handler "
+		nae_print(NAE_DBG_ERROR, "Fatal error! Can't register msgring handler "
 		       "for XLP_MSG_HANDLE_NAE_0\n");
 		return -1;
 	}
 
 	if(is_nlm_xlp9xx()){
-		printk("Registering  poe1->cpu msgring handler\n");
+		nae_print(NAE_DBG_TRACE, "Registering  poe1->cpu msgring handler\n");
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_POE_1,
 			nlm_xlp_nae_msgring_handler, NULL)) {
-			printk("Fatal error! Can't register msgring handler "
+			nae_print(NAE_DBG_ERROR, "Fatal error! Can't register msgring handler "
 			       "for XLP_MSG_HANDLE_NAE_0\n");
 			return -1;
 		}
-		printk("Registering nae-1 FB msgring handler\n");
+		nae_print(NAE_DBG_TRACE, "Registering nae-1 FB msgring handler\n");
 		if (register_xlp_msgring_handler(XLP_MSG_HANDLE_NAE_1,
 			nlm_xlp_nae_msgring_handler, NULL)) {
-			printk("Fatal error! Can't register msgring handler "
+			nae_print(NAE_DBG_ERROR, "Fatal error! Can't register msgring handler "
 		       	"for XLP_MSG_HANDLE_NAE_0\n");
 			return -1;
 		}
@@ -1063,12 +1062,12 @@ int nlm_xlp_enable_napi(void)
 
 #ifdef CONFIG_INET_LRO
 	if (enable_lro) {
-		printk("Registering poe0->cpu napi final handler\n");
+		nae_print(NAE_DBG_TRACE, "Registering poe0->cpu napi final handler\n");
 		nlm_xlp_register_napi_final_handler(XLP_MSG_HANDLE_POE_0,
 				xlp_napi_lro_flush, NULL);
 
 		if(is_nlm_xlp9xx()){
-			printk("Registering poe1->cpu napi final handler\n");
+			nae_print(NAE_DBG_TRACE, "Registering poe1->cpu napi final handler\n");
 			nlm_xlp_register_napi_final_handler(XLP_MSG_HANDLE_POE_1,
 					xlp_napi_lro_flush, NULL);
 		}
diff --git a/drivers/netlogic/nae/xlpge_tso.h b/drivers/netlogic/nae/xlpge_tso.h
index f7f390c..6895a43 100644
--- a/drivers/netlogic/nae/xlpge_tso.h
+++ b/drivers/netlogic/nae/xlpge_tso.h
@@ -162,7 +162,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 	uint32_t pad_len = 0, icv_len = 0, param_index = 0;
 
 #ifdef MACSEC_DEBUG
-	printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+	nae_print(NAE_DBG_TRACE, "nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
 		nae_cfg->sectag_offset[priv->port],
 		nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
 #endif
@@ -173,7 +173,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 
 #ifdef MACSEC_DEBUG
 	dump_buffer(skb->data, skb->len, "Org skb pkt:");
-	printk("msec_port = %x priv->port = %d priv->block = %d \
+	nae_print(NAE_DBG_TRACE, "msec_port = %x priv->port = %d priv->block = %d \
 		priv->index = %d skb->len = %d \
 		nae_cfg->msec_port_enable = %x\n",
 		msec_port, priv->port, priv->block, priv->index,
@@ -187,7 +187,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 					MAC_HEADER_LEN);
 
 #ifdef MACSEC_DEBUG
-	printk("skb->len = %d ether_type = %x\n",
+	nae_print(NAE_DBG_TRACE, "skb->len = %d ether_type = %x\n",
 			skb->len, ether_type);
 #endif
 		/* Enable Macsec processing */
@@ -201,7 +201,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 			icv_len = nae_cfg->icv_len[priv->port];
 
 #ifdef MACSEC_DEBUG
-	printk("pad_len = %d icv_len = %d ether_type = %x\n",
+	nae_print(NAE_DBG_TRACE, "pad_len = %d icv_len = %d ether_type = %x\n",
 			pad_len, icv_len, ether_type);
 #endif
 		}
@@ -239,7 +239,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 			udp_hdr(skb)->check = 0;
 			tcp_packet = 0;
 		} else {
-			printk("Invalid packet in %s\n", __FUNCTION__);
+			nae_print(NAE_DBG_ERROR, "Invalid packet in %s\n", __FUNCTION__);
 			goto out_unlock;
 		}
 
@@ -281,7 +281,7 @@ static inline int tso_xmit_skb(struct sk_buff *skb, struct net_device *dev)
 #ifdef MACSEC_DEBUG
 			dump_buffer((char *)&p2pdesc[P2P_SKB_OFF-8],
 				pad_len, "first_seg:");
-			printk(" len = %d pad_len = %d icv_len = %d \
+			nae_print(NAE_DBG_TRACE, " len = %d pad_len = %d icv_len = %d \
 				param_index = %d\n", len, pad_len, icv_len,
 				param_index);
 #endif
@@ -328,7 +328,7 @@ retry_send:
 		ret = xlp_message_send_1(priv->nae_tx_qid, 0, msg);
 	msgrng_access_disable(mflags);
 	if(ret)	{
-		printk("Transmit failed\n");
+	//	printk("Transmit failed\n");
 		xlp_poll_upper(cpu);
 		retry_cnt++;
 		if(retry_cnt >= 128) {
@@ -349,7 +349,7 @@ out_unlock:
 	return NETDEV_TX_OK;
 }
 
-static int __maybe_unused tso_enable(struct net_device *dev, u32 data)
+static int tso_enable(struct net_device *dev, u32 data)
 {
 	int rv = 0;
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
@@ -358,7 +358,7 @@ static int __maybe_unused tso_enable(struct net_device *dev, u32 data)
 	if(!(is_nlm_xlp2xx_b0() || is_nlm_xlp9xx())) {
 		/* If force tso is not set, enable gso in that case */
 		if(!force_tso) {
-			printk("Disabling TSO & Enabling GSO \n");
+			nae_print(NAE_DBG_TRACE, "Disabling TSO & Enabling GSO \n");
 			dev->features = (dev->features & ~NETIF_F_TSO) | NETIF_F_GSO;
 			dev->hw_features = (dev->hw_features & ~NETIF_F_TSO) | NETIF_F_GSO;
 		}
diff --git a/drivers/netlogic/nae/xlpge_tx.c b/drivers/netlogic/nae/xlpge_tx.c
index 8854943..ceacfc1 100644
--- a/drivers/netlogic/nae/xlpge_tx.c
+++ b/drivers/netlogic/nae/xlpge_tx.c
@@ -72,7 +72,7 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	nae_t* nae_cfg = priv->nae;
 
 #ifdef MACSEC_DEBUG
-	printk("nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
+	nae_print(NAE_DBG_TRACE, "nae_cfg->sectag_offset = %d sectag_len = %d icv_len = %d\n",
 		nae_cfg->sectag_offset[priv->port],
 		nae_cfg->sectag_len[priv->port], nae_cfg->icv_len[priv->port]);
 #endif
@@ -83,7 +83,7 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 #ifdef MACSEC_DEBUG
 	dump_buffer(skb->data, skb->len, "Org skb pkt:");
-	printk("msec_port = %x priv->port = %d priv->block = %d \
+	nae_print(NAE_DBG_TRACE, "msec_port = %x priv->port = %d priv->block = %d \
 		priv->index = %d skb->len = %d \
 		nae_cfg->msec_tx_port_enable = %x\n",
 		msec_port, priv->port, priv->block, priv->index,
@@ -97,7 +97,7 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 #ifdef MACSEC_DEBUG
 	short ether_type = *(short*)(((char*)skb->data) +
 				MAC_HEADER_LEN);
-	printk("skb->len = %d ether_type = %x\n",
+	nae_print(NAE_DBG_TRACE, "skb->len = %d ether_type = %x\n",
 			skb->len, ether_type);
 #endif
 		/* Enable Macsec processing */
@@ -112,7 +112,7 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			icv_len = nae_cfg->icv_len[priv->port];
 
 #ifdef MACSEC_DEBUG
-	printk("pad_len = %d icv_len = %d ether_type = %x\n",
+	nae_print(NAE_DBG_TRACE, "pad_len = %d icv_len = %d ether_type = %x\n",
 			pad_len, icv_len, ether_type);
 #endif
 		}
@@ -122,11 +122,11 @@ int nlm_xlp_nae_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 #ifdef ENABLE_SANITY_CHECKS
 	if (!skb) {
-		printk("[%s] skb is NULL\n",__FUNCTION__);
+		nae_print(NAE_DBG_ERROR, "[%s] skb is NULL\n",__FUNCTION__);
 		return -1;
 	}
 	if (skb->len == 0) {
-		printk("[%s] skb empty packet\n",__FUNCTION__);
+		nae_print(NAE_DBG_ERROR, "[%s] skb empty packet\n",__FUNCTION__);
 		return -1;
 	}
 #endif
-- 
1.7.9.5

