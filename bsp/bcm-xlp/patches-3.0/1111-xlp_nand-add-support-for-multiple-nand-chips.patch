From 582ab9ca7569c2d7d29454f47a7111173b7b6aa0 Mon Sep 17 00:00:00 2001
From: Kamlakant Patel <kamlakant.patel@broadcom.com>
Date: Thu, 27 Mar 2014 19:16:52 +0530
Subject: [PATCH 101/163] xlp_nand: add support for multiple nand chips

xlp2xx-xmc and xlp3xx-xmc has two nand flash chips connected to
chip select 0 and 1 on nand bus.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mtd/nand/xlp_nand.c |  132 ++++++++++++++++++++++++++++---------------
 1 file changed, 88 insertions(+), 44 deletions(-)

diff --git a/drivers/mtd/nand/xlp_nand.c b/drivers/mtd/nand/xlp_nand.c
index e5607a6..9b9c093 100644
--- a/drivers/mtd/nand/xlp_nand.c
+++ b/drivers/mtd/nand/xlp_nand.c
@@ -169,13 +169,13 @@ static inline void xlp_nand_write_reg(struct xlp_nand_data *data,
 
 static int xlp_dma_wait(struct xlp_nand_data *data, int cs)
 {
-	int timeout = 0xfffff;
+	int timeout = 0xffffff;
 	while ((!(xlp_nand_read_reg(data, NAND_STATUS) & (1 << cs))) ||
 		(!(xlp_nand_read_reg(data, NAND_DMA_CTRL) & 0x01))) {
 
 		timeout--;
 		if (timeout == 0) {
-			pr_info("DMA timed out NAND_STATUS:%x\n",
+			pr_info("%d DMA timed out NAND_STATUS:%x\n", cs,
 					xlp_nand_read_reg(data, NAND_STATUS));
 			return -1;
 		}
@@ -565,10 +565,7 @@ static void xlp_select_chip(struct mtd_info *mtd, int dev)
 			struct xlp_nand_data, mtd);
 
 	if ((dev >= 0) && (dev < 8)) {
-		state->cs = dev + NAND_DEV_CS;
 		xlp_nand_write_reg(data, NAND_MEMCTRL, state->cs);
-	} else {
-		state->cs = -1;
 	}
 }
 
@@ -676,29 +673,34 @@ static irqreturn_t xlp_nand_interrupt(int irq, void *dev_id)
 
 	return IRQ_HANDLED;
 }
-/*
- * Probe for the NAND device.
- */
-static int xlp_nand_probe(struct platform_device *pdev)
+
+static int of_xlp_nand_devices(void __iomem *io_base,
+		struct platform_device *pdev,
+		struct device_node *child, int irq, int count)
 {
 	struct xlp_nand_data *data = NULL;
 	struct nand_info *info = NULL;
 	struct nand_state *state = NULL;
 	struct mtd_part_parser_data ppdata;
-	struct resource *res;
-	uint32_t val;
 	const __be32 *prop;
-	int irq, ecc_mode, ret = 0;
+	uint32_t val;
+	int ecc_mode, ret = 0, len, chip_select;
 
-	data = devm_kzalloc(&pdev->dev, sizeof(struct xlp_nand_data), GFP_KERNEL);
-	if (!data) {
-		dev_err(&pdev->dev, "failed to get device structure.\n");
-		return -ENOMEM;
+	if (count > 0) {
+		chip_select = 1;
+	} else {
+		prop = of_get_property(child, "reg", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&pdev->dev, "No 'reg' property\n");
+			return -ENXIO;
+		}
+		chip_select = be32_to_cpup(prop);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		pr_info("couldn't get resource !!\n");
+	data = devm_kzalloc(&pdev->dev,
+			sizeof(struct xlp_nand_data), GFP_KERNEL);
+	if (!data) {
+		dev_err(&pdev->dev, "devm_kzalloc failed!!\n");
 		return -ENOMEM;
 	}
 
@@ -706,25 +708,22 @@ static int xlp_nand_probe(struct platform_device *pdev)
 	if (!info)
 		return -ENOMEM;
 
-	info->nand_state = devm_kzalloc(&pdev->dev, sizeof(struct nand_state), GFP_KERNEL);
+	info->nand_state = devm_kzalloc(&pdev->dev,
+				sizeof(struct nand_state), GFP_KERNEL);
 	if (!info->nand_state)
 		return -ENOMEM;
 
-	data->io_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!data->io_base) {
-		dev_err(&pdev->dev, "ioremap failed!!\n");
-		return -ENOMEM;
-	}
+	data->io_base = io_base;
 
 	pdev->dev.dma_mask = &xlp_dev_dma_mask;
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 
 	state		= info->nand_state;
 	state->last_cmd	= 0;
-	state->cs	= 0;
+	state->cs	= chip_select;
 	state->buf_ptr	= 0;
 	state->buf	= dmam_alloc_coherent(&pdev->dev, BUF_SIZE,
-				&(state->buf_dma), GFP_KERNEL);
+			&(state->buf_dma), GFP_KERNEL);
 	if (!state->buf) {
 		pr_info("%s: dma_alloc_coherent failed!!\n", __func__);
 		return -ENXIO;
@@ -749,9 +748,9 @@ static int xlp_nand_probe(struct platform_device *pdev)
 	xlp_nand_write_reg(data, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG |
 			NAND_CTRL_GINTR_EN);
 	val = (NAND_TIME_SEQ0_TWHR(7) |
-	       NAND_TIME_SEQ0_TRHW(7) |
-	       NAND_TIME_SEQ0_TADL(7) |
-	       NAND_TIME_SEQ0_TCCS(7));
+			NAND_TIME_SEQ0_TRHW(7) |
+			NAND_TIME_SEQ0_TADL(7) |
+			NAND_TIME_SEQ0_TCCS(7));
 	xlp_nand_write_reg(data, NAND_TIME_SEQ0, val);
 
 	val = NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
@@ -769,18 +768,7 @@ static int xlp_nand_probe(struct platform_device *pdev)
 	data->chip.ecc.read_page  = xlp_nand_read_page;
 	data->chip.ecc.write_page = xlp_nand_write_page;
 
-	prop = of_get_property(pdev->dev.of_node, "interrupts", NULL);
-	if (prop == NULL) {
-		dev_err(&pdev->dev, "No \"interrupts\" property!\n");
-		return -ENXIO;
-	}
-	irq = be32_to_cpu(*prop);
-	if (!irq) {
-		dev_err(&pdev->dev, "no irq!\n");
-		return -ENXIO;
-	}
-
-	ret = devm_request_irq(&pdev->dev, irq, xlp_nand_interrupt, 0,
+	ret = devm_request_irq(&pdev->dev, irq, xlp_nand_interrupt, IRQF_SHARED,
 			pdev->name, data);
 	if (ret) {
 		dev_err(&pdev->dev, "request_irq failed!!\n");
@@ -792,9 +780,8 @@ static int xlp_nand_probe(struct platform_device *pdev)
 	if (nand_scan(&data->mtd, 1))
 		return -ENXIO;
 
-	ppdata.of_node = pdev->dev.of_node;
+	ppdata.of_node = child;
 	ret = mtd_device_parse_register(&data->mtd, NULL, &ppdata, NULL, 0);
-
 	if (!ret)
 		return ret;
 
@@ -802,6 +789,63 @@ static int xlp_nand_probe(struct platform_device *pdev)
 
 	return ret;
 }
+/*
+ * Probe for the NAND device.
+ */
+static int xlp_nand_probe(struct platform_device *pdev)
+{
+	struct device_node *child;
+	struct resource *res;
+	void __iomem *io_base;
+	const __be32 *prop;
+	int irq, ret = 0, count = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_info("couldn't get resource !!\n");
+		return -ENOMEM;
+	}
+
+	prop = of_get_property(pdev->dev.of_node, "interrupts", NULL);
+	if (prop == NULL) {
+		dev_err(&pdev->dev, "No \"interrupts\" property!\n");
+		return -ENXIO;
+	}
+	irq = be32_to_cpu(*prop);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq!\n");
+		return -ENXIO;
+	}
+
+	io_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!io_base) {
+		dev_err(&pdev->dev, "ioremap failed!!\n");
+		return -ENOMEM;
+	}
+
+	for_each_child_of_node(pdev->dev.of_node, child) {
+		/* Needs to be removed with updated FDT */
+		if (!strcmp(child->name, "partition")) {
+			count++;
+		} else {
+			ret = of_xlp_nand_devices(io_base, pdev, child,
+					irq, count);
+			if (ret < 0)
+				return ret;
+		}
+
+		continue;
+	}
+	/* Needs to be removed  with updated FDT */
+	if (count > 0) {
+		dev_err(&pdev->dev, "Old FDT, DTS file needs to be updated!\n");
+		child = pdev->dev.of_node;
+		ret = of_xlp_nand_devices(io_base, pdev, child, irq, count);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
 
 static int xlp_nand_remove(struct platform_device *pdev)
 {
-- 
1.7.9.5

