From dc8d34611ed0c36ca7886b81e1fe274b7c5f7c57 Mon Sep 17 00:00:00 2001
From: Kamlakant Patel <kamlakant.patel@broadcom.com>
Date: Sat, 9 Nov 2013 11:35:50 +0530
Subject: [PATCH 003/163] spi: add interrupt support to SPI-Controller

Signed-off-by: Kamlakant Patel <kamlakant.patel@broadcom.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/netlogic/xlp-hal/xlp.h |    2 +
 arch/mips/netlogic/xlp/nlm_hal.c             |    6 +
 drivers/spi/spi-xlp.c                        |  173 ++++++++++++++++----------
 3 files changed, 115 insertions(+), 66 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
index 75eab94..9a23eb3 100644
--- a/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp-hal/xlp.h
@@ -59,6 +59,8 @@
 #define PIC_I2C_2_IRQ			32
 #define PIC_I2C_3_IRQ			33
 
+#define PIC_SPI_IRQ			34
+
 #define PIC_SATA_IRQ			38
 
 #define PIC_GPIO_0_IRQ			39
diff --git a/arch/mips/netlogic/xlp/nlm_hal.c b/arch/mips/netlogic/xlp/nlm_hal.c
index 7093d8b..389f06c 100644
--- a/arch/mips/netlogic/xlp/nlm_hal.c
+++ b/arch/mips/netlogic/xlp/nlm_hal.c
@@ -84,6 +84,8 @@ int nlm_irq_to_irt(int irq)
 			return 134;
 		case PIC_SATA_IRQ:
 			return 143;
+		case PIC_SPI_IRQ:
+			return 152;
 		case PIC_MMC_IRQ:
 			return 153;
 		case PIC_PCIE_LINK_LEGACY_IRQ(0):
@@ -140,6 +142,10 @@ int nlm_irq_to_irt(int irq)
 	case PIC_NAND_IRQ:
 		devoff = XLP_IO_NAND_OFFSET(0);
 		break;
+
+	case PIC_SPI_IRQ:
+		devoff = XLP_IO_SPI_OFFSET(0);
+		break;
 	default:
 		if (cpu_is_xlpii()) {
 			switch (irq) {
diff --git a/drivers/spi/spi-xlp.c b/drivers/spi/spi-xlp.c
index 22ebf96..e8b76b5 100644
--- a/drivers/spi/spi-xlp.c
+++ b/drivers/spi/spi-xlp.c
@@ -35,6 +35,8 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
 
 #define XLP_SPI_CONFIG			0x40
 #define XLP_SPI_CPHA			BIT(0)
@@ -44,7 +46,7 @@
 #define XLP_SPI_TXMOSI_EN		BIT(4)
 #define XLP_SPI_RXMISO_EN		BIT(5)
 #define XLP_SPI_CS_LSBFE		BIT(10)
-#define XLP_SPI_RXCAP_EV		BIT(11)
+#define XLP_SPI_RXCAP_EN		BIT(11)
 
 #define XLP_SPI_FDIV			0x41
 #define XLP_SPI_CMD			0x42
@@ -83,20 +85,24 @@
 #define XLP_SPI_SYS_CLKDIS		BIT(1)
 #define XLP_SPI_SYS_PMEN		BIT(8)
 
-#define XLP_SPI_MAX_XFER_SIZE		0x1000
+#define XLP_SPI_XFER_SIZE		0x1c
 #define SPI_CHAN_OFFSET			0x10
-#define DEFAULT_CS_FDIV			0x10
+#define DEFAULT_CS_FDIV			0x4
+#define XLP_SPI_TXRXTH			0x80
 #define XLP_SPI_FIFO_SIZE		8
 #define XLP_SPI_MAX_CS			4
 
 struct xlp_spi_priv {
 	struct spi_master	*master;
+	struct spi_device	*spi_dev;
 	void __iomem		*base;
 	/* data buffers */
 	unsigned char		*rx_buf;
 	const unsigned char	*tx_buf;
 	int			tx_len;
 	int			rx_len;
+	int			txerrors;
+	int			rxerrors;
 	struct device		*dev;
 	int			cs;
 	bool			cmd_cont;
@@ -175,19 +181,19 @@ static int xlp_spi_setup(struct spi_device *spi)
 	 */
 	xlp_spi_reg_write(xspi, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
 	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
-	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_FIFO_THRESH, 0x80);
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_FIFO_THRESH, XLP_SPI_TXRXTH);
 
 	cfg = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_CONFIG);
 	if (spi->mode & XLP_SPI_CPHA)
 		cfg |= XLP_SPI_CPHA;
 	if (spi->mode & XLP_SPI_CPOL)
 		cfg |= XLP_SPI_CPOL;
-	if ((spi->mode & SPI_CS_HIGH))
+	if (!(spi->mode & SPI_CS_HIGH))
 		cfg |= XLP_SPI_CS_POL;
 	if (spi->mode & SPI_LSB_FIRST)
 		cfg |= XLP_SPI_CS_LSBFE;
 
-	cfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN;
+	cfg |= XLP_SPI_TXMOSI_EN | XLP_SPI_RXMISO_EN | XLP_SPI_RXCAP_EN;
 	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CONFIG, cfg);
 
 	return 0;
@@ -200,22 +206,21 @@ static void xlp_spi_read_rxfifo(struct xlp_spi_priv *xspi)
 
 	rxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs,
 			XLP_SPI_FIFO_WCNT);
-	rxfifo_cnt = rxfifo_cnt & XLP_SPI_FIFO_WCNT_MASK;
+	rxfifo_cnt &= XLP_SPI_FIFO_WCNT_MASK;
 
 	while (rxfifo_cnt) {
 		rx_data = xlp_spi_reg_read(xspi, xspi->cs,
 				XLP_SPI_RXDATA_FIFO);
 		rxfifo_cnt--;
-
 		j = 0;
 
-		limit = xspi->rx_len > 3 ? 3 : xspi->rx_len - 1;
-		for (i = limit; i >= 0; i--) {
+		limit = xspi->rx_len > 4 ? 4 : xspi->rx_len;
+		for (i = limit - 1; i >= 0; i--) {
 			xspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;
 			j++;
 		}
-		xspi->rx_len -= (limit + 1);
-		xspi->rx_buf += (limit + 1);
+		xspi->rx_len -= limit;
+		xspi->rx_buf += limit;
 	}
 }
 
@@ -232,20 +237,54 @@ static void xlp_spi_fill_txfifo(struct xlp_spi_priv *xspi)
 		j = 0;
 		tx_data = 0;
 
-		limit = xspi->tx_len > 3 ? 3 : xspi->tx_len - 1;
-		for (i = limit; i >= 0; i--) {
+		limit = xspi->tx_len > 4 ? 4 : xspi->tx_len;
+		for (i = limit - 1; i >= 0; i--) {
 			tx_data |= xspi->tx_buf[i] << (j * 8);
 			j++;
 		}
 
 		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
 
-		xspi->tx_len -= (limit + 1);
-		xspi->tx_buf += (limit + 1);
+		xspi->tx_len -= limit;
+		xspi->tx_buf += limit;
 		txfifo_cnt++;
 	}
 }
 
+static irqreturn_t xlp_spi_interrupt(int irq, void *dev_id)
+{
+	struct xlp_spi_priv *xspi;
+	struct spi_master *master = dev_id;
+	u32 stat;
+
+	xspi = spi_master_get_devdata(master);
+	xspi->cs = xspi->spi_dev->chip_select;
+	stat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS);
+
+	if (xspi->tx_len) {
+		if (stat & XLP_SPI_TX_TH_OV)
+			xlp_spi_fill_txfifo(xspi);
+
+		if (stat & XLP_SPI_TX_UF)
+			xspi->txerrors++;
+	}
+
+	if (xspi->rx_len) {
+		if (stat & XLP_SPI_RX_TH_OV)
+			xlp_spi_read_rxfifo(xspi);
+
+		if (stat & XLP_SPI_RX_OF)
+			xspi->rxerrors++;
+	}
+
+	if (stat & XLP_SPI_XFR_DONE)
+		complete(&xspi->done);
+
+	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, (stat & 0x3f));
+
+	return IRQ_HANDLED;
+}
+
 static void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,
 		int cmd_cont)
 {
@@ -263,45 +302,23 @@ static void xlp_spi_send_cmd(struct xlp_spi_priv *xspi, int xfer_len,
 	}
 }
 
-/* wait for transfer status done */
-static inline int xlp_spi_wait_xfer_done(struct xlp_spi_priv *xspi)
-{
-	unsigned long timeout, stoptime, checktime;
-	int timedout;
-	u32 status;
-
-	timeout = msecs_to_jiffies(500);
-	stoptime = jiffies + timeout;
-	timedout = 0;
-
-	while (!timedout) {
-		checktime = jiffies;
-		status = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS);
-
-		if (status & XLP_SPI_XFR_DONE)
-			return 0;
-		timedout = time_after(checktime, stoptime);
-
-		if (timedout)
-			break;
-	}
-	return -ETIMEDOUT;
-}
-
 static int xlp_spi_xfer_block(struct spi_device *spi, struct spi_transfer *t,
 		int xfer_len, int cmd_cont)
 {
 	struct xlp_spi_priv *xs = spi_master_get_devdata(spi->master);
-	int ret;
+	int timeout;
 
 	xs->rx_buf = NULL;
 	xs->tx_buf = NULL;
 
 	xs->tx_buf = t->tx_buf;
 	xs->rx_buf = t->rx_buf;
-
+	xs->spi_dev = spi;
 	xs->tx_len = (xs->tx_buf == NULL) ? 0 : xfer_len;
 	xs->rx_len = (xs->rx_buf == NULL) ? 0 : xfer_len;
+	xs->txerrors = xs->rxerrors = 0;
+
+	init_completion(&xs->done);
 
 	/* fill TXDATA_FIFO, then send the CMD */
 	if (xs->tx_len)
@@ -309,21 +326,27 @@ static int xlp_spi_xfer_block(struct spi_device *spi, struct spi_transfer *t,
 
 	xlp_spi_send_cmd(xs, xfer_len, cmd_cont);
 
-	while (xs->tx_len || xs->rx_len) {
-		if (xs->rx_len)
-			xlp_spi_read_rxfifo(xs);
-
-		if (xs->tx_len)
-			xlp_spi_fill_txfifo(xs);
+	if (xs->tx_len)
+		xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x1f);
+	else
+		xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x15);
+
+	timeout = wait_for_completion_timeout(&xs->done,
+			msecs_to_jiffies(1000));
+	if (!timeout) {
+		pr_info("%s: xfer timedout !!!\n", __func__);
+		goto out;
 	}
+	if (xs->txerrors || xs->rxerrors)
+		pr_info("Under/Overflow rx %d tx %d xfer %d!!\n",
+				xs->rxerrors, xs->txerrors, xfer_len);
 
-	ret = xlp_spi_wait_xfer_done(xs);
-	if (ret) {
-		pr_info("spi%d: xfer timedout!!\n", xs->cs);
-		return ret;
-	}
+	/* Disable interrupts */
+	xlp_spi_reg_write(xs, xs->cs, XLP_SPI_INTR_EN, 0x0);
 
 	return xfer_len;
+out:
+	return -ETIMEDOUT;
 }
 
 static int xlp_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
@@ -334,18 +357,18 @@ static int xlp_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
 	ret = 0;
 	total_len = 0;
 	len = t->len;
-	while (len > XLP_SPI_MAX_XFER_SIZE) {
-		ret = xlp_spi_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE, 1);
+	while (len > XLP_SPI_XFER_SIZE) {
+		ret = xlp_spi_xfer_block(spi, t, XLP_SPI_XFER_SIZE, 1);
 		if (ret < 0)
 			return ret;
 		else
 			total_len += ret;
 
-		len = len - XLP_SPI_MAX_XFER_SIZE;
+		len = len - XLP_SPI_XFER_SIZE;
 		if (t->tx_buf)
-			t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+			t->tx_buf = t->tx_buf + XLP_SPI_XFER_SIZE;
 		if (t->rx_buf)
-			t->rx_buf = t->rx_buf + XLP_SPI_MAX_XFER_SIZE;
+			t->rx_buf = t->rx_buf + XLP_SPI_XFER_SIZE;
 	}
 	if (len) {
 		ret = xlp_spi_xfer_block(spi, t, len, xs->cmd_cont);
@@ -382,14 +405,14 @@ static int xlp_spi_transfer_one(struct spi_master *master,
 		}
 
 		if (r != t->len || r < 0) {
-			if (r > 0)
-				status = -EREMOTEIO;
-
+			status = -EREMOTEIO;
 			goto err;
-		} else
+		} else {
 			msg->actual_length += r;
+		}
 	}
 err:
+
 	msg->status = status;
 	spi_finalize_current_message(master);
 
@@ -401,12 +424,25 @@ static int xlp_spi_probe(struct platform_device *pdev)
 	struct spi_master *master;
 	struct xlp_spi_priv *xspi;
 	struct resource *res;
-	int ret = 0;
+	const __be32 *prop;
+	int irq, ret = 0;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
 		return -ENODEV;
 
+	prop = of_get_property(pdev->dev.of_node, "interrupts", NULL);
+	if (prop == NULL) {
+		dev_err(&pdev->dev, "No \"interrupts\" property!\n");
+		return -ENXIO;
+	}
+
+	irq = be32_to_cpu(*prop);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq\n");
+		return -ENXIO;
+	}
+
 	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
 	if (!master) {
 		dev_err(&pdev->dev, "out of memory\n");
@@ -425,14 +461,19 @@ static int xlp_spi_probe(struct platform_device *pdev)
 	master->transfer_one_message = xlp_spi_transfer_one;
 	master->dev.of_node = pdev->dev.of_node;
 
-	init_completion(&xspi->done);
-
 	xspi->base = devm_request_and_ioremap(&pdev->dev, res);
 	if (xspi->base == NULL) {
 		ret = -ENOMEM;
 		goto put_master;
 	}
 
+	ret = devm_request_irq(&pdev->dev, irq, xlp_spi_interrupt,
+			IRQF_NO_THREAD, pdev->name, master);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request irq %d\n", irq);
+		goto put_master;
+	}
+
 	xlp_spi_slave_reset(xspi);
 	/* register our spi controller */
 	ret = spi_register_master(master);
-- 
1.7.9.5

