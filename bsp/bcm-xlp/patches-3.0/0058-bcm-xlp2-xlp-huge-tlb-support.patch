From 032a5f411c11fd776ab71b5e93d0a2e9317c8d0d Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 Feb 2014 21:13:39 +0800
Subject: [PATCH 58/58] bcm-xlp2: xlp huge tlb support

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/Kconfig                |    1 +
 arch/mips/include/asm/hugetlb.h  |   36 +++++++++++--
 arch/mips/include/asm/mipsregs.h |   24 +++++++++
 arch/mips/include/asm/page.h     |   24 +++++++++
 arch/mips/mm/hugetlbpage.c       |  110 ++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/tlb-r4k.c           |   44 +++++++++++++++
 arch/mips/mm/tlbex-fault.S       |    7 +++
 arch/mips/mm/tlbex.c             |   42 ++++++++++++++-
 arch/mips/netlogic/Kconfig       |    2 +-
 arch/mips/netlogic/xlp/setup.c   |    4 +-
 10 files changed, 285 insertions(+), 9 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index e17f48e..225a941 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -824,6 +824,7 @@ config NLM_XLP_BOARD
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
+	select CPU_SUPPORTS_HUGEPAGES
 	select DMA_COHERENT
 	select NR_CPUS_DEFAULT_32
 	select CEVT_R4K
diff --git a/arch/mips/include/asm/hugetlb.h b/arch/mips/include/asm/hugetlb.h
index fe0d15d..4addff1 100644
--- a/arch/mips/include/asm/hugetlb.h
+++ b/arch/mips/include/asm/hugetlb.h
@@ -51,12 +51,21 @@ static inline void hugetlb_free_pgd_range(struct mmu_gather *tlb,
 	free_pgd_range(tlb, addr, end, floor, ceiling);
 }
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+extern void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,
+	pte_t *ptep, pte_t pte);
+#else
 static inline void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,
 				   pte_t *ptep, pte_t pte)
 {
 	set_pte_at(mm, addr, ptep, pte);
 }
+#endif
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+extern pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
+	unsigned long addr, pte_t *ptep);
+#else
 static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
 					    unsigned long addr, pte_t *ptep)
 {
@@ -67,6 +76,7 @@ static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
 	set_pte_at(mm, addr, ptep, clear);
 	return pte;
 }
+#endif
 
 static inline void huge_ptep_clear_flush(struct vm_area_struct *vma,
 					 unsigned long addr, pte_t *ptep)
@@ -85,10 +95,27 @@ static inline pte_t huge_pte_wrprotect(pte_t pte)
 	return pte_wrprotect(pte);
 }
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+static inline pte_t huge_ptep_get(pte_t *ptep)
+{
+	/* Get the pte value for the even entry */
+	return __pte(pte_val(*ptep) & ~(HPAGE_SIZE >> 1));
+}
+#else
+static inline pte_t huge_ptep_get(pte_t *ptep)
+{
+	return *ptep;
+}
+#endif
+
 static inline void huge_ptep_set_wrprotect(struct mm_struct *mm,
 					   unsigned long addr, pte_t *ptep)
 {
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	set_huge_pte_at(mm, addr, ptep, pte_wrprotect(huge_ptep_get(ptep)));
+#else
 	ptep_set_wrprotect(mm, addr, ptep);
+#endif
 }
 
 static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,
@@ -99,7 +126,11 @@ static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,
 	int changed = !pte_same(*ptep, pte);
 
 	if (changed) {
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+		set_huge_pte_at(vma->vm_mm, addr, ptep, pte);
+#else
 		set_pte_at(vma->vm_mm, addr, ptep, pte);
+#endif
 		/*
 		 * There could be some standard sized pages in there,
 		 * get them all.
@@ -109,11 +140,6 @@ static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,
 	return changed;
 }
 
-static inline pte_t huge_ptep_get(pte_t *ptep)
-{
-	return *ptep;
-}
-
 static inline int arch_prepare_hugepage(struct page *page)
 {
 	return 0;
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index a543c59..1a19e48 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -231,6 +231,28 @@
 /*
  * Default huge tlb size for a given kernel configuration
  */
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+
+#ifdef CONFIG_HUGE_PAGE_SIZE_128K
+#define PM_HUGE_MASK	PM_64K
+#elif defined(CONFIG_HUGE_PAGE_SIZE_512K)
+#define PM_HUGE_MASK	PM_256K
+#elif defined(CONFIG_HUGE_PAGE_SIZE_2M)
+#define PM_HUGE_MASK	PM_1M
+#elif defined(CONFIG_HUGE_PAGE_SIZE_8M)
+#define PM_HUGE_MASK	PM_4M
+#elif defined(CONFIG_HUGE_PAGE_SIZE_32M)
+#define PM_HUGE_MASK	PM_16M
+#elif defined(CONFIG_HUGE_PAGE_SIZE_128M)
+#define PM_HUGE_MASK	PM_64M
+#elif defined(CONFIG_HUGE_PAGE_SIZE_512M)
+#define PM_HUGE_MASK	PM_256M
+#else
+#error Bad page size configuration for hugetlbfs!
+#endif
+
+#else /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
+
 #ifdef CONFIG_PAGE_SIZE_4KB
 #define PM_HUGE_MASK	PM_1M
 #elif defined(CONFIG_PAGE_SIZE_8KB)
@@ -245,6 +267,8 @@
 #error Bad page size configuration for hugetlbfs!
 #endif
 
+#endif /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
+
 /*
  * Values used for computation of new tlb entries
  */
diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index f59552f..4d78ed1 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -34,7 +34,31 @@
 #define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
 
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
+
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+
+#ifdef CONFIG_HUGE_PAGE_SIZE_128K
+#define HPAGE_SHIFT	(PL_64K + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_512K)
+#define HPAGE_SHIFT	(PL_256K + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_2M)
+#define HPAGE_SHIFT	(PL_1M + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_8M)
+#define HPAGE_SHIFT	(PL_4M + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_32M)
+#define HPAGE_SHIFT	(PL_16M + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_128M)
+#define HPAGE_SHIFT	(PL_64M + 1)
+#elif defined(CONFIG_HUGE_PAGE_SIZE_512M)
+#define HPAGE_SHIFT	(PL_256M + 1)
+#else
+#error no proper huge page size defined!
+#endif
+
+#else /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
+#endif /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
+
 #define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
diff --git a/arch/mips/mm/hugetlbpage.c b/arch/mips/mm/hugetlbpage.c
index a7fee0d..f36bbda 100644
--- a/arch/mips/mm/hugetlbpage.c
+++ b/arch/mips/mm/hugetlbpage.c
@@ -22,6 +22,114 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+
+static pte_t *huge_pte_alloc_single(struct mm_struct *mm, unsigned long addr)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte = NULL;
+
+	pgd = pgd_offset(mm, addr);
+	pud = pud_alloc(mm, pgd, addr);
+	if (pud) {
+		pmd = (pmd_t *)pmd_alloc(mm, pud, addr);
+		if (pmd)
+			pte = pte_alloc_map(mm, NULL, pmd, addr);
+	}
+
+	return pte;
+}
+
+/**
+ * Given any address, we need to allocate page table entries
+ * for all pte's covered by the same huge page. This is needed if
+ * any address referencing the huge page faults and the tlb refill handler
+ * can refill the tlb entry with correct value.
+ *
+ * Return any valid pte pointer is fine as later on we still have
+ * "addr" to identify the correct huge page.
+ */
+pte_t *huge_pte_alloc(struct mm_struct *mm, unsigned long addr,
+		      unsigned long sz)
+{
+	pte_t *pte = NULL;
+	unsigned long i = 0;
+	unsigned long htlb_entries = 1 << HUGETLB_PAGE_ORDER;
+
+	addr &= HPAGE_MASK;
+	for (i = 0; i < htlb_entries; i++) {
+		pte = huge_pte_alloc_single(mm, addr);
+		if (!pte)
+			return NULL;
+		addr += PAGE_SIZE;
+	}
+	return pte;
+}
+
+pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte = NULL;
+
+	pgd = pgd_offset(mm, addr);
+	if (pgd_present(*pgd)) {
+		pud = pud_offset(pgd, addr);
+		if (pud_present(*pud)) {
+			pmd = pmd_offset(pud, addr);
+			if (pmd_present(*pmd))
+				pte = pte_offset_map(pmd, addr);
+		}
+	}
+	return pte;
+}
+
+/**
+ * Fill the pte value to all pte's covered by the same huge page.
+ */
+void set_huge_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep,
+			pte_t entry)
+{
+	unsigned long i;
+	unsigned long htlb_entries = 1 << HUGETLB_PAGE_ORDER;
+	pte_t entry2;
+
+	entry2 =  __pte(pte_val(entry) + (HPAGE_SIZE >> 1));
+
+	addr &= HPAGE_MASK;
+	for (i = 0; i < htlb_entries; i += 2) {
+		ptep = huge_pte_offset(mm, addr);
+		set_pte_at(mm, addr, ptep, entry);
+		addr += PAGE_SIZE;
+
+		ptep = huge_pte_offset(mm, addr);
+		set_pte_at(mm, addr, ptep, entry2);
+		addr += PAGE_SIZE;
+	}
+}
+
+pte_t huge_ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,
+				pte_t *ptep)
+{
+	pte_t entry;
+	unsigned long i;
+	unsigned long htlb_entries = 1 << HUGETLB_PAGE_ORDER;
+
+	entry = *ptep;
+	addr &= HPAGE_MASK;
+	for (i = 0; i < htlb_entries; i++) {
+		ptep = huge_pte_offset(mm, addr);
+		pte_clear(mm, addr, ptep);
+		addr += PAGE_SIZE;
+	}
+	return entry;
+}
+
+#else /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
+
 pte_t *huge_pte_alloc(struct mm_struct *mm, unsigned long addr,
 		      unsigned long sz)
 {
@@ -52,6 +160,8 @@ pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)
 	return (pte_t *) pmd;
 }
 
+#endif /* CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT */
+
 int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
 {
 	return 0;
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 355bc81..7543efd 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -299,6 +299,22 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 	idx = read_c0_index();
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 	/* this could be a huge page  */
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	if (is_vm_hugetlb_page(vma)) {
+		write_c0_pagemask(PM_HUGE_MASK);
+		ptep = pte_offset_map(pmdp, address);
+		write_c0_entrylo0(pte_to_entrylo(pte_val(*ptep++)));
+		write_c0_entrylo1(pte_to_entrylo(pte_val(*ptep)));
+
+		mtc0_tlbw_hazard();
+		if (idx < 0)
+			tlb_write_random();
+		else
+			tlb_write_indexed();
+		tlbw_use_hazard();
+		write_c0_pagemask(PM_DEFAULT_MASK);
+	} else
+#else
 	if (pmd_huge(*pmdp)) {
 		unsigned long lo;
 		write_c0_pagemask(PM_HUGE_MASK);
@@ -316,6 +332,7 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 		write_c0_pagemask(PM_DEFAULT_MASK);
 	} else
 #endif
+#endif
 	{
 		ptep = pte_offset_map(pmdp, address);
 
@@ -369,6 +386,33 @@ void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 	EXIT_CRITICAL(flags);
 }
 
+#if defined(CONFIG_CPU_XLP) && defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
+asmlinkage void do_hugetlb_invalidate(void)
+{
+	int idx;
+	uint64_t oldpid;
+
+	oldpid = read_c0_entryhi();
+	tlb_probe();
+	tlb_probe_hazard();
+	idx = read_c0_index();
+	if (idx > 0) {
+		int ridx = idx & 0x1fff;
+
+		if (ridx > ((read_c0_config6() >> 6) & 0x3ff)) {
+			/* Make sure all entries differ. */
+			write_c0_entrylo0(0);
+			write_c0_entrylo1(0);
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx & 0x1fff));
+			mtc0_tlbw_hazard();
+			tlb_write_indexed();
+			tlbw_use_hazard();
+			write_c0_entryhi(oldpid);
+		}
+	}
+}
+#endif
+
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 
 int __init has_transparent_hugepage(void)
diff --git a/arch/mips/mm/tlbex-fault.S b/arch/mips/mm/tlbex-fault.S
index 318855e..2507a08 100644
--- a/arch/mips/mm/tlbex-fault.S
+++ b/arch/mips/mm/tlbex-fault.S
@@ -13,6 +13,13 @@
 	.macro tlb_do_page_fault, write
 	NESTED(tlb_do_page_fault_\write, PT_SIZE, sp)
 	SAVE_ALL
+
+#if defined(CONFIG_CPU_XLP) && defined(CONFIG_MIPS_HUGE_TLB_SUPPORT)
+	/* invalidate the tlb entry */
+	jal	do_hugetlb_invalidate
+	nop
+#endif
+
 	MFC0	a2, CP0_BADVADDR
 	KMODE
 	move	a0, sp
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 7e55c85..47e2d40 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -160,6 +160,9 @@ enum label_id {
 	label_large_segbits_fault,
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 	label_tlb_huge_update,
+#ifdef CONFIG_CPU_XLP
+	label_r4000_write_huge_probe_fail,
+#endif
 #endif
 };
 
@@ -179,6 +182,9 @@ UASM_L_LA(_r3000_write_probe_fail)
 UASM_L_LA(_large_segbits_fault)
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 UASM_L_LA(_tlb_huge_update)
+#ifdef CONFIG_CPU_XLP
+UASM_L_LA(_r4000_write_huge_probe_fail)
+#endif
 #endif
 
 static int __cpuinitdata hazard_instance;
@@ -742,6 +748,16 @@ static __cpuinit void build_huge_update_entries(u32 **p,
 						unsigned int pte,
 						unsigned int tmp)
 {
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	build_convert_pte_to_entrylo(p, pte);
+	UASM_i_MTC0(p, pte, C0_ENTRYLO0); /* load it */
+
+	uasm_i_ld(p, pte, sizeof(pte_t), tmp);
+	build_convert_pte_to_entrylo(p, pte);
+	UASM_i_MTC0(p, pte, C0_ENTRYLO1); /* load it */
+
+	uasm_i_ehb(p);
+#else
 	int small_sequence;
 
 	/*
@@ -768,6 +784,7 @@ static __cpuinit void build_huge_update_entries(u32 **p,
 		UASM_i_ADDU(p, pte, pte, tmp);
 
 	UASM_i_MTC0(p, pte, C0_ENTRYLO1); /* load it */
+#endif
 }
 
 static __cpuinit void build_huge_handler_tail(u32 **p,
@@ -783,6 +800,14 @@ static __cpuinit void build_huge_handler_tail(u32 **p,
 #else
 	UASM_i_SW(p, pte, 0, ptr);
 #endif
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	/* adjust the ptep pointer to be at even entry boundary.
+	 * this is needed to write back entries to tlb.
+	 */
+	uasm_i_ori(p, ptr, ptr, sizeof(pte_t));
+	uasm_i_xori(p, ptr, ptr, sizeof(pte_t));
+	UASM_i_LW(p, pte, 0, ptr);
+#endif
 	build_huge_update_entries(p, pte, ptr);
 	build_huge_tlb_write_entry(p, l, r, pte, tlb_indexed, 0);
 }
@@ -1336,11 +1361,17 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		build_get_pgde32(&p, K0, K1); /* get pgd in K1 */
 #endif
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+		build_get_ptep(&p, K0, K1);
+#endif
+
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 		build_is_huge_pte(&p, &r, K0, K1, label_tlb_huge_update);
 #endif
 
+#ifndef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
 		build_get_ptep(&p, K0, K1);
+#endif
 		build_update_entries(&p, K0, K1);
 		build_tlb_write_entry(&p, &l, &r, tlb_random);
 		uasm_l_leave(&l, p);
@@ -1348,6 +1379,11 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	}
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 	uasm_l_tlb_huge_update(&l, p);
+
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	/* We need to load huge_pte which is expected by subsequent call */
+	UASM_i_LW(&p, htlb_info.huge_pte, 0, K1);
+#endif
 	build_huge_update_entries(&p, htlb_info.huge_pte, K1);
 	build_huge_tlb_write_entry(&p, &l, &r, K0, tlb_random,
 				   htlb_info.restore_scratch);
@@ -1909,7 +1945,7 @@ build_r4000_tlbchange_handler_head(u32 **p, struct uasm_label **l,
 	build_get_pgde32(p, wr.r1, wr.r2); /* get pgd in ptr */
 #endif
 
-#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
+#if defined(CONFIG_MIPS_HUGE_TLB_SUPPORT) && !defined(CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT)
 	/*
 	 * For huge tlb entries, pmd doesn't contain an address but
 	 * instead contains the tlb pte. Check the PAGE_HUGE bit and
@@ -1924,6 +1960,10 @@ build_r4000_tlbchange_handler_head(u32 **p, struct uasm_label **l,
 	uasm_i_andi(p, wr.r1, wr.r1, (PTRS_PER_PTE - 1) << PTE_T_LOG2);
 	UASM_i_ADDU(p, wr.r2, wr.r2, wr.r1);
 
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	build_is_huge_pte(p, r, wr.r1, wr.r2, label_tlb_huge_update);
+#endif
+
 #ifdef CONFIG_SMP
 	uasm_l_smp_pgtable_change(l, *p);
 #endif
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 8ae3174..25720b1 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -87,7 +87,7 @@ config NLM_ENABLE_COP2
 
 config HUGEPAGE_NOT_MIPS_DEFAULT
 	bool "Support for not-mips-style hugepage"
-	depends on HUGETLB_PAGE
+	depends on MIPS_HUGE_TLB_SUPPORT
 	default n
 	help
 	  Support not-mips-style hugepage
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 316b509..c4e1e6b 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -188,7 +188,7 @@ void pgwalker_init(void)
 		printk("Hardware page walker is not supported for XLP8XX/XLP3XX\n");
 		return;
 	}
-#ifdef CONFIG_HUGETLB_PAGE
+#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 	else if (!cpu_is_xlp9xx()) {
 		printk("Hardware page walker is not supported for XLP2XX HugeTLB Page\n");
 		return;
@@ -215,7 +215,7 @@ void pgwalker_init(void)
 	/* enable page walker */
 	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_O;
 
-#ifdef CONFIG_HUGETLB_PAGE
+#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_HUGETLB;
 	pwctl_val |= _PAGE_HUGE_SHIFT << PWCTL_PW_HUGEVLD_PSN;
 #endif
-- 
1.7.9.5

