From a4d63b0fab0a8a2b3c078abfe2abf5d502906291 Mon Sep 17 00:00:00 2001
From: Ganesan Ramalingam <ganesanr@broadcom.com>
Date: Wed, 26 Feb 2014 07:50:18 +0530
Subject: [PATCH 090/160] Fix for SATA link-up issue on low temperature

* Port2 like-up failing on low temperature, changes in Vsemi phy values
  fixes the issue.

* Fixes for the bugs in debug functions

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 arch/mips/netlogic/xlp/ahci-init-xlp2.c |   56 ++++++++++++++++++++-----------
 1 file changed, 36 insertions(+), 20 deletions(-)

diff --git a/arch/mips/netlogic/xlp/ahci-init-xlp2.c b/arch/mips/netlogic/xlp/ahci-init-xlp2.c
index ac292af..3332001 100644
--- a/arch/mips/netlogic/xlp/ahci-init-xlp2.c
+++ b/arch/mips/netlogic/xlp/ahci-init-xlp2.c
@@ -140,9 +140,6 @@
 #define RXDPIF			0x8065
 #define PPMDRIFTMAX_HI		0x80A4
 
-#define D15				0x800F
-#define D15_CONFIG_VAL	0x1F
-
 #define nlm_read_sata_reg(b, r)		nlm_read_reg(b, r)
 #define nlm_write_sata_reg(b, r, v)	nlm_write_reg(b, r, v)
 #define nlm_get_sata_pcibase(node)	\
@@ -190,41 +187,62 @@ static void write_phy_reg(u64 regbase, u32 addr, u32 physel, u8 data)
 	udelay(850);
 }
 
+static u8 read_phy_reg(u64 regbase, u32 addr, u32 physel)
+{
+	u32 val;
+
+	nlm_write_sata_reg(regbase, PHY_MEM_ACCESS,
+		(0 << 31) | (physel << 24) | (0 << 16) | addr);
+	udelay(850);
+	val = nlm_read_sata_reg(regbase, PHY_MEM_ACCESS);
+	return (val >> 16) & 0xff;
+}
+
 static void config_vsemi_phy(u64 regbase, u32 node)
 {
 	u32 port, i, reg;
+	u8 val;
 
 	for (port = 0; port < 2; port++) {
 		for (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)
 			write_phy_reg(regbase, reg, port, vsemi_config1[i]);
 		
-		//write_phy_reg(regbase, D15, port, D15_CONFIG_VAL);
-
 		for (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)
 			write_phy_reg(regbase, reg, port, vsemi_config2[i]);
+
+		/* On lower temperature the port2 link-up failing, to fix that
+		 * below changes are needed in Vsemi phy
+		 */
+		write_phy_reg(regbase, 0x800F, port, 0x1f);
+
+		val = read_phy_reg(regbase, 0x0029, port);
+		write_phy_reg(regbase, 0x0029, port, val | (0x7 << 1));
+		
+		val = read_phy_reg(regbase, 0x0056, port);
+		write_phy_reg(regbase, 0x0056, port, val & ~(1 << 3));
+
+		val = read_phy_reg(regbase, 0x0018, port);
+		write_phy_reg(regbase, 0x0018, port, val & ~(0x7 << 0));
 	}
 }
 
 #if 0	/* DEBUG */
-static u8 read_phy_reg(u64 regbase, u32 addr, u32 physel)
+static void check_phy_register(u64 regbase, u32 addr, u32 physel, u8 xdata)
 {
-	u32 val;
+	u8 data;
 
-	nlm_write_sata_reg(regbase, PHY_MEM_ACCESS,
-		(0 << 31) | (physel << 24) | (data << 16) | addr);
-	udelay(850);
-	val = nlm_read_sata_reg(regbase, PHY_MEM_ACCESS);
-	return (val >> 16) & 0xff;
+	data = read_phy_reg(regbase, addr, physel);
+	pr_info("PHY read addr = 0x%x physel = %d data = 0x%x %s\n",
+		addr, physel, data, data == xdata ? "TRUE" : "FALSE");
 }
 
-static void check_phy_register(u63 regbase, u32 addr, u32 physel, u8 xdata)
+static void print_phy_register(u64 regbase, u32 addr, u32 physel)
 {
-	u64 regbase;
 	u8 data;
 
 	data = read_phy_reg(regbase, addr, physel);
-	pr_info("PHY read addr = 0x%x physel = %d data = 0x%x %s\n",
-		addr, physel, data, data == xdata ? "TRUE" : "FALSE");
+	pr_info("PHY read addr = 0x%x physel = %d data = 0x%x\n",
+		addr, physel, data);
 }
 
 static void verify_vsemi_config(u64 regbase, u32 node)
@@ -233,13 +251,11 @@ static void verify_vsemi_config(u64 regbase, u32 node)
 
 	for (port = 0; port < 2; port++) {
 		for (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)
-			check_phy_register(regbase, node, reg, port,
+			check_phy_register(regbase, reg, port,
 					vsemi_config1[i]);
 
-		check_phy_register(regbase, node, D15, port, D15_CONFIG_VAL);
-		
 		for (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)
-			check_phy_register(regbase, node, reg, port,
+			check_phy_register(regbase, reg, port,
 					vsemi_config2[i]);
 	}
 }
-- 
1.7.9.5

