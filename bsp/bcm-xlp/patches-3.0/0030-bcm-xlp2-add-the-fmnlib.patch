From a389594d6c24f9966864b09269052026cfd4bf3b Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 17:35:48 +0800
Subject: [PATCH 30/58] bcm-xlp2: add the fmnlib

Get from SDK_DIR/libraries/fmnlib

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/netlogic/lib/fmnlib/Makefile             |    9 +
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h        |  298 ++++
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c | 1418 ++++++++++++++++++++
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h     | 1188 ++++++++++++++++
 arch/mips/netlogic/lib/fmnlib/nlm_msgring.h        |  107 ++
 5 files changed, 3020 insertions(+)

diff --git a/arch/mips/netlogic/lib/fmnlib/Makefile b/arch/mips/netlogic/lib/fmnlib/Makefile
new file mode 100644
index 0000000..528a0ea
--- /dev/null
+++ b/arch/mips/netlogic/lib/fmnlib/Makefile
@@ -0,0 +1,9 @@
+EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -DNLM_CORTINA_SUPPORT -Wno-maybe-uninitialized
+EXTRA_CFLAGS += -Iarch/mips/netlogic/boot/
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/syslib/include
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/fmnlib
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt/contrib
+
+obj-y += fmnlib.o
+fmnlib-objs := nlm_hal_fmn_config.o
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
new file mode 100644
index 0000000..d01812b
--- /dev/null
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
@@ -0,0 +1,298 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLH_FMN_H
+#define _NLH_FMN_H
+
+#include "nlm_hal.h"
+#include "nlm_hal_fmn_dp.h"
+#include "nlm_hal_xlp_dev.h"
+
+#ifndef __ASSEMBLY__
+
+#define FMN_INT_BIT_MASK 0x800000000000000ULL /* Bit 59 */
+
+#define XLP_FMN_DEFAULT_QUEUE_SIZE	28672 /* 28K */
+#define XLP_FMN_DEFAULT_CREDITS    	50
+#define XLP_FMNQ_SPILL_DEFAULT_MEM_ADDR (256ULL << 20)
+#define XLP_FMNQ_SPILL_DEFAULT_MEM_SIZE (32ULL << 20)
+
+#define FMN_MAX_Q_SIZE (256ULL * 1024)
+#define FMN_Q_PAGE_SIZE (4ULL * 1024)
+
+enum FMN_MSG_BLKS {
+	XLP_MSG_BLK_CPU = 0, 
+	XLP_MSG_BLK_POPQ, 
+        XLP_MSG_BLK_PCIE0,
+        XLP_MSG_BLK_PCIE1,
+        XLP_MSG_BLK_PCIE2,
+        XLP_MSG_BLK_PCIE3,
+	XLP_MSG_BLK_GDX,
+	XLP_MSG_BLK_GDX1,
+	XLP_MSG_BLK_RSA_ECC,
+	XLP_MSG_BLK_CRYPTO,
+	XLP_MSG_BLK_CMP,
+	XLP_MSG_BLK_POE,
+	XLP_MSG_BLK_NAE,
+	XLP_MSG_BLK_REGX,
+	XLP_MSG_BLK_SRIO,
+	XLP_MSG_BLK_LZS,
+	XLP_MSG_BLK_MAX
+};
+
+
+enum LVL_INT_TYPES {
+	LVL_INT_DISABLE,
+	LVL_INT_LOW_WM,
+	LVL_INT_HIGH_WM,
+	LV_INT_RESERVED
+};
+
+enum LWM_INT_VALUES {
+	LWM_EMPTY,
+	LWM_1_4_FULL,
+	LWM_1_2_FULL,
+	LWM_3_4_FULL,
+	LWM_NON_FULL,
+	LWM_NUM_VALUES
+};
+enum HWM_INT_VALUES {
+	HWM_NON_EMPTY,
+	HWM_1_4_FULL,
+	HWM_1_2_FULL,
+	HWM_3_4_FULL,
+	HWM_FULL,
+	HWM_NUM_VALUES
+};
+
+/*
+ *  FMN Reg access macros
+ */
+enum XLP_REGS{
+  XLP_OUTQ_CONFIG_REG,
+  XLP_CREDIT_CONFIG_REG,
+  XLP_INTERCHIP_LINK_CONFIG_REG,
+  XLP_ERROR_REG
+};
+
+struct fmn_qsize_credit_config
+{
+        char q_name[16]; /* fmn station type*/
+        int b_stid; /* base stations */
+        int e_stid; /* end stations */
+        int n_txstns; /* number of tranmit stations from this type, only used for credit warn */
+        int valid;
+        int q_size; /* queue size for this type */
+        unsigned int credits[NLM_MAX_NODES][XLP_MSG_BLK_MAX];
+};
+
+struct fmn_cfg {
+        uint64_t fmn_spill_base;
+        uint64_t fmn_spill_size;
+        uint32_t fmn_default_qsize;
+        uint32_t fmn_default_credits;
+        uint32_t max_msg_blk;
+        struct fmn_qsize_credit_config  fmn_q_config[XLP_MSG_BLK_MAX];
+        /* onchi mem */
+        uint64_t q_ram_base;
+        uint32_t q_ram_page_perq;
+        uint32_t q_ram_base_cur;
+
+        /* spill mem */
+        uint32_t spill_base_cur;
+};
+
+typedef volatile unsigned long long msg_reg_t;
+
+static inline unsigned long long nlh_qid_to_virt_addr(int node, int reg, int sel)
+{
+  unsigned long long base = xlp_fmn_base[node] & 0xffffffc000ULL;
+
+#if 0 /*defined(NLM_HAL_LINUX_USER) */
+  base |= NLH_XKPHYS_UNCACHED;
+#endif
+
+  if (reg == XLP_OUTQ_CONFIG_REG) {
+    return ((sel * 8) | base); /* 'sel' is the qid */
+
+  } else if (reg == XLP_CREDIT_CONFIG_REG) {
+    return (0x2000 | base);
+
+  } else if (reg == XLP_ERROR_REG) {
+    return (0x2020 | base);
+
+  } else {
+    /*    nlm_print("FMN Error: Unknown register ID %d\n", reg); */
+  }
+  return 0;
+}
+/* */
+
+#define nlm_hal_read_outq_config(node, qid) \
+	nlh_read_cfg_reg64(nlh_qid_to_virt_addr(node, XLP_OUTQ_CONFIG_REG, qid))
+
+#define nlm_hal_write_outq_config(node, qid, val) \
+	nlh_write_cfg_reg64(nlh_qid_to_virt_addr(node, XLP_OUTQ_CONFIG_REG, qid), val)
+
+/* */
+#define xlp_enable(flags)                        \
+do {                                                \
+  __asm__ volatile (                                \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+} while (0)
+/* */
+#define xlp_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+/* */
+static __inline__ unsigned long long xlp_cpu_to_bucket_mask(unsigned int
+							       cpumask)
+{
+  return 0;
+}
+/* */
+static __inline__ unsigned int xlp_cpu_to_bucket(int pid)
+{
+  return 0;
+}
+
+/* 
+   *
+   * This API can be used for both enabling and disabling the POP operation 
+   * in the msgconfig register.  
+   * 
+   * In vc_mask:
+   * '0' means disable  and 
+   * '1' means enable.
+   *
+   * bit0 = vc0, bit1 = vc1, bit2 = vc2, bit3 = vc3
+   *
+   */
+static inline int nlm_hal_pop_cfg_update (uint32_t vc_mask)
+{
+	uint32_t vc, config; 
+
+	/* mask out the other bits in vc_mask, just to be safe */
+	vc_mask &= 0x0f;
+	vc = (vc_mask << 1);
+
+	config = xlp_read_config();
+	config &= ~(0x1e);
+	config |= vc;
+	xlp_write_config(config);
+
+	return 0;
+}
+
+static inline int nlm_hal_pop_send (uint32_t popq)
+{
+	int rc = 0;
+
+	if (!xlp_send(popq) )
+	{
+		/* Check the status */
+		rc = xlp_read_tx_status();
+	}
+
+	return rc;
+}
+
+#endif				/* __ASSEMBLY__ */
+
+
+static __inline__ int fmn_level_int_type(uint64_t outq_config)
+{
+	return xlp_get_field_dw(outq_config, 54, 2);
+}
+
+static __inline__ int fmn_level_int_val(uint64_t outq_config)
+{
+	return xlp_get_field_dw(outq_config, 56, 3);
+}
+
+
+static __inline__ int nlm_hal_enable_rxqdepth(int node, int qid)
+{
+        uint64_t val = 0;
+        if (is_nlm_xlp9xx()) {
+                //*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+                val = nlh_read_cfg_reg64(xlp_fmn_base[node] + (qid << 3));
+                val |= (1UL<<51);
+                nlh_write_cfg_reg64(xlp_fmn_base[node] + (qid << 3), val);
+                return 0;
+        }
+        else
+                return -1;
+}
+
+
+static __inline__ int nlm_hal_disable_rxqdepth(int node, int qid)
+{
+        uint64_t val = 0;
+        if (is_nlm_xlp9xx()) {
+                //*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+                val = nlh_read_cfg_reg64(xlp_fmn_base[node] + (qid << 3));
+                val &= ~(1UL<<51);
+                nlh_write_cfg_reg64(xlp_fmn_base[node] + (qid << 3), val);
+                return 0;
+        }
+        else
+                return -1;
+}
+
+extern int get_dom_fmn_node_ownership(void *fdt, int dom_id);
+extern void nlm_hal_fmn_init(void *fdt, int node);
+extern void nlm_hal_set_fmn_interrupt(int irq);
+
+extern void nlm_hal_disable_vc_intr(int node, int vc);
+extern void nlm_hal_enable_vc_intr(int node, int vc);
+#endif /* #ifndef _NLH_FMN_H */
+
+	
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
new file mode 100644
index 0000000..52aab90
--- /dev/null
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -0,0 +1,1418 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#endif
+#include "nlm_hal_fmn.h"
+#include "libfdt.h"
+#include "fdt_helper.h"
+#include "nlm_hal_sys.h"
+
+#define CPU		1
+#define PCIE		2
+#define GDX		3
+#define CMP		4
+#define CRYPTO		5
+#define POE		6
+#define NAE		7
+#define RSA		8
+
+#define INT_EN 			0x0800000000000000ULL
+#define OUTQ_EN			0x8000000000000000ULL
+#define SPILL_EN 		0x4000000000000000ULL
+#define LOW40MASK       	0x000000ffffffffffULL
+#define UP46MASK        	0xfffffffffffc0000ULL
+#define UP52MASK        	0xfffffffffffff000ULL
+#define LOW18MASK       	0x000000000003ffffULL
+#define LOW4KMASK       	0x00000000000003ffULL
+
+
+#define DEFAULT_SINGLE_ENTRY_MSG_SZ	12
+#define XLP9XX_SINGLE_ENTRY_MSG_SZ	16
+
+nlm_fmn_config_t xlp3xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU2] = {XLP_STNID_CPU2, XLP_CPU2_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU3] = {XLP_STNID_CPU3, XLP_CPU3_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CPU4] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU5] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU6] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU7] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU8] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU9] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU10] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU11] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU12] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU13] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU14] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU15] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU16] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU17] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU18] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU19] = {XLP_3XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
+
+/* duplication? DTRE and GDX */
+[XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]  = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_REGX] = {XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO] = {XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_SRIO] = {XLP_3XX_SRIO_VC_BASE, XLP_3XX_SRIO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CMP] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_LZS] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_KBP] = {XLP_3XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_POE] = {XLP_3XX_POE_VC_BASE, XLP_3XX_POE_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_3XX_NET_TX_VC_BASE, XLP_3XX_NET_TX_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POE_1] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_ALE]   = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POPQ]  = {XLP_3XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_3XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_3XX_INVALID_STATION, 0},
+};
+
+nlm_fmn_config_t xlp2xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CPU2] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU3] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_CPU4] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU5] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU6] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU7] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU8] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU9] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU10] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU11] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU12] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU13] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU14] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU15] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU16] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU17] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU18] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU19] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
+
+/* duplication? DTRE and GDX */
+[XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]  = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_REGX] = {XLP_2XX_REGEX_VC_BASE, XLP_2XX_REGEX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO] = {XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_SRIO] = {XLP_2XX_INVALID_STATION,0},
+
+[XLP_MSG_HANDLE_CMP] = {XLP_2XX_CDE_VC_BASE, XLP_2XX_CDE_VC_BASE},
+[XLP_MSG_HANDLE_LZS] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_KBP] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_POE] = {XLP_2XX_POE_VC_BASE, XLP_2XX_POE_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_2XX_NET_TX_VC_BASE, XLP_2XX_NET_VC_LIMIT},
+[XLP_MSG_HANDLE_POE_1] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_ALE]   = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_POPQ]  = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_2XX_INVALID_STATION, 0},
+};
+
+nlm_fmn_config_t xlp9xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0]  = {XLP_STNID_CPU0,  XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1]  = {XLP_STNID_CPU1,  XLP_CPU1_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU2]  = {XLP_STNID_CPU2,  XLP_CPU2_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU3]  = {XLP_STNID_CPU3,  XLP_CPU3_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU4]  = {XLP_STNID_CPU4,  XLP_CPU4_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU5]  = {XLP_STNID_CPU5,  XLP_CPU5_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU6]  = {XLP_STNID_CPU6,  XLP_CPU6_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU7]  = {XLP_STNID_CPU7,  XLP_CPU7_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU8]  = {XLP_STNID_CPU8,  XLP_CPU8_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU9]  = {XLP_STNID_CPU9,  XLP_CPU9_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU10] = {XLP_STNID_CPU10, XLP_CPU10_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU11] = {XLP_STNID_CPU11, XLP_CPU11_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU12] = {XLP_STNID_CPU12, XLP_CPU12_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU13] = {XLP_STNID_CPU13, XLP_CPU13_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU14] = {XLP_STNID_CPU14, XLP_CPU14_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU15] = {XLP_STNID_CPU15, XLP_CPU15_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU16] = {XLP_STNID_CPU16, XLP_CPU16_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU17] = {XLP_STNID_CPU17, XLP_CPU17_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU18] = {XLP_STNID_CPU18, XLP_CPU18_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU19] = {XLP_STNID_CPU19, XLP_CPU19_VC_LIMIT},
+
+[XLP_MSG_HANDLE_PCIE0]   = {XLP_9XX_PCIE0_VC_BASE, XLP_9XX_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1]   = {XLP_9XX_PCIE1_VC_BASE, XLP_9XX_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2]   = {XLP_9XX_PCIE2_VC_BASE, XLP_9XX_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3]   = {XLP_9XX_PCIE3_VC_BASE, XLP_9XX_PCIE3_VC_LIMIT},
+[XLP_MSG_HANDLE_DTRE]    = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_GDX_0]   = {XLP_9XX_GDX0_VC_BASE, XLP_9XX_GDX0_VC_LIMIT},
+[XLP_MSG_HANDLE_GDX_1]   = {XLP_9XX_GDX1_VC_BASE, XLP_9XX_GDX1_VC_LIMIT},
+[XLP_MSG_HANDLE_REGX]    = {XLP_9XX_RGX_VC_BASE, XLP_9XX_RGX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_9XX_RSA_VC_BASE, XLP_9XX_RSA_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO]  = {XLP_9XX_SEC_VC_BASE, XLP_9XX_SEC_VC_LIMIT},
+[XLP_MSG_HANDLE_SRIO]    = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CMP]    = {XLP_9XX_CMP_VC_BASE, XLP_9XX_CMP_VC_LIMIT},
+[XLP_MSG_HANDLE_LZS]    = {XLP_9XX_LZS_VC_BASE, XLP_9XX_LZS_VC_LIMIT},
+[XLP_MSG_HANDLE_KBP]    = {XLP_9XX_KBP_VC_BASE, XLP_9XX_KBP_VC_LIMIT},
+
+[XLP_MSG_HANDLE_POE_0] = {XLP_9XX_POE0_VC_BASE, XLP_9XX_POE0_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_9XX_NET0_VC_BASE, XLP_9XX_NET0_VC_LIMIT},
+[XLP_MSG_HANDLE_POE_1] = {XLP_9XX_POE1_VC_BASE, XLP_9XX_POE1_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_1] = {XLP_9XX_NET1_VC_BASE, XLP_9XX_NET1_VC_LIMIT},
+[XLP_MSG_HANDLE_ALE]   = {XLP_9XX_ALE_VC_BASE,  XLP_9XX_ALE_VC_LIMIT},
+[XLP_MSG_HANDLE_POPQ]   = {XLP_9XX_POPQ_VC_BASE,  XLP_9XX_POPQ_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_9XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_9XX_INVALID_STATION, 0},
+};
+
+extern struct nlm_node_config nlm_node_cfg;
+
+/* #define FMN_DEBUG 1 */
+
+static unsigned int fmn_cfg_value[XLP_NET_VC_LIMIT + 1];
+static unsigned int fmn_default_credits = XLP_FMN_DEFAULT_CREDITS;
+static unsigned int fmn_default_qsize = XLP_FMN_DEFAULT_QUEUE_SIZE;
+static unsigned long long fmn_spill_mem_addr = XLP_FMNQ_SPILL_DEFAULT_MEM_ADDR;
+static unsigned long long fmn_spill_mem_size = XLP_FMNQ_SPILL_DEFAULT_MEM_SIZE;
+
+
+static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP_MSG_BLK_MAX] = {
+	[XLP_MSG_BLK_CPU] =     { "cpu",    XLP_CPU0_VC_BASE,      XLP_CPU7_VC_LIMIT,      8, 1 },
+	[XLP_MSG_BLK_POPQ] =    { "popq",   XLP_POPQ_VC_BASE,      XLP_POPQ_VC_LIMIT,      0, 1 },
+        [XLP_MSG_BLK_PCIE0] =    { "pcie0",   XLP_PCIE0_VC_BASE,     XLP_PCIE0_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE1] =    { "pcie1",   XLP_PCIE1_VC_BASE,     XLP_PCIE1_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE2] =    { "pcie2",   XLP_PCIE2_VC_BASE,     XLP_PCIE2_VC_LIMIT,     1, 1 },
+        [XLP_MSG_BLK_PCIE3] =    { "pcie3",   XLP_PCIE3_VC_BASE,     XLP_PCIE3_VC_LIMIT,     1, 1 },
+	[XLP_MSG_BLK_GDX]  =    { "gdx",    XLP_GDX_VC_BASE,       XLP_GDX_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_GDX1]  =    { "gdx1", XLP_9XX_GDX1_VC_BASE, XLP_9XX_GDX1_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_RSA_ECC] = { "rsa",    XLP_RSA_ECC_VC_BASE,   XLP_RSA_ECC_VC_LIMIT,   1, 1 },
+	[XLP_MSG_BLK_CRYPTO] =  { "crypto", XLP_CRYPTO_VC_BASE,    XLP_CRYPTO_VC_LIMIT,    1, 1 },
+	[XLP_MSG_BLK_CMP] =     { "cmp",    XLP_CMP_VC_BASE,       XLP_CMP_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_POE] =     { "poe",    XLP_POE_VC_BASE,       XLP_POE_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_NAE] =     { "nae",    XLP_NET_VC_BASE,       XLP_NET_VC_LIMIT,       1, 1 },
+	[XLP_MSG_BLK_REGX] =    { "regx",   XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT, 1, 1 },
+	[XLP_MSG_BLK_SRIO] =    { "srio",   XLP_3XX_SRIO_VC_BASE,  XLP_3XX_SRIO_VC_LIMIT,  1, 1 },
+	[XLP_MSG_BLK_LZS] =    { "lzs",   XLP_9XX_LZS_VC_BASE,  XLP_9XX_LZS_VC_LIMIT,  1, 1 },
+};
+
+int station_exist_in_2xx(int qid)
+{
+	int hndl;
+	nlm_fmn_config_t *fmn_config = &xlp2xx_fmn_config[0];
+	for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+		if((qid >= fmn_config[hndl].base_vc) && (qid <= fmn_config[hndl].vc_limit))
+			return 1;
+
+	}
+	/* check for popq. 
+	TODO : We should add this also in to the array 
+	 */
+	if(qid >= 128 && qid <= 159)
+		return 1;
+
+	return 0;
+}
+
+/* called based on the chip type */
+static void fmn_modify_qsize_credit_config(int node, int blk, int ntxstns, int b_stid, int e_stid)
+{
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	if(ntxstns >= 0)
+		fmn_q_config[blk].n_txstns = ntxstns;
+	if(b_stid >= 0)
+		fmn_q_config[blk].b_stid = b_stid;
+	if(e_stid >= 0)
+		fmn_q_config[blk].e_stid = e_stid;
+}
+
+static void fmn_invalidate_blocks(int node, int blk)
+{
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	fmn_q_config[blk].valid = 0;
+}
+
+
+static void fmn_invalidate_block_on_allnodes(int block)
+{
+	int node;
+
+	for(node=0; node < nlm_node_cfg.num_nodes; node++)
+		fmn_invalidate_blocks(node, block); 
+}
+
+static void update_fmn_config(void)
+{
+	uint32_t pid, epid, config;
+
+	pid = get_proc_id();
+
+	switch(pid) {
+                case CHIP_PROCESSOR_ID_XLP_8_4_XX:
+			fmn_invalidate_block_on_allnodes(XLP_MSG_BLK_REGX);
+			fmn_invalidate_block_on_allnodes(XLP_MSG_BLK_SRIO);
+                        break;
+		case CHIP_PROCESSOR_ID_XLP_3XX:
+			xlp3xx_fmn_config[XLP_MSG_HANDLE_CMP].base_vc = XLP_INVALID_STATION;
+			fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CMP);
+			epid = get_xlp3xx_epid();
+			switch(epid) {
+				case CPU_EXTPID_XLP_202a:
+				case CPU_EXTPID_XLP_201a:
+				case CPU_EXTPID_XLP_101a:
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_RSA_ECC].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_CRYPTO].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_SRIO].base_vc = XLP_INVALID_STATION;
+					xlp3xx_fmn_config[XLP_MSG_HANDLE_REGX].base_vc = XLP_INVALID_STATION;
+
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_RSA_ECC);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CRYPTO);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_SRIO);
+					fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_REGX);
+					break;
+			}
+			break;
+		case CHIP_PROCESSOR_ID_XLP_2XX:
+			xlp2xx_fmn_config[XLP_MSG_HANDLE_SRIO].base_vc =  XLP_INVALID_STATION;
+			fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_SRIO);
+			
+			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG2)));
+			nlm_print("XLP2xx Efuse config 2 0x%x\n",config);
+
+			if (config & (1 << XLP2XX_RSA_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_RSA_ECC].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_RSA_ECC);
+			}
+
+			if (config & (1 << XLP2XX_REGX_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_REGX].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_REGX);
+			}
+
+			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
+			nlm_print("XLP2xx Efuse config 1 0x%x\n",config);
+
+			if (config & (1 << XLP2XX_CMP_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_CMP].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CMP);
+			}
+
+			if (config & (1 << XLP2XX_CRYPTO_BLOCK_INDEX)) {
+				xlp2xx_fmn_config[XLP_MSG_HANDLE_CRYPTO].base_vc = XLP_INVALID_STATION;
+				fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_CRYPTO);
+			}
+			break;
+	}
+}
+
+#if 0
+static void fmn_qsize_credit_cfg_extract(void *fdt)
+{
+	char path[128];
+	const void *pval;
+	int s_stn = 0, d_stn = 0, nodeoffset, plen, len = 0;
+	unsigned int qsize = XLP_FMN_DEFAULT_QUEUE_SIZE;
+	unsigned int credits = XLP_FMN_DEFAULT_CREDITS;
+
+	/* initialize with the default values, given the config file */
+	if(fdt) {
+		strcpy(path, "/fmn-config");
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset >= 0)  {
+			pval = fdt_getprop(fdt, nodeoffset, "default-queue-size", &plen);
+			if(pval != NULL) {
+				qsize = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_default_qsize = qsize;
+			}
+			pval = fdt_getprop(fdt, nodeoffset, "default-credits", &plen);
+			if(pval != NULL) {
+				credits = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_default_credits = credits;
+			}
+		}
+
+		strcpy(path, "/extra-mem-config");
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset >= 0)  {
+			pval = fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-range", &plen);
+			if(pval != NULL) {
+				fmn_spill_mem_addr = fdt64_to_cpu(*(unsigned long long *)pval);
+				fmn_spill_mem_size = fdt64_to_cpu(*((unsigned long long *)pval + 1));
+			}
+		}
+	}
+
+	nlm_print("FMN Default queuesize %d credtis %d\n", qsize, credits);
+	nlm_print("FMN Spill mem addr %lx mem size %lx\n", 
+					(long)fmn_spill_mem_addr, (long)fmn_spill_mem_size);
+
+	/* credits from this source station(s_stn) to the destination station(d_stn) */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		fmn_qsize_credit_cfg[s_stn].q_size = qsize;
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++)
+			fmn_qsize_credit_cfg[s_stn].credits[d_stn] = credits;
+	}
+
+	if(!fdt)
+		return;
+	
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		len = sprintf(&path[0], "%s", "/fmn-config/");
+		sprintf(&path[len], "%s", fmn_qsize_credit_cfg[s_stn].q_name);
+		nodeoffset = fdt_path_offset(fdt, path);
+		if(nodeoffset < 0) 
+			continue;
+
+		/* get queue size for this station */
+		pval = fdt_getprop(fdt, nodeoffset, "queue-size", &plen);
+		if(pval != NULL) {
+			qsize = fdt32_to_cpu(*(unsigned int *)pval);
+			fmn_qsize_credit_cfg[s_stn].q_size = qsize;
+		}
+
+		/* get credits from this station to other stations */
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+			pval = fdt_getprop(fdt, nodeoffset, fmn_qsize_credit_cfg[d_stn].q_name, &plen);
+			if (pval != NULL) {
+				credits = fdt32_to_cpu(*(unsigned int *)pval);
+				fmn_qsize_credit_cfg[s_stn].credits[d_stn] = credits;
+				/*nlm_print(" dst stn name %s credits %d\n", 
+						fmn_qsize_credit_cfg[d_stn].q_name, credits);*/
+			}
+		}
+	}
+	
+#ifdef FMN_DEBUG
+	/* dump the table */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		len = 0;
+		nlm_print("name %s bstid %d estid %d ntxstns %d qsize %d\n",
+				fmn_qsize_credit_cfg[s_stn].q_name, fmn_qsize_credit_cfg[s_stn].b_stid,
+				fmn_qsize_credit_cfg[s_stn].e_stid, fmn_qsize_credit_cfg[s_stn].n_txstns,
+				fmn_qsize_credit_cfg[s_stn].q_size);
+		nlm_print("  credits ");
+		for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++)
+			nlm_print("<%s:%d> ",   fmn_qsize_credit_cfg[d_stn].q_name,
+					 fmn_qsize_credit_cfg[s_stn].credits[d_stn]);
+		nlm_print("\n");
+	}
+#endif
+}
+#endif
+
+static void fmn_update_credit(int node, int b_stid, int dst_node)
+{
+	unsigned int *credits = NULL;
+	int s_stn, d_stn, sid;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	/* configure with the default */
+	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
+		fmn_cfg_value[sid] = nlm_node_cfg.fmn_cfg[node]->fmn_default_credits;
+
+	/* Get credit config from the given source station to different destination station */
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		if(!fmn_q_config[s_stn].valid)
+			continue;
+		if(b_stid >=  fmn_q_config[s_stn].b_stid && 
+				b_stid <= fmn_q_config[s_stn].e_stid) {
+			credits = fmn_q_config[s_stn].credits[dst_node];
+			break;
+		}
+	}
+	if(credits == NULL) {
+		nlm_print("ERROR in Credit config: Station id not found, configuring default credit\n");
+#ifdef FMN_DEBUG
+		nlm_print("b_stid %d, dst_node %d.\n", b_stid, dst_node);
+#endif
+		return;
+	}
+
+	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+/*		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]); */
+		if(!fmn_q_config[d_stn].valid)
+			continue;
+		for(sid = fmn_q_config[d_stn].b_stid; sid <= fmn_q_config[d_stn].e_stid; sid++)
+			fmn_cfg_value[sid] = credits[d_stn];
+	}
+
+	return;
+}
+
+static int fmn_update_qsize(int node)
+{
+	int sid, s_stn;
+	unsigned long long qsize;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	
+	/* qsize cannot be more than 256KB and it should be aligned to 4K */
+	if((fmn_default_qsize % FMN_Q_PAGE_SIZE) != 0)
+		fmn_default_qsize = (fmn_default_qsize + FMN_Q_PAGE_SIZE - 1) & (~(FMN_Q_PAGE_SIZE - 1));
+
+	if(fmn_default_qsize > FMN_MAX_Q_SIZE) {
+		nlm_print("ERROR: Default FMN Q size exceeds the limit\n");
+		return -1;
+	}
+	
+	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
+		fmn_cfg_value[sid] = fmn_default_qsize;
+
+	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+		if(!fmn_q_config[s_stn].valid)
+			continue;
+		for(sid = fmn_q_config[s_stn].b_stid; sid <= fmn_q_config[s_stn].e_stid; sid++) {
+			qsize = fmn_q_config[s_stn].q_size;
+			if(qsize > FMN_MAX_Q_SIZE) {
+				nlm_print("ERROR: FMN Q size for stn %d exceeds the limit\n", s_stn);
+				return -1;
+			}
+			if((qsize % FMN_Q_PAGE_SIZE) != 0)
+				qsize = (qsize + FMN_Q_PAGE_SIZE - 1) & (~(FMN_Q_PAGE_SIZE - 1));
+			fmn_cfg_value[sid] = qsize;
+		}
+	}
+	return 0;
+}
+
+
+static void fmn_validate_credit(int node, int max_nodes)
+{
+	unsigned int credits, qsize, reqd_size;
+	unsigned int s_stn, d_stn, src_node;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+
+	
+	/* credits from all the source stations to this station */
+	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+		if(!fmn_q_config[d_stn].valid)
+			continue;
+		qsize = fmn_q_config[d_stn].q_size;
+		credits = 0;
+	        for(src_node = 0; src_node < max_nodes; src_node++) {
+  		    for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++)  {
+		 	if(!fmn_q_config[s_stn].valid)
+				continue;
+			credits += (fmn_q_config[s_stn].credits[src_node][d_stn] * fmn_q_config[s_stn].n_txstns);
+                    }
+		}
+
+		/* considering single entry message only */
+		reqd_size = credits * DEFAULT_SINGLE_ENTRY_MSG_SZ;
+		if(is_nlm_xlp9xx()) {
+			reqd_size = credits * XLP9XX_SINGLE_ENTRY_MSG_SZ;
+		}
+
+#ifdef FMN_DEBUG
+                nlm_print("Credits check dst stn %s, reqd %d cfgrd %d\n",
+                                        fmn_q_config[d_stn].q_name, reqd_size, qsize);
+#endif
+
+		if(reqd_size >= qsize)
+			nlm_print("WARN ... Credits overflow.. dst stn %s, reqd %d cfgd %d\n",
+					fmn_q_config[d_stn].q_name, reqd_size, qsize);
+	}
+}
+
+/* 1024-bit bitmask as 16 64-bit longs.
+ * '1' => station @ that bit position
+ * is disabled.
+ */
+unsigned long long stids[16];
+
+/*********************************************************************
+ * nlm_hal_enable_vc_intr
+ *
+ * In xlp, there are 4 VC per cpu. Each vc can be configured to generate
+ * an interrupt when message receive event happens.
+ ********************************************************************/
+void nlm_hal_enable_vc_intr(int node, int vc)
+{
+	uint64_t val = 0;
+	if (is_nlm_xlp9xx()) {
+		val =  (0ULL << 7) | (0x2ULL << 5) | (0x0ULL << 2) | (0x1ULL << 0);
+		//*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = val;
+		nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 13) + (vc << 3), val);
+	} else {
+		val = nlm_hal_read_outq_config(node, vc);
+		val &= ~((0x7ULL<<56) | (0x3ULL<<54) | (0x7ULL<<51) | (0x3ULL<<49));
+		val |=  (0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49);
+		nlm_hal_write_outq_config(node, vc, val);
+	}
+}
+
+/*********************************************************************
+ * nlm_hal_disable_vc_intr
+*********************************************************************/
+void nlm_hal_disable_vc_intr(int node, int vc)
+{
+	uint64_t val = 0;
+	if (is_nlm_xlp9xx()) {
+		//*(uint64_t *)(xlp_fmn_base[node] + (1 << 13) + (vc << 3)) = 0x0;
+		nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 13) + (vc << 3), 0);
+	} else {
+		val = nlm_hal_read_outq_config(node, vc);
+		val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
+		nlm_hal_write_outq_config(node, vc, val);
+	}
+}
+
+/*********************************************************************
+ * nlm_hal_set_fmn_interrupt
+ *
+ * setup cp2 msgconfig register for fmn interrup vector as 6
+ *
+ ********************************************************************/
+void nlm_hal_set_fmn_interrupt(int irq)
+{
+	uint32_t val;
+	/* Need write interrupt vector to cp2 msgconfig register */
+
+	val =  _read_32bit_cp2_register(XLP_MSG_CONFIG_REG);
+	val &= ~(0x1f << 16);
+	val |= (irq << 16);
+
+	/* Enable VC Interrupt for all 4 VC's */
+	if (is_nlm_xlp2xx() || is_nlm_xlp9xx())
+		val |= (0xf << 22);
+
+	_write_32bit_cp2_register(XLP_MSG_CONFIG_REG, val);
+
+}
+
+static __inline__ void nlm_hal_write_credit(int node, uint64_t src, uint64_t dst, uint64_t credits)
+{
+	uint64_t regaddr = nlh_qid_to_virt_addr(node, XLP_CREDIT_CONFIG_REG, 0); 
+	uint64_t value = (((src) & 0x3ff) | (((dst) & 0xfff) << 12) | (((credits) & 0xffff) << 24));
+
+	nlh_write_cfg_reg64(regaddr, value);
+}
+
+/* Clear a particular bit within the
+ * 1024 bitmaks array stids.
+ * Note: not a generic routine.
+ */
+static void clearbit(int bitnum) {
+
+	int index = bitnum / 64;
+	stids[index] &= ~(1ULL << (bitnum % 64));
+}
+
+void enable_interface(int interface, short value) {
+
+	switch (interface) {
+		case CPU: {
+				int i, nCore;
+				nCore = 8-bitcount(value);
+				for (i=0; i < nCore; i++) clearbit(i << 4);
+			} break;
+		case PCIE: {
+				int i;
+				for (i=0; i<4; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_PCIE0 + (i << 1));		
+				}
+			} break;
+		case GDX: {
+				if (value == 0)
+					clearbit(XLP_STNID_GDX);		
+			} break;
+		case CMP: {
+				int i;
+#ifndef NLM_XLP_3XX
+				for (i=0; i<4; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_CMP + i);		
+				}
+#endif
+			} break;
+		case CRYPTO: {
+				int i;
+				for (i=0; i<12; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_CRYPTO + i);		
+				}
+			} break;
+		case POE: {
+				if (value == 0)
+					clearbit(XLP_STNID_POE);		
+			} break;
+		case NAE: {
+				if (value == 0)
+					clearbit(XLP_STNID_NAE_TX);		
+			} break;
+		case RSA: {
+				int i;
+				for (i=0; i<9; i++) {
+					if ((value  & (1 << i)) == 0)
+						clearbit(XLP_STNID_RSA_ECC + i);		
+				}
+			} break;
+		default:
+			nlm_print("Error! Configuring Credits for Unknown Interface.\n");
+			break;
+	}
+}
+	
+/* Based on the (un)set bits from the EFUSE CFG Regs,
+ * create a bitmask representing 0-1023 station IDs
+ * which can then be used to check whether to send
+ * credits to or not. This is a one-time operation.
+ */
+void stids_toskip(int node) {
+
+	int i;
+
+        if(is_nlm_xlp2xx()) {
+		nlm_print("xlp2xx: please update %s\n", __FUNCTION__);
+		return;
+	}
+
+	for (i=0; i<16; i++)
+		stids[i] = ~0ULL;	/* init to all disabled */
+	
+	enable_interface(CPU,     nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG0) & 0xff);
+	enable_interface(PCIE,   (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 3) & 0xf);
+	enable_interface(GDX,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 8) & 0x1);
+	enable_interface(CMP,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 9) & 0xf);
+	enable_interface(CRYPTO, (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 14) & 0xfff);
+	enable_interface(POE,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 27) & 0x1);
+	enable_interface(NAE,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 28) & 0x1);
+	enable_interface(RSA,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG2)) & 0x1ff);
+}
+
+static int  fmn_9xx_is_vc_valid(int node, unsigned int base_vc)
+{
+	volatile uint32_t * fuse = xlp9xx_cpu_io_mmio(node, (6<<15) | (1<<12) );
+	uint32_t cfg6 = fuse[0xc6]; //FUSE_DEVICECFG6
+	uint32_t nCore = 20 - bitcount(cfg6);
+
+	if( base_vc == XLP_9XX_INVALID_STATION ) return 0;
+	if( XLP_9XX_PCIE0_VC_BASE <= base_vc   ) return 1;
+	if( base_vc < (XLP_CPU0_VC_LIMIT - XLP_CPU0_VC_BASE + 1)*nCore ) return 1; //core enabled
+
+	return 0;
+}
+
+
+static void nlm_hal_write_fmn_credit(int node, int max_nodes) 
+{
+	int src, qid, hndl = 0, dst_node;
+	nlm_fmn_config_t *fmn_config = NULL;
+	volatile int index;
+	uint32_t credits, cfgrd;
+
+	if (is_nlm_xlp9xx()) {
+		/* XLP9XX / XLP7XX */
+		nlm_print(" XLP9XX/XLP7XX FMN credit configuration \n");
+		
+		/* 9xx does not have SRIO engine */
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+
+		fmn_config = &xlp9xx_fmn_config[0];
+
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 20, XLP_CPU0_VC_BASE, XLP_CPU19_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_GDX, 1, XLP_9XX_GDX0_VC_BASE, XLP_9XX_GDX0_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_REGX, 1, XLP_9XX_RGX_VC_BASE, XLP_9XX_RGX_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CMP, 1, XLP_9XX_CMP_VC_BASE, XLP_9XX_CMP_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_9XX_RSA_VC_BASE, XLP_9XX_RSA_VC_LIMIT);
+		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_9XX_SEC_VC_BASE, XLP_9XX_SEC_VC_LIMIT);
+
+
+		/* go through each valid station */
+		for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+			int base_vc = fmn_config->base_vc;
+			if ( fmn_9xx_is_vc_valid(node, base_vc) )
+			{
+				int station;
+
+				/* configure credits from this base station to all other appropriate VC's */
+				for(dst_node = 0 ;dst_node < max_nodes; dst_node++) {
+					fmn_update_credit(node, base_vc, dst_node);
+
+					/* go through all valid stations and all valid vc's */
+					for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
+						qid = xlp9xx_fmn_config[station].base_vc;
+						if ( fmn_9xx_is_vc_valid(node, qid) == 0 ) continue;
+
+						for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+							/* FIXME: define/config fmn_cfg_value properly for XLP9XX */
+#if 1
+							credits = fmn_cfg_value[qid] - 1;
+#else
+							credits = 50;
+#endif
+							nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 14),
+								(0ULL << 42) /* type, credit value + 1 */
+								| (credits << 26) /* credit count */
+								| ((qid | (dst_node << 10)) << 13) /* destination */
+								| (base_vc | (node << 10)) ); /* source */
+				#if 0
+							*(uint64_t *)(xlp_fmn_base[0] + (1 << 14)) =
+								(0ULL << 42) /* type, credit value + 1 */
+								| (credits << 26) /* credit count */
+								| ((qid | (dst_node << 10)) << 13) /* destination */
+								| (base_vc | (node << 10)); /* source */
+				#endif
+						}
+					}
+				}
+			}
+			fmn_config++;
+		}
+	} else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		nlm_print(" XLP3XX/XLP2XX FMN configuration \n");
+		if(is_nlm_xlp316()){
+			nlm_print(" XLP316 FMN configuration \n");
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 4, XLP_CPU0_VC_BASE, XLP_CPU3_VC_LIMIT);
+		}
+		else if(is_nlm_xlp312()){
+			nlm_print(" XLP312 FMN configuration \n");
+			fmn_config = &xlp3xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU3;
+			for(hndl = 0; hndl<1; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 3, XLP_CPU0_VC_BASE, XLP_CPU2_VC_LIMIT);
+		}
+		else if(is_nlm_xlp308() || is_nlm_xlp208()){
+			nlm_print(" XLP308/208 FMN configuration \n");
+			fmn_config = (is_nlm_xlp308())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU2;
+			for(hndl = 0; hndl<2; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 2, XLP_CPU0_VC_BASE, XLP_CPU1_VC_LIMIT);
+
+		}
+		else if(is_nlm_xlp304() || is_nlm_xlp204()){
+			nlm_print(" XLP304/204 FMN configuration \n");
+			fmn_config = (is_nlm_xlp304())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU1;
+			for(hndl = 0; hndl<3; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 1, XLP_CPU0_VC_BASE, XLP_CPU0_VC_LIMIT);
+		}
+		else { }
+
+		if (is_nlm_xlp3xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_3XX_NET_VC_BASE, XLP_3XX_NET_VC_LIMIT);
+		}
+		else if (is_nlm_xlp2xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_2XX_NET_VC_BASE, XLP_2XX_NET_VC_LIMIT);
+		}
+			
+		if (is_nlm_xlp3xx_ax() == 0)
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_SRIO, 1, XLP_3XX_SRIO_VC_BASE, XLP_3XX_B0_SRIO_VC_LIMIT);
+
+		/* 3xx does not have compression engine */
+		if(is_nlm_xlp3xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_CMP);
+
+		/* 2xx does not have SRIO engine */
+		if(is_nlm_xlp2xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+
+		fmn_config = (is_nlm_xlp3xx())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
+                for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+                        if (fmn_config->base_vc != XLP_INVALID_STATION) {
+				fmn_update_credit(node, fmn_config->base_vc, node);		
+				credits = 0;
+                                for (qid = 0; qid <= XLP_3XX_NET_VC_LIMIT; qid++) {
+#ifdef FMN_DEBUG
+					if(credits != fmn_cfg_value[qid]) {
+						nlm_print("base %d qid %d credits %d\n", 
+							fmn_config->base_vc, qid, fmn_cfg_value[qid]);
+					}
+#endif
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((fmn_config->base_vc >= XLP_STNID_CPU0) && (fmn_config->base_vc <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, cfgrd);	
+                                }
+                        }
+                        fmn_config++;
+                }
+        }
+	else {
+	/* this populates the global array 'stids' 
+	 * with a '1' representing a disabled station ID.
+	 */
+		stids_toskip(node);
+
+		for (src = 0; src <= XLP_STNID_NAE_TX; src++) {
+			/* check if bitposition src == 1 in 
+			 * the dst_skip_bitmask. if so, continue
+			 */
+			index = src / 64;
+
+			if ((stids[index] >> (src % 64)) & 0x1) {
+				continue;
+			}
+
+			/* only enabled stations will reach here
+			 */
+
+			for(dst_node = 0 ;dst_node < max_nodes; dst_node++) {
+				fmn_update_credit(node, src, dst_node);
+				credits = 0;
+				for (qid = 0; qid < 1024; qid++) {
+#ifdef FMN_DEBUG
+					if(credits != fmn_cfg_value[qid]) {
+						nlm_print("src%d@%d node %d qid %d credits %d\n", 
+							src, node, dst_node, qid, fmn_cfg_value[qid]);
+					}
+#endif
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((src >= XLP_STNID_CPU0) && (src <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), cfgrd);	
+				}
+			}
+		}
+	}
+
+	/* Validae the credit config */
+	fmn_validate_credit(node, max_nodes);
+}
+/*********************************************************************
+ * nlm_hal_fmn_init
+ *
+ * setup 1024 outq, set credit from cpu to io,  io to io, and io to
+ * cpu
+ ********************************************************************/
+#if defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT) || defined(NLM_HAL_NETOS)
+
+#define OUT_Q_INIT	0
+
+#else
+
+#define OUT_Q_INIT	((0x2ULL<<54) | (0x1ULL<<49))
+
+#endif
+/*********************************************************************
+ * nlm_hal_setup_outq
+ *
+ * In xlp, there is 1024 receive message queues for fmn network. The
+ * queue, allocated to cpu and high speed IO device, identified by
+ * their vc number. When A send B a FMN message, receive VC is dest
+ * number A need addressing. This function is to config each queue with
+ * initial defaule value
+ *
+ * Total spill size for each Q is 16KB
+ * This allows for 1024 q entries with 16B of entry size
+ * This assumes credits across all sending agents to this queue is < 1024
+ *
+ * For xlp9xx, the total capacity of output buffer is 64K entry. Each output queue
+ * can be sized from 32 entry to 2048 entry in increments of 32 entry. So
+ * index[15:0] is to identified a particular entry.
+ *
+ * For xlp9xx, each node has 1024 output queues, total 8 nodes.
+ * So globally addressable qid's are 1024 * 8.
+ ********************************************************************/
+int nlm_hal_setup_outq(int node, int max_nodes)
+{
+	uint32_t qid, max_qs = 0;
+	uint64_t val;
+
+	uint64_t spill_base = nlm_node_cfg.fmn_cfg[node]->fmn_spill_base; /*fmn_spill_mem_addr; */
+	uint32_t spill_size = nlm_node_cfg.fmn_cfg[node]->fmn_spill_size;
+	uint64_t q_spill_start_page = 0, q_spill_pages;
+
+	const uint32_t ram_base = 0;
+	uint32_t q_ram_base = 0;
+	uint32_t q_ram_start_page = 0, q_ram_end_page = 0;
+	const int q_ram_pages = 1;
+	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
+	const uint32_t q_ram_page_entries_9xx = 64; /* entries, not bytes */
+	int cnt =0;
+
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		max_qs = XLP_3XX_NET_VC_LIMIT;
+	}
+	else {
+		max_qs = XLP_NET_VC_LIMIT;
+	}
+
+        nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_base = nlm_node_cfg.fmn_cfg[node]->q_ram_base_cur = q_ram_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_page_perq = 1;
+
+	if(fmn_update_qsize(node) < 0)
+		return -1;
+
+	if (is_nlm_xlp9xx()) {
+		int station;
+
+		/* XLP9XX / XLP7XX */
+		nlm_print(" XLP9XX/XLP7XX FMN output queue configuration \n");
+
+		for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
+			qid = xlp9xx_fmn_config[station].base_vc;
+			if ( fmn_9xx_is_vc_valid(node, qid) == 0 ) continue;
+
+			for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+				/* enable output queue and setup on-chip output queue */
+				val = 1ULL << 63; /* enable */
+
+				/* here, we are assuming that each page
+				   has 32 entries.  Hence, each outq is configured
+				   for 2 pages (or 64 entries) */
+
+				if((q_ram_start_page+ 2) > q_ram_page_entries_9xx) {
+					q_ram_base++;
+					q_ram_start_page = 0;
+				}
+				q_ram_end_page = q_ram_start_page +1;
+
+				val |= (q_ram_base & 0x1f) <<12; /* [16:12] of q_ram_base */
+				val |= (q_ram_end_page & 0x3f)<<6; /* [11:6] of q_ram_base */
+				val |= (q_ram_start_page & 0x3f);  /* [5:0] of q_ram_base */
+
+#ifdef FMN_DEBUG
+				nlm_print("qid: %d, q_ram_base: %d, q_ram_start_page: %d, q_ram_end_page: %d.\n",
+						qid, (q_ram_base & 0x1f),
+						(q_ram_start_page & 0x3f),
+						(q_ram_end_page & 0x3f));
+#endif
+
+				q_ram_start_page = q_ram_end_page +1;
+
+
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+				/* spills, maximum spill per VC: 64 * 4KB = 256KB,
+				 * In our configuration, each VC: 4KB
+				 */
+				if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+
+				val |= 1ULL << 62; /* enable spill */
+
+				/* carve the total fmn_spill area into all 32 VC's here */
+				q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
+				/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as
+				   only 17-12 bits only considered for spill last */
+				if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
+					spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
+
+				val |= ( ((spill_base >> 18) & 0x3fffff) << 29); /* [39:18] of q_spill_base */
+
+				q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
+				val |= (q_spill_start_page << 17);
+				val |= ( (q_spill_start_page + q_spill_pages - 1) << 23);
+
+#ifdef FMN_DEBUG
+				nlm_print("qid %d sb: %lx ss: %lx sl: %lx sqsize %d sqpages %d\n",
+					qid, ((val >> 29) & 0x3fffff), ((val >> 17) & 0x3f), ((val >> 23) & 0x3f),
+					fmn_cfg_value[qid], (int)q_spill_pages);
+#endif
+				spill_base +=  fmn_cfg_value[qid];
+
+				}
+#endif
+
+				/* configure */
+				nlh_write_cfg_reg64(xlp_fmn_base[node] + (qid << 3), val);
+
+				/* disable interrupt by default, interrupt will be
+				 * enabled by respective OS configuration if needed.
+				 */
+				nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 13) + (qid << 3), 0);
+			}
+		}
+	} else {
+		for( qid = 0; qid <= max_qs; qid++ )
+		{
+			/* Enable all output queues and spill on all queues.
+			   Disable spill for u-boot as the spill memory will be enabled by the os
+			   loading time with the specified address */
+#if defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT)
+			val = OUTQ_EN;
+#else
+			val = OUTQ_EN;
+			if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL)
+				val |= SPILL_EN;
+#endif
+
+			/* Enable interrupts for cpu Queues */
+			if ( (qid >= 0) && (qid < 128))
+				val |= OUT_Q_INIT ;
+
+			/*val |= INT_EN|(0ULL<<56)|(0x2ULL<<54)|(0x0ULL<<51)|(0x1ULL<<49); */
+
+			/***************************************************************
+			 * Configuration of on-chip RAM area
+			 **************************************************************
+			 */
+			/* As 2xx has only 8k onchip memory skip all the invalid stations */
+			if(is_nlm_xlp2xx()) {
+				if(!station_exist_in_2xx(qid))
+					continue;
+				q_ram_base = ram_base + (cnt * q_ram_pages * q_ram_page_entries);
+				cnt++;
+			} else
+				q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
+
+			val |= ( ((q_ram_base >> 10) & 0x1f) << 10); /* [14:10] of q_ram_base */
+
+			q_ram_start_page = (q_ram_base >> 5) & 0x1f; /* [9:5] of q_ram_base */
+			val |= (q_ram_start_page << 0);
+			val |= ( (q_ram_start_page + q_ram_pages - 1) << 5) ;
+
+			if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+
+				/***************************************************************
+				 * Configuration of spill area
+				 **************************************************************
+				 */
+				/* pages in 4K units */
+				q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
+
+				/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as
+				   only 17-12 bits only considered for spill last */
+				if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
+					spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
+
+				val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
+
+				q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
+				val |= (q_spill_start_page << 15);
+				val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
+
+#ifdef FMN_DEBUG
+				nlm_print("Fmn q config %d sqbase %lx sqsize %d sqpages %d\n",
+						qid, (long)spill_base, fmn_cfg_value[qid], (int)q_spill_pages);
+#endif
+
+				spill_base +=  fmn_cfg_value[qid];
+			}
+
+			/* Write to the configuration register */
+			nlm_hal_write_outq_config(node, qid, val);
+		}
+	}
+
+        nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
+        nlm_node_cfg.fmn_cfg[node]->q_ram_base_cur = q_ram_base;
+ 
+        nlm_print("spill_base_cur 0x%llx qram_base_cur 0x%llx \n",(unsigned long long)spill_base,(unsigned long long) q_ram_base);
+
+/*	if((spill_base - fmn_spill_mem_addr) > fmn_spill_mem_size) { */
+	if ((spill_base - nlm_node_cfg.fmn_cfg[node]->fmn_spill_base) > spill_size) {
+		nlm_print("ERROR:  FMN Q total size exceeds the limit\n");
+		return -1;
+	}
+	return 0;
+}
+
+int parse_queue_config(void *fdt, int max_nodes)
+{
+        int node = 0, src_node, s_stn, d_stn;
+        char fmn_cfg_str[80];
+        char prop_str[10];
+        int plen, nodeoffset;
+        uint32_t *pval;
+	struct fmn_qsize_credit_config *fmn_q_config;
+	uint32_t credits, qsize;
+
+        for(node = 0 ;  node < max_nodes; node++) {
+                fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+                for(d_stn=0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+
+                        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[d_stn].q_name);
+                        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                        if(nodeoffset < 0)
+                                continue;
+	                /* get queue size for this station */
+        	        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "queue-size", &plen);
+                	if(pval != NULL) {
+                        	qsize = fdt32_to_cpu(*(unsigned int *)pval);
+	                        fmn_q_config[d_stn].q_size = qsize;
+        	        }
+
+                        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s/credits-from", node, fmn_q_config[d_stn].q_name);
+                        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                        if(nodeoffset < 0)
+                                continue;
+
+                	/* get credits from this station to other stations */
+
+                        for(src_node = 0; src_node < max_nodes; src_node++) {
+                                sprintf(prop_str, "node-%d", src_node);
+                                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, prop_str, &plen);
+                                if(pval != NULL) {
+                                        if ((plen / sizeof(uint32_t)) != XLP_MSG_BLK_MAX) {
+                                                nlm_print("Invalid credit configuration in fdt \n");
+                                                while(1); 
+                                        }
+                                        for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                                credits = fdt32_to_cpu(*(unsigned int *)(pval + s_stn));
+						if (credits != 0)
+							nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn] = credits;
+#ifdef FMN_DEBUG
+                                                nlm_print("node %d station %s has %d credits to %d:Q %s\n", src_node, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].q_name, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn], node, fmn_q_config[d_stn].q_name);
+#endif
+                                        }
+
+                                }
+                        }
+                }
+        }
+	return 0;
+}
+
+
+int parse_fdt_fmn_config(void *fdt)
+{
+	char fmn_cfg_str[50];
+	int nodeoffset = 0, plen, max_nodes = 1, node = 0;
+  	uint32_t *pval;
+	struct fmn_cfg *fmn_config;
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+	uint64_t spill_base = 0ULL;
+#endif
+	uint32_t qsize, credits, src_node, s_stn, d_stn;
+
+	sprintf(fmn_cfg_str,"/soc/nodes");
+	nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset >= 0) {
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "num-nodes", &plen);
+		if(pval != NULL) {
+			max_nodes = fdt32_to_cpu(*(unsigned int *)pval);
+		}
+	}
+
+	nlm_print("Number of nodes %d \n",max_nodes);
+
+	nlm_node_cfg.num_nodes = max_nodes;
+	
+	for(node = 0; node < max_nodes; node++) {
+		nlm_node_cfg.fmn_cfg[node] = nlm_malloc(sizeof(struct fmn_cfg));
+		if (nlm_node_cfg.fmn_cfg[node] == NULL) {
+			nlm_print("nlm_malloc failed for node %d\n", node);
+			return -1;
+		}
+		memset(nlm_node_cfg.fmn_cfg[node], 0, sizeof(struct fmn_cfg));
+		nlm_node_cfg.fmn_cfg[node]->fmn_default_credits = fmn_default_credits/max_nodes;
+		nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize = fmn_default_qsize;
+		if (node == 0) {
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = fmn_spill_mem_addr;
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = fmn_spill_mem_size;
+		}
+		else {
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = 0ULL;
+			nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = 0ULL;
+		}
+		
+		sprintf(fmn_cfg_str,"/soc/fmn@node-%d",node);
+                nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+                if(nodeoffset < 0) {
+                        nlm_print("No 'fmn@node-%d' param in dtb \n",node);
+			nlm_print("node %d default qsize %d credits %d\n",node, nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize, nlm_node_cfg.fmn_cfg[node]->fmn_default_credits);
+	                memcpy(nlm_node_cfg.fmn_cfg[node]->fmn_q_config, fmn_qsize_credit_cfg, sizeof(fmn_qsize_credit_cfg));
+                        continue;
+                }
+
+#if !defined(NLM_HAL_UBOOT) && !defined(NLM_HAL_NETLBOOT)
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-size", &plen);
+                if(pval != NULL) {
+                        nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = fdt64_to_cpu(*(unsigned long long *)pval) ;
+		}
+
+		pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "fmn-spill-mem-base", &plen);
+		if(pval != NULL) {
+			spill_base = fdt64_to_cpu(*(unsigned long long *)pval);
+			if (spill_base != 0ULL) {
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = spill_base;
+			}
+		}
+#ifdef NLM_HAL_LINUX_KERNEL
+		if ((pval == NULL) || (spill_base == 0ULL)){
+			spill_base = nlm_spill_alloc(node, (nlm_node_cfg.fmn_cfg[node]->fmn_spill_size));
+			if (spill_base == 0ULL) {
+				nlm_print("Node %d FMN spill_mem alloc failed \n", node);
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = 0;
+			}
+			else
+				nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = spill_base;
+		}
+#endif
+#endif
+		nlm_print("spillsize 0x%llx @ 0x%016llx \n", (unsigned long long)nlm_node_cfg.fmn_cfg[node]->fmn_spill_size,(unsigned long long)nlm_node_cfg.fmn_cfg[node]->fmn_spill_base);
+
+
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "default-queue-size", &plen);
+                if (pval != NULL) {
+                        qsize = fdt32_to_cpu(*(unsigned int *)pval);
+                        nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize = qsize;
+                }
+
+                pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, "default-credits", &plen);
+                if (pval != NULL) {
+                        credits = fdt32_to_cpu(*(unsigned int *)pval);
+                        nlm_node_cfg.fmn_cfg[node]->fmn_default_credits = credits / max_nodes;
+                }
+
+		nlm_print("node %d default qsize %d credits %d\n",node, nlm_node_cfg.fmn_cfg[node]->fmn_default_qsize, nlm_node_cfg.fmn_cfg[node]->fmn_default_credits);
+                memcpy(nlm_node_cfg.fmn_cfg[node]->fmn_q_config, fmn_qsize_credit_cfg, sizeof(fmn_qsize_credit_cfg));
+	}
+
+        for(node=0; node < max_nodes; node++) {
+                fmn_config = nlm_node_cfg.fmn_cfg[node];
+                for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+                        fmn_config->fmn_q_config[d_stn].q_size = fmn_config->fmn_default_qsize;
+                        for(src_node=0; src_node < max_nodes; src_node++) {
+                                for(s_stn=0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                        fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn] = fmn_config->fmn_default_credits;
+#ifdef FMN_DEBUG
+                                        nlm_print("%d:%s Q, credits given to node %d stn %s : %d\n", node, fmn_config->fmn_q_config[d_stn].q_name, src_node, fmn_config->fmn_q_config[s_stn].q_name, fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn]);
+#endif
+                                }
+                        }
+                }
+        }
+
+	parse_queue_config(fdt, max_nodes);
+
+	return max_nodes;
+}
+
+int get_dom_fmn_node_ownership(void *fdt, int dom_id)
+{
+	uint32_t owner_mask;
+
+	owner_mask = get_dom_owner_mask(fdt, dom_id, "fmn");
+
+	return owner_mask;
+}
+
+/**
+* @brief nlm_hal_fmn_init function Initializes FMN (outpu Queues and Credit registers)
+*
+* @param [in]  spill_base    :Physical address where the spill base starts
+* @param [in]  size          :Size of the spill/fill region in bytes
+* @param [in]  credits       :Number of credits from any src to any dst. 
+*
+* @return
+*  - Returns no value.
+*
+* @note
+*    1. This funysconfig/dts/fmn-temp.dtstion must be the first to be called before any FMN HAL API's.
+* @n
+*    2. This function is typically called twice (once from U-boot and once from OS). This is due to
+*       Netlogic's SDK convention that only 1 cpu is running while in U-boot and potentially more than 
+*       one cpu running while in OS and also the requirement that Credit configuration can only
+*       happen after the cpu is out of reset.
+* @n
+*    3. The credits between any source and any destination is chosen to be same for simplification.
+* 
+* @ingroup hal_fmn
+*
+*/
+void nlm_hal_fmn_init(void *fdt, int node)
+{
+	int max_nodes;
+
+	nlm_print("*** Firmware Configuration of FMN ***\n");
+
+	max_nodes = parse_fdt_fmn_config(fdt);
+
+	update_fmn_config();
+
+	if (max_nodes < 0) {
+		nlm_print("FMN Configuration failed\n");
+		while(1);
+	}
+
+	if(!is_nlm_xlp2xx() && !is_nlm_xlp9xx()) {
+		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
+	}
+
+	/*fmn_qsize_credit_cfg_extract(fdt); */
+	/* verify out_q config 
+	 */
+	if(nlm_hal_setup_outq(node, max_nodes) < 0)
+		while(1);
+	nlm_hal_write_fmn_credit(node, max_nodes);
+}
+
+#ifdef NLM_HAL_LINUX_KERNEL 
+#include <linux/types.h>
+#include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_disable_vc_intr);
+EXPORT_SYMBOL(nlm_hal_enable_vc_intr);
+EXPORT_SYMBOL(nlm_hal_fmn_init);
+EXPORT_SYMBOL(nlm_hal_set_fmn_interrupt);
+EXPORT_SYMBOL(get_dom_fmn_node_ownership);
+#endif
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
new file mode 100644
index 0000000..6f4560a
--- /dev/null
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_dp.h
@@ -0,0 +1,1188 @@
+
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * or the Broadcom license below:
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_4# */
+
+
+#ifndef _NLH_FMN_DP_H
+#define _NLH_FMN_DP_H
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#ifndef __ASSEMBLY__
+
+/*Cop2 Regs */
+#define XLP_TX_BUF_REG          $0
+#define XLP_RX_BUF_REG          $1
+#define XLP_MSG_TXSTATUS_REG    $2
+#define XLP_MSG_RXSTATUS_REG    $3
+#define XLP_MSG_STATUS1_REG     $4
+#define XLP_MSG_CONFIG_REG      $5
+#define XLP_MSG_CONFIG1_REG     $6
+#define XLP_MSG_INT_REG         $8
+
+
+#define _read_32bit_cp2_register(source)                        \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define _write_32bit_cp2_register(register,value)               \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define _read_32bit_cp2_register_sel(source, sel)               \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+        ".set\tpop"                                             \
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_32bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+        ".set\tpop"                                             \
+        : : "r" (value), "i" (sel) );
+
+
+#ifndef _ABI64
+
+#define _read_64bit_cp2_register_sel(source, sel)                        \
+({                                                                      \
+        unsigned int high, low;                                         \
+                                                                        \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dmfc2\t$8, "STR(source)","STR(sel)"\n\t"       \
+                        "dsrl32\t%0, $8, 0\n\t"                         \
+                        "dsll32\t$8, $8, 0\n\t"                         \
+                        "dsrl32\t%1, $8, 0\n\t"                         \
+                        ".set\tmips0"                                   \
+                        : "=r" (high), "=r"(low): "i"(sel) : "$8");     \
+        ( (((unsigned long long)high)<<32) | low);                      \
+})
+
+#define _write_64bit_cp2_register_sel(source, val, sel)                 \
+do {                                                                    \
+     unsigned int high = val>>32;                                       \
+     unsigned int low  = val & 0xffffffff;                              \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dsll32 $8, %1, 0\n"                            \
+                        "dsll32 $9, %0, 0\n"                            \
+                        "dsrl32 $8, $8, 0\n"                            \
+                        "or     $8, $8, $9\n"                           \
+                        "dmtc2\t$8, "STR(source)", %2\n\t"              \
+                        ".set\tmips0"                                   \
+                        : : "r" (high), "r" (low), "i"(sel): "$8", "$9");               \
+} while (0)
+
+#else /* _ABI64 */
+
+#define _read_64bit_cp2_register_sel(source, sel)               \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmfc2\t%0,"STR(source)", %1\n\t"                       \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_64bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmtc2\t%0,"STR(reg)", %1\n\t"                          \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#endif /* _ABI64 */
+
+
+#define xlp_read_tx_status() _read_32bit_cp2_register(XLP_MSG_TXSTATUS_REG)
+#define xlp_read_rx_status() _read_32bit_cp2_register(XLP_MSG_RXSTATUS_REG)
+#define xlp_read_rx_status2() _read_32bit_cp2_register_sel(XLP_MSG_RXSTATUS_REG, 1)
+
+#define xlp_read_status1()   _read_32bit_cp2_register(XLP_MSG_STATUS1_REG)
+#define xlp_write_status1(value)   _write_32bit_cp2_register(XLP_MSG_STATUS1_REG, value)
+
+#define xlp_read_config()       _read_32bit_cp2_register(XLP_MSG_CONFIG_REG)
+#define xlp_write_config(value) _write_32bit_cp2_register(XLP_MSG_CONFIG_REG, value)
+
+#define xlp_read_msg_ecc_status()  _read_32bit_cp2_register(XLP_MSG_ECC_STATUS)
+#define xlp_write_msg_ecc_status() _write_32bit_cp2_register(XLP_MSG_ECC_STATUS, value)
+
+#define xlp_read_msg_ecc_config()  _read_32bit_cp2_register_sel(XLP_MSG_ECC_STATUS, 1)
+#define xlp_write_msg_ecc_config() _write_32bit_cp2_register_sel(XLP_MSG_ECC_STATUS, value, 1)
+
+#define xlp_read_msg_int()	_read_32bit_cp2_register(XLP_MSG_INT_REG)
+#define xlp_write_msg_int(value)	_write_32bit_cp2_register(XLP_MSG_INT_REG, value)
+
+#define xlp_read_oq_credit_status() _read_64bit_cp2_register_sel(XLP_MSG_Q_CNT_STATUS, 0)
+#define xlp_read_iq_credit_status() _read_64bit_cp2_register_sel(XLP_MSG_Q_CNT_STATUS, 1)
+
+#define xlp_load_rx_msg0() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 0)
+#define xlp_load_rx_msg1() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 1)
+#define xlp_load_rx_msg2() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 2)
+#define xlp_load_rx_msg3() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 3)
+
+#define xlp_load_tx_msg0(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 0)
+#define xlp_load_tx_msg1(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 1)
+#define xlp_load_tx_msg2(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 2)
+#define xlp_load_tx_msg3(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 3)
+
+/*
+ *  Messaging Operations 
+ */
+/**
+* @brief xlp_send function is used to send any configured message to a destination, used by the HAL send message API's for different number of messages. Performs a sync before sending.
+*
+* @param [in]  dest 		:Destination Message Queue number
+*
+* @return
+*  - "1" on  send success, "0" on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_send(unsigned int dest)
+{
+        unsigned int success = 0;
+
+        __asm__ volatile (".set push\n"
+                          ".set noreorder\n"
+                          ".set arch=xlp\n"
+                          "sync\n"
+                          "msgsnds %0, %1\n"
+                          ".set pop\n"
+                          : "=&r" (success)
+                          : "r" (dest));
+
+        return success;
+}
+
+/* */
+/**
+* @brief xlp_message_wait function is a non-blocking API used to wait for the first message to come to a mailbox. 
+*
+* @param [in]  mask 		:bitmask of the 4 VC's of the CPU, for which queues to monitor for a message
+*
+* @return
+*  - none
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline void xlp_message_wait(unsigned int mask)
+{
+    __asm__ volatile(".set push\n"
+            ".set noreorder\n"
+            " msgwait %0\n"
+            ".set pop\n"::"r" (mask)
+            );
+}
+
+/* */
+/*
+   XLP API
+   RT[63 : 32] - Reserved
+   RT[31 : 24] - Software Code
+   RT[23 : 21] - Reserved
+   RT[20 : 19] - Pop Message Source VC no.
+   RT[18 : 18] - Reserved
+   RT[17 : 16] - Message Size-1
+   RT[15 : 12] - Reserved
+   RT[11 : 0]  - Message Destination ID
+ */
+/* message send API NON blocking for single entry message*/
+/**
+* @brief xlp_message_send_1 function is a non-blocking API used to send a single entry message to a mailbox. Will retry the message send 16 times. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  data 		:64b data value for the single message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_1(uint32_t dst, 
+				     uint32_t  code, uint64_t data)
+{
+  unsigned int dest = 0;
+  int retry = 16;
+
+  xlp_load_tx_msg0(data);
+
+  dest = ((code << 24) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx> to dest = %x\n", 
+	  data, dest);
+#endif
+
+  while(retry--){
+	if(xlp_send(dest))
+		return 0;
+  }
+  return xlp_read_tx_status();
+
+}
+/* message send API NON blocking for double entry message*/
+/**
+* @brief xlp_message_send_2 function is a non-blocking API used to send a two entry message to a mailbox. Will retry the message send 16 times. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  data0 		:64b data value for the first message
+* @param [in]  data1 		:64b data value for the second message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_2(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1)
+{
+  unsigned int dest = 0;
+  int retry = 16;
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+
+  dest = ((code << 24) | (1 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx> to dest = %x\n", 
+	  data0, data1, dest);
+#endif
+  while(retry--){
+	if(xlp_send(dest))
+		return 0;
+  }
+  return xlp_read_tx_status();
+}
+
+/* message send API NON blocking for double entry message*/
+/**
+* @brief xlp_message_send_3 function is a non-blocking API used to send a three entry message to a mailbox. Does not retry the send message. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  data0 		:64b data value for the first message
+* @param [in]  data1 		:64b data value for the second message
+* @param [in]  data2 		:64b data value for the third message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_3(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1,
+				     uint64_t data2)
+{
+  unsigned int dest = 0;
+
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+  xlp_load_tx_msg2(data2);
+
+  dest = ((code << 24) | (2 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx, %llx> to dest = %x\n", 
+	  data0, data1, data2, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+
+  return 0;
+}
+
+
+/* message send API NON blocking for double entry message*/
+/**
+* @brief xlp_message_send_4 function is a non-blocking API used to send a three entry message to a mailbox. Does not retry the send message. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  data0 		:64b data value for the first message
+* @param [in]  data1 		:64b data value for the second message
+* @param [in]  data2 		:64b data value for the third message
+* @param [in]  data3 		:64b data value for the fourth message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_4(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1,
+				     uint64_t data2, uint64_t data3)
+{
+  unsigned int dest = 0;
+
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+  xlp_load_tx_msg2(data2);
+  xlp_load_tx_msg3(data3);
+
+  dest = ((code << 24) | (3 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx, %llx, %llx> to dest = %x\n", 
+	  data0, data1, data2, data3, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+
+  return 0;
+}
+
+/* Generic message send API NON blocking */
+/**
+* @brief xlp_message_send function is a non-blocking API for sending a one to four entry message to a mailbox.  Does not retry the send message. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  size		:Number of messages to transmit (1 to 4)
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  *data 		:uint64_t array of data[0] to data[3] representing each 64b message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send(uint32_t dst, 
+				   uint32_t size,  uint32_t  code,
+				   uint64_t *data)
+{
+  unsigned int dest = 0;
+
+    switch (size)
+    {
+      case 4:
+		  xlp_load_tx_msg3(data[3]);
+
+      case 3:
+		  xlp_load_tx_msg2(data[2]);
+
+      case 2:
+		  xlp_load_tx_msg1(data[1]);
+          
+      default:
+		  xlp_load_tx_msg0(data[0]);
+    }
+
+  dest = ((code << 24) | ((size - 1) << 16) | dst);
+ 
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+  return 0;
+}
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI32)
+static inline void xlp_message_send_block_fast_1(unsigned int code,
+						 unsigned int dest_vc,
+						 unsigned long long msg0)
+{
+	unsigned int high = msg0>>32;
+	unsigned int low = msg0 & 0xffffffff;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dsll32 $9, %3, 0\n"
+			"dsll32 $10, %2, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 0\n"
+			/* "dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n" */
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) |  dest_vc), /* %0 */
+			  "r"(msg0),
+			  "r" (high), "r" (low) /* %2, %3 */
+			: "$8", "$9", "$10"
+			);
+}
+
+static inline void xlp_message_send_block_fast_2(unsigned int code,
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1)
+{
+	unsigned int high0 = msg0>>32;
+	unsigned int low0 = msg0 & 0xffffffff;
+	unsigned int high1 = msg1>>32;
+	unsigned int low1 = msg1 & 0xffffffff;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dsll32 $9, %4, 0\n"
+			"dsll32 $10, %3, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 0\n"
+			"sync\n"
+			/* "dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n" */
+			"dsll32 $9, %6, 0\n"
+			"dsll32 $10, %5, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 1\n"
+			"sync\n"
+			/* "dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n" */
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (1 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1),
+			  "r"(high0), "r"(low0), /* %3, %4 */
+			  "r"(high1), "r"(low1)  /* %5, %6 */
+			: "$8", "$9", "$10"
+			);
+}
+
+static inline void xlp_message_send_block_fast_3(unsigned int code,
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1,
+						 unsigned long long msg2)
+{
+	unsigned int high0 = msg0>>32;
+	unsigned int low0 = msg0 & 0xffffffff;
+	unsigned int high1 = msg1>>32;
+	unsigned int low1 = msg1 & 0xffffffff;
+	unsigned int high2 = msg2>>32;
+	unsigned int low2 = msg2 & 0xffffffff;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dsll32 $9, %5, 0\n"
+			"dsll32 $10, %4, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 0\n"
+			"sync\n"
+			/* "dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n" */
+			"dsll32 $9, %7, 0\n"
+			"dsll32 $10,%6, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 1\n"
+			"sync\n"
+			/* "dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n" */
+			"dsll32 $9, %9, 0\n"
+			"dsll32 $10,%8, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2  $9, "STR(XLP_TX_BUF_REG)", 2\n"
+			"sync\n"
+			/* "dmtc2 %3, "STR(XLP_TX_BUF_REG)", 2\n" */
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (2 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1), "r" (msg2),
+			  "r"(high0), "r"(low0), /* %4, %5 */
+			  "r"(high1), "r"(low1), /* %6, %7 */
+			  "r"(high2), "r"(low2)  /* %8, %9 */
+			: "$8", "$9", "$10"
+			);
+}
+
+static inline void xlp_message_send_block_fast(int size, unsigned int code,
+					       unsigned int dest_vc,
+					       unsigned long long msg0,
+					       unsigned long long msg1,
+					       unsigned long long msg2,
+					       unsigned long long msg3)
+{
+	unsigned int high0 = msg0>>32;
+	unsigned int low0 = msg0 & 0xffffffff;
+	unsigned int high1 = msg1>>32;
+	unsigned int low1 = msg1 & 0xffffffff;
+	unsigned int high2 = msg2>>32;
+	unsigned int low2 = msg2 & 0xffffffff;
+	unsigned int high3 = msg3>>32;
+	unsigned int low3 = msg3 & 0xffffffff;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dsll32 $9, %6, 0\n"
+			"dsll32 $10, %5, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2 $9, " STR(XLP_TX_BUF_REG) ", 0\n"
+			"sync\n"
+			/* "dmtc2 %1, " STR(XLP_TX_BUF_REG) ", 0\n" */
+			"dsll32 $9, %8, 0\n"
+			"dsll32 $10, %7, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2 $9, " STR(XLP_TX_BUF_REG) ", 1\n"
+			"sync\n"
+			/* "dmtc2 %2, " STR(XLP_TX_BUF_REG) ", 1\n" */
+			"dsll32 $9, %10, 0\n"
+			"dsll32 $10, %9, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2 $9, " STR(XLP_TX_BUF_REG) ", 2\n"
+			"sync\n"
+			/* "dmtc2 %3, " STR(XLP_TX_BUF_REG) ", 2\n" */
+			"dsll32 $9, %12, 0\n"
+			"dsll32 $10, %11, 0\n"
+			"dsrl32 $9, $9, 0\n"
+			"or     $9, $9, $10\n"
+			"dmtc2 $9, " STR(XLP_TX_BUF_REG) ", 3\n"
+			"sync\n"
+			/* "dmtc2 %4, " STR(XLP_TX_BUF_REG) ", 3\n" */
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"::
+			"r"((code << 24) | ((size-1) << 16) | dest_vc), /* %0 */
+			"r"(msg0), "r"(msg1),
+			"r"(msg2), "r"(msg3),
+			"r"(high0), "r"(low0), /* %5, %6 */
+			"r"(high1), "r"(low1), /* %7, %8 */
+			"r"(high2), "r"(low2), /* %9, %10 */
+			"r"(high3), "r"(low3)  /* %11, %12 */
+			:"$8", "$9", "$10");
+}
+
+#else
+
+/* API to send a 1 entry message to "stid" with given "code" */
+/**
+* @brief xlp_message_send_block_fast_1 function is a blocking API for sending a one entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
+*
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  dest_vc		:Destination Message Queue number
+* @param [in]  msg0 		:64b data value for the first message
+*
+* @return
+*  - none
+* 
+* @ingroup hal_fmn
+*
+*/
+
+static inline void xlp_message_send_block_fast_1(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) |  dest_vc), /* %0 */
+			  "r"(msg0) 
+			: "$8"
+			);
+}
+
+/* */
+/* API to send a 2 entry message to "stid" with given "code" */
+/**
+* @brief xlp_message_send_block_fast_2 function is a blocking API for sending a two entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
+*
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  dest_vc		:Destination Message Queue number
+* @param [in]  msg0 		:64b data value for the first message
+* @param [in]  msg1 		:64b data value for the second message
+*
+* @return
+*  - none
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline void xlp_message_send_block_fast_2(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (1 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1) 
+			: "$8"
+			);
+}
+/* API to send a 3 entry message to "stid" with given "code" */
+/**
+* @brief xlp_message_send_block_fast_3 function is a blocking API for sending a three entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
+*
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  dest_vc		:Destination Message Queue number
+* @param [in]  msg0 		:64b data value for the first message
+* @param [in]  msg1 		:64b data value for the second message
+* @param [in]  msg2 		:64b data value for the third message
+*
+* @return
+*  - none
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline void xlp_message_send_block_fast_3(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1,
+						 unsigned long long msg2)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
+			"dmtc2 %3, "STR(XLP_TX_BUF_REG)", 2\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (2 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1), "r" (msg2)
+			: "$8"
+			);
+}
+
+/* */
+/**
+* @brief xlp_message_send_block_fast_3 function is a blocking API for sending a four entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
+*
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  dest_vc		:Destination Message Queue number
+* @param [in]  msg0 		:64b data value for the first message
+* @param [in]  msg1 		:64b data value for the second message
+* @param [in]  msg2 		:64b data value for the third message
+* @param [in]  msg3 		:64b data value for the fourth message
+*
+* @return
+*  - none
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline void xlp_message_send_block_fast(int size, unsigned int code,
+					       unsigned int dest_vc,
+					       unsigned long long msg0,
+					       unsigned long long msg1,
+					       unsigned long long msg2,
+					       unsigned long long msg3)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, " STR(XLP_TX_BUF_REG) ", 0\n"
+			"dmtc2 %2, " STR(XLP_TX_BUF_REG) ", 1\n"
+			"dmtc2 %3, " STR(XLP_TX_BUF_REG) ", 2\n"
+			"dmtc2 %4, " STR(XLP_TX_BUF_REG) ", 3\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"::
+			"r"((code << 24) | ((size-1) << 16) | dest_vc), /* %0 */
+			"r"(msg0), "r"(msg1),
+			"r"(msg2), "r"(msg3)
+			:"$8");
+}
+
+#endif
+
+/* */
+/**
+* @brief xlp_receive function is used to receive message from a mailbox vc, used by the HAL receive message API's for different number of messages
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+*
+* @return
+*  - "1" on load success, "0" on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_receive(unsigned int vc)
+{
+	unsigned int success = 0;
+
+	__asm__ volatile (".set push\n"
+	                  ".set noreorder\n"
+	                  ".set arch=xlp\n"
+	                  "msglds %0, %1\n"
+	                  ".set pop\n"
+	                  : "=&r" (success)
+	                  : "r" (vc));
+
+	return success;
+}
+
+/* */
+/**
+* @brief xlp_message_receive_1 function is used to receive a single entry message from a VC of the CPU. Size should be used to determine how other 64b messages were available with data.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages returned (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the received message
+*
+* @return
+*  - "0" on receive success, "-1" on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_1(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code,	uint64_t *msg0)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	return 0;
+}
+/**
+* @brief xlp_message_receive_2 function is used to receive a single entry message from a VC of the CPU. Size should be used to determine how many of msg0-msg1 have valid data and if there were more messages available.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages that were in this received message (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the first received message
+* @param [out]  msg1 		:64b data value for the second received message
+*
+* @return
+*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_2(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	return (status & 0x3);
+}
+
+/**
+* @brief xlp_message_receive_3 function is used to receive three entry message from a VC of the CPU. Size should be used to determine how many of msg0-msg2 have valid data and if there were more messages available.
+*
+* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id          :Source Message Queue Number
+* @param [out]  size            :# of messages that were in this received message (1 to 4)
+* @param [out]  code            :8b SW code of the received message
+* @param [out]  msg0            :64b data value for the first received message
+* @param [out]  msg1            :64b data value for the second received message
+* @param [out]  msg2            :64b data value for the third received message
+*
+* @return
+*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_3(uint32_t vc, uint32_t *src_id,
+        uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1, uint64_t *msg2)
+{
+        unsigned int status;
+
+        if (!xlp_receive(vc))
+                return -1;
+
+        status = xlp_read_rx_status();
+        *size = ((status >> 26) & 0x3) + 1;
+        *code = (status >> 18) & 0xff;
+        *src_id = (status >> 4) & 0xfff;
+        *msg0 = xlp_load_rx_msg0();
+        *msg1 = xlp_load_rx_msg1();
+        *msg2 = xlp_load_rx_msg2();
+        return (status & 0x3);
+}
+
+/* */
+/**
+* @brief xlp_message_receive function is used to receive a four entry message from a VC of the CPU.  Size should be used to determine how many of msg0-msg3 have valid data.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages that were in this received message (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the first received message
+* @param [out]  msg1 		:64b data value for the second received message
+* @param [out]  msg2 		:64b data value for the third received message
+* @param [out]  msg3 		:64b data value for the fourth received message
+*
+* @return
+*  - "0" on receive success, "-1" on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1,
+	uint64_t *msg2, uint64_t *msg3)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	*msg2 = xlp_load_rx_msg2();
+	*msg3 = xlp_load_rx_msg3();
+	return 0;
+}
+
+/*
+   Applications can use the fast path (inlined) APIs directly.
+   However, for other application which have historically used these APIs, the same
+   have been added for backward compatibility.
+   */
+
+#define nlm_hal_send_msg1(dst, code, data0) \
+	xlp_message_send_1(dst, code, data0)
+#define nlm_hal_send_msg2(dst, code, data0, data1) \
+	xlp_message_send_2(dst, code, data0, data1)
+#define nlm_hal_send_msg3(dst, code, data0, data1, data2) \
+	xlp_message_send_3(dst, code, data0, data1, data2)
+#define nlm_hal_send_msg4(dst, code, data0, data1, data2, data3) \
+	xlp_message_send_4(dst, code, data0, data1, data2, data3)
+
+#define nlm_hal_recv_msg1(dst, src, size, code, data0) \
+	xlp_message_receive_1(dst, src, size, code, data0)
+#define nlm_hal_recv_msg2(dst, src, size, code, data0, data1) \
+	xlp_message_receive_2(dst, src, size, code, data0, data1)
+#define nlm_hal_recv_msg3(dst, src, size, code, data0, data1, data2) \
+	xlp_message_receive_3(dst, src, size, code, data0, data1, data2)
+
+/**
+* @brief xlp_message_receive_gid_1 function is used to receive a single entry message from a VC of the CPU. It also reads the 8b guest ID. Size should be used to determine how other 64b messages were available with data.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages returned (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the received message
+* @param [out]  gid             :8b guest ID
+*
+* @return
+*  - "0" on receive success, "-1" on failure
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_gid_1(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code,	uint64_t *msg0, uint64_t *gid)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*gid = (xlp_read_rx_status2()) & 0xff;
+	return 0;
+}
+/**
+* @brief xlp_message_receive_gid_2 function is used to receive a single entry message from a VC of the CPU. It also reads the 8b guest ID. Size should be used to determine how many of msg0-msg1 have valid data and if there were more messages available.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages that were in this received message (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the first received message
+* @param [out]  msg1 		:64b data value for the second received message
+* @param [out]  gid             :8b guest ID
+*
+* @return
+*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_gid_2(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1, uint64_t *gid)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	*gid = (xlp_read_rx_status2()) & 0xff;
+	return (status & 0x3);
+}
+
+/**
+* @brief xlp_message_receive_gid_3 function is used to receive three entry message from a VC of the CPU. It also reads the 8b guest ID. Size should be used to determine how many of msg0-msg2 have valid data and if there were more messages available.
+*
+* @param [in]  vc               :VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id          :Source Message Queue Number
+* @param [out]  size            :# of messages that were in this received message (1 to 4)
+* @param [out]  code            :8b SW code of the received message
+* @param [out]  msg0            :64b data value for the first received message
+* @param [out]  msg1            :64b data value for the second received message
+* @param [out]  msg2            :64b data value for the third received message
+* @param [out]  gid             :8b guest ID
+*
+* @return
+*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_gid_3(uint32_t vc, uint32_t *src_id,
+        uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1, uint64_t *msg2,
+	uint64_t *gid)
+{
+        unsigned int status;
+
+        if (!xlp_receive(vc))
+                return -1;
+
+        status = xlp_read_rx_status();
+        *size = ((status >> 26) & 0x3) + 1;
+        *code = (status >> 18) & 0xff;
+        *src_id = (status >> 4) & 0xfff;
+        *msg0 = xlp_load_rx_msg0();
+        *msg1 = xlp_load_rx_msg1();
+        *msg2 = xlp_load_rx_msg2();
+	*gid = (xlp_read_rx_status2()) & 0xff;
+        return (status & 0x3);
+}
+
+/* */
+/**
+* @brief xlp_message_receive_gid function is used to receive a four entry message from a VC of the CPU.  It also reads the 8b guest ID. Size should be used to determine how many of msg0-msg3 have valid data.
+*
+* @param [in]  vc 		:VC mailbox of the CPU (1 to 4)
+* @param [out]  src_id		:Source Message Queue Number
+* @param [out]  size		:# of messages that were in this received message (1 to 4)
+* @param [out]  code		:8b SW code of the received message
+* @param [out]  msg0 		:64b data value for the first received message
+* @param [out]  msg1 		:64b data value for the second received message
+* @param [out]  msg2 		:64b data value for the third received message
+* @param [out]  msg3 		:64b data value for the fourth received message
+* @param [out]  gid             :8b guest ID
+*
+* @return
+*  - "0" on receive success, "-1" on failure
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_receive_gid(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1,
+	uint64_t *msg2, uint64_t *msg3, uint64_t *gid)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	*msg2 = xlp_load_rx_msg2();
+	*msg3 = xlp_load_rx_msg3();
+	*gid = (xlp_read_rx_status2()) & 0xff;
+	return 0;
+}
+
+/* */
+/* Generic Messaging API */
+/* */
+/**
+* @brief xlp_message_send_block function is a blocking API for sending a one to four entry message to a mailbox.  It will continuously retry the send message until successful. Performs a sync before sending.
+*
+* @param [in]  size		:# of 64b messages to be sent (1 to 4)
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  stid		:Destination Message Queue number
+* @param [in]  data0 		:64b data value for the first message
+* @param [in]  data1 		:64b data value for the second message, if size < 2 can be any value
+* @param [in]  data2 		:64b data value for the third message, if size < 3 can be any value
+* @param [in]  data3 		:64b data value for the fourth message, if size < 4 can be any value
+*
+* @return
+*  - none
+*
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_block(unsigned int size, unsigned int code,
+					 unsigned int stid, uint64_t data0, uint64_t data1,
+					 uint64_t data2, uint64_t data3)
+{
+    xlp_message_send_block_fast(size, code, stid, data0, data1, data2, data3);
+    return 0;
+}
+/* */
+
+#endif				/* __ASSEMBLY__ */
+
+#endif /* #ifndef _NLH_FMN_DP_H */
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_msgring.h b/arch/mips/netlogic/lib/fmnlib/nlm_msgring.h
new file mode 100644
index 0000000..3d94e70
--- /dev/null
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_msgring.h
@@ -0,0 +1,107 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ASM_NLM_MSG_RING_H
+#define _ASM_NLM_MSG_RING_H
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+
+#define msgrng_enable(flags) 
+#define msgrng_disable(flags) 
+
+#else
+
+#define msgrng_enable(flags)                \
+do {                                        \
+  preempt_disable(); \
+  __asm__ volatile (                        \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+  preempt_enable(); \
+} while (0)
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#endif
+
+#define msgrng_flags_save(flags) msgrng_enable(flags)
+#define msgrng_flags_restore(flags) msgrng_disable(flags)
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+
+#define msgrng_access_save(lock, iflags, mflags)
+#define msgrng_access_restore(lock, iflags, mflags)
+
+#define msgrng_access_enable(mflags) ((void)(mflags))
+#define msgrng_access_disable(mflags) ((void)(mflags))
+
+#else
+
+#define msgrng_access_save(lock, iflags, mflags) do {        \
+  spin_lock_irqsave(lock, iflags);                           \
+  msgrng_flags_save(mflags);                                 \
+ }while(0)
+
+#define msgrng_access_restore(lock, iflags, mflags) do {     \
+  msgrng_flags_restore(mflags);                              \
+  spin_unlock_irqrestore(lock, iflags);                      \
+ }while(0)
+
+#define msgrng_access_enable(mflags) do {   \
+  preempt_disable();                        \
+  msgrng_flags_save(mflags);                \
+} while(0)
+#define msgrng_access_disable(mflags) do {   \
+  msgrng_flags_restore(mflags);              \
+  preempt_enable();                          \
+} while(0)
+
+#endif
+
+#ifdef CONFIG_CPU_XLP
+extern int register_xlp_msgring_handler(int major,
+                             void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+                                             uint64_t, uint64_t, uint64_t, uint64_t, void *),
+                             void *dev_id);
+extern int unregister_xlp_msgring_handler(int, void *);
+#endif
+
+#endif
-- 
1.7.9.5

