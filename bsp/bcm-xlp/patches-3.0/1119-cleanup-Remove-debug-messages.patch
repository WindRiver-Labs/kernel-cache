From f7daacbada232534729d3f2f8b3e396f92e943ca Mon Sep 17 00:00:00 2001
From: "P. Sadik" <psadik@broadcom.com>
Date: Wed, 19 Feb 2014 20:22:28 +0530
Subject: [PATCH 119/160] cleanup: Remove debug messages.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c |  119 +++++++++-----------
 arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c   |   19 +---
 2 files changed, 61 insertions(+), 77 deletions(-)

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 9a32bd4..6882a87 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -6,7 +6,7 @@
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
  * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * http://www.gnu.org/licenses/gpl-2.0.txt
  * or the Broadcom license below:
 
  * Redistribution and use in source and binary forms, with or without
@@ -224,7 +224,7 @@ nlm_fmn_config_t xlp9xx_fmn_config[] = {
 
 extern struct nlm_node_config nlm_node_cfg;
 
-//#define FMN_DEBUG 1 
+//#define FMN_DEBUG 1
 static int max_msg_blks = XLP_MSG_BLK_MAX;
 
 static unsigned int fmn_cfg_value[XLP_NET_VC_LIMIT + 1];
@@ -287,7 +287,7 @@ static int get_onchip_qsize(void *fdt, int node, int station)
 		else {
 			if (onchip_qsize > XLP_FMN_ONCHIP_PERQ)
 				return -1;
-		}	
+		}
 		return onchip_qsize / 32;
 	}
  	return -1;
@@ -400,8 +400,8 @@ int station_exist_in_2xx(int qid)
 			return 1;
 
 	}
-	/* check for popq. 
-	TODO : We should add this also in to the array 
+	/* check for popq.
+	TODO : We should add this also in to the array
 	 */
 	if(qid >= 128 && qid <= 159)
 		return 1;
@@ -435,7 +435,7 @@ static void fmn_invalidate_block_on_allnodes(int block)
 	int node;
 
 	for(node=0; node < nlm_node_cfg.num_nodes; node++)
-		fmn_invalidate_blocks(node, block); 
+		fmn_invalidate_blocks(node, block);
 }
 
 static void update_fmn_config(void)
@@ -472,9 +472,8 @@ static void update_fmn_config(void)
 		case CHIP_PROCESSOR_ID_XLP_2XX:
 			xlp2xx_fmn_config[XLP_MSG_HANDLE_SRIO].base_vc =  XLP_INVALID_STATION;
 			fmn_invalidate_block_on_allnodes( XLP_MSG_BLK_SRIO);
-			
+
 			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG2)));
-			nlm_print("XLP2xx Efuse config 2 0x%x\n",config);
 
 			if (config & (1 << XLP2XX_RSA_BLOCK_INDEX)) {
 				xlp2xx_fmn_config[XLP_MSG_HANDLE_RSA_ECC].base_vc = XLP_INVALID_STATION;
@@ -487,7 +486,6 @@ static void update_fmn_config(void)
 			}
 
 			config = nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
-			nlm_print("XLP2xx Efuse config 1 0x%x\n",config);
 
 			if (config & (1 << XLP2XX_CMP_BLOCK_INDEX)) {
 				xlp2xx_fmn_config[XLP_MSG_HANDLE_CMP].base_vc = XLP_INVALID_STATION;
@@ -540,7 +538,7 @@ static void fmn_qsize_credit_cfg_extract(void *fdt)
 	}
 
 	nlm_print("FMN Default queuesize %d credtis %d\n", qsize, credits);
-	nlm_print("FMN Spill mem addr %lx mem size %lx\n", 
+	nlm_print("FMN Spill mem addr %lx mem size %lx\n",
 					(long)fmn_spill_mem_addr, (long)fmn_spill_mem_size);
 
 	/* credits from this source station(s_stn) to the destination station(d_stn) */
@@ -552,12 +550,12 @@ static void fmn_qsize_credit_cfg_extract(void *fdt)
 
 	if(!fdt)
 		return;
-	
+
 	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
 		len = sprintf(&path[0], "%s", "/fmn-config/");
 		sprintf(&path[len], "%s", fmn_qsize_credit_cfg[s_stn].q_name);
 		nodeoffset = fdt_path_offset(fdt, path);
-		if(nodeoffset < 0) 
+		if(nodeoffset < 0)
 			continue;
 
 		/* get queue size for this station */
@@ -573,12 +571,12 @@ static void fmn_qsize_credit_cfg_extract(void *fdt)
 			if (pval != NULL) {
 				credits = fdt32_to_cpu(*(unsigned int *)pval);
 				fmn_qsize_credit_cfg[s_stn].credits[d_stn] = credits;
-				/*nlm_print(" dst stn name %s credits %d\n", 
+				/*nlm_print(" dst stn name %s credits %d\n",
 						fmn_qsize_credit_cfg[d_stn].q_name, credits);*/
 			}
 		}
 	}
-	
+
 #ifdef FMN_DEBUG
 	/* dump the table */
 	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
@@ -611,13 +609,13 @@ static void fmn_update_credit(int node, int b_stid, int dst_node)
 	for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
 		if(!fmn_q_config[s_stn].valid)
 			continue;
-		
-		if(b_stid >=  fmn_q_config[s_stn].b_stid && 
+
+		if(b_stid >=  fmn_q_config[s_stn].b_stid &&
 				b_stid <= fmn_q_config[s_stn].e_stid) {
 			credits = fmn_q_config[s_stn].credits[dst_node];
 			break;
 		}
-	
+
 	}
 
 	if(credits == NULL) {
@@ -630,7 +628,7 @@ static void fmn_update_credit(int node, int b_stid, int dst_node)
 
 	for(d_stn = 0; d_stn < max_msg_blks; d_stn++) {
 #ifdef FMN_DEBUG
-		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]); 
+		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]);
 #endif
 		if(!fmn_q_config[d_stn].valid)
 			continue;
@@ -646,7 +644,7 @@ static int fmn_update_qsize(int node)
 	int sid, s_stn;
 	unsigned long long qsize;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
-	
+
 	/* qsize cannot be more than 256KB and it should be aligned to 4K */
 	if((fmn_default_qsize % FMN_Q_PAGE_SIZE) != 0)
 		fmn_default_qsize = (fmn_default_qsize + FMN_Q_PAGE_SIZE - 1) & (~(FMN_Q_PAGE_SIZE - 1));
@@ -655,7 +653,7 @@ static int fmn_update_qsize(int node)
 		nlm_print("ERROR: Default FMN Q size exceeds the limit\n");
 		return -1;
 	}
-	
+
 	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
 		fmn_cfg_value[sid] = fmn_default_qsize;
 
@@ -683,7 +681,7 @@ static void fmn_validate_credit(int node, int max_nodes)
 	unsigned int s_stn, d_stn, src_node;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
 
-	
+
 	/* credits from all the source stations to this station */
 	for(d_stn = 0; d_stn < max_msg_blks; d_stn++) {
 		if(!fmn_q_config[d_stn].valid)
@@ -778,7 +776,7 @@ int brcm_hal_config_popq_class(int node, int popq_class, uint8_t width, uint16_t
 {
 	uint64_t val = 0;
 	int offset = 0;
-	
+
 	if (is_nlm_xlp9xx()) {
 		if ((popq_class < 0) || (popq_class > POPQ_MAX_CLASS_NUM)) {
 			nlm_print("ERROR: popq class number out of range. \
@@ -825,7 +823,7 @@ void nlm_hal_set_fmn_interrupt(int irq)
 
 static __inline__ void nlm_hal_write_credit(int node, uint64_t src, uint64_t dst, uint64_t credits)
 {
-	uint64_t regaddr = nlh_qid_to_virt_addr(node, XLP_CREDIT_CONFIG_REG, 0); 
+	uint64_t regaddr = nlh_qid_to_virt_addr(node, XLP_CREDIT_CONFIG_REG, 0);
 	uint64_t value = (((src) & 0x3ff) | (((dst) & 0xfff) << 12) | (((credits) & 0xffff) << 24));
 
 	nlh_write_cfg_reg64(regaddr, value);
@@ -853,19 +851,19 @@ void enable_interface(int interface, short value) {
 				int i;
 				for (i=0; i<4; i++) {
 					if ((value  & (1 << i)) == 0)
-						clearbit(XLP_STNID_PCIE0 + (i << 1));		
+						clearbit(XLP_STNID_PCIE0 + (i << 1));
 				}
 			} break;
 		case GDX: {
 				if (value == 0)
-					clearbit(XLP_STNID_GDX);		
+					clearbit(XLP_STNID_GDX);
 			} break;
 		case CMP: {
 				int i;
 #ifndef NLM_XLP_3XX
 				for (i=0; i<4; i++) {
 					if ((value  & (1 << i)) == 0)
-						clearbit(XLP_STNID_CMP + i);		
+						clearbit(XLP_STNID_CMP + i);
 				}
 #endif
 			} break;
@@ -873,22 +871,22 @@ void enable_interface(int interface, short value) {
 				int i;
 				for (i=0; i<12; i++) {
 					if ((value  & (1 << i)) == 0)
-						clearbit(XLP_STNID_CRYPTO + i);		
+						clearbit(XLP_STNID_CRYPTO + i);
 				}
 			} break;
 		case POE: {
 				if (value == 0)
-					clearbit(XLP_STNID_POE);		
+					clearbit(XLP_STNID_POE);
 			} break;
 		case NAE: {
 				if (value == 0)
-					clearbit(XLP_STNID_NAE_TX);		
+					clearbit(XLP_STNID_NAE_TX);
 			} break;
 		case RSA: {
 				int i;
 				for (i=0; i<9; i++) {
 					if ((value  & (1 << i)) == 0)
-						clearbit(XLP_STNID_RSA_ECC + i);		
+						clearbit(XLP_STNID_RSA_ECC + i);
 				}
 			} break;
 		default:
@@ -896,7 +894,7 @@ void enable_interface(int interface, short value) {
 			break;
 	}
 }
-	
+
 /* Based on the (un)set bits from the EFUSE CFG Regs,
  * create a bitmask representing 0-1023 station IDs
  * which can then be used to check whether to send
@@ -913,7 +911,7 @@ void stids_toskip(int node) {
 
 	for (i=0; i<16; i++)
 		stids[i] = ~0ULL;	/* init to all disabled */
-	
+
 	enable_interface(CPU,     nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG0) & 0xff);
 	enable_interface(PCIE,   (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 3) & 0xf);
 	enable_interface(GDX,    (nlm_hal_read_sys_reg(node, EFUSE_DEVICE_CFG1) >> 8) & 0x1);
@@ -938,7 +936,7 @@ static int  fmn_9xx_is_vc_valid(int node, unsigned int base_vc)
 }
 
 
-static void nlm_hal_write_fmn_credit(int node, int max_nodes) 
+static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 {
 	int src, qid, hndl = 0, dst_node;
 	nlm_fmn_config_t *fmn_config = NULL;
@@ -994,7 +992,6 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 		}
 
 	} else if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
-		nlm_print(" XLP3XX/XLP2XX FMN configuration \n");
 		if(is_nlm_xlp316()){
 			nlm_print(" XLP316 FMN configuration \n");
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 4, XLP_CPU0_VC_BASE, XLP_CPU3_VC_LIMIT);
@@ -1046,7 +1043,7 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT);
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_2XX_NET_VC_BASE, XLP_2XX_NET_VC_LIMIT);
 		}
-			
+
 		if (is_nlm_xlp3xx_ax() == 0)
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_SRIO, 1, XLP_3XX_SRIO_VC_BASE, XLP_3XX_B0_SRIO_VC_LIMIT);
 
@@ -1061,12 +1058,12 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 		fmn_config = (is_nlm_xlp3xx())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
                 for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
                         if (fmn_config->base_vc != XLP_INVALID_STATION) {
-				fmn_update_credit(node, fmn_config->base_vc, node);		
+				fmn_update_credit(node, fmn_config->base_vc, node);
 				credits = 0;
                                 for (qid = 0; qid <= XLP_3XX_NET_VC_LIMIT; qid++) {
 #ifdef FMN_DEBUG
 					if(credits != fmn_cfg_value[qid]) {
-						nlm_print("base %d qid %d credits %d\n", 
+						nlm_print("base %d qid %d credits %d\n",
 							fmn_config->base_vc, qid, fmn_cfg_value[qid]);
 					}
 #endif
@@ -1074,20 +1071,20 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 					if ((fmn_config->base_vc >= XLP_STNID_CPU0) && (fmn_config->base_vc <= XLP_STNID_CPU7))
 						cfgrd = credits - 1;
 
-	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, cfgrd);	
+	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, cfgrd);
                                 }
                         }
                         fmn_config++;
                 }
         }
 	else {
-	/* this populates the global array 'stids' 
+	/* this populates the global array 'stids'
 	 * with a '1' representing a disabled station ID.
 	 */
 		stids_toskip(node);
 
 		for (src = 0; src <= XLP_STNID_NAE_TX; src++) {
-			/* check if bitposition src == 1 in 
+			/* check if bitposition src == 1 in
 			 * the dst_skip_bitmask. if so, continue
 			 */
 			index = src / 64;
@@ -1105,7 +1102,7 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 				for (qid = 0; qid < 1024; qid++) {
 #ifdef FMN_DEBUG
 					if(credits != fmn_cfg_value[qid]) {
-						nlm_print("src%d@%d node %d qid %d credits %d\n", 
+						nlm_print("src%d@%d node %d qid %d credits %d\n",
 							src, node, dst_node, qid, fmn_cfg_value[qid]);
 					}
 #endif
@@ -1113,7 +1110,7 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 					if ((src >= XLP_STNID_CPU0) && (src <= XLP_STNID_CPU7))
 						cfgrd = credits - 1;
 
-					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), cfgrd);	
+					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), cfgrd);
 				}
 			}
 		}
@@ -1175,7 +1172,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 	int cnt =0, oq_num32pages = 0, oq_num32pages_stn , num_valid_queues;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
 	int single_sae_vc = 0;
-	
+
 
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		max_qs = XLP_3XX_NET_VC_LIMIT;
@@ -1207,7 +1204,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 			oq_num32pages = get_onchip_qsize(fdt, node, station);
 			if (oq_num32pages < 0)
 				oq_num32pages = 1;
-				
+
 			nlm_print("station %d oq_num32pages %d  base %d limit %d\n",station, oq_num32pages, qid, fmn_q_config[station].e_stid);
 			oq_num32pages_stn = oq_num32pages;
 
@@ -1226,7 +1223,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
                                 }
                         }
 
-		
+
 			for (; qid <= fmn_q_config[station].e_stid; qid++) {
 				q_enable = 1ULL;
 				if (station == XLP_MSG_BLK_CPU) {
@@ -1238,7 +1235,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 						else {
 							oq_num32pages = 1;
 						}
-					}	
+					}
 				}
 				else if ((station == XLP_MSG_BLK_NAE) && (qid >= (XLP_9XX_NET0_TX_VC_BASE + num_valid_queues)) && (qid < XLP_9XX_NET0_RX_VC_BASE)) {
 					q_enable = 0ULL;
@@ -1274,7 +1271,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 					nlm_print("Invalid FMN onchip queue configuration \n");
 					return -1;
 				}
-					
+
 				q_ram_end_page = q_ram_start_page + oq_num32pages - 1;
 
 				val |= (q_ram_base & 0x1f) <<12; /* [16:12] of q_ram_base */
@@ -1413,7 +1410,7 @@ int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 
         nlm_node_cfg.fmn_cfg[node]->spill_base_cur = spill_base;
         nlm_node_cfg.fmn_cfg[node]->q_ram_base_cur = q_ram_base;
- 
+
         nlm_print("spill_base_cur 0x%llx qram_base_cur 0x%llx \n",(unsigned long long)spill_base,(unsigned long long) q_ram_base);
 
 /*	if((spill_base - fmn_spill_mem_addr) > fmn_spill_mem_size) { */
@@ -1457,7 +1454,7 @@ int parse_queue_config(void *fdt, int max_nodes)
                                 continue;
 			if (get_fmn_dts_version(fdt, node) != 0) {
 				for(src_node = 0; src_node < max_nodes; src_node++) {
-					sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s/credits-from/stn@node-%d", 
+					sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s/credits-from/stn@node-%d",
 						node, fmn_q_config[d_stn].q_name, src_node);
 					nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
         	        	        if(nodeoffset < 0)
@@ -1484,7 +1481,7 @@ int parse_queue_config(void *fdt, int max_nodes)
                                 if(pval != NULL) {
                                         if ((plen / sizeof(uint32_t)) != max_msg_blks) {
                                                 nlm_print("Invalid credit configuration in fdt \n");
-                                                while(1); 
+                                                while(1);
                                         }
                                         for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
                                                 credits = fdt32_to_cpu(*(unsigned int *)(pval + s_stn));
@@ -1516,7 +1513,7 @@ int parse_fdt_fmn_config(void *fdt)
 	uint32_t qsize, credits, src_node, s_stn, d_stn;
 	static int init_done = 0;
 
-	
+
 	sprintf(fmn_cfg_str,"/soc/nodes");
 	nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
         if(nodeoffset >= 0) {
@@ -1525,13 +1522,12 @@ int parse_fdt_fmn_config(void *fdt)
 			max_nodes = fdt32_to_cpu(*(unsigned int *)pval);
 		}
 	}
-	nlm_print("Number of nodes %d \n",max_nodes);
 
 	if(init_done)
 		return max_nodes;
 
 	nlm_node_cfg.num_nodes = max_nodes;
-	
+
 	for(node = 0; node < max_nodes; node++) {
 		nlm_node_cfg.fmn_cfg[node] = nlm_malloc(sizeof(struct fmn_cfg));
 		if (nlm_node_cfg.fmn_cfg[node] == NULL) {
@@ -1549,7 +1545,7 @@ int parse_fdt_fmn_config(void *fdt)
 			nlm_node_cfg.fmn_cfg[node]->fmn_spill_base = 0ULL;
 			nlm_node_cfg.fmn_cfg[node]->fmn_spill_size = 0ULL;
 		}
-		
+
 		sprintf(fmn_cfg_str,"/soc/fmn@node-%d",node);
                 nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
                 if(nodeoffset < 0) {
@@ -1638,7 +1634,7 @@ int get_dom_fmn_node_ownership(void *fdt, int dom_id)
 *
 * @param [in]  spill_base    :Physical address where the spill base starts
 * @param [in]  size          :Size of the spill/fill region in bytes
-* @param [in]  credits       :Number of credits from any src to any dst. 
+* @param [in]  credits       :Number of credits from any src to any dst.
 *
 * @return
 *  - Returns no value.
@@ -1647,12 +1643,12 @@ int get_dom_fmn_node_ownership(void *fdt, int dom_id)
 *    1. This funysconfig/dts/fmn-temp.dtstion must be the first to be called before any FMN HAL API's.
 * @n
 *    2. This function is typically called twice (once from U-boot and once from OS). This is due to
-*       Netlogic's SDK convention that only 1 cpu is running while in U-boot and potentially more than 
+*       Netlogic's SDK convention that only 1 cpu is running while in U-boot and potentially more than
 *       one cpu running while in OS and also the requirement that Credit configuration can only
 *       happen after the cpu is out of reset.
 * @n
 *    3. The credits between any source and any destination is chosen to be same for simplification.
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -1661,9 +1657,6 @@ void nlm_hal_fmn_init(void *fdt, int node)
 	int max_nodes;
 	nlm_fmn_config_t *fmn_config = NULL;
 
-	nlm_print("*** Firmware Configuration of FMN ***\n");
-
-
         if (is_nlm_xlp9xx()) {
 		unsigned long long mask = ~0xf;
 		fmn_default_qsize = 0;
@@ -1699,7 +1692,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
         }
 
 	update_fmn_config();
-	
+
 	if (max_nodes < 0) {
 		nlm_print("FMN Configuration failed\n");
 		while(1);
@@ -1710,7 +1703,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 	}
 
 	/*fmn_qsize_credit_cfg_extract(fdt); */
-	/* verify out_q config 
+	/* verify out_q config
 	 */
 	if(nlm_hal_setup_outq(fdt, node, max_nodes) < 0)
 		while(1);
@@ -1718,7 +1711,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 	nlm_hal_write_fmn_credit(node, max_nodes);
 }
 
-#ifdef NLM_HAL_LINUX_KERNEL 
+#ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
 EXPORT_SYMBOL(nlm_hal_disable_vc_intr);
diff --git a/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c b/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c
index 6efec71..1ac3b40 100644
--- a/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c
+++ b/arch/mips/netlogic/lib/syslib/src/nlm_evp_cpld.c
@@ -6,7 +6,7 @@
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
  * General Public License (GPL) Version 2, available from the file
- * http://www.gnu.org/licenses/gpl-2.0.txt  
+ * http://www.gnu.org/licenses/gpl-2.0.txt
  * or the Broadcom license below:
 
  * Redistribution and use in source and binary forms, with or without
@@ -84,11 +84,9 @@ uint16_t nlm_hal_cpld_read_16(int cs, uint16_t reg)
 			nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2f84);
 	}
 
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	val = nlm_hal_read_16bit_reg(xlp_nor_dev[cs].base, reg);
         return (xlp_nor_dev[cs].swap ? le16_to_cpu(val): be16_to_cpu(val));
 #else
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	return 0;
 #endif
 }
@@ -97,17 +95,14 @@ void nlm_hal_cpld_write_16(int cs, uint16_t val, uint16_t reg)
 {
 #ifndef CONFIG_N511
         uint16_t data = xlp_nor_dev[cs].swap ? cpu_to_le16(val): cpu_to_be16(val);
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	if(!is_nlm_xlp9xx())
 	{
 		if ((cs == 3) || (cs ==4))
 	        	nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2d84);
 	}
 
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
         nlm_hal_write_16bit_reg(xlp_nor_dev[cs].base, reg, data);
 #else
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 #endif
 }
 
@@ -152,7 +147,7 @@ int is_ilk_card_onslot(int slot)
 
 	slot >>= 1;
 
-	if (DC_TYPE(data, slot) == DC_ILK) 
+	if (DC_TYPE(data, slot) == DC_ILK)
 		return 1;
 	else
 		return 0;
@@ -179,13 +174,13 @@ static inline int my_cpu_id(void)
 int nlm_get_interface_type(int node, int slot)
 {
 	uint16_t data;
-       
+
 	/* there is no cpld in the existing multi node board for node 1-3 */
 #if defined(NLM_HAL_LINUX_USER) || defined(NLM_HAL_LINUX_KERNEL)
 	if(my_cpu_id() >= 32)
 		return DC_NOT_PRSNT;
 #endif
-	
+
 	data = nlm_hal_cpld_read_16(2, 6);
 	nlm_print("Slot present status 0x%x\n", (data & 0xFF));
         if (slot == 4)
@@ -209,7 +204,6 @@ int xlp_cpld_init(uint32_t cs)
 {
 	unsigned long base = xlp_nor_dev[cs].base;
 	unsigned long limit = base + xlp_nor_dev[cs].size - 1;
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	if (cs > NLM_XLP_MAX_CS)
 		return -1;
 	if(cs == 3)
@@ -225,7 +219,7 @@ nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 	nlm_hal_nor_write(XLP_NOR_CS_BASE + cs , (base >> 8));
 	nlm_hal_nor_write(XLP_NOR_CS_LIMIT + cs , (limit >> 8));
 
-	nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , xlp_nor_dev[cs].devparam); 
+	nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , xlp_nor_dev[cs].devparam);
 
 	nlm_hal_nor_write(XLP_NOR_DEV_TIME0 + (cs * 2), 0x4F646EC2 );
 	nlm_hal_nor_write(XLP_NOR_DEV_TIME1 + (cs * 2), 0x8CF3);
@@ -256,9 +250,7 @@ void nlm_hal_cpld_init(int node)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 	int i;
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 #if defined(NLM_CORTINA_SUPPORT)
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	if(is_nlm_xlp9xx())
 		set_gbu_frequency(node, NLM_GBU_FREQ_ILK_9XX);
 	else
@@ -266,7 +258,6 @@ nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 #else
 	set_gbu_frequency(node, NLM_GBU_FREQ_DEFAULT);
 #endif
-nlm_print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ %s %d\n", __FUNCTION__, __LINE__);
 	for(i=2; i<5; i++)
         	xlp_cpld_init(i);
 #endif
-- 
1.7.9.5

