From 10224fb441c389ec4019163038dd54a30d4ab72c Mon Sep 17 00:00:00 2001
From: Vikas Gupta <vikas.gupta@broadcom.com>
Date: Wed, 22 Jan 2014 15:59:18 +0530
Subject: [PATCH 111/163] nae: PHY access changes.

     1. Add neighbour nae pointer in nae struct. Using this, APIs can have
     	access to neighbour NAE unit.
     2. With this feature PHYs are accessible even if they
	are connected to neighbour NAE external MDIO.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 .../netlogic/lib/netlib/external/ext_phy_bcm.c     |   77 ++++++++++++++------
 .../mips/netlogic/lib/netlib/include/nlm_hal_nae.h |    1 +
 arch/mips/netlogic/lib/netlib/include/nlm_nae.h    |    2 +
 arch/mips/netlogic/lib/netlib/src/ext_phy.c        |   15 +++-
 arch/mips/netlogic/lib/netlib/src/netsoc_config.c  |    4 +
 arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c     |    2 +
 6 files changed, 77 insertions(+), 24 deletions(-)

diff --git a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
index d3e057d..12a7e86 100644
--- a/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
+++ b/arch/mips/netlogic/lib/netlib/external/ext_phy_bcm.c
@@ -83,14 +83,24 @@ static int bcm_get_phy_status(net_port_t *netport, uint32_t *speed, uint32_t *du
         int phyaddr = netport->ext_phy_addr;
         int bus = netport->ext_phy_bus;
 	nae_t *nae = netport->nae;
-
+	nae_t *nae_ext = NULL;
+
+	if(netport->ext_phy_sbl){
+		nae_ext = netport->nae->sibling;
+		if(!nae_ext){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Neighbour NAE is not accessible \n");
+			return;			
+		}
+	}else{
+		nae_ext = nae;
+	}
 
         /*switch to Copper registers mode*/
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C, 0x7c00);
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C, 0x7c00);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
         /* check the status */
-        aux_status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x19);
+        aux_status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x19);
         switch ((aux_status>>8) & 0x7){
                 case 0x7:
                         *speed = SPEED_1000M;
@@ -142,8 +152,8 @@ static int bcm_get_phy_status(net_port_t *netport, uint32_t *speed, uint32_t *du
 		netsoc_api_print(NETSOC_APIDBG_DEFAULT, "Half duplex\n");
 	}
 //#endif
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1);
         if(status & (1<<2)){
                 netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Link is up : %x\n", status);
                 //netsoc_api_print(NETSOC_APIDBG_DEFAULT,"%s: exit\n", __func__);
@@ -175,6 +185,17 @@ static void bcm_start_an(net_port_t *netport)
         int bus = netport->ext_phy_bus;
         int int_inf = netport->hw_port_id;
 	nae_t *nae = netport->nae;
+	//nae_t *nae_ext = NULL;
+
+#if 0	
+	if(netport->ext_phy_sbl){
+		nae_ext = netport->nae->sibling;
+		if(!nae_ext){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Neighbour NAE is not accessible \n");
+			return;			
+		}
+	}
+#endif
 
         netsoc_api_print(NETSOC_APIDBG_DEFAULT,"Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", int_inf,  bus, phyaddr);
 
@@ -220,6 +241,16 @@ static void bcm_init_phy(net_port_t *netport)
         int int_inf = netport->hw_port_id;
         int status=0;
 	nae_t *nae = netport->nae;
+	nae_t *nae_ext = NULL; 	
+	if(netport->ext_phy_sbl){
+		nae_ext = netport->nae->sibling;
+		if(!nae_ext){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Neighbour NAE is not accessible \n");
+			return;			
+		}
+	}else{
+		nae_ext = nae;
+	}
 
         netsoc_api_print(NETSOC_APIDBG_DEFAULT,"BCM_INIT_PHY \n ");
 
@@ -229,45 +260,45 @@ static void bcm_init_phy(net_port_t *netport)
 
 
         /* setup for SGMII-Copper mode */
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x7c00);
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x7c00);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
 	
 	if(netport->gig_phy_id==0x60c1){
 		status &= ~(0xff);
-		__netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (status | (1<<15)| (0x2<<1)));
+		__netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (status | (1<<15)| (0x2<<1)));
 	}
         /* Turn off Signal Detect Enable on 1000BASE-X side */
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (0x5c00 | (1<<15)));
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (0x5c00 | (1<<15)));
 
         /* power up copper side*/
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0);
         status &= ~(1<<11);
         //netsoc_api_print(NETSOC_APIDBG_DEFAULT,"writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x00, status); // Normal Operation
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x00, status); // Normal Operation
         nlm_mdelay(100);
 
 
         /* setup LED control */
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x8801); // spare control 1, enable link led mode
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0xB4E5); // LED Selector 1, LED3 off, LED1 SLAVE (LINK)
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0xB83E); // LED Selector 2, LED2 ACTIVITY, LED4 off
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x8801); // spare control 1, enable link led mode
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0xB4E5); // LED Selector 1, LED3 off, LED1 SLAVE (LINK)
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0xB83E); // LED Selector 2, LED2 ACTIVITY, LED4 off
 
         /*switch to 1000Base-X registers mode*/
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x7c00);
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0, 0x100 ); /*Disable AN and power up SGMII side*/
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, 0x7c00);
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x1C);
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0, 0x100 ); /*Disable AN and power up SGMII side*/
         nlm_mdelay(100);
 
-        status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0);
-        __netsoc_mdio_wr(nae, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
+        status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0);
+        __netsoc_mdio_wr(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
 
 #if 1
         /* wait up to 5 seconds for AN to complete on copper side */
         i=0;
         do {
                 nlm_mdelay(100);
-                aux_status = __netsoc_mdio_rd(nae, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x19);
+                aux_status = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, bus, phyaddr, 0x19);
                 if (aux_status & 0x8000)
                         break;
 
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
index f627645..457f47b 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_hal_nae.h
@@ -128,6 +128,7 @@ struct nae_complex_config {
 	uint32_t ucore_mask[MAX_PORTS_PERBLOCK];	
 	uint32_t ext_phy_addr[MAX_PORTS_PERBLOCK];
 	uint32_t ext_phy_bus[MAX_PORTS_PERBLOCK];
+	uint32_t ext_phy_sbl[MAX_PORTS_PERBLOCK];
 	uint32_t mgmt[MAX_PORTS_PERBLOCK];
 	uint32_t loopback[MAX_PORTS_PERBLOCK];
 	uint32_t num_channels[MAX_PORTS_PERBLOCK];
diff --git a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
index b4322d5..d92bf98 100644
--- a/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
+++ b/arch/mips/netlogic/lib/netlib/include/nlm_nae.h
@@ -321,6 +321,7 @@ struct nlm_hal_nae_port {
 	uint32_t param_index;
         int  ext_phy_addr;
         int  ext_phy_bus;
+	int ext_phy_sbl;
         int  gig_phy_id;
 	void *phy_dev;
 	uint32_t  rxaui_scrambler; /* 0: disable scrambler ; 1: enable scrambler */
@@ -333,6 +334,7 @@ struct nlm_hal_nae_port {
 typedef struct nlm_hal_nae_port net_port_t;
 
 struct nlm_hal_nae_config {
+	struct nlm_hal_nae_config *sibling;
 	uint64_t nae_base;
 	uint64_t mac_base;
 	uint64_t pcie_base;
diff --git a/arch/mips/netlogic/lib/netlib/src/ext_phy.c b/arch/mips/netlogic/lib/netlib/src/ext_phy.c
index ed4eb02..8285f3f 100644
--- a/arch/mips/netlogic/lib/netlib/src/ext_phy.c
+++ b/arch/mips/netlogic/lib/netlib/src/ext_phy.c
@@ -57,6 +57,19 @@ void __netsoc_init_ext_phy(net_port_t *netport)
 	int i, phyid; 
         ext_phy_t *phy_dev;
 
+	nae_t *nae = netport->nae; 	
+	nae_t *nae_ext = NULL; 	
+	if(netport->ext_phy_sbl){
+		nae_ext = netport->nae->sibling;
+		if(!nae_ext){
+			netsoc_api_print(NETSOC_APIDBG_ERROR, "Neighbour NAE is not accessible \n");
+			return;			
+		}
+	}else{
+		nae_ext = nae;
+	}
+
+
         if (netport->iftype != SGMII_IF) {
                 return;
         }
@@ -69,7 +82,7 @@ void __netsoc_init_ext_phy(net_port_t *netport)
 
         netsoc_api_print(NETSOC_APIDBG_TRACE, "Scanning MDIO external BUS %d Phy addr 0x%x----\n", netport->ext_phy_bus, netport->ext_phy_addr);
 
-        phyid = __netsoc_mdio_rd(netport->nae, NLM_HAL_EXT_MDIO, netport->ext_phy_bus, netport->ext_phy_addr, 3);
+        phyid = __netsoc_mdio_rd(nae_ext, NLM_HAL_EXT_MDIO, netport->ext_phy_bus, netport->ext_phy_addr, 3);
 
         i = 0;
         while(known_ext_phys[i].phy_idfer != 0) {
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
index 161ae49..9b5ee9a 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_config.c
@@ -633,6 +633,10 @@ int __netsoc_parse_and_init(void *fdt, int dom_id)
 			xlp_nae[node][id] = nae;
 			dump_nae_config(nae);
 		}
+		if(max_nae==2){  /*storing sibling pointers in case if max_nae==2*/
+			xlp_nae[node][0]->sibling = xlp_nae[node][1];
+			xlp_nae[node][1]->sibling = xlp_nae[node][0];
+		}
 	
 		// Parset poe configuration from fdt
 		for(id = 0; id < max_poe; id++) {
diff --git a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
index 6429fbd..2e052ba 100644
--- a/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
+++ b/arch/mips/netlogic/lib/netlib/src/netsoc_fdt.c
@@ -868,6 +868,7 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
                 }
                 GET_PORT_PROP("ext-phy-addr", &cmplx->ext_phy_addr, sizeof(cmplx->ext_phy_addr));
                 GET_PORT_PROP("ext-phy-bus", &cmplx->ext_phy_bus, sizeof(cmplx->ext_phy_bus));
+                GET_PORT_PROP("ext-phy-sbl", &cmplx->ext_phy_sbl, sizeof(cmplx->ext_phy_sbl));
         }
         else if (intf_type == INTERLAKEN_IF) {
                 if(GET_PORT_PROP("num-lanes", &cmplx->num_lanes, sizeof(uint32_t)) < 0) {
@@ -1101,6 +1102,7 @@ static int fdt_parse_port_config(void *fdt, nae_t *nae_cfg)
                         nae_port->ucore_mask = cmplx_cfg.ucore_mask[offset];
                         nae_port->ext_phy_addr = cmplx_cfg.ext_phy_addr[offset]; /*used for both 1G and 10G PHY*/
                         nae_port->ext_phy_bus = cmplx_cfg.ext_phy_bus[offset];
+                        nae_port->ext_phy_sbl = cmplx_cfg.ext_phy_sbl[offset];
                         nae_port->loopback = cmplx_cfg.loopback[offset];
                         nae_port->rxaui_mode = cmplx_cfg.rxaui_submode[offset];;
                         //nae_port->msec_enable = cmplx_cfg.msec_port_enable[offset];;
-- 
1.7.9.5

