From 11a994ccbb6b1cdeeb589f468bebf900907c0459 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 14 Aug 2014 11:19:52 +0800
Subject: [PATCH 3/8] bcm-xlp: serialize the NOR and MMC operations

Serialize the NOR and MMC operations to prevent them
from access MMC/NAND/SPI/NOR configuration space
register simultaneously.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/netlogic/Kconfig     | 10 +++++
 arch/mips/netlogic/xlp/setup.c | 10 +++++
 drivers/mmc/host/sdhci-xlp.c   | 41 +++++++++++++++++-
 drivers/mmc/host/sdhci.c       | 10 ++++-
 drivers/mmc/host/sdhci.h       | 56 +++++++++++++++++++++++++
 drivers/spi/spi-xlp.c          | 24 +++++++++++
 include/linux/mtd/map.h        | 95 ++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 243 insertions(+), 3 deletions(-)

diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 5fba625..548f48e 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -4,6 +4,16 @@ config ARCH_SELECT_MEMORY_MODEL
 	bool
 
 if NLM_XLP_BOARD
+config  FLASH_MMC_LOCK
+	bool "Serialize the NOR and MMC operation"
+	default y
+	help
+	  Select this option if you want to make operations
+	  on NOR/MMC devices serialized.
+	  This is always necessary for all XLP series board.
+
+	  If unsure, say Y.
+
 config DT_XLP_EVP
 	bool "Built-in device tree for XLP EVP boards"
 	default y
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 2f9e6a0..312322f 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -202,6 +202,12 @@ void nlm_percpu_init(int hwcpuid)
 #ifdef CONFIG_KEXEC
 extern void nlm_kexec_init(void);
 #endif
+
+#ifdef CONFIG_FLASH_MMC_LOCK
+spinlock_t g_flashmmc_lock;
+EXPORT_SYMBOL(g_flashmmc_lock);
+#endif
+
 void __init prom_init(void)
 {
 	void *reset_vec;
@@ -224,6 +230,10 @@ void __init prom_init(void)
 	memcpy(reset_vec, (void *)nlm_reset_entry,
 			(nlm_reset_entry_end - nlm_reset_entry));
 
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_init(&g_flashmmc_lock);
+#endif
+
 #ifdef CONFIG_SMP
 	xlp_dt_get_cpumask(&nlm_cpumask);
 #endif
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
index 3694089..79e3589 100644
--- a/drivers/mmc/host/sdhci-xlp.c
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -149,13 +149,23 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 	struct resource res;
 	void __iomem *sys_addr;
 	int ret, slotno, node;
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+#endif
 
 	node = xlp_socdev_to_node(pdev);
 	chip = kzalloc(sizeof(struct sdhci_xlp_chip), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
 
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
 	ret = pci_enable_device(pdev);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
+
 	if (ret) {
 		dev_err(&pdev->dev, "pci_enable_device() failed!\n");
 		kfree(chip);
@@ -180,7 +190,14 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 		ret = -ENOMEM;
 		goto err;
 	}
+
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
 	writel(0x1C, sys_addr);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
 
 	/*
 	 * The XLP MMC/SD controller has two slots. The registers for the
@@ -206,8 +223,15 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 	return 0;
 
 err:
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
 	pci_disable_device(pdev);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
 	kfree(chip);
+
 	return ret;
 }
 
@@ -216,12 +240,21 @@ static void sdhci_xlp_remove(struct pci_dev *pdev)
 	struct sdhci_xlp_chip *chip;
 	int slotno, dead;
 	u32 scratch;
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+#endif
 
 	chip = pci_get_drvdata(pdev);
 	if (chip) {
 		for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
+#ifdef CONFIG_FLASH_MMC_LOCK
+			spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
 			scratch = readl(chip->host[slotno]->ioaddr +
 					SDHCI_INT_STATUS);
+#ifdef CONFIG_FLASH_MMC_LOCK
+			spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
 			if (scratch == (u32)-1)
 				dead = 1;
 
@@ -231,7 +264,13 @@ static void sdhci_xlp_remove(struct pci_dev *pdev)
 		}
 		pci_set_drvdata(pdev, NULL);
 	}
-	pci_disable_device(pdev);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
+		pci_disable_device(pdev);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
 }
 
 static struct pci_driver sdhci_xlp_driver = {
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index c4a94f2..b08178d 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -120,8 +120,14 @@ static void sdhci_dumpregs(struct sdhci_host *host)
 
 	if (host->flags & SDHCI_USE_ADMA)
 		pr_debug(DRIVER_NAME ": ADMA Err: 0x%08x | ADMA Ptr: 0x%08x\n",
-		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
-		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
+#ifdef CONFIG_FLASH_MMC_LOCK
+				sdhci_readl(host, SDHCI_ADMA_ERROR),
+				sdhci_readl(host, SDHCI_ADMA_ADDRESS)
+#else
+				readl(host->ioaddr + SDHCI_ADMA_ERROR),
+				readl(host->ioaddr + SDHCI_ADMA_ADDRESS)
+#endif
+				);
 
 	pr_debug(DRIVER_NAME ": ===========================================\n");
 }
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index b037f18..1ed748b 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -20,6 +20,9 @@
 
 #include <linux/mmc/sdhci.h>
 
+#ifdef CONFIG_FLASH_MMC_LOCK
+extern spinlock_t g_flashmmc_lock;
+#endif
 /*
  * Controller registers
  */
@@ -351,32 +354,85 @@ static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
 
 static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	writel(val, host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#else
 	writel(val, host->ioaddr + reg);
+#endif
 }
 
 static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	writew(val, host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#else
+	writew(val, host->ioaddr + reg);
+#endif
+
 }
 
 static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	writeb(val, host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#else
 	writeb(val, host->ioaddr + reg);
+#endif
 }
 
 static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	u32 value;
+
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	value = readl(host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	return value;
+#else
 	return readl(host->ioaddr + reg);
+#endif
 }
 
 static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	u16 value;
+
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	value = readw(host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	return value;
+#else
 	return readw(host->ioaddr + reg);
+#endif
+
 }
 
 static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
 {
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	u8 value;
+
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	value = readb(host->ioaddr + reg);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	return value;
+#else
 	return readb(host->ioaddr + reg);
+#endif
 }
 
 #endif /* CONFIG_MMC_SDHCI_IO_ACCESSORS */
diff --git a/drivers/spi/spi-xlp.c b/drivers/spi/spi-xlp.c
index 6077373..6036f0d 100644
--- a/drivers/spi/spi-xlp.c
+++ b/drivers/spi/spi-xlp.c
@@ -38,6 +38,10 @@
 #include <linux/of.h>
 #include <linux/interrupt.h>
 
+#ifdef CONFIG_FLASH_MMC_LOCK
+extern spinlock_t g_flashmmc_lock;
+#endif
+
 #define XLP_SPI_CONFIG			0x40
 #define XLP_SPI_CPHA			BIT(0)
 #define XLP_SPI_CPOL			BIT(1)
@@ -111,20 +115,40 @@ static inline int xlp_spi_reg_read(struct xlp_spi_priv *priv,
 					int cs, int regidx)
 {
 	void __iomem *addr;
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+	int value;
+#endif
 
 	regidx += cs * SPI_CHAN_OFFSET;
 	addr = priv->base + (regidx << 2);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	value = readl(addr);
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	return value;
+#else
 	return readl(addr);
+#endif
 }
 
 static inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,
 		int regidx, u32 val)
 {
 	void __iomem *addr;
+#ifdef CONFIG_FLASH_MMC_LOCK
+	unsigned long spinirq;
+#endif
 
 	regidx += cs * SPI_CHAN_OFFSET;
 	addr = priv->base + (regidx << 2);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+#endif
 	writel(val, addr);
+#ifdef CONFIG_FLASH_MMC_LOCK
+	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+#endif
 }
 
 /* reset all spi channels */
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 5f487d7..3d13798 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -31,6 +31,12 @@
 #include <asm/unaligned.h>
 #include <asm/io.h>
 #include <asm/barrier.h>
+#ifdef CONFIG_FLASH_MMC_LOCK
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#endif
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
 #define map_bankwidth(map) 1
@@ -456,10 +462,99 @@ extern void simple_map_init(struct map_info *);
 #define map_is_linear(map) (map->phys != NO_XIP)
 
 #else
+#ifdef CONFIG_FLASH_MMC_LOCK
+/*
+ * Olny take cares XLP9XX and XLP2XX
+ */
+static inline int is_inside_flash_region(struct map_info *map)
+{
+	resource_size_t bridge_phybase;
+	resource_size_t start, end;
+	volatile unsigned int *reg_start;
+	volatile unsigned int *reg_limit;
+	int i;
+#define XLP9XX_FLASH_START 0x51
+#define XLP_FLASH_START 0x4C
+
+	if (cpu_is_xlp9xx()) {
+		bridge_phybase =
+			XLP9XX_IO_BRIDGE_OFFSET(0) + XLP_DEFAULT_PCI_ECFG_BASE;
+		reg_start =
+			(unsigned int *)ioremap(bridge_phybase+XLP9XX_FLASH_START*4, 32);
+	} else {
+		bridge_phybase =
+			XLP_IO_BRIDGE_OFFSET(0) + XLP_DEFAULT_PCI_ECFG_BASE;
+		reg_start =
+			(unsigned int *)ioremap(bridge_phybase+XLP_FLASH_START*4, 32);
+	}
+	if (!reg_start) {
+		printk(KERN_ERR "Failed in map flash registers.\n");
+		return 0;
+	}
+
+	reg_limit = reg_start+4;
+	for (i = 0; i < 4; i++) {
+		start = (*(reg_start+i))>>12;
+		end = (*(reg_limit+i))>>12;
+		if (((map->phys>>20) >= start)
+			&& ((map->phys>>20) <= end))
+			return 1;
+	}
+	return 0;
+}
+
+extern spinlock_t g_flashmmc_lock;
+static inline map_word map_read(struct map_info *map, unsigned long ofs)
+{
+	unsigned long spinirq;
+	map_word r;
+	if (is_inside_flash_region(map)) {
+		spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+		r = inline_map_read(map, ofs);
+		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	} else {
+		r = inline_map_read(map, ofs);
+	}
+	return r;
+}
+
+#define map_copy_from(map, to, from, len) \
+{\
+	unsigned long spinirq;\
+	if (is_inside_flash_region(map)) {\
+		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		inline_map_copy_from(map, to, from, len);\
+		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+	} else \
+		inline_map_copy_from(map, to, from, len);\
+}
+
+#define map_write(map, datum, ofs)\
+{\
+	unsigned long spinirq;\
+	if (is_inside_flash_region(map)) {\
+		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		inline_map_write(map, datum, ofs);\
+		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+	} else \
+		inline_map_write(map, datum, ofs);\
+}
+#define map_copy_to(map, to, from, len)\
+{\
+	unsigned long spinirq;\
+	if (is_inside_flash_region(map)) {\
+		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		inline_map_copy_to(map, to, from, len);\
+		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+	} else \
+		inline_map_copy_to(map, to, from, len);\
+}
+#else
 #define map_read(map, ofs) inline_map_read(map, ofs)
 #define map_copy_from(map, to, from, len) inline_map_copy_from(map, to, from, len)
 #define map_write(map, datum, ofs) inline_map_write(map, datum, ofs)
 #define map_copy_to(map, to, from, len) inline_map_copy_to(map, to, from, len)
+#endif
 
 
 #define simple_map_init(map) BUG_ON(!map_bankwidth_supported((map)->bankwidth))
-- 
1.9.1

