From c43441c7e3c69ec0e34975f1f9fc59d4b133755c Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 23 Jan 2014 15:43:13 +0800
Subject: [PATCH 01/58] bcm-xlp2: BCM XLP series common platform implementation

Including IO, IRQ, timer, FMN, on-chip AHCI, on-chip USB etc.

update the basic arch dir of netlogic

Based on sdk 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/netlogic/Kconfig                 |  102 ++++++
 arch/mips/netlogic/Makefile                |    1 +
 arch/mips/netlogic/Platform                |    9 +-
 arch/mips/netlogic/common/Makefile         |   10 +-
 arch/mips/netlogic/common/earlycons.c      |    1 +
 arch/mips/netlogic/common/io.c             |   41 +++
 arch/mips/netlogic/common/irq.c            |  139 ++++++--
 arch/mips/netlogic/common/memory.c         |  204 +++++++++++
 arch/mips/netlogic/common/nlm-dma.c        |  107 ++++++
 arch/mips/netlogic/common/nlm_fs.h         |  102 ++++++
 arch/mips/netlogic/common/nlm_fs_handler.S |  533 ++++++++++++++++++++++++++++
 arch/mips/netlogic/common/nlm_fs_tbl.c     |   77 ++++
 arch/mips/netlogic/common/perf_ctr.h       |   72 ++++
 arch/mips/netlogic/common/reset.S          |  338 ++++++++++++++++++
 arch/mips/netlogic/common/smp.c            |  148 ++++++--
 arch/mips/netlogic/common/smpboot.S        |  217 ++---------
 arch/mips/netlogic/common/time.c           |   41 ++-
 arch/mips/netlogic/dts/Makefile            |    2 +
 arch/mips/netlogic/dts/xlp_evp.dts         |  105 +++++-
 arch/mips/netlogic/dts/xlp_fvp.dts         |  197 ++++++++++
 arch/mips/netlogic/dts/xlp_gvp.dts         |  176 +++++++++
 arch/mips/netlogic/dts/xlp_htc.dts         |  150 ++++++++
 arch/mips/netlogic/dts/xlp_svp.dts         |  118 +++++-
 arch/mips/netlogic/kvm/Makefile            |    5 +
 arch/mips/netlogic/kvm/kvm_bridge.c        |  112 ++++++
 arch/mips/netlogic/kvm/kvm_clk.c           |   82 +++++
 arch/mips/netlogic/kvm/kvm_fault.c         |  303 ++++++++++++++++
 arch/mips/netlogic/kvm/kvm_fuse.c          |   80 +++++
 arch/mips/netlogic/kvm/kvm_pcie.c          |  157 ++++++++
 arch/mips/netlogic/kvm/kvm_pic.c           |  193 ++++++++++
 arch/mips/netlogic/kvm/kvm_sysmgt.c        |  135 +++++++
 arch/mips/netlogic/kvm/kvm_traps.c         |  483 +++++++++++++++++++++++++
 arch/mips/netlogic/kvm/kvm_uart.c          |  217 +++++++++++
 arch/mips/netlogic/xlp/Makefile            |    7 +-
 arch/mips/netlogic/xlp/ahci-init-xlp2.c    |  367 +++++++++++++++++++
 arch/mips/netlogic/xlp/ahci_init.c         |  196 ++++++++++
 arch/mips/netlogic/xlp/c-xlp.c             |  412 +++++++++++++++++++++
 arch/mips/netlogic/xlp/cop2.S              |  127 +++++++
 arch/mips/netlogic/xlp/dt.c                |  171 +++++++++
 arch/mips/netlogic/xlp/nlm_hal.c           |  378 ++++++++++++++++++--
 arch/mips/netlogic/xlp/numa.c              |  218 ++++++++++++
 arch/mips/netlogic/xlp/setup.c             |  336 ++++++++++++++----
 arch/mips/netlogic/xlp/usb-init-xlp2.c     |  280 +++++++++++++++
 arch/mips/netlogic/xlp/usb-init.c          |   80 +++--
 arch/mips/netlogic/xlp/wakeup.c            |  123 +++++--
 arch/mips/netlogic/xlr/Makefile            |    2 +-
 arch/mips/netlogic/xlr/c-xlr.c             |  219 ++++++++++++
 arch/mips/netlogic/xlr/fmn-config.c        |    4 +-
 arch/mips/netlogic/xlr/fmn.c               |   18 +-
 arch/mips/netlogic/xlr/platform-flash.c    |   12 +-
 arch/mips/netlogic/xlr/platform.c          |   10 +-
 arch/mips/netlogic/xlr/setup.c             |   14 +-
 arch/mips/netlogic/xlr/wakeup.c            |   12 +-
 53 files changed, 7184 insertions(+), 459 deletions(-)

diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index e0873a3..8ae3174 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -19,6 +19,24 @@ config DT_XLP_SVP
 	  pointer to the kernel.  The corresponding DTS file is at
 	  arch/mips/netlogic/dts/xlp_svp.dts
 
+config DT_XLP_FVP
+	bool "Built-in device tree for XLP FVP boards"
+	default y
+	help
+	  Add an FDT blob for XLP FVP board into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/netlogic/dts/xlp_fvp.dts
+
+config DT_XLP_GVP
+	bool "Built-in device tree for XLP GVP boards"
+	default y
+	help
+	  Add an FDT blob for XLP GVP board into the kernel.
+	  This DTB will be used if the firmware does not pass in a DTB
+	  pointer to the kernel.  The corresponding DTS file is at
+	  arch/mips/netlogic/dts/xlp_gvp.dts
+
 config NLM_MULTINODE
 	bool "Support for multi-chip boards"
 	depends on NLM_XLP_BOARD
@@ -48,7 +66,91 @@ endchoice
 endif
 endif
 
+config MAPPED_KERNEL
+	bool "Mapped kernel support"
+	default n
+	help
+	  Select this option if you want the kernel code and data to be
+	  in mapped memory.
+
 config NLM_COMMON
 	bool
 
+if NLM_XLP_BOARD
+
+config NLM_ENABLE_COP2
+	bool "Enable Cop2 Access "
+	depends on CPU_XLP && 64BIT
+	default n
+	help
+	  This option enables cop2 access for both user and kernel space.
+
+config HUGEPAGE_NOT_MIPS_DEFAULT
+	bool "Support for not-mips-style hugepage"
+	depends on HUGETLB_PAGE
+	default n
+	help
+	  Support not-mips-style hugepage
+
+if HUGEPAGE_NOT_MIPS_DEFAULT
+choice
+	prompt "Not-MIPS-default-style Huge page size"
+	default HUGE_PAGE_SIZE_8M
+
+	config HUGE_PAGE_SIZE_128K
+	bool "128KB"
+	help
+	  Using 128KB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_512K
+	bool "512KB"
+	help
+	  Using 512KB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_2M
+	bool "2MB"
+	help
+	  Using 2MB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_8M
+	bool "8MB"
+	help
+	  Using 8MB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_32M
+	bool "32MB"
+	help
+	  Using 32MB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_128M
+	bool "128MB"
+	help
+	  Using 128MB as the hugetlb page size
+
+	config HUGE_PAGE_SIZE_512M
+	bool "512MB"
+	help
+	  Using 512MB as the hugetlb page size
+
+endchoice
+endif
+endif
+
+config IOMMU_HELPER
+	bool
+
+config NEED_SG_DMA_LENGTH
+	bool
+
+config SWIOTLB
+	def_bool y
+	select NEED_SG_DMA_LENGTH
+	select IOMMU_HELPER
+
+config NLM_ADMA
+	bool "NLM_ADMA support"
+	select DMA_ENGINE
+	help
+		Enable support for NLM ADMA RAID
+
 endif
diff --git a/arch/mips/netlogic/Makefile b/arch/mips/netlogic/Makefile
index 7602d13..69def59 100644
--- a/arch/mips/netlogic/Makefile
+++ b/arch/mips/netlogic/Makefile
@@ -2,3 +2,4 @@ obj-$(CONFIG_NLM_COMMON)	+=	common/
 obj-$(CONFIG_CPU_XLR)		+=	xlr/
 obj-$(CONFIG_CPU_XLP)		+=	xlp/
 obj-$(CONFIG_CPU_XLP)		+=	dts/
+obj-$(CONFIG_KVM)		+=	kvm/
diff --git a/arch/mips/netlogic/Platform b/arch/mips/netlogic/Platform
index fb8eb4c..8b893ab 100644
--- a/arch/mips/netlogic/Platform
+++ b/arch/mips/netlogic/Platform
@@ -13,5 +13,10 @@ cflags-$(CONFIG_CPU_XLP)	+= $(call cc-option,-march=xlp,-march=mips64r2)
 #
 # NETLOGIC processor support
 #
-platform-$(CONFIG_NLM_COMMON)	+= netlogic/
-load-$(CONFIG_NLM_COMMON)	+= 0xffffffff80100000
+platform-$(CONFIG_NLM_COMMON)  	+= netlogic/
+
+ifdef CONFIG_MAPPED_KERNEL
+load-$(CONFIG_NLM_COMMON)  	+= 0xffffffffc0100000
+else
+load-$(CONFIG_NLM_COMMON)  	+= 0xffffffff80100000
+endif
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 291372a..ca4dd14 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -1,3 +1,11 @@
-obj-y				+= irq.o time.o
+obj-y				+= irq.o time.o reset.o memory.o io.o
+obj-y				+= nlm_fs_tbl.o	nlm_fs_handler.o
+obj-y				+= nlm-dma.o
+obj-y				+= reset.o
+obj-y				+= memory.o
+obj-y				+= io.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_EARLY_PRINTK)	+= earlycons.o
+
+AFLAGS_nlm_fs_handler.o += -I$(srctree)/../libraries/syslib/include \
+	-DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL
diff --git a/arch/mips/netlogic/common/earlycons.c b/arch/mips/netlogic/common/earlycons.c
index 1902fa2..080fb2e 100644
--- a/arch/mips/netlogic/common/earlycons.c
+++ b/arch/mips/netlogic/common/earlycons.c
@@ -40,6 +40,7 @@
 
 #if defined(CONFIG_CPU_XLP)
 #include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/uart.h>
 #elif defined(CONFIG_CPU_XLR)
 #include <asm/netlogic/xlr/iomap.h>
diff --git a/arch/mips/netlogic/common/io.c b/arch/mips/netlogic/common/io.c
new file mode 100644
index 0000000..527ac26
--- /dev/null
+++ b/arch/mips/netlogic/common/io.c
@@ -0,0 +1,41 @@
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+/* Based on arch/ia64/lib/io.c */
+
+void memcpy_fromio(void *dst, const volatile void __iomem *src, long count)
+{
+        char *to = dst;
+
+        while (count) {
+                count--;
+                *to++ = readb(src++);
+        }
+}
+EXPORT_SYMBOL(memcpy_fromio);
+
+void memcpy_toio(volatile void __iomem *dst, const void *src, long count)
+{
+        const char *from = src;
+
+        while (count) {
+                count--;
+                writeb(*from++, dst++);
+        }
+}
+EXPORT_SYMBOL(memcpy_toio);
+
+void memset_io(volatile void __iomem *dst, int c, long count)
+{
+        unsigned char ch = (char)(c & 0xff);
+
+        while (count) {
+                count--;
+                writeb(ch, dst);
+                dst++;
+        }
+}
+EXPORT_SYMBOL(memset_io);
+
diff --git a/arch/mips/netlogic/common/irq.c b/arch/mips/netlogic/common/irq.c
index 9f84c60..28c4563 100644
--- a/arch/mips/netlogic/common/irq.c
+++ b/arch/mips/netlogic/common/irq.c
@@ -40,6 +40,10 @@
 #include <linux/slab.h>
 #include <linux/irq.h>
 
+#include <linux/irqdomain.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
 #include <asm/errno.h>
 #include <asm/signal.h>
 #include <asm/ptrace.h>
@@ -69,8 +73,9 @@
 #else
 #define SMP_IRQ_MASK	0
 #endif
-#define PERCPU_IRQ_MASK (SMP_IRQ_MASK | (1ull << IRQ_TIMER) | \
-				(1ull << IRQ_FMN))
+#define PERCPU_IRQ_MASK	(SMP_IRQ_MASK | (1ull << IRQ_TIMER) | \
+				(1ull << IRQ_FMN) | \
+				(1ull << IRQ_PERF))
 
 struct nlm_pic_irq {
 	void	(*extra_ack)(struct irq_data *);
@@ -176,6 +181,7 @@ static void __init nlm_init_percpu_irqs(void)
 #endif
 }
 
+
 void nlm_setup_pic_irq(int node, int picirq, int irq, int irt)
 {
 	struct nlm_pic_irq *pic_data;
@@ -198,48 +204,41 @@ void nlm_set_pic_extra_ack(int node, int irq, void (*xack)(struct irq_data *))
 
 	xirq = nlm_irq_to_xirq(node, irq);
 	pic_data = irq_get_handler_data(xirq);
+	if (pic_data == NULL) {
+		pr_err("%s : Invalid IRQ <%d, %d>!\n", __func__, node, irq);
+		return;
+	}
 	pic_data->extra_ack = xack;
 }
 
 static void nlm_init_node_irqs(int node)
 {
-	int i, irt;
-	uint64_t irqmask;
 	struct nlm_soc_info *nodep;
+	int i, irt;
 
 	pr_info("Init IRQ for node %d\n", node);
 	nodep = nlm_get_node(node);
-	irqmask = PERCPU_IRQ_MASK;
+	nodep->irqmask = PERCPU_IRQ_MASK;
 	for (i = PIC_IRT_FIRST_IRQ; i <= PIC_IRT_LAST_IRQ; i++) {
 		irt = nlm_irq_to_irt(i);
-		if (irt == -1)
+		if (irt == -1)		/* unused irq */
 			continue;
-		nlm_setup_pic_irq(node, i, i, irt);
-		/* set interrupts to first cpu in node */
+		nodep->irqmask |= 1ull << i;
+		if (irt == -2)		/* not a direct PIC irq */
+			continue;
+
 		nlm_pic_init_irt(nodep->picbase, irt, i,
-					node * NLM_CPUS_PER_NODE, 0);
-		irqmask |= (1ull << i);
+				node * nlm_threads_per_node(), 0);
+		nlm_setup_pic_irq(node, i, i, irt);
 	}
-	nodep->irqmask = irqmask;
-}
-
-void __init arch_init_irq(void)
-{
-	/* Initialize the irq descriptors */
-	nlm_init_percpu_irqs();
-	nlm_init_node_irqs(0);
-	write_c0_eimr(nlm_current_node()->irqmask);
-#if defined(CONFIG_CPU_XLR)
-	nlm_setup_fmn_irq();
-#endif
 }
 
 void nlm_smp_irq_init(int hwcpuid)
 {
 	int node, cpu;
 
-	node = hwcpuid / NLM_CPUS_PER_NODE;
-	cpu  = hwcpuid % NLM_CPUS_PER_NODE;
+	node = nlm_cpuid_to_node(hwcpuid);
+	cpu  = hwcpuid % nlm_threads_per_node();
 
 	if (cpu == 0 && node != 0)
 		nlm_init_node_irqs(node);
@@ -253,17 +252,101 @@ asmlinkage void plat_irq_dispatch(void)
 
 	node = nlm_nodeid();
 	eirr = read_c0_eirr_and_eimr();
-
-	i = __ilog2_u64(eirr);
-	if (i == -1)
+	if (eirr == 0)
 		return;
 
+	i = __ffs64(eirr);
 	/* per-CPU IRQs don't need translation */
-	if (eirr & PERCPU_IRQ_MASK) {
+	if (i < PIC_IRQ_BASE) {
 		do_IRQ(i);
 		return;
 	}
 
+#if defined(CONFIG_PCI_MSI) && defined(CONFIG_CPU_XLP)
+	/* PCI interrupts need a second level dispatch for MSI bits */
+	if (i >= PIC_PCIE_LINK_MSI_IRQ(0) && i <= PIC_PCIE_LINK_MSI_IRQ(3)) {
+		nlm_dispatch_msi(node, i);
+		return;
+	}
+	if (i >= PIC_PCIE_MSIX_IRQ(0) && i <= PIC_PCIE_MSIX_IRQ(3)) {
+		nlm_dispatch_msix(node, i);
+		return;
+	}
+
+#endif
 	/* top level irq handling */
 	do_IRQ(nlm_irq_to_xirq(node, i));
 }
+
+#ifdef CONFIG_OF
+static const struct irq_domain_ops xlp_pic_irq_domain_ops = {
+	.xlate = irq_domain_xlate_onetwocell,
+};
+
+static int __init xlp_of_pic_init(struct device_node *node,
+					struct device_node *parent)
+{
+	const int n_picirqs = PIC_IRT_LAST_IRQ - PIC_IRQ_BASE + 1;
+	struct irq_domain *xlp_pic_domain;
+	struct resource res;
+	int socid, ret, bus;
+
+	/* we need a hack to get the PIC's SoC chip id */
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret < 0) {
+		pr_err("PIC %s: reg property not found!\n", node->name);
+		return -EINVAL;
+	}
+
+	if (cpu_is_xlp9xx()) {
+		bus = (res.start >> 20) & 0xf;
+		for (socid = 0; socid < NLM_NR_NODES; socid++) {
+			if (!nlm_node_present(socid))
+				continue;
+			if (nlm_get_node(socid)->socbus == bus)
+				break;
+		}
+		if (socid == NLM_NR_NODES) {
+			pr_err("PIC %s: Node mapping for bus %d not found!\n",
+					node->name, bus);
+			return -EINVAL;
+		}
+	} else
+		socid = (res.start >> 18) & 0x3;
+
+	if (!nlm_node_present(socid)) {
+		pr_err("PIC %s: node %d does not exist!\n", node->name, socid);
+		return -EINVAL;
+	}
+
+	xlp_pic_domain = irq_domain_add_legacy(node, n_picirqs,
+		nlm_irq_to_xirq(socid, PIC_IRQ_BASE), PIC_IRQ_BASE,
+		&xlp_pic_irq_domain_ops, NULL);
+	if (xlp_pic_domain == NULL) {
+		pr_err("PIC %s: Creating legacy domain failed!\n", node->name);
+		return -EINVAL;
+	}
+	pr_info("Node %d: IRQ domain created for PIC@%pa\n", socid,
+							&res.start);
+	return 0;
+}
+
+static struct of_device_id __initdata xlp_pic_irq_ids[] = {
+	{ .compatible = "netlogic,xlp-pic", .data = xlp_of_pic_init },
+	{},
+};
+#endif
+
+void __init arch_init_irq(void)
+{
+	/* Initialize the irq descriptors */
+	nlm_init_percpu_irqs();
+	nlm_init_node_irqs(0);
+	write_c0_eimr(nlm_current_node()->irqmask);
+#if defined(CONFIG_CPU_XLR)
+	nlm_setup_fmn_irq();
+#endif
+#if defined(CONFIG_OF)
+	of_irq_init(xlp_pic_irq_ids);
+#endif
+}
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
new file mode 100644
index 0000000..62c4e35
--- /dev/null
+++ b/arch/mips/netlogic/common/memory.c
@@ -0,0 +1,204 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/bootinfo.h>
+#include <asm/pgtable.h>
+#include <asm/types.h>
+#include <asm/tlb.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define TLBSZ		(256 * 1024 * 1024)
+#define PM_TLBSZ	PM_256M
+#define HTLBSZ		(4ull * 1024 * 1024 * 1024)
+#define PM_HTLBSZ	0x1ffffe000
+#define PTE_MAPKERN(pa)	((((pa) >> 12) << 6) | 0x2f)
+#define TLB_MAXWIRED	28
+
+static const int perf_backup = 512;
+
+#ifdef CONFIG_MAPPED_KERNEL
+static void nlm_tlb_align(struct boot_mem_map_entry *map)
+{
+	phys_t astart, aend, start, end;
+
+	start = map->addr;
+	end = start + map->size + perf_backup;	/* fixup for earlier change */
+
+	/* fudge first entry for now  */
+	if (start < 0x10000000) {
+		start = 0;
+		end = 0x10000000;
+	}
+	astart = round_up(start, TLBSZ);
+	aend = round_down(end, TLBSZ);
+	if (aend <= astart) {
+		pr_info("Boot mem map: discard seg %lx-%lx\n",
+				(unsigned long)start, (unsigned long)end);
+		map->size = 0;
+		return;
+	}
+	if (astart != start || aend != end) {
+		if (start != 0) {
+			map->addr = astart;
+			map->size = aend - astart - perf_backup;
+		}
+		pr_info("Boot mem map: %lx - %lx -> %lx-%lx\n",
+			(unsigned long)start, (unsigned long)end,
+			(unsigned long)astart, (unsigned long)aend);
+	} else
+		pr_info("Boot mem map: added %lx - %lx\n",
+			(unsigned long)astart, (unsigned long)aend);
+}
+#endif
+
+void nlm_fixup_mem(void)
+{
+	int i;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+			continue;
+#ifdef CONFIG_CPU_XLP
+		boot_mem_map.map[i].size -= perf_backup;
+#endif
+#ifdef CONFIG_MAPPED_KERNEL
+		nlm_tlb_align(&boot_mem_map.map[i]);
+#endif
+	}
+}
+
+struct fittlb_info {
+	int	ntlb;			/* tlbs used */
+	int	ovf;			/* overflow */
+	phys_addr_t limitlo_in;		/* end of the previous mapping */
+	phys_addr_t limithi_in;		/* start of the next mapping */
+	phys_addr_t limitlo_out;	/* beginning of current */
+	phys_addr_t limithi_out;	/* end of current */
+	phys_addr_t lastaddr;		/* last address mapped */
+};
+
+static inline void addtlb(struct fittlb_info *fti, phys_addr_t pa,
+	u64 pgsz, u64 pmask, unsigned int valid)
+{
+	u64 *t;
+
+	pr_debug("%2d - pa0 %llx pa1 %llx pgsz %llx valid %x\n",
+		fti->ntlb, pa, pa + 2 * pgsz, pgsz, valid);
+	if (fti->ntlb == TLB_MAXWIRED) {
+		fti->ovf = 1;
+		return;
+	}
+	t = nlm_get_boot_data(BOOT_TLBS_START);
+	t += fti->ntlb * (BOOT_TLB_SIZE / sizeof(t[0]));
+
+	t[BOOT_TLB_ENTRYHI] = pa + PAGE_OFFSET;
+	t[BOOT_TLB_ENTRYLO0] = (valid & 0x1) ? PTE_MAPKERN(pa) : 1;
+	t[BOOT_TLB_ENTRYLO1] = (valid & 0x2) ? PTE_MAPKERN(pa + pgsz) : 1;
+	t[BOOT_TLB_PAGEMASK] = pmask;
+
+	if (pa < fti->limitlo_out)
+		fti->limitlo_out = pa;
+	if (pa + 2 * pgsz > fti->limithi_out)
+		fti->limithi_out = pa + 2 * pgsz;
+	if (valid == 1)
+		fti->lastaddr = pa + pgsz;
+	else
+		fti->lastaddr = pa + 2 * pgsz;
+	fti->ntlb++;
+}
+
+static int tlbfit(struct fittlb_info *fti, phys_addr_t start, phys_addr_t end,
+	u64 pgsz, u64 pgmask)
+{
+	phys_addr_t tstart, tend, p, n = 0;
+	u64 npgsz, npgmask;
+
+	/* page size and mask for next level of recursion */
+	npgsz = pgsz / 4;
+	npgmask = (pgmask >> 2) & ~(u64)0x1fff;
+
+	tstart = round_up(start, 2 * pgsz);
+	tend = round_down(end, 2 * pgsz);
+	if (tstart > tend)
+		return tlbfit(fti, start, end, npgsz, npgmask);
+
+	n = fti->ntlb;
+	/* check if we can use lo1 of an entry for the initial part */
+	if (tstart - start == pgsz && fti->limitlo_in <= tstart - 2 * pgsz)
+		addtlb(fti, start, pgsz, pgmask, 0x2);
+	else if (tstart != start)
+		tlbfit(fti, start, tstart, npgsz, npgmask);
+
+	/* map the 2 * pgsz aligned sections */
+	for (p = tstart; p < tend; p += 2 * pgsz)
+		addtlb(fti, p, pgsz, pgmask, 0x3);
+
+	/* handle the tail, similar to the initial part */
+	if (end - tend == pgsz && tend + 2 * pgsz <= fti->limithi_in)
+		addtlb(fti, tend, pgsz, pgmask, 0x1);
+	else if (end != tend)
+		tlbfit(fti, tend, end, npgsz, npgmask);
+
+	return fti->ntlb - n;	/* return number of TLBs used */
+}
+
+/*
+ * Compute the wired TLB entries needed to map the physical memory
+ * and update the boot data area. The other CPUs pick this up
+ * at bootup and setup their wired entries before entering kernel.
+ */
+void nlm_calc_wired_tlbs(void)
+{
+	struct fittlb_info ftlb = { 0 };
+	phys_addr_t astart, aend;
+	u32 *tlbcount;
+	int i, ni, mapsz;
+
+	mapsz = boot_mem_map.nr_map;
+	for (i = 0; i < mapsz; i = ni) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_RAM) {
+			ni = i + 1;
+			continue;
+		}
+		astart = boot_mem_map.map[i].addr;
+		aend =	astart + boot_mem_map.map[i].size + perf_backup;
+
+		pr_debug("astart %llx aend %llx\n", astart, aend);
+		/* fudge first entry for now  */
+		if (astart < 0x10000000) {
+			astart = 0;
+			aend = 0x10000000;
+		}
+
+		/* find the start of the next */
+		for (ni = i + 1; ni < mapsz &&
+				boot_mem_map.map[ni].type != BOOT_MEM_RAM; ni++)
+			;
+		if (ni == mapsz)
+			ftlb.limithi_in = ~(phys_addr_t)0;
+		else
+			ftlb.limithi_in = boot_mem_map.map[ni].addr;
+		ftlb.limithi_out = 0;
+		ftlb.limitlo_in = ~(phys_addr_t)0;
+		if (cpu_is_xlpii())
+			tlbfit(&ftlb, astart, aend, HTLBSZ, PM_HTLBSZ);
+		else
+			tlbfit(&ftlb, astart, aend, TLBSZ, PM_TLBSZ);
+
+		if (ftlb.ovf)
+			break;
+		ftlb.limitlo_in = ftlb.limithi_out;
+	}
+	if (ftlb.ovf) {
+		pr_err("No more TLBs, discarding memory from 0x%llx!\n",
+					(unsigned long long)ftlb.lastaddr);
+		boot_mem_map.nr_map = i + 1;
+		boot_mem_map.map[i].size = ftlb.lastaddr -
+						boot_mem_map.map[i].addr;
+	}
+	tlbcount = (u32 *)nlm_get_boot_data(BOOT_NTLBS);
+	*tlbcount = ftlb.ntlb;
+	pr_info("%d TLB entires used for mapped kernel.\n", ftlb.ntlb);
+}
diff --git a/arch/mips/netlogic/common/nlm-dma.c b/arch/mips/netlogic/common/nlm-dma.c
new file mode 100644
index 0000000..f3d4ae8
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm-dma.c
@@ -0,0 +1,107 @@
+/*
+*  Copyright (C) 2003-2013 Broadcom Corporation
+*  All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/bootmem.h>
+#include <linux/export.h>
+#include <linux/swiotlb.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+
+#include <asm/bootinfo.h>
+
+static char *nlm_swiotlb;
+
+static void *nlm_dma_alloc_coherent(struct device *dev, size_t size,
+	dma_addr_t *dma_handle, gfp_t gfp, struct dma_attrs *attrs)
+{
+	void *ret;
+
+	if (dma_alloc_from_coherent(dev, size, dma_handle, &ret))
+		return ret;
+
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_DMA32 | __GFP_HIGHMEM);
+
+#ifdef CONFIG_ZONE_DMA32
+	if (dev->coherent_dma_mask <= DMA_BIT_MASK(32))
+		gfp |= __GFP_DMA32;
+#endif
+
+	/* Don't invoke OOM killer */
+	gfp |= __GFP_NORETRY;
+
+	return swiotlb_alloc_coherent(dev, size, dma_handle, gfp);
+}
+
+static void nlm_dma_free_coherent(struct device *dev, size_t size,
+	void *vaddr, dma_addr_t dma_handle, struct dma_attrs *attrs)
+{
+	int order = get_order(size);
+
+	if (dma_release_from_coherent(dev, order, vaddr))
+		return;
+
+	swiotlb_free_coherent(dev, size, vaddr, dma_handle);
+}
+
+struct dma_map_ops nlm_swiotlb_dma_ops = {
+	.alloc = nlm_dma_alloc_coherent,
+	.free = nlm_dma_free_coherent,
+	.map_page = swiotlb_map_page,
+	.unmap_page = swiotlb_unmap_page,
+	.map_sg = swiotlb_map_sg_attrs,
+	.unmap_sg = swiotlb_unmap_sg_attrs,
+	.sync_single_for_cpu = swiotlb_sync_single_for_cpu,
+	.sync_single_for_device = swiotlb_sync_single_for_device,
+	.sync_sg_for_cpu = swiotlb_sync_sg_for_cpu,
+	.sync_sg_for_device = swiotlb_sync_sg_for_device,
+	.mapping_error = swiotlb_dma_mapping_error,
+	.dma_supported = swiotlb_dma_supported
+};
+
+void __init plat_swiotlb_setup(void)
+{
+	size_t swiotlbsize;
+	unsigned long swiotlb_nslabs;
+
+	swiotlbsize = 1 << 20; /* 1 MB for now */
+	swiotlb_nslabs = swiotlbsize >> IO_TLB_SHIFT;
+	swiotlb_nslabs = ALIGN(swiotlb_nslabs, IO_TLB_SEGSIZE);
+	swiotlbsize = swiotlb_nslabs << IO_TLB_SHIFT;
+
+	nlm_swiotlb = alloc_bootmem_low_pages(swiotlbsize);
+	swiotlb_init_with_tbl(nlm_swiotlb, swiotlb_nslabs, 1);
+}
diff --git a/arch/mips/netlogic/common/nlm_fs.h b/arch/mips/netlogic/common/nlm_fs.h
new file mode 100644
index 0000000..e8f1080
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_fs.h
@@ -0,0 +1,102 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+#ifndef _ASM_NLM_XLR_UACCESS_H
+#define _ASM_NLM_XLR_UACCESS_H
+
+
+#define NLM_FS_UNUSED             0
+#define NLM_FS_MSGSND             1
+#define NLM_FS_MSGRCV             2
+#define NLM_FS_C0_COUNT           3
+#define NLM_FS_MEM_READ           4
+#define NLM_FS_MEM_WRITE          5
+#define NLM_FS_MSGINT             6
+#define NLM_FS_READ_COP           7
+#define NLM_FS_PERFCTR_START      8
+#define NLM_FS_PERFCTR_STOP       9
+#define NLM_FS_READ_CPUMASKS      10
+#define NLM_FS_READ_PROCID        11
+#define NLM_FS_PROMINFO           12
+#define NLM_FS_READ_TIMER         13
+#define NLM_FS_HARD_CPUID         14
+#define NLM_FS_ENDIANESS          15
+#define NLM_FS_REVERSE_ENDIANESS  16
+#define NLM_FS_USPACE_64BIT_INS   17
+#define NLM_FS_CPU_MAX_FREQ       18
+#define NLM_FS_MEM_READ64         19
+#define NLM_FS_MEM_WRITE64        20
+#define NLM_FS_MEM_READ32         21
+#define NLM_FS_MEM_WRITE32        22
+#define NLM_FS_MSGSND3            23
+#define NLM_FS_MSGRCV1            24
+#define NLM_FS_MEM_READ16         25
+#define NLM_FS_MEM_WRITE16        26
+#define NLM_FS_MEM_READ8	  27
+#define NLM_FS_MEM_WRITE8	  28 
+
+#ifndef __ASSEMBLY__
+
+extern void nlm_fs_unused(void);
+extern void nlm_fs_mem_read8(void);
+extern void nlm_fs_mem_write8(void);
+extern void nlm_fs_mem_read16(void);
+extern void nlm_fs_mem_write16(void);
+extern void nlm_fs_mem_read32(void);
+extern void nlm_fs_mem_write32(void);
+extern void nlm_fs_mem_read64(void);
+extern void nlm_fs_mem_write64(void);
+extern void nlm_fs_msgsnd(void);
+extern void nlm_fs_msgrcv(void);
+extern void nlm_fs_c0_count(void);
+extern void nlm_fs_processorId(void);
+extern void nlm_fs_iomem_read(void);
+extern void nlm_fs_iomem_write(void);
+extern void nlm_fs_msg_read(void);
+extern void nlm_fs_perf_ctr_start(void);
+extern void nlm_fs_perf_ctr_stop(void);
+extern void nlm_fs_get_cpumasks(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_hard_cpuid(void);
+extern void nlm_fs_is_big_endian(void);
+extern void nlm_fs_is_endian_reversed(void);
+extern void nlm_fs_uspace_64bit_ins_enabled(void);
+extern void nlm_fs_cpu_max_freq(void);
+
+#if defined(CONFIG_NLM_XLR)
+extern void nlm_fs_prominfo(void);
+#else
+extern void nlm_fs_msgsnd3(void);
+extern void nlm_fs_msgrcv1(void);
+#endif /* CONFIG_NLM_XLR */
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_NLM_XLR_UACCESS_H */
diff --git a/arch/mips/netlogic/common/nlm_fs_handler.S b/arch/mips/netlogic/common/nlm_fs_handler.S
new file mode 100644
index 0000000..b5e1002
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_fs_handler.S
@@ -0,0 +1,533 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/asm-offsets.h>
+
+#include <asm/netlogic/interrupt.h>
+#include "perf_ctr.h"
+#include "nlm_fs.h"
+
+#ifdef CONFIG_32BIT
+	#define T0 t0
+	#define T1 t1
+	#define T2 t2
+	#define T3 t3
+	#define T4 t4
+	#define T5 t5
+	#define T6 t6
+	#define T7 t7
+#else
+	#define T0 ta0
+	#define T1 ta1
+	#define T2 ta2
+	#define T3 ta3
+	#define T4 t0
+	#define T5 t1
+	#define T6 t2
+	#define T7 t3
+#endif
+	.text
+	.set	push
+	.set	noreorder
+	.set	mips64
+	.align	5
+
+.macro	fs_eret
+	/* skip the syscall instruction */
+	MFC0    k0, CP0_EPC
+	PTR_ADDIU   k0, 4
+	MTC0    k0, CP0_EPC
+	eret
+.endm
+
+#if defined(CONFIG_NLM_XLR)
+
+NESTED(nlm_fs_msgsnd, PT_SIZE, sp)
+
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, $0, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, $0, 1
+
+	/* msgsnd dst is in t0 */
+1:	c2	0x80001
+	mfc2	T1, $2
+	andi	T1, T1, 0x06
+	bnez	T1, 1b
+	nop
+
+	fs_eret
+END(nlm_fs_msgsnd)
+
+NESTED(nlm_fs_msgrcv, PT_SIZE, sp)
+	/* t0 has the bucket arg */
+	c2	0x80002
+1:	mfc2	T3, $2
+	andi	k0, T3, 0x08
+	bnez	k0, 1b
+	nop
+	andi    T0, T3, 0x30
+	bnez	T0, 2f
+	nop
+	dmfc2	T2, $1, 0
+	dmfc2   T5, $1, 1
+	nop
+	dsra32  T1, T2, 0
+	dsra32  T4, T5, 0
+2:
+
+	/* move    t0, k0 */
+
+	fs_eret
+END(nlm_fs_msgrcv)
+
+NESTED(nlm_fs_get_cpumasks, PT_SIZE, sp)
+
+	.word 0x40088007
+	move k0, T0
+	srl  T0, T0, 4
+	andi T0, T0, 0x3f
+	sll  T0, T0, 2
+	andi k0, k0, 0x0f
+	or T0, T0, k0
+
+	PTR_LA k0, fast_syscall_cpumask_phy		;
+	lw T1, (k0)
+
+	fs_eret
+END(nlm_fs_get_cpumasks)
+
+NESTED(nlm_fs_prominfo, PT_SIZE, sp)
+
+	PTR_LA	k0, prom_info_copy
+	move	k1, T0
+	sll	k1, k1, 3
+	addu	k0, k0, k1
+	lw	T1, (k0)
+	lw	T2, 4(k0)
+
+	fs_eret
+END(nlm_fs_prominfo)
+
+#else /* CONFIG_NLM_XLR */
+
+#include "nlm_hal_xlp_dev.h"
+
+	.set	arch=xlp
+
+NESTED(nlm_fs_msgsnd3, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	/* msgsnd arg1 is in (t5, t6) */
+	dsll32  k0, T5, 0
+	dsll32	k1, T6, 0
+	dsrl32	T6, k1, 0
+	or      T5, k0, T6
+	dmtc2   T5, XLP_TX_BUF_REG, 2
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd3)
+
+NESTED(nlm_fs_msgsnd, PT_SIZE, sp)
+	/* msgsnd arg0 is in (t1, t2) */
+	dsll32  k0, T1, 0
+	dsll32	k1, T2, 0
+	dsrl32	T2, k1, 0
+	or      T1, k0, T2
+	dmtc2	T1, XLP_TX_BUF_REG, 0
+
+	/* msgsnd arg1 is in (t3, t4) */
+	dsll32  k0, T3, 0
+	dsll32	k1, T4, 0
+	dsrl32	T4, k1, 0
+	or      T3, k0, T4
+	dmtc2   T3, XLP_TX_BUF_REG, 1
+
+	sync
+
+	/* msgsnd dst is in t0, status returned in t1 */
+1:	msgsnds	T1, T0
+	beqz	T1, 1b /* comment out the branch              */
+	nop            /* for non-blocking msgsnd fastsyscall */
+
+	fs_eret
+END(nlm_fs_msgsnd)
+
+NESTED(nlm_fs_msgrcv, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dmfc2   T5, XLP_RX_BUF_REG, 1
+	dsra32  T1, T2, 0
+	dsra32  T4, T5, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv)
+
+NESTED(nlm_fs_msgrcv1, PT_SIZE, sp)
+	/* msgld vc is in t0, status returned in k0 */
+	msglds	k0, T0
+	beqz	k0, 1f
+	move	T0, k0
+
+	/* msgld status  t0       *
+	 * arg0          (t1, t2) *
+	 * msg_rxstatus  t3       *
+	 * arg1          (t4, t5) */
+	mfc2	T3, XLP_MSG_RXSTATUS_REG
+	dmfc2	T2, XLP_RX_BUF_REG, 0
+	dsra32  T1, T2, 0
+1:
+	fs_eret
+END(nlm_fs_msgrcv1)
+
+#endif /* CONFIG_CPU_XLP */
+
+NESTED(nlm_fs_mem_read64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	ld	T3, (T0)
+	dsra32	T2, T3, 0
+
+	fs_eret
+END(nlm_fs_mem_read64)
+
+NESTED(nlm_fs_mem_write64, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in (t2, t3) */
+	dsll32  k0, T2, 0
+	dsll32	k1, T3, 0
+	dsrl32	T3, k1, 0
+	or      T1, k0, T3
+
+	sd	T1, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write64)
+
+NESTED(nlm_fs_mem_read32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	lw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_read32)
+
+NESTED(nlm_fs_mem_write32, PT_SIZE, sp)
+	/* address is in (t0, t1) */
+	dsll32  k0, T0, 0
+	dsll32	k1, T1, 0
+	dsrl32	T1, k1, 0
+	or      T0, k0, T1
+
+	/* data is in t2 */
+	sw	T2, (T0)
+
+	fs_eret
+END(nlm_fs_mem_write32)
+
+NESTED(nlm_fs_mem_read16, PT_SIZE, sp)
+       /* address is in (t0-msb, t1-lsb) */
+       dsll32  k0, T0, 0
+       dsll32  k1, T1, 0
+       dsrl32  T1, k1, 0
+       or      T0, k0, T1
+
+       /* data is in t2 */
+       lh      T2, (T0)
+       fs_eret
+END(nlm_fs_mem_read16)
+
+NESTED(nlm_fs_mem_write16, PT_SIZE, sp)
+        /* address is in (t0-msb, t1-lsb) */
+        dsll32  k0, T0, 0
+        dsll32  k1, T1, 0
+        dsrl32  T1, k1, 0
+        or      T0, k0, T1
+
+        /* data is in t2 */
+        sh      T2, (T0)
+        fs_eret
+END(nlm_fs_mem_write16)
+
+NESTED(nlm_fs_mem_read8, PT_SIZE, sp)
+       /* address is in (t0-msb, t1-lsb) */
+       dsll32  k0, T0, 0
+       dsll32  k1, T1, 0
+       dsrl32  T1, k1, 0
+       or      T0, k0, T1
+
+       /* data is in t2 */
+       lb      T2, (T0)
+       fs_eret
+END(nlm_fs_mem_read16)
+
+NESTED(nlm_fs_mem_write8, PT_SIZE, sp)
+        /* address is in (t0-msb, t1-lsb) */
+        dsll32  k0, T0, 0
+        dsll32  k1, T1, 0
+        dsrl32  T1, k1, 0
+        or      T0, k0, T1
+
+        /* data is in t2 */
+        sb      T2, (T0)
+        fs_eret
+END(nlm_fs_mem_write16)
+
+NESTED(nlm_fs_c0_count, PT_SIZE, sp)
+
+	mfc0    T0, $9, 0
+
+	fs_eret
+END(nlm_fs_c0_count)
+
+NESTED(nlm_fs_iomem_read, PT_SIZE, sp)
+
+	/* t0 has the address */
+	lw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_read)
+
+NESTED(nlm_fs_iomem_write, PT_SIZE, sp)
+
+	/* t0 has the address, t1 has the data */
+	sw      T1, (T0)
+
+	fs_eret
+END(nlm_fs_iomem_write)
+
+
+NESTED(nlm_fs_msg_write, PT_SIZE, sp)
+
+	/* disable the message ring interrupts and enable 64 bits operations */
+	mfc0    k0, CP0_STATUS
+	li      k1, 1
+	dsll    k1, k1, 30
+	or      k0, k0, k1
+	li      k1, 1
+	dsll    k1, k1, 23
+	or      k0, k0, k1
+	mtc0    k0, CP0_STATUS
+	bnez	T1, 1f
+	nop
+	mtc2    T1, $3, 0
+1:
+
+	fs_eret
+END(nlm_fs_msg_write)
+
+
+NESTED(nlm_fs_msg_read, PT_SIZE, sp)
+
+	/* read C0 and C2 registers */
+	mfc0    T0, CP0_STATUS
+	mfc2    T1, $2, 0
+	mfc2    T2, $2, 1
+	mfc2    T3, $3, 0
+	mfc2    T4, $3, 1
+
+	fs_eret
+END(nlm_fs_msg_read)
+
+NESTED(nlm_fs_perf_ctr_start, PT_SIZE, sp)
+
+	/* reset value counters */
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dmtc0    $0, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+
+	/* arm the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T1, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	fs_eret
+END(nlm_fs_perf_ctr_start)
+
+	/* {evt@0:hi=T1, evt@0:lo=T0}
+	 * {evt@1:hi=T3, evt@1:lo=T2}
+	 * nlm_fs_perf_ctr_stop(uint32_t val) */
+NESTED(nlm_fs_perf_ctr_stop, PT_SIZE, sp)
+
+	/* stop the counters */
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT0
+	mtc0    T0, CP0_PERF_CTR, PERF_CTR_EVENT1
+
+	/* load return values */
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT0_VALUE
+	dsrl32 	 T1, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T0, k1, 0
+
+	dmfc0    k1, CP0_PERF_CTR, PERF_CTR_EVENT1_VALUE
+	dsrl32 	 T3, k1, 0
+	dsll32   k1, k1, 0
+	dsrl32   T2, k1, 0
+
+	fs_eret
+END(nlm_fs_perf_ctr_stop)
+
+NESTED(nlm_fs_processorId, PT_SIZE, sp)
+
+	mfc0    T0, $15, 0
+
+	fs_eret
+END(nlm_fs_processorId)
+
+NESTED(nlm_fs_read_timer, PT_SIZE, sp)
+
+#if defined(CONFIG_CPU_XLP)
+#include <nlm_hal_pic.h>
+        MFC0    k0, CP0_PRID, 1
+        andi    k0, k0, 0x3ff
+        srl     k0, k0, 5  /* grab node id */
+        sll     k0, k0, 18 /* Use local PIC */
+        dli     k1, ASM_XLP_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER << 3)
+        dadd    k0, k1, k0
+	ld	k1, 0(k0)
+	dsrl32	$9, k1, 0
+	dsll32  $8, k1, 0
+	dsrl32  $8, T0, 0
+#else
+	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_0 << 2)
+	lw	$8, 0(k0)
+	dli	k0, 0xffffffffbef00000 + NETLOGIC_IO_PIC_OFFSET + (PIC_TIMER_6_COUNTER_1 << 2)
+	lw	$9, 0(k0)
+#endif
+	fs_eret
+
+END(nlm_fs_read_timer)
+
+NESTED(nlm_fs_hard_cpuid, PT_SIZE, sp)
+
+	mfc0	T0, $15, 1
+	andi	T0, T0, 0x3ff
+
+	fs_eret
+
+END(nlm_fs_hard_cpuid)
+
+NESTED(nlm_fs_is_big_endian, PT_SIZE, sp)
+	mfc0	T0, $16, 0
+	andi	T0, T0, 0x8000
+
+	fs_eret
+END(nlm_fs_is_big_endian)
+
+NESTED(nlm_fs_is_endian_reversed, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x2000000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_is_endian_reversed)
+
+NESTED(nlm_fs_uspace_64bit_ins_enabled, PT_SIZE, sp)
+	mfc0	T0, $12, 0
+	li	k1, 0x800000
+	and	T0, T0, k1
+
+	fs_eret
+END(nlm_fs_uspace_64bit_ins_enabled)
+
+	/* {hi=T1, lo=T0} nlm_fs_cpu_max_freq(void) */
+NESTED(nlm_fs_cpu_max_freq, PT_SIZE, sp)
+	PTR_LA k0, mips_hpt_frequency
+	lw     k1, 0(k0)
+	dsrl32 T1, k1, 0
+	dsll32 k1, k1, 0
+	dsrl32 T0, k1, 0
+
+	fs_eret
+END(nlm_fs_cpu_max_freq)
+
+LEAF(nlm_fs_unused)
+	fs_eret
+END(nlm_fs_unused)
+
+	.set pop
+
+
diff --git a/arch/mips/netlogic/common/nlm_fs_tbl.c b/arch/mips/netlogic/common/nlm_fs_tbl.c
new file mode 100644
index 0000000..1ca04cb
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_fs_tbl.c
@@ -0,0 +1,77 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#include <linux/kernel.h>
+#include <linux/export.h>
+
+#include "nlm_fs.h"
+
+unsigned long nlm_fs_table[] = {
+	[NLM_FS_UNUSED]           = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGSND]           = (unsigned long)nlm_fs_msgsnd,
+	[NLM_FS_MSGRCV]           = (unsigned long)nlm_fs_msgrcv,
+	[NLM_FS_C0_COUNT]         = (unsigned long)nlm_fs_c0_count,
+	[NLM_FS_MEM_READ]         = (unsigned long)nlm_fs_iomem_read,
+	[NLM_FS_MEM_WRITE]        = (unsigned long)nlm_fs_iomem_write,
+	[NLM_FS_MSGINT]           = (unsigned long)nlm_fs_unused,
+	[NLM_FS_READ_COP]         = (unsigned long)nlm_fs_msg_read,
+	[NLM_FS_PERFCTR_START]    = (unsigned long)nlm_fs_perf_ctr_start,
+	[NLM_FS_PERFCTR_STOP]     = (unsigned long)nlm_fs_perf_ctr_stop,
+	[NLM_FS_CPU_MAX_FREQ]     = (unsigned long)nlm_fs_cpu_max_freq,
+	[NLM_FS_READ_PROCID]      = (unsigned long)nlm_fs_processorId,
+	[NLM_FS_READ_TIMER]       = (unsigned long)nlm_fs_read_timer,
+	[NLM_FS_HARD_CPUID]       = (unsigned long)nlm_fs_hard_cpuid,
+	[NLM_FS_ENDIANESS]        = (unsigned long)nlm_fs_is_big_endian,
+	[NLM_FS_REVERSE_ENDIANESS]= (unsigned long)nlm_fs_is_endian_reversed,
+	[NLM_FS_USPACE_64BIT_INS] = (unsigned long)nlm_fs_uspace_64bit_ins_enabled,
+	[NLM_FS_MEM_READ64]       = (unsigned long)nlm_fs_mem_read64,
+	[NLM_FS_MEM_WRITE64]      = (unsigned long)nlm_fs_mem_write64,
+	[NLM_FS_MEM_READ32]       = (unsigned long)nlm_fs_mem_read32,
+	[NLM_FS_MEM_WRITE32]      = (unsigned long)nlm_fs_mem_write32,
+
+#if defined(CONFIG_NLM_XLR)
+	[NLM_FS_READ_CPUMASKS]    = (unsigned long)nlm_fs_get_cpumasks,
+	[NLM_FS_PROMINFO]         = (unsigned long)nlm_fs_prominfo,
+	[NLM_FS_MSGSND3]          = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGRCV1]          = (unsigned long)nlm_fs_unused,
+#else
+	[NLM_FS_READ_CPUMASKS]    = (unsigned long)nlm_fs_unused,
+	[NLM_FS_PROMINFO]         = (unsigned long)nlm_fs_unused,
+	[NLM_FS_MSGSND3]          = (unsigned long)nlm_fs_msgsnd3,
+	[NLM_FS_MSGRCV1]          = (unsigned long)nlm_fs_msgrcv1,
+#endif /* CONFIG_NLM_XLR */
+	[NLM_FS_MEM_READ16]       = (unsigned long)nlm_fs_mem_read16,
+	[NLM_FS_MEM_WRITE16]      = (unsigned long)nlm_fs_mem_write16,
+	[NLM_FS_MEM_READ8]        = (unsigned long)nlm_fs_mem_read8,
+	[NLM_FS_MEM_WRITE8]       = (unsigned long)nlm_fs_mem_write8,
+	0
+};
+
+
diff --git a/arch/mips/netlogic/common/perf_ctr.h b/arch/mips/netlogic/common/perf_ctr.h
new file mode 100644
index 0000000..447a019
--- /dev/null
+++ b/arch/mips/netlogic/common/perf_ctr.h
@@ -0,0 +1,72 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef __ASM_NLM_PERF_CTR_H
+#define __ASM_NLM_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_NLM_PERF_CTR_H */
diff --git a/arch/mips/netlogic/common/reset.S b/arch/mips/netlogic/common/reset.S
new file mode 100644
index 0000000..e7ebb47
--- /dev/null
+++ b/arch/mips/netlogic/common/reset.S
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2003-2013 Broadcom Corporation.
+ * All Rights Reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/cacheops.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/asmmacro.h>
+#include <asm/addrspace.h>
+
+#include <kernel-entry-init.h>
+#include <asm/netlogic/common.h>
+
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/netlogic/xlp-hal/cpucontrol.h>
+
+#define CP0_EBASE	$15
+#define SYS_CPU_COHERENT_BASE	CKSEG1ADDR(XLP_DEFAULT_IO_BASE) + \
+			XLP_IO_SYS_OFFSET(0) + XLP_IO_PCI_HDRSZ + \
+			SYS_CPU_NONCOHERENT_MODE * 4
+
+/* Enable XLP features and workarounds in the LSU */
+.macro xlp_config_lsu
+	li	t0, LSU_DEFEATURE
+	mfcr	t1, t0
+
+#ifdef CONFIG_MAPPED_KERNEL
+	lui	t2, 0x4080	/* Unaligned Access, L2HPE */
+#else
+	lui	t2, 0xc080	/* SUE, Unaligned Access, L2HPE */
+#endif
+	or	t1, t1, t2
+	mtcr	t1, t0
+
+	li	t0, SCHED_DEFEATURE
+	lui	t1, 0x0100	/* Disable BRU accepting ALU ops */
+	mtcr	t1, t0
+.endm
+
+/*
+ * Low level flush for L1D cache on XLP, the normal cache ops does
+ * not do the complete and correct cache flush.
+ */
+.macro	xlp_flush_l1_dcache
+	mfc0	t0, CP0_EBASE, 0
+	andi	t0, t0, 0xff00
+	slt	t1, t0, 0x1200
+	beqz	t1, 15f
+	nop
+
+	li	t0, LSU_DEBUG_DATA0
+	li	t1, LSU_DEBUG_ADDR
+	li	t2, 0		/* index */
+	li	t3, 0x1000	/* loop count */
+11:
+	sll	v0, t2, 5
+	mtcr	zero, t0
+	ori	v1, v0, 0x3	/* way0 | write_enable | write_active */
+	mtcr	v1, t1
+12:
+	mfcr	v1, t1
+	andi	v1, 0x1		/* wait for write_active == 0 */
+	bnez	v1, 12b
+	nop
+	mtcr	zero, t0
+	ori	v1, v0, 0x7	/* way1 | write_enable | write_active */
+	mtcr	v1, t1
+13:
+	mfcr	v1, t1
+	andi	v1, 0x1		/* wait for write_active == 0 */
+	bnez	v1, 13b
+	nop
+	addi	t2, 1
+	bne	t3, t2, 11b
+	nop
+	beqz	zero, 21f
+	nop
+15:
+	/* Invalidate all 64k of L1 D-cache */
+	li	t0, 0x80000000
+	li	t1, 0x80010000
+20:	cache	Index_Writeback_Inv_D, 0(t0)
+	addiu	t0, t0, 32
+	bne	t0, t1, 20b
+	nop
+21:
+
+.endm
+
+	/* Errata: Disable 2way L1 D-cache on XLP2xx A0 chips */
+.macro xlp2xx_setup_l1dcache
+	/* Check for XLP2xx */
+	mfc0	t0, CP0_EBASE, 0	/* Read processor ID */
+	andi	t0, t0, 0xffff
+	li	t1, 0x1200		/* XLP 2xx A0 PRID */
+	bne	t0, t1, 15f
+	nop
+
+	/* Disable 2way L1 D-cache, set 0 to 15th bit disables 2way */
+	li	t0, LSU_DEFEATURE
+	li	t1, 0xfa406038
+	mtcr	t1, t0
+	_ehb
+15:
+.endm
+
+/*
+ * nlm_reset_entry will be copied to the reset entry point for
+ * XLR and XLP. The XLP cores start here when they are woken up. This
+ * is also the NMI entry point.
+ *
+ * We use scratch reg 6/7 to save k0/k1 and check for NMI first.
+ *
+ * The data corresponding to reset/NMI is stored at RESET_DATA_PHYS
+ * location, this will have the thread mask (used when core is woken up)
+ * and the current NMI handler in case we reached here for an NMI.
+ *
+ * When a core or thread is newly woken up, it marks itself ready and
+ * loops in a 'wait'. When the CPU really needs waking up, we send an NMI
+ * IPI to it, with the NMI handler set to prom_boot_secondary_cpus
+ */
+	.set	noreorder
+	.set	noat
+	.set	arch=xlr	/* for mfcr/mtcr, XLR is sufficient */
+
+FEXPORT(nlm_reset_entry)
+	dmtc0	k0, $22, 6
+	dmtc0	k1, $22, 7
+	mfc0	k0, CP0_STATUS
+	li	k1, 0x80000
+	and	k1, k0, k1
+	beqz	k1, 1f		/* go to real reset entry */
+	nop
+	li	k1, CKSEG1ADDR(RESET_DATA_PHYS) /* NMI */
+	ld	k0, BOOT_NMI_HANDLER(k1)
+	jr	k0
+	nop
+
+1:	/* Entry point on core wakeup */
+	mfc0	t0, CP0_EBASE, 0	/* processor ID */
+	andi	t0, 0xff00
+	li	t1, 0x1500		/* XLP 9xx */
+	beq	t0, t1, 2f		/* does not need to set coherent */
+	nop
+
+	/* set bit in SYS coherent register for the core */
+	mfc0	t0, CP0_EBASE, 1
+	mfc0	t1, CP0_EBASE, 1
+	srl	t1, 5
+	andi	t1, 0x3			/* t1 <- node */
+	li	t2, 0x40000
+	mul	t3, t2, t1		/* t3 = node * 0x40000 */
+	srl	t0, t0, 2
+	and	t0, t0, 0x7		/* t0 <- core */
+	li	t1, 0x1
+	sll	t0, t1, t0
+	nor	t0, t0, zero		/* t0 <- ~(1 << core) */
+	li	t2, SYS_CPU_COHERENT_BASE
+	add	t2, t2, t3		/* t2 <- SYS offset for node */
+	lw	t1, 0(t2)
+	and	t1, t1, t0
+	sw	t1, 0(t2)
+
+	/* read back to ensure complete */
+	lw	t1, 0(t2)
+	sync
+
+2:
+	/* Configure LSU on Non-0 Cores. */
+	xlp_config_lsu
+	/* FALL THROUGH */
+
+/*
+ * Wake up sibling threads from the initial thread in a core.
+ */
+EXPORT(nlm_boot_siblings)
+	/* core L1D flush before enable threads */
+	xlp_flush_l1_dcache
+
+	/* CPU0 L1 D-cache 2way access disabled by U-boot */
+	xlp2xx_setup_l1dcache
+
+	/* Enable hw threads by writing to MAP_THREADMODE of the core */
+	li	t0, CKSEG1ADDR(RESET_DATA_PHYS)
+	lw	t1, BOOT_THREAD_MODE(t0)	/* t1 <- thread mode */
+	li	t0, ((CPU_BLOCKID_MAP << 8) | MAP_THREADMODE)
+	mfcr	t2, t0
+	or	t2, t2, t1
+	mtcr	t2, t0
+
+	/*
+	 * The new hardware thread starts at the next instruction
+	 * For all the cases other than core 0 thread 0, we will
+	 * jump to the secondary wait function.
+
+	 * NOTE: All GPR contents are lost after the mtcr above!
+	 */
+	mfc0	v0, CP0_EBASE, 1
+	andi	v0, 0x3ff		/* v0 <- node/core */
+
+#ifndef CONFIG_MAPPED_KERNEL
+	/* Errata: to avoid potential live lock, only apply to 4
+	 * thread per core mode */
+	andi	v1, v0, 0x3             /* v1 <- thread id */
+	bnez	v1, 2f
+	nop
+
+	/* thread 0 of each core. */
+	li	t0, CKSEG1ADDR(RESET_DATA_PHYS)
+	lw	t1, BOOT_THREAD_MODE(t0)        /* t1 <- thread mode */
+	subu	t1, 0x3				/* 4-thread per core mode? */
+	bnez	t1, 2f
+	nop
+
+	li	t0, IFU_BRUB_RESERVE
+	li	t1, 0x55
+	mtcr	t1, t0
+	_ehb
+2:
+#endif
+	beqz	v0, 4f		/* boot cpu (cpuid == 0)? */
+	nop
+
+	/* setup status reg */
+	move	t1, zero
+#ifdef CONFIG_64BIT
+	ori	t1, ST0_KX
+#endif
+	mtc0	t1, CP0_STATUS
+
+	/* mark CPU ready */
+	li	t3, CKSEG1ADDR(RESET_DATA_PHYS)
+	ADDIU	t1, t3, BOOT_CPU_READY
+	sll	v1, v0, 2
+	PTR_ADDU t1, v1
+	li	t2, 1
+	sw	t2, 0(t1)
+
+	/* mapped first wired TLB for mapped kernel */
+	kernel_entry_setup
+
+	/* Wait until NMI hits */
+3:	wait
+	b	3b
+	nop
+
+	/*
+	 * For the boot CPU, we have to restore registers and
+	 * return
+	 */
+4:	dmfc0	t0, $4, 2	/* restore SP from UserLocal */
+	li	t1, 0xfadebeef
+	dmtc0	t1, $4, 2	/* restore SP from UserLocal */
+	PTR_SUBU sp, t0, PT_SIZE
+	RESTORE_ALL
+	jr	ra
+	nop
+EXPORT(nlm_reset_entry_end)
+
+LEAF(nlm_init_boot_cpu)
+#ifdef CONFIG_CPU_XLP
+	xlp_config_lsu
+#endif
+	jr	ra
+	nop
+END(nlm_init_boot_cpu)
+
+LEAF(nlm_setup_wired_tlbs)
+#ifdef CONFIG_MAPPED_KERNEL
+	li	t0, CKSEG1ADDR(RESET_DATA_PHYS)
+	lw	t3, BOOT_NTLBS(t0)
+	ADDIU	t0, t0, BOOT_TLBS_START
+	li	t1, 1		/* entry 0 is wired at boot, start at 1 */
+	addiu	t3, 1		/* final number of wired entries */
+
+1:	sltu	v1, t1, t3
+	beqz	v1, 2f
+	nop
+	ld	a0, (8 * BOOT_TLB_ENTRYLO0)(t0)
+	dmtc0	a0, CP0_ENTRYLO0
+	ld	a1, (8 * BOOT_TLB_ENTRYLO1)(t0)
+	dmtc0	a1, CP0_ENTRYLO1
+	ld	a2, (8 * BOOT_TLB_ENTRYHI)(t0)
+	dmtc0	a2, CP0_ENTRYHI
+	ld	a2, (8 * BOOT_TLB_PAGEMASK)(t0)
+	dmtc0	a2, CP0_PAGEMASK
+	mtc0	t1, CP0_INDEX
+	_ehb
+	tlbwi
+	ADDIU	t0, BOOT_TLB_SIZE
+	addiu	t1, 1
+	b	1b
+	nop
+2:
+	mtc0	t3, CP0_WIRED
+	JRHB	ra
+#else
+	jr	ra
+#endif
+	nop
+END(nlm_setup_wired_tlbs)
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index ffba524..560bdd2 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -63,7 +63,7 @@ void nlm_send_ipi_single(int logical_cpu, unsigned int action)
 	uint64_t picbase;
 
 	cpu = cpu_logical_map(logical_cpu);
-	node = cpu / NLM_CPUS_PER_NODE;
+	node = nlm_cpuid_to_node(cpu);
 	picbase = nlm_get_node(node)->picbase;
 
 	if (action & SMP_CALL_FUNCTION)
@@ -106,9 +106,8 @@ void nlm_early_init_secondary(int cpu)
 {
 	change_c0_config(CONF_CM_CMASK, 0x3);
 #ifdef CONFIG_CPU_XLP
-	/* mmu init, once per core */
-	if (cpu % NLM_THREADS_PER_CORE == 0)
-		xlp_mmu_init();
+	xlp_mmu_init();
+	pgwalker_init();
 #endif
 	write_c0_ebase(nlm_current_node()->ebase);
 }
@@ -130,6 +129,10 @@ void nlm_prepare_cpus(unsigned int max_cpus)
 {
 	/* declare we are SMT capable */
 	smp_num_siblings = nlm_threads_per_core;
+#ifdef CONFIG_CPU_XLP
+	/* hardware page walker configuration for boot cpu */
+	pgwalker_init();
+#endif
 }
 
 void nlm_smp_finish(void)
@@ -137,15 +140,114 @@ void nlm_smp_finish(void)
 	local_irq_enable();
 }
 
-void nlm_cpus_done(void)
+#ifdef CONFIG_KVM
+
+static atomic_t __cpuinitdata count_count_start = ATOMIC_INIT(0);
+static atomic_t __cpuinitdata count_count_stop = ATOMIC_INIT(0);
+static atomic_t __cpuinitdata tsc_count_start_flag = ATOMIC_INIT(0);
+static atomic64_t __cpuinitdata tsc_count_reference = ATOMIC_INIT(0);
+
+#define NR_LOOPS 5
+
+/* sync TSC at all cores */
+static void __init nlm_sync_tsc_ipi(void *args)
 {
+	int i;
+	unsigned long flags;
+	uint64_t tsc_initcount;
+
+	(void)args;
+
+	if (smp_processor_id() == 0) {
+		int nslaves;
+
+		printk(KERN_INFO "Synchronize TSC counters across %u CPUs: ",
+			num_online_cpus());
+
+		/* we are the master. */
+		local_irq_save(flags);
+
+		/*
+		 * Notify the other cpus to start.
+		 */
+		atomic_set(&tsc_count_reference, nlm_read_tsc());
+		atomic_set(&tsc_count_start_flag, 1);
+		smp_wmb();
+
+		tsc_initcount = nlm_read_tsc();
+		nslaves = num_online_cpus()-1;
+		for (i = 0; i < NR_LOOPS; i++) {
+			/* slaves loop on '!= ncpus' */
+			while (atomic_read(&count_count_start) != nslaves)
+				mb();
+			atomic_set(&count_count_stop, 0);
+			smp_wmb();
+
+			/* this lets the slaves write their count register */
+			atomic_inc(&count_count_start);
+
+			/*
+			 * Everyone initialises count in the last loop:
+			 */
+			if (i == NR_LOOPS-1) {
+				nlm_write_tsc(tsc_initcount);
+			}
+
+			/*
+			 * Wait for all slaves to leave the synchronization point:
+			 */
+			while (atomic_read(&count_count_stop) != nslaves)
+				mb();
+			atomic_set(&count_count_start, 0);
+			smp_wmb();
+			atomic_inc(&count_count_stop);
+		}
+		local_irq_restore(flags);
+
+		printk("done.\n");
+	} else {
+		int ncpus;
+
+		local_irq_save(flags);
+		while (!atomic_read(&tsc_count_start_flag))
+			mb();
+
+		tsc_initcount = atomic64_read(&tsc_count_reference);
+		ncpus = num_online_cpus();
+		for (i = 0; i < NR_LOOPS; i++) {
+			atomic_inc(&count_count_start);
+			while (atomic_read(&count_count_start) != ncpus)
+				mb();
+
+			/*
+			 * Everyone initialises count in the last loop:
+			 */
+			if (i == NR_LOOPS-1) {
+				if ((hard_smp_processor_id() & 0x3) == 0)
+					nlm_write_tsc(tsc_initcount);
+			}
+
+			atomic_inc(&count_count_stop);
+			while (atomic_read(&count_count_stop) != ncpus)
+				mb();
+		}
+
+		local_irq_restore(flags);
+	}
+}
+#endif
+
+void __init nlm_cpus_done(void)
+{
+#ifdef CONFIG_KVM
+	on_each_cpu(nlm_sync_tsc_ipi, (void *)NULL, 0);
+#endif
 }
 
 /*
  * Boot all other cpus in the system, initialize them, and bring them into
  * the boot function
  */
-int nlm_cpu_ready[NR_CPUS];
 unsigned long nlm_next_gp;
 unsigned long nlm_next_sp;
 static cpumask_t phys_cpu_present_mask;
@@ -155,7 +257,7 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 	int cpu, node;
 
 	cpu = cpu_logical_map(logical_cpu);
-	node = cpu / NLM_CPUS_PER_NODE;
+	node = nlm_cpuid_to_node(logical_cpu);
 	nlm_next_sp = (unsigned long)__KSTK_TOS(idle);
 	nlm_next_gp = (unsigned long)task_thread_info(idle);
 
@@ -167,8 +269,9 @@ void nlm_boot_secondary(int logical_cpu, struct task_struct *idle)
 void __init nlm_smp_setup(void)
 {
 	unsigned int boot_cpu;
-	int num_cpus, i, ncore;
-	char buf[64];
+	int num_cpus, i, ncore, node;
+	volatile u32 *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+	char buf[129];
 
 	boot_cpu = hard_smp_processor_id();
 	cpumask_clear(&phys_cpu_present_mask);
@@ -177,18 +280,21 @@ void __init nlm_smp_setup(void)
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
 	set_cpu_possible(0, true);
+	cpumask_set_cpu(0, &nlm_get_node(0)->cpumask);
 
 	num_cpus = 1;
 	for (i = 0; i < NR_CPUS; i++) {
 		/*
-		 * nlm_cpu_ready array is not set for the boot_cpu,
+		 * cpu_ready array is not set for the boot_cpu,
 		 * it is only set for ASPs (see smpboot.S)
 		 */
-		if (nlm_cpu_ready[i]) {
+		if (cpu_ready[i]) {
 			cpumask_set_cpu(i, &phys_cpu_present_mask);
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
 			set_cpu_possible(num_cpus, true);
+			node = nlm_cpuid_to_node(i);
+			cpumask_set_cpu(num_cpus, &nlm_get_node(node)->cpumask);
 			++num_cpus;
 		}
 	}
@@ -198,9 +304,12 @@ void __init nlm_smp_setup(void)
 	cpumask_scnprintf(buf, ARRAY_SIZE(buf), cpu_possible_mask);
 	pr_info("Possible CPU mask: %s\n", buf);
 
-	/* check with the cores we have worken up */
-	for (ncore = 0, i = 0; i < NLM_NR_NODES; i++)
+	/* check with the cores we have woken up */
+	for (ncore = 0, i = 0; i < NLM_NR_NODES; i++) {
 		ncore += hweight32(nlm_get_node(i)->coremask);
+		cpumask_scnprintf(buf, ARRAY_SIZE(buf), &nlm_get_node(i)->cpumask);
+		pr_info("\tnode %d: %s\n", i, buf);
+	}
 
 	pr_info("Detected (%dc%dt) %d Slave CPU(s)\n", ncore,
 		nlm_threads_per_core, num_cpus);
@@ -214,6 +323,7 @@ static int nlm_parse_cpumask(cpumask_t *wakeup_mask)
 	uint32_t core0_thr_mask, core_thr_mask;
 	int threadmode, i, j;
 
+	/* Get Core 0 thread mask and value for thread mode register */
 	core0_thr_mask = 0;
 	for (i = 0; i < NLM_THREADS_PER_CORE; i++)
 		if (cpumask_test_cpu(i, wakeup_mask))
@@ -254,21 +364,15 @@ unsupp:
 
 int __cpuinit nlm_wakeup_secondary_cpus(void)
 {
-	unsigned long reset_vec;
-	char *reset_data;
+	u32 *reset_data;
 	int threadmode;
 
-	/* Update reset entry point with CPU init code */
-	reset_vec = CKSEG1ADDR(RESET_VEC_PHYS);
-	memcpy((void *)reset_vec, (void *)nlm_reset_entry,
-			(nlm_reset_entry_end - nlm_reset_entry));
-
 	/* verify the mask and setup core config variables */
 	threadmode = nlm_parse_cpumask(&nlm_cpumask);
 
 	/* Setup CPU init parameters */
-	reset_data = (char *)CKSEG1ADDR(RESET_DATA_PHYS);
-	*(int *)(reset_data + BOOT_THREAD_MODE) = threadmode;
+	reset_data = nlm_get_boot_data(BOOT_THREAD_MODE);
+	*reset_data = threadmode;
 
 #ifdef CONFIG_CPU_XLP
 	xlp_wakeup_secondary_cpus();
diff --git a/arch/mips/netlogic/common/smpboot.S b/arch/mips/netlogic/common/smpboot.S
index 0265174..32add19 100644
--- a/arch/mips/netlogic/common/smpboot.S
+++ b/arch/mips/netlogic/common/smpboot.S
@@ -41,7 +41,9 @@
 #include <asm/stackframe.h>
 #include <asm/asmmacro.h>
 #include <asm/addrspace.h>
+#include <asm/cacheops.h>
 
+#include <kernel-entry-init.h>
 #include <asm/netlogic/common.h>
 
 #include <asm/netlogic/xlp-hal/iomap.h>
@@ -50,197 +52,12 @@
 #include <asm/netlogic/xlp-hal/cpucontrol.h>
 
 #define CP0_EBASE	$15
-#define SYS_CPU_COHERENT_BASE(node)	CKSEG1ADDR(XLP_DEFAULT_IO_BASE) + \
-			XLP_IO_SYS_OFFSET(node) + XLP_IO_PCI_HDRSZ + \
-			SYS_CPU_NONCOHERENT_MODE * 4
-
-#define XLP_AX_WORKAROUND	/* enable Ax silicon workarounds */
-
-/* Enable XLP features and workarounds in the LSU */
-.macro xlp_config_lsu
-	li	t0, LSU_DEFEATURE
-	mfcr	t1, t0
-
-	lui	t2, 0xc080	/* SUE, Enable Unaligned Access, L2HPE */
-	or	t1, t1, t2
-#ifdef XLP_AX_WORKAROUND
-	li	t2, ~0xe	/* S1RCM */
-	and	t1, t1, t2
-#endif
-	mtcr	t1, t0
-
-	li	t0, ICU_DEFEATURE
-	mfcr	t1, t0
-	ori	t1, 0x1000	/* Enable Icache partitioning */
-	mtcr	t1, t0
-
-
-#ifdef XLP_AX_WORKAROUND
-	li	t0, SCHED_DEFEATURE
-	lui	t1, 0x0100	/* Disable BRU accepting ALU ops */
-	mtcr	t1, t0
-#endif
-.endm
-
-/*
- * This is the code that will be copied to the reset entry point for
- * XLR and XLP. The XLP cores start here when they are woken up. This
- * is also the NMI entry point.
- */
-.macro	xlp_flush_l1_dcache
-	li	t0, LSU_DEBUG_DATA0
-	li	t1, LSU_DEBUG_ADDR
-	li	t2, 0		/* index */
-	li	t3, 0x1000	/* loop count */
-1:
-	sll	v0, t2, 5
-	mtcr	zero, t0
-	ori	v1, v0, 0x3	/* way0 | write_enable | write_active */
-	mtcr	v1, t1
-2:
-	mfcr	v1, t1
-	andi	v1, 0x1		/* wait for write_active == 0 */
-	bnez	v1, 2b
-	nop
-	mtcr	zero, t0
-	ori	v1, v0, 0x7	/* way1 | write_enable | write_active */
-	mtcr	v1, t1
-3:
-	mfcr	v1, t1
-	andi	v1, 0x1		/* wait for write_active == 0 */
-	bnez	v1, 3b
-	nop
-	addi	t2, 1
-	bne	t3, t2, 1b
-	nop
-.endm
-
-/*
- * The cores can come start when they are woken up. This is also the NMI
- * entry, so check that first.
- *
- * The data corresponding to reset/NMI is stored at RESET_DATA_PHYS
- * location, this will have the thread mask (used when core is woken up)
- * and the current NMI handler in case we reached here for an NMI.
- *
- * When a core or thread is newly woken up, it loops in a 'wait'. When
- * the CPU really needs waking up, we send an NMI to it, with the NMI
- * handler set to prom_boot_secondary_cpus
- */
 
 	.set	noreorder
 	.set	noat
-	.set	arch=xlr	/* for mfcr/mtcr, XLR is sufficient */
-
-FEXPORT(nlm_reset_entry)
-	dmtc0	k0, $22, 6
-	dmtc0	k1, $22, 7
-	mfc0	k0, CP0_STATUS
-	li	k1, 0x80000
-	and	k1, k0, k1
-	beqz	k1, 1f		/* go to real reset entry */
-	nop
-	li	k1, CKSEG1ADDR(RESET_DATA_PHYS) /* NMI */
-	ld	k0, BOOT_NMI_HANDLER(k1)
-	jr	k0
-	nop
-
-1:	/* Entry point on core wakeup */
-	mfc0	t0, CP0_EBASE, 1
-	mfc0	t1, CP0_EBASE, 1
-	srl	t1, 5
-	andi	t1, 0x3			/* t1 <- node */
-	li	t2, 0x40000
-	mul	t3, t2, t1		/* t3 = node * 0x40000 */
-	srl	t0, t0, 2
-	and	t0, t0, 0x7		/* t0 <- core */
-	li	t1, 0x1
-	sll	t0, t1, t0
-	nor	t0, t0, zero		/* t0 <- ~(1 << core) */
-	li	t2, SYS_CPU_COHERENT_BASE(0)
-	add	t2, t2, t3		/* t2 <- SYS offset for node */
-	lw	t1, 0(t2)
-	and	t1, t1, t0
-	sw	t1, 0(t2)
-
-	/* read back to ensure complete */
-	lw	t1, 0(t2)
-	sync
-
-	/* Configure LSU on Non-0 Cores. */
-	xlp_config_lsu
-	/* FALL THROUGH */
-
-/*
- * Wake up sibling threads from the initial thread in
- * a core.
- */
-EXPORT(nlm_boot_siblings)
-	/* core L1D flush before enable threads */
-	xlp_flush_l1_dcache
-	/* Enable hw threads by writing to MAP_THREADMODE of the core */
-	li	t0, CKSEG1ADDR(RESET_DATA_PHYS)
-	lw	t1, BOOT_THREAD_MODE(t0)	/* t1 <- thread mode */
-	li	t0, ((CPU_BLOCKID_MAP << 8) | MAP_THREADMODE)
-	mfcr	t2, t0
-	or	t2, t2, t1
-	mtcr	t2, t0
-
-	/*
-	 * The new hardware thread starts at the next instruction
-	 * For all the cases other than core 0 thread 0, we will
-	* jump to the secondary wait function.
-	*/
-	mfc0	v0, CP0_EBASE, 1
-	andi	v0, 0x3ff		/* v0 <- node/core */
-
-	/* Init MMU in the first thread after changing THREAD_MODE
-	 * register (Ax Errata?)
-	 */
-	andi	v1, v0, 0x3		/* v1 <- thread id */
-	bnez	v1, 2f
-	nop
-
-	li	t0, MMU_SETUP
-	li	t1, 0
-	mtcr	t1, t0
-	_ehb
-
-2:	beqz	v0, 4f		/* boot cpu (cpuid == 0)? */
-	nop
-
-	/* setup status reg */
-	move	t1, zero
-#ifdef CONFIG_64BIT
-	ori	t1, ST0_KX
-#endif
-	mtc0	t1, CP0_STATUS
-	/* mark CPU ready */
-	PTR_LA	t1, nlm_cpu_ready
-	sll	v1, v0, 2
-	PTR_ADDU t1, v1
-	li	t2, 1
-	sw	t2, 0(t1)
-	/* Wait until NMI hits */
-3:	wait
-	j	3b
-	nop
-
-	/*
-	 * For the boot CPU, we have to restore registers and
-	 * return
-	 */
-4:	dmfc0	t0, $4, 2	/* restore SP from UserLocal */
-	li	t1, 0xfadebeef
-	dmtc0	t1, $4, 2	/* restore SP from UserLocal */
-	PTR_SUBU sp, t0, PT_SIZE
-	RESTORE_ALL
-	jr   ra
-	nop
-EXPORT(nlm_reset_entry_end)
+	.set	arch=xlr		/* for mfcr/mtcr, XLR is sufficient */
 
 FEXPORT(xlp_boot_core0_siblings)	/* "Master" cpu starts from here */
-	xlp_config_lsu
 	dmtc0	sp, $4, 2		/* SP saved in UserLocal */
 	SAVE_ALL
 	sync
@@ -250,6 +67,7 @@ FEXPORT(xlp_boot_core0_siblings)	/* "Master" cpu starts from here */
 	dla	t2, nlm_boot_siblings
 	dsubu	t2, t1
 	daddu	t2, t0
+
 	/* call it */
 	jr	t2
 	nop
@@ -263,6 +81,13 @@ NESTED(nlm_boot_secondary_cpus, 16, sp)
 	ori	t1, ST0_KX
 #endif
 	mtc0	t1, CP0_STATUS
+
+#ifdef CONFIG_64BIT
+	/* set the full wired TLBs needed for mapped kernel */
+	jal	nlm_setup_wired_tlbs
+	nop
+#endif
+
 	PTR_LA	t1, nlm_next_sp
 	PTR_L	sp, 0(t1)
 	PTR_LA	t1, nlm_next_gp
@@ -285,7 +110,7 @@ END(nlm_boot_secondary_cpus)
  * In case of RMIboot bootloader which is used on XLR boards, the CPUs
  * be already woken up and waiting in bootloader code.
  * This will get them out of the bootloader code and into linux. Needed
- *  because the bootloader area will be taken and initialized by linux.
+ * because the bootloader area will be taken and initialized by linux.
  */
 	__CPUINIT
 NESTED(nlm_rmiboot_preboot, 16, sp)
@@ -294,8 +119,9 @@ NESTED(nlm_rmiboot_preboot, 16, sp)
 	andi	t2, t0, 0x3	/* thread num */
 	sll	t0, 2		/* offset in cpu array */
 
-	PTR_LA	t1, nlm_cpu_ready /* mark CPU ready */
-	PTR_ADDU t1, t0
+	li	t3, CKSEG1ADDR(RESET_DATA_PHYS)
+	ADDIU	t1, t3, BOOT_CPU_READY
+	ADDU	t1, t0
 	li	t3, 1
 	sw	t3, 0(t1)
 
@@ -307,21 +133,26 @@ NESTED(nlm_rmiboot_preboot, 16, sp)
 	 */
 	li	t0, 0x400
 	mfcr	t1, t0
-	li	t2, 6		/* XLR thread mode mask */
+	li	t2, 6 		/* XLR thread mode mask */
 	nor	t3, t2, zero
 	and	t2, t1, t2	/* t2 - current thread mode */
 	li	v0, CKSEG1ADDR(RESET_DATA_PHYS)
 	lw	v1, BOOT_THREAD_MODE(v0) /* v1 - new thread mode */
 	sll	v1, 1
-	beq	v1, t2, 1f	/* same as request value */
+	beq	v1, t2, 1f 	/* same as request value */
 	nop			/* nothing to do */
 
 	and	t2, t1, t3	/* mask out old thread mode */
 	or	t1, t2, v1	/* put in new value */
 	mtcr	t1, t0		/* update core control */
 
-1:	wait
-	j	1b
+1:
+	/* map first wired TLB for mapped kernel */
+	kernel_entry_setup
+
+	/* wait for NMI to hit */
+2:	wait
+	b	2b
 	nop
 END(nlm_rmiboot_preboot)
 	__FINIT
diff --git a/arch/mips/netlogic/common/time.c b/arch/mips/netlogic/common/time.c
index 5c56555..551d276 100644
--- a/arch/mips/netlogic/common/time.c
+++ b/arch/mips/netlogic/common/time.c
@@ -41,11 +41,14 @@
 #include <asm/netlogic/common.h>
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/common.h>
+#include <asm/netlogic/kvm_para.h>
+#include <asm/netlogic/mips-extns.h>
 
 #if defined(CONFIG_CPU_XLP)
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/pic.h>
+#include <asm/netlogic/xlp-hal/sys.h>
 #elif defined(CONFIG_CPU_XLR)
 #include <asm/netlogic/xlr/iomap.h>
 #include <asm/netlogic/xlr/pic.h>
@@ -81,6 +84,7 @@ static struct clocksource csrc_pic = {
 static void nlm_init_pic_timer(void)
 {
 	uint64_t picbase = nlm_get_node(0)->picbase;
+	uint32_t pichz;
 
 	nlm_pic_set_timer(picbase, PIC_CLOCK_TIMER, ~0ULL, 0, 0);
 	if (current_cpu_data.cputype == CPU_XLR) {
@@ -91,12 +95,45 @@ static void nlm_init_pic_timer(void)
 		csrc_pic.read	= nlm_get_pic_timer;
 	}
 	csrc_pic.rating = 1000;
-	clocksource_register_hz(&csrc_pic, PIC_CLK_HZ);
+	pichz = pic_timer_freq();
+	clocksource_register_hz(&csrc_pic, pichz);
+	pr_info("XLP PIC counter frequency [%d]\n", pichz);
 }
 
+#ifdef CONFIG_CPU_XLP
+static uint32_t tsc_timer_freq(void)
+{
+	return 133333333;
+}
+
+static cycle_t nlm_get_tsc_timer(struct clocksource *cs)
+{
+	return nlm_read_tsc();
+}
+
+static struct clocksource csrc_tsc = {
+	.name	= "TSC",
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+	.mask	= CLOCKSOURCE_MASK(64),
+	.read	= nlm_get_tsc_timer,
+	.rating = 1000,
+};
+
+static void nlm_init_tsc_timer(void)
+{
+	clocksource_register_hz(&csrc_tsc, tsc_timer_freq());
+}
+#else
+#define	is_nlm_guest_os		0
+static void nlm_init_tsc_timer(void) {}
+#endif
+
 void __init plat_time_init(void)
 {
-	nlm_init_pic_timer();
+	if (is_nlm_guest_os)
+		nlm_init_tsc_timer();
+	else
+		nlm_init_pic_timer();
 	mips_hpt_frequency = nlm_get_cpu_frequency();
 	if (current_cpu_type() == CPU_XLR)
 		preset_lpj = mips_hpt_frequency / (3 * HZ);
diff --git a/arch/mips/netlogic/dts/Makefile b/arch/mips/netlogic/dts/Makefile
index aecb6fa..25c8e87 100644
--- a/arch/mips/netlogic/dts/Makefile
+++ b/arch/mips/netlogic/dts/Makefile
@@ -1,2 +1,4 @@
 obj-$(CONFIG_DT_XLP_EVP) := xlp_evp.dtb.o
 obj-$(CONFIG_DT_XLP_SVP) += xlp_svp.dtb.o
+obj-$(CONFIG_DT_XLP_FVP) += xlp_fvp.dtb.o
+obj-$(CONFIG_DT_XLP_GVP) += xlp_gvp.dtb.o
diff --git a/arch/mips/netlogic/dts/xlp_evp.dts b/arch/mips/netlogic/dts/xlp_evp.dts
index e14f423..0b0af6a 100644
--- a/arch/mips/netlogic/dts/xlp_evp.dts
+++ b/arch/mips/netlogic/dts/xlp_evp.dts
@@ -9,19 +9,12 @@
 	#address-cells = <2>;
 	#size-cells = <2>;
 
-	memory {
-		device_type = "memory";
-		reg =  <0 0x00100000 0 0x0FF00000	// 255M at 1M
-			0 0x20000000 0 0xa0000000	// 2560M at 512M
-			0 0xe0000000 1 0x00000000>;
-	};
-
 	soc {
 		#address-cells = <2>;
 		#size-cells = <1>;
 		compatible = "simple-bus";
 		ranges = <0 0  0 0x18000000  0x04000000   // PCIe CFG
-			  1 0  0 0x16000000  0x01000000>; // GBU chipselects
+			  1 0  0 0x16000000  0x02000000>; // GBU chipselects
 
 		serial0: serial@30000 {
 			device_type = "serial";
@@ -76,10 +69,11 @@
 			};
 		};
 		pic: pic@4000 {
-			interrupt-controller;
+			compatible = "netlogic,xlp-pic";
 			#address-cells = <0>;
 			#interrupt-cells = <1>;
 			reg = <0 0x4000 0x200>;
+			interrupt-controller;
 		};
 
 		nor_flash@1,0 {
@@ -116,6 +110,99 @@
 				read-only;
 			};
 		};
+
+		nand_flash@0,0 {
+			compatible = "netlogic,xlp-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0x39000 0x1000>;
+
+ 			interrupts = <43>;
+ 			interrupt-parent = <&pic>;
+			nand-ecc-mode = "hw";
+ 
+			partition@0 {
+				label = "firmware";
+				reg = <0x0 0x20000000>;
+			};
+
+			partition@1 {
+				label = "kernel";
+				reg = <0x20000000 0x20000000>;
+			};
+
+			partition@2 {
+				label = "user";
+				reg = <0x40000000 0x0>;
+			};
+		};
+
+		spi: xlp_spi@3a000 {
+			compatible = "netlogic,xlp-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x3a000 0x100>;
+
+			spi_nor@1 {
+				compatible = "spansion,s25sl12801";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				reg = <1>;	/* Chip Select */
+				spi-max-frequency = <40000000>;
+
+				partition@0 {
+					label = "x-loader";
+					reg = <0x0 0x200000>; /* 2M */
+					read-only;
+				};
+
+				partition@200000 {
+					label = "kernel";
+					reg = <0x200000 0x500000>; /* 5M */
+				};
+
+				partition@700000 {
+					label = "rootfs";
+					reg = <0x700000 0x800000>; /* 8M */
+				};
+
+				partition@f00000 {
+					label = "env";
+					reg = <0xf00000 0x100000>; /* 1M */
+					read-only;
+				};
+			};
+
+			spi_nand@2 {
+				compatible = "spinand,mt29f";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <2>;	/* SPI NAND CS */
+				spi-max-frequency = <50000000>;
+
+				partition@0 {
+					label = "firmware";
+					reg = <0x0 0x1c00000>;
+				};
+
+				partition@1 {
+					label = "kernel";
+					reg = <0x1c00000 0x0>;
+				};
+			};
+		};
+		gpio: xlp_gpio@34000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x34100 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
 	};
 
 	chosen {
diff --git a/arch/mips/netlogic/dts/xlp_fvp.dts b/arch/mips/netlogic/dts/xlp_fvp.dts
new file mode 100644
index 0000000..32800f7
--- /dev/null
+++ b/arch/mips/netlogic/dts/xlp_fvp.dts
@@ -0,0 +1,197 @@
+/*
+ * XLP2XX Device Tree Source for FVP boards
+ */
+
+/dts-v1/;
+/ {
+	model = "netlogic,XLP-FVP";
+	compatible = "netlogic,xlp";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0 0  0 0x18000000  0x04000000   // PCIe CFG
+			  1 0  0 0x16000000  0x02000000>; // GBU chipselects
+
+		serial0: serial@30000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x30100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic>;
+			interrupts = <17>;
+		};
+		serial1: serial@31000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x31100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic>;
+			interrupts = <18>;
+		};
+		i2c0: ocores@37100 {
+			compatible = "opencores,i2c-ocores";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x37100 0x20>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <32000000>;
+			interrupt-parent = <&pic>;
+			interrupts = <30>;
+		};
+		i2c1: ocores@37120 {
+			compatible = "opencores,i2c-ocores";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x37120 0x20>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <32000000>;
+			interrupt-parent = <&pic>;
+			interrupts = <31>;
+
+			rtc@68 {
+				compatible = "dallas,ds1374";
+				reg = <0x68>;
+			};
+
+			dtt@4c {
+				compatible = "national,lm90";
+				reg = <0x4c>;
+			};
+		};
+		pic: pic@4000 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0x4000 0x200>;
+		};
+
+		nor_flash@1,0 {
+			compatible = "cfi-flash";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			bank-width = <2>;
+			reg = <1 0 0x1000000>;
+
+			partition@0 {
+				label = "x-loader";
+				reg = <0x0 0x100000>; /* 1M */
+				read-only;
+			};
+
+			partition@100000 {
+				label = "u-boot";
+				reg = <0x100000 0x100000>; /* 1M */
+			};
+
+			partition@200000 {
+				label = "kernel";
+				reg = <0x200000 0x500000>; /* 5M */
+			};
+
+			partition@700000 {
+				label = "rootfs";
+				reg = <0x700000 0x800000>; /* 8M */
+			};
+
+			partition@f00000 {
+				label = "env";
+				reg = <0xf00000 0x100000>; /* 1M */
+				read-only;
+			};
+		};
+		spi: xlp_spi@3a000 {
+			compatible = "netlogic,xlp-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x3a000 0x100>;
+
+			spi_nor@1 {
+				compatible = "spansion,s25sl12801";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				reg = <1>;	/* Chip Select */
+				spi-max-frequency = <40000000>;
+
+				partition@0 {
+					label = "x-loader";
+					reg = <0x0 0x200000>; /* 2M */
+					read-only;
+				};
+
+				partition@200000 {
+					label = "kernel";
+					reg = <0x200000 0x500000>; /* 5M */
+				};
+
+				partition@700000 {
+					label = "rootfs";
+					reg = <0x700000 0x800000>; /* 8M */
+				};
+
+				partition@f00000 {
+					label = "env";
+					reg = <0xf00000 0x100000>; /* 1M */
+					read-only;
+				};
+			};
+
+			spi_nand@2 {
+				compatible = "spinand,mt29f";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <2>;	/* SPI NAND CS */
+				spi-max-frequency = <50000000>;
+
+				partition@0 {
+					label = "firmware";
+					reg = <0x0 0x1c00000>;
+				};
+
+				partition@1 {
+					label = "kernel";
+					reg = <0x1c00000 0x0>;
+				};
+			};
+		};
+
+		gpio: xlp_gpio@34000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x34100 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
+		ethernet@2,0 {
+		        compatible = "smsc,lan9115";
+		        reg = <1 0x01200000 0x100000>;
+		        reg-io-width = <4>;
+		
+		        interrupts = <39>;
+		        interrupt-parent = <&gpio>;
+		
+		        phy-mode = "mii";
+		        mac-address = [00 11 22 33 44 55];
+		        smsc,irq-push-pull;
+		};
+
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 rdinit=/sbin/init";
+	};
+};
diff --git a/arch/mips/netlogic/dts/xlp_gvp.dts b/arch/mips/netlogic/dts/xlp_gvp.dts
new file mode 100644
index 0000000..623fa63
--- /dev/null
+++ b/arch/mips/netlogic/dts/xlp_gvp.dts
@@ -0,0 +1,176 @@
+/*
+ * XLP9XX Device Tree Source for GVP boards
+ */
+
+/dts-v1/;
+/ {
+	model = "netlogic,XLP-GVP";
+	compatible = "netlogic,xlp";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0 0  0 0x18000000  0x04000000   // PCIe CFG
+			  1 0  0 0x16000000  0x02000000>; // GBU chipselects
+
+		serial0: serial@30000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x112100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <125000000>;
+			interrupt-parent = <&pic>;
+			interrupts = <17>;
+		};
+		pic: pic@11000 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0x110000 0x200>;
+		};
+
+		spi: xlp_spi@13a000 {
+			compatible = "netlogic,xlp-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x13a000 0x100>;
+
+			spi_nor@1 {
+				compatible = "spansion,s25sl12801";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				reg = <1>;		/* Chip Select */
+
+				spi-max-frequency = <40000000>;
+
+				partition@0 {
+					label = "x-loader";
+					reg = <0x0 0x200000>; /* 2M */
+					read-only;
+				};
+
+				partition@200000 {
+					label = "kernel";
+					reg = <0x200000 0x500000>; /* 5M */
+				};
+
+				partition@700000 {
+					label = "rootfs";
+					reg = <0x700000 0x800000>; /* 8M */
+				};
+
+				partition@f00000 {
+					label = "env";
+					reg = <0xf00000 0x100000>; /* 1M */
+					read-only;
+				};
+			};
+			spi_nand@2 {
+				compatible = "spinand,mt29f";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <2>;	/* SPI NAND CS */
+				spi-max-frequency = <50000000>;
+
+				partition@0 {
+					label = "firmware";
+					reg = <0x0 0x1c00000>;
+				};
+
+				partition@1 {
+					label = "kernel";
+					reg = <0x1c00000 0x0>;
+				};
+			};
+		};
+		nor_flash@1,0 {
+			compatible = "cfi-flash";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			bank-width = <2>;
+			reg = <1 0 0x1000000>;
+
+			partition@0 {
+				label = "x-loader";
+				reg = <0x0 0x100000>; /* 1M */
+				read-only;
+			};
+
+			partition@100000 {
+				label = "u-boot";
+				reg = <0x100000 0x100000>; /* 1M */
+			};
+
+			partition@200000 {
+				label = "kernel";
+				reg = <0x200000 0x500000>; /* 5M */
+			};
+
+			partition@700000 {
+				label = "rootfs";
+				reg = <0x700000 0x800000>; /* 8M */
+			};
+
+			partition@f00000 {
+				label = "env";
+				reg = <0xf00000 0x100000>; /* 1M */
+				read-only;
+			};
+		};
+
+		gpio: xlp_gpio@114000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x114100 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
+
+		i2c0: i2c@113100 {
+			compatible = "netlogic,xlp9xx-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x113100 0x100>;
+			clock-frequency = <133000000>;
+		};
+		i2c1: i2c@113300 {
+			compatible = "netlogic,xlp9xx-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x113300 0x100>;
+			clock-frequency = <133000000>;
+
+			rtc@68 {
+				compatible = "dallas,ds1374";
+				reg = <0x68>;
+			};
+		};
+		i2c2: i2c@113500 {
+			compatible = "netlogic,xlp9xx-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x113500 0x100>;
+			clock-frequency = <133000000>;
+		};
+		i2c3: i2c@113700 {
+			compatible = "netlogic,xlp9xx-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x113700 0x100>;
+			clock-frequency = <133000000>;
+		};
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 rdinit=/sbin/init";
+	};
+};
diff --git a/arch/mips/netlogic/dts/xlp_htc.dts b/arch/mips/netlogic/dts/xlp_htc.dts
new file mode 100644
index 0000000..f8b380a
--- /dev/null
+++ b/arch/mips/netlogic/dts/xlp_htc.dts
@@ -0,0 +1,150 @@
+/*
+ * XLP8XX Device Tree Source for EVP boards
+ */
+
+/dts-v1/;
+/ {
+	model = "netlogic,XLP-EVP";
+	compatible = "netlogic,xlp";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		ranges = <0 0  0 0x18000000  0x04000000   // PCIe CFG
+			  1 0  0 0x16000000  0x02000000>; // GBU chipselects
+
+		/* Node 0 devices */
+		pic0: pic@4000 {
+			compatible = "netlogic,xlp-pic";
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0x4000 0x200>;
+			interrupt-controller;
+		};
+		serial00: serial@30000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x30100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic0>;
+			interrupts = <17>;
+		};
+		serial01: serial@31000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x31100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic0>;
+			interrupts = <18>;
+		};
+		i2c00: ocores@32000 {
+			compatible = "opencores,i2c-ocores";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x32100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <32000000>;
+			interrupt-parent = <&pic0>;
+			interrupts = <30>;
+		};
+		i2c01: ocores@33000 {
+			compatible = "opencores,i2c-ocores";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x33100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <32000000>;
+			interrupt-parent = <&pic0>;
+			interrupts = <31>;
+
+			rtc@68 {
+				compatible = "dallas,ds1374";
+				reg = <0x68>;
+			};
+
+			dtt@4c {
+				compatible = "national,lm90";
+				reg = <0x4c>;
+			};
+		};
+
+		gpio0: xlp_gpio@34000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x34100 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic0>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
+
+		/* Node 1 devices */
+		pic1: pic@44000 {
+			compatible = "netlogic,xlp-pic";
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0x44000 0x200>;
+			interrupt-controller;
+		};
+		serial10: serial@70000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x70100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic1>;
+			interrupts = <17>;
+		};
+		serial11: serial@71000 {
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0 0x71100 0xa00>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clock-frequency = <133333333>;
+			interrupt-parent = <&pic1>;
+			interrupts = <18>;
+		};
+		gpio1: xlp_gpio@74000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x74000 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic1>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
+		pic2: pic@84000 {
+			compatible = "netlogic,xlp-pic";
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0x84000 0x200>;
+		};
+		pic3: pic@c4000 {
+			compatible = "netlogic,xlp-pic";
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			reg = <0 0xc4000 0x200>;
+		};
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 rdinit=/sbin/init";
+	};
+};
diff --git a/arch/mips/netlogic/dts/xlp_svp.dts b/arch/mips/netlogic/dts/xlp_svp.dts
index 8af4bdb..c2f725f 100644
--- a/arch/mips/netlogic/dts/xlp_svp.dts
+++ b/arch/mips/netlogic/dts/xlp_svp.dts
@@ -9,19 +9,12 @@
 	#address-cells = <2>;
 	#size-cells = <2>;
 
-	memory {
-		device_type = "memory";
-		reg =  <0 0x00100000 0 0x0FF00000	// 255M at 1M
-			0 0x20000000 0 0xa0000000	// 2560M at 512M
-			0 0xe0000000 0 0x40000000>;
-	};
-
 	soc {
 		#address-cells = <2>;
 		#size-cells = <1>;
 		compatible = "simple-bus";
 		ranges = <0 0  0 0x18000000  0x04000000   // PCIe CFG
-			  1 0  0 0x16000000  0x01000000>; // GBU chipselects
+			  1 0  0 0x16000000  0x02000000>; // GBU chipselects
 
 		serial0: serial@30000 {
 			device_type = "serial";
@@ -76,10 +69,11 @@
 			};
 		};
 		pic: pic@4000 {
-			interrupt-controller;
+			compatible = "netlogic,xlp-pic";
 			#address-cells = <0>;
 			#interrupt-cells = <1>;
 			reg = <0 0x4000 0x200>;
+			interrupt-controller;
 		};
 
 		nor_flash@1,0 {
@@ -116,6 +110,112 @@
 				read-only;
 			};
 		};
+
+		nand_flash@0,0 {
+			compatible = "netlogic,xlp-nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0 0x39000 0x1000>;
+
+ 			interrupts = <43>;
+ 			interrupt-parent = <&pic>;
+			nand-ecc-mode = "hw";
+
+			partition@0 {
+				label = "firmware";
+				reg = <0x0 0x20000000>;
+			};
+
+			partition@1 {
+				label = "kernel";
+				reg = <0x20000000 0x20000000>;
+			};
+
+			partition@2 {
+				label = "user";
+				reg = <0x40000000 0x0>;
+			};
+		};
+
+		spi: xlp_spi@3a000 {
+			compatible = "netlogic,xlp-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0 0x3a000 0x100>;
+
+			spi_nor@1 {
+				compatible = "spansion,s25sl12801";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				reg = <1>;		/* Chip Select */
+				spi-max-frequency = <40000000>;
+
+				partition@0 {
+					label = "x-loader";
+					reg = <0x0 0x200000>; /* 2M */
+					read-only;
+				};
+
+				partition@200000 {
+					label = "kernel";
+					reg = <0x200000 0x500000>; /* 5M */
+				};
+
+				partition@700000 {
+					label = "rootfs";
+					reg = <0x700000 0x800000>; /* 8M */
+				};
+
+				partition@f00000 {
+					label = "env";
+					reg = <0xf00000 0x100000>; /* 1M */
+					read-only;
+				};
+			};
+
+			spi_nand@2 {
+				compatible = "spinand,mt29f";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <2>;	/* SPI NAND CS */
+				spi-max-frequency = <50000000>;
+
+				partition@0 {
+					label = "firmware";
+					reg = <0x0 0x1c00000>;
+				};
+
+				partition@1 {
+					label = "kernel";
+					reg = <0x1c00000 0x0>;
+				};
+			};
+		};
+		gpio: xlp_gpio@34000 {
+			compatible = "netlogic,xlp-gpio";
+			reg = <0 0x34100 0x1000>;
+			#gpio-cells = <2>;
+			gpio-controller;
+			
+			#interrupt-cells = <1>;
+			interrupt-parent = <&pic>;
+			interrupts = <39>;
+			interrupt-controller;
+		};
+		ethernet@2,0 {
+		        compatible = "smsc,lan9115";
+		        reg = <1 0x01200000 0x100000>;
+		        reg-io-width = <4>;
+		
+		        interrupts = <39>;
+		        interrupt-parent = <&gpio>;
+		
+		        phy-mode = "mii";
+		        mac-address = [00 11 22 33 44 55];
+		        smsc,irq-push-pull;
+		};
+
 	};
 
 	chosen {
diff --git a/arch/mips/netlogic/kvm/Makefile b/arch/mips/netlogic/kvm/Makefile
new file mode 100644
index 0000000..7289243
--- /dev/null
+++ b/arch/mips/netlogic/kvm/Makefile
@@ -0,0 +1,5 @@
+EXTRA_CFLAGS := -Werror
+EXTRA_CFLAGS := $(CFLAGS)
+
+obj-y = kvm_traps.o kvm_fault.o kvm_pic.o kvm_uart.o kvm_sysmgt.o kvm_fuse.o \
+	kvm_bridge.o kvm_pcie.o kvm_clk.o
diff --git a/arch/mips/netlogic/kvm/kvm_bridge.c b/arch/mips/netlogic/kvm/kvm_bridge.c
new file mode 100644
index 0000000..840c216
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_bridge.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_bridge(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+
+// printk("!!! bridge register: 0x%x, reg_num: %d, epc: 0x%lx\n", rindex, (int)reg_num, regs->cp0_epc);
+
+	if (rindex <= 0x0f) {
+		if (write) {
+			arch->bridge.config[rindex] = regs->regs[reg_num];
+		} else {
+			regs->regs[reg_num] = arch->bridge.config[rindex];
+		}
+		return;
+	}
+	else if (rindex == 0x99 || rindex == 0x9a || rindex == 0x9b
+		|| rindex == 0x9c) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_membase[rindex - 0x99];
+			return;
+		}
+	}
+	else if (rindex == 0x9d || rindex == 0x9e || rindex == 0x9f
+		|| rindex == 0xa0) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_memlimit[rindex - 0x9d];
+			return;
+		}
+	}
+	else if (rindex == 0xa1 || rindex == 0xa2 || rindex == 0xa3
+		|| rindex == 0xa4) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_iobase[rindex - 0xa1];
+			return;
+		}
+	}
+	else if (rindex == 0xa5 || rindex == 0xa6 || rindex == 0xa7
+		|| rindex == 0xa8) {
+		if (!write) {
+			regs->regs[reg_num] = arch->bridge.pcie_iolimit[rindex - 0xa5];
+			return;
+		}
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_clk.c b/arch/mips/netlogic/kvm/kvm_clk.c
new file mode 100644
index 0000000..461633b
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_clk.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_clk(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+
+	if (rindex == 0x101) {
+		/* cpu pll control 1 */
+		return;
+	} else if (rindex == 0x1c8) {
+		/* cpu pll change control */
+		if (!write)
+			regs->regs[reg_num] = 0x0;
+		return;
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_fault.c b/arch/mips/netlogic/kvm/kvm_fault.c
new file mode 100644
index 0000000..5349c77
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_fault.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+/*
+ * This file contains the implementation to virtualize
+ * PCIe configuration space and PCIe memory mapped space
+ * for various I/O blocks.
+ * 
+ * 1. The physical memory region of 0x18000000 - 0x1c000000 (64MB) is reserved
+ *    in guest for PCIe configuration space access.
+ * 2. The physical memory region of 0x1c000000 - 0x1d000000 (16MB) is reserved
+ *    in guest for PCI configuration space access.
+ * 2. The physical memory region of 0xd0000000 - 0xe0000000 (256MB) is reserved
+ *    for memory mapped device.
+ */
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address/offset %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+static void handle_pci_config_space(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+
+	/* FIXME: workaround */
+	if (write)
+		return;
+
+	regs->regs[reg_num] = *(unsigned int *)(0x9000000000000000ULL | address);
+
+#if 0
+	if (address == 0x1c000000) {
+		if (!write)
+			regs->regs[reg_num] = 0x1001184e;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else if (address == 0x1c000004) {
+		if (!write)
+			regs->regs[reg_num] = 0x4;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else if (address == 0x1c000008) {
+		if (!write)
+			regs->regs[reg_num] = 0xffffffffff000000;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else if (address == 0x1c00000c) {
+		if (!write)
+			regs->regs[reg_num] = 0x808008;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else if (address == 0x1c000010
+			|| address == 0x1c000014
+			|| address == 0x1c000018
+			|| address == 0x1c00001c
+			|| address == 0x1c000020
+			|| address == 0x1c000024
+			|| address == 0x1c000030
+			|| address == 0x1c00003c
+		  ) {
+		if (!write)
+			regs->regs[reg_num] = 0x0;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else if (address == 0x1c00002c) {
+		if (!write)
+			regs->regs[reg_num] = 0xffffffffaaaaaaaa;
+		else
+			printk("ignore guest pci write: %lx, epc %lx, val %lx\n",
+				address, regs->cp0_epc, regs->regs[reg_num]);
+	} else
+		panic("caught one guest pci address: %lx, epc %lx\n",
+			address, regs->cp0_epc);
+#endif
+}
+
+asmlinkage int do_guest_fault_check(struct pt_regs *regs, unsigned long write,
+				    unsigned long address)
+{
+	unsigned int reg_num = 0;
+	unsigned int badinstr, epc_badinstr;
+
+	/* check whether the fault is from guest. */
+	if ((regs->cp0_guestctl0 >> 31) == 0)
+		return 0;
+
+	if (address >= 0x14000000 && address < 0x16000000) {
+		/* I/O address */
+		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0x80000000 /* lb */
+		    || (badinstr & 0xfc000000) == 0xa0000000 /* sb */
+		    || (badinstr & 0xfc000000) == 0x90000000 /* lbu */
+		    || (badinstr & 0xfc000000) == 0xa4000000 /* sh */
+		    || (badinstr & 0xfc000000) == 0x94000000 /* lhu */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+                else {
+			printk("%s: 0x%x, unhandled epc %lx, address %lx\n",
+				__FUNCTION__, badinstr, regs->cp0_epc, address);
+			return 0;
+                }
+
+		kvm_handle_pcie_io(regs, write, address, reg_num, badinstr, epc_badinstr);
+
+		compute_guest_return_epc(regs, epc_badinstr);
+
+		return 1;
+	} else if (address >= 0x18000000 && address < 0x1c000000) {
+		/* pcie register configuration space */
+
+		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+		/* This is the pcie configuration space. The only instructions
+		 * which can access here is lw/sw/ld/sd.
+		 * Decode the badinstr.
+		 */
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+		else {
+			/* The guest gives us wrong information. What to do? */
+			printk("%s: unhandled epc %lx, address %lx\n",
+				__FUNCTION__, regs->cp0_epc, address);
+			return 0;
+		}
+
+		if ((address & 0xfffff000) == 0x18000000) {
+			/* bridge: bus 0, dev 0, func 0 */
+			kvm_handle_pcie_bridge(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18108000) {
+			/* pcie link 0: dev 1, func 0 */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		}
+		else if ((address & 0xfffff000) == 0x18109000) {
+			/* pcie link 1: dev 1, func 1 */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		}
+		else if ((address & 0xfffff000) == 0x1810a000) {
+			/* pcie link 2: dev 1, func 2 */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		}
+		else if ((address & 0xfffff000) == 0x1810b000) {
+			/* pcie link 3: dev 1, func 3 */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		}
+		else if ((address & 0xfffff000) == 0x18110000) {
+			/* pic: dev 2, func 0 */
+			kvm_handle_pcie_pic(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18112000) {
+			/* uart: dev 2, func 2 */
+			kvm_handle_pcie_uart(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18130000) {
+			/* sys management: dev 6, func 0 */
+			kvm_handle_pcie_sysmgt(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18131000) {
+			/* fuse: dev 6, func 1 */
+			kvm_handle_pcie_fuse(regs, write, address & 0xfff, reg_num);
+		}
+		else if ((address & 0xfffff000) == 0x18132000) {
+			/* fuse: dev 6, func 2 */
+			kvm_handle_pcie_clk(regs, write, address & 0xfff, reg_num);
+		}
+		else if (((address & 0xfff00000) != 0x18000000) && ((address & 0xfff00000) != 0x18100000)) {
+			/* not bus 0, bus 1, a real bridge */
+			kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+		} else {
+			/* disable the device */
+			if (!write && (address & 0xfff) == 0)
+				regs->regs[reg_num] = 0xffffffff;
+			else {
+				printk("caught one guest pcie address: %lx, epc %lx\n",
+						address, regs->cp0_epc);
+			}
+		}
+
+		compute_guest_return_epc(regs, epc_badinstr);
+		return 1;
+	} else if (address >= 0x1c000000 && address < 0x1d000000) {
+		/* pci register configuration space */
+
+		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+		else {
+			printk("%s: unhandled epc %lx, address %lx\n",
+				__FUNCTION__, regs->cp0_epc, address);
+			return 0;
+		}
+
+		handle_pci_config_space(regs, write, address, reg_num);
+		compute_guest_return_epc(regs, epc_badinstr);
+
+		return 1;
+	} else if (address >= 0xd0000000ul && address < 0xe0000000ul) {
+
+		kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+		if ((badinstr & 0xfc000000) == 0x8c000000 /* lw */
+		    || (badinstr & 0xfc000000) == 0xac000000 /* sw */
+		    || (badinstr & 0xfc000000) == 0x80000000 /* lb */
+		    || (badinstr & 0xfc000000) == 0xa0000000 /* sb */
+		    || (badinstr & 0xfc000000) == 0x90000000 /* lbu */
+		    || (badinstr & 0xfc000000) == 0xa4000000 /* sh */
+		    || (badinstr & 0xfc000000) == 0x94000000 /* lhu */
+		    || (badinstr & 0xfc000000) == 0xdc000000 /* ld */
+		    || (badinstr & 0xfc000000) == 0xfc000000 /* sd */
+		   )
+			reg_num = (badinstr >> 16) & 0x1f;
+                else {
+			printk("%s: 0x%x, unhandled epc %lx, address %lx\n",
+				__FUNCTION__, badinstr, regs->cp0_epc, address);
+			return 0;
+                }
+
+                kvm_handle_pcie_pcie(regs, write, address, reg_num, badinstr, epc_badinstr);
+
+		compute_guest_return_epc(regs, epc_badinstr);
+
+		return 1;
+	}
+
+	return 0;
+}
diff --git a/arch/mips/netlogic/kvm/kvm_fuse.c b/arch/mips/netlogic/kvm/kvm_fuse.c
new file mode 100644
index 0000000..30a150b
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_fuse.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_fuse(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+
+	if (rindex == 0x106) {
+		/* cpu disables */
+		if (!write) {
+			regs->regs[reg_num] = 0x0;
+			return;
+		}
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_pcie.c b/arch/mips/netlogic/kvm/kvm_pcie.c
new file mode 100644
index 0000000..8ee420b
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_pcie.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+void kvm_handle_pcie_pcie(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num, uint32_t badinstr,
+		uint32_t epc_badinstr)
+{
+	uint32_t val;
+	struct kvm_vcpu *vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
+
+#if 0
+	printk("=== pcie_pcie: address 0x%lx, epc 0x%lx, write %ld\n",
+		address, regs->cp0_epc, write);
+#endif
+
+	val = KVM_EXIT_MMIO << 24;
+	vcpu->arch.mmio.addr = address;
+	vcpu->arch.mmio.is_write = write;
+	vcpu->arch.mmio.reg_num = reg_num;
+
+	if ((badinstr & 0xfc000000) == 0x80000000
+	    || (badinstr & 0xfc000000) == 0x90000000
+	    || (badinstr & 0xfc000000) == 0xa0000000)
+		vcpu->arch.mmio.len = 1;
+	else if ((badinstr & 0xfc000000) == 0xa4000000
+	    || (badinstr & 0xfc000000) == 0x94000000)
+		vcpu->arch.mmio.len = 2;
+	else if ((badinstr & 0xfc000000) == 0x8c000000
+	    || (badinstr & 0xfc000000) == 0xac000000)
+		vcpu->arch.mmio.len = 4;
+	else
+		vcpu->arch.mmio.len = 8;
+
+	if (write)
+		vcpu->arch.mmio.val = regs->regs[reg_num];
+
+	compute_guest_return_epc(regs, epc_badinstr);
+	kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+	__kvm_vcpu_leave_guest(vcpu, val);
+}
+
+void kvm_handle_pcie_io(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num, uint32_t badinstr,
+		uint32_t epc_badinstr)
+{
+	uint32_t val, size;
+	struct kvm_vcpu *vcpu = (struct kvm_vcpu *)regs->cp0_osscratch7;
+	struct kvm *kvm = vcpu->kvm;
+
+#if 0
+	printk("=== pcie_io: address 0x%lx, epc 0x%lx, write %ld\n",
+		address, regs->cp0_epc, write);
+#endif
+
+	if ((badinstr & 0xfc000000) == 0x80000000
+	    || (badinstr & 0xfc000000) == 0x90000000
+	    || (badinstr & 0xfc000000) == 0xa0000000) {
+		size = 1;
+		if (write) *(char *)&val = regs->regs[reg_num];
+	} else if ((badinstr & 0xfc000000) == 0xa4000000
+	    || (badinstr & 0xfc000000) == 0x94000000) {
+		size = 2;
+		if (write) *(short *)&val = regs->regs[reg_num];
+	} else if ((badinstr & 0xfc000000) == 0x8c000000
+	    || (badinstr & 0xfc000000) == 0xac000000) {
+		size = 4;
+		if (write) *(int *)&val = regs->regs[reg_num];
+	} else {
+		panic("not supported\n");
+	}
+
+	if (write) {
+		if (kvm_io_bus_write(kvm, KVM_PIO_BUS, address & 0xffff, size, &val) == 0)
+			return;
+	} else {
+		if (kvm_io_bus_read(kvm, KVM_PIO_BUS, address & 0xffff, size, &val) == 0) {
+			if (size == 1)
+				regs->regs[reg_num] = *(char *)&val;
+			else if (size == 2)
+				regs->regs[reg_num] = *(short *)&val;
+			else
+				regs->regs[reg_num] = *(int *)&val;
+			return;
+		}
+	}
+
+	val = KVM_EXIT_IO << 24;
+	vcpu->arch.pio.direction = (write ? KVM_EXIT_IO_OUT : KVM_EXIT_IO_IN);
+	vcpu->arch.pio.port = address & 0xffff; /* ignore upper bits */
+	vcpu->arch.pio.size = size;
+	vcpu->arch.pio.count = 1;
+	vcpu->arch.pio.data_offset = (uint64_t)&(((struct kvm_run *)0)->mips_exit_io.data);
+
+	if (write)
+		vcpu->arch.pio.val = regs->regs[reg_num];
+
+	vcpu->arch.pio.reg_num = reg_num;
+
+	compute_guest_return_epc(regs, epc_badinstr);
+	kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+	__kvm_vcpu_leave_guest(vcpu, val);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_pic.c b/arch/mips/netlogic/kvm/kvm_pic.c
new file mode 100644
index 0000000..f3abb2c
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_pic.c
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+#include <asm/netlogic/mips-extns.h>
+
+// #define DEBUG
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_pic_inject_guest(struct kvm_arch *arch, unsigned int irt, struct pt_regs *regs)
+{
+	unsigned long long irt_entry;
+	unsigned int rvec;
+	struct kvm_vcpu_arch *vcpu_arch;
+
+	irt_entry = arch->pic.u.v64[(0x200 >> 1) + irt];
+	rvec = (irt_entry >> 24) & 0x3f;
+	vcpu_arch = kvm_get_vcpu_arch(regs);
+#ifdef DEBUG
+	printk("===== Inject IRT %u, RVEC %u to the guest (irt_entry %llx)\n", irt, rvec, irt_entry);
+#endif
+	atomic_or_llong(&vcpu_arch->pip_vector, 1ULL << rvec);
+}
+
+void kvm_pic_inject_guest_ext(struct kvm *kvm, struct kvm_arch *arch, unsigned int irt, unsigned int cpuid)
+{
+	unsigned long long irt_entry;
+	unsigned int rvec;
+	struct kvm_vcpu_arch *vcpu_arch;
+
+	/* FIXME: We should really look at irt_entry and deliver it to proper cpu
+	 * according to the schedule type.
+	 */
+	irt_entry = arch->pic.u.v64[(0x200 >> 1) + irt];
+	rvec = (irt_entry >> 24) & 0x3f;
+	vcpu_arch = kvm_get_vcpu_arch_ext(kvm, cpuid);
+#ifdef DEBUG
+	printk("===== Inject IRT %u, RVEC %u to the guest (irt_entry %llx)\n", irt, rvec, irt_entry);
+#endif
+	atomic_or_llong(&vcpu_arch->pip_vector, 1ULL << rvec);
+}
+
+static unsigned int xlp_kvm_get_ipi_cpuid(uint64_t ipi_ctrl)
+{
+	unsigned int mask = ipi_ctrl & 0x3ff;
+	return mask;
+}
+
+void kvm_handle_pcie_pic(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+	extern void nlm_send_ipi_single(int lcpu, unsigned int action);
+
+	if (rindex == 0x0 || rindex == 0x2 || rindex == 0x3d) {
+		if (!write)
+			regs->regs[reg_num] = arch->pic.u.v32[rindex];
+		else
+			unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+	} else if (rindex == 0x40) {
+		/* pic control */
+		if (write)
+			arch->pic.u.v64[rindex >> 1] = regs->regs[reg_num]; 
+		else
+			regs->regs[reg_num] = arch->pic.u.v64[rindex >> 1];
+	} else if (rindex == 0x44) {
+		/* watchdog/systimer/other_interrupt status */
+		if (write)
+			arch->pic.u.v64[rindex >> 1] = regs->regs[reg_num];
+		else
+			unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+	} else if (rindex == 0x4e) {
+		/* IPI control: set IPI pending at target cpus */
+		if (write) {
+			uint64_t  val = regs->regs[reg_num];
+			uint32_t  rvec, cpuid;
+			struct kvm_vcpu_arch *vcpu_arch;
+
+			arch->pic.u.v64[rindex >> 1] = val;
+
+			if ((val & (0x7 << 20)) != 0) {
+				printk("===== Non Unicast IPI is not supported\n");
+				return;
+			}
+
+			cpuid = xlp_kvm_get_ipi_cpuid (val);
+#ifdef DEBUG
+printk("Sending %s from cpuid %d to cpuid %d\n", (val & (1 << 23)) ? "NMI" : "IPI",
+	(int)(regs->guest_cp0_ebase & 0x3ff), cpuid);
+#endif
+			vcpu_arch = kvm_get_vcpu_arch_with_cpuid(regs, cpuid);
+			if (val & (1 << 23)) {
+				vcpu_arch->nmi = 1;
+			} else {
+				rvec = (val >> 24) & 0x3f;
+				atomic_or_llong(&vcpu_arch->pip_vector, 1ULL << rvec);
+			}
+		} else
+			regs->regs[reg_num] = arch->pic.u.v64[rindex >> 1];
+
+	} else if (rindex == 0x50) {
+		/* ACK */
+		unsigned int irt = regs->regs[reg_num];
+		unsigned int rvec, irt_entry = arch->pic.u.v64[(0x200 >> 1) + irt];
+		struct kvm_vcpu_arch *vcpu_arch;
+
+		rvec = (irt_entry >> 24) & 0x3f;
+
+		vcpu_arch = kvm_get_vcpu_arch(regs);
+#ifdef DEBUG
+		printk("===== ACK IRT %u RVEC %u from guest\n", irt, rvec);
+#endif
+		atomic_and_llong(&vcpu_arch->pip_vector, ~(1ULL << rvec));
+
+	} else if (rindex >= 0x74 && rindex <= 0x82) {
+		/* pic timer 0-7 max value */
+		if (write)
+			arch->pic.u.v64[rindex >> 1] = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->pic.u.v64[rindex >> 1];
+	} else if (rindex >= 0x200 && rindex < 0x400) {
+		/* register 0x200 - 0x400: interrupt redirection table (256 entries) */
+		if (write) {
+#ifdef DEBUG
+			printk("===== Guest IRT index %d, val %lx\n", (rindex - 0x200) >> 1, regs->regs[reg_num]);
+#endif
+			arch->pic.u.v64[rindex >> 1] = regs->regs[reg_num];
+		} else
+			regs->regs[reg_num] = arch->pic.u.v64[rindex >> 1];
+
+	} else
+		unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_sysmgt.c b/arch/mips/netlogic/kvm/kvm_sysmgt.c
new file mode 100644
index 0000000..e805fbd
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_sysmgt.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_sysmgt(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+
+	if (rindex == 0x0) {
+		if (!write) {
+			regs->regs[reg_num] = arch->sysmgt.regs[rindex];
+			return;
+		}
+	} else if (rindex == 0x40) {
+		/* power on reset: used to calculate frequency */
+		if (!write) {
+			regs->regs[reg_num] = arch->sysmgt.regs[rindex];
+			return;
+		}
+	} else if (rindex == 0x41) {
+		/* chip reset */
+		if (write) {
+			int val;
+
+			printk("Guest vcpu %lu request exiting ...\n", regs->guest_cp0_ebase & 0x3ff);
+			val = (KVM_EXIT_REQUEST_QUIT << 24);
+			 __kvm_vcpu_leave_guest((struct kvm_vcpu *)regs->cp0_osscratch7, val);
+			return;
+		}
+	} else if (rindex == 0x42) {
+		/* cpu reset register*/
+		if (write) {
+			int i, nval, oval;
+
+			oval = arch->sysmgt.regs[rindex];
+			nval = regs->regs[reg_num];
+			arch->sysmgt.regs[rindex] = nval;
+
+			for (i = 1; i < (KVM_MAX_VCPUS >> 2); i++) {
+				/* if it is already out of reset, skip */
+				if (!(oval & (1 << i)))
+					continue;
+
+				/* not out of reset yet, should it? */
+				if (!(nval & (1 << i))) {
+					unsigned int val = i << 2, badinstr, epc_badinstr;
+					val |= (KVM_EXIT_ENABLE_CORE << 24);
+
+#if 0
+					printk("Enable core %d ...\n", i);
+#endif
+					kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+					compute_guest_return_epc(regs, epc_badinstr);
+					kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));	
+					__kvm_vcpu_leave_guest((struct kvm_vcpu *)regs->cp0_osscratch7, val);
+				}
+			}
+		} else {
+			regs->regs[reg_num] = arch->sysmgt.regs[rindex];	
+		}
+		return;
+	} else if (rindex == 0x43) {
+		/* cpu noncoherent mode */
+		if (write)
+			arch->sysmgt.regs[rindex] = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->sysmgt.regs[rindex];
+		return;
+	}
+
+	unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/kvm/kvm_traps.c b/arch/mips/netlogic/kvm/kvm_traps.c
new file mode 100644
index 0000000..fb1266c
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_traps.c
@@ -0,0 +1,483 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/ptrace.h>
+#include <linux/kvm_host.h>
+
+#include <asm/uaccess.h>
+#include <asm/kvm.h>
+#include <asm/kvm_host.h>
+#include <asm/netlogic/kvm_para.h>
+#include <asm/netlogic/kvm_xlp.h>
+#include <asm/netlogic/mips-extns.h>
+
+/* Virtualization exceptions (as tagged in cause register) handled here */
+
+#define PSI_UNHANDLED(epc, cause, instr, epc_instr) \
+	printk("PSI (unhandled): epc %lx, cause %lx, badinstr: %x, epc_badinstr: %x\n", epc, cause, instr, epc_instr)
+
+#define FC_UNHANDLED(epc, cause, instr, epc_instr) \
+	printk("FC (captured): epc %lx, cause %lx, badinstr: %x, epc_badinstr: %x\n", epc, cause, instr, epc_instr)
+
+
+#define cacheop(op, base) __asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
+
+/* Enable guest counting of guest mode */
+#define PERF_GUEST_EC   (0x2 << 23)
+
+/* Guest privileged sensitive instruction */
+static void process_psi(struct pt_regs *regs)
+{
+	unsigned int badinstr, epc_badinstr;
+	unsigned long epc;
+
+	epc = regs->cp0_epc;
+	kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+	if ((badinstr >> 26) == 0x10) {
+		/* cop0 */
+		if ((badinstr & 0xfe00003f) == 0x42000020) {
+			struct kvm_vcpu_arch *vcpu_arch;
+			uint32_t val, cause;
+
+			vcpu_arch = kvm_get_vcpu_arch(regs);
+			if (vcpu_arch->nmi == 1) {
+				regs->cp0_epc = 0xffffffffbfc00000;
+				__write_32bit_guest_c0_register($12, 0,
+					__read_32bit_guest_c0_register($12, 0) | 0x80000);
+				vcpu_arch->nmi = 0;
+				return;
+			}
+
+			/* We do not want to simply bounce back. As for SMT,
+			 * this will have performance implication.
+			 */
+#if 0
+			__asm__ __volatile__ ("wait" : : : "memory");
+#else
+			/* Let us do a tpause here */
+			/* compare - count */
+			val = __read_32bit_guest_c0_register($11, 0) -
+				__read_32bit_guest_c0_register($9,  0);
+			cause = __read_32bit_guest_c0_register($13, 0);
+			if (!((cause >> 30) & 0x1) && val > 500) {
+				write_xlp_pausetime(val - 500);
+				__asm__ __volatile__ ("tpause" : : : "memory");
+			}
+#endif
+			return; 
+		} else if (((badinstr >> 21) & 0x1f) == 0x0) {
+			/* MF */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 15 && sel == 0) {
+				regs->regs[rt] = read_c0_prid();
+			}
+			else if (rd == 12 && sel == 2) {
+				/* srsctl */
+				regs->regs[rt] = 0;
+			} else if (rd == 25 && (sel == 0 || sel == 2 || sel == 4 || sel == 6)) {
+				/* perf counter control registers: enable guest use */
+				int32_t val = 0;
+
+				if (sel == 0) {
+					val = read_c0_perfctrl0();
+					write_c0_perfctrl0(val | PERF_GUEST_EC);
+				} else if (sel == 2) {
+					val = read_c0_perfctrl1();
+					write_c0_perfctrl1(val | PERF_GUEST_EC);
+				} else if (sel == 4) {
+					val = read_c0_perfctrl2();
+					write_c0_perfctrl2(val | PERF_GUEST_EC);
+				} else {
+					val = read_c0_perfctrl3();
+					write_c0_perfctrl3(val | PERF_GUEST_EC);
+				}
+				regs->regs[rt] = val;
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else if (((badinstr >> 21) & 0x1f) == 0x1) {
+			/* DMF */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 25 && (sel == 1 || sel == 3 || sel == 5 || sel == 7)) {
+				/* perf counter control registers: enable guest use */
+
+				if (sel == 1) {
+					write_c0_perfctrl0(read_c0_perfctrl0() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr0_64();
+				} else if (sel == 3) {
+					write_c0_perfctrl1(read_c0_perfctrl1() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr1_64();
+				} else if (sel == 5) {
+					write_c0_perfctrl2(read_c0_perfctrl2() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr2_64();
+				} else {
+					write_c0_perfctrl3(read_c0_perfctrl3() | PERF_GUEST_EC);
+					regs->regs[rt] = read_c0_perfcntr3_64();
+				}
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else if (((badinstr >> 21) & 0x1f) == 0x4) {
+			/* MT */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 9 && sel == 0) {
+				/* count */
+				unsigned int val = regs->regs[rt] - read_c0_count();
+				__write_32bit_c0_register($12, 7, val);
+			} else if (rd == 25 && (sel == 0 || sel == 2 || sel == 4 || sel == 6)) {
+				/* perf cnt registers */
+				if (sel == 0)
+					write_c0_perfctrl0(regs->regs[rt] | PERF_GUEST_EC);
+				else if (sel == 2)
+					write_c0_perfctrl1(regs->regs[rt] | PERF_GUEST_EC);
+				else if (sel == 4)
+					write_c0_perfctrl2(regs->regs[rt] | PERF_GUEST_EC);
+				else
+					write_c0_perfctrl3(regs->regs[rt] | PERF_GUEST_EC);
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else if (((badinstr >> 21) & 0x1f) == 0x5) {
+			/* DMT */
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 25 && (sel == 1 || sel == 3 || sel == 5 || sel == 7)) {
+				/* perf cnt registers */
+
+				if (sel == 1) {
+					write_c0_perfctrl0(read_c0_perfctrl0() | PERF_GUEST_EC);
+					write_c0_perfcntr0_64(regs->regs[rt]);
+				} else if (sel == 3) {
+					write_c0_perfctrl1(read_c0_perfctrl1() | PERF_GUEST_EC);
+					write_c0_perfcntr1_64(regs->regs[rt]);
+				} else if (sel == 5) {
+					write_c0_perfctrl2(read_c0_perfctrl2() | PERF_GUEST_EC);
+					write_c0_perfcntr2_64(regs->regs[rt]);
+				} else {
+					write_c0_perfctrl3(read_c0_perfctrl3() | PERF_GUEST_EC);
+					write_c0_perfcntr3_64(regs->regs[rt]);
+				}
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+
+		} else
+			PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+	} else if ((badinstr >> 26) == 0x1c) {
+		if ((badinstr & 0xffff) == 0x18) {
+			/* mfcr */
+			unsigned int rs = (badinstr >> 21) & 0x1f;
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int cr = regs->regs[rs];
+
+			if (cr == 0x007) {
+				/* IFU BRUB reserve register */
+				;
+			} else if (cr == 0x100) {
+				/* ICU defeature register */
+				;
+			} else if (cr == 0x304) {
+				/* LSU defeature register */
+			} else if (cr == 0x305) {
+				/* LSU debug addr */
+				/* regs->regs[rt] = (uint32_t)read_32bit_nlm_ctrl_reg(0x3, 0x5); */
+				regs->regs[rt] = 0x0;
+			} else if (cr == 0xa00) {
+				/* map thread mode */
+				regs->regs[rt] = 0x0;
+			} else if (cr == 0x400) {
+				/* mmu setup */
+				regs->regs[rt] = 0x0;
+			} else if (cr == 0x800) {
+				/* scu config */
+				regs->regs[rt] = 0x0;
+			} else
+				printk("=== unhandled mfcr cr %x\n", cr);
+
+		} else if ((badinstr & 0xffff) == 0x19) {
+			/* mtcr */
+			unsigned int rs = (badinstr >> 21) & 0x1f;
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int cr = regs->regs[rs];
+
+			if (cr == 0x007) {
+				/* IFU BRUB reserve register */
+				;
+			} else if (cr == 0x100) {
+				/* ICU defeature register */
+				;
+			} else if (cr == 0x304) {
+				/* LSU defeature register */
+				;
+			} else if (cr == 0x305) {
+				/* write_32bit_nlm_ctrl_reg (0x3, 0x5, (uint32_t)regs->regs[rt]); */
+				;
+			} else if (cr == 0x306) {
+				/* LSU debug data0 */
+				/* write_64bit_nlm_ctrl_reg (0x3, 0x6, regs->regs[rt]); */
+				;
+			} else if (cr == 0x400) {
+				/* MMU setup */
+				;
+			} else if (cr == 0x700) {
+				/* schedule defeature */
+				;
+			} else if (cr == 0x800) {
+				/* scu config */
+				;
+			} else if (cr == 0xa00) {
+				/* map thread mode: this is the way to wake up
+				 * other threads in the same core.
+				 */
+				if (regs->regs[rt] != 0 && regs->regs[rt] != 1) {
+					int val;
+
+					/*
+					 * val[15:0]: start cpu id (ebase).
+					 * val[23:16]: # of cpus to spawn.
+					 * val[31:24]: exit code.
+					 */
+					val = regs->guest_cp0_ebase & 0x3ff;
+					val ++;
+					if (regs->regs[rt] == 2)
+						val |= (1 << 16);
+					else
+						val |= (3 << 16);
+					val |= (KVM_EXIT_SPAWN_THREADS << 24);
+
+#if 0
+					printk("Tentatively Leaving the guest (Spawning %d new threads)...\n",
+						(regs->regs[rt] == 2) ? 1 : 3);
+#endif
+
+					compute_guest_return_epc(regs, epc_badinstr);
+					kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+					__kvm_vcpu_leave_guest((struct kvm_vcpu *)regs->cp0_osscratch7, val);
+				}
+			} else
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+
+		} else
+			PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+	} else if ((badinstr >> 26) == 0x2f) {
+		/* cache instruction */
+		int base, op;
+		uint64_t offset, addr;
+
+		base = (badinstr >> 21) & 0x1f;
+		op = (badinstr >> 16) & 0x1f;
+		offset = badinstr & 0xffff;
+		addr = regs->regs[base] + offset;
+		switch(op) {
+			case 0:  /* I, Index Invalidate */ cacheop(0, addr); break;
+			case 1:  /* D, Index Invalidate */ cacheop(1, addr); break;
+			case 2:  break;
+			case 3:  /* S, Index Invalidate */ cacheop(3, addr); break;
+			case 4:  break;
+			case 5:  break;
+			case 6:  break;
+			case 7:  break;
+			case 8:  /* I, Index Store Tag */ cacheop(8, addr); break;
+			case 9:  /* D, Index Store Tag */ cacheop(9, addr); break;
+			case 10: break;
+			case 11: /* S, Index Store Tag */ cacheop(11, addr); break;
+			case 12: break;
+			case 13: break;
+			case 14: break;
+			case 15: break;
+			case 16: /* I, Hit Invalidate */ cacheop(16, addr); break;
+			case 17: /* D, Hit Invalidate */ cacheop(17, addr); break;
+			case 18: break;
+			case 19:
+				/* S, Hit Invalidate, translation will be performed. */
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+				break;
+			case 20: /* I, Hit Writeback */ cacheop(20, addr); break;
+			case 21: /* D, Hit Writeback */ cacheop(21, addr); break;
+			case 22: break;
+			case 23:
+				/* S, Hit Writeback, translation will be performed. */
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+				break;
+			case 24: break;
+			case 25: break;
+			case 26: break;
+			case 27: break;
+			case 28: /* I, Fetch and Lock */ cacheop(28, addr); break;
+			case 29: /* D, Fetch and Lock */ cacheop(29, addr); break;
+			case 30: break;
+			case 31:
+				/* S, Fetch and Lock, translation will be performed. */
+				PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+				break;
+		}
+	} else
+		PSI_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+
+	compute_guest_return_epc(regs, epc_badinstr);
+}
+
+/* Guest field change */
+static void process_fc(struct pt_regs *regs)
+{
+	unsigned int badinstr, epc_badinstr;
+	unsigned long epc;
+
+	epc = regs->cp0_epc;
+	kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+	if ((badinstr >> 26) == 0x10) {
+		if (((badinstr >> 21) & 0x1f) == 0x4) {
+			unsigned int rt = (badinstr >> 16) & 0x1f;
+			unsigned int rd = (badinstr >> 11) & 0x1f;
+			unsigned int sel = badinstr & 0x7;
+
+			if (rd == 12 && sel == 0) {
+				__write_32bit_guest_c0_register($12, 0, regs->regs[rt]);
+			} else if (rd == 13 && sel == 0) {
+				__write_32bit_guest_c0_register($13, 0, regs->regs[rt]);
+			} else if (rd == 12 && sel == 1) {
+				__write_32bit_guest_c0_register($12, 1, regs->regs[rt]);
+			} else if (rd == 25 && (sel == 0 || sel == 2 || sel == 4 || sel == 6)) {
+				/* perf cnt registers: event field may get changed */
+				if (sel == 0)
+					write_c0_perfctrl0(regs->regs[rt] | PERF_GUEST_EC);
+				else if (sel == 2)
+					write_c0_perfctrl1(regs->regs[rt] | PERF_GUEST_EC);
+				else if (sel == 4)
+					write_c0_perfctrl2(regs->regs[rt] | PERF_GUEST_EC);
+				else
+					write_c0_perfctrl3(regs->regs[rt] | PERF_GUEST_EC);
+			} else
+				FC_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+		} else
+			FC_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+	} else
+		FC_UNHANDLED(epc, regs->cp0_cause, badinstr, epc_badinstr);
+
+	compute_guest_return_epc(regs, epc_badinstr);
+}
+
+/* Guest hypercall */
+static void process_hc(struct pt_regs *regs)
+{
+	unsigned int badinstr, epc_badinstr;
+	unsigned long epc;
+	int hc_num;
+
+	epc = regs->cp0_epc;
+	kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+
+	hc_num = regs->regs[2];
+	switch (hc_num) {
+	case KVM_HC_GET_HARD_CPUID:
+	{
+		int i, guest_cpuid = regs->regs[3], host_cpuid = -1;
+		struct kvm *kvm;
+		struct kvm_vcpu *vcpu;
+
+		kvm = ((struct kvm_vcpu *)regs->cp0_osscratch7)->kvm;
+		kvm_for_each_vcpu(i, vcpu, kvm) {
+			if (vcpu->vcpu_id == guest_cpuid) {
+				host_cpuid = __cpu_logical_map[vcpu->arch.host_vcpuid];
+				break;
+			}
+		}
+
+		/* result */
+		if (host_cpuid == (-1)) {
+			regs->regs[2] = -1; /* fail */
+		} else {
+			regs->regs[2] = 0; /* succeed */
+			regs->regs[3] = host_cpuid;
+		}
+		break;
+	}
+	default:
+		printk("Hypercall exception (number %d) not implemented:\n", hc_num);
+		printk("\tepc 0x%lx, badinstr: 0x%x\n", epc, badinstr);
+		break;
+	}
+
+	compute_guest_return_epc(regs, epc_badinstr);
+}
+
+/* Guest reserved instruction redirect */
+static void process_grr(struct pt_regs *regs)
+{
+	panic("GRR exception not implemented\n");
+}
+
+/* Guest cp0 mode change event */
+static void process_mc(struct pt_regs *regs)
+{
+	panic("MC exception not implemented\n");
+}
+
+void process_virt_exception(struct pt_regs *regs)
+{
+	int excode = (regs->cp0_guestctl0 >> 2) & 0x1f;
+
+	switch(excode) {
+	case 0x0:
+		process_psi(regs);
+		break;
+	case 0x1:
+		process_fc(regs);
+		break;
+	case 0x2:
+		process_hc(regs);
+		break;
+	case 0x3:
+		process_grr(regs);
+		break;
+	case 0x9:
+		process_mc(regs);
+		break;
+	default:
+		panic("%s: Unimpled excode %d, epc 0x%lx, bad insn 0x%lx\n",
+			__FUNCTION__, excode, regs->cp0_epc, regs->cp0_badinstr);
+	}
+
+	return;
+}
diff --git a/arch/mips/netlogic/kvm/kvm_uart.c b/arch/mips/netlogic/kvm/kvm_uart.c
new file mode 100644
index 0000000..2a7da73
--- /dev/null
+++ b/arch/mips/netlogic/kvm/kvm_uart.c
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/module.h>
+#include <linux/kvm.h>
+#include <linux/kvm_host.h>
+
+#include <asm/branch.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
+
+#include <asm/netlogic/kvm_xlp.h>
+
+static inline void unhandled_exception(const char *func, unsigned long addr,
+	unsigned long epc, unsigned long write)
+{
+	printk("%s: unhandled address %lx, epc %lx, is_write %lx\n",
+		func, addr, epc, write);
+}
+
+void kvm_handle_pcie_uart(struct pt_regs *regs, unsigned long write,
+		unsigned long address, unsigned long reg_num)
+{
+	unsigned int rindex = address >> 2, unhandled = 0;
+	struct kvm_arch *arch = kvm_get_arch(regs);
+
+	spin_lock(&arch->uart.lock);
+
+	if (rindex == 0x0 || rindex == 0x2 || rindex == 0x3d) {
+		if (!write)
+			regs->regs[reg_num] = arch->uart.header[rindex];
+		else
+			unhandled = 1;
+	} else if (rindex == 0x40) {
+		if (write) {
+			if (arch->uart.lcr & (1 << 7))
+				arch->uart.dlb1 = regs->regs[reg_num];
+			else {
+				uint8_t c = regs->regs[reg_num];
+				uint32_t val, badinstr, epc_badinstr;
+
+				if (arch->uart.ier & 0x2) {
+					arch->uart.iir = 0x2;
+
+					/* For every transmit char, we always generate an interrupt
+					 * for guest to look at the buffer again. This will generate
+					 * one more interrupt than in an actual system:
+					 *  . for the last transmied char, root may simply
+					 *    turned off uart tx interrupt. However, we may still
+					 *    generate this interrupt and guest needs to go through
+					 *    interrupt routine one more time.
+					 *
+					 *    Checked the uart interrupt code. It looks guest OS is
+					 *    able to handle this extra interrupt properly.
+					 */
+					kvm_pic_inject_guest(arch,
+						arch->uart.header[0x3d] & 0xffff,
+						regs);
+				}
+
+				/* Quit the guest and go to QEMU for real print */
+				spin_unlock(&arch->uart.lock);
+
+#if 1
+				/* Huge amount of guest output in a short period of time
+				 * may cause guest uart function incorrectly.
+				 * The below can reproduce the issue:
+				 *    while true; do cat /proc/cpuinfo; done
+				 * If the console switched to qemu and then back to guest, the
+				 * output will be good for a while before it turns bad again.
+				 * The qemu can still break in and kill the guest.
+				 *
+				 * FIXME: it looks like the below workaround fixed the issue.
+				 * But the root cause is unknown at this point.
+				 */
+				udelay(100);
+#endif
+
+				val = (KVM_EXIT_CHAR_PRINT << 24) | c;
+				kvm_get_badinstr(regs, &badinstr, &epc_badinstr);
+				compute_guest_return_epc(regs, epc_badinstr);
+				kvm_save_guest_context(regs, kvm_get_vcpu_guest_regs(regs));
+				__kvm_vcpu_leave_guest((struct kvm_vcpu *)regs->cp0_osscratch7, val);
+			}
+		} else {
+			if (arch->uart.lcr & (1 << 7))
+				regs->regs[reg_num] = arch->uart.dlb1;
+			else {
+				/* read a character */
+				if (arch->uart.input_size > 0) {
+					int idx;
+					regs->regs[reg_num] = arch->uart.input_buf[0];
+
+					arch->uart.input_size --;
+					for (idx = 0; idx < arch->uart.input_size; idx++)
+						arch->uart.input_buf[idx] =
+							arch->uart.input_buf[idx + 1];
+				} else
+					regs->regs[reg_num] = 0x0;
+
+				if (arch->uart.input_size == 0) {
+					/* no data is available */
+					arch->uart.lsr &= 0xfe;
+
+					/* clear "receive data ready" and interrupt */
+					if ((arch->uart.ier & 0x2) == 0) {
+						arch->uart.iir = 0x1;
+					} else
+						arch->uart.iir = 0x2;
+				}
+			}
+		}
+	} else if (rindex == 0x41) {
+		if (write) {
+			if (arch->uart.lcr & (1 << 7))
+				arch->uart.dlb2 = regs->regs[reg_num];
+			else {
+				arch->uart.ier = regs->regs[reg_num] & 0xf;
+
+				/* clear the "transmit" ready interrupt */
+				if ((arch->uart.ier & 0x2) == 0) {
+					if (arch->uart.iir == 0x2)
+						arch->uart.iir = 0x1;
+				}
+			}
+		} else {
+			if (arch->uart.lcr & (1 << 7))
+				regs->regs[reg_num] = arch->uart.dlb2;
+			else {
+				regs->regs[reg_num] = arch->uart.ier;
+			}
+		}
+	} else if (rindex == 0x42) {
+		/* uart interrupt source /fifo control */
+		if (write)
+			; /* do nothing */
+		else {
+			regs->regs[reg_num] = arch->uart.iir;
+		}
+	} else if (rindex == 0x43) {
+		/* line control */
+		if (write)
+			arch->uart.lcr = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->uart.lcr;
+	} else if (rindex == 0x44) {
+		/* modem control */
+		if (write)
+			arch->uart.mcr = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->uart.mcr;
+	} else if (rindex == 0x45) {
+		/* line status */
+		if (write) {
+			arch->uart.lsr = regs->regs[reg_num];
+		} else {
+			regs->regs[reg_num] = arch->uart.lsr;
+		}
+	} else if (rindex == 0x46) {
+		/* modem status  */
+		if (write)
+			arch->uart.msr = regs->regs[reg_num];
+		else
+			regs->regs[reg_num] = arch->uart.msr;
+	} else
+		unhandled = 1;
+
+	spin_unlock(&arch->uart.lock);
+
+	if (unhandled)
+		unhandled_exception(__FUNCTION__, address, regs->cp0_epc, write);
+}
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index a84d6ed..9d2dd42 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -1,3 +1,8 @@
-obj-y				+= setup.o nlm_hal.o
+obj-y				+= setup.o nlm_hal.o dt.o c-xlp.o
 obj-$(CONFIG_SMP)		+= wakeup.o
 obj-$(CONFIG_USB)		+= usb-init.o
+obj-$(CONFIG_USB)		+= usb-init-xlp2.o
+obj-$(CONFIG_SATA_AHCI)		+= ahci_init.o
+obj-$(CONFIG_SATA_AHCI)		+= ahci-init-xlp2.o
+obj-$(CONFIG_NUMA)		+= numa.o
+obj-$(CONFIG_NLM_ENABLE_COP2)	+= cop2.o
diff --git a/arch/mips/netlogic/xlp/ahci-init-xlp2.c b/arch/mips/netlogic/xlp/ahci-init-xlp2.c
new file mode 100644
index 0000000..26fcff5
--- /dev/null
+++ b/arch/mips/netlogic/xlp/ahci-init-xlp2.c
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/bitops.h>
+#include <linux/pci_ids.h>
+#include <linux/nodemask.h>
+
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+
+#define SATA_CTL		0x0
+#define SATA_STATUS		0x1 /* Status Reg */
+#define SATA_INT		0x2 /* Interrupt Reg */
+#define SATA_INT_MASK		0x3 /* Interrupt Mask Reg */
+#define SATA_BIU_TIMEOUT	0x4
+#define AXIWRSPERRLOG		0x5
+#define AXIRDSPERRLOG		0x6
+#define BiuTimeoutLow		0x7
+#define BiuTimeoutHi		0x8
+#define BiuSlvErLow		0x9
+#define BiuSlvErHi		0xa
+#define IO_CONFIG_SWAP_DIS	0xb
+#define CR_REG_TIMER		0xc
+#define CORE_ID			0xd
+#define AXI_SLAVE_OPT1		0xe
+#define PHY_MEM_ACCESS		0xf
+#define PHY0_CNTRL		0x10
+#define PHY0_STAT		0x11
+#define PHY0_RX_ALIGN		0x12
+#define PHY0_RX_EQ_LO		0x13
+#define PHY0_RX_EQ_HI		0x14
+#define PHY0_BIST_LOOP		0x15
+#define PHY1_CNTRL		0x16
+#define PHY1_STAT		0x17
+#define PHY1_RX_ALIGN		0x18
+#define PHY1_RX_EQ_LO		0x19
+#define PHY1_RX_EQ_HI		0x1a
+#define PHY1_BIST_LOOP		0x1b
+#define RdExBase		0x1c
+#define RdExLimit		0x1d
+#define CacheAllocBase		0x1e
+#define CacheAllocLimit		0x1f
+#define BiuSlaveCmdGstNum	0x20
+
+/*SATA_CTL Bits */
+#define SATA_RST_N		BIT(0)  /* Active low reset sata_core phy */
+#define SataCtlReserve0		BIT(1)
+#define M_CSYSREQ		BIT(2)  /* AXI master low power, not used */
+#define S_CSYSREQ		BIT(3)  /* AXI slave low power, not used */
+#define P0_CP_DET		BIT(8)  /* Reserved, bring in from pad */
+#define P0_MP_SW		BIT(9)  /* Mech Switch */
+#define P0_DISABLE		BIT(10) /* disable p0 */
+#define P0_ACT_LED_EN		BIT(11) /* Active LED enable */
+#define P0_IRST_HARD_SYNTH	BIT(12) /* PHY hard synth reset */
+#define P0_IRST_HARD_TXRX	BIT(13) /* PHY lane hard reset */
+#define P0_IRST_POR		BIT(14) /* PHY power on reset*/
+#define P0_IPDTXL		BIT(15) /* PHY Tx lane dis/power down */
+#define P0_IPDRXL		BIT(16) /* PHY Rx lane dis/power down */
+#define P0_IPDIPDMSYNTH		BIT(17) /* PHY synthesizer dis/porwer down */
+#define P0_CP_POD_EN		BIT(18) /* CP_POD enable */
+#define P0_AT_BYPASS		BIT(19) /* P0 address translation by pass */
+#define P1_CP_DET		BIT(20) /* Reserved,Cold Detect */
+#define P1_MP_SW		BIT(21) /* Mech Switch */
+#define P1_DISABLE		BIT(22) /* disable p1 */
+#define P1_ACT_LED_EN		BIT(23) /* Active LED enable */
+#define P1_IRST_HARD_SYNTH	BIT(24) /* PHY hard synth reset */
+#define P1_IRST_HARD_TXRX	BIT(25) /* PHY lane hard reset */
+#define P1_IRST_POR		BIT(26) /* PHY power on reset*/
+#define P1_IPDTXL		BIT(27) /* PHY Tx lane dis/porwer down */
+#define P1_IPDRXL		BIT(28) /* PHY Rx lane dis/porwer down */
+#define P1_IPDIPDMSYNTH		BIT(29) /* PHY synthesizer dis/porwer down */
+#define P1_CP_POD_EN		BIT(30)
+#define P1_AT_BYPASS		BIT(31) /* P1 address translation by pass */
+
+/* Status register */
+#define M_CACTIVE		BIT(0)  /* m_cactive, not used */
+#define S_CACTIVE		BIT(1)  /* s_cactive, not used */
+#define P0_PHY_READY		BIT(8)  /* phy is ready */
+#define P0_CP_POD		BIT(9)  /* Cold PowerOn */
+#define P0_SLUMBER		BIT(10) /* power mode slumber */
+#define P0_PATIAL		BIT(11) /* power mode patial */
+#define P0_PHY_SIG_DET		BIT(12) /* phy dignal detect */
+#define P0_PHY_CALI		BIT(13) /* phy calibration done */
+#define P1_PHY_READY		BIT(16) /* phy is ready */
+#define P1_CP_POD		BIT(17) /* Cold PowerOn */
+#define P1_SLUMBER		BIT(18) /* power mode slumber */
+#define P1_PATIAL		BIT(19) /* power mode patial */
+#define P1_PHY_SIG_DET		BIT(20) /* phy dignal detect */
+#define P1_PHY_CALI		BIT(21) /* phy calibration done */
+
+/* SATA CR_REG_TIMER bits */
+#define CR_TIME_SCALE		(0x1000 << 0)
+
+/* VSEMI PHY specific registers start and end address */
+#define RXCDRCALFOSC0		0x0065
+#define CALDUTY			0x006e
+#define RXDPIF			0x8065
+#define PPMDRIFTMAX_HI		0x80A4
+
+#define nlm_read_sata_reg(b, r)		nlm_read_reg(b, r)
+#define nlm_write_sata_reg(b, r, v)	nlm_write_reg(b, r, v)
+#define nlm_get_sata_pcibase(node)	\
+		nlm_pcicfg_base(XLP9XX_IO_SATA_OFFSET(node))
+#define nlm_get_sata_regbase(node)	\
+		(nlm_get_sata_pcibase(node) + 0x100)
+
+/* Vsemi PHY config for register block 1 0x0065 .. 0x006e */
+static const u8 vsemi_config1[]  = {
+	0xC9, 0xC9, 0x07, 0x07, 0x18, 0x18, 0x01, 0x01, 0x22, 0x00
+};
+
+/* Vsemi PHY config for register block 2 0x0x8065 .. 0x0x80A4 */
+static const u8 vsemi_config2[]  = {
+	0xAA, 0x00, 0x4C, 0xC9, 0xC9, 0x07, 0x07, 0x18,
+	0x18, 0x05, 0x0C, 0x10, 0x00, 0x10, 0x00, 0xFF,
+	0xCF, 0xF7, 0xE1, 0xF5, 0xFD, 0xFD, 0xFF, 0xFF,
+	0xFF, 0xFF, 0xE3, 0xE7, 0xDB, 0xF5, 0xFD, 0xFD,
+	0xF5, 0xF5, 0xFF, 0xFF, 0xE3, 0xE7, 0xDB, 0xF5,
+	0xFD, 0xFD, 0xF5, 0xF5, 0xFF, 0xFF, 0xFF, 0xF5,
+	0x3F, 0x00, 0x32, 0x00, 0x03, 0x01, 0x05, 0x05,
+	0x04, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x04,
+};
+
+static void sata_clear_glue_reg(u64 regbase, u32 off, u32 bit)
+{
+	u32 reg_val;
+
+	reg_val = nlm_read_sata_reg(regbase, off);
+	nlm_write_sata_reg(regbase, off, (reg_val & ~bit));
+}
+
+static void sata_set_glue_reg(u64 regbase, u32 off, u32 bit)
+{
+	u32 reg_val;
+
+	reg_val = nlm_read_sata_reg(regbase, off);
+	nlm_write_sata_reg(regbase, off, (reg_val | bit));
+}
+
+static void write_phy_reg(u64 regbase, u32 addr, u32 physel, u8 data)
+{
+	nlm_write_sata_reg(regbase, PHY_MEM_ACCESS,
+		(1u << 31) | (physel << 24) | (data << 16) | addr);
+	udelay(850);
+}
+
+static void config_vsemi_phy(u64 regbase, u32 node)
+{
+	u32 port, i, reg;
+
+	for (port = 0; port < 2; port++) {
+		for (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)
+			write_phy_reg(regbase, reg, port, vsemi_config1[i]);
+
+		for (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)
+			write_phy_reg(regbase, reg, port, vsemi_config2[i]);
+	}
+}
+
+#if 0	/* DEBUG */
+static u8 read_phy_reg(u64 regbase, u32 addr, u32 physel)
+{
+	u32 val;
+
+	nlm_write_sata_reg(regbase, PHY_MEM_ACCESS,
+		(0 << 31) | (physel << 24) | (data << 16) | addr);
+	udelay(850);
+	val = nlm_read_sata_reg(regbase, PHY_MEM_ACCESS);
+	return (val >> 16) & 0xff;
+}
+
+static void check_phy_register(u63 regbase, u32 addr, u32 physel, u8 xdata)
+{
+	u64 regbase;
+	u8 data;
+
+	data = read_phy_reg(regbase, addr, physel);
+	pr_info("PHY read addr = 0x%x physel = %d data = 0x%x %s\n",
+		addr, physel, data, data == xdata ? "TRUE" : "FALSE");
+}
+
+static void verify_vsemi_config(u64 regbase, u32 node)
+{
+	u32 port, i, reg;
+
+	for (port = 0; port < 2; port++) {
+		for (i = 0, reg = RXCDRCALFOSC0; reg <= CALDUTY; reg++, i++)
+			check_phy_register(regbase, node, reg, port,
+					vsemi_config1[i]);
+
+		for (i = 0, reg = RXDPIF; reg <= PPMDRIFTMAX_HI; reg++, i++)
+			check_phy_register(regbase, node, reg, port,
+					vsemi_config2[i]);
+	}
+}
+#endif
+
+static void nlm_sata_firmware_init(int node)
+{
+	u32 reg_val;
+	u64 regbase;
+	int n;
+
+	pr_info("Initializing XLP9XX On-chip AHCI...\n");
+	regbase = nlm_get_sata_regbase(node);
+
+	/* Reset port0 */
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_POR);
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_TXRX);
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_SYNTH);
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IPDTXL);
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IPDRXL);
+	sata_clear_glue_reg(regbase, SATA_CTL, P0_IPDIPDMSYNTH);
+
+
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_POR);
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_TXRX);
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_SYNTH);
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IPDTXL);
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IPDRXL);
+	sata_clear_glue_reg(regbase, SATA_CTL, P1_IPDIPDMSYNTH);
+	udelay(300);
+
+	/* Set PHY */
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IPDTXL);
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IPDRXL);
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IPDIPDMSYNTH);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IPDTXL);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IPDRXL);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IPDIPDMSYNTH);
+
+	udelay(1000);
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IRST_POR);
+	udelay(1000);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IRST_POR);
+	udelay(1000);
+
+	/* setup PHY */
+	config_vsemi_phy(regbase, node);
+#if 0	/* For debug */
+	verify_vsemi_config(regbase, node);
+#endif
+	udelay(1000);
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_TXRX);
+	sata_set_glue_reg(regbase, SATA_CTL, P0_IRST_HARD_SYNTH);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_TXRX);
+	sata_set_glue_reg(regbase, SATA_CTL, P1_IRST_HARD_SYNTH);
+	udelay(300);
+
+	/* Override reset in serial PHY mode */
+	sata_set_glue_reg(regbase, CR_REG_TIMER, CR_TIME_SCALE);
+	/* Set reset SATA */
+	sata_set_glue_reg(regbase, SATA_CTL, SATA_RST_N);
+	sata_set_glue_reg(regbase, SATA_CTL, M_CSYSREQ);
+	sata_set_glue_reg(regbase, SATA_CTL, S_CSYSREQ);
+
+	pr_debug("Waiting for PHYs to come up.\n");
+	n = 10000;
+	do {
+		reg_val = nlm_read_sata_reg(regbase, SATA_STATUS);
+		if ((reg_val & P1_PHY_READY) && (reg_val & P0_PHY_READY))
+			break;
+		udelay(10);
+	} while (--n > 0);
+
+	if (reg_val  & P0_PHY_READY)
+		pr_info("PHY0 is up.\n");
+	else
+		pr_info("PHY0 is down.\n");
+	if (reg_val  & P1_PHY_READY)
+		pr_info("PHY1 is up.\n");
+	else
+		pr_info("PHY1 is down.\n");
+
+	pr_info("XLP AHCI Init Done.\n");
+}
+
+static int __init nlm_ahci_init(void)
+{
+	int node;
+
+	if (!cpu_is_xlp9xx())
+		return 0;
+	for (node = 0; node < NLM_NR_NODES; node++)
+		if (nlm_node_present(node))
+			nlm_sata_firmware_init(node);
+	return 0;
+}
+
+static void nlm_sata_intr_ack(struct irq_data *data)
+{
+	u32 val = 0;
+	u64 regbase;
+
+	regbase = nlm_get_sata_regbase(nlm_nodeid());	/* FIXME */
+	val = nlm_read_sata_reg(regbase, SATA_INT);
+	sata_set_glue_reg(regbase, SATA_INT, val);
+}
+
+static void nlm_sata_fixup_final(struct pci_dev *dev)
+{
+	u32 val;
+	u64 regbase;
+	int node;
+
+	/* Find end bridge function to find node */
+	node = xlp_socdev_to_node(dev);
+	regbase = nlm_get_sata_regbase(node);
+
+	/* clear pending interrupts and then enable them */
+	val = nlm_read_sata_reg(regbase, SATA_INT);
+	sata_set_glue_reg(regbase, SATA_INT, val);
+
+	/* Enable only the core interrupt */
+	sata_set_glue_reg(regbase, SATA_INT_MASK, 0x1);
+
+	dev->irq = nlm_irq_to_xirq(node, PIC_SATA_IRQ);
+	nlm_set_pic_extra_ack(node, PIC_SATA_IRQ, nlm_sata_intr_ack);
+}
+
+arch_initcall(nlm_ahci_init);
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_XLP9XX_SATA,
+		nlm_sata_fixup_final);
diff --git a/arch/mips/netlogic/xlp/ahci_init.c b/arch/mips/netlogic/xlp/ahci_init.c
new file mode 100644
index 0000000..a271f4d
--- /dev/null
+++ b/arch/mips/netlogic/xlp/ahci_init.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/bitops.h>
+
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/mips-extns.h>
+
+#define SATA_CTL		0x0
+#define SATA_STATUS		0x1	/* Status Reg */
+#define SATA_INT		0x2	/* Interrupt Reg */
+#define SATA_INT_MASK		0x3	/* Interrupt Mask Reg */
+#define SATA_CR_REG_TIMER	0x4	/* PHY Conrol Timer Reg */
+#define SATA_CORE_ID		0x5	/* Core ID Reg */
+#define SATA_AXI_SLAVE_OPT1	0x6	/* AXI Slave Options Reg */
+#define SATA_PHY_LOS_LEV	0x7	/* PHY LOS Level Reg */
+#define SATA_PHY_MULTI		0x8	/* PHY Multiplier Reg */
+#define SATA_PHY_CLK_SEL	0x9	/* Clock Select Reg */
+#define SATA_PHY_AMP1_GEN1	0xa	/* PHY Transmit Amplitude Reg 1 */
+#define SATA_PHY_AMP1_GEN2	0xb	/* PHY Transmit Amplitude Reg 2 */
+#define SATA_PHY_AMP1_GEN3	0xc	/* PHY Transmit Amplitude Reg 3 */
+#define SATA_PHY_PRE1		0xd	/* PHY Transmit Preemphasis Reg 1 */
+#define SATA_PHY_PRE2		0xe	/* PHY Transmit Preemphasis Reg 2 */
+#define SATA_PHY_PRE3		0xf	/* PHY Transmit Preemphasis Reg 3 */
+#define SATA_SPDMODE		0x10	/* Speed Mode Reg */
+#define SATA_REFCLK		0x11	/* Reference Clock Control Reg */
+#define SATA_BYTE_SWAP_DIS	0x12	/* byte swap disable */
+
+/*SATA_CTL Bits */
+#define SATA_RST_N		BIT(0)
+#define PHY0_RESET_N		BIT(16)
+#define PHY1_RESET_N		BIT(17)
+#define PHY2_RESET_N		BIT(18)
+#define PHY3_RESET_N		BIT(19)
+#define M_CSYSREQ		BIT(2)
+#define S_CSYSREQ		BIT(3)
+
+/*SATA_STATUS Bits */
+#define P0_PHY_READY		BIT(4)
+#define P1_PHY_READY		BIT(5)
+#define P2_PHY_READY		BIT(6)
+#define P3_PHY_READY		BIT(7)
+
+#define nlm_read_sata_reg(b, r)		nlm_read_reg(b, r)
+#define nlm_write_sata_reg(b, r, v)	nlm_write_reg(b, r, v)
+#define nlm_get_sata_pcibase(node)	\
+		nlm_pcicfg_base(XLP3XX_IO_SATA_OFFSET(node))
+/* SATA device specific configuration registers are starts at 0x900 offset */
+#define nlm_get_sata_regbase(node)	\
+		(nlm_get_sata_pcibase(node) + 0x900)
+
+static void sata_clear_glue_reg(uint64_t regbase, uint32_t off, uint32_t bit)
+{
+	uint32_t reg_val;
+
+	reg_val = nlm_read_sata_reg(regbase, off);
+	nlm_write_sata_reg(regbase, off, (reg_val & ~bit));
+}
+
+static void sata_set_glue_reg(uint64_t regbase, uint32_t off, uint32_t bit)
+{
+	uint32_t reg_val;
+
+	reg_val = nlm_read_sata_reg(regbase, off);
+	nlm_write_sata_reg(regbase, off, (reg_val | bit));
+}
+
+static void nlm_sata_firmware_init(int node)
+{
+	uint32_t reg_val;
+	uint64_t regbase;
+	int i;
+
+	pr_info("XLP AHCI Initialization started.\n");
+	regbase = nlm_get_sata_regbase(node);
+
+	/* Reset SATA */
+	sata_clear_glue_reg(regbase, SATA_CTL, SATA_RST_N);
+	/* Reset PHY */
+	sata_clear_glue_reg(regbase, SATA_CTL,
+			(PHY3_RESET_N | PHY2_RESET_N
+			 | PHY1_RESET_N | PHY0_RESET_N));
+
+	/* Set SATA */
+	sata_set_glue_reg(regbase, SATA_CTL, SATA_RST_N);
+	/* Set PHY */
+	sata_set_glue_reg(regbase, SATA_CTL,
+			(PHY3_RESET_N | PHY2_RESET_N
+			 | PHY1_RESET_N | PHY0_RESET_N));
+
+	pr_debug("Waiting for PHYs to come up.\n");
+	i = 0;
+	do {
+		reg_val = nlm_read_sata_reg(regbase, SATA_STATUS);
+		i++;
+	} while (((reg_val & 0xF0) != 0xF0) && (i < 10000));
+
+	for (i = 0; i < 4; i++) {
+		if (reg_val  & (P0_PHY_READY << i))
+			pr_info("PHY%d is up.\n", i);
+		else
+			pr_info("PHY%d is down.\n", i);
+	}
+
+	pr_info("XLP AHCI init done.\n");
+}
+
+static int __init nlm_ahci_init(void)
+{
+	int node = 0;
+	int chip = read_c0_prid() & 0xff00;
+	if (chip == PRID_IMP_NETLOGIC_XLP3XX)
+		nlm_sata_firmware_init(node);
+	return 0;
+}
+
+static void nlm_sata_intr_ack(struct irq_data *data)
+{
+	uint32_t val = 0;
+	uint64_t regbase;
+
+	regbase = nlm_get_sata_regbase(nlm_nodeid());
+	val = nlm_read_sata_reg(regbase, SATA_INT);
+	sata_set_glue_reg(regbase, SATA_INT, val);
+}
+
+static void nlm_sata_fixup_final(struct pci_dev *dev)
+{
+	uint32_t val;
+	uint64_t regbase;
+	int node = 0; /* XLP3XX does not support multi-node */
+
+	regbase = nlm_get_sata_regbase(node);
+
+	/* clear pending interrupts and then enable them */
+	val = nlm_read_sata_reg(regbase, SATA_INT);
+	sata_set_glue_reg(regbase, SATA_INT, val);
+
+	/* Mask the core interrupt. If all the interrupts
+	 * are enabled there are spurious interrupt flow
+	 * happening, to avoid only enable core interrupt
+	 * mask.
+	 */
+	sata_set_glue_reg(regbase, SATA_INT_MASK, 0x1);
+
+	dev->irq = PIC_SATA_IRQ;
+	nlm_set_pic_extra_ack(node, PIC_SATA_IRQ, nlm_sata_intr_ack);
+}
+
+arch_initcall(nlm_ahci_init);
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_SATA,
+		nlm_sata_fixup_final);
diff --git a/arch/mips/netlogic/xlp/c-xlp.c b/arch/mips/netlogic/xlp/c-xlp.c
new file mode 100644
index 0000000..da7161a
--- /dev/null
+++ b/arch/mips/netlogic/xlp/c-xlp.c
@@ -0,0 +1,412 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <asm/ptrace.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlp-hal/cpucontrol.h>
+#include <asm/netlogic/xlp-hal/bridge.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+/* Bridge error masks and shifts */
+#define XLP9XX_REQ_SRC_SHIFT		7
+#define XLP9XX_REQ_SRC_MASK		0xfff
+
+#define REQ_SRC_NODE_MASK		0x7
+#define REQ_SRC_ID_SHIFT		3
+#define REQ_SRC_ID_MASK			0x3
+#define REQ_SRC_RX_SHIFT		5
+#define REQ_SRC_RX_MASK			0x1
+#define REQ_SRC_PCIE_FN_MASK		0x7
+#define REQ_SRC_PCIE_DEV_SHIFT		3
+#define REQ_SRC_PCIE_DEV_MASK		0x1f
+#define REQ_SRC_TYPE_SHIFT		8
+#define REQ_SRC_TYPE_MASK		0x1
+#define REQ_SRC_AGENT_SHIFT		9
+#define REQ_SRC_AGENT_MASK		0x7
+#define REQ_SRC_CPU_MASK		0x000
+#define SRC_CPU_ID_MASK			0x1ff
+#define REQ_SRC_NBU_MASK		0x001
+#define SRC_NBU_TYPE_SHIFT		7
+#define SRC_NBU_TYPE_MASK		0x3
+#define SRC_TXVC_SHIFT			6
+#define SRC_TXVC_MASK			0x1
+#define SRC_RXVC_SHIFT			5
+#define SRC_RXVC_MASK			0x1
+#define SRC_NBU_TILE_MASK		0x7
+#define REQ_SRC_DMC_MASK		0x010
+#define SRC_DMC_TILE_MASK		0x3
+#define REQ_SRC_IO_MASK			0x011
+#define REQ_SRC_GCU_MASK		0x100
+
+#define XLP9XX_TARGET_ID		0xc3
+#define XLP9XX_TARGETID_MASK		0xffffffe7
+
+/* ICU error masks and shifts */
+#define ICU_CERR_VALID_MASK	0xf
+#define ICU_CERR_OPTYPE_SHIFT	6
+#define ICU_CERR_OPTYPE_MASK	0x7
+#define ICU_CERR_ERRTYPE_SHIFT	9
+#define ICU_CERR_ERRTYPE_MASK	0x7
+#define ICU_CERR_INFO_SHIFT	12
+#define ICU_CERR_INFO_MASK	0xf
+
+/* L2 error masks and shifts */
+#define SCU_OP_TYP_SHIFT	4
+#define SCU_OP_TYP_MASK		0x3
+#define SCU_ERR_TYP_SHIFT	8
+#define SCU_ERR_TYP_MASK	0x3
+
+/* L3 Cache Error Registers */
+#define TCU_ERR_LOG0		0xfc
+#define TCU_OP_TYPE_SHIFT	4
+#define TCU_OP_TYPE_MASK	0x7
+
+#define TCU_ERR_LOG1		0xfd
+#define TCU_ERR_LOG2		0xfe
+
+#define XLP9XX_TCU_ERR_LOG0	0xd9
+#define XLP9XX_TCU_ERR_LOG1	0xda
+#define XLP9XX_TCU_ERR_LOG2	0xdb
+
+static void xlp9xx_err_info(uint32_t aerr_reg)
+{
+	uint32_t err_val;
+	int val;
+	char *err_id[] = {"Request", "Snoop", "Self Snoop"};
+	char *nbu_err[] = {"Flush", "MUnit", "L3", "Snoop Queue"};
+
+	err_val = (aerr_reg >> XLP9XX_REQ_SRC_SHIFT) &
+		XLP9XX_REQ_SRC_MASK;
+	pr_err("Error Source Info:\n");
+	pr_err("\tNode ID:\t%d\n", err_val & REQ_SRC_NODE_MASK);
+	pr_err("\tPCIe Func:\t%d\n", err_val & REQ_SRC_PCIE_FN_MASK);
+
+	val = (err_val >> REQ_SRC_ID_SHIFT) & REQ_SRC_ID_MASK;
+	pr_err("\tID:\t%s", val < 3 ? err_id[val] : "Unknown");
+
+	val = (err_val >> REQ_SRC_RX_SHIFT) & REQ_SRC_RX_MASK;
+	pr_err("\tOperation:\t%s\n", val ? "RX" : "TX");
+
+	val = (err_val >> REQ_SRC_PCIE_DEV_SHIFT) &
+		REQ_SRC_PCIE_DEV_MASK;
+	pr_err("\tPCIe Device:\t%x", val);
+
+	val = (err_val >> REQ_SRC_TYPE_SHIFT) & REQ_SRC_TYPE_MASK;
+	pr_err("\tType:\t%s", val ? "Slave" : "Master");
+
+	val = (err_val >> REQ_SRC_AGENT_SHIFT) & REQ_SRC_AGENT_MASK;
+	pr_err("Error Agent:\n");
+	switch (val) {
+	case REQ_SRC_CPU_MASK:
+		pr_err("\tCPU ID:\t%x", err_val & SRC_CPU_ID_MASK);
+		break;
+	case REQ_SRC_NBU_MASK:
+		val = (err_val >> SRC_NBU_TYPE_SHIFT) & SRC_NBU_TYPE_MASK;
+		pr_err("\tNBU:\n");
+		pr_err("\t\tType:\t%s\n", val < 4 ? nbu_err[val] : "Unknown");
+
+		val = (err_val >> SRC_TXVC_SHIFT) & SRC_TXVC_MASK;
+		if (val)
+			pr_err("\t\tTX_VC\n");
+
+		val = (err_val >> SRC_RXVC_SHIFT) & SRC_RXVC_MASK;
+		if (val)
+			pr_err("\t\tRX_VC\n");
+
+		val = err_val & SRC_NBU_TILE_MASK;
+		pr_err("\t\tNBU Tile ID\n%x\n", val);
+
+		break;
+	case REQ_SRC_DMC_MASK:
+		val = err_val & SRC_DMC_TILE_MASK;
+		pr_err("\tDMC tile ID:\t%x\n", val);
+		break;
+	case REQ_SRC_IO_MASK:
+		pr_err("\tIO\n");
+		break;
+	case REQ_SRC_GCU_MASK:
+		pr_err("\tGCU\n");
+		break;
+	default:
+		pr_err("\tUnknown\n");
+	}
+}
+
+static void xlp_address_err(uint32_t aerr_reg)
+{
+	uint32_t val;
+	char *err[] = {"Invalidate", "Read", "Read Excl", "Read Upgrade",
+			"Writeback", "I/O Read", "I/O write", "I/O Read Excl",
+			"L3 cache", "DRAM", "I/O", "GCU", "IODI"};
+
+	if (aerr_reg & BRIDGE_ERR_OV_MASK)
+		pr_err("\tErr Ov\t\t: BAR address overflow\n");
+
+	val = (aerr_reg & BRIDGE_REQ_TYPE_MASK) >> BRIDGE_REQ_TYPE_SHIFT;
+	pr_err("\tReq Type\t: %s\n", (val < 8) ? err[val] : "Unknown");
+
+	if (cpu_is_xlp9xx())
+		xlp9xx_err_info(aerr_reg);
+	else {
+		val = (aerr_reg & BRIDGE_REQ_SRC_MASK) >> BRIDGE_REQ_SRC_SHIFT;
+		if (val >= 0 && val < 8)
+			pr_err("\tSource\t\t: Core [%d]\n", val);
+		else
+			pr_err("\tSource\t\t: %s",
+					(val <= 12) ? err[val] : "Unknown");
+	}
+}
+
+static void check_icu_error(void)
+{
+	uint32_t icu_err_log0, icu_err_log1, icu_err_log2;
+	int val;
+
+	icu_err_log0 = nlm_mfcr(ICU_CERR_LOG0);
+	icu_err_log1 = nlm_mfcr(ICU_CERR_LOG1);
+	icu_err_log2 = nlm_mfcr(ICU_CERR_LOG2);
+
+	if (icu_err_log0 & 0xF) {
+		pr_err("Processor Control Registers:\n");
+		pr_err("\tICU LOG0\t: 0x%x\n", icu_err_log0);
+		val = (icu_err_log0 >> ICU_CERR_OPTYPE_SHIFT) &
+				ICU_CERR_OPTYPE_MASK;
+		if (!val)
+			pr_err("\tOp Type\t: Read Access\n");
+		val = (icu_err_log0 >> ICU_CERR_ERRTYPE_SHIFT) &
+				ICU_CERR_ERRTYPE_MASK;
+		if (!val)
+			pr_err("\tError Type\t: Single-Bit\n");
+		val = (icu_err_log0 >> ICU_CERR_INFO_SHIFT) &
+				ICU_CERR_INFO_MASK;
+		if (!val)
+			pr_err("\tError Info\t: L1 tag RAM\n");
+		if (val == 1)
+			pr_err("\tError Info\t: L1 data RAM\n");
+
+		pr_err("\tBad Physical Address : 0x%llx\n",
+			(((uint64_t)icu_err_log2 & 0xff) << 32) | icu_err_log1);
+	}
+}
+
+static void check_lsu_error(void)
+{
+	uint64_t lsu_cerr_log1;
+	uint32_t lsu_cerr_log0;
+
+	lsu_cerr_log0 = nlm_mfcr(LSU_CERR_LOG0);
+	lsu_cerr_log1 = nlm_mfcr(LSU_CERR_LOG1);
+
+	if (lsu_cerr_log0 & 0xf) {
+		pr_err("Processor Control Registers:\n");
+		pr_err("\nLSU_CERR_LOG0\t:0x%x (error valid)\n", lsu_cerr_log0);
+		pr_err("\tValid\t:0x%x", (lsu_cerr_log0 & 0xf));
+
+		if (lsu_cerr_log0 & BIT(4))
+			pr_err("\tOv\t: Overflow");
+		if (lsu_cerr_log0 & BIT(5))
+			pr_err("\tUc\t: Uncorrectable error");
+		if (!(lsu_cerr_log0 & BIT(6)))
+			pr_err("\tOpType\t: Read");
+		if (!(lsu_cerr_log0 & BIT(10)))
+			pr_err("\tError Type\t: Parity error");
+		if ((lsu_cerr_log0 & BIT(11)))
+			pr_err("\tError Info\t: L1 Data");
+		else
+			pr_err("\tError Info\t: L1 Tag");
+
+		pr_err("Error Physical Address\t: 0x%llx\n", lsu_cerr_log1);
+	}
+}
+
+static void check_scu_error(void)
+{
+	uint32_t scu_log0, scu_log1, scu_log2;
+
+	scu_log0 = nlm_mfcr(SCU_CERR_LOG0);
+	scu_log1 = nlm_mfcr(SCU_CERR_LOG1);
+	scu_log2 = nlm_mfcr(SCU_CERR_LOG2);
+
+	if (scu_log0 & 0x1) {
+		int val;
+		char *err1;
+		char *err[] = {"Load", "Probe", "Store", "Load fill",
+				"Store fill", "Evict Compl"};
+
+		pr_err("SCU[L2] Error Registers:\n");
+		pr_err("\tL2_ERROR_LOG0\t: 0x%x\n", scu_log0);
+
+		val = (scu_log0 >> SCU_OP_TYP_SHIFT) & SCU_OP_TYP_MASK;
+		pr_err("\tOp type\t\t: %s\n", err[val]);
+
+		val = (scu_log0 >> SCU_ERR_TYP_SHIFT) & SCU_ERR_TYP_MASK;
+		if (!val)
+			err1 = "Single-bit Tag RAM";
+		if (val == 1)
+			err1 = "Double-bit Tag RAM";
+		if (val == 2)
+			err1 = "valid Array parity";
+		if (val == 3)
+			err1 = "Single-bit Data RAM";
+		if (val == 4)
+			err1 = "Double-bit Data RAM";
+		if (val == 5)
+			err1 = "DRAM ECC";
+		if (val == 6)
+			err1 = "Evict Compl";
+		pr_info("\tError Type\t: %s\n", err1);
+
+		pr_err("\tSCU Error Address\t: 0x%llx\n",
+			(((uint64_t)scu_log2 & 0xff) << 32) | scu_log1);
+	}
+}
+
+static void check_tcu_error(void)
+{
+	uint64_t base;
+	uint32_t tcu_log0, tcu_log1, tcu_log2;
+
+	base = nlm_get_bridge_regbase(nlm_nodeid());
+	if (cpu_is_xlp9xx()) {
+		tcu_log0 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG0);
+		tcu_log1 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG1);
+		tcu_log2 = nlm_read_bridge_reg(base, XLP9XX_TCU_ERR_LOG2);
+	} else {
+		tcu_log0 = nlm_read_bridge_reg(base, TCU_ERR_LOG0);
+		tcu_log1 = nlm_read_bridge_reg(base, TCU_ERR_LOG1);
+		tcu_log2 = nlm_read_bridge_reg(base, TCU_ERR_LOG2);
+	}
+
+	if (tcu_log0 & 0x1) {
+		int val;
+		char *err[] = { "Read", "Write", "MSG"};
+		pr_err("TCU[L3] Error Registers:\n");
+		pr_err("\tL3_ERROR_LOG0\t: 0x%x\n", tcu_log0);
+		if (tcu_log0 & BIT(1))
+			pr_err("\tOv\t: Overflow\n");
+		if (tcu_log0 & BIT(2))
+			pr_err("\tErr Type\t: Uncorrectable\n");
+
+		val = (tcu_log0 >> TCU_OP_TYPE_SHIFT) & TCU_OP_TYPE_MASK;
+		pr_err("\tOperation Type\t: %s\n", err[val]);
+
+		if (cpu_is_xlp9xx())
+			pr_err("\tTCU LOG1: 0x%x, LOG2: 0x%x\n",
+					tcu_log1, tcu_log2);
+		else
+			pr_err("\tTCU Error Address\t: 0x%llx\n",
+				(((uint64_t)tcu_log2 & 0xff) << 32) | tcu_log1);
+	}
+}
+
+static void check_nbu_error(void)
+{
+	uint64_t base, add_reg2;
+	uint32_t add_reg0, add_reg1;
+
+	base = nlm_get_bridge_regbase(nlm_nodeid());
+	if (cpu_is_xlp9xx()) {
+		add_reg0 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR0);
+		add_reg1 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR1);
+		add_reg2 = nlm_read_bridge_reg(base, BRIDGE_9XX_ADDRESS_ERROR2);
+	} else {
+		add_reg0 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR0);
+		add_reg1 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR1);
+		add_reg2 = nlm_read_bridge_reg(base, BRIDGE_ADDRESS_ERROR2);
+	}
+
+	if (add_reg0 & BRIDGE_ERR_VALID_MASK) {
+		pr_err("Adress Error Registers:");
+		pr_err("\tADDRESS_ERROR0\t: 0x%x (error valid)\n", add_reg0);
+
+		xlp_address_err(add_reg0);
+		pr_err("\tBad Physical Address : 0x%llx\n",
+			(((uint64_t)add_reg2 & 0xff) << 32) | add_reg1);
+	}
+}
+
+static void check_dram_error(void)
+{
+	uint64_t nlm_io_base;
+	uint32_t dram_err_reg0, dram_err_reg1;
+	int i, ctrls;
+
+	ctrls = (read_c0_prid() & 0xff00) == PRID_IMP_NETLOGIC_XLP3XX ? 2 : 4;
+
+	nlm_io_base = nlm_get_bridge_regbase(nlm_nodeid());
+	for (i = 0; i < ctrls ; i++) {
+		if (cpu_is_xlp9xx()) {
+			/* write target ID */
+			uint32_t id = nlm_read_bridge_reg(nlm_io_base,
+					XLP9XX_TARGET_ID);
+			nlm_write_bridge_reg(nlm_io_base, XLP9XX_TARGET_ID,
+					(id & XLP9XX_TARGETID_MASK) | (i << 3));
+
+			dram_err_reg0 = nlm_read_bridge_reg(nlm_io_base,
+					BRIDGE_9XX_DMC_ECCLOG1);
+			dram_err_reg1 = nlm_read_bridge_reg(nlm_io_base,
+					BRIDGE_9XX_DMC_ECCLOG2);
+		} else {
+			dram_err_reg0 = nlm_read_bridge_reg(nlm_io_base,
+					i * 0x80 + BRIDGE_DMC_ECCLOG1);
+			dram_err_reg1 = nlm_read_bridge_reg(nlm_io_base,
+					i * 0x80 + BRIDGE_DMC_ECCLOG2);
+		}
+
+		if (dram_err_reg0 & 0x1) {
+			pr_err("DRAM Registers (channel %d):\n", i);
+			pr_err("\tDRAM ECC LOG0: 0x%x, LOG1: 0x%x\n",
+					dram_err_reg0, dram_err_reg1);
+		}
+	}
+}
+asmlinkage void nlm_cache_error(struct pt_regs *regs)
+{
+	pr_err("Cache Error Exception:\n");
+
+	check_icu_error();	/* ICU	*/
+	check_lsu_error();	/* LSU	*/
+	check_scu_error();	/* L2	*/
+	check_tcu_error();	/* L3	*/
+	check_nbu_error();	/* NBU	*/
+	check_dram_error();	/* DRAM */
+
+	pr_err("CPU [%d]\tErrorEPC \t: 0x%lx\n",
+			read_c0_ebase() & 0x3ff, read_c0_errorepc());
+	die("Cache error exception", regs);
+}
diff --git a/arch/mips/netlogic/xlp/cop2.S b/arch/mips/netlogic/xlp/cop2.S
new file mode 100644
index 0000000..7d5e3af
--- /dev/null
+++ b/arch/mips/netlogic/xlp/cop2.S
@@ -0,0 +1,127 @@
+/*-
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/netlogic/interrupt.h>
+#include <asm/asm-offsets.h>
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+/*
+ * void nlm_cop2_save()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in SAVE_SOME in stackframe.h. It can only
+ *       safely modify k0 and k1.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_save)
+	/*msgring tx buf reg*/
+	dmfc2 k0, $0, 0
+	LONG_S  k0, NLM_COP2_TX_BUF(sp)
+	dmfc2 k0, $0, 1
+	LONG_S  k0, (NLM_COP2_TX_BUF+8)(sp)
+	dmfc2 k0, $0, 2
+	LONG_S k0, (NLM_COP2_TX_BUF+16)(sp)
+	dmfc2 k0, $0, 3
+	LONG_S k0, (NLM_COP2_TX_BUF+24)(sp)
+	
+	/*msgring rx buf reg*/
+	dmfc2 k0, $1, 0
+	LONG_S  k0, NLM_COP2_RX_BUF(sp)
+	dmfc2 k0, $1, 1
+	LONG_S  k0, (NLM_COP2_RX_BUF+8)(sp)
+	dmfc2 k0, $1, 2
+	LONG_S  k0, (NLM_COP2_RX_BUF+16)(sp)
+	dmfc2 k0, $1, 3
+	LONG_S  k0, (NLM_COP2_RX_BUF+24)(sp)
+
+	mfc2 k0, $2, 0
+	sw  k0, NLM_COP2_TX_MSG_STATUS(sp)
+	
+	mfc2 k0, $3, 0
+	jr	ra
+	sw k0, NLM_COP2_RX_MSG_STATUS(sp)
+
+	END(nlm_cop2_save)
+	.set pop
+
+/*
+ * void nlm_cop2_restore()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in RESTORE_SOME in stackframe.h.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_restore)
+	/*msgring tx buf reg*/
+	LONG_L  v1, NLM_COP2_TX_BUF(sp)
+	dmtc2 v1, $0, 0
+	LONG_L  v1, (NLM_COP2_TX_BUF+8)(sp)
+	dmtc2 v1, $0, 1
+	LONG_L  v1, (NLM_COP2_TX_BUF+16)(sp)
+	dmtc2 v1, $0, 2
+	LONG_L  v1, (NLM_COP2_TX_BUF+24)(sp)
+	dmtc2 v1, $0, 3
+
+	/*msgring rx buf reg*/
+	LONG_L  v1, NLM_COP2_RX_BUF(sp)
+	dmtc2 v1, $1, 0
+	LONG_L  v1, (NLM_COP2_RX_BUF+8)(sp)
+	dmtc2 v1, $1, 1
+	LONG_L  v1, (NLM_COP2_RX_BUF+16)(sp)
+	dmtc2 v1, $1, 2
+	LONG_L  v1, (NLM_COP2_RX_BUF+24)(sp)
+	dmtc2 v1, $1, 3
+	lw  v1, NLM_COP2_TX_MSG_STATUS(sp)
+	mtc2 v1, $2, 0
+
+	/*leave bits 28-31 up to date*/
+	li k0, 0xf0000000
+	lw v1, NLM_COP2_RX_MSG_STATUS(sp)
+	or v1, k0, v1
+	xor v1, k0, v1
+	mfc2 k0, $3, 0
+	srl k0, k0, 28
+	sll k0, k0, 28
+	or v1, k0, v1
+	jr	ra
+	mtc2 v1, $3, 0
+	END(nlm_cop2_restore)
+	.set pop
+#endif
+
diff --git a/arch/mips/netlogic/xlp/dt.c b/arch/mips/netlogic/xlp/dt.c
new file mode 100644
index 0000000..987efe2
--- /dev/null
+++ b/arch/mips/netlogic/xlp/dt.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2003-2013 Broadcom Corporation.
+ * All Rights Reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/bootmem.h>
+
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+
+extern u32 __dtb_xlp_evp_begin[], __dtb_xlp_svp_begin[],
+	__dtb_xlp_fvp_begin[], __dtb_xlp_gvp_begin[], __dtb_start[];
+
+void __init *xlp_dt_init(void *fdtp)
+{
+	if (!fdtp) {
+		switch (current_cpu_data.processor_id & 0xff00) {
+#ifdef CONFIG_DT_XLP_GVP
+		case PRID_IMP_NETLOGIC_XLP9XX:
+			fdtp = __dtb_xlp_gvp_begin;
+			break;
+#endif
+#ifdef CONFIG_DT_XLP_FVP
+		case PRID_IMP_NETLOGIC_XLP2XX:
+			fdtp = __dtb_xlp_fvp_begin;
+			break;
+#endif
+#ifdef CONFIG_DT_XLP_SVP
+		case PRID_IMP_NETLOGIC_XLP3XX:
+			fdtp = __dtb_xlp_svp_begin;
+			break;
+#endif
+#ifdef CONFIG_DT_XLP_EVP
+		case PRID_IMP_NETLOGIC_XLP8XX:
+			fdtp = __dtb_xlp_evp_begin;
+			break;
+#endif
+		default:
+			/* Pick a built-in if any, and hope for the best */
+			fdtp = __dtb_start;
+			break;
+		}
+	}
+
+	initial_boot_params = fdtp;
+	return fdtp;
+}
+
+/* Provide FDT blob if the modules need it */
+void *nlm_fdt_blob;
+EXPORT_SYMBOL(nlm_fdt_blob);
+
+EXPORT_SYMBOL(initial_boot_params); /* deprecated */
+
+#ifdef CONFIG_SMP
+static int __init xlp_dt_scan_chosen(unsigned long node, const char *uname,
+				     int depth, void *data)
+{
+	unsigned long size = 0;
+	cpumask_t *mask = data;
+	const __be32 *p;
+	int i, pos, last;
+
+	if (depth != 1 || strcmp(uname, "chosen") != 0)
+		return 0;
+
+	p = of_get_flat_dt_prop(node, "netlogic,cpumask", &size);
+	if (p == NULL)
+		return 1;	/* no cpumask, leave */
+
+	pos = 0;
+	/* iterate over the u32 cpumask values backwards */
+	for (last = (int)size / 4 - 1; last >= 0; last--) {
+		u32 m = be32_to_cpup(&p[last]);
+		for (i = 0; i < sizeof(m) * BITS_PER_BYTE ; i++, pos++) {
+			if (pos == cpumask_size() * BITS_PER_BYTE)
+				goto out;
+			if ((m & (1u << i)) == 0)
+				continue;
+			cpumask_set_cpu(pos, mask);
+		}
+	}
+
+out:
+	return 1;
+}
+#endif
+
+int __init xlp_dt_get_cpumask(cpumask_t *mask)
+{
+#ifdef CONFIG_SMP
+	cpumask_clear(mask);
+	of_scan_flat_dt(xlp_dt_scan_chosen, mask);
+	if (!cpumask_empty(mask))
+		return 1;
+
+	cpumask_setall(mask);
+#else
+	cpumask_set_cpu(0, mask);
+#endif
+	return 0;
+}
+
+void __init device_tree_init(void)
+{
+	unsigned long dt_size;
+	void	*blob;
+
+	if (!initial_boot_params)
+		panic("No device tree!\n");
+
+	/*
+	 * boot mem available now, make a copy of the blob, and
+	 * update initial_boot_params to point there.
+	 */
+	dt_size = be32_to_cpu(initial_boot_params->totalsize);
+	blob = early_init_dt_alloc_memory_arch(dt_size, 8);
+	if (blob == NULL)
+		panic("Could not allocate initial_boot_params\n");
+	memcpy(blob, initial_boot_params, dt_size);
+	nlm_fdt_blob = initial_boot_params = blob;
+	pr_info("fdt copied to %p, size %ld\n", blob, dt_size);
+
+	unflatten_device_tree();
+}
+
+static struct of_device_id __initdata xlp_ids[] = {
+	{ .compatible = "simple-bus", },
+	{},
+};
+
+int __init xlp8xx_ds_publish_devices(void)
+{
+	if (!of_have_populated_dt())
+		return 0;
+	return of_platform_bus_probe(NULL, xlp_ids, NULL);
+}
+
+device_initcall(xlp8xx_ds_publish_devices);
diff --git a/arch/mips/netlogic/xlp/nlm_hal.c b/arch/mips/netlogic/xlp/nlm_hal.c
index 87560e4..7093d8b 100644
--- a/arch/mips/netlogic/xlp/nlm_hal.c
+++ b/arch/mips/netlogic/xlp/nlm_hal.c
@@ -44,6 +44,7 @@
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/bridge.h>
 #include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
@@ -56,6 +57,10 @@ void nlm_node_init(int node)
 	nodep->sysbase = nlm_get_sys_regbase(node);
 	nodep->picbase = nlm_get_pic_regbase(node);
 	nodep->ebase = read_c0_ebase() & (~((1 << 12) - 1));
+	if (cpu_is_xlp9xx())
+		nodep->socbus = xlp9xx_get_socbus(node);
+	else
+		nodep->socbus = 0;
 	spin_lock_init(&nodep->piclock);
 }
 
@@ -64,6 +69,45 @@ int nlm_irq_to_irt(int irq)
 	uint64_t pcibase;
 	int devoff, irt;
 
+	/* bypass for 9xx */
+	if (cpu_is_xlp9xx()) {
+		switch (irq) {
+		case PIC_GPIO_0_IRQ:
+			return 12;
+		case PIC_9XX_XHCI_0_IRQ:
+			return 114;
+		case PIC_9XX_XHCI_1_IRQ:
+			return 115;
+		case PIC_UART_0_IRQ:
+			return 133;
+		case PIC_UART_1_IRQ:
+			return 134;
+		case PIC_SATA_IRQ:
+			return 143;
+		case PIC_MMC_IRQ:
+			return 153;
+		case PIC_PCIE_LINK_LEGACY_IRQ(0):
+		case PIC_PCIE_LINK_LEGACY_IRQ(1):
+		case PIC_PCIE_LINK_LEGACY_IRQ(2):
+		case PIC_PCIE_LINK_LEGACY_IRQ(3):
+			return 191 + irq - PIC_PCIE_LINK_LEGACY_IRQ_BASE;
+#ifdef CONFIG_PCI_MSI
+		case PIC_PCIE_LINK_MSI_IRQ(0):
+		case PIC_PCIE_LINK_MSI_IRQ(1):
+		case PIC_PCIE_LINK_MSI_IRQ(2):
+		case PIC_PCIE_LINK_MSI_IRQ(3):
+			return -2;
+		case PIC_PCIE_MSIX_IRQ(0):
+		case PIC_PCIE_MSIX_IRQ(1):
+		case PIC_PCIE_MSIX_IRQ(2):
+		case PIC_PCIE_MSIX_IRQ(3):
+			return -2;
+#endif
+		}
+		return -1;
+	}
+
+	devoff = 0;
 	switch (irq) {
 	case PIC_UART_0_IRQ:
 		devoff = XLP_IO_UART0_OFFSET(0);
@@ -71,47 +115,98 @@ int nlm_irq_to_irt(int irq)
 	case PIC_UART_1_IRQ:
 		devoff = XLP_IO_UART1_OFFSET(0);
 		break;
-	case PIC_EHCI_0_IRQ:
-		devoff = XLP_IO_USB_EHCI0_OFFSET(0);
-		break;
-	case PIC_EHCI_1_IRQ:
-		devoff = XLP_IO_USB_EHCI1_OFFSET(0);
-		break;
-	case PIC_OHCI_0_IRQ:
-		devoff = XLP_IO_USB_OHCI0_OFFSET(0);
-		break;
-	case PIC_OHCI_1_IRQ:
-		devoff = XLP_IO_USB_OHCI1_OFFSET(0);
-		break;
-	case PIC_OHCI_2_IRQ:
-		devoff = XLP_IO_USB_OHCI2_OFFSET(0);
+	case PIC_MMC_IRQ:
+		devoff = XLP_IO_MMC_OFFSET(0);
 		break;
-	case PIC_OHCI_3_IRQ:
-		devoff = XLP_IO_USB_OHCI3_OFFSET(0);
+	case PIC_I2C_0_IRQ:	/* I2C will be fixed up */
+	case PIC_I2C_1_IRQ:
+	case PIC_I2C_2_IRQ:
+	case PIC_I2C_3_IRQ:
+		if (cpu_is_xlpii())
+			devoff = XLP2XX_IO_I2C_OFFSET(0);
+		else
+			devoff = XLP_IO_I2C0_OFFSET(0);
 		break;
-	case PIC_MMC_IRQ:
-		devoff = XLP_IO_SD_OFFSET(0);
+	case PIC_SATA_IRQ:
+		devoff = XLP3XX_IO_SATA_OFFSET(0);
 		break;
-	case PIC_I2C_0_IRQ:
-		devoff = XLP_IO_I2C0_OFFSET(0);
+	case PIC_GPIO_0_IRQ:
+	case PIC_GPIO_1_IRQ:
+	case PIC_GPIO_2_IRQ:
+	case PIC_GPIO_3_IRQ:
+		devoff = XLP_IO_GPIO_OFFSET(0);
 		break;
-	case PIC_I2C_1_IRQ:
-		devoff = XLP_IO_I2C1_OFFSET(0);
+
+	case PIC_NAND_IRQ:
+		devoff = XLP_IO_NAND_OFFSET(0);
 		break;
 	default:
-		devoff = 0;
-		break;
+		if (cpu_is_xlpii()) {
+			switch (irq) {
+				/* XLP2XX has three XHCI USB controller */
+			case PIC_2XX_XHCI_0_IRQ:
+				devoff = XLP2XX_IO_USB_XHCI0_OFFSET(0);
+				break;
+			case PIC_2XX_XHCI_1_IRQ:
+				devoff = XLP2XX_IO_USB_XHCI1_OFFSET(0);
+				break;
+			case PIC_2XX_XHCI_2_IRQ:
+				devoff = XLP2XX_IO_USB_XHCI2_OFFSET(0);
+				break;
+			}
+		} else {
+			switch (irq) {
+			case PIC_EHCI_0_IRQ:
+				devoff = XLP_IO_USB_EHCI0_OFFSET(0);
+				break;
+			case PIC_EHCI_1_IRQ:
+				devoff = XLP_IO_USB_EHCI1_OFFSET(0);
+				break;
+			case PIC_OHCI_0_IRQ:
+				devoff = XLP_IO_USB_OHCI0_OFFSET(0);
+				break;
+			case PIC_OHCI_1_IRQ:
+				devoff = XLP_IO_USB_OHCI1_OFFSET(0);
+				break;
+			case PIC_OHCI_2_IRQ:
+				devoff = XLP_IO_USB_OHCI2_OFFSET(0);
+				break;
+			case PIC_OHCI_3_IRQ:
+				devoff = XLP_IO_USB_OHCI3_OFFSET(0);
+				break;
+			}
+		}
 	}
 
 	if (devoff != 0) {
 		pcibase = nlm_pcicfg_base(devoff);
 		irt = nlm_read_reg(pcibase, XLP_PCI_IRTINFO_REG) & 0xffff;
-		/* HW bug, I2C 1 irt entry is off by one */
-		if (irq == PIC_I2C_1_IRQ)
-			irt = irt + 1;
-	} else if (irq >= PIC_PCIE_LINK_0_IRQ && irq <= PIC_PCIE_LINK_3_IRQ) {
+		/* HW weirdness, I2C IRT entry has to be fixed up */
+		switch (irq) {
+		case PIC_I2C_1_IRQ:
+			irt = irt + 1; break;
+		case PIC_I2C_2_IRQ:
+			irt = irt + 2; break;
+		case PIC_I2C_3_IRQ:
+			irt = irt + 3; break;
+		case PIC_GPIO_1_IRQ:
+			irt = irt + 1; break;
+		case PIC_GPIO_2_IRQ:
+			irt = irt + 2; break;
+		case PIC_GPIO_3_IRQ:
+			irt = irt + 3; break;
+		}
+	} else if (irq >= PIC_PCIE_LINK_LEGACY_IRQ(0) &&
+			irq <= PIC_PCIE_LINK_LEGACY_IRQ(3)) {
 		/* HW bug, PCI IRT entries are bad on early silicon, fix */
-		irt = PIC_IRT_PCIE_LINK_INDEX(irq - PIC_PCIE_LINK_0_IRQ);
+		irt = PIC_IRT_PCIE_LINK_INDEX(irq -
+					PIC_PCIE_LINK_LEGACY_IRQ_BASE);
+	} else if (irq >= PIC_PCIE_LINK_MSI_IRQ(0) &&
+			irq <= PIC_PCIE_LINK_MSI_IRQ(3)) {
+		irt = -2;
+	} else if (irq >= PIC_PCIE_MSIX_IRQ(0) &&
+			irq <= PIC_PCIE_MSIX_IRQ(3)) {
+		irt = -2;
 	} else {
 		irt = -1;
 	}
@@ -125,20 +220,227 @@ unsigned int nlm_get_core_frequency(int node, int core)
 	uint64_t num, sysbase;
 
 	sysbase = nlm_get_node(node)->sysbase;
-	rstval = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
-	dfsval = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIV_VALUE);
-	pll_divf = ((rstval >> 10) & 0x7f) + 1;
-	pll_divr = ((rstval >> 8)  & 0x3) + 1;
-	ext_div	 = ((rstval >> 30) & 0x3) + 1;
-	dfs_div	 = ((dfsval >> (core * 4)) & 0xf) + 1;
-
-	num = 800000000ULL * pll_divf;
-	denom = 3 * pll_divr * ext_div * dfs_div;
+	if (cpu_is_xlp9xx())
+		rstval = nlm_read_sys_reg(sysbase, SYS_9XX_POWER_ON_RESET_CFG);
+	else
+		rstval = nlm_read_sys_reg(sysbase, SYS_POWER_ON_RESET_CFG);
+	if (cpu_is_xlpii()) {
+		num = 1000000ULL * (400 * 3 + 100 * (rstval >> 26));
+		denom = 3;
+	} else {
+		dfsval = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIV_VALUE);
+		pll_divf = ((rstval >> 10) & 0x7f) + 1;
+		pll_divr = ((rstval >> 8)  & 0x3) + 1;
+		ext_div  = ((rstval >> 30) & 0x3) + 1;
+		dfs_div  = ((dfsval >> (core * 4)) & 0xf) + 1;
+
+		num = 800000000ULL * pll_divf;
+		denom = 3 * pll_divr * ext_div * dfs_div;
+	}
 	do_div(num, denom);
 	return (unsigned int)num;
 }
 
+/* Calculate Frequency to the PIC from PLL.
+ * freq_out = ( ref_freq/2 * (6 + ctrl2[7:0]) + ctrl2[20:8]/2^13 ) /
+ * ((2^ctrl0[7:5]) * Table(ctrl0[26:24]))
+ */
+static unsigned int nlm_xlp2_get_pic_frequency(int node)
+{
+	u32 ctrl_val0, ctrl_val2, vco_post_div, pll_post_div, cpu_xlp9xx;
+	u32 mdiv, fdiv, pll_out_freq_den, reg_select, ref_div, pic_div;
+	u64 sysbase, pll_out_freq_num, ref_clk_select, clockbase, ref_clk;
+
+	sysbase = nlm_get_node(node)->sysbase;
+	clockbase = nlm_get_clock_regbase(node);
+	cpu_xlp9xx = cpu_is_xlp9xx();
+
+	/* Find ref_clk_base */
+	if (cpu_xlp9xx)
+		ref_clk_select = (nlm_read_sys_reg(sysbase,
+				SYS_9XX_POWER_ON_RESET_CFG) >> 18) & 0x3;
+	else
+		ref_clk_select = (nlm_read_sys_reg(sysbase,
+					SYS_POWER_ON_RESET_CFG) >> 18) & 0x3;
+	switch (ref_clk_select) {
+	case 0:
+		ref_clk = 200000000ULL;
+		ref_div = 3;
+		break;
+	case 1:
+		ref_clk = 100000000ULL;
+		ref_div = 1;
+		break;
+	case 2:
+		ref_clk = 125000000ULL;
+		ref_div = 1;
+		break;
+	case 3:
+		ref_clk = 400000000ULL;
+		ref_div = 3;
+		break;
+	}
+
+	/* Find the clock source PLL device for PIC */
+	if (cpu_xlp9xx) {
+		reg_select = nlm_read_sys_reg(clockbase,
+				SYS_9XX_CLK_DEV_SEL) & 0x3;
+		switch (reg_select) {
+		case 0:
+			ctrl_val0 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL0);
+			ctrl_val2 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL2);
+			break;
+		case 1:
+			ctrl_val0 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL0_DEVX(0));
+			ctrl_val2 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL2_DEVX(0));
+			break;
+		case 2:
+			ctrl_val0 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL0_DEVX(1));
+			ctrl_val2 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL2_DEVX(1));
+			break;
+		case 3:
+			ctrl_val0 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL0_DEVX(2));
+			ctrl_val2 = nlm_read_sys_reg(clockbase,
+					SYS_9XX_PLL_CTRL2_DEVX(2));
+			break;
+		}
+	} else {
+		reg_select = (nlm_read_sys_reg(sysbase,
+					SYS_CLK_DEV_SEL) >> 22) & 0x3;
+		switch (reg_select) {
+		case 0:
+			ctrl_val0 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL0);
+			ctrl_val2 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL2);
+			break;
+		case 1:
+			ctrl_val0 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL0_DEVX(0));
+			ctrl_val2 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL2_DEVX(0));
+			break;
+		case 2:
+			ctrl_val0 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL0_DEVX(1));
+			ctrl_val2 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL2_DEVX(1));
+			break;
+		case 3:
+			ctrl_val0 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL0_DEVX(2));
+			ctrl_val2 = nlm_read_sys_reg(sysbase,
+					SYS_PLL_CTRL2_DEVX(2));
+			break;
+		}
+	}
+
+	vco_post_div = (ctrl_val0 >> 5) & 0x7;
+	pll_post_div = (ctrl_val0 >> 24) & 0x7;
+	mdiv = ctrl_val2 & 0xff;
+	fdiv = (ctrl_val2 >> 8) & 0x1fff;
+
+	/* Find PLL post divider value */
+	switch (pll_post_div) {
+	case 1:
+		pll_post_div = 2;
+		break;
+	case 3:
+		pll_post_div = 4;
+		break;
+	case 7:
+		pll_post_div = 8;
+		break;
+	case 6:
+		pll_post_div = 16;
+		break;
+	case 0:
+	default:
+		pll_post_div = 1;
+		break;
+	}
+
+	fdiv = fdiv/(1 << 13);
+	pll_out_freq_num = ((ref_clk >> 1) * (6 + mdiv)) + fdiv;
+	pll_out_freq_den = (1 << vco_post_div) * pll_post_div * 3;
+
+	if (pll_out_freq_den > 0)
+		do_div(pll_out_freq_num, pll_out_freq_den);
+
+	/* PIC post divider, which happens after PLL */
+	if (cpu_xlp9xx)
+		pic_div = nlm_read_sys_reg(clockbase,
+				SYS_9XX_CLK_DEV_DIV) & 0x3;
+	else
+		pic_div = (nlm_read_sys_reg(sysbase,
+					SYS_CLK_DEV_DIV) >> 22) & 0x3;
+	do_div(pll_out_freq_num, 1 << pic_div);
+
+	return pll_out_freq_num;
+}
+
+unsigned int nlm_get_pic_frequency(int node)
+{
+	if (cpu_is_xlpii())
+		return nlm_xlp2_get_pic_frequency(node);
+	else
+		return 133333333;
+}
+
 unsigned int nlm_get_cpu_frequency(void)
 {
 	return nlm_get_core_frequency(0, 0);
 }
+
+/*
+ * Fills upto 8 pairs of entries containing the DRAM map of a node
+ * if n < 0, get dram map for all nodes
+ */
+int xlp_get_dram_map(int n, uint64_t *dram_map)
+{
+	uint64_t bridgebase, base, lim;
+	uint32_t val;
+	unsigned int barreg, limreg, xlatreg;
+	int i, node, rv;
+
+	/* Look only at mapping on Node 0, we don't handle crazy configs */
+	bridgebase = nlm_get_bridge_regbase(0);
+	rv = 0;
+	for (i = 0; i < 8; i++) {
+		if (cpu_is_xlp9xx()) {
+			barreg = BRIDGE_9XX_DRAM_BAR(i);
+			limreg = BRIDGE_9XX_DRAM_LIMIT(i);
+			xlatreg = BRIDGE_9XX_DRAM_NODE_TRANSLN(i);
+		} else {
+			barreg = BRIDGE_DRAM_BAR(i);
+			limreg = BRIDGE_DRAM_LIMIT(i);
+			xlatreg = BRIDGE_DRAM_NODE_TRANSLN(i);
+		}
+		if (n >= 0) {
+			/* node specified, get node mapping of BAR */
+			val = nlm_read_bridge_reg(bridgebase, xlatreg);
+			node = (val >> 1) & 0x3;
+			if (n != node)
+				continue;
+		}
+		val = nlm_read_bridge_reg(bridgebase, barreg);
+		val = (val >>  12) & 0xfffff;
+		base = (uint64_t) val << 20;
+		val = nlm_read_bridge_reg(bridgebase, limreg);
+		val = (val >>  12) & 0xfffff;
+		if (val == 0)   /* BAR not used */
+			continue;
+		lim = ((uint64_t)val + 1) << 20;
+		dram_map[rv] = base;
+		dram_map[rv + 1] = lim;
+		rv += 2;
+	}
+	return rv;
+}
diff --git a/arch/mips/netlogic/xlp/numa.c b/arch/mips/netlogic/xlp/numa.c
new file mode 100644
index 0000000..be5ef3c
--- /dev/null
+++ b/arch/mips/netlogic/xlp/numa.c
@@ -0,0 +1,218 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2013 Broadcom Corporation.
+ *
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include <linux/memblock.h>
+#include <linux/mmzone.h>
+#include <linux/nodemask.h>
+#include <linux/bootmem.h>
+#include <linux/pfn.h>
+#include <linux/initrd.h>
+#include <linux/swap.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/pgalloc.h>
+#include <asm/sections.h>
+
+#include <asm/mach-netlogic/multi-node.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define NODE_RESV_MEM	(64 * 1024)
+struct node_data *__node_data[NLM_NR_NODES];
+EXPORT_SYMBOL(__node_data);
+
+/* @uick and dirty implementation for now */
+int xlp_pa_to_nid(phys_addr_t pa)
+{
+	unsigned long pfn, start, end;
+	int n;
+
+	pfn = PFN_DOWN(pa);
+	for_each_online_node(n) {
+		start = NODE_DATA(n)->node_start_pfn;
+		end = start + NODE_DATA(n)->node_spanned_pages - 1;
+		if (pfn >= start && pfn <= end)
+			return n;
+	}
+	BUG();
+	return 0;		/* not reached */
+}
+
+static void __init init_node_bootmem(int node, unsigned long min_pfn,
+	unsigned long max_pfn)
+{
+	unsigned long freepfn, bootmap_size, kpfn;
+	unsigned long nodedata_size = sizeof(struct node_data);
+	unsigned long ofreepfn;
+
+	/* skip kernel and initrd load area on node it is on */
+	kpfn = max(PFN_UP(__pa(initrd_start)), PFN_UP(__pa_symbol(&_end)));
+	if (kpfn > min_pfn && kpfn <= max_pfn)
+		freepfn = kpfn;
+	else
+		freepfn = min_pfn + PFN_UP(NODE_RESV_MEM);
+
+	/* Allocate node area starting at freepfn */
+	__node_data[node] = __va(PFN_PHYS(freepfn));
+	memset(__node_data[node], 0, PAGE_SIZE * PFN_UP(nodedata_size));
+
+	NODE_DATA(node)->bdata = &bootmem_node_data[node];
+	NODE_DATA(node)->node_start_pfn = min_pfn;
+	NODE_DATA(node)->node_spanned_pages = max_pfn - min_pfn + 1;
+
+	ofreepfn = freepfn;
+	freepfn += PFN_UP(nodedata_size);
+	bootmap_size = init_bootmem_node(NODE_DATA(node), freepfn,
+							min_pfn, max_pfn);
+	free_bootmem_with_active_regions(node, max_pfn);
+	reserve_bootmem_node(NODE_DATA(node), PFN_PHYS(min_pfn),
+		PFN_PHYS(freepfn - min_pfn) + bootmap_size,
+		BOOTMEM_DEFAULT);
+	sparse_memory_present_with_active_regions(node);
+}
+/*
+ * This is done in  bootmem_init() for other mips, but in NUMA config
+ * we need to do it for each node.
+ */
+void __init xlp_numa_bootmem_init(void)
+{
+	uint64_t map[16];
+	unsigned long node_pfn_start, node_pfn_end;	/* from DRAM bars */
+	unsigned long min_node_pfn, max_node_pfn;	/* from device tree */
+	int node, n, i;
+	
+	/*
+	 * At this point, the boot_mem_map is setup from the DTB, and
+	 * that needs to be split based on the NODE memory setup and
+	 * added to the right node
+	 */
+	num_physpages = 0;
+	for_each_online_node(node) {
+		/* Get the node's DRAM map */
+		n = xlp_get_dram_map(node, map);
+		if (n == 0)  {
+			pr_err("Node %d: No DRAM found\n", node);
+			goto fail;
+		}
+		node_pfn_start = PFN_UP(map[0]);
+		node_pfn_end = PFN_DOWN(map[n - 1] - 1);
+
+		/* pick up the pieces of boot_mem_map in this node */
+		max_node_pfn = 0;
+		min_node_pfn = ~0ul;
+		for (i = 0;  i < boot_mem_map.nr_map; i++) {
+			unsigned long pfn_start, pfn_end;
+
+			if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+				continue;
+			pfn_start = PFN_UP(boot_mem_map.map[i].addr);
+			pfn_end = PFN_DOWN(boot_mem_map.map[i].addr
+						+ boot_mem_map.map[i].size);
+			/*
+			 * find which node it falls under, and add it there
+			 */
+			if (pfn_start > node_pfn_end)
+				continue;
+
+			/* if entry starts before node region, discard */
+			if (pfn_start < node_pfn_start)
+				pfn_start = node_pfn_start;
+			/* if entry goes beyond node region, split */
+			if (pfn_end > node_pfn_end)
+				pfn_end = node_pfn_end;
+
+			if (pfn_start >= pfn_end)
+				continue;	/* nothing left in segment */
+
+			num_physpages += pfn_end - pfn_start + 1;
+			memblock_add_node(PFN_PHYS(pfn_start),
+					  PFN_PHYS(pfn_end - pfn_start), node);
+			if (pfn_start < min_node_pfn)
+				min_node_pfn = pfn_start;
+			if (pfn_end > max_node_pfn)
+				max_node_pfn = pfn_end;
+
+		}
+		if (min_node_pfn < max_node_pfn)
+			init_node_bootmem(node, min_node_pfn, max_node_pfn);
+		else {
+			pr_err("No memory on node %d\n", node);
+			goto fail;
+		}
+	}
+
+	return;
+fail:
+	panic("Invalid memory config!\n");
+}
+
+extern unsigned long setup_zero_pages(void);
+
+void __init paging_init(void)
+{
+	unsigned long zones_size[MAX_NR_ZONES] = {0, };
+	unsigned node;
+
+	pagetable_init();
+
+	for_each_online_node(node) {
+		unsigned long start_pfn, end_pfn;
+
+		get_pfn_range_for_nid(node, &start_pfn, &end_pfn);
+
+		if (end_pfn > max_low_pfn)
+			max_low_pfn = end_pfn;
+	}
+	zones_size[ZONE_NORMAL] = max_low_pfn;
+	free_area_init_nodes(zones_size);
+}
+
+void __init mem_init(void)
+{
+	unsigned long codesize, datasize, initsize, tmp;
+	unsigned node;
+
+	high_memory = (void *) __va(num_physpages << PAGE_SHIFT);
+
+	for_each_online_node(node) {
+		/*
+		 * This will free up the bootmem, ie, slot 0 memory.
+		 */
+		totalram_pages += free_all_bootmem_node(NODE_DATA(node));
+	}
+
+	totalram_pages -= setup_zero_pages();	/* This comes from node 0 */
+
+	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
+
+	tmp = nr_free_pages();
+	printk(KERN_INFO "Memory: %luk/%luk available (%ldk kernel code, "
+	       "%ldk reserved, %ldk data, %ldk init, %ldk highmem)\n",
+	       tmp << (PAGE_SHIFT-10),
+	       num_physpages << (PAGE_SHIFT-10),
+	       codesize >> 10,
+	       (num_physpages - tmp) << (PAGE_SHIFT-10),
+	       datasize >> 10,
+	       initsize >> 10,
+	       totalhigh_pages << (PAGE_SHIFT-10));
+}
+
+void __init xlp_numa_init(void)
+{
+	int i;
+
+	for (i = 0; i < NLM_NR_NODES; i++)
+		if (nlm_node_present(i))
+			node_set_online(i);
+}
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index eaa99d2..c6aaa33 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -33,22 +33,22 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/serial_8250.h>
-#include <linux/pm.h>
-#include <linux/bootmem.h>
+#include <linux/export.h>
+#include <linux/of_fdt.h>
+#include <linux/module.h>
 
-#include <asm/idle.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/bootinfo.h>
-
-#include <linux/of_fdt.h>
-#include <linux/of_platform.h>
-#include <linux/of_device.h>
+#include <asm/pgtable.h>
+#include <asm/asm-offsets.h>
 
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/common.h>
+#include <asm/netlogic/kvm_para.h>
+#include <asm/netlogic/mips-extns.h>
 
+#include <asm/netlogic/xlp-hal/cpucontrol.h>
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/sys.h>
@@ -57,57 +57,104 @@ uint64_t nlm_io_base;
 struct nlm_soc_info nlm_nodes[NLM_NR_NODES];
 cpumask_t nlm_cpumask = CPU_MASK_CPU0;
 unsigned int nlm_threads_per_core;
-extern u32 __dtb_xlp_evp_begin[], __dtb_xlp_svp_begin[], __dtb_start[];
+unsigned int xlp_cores_per_node;
+int is_nlm_guest_os = 0;
+EXPORT_SYMBOL(is_nlm_guest_os);
+
+DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
+static int enable_pgwalker = 0;
+static int __init enable_pgwalker_cmdline(char *str)
+{
+	enable_pgwalker = 1;
+	return 1;
+}
+__setup("enable_pgwalker", enable_pgwalker_cmdline);
 
 static void nlm_linux_exit(void)
 {
 	uint64_t sysbase = nlm_get_node(0)->sysbase;
 
-	nlm_write_sys_reg(sysbase, SYS_CHIP_RESET, 1);
+	if (cpu_is_xlp9xx())
+		nlm_write_sys_reg(sysbase, SYS_9XX_CHIP_RESET, 1);
+	else
+		nlm_write_sys_reg(sysbase, SYS_CHIP_RESET, 1);
 	for ( ; ; )
 		cpu_wait();
 }
 
+static void xlp_init_mem_from_bars(void)
+{
+	uint64_t map[16];
+	int i, n;
+
+	n = xlp_get_dram_map(-1, map);	/* -1: info for all nodes */
+	for (i = 0; i < n; i += 2) {
+		/* hack to exclude 0x1000_0000 to 0x2000_0000 */
+		if (map[i] < 0x10000000 && map[i+1] > 0x10000000)
+			map[i+1] = 0x10000000;
+		if (map[i] > 0x10000000 && map[i] < 0x20000000)
+			map[i] = 0x20000000;
+
+		add_memory_region(map[i], map[i+1] - map[i], BOOT_MEM_RAM);
+	}
+}
+
 void __init plat_mem_setup(void)
 {
-	void *fdtp;
+#ifdef CONFIG_SMP
+	nlm_wakeup_secondary_cpus();
+
+	/* update TLB size after waking up threads */
+	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
 
+	register_smp_ops(&nlm_smp_ops);
+#endif
 	panic_timeout	= 5;
 	_machine_restart = (void (*)(char *))nlm_linux_exit;
 	_machine_halt	= nlm_linux_exit;
 	pm_power_off	= nlm_linux_exit;
 
-	/*
-	 * If no FDT pointer is passed in, use the built-in FDT.
-	 * device_tree_init() does not handle CKSEG0 pointers in
-	 * 64-bit, so convert pointer.
-	 */
-	fdtp = (void *)(long)fw_arg0;
-	if (!fdtp) {
-		switch (current_cpu_data.processor_id & 0xff00) {
-#ifdef CONFIG_DT_XLP_SVP
-		case PRID_IMP_NETLOGIC_XLP3XX:
-			fdtp = __dtb_xlp_svp_begin;
-			break;
+#ifdef CONFIG_BLK_DEV_INITRD
+	if(fw_arg1){
+		 extern unsigned long initrd_start, initrd_end;
+		 initrd_start = (unsigned long)fw_arg1;
+#if defined(CONFIG_32BIT) && defined (CONFIG_MAPPED_KERNEL)
+		 initrd_start = CKSEG2ADDR(initrd_start);
+#else
+		 initrd_start = CKSEG1ADDR(initrd_start);
 #endif
-#ifdef CONFIG_DT_XLP_EVP
-		case PRID_IMP_NETLOGIC_XLP8XX:
-			fdtp = __dtb_xlp_evp_begin;
-			break;
+		 initrd_end = initrd_start + (unsigned long)fw_arg2;
+		 printk("initrd_start: 0x%lx initrd_end: 0x%lx\n",
+			 initrd_start,initrd_end);
+	}
 #endif
-		default:
-			/* Pick a built-in if any, and hope for the best */
-			fdtp = __dtb_start;
-			break;
-		}
+	/* memory and bootargs from DT */
+	early_init_devtree(initial_boot_params);
+
+	if (boot_mem_map.nr_map == 0) {
+		pr_info("Using DRAM BARs for memory map.\n");
+		xlp_init_mem_from_bars();
 	}
-	fdtp = phys_to_virt(__pa(fdtp));
-	early_init_devtree(fdtp);
+	/* Calculate and setup wired entries for mapped kernel */
+	nlm_fixup_mem();
+#ifdef CONFIG_MAPPED_KERNEL
+	nlm_calc_wired_tlbs();
+	nlm_setup_wired_tlbs();
+#endif
+#ifdef CONFIG_NUMA
+	xlp_numa_init();
+#endif
 }
 
 const char *get_system_type(void)
 {
-	return "Netlogic XLP Series";
+	switch (read_c0_prid() & 0xff00) {
+	case PRID_IMP_NETLOGIC_XLP9XX:
+	case PRID_IMP_NETLOGIC_XLP2XX:
+		return "Broadcom XLPII Series";
+	default:
+		return "Netlogic XLP Series";
+	}
 }
 
 void __init prom_free_prom_memory(void)
@@ -115,66 +162,203 @@ void __init prom_free_prom_memory(void)
 	/* Nothing yet */
 }
 
-void xlp_mmu_init(void)
+void setup_hwp_user_pgd(unsigned long pgd)
 {
-	/* enable extended TLB and Large Fixed TLB */
-	write_c0_config6(read_c0_config6() | 0x24);
-
-	/* set page mask of Fixed TLB in config7 */
-	write_c0_config7(PM_DEFAULT_MASK >>
-		(13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+	get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
+	put_cpu_var(pgd_bases);
 }
 
-void nlm_percpu_init(int hwcpuid)
+void pgwalker_init(void)
 {
-}
+	int i = 0;
+	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0, bd_shift = 0;
+	uint32_t pwctl_val = 0;
 
-void __init prom_init(void)
-{
-	nlm_io_base = CKSEG1ADDR(XLP_DEFAULT_IO_BASE);
-	xlp_mmu_init();
-	nlm_node_init(0);
+	if (enable_pgwalker == 0) {
+		/* If the kernel is root, also disable nested page table walk. */
+		if (cpu_is_xlp9xx() && is_nlm_guest_os == 0)
+			nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) | ((0x1 << 5)));
 
-#ifdef CONFIG_SMP
-	cpumask_setall(&nlm_cpumask);
-	nlm_wakeup_secondary_cpus();
+		return;
+	}
 
-	/* update TLB size after waking up threads */
-	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+	if (!cpu_is_xlpii()) {
+		printk("Hardware page walker is not supported for XLP8XX/XLP3XX\n");
+		return;
+	}
+#ifdef CONFIG_HUGETLB_PAGE
+	else if (!cpu_is_xlp9xx()) {
+		printk("Hardware page walker is not supported for XLP2XX HugeTLB Page\n");
+		return;
+	}
+#ifdef CONFIG_HUGEPAGE_NOT_MIPS_DEFAULT
+	else {
+		/* no mips default style hugepage is enabled,
+		 * hardware page walker does not work for it.
+		 */
+		printk("Hardware page walker is not supported for no mips default huge page\n");
+		return;
+	}
+#endif
+#endif
 
-	register_smp_ops(&nlm_smp_ops);
+	/* Initialize pgd bases to default values */
+	for (i = 0; i < NR_ADDR_SEGMENTS; i++) {
+		get_cpu_var(pgd_bases)[i] = (unsigned long)swapper_pg_dir;
+		put_cpu_var(pgd_bases);
+	}
+
+	pwbase_val = (uint64_t)(long)&(__get_cpu_var(pgd_bases)[0]);
+
+	/* enable page walker */
+	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_O;
+
+#ifdef CONFIG_HUGETLB_PAGE
+	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_HUGETLB;
+	pwctl_val |= _PAGE_HUGE_SHIFT << PWCTL_PW_HUGEVLD_PSN;
+#endif
+
+	/* page table selector */
+	bd_shift = _PGDIR_SHIFT + ffs(_PTRS_PER_PGD) - 1;
+	pwfield_val |= bd_shift << PWFIELD_BD_O;
+	pwsize_val |= ((uint64_t)(ffs(NR_ADDR_SEGMENTS) - 1)) << PWSIZE_BD_O;
+
+	/* global directory */
+	pwfield_val |= ((uint64_t)(_PGDIR_SHIFT)) << PWFIELD_GD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PGD) - 1)) << PWSIZE_GD_O;
+
+	/* upper directory (was initialized to 0) */
+
+#ifndef __PAGETABLE_PMD_FOLDED
+	/* middle directory */
+	pwfield_val |= ((uint64_t)_PMD_SHIFT) << PWFIELD_MD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PMD) - 1)) << PWSIZE_MD_O;
 #endif
+	/* page table index */
+	pwfield_val |= ((uint64_t)PAGE_SHIFT) << PWFIELD_PT_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PTE) - 1)) << PWSIZE_PT_O;
+
+#ifdef CONFIG_64BIT
+	pwsize_val |= ((uint64_t)1) << PWSIZE_PS_O;
+#else
+	/* PWSIZE_PS field was initialized to 0 */
+#endif
+
+	/* logical right rotate of PTE loaded from memory */
+	pwfield_val |= ((uint64_t)_PAGE_GLOBAL_SHIFT) << PWFIELD_PTE_O;
+	/* PWSIZE_PTE field was initialized to 0 (page table entry spacing) */
+
+	/* write registers*/
+	__write_64bit_c0_register($5, 5, pwbase_val);
+	__write_64bit_c0_register($5, 6, pwfield_val);
+	__write_64bit_c0_register($5, 7, pwsize_val);
+	__write_32bit_c0_register($6, 6, pwctl_val);
+
+	get_cpu_var(pgd_bases)[VMALLOC_SEG] = (unsigned long)swapper_pg_dir;
+#ifdef MODULE_START
+	__get_cpu_var(pgd_bases)[MODULE_SEG] = (unsigned long)swapper_pg_dir;
+#endif
+	put_cpu_var(pgd_bases);
+
+	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
 }
 
-void __init device_tree_init(void)
+void xlp_mmu_init(void)
 {
-	unsigned long base, size;
+	u32 conf4;
 
-	if (!initial_boot_params)
-		return;
+	if (cpu_is_xlpii()) {
+		/* the extended TLB is always enabled, the large fixed TLB is enabled by default. */
+#if 0
+		/* disable large fixed TLB */
+		nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) & (~(0x1 << 3)));
+#endif
+		/* turn off hardware page walker cache, workaround for xlp9xx */
+		if (cpu_is_xlp9xx()) {
+			nlm_mtcr(MMU_SETUP, nlm_mfcr(MMU_SETUP) | ((0x1 << 14)));
+		}
 
-	base = virt_to_phys((void *)initial_boot_params);
-	size = be32_to_cpu(initial_boot_params->totalsize);
+		/* XLPII series has extended pagesize in config 4 */
+		conf4 = read_c0_config4() & ~0x1f00u;
+		write_c0_config4(conf4 | ((PAGE_SHIFT - 10) / 2 << 8));
+	} else {
+		/* enable extended TLB and Large Fixed TLB */
+		write_c0_config6(read_c0_config6() | 0x24);
 
-	/* Before we do anything, lets reserve the dt blob */
-	reserve_bootmem(base, size, BOOTMEM_DEFAULT);
+		/* set page mask of extended Fixed TLB in config7 */
+		write_c0_config7(PM_DEFAULT_MASK >>
+			(13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+	}
+}
 
-	unflatten_device_tree();
+static void xlp_guest_check(void)
+{
+	uint32_t saved_val, tmp_val;
 
-	/* free the space reserved for the dt blob */
-	free_bootmem(base, size);
+	saved_val = __read_32bit_c0_register($12, 6); /* read guestctl0 register */
+	__write_32bit_c0_register($12, 6, (1 << 30)); /* guest RI redirect bit */
+	tmp_val = __read_32bit_c0_register($12, 6);
+	if (tmp_val == 0) {
+		/* write has no effect */
+		is_nlm_guest_os = 1;
+	} else {
+		/* not guest mode, restore the original value */
+		__write_32bit_c0_register($12, 6, saved_val);
+	}
 }
+ 
 
-static struct of_device_id __initdata xlp_ids[] = {
-	{ .compatible = "simple-bus", },
-	{},
-};
-
-int __init xlp8xx_ds_publish_devices(void)
+void nlm_percpu_init(int hwcpuid)
 {
-	if (!of_have_populated_dt())
-		return 0;
-	return of_platform_bus_probe(NULL, xlp_ids, NULL);
 }
 
-device_initcall(xlp8xx_ds_publish_devices);
+void __init prom_init(void)
+{
+	void *reset_vec;
+
+	if (cpu_is_xlp9xx())
+		xlp_guest_check();
+	nlm_io_base = CKSEG1ADDR(XLP_DEFAULT_IO_BASE);
+	if (cpu_is_xlp9xx())
+		xlp_cores_per_node = 32;
+	else
+		xlp_cores_per_node = 8;
+	nlm_init_boot_cpu();
+	xlp_mmu_init();
+	nlm_node_init(0);
+	xlp_dt_init((void *)(long)fw_arg0);
+
+	/* Update reset entry point with CPU init code */
+	reset_vec = (void *)CKSEG1ADDR(RESET_VEC_PHYS);
+	memset(reset_vec, 0, RESET_VEC_SIZE);
+	memcpy(reset_vec, (void *)nlm_reset_entry,
+			(nlm_reset_entry_end - nlm_reset_entry));
+
+#ifdef CONFIG_SMP
+	xlp_dt_get_cpumask(&nlm_cpumask);
+#endif
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+	/* Set the CU2 bit here for the bootcpu here.
+	 * In below call stack, COP2 registers saves happened.
+	 *   setup_arch
+	 *     arch_mem_init
+	 *       plat_mem_setup
+	 *         nlm_wakeup_secondary_cpus
+	 *           xlp_wakeup_secondary_cpus
+	 *             xlp_boot_core0_siblings
+	 *               SAVEALL
+	 * In linux/init/main.c, setup_arch is called earlier
+	 * than trap_init. The trap_init setups exception vectors properly
+	 * including enabling CU2 bit in the status register.
+	 *
+	 * For guestOS, if COP2 is not enabled, accessing COP2
+	 * registers will produce guest level exceptions. Since
+	 * exception vectors has not been setup yet, incorrect
+	 * execution will happen.
+	 *
+	 * Enable bootcpu COP2 here.
+	 */ 
+	write_c0_status(read_c0_status() | ST0_CU2);
+#endif
+}
diff --git a/arch/mips/netlogic/xlp/usb-init-xlp2.c b/arch/mips/netlogic/xlp/usb-init-xlp2.c
new file mode 100644
index 0000000..447e703
--- /dev/null
+++ b/arch/mips/netlogic/xlp/usb-init-xlp2.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define XLPII_USB3_CTL_0		0xc0
+#define XLPII_VAUXRST			BIT(0)
+#define XLPII_VCCRST			BIT(1)
+#define XLPII_NUM2PORT			9
+#define XLPII_NUM3PORT			13
+#define XLPII_RTUNEREQ			BIT(20)
+#define XLPII_MS_CSYSREQ		BIT(21)
+#define XLPII_XS_CSYSREQ		BIT(22)
+#define XLPII_RETENABLEN		BIT(23)
+#define XLPII_TX2RX			BIT(24)
+#define XLPII_XHCIREV			BIT(25)
+#define XLPII_ECCDIS			BIT(26)
+
+#define XLPII_USB3_INT_REG		0xc2
+#define XLPII_USB3_INT_MASK		0xc3
+
+#define XLPII_USB_PHY_TEST		0xc6
+#define XLPII_PRESET			BIT(0)
+#define XLPII_ATERESET			BIT(1)
+#define XLPII_LOOPEN			BIT(2)
+#define XLPII_TESTPDHSP		BIT(3)
+#define XLPII_TESTPDSSP		BIT(4)
+#define XLPII_TESTBURNIN		BIT(5)
+
+#define XLPII_USB_PHY_LOS_LV		0xc9
+#define XLPII_LOSLEV			0
+#define XLPII_LOSBIAS			5
+#define XLPII_SQRXTX			8
+#define XLPII_TXBOOST			11
+#define XLPII_RSLKSEL			16
+#define XLPII_FSEL			20
+
+#define XLPII_USB_RFCLK_REG		0xcc
+#define XLPII_VVLD			30
+
+#define nlm_read_usb_reg(b, r)		nlm_read_reg(b, r)
+#define nlm_write_usb_reg(b, r, v)	nlm_write_reg(b, r, v)
+
+#define nlm_xlpii_get_usb_pcibase(node, inst)			\
+			nlm_pcicfg_base(cpu_is_xlp9xx() ?	\
+			XLP9XX_IO_USB_OFFSET(node, inst) :	\
+			XLP2XX_IO_USB_OFFSET(node, inst))
+#define nlm_xlpii_get_usb_regbase(node, inst)		\
+	(nlm_xlpii_get_usb_pcibase(node, inst) + XLP_IO_PCI_HDRSZ)
+
+static void xlp2xx_usb_ack(struct irq_data *data)
+{
+	u64 port_addr;
+
+	switch (data->irq) {
+	case PIC_2XX_XHCI_0_IRQ:
+		port_addr = nlm_xlpii_get_usb_regbase(0, 1);
+		break;
+	case PIC_2XX_XHCI_1_IRQ:
+		port_addr = nlm_xlpii_get_usb_regbase(0, 2);
+		break;
+	case PIC_2XX_XHCI_2_IRQ:
+		port_addr = nlm_xlpii_get_usb_regbase(0, 3);
+		break;
+	default:
+		pr_err("No matching USB irq!\n");
+		return;
+	}
+	nlm_write_usb_reg(port_addr, XLPII_USB3_INT_REG, 0xffffffff);
+}
+
+static void xlp9xx_usb_ack(struct irq_data *data)
+{
+	u64 port_addr;
+	int node;
+	int irq = data->irq % NR_IRQS_PER_NODE;
+
+	/* Find the node without pci-dev */
+	node = data->irq * NR_IRQS_PER_NODE;
+
+	switch (irq) {
+	case PIC_9XX_XHCI_0_IRQ:
+		port_addr = nlm_xlpii_get_usb_regbase(node, 1);
+		break;
+	case PIC_9XX_XHCI_1_IRQ:
+		port_addr = nlm_xlpii_get_usb_regbase(node, 2);
+		break;
+	default:
+		pr_err("No matching USB irq %d node  %d!\n", irq, node);
+		return;
+	}
+	nlm_write_usb_reg(port_addr, XLPII_USB3_INT_REG, 0xffffffff);
+}
+
+static void nlm_xlpii_usb_hw_reset(int node, int port)
+{
+	u64 port_addr, xhci_base, pci_base;
+	void __iomem *corebase;
+	u32 val;
+
+	port_addr = nlm_xlpii_get_usb_regbase(node, port);
+
+	/* Set frequency */
+	val = nlm_read_usb_reg(port_addr, XLPII_USB_PHY_LOS_LV);
+	val &= ~(0x3f << XLPII_FSEL);
+	val |= (0x27 << XLPII_FSEL);
+	nlm_write_usb_reg(port_addr, XLPII_USB_PHY_LOS_LV, val);
+
+	val = nlm_read_usb_reg(port_addr, XLPII_USB_RFCLK_REG);
+	val |= (1 << XLPII_VVLD);
+	nlm_write_usb_reg(port_addr, XLPII_USB_RFCLK_REG, val);
+
+	/* PHY reset */
+	val = nlm_read_usb_reg(port_addr, XLPII_USB_PHY_TEST);
+	val &= (XLPII_ATERESET | XLPII_LOOPEN | XLPII_TESTPDHSP
+		| XLPII_TESTPDSSP | XLPII_TESTBURNIN);
+	nlm_write_usb_reg(port_addr, XLPII_USB_PHY_TEST, val);
+
+	/* Setup control register */
+	val =  XLPII_VAUXRST | XLPII_VCCRST | (1 << XLPII_NUM2PORT)
+		| (1 << XLPII_NUM3PORT) | XLPII_MS_CSYSREQ | XLPII_XS_CSYSREQ
+		| XLPII_RETENABLEN | XLPII_XHCIREV;
+	nlm_write_usb_reg(port_addr, XLPII_USB3_CTL_0, val);
+
+	/* Enabling interrupt on cores */
+	nlm_write_usb_reg(port_addr, XLPII_USB3_INT_MASK, 0x00000001);
+
+	/* clear all interrupts */
+	nlm_write_usb_reg(port_addr, XLPII_USB3_INT_REG, 0xffffffff);
+
+	udelay(2000);
+
+	/* XHCI configuration at PCI mem */
+	pci_base = nlm_xlpii_get_usb_pcibase(node, port);
+	xhci_base = nlm_read_usb_reg(pci_base, 0x4) & ~0xf;
+	corebase = ioremap(xhci_base, 0x10000);
+	if (!corebase)
+		return;
+
+	writel(0x240002, corebase + 0xc2c0);
+	/* GCTL 0xc110 */
+	val = readl(corebase + 0xc110);
+	val &= ~(0x3 << 12);
+	val |= (1 << 12);
+	writel(val, corebase + 0xc110);
+	udelay(100);
+
+	/* PHYCFG 0xc200 */
+	val = readl(corebase + 0xc200);
+	val &= ~(1 << 6);
+	writel(val, corebase + 0xc200);
+	udelay(100);
+
+	/* PIPECTL 0xc2c0 */
+	val = readl(corebase + 0xc2c0);
+	val &= ~(1 << 17);
+	writel(val, corebase + 0xc2c0);
+
+	iounmap((void *) corebase);
+}
+
+static int __init nlm_platform_xlpii_usb_init(void)
+{
+	int node;
+
+	if (!cpu_is_xlpii())
+		return 0;
+
+	if (!cpu_is_xlp9xx()) {
+		/* XLP 2XX single node */
+		pr_info("Initializing 2XX USB Interface\n");
+		nlm_xlpii_usb_hw_reset(0, 1);
+		nlm_xlpii_usb_hw_reset(0, 2);
+		nlm_xlpii_usb_hw_reset(0, 3);
+		nlm_set_pic_extra_ack(0, PIC_2XX_XHCI_0_IRQ, xlp2xx_usb_ack);
+		nlm_set_pic_extra_ack(0, PIC_2XX_XHCI_1_IRQ, xlp2xx_usb_ack);
+		nlm_set_pic_extra_ack(0, PIC_2XX_XHCI_2_IRQ, xlp2xx_usb_ack);
+		return 0;
+	}
+
+	/* XLP 9XX, multi-node */
+	pr_info("Initializing 9XX USB Interface\n");
+	for (node = 0; node < NLM_NR_NODES; node++) {
+		if (!nlm_node_present(node))
+			continue;
+		nlm_xlpii_usb_hw_reset(node, 1);
+		nlm_xlpii_usb_hw_reset(node, 2);
+		nlm_set_pic_extra_ack(node, PIC_9XX_XHCI_0_IRQ, xlp9xx_usb_ack);
+		nlm_set_pic_extra_ack(node, PIC_9XX_XHCI_1_IRQ, xlp9xx_usb_ack);
+	}
+	return 0;
+}
+
+arch_initcall(nlm_platform_xlpii_usb_init);
+
+static u64 xlp_usb_dmamask = ~(u32)0;
+
+/* Fixup the IRQ for USB devices which is exist on XLP9XX SOC PCIE bus */
+static void nlm_xlp9xx_usb_fixup_final(struct pci_dev *dev)
+{
+	int node;
+
+	node = xlp_socdev_to_node(dev);
+	dev->dev.dma_mask		= &xlp_usb_dmamask;
+	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(32);
+	switch (dev->devfn) {
+	case 0x21:
+		dev->irq = nlm_irq_to_xirq(node, PIC_9XX_XHCI_0_IRQ);
+		break;
+	case 0x22:
+		dev->irq = nlm_irq_to_xirq(node, PIC_9XX_XHCI_1_IRQ);
+		break;
+	}
+}
+
+/* Fixup the IRQ for USB devices which is exist on XLP2XX SOC PCIE bus */
+static void nlm_xlp2xx_usb_fixup_final(struct pci_dev *dev)
+{
+	dev->dev.dma_mask		= &xlp_usb_dmamask;
+	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(32);
+	switch (dev->devfn) {
+	case 0x21:
+		dev->irq = PIC_2XX_XHCI_0_IRQ;
+		break;
+	case 0x22:
+		dev->irq = PIC_2XX_XHCI_1_IRQ;
+		break;
+	case 0x23:
+		dev->irq = PIC_2XX_XHCI_2_IRQ;
+		break;
+	}
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_XLP9XX_XHCI,
+		nlm_xlp9xx_usb_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_XHCI,
+		nlm_xlp2xx_usb_fixup_final);
diff --git a/arch/mips/netlogic/xlp/usb-init.c b/arch/mips/netlogic/xlp/usb-init.c
index 9c401dd..91368f5 100644
--- a/arch/mips/netlogic/xlp/usb-init.c
+++ b/arch/mips/netlogic/xlp/usb-init.c
@@ -39,6 +39,7 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 
+#include <asm/netlogic/common.h>
 #include <asm/netlogic/haldefs.h>
 #include <asm/netlogic/xlp-hal/iomap.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
@@ -67,6 +68,8 @@
 #define nlm_get_usb_regbase(node, inst)		\
 	(nlm_get_usb_pcibase(node, inst) + XLP_IO_PCI_HDRSZ)
 
+static int disable_usb;
+
 static void nlm_usb_intr_en(int node, int port)
 {
 	uint32_t val;
@@ -75,7 +78,7 @@ static void nlm_usb_intr_en(int node, int port)
 	port_addr = nlm_get_usb_regbase(node, port);
 	val = nlm_read_usb_reg(port_addr, USB_INT_EN);
 	val = USB_CTRL_INTERRUPT_EN  | USB_OHCI_INTERRUPT_EN |
-		USB_OHCI_INTERRUPT1_EN | USB_CTRL_INTERRUPT_EN	|
+		USB_OHCI_INTERRUPT1_EN | USB_CTRL_INTERRUPT_EN  |
 		USB_OHCI_INTERRUPT_EN | USB_OHCI_INTERRUPT2_EN;
 	nlm_write_usb_reg(port_addr, USB_INT_EN, val);
 }
@@ -100,48 +103,81 @@ static void nlm_usb_hw_reset(int node, int port)
 
 static int __init nlm_platform_usb_init(void)
 {
+	int nr_nodes = 0;
+	int node;
+
+	if (cpu_is_xlpii())
+		return 0;
+
+	for (node = 0; node < NLM_NR_NODES; node++) {
+		if (nlm_node_present(node))
+			nr_nodes++;
+	}
+
+	/* on 8XX multinode, USB is broken */
+	if (nr_nodes != 1) {
+		disable_usb = 1;
+		pr_err("Multinode configuration - USB skipped!\n");
+		return 0;
+	}
+
 	pr_info("Initializing USB Interface\n");
-	nlm_usb_hw_reset(0, 0);
-	nlm_usb_hw_reset(0, 3);
+	node = 0;
+	nlm_usb_hw_reset(node, 0);
+	nlm_usb_hw_reset(node, 3);
 
 	/* Enable PHY interrupts */
-	nlm_usb_intr_en(0, 0);
-	nlm_usb_intr_en(0, 3);
+	nlm_usb_intr_en(node, 0);
+	nlm_usb_intr_en(node, 3);
 
 	return 0;
 }
 
 arch_initcall(nlm_platform_usb_init);
 
-static u64 xlp_usb_dmamask = ~(u32)0;
-
 /* Fixup the IRQ for USB devices which is exist on XLP SOC PCIE bus */
 static void nlm_usb_fixup_final(struct pci_dev *dev)
 {
-	dev->dev.dma_mask		= &xlp_usb_dmamask;
-	dev->dev.coherent_dma_mask	= DMA_BIT_MASK(64);
-	switch (dev->devfn) {
-	case 0x10:
-		dev->irq = PIC_EHCI_0_IRQ;
+	int node, irq;
+
+	irq = 0;
+	node = xlp_socdev_to_node(dev);
+	switch (PCI_FUNC(dev->devfn)) {
+	case 0x0:
+		irq = PIC_EHCI_0_IRQ;
 		break;
-	case 0x11:
-		dev->irq = PIC_OHCI_0_IRQ;
+	case 0x1:
+		irq = PIC_OHCI_0_IRQ;
 		break;
-	case 0x12:
-		dev->irq = PIC_OHCI_1_IRQ;
+	case 0x2:
+		irq = PIC_OHCI_1_IRQ;
 		break;
-	case 0x13:
-		dev->irq = PIC_EHCI_1_IRQ;
+	case 0x3:
+		irq = PIC_EHCI_1_IRQ;
 		break;
-	case 0x14:
-		dev->irq = PIC_OHCI_2_IRQ;
+	case 0x4:
+		irq = PIC_OHCI_2_IRQ;
 		break;
-	case 0x15:
-		dev->irq = PIC_OHCI_3_IRQ;
+	case 0x5:
+		irq = PIC_OHCI_3_IRQ;
 		break;
 	}
+	if (irq)
+		dev->irq = nlm_irq_to_xirq(node, irq);
 }
+
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_EHCI,
 		nlm_usb_fixup_final);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_OHCI,
 		nlm_usb_fixup_final);
+
+static void nlm_usb_fixup_early(struct pci_dev *dev)
+{
+	/* force PCI to ignore device */
+	if (disable_usb)
+		dev->hdr_type = 0x7f;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_EHCI,
+		nlm_usb_fixup_early);
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_NETLOGIC, PCI_DEVICE_ID_NLM_OHCI,
+		nlm_usb_fixup_early);
diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index abb3e08..e33e93a 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -47,28 +47,42 @@
 #include <asm/netlogic/mips-extns.h>
 
 #include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
 static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 {
 	uint32_t coremask, value;
-	int count;
+	int count, resetreg;
 
 	coremask = (1 << core);
 
-	/* Enable CPU clock */
-	value = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL);
-	value &= ~coremask;
-	nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
+	/* Enable CPU clock in case of 8xx/3xx */
+	if (!cpu_is_xlpii()) {
+		value = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL);
+		value &= ~coremask;
+		nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
+	}
+
+	/* On 9XX, mark coherent first */
+	if (cpu_is_xlp9xx()) {
+		value = nlm_read_sys_reg(sysbase, SYS_9XX_CPU_NONCOHERENT_MODE);
+		value &= ~coremask;
+		nlm_write_sys_reg(sysbase, SYS_9XX_CPU_NONCOHERENT_MODE, value);
+	}
 
 	/* Remove CPU Reset */
-	value = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);
+	resetreg = cpu_is_xlp9xx() ? SYS_9XX_CPU_RESET : SYS_CPU_RESET;
+	value = nlm_read_sys_reg(sysbase, resetreg);
 	value &= ~coremask;
-	nlm_write_sys_reg(sysbase, SYS_CPU_RESET, value);
+	nlm_write_sys_reg(sysbase, resetreg, value);
 
-	/* Poll for CPU to mark itself coherent */
+	/* We are done on 9XX */
+	if (cpu_is_xlp9xx())
+		return 1;
+
+	/* Poll for CPU to mark itself coherent on other type of XLP */
 	count = 100000;
 	do {
 		value = nlm_read_sys_reg(sysbase, SYS_CPU_NONCOHERENT_MODE);
@@ -77,30 +91,83 @@ static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 	return count != 0;
 }
 
+static int wait_for_cpus(int cpu, int bootcpu)
+{
+	volatile uint32_t *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+	int i, count, notready;
+
+	count = 0x800000;
+	do {
+		notready = nlm_threads_per_core;
+		for (i = 0; i < nlm_threads_per_core; i++)
+			if (cpu_ready[cpu + i] || cpu == bootcpu)
+				--notready;
+	} while (notready != 0 && --count > 0);
+
+	return count != 0;
+}
+
 static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 {
 	struct nlm_soc_info *nodep;
-	uint64_t syspcibase;
-	uint32_t syscoremask;
-	int core, n, cpu, count, val;
+	uint64_t syspcibase, fusebase;
+	uint32_t syscoremask, mask, fusemask;
+	int core, n, cpu;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
-		syspcibase = nlm_get_sys_pcibase(n);
-		if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
-			break;
+		if (n != 0) {
+			/* check if node exists and is online */
+			if (cpu_is_xlp9xx()) {
+				int b = xlp9xx_get_socbus(n);
+				pr_info("Node %d SoC PCI bus %d.\n", n, b);
+				if (b == 0)
+					break;
+			} else {
+				syspcibase = nlm_get_sys_pcibase(n);
+				if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
+					break;
+			}
+			nlm_node_init(n);
+		}
 
 		/* read cores in reset from SYS */
-		if (n != 0)
-			nlm_node_init(n);
 		nodep = nlm_get_node(n);
-		syscoremask = nlm_read_sys_reg(nodep->sysbase, SYS_CPU_RESET);
+
+		if (cpu_is_xlp9xx()) {
+			fusebase = nlm_get_fuse_regbase(n);
+			fusemask = nlm_read_reg(fusebase, FUSE_9XX_DEVCFG6);
+			mask = 0xfffff;
+		} else {
+			fusemask = nlm_read_sys_reg(nodep->sysbase,
+						SYS_EFUSE_DEVICE_CFG_STATUS0);
+			switch (read_c0_prid() & 0xff00) {
+			case PRID_IMP_NETLOGIC_XLP3XX:
+				mask = 0xf;
+				break;
+			case PRID_IMP_NETLOGIC_XLP2XX:
+				mask = 0x3;
+				break;
+			case PRID_IMP_NETLOGIC_XLP8XX:
+				mask = 0xff;
+				break;
+			default:
+				mask = 0xff;
+				break;
+			}
+		}
+
+		/*
+		 * Fused out cores are set in the fusemask, and the remaining
+		 * cores are renumbered to range 0 .. nactive-1
+		 */
+		syscoremask = (1 << hweight32(~fusemask & mask)) - 1;
+
 		/* The boot cpu */
-		if (n == 0) {
-			syscoremask |= 1;
+		if (n == 0)
 			nodep->coremask = 1;
-		}
 
-		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
+		pr_info("Node %d - SYS/FUSE coremask %x\n", n, syscoremask);
+		for (core = 0; core < nlm_cores_per_node(); core++) {
 			/* we will be on node 0 core 0 */
 			if (n == 0 && core == 0)
 				continue;
@@ -110,7 +177,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 				continue;
 
 			/* see if at least the first hw thread is enabled */
-			cpu = (n * NLM_CORES_PER_NODE + core)
+			cpu = (n * nlm_cores_per_node() + core)
 						* NLM_THREADS_PER_CORE;
 			if (!cpumask_test_cpu(cpu, wakeup_mask))
 				continue;
@@ -122,11 +189,9 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 			/* core is up */
 			nodep->coremask |= 1u << core;
 
-			/* spin until the first hw thread sets its ready */
-			count = 0x20000000;
-			do {
-				val = *(volatile int *)&nlm_cpu_ready[cpu];
-			} while (val == 0 && --count > 0);
+			/* spin until the hw threads sets their ready */
+			if (!wait_for_cpus(cpu, 0))
+				pr_err("Node %d : timeout core %d\n", n, core);
 		}
 	}
 }
@@ -138,6 +203,8 @@ void xlp_wakeup_secondary_cpus()
 	 * first wakeup core 0 threads
 	 */
 	xlp_boot_core0_siblings();
+	if (!wait_for_cpus(0, 0))
+		pr_err("Node 0 : timeout core 0\n");
 
 	/* now get other cores out of reset */
 	xlp_enable_secondary_cores(&nlm_cpumask);
diff --git a/arch/mips/netlogic/xlr/Makefile b/arch/mips/netlogic/xlr/Makefile
index 05902bc..345e687 100644
--- a/arch/mips/netlogic/xlr/Makefile
+++ b/arch/mips/netlogic/xlr/Makefile
@@ -1,2 +1,2 @@
-obj-y			+=  fmn.o fmn-config.o setup.o platform.o platform-flash.o
+obj-y			+=  fmn.o fmn-config.o setup.o platform.o platform-flash.o c-xlr.o
 obj-$(CONFIG_SMP)	+= wakeup.o
diff --git a/arch/mips/netlogic/xlr/c-xlr.c b/arch/mips/netlogic/xlr/c-xlr.c
new file mode 100644
index 0000000..35d8f3f
--- /dev/null
+++ b/arch/mips/netlogic/xlr/c-xlr.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 2003-2013 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <asm/uaccess.h>
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/mips-extns.h>
+#include <asm/netlogic/xlr/bridge.h>
+
+/* XLR Cache Error log registers */
+#define CACHE_ERROR_LOG         0x309
+#define CACHE_ERROR_OVF_LOG     0x30a
+
+static void xlr_system_bridge_err(uint32_t aerr_log)
+{
+	uint32_t err_val;
+	char *err_msg;
+
+	if (aerr_log & BRIDGE_AERR_STAT_MASK) {
+		err_val = aerr_log & BRIDGE_AERR_STAT_MASK;
+		switch (ffs(err_val)) {
+		case 5:
+			err_msg = "L2 Tag";
+			break;
+		case 6:
+			err_msg = "L1 Tag";
+			break;
+		case 7:
+			err_msg = "System Bridge Controller";
+			break;
+		default:
+			err_msg = "Unknown";
+		}
+		pr_err("\t\tDetected by\t: %s [AERR_STATE %#x]\n", err_msg,
+				(unsigned)err_val);
+	}
+
+	if (aerr_log & BRIDGE_AERR_DEVID_MASK) {
+		err_val = (aerr_log & BRIDGE_AERR_DEVID_MASK) >> 8;
+
+		if (err_val >= 0 && err_val < 8)
+			pr_err("\t\tDevice\t: CPU %d [AERR_DEVID 0x%x]\n",
+				err_val, (aerr_log & BRIDGE_AERR_DEVID_MASK));
+		else if (err_val >= 8 && err_val < 16)
+			pr_err("\t\tDevice\t: L2[%d] [AERR_DEVID 0x%x]\n",
+				err_val, (aerr_log & BRIDGE_AERR_DEVID_MASK));
+		else {
+			switch (err_val) {
+			case 17:
+				err_msg = "XGSA";
+				break;
+			case 18:
+				err_msg = "XGSB";
+				break;
+			case 19:
+				err_msg = "RGMII";
+				break;
+			case 20:
+				err_msg = "SAE";
+				break;
+			case 21:
+				err_msg = "GPIO";
+				break;
+			case 22:
+				err_msg = "PCIX";
+				break;
+			case 23:
+				err_msg = "HT";
+				break;
+			case 24:
+				err_msg = "DMA";
+				break;
+			case 25:
+				err_msg = "CDE";
+				break;
+			case 26:
+				err_msg = "PCIe";
+				break;
+			case 27:
+				err_msg = "USB";
+				break;
+			case 28:
+				err_msg = "GMAC Quad 1 or XAUI_1";
+				break;
+			default:
+				err_msg = "Unknown";
+			}
+			pr_err("\t\tDevice\t: %s\n", err_msg);
+		}
+	}
+	if (aerr_log & BRIDGE_AERR_CMD_MASK) {
+		err_val = (aerr_log & BRIDGE_AERR_CMD_MASK) >> 16;
+		switch (err_val) {
+		case 0x0:
+			err_msg = "Idle";
+			break;
+		case 0x1:
+			err_msg = "Write";
+			break;
+		case 0x2:
+			err_msg = "Read";
+			break;
+		case 0x3:
+			err_msg = "Read exclusive";
+			break;
+		case 0x4:
+			err_msg = "Upgrade";
+			break;
+		case 0x5:
+			err_msg = "Invalidate";
+			break;
+		case 0x6:
+			err_msg = "Undefined";
+			break;
+		case 0x7:
+			err_msg = "Write error";
+			break;
+		default:
+			err_msg = "Unknown";
+		}
+		pr_err("\t\tMemory operation: %s [AERR_CMD 0x%x]\n",
+			err_msg, err_val);
+	}
+}
+
+asmlinkage void nlm_cache_error(void)
+{
+	uint64_t cache_error_log, aerr0_log2, aerr0_log3, aerr1_log2,
+		 aerr1_log3;
+	uint32_t aerr0_log1, aerr1_log1;
+	char *err_val;
+
+	cache_error_log = nlm_mfcr(CACHE_ERROR_LOG);
+	aerr0_log1 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG1);
+	aerr0_log2 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG2);
+	aerr0_log3 = nlm_read_reg(nlm_io_base, BRIDGE_AERR_INTR_LOG3);
+	aerr1_log1 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG1);
+	aerr1_log2 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG2);
+	aerr1_log3 = nlm_read_reg(nlm_io_base, BRIDGE_AERR1_INTR_LOG3);
+
+	pr_err("Cache Error Exception:\n");
+	pr_err("Processor Control Registers\n");
+
+	if (cache_error_log) {
+		pr_err("CACHE_ERR_LOG\t\t: 0x%x\n",
+				(unsigned)cache_error_log);
+		if (cache_error_log & (1u << 4))
+			err_val = "Load";
+		else if (cache_error_log & (1u << 5))
+			err_val = "Store";
+		else if (cache_error_log & (1u << 6))
+			err_val = "Double Bit Error";
+		else if (cache_error_log & (1u << 7))
+			err_val = "Tag Parity Error";
+		else if (cache_error_log & (1u << 8))
+			err_val = "Address Error";
+		else if (cache_error_log & (1u << 9))
+			err_val = "Data Error";
+		else if ((cache_error_log & (1ull << 55)))
+			err_val = "Dirty Line";
+		else
+			err_val = "Unknown";
+
+		pr_err("\t\tError type\t: %s\n", err_val);
+	}
+
+	pr_err("\t\tError Address\t: 0x%llx\n", ((cache_error_log >> 10) << 3));
+	pr_err("CACHE_ERROR_OVF_LOG\t: 0x%llx\n",
+			nlm_mfcr(CACHE_ERROR_OVF_LOG));
+
+	if (aerr0_log1 & 0x1) {
+		pr_err("System Bridge Controller AERR0 :\n");
+		pr_err("\t\tAERR0 LOG\t: 0x%x (valid)", aerr0_log1);
+		xlr_system_bridge_err(aerr0_log1);
+		pr_err("AERR0 Physical Address   : 0x%llx\n",
+				(aerr0_log2 << 5) | (aerr0_log3 << 37));
+	} else
+		pr_err("\t\tAERR0 LOG\t: 0 (invalid)");
+
+	if (aerr1_log1 & 0x1) {
+		pr_err("System Bridge Controller AERR1 :\n");
+		pr_err("\tAERR1 LOG\t: 0x%x (valid)\n", aerr1_log1);
+		xlr_system_bridge_err(aerr1_log1);
+		pr_err("AERR1 Physical Address   : 0x%llx\n",
+				(aerr1_log2 << 5) | (aerr1_log3 << 37));
+	} else
+		pr_err("\t\tAERR1 LOG\t: 0 (invalid)\n");
+
+	panic("Can't handle cache error exception\n");
+}
diff --git a/arch/mips/netlogic/xlr/fmn-config.c b/arch/mips/netlogic/xlr/fmn-config.c
index ed3bf0e..e8071d6 100644
--- a/arch/mips/netlogic/xlr/fmn-config.c
+++ b/arch/mips/netlogic/xlr/fmn-config.c
@@ -164,8 +164,8 @@ static void setup_cpu_fmninfo(struct xlr_fmn_info *cpu, int num_core)
 	int i, j;
 
 	for (i = 0; i < num_core; i++) {
-		cpu[i].start_stn_id	= (8 * i);
-		cpu[i].end_stn_id	= (8 * i + 8);
+		cpu[i].start_stn_id     = (8 * i);
+		cpu[i].end_stn_id       = (8 * i + 8);
 
 		for (j = cpu[i].start_stn_id; j < cpu[i].end_stn_id; j++)
 			xlr_board_fmn_config.bucket_size[j] = 32;
diff --git a/arch/mips/netlogic/xlr/fmn.c b/arch/mips/netlogic/xlr/fmn.c
index 4d74f03..d428e84 100644
--- a/arch/mips/netlogic/xlr/fmn.c
+++ b/arch/mips/netlogic/xlr/fmn.c
@@ -74,13 +74,13 @@ static irqreturn_t fmn_message_handler(int irq, void *data)
 	struct nlm_fmn_msg msg;
 	uint32_t mflags, bkt_status;
 
-	mflags = nlm_cop2_enable();
+	mflags = nlm_cop2_enable_irqsave();
 	/* Disable message ring interrupt */
 	nlm_fmn_setup_intr(irq, 0);
 	while (1) {
 		/* 8 bkts per core, [24:31] each bit represents one bucket
 		 * Bit is Zero if bucket is not empty */
-		bkt_status = (nlm_read_c2_status() >> 24) & 0xff;
+		bkt_status = (nlm_read_c2_status0() >> 24) & 0xff;
 		if (bkt_status == 0xff)
 			break;
 		for (bucket = 0; bucket < 8; bucket++) {
@@ -97,16 +97,16 @@ static irqreturn_t fmn_message_handler(int irq, void *data)
 				pr_warn("No msgring handler for stnid %d\n",
 						src_stnid);
 			else {
-				nlm_cop2_restore(mflags);
+				nlm_cop2_disable_irqrestore(mflags);
 				hndlr->action(bucket, src_stnid, size, code,
 					&msg, hndlr->arg);
-				mflags = nlm_cop2_enable();
+				mflags = nlm_cop2_enable_irqsave();
 			}
 		}
 	};
 	/* Enable message ring intr, to any thread in core */
 	nlm_fmn_setup_intr(irq, (1 << nlm_threads_per_core) - 1);
-	nlm_cop2_restore(mflags);
+	nlm_cop2_disable_irqrestore(mflags);
 	return IRQ_HANDLED;
 }
 
@@ -128,7 +128,7 @@ void xlr_percpu_fmn_init(void)
 
 	bucket_sizes = xlr_board_fmn_config.bucket_size;
 	cpu_fmn_info = &xlr_board_fmn_config.cpu[id];
-	flags = nlm_cop2_enable();
+	flags = nlm_cop2_enable_irqsave();
 
 	/* Setup bucket sizes for the core. */
 	nlm_write_c2_bucksize(0, bucket_sizes[id * 8 + 0]);
@@ -166,7 +166,7 @@ void xlr_percpu_fmn_init(void)
 
 	/* enable FMN interrupts on this CPU */
 	nlm_fmn_setup_intr(IRQ_FMN, (1 << nlm_threads_per_core) - 1);
-	nlm_cop2_restore(flags);
+	nlm_cop2_disable_irqrestore(flags);
 }
 
 
@@ -198,7 +198,7 @@ void nlm_setup_fmn_irq(void)
 	/* setup irq only once */
 	setup_irq(IRQ_FMN, &fmn_irqaction);
 
-	flags = nlm_cop2_enable();
+	flags = nlm_cop2_enable_irqsave();
 	nlm_fmn_setup_intr(IRQ_FMN, (1 << nlm_threads_per_core) - 1);
-	nlm_cop2_restore(flags);
+	nlm_cop2_disable_irqrestore(flags);
 }
diff --git a/arch/mips/netlogic/xlr/platform-flash.c b/arch/mips/netlogic/xlr/platform-flash.c
index 6d3c727..340ab16 100644
--- a/arch/mips/netlogic/xlr/platform-flash.c
+++ b/arch/mips/netlogic/xlr/platform-flash.c
@@ -36,7 +36,7 @@ static struct mtd_partition xlr_nor_parts[] = {
 	{
 		.name = "User FS",
 		.offset = 0x800000,
-		.size	= MTDPART_SIZ_FULL,
+		.size   = MTDPART_SIZ_FULL,
 	}
 };
 
@@ -46,13 +46,13 @@ static struct mtd_partition xlr_nor_parts[] = {
 static struct mtd_partition xlr_nand_parts[] = {
 	{
 		.name	= "Root Filesystem",
-		.offset = 64 * 64 * 2048,
+		.offset	= 64 * 64 * 2048,
 		.size	= 432 * 64 * 2048,
 	},
 	{
 		.name	= "Home Filesystem",
-		.offset = MTDPART_OFS_APPEND,
-		.size	= MTDPART_SIZ_FULL,
+		.offset	= MTDPART_OFS_APPEND,
+		.size   = MTDPART_SIZ_FULL,
 	},
 };
 
@@ -74,8 +74,8 @@ static struct platform_device xlr_nor_dev = {
 	.dev	= {
 		.platform_data	= &xlr_nor_data,
 	},
-	.num_resources	= ARRAY_SIZE(xlr_nor_res),
-	.resource	= xlr_nor_res,
+	.num_resources  = ARRAY_SIZE(xlr_nor_res),
+	.resource       = xlr_nor_res,
 };
 
 const char *xlr_part_probes[] = { "cmdlinepart", NULL };
diff --git a/arch/mips/netlogic/xlr/platform.c b/arch/mips/netlogic/xlr/platform.c
index 7b96a91..ce838f9 100644
--- a/arch/mips/netlogic/xlr/platform.c
+++ b/arch/mips/netlogic/xlr/platform.c
@@ -162,18 +162,18 @@ int xls_platform_usb_init(void)
 	nlm_write_reg(usb_mmio, 50, 0x1f000000);
 
 	/* Enable ports */
-	nlm_write_reg(usb_mmio,	 1, 0x07000500);
+	nlm_write_reg(usb_mmio,  1, 0x07000500);
 
 	val = nlm_read_reg(gpio_mmio, 21);
 	if (((val >> 22) & 0x01) == 0) {
 		pr_info("Detected USB Device mode - Not supported!\n");
-		nlm_write_reg(usb_mmio,	 0, 0x01000000);
+		nlm_write_reg(usb_mmio,  0, 0x01000000);
 		return 0;
 	}
 
 	pr_info("Detected USB Host mode - Adding XLS USB devices.\n");
 	/* Clear reset, host mode */
-	nlm_write_reg(usb_mmio,	 0, 0x02000000);
+	nlm_write_reg(usb_mmio,  0, 0x02000000);
 
 	/* Memory resource for various XLS usb ports */
 	usb_mmio = nlm_mmio_base(NETLOGIC_IO_USB_0_OFFSET);
@@ -221,8 +221,8 @@ static struct resource i2c_resources[] = {
 };
 
 static struct platform_device nlm_xlr_i2c_1 = {
-	.name		= "xlr-i2cbus",
-	.id		= 1,
+	.name           = "xlr-i2cbus",
+	.id             = 1,
 	.num_resources	= 1,
 	.resource	= i2c_resources,
 };
diff --git a/arch/mips/netlogic/xlr/setup.c b/arch/mips/netlogic/xlr/setup.c
index 89c8c10..6e5e000 100644
--- a/arch/mips/netlogic/xlr/setup.c
+++ b/arch/mips/netlogic/xlr/setup.c
@@ -36,7 +36,6 @@
 #include <linux/serial_8250.h>
 #include <linux/pm.h>
 
-#include <asm/idle.h>
 #include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/bootinfo.h>
@@ -96,6 +95,10 @@ void __init plat_mem_setup(void)
 	_machine_restart = (void (*)(char *))nlm_linux_exit;
 	_machine_halt	= nlm_linux_exit;
 	pm_power_off	= nlm_linux_exit;
+#if defined(CONFIG_MAPPED_KERNEL) && defined(CONFIG_64BIT)
+	nlm_calc_wired_tlbs();
+	nlm_setup_wired_tlbs();
+#endif
 }
 
 const char *get_system_type(void)
@@ -164,7 +167,7 @@ static void prom_add_memory(void)
 {
 	struct nlm_boot_mem_map *bootm;
 	u64 start, size;
-	u64 pref_backup = 512;	/* avoid pref walking beyond end */
+	u64 pref_backup = 512;  /* avoid pref walking beyond end */
 	int i;
 
 	bootm = (void *)(long)nlm_prom_info.psb_mem_map;
@@ -196,6 +199,7 @@ void __init prom_init(void)
 {
 	int *argv, *envp;		/* passed as 32 bit ptrs */
 	struct psb_info *prom_infop;
+	void *reset_vec;
 #ifdef CONFIG_SMP
 	int i;
 #endif
@@ -208,6 +212,12 @@ void __init prom_init(void)
 	nlm_prom_info = *prom_infop;
 	nlm_init_node();
 
+	/* Update reset entry point with CPU init code */
+	reset_vec = (void *)CKSEG1ADDR(RESET_VEC_PHYS);
+	memset(reset_vec, 0, RESET_VEC_SIZE);
+	memcpy(reset_vec, (void *)nlm_reset_entry,
+			(nlm_reset_entry_end - nlm_reset_entry));
+
 	nlm_early_serial_setup();
 	build_arcs_cmdline(argv);
 	prom_add_memory();
diff --git a/arch/mips/netlogic/xlr/wakeup.c b/arch/mips/netlogic/xlr/wakeup.c
index 3ebf741..eb823bb 100644
--- a/arch/mips/netlogic/xlr/wakeup.c
+++ b/arch/mips/netlogic/xlr/wakeup.c
@@ -53,6 +53,8 @@ int __cpuinit xlr_wakeup_secondary_cpus(void)
 {
 	struct nlm_soc_info *nodep;
 	unsigned int i, j, boot_cpu;
+	volatile u32 *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+	void *handler;
 
 	/*
 	 *  In case of RMI boot, hit with NMI to get the cores
@@ -60,7 +62,11 @@ int __cpuinit xlr_wakeup_secondary_cpus(void)
 	 */
 	nodep = nlm_get_node(0);
 	boot_cpu = hard_smp_processor_id();
-	nlm_set_nmi_handler(nlm_rmiboot_preboot);
+	handler = nlm_rmiboot_preboot;
+#ifdef CONFIG_MAPPED_KERNEL
+	handler = (void *)CKSEG0ADDR(CPHYSADDR((long)handler));
+#endif
+	nlm_set_nmi_handler(handler);
 	for (i = 0; i < NR_CPUS; i++) {
 		if (i == boot_cpu || !cpumask_test_cpu(i, &nlm_cpumask))
 			continue;
@@ -69,9 +75,9 @@ int __cpuinit xlr_wakeup_secondary_cpus(void)
 
 	/* Fill up the coremask early */
 	nodep->coremask = 1;
-	for (i = 1; i < NLM_CORES_PER_NODE; i++) {
+	for (i = 1; i < nlm_cores_per_node(); i++) {
 		for (j = 1000000; j > 0; j--) {
-			if (nlm_cpu_ready[i * NLM_THREADS_PER_CORE])
+			if (cpu_ready[i * NLM_THREADS_PER_CORE])
 				break;
 			udelay(10);
 		}
-- 
1.7.9.5

