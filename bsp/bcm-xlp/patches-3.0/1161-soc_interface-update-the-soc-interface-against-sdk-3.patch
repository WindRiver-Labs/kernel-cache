From c62629df79887ebf5cac9b6843f6b8ec2a00a6e7 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Thu, 19 Jun 2014 11:20:30 +0800
Subject: [PATCH 161/163] soc_interface: update the soc interface against sdk
 3.0.2

rebase the soc interface driver to sdk 3.0.2

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/netlogic/soc_interface/libfdt-wrapper.c |    2 +-
 drivers/netlogic/soc_interface/on_chip.c        |   50 ++++++++++++-----------
 2 files changed, 27 insertions(+), 25 deletions(-)

diff --git a/drivers/netlogic/soc_interface/libfdt-wrapper.c b/drivers/netlogic/soc_interface/libfdt-wrapper.c
index 0716db0..e2e98c0 100644
--- a/drivers/netlogic/soc_interface/libfdt-wrapper.c
+++ b/drivers/netlogic/soc_interface/libfdt-wrapper.c
@@ -58,7 +58,7 @@
 #define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
 #define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
 
-void *fdt;
+extern void *fdt;
 #if 0
 static void *buf; /* = NULL */
 #endif
diff --git a/drivers/netlogic/soc_interface/on_chip.c b/drivers/netlogic/soc_interface/on_chip.c
index 17c8c3c..cf3e18d 100644
--- a/drivers/netlogic/soc_interface/on_chip.c
+++ b/drivers/netlogic/soc_interface/on_chip.c
@@ -38,6 +38,8 @@
 #include <linux/timer.h>
 #include <linux/proc_fs.h>
 
+#include <asm/netlogic/mips-extns.h>
+
 #include "nlm_msgring.h"
 #include "nlm_xlp.h"
 #include "nlm_debug.h"
@@ -72,10 +74,10 @@ extern void nlm_cpu_stat_update_msgring_int(void);
 extern void nlm_cpu_stat_update_msgring_cycles(__u32 cycles);
 extern void nlm_cpu_stat_update_msgring_pic_int(void);
 extern void *fdt;
-EXPORT_SYMBOL(fdt);
+// EXPORT_SYMBOL(fdt);
 
 uint32_t msgring_global_thread_mask = 0;
-uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0}; 
+uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE_9XX*NLM_MAX_CPU_PER_NODE_9XX] = {0};
 /* nlm_cpu_vc_mask is superset and will work in other chip type too. for eg in xlp8xx case it will use just 4x32 fields */
 
 uint32_t nlm_l1_lock[NR_CPUS/4] = {0};
@@ -87,6 +89,7 @@ static vchandler xlp_napi_vc_handlers[NLM_MAX_VC_PER_THREAD];
 typedef int (*intr_vchandler)(int vc);
 static intr_vchandler xlp_intr_vc_handler;
 unsigned int intr_vc_mask[NR_CPUS];
+EXPORT_SYMBOL(intr_vc_mask);
 
 /* make this a read/write spinlock */
 spinlock_t msgrng_lock;
@@ -373,7 +376,7 @@ static uint16_t xlp9xx_vc_to_handle_map[MAX_VC_9XX] = {
 	[1752 ... 1753] = XLP_MSG_HANDLE_INVALID,
 	[1754 ... 1755] = XLP_MSG_HANDLE_ALE,
 	[1756 ... 2047]= XLP_MSG_HANDLE_INVALID,
-	
+
 	/* NODE 2 */
 	[2048 ... 2063] = XLP_MSG_HANDLE_CPU0,
 	[2064 ... 2079] = XLP_MSG_HANDLE_CPU1,
@@ -423,7 +426,7 @@ static uint16_t xlp9xx_vc_to_handle_map[MAX_VC_9XX] = {
 	[2776 ... 2777] = XLP_MSG_HANDLE_INVALID,
 	[2778 ... 2779] = XLP_MSG_HANDLE_ALE,
 	[2780 ... 3071]= XLP_MSG_HANDLE_INVALID,
-	
+
 	/* NODE 3 */
 	[3072 ... 3087] = XLP_MSG_HANDLE_CPU0,
 	[3088 ... 3103] = XLP_MSG_HANDLE_CPU1,
@@ -473,7 +476,7 @@ static uint16_t xlp9xx_vc_to_handle_map[MAX_VC_9XX] = {
 	[3800 ... 3801] = XLP_MSG_HANDLE_INVALID,
 	[3802 ... 3803] = XLP_MSG_HANDLE_ALE,
 	[3804 ... 4095]= XLP_MSG_HANDLE_INVALID,
-	
+
 	/* NODE 4 */
 	[4096 ... 4111] = XLP_MSG_HANDLE_CPU0,
 	[4112 ... 4127] = XLP_MSG_HANDLE_CPU1,
@@ -838,7 +841,11 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 			for(vc = 0; vc < 4; vc++) {
 				if(!(vcmask & (1<<vc)))
 					continue;
-				xlp_intr_vc_handler(vc);
+				/*Don't acknowledge MSG RING interrupt when
+				  intr_vc_handler returns 1*/
+				if(xlp_intr_vc_handler(vc) == 1){
+					pop_vc_mask = pop_vc_mask & ~(1<<vc);
+				}
 			}
 		}
 
@@ -1062,10 +1069,10 @@ void nlm_enable_vc_intr(void)
 	for(cpu=0; cpu<NR_CPUS; cpu++){
                 if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
                         continue;
-		node = cpu / 32;
+		node = nlm_nodeid();
 		for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
 		{
-			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
+			vc_index = (i + (cpu % NLM_MAX_CPU_PER_NODE)*NLM_MAX_VC_PER_THREAD);
 			if(nlm_cpu_vc_mask[cpu] & (1<<i)){
 				/*enable interrupts*/
 				nlm_hal_enable_vc_intr(node, vc_index);
@@ -1085,9 +1092,9 @@ void nlm_enable_vc_intr_9xx(void)
         for(cpu=0; cpu < NR_CPUS; cpu++){
                 if(!cpumask_test_cpu(cpu, &phys_cpu_present_map))
                         continue;
-                node = cpu / NLM_MAX_CPU_PER_NODE_9XX;
+                node = nlm_nodeid();
                 for(i = 0; i < NLM_MAX_VC_PER_THREAD_9XX; i++) {
-                        vc_index = (i + cpu * NLM_MAX_VC_PER_THREAD_9XX) & NLM_MAX_VC_MASK_9XX;
+			vc_index = (i + (cpu % NLM_MAX_CPU_PER_NODE_9XX)*NLM_MAX_VC_PER_THREAD_9XX);
                         if(nlm_cpu_vc_mask[cpu] & (1<<i)){
                                 /*enable interrupts*/
                                 nlm_hal_enable_vc_intr(node, vc_index);
@@ -1214,7 +1221,6 @@ static int xlp_napi_fmn_setup(void)
 	int weight_p = 300;
 
 	xlp_napi_vc_count = num_ones(xlp_napi_vc_mask);
-	printk("MSGRING_NAPI: Initializing NLM NAPI subsystem\n");
 
 	init_dummy_netdev(&xlp_napi_fmn_dummy_dev);
 
@@ -1262,7 +1268,6 @@ static int __init nlm_proc_setup(void)
         if (!nlm_root_proc)
                 return -ENOMEM;
 
-	pr_info("proc setup done\n");
         return 0;
 }
 
@@ -1314,7 +1319,7 @@ static void parse_fmn_config(void)
 void initialize_cpumask_new_9xx(int node, big_mask_t *onlinemask)
 {
 	onlinemask->map[node][0] = 0xffffffffffffffff;	/* 64 cpu */
-	onlinemask->map[node][1] = 0xffff;		/* 16 cpu */	
+	onlinemask->map[node][1] = 0xffff;		/* 16 cpu */
 }
 
 static void parse_fmn_config_9xx(void)
@@ -1423,7 +1428,6 @@ static void parse_fdt_sae_vc_config(void)
 
 		}
 	}
-	pr_info("parse fdt node %p\n", node);
 
 	return;
 }
@@ -1431,7 +1435,7 @@ static void parse_fdt_sae_vc_config(void)
 
 static long fmn_config(void *arg)
 {
-        pr_info("Doing fmn init from cpu %d for node %d fdt %p\n", hard_smp_processor_id(), (int)(long)arg, fdt);
+        pr_info("Doing fmn init from cpu %d for node %d\n", hard_smp_processor_id(), (int)(long)arg);
         nlm_hal_fmn_init(fdt, (int)(long)arg);
         return 0;
 }
@@ -1441,18 +1445,19 @@ static int __init nlm_fmn_init(void)
         int node, rv;
 	int node_exist[8] = {1, 0, 0, 0, 0, 0, 0, 0};
 	int max_nodes = NLM_MAX_NODES;
+	uint32_t fmn_owner_mask = 0;
 
 	if(is_nlm_xlp9xx())
 		max_nodes = NLM_MAX_CPU_NODE_9XX;
 
         /* Better to do node level fmn initialization */
-        if(get_dom_fmn_node_ownership(fdt, 0)) {
-                for(node = 0; node < max_nodes; node++) {
-                        if(!node_exist[node])
+	fmn_owner_mask = get_dom_fmn_node_ownership(fdt, 0);
+        if(fmn_owner_mask) {
+                for(node = 0; node < max_nodes; node++)
+		{
+			if(!(fmn_owner_mask & (1<<node)))
                                 continue;
-                        rv = work_on_cpu(node_exist[node] >> 16, fmn_config, (void *)(long)node);
-                        if(rv < 0)
-                                panic("Fmn init failed\n");
+			fmn_config((void *)(long)node);
                 }
         } else
                 printk("Skipping FMN initialization due to lack of ownership\n");
@@ -1487,7 +1492,6 @@ static int __init on_chip_init(void)
 		pr_err("Null FDT blob\n");
 		return -ENODEV;
 	}
-	pr_info("Init at %p\n", fdt);
 	fdt_init(fdt);
 
 	cpumask_clear(&phys_cpu_present_map);
@@ -1504,10 +1508,8 @@ static int __init on_chip_init(void)
 	else {
 		parse_fmn_config();
 	}
-	pr_info("parse done\n");
 
 	parse_fdt_sae_vc_config();
-	pr_info("parse vc done\n");
 
 	/* Set netlogic_io_base to the run time value */
 #ifdef CONFIG_XLP_FMN_SUPPORT
-- 
1.7.9.5

