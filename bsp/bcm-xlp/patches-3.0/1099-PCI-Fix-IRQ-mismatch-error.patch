From b72e9231d3d14d4353c6293b58fe1ee64cb67bb5 Mon Sep 17 00:00:00 2001
From: ajesh <ajesh@broadcom.com>
Date: Tue, 25 Mar 2014 16:23:24 +0530
Subject: [PATCH 099/163] PCI: Fix IRQ mismatch error.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/pci/pci-xlp.c |   14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 8548534..6172de8 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -345,7 +345,7 @@ int xlp_fixup_numa_node(struct device *dev)
 
 static void modify_def_value()
 {
-	uint64_t sysbase = nlm_get_sys_pcibase(0);
+	uint64_t sysbase = nlm_get_sys_regbase(0);
 	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
 	uint32_t pcfg = (sysreg >> 12) & 0x3;
 	uint64_t pciebase = nlm_get_pcie_base(0,0);
@@ -433,18 +433,24 @@ static irqreturn_t xlp_pcie_hot_reset_handler(int irq, void *dev_id)
 
 static int __init xlp_pci_hot_reset_init(void)
 {
-	uint64_t sysbase = nlm_get_sys_pcibase(0);
+	uint64_t sysbase = nlm_get_sys_regbase(0);
 	uint32_t sysreg = nlm_read_sys_reg(sysbase,SYS_POWER_ON_RESET_CFG);	
 	uint64_t pciebase = nlm_get_pcie_base(0,0);
 	uint64_t picbase, picreg;
 	uint32_t irq, pciintenable;
 
+	if(!(cpu_is_xlp2xx()))
+	  {
+		  pr_err("Hot Reset not handled\n");
+		  return 0;
+	  }
+	pr_info("Sysreg is 0x%x \n", sysreg);
 	if(((sysreg >> 8) & 0xf) & 0x1)
 	{
 		pr_err("PCIE in RC Mode \n");
 		return 0;
 	}
-
+	pr_info("PCIE in EP mode 0x%x\n", sysreg);
 	pciintenable = nlm_read_pci_reg(pciebase, PCIE_INT_EN1);
 	pciintenable |= 0x1;
 	nlm_write_pci_reg(pciebase,PCIE_INT_EN1, pciintenable);
@@ -462,7 +468,7 @@ static int __init xlp_pci_hot_reset_init(void)
 			pr_info("Could not register PCIe hot Reset interrupt handler \n");
 			return 0;
 		}
-	pr_err("PCIE in Mode 2\n");
+	//pr_err("PCIE in Mode 2\n");
 	return 0;
 }
 late_initcall(xlp_pci_hot_reset_init);
-- 
1.7.9.5

