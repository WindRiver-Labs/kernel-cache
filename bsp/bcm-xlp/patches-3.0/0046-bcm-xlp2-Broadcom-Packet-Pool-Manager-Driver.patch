From 95cb07e12d21bcb664c2ff5a80e01a71f64ad81c Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 14 Feb 2014 18:32:00 +0800
Subject: [PATCH 46/58] bcm-xlp2: Broadcom Packet Pool Manager Driver

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/netlogic/Kconfig                           |    7 +
 drivers/netlogic/pkt_pool_mem/Makefile             |    5 +
 .../netlogic/pkt_pool_mem/pkt_pool_kern_iface.h    |   17 +
 drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c       |  328 ++++++++++++++++++++
 4 files changed, 357 insertions(+)

diff --git a/drivers/netlogic/Kconfig b/drivers/netlogic/Kconfig
index 33527fb..b7438e7 100644
--- a/drivers/netlogic/Kconfig
+++ b/drivers/netlogic/Kconfig
@@ -59,3 +59,10 @@ config XLP_FMN_DP
         default y
         help
           This driver supports fmn data path.
+
+config XLP_PPM
+	tristate "Broadcom Packet Pool Manager"
+        depends on NLM_XLP_BOARD
+        default y
+	help
+          This driver supports Manage Packet Pool.
diff --git a/drivers/netlogic/pkt_pool_mem/Makefile b/drivers/netlogic/pkt_pool_mem/Makefile
new file mode 100644
index 0000000..96901e8
--- /dev/null
+++ b/drivers/netlogic/pkt_pool_mem/Makefile
@@ -0,0 +1,5 @@
+EXTRA_CFLAGS := -DCONFIG_XLP_FMN_SUPPORT -DNLM_HAL_LINUX_KERNEL
+EXTRA_CFLAGS += -Iarch/mips/netlogic/lib/libfdt
+
+obj-$(CONFIG_XLP_PPM) 	+= pktmem.o
+pktmem-objs	:= pkt_pool_mem.o
diff --git a/drivers/netlogic/pkt_pool_mem/pkt_pool_kern_iface.h b/drivers/netlogic/pkt_pool_mem/pkt_pool_kern_iface.h
new file mode 100644
index 0000000..395ff01
--- /dev/null
+++ b/drivers/netlogic/pkt_pool_mem/pkt_pool_kern_iface.h
@@ -0,0 +1,17 @@
+#ifndef __PKT_POOL_KERN_IFACE_H
+#define __PKT_POOL_KERN_IFACE_H
+
+typedef struct brcm_devmem_ioctl {
+	unsigned int node_id;
+	char shr_id[64];
+	unsigned long long phys_addr;
+	unsigned long long size;
+} brcm_devmem_ioctl_t;
+
+enum pktmem_ops {
+	ALLOC_POOL = 0,
+	FREE_POOL,
+	PRINT_POOL,
+};
+
+#endif
diff --git a/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c b/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c
new file mode 100644
index 0000000..bd257a3
--- /dev/null
+++ b/drivers/netlogic/pkt_pool_mem/pkt_pool_mem.c
@@ -0,0 +1,328 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include "libfdt.h"
+#include "pkt_pool_kern_iface.h"
+
+
+#define MAX_NODES 	8
+#define MB(x) 		(x*1024*1024)
+#define PKTMEM_MAJOR 	123
+static DEFINE_SPINLOCK(ioctl_lock);
+
+
+typedef struct memory_pool 
+{
+	struct memory_pool * next;
+	unsigned long long start;
+	unsigned long long size;
+	char shr_id[64];
+	int in_use;
+} memory_pool_t;
+
+static memory_pool_t mem_pool_data[MAX_NODES];
+
+#undef PKTMEM_DEBUG
+
+static int print_memory(brcm_devmem_ioctl_t * param)
+{
+	memory_pool_t *mem;
+	mem = &mem_pool_data[param->node_id];
+
+	printk("pktmem: printing for node %d.\n", param->node_id);
+	while (mem != NULL)
+	{
+		printk("pktmem: addr 0x%llx, size 0x%llx, shr_id %s, in_use %d.\n",
+				mem->start, mem->size, mem->shr_id, mem->in_use);
+		mem = mem->next;
+	}
+
+	return 0;
+}
+
+static int alloc_memory (brcm_devmem_ioctl_t * param)
+{
+	int alloc, align_len;
+	memory_pool_t *mem, *newmem;
+
+	/* take care of shared memory request first */
+	mem = &mem_pool_data[param->node_id];
+	alloc = 0;
+	if (param->shr_id != NULL)
+	{
+		if (param->size < 0x100000)
+		{
+			printk ("Packet allocation request should be > 1MB.\n");
+			return -1;
+		}
+		while (mem != NULL)
+		{
+			if (strcmp(param->shr_id,mem->shr_id) == 0)
+			{
+				param->phys_addr = mem->start;
+				alloc = 1;
+				break;
+			}
+			mem = mem->next;
+		}
+	}
+
+
+	if (alloc)
+		return 0;
+
+	mem = &mem_pool_data[param->node_id];
+	alloc = 0;
+
+	/*
+	 * Align the packet allocation to 64K page size.
+	 */
+	if((align_len = param->size % PAGE_SIZE) != 0)
+		param->size += (PAGE_SIZE - align_len) ;
+
+
+	while (mem != NULL)
+	{
+		if (mem->in_use == 0)
+		{
+			if (mem->size == param->size)
+			{
+				param->phys_addr = mem->start;
+				if (param->shr_id != NULL)
+					sprintf(mem->shr_id, param->shr_id);
+				else
+					memset(mem->shr_id, '\0', 64);
+				mem->in_use = 1;
+				alloc = 1;
+				break;
+			}
+
+			if (mem->size > param->size)
+			{
+				newmem = (memory_pool_t *) kmalloc(sizeof(memory_pool_t), GFP_KERNEL);
+
+				if (newmem == NULL)
+				{
+					printk ("pktmem: kmalloc failed.\n");
+					return -1;
+				}
+
+				newmem->next = NULL;
+				newmem->start = mem->start;
+				newmem->size = param->size;
+				if (param->shr_id != NULL)
+					sprintf(newmem->shr_id, param->shr_id);
+				else
+					memset(mem->shr_id, '\0', 64);
+				newmem->in_use = 1;
+
+				param->phys_addr = newmem->start;
+
+				mem->size -= param->size;
+				mem->start += param->size;
+
+				while (mem->next != NULL) {
+					mem = mem->next;
+				}
+				mem->next = newmem;
+				alloc = 1;
+			}
+
+
+		}
+
+		mem = mem->next;
+	}
+
+	if (alloc)
+		return 0;
+	else
+		return -1;
+}
+
+static int free_memory (brcm_devmem_ioctl_t * param)
+{
+	int free;
+	memory_pool_t *mem;
+
+	mem = &mem_pool_data[param->node_id];
+	free = 0;
+
+	while (mem != NULL)
+	{
+		if (param->phys_addr == mem->start)
+		{
+			memset(mem->shr_id, '\0', 64);
+			mem->in_use = 0;
+			free = 1;
+			break;
+		}
+		mem = mem->next;
+	}
+	
+	if (free)
+		return 0;
+	else
+		return -1;
+}
+
+static long pktmem_ioctl (struct file *fptr, unsigned int cmd, unsigned long dp)
+{
+	int rc;
+	brcm_devmem_ioctl_t *dptr, data;
+
+#ifdef PKTMEM_DEBUG
+	printk("pktmem: icoctl enter, cmd %d.\n", cmd);
+#endif
+	spin_lock(&ioctl_lock);
+	dptr = &data;
+	rc = 0;
+
+	copy_from_user(dptr, dp, sizeof(brcm_devmem_ioctl_t));
+
+#ifdef PKTMEM_DEBUG
+	printk("pktmem: memory map before\n");
+	print_memory(dptr);
+#endif
+
+	switch (cmd)
+	{
+		case ALLOC_POOL:
+			rc = alloc_memory(dptr);
+			break;
+		case FREE_POOL:
+			rc = free_memory(dptr);
+			break;
+		case PRINT_POOL:
+			rc = print_memory(dptr);
+			break;
+		default:
+			rc = -1;
+			break;
+	}
+
+#ifdef PKTMEM_DEBUG
+	printk("pktmem: memory map after\n");
+	print_memory(dptr);
+	printk("pktmem: ioctl returns rc %d.\n", rc);
+#endif
+
+	copy_to_user(dp, dptr, sizeof(brcm_devmem_ioctl_t));
+
+	spin_unlock(&ioctl_lock);
+	return rc;
+}
+
+static int pktmem_mmap(struct file *file_p, struct vm_area_struct *vm_p)
+{
+#if 0
+	/* make sure it is cacheable */
+	if ((pgprot_val(vm_p->vm_page_prot) & _CACHE_MASK) != _CACHE_CACHABLE_NONCOHERENT) {
+		printk("BUG: packet memory as uncached ...\n");
+		return -EPERM;
+	}
+#endif
+
+	if (remap_pfn_range(vm_p, vm_p->vm_start, vm_p->vm_pgoff,
+		vm_p->vm_end - vm_p->vm_start, vm_p->vm_page_prot))
+		return -EFAULT;
+
+	return 0;
+}
+
+static const struct file_operations pktmem_ops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = pktmem_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = pktmem_ioctl,
+#endif
+	.mmap = pktmem_mmap,
+};
+
+static inline int get_fdt_prop(void *fdt, const char* node_path,
+		const char *prop, void *prop_buf, int type)
+{
+	int prop_len;
+	const void *pbuf;
+	int node;
+
+	node = fdt_path_offset(fdt, node_path);
+	if (node < 0)
+		return -1;
+
+	pbuf = (char *)fdt_getprop(fdt, node, prop, &prop_len);
+	if (pbuf == NULL)
+		return -1;
+
+	memcpy((void *) prop_buf, (void * )pbuf, prop_len);
+
+	return 0;
+}
+
+extern void *initial_boot_params;
+
+/* see "pktmem" section in DTS file for providing memory */
+
+static int __init brcm_xlp_ppm_init (void)
+{
+	int i, node;
+	void *fdt;
+	uint32_t pktregs[MAX_NODES * 5];
+
+	i = register_chrdev(PKTMEM_MAJOR, "brcm_pktmem", &pktmem_ops);
+	if (i < 0)
+	{
+		printk(KERN_ERR "brcm_pktmem: unable to register %d", PKTMEM_MAJOR);
+		return i;
+	}
+
+	for (i=0; i<MAX_NODES*5; i++) pktregs[i] = 0;
+
+	/* read from FDT and fill the array */
+	fdt = initial_boot_params;
+	if (get_fdt_prop(fdt, "/pktmem", "reg", pktregs, 1) == 0)
+	{
+		for (i=0; i<MAX_NODES*5; i=i+5)
+		{
+			node = i/5;
+			mem_pool_data[node].next = NULL;
+			memset(mem_pool_data[node].shr_id, '\0', 64);
+			mem_pool_data[node].in_use = 0;
+			mem_pool_data[node].start = ((((unsigned long long)pktregs[i+1])<<32) | (pktregs[i+2]));
+			mem_pool_data[node].size = ((((unsigned long long)pktregs[i+3])<<32) | (pktregs[i+4]));
+		}
+	}
+	else
+	{
+		printk(KERN_ERR "brcm_pktmem: unable to read pktmem from DTB.\n");
+		return -1;
+	}
+
+
+	/* print the pktmem array */
+	for (i=0; i<MAX_NODES; i++)
+	{
+		printk("pktmem: node %d, addr 0x%llx size 0x%llx.\n",
+				i, mem_pool_data[i].start, mem_pool_data[i].size);
+	}
+
+	printk ("pktmem module init done.\n");
+	return 0;
+}
+
+static void __exit brcm_xlp_ppm_exit (void)
+{
+	printk (" brcm pkt mem module exit.\n");
+}
+
+module_init(brcm_xlp_ppm_init);
+module_exit(brcm_xlp_ppm_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("Packet Pool Manager");
+MODULE_LICENSE("Proprietary");
+MODULE_VERSION("0.1");
-- 
1.7.9.5

