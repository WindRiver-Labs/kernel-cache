From d894a9f8d60ddaa2c3d541f70e6e24d51ede8089 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 Feb 2014 15:27:45 +0800
Subject: [PATCH 55/58] bcm-xlp2: xlp gpio support

Based on SDK 3.0 (2013-10-29)

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/Kconfig       |    1 +
 drivers/gpio/Kconfig    |   13 ++
 drivers/gpio/Makefile   |    1 +
 drivers/gpio/gpio-xlp.c |  408 +++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 423 insertions(+)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index e53e2b4..bbb9a32 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -820,6 +820,7 @@ config NLM_XLP_BOARD
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
 	select 64BIT_PHYS_ADDR
+	select ARCH_REQUIRE_GPIOLIB
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 573c449..9801dda 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -238,6 +238,19 @@ config GPIO_XILINX
 	help
 	  Say yes here to support the Xilinx AXI/XPS GPIO device
 
+config GPIO_XLP
+	tristate "Netlogic XLP series GPIO support"
+	depends on CPU_XLP
+	default y
+	help
+	  Say yes here to support the Netlogic XLP GPIO device.
+	  This driver provides basic support (configure as input or output,
+	  read and write pin state) for GPIO interface on Netlogic XLP SoCs.
+
+	  If you have a Netlogic XLP platform say Y here.
+
+	  If unsure, say N.
+
 config GPIO_XILINX_PS
 	tristate "Xilinx GPIO PS"
 	depends on ARCH_ZYNQ
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 0cb2d65..2bab829 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -87,4 +87,5 @@ obj-$(CONFIG_GPIO_WM831X)	+= gpio-wm831x.o
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
 obj-$(CONFIG_GPIO_XILINX_PS)	+= gpio-xilinxps.o
+obj-$(CONFIG_GPIO_XLP)		+= gpio-xlp.o
diff --git a/drivers/gpio/gpio-xlp.c b/drivers/gpio/gpio-xlp.c
new file mode 100644
index 0000000..5c2fa10
--- /dev/null
+++ b/drivers/gpio/gpio-xlp.c
@@ -0,0 +1,408 @@
+/*
+ *  Copyright (C) 2003-2012 Broadcom Corporation
+ *  All Rights Reserved
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the Broadcom
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/spinlock.h>
+#include <linux/bitops.h>
+
+#include <asm-generic/bitops/non-atomic.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+
+#define GPIO_OUTPUT_EN		0x00
+#define GPIO_PADDRV		0x08
+#define GPIO_PADSMPL		0x10
+#define GPIO_INT_EN00		0x18
+#define GPIO_INT_EN10		0x20
+#define GPIO_INT_EN20		0x28
+#define GPIO_INT_EN30		0x30
+#define GPIO_INT_POL		0x38
+#define GPIO_INT_TYPE		0x40
+#define GPIO_INT_STAT		0x48
+
+#define GPIO_9XX_BYTESWAP	0X00
+#define GPIO_9XX_CTRL		0X04
+#define GPIO_9XX_OUTPUT_EN	0x14
+#define GPIO_9XX_PADDRV		0x24
+#define GPIO_9XX_PADSMPL	0x34
+/* Only for 4 interrupt enable reg are defined,
+ * total reg available are 12
+ */
+#define GPIO_9XX_INT_EN00	0x44
+#define GPIO_9XX_INT_EN10	0x54
+#define GPIO_9XX_INT_EN20	0x64
+#define GPIO_9XX_INT_EN30	0x74
+#define GPIO_9XX_INT_POL	0x104
+#define GPIO_9XX_INT_TYPE	0x114
+#define GPIO_9XX_INT_STAT	0x124
+
+#define GPIO_3XX_INT_EN00	0x18
+#define GPIO_3XX_INT_EN10	0x20
+#define GPIO_3XX_INT_EN20	0x28
+#define GPIO_3XX_INT_EN30	0x30
+#define GPIO_3XX_INT_POL	0x78
+#define GPIO_3XX_INT_TYPE	0x80
+#define GPIO_3XX_INT_STAT	0x88
+
+struct xlp_gpio_priv {
+	void __iomem *gpio_base;
+	int gpio_irq;
+	int ngpio;
+	DECLARE_BITMAP(gpio_enabled_mask, 66);
+	u32 intr_enable_reg;
+	u32 intr_status_reg;
+	u32 intr_type_reg;
+	u32 intr_polarity_reg;
+	u32 gpio_output_enbl;
+	u32 gpio_paddrv;
+	u32 gpio_padsmpl;
+	u32 prid;
+	struct irq_domain *domain;
+	spinlock_t spin_lock;
+};
+
+static inline u32 xlp_gpio_get_reg(struct xlp_gpio_priv *priv, int reg,
+		unsigned gpio)
+{
+	u32 pos, regset;
+
+	pos = gpio % 32;
+	regset = (gpio / 32) * 4;
+	return (readl(priv->gpio_base + regset) & BIT(pos)) != 0;
+}
+
+static inline void xlp_gpio_set_reg(struct xlp_gpio_priv *priv, int reg,
+		unsigned gpio, int state)
+{
+	u32 value, pos, regset;
+
+	pos = gpio % 32;
+	regset = (gpio / 32) * 4;
+	value = readl(priv->gpio_base + reg + regset);
+
+	if (state)
+		value |= BIT(pos);
+	else
+		value &= ~BIT(pos);
+
+	writel(value, (priv->gpio_base + reg + regset));
+}
+
+static void xlp_gpio_enable(struct irq_data *d)
+{
+	struct xlp_gpio_priv *priv = d->chip_data;
+	int g_pin = d->hwirq;
+	int intr_enable_reg = priv->intr_enable_reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->spin_lock, flags);
+	xlp_gpio_set_reg(priv, intr_enable_reg, g_pin, 1);
+	__set_bit(g_pin, priv->gpio_enabled_mask);
+	xlp_gpio_set_reg(priv, priv->intr_polarity_reg, g_pin, 1);
+	xlp_gpio_set_reg(priv, priv->intr_type_reg, g_pin, 0);
+	spin_unlock_irqrestore(&priv->spin_lock, flags);
+}
+
+static void xlp_gpio_disable(struct irq_data *d)
+{
+	struct xlp_gpio_priv *priv = d->chip_data;
+	int intr_enable_reg = priv->intr_enable_reg;
+	int g_pin = d->hwirq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->spin_lock, flags);
+	xlp_gpio_set_reg(priv, intr_enable_reg, g_pin, 0);
+	__clear_bit(g_pin, priv->gpio_enabled_mask);
+	spin_unlock_irqrestore(&priv->spin_lock, flags);
+}
+
+static void xlp_gpio_mask_ack(struct irq_data *d)
+{
+	struct xlp_gpio_priv *priv = d->chip_data;
+	int intr_enable_reg = priv->intr_enable_reg;
+	int g_pin = d->hwirq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->spin_lock, flags);
+	xlp_gpio_set_reg(priv, intr_enable_reg, g_pin, 0);
+	spin_unlock_irqrestore(&priv->spin_lock, flags);
+
+	xlp_gpio_set_reg(priv, priv->intr_status_reg, g_pin, 1);
+}
+
+static void xlp_gpio_unmask(struct irq_data *d)
+{
+	struct xlp_gpio_priv *priv = d->chip_data;
+	int intr_enable_reg = priv->intr_enable_reg;
+	int g_pin = d->hwirq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->spin_lock, flags);
+	xlp_gpio_set_reg(priv, intr_enable_reg, g_pin, 1);
+	spin_unlock_irqrestore(&priv->spin_lock, flags);
+}
+
+static struct irq_chip xlp_gpio_irq_chip = {
+	.name		= "XLP-GPIO",
+	.irq_enable	= xlp_gpio_enable,
+	.irq_disable	= xlp_gpio_disable,
+	.irq_mask_ack	= xlp_gpio_mask_ack,
+	.irq_unmask	= xlp_gpio_unmask,
+	.flags		= IRQCHIP_ONESHOT_SAFE,
+};
+
+irqreturn_t xlp_gpio_generic_handler(int irq, void *data)
+{
+	u64 irq_stat_hi, irq_stat_lo, gpio_online_stat;
+	struct xlp_gpio_priv *priv = data;
+	int irqoffset;
+
+	irq_stat_lo = readl(priv->gpio_base + priv->intr_status_reg);
+	irq_stat_hi = readl(priv->gpio_base + priv->intr_status_reg + 0x4);
+	/* Check first 64 pins */
+	gpio_online_stat = priv->gpio_enabled_mask[0] &
+		(((u64)irq_stat_hi << 32) | irq_stat_lo);
+
+	while (gpio_online_stat) {
+		irqoffset = fls64(gpio_online_stat) - 1;
+		generic_handle_irq(irq_find_mapping(priv->domain, irqoffset));
+		gpio_online_stat &= ~BIT(irqoffset);
+	}
+	/* XLP9xx has 66 pins, check last 2 pins */
+	if (priv->ngpio > 64) {
+		irq_stat_lo = readl(priv->gpio_base +
+				priv->intr_status_reg + 0x8);
+		gpio_online_stat = priv->gpio_enabled_mask[1] & irq_stat_lo;
+		while (gpio_online_stat) {
+			irqoffset = fls(gpio_online_stat) - 1;
+			generic_handle_irq(irq_find_mapping(priv->domain,
+						irqoffset + 64));
+			gpio_online_stat &= ~BIT(irqoffset);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int xlp_gpio_dir_output(struct gpio_chip *gc, unsigned gpio, int state)
+{
+	struct platform_device *pdev = to_platform_device(gc->dev);
+	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
+
+	BUG_ON(gpio >= gc->ngpio);
+	xlp_gpio_set_reg(priv, priv->gpio_output_enbl, gpio, state);
+	return 0;
+}
+
+static int xlp_gpio_dir_input(struct gpio_chip *gc, unsigned gpio)
+{
+	return 0;
+}
+
+static int xlp_gpio_get(struct gpio_chip *gc, unsigned gpio)
+{
+	struct platform_device *pdev = to_platform_device(gc->dev);
+	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
+
+	BUG_ON(gpio >= gc->ngpio);
+	return xlp_gpio_get_reg(priv, priv->gpio_padsmpl, gpio);
+}
+
+static void xlp_gpio_set(struct gpio_chip *gc, unsigned gpio, int state)
+{
+	struct platform_device *pdev = to_platform_device(gc->dev);
+	struct xlp_gpio_priv *priv = platform_get_drvdata(pdev);
+
+	BUG_ON(gpio >= gc->ngpio);
+	xlp_gpio_set_reg(priv, priv->gpio_paddrv, gpio, state);
+}
+
+static int xlp_gpio_probe(struct platform_device *pdev)
+{
+	struct gpio_chip *gc;
+	struct resource *iores;
+	struct xlp_gpio_priv *priv;
+	int irq_base, gpio_irq, g_pin, ret, rev, node;
+
+	iores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!iores)
+		return -ENODEV;
+
+	priv = devm_kzalloc(&pdev->dev,
+			sizeof(struct xlp_gpio_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	gc = devm_kzalloc(&pdev->dev, sizeof(struct gpio_chip), GFP_KERNEL);
+	if (!gc)
+		return -ENOMEM;
+
+	priv->gpio_base = devm_request_and_ioremap(&pdev->dev, iores);
+	if (!priv->gpio_base)
+		return -ENOMEM;
+
+	gpio_irq = platform_get_irq(pdev, 0);
+	if (gpio_irq < 0)
+		return gpio_irq;
+	node = gpio_irq * NLM_NR_NODES / NR_IRQS;
+
+	priv->prid = read_c0_prid() & 0xff00;
+	/* Set the no. of gpios according to the XLP chip */
+	switch (priv->prid) {
+	case PRID_IMP_NETLOGIC_XLP8XX:
+		gc->ngpio = 41;
+		priv->ngpio = gc->ngpio;
+		priv->gpio_output_enbl = GPIO_OUTPUT_EN;
+		priv->gpio_paddrv = GPIO_PADDRV;
+		priv->gpio_padsmpl = GPIO_PADSMPL;
+		priv->intr_status_reg = GPIO_INT_STAT;
+		priv->intr_type_reg = GPIO_INT_TYPE;
+		priv->intr_polarity_reg = GPIO_INT_POL;
+		priv->intr_enable_reg = GPIO_INT_EN00;
+		break;
+	case PRID_IMP_NETLOGIC_XLP2XX:
+	case PRID_IMP_NETLOGIC_XLP3XX:
+		rev = nlm_read_sys_reg(nlm_get_sys_regbase(0),
+					SYS_EFUSE_DEVICE_CFG_STATUS0);
+		gc->ngpio = (rev & 0xf0) ? 44 : 57;
+		priv->ngpio = gc->ngpio;
+		priv->gpio_output_enbl = GPIO_OUTPUT_EN;
+		priv->gpio_paddrv = GPIO_PADDRV;
+		priv->gpio_padsmpl = GPIO_PADSMPL;
+		priv->intr_status_reg = GPIO_3XX_INT_STAT;
+		priv->intr_type_reg = GPIO_3XX_INT_TYPE;
+		priv->intr_polarity_reg = GPIO_3XX_INT_POL;
+		priv->intr_enable_reg = GPIO_3XX_INT_EN00;
+		break;
+	case PRID_IMP_NETLOGIC_XLP9XX:
+		gc->ngpio = 66;
+		priv->ngpio = gc->ngpio;
+		priv->gpio_output_enbl = GPIO_9XX_OUTPUT_EN;
+		priv->gpio_paddrv = GPIO_9XX_PADDRV;
+		priv->gpio_padsmpl = GPIO_9XX_PADSMPL;
+		priv->intr_status_reg = GPIO_9XX_INT_STAT;
+		priv->intr_type_reg = GPIO_9XX_INT_TYPE;
+		priv->intr_polarity_reg = GPIO_9XX_INT_POL;
+		priv->intr_enable_reg = GPIO_9XX_INT_EN00;
+		break;
+	default:
+		dev_err(&pdev->dev, "Unknown Processor id %x!", priv->prid);
+		return -ENODEV;
+	}
+
+	gc->base = -1;
+	gc->dev = &pdev->dev;
+	gc->of_node = pdev->dev.of_node;
+	gc->direction_output = xlp_gpio_dir_output;
+	gc->direction_input = xlp_gpio_dir_input;
+	gc->set = xlp_gpio_set;
+	gc->get = xlp_gpio_get;
+	gc->owner = THIS_MODULE;
+
+	spin_lock_init(&priv->spin_lock);
+	pr_info("Node %d: registering %d XLP GPIOs\n", node, gc->ngpio);
+	if (gpiochip_add(gc) < 0)
+		return -EINVAL;
+
+	ret = devm_request_irq(&pdev->dev, gpio_irq, xlp_gpio_generic_handler,
+			0, pdev->name, priv);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot claim IRQ\n");
+		return ret;
+	}
+
+	irq_set_chip_data(gpio_irq, priv);
+
+	/* Map gpio irqs from NLM_GPIO_VEC_BASE + (node * node_base_irq) */
+	irq_base = irq_alloc_descs(-1,
+		nlm_irq_to_xirq(node, NLM_GPIO_VEC_BASE), gc->ngpio, 0);
+	if (irq_base < 0) {
+		dev_err(&pdev->dev, "Couldn't allocate IRQ numbers\n");
+		return -ENODEV;
+	}
+
+	priv->domain = irq_domain_add_legacy(pdev->dev.of_node,
+			gc->ngpio, irq_base, 0,
+			&irq_domain_simple_ops, NULL);
+
+	for (g_pin = 0; g_pin < gc->ngpio; g_pin++) {
+		irq_set_chip_and_handler(irq_base + g_pin, &xlp_gpio_irq_chip,
+				handle_level_irq);
+		irq_set_chip_data(irq_base + g_pin, priv);
+	}
+
+	/* This is used for find the gpio interrupt enable register
+	   offset, this has the gpio_pin to kernel_irq mapping.
+	   Now, all the interrupts are mapped to single interrupt
+	   irq(34), this shall be altered to map 32 gpio_irq to one
+	   irq and rest of gpio_irq to other irq. */
+	priv->gpio_irq = gpio_irq;
+
+	platform_set_drvdata(pdev, priv);
+	return 0;
+}
+
+static struct of_device_id xlp_gpio_dt_ids[] = {
+	{ .compatible = "netlogic,xlp-gpio" },
+};
+
+static struct platform_driver xlp_gpio_driver = {
+	.driver		= {
+		.name	= "xlp-gpio",
+		.owner	= THIS_MODULE,
+		.of_match_table = xlp_gpio_dt_ids,
+	},
+	.probe		= xlp_gpio_probe,
+};
+
+static int __init xlp_gpio_init(void)
+{
+	return platform_driver_register(&xlp_gpio_driver);
+}
+postcore_initcall(xlp_gpio_init);
+
+MODULE_AUTHOR("Kamlakant Patel <kamlakant.patel@broadcom.com>, Ganesan Ramalingam <ganesanr@broadcom.com");
+MODULE_DESCRIPTION("Netlogic XLP GPIO Driver");
+MODULE_LICENSE("GPL v2");
-- 
1.7.9.5

