From c37e994c98538e5cec86164df7df0f7e8768d746 Mon Sep 17 00:00:00 2001
From: Jayanthi A <jayanthi.annadurai@broadcom.com>
Date: Wed, 30 Oct 2013 15:29:56 -0700
Subject: [PATCH 026/160] fmnlib: Fixed xlp9xx nae and poe queue configuration

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Jack Tan <jiankemeng@gmail.com>
---
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h        |   14 +-
 arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c |  299 ++++++++++++++++----
 2 files changed, 262 insertions(+), 51 deletions(-)

diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
index e0729033..1d21ff8 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn.h
@@ -58,6 +58,9 @@
 #define POPQ_CLASS_CONFIG_OFFSET	8
 #define POPQ_MAX_CLASS_NUM		3	/* popq priority class: 0, 1, 2, 3 */
 
+#define XLP9XX_FMN_ONCHIP_PERQ		2048
+#define XLP_FMN_ONCHIP_PERQ		1024
+
 enum FMN_MSG_BLKS {
 	XLP_MSG_BLK_CPU = 0, 
 	XLP_MSG_BLK_POPQ, 
@@ -75,7 +78,12 @@ enum FMN_MSG_BLKS {
 	XLP_MSG_BLK_REGX,
 	XLP_MSG_BLK_SRIO,
 	XLP_MSG_BLK_LZS,
-	XLP_MSG_BLK_MAX
+	XLP_MSG_BLK_MAX = XLP_MSG_BLK_LZS + 1,
+
+	XLP_MSG_BLK_POE_1 = XLP_MSG_BLK_MAX,
+	XLP_MSG_BLK_NAE_1,
+        XLP_MSG_BLK_ALE,
+	XLP9XX_MSG_BLK_MAX
 };
 
 
@@ -121,7 +129,7 @@ struct fmn_qsize_credit_config
         int n_txstns; /* number of tranmit stations from this type, only used for credit warn */
         int valid;
         int q_size; /* queue size for this type */
-        unsigned int credits[NLM_MAX_NODES][XLP_MSG_BLK_MAX];
+        unsigned int credits[NLM_MAX_NODES][XLP9XX_MSG_BLK_MAX];
 };
 
 struct fmn_cfg {
@@ -130,7 +138,7 @@ struct fmn_cfg {
         uint32_t fmn_default_qsize;
         uint32_t fmn_default_credits;
         uint32_t max_msg_blk;
-        struct fmn_qsize_credit_config  fmn_q_config[XLP_MSG_BLK_MAX];
+        struct fmn_qsize_credit_config  fmn_q_config[XLP9XX_MSG_BLK_MAX];
         /* onchi mem */
         uint64_t q_ram_base;
         uint32_t q_ram_page_perq;
diff --git a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
index 7492dec..1f64e06 100644
--- a/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/lib/fmnlib/nlm_hal_fmn_config.c
@@ -224,7 +224,8 @@ nlm_fmn_config_t xlp9xx_fmn_config[] = {
 
 extern struct nlm_node_config nlm_node_cfg;
 
-/* #define FMN_DEBUG 1 */
+/* #define FMN_DEBUG 1  */
+static int max_msg_blks = XLP_MSG_BLK_MAX;
 
 static unsigned int fmn_cfg_value[XLP_NET_VC_LIMIT + 1];
 static unsigned int fmn_default_credits = XLP_FMN_DEFAULT_CREDITS;
@@ -232,8 +233,9 @@ static unsigned int fmn_default_qsize = XLP_FMN_DEFAULT_QUEUE_SIZE;
 static unsigned long long fmn_spill_mem_addr = XLP_FMNQ_SPILL_DEFAULT_MEM_ADDR;
 static unsigned long long fmn_spill_mem_size = XLP_FMNQ_SPILL_DEFAULT_MEM_SIZE;
 
+static int get_onchip_qsize(void *fdt, int node, int station);
 
-static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP_MSG_BLK_MAX] = {
+static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP9XX_MSG_BLK_MAX] = {
 	[XLP_MSG_BLK_CPU] =     { "cpu",    XLP_CPU0_VC_BASE,      XLP_CPU7_VC_LIMIT,      8, 1 },
 	[XLP_MSG_BLK_POPQ] =    { "popq",   XLP_POPQ_VC_BASE,      XLP_POPQ_VC_LIMIT,      0, 1 },
         [XLP_MSG_BLK_PCIE0] =    { "pcie0",   XLP_PCIE0_VC_BASE,     XLP_PCIE0_VC_LIMIT,     1, 1 },
@@ -250,8 +252,118 @@ static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP_MSG_BLK_MAX] = {
 	[XLP_MSG_BLK_REGX] =    { "regx",   XLP_3XX_REGEX_VC_BASE, XLP_3XX_REGEX_VC_LIMIT, 1, 1 },
 	[XLP_MSG_BLK_SRIO] =    { "srio",   XLP_3XX_SRIO_VC_BASE,  XLP_3XX_SRIO_VC_LIMIT,  1, 1 },
 	[XLP_MSG_BLK_LZS] =    { "lzs",   XLP_9XX_LZS_VC_BASE,  XLP_9XX_LZS_VC_LIMIT,  1, 1 },
+        [XLP_MSG_BLK_POE_1] =  { "poe1",    XLP_9XX_POE1_VC_BASE,   XLP_9XX_POE1_VC_LIMIT, 1, 1 },
+        [XLP_MSG_BLK_NAE_1] =  { "nae1",    XLP_9XX_NET1_VC_BASE,   XLP_9XX_NET1_VC_LIMIT, 1, 1 },
+	[XLP_MSG_BLK_ALE] =    { "ale",     XLP_9XX_ALE_VC_BASE,   XLP_9XX_ALE_VC_LIMIT, 1, 1 },
 };
 
+
+static int get_onchip_qsize(void *fdt, int node, int station)
+{
+	char prop_str[10];
+	int plen, nodeoffset;
+	char fmn_cfg_str[80];
+	uint32_t *pval;
+	uint32_t onchip_qsize;
+	struct fmn_qsize_credit_config *fmn_q_config;
+
+	if (station > max_msg_blks)
+		return -1;
+
+	fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+	sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[station].q_name);
+        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset < 0)
+		return -1;
+
+	pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"onchip-entries", &plen);
+	if(pval != NULL) {
+		onchip_qsize = fdt32_to_cpu(*(uint32_t *)pval);
+		if (is_nlm_xlp9xx()) {
+			if (onchip_qsize > XLP9XX_FMN_ONCHIP_PERQ)
+				return -1;
+		}
+		else {
+			if (onchip_qsize > XLP_FMN_ONCHIP_PERQ)
+				return -1;
+		}	
+		return onchip_qsize / 32;
+	}
+ 	return -1;
+}
+
+
+static int get_cpu_vc_mask(void *fdt, int node, int station)
+{
+        char prop_str[10];
+        int plen, nodeoffset;
+        char fmn_cfg_str[80];
+        uint32_t *pval;
+        uint32_t vc_mask = 0;
+        struct fmn_qsize_credit_config *fmn_q_config;
+
+        if ((station > max_msg_blks) || (station != XLP_MSG_BLK_CPU))
+                return 0;
+
+        fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[station].q_name);
+        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset < 0)
+                return 0;
+
+        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"cpu-vc-mask", &plen);
+        if(pval != NULL) {
+                vc_mask = fdt32_to_cpu(*(uint32_t *)pval);
+	}
+	return vc_mask;
+}
+
+
+static int get_num_naetx_queues(void *fdt, int node, int station)
+{
+        char prop_str[10];
+        int plen, nodeoffset;
+        char fmn_cfg_str[80];
+        uint32_t *pval;
+        int num_queues = -1;
+        struct fmn_qsize_credit_config *fmn_q_config;
+
+        if ((station > max_msg_blks) || ((station != XLP_MSG_BLK_NAE) && (station != XLP_MSG_BLK_NAE_1)))
+                return -1;
+
+        fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+        sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[station].q_name);
+        nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        if(nodeoffset < 0)
+                return -1;
+
+        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"num-tx-queues", &plen);
+        if(pval != NULL) {
+                num_queues = fdt32_to_cpu(*(uint32_t *)pval);
+        }
+        return num_queues;
+}
+
+
+static int get_fmn_dts_version(void *fdt, int node)
+{
+        char prop_str[10];
+        int plen, nodeoffset;
+        char fmn_cfg_str[80];
+        uint32_t *pval;
+
+	sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config", node);
+	nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+	if(nodeoffset < 0)
+                return -1;
+
+        pval = (uint32_t *)fdt_getprop(fdt, nodeoffset,"version", &plen);
+        if(pval != NULL) {
+		return (fdt32_to_cpu(*(uint32_t *)pval));
+	}
+	return 0;
+}
+
 int station_exist_in_2xx(int qid)
 {
 	int hndl;
@@ -469,7 +581,7 @@ static void fmn_update_credit(int node, int b_stid, int dst_node)
 		fmn_cfg_value[sid] = nlm_node_cfg.fmn_cfg[node]->fmn_default_credits;
 
 	/* Get credit config from the given source station to different destination station */
-	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+	for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
 		if(!fmn_q_config[s_stn].valid)
 			continue;
 		if(b_stid >=  fmn_q_config[s_stn].b_stid && 
@@ -486,8 +598,10 @@ static void fmn_update_credit(int node, int b_stid, int dst_node)
 		return;
 	}
 
-	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
-/*		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]); */
+	nlm_print("b_stid %d, dst_node %d.\n", b_stid, dst_node);
+
+	for(d_stn = 0; d_stn < max_msg_blks; d_stn++) {
+		nlm_print("update credit s_stn %d d_stn %d credits %d\n",s_stn, d_stn, credits[d_stn]); 
 		if(!fmn_q_config[d_stn].valid)
 			continue;
 		for(sid = fmn_q_config[d_stn].b_stid; sid <= fmn_q_config[d_stn].e_stid; sid++)
@@ -502,7 +616,6 @@ static int fmn_update_qsize(int node)
 	int sid, s_stn;
 	unsigned long long qsize;
 	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
-
 	
 	/* qsize cannot be more than 256KB and it should be aligned to 4K */
 	if((fmn_default_qsize % FMN_Q_PAGE_SIZE) != 0)
@@ -516,7 +629,7 @@ static int fmn_update_qsize(int node)
 	for(sid = 0; sid <= XLP_NET_VC_LIMIT; sid++)
 		fmn_cfg_value[sid] = fmn_default_qsize;
 
-	for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+	for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
 		if(!fmn_q_config[s_stn].valid)
 			continue;
 		for(sid = fmn_q_config[s_stn].b_stid; sid <= fmn_q_config[s_stn].e_stid; sid++) {
@@ -542,13 +655,13 @@ static void fmn_validate_credit(int node, int max_nodes)
 
 	
 	/* credits from all the source stations to this station */
-	for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+	for(d_stn = 0; d_stn < max_msg_blks; d_stn++) {
 		if(!fmn_q_config[d_stn].valid)
 			continue;
 		qsize = fmn_q_config[d_stn].q_size;
 		credits = 0;
 	        for(src_node = 0; src_node < max_nodes; src_node++) {
-  		    for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++)  {
+  		    for(s_stn = 0; s_stn < max_msg_blks; s_stn++)  {
 		 	if(!fmn_q_config[s_stn].valid)
 				continue;
 			credits += (fmn_q_config[s_stn].credits[src_node][d_stn] * fmn_q_config[s_stn].n_txstns);
@@ -802,27 +915,26 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 	volatile int index;
 	uint32_t credits, cfgrd;
 
+	if (!is_nlm_xlp9xx()) {
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_POE_1);
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_NAE_1);
+		fmn_invalidate_blocks(node, XLP_MSG_BLK_ALE);
+
+	}
+
 	if (is_nlm_xlp9xx()) {
 		/* XLP9XX / XLP7XX */
 		nlm_print(" XLP9XX/XLP7XX FMN credit configuration \n");
-		
 		/* 9xx does not have SRIO engine */
-		fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
 
 		fmn_config = &xlp9xx_fmn_config[0];
 
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 20, XLP_CPU0_VC_BASE, XLP_CPU19_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_GDX, 1, XLP_9XX_GDX0_VC_BASE, XLP_9XX_GDX0_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_REGX, 1, XLP_9XX_RGX_VC_BASE, XLP_9XX_RGX_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CMP, 1, XLP_9XX_CMP_VC_BASE, XLP_9XX_CMP_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_9XX_RSA_VC_BASE, XLP_9XX_RSA_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_9XX_SEC_VC_BASE, XLP_9XX_SEC_VC_LIMIT);
-
-
 		/* go through each valid station */
 		for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
 			int base_vc = fmn_config->base_vc;
-			if ( fmn_9xx_is_vc_valid(node, base_vc) )
+			if ((hndl == XLP_MSG_HANDLE_POPQ) || (hndl == XLP_MSG_HANDLE_INVALID))
+				continue;
+			if (fmn_9xx_is_vc_valid(node, base_vc) )
 			{
 				int station;
 
@@ -830,18 +942,16 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 				for(dst_node = 0 ;dst_node < max_nodes; dst_node++) {
 					fmn_update_credit(node, base_vc, dst_node);
 
+					nlm_print("Configuring credis from source %d  hndl %d \n", base_vc, hndl);
 					/* go through all valid stations and all valid vc's */
-					for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
-						qid = xlp9xx_fmn_config[station].base_vc;
-						if ( fmn_9xx_is_vc_valid(node, qid) == 0 ) continue;
-
-						for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+					for (qid = 0; qid <= XLP_9XX_POPQ_VC_LIMIT; qid++) {
 							/* FIXME: define/config fmn_cfg_value properly for XLP9XX */
-#if 1
 							credits = fmn_cfg_value[qid] - 1;
-#else
-							credits = 50;
+#ifdef FMN_DEBUG
+							if ((credits+1) != nlm_node_cfg.fmn_cfg[node]->fmn_default_credits)
+								nlm_print("Overriding credis from source %d qid %d credits %d \n", base_vc, qid, credits);
 #endif
+
 							nlh_write_cfg_reg64(xlp_fmn_base[node] + (1 << 14),
 								(0ULL << 42) /* type, credit value + 1 */
 								| (credits << 26) /* credit count */
@@ -854,7 +964,6 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 								| ((qid | (dst_node << 10)) << 13) /* destination */
 								| (base_vc | (node << 10)); /* source */
 				#endif
-						}
 					}
 				}
 			}
@@ -1024,10 +1133,10 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
  * For xlp9xx, each node has 1024 output queues, total 8 nodes.
  * So globally addressable qid's are 1024 * 8.
  ********************************************************************/
-int nlm_hal_setup_outq(int node, int max_nodes)
+int nlm_hal_setup_outq(void *fdt, int node, int max_nodes)
 {
-	uint32_t qid, max_qs = 0;
-	uint64_t val;
+	uint32_t qid, max_qs = 0, cpu_vc_mask;
+	uint64_t val, q_enable = 1ULL;
 
 	uint64_t spill_base = nlm_node_cfg.fmn_cfg[node]->fmn_spill_base; /*fmn_spill_mem_addr; */
 	uint32_t spill_size = nlm_node_cfg.fmn_cfg[node]->fmn_spill_size;
@@ -1039,7 +1148,9 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 	const int q_ram_pages = 1;
 	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
 	const uint32_t q_ram_page_entries_9xx = 64; /* entries, not bytes */
-	int cnt =0;
+	int cnt =0, oq_num32pages = 0, oq_num32pages_stn , num_valid_queues;
+	struct fmn_qsize_credit_config *fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
+	
 
 	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		max_qs = XLP_3XX_NET_VC_LIMIT;
@@ -1061,30 +1172,71 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 		/* XLP9XX / XLP7XX */
 		nlm_print(" XLP9XX/XLP7XX FMN output queue configuration \n");
 
-		for (station = 0; station < XLP_MSG_HANDLE_MAX; station++) {
-			qid = xlp9xx_fmn_config[station].base_vc;
+		for (station = 0; station < max_msg_blks; station++) {
+			qid = fmn_q_config[station].b_stid;
 			if ( fmn_9xx_is_vc_valid(node, qid) == 0 ) continue;
 
-			for (; qid <= xlp9xx_fmn_config[station].vc_limit; qid++) {
+			oq_num32pages = get_onchip_qsize(fdt, node, station);
+			if (oq_num32pages < 0)
+				oq_num32pages = 1;
+				
+			nlm_print("station %d oq_num32pages %d  base %d limit %d\n",station, oq_num32pages, qid, fmn_q_config[station].e_stid);
+			oq_num32pages_stn = oq_num32pages;
+
+			if ((station == XLP_MSG_BLK_NAE) || (station == XLP_MSG_BLK_NAE_1)) {
+				num_valid_queues = get_num_naetx_queues(fdt, node, station);
+				if (num_valid_queues < 0)
+					num_valid_queues = 64;
+			}
+		
+			for (; qid <= fmn_q_config[station].e_stid; qid++) {
+				q_enable = 1ULL;
+				if (station == XLP_MSG_BLK_CPU) {
+					cpu_vc_mask = get_cpu_vc_mask(fdt, node, station);
+					if ((cpu_vc_mask) && (oq_num32pages_stn > 1)) {
+						if (cpu_vc_mask & (1 << (qid%4))) {
+							oq_num32pages = oq_num32pages_stn;
+						}
+						else {
+							oq_num32pages = 1;
+						}
+					}	
+				}
+				else if ((station == XLP_MSG_BLK_NAE) && (qid >= (XLP_9XX_NET0_TX_VC_BASE + num_valid_queues)) && (qid < XLP_9XX_NET0_RX_VC_BASE)) {
+					q_enable = 0ULL;
+					fmn_cfg_value[qid] = 0;
+					oq_num32pages = 2;
+				}
+				else if ((station == XLP_MSG_BLK_NAE_1) && (qid >= (XLP_9XX_NET1_TX_VC_BASE + num_valid_queues)) && (qid < XLP_9XX_NET1_RX_VC_BASE) ) {
+					fmn_cfg_value[qid] = 0;
+					q_enable = 0ULL;
+					oq_num32pages = 2;
+				}
 				/* enable output queue and setup on-chip output queue */
-				val = 1ULL << 63; /* enable */
+				val = q_enable << 63; /* enable */
 
 				/* here, we are assuming that each page
 				   has 32 entries.  Hence, each outq is configured
 				   for 2 pages (or 64 entries) */
 
-				if((q_ram_start_page+ 2) > q_ram_page_entries_9xx) {
+				if((q_ram_start_page+ oq_num32pages) >= q_ram_page_entries_9xx) {
 					q_ram_base++;
 					q_ram_start_page = 0;
 				}
-				q_ram_end_page = q_ram_start_page +1;
+				if (q_ram_base == 32) {
+					nlm_print("Invalid FMN onchip queue configuration \n");
+					return -1;
+				}
+					
+				q_ram_end_page = q_ram_start_page + oq_num32pages - 1;
 
 				val |= (q_ram_base & 0x1f) <<12; /* [16:12] of q_ram_base */
 				val |= (q_ram_end_page & 0x3f)<<6; /* [11:6] of q_ram_base */
 				val |= (q_ram_start_page & 0x3f);  /* [5:0] of q_ram_base */
 
 #ifdef FMN_DEBUG
-				nlm_print("qid: %d, q_ram_base: %d, q_ram_start_page: %d, q_ram_end_page: %d.\n",
+				if (q_enable)
+					nlm_print("qid: %d, q_ram_base: %d, q_ram_start_page: %d, q_ram_end_page: %d.\n",
 						qid, (q_ram_base & 0x1f),
 						(q_ram_start_page & 0x3f),
 						(q_ram_end_page & 0x3f));
@@ -1097,7 +1249,7 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 				/* spills, maximum spill per VC: 64 * 4KB = 256KB,
 				 * In our configuration, each VC: 4KB
 				 */
-				if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+				if ((nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) && (fmn_cfg_value[qid])) {
 
 				val |= 1ULL << 62; /* enable spill */
 
@@ -1218,6 +1370,7 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 	return 0;
 }
 
+
 int parse_queue_config(void *fdt, int max_nodes)
 {
         int node = 0, src_node, s_stn, d_stn;
@@ -1228,9 +1381,10 @@ int parse_queue_config(void *fdt, int max_nodes)
 	struct fmn_qsize_credit_config *fmn_q_config;
 	uint32_t credits, qsize;
 
+
         for(node = 0 ;  node < max_nodes; node++) {
                 fmn_q_config = nlm_node_cfg.fmn_cfg[node]->fmn_q_config;
-                for(d_stn=0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+                for(d_stn=0; d_stn < max_msg_blks; d_stn++) {
 
                         sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s", node, fmn_q_config[d_stn].q_name);
                         nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
@@ -1247,18 +1401,38 @@ int parse_queue_config(void *fdt, int max_nodes)
                         nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
                         if(nodeoffset < 0)
                                 continue;
-
+			if (get_fmn_dts_version(fdt, node) != 0) {
+				for(src_node = 0; src_node < max_nodes; src_node++) {
+					sprintf(fmn_cfg_str, "/soc/fmn@node-%d/q-config/%s/credits-from/stn@node-%d", 
+						node, fmn_q_config[d_stn].q_name, src_node);
+					nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
+        	        	        if(nodeoffset < 0)
+                	        	        continue;
+					for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
+						sprintf(prop_str, "%s", fmn_q_config[s_stn].q_name);
+						pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, prop_str, &plen);
+						if(pval != NULL) {
+							credits = fdt32_to_cpu(*(unsigned int *)(pval));
+							nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn] = credits;
+#ifdef FMN_DEBUG
+                                                nlm_print("node %d station %s has %d credits to %d:Q %s\n", src_node, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].q_name, nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn], node, fmn_q_config[d_stn].q_name);
+#endif
+						}
+					}
+				}
+			}
+			else {
                 	/* get credits from this station to other stations */
 
                         for(src_node = 0; src_node < max_nodes; src_node++) {
                                 sprintf(prop_str, "node-%d", src_node);
                                 pval = (uint32_t *)fdt_getprop(fdt, nodeoffset, prop_str, &plen);
                                 if(pval != NULL) {
-                                        if ((plen / sizeof(uint32_t)) != XLP_MSG_BLK_MAX) {
+                                        if ((plen / sizeof(uint32_t)) != max_msg_blks) {
                                                 nlm_print("Invalid credit configuration in fdt \n");
                                                 while(1); 
                                         }
-                                        for(s_stn = 0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                        for(s_stn = 0; s_stn < max_msg_blks; s_stn++) {
                                                 credits = fdt32_to_cpu(*(unsigned int *)(pval + s_stn));
 						if (credits != 0)
 							nlm_node_cfg.fmn_cfg[src_node]->fmn_q_config[s_stn].credits[node][d_stn] = credits;
@@ -1269,6 +1443,7 @@ int parse_queue_config(void *fdt, int max_nodes)
 
                                 }
                         }
+			}
                 }
         }
 	return 0;
@@ -1286,6 +1461,7 @@ int parse_fdt_fmn_config(void *fdt)
 #endif
 	uint32_t qsize, credits, src_node, s_stn, d_stn;
 
+
 	sprintf(fmn_cfg_str,"/soc/nodes");
 	nodeoffset = fdt_path_offset(fdt, fmn_cfg_str);
         if(nodeoffset >= 0) {
@@ -1372,10 +1548,10 @@ int parse_fdt_fmn_config(void *fdt)
 
         for(node=0; node < max_nodes; node++) {
                 fmn_config = nlm_node_cfg.fmn_cfg[node];
-                for(d_stn = 0; d_stn < XLP_MSG_BLK_MAX; d_stn++) {
+                for(d_stn = 0; d_stn < max_msg_blks; d_stn++) {
                         fmn_config->fmn_q_config[d_stn].q_size = fmn_config->fmn_default_qsize;
                         for(src_node=0; src_node < max_nodes; src_node++) {
-                                for(s_stn=0; s_stn < XLP_MSG_BLK_MAX; s_stn++) {
+                                for(s_stn=0; s_stn < max_msg_blks; s_stn++) {
                                         fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn] = fmn_config->fmn_default_credits;
 #ifdef FMN_DEBUG
                                         nlm_print("%d:%s Q, credits given to node %d stn %s : %d\n", node, fmn_config->fmn_q_config[d_stn].q_name, src_node, fmn_config->fmn_q_config[s_stn].q_name, fmn_config->fmn_q_config[d_stn].credits[src_node][s_stn]);
@@ -1427,9 +1603,36 @@ void nlm_hal_fmn_init(void *fdt, int node)
 	int max_nodes;
 
 	nlm_print("*** Firmware Configuration of FMN ***\n");
+	nlm_fmn_config_t *fmn_config = NULL;
+
+
+        if (is_nlm_xlp9xx()) {
+		fmn_default_qsize = 0;
+                max_msg_blks = XLP9XX_MSG_BLK_MAX;
+	}
+        else
+                max_msg_blks = XLP_MSG_BLK_MAX;
 
 	max_nodes = parse_fdt_fmn_config(fdt);
 
+        if (is_nlm_xlp9xx()) {
+                /* 9xx does not have SRIO engine */
+                fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+
+                fmn_config = &xlp9xx_fmn_config[0];
+
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_POPQ, 0, XLP_9XX_POPQ_VC_BASE, XLP_9XX_POPQ_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 20, XLP_CPU0_VC_BASE, XLP_CPU19_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_GDX, 1, XLP_9XX_GDX0_VC_BASE, XLP_9XX_GDX0_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_REGX, 1, XLP_9XX_RGX_VC_BASE, XLP_9XX_RGX_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CMP, 1, XLP_9XX_CMP_VC_BASE, XLP_9XX_CMP_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_9XX_RSA_VC_BASE, XLP_9XX_RSA_VC_LIMIT);
+                fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_9XX_SEC_VC_BASE, XLP_9XX_SEC_VC_LIMIT);
+
+               fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_9XX_NET0_VC_BASE, XLP_9XX_NET0_VC_LIMIT);
+               fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_POE, 1, XLP_9XX_POE0_VC_BASE, XLP_9XX_POE0_VC_LIMIT);
+        }
+
 	update_fmn_config();
 
 	if (max_nodes < 0) {
@@ -1444,7 +1647,7 @@ void nlm_hal_fmn_init(void *fdt, int node)
 	/*fmn_qsize_credit_cfg_extract(fdt); */
 	/* verify out_q config 
 	 */
-	if(nlm_hal_setup_outq(node, max_nodes) < 0)
+	if(nlm_hal_setup_outq(fdt, node, max_nodes) < 0)
 		while(1);
 	nlm_hal_write_fmn_credit(node, max_nodes);
 }
-- 
1.7.9.5

